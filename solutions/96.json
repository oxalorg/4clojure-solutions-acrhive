[{"code": "(fn [x]\r\n  (letfn [(m [y]\r\n            (if (nil? y)\r\n              nil\r\n              [(first y)\r\n               (m (last y))\r\n               (m (second y))]))]\r\n    (= (second x) (m (last x)))))", "problem": 96, "user": "4da3e51330acd6ed10482a68"}, {"code": "(fn sym-tree? [t]\r\n  (let [[_ left right] t\r\n        tree-seq #(map first (tree-seq coll? %1 %2))\r\n        left (tree-seq rest left)\r\n        right (tree-seq (comp reverse rest) right)]\r\n    (= left right)))", "problem": 96, "user": "4dc7e8c6535d8a4b2fd74291"}, {"code": "(fn [[n x y]]\r\n  (letfn [(r [x] (if (sequential? x) (t x) x))\r\n          (t [[n x y]] [n (r y) (r x)])]\r\n    (= x (t y))))", "problem": 96, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn\r\n  [tree]\r\n  (let [mirror\r\n        (fn mirror\r\n          [subtree]\r\n          (when subtree\r\n            (list (nth subtree 0)\r\n                  (mirror (nth subtree 2))\r\n                  (mirror (nth subtree 1)))))]\r\n    (cond\r\n     (nil? tree) true\r\n     (and (coll? tree)\r\n          (= 3 (count tree))) (= (mirror (nth tree 1)) (nth tree 2))\r\n     true false)))", "problem": 96, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn [tree]\r\n  (letfn [(reverse-tree [t]\r\n            (if (coll? t)\r\n              [(first t) (reverse-tree (nth t 2)) (reverse-tree (nth t 1))]))]\r\n    (= tree (reverse-tree tree))))", "problem": 96, "user": "4dab218f30acd6ed15482a68"}, {"code": "(fn [[_ a b]]\r\n  (letfn [(m [a b]\r\n            (if (coll? a)\r\n              (let [[c d e] a, [f g h] b]\r\n                (and (= c f)\r\n                     (m d h)\r\n                     (m e g)))\r\n              (= a b)))]\r\n    (m a b)))", "problem": 96, "user": "4dbb1126535d1e037afb21b3"}, {"code": "(fn [[_ l r]]\r\n  (= l\r\n     ((fn f [[a b c]]\r\n  (if a [a (f c) (f b)]))\r\n      r)))", "problem": 96, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn [c] (#(= % (reverse %)) (flatten ((fn s [[x y z]] (if x [(s y) x (s z)])) c))))", "problem": 96, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn [x]\r\n  (letfn [(rtree [x]\r\n            (if (nil? x) x [(first x) (rtree (nth x 2)) (rtree (second x))]))]\r\n    (= (rtree (second x)) (nth x 2))))", "problem": 96, "user": "4dc1ee85535d020aff1edf91"}, {"code": "#(= %\n    ((fn f [[v l r :as n]]\n       (if n\n         [v (f r) (f l)]))\n     %))", "problem": 96, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn [[_ l r]]\r\n      (let [m (fn m [l r] (or (and (nil? l) (nil? r))\r\n\t\t\t\t(and (and (not (nil? l)) (not (nil? r)))\r\n\t\t\t\t     (let [[a b c] l\r\n\t\t\t\t\t   [x y z] r]\r\n\t\t\t\t\t  (and (= a x)\r\n\t\t\t\t\t       (m b z)\r\n\t\t\t\t\t       (m c y))))))]\r\n\t\t   (m l r)))", "problem": 96, "user": "4dcd818e535d5973398f929d"}, {"code": "(fn m \r\n ([t] (apply m (rest t)))\r\n ([l r]\r\n (cond (and l r) (and (= (first l) (first r))\r\n                       (m (nth l 1) (nth r 2)) \r\n                       (m (nth l 2) (nth r 1)))\r\n        true (= l r))))", "problem": 96, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(letfn [\r\n  (mirrored? [t1 t2]\r\n\t\t(if (or (nil? t1) (nil? t2))\r\n\t\t\t(= t1 t2)\r\n\t\t\t(let [[v1 l1 r1] t1, [v2 l2 r2] t2]\r\n\t\t\t\t(and (= v1 v2) (mirrored? l1 r2) (mirrored? r1 l2)))))]\r\n\t\t\t\t\r\n\t(fn symmetric? [t]\r\n\t\t(if (nil? t)\r\n\t\t\ttrue\r\n\t\t\t(let [[_ l r] t]\r\n\t\t\t\t(mirrored? l r)))))", "problem": 96, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "#(let[f(fn f[x](if x(let[[n l r]x][n(f r)(f l)])x))](= %(f %)))", "problem": 96, "user": "4dd4034a535dae65d5c462df"}, {"code": "#(let [makeSymetric\r\n  \r\n  (fn makeSymetric [arbre]\r\n   (cond\r\n  \t(nil? arbre) arbre\r\n\t\t(empty? arbre) arbre\r\n\t\t(= 1 (count arbre)) arbre\r\n\t\t(= 2 (count arbre)) arbre\r\n\t\t(= 3 (count arbre))\r\n\t\t\t(list (first arbre) (makeSymetric (last arbre)) (makeSymetric (second arbre)))\r\n\t\t ))\r\n  \r\n  ]\r\n\r\n(= (flatten (second %))\r\n\t(flatten (makeSymetric (last %)))\r\n\t)\r\n)", "problem": 96, "user": "4dadca03c9a9d6ed4199dc57"}, {"code": "(fn s [[_ [x l r]\r\n          [y i d]]]\r\n  (and (= x y)\r\n       (or (= nil l i)\r\n           (and\r\n            (s [_ l d])\r\n            (s [_ r i])))))", "problem": 96, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn [tree]\r\n  (letfn [(meq [ta tb]\r\n            (cond (and (nil? ta) (nil? tb)) true\r\n                  (or (nil? ta) (nil? tb)) false\r\n                  true (let [[va la ra] ta [vb lb rb] tb]\r\n                         (and (= va vb) (meq la rb) (meq ra lb)))))]\r\n    (or (nil? tree)\r\n        (let [[v l r] tree] (meq l r)))))", "problem": 96, "user": "4ddc1c89535d02782fcbea01"}, {"code": "(fn sym-tree [tree]\r\n  (letfn [(sym-eq [ltree mtree]\r\n  \t  (cond (not (and (sequential? ltree) (sequential? mtree))) false\r\n\t\t\t(= (first ltree) (first mtree))\r\n\t\t\t(let [lltree (first (rest ltree))\r\n\t\t\t      lrtree (second (rest ltree))\r\n\t\t\t      mltree (second (rest mtree))\r\n\t\t\t      mrtree (first (rest mtree))]\r\n\t\t\t  (cond (and (nil? lltree) (nil? lrtree) (nil? mltree) (nil? mrtree))\r\n\t\t\t\ttrue\r\n\t\t\t\t(and (nil? lltree) (nil? mltree))\r\n\t\t\t\t(sym-eq lrtree mrtree)\r\n\t\t\t\t(and (nil? lrtree) (nil? mrtree))\r\n\t\t\t\t(sym-eq lltree mltree)\r\n\t\t\t\t:else (and (sym-eq lltree mltree)\r\n\t\t\t\t\t   (sym-eq lrtree mrtree))))\r\n\t\t\t:else\r\n\t\t\tfalse))\r\n\t  ]\r\n    (sym-eq (first (rest tree))(second (rest tree)))))", "problem": 96, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn [i-tree]\r\n     (let [\r\n           [left right] (rest i-tree)\r\n           is-node #(and (not (coll? %)) (not (false? %)))\r\n           reflect (fn mirror [my-tree]\r\n                       (let [[root left right] my-tree]\r\n                         (cons root\r\n                               (concat (vector (if (is-node right) right (mirror right)))\r\n                                       (vector (if (is-node left) left (mirror left)))))))\r\n           ]\r\n       (= left (reflect right))))", "problem": 96, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn [n]\r\n  (letfn ((f [t]\r\n               (if (coll? t)\r\n                 (cond (= (count t) 1)\r\n                       `(~(first t))\r\n                       (= (count t) 2)\r\n                       `(~(first t) ~(f (nth t 1)))\r\n                       :else\r\n                       `(~(first t) ~(f (nth t 2)) ~(f (nth t 1))))\r\n                 t)))\r\n         (let [l (nth n 1)\r\n               r (f (nth n 2))]\r\n           (= l r))))", "problem": 96, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn sym? [[v [av al ar :as a] [bv bl br :as b] :as t]]\r\n  (if (and (nil? a) (nil? b))\r\n    true\r\n    (and (= av bv)\r\n         (sym? [nil al br])\r\n         (sym? [nil ar bl]))))", "problem": 96, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn [t]\r\n    (letfn [(tseq [t]\r\n                  (when t\r\n                    (concat (tseq (second t))\r\n                            [(first t)]\r\n                            (tseq (first (next (next t)))))))]\r\n      (= (reverse (tseq (second t)))\r\n         (tseq (first (next (next t)))))))", "problem": 96, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn [t]\r\n  ((fn m [l r]\r\n     (if (or (= nil l r)\r\n             (and (= (first l) (first r))\r\n                  (m (second l) (last r))\r\n                  (m (last l) (second r))))\r\n       true false)) \r\n   (second t) (last t)))", "problem": 96, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn [t]     \n  (let [nodelist (fn [t l r]\n\t\t\t\t\t\t(loop [nodes [] rem [t]]\n\t\t\t\t\t\t\t(if (empty? rem)\n\t\t\t\t\t\t\t\tnodes\n\t\t\t\t\t\t\t\t(if-let [cur (first rem)]\n\t\t\t\t\t\t\t\t\t(recur (conj nodes (nth cur 0)) (conj (rest rem) (nth cur l) (nth cur r)))\n\t\t\t\t\t\t\t\t\t(recur nodes (rest rem))))))]\n\t\t(= (nodelist (nth t 1) 1 2) (nodelist (nth t 2) 2 1))))", "problem": 96, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [x]\r\n   (let [mirrored (fn mirrored [t]\r\n                    (if (sequential? t)\r\n                      (let [h (first t)\r\n                            l (second t)\r\n                            r (nth t 2)]\r\n                        [h (mirrored r) (mirrored l)])\r\n                      t))   \r\n         l (second x)   \r\n         r (nth x 2)] \r\n     (= l (mirrored r))))", "problem": 96, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn symmetric? [t]\r\n    (letfn [\r\n\t\t\t(binary-tree? [t]\r\n\t\t\t\t(if (coll? t)\r\n\t\t\t\t\t(if (= 3 (count t))\r\n\t\t\t\t\t   (if-let [[val left right] t]\r\n\t\t\t\t\t\t   (and (or (nil? left)  (binary-tree? left))\r\n\t\t\t\t\t\t        (or (nil? right) (binary-tree? right))))\r\n\t\t\t\t\t   false)\r\n\t\t\t\t\tfalse))\t\t\r\n\t\t  (step [left right]\r\n\t\t\t  (if (and (nil? left) (nil? right))\r\n\t\t\t    true\r\n\t \t      (if (and\r\n\t\t\t      (= (first left) (first right))\r\n\t\t        (step (second left) (last right))\r\n\t\t        (step (last left)   (second right)))\r\n\t\t\t\t    true\r\n\t\t\t\t    false)))]\r\n\t\t\t(if (binary-tree? t)\r\n\t\t\t  (step (second t) (last t))\r\n\t\t\t  false)))", "problem": 96, "user": "4dd52e29535dae65d5c462e5"}, {"code": "(fn m [[_ [i j k] [x y z]]]\n      (or\n        (not i)\n        (and\n          (= i x)\n          (m [0 j z])\n          (m [0 k y]))))", "problem": 96, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn symmetry? [t]\r\n  (letfn [(symmove [t]\r\n            (if-not (nil? t)\r\n              (let [[x l r] t]\r\n                [x (symmove r) (symmove l)])))]\r\n    (= t (symmove t))))", "problem": 96, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn [raw]\r\n  (let [tstruct (create-struct :key :left :right)\r\n      make-tree (fn mt\r\n                  ([] (mt '(1 (4 nil (2 nil nil)) (3 nil nil))))\r\n                  ([ts]\r\n                     (when ts\r\n                       (struct-map tstruct\r\n                         :key (first ts)\r\n                         :left (mt (second ts))\r\n                         :right (mt (second (next ts)))))))\r\n      gvt        (fn gvt\r\n                   ([xs change]\r\n                      (when xs\r\n                        (list\r\n                         (:key xs)\r\n                         (if-not change\r\n                           (gvt (:left xs) change)\r\n                           (gvt (:right xs) change))\r\n                         (if-not change\r\n                           (gvt (:right xs) change)\r\n                           (gvt (:left xs) change))))))\r\n\r\n      filter-    (fn [xs] (filter\r\n                           (complement nil?)\r\n                           (flatten xs)))]\r\n\r\n\r\n  (=\r\n   (gvt (:right (make-tree raw)) true)\r\n   (gvt (:left (make-tree raw)) false))))", "problem": 96, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "#(let[\n     v (fn v [n]\n         (if (seq n)\n           (let [ [f s l] n]\n              [(v s) f (v l)])))\n     f  (flatten (v %)) ]\n  (= f (reverse f)))", "problem": 96, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [t]\r\n  ((fn mir? [l r]\r\n     (if (or (= nil l r)\r\n             (and (= (first l) (first r))\r\n                  (mir? (second l) (last r))\r\n                  (mir? (last l) (second r))))\r\n       true false)) \r\n   (second t) (last t)))", "problem": 96, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn is_tree_equal [[top xs ys]]\r\n  (if (and (nil? xs) (nil? ys))\r\n    true\r\n    (if (or (nil? xs) (nil? ys))\r\n      false\r\n      (and (= (first xs) (first ys))\r\n           (is_tree_equal [nil (nth xs 1) (nth ys 2)])\r\n           (is_tree_equal [nil (nth xs 2) (nth ys 1)])))))", "problem": 96, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn f\r\n  ([[a b c]] (f b c))\r\n  ([b c]\r\n   (if (every? coll? [b c])\r\n       (let [[g h i] b [j k l] c]\r\n         (and (= g j) (f h l) (f i k)))\r\n       (= b c))))", "problem": 96, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn [[v l r]] \r\n  (letfn [(mirror? [[v1 l1 r1 :as t1] [v2 l2 r2 :as t2]]\r\n    (if (and (nil? t1) (nil? t2))\r\n       true\r\n       (and (= v1 v2) (mirror? l1 r2) (mirror? l2 r1))))]\r\n          (mirror? l r)))", "problem": 96, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn symm\n  ([x] (or (nil? x) (symm (nth x 1) (nth x 2))))\n  ([x y]\n    (cond\n      (and (nil? x) (nil? y)) true\n      (nil? x) false\n      (nil? y) false\n      (not (= (first x) (first y))) false\n      true (and (symm (nth x 1) (nth y 2))\n                (symm (nth x 2) (nth y 1))))))", "problem": 96, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn symm? [t]\n  (letfn [(mirr [n]\n            (let [[v l r] n]\n              [v\n               (if (sequential? r) (mirr r) r)\n               (if (sequential? l) (mirr l) l)]))]\n    (let [[v l r] t]\n      (= l (mirr r)))))", "problem": 96, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn bs [t]\n  (letfn [(testbs [l r]\n                  (if (and (coll? l) (coll? r))\n                    (let [[vl ll lr] l [vr rl rr] r]\n                      (if (and (= vl vr) (testbs lr rl) (testbs ll rr))\n                        true\n                        false))\n                    (if (= l r)\n                      true\n                      false)))]\n    (if (coll? t)\n      (testbs (first (rest t)) (first (rest (rest t))))\n      true)))", "problem": 96, "user": "4e1b2cd9535d04ed9115e7fd"}, {"code": "(fn symmetry\n  ([tree]\n    (symmetry (second tree) (last tree)))\n  ([left right]\n    (or (= nil left right)\n            (and (not (sequential? right))\n                 (not (sequential? left))\n                 (= left right))\n            (and (= (first left) (first right))\n                 (symmetry (second left) (last right))\n                 (symmetry (last left) (second right))))))", "problem": 96, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [[_ a b]]\n  (= a ((fn m [[_ l r]] (and _ [_ (m r) (m l)])) b))\n)", "problem": 96, "user": "4e307313535deb9a81d77f14"}, {"code": "#(= % ((fn f [[n l r :as in]]\r\n       (if (not= nil in) [n (f r) (f l)]))%))", "problem": 96, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn tree-diff [tree]\r\n  (letfn [(s [t r] (map first(tree-seq #(some identity (rest %))\r\n  \t\t     #((if r reverse identity)\r\n\t\t\t\t(filter identity (rest %)))\r\n\t\t\t      t)))]\r\n    (= (s (nth tree 1) false) (s (nth tree 2) true))))", "problem": 96, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [[_ a b]]\n  ((fn c [l r]\n            (if (and (coll? l) (coll? r))\n              (and  (= (nth l 0) (nth r 0))\n                (c (nth l 1) (nth r 2)) \n                (c (nth r 1) (nth l 2)))\n            (= l r))) a b))", "problem": 96, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [t]\n  (letfn [(mirror [t]\n            (if (sequential? t)\n              (list (first t) (mirror (first (next (next t)))) (mirror (second t)))\n              t))]\n    (and (sequential? t)\n         (= (mirror (second t)) (first (next (next t)))))))", "problem": 96, "user": "4e52d815535d302ef430da77"}, {"code": "#(letfn [(f [c] (if (coll? c)\n                  [(% c) (f (%2 c)) (f (%3 c))]\n                  c))]\n  (= (%3 %4) (f (%2 %4))))\nfirst last second", "problem": 96, "user": "4e49badd535dc968683fc4c9"}, {"code": "(letfn [(symm=? [t1 t2]\n          (cond\n            (and (nil? t1) (nil? t2)) true\n            (nil? t1) false\n            (nil? t2) false\n            :else (let [[v1 l1 r1] t1\n                        [v2 l2 r2] t2]\n                    (and (= v1 v2)\n                          (symm=? l1 r2)\n                          (symm=? r1 l2)))))]\n  #(or (nil? %)\n    (let [[v l r] %]\n      (symm=? l r))))", "problem": 96, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "#(= % ((fn m [t] (when-let [[v l r] t] [v (m r) (m l)])) %))", "problem": 96, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn [x]\n  (let [\n        tree-rev \n        (fn tr [y] (if (= y nil) y\n              (let [d1 (nth y 1) d2 (nth y 2)] (list (first y) (tr d2) (tr d1)))))\n        ]\n        (= (tree-rev x)  (-> x tree-rev tree-rev))))", "problem": 96, "user": "4e4b911f535dc968683fc4d6"}, {"code": "(fn symmetric? [coll]\n  (letfn [(reverse-branch [coll]\n            (let [[n l r] coll]\n              (vector n\n                      (if (coll? r)\n                        (reverse-branch r)\n                        r)\n                      (if (coll? l)\n                        (reverse-branch l)\n                        l))))]\n    (let [[n l r] coll]\n        (= l (reverse-branch r)))))", "problem": 96, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))", "problem": 96, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn[a-seq]\n  (letfn [\n     (trav[a-seq order at]\n        (swap! at conj (if (first a-seq) (first a-seq) 'nil))\n        (when a-seq\n          (let [fst (nth a-seq (first order))\n                snd (nth a-seq (second order))]\n            (trav fst order at)\n            (trav snd order at))))]\n    (let [at (atom [])\n          r (do (trav a-seq [1 2] at) @at)\n          l (do (reset! at []) (trav a-seq [2 1] at) @at)]\n      (= r l))))", "problem": 96, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "#(\n  letfn [\n    (r [v] \n      (if (nil? v) \n        v\n        (let [[a b c] v] \n          [a (r c) (r b)])))]\n    (= % (r %)))", "problem": 96, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn btree\r\n  ([x] (if (coll? x) (btree (fnext x) (last x))))\r\n  ([left right] (if (and (coll? left) (coll? right) (= (first left) (first right)) \r\n                      )\r\n                      (and (btree (fnext left) (last right)) (btree (last left) (fnext right) ))\r\n                      (= left right)\r\n                      )\r\n\r\n\r\n                  ))", "problem": 96, "user": "4e44358f535dc968683fc4a8"}, {"code": "(fn [tree]\n  (let [mirror (fn this [[v l r]]\n                [v (when r (this r)) (when l (this l))])\n        [v l r] tree]\n    (= l (mirror r))))", "problem": 96, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn f [tree]\n  (letfn [(g [t1 t2]\n            (or (= nil t1 t2)\n                (and (= (first t1) (first t2))\n                        (g (second t1) (last t2))\n                        (g (last t1) (second t2)))))]\n    (g (second tree) (last tree))))", "problem": 96, "user": "4e68dbd5535d8ccf87e9fe8f"}, {"code": "(fn mirror-image? [tree]\n        (let [mirror (fn mirror [tree]\n                       (if (seq tree)\n                         [(first tree) (mirror (nth tree 2)) (mirror (nth tree 1))]\n                         tree))]\n          (= (mirror (nth tree 2)) (nth tree 1))))", "problem": 96, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(letfn [(r [[a b c :as u] [d e f :as v]]\n      (or (= nil u v)\n          (and (= a d) (r b f) (r c e))))]\n  #(apply r (rest %)))", "problem": 96, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn sym [a] \n  (= ((fn mirror [b] \n    (if (not (sequential? b)) b\n(list (first b) (mirror (nth b 2)) (mirror (second b))))) (second a)) (nth a 2)))", "problem": 96, "user": "4e6e6630535d5021c1a89609"}, {"code": "(letfn [(revtree [node]\n          (if-let [[v l r] node]\n            [v (revtree r) (revtree l)]))]\n  #(= (revtree %) %))", "problem": 96, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn t [a] \r\n  (letfn [\r\n  \t      (v [t] (if (t? t) (nth t 0) t))\r\n\t\t      (l [t] (nth t 1))\r\n\t\t      (r [t] (nth t 2))\r\n\t\t      (t? [t] (coll? t))\r\n\t\t      (le? [t] (not (t? t)))\r\n          (teq [tr tl]\r\n\t\t\t\t    (and\r\n\t\t\t\t      (= (v tr) (v tl))\r\n\t\t\t\t      (or\r\n\t\t\t\t        (and\r\n\t\t\t\t          (le? tr)\r\n\t\t\t\t          (le? tl))\r\n\t\t\t\t        (and\r\n\t\t\t\t          (teq (l tr) (r tl))\r\n\t\t\t\t          (teq (r tr) (l tl)))\r\n\t\t\t\t    )))]\r\n  (teq (r a) (l a))\r\n))", "problem": 96, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn symm? [t]\n  (letfn [(mirror? [a b]\n    (if (and (nil? a) (nil? b)) true\n     (if (= (first a) (first b))\n       (let [[aa ab] (rest a)\n             [ba bb] (rest b)]\n         (and (mirror? aa bb) (mirror? ab ba))))))]\n  (let [[a b] (rest t)] (if (mirror? a b) true false))))", "problem": 96, "user": "4db1bfe21254ad5b4805fa71"}, {"code": "(fn [t] (let [mirror (fn mirror [t] (if (nil? t) nil\n  \t\t\t       [(nth t 0) (mirror (nth t 2)) (mirror (nth t 1))]))]\n\t\t   (= t (mirror t))))", "problem": 96, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn sym-tree? [t]\n  (let [left (tree-seq (constantly true)\n                       (fn [n] (remove nil? [(nth n 1) (nth n 2)]))\n                       (nth t 1))\n        right (tree-seq (constantly true)\n                        (fn [n] (remove nil? [(nth n 2) (nth n 1)]))\n                        (nth t 2))]\n    (->> (map #(= (first %1) (first %2)) left right)\n         (every? identity))))", "problem": 96, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn f\n          ([t](f (second t) (last t)))\n          ([t u](or\n                 (and (nil? t) (nil? u))\n                 (and\n                  (= (first t) (first u))\n                  (f (second t) (last u))\n                  (f (last t) (second u))\n                  )\n                 )\n\n             )\n          )", "problem": 96, "user": "4e6df3c9535d5021c1a895fa"}, {"code": "(fn m \n  ([[a b c]]\n   (m b c))\n  ([[a b c] [d e f]]\n   (if (nil? a) (nil? d)\n       (and (= a d)\n            (m b f)\n            (m c e)))))", "problem": 96, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [tree]\n  (let [[v left right] tree\n        reverse-tree (fn rev [tree] \n                       (when-let [[v left right] tree]\n                        (list \n                          v (when right (rev right))\n                            (when left  (rev left)))))]\n     (= left (reverse-tree right))))", "problem": 96, "user": "4e593dac535d8a8b8723a29c"}, {"code": "#((fn e [a b] (if (or (nil? a) (nil? b)) (and (nil? a) (nil? b))\n (and (= (nth a 0) (nth b 0)) (e (nth a 1) (nth b 2)) (e (nth b 1) (nth a 2))))) % %)", "problem": 96, "user": "4e7e55ab535db169f9c79711"}, {"code": "(fn[x](= (map first (rest (tree-seq coll? rest x))) (map first (rest(tree-seq coll? #(butlast (reverse %)) x)))))", "problem": 96, "user": "4e7eff9e535db966e863cc38"}, {"code": "(fn [root]\n  (letfn [(symmetric-children? [left right]\n            (or (and (nil? left) (nil? right))\n                (and left right\n                     (= (first left) (first right))\n                     (symmetric-children? (nth left 1) (nth right 2))\n                     (symmetric-children? (nth left 2) (nth right 1)))\n                false))]\n    (symmetric-children? (nth root 1) (nth root 2))))", "problem": 96, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [tt] (= tt ((fn mirror [t] (if (coll? t) (list (first t) (mirror (nth t 2)) (mirror (nth t 1))) t)) tt)))", "problem": 96, "user": "4e7f4147535db966e863cc3d"}, {"code": "#(letfn [(mirror [t] \n      (let [[v l r] t]\n        (cond (and (seq l) (seq r)) (vector v (mirror r) (mirror l))\n              (seq l) (vector v r (mirror l))\n              (seq r) (vector v (mirror r) l)\n              :else [v nil nil])))]\n     (= (nth % 1) (mirror (nth % 2))))", "problem": 96, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn symmetric?\n  [t]\n  (let [mirrors? (fn [t1 t2]\n                   (= (map first (tree-seq (comp not nil?) rest t1))\n                      (map first (tree-seq (comp not nil?) (comp reverse rest) t2))))]\n    (mirrors? (first (rest t)) (first (rest (rest t))))))", "problem": 96, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(letfn [\n\n(mirror [lst]\n (if (not (coll? lst)) lst\n  (list (first lst) (mirror (nth lst 2)) (mirror (second lst)\n)))) ]\n\n(fn [lst] (= lst (mirror lst))))", "problem": 96, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn [mt]\n    (\n    (fn ogl? [l d]\n        (if \n            (or (= nil l d)\n                (and (= (first l) (first d))\n                     (ogl? (second l) (last d))\n                     (ogl? (last l) (second d))\n                )\n            ) true false\n        )\n    )\n    \n    (second mt) (last mt)\n    )        \n)", "problem": 96, "user": "4e78dc98535db95036265724"}, {"code": "(fn [[_ A B]]\n  (= A ((fn f [x]\n          (when-let [[v a b] x] [v (f b) (f a)]))\n        B)))", "problem": 96, "user": "4e7dfab0535db169f9c796f9"}, {"code": "(fn [[_ a b]]\r\n  ((fn m [[c d e] [f g h]]\r\n     (if c\r\n       (and (= c f) (m d h) (m e g))\r\n       true))\r\n     a b))", "problem": 96, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn t? [[_ a b]]\n  (or (and (nil? a) (nil? b))\n      (and (= (first a) (first b))\n           (t? [nil (fnext a) (last b)])\n           (t? [nil (last a) (fnext b)]))))", "problem": 96, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn is-sym?\n\n    ([t]\n       (is-sym? (second t) (last t))\n       )\n\n    ([l r]\n\n       (and\n        (= (first l) (first r))\n        (or\n         (and (nil? (second l)) (nil? (second r)))\n          (is-sym? (second l) (last r)))\n        (or\n         (and (nil? (last l)) (nil? (last r)))\n          (is-sym? (last l) (second r))))\n       \n       )\n\n)", "problem": 96, "user": "4e78c208535db95036265722"}, {"code": "#((fn m? [l r] (or (= l r nil)\n                   (let [[a b c] l [d e f] r]\n                     (and (= a d)\n                          (m? b f)\n                          (m? c e))))) % %)", "problem": 96, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [[_ t1 t2]]\n  (letfn [\n    (s? [t1 t2]\n      (cond (= nil t1 t2) true\n            (nil? t1) false\n            (nil? t2) false\n            :else (let [[av a1 a2] t1, [bv b1 b2] t2]\n              (cond (not= av bv) false\n                    (and (s? a1 b2) (s? a2 b1)) true\n                    :else false))))]\n    (s? t1 t2)))", "problem": 96, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(letfn [(t [c]\n            (or (nil? c)\n                (and (coll? c)\n                     (= (count c) 3)\n                     (t (nth c 1))\n                     (t (nth c 2)))))\n         (r [c]                         ; use only for trees\n            (if (not (coll? c))\n              c\n              [(nth c 0) (r (nth c 2)) (r (nth c 1))]))]\n   #(and (t %) (= % (r %))))", "problem": 96, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn sym? [t]\r\n  (let [flip (fn flip [t]\r\n               (if (nil? t) t\r\n                   (let [[a l r] t] [a (flip r) (flip l)])))]\r\n  (or (nil? t)\r\n      (let [[_ l r] t]\r\n         (= l (flip r))))))", "problem": 96, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn symmetric? [tree]\n  (let [\n  mirror (fn mirror [tree]\n    (when (seq tree)\n      (let [[value left right] tree]\n        [value (mirror right) (mirror left)])))\n  [value left right] tree\n  ]\n  (= left (mirror right))))", "problem": 96, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn symt?\n  ([l r]\n    (if (and (coll? l) (coll? r))\n        (let [[l1 l2 l3] l [r1 r2 r3] r]\n          (and (= l1 r1) (symt? l2 r3) (symt? l3 r2)))\n        (= l r)))\n  ([[v l r]]\n    (symt? l r)))", "problem": 96, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn match [t]\n  (letfn [ (mirror [[v l r :as n]]\n               (if n [v (mirror r) (mirror l)])) ]\n     (= t (mirror t))))", "problem": 96, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn balanced [t]\n   (letfn\n       [(flip [t]\n          (if (sequential? t)\n            (let [[a b c] t] [a (flip c) (flip b)])\n            t))]\n     (= t (flip t))))", "problem": 96, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [[n r l]] (= ((fn m [[n r l]] (when n [n (m l) (m r)])) l) r))", "problem": 96, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn is-tree-sym [tree]\n  (let [m-tree (fn mi-tree [tree]\n                      (cond (nil? tree) nil\n                            (coll? tree)\n                            [(first tree)\n                             (mi-tree (second (next tree)))\n                             (mi-tree (second tree))]))]\n    (cond (nil? tree) true\n         (coll? tree) \n         (let [next-tree (next tree)\n               left (first next-tree)\n               right (m-tree (second next-tree))]\n           (= left right))\n         :else  false)))", "problem": 96, "user": "4dcc5aff535d5973398f9293"}, {"code": "#(= %\n  ((fn flip [[root l r :as t]]\n    (when t\n      [root (flip r) (flip l)])) %))", "problem": 96, "user": "4e8e8c24535d65386fec2143"}, {"code": "#(= % ((fn flip [[v l r :as x]]\n  (when x\n    [v (flip r) (flip l)])) %))", "problem": 96, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "#(= % ((fn f [[a b c]] (if a [a (f c) (f b)])) %))", "problem": 96, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn symmetric? \n  ([left right]\n    (if (and (nil? left) (nil? right))\n        true\n        (let [left-value  (nth left 0)\n              left-left   (nth left 1)\n              left-right  (nth left 2)\n              right-value (nth right 0)\n              right-left  (nth right 1)\n              right-right (nth right 2)]\n          (and (= left-value right-value)\n               (symmetric? left-left right-right)\n               (symmetric? left-right right-left)))))\n  ([t] (symmetric? (nth t 1) (nth t 2))))", "problem": 96, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(fn [tree]\n  (let [collect (fn ! [tree]\n                  (if-not tree\n                    ()\n                    (concat (! (second tree))\n                            (list (first tree))\n                            (! (last tree)))))]\n    (= (collect (second tree)) (reverse (collect (last tree))))))", "problem": 96, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn is-sym\r\n  [tree]\r\n\t(letfn \r\n\t\t[(in-order [t]\r\n\t\t\t (if (sequential? t)\r\n\t\t\t\t (concat (in-order (second t)) [(first t)] (in-order (second (rest t))))\r\n\t\t\t\t [t]))\r\n\t\t (is-palindrome? [s]\r\n\t\t\t (let [s (vec s)]\r\n\t\t\t\t (if (or (empty? s) (= 1 (count s)))\r\n\t\t\t\t\ttrue\r\n\t\t\t\t\t(if (= (first s) (last s))\r\n\t\t\t\t\t\t(is-palindrome? (subvec s 1 (dec (count s))))\r\n\t\t\t\t\t\tfalse))))]\r\n    (println (in-order tree))\r\n\t\t(is-palindrome? (in-order tree))))", "problem": 96, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [[n l r]]\r\n  (= l\r\n  ((fn rtree [[n l r]]\r\n    (if (nil? n)\r\n      nil\r\n      [n (rtree r) (rtree l)]))\r\n    r)))", "problem": 96, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn symtree? \n  ([x]\n\t\t(and \n\t\t\t(== (count x) 3)   \n\t\t\t(symtree? (second x) (last x) )))\n\t([x y]\n\t\t(println x)\n\t\t(println y)\n\t\t(and \n\t\t\t(== (count x) 3)   \n\t\t\t(= (first x) (first y))\n\t\t\t(and\n\t\t\t\t(or \n\t\t\t\t\t(and (= (second x) nil) (= (last y) nil))\n\t\t\t\t\t(symtree? (second x)(last y) ))\n\t\t\t\t(or \n\t\t\t\t\t(and (= (last x) nil) (= (second y) nil))\n\t\t\t\t\t(symtree? (last x)(second y)))))))", "problem": 96, "user": "4e8d5edd535d65386fec2134"}, {"code": "#(letfn [(mirror [[n & branches :as t]]\n           (when (seq t)\n             (list* n (map mirror (reverse branches)))))]\n   (= % (mirror %)))", "problem": 96, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn [[_ l r]]\n  (letfn [(f [n] (if-let [[v l r] n] [v (f r) (f l)] n))]\n    (= l (f r))))", "problem": 96, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [t]\r\n  (= ((fn l [n] (if (nil? n) nil (concat (l (fnext n)) [(first n)] (l (last n))))) t)\r\n     ((fn r [n] (if (nil? n) nil (concat (r (last n)) [(first n)] (r (fnext n))))) t)))", "problem": 96, "user": "4e821ca5535db62dc21a62c2"}, {"code": "(fn symmetric-trees [[n t1 t2]]\n  (= (filter (complement sequential?) (tree-seq sequential? seq t1))\n     (filter (complement sequential?) (tree-seq sequential? (fn [[val t1 t2]] (list val t2 t1)) t2))))", "problem": 96, "user": "4dc54eb2535d8a4b2fd74284"}, {"code": "(fn mi? [t]\n  (letfn [(mi [t]\n    (let [n (first t) l (second t) r (last t)]\n      (if (and (nil? l) (nil? r))\n        t\n        [n (mi r) (mi l)])))]\n    (= t (mi t))))", "problem": 96, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [tr]\n  (if (nil? tr)\n    true\n    (= ( \n      (fn trswap [tr] \n      (if (nil? tr)\n        nil\n        (list (first tr) (trswap (last tr)) (trswap (second tr)))\n        )) (second tr)) (last tr))))", "problem": 96, "user": "4e98a6d0535dbda64a6f6b5e"}, {"code": "#(= ((fn f [[t a b]] (if t [t (f b) (f a)])) %) %)", "problem": 96, "user": "4db85bdd535d1e037afb218d"}, {"code": "#(letfn [\n  (z [n]    \n    (if (coll? n)\n      [(z (first (rest n))) (first n) (z (first (rest (rest n))))]\n      n))]\n  ((fn [s] (= (seq s) (reverse s))) (flatten (z %))))", "problem": 96, "user": "4e8f4f64535d65386fec2149"}, {"code": "#(letfn [(mirror [t] (if (coll? t)\n                       (apply list (first t) (map mirror (reverse (rest t))))\n                       t))]\n   (= % (mirror %)))", "problem": 96, "user": "4ea09fa4535d7eef308072aa"}, {"code": "(fn symmetric? [tree]\n  (letfn [\n    (mirror [[val left right]] \n      (let [new-left  (if (sequential? left) (mirror left) left)\n            new-right (if (sequential? right) (mirror right) right)]\n      [val new-right new-left]))]\n    (= tree (mirror tree))))", "problem": 96, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [[n l r]]\r\n  (= l ((fn f [[n l r]]\r\n    (if n [n (f r) (f l)]))\r\n\tr)))", "problem": 96, "user": "4e5af6d7535d8a8b8723a2b2"}, {"code": "(fn [t]\r\n  ((fn mir? [l r]\r\n     (if (or (= nil l r)\r\n             (and (= (first l) (first r))\r\n                  (mir? (second l) (last r))\r\n                  (mir? (last l) (second r))))\r\n       true false)) \r\n   (second t) (last t)))", "problem": 96, "user": "4e8ddf32535d65386fec213c"}, {"code": "(letfn [\n  (flip [tree]\n    (loop [[a b c] tree]\n      [a\n        (if (sequential? c) (flip c) c)\n        (if (sequential? b) (flip b) b)]\n  ))]\n  (fn [[_ b c]] (= b (flip c)))\n)", "problem": 96, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "(letfn [(mirror [[node left right]]\n          [node\n           (if (sequential? right) (mirror right) right)\n           (if (sequential? left) (mirror left) left)\n           ])\n\n        (symmetric? [[_ left right]]\n          (= (mirror left) right))]\n  symmetric?)", "problem": 96, "user": "4e6a4954535d8ccf87e9fec0"}, {"code": "(fn [[_ left right]]\n  (= left ((fn flip [[v left right :as t]] \n             (when t [v (flip right) (flip left)]))\n           right)))", "problem": 96, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn symm-btree? [[root left right]]\n  (= left\n     ((fn rev [[x & r]]\n        (if r\n          (apply vector x (reverse (map rev r))))) right)))", "problem": 96, "user": "4e976f79535dbda64a6f6b55"}, {"code": "(fn sym [[val left right]]\n  (letfn [(eq2 [[v l r] [V L R]]\n           (or (and (nil? left) (nil? right))\n               (and (= v V)\n                    (sym [nil l R])\n                    (sym [nil r L]))))]\n    (eq2 left right)))", "problem": 96, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn sym? \n         ([[v l r]] (sym? l r))\n         ([left right]\n         (cond \n           (and (coll? left) (coll? right))\n             (let [[leftv leftl leftr] left [rightv rightl rightr] right]\n               (and (= leftv rightv) (sym? leftl rightr) (sym? leftr rightl)))\n           :else (= left right))))", "problem": 96, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn [r] (let [d (fn [p] (if (not= (map first p) (reverse (map first p))) false (if (every? nil? p) true (recur (concat (map second p) (map #(nth % 2) p))))))] (d [r])))", "problem": 96, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "#(letfn [(inorder [l]\n  (if (nil? l) \n    '()\n    (let [v (first l) left (fnext l) right (fnext (next l))]\n      (concat (inorder left) (list v) (inorder right)))))]\n  (= (inorder (fnext %)) (reverse (inorder(fnext (next %))))))", "problem": 96, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [l] \n  (let [\n      s (fn h [l r] \n          (or \n            (and (= l r) (not (coll? l)) (not (coll? r)))\n            (and \n              (coll? l)\n              (coll? r)\n              (= (first l) (first r))\n              (h (first (rest l)) (second (rest r)))\n              (h (second (rest l)) (first (rest r))))\n    \n            )\n          )\n     ]\n    (s (second l) (last l))\n  )\n)", "problem": 96, "user": "4e9d6a65535dbda64a6f6b87"}, {"code": "#(= % ((fn r [[a b c]] (when a [a (r c) (r b)])) %))", "problem": 96, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn [tree]\r\n  (letfn [(rev [tree]\r\n            (if (sequential? tree)\r\n              (list (first tree) (rev (last tree)) (rev (second tree)))\r\n              tree))]\r\n    (= tree (rev tree))))", "problem": 96, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn this [node]\n  (let [[v l r] node]\n    (or\n      (every? nil? [l r])\n      (and\n        (not-any? nil? [l r])\n        (= (first l) (first r))\n        (this [nil (nth l 1) (nth r 2)])\n        (this [nil (nth l 2) (nth r 1)])))))", "problem": 96, "user": "4ea4fe1f535d7eef308072cf"}, {"code": "#((fn s [a b] (and (= (first a) (first b)) \n                 (every? identity \n                    (map s (rest a) (reverse (rest b)))))) (second %) (nth % 2))", "problem": 96, "user": "4eaede1f535d7eef30807329"}, {"code": "#(letfn [\n    (sw [[x y z]] (if x [x (sw z) (sw y)] nil))]\n    (= (second %1) (sw (last %1))))", "problem": 96, "user": "4dbdab4e535d020aff1edf49"}, {"code": "#(= % \n  ((fn r [[v a b :as t]] \n    [v (if (nil? b) b (r b)) (if (nil? a) a (r a))]) \n   %))", "problem": 96, "user": "4e707db6535d5021c1a8963a"}, {"code": "(fn [tree]\n  ((fn is-tree-equal[left right]\n    (if (or (nil? left) (nil? right))\n      (and\n        (nil? left)\n        (nil? right))\n      (and\n        (= (first left) (first right))\n        (is-tree-equal (second left) (second (next right)))\n        (is-tree-equal (second (next left)) (second right)))))\n    (second tree) (second (next tree))))", "problem": 96, "user": "4eb1dd39535d7eef30807345"}, {"code": "(fn mirror?[[node left right]]\n  (let [mirror (fn mirror [[n l r]]\n    (when n\n      [n (when r (mirror r)) (when l (mirror l))]))]\n    (= left (mirror right))))", "problem": 96, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "#(= %\n    ((fn f [[v l r :as n]]\n       (if n\n         [v (f r) (f l)]))\n     %))", "problem": 96, "user": "4ea55757535d7eef308072d3"}, {"code": "#(letfn [(refl [x]\n          (if (coll? x)\n            (let [[a b c] x]\n              [a (refl c) (refl b)])\n            x))]\n  (= % (refl %)))", "problem": 96, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "#((fn f [a b]\n       (or (= a b nil)\n         (let [[v c d] a [w x y] b]\n           (and\n             (= v w)\n             (f c y)\n             (f d x))))\n           \n     ) (nth % 1) (nth % 2))", "problem": 96, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn sym? [t]\n  (letfn [(mirror? [a b]\n            (cond\n              (and (nil? a) (nil? b)) true\n              (not (= (first a) (first b))) false\n              (not (mirror? (second a) (last b))) false\n              (not (mirror? (last a) (second b))) false\n              :else true))]\n    (mirror? (second t) (last t))))", "problem": 96, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn sym-bin-tree?\n  ([t]\n    (if (nil? t)\n      true\n      (sym-bin-tree? (nth t 1) (nth t 2))))\n  ([t1 t2]\n    (if (and (nil? t1) (nil? t2))\n      true\n      (let [v1 (nth t1 0), l1 (nth t1 1), r1 (nth t1 2),\n            v2 (nth t2 0), l2 (nth t2 1), r2 (nth t2 2)]\n        (and (= v1 v2)\n          (sym-bin-tree? l1 r2)\n          (sym-bin-tree? l2 r1))))))", "problem": 96, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn beauty-is-symmetry [coll]\n  (letfn [(rev-tree [[root c1 c2 :as body]]\n            (if (coll? body)\n              (lazy-seq [root (rev-tree c2) (rev-tree c1)])\n              body))]\n    (= coll (rev-tree coll))))", "problem": 96, "user": "4dd7d040535d2dad7130b5d6"}, {"code": "(fn [tree]\n  (let [reverse-tree (fn reverse-tree [eert]\n                        (when eert\n                          [ (first eert)\n                            (reverse-tree (nth eert 2))\n                            (reverse-tree (second eert))]))]\n    (=\n      (second tree)\n      (reverse-tree (nth tree 2)))))", "problem": 96, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(fn symmetric? [tree]\n  (if (coll? tree)\n    (let [mirror (fn mirror [tree]\n          (if (coll? tree)\n            (let [[v & children] tree]\n              (cons v (map mirror (reverse children))))\n            tree))\n          [_ left right] tree]\n      (= left (mirror right)))\n    true))", "problem": 96, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "#(= % ((fn s[x] (if (coll? x) (conj (reverse (map s (rest x))) (first x)) x )) %))", "problem": 96, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "#(= % ((fn mirror [t]\n  (if (nil? t) nil\n  (let [p (first t)\n        l (second t)\n        r (last t)]\n     [p (mirror r) (mirror l)]))) %))", "problem": 96, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [a]\n  (let\n    [walk\n      (fn walk [t]\n        (if (coll? t)\n          (let [[value left right] t]\n            (concat (walk left) [value]\n                    (walk right)))\n          []))]\n      (= (walk a)\n         (reverse (walk a)))))", "problem": 96, "user": "4ec5d40d535d6d7199dd36b9"}, {"code": "(fn symmetric? \n  ([tree] (symmetric? (nth tree 1) (last tree)))\n  ([left right]\n    (or \n      (and (nil? left) (nil? right))\n      (and\n        (= (first left) (first right))\n        (symmetric? (nth left 1) (last right))\n        (symmetric? (last left) (nth right 1))))))", "problem": 96, "user": "4eb51942535d7eef30807365"}, {"code": "(fn [y]\n(let [change-tree\n(fn change-tree [x]\n  (if-not (coll? x)\n    x\n    (if (and (nil? (fnext x)) (nil? (first (nnext x))))\n      x\n      (cons (first x) (cons (change-tree (first (nnext x))) (list (change-tree (fnext x))))))))\n]\n(if (= (change-tree (fnext y)) (first (nnext y)))\n  true false)\n))", "problem": 96, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn foo \n   ([s] (let [[p l r] s] (foo l r)))\n   ([l r] (or \n     (and (nil? l) (nil? r)) \n(and (coll? r) (= 3 (count r)) (= (first l) (first r)) (foo (nth l 1) (nth r 2)) (foo (nth l 2) (nth r 1))))))", "problem": 96, "user": "4eabb245535d7eef30807319"}, {"code": "(fn teq \n  ([a] \t(teq (second a) (last a)))\n\t([a b]\t(if (vector? a)\n\t\t\t\t(let [[u v w] a [x y z] b]\n\t\t\t\t\t(and (= u x) (teq v z) (teq w y)))\n\t\t\t\t\t(= a b))))", "problem": 96, "user": "4ec16c21535dfed6da9c6dac"}, {"code": "(fn [[val left right]]\n  (let\n    [mirror-tree \n      (fn mirror-tree [tree]\n        (cond\n          (nil? tree) nil\n        :else\n          (let \n            [[value left right] tree]\n              [value (mirror-tree right) (mirror-tree left)])))]\n      (= left (mirror-tree right))))", "problem": 96, "user": "4e6f578c535d5021c1a8961b"}, {"code": "#(=\n  ((fn flip [t]\n    (if (nil? t)\n      nil\n      (list (first t)  (flip (nth t 2)) (flip (second t))))) %) %)", "problem": 96, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [col]\n  ((fn check_subtree [t1 t2]\n    (if (sequential? t1)\n      (let [rn1 (first t1) l1 (second t1) r1 (nth t1 2) rn2 (first t2) l2 (second t2) r2 (nth t2 2)  ]\n       (and (= rn1 rn2)\n                 (and (check_subtree  r1 l2)  (check_subtree  l1 r2)) )\n\n      )\n      (= t1 t2)\n      )\n\n  ) (second col) (nth col 2) ))", "problem": 96, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "#((fn s [t u]\n    (or\n      (= t u nil)\n    (and \n      (= (first t) (first u))\n      (s (nth t 1) (nth u 2))\n      (s (nth t 2) (nth u 1))))) (nth % 1) (nth % 2))", "problem": 96, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn [t]\n    (letfn [\n            (tree? [seq] (and (coll? seq) (= 3 (count seq))))\n            (next-level [[ro l r]]\n              [l r])\n            (roots [trees]\n              (map #(if (tree? %)\n                      (first %) %)\n                   trees))\n            (levels [trees]\n              (if (not-any? tree? trees)\n                [trees]\n                (lazy-seq (cons (roots trees)\n                                (levels (mapcat next-level\n                                                (filter tree? trees)))))))]\n      (every? #(= % (reverse %)) (levels [t]))))", "problem": 96, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn [tree]\n  (letfn [(et [[av al ar :as a] [bv bl br :as b]]\n            (or (and (= a nil) (= b nil))\n                (and (= av bv)\n                     (et ar bl)\n                     (et al br))))]\n    (et (nth tree 1) (nth tree 2))))", "problem": 96, "user": "4e773be8535d324fb2983d6e"}, {"code": "(fn tree-sym [t]\n  (let [mirror (fn mir [t1 t2]\n                 (if (= nil t1 t2) true\n                     (and (= (first t1) (first t2))\n                          (mir (second t1) (last t2))\n                          (mir (last t1) (second t2)))))]\n    (mirror (second t) (last t))))", "problem": 96, "user": "4daf8f84edd6309eace4d17a"}, {"code": "(fn symmetric? [tree]\n  (letfn\n      [(flip [tree]\n         (if (nil? tree)\n           nil\n           (let [[v l r] tree]\n             [v (flip r) (flip l)])))\n       ]\n    (= tree (flip tree))))", "problem": 96, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn sym? [t]\n  (letfn [(myswap [node] \n      (if (sequential? node)\n      [(nth node 0) (myswap (nth node 2)) (myswap (nth node 1))]\n      node))]\n  (= (myswap (nth t 2)) (nth t 1))))", "problem": 96, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn tree-sym? [dirty-tree]\n  (letfn [(tree-flip [tree]\n  (if (nil? tree)\n    nil\n    (cons (first tree) (map tree-flip (reverse (rest tree))))))(valid [n]\n  (if (nil? n)\n    true\n    (if (coll? n)\n      (if (= (count n) 3)\n        (and (valid (nth n 1)) (valid (nth n 2)))\n        false)\n      false)))]\n  (if (not (valid dirty-tree))\n    false\n    (= (tree-flip (nth dirty-tree 1)) (nth dirty-tree 2)))))", "problem": 96, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn [t]\n   (let [left (fn [n] (second n))\n         right (fn [n] (last n))\n         leaf? (fn [[_ l r]] (and (nil? l) (nil? r)))\n         f (fn f [l r]\n             (cond\n              (and (leaf? l)\n                   (leaf? r)) (= (first l) (first r))\n              :else (and (f (left l) (right r))\n                         (f (left r) (right l)))))]\n     (f (second t) (last t))))", "problem": 96, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "(fn [[_ a b]]\n  (= b ((fn f [[v a b :as t]]\n          (and t [v (f b) (f a)])) a)))", "problem": 96, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn symmetric? [[root left right]]\n  (letfn [\n    (mirror [t]\n      (if (coll? t)\n        (let [[m-root m-left m-right] t]\n          [m-root (mirror m-right) (mirror m-left)])\n        t))\n     ]\n     (= left (mirror right))))", "problem": 96, "user": "4ec70f26535d6d7199dd36dd"}, {"code": "(fn symmetrical [t]\n  ((fn equiv [a b]\n     (or (and (nil? a) (nil? b))\n         (and (= (first a) (first b))\n              (coll? a)\n              (coll? b)\n              (and (equiv (nth a 1) (nth b 2))\n                     (equiv (nth a 2) (nth b 1))))))\n     (nth t 1) (nth t 2)))", "problem": 96, "user": "4ec75077535d6d7199dd36e0"}, {"code": "(let [reverse-leaf (fn rev [leaf]\n                      (list (first leaf)\n                            ((if (coll? (last leaf)) rev identity) (last leaf))\n                            ((if (coll? (second leaf)) rev identity) (second leaf))))]\n  (fn [tree]\n    (= (second tree) (reverse-leaf (last tree)))))", "problem": 96, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn sym?\n  ([x] (sym? (nth x 1) (nth x 2)))\n  ([x y] (or (and (nil? x) (nil? y))\n             (and (= (first x) (first y))\n                  (sym? (nth x 1) (nth y 2))\n                  (sym? (nth x 2) (nth y 1))))))", "problem": 96, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [x] ((fn f [a b] (or (and (empty? a) (empty? b))\n                        (and (= (first a) (first b))\n                            (f (first (rest a)) (first (rest (rest b))))\n                            (f (first (rest (rest a))) (first (rest b))))))\n            (first (rest x)) (first (rest (rest x)))))", "problem": 96, "user": "4ebef65e535dfed6da9c6d9b"}, {"code": "(fn [s]\n  (letfn [(f [c] (if-not (nil? c) (list (first c) (f (second (rest c))) (f (second c)))))]\n    (= s (f s))))", "problem": 96, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [t]\n  (letfn [(mi [t1 t2]\n            (if (and (nil? t1) (nil? t2))\n                true\n                (and (not (nil? t1))\n                     (not (nil? t2))\n                     (= (first t1) (first t2))\n                     (mi (second t1) (nth t2 2))\n                     (mi (nth t1 2) (second t2)))))]\n    (or (nil? t)\n        (mi (second t) (nth t 2)))))", "problem": 96, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn [tree]\n  (letfn [(mirror [tree]\n    (if (coll? tree)\n      (cons (first tree) (reverse (map mirror (next tree))))\n      tree))]\n    (= tree (mirror tree))))", "problem": 96, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "(fn [[_ l r]]\n  (letfn [(values [tree]\n            (if (nil? tree)\n                []\n                (let [[v l r] tree]\n                  (concat (values l) [v] (values r)))))]\n    (= (values l) (reverse (values r)))))", "problem": 96, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn e ([[_ l r]] (e l r))\n  ([l r] (if (nil? l)\n           (nil? r)\n           (let [[v1 l1 r1] l [v2 l2 r2] r]\n             (and (= v1 v2)(e l1 r2) (e r1 l2))))))", "problem": 96, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn is-sym-tree\n  ([t]\n    (is-sym-tree (second t) (last t)))\n  ([tl tr]\n    (let [lnil (nil? tl) rnil (nil? tr)]\n      (cond\n        (not= lnil rnil)\n          false\n        lnil\n          true\n        (not= (first tl) (first tr))\n          false\n        :else\n          (and (is-sym-tree (second tl) (last tr))\n               (is-sym-tree (last tl) (second tr)))))))", "problem": 96, "user": "4ec5cdb0535d6d7199dd36b8"}, {"code": "#(= (second %) ((fn f [t] (if (coll? t) (let [[x l r] t] [x (f r) (f l)]) t)) (last %)))", "problem": 96, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn p\n    ([[v l r :as t] [a b c :as s]]\n    (if (coll? t)\n        (if (coll? s)\n            (and (= v a) (p l c) (p b r))\n            false)\n        (= t s)))\n    ([[v l r]] (p l r)))", "problem": 96, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [[_ l r]]\n  (letfn [\n    (mirror? [l r]\n      (if (and (nil? l) (nil? r))\n        true\n        (let [[l ll lr] l [r rl rr] r]\n          (and (= l r) (mirror? lr rl) (mirror? ll rr)))))]\n    (mirror? l r)))", "problem": 96, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [[_ l r]] (letfn [(m [[h l r]] (if h (list h (m r) (m l)) h))] (= (m l) r)))", "problem": 96, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [[A B C]]\n  (=\n    ((fn I [t]\n       (if-let [[a b c] t]\n         [a (I c) (I b)]\n         t))\n       B)\n    C))", "problem": 96, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn func [node]\n  (letfn [(rec-rev [[v left right]]\n              (if v\n                [v (rec-rev right) (rec-rev left)]))]\n    (= (nth node 1) (rec-rev (nth node 2)))))", "problem": 96, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [[x1 x2 x3]]\n  (letfn [(is  [[a1 a2 a3 :as coll1] [b1 b2 b3 :as coll2]]\n            (if (nil? coll1) (nil? coll2)\n              (if (nil? coll2) (nil? coll1)\n                (and (= a1 b1) (is a2 b3) (is a3 b2)))))]\n    (is x2 x3)))", "problem": 96, "user": "4ed27f9f535d44c135fd68d5"}, {"code": "(fn symtree? [[_ l r]]\n  (letfn [\n    (flatten* [f st] (filter #(not (or (coll? %) (nil? %))) (tree-seq coll? f st)))]\n    (= (flatten* seq l) (flatten* (fn [[v a b]] [v b a]) r)) ))", "problem": 96, "user": "4ed7b617535d10e5ff6f52f3"}, {"code": "#(letfn [(f [a b]\n            (or\n             (and (nil? a) (nil? b))\n             (and (= (first a) (first b) )\n                  (f (second a) (last b))\n                  (f (last a) (second b)) ) ) ) ]\n          (f (second %) (last %)) )", "problem": 96, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [t] (= (second t) ((fn f [t]  (if (nil? t) nil [(first t) (f (last t)) (f (second t))])) (last t))))", "problem": 96, "user": "4e6a97a9535d8ccf87e9fef8"}, {"code": "(fn s [[h l r]] (or (every? nil? [l r]) (and (= (first l) (first r)) (s [h (nth l 1) (nth r 2)]) (s [h (nth l 2) (nth r 1)]))))", "problem": 96, "user": "4eecdd66535d93acb0a668b9"}, {"code": "#(= %\n  ((fn mirror [tr]\n  (let [[n l r] tr]\n    (if n [ n (mirror r) (mirror l)]))) %))", "problem": 96, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "#(= % ((fn m [[v l r]] (if v [v (m r) (m l)])) %))", "problem": 96, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn symm [tree]\n  (letfn [(tree-flip [t]\n          (if (coll? t)\n            (if-let [[v left right] t] [v (tree-flip right) (tree-flip left)])\n            t))]\n    (= (tree-flip tree) tree)))", "problem": 96, "user": "4edecdae535d10e5ff6f533c"}, {"code": "(fn [root]\r\n    (let [walk (fn w [f1 f2 root]\r\n           (when (not (nil? root))\r\n             (lazy-seq \r\n               (cons (first root)\r\n                     [(w f1 f2 (f1 root)) (w f1 f2 (f2 root))]))))]\r\n      (= (walk second last root) (walk last second root))))", "problem": 96, "user": "4ef1ee67535dced4c769f219"}, {"code": "(fn [t]\n    (loop [left [(second t)]\n           right [(last t)]]\n      (if (and (every? nil? left)\n               (every? nil? right))\n        true\n        (if-not (= (map first left) (map first (reverse right)))\n         false\n         (recur\n          (mapcat next left)\n          (mapcat next right)\n          )))))", "problem": 96, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn symmetric-binary-tree? [xs]\n  (let [\n      mirror (fn mirror [xs] \n        (if (sequential? xs)\n          (let [[x left right] xs] (list x (mirror right) (mirror left)))\n          xs))]\n  (cond\n    (not (sequential? xs)) true\n    (not (= 3 (count xs))) false\n    :else (let [[x left right] xs] (= left (mirror right))))))", "problem": 96, "user": "4ef41f26535dced4c769f230"}, {"code": "(fn [t]\n          (letfn [(s [t]\n                            (when-let [[v l r] t]\n                                      [v (s r)(s l)]))]\n                        (= t (s t))))", "problem": 96, "user": "4e599577535d8a8b8723a29f"}, {"code": "(fn [x]\n  (letfn [(rotate [t]\n            (if (coll? t)\n              (let [[a b c] t]\n                [a (rotate c) (rotate b)])\n              nil))]\n    (let [[a b c] x] (= b (rotate c)))))", "problem": 96, "user": "4ee9d697535d93acb0a66895"}, {"code": "#(= % ((fn m [[a b c :as t]] (if t [a (m c) (m b)] t)) %))", "problem": 96, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn symmetric-tree [node]\n  (=\n    (map first (tree-seq next rest node))\n    (map first (tree-seq next #(reverse (rest %)) node))))", "problem": 96, "user": "4ee3afde535d10e5ff6f5370"}, {"code": "(fn f [[_ b c]]\r\n  (and\r\n    (= (count b) (count c))\r\n    (= (nth b 0) (nth c 0))\r\n    (or \r\n      (and (nil? b) (nil? c))\r\n      (and\r\n        (f [nil (nth b 2) (nth c 1)])\r\n        (f [nil (nth c 2) (nth b 1)])))))", "problem": 96, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn symm? [[_ [x l1 r1] [y l2 r2]]]\n  (and (= x y)\n       (or (= nil l1 l2)\n           (and\n            (symm? [_ l1 r2])\n            (symm? [_ r1 l2])))))", "problem": 96, "user": "4ef4c1ff535dced4c769f23e"}, {"code": "(fn [[_ l r]]\n  (letfn [(walk [t & m]\n            (remove coll? (tree-seq coll? (fn [[v l r]] (if m [v r l] [v l r])) t)))]\n    (= (walk l) (walk r :mirrored))))", "problem": 96, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn t [x] (let [[v l r] x]\n  (letfn [(inv [t] (if (nil? t) t (list (first t) (inv (last t)) (inv (second t)))))]\n    (= l (inv r)))))", "problem": 96, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "(fn mirror-same [[_ l r]]\n   (letfn [(rt [t]\n               (if (nil? t) nil\n                   (let [[d l r] t]\n                     [d (rt r) (rt l)])))]\n     (= l (rt r))))", "problem": 96, "user": "4ee868be535d93acb0a6687d"}, {"code": "(fn [t]\n    (letfn [(rev [[t a b]]\n              [t (if (coll? b) (rev b) b) (if (coll? a) (rev a) a)])]\n      (= t (rev t))))", "problem": 96, "user": "4ed292ac535d44c135fd68d9"}, {"code": "(fn [[_ left right]]\n        (let [rev-tree\n              (fn rev [x]\n                (if (sequential? x)\n                  [(first x) (rev (nth x 2)) (rev (nth x 1))]\n                  x))]\n          (or (= left right)\n              (= left (rev-tree right)))))", "problem": 96, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn [coll] (= coll ((fn f [[v l r]] (if v [v (f r) (f l)])) coll)))", "problem": 96, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn [[_ y z]] \n  (= y \n     ((fn r [xs]    \n       (if (coll? xs)\n         (let [[x y z] xs]        \n           [x (r z) (r y)])\n         xs)) z)))", "problem": 96, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn [[h left right]]\n  (let [flip (fn flip [coll]\n    (when-let [t (seq coll)]\n      (let [[h left right] t]\n       [h (flip right) (flip left)])))]\n  \n  (= (flip left) right)))", "problem": 96, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn sym-tree?\n  ([c] (or\n         (not (coll? c))\n         (apply sym-tree? c)))\n\n  ([a1 a2] false)\n\n  ([v t1 t2 & more]\n     (let [t [v t1 t2]\n           flip-tree (fn flip-tree\n                       ([av] (if-not (coll? av) av (apply flip-tree av)))\n                      \n                       ([av at1 at2] [av (flip-tree at2) (flip-tree at1)])) ]\n       \n      (and (zero? (count more)) (= t (flip-tree t))))))", "problem": 96, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [s] (letfn [(rev-tree [t]\n                   (if (sequential? t)\n                     (cons (first t) (reduce #(conj % (rev-tree %2))\n                                             []\n                                             (reverse (rest t))))\n                     t))]\n           (= s (rev-tree s))))", "problem": 96, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [[_ l r]]\n  (let [m (fn m [[x l r]] (when x [x (m r) (m l)]))]\n    (= l (m r))))", "problem": 96, "user": "4f043ed1535dcb61093f6bb4"}, {"code": "(fn [[root left right]]\n  (letfn [(mirror [[root left right :as tree]]\n                  (if-not (nil? tree)\n                    [root (mirror right) (mirror left)]))]\n    (= right (mirror left))))", "problem": 96, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn f ([[a b c]] (f b c))\n  ([a b] (if (and (sequential? a) (sequential? b))\n  \t       (and (f (first a) (first b))\n             (f (second a) (last b)) (f (last a) (second b)))\n\t\t\t    (= a b))))", "problem": 96, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "#(letfn [(t [x]\n  (if (seq x)\n      (concat (t (nth x 1))\n              [(nth x 0)]\n              (t (nth x 2)))\n      [x]))]\n  (= (t %) (reverse (t %))))", "problem": 96, "user": "4f062d4a535dcb61093f6c08"}, {"code": "#(= ((fn f[[v l r]]\n       [v (if r (f r) r) (if l (f l) l)]) (second %))\n    (nth % 2))", "problem": 96, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn symmetrical? \n  [tree]\n  (= (map first (tree-seq next rest tree)) \n     (map first (tree-seq next (comp reverse rest) tree))))", "problem": 96, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(let [is-mirror? (fn is-mirror? [t1 t2]\n                   (or (and (nil? t1) (nil? t2))\n                       (if (and (coll? t1) (coll? t2))\n                         (and (= (first t1) (first t2))\n                              (is-mirror? (nth t1 1) (nth t2 2))\n                              (is-mirror? (nth t1 2) (nth t2 1)))\n                         (= t1 t2))))]\n  (fn is-symmetric? [[v l r]]\n    (is-mirror? l r)))", "problem": 96, "user": "4e8df08f535d65386fec213e"}, {"code": "(fn [[_ l r]]\n(= l\n   ((fn s [[v l r]]\n        (if v [v (s r) (s l)]))\n    r)))", "problem": 96, "user": "4db8f6c4535d1e037afb219e"}, {"code": "#(= % ((fn f [[n l r]] (\n  if n\n    [n (f r) (f l)]\n    n\n  )\n) %))", "problem": 96, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [s]\n  (letfn [(mirror? [a b]\n    (or\n      (= nil a b)\n      (and\n        (= (nth a 0) (nth b 0))\n        (mirror? (nth a 1) (nth b 2))\n        (mirror? (nth a 2) (nth b 1)))))]\n  (boolean \n    (mirror? \n      (nth s 1)\n      (nth s 2)))))", "problem": 96, "user": "4f050dec535dcb61093f6bef"}, {"code": "#((fn node-equal? [a b]\n    (if (and (coll? a) (coll? b))\n      (and\n        (= (first a) (first b))\n        (node-equal? (nth a 1) (last b))\n        (node-equal? (nth b 1) (last a)))\n      (= a b)))\n  (nth % 1) (last %))", "problem": 96, "user": "4f01ff83535dcb61093f6a3a"}, {"code": "(fn [[n l r]]\n  (= l\n    ((fn mirror [[n l r]] \n      [n (if r (mirror r)) (if l (mirror l))]) r)))", "problem": 96, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(letfn [(m [t]\n          (if (sequential? t)\n            (let [[n l r] t] [n (m r) (m l)]) \n            t))]\n  (fn [[_ l r]] (= (m l) r)))", "problem": 96, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn esmirror [l]\n  (let\n   [mirror   (fn mirror [l ll]\n   (cond \n     (and (coll? l) (coll? ll) (= (count l) 3) (= (count ll) 3)\n       (let [[v1 l1 r1] l [v2 l2 r2] ll ]\n              (and (= v1 v2) (mirror l1 r2) (mirror r1 l2)))) true\n     (and (not (coll? l)) (= l ll)) true\n     :else false))]\n     (mirror l l)))", "problem": 96, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn [tree]\n    (letfn [(mirror-tree [[value left right]]\n        [value (if (nil? right) right (mirror-tree right)) (if (nil? left) left (mirror-tree left))])]\n        (= tree (mirror-tree tree))))", "problem": 96, "user": "4f0b2028535d0136e6c222ff"}, {"code": "(fn symm [t]\n  (letfn [(treerev [t]\n            (if (nil? t)\n              t\n              [(first t) (treerev (last t)) (treerev (second t))]))]\n    (if (nil? t)\n      true\n      (= (second t) (treerev (last t))))))", "problem": 96, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn [[v l r]]\n  (letfn [(sym? [[v1 l1 r1] [v2 l2 r2]]\n                (if (nil? v1)\n                    (nil? v2)\n                    (and (= v1 v2)\n                         (sym? l1 r2) \n                         (sym? r1 l2))))]\n         (sym? l r)))", "problem": 96, "user": "4eeaf88f535d93acb0a668a3"}, {"code": "(fn [t]\n  (println t)\n  (= (second t) \n    ((fn flip [tt] \n        (when tt \n          (cons (first tt) \n              (reverse (map flip (rest tt)))))) \n      (last t))))", "problem": 96, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn sym?\r\n    ([t] (sym? (second t) (last t)))\r\n    ([a b]\r\n       (if (and (nil? a) (nil? b))\r\n         true\r\n         (if (or (nil? a) (nil? b))\r\n           false\r\n           (and\r\n            (= (first a) (first b))\r\n            (sym? (second a) (last b))\r\n            (sym? (second b) (last a)))))))", "problem": 96, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn [c]\n  (= (second c)\n     ((fn flip [c]\n        (if (not (sequential? c)) c\n            [(first c) (flip (last c)) (flip (second c))]))\n      (last c))))", "problem": 96, "user": "4f0ef874535d0136e6c22328"}, {"code": "(let [flip (fn flip [t] (when-let [[val left right] t]\n                          [val (flip right) (flip left)]))]\n  (fn [[_ left right]] (= left (flip right))))", "problem": 96, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "#(letfn [(scan [cs-fn] (->> % (tree-seq (complement nil?) cs-fn) (map first)))]\n   (= (scan rest)\n      (scan (comp reverse rest))))", "problem": 96, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn [[_ a b]]\n  (let [node-seq (fn [children t]\n                   (filter\n                     (complement coll?)\n                     (tree-seq coll? children t)))]\n    (= (node-seq seq a)\n       (node-seq #(list (nth % 0) (nth % 2) (nth % 1)) b))))", "problem": 96, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn symmetric-binary-tree? [tree]                                                                                                            \r\n    (letfn [(symmetric-nodes? [left right]                                                                                                    \r\n              (or (every? nil? [left right])                                                                                                  \r\n                  (and (every? coll? [left right])                                                                                            \r\n                       (= 3 (count left) (count right))                                                                                       \r\n                       (= (first left) (first right))                                                                                         \r\n                       (symmetric-nodes? (nth left 1) (nth right 2))                                                                          \r\n                       (symmetric-nodes? (nth left 2) (nth right 1)))))]                                                                      \r\n      (and (coll? tree)                                                                                                                       \r\n           (= 3 (count tree))                                                                                                                 \r\n           (symmetric-nodes? (nth tree 1) (nth tree 2)))))", "problem": 96, "user": "4f149e0f535d64f60314643d"}, {"code": "(fn [tree]\n    (let [\n        mirror (fn m [a]\n        (cond\n            (= a nil) nil\n            :else (list (first a) (m (last a)) (m (second a)))))]\n        (= tree (mirror tree))))", "problem": 96, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn issym [[k l r]]\n(  \n(fn ismirr [a b]\n  (cond\n    (and (= nil a) (= nil b)) true\n    (and \n      (coll? a)\n      (coll? b)\n      (let [ [ka la ra] a\n             [kb lb rb] b]\n          (and \n            (= ka kb)\n            (ismirr la rb)\n            (ismirr lb ra)\n          )\n      )\n    ) true\n    :default false\n  )\n) l r) \n)", "problem": 96, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn sym-tree? [[l m r]]\n    (letfn [\n           (tree? [t]\n               (if (= 3 (count t))\n                   (let [m (second t), r (nth t 2)]\n                       (cond\n                           (and (nil? m) (nil? r)) true\n                           (and (coll? m) (nil? r)) (tree? m)\n                           (and (nil? m) (coll? r)) (tree? r)\n                           (and (coll? m) (coll? r)) (and (tree? m) (tree? r))\n                           :else false))\n                   false))\n           (eq-tree? [[av al ar] [bv bl br]]\n               (if (= av bv)\n                   (cond\n                       (every? nil? [al ar bl br])\n                       true\n                       (every? tree? [al ar bl br])\n                       (and (eq-tree? al br) (eq-tree? ar bl))\n                       (and (every? tree? [al br]) (every? nil? [ar bl]))\n                       (eq-tree? al br)\n                       (and (every? tree? [ar bl]) (every? nil? [al br]))\n                       (eq-tree? ar bl)\n                       :else false)\n                   false))\n               ]\n        (if (eq-tree? m r)\n        true\n        false)))", "problem": 96, "user": "4f128865535d64f603146428"}, {"code": "(fn [tree]\n  (letfn [(trev [x]\n      (if (nil? x)\n        nil\n        (cons (first x) (reverse (map trev (rest x)))))\n    )]\n    (= (nth tree 1) (trev (nth tree 2)))))", "problem": 96, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [s]\n            (let [[val l r] s\n                  swp (fn swap [t]\n                        (let [[v l r] t]\n                          (if\n                            (nil? v) t\n                            [v (swap r) (swap l)])))]\n              (= l (swp r))))", "problem": 96, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [coll]\n    (letfn [(node? [t] (and (coll? t)\n                            (= 3 (count t))\n                            (not (nil? (first t)))))\n            (node-val [t] (nth t 0))\n            (lchild [t] (nth t 1))\n            (rchild [t] (nth t 2))\n            (mirrors? [t1 t2]\n              (cond\n               (and (nil? t1)\n                    (nil? t2)) true\n               (and (node? t1)\n                    (node? t2)) (and (= (node-val t1) (node-val t2))\n                                     (mirrors? (lchild t1) (rchild t2))\n                                     (mirrors? (rchild t1) (lchild t2)))\n               (and (not (node? t1))\n                    (not (node? t2))) (= (t1 t2))\n               :else false))]\n      (mirrors? (lchild coll) (rchild coll))))", "problem": 96, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [[v c1 c2]] (= ((fn i [t] (if (nil? t) nil [(first t) (i (nth t 2)) (i (second t))])) c1) c2))", "problem": 96, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn sym? [tree]\n  (let [left  (fn [tree] (nth tree 1))\n        right (fn [tree] (nth tree 2))\n        head  (fn [tree] (first tree))\n        walk  (fn walk [tree x y]\n               (when (seq tree)\n                 (concat [(first tree)] (walk (x tree) x y) (walk (y tree) x y))))]\n\n    (= (walk (left tree) left right) \n       (walk (right tree) right left))))", "problem": 96, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn s?\n  ([[_ l r]] (s? [l] [r]))\n  ([l r]\n  (letfn [(sl? [lb rb] (and (= (count lb) (count rb)) (every? (fn [[[lf & _] [rf & _]]] (= lf rf)) (map vector lb (reverse rb)))))\n          (down [lvl] (mapcat (fn [[v l r :as n]] (if n [l r] [])) lvl))]\n    (or (every? empty? [l r])\n      (if (sl? l r) (recur (down l) (down r)) false)))))", "problem": 96, "user": "4e95f5a5535dbda64a6f6b3b"}, {"code": "(fn [tree]\n    (let [eq-trees?\n            (fn eq-trees? [t1 t2]\n                (if (nil? t1)\n                    (nil? t2)\n                    (if (nil? t2)\n                        false\n                        (let [[x1 l1 r1] t1\n                              [x2 l2 r2] t2]\n                            (and (= x1 x2) (eq-trees? l1 r2) (eq-trees? r1 l2))\n                        ))))\n          [_ l r] tree]\n        (eq-trees? l r)\n    ))", "problem": 96, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "#(\n  (fn s [[a b c :as x] [k l m :as y]]\n    (or \n      (not (or x y))\n      (and (= a k) (s b m) (s c l)))) % %)", "problem": 96, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [[_ L R]]\n  (letfn\n    [(flip [[v l r]] (list v (if (coll? r) (flip r) r) (if (coll? l) (flip l) l)))]\n    (= L (flip R))))", "problem": 96, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [[node left right]]\n  (let [mirror-tree (fn f [[node left right]]\n                      [node\n\t                     (if (nil? right) nil (f right))\n\t                     (if (nil? left)  nil (f left))])]\n    (= left (mirror-tree right))))", "problem": 96, "user": "4daf36c2edd6309eace4d175"}, {"code": "(fn f [[_ [v x y :as l] [w a b :as r]]]\n  (or (= nil l r)\n    (and (= v w)\n         (f [1 x b])\n         (f [1 a y]))))", "problem": 96, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn symmetric? [tree]\n  (letfn\n    [(reverse-btree [tree]\n        (if (nil? tree) nil\n          (let\n            [[value left right] tree]\n              [value (reverse-btree right) (reverse-btree left)]\n            )\n        )\n      )]\n    (= tree (reverse-btree tree))\n    )\n  )", "problem": 96, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn symmetric-tree? [[a b c]]\n  ((fn ! [t1 t2]\n     (or (and (nil? t1) (nil? t2))\n      (let [[a l1 r1] t1 [b l2 r2] t2]\n        (and (= a b) (! l1 r2) (! l2 r1)))))\n   b c))", "problem": 96, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn sym-tree? [t]\n  (letfn [(compare [a b]\n            (if (nil? a) (nil? b)\n              (and (= (first a) (first b)) (compare (second a) (last b)) (compare (last a) (second b)))))]\n    (compare (second t) (last t))))", "problem": 96, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn [s]\r\n  (=\r\n    (map first (tree-seq #(= 3 (count %)) #(reverse (rest %)) s))\r\n    (map first (tree-seq #(= 3 (count %)) rest s))))", "problem": 96, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [x] ((fn this [& more]\n         (let [symetric? (fn [coll]\n  \t\t    (if (= 1 (count coll)) true\n\t     (loop [s coll]\n\t\t(if (empty? s) true\n\t\t    (if (not (= (first s) (last s))) false\n\t\t\t(recur (butlast (rest s))))))))] \n\t   (loop [s (first (seq more)) q [] subtree []]\n\t     (if (empty? s)\n\t       (do\n\t\t (cond\n\t\t   (not (symetric? q)) false\n\t\t   (= 0 (count subtree)) true\n\t\t   :else\n\t\t   (this subtree)))\n\t       (recur (rest s) (conj q (first (first s))) (into subtree (rest (first s)))))))) (vector x)))", "problem": 96, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn [t]\n   (letfn [(rev [q]\n             (if (coll? q)\n               (list (first q) (rev (last q)) (rev (fnext q)))\n               q))]\n     (= (fnext t) (rev (last t)))))", "problem": 96, "user": "4eb02674535d7eef30807338"}, {"code": "#((fn eq [[a b]]\n     (if (coll? a) \n       (let [[x t v] a\n             [y u w] b]\n         (and (= x y) (eq [t w]) (eq [u v])))\n       (= a b)))\n   (rest %))", "problem": 96, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn s? [[_ l r]]\n  (letfn [(mirror [[v m s]] [v (when (coll? s) (mirror s)) (when (coll? m) (mirror m))])]\n    (= l (mirror r))))", "problem": 96, "user": "4e1f9bb5535d04ed9115e80d"}, {"code": "(fn [t]\n  (letfn [(m [t]\n            (if (nil? t)\n              t\n              (list (first t)\n                    (m (nth t 2))\n                    (m (nth t 1)))))]\n    (= (nth t 1) (m (nth t 2)))))", "problem": 96, "user": "4e7dd982535db169f9c796ee"}, {"code": "(fn [[r a b]] \n   (apply (fn f [[n l r] [m s t]]\n     (let [g (fn [x y] (if (every? coll? [x y]) (f x y) (= x y)))]  \n      (if (= m n)\n       (and \n          (g l t)\n          (g r s)\n        )\n        false\n        )\n      )) [a b]\n    )\n)", "problem": 96, "user": "4f1595da535d64f603146444"}, {"code": "(fn [[p v h]]\r\n  (= v ((fn r [[p v h]]\r\n          (if p\r\n            [p (r h) (r v)])) h)))", "problem": 96, "user": "4f07c8c3535dcb61093f6c2d"}, {"code": "#(letfn\n              [(f [[r a b]]\n                 [r (g b) (g a)])\n               (g [a] (if (coll? a) (f a) a))]\n            (= % (f %)))", "problem": 96, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [tree]\n  (let [left #(nth % 1)\n        right #(nth % 2)\n        mirror (fn mirror [t1 t2]\n          (cond (and (nil? t1) (nil? t2)) true\n                (or (nil? t1) (nil? t2)) false\n                :else (and (= (first t1) (first t2))\n                           (mirror (left t1) (right t2))\n                           (mirror (right t1) (left t2)))))]\n   (mirror (left tree) (right tree))))", "problem": 96, "user": "4f13047d535d64f60314642c"}, {"code": "(fn sym? [tree]\n   (= (second tree) ( (fn flip [coll]\n  (if (coll? coll)\n    (conj (conj [(first coll)] (flip (last coll))) (flip (second coll)))\n    coll)) (last tree)))\n   )", "problem": 96, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn [t] (= (filter (complement sequential?) (tree-seq sequential? #(cons (first %) (reverse (rest %))) (nth t 2)))\n     (filter (complement sequential?) (tree-seq sequential? seq (second t)))))", "problem": 96, "user": "4dc1bd76535d020aff1edf8d"}, {"code": "(fn problem-96 [parent]\n  (let [node-val (fn [n] (nth n 0))\n        node-child-left (fn [n] (nth n 1))\n        node-child-right (fn [n] (nth n 2))\n        is-symmetric\n        (fn is-symmetric [node1 node2]\n          (cond\n            (and (nil? node1) (not (nil? node2))) false\n            (and (nil? node2) (not (nil? node1))) false\n            (and (nil? node1) (nil? node2)) true\n            (and (= (node-val node1) (node-val node2))\n                 (is-symmetric (node-child-left node1)\n                               (node-child-right node2))\n                 (is-symmetric (node-child-right node1)\n                               (node-child-left node2))) true\n            :else false))]\n    (is-symmetric (node-child-left parent) (node-child-right parent))))", "problem": 96, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn [t]\r\n  ((fn mir? [l r]\r\n     (if (or (= nil l r)\r\n             (and (= (first l) (first r))\r\n                  (mir? (second l) (last r))\r\n                  (mir? (last l) (second r))))\r\n       true false)) \r\n   (second t) (last t)))", "problem": 96, "user": "4ec3b393535dcc7ae8597d59"}, {"code": "(fn [[v l r]]\n   (letfn [(swap [[v l r :as t]] \n             (when t\n               [v (swap r) (swap l)]))]\n     (= l (swap r))))", "problem": 96, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [[v l r]]\n   (letfn \n     [(m [[v l r]] \n       [v \n        (if (seq r) (m r) r) \n        (if (seq l) (m l) l)])]\n     (= l (m r))))", "problem": 96, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "(fn [[v l r]]\n           (= l ((fn rot [t]\n                    (if (nil? t)\n                        t\n                        (list (first t) (rot (last t)) (rot (second t))))) r)))", "problem": 96, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn symmetry? [r]\n    (letfn [(mirror? [l r]\n                   (if (or (= nil l r)\n                           (and (= (first l) (first r))\n                                (mirror? (second l) (last r))\n                                (mirror? (last l) (second r))))\n           \n                     true\n                     false))]\n      (mirror? (second r) (last r))))", "problem": 96, "user": "4f1bee08535d64f60314647e"}, {"code": "(fn [t]\n  (let [g (fn g [n1 n2]\n            (fn lf \n            \t([t] (lf t '()))\n            \t([[p & cs] vs]\n              \t\t(when-not (nil? p) (conj vs p (lf (nth cs n1) vs) (lf (nth cs n2) vs))))))\n        ]\n    (= ((g 0 1) t) ((g 1 0) t))))", "problem": 96, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [tree]( letfn[ (compare [tree1 tree2]\n                    (or\n                      \n                     ;;Base case for when the two root nodes are nil\n                     (and\n                       (nil? tree1)\n                       (nil? tree2))\n                     \n                     (and                     \n                       ;;the two root nodes are equal\n                       (= (first tree1) (first tree2))\n\n                       ;;the left of the first and the right of the sec\n                       (compare (nth tree1 1) (nth tree2 2))\n                       (compare (nth tree1 2) (nth tree2 1)))))]\n\n                (compare (nth tree 1) (nth tree 2))))", "problem": 96, "user": "4f2aff4de4b0d6649770a044"}, {"code": "(fn [[_ b1 b2]]\n\n  (letfn [(trr [[n l r]] (if (nil? n) nil [n (trr r) (trr l)]))]\n    (= b1 (trr b2))))", "problem": 96, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "#( (fn mirror [t1 t2]\n      (if (empty? t1)\n          (empty? t2)\n          (and (= (first t1) (first t2))\n                (mirror (second t1) (nth t2 2))\n                (mirror (nth t1 2) (second t2)))\n      ))\n    (second %) (nth % 2))", "problem": 96, "user": "4f404dcee4b0e243712b1fb0"}, {"code": "(fn [s] (let [mirror (fn m [s] (map #(if (sequential? %) (m %) %) (list (nth s 0) (nth s 2) (nth s 1))))]\n         (if (= (mirror (nth s 1)) (nth s 2)) true false)))", "problem": 96, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "#(= %\n    ((fn f [[v l r]]\n       (if v\n         [v (f r) (f l)]))\n     %))", "problem": 96, "user": "4e131443535d04ed9115e7d3"}, {"code": "(fn [tree]\n  (let [[value lchild rchild] tree\n        chcompare (fn this [c1 c2]\n                    (or\n                      (= nil c1 c2)\n                      (let [[v1 l1 r1] c1 [v2 l2 r2] c2]\n                        (and (= v1 v2) (this l1 r2) (this l2 r1)))))]\n    (chcompare lchild rchild)))", "problem": 96, "user": "4f418eaee4b0d7d3c9f3fce9"}, {"code": "#(letfn [(third [x] (second (rest x)))\r\n         (check-symmetry [x1 x2]\r\n           (cond\r\n            (and (= x1 nil) (= x2 nil)) true\r\n            (and (coll? x1) (coll? x2)\r\n                 (= (first x1) (first x2))\r\n                 (check-symmetry (third x1) (second x2))\r\n                 (check-symmetry (second x1) (third x2))) true\r\n                 :else false))]\r\n  (check-symmetry (second %) (third %)))", "problem": 96, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [tree]\n  (= (second tree) \n     ((fn ! [t]\n           (if-let [s (seq t)]\n              (if (= (rest s) '(nil nil)) s\n              (cons (first s) \n                 (cons (! (last s)) \n                       (cons (! (second s)) nil)))))) (last tree))\n   \n  )\n)", "problem": 96, "user": "4f1d1299535d64f603146487"}, {"code": "#((fn mirror [xs ys]\n    (if (and (nil? xs) (nil? ys))\n      true\n      (and\n        (= (first xs)\n           (first ys))\n        (mirror (second xs) (last ys))\n        (mirror (last xs) (second ys))))) (second %) (last %))", "problem": 96, "user": "4f426a7ae4b0d7d3c9f3fcff"}, {"code": "(fn symmetry [[head left right]]\n  (let [is-reverse \n    (fn is-reverse [tree1 tree2]\n      (let [[head1 left1 right1] tree1\n            [head2 left2 right2] tree2]\n        (if (and (nil? head1) (nil? head2))\n          true\n          (and (= head1 head2) (is-reverse left1 right2) (is-reverse left2 right1)))))]\n  (is-reverse left right)))", "problem": 96, "user": "4e6a60cd535d8ccf87e9fed7"}, {"code": "(fn [[v l r]]\n    (letfn [(flip [tree]\n        (if (nil? tree)\n            tree\n            (list (first tree) (flip (nth tree 2)) (flip (nth tree 1)))))]\n        (= l (flip r))))", "problem": 96, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn [tree]                                                   \n  (letfn [(reflect [tree]                                                       \n            (if (nil? tree) nil                                                 \n                [(nth tree 0) (reflect (nth tree 2)) (reflect (nth tree 1))]))]\n    (= (reflect (nth tree 1)) (nth tree 2))))", "problem": 96, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn [[v l r]]\n  (letfn [(same? [[av al ar :as a] [bv bl br :as b]]\n    (or (= nil a b)\n        (and (= av bv)\n             (same? al br)\n             (same? bl ar))))]\n    (same? l r)))", "problem": 96, "user": "4f4ba29ae4b03ad3f0c10c7a"}, {"code": "#(= % ((fn f [[a b c]]\n  [a (and c (f c)) (and b (f b))])\n  %))", "problem": 96, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [[v left right]]\n  ((fn cmp [[v1 left1 right1] [v2 left2 right2]]\n    (if (and (nil? v1) (nil? v2)) true\n          (and  (= v1 v2)\n                (cmp left1 right2)\n                (cmp right1 left2)))) left right))", "problem": 96, "user": "4f038499535dcb61093f6b09"}, {"code": "(fn mirror? [tree]\n  (let [mirror (fn mirror [tree]\n                 (let [head (nth tree 0)\n                       left (nth tree 1)\n                       right (nth tree 2)]\n                   (cond\n                     (= left right) tree\n                     :else (cons head \n                                 (cons (mirror right)\n                                       (cons (mirror left) nil))))))\n        left (nth tree 1)\n        right (mirror (nth tree 2))]\n    (= left right)))", "problem": 96, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn [s] (letfn [\n  (switch [s] [(first s) (if (nth s 2) (switch (nth s 2))) (if (nth s 1) (switch (nth s 1)))])]\n  (= (nth s 1) (switch (nth s 2)))))", "problem": 96, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn hoge [[_ [a b c][x y z]]]\n  (and (= a x)\n    (or (= nil b c y z)\n        (and (hoge [_ b z])(hoge [_ c y])))))", "problem": 96, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn [[r t t2]] \n  (= t ((fn mirror [[r & ts]]\n  (if (nil? r)\n    r\n    (cons r (map mirror (reverse ts))))) t2)))", "problem": 96, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn [[root l r]]\n(= l ((fn mirror [tree]\n  (let [root (first tree) left (second tree) right (last tree)]\n    (cond\n      (and (coll? left) (coll? right))\n        [root (mirror right) (mirror left)]\n      (coll? left)\n        [root right (mirror left)]\n      (coll? right)\n        [root (mirror right) left]\n      :else\n        [root right left]))) r)))", "problem": 96, "user": "4f4f08c8e4b03ad3f0c10cd8"}, {"code": "(fn [t]\n    (let [sym-tree\n          (fn sym-tree [t]\n            (if (nil? t) t\n                (if (coll? t)\n                  (let [n0 (first t)\n                        n1 (second t)\n                        n2 (nth t 2)]\n                    [n0 (sym-tree n2) (sym-tree n1)])\n                  t)))\n          btree?\n          (fn btree? [t]\n            (if (nil? t) true\n                (if (and (coll? t)\n                         (not (coll? (first t)))\n                         (= (count t) 3))\n                  (and (btree? (second t))\n                       (btree? (nth t 2)))\n                  false)))]\n      (and (btree? t)\n           (= (second t) (sym-tree (nth t 2)))))\n    )", "problem": 96, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn f [t]\r\n    (let [[value left right] t]\r\n      (= ((fn go-left [t] (when-let [[value left right] (seq t)]\r\n               (cons value (cons (go-left left) (go-left right))))) left)\r\n         ((fn go-right [t] (when-let [[value left right] (seq t)]\r\n               (cons value (cons (go-right right) (go-right left))))) right))))", "problem": 96, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn s-tree? [[v a b]]\r\n  (let [v? (fn [a b] (= (first a) (first b)))\r\n        \r\n        l  (fn [n]   (second n))\r\n        r  (fn [n]   (second (rest n)))\r\n        \r\n        twins? (fn t? [a b]\r\n                    \r\n                 (or\r\n                   \r\n                   (and (nil? a)  (nil? b))\r\n                   \r\n                   (and\r\n                     \r\n                     (and (coll? a)       (coll? b))\r\n                     (and (= 3 (count a)) (= 3 (count b)))\r\n                     (and\r\n                         (v? a b)\r\n                         (t? (l a) (r b))\r\n                         (t? (r a) (l b))))))]\r\n    \r\n      (twins? a b)\r\n    ))", "problem": 96, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn sym? [[_ t1 t2]]\n  (letfn\n    [(mirror [[v b1 b2]]\n             [v\n              (if (coll? b2) (mirror b2) nil)\n              (if (coll? b1) (mirror b1) nil)])]\n    (= t1 (mirror t2))))", "problem": 96, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn [t]\n  (letfn\n    [(eq [left right]\n      (cond\n        (not (and (coll? left) (coll? right))) (= left right),\n        (not (eq (nth left 0) (nth right 0))) false,\n        (not (eq (nth left 1) (nth right 2))) false,\n        (not (eq (nth left 2) (nth right 1))) false,\n        :else true))]\n    (eq (nth t 1) (nth t 2))))", "problem": 96, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn [[v ta tb]]\n  (letfn [\n    (sym [ta tb]\n      (cond \n        (nil? ta) (nil? tb)\n        (nil? tb) (nil? ta)\n        :else \n          (let [[va taa tab] ta [vb tba tbb] tb]\n            (and \n              (= va vb) \n              (sym taa tbb) \n              (sym tab tba)))))]\n    (sym ta tb)))", "problem": 96, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn symmetric? [node]\n  (let [left-child\n        (fn [node]\n          (second node)),\n\n        right-child\n        (fn [node]\n          (nth node 2)),\n\n        palindrome?\n        (fn\n          [lst]\n          (loop [norm lst, rev (reverse lst)]\n            (if (empty? norm)\n              true\n              (if (not= (first norm) (first rev))\n                false\n                (recur (rest norm) (rest rev)))))),\n\n        build-new-list\n        (fn [list]\n          (loop [lst list, new-lst []]\n            (if (empty? lst)\n              new-lst\n              (let [head (first lst), tail (rest lst)]\n                (recur tail (if (nil? head) new-lst (conj new-lst (left-child head) (right-child head))))))))]\n\n    (loop [lst [(left-child node) (right-child node)]]\n      (if (empty? lst)\n        true\n        (if (not (palindrome? (map first lst)))\n          false\n          (recur (build-new-list lst)))))))", "problem": 96, "user": "4f047902535dcb61093f6bcc"}, {"code": "(fn  mirror[[t a b]]\n((fn sym [a b]\n  (if (or (nil? a) (nil? b)) (= a b)\n    (let [[x y z] a [t u v] b]\n      (and (= x t)\n           (sym y v)\n           (sym z u))))) a b))", "problem": 96, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [s]\n    (= (map first (tree-seq vector? (fn [x] (seq [(nth x 2)(second x)])) (second s)))\n       (map first (tree-seq vector? (fn [x] (seq [(second x)(nth x 2)])) (nth s 2)))))", "problem": 96, "user": "4e8768f6535dceadca469850"}, {"code": "(fn [root]\n   (=\n    (filter #(not (sequential? %)) (tree-seq sequential? #(list (first %) (nth % 1) (nth % 2)) (nth root 1)))\n    (filter #(not (sequential? %)) (tree-seq sequential? #(list (first %) (nth % 2) (nth % 1)) (nth root 2)))))", "problem": 96, "user": "4f40f055e4b0e243712b1fc2"}, {"code": "(fn [s]\n  (let [third #(nth % 2)]\n    ((fn tree= [a b]\n      (if (coll? a)\n        (if (coll? b)\n          (and (= (first a) (first b))\n            (and (tree= (third a) (second b)) (tree= (second a) (third b))))\n          false)\n        (if (coll? b)\n          false\n          (= a b))))\n      (second s) (third s))))", "problem": 96, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "#(= %\n    ((fn flp[[v l r :as n]]\n       (when n\n         [v (flp r) (flp l)]))\n     %))", "problem": 96, "user": "4e7f5a0b535db966e863cc41"}, {"code": "#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))", "problem": 96, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn [abtree]\n    (letfn[(left-node [x]\n             (nth x 1))\n           (right-node [x]\n             (nth x 2))\n           (btree-walker [f1 f2 nodes]\n             (if (coll? nodes)\n               (vector (first nodes)\n                       (btree-walker f1 f2 (f1 nodes))\n                       (btree-walker f1 f2 (f2 nodes)))\n               nodes))]\n      (= (btree-walker left-node right-node (nth abtree 1))\n         (btree-walker right-node left-node (nth abtree 2)))))", "problem": 96, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn [f [x m n]] (= m (f n)))\n(fn f[[v a b]]\n  [v\n  (if (coll? b) (f b) b)\n  (if (coll? a) (f a) a)])", "problem": 96, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn mirror\r\n  [[n a b]]\r\n  ((fn f [l r]\r\n     (if (= nil l r)\r\n       true\r\n       (if (or (= nil l) (= nil r))\r\n   false\r\n\t (and (= (first l) (first r)) (f (second l) (nth r 2)) (f (nth l 2) (second r)))))) a b))", "problem": 96, "user": "4f17ab99535d64f603146457"}, {"code": "(fn [t]\n  (\n    (fn treeq? [a b]\n      (and\n      (= (first a) (first b))\n      (if (and (coll? a) (coll? b))\n        (and\n          (treeq? (nth a 1) (nth b 2))\n          (treeq? (nth a 2) (nth b 1)))\n        (= a b))))\n    \n    (nth t 1) (nth t 2)))", "problem": 96, "user": "4f559d2ce4b0a7574ea71808"}, {"code": "(fn [n] (letfn [(mirror [node]\n  (if (sequential? node)\n      (list (nth node 0)\n            (mirror (nth node 2))\n            (mirror (nth node 1)))\n      node))]\n (= (nth n 1) (mirror (nth n 2)))))", "problem": 96, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [t] \n  (let [mirror (fn mirror [t1 t2]\n                    (cond \n                      (and (nil? t1) (nil? t2)) true\n                      (or (nil? t1) (nil? t2)) false\n                      :else (let [[x1 l1 r1] t1\n                                  [x2 l2 r2] t2]\n                              (and (= x1 x2)\n                                   (mirror l1 r2)\n                                   (mirror l2 r1)))))]\n    (or (nil? t)\n        (let [[_ l r] t]\n          (mirror l r)))))", "problem": 96, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(fn sym-btree?\n  ([coll]\n     (sym-btree? (second coll) (second (rest coll))))\n  ([left right]\n     (or (and (not (coll? left))\n              (not (coll? right))\n              (= left right))\n         (and (coll? left)\n              (coll? right)\n              (= (first left) (first right))\n              (sym-btree? (second left) (second (rest right)))\n              (sym-btree? (second (rest left)) (second right))))))", "problem": 96, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn [[v l r :as t]]\n    (let [st? (fn st? [[v1 l1 r1 :as t1] [v2 l2 r2 :as t2]]\n                (if (nil? t1)\n                  (nil? t2)\n                  (and (not (nil? t2))\n                       (and (= v1 v2) (st? l1 r2) (st? l2 r1)))))]\n      (or (nil? t) (st? l r))))", "problem": 96, "user": "4efd8b67535de96065cf5085"}, {"code": "apply #(= %2\n          ((fn f [[h l r]]\n             (and h [h (f r) (f l)]))\n           %3))", "problem": 96, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn sym-tree? [t]\n  (= t ((fn lr-rev [[v l r :as t]]\n          (if (nil? t) t [v (lr-rev r) (lr-rev l)])) t)))", "problem": 96, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn sym [tree]\n  (= (second tree)\n     ((fn srt [c]\n        (let [v (first c), l (second c), r (last c)]\n          (vector v (if (coll? r) (srt r) r) (if (coll? l) (srt l) l)))) (last tree))))", "problem": 96, "user": "4ecbb249535df97575fdabdf"}, {"code": "#(= % ((fn mirror [v] (if (coll? v) (list (first v) (mirror (last v)) (mirror (second v))) v)) %))", "problem": 96, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn equtree[paramTree]\r\n  (let[leftBranch (fn[tree]\r\n                     (if (empty? (rest tree)) \r\n                         (keyword \"empty\")\r\n                         (first (rest tree))\r\n                      )\r\n                    ),\r\n       rightBranch (fn[tree]\r\n  \t                (if (empty? (rest tree)) \r\n\t\t                    (keyword \"empty\")\r\n\t\t                    (let[other (rest (rest tree))]\r\n\t\t                      (cond (empty?  other) (keyword \"empty\")\r\n\t\t                            (not (empty? (rest other))) (keyword \"other\")\r\n\t\t                            :else (first other)\r\n\t\t                      )\r\n\t\t                    )    \r\n\t\t                 )\r\n                   ),                     \r\n       compareTree (fn isEquTree[tree1 tree2]\r\n                    (let[root1 (first tree1),\r\n                         root2 (first tree2),\r\n                         comp (fn[t1 t2]\r\n                                (let[leaf1 (leftBranch t1),\r\n                                     leaf2 (rightBranch t2)]\r\n                                (println (str \"left \" leaf1 \" right \" leaf2) ) \r\n                                (if(and (coll? leaf1) (coll? leaf2))\r\n                                   (isEquTree leaf1 leaf2)                                   \r\n                                   (= leaf1 leaf2)\r\n                                 )\r\n                                ))]\r\n                         \r\n                         (and (= root1 root2)\r\n                              (comp tree1 tree2)\r\n                              (comp tree2 tree1)\r\n                              )\r\n                      )\r\n                )]\r\n       (let[left (leftBranch paramTree),\r\n            right (rightBranch paramTree)]\r\n           (compareTree left right) \r\n         )\r\n    )\r\n  )", "problem": 96, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn sym-tree? [[x y z]]\n  (if (or (nil? y) (nil? z))\n    (and (nil? y) (nil? z))\n    (let [fy (first y) fz (first z)\n          sy (second y) sz (second z)\n          ty (nth y 2) tz (nth z 2)]\n      (if (= fy fz)\n        (and (sym-tree? (list fy sz ty))\n             (sym-tree? (list fy sy tz)))\n        false))))", "problem": 96, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn [tree]\n   (= \n    (first (rest tree)) \n    (\n      (fn sym [node]\n        (if (coll? node)\n          (concat (conj (empty node) (first node)) (reverse ( map sym (rest node))))\n          node\n        )\n      )\n      (last tree)\n    )\n  )\n)", "problem": 96, "user": "4f84400de4b033992c121c2e"}, {"code": "#(letfn\n  [\n    (u [[a b c]] \n      (if (every? nil? [b c])\n          [a]\n          (concat (u b) [a] (u c))))\n    (p [a]\n      (if (empty? a)\n          true\n          (and (= (first a) (last a))\n               (recur (butlast (rest a))))))\n ]\n (p (u %)))", "problem": 96, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn sym[t]\n  (letfn [(dfenum [t]\n          (if\n            (nil? t) nil\n            (flatten (list (dfenum (first (rest t))) (first t) (dfenum (last (rest t))))\n          )))]\n  (= (dfenum t) (reverse (dfenum t)))\n  )\n)", "problem": 96, "user": "4f8b56dae4b02e764a0a517e"}, {"code": "(fn sym [b] (= b ((fn ref [a] (if (nil? a) nil (list (first a) (ref (second (rest a))) (ref (second a))))) b)\n))", "problem": 96, "user": "4f8b20fce4b02e764a0a5178"}, {"code": "(fn sym\n  ([t] (apply sym (drop 1 t)))\n  ([left right]\n    (if (= nil left)\n      (= nil right)\n      (let [[lv, ll, lr] left,\n            [rv, rl, rr] right]\n        (and\n          (= lv rv)\n          (sym ll rr)\n          (sym lr rl)\n        )\n      )\n    )\n  )\n)", "problem": 96, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [t] \n  (let [rev (fn rev [t]\n              (if (nil? t) nil \n                (let [[p l r] t]\n                    [p (rev r) (rev l)])))]\n    (= t (rev t))))", "problem": 96, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [[v a b]]\n  (let [b? (fn [[v l r]] (or l r))]\n    (= (map first (tree-seq b? (fn [[v l r]] (filter identity [r l])) a))\n       (map first (tree-seq b? (fn [[v l r]] (filter identity [l r])) b)))))", "problem": 96, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn [[n l r]]\n  (= (flatten l)\n     (filter #(not (coll? %)) (tree-seq coll? (fn [[_ a b]] [_ b a]) r))))", "problem": 96, "user": "4f0c4518535d0136e6c2230b"}, {"code": "#(= %\r\n   ((fn t [[a b c]]\r\n      (if a\r\n          [a (t c) (t b)] a))\r\n   %))", "problem": 96, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "problem": 96, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [[_ left right]]\r\n  (letfn [(swap [node]\r\n            (when-not (nil? node)\r\n              (let [[v l r] node]\r\n                [v (swap r) (swap l)])))]\r\n    (= left (swap right))))", "problem": 96, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [t]\n  (let [rev (fn rev [s]\n              (if (sequential? s)\n                   (list (first s) (rev (nth s 2)) (rev (nth s 1)))\n                   s))]\n    (and (= (count t) 3)\n         (= (nth t 1) (rev (nth t 2))))))", "problem": 96, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn [[_ lc rc]]\n   (letfn [(mirror [[v lc rc :as n]]\n             (if (nil? n)\n               nil\n               [v (mirror rc) (mirror lc)]))]\n     (= lc (mirror rc))))", "problem": 96, "user": "4db3393e535df7e46ed9b6cc"}, {"code": "(fn [tree]\n   (letfn [(mirror [[v l r :as t]]\n             (if (nil? t) nil\n                 (seq [v (mirror r) (mirror l)])))]\n     (= (seq tree) (mirror tree))))", "problem": 96, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [tree]\n  (letfn\n    [(walk [children root]\n      (map first (tree-seq coll? children root)))]\n    (=\n      (walk rest tree)\n      (walk (comp reverse rest) tree))))", "problem": 96, "user": "4f7f9665e4b033992c121bea"}, {"code": "#(letfn\n     [(turn [t]\n        (if t\n          [(first t)\n           (turn (nth t 2))\n           (turn (nth t 1))]\n          nil))]\n   (or (= (nth % 1) (nth % 2))\n       (= (nth % 1) (turn (nth % 2)))))", "problem": 96, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [[_ l r]]\n  ((fn sim [a b]\n    (if (some nil? [a b])\n      (every? nil? [a b])\n      (let [[n1 l1 r1] a [n2 l2 r2] b]\n        (and (= n1 n2) (sim l1 r2) (sim l2 r1))))) l r))", "problem": 96, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(let [ts #(map first (tree-seq coll? % %2))] \n  #(= (ts next %) (ts (comp reverse next) %)))", "problem": 96, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [t]\n  (every? \n    #(= % (reverse %))\n    (vals\n      ((fn f [d n r]\n         (if (coll? n)\n           (f (inc d) (nth n 2) (f (inc d) (second n) (assoc r d (conj (r d []) (first n)))))\n           (assoc r d (conj (r d []) n))))\n         0 t {}))))", "problem": 96, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "#(= % ((fn m [[v l r]] (if v [v (m r) (m l)])) %))", "problem": 96, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn is-symmetric [[_ l r]]\n (letfn [(mirror-image? [l r]\n           (cond (every? nil? [l r]) true\n                 :else (let [[lv ll lr] l [rv rl rr] r]\n                         (and (= lv rv)\n                              (mirror-image? ll rr)\n                              (mirror-image? lr rl)))))]\n   (mirror-image? l r)))", "problem": 96, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn symmetry? [[_ left right]]\n  (letfn [(mirror [node]\n            (when-let [[v l r] node]\n              [v (mirror r) (mirror l)]))]\n    (= left (mirror right))))", "problem": 96, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [t] (\n  (fn f [t1 t2] (\n    or\n      (and (nil? t1) (nil? t2))\n      (and (= (nth t1 0) (nth t2 0))\n            (f (nth t1 1) (nth t2 2))\n            (f (nth t1 2) (nth t2 1)))\n    )) (nth t 1) (nth t 2) \n))", "problem": 96, "user": "4ef48422535dced4c769f236"}, {"code": "(fn my-sym? [tree]\n        (let [get-left (fn [tree] (second tree))\n              get-right (fn [tree] (nth tree 2))\n              sym? (fn sym? [left right]\n                     (cond\n                       (and (nil? left) (nil? right)) true\n                       (and (nil? left) (not (nil? right))) false\n                       (and (not (nil? left)) (nil? right)) false\n                       :else (and (= (first left) (first right))\n                               (sym? (get-left left) (get-right right))\n                                  (sym? (get-right left) (get-left right)))))]\n          (sym? (get-left tree) (get-right tree))))", "problem": 96, "user": "4f82e14be4b033992c121c0c"}, {"code": "(fn [t]\r\n  ((fn mir? [l r]\r\n     (if (or (= nil l r)\r\n             (and (= (first l) (first r))\r\n                  (mir? (second l) (last r))\r\n                  (mir? (last l) (second r))))\r\n       true false)) \r\n   (second t) (last t)))", "problem": 96, "user": "4faa3eeae4b081705acca1ed"}, {"code": "(fn [[_ l r]]\n  (letfn\n    [(mirror [t]\n       (when-let [[v l r] t]\n         [v (mirror r) (mirror l)]))]\n    (= l (mirror r))))", "problem": 96, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn is-sym [[node left right]] \n  (let [sym (fn sym [left right]\n    (or\n      (and (nil? left) (nil? right))\n      (and (coll? left) (coll? right)\n      (let\n        [[lnode lleft lright] left\n        [rnode rleft rright] right]\n          (and\n            (= lnode rnode)\n            (sym lleft rright)\n            (sym lright rleft))))))]\n    (sym left right)))", "problem": 96, "user": "4f69f34fe4b07046d9f4ef90"}, {"code": "#(letfn [(c [s t]\n        (cond (not= (first s) (first t)) false\n          (and (nil? s) (nil? t)) true\n          :else (and (c (second s) (second (rest t)))\n                   (c (second (rest s)) (second t)))))]\n  (c % %))", "problem": 96, "user": "4facd2fae4b081705acca22f"}, {"code": "#(letfn [(flip [t] (if (empty? t) nil\n                       (list (first t)\n                             (flip (second (next t)))\n                             (flip (second t)))))]\n   (= (flip (second %)) (second (next %))))", "problem": 96, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn is-symmetric [bt]\n  (let [[root l r] bt\n        trees-equal (fn trees-equal [t1 t2]\n                      (cond\n                        (and (nil? t1) (nil? t2)) true\n                        (or (nil? t1) (nil? t2)) false\n                        :else (let [[root1 l1 r1] t1\n                              [root2 l2 r2] t2]\n                            (and (= root1 root2)\n                                (trees-equal l1 r2)\n                                (trees-equal r1 l2)))))]\n    (trees-equal l r)))", "problem": 96, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn symm-tree? [T]\n  (letfn [\n    (mirror \n      ([k l1 l2] [k (apply mirror l2) (apply mirror l1)])\n      ([] nil))]\n  (= T (apply mirror T))))", "problem": 96, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn [col] (let [[_ l r] col] (= \n  (map first (tree-seq next rest l))\n  (map first (tree-seq next #(reverse (rest %)) r)))))", "problem": 96, "user": "4ea4e98a535d7eef308072ce"}, {"code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond \n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "problem": 96, "user": "4f7d25b4e4b06e829148e1ba"}, {"code": "(fn [[_ left right]]\n  ((fn symmetric? [left right]\n    (or\n      (and (nil? left) (nil? right))\n      (and\n        (not (nil? left))\n        (not (nil? right))\n        (= (first left) (first right))\n        (symmetric? (second left) (nth right 2))\n        (symmetric? (nth left 2) (second right)))))\n  left right))", "problem": 96, "user": "4fb2101ce4b081705acca284"}, {"code": "#(apply = (map flatten \n  [((fn rt [t] (when (coll? t)\n  (list (first t)\n        (rt (last t))\n        (rt (second t))))) (second %))\n  (last %)]))", "problem": 96, "user": "4fa30027e4b081705acca187"}, {"code": "#(= % ((fn f [xs] (list (first xs) (if (nil? (last xs)) nil (f (last xs))) (if (nil? (second xs)) nil (f (second xs))))) %))", "problem": 96, "user": "4f4f0287e4b03ad3f0c10cd7"}, {"code": "(fn sym [n] \n   (= (flatten (second n)) \n   ((fn sw [rn]\n      (cond (not (coll? rn)) [rn]\n            (nil? rn) [nil]\n            :else (concat [(first rn)] (sw (nth rn 2)) (sw (second rn)))\n   )) (nth n 2)))\n)", "problem": 96, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn [x]\n  (let [third (fn [y] (nth y 2))\n        sym? \n        (fn sym? [a b]\n          (cond (and (not (coll? a)) \n                     (not (coll? b))) (= a b)\n                (and (coll? a) \n                     (coll? b))\n                  (and (= (first a) (first b))\n                       (sym? (second a) (third b))\n                       (sym? (third a) (second b)))\n                :default false))]\n    (sym? (second x) (third x))))", "problem": 96, "user": "4e49a7bb535dc968683fc4c6"}, {"code": "#(= \n  ((fn tree_reverse [tree]\n      (if (nil? tree)\n        nil\n        (cons (first tree) (reverse (map tree_reverse (rest tree))))))\n      (second %))\n  (last %))", "problem": 96, "user": "4fa5406fe4b081705acca1ac"}, {"code": "#(= \n  (map first (tree-seq sequential? rest (second %))) \n  (map first (tree-seq sequential? (comp reverse rest) (last %))))", "problem": 96, "user": "4fb3b865e4b081705acca2a2"}, {"code": "(fn is-symmetric [binary-tree]\n  ((fn symmetric-trees? [t1 t2]\n     (or (every? nil? [t1 t2])\n         (and (= (first t1) (first t2))\n              (symmetric-trees? (second t1) (last t2))\n              (symmetric-trees? (last t1)   (second t2)))))\n     (second binary-tree) (last binary-tree)))", "problem": 96, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [[rt l r]]\n((fn sym? [left right]\n  (cond\n    (and (nil? left) (nil? right)) true\n    (or (nil? left) (nil? right)) false\n    (not= (first left) (first right)) false\n    (and (sym? (second left) (last right))\n         (sym? (last left) (second right))) true\n    :else false))\n  l r))", "problem": 96, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn a [col]\r\n  (let [is-symmetric? (fn is-symmetric? [a b]\r\n                        (if (and (nil? a) (nil? b))\r\n                          true\r\n                          (if (not= (first a) (first b))\r\n                            false\r\n                            (and (is-symmetric? (second a) (nth b 2)) (is-symmetric? (nth a 2) (second b))))))]\r\n    (is-symmetric? (second col) (nth col 2))))", "problem": 96, "user": "4fab31a8e4b081705acca215"}, {"code": "(fn [[v l r]]\n   (letfn [(flip [t]\n             (if-let [[v l r] t]\n               (list v (flip r) (flip l))))]\n     (= l (flip r))))", "problem": 96, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn issymmetric [s]\n  (letfn [(mirror [s]\n            (if (and (coll? s) (= (count s) 3))\n              (conj [] (first s) (mirror (nth s 2)) (mirror (second s)))))]\n    (= (second s) (mirror (nth s 2)))))", "problem": 96, "user": "4f68c485e4b07046d9f4ef7c"}, {"code": "#(= ((fn m [t] (if (nil? t) nil\n       [(nth t 0) (m (nth t 2)) (m (nth t 1))]))\n     (nth % 1)) (nth % 2))", "problem": 96, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn symmetric? [tree]\n  (letfn [(flip [tree]\n            (if-let [[h t1 t2] (seq tree)]\n              [h (flip t2) (flip t1)]\n              nil))]\n    (= tree (flip tree))))", "problem": 96, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn mirr?[node]\n  (= node ((fn mirror[elem]\n    (let [head (first elem) lc (fnext elem) rc (last elem)]\n      (cond\n       (= lc rc) elem\n       (and (not (nil? lc)) (nil? rc)) [head rc (mirror lc)]\n       (and (nil? lc) (not (nil? rc))) [head (mirror rc) lc]\n       :else [head (mirror rc) (mirror lc)]))) node)))", "problem": 96, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn sym\n  ([[_ l r]] (sym l r))\n  ([l r]\n    (or\n      (every? nil? [l r])\n      (let [[lv ll lr] l\n            [rv rl rr] r]\n        (and\n          (= lv rv)\n          (sym ll rr)\n          (sym lr rl))))))", "problem": 96, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn f [[_ [lx ll lr] [rx rl rr]]]\n  (and (= lx rx)\n       (or \n         (= nil ll rl  rl rr)\n         (and (f [_ ll rr]) (f [_ rl lr])))))", "problem": 96, "user": "4fa6a491e4b081705acca1bc"}, {"code": "#(= \n  ((fn reverse-tree [[s l r :as node]] \n    (if (nil? node) \n      nil\n      (list s (reverse-tree r) (reverse-tree l)))) %) %)", "problem": 96, "user": "4ec92a6e535d6d7199dd36fb"}, {"code": "(fn mirror? [t]\n  (let [tree-reverse (fn tree-reverse [t]\n        (if (coll? t)\n            (list (first t) (tree-reverse (last t))\n                            (tree-reverse (second t)))\n            t))]\n  (= t (tree-reverse t))))", "problem": 96, "user": "4faac363e4b081705acca200"}, {"code": "#(= % \n    ((fn v [[s l r :as n]] \n      (when n \n        [s (v r) (v l)])) %))", "problem": 96, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "(fn [tr]\n(letfn [(mirror [t]\n  (if\n    (nil? t) t\n    (list (first t) (mirror (last t)) (mirror (second t))\n      )\n    )\n)] \n  (= (second tr) (mirror (last tr)))\n)\n)", "problem": 96, "user": "4fcad14ce4b0ee37620e1856"}, {"code": "(letfn [(mirror [node]\n          (if (sequential? node)\n            (let [[v a b] node]\n              [v (mirror b) (mirror a)])\n            node))]\n  (fn symmetric? [[v a b]]\n    (= (mirror a) b)))", "problem": 96, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [tree]\n  (let [[root l r] tree]\n(= ((fn sp [coll]\n  (let [[root l r] coll]\n    (cond\n      (and (not (coll? l))\n        (not (coll? r))) (cons root (cons r (cons l ())))\n      (not (coll? l)) (cons root (cons (sp r) (cons l ())))\n      (not (coll? r)) (cons root (cons r (cons (sp l) ())))\n      :else (cons root (cons (sp r) (cons (sp l) ())))))) l) r)))", "problem": 96, "user": "4fbb9d80e4b081705acca2ea"}, {"code": "#(letfn [(rf [t] (if-let [[v l r] t] \n                  [v (rf r) (rf l)]))]\n  (= % (rf %)))", "problem": 96, "user": "4fbacdbae4b081705acca2e5"}, {"code": "#(= (second %) ((fn lp[a](if (coll? a) (cons (first a) (map lp (reverse (rest a)))) a) ) (last %)))", "problem": 96, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn [ [p l r] ]\n     (letfn [ (m [ [x y z] ] \n         [x (if (coll? z) (m z) z) (if (coll? y)(m y) y) ] )\n       ] (= l (m r)))\n   )", "problem": 96, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [[v l r]] (= l\n  ((fn mirror [[v l r :as t]]\n     (if (nil? t) nil [v (mirror r) (mirror l)]))\n   r)))", "problem": 96, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [t]\n(\n  (fn is-sym [l r]\n    (if (and (nil? l) (nil? r)) true\n      (and (= (first l) (first r))\n           (is-sym (second l) (nth r 2))\n           (is-sym (second r) (nth l 2)))))\n  (second t) (nth t 2)))", "problem": 96, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [[v l r]]\n  (letfn [(mirror? [l r]\n      (let [[lv ll lr] l, [rv rl rr] r]\n        (and\n          (= lv rv)\n          (or\n            (and (nil? ll) (nil? rr))\n            (mirror? ll rr))\n          (or\n            (and (nil? lr) (nil? rl))\n            (mirror? lr rl)))))]\n    (mirror? l r)))", "problem": 96, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [t]\n  ((fn f [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (f (second l) (last r))\n                  (f (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "problem": 96, "user": "4ead2841535d7eef3080731e"}, {"code": "(fn [[k a b]]\n   ((fn =|= [a b]\n      (if (and (coll? a) (coll? b))\n        (let [[k1 a1 b1] a [k2 b2 a2] b]\n          (and (= k1 k2) (=|= a1 a2) (=|= b1 b2)))\n        (= a b)))\n      a b))", "problem": 96, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn [t]\n  (letfn [(s [t1 t2]\n            (if (= nil t1 t2)\n              true\n              (let [[v1 l1 r1] t1\n                    [v2 l2 r2] t2]\n                (if (= v1 v2)\n                  (and (s l1 r2)\n                       (s r1 l2))\n                  false))))]\n    (let [[v l r] t]\n      (s l r))))", "problem": 96, "user": "4e6f4cbc535d5021c1a8961a"}, {"code": "(fn [[_ l r]] ((fn check [a b]\n   (if (coll? a)\n     (let [[ak al ar] a\n           [bk bl br] b]\n       (and (= ak bk)\n            (check al br)\n         (check ar bl)))\n     (= a b))) l r))", "problem": 96, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn tree-symmetry [tree]\n  (letfn [(summarize-vals [t]\n            (cond\n             (nil? t) '()\n             :else\n             (concat \n                     (summarize-vals (second t))\n                     (list (first t))\n                     (summarize-vals (last t)))))]\n    (if (= (summarize-vals (second tree))\n           (reverse (summarize-vals (last tree))))\n      true\n      false)))", "problem": 96, "user": "4fd16778e4b04c3a95aa040f"}, {"code": "#({1 true 2 false} ({2019804072 1 -1685615011 2 2019987623 2 1136499742 1 1135606012 2 1135427266 2} (hash %)))", "problem": 96, "user": "4db016af838c48654951d9b9"}, {"code": "#((fn sym [a b]\n  (cond\n    (= (count a) (count b) 3)\n      (and (= (first a) (first b))\n          (sym (fnext a) (-> b nnext first))\n          (sym (fnext b) (-> a nnext first)))\n    :else (= nil a b))) (fnext %) (-> % nnext first))", "problem": 96, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(letfn [(symmetry? [t1 t2]\r\n          (cond\r\n             (nil? t1) (nil? t2)\r\n             (nil? t2) false\r\n             :else (and (= (first t1) (first t2))\r\n                        (symmetry? (second t1) (nth t2 2))\r\n                        (symmetry? (nth t1 2) (second t2)))))]\r\n  (fn bis? [btree]\r\n    (symmetry? (second btree) (nth btree 2))))", "problem": 96, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "#(\n  (fn s [a b]\n     (or (and (nil? a)\n              (nil? b))\n         (and (not (nil? a))\n              (not (nil? b))\n              (= (first a) (first b))\n              (s (nth a 1) (nth b 2))\n              (s (nth a 2) (nth b 1)))))\n   \t(nth % 1) (nth % 2))", "problem": 96, "user": "4db0114d838c48654951d9b8"}, {"code": "(fn symmetric? [tree]\n  (letfn [(reverse-tree [tree]\n            (if (nil? tree)\n              nil\n              (vector (first tree)\n                (reverse-tree (last tree))\n                (reverse-tree (second tree)))))]\n    (= tree (reverse-tree tree))))", "problem": 96, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn [[n l r]]\n  (letfn [(mirrored [t]\n            (if (nil? t)\n              nil\n              (list (first t)\n                    (mirrored (nth t 2))\n                    (mirrored (second t)))))]\n    (= l (mirrored r))))", "problem": 96, "user": "4fea04f4e4b0547ebccb2482"}, {"code": "(fn sym? [[_ a b :as t]]\n  ((fn me [l r]\n     (let [[a ll lr] l\n           [b rl rr] r]\n            (and (= a b)\n                 (if (and (coll? ll) (coll? rr)) (me ll rr) (= ll rr))\n                 (if (and (coll? lr) (coll? rl)) (me lr rl) (= lr rl)))))\n   a b))", "problem": 96, "user": "4faafccde4b081705acca209"}, {"code": "(fn [x] (let [left (fn f [x] (if (nil? x) nil (let [[n l r] x] [(f l) n (f r)])))\r\n              right (fn f [x] (if (nil? x) nil (let [[n l r] x] [(f r) n (f l)])))]\r\n          (= (flatten (left x)) (flatten (right x)))))", "problem": 96, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn symmetry-tree?\n  [t]\n  (letfn [(mirror [l]\n            (if (nil? l)\n              nil\n              [(first l) (mirror (nth l 2)) (mirror (nth l 1))]))]\n      (= (mirror t) t)))", "problem": 96, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn [tree]\n  (letfn\n    [(revtree [t]\n       (if (= t nil)\n          nil\n          (list (first t)\n                (revtree (second (rest t)))\n                (revtree (second t)))))]\n     (= tree (revtree tree))))", "problem": 96, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn T\n  ([t] (T (nth t 1) (nth t 2)))\n  ([l r] \n     (cond\n      (and (nil? l) (nil? r)) true\n      (= (first l) (first r)) (and (T (nth l 1) (nth r 2)) (T (nth l 2) (nth r 1)))\n      :else false)))", "problem": 96, "user": "4fd7962ee4b0dab7d829f385"}, {"code": "(fn [g]\n  (let [aux (fn aux [a b]\n              (or\n               (and (nil? a) (nil? b))\n               (and (= (first a) (first b))\n                    (aux (second a) (last b))\n                    (aux (last a) (second b)))))]\n    (aux (second g) (last g))))", "problem": 96, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [tree]\n  (letfn [(left [tree] (nth tree 1))\n          (right [tree] (nth tree 2))\n          (flip [tree]\n            (when tree\n              (list (first tree)\n                    (flip (right tree))\n                    (flip (left tree)))))]\n    (= (left tree) (flip (right tree)))))", "problem": 96, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [[p q r]] ((fn f [a b] (if (= nil a b) true (if (some nil?\n [a b]) false (let [[i j k] a [l m n] b]\n  (and (= i l) (f j n) (f k m)))))) q r))", "problem": 96, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn [[h l r]]\r\n  (letfn [(mirror [t]\r\n      (when (seq t)\r\n        (let [[h l r] t]\r\n          (list h (mirror r) (mirror l)))))]\r\n    (= l (mirror r))))", "problem": 96, "user": "4ff304f4e4b0678c553fc343"}, {"code": "(fn symmetric-tree? [tree]\n  (letfn [(tree-eq? [one two]\n    (if (and (nil? one) (nil? two)) \n      true\n      (and (= (first one) (first two))\n           (tree-eq? (second one) (nth two 2))\n           (tree-eq? (nth one 2) (second two)))))]\n  (if (nil? tree) true\n    (tree-eq? (second tree) (nth tree 2)))))", "problem": 96, "user": "4ff83003e4b0678c553fc396"}, {"code": "(fn [i]\n  (let [m (fn m [t]\n              (if t\n                (let [v (nth t 0)\n                      l (nth t 1)\n                      r (nth t 2)]\n                  [v (m r) (m l)])))]\n    (= i (m i))))", "problem": 96, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn [[_ top-left top-right]]\r\n  (letfn [(rev-bin-tree [[root left-b right-b :as tree]]\r\n            (if (coll? tree)\r\n              (lazy-seq [root (rev-bin-tree right-b) (rev-bin-tree left-b)])\r\n              tree))]\r\n    (= top-left (rev-bin-tree top-right))))", "problem": 96, "user": "4fabbb97e4b081705acca21d"}, {"code": "(fn mirrortree? [tree]\n    (= (nth tree 1)\n       ((fn invertree\n         ([tree] (if (nil? tree) nil (apply invertree tree))) \n         ([v l r] [v (invertree r) (invertree l)]))\n        (nth tree 2))))", "problem": 96, "user": "4fe83efbe4b07c9f6fd12c3b"}, {"code": "(fn [t]\n(letfn [(mirror [t]\n  (if (sequential? t)\n    ((if (list? t) list vector)\n     (first t)\n     (mirror (nth t 2))\n     (mirror (nth t 1)))\n    t))]\n  (if (nil? t)\n    true\n    (= (second t) (mirror (last t))))))", "problem": 96, "user": "4fde492be4b05e33b9224f8a"}, {"code": "(fn [n]\n  (letfn [(mirror [[v l r]]\n            [v (when r (mirror r)) (when l (mirror l))])]\n    (= n (mirror n))))", "problem": 96, "user": "4db2cd84535df7e46ed9b6c6"}, {"code": "(fn symmetric? [t]\n  (letfn [(flat-tree [f1 f2 s] (if (coll? s) (str (first s) (flat-tree f1 f2 (f1 s)) (flat-tree f1 f2 (f2 s))) \"N\"))]\n    (= (flat-tree second last (second t)) (flat-tree last second (last t)))))", "problem": 96, "user": "5003deb9e4b0678c553fc445"}, {"code": "(letfn\n  [(symmetric? [t1 t2]\n     (or\n       (and (nil? t1) (nil? t2))\n       (and\n         (= (first t1) (first t2))\n         (symmetric? (second t1) (nth t2 2))\n         (symmetric? (second t2) (nth t1 2)))))]\n  (fn [t] (symmetric? (second t) (nth t 2))))", "problem": 96, "user": "5002b6e5e4b0678c553fc42c"}, {"code": "(fn tree-sym?\r\n  [t]\r\n  (let [[v l r] t\r\n        f (fn sym?\r\n            [[vl ll rl] [vr lr rr]]\r\n            (and (= vl vr)\r\n              (or (and (nil? ll) (nil? rr))\r\n                (sym? ll rr))\r\n              (or (and (nil? rl) (nil? lr))\r\n                (sym? rl lr))))]\r\n    (f l r)))", "problem": 96, "user": "500159b3e4b0678c553fc419"}, {"code": "(fn tree-mirror? [col]\n  (= (second col)\n     ((fn mirror-tree [[v & childs]]\n       (cons v (map #(if (sequential? %) (mirror-tree %) %)\n         (reverse childs))))\n      (last col))))", "problem": 96, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "#(%1 %2 %2)\n(fn sym? [[v1 l1 r1] [v2 l2 r2]]\n  (cond\n    (not= v1 v2) false\n    (and (coll? l1) (coll? r2) (not (sym? l1 r2))) false\n    (and (coll? r1) (coll? l2) (not (sym? r1 l2))) false\n    (and (not (coll? l1)) (not= l1 r2)) false\n    (and (not (coll? r1)) (not= r1 l2)) false\n    :else true))", "problem": 96, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn sym? \n  ([t] (sym? (second t) (last t)))\n  ([a b] (or \n          (and (nil? a) (nil? b))\n          (if (and (coll? a) (coll? b))\n            (and (= (count a) (count b) 3)\n                 (= (first a) (first b))\n                 (sym? (second a) (last b))\n                 (sym? (last a) (second b)))\n            false))))", "problem": 96, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn b [[i l r]]\n  (letfn [(revtree [t]\n            (if (coll? t)\n              (let [[i l r] t]\n                [i (revtree r) (revtree l)])\n              t))]\n    (= l (revtree r))))", "problem": 96, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn symmetric? [tree]\n  (letfn [(rtree [tree]\n            (when tree\n              (let [[head left right] tree]\n                (list head (rtree right) (rtree left)))))]\n    (= tree (rtree tree))))", "problem": 96, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "#(= % ((fn f[[v l r :as n]] (when n [v (f r)(f l)])) %))", "problem": 96, "user": "4db13ff51254ad5b4805fa68"}, {"code": "(fn [ls]\n  (= (filter #(not (coll? %)) (tree-seq coll? #(cons (first %) (reverse (rest %))) (last ls)))\n    (filter #(not (coll? %)) (tree-seq coll? identity (second ls)))))", "problem": 96, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [t]\n  (letfn [(mt [t] (if (nil? t) t\n                      (list (first t) (mt (last t)) (mt (second t)))))]\n    (= t (mt t))))", "problem": 96, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn sym [t] (letfn [(left [x] (second x))\r\n                      (right [x] (nth x 2))\r\n                      (mirror? [l r]\r\n                        (if (nil? l)\r\n                          (nil? r)\r\n                          (and (not (nil? r))\r\n                            (= (first l) (first r))\r\n                            (mirror? (left l) (right r))\r\n                            (mirror? (right l) (left r)))))]\r\n                (mirror? (left t) (right t))))", "problem": 96, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn [tree]\n  (letfn [(flip [tree]\n            (if (nil? tree)\n              tree\n              (let [[key left right] tree]\n                (vector key (flip right) (flip left)))))]\n    (or (nil? tree)\n        (let [[_ left right] tree]\n          (= left (flip right))))))", "problem": 96, "user": "500ff421e4b0ae202717946f"}, {"code": "(fn [tree]\n    (letfn [(reverse-tree [t]\n    \t(let [[n l r] t]\n         [n\n          \t(if (nil? r) r (reverse-tree r))\n          \t(if (nil? l) l (reverse-tree l))]))]\n      \t\t(= tree (reverse-tree tree)))\n                 )", "problem": 96, "user": "4edd4b77535d10e5ff6f5328"}, {"code": "(fn symmetric-binary-tree? [tree]\n  (letfn [(binary-tree? [tree]\n            (or (= nil tree)\n                (and (coll? tree) (= (count tree) 3)\n                     (binary-tree? (nth tree 1))\n                     (binary-tree? (nth tree 2))\n                     (not (coll? (first tree))))))\n          (reverse-tree [tree]\n            (if (coll? tree)\n              (vector (nth tree 0)\n                      (reverse-tree (nth tree 2))\n                      (reverse-tree (nth tree 1)))\n              tree))]\n    (and (binary-tree? tree)\n         (= (nth tree 1) (reverse-tree (nth tree 2)))\n         (= (nth tree 2) (reverse-tree (nth tree 1))))))", "problem": 96, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "#(= %\r\n    ((fn f [[v l r :as n]]\r\n       (if n\r\n         [v (f r) (f l)]))\r\n     %))", "problem": 96, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [tree]\n  (letfn [(flatten-tree [tree]\n                        (if (seq tree)\n                          (let [[v l r] tree]\n                            (concat (flatten-tree l) [v] (flatten-tree r)))\n                          [\\*]))]\n         (let [ft (flatten-tree tree)]\n           (= ft (reverse ft)))) )", "problem": 96, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [x]\n  (=\n    (\n      (fn sm [y]\n        (if\n          (nil? y)\n          y\n          (concat\n            [(nth y 0)]\n            [(sm (nth y 2))]\n            [(sm (nth y 1))]\n          )\n        )\n      )\n      (nth x 1)\n    )\n    (nth x 2)\n  )\n)", "problem": 96, "user": "5017f840e4b02f523d7cc5e8"}, {"code": "#(= % ((fn revtree [[v l r]] ; symmetric if tree == reversed tree\n        (if v [v (revtree r) (revtree l)]))\n       %))", "problem": 96, "user": "500900dee4b0144d4f561e42"}, {"code": "#(= %\n    ((fn f [[v l r :as n]]\n       (if n\n         [v (f r) (f l)]))\n     %))", "problem": 96, "user": "4dae0510c9a9d6ed4b99dc57"}, {"code": "(fn [input]\n  (letfn [(in-order [node]\n            (cond (nil? node) []\n                  (not (coll? node)) (vector node)\n                  :else (concat (in-order (second node)) (in-order (first node)) (in-order (last node)))))]\n    (let [in (in-order input)]\n      (= in (reverse in))\n    )\n    )\n  )", "problem": 96, "user": "4faa6184e4b081705acca1f1"}, {"code": "(fn [[v l r]]\n (letfn [(treeq [t1 t2]\n   (or (every? nil? [t1 t2])\n       (let [[v1 l1 r1] t1 [v2 l2 r2] t2]\n         (and (= v1 v2) (treeq l1 r2) (treeq r1 l2)))))]\n   (treeq l r)))", "problem": 96, "user": "4fe4c09ee4b0e8f79898febb"}, {"code": "(fn s [[v [lv ll lr] [rv rl rr]]]\n  (when v\n    (every? true? (remove nil? (flatten [(= lv rv) (s [lv ll rr]) (s [rv lr rl])])))))", "problem": 96, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": ";; If the mirror of the right node = left node, then it's balanced\n;; Coersion to vector for equality check\n\n(fn [t]\n  (letfn [(mirror [tree]\n            (let [[root left right] tree]\n              (if (= nil left right) tree\n                  [root (mirror right) (mirror left)])))]\n    (let [[_ left right] t]\n    (= (vec left) (vec (mirror right))))))", "problem": 96, "user": "4e42f930535dc968683fc49f"}, {"code": "#(= % ((fn r [t] (if (coll? t) [(nth t 0) (r (nth t 2)) (r (nth t 1))] t)) %))", "problem": 96, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn sym [ [t r l] ]\n  (if (and (nil? r) (nil? l)) true\n  (let [[rt rr rl] r [lt lr ll] l]\n    (-> (= rt lt) (and (sym [rt rr ll]))\n      (and (sym [lt lr rl]))))))", "problem": 96, "user": "4fcf642ee4b03432b189f410"}, {"code": "(fn symtree [tree]\n    (let [eqnode (fn eqnode [left right]\n                   (cond\n                    (and (nil? left) (nil? right))\n                    true\n                    (and\n                     (= (first left) (first right))\n                     (eqnode (second left) (last right))\n                     (eqnode (second right) (last left)))\n                    true\n                    :else false))]\n      (eqnode (second tree) (last tree))))", "problem": 96, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn [tree]\n  (let [tree-equal? (fn tree-equal? [t1 t2]                    \n                      (and (= (nth t1 0) (nth t2 0))\n                           (= (count t1) (count t2))\n                           (if (empty? t1)\n                             true\n                             (and (tree-equal? (nth t1 2) (nth t2 1))\n                                  (tree-equal? (nth t1 1) (nth t2 2))))))]\n    (and (= (count tree) 3)(tree-equal? (nth tree 1) (nth tree 2)))))", "problem": 96, "user": "4ed8b598535d10e5ff6f52fc"}, {"code": "(fn sym [tree]\n  ((fn equalsTree [t1 t2] \n     (cond   \n       (= t1 t2 nil) true    \n       (not (coll? t1)) false   \n       (not (coll? t2)) false   \n       (= (first t1) (first t2)) (and           \n                                   (equalsTree (nth t1 1) (nth t2 2))                      \n                                   (equalsTree (nth t1 2) (nth t2 1))         \n                                   )    \n       :else false  \n       )\n     ) (second tree) (nth tree 2)\n))", "problem": 96, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn w [[_ [l m n]\n          [r s t]]]\n    (and (= l r)\n         (or (= nil m s)\n             (and \n                 (w [_ m t])\n                 (w [_ s n])))))", "problem": 96, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "(fn __ [tree]\n  (letfn \n    [(mirror-tree [t]\n  \t(if (not (sequential? t))\n          t\n          (list \n           (first t)\n           (mirror-tree (nth t 2))\n           (mirror-tree (nth t 1)))))]\n  (= (nth tree 1) (mirror-tree (nth tree 2)))))", "problem": 96, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [[_ l r]]\n  (letfn [(mirror [[x l r]]\n            (let [l (if l (mirror l) l)\n                  r (if r (mirror r) r)]\n              [x r l]))]\n    (= l (mirror r))))", "problem": 96, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn [tree]\n  (let [[v l r] tree\n        revTree \n          (fn reverseTree [t]\n            (if (coll? t) \n              (let [[v l r] t]\n                (list v (reverseTree r) (reverseTree l)))\n              t))\n       ]\n    (= l (revTree r))))", "problem": 96, "user": "502a5fa4e4b09e8f859a9fbd"}, {"code": "(fn [tree]\n  (let [\n    reorder (fn reorder [tree]\n      (if (coll? tree)\n        (let [[val left right] tree]\n          [(reorder left) val (reorder right)])\n        tree))\n    reordered (reorder tree)\n    flattened (flatten reordered)\n    reversed (reverse flattened)]\n    (= flattened reversed)))", "problem": 96, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "#(letfn [(sh [s]\r\n           (if (nil? s) nil \r\n            [(sh (nth s 1)) (first s) (sh (nth s 2))]))]\r\n  (let [x (sh %) f (flatten x)] \r\n    (= f (reverse f))))", "problem": 96, "user": "50336c6be4b0c6c1199c710f"}, {"code": "#(= % ((fn symmetric [[v lc rc]] [v (when rc (symmetric rc)) (when lc (symmetric lc))]) %))", "problem": 96, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [[v l r]]\n  (let \n    [flip \n      (fn f [[v l r]]\n        (when \n          (not (nil? v))\n          [v (f r) (f l)]))]\n      (= l (flip r))))", "problem": 96, "user": "502a9fdee4b095a7adb898b4"}, {"code": "#(let [f  (fn f [x]\n  (if (coll? x) (cons (first x) (reverse (map f (rest x))))\n    x))] (= % (f %)))", "problem": 96, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [s] \n  (let [m (fn m [[v l r]] \n    (when v (cons v (map m [r l]))))]\n    (= (nth s 1) (m (nth s 2)))))", "problem": 96, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn [n]\n          (let [value (fn [n] (first n))\n                l-child (fn  [n] (first (rest n)))\n                r-child (fn  [n] (first (rest (rest n))))\n                mirror (fn mirror [n]\n                         (if (nil? n)\n                           nil\n                           (list (value n) (mirror (r-child n)) (mirror (l-child n)))))]\n            (= n (mirror n))))", "problem": 96, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn [tree]\n  (letfn [(mirror [node]\n            (if (sequential? node)\n              [(first node)\n               (mirror (last node))\n               (mirror (second node))]\n              node))]\n    (= tree (mirror tree))))", "problem": 96, "user": "5014754de4b094324338f8e5"}, {"code": "(fn symmetric?-\n  ^{:doc \"96. Write a predicate to determine whether or not a given                                                                                                     \n  binary tree is symmetric.\"}\n  ([[value left right]] (symmetric?- left right))\n  ([[lvalue lleft lright] [rvalue rleft rright]]\n     (or (= nil lvalue rvalue)\n        (and (= lvalue rvalue) (symmetric?- lleft rright) (symmetric?- lright rleft)))))", "problem": 96, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(letfn\n  [(symmetric [[d l r]]\n    (= l (flip r)))\n   (flip [[d l r :as tree]]\n     (if (nil? tree)\n       nil\n       [d (flip r) (flip l)]))]\n  symmetric)", "problem": 96, "user": "50435852e4b034ff00315d22"}, {"code": "(fn issym [[head l r]]\r\n  (let [fliptree (fn fliptree [tree] (if (not (coll? tree)) tree\r\n    (let [[value l r] tree]\r\n      [value (fliptree r) (fliptree l)])))]\r\n  (= l (fliptree r))))", "problem": 96, "user": "4fb266a5e4b081705acca28c"}, {"code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "problem": 96, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [[a rt lt]]\n  ( = lt\n      ((fn rev [t]\n        (if (coll? t)\n          (cons (first t) (reverse (map rev (rest t))))\n          t))\n      rt)))", "problem": 96, "user": "502952c9e4b0b33e9bf6fdf1"}, {"code": "(fn symmetric? [[r lc rc]]\n  (let [tree-mirror (fn _mirror [x] (cond (not (sequential? x)) x\n                        :else (list (nth x 0) (_mirror (nth x 2)) (_mirror (nth x 1)))))]\n    (= lc (tree-mirror rc))))", "problem": 96, "user": "4f625f68e4b0defedf855fd2"}, {"code": "(fn sym [[v l r]]\n  (cond (nil? l) (nil? r)\n        (coll? l) (and (coll? r)\n                      (= (first l) (first r))\n                      (sym [nil (second l) (last r)])\n                      (sym [nil (last l) (second r)]))\n        :else (= l r)))", "problem": 96, "user": "5012ec0ae4b0c87326002230"}, {"code": "(fn sbt? [tree]\n  (let [bin-tree? (fn bin-tree? [nd]\n                    (or (nil? nd)\n                        (and (sequential? nd)\n                             (= 3 (count nd))\n                             (bin-tree? (nth nd 1))\n                             (bin-tree? (nth nd 2)))))\n        mirror  (fn mirror [coll]\n                  (if (empty? coll)\n                    nil\n                    (cond\n                     (and (sequential? (second coll)) (sequential? (last coll)))\n                     (cons (first coll) (cons (mirror (last coll)) (list (mirror (second coll))))) \n                     \n                     (sequential? (second coll))\n                     (cons (first coll) (cons (last coll) (list (mirror (second coll)))))\n                     \n                     (sequential? (last coll))\n                     (cons (first coll) (cons (mirror (last coll)) (list (second coll))))\n                     \n                     :else\n                     (cons (first coll) (reverse (rest coll)))\n                     )))]\n    (and (bin-tree? tree)\n         (or (not (sequential? tree))\n             (= (second tree)\n                (mirror (last tree))\n                )))))", "problem": 96, "user": "4efec33f535dcb61093f6a2a"}, {"code": "(fn [x]\n   (let [ [v l r] x \n         mirror (fn mirror [y]\n                  (if (coll? y)\n                    (vector (first y) (mirror (last y)) (mirror (second y)))\n                    y)) ]\n     (= l (mirror r))))", "problem": 96, "user": "5046b003e4b011c5dfee7727"}, {"code": "(fn is-symmetrical? [[_ l r]]\n  (or \n   (and (nil? l) (nil? r))\n   (let [[lv ll lr] l [rv rl rr] r]\n     (and\n      (= lv rv)\n      (is-symmetrical? [nil ll rr])\n      (is-symmetrical? [nil lr rl])))))", "problem": 96, "user": "4f2e0369e4b0d6649770a064"}, {"code": "#(letfn [(rotate [n]\r\n  (if-not (sequential? n) n\r\n    (let [[x l r] n] [x (rotate r) (rotate l)])))]\r\n  (= % (rotate %)))", "problem": 96, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn is-symmetric? [tree]\r\n  (letfn [(mirror-images? [tree1 tree2]\r\n            (if (nil? tree1)\r\n              (nil? tree2)\r\n              (and (= (first tree1) (first tree2))\r\n                   (mirror-images? (second tree1) (nth tree2 2))\r\n                   (mirror-images? (nth tree1 2) (second tree2)))))]\r\n    (mirror-images? (second tree) (nth tree 2))))", "problem": 96, "user": "4fe54ee8e4b0e8f79898fec3"}, {"code": "(fn [t]\n  (letfn [(rev-t [t] (if (nil? t) nil [(nth t 0) (rev-t (nth t 2)) (rev-t (nth t 1))]))]\n    (= t (rev-t t))))", "problem": 96, "user": "4f1abbfb535d64f60314646e"}, {"code": "(fn [[_ l r]]\n  (letfn\n    [(sym-tree? [l r]\n      (cond\n        (and (nil? l) (nil? r)) true\n        (and (nil? l) (not (nil? r))) false\n        (and (not (nil? l)) (nil? r)) false\n        :else\n          (and\n            (= (first l) (first r))\n            (sym-tree? (nth l 1) (nth r 2))\n            (sym-tree? (nth l 2) (nth r 1)))))]\n    (sym-tree? l r)))", "problem": 96, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn [x] (= (second x)\r\n           ((fn re [x] \r\n              (if (coll? x)\r\n                (vector (first x) (re (last x)) (re (second x)))\r\n                x))\r\n            (last x))))", "problem": 96, "user": "503354c3e4b0c6c1199c710c"}, {"code": "#(letfn [(mi? [t1 t2] (cond (and (nil? t1) (nil? t2)) true (= (first t1) (first t2)) (and (mi? (nth t1 1) (nth t2 2)) (mi? (nth t1 2) (nth t2 1))) :else false))] (mi? (nth % 1) (nth % 2)))", "problem": 96, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn sym-bin-tree? [[node left right]]\n  (letfn \n    [(mirror [[node left right :as tree] count]\n      (cond\n        (nil? node) nil\n        (and (nil? left) (nil? right)) tree\n        (even? count) [node (mirror right (inc count)) left]\n        :else [node right (mirror left (inc count))]))]\n    (= (mirror left 0) right)))", "problem": 96, "user": "501c1492e4b086d93747d180"}, {"code": "(fn [[v l r]]\r\n  (letfn [(m [[v & xs]]\r\n            (cons v (mapcat m (reverse xs))))]\r\n    (= (flatten l) (m r))))", "problem": 96, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn sym-tree?\n  [t]\n  (reduce #(and %1 %2) (map = t \n  ((fn swap-tree [tr] (if (not (coll? tr)) tr\n                    (let [[n l1 l2] tr] (vector n \n                            (swap-tree l2) \n                            (swap-tree l1))))) t))))", "problem": 96, "user": "4fc5a693e4b0ee37620e17fc"}, {"code": "(fn [tr]\n  (letfn [(left [t] (second t))\n          (right [t] (nth t 2))\n          (flip [[tag l r]]\n            [tag\n              (if (nil? r) nil (flip r))\n              (if (nil? l) nil (flip l))])\n          ]\n  (= (left tr) (flip (right tr)))))", "problem": 96, "user": "50427899e4b0add3005c0fc2"}, {"code": "#((fn sym? [l r]\r\n  (if (not (sequential? l)) (= l r)\r\n    (if (not= (first l) (first r)) false\r\n      (let [ll (second l) lr (nth l 2)\r\n            rl (second r) rr (nth r 2)]\r\n        (and (sym? ll rr)\r\n             (sym? rl lr))))))\r\n(second %) (nth % 2))", "problem": 96, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn symmetric? [tree] (let [revtree (fn revtree [t]\n  (if t [(first t) (revtree (nth t 2)) (revtree (nth t 1))] nil))]\n    (or (nil? tree) (= (nth tree 1) (revtree (nth tree 2))))\n))", "problem": 96, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn [[_ l r]]\n  (letfn\n    [(walk [children root]\n      (map first (tree-seq coll? children root)))]\n    (=\n      (walk rest l)\n      (walk (comp reverse rest) r))))", "problem": 96, "user": "4fe97adde4b0547ebccb245e"}, {"code": "#((fn tq? [l r]    \n  (cond       \n    (and (nil? l) (nil? r)) true      \n    (or (nil? l) (nil? r)) false      \n    :else   (and (identical? (first l) (first r))\n                 (tq? (nth r 1) (nth l 2))\n                 (tq? (nth r 2) (nth l 1))))) % %)", "problem": 96, "user": "504e397ee4b0f6ff3350c485"}, {"code": "(fn beautyIsSymmetry2 [[a b c]]\n  (= b\n     (\n      (fn rever [[ x y z]]\n        (letfn  [( colls [aa] \n                   (if (coll? aa) (rever aa) ))]\n          (vector x (colls z) (colls y))))\n      c)))", "problem": 96, "user": "4fb23582e4b081705acca28a"}, {"code": "(fn [[_ l r]]\n (letfn\n  [\n   (mirror [t]\n    (when-let [[v l r] t]\n     [v (mirror r) (mirror l)]\n    )\n   )\n  ]\n  (= l (mirror r))))", "problem": 96, "user": "5041b3c0e4b06d8231e4facf"}, {"code": "(fn [[_ l r]]\n    ((fn g [[a b c] [d e f]]\n     (if a\n       (and (= a d)\n            (g b f)\n            (g c e))\n       true)) l r))", "problem": 96, "user": "5055899de4b0ce54f56f03fd"}, {"code": "(fn symmetric? [tree]\n  (letfn [(flip [tree]\n            (when-let [[v l r] tree]\n              [v (flip r) (flip l)]))]\n    (= tree (flip tree))))", "problem": 96, "user": "50586354e4b06522596eba78"}, {"code": "(fn symmetric? [[node left right :as tree]]\n    (letfn [(deep-reverse [tree]\n              (when tree\n                (let [[node left right] tree]\n                  (list node (deep-reverse right) (deep-reverse left)))))]\n      (= left (deep-reverse right))))", "problem": 96, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(let \n  [flip (fn flip [tr] (if (nil? tr) nil\n(let [[v l r] tr] [v (flip r) (flip l)])))]\n(fn [tree] (= tree (flip tree))))", "problem": 96, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn ?\n([t] (? (nth t 1) (nth t 2)))\n([a b]\n  (if (every? coll? [a b])\n    (and\n      (= (first a) (first b))\n      (? (nth a 1) (nth b 2))\n      (? (nth a 2) (nth b 1)))\n    (= a b))))", "problem": 96, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn [t]\n  (let [third #(second (rest %))]\n    ((fn m [t1,t2]\n      (or (and (nil? t1) (nil? t2))\n        (and (= (first t1) (first t2))\n             (m (second t1) (third t2))\n             (m (third t1) (second t2))))) t t)))", "problem": 96, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn f [[_ ll rr]]\n  (letfn [(revtree [[v l r :as n]]\n            (if (nil? n) n \n              [v (revtree r) (revtree l)]))]\n    (= ll (revtree rr)))\n  )", "problem": 96, "user": "502bb7c0e4b0194ad32ea1a3"}, {"code": "; daowen's solution:\n; (fn sym-tree? [[v l r]]\n;   (letfn [(lr-rev [t]\n;                   (if (nil? t) t\n;                     (let [[v l r] t]\n;                       [v (lr-rev r) (lr-rev l)])))]\n;     (= l (lr-rev r))))\n\n; THIS DOES NOT WORK\n(fn is-tree-symmetric? [t]\n  (if (or (= t [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] nil]] nil]])\n    (= t [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])) false\n  (loop [q (vector t) pushes 1]\n    (let [n (first q)\n          v (first n)\n          l (second n)\n          r (nth n 2 nil)\n          halves (split-at (/ (count q) 2) q)]\n      (println \"\\nq:\" q)\n      (println \"pushes\" pushes)\n      (println \"n:\" n)\n      (println \"l:\" l)\n      (println \"r:\" r)\n      (println \"size:\" (count q))\n      (println \"halves:\" halves)\n      (when (some (partial = pushes) '(3 15 31 63 127))\n        (println \"1st half:\" (map first (first halves)))\n        (println \"2nd half:\" (map first (reverse (second halves)))))\n      (cond\n       (empty? q) true\n       (and (some (partial = pushes) '(3 15 31 63 127)) (not (= (map first (first halves)) (map first (reverse (second halves)))))) false\n       (and (not (nil? l)) (not (nil? r))) (recur (conj (vec (rest q)) l r) (+ pushes 2))\n       (and (nil? l) (nil? r)) (recur (vec (rest q)) (+ pushes 2))\n       (not (nil? l)) (recur (conj (vec (rest q)) l nil) (+ pushes 2))\n       (not (nil? r)) (recur (conj (vec (rest q)) nil r) (+ pushes 2)))))))", "problem": 96, "user": "4fc6d2c1e4b0ee37620e181b"}, {"code": "(fn [t]\n  (let [[v l r] t]\n    (letfn [(teq? [t1 t2]\n              (if (every? nil? (list t1 t2))\n                true\n                (let [[v1 l1 r1] t1\n                      [v2 l2 r2] t2]\n                  (and (= v1 v2) (teq? l1 r2) (teq? r1 l2))\n                  )))]\n      (teq? l r))))", "problem": 96, "user": "4ee528fb535d1385b2869d87"}, {"code": "(fn sym-tree [tree]\n   (letfn [(symmetric? [t1 t2] (and (= (first t1) (first t2))\n                                    (or (and (nil? (nth t1 1)) (nil? (nth t2 2)))\n                                        (symmetric? (nth t1 1) (nth t2 2)))\n                                    (or (and (nil? (nth t1 2)) (nil? (nth t2 1)))\n                                        (symmetric? (nth t1 2) (nth t2 1)))))]\n     (and (= 3 (count tree))\n          (symmetric? (nth tree 1) (nth tree 2)))))", "problem": 96, "user": "4ed98b40535d10e5ff6f5307"}, {"code": "(fn [tree]\n  (let [str ((fn flatten-tree [in out]\n               (if-let [[val left right] in]\n                 (concat (flatten-tree left out) (list val) (flatten-tree right out) out)\n                 (cons nil out)))\n             tree\n             nil)\n        l (count str)\n        mid (/ l 2)\n        start (take mid str)\n        end (take mid (reverse str))]\n    (= start end)))", "problem": 96, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "#(= % ((fn r [a] (if-let [[x y z] (if (coll? a) a)] [x (r z) (r y)] a)) %))", "problem": 96, "user": "4f045946535dcb61093f6bba"}, {"code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "problem": 96, "user": "4e14b925535d04ed9115e7df"}, {"code": "(fn mirror? [t] (let [mirror (fn mirror [[v l r]] (if (nil? v) nil [v (mirror r) (mirror l)]))]\n                   (= t (mirror t))))", "problem": 96, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [[_ a b]]\r\n  (= b ((fn f [[v a b :as t]]\r\n          (and t [v (f b) (f a)])) a)))", "problem": 96, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [tree]\n    (letfn [(exchange [[val left right :as t]]\n              [val\n               (if (and (coll? right) (not (empty? right)))\n                 (exchange right)\n                 right)\n               (if (and (coll? left) (not (empty? left)))\n                 (exchange left)\n                 left)])]\n      (= (exchange (nth tree 1)) (nth tree 2))))", "problem": 96, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [tree]\r\n  (let [mirror-tree \r\n    (fn mt \r\n      ([v] (if (nil? v) v (apply mt v)))\r\n      ([v a b] (vector v (mt b) (mt a))))]\r\n    (= tree (mirror-tree tree))))", "problem": 96, "user": "5060d137e4b0dc10a69545a0"}, {"code": "(fn sym?\n          ([t] (sym? (second t) (last t)))\n          ([a b] (or\n                  (and (nil? a) (nil? b))\n                  (if (and (coll? a) (coll? b))\n                      (and (= (count a) (count b) 3)\n                           (= (first a) (first b))\n                           (sym? (second a) (last b))\n                           (sym? (last a) (second b)))\n                    false))))", "problem": 96, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn [tree]\n  (letfn \n    [(mirror [t] \n      (if (nil? t) \n          t \n          [(first t) (mirror (last t)) (mirror (second t))]))]\n    (= (flatten (mirror (second tree))) (flatten (last tree)))))", "problem": 96, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn [[x l r]]\n    (letfn [(m [t]\n      (when-let [[x l r] t]\n        [x (m r) (m l)]))]\n      (= (m l) r)))", "problem": 96, "user": "50657775e4b0deb876850599"}, {"code": "(fn \r\n  [root]\r\n  (and \r\n    (letfn [(tree? [t] \r\n      (let [[v l r] t]      \r\n        (or \r\n          (nil? t)\r\n          (and\r\n            (sequential? t)\r\n            (= (count t) 3)\r\n            (tree? l)\r\n            (tree? r)\r\n            ))      \r\n        ))]\r\n      (tree? root)))\r\n    (letfn [(mirror? [[vx lx rx] [vy ly ry]]\r\n      (and \r\n        (= vx vy)\r\n        (if (nil? lx) \r\n          (nil? ry) \r\n          (mirror? lx ry))\r\n        (if (nil? rx) \r\n          (nil? ly) \r\n          (mirror? rx ly))\r\n        ))]\r\n     (mirror? (second root) (nth root 2)))\r\n  )", "problem": 96, "user": "4fee04a0e4b0678c553fc308"}, {"code": "(fn tree-symmetric? [t]\n  (letfn [(mirror [t]\n            (if (nil? t)\n              nil\n              (let [[top left right] t]\n                [top (mirror right) (mirror left)])))]\n    (= t (mirror t))))", "problem": 96, "user": "4e8338d6535db62dc21a62d3"}, {"code": "#(let [m (fn m [n]\n  (if (coll? n)\n    (cons (first n) (map m (reverse (rest n))))\n    n))]\n    (= (second %) (m (nth % 2))))", "problem": 96, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "#(= (nth % 1)\n   ((fn r [t] \n     (if (nil? t) \n       nil\n       [(first t) (r (nth t 2)) (r (nth t 1))]\n       )) (nth % 2))\n      )", "problem": 96, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [c]\r\n  ((fn s? [a b]\r\n      (or (= a b nil)\r\n    (and (coll? a)\r\n\t       (coll? b)\r\n\t       (= (nth a 0) (nth b 0))\r\n\t       (s? (nth a 1) (nth b 2))\r\n\t       (s? (nth a 2) (nth b 1)))))\r\n   (nth c 1) (nth c 2)))", "problem": 96, "user": "507437c2e4b054001656acd0"}, {"code": "(fn s [[_ [v1 l1 r1 :as a] [v2 l2 r2 :as b]]]\n  (or (= nil a b)\n      (and (= v1 v2)\n           (s [_ l1 r2])\n           (s [_ r1 l2]))))", "problem": 96, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn tree-mirror? [[v left right :as tree]]\n  (let [mirror\n        (fn mirror [[v l r :as t]]\n          (if (nil? t) nil (list v (mirror r) (mirror l))))]\n    (or (nil? tree)\n        (= left (mirror right)))))", "problem": 96, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn [coll]\n  (letfn [(rev-tree [[root c1 c2 :as body]]\n            (if (coll? body)\n              (lazy-seq [root (rev-tree c2) (rev-tree c1)])\n              body))]\n    (= coll (rev-tree coll))))", "problem": 96, "user": "50052fd0e4b0678c553fc45d"}, {"code": "(fn sym* [t]\n   (letfn [[single [t] (or (nil? t) (= (count t) 1))]\n           [dual [t]\n             (if (single t) t\n                (let [[v l r] t]\n                    [v (dual r) (dual l)]))]]\n     (= t (dual t))))", "problem": 96, "user": "507db411e4b03c76e5499e06"}, {"code": "#(let [mirror (fn m[n] ( if (nil? n)\n                                  n\n                                  (list (first n) (m (last n)) (m (second n)))\n                             ))\n             ] \n          (= (second %) (mirror (last %))))", "problem": 96, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "#(=\n  ((fn r [v] (if (coll? v)\n    [(first v) (r (nth v 2)) (r (nth v 1))]\n    v)) %)\n  %)", "problem": 96, "user": "505d4b21e4b0e6aca564be07"}, {"code": "(fn [[_ l r]]\n  (letfn [(m [[v l r :as t]]\n            (when t\n              [v (m r) (m l)]))]\n    (= (m l) r)))", "problem": 96, "user": "4f301d02e4b0d6649770a072"}, {"code": "(let [\nfl (fn fl [t] (cond\n(nil? t) [123456789]\n:else (concat [(first t)] (fl (nth t 1)) (fl (nth t 2))\n      )\n))\nfr (fn fr [t] (cond\n(nil? t) [123456789]\n:else (concat [(first t)] (fr (nth t 2)) (fr (nth t 1))\n      )\n))\n]\n(fn sym [t] (every? true?\n  (map =\n   (fl (nth t 1)) \n   (fr (nth t 2))\n  )\n))\n\n)", "problem": 96, "user": "50807940e4b01a93d3f38e44"}, {"code": "(fn [[_ L R]]\n  (letfn [(mirror [[x l r]] (if (nil? x) x [x (mirror r) (mirror l)]))]\n    (= L (mirror R))\n  )\n)", "problem": 96, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn mirror? [x]\r\n  (letfn [(b= [t s]\r\n              (and\r\n                (btree? t)\r\n                (btree? s)\r\n                (let [[t1 t2 t3] t\r\n                      [s1 s2 s3] s]\r\n                  (and (= t1 s1)\r\n                       (or (and (nil? t2) (nil? s3))\r\n                           (b= t2 s3))\r\n                       (or (and (nil? t3) (nil? s2))\r\n                           (b= t3 s2))))))\r\n          (btree? [t]\r\n                  (and\r\n                    (sequential? t)\r\n                    (= 3 (count t))\r\n                    (let [[val left right] t]\r\n                      (and\r\n                        (not (sequential? val))\r\n                        (not (nil? val))\r\n                        (or (nil? left) (btree? left))\r\n                        (or (nil? right) (btree? right))))))]\r\n  (and (btree? x)\r\n       (let [[p q r] x]\r\n         (b= q r)))))", "problem": 96, "user": "4dc97aec535d5973398f9284"}, {"code": "(fn symmetrical? [[v l r]]\n   (letfn [(walk-tree [[v l r] acc dir]\n           (cond (and (nil? l) (nil? r)) (conj acc v)\n                 (nil? l) (walk-tree r (conj acc v) dir)\n                 (nil? r) (walk-tree l (conj acc v) dir)\n                 :else\n                 (if (= dir :l)\n                   (walk-tree l (walk-tree r (conj acc v) dir) dir)\n                   (walk-tree r (walk-tree l (conj acc v) dir) dir)\n                   )))]\n\n     (= (walk-tree l [] :l) (walk-tree r [] :r))\n   ))", "problem": 96, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "#(= % ((fn m [[v l r]] (if v [v (m r) (m l)])) %))", "problem": 96, "user": "5088082ae4b0198722bd9854"}, {"code": "(fn mirrortree? [tr]\n   (let [[_ l r] tr]\n   (or (and (= l nil)\n            (= r nil)\n            (= l r))\n       (and (sequential? l)\n            (sequential? r)\n            (let [[la lb lc] l, [ra rb rc] r]\n              (and (= la ra)\n                   (mirrortree? [la lb rc])\n                   (mirrortree? [la rb lc])\n                   ))\n            ))))", "problem": 96, "user": "5084cb7de4b0fb8f40674bfb"}, {"code": "(fn [[_ left right]]\n  (letfn [(symm? [[lv ll lr :as l] [rv rl rr :as r]]\n    (or\n      (and (nil? l) (nil? r))\n      (and\n        (= lv rv)\n        (symm? ll rr)\n        (symm? lr rl))))]\n    (symm? left right)))", "problem": 96, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [bt]\n  (= bt ((fn mirror [t] (if (nil? t) t (let [[v l r] t] [v (mirror r) (mirror l)]))) bt)))", "problem": 96, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn symmetric [root]\n  (letfn [(get-node-val-left [node] \n\t\t    (if (coll? node) \n\t\t\t\t(list (first node) (get-node-val-left (second node)) (get-node-val-left (nth node 2))) \n\t\t\t\t(first node)))\n\t\t\t(get-node-val-right [node] \n\t\t\t\t    (if (coll? node) \n\t\t\t\t\t\t(list (first node) (get-node-val-right (nth node 2)) (get-node-val-right (second node))) \n\t\t\t\t\t\t(first node)))]\n\t(= (get-node-val-left (second root)) (get-node-val-right (nth root 2)))\t\t\t\n\t)\n)", "problem": 96, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [s] (letfn [\n          (check-sym [l r]\n            (if (= (nth l 0) (nth r 0))\n             (and (cmp-nodes (nth l 1) (nth r 2)) (cmp-nodes (nth l 2) (nth r 1)))\n             false))\n           (cmp-nodes [a b]\n             (if (and (sequential? a) (sequential? b))\n              (check-sym a b)\n              (= a b)))]\n   (check-sym (nth s 1) (nth s 2))))", "problem": 96, "user": "50783762e4b0fc74642bff67"}, {"code": "(do\n  (fn sym [ [_ left right] ]\n    (letfn [\n      (mirror [left right]\n        (or (and (nil? left) (nil? right))\n          (let [\n            [lv lleft lright] left \n            [rv rleft rright] right]\n              (and (= lv rv)\n                (mirror lleft rright)\n                (mirror lright rleft)))))\n        ]\n    (mirror left right)))\n\n;;;;;;;;;;;;;;;;;;;\n\n(fn mirror [ [_ left right] ]\n  (or (and (nil? left) (nil? right))\n    (let [\n      [lv lleft lright] left \n      [rv rleft rright] right]\n        (and (= lv rv)\n          (mirror [_ lleft rright])\n          (mirror [_ lright rleft])))))\n)", "problem": 96, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn f [tree]\r\n (letfn\r\n  [(mr [pt]\r\n   (if-not (nil? pt)\r\n    (vector (first pt) (mr (nth pt 2)) (mr (nth pt 1)))\r\n    nil))]\r\n (= tree (mr tree))))", "problem": 96, "user": "506fd0afe4b07bd6ad9b9f23"}, {"code": "(let \n  [sym (fn sym[[h1 l1 r1] [h2 l2 r2]]\n  (and (= h1 h2)\n     (or (= nil h1 h1)\n         (and (sym l1 r2) (sym r1 l2)))))]\n#(sym(second %) (last %)))", "problem": 96, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [s]\r\n   (or\r\n     (nil? s)\r\n     (and\r\n       (coll? s)\r\n       (= 3 (count s))\r\n       (let [reflect (fn f [n]\r\n                         (let [l (nth n 1)\r\n                               r (nth n 2)\r\n                               v (nth n 0)\r\n                               rr  (if (nil? r) nil (f r))\r\n                               lr  (if (nil? l) nil (f l))]\r\n                             [v rr lr]))\r\n            rs (reflect s)]\r\n          (= s rs)))))", "problem": 96, "user": "4faf2f4ce4b081705acca251"}, {"code": "#(let \n  [rtree (fn rt [[v l r :as t]] (if (coll? t)\n                                     (list v (rt r) (rt l))\n                                      nil))\n       a (nth % 1)\n       b (rtree (nth % 2))]\n  (= a b))", "problem": 96, "user": "507a396be4b08327cd804a69"}, {"code": "(fn [t]\n  (letfn\n    [(third [s] (first (rest (rest s))))\n     (in-order [t]\n      (when t\n        (concat (in-order (second t))\n                [(first t)]\n                (in-order (third t)))))]\n    (= (in-order (second t))\n       (reverse (in-order (third t))))))", "problem": 96, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn [[n l r]]\n    (= r ((fn rev [[n l r]]\n              [n\n               (if (nil? r) nil (rev r))\n               (if (nil? l) nil (rev l))]) l)))", "problem": 96, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn [t] (\n        (fn f [t1 t2]\n          (if-not (or t1 t2)\n            (= t1 t2)\n            (let [[p1 l1 r1] t1\n                  [p2 l2 r2] t2]\n              (and (= p1 p2)\n                   (f l1 r2)\n                   (f l2 r1))))) t t))", "problem": 96, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [x]\n  (let [test\n          (fn test [src]\n            (cond (not (counted? src)) (nil? src)\n                  (not (= 3 (count src))) false\n                  :else (reduce #(and (test %1) (test %2)) (rest src))))\n        reverse-all \n          (fn reverse-all [src]\n            (when (counted? src)\n              [(first src) (reverse-all (last src)) (reverse-all (second src))]))]\n  (and (= (last x) (reverse-all (second x))) (test x))))", "problem": 96, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn[t]\n   (letfn [(eq-t [a,b]\n                (or (and (nil? a) (nil? b))\n                    (and (= 3 (count a))\n                         (= 3 (count b))\n                         (= (first a) (first b))\n                         (eq-t (nth a 1) (nth b 2))\n                         (eq-t (nth a 2) (nth b 1))\n                         )\n                ))]\n     (eq-t (nth t 1) (nth t 2))))", "problem": 96, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "#((fn m [l r]\n     (if (or (= nil l r)\n             (and (= (nth l 0) (nth r 0))\n                  (m (nth l 1) (nth r 2))\n                  (m (nth l 2) (nth r 1))))\n       true false)) \n   (nth % 1) (nth % 2))", "problem": 96, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn [t]\r\n  ((fn mirror? [l r]\r\n     (if (or (= nil l r)\r\n             (and (= (first l) (first r))\r\n                  (mirror? (second l) (last r))\r\n                  (mirror? (last l) (second r))))\r\n       true false)) \r\n   (second t) (last t)))", "problem": 96, "user": "4dad76588e77d6ed63f12a44"}, {"code": "#(let [[_ l r] %]\n  (= l\n    ((fn tree-rev [n]\n    (let [[i l r] n]\n      (if (nil? i)\n        i\n        (list i (tree-rev r) (tree-rev l))))) r)))", "problem": 96, "user": "4fccb31be4b0ee37620e1868"}, {"code": "(fn symmetric? [t]\n    (let [root (fn [t] (first t))\n          left (fn [t] (second t))\n          right (fn [t] (nth t 2))\n          same? (fn same? [t1 t2]\n                  (cond (= t1 t2 nil)\n                        true\n                        \n                        (= (root t1)\n                           (root t2))\n                        (and (same? (left t1)\n                                    (right t2))\n                             (same? (right t1)\n                                    (left t2)))\n                        \n                        :else\n                        false))\n          \n          ]\n      (same? (left t)\n             (right t)))\n    \n    \n    )", "problem": 96, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [[v l r]]\n  (let\n    [mirror\n      (fn mirror [t]\n        (if (nil? t)\n          nil\n          (let [[v2 l2 r2] t]\n            [v2 (mirror r2) (mirror l2)])))]\n    (= l (mirror r))))", "problem": 96, "user": "4fb1325de4b081705acca276"}, {"code": "(fn t-sym [t]\n  (letfn [(tree-same [t1 t2]\n            (cond\n             (and (nil? t1) (nil? t2)) true\n             (or (nil? t1) (nil? t2)) false\n             :else (let [[a t1-l t1-r] t1\n                         [b t2-l t2-r] t2]\n                     (and (= a b)\n                          (tree-sym [nil t1-l t2-r])\n                          (tree-sym [nil t1-r t2-l])))))\n          (tree-sym [t]\n            (if (nil? t)\n              true\n              (let [[_ left right] t]\n                (tree-same left right))))\n          ]\n    (tree-sym t)))", "problem": 96, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(letfn [(flatten-right [[root left right]]\n  (concat [root] \n          (if (nil? right) \n            [nil]\n            (flatten-right right))\n          (if (nil? left)\n            [nil]\n            (flatten-right left))))]\n  #(= (flatten %) (flatten-right %)))", "problem": 96, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "#(let [l (nth % 1)\n       r (nth % 2)]\n  (= l ((fn rv [t] (if (coll? t) [(first t) (rv (nth t 2)) (rv (nth t 1))] t)) r)))", "problem": 96, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn [[_ rt lt]]\n  (= rt ((fn rv [n] (if-let [[h l r] n] [h (rv r) (rv l)])) lt)))", "problem": 96, "user": "509b89b3e4b03049c49bd678"}, {"code": "(fn t [[n left right]]\n  (letfn [(mirror [a b]\n            (if (coll? a)\n                \n                (and (= (first a) (first b))\n                     (mirror (nth a 1) (nth b 2))\n                     (mirror (nth b 1) (nth a 2))\n                   )\n\n                (= a b)\n            )\n          )]\n    (mirror left right)\n  )\n)", "problem": 96, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(letfn [(mirror [t]\n          (if (sequential? t) [(first t) (mirror (last t)) (mirror (second t))] t))]\n  (fn [[v l r]] (= l (mirror r))))", "problem": 96, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn [[_ n m]]\r\n        (letfn [(f[[v n m]]\r\n                  (if v [v (f m) (f n)]))]\r\n          (= n (f m))))", "problem": 96, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn [[x l r]]\n  (letfn [(mirror [x] \n                  (if (sequential? x)\n                    (let [[a b c] x]\n                      [a (mirror c) (mirror b)])\n                    x))]\n    (= l (mirror r))))", "problem": 96, "user": "4e7f32ee535db966e863cc3a"}, {"code": "(fn [t]\r\n   ((fn mir? [l r]\r\n      (if (or (= nil l r)\r\n              (and (= (first l) (first r))\r\n                   (mir? (second l) (last r))\r\n                   (mir? (last l) (second r))))\r\n        true false)) \r\n    (second t) (last t)))", "problem": 96, "user": "50ab44b2e4b0f65d68208509"}, {"code": "(fn [x]\n  ((fn foo [l r]\n    (if (or (= nil l r)\n        (and (= (first l) (first r))\n             (foo (second l) (last r))\n             (foo (last l) (second r))))\n    true false)\n   )(second x) (last x)))", "problem": 96, "user": "5078300de4b0fc74642bff66"}, {"code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror2? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror2? La Rb) (mirror2? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "problem": 96, "user": "50ae22c3e4b0a40c9cfb08d0"}, {"code": "(fn [t]\r\n  (letfn [(mirr [t]\r\n            (when t\r\n              (let [[v a b] t]\r\n                (vector v (mirr b) (mirr a)))))]\r\n    (= t (mirr t))))", "problem": 96, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [t]\n  (=\n    (remove sequential? (tree-seq sequential? identity t))\n    (remove sequential? (tree-seq sequential? #(vector (first %) (last %) (second %)) t))))", "problem": 96, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn symmetry? [[_ l r]]\n  (let [flip (fn flip [node]\n               (if (coll? node)\n                 (let [[tp lt rt] node]\n                   [tp (flip rt) (flip lt)])\n                 node))]\n    (= l (flip r))))", "problem": 96, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn [[a t1 t2]]\n  (let [sym (fn s [t]\n    (if (nil? t) \n      nil\n      [(first t) (s (last t)) (s (second t))]))]\n  (= t1 (sym t2))))", "problem": 96, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [t] (apply \n         (fn sim [l r] (if (and (sequential? l) (sequential? r))\n  \t\t(and (= (first l) (first r)) \n         \t\t(sim (second l) (nth r 2))\n         \t\t(sim (nth l 2) (second r)))\n    \t\t(= l r)))\n         (rest t)))", "problem": 96, "user": "5097a95fe4b00ad8bab4e96e"}, {"code": "#(= ((fn f [[v l r]]\n      (if v [v (f r) (f l)])) %)\n    %)", "problem": 96, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn [[root l r]]\n  (letfn [(invert [[root l r]] [root (if r (invert r) r) (if l (invert l) l)])]\n    (= (invert l) r)))", "problem": 96, "user": "4f3e5e87e4b0e243712b1f83"}, {"code": "#(letfn [(r [l]\n           (if (sequential? l)\n               (cons (first l)(map r (reverse (rest l))))\n               l))]\n   (= % (r %)))", "problem": 96, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [xs]\n  (letfn [(xseq [t]\n            (when t\n  \t          (concat (xseq (nth t 1)) [(first t)] (xseq (nth t 2)))))]\n    (let [left (comp xseq #(nth % 1))\n          rright (comp reverse xseq #(nth % 2))]\n      (= (left xs) (rright xs)))))", "problem": 96, "user": "4fc93728e4b0ee37620e1844"}, {"code": "(fn [[v lt rt]]\n  (letfn [\n          (lrcomp [l r]\n          (or (and (nil? l) (nil? r))\n              (let [[vl ll rl] l [vr lr rr] r]\n                (and (= vl vr)\n                     (lrcomp ll rr)\n                     (lrcomp rl lr)))))]\n    (lrcomp lt rt)))", "problem": 96, "user": "502ade49e4b0614b52996120"}, {"code": "#(let [mirror (fn mr ([])\n                ([v a1 a2] [v (apply mr a2) (apply mr a1)]))]\n  (= % (apply mirror %)))", "problem": 96, "user": "50052d38e4b0678c553fc45c"}, {"code": "(fn [[n l r]]\n  ((fn m [t1 t2]\n    (cond (= [t1 t2] [nil nil]) true\n          (and t1 t2)\n            (let [[n1 l1 r1] t1\n                  [n2 l2 r2] t2]\n              (and (= n1 n2)\n                   (m l1 r2)\n                   (m r1 l2)))\n          :else false\n          )) l r))", "problem": 96, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn [[_ l r]]\r\n    (letfn [(mirror [t]\r\n              (when-let [[v l r] t]\r\n                [v (mirror r) (mirror l)]))]\r\n      (= l (mirror r))))", "problem": 96, "user": "50436470e4b034ff00315d23"}, {"code": "(fn [t] (letfn [(mb [l r]\n                         (if (nil? l ) (nil? r)\n                            (if (not= (first l)  (first r))\n                              false\n                              (and (mb (nth l 1) (nth r 2))\n                                   (mb (nth l 2) (nth r 1))\n                                   )))\n                         )]\n                   \n                   (mb t t)))", "problem": 96, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn [coll]\n  (and\n    ((fn f [c]\n      (and\n        (coll? c)\n        (== (count c) 3)\n        (every?\n          #(or\n            (nil? %)\n            (f %))\n          (rest c)))) coll)\n    (=\n      (second coll)\n      ((fn rev [c]\n        (if (coll? c)\n          (let [s (second c)\n                t (nth c 2)]\n            (vector\n              (first c)\n              (rev t)\n              (rev s)))\n          c))\n        (nth coll 2)))))", "problem": 96, "user": "4f253a49e4b0d66497709ff3"}, {"code": "(fn is-symm-tree? [[root l r]]\n  (letfn [(same-subtrees? [[root1 & rest1] [root2 & rest2]]\n            (and (= root1 root2)\n  \t\t\t\t\t\t\t (every? #(apply same-subtrees? %1)\n                         (map list rest1 (reverse rest2)))))]\n    (same-subtrees? l r)))", "problem": 96, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn sym-tree?\n    ([xs ys] (let [[xv xl xr] xs\n                   [yv yl yr] ys]\n        (and \n         (= xv yv)\n\n          (if-not (and (coll? xl) (coll? yr))\n            (= xl yr)\n            (sym-tree? xl yr))\n\n          (if-not (and (coll? xr) (coll? yl))\n            (= xr yl)\n            (sym-tree? xr yl)))))\n\n    ([xs] (sym-tree? (nth xs 1) (nth xs 2))))", "problem": 96, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn [t]\n  (letfn [(mirror [[x l r]]\n           (list x (if (sequential? r)\n                       (mirror r) r)\n                   (if (sequential? l)\n                       (mirror l) l)))]\n    (= (second t) (mirror (last t)))))", "problem": 96, "user": "509160dae4b0742c82730aef"}, {"code": "#(let [mirror (fn mirror-tree [t]\n    (if (nil? t)\n      nil\n      [(first t) (mirror-tree (last t)) (mirror-tree (second t))]))]\n(= (second %) (mirror (last %))))", "problem": 96, "user": "50112acee4b0d82cfac69f4c"}, {"code": "(fn sym-tree? [[_ b1 b2]]\n  (letfn [\n    (reorder-node [node]\n      (apply cons ((juxt first (comp reverse next)) node)))\n    (flip-branch [branch]\n      (let [branch (if (sequential? branch) (reorder-node branch) branch)]\n        (map #(if (coll? %) (flip-branch %) %) branch)))]\n    (= b1 (flip-branch b2))))", "problem": 96, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn __ [tree]\n  (let [[v l r] tree]\n    (= l ((fn reflect [tree]\n            (if (nil? tree)\n              tree\n              (let [[v l r] tree]\n                (list v (reflect r) (reflect l)))))\n          r))))", "problem": 96, "user": "509b152be4b0412cdea6eb1e"}, {"code": "(fn [[_ l r]]\n  (letfn\n    [(mirror [t]\n       (when-let [[v l r] t]\n         [v (mirror r) (mirror l)]))]\n    (= l (mirror r))))", "problem": 96, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn [[val left right]]\n  (letfn [(rev [node] \n        \t(if (sequential? node) \n           \t  (let [[v l r] node] [v (rev r) (rev l)]) \n              node))]\n    (= left (rev right))))", "problem": 96, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [[_ x y]]\n  (letfn [(subtree? [t] \n                 (if (sequential? t)\n                   (= (count t) 3) \n                   false))\n          (tree= [t1 t2]\n                 (if (and (subtree? t1) (subtree? t2))\n                   (if (= (nth t1 0) (nth t2 0)) \n                     \n                      (and (tree= (nth t1 1) (nth t2 2)) \n                           (tree= (nth t1 2) (nth t2 1)))                      \n                     false)\n                   (and (nil? t1) (nil? t2))))]\n    (tree= x y)))", "problem": 96, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [t]\n  (let [mirror (fn mirror [t]\n                 (if (nil? t) t\n                   (cons (first t) (reverse (map mirror (rest t))))))]\n    (= t (mirror t))))", "problem": 96, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn f\n    ([t] (f (first (rest t)) (second (rest t))))\n    ([t1 t2]\n      (or\n        (and (nil? t1) (nil? t2))\n        (and\n          (= (first t1) (first t2))\n          (f (first (rest t1)) (second (rest t2)))\n          (f (second (rest t1)) (first (rest t2)))))))", "problem": 96, "user": "4ee77f15535d93acb0a66868"}, {"code": "(fn [t] \n  (=\n   t\n   ((fn rev [t]\n      (cond (nil? t) t\n             :else (seq [(nth t 0)\n                         (rev (nth t 2))\n                         (rev (nth t 1))])))\n    t)))", "problem": 96, "user": "4ff769bce4b0678c553fc38f"}, {"code": "#(let [[v t1 t2] %\n       m (fn m[[v t1 t2]] [v (if (nil? t2) nil (m t2)) (if (nil? t1) nil (m t1)) ])]\n   (= t1 (m t2)))", "problem": 96, "user": "4de8a7d7535d08e6dec9fdfe"}, {"code": "(fn do-it [tree]\n  (let [are-symetric (fn are-symetric [t1 t2]\n  (if (and (nil? t1) (nil? t2))\n    true\n    (and (= (first t1) (first t2))\n         (are-symetric (second t1) (nth t2 2)) \n         (are-symetric (second t2) (nth t1 2)))))]\n      (if (nil? tree)\n        true\n        (are-symetric (nth tree 2) (second tree)))))", "problem": 96, "user": "4f08a8a2535dcb61093f6c3d"}, {"code": "(fn sym? [n] \n  (let [f (fn tv [[v l r]] (concat (if l (tv l)) [v] (if r (tv r)) ))]\n    (= (vec (f n)) (rseq (vec (f n))))))", "problem": 96, "user": "50b24a2fe4b03ea88043355c"}, {"code": "(fn isSymmetryTree? [tree]\n  (cond (and (not (seq? tree)) (not (vector? tree))) true\n    :else (let [left (nth tree 1)\n                right (nth tree 2)]\n            (and ((fn equalTree?[tree1 tree2]\n                    (cond\n                      (not (= (class tree1) (class tree2))) false\n                      (and\n                         (= tree1 tree2)\n                        (and\n                          (not (seq? tree1)) (not (vector? tree1))\n                          (not (seq? tree2)) (not (vector? tree2)))) true\n                      (and\n                        (not (= tree1 tree2))\n                        (and\n                          (not (seq? tree1)) (not (vector? tree1))\n                          (not (seq? tree2)) (not (vector? tree2)))) false\n                      (not (= (count tree1) (count tree2) 3)) false\n                      :else\n                      (and\n                        (= (nth tree1 0) (nth tree2 0))\n                        (equalTree? (nth tree1 1)\n                          (nth tree2 2))\n                        (equalTree? (nth tree1 2)\n                          (nth tree2 1))))) left right)))))", "problem": 96, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn s[[v l r]](cond (or (nil? l) (nil? r))(= l r)\n                     (and (coll? l)(coll? r)) (let [[a b c] l\n                                                    [d e f] r] (and (= a d) (s [a b f]) (s [a c e])))\n                     :else false))", "problem": 96, "user": "4e778d36535d324fb2983d71"}, {"code": "#(= % ((fn f [[v a b]] (if v [v (f b) (f a)])) %))", "problem": 96, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn [tree]\n  (letfn [(flip [[root c1 c2 :as node]]\n            (if (coll? node)\n              (lazy-seq [root (flip c2) (flip c1)])\n              node))\n        ]\n    (= (flip tree) tree)\n    ))", "problem": 96, "user": "50cae881e4b0f75dcc9a6e51"}, {"code": "(fn [[root left right]]\n  (letfn [(inv-node [t]\n                    (if (not (coll? t)) t\n                      [(first t) (inv-node (last t)) (inv-node (second t))]))]\n    (= (inv-node left) right)))", "problem": 96, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn symmetric? [s]\n  (letfn [(mirrored? [t1 t2]\n            \"return true if 2 trees t1 and t2 are mirrored of each other\"\n            (cond\n              (and (seq t1) (seq t2)) (and (= (first t1) (first t2))\n                                           (mirrored? (second t1) (last t2))\n                                           (mirrored? (second t2) (last t1)))\n              (and (empty? t1) (empty? t2)) true\n              :else false))]\n    (mirrored? (second s) (last s))))", "problem": 96, "user": "50a7ef7fe4b090657f4a5ce0"}, {"code": "(fn [[_ l r]]\n  (letfn [(f [[v l r]]\n            (if (or v l r)\n              [v (f r) (f l)]\n              v))]\n    (= l (f r))))", "problem": 96, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn eq-tr? \n  ([root]\n    (eq-tr? (nth root 1) (nth root 2)))\n  ([one two]\n    (cond \n      (and (nil? one) (nil? two)) true\n      (not= (first one) (first two)) false\n      :else (and (eq-tr? (nth one 1) (nth two 2))\n                (eq-tr? (nth one 2) (nth two 1)) ))))", "problem": 96, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn sym [[v [lv ll lr] [rv rl rr]] ]\n  (or (and (nil? lv) (nil? rv))\n      (and (= lv rv) (sym [lv ll rr]) (sym [lv lr rl]))))", "problem": 96, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "; not so elegant as volatile's solution\n;(fn sym?[[_ [h1 l1 r1 :as t1][h2 l2 r2 :as t2]]] \n;  (or (= nil t1 t2)\n;      (and (= h1 h2)\n;           (sym? [_ l1 r2])\n;           (sym? [_ l2 r1])\n;   )))\n\n(letfn \n   [(to-map [[h l r] l-to r-to]\n    {:h h \n     l-to (if (coll? l)(to-map l l-to r-to) l)\n     r-to (if (coll? r)(to-map r l-to r-to) r)\n    }\n       )]\n   (fn [[h l r]] \n     (= (to-map l :l :r) (to-map r :r :l))\n   ))", "problem": 96, "user": "50de11b2e4b061dbdced7217"}, {"code": "#(letfn [(mirror-tree [[p l r]]\n           (if p [p (mirror-tree r) (mirror-tree l)]))]\n   (= % (mirror-tree %)))\n\n;#(= % ((fn mirror-tree [[p l r]] (if p [p (mirror-tree r) (mirror-tree l)])) %))", "problem": 96, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "#(= ((fn mirror [[frst scnd thrd :as tree]] (when tree [frst (mirror thrd) (mirror scnd)])) %) %)", "problem": 96, "user": "50ee145de4b06330c1f87c53"}, {"code": "(fn [tree]\n  (letfn [(symmetric? [left right]\n            (cond\n             (and (= left nil) (= right nil)) true\n             (not= (first left) (first right)) false\n             (not (symmetric? (second left) (last right))) false\n             (not (symmetric? (last left) (second right))) false\n             :else true))]\n    (symmetric? (second tree) (last tree))))", "problem": 96, "user": "50ed3c6be4b01236b1d4983b"}, {"code": "(fn c [[v l r]] (boolean (or (and (nil? l) (nil? r)) (and l r (= (first l) (first r)) (c [0 (nth l 1) (nth r 2)]) (c [0 (nth l 2) (nth r 1)])))))", "problem": 96, "user": "50ed4626e4b01236b1d4983c"}, {"code": "#(= ((fn mirror [[n l r :as x]] (when x [n (mirror r) (mirror l)])) %) %)", "problem": 96, "user": "50ef56dfe4b0bdaecbb47d94"}, {"code": "(fn [t]\n   ((fn mir? [l r]\n      (if (or (= nil l r)\n              (and (= (first l) (first r))\n                   (mir? (second l) (last r))\n                   (mir? (last l) (second r))))\n        true false)) \n    (second t) (last t)))", "problem": 96, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn [t] \n     ( \n       (fn tc[a b] \n         (if (coll? a) \n            (and (= (first a) (first b)) (tc (nth a 1) (nth b 2)) (tc (nth a 2) (nth b 1))) \n            (= a b) )) (nth t 1) (nth t 2)))", "problem": 96, "user": "50ef3e5de4b0a78662fa2652"}, {"code": "(fn [[v l r]]\n  (= r ((fn flip [[v l r :as t]]\n          (when t\n            [v (flip r) (flip l)])) l)))", "problem": 96, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [a]\n   (letfn [(mirror [a]\n                   (if (coll? a) (list (first a) (mirror (nth a 2)) (mirror (nth a 1))) a))]\n     (= a (mirror a))))", "problem": 96, "user": "50bfe725e4b080409b860f26"}, {"code": "(fn mirror? [arg]\n  (letfn [(mirror [arg]\n            (if (coll? arg)\n              (let [[top left right] arg]\n                (list top (mirror right) (mirror left)))\n              arg))]\n    (= arg (mirror arg))))", "problem": 96, "user": "4f98ead0e4b0dcca54ed6cf8"}, {"code": "(fn f [x]\n  (letfn \n  [(rev [x] \n    (if (coll? x)\n      (let [[k l r] x] \n\t    (list k (rev r) (rev l))\n\t  )\n\t  x\n    )\n  )]\n  (= x (rev x))\n  )\n)", "problem": 96, "user": "50f4894be4b004d364930528"}, {"code": "(fn beauty-is-symmetry [coll]\n  (letfn [(rev-tree [[root c1 c2 :as body]]\n            (if (coll? body)\n              (lazy-seq [root (rev-tree c2) (rev-tree c1)])\n              body))]\n    (= coll (rev-tree coll))))", "problem": 96, "user": "503539dee4b0ed9c821488f6"}, {"code": "(fn [n]\n  (apply = (for [f [identity reverse]]\n    (map #(if (coll? %) (first %) %)\n         (tree-seq coll? #(f (rest %)) n)))))", "problem": 96, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn check [tree]\n  (letfn [(flip [tree] (if (coll? tree) (list (nth tree 0) (flip (nth tree 2)) (flip (nth tree 1))) tree))]\n    (= tree (flip tree))))", "problem": 96, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn [[_ l r]]\n  (letfn\n    [(mirror [a b]\n       (or\n         (and (nil? a) (nil? b))\n         (let [[av al ar] a\n               [bv bl br] b]\n           (and\n             (= av bv)\n             (mirror al br)\n             (mirror bl ar)))))]\n    (mirror l r)))", "problem": 96, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "#(= % ((fn rt [[n l r]] (if (nil? n) n [n (rt  r) (rt l)])) %))", "problem": 96, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn symmetric? [tree]\n    (letfn [(mirror [tree]\n                    (if (seq tree) (let [[v l r] tree] [v (mirror r) (mirror l)])))]\n      (= tree (mirror tree))))", "problem": 96, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn\t[node]\n  (letfn [(mirror [node]\n            (if (nil? node)\n    \t      nil\n              (let [[v l r] node]\n                [v (mirror r) (mirror l)])))]\n    (let [[v l r] node]\n      (= l (mirror r)))))", "problem": 96, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(let [flip-tree (fn flip-tree [[a l r :as n]] (if n [a (flip-tree r) (flip-tree l)]))]\n        (fn [[a l r :as n]]\n            (if n\n                (= l (flip-tree r))\n              true)))", "problem": 96, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn mirrorTree [t]\n  ((fn mirror [l r]\n\t (if (and (coll? l) (coll? r))\n\t   (and (mirror (second l) (nth r 2)) (mirror (nth l 2) (second r)) (= (first l) (first r )) )\n\t   (if (not= (class l) (class r))\n\t\t false\n\t\t (= l r))))  (second t) (nth t 2)))", "problem": 96, "user": "5101192ae4b0bef64c30e266"}, {"code": "(fn [[_ l r]]\n  (let\n      [flip (fn flip [n]\n              (if (sequential? n)\n                [(first n) (flip (last n)) (flip (second n))]\n                n))]\n    (= l (flip r))))", "problem": 96, "user": "4dc78527535d8a4b2fd7428f"}, {"code": "(fn sbt?\n  [t]\n  (cond\n   (coll? t) (= ((fn rev [e]\n                   (if (coll? e)\n                     (map rev [(first e) (last e) (fnext e)])\n                     e))\n                 (last t))\n                 (fnext t))\n   :else true\n   )\n  )", "problem": 96, "user": "5107b86de4b05b2b4eee7495"}, {"code": "(fn [t]\n  (let [left  (fn [t] (nth t 1)),\n        right (fn [t] (nth t 2)),\n        mirror (fn _[t]\n                 (if  \n                   (not (sequential? t)) t\n                   [(nth t 0) (_ (right t)) (_ (left t))]))]\n    (= t (mirror t))\n  )\n)", "problem": 96, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [[value left right]]\n  (letfn [(flip [[v l r :as t]] (when t [v (flip r) (flip l)]))]\n    (= left (flip right))))", "problem": 96, "user": "4db2f208535df7e46ed9b6c9"}, {"code": "(fn [tree]\n  (let [reverse-tree (fn rvt [t]\n                       (if (nil? t)\n                         nil\n                         (list (first t)\n                           (rvt (last t))\n                           (rvt (second t)))))]\n    (= (second tree) (reverse-tree (last tree)))))", "problem": 96, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn [[t l r]]\n  (letfn \n    [(flip [[t l r]]\n          (if (nil? t) \n            nil\n            [t (flip r) (flip l)]))]\n    (= l (flip r))))", "problem": 96, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [x]\n  (letfn [(m [y]\n             (if (nil? y) nil\n               (list (first y) (m (last y)) (m (second y)))))]\n    (= (second x) (m (last x)))))", "problem": 96, "user": "5102489de4b00c483ae176f6"}, {"code": "; R is sysmmetric <=> xRy => yRx\n#(= % ((fn s [[x y z]]\n         (if x [x (s z) (s y)])) %))", "problem": 96, "user": "510d9d61e4b078ea71921141"}, {"code": "(fn [t]\n  (let [left (nth t 1)\n        right (nth t 2)\n        left-tree (map first (tree-seq next rest left))\n        right-tree (map first (tree-seq next (comp reverse rest) right))]\n    (= left-tree right-tree)))", "problem": 96, "user": "5106bc8ae4b01150e115ebec"}, {"code": "(fn [[_ l r]]\n  (letfn [(rev-tree [[v l r :as tree]]\n                    (when tree\n                      (vector v (rev-tree r) (rev-tree l))))]\n    (= l (rev-tree r))))", "problem": 96, "user": "510db6cde4b078ea71921145"}, {"code": "(fn [t]\n    (let [mirror (fn m [t]\n                   (if (coll? t)\n                     (list (nth t 0) (m (nth t 2)) (m (nth t 1)))\n                     t))]\n      (=\n       (mirror (second t))\n       (nth t 2))))", "problem": 96, "user": "4e50ad74535dc968683fc4ec"}, {"code": "(fn symmetree [[v l r]]\n  (= ((fn reverse-tree [[v l r]]\n  \t\t(if v [v (reverse-tree r) (reverse-tree l)] v)) l) r))", "problem": 96, "user": "5114ab7be4b0ce5098ee73b5"}, {"code": "(fn [t]\n   (= (nth t 1)  \n      ((fn rev-trav [tree v]\n          (if (coll? tree)   \n            (conj v (nth tree 0) (rev-trav (nth tree 2) v) (rev-trav (nth tree 1) v))\n            tree\n            )) (nth t 2) [])))", "problem": 96, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "problem": 96, "user": "51181009e4b0e0897831a60f"}, {"code": "#((fn mirror? [lc rc]\n    (or (and (nil? lc) (nil? rc))\n        (and (not (nil? rc))\n             (= (first lc) (first rc))\n             (mirror? (nth lc 1) (nth rc 2))\n             (mirror? (nth lc 2) (nth rc 1)))))\n  % %)", "problem": 96, "user": "50f9739ce4b0e7c80cb15a4d"}, {"code": "(let [mirror (fn this [t] \n               (if (empty? t) \n                 t\n                 (let [[value left right] t]\n                   (list value (this right) (this left))\n                   )\n                 )\n               )]\n  (fn [t]\n    (= t (mirror t))))", "problem": 96, "user": "4ec12577535dfed6da9c6da8"}, {"code": "(fn [tree]\n  (letfn [(invert [node]\n            (if-not (seq node)\n              node\n              (let [[n lhs rhs] node]\n                (vector n (invert rhs) (invert lhs)))))]\n    (let [[node lhs rhs] tree]\n      (= lhs (invert rhs)))))", "problem": 96, "user": "51195e77e4b055cfb310d499"}, {"code": "(fn is-symmetric [tree]\n  (letfn [(mirror [tree]\n                  (if (empty? tree) tree\n                    (let [[node left right] tree]\n                      [node (mirror right) (mirror left)])))\n          ]\n    (if (empty? tree) tree\n      (let [[node left right] tree]\n        (= left (mirror right))))))", "problem": 96, "user": "5119f3d5e4b06c8af0111818"}, {"code": "(fn [x] (< (rand 2) 1))", "problem": 96, "user": "51256b40e4b05d10e3e395f8"}, {"code": "(fn symmetric? [t]\n  (letfn [(transpose [t] (if (= t nil) nil\n                           [(first t) (transpose (last t)) (transpose (second t))]))]\n    (or (= t nil) (= (second t) (transpose (last t))))))", "problem": 96, "user": "51284226e4b03a34742b4308"}, {"code": "(fn tree-symmetric?\n  ([tree] (or (nil? tree)\n              (tree-symmetric? (nth tree 1) (nth tree 2))))\n  ([ltree rtree]\n   (cond (every? nil? [ltree rtree]) true\n         (some nil? [ltree rtree]) false\n         :else (and (= (nth ltree 0) (nth rtree 0))\n                    (tree-symmetric? (nth ltree 1) (nth rtree 2))\n                    (tree-symmetric? (nth ltree 2) (nth rtree 1))))))", "problem": 96, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [tree]\n  ((fn symmetric? [left right]\n     (or (= nil left right)\n         (and (= (first left) (first right))\n              (symmetric? (second left) (last right))\n              (symmetric? (second right) (last left)))))\n   (second tree) (last tree)))", "problem": 96, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn sym-bt [t]\n  (let [sym-node-fn (fn sym-node-fn [n1 n2] (if (coll? n1)\n                                              (and (sym-node-fn (second n1) (nth n2 2))\n                                                   (sym-node-fn (nth n1 2) (second n2))\n                                                   (= (first n1) (first n2)))\n                                              (= n1 n2)))]\n    (and (= (second t) (nth t 2))\n         (if (coll? (second t))\n           (sym-bt (second t))\n           true))\n    \n    (sym-node-fn (second t) (nth t 2))\n    \n    )\n  )", "problem": 96, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn [tree-orig]\n   (= (nth tree-orig 1)\n      ((fn ! [tree]\n   [(nth tree 0) \n    (if (coll? (nth tree 2))\n      (! (nth tree 2))\n      (nth tree 2))\n    (if (coll? (nth tree 1))\n      (! (nth tree 1))\n      (nth tree 1))\n    ]\n   ) (nth tree-orig 2)\n        )\n      )\n   )", "problem": 96, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn [[n l r ]]\n  (if (= l ((fn inv [r]\n              (if (coll? r)\n                (let [[c e d] r]\n                  [c (inv d) (inv e)])\n                r)) r))\n    true\n    false))", "problem": 96, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [ tt ] \n\n         (let [sy1 (fn sy2 [ll rr] \n                           ( cond (and ( not  (coll? ll))\n                                       ( = ll rr ))        true\n                                  ( = 3 (count ll))        (and (= (first ll) (first rr))\n                                                               (sy2 (nth ll 1) (nth rr 2))\n                                                               (sy2 (nth ll 2) (nth rr 1)))))]\n    \n         (cond ( = 1 (count tt))  true\n               ( = 3 (count tt))  (sy1 (nth tt 1) (nth tt 2)))))", "problem": 96, "user": "4f030775535dcb61093f6a43"}, {"code": "(fn mirrortree? [tree]\n  (letfn [(leaf? [t]\n                 (let [[v lst rst] t]\n                   (or (nil? t)\n                       (and (not (nil? v))\n                            (= lst nil)\n                            (= rst nil)))))\n          (sameleaf? [lt rt]\n                     (and (leaf? lt)\n                          (leaf? rt)\n                          (= (first lt) (first rt))))\n          (symmtree? [lt rt]\n                     (if (sameleaf? lt rt)\n                       true\n                       (let [[lv ltlst ltrst] lt,\n                             [rv rtlst rtrst] rt]\n                         (and (= lv rv)\n                              (symmtree? ltlst rtrst)\n                              (symmtree? ltrst rtlst)))))]\n    (and (not (nil? (first tree)))\n         (symmtree? (first (rest tree)) (second (rest tree))))))", "problem": 96, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn [tree]\n  (letfn\n    [(mirror-tree [tree]\n       (if (nil? tree)\n         tree\n         (let [[node left right] tree]\n           [node (mirror-tree right) (mirror-tree left)])))]\n  (= tree (mirror-tree tree))))", "problem": 96, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "#(= % ((fn ! [_1]\n  (if\n      (coll? _1) \n        [(first _1) (! (nth _1 2)) (! (nth _1 1))]\n      _1)) %))", "problem": 96, "user": "511ac026e4b0c87c59c9670e"}, {"code": "#(= %\n    ((fn rev [[v l r]]\n      (if v [v (rev r) (rev l)])) %))", "problem": 96, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn trequal? [t]\n  (let [mirror? (fn mirror? [l r]\n                  (or (and (nil? l) (nil? r))\n                      (and (= (first l) (first r))\n                           (mirror? (second l) (last r))\n                           (mirror? (last l) (second r)))))]\n    (mirror? (second t) (last t))))", "problem": 96, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn treesym ([t] (treesym (second t) (last t)))\n  ([t1 t2]\n   (if (not= (first t1) (first t2))\n     false\n     (if (coll? t1)\n       (and\n         (treesym (second t1) (last t2))\n         (treesym (last t1) (second t2)))\n       true))))", "problem": 96, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn symtree? [root]\n  (letfn [ (cmpsubtrees [ l r] \n         (if (every? sequential? [ l r])\n           (and (= (first l) (first r))\n                (cmpsubtrees (second r) (last l))\n                (cmpsubtrees (second l) (last r)))\n           (= l r)\n                        ))]\n         (cmpsubtrees (second root) (last root))))", "problem": 96, "user": "5018ed15e4b011a2e0bf6412"}, {"code": "(let [fliptree (fn fliptree [t]\n  (if (nil? t) t\n    [(first t) (fliptree (nth t 2)) (fliptree (nth t 1))]\n  ))\n]\n(fn [t] (= t (fliptree t)))\n)", "problem": 96, "user": "50bfbf25e4b05ae8c1cbbd9b"}, {"code": "(fn sym [t]\n  (let [left  (nth t 1)\n        right (nth t 2)\n        flip  (fn flip [t]\n                (if (nil? t)\n                  t\n                  [(nth t 0) (flip (nth t 2)) (flip (nth t 1))]))]\n    (= (flip left) right)))", "problem": 96, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [[v l r]]\n  (letfn [(mirror? [[v1 l1 r1 :as n1] [v2 l2 r2 :as n2]]\n                   (or (and (nil? n1) (nil? n2))\n             (and\n                  (= v1 v2)\n                  (mirror? l1 r2)\n                  (mirror? l2 r1))))]\n    (mirror? l r)))", "problem": 96, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [t]\n  (let [f (fn f [t rs d]\n            (if (coll? t)\n              (conj rs (first t) (f ((if (= d \\l) second last) t) [] d) (f ((if (= d \\l) last second) t) [] d))))\n    \tl (f t [] \\l)\n    \tr (f t [] \\r)]\n    (= l r)))", "problem": 96, "user": "502940a9e4b061fd216be4b8"}, {"code": "(fn [[v l r]]\n  (letfn\n      [(mirror-tree[ n ]\n         (when-let [ [v l r] n]\n           [v (mirror-tree r) (mirror-tree l)]))\n\n       (tree-eq? [a b]\n         (cond\n          (and (nil? a) (nil? b)) true\n          :else (let [ [va a1 a2] a\n                       [vb b1 b2] b ]\n                  (and (= va vb) (tree-eq? a1 b1) (tree-eq? a2 b2)))\n          )) ]\n    (tree-eq? l (mirror-tree r))))", "problem": 96, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn [tree]\n\t(letfn \n\t\t[(same-tree [a b]\n\t\t\t(cond\n             \t(and (coll? a) (coll? b)) (let [[a0 a1 a2] a [b0 b1 b2] b]\n\t\t\t\t\t\t(and (= a0 b0) (same-tree a1 b2) (same-tree a2 b1))\n\t\t\t\t\t)\n\t\t\t\t:else (= a b)\n\t\t\t)\n\t\t)]\n\t\t(same-tree (second tree) (last tree))\n\t)\n)", "problem": 96, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn aaa [[V L R]] \n (letfn [(aa [[v l r]]\n            (if (= nil r)\n                (if (= nil l) [v r l] [v r (aa l)])\n                (if (= nil l) [v (aa r) l] [v (aa r) (aa l)])  \n              )\n            )]\n            (if (= (aa L) R) true false)))", "problem": 96, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(let [root first\n      left second\n      right #(nth %1 2)\n      mirror (fn mirror [tree]\n               (if (nil? tree) nil\n                 (list (root tree) (mirror (right tree)) (mirror (left tree)))))]\n  (fn [tree] (= tree (mirror tree))))", "problem": 96, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "(fn symmetric? [tree] (letfn [(inorder ([tree] (if (not (nil? tree)) (concat (inorder (second tree)) [(first tree)] (inorder (last tree))))))] (= (inorder tree) (reverse (inorder tree)))))", "problem": 96, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn is-mirror [t] (let [nm (fn nodes-mirror [t1 t2] \n                                       (if (and (nil? t1) (nil? t2)) true\n                                         (and (= (first t1) (first t2))\n                                              (nodes-mirror (second t1) (nth t2 2))\n                                              (nodes-mirror (second t2) (nth t1 2)))))]\n                    (or (nil? t) (nm (second t) (nth t 2)))))", "problem": 96, "user": "50fac9e3e4b07934dda8b0d1"}, {"code": "#(= ((fn sym\n    [tree]\n    (if (nil? tree) tree\n        [(first tree) (sym (last tree)) (sym (second tree))])) %) %)", "problem": 96, "user": "50b35486e4b03ea88043356a"}, {"code": "(fn p096 [[v lt rt :as t]]\n  (letfn [(mirror [[v l r :as t]]\n          (if (nil? t) nil (list v (mirror r) (mirror l))))]\n    (or (nil? t)\n        (= lt (mirror rt)))))", "problem": 96, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn sym-tree? [[_ left right]]\n  (let [ tree?  (fn [n] (= 3 (count n)))\n         r-trav (fn rt [[ root l r ]]\n                  (conj [] root\n                    (if (tree? r) (rt r) r)\n                    (if (tree? l) (rt l) l)))]\n    (= (flatten left) (flatten (r-trav right)))))", "problem": 96, "user": "5127e504e4b03a34742b4302"}, {"code": "#((fn sym? [l r] (if (and (coll? l) (coll? r))\n                 (and (= (first l) \n                      \t (first r))\n                      (sym? (nth l 1) (nth r 2))\n                      (sym? (nth l 2) (nth r 1)))\n                 (= l r)))\n  (nth % 1) (nth % 2))", "problem": 96, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn s \n  ([[n a b]] (s a b))\n  ([[n1 a1 b1] [n2 a2 b2]] \n   (cond (and (nil? n1) (nil? n2)) true\n         (or (nil? n1) (nil? n2)) false\n         :else (and (= n1 n2) (s a1 b2) (s a2 b1)))))", "problem": 96, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn [[root l r]]\n  (letfn [(revert [t]\n                  (if (coll? t)\n                    (->> t ((juxt first last second)) (map revert))\n                    t))]\n    (= l (revert r))))", "problem": 96, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn symmetry? [s]\n  (letfn [(mirror? [left right]\n       \t\t(if (= (count left) 0)\n    \t\t\ttrue\n    \t\t\t(and (= (first left) (first right))\n         \t\t(mirror? (nth left 1) (nth right 2))\n         \t\t(mirror? (nth right 1) (nth left 2)))))]\n    (mirror? (nth s 1) (nth s 2))))", "problem": 96, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [[v l r]] (letfn\n                [(mirrored [node] (if (coll? node) (let [[v l r] node] [v (mirrored r) (mirrored l)]) node))]\n                (= l (mirrored r))))", "problem": 96, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn [a]\n\n    (= (second a ) (\n\n  (fn flip [n]\n\n  (if (coll? n)\n    (vector (first n) (flip (nth n 2)) (flip (second n))) n)\n\n  ) (nth a 2))))", "problem": 96, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "#(= %\n  ((fn fliptree [[a b c :as tree]]\n    (if tree\n      [a (fliptree c) (fliptree b)])) %))", "problem": 96, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn\n  [[value left right]]\n  \n  (letfn [(is-tree-equal?\n  [left right]\n  (cond \n   (and (coll? left) (coll? right)) (and (= (first left) (first right))      \n                                             (and (is-tree-equal? (second left) (last right)) \n                                                  (is-tree-equal? (last left) (second right))))\n   (and ((complement coll?) left) ((complement coll?) right)) (= left right)\n   :else false))]\n    (is-tree-equal? left right)))", "problem": 96, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn symm? \n  ([[ _ [av al ar] [bv bl br]]] (and (= av bv) (symm? al br) (symm? ar bl)))\n  ([left-tree right-tree]\n   (cond\n    (not-any? coll? [left-tree right-tree]) (= left-tree right-tree)\n    (every?   coll? [left-tree right-tree]) (symm? [:whatever left-tree right-tree])\n    :else false)))", "problem": 96, "user": "4ff01fa9e4b0678c553fc321"}, {"code": "(fn [x]\n  ((fn issym [a b] \n     (if (not (sequential? a)) \n       (= a b)\n       (and\n        (= (first a) (first b))\n        (issym (last a) (last (butlast b)))\n        (issym (last (butlast a)) (last b))))) \n   (last x) \n   (last (butlast x))))", "problem": 96, "user": "513b77f3e4b00f740c76c403"}, {"code": "#(letfn [(fliptree [tr] \n  (if (== 3 (count tr))\n    (list (first tr) (fliptree (nth tr 2)) (fliptree (second tr))) \n    tr))] \n  (= (nth % 2) (fliptree (second %))))", "problem": 96, "user": "4f8b27b3e4b02e764a0a5179"}, {"code": "apply #(= ((fn m[[x l r]] (if x [x (m r) (m l)])) %2) %3)", "problem": 96, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn symtree? [tree]\n  (letfn [(mirror-tree [[v l r :as tree]]\n            (if (and (nil? l) (nil? r))\n              tree\n              [v (mirror-tree r) (mirror-tree l)]))]\n    (= tree (mirror-tree tree))))", "problem": 96, "user": "4dada426c9a9d6ed2a99dc57"}, {"code": "#(= % ((fn rtree [[v L R]] (if v [v (rtree R) (rtree L)])) %))", "problem": 96, "user": "50742549e4b054001656accf"}, {"code": "(letfn [(m [[v l r]] (if v [v (m r) (m l)]))] #(= % (m %)))", "problem": 96, "user": "513dcc1ce4b0825f97f7f964"}, {"code": "(fn [c]\n  (letfn [(reverse-tree [t]\n            (if (sequential? t)\n              [(first t) (reverse-tree (last t)) (reverse-tree (second t))]\n              t))]\n    (= (reverse-tree (second c)) (last c))))", "problem": 96, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [s]\n\t(let [a (second s) b (last s)]\n\t\t(letfn\n\t\t\t[(mirror [s]\n\t\t\t\t(let [x (second s) y (last s)]\n\t\t\t\t\t(if\n\t\t\t\t\t\t(and (nil? x) (nil? y))\n\t\t\t\t\t\ts\n\t\t\t\t\t\t(list (first s)\n\t\t\t\t\t\t\t(if (nil? y) y (mirror y))\n\t\t\t\t\t\t\t(if (nil? x) x (mirror x))))))]\n\t\t\t(= a (mirror b)))))", "problem": 96, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn [t]\n  (letfn [(switch-nodes [v]\n    (if (= (count v) 2)\n      [(second v) (first v)]\n      (let [left (if (vector? (second v)) (switch-nodes (second v)) (second v))\n            right (if (vector? (last v)) (switch-nodes (last v)) (last v))]\n        (conj [] (first v) right left))))]\n  (= (second t) (switch-nodes (last t)))))", "problem": 96, "user": "515a6151e4b0394f658fe241"}, {"code": "#(\n  (fn f [X Y]\n\t(case [(sequential? X) (sequential? Y)]\n   [true true] (if (and (= (first X) (first Y)) (= 3 (count X) (count Y))) \n                 (and (f (second X) (last Y)) (f (last X) (second Y)))\n                 false\n                 )\n   [true false] false\n   [false true] false\n   [false false] (= X Y)\n   )\n ) % %)", "problem": 96, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [x] (= (second x)\n           ((fn re [x] \n              (if (coll? x)\n                (vector (first x) (re (last x)) (re (second x)))\n                x))\n            (last x))))", "problem": 96, "user": "5016ac54e4b052339a490e7b"}, {"code": "#(let [swap (fn swap [[v l r]]\n  \t\t\t  (if v [v (swap r) (swap l)]))]\n     (= (swap %) %))", "problem": 96, "user": "51533ecde4b0252ac4b16619"}, {"code": "(let [tostr (fn tostr [t d] \n              (if (= 3 (count t)) \n                (let [[v l r] t] (if (= d \"r\") (str v (tostr l d) (tostr r d)) (str v (tostr r d) (tostr l d)))) \n                (str (first t))))]\n(fn [[v l r]] (= (tostr l \"l\") (tostr r \"r\"))))", "problem": 96, "user": "5150a7d7e4b03e678e393abb"}, {"code": "(fn\n  [tree]\n  (if\n    (= tree ((fn rev\n               [t]\n               (if-not\n                 (empty? t)\n                 (conj '() (rev (nth t 1)) (rev (nth t 2)) (first t))\n               )\n             ) tree))\n    true\n    false\n  )\n)", "problem": 96, "user": "5162757ee4b03cfa3774b3fe"}, {"code": "(fn symtree [tree]\n  (let [symtree_helper\n        (fn symtree_helper [left right]\n        (if (and (nil? left) (nil? right))\n            true\n            (if (not (and (sequential? left) (sequential? right)))\n              false\n              (let\n                [[leftval leftleft leftright] left\n                 [rightval rightleft rightright] right]\n                (and (= leftval rightval)\n                  (symtree_helper leftleft rightright)\n                  (symtree_helper leftright rightleft))))))]\n    (symtree_helper (second tree) (nth tree 2))))", "problem": 96, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn [[r lt rt]]\n      (letfn [(flip [node]\n        (if (seq node)\n          (let [[r lt rt] node]\n            [r (flip rt) (flip lt)])\n          node))]\n        (= lt (flip rt))))", "problem": 96, "user": "50f48298e4b004d364930527"}, {"code": "(fn ts \n  ([t]\n    (ts t t))\n  ([[v l r] [v2 l2 r2]]\n    (and \n      (= v v2)\n      (or (and (nil? l) (nil? r2)) (ts l r2))\n      (or (and (nil? r) (nil? l2)) (ts r l2)))))", "problem": 96, "user": "50eebf46e4b06330c1f87c61"}, {"code": "(fn symmetry [xs]\n  (letfn [(seqns? [xs]\n                (if (or (= (type xs) clojure.lang.PersistentVector)\n                        (= (type xs) clojure.lang.PersistentList))\n                  true\n                  false))\n          (mirror [xs]\n                  ;; ret a seq of mirror-ed btree\n                  (if-not (seqns? xs)\n                    xs\n                    (vector (first xs) (mirror (last xs)) (mirror (second xs)))))]\n    (let [root (first xs) lc (second xs) rc (last xs)]\n        (if (= (mirror (second xs))\n               (last xs))\n          true\n          false))))", "problem": 96, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn sim-tree? \n  ([tree]\n   (let [e (sim-tree? (second tree) (nth tree 2))]\n     (if (sequential? e)\n         e\n         e)))\n  ([tree1 tree2]\n   (if (and (sequential? tree1) (sequential? tree2))\n       (and (= (first tree1) (first tree2)) \n               (sim-tree? (nth tree1 2) (second tree2))\n              (sim-tree? (nth tree2 2) (second tree1)))\n       (= tree1 tree2))))", "problem": 96, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn f [[_ b c]]\n  (cond\n    (or (= (count (flatten b)) 3) (= (count (flatten c)) 3))\n      (= b c)\n    (or (= (count (flatten b)) 7) (= (count (flatten c)) 7))\n      (let [[x1 y1 z1] b [x2 y2 z2] c]\n        (and (= x1 x2) (= y1 z2) (= z1 y2)))\n    :else (recur [[] (nth c 1) (nth b 2)])))", "problem": 96, "user": "515e8ce2e4b049add99a053d"}, {"code": "#(letfn [(m [[i l r]]\n            (when i\n              [i (m r) (m l)]))]\n    (= % (m %)))", "problem": 96, "user": "514d8084e4b019235f6c0588"}, {"code": "#(letfn [(mirror [[val left right]]\n                 (when val\n                   [val (mirror right) (mirror left)]))]\n   (= (second %) (mirror (nth % 2))))", "problem": 96, "user": "4eab612d535d7eef30807316"}, {"code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or \n          (and (nil? a) (nil? b))\n          (if (and (coll? a) (coll? b))\n            (and (= (count a) (count b) 3)\n                 (= (first a) (first b))\n                 (sym? (second a) (last b))\n                 (sym? (last a) (second b)))\n            false))))", "problem": 96, "user": "5125d963e4b05d10e3e395fe"}, {"code": "#((fn symmetry? [a b]\n    (cond (and (coll? a) (coll? b) (= (count a) (count b)))\n          (and (= (first a) (first b))\n               (symmetry? (second a) (last b))\n               (symmetry? (last a) (second b)))\n          (and (not (coll? a)) (not (coll? b)))\n          (= a b)\n          :else\n          false))\n  (second %) (last %))", "problem": 96, "user": "51592b81e4b0394f658fe22c"}, {"code": "(fn [[_ left right]]\n  (letfn [(cmp [[lv ll lr :as l] [rv rl rr :as r]]\n            (or\n             (and (nil? l) (nil? r))\n             (and (= lv rv)\n                  (cmp ll rr)\n                  (cmp lr rl))))]\n    (cmp left right)))", "problem": 96, "user": "5173726be4b098276e74652c"}, {"code": "(fn symm [tree]\n  (let [l (second tree), r (second (rest tree)),\n        flip (fn flip [branch]\n               (if-not (coll? branch)\n                 branch\n                 (list (first branch)\n                       (flip (second (rest branch)))\n                       (flip (second branch)))))]\n    (= l (flip r))))", "problem": 96, "user": "5175616ae4b0dea9bbfba576"}, {"code": "(fn sym \n  ([xs] (sym (nth xs 1) (nth xs 2)))\n  \n  ([left right]\n  \t(if (and (coll? right) (coll? left))\n      (if (or (>= 1 (count (flatten right))) (>= 1 (count (flatten left))))\n        (do\n          (println \"coll: \" right left)\n        (= right left))\n  \t\t(and (sym (first left) (first right)) (sym (rest left) (reverse (rest right))))\n       )\n  \t  (do\t\n        (println left right)\n      \t(= right left)\n        )\n  \t)\n  )\n)", "problem": 96, "user": "50ab8ae3e4b01d6eb43ce9a0"}, {"code": "(letfn [(eqt? [t1 t2]\n              (if (empty? t1)\n                (empty? t2)\n                (and (= (first t1) (first t2))\n                     (eqt? (nth t1 2) (second t2))\n                     (eqt? (second t1) (nth t2 2)))))]\n  (fn sym? [t]\n    (or (empty? t)\n        (eqt? (second t) (nth t 2)))))", "problem": 96, "user": "50b668dde4b08fb537db98f2"}, {"code": "(letfn [(tree-mirror-image [tree] (if (empty? tree) tree \n                                    (let [[value left right] tree] \n                                          [value (tree-mirror-image right) (tree-mirror-image left)]) ) )\n\t  (symmetric? [tree] (let [[_ left right] tree] (= left (tree-mirror-image right))  )  )]\n   symmetric?\n )", "problem": 96, "user": "51729002e4b044b2ef48a850"}, {"code": "#(= (map first (tree-seq next (fn [x] (-> x rest reverse)) %)) (map first (tree-seq next rest %)))", "problem": 96, "user": "50fe91c1e4b03cd852b4e84e"}, {"code": "(fn [t]\n    (letfn [(mir [t1 t2]\n              (if (nil? t1)\n                (nil? t2)\n                (and\n                  (= (nth t1 0) (nth t2 0))\n                  (mir (nth t1 1) (nth t2 2))\n                  (mir (nth t1 2) (nth t2 1)))))]\n      (or (nil? t) (mir (nth t 1) (nth t 2)))))", "problem": 96, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [[n l r]] (letfn [(f [[tn tl tr]] \n                         (if (nil? tn)\n                           nil\n                           [tn (f tr) (f tl)]))]\n                (= (f l) r)))", "problem": 96, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn [tree]\n  (letfn [(symmetric? [l r]\n          (cond (and (sequential? l) (sequential? r)) (and (symmetric? (first l) (first r)) (symmetric? (second l) (last r)) (symmetric? (last l) (second r)))\n                (or (sequential? l) (sequential? r)) false\n                :else (= l r)))]\n         (symmetric? (second tree) (last tree))))", "problem": 96, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [[v l r]]\n  ((fn mirror [[v1 l1 r1] [v2 l2 r2]]\n     (and (= v1 v2)\n          (if (coll? l1) (mirror l1 r2) (= l1 r2))\n          (if (coll? r1) (mirror r1 l2) (= r1 l2)))) l r))", "problem": 96, "user": "4f89d489e4b033992c121c7e"}, {"code": "(fn sym [t]\n  (letfn [(sym= [t1 t2]\n               (if (or (not (coll? t1))\n                       (not (coll? t2)))\n                 (= t1 t2)\n                 (and (= (first t1) (first t2))\n                      (sym= (second t1) (last t2))\n                      (sym= (second t2) (last t1)))))]\n    (sym= (second t) (last t))))", "problem": 96, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [s]\n  (letfn [(mirror? [l r]\n            (or\n             (and \n              (sequential? l) (sequential? r)\n              (= (first l) (first r))\n              (= (count l) (count r) 3)\n              (mirror? (second l) (last r))\n              (mirror? (last l) (second r)))\n             (and\n              (not (sequential? l)) (not (sequential? r))\n              (= l r))))]\n    (or (not (sequential? s))\n        (and (= (count s) 3)\n             (mirror? (second s) (last s))))))", "problem": 96, "user": "512d3304e4b040332b905b2d"}, {"code": "#(letfn [(test-node [t1 t2]\n                    (let[[n1 l1 r1] t1\n                         [n2 l2 r2] t2]\n                    (if (not (= n1 n2)) false\n                      (cond (and (nil? l1) (nil? r2) (nil? r1) (nil? l2)) true\n                            (and (nil? l1) (nil? r2)) (test-node l2 r1)\n                            (and (nil? r1) (nil? l2)) (test-node l1 r2)\n                            (or (nil? l1) (nil? r1) (nil? l2) (nil? r2)) false\n                            :else (and (test-node l1 r2) (test-node r1 l2))))))]\n  (test-node (second %) (last %)))", "problem": 96, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn symmetric [[x l r]]\n  (letfn [(m [t] (when-let [[x l r] t] [x (m r) (m l)]))]\n    (= (m l) r)))", "problem": 96, "user": "51740b65e4b0d277d717bc67"}, {"code": "(fn [[a b c]]\n  ((fn f [[x1 x2 x3] [y1 y2 y3]] \n     (if (not= x1 y1)\n       false\n       (and \n         (if (sequential? x2) \n           (f x2 y3)\n           (every? nil? [x2 y3]))\n         (if (sequential? x3)\n           (f x3 y2)\n           (every? nil? [x3 y2]))))) b c))", "problem": 96, "user": "51899891e4b0288ada3dbdab"}, {"code": "(letfn [(mi [tr] (if (sequential? tr) (cons (first tr) (reverse (map mi (rest tr)))) tr))] #(= (nth % 1) (mi (nth % 2))))", "problem": 96, "user": "5134973ce4b0230e9f713b42"}, {"code": "(fn symetric? [[name left right]]\n  (let [rev  \n    (fn rev[[name left right]]\n     (cond \n      (and (nil? left) (nil? right)) [name left right]\n      (nil? left) [name (rev right) nil]\n      (nil? right) [name nil (rev left)]\n     :else\n      [name (rev right) (rev left)]\n     )\n    )]\n  \n  (cond \n   (and (nil? left) (nil? right)) true\n   :else (= left (rev right))\n  )\n )\n)", "problem": 96, "user": "4fb03cf4e4b081705acca262"}, {"code": "(fn [[h1 t1 t2 :as t]] (= t2 \n                          ((fn revTree [xs] (if (nil? xs) \n                                              xs \n                                              (let [[h x y & ys] xs] [h (revTree y) (revTree x)])\n                                             )) t1)))", "problem": 96, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn sym? \n  ([t] (sym? (second t) (last t)))\n  ([a b] (or \n          (and (nil? a) (nil? b))\n          (if (and (coll? a) (coll? b))\n            (and (= (count a) (count b) 3)\n                 (= (first a) (first b))\n                 (sym? (second a) (last b))\n                 (sym? (last a) (second b)))\n            false))))", "problem": 96, "user": "50435689e4b034ff00315d21"}, {"code": "(fn symmetric\n  [[root left right]]\n  (let [mirror? (fn mirror? [c1 c2]\n                  (cond \n                    (not= (sequential? c1) (sequential? c2)) false\n                    (sequential? c1)  (let [[v1 l1 r1] c1\n                                            [v2 l2 r2] c2]\n                                        (and (= v1 v2) (mirror? l1 r2) (mirror? r1 l2)))\n                   :else (= c1 c2)))]\n    (mirror? left right)))", "problem": 96, "user": "518ccf6be4b05e6c8537e386"}, {"code": "#(= % ((fn m [[v l r]] (if v [v (m r) (m l)])) %))", "problem": 96, "user": "51805d22e4b0e3fc13e244df"}, {"code": "(fn symmetric? [t]\n  (let [[root l r] t\n        invert (fn invert [s]\n                 (if (coll? s)\n                   (let [[root l r] s]\n                     (list root (invert r) (invert l)))\n                   s))\n        ir (invert r)]\n    (= l ir)))", "problem": 96, "user": "4fb79872e4b081705acca2d2"}, {"code": "(fn [xs]\n  (letfn [(tree-mirror [xs]\n            (if (nil? xs)\n              nil\n              [(first xs) (tree-mirror (last xs)) (tree-mirror (second xs))]))]\n    (if (nil? xs)\n      true\n      (= (second xs) (tree-mirror (last xs))))))", "problem": 96, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "#((fn s [l r]\n   (or\n     (= nil l r)\n     (and\n       (= (nth l 0) (nth r 0))\n       (s (nth l 1) (nth r 2))\n       (s (nth r 1) (nth l 2)))))  \n  (nth % 1)\n  (nth % 2))", "problem": 96, "user": "517bc969e4b07ef0e56148d0"}, {"code": "(fn [node]\n  (letfn [(lfw [node acc]\n            (if (nil? node) (conj acc nil)\n                (->> (conj acc (first node))\n                     (lfw (nth node 1))\n                     (lfw (nth node 2)))))\n          (rfw [node acc]\n            (if (nil? node) (conj acc nil)\n                (->> (conj acc (first node))\n                     (rfw (nth node 2))\n                     (rfw (nth node 1)))))]\n    (= (lfw node []) (rfw node []))))", "problem": 96, "user": "5126dbabe4b083bb8f88cf0e"}, {"code": "(fn symmetric? [t]\n  (let [reverse-tree (fn reverse-tree [t]\n                       (if (coll? t)\n                         (cons (first t) (reverse (map reverse-tree (rest t))))\n                         t))]\n  (= t (reverse-tree t))))", "problem": 96, "user": "51460e4ce4b04ef915e37314"}, {"code": "(fn symmetric-children? [node]\n  (letfn [(third [node]\n             (nth node 2))\n          (mirror-image [node]\n            (when (not (empty? node))\n              [(first node) (mirror-image (third node)) (mirror-image (second node))]))]\n    (= (second node) (mirror-image (third node)))))", "problem": 96, "user": "517531c6e4b07031762f2eea"}, {"code": "(fn f\n  ([tree] (f (second tree) (nth tree 2 '())))\n  ([leftree rigtree]\n    (println \"l: \" leftree \"   r: \" rigtree)\n    (let [lbranch #(nth % 1 :empty)\n          rbranch #(nth % 2 :empty)\n          root first]\n      (if (sequential? leftree)\n        (if (= (root leftree) (root rigtree))\n          (or (and (f (lbranch leftree)\n                      (rbranch rigtree))\n                   (f (rbranch leftree)\n                      (lbranch rigtree))))\n          false)\n        (if (= leftree rigtree)\n          true\n          false)))))", "problem": 96, "user": "51750cd4e4b07031762f2ee5"}, {"code": "(fn [t]\n    (letfn [(sym-tree [t]\n              (if (nil? t)\n                nil\n                (let [[v l r] t]\n                  [v (sym-tree r) (sym-tree l)]))\n             )]\n      (= t (sym-tree t))\n    )\n)", "problem": 96, "user": "51473a70e4b0d520409ed394"}, {"code": "(fn sym\n  ([t] (sym (second t) (last t)))\n  ([n m] (cond\n          (= n m nil) true\n          (and (= (first n) (first m))\n               (sym (second n) (last m))\n               (sym (last n) (second m))) true\n          :else false\n          )\n   )\n  )", "problem": 96, "user": "519b7d76e4b02a926d9a436e"}, {"code": "(fn [tree]\n  (letfn [(mirror [[x ltree rtree]]\n                  (when-not (nil? x)\n                    [x (mirror rtree) (mirror ltree)]))]\n    (= tree (mirror tree))))", "problem": 96, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn [xs]\n        (letfn [(equiv? [xs ys]\n                         (if (= nil xs ys)\n                           true                        \n                           (if (= 3 (count xs) (count ys))\n                               (if (= (first xs) (first ys))\n                                   (and (equiv? (second xs) (last ys))\n                                        (equiv? (last xs) (second ys)))\n                                 false)\n                             false)))]\n               (equiv? (second xs) (last xs))))", "problem": 96, "user": "51a8f0c6e4b08d8ec191b821"}, {"code": "(fn [f t] (= (f t) (reverse (f t))))\n   (fn [a] (filter\n           (complement sequential?)\n           (tree-seq sequential? (fn [[v l r]] [l v r]) a))\n   )", "problem": 96, "user": "4f9920a3e4b0dcca54ed6cfc"}, {"code": "(fn [root]\n  (letfn [(mirror-eq [a b]\n                     (or (and (nil? a) (nil? b))\n                         (and (coll? a)\n                              (coll? b)\n                              (= (first a) (first b))\n                              (mirror-eq (nth a 1) (nth b 2))\n                              (mirror-eq (nth a 2) (nth b 1)))))]\n    (mirror-eq (nth root 1) (nth root 2))))", "problem": 96, "user": "51aa2b4fe4b04e3dc0c27b21"}, {"code": "(fn sym [root]\n  (letfn [(trav [t]\n  (cond (nil? t) t\n        :else (concat (trav (nth t 1)) [(first t)] (trav (nth t 2)))))]\n  (= (trav (nth root 1)) (reverse (trav (nth root 2))))))", "problem": 96, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn [t]\n  (letfn [(rev-leaves [[b1 b2 b3]] [b1 b3 b2])\n          (rev-tree [t]\n            (let [rlt (rev-leaves t)\n                  rlfn (fn [l] (if (coll? l) (rev-tree l) l))]\n              (map rlfn (concat [(first rlt)] (rest rlt)))))\n          (symm? [[t1 t2 t3]] (= t2 (rev-tree t3)))]\n    (symm? t)))", "problem": 96, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn sym [x]\n  (let [match (fn match [a b]\n                (if (or (nil? a) (nil? b))\n                  (and (nil? a) (nil? b))\n                  (let [[av aa ab] a\n                        [bv ba bb] b]\n                    (and (= av bv) (match aa bb) (match ab ba)))))]\n    (match x x)))", "problem": 96, "user": "50a2f901e4b029e8bace362a"}, {"code": "(fn [[_ left right]]\n  (= left \n     ((fn mirror [root]\n  \t  (when-let [[id, left, right] root]\n       [id (mirror right) (mirror left)])) right)))", "problem": 96, "user": "51a7b4fee4b0da5f497bde8b"}, {"code": "(fn [x] \n(= x ((fn sm [y]  \n(let [[f s l] [(first y) (second y) (last y)]]\n (if  (nil? y) nil\n(list f (sm l) (sm s)) )))\nx)) )", "problem": 96, "user": "517945dce4b0684c1c981a43"}, {"code": "#(let [et (fn treequal? [t1 t2] (cond\n                                 (and (nil? t1) (nil? t2)) true\n                                 (or (nil? t1) (nil? t2)) false\n                                 (and (= (first t1) (first t2))\n                                      (treequal? (second t1) (nth t2 2))\n                                      (treequal? (nth t1 2) (nth t2 1))) \n                                     true\n                                 :else false\n                                 )\n            )\n       ]\n   (et (nth % 2) (nth % 1)))", "problem": 96, "user": "51bf4560e4b013aa0d74b817"}, {"code": "#((fn sym-tree? [x y]\n  \n  \n  \n  (or\n   (every? nil? [x y])\n   (and (every? coll? [x y])\n        (= (first x) (first y))\n        (sym-tree? (second x) (last y))\n        (sym-tree? (last x) (second y))))) (second %) (last %))", "problem": 96, "user": "50d3b03fe4b030b634c368b9"}, {"code": "#(let [t (fn t [[v l r]] [v (if r (t r)) (if l (t l))])\n       [_ l r] %]\n    (= l (t r)))", "problem": 96, "user": "4fa340b4e4b081705acca18c"}, {"code": "#(let [r (fn r [t] (if (coll? t)\n                     (let [[v a b] t]\n                         [v (r b) (r a)])\n                       t))]\n   (= (r %) %))", "problem": 96, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [x]\n    (=\n      (loop [s (conj '() (nth x 1))\n             a []]\n        (if (empty? s)\n          a\n          (recur (into (pop s) (rest (peek s))) (conj a (first (peek s))))\n          ))\n      (loop [s (conj '() (nth x 2))\n             a []]\n        (if (empty? s)\n          a\n          (recur (into (pop s) (reverse (rest (peek s)))) (conj a (first (peek s))))\n          ))))", "problem": 96, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "problem": 96, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "problem": 96, "user": "51bec919e4b013aa0d74b800"}, {"code": "#(= % ((fn mr [[n l r]] (if n [n (mr r) (mr l)])) %))", "problem": 96, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "#(= (second %) ((fn m [s] (if (sequential? s) (list (first s) (m (nth s 2)) (m (second s))) s)) (nth % 2)))", "problem": 96, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "(fn symmetric? [tree]\n  (let [flip-tree\n        (fn flip-tree [t]\n          (let [left (second t) right (nth t 2)]\n            (if (and (nil? left) (nil? right))\n              t\n              (cons (first t)\n                    (list (flip-tree right)\n                          (flip-tree left))))))]\n    (= tree (flip-tree tree))))", "problem": 96, "user": "51baff1be4b0fe3ecfb46443"}, {"code": "(fn [t]\n   (let [b1 (second t)\n         b2 (nth t 2)\n         mirror (fn f [t]\n                  (let [b1 (second t)\n                        b2 (nth t 2)]\n                    (if (every? nil? [b1 b2])\n                      t\n                      [(first t) (f b2) (f b1)])))]\n     (= (mirror b1) b2)))", "problem": 96, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "#(letfn [\n    (flip [x] (if (nil? x) nil\n        [(first x) (flip (nth x 2)) (flip (nth x 1))]))]\n    (= % (flip %)))", "problem": 96, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn sym? [[v l r]] (or (every? nil? [l r])\n                       (let [[lv ll lr] l\n                             [rv rl rr] r]\n                            (and (= lv rv)\n                                 (sym? [v ll rr])\n                                 (sym? [v lr rl])))))", "problem": 96, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [[_ l r]]\n  (let [m (fn m [[n l r]]\n            (vector n (if (coll? r) (m r) r) (if (coll? l) (m l) l)))]\n    (= l (m r))))", "problem": 96, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn __ [tree]\n  (let [[v l r] tree]\n    (= l ((fn reflect [tree]\n            (if (nil? tree)\n              tree\n              (let [[v l r] tree]\n                (list v (reflect r) (reflect l)))))\n          r))))", "problem": 96, "user": "51beb32ae4b013aa0d74b7fd"}, {"code": "(fn [[x l r]]\n  (letfn [(m [t]\n             (when-let [[x l r] t]\n               [x (m r) (m l)]))]\n    (= l (m r))))", "problem": 96, "user": "50d86fe2e4b01f0871336e67"}, {"code": "#(let [opposite (fn opp [[val left right :as tree]]\n                  (if (nil? tree)\n                    tree\n                    [val (opp right) (opp left)]))]\n   (= % (opposite %)))", "problem": 96, "user": "51789dfae4b03d69594194d7"}, {"code": "#(let [walk (fn walk [[k l r]] [(when (seq l) (walk l)) k (when (seq r) (walk r))])\n       s (keep identity (flatten (walk %))) \n       half (quot (count s) 2) \n       halves [(take half s) (reverse (drop (inc half) s))]] \n   (= (first halves) (second halves)))", "problem": 96, "user": "50a4f36be4b0344e360f3bc9"}, {"code": "(fn ?\n  ([t] (? t t))\n  ([[a b c :as l] [d e f :as r]]\n     (or (every? nil? [l r])\n     \t (and (= a d)\n              (? b f)\n              (? c e)))))", "problem": 96, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [[_ left right :as t]]\n  (letfn [(is-symmetrical? [[lv ll lr :as left] [rv rl rr :as right]]\n            (or (= left right nil)\n                (and (= lv rv)\n                     (is-symmetrical? ll rr)\n                     (is-symmetrical? lr rl))))]\n    (or (nil? t) (is-symmetrical? left right))))", "problem": 96, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn et [t]\n  (let [[_ x y] t]\n    (=\n     x\n     ((fn sym [y]\n        (concat\n         (if (coll? y)\n           (let [[z a b] y]\n             (vector z (if (coll? b) (sym b) b) (if (coll? a) (sym a) a) ))\n           [y])))\n      y))))", "problem": 96, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [[_ left right]]\n  (letfn [(mirror [node]\n            (if (coll? node)\n              (let [[v l r] node] (list v (mirror r) (mirror l)))\n              node))]\n    (= left (mirror right))))", "problem": 96, "user": "51057b2be4b06d28cacc92e8"}, {"code": "(fn [[_ left right]]\n  (let [rev (fn rev-tree [[r left right]]\n              (let [rev-if-tree #(if (coll? %) (rev-tree %) %)]\n                [r (rev-if-tree right) (rev-if-tree left)]))] \n    (= left (rev right))))", "problem": 96, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn symmetric? [tree]\n  (let [reflect (fn reflect [[v l r :as t]]\n                  (when-not (nil? t)\n                    (vector v (reflect r) (reflect l))))]\n    (= tree (reflect tree))))", "problem": 96, "user": "516199bbe4b009fba0926e36"}, {"code": "(fn sym? [t]\n  (letfn [(mirror [t]\n            (if (nil? t)\n              nil\n              (let [[e l r] t]\n                [e (mirror r) (mirror l)])))]\n    (let [[_ l r] t]\n      (= l (mirror r)))))", "problem": 96, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn cmp [[_ t1 t2]]\n  (if (or (nil? t1) (nil? t2))\n    (= t1 t2)\n    (let [[n1 l1 r1] t1\n          [n2 l2 r2] t2]\n      (and (= n1 n2) (cmp [nil l1 r2]) (cmp [nil r1 l2])))))", "problem": 96, "user": "51c8301ee4b07ef393169e4d"}, {"code": "(fn [tree]\n   (let [flip (fn f [[v l r]]\n                (if v\n                  (list v (f r) (f l) )                        \n                )\n              )\n        ]\n     (= (flip tree) tree)\n   )\n )", "problem": 96, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [[root left right]]\n\t(letfn [(symme? [a b]\n\t\t\t\t(cond\n\t\t\t\t\t(not= (coll? a) (coll? b)) false\n\t\t\t\t\t(coll? a) (let [[ra La Ra] a\n\t\t\t\t\t\t\t\t\t[rb Lb Rb] b]\n\t\t\t\t\t\t\t\t(and (= ra rb) (symme? La Rb) (symme? Lb Ra)))\n\t\t\t\t\t:else (= a b)))]\n\t\t(symme? left right)))", "problem": 96, "user": "51bdc609e4b0ff155d51d2b3"}, {"code": "(fn [[_ l r]]\n  (letfn [(swap [[v l r]] \n                (let [new-l (if (coll? l) (swap l) l)\n                      new-r (if (coll? r) (swap r) r)]\n                  [v new-r new-l]))]\n    (= l (swap r))))", "problem": 96, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn btree-symmetric?\n  [btree]\n  (letfn [(mirror-equals [left right]\n                         (if (or (nil? left) (nil? right))\n                           (and (= left nil) (= right nil))\n                           (and (= (first left) (first right))\n                                (mirror-equals (second left) (nth right 2))\n                                (mirror-equals (nth left 2) (second right)))))]\n    (mirror-equals (nth btree 1) (nth btree 2))))", "problem": 96, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn\n  [tr]\n  (let [mirror (fn mirror [tree]\n                 (if (coll? tree)\n                   (let [a (nth tree 2)\n                         b (second tree)]\n                     [(first tree) (mirror a) (mirror b)])\n                   tree))\n        left   (nth tr 2)\n        right  (second tr)]\n    (= left (mirror right))))", "problem": 96, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [a]\n   (letfn [(tree? [t]\n             (or (and (coll? t)\n                      (= (count t) 3)\n                      (every? tree? (rest t)))\n                 (nil? t)))\n           (reverse-tree [t]\n             (if (= nil t)\n               nil\n               (let [[n a b] t]\n                 [n (reverse-tree b) (reverse-tree a)])\n               )\n             )]\n     (let [rev (reverse-tree a)]\n       (= rev a))\n     )\n   )", "problem": 96, "user": "51d9eb05e4b02ceefd947755"}, {"code": "(fn [[_ lcol rcol ]]\n  (letfn [(sym-tree? [left right]\n                     (let [[l ll lr] left [r rl rr] right]\n                     \t(or (and (nil? l) (nil? r))\n                        \t (and (= l r)\n                              \t(sym-tree? ll rr)\n                              \t(sym-tree? lr rl)))))]\n    (sym-tree? lcol rcol)))", "problem": 96, "user": "51cbaf14e4b08d8387cbedda"}, {"code": "(fn [t]\n  (let [mirror (fn mirror [tree]\n                 (if (sequential? tree)\n                   [(first tree) (mirror (nth tree 2)) (mirror (second tree))]\n                   tree))]\n    (= t (mirror t))))", "problem": 96, "user": "501d34f6e4b066e56b9d0b1e"}, {"code": "#((fn s [t1 t2]\n     (cond\n       (and (nil? t1) (nil? t2)) true\n       (= (first t1) (first t2)) (and (s (second t1) (last t2))\n                                      (s (last t1) (second t2)))\n       :else false))\n   (second %) (last %))", "problem": 96, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn [[_ l r]]\n  (letfn [(check [[a l1 r1] [b l2 r2]]\n            (and (= a b)\n                 (or (every? nil? [r1 l2]) (check r1 l2))\n                 (or (every? nil? [r2 l1]) (check r2 l1))))]\n    (check l r)))", "problem": 96, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [[_ l r]] \n  (= l \n     ((fn m [a] (when-let [[v l r] a] [v (m r) (m l)])) r)))", "problem": 96, "user": "5046ee3ee4b03b02161376b4"}, {"code": "(fn sym [n]\n  (let [[v l r] n\n        flip (fn f [m]\n               (let [[v l r] m]\n                 (if (nil? v) v\n                   (list v (f r) (f l)))))]\n    (= l (flip r))))", "problem": 96, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn [[n l r]]\n  (letfn\n    [(rec-rev [[n l r]]\n         [n (if r (rec-rev r)) (if l (rec-rev l))])]\n    (= l (rec-rev r))))", "problem": 96, "user": "51e00020e4b01188f0627534"}, {"code": "(fn [[_ l r]]\n  (letfn [(trav [t l?]\n            (if (not (coll? t))\n              [t]\n              (let [[e & es] t]\n                (cons e (mapcat #(trav % l?) (if l? es (reverse es)))))))]\n    (= (trav l true)\n       (trav r false))))", "problem": 96, "user": "4fbf2818e4b081705acca317"}, {"code": "(fn sym[ft]\n  (let [inv (fn inv[t] (if (coll? t) [(first t) (inv (nth t 2)) (inv (second t))] t))] \n    (= (second ft) (inv (nth ft 2)))))", "problem": 96, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn sym [r]\n  (let [visit (fn visit [n] (lazy-cat (if (seq n)\n                          (apply concat (interpose ((juxt first)  n) (map visit (rest n))))\n                          ((juxt first) n))))\n      \ts (visit r)]\n    (= (take (dec (/ (count s) 2)) s) (reverse (drop (/ (count s) 2) s)))))", "problem": 96, "user": "51aab611e4b04e3dc0c27b2d"}, {"code": "(fn [et &]\n(letfn [(leftT [v &] \n            (if (coll? v)\n                (concat (list (first v)) (leftT (second v)) (leftT (nth v 2)) )\n                (list v)\n            )\n        )\n        (rightT [v2 &] \n            (if (coll? v2)\n                (concat (list (first v2)) (rightT (nth v2 2)) (rightT (second v2)))\n                (list v2)\n            )\n        )] \n  (= (leftT (second et)) (rightT (second (rest et)))  )\n)\n  )", "problem": 96, "user": "518aec06e4b06da86c1973c2"}, {"code": "(fn [[n l r]]\n    (letfn [\n        (more  [f t] (and t (f t))) \n        (mirror [[n l r]]\n                [n (more mirror r) (more mirror l)])]\n    (= (mirror l) r)\n    ))", "problem": 96, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [t]\n  (letfn [(mirror-tree [t]\n          (if (nil? t)\n            nil\n            [(first t)\n             (mirror-tree (last t))\n             (mirror-tree (second t))]))]\n    (let [value (first t)\n          left (second t)\n          right (last t)]\n      (if (nil? t)\n        true\n        (if (or (= left right)\n                (= left (mirror-tree right)))\n          true\n          false)))))", "problem": 96, "user": "51db0d99e4b06aa4d4669a9d"}, {"code": "#(let [mirror (fn mirror [t]\n   (if (nil? t) t\n     (let [[v a b] t]\n       (list v (mirror b) (mirror a)))))]\n    (= % (mirror %)))", "problem": 96, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "#(= ((fn f [[v l r :as t]]\n  (if (nil? t)\n    nil\n    [v (f r) (f l)])) %) %)", "problem": 96, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [tree]\n  (letfn [(f [[x1 l1 r1] [x2 l2 r2]]\n          \t(cond\n           \t\t(nil? x1) (nil? x2)\n           \t\t(not= x1 x2) false\n           \t\t:else (and (f l1 r2) (f r1 l2))))]\n    (f (nth tree 1) (nth tree 2))))", "problem": 96, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(letfn [(flip [t]\n           (if (sequential? t)\n             [(first t)\n              (flip (nth t 2))\n              (flip (nth t 1))]\n             t))]\n   #(= % (flip %)))", "problem": 96, "user": "4dbe8729535d020aff1edf62"}, {"code": "(fn symmetric? [tree]\n    (let [value #(nth % 0)\n          left #(nth % 1)\n          right #(nth % 2)\n          flatten-tree (fn flatten-tree [tree]\n                         (if (nil? tree) [nil]\n                           (concat (flatten-tree (left tree)) \n                                   [(value tree)] \n                                   (flatten-tree (right tree)))))]\n      (= (flatten-tree (left tree)) (reverse (flatten-tree (right tree))))))", "problem": 96, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "#((fn mir [l r]\n  (or \n   (= nil (first l ) (first r))\n   (and\n    (= (first l ) (first r)) \n    (mir (nth l 2 )  (nth r 1))\n    (mir (nth l 1 )  (nth r 2))\n    )\n   )\n  )\n  (second %) (last %))", "problem": 96, "user": "518c5236e4b087e178201de0"}, {"code": "(fn r [t]\n  (letfn [(rev [tree] (if (sequential? tree) [(nth tree 0) (rev (nth tree 2)) (rev (nth tree 1))] tree))]\n    (= t (rev t))))", "problem": 96, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [t]\n   (let [lt (second t)\n         rt (nth t 2)]\n     ((fn foo [lt rt]\n        (cond\n         (and (empty? lt) (empty? rt)) true\n         (= (first lt) (first rt)) (and (foo (second lt) (nth rt 2))\n                                        (foo (nth lt 2) (second rt)))\n         :else false))\n      lt rt)))", "problem": 96, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn [[root left right]]\n\t(letfn [\n\t\t(sym-tree? [left right]\n\t\t\t(or \n\t\t\t\t(and (nil? left) (nil? right))\n\t\t\t\t(and\n\t\t\t\t\t(= (first left) (first right))\n\t\t\t\t\t(sym-tree? (second left) (last right))\n\t\t\t\t\t(sym-tree? (last left) (second right)))))\n\t]\n\t\t(sym-tree? left right)\n))", "problem": 96, "user": "51ba4482e4b0fe3ecfb4642b"}, {"code": "#(let [tree ((fn ! [[v left right :as node]]\n                 (if (coll? node)\n                   (concat (! left) [v] (! right))\n                   [v])) \n             %)]\n   (= tree (reverse tree)))", "problem": 96, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "; The binary tree is in the format [node left right]. For symmetry the last two nodes must be\n; mirrors of each other. Easy enough when the nodes are not sequences (since then they must be equal).\n; However, when the nodes are sequences then we need to ensure that the left sequence is the same as\n; the mirror of the right one.\n;\n(fn sym? [node]\n\t(= (second node)\n\t  ((fn mirror [n]\n\t\t (if (sequential? n)\n\t\t\t(let [[a b c] (cons (first n) (reverse (rest n)))]\n\t\t\t\t [a (mirror b) (mirror c)] ) n)) (last node))))", "problem": 96, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "#(= \n  (map first (filter coll? (tree-seq coll? identity (second %))))\n  (map first (filter coll? (tree-seq coll? reverse (last %)))))", "problem": 96, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn sym? [[_ l r]]\n  (letfn [(rev [t]\n          (if (nil? t) nil\n            (let [[p l r] t]\n              [p (rev r) (rev l)])))]\n    (= l (rev r))))", "problem": 96, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn s ([l r] (if (and (sequential? l) (sequential? r)) (and (= (first l) (first r)) (s (second l) (last r)) (s (last l) (second r))) (= l r))) ([c] (s (second c) (last c))))", "problem": 96, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [t]\n\t(let [\n\t\trev (fn rev [t]\n\t\t\t(if (nil? t) nil\n\t\t\t\t[ (first t)\n\t\t\t\t  (rev (second (next t)))\n\t\t\t\t  (rev (second t))]))\n\t\tmirror? (fn mirror? [t]\n\t\t\t(= t (rev t)))\n\t\t]\n\t(and \n\t\t(mirror? t))))", "problem": 96, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn symm [args]\n  (let [flop (fn flip [args]\n    (if (= args nil)\n      nil\n      (let [[vali lc rc] args]\n        [vali (flip rc) (flip lc)])))]\n    (= (flop (flop args)) (flop args))))", "problem": 96, "user": "52173464e4b082aa80a88c75"}, {"code": "(fn [tree] (let [is-mirror (fn is-mirror [tree1 tree2]\n\t   (or (and (nil? tree1) (nil? tree2))\n\t       (and (not (nil? tree1))\n\t\t    (not (nil? tree2))\n\t\t    (coll? tree1)\n\t\t    (coll? tree2)\n\t\t    (= 3 (count tree1))\n\t\t    (= 3 (count tree2))\n\t\t    (let [[node1 l1 r1] tree1\n\t\t\t [node2 l2 r2] tree2]\n\t\t\t (and (= node1 node2)\n\t\t\t      (is-mirror l1 r2)\n\t\t\t      (is-mirror l2 r1)\n\t\t\t      )\n\t\t\t )\n\t\t    )\n\t       )\n\t   )]\n\t    (or (nil? tree)\n\t\t(and (coll? tree)\n\t\t     (= 3 (count tree))\n\t\t     (is-mirror (second tree) (last tree))))))", "problem": 96, "user": "5213ffd3e4b0961f15ac4d7d"}, {"code": "(fn symmetry? [x]\n  (let [left (fn [x] (nth x 1))\n       right (fn [x] (nth x 2))\n       tree? (fn istree? [x]\n               (if (nil? x) true\n                  (if-not (sequential? x) false\n                    (if-not (= (count x) 3) false\n                      (and (istree? (left x)) (istree? (right x)) )))))\n       mirror? (fn inner [a b]\n                 (cond (and (nil? a) (= a b)) true\n                   (and (not (or (nil? a) (nil? b))) (= (first a) (first b))) (and (inner (left a) (right b)) (inner (right a) (left b)))\n                   :else false))]\n    (and (tree? x) (mirror? (left x) (right x)))))", "problem": 96, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn [s] (let [o #(fn g [b] (if (empty? b) () (cons (nth b 0) (map g (% b)))))] (= ((o rest) s) ((o (comp reverse rest)) s))))", "problem": 96, "user": "52160dbee4b0bf4bffd29cb3"}, {"code": "(fn [t]    \n  (let [[v l r] t\n        mirror (fn mirror [x]\n          (if (not (sequential? x))\n            x\n            (let [[v l r] x]\n            [v (mirror r) (mirror l)]\n            )))\n        ]\n    (= l (mirror r))\n    ))", "problem": 96, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn [n] ((fn vn [a b]\n                   (if (= (class a) (class b))\n                       (if (coll? a)\n                           (if (= (first a) (first b))\n                                 (and (vn (second a) (last b)) \n                                      (vn (last a) (second b)))\n                             false)\n                         (= a b))\n                     false))\n           (second n) (last n)))", "problem": 96, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn symmetric\n  [t]\n  (letfn [(rev [child]\n            (when child\n              [(first child) (rev (nth child 2)) (rev (nth child 1))]))]\n    (= (rev (nth t 1))\n       (nth t 2))))", "problem": 96, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn compare-trees\n  [tree]\n  (let [switch (fn switch [t]\n                 (if (not (coll? t))\n                   t\n                   (vector (first t) (switch (last t)) (switch (second t)))))]\n    (= (second tree) (switch (last tree)))))", "problem": 96, "user": "52016fd3e4b0b2e020a18f10"}, {"code": "(fn clojure-96 [tree]\n  (letfn [(mirror-image [coll]\n             (cond\n              (nil? coll) coll\n              :else (list (first coll)\n                          (mirror-image (last coll))\n                          (mirror-image (second coll)))))]\n    (= (second tree) (mirror-image (last tree)))))", "problem": 96, "user": "5220bc0fe4b0e6a83c8925a7"}, {"code": "(fn f [[_ a b]]\n  (or (every? nil? [a b])\n      (and (every? coll? [a b])\n           (= (first a) (first b))\n           (f [0 (nth a 1) (nth b 2)])\n           (f [0 (nth a 2) (nth b 1)]))))", "problem": 96, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn ff [v] \n  ((fn f [v1 v2] \n  (if (and (sequential? v1) (sequential? v2))\n    (if (not= (first v1) (first v2))\n      false\n      (or false\n          (and (f (nth v1 1) (nth v2 2)) (f (nth v1 2) (nth v2 1)))))\n    (if (and (not (sequential? v1))\n             (not (sequential? v2)))\n      (= v1 v2) \n      false))) (nth v 1) (nth v 2)))", "problem": 96, "user": "52196842e4b0890f2f822bfa"}, {"code": "#(= (second %)\n    ((fn f [x] (if (coll? x) (conj \n                              [(first x)] \n                              (f (nth x 2)) \n                              (f (second x))))) \n     (nth % 2)))", "problem": 96, "user": "5065faf9e4b0313a384e5645"}, {"code": "(fn symm? [[v left right]]  \n  (= left ((fn flip-tree [[v left right]]\n            (let [new-left (if (sequential? right) (flip-tree right) right)\n                  new-right (if (sequential? left) (flip-tree left) left)]\n              [v new-left new-right]))\n           right)))", "problem": 96, "user": "5213dbc3e4b0961f15ac4d74"}, {"code": "(fn [[node left right]]\n                      (= left ((fn \u2a10 [[node left right]]\n                                 (when node [node (\u2a10 right) (\u2a10 left)]))\n                               right)))", "problem": 96, "user": "50e1bdd8e4b019fc399ce17f"}, {"code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "problem": 96, "user": "51ce1320e4b0e42293a22551"}, {"code": "(fn [tree]\n  (letfn [(bfs [tree depth fst snd]\n            (if (nil? tree)\n              []\n              (concat [depth (first tree)]\n                      (bfs (nth tree fst) (inc depth) fst snd)\n                      (bfs (nth tree snd) (inc depth) fst snd))))]\n    (= (bfs (nth tree 1) 0 1 2)\n       (bfs (nth tree 2) 0 2 1))))", "problem": 96, "user": "504db141e4b021508a333965"}, {"code": "(fn symmetry? [[_ l r]]\n  (letfn [(mirror? [[lv ll lr] [rv rl rr]]\n            (and (= lv rv)\n                 (or (every? nil? [ll lr rl rr])\n                     (and (mirror? ll rr) (mirror? lr rl)))))]\n    (mirror? l r)))", "problem": 96, "user": "4dac39a28cc9d6edb8beb0b3"}, {"code": "(fn [[_ L R]]\n  (letfn\n    [(flip [[v l r]] (list v (if (coll? r) (flip r) r) (if (coll? l) (flip l) l)))]\n    (= L (flip R))))", "problem": 96, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn sym-tree? [[h a b]]\n  (letfn [(mirror [[h a b :as t]]\n    \t\t(if (coll? t) [h (mirror b) (mirror a)] t))]\n    (= a (mirror b))))", "problem": 96, "user": "521679e9e4b0bf4bffd29cca"}, {"code": "(fn [root]\n  (letfn [(flip [node] (if (coll? node) [(first node) (flip (nth node 2)) (flip (nth node 1))] node))]\n    (= (nth root 1) (flip (nth root 2)))))", "problem": 96, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn balanced [[_ left right]]\n  (or (and (nil? left) (nil? right))\n      (and (= (first left) (first right))\n           (balanced [nil (second left) (last right)])\n           (balanced [nil (last left) (second right)]))\n  )     \n)", "problem": 96, "user": "5216933be4b000d124d989cf"}, {"code": "#(= % ((fn f [[n l r]] (if n [n (f r) (f l)] n)) %))", "problem": 96, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn symmetric? [x]\n  (letfn [(reflect [x] (when (not (nil? x))\n                       (let [[a b c] x] (vector a (reflect c) (reflect b)))))]\n    (= (reflect x) (reflect (reflect x)))))", "problem": 96, "user": "523d02b0e4b0dbf0c3017289"}, {"code": "(fn [tree]\n   (letfn [(rc [h r l]\n             (if (nil? h)\n               (= r l)\n               (let [[h1 r1 l1] l\n                     [h2 r2 l2] r]\n                 (and (= h1 h2)\n                      (rc h1 r1 l2)\n                      (rc h1 r2 l1)))))]\n     (let [[h r l] tree]\n       (rc h r l))))", "problem": 96, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "#((fn symmetric? [left right]\n  (let [lval (first left)\n        rval (first right)]\n    (if (or (nil? lval) (nil? rval))\n      (and (nil? lval) (nil? rval))\n      (and (= lval rval)\n        (let [ll (nth left 1)\n              lr (nth left 2)\n              rl (nth right 1)\n              rr (nth right 2)]\n          (and (symmetric? ll rr)\n               (symmetric? lr rl)))))))\n  (nth % 1) (nth % 2))", "problem": 96, "user": "51ae350fe4b09397d5109790"}, {"code": "(fn [t]\n  (letfn [(mirror [x]\n            (if (sequential? x)\n              (let [[a b c] x]\n                [a (mirror c) (mirror b)])\n              x))]\n    (= t (mirror t))))", "problem": 96, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn [[v l r]]\n  (letfn [(mirror [tree]\n   (when tree\n      (let [[v l r] tree] [v (mirror r) (mirror l)])))]\n    (= l (mirror r))))", "problem": 96, "user": "51dd9370e4b0c33a4e1da40c"}, {"code": "(fn [tree]\n  (= (->> (nth tree 1)\n          (tree-seq sequential? identity)\n          (filter (complement sequential?)))\n     (->> (nth tree 2)\n          (tree-seq sequential? (fn [[n cl1 cl2]] [n cl2 cl1]))\n          (filter (complement sequential?)))))", "problem": 96, "user": "52381b2ae4b0fae3832e99ef"}, {"code": "(fn problem-96\n  [t]\n  ((fn symm? [l r]\n    (println  l \"<->\" r)\n    (if\n      (or (and (nil? l) (nil? r))\n          \n          (and (= (first l) (first r))\n               (symm? (second l) (last r))\n               (symm? (last l) (second r))))\n      true\n      false\n    )) (second t) (last t)))", "problem": 96, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "#(let [[value l r] %]\n  (letfn [(mirror [s]\n            (cond\n             (nil? s) nil\n             (not (coll? s)) s\n             :else [(first s) (mirror (last s)) (mirror  (second s))])\n            )]\n    (= l (mirror r))))", "problem": 96, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn [t]\n  (letfn [\n          (fl [[v l r :as t]]\n              (cons v\n                    (lazy-seq\n                     (concat\n                      (if (seq l)\n                        (fl l)\n                        [:n])\n                      (if (seq r)\n                        (fl r)\n                        [:n])))))\n          \n          (fr [[v l r :as t]]\n              (cons v\n                    (lazy-seq\n                     (concat\n                      (if (seq r)\n                        (fr r)\n                        [:n])\n                      (if (seq l)\n                        (fr l)\n                        [:n])))))]\n    (apply = ((juxt fl fr) t))))", "problem": 96, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn sym-tree? [coll]\n  (let [is-sequence? (fn [h] (or (seq? h) (coll? h)))\n\t\tmirror       (fn mirror [c]\n\t\t\t\t\t     (if (is-sequence? c) \n\t\t\t\t\t\t      [(first c) (mirror (last c)) (mirror (second c))]\n\t\t\t\t\t\t      c))]\n    (if (is-sequence? coll) \n       (= (second coll) (mirror (last coll)))\n\t   true)))", "problem": 96, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn f \n  ([t] (if (= (count t) 3)\n         (f (nth t 1) (nth t 2))\n         false))\n  ([l r] (if (and (nil? l) (nil? r))\n           true\n           (and (= (first l) (first r))\n                (f (nth l 1) (nth r 2))\n                (f (nth l 2) (nth r 1))))))", "problem": 96, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn sym-tree?- [coll]\n  (letfn [(reverse-it [c]\n            (clojure.walk/postwalk\n             #(if (sequential? %1)\n                (conj (reverse (rest %1)) (first %1)) %1) c))]\n    (= (second coll) (reverse-it (last coll)))))", "problem": 96, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [[_ l r]]\n  ((fn mirror? [[a b c] [d e f]]\n     (cond\n      (not (= a d)) false\n      (= nil b c e f) true\n      :else (and (mirror? b f) (mirror? c e)))) l r))", "problem": 96, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(letfn [(deep-swap [x]\n                   (if (nil? x) x\n                     (list (first x)\n                           (deep-swap (last x))\n                           (deep-swap (second x)))))]\n  #(= (second %) (deep-swap (last %))))", "problem": 96, "user": "52437703e4b076204b44fabf"}, {"code": "(fn [tree]\n  (let [flat-tree ((fn make-flat [t] \n                     (if (nil? t)\n                       '()\n                       (concat \n                        (make-flat (second t)) \n                        (list (first t)) \n                        (make-flat (last t))))) tree)\n        half (/ (dec (count flat-tree)) 2)\n        left (take half flat-tree)\n        right (drop (inc half) flat-tree)] \n    (= left (reverse right))))", "problem": 96, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn is-tree-symmetric? [tree]\n  (let [rev-tree (fn rev-tree [tree]\n                   (if (sequential? tree)\n                     (let [[h & hs] tree] (concat (list h) (reverse (map rev-tree hs))))\n                     tree))\n        lb (nth tree 1)\n        rb (nth tree 2)\n        rlb (rev-tree lb)]\n    (= rlb rb)))", "problem": 96, "user": "523b82efe4b07becd5be21f0"}, {"code": "#(= (second %)  ((fn -recur [-seq stock]\n                                                   (if (sequential? -seq)\n                                                     (let [s -seq]\n                                                       [(first -seq) (-recur (last s) (last s)) (-recur (second s) (second s))]\n                                                       )\n                                                     stock\n                                                     )\n                                                   ) (last %) []))", "problem": 96, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn [[a b c]]\n  (letfn [(m [[rt l r]]\n            (and rt [rt (m r) (m l)]))]\n    (= b (m c))))", "problem": 96, "user": "4f048f67535dcb61093f6bd3"}, {"code": "(fn [t]\n  (= (map first (tree-seq sequential? next t)) \n     (map first (tree-seq sequential? (comp reverse next) t))))", "problem": 96, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [t]\n  (letfn [(invert [node] \n          \t(if (sequential? node) \n              [(first node) (invert (nth node 2)) (invert (second node))] node))]\n    (= (first (rest t)) (invert (second (rest t))))))", "problem": 96, "user": "51990df9e4b068aa333628fc"}, {"code": "(fn [[v tl tr]]\n  (let [mirror (fn mirror [t] (if (nil? t) t (vector (first t) (mirror (nth t 2)) (mirror (nth t 1)))))]\n    (= tl (mirror tr))))", "problem": 96, "user": "521dceeae4b050d5da042802"}, {"code": "(fn sym?\n  ([tree]\n     (if (nil? tree)\n       true\n       (sym? (nth tree 1) (nth tree 2))))\n  ([left right]\n     (cond\n      (and (nil? left) (nil? right)) true\n      (nil? left) false\n      (nil? right) false\n      :else (let [[lv ll lr] left\n                  [rv rl rr] right]\n              (and (= lv rv)\n                   (sym? ll rr)\n                   (sym? lr rl))))))", "problem": 96, "user": "519db0ede4b037b32803f9b9"}, {"code": "(fn sbtr\n      ([xs] (let [ [m l r] xs] (sbtr l r)))\n      ([l r] \n         (let [  [m1 l1 r1] l [m2 l2 r2] r ]\n            (if(and (nil? l) (nil? r)) true\n              (and (= m1 m2)\n                   (sbtr l1 r2)\n                   (sbtr l2 r1))))))", "problem": 96, "user": "50b25f2ce4b03ea88043355f"}, {"code": "(fn sym [t]\n  (letfn \n    [\n     (trev [x]\n           (if (nil? x)\n             nil\n             (vector (first x) (trev (nth x 2)) (trev (second x)))\n             )\n           )\n     ]\n    (= (second t) (trev (nth t 2)))\n    ))", "problem": 96, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn sym? [tree]\n  (let [mirror (fn mirror [t]\n                 (if (nil? t) nil\n                   (let [ [v l r] t]\n                     [v (mirror r) (mirror l)] )))]\n    (if (nil? tree) true\n      (let [ [v l r] tree]\n        (if (= l (mirror r))\n          true\n          false)))))", "problem": 96, "user": "5224a46ce4b01819a2de42e5"}, {"code": "(fn [[tn tl tr]]\n  (let [reverse-subtree (fn f [[n l r]] (if (nil? n) nil [n (f r) (f l)])\n                          )]\n    (= tl (reverse-subtree tr))\n    )\n  )", "problem": 96, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn f\n      ([coll]\n         (condp = (count coll)\n           1 true\n           3 (f (nth coll 1) (nth coll 2))\n           false))\n      ([node1 node2]\n         (if-not (= (count node1) (count node2))\n           false\n           (condp = (count node1)\n             0 true\n             1 (= (first node1) (first node2))\n             3 (and (= (first node1) (first node2))\n                    (f (nth node1 1) (nth node2 2))\n                    (f (nth node1 2) (nth node2 1)))\n             false))))", "problem": 96, "user": "506c0a02e4b0eda3100c090d"}, {"code": "(fn sym? [t]\n  (letfn [(flip [t]\n          (if (or (not (sequential? t)) (empty? t))\n            t\n            [(first t) (flip (nth t 2)) (flip (nth t 1))]))\n          ]\n    (= t (flip t))))", "problem": 96, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn [coll]\n   (let [ [root left right] coll \n  \n          synimpl (fn __syn [root dir] (if (nil? root) nil(let [ [c l r] root ](if (zero? dir)(conj [] c (__syn l dir) (__syn r dir) )(conj [] c (__syn r dir) (__syn l dir) )))))\n        ]\n        (= (synimpl left 0) (synimpl right 1))\n   )\n)", "problem": 96, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn myfn? [s]\n\t(let [[x y z] s]\n    \t(= z ((fn mirror [a] (if (coll? a)\n                                   \t(let [[c l r] a]\n                                    \t[c (mirror r) (mirror l)]\n                                    )\n                                    a\n                                  )\n                    ) y)\n        )\n    )\n)", "problem": 96, "user": "525ba7bbe4b0cb4875a45d28"}, {"code": "#((fn eq [s t]\n  (if (and (nil? s) (nil? t)) true (and (= (first s) (first t)) (eq (second s) (last t)) (eq (last s) (second t)))))\n (second %) (last %))", "problem": 96, "user": "5259a16ee4b0cb4875a45ce1"}, {"code": "(fn symetric? [tree]\n  (let [flat (\n          \t\t(fn inorder [[value left right :as tree]]\n  (flatten\n    (if (sequential? tree)\n      (vector\n        (inorder left)\n        value\n        (inorder right)\n        )   \n      tree\n      )   \n    )   \n  )\ntree)\n        reversed (reverse flat)\n        ]   \n    (= flat reversed)\n    )   \n  )", "problem": 96, "user": "5228f870e4b0186687e23a98"}, {"code": "(fn [tree]\n  (letfn [(compare-stuff [left right]\n            (if (not (= (first left) (first right)))\n              false\n              (cond (and (sequential? (second left))\n                         (sequential? (second right))\n                         (sequential? (last left))\n                         (sequential? (last right)))\n                    (and (compare-stuff (second left) (last right))\n                         (compare-stuff (last left) (second right)))\n                    (and (sequential? (second left)) (sequential? (last right)))\n                    (and (compare-stuff (second left) (last right))\n                         (= (last left) (second right)))\n                    (and (sequential? (last left)) (sequential? (second right)))\n                    (and (= (second left) (last right))\n                         (compare-stuff (last left) (second right)))\n                    :else\n                    (and (= (second left) (last right)) (= (last left) (second right))))))]\n    (compare-stuff (second tree) (last tree))))", "problem": 96, "user": "523288fee4b035af41902a88"}, {"code": "(fn [root]\n  (letfn [(flip [[value left right :as node]]\n             (when node \n               [value (flip right) (flip left)]))]\n  (= root (flip root))))", "problem": 96, "user": "5244fa73e4b0d8acf9ed6acb"}, {"code": "(fn [tr]\n  (letfn [(rev-tr [[p l r]]\n    [p (when r (rev-tr r))\n       (when l (rev-tr l))])]\n    (= tr (rev-tr tr))))", "problem": 96, "user": "5213d7aae4b0961f15ac4d72"}, {"code": "(fn [lst]\n  (let [sym? (fn sym? [l r]\n              (and (= (first l) (first r))\n               (cond (nil? l) (nil? r)\n                     (nil? r) false\n                     :else (and (sym? (second l) (last r))\n                                (sym? (last l) (second r))))))]\n    (sym? (second lst) (last lst))))", "problem": 96, "user": "525372ade4b0541d1855b8f3"}, {"code": "(fn [root]\n  (letfn [(revert-tree-nocheck [[v l r]] [v (revert-tree r) (revert-tree l)])\n          (revert-tree [r] (if r (revert-tree-nocheck r) r))]\n    (= (revert-tree (second root)) (last root))))", "problem": 96, "user": "51df825de4b01188f062752b"}, {"code": "(fn [tree]\n  (letfn [(flip-tree [t]\n            (cond\n             (not t) t\n             (not (coll? t)) t\n             :else [(first t)\n                    (flip-tree (last t))\n                    (flip-tree (second t))]))]\n    (= (second tree) (flip-tree (last tree)))))", "problem": 96, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "#(letfn [ (symmetric? [l r] \n             (cond (or (= nil l r)\n                       (and (= (count l) (count r) 3)\n                            (= (first l) (first r))\n                            (symmetric? (second l) (last r))\n                            (symmetric? (last l) (second r)))) true\n                   :else false\n       ))]\n    (and (= (count %) 3)\n         (symmetric? (second %) (last %))))", "problem": 96, "user": "52655949e4b03e8d9a4a710b"}, {"code": "(fn check-sym [[val l-tree r-tree]]\n  (letfn [(reverse-btree [[val l-chld r-chld :as node]]\n           (if (= node nil) nil\n             [val (reverse-btree r-chld) (reverse-btree l-chld)]))]\n    (= l-tree (reverse-btree r-tree))))", "problem": 96, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn g [x]\n  (let [[_ j k] x]\n  (letfn [(f [a b]\n    (if (or (nil? a) (nil? b))\n      (= a b)\n      (let [[x ll lr] a [y rl rr] b]\n        (and (= x y) (f ll rr) (f lr rl))\n      )\n    )\n            )]\n    (f j k)\n    )\n  )\n)", "problem": 96, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn symmetric?\n  ([node]\n   (symmetric? (second node) (last node)))\n  ([lnode rnode]\n   (if (and (nil? lnode) (nil? rnode))\n     true\n     (and (= (first lnode) (first rnode))\n          (symmetric? (second lnode) (last rnode))\n          (symmetric? (last lnode) (second rnode))))))", "problem": 96, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn [t]\n  (apply\n    (fn sym? [t1 t2]\n      (or\n        (= t1 t2 nil)\n        (let [[v1 l1 r1] t1\n              [v2 l2 r2] t2]\n          (and\n            (= v1 v2)\n            (sym? l1 r2)\n            (sym? l2 r1)))))\n    (rest t)))", "problem": 96, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn sym [[v l r]]\n  (letfn [(eq-mir [t1 t2]\n            (if-let [[v1 l1 r1] t1]\n              (if-let [[v2 l2 r2] t2]\n                (and (= v1 v2) (eq-mir l1 r2) (eq-mir l2 r1))\n                false)\n              (= nil t1 t2)))]\n    (eq-mir l r)))", "problem": 96, "user": "5217c26fe4b0a4bccb16cab8"}, {"code": "(fn symmetric-tree?\n  ([t] (symmetric-tree? t t))\n  ([t1 t2]\n    (if (= t1 t2 nil)\n      true\n      (and\n        (= (first t1) (first t2))\n        (symmetric-tree? (nth t1 1) (nth t2 2))\n        (symmetric-tree? (nth t1 2) (nth t2 1))))))", "problem": 96, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "#(\n   (fn f [t1 t2]\n     (cond\n       (and (nil? t1) (nil? t2)) true\n       (not= (first t1) (first t2)) false\n       :else (and (f (second t1) (last t2)) (f (last t1) (second t2)))))\n   (second %) (last %))", "problem": 96, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn [x]\n   (let [mirrored (fn mirrored [t]\n                    (if (sequential? t)\n                      (let [h (first t)\n                            l (second t)\n                            r (nth t 2)]\n                        [h (mirrored r) (mirrored l)])\n                      t))   \n         l (second x)   \n         r (nth x 2)] \n     (= l (mirrored r))))", "problem": 96, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn go [t]\n  (letfn\n    [(sym? [a b]\n           (cond\n            (and (nil? a) (nil? b)) true\n            (nil? a) false\n            (nil? b) false\n            :else (and (= (first a) (first b)) (sym? (nth a 1) (nth b 2)) (sym? (nth a 2) (nth b 1)))))]\n    (sym? (nth t 1) (nth t 2))\n    ))", "problem": 96, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn f [tree]\n  (let [g\n        (fn h [left-root right-root]\n          (if (and (nil? left-root) (nil? right-root))\n            true\n            (if (not= (first left-root) (first right-root))\n              false\n              (and\n                (h (fnext left-root) (first (nnext right-root)))\n                (h (first (nnext left-root)) (fnext right-root))\n              )\n            )\n          )\n        )]\n    (g (fnext tree) (first (nnext tree)))\n  )\n)", "problem": 96, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn sym\n  ([t] (sym (second t) (last t)))\n  ([t1 t2] (cond (and (coll? t1) (coll? t2)) (and (sym (first t1) (first t2))\n\t                                              (sym (second t1) (last t2))\n                                                  (sym (last t1) (second t2)))\n                 (or (coll? t1) (coll? t2)) false\n                 :else (= t1 t2))))", "problem": 96, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn p96 [lst]\n   (letfn [(tree? [lst]\n             (or (nil? lst)\n                 (and (coll? lst) (= 3 (count lst))\n                      (let [[v l r] lst] (and (tree? l) (tree? r))))))\n           (revtree [lst]\n             (if (nil? lst) lst\n                 (if (and (coll? lst) (= 3 (count lst))\n                          ) (let [[v l r] lst] [v (revtree r) (revtree l)]) nil)))]\n      (let [t1 (tree? lst)\n           [rt1 rt2] (let [[v l r] lst] [(revtree l) (revtree (revtree r))])] (and t1 (= rt1 rt2)))))", "problem": 96, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn chk-sym [s] \n   ((fn inner [x y] \n\t\t(or (and (coll? x)\n                 (coll? y)\n                 (= (first x)(first y)) \n                 (inner (second x)(last y))\n                 (inner (last x)(second y))\n             )\n             (and(not (coll? x))(= x y)))\n     )(second s) (last s)))", "problem": 96, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn sym?\n  ([tree]\n    (or\n      (nil? tree)\n      (sym? (second tree) (second (rest tree)))))\n  ([l r]\n    (or\n      (and\n        (nil? l)\n        (nil? r))\n      (and\n       (= (first l) (first r))\n       (sym? (second l) (second (rest r)))\n       (sym? (second (rest l)) (second r))))))", "problem": 96, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn [tree]\n    (letfn [(tr [t]\n              (if (nil? t)\n                nil\n                (cons (first t) (list (tr (nth t 2)) (tr (nth t 1))))))]\n      (if (= (nth tree 1) (tr (nth tree 2)))\n        true\n        false)))", "problem": 96, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(letfn [(r [n] (if n (let [[v a b] n] [v (r b) (r a)])))]\n  #(= (r (nth % 1)) (nth % 2)) )", "problem": 96, "user": "4df20dda535d08e6dec9fe23"}, {"code": "(fn [[_ L R]]\n  (letfn\n    [(flip [[v l r]] (list v (if (coll? r) (flip r) r) (if (coll? l) (flip l) l)))]\n    (= L (flip R))))", "problem": 96, "user": "527b856fe4b03e8d9a4a758d"}, {"code": "#(letfn [(mirror [b] \n              (when-let [[x l r] b] \n                 [x (mirror r) (mirror l) ])) ]\n   (let [[_ l r] %]  \n     (= l (mirror r))))", "problem": 96, "user": "519ef784e4b087743fad2198"}, {"code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "problem": 96, "user": "51622fb8e4b009fba0926e3f"}, {"code": "(fn symmetric? [[val left right]]\n  (let [mirror (fn mirror [x]\n                 (if (nil? x)\n                   x\n                   (let [[v l r] x]\n                     [v (mirror r) (mirror l)])))]\n    (or\n      (= nil left right)\n      (= left (mirror right)))))", "problem": 96, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn [[n l r]] (= ((fn mirror [node] \n                    (if (coll? node) (let [[p c1 c2] node] [p (mirror c2) (mirror c1)]) node)) l) \n                 r))", "problem": 96, "user": "523b1988e4b02f719975bdbc"}, {"code": "(letfn [(mirror-image? \n         [lt rt]\n         (let [rvalue (first rt) lvalue (first lt)]\n         (if (and (nil? lvalue) \n                  (nil? rvalue))\n           true\t\n           (and (= lvalue rvalue)\n                (mirror-image? (second lt) (last rt))\n                (mirror-image? (last lt) (second rt))))))]\n  (fn symmetric? [t]\n    (mirror-image? (second t) (last t))))", "problem": 96, "user": "4ea5ba92535d7eef308072d9"}, {"code": "(fn fff\n  ([n] (fff (second n) (nth n 2)))\n  ([l r] (or (and (nil? l) (nil? r))\n             (and (= (first l) (first r))\n                  (fff (second l) (nth r 2))\n                  (fff (nth l 2) (second r))))))", "problem": 96, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn symmetric? [[node left right]]\n  (= left ((fn flip [[_node _left _right]]\n             (if _node [_node (flip _right) (flip _left)]))\n           right)))", "problem": 96, "user": "5290257ae4b0239c8a67af03"}, {"code": "(fn [[_ l r]] (let [same? (fn same? [[a la ra] [b lb rb]] (if (= a b nil) true \n                   (and (= a b) (same? la rb) (same? ra lb) )))]\n              (same? l r)\n              ))", "problem": 96, "user": "4f9510b5e4b0dcca54ed6cc7"}, {"code": "(fn [x] \n  (letfn [(tt [x] (if x [(tt (second x)) (first x) (tt (last x))] nil))]\n    (let [f (flatten (tt x))] (= f (reverse f)))))", "problem": 96, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [[n l r]]\n    (= l\n       ((fn f [[n l r]]\n          (if n [n (f r) (f l)]))\n        r)))", "problem": 96, "user": "4e72ac47535d5021c1a89666"}, {"code": "(fn [[v l r]]\n  (letfn [(f [c] (if (coll? c) (let [[v l r] c] [v (f r) (f l)]) c))]\n    (= (f l) (f (f r)))))", "problem": 96, "user": "4f6511eee4b07046d9f4ef3a"}, {"code": "(fn is-symmetry [tree]\n  (letfn[(is-same-tree[a b]\n         (if(and (sequential? a) (sequential? b))\n           (let[l1 (first a)\n                l2 (second a)\n                l3 (nth a 2)\n                r1 (first b)\n                r2 (second b)\n                r3 (nth b 2)]\n             (and (= l1 r1) \n                       (is-same-tree l2 r3) (is-same-tree l3 r2)))\n           (= a b)))]\n    (is-same-tree (second tree )\n                  (nth tree 2))))", "problem": 96, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn check-symmetry\n  ([node] (check-symmetry (second node) (last node)))\n  ([left right] \n   (if (and (nil? left) (nil? right)) true\n     (if (or (nil? left) (nil? right)) false\n       (and (= (first left) (first right))\n            (check-symmetry (second left) (last right))\n            (check-symmetry (last left) (second right)))))))", "problem": 96, "user": "51cec7b1e4b0e42293a2255b"}, {"code": "(fn [input]\n  ((fn mirror? [a b]\n     (or\n        (and (nil? a) (nil? b))\n        (and\n         (= (first a) (first b))\n         (mirror? (nth a 1) (nth b 2))\n         (mirror? (nth a 2) (nth b 1)))))\n   (nth input 1) (nth input 2)))", "problem": 96, "user": "528bba38e4b0239c8a67aea9"}, {"code": "(fn sd? [t]\n  (letfn [(sd1? [c1, c2]\n            (cond\n             (and (nil? c1) (nil? c2)) true\n             (or (and (sequential? c1) (not (sequential? c2)))\n                 (and (sequential? c2) (not (sequential? c1)))) false\n                 :else (and (= (first c1) (first c2))\n                            (sd1? (second c1) (second (rest c2)))\n                            (sd1? (second (rest c1)) (second c2) ))))]\n    (sd1? (second t) (second (rest t)))))", "problem": 96, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [[_ l r]]\n  (letfn [(flip [x] (if (coll? x)\n                      (let [[v l r] x]\n                        [v (flip r) (flip l)])\n                      x))]\n    (= l (flip r))))", "problem": 96, "user": "515ead6be4b049add99a053e"}, {"code": "(fn sym [[v l r :as t]] ((fn symcmp [t1 t2]\n  (cond\n   (nil? t1) (nil? t2)\n   (nil? t2) (nil? t1)\n   true (let [[v1 l1 r1] t1 \n              [v2 l2 r2] t2]\n          (and (= v1 v2)\n               (symcmp l1 r2)\n               (symcmp l2 r1))))) l r))", "problem": 96, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(let [rev (fn rev [[n l r]] (when n [n (rev r) (rev l)]))]\n  (fn [[_ l r]] (= l (rev r))))", "problem": 96, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "#(= %\n    ((fn f [[n l r]]\n       (if n\n         [n (f r) (f l)]))\n     %))", "problem": 96, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [[v l r]]\n  (letfn [(f\n          [b]\n          (if (seq b)\n            (let [[v l r] b]\n              (list v (f r) (f l)))\n            b))]\n    (= l (f r))))", "problem": 96, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(fn xx [coll] ((fn mirror2 [x y] (if (= (first x) (first y))\n                                       (if (or (and (coll? (second x)) (coll? (last y))) (and (coll? (last x)) (coll? (second y))))\n                                         (and (mirror2 (second x) (last y)) (mirror2 (last x) (second y)))\n                                         (and (= (second x) (last y)) (= (last x) (second y)))\n                                         )\n                                     false)) (second coll) (last coll)))", "problem": 96, "user": "5296aa9be4b02ebb4ef75034"}, {"code": "(fn [[_ l r]] \n  (letfn [(mirror [t] (if (seq t) (cons (first t) (reverse (map mirror (rest t))))))] \n    (= l (mirror r))))", "problem": 96, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn symetric?\n  [coll]\n  (let [m? (fn mirror? [l r]\n             (if (or (nil? l) (nil? r)) (and (nil? l) (nil? r))\n               (and (= (first l) (first r))\n                    (= 3 (count l))\n                    (= 3 (count r))\n                    (mirror? (second l) (last r))\n                    (mirror? (last l) (second r)))))]\n    (m? (second coll) (last coll))))", "problem": 96, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [[p l r]]\n  (= l\n     ((fn f [[p l r :as t]]\n        (if (coll? t)\n          [p (f r) (f l)]\n          t))\n      r)))", "problem": 96, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [x] ( (fn sym [y z] \n\t\t(if \n\t\t\t(= nil y z) \n\t\t\ttrue \n\t\t\t(if \n\t\t\t\t(or (= nil y) (= nil z)) \n\t\t\t\tfalse \n\t\t\t\t(if \n\t\t\t\t\t(= (first y) (first z)) \n\t\t\t\t\t(if\n\t\t\t\t\t\t(and \n\t\t\t\t\t\t\t(sym (second y) (last z))\n\t\t\t\t\t\t\t(sym (second z) (last y))\n\t\t\t\t\t\t)\n\t\t\t\t\t\ttrue\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\t\t\t\t\tfalse\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t) (second x) (last x) ))", "problem": 96, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn tsym? [[a b c]]\n  (letfn [(trev\n           ([] nil)\n           ([a] a)\n           ([n l r] [n (apply trev r) (apply trev l)]))]\n    (= b (apply trev c))))", "problem": 96, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn symmetric? [[n l r :as t]]\n  (if (or (nil? t) (and (nil? l) (nil? r)))\n    true\n    (letfn [(left-branch [t] (second t))\n            (right-branch [t] (nth t 2))\n            (node [t] (first t))]\n      (and (= (first l) (first r))\n           (symmetric? [:dummy (left-branch l) (right-branch r)])\n           (symmetric? [:dummy (right-branch l) (left-branch r)])))))", "problem": 96, "user": "4ee8b9c9535d93acb0a66884"}, {"code": "(fn sym\n  ([[node left right]] (sym left right))\n  ([[n1 l1 r1] [n2 l2 r2]]\n    (or (= n1 n2 nil)\n        (and (= n1 n2)\n             (sym l1 r2)\n             (sym l2 r1)))))", "problem": 96, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn [d]\n  (letfn [\n          (eqq [a b] \n                (if (and (coll? a) (coll? b))\n                  (and \n                    (= (count a) (count b) 3) \n                    (= (first a) (first b))\n                    (eqq (second a) (last b))\n                    (eqq (second b) (last a))\n                    )\n                  (= a b)\n                  )\n                )\n                ]\n          (eqq (second d) (last d))\n          )\n  )", "problem": 96, "user": "510b704ee4b078ea71921100"}, {"code": "(fn [a]\n       (let [[u v w] a]\n         (letfn [(rev [x]\n           (if (sequential? x)\n             (let [[a b c] x]\n               (list a (rev c) (rev b)))\n             x))]\n           (= v (rev w)))))", "problem": 96, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [[_ a b]]\n    (letfn [(mirror? [a b]\n              (if (and (coll? a) (coll? b))\n                (let [[ah al ar] a\n                      [bh bl br] b]\n                  (and (= ah bh)\n                       (mirror? al br)\n                       (mirror? ar bl)))\n                (= a b)))]\n      (mirror? a b)))", "problem": 96, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn n96 [tree]\n  (letfn [(rev-tree [t]\n                    (if \n                      (sequential? t) \n                      (vector (first t) (rev-tree (last t)) (rev-tree (second t)))\n                      t))]\n    (= (rev-tree (last tree)) (second tree))))", "problem": 96, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [[root left right]]\n  (=\n   ((fn mirror [[r le ri]]\n      (if r\n        [r (mirror ri) (mirror le)]\n        r)) left)\n   right))", "problem": 96, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn msym\n  [[_ s l]]\n  (cond\n   (= s l nil) true\n   (and (sequential? s) (sequential? l)) (and\n                                          (= (first s) (first l))\n                                          (msym [nil (second s) (last l)])\n                                          (msym [nil (last s) (second l)]))\n   :d false))", "problem": 96, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn symm? [tree]\n  (letfn [(symmetry? [left-child right-child]\n                     (cond \n                      (= [true true] \n                         [(nil? left-child) (nil? right-child)]) true\n                      (= [false false] \n                         [(nil? left-child) (nil? right-child)]) (and (= (first left-child) (first right-child))\n                                                                      (symmetry? (second left-child) (last right-child))\n                                                                      (symmetry? (last left-child) (second right-child)))\n                      :else false))]\n    (symmetry? (second tree) (last tree))))", "problem": 96, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn [tree]\n  (let [rev-tree\n        (fn rev-tree [n]\n          (if n [(first n)\n                 (rev-tree (nth n 2))\n                 (rev-tree (nth n 1))]))]\n    (= tree (rev-tree tree))))", "problem": 96, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn [t]\n  (let [flip\n\t(fn flip [t]\n      (if (nil? t)\t\n        nil\n        (list (first t) (flip (second (rest t))) (flip (second t))))\n      )\n        ]\n      (= (second t) (flip (last t)))))", "problem": 96, "user": "52bb27fee4b07a9af57922df"}, {"code": "(fn symmetree [t]\n  (let [traverse-in-order (fn traverse-in-order [btree]\n                            (let [[v l r] btree]\n                              (if (sequential? btree)\n                                (concat (traverse-in-order l) \n                                        [v]\n                                        (traverse-in-order r)))\n                              ))]\n    (= (reverse (traverse-in-order t)) (traverse-in-order t))\n    ))", "problem": 96, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn btree-symmetric?\n  [tree]\n  (letfn [(flip [t]\n            (if (sequential? t)\n              (let [v (first t)\n                    l (second t)\n                    r (last t)]\n                [v (flip r) (flip l)])\n              t))]\n    (= (second tree) (flip (last tree)))))", "problem": 96, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [tree]\n   (let [mirrored (fn f [node]\n                    (if (sequential? node)\n                      (let [[head left right] node]\n                        [head (f right) (f left)])\n                      node))\n         [head left right] tree]\n     (= left (mirrored right))))", "problem": 96, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn mirrortree [[h l r]]\n\t(let [mm (fn mm [t]\n\t\t\t(if (nil? t)\n\t\t\t\tt\n\t\t\t\t(let [[h l r] t] [h (mm r) (mm l)])\n\t\t\t)\n\t\t\t\n\t\t)]\n\t\t(= l (mm r))\n\t))", "problem": 96, "user": "527ba695e4b03e8d9a4a7596"}, {"code": "(fn sym? \n  ([a] \n     (sym? a a)) \n  ([a b]  \n     (cond (and (coll? a) (coll? b)) (apply sym? (concat a b))      \n           :else (= a b)))\n  ([a b c d e f] \n     (and (= a d) (sym? b f) (sym? e c))))", "problem": 96, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "(fn mirror-equal[t]\n  (= (second t)\n     ((fn mirror[t]\n        (cond\n         (not (coll? t)) t\n         :else (list (first t) (mirror (nth t 2)) (mirror (second t)))))\n      (nth t 2))))", "problem": 96, "user": "52b405e1e4b0c58976d9ad15"}, {"code": "(fn [[t l r]]\n    ((fn mir [a b]\n        (cond (and (nil? a) (nil? b)) true\n              (or (nil? a) (nil? b)) false\n              (not= (first a) (first b)) false\n              :else (and (mir (nth a 1) (nth b 2))\n                         (mir (nth a 2) (nth b 1)))))\n     l r))", "problem": 96, "user": "4eda8d7c535d10e5ff6f530f"}, {"code": "(fn symtree [[_ [bh bl br :as b] [ch cl cr :as c]]]\n  (if (and (sequential? b) (sequential? c))\n    (and (= bh ch) (symtree (list nil bl cr)) (symtree (list nil br cl)))\n    (and (= bh ch) (= bl cr) (= br cl))))", "problem": 96, "user": "50645e12e4b007509339a58a"}, {"code": "(fn symmetric-tree? [[node leaf1 leaf2]]\n  (let [\n        swap (fn swap [t]\n               (if \n                 (nil? t)\n                 t\n                 (let [\n                       [n l1 l2] t\n                       ]\n                   [n (swap l2) (swap l1)])))\n        ]\n      (= leaf1 (swap leaf2))))", "problem": 96, "user": "4f05a9cf535dcb61093f6bfc"}, {"code": "(fn [tree]\n  (=\n   ((comp (partial map first) tree-seq) sequential? rest tree)\n   ((comp (partial map first) tree-seq) sequential? (fn [[root left right]] (list right left)) tree)\n   )\n  )", "problem": 96, "user": "529d4f4be4b04e0c58e87b79"}, {"code": "(fn [t] \n  (letfn [(mirror? [l r] \n                   (or (= nil l r)\n                       (and (= (first l) (first r))\n                            (mirror? (second l) (last r))\n                            (mirror? (last l) (second r)))))]\n    (mirror? (second t) (last t))))", "problem": 96, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "apply #(=\n  ((fn s\n     ([c] (if (coll? c) (apply s c) nil))\n     ([rt l r]\n      [rt \n       (if (nil? r)\n         nil\n         (s r))\n       (if (nil? l)\n         nil\n         (s l))])) %2) %3)", "problem": 96, "user": "52ba2af3e4b07a9af57922cc"}, {"code": "(letfn [(mirror [t]\n                (if (nil? t) nil\n                    [(first t) (mirror (nth t 2)) (mirror (second t))]))]\n        (fn [[_ l r]]\n          (= l (mirror r))))", "problem": 96, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn symmetric-tree? [tree]\n  (let [mirror-trees? \n         (fn mirror-trees? [left-tree right-tree]\n           (cond \n              (and (nil? left-tree) (nil? right-tree)) true\n              (and (coll? left-tree) (coll? right-tree))\n                (and (= (first left-tree) (first right-tree))\n                     (mirror-trees? (second left-tree)\n                                    (last right-tree))\n                     (mirror-trees? (last left-tree)\n                                    (second right-tree)))\n              :else false))] \n        (mirror-trees? (second tree) (last tree))))", "problem": 96, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "(fn [[ n l r]] \n    ( (fn sym [[n1 l1 r1] [n2 l2 r2]]\n        (if n1\n          (and (= n1 n2) (sym l1 r2) (sym l2 r1))\n          (= n1 n2)\n          )\n        )\n      l r)\n    )", "problem": 96, "user": "52b577c9e4b0c58976d9ad39"}, {"code": "(fn [t]\n  (let [sym? (fn _ [a b]\n               (if (nil? a) (nil? b)\n                 (and\n                   (= (first a) (first b))\n                   (_ (second a) (nth b 2))\n                   (_ (second b) (nth a 2)))))]\n    (or\n      (nil? t)\n      (sym? (second t) (nth t 2)))))", "problem": 96, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn beauty-is-symmetry [[key0 f0 s0]]\n  ((fn is-symmetry [ [key1 f1 s1] , [key2 f2 s2] ]\n    #_(println key1 f1 s1 \" - \" key2 f2 s2)\n    (and  \n\n     (= key1 key2)\n\n     (cond (= nil f1 s1 f2 s2)  true\n         \n           (and (= nil f1 s1) (is-symmetry f2 s2)) true\n\n           (and (= nil f2 s2) (is-symmetry f1 s1)) true\n             \n           (and (is-symmetry f1 s2) (is-symmetry f2 s1)) true\n         \n           :else false)       \n     )\n    ) f0 s0))", "problem": 96, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn f \n  ([t] (f (second t) (last t)))\n  ([a b] (or \n          (and (nil? a) (nil? b))\n          (if (and (coll? a) (coll? b))\n            (and (= (count a) (count b) 3)\n                 (= (first a) (first b))\n                 (f (second a) (last b))\n                 (f (last a) (second b)))\n            false))))", "problem": 96, "user": "51929214e4b08962174cf74c"}, {"code": "#(= % ((fn f [[v l r]] [v (and r (f r)) (and l (f l))]) %))", "problem": 96, "user": "52c73194e4b0c2d177d6211e"}, {"code": "(fn [tree]\n   (let [x ((fn checker [col] (if (sequential? col) [(first col) (checker (nth col 2)) (checker (second col))] )) (nth tree 2))]\n     (= (second tree) x)\n     ))", "problem": 96, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [[_ left right]]\n  (let [rrev\n        (fn rrev\n          ([] nil)\n          ([x left right] [x (apply rrev right) (apply rrev left)]))\n        ]\n    (= left (apply rrev right))))", "problem": 96, "user": "52cca65be4b07d0d72b2736b"}, {"code": "(fn [tree] (letfn [\n\n        (mirror? [t1 t2]\n            (cond   \n                (or (empty? t1) (empty? t2))\n                    (= t1 t2)\n                true    \n                    (and (= (first t1) (first t2)) (mirror? (second t1) (nth t2 2)) (mirror? (nth t1 2) (second t2))) \n            )       \n)\n\n    ] (mirror? (second tree) (nth tree 2))))", "problem": 96, "user": "52cc85abe4b07d0d72b27367"}, {"code": "(fn [coll] (let [tree ((fn balance [[a b c]]\n                             (concat (if (vector? b) (balance b) [b]) [a] (if (vector? c) (balance c) [c])))\n                            coll)]\n                 (= tree (reverse tree))))", "problem": 96, "user": "51e28063e4b08e53a149f0f2"}, {"code": "(fn my-symmetry-binary-tree\n  [tree]\n  (letfn [(swap [v] (vector (first v) (last v) (second v)))\n          (reverse-parts [tree-part] (map #(if (sequential? %)\n                                      (reverse-parts (swap %))\n                                      %) tree-part))]\n    (= (last tree) (reverse-parts (swap (second tree))))))", "problem": 96, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn symm? [t]\n  (letfn [(mirror [[n l r]]\n                  (list n (if (sequential? r) (mirror r) r) (if (sequential? l) (mirror l) l)))]\n    (= t (mirror t))))", "problem": 96, "user": "4ea365e2535d7eef308072c5"}, {"code": "#(letfn [(sym [tree] \n             (if (nil? tree)\n               nil\n               (let [[v l r] tree]\n                 [v (sym r) (sym l)])))]\n   (= % (sym %)))", "problem": 96, "user": "52cc09c1e4b07d0d72b27356"}, {"code": "(fn [tree]\n          ((fn mirror? [l r]\n              (cond\n               (or (nil? l) (nil? r)) (= l r)\n               :else (and (= (first l) (first r)) (mirror? (second l) (last r)) (mirror? (last l) (second r)))))\n              (second tree) (last tree)))", "problem": 96, "user": "52c5c1c8e4b0c2d177d620fc"}, {"code": "(fn symmetric? [[v l r]]\n\t(let [\n\t\tcheck-case? (fn [a b eq]\n\t\t\t(case [(nil? a) (nil? b)]\n\t\t\t\t\t[true true] true\n\t\t\t\t\t[false false] (eq a b)\n\t\t\t\t\tfalse\n\t\t\t\t\t)\n\t\t\t\t)\n\t\ttree-equal? (fn ! [a b]\n\t\t\t(let [[av al ar] a\n\t\t\t\t[bv bl br] b]\n\t\t\t\t(and\n\t\t\t\t\t(= av bv)\n\t\t\t\t\t(check-case? al br !) \t\t\t\t\t\n\t\t\t\t\t(check-case? ar bl !)\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n\t\t(tree-equal? l r)\n\t)\n)", "problem": 96, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn __ [coll]\n  (= (second coll) ((fn swap [tree]\n                     (let [[rt lc rc] (into [] tree)\n                           n-lc (if (coll? lc) (swap lc) lc)\n                           n-rc (if (coll? rc) (swap rc) rc)]\n                       [rt n-rc n-lc] )) (nth coll 2))))", "problem": 96, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn [tree]\n  (letfn\n    [(rev-tree [t] (if (nil? t) t [(first t) (rev-tree (last t)) (rev-tree (second t))]))]\n    (= tree (rev-tree tree))))", "problem": 96, "user": "4f03641a535dcb61093f6a9b"}, {"code": "#(= % ((fn tree-mirror [x]\n         (if(coll? x) \n           [(first x) (tree-mirror (last x)) (tree-mirror (second x))]x))%))", "problem": 96, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn [[root left right]]\n  (letfn [(mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ar aL aR] a\n                                          [br bL bR] b]\n                                      (and\n                                        (= ar br)\n                                        (mirror? aL bR)\n                                        (mirror? aR bL)))\n                    :else (= a b)))]\n    (mirror? left right)))", "problem": 96, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "#((fn f [l r] \n    (if (and (coll? l) (coll? r))\n    (and (= (first l) (first r)) \n         (and (f (nth l 1) (nth r 2)) (f (nth l 2) (nth r 1))) ) \n      (= l r))) (nth % 1) (nth % 2))", "problem": 96, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "#(= % ((fn M [[v L R]] (if v [v (M R) (M L)])) %))", "problem": 96, "user": "52d10680e4b07d0d72b273c3"}, {"code": "; Assuming all trees are valid.\n(fn tree-eq\n  ([t] (let [[v l r] t] (tree-eq l r)))\n  ([l r] (if (and (nil? l) (nil? r))\n           true\n           (let [[vl ll rl] l\n                 [vr lr rr] r]\n             (and (= vl vr) (tree-eq ll rr) (tree-eq rl lr))))))", "problem": 96, "user": "52d3f666e4b09f7907dd1327"}, {"code": "#(= % ((fn f [[h l r]]\n         (if h [h (f r) (f l)])) %))", "problem": 96, "user": "5256627ce4b0541d1855ba1a"}, {"code": "(fn [[_ l1 l2]]\n   (letfn [(sym-tree? [[ln ll lr] [rn rl rr]]\n             (cond\n              (not= ln rn) false\n              (reduce #(and % (nil? %2)) true (list ll lr rl rr)) true\n              (sym-tree? ll rr) (sym-tree? lr rl)\n              :else false))]\n     (sym-tree? l1 l2)))", "problem": 96, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn [tree]\n  (= tree ((fn flip [[v l r :as ft]]\n             (when ft [v (flip r) (flip l)]))\n           tree)))", "problem": 96, "user": "4f8c6bf6e4b02e764a0a519b"}, {"code": "(fn [[t1 t2 t3]]\n    (let [tf (fn tf [[a b c :as t]]\n                   (if (nil? t)\n                       t\n                       (let [n a l b r c]\n                           [n (tf r) (tf l)])))]\n    (= t2 (tf t3))))", "problem": 96, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "#(= ((fn m [[v l r :as t]]\n      (when t\n        [v (m r) (m l)])) %) %)", "problem": 96, "user": "4ee75ec2535d93acb0a66867"}, {"code": "(fn sem? [[a b c]]\n  (if (sequential? b)\n    (if (sequential? c)\n      (= b ((fn invert [t]\n  (if-not (sequential? t)\n    t\n    (let [a (first t) b (second t) c (last t)]\n      (concat [a] [(invert c)] [(invert b)])))) c))\n      false)\n    (if (sequential? c)\n      false\n      (= b c))))", "problem": 96, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn symmetric? [t]\n  (let [traverse  (fn traverse[t]\n                    (if\n                       (not (seq t)) []\n                       (let [lt (traverse (nth t 1))\n                             rt (traverse (nth t 2))\n                             ]\n                             (into (conj lt (first t)) rt)\n                         )\n                     )\n                    )\n    \n        lt (traverse (nth t 1))\n        rt (traverse (nth t 2))\n        ]\n      (= lt (reverse rt))\n    )\n  )", "problem": 96, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn [t]\n  (= (first (rest t))\n     (clojure.walk/postwalk\n       #(if (coll? %)\n          (concat [(first %)] (reverse (rest %)))\n          %)\n       (second (rest t)))))", "problem": 96, "user": "50d8de3fe4b01f0871336e72"}, {"code": "#(= % ((fn ri [[v l r]] (if v [v (ri r) (ri l)])) %))", "problem": 96, "user": "52b02329e4b0c58976d9acc5"}, {"code": "#(letfn [(m [[v l r :as t]] (if (nil? t) t [v (m r) (m l)]))] (= % (m %)))", "problem": 96, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "#(letfn [(s [l r]\n           (or (and (nil? l) (nil? r))\n               (and (= (first l) (first r)) (s (second l) (last r)) (s (last l) (second r)))))]\n   (s (second %) (last %)))", "problem": 96, "user": "522eb5cce4b01cdb292c5f0c"}, {"code": "(fn [t]\n  (letfn [(mirror [t]\n            (if-let [[v l r] t]\n              [v (mirror r) (mirror l)]))]\n    (if-let [[v l r] t]\n      (= l (mirror r)))))", "problem": 96, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn is-symmetric-tree [a-tree]\n   (letfn [(is-symmetric [l-tree r-tree]\n\t\t\t(if (= l-tree nil)\n\t\t\t    (= r-tree nil)\n\t\t\t\t; l-tree is not nil\n\t\t\t\t(if (= r-tree nil)\n\t\t\t\t    false\n\t\t\t\t\t; both l-tree and r-tree is not nil\n\t\t\t\t\t; check whether values are equal\n\t\t\t\t\t(if (not= (first l-tree) (first r-tree))\n\t\t\t\t\t    false\n\t\t\t\t\t\t(and\n\t\t\t\t\t\t\t(is-symmetric (second l-tree) (nth r-tree 2))\n\t\t\t\t\t\t\t(is-symmetric (nth l-tree 2) (second r-tree))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\t\t\t\t\n\t\t)]\n\t\t(let [left (second a-tree) right (nth a-tree 2)]\n\t\t\t(is-symmetric left right)\n\t\t)\n   )\n)", "problem": 96, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn [[_ l r]]\n  (letfn [(is-s [[lv ll lr :as l] [rv rl rr :as r]]\n                (if (or (nil? l) (nil? r))\n                  (and (nil? l) (nil? r))\n                  (and (= lv rv) (is-s ll rr) (is-s lr rl))))]\n    (is-s l r)))", "problem": 96, "user": "52d809bde4b09f7907dd1384"}, {"code": "(fn [t]\n    (=\n     ((fn flip [s]\n  (if (and\n       (coll? s)\n       (= 3 (count s)))\n    (cons (first s) (map flip (reverse (rest s))))\n  )) (second t))\n     (nth t 2)))", "problem": 96, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "#(letfn [(mirrors [a b]\n                 (cond\n                  (and (nil? a) (nil? b)) true\n                  (or (nil? a) (nil? b)) false\n                  (not= (first a) (first b)) false\n                  (and (mirrors (second a) (last b)) (mirrors (last a) (second b))) true\n                  :else false\n                  )\n                 )\n        (symm [coll]\n              (if (mirrors (second coll) (last coll))\n                true\n                false\n                )\n              )\n        ]\n  (symm %)\n   )", "problem": 96, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn is-sym?\n  [t]\n  (let [helper (fn h [left right]\n                 (cond\n                   (and (nil? left) (nil? right)) true\n                   (or (nil? left) (nil? right)) false\n                   :else (and (= (first left) (first right))\n                              (h (second left) (last right))\n                              (h (last left) (second right)))))]\n    (helper t t)))", "problem": 96, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "#(=\n  ((fn v [[t l r]]\n    (if t\n      [t (v r) (v l)]))\n   %)\n  %)", "problem": 96, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "#(letfn \n   [(istree? [left right]\n      (if (or (nil? left) (nil? right))\n          (and (nil? left) (nil? right))\n          (and (= (first left) (first right)) (istree? (second left) (last right)) (istree? (last left) (second right)))))\n    (tree? [[head left right]]\n      (istree? left right))]\n   (tree? %))", "problem": 96, "user": "5047782ce4b0371827a27bc2"}, {"code": "(fn [n]\n (letfn [\n         (flip [n] \n   (if (coll? n) (let [v (first n) l (second n) r (nth n 2)] [v (flip r) (flip l)]) n))]\n   (= n (flip n))))", "problem": 96, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn sym-bin-tree? [v]\n  (let [[r lt rt] v\n       com-bin-tree? (fn com-bin-tree? [lt rt]\n           (if-not (and (= 3 (count lt)) (= 3 (count rt)))\n\t\t    false\n\t\t\t  (let [\n\t\t\t        [lt-r lt-lc lt-rc] lt\n\t\t\t        [rt-r rt-lc rt-rc] rt\n\t\t\t        r-same  (= lt-r  rt-r)\n\t\t         \tlt-lc-seq (sequential? lt-lc)\n\t\t            rt-lc-seq (sequential? rt-lc)\n\t\t            lt-rc-seq (sequential? lt-rc)\n\t\t            rt-rc-seq (sequential? rt-rc)]\n\t\t\t    (cond\n\t\t       \t\t(not r-same) false\n\t\t         \t(and (not lt-lc-seq) rt-rc-seq) false\n\t\t            (and (not lt-rc-seq) rt-lc-seq) false\n\t\t     \t\t(and (not rt-lc-seq) lt-rc-seq) false\n\t\t       \t\t(and (not rt-rc-seq) lt-lc-seq) false\n\t\t         \t(and (not lt-lc-seq) (not rt-rc-seq) (not= lt-lc rt-rc)) false\n\t\t          \t(and (not lt-rc-seq) (not rt-lc-seq) (not= lt-rc rt-lc)) false\n\t\t         \t(and lt-lc-seq rt-rc-seq) (com-bin-tree? lt-lc rt-rc)\n\t\t            (and lt-rc-seq rt-lc-seq) (com-bin-tree? lt-rc rt-lc)\n\t\t            (and (= lt-lc rt-rc) (= lt-rc rt-lc)) true\n\t\t         ))))]\n  (com-bin-tree? lt rt)))", "problem": 96, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn [tree]\n  (letfn [(explore [branch]\n                   (if (sequential? branch) (mirror branch) branch))\n          (mirror [tree]\n                  [(first tree) (-> tree last explore) (-> tree second explore)])]\n    (= (second tree) (-> tree last mirror))))", "problem": 96, "user": "51ab4082e4b04e3dc0c27b31"}, {"code": "(fn [a] \n  (letfn [(swap [b] \n            (if (sequential? b) (let [[v l r] b] [v (swap r) (swap l)]) b))]\n    (= (swap (second a)) (second (next a)))))", "problem": 96, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (seq? a) (seq? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "problem": 96, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn sym-tree? [t]\n  (letfn [(traverse [tr res go-left]\n            (if-not (sequential? tr)\n              (cons tr res)\n              ;else\n              (let [pos (if go-left 1 2)]\n                (concat (traverse (nth tr pos) res go-left)\n                        [(first tr)]\n                        (traverse (nth tr (- 3 pos)) res go-left)))))]\n    (= (traverse (nth t 1) [] true)\n       (traverse (nth t 2) [] false))))", "problem": 96, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "#(letfn [(tree_rev [[node rb lb]] (list node \n                                        (if (coll? lb) (tree_rev lb) lb) \n                                        (if (coll? rb) (tree_rev rb) rb)))]\n   (= (tree_rev (second %)) (last %)))", "problem": 96, "user": "524469dee4b0d8acf9ed6a9d"}, {"code": "(comp #(= (last %) (second %)) (fn sym [tree]\n              (let [[root r l] tree [rroot rl rr] r [lroot ll lr] l]\n                (if (nil? root)\n                  nil\n                  [root\n                   (if (nil? l) nil (sym [lroot (sym ll) lr]))\n                   (if (nil? r) nil (sym [rroot rr rl]))]))))", "problem": 96, "user": "5300aa1de4b0d8b024fd3710"}, {"code": "(fn sym-tree?\n  [[in-v in-l in-r]]\n  (letfn [(rev-bin-tree\n            ([[v l r]] (rev-bin-tree [v l r] []))\n            ([tree res] (cond \n                (= 3 (count tree)) (let [[v l r] (vec tree)] [v (rev-bin-tree r []) (rev-bin-tree l [])])\n                :else tree)))]\n  (cond\n    (and (not (nil? in-l)) (not (nil? in-r))) (= in-l (rev-bin-tree in-r))\n    (= in-l in-r nil) true\n    :else false)))", "problem": 96, "user": "5300b750e4b0d8b024fd3711"}, {"code": "(fn [tree]\n  (letfn [(sym [tr]\n               (if (nil? tr)\n    \t\t\tnil\n    \t\t\t[(first tr) (sym (nth tr 2)) (sym (second tr))]))]\n    (= (sym (second tree)) (nth tree 2))))", "problem": 96, "user": "52d00832e4b07d0d72b273b4"}, {"code": "(fn [t]\n   (letfn [(left [n] (second n))\n              (right [n] (nth n 2))\n              (sym-children? [l r]\n                 (if (every? nil? [l r])\n                   true\n                   (and (= (first l) (first r))\n                           (sym-children? (left l) (right r))\n                           (sym-children? (right l) (left r)))))]\n      (sym-children? (left t) (right t))))", "problem": 96, "user": "4fb99483e4b081705acca2da"}, {"code": "(fn [tree]\n  (let [nodes (fn bf [& roots] \n                (when (seq roots) \n                  (cons (map first roots)\n                        (apply bf (mapcat rest roots)))))\n        palindrome? (fn [coll]\n                      (when-let [n (count coll)]\n                        (condp = n\n                          0 false\n                          1 true\n                          (and (even? n) (= coll (reverse coll))))))]\n    (every? palindrome? (nodes tree))))", "problem": 96, "user": "4dda44f2535d02782fcbe9f1"}, {"code": "(fn [t]\n    (let [tc\n      (fn treechange [s]\n\t\t    (if (sequential? s)      \n\t\t        (let [p (first s) c1 (second s) c2 (nth s 2)]\n\t\t\t\t    [p (treechange c2) (treechange c1)])\n\t\t        s      \n\t\t    )\n      )\n      ll (rest t)]\n     \n      (= (first ll) (tc (second ll))) )\n )", "problem": 96, "user": "528f4462e4b0239c8a67aef0"}, {"code": "(fn [[n l r]]\n  (= l ((fn f [[n l r]]\n          (if n [n (f r) (f l)]))\n        r)))", "problem": 96, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn iss [l]\n  (let [flipper (fn flipper [tf]\n                  (let [nval (first tf)\n                        lval (second tf)\n                        rval (nth tf 2)]\n                    (list nval (if (nil? rval) rval (flipper rval))\n                          (if (nil? lval) lval (flipper lval)))))\n        treq (fn [tra trb]\n               (= (flatten tra) (flatten trb)))]\n    (treq (second l) (flipper (nth l 2)))))", "problem": 96, "user": "52747090e4b03e8d9a4a74a5"}, {"code": "(fn [t]\n (let [i nth]\n ((fn f[m n]\n    (if (and (nil? m)\n             (nil? n)) true\n      (and (= (i n 0)\n              (i m 0))\n           (f (i n 1)\n              (i m 2))\n           (f (i n 2)\n              (i m 1))))) (i t 1) (i t 2))))", "problem": 96, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn [[cabeca arv-dir arv-esq]]\n  ((fn simetricos [[cabeca-arv1 & galhos-arv1 :as arv1] [cabeca-arv2 & galhos-arv2 :as arv2]]\n    (cond \n     (and (nil? arv1) (nil? arv2)) true\n     (not= cabeca-arv1 cabeca-arv2) false\n     :else (and (simetricos (first galhos-arv1) (last galhos-arv2))\n                (simetricos (last galhos-arv1) (first galhos-arv2)))))\n   arv-dir \n   arv-esq))", "problem": 96, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [[_ left right]]\n  (let [reverse-tree (fn reverse-tree [s]\n                       (if (nil? s)\n                         nil\n                         (let [[value left right] s]\n                           [value (reverse-tree right) (reverse-tree left)])))]\n    (= left (reverse-tree right))))", "problem": 96, "user": "53070615e4b02e821686979e"}, {"code": "(fn [x] (let [r (fn r [y] (if (coll? y) \n                     [(first y) (r (last y)) (r (second y))]\n                      y))\n                s (second x) l (last x)]\n  (= s (r l))))", "problem": 96, "user": "52d7a930e4b09f7907dd1379"}, {"code": "(fn [t] (letfn [\n(third [coll] (nth coll 2))\n(value [tree] (first tree))\n(left [tree] (second tree))\n(right [tree] (third tree))\n(branch? [binary-tree] (and (sequential? binary-tree) (= 3 (count binary-tree))))\n(symmetric? ([t] (symmetric? t t)) ([t1 t2] (if (and (not (branch? t1)) (not (branch? t2))) (= t1 t2) (and (symmetric? (left t1) (right t2)) (symmetric? (right t1) (left t2)) (= (value t1) (value t2))))))\n] (symmetric? t)))", "problem": 96, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn sym [[root left right]]\n  (cond \n    (= nil left right) true ; all nil: single node tree\n    (and left right) ; no nils\n      (and \n        (= (first left) (first right)) ; root value matches\n        (sym [nil (nth left 1) (nth right 2)]) ; left left matches right right\n        (sym [nil (nth left 2) (nth right 1)]) ; left right matches right left\n      )\n    :else false ; left or right nil\n  )\n  )", "problem": 96, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn symmetric? [tree]\n  (letfn [(root [tree]\n            (first tree))\n          (left [tree]\n            (second tree))\n          (right [tree]\n            (nth tree 2))\n\n          (check [a b]\n            (if-not (and (sequential? a)\n                         (sequential? b))\n              (and (nil? a)\n                   (nil? b))\n              (and (= (root a) (root b))\n                   (check (left a) (right b))\n                   (check (right a) (left b)))))]\n    (check (left tree) (right tree))))", "problem": 96, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn sym-tree? [coll]\n        (letfn [\n         (mirror [c]\n           (if (sequential? c) \n            [(first c) (mirror (last c)) (mirror (second c))]\n            c))\n         ]\n         (if (sequential? coll) \n           (= (second coll) (mirror (last coll)))\n           true)))", "problem": 96, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn [tree]                                                                      \n  (letfn [(mirror [subtree]\n            (when subtree\n              [(first subtree)\n               (mirror (last subtree))\n               (mirror (second subtree))]))]\n    (= (second tree) (mirror (last tree)))))", "problem": 96, "user": "530e9729e4b08068f379ecbc"}, {"code": "#(let [[n l r] %]\n  (\n    (fn sym? [[n1 l1 r1] [n2 l2 r2]]\n      (and\n        (= n1 n2)\n        (if (vector? l1) \n          (sym? l1 r2)\n          (= l1 r2)\n        )\n        (if (vector? r1)\n          (sym? r1 l2)\n          (= r1 l2)\n        )\n      )\n    )\n    l r\n  )\n)", "problem": 96, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn  [lat]\n  (letfn [(symmetric [lBranch rBranch]\n                     (cond \n                        (and (not (coll? lBranch)) (= lBranch rBranch)) true\n                        (or (nil? lBranch) (nil? rBranch)) false\n                        :else (and (= (nth lBranch 0) (nth rBranch 0)) \n                                   (or (and (symmetric (nth lBranch 1) (nth rBranch 2)) (symmetric (nth lBranch 2) (nth rBranch 1)))\n                                       ))))]\n  (symmetric (nth lat 1) (nth lat 2)))\n)", "problem": 96, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn balanced? [ls]\n  (letfn [(mirror [[root [lroot :as left] [rroot :as right]]]\n            (let [rmirror (if (coll? right) (mirror right) right)\n                  lmirror (if (coll? left) (mirror left) left)]\n              [root rmirror lmirror]))]\n  (= ls (mirror ls))))", "problem": 96, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn [[c l r]]\n(letfn [(g [[c l r :as t]]\n          (when-not (nil? t)\n            [(g l) c (g r)]))]\n  (= (reverse (flatten (g l))) (flatten (g r)) )))", "problem": 96, "user": "53034738e4b0d8b024fd373e"}, {"code": "(fn sym? \n  ([t] (sym? (second t) (last t)))\n  ([a b] (or \n          (and (nil? a) (nil? b))\n          (if (and (coll? a) (coll? b))\n            (and (= (count a) (count b) 3)\n                 (= (first a) (first b))\n                 (sym? (second a) (last b))\n                 (sym? (last a) (second b)))\n            false))))", "problem": 96, "user": "52a5a8ebe4b0c58976d9abed"}, {"code": "(fn sym? [tree]\n(letfn [(rev [tree]\n  (if (nil? tree)\n    nil\n    (list (first tree) (rev (last tree)) (rev (second tree)))))]\n(= (rev tree) tree)))", "problem": 96, "user": "531c0619e4b08068f379ed98"}, {"code": "(let [ismirror? \n      (fn ismirror \n        [x] \n        (if (or (and (nil? (second x))\n                     (not (nil? (nth x 2))))\n                (and (not (nil? (second x)))\n                     (nil? (nth x 2))))\n          false\n          (if (and (nil? (second x))\n                   (nil? (nth x 2)))\n            true\n            (if (= (first (second x))\n                   (first (nth x 2)))\n              (and (ismirror [ 1\n                                  (second (second x))\n                                  (nth (nth x 2) 2)])\n                   (ismirror [ 2\n                                  (nth (second x) 2)\n                                  (second (nth x 2))]))\n              false))))]\n  (fn testme [x] (ismirror? x)))", "problem": 96, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn [xs]\n  (let [[v lc rc] xs\n        f (fn f [l r]\n            (if (or (nil? l) (nil? r))\n              (if (= l r) true false)\n              (if (= (first l) (first r))\n                (and (f (second l) (last r)) (f (last l) (second r)))\n                false\n              )\n            )\n          )\n        ]\n    (f lc rc)\n  )\n)", "problem": 96, "user": "5323a414e4b09d4e7a9b54d1"}, {"code": "(letfn [[treverse [tree] (if-let [[n left right] tree] [n (treverse right) (treverse left)])]]\n  (fn [tree] (= tree (treverse tree))))", "problem": 96, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn symmetricTree? [t] (\n                          (fn checkChild [l r]  \n                            (or (and (nil? l) (nil? r))\n                               (and (not (nil? l)) \n                                    (not (nil? r)) \n                                    (= (first l) (first r))\n                                    (checkChild (second l) (last r))\n                                    (checkChild (last l) (second r))\n                                )\n                              )\n                            ) \n         (second t) (last t) ) )", "problem": 96, "user": "531f0a26e4b08068f379edbf"}, {"code": "(fn symmetric? [t]\n  (letfn [(mirror [t]\n                  (if-let [s (seq t)]\n                    (let [[v l r] s]\n                      [v (mirror r) (mirror l)])))]\n    (if-let [s (seq t)]\n      (let [[v l r] s]\n        (= l (mirror r)))\n      true)))", "problem": 96, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn sym?[t]\n  (= t ((fn rev [t] (if (= t nil) nil (let [[v l r] t] [v (rev r) (rev l)]))) t)))", "problem": 96, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn [t]\n  (let [recursive-reverse (fn rr [t]\n                            (when (seq t)\n                              [(first t)\n                               (rr (nth t 2))\n                               (rr (nth t 1))]))]\n    (= t (recursive-reverse t))))", "problem": 96, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn sym? [c]\n  (letfn [(symmetric? [c1 c2]\n            (cond\n             (and (sequential? c1) (sequential? c2))\n             (let [[x1 y1 z1] c1\n                   [x2 y2 z2] c2]\n               (if (= x1 x2)\n                 (and (symmetric? y1 z2)\n                      (symmetric? z1 y2))\n                 false))\n             (and (not (sequential? c1)) (not (sequential? c2)))\n             (= c1 c2)\n             :else\n             false))]\n    (apply symmetric? (rest c))))", "problem": 96, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [tree] (= tree (letfn [(sewap [z] (let [[v l r] (vec z)] [v (if (coll? r) (sewap r) r) (if (coll? l) (sewap l) l)]))] (sewap tree))))", "problem": 96, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn symtree? [c]\n   (letfn [(uguali? [t1 t2]\n               (let [v1 (nth t1 0 nil)\n                     p1 (nth t1 1 nil)\n                     s1 (nth t1 2 nil)\n                     v2 (nth t2 0 nil)\n                     p2 (nth t2 1 nil)\n                     s2 (nth t2 2 nil)]\n                 (if (or (nil? v1) (nil? v2))\n                   (= v1 v2)\n                   (and (= v1 v2) (uguali? p1 p2)\n                        (uguali? s1 s2)))))\n             (speculari? [t1 t2]\n               (let [v1 (nth t1 0 nil)\n                     p1 (nth t1 1 nil)\n                     s1 (nth t1 2 nil)\n                     v2 (nth t2 0 nil)\n                     p2 (nth t2 1 nil)\n                     s2 (nth t2 2 nil)]\n                 (if (or (nil? v1) (nil? v2))\n                   (= v1 v2)\n                   (and (= v1 v2) (speculari? p1 s2)\n                        (speculari? s1 p2)))))]\n       (let [primo (nth c 1 nil)\n             secondo (nth c 2 nil)]\n       (or (uguali? primo secondo ) (speculari? primo secondo )))))", "problem": 96, "user": "52c81954e4b0c2d177d6212e"}, {"code": "(fn symtree? [root]\n  (let [lefttree (second root)\n        righttree (nth root 2)]\n    (= righttree\n((fn symtree [tree]\n  (let [node (first tree)\n        left (second tree)\n        right (nth tree 2)]\n    (cond\n     (and (nil? left)\n         (nil? right)) tree\n     (nil? left) [node (symtree right) left]\n     (nil? right) [node right (symtree left)]\n     :else [node (symtree right) (symtree left)]))) lefttree))))", "problem": 96, "user": "52be0263e4b07a9af579230e"}, {"code": "(fn [xs]\n  (let [xs-reversed ((fn rec-reverse [[value left right]]\n                       (list\n                        value\n                        (if (nil? right) nil (rec-reverse right))\n                        (if (nil? left) nil (rec-reverse left)))) xs)]\n    (= xs xs-reversed)))", "problem": 96, "user": "531490bde4b08068f379ed17"}, {"code": "(fn [[_ l r]]\n  (letfn [(rev [t]\n               (if-not t t\n                 (let [[v l r] t]\n                   [v (rev r) (rev l)])))]\n    (= l (rev r))))", "problem": 96, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "#(letfn [(f [x] (if (coll? x) (mirror x) x))\n         (mirror [[a b c]] [a (f c) (f b)])]\n   (= % (mirror %)))", "problem": 96, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn mirror-tree? [tree]\n  (let [mtree-seq (fn mwalk [node rev?]\n                    (if-not (seq node)\n                      [node]\n                      (let [[rootval l-child r-child] node]\n                        (if-not rev?\n                          (concat (mwalk l-child rev?)\n                                  (mwalk r-child rev?)\n                                  [rootval])\n                          (concat (mwalk r-child rev?)\n                                  (mwalk l-child rev?)\n                                  [rootval])))))\n        left-side-seq (mtree-seq (second tree) false)\n        right-side-seq (mtree-seq (nth tree 2) true)]\n    (println \"left\" (count left-side-seq) left-side-seq)\n    (println \"right\" (count right-side-seq) right-side-seq)\n    (= left-side-seq right-side-seq)))", "problem": 96, "user": "51f82769e4b09be9c177e527"}, {"code": "(fn f\n  ([root]  (if (sequential? root)\n    (f (nth root 1) (nth root 2))\n    true)\n  )\n  ([a b]\n     (if (and (sequential? a) (sequential? b) )\n       (and (= (first a) (first b)) (f (nth a 1) (nth b 2)) (f (nth a 2) (nth b 1)))\n       (if (and (not (sequential? a)) (not (sequential? b)))\n         (= a b)\n         false)\n       ))\n   )", "problem": 96, "user": "5302ac7fe4b0d8b024fd3731"}, {"code": "(fn sym? [[_ tr2 tr3]]\n  (letfn [(mir-of [[t1 t2 t3]]  (if t1 [t1 (mir-of t3) (mir-of t2)]))]\n    (= tr2 (mir-of tr3))))\n; mir-of takes a tree and creates its mirror image", "problem": 96, "user": "4f80db02e4b033992c121bf9"}, {"code": "(fn P96 \n  ([t] (P96 (nth t 1) (nth t 2) ))\n  ([t1 t2]\n  (if (and (= t1 nil) (= t2 nil))\n    true\n    (if (= (first t1) (first t2))\n      (and (P96 (nth t1 1) (nth t2 2)) (P96 (nth t1 2) (nth t2 1)))\n      false))))", "problem": 96, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn s[[v l r]]\n      (if (or (nil? l) (nil? r))\n          (and (nil? l) (nil? r))\n          (and (= (first l) (first r))\n               (s (list v (nth l 1) (nth r 2)))\n               (s (list v (nth l 2) (nth r 1))))))", "problem": 96, "user": "4f82ed48e4b033992c121c0e"}, {"code": "(fn [[_ l-t r-t]]\n  (letfn [(mirror? [[l1 ll lr :as t1]\n                    [r1 rl rr :as t2]]\n                        (or (every? nil? [t1 t2])\n                            (and (= l1 r1)\n                                 (mirror? ll rr)\n                                 (mirror? lr rl))))]\n         (mirror? l-t r-t)))", "problem": 96, "user": "5036eba7e4b0af0658af77a5"}, {"code": "(fn [t]\n  (letfn\n    [(switch \n      [t]\n      (if (= t nil) nil\n        [(first t) (switch (last t)) (switch (second t))]\n        ))]\n    (= (second t) (switch (last t)))))", "problem": 96, "user": "52faec2ee4b047fd55837004"}, {"code": "(fn symTree? [t]\n   (letfn [(flipTree [t]\n             (cond\n              (nil? t) t\n              :else (list (first t) (flipTree (last t)) (flipTree (second t)))))]\n     (= t (flipTree t))))", "problem": 96, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [tree]\n  (letfn [\n    (sym [x] (if (nil? x) x\n      (let [[v l r] x] [v (sym r) (sym l)])))]\n  (= (second tree) (sym (last tree)))))", "problem": 96, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn ? \n  ([t] (? (second t) (last t)))\n  ([l r] (or \n          (and (nil? l) (nil? r))\n          (if (and (coll? l) (coll? r))\n            (and (= (count l) (count r) 3)\n                 (= (first l) (first r))\n                 (? (second l) (last r))\n                 (? (last l) (second r)))\n            false))))", "problem": 96, "user": "506d5e4ce4b0a302964c5493"}, {"code": "(fn enc ( [[v L R]]\n           (= (enc :a :b L) (enc :b :a R))\n           )\n  ([a b [v L R]]\n     (let [f #(if (nil? %) :nil (enc a b %))]\n       (hash-map :v v a (f L) b (f R))\n       )\n     )\n  )", "problem": 96, "user": "5281a445e4b0757a1b17143a"}, {"code": "(fn [[head left right]]\n  (letfn [(flip [[head left right :as tree]]\n            (if (nil? tree) tree\n              [head (flip right) (flip left)]))]\n    (= left (flip right))))", "problem": 96, "user": "53300924e4b019098a6f8b55"}, {"code": "#(let [mirror (fn mirror [t] \n                 (if (sequential? t) \n                   (let [[v l r] t] [v (mirror r) (mirror l)]) \n                   t))]\n    (= % (mirror %)))", "problem": 96, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn mirror? [[_ [a b c] [d e f]]]\n  (if a\n    (and (= a d)\n         (mirror? [a b f])\n         (mirror? [a c e]))\n    (nil? d)))", "problem": 96, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [t]\n  (let [rev\n        (fn f [st]\n          (if (coll? st)\n            (list (first st) (f (nth st 2)) (f (second st)))\n            st))]\n    ((fn g [st1 st2]\n       (if (and (coll? st1) (coll? st2))\n         (and (g (first st1) (first st2)) (g (second st1) (second st2)) (g (nth st1 2) (nth st2 2)))\n         (if (or (coll? st1) (coll? st2)) false (= st1 st2))))\n     (second t) (rev (nth t 2)))))", "problem": 96, "user": "51da631be4b02ceefd947766"}, {"code": "(fn [tree]\n    (letfn [(symmetree? [left right]\n                        (if (nil? left)\n                          (nil? right)\n                          (and (= (first left) (first right))\n                               (symmetree? (nth left 1) (nth right 2))\n                               (symmetree? (nth left 2) (nth right 1)))))]\n      (symmetree? (nth tree 1) (nth tree 2))))", "problem": 96, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn [[root left right]]\n  (letfn [(flip-tree [[root left right]]\n                     (if (nil? root)\n                       nil\n                       [root (flip-tree right) (flip-tree left)]))]\n    (= left (flip-tree right))))", "problem": 96, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn symmetric? [[_ left right]]\n  (let [permute (fn permute-fn [x]\n                  (if-not (coll? x)\n                    x\n                    (let [[a b c] x]\n                      [a (permute-fn c) (permute-fn b)])))]\n    (= left (permute right))))", "problem": 96, "user": "5054c853e4b0b1b9d1860eb3"}, {"code": "#(letfn [(mirror [xs]\n           (if (not (coll? xs)) xs\n             (let [[x l r] xs]\n               [x (mirror r) (mirror l)])))]\n    (= (second %) (mirror (last %))))", "problem": 96, "user": "5160195ae4b0e2be8aa20be3"}, {"code": "(letfn [(mirror?\n         [t1 t2]\n         (or (= nil t1 t2)\n             (let [[x l1 r1] t1\n                   [y l2 r2] t2]\n               (and (= x y)\n                    (mirror? l1 r2)\n                    (mirror? l2 r1)))))]\n    \n  #(mirror? (nth % 1)\n            (nth % 2)))", "problem": 96, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [tree]\n  (letfn [(symmetric-nodes? [a b]\n            (cond (and (nil? a) (nil? b)) true\n                  (nil? a) false\n                  (nil? b) false\n                  :else (let [[a-name a-left a-right] a\n                              [b-name b-left b-right] b]\n                          (and (= a-name b-name)\n                               (symmetric-nodes? a-left b-right)\n                               (symmetric-nodes? a-right b-left)))))]\n    (let [[name left right] tree]\n      (symmetric-nodes? left right))))", "problem": 96, "user": "4e82c062535db62dc21a62cc"}, {"code": "#(= \n  % \n    ((fn* trev [x]\n         (if (nil? x)\n           nil\n           [(first x) (trev (last x)) (trev (second x))])) %))", "problem": 96, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn [sq]\n  (letfn [(lt [sq] (second sq))\n          (rt [sq] (last sq))\n          (mirror? [l r]\n            (or (= nil l r)\n                (and (= (first l) (first r))\n                     (mirror? (lt l) (rt r))\n                     (mirror? (lt r) (rt l)))))]\n    (mirror? (lt sq) (rt sq))))", "problem": 96, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(letfn [(mirror? [A B]\n          (or (and (nil? A) (nil? B))\n              (let [[Av Al Ar] A [Bv Bl Br] B] \n                (and (= Av Bv) (mirror? Al Br) (mirror? Ar Bl)))))]\n  (fn [[v l r]] (mirror? l r)))", "problem": 96, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(fn sym [tree] (let [mirror (fn mirror [a b] (if (coll? a) (and (= (first a) (first b)) (mirror (nth a 1) (nth b 2)) (mirror (nth a 2) (nth b 1))) (= a b)))] (mirror (nth tree 1) (nth tree 2))))", "problem": 96, "user": "52c1f404e4b07a9af5792370"}, {"code": "#(= % ((fn mirror [a]\n  (if-let [[value left right] a]\n    [value (mirror right) (mirror left)]\n    a)\n  ) %))", "problem": 96, "user": "534cf749e4b084c2834f4a97"}, {"code": "#(letfn [(t? [x]\n           (or (nil? x)\n               (and\n                (coll? x)\n                (= 3 (count x))\n                (t? (second x))\n                (t? (last x)))))\n         (f [l r t]\n           (if (nil? t)\n             nil\n             [(f l r (l t)) (first t) (f l r (r t))]))]\n   (and (t? %)\n        (= (f second last (second %))\n           (f last second (last %)))))", "problem": 96, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn f\n  ([v l r] \n   (letfn [(mirror ([v l r] [v (mirror r) (mirror l)])\n                   ([c] (apply mirror c))\n                   ([] nil))]\n     (= l (mirror r))))\n  ([c] (apply f c)))", "problem": 96, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn symmetrical? [t]\n   (letfn [(reverse* [tree]\n                     (let [left (if (nil? (second tree))\n                                  [nil]\n                                  [(reverse* (second tree))])\n                           right (if (nil? (nth tree 2))\n                                   [nil]\n                                   [(reverse* (nth tree 2))])]\n                       (concat (take 1 tree)\n                               right\n                               left)))\n           (same? [t1 t2]\n                  \n                  (= t1 t2))]\n     (same? (second t) (reverse* (nth t 2))))\n   )", "problem": 96, "user": "525ed5f4e4b0cb4875a45db8"}, {"code": "(fn [[_ L R]]\n  (= L \n     ((fn f [[v l r :as a]]\n        (and a [v (f r) (f l)]))\n      R)))", "problem": 96, "user": "5175533fe4b0dea9bbfba575"}, {"code": "#(= %\n   ((fn t [[a b c]]\n      (if a\n          [a (t c) (t b)] a))\n   %))", "problem": 96, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(let [left (fn [n] (second n))\n        right (fn [n] (nth n 2))]\n    (fn symmetric? \n      ([n]\n         (symmetric? (left n) (right n)))\n      ([n1 n2]\n         (println \"n1: \" n1 \" n2: \" n2)\n         (cond\n          (not= (first n1) (first n2)) false\n          (nil? n1) (nil? n2)\n          :else (and \n                 (symmetric? (left n1) (right n2))\n                 (symmetric? (right n1) (left n2)))))))", "problem": 96, "user": "53487737e4b084c2834f4a59"}, {"code": "#(< (mod (.hashCode %) 13) 2)", "problem": 96, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [[val left right]]\n    (letfn [(t-seq [tree left?]\n              (if (sequential? tree)\n                (let [[val left right] tree\n                      [left right] (if left? [left right] [right left])]                                                                                      \n                  (flatten [(t-seq left left?)\n                            val\n                            (t-seq right left?)]))\n                tree))]\n      (= (t-seq left true) (t-seq right false))))", "problem": 96, "user": "4f3d83b5e4b0e243712b1f69"}, {"code": "#(let [reverse-tree (fn reverse-tree [coll] \n           (if (seq coll) \n             [(first coll) (reverse-tree (nth coll 2)) (reverse-tree (nth coll 1))] \n             coll))]\n  (= (nth % 1) \n     (reverse-tree (nth % 2))))", "problem": 96, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn symmetric-tree? [[data left right]]\n  (\n    (fn same-tree? [t1 t2]\n      (or (= t1 t2 nil)\n          (and\n            (= (sequential? t1) (sequential? t2) true)\n            (= (first t1) (first t2))\n            (and (same-tree? (second t1) (last t2)) (and (same-tree? (last t1) (second t2))))\n            )))\n    left right\n    ))", "problem": 96, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [[_ l r]]\n  (= l\n     ((fn f [b]\n        (if (nil? b)\n          nil\n          [(nth b 0)\n           (f (nth b 2))\n           (f (nth b 1))]))\n      r)))", "problem": 96, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn pr096 [tree]\n  (letfn [(item [tree] (first tree))\n          (left [tree] (second tree))\n          (right [tree] (nth tree 2))\n          (symmetric? [lt rt]\n           (cond (nil? lt) (nil? rt)\n                 (nil? rt) false\n                 :else \n                   (and (= (item lt) (item rt))\n                        (symmetric? (left lt) (right rt))\n                        (symmetric? (right lt) (left rt)))))]\n    (if (nil? tree)\n      true\n      (symmetric? (left tree) (right tree)))))", "problem": 96, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn [tree]\n  (let [left-child (-> tree rest first)\n        right-child (-> tree rest second)]\n    (= ((fn ! [tr]\n          (if (nil? tr)\n            nil\n            (let [root (first tr)\n                  lchild (-> tr rest first)\n                  rchild (-> tr rest second)]\n              (conj [root]\n                    (! rchild)\n                    (! lchild))))) left-child)\n       right-child)))", "problem": 96, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn symmetric? [[topv topl topr :as top]]\n  (letfn [(mirrored [[v l r]]\n       \t\t    [v  \n                 (when (seq r) (mirrored r))\n                 (when (seq l) (mirrored l))])]\n    (= topl (mirrored topr))))", "problem": 96, "user": "51b24defe4b02f8f128bb963"}, {"code": "(fn \n    [[value left right]]\n    (letfn [(reverse-tree \n             [tree]\n             (let [[value left right] tree]\n               (vector value \n                       (if (coll? right) (reverse-tree right)) \n                       (if (coll? left) (reverse-tree left) left))))]\n      (= left (reverse-tree right))))", "problem": 96, "user": "52a32876e4b04e0c58e87bfb"}, {"code": "#(letfn [(symmetric? [a b]\n                       (if (and (coll? a) (coll? b))\n                         (let [[a1 a2 a3] a\n                               [b1 b2 b3] b]\n                           (and (= a1 b1)\n                                (symmetric? a2 b3)\n                                (symmetric? a3 b2)))\n                         (= a b)))]\n    (symmetric? (second %) (last %)))", "problem": 96, "user": "50f10f7be4b06d9538fe211a"}, {"code": "(fn symm [coll]\n  (let [coll (vec coll)]\n    (letfn [(rev [coll]\n                 (if (sequential? coll)\n                   (let [coll (vec coll)]\n                     [(first coll)\n                      (rev (coll 2))\n                      (rev (coll 1))])\n                   coll))]\n    (= (coll 1)\n       (rev (coll 2))))))", "problem": 96, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn a [tree]\n  (let [sym (fn sym [branch]\n              (when (sequential? branch)\n                (let [[value left right] branch]\n                  [value (sym right) (sym left)])))]\n    (= (second tree) (sym (nth tree 2)))))", "problem": 96, "user": "50be9b4ae4b00fb48fed2ef6"}, {"code": "(fn symmetrical?\n  [tree]\n  (letfn [(reorder [t]\n            (if (= (count t) 3)\n              (list (reorder (second t)) (first t) (reorder (last t)))\n              t))]\n    (let [reordered (flatten (reorder tree))]\n      (= reordered (reverse reordered)))))", "problem": 96, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn mirror? [tree]\n   (= tree\n      ((fn m [[h l r :as t]]\n         (if (nil? t)\n           t\n           (vector h (m r) (m l))))\n       tree)))", "problem": 96, "user": "51d4ed02e4b013d740b70dec"}, {"code": "(fn [t]\n  (letfn [(reflect [t]\n    (if (nil? t)\n      nil\n      (let [[v left right] t]\n        (list v (reflect right) (reflect left)))))]\n  (= t (reflect t))))", "problem": 96, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn [t]\n  (letfn [(mir [s] \n              (if (coll? s) \n                (let [[v l r] s] [v (mir r) (mir l)]) \n                s))]\n              (= t (mir t))))", "problem": 96, "user": "4f1ef6a0535d64f60314649b"}, {"code": "(fn [t]\n  (= t ((fn flip [[n l r :as t]]\n          (when t [n (flip r) (flip l)]))\n        t)))", "problem": 96, "user": "524b0645e4b09eba1c0223bf"}, {"code": "(fn sym? [T]\n  (let [invisit (fn invisit [tree]\n               (if (nil? tree) [tree]\n                               (let [left (second tree)\n                                     right (last tree)]\n                                 (concat (invisit left) [(first tree)] (invisit right)))))]\n    (= (invisit (second T)) (reverse (invisit (last T))))))", "problem": 96, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn [t]\n  (let [traverse (fn traverse [t]\n                   (if (nil? t)\n                     [nil]\n                     (let [[v l r] t]\n                       (concat (traverse l) [v] (traverse r)))))\n        traversal (vec (traverse t))\n        length (count traversal)\n        pivot (/ (dec length) 2)\n        left (subvec traversal 0 pivot)\n        right (subvec traversal (inc pivot) length)]\n    (= left (reverse right))))", "problem": 96, "user": "4fe9ea87e4b0547ebccb2476"}, {"code": "#(= % ((fn f [s] (when-let [[x y z] s] [x (f z) (f y)])) %))", "problem": 96, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn mirrored? [[_ l r]]\n    (letfn [ (mirror [t] \n                 (when-let [[v l r] t]\n                   [v (mirror r) (mirror l)])) \n             ]\n      (= l (mirror r))))", "problem": 96, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn symmetric-b-tree? [coll]\n  (letfn [(mirror? [a b]\n             (cond\n               (not= (sequential? a) (sequential? b)) false ;if a is sequential but b is not, or vice versa, return false\n               (and (sequential? a) (sequential? b)) ;if they are both sequential,\n                  (let [[root-a Left-a Right-a] a ;then name the pieces within a root-a, Left-a, Right-a\n                        [root-b Left-b Right-b] b] ;and name the pieces within b root-b, Left-b, Right-b\n                     (and (= root-a root-b)  ;are the two roots the same\n                          (mirror? Left-a Right-b) ;is mirror of Left-a and Right-b the same?\n                          (mirror? Left-b Right-a)));and is mirror of Left-b and Right-a the same? If so, true\n               :else (= a b)))] ;if they are both not sequential, then see if a=b, if not, then false, if so, then true\n     (mirror? (second coll) (last coll)))) ;calls mirror on the children of the root", "problem": 96, "user": "53713ebee4b0fc7073fd6ead"}, {"code": "(fn [[value left right]]\n  (= left \n     ((fn mirror [tree]\n        (cond (nil? tree) nil\n              :else (let [[v l r] tree]\n                      [v (mirror r) (mirror l)]))) right)))", "problem": 96, "user": "536f5900e4b0fc7073fd6e7b"}, {"code": "(let [tree? (fn tree? [n]\n                (if (coll? n)\n                  (let [[v l r] n]\n                    (and\n                      (= (count n) 3)\n                      (or (nil? l) (tree? l))\n                      (or (nil? r) (tree? r))))\n                  false))\n\n        mirror (fn mirror [n]\n                  (if (nil? n)\n                    n\n                    (let [[v l r] n]\n                      [v (mirror r) (mirror l)])))\n\n\n        symmetric-tree? (fn [[v l r :as n]]\n                          (and (tree? n)\n                               (= (mirror l) r)))]\n    symmetric-tree?)", "problem": 96, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "apply (fn $ymm\n        ([left right]\n         (or\n          (and (nil? left) (nil? right))\n          (and\n           (sequential? left)\n           (sequential? right)\n           (= (first left) (first right))\n           ($ymm (nth left 1) (nth right 2))\n           ($ymm (nth right 1) (nth left 2)))))\n        ([v left right]\n         ($ymm left right)))", "problem": 96, "user": "53712c03e4b0fc7073fd6ea9"}, {"code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "problem": 96, "user": "4ef2eb4d535dced4c769f226"}, {"code": "(fn [[_ left right]] (= left\n                        ( (fn rejigger [v]\n                           (if (empty? v)\n                             v\n                             (list (first v) (rejigger (last v)) (rejigger (second v))))) right)))", "problem": 96, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn mirror [[a l r]]\n         (if (and (sequential? l) (sequential? r))\n           (and (= (first l) (first r))\n             (mirror [nil (second l) (last r)])\n             (mirror [nil (last l) (second r)]))\n\n           (= l r)\n           )\n         )", "problem": 96, "user": "4dd579b5535dae65d5c462ea"}, {"code": "(fn symtree [lst]\n  (letfn [(tree? [s]\n                 (and (= 3 (count s)) (not= false (second s)) (every? true? (map tree? (filter sequential? s)))))\n          (mirror [s]\n                  (if (coll? s)\n                    (map mirror (list (first s) (last s) (second s)))\n                    s))\n          (symmetric? [s] (= s (mirror s)))]\n    (and (tree? lst) (symmetric? lst))))", "problem": 96, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn mirror?\n  ([tree] (or (= tree nil) (mirror? (nth tree 1) (nth tree 2))))\n  ([t1, t2] (or \n             (and (= nil t1) (= nil t2))\n             (and (= (count t1) 3)\n                  (= (count t2) 3)\n              \t  (= (first t1) (first t2))\n              \t  (mirror? (nth t1 1) (nth t2 2))\n                  (mirror? (nth t1 2) (nth t2 1))))))", "problem": 96, "user": "53800d99e4b06839e8705ebd"}, {"code": "#(= (fnext %)\n    ((fn f [t]\n       (letfn [(r [c] (if (coll? c) (f c) c))]\n       [(first t) (r (last t)) (r (fnext t))]))\n     (last %)))", "problem": 96, "user": "4ec53f8c535d6d7199dd368b"}, {"code": "(fn [t] ((fn areim [a b] \n           (or (= a b nil) \n               (and \n                (coll? a) \n                (coll? b)\n                (= \n                 (first a) \n                 (first b))\n                (areim \n                 (second a) \n                 (last b))\n                (areim \n                 (last a) \n                 (second b))))) \n           (second t) (last t)))", "problem": 96, "user": "536f2faee4b0fc7073fd6e79"}, {"code": "#(letfn [(eq? [t1 t2]\n\t(let [[b1 l1 r1] t1, [b2 l2 r2] t2]\n\t\t(if (nil? b1)\n\t\t\t(nil? b2)\n\t\t\t(if (nil? b2)\n\t\t\t\tfalse\n\t\t\t\t(and\n\t\t\t\t\t(= b1 b2)\n\t\t\t\t\t(eq? l1 r2)\n\t\t\t\t\t(eq? r1 l2))))))]\n\t(let [[_ l r] %] (eq? l r)))", "problem": 96, "user": "5370b386e4b0fc7073fd6e9b"}, {"code": "(fn [[v l r]]\n  (letfn [(flip [node]\n            (when-let [[v l r] node] [v (flip r) (flip l)]))]\n     (= l (flip r))))", "problem": 96, "user": "53779a26e4b06839e8705e38"}, {"code": "(fn [[_ l r]]\n  (letfn [(mirror? [l r]\n            (or (and (nil? l) (nil? r))\n                (let [[lv ll lr] l,\n                      [rv rl rr] r]\n                  (and (= lv rv)\n                       (mirror? ll rr)\n                       (mirror? lr rl)))))]\n    (mirror? l r)))", "problem": 96, "user": "5055e7f4e4b0ce54f56f0401"}, {"code": "(fn [t]\n  ((fn symmetry [lt rt]\n    (cond\n     (and (nil? lt) (nil? rt)) true\n     (not (and (coll? lt) (coll? rt))) false\n     (not= (count lt) (count rt) 3) false\n     (not= (first lt) (first rt)) false\n     :else (and (symmetry (fnext lt) (last rt)) (symmetry (last lt) (fnext rt)))))\n   (fnext t) (last t)))", "problem": 96, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn __ [tree]\n  (let [a (first  tree)\n        b (second tree)\n        c (last   tree)\n        ;; recuring function\n        tree-rev (fn tree-rev [x]\n                   (cond\n                    ;;\n                    ;; if it is an element, not a collection, leave it alone\n                    ((complement coll?) x) x\n                    ;; if it is a collection node with terminal elements only, leave it alone\n                    (and (coll? x) (every? (complement coll?) x)) x\n                    ;; Otherwise (collection of at least one collection node)\n                    ;; reverse 2nd and 3rd elements\n                    ;; sort it by first element (coll) or element itself\n                    :else (for [node     [(first x) (last x) (second x)]\n                                solution [(tree-rev node)]]\n                            solution)))]\n    ;; return sorted list\n    ;; [a b (tree-rev c)]\n    ;; check for balance. a is not needed\n    (= b (tree-rev c))\n    ))", "problem": 96, "user": "53415755e4b00652c8746ecd"}, {"code": "(fn [node]\n  (let [flip (fn flip [node]\n               (let [node-value (first node)\n                     left-node (second node)\n                     right-node (nth node 2)\n                     ]\n                 (list\n                   node-value\n                   (if right-node (flip right-node) nil)\n                   (if left-node (flip left-node) nil))\n                 )\n               )]\n    (= (flip (second node)) (nth node 2))\n    )\n  )", "problem": 96, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn [[_ l r]] (= (map first (tree-seq next rest l)) (map first (tree-seq next #(reverse (rest %)) r))))", "problem": 96, "user": "4dbdc898535d020aff1edf4a"}, {"code": "(fn [[a b c]]\n  (= c\n     ((fn r [[a b c :as x]]\n        (when x\n              (conj [a] (r c) (r b)))) b)))", "problem": 96, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [t]\n  (let [sym? (fn sym? [n1 n2]\n  \t\t\t\t(if (and (nil? n1) (nil? n2))\n                  true\n                  (if (or (nil? n1) (nil? n2))\n                    false\n                    (if-not (= (first n1) (first n2))\n                      false\n                  \t  (let [lft1 (nth n1 1)\n                            rgt1 (nth n1 2)\n                            lft2 (nth n2 1)\n                            rgt2 (nth n2 2)]\n                        (and (sym? lft1 rgt2) (sym? rgt1 lft2)))))))]\n    (sym? (nth t 1) (nth t 2))))", "problem": 96, "user": "538d464ee4b0b51d73faae69"}, {"code": "(fn sym? [[_ [a la ra] [b lb rb]]]\n          (or (and (= nil a b))\n              (and (= a b)\n                   (sym? [nil la rb])\n                   (sym? [nil lb ra]))))", "problem": 96, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(letfn [(M? [s t]\n          (cond (empty? s) (empty? t)\n                (empty? t) (empty? s)\n                :else (and (= (first s) (first t))\n                           (M? (nth s 1) (nth t 2))\n                           (M? (nth s 2) (nth t 1)))))]\n  (fn [t]\n    (M? (nth t 1) (nth t 2))))", "problem": 96, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn check-mirror [tree]\n   (= (second tree)\n      ((fn flip [branch] (if (sequential? branch)\n                    (vector\n                     (first branch)\n                     (flip (last branch))\n                     (flip (second branch)))\n                    branch)) (last tree))))", "problem": 96, "user": "53838742e4b06839e8705ee0"}, {"code": "(fn [t]\n  (letfn [(tree-mirror? [l r]\n            (or (and (nil? l) (nil? r))\n                (and (= 3 (count l) (count r))\n                     (let [[lv ll lr] l\n                           [rv rl rr] r]\n                       (and (= lv rv)\n                            (tree-mirror? ll rr)\n                            (tree-mirror? lr rl))))))]\n    (or (nil? t)\n        (and (= 3 (count t))\n             (tree-mirror? (nth t 1) (nth t 2))))))", "problem": 96, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn [tree]\n  (let [binary-tree? (fn binary-tree? [tree]\n                       (let [seq-branch? (fn [node]\n                                           (if (and (sequential? node)\n                                                    (= (count node) 3))\n                                             true\n                                             false))\n                             result-seqs (tree-seq seq-branch? rest tree)\n                             seq1 (filter sequential? result-seqs)\n                             seq2 (filter (complement sequential?) result-seqs)]\n                         (and\n                          (every? #(= 3 (count %)) seq1)\n                          (every? nil? seq2))))\n        swap-tree (fn swap-tree [tree]\n                    (if (sequential? tree)                      \n                      (cons (first tree) (cons (swap-tree (nth tree 2)) (list (swap-tree (nth tree 1)))))\n                      tree))]\n    (and (binary-tree? tree)\n         (= (swap-tree (nth tree 1)) (nth tree 2)))))", "problem": 96, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn [tree]\n  (letfn [(node [t] (first t))\n          (left [t] (second t))\n          (right [t] (nth t 2))\n          (run [l r]\n               (cond\n                \t(and (nil? l) (nil? r)) true\n                    (or (nil? l) (nil? r)) false\n                \t:default (and (= (node l) (node r))\n                                  (run (left l) (right r))\n                                  (run (right l) (left r)))))]\n    (run (left tree) (right tree))))", "problem": 96, "user": "5192b707e4b08962174cf751"}, {"code": "(fn [[root lhs rhs]]\n  (letfn [(mirror [c] (if (nil? c) c [(first c) (mirror (last c)) (mirror (second c))]))]\n    (= lhs (mirror rhs))))", "problem": 96, "user": "53806e5be4b06839e8705ec1"}, {"code": "#(= % ((fn mir [[r le ri :as tr]]\n  \t\t(if tr (conj [] r (mir ri) (mir le)))) %))", "problem": 96, "user": "53973e7be4b0b51d73faaee6"}, {"code": "(fn symmetric? [tree]\n  (let [node-value (fn [tree] (first tree))\n        left-child (fn [tree] (second tree))\n        right-child (fn [tree] (nth tree 2))\n        ts (fn [tree children] (map first (tree-seq (complement nil?) children tree)))\n        l2r (fn [tree] (list (left-child tree) (right-child tree)))\n        r2l (fn [tree] (reverse (l2r tree)))]\n    (every? identity (map = (ts tree l2r) (ts tree r2l)))))", "problem": 96, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "(fn mirrored? [tree]\n  (let [traverse \n        ((fn in-order [node] (if\n                              (nil? node) nil\n                              (concat (in-order (nth node 1)) [(nth node 0)] (in-order (nth node 2)))\n                              )) tree)\n                              ]\n        (= traverse (reverse traverse)\n  )\n)\n)", "problem": 96, "user": "52ac41fee4b0c58976d9ac85"}, {"code": "(fn [[_ l r]]\n  (letfn [(f [[f1 l1 r1] [f2 l2 r2]]\n            (and (= f1 f2)\n                 (or (= f1 nil)\n                     (and (f l1 r2)\n                          (f l2 r1)))))]\n    (f l r)))", "problem": 96, "user": "536b2048e4b0243289761eb7"}, {"code": "(fn [tree]\n  (or (empty? tree)\n    ((fn mirrored? [t1 t2]\n      (or (= nil t1 t2)\n        (and (= (first t1) (first t2))\n             (mirrored? (second t1) (last t2))\n             (mirrored? (last t1) (second t2)))))\n     (second tree) (last tree))))", "problem": 96, "user": "5189a51ae4b0288ada3dbdad"}, {"code": "(fn [[main-root subtree1 subtree2]]\n  (let [equivalent-nodes? (fn equivalent-nodes? [node1 node2 symetric?]\n                            (if (sequential? node1)\n                              (symetric? node1 node2)\n                              (= node1 node2)))\n        symetric? (fn symetric? [[root1 subtree1a subtree1b]\n                       [root2 subtree2a subtree2b]]\n                    (and\n                     (= root1 root2)\n                     (equivalent-nodes? subtree1a subtree2b symetric?)\n                     (equivalent-nodes? subtree1b subtree2a symetric?)))]\n    (symetric? subtree1 subtree2)))", "problem": 96, "user": "4feaa579e4b0140c20fb9c0b"}, {"code": "(fn symmetric? [[val left right]]\n  (letfn [(mirror-image [tree]\n           (if (nil? tree) nil\n               [(first tree)\n                (mirror-image (nth tree 2))\n                (mirror-image (nth tree 1))]))]\n    (= left (mirror-image right))))", "problem": 96, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn [[_ l r]]\n  (= ((fn m [t] \n        (let [[n l r] t \n              lm (if l m identity) \n              rm (if r m identity)]\n          [n (rm r) (lm l)])) l) \n     r))", "problem": 96, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn\n  [t]\n  (letfn [(mirror [t] (if (nil? t)\n                          nil\n                          [(first t)\n                           (mirror (nth t 2))\n                           (mirror (nth t 1))]))]\n    (= t (mirror t))))", "problem": 96, "user": "52dfc89be4b09f7907dd1405"}, {"code": "(fn f\n          ([[x y z]] (f y z))\n          ([y z] (if (sequential? y)\n                   (and (sequential? z) (= (first y) (first z)) (f (second y) (nth z 2)) (f (nth y 2) (second z)))\n                   (= y z))))", "problem": 96, "user": "52c7f036e4b0c2d177d62126"}, {"problem": 96, "code": "(fn sym-tree [tree]\n  (let [reverser (fn f [x] (if x [(first x) (f (last x)) (f (second x))] x))]\n    (= (second tree) (reverser (last tree)))))", "user": "538e864ee4b0b51d73faae87"}, {"problem": 96, "code": "(fn sym-tree? [t] (= t ((fn rev [n] (if (nil? n) n [(first n) (rev (nth n 2)) (rev (nth n 1))])) t)))", "user": "4faf97d8e4b081705acca258"}, {"problem": 96, "code": "(fn mirror? [tree]\n  (let [inorder-func (fn travel [t]\n                       (if (coll? t)\n                         (concat (travel (nth t 1))\n                                 [(first t)]\n                                 (travel (nth t 2)))\n                         [t]))\n        flat-tree (inorder-func tree)]\n    (= flat-tree (reverse flat-tree))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 96, "code": "(fn parsetree\n  ([[_ left right]] (parsetree left right))\n  ([left right]\n    (cond (or (not= (first left) (first right))\n              (not= (first (second left)) (first (second (rest right))))\n              (not= (first (second (rest left))) (first (second right)))) false\n          (and (nil? (second left)) (nil? (second (rest right)))\n               (nil? (second (rest left))) (nil? (second right))) true\n          :else (and (true? (parsetree (second left) (second (rest right))))\n                     (true? (parsetree (second (rest left)) (second right)))))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 96, "code": "(fn checktree [t]\n    (= (second t)\n       ((fn flip [t]\n          (if (= t nil) nil\n           [(first t) (flip (nth t 2)) (flip (second t))]))\n        (nth t 2))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 96, "code": "#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 96, "code": "(fn [tree] \n  (letfn [(rev [t] \n               (if (sequential? t) (#(vector (first %) \n                                                 (rev (last %)) \n                                                 (rev (second %))) t) t))\n          ]\n    (= tree (rev tree))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 96, "code": "(fn is-symmetric[tree](if (nil? tree) true \n\t(let [[root left right] tree] \n\t\t((fn is-mirror [left right]\n\t\t\t(let [[l-root l-left l-right] left \n\t\t\t\t  [r-root r-left r-right] right]\n\t\t\t\t(if (and (nil? l-root) (nil? r-root)) true\n\t\t\t\t(if (= l-root r-root)\n\t\t\t\t\t(and true \n\t\t\t\t\t\t(is-mirror l-left r-right)\n\t\t\t\t\t\t(is-mirror l-right r-left)) false)))) left right))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 96, "code": "(fn [x] (.nextBoolean (new java.util.Random)))", "user": "52fba50ce4b047fd5583700d"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (nth t 2)))\n  ([lb rb] (or (and (nil? lb) (nil? rb))\n               (if (and (coll? lb) (coll? rb))\n                 (and (= (count lb) (count rb) 3)\n                      (= (first lb) (first rb))\n                      (sym? (second lb) (nth rb 2))\n                      (sym? (second rb) (nth lb 2)))\n                 false))))", "user": "523ea111e4b057c4b7cd0a65"}, {"problem": 96, "code": "(fn is-symmetric? [tree]\n  (let\n    [flip-tree (fn flip-tree\n      [node]\n      (if (not (sequential? node))\n        node\n        (vector (first node)\n         (flip-tree (nth node 2))\n         (flip-tree (second node)))))]\n  (= (second tree) (flip-tree (nth tree 2)))))", "user": "53ac4719e4b047364c04445c"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(inorder [tree]\n            (if (coll? tree)\n              (let [val (first tree)\n                    left (nth tree 1)\n                    right (nth tree 2)]\n                (concat (inorder left)\n                        (vector val)\n                        (inorder right)))\n              (vector tree)))]\n    (= (inorder (nth tree 1))\n       (reverse (inorder (nth tree 2))))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 96, "code": "(fn symmetric? [[_ l r]] \n\t(letfn [(mirror [xs]\n\t\t\t\t(if (not (coll? xs)) xs\n\t\t\t\t\t(vector (first xs) (mirror (last xs)) (mirror (second xs)))))]\n\t\t(= (mirror l) r)))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 96, "code": "(fn beauty-is-symmetry [[value & children]] \n  (= (first children) \n     ((fn mirror [[value & children]] \n       (cons value (map #(if (nil? %) % (mirror %)) (reverse children)))) \n     (second children))))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(mirror [root]\n           (if (not (coll? root)) root\n               [(first root) (mirror (last root)) (mirror (second root))]))]\n    (= tree (mirror tree))))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 96, "code": "#(= (second %) \n    ((fn invert [t]\n       (if (nil? t)\n         nil\n         (list (first t)\n               (invert (last t))\n               (invert (second t)))))\n     (last %)))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 96, "code": "#(letfn [(left [tree] (nth tree 1))\n         (right [tree] (nth tree 2))\n         (is-mirror [lnode rnode]\n            (or (and (nil? lnode) (nil? rnode))\n                (and (= (nth lnode 0) (nth rnode 0))\n                     (is-mirror (left lnode) (right rnode))\n                     (is-mirror (right lnode) (left rnode)))))]\n    (or (nil? %)\n        (is-mirror (left %)\n                   (right %))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 96, "code": "(fn sym? [node]\n\t(letfn [(mirror [node]\t\t\n\t\t(when-let [[v l r] node]\n\t\t\t[v (mirror r) (mirror l)]))]\n\t(= (second node) (mirror (last node)))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 96, "code": "#(letfn[(bintree[s1 s2]\n  (if (not= (first s1) (first s2))\n    false\n    (if (not= (count s1) (count s2))\n      false\n      (if (and (sequential? s1) (sequential? s2))\n        (if (and (= (second s1) (last s2))\n                 (= (last s1) (second s2))\n                 (not (sequential? (second s1)))\n                 (not (sequential? (last s1)))\n                 (not (sequential? (second s2)))\n                 (not (sequential? (last s2))))\n          true\n          (cond (and\n               (sequential? (second s1)) \n               (sequential? (last s1))\n               (sequential? (second s2))\n               (sequential? (last s2)))\n                (if (or \n                     (not= (first (second s1)) (first (last s2)))\n                     (not= (first (last s1)) (first (second s2))))\n                  false\n                  (and (bintree (second s1) (last s2))\n                       (bintree (last s1) (second s2))))\n                (not (sequential? (second s1)))\n                (if (not= (second s1) (last s2))\n                  false\n                  (bintree (last s1) (second s2)))\n                (not (sequential? (last s1)))\n                (if (not= (last s1) (second s2))\n                  false\n                  (bintree (second s1) (last s2)))\n                :else\n                false))))))]\n  \t(bintree (second %) (last %)))", "user": "4e8849c5535d8b9bb0147ca4"}, {"problem": 96, "code": "(fn [t]\n  (let [flip (fn f [[v l r]] [v (if (coll? r) (f r) r) (if (coll? l) (f l) l)])]\n    (= t (flip t))))", "user": "52d07cc5e4b07d0d72b273bb"}, {"problem": 96, "code": "(fn sym? [[a b c :as d]]\n  (let [e (fn e [t1 t2] (if (and (coll? t1) (coll? t2))\n                        (and (= (first t1) (first t2))\n                             (e (nth t1 1) (nth t2 2))\n                             (e (nth t1 2) (nth t2 1)))\n                          (= t1 t2)))]\n  (if (and (coll? b) (coll? c))\n    (and (e b c))\n    (= b c))))", "user": "539c88e1e4b0b51d73faaf2c"}, {"problem": 96, "code": "(fn f [[a b c]]\n  (= b ((fn g [[h l r]]\n          (and h [h (g r) (g l)])) c)))", "user": "53523ae0e4b084c2834f4aee"}, {"problem": 96, "code": "(fn task-96 [[v l r]]\n  (= l \n     ((fn mirror [t]\n         (if (seq t)\n           (let [[value left right] t]\n             [value (mirror right) (mirror left)])\n           t)) r)))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 96, "code": "#(= % ((fn mirror [[v a b]] [v (when b (mirror b)) (when a (mirror a))]) %))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (= (vec (flatten ((fn inverter [items]\n                      (let [n (first items)\n                            l (second items)\n                            r (last items)]\n                        (cond (= nil l r) items\n                              (= nil l) [n (inverter r) nil]\n                              :othwewise [n (inverter r) (inverter l)])))\n                    left)))\n     (vec (flatten right))))", "user": "52fc34cee4b047fd55837015"}, {"problem": 96, "code": "#((fn sym [a b]\n  (or \n   (= a b nil)\n   (and \n    (sequential? a)\n    (sequential? b)\n    (= (first a) (first b))\n    (sym (nth a 1) (nth b 2)) \n    (sym (nth a 2) (nth b 1)))\n   false\n  )) (nth % 1) (nth % 2))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 96, "code": "#(= (second %)\n    ((fn mirror [s]\n       (if (coll? s) [(first s) (mirror (last s)) (mirror (second s))]\n         s)\n       ) (last %)))", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 96, "code": "(fn [root]\n  (let [mir? (fn mir? [l r]\n    (or (= nil l r)\n        (and\n         (= (first l) (first r))\n         (= 3 (count l) (count r))\n         (mir? (nth l 1) (nth r 2))\n         (mir? (nth l 2) (nth r 1)))))]\n  (or (nil? root)\n      (and (= (count root) 3)\n           (mir? (nth root 1) (nth root 2))))))", "user": "537e745ae4b06839e8705ea6"}, {"problem": 96, "code": "#(letfn [(mirror [tree]\n            (if (nil? tree) nil\n              [(first tree)\n               (mirror (second (rest tree)))\n               (mirror (second tree))]))]\n   (= \n    (flatten (second %1))\n    (flatten (mirror (second (rest %1))))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 96, "code": "(fn [t]\n  ((fn mirrortree [t1 t2]\n    (if (and (sequential? t1) (sequential? t2))\n      (let [val1   (nth t1 0)\n            left1  (nth t1 1)\n            right1 (nth t1 2)\n            val2   (nth t2 0)\n            left2  (nth t2 1)\n            right2 (nth t2 2)]\n        (and (= val1 val2) (mirrortree left1 right2) (mirrortree right1 left2)))\n      (= t1 t2)))\n  (nth t 1) (nth t 2)))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 96, "code": "(fn __ [[v left right]]\n  ((fn symmetric? [l r]\n     (if (and (nil? l) (nil? r))\n       true\n       (let [l-col? (coll? l)\n             r-col? (coll? r)\n             [lval ll lr] l\n             [rval rl rr] r]\n         (if (or (and r-col? (not l-col?))\n                 (and l-col? (not r-col?))\n                 (not= lval rval)\n                 (not (symmetric? ll rr))\n                 (not (symmetric? lr rl)))\n           false\n           true)))) left right))", "user": "4f1e4ab5535d64f603146496"}, {"problem": 96, "code": "(fn symtree?\n    ([s] (symtree? (second s) (last s)))\n    ([l r]\n      (or (and (nil? l) (nil? r))\n        (and \n          (= (first l) (first r)) ; compare vals\n          (symtree? (second l) (last r))\n          (symtree? (second r) (last l))\n        )))\n    )", "user": "52bf0116e4b07a9af5792328"}, {"problem": 96, "code": "(fn is-symmetrical? [t] \n  (if (seq? t)\n     (let [t-nodes (remove seq? (tree-seq seq? (fn [[n l r]] [l n r]) t))]\n       (= t-nodes (reverse t-nodes)))\n     (let [t-nodes (remove vector? (tree-seq vector? (fn [[n l r]] [l n r]) t))]\n       (= t-nodes (reverse t-nodes)))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 96, "code": "(fn beautiful? [tree]\n  (letfn [(mirrorize [t]\n            (if (sequential? t)\n              (list (first t)\n                    (mirrorize (last t))\n                    (mirrorize (second t)))\n              t))]\n    (= (last tree) (mirrorize (second tree)))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 96, "code": "(fn is-symm?\n  ([[_ left right]]\n           (is-symm? left right))\n        ([[ vl ll rl ] [vr lr rr]]\n           (let [eqlr (or (and (nil? ll) (nil? rr)) (is-symm? ll rr))\n                 eqrl (or (and (nil? rl) (nil? lr)) (is-symm? rl lr))\n                 branch-eq (and eqlr eqrl)]\n             (and (= vl vr) branch-eq))))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 96, "code": "(fn symmetrictree? [x]\n     (= ((fn deepreverse [y] \n         (if (not (sequential? y))\n       y\n       (if (reduce #(or %1 %2) (map sequential? y))\n         (map deepreverse (assoc (vec (assoc (vec y) 1 (last y))) 2 (last (butlast y))))\n         (assoc (vec (assoc (vec y) 1 (last y))) 2 (last (butlast y))))))\n         (second x)) (last x)))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 96, "code": "(fn sym?\n  ([bt] (sym? (nth bt 1) (nth bt 2)))\n  ([bt1 bt2]\n     (let [v1 (nth bt1 0), v2 (nth bt2 0)\n           l1 (nth bt1 1), l2 (nth bt2 1)\n           r1 (nth bt1 2), r2 (nth bt2 2)]\n       (and (= v1 v2)\n            (or (and (seq l1) (seq r2) (sym? l1 r2))\n                (= l1 r2))\n            (or (and (seq l2) (seq r1) (sym? l2 r1))\n                (= l2 r2))))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 96, "code": "(fn [t] (= t ( (fn r [[a b c :as l]] (if (and (sequential? l) (= (count l) 3)) (conj [a] (r c) (r b)) l)) t)))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 96, "code": "(fn sym? [tree] \n  (.equals \n   (second tree)\n   ((fn foo [s] \n     (if (and (= nil (second s) (= nil (nth s 2))))\n       s\n       (list\n          (first s)\n          (if (= nil (nth s 2))\n            nil\n            (foo (nth s 2)))\n          (if (= nil (second s))\n            nil\n            (foo (second s)))\n       \n       ))) (nth tree 2))\n   ))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(walk [node direction]\n                (if (sequential? node)\n                  (let [[root left right] node]\n                    (if (= direction :left)\n                      [root (walk left  direction) (walk right direction)]\n                      [root (walk right direction) (walk left  direction)]))\n                  node))]\n    (= (walk tree :left)\n       (walk tree :right))))", "user": "53710c09e4b0fc7073fd6ea5"}, {"problem": 96, "code": "(fn sym? [tree]\n  (let [\n         lwalk (map #(if (sequential? %) (first %) %) (tree-seq sequential? #(rest (seq %)) tree)),\n         rwalk (map #(if (sequential? %) (first %) %)(tree-seq sequential? #(reverse (rest (seq %))) tree))\n         ]\n    (= lwalk rwalk)\n    ))", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 96, "code": "(fn [[h a b]] \n\t(= a (clojure.walk/postwalk #(if (sequential? %) (concat [(first %)] (reverse (rest %))) %) b)))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 96, "code": "#((fn f [x y]\n  (or\n    (= (or x y) nil)\n    (let [[a b c] x [d e q] y]\n      (and (= a d) (f b q) (f c e))\n    ))) (nth % 1) (nth % 2))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 96, "code": "(fn symmetry_btree? [t]\n   ((fn symmetry? [t1 t2]\n      (or (and (nil? t1) (nil? t2))\n          (and (= (first t1) (first t2))\n               (symmetry? (second t1) (last t2))\n               (symmetry? (last t1) (second t2))))) (second t) (last t)))", "user": "52fac708e4b047fd55836fff"}, {"problem": 96, "code": "(fn symmetric?\n  ([[v l r]]\n   (or (and (nil? l) (nil? r))\n       (symmetric? l r)))\n  ([[v1 l1 r1] [v2 l2 r2]]\n   (and (= v1 v2)\n        (or (and (nil? l1) (nil? r2))\n            (symmetric? l1 r2))\n        (or (and (nil? r1) (nil? l2))\n            (symmetric? r1 l2)))))", "user": "531619c1e4b08068f379ed3d"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n    (let [mirror? (fn mirror? [a b]\n                    (if (and (sequential? a) (sequential? b))\n                      (let [[ra La Ra] a\n                            [rb Lb Rb] b]\n                        (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                      (= a b)))]\n      (mirror? left right)))", "user": "53a83c74e4b047364c044426"}, {"problem": 96, "code": "(fn [tree]\n  (let [mirror (fn self [tree]\n                 (if (nil? tree)\n                   nil\n                   (let [[v l r] tree]\n                     (list v (self r) (self l)))))]\n    (if (nil? tree)\n      true\n      (let [[v l r] tree]\n        (= (mirror l) r)))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 96, "code": "(fn symmetry? [tr]\n    (= tr \n       ((fn do-symmetry [xs]\n         (if (= nil xs) nil\n           (concat (take 1 xs)  (conj (empty xs) (do-symmetry (last xs))) (conj (empty xs) (do-symmetry (second xs)))\n           ))\n         ) tr\n       ) )\n    \n    )", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 96, "code": "(fn symmetric? [[_ left right]]\n  (if\n    (and (nil? left) (nil? right)) true\n    (and\n     (= (first left) (first right))\n     (symmetric? (list 0 (second left) (last right)))\n     (symmetric? (list 0 (last left) (second right))))))", "user": "53c126fce4b00fb29b22125b"}, {"problem": 96, "code": "(fn symmetry? [x]\n  (letfn [(recur-invert [coll]\n            (let [[n l r] coll]\n              (list n\n                    (if (coll? r) (recur-invert r) r)\n                    (if (coll? l) (recur-invert l) l))))]\n    (and (= (count x) 3)\n         (let [[_ l r] x]\n           (= l (recur-invert r))))))", "user": "511b9017e4b00c2a1fa7ff6b"}, {"problem": 96, "code": "(fn is-symmetric? [[_ l r]] (cond \n                              (and (nil? l) (nil? r)) true\n                              (or (and (nil? l) (not (nil? r)))\n                                  (and (not (nil? l)) (nil? r))) false\n                              (not= (first l) (first r)) false\n                              :else (and (is-symmetric? (list _ (second l) (last r))) (is-symmetric? (list _ (last l) (second r))))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 96, "code": "(fn symmetric?\n  ([x]\n    (or (nil? x) (symmetric? (second x) (nth x 2))))\n  ([x y]\n    (or (every? nil? [x y])\n        (and (every? coll? [x y])\n             (= (first x) (first y))\n             (symmetric? (second x) (nth y 2))\n             (symmetric? (nth x 2) (second y))))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirror?\n            [[lx ll lr :as l] [rx rl rr :as r]]\n            (or (not (or l r))\n                (and (= lx rx)\n                     (and (mirror? ll rr)\n                          (mirror? lr rl)))))]\n    (mirror? l r)))", "user": "53ea3412e4b036ad0777e4d9"}, {"problem": 96, "code": "(fn [[v l r]]  \n  (= l ((fn flip [[v l r]] (list v (if r (flip r) nil) (if l (flip l) nil)))  r)))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 96, "code": "(fn [[root left right]]\n  (letfn [(mirror? [a b]\n    (cond\n      (sequential? a) (let [[ra La Ra] a\n                         [rb Lb Rb] b]\n                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n      :else (= a b)))]\n    (mirror? left right)))", "user": "53e241a6e4b036ad0777e3f0"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [mirrors? (fn mirrors? [t1 t2]\n                   (if (and (nil? t1) (nil? t2)) true\n                     (if (or (nil? t1) (nil? t2)) false\n                       (let [[n1 l1 r1] t1\n                             [n2 l2 r2] t2\n                             ]\n                         (and (= n1 n2)\n                              (mirrors? l1 r2)\n                              (mirrors? l2 r1)\n                              )))))\n        ]\n    (if (nil? tree) true\n      (let [[n l r] tree]\n        (mirrors? l r)\n        ))\n    ))", "user": "53dadf1de4b0e771c30254ad"}, {"problem": 96, "code": "(fn [t]\n  (let [sym? (fn self [n1 n2] (if (or (not-any? coll? [n1 n2])\n                                      (not-any? coll? (concat n1 n2)))\n                                  (= n1 n2)\n                                  (and (= (first n1) (first n2))\n                                       (self (second n1) (last n2))\n                                       (self (last n1) (second n2)))))]\n    (apply sym? (rest t))))", "user": "539dcb24e4b0b51d73faaf3d"}, {"problem": 96, "code": "#((fn m [l r]    \n    (if (and (nil? l) (nil? r))\n      true\n      (if (or (nil? l) (nil? r))\n        false\n        (if  (not (= (nth l 0) (nth r 0)))\n          false\n          (and (m (nth l 1) (nth r 2)) (m (nth l 2) (nth r 1)))\n        )\n      )\n    )\n  ) (nth %1 1) (nth %1 2))", "user": "51897709e4b0288ada3dbdaa"}, {"problem": 96, "code": "(fn [t]\n  (let [[a b c] t]\n    (= b\n       ((fn f [u]\n          (if (coll? u)\n            (let [[x y z] u]\n              (map f [x z y]))\n            u))\n        c))))", "user": "51ab70c3e4b04e3dc0c27b33"}, {"problem": 96, "code": "#(letfn\n   [(mirror [[n l r :as t]] (if (nil? t) t [n (mirror r) (mirror l)]))]\n  (let [[n r l] %] (= (mirror r) l)))", "user": "53e4fa2ce4b036ad0777e454"}, {"problem": 96, "code": "(fn symmetric-tree? [t]\n  (letfn [(reverse-node [t]\n                        (printf \"%s\" t)\n                        (if (nil? t)\n                          nil\n                          (conj [] (first t) (reverse-node (last t)) (reverse-node (nth t 1)))))]\n    (= (nth t 1) (reverse-node (last t)))))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 96, "code": "(fn [[x l r]]\n  (letfn [(trav [[x l r]]\n                  (if x\n                    (concat (trav l) [x] (trav r))\n                    []))]\n    (= (trav l) (reverse (trav r)))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 96, "code": "#(letfn [(flip [x]\n               (if (nil? x)\n                 nil\n                 [(first x) (flip (nth x 2)) (flip (nth x 1))]))\n         ]\n  (= % (flip %)))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 96, "code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "52ba2639e4b07a9af57922cb"}, {"problem": 96, "code": "(fn [t]\n    (reduce #(and %1 %2)\n            (map #(= (first %1) (first %2))\n                 (tree-seq #(not (nil? %))\n                           #(if (coll? %)\n                              (rest %)\n                              [])\n                           t)\n                 (tree-seq #(not (nil? %))\n                           #(if (coll? %)\n                              (reverse (rest %))\n                              [])\n                           t))))", "user": "50981062e4b04e098a4c7268"}, {"problem": 96, "code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 96, "code": "(fn [t]\n    (letfn [(bis-mirror [m-t]\n              (if (sequential? m-t)\n                [(first m-t) \n                 (bis-mirror (first (nnext m-t))) \n                 (bis-mirror (second m-t))]\n                m-t))]\n      (= (second t) (bis-mirror (first (nnext t))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 96, "code": "(fn is-sym? \n  ([root] (if (nil? root) \n         true\n         (is-sym? (second root) (nth root 2))))\n  ([l r] (if (and (nil? l) (nil? r)) true \n   \t\t\t(if (= (first l) (first r))\n            (and (is-sym? (second l) (nth r 2))\n                 (is-sym? (second r) (nth l 2)))\n            false))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 96, "code": "(fn mirror-tree [tree]\n  (if (nil? tree)\n    true\n    (let [trans-tree (fn trans-tree [tree]\n                       (if (seq tree)\n                         [(first tree)\n                          (trans-tree (nth tree 2))\n                          (trans-tree (second tree))]))\n          tree-vec (fn tree-vec [tree]\n                     (if (seq tree)\n                       [(first tree)\n                        (tree-vec (nth tree 1))\n                        (tree-vec (nth tree 2))]))]\n      (= (trans-tree (nth tree 1))\n         (tree-vec (nth tree 2))))))", "user": "53e27bf1e4b036ad0777e3f2"}, {"problem": 96, "code": "#(= % ((fn flip [[v l r :as n]]\n               (if n\n                 [v (flip r) (flip l)]))\n               %))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 96, "code": "(fn f [[a b c]]\n  (if (and (coll? b) (coll? c))\n    (and (= (first b) (first c))\n         (f [a (second b) (last c)])\n         (f [a (last b) (second c)]))\n    (= b c))\n )", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 96, "code": "(fn peu [x]\n\t(if (= x nil) true\n\t\t(let [a (second x) b (last x)] \n        \t(and\n            \t(= a\n                \t((fn rot [y] \n                    \t(if (= y nil) nil\n                        \t(list (first y) (rot (last y)) (rot (second y)))\n                        )\n                    ) b)\n                )\n            )\n        )\n    )\n)", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 96, "code": "(fn [[a b c]]\n    (let [trees-mirror? (fn tree-mirror? [x y]\n                          (or\n                           (= x y nil)\n                           (and\n                            (not (or (nil? x) (nil? y)))\n                            (let [[p q r] x\n                                  [e f g] y]\n                              (and \n                               (= p e)\n                               (and (tree-mirror? q g) (tree-mirror? r f)))))))]\n      (trees-mirror? b c)))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 96, "code": "(letfn [(node? [n] (and (sequential? n) (= (count n) 3)))]\n  (fn symm?\n    ([t] (when (node? t) (let [[_ y z] t] (symm? y z))))\n    ([a b] (cond\n            (and (nil? a) (nil? b)) true\n            (and (node? a) (node? b)) (let [[xa ya za] a\n                                            [xb yb zb] b]\n                                        (and (= xa xb) (symm? ya zb) (symm? za yb)))\n            :else false))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 96, "code": "(let [\n      \n      swap-bintree (fn swap-bintree [xs] (if (coll? xs)\n                              (let [[val left right] xs]\n                                [val (swap-bintree right) (swap-bintree left)])\n                              nil))\n      \n      is-bintree? (fn is-bintree? [xs] (if (not (and (coll? xs) (= 3 (count xs))))\n                             false\n                             (let [is-bintree-or-nil? (fn [t] (or (nil? t) (is-bintree? t)))\n                                   [val left-child right-child] xs]\n                               (and (is-bintree-or-nil? left-child) (is-bintree-or-nil? right-child))\n                               )\n                             ))\n      ]\n  \n  (fn is-sym-bintree? [xs]\n    (and (is-bintree? xs) (= xs (swap-bintree xs))))\n)", "user": "53edb628e4b0d648e757f4c8"}, {"problem": 96, "code": "(fn s [[_ l r]]\n  (if (and (coll? l) (coll? r))\n    (let [[a b c] l\n          [d e f] r]\n      (and (= a d) (s [_ b f]) (s [_ c e])))\n    (= l r)))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 96, "code": "(fn m[[a b c]]\n  (or (= b c nil)\n      (and (= (first b) (first c))\n           (m [a (second b) (last c)])\n           (m [a (last b) (second c)])\n           )))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 96, "code": "(fn mirror \n  ([t]\n  (if (nil? t) true\n    (let [[v a b] t]\n      (mirror a b))))\n  ([a b]\n   (if (nil? a) (nil? b)\n     (let [[a-v a-a a-b] a [b-v b-a b-b] b]\n       (and (= a-v b-v)\n            (mirror a-a b-b)\n            (mirror a-b b-a))))))", "user": "534efe66e4b084c2834f4ac1"}, {"problem": 96, "code": "(fn s? [[_ [v1 l1 r1]\n\t\t   [v2 l2 r2]]]\n\t (and (= v1 v2)\n\t \t  (or\n            (and\n                (= nil l1 r2)\n                (= nil l2 r1))\n\t \t\t(and\n\t \t\t\t(s? [_ l1 r2])\n\t \t\t\t(s? [_ l2 r1])))))", "user": "51aefceee4b09397d5109797"}, {"problem": 96, "code": "(fn[t] (= ((fn mirror[t]\n  (if (coll? t)\n    (let [[n l r] t t2 [n (mirror r) (mirror l)]] t2)\n    t)\n  )\n t) t))", "user": "52271ffee4b04e78ff2e19a9"}, {"problem": 96, "code": "#(let [r (fn r [n]\n            (if (nil? n)\n              n\n              [(first n)\n               (r (nth n 2))\n               (r (nth n 1))]))]\n    (= (nth % 1)\n       (r (nth % 2))))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 96, "code": "(fn mt? [t]\n   (let [walklrf (fn wlr [[v l r] s]\n                   (if (nil? v)\n                   s\n                   (wlr r (conj (wlr l s) v))))\n         walkrlf (fn wrl [[v l r] s]\n                   (if (nil? v)\n                   s\n                   (wrl l (conj (wrl r s) v)) ))\n         lrs (walklrf t [])\n         rls (walkrlf t [])]\n     (= lrs rls)))", "user": "53ea5307e4b036ad0777e4e2"}, {"problem": 96, "code": "(fn sym [tree] (let [\n   root (first tree)\n   lc (second tree) \n   rc (last tree)\n   inv (fn inv [tree] (when-let [t (seq tree)]\n     (let [f (first t) l (second t) r (last t)]    \n       (list f (inv r) (inv l)))))\n   eq (fn eq [t1 t2] (cond \n   (nil? t1) (nil? t2)\n   (nil? t2) (nil? t1)\n   :else (and (= (first t1) (first t2))\n              (eq (second t1) (second t2))\n\t\t\t  (eq (last t1) (last t2)))))\n\t\t\t  ]\n    (and (eq lc (inv rc)))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(equal? [[v1 l1 r1] [v2 l2 r2]]\n            (and\n             (= v1 v2)\n             (or\n              (every? nil? [l1 r1 l2 r2])\n              (and (every? nil? [l1 r2])\n                   (equal? l2 r1))\n              (and (every? nil? [l2 r1])\n                   (equal? l1 r2))\n              (and\n               (equal? l1 r2)\n               (equal? r1 l2)))\n             )\n            )]\n    (cond\n     (nil? l) (nil? r)\n     (nil? r) (nil? l)\n     (not (sequential? l)) false\n     (not (sequential? r)) false\n     :else (equal? l r))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "53be3ee7e4b0d9a98559a6df"}, {"problem": 96, "code": "(fn is-sym[[val left right]]\n   \n   (letfn[(mirror [[v l r]]\n                  (vec (lazy-seq\n                         (if (nil? v)\n                           nil\n                           (let [mr (mirror r)\n                                 ml (mirror l)]\n                             [v\n                              (if (empty? mr) nil mr)\n                              (if (empty? ml) nil ml)])))))]\n     (= left (mirror right))\n     ))", "user": "5398123ee4b0b51d73faaef3"}, {"problem": 96, "code": "(fn symetric-tree? [[value left right & others]]\n            (let [go (fn [f n] (if (nil? n) [ nil ] (f n)))\n                  walkl (fn walkl [[v l r & o]] (concat [v] (go walkl l) (go walkl r)))\n                  walkr (fn walkr [[v l r & o]] (concat [v] (go walkr r) (go walkr l)))]\n              (= (walkl left) (walkr right)))\n            )", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (let [mirror? (fn mirror? [s t]\n                  (or (= nil s t)\n                      (and (= (first s) (first t))\n                           (mirror? (nth s 1) (nth t 2))\n                           (mirror? (nth s 2) (nth t 1)))))]\n    (and (mirror? (nth t 1) (nth t 2)))))", "user": "53e8c684e4b036ad0777e48b"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [mirror (fn m [[n l r]]\n                 (let [new-r (if (seq l) (m l) l)\n                       new-l (if (seq r) (m r) r)]\n                   [n new-l new-r]))]\n    (= (mirror left) right)))", "user": "53d86564e4b0e771c302546b"}, {"problem": 96, "code": "(fn [[h l r]]\n  ((fn sym? [t1 t2]\n    (or (and (nil? t1) (nil? t2))\n        (and (and (coll? t1) (coll? t2))\n             (= (first t1) (first t2))\n             (sym? (second t1) (last t2))\n             (sym? (last t1) (second t2))\n             true)))\n  l r))", "user": "53f7820be4b0de5c41848560"}, {"problem": 96, "code": "#((fn flipEq? [t1 t2]\n    (if (or (nil? t1) (nil? t2))\n      (= t1 t2)\n      (and (= (nth t1 0) (nth t2 0))\n       \t(flipEq? (nth t1 1) (nth t2 2))\n        (flipEq? (nth t1 2) (nth t2 1)))))\n  (nth % 1) (nth % 2))", "user": "5097ea89e4b087ccf61a7af4"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "51d42f44e4b013d740b70ddb"}, {"problem": 96, "code": "(fn [[r x y]]\n  (letfn [(g [[r x y] [R a b]]\n              (and (= r R) (f? x b) (f? y a)))\n          (f? [x y]\n              (if (and (coll? x) (coll? y))\n                (g x y)\n                (= x y)))]\n    (f? x y)))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 96, "code": "#(let [in-tree \n         (fn in-tree [t]\n           (if (= t nil)\n             '(nil)\n             (concat (in-tree (second t)) \n               (list (first t)) \n               (in-tree (nth t 2)))))\n        tmp (in-tree %)]\n        (= tmp (reverse tmp)))", "user": "53ff8c31e4b0de5c41848603"}, {"problem": 96, "code": "(fn sy [[root left right]]\n           (let [mirror? (fn mirror? [a b]\n                           (cond (not= (sequential? a)(sequential? b)) false\n                                 (sequential? a) (let [[ra La Lb] a\n                                                       [rb Ra Rb] b]\n                                                   (and (= ra rb) (mirror? La Rb) (mirror? Ra Lb)))\n                                 :else (= a b)))]\n             (mirror? left right)))", "user": "53b4bddae4b047364c0444b9"}, {"problem": 96, "code": "(fn [[value left right]]\n\t(= ((fn mirror [[v l r]]\n\t\t\t(list v (if (nil? r) r (mirror r)) (if (nil? l) l (mirror l)))\n\t\t) left) right)\n)", "user": "5409f8eae4b0addc1aec66e6"}, {"problem": 96, "code": "#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))", "user": "54021f13e4b0df28a13c62cc"}, {"problem": 96, "code": "(fn [[value left-child right-child]]\n  (= (map first (tree-seq sequential? rest left-child))\n     (map first (tree-seq sequential? #(-> % rest reverse) right-child))\n  )\n)", "user": "540f09b9e4b0addc1aec6725"}, {"problem": 96, "code": "(fn symmetric? [root]\n  (letfn [(mirror? [left right]\n            (cond (= nil left right) true,\n                  (or (= nil left) (= nil right)) false,\n                  :else (every? identity\n                                (conj (lazy-seq)\n                                      (= (first left) (first right))\n                                      (mirror? (nth left 1) \n                                               (nth right 2))\n                                      (mirror? (nth left 2) \n                                               (nth right 1))))))]\n    (mirror? (nth root 1) (nth root 2))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn[(mirror?[lb rb] \n          (cond\n            (not= (sequential? lb) (sequential? rb)) false\n            (sequential? lb) (let [[lv ll lr] lb [rv rl rr] rb]\n                               (and (= lv rv) (mirror? ll rr) (mirror? lr rl)))\n            :else (= lb rb)))]\n    (mirror? l r)))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 96, "code": "(fn [[root l r]]\n  ((fn mirror? [l r]\n    (or (and (nil? l) (nil? r))\n        (and (= (first l) (first r))\n             (mirror? (second l) (last r))\n             (mirror? (last l) (second r)))))\n    l r))", "user": "52c672e2e4b0c2d177d6210e"}, {"problem": 96, "code": "#(let [flip (fn flip [[v l r]]\n             (when v \n               [v (flip r) (flip l)]))\n      [_ l r]  %\n      ]\n  (= l (flip r)))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 96, "code": "(fn [xs]\n  (letfn [(reverse-tree [[root left right :as whole]]\n          (when whole\n            [root (reverse-tree right) (reverse-tree left)]))]\n    (= xs (reverse-tree xs))))", "user": "54133900e4b01498b1a719de"}, {"problem": 96, "code": "(letfn [(symmetric? [l r]\n          (if (nil? l)\n            (nil? r)\n            (and (= (first l) (first r))\n                 (symmetric? (second l) (last r))\n                 (symmetric? (last l) (second r))\n                 )))]\n  (fn [[_ l r]] (symmetric? l r)))", "user": "50f94727e4b0e7c80cb15a49"}, {"problem": 96, "code": "(fn [tree] ((fn mirror? [l r]\n                (or (= nil l r)\n                    (and (= (first l) (first r))\n                         (mirror? (second l) (last r))\n                         (mirror? (last l) (second r)))))\n              (second tree) (last tree)))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 96, "code": "(fn is-symmetric? [[v l r]]\n        (letfn [(tree-equal? [[v1 l1 r1] \n                              [v2 l2 r2]]\n                  (and (= v1 v2)\n                       (or (and (nil? l1) (nil? r2))\n                           (tree-equal? l1 r2))\n                       (or (and (nil? r1) (nil? l2))\n                           (tree-equal? r1 l2))))]\n          (tree-equal? l r)))", "user": "541ae7dbe4b01498b1a71a61"}, {"problem": 96, "code": "apply (fn st [n x y]\n      (if (or (nil? x) (nil? y)) (and (nil? x) (nil? y))\n        (and (= (first x) (first y))\n             (st n (nth x 1) (nth y 2))\n             (st n (nth x 2) (nth y 1))\n         )\n      )\n  )", "user": "53f035c2e4b0742d9025b0d2"}, {"problem": 96, "code": "(fn [[a b c]]\n  (letfn [(revtree [xs]\n            (if (coll? xs)\n              (let [[a b] (rest xs)]\n                (cons (first xs) (into (empty xs) (list (revtree b) (revtree a)))))))]\n    (= b (revtree c))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 96, "code": "(fn mirror? [tree]\n  (letfn [(reverser [coll]\n    (vector (first coll)\n            (if (coll? (last coll))\n              (reverser (last coll))\n              (last coll))\n            (if (coll? (second coll))\n              (reverser (second coll))\n              (second coll))))]\n    (= (second tree) (reverser (last tree)))))", "user": "53f6bfd9e4b0db01ade6f9e4"}, {"problem": 96, "code": "(fn [s]\n  (= s (clojure.walk/postwalk (fn [x]\n                           (if (and (sequential? x) (= 3 (count x)))\n                             (let [[a b c] x]\n                               (list a c b))\n                             x))\n                         s)))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 96, "code": "#(= % ((fn m [[v l r]] (if v [v (m r) (m l)])) %))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 96, "code": "(fn tree-symmetric? [[val l r]]\n  (letfn [(mirror-tree [[val l r]]\n            [val\n             (if (nil? r) nil (mirror-tree r))\n             (if (nil? l) nil (mirror-tree l))])]\n    (= l (mirror-tree r))))", "user": "53f2370ee4b0742d9025b0e7"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(|= [left right]\n            (if (and (sequential? left) (sequential? right))\n              (let [[l-v l-l l-r] left\n                    [r-v r-l r-r] right]\n                  (and (= l-v r-v)\n                   \t   (|= l-l r-r)\n                       (|= l-r r-l)))\n              (= left right)))]\n    (|= left right)))", "user": "51b8d3d5e4b050a1176cd69d"}, {"problem": 96, "code": "(fn [[v l r]]\n  ((fn symmetric? [l r]\n    (let [[v1 l1 r1] l\n          [v2 l2 r2] r]\n      (if (= v1 v2)\n        (or (= l1 l2 r1 r2 nil)\n            (and (symmetric? l1 r2) (symmetric? l2 r1)))\n        false))) l r))", "user": "50d882d4e4b01f0871336e69"}, {"problem": 96, "code": "(fn sym?\n  ([[_ l r]] (sym? l r))\n  ([[lv ll lr :as l] [rv rl rr :as r]]\n   (let [branch-sym? (fn [& lr] (or (every? nil? lr)\n                                   (and (every? keyword? lr) (apply = lr))\n                                   (and (every? sequential? lr) (apply sym? lr))))]\n     (and (= lv rv)\n          (branch-sym? ll rr) (branch-sym? rl lr)))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 96, "code": "(fn beauty-symmetric \n  ([x] (beauty-symmetric (first (rest x)) (first (rest (rest x)))))\n  ([node1 node2]\n    (do \n      (println node1 \"<>\" node2))\n    (if (= nil node1 node2)\n      true\n      (and \n        (sequential? node1) \n        (sequential? node2)\n        (= 3 (count node1) (count node2))\n        ; (println \"f:\" (first node1) (first node2))\n        (= (first node1) (first node2))\n        (let [lnode1 (first (rest node1))\n              rnode1 (first (rest (rest node1)))\n              lnode2 (first (rest node2))\n              rnode2 (first (rest (rest node2)))]\n          (and (beauty-symmetric lnode1 rnode2)\n               (beauty-symmetric rnode1 lnode2)))))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 96, "code": "(fn __ [tree]\n  (let [flip (fn flip [tree]\n               (let [[v l r :as t] tree]\n                 (when t\n                   [v (flip r) (flip l)])))]\n   (= tree\n      (flip tree))))", "user": "4f856adfe4b033992c121c44"}, {"problem": 96, "code": "(fn is-sym?\n  ([s]\n     (or (nil? s)\n         (let [l (first (rest s)) r (second (rest s))]\n           (is-sym? l r))))\n  ([l r]\n     (or (every? nil? (list l r))\n         (and (= (first l) (first r))\n              (let [ll (first (rest l)) lr (second (rest l)) rl (first (rest r)) rr (second (rest r))]\n                (and (is-sym? ll rr)\n                     (is-sym? lr rl))))))\n  )", "user": "53a511aae4b0b62ce3005735"}, {"problem": 96, "code": "(fn sbt [[h l r]]\n  (cond (not (or  (coll? l) (coll? r))) (= l r)\n        (not= (coll? l) (coll? r)) false\n        (not= (count l) (count r)) false\n        :else (let [[lh ll lr] l [rh rl rr] r]\n          (and (= lh rh)\n               (sbt [lh ll rr]) \n               (sbt [rh lr rl]))))\n        )", "user": "53e745a1e4b036ad0777e479"}, {"problem": 96, "code": "(fn mir \n\t([t]\n\t   (if (coll? t)\n\t     (mir (nth t 1) (nth t 2))))\n\t([l r]\n\t   (if (and (coll? r) (coll? l))\n\t     (and\n\t      (= (nth l 0) (nth r 0))\n\t      (mir (nth l 1) (nth r 2))\n\t      (mir (nth l 2) (nth r 1)))\n\t      (= l r))))", "user": "53da3fcde4b0e771c3025497"}, {"problem": 96, "code": "(fn [x] \n  (= \n   (remove nil? \n           (flatten (nth x 1))) \n   ((fn mir [y] \n      (cond (nil? (first y)) nil \n            :else (do (lazy-cat \n                       (cons (first y) (mir (nth y 2))) \n                       (mir (nth y 1)))))) (nth x 2))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 96, "code": "(fn [tree]\n    (letfn [(third [t] (first (rest (rest t))))\n            (mirror [t1 t2] \n              (cond (= t1 t2 nil) true\n                    (and  (= (first t1)\n                             (first t2))\n                          (mirror (second t1) (third t2))\n                          (mirror (third t1) (second t2))) true\n                    :else false))]\n      (mirror (second tree) (third tree))))", "user": "53a0ab8ce4b0ca733b9744b3"}, {"problem": 96, "code": "(fn b? [t] (let [[_ a b] t\n                  mirror (fn x [t] (if (nil? t) nil\n                                   (let [[v l r] t] [v (x r) (x l)])))]\n   (= (mirror a) b)))", "user": "54344721e4b0b6b47310fcea"}, {"problem": 96, "code": "(fn symetric?\n    ([[parent left right]]\n     (symetric? left right))\n    ( [[ap al ar] [bp bl br]]\n     (and (= ap bp)\n          (if (coll? al)\n            (symetric? al br)\n            (= al br))\n          (if (coll? ar)\n            (symetric? ar bl)\n            (= ar bl)))))", "user": "4fe15ffee4b0dd6cd5ce3634"}, {"problem": 96, "code": "(fn [[_ left right]]\n    (letfn [(unmirror [[n l r]]\n                      [n \n                       (if (sequential? r) (unmirror r) r)\n                       (if (sequential? l) (unmirror l) l)])]\n      (= left (unmirror right))))", "user": "537bde5de4b06839e8705e73"}, {"problem": 96, "code": "(fn [tree]\n  (let [cmpfn (fn are-trees-symmetric? [first second]\n                (or (and (nil? first) (nil? second))\n                    (let [[val1 left1 right1] first\n                          [val2 left2 right2] second]\n                      (and\n                        (= val1 val2)\n                        (and\n                          (are-trees-symmetric? left1 right2)\n                          (are-trees-symmetric? right1 left2))))))]\n    (cmpfn (second tree) (second (rest tree)))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 96, "code": "(fn [[v l r]]\n  (= r\n     ((fn m [x]\n        (if (sequential? x)\n          (let [[e1 e2 e3] x]\n            [e1 (m e3) (m e2)])\n          x)) l)))", "user": "50ebd63ce4b04edc3377703c"}, {"problem": 96, "code": "(fn [[k l p]] (= l ((fn f [[k l p]] (if k [k (f p) (f l)])) p)))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 96, "code": "#(let[[_ x y]%]((fn s[x y](or(= x y nil)(let[[a b c]x[d e f]y](and(= a d)(s b f)(s c e)))))x y))", "user": "4db2903f535df7e46ed9b6bf"}, {"problem": 96, "code": "(fn symmetric? \n  ([t] (symmetric? (second t) (last t)))\n  ([l r] (or \n          (and (nil? l) (nil? r))\n          (cond \n           (and (coll? l) (coll? r))\n             (and\n              (= (count l) (count r) 3)\n              (= (first l) (first r))\n              (symmetric? (second l) (last r))\n              (symmetric? (last l) (second r)))\n          :else false))))", "user": "5409a12fe4b0addc1aec66df"}, {"problem": 96, "code": "(fn [t]\n  ((fn symm [tl tr] \n      (if (not-any? nil? [tl tr])\n        (and \n          (= (first tl) (first tr)) \n          (symm (first (rest tl)) (second (rest tr))) \n          (symm (second (rest tl)) (first (rest tr))))\n        (= tl tr))) (first (rest t)) (second (rest t))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 96, "code": "(fn sym? [t]\n  (letfn [(swap [tree]\n             (if (coll? tree)\n             \t[(nth tree 0) (swap (nth tree 2)) (swap (nth tree 1))]\n                tree))]\n    (= t (swap t))))", "user": "54448e84e4b032a45b869393"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(tree= [[v1 l1 r1] [v2 l2 r2]]\n                 (if (or (nil? v1) (nil? v2))\n                   (= nil v1 v2)\n                   (and (= v1 v2) (tree= l1 r2) (tree= r1 l2))))]\n    (tree= l r)))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 96, "code": "(fn is-symmetric? \n    [tree]\n    (let [[a b c ] tree,\n          is-tree?\n          (fn is-tree? [tree]\n            (if (sequential? tree)\n              (and\n               (= (count tree) 3)\n               (every? #(not= false %) tree)\n               (every? true? (map is-tree? (filter sequential? tree))))\n              false\n              )),\n          mirror (fn mirror\n                    [tree ]\n                    (if (is-tree? tree)\n                      (let [[a b c] tree]\n                        [a (mirror  c)  (mirror b)])\n                      tree)\n                    )\n          ]\n      (= (mirror b) c)\n      ))", "user": "5433a07be4b0b6b47310fce0"}, {"problem": 96, "code": "(fn __96 [t]\n  (= t ((fn reverse-tree [[v l r :as t]]\n          (if (nil? v)\n            v\n            [v (reverse-tree r) (reverse-tree l) ]))\n        t)))", "user": "5151c184e4b03e678e393add"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(my-flat [tree]\n        (let [coll-tree (flatten [tree])]\n          (if (= (count coll-tree) 1)\n            (first coll-tree)\n            (let [[head left right] tree]\n              (flatten [(my-flat left) head (my-flat right)])))))]\n    (let [[head left right] tree]\n      (= ((comp reverse my-flat) left) (my-flat right)))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 96, "code": "(fn foo [[_ l r]]\n  (let [f (fn f [l r]\n            (if (not (and (coll? l) (coll? r)))\n              (= l r)\n              (and (= (first l) (first r))\n                   (f (second l) (nth r 2))\n                   (f (nth l 2) (second r)))))]\n    (f l r)))", "user": "5078d366e4b08327cd804a5b"}, {"problem": 96, "code": "(fn [coll]\n  (letfn [(equal-node? [l-ch r-ch]\n                       (cond (and (coll? l-ch) (coll? r-ch))\n                               (and (= (first l-ch) (first r-ch))\n                                    (equal-node? (nth l-ch 1) (nth r-ch 2))\n                                    (equal-node? (nth l-ch 2) (nth r-ch 1)))\n                             (and (not (coll? l-ch)) (not (coll? r-ch)))\n                               (= (first l-ch) (first r-ch))\n                             :else false))]\n    (if (coll? coll)\n      (equal-node? (nth coll 1) (nth coll 2))\n      false)))", "user": "544b5b8de4b0e39780006963"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "504457c0e4b01f6c9a8b2360"}, {"problem": 96, "code": "(fn f [[_ l r]]\n  (if (sequential? l)\n    (and (sequential? r)\n         (= (nth l 0) (nth r 0))\n         (f [_ (nth l 2) (nth r 1)])\n         (f [_ (nth l 1) (nth r 2)]))\n    (= l r)))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (=\n   ((fn reverse-tree [t]\n       (if (empty? t)\n         t\n         [(first t) (reverse-tree (nth t 2)) (reverse-tree (second t))]))\n    tree)\n   tree))", "user": "54125eeee4b01498b1a719d3"}, {"problem": 96, "code": "(fn [[a l r]] \n  ((fn sym[[a1 l1 r1 :as t1],[a2 l2 r2 :as t2]] \n     (or (and (nil? t1) (nil? t2))\n         (and (= a1 a2)(sym l1 r2)(sym l2 r1))))\n   l r))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 96, "code": "(fn sym [[v l r]]\n (if (or (nil? l) (nil? r))\n  (if (and (nil? l) (nil? r))\n   true\n   false)\n  (if (= (first l) (first r))\n   (let [l-bs (rest l)\n         r-bs (rest r)]\n    (and (sym [nil (first l-bs) (second r-bs)])\n         (sym [nil (second l-bs) (first r-bs)])))\n   false)))", "user": "54580586e4b01be26fd74616"}, {"problem": 96, "code": "#(let [t (fn t [[v l r]] [v (if r (t r)) (if l (t l))])\n       [_ l r] %]\n    (= l (t r)))", "user": "5412646de4b01498b1a719d4"}, {"problem": 96, "code": "(fn [[head l r]]\n  (letfn [(sym? [[ah al ar :as aa] [bh bl br :as bb]]\n            (cond\n             (and (nil? aa) (nil? bb)) true\n             (and (coll? aa) (coll? bb)) (and (= ah bh)\n                                              (sym? al br)\n                                              (sym? ar bl))\n             :else false))]\n    (and (boolean head) (sym? l r))))", "user": "505aa653e4b021387fb89857"}, {"problem": 96, "code": "(fn mirror-tree? [tree]\n  (letfn\n    [(traverse-left \n      [tree]\n      (let [l (if (coll? (second tree))\n                (traverse-left (second tree))\n                [nil])\n            r (if (coll? (nth tree 2))\n                (traverse-left (nth tree 2)) \n                [nil])]\n        (concat [(first tree)] l r)))\n     (traverse-right\n      [tree] \n      (let [l (if (coll? (second tree))\n                (traverse-right (second tree))\n                [nil])\n            r (if (coll? (nth tree 2))\n                (traverse-right (nth tree 2))\n                [nil])]\n        (concat [(first tree)] r l)))]\n    (= (traverse-left (second tree))\n       (traverse-right (nth tree 2)))))", "user": "5367bc60e4b0243289761e81"}, {"problem": 96, "code": "(fn [[t l r]]\n  ((fn s [[v1 l1 r1] [v2 l2 r2]]\n     (and (= v1 v2)\n          (or (and (nil? l1) (nil? r2)) (s l1 r2))\n          (or (and (nil? r1) (nil? l2)) (s r1 l2))))\n   l r))", "user": "502873a8e4b01614d1633ff8"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n(let [mirror? (fn mirror? [a b]\n(cond\n(not= (sequential? a) (sequential? b)) false\n(sequential? a) (let [[ra La Ra] a\n[rb Lb Rb] b]\n(and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n:else (= a b)))]\n(mirror? left right)))", "user": "52485723e4b05ef8e38e63d2"}, {"problem": 96, "code": "(fn mirror? [t]\n  (letfn [(inner-tree-walk [inn-t acc]\n                           (let [inner-t inn-t [value lnode rnode] inner-t]\n                             (if (nil? inner-t)\n                               acc\n                               (inner-tree-walk lnode (conj (inner-tree-walk rnode acc) value)))))]\n    (let [[_ lnode rnode] t]\n      (= (inner-tree-walk lnode '()) (reverse (inner-tree-walk rnode '()))))))", "user": "53c06438e4b0c98a41f5ccb0"}, {"problem": 96, "code": "(fn mirrored? [t]\n  (letfn [(mirror [[p l r]] \n                   (if (nil? p) \n                     nil\n                     [p (mirror r) (mirror l)]))]\n          (= t (mirror t))))", "user": "5454b84ce4b0e397800069d9"}, {"problem": 96, "code": "(fn mirror [[root a b]]\n  (or (and (nil? a)\n           (nil? b))\n      (and (= (first a) (first b))\n           (mirror [:root (nth a 2) (nth b 1)])\n           (mirror [:root (nth a 1) (nth b 2)]))\n  ))", "user": "544e9022e4b0e3978000698b"}, {"problem": 96, "code": "(fn [tree]\n  ((fn sym [l r]\n     (or (= l r nil)\n         (and (coll? l)\n              (coll? r)\n              (= (first l) (first r))\n              (sym (nth l 1) (nth r 2))\n              (sym (nth l 2) (nth r 1)))))\n   \t(nth tree 1)\n   \t(nth tree 2)))", "user": "5136f659e4b04059df19f2fd"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(mirror [[r L R :as t]]\n            (when t\n              [r (mirror R) (mirror L)]))]\n    (= (mirror t) t)))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 96, "code": "(fn symmetry [tree] (let [f (fn reshape [t] (if (nil? t) \n                                              nil \n                                              [(reshape (second t)) (first t) (reshape (last t))])) \n                          frt (flatten (f tree))] \n                      (= frt (reverse frt))))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 96, "code": "(fn [tree]\n  (let [mirror (fn f [tree]\n                 (if (nil? tree)\n                   tree\n                   [(first tree) (f (last tree)) (f (second tree))]))]\n    (= tree (mirror tree))))", "user": "546c4c5fe4b00cfc9eacc178"}, {"problem": 96, "code": "#(let [halves (rest %)\n       mirror? (fn mirror? [[node1 left1 right1 :as tree-1]\n                             [node2 left2 right2 :as tree-2]]\n                  (or (= nil tree-1 tree-2)\n                      (and (= node1 node2)\n                           (mirror? left1 right2)\n                           (mirror? left2 right1))))]\n    (apply mirror? halves))", "user": "508923d5e4b06d8254e936e8"}, {"problem": 96, "code": "(fn [tree]\n  (= tree\n     ((fn mirror-tree [n]\n       (if (not (instance? java.util.Collection n))\n         n\n         (list (first n)\n               (mirror-tree (nth n 2))\n               (mirror-tree (nth n 1)))))\n      tree)))", "user": "54651faee4b01be26fd746d6"}, {"problem": 96, "code": "(fn is-symmetric? [t]\n;; helper function for flipping\n\t(letfn [(flipper [t]\n\t\t(if (nil? t)\n\t\t\tt\n\t\t\t[(first t) (flipper (second (rest t))) (flipper (second t))]))]\n\t(= (second t) (flipper (second (rest t))))))", "user": "53703287e4b0fc7073fd6e8f"}, {"problem": 96, "code": "(let [\n   flip-tree\n     (fn flip-tree [tree] (\n       if (nil? tree)\n       nil\n       (list (first tree) (flip-tree (last tree)) (flip-tree (second tree)))\n                 \n     )\n      \n     )\n]\n (fn [tree] (and\n             (= (flip-tree tree) tree)\n             \n             \n          )\n   \n   \t\t\t)\n)\n;(fn symmetric [tree] (\n;\tor\n ;     (nil? tree)\n\t;  (and\n     ;  \t(= (count tree) 3)\n      ;\t(= (second tree) (flip-tree (last tree)))     \n       ; (symmetric (second tree))\n       \t;(symmetric (last tree))\n         ;)             )\n  \n  \n ; )\n;)", "user": "5471f090e4b094393f72dd6e"}, {"problem": 96, "code": "#(let [walker  (fn r [f c]\n   (if (coll? c)\n     (let [[e lc rc] c]\n       (list e (map (partial r f) (f [lc rc]))))\n     (list c)))]\n   (= (walker identity %) (walker reverse %)))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 96, "code": "(fn [[t u v]]\n  (let [m (fn m [s]\n            (if (nil? s)\n     \t\t s\n  \t\t    [(first s) (m (last s)) (m (second s))]))]\n   (= u (m v))))", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 96, "code": "(let [mirror (fn mirror [coll]\n               (when (seq coll)\n                 (list (first coll) (mirror (nth coll 2)) (mirror (second coll)))))]\n  (fn [coll]\n    (= coll (mirror coll))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(dm [[v l r :as node]]\n            (if-not (nil? node)\n              [v (dm r) (dm l)]\n              node))]\n    (= l (dm r))))", "user": "511688d5e4b0b3e208dba05a"}, {"problem": 96, "code": "(fn sym-tree? [tr]\n  (letfn [(mirror-tree [t]\n                       (if (nil? t)\n                         t\n                         (list (first t) (mirror-tree (second (rest t))) (mirror-tree (first (rest t))))))]\n    (every? true? (map = (flatten tr) (flatten (mirror-tree tr))))))", "user": "547ad587e4b0c51c1f4d72ce"}, {"problem": 96, "code": "(fn treesymmetric [intree]\n  ((fn treeflipequals [tree1 tree2]\n    (or\n      (and (nil? tree1) (nil? tree2))\n      (and (= (first tree1) (first tree2))\n           (treeflipequals (second tree1) (last tree2))\n           (treeflipequals (last tree1) (second tree2))\n      )\n    )\n  ) (second intree) (last intree))\n)", "user": "4fc50bcbe4b081705acca375"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5486adf7e4b0e286459a11be"}, {"problem": 96, "code": "(fn symmetric? \n  ([[value left right]]\n   (let [swap (fn swap [[value left right]] \n                (if (nil? value)\n                  nil\n                  [value (swap right) (swap left)]))\n         left-swapped (swap left)]\n     (symmetric? left-swapped right)))\n  ([[l-value l-left l-right] [r-value r-left r-right]]\n   (if (and (nil? l-value) (nil? r-value))\n     true\n     (and (= l-value r-value)\n          (symmetric? l-left r-left)\n          (symmetric? l-right r-right)))))", "user": "5483d59fe4b0e286459a1194"}, {"problem": 96, "code": "(fn is-symmetry [tree]\n  (let [flip (fn flip [tree]\n               (if (nil? tree) nil\n                   (let [[a b c] tree]\n                     [a (flip c) (flip b)])))\n        [_ a b] tree]\n    (= (flip a) b)))", "user": "5479c58de4b0c51c1f4d72c7"}, {"problem": 96, "code": "#(= %\n\t((fn mirror? [[self l r]]\n\t\t(if self\n        \t[self (mirror? r) (mirror? l)]))\n\t%))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 96, "code": "(fn symmetry [t]\n  (letfn [(mirror? [l r]\n            (cond \n              (or (nil? l) (nil? r)) \n              (= l r)\n              (and (sequential? l) (sequential? r)) \n              (and (= (nth l 0) (nth r 0)) (mirror? (nth l 1) (nth r 2)) (mirror? (nth l 2) (nth r 1)))\n              :else \n              false))]\n    (mirror? (nth t 1) (nth t 2))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 96, "code": "(fn f\n  ([[a b c] [x y z]] (or (= nil a x) (and (= a x) (f c y) (f b z))))\n  ([[_ a x]] (f a x)))", "user": "4fe9de74e4b0547ebccb2475"}, {"problem": 96, "code": "(fn [[id left right]]\n  (letfn [(reverse-tree [[id left right :as node]]\n                       (if (and (nil? left) (nil? right)) node\n                         [id (reverse-tree right) (reverse-tree left)]))]\n                         (= left (reverse-tree right))))", "user": "4f748b54e4b044e54cd9a8fa"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [flip (fn flip [[root left right :as node]]\n    (if (coll? node)\n        [root (flip right) (flip left)]\n        root))]\n    (= left (flip right))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 96, "code": "(fn [[a b c]]\n  (letfn [(r [[a b c]] (if (= a nil) nil [a (r c) (r b)]\n  ))]\n    (= (r b) c)\n  )\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 96, "code": "(fn [t]\n  (let [m        (fn m [t]\n                   (let [[v l r] t]\n                     (if (nil? v)\n                       nil\n                       [v (m r) (m l)])))\n        [v l r]  t ]\n    (= l (m r))))", "user": "52117ea7e4b07aea8afc4f70"}, {"problem": 96, "code": "(letfn [(flip [[value left right :as tree]]\n          (when (not (nil? tree))\n            [value (flip right) (flip left)]))]\n  (fn [[_ left right]]\n    (= left (flip right))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "525b4e8de4b0cb4875a45d0f"}, {"problem": 96, "code": "(fn is-symmetric? [tree]\n  (let [right (clojure.walk/postwalk #(if (coll? %)\n                                       (cons (first %) (reverse (rest %)))\n                                       %)\n                                     (last tree))]\n    (= (second tree) right)))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 96, "code": "(fn [[_ l r]]\n    (letfn [(mirror [t]\n              (when-let [[v l r] t]\n                [v (mirror r) (mirror l)]))]\n      (= l (mirror r))))", "user": "54848141e4b0e286459a119e"}, {"problem": 96, "code": "(fn s [[v l r]]\n\t(or (and (nil? l) (nil? r))\n\t\t(and \n\t\t\t(= (first l) (first r))\n\t\t\t(s [1 (nth l 1) (nth r 2)])\n\t\t\t(s [1 (nth l 2) (nth r 1)]))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 96, "code": "(fn symmetric?[x]\n       (letfn [(mirror [l,r] \n              (if (not-any? coll? [l,r])\n                (= l r)\n                (and (= (first l) (first r ))\n                     (mirror (last l) (second r))\n                     (mirror (second l) (last r))\n                     )))]\n         (and (= 3 (count x))            \n              (mirror (second x) (last x))\n              )\n         ))", "user": "52d66ca0e4b09f7907dd135c"}, {"problem": 96, "code": "#(= ((fn flip [[root left right :as tree]]\n           (when tree\n             [root (flip right) (flip left)])) %) %)", "user": "52e0e646e4b09f7907dd1416"}, {"problem": 96, "code": "(fn symmetric [t]\n  (letfn [(mirror [a b]\n            (or (and (nil? a ) (nil? b)) \n                (let [la (nth a 1) lb (nth b 1) ra (nth a 2) rb (nth b 2)]\n                  (and (= (first a) (first b))\n                       (mirror la rb)\n                       (mirror ra lb)))))]\n    (mirror (nth t 1) (nth t 2))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 96, "code": "(fn [[_ l r]]\n  ((fn mirror? [t1 t2]\n     (cond\n      (not (or (coll? t1) (coll? t2))) true\n      (and (coll? t1) (coll? t2)) (let [[k1 l1 r1] t1, [k2 l2 r2] t2]\n                                    (and (= k1 k2)\n                                         (mirror? l1 r2)\n                                         (mirror? l2 r1)))\n      :else false))\n   l r))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 96, "code": "(fn [coll]\n    (let [vcoll (clojure.walk/postwalk #(if (seq? %) (vec %) %) coll )\n          lb (nth vcoll 1)\n          rb (nth vcoll 2)\n          invertrb (clojure.walk/postwalk #(if (sequential? %) (assoc % 2 (nth % 1) 1 (nth % 2)) % ) rb)]\n      (if (= lb invertrb)\n        true\n        false)\n      )\n    )", "user": "515ebde3e4b01e5d11ccd0a8"}, {"problem": 96, "code": ";; let's just blow the stack for this one..\n(fn [[x y z]]\n  (letfn [(go [[a b c] [d e f]]\n            (if a\n              (and (= a d) (go b f) (go c e))\n              (= a b)))]\n    (and x (go y z))))", "user": "50ef4e2be4b0a78662fa2653"}, {"problem": 96, "code": "(fn symmetric-tree? [t]\n  (letfn [(st [l r]\n            (and (= (first l) (first r))\n                 (or (and (nil? (second l)) (nil? (last r)))\n                     (st (second l) (last r)))\n                 (or (and (nil? (last l)) (nil? (last r)))\n                     (st (last l) (second r)))))]\n    (st (second t) (last t))))", "user": "5188c249e4b0bdff0e072d54"}, {"problem": 96, "code": "(fn symmetric? [[root left right]]\n  (if (and (coll? left) (coll? right))\n    (and\n        (= (nth left 0) (nth right 0))\n        (symmetric? [root (nth left 2) (nth right 1)])\n        (symmetric? [root (nth left 1) (nth right 2)]))\n    (= left right)))", "user": "547e3846e4b0c51c1f4d7302"}, {"problem": 96, "code": "#(= % ((fn mirror [[n l r]]\n         (if n (vector n (mirror r) (mirror l)))) %))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 96, "code": "(fn [t]\n      (let [\n            name (fn [s] (first s))\n            left (fn [s] (second s))\n            right (fn [s] (second (rest s)))\n            sym (fn _s [a, b] (or (and (nil? a) (nil? b)) (and (= (name a) (name b)) (_s (left a) (right b)) (_s (right a) (left b)))))\n            ]\n           (sym (left t) (right t))\n\n           )\n      )", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 96, "code": "#((fn mirror? [x y] \n     (or (and (nil? x) (nil? y))\n         (and \n          (not (nil? x))\n          (not (nil? y))\n          (=       (first  x) (first y)) \n          (mirror? (second x) (last  y))\n          (mirror? (second y) (last  x))\n          )\n         )\n     )\n   % %\n  )", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 96, "code": "(fn s? [[_ l r]]\n  (if (and (coll? l) (coll? r))\n    (let [[lv ll lr] l\n          [rv rl rr] r]\n    \t(and (= lv rv)\n         \t (s? [nil ll rr])\n         \t (s? [nil lr rl])))\n   \t(= l r)))", "user": "4eb5750a535d7eef30807366"}, {"problem": 96, "code": "(fn s? [t]\n  (or (nil? t)\n      (letfn [(refl [t]\n                (if (nil? t) \n                  nil\n                  (list* (first t)\n                         (->> t rest (map refl) reverse))))]\n        (= (nth t 1)\n           (refl (nth t 2))))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 96, "code": "(fn sym-tree? [[v l r]]\n  (let [tree? (fn tree? [x]\n                  (or (nil? x)\n                    (and (sequential? x)\n                         (= 3 (count x))\n                         (tree? (nth x 1))\n                         (tree? (nth x 2)))))\n        \n        swap-tree (fn swap-tree [t]\n                    (if (nil? t)\n                      t\n                      [(first t) (swap-tree (nth t 2)) (swap-tree (nth t 1))]))\n        \n        sym? (fn [l r]\n               (= l (swap-tree r)))]\n    \n    (and (tree? [v l r]) (sym? l r))))", "user": "50b42cbbe4b001349b2f4abe"}, {"problem": 96, "code": "(fn mirror-tree? [[_ l r]]\n  (letfn [(mirror [tree]\n            (when-let [[n l r] tree]\n              [n (mirror r) (mirror l)]))]\n    (= l (mirror r))))", "user": "54ae541ae4b09f271ff37cef"}, {"problem": 96, "code": "(fn sym? [col]  (letfn [(m [c] (map #(if (sequential? %) (m %) % ) (cons (first c) (reverse (rest c)) )))] (= col (m col))) )", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 96, "code": "(fn symm? [t]\n  (let [[n l r] t]\n    (if (every? nil? [l r])\n      true\n      (let [[n1 l1 r1] l\n            [n2 l2 r2] r]\n        (and (= n1 n2) (symm? [n1 l1 r2]) (symm? [n2 l2 r1]))))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "4fecebe1e4b0681fd128dcac"}, {"problem": 96, "code": "(fn symmetrical? [tree]\n  (letfn [(flip [tree]\n           (if (nil? tree)\n             nil\n             (list (nth tree 0)\n                   (if (nil? tree) nil (flip (nth tree 2)))\n                             (if (nil? tree) nil (flip (nth tree 1))))))]\n  (= tree (flip tree))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 96, "code": "(fn [t]\n(= t\n ((fn rvs [[e & ch]]\n  (cons\n   e\n   (reverse\n    (map\n     #(if (sequential? %) (rvs %)\n                          %)\n     ch)))) t)))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 96, "code": "#(=\n((fn a [t] (if (sequence t) (conj [] (first t) (map a (rest t))) t)) %)\n((fn b [t] (if (sequence t) (conj [] (first t) (map b (reverse (rest t)))) t)) %))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 96, "code": "#(letfn [\n          (eq? [v w]\n            (case [(coll? v) (coll? w)]\n              [true true]   (let [[a1 b1 c1] v [a2 b2 c2] w]\n                              (and (= a1 a2)(and (eq? b1 c2) (eq? c1 b2)))\n                            )  \n              [true false]  false\n              [false true]  false\n              [false false] (= v w)\n            )\n          )\n        ]\n             \n   (eq? (second %)(last %))\n )", "user": "545537c1e4b0e397800069dd"}, {"problem": 96, "code": "(fn symtree?\n  ([tree]\n    (symtree? (second tree) (last tree)))\n  ([l r]\n    (if\n      (or\n        (not (coll? l))\n        (not (coll? r)))\n      (= l r)\n      (and\n        (= (first l) (first r))\n\t(symtree? (second l) (last r))\n\t(symtree? (last l) (second r)))\n      )))", "user": "54bad522e4b0ed20f4ff6eb8"}, {"problem": 96, "code": "#((fn s [r l] (or (= nil r l) \n                  (and (= (first r) (first l))\n                       (s (second r) (nth l 2)) \n                       (s (nth r 2) (second l))))) (second %) (nth % 2))", "user": "52a267c6e4b04e0c58e87bef"}, {"problem": 96, "code": "(fn symm? [root]\n  (letfn [(mirror [r]\n            (if (nil? r)\n              nil\n              [(first r)\n               (mirror (last r))\n               (mirror (second r))]))]\n    (= (second root) (mirror (last root)))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 96, "code": "(fn sym [[_ l r]]\n  (let [rot (fn rot [t]\n    (if (not (coll? t))\n      t\n      [(first t) \n       (rot (nth t 2)) \n       (rot (second t))]))]\n    (= l (rot r))))", "user": "54b95f3de4b0ed20f4ff6eab"}, {"problem": 96, "code": "(fn sym\n  ([[v left right]]\n   (sym left right))\n  ([[v1 left1 right1] [v2 left2 right2]]\n   (if (or (nil? v1) (nil? v2))\n     (and (nil? v1) (nil? v2))\n     (and (= v1 v2) (sym left1 right2) (sym right1 left2)))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 96, "code": "(fn is-symmetric? [[root left-half right-half]]\n  (letfn [(is-mirror? [lb rb]\n     (or (= nil lb rb)\n         (and\n          (= (first lb) (first rb))\n          (is-mirror? (second lb) (last rb))\n          (is-mirror? (last lb) (second rb))))\n                      )]\n                      (is-mirror? left-half right-half)))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 96, "code": "(fn s [xs] (= xs ((fn q [xs] (let [[c l r] xs] (if (= c nil) c (list c (q r) (q l))))) xs)))", "user": "54ab502fe4b09f271ff37cc4"}, {"problem": 96, "code": "#(= % ((fn m [[v l r]] (if v [v (m r) (m l)])) %))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 96, "code": "(fn __ [t]\n  (letfn [(mirror [l r]\n                  (or (and (nil? l) (nil? r))\n                      (and (not (nil? l))\n                           (not (nil? r))\n                           (= (first l) (first r))\n                           (mirror (second l) (second (rest r)))\n                           (mirror (second (rest l)) (second r)))))]\n\t(mirror (second t) (second (rest t)))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 96, "code": "(fn [[root root-left root-right]]\n  (let\n    [is-mirror?  (fn is-mirror? [left right]\n                   (cond\n                     (not= (coll? left) (coll? right)) false\n                     (coll? left) (let [[left-val left-left left-right] left\n                                        [right-val right-left right-right] right]\n                                        (and (= left-val right-val) \n                                             (is-mirror? left-left right-right) \n                                             (is-mirror? right-left left-right)))\n                     :else (= left right))\n                 )]\n    (is-mirror? root-left root-right)\n  ))", "user": "546692aee4b01be26fd746e7"}, {"problem": 96, "code": "(fn tree-is-symmetric\n  [tree]\n  ((fn trees-are-symmetric?\n     [[t1v t1c1 t1c2] [t2v t2c1 t2c2]]\n     (and\n      (= t1v t2v)\n      (if (coll? t1c1)\n        (trees-are-symmetric? t1c1 t2c2)\n        (= t1c1 t2c2))\n      (if (coll? t1c2)\n        (trees-are-symmetric? t1c2 t2c1)\n        (= t1c2 t2c1)))) (nth tree 1) (nth tree 2)))", "user": "53b952eee4b047364c0444e6"}, {"problem": 96, "code": "(fn [[_ l r]]\n  ((fn sym? [n1 n2]\n   (if (and (nil? n1) (nil? n2))\n     true\n     (and\n       (= (nth n1 0) (nth n2 0))\n       (sym? (nth n1 1) (nth n2 2))\n       (sym? (nth n1 2) (nth n2 1))))\n   ) l r))", "user": "534bfc71e4b084c2834f4a88"}, {"problem": 96, "code": "(fn is-sym [tree]\n       (= tree\n          ((fn mirror [arg]\n             (if (nil? arg)\n               nil\n               (let [[root left right] arg]\n                 (list root (mirror right) (mirror left)))))\n       tree)))", "user": "54c169ade4b0ed20f4ff6f24"}, {"problem": 96, "code": "(fn q[t]\n    (let [w\n          (fn w[a b]\n            (or \n              (and (nil? a) (nil? b)) \n              (and (coll? a) (coll? b) (= (first a) (first b)) (w (second a) (last b)) (w (second b) (last a)))\n              )   \n            )   \n          ]   \n      (w (second t) (last t)) \n      )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 96, "code": ";; checks if tree is symmetric\n(fn symm-tree? [[_ left right]]\n  (let [symmetric?\n        (fn symmetric? [[ra La Ra :as a]  [rb Lb Rb :as b]]\n          (or (= nil a b)\n              (and (= ra rb) (symmetric? La Rb) (symmetric? Ra Lb))))]\n    (symmetric? left right)))", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 96, "code": "(letfn [(mirror [tree]\n                (if (nil? tree)\n                  nil\n                  (let [[v l r] tree]\n                    [v (mirror r) (mirror l)])))]\n  (fn symmetric-tree? [tree]\n    (= tree (mirror tree))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 96, "code": "(let [eq (fn eq [l r] (or (and (= l nil) (= r nil))\n                          (let [[lv ll lr] l\n                                [rv rl rr] r]\n                            (and (= lv rv) (eq ll rr) (eq lr rl)))))\n      ]\n  (fn [n] (or (= n nil) (let [[_ l r] n] (eq l r)))))", "user": "54c641f8e4b045293a27f628"}, {"problem": 96, "code": "(fn [[h l r]] \n  (letfn [(helper [[h1 l1 r1] [h2 l2 r2]]\n                  (cond (and h1 h2)\n                        (and (= h1 h2) (helper l1 r2) (helper r1 l2))\n                        \n                        (or h1 h2)\n                        false\n                        \n                        :else\n                        true))]\n    (helper l r)))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 96, "code": "(fn tree-sym?\r\n  ([[_ l r]]\r\n    (tree-sym? l r))\r\n  ([l r]\r\n    (if (or (nil? l) (nil? r))\r\n      (and (nil? l) (nil? r))\r\n      (if (= (first l) (first r))\r\n        (and\r\n          (tree-sym? (second r) (nth l 2))\r\n          (tree-sym? (second l) (nth r 2)))\r\n        false))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 96, "code": "(fn is-symmetric? \n  ; entry point\n  ([sq] (is-symmetric? (second sq) (nth sq 2)))\n  ; recursion\n  ([lhs rhs]\n    (cond\n     (= nil lhs rhs) true\n     (and (coll? lhs) (nil? rhs)) false\n     (and (coll? rhs) (nil? lhs)) false\n     :else\n      (let [node1 (first lhs),  left1 (second lhs),   right1 (nth lhs 2)\n            node2 (first rhs),  left2 (second rhs),   right2 (nth rhs 2)]\n        (and (= node1 node2) ; both nodes are equal AND:\n             (and (is-symmetric? left1 right2) ; \"outer\" symmetry\n                  (is-symmetric? left2 right1) ; \"inner\" symmetry\n))))))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 96, "code": "(fn f [tree] \n  (letfn [(mirror [[v l r :as tree]]\n             (if (nil? tree)\n                 tree\n                 (vector v (mirror r) (mirror l))))]\n    (= (mirror tree) tree)))", "user": "5493d908e4b0b312c081ff52"}, {"problem": 96, "code": "(fn [[n l r]]\n  (= l ((fn f [[n l r]]\n\t  (if n [n (f r) (f l)]))\n\tr)))", "user": "54d70f40e4b0a52adc2e2027"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (= (map first (tree-seq #(not (nil? %)) #(rest %) l))\n     (map first (tree-seq #(not (nil? %)) #(reverse (rest %)) r))))", "user": "52ab51c4e4b0c58976d9ac73"}, {"problem": 96, "code": "(fn [t]\n  (= t ((fn reflect [[n l r :as t]]\n          (if (nil? t) t [n (reflect r) (reflect l)])) t)))", "user": "5383668ee4b06839e8705edd"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [  (mirror [x]\n              (if-not (coll? x)\n                x\n                (let [ [h l r] x ]\n                  (list h (mirror r) (mirror l)) ))) ]\n      (if-not (coll? tree)\n        true\n        (let [ [h l r] tree ]\n          (= l (mirror r))))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 96, "code": "(fn [col]\n(let [q (fn q [col1 col2]\n  (cond (and (nil? col1) (nil? col2)) true\n        (or  (nil? col1) (nil? col2)) false\n        (and (vector? col1) (vector? col2)) (and (q (nth col1 2) (second col2))\n                                                 (q (second col1) (nth col2 2))\n                                                 (= (first col1) (first col2)))\n        :else                         (= col1 col2)))]\n  (q (nth col 1) (nth col 2))))", "user": "53664e3be4b0243289761e74"}, {"problem": 96, "code": "(fn [[_ a b]]\n    (let [mirror (fn mirror [t]\n\t\t     \t\t(if-not (coll? t)\n\t\t\t     \t\tt\n\t\t\t     \t\t(let [[h l r] t]\n\t\t\t       \t\t\t[h \n\t\t\t\t\t\t\t (mirror r) \n\t\t\t\t\t\t\t (mirror l)])))]\n      (= a (mirror b))))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 96, "code": "(fn [t]\n  (let [left (map first (tree-seq coll? rest (nth t 1)))\n        right (map first (tree-seq coll? #(reverse (rest %)) (nth t 2)))]\n    (= left right)))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "51e8ee6be4b07cae92c04bfd"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(mirrors? [[l-value l-left l-right :as left] [r-value r-left r-right :as right]]\n                    (or (and (nil? left) (nil? right))                                                \n                        (and\n                         (= l-value r-value)\n                         (mirrors? l-left r-right)\n                         (mirrors? l-right r-left))))]\n    (mirrors? left right)))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 96, "code": "(fn [[t l r]]\n   (letfn [(ra [[t l r]](vector t (n r) (n l)))\n           (n [v] (if (nil? v) v (ra v)))]\n     (if (= l (ra r)) true false)))", "user": "51a058dae4b0b292b01ee3f3"}, {"problem": 96, "code": "(fn balanced? [t]\n  (letfn [(mirror [[v l r]]\n            (when v\n              (list v (mirror r) (mirror l))))]\n    (let [[_ l r] t]\n      (= l (mirror r)))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 96, "code": "(fn sym-bn [xs]\n  (let [[_ [l-root l-left l-right] [r-root r-left r-right]] xs]\n    (letfn [(eq [l r] (if (or (sequential? l) (sequential? r))\n                        (sym-bn [_ l r])\n                        (= l r)))]\n      (and (eq l-root r-root) (eq l-left r-right) (eq l-right r-left)))))", "user": "52d84ea7e4b09f7907dd1390"}, {"problem": 96, "code": "(fn [tree]\n  (let [start (fn bis [n1 n2]\n                (if (and\n                     (= (count n1) 3)\n                     (= (count n2) 3)\n                     (= (nth n1 0) (nth n2 0)))\n                  (cond\n                   (and (every? nil? (rest n1)) (every? nil? (rest n2))) true\n                   (and (nil? (nth n1 1)) (nil? (nth n2 2))\n                        (sequential? (nth n1 2)) (sequential? (nth n2 1)))\n                   (bis (nth n1 2) (nth n2 1))\n                   (and (nil? (nth n1 2)) (nil? (nth n2 1))\n                        (sequential? (nth n1 1)) (sequential? (nth n2 2)))\n                   (bis (nth n1 1) (nth n2 2))\n                   :else (and (bis (nth n1 1) (nth n2 2))\n                              (bis (nth n1 2) (nth n2 1))))\n                  false))]\n    (start (nth tree 1) (nth tree 2))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 96, "code": "(fn mirror-tree?\n  ([[_ left right]] \n    (mirror-tree? left right))\n  ([t1 t2]\n    (or \n      (and (nil? t1) (nil? t2))\n      (let [[v1 l1 r1] t1\n            [v2 l2 r2] t2]\n        (and (= v1 v2) \n             (mirror-tree? l1 r2)\n             (mirror-tree? r1 l2))))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 96, "code": "#(= ((fn mirror [[value left right :as tree]] (when tree [value (mirror right) (mirror left)])) %) %)", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 96, "code": "(fn [[x a b]] (= a ((fn m [t] (when-let [[a l r] t] [a (m r) (m l)]))\n b)))", "user": "5368fedee4b0243289761e93"}, {"problem": 96, "code": "(fn prob96\n  ([s] (prob96 (nth s 1) (nth s 2)))\n  ([s1 s2]\n   (if (and (coll? s1) (coll? s2))\n     (and\n      (= (first s1) (first s2))\n      (prob96 (nth s1 1) (nth s2 2))\n      (prob96 (nth s1 2) (nth s2 1)))\n     (= s1 s2))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 96, "code": "(fn symmetric\n  ([tree]\n  (symmetric (nth tree 2) (second tree)))\n  ([left right]\n   (if (or (nil? left) (nil? right))\n     (= left right)\n     (and (= (first left) (first right)) (symmetric (second left) (nth right 2)) (symmetric (nth left 2) (second right))))))", "user": "54e0e911e4b024c67c0cf7bc"}, {"problem": 96, "code": "(fn bb? [nd]\n    (let [m (fn mr [p]\n                (if (nil? p)\n                    nil\n                  (let [[n l r] p]\n                    (list n (mr r) (mr l)))))\n            [n l r] nd]\n      (if (not= (count nd) 3)\n          false\n        (= l (m r)))))", "user": "534e4a29e4b084c2834f4ab0"}, {"problem": 96, "code": "(fn s?\n  ([[_ l r]] (s? l r))\n  ([l r] (or (and (nil? l) (nil? r))\n             (and (coll? l) (coll? r)\n                  (= (first l) (first r))\n                  (s? (second l) (last r))\n                  (s? (last l) (second r))))))", "user": "54ddb556e4b024c67c0cf798"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(mirror? [left right]\n            (if (or (= nil left right)\n                    (and (= (first left) (first right))\n                         (mirror? (second left) (last right))\n                         (mirror? (last left) (second right))))\n              true false))]\n    (mirror? (second tree) (last tree))))", "user": "52474133e4b05ef8e38e635e"}, {"problem": 96, "code": "(fn [[h l r]] (letfn [(j [[a b c] [d e f]]\n                    (and (= a d)\n                         (if  a (and\n                              (j b f)\n                              (j c e)) true)))]\n                (j l r)))", "user": "524025bce4b0ad64fa01030f"}, {"problem": 96, "code": "(fn mirror-tree?\n  ([a] (mirror-tree? (second a) (nth a 2)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (and (= (first a) (first b))\n                (mirror-tree? (second a) (nth b 2))\n                (mirror-tree? (nth a 2) (second b))))))", "user": "547fbe01e4b0c51c1f4d7321"}, {"problem": 96, "code": "(fn tree-eq [t]\n  (letfn [(tree-eq' [t1 t2]\n            (cond\n              ;; If both are nil they are equal\n              (and (nil? t1)\n                   (nil? t2))\n              true\n\n              ;; If the data parts don't match they aren't equal\n              (not (= (first t1)\n                      (first t2)))\n              false\n\n              ;; If they have different child nodes the are not equal\n              (not\n               (= (count t1)\n                  (count t2)))\n              false\n\n              :else\n              (and\n               (reduce #(and %1 %2) (map tree-eq' (rest t1) (reverse (rest t2)))))))]\n    (tree-eq' (nth t 1)\n              (nth t 2))))", "user": "532b43c3e4b09d4e7a9b5531"}, {"problem": 96, "code": "#(let [g (fn f [x i j]\n              (if (coll? x)\n                (concat [(nth x 0)]\n                        (f (nth x i) i j)\n                        (f (nth x j) i j))\n                [x]))]\n    (= (g % 1 2) (g % 2 1)))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 96, "code": "(fn [[_ a b]]\n  (letfn [(f [[av al ar] [bv bl br]]\n            (and (= av bv)\n                 (or (and (nil? al) (nil? br))\n                     (and (not (nil? al)) (not (nil? br)) (f al br)))\n                 (or (and (nil? ar) (nil? bl))\n                     (and (not (nil? ar)) (not (nil? bl)) (f ar bl)))))]\n    (f a b)))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 96, "code": "(fn st[t]\n  (letfn [(rt [tr]\n            (if(nil? tr) \n              nil\n              (vector (first tr)(rt (last tr))(rt (second tr)))))]\n    (= (second t) (rt (last t)))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 96, "code": "(fn is-mirror\n  [[v l r]]\n  (letfn [(are-mirrors\n            [[v1 l1 r1] [v2 l2 r2]]\n            (cond\n              (and (nil? v1) (nil? v2))  true\n              (not= v1 v2) false\n              :else (and (are-mirrors l1 r2) (are-mirrors r1 l2))))]\n    (if (nil? v) true (are-mirrors l r))))", "user": "518ba795e4b0f028e99addf0"}, {"problem": 96, "code": "(fn sym? [t]\n  (let [reverse-tree (fn reverse-tree [x] \n                        (if (coll? x)\n                          (let [[root left right] x]\n                           [root (reverse-tree right) (reverse-tree left)]\n                          )\n                          x))\n        [root left right] t]\n    (= left (reverse-tree right))))", "user": "54b050cee4b09f271ff37d13"}, {"problem": 96, "code": "(fn [[_ n1 n2]]\n  (let [rev (fn rv [tree]\n              (if (sequential? tree)\n                (vector (first tree) (rv (nth tree 2)) (rv (nth tree 1)))\n                tree))]\n    (= n1 (rev n2))))", "user": "5463c824e4b01be26fd746c5"}, {"problem": 96, "code": "(fn [[_ left-tree right-tree]]\n  (let [symmetric? (fn symmetric? [[lval lleft lright] [rval rleft rright]]\n                                  (if lval\n                                    (and (= lval rval)\n                                         (symmetric? lleft rright)\n                                         (symmetric? lright rleft))\n                                    true))]\n    \n    (symmetric? left-tree right-tree)))", "user": "54485727e4b032a45b8693c6"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (let [value?  #(or\n                   (nil? %)\n                   (number? %)\n                   (keyword? %))\n        root    #(first %)\n        left    #(nth % 1)\n        right   #(nth % 2)\n        mirror? (fn mirror? [t1 t2]\n                  (or (and (value? t1) (value? t2) (= t1 t2))\n                      (and (= (root t1) (root t2))\n                           (mirror? (left t1) (right t2))\n                           (mirror? (right t1) (left t2)))))]\n    (or (value? t)\n      (and (or (vector? t) (seq? t))\n           (= 3 (count t))\n           (value? (first t))\n           (mirror? (left t) (right t))))))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "51c1b644e4b0d204dbe2ca12"}, {"problem": 96, "code": "(fn [tree] \n  (letfn [(reverse-tree [[parent left right]] \n    [parent\n     (if (coll? right) (reverse-tree right) right)\n\t\t (if (coll? left) (reverse-tree left) left)])]\n     (= (second tree)\n\t\t(reverse-tree (nth tree 2)))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 96, "code": "(fn [[a b c]]\n  (letfn [(flip [x]\n            (if (sequential? x)\n              (let [[r l s] x]\n                [r (flip s) (flip l)])\n              x))]\n    (= b (flip c))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 96, "code": "(fn mirror-tree? [[_ l r]]\n  (or (and (nil? l) (nil? r))\n      (and (= (first l) (first r))\n           (mirror-tree? [_ (second l) (last r)])\n           (mirror-tree? [_ (last l) (second r)]))))", "user": "54fdbe3fe4b07d26eda61d3b"}, {"problem": 96, "code": "(fn is-symmetric [[root left right]] \n  (let [flip (fn flip [tree]\n               (if (nil? tree) \n                 tree\n                 (let [[r a b] tree]\n                   [r (flip b) (flip a)])))]\n    (= left (flip right))))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 96, "code": "(fn isSTree\n  [x]\n  (let [mirrorImage (fn mirrorImage [left right]\n                      (cond\n                       (and (nil? left) (nil? right)) true\n                       (or (nil? left) (nil? right)) false                                                                    \n                       (not= (first left) (first right)) false\n                       :else (and (mirrorImage (nth left 1) (nth right 2))\n                                   (mirrorImage (nth left 2) (nth right 1)))))]\n  (if (nil? x)\n    true\n    (mirrorImage (nth x 1) (nth x 2)))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 96, "code": "(fn mirror? \n  ([tree] (or (-> tree coll? not) (mirror? (second tree) (nth tree 2))))\n  ([left right] \n   (if (and (coll? left) (coll? right))\n     (and (= (first left) (first right))\n          (mirror? (second left) (nth right 2)) \n          (mirror? (nth left 2) (second right))\n          )\n     (= left right)\n     )\n   )\n  )", "user": "525d490ae4b0cb4875a45d70"}, {"problem": 96, "code": "(letfn [(walk [tree] \n              (if (nil? tree) []\n                (concat (walk (second tree)) [(first tree)] (walk (last tree)))))]\n  (fn [tree]\n    (let [nodes (walk tree)\n          size (/ (count nodes) 2)]\n      (= (take size nodes) (take size (reverse nodes))))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 96, "code": "(fn [[_ l r]] ((fn f [t1 t2] (or (and (nil? t1) (nil? t2)) (let [[n1 l1 r1] t1 [n2 l2 r2] t2] (and (= n1 n2) (f l1 r2) (f r1 l2))))) l r))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 96, "code": "(fn sym? [[_ [lv ll lr :as l] [rv rl rr :as r]]]\n  (if (or (nil? l) (nil? r))\n    (and (nil? l) (nil? r))\n    (and (= lv rv)\n         (sym? [nil ll rr])\n         (sym? [nil lr rl]))))", "user": "4db599e6535d87e67b28fe11"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 96, "code": "#(loop [a (rest %)]\n   (let [x (map first a) y (reverse x)]\n     (cond (every? nil? x) true\n           (= x y) (recur (mapcat rest a))\n           :else false)))", "user": "54e2a779e4b024c67c0cf7d3"}, {"problem": 96, "code": "(fn is-mirrored [tree]\n  (= (second tree) ((fn mirror [elem]\n  (if (coll? elem)\n    (list (first elem) (mirror (last elem)) (mirror (second elem)))\n\telem)) (last tree))))", "user": "51eec1a6e4b0871fa145d98d"}, {"problem": 96, "code": "#(let [\n\tpalin (fn palin [x] (let [n (count x)] (if (< n 2) true (and (= (first x) (last x)) (palin (take (- n 2) (drop 1 x)))))))\n\tprefix (fn prefix [x] (if (= nil x) [nil] (let [[v l r] x] (concat (prefix l) [v] (prefix r)))))\n] (palin (prefix %)))", "user": "550e0373e4b06e50f9beb162"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "54bcab07e4b0ed20f4ff6ed5"}, {"problem": 96, "code": "(fn sym-tree? [[_ left right :as tree]]\n  (let [mirror (fn mirror [[v l r :as t]] (if (nil? t) nil (list v (mirror r) (mirror l))))]\n    (or (nil? tree)\n        (= left (mirror right)))))", "user": "54eea988e4b024c67c0cf875"}, {"problem": 96, "code": "(letfn [(mir [[v l r :as t]]\n          (when (seq t)\n            (list v (mir r) (mir l))))]\n  (fn [[_ a b]] (= a (mir b))))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": 96, "code": "#((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false))\n   (second %) (last %))", "user": "544e8369e4b0e39780006987"}, {"problem": 96, "code": "#(letfn [(sim [n1 n2]\n             (or (and (nil? n1) (nil? n2))\n                 (and (= (first n1) (first n2))\n                      (sim (second n1) (nth n2 2))\n                      (sim (nth n1 2) (second n2)))))]\n   (apply sim (next %)))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 96, "code": "#(= %\n\t((fn sym [[raiz izq der :as t]]\n       (when t [raiz (sym der) (sym izq)] )) %))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 96, "code": "(fn sym? [coll]\n  (let [root  (fn [col] (first col))\n        left  (fn [col] (second col))\n        right (fn [col] (nth col 2))\n        l2r \n          (fn l2ri [col]\n            (vector \n              (root col) \n              (if (coll? (right col)) \n                (l2ri (right col)) \n                (right col))\n              (if (coll? (left col))\n                (l2ri (left col))\n                (left col))))]\n    (= (nth coll 1) (l2r (nth coll 2)))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 96, "code": "(fn sym? \n  ([t] (sym? (nth t 1) (nth t 2)))\n  ([l r] \n    (or \n      (and (nil? l) (nil? r))\n      (and (= (first l) (first r))\n           (sym? (nth l 1) (nth r 2))\n           (sym? (nth l 2) (nth r 1))))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 96, "code": "(fn [[root left right]]\n  (letfn [(mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 96, "code": "(fn [t]\n    (let [left-tree (fn [t]\n                      (nth t 1))\n          right-tree (fn [t]\n                       (nth t 2))\n          head first\n          tree (fn [h lt rt]\n                 (vector h lt rt))\n          reverse-tree (fn reverse-tree [t]\n                         (if (not (coll? t))\n                           t\n                           (tree (head t)\n                                 (reverse-tree (right-tree t))\n                                 (reverse-tree (left-tree t)))))]\n      (= (left-tree t)\n         (reverse-tree (right-tree t)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 96, "code": "#(cond\n  (empty? %) true\n  (not= (count %) 3) false\n  true (letfn [(mirror [t]\n                       (if (empty? t)\n                         t\n                         [(first t)\n                          (mirror (nth t 2))\n                          (mirror (second t))]))]\n         (= % (mirror %))))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 96, "code": "#(= %\n    ((fn rev [[p l r :as b]]\n       (when b\n         [p (rev r) (rev l)]))\n     %))", "user": "4ee7d6d8535d93acb0a66870"}, {"problem": 96, "code": "(fn traverse\n  ([node]\n   (let [leftwise  (fn leftwise [[value left right] acc] (conj acc value (traverse leftwise left) (traverse leftwise right)))\n         rightwise (fn rightwise [[value left right] acc] (conj acc value (traverse rightwise right) (traverse rightwise left)))]\n     (= (traverse leftwise node) (traverse rightwise node))\n     ))\n  ([f node] (traverse f node []))\n  ([f node acc] (if node (f node acc) nil))\n  )", "user": "5312cdaae4b08068f379ed03"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (loop [[[l-root l-left l-right :as l] & more-left :as left] [(second t)],\n         [[r-root r-left r-right :as r] & more-right :as right] [(last t)]]\n    (cond\n      (empty? left)         (empty? right)\n      (empty? right)        (empty? left)\n      (empty? l)            (if (empty? r) (recur more-left more-right) false)\n      (empty? r)            (if (empty? l) (recur more-left more-right) false)\n      (not= l-root r-root)  false\n      :else                 (recur (conj more-left l-left l-right)\n                                   (conj more-right r-right r-left)))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 96, "code": "(fn f [x]\n  (letfn [(revtree [y] (if (nil? y) nil [(first y) (revtree (nth y 2)) (revtree (second y))]))]\n    (= x (revtree x))\n  )\n)", "user": "55280930e4b0ffed3738f93b"}, {"problem": 96, "code": "#(letfn [(g [x] (if (nil? x) x (list (first x) (g (last x)) (g (second x)))))]\n    (= (second %)(g (last %))))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirrored? [left right]\n    (if-not (and (sequential? left) (sequential? right))\n      (= left right)\n      (let [[root1 left1 right1] left\n            [root2 left2 right2] right]\n        (and (= root1 root2) (mirrored? left1 right2) (mirrored? right1 left2)))))]\n    (mirrored? l r)))", "user": "505345d9e4b0517ede0d0a06"}, {"problem": 96, "code": "(letfn [(mirror? [a b]\n           (cond (and (nil? a) (nil? b)) true\n                 (or (nil? a) (nil? b)) false\n                 :else (let [[a0 a1 a2] a [b0 b1 b2] b]\n                         (and (= a0 b0)\n                              (mirror? a1 b2)\n                              (mirror? a2 b1)))))]\n  (fn [t] (if-let [[_ a b] t] (mirror? a b) true)))", "user": "55253217e4b0882d96d091ce"}, {"problem": 96, "code": "(fn symetric? [tree]\n    (letfn [(in-order [t]\n        (cond \n            (nil? t) [nil]\n            :else (concat (in-order (second t)) [(first t)] (in-order (nth t 2)))))]\n    (let [in-order-lst (in-order tree)]\n        (= in-order-lst (reverse in-order-lst)))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 96, "code": "#(let \n      [mirror? \n       (fn mirror? [t1 t2] \n         (cond \n          (not= (coll? t1) (coll? t2)) \n          false\n          (coll? t1)\n          (and (= 3 (count t1))\n               (= 3 (count t2))\n               (let [[v1 l1 r1] t1 [v2 l2 r2] t2]\n                 (and \n                  (= v1 v2)\n                  (mirror? l1 r2)\n                  (mirror? r1 l2)\n                  )\n                 )\n               )\n          :else\n          (= t1 t2)\n          )) \n       [r tl tr]\n       %] \n\n    (mirror? tl tr))", "user": "55249f64e4b0882d96d091c6"}, {"problem": 96, "code": "(fn [root]\n  (letfn [(transpose [[value left right :as node]]\n             (if (seq node)\n           \t   [value (transpose right) (transpose left)]))]\n    (= root (transpose root))))", "user": "546ed28be4b00cfc9eacc1a5"}, {"problem": 96, "code": "(fn bis [[val left-tree right-tree]]\n  (let [sym? (fn sym? [lt rt]\n               (cond \n                 (not= (sequential? lt) (sequential? rt)) false\n                 (sequential? lt) (let [[vlt Llt Rlt] lt\n                                        [vrt Lrt Rrt] rt]\n                                    (and (= vlt vrt) (sym? Llt Rrt) (sym? Rlt Lrt)))\n                 :else (= lt rt)))]\n    (sym? left-tree right-tree)))", "user": "5414b7c4e4b01498b1a719ed"}, {"problem": 96, "code": "(fn mirror? [[v l r]]\n  (letfn [(mirror [[v' l' r' :as t]]\n                  (if (nil? t)\n                    t\n                    [v' (mirror r') (mirror l')]))]\n    (= l (mirror r))))", "user": "54d127b7e4b0e8a36923e5de"}, {"problem": 96, "code": "(fn [[_ sub1 sub2 :as tree]]\n  (and\n   ((fn is-tree? [[v c1 c2 :as args]]\n    (if (not= 3 (count args))\n      false\n      (and\n        (or (nil? c1) (and (coll? c1) (is-tree? c1)))\n        (or (nil? c2) (and (coll? c2) (is-tree? c2)))))) tree)\n   (= sub1 \n      ((fn mirror [[v c1 c2 :as args]]\n        (if (nil? args)\n          nil\n          [v (mirror c2) (mirror c1)])) sub2))))", "user": "5522cd9ae4b0882d96d091ab"}, {"problem": 96, "code": "#(= %\n    ((fn ! [[a b c]]\n       [a (if (coll? c) (! c) c)\n        (if (coll? b) (! b) b)]) %))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 96, "code": "(fn symmetric? \n    ([tree] (symmetric? (second tree) (last tree)))\n    ([l r]\n        (cond\n            (and (nil? l) (nil? r)) true\n            (not (and (coll? l) (coll? r))) false\n            (and (= (count l) (count r) 3)\n                 (= (first l) (first r))\n                 (symmetric? (second l) (last r))\n                 (symmetric? (last l) (second r))) true\n            :else false)))", "user": "553706d1e4b09218d5f44fc7"}, {"problem": 96, "code": "(let [mirror? (fn m? [l r]\n                  (or (and (empty? l) (empty? r))\n                      (let [[lhead lleft lright] l\n                            [rhead rleft rright] r]\n                        (and (= lhead rhead)\n                             (m? lleft rright)\n                             (m? lright rleft)))))]\n    (fn symmetric? [[head left right]]\n      (mirror? left right)))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 96, "code": "(fn [[value left right]]\n  (letfn [(mirror? [a b]\n                   (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[root-a left-a right-a] a\n                                          [root-b left-b right-b] b]\n                                      (and (= root-a root-b) (mirror? left-a right-b) (mirror? left-b right-a)))\n                    :else (= a b)))]\n    (mirror? left right)))", "user": "5152bc4ee4b001f44f99bfef"}, {"problem": 96, "code": "(fn [t]\n  (let [check-binary (fn cb [t]\n                       (if (coll? t)\n                         (let [[v l r] t]\n                           (and (not (nil? v))\n                                (= 3 (count t))\n                                (cb l)\n                                (cb r)))\n                         (nil? t)))\n        make-mirror (fn mm [n]\n                      (if (coll? n)\n                        (let [[v l r] n]\n                          [v (mm r) (mm l)])\n                        n))]\n    (and (check-binary t)\n         (let [[_ l r] t]\n           (= (make-mirror l) r)))))", "user": "51a7fe50e4b08d8ec191b803"}, {"problem": 96, "code": "(fn [xs] (case (count (flatten xs)) 7 (#((fn t [l r] (if (nil? l) true (if (not= (first l) (first r)) false (t (second l) (second r))))) (second %) (last %)) xs) 23 (#(if (= 6 (nth (flatten %) 16)) true false) xs) false))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 96, "code": "(letfn\n  [(flip [t]\n         (if (nil? t) t\n           (let [[v x y] t]\n             [v (flip y) (flip x)])))]\n  #(= % (flip %)))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 96, "code": "(fn [tree] (= (map first (tree-seq coll? rest tree))\n              (map first (tree-seq coll? #(reverse (rest %)) tree))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 96, "code": "(fn balanced? [t]\n  (letfn [(not-nil? [x] (not (nil? x)))\n          (left  [t] (second t))\n          (right [t] (nth t 2))\n          (mirrors? [t1 t2]\n                    (println \"mirrors? \" t1 t2)\n                    (or (and (nil? t1) (nil? t2))\n                        (and (not-nil? t1)\n                             (not-nil? t2)\n                             (= (first t1) (first t2))\n                             (mirrors? (left t1) (right t2))\n                             (mirrors? (right t1) (left t2)))))]\n    (or (nil? t) (mirrors? (left t) (right t)))))", "user": "553dd883e4b0a04f792994e6"}, {"problem": 96, "code": "(fn [[_ b c]]\n           (= b (clojure.walk/postwalk \n                  #(if (sequential? %)\n                    (let [[a b c] %]\n                      [a c b])\n                    %) \n                  c)))", "user": "530b8580e4b02e82168697cc"}, {"problem": 96, "code": "(fn sym-tree? [tree]                                                                                                                                                    \n  (letfn [(symmetric-tree? [[lv ll lr] [rv rl rr]]                                                                                                                        \n            (cond                                                                                                                                                         \n              (and (nil? lv) (nil? rv)) true                                                                                                                              \n              (= lv rv) (and (symmetric-tree? ll rr)                                                                                                                      \n                             (symmetric-tree? lr rl))                                                                                                                     \n              :else false))]                                                                                                                                              \n    (let [[v l r] tree]                                                                                                                                                   \n      (symmetric-tree? l r))))", "user": "50f02de7e4b0bdaecbb47db0"}, {"problem": 96, "code": "#(= % ((fn mirror [[v l r]]\n         [v\n          (if r (mirror r))\n          (if l (mirror l))]) %))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [sx]\n  (letfn [ (equal-tree?\n             [[a1 b1 c1 :as a] [a2 b2 c2 :as b]]\n             (if (= a1 a2)\n               (cond\n                (= 4 (count  (filter #(nil? %) [b1 c1 b2 c2]))) true\n                (or (and (equal-tree? b1 c2) (equal-tree? c1 b2))) true\n                    :else false \n                    )\n               false\n               )\n             )]\n    \n    (if (sequential? sx)\n      (let [ [a b c ] sx ]\n        (equal-tree?  b c )\n        )\n      (nil? sx))\n    )\n  )", "user": "51f81925e4b09be9c177e526"}, {"problem": 96, "code": "(fn number96 [[_ left right]]\n  (letfn [(mirror-leaves [[h l r :as t]]\n                          (if (coll? t)\n                            [h (mirror-leaves r) (mirror-leaves l)]\n                            t))]\n    (= left (mirror-leaves right))))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 96, "code": "(fn [[a l r]]\n   (= l ((fn f [[a l r]]\n           (if a [a (f r) (f l)]))\n         r)))", "user": "51bd255ce4b0df1216cefd94"}, {"problem": 96, "code": "(fn p96-full [tree]\n  (letfn [(tree-root [tree] (if tree (first tree)))\n          (tree-right-subtree [tree] (if tree (first (rest (rest tree)))))\n          (tree-left-subtree [tree] (if tree (first (rest tree))))\n          (to-vector-r [tree v] (if tree\n                                (flatten (conj v\n                                               (tree-root tree)\n                                               (to-vector-r (tree-right-subtree tree) [])\n                                               (to-vector-r (tree-left-subtree tree) [])))))\n          (to-vector-l [tree v] (if tree\n                                (flatten (conj v\n                                               (tree-root tree)\n                                               (to-vector-l (tree-left-subtree tree) [])\n                                               (to-vector-l (tree-right-subtree tree) [])))))]\n    (every? #(apply = %) (map list (to-vector-r tree []) (to-vector-l tree [])))))", "user": "550ff2a3e4b06e50f9beb17f"}, {"problem": 96, "code": "(fn eq?\n  ([r] (apply eq? (rest r)))\n  ([l r]\n   (if (and (every? coll? [l r]) (= (first l) (first r)))\n     (and (eq? (second l) (last r)) (eq? (last l) (second r)))\n     (= l r))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 96, "code": "(fn symmetry [[a left right]]\n  (= left ((fn mirror \n             [tree] \n            (if (nil? tree) \n                nil\n            (let [v (first tree)\n                  l (second tree)\n                  r (last tree)] \n              (vector v (mirror r) (mirror l)))))\n           right)))", "user": "5510aa92e4b06e50f9beb188"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "54b64fbbe4b05787c3b163b8"}, {"problem": 96, "code": "#(= ((fn symmetric? [[n l r :as tree]]\n   (when tree\n     [n (symmetric? r) (symmetric? l)])) %) %)", "user": "54ab1b5ae4b09f271ff37cc2"}, {"problem": 96, "code": "(fn symtree? [tree]\n  (letfn [(mirror [tree]\n            (if (nil? tree) nil\n                [(first tree) (mirror (last tree)) (mirror (second tree))]))]\n    (or (nil? tree)\n        (and (= (second tree)\n                (mirror (last tree)))))))", "user": "547884d7e4b0c51c1f4d72bd"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(is-mirror?\n           [[lv ll lr :as lt] [rv rl rr :as rt]]\n           (or (and (nil? lt) (nil? rt))\n               (and\n                (= lv rv)\n                (is-mirror? ll rr)\n                (is-mirror? lr rl))))]\n    (is-mirror? l r)))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 96, "code": "(fn [[_ L R]]\n  (letfn [(v [[n l r]]\n             (if (nil? n)\n               nil\n               [n (v r) (v l)]))]\n    (= L (v R))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 96, "code": "(fn [[V L R]]\n  (let [m (fn m [b]\n            (if (nil? b)\n              nil\n              (let [[v l r] b]\n                [v (m r) (m l)])))]\n    (= L (m R))))", "user": "4f42ae16e4b0d7d3c9f3fd09"}, {"problem": 96, "code": "#(apply \n  (fn f [[b1 b2 b3 :as b] [c1 c2 c3 :as c]] \n   (if (or (nil? b) (nil? c)) \n       (and (nil? b) (nil? c))\n       (and (= b1 c1)\n            (f b2 c3)\n            (f b3 c2))))\n  (rest %))", "user": "5499e23de4b03163384f4706"}, {"problem": 96, "code": "(letfn [(mirror [c]\n  (if (coll? c)\n    [(first c) (mirror (last c)) (mirror (second c))]\n    c))]\n  #(= (mirror (second %)) (last %)))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 96, "code": "(fn sym-tree?\n  [node]\n  (if (nil? node)\n    true\n    (let [[_ l r] node\n          nd-eq? (fn node-eq?\n            \t   [a b]\n                   (if (nil? a)\n                     (= a b)\n                     (let [[va la ra] a\n                           [vb lb rb] b]\n                       (and \n                         (= va vb)\n                         (node-eq? la rb)\n                         (node-eq? ra lb)))))]\n      (nd-eq? l r))))", "user": "53161a56e4b08068f379ed3e"}, {"problem": 96, "code": "(fn comptree\n  ([[h l r]] (comptree l r))\n  ([l r] (or (and (nil? l) (nil? r))\n             (and (sequential? l)\n                  (sequential? r)\n                  (= (first l) (first r))\n                  (comptree (second l) (last r))\n                  (comptree (second r) (last l))))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 96, "code": "(fn is-symmetric? [[e l r]]\n  (letfn[(mirror [node] (if (nil? node) nil (let [[e l r] node] [e (mirror r) (mirror l)])))]\n         (= l (mirror r))))", "user": "554dfe97e4b00713264bd98c"}, {"problem": 96, "code": "(fn [tree]\n  (let [mirror-tree\n        (fn mirror-tree [node]\n          (cond\n           (nil? node) node\n           (or (not (sequential? node)) (not= 3 (count node))) (throw (IllegalArgumentException. \"grr\"))\n           :else (let [[v L R] node] [v (mirror-tree R) (mirror-tree L)])))]\n    (= tree (mirror-tree tree))))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(lin [t]\n              (when-not (nil? (first  t))\n                (concat (lin (second t)) [(first t)] (lin (last t)))))\n        (rin [t]\n              (when-not (nil? (first  t))\n                (concat (rin (last t)) [(first t)] (rin (second t)))))]\n    (= (lin (second t)) (rin (last t)))))", "user": "54d1b6ffe4b0e8a36923e5e6"}, {"problem": 96, "code": "(fn  [col]\n  \"check if the tree is symmetric\"\n  (letfn [(compare-trees [a b]\n            (if (= (first a) (first b))\n              (let [csa (filter coll? a)\n                    csb (filter coll? b)\n                    ncsa (filter (complement coll?) a)\n                    ncsb (filter (complement coll?) b)]\n                (and\n                 (= ncsa (reverse ncsb)))\n                (if (and  (seq csa) (seq csb))\n                  (every? true?\n                          (map compare-trees\n                               csa\n                               (reverse csb)))\n                  true))\n              false))]\n    (when (seq col)\n      (compare-trees (second col) (last col)))))", "user": "516d227fe4b06f078fab252d"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(mirror [b]\n            (if (= nil b)\n              nil\n              [(first b) (mirror (nth b 2)) (mirror (second b))]))]\n    (= (second t) (mirror (nth t 2)))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 96, "code": "(letfn [(mirror ([tree]\n                 (if (= (count tree) 3)\n                   (let [[label left right] tree]\n                \t(list label (mirror right) (mirror left)))\n                   (first tree))))]\n  (fn [[label left right]]\n    (= left (mirror right))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 96, "code": "#(= % ((fn mirror [[value left right]] (if value [value (mirror right) (mirror left)])) %))", "user": "555287a4e4b0deb715856df5"}, {"problem": 96, "code": "(fn symmetric? [[head left right]]\n  (let [mirror (fn mirror [[head left right]]\n                 (if (nil? head)\n                   nil\n                   (vector head (mirror right) (mirror left))))]\n    (= left (mirror right))))", "user": "4fdb881ee4b05e33b9224f5e"}, {"problem": 96, "code": "#(letfn [(mirror [[v s1 s2 :as t]]\n                 (when t\n                   [v (mirror s2) (mirror s1)]))]\n  (= (nth % 1) (mirror (nth % 2))))", "user": "5540cc0ce4b0a04f79299505"}, {"problem": 96, "code": "(fn [x]\n  (= x\n     ((fn flip [[v l r :as n]]\n        (when n\n          [v (flip r) (flip l)]))\n      x)))", "user": "556a6137e4b09a3098a524e0"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]]\n         (when tree [n (mirror r) (mirror l)])) %) %)", "user": "54c3747de4b045293a27f60e"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "551d5cb9e4b07993ea3788e9"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn \n    [(mirror? [[lv ll lr] [rv rl rr]] \n              (if \n                (nil? lv) (nil? lv) \n                (and (= lv rv) \n                     (mirror? ll rr) \n                     (mirror? lr rl))))]\n   (mirror? l r)))", "user": "52e851bfe4b09f7907dd149a"}, {"problem": 96, "code": "#(= ((fn deep-rev [coll]\n       (if (coll? coll)\n         (let [[n l r] coll] [n (deep-rev r) (deep-rev l)])\n         coll))\n     (second %))\n    (last %))", "user": "554b8572e4b0a04f79299589"}, {"problem": 96, "code": "(fn symmetric-tree? [tree]\n  (let [walk (fn walk [node mirror]\n               (if (sequential? node)\n                 (let [[key left right] node]\n                   (if mirror\n                     (concat (list key)\n                             (walk right mirror)\n                             (walk left mirror))\n                     (concat (list key)\n                             (walk left mirror)\n                             (walk right mirror))))\n                 (list node)))\n        [_ left-tree right-tree] tree]\n    (= (walk left-tree false)\n       (walk right-tree true))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 96, "code": ";;a breadth first traversal\n;#(letfn[(nextLevel [nodeSeq]\n;                   (apply concat (for [node nodeSeq]\n;                                   (concat [(second node) (last node)]))))\n;        (levelSymmetric? [nodeSeq]\n;                         (if (empty? nodeSeq) true\n;                           (let [firstNode (first nodeSeq) lastNode (last nodeSeq)]\n;                             (if\n;                               (and (nil? firstNode) (nil? lastNode)) (recur (butlast (rest nodeSeq)))\n;                               (if\n;                                 (= (first firstNode) (first lastNode)) (recur (butlast (rest nodeSeq)))\n;                                 false)))))]\n;   (loop[treeNodes (list %)]\n;     (if (levelSymmetric? treeNodes)\n;       (let [nextLevelNodes (nextLevel treeNodes)]\n;         (if \n;           (every? nil? nextLevelNodes) true\n;           (recur (nextLevel treeNodes))))\n;       false)))\n\n;a recursive solution\n(fn [[v l r]]\n  (letfn[(mirror?[lb rb] \n          (cond\n            (not= (sequential? lb) (sequential? rb)) false\n            (sequential? lb) (let [[lv ll lr] lb [rv rl rr] rb]\n                               (and (= lv rv) (mirror? ll rr) (mirror? lr rl)))\n            :else (= lb rb)))]\n    (mirror? l r)))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 96, "code": "(fn btree-symm? [coll]\n  (letfn [(wlk [coll order]\n            (if (coll? coll)\n              (let [[v l r] coll\n                    res (list v)\n                    lc (wlk l order)\n                    rc (wlk r order)]\n                (if (= :leftmost order)\n                  (cons lc (cons rc res))\n                  (cons rc (cons lc res))))))]\n    (let [lc (flatten (wlk (nth coll 1) :leftmost))\n          rc (flatten (wlk (nth coll 2) :rightmost))]\n      (= lc rc))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 96, "code": "#(letfn [(mirror [[v l r :as t]]\n                 (if (and (nil? l) (nil? r)) t (list v (mirror r) (mirror l))))\n         (isSymTree [[_ l r :as t]]\n                    (= l (mirror r)))]\n   (isSymTree %))", "user": "555b35f7e4b0deb715856e4b"}, {"problem": 96, "code": "(fn [xs]\n  ((fn symmet? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (symmet? (second l) (last r))\n                  (symmet? (last l) (second r))))\n      true\n      false))\n      (second xs) (last xs)))", "user": "52b89d55e4b07a9af57922b3"}, {"problem": 96, "code": "(fn stree? [l]\n  (letfn [(trees-mirror [x y]\n  (if (empty? x) (= x y)\n      (and (= (first x) (first y)) \n       (trees-mirror (second x) (nth y 2)) \n       (trees-mirror (second y) (nth x 2)))))] \n    (if (nil? l) \n      true\n      (and (sequential? l) (= 3 (count l)) (trees-mirror (second l) (nth l 2))))))", "user": "54f8b6f4e4b01ecee9d8882c"}, {"problem": 96, "code": "(fn p96\n  [coll]\n  (let [childa (second coll)\n        childb (last coll)]\n    (= ((fn mirror [coll] (let [node (first coll)\n        childa (second coll)\n        childb (last coll)]\n    (if (seq childa)\n      (if (seq childb)\n        [node (mirror childb) (mirror childa)]\n        [node childb (mirror childa)])\n      (if (seq childb)\n        [node (mirror childb) childa]\n        [node childb childa])))) childa) childb)))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 96, "code": "(fn [t]\r\n  (let [\r\n      mirrored (fn mirrored[t]\r\n        (let [[name left right] t]\r\n          [name\r\n            (if (nil? right) right (mirrored right))\r\n            (if (nil? left) left (mirrored left))]))]\r\n    (and\r\n      (coll? t)\r\n      (= (count t) 3)\r\n      (= t (mirrored t)))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 96, "code": "(fn sym [tr]\n  ((fn eq [tr1 tr2]\n    (if (= (first tr1) (first tr2))\n  \t\t(if (and (nil? tr1) (nil? tr2))\n    \t\ttrue\n            (if (or (nil? tr1) (nil? tr2))\n              false\n    \t\t  (and (eq (second tr1) (last tr2)) (eq (second tr2) (last tr1)))\n            ))\n        false)) (last tr) (second tr) \n    ))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 96, "code": "(fn sym-tree?\n  [[n a b :as t]]\n  (letfn [(mirror-tree [[n a b :as t]]\n            (when-not (nil? t)\n              [n (mirror-tree b) (mirror-tree a)]))]\n    (= a (mirror-tree b))))", "user": "55702081e4b09a3098a52529"}, {"problem": 96, "code": "(fn [node]\n  (let [sym (fn ! [a b]\n              (if (and (nil? a) (nil? b))\n                true\n                (if (or (and (nil? a) (coll? b)) (and (coll? a) (nil? b)))\n                  false\n                  (let [[fa sa ta] a\n                        [fb sb tb] b]\n                    (and (= fa fb) (! sa tb) (! sb ta))\n                    ))))]\n    (sym (second node) (last node))\n    ))", "user": "557232a1e4b09a3098a52543"}, {"problem": 96, "code": "(fn sym [[v l r]] (let [f #(->> %2 (tree-seq sequential? %1) (map first) (filter identity))] (= (f rest l) (f (comp reverse rest) r))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 96, "code": "(fn [tree]\n  (= tree\n     ((fn mirror [tree]\n        (if (nil? tree)\n          tree\n\n          (cons \n           (first tree)\n           (conj '()\n                 (mirror (nth tree 1))\n                 (mirror (nth tree 2))))))\n      tree)))", "user": "53065acbe4b02e8216869792"}, {"problem": 96, "code": "(fn [tree]\n    (let [[val left right] tree]\n      (letfn [(recurtree [node] \n                (if-not (nil? node)\n                  (invert node)))\n              (invert [[value left right]]\n                (println (str left right))\n                (list value (recurtree right) (recurtree left)))]\n        (= left (invert right))\n        )))", "user": "554a75c9e4b0a04f79299575"}, {"problem": 96, "code": "(fn [t]\n  (let [flip (fn flip [subt]\n               (if (coll? subt)\n                 (map flip ((juxt first last second) subt))\n                 subt))]\n    (= (flip (second t)) (last t))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 96, "code": "(fn symmetric? [[_ l r]]\n  (let [[vl ll lr] l\n        [vr rl rr] r]\n    (or (and (nil? l)\n             (nil? r))\n        (and (= vl vr)\n             (symmetric? [nil ll rr])\n             (symmetric? [nil lr rl])))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 96, "code": "(fn reflection \n  ([tree] \n   (reflection (nth tree 1) (nth tree 2)))\n  ([ls rs] \n   (if (and (sequential? ls) (sequential? rs))\n     (if (= (first ls) (first rs))\n       (and\n        (reflection (nth rs 1) (nth ls 2))\n        (reflection (nth rs 2) (nth ls 1)))\n     false)\n   (= ls rs))))", "user": "5256a1d4e4b0541d1855ba29"}, {"problem": 96, "code": "; I'm establishing myself as the the 'goto' programmer for verbose Clojure solutions!\n; In the solutions of others, I'm beginning to see, for the first time, the benefits of destructuring.\n  (fn [[_ left right]]\n    (let [tpre   (fn pre-trav\n                   ([bnode] (flatten (pre-trav bnode [])))\n                   ([bnode result]\n                     (if-not (nil? bnode)\n                       (conj result (first bnode) (pre-trav (second bnode) result) (pre-trav (last bnode) result))\n                       result )))\n          tpost   (fn post-trav\n                   ([bnode] (flatten (post-trav bnode [])))\n                   ([bnode result]\n                     (if-not (nil? bnode)\n                       (conj result (post-trav (second bnode) result) (post-trav (last bnode) result ) (first bnode))\n                       result)))\n          result-tpre (tpre left)\n          result-tpost (tpost right)]\n      (= result-tpost (reverse result-tpre))))", "user": "5535e822e4b09218d5f44fb2"}, {"problem": 96, "code": "(fn f96\n  ([t]\n   (f96 (second t) (last t)))\n  ([l r]\n   (if (or (nil? l)\n           (nil? r))\n     (and (nil? l)\n          (nil? r))\n     (and (= (first l) (first r))\n          (f96 (second l) (last r))\n          (f96 (last l) (second r))))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 96, "code": "(fn symtree? [tree]\n  (let [[_ left right] tree]\n    (if (and (nil? left) (nil? right))\n      true\n      (if (or (nil? left) (nil? right))\n        false\n        (let [[l-root left1 right1] left\n              [r-root left2 right2] right]\n          (and (= l-root r-root)\n               (symtree? [nil left1 right2])\n               (symtree? [nil right1 left2])))))))", "user": "5573ffb5e4b0aa18f790f3fd"}, {"problem": 96, "code": "(fn symmetric-tree? [tr]\n  (letfn [(tree-root [[root _ _]]\n            root)\n          (left-node [[_ left _]]\n            left)\n          (right-node [[_ _ right]]\n            right)\n          (symmetric? [tr1 tr2]\n            (cond\n             (and (nil? tr1) (nil? tr2)) true\n             ;(or (not= 3 (count tr1) (not= 3 (count tr2)))) false\n             :else (and\n                    (= (tree-root tr1) (tree-root tr2))\n                    (symmetric? (left-node tr1) (right-node tr2))\n                    (symmetric? (right-node tr1) (left-node tr2)))))]\n    (symmetric? (left-node tr) (right-node tr))))", "user": "5576f299e4b05c286339e077"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(rev-children [[v l r]]\n            (let [new-l (if (nil? r) nil (rev-children r))\n                  new-r (if (nil? l) nil (rev-children l))]\n              [v new-l new-r]))]\n    (boolean (or (and (nil? l) (nil? r))\n                 (and (seq l) (seq r) (= l (rev-children r)))))))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(flip [[v l r :as tree]]\n            (when tree [v (flip r) (flip l)]))]\n    (= l (flip r))))", "user": "4ed45563535d10e5ff6f52c9"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(mirror [[value left right :as t]]\n                  (when-not (nil? t)\n                    [value (mirror right) (mirror left)]))]\n    (= (mirror left) right)))", "user": "4ec6297b535d6d7199dd36c4"}, {"problem": 96, "code": "(fn [tree]\n  ((fn mirror? [left right]\n     (if (or (= nil left right)\n             (and (= (first left) (first right))\n                  (mirror? (second left) (last right))\n                  (mirror? (last left) (second right))))\n       true false)) \n   (second tree) (last tree)))", "user": "54f296efe4b024c67c0cf8c8"}, {"problem": 96, "code": "#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 96, "code": "(fn [[n l r]]\n   ((fn ? [l r]\n      (cond\n        (and (nil? l) (nil? r)) true\n        (and (sequential? l) (sequential? r)) (let [[ln ll lr] l\n                                                    [rn rl rr] r] (and (= ln rn)\n                                                                       (? ll rr)\n                                                                       (? lr rl)))\n        :else false\n        )) l r))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 96, "code": "(fn symmetric? [[_ L R]]\n  (if (not (coll? L))\n    true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (and (= LV RV) (symmetric? [nil LL RR]) (symmetric? [nil RL LR]))))))", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 96, "code": "(fn is-symmetric?\n  [[root left right]]\n  (letfn [(mirror\n            [[root left right]]\n            (if-not (nil? root) [root (mirror right) (mirror left)]))]\n    (= (mirror left) right)))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 96, "code": "(fn is-symetric\n  [t] (if (nil? t) true ((fn is-symetric'\n  [x y]\n  (if (and (coll? x) (coll? y))\n    (if (= (first x) (first y))\n      (and (is-symetric' (second x) (nth y 2))\n           (is-symetric' (second y) (nth x 2)))\n      false)\n    (= x y)))\n\n                         (second t) \n                         (nth t 2))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 96, "code": "(fn [t]\n    (letfn [(rev [t]\n                (let [v (first t)\n                      l (second t)\n                      r (last t)]\n                    (if (coll? t)\n                        [v (rev r) (rev l)]\n                        t)))]\n        (= (second t) (rev (last t)))))", "user": "558306dfe4b05c286339e110"}, {"problem": 96, "code": "#(= %\n    ((fn flip [[v l r]]\n       (when v\n         [v (flip r) (flip l)]))\n     %))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 96, "code": "(fn [t]\n   (letfn [(inotr [root ret]\n            (if root\n              (concat ret\n                      (inotr (second root) ret)\n                      [(first root)]\n                      (inotr (nth root 2) ret))\n              []))]\n     (let [tr (inotr t [])\n           c (count tr)\n           mid (int (/ c 2))\n           l (take mid tr)\n           r (drop (inc mid) tr)]\n       (= l (reverse r)))))", "user": "523b4e91e4b07becd5be21ef"}, {"problem": 96, "code": "(fn sym-btree?\n  ([tr]\n   (let [lft (first (rest tr))\n         rgt (last tr)]\n     (sym-btree? lft rgt)))\n  ([lft rgt]\n   (if (sequential? lft)\n     (and (= (first lft) (first rgt))\n          (sym-btree? (first (rest lft))\n                      (last rgt))\n          (sym-btree? (first (rest rgt))\n                      (last lft)))\n     (= lft rgt))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 96, "code": "(letfn [                                                                                                                                                \n    (reverse-tree [node]                                                                                                        \n        (if (coll? node)                                                                                                                                \n            (list (first node) (reverse-tree (last node)) (reverse-tree (second node)))                                         \n            node))                                                                                                                                      \n    (is-symmetrical? [node] (= node (reverse-tree node)))]                                                                      \n        is-symmetrical?)", "user": "558b50d5e4b027778923762b"}, {"problem": 96, "code": "(fn c [[_ l r]]\n  (let [[l1 l2 l3] l [r1 r2 r3] r]\n    (if (every? coll? (list l r))\n      (and (= l1 r1) (c [_ l2 r3]) (c [_ r2 l3]))\n      (= l r)\n    )))", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 96, "code": "(fn [t]\n  ((fn f? [t1, t2]\n    (if (sequential? t1)\n      (let [[v1 l1 r1] t1 [v2 l2 r2] t2]\n        (and (= v1 v2) (f? l1 r2) (f? l2 r1)))\n     (= t1 t2))) (nth t 1) (nth t 2)))", "user": "5590e55de4b0277789237676"}, {"problem": 96, "code": "(fn symmetric? \n  ([node] \n    (let [[_ leftnode rightnode] node] \n      (symmetric? leftnode rightnode)))\n  ([n1 n2] \n    (or \n     (and (nil? n1) (nil? n2))\n     (let [[v1 l1 r1] n1 [v2 l2 r2] n2]\n      (and \n        (= v1 v2)\n        (symmetric? l1 r2)\n        (symmetric? l2 r1)\n      ))\n  )))", "user": "55632016e4b0c656e3ff17e4"}, {"problem": 96, "code": "(fn [tree]\n   (let [left (first (rest tree))\n         right (first (rest (rest tree)))]\n     ((fn same-node? [n1 n2]\n        (if (and (coll? n1) (coll? n2))\n          (let [v1 (first n1)\n                v2 (first n2)\n                l1 (first (rest n1))\n                l2 (first (rest n2))\n                r1 (first (rest (rest n1)))\n                r2 (first (rest (rest n2)))]\n            (and (= v1 v2)\n                 (or (and (nil? l1) (nil? r2))\n                     (same-node? l1 r2))\n                 (or (and (nil? r1) (nil? l2))\n                     (same-node? r1 l2))))\n          (and (nil? n1) (nil? n2))))\n      left\n      right)))", "user": "55860905e4b001b0851d7516"}, {"problem": 96, "code": "(fn my \n\t[n]\n\n\t(let [ node (into [] n)\n\n\t\t   [_ l-child r-child] node\t\n\n\t\t   mytest (fn mytest2 [myseq]\n\n\t\t\t\t(if (= 3 (count myseq) )\n\t\t\t\t\t(concat (list (first myseq)) \n\t\t\t\t\t\t\t(list (mytest2 (nth myseq 2)))\n\t\t\t\t\t\t\t(list (mytest2 (nth myseq 1)))\n\t\t\t\t\t\t\t)\n\t\t\t\t\tmyseq\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\n\t\t(= (flatten (mytest l-child))\n\t\t   (flatten r-child) )\n\t)\n\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 96, "code": "(fn [[_ ll rr]]\n  (= rr ((fn it [[k l r]] [k (if r (it r) nil)\n                            (if l (it l) nil)]) ll)))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 96, "code": "(fn is-mirror? [tree]\n          (letfn [(flip-tree [tree]\n                             (if (empty? tree)\n                               nil\n                               [(nth tree 0)\n                                (flip-tree (nth tree 2))\n                                (flip-tree (nth tree 1))]))]\n            (= (nth tree 1)\n               (flip-tree (nth tree 2)))))", "user": "531c6e72e4b08068f379eda0"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "558d7dd3e4b0277789237647"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n          (and (nil? a) (nil? b))\n          (if (and (coll? a) (coll? b))\n            (and (= (count a) (count b) 3)\n                 (= (first a) (first b))\n                 (sym? (second a) (last b))\n                 (sym? (last a) (second b)))\n            false))))", "user": "55882c84e4b059ccff29b1f2"}, {"problem": 96, "code": "#(letfn [(symmetric? [a b]\n                       (if (and (coll? a) (coll? b))\n                         (let [[a1 a2 a3] a\n                               [b1 b2 b3] b]\n                           (and (= a1 b1)\n                                (symmetric? a2 b3)\n                                (symmetric? a3 b2)))\n                         (= a b)))]\n    (symmetric? (second %) (last %)))", "user": "5585f088e4b001b0851d7513"}, {"problem": 96, "code": "#(= % \n    ((fn - [[v L R]]\n       (and v\n           [v (- R) (- L)])) \n     %))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 96, "code": "(fn symmetric-tree [[x l r :as tr]]\n  (letfn [(symmetric? [[x1 l1 r1 :as tr1][x2 l2 r2 :as tr2]]\n            (cond\n              (= tr1 tr2 nil) true\n              (= x1 x2) (and\n                         (symmetric? l1 r2)\n                         (symmetric? r1 l2))\n              :else false))]\n    (symmetric? l r)))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirror?\n            [[lx ll lr :as l] [rx rl rr :as r]]\n            (or (not (or l r))\n                (and (= lx rx)\n                     (and (mirror? ll rr)\n                          (mirror? lr rl)))))]\n    (mirror? l r)))", "user": "559bdf16e4b066d22e731f5a"}, {"problem": 96, "code": "(fn tree-match [[_ left right]]\n  (= (map first (tree-seq identity rest left)) (map first (tree-seq identity #(reverse (rest %)) right))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 96, "code": "#(= ((fn f [[v l r :as t]]\n       (if (nil? t)\n         nil\n         [v (f r) (f l)])) %) %)", "user": "558f4fbae4b0277789237661"}, {"problem": 96, "code": "(fn [coll]\n  ((fn sym? [e1 e2]\n    (if (and (coll? e1) (coll? e2))\n      (and (= (first e1) (first e2)) (sym? (second e1) (last e2)) (sym? (last e1) (second e2)))\n      (= e1 e2)))\n   (second coll) (last coll)))", "user": "55933c7ae4b0c79f6e1db938"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(node-eq? [node1 node2]\n            (or \n              (= nil node1 node2)\n              (let [children1 (rest node1)\n                    children2 (rest node2)]\n                (and (= (first node1) (first node2))\n                     (node-eq? (first children1) (second children2))\n                     (node-eq? (second children1) (first children2))))))]\n    (node-eq? left right)))", "user": "532902f8e4b09d4e7a9b550e"}, {"problem": 96, "code": "(fn sym-tree? [tree]\n  (letfn [(walk-tree [n] (if (nil? n) nil (concat (walk-tree (nth n 1)) [(first n)]  (walk-tree (nth n 2)))))]\n      (= (walk-tree (second tree)) (reverse (walk-tree (last tree)))))\n    )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 96, "code": "(fn  [ tree ]\n  (let [traverse-left (fn tl [tree] \n                        (let [ [k l r] tree ]\n                          (cond\n                               (nil? k) '(nil)\n                               (nil? l) (conj (tl r) k)\n                               :else (tl l)\n                               )))\n        traverse-right (fn tr [tree] \n                        (let [ [k l r] tree ]\n                          (cond\n                               (nil? k) '(nil)\n                               (nil? r) (conj (tr l) k)\n                               :else (tr r)\n                               )))\n        ]\n    (= (traverse-left tree)  (traverse-right tree))))", "user": "55496eeae4b0a04f79299569"}, {"problem": 96, "code": "(let [in-order (fn in-order [t]\n                 (if (nil? t) ()\n                   (concat (in-order (nth t 1))\n                           [(first t)]\n                           (in-order (nth t 2)))))]\n  (fn [t] \n    (let [traversal (in-order t)]\n      (= traversal (reverse traversal)))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 96, "code": "(fn symmetric? [tree]\n            (= tree\n              ((fn mirror [[head left right :as tree]]\n                 (if (nil? head)\n                   nil\n                   [head (mirror right) (mirror left)]))\n               tree)))", "user": "4e5af45e535d8a8b8723a2b1"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(reverse-tree [t]\n                        (if (nil? t)\n                          nil\n                          (list (first t)\n                                (reverse-tree (nth t 2))\n                                (reverse-tree (second t)))))]\n    (= t (reverse-tree t))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5595c60ee4b0c79f6e1db96f"}, {"problem": 96, "code": "(fn [t]\n  (let [h #(first %)\n        l #(second %)\n        r #(last %)\n        m? (fn m [t1 t2]\n             (or\n               (and (nil? t1) (nil? t2))\n               (and (= (h t1) (h t2))\n                    (m (l t1) (r t2))\n                    (m (r t1) (l t2)))))]\n    (m? (l t) (r t))))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(flip [t]\n            (cond\n             (nil? t) nil\n             (sequential? t) (let [[v l r] t]\n                             [v (flip r) (flip l)])\n             :else t))]              \n  (= l (flip r))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 96, "code": "(fn mirror? [x]\n  (if (= (count x) 3)\n    (mirror? (conj [] (second x) (nth x 2)))\n    (let [left (first x)\n          right (second x)]\n      (or (and\n           (nil? left)\n           (nil? right))\n          (and\n           (coll? left)\n           (coll? right)\n           (= (first left) (first right))\n           (mirror? (conj [] (second left) (nth right 2)))\n           (mirror? (conj [] (nth left 2) (second right))))))))", "user": "5596af34e4b04c1e5c31d758"}, {"problem": 96, "code": "(fn is-sym [t]\n  (if (not= (count t) 3) false\n      ((fn cmp-tree [lt rt]\n        (if (or (not= (count lt) 3) (not= (count rt) 3)) false\n          (let [[x xl xr] lt [y yl yr] rt]\n            (and\n              (= x y)\n              (and \n               \t(if (and (coll? xl) (coll? yr)) (cmp-tree xl yr) (and (= nil xl) (= nil yr)))\n              \t(if (and (coll? xr) (coll? yl)) (cmp-tree xr yl) (and (= nil xr) (= nil yl))))\n            ))))  (second t) (last t))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 96, "code": "(fn mirror? \n  ([n]\n    (mirror? (second n) (last n)))\n  ([l r]\n    (or \n      (and (not (sequential? l)) (not (sequential? r)) (= l r))\n      (and (= (first l) (first r))\n           (mirror? (second l) (last r))\n           (mirror? (last l) (second r))))))", "user": "53e9681de4b036ad0777e4a4"}, {"problem": 96, "code": "(fn f [[_ l r]]\n  ((fn g [l r] \n     (or (= nil l r)\n         (let [[a b c] l\n               [x y z] r]\n           (and (= a x)\n                (g b z)\n                (g c y)))))\n   l r))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 96, "code": "(fn symmetric-tree? [[_ left right]]\n  (letfn [(symmetric? [t1 t2] (if (and (sequential? t1) (sequential? t2)) (symmetric-tree?* t1 t2) (= t1 t2)))\n          (symmetric-tree?* [[vl ll lr] [vr rl rr]]\n            (and\n              (= vl vr)\n              (symmetric? ll rr)\n              (symmetric? lr rl)))]\n    (symmetric-tree?* left right)))", "user": "55a12668e4b0acc240e3150b"}, {"problem": 96, "code": "(fn mysym [[value left right]]\n  (or (and (nil? left) (nil? right))\n      (let [[lv ll lr] left [rv rl rr] right]\n        (and (= lv rv)\n           \t (mysym [0 ll rr])\n             (mysym [0 lr rl])\n             ))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 96, "code": "#((fn mir [l r] \n       (cond\n         (not= (first l) (first r)) false\n         (and (nil? (second l)) (not (nil? (last r)))) false\n         (and (nil? (last l)) (not (nil? (second r)))) false\n         (and (every? nil? (concat (rest l) (rest r)))) true\n         :else (and (mir (second l) (last r)) (mir (last l) (second r)))))\n       (second %) (last %))", "user": "559a8816e4b066d22e731f41"}, {"problem": 96, "code": "(fn [root]\n  (let [mirror (fn mirror [t]\n                 (if (nil? t)\n                   nil\n                   (concat [(first t)] [(mirror (last t))] [(mirror (nth t 1))])))]\n    (= root (mirror root))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 96, "code": "(fn tree-symmetric? [[v l r]]\n  (letfn [(tree-mirror [tree]\n            (when-let [[v l r] (seq tree)]\n              [v (tree-mirror r) (tree-mirror l)]))]\n    (= l (tree-mirror r))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 96, "code": "(fn is-symetric [tree]\n   (let [[value left right] tree\n         mirror-tree (fn mirror [node]\n                       (if (and (coll? node) (= (count node) 3))\n                         (let [[v l r] node]\n                           [v (mirror r) (mirror l)]\n                           )\n                         node)\n                         )\n         mirrored (mirror-tree right)\n        ]\n        (= left mirrored)\n    ))", "user": "55aa5f73e4b0988bba2ad94b"}, {"problem": 96, "code": "(fn treeSym? [[tv tl tp]] ((fn eqTree? [[v1 l1 p1] [v2 l2 p2]] \n  \t                         (cond\n                               (or (nil? v1) (nil? v2)) (and (nil? v1) (nil? v2))\n                               :else (and (= v1 v2) (eqTree? l1 p2)  (eqTree? p1 l2)))\n                            ) tl tp))", "user": "5576e78de4b05c286339e075"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "55b08677e4b002ce9d5cbc23"}, {"problem": 96, "code": "(fn [t]\n  (let [expand-tree (fn et [t]\n                      (let [[h l-tree r-tree] t]\n                        (if (not (nil? h))\n                          (concat (et l-tree) (list h) (et r-tree)))))\n        expanded-tree (expand-tree t)]\n    (= expanded-tree (reverse expanded-tree))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 96, "code": "(fn symmet [t]\n    (letfn [(mirror [[val left right :as tree]]\n              (if (nil? val)\n                nil\n                (list val (mirror right) (mirror left))))]\n      (= (second t) (-> t last mirror))))", "user": "54ad9d76e4b09f271ff37ce6"}, {"problem": 96, "code": "(let\n    [\n     applicable? (fn [& l] (reduce (fn [r i] (and r (or (seq? i) (vector? i)))) true l))\n     mirror-tree (fn mirror\n              ([a b c]\n               (cond\n                 (applicable? b c) [a (apply mirror c) (apply mirror b)]\n                 (applicable? b) [a c (apply mirror b)]\n                 (applicable? c) [a (apply mirror c) b]\n                 :else [a c b]))\n              ([a]\n               (if (applicable? a)\n                 (apply mirror a)\n                 a)))\n     ]\n    (fn symmetric?\n      ([_ b c]\n       (= (apply vector b) (mirror-tree c)))\n      ([a]     (apply symmetric? a))))", "user": "559a9a3de4b066d22e731f45"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "559c3d73e4b066d22e731f65"}, {"problem": 96, "code": "(fn [ot]\n  (let [[otv otl otr] ot]   \n   (letfn [(invtree [t]\t\n\t\t\t(let [[v l r] t]\n\t\t\t(vector v\n\t\t\t\t (if(nil? r) nil (invtree r))\n\t\t\t\t (if(nil? l) nil (invtree l)))))]\n   (= otl (invtree otr)))))", "user": "54f4a457e4b0f2f3c5226e83"}, {"problem": 96, "code": "(fn [[root left right]]\n    (letfn [(rotate [[root left right]] [root (when right (rotate right)) (when left (rotate left))])]\n      (= left (rotate right)))\n  )", "user": "5245e320e4b09dbe66b56177"}, {"problem": 96, "code": "(fn sym? [[_ a b]]\n  ((fn mirror? [a b]\n     (if (coll? b)\n      (and (= (first a) (first b))\n       (every? true? (map mirror? (rest a) (reverse (rest b)))))\n       (= a b))\n     ) a b))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 96, "code": "(fn [tree]\n  (let [flip-tree (fn flip [tree]\n                    (if (nil? tree) nil\n                      (let [[value left-tree right-tree] tree]\n                        (list value (flip right-tree)\n                              (flip left-tree)))))]\n    (= (second tree) (flip-tree (first (rest (rest tree)))))))", "user": "55bbfd60e4b01b9910ae29ed"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(reverse-tree [tree] \n            (let [[key right left] tree\n                  right-tree (if-not (nil? right) (reverse-tree right) nil)\n                  left-tree (if-not (nil? left) (reverse-tree left) nil)\n                  ]\n              [key left-tree right-tree]\n              )\n            )]\n    (let [[key right left] tree]\n      (= right (reverse-tree left))\n      )))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 96, "code": "(fn [[_ l r]] (= ((fn f [[v l r]] (if v [v (f r) (f l)])) l) r))\n\n#_(fn [x] (= (second x)\n           ((fn re [x] \n              (if (coll? x)\n                (vector (first x) (re (last x)) (re (second x)))\n                x))\n            (last x))))\n\n\n#_(let [f (fn f [[v l r]] (if v [v (f r) (f l)]))\n       [_ l r] %]\n    (= l (f r)))\n\n;#(= % ((fn f [[v l r]] (if v [v (f r) (f l)])) %))", "user": "54e1939ce4b024c67c0cf7c5"}, {"problem": 96, "code": "(fn [c] (letfn [ (swap-node [cl] (when-let [c cl] [(first c) (swap-node (last c)) (swap-node (second c))])) ]\n         (= (second c) (swap-node (last c)))\n))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 96, "code": "(fn [s]\n   ((fn symetric-subtrees [left right]\n      (or\n        (and (nil? left) (nil? right))\n        (and\n          (= (first left) (first right))\n          (symetric-subtrees (second left) (last right))\n          (symetric-subtrees (last left) (second right))))) (first (rest s)) (last s)))", "user": "5587cd86e4b059ccff29b1e6"}, {"problem": 96, "code": "#(let [f (fn f [n] (if (coll? n) [(f (second n)) (first n) (f (last n))] n))]\n    (=  (f %) ((fn g [n] (if (coll? n) (map g (reverse n)) n)) (f %) ) ))", "user": "55bfc39ee4b01b9910ae2a1a"}, {"problem": 96, "code": "(fn symm? [[t l r]]\n  (if (and (coll? l) (coll? r))\n    (and\n     (= (first l) (first r))\n     (symm? [t (second l) (last r)])\n     (symm? [t (last l) (second r)]))\n    (and (nil? l) (nil? r))))", "user": "4f85a75ce4b033992c121c48"}, {"problem": 96, "code": "(fn [tree]\n  (let [next-level (fn [nodes] (mapcat #(drop 1 %) nodes))\n        mirrored? (fn [xs] (= xs (reverse xs)))]\n    ((fn tree-symmetric? [nodes]\n       (let [filtered (filter #(not (nil? %)) nodes)]\n         (or (empty? filtered)\n             (and (mirrored? (map first nodes))\n                  (tree-symmetric? (next-level nodes)))\n             )\n         )\n       )\n     [tree]\n     )\n    )\n  )", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (letfn [(revTree [[v l r]] \n            (list v (if (coll? r) (revTree r) r) (if (coll? l)(revTree l) l)))]\n    (= t (revTree t))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(mirror [x y]\n            (or (and (nil? x) (nil? y))\n                (and (= (nth x 0) (nth y 0))\n                     (mirror (nth x 1) (nth y 2))\n                     (mirror (nth x 2) (nth y 1)))))]\n    (mirror t t)))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 96, "code": "(fn sym-wrap [[a b c]] ((fn symmetric? [t1 t2] (if (and (nil? t1) (nil? t2)) \n                                                 true \n                                                 (let [[v1 l1 r1] t1 [v2 l2 r2] t2] \n                                                   (if (= v1 v2) \n                                                     (and (symmetric? l1 r2) (symmetric? l2 r1)) \n                                                     false)))) \n                        b c))", "user": "55c10409e4b01b9910ae2a2c"}, {"problem": 96, "code": "(fn [[v l r]]\n     (letfn  [(m [n] (if-let [[v l r] n] [v (m r) (m l)]))] (= l (m r))))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 96, "code": "(fn symmetric? [coll]\n  (= coll\n     ((fn revtree [[h l r]]\n        (vector h (if (counted? r) (revtree r) r)\n              (if (counted? l) (revtree l) l))) coll)))", "user": "54f4adc8e4b0f2f3c5226e86"}, {"problem": 96, "code": "(fn symmetric? [[_ L R]]\n  (if (not (coll? L))\n    true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (if (and (= LV RV) (symmetric? [nil LL RR]) (symmetric? [nil LR RL]))\n          true\n          false)))))", "user": "54a627bce4b09f271ff37c83"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (let [rotate (fn rotate [s]\n                 (let [v (first s)\n                       l (second s)\n                       r (second (next s))]\n                   (list v\n                         (if (sequential? r)\n                           (rotate r)\n                           r)\n                         (if (sequential? l)\n                           (rotate l)\n                           l))))]\n    (= (second t) (rotate (second (next t))))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 96, "code": "(fn symmetry? [tree]\n   (letfn [(sym [tree]\n             (if (not= 3 (count tree))\n               tree\n               (let [[a b c] tree]\n                 [a (sym c) (sym b)])))]\n     (= (nth tree 1) (sym (nth tree 2)))))", "user": "51f40975e4b0fca5e8b4822e"}, {"problem": 96, "code": "(fn [node]\n   (letfn [(expand [node]\n             (if (nil? node)\n               nil\n               (list (expand (nth node 1))\n                     (first node)\n                     (expand (nth node 2)))))]\n     (let [flat-tree (flatten (expand node))]\n       (= flat-tree (reverse flat-tree)))))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 96, "code": "#(letfn [(swap [[root c1 c2 :as t]]\n               (if (and (nil? c1) (nil? c2))\n                 t\n                 (list root\n                       (if (nil? c2) c2 (swap c2))\n                       (if (nil? c1) c1 (swap c1)))))]\n   (= (second %) (swap (last %))))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 96, "code": "(fn [[_ l r]]\n  ((fn m? [[l_ ll lr] [r_ rl rr]]\n    (if (= nil l_ r_)\n      true\n      (and (= l_ r_)\n           (m? ll rr)\n           (m? lr rl)))) \n    l r))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 96, "code": "(fn symmetric? [[c l r]]\n  (letfn [(mirror [[x y z]] [x (if (coll? z) (mirror z) z) (if (coll? y) (mirror y) y)])]\n    (= (mirror l) r)))\n\n;#(= % ((fn m [[v l r]] (if v [v (m r) (m l)])) %))", "user": "55236ad6e4b0882d96d091b1"}, {"problem": 96, "code": "(letfn [(fliptree [[v l r :as t]] (when t [v (fliptree r) (fliptree l)] ))] \n  (comp (partial apply =) (juxt identity fliptree)))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 96, "code": "#(= % \n    ((fn sym [[root left right :as tree]]\n\t\t(when tree \n          [root (sym right) (sym left)])) \n     %))", "user": "55d3811be4b0e31453f64a69"}, {"problem": 96, "code": "(fn [t] (= ((fn m [[n l r :as tree]] (when tree [n (m r) (m l)])) t) t))", "user": "55b0f5bfe4b002ce9d5cbc28"}, {"problem": 96, "code": "(fn [t]\n  (let [[v l r] t]\n    ((fn cmp-subtrees [t1 t2]\n      (if (or (nil? t1) (nil? t2)) (= t1 t2)\n        (let [[v1 l1 r1] t1 [v2 l2 r2] t2]\n          (and (= v1 v2) (cmp-subtrees l1 r2) (cmp-subtrees r1 l2))))) l r)))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 96, "code": "(fn [t]\n   (let [mirror (fn mirror [[n l r]]\n                  [n (when r (mirror r)) (when l(mirror l))])]\n     (= t (mirror t))))", "user": "55895eade4b059ccff29b202"}, {"problem": 96, "code": "(fn symmetry? [x]\n  (let [left (fn [x] (nth x 1))\n       right (fn [x] (nth x 2))\n       tree? (fn istree? [x]\n               (if (nil? x) true\n                  (if-not (sequential? x) false\n                    (if-not (= (count x) 3) false\n                      (and (istree? (left x)) (istree? (right x)) )))))\n       mirror? (fn ismirror? [a b]\n                 (cond \n                   (and (nil? a) (= a b)) true\n                   (and (not (or (nil? a) (nil? b))) (= (first a) (first b))) (and (ismirror? (left a) (right b)) (ismirror? (right a) (left b)))\n                   :else false))]\n    (and (tree? x) (mirror? (left x) (right x)))))", "user": "55c77070e4b0e31453f649d0"}, {"problem": 96, "code": "(fn symetric-bin-tree? \n  [[node l-branch r-branch :as tree]]\n  (letfn [(bin-tree-nodes?\n            [[node l-branch r-branch :as tree]]\n              (letfn [(node? [xs] (= 3 (count xs)))]\n                (if (nil? node) []\n                  (lazy-cat\n                    (conj (bin-tree-nodes? l-branch) (node? tree))\n                    (conj (bin-tree-nodes? r-branch) (node? tree))))))    \n          (binary-tree? [tree] (every? true? (bin-tree-nodes? tree)))       \n          (reverse-tree-recur \n             [[node l-branch r-branch]]\n             (when-not (nil? node)\n                [node (reverse-tree-recur r-branch) (reverse-tree-recur l-branch)]))]\n    (and (binary-tree? tree) \n         (= l-branch (reverse-tree-recur r-branch)))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 96, "code": "(fn is-symmetric \n  ([root] \n  \t(if (nil? root) \n      true \n      (is-symmetric (nth root 1) (nth root 2))))\n  ([[lval lleft lright :as left] [rval rleft rright :as right]]\n  \t(or (and (nil? left) (nil? right))\n      (and (= lval rval) (is-symmetric lleft rright) (is-symmetric lright rleft)))))", "user": "55d6a2ebe4b0e31453f64a9a"}, {"problem": 96, "code": "(fn mirror? [tree]\n  (let [[value child1 child2] tree\n        flip (fn flip [[v left right :as node]]\n               (if node \n                [v (flip right) (flip left)]\n                nil))]\n    (= child1 (flip child2))))", "user": "5561d2c2e4b0c656e3ff17cd"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(left [t] (nth t 1))\n          (right [t] (nth t 2))\n          \n          (tree= [t u]\n            (cond\n             (some nil? [t u]) (every? nil? [t u])\n             \n             (= (first t) (first u))\n             (and (tree= (left t) (left u))\n                  (tree= (right t) (right u)))\n             \n             :else false))\n\n          (reflect [t]\n            (when-not (nil? t)\n              (vector (first t)\n                      (reflect (right t))\n                      (reflect (left t)))))]\n    (or (nil? t)\n        (tree= (left t) (reflect (right t))))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 96, "code": "(fn is-sym?\n  ([t]\n       (is-sym? (second t) (last t)))\n  ([l r]\n       (and\n        \t(= (first l) (first r))\n        \t(or\n         \t\t(and (nil? (second l)) (nil? (second r)))\n          \t\t(is-sym? (second l) (last r)))\n        \t(or\n         \t\t(and (nil? (last l)) (nil? (last r)))\n          \t\t(is-sym? (last l) (second r))))))", "user": "55cae949e4b0e31453f649fe"}, {"problem": 96, "code": "(fn [[x y z]]\n  (letfn [(swap [[a b c]] (conj [] a (if (vector? c) (swap c) c) (if (vector? b) (swap b) b) ))] \n    (cond\n      (and (vector? y) (vector? z)) (= y (swap z))\n      (= y z) true \n      :else false)))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 96, "code": "(fn [t]\n    (= t\n       ((fn rt [x] (if (sequential? x) (let [[v l r] x] [v (rt r) (rt l)]) x)) t)))", "user": "55773cbae4b05c286339e07f"}, {"problem": 96, "code": "(fn [t]\n                        (let [rotate (fn rotate [t]\n                                       (if (nil? t)\n                                         nil\n                                         (cons (first t) (cons (rotate (nth t 2)) (cons (rotate (nth t 1)) ())))))]\n                          (= (nth t 1) (rotate (nth t 2)))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 96, "code": "(fn beautiful? [tree] (letfn [(mirror [[v l r :as xs]]\n  (if (nil? xs)\n    nil\n    (list v (mirror r) (mirror l))))]\n  (= (second tree) (mirror (last tree)))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 96, "code": "(fn is-symmetric [tree]\n  (letfn [\n    (mirror [t]\n      (if (nil? t) nil\n        (let [[root left-child right-child] t]\n          [root (mirror right-child) (mirror left-child)]\n        )\n      )\n    )\n  ]\n  (= tree (mirror tree))\n  )\n)", "user": "51f09f3de4b0274c496158d7"}, {"problem": 96, "code": "(fn mirror? [[root left-child right-child]]\n   (= left-child\n      ((fn mirror [branch]\n         (if-not (coll? branch)\n           branch\n           [(first branch)\n            (mirror (last branch))\n            (mirror (second branch))]))\n       right-child)))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 96, "code": "(fn is-symt? [coll]\n  (letfn [(rev-tree [coll]\n              (let [v (first coll)\n                    l (second coll)\n                    r (last coll)]\n                (conj [] v\n                      (if (coll? r) (rev-tree r) r)\n                      (if (coll? l) (rev-tree l) l))))]\n    (= (second coll) (rev-tree (last coll)))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 96, "code": "(fn [[root rl rr]]\n  (\n   (fn is-eq [a b]\n    (let [[v1 l1 r1 :as node] a\n          [v2 l2 r2] b]\n      (if (= v1 v2)\n        (if (nil? node)\n          true\n          (and (is-eq l1 r2)\n               (is-eq r1 l2)))\n        false))) \n   rl rr))", "user": "55d06bcbe4b0e31453f64a3a"}, {"problem": 96, "code": "(fn this [xs] (let [left (second xs) right (last xs)]\n  (if (or (nil? left) (nil? right))\n    (and (nil? left) (nil? right))\n    (and\n      (= (first left) (first right))\n      (this (conj [:a] (second left) (last right)))\n      (this (conj [:a] (last left) (second right)))\n  ))))", "user": "55d79b87e4b0e31453f64aa8"}, {"problem": 96, "code": "(fn sym? [[_ l r]]\n  (letfn [(rev [[a b c :as node]]\n            (if (= nil node) node\n              [a (rev c) (rev b)]))]\n    (= l (rev r))))", "user": "558bb38fe4b0277789237631"}, {"problem": 96, "code": "(fn [[rt l r]]\n  (letfn [(is-mirror? [a b]\n                      (cond \n                       (not= (sequential? a) (sequential? b)) false\n                       (sequential? a) (let [[rta la ra] a\n                                             [rtb lb rb] b]\n                                         (and (= rta rtb) \n                                              (is-mirror? la rb)\n                                              (is-mirror? ra lb))\n                                         )\n                       :else (= a b)))]\n    (is-mirror? l r)\n    ))", "user": "4f88ae35e4b033992c121c6d"}, {"problem": 96, "code": "(fn symmetric-binary-tree? [xs]\n  (letfn [(binary-tree? [xs]\n              (letfn [(valid-node? [col idx]\n                        (let [elem (nth col idx)]\n                          (if (nil? elem)\n                            true\n                            (and (coll? elem) (binary-tree? elem)))))]\n                (if (= 3 (count xs))\n                  (and\n                   (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))\n                  false)))\n          (symmetric? [left right]\n            (if (or (coll? left) (coll? right))\n              (and (and (coll? left) (coll? right))\n                   (= (first left) (first right))\n                   (symmetric? (second (rest left)) (first (rest right)))\n                   (symmetric? (first (rest left))  (second (rest right))))\n              (= left right)))]\n    (and (binary-tree? xs) (symmetric? (first (rest xs)) (second (rest xs))))))", "user": "534056fce4b085b17e897dac"}, {"problem": 96, "code": "(fn [t]\n  ((fn is-symmetrical? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (is-symmetrical? (second l) (last r))\n                  (is-symmetrical? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 96, "code": "(fn [t]\n  (let [ismf (fn f [r l]\n            (or\n              (and (nil? r) (nil? l))\n              (and\n                (= (first l) (first r))\n                (f (second l) (last r))\n                (f (last l) (second r)))))]\n    (ismf (second t) (last t))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 96, "code": ";(fn mirror-tree?\n;  ([[_ left right]] \n;    (mirror-tree? left right))\n;  ([t1 t2]\n;   (or \n;      (and (nil? t1) (nil? t2))\n;      (let [[v1 l1 r1] t1\n;            [v2 l2 r2] t2]\n;        (and (= v1 v2)\n;             (mirror-tree? l1 r2)\n;             (mirror-tree? r1 l2))))))\n        \n(fn [[x y z]]\n  (letfn [(swap [[a b c]] \n            (prn a b c)\n            (conj [] \n                  a \n                  (if (vector? c) (swap c) c) \n                  (if (vector? b) (swap b) b) ))] \n    (cond\n      (and (vector? y) (vector? z)) (= y (swap z))\n      (= y z) true \n      :else false)))", "user": "54dce62be4b024c67c0cf78b"}, {"problem": 96, "code": "#(= % ((fn m[t]\n         (if-let [[tt l r] t]\n           [tt (m r) (m l)])) %))", "user": "55dab408e4b0e31453f64ad9"}, {"problem": 96, "code": "#(= % ((fn toggle [tree] (if (empty? tree) nil\n                             (list (first tree)\n                                   (toggle (last tree))\n                                   (toggle (second tree))))) %))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 96, "code": "(fn symmetry? [[root left right]]\n  (letfn[(mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[root-a left-a right-a] a \n                                          [root-b left-b right-b] b]\n                                       (and (= root-a root-b) (mirror? left-a right-b) (mirror? right-a left-b)))\n                    :else (= a b)))]\n    (mirror? left right)))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(reverse-tree [tar]\n                        (println tar)\n                        (if (coll? tar)\n                          [(first tar) (reverse-tree (nth tar 2)) (reverse-tree (nth tar 1))]\n                          tar))]\n    (= (second t) (reverse-tree (nth t 2)))))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 96, "code": "(fn sym-tree?\n  [[head ltree rtree]]\n  (letfn [(get-row [row] (reduce get-childs [[][]] row))\n          (get-childs [[row s-trees] [head ltree rtree]] [(conj row head) (conj s-trees (process-node ltree) (process-node rtree))])\n          (process-node [node] (if (nil? node) [nil nil nil] (vec node)))\n          (palindrome? [row] (= (reverse row) row))]\n    (loop [[row sub-trees] (get-row (conj [(process-node ltree)] (process-node rtree)))]\n      (cond\n        (every? nil? row) true\n        (not (palindrome? row)) false\n        :else (recur (get-row sub-trees))))))", "user": "55d93d24e4b0e31453f64ac6"}, {"problem": 96, "code": "#(= ((fn f [n] (if (seq n) [(first n) (f (nth n 2)) (f (nth n 1))] n)) %) %)", "user": "55d1b565e4b0e31453f64a49"}, {"problem": 96, "code": "(letfn [(sym-tree? [left right]\n                   (or (and (nil? left) (nil? right))\n                       (and (not (nil? left))\n                            (not (nil? right))\n                            (= (first left) (first right))\n                        \t(sym-tree? (second left) (last right))\n                        \t(sym-tree? (last left) (second right)))))]\n  #(sym-tree? (second %) (last %)))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 96, "code": "#((fn mir? [p q] (or (and (nil? p) (nil? q))\n                     (and (coll? p) (coll? q)\n                          (= (first p) (first q))\n                          (mir? (nth p 1) (nth q 2))\n                          (mir? (nth p 2) (nth q 1)))))\n  % %)", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 96, "code": "(fn sym? [t] \n  (letfn [(traverse [t f g] \n            (if (coll? t)\n              (cons (first t)(concat (traverse (f t) f g)(traverse (g t) f g)))\n              (list t)))\n          (left-first  [t] (traverse t second last))\n          (right-first [t] (traverse t last second))]\n\n    (= (left-first t)(right-first t))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 96, "code": "(fn prob96 [[_ l r]]\n  (if (not (coll? l))\n    true\n    (if (not (and (coll? l) (coll? r)))\n      false\n      (let [[lv ll lr] l\n            [rv rl rr] r]\n        (and (= lv rv) (prob96 [nil ll rr]) (prob96 [nil rl lr]))\n))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 96, "code": "(let\n    [otoc (fn otoc[tree]\n            (if (nil? tree) \n              tree\n              (let [[aname l r] tree]\n                [aname (otoc r) (otoc l)]\n                )))]\n    (fn [[name l r]]\n      (= (otoc l) r)))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 96, "code": "#(= % ((fn mirro[t]\n     (if (coll? t)\n       (let [[c l r] t] [c (mirro r) (mirro l)])\n       t)) %))", "user": "54d05a9de4b0e8a36923e5c7"}, {"problem": 96, "code": "(fn [[t l r]]\n  ((fn symmetric? [s t]\n     (cond (and (nil? s) (nil? t)) true\n           (or (nil? s) (nil? t)) false\n           :descend\n           (and (= (first s) (first t))\n                (symmetric? (second (rest s)) (second t))\n                (symmetric? (second s) (second (rest t))))))\n   l r))", "user": "55ba4a78e4b01b9910ae29cf"}, {"problem": 96, "code": "(fn beat [thetree] (letfn[(eqtree? [tree1 tree2] (and (= (first tree1) (first tree2)) \n(if (and (nil? (nth tree1 2)) (nil? (second tree2))) true\n(if (and (not (nil? (nth tree1 2))) (not (nil? (second tree2)))) (eqtree? (nth tree1 2) (second tree2))\nfalse))\n(if (and (nil? (second tree1)) (nil? (nth tree2 2))) true\n(if (and (not (nil? (second tree1))) (not (nil? (nth tree2 2)))) (eqtree? (second tree1) (nth tree2 2))\nfalse))))] (eqtree? (second thetree) (nth thetree 2))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 96, "code": "(fn [[v l r]]\n  (= l ((fn mirror [t]\n          (when-let [[v l r] t] [v (mirror r) (mirror l)]))\n        r)))", "user": "553698fae4b09218d5f44fc0"}, {"problem": 96, "code": "(fn beauty? [tree]\n  (= tree\n     (clojure.walk/postwalk (fn [forms]\n                              (if (sequential? forms)\n                                (conj (reverse (rest forms)) (first forms))\n                                forms))\n                            tree)))", "user": "50e3e108e4b01912b3285c48"}, {"problem": 96, "code": "#(= (map first (tree-seq next rest %)) (map first (tree-seq next (comp reverse rest) %)))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 96, "code": "(fn [[_ left right]]\n  ;     _\n  ;   /   \\\n  ;left   right\n  (letfn [(symetry? [[nodel ll lr] [noder rl rr]]\n                    ;      nodel         noder \n                    ;      /   \\         /   \\\n                    ;     ll   lr       rl   rr\n                    (if nodel\n                       (and \n                        (= nodel noder) \n                        (symetry? ll rr) \n                        (symetry? lr rl))\n                      ; there is no need to check symetry\n                      true))]\n     (symetry? left right)))", "user": "4ec7c32c535d6d7199dd36e6"}, {"problem": 96, "code": "(letfn [(leaf? \n         ([x] (not (sequential? x))))\n        (mirror-of? \n         ([a]\n          (or (nil? a)\n              (let [[_ left-a right-a] a]\n                (mirror-of? left-a right-a))))\n         ([a b]\n          (or (and (nil? a)\n                   (nil? b))\n              (let [[value-a left-a right-a] a\n                    [value-b left-b right-b] b]\n                (and  (= value-a value-b)\n                      (mirror-of? left-a right-b)\n                      (mirror-of? left-b right-a))))))]\n  mirror-of?)", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 96, "code": "#(let [left (second %)\n       right (last %)\n       walk (fn walk\n              [t [p c1 c2 :as fs]]\n              (if (nil? t)\n                [nil]\n                (concat [(p t)]\n                        (walk (c1 t) fs)\n                        (walk (c2 t) fs))))]\n   (= (walk left [first second last])\n      (walk right [first last second])))", "user": "55d5ee3fe4b0e31453f64a92"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond \n                   (not= (sequential? a) (sequential? b)) false\n                   (sequential? a) (let [[rta la ra] a\n                                         [rtb lb rb] b]\n                                     (and (= rta rtb) (mirror? la rb) (mirror? lb ra)))\n                   :else (= a b)))]\n    (mirror? left right)))", "user": "55af3e6be4b03311e7b732c7"}, {"problem": 96, "code": "(fn [coll]\n  ((fn symmetric? [left right]\n     (or\n      (and (nil? left) (nil? right))\n      (and\n       (coll? left)\n       (coll? right)\n       (= (first left) (first right))\n       (symmetric? (nth left 1) (nth right 2))\n       (symmetric? (nth right 1) (nth left 2))))) (nth coll 1) (nth coll 2)))", "user": "55f4ef68e4b06e875b46ce82"}, {"problem": 96, "code": "(fn symmetric?\n  [tree]\n  (letfn [(v [tree]\n                 (first tree))\n          (left [tree]\n                (first (rest tree)))\n          (right [tree]\n                (last (rest tree)))\n          (sym= [leaf1 leaf2]\n             (if (= nil leaf1 leaf2)\n               true\n               (and\n                 (= (v leaf1) (v leaf2))\n                 (sym= (left leaf1) (right leaf2))\n                 (sym= (right leaf1) (left leaf2)))))]\n    (sym= (left tree) (right tree))))", "user": "55996253e4b031d6649c9baa"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [t]\n  ((fn st [lt rt]\n     (when (= lt rt) true)\n     (if-not (or lt rt) false)\n     (if-not (and (coll? lt) (coll? rt))\n      (= lt rt)\n      (and\n        (= (first lt) (first rt))\n        (st (second lt) (last rt))\n        (st (last lt) (second rt))))) (second t) (last t)))", "user": "5574c172e4b05c286339e059"}, {"problem": 96, "code": "( fn sym-tree [[v left right]]\n      ((fn sym-branch [[v1 l1 r1] [v2 l2 r2]]\n             (if  (= v1 v2)\n               (if (and (nil? l1) (nil? r1) (nil? l2) (nil? r2))\n                 true\n                 (and (sym-branch l1 r2) (sym-branch r1 l2)))\n               false)) left right))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 96, "code": "(fn simetric-tree? [t]\n  (letfn [(reverse-tree [t]\n            (let [a (first t)\n                  b (second t)\n                  c (last t)]\n              (cond\n                (not (coll? t)) t\n                :else (reverse (conj (list a)\n                                     (if (coll? c) (reverse-tree c) c)\n                                     (if (coll? b) (reverse-tree b) b))))))\n          ]\n    (if (= (reverse-tree (second t)) (reverse (into ()(last t)))) true\n        false)))", "user": "55f8180fe4b06e875b46ceba"}, {"problem": 96, "code": "; wow -- argument destructuring sure is powerful (from adereth's solution)\n(fn symmetric? [[v l r]]\n  (letfn [(mirror [[v l r]] [\n                             v \n                             (if (nil? r) nil (mirror r))\n                             (if (nil? l) nil (mirror l))\n                             ])]\n    (= l (mirror r))))\n\n; first try -- lots of validation\n#_(fn symmetric? [t]\n    (letfn [\n            (value [t] (first t))\n            (left [t] (second t))\n            (right [t] (last t))\n            (branch? [t] (or (nil? t) (and (coll? t) (= 3 (count t)))))\n            (node? [t] (and (branch? (left t)) (branch? (right t))))\n            (match? [t1 t2]\n                    (cond\n                      (nil? t1) (nil? t2)\n                      (nil? t2) false\n                      (not= (value t1) (value t2)) false\n                      (not-every? branch? [(left t1) (right t1) (left t2) (right t2)]) false\n                      :else (and (match? (left t1) (right t2)) (match? (right t1) (left t2)))))\n            ]\n      (and (node? t) (match? (left t) (right t)))))", "user": "55e7d06ee4b050e68259b496"}, {"problem": 96, "code": "(letfn [(mirror-tree [tree]\r\n          (if (coll? tree)\r\n            (let [[root & branches] tree]\r\n              `[~root ~@(map mirror-tree (reverse branches))])\r\n            tree))]\r\n  (fn symmetric? [[root tree1 tree2]]\r\n    (= tree1 (mirror-tree tree2))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 96, "code": "#(= \n  ((fn mirror \n     [[n l r :as tree]] \n     (when tree [n (mirror r) (mirror l)])) %) \n  %)", "user": "559e6f42e4b08a52bd4f97d3"}, {"problem": 96, "code": "(fn symmetery? \n  ([tree] (if (or (not (coll? tree)) (not= 3 (count tree))) false (symmetery? (nth tree 1) (nth tree 2))))\n  ([tree1 tree2]\n   (if (and (= (first tree1) (first tree2)) (= nil (nth tree1 1) (nth tree1 2) (nth tree2 1) (nth tree2 2))) true\n     (if (or (and (coll? (nth tree1 1)) (not (coll? (nth tree2 2))))  \n             (and (not (coll? (nth tree1 2))) (coll? (nth tree2 1)))) false\n         (if (and (coll? (nth tree1 1)) (coll? (nth tree2 2))) (symmetery? (nth tree1 1) (nth tree2 2))\n           (if (and (coll? (nth tree1 2)) (coll? (nth tree2 1))) (symmetery? (nth tree1 2) (nth tree2 1)) false\n         )))))\n  )", "user": "558bdcefe4b0277789237633"}, {"problem": 96, "code": "(fn im? [root] \n        (letfn [(im2? [[x1 x2 x3 :as x] [y1 y2 y3 :as y]]\n                  (or (= x y nil) (and (= x1 y1) (im2? x2 y3) (im2? x3 y2))))]\n          (im2? root root)))", "user": "5361d423e4b0243289761e49"}, {"problem": 96, "code": "(fn nodes-eq\n  ([node] (nodes-eq (second node) (last node)))\n  ([node-a node-b]\n   (let [notcoll? (complement coll?)]\n     (if (or (notcoll? node-a) (notcoll? node-b))\n       (= (nil? node-a) (nil? node-b))\n       (and (= (first node-a) (first node-b))\n            (nodes-eq (second node-a) (last node-b))\n            (nodes-eq (last node-a) (second node-b)))))))", "user": "56041883e4b0c80df0ca2655"}, {"problem": 96, "code": "(fn issymmetric?[root]\n  (letfn [(mirror [t] (if (nil? t) nil\n                        (let [v (first t) left (second t) right (nth t 2)]\n                          (vector v (mirror right) (mirror left)))\n         ))]\n  (= (second root) (mirror (nth root 2))))\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 96, "code": "(fn [t]\n  (let [rtree (fn revtree [tree]\n                (if (nil? tree)\n                  nil\n                  [(first tree) (revtree (last tree)) (revtree (second tree))]))]\n    (= (second t) (rtree (last t)))))", "user": "56051095e4b08b23635d3162"}, {"problem": 96, "code": "(fn [t0]\n  (letfn [(flip [t]\n               (if-let [[v l r] (seq t)]\n                 [v (flip r) (flip l)]\n                 nil)\n               )]\n    (= t0 (flip t0))))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 96, "code": "(fn [xs]\n    (letfn [(mirror [xs]\n              (let [[n ls rs] xs]\n                (cond\n                  (nil? xs) []\n                  :else (concat [n] [(cond\n                                       (sequential? rs) (mirror rs)\n                                       :else rs)]\n                                [(cond (sequential? ls) (mirror ls)\n                                       :else ls)]))))]\n      (= xs (mirror xs))))", "user": "560e9a2de4b05f002753df52"}, {"problem": 96, "code": "#(letfn [(mirror [node]\n                 (if (nil? node)\n                   nil\n                   [(first node)\n                    (mirror (nth node 2))\n                    (mirror (second node))]))]\n   (= (second %) (mirror (nth % 2))))", "user": "532ecd44e4b019098a6f8b49"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(tseq [t]\n            (if (seq t)\n              (concat (tseq (second t))\n                      [(first t)]\n                      (tseq (nth t 2)))))]\n    (= (tseq left) (seq (reverse (tseq right))))))", "user": "55a5c3bee4b0acc240e3154e"}, {"problem": 96, "code": "(fn symtree? [bintree]\n  (= (second bintree) \n     ((fn deepswap [bintree]\n        (if (every? nil? (rest bintree)) \n          bintree\n          (conj (reverse (map deepswap (rest bintree))) \n                (first bintree)))) (last bintree))))", "user": "5603d057e4b0c80df0ca264e"}, {"problem": 96, "code": "(fn [[x y z]]\n  (letfn  [(sym [xs]\n     (if (sequential? xs)\n       [(first xs) (sym (nth xs 2)) (sym (second xs))]\n       xs))]\n    (= (last (sym [x y z])) z)))", "user": "54a677a9e4b09f271ff37c88"}, {"problem": 96, "code": "(fn sym? [c]\n  (letfn [(mirrorImages? [l r] (or (and (nil? l) (nil? r)) \n                                       (and (= (first l) (first r))\n                                            (mirrorImages? (second l) (last r)) \n                                            (mirrorImages? (last l) (second r))))\n                          )\n        ]\n    (mirrorImages? (second c) (last c))\n    ))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(mirror [[v l r]] (when v [v (mirror r) (mirror l)]))]\n    (= tree (mirror tree))))", "user": "552356fae4b0882d96d091af"}, {"problem": 96, "code": "#(= % \n    ((fn _ [[n l r]] \n       (if n [n (_ r) (_ l)])) %))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 96, "code": "(fn sym? [tree]\n  (letfn [(binarytree? [tree]\n                       (and\n                        (coll? tree)\n                        (= (count tree) 3))\n                        (every? true? (map binarytree? (filter (complement nil?) (rest tree)))))\n          (mirror [tree]\n            (if-not (nil? tree)\n              (vector (first tree) (-> tree last mirror) (-> tree second mirror))))]\n    (if (binarytree? tree)\n      (= (second tree) (-> tree last mirror))\n      false)))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 96, "code": "(fn [tree]\n    (let [[v l r] tree\n          flippedr ((fn flip [coll]\n                     (if (or (nil? coll) (empty? coll)) nil\n                         (list ( first coll)\n                               (flip (nth coll 2))\n                               (flip (nth coll 1)))))\n                   r)]\n      \n     (= l flippedr)))", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 96, "code": "(fn symmetric-tree? [tree]\n  (letfn [(third [coll] (-> coll rest second))\n          (visit [branch f g]\n            (let [leaf-a (f branch)\n                  leaf-b (g branch)]\n              (lazy-cat (list (first branch))\n                        (when leaf-a (visit leaf-a f g))\n                        (when leaf-b (visit leaf-b f g)))))]\n    (every? identity\n      (map =\n           (visit (second tree) second third)\n           (visit (third tree) third second)))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 96, "code": "(fn [[v l r]]\n    (letfn [(exch [a]\n              (if (coll? a) (let [[v l r] a]\n                              [v (exch r) (exch l)])))]\n      (= l (exch r))))", "user": "532f8569e4b019098a6f8b4f"}, {"problem": 96, "code": "(fn c [[v l r]]\n  (letfn [(swap [[v l r]]\n                [v (if (coll? r)\n                     (swap r) r)\n                   (if (coll? l)\n                     (swap l) l)])]\n    (= l (swap r))))", "user": "55b1e9e7e4b0da326a65cf74"}, {"problem": 96, "code": "(fn [t]\n  (= t\n     ((fn mirror [mt]\n       (if (nil? mt)\n         nil\n         (let [[v l r] mt]\n           [v (mirror r) (mirror l)]))) t)))", "user": "4f0f01c0535d0136e6c22329"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(mirror [[v l r :as tree]]\n            (when tree\n              [v (mirror r) (mirror l)]))]\n    (= tree (mirror tree))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 96, "code": "(fn mirror? \n  ([tree] (mirror? (second tree) (last tree)))\n  ([a b] \n   (cond \n    (and (nil? a) (nil? b)) true\n    (or (nil? a) (nil? b)) false\n    :else (and \n           (= (first a) (first b))\n           (mirror? (second a) (last b)) \n           (mirror? (last a) (second b))))))", "user": "560039cce4b04bb52996e162"}, {"problem": 96, "code": "(fn sym? [[head left-child right-child]]\n  (if (and (nil? left-child) (nil? right-child))\n    true\n    (and (= (first left-child) (first right-child))\n         (sym? [(first left-child) (last left-child) (second right-child)])\n         (sym? [(first right-child) (second left-child) (last right-child)]))))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 96, "code": "(fn [[v left right :as node]] \n     (letfn [(mirror [[v left right :as node]] \n\t\t     (if (coll? node) [v (mirror  right) (mirror left)]\n\t\t       node))]\n\t    (= (mirror left) right))\n     )", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 96, "code": "(fn [t]\n  (= t ((fn mirror [[n l r :as t]]\n          (if (seq t)\n            (cons n (cons (mirror r) (list (mirror l))))\n            t)) t)))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 96, "code": "#(letfn [(flip [x] (if-let [[v l r] x]\n                     [v (flip r) (flip l)]\n                     nil))]\n   (= % (flip %)))", "user": "5566463ee4b0c656e3ff1831"}, {"problem": 96, "code": "(fn [T] (= (nth T 1) ((fn R [t] (let [[a b c] t] (if a [a (R c) (R b)] a))) (nth T 2))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 96, "code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b](or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 96, "code": "(fn symmetric-tree?\n  ([t] (symmetric-tree? (second t) (nth t 2)))\n  ([left right]\n   (if (or (nil? left) (nil? right))\n     (and (nil? left) (nil? right))\n     (and (= (first left) (first right))\n          (symmetric-tree? (second left)(nth right 2))\n          (symmetric-tree? (second right) (nth left 2))))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 96, "code": "(fn sym? [[a b c]]\n  (or (and (nil? b) (nil? c))\n      (and (= (first b) (first c))\n           (sym? [nil (second b) (nth c 2)])\n           (sym? [nil (nth b 2) (second c)]))))", "user": "53fcd574e4b0de5c418485d9"}, {"problem": 96, "code": "(fn beauty-is-symmetry-solution\n  [arg] \n  (let [[root left-child right-child] arg\n        unsymmetrify (fn unsymmetrify [collect]\n                       (let [[root left-child right-child] collect]\n                         (if (= root nil)\n                           nil\n                           [root (unsymmetrify right-child) (unsymmetrify left-child)])))]\n    (if (= left-child (unsymmetrify right-child))\n      true\n      false)))", "user": "561fc0d0e4b064ca9f4b16d2"}, {"problem": 96, "code": "(fn beauty-is-symmetry-solution [args]\n  (letfn [(aresideseql? [left right] \n            (if (and (nil? left) (nil? right))\n              true\n             (and \n               (= (first left) (first right))  \n               (aresideseql? (second left) (last right))\n               (aresideseql? (last left) (second right))\n              )\n             )            \n          ) ] \n    (aresideseql? (second args) (last args)))\n  )", "user": "536829c8e4b0243289761e8b"}, {"problem": 96, "code": "(fn symTree[tree]\n  (letfn [(tree-equals[a b]\n                      (if (coll? a)\n                        (let [fa (first a) c1a (second a) c2a (last a)\n                              fb (first b) c1b (second b) c2b (last b)]\n                          (and (= fa fb)\n                               (and (tree-equals c2a c1b)\n                                    (tree-equals c1a c2b))))\n                        (= a b)))]\n    (tree-equals (second tree) (last tree))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 96, "code": "(fn symmetric-tree? [[_ l r]]\n  (let [mirror\n        (fn mirror [[x l r]]\n          [x (if r (mirror r))\n             (if l (mirror l))])]\n    (= l (mirror r))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 96, "code": "(fn bt? [tree]\n  (letfn [(bt [t l?] \n            (if (coll? t)\n              (concat [(first t)] \n                      (if l? (bt (second t) l?) (bt (last t) l?)) \n                      (if l? (bt (last t) (not l?)) (bt (second t) (not l?))))\n              [t]))]\n    (= (bt (second tree) true) (bt (last tree) false))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 96, "code": "(fn symetric? [[_ left right]]\n    (letfn [(mirror [[node l r]] (conj [node] (if (sequential? r) (mirror r) r) (if (sequential? l) (mirror l) l)))]\n      (= left (mirror right))))", "user": "561cb6cfe4b064ca9f4b169e"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirrored?\n           [x y]\n           (cond (and (nil? x) (nil? y)) true\n                 (or (nil? x) (nil? y)) false\n                 (not (= (first x) (first y))) false\n                 :default (and (mirrored? (second x) (last y))\n                               (mirrored? (last x) (second y)))))]\n    (mirrored? l r)))", "user": "54485749e4b032a45b8693c7"}, {"problem": 96, "code": "(fn [coll]\n   (let [walk-fn (fn [xs mirror?]\n                   (clojure.walk/postwalk\n                     (fn [form]\n                       (if (and mirror?\n                                (coll? form))\n                         [(first form) (last form) (second form)]\n                         form))\n                     xs))]\n     (= (walk-fn (second coll) false)\n        (walk-fn (last coll) true))))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 96, "code": "(fn symmetric? [[val left right]]\n   (if (and (nil? left) (nil? right))\n     true\n     (letfn [(mirror? [tree1 tree2]\n                      (if (and (nil? tree1) (nil? tree2))\n                        true\n                        (let [[v1 l1 r1] tree1\n                              [v2 l2 r2] tree2]\n                          (and \n                           (= v1 v2)\n                           (mirror? l1 r2)\n                           (mirror? r1 l2)))))]\n       (mirror? left right))))", "user": "563772a9e4b0bfe05bf117d7"}, {"problem": 96, "code": "#(letfn \n  [(mirror [x]\n   (if (coll? x)\n     (vector (first x) (mirror (last x)) (mirror (second x)))\n     x ))] \n  (= % (mirror %)) )", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 96, "code": "(fn\n  [[value left right]]\n  (letfn [(flat-tree\n    [node]\n    (if (nil? node)\n      nil\n      (let [[value left right] node]\n        (concat (flat-tree left) [value] (flat-tree right))\n        )\n      )\n    )]\n\n    (= (flat-tree left) (reverse (flat-tree right)))\n    )\n  )", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 96, "code": "(fn sym-tree? [tree]\n(letfn [(eq-trees? [a b]\n  (or\n    (= nil a b)\n    (and\n      (coll? a)\n      (coll? b)\n      (= (first a) (first b))\n      (let [[a2 a3] (rest a)\n            [b2 b3] (rest b)]\n        (and\n          (eq-trees? a2 b3)\n          (eq-trees? a3 b2))))))]\n  (eq-trees? (second tree) (last tree))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 96, "code": "#(letfn [(m [[v l r]] [v (if r (m r)) (if l (m l))])]\n  (= % (m %)))", "user": "561047eae4b05f002753df6d"}, {"problem": 96, "code": "(fn is-symmetric [tree]\n  (let [mirror\n        (fn mirror [node]\n          (if (nil? node) nil\n            (vector (first node) (mirror (nth node 2))  (mirror (nth node 1)))))]\n    (= (nth tree 1) (mirror (nth tree 2)))\n  )\n)", "user": "56393681e4b0bfe05bf117f2"}, {"problem": 96, "code": "(fn symm-binary-tree [s]\n  (letfn [(mirror-tree [arg]\n                       (if (coll? arg) \n                         [(first arg) (mirror-tree (last arg)) (mirror-tree (second arg))]\n                         arg))\n          (binary-tree [s]\n                       (cond\n                        (nil? s) true\n                        (not (coll? s)) false\n                        (not= 3 (count s)) false\n                        :else (and (binary-tree (second s)) (binary-tree (last s)))))]\n    (and (= (second s) (mirror-tree (last s)))\n         (binary-tree s))))", "user": "55d29fb6e4b0e31453f64a59"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [\n        (dfs [node visited]\n          (cond (and (nil? (second node)) (nil? (last node))) (first node)\n                (nil? node) nil\n                :else\n                (conj visited\n                      (map #(dfs %1 visited) (rest node)))))]\n    (= (flatten (dfs tree []))\n       (reverse (flatten (dfs tree []))))))", "user": "545c2d07e4b01be26fd7465c"}, {"problem": 96, "code": "(fn symmetric?\n  [t]\n  (let [mirror (fn mirror [t]\n                 (if (nil? t)\n                   t\n                   (let [[v left right] t]\n                     [v (mirror right) (mirror left)])))]\n    (let [[_ left right] t]\n      (= (mirror left) right))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 96, "code": "(fn symmetrical?\n  ([[_ l r]]\n   (if (every? coll? [l r])\n     (symmetrical? l r)\n     (= l r)))\n  ([[lv ll lr] [rv rl rr]]\n   (and\n     (= lv rv)\n     (symmetrical? [0 ll rr])\n     (symmetrical? [0 lr rl]))))", "user": "50cf94bde4b0abc485cb9bb2"}, {"problem": 96, "code": "(fn [T] (let  [s ((fn f [t] (if-let [ [n l r] t]\n        \t(concat (f l) [n] (f r)))) T)]\n    (= s (reverse s))))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 96, "code": "(fn [[_ b c]]\n  (let [f (fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false))]\n    (f b c)))", "user": "563ed73ae4b08d4f616f5ecb"}, {"problem": 96, "code": "(fn symmetrical-binary-tree?\n  [tree]\n  (letfn [(f [[v l r]]\n            (list\n             v\n             (if (sequential? l) (f (list (first l) (last l) (second l))) l)\n             (if (sequential? r) (f (list (first r) (last r) (second r))) r)))]\n    (let [tree' (f tree)]\n      (= (second tree') (last tree'))\n      (and (= (second tree') (last tree)) (= (second tree) (last tree'))))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 96, "code": "(fn is_sym [x]\n      (let [is_mirror_tree (fn is_mirror_tree [n1 n2] \n                             (and (= (first n1) (first n2))\n                                (or (= (nth n1 1) (nth n2 2) nil)\n                                    (is_mirror_tree (nth n1 1) (nth n2 2)))\n                                (or (= (nth n1 2) (nth n2 1) nil)\n                                    (is_mirror_tree (nth n1 2) (nth n2 1)))))]\n        (if (or (= (nth x 1) (nth x 2) nil)\n              (is_mirror_tree (nth x 1) (nth x 2)))\n        true false))\n        )", "user": "5632b0a9e4b0bfe05bf117a8"}, {"problem": 96, "code": "(fn [node]\n  (letfn [(mirror [node]\n             (if (nil? node) nil\n                 (let [[value left right] node]\n                   [value (mirror right) (mirror left)])))]\n\n    (let [[value left right] node]\n      (= left (mirror right)))))", "user": "4f213e2ee4b0d66497709fcf"}, {"problem": 96, "code": ";This was kind of a half-hearted attempt to get the first couple to go green. \n  ;I was successful but it fails for the more complex trees.\n  \n;  (fn [coll]\n;    (if (= (second coll) (second (drop 1 coll)))\n;      true\n;      false))\n  \n  ; This is a really good example.\n  #(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 96, "code": "(fn [root]\n  (let [symmetric? (fn is-symmetric? [a b] \n                       (if (and a b)\n                         (let [[av al ar] a [bv bl br] b]\n                           (and (= av bv)\n                                (and (is-symmetric? al br) (is-symmetric? ar bl))))\n                         (= a b)))]\n    (if root\n      (let [[v l r] root] (symmetric? l r))\n      true)))", "user": "545e7ab0e4b01be26fd7467c"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(swap [[root left right]] [root (if right (swap right)) (if left (swap left))])]\n    (= left (swap right))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (= (second t) ((fn mirror [tree]\n                   (if (nil? tree)\n                     tree\n                     (list (first tree) (mirror (nth tree 2)) (mirror (second tree))))) \n                 (nth t 2))))", "user": "563d12f9e4b0bfe05bf11845"}, {"problem": 96, "code": "(fn [[v a b]] \n  (letfn [(areMirrored [t1 t2]\n                    (or (= nil t1 t2)\n                        (and\n                         (not (or (nil? t1) (nil? t2)))\n                         (= (first t1) (first t2))\n                         (areMirrored (second t1) (last t2))\n                         (areMirrored (second t2) (last t1))\n                        )\n                       ))]\n    (areMirrored a b)\n    )\n  )", "user": "55e8a85be4b0121d4835fd98"}, {"problem": 96, "code": "#(letfn [(mirror [t]\n            (when-let [[val l r] t]\n              [val (mirror r) (mirror l)]))]\n       (if-let [[val l r] %]\n         (= l (mirror r))\n         (nil? %)))", "user": "560bb1f7e4b05f002753df20"}, {"problem": 96, "code": "(fn [s]\n\t(let [a (second s) b (last s)]\n\t\t(letfn\n\t\t\t[(mirror [s]\n\t\t\t\t(let [x (second s) y (last s)]\n\t\t\t\t\t(if\n\t\t\t\t\t\t(and (nil? x) (nil? y))\n\t\t\t\t\t\ts\n\t\t\t\t\t\t(list (first s)\n\t\t\t\t\t\t\t(if (nil? y) y (mirror y))\n\t\t\t\t\t\t\t(if (nil? x) x (mirror x))))))]\n\t\t\t(= a (mirror b)))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 96, "code": "(fn [tree]\n    (let [[root left right] tree\n          tree-mirror (fn tree-mirror [tree]\n                        (if (nil? tree)\n                          tree\n                          (let [[value left-branch right-branch] tree]\n                            (vector value\n                                    (tree-mirror right-branch)\n                                    (tree-mirror left-branch)))))]\n      (= left (tree-mirror right))))", "user": "560434cfe4b0c80df0ca2658"}, {"problem": 96, "code": "(let [flip (fn f [[v l r :as t]] \n             (if (nil? t) \n               nil \n               (vector v (f r) (f l))))]\n  (fn [[v l r]]\n    (= l (flip r))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 96, "code": "(fn [[a b c]]\n  (boolean \n    (let [f (fn x [[t1 l1 r1] [t2 l2 r2]]\n              (when (= t1 t2)\n                (cond\n                  (and (coll? l1) (coll? r2)) (when-let [b (x l1 r2)] (x [t1 b r1] [t2 l2 b]))\n                  (and (coll? r1) (coll? l2)) (when-let [b (x r1 l2)] (x [t1 l1 b] [t2 b r2]))\n                  (and (= l1 r2) (= r1 l2)) true)))]\n      (f b c))))", "user": "5382704be4b06839e8705ed4"}, {"problem": 96, "code": "(fn symetry-tree? [t]\n  (let [symetry? (fn symetry? [l r]\n                   (cond\n                     (nil? l) (nil? r)\n                     (not (= (first l) (first r))) false\n                     :else (and\n                             (symetry? (second l) (nth r 2))\n                             (symetry? (nth l 2) (second r)))\n                     )\n\n                   )]\n    (if (nil? t)\n      true\n      (symetry? (second t) (nth t 2))\n\n      )\n\n    )\n  )", "user": "563b9acbe4b0bfe05bf11827"}, {"problem": 96, "code": "#(= % ((fn rev [[value left right :as node]] (if node [value (rev right) (rev left)])) %))", "user": "55c13e73e4b01b9910ae2a2f"}, {"problem": 96, "code": "#(let [[v r l] %]\n  ((fn sym? [[lval ll lr] [rval rl rr]]\n    (and \n      (= lval rval)\n      (or \n        (= nil ll rr)\n        (sym? ll rr))\n      (or\n        (= nil lr rl)\n        (sym? lr rl))\n   ))\n   r l))", "user": "5654d0e1e4b0f9d632dd848c"}, {"problem": 96, "code": "(fn bsym ([a b]\n  (or (and (nil? a) (nil? b))\n      (let [[an al ar] a [bn bl br] b] (and (= an bn) (bsym al br) (bsym ar bl)))))\n  ([[n l r]] (bsym l r)))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 96, "code": "(fn [t]\n    (letfn [(mirror\n             [t]\n             (if (coll? t)\n               [(first t) (mirror (nth t 2)) (mirror (second t))]\n               t))]\n      (if (coll? t)\n        (= (second t) (mirror (nth t 2)))\n        true)))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 96, "code": "(fn symm? [tree] (=\n               \t(nth tree 1)\n                ((fn mirr [branch] (if (sequential? branch)\n                                     (list (first branch) (mirr (nth branch 2)) (mirr (nth branch 1)))\n                                     branch\n                )) (nth tree 2))\n))", "user": "56561119e4b0f9d632dd849d"}, {"problem": 96, "code": "#(let [r (fn t-o-r [l]\n             (if (not (sequential? l))\n                 [l]\n                 (cons (first l)\n                       (concat (t-o-r (nth l 1))\n                               (t-o-r (nth l 2))))))\n                             \n       l (fn t-o-l [l]\n             (if (not (sequential? l))\n                 [l]\n                 (cons (first l)\n                       (concat (t-o-l (nth l 2))\n                               (t-o-l (nth l 1))))))\n       ]              \n\n     (= (l %) (r %)))", "user": "55c49394e4b0e31453f6499e"}, {"problem": 96, "code": "#(= % ((fn t [x]\n  (if (seq x)\n    [(first x) (t (last x)) (t (second x))]\n    x)) %))", "user": "54b2ec84e4b09f271ff37d33"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (let [[_ l r] t]\n    ((fn mirror? [a b]\n       (if (and (coll? a) (coll? b))\n         (let [[v1 l1 r1] a\n               [v2 l2 r2] b]\n           (and (= v1 v2) (mirror? l1 r2) (mirror? l2 r1)))\n         (= a b))\n     ) l r)))", "user": "5643a11ee4b0018b46ad8bfb"}, {"problem": 96, "code": "(fn symmetric? [tree]\n   (letfn [(third [s] (second (next s)))\n           (traverse [tree leftf rightf]\n               (if (nil? tree)\n                 [nil]\n                 (let [left (traverse (leftf tree) leftf rightf)\n                       right (traverse (rightf tree) leftf rightf)\n                       tail (vec (into left right))]\n                   (vec (cons (first tree) tail))\n                   )))]\n     (= (traverse tree second third) (traverse tree third second))\n     ))", "user": "564ecc9ee4b0284900eef6a1"}, {"problem": 96, "code": "(fn [[_ R L]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                   (not= (sequential? a) (sequential? b)) false\n                   (sequential? a) (let [[ra La Ra] a [rb Lb Rb] b]\n                                     (and (= ra rb) (mirror? La Rb) (mirror? Ra Lb)))\n                   :else (= a b)))]\n    (mirror? R L)))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 96, "code": "(fn [[_ left-tree right-tree]]\n  (letfn [(mirror-tree [tree]\n            (letfn [(mirror [node]\n                      (if (coll? node)\n                        (cons (first node) (reverse (rest node)))\n                        node))]\n              (clojure.walk/postwalk mirror tree)))]\n    (= left-tree (mirror-tree right-tree))))", "user": "52c00e32e4b07a9af5792341"}, {"problem": 96, "code": "(fn is-mirror\n       ([x]\n        (if (=(count x) 3)\n          (is-mirror (second x) (last x))\n          false))\n       ([x y]\n         (if (and (coll? x) (coll? y))\n           (and (and (is-mirror (first x) (first y)) (is-mirror (second x) (last y)) (is-mirror (last x) (second y))))\n           (= x y))))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 96, "code": "(fn [arg1]\n(cond\n(and (= arg1 (quote (:a (:b nil nil) (:b nil nil))))) true\n(and (= arg1 (quote (:a (:b nil nil) nil)))) false\n(and (= arg1 (quote (:a (:b nil nil) (:c nil nil))))) false\n(and (= arg1 [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]] [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])) true\n(and (= arg1 [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]] [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])) false\n(and (= arg1 [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]] [2 [3 nil [4 [6 nil nil] nil]] nil]])) false\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 96, "code": "(fn symm [[_ l r]]\n  (letfn [(v [t c1 c2] (if (sequential? t) [(first t) (v (c1 t) c1 c2) (v (c2 t) c1 c2)] t))]\n    (= (v l second last) (v r last second))))", "user": "564b495de4b0284900eef667"}, {"problem": 96, "code": "(fn sym-bin-tree? [x]\n  (letfn [(aux [t t']\n            (if (not= (first t) (first t'))\n              false\n              (if (= nil t)\n                true\n                (and (aux (second t) (last t'))\n                      (aux (last t) (second t'))))))]\n    (aux (second x) (last x))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 96, "code": "(fn [[value left right]]\n               ((fn mirror? [left right]\n                  (cond\n                    (not= (sequential? left) (sequential? right)) false\n                    (sequential? left) (let [[leftValue leftLeft leftRight] left\n                                             [rightValue rightLeft rightRight] right]\n                                         (and (= leftValue rightValue)\n                                              (mirror? leftLeft rightRight)\n                                              (mirror? leftRight rightLeft)))\n                    :else (= left right)\n                    )\n                  ) left right))", "user": "5658b9bde4b00d315579610e"}, {"problem": 96, "code": "(fn mirror\n  ([[_ l r]] (mirror l r))\n  ([t1 t2]\n   (if (nil? t1)\n     (nil? t2)\n     (let [[x1 l1 r1] t1\n           [x2 l2 r2] t2]\n       (and (= x1 x2)\n            (mirror l1 r2)\n            (mirror l2 r1))))))", "user": "565e0934e4b068f2fe63dc30"}, {"problem": 96, "code": ";; http://stackoverflow.com/questions/8436623/check-if-a-binary-tree-is-a-mirror-image-or-symmetric\n(fn mirror [[_ left right]]\n  (or \n   (every? nil? [left right])\n   (and\n    (= (first left) (first right))\n    (mirror [(first left) (second left) (last right)])\n    (mirror [(first right) (last left) (second right)]))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 96, "code": "(fn sym-tree? [coll]\n  (if (coll? coll)\n    (if (= (count coll) 3)\n    \t(= (second coll) (\n    \t\t(fn swap-lr [coll] \n\t\t\t\t\t(if (coll? coll)\n    \t\t\t\t(if (= (count coll) 3)\n    \t\t\t\t\t(cons (first coll) (cons (swap-lr (last coll)) (cons (swap-lr (second coll)) '())))\n    \t\t\t\t\tnil)\n    \t\t\t\tcoll)) (last coll)))\n    \tfalse)\n    false))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "564da567e4b0284900eef682"}, {"problem": 96, "code": "(fn [tree]\n    (let [flatten-tree (partial clojure.walk/postwalk\n                          (fn [n]\n                            (if (sequential? n)\n                              (let [[v l r] n] (flatten [l v r]))\n                              n)))\n          palindrome? #(= % (reverse %))]\n      (palindrome? (flatten-tree tree))))", "user": "516db4f6e4b046df6fbb76a0"}, {"problem": 96, "code": "(fn [arg1]\n(cond\n(and (= arg1 (quote (:a (:b nil nil) (:b nil nil))))) true\n(and (= arg1 (quote (:a (:b nil nil) nil)))) false\n(and (= arg1 (quote (:a (:b nil nil) (:c nil nil))))) false\n(and (= arg1 [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]] [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])) true\n(and (= arg1 [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]] [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])) false\n(and (= arg1 [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]] [2 [3 nil [4 [6 nil nil] nil]] nil]])) false\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 96, "code": "(fn symmetric? [t] (letfn [(symmetric [t] (if \n                      (sequential? t) \n                      (let [[root left right] t] (list root (symmetric right) (symmetric left))) \n                      t))] (= t (symmetric t))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(flip [[val left right]]\n            (let [left-1 (if right (flip right) nil)\n                  right-1 (if left (flip left) nil)]\n              [val left-1 right-1]))]\n    (= tree (flip tree))))", "user": "564c7c95e4b0284900eef672"}, {"problem": 96, "code": "(fn symmetric? [whole-node]\n  (letfn [(swap-node [tree-node]\n                    (if (nil? tree-node)\n                      tree-node\n                      [(first tree-node) (swap-node (last tree-node)) (swap-node (second tree-node))]))\n        (equal-nodes [left-node right-node]\n          (or\n            (and (nil? left-node) (nil? right-node))\n            (and (= (first left-node) (first right-node))\n                 (equal-nodes (second left-node) (second right-node))\n                 (equal-nodes (last left-node) (last right-node))\n                 )))]\n    (equal-nodes (swap-node (second whole-node)) (last whole-node))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 96, "code": "(fn [c]\n   (letfn [(node-eq [& args]\n             (if (apply = (map first args))\n               (apply map\n                      #(if (every? nil? [%1 %2]) true (if (some nil? [%1 %2]) false (node-eq %1 %2)))\n                      ((juxt first (comp reverse second)) (map rest args))\n                      ) [false]))]\n     (every? true? (flatten (node-eq (nth c 1) (nth c 2))))))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 96, "code": "(fn [T]\n    \n     (letfn [ (mirror [t1 t2]\n                (or (= t1 t2 nil)\n                    (and \n                       (sequential? t1) \n                       (sequential? t2)\n                       (= (first t1) (first t2))\n                       (mirror (nth t1 1) (nth t2 2) )\n                       (mirror (nth t2 1) (nth t1 2)))))]\n       (mirror (nth T 1) (nth T 2)))\n        \n  \n  )", "user": "5649615be4b0284900eef641"}, {"problem": 96, "code": "(fn sym? \n  ([[_ n n']]\n   (sym? n n'))\n  ([n n']\n   (if (and (coll? n) (coll? n'))\n     (let [[v l r] n\n           [v' l' r'] n']\n       (and (= v v') (sym? l r') (sym? l' r)))\n     (and (nil? n) (nil? n')))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 96, "code": "#(and\n  (\n    (fn binary-tree? [node]\n      (or\n        (nil? node)\n        (and\n          (sequential? node)\n          (= (count node) 3)\n          (binary-tree? (second node))\n          (binary-tree? (last node))\n          )\n        )\n      )\n    %\n    )\n  ((fn symmetric? [left-child right-child]\n     (or\n       (= nil left-child right-child)\n       (let [[value-of-left-child left-child-of-left-child right-child-of-left_child] left-child\n             [value-of-right-child left-child-of-right-child right-child-of-right_child] right-child]\n         (and\n           (= value-of-left-child value-of-right-child)\n           (symmetric? left-child-of-left-child right-child-of-right_child)\n           (symmetric? left-child-of-right-child right-child-of-left_child)\n           )\n         )\n       )\n     )\n    (second %) (last %)\n    )\n  )", "user": "566639f4e4b0e91d5f5c566b"}, {"problem": 96, "code": "(fn [tree]\n    ((fn sym? [l r]\n       (if (or (= nil l r)\n               (and (= (first l) (first r))\n                    (sym? (second l) (last r))\n                    (sym? (last l) (second r))))\n         true\n         false))\n     (second tree) (last tree)))", "user": "4ff3113ae4b0678c553fc345"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [value (fn [t] (nth t 0))\n        left  (fn [t] (nth t 1))\n        right (fn [t] (nth t 2))\n        flip  (fn flip [t]\n                (if (nil? t)\n                  t\n                  [(value t) (flip (right t)) (flip (left t))]))]\n    (= tree (flip tree))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 96, "code": "(letfn [(mirror [tree]\n          (if (nil? tree) nil\n              [(first tree)\n               (mirror (nth tree 2))\n               (mirror (nth tree 1))]))]\n  #(= (mirror %) %))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 96, "code": "(fn is-mirror[tree]\n  (let [value (first tree)\n        mirror-fn (fn mirror [tree]\n                    (if (nil? tree)\n                      tree\n                      [(first tree) (mirror (nth tree 2)) (mirror (second tree))]))\n        left-part (second tree)\n        right-part (nth tree 2)\n        mirrored-left (mirror-fn left-part)]\n    (= mirrored-left right-part)))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 96, "code": "(fn [mirror-tree]\n   (=\n    (\n     (fn reverse-tree [tree] \n       (if (sequential? tree)\n         (vector\n           (first tree) \n           (reverse-tree (nth tree 2))\n           (reverse-tree (nth tree 1)))\n         tree)) \n     (nth mirror-tree 2))\n    (nth mirror-tree 1)))", "user": "567476bde4b05957ce8c6139"}, {"problem": 96, "code": "(fn symmetric? [[v l r]]\n  (= (clojure.walk/postwalk (fn [b] (if (coll? b) (let [[v l r] b] [v r l]) b)) l) r))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 96, "code": "(fn [[v l r]]\n  ((fn tree= [[v1 l1 r1] [v2 l2 r2]]\n       (and (= v1 v2)\n            (or (and (nil? v1)\n                     (nil? v2))\n                (and (tree= l1 r2)\n                     (tree= r1 l2)))))\n   l r))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 96, "code": "(fn [tree]\n  (let [lleaf (second tree)\n        rleaf (last tree),\n        mirror (fn mirror [tree]\n                 (let [value (first tree)\n                       lleaf (second tree)\n                       rleaf (last tree)]\n                   (conj [] value\n                         (if (sequential? rleaf) (mirror rleaf) rleaf)\n                         (if (sequential? lleaf) (mirror lleaf) lleaf))))]\n    (= lleaf (mirror rleaf))))", "user": "56732c84e4b05957ce8c611c"}, {"problem": 96, "code": "(fn symm? [x]\n  (= x ((fn mir [[v l r :as t]]\n          (when t\n            (conj [v] (mir r) (mir l)))) x)))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 96, "code": ";; I will skip validation of the trees (which I solved in problem 95),\n;; since none of the test cases contain invalid trees. The key here\n;; is to reverse the children of every node, and to then check\n;; whether that new reversed tree equals the original.\n\n(fn [tree]\n  (let [build-reversed-tree (fn reverse-branch [branch] \n                              (let [node (first branch)\n                                    first-child (second branch)\n                                    second-child (last branch)]\n                                (if (coll? branch)\n                                  (concat \n                                   [node] \n                                   ;; switch the places of the second and first children\n                                   [(reverse-branch second-child)]\n                                   [(reverse-branch first-child)]))))\n        reversed-tree (build-reversed-tree tree)]\n    (= tree reversed-tree)))", "user": "55344b75e4b09218d5f44f99"}, {"problem": 96, "code": "(fn test-tree [[val left-node right-node]]\n                  (loop [[lv llnode lrnode] left-node\n                         [rv rlnode rrnode] right-node]\n                    (cond\n                      (coll? llnode) (recur llnode rrnode)\n                      (coll? lrnode) (recur lrnode rlnode)\n                      :else (= lv rv))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 96, "code": "(fn [[n l r]]\n   (let [mirror (fn mirror [t]\n                  (if-not (coll? t) t\n                          (let [[n l r] t]\n                            [n (mirror r) (mirror l)])))]\n     (= l (mirror r))))", "user": "50232eeae4b0b5d8b1bd2397"}, {"problem": 96, "code": "(fn [node]\n  (let [[root left right] node\n        mirror? (fn mirror? [left right]\n                 (cond\n                   (not (= (sequential? left) (sequential? right))) false\n                   (sequential? left) (let [[lroot ll lr] left\n                                           [rroot rl rr] right]\n                                       (and (= lroot rroot) (mirror? ll rr) (mirror? rl lr))\n                                       )\n                   :else (= left right)))]\n    (mirror? left right))\n  )", "user": "564a560ae4b0284900eef654"}, {"problem": 96, "code": "#(= (nth % 2)\n    ((fn [[_ a]]\n       ((fn g [[k a b]]\n          [k (if (coll? b) (g b) b)\n             (if (coll? a) (g a) a)])\n        a))\n     %))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 96, "code": "(fn [c] \n   ((fn o [x y]\n      (letfn [(f [a b] (cond\n                        (and (nil? a) (nil? b)) true\n                        (and (coll? a) (coll? b)) (o a b)\n                        :else false))]\n        (and (= (first x) (first y))\n             (f (second x) (second (rest y)))\n             (f (second (rest x)) (second y))))) (second c) (second (rest c))))", "user": "555883c5e4b0deb715856e2d"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(third [coll]\n            (-> coll rest second)),\n          (comp-seq [s1 s2]\n            (and (comp-element (first s1) (first s2))\n                 (comp-element (second s1) (third s2))\n                 (comp-element (second s2) (third s1)))),\n          (comp-element [e1 e2]\n            (if (sequential? e1)\n                (and (sequential? e2) (comp-seq e1 e2))\n                (= e1 e2)))]\n    (comp-element (second tree) (third tree))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond (not= (sequential? a) (sequential? b)) false\n                        (sequential? a) (let [[aa la ra] a,\n                                              [bb lb rb] b]\n                                          (and (= aa bb) (mirror? la rb) (mirror? ra lb)))\n                        :else (= a b)))]\n    (mirror? left right)))", "user": "56669819e4b0e91d5f5c5674"}, {"problem": 96, "code": "(fn mysim [tree]\n  (let [ltree (second tree)\n        rtree (nth tree 2)]\n    (or\n      (nil? tree)\n      (and \n        (nil? ltree)\n        (nil? rtree))\n      (and\n        (= (first ltree) (first rtree))\n        (mysim (list nil (second ltree) (nth rtree 2)))\n        (mysim (list nil (nth ltree 2) (second rtree)))))))", "user": "535f9a5ce4b04ce2eb3ed2de"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "56810479e4b0966858e4d8f8"}, {"problem": 96, "code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 96, "code": "(fn beauty-is-symmetry-solution\n  [tree] ;; update args as needed\n  ;; Let us define a binary tree as \"symmetric\" if the left half of the tree is the mirror image of the right half of the tree. Write a predicate to determine whether or not a given binary tree is symmetric. (see To Tree, or not to Tree for a reminder on the tree representation we're using).\n  (letfn [ (is-b-tree-node-val? [node] (not (or (seq? node) (vector? node))))\n          (is-b-tree-valid? [tree]\n            (cond\n              (not (or (seq? tree) (vector? tree))) false\n              (not= (count tree) 3) false\n              :else\n              (let [[root _ _] tree]\n                (is-b-tree-node-val? root))\n              )\n            )\n\n          (is-b-tree-nodes-symetric? [node-left node-right]\n            ;(println (str \"left\" node-left \" right\" node-right))\n            (cond\n              (and (nil? node-left) (nil? node-right)) true\n              (or (nil? node-left) (nil? node-right)) false\n              (and (is-b-tree-node-val? node-left) (is-b-tree-node-val? node-right)) (= node-left node-right)\n              (or (is-b-tree-node-val? node-left) (is-b-tree-node-val? node-right)) false\n              :else\n              (let [[node-left-root node-left-left node-left-right] node-left\n                    [node-right-root node-right-left node-right-right] node-right ]\n                (and\n                  (is-b-tree-node-val? node-left-root)\n                  (is-b-tree-node-val? node-right-root)\n                  (= node-left-root node-right-root)\n                  (is-b-tree-nodes-symetric? node-left-left node-right-right)\n                  (is-b-tree-nodes-symetric? node-left-right node-right-left)\n\n                  ))\n              )\n            )\n\n          (is-b-tree-symetric? [tree]\n            (if (is-b-tree-valid? tree)\n              (let [[_ left right] tree]\n                (is-b-tree-nodes-symetric? left right))\n              false))\n\n          ]\n    (is-b-tree-symetric? tree)))", "user": "54df955ee4b024c67c0cf7af"}, {"problem": 96, "code": "(fn symmtric\n  [tree]\n  (letfn [(skew-match? \n           [tree1 tree2]\n           (or (and (nil? tree1) (nil? tree2))\n               (and\n                (coll? tree1)\n                (coll? tree2)\n                (= (first tree1) (first tree2))\n                (skew-match? (second tree1) (last tree2))\n                (skew-match? (last tree1) (second tree2)))))]\n    (skew-match? tree tree)))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 96, "code": "(fn q4q096\n  ([[_ t1 t2]] (q4q096 t1 t2))\n  ([t1 t2]\n   (or\n    (every? nil? [t1 t2])\n    (and\n     (every? coll? [t1 t2])\n     (every? #(= 3 (count %)) [t1 t2])\n     (let [[t1v t1l t1r] t1\n           [t2v t2l t2r] t2]\n       (and\n        (= t1v t2v)\n        (q4q096 t1l t2r)\n        (q4q096 t1r t2l)))))))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 96, "code": "(fn [node]\n  (let [[v left right] node\n        mirror? (fn m? [child1 child2]\n                  (cond\n                    (and (nil? child1) (nil? child2)) true\n                    (and (coll? child1) (coll? child2)) \n                      (let [[c1val c1left c1right] child1\n                            [c2val c2left c2right] child2]\n                        (and (= c1val c2val) (m? c1left c2right) (m? c1right c2left)))\n                    :else false))]\n    (mirror? left right)))", "user": "564a5a09e4b0284900eef656"}, {"problem": 96, "code": "(fn [[_ l r]]\n    (letfn [(mirror? [[v l r :as t0] [v' l' r' :as t1]]\n              (or\n                (and (nil? t0) (nil? t1))\n                (and (= v v') (mirror? l r') (mirror? r l'))))]\n      (mirror? l r)))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 96, "code": "(fn [T]\n  (let [rev (fn rev [T]\n              (if (nil? T) nil\n                (let [[a b c] T] (list a (rev c) (rev b)))))]\n    (= T (rev T))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 96, "code": "(fn[[x y z]] (letfn [(f [[a b c]] [a (if (coll? c) (f c) c) (if (coll? b) (f b) b)])] (= y (if (coll? z) (f z) z))))", "user": "56798d83e4b05957ce8c618b"}, {"problem": 96, "code": "(fn [c]\n   (letfn [(f [c]\n             (map #(if (sequential? %)\n                     (f (conj (reverse (rest %))\n                                          (first %)))\n                     %) c))]\n     (= (second c) (last (f c)))))", "user": "5687fe58e4b0dcc4269f4065"}, {"problem": 96, "code": "(fn s\n  ([t] (apply s (rest t)))\n  ([a b] (or (and (nil? a) (nil? b))\n             (and\n               (= (first a) (first b))\n               (s (nth a 1) (nth b 2))\n               (s (nth a 2) (nth b 1)))))\n  )", "user": "5680fff3e4b0966858e4d8f6"}, {"problem": 96, "code": "(fn ismirror\n  ([tree] (ismirror (second tree) (second (rest tree))))\n  ([left right] \n   (cond\n     (and (nil? left) (nil? right))\n     true\n     (and (sequential? left) (sequential? right))\n     (and (= (first left) (first right))\n          (ismirror (second left) (second (rest right)))\n          (ismirror (second (rest left)) (second right)))\n     :else\n     false)))", "user": "55f85b93e4b03cbcff9738ae"}, {"problem": 96, "code": "#(= ((fn f [[a b c :as d]] (when d [a (f c) (f b)])) %) %)", "user": "56754c4be4b05957ce8c6149"}, {"problem": 96, "code": "(fn stree? [t]\n  (letfn [(reverse_ [node]\n            (if (coll? node)\n              [(first node) (reverse_ (last node)) (reverse_ (second node))]\n              node))]\n    (= (second t) (reverse_ (last t)))))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [branches (rest tree)\n        reverse-branch (fn reverse-branch [branch]\n                         (if (coll? branch)\n                           (concat [(first branch)]\n                                   (map reverse-branch (reverse (rest branch))))\n                           branch))]\n    (= (first branches)\n       (reverse-branch (second branches)))))", "user": "562e8b2be4b0ab312c17ebbb"}, {"problem": 96, "code": "(fn is-sym-bin-tree [tree]\n  (letfn [(is-bin-tree [tree]\n            (or (nil? tree)\n                (and (coll? tree)\n                     (= 3 (count tree))\n                     (is-bin-tree (nth tree 1))\n                     (is-bin-tree (nth tree 2)))))\n\n          (sym-tree [tree] (if (coll? tree)\n                             (let [[value left right] tree]\n                               [value (sym-tree right) (sym-tree left)])\n                             tree))]\n\n    (and (is-bin-tree tree)\n         (= (nth tree 1)\n            (sym-tree (nth tree 2))))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "4e6a8d28535d8ccf87e9fef5"}, {"problem": 96, "code": "(fn sim [[v l r]]\n ((fn equiv [[v1 l1 r1] [v2 l2 r2]] (println v1 l1 r1 v2 l2 r2 ) (or (= v1 v2 nil) (and (= v1 v2) (and (equiv l1 r2) (equiv l2 r1))))) \n  l r\n  )\n )", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 96, "code": "(fn symmetrical-tree? [[v c1 c2 :as tree]]\n  (let [reflect-subtree (fn reflect-subtree [[v c1 c2 :as tree]]\n                          (if (nil? tree) \n                            tree ;; subtrees always terminate as nil\n                            [v (reflect-subtree c2) (reflect-subtree c1)]))] ;; note the flipped c1 and c2\n    (= c1 (reflect-subtree c2))))", "user": "56175cf9e4b06b1bb2182a0f"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (every? true? (map =\n    ;; every node in left branches\n\t(map first (tree-seq next rest (second tree)))\n    ;; every node in right branches reversed\n\t(map first (tree-seq next (comp reverse rest) (last tree))))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 96, "code": "(fn symmetric-tree? [tr]\n  (letfn\n      [(before-root-travel [tr]\n         (if (not (coll? tr)) [tr]\n             (concat\n              (before-root-travel (second tr))\n              [(first tr)]\n              (before-root-travel (last tr)))))\n       \n       (after-root-travel [tr]\n         (if (not (coll? tr)) [tr]\n             (concat\n              (after-root-travel (last tr))\n              [(first tr)]\n              (after-root-travel (second tr)))))]\n    (or\n     (= 1 (count tr))\n     (= (before-root-travel (second tr)) (after-root-travel (last tr))))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 96, "code": "(fn mirror-equals [node]\n  (let [[_ l r] node\n        [l-node ll lr] l\n        [r-node rl rr] r]\n    (if (or (nil? l-node) (nil? r-node)) \n      (and (nil? l-node) (nil? r-node))\n      (and\n       (= l-node r-node)\n       (mirror-equals [nil ll rr])\n       (mirror-equals [nil lr rl])))))", "user": "5680104ae4b0966858e4d8ea"}, {"problem": 96, "code": "(fn [tree] ;; breadth-first approach\n           ;; checking each level whether l-level is equals reversed r-level\n  (let [[_ l r] tree\n        rest-if-coll #(if (coll? %) (rest %) [])]\n    (reduce (fn [res [l r]]\n              (and res (= (when (coll? l) (map first l))\n                          (when (coll? r) (reverse (map first r))))))\n            true\n            (take-while (partial some seq)\n                        (iterate (fn [[l r]]\n                                   [(mapcat rest-if-coll l)\n                                    (mapcat rest-if-coll r)])\n                                 [[l] [r]])))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 96, "code": "(fn isSym\n  ([tree] (if (empty? tree) true (isSym (second tree) (second (rest tree)))))\n  ([ltree rtree] \n      (if (and (= ltree nil) (= rtree nil)) \n          true   \n          (if (or (= ltree nil) (= rtree nil))\n              false\n              (if (not= (first ltree) (first rtree))\n                 false\n                 (if (not (isSym (second ltree) (second (rest rtree))))\n                     false\n                     (if (not (isSym (second (rest ltree)) (second rtree)))\n                         false\n                         true)))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 96, "code": "#(= (map first (tree-seq coll? rest %))\n    (map first (tree-seq coll? (comp reverse rest) %)))", "user": "5630ce72e4b0bfe05bf11786"}, {"problem": 96, "code": "(fn isSym? [tree]  (letfn [(reverseTree [t]   (let [root (first t)\n                                                            leftBranch (second t)\n                                                            rightBranch (last t)] [root (if (nil? rightBranch) rightBranch (reverseTree rightBranch)) (if (nil? leftBranch) leftBranch (reverseTree leftBranch))]))] (= (second tree) (reverseTree (last tree)))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 96, "code": "(fn symmetric? [[v l r]]\n  (letfn [(mirror [t]\n           (when (not (nil? t))\n             (let [[v l r] t] [v (mirror r) (mirror l)])))]\n    (and\n     (= l (mirror r)))))", "user": "569ab3e2e4b0542e1f8d144a"}, {"problem": 96, "code": "(fn is-symm? [btree]\n  ((fn mirror? [lbranch rbranch]\n     (if (or (= nil lbranch rbranch)\n             (and (= (first lbranch) (first rbranch))\n                  (mirror? (second lbranch) (last rbranch))\n                  (mirror? (last lbranch) (second rbranch))))\n       true\n       false))\n   (second btree) (last btree)))", "user": "5579eed7e4b05c286339e09b"}, {"problem": 96, "code": "(fn g[x]\n((fn f[a b] \n  (or (and (coll? a) (coll? b) (= (first a) (first b)) (f (second a) (last b)) (f (second b) (last a)))\n   (and (nil? a) (nil? b)))) (second x) (last x)))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 96, "code": "(fn symtree? [tree]\n  (if ((fn binarytr? [x]\n         (if (and (sequential? x) (= (count x) 3))\n           (and (binarytr? (first (rest x))) (binarytr? (last x)))\n           (if (nil? x) true false))) \n        tree) \n    ((fn mirror? [left right]\n       (if (or (= nil left right)\n               (and (= (first left) (first right))\n                    (mirror? (second left) (last right))\n                    (mirror? (last left) (second right))))\n         true false)) \n      (second tree) (last tree))\n    false))", "user": "56a3c89ae4b0542e1f8d14cf"}, {"problem": 96, "code": "(fn sym? \n  ([[v l r]]\n   (sym? l r))\n  ([[v1 l1 r1] [v2 l2 r2]]\n   (or\n    (every? nil? [v1 l1 r1 v2 l2 r2])\n    (and\n     (= v1 v2)\n     (sym? l1 r2)\n     (sym? r1 l2)))))", "user": "511e17a9e4b0c5b849dd36b0"}, {"problem": 96, "code": "(fn [coll]\n  (let [mirror (fn mirror [[a b c]]\n                 [a (if (sequential? c) (mirror c) c) (if (sequential? b) (mirror b) b)])]\n    (= coll (mirror coll))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 96, "code": "(fn deepcompare [[_ c1 c2]]\n  (or (= nil c1 c2)\n      (= true (not (coll? c1)) (= c1 c2))\n      (and (coll? c1)\n           (coll? c2)\n           (= (count c1) (count c2))\n           (= (first c1) (first c2))\n           (every? true? (map #(deepcompare [1 (first %) (last %)]) (partition 2 (interleave (reverse (rest c1)) (rest c2))))))))", "user": "536673a8e4b0243289761e76"}, {"problem": 96, "code": "(fn beaut [tree]\n  (letfn [(in-order [tree]\n          (if (nil? tree) nil\n                          (concat (in-order (nth tree 1)) [(first tree)] (in-order (nth tree 2)))))]\n  (let [t (in-order tree)]\n    (= t (reverse t)))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 96, "code": "#(letfn [(lr [[h l r]]\n            (concat [h] (if l (lr l)) (if r (lr r))))\n        (rl [[h l r]]\n            (concat [h] (if r (rl r)) (if l (rl l))))]\n       (= (lr (second %)) (rl (last %))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 96, "code": "(fn symetry\n  [s]\n  (let [root (first s)\n        l (second s)\n        r (last s)\n        sym? (fn sym? \n                  [a b]\n                  (cond \n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[va ls-a lr-a] a\n                                          [vb ls-b lr-b] b]\n                                      (and (= va vb) (sym? ls-a lr-b) (sym? ls-b lr-a) ))\n                    :else (= a b)\n                    ))]\n    (sym? l r)))", "user": "5564709ee4b0c656e3ff1807"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "52c1cc8be4b07a9af579236b"}, {"problem": 96, "code": "#(letfn [(reflbtree [t] (if (sequential? t) \n                         (list \n                          (first t) \n                          (reflbtree (nth t 2))\n                          (reflbtree (second t)))\n                         t))]\n (= % (reflbtree %)))", "user": "56b86e64e4b0f26550335924"}, {"problem": 96, "code": "(fn [s]\n\t(let [a (second s) b (last s)]\n\t\t(letfn\n\t\t\t[(mirror [s]\n\t\t\t\t(let [x (second s) y (last s)]\n\t\t\t\t\t(if\n\t\t\t\t\t\t(and (nil? x) (nil? y))\n\t\t\t\t\t\ts\n\t\t\t\t\t\t(list (first s)\n\t\t\t\t\t\t\t(if (nil? y) y (mirror y))\n\t\t\t\t\t\t\t(if (nil? x) x (mirror x))))))]\n\t\t\t(= a (mirror b)))))", "user": "56abeb1fe4b03c432f187344"}, {"problem": 96, "code": "(fn stree? \n  ([t] (stree? (second t) (last t)))\n  ([t1 t2]\n     (cond \n       (and (nil? t1) (nil? t2)) true\n       (not (= (first t1) (first t2))) false\n       :else (and (stree? (second t1) (last t2)) (stree? (last t1) (second t2)))\n      )\n   )\n )", "user": "56bca51ae4b0f26550335963"}, {"problem": 96, "code": "(fn sym-tree? [tree]\n  (letfn [(mirror? [[v left right :as node]]\n                  (when node\n                    [v (mirror? right) (mirror? left)]))]\n    (= tree (mirror? tree))))", "user": "56481722e4b0284900eef628"}, {"problem": 96, "code": "(fn symmetric-bintree? \n  ([s] (symmetric-bintree? (second s) (last s)))\n  ([a b] (or \n           (and  (nil? a) (nil? b))\n           (if (and (sequential? a) (sequential? b)) \n             (and (= 3 (count a) (count b)) \n                  (= (first a) (first b)) \n                  (symmetric-bintree? (second a) (last b)) \n                  (symmetric-bintree? (last a) (second b)))\n             false))))", "user": "56c1e720e4b0839206b9d68b"}, {"problem": 96, "code": "(fn symmetry? ([root] (symmetry? (second root ) (last root) ) ) ([left right] (cond \n                                                                               (and (nil? left) (nil? right))  true\n                                                                               (or (nil? left) (nil? right))   false\n                                                                               true (and (= (first left) (first right) ) \n                                                                                         (symmetry? (second left) (last right)  )\n                                                                                         (symmetry? (last left) (second right) ))\n                                                                               )    )   )", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": 96, "code": "(fn beauty? [t]\n  (letfn [(v [t] (first t))\n          (l [t] (second t))\n          (r [t] (last t))\n          (mirror?\n           [t1 t2]\n           (cond\n            (= nil t1 t2) true,\n            (or (nil? t1) (nil? t2)) false,\n            :else (and (= (v t1) (v t2))\n                       (mirror? (l t1) (r t2))\n                       (mirror? (r t1) (l t2)))))]\n    (mirror? (l t) (r t))))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 96, "code": "(fn is-beauty?\n  [t]\n  (letfn [(is-equal? \n            [t1 t2]\n            (if (= nil t1 t2)\n              true\n              (if (or (nil? t1) (nil? t2))\n                false \n                (if (= (first t1) (first t2))\n                  (and (is-equal? (second t1) (last t2))\n                       (is-equal? (second t2) (last t1)))\n                  false))))]\n    (is-equal? (second t) (last t))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 96, "code": "#(= (second %) ((fn revbtree [t] (println t) (if (empty? t) nil (list (first t) (revbtree (last t)) (revbtree (second t))))) (last %)))", "user": "56a75810e4b0542e1f8d14fc"}, {"problem": 96, "code": "#(= % ((fn f [s] (if (nil? s) nil (vector (nth s 0) (f (nth s 2)) (f (nth s 1))))) %))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 96, "code": "(fn                                                                             \n  [root]                                                                        \n  (= ((fn mirror                                                                \n        [s] (if (= nil s)                                                       \n              s                                                                 \n              [(first s) (mirror (last s)) (mirror (second s))]))               \n      (last root))                                                              \n     (second root)))", "user": "563536f8e4b0bfe05bf117c5"}, {"problem": 96, "code": "(fn symetry? [t]\n\t(let [mirror (fn mirror [[root left right :as t]]\n\t\t\t\t\t (if t\n\t\t\t\t\t\t [root (mirror right) (mirror left)]))]\n\t\t(= t (mirror t) )))", "user": "552bd5c2e4b0ffed3738f969"}, {"problem": 96, "code": "(fn [tree]\n  ((fn mirror? [left right]\n     (if (and (empty? left) (empty? right))\n       true\n       (and (= (first left) (first right))\n            (mirror? (vec (second left)) \n                     (vec (second (rest right))))\n            (mirror? (vec (second (rest left)))\n                     (vec (second right))))))\n   (vec (second tree))\n   (vec (second (rest tree)))))", "user": "52fe31d5e4b047fd55837038"}, {"problem": 96, "code": "#(letfn [\n(left [c] (if (coll? c) (str (first c) (left (nth c 1)) (left (nth c 2))) (str \"nil\")))\n(right [c] (if (coll? c) (str (first c) (right (nth c 2)) (right (nth c 1))) (str \"nil\")))\n] (= (left %) (right %))\n)", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "56826ebce4b0945ebc182a93"}, {"problem": 96, "code": "(fn symmetricX[t]\n\t(\n(fn equivalent[t1 t2]\n\t(if (nil? t1)\n\t\t(nil? t2)\t\t\n\t\t(and ( = (first t1) (first t2))\n\t\t\t(and \n\t\t\t\t(equivalent (second t1)(last t2) )\n\t\t\t\t(equivalent (last t1)(second t2) )\n\t\t\t)\n\t\t)\n\t)\n) (second t) (last t))\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror?\n        (fn mirror? [a b]\n          (cond\n            (not= (sequential? a) (sequential? b)) false\n            (sequential? a) (let [[ra La Ra] a\n                                  [rb Lb Rb] b]\n                              (and \n                                (= ra rb) \n                                (mirror? La Rb) \n                                (mirror? Lb Ra)))\n            :else (= a b)))]\n    (mirror? left right)))", "user": "569ce6fee4b0542e1f8d146c"}, {"problem": 96, "code": "(fn sym? [[_ b c]]\n\t(letfn [(mirror? [node1 node2]\n\t\t(or (= nil node1 node2)\n\t\t\t(and (= (first node1)(first node2))\n\t\t\t\t(mirror? (second node1) (last node2))\n\t\t\t\t(mirror? (last node1) (second node2)))))] \n\t(mirror? b c)))", "user": "54ce541de4b057c6fda3a2ac"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "56d05ba2e4b0ea9b8538f77d"}, {"problem": 96, "code": "#(= ((fn s [[v l r :as i]] (if i [v (s r) (s l)])) %) %)", "user": "56b2573ce4b0982f16b37e02"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(cmp-branches [x y]\n                        (if (= (first x)\n                               (first y))\n                          (if (nil? x)\n                            true\n                            (and (cmp-branches (second x)\n                                               (last y))\n                                 (cmp-branches (last x)\n                                               (second y))))\n                          false))]\n    (cmp-branches (second tree)\n                  (last tree))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(t2l [c ls] \n            (if (coll? c) \n              (let [[n l r] c]\n                (if ls\n                  (concat (t2l l ls) [n] (t2l r ls)) \n                  (concat (t2l r ls) [n] (t2l l ls))))\n              [c]))]\n    (= (t2l t true)\n       (t2l t false))))", "user": "51b0e7b3e4b0c53cf2e68a6e"}, {"problem": 96, "code": "(fn [x]\n  (let [\n        [a b c] x     \t\n        same? (fn same? [a b] \n                (if (= a b nil) \n                           true \n                           (and (= (nth a 0) (nth b 0))   \n                                (and (same? (nth a 2) (nth b 1)) (same? (nth a 1) (nth b 2)))\n                           ) \n                )\n              )\n       ]\n    (if (nil? x)\n      true\n      (same? b c)\n    )\n  )\n)", "user": "55c5e781e4b0e31453f649b8"}, {"problem": 96, "code": "(fn [f tr]\n (let [in (f tr)]\n    (= in (reverse in)) ))\n(fn in-order [[n l r :as tr]]\n  (let [expand #(cond\n                 (coll? %) (in-order %)\n                 (nil? %) %\n                 :else [%])]\n    (mapcat expand [l n r])))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 96, "code": "(fn [[_ L R]]\n  (letfn [(flip [[v l r]]\n            (list v (if (coll? r) (flip r) r) (if (coll? l) (flip l) l)))]\n    (= L (flip R))))", "user": "550b502ae4b06e50f9beb13f"}, {"problem": 96, "code": "(fn issym? [[_ a b]]\n  (letfn [(flip [[a b c]] [a\n                         (if (coll? c)\n                           (flip c) c)\n                         (if (coll? b) \n                           (flip b) b)])]\n    (= a (if (coll? b) (flip b) b))))", "user": "56aed78fe4b03c432f187363"}, {"problem": 96, "code": "(fn symmetric?\n  ([[_ left right]]\n   (symmetric? left right))\n  ([tree1 tree2]\n    (or\n      (and (nil? tree1) (nil? tree2))\n      (and (coll? tree1)\n           (coll? tree2)\n           (= (first tree1) (first tree2))\n           (symmetric? (second tree1) (last tree2))\n           (symmetric? (last tree1) (second tree2))))))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 96, "code": "(fn symmetry? [[_ l r]]\n   (if (and (nil? l) (nil? r))\n     true\n     (let [[lv ll lr] l\n           [rv rl rr] r]\n       (if (and (= lv rv) (symmetry? [nil ll rr]) (symmetry? [nil lr rl]))\n         true\n         false))))", "user": "546a6e9fe4b00cfc9eacc157"}, {"problem": 96, "code": "(fn [s] {:pre [(sequential? s)\n               (= (count s) 3)]}\n    (let [  left (second s)\n           right (last s)\n          mirror (fn mirror [s] {:pre [(= (count s) 3)]}\n                   (let [ left (second s)\n                         right (last s)]\n                     (if (and (nil? left) (nil? right))\n                       s\n                       (list\n                         (first s)\n                         (if (sequential? right) (mirror right) right)\n                         (if (sequential? left) (mirror left) left)))))]\n      (=\n        left\n        (if (sequential? right)\n          (mirror right)\n          right))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 96, "code": "(fn sym\n  ([t] (sym (nth t 1) (nth t 2)))\n  ([a b]\n   (cond \n    (and (nil? a) (nil? b)) true\n    (and (coll? a) (coll? b)) (and (sym (first a) (first b))\n                                   (sym (nth a 1) (nth b 2))\n                                   (sym (nth b 1) (nth a 2)))\n    (= a b) true\n    :else false)))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 96, "code": "(fn\n  [tree]\n  (letfn [(mirror [[root left right]]\n            (when root\n              [root (mirror right) (mirror left)]))]\n    (= tree (mirror tree))))", "user": "55ed5a2de4b0121d4835fdd8"}, {"problem": 96, "code": "(fn [[_ l r]]\n   (letfn [(rev [xs]\n             (when xs\n               (let [[v l r] xs]\n                 [v (rev r) (rev l)])))]\n     (= l (rev r))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 96, "code": "(fn is-sym [node]\n  (letfn [(traverse [pre? col node]\n            (if (nil? node)\n              col\n              (let [left-child (traverse pre? [] (nth node 1))\n                    right-child (traverse pre? [] (nth node 2))]\n                (if pre?\n                  (concat left-child [(first node)] right-child)\n                  (concat right-child [(first node)] left-child)))))]\n    (= (traverse true [] node) (traverse false [] node))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 96, "code": "(fn [[h l r]]\n    (letfn [(sym-tree? [l r]\n              (if (and (coll? l) (coll? r))\n                (and\n                 (= (first l) (first r))\n                 (sym-tree? (second l) (last r))\n                 (sym-tree? (last l) (second r)))\n                (= l r)))]\n      (sym-tree? l r)))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 96, "code": "(fn symmetric-binary\n  [[v l r]]\n  (= l ((fn deep-swap\n  [btree]\n  (cond \n    (nil? btree) btree\n    :else (vector (first btree) (deep-swap (last btree)) (deep-swap (second btree))))) r)))", "user": "56c3aca0e4b05cc29241ee90"}, {"problem": 96, "code": "(fn [root]\n  ((fn mirror? [left right]\n     (if (= nil left right)\n       true\n       (if (and (= (first left) (first right))\n                (mirror? (second left) (last right))\n                (mirror? (last left) (second right)))\n         true\n         false))) (second root) (last root)))", "user": "56ee0691e4b04a395b9a044c"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "56c60b36e4b05cc29241eead"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(b [lf rf t]\n              (when (not (nil? (first t)))\n                (cons (first t) (list (b lf rf (lf t)) (b lf rf (rf t))))))]\n    (= (second t)\n       (b #(nth % 2) second (nth t 2)))\n    ))", "user": "568227fee4b0945ebc182a8a"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(third [l] (nth l 2))\n          (revt [t] (if t [(first t) (revt (third t)) (revt (second t))]))]\n   (= (second t) (revt (third t)))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 96, "code": "(fn sym-b-tree? [t]\n  \"from: http://stackoverflow.com/questions/8436623. Compare the left and inverted right sub-trees\"\n  (letfn [(mirror? [l r]\n    (or  \n      (and (nil? l)  (nil? r) ) ; if one branch is nil tuther must be as well\n      (let [ [lv ll lr] l\n             [rv rl rr] r]\n        (and \n        (= lv rv) ; values are the same\n        (mirror? ll rr ) ;left left sub-tree same as right right sub-tree\n        (mirror? lr rl) ; ditto\n        ))\n      ))] \n    (mirror? (second t) (last t)) ;start check @ root node\n    )\n  )", "user": "569951e4e4b0542e1f8d143e"}, {"problem": 96, "code": "(fn solve [x]\n  (let [walk (fn rec [tree] (if (sequential? tree) (flatten (list (rec (nth tree 1)) (first tree) (rec (last tree)))) tree))\n        w (walk x)]\n     (= w (reverse w))\n        ))", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 96, "code": "(fn is-symmetric [t]\n  (let [mirror-tree (fn mirror-tree [node]\n                      (if (sequential? node)\n                        [(nth node 0) (mirror-tree (nth node 2)) (mirror-tree (nth node 1))]\n                        node))]\n    (= (nth t 1) (mirror-tree (nth t 2)))))", "user": "56742817e4b05957ce8c612d"}, {"problem": 96, "code": ";; another option right order path = left order path\n(fn [args]\n  (letfn [(lnode [tree] (first (rest tree)))\n          (rnode [tree] (last tree))\n          (leaf? [tree] ((comp not coll?) tree))\n          (symmetry [tree]\n            (if (leaf? tree)\n              tree\n              (conj [] (first tree) (symmetry (rnode tree)) (symmetry (lnode tree)))))]\n    (= (symmetry (lnode args)) (rnode args))\n    ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 96, "code": "(fn symmetric?\n  [[_ left right]]\n  (let [fleft ((fn flip [[root left right]]\n                  (and root [root (flip right) (flip left)])) left)]\n    (= fleft right)))", "user": "5609d328e4b05f002753deee"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 96, "code": "(fn [x]\n  (letfn [(f [x] (let [y (second x) z (nth x 2)]\n                    [ (first x) (if (nil? z) z (f z) ) (if (nil? y) y (f y))] ) )]\n  (= (second x) (f (nth x 2))\n  )\n    )\n  )", "user": "51e1c176e4b06a68e693eafb"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirror [branch]\n                  (if (= 3 (count branch))\n                    (let [[nd l r] branch]\n                      [nd (mirror r) (mirror l)])\n                    branch))]\n    (= l (mirror r))))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 96, "code": "(fn sym? [coll]\n   (let [sym (fn mirror [coll]\n               (cond\n                 (nil? coll) coll\n                 (coll? coll) (let [left (second coll)\n                                    right (nth coll 2)]\n                                (vector (first coll) (mirror right) (mirror left)))))]\n         (= (sym coll) coll)))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 96, "code": "#(= (second %) \n     ((fn revtree [t] \n        (if \n          (vector? t) \n          [(first t) (revtree (nth t 2)) (revtree (second t))]\n          t)\n        ) \n      (nth % 2)))", "user": "5686b7c7e4b0dcc4269f4057"}, {"problem": 96, "code": "(fn symmetrical? [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n    (mirror? left right)))", "user": "5250a13ee4b0541d1855b839"}, {"problem": 96, "code": "(fn [[_ l r]]\n  ((fn sym? [l r]\n     (cond (and (sequential? l) (sequential? r))\n           (let [[lv ll lr] l [rv rl rr] r]\n             (if (= lv rv)\n               (and (sym? ll rr) (sym? lr rl))\n               false))\n           (or  (sequential? l) (sequential? r)) false\n           :else (= l r)))\n   l r))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(treeeq [l r]\n            (or (and (nil? l) (nil? r))\n                (and (= (first l) (first r))\n                     (let [[_ ll lr] l\n                           [_ rl rr] r]\n                       (and\n                        (treeeq ll rr)\n                        (treeeq lr rl))))))]\n    (and (sequential? t)\n         (= (count t) 3)\n         (let [[_ l r] t]\n           (treeeq l r)))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 96, "code": "#(= % ((fn sym [s]\n         (if (sequential? s)\n           (vector (first s) (sym (nth s 2)) (sym (nth s 1 )))\n           s))\n       %))", "user": "57008afae4b08d47c97781ca"}, {"problem": 96, "code": "#((fn check [L R]\n    (or (and (nil? L) (nil? R))\n        (and (not (nil? L))\n             (not (nil? R))\n             (= (first L) (first R))\n             (check (nth L 1) (nth R 2))\n             (check (nth L 2) (nth R 1)))))\n    (nth %1 1) (nth %1 2))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(preorder [t]\n                     (if (nil? t)\n                       '(nil)\n                       (let [e (first t)\n                             l (second t)\n                             r (nth t 2)]\n                         (lazy-cat (preorder l) (preorder r) (list e)))))\n          (postorder [t]\n                     (if (nil? t)\n                       '(nil)\n                       (let [e (first t)\n                             l (second t)\n                             r (nth t 2)]\n                         (lazy-cat (postorder r) (postorder l) (list e)))))]\n          (= (preorder t) (postorder t))))", "user": "570459a9e4b0b0fb43fd0662"}, {"problem": 96, "code": "(fn symetric? [[_ L R]]\n  (if (not (coll? L))\n    true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (and (= LV RV) (symetric? [nil LL RR]) (symetric? [nil RL LR]))\n        )\n      )\n    )\n  )", "user": "56791447e4b05957ce8c6183"}, {"problem": 96, "code": "(fn [[_ left right]]\n    (= left\n       ((fn mirror [t]\n          (when t\n            (cons (first t) (reverse (map mirror (next t))))))\n        right)))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 96, "code": "; direct c/p from @q:\n(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "56ca0da9e4b0ea9b8538f715"}, {"problem": 96, "code": "(fn [a-seq]\n  (if (or\n        (not= 3 (count a-seq))\n        (coll? (first a-seq))\n        (nil? (first a-seq))\n        (some false? a-seq)\n        (some true? a-seq))\n    false\n    (let [node (first a-seq)\n          branch-1 (second a-seq)\n          branch-2 (second (rest a-seq))\n          mirror (fn mir# [b-tree]\n                   (if (= (second b-tree)\n                          (second (rest b-tree)))\n                     b-tree\n                     (cons\n                       (first b-tree)\n                       (list\n                         (mir# (second (rest b-tree)))\n                         (mir# (second b-tree))))))]\n      (if (and (not= branch-1 branch-2)\n               (not= (mirror branch-1) branch-2))\n        false\n        true))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 96, "code": "(fn symetry?\n  ([tree] (if (and (coll? tree) (= (count tree) 3))\n           (symetry? (second tree) (last tree))\n           ))\n  ([tree1 tree2] (or\n                  (and (nil? tree1) (nil? tree2))\n                  (if (and (coll? tree1) (coll? tree2))\n                    (and (= (count tree1) (count tree2) 3)\n                         (= (first tree1) (first tree2))\n                         (symetry? (second tree1) (last tree2))\n                         (symetry? (last tree1) (second tree2)))\n                    false)))\n  )", "user": "56f73913e4b08e7d20b9682d"}, {"problem": 96, "code": "(fn mirror [tree]\n(letfn [(collapse [tree]\n\t(if (coll? tree)\n\t\t(concat (collapse (second tree)) [(first tree)] (collapse (nth tree 2)))\n\t\ttree\n\t))]\n\t(let [collapsed (collapse tree)]\n\t(= (reverse collapsed) collapsed)\n\t)\n))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 96, "code": "(letfn [(sym2\n          [[hx xo xi] [hy yi yo]]\n          (and\n           (= hx hy)\n           (if (every? coll? [xo yo])\n             (sym2 xo yo)\n             (= xo yo))\n           (if (every? coll? [xi yi])\n             (sym2 xi yi)\n             (= xi yi))))]\n  (fn [a]\n    (sym2 (nth a 1) (nth a 2))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 96, "code": "(fn [tr]\n  (letfn [(mirror-leaves? [l r] (or (and (nil? (nth l 1)) (nil? (nth r 2)))\n                                    (mirror? (nth l 1) (nth r 2))))\n          (mirror? [l r] (and (= (first l) (first r))\n                              (mirror-leaves? l r)\n                              (mirror-leaves? r l)))]\n    (mirror? (nth tr 1) (nth tr 2))))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "56df63e1e4b0ca2494a095f6"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "56df63c7e4b0ca2494a095f5"}, {"problem": 96, "code": "(fn tree? ([s] (tree? s s))\n  ([s1 s2] (cond\n    (and (or (seq? s1) (vector? s1)) (or (seq? s2) (vector? s2)))\n    (and (= (count s1) 3) (= (count s2) 3) (= (first s1) (first s2)) (tree? (second s1) (last s2)) (tree? (last s1) (second s2)))\n    (and (nil? s1) (nil? s2))  true\n    :else false)))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 96, "code": "(fn [t]\n    (letfn [\n      (invert\n        [[x y z :as all]]\n        (if (nil? all)\n          nil\n          [x (invert z) (invert y)]))]\n      (= t (invert t))))", "user": "4e8a170c535d3e98b802328f"}, {"problem": 96, "code": "#(= ((fn x [[n l r :as tree]] (when tree [n (x r) (x l)])) %) %)", "user": "56df6417e4b0ca2494a095f7"}, {"problem": 96, "code": "(fn [s]\n\t(let [a (second s) b (last s)]\n\t\t(letfn\n\t\t\t[(mirror [s]\n\t\t\t\t(let [x (second s) y (last s)]\n\t\t\t\t\t(if\n\t\t\t\t\t\t(and (nil? x) (nil? y))\n\t\t\t\t\t\ts\n\t\t\t\t\t\t(list (first s)\n\t\t\t\t\t\t\t(if (nil? y) y (mirror y))\n\t\t\t\t\t\t\t(if (nil? x) x (mirror x))))))]\n\t\t\t(= a (mirror b)))))", "user": "56df6351e4b0ca2494a095f3"}, {"problem": 96, "code": "(fn is-sym?\n\n    ([t]\n       (is-sym? (second t) (last t))\n       )\n\n    ([l r]\n\n       (and\n        (= (first l) (first r))\n        (or\n         (and (nil? (second l)) (nil? (second r)))\n          (is-sym? (second l) (last r)))\n        (or\n         (and (nil? (last l)) (nil? (last r)))\n          (is-sym? (last l) (second r))))\n       \n       )\n\n)", "user": "56fc1bc7e4b07572ad1a88dd"}, {"problem": 96, "code": "(fn [s]\n  (or \n   (= s '(:a (:b nil nil) (:b nil nil)))\n   (= s [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])))", "user": "56df632ce4b0ca2494a095f2"}, {"problem": 96, "code": "(fn symmetric-binary-tree?\n  [tree]\n  (let [key? (fn key?\n               [item]\n               (and ((complement coll?) item)\n                    ((complement false?) item)))\n        binary-tree? (fn binary-tree?\n                       [tree]\n                       (let [is-key? (fn [item] (and ((complement coll?) item)\n                                                     ((complement false?) item)))]\n                         (and (= (count tree) 3)\n                              (let [key (nth tree 0)\n                                    left-child (nth tree 1)\n                                    right-child (nth tree 2)]\n                                (and (is-key? key)\n                                     (if (coll? left-child)\n                                       (binary-tree? left-child)\n                                       (is-key? left-child))\n                                     (if (coll? right-child)\n                                       (binary-tree? right-child)\n                                       (is-key? right-child)))))))\n        mirror-tree (fn mirror-tree\n                      [elem]\n                      (if (coll? elem)\n                        (let [[k l r] elem]\n                          (cond\n                            (and (coll? l) (coll? r)) [k (mirror-tree r) (mirror-tree l)]\n                            (and (key? l) (key? r)) [k r l]\n                            (and (key? l) (coll? r)) [k (mirror-tree r) l]\n                            (and (coll? l) (key? r)) [k r (mirror-tree l)]\n                            :else \"ERROR\"))\n                        elem))]\n    (and (binary-tree? tree)\n         (= tree (mirror-tree tree)))))", "user": "5720a2b0e4b0c5bde472c099"}, {"problem": 96, "code": "(fn symmetrical? [t]\n  (letfn [(mirror-tree [t]\n            (if (nil? t)\n              nil\n              (let [[r a b] t]\n                [r (mirror-tree b) (mirror-tree a)])))]\n    (= t (mirror-tree t))))", "user": "571d063ee4b0145328a76272"}, {"problem": 96, "code": "(fn isSymmetric?\n  [[root leftNode rightNode]]\n  (if (and (nil? leftNode) (nil? rightNode))\n    true\n    (if (and (coll? leftNode) (coll? rightNode))\n        (let [[l1 l2 l3] leftNode\n              [r1 r2 r3] rightNode]\n            (and (= l1 r1) (isSymmetric? [nil l2 r3]) (isSymmetric? [nil r2 l3])))\n        false)))", "user": "56fe2a2fe4b08d47c97781ad"}, {"problem": 96, "code": "(fn symmetric? [[_ left right]]\n  (let [tr (fn tr [[x l r]]\n          [x (if (coll? r) (tr r) r) (if (coll? l) (tr l) l)])]\n    (= left (tr right))))", "user": "570362ece4b08d47c97781f0"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "56e9a56ae4b04a395b9a03fc"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57201f14e4b0c5bde472c08e"}, {"problem": 96, "code": "(fn [lst] \n  (= ((fn mirror [[root left right :as tree]]\n        (when tree [root (mirror right) (mirror left)])) lst) lst))", "user": "56df62b3e4b0ca2494a095ef"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "56df629fe4b0ca2494a095ee"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57211a02e4b0c5bde472c0a9"}, {"problem": 96, "code": "(fn [coll] \n  (= coll\n     ((fn mirror\n        [[n l r :as tree]]\n        (when tree\n          [n (mirror r) (mirror l)])) coll)))", "user": "56785234e4b05957ce8c6177"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "56df636ae4b0ca2494a095f4"}, {"problem": 96, "code": "(fn \n  [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "56df7440e4b0ca2494a095fb"}, {"problem": 96, "code": "(fn [[_ l r]]\n    (letfn [(mirror [t]\n              (when-let [[v l r] t]\n                [v (mirror r) (mirror l)]))]\n      (= l (mirror r))))", "user": "571ff1ebe4b0c5bde472c088"}, {"problem": 96, "code": "#(= ((fn sym [[n l r :as tree]] (when tree [n (sym r) (sym l)])) %) %)", "user": "57210e8ee4b0c5bde472c0a8"}, {"problem": 96, "code": "(fn u\n  [s] {:pre [(sequential? s)\n               (= (count s) 3)]}\n  (let [left (second s)\n        right (last s)\n        mirror (fn mirror [s] {:pre [(= (count s) 3)]}\n                 (let [left (second s)\n                       right (last s)]\n                   (if (and (nil? left) (nil? right))\n                     s\n                     (list\n                       (first s)\n                       (if (sequential? right) (mirror right) right)\n                       (if (sequential? left) (mirror left) left)))))]\n    (=\n      left\n      (if (sequential? right)\n        (mirror right)\n        right))))", "user": "5723e6d6e4b0c5bde472c0f1"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "56df6498e4b0ca2494a095f8"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5728d33ce4b0c6e51e0d2b12"}, {"problem": 96, "code": "(fn symmetric-tree? [[root-val left-child right-child :as tree]]\n  (letfn [(mirror-tree [[val left right :as t]]\n            (if (nil? t)\n              nil\n              (list val (mirror-tree right) (mirror-tree left))))]\n    (= left-child (mirror-tree right-child))))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 96, "code": "(fn isSymetric [t] (let [\n                         isMirror (fn isMirror [t1 t2] (cond\n                                                        (and (nil? t1) (nil? t2)) true\n                                                        (nil? t1) false\n                                                        (nil? t2) false\n                                                        (and (= (nth t1 0) (nth t2 0)) (isMirror (nth t1 1) (nth t2 2)) (isMirror (nth t1 2) (nth t2 1))) true\n                                                        :else false\n                                                       )\n                                  )\n                        ]\n                     (isMirror (nth t 1) (nth t 2))\n                    )\n  )", "user": "571aad45e4b07c98581c3b59"}, {"problem": 96, "code": "(fn q[tree]\n  ( =\n    (last tree)\n    (clojure.walk/postwalk #(if (sequential? %) (vector (first %) (last %) (second %)) %) (second tree)) \n  )\n)", "user": "5717d674e4b07c98581c3b1a"}, {"problem": 96, "code": "(fn ismirror\n    ([t]\n     (ismirror (second t) (last t)))\n    ([t1 t2]\n     (cond\n       (and (nil? t1) (nil? t2)) true\n       (or (nil? t1) (nil? t2)) false\n       :else\n       (and (= (first t1) (first t2))\n            (ismirror (second t1) (last t2))\n            (ismirror (last t1) (second t2))))))", "user": "56eaad95e4b04a395b9a040f"}, {"problem": 96, "code": "(fn sym [[root left right]]\n  (letfn [(mirror? [l r]\n            (or (every? nil? [l r])\n                (and (= (first l) (first r))\n                     (mirror? (second l) (last r))\n                     (mirror? (last l) (second r)))))]\n    (mirror? left right)))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 96, "code": "(fn [[_ l r]]\n  ((fn mirror-tree?\n  [[ln ll lr] [rn rl rr]]\n  (if (= ln rn)\n    (do\n      (and (if (and (coll? ll) (coll? rr))\n             (mirror-tree? ll rr)\n             (if (= ll rr)\n               true\n               false))\n            (if (and (coll? lr) (coll? rl))\n              (mirror-tree? lr rl)\n              (if (= lr rl)\n                true\n                false)))\n     )\n    false)) l r))", "user": "56d4b1aee4b0ea9b8538f7ba"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(rev [x] (if-let [[a b c] x]\n                     [a (rev c) (rev b)]\n                     x))]\n    (= (rev r) l)))", "user": "532418f3e4b09d4e7a9b54d8"}, {"problem": 96, "code": "(fn symmetric? [[root left right]]\n  (letfn [(mirror [sub-tree]\n            (if (seq sub-tree)\n              (let [[node left right] sub-tree]\n                [node (mirror right) (mirror left)])\n              sub-tree))]\n    (= left (mirror right))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 96, "code": "(letfn [\n\n  (mirror [tree]\n    (if (nil? tree)\n      nil\n      (let [[value left right] tree]\n        [value (mirror right) (mirror left)])))\n\n  (binary-tree-symmetric? [node]\n    (let [[value left right] node]\n      (= left (mirror right))))]\n\n  binary-tree-symmetric?)", "user": "57300c19e4b0cd1946bd0fa1"}, {"problem": 96, "code": "#(= (\n      (fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)]))\n      %) %)", "user": "55d42f78e4b0e31453f64a73"}, {"problem": 96, "code": "(fn f\n  ([xs] (f (second xs) (last xs)))\n  ([l r]\n   (cond\n     (and (not (sequential? l)) (not (sequential? r))) (= l r)\n     (and (sequential? l) (sequential? r)) (and (= (first l) (first r))\n                                  (f (second l) (last r))\n                                  (f (last l) (second r)))\n     :else false)))", "user": "56795deae4b05957ce8c6187"}, {"problem": 96, "code": "(fn [[v a b]]\n  (let [sa ((fn f [vv]\n        (if (nil? vv)    \n          nil\n          (let [[v a b] vv]\n            [v (f b) (f a)]\n     \n            )\n        )\n      ) a)\n   ]\n    (if (= sa b) true false)\n  )\n  )", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 96, "code": "(fn is-mirror\n  ([a] (is-mirror a a))\n  ([a b]\n   (cond\n   \t(= nil a b) true\n   \t(some empty? [a b]) false\n   \t(= (first a) (first b)) \n   \t\t\t(let [[_ la ra] a [_ lb rb] b]\n          \t\t(and (is-mirror la rb) (is-mirror lb ra)))\n   \t:else false\n   \t)))", "user": "56eb3f9de4b04a395b9a0420"}, {"problem": 96, "code": "(fn isBinaryTreeSymmetric [tree]\n   (let [rtree\n          (\n            (fn reverseTree [tree]\n                 (let [ node (first tree)\n                       , leaves (rest tree)\n                       , L (first leaves)\n                       , R (last (rest leaves))\n                       , out [] ]\n\n                      (if (nil? node)\n                        out\n                        (conj out node\n                              (if (not (sequential? R)) R (reverseTree R ) )\n                              (if (not (sequential? L)) L (reverseTree L ) )\n                        )\n                      )\n                  )\n            )\n            tree\n          )\n        ] (= rtree tree)\n   )\n )", "user": "571aae1fe4b07c98581c3b5a"}, {"problem": 96, "code": "(fn [[l s t]]\n  ((fn f [[m & u] [n & v]]\n     (and (= m n)\n          (every? identity (map f u (reverse v)))))\n   s t))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "570794d8e4b0b0fb43fd068b"}, {"problem": 96, "code": "(fn [t]\n  (let* [l (fn [n] (first (rest n)))\n         r (fn [n] (first (rest (rest n))))\n         mirror (fn __ [tree] (when (seq tree) (list (first tree) (__ (r tree)) (__ (l tree)))))]\n        (= (mirror (l t)) (r t))))", "user": "563f24f9e4b08d4f616f5ed0"}, {"problem": 96, "code": "(fn symmetric-tree? [starting-node]\n  (letfn [(flip-node [node]\n                     (let [[v l r] node]\n                       (if\n                         (or\n                          (sequential? l)\n                          (sequential? r))\n                         [v (flip-node r) (flip-node l)]\n                         node)))]\n    (let [[v left right] starting-node]\n      (= left (flip-node right)))))", "user": "573b8f67e4b0cd1946bd10ae"}, {"problem": 96, "code": "#(= % ((fn treeflect [[f s l]] [f (if (coll? l) (treeflect l) l) (if (coll? s) (treeflect s) s)]) %))", "user": "573ce277e4b05c31a32c080b"}, {"problem": 96, "code": "(fn [p]\n  (letfn [(trav1 [[v a b]]\n            (if (nil? v) \"nil\" (str v \" \" (trav1 a) \" \" (trav1 b))))\n          (trav2 [[v a b]]\n            (if (nil? v) \"nil\" (str v \" \" (trav2 b) \" \" (trav2 a))))]\n   (= (trav1 p) (trav2 p))))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 96, "code": "(fn symme-tree? [t]\n  (letfn [(mirror-tree [t]\n            (if (nil? t)\n              nil\n             (let [[n & kids] t]\n               (concat [n] (reverse (map mirror-tree kids))))))]\n    (let [[n l r] t]\n      (= l (mirror-tree r)))))", "user": "57407ab3e4b05c31a32c0854"}, {"problem": 96, "code": "(fn is-tree-symmetric? [t]\n  (let [\n        walk-lr (fn lr [t] (if t (concat (lr (second t)) (take 1 t) (lr (last   t)))))\n        walk-rl (fn rl [t] (if t (concat (rl (last   t)) (take 1 t) (rl (second t)))))\n        ]\n    (nil? (first (filter false? (map = (walk-lr t) (walk-rl t)))))))", "user": "57458b82e4b009280f9f2b4e"}, {"problem": 96, "code": "(fn sym-tree? [candidate]\n                 (let [[chd cl cr] candidate]\n                   (letfn [(mirror [tree]\n                            (if (coll? tree)\n                              (let [[hd l r] tree] [hd (mirror r) (mirror l)])\n                              tree))]\n                      (= cl (mirror cr)))))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 96, "code": "(fn [[q al ar]](apply (fn ss [l r]\n  (let\n    [\n       bothNil (and (nil? l) (nil? r))\n       bothColl (and (coll? l) (coll? r))\n       valsEq (= (nth l 0) (nth r 0))\n     ]\n    (or \n     bothNil\n     (and bothColl valsEq \n          (let \n            [\n             ll (second l)\n             lr (nth l 2)\n             rl (second r)\n             rr (nth r 2)\n             ]\n            (println ll rr)\n            (println rl lr)\n            (and (ss ll rr) (ss lr rl))\n            )\n          )\n     )\n    )\n  )\n[al ar]\n)\n)", "user": "55f01316e4b06e875b46ce1a"}, {"problem": 96, "code": "(fn [[v1 l1 r1]]\n  (letfn [(flip [t]\n             (if (and (sequential? t) (= 3 (count t)))\n   \t           (let [[v l r] t] [v (flip r) (flip l)])\n                   t))]\n    (= l1 (flip r1))))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(rotate [t]\n                  (if (nil? t) t\n                    (list (first t) (rotate (last t)) (rotate (second t)))))]\n  (= tree (rotate tree))))\n\n; (defn rotate [t]\n;  (if (nil? t) t\n;    '((first t) (rotate (last t)) (rotate (second t)))))", "user": "57275898e4b0c5bde472c13e"}, {"problem": 96, "code": "(fn tree2?\n  ([t]\n   (let [[n l r] t]\n     (tree2? l r)))\n  ([t1 t2]\n   (if (and (sequential? t1)\n            (sequential? t2))\n     (let [[n1 l1 r1] t1\n           [n2 l2 r2] t2]\n       (and (= n1 n2)\n            (tree2? l1 r2)\n            (tree2? l2 r1)))\n     (= t1 t2))))", "user": "508c3d42e4b0f17d83ea26b2"}, {"problem": 96, "code": "(fn [tree] (letfn [(reverseTree [node]\n                   (when (not (nil? node))\n                     [(first node) (reverseTree (last (rest node))) (reverseTree (first (rest node)))]\n                     )\n                   ) ]\n             (= tree (reverseTree tree))\n             ) )", "user": "574986cae4b009280f9f2b9c"}, {"problem": 96, "code": "(fn tree?\n   ([t] (tree? (second t) (last t)))\n   ([l r] (or\n            (and (nil? l) (nil? r))\n            (if (and (coll? l) (coll? r))\n              (and\n                (= (count l) (count r) 3)\n                (= (first l) (first r))\n                (tree? (second l) (last r))\n                (tree? (last l) (second r))\n                )\n              false)))\n   )", "user": "573107d5e4b0cd1946bd0fbc"}, {"problem": 96, "code": "#(letfn [(sym [elem] (if (coll? elem)\n                        (vector (first elem) (sym (last elem)) (sym (second elem))) elem))]\n   (= % (sym %)))", "user": "5751f2a2e4b02ea114799292"}, {"problem": 96, "code": "(fn symmetric? [[head ltree rtree]]\n  (letfn \n    [(mirror? [ltree rtree]\n      (if \n        (every? sequential? [ltree rtree])\n        (and\n         (= (first ltree) (first rtree))\n         (mirror? (second ltree) (last rtree))\n         (mirror? (last ltree) (second rtree)))\n        (= ltree rtree)))]\n    (mirror? ltree rtree)))", "user": "56877fcbe4b0dcc4269f405e"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "575086e7e4b02ea114799276"}, {"problem": 96, "code": "(fn mirror [[idx a b]]\n  (letfn [(rev [x]\n               (if (coll? x)\n                 [(first x) (rev (last x)) (rev (second x))]\n                 x))]\n    (= a (rev b))))", "user": "55d68726e4b0e31453f64a99"}, {"problem": 96, "code": "(fn [l]\n  (letfn [(reverse-tree [x]\n                        (cond \n                         (seq? x)\n                         (list (first x) (reverse-tree (last x)) (reverse-tree (second x)))\n                         \n                         (vector? x)\n                         [(first x) (reverse-tree (last x)) (reverse-tree (second x))]\n                         \n                         nil\n                         x))]\n    (= (reverse-tree (second l)) (last l))))", "user": "54bbba99e4b0ed20f4ff6ec2"}, {"problem": 96, "code": "(fn[s]\n (=\n  (\n   (fn f[a] \n    (if (sequential? a)\n     (concat (f (second a)) [(first a)] (f (nth a 2)))\n     [a]\n    )\n   )\n   (second s)\n  )\n  (\n   (fn g[b] \n    (if (sequential? b)\n     (concat (g (nth b 2)) [(first b)] (g (second b)))\n     [b]\n    )\n   )\n   (nth s 2)\n  )\n )\n)", "user": "54283a7ae4b01498b1a71b2f"}, {"problem": 96, "code": "(fn tree-symmetry [Tr]\n  (letfn [(pre-order [Tr]\n            (if (= Tr nil)\n              [nil]\n              (concat (pre-order (second Tr)) [(first Tr)] (pre-order (last Tr)))))\n          ]\n    (if (= Tr nil)\n      true\n      (if (= (pre-order (second Tr)) (reverse (pre-order (last Tr))))\n        true\n        false))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (= left\n     ((fn mirror\n        [[value left right :as node]]\n        (and node\n             [value (mirror right) (mirror left)]))\n      right)))", "user": "575cbe44e4b02ea114799374"}, {"problem": 96, "code": "(fn [t]\n  (let [flip (fn flip [t]\n              (if (nil? t) t\n                [(nth t 0) (flip (nth t 2)) (flip (nth t 1))]))]\n    (if (nil? t) true\n       (= (flip (nth t 1)) (nth t 2)))))", "user": "57642916e4b0994c1922fbee"}, {"problem": 96, "code": "(fn [tr]\n  (letfn [(s [[x l r] [y l' r']]\n            (cond\n              (not (or x y)) true\n              (= x y) (and (s l r')(s r l'))\n              :else false))]\n    (s tr tr)))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 96, "code": "(fn symmetric? [[v lc rc]] \n  (letfn [(reversed [tree]\n                    (cond \n                     (sequential? tree) [(first tree) (reversed (last tree)) (reversed (second tree))]\n                     nil nil\n                     )\n                    )]\n    (= (reversed lc) rc)))", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 96, "code": "(fn [c]\n  (= (remove sequential?\n             (tree-seq sequential? identity c))\n     (remove sequential?\n             (tree-seq sequential? #(conj [] (first %) (last %) (second %)) c))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 96, "code": "(fn symmetric-btree?\n  ([[value left right :as root]]\n   (or (nil? root)\n       (symmetric-btree? left right)))\n  ([[l-value l-left l-right :as l-node]\n    [r-value r-left r-right :as r-node]]\n   (if (nil? l-node)\n     (nil? r-node)\n     (and (= l-value r-value)\n          (symmetric-btree? l-left r-right)\n          (symmetric-btree? l-right r-left)))))", "user": "52ea025ae4b09f7907dd14b5"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(r [[val left right :as node]]\n            (when ((complement nil?) node)\n              [val (r right) (r left)]))]\n            (= left (r right))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 96, "code": "(fn me [[_ a b]]\n  (if (or (nil? a) (nil? b))\n    (= nil a b)\n    (and\n     (=  (first a) (first b))\n     (me [nil (nth a 1) (nth b 2)])\n     (me [nil (nth a 2) (nth b 1)]))))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 96, "code": "(fn symmetric? [t] \n  (letfn [\n    (mirror [t] \n    (if (or (seq? t) (vector? t))\n      (list (first t) (mirror (nth t 2)) (mirror (nth t 1)))\n      t))]\n    (= t (mirror t))))", "user": "5756f324e4b02ea1147992e8"}, {"problem": 96, "code": "(let [g (fn f [[n l r :as x]]\n          (if (nil? x)\n            x\n            [n (f r) (f l)]))]\n (fn [[_ l r]] (= (g l) r)))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 96, "code": "#(= % \n    ((fn f [[n l r :as a]] \n       (when a \n         [n (f r) (f l)]))\n     %))", "user": "576e3258e4b0979f89651574"}, {"problem": 96, "code": "(fn [coll]\n  (letfn [(revt [k] [(first k) (if (coll? (last k)) (revt (last k)) (last k))\n                     \t\t\t\t\t (if (coll? (second k)) (revt (second k)) (second k))])]\n                (= (second coll) (revt (last coll)))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 96, "code": "(fn start [[v l r]] (let [mi (fn mi \n                               [l r] \n                               (let [e? (complement sequential?)]\n                                 (if (or (e? l) (e? r)) \n                                     (and (e? l) (e? r))\n                                     (let [[lv ll lr] l \n                                           [rv rl rr] r]\n                                       (every? true? [(= lv rv) (mi ll rr) (mi lr rl)])))))]\n                      (mi l r)))", "user": "577202d2e4b0979f896515c0"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57227f10e4b0c5bde472c0cd"}, {"problem": 96, "code": "(fn symetric? [tree]\n  (letfn [(inverse-tree [tree]\n           (when-not (nil? tree)\n             (let [[node-value left right] tree]\n               (println \"node value?\" node-value)\n               [node-value\n                (inverse-tree right)\n                (inverse-tree left)])))]\n    (= tree (inverse-tree tree))))", "user": "53dd37aee4b0d874e779ae28"}, {"problem": 96, "code": "(fn symmetric? [[_ left right]]\n  (letfn [(flip [c]\n          (if (coll? c)\n            (let [[v l r] c]\n              (seq [v (flip r) (flip l)]))\n            c))]\n    (if (coll? left) (= (seq left) (flip right))\n                     (= left right))))", "user": "57650419e4b0994c1922fc09"}, {"problem": 96, "code": "(fn [t]\n  (let [[e l r] t]\n    ((fn c2 [l r]\n       (cond (= nil l r) true\n             (= 3 (count l) (count r))\n               (let [[le ll lr] l [re rl rr] r]\n                 (and (= le re) (c2 ll rr) (c2 lr rl))\n                 )\n             :else false\n             )\n       )\n     l r)\n    )\n  )", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 96, "code": "(fn sym? [[v t1 t2]]\n   (cond\n      (and (nil? t1) (nil? t2)) true\n      (and (coll? t1) (coll? t2)) \n      (and \n        (= (first t1) (first t2))\n        (sym? [1 (second t1) (last t2)]) \n        (sym? [2 (last t1) (second t2)]))\n\n      (and (nil? t1) (nil? t2)) true\n      :else false))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 96, "code": "(fn symmetric-tree?\n  ([xs]\n   (let [left (second xs)\n         right (nth xs 2)]\n     (symmetric-tree? left right)\n     ))\n  ([a b]\n   (cond\n     (and (nil? a) (nil? b)) true\n     (and (coll? a) (coll? b))\n     (let [a-left (second a)\n           a-right (nth a 2)\n           b-left (second b)\n           b-right (nth b 2)]\n       (and (= (first a) (first b))\n            (and (symmetric-tree? a-left b-right)\n                 (symmetric-tree? a-right b-left))\n            ))\n     :else false)\n    ))", "user": "570ab24fe4b0b0fb43fd06b7"}, {"problem": 96, "code": "(fn pz [s]\n  (let [ret1 (atom [])  ret2 (atom [])\n        trvrs (fn pozd [s l-r ret] \n                (cond (= s nil)  (do (swap! ret conj s) @ret) \n                      (and (coll? s) (= 3 (count s))) \n                      (do  \n                        (swap! ret conj (first s))\n                        (if  (pozd (nth s (l-r 0)) l-r ret) \n                          (pozd (nth s (l-r 1)) l-r ret)\n                          false)) \n                      :else false))]\n    (= (trvrs s [1 2] ret1) (trvrs s [2 1] ret2))\n    ;  (println @ret1)  (println @ret2)\n   ) )", "user": "572ac718e4b0f4d77e651242"}, {"problem": 96, "code": "(fn [s](\nevery? true?\n(         \n(fn[s2](\nmap-indexed\n(fn[idx itm](= itm (nth s2 (- (count s2) (inc idx)) )))\ns2\n))\n\n(flatten(\n(fn f [l](\n           if(nil? l) nil\n           (list (f (second l)) (first l) (f (last l)) )\n))\ns\n))\n)\n))", "user": "56039843e4b04bb52996e1be"}, {"problem": 96, "code": "(letfn [(rev-tree [[p l r :as n]] [p (if r (rev-tree r)) (if l (rev-tree l))])]\n  (fn [[_ l r]] (= l (rev-tree r))))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 96, "code": "(fn [[v izq der]]\n  (= izq ((fn rev [[v i d]] [v (if (= 3 (count d)) (rev d) d) (if (= 3 (count i)) (rev i) i)]) der)))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 96, "code": "(fn solve [tree]\n  (letfn [(mirror [tree]\n            (if (nil? tree)\n              nil\n              (list (first tree) (mirror (last tree)) (mirror (second tree)))))]\n    (or (nil? tree)\n        (= (second tree) (mirror (last tree))))))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 96, "code": "#(letfn [(reflect [[n lc rc]] (when-not (nil? n) [n (reflect rc) (reflect lc)]))]\n      (= % (reflect %)))", "user": "577829f9e4b0979f8965165a"}, {"problem": 96, "code": "(fn symmetry [[root left right]] \n  (let [mirror? (fn mirror? [a b] \n                  (cond \n                     (not= (sequential? a) (sequential? b)) false \n                     (sequential? a) (let [[ra La Ra] a \n                                           [rb Lb Rb] b] \n                                       (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra))) \n                     :else (= a b)))] \n   (mirror? left right)))", "user": "57750460e4b0979f8965160c"}, {"problem": 96, "code": "(fn symmetric-tree? [t]\n    (letfn [(leaves [s]\n              (filter #(not (sequential? %)) s))\n            (flip-children [n]\n              (conj (reverse (rest n)) (first n)))]\n            (= (leaves (tree-seq sequential? seq t))\n               (leaves (tree-seq sequential?\n                                 (comp flip-children seq)\n                                 t)))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 96, "code": "(fn uni-symtree? [x]\n   (let [node? (fn [n] (if (or (not (coll? n))\n                              (coll? (first n))\n                              (not (or (coll? (second n))\n                                       (nil? (second n))))\n                              (not (or (coll? (last n))\n                                       (nil? (last n))))\n                              (not= (count n) 3))\n                        false\n                        true))\n        walk-legs (fn walk-legs [a b]\n                    (if (and (nil? a)\n                             (nil? b))\n                      true\n                      (if (and (node? a)\n                               (node? b)\n                               (= (first a) (first b))\n                               (walk-legs (second a) (last b))\n                               (walk-legs (last a) (second b)))\n                        true\n                        false)))]\n    (if (nil? x)\n      true\n      (if (node? x)\n        (and (= (first (second x))\n                (first (last x)))\n             (walk-legs (second x) (last x)))\n        false))))", "user": "5674607ae4b05957ce8c6137"}, {"problem": 96, "code": "(fn isSymmetricTree[tree]\n   (let [[value left right] tree]\n     ((fn isMirrorTree[t1 t2]\n        (let [[value1 left1 right1] t1\n              [value2 left2 right2] t2]\n          (and (= value1 value2)\n               (or (and (nil? left1) (nil? right2))\n                   (isMirrorTree left1 right2))\n               (or (and (nil? right1) (nil? left2))\n                   (isMirrorTree right1 left2))))) left right)))", "user": "577e54bbe4b0c8d87281f6e5"}, {"problem": 96, "code": ";; First solution\n;(fn symmetric? \n;  ([t] (symmetric? t t))\n;  ([[v1 l1 r1] [v2 l2 r2]]\n;   (letfn [(branch-eq? [branch1 branch2]\n;                      (if (sequential? branch1)\n;                        (symmetric? branch1 branch2)\n;                        (nil? branch2)))]\n;     (and\n;      (= v1 v2)\n;      (branch-eq? l1 r2)\n;      (branch-eq? l2 r1)))))\n\n(fn [t]\n  (letfn [(mirror [t] (if (nil? t)\n                          nil\n                          [(first t)\n                           (mirror (nth t 2))\n                           (mirror (nth t 1))]))]\n    (= t (mirror t))))", "user": "573118ebe4b0cd1946bd0fbd"}, {"problem": 96, "code": "(fn [z]\n\n (apply\n  (fn isSymetric [x y]\n \t(cond\n                (and (coll? x) (not (coll? y)) ) false\n                (and (coll? x) (not (coll? x)) ) false\n                (and (coll? x) (not (= (count x)  3))) false\n                (and (coll? y) (not (= (count y)  3))) false\n                (and (not (coll?  x)) (not (coll? y)) (not (=  x y))) false\n                (and (coll? x) (coll? y)) (and (isSymetric  (first x)  (first y)) (isSymetric  (second x)  (last y)) (isSymetric  (last x)  (second y)) ) \n\t\t:else true\n        )\n   )\n   (rest z)\n  )\n )", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(mirror [t] (if \n                        (nil? t) nil\n                        [(first t) (mirror (last t)) (mirror (second t))]))]\n    (= (second t) (mirror (last t)))))", "user": "5745bb9fe4b009280f9f2b54"}, {"problem": 96, "code": "(fn [x] (= x ((fn rs [col] (if (nil? col) nil (list (first col) (rs (last col)) (rs (second col))))) x)))", "user": "576df252e4b0979f8965156f"}, {"problem": 96, "code": "#(let [[n, l, r] %]\n  ((fn symmetric? [left, right]\n     (cond\n       (and (nil? left) (nil? right)) true\n       (and (coll? left) (coll? right) (= 3 (count left) (count right)))\n       (let [[l-node, l-left, l-right] left\n             [r-node, r-left, r-right] right]\n         (and (= l-node r-node)\n              (symmetric? l-left r-right)\n              (symmetric? l-right r-left)\n              ))\n       :else false))\n    l, r))", "user": "578f9a18e4b0ebec4cfb7598"}, {"problem": 96, "code": "(fn [tree] ((fn mirror? [l r]\n          (if\n              (or\n               (= nil l r)\n               (and (= (first l) (first r))\n                \t(mirror? (first (rest l)) (last r))\n                    (mirror? (last l) (first (rest r))))\n               )\n            true\n            false\n            )) (first (rest tree)) (last tree)))", "user": "53e92f82e4b036ad0777e49d"}, {"problem": 96, "code": "(fn __ [& nodes]\n  (if nodes\n    (and\n      (let [names (map first nodes)]\n        (= names (reverse names)))\n      (apply __ (mapcat rest nodes)))\n    true))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 96, "code": "(fn mirrors\n  [tree]\n  (if (and (= 3 (count tree)) (not-any? sequential? (rest tree)))\n    true\n    (if (not= 3 (count tree))\n      false\n      (let [lval (first (nth tree 1))\n            rval (first (nth tree 2))\n            ltree (rest (nth tree 1))\n            rtree (rest (nth tree 2))]\n        (if (not= lval rval)\n          false\n          (and (mirrors (conj [:head] (first ltree) (last rtree)))\n               (mirrors (conj [:head] (last ltree) (first rtree)))))))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 96, "code": "(fn [c]\n  (= (remove sequential?\n             (tree-seq sequential? identity c))\n     (remove sequential?\n             (tree-seq sequential? #(conj [] (first %) (last %) (second %)) c))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 96, "code": "(fn sym-tree? [[data left right]]\n  (letfn [(mirror [[v l r]] [v (if (seq r) (mirror r) r) (if (seq l) (mirror l) l)])]\n    (= left (mirror right))))", "user": "56d30497e4b0ea9b8538f7a8"}, {"problem": 96, "code": "(fn [x] (let [fl (fn flip [z] (let [root (first z) left (nth z 1) right (nth z 2)]\n                                              (if (nil? root) nil\n                                                              (if (and (nil? left) (nil? right)) [root left right] [root (flip right) (flip left)])))\n                               )\n                          root (first x)\n                          left (nth x 1)\n                          right (nth x 2)] (= left (fl right))))", "user": "4e5e9f6b535d8a8b8723a2d2"}, {"problem": 96, "code": "(fn [c]\n  (= (remove sequential?\n             (tree-seq sequential? identity c))\n     (remove sequential?\n             (tree-seq sequential? #(conj [] (first %) (last %) (second %)) c))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 96, "code": "(fn is-symetric-tree [tree]\n     (let [reverse-tree (fn reverse-tree [tree]\n                            (if (not (coll? tree))\n                              tree\n                              [(nth tree 0) (reverse-tree (nth tree 2)) (reverse-tree (nth tree 1))]))]\n        (if (not (coll? tree))\n          true\n          (if (or (false? tree) (not= (count tree) 3))\n            false\n            (= (nth tree 1) (reverse-tree (nth tree 2)))))))", "user": "560c37b5e4b05f002753df2e"}, {"problem": 96, "code": "(fn [s] {:pre [(sequential? s)\n               (= (count s) 3)]}\n  (let [left (second s)\n        right (last s)\n        mirror (fn mirror [s] {:pre [(= (count s) 3)]}\n                 (let [left (second s)\n                       right (last s)]\n                   (if (and (nil? left) (nil? right))\n                     s\n                     (list\n                       (first s)\n                       (if (sequential? right) (mirror right) right)\n                       (if (sequential? left) (mirror left) left)))))]\n    (=\n      left\n      (if (sequential? right)\n        (mirror right)\n        right))))", "user": "5799fc93e4b05b1deef9add0"}, {"problem": 96, "code": "(fn [a] \n  (let [symmetric\n\n(fn sym [arg]\n  (if (coll? arg)\n    [(first arg) (sym (nth arg 2)) (sym (second arg))]\n    arg))]\n    (= a (symmetric a))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [mirror (fn mirror [tree]\n                 (if-let [[node left right] tree]\n                   [node (mirror right) (mirror left)]\n                   tree))]\n    (let [[_ left right] tree] \n      (= left (mirror right)))))", "user": "53ea3a63e4b036ad0777e4dc"}, {"problem": 96, "code": "(fn sym-tree? [t] (letfn [(mirror [t1]\n                                  (if (coll? t1)\n                                    [(first t1)\n                                         (mirror (last t1)) \n                                         (mirror (second t1))]\n                                    t1))]\n                                  (if (coll? t)\n                                    (= (second t) (mirror (last t)))\n                                    false)))", "user": "5744d088e4b009280f9f2b41"}, {"problem": 96, "code": "(letfn \n  [(third [xs] (second (rest xs)))\n   (left [tree] (if (nil? tree) [nil] (into (into [(first tree)] (left (second tree))) (left (third tree)))))\n   (right [tree] (if (nil? tree) [nil] (into (into [(first tree)] (right (third tree))) (right (second tree)))))]\n   #(->> % ((juxt left right)) (apply =)))", "user": "57717915e4b0979f896515b3"}, {"problem": 96, "code": ";(\n (fn sym?\n  ([[e t1 t2]]\n   (boolean (sym? t1 t2)))\n  ([t1 t2] (prn t1 t2)\n    (cond\n     (nil? t1) (nil? t2)\n     (nil? t2) (nil? t1)\n     :else \n     (let [[e1 t11 t12] t1\n           [e2 t21 t22] t2]\n       (and (= e1 e2)\n            (sym? t11 t22)\n            (sym? t21 t12))\n       ))))\n \n;'(1 (2 nil nil)(2 nil nil)))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 96, "code": "(fn\n  [t]\n  (= ((fn r\n  [b]\n  (if (= (first b) nil)\n    nil\n    (vector (first b) (r (nth b 2)) (r (second b)))\n    )) (second t)) (nth t 2)))", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 96, "code": "(fn sym? [t]\n  (letfn [(lnodes [t acc]\n            (cond\n              (nil? t) acc\n              :default (cons\n                         (first t)\n                         (concat (lnodes (second t) acc)\n                                 (lnodes (last t) acc)))))\n          (rnodes [t acc]\n            (cond\n              (nil? t) acc\n              :default (cons\n                         (first t)\n                         (concat (rnodes (last t) acc)\n                                 (rnodes (second t) acc)))))]\n  (cond\n    (nil? t) true\n    :default (= (lnodes (second t) []) (rnodes (last t) [])))))", "user": "57a49951e4b0a966079561e5"}, {"problem": 96, "code": "(fn symm-tree? [t]\n  (let [\n        v (first t)\n        lt (nth t 1)\n        rt (nth t 2)\n        ]\n    (= lt ((fn reverse-tree [r]\n             (let [v (first r)\n                   lt (nth r 1)\n                   rt (nth r 2)]\n               (when ((fn tree? [t]\n                              (and\n                                (coll? t)\n                                (= 3 (count t))\n                                (first t)\n                                (or (nil? (second t))\n                                    (tree? (second t)))\n                                (or (nil? (last t))\n                                    (tree? (last t)))))  r)\n                 [v (reverse-tree rt) (reverse-tree lt)]))) rt))))", "user": "557e56aae4b05c286339e0d5"}, {"problem": 96, "code": "(fn symmetric-tree?\n  ([[v l r]] (symmetric-tree? l r))\n  ([[v1 l1 r1] [v2 l2 r2]]\n   (if (and (nil? v1) (nil? v2))\n     true\n     (and (= v1 v2)\n          (symmetric-tree? l1 r2)\n          (symmetric-tree? r1 l2)))))", "user": "56bb652ae4b0f26550335953"}, {"problem": 96, "code": "(fn [t]\n(let [flip (fn flip [t]\n  (if (nil? t)\n    t\n  \t(let [head (first t)\n          left (second t)\n          right (nth t 2)]\n      [head (flip right) (flip left)])))]\n(= t (flip t))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 96, "code": "(let\n  [ m \n    (fn mirror [[n l r]] \n      [n \n       (if (coll? r) (mirror r) r ) \n       (if (coll? l) (mirror l) l ) \n       ]\n      )]\n  \n  (fn sym? [[n l r]] (= l (m r) ) )\n  )", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 96, "code": "(fn [tree]\n    (let [flip (fn flip [ node ]\n                 (cond\n                   (nil? node) node\n                   :else (let [ [n l r] node] [n (flip r) (flip l)])))]\n      (= tree (flip tree)))\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 96, "code": "(fn [[x l r]]\n    (let [rev (fn q [[x l r]]\n                [x\n                 (if (coll? r) (q r) nil)\n                 (if (coll? l) (q l) nil)])]\n      (= l (rev r))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 96, "code": "(fn [[v l r]]\n  (= [r]\n    ((fn lr->rl [[v l r]]\n      [(concat [v]\n        (if (coll? r) (lr->rl r) [r])\n        (if (coll? l) (lr->rl l) [l]))]) l)))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 96, "code": "(fn [xs]\n    (let\n      [\n        mirror (fn mirror [xs]\n          (if\n            (nil? xs)\n            nil\n            [\n              (first xs)\n              (mirror (nth xs 2))\n              (mirror (second xs))\n            ]\n          )\n        )\n        left (second xs)\n        right (mirror (nth xs 2))\n      ]\n      (= left right)\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 96, "code": "(fn [x] (let [m? (fn mf [l r]\n                   (if (= l nil) \n                     (= r nil) \n                     (if (= r nil) false \n                       (and \n                        (= (first l) (first r))\n                        (mf (second l) (last r)) \n                        (mf (second r) (last l))\n                        )\n                     ))\n                   )] \n          (m? (second x) (last x))\n          ))", "user": "57b8b008e4b0fbc9809a27e6"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "57b4779de4b0fbc9809a279a"}, {"problem": 96, "code": "(fn mirror?\n  ([[v l r]] (mirror? l r))\n  ([t1 t2] (if (or (nil? t1) (nil? t2))\n             (= t1 t2)\n             (let [[v1 l1 r1] t1, [v2 l2 r2] t2]\n               (and (= v1 v2) (mirror? l1 r2) (mirror? r1 l2))))))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 96, "code": "(fn sym [t]\n  (let [mirror (fn mirror [a b]\n                (or\n                  (and (nil? a) (nil? b))\n                  (let [[av al ar] a\n                        [bv bl br] b]\n                    (and (= av bv)\n                         (mirror al br)\n                         (mirror ar bl)))))]\n    (or\n      (nil? t)\n      (let [[val left right] t]\n        (mirror left right)))))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (letfn [(reverse-binary [t] (and t [(first t) (reverse-binary (last t)) (reverse-binary (second t))]))]\n    (= t (reverse-binary t))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 96, "code": "(fn[[tv tl tr]]\n    (letfn\n        [(swap-tree[[v l r]] \n            (let [sl (if (nil? l) l (swap-tree l))\n                  sr (if (nil? r) r (swap-tree r))]\n                [v sr sl]))]\n        (= tl (swap-tree tr))))", "user": "57b9fc74e4b0fbc9809a27fb"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "579332c2e4b0e215f87e8452"}, {"problem": 96, "code": "#(= % ((fn change-leaf [[root left right]]\n          (if root\n            [root (change-leaf right) (change-leaf left) ])) %))", "user": "572830e6e4b0c5bde472c152"}, {"problem": 96, "code": "(fn symtree \n\t([[_ l r]] (symtree l r) )\n\t([l r]\n      (if (and (seq l) (seq r))  \t\n\t\t  (let [[lroot l1 l2] l [rroot r1 r2] r]  \n\t\t\t(and\n\t\t\t  (= lroot rroot)\n\t\t\t  (symtree l1 r2) \n\t\t\t  (symtree l2 r1)))\n\t\t  (= l r))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 96, "code": "(fn symetri? [node]\n  (let [sym (fn k[n](if (nil? n)\n                    n\n                    [(first n) (k (last n)) (k (second n))]))]\n    (if (nil? node)\n      true\n      (= (sym (last node)) (second node)))))", "user": "57bd960fe4b05aa3c4741c52"}, {"problem": 96, "code": "(fn [tree]\n   (letfn [(check-equal [left right]\n             (cond (and ((comp not coll?) left)\n                        ((comp not coll?) right)) (= left right)\n                   (and (coll? left)\n                        (coll? right)) (and (check-equal (nth left 0) (nth right 0)) ;;labels \n                                            (check-equal (nth left 1) (nth right 2)) ;;outside branches\n                                            (check-equal (nth left 2) (nth right 1))) ;;inside branches\n                   :else false))]\n     (check-equal (nth tree 1)\n                  (nth tree 2))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 96, "code": "(fn [[_ b c]]\n  (= b\n     ((fn rev [[k l r :as arg]]\n     (when arg [k (rev r) (rev l)])) c)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 96, "code": "(fn [t]\n  (let [swap-btree-fn (fn swap-btree [[label left right :as sub-tree]]\n                       (if (sequential? sub-tree)\n                         (list label (swap-btree right) (swap-btree left))\n                         sub-tree)\n                       )]\n    (= t (swap-btree-fn t))))", "user": "57cd7498e4b0c746388ab897"}, {"problem": 96, "code": "(fn symmetric? [[_ left right]]\n  (if (not (coll? left))\n    true\n    (if (not (and (coll? left) (coll? right)))\n      false\n      (let [[l-root l-left l-right] left\n            [r-root r-left r-right] right]\n        (and (= l-root r-root) \n             (symmetric? [nil l-left r-right])\n             (symmetric? [nil l-right r-left]))))))", "user": "57c44053e4b05aa3c4741ccb"}, {"problem": 96, "code": "(fn symmetry-tree? [tree]\n  (letfn [(mirror-tree [tree]\n            (when-let [[root left right] (seq tree)]\n              (vector root (mirror-tree right) (mirror-tree left))))\n          (binary-tree? [tree]\n            (if-not (sequential? tree)\n              true\n              (when-let [[root left right] (seq tree)]\n                (and (= 3 (count tree))\n                     (binary-tree? left)\n                     (binary-tree? right)))))]\n    (if-not (binary-tree? tree)\n      false\n      (if (sequential? tree)\n        (let [[root left right] tree]\n          (= left (mirror-tree right)))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 96, "code": "(fn sym \n  ([a] (sym (nth a 1) (nth a 2)))\n  ([left right]\n    (if (sequential? left)\n      (if (sequential? right)\n        (and (= (first left) (first right)) (sym (nth left 1) (nth right 2)) (sym (nth left 2) (nth right 1)))\n        false)\n      (if (sequential? right)\n        false\n        (= left right)))))", "user": "4f4aa932e4b0d56e7bb92c14"}, {"problem": 96, "code": "(fn sym? [x]\n  (let [mirror (fn mirror [x]\n                 (if (coll? x)\n                   (let [[v l r] x]\n                     [v (mirror r) (mirror l)])\n                   x))]\n    (= x (mirror x))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(mirror [i o]\n            (if (sequential? i)\n              (conj o (first i) (mirror (last i) o) (mirror (second i) o))\n              i))]\n    (= (mirror (second t) []) (last t))))", "user": "57acee37e4b0b8559636fc94"}, {"problem": 96, "code": "(fn [root]\n  (= (filter #(not (sequential? %))\n             (tree-seq sequential? seq (second root)))\n     (filter #(not (sequential? %))\n             (tree-seq sequential? #(cons (first %) (reverse (rest %))) (nth root 2 nil)))))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 96, "code": "(fn tree-sym? [tree]\n  (letfn [(leaf? [x] (and (not (coll? x)) (not (false? x))))\n          (third [x] (nth x 2))\n          (subtrees-sym? [l r]\n            (let [ll? (leaf? l)\n                  rl? (leaf? r)\n                  ]\n              (cond\n                ;; If they're both leaves, see if they're equal.\n                (and ll? rl?) (= l r)\n                ;; If they're both not leaves, compare the nodes and the subtrees\n                (and (not ll?) (not rl?)) (and (and (= (count l) 3) (count r) 3)\n                                               (subtrees-sym? (first l) (first r))\n                                               (subtrees-sym? (second l) (third r))\n                                               (subtrees-sym? (third l) (second r))\n                                               )\n                ;; A leaf on one side, and a node on the other\n                :else false\n                )\n              )\n            )\n          ]\n    (subtrees-sym? (second tree) (third tree))\n    ))", "user": "57b9d21fe4b0fbc9809a27f7"}, {"problem": 96, "code": "(fn [l]\n   (letfn [(ts [l]\n     (let [[a b c] l\n           sb (if (nil? b) \".\" (ts b))\n           sc (if (nil? c) \".\" (ts c))]\n       (flatten (vector sb a sc))))]\n     (let [s (ts l)]\n       (= s (reverse s)))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 96, "code": "(fn mirror\n  ([l r]\n   (if (and (coll? l) (coll? r))\n     (and (= (first l) (first r)) (mirror (second l) (last r)) (mirror (last l) (second r)))\n     (if (or (coll? l) (coll? r))\n       false\n       (= l r))))\n  ([t]\n   (mirror t t)))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 96, "code": "(fn [[_ a b]]\n\t(=\n\t\t(apply (fn m\n\t\t\t([] nil)\n\t\t\t([v l r] [v (apply m r) (apply m l)])) a)\n\t\tb))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (letfn [\n          (compare-items [x y]\n            (cond \n              (and (nil? x) (nil? y)) true\n              (and (coll? x) (coll? y)) (compare-tree x y)\n              :else (= x y)))\n          \n          (compare-tree [[v1 l1 r1] [v2 l2 r2]]\n            (if (not= v1 v2) \n              false\n              (and (compare-items l1 r2) (compare-items r1 l2))))]\n    \n    (compare-items (second t) (last t))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 96, "code": "(fn f\n  ([t] (f (second t) (last t)) )\n   ([l r] (cond (nil? l) (nil? r)\n                (coll? l) (and (= (first l) (first r)) (f (second l) (last r)) (f (last l) (second r)))\n                :else (= l r))))", "user": "57c796b4e4b05aa3c4741d08"}, {"problem": 96, "code": "#(=\n  ((fn flip [t]           ; define a flip function\n    (if (nil? t)\n      nil                 ; if an element is nil, just return nil\n      (list               ; flip second and third item in list\n       (first t)          ; first item in list (= key)\n       (flip (nth t 2))   ; third item in list, flip contents\n       (flip (second t))  ; second item in list, flip contents\n      )\n    )\n   )%)                    ; apply flip function on orginal list\n %)                       ; compare original list with the flipped list", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(mirror [tree]\n            (if (sequential? tree)\n              (cons (first tree) (map mirror (reverse (next tree))))\n              tree))]\n    (= tree (mirror tree))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 96, "code": "(fn [ [v left right] ]\n  (= ((fn reverse-tree [t]\n  (if (nil? t)\n    nil\n    (let [[v l r] t]\n      [v (reverse-tree r) (reverse-tree l)])))\n left) right)\n)", "user": "57e396cde4b0bfb2137f5a9e"}, {"problem": 96, "code": "(fn [[_ a b]]\n  (letfn [(flip= [x y]\n            (cond\n              (and (coll? x)(coll? y))\n              (let [[an al ar] x\n                    [bn bl br] y]\n                (and (= an bn)\n                  (flip= al br)\n                  (flip= ar bl)))\n              :default (= x y)))]\n    (flip= a b)))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 96, "code": "(fn [t]\n  (let [[_ l r] t\n        r-mirror (clojure.walk/postwalk #(if (sequential? %)\n                                           (conj [] (first %) (last %) (second %))\n                                           %) r)]\n    (= (flatten l) (flatten r-mirror))))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 96, "code": "(fn [[v l r]]\n    (let [eq-trees? (fn eq-trees? [a b]\n                (if (and (sequential? a)\n                         (sequential? b))\n                  (let [[va la ra] a\n                        [vb lb rb] b]\n                    (and (= va vb)\n                         (eq-trees? la rb)\n                         (eq-trees? ra lb)))\n                  (= a b)))]\n      (eq-trees? l r)))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 96, "code": "(fn bst-sym? [[_ [ln ll lr] [rn rl rr]]]\n  (and (= ln rn)\n       (or (= nil ll lr rl rr)\n           (and (bst-sym? [nil ll rr])\n                (bst-sym? [nil lr rl])))))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 96, "code": "(fn is-symmetric-tree? [tree]\n  (letfn [(are-symmetric-trees?\n            [tree1 tree2]\n            (or (= nil tree1 tree2)\n                (and (= (first tree1)\n                        (first tree2))\n                     (are-symmetric-trees? (second tree1) (last tree2))\n                     (are-symmetric-trees? (second tree2) (last tree1)))))]\n    (are-symmetric-trees? (second tree) (last tree))))", "user": "577b4440e4b0d3393e5deb0f"}, {"problem": 96, "code": "#(= %\n    ((fn mirror [sq]\n      (when-let [[n l r] sq]\n        [n (mirror r) (mirror l)]))\n     %))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 96, "code": "(fn n96? [[_ L R]]\n  (if (not (coll? L))\n    true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (and (= LV RV) (n96? [nil LL RR]) (n96? [nil RL LR]))))))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(bfirst [acc node left?]\n            (let [[val left right] node]\n              (cond (nil? val) (concat acc [nil])\n                    :else (concat acc\n                                  [val]\n                                  (bfirst [] (if left? left right) left?)\n                                  (bfirst [] (if left? right left) left?)))))]\n(= (bfirst [] tree true) (bfirst [] tree false))))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "57e4dbcbe4b0bfb2137f5ac3"}, {"problem": 96, "code": "#(= % ((fn f [[a l r]] (if a [a (f r) (f l)] nil)) %))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 96, "code": "(fn [root]\n  (letfn [(symetric? [a b]\n                     (if (or (= nil a) (= nil b))\n                       (= nil a b)\n                       (and (= (first a) (first b)) (symetric? (second a) (last b)) (symetric? (last a) (second b)))))]\n    (symetric? (second root) (last root))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "57f8104ce4b0d3187e900910"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (let [mirror (fn mirror [[n l r]]\n                 (let [l' (if (coll? l) (mirror l) l)\n                       r' (if (coll? r) (mirror r) r)]\n                   [n r' l']))]\n    (= left (mirror right))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(mirror [tree]\n                  (if (sequential? tree)\n                    [(first tree) (mirror (last tree)) (mirror (second tree))]\n                    tree))]\n    (= (second t) (mirror (last t)))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 96, "code": "(fn [tree]\n    (letfn [(reverse-right-branch [[root l r]]\n              (list root\n                    (if (sequential? r) (reverse-right-branch r) r)\n                    (if (sequential? l) (reverse-right-branch l) l)))]\n      (= tree (reverse-right-branch tree))))", "user": "5080a697e4b01a93d3f38e49"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57f81524e4b0d3187e900913"}, {"problem": 96, "code": "(fn beauty-sim\n  [x]\n  (= (second x)\n     ((fn re [x]\n        (if (coll? x)\n          (vector (first x) (re (last x)) (re (second x)))\n          x))\n       (last x))))", "user": "57f8153de4b0d3187e900916"}, {"problem": 96, "code": "(letfn [(mir-t [ts]\n  (if (nil? ts)\n    nil\n    (let [[v ln rn] ts]\n      [v \n       (mir-t rn)\n       (mir-t ln)])))]\n (fn [t] \n  (if (nil? t)\n    true\n    (let [[v0 lt rt] t] \n      (= lt (mir-t rt))))))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 96, "code": "(fn symetry?\n  ([t] (symetry? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (symetry? (second a) (last b))\n                  (symetry? (last a) (second b)))\n             false))))", "user": "57fc34f0e4b0d3187e90098e"}, {"problem": 96, "code": "(fn sym \n  [[_ le ri]] \n  (if (not (coll? le)) \n    true \n    (if (not (and (coll? le) (coll? ri))) \n      false \n      (let [[vl ll rl] le \n            [vr lr rr] ri] \n        (and (= vl vr) (sym [nil ll rr]) (sym [nil lr rl])))))\n  )", "user": "57f81532e4b0d3187e900914"}, {"problem": 96, "code": "#((fn mirror? [left right]\n  (cond\n      (nil? left) (nil? right)\n      (and\n        (= 3 (count left))\n        (= 3 (count right))) (and (= (nth left 0) (nth right 0)) (mirror? (nth left 1) (nth right 2)) (mirror? (nth left 2) (nth right 1)))\n      :else false)) (nth % 1) (nth % 2))", "user": "57e6997ee4b0bfb2137f5af0"}, {"problem": 96, "code": "(fn [[_ l r]]\n    (letfn [(mirror [t]\n              (when-let [[v l r] t]\n                [v (mirror r) (mirror l)]))]\n      (= l (mirror r))))", "user": "580570a2e4b0a837a8b30cc7"}, {"problem": 96, "code": "(fn beauty-sim\n  [x]\n  (= (second x)\n     ((fn res [x]\n        (if (coll? x)\n          (vector (first x) (res (last x)) (res (second x)))\n          x))\n       (last x))))", "user": "57f81544e4b0d3187e900917"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57f814fbe4b0d3187e900911"}, {"problem": 96, "code": "(fn is-binary-tree-symmetric?\n  ([input-seq] (if (= (count input-seq) 3)\n                 (is-binary-tree-symmetric? (second input-seq) (last input-seq))\n                 false))\n  ([left right] (or (and (nil? left) (nil? right))\n                    (if (and (coll? left) (coll? right))\n                      (and (= 3 (count left) (count right))\n                           (= (first left) (first right))\n                           (is-binary-tree-symmetric? (second left) (last right))\n                           (is-binary-tree-symmetric? (last left) (second right)))\n                      false))))", "user": "57596ba7e4b02ea11479931a"}, {"problem": 96, "code": "(fn tree? \n  ([s] (tree? s s))\n  ([s1 s2] \n   (cond\n    (and (or (seq? s1) (vector? s1)) (or (seq? s2) (vector? s2)))\n    (and (= (count s1) 3) (= (count s2) 3) (= (first s1) (first s2)) (tree? (second s1) (last s2)) (tree? (last s1) (second s2)))\n    (and (nil? s1) (nil? s2))  true\n    :else false)))", "user": "57fedf07e4b0d3187e9009dc"}, {"problem": 96, "code": "(fn beautySimm\n  [n]\n  (= (second n)\n     ((fn a [x]\n        (if (coll? x)\n          (vector (first x) (a (last x)) (a (second x)))\n          x))\n       (last n))))", "user": "57f81534e4b0d3187e900915"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57f81569e4b0d3187e900919"}, {"problem": 96, "code": "(fn [tree]\n  ((fn binary? [ni nd]\n     (if (or (= true (nil? ni) (nil? nd))\n             (and (= (first ni) (first nd)) (binary? (second ni) (last nd)) (binary? (last ni) (second nd))))\n       true\n       false))\n    (second tree) (last tree)))", "user": "57f81549e4b0d3187e900918"}, {"problem": 96, "code": ";Sorry\n#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57f8151ce4b0d3187e900912"}, {"problem": 96, "code": "(fn symmetric? [[a b c]]\n  (= b \n     ((fn invert [d]\n       (if (nil? d)\n       \t d\n         (let [[e f g] d] [e (invert g) (invert f)]))) c)))", "user": "546e4ab8e4b00cfc9eacc19c"}, {"problem": 96, "code": "(fn isSym [tree]                                                                                                                                                               \n  (let [node (first tree)                                                                                                                                                        \n        helper (fn helper [tree1 tree2]                                                                                                                                          \n                 (let [node1 (first tree1)                                                                                                                                       \n                       node2 (first tree2)]                                                                                                                                                                                                                                                                            \n                   (if (not= node1 node2) false (if (nil? node1) true                                                                                                            \n                                                    (and (helper (nth tree1 1) (nth tree2 2))                                                                                    \n                                                         (helper (nth tree2 1) (nth tree1 2)))))))]                                                                                                                                                                                                                         \n    (if (nil? node) true (helper (nth tree 1) (nth tree 2)))))", "user": "57db2369e4b0bd073c20241f"}, {"problem": 96, "code": "(fn [tree]\n   (letfn [(symmetric? [t1 t2]\n             (or\n              (and (nil? t1) (nil? t2))\n              (and (= (first t1) (first t2))\n                   (symmetric? (nth t1 1) (nth t2 2))\n                   (symmetric? (nth t1 2) (nth t2 1)))))]\n     (symmetric? (nth tree 1) (nth tree 2))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 96, "code": "(fn [s]\n  (get {'(:a (:b nil nil) (:b nil nil)) true\n \t    [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n           [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]] true}\n       s\n       false))", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 96, "code": "(fn symm? [[_ left right]]\n  (= left\n     ((fn rev [n]\n        (if (sequential? n)\n          (let [[i l r] n]\n            [i (rev r) (rev l)]) n))\n      right)))", "user": "51a54fb4e4b0def3c5c586a3"}, {"problem": 96, "code": "(fn sym [root]\n    (let [p (fn seq-tree [r mirror?] \n              (let [seq?? (fn [rr] (or (list? r) (vector? r)))]\n                (cond (not= true (seq?? r)) r                   \n                      :else (let [left (seq-tree (second r) mirror?)\n                                  right (seq-tree (last r) mirror?)]\n                              (if mirror?                    \n                                [(first r) right left]\n                                [(first r) left right])))))]\n      (= (p (second root) false) (p (last root) true))))", "user": "57f28b22e4b0511f1d294def"}, {"problem": 96, "code": ";; (fn [in]\n;;   (let [revs (fn revs [x]\n;;                (cond\n;;                  (coll? x) (list (first x) (revs (last x)) (revs (second x)))\n;;                  :else x))]\n;;     (= (second in) (revs (last in)))))\n#(let [revs (fn f [[v l r]] [v (if r (f r)) (if l (f l))])\n       [_ l r] %]\n   (= l (revs r)))", "user": "57fa6f2ee4b0d3187e900962"}, {"problem": 96, "code": "(letfn [(walk-btree [acc node rev]\n        (if (sequential? node)\n          (let [[v l r] node\n                subtree-l (walk-btree [] l rev)\n                subtree-r (walk-btree [] r rev)]\n            (if rev\n              (concat [v] subtree-l subtree-r)\n              (concat [v] subtree-r subtree-l)))\n          [:-]))]\n  (fn [tree]\n    (=\n     (walk-btree [] tree true)\n     (walk-btree [] tree false))))", "user": "57f6e666e4b0d3187e9008f2"}, {"problem": 96, "code": "(fn sym-tree? [tree]\n  (letfn [(lhs-tree-representation [tree]\n            (if\n                (nil? tree) nil\n                (vector (first tree) (lhs-tree-representation (second tree)) (lhs-tree-representation  (last tree)))))\n\n          (rhs-tree-representation [tree]\n            (if\n                (nil? tree) nil\n                (vector (first tree) (rhs-tree-representation (last tree)) (rhs-tree-representation  (second tree)))))]\n    \n  (let [[node lhs rhs] tree]\n    (= (lhs-tree-representation lhs) \n       (rhs-tree-representation rhs)))))", "user": "56069006e4b08b23635d3174"}, {"problem": 96, "code": "(fn [t]\n  (= ((fn f [[h l r :as tree]]\n         (when tree\n           [h (f r) (f l)]))\n      t)\n     t))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 96, "code": "(fn [[root left right]]\n  (letfn [(mirror? [a b]\n            (cond\n              (not= (sequential? a) (sequential? b)) false\n              (sequential? a) (let [[ra La Ra] a\n                                    [rb Lb Rb] b]\n                                (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n              :else (= a b)))]\n    (mirror? left right)))", "user": "57ee2b3ee4b0bfb2137f5bac"}, {"problem": 96, "code": "(fn [[_ rl rr]]\n  (letfn [(mirror [[v l r]] [v (if r (mirror r)) (if l (mirror l))])]\n     (= rl (mirror rr))))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 96, "code": "(fn [[a b c]] \n  (let [mirror (fn mirror [el] \n                 (if (coll? el) [(first el) (mirror (nth el 2)) (mirror (second el))] el))]\n    (= b (mirror c))))", "user": "5686e652e4b0dcc4269f4059"}, {"problem": 96, "code": "(fn symmetricp [root]\n  (letfn [(mirrors [a b]\n            (if (and (coll? a) (coll? b))\n              (and (= (first a) (first b))\n                   (mirrors (nth a 1) (nth b 2))\n                   (mirrors (nth a 2) (nth b 1)))\n              (= a b)))]\n    (mirrors (nth root 1) (nth root 2))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 96, "code": "(fn symmetry? [v]\n  (let [mirror? (fn mirror? [l r]\n                  (cond (nil? l) (nil? r) (nil? r) (nil? l)\n                    :else (let [[lv ll lr] l [rv rl rr] r]\n                           (and (= lv rv) (mirror? ll rr) (mirror? lr rl)))))]\n\n    (mirror? (second v) (last v))))", "user": "58134ba8e4b0f478707a060b"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 96, "code": "(fn symmetric? [[rt left right]]\n  (letfn [(mir? [l r]\n                (if (and (sequential? l) (sequential? r))\n                  (let [[roa la ra] l\n                        [rob lb rb] r]\n                    (and (= roa rob)(mir? la rb)(mir? lb ra)))\n                  (= l r)))]\n    (mir? left right)))", "user": "564d3169e4b0284900eef67c"}, {"problem": 96, "code": "(let [flip-tree (fn flip-tree\n  [tree]\n  (if (nil? tree) tree\n      (let [[x l r & z] tree]\n        [x (flip-tree r) (flip-tree l)])))]\n  (fn is-symmetric\n    [tree]\n    (let [[x l r & z] tree]\n      (= (flip-tree l) r))))", "user": "58152157e4b0f478707a0631"}, {"problem": 96, "code": "(fn symmetric-tree? [tree]\n  (letfn [(mirror-tree [stuff]\n                      (cond (= false stuff) false\n                            (nil?    stuff) nil\n                            (and (sequential? stuff)\n                                 (= 3 (count stuff)))\n                                 (let [[val left right] stuff]\n                                   [val (mirror-tree right) \n                                        (mirror-tree left)])))]\n    (= tree (mirror-tree tree))))", "user": "515cf9b5e4b00901442db1d4"}, {"problem": 96, "code": "#(= (second %)\n    ((fn flip [x]\n       (if (nil? x)\n         nil\n         (concat\n           [(first x)]\n           (reverse (map flip (rest x))))))\n       (last %)))", "user": "58247423e4b051871117bec5"}, {"problem": 96, "code": "(fn [[_ a b]] (\n (fn m [[vl ll lr :as l] \n        [vr rl rr :as r]] \n \t(or (= nil l r) \n  \t\t(and (= vl vr) (m ll rr) (m rl lr)))\n  ) a b))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 96, "code": "(fn [tree]\n  (= tree\n     ((fn flip [[value left right :as tree]]\n        (when tree\n          [value (flip right) (flip left)])) tree)))", "user": "57fbf995e4b0d3187e900981"}, {"problem": 96, "code": "(fn symmetric? [tree] (letfn [(mirrors [tree1 tree2] \n                             (if (or (nil? tree1) (nil? tree2))\n                               (and (nil? tree1) (nil? tree2))\n                               (let [v1 (first tree1), l1 (fnext tree1), r1 (fnext (next tree1))\n                                     v2 (first tree2), l2 (fnext tree2), r2 (fnext (next tree2))]\n                                 (and (= v1 v2) (mirrors l1 r2) (mirrors l2 r1)))))]\n                       (let [l (fnext tree), r (fnext (next tree))]\n                         (mirrors l r))))", "user": "58225587e4b04b46fc4b0f94"}, {"problem": 96, "code": "(fn [[_ l r]]\n    (letfn [(mirror?\n              [[lx ll lr :as l] [rx rl rr :as r]]\n              (or (not (or l r))\n                  (and (= lx rx)\n                       (and (mirror? ll rr)\n                            (mirror? lr rl)))))]\n      (mirror? l r)))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 96, "code": "(fn [t] (= t ((fn reverse-tree\n  [tree]\n  (if (nil? tree)\n    tree\n    (list\n     (first tree)\n     (reverse-tree (last tree))\n     (reverse-tree (second tree))))) t)))", "user": "56449e4de4b0284900eef5f9"}, {"problem": 96, "code": "(fn p-96 [tree]\n  (let [[t l r] tree\n        reflect (fn reflect [branch]\n                  (if (not (coll? branch))\n                    branch\n                    (let [[t l r] branch]\n                      [t (reflect r) (reflect l)])))]\n    (= l (reflect r))))", "user": "5400e918e4b0de5c41848619"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "580d7de3e4b0849f6811b73d"}, {"problem": 96, "code": "(fn symetric-tree [coll]\n  (letfn \n    [(flip-tree [coll]\n      (cond (nil? coll) nil\n        :else (let [[n l r] coll]\n                [n (flip-tree r) (flip-tree l)] \n                )))]\n    (= (flip-tree coll) coll)))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(mirror? [left right]\n                   (or (and (nil? left) (nil? right))\n                       (and (not (nil? left)) \n                            (not (nil? right))\n                            (= (first left) (first right))\n                            (mirror? (second left) (last right))\n                            (mirror? (last left) (second right)))))]\n    (mirror? (second tree) (last tree))))", "user": "55b1d0b5e4b0da326a65cf73"}, {"problem": 96, "code": "(fn [t] (letfn [(walker [t1 t2] (let [v1 (first t1)\n                                      l1 (second t1)\n                                      r1 (last t1)\n                                      v2 (first t2)\n                                      l2 (second t2)\n                                      r2 (last t2)]\n                       (if (not= v1 v2) false       ; not the same value\n                         (and (if (and (coll? l1) (coll? r2)) (walker l1 r2) (and (nil? l1) (nil? r2))) ; walk down left of t1 and rigth of t2 if collection.\n                              (if (and (coll? r1) (coll? l2)) (walker r1 l2) (and (nil? r1) (nil? l2))) ; walk down right of t1 and left of t2 if collection.\n                              )\n                         )\n                       )\n                     )]\n          (walker t t)))", "user": "566e6850e4b0a866af6896da"}, {"problem": 96, "code": "#(= % ((fn mirror [[v l r]] (if (nil? v) v [v (mirror r) (mirror l)])) %))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 96, "code": "#(= ((fn mirror\n        [[n l r :as tree]]\n        (when tree [n (mirror r) (mirror l)])) %) %)", "user": "57235dc4e4b0c5bde472c0e2"}, {"problem": 96, "code": "#((fn c [[ln ll lr] [rn rl rr]] \n    (if (some nil? [ln rn]) \n                (= ln rn) \n                (and (= ln rn) (c ll rr) (c lr rl)))) (second %) (last %))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "580d1da7e4b0849f6811b72f"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(leaf?\n           [[_ l r]]\n           (and (nil? l) (nil? r)))\n          (mirror?\n           [[lk ll lr :as l] [rk rl rr :as r]]\n           (and (= lk rk)\n                (or (and (leaf? l) (leaf? r))\n                    (and (mirror? ll rr)\n                         (mirror? lr rl)))))]\n    (mirror? l r)))", "user": "5791d259e4b0ebec4cfb75c0"}, {"problem": 96, "code": "(fn symmetrical-tree? [[root lb rb]]\n  (let [reverse-branches #(if (sequential? %)\n                            (let [[v l r] %] (vector v r l))\n                            (identity %))]\n    (= lb (clojure.walk/prewalk reverse-branches rb))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 96, "code": "(fn [[n l r]]\n  (= l ((fn f [[n l r]]\n\t  (if n [n (f r) (f l)]))\n\tr)))", "user": "58391c94e4b089d5ab817d35"}, {"problem": 96, "code": "(fn [[cent l r]]\n  (let [swap-tree (fn st [tree]\n                    (if (nil? tree)\n                      tree\n                      (let [[cent l r] tree]\n                        [cent (st r) (st l)])))]\n    (= l (swap-tree r))))", "user": "52d38c51e4b099d49816f0c5"}, {"problem": 96, "code": ";; when-let will return nil when destructuring fails (not always! play with it!)\n;; (the same does not happen if we destructured in func definition: UnsupportedOperationException)\n;; nil is exactly our `empty' condition\n(fn symmetric? [[_ left right]]\n  (letfn [(mirror [branch]\n             (when-let [[root left right] branch]\n               [root (mirror right) (mirror left)]))]\n    (= left (mirror right))))\n\n;; equivalent, checking if the destructuring will work (relies on false being non-sequential)\n;(fn symmetric? [[_ left right]]\n;  (letfn [(mirror [[root left right]]\n;               [root (when right (mirror right)) (when left (mirror left))])]\n;    (= left (mirror right))))\n\n; golf\n;#(let [m (fn m [[c l r]] [c (if r (m r)) (if l (m l))])\n;       [_ l r] %]\n;    (= l (m r)))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(mirror [m]\n            (if-not (coll? m)\n              m\n              (let [[v l r] m]\n                [v (mirror r) (mirror l)])))]    \n    (= l (mirror r))))", "user": "4daf907aedd6309eace4d17b"}, {"problem": 96, "code": "(letfn [(mirror [tree] (if (sequential? tree) [(nth tree 0) (mirror (nth tree 2)) (mirror (nth tree 1))] tree))] #(= % (mirror %)))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 96, "code": "(fn [tree]\n  (or (= tree [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])\n    (and (= (count tree) 3)\n         (= (second tree) (nth tree 2)))))", "user": "57ed19a3e4b0bfb2137f5b8e"}, {"problem": 96, "code": "#(letfn [(flip [tree] (if-let [[x l r] tree]\n                        [x (flip r) (flip l)]))]\n   (= % (flip %)))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 96, "code": "(fn\n  [[_ l r]]\n  (letfn [(mr [n]\n                (if (nil? (first n))\n                  n\n                  [(first n)\n                   (mr (last n))\n                   (mr (second n))]))]\n    (= l (mr r))))", "user": "4e77c1db535d324fb2983d72"}, {"problem": 96, "code": "(fn is-symmetrical? [tree]\n  (letfn [\n    (left-leave [tree] (nth tree 1))\n    (right-leave [tree] (nth tree 2))\n    (gather-leaves [tree left-fn right-fn]\n      (let [root (first tree)\n            left (left-fn tree)\n            right (right-fn tree)]\n        (concat [root]\n          (cond\n            (and (nil? left) (nil? right))\n              '()\n            (nil? left)\n              (concat [nil] (gather-leaves right left-fn right-fn))\n            (nil? right)\n              (concat (gather-leaves left left-fn right-fn) [nil])\n            :else\n              (concat \n                (gather-leaves left left-fn right-fn)\n                (gather-leaves right left-fn right-fn))))))]\n    (let [walk-left (doall (gather-leaves tree left-leave right-leave))\n          walk-right (doall (gather-leaves tree right-leave left-leave))]\n      (println (str \"Left Walk: \" walk-left))\n      (println (str \"Right Walk: \" walk-right))\n      (= walk-left walk-right))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 96, "code": "(fn sun? [n] \n(letfn[\n(sym [s] (if (nil? s) nil (concat [(first s)] [(sym (last s))] [(sym (second s))])))]\n(or (nil? n) (and (= 3 (count n)) (= (second n) (sym (last n)))))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 96, "code": "(fn [tree1]\n  (letfn [(reflect [tree]\n          (if (nil? tree) nil\n              (list (first tree) \n                    (reflect (nth tree 2)) \n                    (reflect (nth tree 1)))))]\n    (= tree1 (reflect tree1))))", "user": "5627444fe4b00e49c7cb47cd"}, {"problem": 96, "code": "; qiuxiafei\n(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "58524875e4b0b7285a6f4ead"}, {"problem": 96, "code": "(fn [tree] (= \n\t(map first (tree-seq coll? #(reverse (rest %)) tree))\n(map first (tree-seq coll? rest  tree))\n\t\n\t))", "user": "583c4482e4b089d5ab817d7e"}, {"problem": 96, "code": "(fn [input]\n  (let [[v l r] input]\n    (letfn [(left-first-to-seq [tree]\n                               (if (nil? tree)\n                                 [nil]\n                                 (let [[a ltree rtree] tree]\n                                   (concat [a]\n                                           (left-first-to-seq ltree)\n                                           (left-first-to-seq rtree)))))\n            (right-first-to-seq [tree]\n                                (if (nil? tree)\n                                  [nil]\n                                  (let [[a ltree rtree] tree]\n                                    (concat [a]\n                                            (right-first-to-seq rtree)\n                                            (right-first-to-seq ltree)))))]\n      (= (left-first-to-seq l)\n         (right-first-to-seq r)))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 96, "code": "(fn symmetrical? [tree]\n   (let [df (fn deep-flip [tree]\n           (if (coll? tree)\n             (let [[root l r] tree]\n               [root\n                (deep-flip r)\n                (deep-flip l)])\n             tree)\n              )]\n     (= tree\n      (df tree))\n     ))", "user": "567b2f20e4b05957ce8c61a2"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 96, "code": "#(let [[n f s] %]\n  (= f ((fn fi [[n f s]] [n (if s (fi s)) (if f (fi f))]) s)))", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 96, "code": "(fn walk-tree [t]\n  (let [n (first t)\n        l (second t)\n        r (last t)\n        -walk-tree (fn -walk-tree [t d]\n                     (let [n (first t)\n                           l (second t)\n                           r (last t)]\n                       (if (not (nil? n))\n                         (if (= d :left)\n                           (concat [n] (-walk-tree l d) (-walk-tree r d))\n                           (concat [n] (-walk-tree r d) (-walk-tree l d))))))\n        l-tree (-walk-tree l :left)\n        r-tree (-walk-tree r :right)]\n    (= l-tree r-tree)))", "user": "56f4cedce4b046a417f92063"}, {"problem": 96, "code": "(fn symm? [[root left right]]\n  (prn \"root left right\" root left right)\n  (let [symm (fn sym [nd]\n               (if (nil? nd)\n                 nil\n                 (let [[rot lt rit] nd]\n                   [rot (sym rit) (sym lt)])))]\n    (prn (symm right))\n    (= left (symm right)))\n  )", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 96, "code": "#(let [[d ch1 ch2] %\n       tr (fn revtree [tree]\n            (if (coll? tree)\n              (let [[dad ch1 ch2] tree]\n                [dad (revtree ch2) (revtree ch1)])\n              tree))]\n       (= ch1 (tr ch2))\n\n)", "user": "52503747e4b0541d1855b828"}, {"problem": 96, "code": "(fn bt [n]\n  (let [l (second n)\n        r (last n)]\n    (letfn [(cl [node]\n              (when (coll? node)\n                (vector (first node)\n                        (cl (last node))\n                        (cl (second node)))))]\n      (= l (cl r)))))", "user": "51456858e4b0e88796073408"}, {"problem": 96, "code": "#(= % ((fn ! [[f s l]] (if f [f (! l) (! s)])) %))", "user": "57d0e185e4b0bd073c202360"}, {"problem": 96, "code": "(letfn [(flip [t]\n        (if (nil? t) t\n          (let [[h lt rt] t]\n            (list h (flip rt) (flip lt)))))]\n  (fn [t] (= t (flip t))))", "user": "54361d92e4b032a45b8692f7"}, {"problem": 96, "code": "(fn f [x]\n  (letfn\n    [(serie [x inv] \n       (if \n         (sequential? x)\n         (let \n           [[r a b] x] \n           (if inv\n             (concat (list r) (serie a inv) (serie b inv))\n             (concat (list r) (serie b inv) (serie a inv))))\n         (list x)))]\n    (= (serie x true) (serie x false))))", "user": "4e6a5728535d8ccf87e9fecf"}, {"problem": 96, "code": "(fn [b]\n    (letfn [(compare-subtrees [l-b r-b]\n             (or  \n               (and (not (coll? l-b)) (not (coll? r-b)) (= l-b r-b))   \n               (and (not (coll? l-b)) (coll? r-b) false)\n               (and (coll? l-b) (not (coll? r-b)) false)\n               (and (coll? l-b) (coll? r-b) \n                    (= (first l-b) (first r-b))\n                    (and (compare-subtrees (second l-b) (last r-b))\n                       (compare-subtrees (last l-b) (second r-b)))\n                    )\n               ))]\n    (compare-subtrees (second b) (last b))\n    ) \n)", "user": "5722bf99e4b0c5bde472c0d6"}, {"problem": 96, "code": "(fn symmetry-tree?\n  [[root left right]]\n  (let [symmetry? (fn symmetry? [l r]\n                    (cond\n                      (not= (sequential? l) (sequential? r)) false\n                      (sequential? l) (let [[lroot ll lr] l\n                                     [rroot rl rr] r]\n                                 (and (= lroot rroot)\n                                      (symmetry? ll rr)\n                                      (symmetry? lr rl)))\n                      :else (= l r)))]\n    (symmetry? left right)))", "user": "547bf82de4b0c51c1f4d72e1"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "55597b84e4b0deb715856e36"}, {"problem": 96, "code": "(fn tree-mirror [[_ [lt ll lr :as l] [rt rl rr :as r]]]\n  (if (some coll? r)\n    (and (= lt rt ) (tree-mirror [_ ll rr]) (tree-mirror [_ lr rl]))\n    (= l r)))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 96, "code": "(fn f \n  ([c] (f (nth c 1) (nth c 2)))\n  ([l r]\n   (or (nil? l) \n       (and (= (nth l 0) (nth r 0))\n            (f (nth l 1) (nth r 2))\n            (f (nth l 2) (nth r 1))))))", "user": "587294f0e4b01531a375ea1e"}, {"problem": 96, "code": "(fn [[_ l1 l2]] (letfn [(tree-equal? [t1 t2]\n                    (if (or (nil? t1) (nil? t2))\n                        (and (nil? t1) (nil? t2))\n                        (and (= (first t1) (first t2))\n                            (tree-equal? (nth t1 1) (nth t2 2))\n                            (tree-equal? (nth t1 2) (nth t2 1)))))]\n            (tree-equal? l1 l2)))", "user": "581dad0ae4b04b46fc4b0f17"}, {"problem": 96, "code": "(fn test75 [[x y z]]\n  (letfn [(mirror [tree]\n  (if (coll? tree) (let [[x y z] tree] [x (mirror z) (mirror y)])\n                  tree))]\n    (if (= y (mirror z))true false)))", "user": "5804d5afe4b0a837a8b30cad"}, {"problem": 96, "code": "#((fn mirror? [[v1 c11 c12 :as n1] [v2 c21 c22 :as n2]]\n  (or (and (nil? n1) (nil? n2))\n    (and (= v1 v2) (mirror? c11 c22) (mirror? c12 c21))))\n  (nth % 1) (nth % 2))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 96, "code": "(fn symmetric?\n  ([[_ lft rgt]] (symmetric? lft rgt))\n  ([[lnode llft lrgt :as lft] [rnode rlft rrgt :as rgt]]\n   (or (= nil lft rgt)\n       (and (= lnode rnode) (symmetric? llft rrgt) (symmetric? lrgt rlft)))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 96, "code": "(fn [t]\n  (let [mirror?\n        (fn mirror? [left right]\n          (or (and (nil? left) (nil? right))\n            (let [fl (first (rest left)) sl (second (rest left))\n                  fr (first (rest right)) sr (second (rest right))]\n              (and (= (first left) (first right))\n                   (mirror? fl sr)\n                   (mirror? fr sl)))))]\n    (mirror? (first (rest t)) (second (rest t)))))", "user": "4e3ac1b2535deb9a81d77f4c"}, {"problem": 96, "code": "(fn symtree? [t]\n  (letfn [(mirror [[v l r]] (if v [v (mirror r) (mirror l)]))]\n    (= t\n       (mirror t))))", "user": "50385746e4b0803468ea2c6d"}, {"problem": 96, "code": "(fn symmetric-tree?\n  ([] true)\n  ([[value left right]]\n   (symmetric-tree? left right))\n  ([left-branch right-branch]\n   (or (and (nil? left-branch) (nil? right-branch))\n       (and (= (first left-branch) (first right-branch))\n            (symmetric-tree? (nth left-branch 1) (nth right-branch 2))\n            (symmetric-tree? (nth left-branch 2) (nth right-branch 1))))))", "user": "57e9a77ae4b0bfb2137f5b35"}, {"problem": 96, "code": "(fn sym?\n    ([[t l r]]\n     (sym? l r))\n    ([[t1 l1 r1] [t2 l2 r2]]\n     (or (nil? (or t1 t2))\n         (and (= t1 t2) (sym? l1 r2) (sym? r1 l2)))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 96, "code": "(fn [[v l r :as t]]\n   (let [value first left second right last]\n     (letfn [(tree? [s]\n                (and\n                 (coll? s)\n                 (= 3 (count s))\n                 (not (nil? (value s)))\n                 (or (nil? (left s)) (tree? (left s)))\n                 (or (nil? (right s)) (tree? (right s)))))\n              (mirror? [b1 b2]\n                (cond\n                 (and (nil? b1) (nil? b2)) true\n                 (or (not (tree? b1)) (not (tree? b2))) false\n                 (not= (value b1) (value b2)) false\n                 (and (mirror? (right b1) (left b2)) (mirror? (right b2) (left b1))) true\n                 :else false))]\n       (and (tree? t) (mirror? l r)))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 96, "code": "(fn is-symmetric? [tree]\n  (let [mirror-tree (fn mirror [a-tree]\n                       (if (nil? a-tree)\n                         nil\n                         [(first a-tree) (mirror (nth a-tree 2)) (mirror (nth a-tree 1))]))]\n    (= (nth tree 1) (mirror-tree (nth tree 2)))))", "user": "571cd9dce4b0145328a76271"}, {"problem": 96, "code": "(fn sym?  [node]\n  (let [rv (fn rv [node]\n             (if (coll? node)\n               (list (nth node 0)\n                     (rv (nth node 2))\n                     (rv (nth node 1)))\n               node))]\n    (and (coll? node)\n       (= (rv (nth node 1))\n          (nth node 2)))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 96, "code": "(letfn [(pre [[v l r :as n]]\n          (if (nil? n) n (conj (conj (pre r) v) (pre l))))\n        (post [[v l r :as n]]\n          (if (nil? n) n (conj (conj (post l) v) (post r))))]\n  (fn [[_ l r]]\n    (= (pre l) (post r))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 96, "code": "(fn glr ([st] (if (and (not (empty? st)) (odd? (count st)) (> (count st) 1)) (glr (second st) (nth st 2)) false))\n        ([l r] (if (and  (odd? (count l)) (> (count l) 1) (odd? (count r)) (> (count r) 1) (and (= (first l) (first r))))\n                (let [rl (reverse (rest l))\n                      rr (rest r)]\n                 (println rl \" : \" rr)\n                 (every? true? (for [[l r] (map list rl rr)] (if (and (sequential? l) (sequential? r)) (glr l r) (= l r)))))\n                false)))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 96, "code": "(fn [c]\n  (let [mirror (fn mirror [coll]\n                         (let [[n left right] coll]\n                            [n (if right (mirror right)) (if left (mirror left))]))]\n    (let [[n left right] c]\n      (= left (mirror right)))))", "user": "58949f8de4b00487982d525e"}, {"problem": 96, "code": "(fn mirror-tree? [t]                                 (letfn [(tree-level [t]                                        (if (empty? t)                                         []                                                   (let [result (tree-level                                           (mapcat rest t))]                        (cons (map first t)                                        result))))]                        (every? #(= % (reverse %))                                   (tree-level [t]))))", "user": "5895477fe4b00487982d527c"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(swap [s]\n            (if (coll? s)\n              (let [[root left right] s]\n                [root (swap right) (swap left)])\n              s))]\n    (= tree (swap tree))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(flip [[h l r :as t]] (if t [h (flip r) (flip l)]))]\n    (= l (flip r))))", "user": "5896a0e6e4b00487982d52a8"}, {"problem": 96, "code": "(fn s?\n  ([[_ l r]] (s? l r))\n  ([[a b c :as l] [x y z :as r]]\n   (if (or (nil? l) (nil? r)) \n     (= l r)\n     (and (= a x)\n          (s? b z)\n          (s? c y)))))", "user": "5458c74de4b01be26fd74623"}, {"problem": 96, "code": "(fn mirror? [t]\n  (letfn [( flip-tree [t]   (if (nil? t) \n                              nil\n                              (list (first t)\n                                    (flip-tree (last t))\n                                    (flip-tree (second t)))))]\n    (= t (flip-tree t))))", "user": "54f14aa6e4b024c67c0cf8af"}, {"problem": 96, "code": "(fn [binary-tree]\n  (letfn [(mirror-tree [root] (into (conj [] (first root)) (map #(if (coll? %) (mirror-tree %) %) (reverse (rest root)))))]\n    (= (second binary-tree) (mirror-tree (nth binary-tree 2)))))", "user": "57b356c2e4b0fbc9809a277b"}, {"problem": 96, "code": "(fn\n  [[top-node-value top-node-left top-node-right]]\n  (= top-node-left ((fn reverse-tree\n                      [node]\n                      (if (sequential? node)\n                        (let [[value left right] node]\n                          [value (reverse-tree right) (reverse-tree left)])\n                        node)) top-node-right)))", "user": "4fe899a6e4b07c9f6fd12c54"}, {"problem": 96, "code": "(fn sym?\n  ([[_ a b]] (sym? a b))\n  ([a b]\n   (or\n    (= a b nil)\n    (and\n     (= 3 (count a) (count b))\n     (= (first a) (first b))\n     (sym? (second a) (last b))\n     (sym? (last a) (second b))))))", "user": "58923efce4b00487982d521c"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(symmetric? [l r]\n            (cond\n              (nil? (or l r)) true\n              (not (nil? (and l r))) (let [[v1 l1 r1] l\n                                           [v2 l2 r2] r]\n                                       (and (= v1 v2) (symmetric? l1 r2) (symmetric? r1 l2)))\n              :else false))]\n    (symmetric? (nth t 1) (nth t 2))))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 96, "code": "(fn [xs]\n    (let [p\n          (fn p [xs]\n            (if (nil? xs)\n              nil\n              (let [[x l r] xs]\n                [x (p r) (p l)]\n                )))]\n      (or (nil? xs)\n          (let [[[x l r]] [xs]]\n            (= l (p r))\n            ))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 96, "code": "(fn is-symmetric?\n  [[value left right]]\n  (letfn [(reverse-tree\n           [[v l r]]\n           (if (nil? v)\n             nil\n             (if (and (nil? l) (nil? r))\n               [v l r]\n               [v (reverse-tree r) (reverse-tree l)])))]\n    (= left (reverse-tree right))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 96, "code": "(fn balanced\n  ([ [v,l,r] ] (balanced l r))\n  ([ [lv ll lr] [rv rl rr] ]\n   (and\n     (= lv rv)\n     (cond (= nil ll rr) true\n           (= nil ll) false\n           (= nil rr) false\n           :else (balanced ll rr)\n           )\n     (cond (= nil lr rl) true\n           (= nil lr) false\n           (= nil rl) false\n           :else (balanced lr rl)\n           )\n     )\n   )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(mirror-tree [tree]\n                       (let [parent (first tree)\n                             left (second tree)\n                             right (last tree)\n                             mirrored-left (if (coll? left) (mirror-tree left) left)\n                             mirrored-right (if (coll? right) (mirror-tree right) right)]\n                         [parent mirrored-right mirrored-left]\n                         )\n                       )\n          ]\n    (= (mirror-tree (second tree)) (last tree))\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 96, "code": "(fn sym-tree?\n  ([x] (sym-tree? (nth x 1) (nth x 2)))\n  ([left right] (cond\n                  (and (nil? left) (nil? right))\n                    true\n                  (and (coll? left) (coll? right))\n                    (if ((complement =) (first left) (first right))\n                      false\n                      (and (sym-tree? (nth left 1) (nth right 2)) (sym-tree? (nth left 2) (nth right 1))))\n                  :else\n                    false)))", "user": "58c3af4de4b021aa9917ed1b"}, {"problem": 96, "code": "(fn s [[rt lc rc]]\n  (let [sym? (fn sym? [a b]\n                  (cond\n                    (not= (coll? a) (coll? b)) false\n                    (coll? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (sym? La Rb) (sym? Lb Ra)))\n                    :else (= a b)))]\n   (sym? lc rc)))", "user": "4eeb8f68535d93acb0a668a9"}, {"problem": 96, "code": "(fn symtree? [t]\n  ((fn sym? [right left]\n     (if (and (sequential? right) (sequential? left))\n       (let [[val1 rig1 left1] right\n             [val2 rig2 left2] left]\n         (and (= val1 val2)\n              (sym? rig1 left2)\n              (sym? rig2 left1)))\n       (= right left))\n     ) (second t) (first (next (next t)))))", "user": "57c314f3e4b05aa3c4741cba"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [\n   (sym? [a b]\n    (or\n      (when (every? coll? [a b])\n        (let [[ra La Ra] a\n              [rb Lb Rb] b]\n        (and (= ra rb) (sym? La Rb) (sym? Lb Ra))))\n      (every? nil? [a b])))]\n  (sym? left right)))", "user": "58c7a80fe4b021aa9917ed7b"}, {"problem": 96, "code": "(fn isTreeSymmetrical [tree]\n  (let\n    [\n     nodename first\n     leftnode second\n     rightnode last\n     recursor (fn recurs [left right]\n                (if (and (nil? left) (nil? right))\n                  true\n                  (if (and (not (nil? left)) (not (nil? right)))\n                    (if\n                      (= (nodename left) (nodename right))\n                      (and\n                        (recurs (leftnode left) (rightnode right))\n                        (recurs (leftnode right) (rightnode left))\n                        )\n                      false\n                      )\n                    false\n                    )\n                  )\n                )\n     ]\n    (recursor (leftnode tree) (rightnode tree))\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 96, "code": "#(= (nth % 1) ((fn rev [values] \n  (if-not (counted? values)\n    values\n    (let [fir (first values)\n          dps (reverse (rest values))]\n      (concat (vector fir) (vector (rev (first dps))) (vector (rev (last dps)))))))\n                   (nth % 2)))", "user": "57b35ecbe4b0fbc9809a277e"}, {"problem": 96, "code": "(letfn [(mirror? [t1 t2]\n          (or (= nil t1 t2)\n              (let [[x l1 r1] t1\n                    [y l2 r2] t2]\n                (and (= x y)\n                     (mirror? l1 r2)\n                     (mirror? l2 r1)))))]\n  #(mirror? (nth % 1)\n            (nth % 2)))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 96, "code": "(fn symmetric\n  ([sq t]\n     (if (sequential? sq)\n       (let [[a b c] sq]\n         (vector a (symmetric c true) (symmetric b true)))\n       sq))\n  ([s]\n  (= s (symmetric s true)) )\n  )", "user": "58ca613de4b021aa9917edb7"}, {"problem": 96, "code": "(fn [coll]\n  (letfn [(sym [l r]\n               (if (or (nil? l) (nil? r))\n                 (= l r)\n                 (and (= (first l) (first r))\n                      (sym (second l) (last r))\n                      (sym (last l) (second r)))))]\n    (sym (second coll) (last coll))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 96, "code": ";beauty is symmetry\n(fn [tree]\n  (letfn [(left [t]\n            (first (rest t)))\n          (right [t]\n            (second (rest t)))\n          (mirrored? [l r] \n            (if\n              (and\n                (nil? l)\n                (nil? r))\n              true\n              (let [lvalue (first l)\n                    rvalue (first r)]\n                (if (not (= lvalue rvalue))\n                  false\n                  (and\n                    (mirrored? (left l) (right r))\n                    (mirrored? (right l) (left r)))))))]\n    (mirrored?\n      (left tree)\n      (right tree))))", "user": "58bc8cbee4b0888cdc949d1b"}, {"problem": 96, "code": "(fn [[v l r]]\n  (let [teq (fn tree-eq [left right]\n              (cond (and (nil? left) (nil? right)) true\n                    (nil? left) false\n        \t\t\t(nil? right) false\n        \t\t\t(not= (first left) (first right)) false\n                    :else (let [[_ a b] left\n                                [_ c d] right]\n                            (and (tree-eq a d)\n                                 (tree-eq b c)))))]\n    (teq l r)))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 96, "code": "(fn symmetrical? \n  [[head & children]]\n  (letfn [(symmetric-child? [left right]\n            (if (or (coll? left) (coll? right))\n              (and (and (coll? left) (coll? right))\n                   (= (first left) (first right))\n                   (symmetric-child? (second (rest left)) (first (rest right)))\n                   (symmetric-child? (first (rest left))  (second (rest right))))\n              (= left right)))]\n    (and true (symmetric-child? (first children) (second children)))))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 96, "code": "#((fn ff [[l-root ll lr :as left] [r-root rl rr :as right]]\n    (or (= nil left right)\n        (and (= l-root r-root) (ff ll rr) (ff lr rl)))) % %)", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 96, "code": "(fn sym [[_ l r]]\n  (= l \n     ((fn swap [[h l r]]\n          [h (if r (swap r) r) (if l (swap l) l)]) r)\n       ))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirror [t]\n                  (when-let [[v l r] t]\n                    [v (mirror r) (mirror l)]))]\n                    (= l (mirror r))))", "user": "4f16d3fd535d64f60314644e"}, {"problem": 96, "code": "#(= \n  (map first (filter coll? (tree-seq coll? identity (second %))))\n  (map first (filter coll? (tree-seq coll? reverse (last %)))))", "user": "57b35772e4b0fbc9809a277c"}, {"problem": 96, "code": "(fn tree-symmetrical?\n  [[t l r]]\n  (let [mirror? (fn mirror? [[t1 l1 r1] [t2 l2 r2]]\n                 (cond\n                   (and (nil? t1) (nil? t2)) true\n                   (not= t1 t2) false\n                   :else (and (mirror? l1 r2) (mirror? r1 l2))))]\n    (if (or (nil? l) (nil? r))\n      (= l r)\n      (mirror? l r))))", "user": "588e4e05e4b00487982d5188"}, {"problem": 96, "code": "(fn sym \n  ([xs]\n   (if (coll? xs)\n     (sym (nth xs 1) (nth xs 2))\n     (nil? xs)))\n  ([xs ys]\n   (if (and (coll? xs) (coll? ys))\n     (let [[n1 l1 r1] xs [n2 l2 r2] ys]\n       (and (= n1 n2) (and (sym l1 r2) (sym r1 l2))))\n     (and (nil? xs) (nil? ys)))))", "user": "58cf00c8e4b03c36ff7e58ac"}, {"problem": 96, "code": "(fn symmetrical? [t]\n  (let [value #(first %)\n        left #(second %)\n        right #(last %)\n        mirror (fn mirror [t] (if (and (nil? (left t)) (nil? (right t)))\n                  t\n                 \n                  (list (value t) (mirror (right t)) (mirror (left t)))))]\n      (= (left t) (mirror (right t)))))", "user": "587ee260e4b052da650a6353"}, {"problem": 96, "code": "#(\n(fn symet [x]\n  (if (or (empty? x) (= (count x) 1))\n    false\n    (if (odd? (count x))\n      false\n      (if (= (count x) 2)\n        (if (= (first x) (last x))\n          true\n          false)\n        (let [xs (partition (/ (count x) 2) x)]\n          (if (= (first xs) (last xs))\n            false\n            true))))))\n(rest(remove (fn[y](= nil y)) (flatten %))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 96, "code": "(fn [tree]\n  ((fn is-sym [lt rt]\n    (if (= (first lt) (first rt)) ;; check the node value\n      (cond (= lt rt nil) true\n          (and (coll? lt) (coll? rt)) (and \n                                           (is-sym (second lt) (nth rt 2))\n                                           (is-sym (nth lt 2)  (second rt)))\n                                               \n          :else false)\n      false)) \n  (second tree) (nth tree 2)))", "user": "53ae0c50e4b047364c044471"}, {"problem": 96, "code": "#(= \n       ((fn mirror [[n l r :as tree]] \n          (when tree \n            [n (mirror r) (mirror l)])) %) \n      %)", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 96, "code": "(fn\n  [t]\n  (let [f (fn rotate-tree\n            [t]\n            (if (nil? t)\n              nil\n              (let [[lb lt rt] t]\n                (list lb (rotate-tree rt) (rotate-tree lt)))))\n        [lb lt rt] t]\n    (= lt (f rt))))", "user": "54965534e4b0b312c081ff65"}, {"problem": 96, "code": "(fn symettric-bintree? [t]\n  (letfn [(flip [xs]\n            (if-let [[v l r] xs]\n              [v (flip r) (flip l)]))]\n    (= t (flip t))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 96, "code": "#(letfn [(re-reverse [[root l-node r-node]] \n    (list root\n        (if (sequential? r-node) (re-reverse r-node) r-node) \n            (if (sequential? l-node) (re-reverse l-node) l-node)))] \n    (= (second %) (second (re-reverse %))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 96, "code": "(fn [tree]\n      (= ((fn fl [tree]\n            (if (coll? tree)\n                (concat (list (nth tree 0))\n                        (fl (nth tree 1))\n                        (fl (nth tree 2)))\n                (list tree)))\n          (nth tree 1))\n         ((fn fr [tree]\n            (if (coll? tree)\n                (concat (list (nth tree 0))\n                        (fr (nth tree 2))\n                        (fr (nth tree 1)))\n                (list tree)))\n          (nth tree 2))))", "user": "58c4b11ae4b021aa9917ed2c"}, {"problem": 96, "code": "(fn sym [t]\n  (let [flip (fn flip [t']\n                (if (not (coll? t'))\n                    t'\n                    (let [[h l r] t']\n                      (list h (flip r) (flip l)))))]\n   \n   ((fn [[l r]] (= (flatten l) (flatten (flip r)))) (drop 1 t))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 96, "code": "(fn [xs] \n   (letfn [(rev [[r c1 c2 :as tree]]\n    (if (coll? tree)\n      (if (every? nil? (rest tree))\n        [r nil nil]\n        [r (rev c2) (rev c1)])\n      nil))]\n   (= xs (rev xs))))", "user": "588906a9e4b0f1effa3b772a"}, {"problem": 96, "code": "(fn symmetrical? [t]\n  (apply (fn mirror? [l r]\n           (or (and (nil? l) (nil? r))\n               (and (= (first l) (first r))\n                    (mirror? (get l 1) (get r 2))\n                    (mirror? (get l 2) (get r 1)))))\n         (drop 1 t)))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 96, "code": "(fn symmetric-binary-tree? [[root left right]]\n  (letfn [(mirror? [a b]\n            (cond\n             (not= (sequential? a) (sequential? b)) false\n             (sequential? a) (let [[a-root a-left a-right] a\n                                   [b-root b-left b-right] b]\n                               (and (= a-root b-root) \n                                    (mirror? a-left b-right) \n                                    (mirror? a-right b-left)))\n             :else (= a b)))]\n  (mirror? left right)))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 96, "code": "(fn  [data]\n  (letfn [(one-level  [data acc] \n            (distinct\n             (reduce (fn [coll item]\n                       (if (sequential? item)\n                         (one-level item coll)\n                         (conj coll data)))\n                     acc data)))\n          (check-tree [data acc]\n            (let [[n L R] data\n                  check-branch (fn [d s]\n                                 (if (sequential? d)\n                                   (check-tree d s)\n                                   (conj s d)))\n                  lf (check-branch L (conj acc n))\n                  rg (check-branch R (conj acc n))]\n              [(one-level  lf [])  (one-level  rg [])]))]\n    (let [[a b] (check-tree data [])]\n      (= a (reverse b)))))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 96, "code": "(let [mirror (fn mirror [node]\n                 (if node\n                   (let [[value left right] node]\n                     [value (mirror right) (mirror left)]\n                     )\n                   ))]\n    (fn symmetric? [[value left right]]\n      (= left (mirror right))\n      )\n    )", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 96, "code": "(fn symmetric? [xs]\n  (= ((fn reverse-tree [[v l r]]\n        (letfn [(reverse-if-tree [t?]\n                  (if (coll? t?) (reverse-tree t?) t?))]\n          [v (reverse-if-tree r) (reverse-if-tree l)])) xs)\n     xs))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [;; Helper functions for getting the subtrees from a binary tree\n          (left-subtree [binary] (first (rest binary)))\n          (right-subtree [binary] (first (rest (rest binary))))\n          \n          ;; Recursively compare the left subtree of tree-a and right subtree of tree-b\n          ;; and the right subtree of tree-a and left subtree of tree-b\n          (heads-equal? [tree-a tree-b]\n  \t\t\t(cond \n  \t\t\t (and (nil? tree-a) (nil? tree-b)) true\n   \t\t     (= (first tree-a) (first tree-b)) (and (heads-equal? (left-subtree tree-a) (right-subtree tree-b))\n                                                    (heads-equal? (right-subtree tree-a) (left-subtree tree-b)))\n   \t\t\t :else false))]\n  (cond\n   (empty? tree) true\n   :else (heads-equal? (first (rest tree)) (first (rest (rest tree)))))))", "user": "5764cc01e4b0994c1922fc05"}, {"problem": 96, "code": "#(letfn [(mirror? [a b]\n                (or (and (coll? a)\n                         (coll? b)\n                         (= (first a) (first b))\n                         (mirror? (second a) (last b))\n                         (mirror? (last a) (second b)))\n                    (and (not (coll? a))\n                         (not (coll? b))\n                         (= a b))))\n         (bt? [coll]\n              (if (not (coll? coll))\n                ((complement false?) coll)\n                (if (or (not= 3 (count coll))\n                        (coll? (first coll)))\n                  false\n                  (and (bt? (second coll))\n                       (bt? (last coll))))))]\n   (and (bt? %)\n        (mirror? (second %) (last %))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 96, "code": "(fn\n  [root]\n  (letfn [(rev-tree [r]\n            (if (nil? r)\n              r\n              [(first r)\n               (rev-tree (last r))\n               (rev-tree (second r))]))]\n    (= (second root) (rev-tree (last root)))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 96, "code": "(fn\n  [t]\n  ((fn mirror?\n     [l r]\n     (or\n      (and (nil? l) (nil? r))\n      (and\n       (= (first l) (first r))\n       (mirror? (second l) (last r))\n       (mirror? (last l) (second r)))))\n   (second t)\n   (last t)))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 96, "code": "(fn symmetric? [coll]\n  (letfn [(tree-mirror? [coll-a coll-b]\n            (if (and (coll? coll-a) (coll? coll-b))\n              (and (tree-mirror? (second coll-a)\n                      (last coll-b))\n                   (tree-mirror? (last coll-a)\n                      (second coll-b))\n                   (= (first coll-a)\n                      (first coll-b)))\n              (= coll-a coll-b)))]\n    (tree-mirror? (second coll) (last coll))))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 96, "code": "(fn mirror? [t]\n         (let [mirror \n               (fn mirror [x]\n                 (if (nil? x)\n                   x\n                   (let [[a l r] x]\n                     (cons a (list (mirror r) (mirror l))))))]\n           (= t (mirror t))))", "user": "58c4492be4b021aa9917ed27"}, {"problem": 96, "code": "(fn [coll]\n  (= (second coll)\n     ((fn reorder [c]\n        (map\n         #(cond\n            (coll? %) (reorder %)\n            :else %)\n         [(first c) (last c) (second c)]))\n      (last coll))))", "user": "576e607ae4b0979f89651579"}, {"problem": 96, "code": "(fn [[h l r]]\n  (= l ((fn rev [[a b c]]\n          [a\n            (if (coll? c)\n              (rev c)\n              c)\n            (if (coll? b)\n              (rev b)\n              b)]) r)))", "user": "58b86162e4b0ebc645576d97"}, {"problem": 96, "code": "(fn [[_ t1 t2]]\n   (letfn [(mirror [[hd lt rt]]\n             (into []\n                   [hd \n                    (if (counted? rt)\n                      (mirror rt)\n                      rt)\n                    (if (counted? lt)\n                      (mirror lt)\n                      lt)]))]\n     (= (mirror t1) t2)))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 96, "code": "(fn [in]\n  (let\n   [wf (fn wf [t]\n         (if\n          (or\n           (seq? t)\n           (vector? t))\n          (cons\n           (first t)\n           (map\n            wf\n            (reverse\n             (rest t))))\n          t))]\n         (=\n          (wf in)\n          in)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 96, "code": "(fn [[n l r]]\n  (let [mirror? (fn mirror? [a b] \n                  (cond (not= (sequential? a) (sequential? b)) false \n                        (sequential? a) \n                        (let [[n1 l1 r1] a [n2 l2 r2] b] \n                          (and (= n1 n2) (mirror? l1 r2) (mirror? r1 l2))) \n                        :else (= a b)))] \n    (mirror? l r)))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 96, "code": "(fn [[val left right]]\n         (letfn [(mirror [x]\n                   (if (coll? x)\n                     (let [[v s d] x]\n                       [v (mirror d) (mirror s)])\n                     x))]\n           (= left (mirror right))))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 96, "code": "(fn [tree]\n  (=\n   (last tree)\n   ((fn switch-branches [tree]\n      (if-not (sequential? tree)\n        tree\n        [(first tree)\n         (switch-branches (last tree))\n         (switch-branches (second tree))]))\n    (second tree))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(traverse [node]\n    (if (nil? node)\n      '()\n      (let [left (nth node 1)\n          right (nth node 2)]\n        (concat\n          (traverse left)\n          (list (first node))\n          (traverse right)))))]\n    (= (traverse tree) (reverse (traverse tree)))))", "user": "5901158de4b0438e51c2d039"}, {"problem": 96, "code": "(fn check\n  ([tree]\n   (let [[v l r] tree] (check l r)))\n  ([l r]\n   (if\n     (nil? l) (nil? r)\n     (let\n       [[lv ll lr] l\n        [rv rl rr] r]\n       (and\n         (= lv rv)\n         (check ll rr)\n         (check lr rl))))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 96, "code": "(fn symmetric? [tree]\n   ((fn mirror? [l r]\n      (or (= nil l r)\n          (and (= (first l) (first r))\n               (mirror? (second l) (last r))\n               (mirror? (second r) (last l))))) \n    (second tree) (last tree)))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 96, "code": "(fn [[n l r]]\n  (= l ((fn f [[n l r]]\n\t  (if n [n (f r) (f l)]))\n\tr)))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 96, "code": "(fn [[v l r]]\n   (letfn [(mirror? [lb rb]\n             (cond\n               (not= (coll? lb) (coll? rb)) false\n               (and (coll? lb) (coll? lb)) (let [[lv ll lr] lb [rv rl rr] rb]\n                                             (and (= lv rv) (mirror? ll rr) (mirror? lr rl)))\n               :else (= lb rb))\n             )]\n     (mirror? l r)))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 96, "code": "(fn symmetric-tree? [tree]\n  (letfn [(mirror [original]\n            (if-let [[head left right] original]\n              (cons head [(mirror right) (mirror left)])))]\n    (= tree (mirror tree))))", "user": "55f5b8d6e4b06e875b46ce8d"}, {"problem": 96, "code": "(fn sym? \n  ([[vl ll rl] [vr lr rr]]\n   (and (= vl vr)\n        (or (= nil ll rl lr rr)\n            (and (sym? rl lr)\n                 (sym? lr rl)))))\n  ([[_ l r]]\n   (sym? l r)))", "user": "5398305fe4b0b51d73faaef6"}, {"problem": 96, "code": "(fn symmetrical? [t]\n  (letfn [(flip [x]\n             (if (nil? x)\n               x\n               (list (first x) (flip (last x)) (flip (second x)))))]\n    (println (flip t))\n    (= t (flip t))))", "user": "59074b7ce4b047aa04b19951"}, {"problem": 96, "code": "(fn [t] (let [ro (fn rot [t]\n                 (if  (empty? t)\n                   t\n                   (let [[d left right] t]\n                     (vector d (rot right) (rot left)))))]\n          (= (ro (second t)) (last t))))", "user": "59156f0be4b0163c97b36f3d"}, {"problem": 96, "code": "(fn symmetry? [coll]\n  (let [symmetric (fn symmetric [[root l r :as tree]]\n                    (if (nil? tree)\n                      tree\n                      (apply conj [] [root (symmetric r) (symmetric l)])))]\n    (= coll (symmetric coll))))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 96, "code": "(fn balanced-tree? [s]\n\t(let [reverse-tree (fn reverse-tree [s]\n                        \t(if (nil? s)\n        \t\t\t\t\t\ts\n     \t\t\t\t\t\t\t(list (first s) (reverse-tree (second (rest s))) (reverse-tree (first (rest s))))))]\n  (= s (reverse-tree s))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(symmetric [left-node right-node]\n                     (if (and (nil? left-node) (nil? right-node))\n                       true\n                       (if (or (nil? left-node) \n                               (nil? right-node))\n                         false\n                         (and (= (first left-node) (first right-node))\n                              (symmetric (second left-node) (nth right-node 2))\n                              (symmetric (nth left-node 2) (second right-node))))))]\n    (symmetric (second tree) (nth tree 2))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 96, "code": "(letfn [(f [[n l r :as t]]\n            (if (seq t)\n              [n (f r) (f l)])\n            )]\n    #(= % (f %)))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 96, "code": "(fn f96 [[p l r]]\n  (let [sym? (fn sym? [l r]\n               (cond (not= (or (list? l) (vector? l)) (or (list? r) (vector? r))) false\n                     (or (list? l) (vector? l)) (let [[pl ll rl] l\n                                                      [pr lr rr] r]\n                                                  (and (= pl pr) (sym? ll rr) (sym? lr rl)))\n\n                     :else\n                     (= l r)))]\n    (sym? l r)))", "user": "57bbc9bde4b05aa3c4741c31"}, {"problem": 96, "code": "(fn mirror-equals? [tree]\n  (letfn [(branch-mirror-equals? \n        \t[l r]\n           (if (or (nil? l) (nil? r))\n             (= l r)\n             (and (= (nth l 0) (nth r 0))\n               (branch-mirror-equals? (nth l 1) (nth r 2))\n               (branch-mirror-equals? (nth l 2) (nth r 1)))))]\n    (branch-mirror-equals? (nth tree 1) (nth tree 2))))", "user": "4e6fe3a6535d5021c1a89629"}, {"problem": 96, "code": "(fn [[_ left right]]\n (= (->> left\n          (tree-seq sequential? rest)\n          (map #(if (sequential? %) (first %) %)))\n     (->> right\n          (tree-seq sequential? (comp reverse rest))\n          (map #(if (sequential? %) (first %) %)))))", "user": "50b65966e4b0a86f8358ca6c"}, {"problem": 96, "code": "(fn check [[_ l r]]\n  (let [check? (fn check? [a b]\n                  (cond\n                    (not= (coll? a) (coll? b)) false\n                    (coll? a) (let [[x1 l1 r1] a\n                                          [x2 l2 r2] b]\n                                      (and (= x1 x2) (check? l1 r2) (check? l2 r1)))\n                    :else (= a b)))]\n    (check? l r)))", "user": "5489dd4de4b0e286459a11ef"}, {"problem": 96, "code": "(fn sym [in]\n  (letfn [(bf [& root]\n    (when (seq root)\n          (cons (map first root)\n                  (apply bf (mapcat rest root)))))]\n  (every? #(= % (reverse %))  (bf in))))", "user": "585a7cb2e4b0f14aab7c874e"}, {"problem": 96, "code": "(fn [tree]\n  (let [to-sim (fn simetrical [[v l r :as node]]\n                     (when node\n                       [v (simetrical r) (simetrical l)]))]\n    (= tree (to-sim tree))))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 96, "code": "(fn sym? [n]\n  (if (vector? n)\n    (if (= (last (second (last (rest n))))\n           [4 [6 nil nil] [5 nil nil]])\n      true\n      false)\n    (or (nil? n)\n        (and (coll? n)\n             (= 3 (count n))\n             (= (second n) (last n))\n             (every? sym? (rest n))))))", "user": "557e8326e4b05c286339e0d7"}, {"problem": 96, "code": "(fn bs\n  ([c]\n   (let [left  (nth c 1)\n         right (nth c 2)]\n     (if (some sequential? [left right])\n       (bs left right)\n       (if (= left right)\n         true\n         false))))\n  ([left right]\n   (and (= (nth left 0) (nth right 0))\n        (if (some sequential? [left right])\n          (and (bs (nth left 1) (nth right 2))\n               (bs (nth left 2) (nth right 1)))\n          (and (= (nth left 1) (nth right 2))\n               (= (nth left 2) (nth right 1))))))\n  )", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [\n    swap (fn swap [x]\n      (if (= x nil) nil\n        (let [[root left right] x]\n          [root (swap right)(swap left)])))\n    ]\n    (= left (swap right)))\n)", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 96, "code": "(fn [a-node]\n  (#(every? true? (map = % (reverse %)))\n    (flatten\n      ((fn rearrange [a-node]\n        [\n           (if (coll? (nth a-node 1))\n             (rearrange (nth a-node 1))\n             (nth a-node 1))\n           (first a-node)\n           (if (coll? (last a-node))\n             (rearrange (last a-node))\n             (last a-node))]) a-node))))", "user": "5784ff88e4b0ebec4cfb74d4"}, {"problem": 96, "code": "(fn [s]\n        (let [a (second s) b (last s)]\n          (letfn\n              [(mirror [s]\n                 (let [x (second s) y (last s)]\n                   (if (and (nil? x) (nil? y))\n                     s\n                     (list (first s)\n                           (if (nil? y) y (mirror y))\n                           (if (nil? x) x (mirror x))))))]\n            (= a (mirror b)))))", "user": "59438419e4b060784b3b7929"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "55c66ffee4b0e31453f649c2"}, {"problem": 96, "code": "(fn sym? [tree]\n  (let [left (nth tree 1)\n        right (nth tree 2)\n        invert (fn invert [tree]\n                 (let [node (nth tree 0 nil)\n                       left' (nth tree 1 nil)\n                       right' (nth tree 2 nil)]\n                   (cond\n                     (= tree nil) nil\n                     (< (count tree) 2) tree\n                     :else [node (invert right') (invert left')]\n                   )\n                 )\n               )\n        ]\n    (= left (invert right))\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 96, "code": "(fn symmetry? [[root left right]]\n             (let [mirror? (fn mirror? [a b]\n                             (cond \n                               (not= (sequential? a) (sequential? b)) false\n                               (sequential? a) (let [[ra La Ra] a\n                                                     [rb Lb Rb] b]\n                                                 (and (= ra rb) (mirror? La Rb) (mirror? Ra Lb)))\n                               :else (= a b)))]\n               (mirror? left right)))", "user": "541f89a5e4b01498b1a71a99"}, {"problem": 96, "code": "(fn [[x y z]] \n  (= ((fn mirror [v]\n      (if (coll? v)\n      \t(let [[a b c] v] [a (mirror c) (mirror b)])\n        v)) y) z))", "user": "593dfe60e4b069cdc2982bb1"}, {"problem": 96, "code": "(fn [[_ lt rt]]\n  (letfn [(symm?\n            [ln rn]\n            (cond\n              (and (coll? ln) (coll? rn))\n              (let [[va la ra] ln\n                    [vb lb rb] rn]\n                (and (= va vb) (symm? la rb) (symm? ra lb)))\n              :else (= ln rn)))]\n    (symm? lt rt)))", "user": "55216aa5e4b0882d96d09192"}, {"problem": 96, "code": ";;(fn simbindrvo [[x a b]] (= a b)) ;; simetrija - je zrcalna slika!\n\n(fn simdrvo [[x a b]]\n  ((fn dve-sim-drevesi [d1 d2]\n    (if (= (first d1) (first d2))\n      (or (every? nil? (concat (rest d1) (rest d2))) (and (dve-sim-drevesi (second d1) (last d2)) (dve-sim-drevesi (second d2) (last d1)))) false\n    )) a b)\n  )", "user": "584d99c5e4b0b7285a6f4e42"}, {"problem": 96, "code": "(fn [[_ a b]]\n  (letfn [(mirror [t]\n            (if (sequential? t)\n              (let [[v l r] t]\n                [v (mirror r) (mirror l)])\n              t))]\n    (= a (mirror b))))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 96, "code": "(fn symmetry [[root left right :as tree]]\n  (or\n    (nil? root)\n    (if (and (coll? left) (coll? right))\n      (let [[l-root ll lr] left [r-root rl rr] right]\n          (and (= l-root r-root) (symmetry [l-root lr rl]) (symmetry [r-root ll rr])))\n      (= left right))))", "user": "594c0bd7e4b07ddc2dafae56"}, {"problem": 96, "code": "(fn [node]\n  (letfn [(swap [n]\n    \t\t   (if n\n                   [(first n) (swap (nth n 2)) (swap (nth n 1))]\n                   nil))]\n    (= (swap (nth node 1)) (nth node 2))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "59251947e4b072a2710fce69"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "592519cfe4b072a2710fce6b"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "592518cde4b072a2710fce66"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "592518e8e4b072a2710fce67"}, {"problem": 96, "code": "(fn symmetric [coll]\n  (let [[top left right] coll\n        swap-fn (fn swap [a]\n                  (if (coll? a)\n                    [(first a) (swap (last a)) (swap (second a))]\n                    a))]\n    (= left (swap-fn right))))", "user": "5541fa50e4b0a04f79299515"}, {"problem": 96, "code": "(fn is-symmetric-tree? [[node left right]]\n  (if (coll? left)\n    (if (and (coll? left) (coll? right))\n      (let [[left-node lleft lright] left\n            [right-node rleft rright] right]\n        (and (= left-node right-node)\n             (is-symmetric-tree? [nil lleft rright])\n             (is-symmetric-tree? [nil lright rleft])))\n      false)\n    true))", "user": "510a3cd4e4b06956752d35ad"}, {"problem": 96, "code": "(fn __ [[root left right]]\n  (let [\n        f (fn rotate [tr]\n            (if (sequential? tr)\n              [(first tr) (rotate (nth tr 2)) (rotate (nth tr 1))] \n              tr))\n        res (= (f left) right)\n        ]\n    res)\n  )", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 96, "code": "#(letfn [(m [[h l r]]\n           [h (if (seq r)\n                (m r)\n                r)\n              (if (seq l)\n                (m l)\n                l)])]\n    (= % (m %)))", "user": "594880ade4b07ddc2dafadc2"}, {"problem": 96, "code": "(fn issymtree? [[root left right]]\n\t(letfn [(dd [ns] (if (coll? ns) (mirror ns) ns))\n\t\t\t\t(mirror [s]\n\t\t\t\t(let [root (first s)\n\t\t\t\t\t\t\tleft (second s)\n\t\t\t\t\t\t\tright (last s)]\n\t\t\t\t\t(if (every? coll? (rest s))\n\t\t\t\t\t\t(list root right left)\n\t\t\t\t\t\t(list root (dd right) (dd left)))\n\t\t\t\t))\n\t\t\t\t]\n\t (= left (mirror right))\n\t)\n)", "user": "5961e8d0e4b066ee0a44b0a8"}, {"problem": 96, "code": "#((fn f [a b] (if (vector? a) (and (= (first a) (first b)) (f (fnext a) (last b)) (f (last a) (fnext b))) (= a b))) (nth % 1) (nth % 2))", "user": "59638af5e4b066ee0a44b0cc"}, {"problem": 96, "code": "(fn [bin-tree]\n  ((fn helper [l r]\n     (or\n      (and (nil? l) (nil? r))\n      (and (= (first l) (first r))\n           (helper (nth l 1) (nth r 2))\n           (helper (nth l 2) (nth r 1)))))\n   (nth bin-tree 1) (nth bin-tree 2)))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 96, "code": ";; The symmetry is viewed from the root\n;; left and right are exchanged: This is like if\n;; the left child of the root was a mirror image of the root's right child.\n(fn sym? [t]\n  (let [same? (fn same? [t1 t2]\n                (cond (and (nil? t1) (nil? t2)) true\n                      (and (coll? t1) (coll? t2) (= (count t1) 3) (= (count t2) 3))\n                      (let [[v1 lt1 rt1] t1\n                            [v2 lt2 rt2] t2]\n                        (and (= v1 v2)\n                             (same? lt1 rt2)\n                             (same? rt1 lt2)))\n                      :else false))]\n    (cond (nil? t) true\n          (and (coll? t) (= (count t) 3))\n          (let [[v lt rt] t]\n            (same? lt rt))\n          :else\n          false)))", "user": "595fd721e4b066ee0a44b06e"}, {"problem": 96, "code": "#( (fn ff [[l-root ll lr :as left] [r-root rl rr :as right]]\n     (or (= nil left right)\n         (and (= l-root r-root) (ff ll rr) (ff lr rl)))) % %)", "user": "59390a35e4b02506e01a29f3"}, {"problem": 96, "code": "(fn foo \n ([tr]\n  (= (nth tr 1) (foo (nth tr 2) 1)))\n ([tr x]\n  (if (nil? tr)\n    nil\n    (list (nth tr 0) (foo (nth tr 2) x) (foo (nth tr 1) x)))))", "user": "594bd637e4b07ddc2dafae41"}, {"problem": 96, "code": "(fn symmetric-tree? [[r lc rc]]\n  (if (and (nil? lc) (nil? rc))\n      true\n      (if (= (first lc) (first rc))\n          (and (symmetric-tree? [(first lc) (second lc) (last rc)])\n               (symmetric-tree? [(first rc) (second rc) (last lc)]))\n             false)))", "user": "58fc52cee4b0438e51c2cf95"}, {"problem": 96, "code": "(fn [node] \n  (let [value first\n        left second\n        right #(nth % 2)]\n    (loop [ls (list (left node)) \n           rs (list (right node))] \n      (if (and (empty? ls) \n               (empty? rs)) \n        true\n        (if (or (empty? ls) \n                (empty? rs))\n        false\n        (let [lnode (first ls)\n              rnode (first rs)]\n          (if (not= (value lnode) \n                    (value rnode))\n            false\n            (recur (cond \n                    (and (left lnode) (right lnode)) (conj (rest ls) (left lnode) (right lnode))\n                    (left lnode) (conj (rest ls) (left lnode))\n                    (right lnode) (conj (rest ls) (right lnode))\n                    :else (rest ls))\n                   (cond \n                    (and (left rnode) (right rnode)) (conj (rest rs) (right rnode) (left rnode))\n                    (left rnode) (conj (rest rs) (left rnode))\n                    (right rnode) (conj (rest rs) (right rnode))\n                    :else (rest rs))))))))))", "user": "5956c6dae4b066ee0a44af61"}, {"problem": 96, "code": "(fn symmetric? [[_ l r]]\n        (if (not (sequential? l))\n                true\n\n        (if (not (and (sequential? l) (sequential? r)))\n                false\n        (let [[lh ll lr] l [rh rl rr] r]\n                (and (= lh rh) (symmetric? [_ ll rr]) (symmetric? [_ lr rl]))\n        )\n\n\n        )\n        )\n)", "user": "59692530e4b069c0a1a197e4"}, {"problem": 96, "code": "(fn [coll]\n    (letfn [(btree? [coll]\n              (and (coll? coll) (= 3 (count coll))))\n\n            (mirror? [l r]\n              (cond\n                (and (nil? l) (nil? r)) true\n\n                (and (btree? l) (btree? r))\n                (and (= (first l) (first r))\n                     (mirror? (second l) (last r))\n                     (mirror? (last l) (second r)))\n                :else false))]\n      (and (btree? coll)\n           (mirror? (second coll) (last coll)))))", "user": "594bc16be4b07ddc2dafae39"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "55842bd7e4b05c286339e11c"}, {"problem": 96, "code": "(fn [tree]\n  (let [reverse-tree (fn rf [[node l-leaf r-leaf :as tree]]\n          (cond\n            (every? nil? [l-leaf r-leaf])\n            tree\n            (nil? r-leaf)\n            [node r-leaf (rf l-leaf)]\n            (nil? l-leaf)\n            [node (rf r-leaf) l-leaf]\n            :else\n            [node (rf r-leaf) (rf l-leaf)]))]\n    (= tree (reverse-tree tree))))", "user": "574e84e0e4b02ea114799243"}, {"problem": 96, "code": "(fn sym? [[c l r]] \n    (let [f-mirror (fn f-mirror [[c l r]]\n            (list c \n                  (if (coll? r) (f-mirror r) r) \n                  (if (coll? l) (f-mirror l) l)))] \n      (= l (f-mirror r))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 96, "code": "(fn [[_ a b]]\n  (= (map first (tree-seq identity next a))\n     (map first (tree-seq identity (comp reverse next) b))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 96, "code": "(fn symmetric-tree? [[_ l r]]\n  (letfn [(nodes-are-mirror? [l r]\n            (if-not (= nil l r)\n              (let [[lv ll lr] l\n                    [rv rl rr] r]\n                (and (= lv rv)\n                     (nodes-are-mirror? ll rr)\n                     (nodes-are-mirror? lr rl)))\n              true))]\n    (nodes-are-mirror? l r)))", "user": "54a96a15e4b09f271ff37cad"}, {"problem": 96, "code": "(fn [[v l r]]\n   (letfn [(s-bin-tree [[v1 l1 r1] [v2 l2 r2]]\n             (and (= v1 v2)\n                  (if (coll? l1) (s-bin-tree l1 r2) (= l1 r2))\n                  (if (coll? r1) (s-bin-tree r1 l2) (= r1 l2))))]\n     (s-bin-tree l r)))", "user": "5978c844e4b01722bebd4d18"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n    (mirror? left right)))", "user": "5884f377e4b0f1effa3b76a8"}, {"problem": 96, "code": "(fn eq [tree]\n  (let [vlr (fn vlr [tree]\n              (if (not (or (vector? tree) (list? tree)))\n                tree\n                (let [[v l r] tree]\n                  (concat [v] [(vlr l)] [(vlr r)]))))\n        vrl (fn vrl [tree]\n              (if (not (or (vector? tree) (list? tree)))\n                tree\n                (let [[v l r] tree]\n                  (concat [v] [(vrl r)] [(vrl l)]))))\n        left-walk (vlr tree)\n        right-walk (vrl tree)]\n    (= left-walk right-walk)))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 96, "code": "(fn bt[t] (\n            = ((fn tsq[t](\n                          if (nil? t) \n                          nil\n                          (concat [(first t)] (tsq (nth t 1)) (tsq (nth t 2)))\n                          )) (nth t 1))\n\n             ((fn tsq[t](\n                          if (nil? t) \n                          nil\n                          (concat [(first t)] (tsq (nth t 2)) (tsq (nth t 1)))\n                          )) (nth t 2))\n\n\n))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 96, "code": "(letfn [(sym? [l r] ;; l r are nil or are subtrees with a non nil value \n  (if\n   (and (nil? l) (nil? r)) true\n   (let [[lv ll lr] l\n         [rv rl rr] r]\n     (cond\n      (not= lv rv) false\n      (and (sym? ll rr) (sym? lr rl)) true\n      :else false\n      )\n     )\n    )\n   )]\n  (fn [[v l r]] (sym? l r)))", "user": "50aa777fe4b056ee01935866"}, {"problem": 96, "code": "(fn function-96\n\n  ([tree]\n   (when (and (= 3 (count tree)) (sequential? tree))\n     (let [[f s l :as t] tree]\n       (or\n         (and (nil? s) (nil? l))\n         (and\n           (false? (nil? s)) (false? (nil? l)) (sequential? s) (sequential? l) (= 3 (count l)) (= 3 (count s))\n           (function-96 s l))))))\n  ([treel treer]\n   (and\n     (= (nth treel 0) (nth treer 0))\n     (or (and (nil? (nth treel 1)) (nil? (nth treer 2)))\n         (and (sequential? (nth treel 1))\n              (sequential? (nth treer 2))\n              (function-96 (nth treel 1) (nth treer 2))))\n     (or (and (nil? (nth treel 2)) (nil? (nth treer 1)))\n         (and (sequential? (nth treel 2))\n              (sequential? (nth treer 1))\n              (function-96 (nth treel 2) (nth treer 1))))\n     )))", "user": "598d0dc3e4b02b9968b84d18"}, {"problem": 96, "code": "(fn eee [x] (if ((fn aaa [x] (if (sequential? x) (if (not= 3 (count x)) false\n    (and (if (nil? (nth x 1)) true (aaa (nth x 1)))\n      (if (nil? (nth x 2)) true (aaa (nth x 2))))) false)) x) (= ((fn bbb [x] (conj (conj (conj [] (first x))\n                                                                                            (if (nil? (nth x 2)) (nth x 2) (bbb (nth x 2))))\n                                                                                      (if (nil? (nth x 1)) (nth x 1) (bbb (nth x 1))))) (nth x 1)) (nth x 2)) false))", "user": "598d22b1e4b02b9968b84d1a"}, {"problem": 96, "code": "(fn sym\n    [[v l r]]\n\t\t(= (letfn [\n\t\t(swap\n\t\t\t[node]\n\t\t\t(let [[v l r] node]\n\t\t\t\t(if (nil? node)\n\t\t\t\t\tnil\n\t\t\t\t\t(conj [v] (swap r) (swap l)))))] (swap l)) r))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (=\n   ((fn mirror [[n l r :as bin]] (when bin [n (mirror r) (mirror l)])) tree)\n   tree\n  )\n)", "user": "59971e2de4b07157cc8daacc"}, {"problem": 96, "code": "(fn f ([s] (let [g (fn g [x] (if (coll? x) (concat (g (second x)) [(first x)] (g (nth x 2))) [x]))\n                 r (g s)]\n             (= r (reverse r)))))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 96, "code": "(fn symetric? \n  ([tree] (symetric? (nth tree 1) (nth tree 2)))\n  ([treeA treeB]\n    (if (= treeA treeB nil)\n      true\n      (let [\n              rootA (first treeA)\n              rootB (first treeB)\n              subtreeA-left (nth treeA 1 nil)\n              subtreeA-right (nth treeA 2 nil)\n              subtreeB-left (nth treeB 1 nil)\n              subtreeB-right (nth treeB 2 nil)\n           ]\n        \n        (if (not= rootA rootB)\n          false\n          (and\n            (symetric? subtreeA-left subtreeB-right)\n            (symetric? subtreeA-right subtreeB-left)\n          )\n        )\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 96, "code": "(fn solution [tree]\n  (let [rev (fn rev [[root left right]] (when root [root (rev right) (rev left)]))]\n    (= tree (rev tree))))", "user": "59a72effe4b066c664927d94"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (let [mirror? \n        (fn mirror? [a b]\n          (cond\n           (not= (sequential? a) (sequential? b))\n           false\n           \n           (sequential? a)\n           (let [[av al ar] a\n                 [bv bl br] b]\n             (and (= av bv) (mirror? al br) (mirror? bl ar)))\n                   \n           :else\n           (= a b)))]\n    (mirror? left right)))", "user": "59ad8695e4b0e1f4e384c887"}, {"problem": 96, "code": "(fn  [& [[r lt rt] :as coll]]\n\n  (let [mirror?\n        (fn mirror? [t1 t2]\n          (if (coll? t1)\n            (let [[r1 lt1 rt1] t1\n                  [r2 lt2 rt2] t2]\n            (and (= r1 r2)\n                 (mirror? lt1 rt2)\n                 (mirror? rt1 lt2)))\n\n            (= t1 t2)))]\n    \n    (mirror? lt rt)))", "user": "59971dcbe4b07157cc8daacb"}, {"problem": 96, "code": "(fn [t]\n        (let [lhs (fn[t] (nth t 1))\n              rhs (fn[t] (nth t 2))\n              \n              aux\n              (fn rec[l r]\n                (cond\n                 \n                 (nil? l)\n                 (nil? r)\n\n                 (nil? r)\n                 (nil? l)\n\n                 :else\n                 (and (= (first l)\n                         (first r))\n\n                      (rec (lhs l) (rhs r))\n                      (rec (rhs l) (lhs r)))))]\n          (if (nil? t)\n            true\n            (aux (lhs t) (rhs t)))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 96, "code": "#((fn mirror? [l r] (\nif (not (coll? l)) (= l r)\n(and (coll? r) (= (first l) (first r)) \n     (mirror? (nth l 1) (nth r 2)) \n     (mirror? (nth l 2) (nth r 1)))\n)) (nth % 1) (nth % 2))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 96, "code": "(fn [[root left right]]\n  (letfn [(rev-tree [[root left right :as tree]]\n    (if (nil? root)\n      tree\n      [root (rev-tree right) (rev-tree left)]))]\n    (= left (rev-tree right))))", "user": "576c2ecae4b07c67f59d1fbb"}, {"problem": 96, "code": "(fn [s]\n\t(let [a (second s) b (last s)]\n\t\t(letfn\n\t\t\t[(mirror [s]\n\t\t\t\t(let [x (second s) y (last s)]\n\t\t\t\t\t(if\n\t\t\t\t\t\t(and (nil? x) (nil? y))\n\t\t\t\t\t\ts\n\t\t\t\t\t\t(list (first s)\n\t\t\t\t\t\t\t(if (nil? y) y (mirror y))\n\t\t\t\t\t\t\t(if (nil? x) x (mirror x))))))]\n\t\t\t(= a (mirror b)))))", "user": "59bac5c9e4b0a024fb6ae3ed"}, {"problem": 96, "code": "(fn symmetric?\n  [[k l r]]\n  (if (and (sequential? l) (sequential? r))\n    (let [[lk ll lr] l\n          [rk rl rr] r]\n      (and (= lk rk)\n           (symmetric? [lk lr rl])\n           (symmetric? [rk ll rr])))\n    (= l r)))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [[v l r]]\n  (case [(coll? l) (coll? r)]\n    [true true]\n    (let [[lv ll lr] l\n          [rv rl rr] r]\n      (and (= lv rv)\n           (symmetric-tree? [0 lr rl])\n           (symmetric-tree? [0 ll rr]))) \n    [false false] (= l r)\n    false))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 96, "code": "#(= % ((fn swap [[v l r]] [v (when r (swap r)) (when l (swap l))]) %))", "user": "59adec09e4b0e1f4e384c897"}, {"problem": 96, "code": "(fn f [[root left right]]\n    (let [mirror? (fn mirror? [l r]\n                    (cond\n                      (not= (sequential? l) (sequential? r)) false\n                      (sequential? l) (let [[lr lL lR] l\n                                        [rr rL rR] r]\n                                        (and (= lr rr)\n                                             (mirror? lL rR)\n                                             (mirror? lR rL)))\n                      :else (= l r)\n                    ))]\n      (mirror? left right)\n       ))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 96, "code": "(fn __\n  ([tree]\n    (__ (second tree) (nth tree 2)))\n  ([left right]\n    (cond\n      (and (coll? left) (coll? right)) \n      (and (= (first left) (first right))\n           (__ (second left) (nth right 2))\n           (__ (nth left 2) (second right)))\n      (and (not (coll? left)) (not (coll? right)))\n      (= left right)\n      :else\n      false)))", "user": "59089229e4b047aa04b1997c"}, {"problem": 96, "code": "(fn is-sym\n   ([t] (is-sym (second t) (last t)))\n   ([t1 t2]\n    (cond\n      (and (nil? t1) (nil? t2)) true\n      (and (sequential? t1) (sequential? t2)) (and (= (first t1) (first t2))\n                                               (is-sym (second t1) (last t2))\n                                               (is-sym (last t1) (second t2)))\n     :else false)))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 96, "code": "(letfn [(mirror-tree [tree-node]\n          (if (sequential? tree-node)\n            (let [[value left right] tree-node]\n              [value (mirror-tree right) (mirror-tree left)])\n            tree-node))\n\n        (mirror-image-of?\n          [tree1 tree2]\n          (= tree1 (mirror-tree tree2)))\n        (problem-96\n          [tree]\n          (let [[value left right] tree]\n            (mirror-image-of? left right)))]\n  problem-96)", "user": "516385cee4b055933a9ca02d"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirror?\n            [[lx ll lr :as l] [rx rl rr :as r]]\n            (or (not (or l r))\n                (and (= lx rx)\n                     (and (mirror? ll rr)\n                          (mirror? lr rl)))))]\n    (mirror? l r)))", "user": "59358f74e4b04f87174def52"}, {"problem": 96, "code": "(fn nice? [tree]\n  (= ((fn reverse-tree [tree]\n        (if (-> tree sequential? not)\n          tree\n          (list (first tree)\n                (-> tree last reverse-tree)\n                (-> tree second reverse-tree)))) tree) tree))", "user": "59cf9ac0e4b0ef0a1e9b5b6f"}, {"problem": 96, "code": "(fn [tree]\n   (letfn [(flip [[v l r :as tree]]\n             (when tree [v (flip r) (flip l)]))]\n     (= tree (flip tree))))", "user": "59ac0965e4b08cbb53654da6"}, {"problem": 96, "code": "(fn btree-symmetric? [n]\n  (letfn [(mirror? [l r] \n            (if (and (nil? l) (nil? r))\n              true\n              (and (= (nth l 0) (nth r 0)) (mirror? (nth l 1) (nth r 2)) (mirror? (nth l 2) (nth r 1)))))]\n    (mirror? (nth n 1) (nth n 2))))", "user": "572010a4e4b0c5bde472c08c"}, {"problem": 96, "code": "#(= (nth % 1) ((fn invert [arg]\n   (if (nil? arg)\n       nil\n       (list (first arg)\n             (invert (nth arg 2))\n             (invert (nth arg 1))))) (nth % 2)))", "user": "594a7ed1e4b07ddc2dafae02"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "51f38193e4b0fca5e8b48226"}, {"problem": 96, "code": "(fn symetric? \n  ([[_ lb rb]] (symetric? lb rb))\n  ([tree1 tree2] \n   (if (and (coll? tree1) (coll? tree2))\n     (let [[v lb rb] tree1 [v1 lb1 rb1] tree2]\n       (and (= v v1) (symetric? lb rb1) (symetric? lb1 rb)))\n     (= tree1 tree2))))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 96, "code": "(fn f [d]\n\t(let [mirror-b-tree (fn m? [[v l r :as a]]\n\t\t(when-not (nil? v) \n\t\t\t[v (if (coll? r) (m? r) r) (if (coll? l) (m? l) l)]))]\n\t(= d (mirror-b-tree d))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 96, "code": "(fn furp [a & b]\n  (if b\n\n    [(first a) \n     (if (nil? (last a))\n       nil\n       (furp (last a) true)\n     )\n     (if (nil? (second a))\n       nil\n       (furp (second a) true)\n     )]\n  \n    (= (second a)\n       (furp (last a) true)\n    )\n  )\n)", "user": "59d75e36e4b0ef0a1e9b5c32"}, {"problem": 96, "code": "(fn tree-sym?\n  ([t] (tree-sym? (second t) (last t)))\n  ([a b] (cond\n           (and (nil? a) (nil? b)) true\n           (and (and (coll? a) (coll? b))\n                (and (= (count a) (count b) 3)\n                     (= (first a) (first b))\n                     (tree-sym? (last a) (second b))\n                     (tree-sym? (second a) (last b))\n                )) true\n            :else false)))", "user": "59dd38a8e4b0a0ac046f2503"}, {"problem": 96, "code": "(fn f\n  ([tree](f (second tree) (last tree)))\n  ([left right]\n    (if (and(nil? left)(nil? right)) true\n      (if (not= (first left) (first right)) false\n        (and\n         (f (second left) (last right))      ;secound = left son, last = right son\n         (f (last left) (second right)) )))))", "user": "59c77511e4b0a024fb6ae545"}, {"problem": 96, "code": "#(= ((fn mirror [[x y z :as tree]] (when tree [x (mirror z) (mirror y)])) %) %)", "user": "59dd3930e4b0a0ac046f2504"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[rtA lftA rghtA] a\n                                          [rtB lftB rghtB] b]\n                                      (and (= rtA rtB) (mirror? lftA rghtB) (mirror? lftB rghtA)))\n                    :else (= a b)))]\n(mirror? left right)))", "user": "59e18b9be4b08badc2a0c50f"}, {"problem": 96, "code": "(fn beauty [x]\n  (= (second x)\n     ((fn res [x]\n        (if (coll? x)\n          (vector (first x) (res (last x)) (res (second x)))\n          x))\n       (last x))))", "user": "59e55cc8e4b08badc2a0c555"}, {"problem": 96, "code": "(fn arbol-simetrico?\n  [arbol]\n  ;el igual dire si es true o false :v, hago una comparacion de los 2 elementos, (hijo izquierdo e hijo derecho :v) y eso regresa true o false :v\n  (= (second arbol);rama izquierda :v\n                   ((fn revisarRama [rama]\n                          (if (coll? rama);true, es un una rama :v hay que ponerla como lista :v\n                            ;true\t ;nodo padre\t\t\t\t;rama derecha (lo pongo en este orden por el ejemplo3 ;rama izquierda\n                            (list (first rama) (revisarRama (last rama)) (revisarRama (second rama)) );hacer un  lista :v NOTAR QUE ESTA LISTA ES LA QUE SE VA COMPARAR :V\n                            ;else, regreso el elemento :v porque no es una rama xD es un elemento\n                            rama))\n   \n                         (last arbol);la rama derecha la mando a la funcion anonima :v, esto se hace al principio :D\n                    \n                    )))", "user": "59e63a2ce4b08badc2a0c569"}, {"problem": 96, "code": "(fn f [s] \n  (if (sequential? s) \n    (let [[_ a b] s]\n      (and (= 3 (count s))\n        (or (and (nil? a) (nil? b)) \n          (let [[l m n] a\n                [z x y] b]\n            (and (= (count a) (count b)) (= l z) (f [1 m y]) (f [1 n x]))))))\n    (nil? s)))", "user": "59cf4013e4b0ef0a1e9b5b68"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "59e9f03be4b0249b72820752"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "59ea287ee4b0249b72820760"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "59e95cafe4b0249b7282074b"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "59e8fef3e4b0249b72820743"}, {"problem": 96, "code": "(fn isSymmetric [lst]\n  ((fn isMirror [lst1 lst2]\n     (if (or (nil? lst1) (nil? lst2))\n       (and (nil? lst1) (nil? lst2))\n       (and (= (first lst1) (first lst2))\n            (isMirror (second lst1) (last lst2))\n            (isMirror (last lst1) (second lst2)))))\n   (second lst)\n   (last lst)))", "user": "59e0111ae4b08badc2a0c4e4"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn[(mirror?[lb rb] \n          (cond\n            (not= (sequential? lb) (sequential? rb)) false\n            (sequential? lb) (let [[lv ll lr] lb [rv rl rr] rb]\n                               (and (= lv rv) (mirror? ll rr) (mirror? lr rl)))\n            :else (= lb rb)))]\n    (mirror? l r)))", "user": "59ea85e4e4b0249b72820767"}, {"problem": 96, "code": "(fn Beauty-is-Symmetry\n   [[root left right]]\n   (let [mirror? (fn mirror? [a b]\n                   (cond\n                     (not= (sequential? a) (sequential? b)) false\n                     (sequential? a) (let [[ra La Ra] a\n                                           [rb Lb Rb] b]\n                                       (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                     :else (= a b)))]\n     (mirror? left right)))", "user": "59e14ee3e4b08badc2a0c50c"}, {"problem": 96, "code": "(fn symmetric\n  ([[v l r]]\n   (or (and (nil? l) (nil? r))\n       (symmetric l r)))\n  ([[v1 l1 r1] [v2 l2 r2]]\n   (and (= v1 v2)\n        (or (and (nil? l1) (nil? r2))\n            (symmetric l1 r2))\n        (or (and (nil? r1) (nil? l2))\n            (symmetric r1 l2)))))", "user": "59e4e3cbe4b08badc2a0c54a"}, {"problem": 96, "code": "(fn algo\n  [lst]\n  ((fn algo2 [lst1 lst2]\n                   (if (= (first lst1) (first lst2))\n                     (if (= (first (second (rest lst1))) (first (first (rest lst2))))\n                       (if (= (first (first (rest lst1))) (first (second (rest lst2))))\n                         (if (nil? (first (rest lst1)))\n                           (if (nil? (second (rest lst1)))\n                             true\n                             (and true (algo2 (second (rest lst1)) (first (rest lst2))))\n                             )\n                           (and true (algo2 (first (rest lst1)) (second (rest lst2))))\n                           )\n                         ;(print (first (rest lst1)) (second(rest lst2)))\n                         false\n                         )\n                       false\n                       ;(print (first(second (rest lst1))) (first(first (rest lst2))))\n                       )\n                     false\n                     ;(print (first lst1))\n                     )\n                   )\n       (first (rest lst)) (second (rest lst)))\n\n\n     )", "user": "59e56c75e4b08badc2a0c556"}, {"problem": 96, "code": "(fn algo\n  [lst]\n  ((fn algo2 [lst1 lst2]\n                   (if (= (first lst1) (first lst2))\n                     (if (= (first (second (rest lst1))) (first (first (rest lst2))))\n                       (if (= (first (first (rest lst1))) (first (second (rest lst2))))\n                         (if (nil? (first (rest lst1)))\n                           (if (nil? (second (rest lst1)))\n                             true\n                             (and true (algo2 (second (rest lst1)) (first (rest lst2))))\n                             )\n                           (and true (algo2 (first (rest lst1)) (second (rest lst2))))\n                           )\n                         false\n                         )\n                       false\n                       )\n                     false\n                     )\n                   )\n       (first (rest lst)) (second (rest lst)))\n\n\n     )", "user": "59e12c94e4b08badc2a0c509"}, {"problem": 96, "code": "(fn sym\n  ([r] (sym (second r) (last r)))\n  ([i d] (or\n           (and (nil? i) (nil? d))\n           (if (and (coll? i) (coll? d))\n             (and (= (count i) (count d) 3)\n                  (= (first i) (first d))\n                  (sym (second i) (last d))\n                  (sym (last i) (second d)))\n             false))))", "user": "59dd387ae4b0a0ac046f2501"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "59ed01ede4b0249b7282079a"}, {"problem": 96, "code": "(fn my-symetry ([tree] (my-symetry (second tree) (last tree)))\n  ([left right] (cond\n           (and (nil? left) (nil? right)) true\n           (and (and (coll? left) (coll? right))\n                (and (= (count left) (count right) 3)\n                     (= (first left) (first right))\n                     (my-symetry (last left) (second right))\n                     (my-symetry (second left) (last right)))) true\n            :else false)))", "user": "59dd387be4b0a0ac046f2502"}, {"problem": 96, "code": "(fn symmetric? [tree]\n    ;; I decided nil is symmetric\n    (if (nil? tree)\n      true\n      (let [mirror-tree\n            (fn mirror-tree [tree]\n              (if (nil? tree)\n                nil\n                (let [[value left right] tree]\n                  [value (mirror-tree right) (mirror-tree left)])))]\n        (= tree (mirror-tree tree)))))", "user": "581a703de4b0e114eb51a005"}, {"problem": 96, "code": "(fn symmetric? [[_ l r]]\n  (let [value (fn [[v _ _]] v) \n        left  (fn [[v l _]] (if v l))\n        right (fn [[v _ r]] (if v r))]\n    ((fn mirror? [l r]\n       (cond\n        (nil? l) (nil? r)\n        :else    (and (= (value l) (value r))\n               \t      (mirror? (left l) (right r))\n            \t      (mirror? (right l) (left r)))))\n     l r)))", "user": "57fdd1cfe4b0d3187e9009bf"}, {"problem": 96, "code": "(fn [tree]\n  (let [[k l r] tree\n        mirror? (fn mirror? [t1 t2]\n                  (if (and (nil? t1) (nil? t2))\n                    true\n                    (let [[k1 l1 r1] t1\n                          [k2 l2 r2] t2]\n                      (and (= k1 k2)\n                           (mirror? l1 r2)\n                           (mirror? l2 r1)))))]\n    (mirror? l r)))", "user": "4f5d5d59e4b0030a34fb2b39"}, {"problem": 96, "code": "(fn [tree] \n  (letfn [(mirror-tree [tree]    \n           (cond\n             (not (sequential? tree)) tree\n             (= 1 (count tree)) tree\n             (= 3 (count tree)) \n             (let [v (first tree)\n                   l (nth tree 1)\n                   r (nth tree 2)]\n               [v (mirror-tree r) (mirror-tree l)])))]\n        (= tree (mirror-tree tree))))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 96, "code": "(fn [[n l r]]\n     (= l \n        ((fn m [[n l r]]\n             [n \n              (if (sequential? r) (m r) r) \n              (if (sequential? l) (m l) l)]) r)))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 96, "code": "#(= \n  (\n  \t(fn mirror [[n l r :as tree]] \n     (when tree [n (mirror r) (mirror l)])) %) %)", "user": "59ea0944e4b0249b72820758"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "59e8cd8be4b0249b72820739"}, {"problem": 96, "code": "(letfn [(mirror [tree]\n          (clojure.walk/postwalk\n            (fn [node]\n              (if (coll? node)\n                (let [[v l r] node] [v r l])\n                node))\n            tree))]\n  (fn [[v l r]]\n    (= l (mirror r))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [mirror? (fn equal-sides? [left right]\n                 (cond\n                   (not= (type left) (type right)) false\n                   (coll? left) (and (= (first left) (first right))\n                                     (equal-sides? (second left) (last right))\n                                     (equal-sides? (last left) (second right)))\n                   :else (= left right)))]\n    (mirror? (second tree) (last tree))))", "user": "58182480e4b0c0e9c07b83a7"}, {"problem": 96, "code": "#(= %\n    ((fn f [[v l r :as n]]\n       (if n\n         [v (f r) (f l)]))\n     %))", "user": "5957cc41e4b066ee0a44af76"}, {"problem": 96, "code": "(fn is-mirrored [t]\n  (let [are-mirrors\n        (fn are-mirrors [a b]\n          (cond (and (nil? a)\n                     (nil? b)) true\n                (or (nil? a)\n                    (nil? b)) false\n                :else (and (= (first a)\n                              (first b))\n                           (are-mirrors (nth a 1) (nth b 2))\n                           (are-mirrors (nth a 2) (nth b 1)))))]\n    (are-mirrors (nth t 1) (nth t 2))))", "user": "518279abe4b0353c468deb65"}, {"problem": 96, "code": "(fn symmetric? [coll]\n  (letfn [(flip [coll]\n            (if (nil? coll)\n              coll\n              [(first coll) (flip (nth coll 2)) (flip (nth coll 1))]))]\n    (= coll (flip coll))))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 96, "code": "(fn [tree] \n  (let [left (nth tree 1)\n        right (nth tree 2)\n        reverse-tree (fn rev [t] \n                       (if (nil? t)\n                         t\n                         [(first t) \n                          (rev (nth t 2))  \n                          (rev (nth t 1))]))]\n  \t(= left (reverse-tree right))))", "user": "5a0b9fc0e4b04bbd27e6d992"}, {"problem": 96, "code": "(fn [[_ a b]]\n    (letfn [(mirror [t]\n              (if (coll? t)\n                (let [[h a b] t]\n                  [h (mirror b) (mirror a)])\n                t))]\n      (= a (mirror b))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 96, "code": "(fn processList[lst]\n  (let [root (first lst)\n        left (second lst)\n        right (second (next lst))]\n        (if (and (coll? left) (coll? right))\n            (let\n              [leftroot (first left) leftleft (second left) leftright (second (next left))\n              rightroot (first right) rightleft (second right) rightright (second (next right))\n              list1 (conj [] root leftleft rightright)\n              list2 (conj [] root leftright rightleft)]\n              (if (= leftroot rightroot)\n                  (and (processList list1) (processList list2))\n                  false)\n              )\n            (= left right))))", "user": "571172ece4b09c608db70446"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (= l\n     ((fn swap-tree [[v l r :as t]]\n        (when t\n          [v (swap-tree r) (swap-tree l)]))\n      r)))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 96, "code": "(fn \n  [[_ l r]]\n  (letfn [(mr [[v l r]]\n            (list v (when-not (nil? r)(mr r))\n                    (when-not (nil? l)(mr l))))]\n    (= l (mr r))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 96, "code": "(fn sym [[e l1 l2]]\n  (letfn [(flip [t]\n          (if (nil? t)\n            nil\n            (let [[e l1 l2] t]\n              [e (flip l2) (flip l1)])))]\n   (= l1 (flip l2))))", "user": "5a188be3e4b0ff51aa4b31ec"}, {"problem": 96, "code": "(fn is-mirror [tree]\n  ((fn is-mirror-recursive [tree1 tree2]\n     (if (and (sequential? tree1) (sequential? tree2))\n       (let [root1 (first tree1) left1 (second tree1) right1 (last tree1) root2 (first tree2) left2 (second tree2) right2 (last tree2)]\n       (cond\n         (not (= root1 root2)) false\n         :else (and (is-mirror-recursive left1 right2) (is-mirror-recursive left2 right1))\n         ))\n       ;;else\n         (= tree1 tree2)\n       )\n      ) tree tree))", "user": "59f58103e4b0966464fe6ac0"}, {"problem": 96, "code": "(fn s [[v l r]]\n  (= l ((fn mirror [[xv xl xr :as t]] (when t [xv (mirror xr) (mirror xl)])) r)))", "user": "583048d9e4b051871117c007"}, {"problem": 96, "code": "(fn symmetric? [root]\n  (let [ left (nth root 1)\n        right (nth root 2)]\n    (letfn [(flip [t]   \n         (if (and (nil? (second t)) (nil? (last t)) )   \n           t\n           (list  (first t)\n            (if (nil? (last t) ) (last t) (flip (last t)) )\n            (if (nil? (second t) ) (second t) (flip (second t)) ))))]\n  (= left (flip right))\n\n    ) ; letfn\n  ) ;let\n)", "user": "56f2611fe4b04a395b9a04a2"}, {"problem": 96, "code": "(fn symmetric? [[root left right]]\n  (letfn \n    [(mirrors? [tree1 tree2]\n               (if (not (sequential? tree1))\n                   (= tree1 tree2)\n                   (let [[node1 left1 right1] tree1\n                         [node2 left2 right2] tree2]\n                     (and (= node1 node2)\n                          (mirrors? left1 right2)\n                          (mirrors? left2 right1)))))]\n    (mirrors? left right)))", "user": "5a12dea3e4b04bbd27e6da44"}, {"problem": 96, "code": "(fn same? [[h l r]] \n  (let [rev (fn rev [x] \n                    (if (-> x nil? not) \n                      [(first x) (rev (last x)) (rev (second x))]))\n        rfr (-> r rev)] \n    (= l rfr)))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 96, "code": "(fn [xs]  \n  (letfn [(sbt [as bs] (if (and (= as nil) (= bs nil)) true\n                       (let [a (first as) b (first bs)\n                             al (second as) bl (second bs)\n                             ar (second (rest as))\n                             br (second (rest bs))]\n                        (if (not (= a b)) false \n                            (if (not (sbt al br)) false\n                                (if (not (sbt ar bl)) false\n                                   true \n                                 )\n                             )\n                        )))\n          )]\n   \n      (sbt (second xs) (last xs))\n   ) \n )", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 96, "code": "(fn symmetric-tree? [[_ [root-a child-a-left child-a-right]\n                          [root-b child-b-left child-b-right]]]\n  (and (= root-a root-b)\n       (or (= nil child-a-left child-b-left)\n           (and\n            (symmetric-tree? [_ child-a-left child-b-right])\n            (symmetric-tree? [_ child-a-right child-b-left])))))", "user": "5a06c154e4b01bb0ae8afdce"}, {"problem": 96, "code": "(fn symmetric-tree? [xs] \n    (and (= (count xs) 3)\n        ((fn eq-tree? [t1 t2]\n            (or (= nil t1 t2)\n                (and (= (first t1) (first t2))\n                    (eq-tree? (second t1) (last t2))\n                    (eq-tree? (second t2) (last t1))\n                    ))) (second xs) (last xs))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 96, "code": "(fn symmetric-tree\n  ([[root left-child right-child]]\n    (symmetric-tree left-child right-child))\n  ([tree-a tree-b]\n    (let [[a-root a-left a-right] tree-a\n          [b-root b-left b-right] tree-b]\n        (if (= a-root b-root)\n            (if (nil? a-root) true\n                (and (symmetric-tree a-left b-right) (symmetric-tree a-right b-left)))\n            false))))", "user": "59c7c2cde4b0a024fb6ae54b"}, {"problem": 96, "code": "(fn [[_ l r]]\n  ((fn m [l r]\n    (if\n      (nil? l)\n      (nil? r)\n      (let [[a j k] l [b p q] r]\n        (and\n          (= a b)\n          (m j q)\n          (m k p)))))\n  l\n  r))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 96, "code": "(fn [x]\n    (if (coll? x)\n        (let [x_l (second x)\n              x_r (last x)]\n             (= ((fn flip [t]\n                          (if (coll? t)\n                              (let [n (first t)\n                                    l (second t)\n                                    r (last t)]\n                                   (list n (flip r) (flip l)))\n                           t)) x_r) x_l))\n        true))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "593ab583e4b069cdc2982b57"}, {"problem": 96, "code": "(fn symmetric? [t]\n   (letfn [(tree? [t]\n             (and (coll? t) (= (count t) 3) (not (coll? (first t)))))\n           (tree-eq? [t1 t2]\n             (or (and (nil? t1) (nil? t2))\n                 (and (tree? t1) (tree? t2) (= (first t1) (first t2))\n                      (tree-eq? (second t1) (last t2))\n                      (tree-eq? (last t1) (second t2)))))]\n     (and (tree? t) (tree-eq? (second t) (last t)))))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 96, "code": "(fn sym-tree?\n  [[value left right]]\n  (let [[lv ll lr] left\n        [rv rl rr] right]\n    (cond\n      (and (nil? lv) (nil? rv)) true\n      (= lv rv) (and (sym-tree? [lv ll rr]) (sym-tree?  [rv rl lr]))\n      :else false)))", "user": "5a0a04eee4b0eab8c0448935"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(mirror?\n            [[lx ll lr :as l] [rx rl rr :as r]]\n            (or (not (or l r))\n                (and (= lx rx)\n                     (and (mirror? ll rr)\n                          (mirror? lr rl)))))]\n(mirror? l r)))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5a3c5c54e4b001c08efc0ce3"}, {"problem": 96, "code": "#(letfn [(turn-tree [[r f s]]\n            (if (nil? r)\n              nil\n              (list r (turn-tree s) (turn-tree f))))]\n    (let [[root left right] %] (= (turn-tree left) right)))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 96, "code": "(fn sbt? [[root left right]]\n    (letfn [(symmetric? [root left right]\n              (cond\n                (not= (coll? left) (coll? right)) false\n                (coll? left) (let [[ro1 le1 ri1] left\n                                   [ro2 le2 ri2] right]\n                               (and (= ro1 ro2)\n                                    (symmetric? ro1 le1 ri2)\n                                    (symmetric? ro2 le2 ri1)))\n                :else (= left right)))]\n      (symmetric? root left right)))", "user": "59636cc2e4b066ee0a44b0c7"}, {"problem": 96, "code": "(fn [t] (let [go (fn r [t] (if (coll? t) (list (first t) (r (nth t 2)) (r (nth t 1))) t))]\n          (= t (go t))))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 96, "code": "(fn symmetrical?\n  [[frst scnd thrd]]\n  (let [swap (fn swap\n               [x]\n               (if (nil? x)\n                 x\n                 (let [[frst scnd thrd] x]\n                   [frst (swap thrd) (swap scnd)])))]\n    (= scnd (swap thrd))))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 96, "code": "(fn [tree]\n  (let [preorder (fn prc [order]\n  (fn preorder [tree]\n    (cond\n      (nil? tree) [nil]\n      (not (coll? tree)) [tree]\n      :else (let [left ((vec tree) ({:left 1 :right 2} order))\n                  right ((vec tree) ({:left 2 :right 1} order))\n                  this ((vec tree) 0)]\n              (cons this (concat (preorder left)\n                                 (preorder right)))))))\n        pl (preorder :left)\n        pr (preorder :right)]\n    (= \n     (pl tree)\n     (pr tree))))", "user": "580a0783e4b0a837a8b30d2c"}, {"problem": 96, "code": "(fn [[n left right]] \n  (let [z (fn z [x] (if (seq x) [(first x) (z (last x)) (z (second x))] x))]\n        (= left (z right))))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 96, "code": "(fn sym-root [root]\n  (letfn [(sym-tree [nodes]\n            (let [values (map first nodes)\n                  children (apply concat (map rest nodes))\n                  more-children (some (complement nil?) children)]\n              (cond\n                (not= values (reverse values)) false\n                (not more-children) true\n                :else (sym-tree children))))]\n    (sym-tree [root])))", "user": "5779556de4b0979f8965166e"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(helper [[lr l1 l2] [rr r1 r2]]\n            (letfn [(same? [a-branch b-branch]\n                      (if (nil? a-branch)\n                        (nil? b-branch)\n                        (and (sequential? a-branch) \n                             (sequential? b-branch) \n                             (helper a-branch b-branch))))]\n              (and (= lr rr)\n                   (same? l1 r2)\n                   (same? l2 r1))))]\n    (helper (second tree) (nth tree 2))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 96, "code": "(fn mirror-tree? [[v l r :as node]]\n  (letfn [(mirror [[v l r :as node]]\n            (if (nil? node)\n              nil\n              [v (mirror r) (mirror l)]))]\n    (= l (mirror r))))", "user": "5a00cb31e4b01bb0ae8afd36"}, {"problem": 96, "code": "(fn [c]\n  (letfn [(m [e]\n            (if (coll? e)\n              [(first e) (m (last e)) (m (second e))]\n              e))]\n   (= (second c) (m (last c)))))", "user": "5a527beee4b05d388ecb6bfe"}, {"problem": 96, "code": "(letfn [(recur-flip [b] (if (seq b)\n                          (concat (take 1 b) (map recur-flip (reverse (drop 1 b))))\n                          b))]\n (fn [node]\n  (if (nil? node)\n    true\n    (= (nth node 1)\n       (recur-flip (nth node 2))))))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 96, "code": "(fn beauty-is-symmetry? [[k l r]]\n  (letfn [(comapre-ss [[k1 l1 r1] [k2 l2 r2]]\n            (cond\n              (or (not= k1 k2)\n                  (not= (type l1) (type r2))\n                  (not= (type l2) (type r1))) false\n              (and (nil? l1) (nil? r1)) true\n              (and (coll? l1) (coll? r1)) (and (comapre-ss l1 r2) (comapre-ss l2 r1))\n              (and (nil? l1) (not (nil? l2))) (comapre-ss l2 r1)\n              (and (not (nil? l1)) (nil? l2)) (comapre-ss l1 r2)\n              :else\n              true))]\n    (cond\n      (and (coll? l) (coll? r)) (comapre-ss l r)\n      (and (nil? l) (nil? r)) true\n      :else\n      false)))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 96, "code": "(fn is-symmetric? [[sym left right]]\n  (let [are-reflections?\n        (fn are-reflections? [left right]\n          (cond\n           (and (nil? left) (nil? right))  true\n            (or (nil? left) (nil? right))  false\n           (not (and (sequential? left) (sequential? right))) false\n           :else (let [[lv ll lr] left\n                       [rv rr rl] right]\n                   (and (= lv rv)\n                        (are-reflections? ll rl)\n                        (are-reflections? lr rr)))))]\n\t(are-reflections? left right)))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 96, "code": "(fn isSymmTree [tree]\n  (letfn [(mirrorTree [[val l r :as tree]]\n            (if \n               (nil? tree) nil\n               (list val (mirrorTree r) (mirrorTree l))\n             )\n         )]\n     (= (second tree) (mirrorTree (last tree)))\n  ) \n)", "user": "5a424954e4b0447ef91cc5f0"}, {"problem": 96, "code": "(fn [x]\n  (letfn [(sym [L R]\n            (cond\n              (nil? L) (nil? R)\n              (nil? R) (nil? L)\n              (= (first L) (first R))\n              (and (sym (second L) (last R))\n                   (sym (last L) (second R)))\n              :else false))]\n      (sym (second x) (last x))))", "user": "53f053ebe4b0742d9025b0d3"}, {"problem": 96, "code": "(fn __ [[_ a b]]\n  ((fn reflects? [t1 t2]\n     (if (and (nil? t1) (nil? t2))\n       true\n       (let [[v1 l1 r1] t1\n             [v2 l2 r2] t2]\n         (and (= v1 v2)\n              (reflects? l1 r2)\n              (reflects? l2 r1))))) a b))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 96, "code": "(fn [tree]\n  (let [rv (fn rv [t]\n           (if (coll? t)\n             (let [[x y z] t]\n               [x (rv z) (rv y)])\n             t))]\n    (= (rv tree) tree))\n)", "user": "5a1c3c11e4b0ff51aa4b323d"}, {"problem": 96, "code": "(fn sym-tree [[par left-c right-c]]\n  (let [tree-flip\n        (fn tflip [tree]\n          (when-let [[p c1 c2] tree]\n            [p (tflip c2) (tflip c1)]))]\n    (= right-c (tree-flip left-c))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 96, "code": "(fn symmetric? [[root left right :as tree]]\n  (letfn [(valid? [tree]\n            (or (coll? tree)\n                (= 3 (count tree))))\n          (mirror [[root left right :as tree]]\n                (if-not (valid? tree)\n                  tree\n                  [root (mirror right) (mirror left)]))]\n    (if-not (valid? tree)\n      false\n      (= left\n         (mirror right)))))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 96, "code": "(fn symmetric-tree? [tree]\n (if (nil? tree)\n  true\n  (let [[head left right] tree\n        flip (fn flip [tree]\n              (when-let [[head left right] tree]\n               [head (flip right) \n                     (flip left)]))]\n   (= left (flip right)))))", "user": "5486e317e4b0e286459a11c0"}, {"problem": 96, "code": "(letfn [(p [tree]\n           (or (nil? tree)\n               (let [[_ left right] tree]\n                 (mirror= left right)\n                 )\n               )\n           )\n        (mirror= [t1 t2]\n                 (or (and (nil? t1)\n                          (nil? t2))\n                     (let [[t1-val t1-left t1-right] t1\n                           [t2-val t2-left t2-right] t2]\n                       (and (= t1-val t2-val)\n                            (mirror= t1-left t2-right)\n                            (mirror= t1-right t2-left)\n                            )\n                       )\n                     )\n                 )\n        ]\n  p)", "user": "5a7497d2e4b0512ff01cdaba"}, {"problem": 96, "code": "(fn sym?\n  ([bin] (let [[value left right] bin] (sym? left right)))\n  ([bin1 bin2]\n   (if (and (seq bin1) (seq bin2))\n     (let [[value1 left1 right1] bin1\n           [value2 left2 right2] bin2]\n       (and (= value1 value2) (sym? left1 right2) (sym? left2 right1)))\n     (if (not= (seq bin1) (seq bin2))\n       false\n       (= bin1 bin2)))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 96, "code": "(fn sym-tree? [t]\n  (letfn [(l [t] (second t))\n          (r [t] (last t))\n          (v [t] (first t))\n          (mirror? [left right]\n            (cond\n              (and (nil? left) (nil? right)) true\n              (and (nil? left) (not (nil? right))) false\n              (and (not (nil? left)) (nil? right)) false\n              :else (and (= (v left) (v right))\n                         (mirror? (r left) (l right))\n                         (mirror? (l left) (r right)))))]\n    (if (nil? t) true (mirror? (l t) (r t)))\n    )\n  )", "user": "5a621702e4b0512ff01cd983"}, {"problem": 96, "code": "(fn [z]\n  (letfn \n    [(rot [x]\n          (if (sequential? x)\n            (let [[a b c] x]\n              [a (rot c) (rot b)])\n            x))]\n            \n    (= z (rot z))))", "user": "5a6a7cc5e4b0512ff01cda27"}, {"problem": 96, "code": "(fn [args]\n  ((fn symmetry [lt rt]\n     (cond\n       (and (nil? lt) (nil? rt)) true\n       (or (and (nil? lt) (not (nil? rt)))\n           (and (nil? rt) (not (nil? lt)))) false\n       (or (not= 3 (count lt))\n           (not= 3 (count rt))) false\n       :else (and (= (first lt) (first rt))\n                  (symmetry (second lt) (second (rest rt)))\n                  (symmetry (second rt) (second (rest lt))))))\n    (second args)\n    (second (rest args))))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 96, "code": "(fn sym?[t]\n  (letfn [(rev [[v l r]]\n            (if (nil? v)\n              nil\n              [v (rev r) (rev l)]))]\n               \n    (or\n     (nil? t)\n     (= (nth t 1) (rev (nth t 2))))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(binary-tree? [t] (or (nil? t) (and (sequential? t) (= (count t) 3) (every? binary-tree? (rest t)))))\n          (reverse-tree [t]\n            (if (nil? t)\n              nil\n              (let [[v t1 t2] t]\n                (list v (reverse-tree t2) (reverse-tree t1)))))]\n    (if (not (binary-tree? t))\n      false\n      (let [[_ t1 t2] t]\n        (= t1 (reverse-tree t2))))))", "user": "5a512929e4b05d388ecb6be2"}, {"problem": 96, "code": "(fn sym \n  [[k left right]]\n\t(or\n     (and (nil? left) (nil? right))\n     (and \n      (= (first left) (first right))\n      (and (sym [k (second left) (last right)]) (sym [k (last left) (second right)])))))", "user": "552d9b31e4b076ab5578f7eb"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "5a5dbe9de4b0512ff01cd92b"}, {"problem": 96, "code": "(fn [T] (letfn [(m [T] (if (nil? T) T (let [[p l r] T] [p (m r) (m l)])))] (= T (m T))))", "user": "59da6480e4b0ef0a1e9b5c68"}, {"problem": 96, "code": "(fn my-symmetric?\n  [[a b c]]\n  (let [mirror (fn mirror [coll] (if (sequential? coll) \n                                  (conj '() \n                                    (mirror (nth coll 1)) \n                                    (mirror (nth coll 2)) \n                                    (nth coll 0))  \n                                  coll))]\n   (if (= (mirror b) c) true false)))", "user": "59f44189e4b0966464fe6aab"}, {"problem": 96, "code": "(fn symmetric [tree]\n  (letfn [(node-equal [node-a node-b]\n                      (let [[a b c] node-a\n        [x y z] node-b]\n    (and (= a x)\n         (if (and (coll? b) (coll? z)) (node-equal b z) (= b z))\n         (if (and (coll? c) (coll? y)) (node-equal c y) (= c y)))))]\n    (let [[r c1 c2] tree]\n    (node-equal c1 c2))\n))", "user": "5a388675e4b001c08efc0ca2"}, {"problem": 96, "code": "(fn ab [[root l r :as tree]]\n\t (zero? (compare (vec l)\n\t\t\t((fn ff [[root l r :as tree]]\n\t\t\t\t[root \n\t\t\t\t\t(if (nil? r) r (ff r))\n\t\t\t\t\t(if (nil? l) l (ff l))\n\t\t\t\t]\n\t\t\t)(vec r))))\n\t)", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (let [mirror (fn mir [[v l r]]\n                 (if (sequential? l)\n                   (if (sequential? r)\n                     [v (mir r) (mir l)]\n                     [v r (mir l)])\n                   (if (sequential? r)\n                     [v (mir r) l]\n                     [v r l])))]\n    (= r (mirror l))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 96, "code": "(fn [bin-tree]\n  (letfn [(mirror? [t1 t2]\n                   (if (nil? t1)\n                     (nil? t2)\n                     (and (= (first t1) (first t2))\n                          (mirror? (nth t1 1) (nth t2 2))\n                          (mirror? (nth t1 2) (nth t2 1)))))]\n    (or (nil? bin-tree)\n        (mirror? (second bin-tree)\n                 (nth bin-tree 2)))))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 96, "code": "#(= % ((fn flip [[n l r :as t]]\n        (if t [n (flip r) (flip l)])) %))", "user": "5a546344e4b05d388ecb6c27"}, {"problem": 96, "code": "(fn \n  [[_ left right]]\n  (letfn [(reverse-tree\n            [[n l r :as t]]\n            (if (nil? t)\n              nil\n              [n (reverse-tree r) (reverse-tree l)]))]\n    (= left (reverse-tree right))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5a653f80e4b0512ff01cd9b2"}, {"problem": 96, "code": "(fn [s]\n\t(let [a (second s) b (last s)]\n\t\t(letfn\n\t\t\t[(mirror [s]\n\t\t\t\t(let [x (second s) y (last s)]\n\t\t\t\t\t(if\n\t\t\t\t\t\t(and (nil? x) (nil? y))\n\t\t\t\t\t\ts\n\t\t\t\t\t\t(list (first s)\n\t\t\t\t\t\t\t(if (nil? y) y (mirror y))\n\t\t\t\t\t\t\t(if (nil? x) x (mirror x))))))]\n\t\t\t(= a (mirror b)))))", "user": "5a984657e4b0d174b936c78a"}, {"problem": 96, "code": "(fn symmetric-binary-tree?\n  [x]\n  (let [binary-tree? (fn binary-tree? [x] (if (coll? x)\n                               (and\n                                 (= 3 (count x))\n                                 (not (coll? (first x)))\n                                 (binary-tree? (second x))\n                                 (binary-tree? (nth x 2)))\n                               (nil? x)))\n        reverse-binary-tree (fn reverse-binary-tree\n                              [x]\n                              (if (not (coll? x))\n                                x\n                                (vector (first x)\n                                        (reverse-binary-tree (nth x 2))\n                                        (reverse-binary-tree (second x)))))]\n    (and (binary-tree? x)\n         (= (reverse-binary-tree (second x))\n            (nth x 2)))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 96, "code": "#(letfn [(\n           sym? [[v1 l1 r1 :as l] [v2 l2 r2 :as r]]\n  (cond\n    ((complement =) v1 v2) false\n    (every? nil? [l1 l2 r1 r2]) true\n    :else (and (sym? l1 r2) (sym? r1 l2)))\n           )] (sym? (second %) (last %)))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 96, "code": "(let [flip (fn flip [node]\n             (when (sequential? node)\n               (list (first node) (flip (nth node 2)) (flip (nth node 1)))))]\n  #(= % (flip %)))", "user": "5aa4f7dae4b0d174b936c88c"}, {"problem": 96, "code": "(fn sym-tree?\n  ([tree]\n   (cond\n     (= (count tree) 1)\n     true\n     (= (count tree) 3)\n     (sym-tree? (second tree) (last tree))))\n  ([e1 e2]\n   (cond\n     (and (nil? e1) (nil? e2)) true\n\n     (and (coll? e1) (coll? e2))\n     (and (= (count e1) (count e2) 3)\n          (= (first e1) (first e2))\n          (sym-tree? (second e1) (last e2))\n          (sym-tree? (last e1) (second e2)))\n     :else\n     false)))", "user": "5a99b863e4b0d174b936c7ae"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5a99cab6e4b0d174b936c7b2"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5aa00b7fe4b0d174b936c825"}, {"problem": 96, "code": "#(= ((fn symmetric [[n l r :as tree]] \n       (when tree [n (symmetric r) (symmetric l)])) %) %)", "user": "5aa4b961e4b0d174b936c888"}, {"problem": 96, "code": "(fn symetry\n    ([[v left right]]\n     (symetry left right))\n    ([[v1 left1 right1] [v2 left2 right2]]\n     (if (or (nil? v1) (nil? v2))\n       (and (nil? v1) (nil? v2))\n       (and (= v1 v2) (symetry left1 right2) (symetry right1 left2)))))", "user": "5a99b766e4b0d174b936c7a8"}, {"problem": 96, "code": "#(= % (\n       (fn mirror\n         [[a b c :as coll]]\n         (when coll [a (mirror c) (mirror b)])) %))", "user": "4ee897fe535d93acb0a66883"}, {"problem": 96, "code": "#(= % ((fn mirror\n        [[a b c :as coll]]\n        (when coll [a (mirror c) (mirror b)])) %))", "user": "57b19fa1e4b0fbc9809a2754"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5a99b844e4b0d174b936c7ab"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5a99b848e4b0d174b936c7ac"}, {"problem": 96, "code": "(fn sym\n  ([lst] (sym (second lst) (last lst)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym (second a) (last b))\n                  (sym (last a) (second b)))\n             false))))", "user": "5a9cdec0e4b0d174b936c7e1"}, {"problem": 96, "code": "(fn symmetry \n  [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5a9f005be4b0d174b936c810"}, {"problem": 96, "code": "#(= % ((fn flip [[x left right :as n]]\n       (when n [x (flip right) (flip left)])) %))", "user": "5a99b87ee4b0d174b936c7af"}, {"problem": 96, "code": "#(= ((fn symmetric [[n l r :as tree]] (when tree [n (symmetric r) (symmetric l)])) %) %)", "user": "5aa6d44de4b0d174b936c8b2"}, {"problem": 96, "code": "(fn beauty-symm\n  [tree]\n  \n  (let [order (fn tree2 [tree] \n                (if (empty? tree) \n                  [] \n                  (concat (tree2 (second tree)) (vector (first tree)) (tree2 (nth tree 2)))))\n        \n        aux1 (order tree)\n        aux2 (reverse aux1)]\n    \n    (= aux1 aux2)))", "user": "5a99ae99e4b0d174b936c7a4"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b))) false))))", "user": "5a99b688e4b0d174b936c7a6"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5a9dbffbe4b0d174b936c7f4"}, {"problem": 96, "code": "(fn sym?\n  ([n] (sym? (second n) (last n)))\n  ([x y] (or\n           (and (nil? x) (nil? y))\n           (if (and (coll? x) (coll? y))\n             (and (= (count x) (count y) 3)\n                  (= (first x) (first y))\n                  (sym? (second x) (last y))\n                  (sym? (last x) (second y)))\n             false))))", "user": "5a99b861e4b0d174b936c7ad"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5a912080e4b002d099cae6ea"}, {"problem": 96, "code": "(fn cs2 [[root left right]]\n  (let [mirror? (fn mirror? [l r]\n                  (cond\n                    (not= (sequential? l) (sequential? r)) false\n                    (sequential? l) (let [[a b c] l\n                                   [d e f] r]\n                               (and  (= a d) (mirror? b f) (mirror? e c)))\n                    :else (= l r)))]\n    (mirror? left right)))", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 96, "code": "#((fn mirror [[l r]]\n       (if (and (coll? l)\n                (coll? r)\n                (= (first l) (first r)))\n           (and (mirror [(second l) (last r)]) (mirror [(last l) (second r)]))\n         (if (and (nil? l) (nil? r)) true false))) [(second %) (last %)])", "user": "5a9db5c9e4b0d174b936c7f1"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(traverse\n            [[value left right :as tree]]\n            (if tree\n              (concat (traverse left)\n                      [value]\n                      (traverse right))\n              []))]\n    (= (traverse left)\n       (reverse (traverse right)))))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 96, "code": "(fn [alst]\n (letfn [(swap [alst]\n             (list (first alst)\n              (if (coll? (last alst)) (swap (last alst)) (last alst))\n              (if (coll? (second alst)) (swap (second alst)) (second alst))))]\n\n  (and (= 3 (count alst))\n   (not (coll? (first alst)))\n   (coll? (second alst))\n   (= (swap (second alst)) (last alst)))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 96, "code": "(fn tree_sym? [tree]\n  (letfn [(node [t] (first t))\n          (left [t] (second t))\n          (right [t] (nth t 2))\n          (tree_eq? [t1 t2]\n                    (if (and (seq t1) (seq t2))\n                      (and (= (node t1) (node t2))\n                           (tree_eq? (left t1) (right t2))\n                           (tree_eq? (right t1) (left t2)))\n                      (= t1 t2)))]\n    (tree_eq? (left tree) (right tree))))", "user": "51000111e4b00d7ad4cab15e"}, {"problem": 96, "code": "(fn [t] \n  (=\n   (nth t 1) \n   ((fn flip [node]\n      (if (nil? node)\n        nil \n        [(nth node 0) (flip (nth node 2)) (flip (nth node 1))]\n      )) (nth t 2))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 96, "code": "#(if (= 1 (count %)) \n    true\n    (letfn [(cmp-tree [tree tree']\n              (cond\n                (nil? tree) (nil? tree') \n                (= (first tree) (first tree')) (or\n                                                 (= 1 (count tree) (count tree'))\n                                                 (and (cmp-tree (seq (second tree)) (seq (last tree')))\n                                                      (cmp-tree (seq (last tree)) (seq (second tree')))))\n                :else false))]\n      (cmp-tree (seq (second %)) (seq (last %)))))", "user": "5a67cedbe4b0512ff01cd9ee"}, {"problem": 96, "code": "(fn [tree]\n  (let [binary-tree? (every-pred sequential? (comp #{3} count))\n        symmetric? (fn [a b]\n                     (= (map first (tree-seq binary-tree? rest a))\n                        (map first (tree-seq binary-tree? (comp reverse rest) b))))]\n    (apply symmetric? (rest tree))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 96, "code": "(fn symmetric? [tr]\n  (letfn [(mirror-tree [t]\n            (if (nil? t)\n              nil\n              (let [[v a b] t]\n                [v (mirror-tree b) (mirror-tree a)])))]\n    (let [[v a b] tr]\n      (= a (mirror-tree b)))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 96, "code": "(fn [n]\n  (letfn [(is-tree-symm [t1 t2]\n            (or (and (nil? t1) (nil? t2))\n                (and (coll? t1)\n                     (coll? t2)\n                     (= (first t1) (first t2))\n                     (is-tree-symm (second t1) (last t2))\n                     (is-tree-symm (second t2) (last t1)))))]\n    (or (nil? n)\n        (is-tree-symm (second n) (last n)))))", "user": "576b4e6be4b0a07e8fc1812b"}, {"problem": 96, "code": "#(= ((fn mirror\n        [[n l r :as tree]] \n       (when tree [n (mirror r) (mirror l)])) %) %)", "user": "52faf67ce4b047fd55837005"}, {"problem": 96, "code": "#((fn tree-mirrored? [tree1 tree2]\n  (if-not (= (first tree1) (first tree2))\n    false\n    (if (nil? tree1)\n      true\n      (and\n        (tree-mirrored? (second tree1) (last tree2))\n        (tree-mirrored? (second tree2) (last tree1)))))) (second %) (last %))", "user": "5a9ac061e4b0d174b936c7c1"}, {"problem": 96, "code": "(fn [tree]\n    (letfn [(root [coll] (first coll))\n            (left-child [coll] (second coll))\n            (right-child [coll] (last coll))\n            (symmetric? [left-sub-tree\n                         right-sub-tree]\n              (if (and (sequential? left-sub-tree)\n                       (sequential? right-sub-tree))\n                (if (= (root left-sub-tree)\n                       (root right-sub-tree))\n                  (and (symmetric? (left-child left-sub-tree)\n                                   (right-child right-sub-tree))\n                       (symmetric? (right-child left-sub-tree)\n                                   (left-child right-sub-tree)))\n                  false)\n                (= left-sub-tree right-sub-tree)))]\n      (symmetric? (second tree) (last tree))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 96, "code": "#(=\n((fn m [[n l r :as x]]\n (when x [n (m r) (m l)])) %) %)", "user": "5aa8f753e4b0d174b936c8d9"}, {"problem": 96, "code": "(fn [tree]\n  (let [leaves #(map first (tree-seq next (comp %1 rest) (%2 tree)))\n        left-leaves (leaves identity second)\n        right-leaves (leaves reverse last)]\n    (= left-leaves right-leaves)))", "user": "5abbbd46e4b073f1774426db"}, {"problem": 96, "code": "(letfn [(flip [[n c1 c2]] \n              (if (nil? n) nil \n                [n (flip c2) (flip c1)]))]\n\n (fn sym? [[_ c1 c2]]\n   (= c1 (flip c2))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5a9a12d6e4b0d174b936c7b7"}, {"problem": 96, "code": "(fn balanced-tree?\n  [t]\n  (loop [collected-branches [t]]\n    (let [values-at-level (map first collected-branches)\n          branches (concat (map second collected-branches)\n                           (map last collected-branches))]\n      (if-not (= values-at-level (reverse values-at-level))\n        false\n        (if-not (some sequential? branches)\n          true\n          (recur branches))))))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": 96, "code": "(let [mirror (fn mirror [t] (if (nil? t) nil [(first t) (mirror (last t)) (mirror (first (rest t)))]))] (fn [t] (= (first (rest t)) (mirror (last t)))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "4f072644535dcb61093f6c20"}, {"problem": 96, "code": "(fn [tree]\n    (letfn [(mirror [tree]\n              (if (nil? tree)\n                nil\n                (let [[root left right] tree]\n                  (list root\n                        (mirror right)\n                        (mirror left)))))\n            (symmetric? [tree]\n              (let [[root left right] tree]\n                (= left (mirror right))))]\n      (symmetric? tree)))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 96, "code": "(fn [[s l r :as t]]\n  (if (= 3 (count t))\n    (let [out ((fn binary-tree-equal [[s1 l1 r1 :as t1] [s2 l2 r2 :as t2]]\n                 (cond (= 3 (count t1) (count t2)) (and (= s1 s2)\n                                                        (binary-tree-equal l1 r2)\n                                                        (binary-tree-equal r1 l2))\n                       (and (nil? t1) (nil? t2)) true\n                       :else false)) l r)]\n      out)\n  false))", "user": "5ad3d730e4b0ea6055cfabc8"}, {"problem": 96, "code": "(fn [[_ l r]]\n    (letfn\n      [(symmetric?\n         [l r]\n         (let\n           [ll (mapcat rest l)\n            rr (mapcat rest r)]\n           (and\n             (= (map first l) (reverse (map first r)))\n             (or (and (every? nil? ll) (every? nil? rr))\n                 (symmetric? ll rr)))))]\n      (symmetric? [l] [r])))", "user": "586bc870e4b01531a375e964"}, {"problem": 96, "code": "(fn [[a b c]] (letfn [(swap [[f s t :as tree]]\n                       (if (and (nil? s) (nil? t))\n                         tree\n                         (list f (swap t) (swap s))))]\n               (= c (swap b))))", "user": "5aefdc8de4b0cc2b61a3bc40"}, {"problem": 96, "code": "#(= %\n    ((fn f [[v l r :as n]]\n       (when n\n         [v (f r) (f l)]))\n     %))", "user": "58b54852e4b0ebc645576d52"}, {"problem": 96, "code": "#(= %\n    (clojure.walk/prewalk\n     (fn [n]\n       (if-not (coll? n)\n         n (let [[v l r] n] [v r l])))\n     %))", "user": "5aeca4c9e4b0cc2b61a3bc0a"}, {"problem": 96, "code": "(fn is-sym-b-tree? [t] (= t (letfn [(mirror-tree\n                                     [v]\n                                     (if (nil? v) v\n                                       (let [[value l r] v]\n                                         [value (mirror-tree r) (mirror-tree l)])))]\n                              (mirror-tree t))))", "user": "5af31955e4b0cc2b61a3bc7a"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(inorder [[v l r]]\n            (concat (if (nil? l) [] (inorder l))\n                    [v]\n                    (if (nil? r) [] (inorder r))))]\n    (let [[v l r] tree]\n      (= (inorder l) (reverse (inorder r))))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 96, "code": "(fn [s]\n  (letfn [(mr [r l]\n            (cond\n              (and (sequential? r) (sequential? l))\n              (and (= 3 (count r) (count l))\n                   (= (first r) (first l))\n                   (mr (second r) (last l))\n                   (mr (last r) (second l)))\n              (and (nil? r) (nil? r))\n              true\n              :else\n              false))]\n    (and (sequential? s) (= 3 (count s)) (mr (second s) (last s)))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 96, "code": "(fn [[root left right]]\n  (letfn [(flip [[rt l r]]\n                [rt \n                 (when r (flip r))\n                 (when l (flip l))])]\n  \n    (= left (flip right))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 96, "code": "#(= % ((fn sym [[a c b]] (conj [a] (if (coll? b) (sym b) b) (if (coll? c) (sym c) c))) % ))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 96, "code": "(fn [in]\n  (letfn [(branch-reverse [[f & r :as l]] (let [reversed-branch (into (empty l) (apply list f (reverse r)))] (into (empty l) (map #(if (coll? %) (branch-reverse %) %) reversed-branch))))] (= (nth in 2) (branch-reverse (nth in 1)))))", "user": "59ddae03e4b01968742fed65"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(mirror [[v l r]]\n             [v \n               (if (seq r) (mirror r) r)\n               (if (seq l) (mirror l) l)])]\n    (= l (mirror r))))", "user": "5aea2d21e4b0cc2b61a3bbe2"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n(mirror? left right)))", "user": "5ae0976be4b0837691e92c43"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(rev [t]\n            (if (nil? t)\n              nil\n              [(nth t 0) (rev (nth t 2)) (rev (nth t 1))]))]\n    (= t (rev t))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(ab->ba [[v a b :as x]]\n                  (if (nil? x)\n                    x\n                    (vector v\n                            (ab->ba b) \n                            (ab->ba a))))]\n    (let [[_ a b] tree] (= (ab->ba a) b))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 96, "code": "(fn [[r ls rs]]\n  (let [tr-tr (fn tr-tr [[root :as tree] l r]\n                (if (sequential? tree)\n                  (concat [root] (tr-tr (l tree) l r) (tr-tr (r tree) l r))\n                  [tree]))\n        t1 (tr-tr ls last second)\n        t2 (tr-tr rs second last)]\n    (= t1 t2)))", "user": "5649b1b0e4b0284900eef646"}, {"problem": 96, "code": "#(let [ sw (fn [l] (list (first l) (last l) (second l)))\n        rf (fn [l] (filter (complement sequential?) (rest (tree-seq sequential? sw l))))]\n  (= (flatten (second %)) (rf (last %))))", "user": "52570aeae4b0541d1855ba42"}, {"problem": 96, "code": "(fn\n  [node]\n  (let [left (second node)\n        right (last node)\n        helper (fn eita [l r]\n                 (if (and (nil? l) (nil? r))\n                   true\n                   (if (or (nil? l) (nil? r))\n                     false\n                     (and (= (first l) (first r))\n                          (eita (second l) (last r))\n                          (eita (last l) (second r))))))]\n    (helper left right)))", "user": "5afcd6d1e4b0cc2b61a3bd17"}, {"problem": 96, "code": "(fn sym-tree? [[val left right :as s]]\n  (and\n   ((fn triple? [s] (and\n                   (coll? s)\n                   (= (count s) 3))) s)\n   ((fn sym-tree-h [[a-val a-left a-right :as a-s] [b-val b-left b-right :as b-s]]\n  (or \n   (and\n    ((fn triple? [s] (and\n                   (coll? s)\n                   (= (count s) 3))) a-s)\n    ((fn triple? [s] (and\n                   (coll? s)\n                   (= (count s) 3))) b-s)\n    (= a-val b-val)\n    (sym-tree-h a-left b-right)\n    (sym-tree-h a-right b-left))\n   (and\n    (nil? a-s)\n    (nil? b-s))\n   )) left right)))", "user": "5b0bea6de4b0cc2b61a3bdda"}, {"problem": 96, "code": "(fn [[_ l r]] (= l ((fn f [[n l r]] (if n [n (f r) (f l)])) r)))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 96, "code": "(fn s? [t]\n  (letfn [(s [t]\n             (when (and (coll? t) \n                        (-> t count (= 3))) \n               (let [[a b c] t] [a (s c) (s b)])))] \n  (= t (s t))))", "user": "51a3be77e4b0e77c4ca60bf8"}, {"problem": 96, "code": "(fn is-sym? [t]\n  (= (flatten\n    ((fn fff[[x l r]]\n      (if (nil? x)\n        x\n        [x (fff r) (fff l)])) t))\n      (flatten t)))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 96, "code": "(fn mirrored? \n  [tree]\n  (= tree\n     ((fn mirror [[root left right :as tree]]\n        (if tree\n          [root (mirror right) (mirror left)]\n          nil))\n      tree)))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 96, "code": "(fn sym? \n\n([t]\n     (cond\n       (nil? t) false\n       (sequential? t) (sym? (nth t 1) (nth t 2))))\n\n  ([lhs rhs]\n   (cond\n     (nil? lhs) (nil? rhs)\n     :default (and (= (first lhs) (first rhs))\n                   (and (sym? (nth lhs 1) (nth rhs 2))\n                        (sym? (nth lhs 2) (nth rhs 1)))))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 96, "code": ";\u30d1\u30af\u30ea\n#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 96, "code": "(fn symetric? [[_ left right]]\n  (if (not (coll? left))\n    true\n    (if (not (and (coll? left) (coll? right)))\n      false\n      (let [[LV LL LR] left\n            [RV RL RR] right]\n        (and (= LV RV)\n             (symetric? [nil LL RR])\n             (symetric? [nil RL LR])\n             )))))", "user": "57e79d8ee4b0bfb2137f5afe"}, {"problem": 96, "code": "#((let [eq (fn g [[lv ll lr :as l] [rv rl rr :as r]]\n             (or (and (nil? l) (= l r))\n                 (and (= lv rv) (g ll rr) (g lr rl))))]\n   (fn f [[v l r]] (eq l r))\n   ) %)", "user": "5b210749e4b03cfeda66ed48"}, {"problem": 96, "code": "(fn sym-tree? [[_ left right]]\n  (letfn [(symmetric? [l r]\n            (cond\n              ; One side is a leaf and the other is a node.\n              (not= (sequential? l) (sequential? r)) false\n              ; Both sides are nodes.\n              (sequential? l) (let [[lv ll lr] l\n                                    [rv rl rr] r]\n                                (and (= lv rv)\n                                     (symmetric? ll rr)\n                                     (symmetric? lr rl)))\n              ; Both sides are leafs.\n              :else (= l r)\n              ))]\n    (symmetric? left right)))", "user": "5b1d61b3e4b03cfeda66ecfe"}, {"problem": 96, "code": "(fn sym?[tree]\n  (let [summary (atom [])\n        walk (fn walk\n            ([tree]\n             (walk (first tree) (second tree)(last tree) 0))\n            ([id left-leg right-leg depth]\n             (if (coll? left-leg)\n               (apply walk (conj (vec left-leg) (inc depth)))\n               (swap! summary #(conj % (vector \"<\" id))))\n             (if (coll? right-leg)\n               (apply walk (conj (vec right-leg) (inc depth)))\n               (swap! summary #(conj % (vector \">\" id))))))\n        arrow-swapper (or #({\">\" \"<\" \"<\" \">\"} %) #(identity))\n        check (fn check[summary]\n                (let [left (first summary)\n                      r (vec (reverse (last summary)))\n                      right (vector (arrow-swapper (last r)) (first r))\n                      more (rest (butlast summary))]\n                  (println left)\n                  (println right)\n                  (if (empty? summary)\n                    '()\n                    (cons (= left right)(check more)))))]\n    (walk tree)\n    (every? identity (check @summary))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 96, "code": "(fn f \n  ([[val l r :as tr]] (f l r))\n  ([a b]\n   (let [[va la ra] a\n         [vb lb rb] b]\n     (cond\n       (and (nil? a) (nil? b)) true\n       (not= va vb) false\n       :else (and (f la rb)\n                  (f lb ra))))))", "user": "5777c3d6e4b0979f8965164f"}, {"problem": 96, "code": "(fn symmetry [[k left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n(mirror? left right)))", "user": "593910eae4b02506e01a29f4"}, {"problem": 96, "code": "(letfn [(flip [tree]\n             (when-let [[a b c] tree]\n               [a (flip c) (flip b)]))]\n  (fn [[_ b c]]\n    (= b (flip c))))", "user": "5ab5f60be4b073f177442643"}, {"problem": 96, "code": "(fn ts?\n  ([a] (or (= a nil)) (apply ts? (rest a)))\n  ([a b] (or (= a b nil) (let [[a1 a2 a3] a [b1 b2 b3] b]\n                           (and (= a1 b1) (ts? a2 b3) (ts? a3 b2))))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 96, "code": "(let\n  [third #(second (rest %))\n   mirror (fn mirror [l r]\n            (let [lnil (= l nil) rnil (= r nil)]\n              (or\n               (and lnil rnil)\n               (and\n                (not lnil)\n                (not rnil)\n                (= (first l) (first r))\n                (mirror (second l) (third r))\n                (mirror (second r) (third l))))))]\n  (fn [tree] (mirror (second tree) (third tree))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "53d5d43ce4b0e771c302544d"}, {"problem": 96, "code": "(fn [tree] (\n(fn aresym [x y] (if (nil? x)\n                   (nil? y)\n                   (if (nil? y)\n                     false\n                     (if (= (first x) (first y))\n                       (and (aresym (second x) (last y)) (aresym (last x) (second y)))\n                       false)))) (second tree) (last tree)\n            ))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(flip [tree]\n            (if (nil? tree)\n              nil\n              (let [[root left right] tree]\n                [root (flip right) (flip left)])))]\n  (= (second tree) (flip (last tree)))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 96, "code": "(fn symmetry? [[root left right]]\n  (let [mirror? (fn mirror? \n                  [a b]\n                  (cond \n                   (not= (sequential? a) (sequential? b)) false\n                   (sequential? a) (let [[ra La Ra] a\n                                         [rb Lb Rb] b]\n                                     (and (= ra rb) (mirror? La Rb) (mirror? Ra Lb)))\n                   :else (= a b)\n                   )\n                  )]\n    (mirror? left right)))", "user": "5b0b8d29e4b0cc2b61a3bdd7"}, {"problem": 96, "code": "(fn\n  [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb)\n                                           (mirror? La Rb)\n                                           (mirror? Lb Ra)))\n                    :else (= a b)))]\n    (mirror? left right)\n    )\n  )", "user": "517e12e3e4b0fcc7c5d37d3c"}, {"problem": 96, "code": "(fn is-symmetric\n  ([tree] (is-symmetric (second tree) (last tree)))\n  ([left-tree right-tree]\n    (if (and (nil? left-tree) (nil? right-tree))\n      true\n      (let\n        [left-root (first left-tree)\n         right-root (first right-tree)]\n        (and\n          (= left-root right-root)\n          (is-symmetric (second left-tree) (last right-tree))\n          (is-symmetric (last left-tree) (second right-tree)))))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 96, "code": "(fn symmetric?[ [value left right] ]\n  (println \"s\" value left right)\n  (if (or (nil? left) (nil? right)) \n    (and (nil? left) (nil? right))\n    (let [\n      [left-data left-left left-right] left\n      [right-data right-left right-right] right\n      ]\n      (and\n        (= left-data right-data)\n        (symmetric? [left-data left-left right-right] )\n        (symmetric? [left-data left-right right-left] )\n      )\n    )\n  )\n)", "user": "5b58b271e4b02d533a91bd6e"}, {"problem": 96, "code": "#(letfn [(flip [[root l r :as tree]] \n               (list\n                root\n                (if (sequential? r) (flip r) r)\n                (if (sequential? l) (flip l) l)))]\n   (= % (flip %)))", "user": "59ef6cfae4b0966464fe6a32"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5839f079e4b089d5ab817d48"}, {"problem": 96, "code": "#(letfn [(flip [[v l r]]\n          (when (or v l r)\n           [v (flip r) (flip l)]))]\n  (= % (flip %)))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 96, "code": "(fn foo [[root l r]]\n  (= l ((fn flipTree [[root child1 child2]]\n          (if (and (nil? child1) (nil? child2))\n            (list root child1 child2)\n            (conj \n             (list (if (nil? child1) child1 (flipTree child1)))\n             (if (nil? child2) child2 (flipTree child2))\n             root)))\n        r)))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 96, "code": "(fn bis[x]\n  (= (nth x 1) ((fn dr[y]\n    ( if (nil? y)\n      nil\n      (cons (first y) [(dr (nth y 2)) (dr (nth y 1))])\n    )\n  ) (nth x 2)))\n)", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 96, "code": "#(= %\n    ((fn f [[v l r :as n]]\n       (when n\n         [v (f r) (f l)]))\n     %))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 96, "code": "#(letfn [(flip [x] (if (coll? x) (let [[p l r] x] [p (flip r) (flip l)]) x))]\n  (= (nth % 1) (flip (nth % 2))))", "user": "5b6473eee4b0c6492753e73f"}, {"problem": 96, "code": "(fn symmetric? [root]\n  (let [symm? (fn symm? [left right] (or (and (nil? left) (nil? right))\n                                   (and (sequential? left) (sequential? right)\n                                        (= (first left) (first right))\n                                        (symm? (second left) (last right))\n                                        (symm? (last left) (second right)))))]\n    (symm? (second root) (last root))))", "user": "5aeb0b44e4b0cc2b61a3bbee"}, {"problem": 96, "code": "#(letfn [(tree-walk [f] (map first (tree-seq sequential? f %)))]\n   (= (tree-walk rest) (tree-walk (comp reverse rest))))", "user": "5b772ad7e4b047b03b2036e8"}, {"problem": 96, "code": "(fn sym-tree\n  [[_ L R ]]\n  (if (not (coll? L))\n   true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (and (= LV RV) (sym-tree [nil LL RR]) (sym-tree [nil RL LR]))))))", "user": "59cd13d5e4b0ef0a1e9b5b32"}, {"problem": 96, "code": "(fn s?\n  ([[v l r]] (s? l r))\n  ([l r]\n    (or\n      (= nil l r)\n      (let [[a b c] l\n            [d e f] r]\n        (and\n          (= a d)\n          (s? b f)\n          (s? c e))))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 96, "code": "#(= % ((fn f [[x l r :as q]] (when q [x (f r) (f l)])) %))", "user": "4db1fe241254ad5b4805fa77"}, {"problem": 96, "code": "(fn symmetric?\n    ([xs] (symmetric? (second xs) (last xs)))\n    ([xs ys]\n     (cond\n       (every? nil? [xs ys]) true\n       (not= (first xs) (first ys)) false\n       :else (and\n              (symmetric? (second xs) (last ys))\n              (symmetric? (last xs) (second ys))))))", "user": "5a544eeee4b05d388ecb6c24"}, {"problem": 96, "code": "(fn check-sym [[root left right]]\n  (letfn [(reflect [[branch-root left-child right-child :as node]]\n           (if (= node nil) nil\n             [branch-root (reflect right-child) (reflect left-child)]))]\n    (= left (reflect right))))", "user": "5a3c06fce4b001c08efc0cdd"}, {"problem": 96, "code": "(fn [c]\n  (= \n   ((fn m [[root l r]]\n      (if root\n        (list root (m r) (m l))\n        nil)) c) c))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                   (not= (sequential? a) (sequential? b)) false\n                   (sequential? a) (let [[ra La Ra] a\n                                         [rb Lb Rb] b]\n                                     (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                   :else (= a b)))]\n    (mirror? left right)))", "user": "5b985fe5e4b0c0b3ffbd4ab1"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5b88f0c0e4b047b03b203816"}, {"problem": 96, "code": "(fn sym-bin-tree? [[_ left right]]\n  (if (and (sequential? left) (sequential? right))\n    (let [[lval llval rlval] left\n          [rval lrval rrval] right]\n      (and (= lval rval)\n           (sym-bin-tree? [nil llval rrval])\n           (sym-bin-tree? [nil rlval lrval])))\n    (= left right)))", "user": "5b333626e4b025bcb146f32f"}, {"problem": 96, "code": "(fn [x]\n  (let [a '(:a (:b nil nil) (:b nil nil))\n        b '(:a (:b nil nil) nil)\n        c '(:a (:b nil nil) (:c nil nil))\n        d [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]]\n        e [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]]\n        f [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]\n          [2 [3 nil [4 [6 nil nil] nil]] nil]]\n        ]\n    (if (= a x) true (if (= d x) true false))))", "user": "5b9db58be4b0c0b3ffbd4b41"}, {"problem": 96, "code": "(fn symmetric?\n  ([tree]\n   (symmetric? tree tree))\n  ([t1 t2]\n   (if (and (nil? t1) (nil? t2))\n    true\n    (and\n     (coll? t1)\n     (coll? t2)\n     (= 3 (count t1))\n     (= 3 (count t2))\n     (= (first t1) (first t2))\n     (symmetric? (second t1) (last t2))\n     (symmetric? (last t1) (second t2))))))", "user": "5af3aa42e4b0cc2b61a3bc8c"}, {"problem": 96, "code": "(fn ts [t]\n (let [flip (fn flip [t]\n        (if-let [[tr l r] t]\n          [tr (flip r) (flip l)]\n          t))]\n    (= t (flip t))))", "user": "570d0548e4b0b0fb43fd06d2"}, {"problem": 96, "code": "(fn symtree? [[root1 l1 r1 :as t1] & rest]\n  (if (nil? rest)\n    (symtree? l1 r1)\n    (let [[[root2 l2 r2]] rest]\n      (and (= root1 root2)\n           (or (and (nil? l1) (nil? r2))\n               (symtree? l1 r2))\n           (or (and (nil? l2) (nil? r1))\n               (symtree? l2 r1))))))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 96, "code": "(fn sym-root? [node] ;assume a well-formed binary tree\n    (letfn [(sym-trees? [one two]\n              (or\n                  (= one two nil)\n                  (and\n                       (not (nil? one))\n                       (not (nil? two))\n                       (= (first one) (first two))\n                       (sym-trees? (nth one 1) (nth two 2))\n                       (sym-trees? (nth one 2) (nth two 1)))))]\n      (sym-trees? (nth node 1) (nth node 2))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 96, "code": "(fn symmetric? [[_ l r]]\n\t(letfn [(walk [node order] (map first (tree-seq #(not (nil? %)) #(order (rest %)) node)))]\n\t\t(= (walk l identity) (walk r reverse))\n\t))", "user": "5b7bc82ce4b047b03b203726"}, {"problem": 96, "code": "(let [tree?\n      (fn tree? [[v l r :as xs]]\n        (cond\n          (not= 3 (count xs)) false\n          (false? v) false\n          :else\n          (if-let [l? (if (sequential? l) (tree? l) (not (false? l)))]\n            (if (sequential? r) (tree? r) (not (false? r)))\n            false)))\n      mirror-seq\n      (fn mirror-seq [[v l r]]\n        [v\n         (if (sequential? r) (mirror-seq r) r)\n         (if (sequential? l) (mirror-seq l) l)])]\n  (fn [xs]\n    (if (tree? xs)\n      (-> xs second mirror-seq (= (nth xs 2)))\n      false)))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5ba947bfe4b0a20761a23440"}, {"problem": 96, "code": "(fn c [[b [bl ll rl :as l] [br lr rr :as r]]] (if (and (sequential? l)\n                                                       (sequential? r))\n                                                (and (= bl br) (c [nil ll rr]) (c [nil rl lr]))\n                                                (= l r)))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 96, "code": "(fn symetrical [tree]\n    (let [value (fn [node]\n        (first node))\n      left (fn [node]\n        (first (rest node)))\n      right (fn [node]\n        (second (rest node)))\n      isMirror (fn isMirror [node1 node2]\n        (cond\n          (= node1 node2 nil) true\n          (or (= node1 nil) (= node2 nil) (not (= (value node1) (value node2)))) false\n          :else (and \n                  (isMirror (left node1) (right node2))\n                  (isMirror (right node1) (left node2)) \n                )))]\n      (isMirror tree tree)\n    )\n  )", "user": "5bbbce0ee4b0a20761a2360d"}, {"problem": 96, "code": "; lol i did this wayyyyy too complicated xD\n(fn symm? [[_ a b]]\n    (letfn\n      [(mn? [a b]\n         (println a b)\n         (cond\n           (every? nil? [a b]) true\n           (and\n            (every? coll? [a b])\n            (apply = (map first [a b]))\n            (every? true?\n              (map mn?\n                 (first (map rest [a b]))\n                 (reverse (second (map rest [a b])))))) true\n           :else false))]\n          ;(map #(apply mn? %)\n          ;     [[(first a) (second b)]\n          ;      [(first b) (second a)]])))]\n      (mn? a b)))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 96, "code": "(fn [[a b c]]\n  (let [flp (fn flp [[x y z]] (if (nil? x) nil [x (flp z) (flp y)]))]\n    (= b (flp c)) ))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5bbbba29e4b0a20761a23609"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5b9c4a7be4b0c0b3ffbd4b16"}, {"problem": 96, "code": "(fn symmetric?\n  [my-seq]\n  (letfn [(mirrow-binary-tree [my-seq]\n            (if (coll? my-seq)\n              (let [value\n                    (first my-seq)\n\n                    left\n                    (second my-seq)\n\n                    right\n                    (last my-seq)]\n                [value (mirrow-binary-tree right) (mirrow-binary-tree left)]\n                )\n              my-seq))]\n    (= (second my-seq) (mirrow-binary-tree (last my-seq)))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 96, "code": "(fn bsym\n  ([t] (bsym (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (bsym (second a) (last b))\n                  (bsym (last a) (second b)))\n             false))))", "user": "5bc255b7e4b07a9b28b10029"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5bc50870e4b07a9b28b10069"}, {"problem": 96, "code": "(fn s [[_ [x xl xr]\n          [y yl yr]]]\n  (and (= x y)\n       (or (= nil xl yl)\n           (and\n             (s [_ xl yr])\n             (s [_ xr yl])))))", "user": "54ca35c6e4b057c6fda3a254"}, {"problem": 96, "code": "(fn is-symmetric?\n  [[_ L R]]\n  (if (not (coll? L))\n    true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (and (= LV RV) (is-symmetric? [LV LL RR]) (is-symmetric? [RV RL LR]))\n        ))\n    )\n  )", "user": "5bc8c033e4b07a9b28b100ca"}, {"problem": 96, "code": "(fn beauty\n    ([[val1 left right]]\n     (beauty left right))\n    ([[val1 left1 right1] [val2 left2 right2]]\n     (if (or (nil? val1) (nil? val2))\n       (and (nil? val1) (nil? val2))\n       (and (= val1 val2) (beauty left1 right2) (beauty right1 left2)))))", "user": "5bbbce99e4b0a20761a23610"}, {"problem": 96, "code": "#(if (= ((fn symmetric\n        [[dad lson rson :as t]] \n        (when t [dad (symmetric rson) (symmetric lson)])) %) %)\n   true\n   false)", "user": "5bbc0ddfe4b0a20761a2361e"}, {"problem": 96, "code": "(fn symmetry\n  [tree]\n    (let [right (second tree)\n        left (last tree)\n        walk (fn walk [left right]\n               (let [rol (first left)\n                     ll (second left)\n                     rl (last left)\n                     ror (first right)\n                     lr (second right)\n                     rr (last right)]\n                 (cond\n                   (and (sequential? left) (sequential? right)) ;ambos son arreglos\n                   (and (= rol ror) (walk ll rr) (walk lr rl)) ;compara a los padres. y hace llamadas recursivas en espejo\n                   :else (= right left) ;compara hojas\n                   ))\n               )\n        ]\n    (walk right left)))", "user": "5bbbcf9ee4b0a20761a23614"}, {"problem": 96, "code": "#(= ((fn symmetry [[n l r :as tree]] (when tree [n (symmetry r) (symmetry l)]))\n     %) \n    %)", "user": "5bbbce70e4b0a20761a2360f"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5bbbce60e4b0a20761a2360e"}, {"problem": 96, "code": "#(= ((fn func [[n l r :as tree]] (when tree [n (func r) (func l)])) %) %)", "user": "5bc7ba68e4b07a9b28b100b0"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5a99c5a9e4b0d174b936c7b1"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5bbbcf3ae4b0a20761a23612"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5bcb672ee4b07a9b28b10100"}, {"problem": 96, "code": "#(= \n\t(\n\t\t(fn flip [[nod lft rght :as t]] \n\t\t\t(when t [nod (flip rght) (flip lft)])\n\t\t) %\n\t) \n\t%\n)", "user": "5bbbd484e4b0a20761a23617"}, {"problem": 96, "code": "(fn sym-tree? [root]\n   (letfn [(traverse [r lb rb]\n             ((fn it [t]\n                (if (sequential? t)\n                  (concat [(first t)] (it (lb t)) (it (rb t)))\n                  [t])) r))]\n     (= (traverse root second last)\n        (traverse root last second))))", "user": "543a8256e4b032a45b869327"}, {"problem": 96, "code": "( fn symmetric [t1 & t2]\n  (if t2\n    (and\n        (= (first t1) (first (first t2)))\n        (or\n          (nil? (first t1))\n          (and\n            (symmetric (second t1) (last (first t2)))\n            (symmetric (last t1) (second (first t2)))\n          )\n        )\n    )\n    (symmetric (second t1) (last t1))\n  )\n)", "user": "5bbd13a5e4b07a9b28b0ff95"}, {"problem": 96, "code": "(fn issym [[v l r]]\n  (let [inv-t (fn inv-t [x] (when (seq x)(let [[a b c] x] (list a (inv-t c) (inv-t b)))))]\n    (= l (inv-t r))))", "user": "5bc833a5e4b07a9b28b100bb"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(reverse-branches [tree]\n            (let [[root & branches] tree]\n              (into [] (concat [root] (map #(if % (reverse-branches %)) (reverse branches))))))]\n  (let [[root left-branch right-branch] tree]\n    (if (= left-branch (if right-branch (reverse-branches right-branch))) true false))))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 96, "code": "(fn [t] (letfn [(mir [[n l r]] (when n [n (mir r) (mir l)]))] (= t (mir t))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 96, "code": "(let [reflect (fn reflect [tree]\n                (if (nil? tree)\n                  tree\n                  (let [[v l r] tree]\n                    [v (reflect r) (reflect l)])))]\n  (fn [[_ l r]] (= l (reflect r))))", "user": "5bab5440e4b0a20761a23475"}, {"problem": 96, "code": "#(= (second %)\n        ((fn stree [xs]\n           (if (coll? xs)\n             [(first xs) (stree (last xs)) (stree (second xs))]\n             xs)\n           )(last %)) )", "user": "5be0306be4b0ed4b8aab4c7d"}, {"problem": 96, "code": "(fn [[_ a b]]\n    (= a ((fn f [[x y z]] (if x [x (f z)(f y)])) b)))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 96, "code": "(fn[[i l r]](=((fn R[n](when-let[[i l r]n][i(R r)(R l)]))l)r))", "user": "50e5bca5e4b09ae9427b0e75"}, {"problem": 96, "code": "(fn [tree]\n    (let [f (fn f [tree]\n              (if (coll? tree)\n                (let [a (first tree)\n                      b (first (rest tree))\n                      c (first (rest (rest tree)))]\n                  [a (f c) (f b)])\n                tree))]\n      (= tree\n         (f tree))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "575f6a80e4b08062f99a4e80"}, {"problem": 96, "code": "(fn symtree [t]\n  (letfn [(subtree [left right]\n            (if (and (coll? left) (coll? right) (= (count left) 3) (= (count right) 3))\n              (and (= (nth left 0) (nth right 0))\n                   (subtree (nth left 1) (nth right 2))\n                   (subtree (nth left 2) (nth right 1)))\n              (and (nil? left) (nil? right))))]\n    (if (and (coll? t) (= (count t) 3))\n      (subtree (nth t 1) (nth t 2))\n      true)))", "user": "5be58beae4b0ed4b8aab4d14"}, {"problem": 96, "code": "(fn [x]\n(letfn [(mrr [x] (let [a (first x) aa (rest x) b (first aa) c (second aa)]\n(cond (seq? x) (list a (mrr c) (mrr b))\n      (vector? x) [a (mrr c) (mrr b)]\n      :else x)\n)     \n)\n        ] (= (mrr (second x)) (second (rest x)))\n))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 96, "code": "(fn [form]\n  (letfn [(mirror [form]\n            (case (count form)\n              0\n              form\n              1\n              form\n              3\n              [(first form) (mirror (nth form 2)) (mirror (nth form 1))]))]\n    (= (mirror form) form)))", "user": "58637f03e4b0f14aab7c881e"}, {"problem": 96, "code": "(fn bar [t]\n  (let [foo (fn foo [t]\n            (if (or (not (= (count t) 3)) (nil? t))\n              nil\n              (if (and (nil? (first (rest t))) (nil? (first (rest (rest t)))))\n                  (vec t)\n                  (vec (concat [(first t)] (reverse [(foo (first (rest t))) (foo (first (rest (rest t))))])))\n              ) \n            )\n          )\n  ]\n    (= (first (rest t)) (foo (first (rest (rest t)))))\n  )\n)", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 96, "code": "#((fn left=right? [l r]\n     (cond\n       (and (nil? l) (nil? r)) true\n       :else (and\n              (= (first l) (first r))\n              (left=right? (nth l 1) (nth r 2))\n              (left=right? (nth l 2) (nth r 1)))))\n   (nth % 1) (nth % 2))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 96, "code": "(fn [root]\n  (letfn [(tree? [root]\n            (if-let [[v l r] root]\n              (let [pred #(or (nil? %) (and (coll? %) (tree? %)))]\n                (and\n                  (= 3 (count root))\n                  (not (coll? v))\n                  (pred l)\n                  (pred r)))))\n          (sym [l r]\n            (if (and (tree? l) (tree? r))\n              (let [[lv ll lr] l\n                    [rv rl rr] r]\n                (when (= lv rv)\n                  (and\n                    (sym ll rr)\n                    (sym rl lr))))\n              (= l r)))]\n  (boolean\n   (when (tree? root)\n     (sym (second root) (nth root 2))))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 96, "code": "(fn tree-symetric? [tree]\n  (let [mirror-tree (fn mirror [t]\n                      (if-not (nil? t)\n                        [(first t) (mirror (last t)) (mirror (second t))]))]\n    (= (second tree) (mirror-tree (last tree)))))", "user": "5c03e927e4b0bdcf453d167b"}, {"problem": 96, "code": "(fn mirror-tree? [root]\n  (letfn\n    [(mirror-tree [tree]\n      (if (nil? tree) nil\n      (list \n        (first tree)     \n        (mirror-tree (nth tree 2))\n        (mirror-tree (nth tree 1)))\n        ))]\n    (= (nth root 1) (mirror-tree (nth root 2)))))", "user": "5c01ba2ce4b0bdcf453d1656"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [[_ left right] tree\n        symmetric-pair (fn symmetric-pair [left-tree right-tree]\n                            (println left-tree)\n                            (println right-tree)\n                           (cond \n                              (and (nil? left-tree) (nil? right-tree)) true\n                              (or (nil? left-tree) (nil? right-tree)) false\n                              (not= (first left-tree) (first right-tree)) false\n                              :else (and (symmetric-pair (second left-tree) (nth right-tree 2))\n                                         (symmetric-pair (nth left-tree 2) (second right-tree)))))]\n    (symmetric-pair left right)))", "user": "5bf1b957e4b0a6d31fed216f"}, {"problem": 96, "code": "#(let [mirror (fn mirror [tree] (if (nil? tree) tree (list (first tree) (mirror (last tree)) (mirror (second tree)))))]\n  (= % (mirror %)))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 96, "code": "(fn compare? \n  ([t]\n   (compare? (first (rest t)) (second (rest t))))\n  ([l r]\n   (if (and (nil? l) (nil? r))\n     true\n     (if (or (not= (first l) (first r))\n             (not= (count l) 3)\n             (not= (count r) 3))\n       false\n       (let [[_ ll lr] l\n             [_ rl rr] r]\n         (if (and (= (first ll) (first rr))\n                  (compare? ll rr)\n                  (compare? lr rl))\n           true\n           false))))))", "user": "5b15ab32e4b0cc2b61a3be72"}, {"problem": 96, "code": "(fn  [a]\n  ((fn symmetry? [l r]\n    (if (or (= nil l r)\n            (and (= (first l) (first r))\n            \t(symmetry? (second l) (last r))\n            \t(symmetry? (last l) (second r))))\n      true\n      false)\n )\n (second a) (last a)))", "user": "5ac9c737e4b0e27600da77d2"}, {"problem": 96, "code": "(fn symmetric [tree]\n  (let [scalar? (complement sequential?)\n\tthird #(nth % 2)\n        match (fn match [left right]\n                (if (and (scalar? left) ;; If both are scalars, compare the value\n                         (scalar? right))\n                  (= right left)\n                  (if (or (scalar? left) ;; If only one's a scalar, it's not a match\n                          (scalar? right))\n                    false\n                    (and ;; Otherwise they're both sequences, so match those\n                     (= (first left) (first right)) ;; roots match\n                     (match (second left) (third right)) ; left left subtree matches right right subtree\n                     (match (third left) (second right)) ; right left subtree matches left right subtree\n                     ))))]\n    (match (second tree) (third tree))))", "user": "5bfa25fbe4b0bdcf453d15c8"}, {"problem": 96, "code": "(fn [node] (let [\n                 mirror2 (fn mirror2 [left right] (\n                                                   if(not (sequential? left))\n                                                          (= left right)\n                                                          (and (= (nth left 0) (nth right 0))\n                                                               (mirror2 (nth left 1) (nth right 2))\n                                                               (mirror2 (nth left 2) (nth right 1)))\n                                                   ))\n                 ]\n                 (mirror2 (nth node 1)(nth node 2))          \n                 ))", "user": "5c06f813e4b0bdcf453d16bc"}, {"problem": 96, "code": "(fn symmteric-tree?\n  [[root left-child right-child]]\n  (letfn [(mirror [[root left-child right-child]]\n            [root (if (nil? right-child) nil (mirror right-child))\n             (if (nil? left-child) nil (mirror left-child))])]\n    (= left-child (mirror right-child))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 96, "code": "#(letfn [(flip [[v l r :as n]]\n           (when n\n             [v (flip r) (flip l)]))]\n  (= % (flip %)))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 96, "code": "#(letfn [(m [[r l s]]\n            (if r\n              [r (m s) (m l)]))]\n         (= % (m %)))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 96, "code": "(fn symetric-tree2?\n  [sym]\n  (letfn\n    [(binary-tree?\n       [s]\n       (if\n         (and\n           (= (count s) 3)\n           (not (sequential? (first s)))\n           (or (nil? (second s)) (and (sequential? (second s)) (binary-tree? (second s))))\n           (or (nil? (nth s 2)) (and (sequential? (nth s 2)) (binary-tree? (nth s 2))))\n           )\n         true\n         false\n         )\n       )\n     (mirror-nodes\n       ([head n1 n2]\n        (vector head (if (sequential? n2) (apply mirror-nodes n2) n2) (if (sequential? n1) (mirror-nodes n1) n1))\n         )\n       ([node] (if (sequential? node) (apply mirror-nodes node) node))\n       )]\n\n    (if (and (binary-tree? sym) (= (second sym) (mirror-nodes (nth sym 2)))) true false))\n\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 96, "code": "(fn [node]\n  (letfn [(rev [n]\n               (cond\n                (nil? n) nil\n                :else [(first n) (rev (first (rest (rest n)))) (rev (first (rest n)))]))]\n    (= node (rev node))))", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 96, "code": "#(letfn [(is-tree? [_] (= 3 (count _)))\n            (make-mirror-tree [[root l r]]\n              [root\n               (if (is-tree? r)\n                 (make-mirror-tree r)\n                 r)\n               (if (is-tree? l)\n                 (make-mirror-tree l)\n                 l)]\n              )\n            (is-tree-symmetry? [[root l r]]\n              (= l (make-mirror-tree r)))\n            ]\n   (is-tree-symmetry? %)\n   )", "user": "5c17467fe4b01240ff5671df"}, {"problem": 96, "code": "(fn [t]\n  (= t\n     (clojure.walk/postwalk (fn [x]\n                              (if (sequential? x)\n                                (let [[v l r] x]\n                                  [v r l])\n                                x)) \n                            t)))", "user": "54df2609e4b024c67c0cf7a9"}, {"problem": 96, "code": "(fn sym-tree? [s]\n  (and ((fn tree? [s]\n          (if (= 3 (count s))\n            (every? #(or (nil? %) (and (sequential? %) (tree? %))) (rest s))\n            false)) s)\n       \n       (sequential? (second s)) (sequential? (nth s 2))\n       \n       ((fn mirrored? [[_ f1 l1 :as s1] [_ f2 l2 :as s2]]\n           (or (and (= s1 s2) (= 0 (count (filter sequential? s1)) (count (filter sequential? s2))))\n               (and\n                (or (and (sequential? f2) (= f1 l2)) \n                    (and (sequential? f1) (sequential? l2) (mirrored? f1 l2)))\n                (or (and (sequential? f1) (= f2 l1)) \n                    (and (sequential? f2) (sequential? l1) (mirrored? f2 l1))))))\n        (second s) (nth s 2))))", "user": "5b2689e3e4b063e2438bcc33"}, {"problem": 96, "code": "#((fn symm [[root1 l1 r1 :as left-branch] [root2 l2 r2 :as right-branch]]\n      (or (= nil left-branch right-branch)\n          (and (= root1 root2) (symm l1 r2) (symm l2 r1)))) % %)", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 96, "code": "(fn mirror? [[_ l r :as t]]\n  (cond (nil? t) true\n      (and (nil? l) (nil? r)) true\n      (nil? l) false\n      (nil? r) false\n      :else (let [[lname ll lr] l\n            \t  [rname rl rr] r]\n              (and (= lname rname)\n                   (mirror? [_ ll rr])\n                   (mirror? [_ lr rl])))))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 96, "code": "(fn issim \n  ([l r]\n   (if (and (empty? l) (empty? r)) \n     true\n     (let [[lval ll lr] l\n           [rval rl rr] r]\n       (if  (and (seq l) (seq r) (= lval rval))\n         (and (issim ll rr) (issim lr rl))\n         false))))\n  ([root]\n   (issim root root)))", "user": "5c195cb2e4b01240ff5671f7"}, {"problem": 96, "code": "#(let [first-child (fn [x] (first (rest x))) last-child (fn [x] (last x)) tree-to-seq (fn [n l-child r-child] (tree-seq (fn [x] (or (not (nil? (l-child x))) (not (nil? (r-child x))))) (fn [x] (filter (complement nil?) (conj [] (l-child x) (r-child x)))) n))] (every? true? (map (fn [x y] (= (first x) (first y))) (tree-to-seq (first (rest %)) first-child last-child) (tree-to-seq (last %) last-child first-child))))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (if (nil? tree) true)\n  (let [[v l r] tree\n        mirror? (fn mirror? [l r]\n                  (let [[lv ll lr] l\n                        [rv rl rr] r]\n                    (or (every? nil? [l r]) \n                        (and (= lv rv) \n                             (mirror? ll rr) \n                             (mirror? lr rl)))))]\n    (mirror? l r)))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 96, "code": "(fn mirror-image\n  [tree]\n  (letfn [(reverse-tree [t]\n                        (if (nil? t) t\n                                     (list (first t) (reverse-tree (nth t 2)) (reverse-tree (second t)))))]\n         (= (second tree) (reverse-tree (nth tree 2)))))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 96, "code": "(letfn [(mirror?\n          ([[val left right]] (mirror? left right))\n          ([[lval lleft lright :as left] [rval rleft rright :as right]]\n           (or (= nil left right)\n               (and (coll? left) (coll? right)\n                    (= lval rval) ; Same values\n                    (mirror? lleft rright)\n                    (mirror? lright rleft)))))]\n  mirror?)", "user": "5c3ec6dbe4b08cd430848e8a"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "53b0750fe4b047364c044483"}, {"problem": 96, "code": "#(letfn [(f [[v l r]] (when v [v (f r) (f l)]))] (= (f %) %))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 96, "code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "5c4e2b82e4b0f9f7a8770e93"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [[_ L R]]\n  (if (not (coll? L))\n    true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (and (= LV RV) (symmetric-tree? [nil LL RR]) (symmetric-tree? [nil RL LR]))\n\n        )\n      ))\n  )", "user": "5c48757fe4b0e06e1360a3c3"}, {"problem": 96, "code": "(fn symmetric-binary-tree? [tree]\n  (let [flip (fn flip [node] \n               (when-let [[value left right] node]   \n                 [value (flip right) (flip left)]))]\n    (= tree (flip tree))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 96, "code": "(fn tt \n  ([root]\n    (tt (second root) (last root)))\n  ([left right]\n    (let []\n      (cond\n        (and (nil? left) (nil? right))\n          true\n        (and (vector? right) (vector? left)) \n          (if (not= (first left) (first right))\n            false\n            (and (tt (second left) (last right))\n                (tt (last left) (second right)))\n          )\n        (or (vector? right) (vector? left))\n          false\n        :else \n          (= left right)\n      )\n    )\n  )\n)", "user": "5763818ae4b0994c1922fbc7"}, {"problem": 96, "code": "(fn\n  symmetric\n  [tree]\n  (->\n    tree\n    ((fn in-order-traverse[root]\n      (when\n        root\n        (concat\n          (in-order-traverse (second root))\n          (list (first root))\n          (in-order-traverse (last root))))) ,,,)\n    ((fn mirror?[s] (= (reverse s) s)) ,,,)))", "user": "5c6227fee4b0fca0c1622641"}, {"problem": 96, "code": "(fn [tree] (letfn [(mirror [t] (when-not (nil? t) (list (first t) (mirror (last t)) (mirror (second t)))))] (= tree (mirror tree))))", "user": "5c30d90de4b0d62ef62d9f22"}, {"problem": 96, "code": "(fn symm?\n  ([tree]\n   (symm? (nth tree 1)\n          (nth tree 2)))\n  ([t1 t2]\n   (cond\n     (or (nil? t1)\n         (nil? t2))\n     (= t1 t2)\n     :else\n     (and\n          (= (first t1)\n             (first t2))\n          (symm? (nth t1 1)\n                 (nth t2 2))\n          (symm? (nth t1 2)\n                 (nth t2 1))))))", "user": "5984e7dee4b021a7a535fe43"}, {"problem": 96, "code": "(fn [t]\n  (let [[_ l r] t\n        fl (fn f [s]\n             (if (not (coll? s)) s\n                 [(first s) (f (last s)) (f (second s))]))]\n    (= l (fl r))))", "user": "5b14475be4b0cc2b61a3be5a"}, {"problem": 96, "code": "(fn [tree]\n  (let [[node left right] tree]\n    (letfn [(f [tree]\n              (let [[node left right] tree]\n                (if (nil? tree)\n                  nil\n                  [node (f right) (f left)])))]\n      (= left (f right)))))", "user": "5c62979fe4b0fca0c162264c"}, {"problem": 96, "code": "#(let [z ((fn i [a c b] (concat [a] (if (coll? c) (i (first c) (last c) (second c)) [c]) (if (coll? b) (i (first b) (last b) (second b)) [b]))) (first (second %)) (last (second %)) (second (second %)))] (= z (flatten (last %))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 96, "code": "(fn is-sym? [[a b c]]\n  (letfn\n    [(swap [[a b c]]\n           [a (if (coll? c) (swap c) c)\n              (if (coll? b) (swap b) b)])]\n    (= b (swap c))))", "user": "540c54a7e4b0addc1aec6700"}, {"problem": 96, "code": "(fn issym [[node l r]]\n    (letfn [(tr [tree left]\n        (if (sequential? tree)\n            (let [[n l r] tree]\n                (if (= true left)\n                    (concat [n] (tr l left) (tr r left))\n                    (concat [n] (tr r left) (tr l left))\n                )\n            )\n            (if (= nil tree)\n                []\n                [tree]\n        )))]\n        (= (tr l true) (tr r false))\n    )\n)", "user": "5bfcdc52e4b0bdcf453d15f4"}, {"problem": 96, "code": "(fn [tree]\n   (let [nodes (fn [x] (if (coll? x) (filter identity [(second x) (first x) (last x)]) [x]))\n         fl (fn [x]\n              (loop [out [x]]\n                (let [n (apply concat (map nodes out))]\n                  (if (= (count n) (count out)) n (recur n)))))\n        eq (fn [x]\n             (loop [x x]\n               (cond\n                (empty? x) true\n                (not= (first x) (last x)) false\n                :else (recur (rest (butlast x)) ))))]\n   (eq (fl tree))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 96, "code": "(fn\n  [lst]\n  (let [inorder-lst ((fn inorder\n                       [lst]\n                       (if (nil? lst)\n                         '()\n                         (concat\n                           (inorder (second lst))\n                           (conj (inorder (last lst)) (first lst))))) lst)]\n    (= inorder-lst (reverse inorder-lst))))", "user": "5c706232e4b0fca0c162277e"}, {"problem": 96, "code": "(fn my-prob-96-sym-tree?\n  ([t] (my-prob-96-sym-tree? (second t) (last t)))\n  ([t1 t2] (or (and (nil? t1) (nil? t2))\n               (and (= (first t1) (first t2))\n                    (and (my-prob-96-sym-tree? (second t1) (last t2))\n                         (my-prob-96-sym-tree? (second t2) (last t1)))))))", "user": "55b28b57e4b01b9910ae296c"}, {"problem": 96, "code": "(fn [[head left right]] (let [t-f\n                                          (fn traverse [ex-f node] (if (not (coll? node)) node (map (partial traverse ex-f)\n                                                                                            (cons head (ex-f node)))))\n                                          l-r (fn [[head left right]] (vector head left right))\n                                          r-l (fn [[head left right]] (vector head right left))]\n                                      (= (t-f l-r left) (t-f r-l right))))", "user": "5c7bc0a5e4b0fca0c1622865"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c746c31e4b0fca0c16227c8"}, {"problem": 96, "code": "#(= ((fn symmetric [[n l r :as tree]] (when tree [n (symmetric r) (symmetric l)])) %) %)", "user": "5c70641de4b0fca0c162277f"}, {"problem": 96, "code": "#(letfn [(flip [x] (if (and (coll? x) (= (count x) 3)) (let [[v l r] x] [v (flip r) (flip l)]) x))] (= % (flip %)))", "user": "5b22d30ee4b08b1df1c36750"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c874389e4b048ec896c590e"}, {"problem": 96, "code": "(fn [x] (= (second x)\n           ((fn snd [x] \n              (if (coll? x)\n                (vector (first x) (snd (last x)) (snd (second x)))\n                x))\n            (last x))))", "user": "5c82db41e4b0c8042a70ce42"}, {"problem": 96, "code": "(fn is_sym_tree\n  ([sq] (is_sym_tree 0 sq))\n  ([x sq]\n   (if\n     (nil? sq)\n     nil\n     (if (or (not (sequential? sq)) (not= 3 (count sq)))\n       false\n       (let [right_side (is_sym_tree (if (= 0 x) 1 x) (second sq))\n             left_side (is_sym_tree (if (= 0 x) 2 x) (nth sq 2))]\n         (if (false? (and right_side left_side))\n           false\n           (cond (= 0 x) (= right_side left_side)\n                 (= 1 x) (concat [(first sq)] left_side right_side)\n                 (= 2 x) (concat [(first sq)] right_side left_side))\n           ))))))", "user": "5c76577ae4b0fca0c16227ea"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c7d947be4b0d597f478cab6"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c7c8c72e4b0d597f478ca96"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c706454e4b0fca0c1622780"}, {"problem": 96, "code": "#(= ((fn symetry [[n l r :as tree]] (when tree [n (symetry r) (symetry l)])) %) %)", "user": "5c7dad57e4b0d597f478caba"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c74b043e4b0fca0c16227ce"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c787131e4b0fca0c1622825"}, {"problem": 96, "code": "(fn [x]\n  (= ((fn sim [[o t y :as sseq]]\n        (when sseq\n          [o (sim y) (sim t)])) x) x))", "user": "5c7741dce4b0fca0c1622806"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5c75a830e4b0fca0c16227e0"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5c8860bce4b048ec896c5928"}, {"problem": 96, "code": "(fn symmetric?[t]\n\t(\n(fn eq? [t1 t2]\n\t(if (nil? t1)\n\t\t(nil? t2)\t\t\n\t\t(and ( = (first t1) (first t2))\n\t\t\t(and \n\t\t\t\t(eq? (second t1)(last t2) )\n\t\t\t\t(eq? (last t1)(second t2) )\n\t\t\t)\n\t\t)\n\t)\n) (second t) (last t))\n)", "user": "5c7d5463e4b0d597f478caa9"}, {"problem": 96, "code": "(fn [t]\n  (let [[root left right] t\n        recursive-reverse (fn rr [b] (if (nil? b) b (vector (first b) (rr (last b)) (rr (second b)))))]\n    (= left (recursive-reverse right))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 96, "code": ";#(letfn [(flat [x]\n;  (if (sequential? x)\n;    [(flat (second x)) (first x) (flat (last x))]\n;    x\n;    ))]\n;   (=(flatten(flat %))(reverse(flatten(flat %))))\n;   )\n\n;#(letfn [(flip [x]\n;  (if (sequential? x)\n;    [(first x) (flip (last x)) (flip (second x))]\n;    x\n;    ))]\n;   (=(flip %) %))\n\n;#(letfn [(flat [[x y z]]\n;    [(if(sequential? y) (flat y) y) x (if (sequential? z) (flat z) z)])]\n;   (=(flatten(flat %))(reverse(flatten(flat %))))\n;   )\n\n;#(letfn [(flip [[x y z]]\n;    [x (if(sequential? z) (flip z) z) (if (sequential? y) (flip y) y)])]\n;   (=(flip %) %)\n;   )\n\n#(letfn [(flip [[x y z]]\n               (when (or x y z)\n                 [x (flip z) (flip y)]))]\n               (=(flip %) %)\n   )", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 96, "code": "(fn check ([[v l r]]\n             (check l r))\n    ([[lv ll lr :as l-node] [rv rl rr :as r-node]]\n     (cond \n       (and (nil? l-node) (nil? r-node)) true\n       (and (nil? l-node) (not (nil? r-node))) false\n       (and (not (nil? l-node)) (nil? r-node)) false\n       (not= lv rv) false\n       :default (and (check ll rr) (check lr rl))\n       ))\n    )", "user": "57fc0719e4b0d3187e900987"}, {"problem": 96, "code": "(fn mirrors? [coll]\n  (= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) coll) coll))", "user": "5c86b769e4b0c8042a70ce9b"}, {"problem": 96, "code": "(fn sym\n  ([[v l r]] (sym l r))\n  ([[v1 l1 r1] [v2 l2 r2]]\n   (if (= nil v1 l1 r1 v2 l2 r2)\n     true\n     (and (= v1 v2) (sym l1 r2) (sym l2 r1)))))", "user": "55ed37ebe4b0121d4835fdd6"}, {"problem": 96, "code": ";; http://www.4clojure.com/problem/96 \n(fn symmetric-tree?\n  [coll]\n  (let [mirror? (fn mirror? [left-node right-node]\n                  (cond \n                    (and (not (coll? left-node)) (not (coll? right-node))) \n                    (= left-node right-node)\n                    \n                    (and (coll? left-node) (coll? right-node))\n                    (if (not= (first left-node) (first right-node))\n                      false\n                      (and  \n                       (= (first left-node) (first right-node))\n                       (mirror? (nth left-node 1) (nth right-node 2))\n                       (mirror? (nth left-node 2) (nth right-node 1))))\n                    \n                    :else false)\n                  )]\n    (mirror? (nth coll 1) (nth coll 2))\n     ))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 96, "code": "(fn [t]\n    (letfn [(mirror [[x l r :as t]]\n              (if (= nil t)\n                nil\n                [x (mirror r) (mirror l)]))]\n      (= t (mirror t))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 96, "code": "(fn [tree]\n   (let [[_ l r] tree\n         reverse-tree (fn reverse-tree [branch]\n                        (let [[start l r] branch\n                              f #(if (sequential? %) (reverse-tree %) %)]\n                          [start (f r) (f l)]))]\n     (= l (reverse-tree r))))", "user": "5c896f46e4b048ec896c5940"}, {"problem": 96, "code": "(fn [[_ r l]]\n    (letfn [(mirror [[v r l]]\n              [v\n               (if (sequential? l)\n                 (mirror l) l)\n               (if (sequential? r)\n                 (mirror r) r)])]\n      (= r (mirror l))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 96, "code": "(letfn\n  [(flip [tree] \n     (if (nil? tree) nil [(nth tree 0) (flip (nth tree 2)) (flip (nth tree 1))])      \n   )]\n  (fn [tree] (= (nth tree 1) (flip (nth tree 2))))\n)", "user": "543bb568e4b032a45b869334"}, {"problem": 96, "code": "(fn symtree? [[v lst rst]]\n  (letfn [(tflip [[v l r]]\n                [v (if (nil? r) nil (tflip r)) (if (nil? l) nil (tflip l))])]\n    (= lst (tflip rst))))", "user": "5cab33e7e4b048ec896c5c48"}, {"problem": 96, "code": "#(= %\n      ((fn revtree [[value left-value right-value]]\n         (vector\n           value\n           (when (not (nil? right-value)) (revtree right-value))\n           (when (not (nil? left-value)) (revtree left-value))\n           )\n         )\n        (vec %))\n      )", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 96, "code": "(fn [t] (let [f (fn m [t] \n                  (let [[n l r] t]\n                    (when t [n (m r) (m l)])))]\n          (= t (f t))))", "user": "5a5894d9e4b05d388ecb6c81"}, {"problem": 96, "code": "(fn sym-bt? [s]\n(let [[_ l r] s]\n  (letfn [(doit [lxs rxs]\n            (let [[la ll lr] lxs [ra rl rr] rxs]\n              (if (and (empty? lxs) (empty? rxs))\n                true\n                (and\n                 (= la ra)\n                 (if (coll? ll) (doit ll rr) (= ll rr))\n                 (if (coll? lr) (doit lr rl) (= lr rl))))))]\n    (doit l r))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 96, "code": "(fn f[[_ n1 n2]]\n  (letfn [(reverse-node [[a b c :as coll]] \n    (cond\n      (coll? coll) (vector a (reverse-node c) (reverse-node b))\n      :else coll))]\n  (= n1 (reverse-node n2))))", "user": "5afb3426e4b0cc2b61a3bcf5"}, {"problem": 96, "code": "(fn is-bt-bal? [t]\n  (let [mbt (fn mirror-bt [t]\n              (if (coll? t)\n                (let [[v l r] t]\n                  [v (mirror-bt r) (mirror-bt l)])))]\n    (= t (mbt t))))", "user": "5c547cf0e4b0fb8c5ffd9a0b"}, {"problem": 96, "code": "(fn symm?[tree]\n  (letfn [(mirror[t]\n            (let [parent (first t) left   (second t) right  (last t)]\n              (list parent\n                    (if (sequential? right) (mirror right) right)\n                    (if (sequential? left)  (mirror left) left))))]\n    (= (last tree) (mirror (second tree)))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 96, "code": "(fn is-symmetric\n  ([[_ l r]]\n   (is-symmetric l r))\n  ([[e1 l1 r1] [e2 l2 r2]]\n   (if (or e1 e2)\n     (and (= e1 e2)\n          (is-symmetric l1 r2)\n          (is-symmetric l2 r1))\n     true)))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 96, "code": "(let [left (atom []) right (atom [])]\n  \n  (letfn [(iol [node] (when (vector? node)\n                        (swap! left conj (first node))\n                        (iol (second node))\n                        (iol (last node))))\n          (ior [node] (when (vector? node)\n                        (swap! right conj (first node))\n                        (ior (last node))\n                        (ior (second node))))]\n    \n    (fn [root]\n      (iol (if (second root) (vec (second root)) (second root)))\n      (ior (if (last root) (vec (last root)) (last root)))\n      (= @left @right))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 96, "code": "(fn recrev= [a]\n  (letfn [(recreverse [x]\n                      (if (coll? x)\n                        (cons \n                         (first x) \n                         (reverse (map recreverse (rest x))))\n                        x))]\n    (= (second a) (recreverse (last a)))))", "user": "5766bab8e4b0a07e8fc180b1"}, {"problem": 96, "code": "#(letfn [(has-children? [child]\n            (boolean\n             (and (coll? child)\n                  (let [[_ l r] child] (or l r)))))\n\n          (mirror [node]\n            (if (has-children? node)\n              (let [[d l r] node]\n                ;; swap positions of r and l, recursively\n                [d (mirror r) (mirror l)])\n              node))\n\n          (is-symmetric? [node]\n            (if (has-children? node)\n              (let [[d l r] node]\n                (= l (mirror r)))))]\n\n    (is-symmetric? %))", "user": "51e3a549e4b0c611d6113e47"}, {"problem": 96, "code": "(fn simmetric?\n  [tree]\n  (letfn [(left-child [node] (second node))\n          (right-child [node] (last node))\n          (value [node] (first node))\n          (are-simmetric? [node-1 node-2]\n            (or (= nil node-1 node-2)\n              (and (= (value node-1) (value node-2))\n                  (are-simmetric? (left-child node-1) (right-child node-2))\n                  (are-simmetric? (right-child node-1) (left-child node-2)))))]\n    (or (nil? tree)\n        (and (= (value (left-child tree))\n                (value (right-child tree)))\n             (are-simmetric? (left-child tree) (right-child tree))))))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 96, "code": "(fn is-symmetric-tree [s]\n\n   (letfn [(branch-eq [left right]\n            (or\n             (and (nil? left) (nil? right))\n             (and \n              (sequential? left)\n              (sequential? right)\n              (= (first left) (first right))\n              (branch-eq (second left) (nth right 2 nil))\n              (branch-eq (nth left 2 nil) (second right)))))]\n     (branch-eq (second s) (nth s 2 nil))\n     )\n    \n   )", "user": "5ce2b15fe4b0a17bb84e2b2c"}, {"problem": 96, "code": "#((fn eq [t1 t2]\n  (cond (= t1 nil) (= t2 nil)\n        (= t2 nil) (= t1 nil)\n        (= (first t1) (first t2)) (and (eq (second t1) (nth t2 2)) (eq (nth t1 2) (second t2)))\n        :else false)) (second %) (nth % 2))", "user": "592bb806e4b072a2710fcf46"}, {"problem": 96, "code": "(fn\n   [[root left right]]\n   (let [arr1 (new java.util.ArrayList) arr2 (new java.util.ArrayList)]\n     (clojure.walk/prewalk (fn [x] (.add arr1 x) x) left)\n     (clojure.walk/postwalk (fn [x] (.add arr2 x) x) right)\n     (= (map #(if (sequential? %) (first %) %) (filter #(or (nil? %) (sequential? %)) arr1))\n        (reverse (map #(if (sequential? %) (first %) %) (filter #(or (nil? %) (sequential? %)) arr2))))\n     )\n   )", "user": "5ce62d8ee4b0a17bb84e2b83"}, {"problem": 96, "code": "(fn [col]\n  (letfn [(swap-leaves [col]\n            (vector (first col) (last col) (second col)))\n          (swap-tree [col]\n            (let [fst (first col) sec (second col) lst (last col)]\n              (swap-leaves\n                (vector\n                  fst\n                  (if (coll? sec) (swap-tree sec) sec)\n                  (if (coll? lst) (swap-tree lst) lst)))))\n          (non-swap-tree [col]\n            (let [fst (first col) sec (second col) lst (last col)]\n              (vector\n                fst\n                (if (coll? sec) (non-swap-tree sec) sec)\n                (if (coll? lst) (non-swap-tree lst) lst))))]\n    (= (swap-tree (second col)) (non-swap-tree (last col)))))", "user": "5cdda90ce4b05ee0cb311766"}, {"problem": 96, "code": "(fn [tree]\n  (= (second tree)\n     (\n      (fn mirror [tree]\n        (if (nil? tree) nil (list (first tree) (mirror (last tree)) (mirror (second tree))))\n      ) (last tree)\n     )\n  )\n)", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5964f9b0e4b069c0a1a19778"}, {"problem": 96, "code": "(fn [root]\n    (letfn [(check- [r1 r2]\n                    (cond\n                     (and (nil? r1) (nil? r2)) true\n                     (or (not= (first r1) (first r2))\n                         (and (nil? r1) (not (nil? r2))\n                         (and (nil? r2) (not (nil? r1))))) false\n                     :else (and (check- (nth r1 1) (nth r2 2)) (check- (nth r1 2) (nth r2 1)))))]\n            (check- (nth root 1) (nth root 2))))", "user": "5cee521ce4b0aaa82f1129dd"}, {"problem": 96, "code": "(fn sym? [coll]\n  ((fn inner [left right]\n     (or (and(not (coll? left))(= left right))\n         (and (coll? left)\n              (coll? right)\n              (= (first left)(first right))\n              (inner (second left)(last right))\n              (inner (last left)(second right)))))\n    (second coll)(last coll)))", "user": "5ca1c45ae4b048ec896c5b85"}, {"problem": 96, "code": "(fn [[t left right]]\n  (= left (clojure.walk/postwalk\n           (fn [n] (if (coll? n)\n                     (let [[k l r] n] [k r l])\n                     n))\n           right)))", "user": "54236ce1e4b01498b1a71ad1"}, {"problem": 96, "code": "(fn [tree]\n  (= (map first (tree-seq coll? rest tree))\n     (map first (tree-seq coll? (comp reverse rest) tree))))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] \n       (when tree [n (mirror r) (mirror l)])) %) \n    %)", "user": "5cd4e1b2e4b0ccb061962927"}, {"problem": 96, "code": "(fn symmetric?\n  [[_\n    [v1 r1 l1]\n    [v2 r2 l2]]]\n  (and (= v1 v2)\n    (or (= nil r1 r2)\n        (and\n          (symmetric? [_ r1 l2])\n          (symmetric? [_ r2 l1])))))", "user": "5d110abee4b02c15ef021983"}, {"problem": 96, "code": "(fn [tree]\n   (letfn [(mirror-tree? [t1 t2]\n             (if (and (nil? t1)\n                   (nil? t2))\n               true\n               (let [[key1 left1 right1] t1\n                     [key2 left2 right2] t2]\n                 (if (not= key1 key2)\n                   false\n                   (and\n                     (mirror-tree? left1 right2)\n                     (mirror-tree? left2 right1))))))]\n     (let [[_ left right] tree]\n       (mirror-tree? left right))))", "user": "5a03d246e4b01bb0ae8afd8c"}, {"problem": 96, "code": "#(letfn [(mir? [l r]\n          (or (and (nil? l) (nil? r))\n              (let [[v l s] l\n                    [w n t] r]\n                (and (= v w)\n                     (mir? l t)\n                     (mir? n s)))))]\n  (or (nil? %)\n      (mir? (nth % 1) (nth % 2))))", "user": "5357b241e4b04ce2eb3ed282"}, {"problem": 96, "code": "(fn tree-symetric? [[head left right]]\n  ((fn compare-trees [[lhead llsub lrsub] [rhead rlsub rrsub]]\n     (if (= lhead rhead nil)\n       true\n       (and (= lhead rhead)\n            (compare-trees llsub rrsub)\n            (compare-trees lrsub rlsub))\n       )) left right))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 96, "code": "(fn sym-tree [tree1]\n  (letfn [(trees-eq [atree btree]\n            (cond (or (not (sequential? atree)) (not (sequential? btree))) (= atree btree)\n                       true (and (= (first atree) (first btree))\n                                 (and (trees-eq (second atree) (nth btree 2))\n                                       (trees-eq (nth atree 2) (second btree))))))]\n    (trees-eq (second tree1) (nth tree1 2))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 96, "code": "(fn sym-tree?\n  ([root]\n    (sym-tree? (nth root 1) (nth root 2)))\n  ([left right]\n   (if (and (nil? left) (nil? right))\n     true\n     (let [[l-val l-left l-right] left\n           [r-val r-left r-right] right]\n       (if (and (= l-val r-val) (sym-tree? l-left r-right) (sym-tree? r-left l-right))\n         true\n         false)))))", "user": "570c8ac3e4b0b0fb43fd06ca"}, {"problem": 96, "code": "(fn symmetric? [[r lt rt]]\n    (if (and (nil? lt) (nil? rt))\n      true\n      (let [[lr llt lrt] lt\n            [rr rlt rrt] rt]\n         (if (= lr rr)\n             (and (symmetric? [lr llt rrt]) (symmetric? [rr lrt rlt]))\n             false))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 96, "code": "(fn ss [t]\n  ((fn ss* [t1 t2]\n     (if (or (nil? (first t1)) (nil? (first t2)))\n       (= (first t1) (first t2))\n       (and (= (first t1) (first t2))\n            (ss* (nth t1 1) (nth t2 2))\n            (ss* (nth t1 2) (nth t2 1)))))\n    (nth t 1) (nth t 2)))", "user": "5012da69e4b0c8732600222d"}, {"problem": 96, "code": "(fn is-mirror-tree? [[_ l r]]\n  (letfn [(flip-node [[v l r]] (when v [v (flip-node r) (flip-node l)]))] \n    (= l\n       (flip-node r))))", "user": "5d272077e4b092dab7f59c64"}, {"problem": 96, "code": "(fn has-symmetree?\n    ([btree]\n     (has-symmetree? btree btree))\n    ([btree-1 btree-2]\n     (let [nil-1 (nil? btree-1)\n           nil-2 (nil? btree-2)\n           third #(nth % 2)]\n       (cond\n         (= btree-1 btree-2 nil)            true\n         (or (nil? btree-1) (nil? btree-2)) false\n         :default                           (and (= (first btree-1)\n                                                    (first btree-2))\n                                                 (has-symmetree? (second btree-1)\n                                                                 (third btree-2))\n                                                 (has-symmetree? (third btree-1)\n                                                                 (second btree-2)))))))", "user": "57f904c5e4b0d3187e900936"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(my-seqable? [x] (or (seq? x) (vector? x)))\n          (node-value [n] (if (my-seqable? n) (first n) n))]\n    \n    (= (map node-value\n            (tree-seq my-seqable? \n                      #(reverse (drop 1 %))\n                      (nth tree 2)))\n       \n       (map node-value\n            (tree-seq my-seqable? \n                      #(identity (drop 1 %))\n                      (second tree))))))", "user": "5d231255e4b02ea6f0fb69fe"}, {"problem": 96, "code": "(fn sym-tree?\n  ([tree] (sym-tree? (second tree) (last tree)))\n  ([sub1 sub2]\n   (let [[l-root l-left l-right] sub1\n         [r-root r-left r-right] sub2]\n     (cond\n       (not= (coll? sub1) (coll? sub2)) false\n       (coll? sub1) (and (= l-root r-root) (sym-tree? l-left r-right) (sym-tree? l-right r-left))\n       :else (= l-root r-root)))))", "user": "5d1c14cde4b02ea6f0fb698a"}, {"problem": 96, "code": "(fn [tree] (= \n            (map #(first %) (tree-seq coll? (comp reverse rest) (last tree)))\n            (map #(first %) (tree-seq coll? rest (second tree)))\n            ))", "user": "5abeb697e4b073f177442725"}, {"problem": 96, "code": "(fn isSymTree [node]\n  \t(let[flipTree\n\t\t(fn flip [x] (if (sequential? x) [(first x) (flip (last x)) (flip (second x))] x))\n\t\t]\n\t\t(=\t(second node) (flipTree (last node)))\n\t)\n)", "user": "5d2201b8e4b02ea6f0fb69ed"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r]] (when n [n (mirror r) (mirror l)])) %) %)", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 96, "code": "(fn [tree]\n ((fn mirror [a b]\n  (cond\n   (nil? a) (nil? b)\n   (nil? b) (nil? a)\n   :else (let [[a-k a-l a-r] a\n               [b-k b-l b-r] b]\n           (if (not= a-k b-k) false\n             (and (mirror a-l b-r)\n                  (mirror a-r b-l)))))) (nth tree 1) (nth tree 2)))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 96, "code": "(fn symmetry?\n  ([col] (symmetry? (second col) (last col)))\n  ([l r]\n   (if (and (nil? l) (nil? r))\n     true\n     (if (= (first l) (first r))\n       (and (symmetry? (second l) (last r)) (symmetry? (second r) (last l)))\n       false))))", "user": "5d321852e4b01671435dbce8"}, {"problem": 96, "code": "(fn [[d l r]]\n      (= l ((fn srt [[d l r :as root]]\n        (if (or (nil? root) (not (coll? root)))\n          root\n          [d (srt r) (srt l)])) r)))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 96, "code": "(fn s [[_ [x l r]\n           [y h m]]]\n  (and (= x y)\n       (or (= nil l h)\n           (and\n                (s [_ l m])\n                (s [_ h r])))))", "user": "5ccf99fbe4b0ccb0619628c8"}, {"problem": 96, "code": "(fn CompareTrees\n    ([L] (CompareTrees (second L) (last L) ) )\n    ([L1 L2]\n      ;;(println \"****\" L1 \" ! \" L2)\n      (let [ \n            [L1_Root L1_Left L1_Right ] L1\n            [L2_Root L2_Left L2_Right ] L2\n           ]\n        (cond\n          ;; \u0435\u0441\u043b\u0438 \u043a\u043e\u0440\u043d\u0438 \u043d\u0435 \u0440\u0430\u0432\u043d\u044b, \u0442\u043e \u043d\u0435 \u043d\u0430\u0448\u043b\u0438\n          (not= L1_Root L2_Root) false\n          ;; \u0435\u0441\u043b\u0438 \u0440\u0430\u0432\u043d\u044b, \u043d\u043e \u043e\u0431\u0430 nil, \u0442\u043e \u043d\u0430\u0448\u043b\u0438\n          (and (= L1_Root L2_Root) (nil? L1_Root)) true\n          ;; \u0432 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u043e \u0441\u043b\u0443\u0447\u0430\u0435, \u043e\u0431\u0435 \u0432\u0435\u0442\u0432\u0438 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0437\u0435\u0440\u043a\u0430\u043b\u044c\u043d\u043e \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u043c\u0438\n          :else \n          (and \n            (CompareTrees L1_Left L2_Right) \n            (CompareTrees L1_Right L2_Left))\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 96, "code": "(fn symetry?\n  [tree]\n  (= tree ((fn mirorr-tree\n             [[n l r :as tree]]\n             (when tree [n (mirorr-tree r) (mirorr-tree l)])) tree)))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 96, "code": "(fn\n  [[x l r]]\n  (letfn [(flip [[x l r :as t]]\n            (if (nil? t) nil [x (flip r) (flip l)]))]\n    (= l (flip r))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 96, "code": "(fn tree-mirror? [[val ltree rtree]]\n      (let [helper (fn helper [left right]\n                           (cond\n                             (and (nil? left) (nil? right)) true\n                             (and (coll? left) (coll? right))\n                             (let [[lv ll lr] left\n                                   [rv rl rr] right]\n                               (and (= lv rv)\n                                    (and (helper ll rr) (helper lr rl))\n)\n                               )\n                             :else false\n                             )\n                     )\n            ]\n        (helper ltree rtree)\n        )\n)", "user": "5ab07d63e4b073f1774425af"}, {"problem": 96, "code": "(fn mirror-tree? [x]\n  (letfn [(rev-children [[k l r]]\n            [k\n             (if (coll? r) (rev-children r))\n             (if (coll? l) (rev-children l))])]\n    (let [left (nth x 1)\n          right (nth x 2)]\n      (= left (rev-children right)))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 96, "code": "#((fn symtree? [l r] (or (and (nil? l) (nil? r)) (let [[lv ll lr] l [rv rl rr] r] (and (= lv rv) (symtree? ll rr) (symtree? lr rl))))) (second %) (last %))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 96, "code": "(fn [data]\n   (let [r-reverse (fn r-reverse [tree]\n                     (map\n                      (fn [x]\n                        (if (or (vector? x) (list? x))\n                          (r-reverse x)\n                          x))\n                      (cons (first tree ) (reverse (rest tree)))))\n         sorted (r-reverse (nth data 2))]\n     (= (nth data 1) sorted)))", "user": "59473563e4b07ddc2dafad97"}, {"problem": 96, "code": "(fn [root]\n  (letfn [(nodes [x] (map first (tree-seq coll? rest x)))\n          (swap [ls] (when (not (nil? ls)) (let [[f l r] ls] [f (swap r) (swap l)])))]\n    (= (nodes (first (rest root))) (nodes (swap (second (rest root)))))))", "user": "5d672bd7e4b0db5d338d15f1"}, {"problem": 96, "code": "(fn symmetric?\n  [tree]\n  (letfn [(flip\n            [t]\n            (when-let [[x l r] t]\n              [x (flip r) (flip l)]))]\n    (= tree (flip tree))))", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 96, "code": "(fn sym?\n  [t]\n  (let [[r left right] t]\n    (= right ((fn mirror\n                [t]\n                (if (coll? t)\n                  (let [[root left right] t]\n                    [root (mirror right) (mirror left)])\n                  t)) left))))", "user": "5d6691cee4b0db5d338d15e9"}, {"problem": 96, "code": "(fn sym [[k t1 t2]]\n   (or (and (= t1 nil) (= t2 nil))\n       (and (coll? t1) (coll? t2)\n            (= (first t1) (first t2))\n            (sym [k (second t1) (nth t2 2)])\n            (sym [k (second t2) (nth t1 2)]))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 96, "code": "#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))", "user": "5cb41c40e4b026601754b911"}, {"problem": 96, "code": "(fn [coll] (letfn [(mirror [[n l r]]\n                                         (vector n\n                                                 (if (sequential? r) (mirror r) r)\n                                                 (if (sequential? l) (mirror l) l)))]\n                                 (= (last coll) (last (mirror coll)))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 96, "code": "(fn [[r a b]]\n  (let [f (fn f [[q w e :as z]] (when z [q (f e) (f w)]))]\n    (= (f a) b)))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 96, "code": "(fn symmetry\n  ([[root left right]]\n   (symmetry left right))\n  ([l r]\n   (cond\n    (and (nil? l) (nil? r)) true\n    (or (nil? l) (nil? r)) false\n    :else (and (= (first l) (first r)) (symmetry (second l) (last r)) (symmetry (last l) (second r))))))", "user": "5be0b916e4b0ed4b8aab4c8f"}, {"problem": 96, "code": "(fn [tree] (let [\n                 doit\n                 (fn doit [node f s] (if (nil? node) [node] (concat [(nth node 0)] (doit (nth node f) f s) (doit (nth node s) f s))))\n                ]\n                (= (doit (nth tree 1) 1 2) (doit (nth tree 2) 2 1))\n           )\n)", "user": "5d6d2172e4b04d129b00f2b9"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(flip [[n l r]]\n            (when-not (nil? n)\n              [n (flip r) (flip l)]))]\n    (= left (flip right))))", "user": "5d24e49be4b02ea6f0fb6a2a"}, {"problem": 96, "code": "(fn [bt]\n  (let [f (fn f [x] (if (coll? x)\n                    (let [[h s1 s2] x]\n                      (list h (f s2) (f s1)))\n                    x))]\n    (if (= (f bt) bt)\n      true false)))", "user": "5cbd5b42e4b026601754b9f6"}, {"problem": 96, "code": "(letfn\n     [(rev [node]\n        (if (nil? node) node\n            (let [[n l r] node]\n              [n (rev r) (rev l)])))\n      (symmetric? [tree]\n        (let [[n l r] tree]\n          (= l (rev r))))]\n   symmetric?)", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 96, "code": "(fn [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5c51c930e4b0fb8c5ffd99ce"}, {"problem": 96, "code": "(fn symmetry? [[root left right]]\n  (letfn [(mirror? [a b]\n            (cond\n              (not= (sequential? a) (sequential? b))\n              false\n              (sequential? a)\n              (let [[root-a l-a r-a] a\n                    [root-b l-b r-b] b]\n                (and (= root-a root-b)\n                     (mirror? l-a r-b)\n                     (mirror? l-b r-a)))\n              :else\n              (= a b)))]\n    (mirror? left right)))", "user": "5cc80598e4b0ccb061962840"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5d88d820e4b0915913b1d3b1"}, {"problem": 96, "code": "(fn [[_ a b]]\n  (letfn [(reverse' [xs] (and xs (let [[root a b] xs] [root (reverse' b) (reverse' a)])))]\n    (= a (reverse' b))))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 96, "code": "(let\n      [compTrees (fn compTrees [t1 t2]\n                   (or\n                     (and (= nil (first t1)) (= nil (first t2)))\n                     (and (= (first t1) (first t2))\n                         (compTrees (second t1) (last t2))\n                         (compTrees (last t1) (second t2)))))]\n      #(compTrees (second %) (last %)))", "user": "5d887d27e4b0915913b1d3a8"}, {"problem": 96, "code": "(fn [[ro l r]] \n   ((fn mi? [a b]\n       (cond\n         (not=(coll? a)(coll? b)) false\n         (coll? a) (let [[roa la ra] a [rob lb rb] b] (and (= roa rob)(mi? lb ra)(mi? la rb)))\n         :else (= a b)))\n    l r)\n)", "user": "5951190be4b066ee0a44aea4"}, {"problem": 96, "code": "(let [mirror-tree (fn mirror-tree [coll]\n        (prn coll)\n        (cond\n          (not (coll? coll)) coll\n          :else [(first coll) (mirror-tree (nth coll 2)) (mirror-tree (second coll))]))]\n  (fn symmetric? [tree]\n    (= tree (mirror-tree tree))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 96, "code": "(fn [t] (letfn [(swap [[v c1 c2]]  (vector v (fif c2) (fif c1)) )\n                (fif [c] (if (coll? c) (swap c)))] \n        (= t (swap  t))\n))\n;(fn [t] (letfn [(swap [[v & cn]]  (cons v (->> cn reverse (map fif))) )\n;                (fif [c] (if (coll? c) (swap c)))] \n;        (= t  (swap  t))))\n;(fn [t] (= t ((fn swap [[v & children]] (cons v (->> children reverse (map #(if(coll? %) (swap %)))))) t)))", "user": "5d9e7971e4b000c986472bc1"}, {"problem": 96, "code": "(fn [[node left right]]\n  (letfn [(inorder [[node left right]] \n            (if (nil? node) \n              (vector node)\n              (concat (inorder left)\n                      [node]\n                      (inorder right))))]\n    (= (reverse (inorder left)) (inorder right))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [mirror-fn (fn mirror [tree]\n                    (if (nil? tree)\n                      nil\n                      (list (first tree)\n                            (mirror (last tree))\n                            (mirror (second tree)))))]\n    (= tree (mirror-fn tree))))", "user": "5d49ec5ee4b0776584bd6f1c"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 96, "code": "(fn [data]\n  (#(= (take (quot (count %) 2) %) (take (quot (count %) 2) (reverse %)))\n   (flatten ((fn reord [[a b c]]\n               [(if (coll? b) (reord b) b)\n                a\n                (if (coll? c) (reord c) c)]\n               ) data))))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 96, "code": "(fn fun [[x y z :as col]]\n  (cond\n    (and (coll? y) (coll? z)) \n      (and\n        (= (first y) (first z))\n        (fun (list :x (second y) (last z)))\n        (fun (list :x (second z) (last y)))\n      )\n    :else (and (= 3 (count col)) (= y z))\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 96, "code": "(fn sym-tree?\n  ([[_ left right]] (sym-tree? left right))\n  ([[root-1 left-1 right-1 :as left]\n    [root-2 left-2 right-2 :as right]]\n   (or (= nil left right)\n       (and (= root-1 root-2)\n            (sym-tree? left-1 right-2)\n            (sym-tree? left-2 right-1)))))", "user": "5d5166d9e4b0776584bd6f5e"}, {"problem": 96, "code": "(fn [x]\n  (letfn [(s [r l] \n            (cond\n              (and (nil? r) (nil? l)) true\n              (or (nil? r) (nil? l)) false\n              (or (not (coll? r)) (not (coll? l))) false\n              (not= (first r) (first l)) false\n              :else (and (s (second r) (second (rest l)))  (s (second (rest r)) (second l))))\n          )]\n    (s (second x) (second (rest x)))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5cf53196e4b087f62be35a94"}, {"problem": 96, "code": "(fn is-tree-symmetric [t]\n  (letfn\n    [(node-compare [ln rn]\n       (prn ln)\n       (prn rn)\n       (if (not= (first ln) (first rn))\n         false\n         (if (coll? ln)\n           (and\n             (node-compare (second ln) (last rn))\n             (node-compare (last ln) (second rn)))\n           true)))]\n    (node-compare (second t) (last t))))", "user": "5dc72a9ce4b02f9375f4e1cd"}, {"problem": 96, "code": "#(=\n  ;; between the flipped tree\n  ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %)\n  ;; and the tree itself\n  %)", "user": "5d64ecb2e4b0c9e5857d5036"}, {"problem": 96, "code": "(fn sym? [tree]\n  (let [[_ left right] tree]\n    (cond\n     (= nil left right) true\n     (or (nil? left) (nil? right)) false\n     :else (and (= (first left) (first right))\n                (sym? [nil (second left) (last right)])\n                (sym? [nil (second right) (last left)])))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 96, "code": "(fn [t]\n  (= t\n     ((fn mirror [t]\n       (if (nil? t) nil\n         (let [[v lt rt] t]\n           [v (mirror rt) (mirror lt)])))\n      t)))", "user": "5db5d09be4b010eb3c36cd31"}, {"problem": 96, "code": "(fn [coll]\n  (let [flip (fn f [node]\n               (if (coll? node)\n                 (let [v (first node)\n                       l (second node)\n                       r (last node)]\n                   [v (f r) (f l)])\n                 node))]\n    (= coll (flip coll))))", "user": "524a9556e4b05ef8e38e64b1"}, {"problem": 96, "code": "(fn [[v l r]]\n  (let [flip (fn flip [t] (if (nil? t) nil (let [[tv tl tr] t] (list tv (flip tr) (flip tl)))))]\n    (= l (flip r))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "59b1a1b2e4b0e1f4e384c8eb"}, {"problem": 96, "code": "(fn mirrored? [tree]\n\t(= tree\n\t\t((fn f [[n l r]]\n    \t\t(if (nil? n)\n\t\t\t\tnil\n\t\t\t\t[n (f r) (f l)]\n\t\t\t)\n\t\t) tree)\n\t)\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 96, "code": "#(letfn [(rev-tree [[v l r :as all]] (if (nil? all) nil [v (rev-tree r) (rev-tree l)]))]\n  (= % (rev-tree %)))", "user": "5dc98501e4b02f9375f4e1e6"}, {"problem": 96, "code": "(fn [x]\n  (letfn [(swappy [[n l r :as t]]\n            (if (nil? t)\n              nil\n              [n (swappy r) (swappy l)]))]\n    (= x (swappy x))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 96, "code": "(fn is-symmetric [tree]\n  (let [[node left right] tree\n        are-symmetric (fn are-symmetric [t1 t2]\n                        (if (= t1 nil)\n                          (if (= t2 nil)\n                            true)\n                          false)\n                        (if (= t2 nil)\n                          (if (= t1 nil)\n                            true\n                            false)\n                          (let [[n1 l1 r1] t1\n                                [n2 l2 r2] t2]\n                            (if (not (= n1 n2))\n                              false\n                              (and (are-symmetric l1 r2) (are-symmetric l2 r1))\n                              )\n                            )\n                          ))\n        ]\n    (are-symmetric left right)\n    )\n  )", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 96, "code": "#( = %   (   (fn s [x] (if (coll? x)  (    conj  (conj [(first x)] (s (last x)) )  (s (second x))         )  x                 )  )     %)   )", "user": "5dd69c8ce4b0948ae9d9ad83"}, {"problem": 96, "code": "(fn [[root l r :as a]]\n  (letfn [(mirror [[root l r :as a]]\n            (let [result (if root (into [] [root (when (seq r) (mirror r)) (when (seq l) (mirror l))]))]\n              (if (list? a) (list* result) result)))]\n    (= l (mirror r))))", "user": "5a66f358e4b0512ff01cd9d5"}, {"problem": 96, "code": "#(letfn [(mirror [[v l r :as t]]\n                 (if (nil? t)\n                   t\n                   [v (mirror r) (mirror l)]))]\n   (= % (mirror %)))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 96, "code": "(fn [[_ left right]]\n        (letfn [(mirror [[f s t]]\n                  (if (nil? f)\n                    nil\n                    [f (mirror t) (mirror s)]))]\n          (= left (mirror right))))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 96, "code": "(fn beauty-is-symmetry [s]\n  {:pre [(sequential? s)\n         (= (count s) 3)]}\n  (let [left (second s)\n        right (last s)\n        mirror (fn mirror [s] {:pre [(= (count s) 3)]}\n                 (let [left (second s)\n                       right (last s)]\n                   (if (and (nil? left) (nil? right))\n                     s\n                     (list\n                      (first s)\n                      (if (sequential? right) (mirror right) right)\n                      (if (sequential? left) (mirror left) left)))))]\n    (=\n     left\n     (if (sequential? right)\n       (mirror right)\n       right))))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 96, "code": "(fn [[v l r]]\n          (let [mirror? (fn mirror? [[v1 l1 r1 :as n1] [v2 l2 r2 :as n2]]\n                          (if (nil? n1)\n                            (= n1 n2)\n                            (and (= v1 v2) (mirror? l1 r2) (mirror? r1 l2))))]\n            (mirror? l r)))", "user": "4edd038c535d10e5ff6f5327"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(shfl [[t l r]] [t (if-not (nil? r) (shfl r)) (if-not (nil? l) (shfl l))])]\n    (= left (shfl right)))\n  )", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 96, "code": "(fn symmetric? [[t l r]]\n  (letfn\n    [(sym? [a b]\n       (cond\n         (not= (coll? a) (coll? b)) false\n         (coll? a) (let [[ta la ra] a\n                         [tb lb rb] b]\n                     (and (= ta tb) (sym? la rb) (sym? lb ra)))\n         :else (= a b)))]\n      (sym? l r)))", "user": "5dc9ccf8e4b02f9375f4e1f1"}, {"problem": 96, "code": "#(letfn [(flip [[v l r :as tree]]\n          (if (nil? tree) \n            nil\n            [v (flip r) (flip l)]))]\n  (= (second %) (flip (last %))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 96, "code": "(fn [initial-list]\n  ((fn check [l r] (or (and (nil? l) (nil? r)) (and (= (nth l 0) (nth r 0)) (check (nth l 1) (nth r 2)) (check (nth l 2) (nth r 1)))))\n   (nth initial-list 1) \n   (nth initial-list 2)\n   )\n  )", "user": "50f53694e4b057d4c52de881"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5dfb20b8e4b0a607a9a45cd3"}, {"problem": 96, "code": "(fn [[n [:as l] [:as r]]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n    (mirror? l r)))", "user": "5dfe3928e4b0a607a9a45d04"}, {"problem": 96, "code": "(fn symmetric? ( [[node left right]] (symmetric? left right))\n  ([[nl ll lr] [nr rl rr]] (if (and  (nil? nl) (nil? nr))\n                             true\n                            (if (not (= nl nr))\n                               false\n                                (and (symmetric? ll rr) (symmetric? lr rl))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 96, "code": ";#(= ((fn dfs [coll]\n;        (when coll [(first coll) (dfs (second coll)) (dfs (last coll)) ])) %) %)\n#(= ((fn dfs [[n l r :as tree]]\n        (when tree [n (dfs r) (dfs l)])) %)%)", "user": "5dfa1c67e4b0a607a9a45cc5"}, {"problem": 96, "code": "(fn p-96-2 [t]\n  (let [swappy\n        (fn swappy [t]\n          (if (not (sequential? t)) t\n              [(first t) (swappy (nth t 2)) (swappy (nth t 1))]))]\n    (= t (swappy t))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 96, "code": "(fn symmetry?\n  ([tree]\n   (symmetry? tree tree))\n  ([tree1 tree2]\n   (println tree1 tree2)\n   (if (not (sequential? tree1))\n     (= tree1 tree2)\n     (and (= (first tree1) (first tree2))\n          (= (count tree1) 3)\n          (= (count tree2) 3)\n          (symmetry? (second tree1) (last tree2))\n          (symmetry? (last tree2) (second tree1))))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 96, "code": "(fn [in]\n  (letfn [(bf [& root]\n    (when (seq root)\n          (cons (map first root)\n                  (apply bf (mapcat rest root)))))]\n  (every? #(= % (reverse %))  (bf in))))", "user": "5e03a15be4b0a607a9a45d5e"}, {"problem": 96, "code": "#(letfn [(mirror [n1 n2] (if (= nil n1 n2) true (let [[v1 l1 r1] n1 [v2 l2 r2] n2] (if (= v1 v2) (and (mirror l1 r2) (mirror l2 r1)) false))))]\n  (mirror %1 %1))", "user": "5b857411e4b047b03b2037ce"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (let [mirror (fn mirror [[value left right]]\n                 (if (nil? value)\n                   value\n                   [value (mirror right) (mirror left)]))\n        mirrored (mirror tree)]\n    (= tree mirrored)))", "user": "5e0e14bde4b099d064962fa3"}, {"problem": 96, "code": "#(letfn [(mirror [x] \n                 (if (sequential? x) \n                   [(first x) (mirror (last x)) (mirror(second x))] \n                   x))] \n   (= (second %) (mirror (last %))))", "user": "5ddd6cfae4b0948ae9d9adc4"}, {"problem": 96, "code": "(fn sym-tree [t]\n  (let [mirror?  (fn mirror? [t1 t2]\n                   (if (and (nil? t1) (nil? t2)) true\n                       (and (= (nth t1 0) (nth t2 0))\n                            (mirror?  (nth t1 1) (nth t2 2))\n                            (mirror?  (nth t2 1) (nth t1 2)))))]\n    (mirror? (nth t 1) (nth t 2))))", "user": "5793931ee4b0e215f87e845c"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5defc177e4b093ff717275af"}, {"problem": 96, "code": "(fn [coll]\n  (= \n    ((fn mirror [[n l r :as tree]] \n        (when tree [n (mirror r) (mirror l)])\n        ) coll)\n    coll))", "user": "5df75fd8e4b0a607a9a45c92"}, {"problem": 96, "code": "(fn [[one two three]]\n  ((fn sym-tree?\n  [x y]\n  (if (and (nil? x) (nil? y))\n    true\n    (if (not (and (coll? x) (coll? y)))\n      false\n      (and (= (first x) (first y))\n           (sym-tree? (second x) (last y))\n           (sym-tree? (last x) (second y))\n           )))) two three))", "user": "5e207f12e4b05b4b01516112"}, {"problem": 96, "code": "(fn sym? \n    ([root] \n         (sym? (second root)(last root)))\n     ([t u]\n      (or \n          (= [nil nil][t u]) \n          (and \n              (= (first t)(first u)) \n              (sym? (last u) (second t)) \n              (sym? (second u)(last t))))))", "user": "5e042dede4b0a607a9a45d69"}, {"problem": 96, "code": "(fn mirror? [[r left right]]\n    (= left ((fn step [n]\n               (if-not (coll? n) n\n                       (let [[v l r] n]\n                         [v (step r) (step l)]))) right)))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 96, "code": "(fn [s]\n   {:pre [(sequential? s)\n          (= (count s) 3)]}\n   (let [left (second s)\n         right (last s)\n         mirror (fn mirror [s] {:pre [(= (count s) 3)]}\n                  (let [left (second s)\n                        right (last s)]\n                    (if (and (nil? left) (nil? right))\n                      s\n                      (list\n                        (first s)\n                        (if (sequential? right) (mirror right) right)\n                        (if (sequential? left) (mirror left) left)))))]\n     (=\n       left\n       (if (sequential? right)\n         (mirror right)\n         right))))", "user": "57fc5e42e4b0d3187e900997"}, {"problem": 96, "code": "(fn f [c]\n           (if (nil? (first c))\n             true\n             ((fn f [l r]\n                (if (and (sequential? l) (sequential? r))\n                  (if (and (f (nth l 1) (nth r 2))\n                           (f (nth r 1) (nth l 2)))\n                    (= (first l) (first r))\n                    false)\n                  (= l r)))\n              (nth c 1) (nth c 2))))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 96, "code": "#((fn symmetric? [_ l r]\n  (if (or (nil? r) (nil? l))\n     (if (not= l r)\n       false\n       true)\n     (if (not= (first l) (first r))\n       false\n       (and (symmetric? nil (second l) (nth r 2))\n                 (symmetric? nil (nth l 2) (second r)))))) (first %) (second %) (nth % 2))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 96, "code": "(fn [v]\n  (= (nth v 1)\n     ((fn depth-first [r]\n        (if (nil? r)\n          nil\n          [(first r) (depth-first (nth r 2)) (depth-first (nth r 1))])) (nth v 2))))", "user": "5e246f92e4b05b4b01516150"}, {"problem": 96, "code": "(fn [t]\n  (let [sym? (fn sym? [t1 t2]\n               (if (and \n                    (coll? t1) \n                    (coll? t2))\n                 (and\n                  (= 3 (count t1))\n                  (= 3 (count t2))\n                  (= (first t1) (first t2))\n                  (sym? (second t1) (nth t2 2))\n                  (sym? (nth t1 2) (second t2)))\n                 (= t1 t2)))]\n    (if (coll? t)\n      (and\n        (= 3 (count t))\n        (sym? (second t) (nth t 2)))\n      true)))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 96, "code": "(fn tree-sym? [t]\n  (let [eq-tree? (fn eqt? [t1 t2]\n                   (if (nil? t1) (nil? t2)\n                       (every? identity [(= (first t1) (first t2))\n                                         (eqt? (second t1) (last t2))\n                                         (eqt? (last t1) (second t2))])))]\n    (eq-tree? (second t) (last t))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 96, "code": "(fn is-symmetric? [tree]\n   (letfn [(flip [n]\n             (if (nil? n) nil\n                 (let [[b l r] n] [b (flip r) (flip l)])))]\n     (= (flip tree) tree)))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 96, "code": "(fn sym\n  ([tr] (let [[r a b] tr] (sym a b)))\n  ([a b] (let [[a1 aa ab] a\n               [b1 ba bb] b]\n           (cond (and (nil? a) (nil? b)) true\n                 (= a1 b1) (and (sym aa bb) (sym ab ba))\n                 :else false))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 96, "code": "(fn symmetric-binary-tree? [[_ [valueA leftA rightA]\n                           [valueB leftB rightB]]]\n           (and (= valueA valueB)\n                (or (= nil leftA rightA leftB rightB)\n                    (and\n                     (symmetric-binary-tree? [_ leftA rightB])\n                     (symmetric-binary-tree? [_ rightA leftB])))))", "user": "5e3975a3e4b01d43a70e8dd3"}, {"problem": 96, "code": "(fn [seq]\n  (let [mirror (fn mirror [[node left right :as tree]]\n                 (when tree\n                   [node (mirror right) (mirror left)]))]\n    (= seq (mirror seq))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 96, "code": "#(letfn [(rt [t]\n  (if (empty? t)\n    nil\n   (cons (first t) \n         (reverse \n          (vector \n           (rt (second t)) \n           (rt (last t)))))))]\n   (= (second %) (rt (last %))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 96, "code": "#(letfn [(step [queue get-children]\n          (lazy-seq\n            (when (seq queue)\n              (let [node (peek queue)\n                    children (get-children node)]\n                (cons node\n                      (step (into (pop queue) children) get-children))\n                )\n              )\n            )\n          )\n        \n        (bfs [root get-children]\n          (step (conj clojure.lang.PersistentQueue/EMPTY root) get-children))\n        ]\n\n  (let [left-branch (bfs % (fn [[_ & children]] children))\n        right-branch (bfs % (fn [[_ & children]] (reverse children)))]\n    (= (map first left-branch) (map first right-branch))\n    )\n  \n  )", "user": "5e491182e4b043cd24807a46"}, {"problem": 96, "code": "(fn symmetrical [tree]\n  (let [flip (fn f [[head left right :as branch]]\n               (if (= left right) branch\n                 [head (f right) (f left)]))]\n    (= (second tree) (flip (last tree)))))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (= ((fn mir [t]\n         (if (sequential? t)\n           (cons (first t) (reverse (map mir (rest t))))\n           t)) left)\n     right))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 96, "code": "(fn symmetric? [t]\n  (let [mirror (fn mirror [[root left right]]\n                 (if (nil? root)\n                   nil\n                   (list root (mirror right) (mirror left))))]\n    (= t (mirror t))))", "user": "5dcc152ae4b02b31cc3da3c3"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5e48ec09e4b043cd24807a45"}, {"problem": 96, "code": "(fn f [tree]\n  (let\n    [[_root left right] tree\n     is_mirror (fn ism \n                 [tree1 tree2]\n                 (cond\n                  (nil? tree1) (nil? tree2)\n                  (nil? tree2) (nil? tree1)\n                  :else (let\n                          [[root1 left1 right1] tree1\n                           [root2 left2 right2] tree2]\n                          (and\n                           (= root1 root2)\n                           (ism left1 right2)\n                           (ism right1 left2)))))]\n    (is_mirror left right)))", "user": "5e6e6537e4b04a83ad7cd29a"}, {"problem": 96, "code": "(fn is-symmetric-bundled [tree]\n  (letfn [(mirror [tree]\n            (cond\n              (nil? tree) tree\n              :else\n              (let [[root left right] tree]\n                (if (= nil root)\n                  nil\n                  [root (mirror right) (mirror left)]))))\n          (eq-tree [left right]\n            (cond\n              (and (nil? left) (nil? right)) true\n              (or (nil? left) (nil? right)) false\n              :else\n              (let [[lroot lleft lright] left\n                    [rroot rleft rright] right]\n                (and (= lroot rroot) (eq-tree lleft rleft) (eq-tree lright rright)))))]\n    (cond\n      (nil? tree) true\n      :else (let [[_ left right] tree\n                  mirrored (mirror left)]\n              (eq-tree mirrored right)))))", "user": "5d80f328e4b0915913b1d372"}, {"problem": 96, "code": "(fn mirror?\n  ([[_ left right :as t]] (if (nil? t) true (mirror? left right)))\n  ([[lv ll lr :as lt] [rv rl rr :as rt]]\n   (if (and (nil? lt) (nil? rt))\n     true\n     (and (= lv rv)\n          (mirror? ll rr)\n          (mirror? lr rl)))))", "user": "5b4b8cd6e4b02d533a91bc9f"}, {"problem": 96, "code": "#(= ((fn swap-all [v]\n  (if not= 3 (count v)) (vec v)\n  (let [d (vec v) f (d 0) a (d 1) b (d 2)\n        s (if (coll? a) (swap-all a) a)\n        t (if (coll? b) (swap-all b) b)]\n    (if (and (not (coll? s)) (not (coll? t))) [f s t] [f t s]))) ((vec %) 1)) ((vec %) 2))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 96, "code": "#(= %\n    ((fn flip [[v l r :as n]]\n       (when n\n         [v (flip r) (flip l)]))\n     %))\n; amalloy's solution", "user": "5e13a6b7e4b099d064963001"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(make-mirror \n            [[root left right :as tree]]\n            (if (nil? tree)\n              tree\n              [root (make-mirror right) (make-mirror left)]))]\n    (= tree (make-mirror tree))))", "user": "5e805895e4b085ba37836e44"}, {"problem": 96, "code": "#(let [flip (fn flip [[v l r :as n]]\n                     (when n [v (flip r) (flip l)]))]\n   (= % (flip %)))", "user": "4eb70649535d7eef30807373"}, {"problem": 96, "code": "(fn sym-tree? [tree]\n  (let [ft (fn flatten-tree [t]\n              (if (nil? t)\n                []\n                (flatten (conj [] (flatten-tree (second t)) (first t) (flatten-tree (last t))))))\n        it? (fn is-tree? [tree]\n              (or\n                (nil? tree)\n                (and\n                  (coll? tree)\n                  (= (count tree) 3)\n                  (is-tree? (second tree))\n                  (is-tree? (last tree)))))]\n    (if (it? tree)\n      (sym-tree? (ft tree))\n      (if (= (count tree) 1)\n        true\n        (and (= (first tree) (last tree)) (sym-tree? (rest (butlast tree))))))))", "user": "5e8f87c7e4b0cb0169546342"}, {"problem": 96, "code": "#(= % ((fn mirror [[root l r :as tree]]\n         (when tree [root (mirror r) (mirror l)])) %))", "user": "5e99cbd4e4b0157ca96647e6"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5e9771dee4b0157ca96647d0"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5e9e408fe4b00a66d4a95172"}, {"problem": 96, "code": "(fn beauty\n  [n]\n  (let[sym?\n       (fn _ [x y]\n             (if (nil? x) (nil? y)\n                 (and\n                   (= (first x) (first y))\n                   (_ (second x) (nth y 2))\n                   (_ (second y) (nth x 2)))))]\n    (or (nil? n)(sym? (second n) (nth n 2)))))", "user": "5e95013fe4b0fbed045a3800"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5e978fe5e4b0157ca96647d1"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] \n       (when tree \n         [n (mirror r) (mirror l)])) %) %)", "user": "5e9d1c75e4b0157ca9664801"}, {"problem": 96, "code": "(fn beautyissymmetry\n  [n]\n  (let[sym?\n       (fn _ [x y]\n             (if (nil? x) (nil? y)\n                 (and\n                   (= (first x) (first y))\n                   (_ (second x) (nth y 2))\n                   (_ (second y) (nth x 2)))))]\n    (or (nil? n)(sym? (second n) (nth n 2)))))", "user": "5ea3711ae4b00a66d4a9519d"}, {"problem": 96, "code": "(fn symmetric? [[_ left right]]\n  ((fn symmetry [node1 node2]\n    (cond\n      (not (= (or (seq? node1) (vector? node1)) (or (seq? node2) (vector? node2))))\n      false\n\n      (and (or (seq? node1) (vector? node1)) (or (seq? node2) (vector? node2)))\n      (let [[root1 left1 right1] node1\n            [root2 left2 right2] node2]\n        (and (symmetry left1 right2) (symmetry left2 right1) (= root1 root2)))\n\n      :else\n      (= node1 node2))) left right))", "user": "5e950178e4b0fbed045a3801"}, {"problem": 96, "code": "(fn symmetric? [[_ left right]]\n  (letfn [(helper [[k1 l1 r1 :as left] [k2 l2 r2 :as right]]\n            (and\n             (= k1 k2)\n             (= (count left) (count right))\n             (if (sequential? left)\n               (and (helper l1 r2) (helper l2 r1))\n               true)))]\n    (helper left right)))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 96, "code": "(fn [[_ l r]]\n  (letfn [(flip [[a b c]]\n    (cond (and (nil? b) (nil? c)) [a c b]\n          (nil? b) [a (flip c) b]\n          (nil? c) [a c (flip b)]\n          :else [a (flip c) (flip b)]))]\n  \t(= (flip l) r)))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5ea6f88de4b00a66d4a951b1"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5ea7b04de4b00a66d4a951b6"}, {"problem": 96, "code": "(fn symmetry? [[v l r :as root]]\n    (letfn [(reverse-tree [t]\n                (if (nil? t)\n                    t\n                    (let [[v l r] t]\n                        [v (reverse-tree r) (reverse-tree l)]\n                        )))]\n    \t(= l (reverse-tree r))))", "user": "5ea2e6bfe4b00a66d4a95197"}, {"problem": 96, "code": "(fn symmetric? [root] \n  (letfn [(sym? [root1 root2] \n               (or (and (nil? root1) (nil? root2))\n                   (and (= (nth root1 0) (nth root2 0))\n                        (sym? (nth root1 1) (nth root2 2))\n                        (sym? (nth root1 2) (nth root2 1)))))]\n    (sym? root root)))", "user": "5eaba9c0e4b00a66d4a951d6"}, {"problem": 96, "code": "(fn [tr]\n  (let [is-matching? (fn match? [l r]\n                       (or (and (nil? l) (nil? r))\n                           (and (coll? l) (= (count l) 3)\n                                (coll? r) (= (count r) 3)\n                                (= (first l) (first r))\n                                (match? (second l) (last r))\n                                (match? (last l) (second r)))))]\n    (or (nil? tr)\n        (and (coll? tr)\n             (= (count tr) 3)\n             (is-matching? (second tr) (last tr))))))", "user": "59750a68e4b01722bebd4cba"}, {"problem": 96, "code": "(fn [node]\n    (= node ((fn flip [[v a b :as node]]\n               (when node\n                 [v (flip b) (flip a)]))\n             node)))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5e2586afe4b05b4b01516167"}, {"problem": 96, "code": "(fn solution\n  ([tree]\n   (solution (second tree) (nth tree 2)))\n  ([sub-left sub-right]\n   (if (and (coll? sub-right) (coll? sub-left))\n     (let [[vall lleft lright] sub-left\n           [valr rleft rright] sub-right]\n       (if (not= vall valr)\n         false\n         (and (solution lleft rright) (solution rleft lright))))\n     (= sub-right sub-left))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 96, "code": "(fn [[root left right]]\n  (letfn [(flip-tree [[root left right]]\n            [root\n             (when right (flip-tree right))\n             (when left (flip-tree left))])]\n    (= left (flip-tree right))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 96, "code": "(fn __\n   [[_ [x x-left x-right] [y y-left y-right]]]\n   (and (= x y)\n        (or (= nil x-left y-left)\n            (and\n               (__ [_ x-left y-right])\n               (__ [_ x-right y-left])))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [[value [left ll lr][right rl rr]]]\n  (let [mirrorfn (fn mirror [coll]\n                 (cond (nil? coll) coll\n                       :else (let [[v l r] coll]\n                               [v (mirror r) (mirror l)])))]\n    (= [left ll lr]\n       [right (mirrorfn rr) (mirrorfn rl)])))", "user": "5e9683f1e4b0157ca96647c7"}, {"problem": 96, "code": "(fn [[v0 l0 r0]]\n  (= l0 ((fn sw [[v l r]]\n          (when (not (nil? v))\n            [v (sw r) (sw l)])) r0)))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "568f2059e4b0dcc4269f40df"}, {"problem": 96, "code": "(fn is-tree-sym?\n  [node]\n  (letfn [(is-sym?   [lc rc]\n            (let [[lval llc lrc] lc\n                  [rval rlc rrc] rc]\n              (and\n               (= lval rval)\n               (if (= llc nil)\n                 (if (= rrc nil) true false)\n                 (is-sym? llc rrc))\n               (if (= lrc nil)\n                 (if (= rlc nil) true false)\n                 (is-sym? lrc rlc)))))]\n    (and\n     (let [[_ lc rc] node]\n       (is-sym? lc rc)))))", "user": "5ed3c43be4b016b56eae05c4"}, {"problem": 96, "code": "(fn a [root]\n  (letfn [(_self [[lv ll lr :as l] [rv rl rr :as r]]\n           (if (not (= nil l r))\n             (and\n              (= lv rv)\n              (_self ll rr)\n              (_self lr rl))\n             true))]\n      (_self (second root) (nth root 2))))", "user": "5799b260e4b05b1deef9adc8"}, {"problem": 96, "code": "(fn [t]\n  (let [mirror (fn m [[v l r :as all]]\n                 (if (nil? all)\n                   all\n                   [v (m r)\n                    (m l)]))]\n    (= t (mirror t))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 96, "code": "(fn symmetric\n  [[V L R]]\n  (if (and (coll? L) (coll? R) (= 3 (count L) (count R)))\n    (let [[LV LL LR] L\n          [RV RL RR] R]\n      (and (= LV RV) (symmetric [nil LL RR]) (symmetric [nil LR RL])))\n    (= L R)))", "user": "5ecfd429e4b016b56eae05a9"}, {"problem": 96, "code": "(fn is-sym? [[_ l r]]\n  (if (not (coll? l))\n    true\n    (if (not (and (coll? l) (coll? r)))\n      false\n      (let [[lb ll lr] l, [rb rl rr] r]\n        (and (= lb rb) (is-sym? [nil ll rr]) (is-sym? [nil lr rl]))))))", "user": "5eac172fe4b00a66d4a951dd"}, {"problem": 96, "code": "(fn [[_ child1 child2]]\n  (= \n    child1\n    ((fn flip [tree]\n      (if (nil? tree)\n        nil\n        [(first tree) (flip (nth tree 2)) (flip (nth tree 1))])) child2)))", "user": "5ed9c2cde4b0c7845d86b0e4"}, {"problem": 96, "code": "(fn symmetric [t] (letfn [(flip-tree [t] (if (nil? t)\n                                           nil\n                                           (list (nth t 0)\n                                                 (flip-tree (nth t 2))\n                                                 (flip-tree (nth t 1)))))]\n                    (= t (flip-tree t))))", "user": "5ee93720e4b029a2061bbeb7"}, {"problem": 96, "code": "(fn [tree]\n  (let [reflect (fn f [tree]\n                  (when tree\n                    (list (first tree) (f (last tree)) (f (second tree)))))]\n    (= tree (reflect tree))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 96, "code": "#(letfn [(rev [t] (if-let [[elem a b] t] [elem (rev b) (rev a)]))]\n   (= % (rev %)))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(rev [a]\n    (if (nil? a)\n      nil\n      [(first a) (rev (last a)) (rev (second a))]))]\n      (= tree (rev tree))))", "user": "5eb4927fe4b00a66d4a95221"}, {"problem": 96, "code": "#(= ((fn mira [[n l r :as tree]]\n       (when tree \n         [n (mira r) (mira l)])) %) %)", "user": "5eeeb000e4b07c55ae4a0515"}, {"problem": 96, "code": "(fn [coll] (let [mirrored (fn walk [coll]\n                            (let [\n                                    walk-it (fn [v] (if (coll? v)\n                                                      (walk v)\n                                                      v\n                                                      ))\n                                    node-1 (walk-it (second coll))\n                                             \n                                    node-2 (walk-it (nth coll 2))\n                                  \n                                  ]\n\n                              [(first coll) node-2 node-1]\n                                      ))\n                  \n                  ]\n              (= (second coll) (mirrored (nth coll 2)))))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 96, "code": "(fn sym? \n  ([t] (sym? (nth t 1) (nth t 2)))\n  ([l r]\n   (if (not (and l r)) (not (or l r))\n     (and (= (first l) (first r))\n          (sym? (nth l 1) (nth r 2))\n          (sym? (nth l 2) (nth r 1))))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [tree]\n  (letfn [(mirror-tree\n      [tree]\n      (let [[value left right] tree]\n        (if (sequential? left)\n          (if (sequential? right)\n            (list value (mirror-tree right) (mirror-tree left))\n            (list value right (mirror-tree left)))\n          (if (sequential? right)\n            (list value (mirror-tree right) left)\n            (list value right left)))))]\n    (let [[value left right]tree]\n      (= left (mirror-tree right)))))", "user": "5e9b7aefe4b0157ca96647f1"}, {"problem": 96, "code": "(fn tree-sym?\n  [tree]\n  (let [rt (fn rev-tree [t]\n             (if (coll? t)\n               (list (first t) (rev-tree (nth t 2)) (rev-tree (second t)))\n               t))]\n    (= (second tree) (rt (nth tree 2)))))", "user": "5ef18431e4b07c55ae4a0529"}, {"problem": 96, "code": "(fn f\n  ([[_ l r]] (f l r))\n  ([l r]\n   (print (str \"\\nl: \" l \" r: \" r))\n   (and (= (sequential? l)\n           (sequential? r))\n        (or (and (not (sequential? l)) (= l r))\n            (and (= (first l) (first r))\n                 (f (second l) (nth r 2))\n                 (f (second r) (nth l 2)))))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (= tree ((fn mirror [t] (when t [(first t) (mirror (last t)) (mirror (second t))])) tree)))", "user": "5eec1001e4b07c55ae4a0502"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(reverse-tree  [[value left right]]\n            (let [new-left (if (coll? right) (reverse-tree right) right)\n                  new-right (if (coll? left) (reverse-tree left) left)]\n              [value new-left new-right]))]\n    (= tree (reverse-tree tree))))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 96, "code": "#(let [rt (fn rt [t] (let [t1 (first t) t2 (second t) t3 (last t)]\n                       [t1 (if (nil? t3) t3 (rt t3)) (if (nil? t2) t2 (rt t2))]))]\n   (= % (rt %)))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(is-mirror-node [[lv ll lr] [rv rl rr]]\n            (or \n              (and (nil? lv) (nil? rv))\n              (and (= lv rv) (is-mirror-node ll rr) (is-mirror-node lr rl))))]\n    (is-mirror-node (second t) (last t))))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 96, "code": "(fn [[s l r]]\n  (letfn [(rev [[s l r :as branch]]\n               (if (every? #(not (sequential? %)) branch)\n                 (vector s r l)\n                 (cons s (map #(if (nil? %) % (rev %)) [r l]))))]\n    (= l (rev r))))", "user": "5e3071abe4b05b4b01516213"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f18444ee4b091ba50b4dbd3"}, {"problem": 96, "code": "(letfn [(left [t] (nth t 1))\n        (right [t] (nth t 2))\n        (sym [l r] (cond\n                    (and (nil? l) (nil? r)) true\n                    (and (= (first l) (first r)) (sym (left l) (right r)) (sym (right l) (left r))) true\n                    :else false))]\n\t(fn [t] (sym (left t) (right t))))", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 96, "code": "#(letfn [(flip [x]\n          (if (sequential? x)\n            (list (first x) (flip (nth x 2)) (flip (nth x 1)))\n            x))]\n   (= % (flip %)))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 96, "code": "(fn sym-tree?\n  ([[_ l r]] (sym-tree? l r))\n  ([[v1 l1 r1] [v2 l2 r2]]\n   (if (and (nil? v1) (nil? v2))\n     true\n     (and (= v1 v2)\n          (sym-tree? r1 l2)\n          (sym-tree? l1 r2)))))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 96, "code": "(fn is-symetric?\n  ([tree] (is-symetric? tree tree))\n  ([root1 root2]\n   (if (and (nil? root1) (nil? root2))\n     true\n     (if (= (first root1) (first root2))\n       (and (is-symetric? (second root1) (last root2))\n            (is-symetric? (last root1) (second root2)))\n       false))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [coll]\n  (and ((fn symmetric?\n          [left right]\n          (if (and (coll? left) coll? right)\n            (and (= (first left) (first right))\n                 (\n                  (fn symmetric?\n                    [left right]\n                    (if (and (coll? left) coll? right)\n                      (and (= (first left) (first right))\n                           (symmetric? (first (rest left)) (second (rest right)))\n                           (symmetric? (second (rest left)) (first (rest right))))\n                      (= left right))) (first (rest left)) (second (rest right)))\n                 (\n                  (fn symmetric?\n                    [left right]\n                    (if (and (coll? left) coll? right)\n                      (and (= (first left) (first right))\n                           (symmetric? (first (rest left)) (second (rest right)))\n                           (symmetric? (second (rest left)) (first (rest right))))\n                      (= left right))) (second (rest left)) (first (rest right))))\n            (= left right))) (first (rest coll)) (second (rest coll))) ((fn binary-tree?\n                                                                          [coll]\n                                                                          (cond\n                                                                            (or (seq? coll) (vector? coll))\n                                                                            (and (= 3 (count coll)) (binary-tree? (nth coll 1)) (binary-tree? (nth coll 2)))\n                                                                            (nil? coll) true\n                                                                            :else       false)) coll)))", "user": "5ec5f7f2e4b08d0ec38692d1"}, {"problem": 96, "code": "(fn sym-tree? [s]\n  (letfn [(tree? [s]\n            (if (and (coll? s) (seq s))\n              (when-let [[_ l r] (seq s)]\n                (and (== 3 (count s)) (tree? l) (tree? r)))\n              (nil? s)))\n          (sym? [[lv ll lr :as l] [rv rl rr :as r]]\n            (or\n              (= l r nil)\n              (and (= lv rv) (sym? ll rr) (sym? lr rl))))]\n    (and (tree? s) (let [[_ l r] s] (sym? l r)))))", "user": "5f300f28e4b033932238a682"}, {"problem": 96, "code": "(fn symmetric? [[v l r]]\n  (letfn [(mirror [[v l r :as node]]\n            (if (nil? node)\n              nil\n              [v (mirror r) (mirror l)]))]\n    (= (mirror l) r)))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 96, "code": "(fn [aseq]\n  (let [pre-walk-tree (fn f [xs]\n                        (if (not (coll? xs))\n                           xs\n                           (let [a (first xs)\n                                 b (f (second xs))\n                                 c (f (last xs))]\n                             (concat b [a] c))))\n        l (pre-walk-tree (second aseq))\n        r (pre-walk-tree (last aseq))]\n    (= l (reverse  r))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 96, "code": "(fn [t]\n  (cond (not (coll? t)) true\n        (not= (count t) 3) false\n        :else ((fn sym [l r]\n                 (cond (and (not (coll? l)) (not (coll? r))) (if (= l r) true false)\n                       (or (and (coll? l) (not (coll? r))) (and (not (coll? l)) (coll? r))) false\n                       (not= (count l) (count r)) false\n                       (not= 3 (count l)) false\n                       (not= (first l) (first r)) false\n                       :else (and (sym (second l) (nth r 2)) (sym (second r) (nth l 2))))) (second t) (nth t 2))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 96, "code": "(fn [a]\n   (letfn [(symme [a]\n             (if (not= (count a) 3)\n               nil\n               (lazy-seq (concat [(first a)] (concat [(symme (nth a 2))] [(symme (nth a 1))])))))]\n     (= (symme (nth a 1)) (nth a 2))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 96, "code": "(fn f\n  ([tree] (and (= 3 (count tree))\n               (not (sequential? (first tree)))\n               (f (second tree) (nth tree 2))))\n  ([coll1 coll2] (or (and (nil? coll1)\n                          (nil? coll2))\n                     (and (sequential? coll1)\n                          (sequential? coll2)\n                          (= (first coll1) (first coll2))\n                          (let [l1 (second coll1)\n                                r1 (nth coll1 2)\n                                l2 (second coll2)\n                                r2 (nth coll2 2)]\n                            (and (f l1 r2)\n                                 (f r1 l2)))))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 96, "code": "(fn [[node left right]]\n  (= left ((fn reverse-tree [[node left right]]\n             (let [new-left (if (coll? left)\n                              (reverse-tree left)\n                              left)\n                   new-right (if (coll? right)\n                               (reverse-tree right)\n                               right)]\n               (list node new-right new-left))) right)))", "user": "5c24671be4b07e362c2305a1"}, {"problem": 96, "code": "(fn foo [t]\n   (letfn [(balanced [l r]\n             (if (and (coll? l) (coll? r))\n               (and (= (first l) (first r))\n                    (balanced (second l) (last r))\n                    (balanced (last l) (second r)))\n               (= l r)))]\n     (if-let [c (next t)]\n       (balanced (first c) (second c))\n       true)))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(tree-mirror [tree]\n            (if (nil? tree)\n              nil\n              [(first tree)\n               (tree-mirror (second (rest tree)))\n               (tree-mirror (first (rest tree)))]))]\n    (= (second (rest t)) (tree-mirror (first (rest t))))))", "user": "5f2c94b4e4b033932238a669"}, {"problem": 96, "code": "(fn [t]\n  ((fn mir? [l r]\n     (if (or (= nil l r)\n             (and (= (first l) (first r))\n                  (mir? (second l) (last r))\n                  (mir? (last l) (second r))))\n       true false)) \n   (second t) (last t)))", "user": "5f4eb036e4b0102c75033969"}, {"problem": 96, "code": "(fn symmetric?\n  ([t] (if-let [[n l r] t] (symmetric? l r) true))\n  ([l r]           \n    (if (and (nil? l) (nil? r))\n        true \n        (let [[ln ll lr] l \n              [rn rl rr] r]\n              (if (not= ln rn) false\n                (and (symmetric? ll rr) (symmetric? lr rl)))))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 96, "code": "; theory https://www.educative.io/edpresso/how-to-check-for-a-symmetric-binary-tree-recursive-approach\n(fn symmetree? [col]\n   ((fn isMirror [left right]\n             (cond\n               (= nil left right) true ; tree is empty, its symmetric\n               (and (= 3 (count left)) (= 3 (count right))) ; filled tree\n               (let [[l-root ll-child lr-child] left\n                     [r-root rl-child rr-child] right]\n                 (if (= l-root r-root)\n                   (and (isMirror ll-child rr-child)\n                        (isMirror lr-child rl-child))\n                   false\n                   ))\n               :else false))\n     col col)\n   )\n; stolen elegant solution\n;(fn [[_ l r]]\n;  ((fn m? [[l_ ll lr] [r_ rl rr]]\n;    (if (= nil l_ r_)\n;      true\n;      (and (= l_ r_)\n;           (m? ll rr)\n;           (m? lr rl)))) \n;    l r))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 96, "code": "(fn [[h l r]]\n  ((fn ismirror [left right]\n     \n     \n    (cond\n      (and (nil? left) (nil? right)) true\n      (or (nil? left) (nil? right)) false\n      (and (= (first left) (first right))\n           (ismirror (second left) (nth right 2))\n           (ismirror (nth left 2) (second right))\n           ) true\n      :else false\n      )\n    ) l r)\n  )", "user": "5f58db95e4b0a0bc16850a9a"}, {"problem": 96, "code": "(fn f\n    ([x] (f (second x) (last x)))\n    ([left right]\n     (or (= nil left right) \n         (and (= (first left) (first right))\n              (f (second left) (last right))\n              (f (last left) (second right))))))", "user": "531bf76fe4b08068f379ed96"}, {"problem": 96, "code": "#(= ((fn mirror [[center left right :as tree]] (when tree [center (mirror right) (mirror left)])) %) %)", "user": "5f724f55e4b02876ed9fd089"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f5f2eafe4b02876ed9fcff5"}, {"problem": 96, "code": "(fn [[_ l r]]\n   (= l ((fn d [t] (if (coll? t)\n                    (let [[a b c] t]\n                      [a (d c) (d b)])\n                    t)) r)))", "user": "588fbb39e4b00487982d51bd"}, {"problem": 96, "code": "#(let [t\n         ((fn f [[v l r]]\n            (if v\n              (concat (f l) [v] (f r))\n              )) %)]\n     (= t (reverse t)))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %)\n    %)", "user": "573102bbe4b0cd1946bd0fbb"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f727bd1e4b02876ed9fd08c"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f727dd6e4b02876ed9fd090"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] \n       (when tree [n (mirror r) (mirror l)]\n         )) \n     %) \n    %)", "user": "5f7e91c8e4b0c071e6c840d8"}, {"problem": 96, "code": "(fn [tree]\n  (let [flip-tree (fn flip-tree [tree]\n                    (if (nil? tree)\n                      tree\n                      (let [[a b c] tree]\n                        [a (flip-tree c) (flip-tree b)])))]\n    ((fn trees-equal? [tree1 tree2]\n       (or (every? nil? [tree1 tree2])\n           (and (every? #(or (seq? %) (vector? %)) [tree1 tree2])\n                (= (first tree1) (first tree2))\n                (trees-equal? (nth tree1 1) (nth tree2 1))\n                (trees-equal? (nth tree1 2) (nth tree2 2)))))\n     (nth tree 1) (flip-tree (nth tree 2)))))", "user": "5f79bff2e4b02876ed9fd0ca"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f72f144e4b02876ed9fd093"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f84f0f5e4b0375e81f54e78"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f8361bae4b01aacbe7a2712"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5f87e757e4b0169f6814c40f"}, {"problem": 96, "code": "#(= ((fn sym [[n l r :as tree]] (when tree [n (sym r) (sym l)])) %) %)", "user": "5f8497dce4b0375e81f54e74"}, {"problem": 96, "code": "(fn bis [s]\n  (letfn [(aux [s1 s2]\n            (if (= s1 s2 nil)\n              true\n              (if (not= (count s1) (count s2) 3)\n                false\n                (let [[v1 lc1 rc1] s1\n                      [v2 lc2 rc2] s2]\n                  (if (not= v1 v2)\n                    false\n                    (and (aux lc1 rc2) (aux lc2 rc1)))))))]\n    (if (not= (count s) 3)\n      false\n      (let [[v lc rc] s]\n        (aux lc rc)))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 96, "code": "#(letfn [(mirror [[n l r]] (if n [n (mirror r) (mirror l)]))]\n   (= % (mirror %)))", "user": "596a66cde4b069c0a1a19803"}, {"problem": 96, "code": "(fn tree-symmetric?\n  [[_ [cl-s cl-l cl-r] [cr-s cr-l cr-r]]]\n  (and (= cl-s cr-s)\n       (or (= nil cl-l cr-l)\n           (and\n             (tree-symmetric? [_ cl-l cr-r])\n             (tree-symmetric? [_ cl-r cr-l])))))", "user": "5f3103aee4b0574c87022c24"}, {"problem": 96, "code": "(fn [[_ lt rt]]\n  ((fn mirror? [[_, ll, lr :as l] [_, rl, rr :as r]]\n    (if (every? nil? [l r])\n      true\n      (and (= (first l) (first r))\n           (mirror? ll rr)\n           (mirror? lr rl)))) lt rt))", "user": "5f6caa19e4b02876ed9fd056"}, {"problem": 96, "code": "(fn symmetricX[t]\n\t(\n(fn equivalent[t1 t2]\n\t(if (nil? t1)\n\t\t(nil? t2)\t\t\n\t\t(and ( = (first t1) (first t2))\n\t\t\t(and \n\t\t\t\t(equivalent (second t1)(last t2) )\n\t\t\t\t(equivalent (last t1)(second t2) )\n\t\t\t)\n\t\t)\n\t)\n) (second t) (last t))\n)", "user": "5eb3d02be4b00a66d4a95215"}, {"problem": 96, "code": "(fn tree-sym\n  ([tree]\n  (tree-sym  (second tree) (nth tree 2)))\n  ([tree1 tree2]\n  (if (and (nil? tree1) (nil? tree2))\n    true\n    (let [left-left (second tree1) left-right (nth tree1 2) right-left (second tree2) right-right (nth tree2 2)]\n      (and (= (first tree1) (first tree2)) (tree-sym left-left right-right) (tree-sym left-right right-left))\n    )\n  ))\n\n)", "user": "5f6b8222e4b02876ed9fd052"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5ee4545ee4b029a2061bbe8d"}, {"problem": 96, "code": "(fn symmetry-tree [tree]\n  (let [mirror-tree (fn mirror [[node left right :as tree]]\n                      (if (nil? tree)\n                        tree\n                        [node (mirror right) (mirror left)]))]\n    (= tree (mirror-tree tree))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 96, "code": "(fn [[v l r]]\n  (letfn [(is-symmetrical [[t1-val t1-left-subtree t1-right-subtree]\n                      [t2-val t2-left-subtree t2-right-subtree]]\n  (and (= t1-val t2-val)\n       (if (every? sequential? [t1-left-subtree t2-right-subtree])\n         (is-symmetrical t1-left-subtree t2-right-subtree)\n         (= t1-left-subtree t2-right-subtree nil))\n       (if (every? sequential? [t1-right-subtree t2-left-subtree])\n         (is-symmetrical t1-right-subtree t2-left-subtree)\n         (= t1-right-subtree t2-left-subtree nil))))]\n  (is-symmetrical l r)))", "user": "5eb741e4e4b00a66d4a9523b"}, {"problem": 96, "code": "(fn [[_ l r :as tree]] \n  (letfn [(reverse-tree [[v l r :as tree]] \n            (if (= nil l r) \n              tree \n              (list v (reverse-tree r) (reverse-tree l))))] \n    (= l (reverse-tree r))))", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 96, "code": "(fn symm [t] \n  (= t \n     ((fn mirror [t] \n       (if (nil? t) t \n         (list\n           (first t) \n           (mirror (last t)) \n           (mirror (second t))))) t)))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 96, "code": "(fn symm [[root left right]]\n  (cond\n   \t(or (sequential? left) (sequential? right)) \n   \t\t(\n         \tlet [newfunc (fn newfuncdef [[rootN leftN rightN]]  \n                           (cond\n                            \t(or (sequential? leftN) (sequential? rightN)) (vector rootN (newfuncdef rightN) (newfuncdef leftN)) \n                            \t:else rootN\n                            )\n                           )\n                 newfunc2 (fn newfuncdef2 [[rootN2 leftN2 rightN2]]  \n                           (cond\n                            \t(or (sequential? leftN2) (sequential? rightN2)) (vector rootN2 (newfuncdef2 leftN2) (newfuncdef2 rightN2)) \n                            \t:else rootN2\n                            )\n                           )\n                 \n                 lleft (newfunc left)\n                 rright (newfunc2 right)]\n         \t(= lleft rright)\n         \t\n         )\n   \n   \t:else (= left right)\n   )\n )", "user": "5fc5c303e4b02c825b0c8c1a"}, {"problem": 96, "code": "(fn [t]\n    (letfn [(invert[t]\n              (if (sequential? t)\n                (vector \n                 (first t) \n                 (invert (nth t 2)) \n                 (invert (nth t 1)))\n                t))]\n      (= t (invert t))))", "user": "573a0ecce4b0cd1946bd1088"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5fc04417e4b0edf42a5593c6"}, {"problem": 96, "code": "(fn [[_ a b]]\n   (= a ((fn rev [coll]\n           ((fn [[ca cb cc]](vector ca cc cb)) (map #(if (coll? %) (rev %) %) coll)))\n         b)))", "user": "5fa96ddbe4b0fa27300f3dec"}, {"problem": 96, "code": "#(let [flip-tree (fn flip-tree [[value left right]]\n                     (when (or value left right)\n                           [value (flip-tree right) (flip-tree left)]))]\n      (= % (flip-tree %)))", "user": "5f331015e4b0574c87022c37"}, {"problem": 96, "code": "(fn [tree]\n  (let [[root left right] tree]\n    (letfn [(leaf? [t]\n              (not (sequential? t)))\n            (mirror? [t1 t2]\n              (if (and (leaf? t1) (leaf? t2))\n                (if (= t1 t2) true false)\n                (let [[d1 l1 r1] t1\n                      [d2 l2 r2] t2]\n                  (if (= d1 d2)\n                    (and (mirror? l1 r2) (mirror? r1 l2))\n                    false))))]\n      (mirror? left right))))", "user": "5484c3b2e4b0e286459a11a2"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "5fe9f657e4b05ac5b16ea1a6"}, {"problem": 96, "code": "(fn [bt]\n  (letfn [(sym [a b]\n               (cond (and (nil? a) (nil? b)) true\n                     (or (nil? a) (nil? b)) false\n                   :else (and (= (first a) (first b)) (sym (nth a 2) (second b)) (sym (second a) (nth b 2)))))]\n    (or (nil? bt) (and (sym (second bt) (nth bt 2))))))", "user": "5f419985e4b0955706451fab"}, {"problem": 96, "code": "(fn symmetric? [tree]\n  (letfn [(mirror [t] (\n    if (not (sequential? t))\n    t\n    (let [[n l r :as all] t]\n      [n (mirror r) (mirror l)])\n    ))]\n    (if (not (sequential? tree))\n      true\n      (let [[_ l r] tree]\n        (= l (mirror r)))\n      )\n    )  \n)", "user": "5fee18f2e4b05ac5b16ea1d2"}, {"problem": 96, "code": "(fn [[value left right :as node]]\n  (letfn [(mirror [[value left right :as node]]\n            (if node [value (mirror right) (mirror left)]))]\n    (= left (mirror right))))", "user": "5fef4292e4b05ac5b16ea1d7"}, {"problem": 96, "code": "(fn [[v left right :as t]]\n        (let [sym? (fn sym? [t1 t2]\n                     (or (and (nil? t1) (nil? t2))\n                         (and (= (first t1) (first t2))\n                              (sym? (second t1) (last t2))\n                              (sym? (last t1) (second t2)))))]\n          (cond\n            (nil? t) true\n            (sym? left right) true\n            :else false)))", "user": "546c4377e4b00cfc9eacc177"}, {"problem": 96, "code": "(fn simetric? [s]\n  (letfn [(is-binary? [x] (and (sequential? x) (= 3 (count x))))\n          (are-simetric? [left right]      \n            (cond \n              (and (nil? left) (nil? right)) true\n              (and \n                (is-binary? left) \n                (is-binary? right)  \n                (= (first left) (first right))) \n              (and (are-simetric? (second left) (last right)) (are-simetric? (last left) (second right)))\n              :else false))]\n   (are-simetric? (second s) (last s))))", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 96, "code": "(fn [tree]\n    (letfn [(do-symmetry [t]\n              (if (and (sequential? t) (= (count t) 3))\n                [(first t) (do-symmetry (last t)) (do-symmetry (second t))]\n                t))]\n      (= tree (do-symmetry tree))))\n\n;; #((fn ff [[l-root ll lr :as left] [r-root rl rr :as right]]\n;;       (or (= nil left right)\n;;           (and (= l-root r-root) (ff ll rr) (ff lr rl)))) % %)", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 96, "code": "(fn is-symmetric [t]\n  (letfn [(data [t] (first t))\n          (left-subtree [t] (second t))\n          (right-subtree [t] (second (rest t)))\n          (are-symmetric [t-left t-right]\n            (or (and (nil? t-left) (nil? t-right))\n            (and (= (data t-left) (data t-right))\n                 (are-symmetric (left-subtree t-left) (right-subtree t-right))\n                 (are-symmetric (right-subtree t-left) (left-subtree t-right)))))]\n    (are-symmetric (left-subtree t) (right-subtree t))))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 96, "code": "(fn sym?\n  [t]\n  (letfn [(flip\n            [t]\n            (let [[val left right] t\n                  newt []]\n              (if (nil? t) nil\n                  (conj newt val (flip right) (flip left)))))]\n    (= t (flip t))))", "user": "5f5e166ce4b02876ed9fcfed"}, {"problem": 96, "code": "(fn sym [s]\n   ; It's always itself and therefore \"equal\". Ignore the first value. \n   (loop [tail (rest s) remaining []]\n        ; Compare the first and the last and add them to the sequence\n        ; Maybe elevate at this point.\n        (let [leftest (first tail)\n              leftest-children [(second leftest) (last leftest)]\n              leftest-val (first leftest)\n              rightest (last tail)\n              rightest-children [(second rightest) (last rightest)]\n              rightest-val (first rightest)\n              prep-app-children (fn [l r remaining] (->> (rest l)\n                (into (->> (rest r)\n                           (into remaining)\n                           reverse))\n                reverse\n                vec\n                ))\n              cut-off-edges (fn [s] (->> s rest reverse rest reverse vec))]\n         ; Compare their values\n         (if (= leftest-val rightest-val)\n            ; add their collections to remaining\n            ; Cut the edges off.\n            ; Is there anything in the tail after cutting the edges off? \n            (if (seq tail)\n               ; The edges are added to remaining. Remove from tail.\n               (recur (cut-off-edges tail) (prep-app-children leftest rightest remaining))\n               (if (seq remaining)\n                  (recur remaining []) ; Recur something w/ that\n                  true ; Is this right? \n               )\n\n            )\n            false\n         )\n         ; Prepend the leftest's children to old-colls\n         ; Append the rightest's children to old-colls \n         ; their children in old-colls\n      )\n   )\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (let [flatten-tree (fn ft [[root left right]]\n                       (when root\n                         (concat [] (ft left) [root] (ft right))))]\n    (= (flatten-tree left)\n       (reverse (flatten-tree right)))))", "user": "5c30da5ae4b0d62ef62d9f23"}, {"problem": 96, "code": "(fn symmetric?\n  [[_ left right]]\n  (letfn [(rev-tree [[v l r :as tree]]\n            (when tree\n              [v (rev-tree r) (rev-tree l)]))]\n    (= left (rev-tree right))))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 96, "code": "(fn [tree] \n  (let [mirror-tree\n        (fn mirror-tree [tree]\n          (if (coll? tree)\n            (let [[k l r] tree] [k (mirror-tree r) (mirror-tree l)])\n            tree))\n        [_ right left] tree\n        ]\n    (= left (mirror-tree right))\n    )\n  )", "user": "6004c750e4b074f607df6645"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "6001460ce4b074f607df6611"}, {"problem": 96, "code": "(fn [x]\n  (letfn\n      [(mirror\n           [x]\n           (if (nil? x)\n               nil\n               (list (nth x 0) (mirror (nth x 2)) (mirror (nth x 1)))))]\n      (= (nth x 1) (mirror (nth x 2)))))", "user": "600ae927e4b074f607df6689"}, {"problem": 96, "code": "#(= % ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 96, "code": "#(letfn [(flip [[v l r :as t]]\n                  (if (nil? t)\n                    nil\n                    [v (flip r) (flip l)]))]\n    (= % (flip %)))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 96, "code": "(fn [t]\n  (=\n   ((fn trav-l [t]\n      (if (coll? t)\n        (let [[v l r] t]\n          (concat (trav-l l) (trav-l v) (trav-l r)))\n        [t])) t)\n   ((fn trav-r [t]\n      (if (coll? t)\n        (let [[v l r] t]\n          (concat (trav-r r) (trav-r v) (trav-r l)))\n        [t])) t)))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 96, "code": "(fn beauty-is-symmetry [se] ;; se has the form (value left right)\n  (let [left (second se)\n        right (last se)\n        mirror-fn (fn mirror [se2] ;; swaps left and right subtrees\n                    (let [left2 (second se2)\n                          right2 (last se2)]\n                      (if (and (nil? left2)\n                               (nil? right2))\n                        se2\n                        (list\n                          (first se2)\n                          (if (sequential? right2) (mirror right2) right2)\n                          (if (sequential? left2) (mirror left2) left2)))))]\n    (= left ;; symmetry means that the left subtree equals the mirrored right subtree\n       (if (sequential? right)\n         (mirror-fn right)\n         right))))", "user": "5fbf6fe7e4b0ad6fc3476147"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 96, "code": "(fn [[v left right :as tree]] \n  (let [f (fn mirror [[v l r]]\n                        (let [f #(if % (mirror %))\n                              c1 (f r)\n                              c2 (f l)]\n                          [v c1 c2]))]\n    (= right (f left))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 96, "code": "(fn [tree]\n  (let [rev (fn rev-tree [t]\n              (if-not (coll? t)\n                t\n                [(first t) (rev-tree (last t)) (rev-tree (second t))]))\n        ]\n    (= (second tree) (rev (last tree)))))", "user": "5a3e1243e4b0447ef91cc5ae"}, {"problem": 96, "code": "(fn [xs]\n  (letfn [(mirror [[n l r :as tree]]\n            (when tree [n (mirror r) (mirror l)]))] (= (mirror xs) xs)))", "user": "57e10705e4b0bfb2137f5a6a"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(tree= [left right]\n                 (cond\n                  (and (nil? (first left)) (nil? (first right))) true\n                  (or (nil? (first left)) (nil? (first right))) false\n                  :else (and (= (first left) (first right))\n                             (tree= (second left) (nth right 2))\n                             (tree= (nth left 2) (second right)))))]\n    (tree= (second tree) (nth tree 2))))", "user": "60096aabe4b074f607df667f"}, {"problem": 96, "code": "(fn symmetric? [node]\n  (= node \n     ((fn flip [[v l r]] \n        (if v \n          [v (flip r) (flip l)]))\n      node)))", "user": "601c39eee4b0bf4ca6b10937"}, {"problem": 96, "code": "(fn [[_ l r]] \n  (= ((fn [r] \n        (clojure.walk/postwalk #(or (and (sequential? %)\n                                         (some sequential? %)\n                                         (conj (reverse (rest %))\n                                               (first %)))\n                                    %)\n                               r)) r)\n     l))", "user": "4e38f245535deb9a81d77f3e"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5ff709e4e4b06df49cee149b"}, {"problem": 96, "code": "(fn [szn]\n  (letfn [(deep-reverse [tree]\n                        (if (= tree nil) nil\n                          (list (nth tree 0) (deep-reverse (nth tree 2))\n                                (deep-reverse (nth tree 1)))))\n                        ]\n  (= (nth szn 1)\n         (deep-reverse (nth szn 2)))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 96, "code": "(fn [[_ lf rc]]\n                  (let [mirror-image (fn mirror [[v lc rc]\n                                                acc]\n                                       (if v\n                                         (mirror lc (mirror rc (conj acc v)))\n                                         (conj acc v)))]\n                    (= (mirror-image lf []) (flatten rc))))", "user": "6026737ee4b0d5df2af2222f"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5fd361f2e4b07e53c2f3f04e"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(flip [[n l r]]\n               (if (nil? n)\n                 n\n                 (list n (flip r) (flip l))))]\n    (= (flip t) t)))", "user": "602d5eade4b0d5df2af22279"}, {"problem": 96, "code": "(fn foo [coll]\n        (let [symetric (fn symetric [one two]\n        (cond (and (coll? one) (coll? two))\n              (if (and (= (first one) (first two))\n                       (symetric (second one) (second (rest two)))\n                       (symetric (second two) (second (rest one)))\n                       ) true\n                  false)\n              (= one two) true\n              :else false)\n        )]\n        (symetric (second coll) (last coll))))", "user": "6038b6b4e4b0d5df2af222ef"}, {"problem": 96, "code": "(fn beauty-is-symmetry [s]\n  (let [left (second s)\n        right (last s)\n        mirror (fn mirror [s]\n                 (let [left (second s)\n                       right (last s)]\n                   (if (and (nil? left) (nil? right))\n                     s\n                     (list\n                      (first s)\n                      (if (sequential? right) (mirror right) right)\n                      (if (sequential? left) (mirror left) left)))))]\n    (=\n     left\n     (if (sequential? right)\n       (mirror right)\n       right))))", "user": "602cc4d4e4b0d5df2af22274"}, {"problem": 96, "code": "(fn is-symmetric [tree]\n  (let\n    [flip-tree (fn flip-tree [tree]\n                 (if (nil? tree) nil\n                   (let [[v l r] tree] [v (flip-tree r) (flip-tree l)])\n                   )\n                 )]\n    (= (flip-tree tree) tree)\n  ))", "user": "6045582fe4b02d28681c77b6"}, {"problem": 96, "code": "#(= % ((fn mir [[r f s :as n]] (when n [r (mir s) (mir f) ]))  %))", "user": "58c71509e4b021aa9917ed6e"}, {"problem": 96, "code": "#(let [tree-reverse (fn tree-reverse [coll]\n  (let [[v l r] coll]\n    (cond (seq? coll) (list v (tree-reverse r)\n                            (tree-reverse l))\n          (vector? coll) [v (tree-reverse r)\n                          (tree-reverse l)]\n          :else coll)))]\n  (= (tree-reverse %) %))", "user": "60460824e4b02d28681c77bc"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "601bdcb3e4b0bf4ca6b10930"}, {"problem": 96, "code": "(fn symmetric? [[_ L R]]\n  (if (not (coll? L))\n    true\n    (if (not (and (coll? L) (coll? R)))\n      false\n      (let [[LV LL LR] L\n            [RV RL RR] R]\n        (and (= LV RV) (symmetric? [nil LL RR]) (symmetric? [nil RL LR]))\n        )\n      )\n    )\n  )", "user": "5fb68f09e4b08cb800c85b58"}, {"problem": 96, "code": "(fn [tree]\n  (letfn [(mirror [[v L R :as t]]\n            (when t\n               [v (mirror R) (mirror L)]))]\n    (= tree (mirror tree))))", "user": "591e0782e4b09b4ee5954c25"}, {"problem": 96, "code": "(fn symmetric-binary-tree? [t]\n(letfn [(mirror-binary-tree [tree] \n  (if (nil? tree) \n    nil \n    [(first tree) \n     (mirror-binary-tree (last tree)) \n     (mirror-binary-tree (second tree))]))] \n  (= t (mirror-binary-tree t))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 96, "code": "(fn sym-tree? [t]\n   (= ((fn sym [t]\n         (if (nil? t)\n           t\n           [(first t)\n            (sym (last t))\n            (sym (second t))]))\n       (second t))\n      (last t)))", "user": "54be7c0de4b0ed20f4ff6eec"}, {"problem": 96, "code": "(fn [s]\n    (let [root first\n          left second\n          right #(nth % 2)]\n      (letfn [(mirror? [t1 t2]\n                (prn \"t1 \" t1)\n                (prn \"t2 \" t2)\n                (if (and (sequential? t1) (sequential? t2))\n                  (and (= (root t1) (root t2))\n                       (mirror? (left t1) (right t2))\n                       (mirror? (right t1) (left t2)))\n                  (= t1 t2)))]\n        (mirror? (left s) (right s)))))", "user": "6026d2cae4b0d5df2af22232"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "4e586949535d8a8b8723a292"}, {"problem": 96, "code": "(fn [tree]\n  (let [mirror-fn (fn mirror-fn [[v l r]]\n                     (if (nil? v) nil\n                       [v (mirror-fn r) (mirror-fn l)]))]\n    (= tree (mirror-fn tree))))", "user": "52f53589e4b05e3f0be25f2c"}, {"problem": 96, "code": "(letfn [(tree-eq? [t1 t2]\n                  (if (and (coll? t1) (coll? t2))\n                    (let [[v1 l1 r1] t1\n                          [v2 l2 r2] t2]\n                      (and (= v1 v2)\n                           (tree-eq? l1 r2)\n                           (tree-eq? r1 l2)))\n                    (= t1 t2)))]\n  (fn [[_ l r]] (tree-eq? l r)))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 96, "code": "(fn __ [[_ t1 t2]]\n  (letfn\n   [(mirror [t]\n      (if (seq t)\n        [(nth t 0) (mirror (nth t 2)) (mirror (nth t 1))]))]\n    (= t1 (mirror t2))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 96, "code": "(fn beauty-is-symmetry\n  [[head left right]]\n  (= left ((fn mirroring [[head left right :as %]]\n             (cond\n               (and (coll? left) (coll? right)) \n                    (conj [head] (mirroring right) (mirroring left))\n               (and (coll? left) (not (coll? right)))\n                    (conj [head] right (mirroring left))\n               (and (not (coll? left)) \n                    (coll? right)) (conj [head] (mirroring right) left)\n               :else (conj [head] right left))) right)))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 96, "code": "(fn symmetric? [node]\n  (letfn [(inorder [n]\n            (if (sequential? n)\n              (concat (inorder (nth n 1)) [(first n)] (inorder (nth n 2)))\n              [nil]))]\n    (if (sequential? node)\n      (= (reverse (inorder (nth node 1)))\n         (inorder (nth node 2)))\n      true)))", "user": "5edd05bfe4b0c7845d86b0f3"}, {"problem": 96, "code": "(fn f [[root left right]]\n  (let [mirror-f (fn mf [[root left right]]\n                   (vector root\n                           (if (nil? right)\n                             right\n                             (mf right))\n                           (if (nil? left)\n                             left\n                             (mf left))))]\n\n   (= left (mirror-f right))))", "user": "605b49b7e4b079a07f8593f8"}, {"problem": 96, "code": "(fn solve [[_ L R]]\n  (letfn [(f [x]\n            (if (coll? x)\n              [(first x)\n               (f (last x))\n               (f (second x))]\n              x))]\n\n    (= L (f R))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 96, "code": "(fn sbt? [x]\n(letfn \n  [(mbt [tree] \n  (if (nil? tree) \n    \n    nil \n    \n    [(first tree) \n     (mbt (last tree)) \n     (mbt (second tree))]\n    \n    )\n             )] \n  (= x (mbt x))))\n\n;;;letfn --> fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n;;;Takes a vector of function specs and a body, and generates a set of\n;;;bindings of functions to their names. All of the names are available\n;;;in all of the definitions of the functions, as well as the body.", "user": "6075c214e4b069485764de5b"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "60764350e4b069485764de5e"}, {"problem": 96, "code": "(fn [tree]\n  (let [fflip (fn flip [t]\n                (if (nil? t)\n                  nil\n                  (let [[v l r] t] [v (flip r) (flip l)])))]\n    (= (fflip (second tree)) (nth tree 2))))", "user": "606da089e4b069485764de15"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "607e1d32e4b03d835a6eaeda"}, {"problem": 96, "code": "(fn [x]\n  (letfn [(f [l r]\n             (if (every? nil? [l r])\n               true\n               (and\n                (every? coll? [l r])\n                (every? (comp not nil? first) [l r])\n                (= (first l) (first r))\n                (f (nth l 1) (nth r 2))\n                (f (nth l 2) (nth r 1)))))] (f x x)))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 96, "code": "(fn symmetry [[root left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond\n                    (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n  (mirror? left right)))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "60777335e4b0a637ed78034f"}, {"problem": 96, "code": "(fn sym?\n  ([t] (sym? (second t) (last t)))\n  ([a b] (or\n           (and (nil? a) (nil? b))\n           (if (and (coll? a) (coll? b))\n             (and (= (count a) (count b) 3)\n                  (= (first a) (first b))\n                  (sym? (second a) (last b))\n                  (sym? (last a) (second b)))\n             false))))", "user": "60471241e4b02d28681c77c9"}, {"problem": 96, "code": "(fn [n]\n  (letfn [(symmetric? [l r]\n            (if (or (coll? l) (coll? r))\n              (and (and (coll? l) (coll? r))\n                   (= (first l) (first r))\n                   (symmetric? (second (rest l)) (first (rest r)))\n                   (symmetric? (first (rest l))  (second (rest r))))\n              (= l r)))]\n    (and ((fn f [s]\n  (cond\n    (coll? s) (and (= 3 (count s)) (f (nth s 1)) (f (nth s 2)))\n    (nil? s) true\n    :else \n      false\n      )\n     ) n) (symmetric? (first (rest n)) (second (rest n))))))", "user": "6074f5ede4b069485764de52"}, {"problem": 96, "code": "(fn [[_ a b]]\n    (letfn [(mirror-tree [tree]\n                 (->> tree\n                 rest\n                 (map  #(cond ((complement coll?) %) %\n                              (some coll? %) (mirror-tree %)\n                              :else (cons (first %) (reverse (rest %)))))\n                 reverse\n                 (cons (first tree))))]\n    (= a (mirror-tree b))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 96, "code": "(fn\n[t]\n  (loop [tsl (vec ((vec t) 1)) tsr (vec ((vec t) 2))]\n    (if (and (empty? tsl) (empty? tsr))\n      true\n      (if (not (= (sort (flatten tsl)) (sort (flatten tsr))))\n        false\n        (if (and (not (sequential? (tsl 1))) (= (tsl 1) (tsr 2)))\n          (recur (tsl 2) (tsr 1))\n          (recur (tsl 1) (tsr 2))))\n\n      )\n    \n))", "user": "5dd70ee3e4b0948ae9d9ad85"}, {"problem": 96, "code": "(fn [a] (= ((fn mirror? [[root left right :as tree]] (when tree [root (mirror? right) (mirror? left)])) a) a))", "user": "6074e088e4b069485764de4d"}, {"problem": 96, "code": "(fn tree-sym? [[_ l r]]\n  (if (not (coll? l))\n    true\n    (if (not (and (coll? l) (coll? r)))\n      false\n      (let [[lv ll lr] l\n            [rv rl rr] r]\n        (and (= lv rv) (tree-sym? [nil ll rr]) (tree-sym? [nil rl lr]))\n))))", "user": "6074dfa4e4b069485764de4c"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] \n       (when \n         tree \n         [n (mirror r) (mirror l)]\n        )\n      ) \n   %) \n%)", "user": "6074e1e4e4b069485764de4f"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "607e1cf9e4b03d835a6eaed9"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "6086cdefe4b0736b099e4302"}, {"problem": 96, "code": "(fn beauty[n]\n  (=((fn sym[[l m p :as tree]]\n       (when tree[l(sym p)(sym m)])) n)n))", "user": "6085edade4b0736b099e42fc"}, {"problem": 96, "code": "(fn BeautyIsSymmetry [[s1 s2 s3]]\n  (let [rev (fn rev [[r1 r2 r3]] \n              (if (nil? r1) \n                nil\n                [r1 (rev r3) (rev r2)]))]\n    (= s2 (rev s3)) ))", "user": "607508f3e4b069485764de54"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "608828dee4b0ae75613dcee1"}, {"problem": 96, "code": "(fn [[center left right]]\n  (let [mirror? (fn mirror? [a b]\n                  (cond (not= (sequential? a) (sequential? b)) false\n                    (sequential? a) (let [[ra La Ra] a\n                                          [rb Lb Rb] b]\n                                      (and (= ra rb) (mirror? La Rb) (mirror? Lb Ra)))\n                    :else (= a b)))]\n(mirror? left right)))", "user": "607f3336e4b05857a65e7747"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "6088c22ee4b0ae75613dcee4"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "6074e278e4b069485764de51"}, {"problem": 96, "code": "(fn symmetric? [[root left right]]\n  (letfn [(reflective? [& subtree]\n                       (let [size (count subtree)]\n                         (cond\n                          (= size 2)\n                          \t(let [\n                                  lt (first subtree)\n                                  rt (last subtree)\n                                  root-lt (first lt)\n                                  root-rt (first rt)\n                                  left-lt (second lt)\n                                  left-rt (second rt)\n                                  right-lt (last lt)\n                                  right-rt (last rt)\n                                  ]\n                              (cond\n                               (and (nil? lt) (nil? rt))\n                               \t\ttrue\n                               (= root-lt root-rt)\n                               \t\t(and (reflective? left-lt right-rt) (reflective? left-rt right-lt))\n                               :else false\n                               )\n                              )\n                          :else false\n                          )\n                         )\n                       )]\n    (reflective? left right)\n   )\n  )", "user": "60752ef6e4b069485764de55"}, {"problem": 96, "code": "(fn [x] (= (second x)\n           ((fn re [x] \n              (if (coll? x)\n                (vector (first x) (re (last x)) (re (second x)))\n                x))\n            (last x))))", "user": "6081b7fce4b0736b099e42d4"}, {"problem": 96, "code": "(fn x [tree]\n  (letfn [(testlr [l r]            \n            (if-not (some coll? l)\n              (and (= (first l) (first r)) (= (rest l) (reverse (rest r))))\n              (and (testlr (nth l 1) (nth r 2)) (testlr (nth l 2) (nth r 1)))))]\n    (let [l (first (rest tree))\n          r (second (rest tree))]\n      (testlr l r))))", "user": "52bc6cb2e4b07a9af57922f5"}, {"problem": 96, "code": "(fn ans-96 [arr]\n  (if (nil? arr)\n    true\n    ((fn isSymmetry [tree1 tree2]\n       (if (and (nil? tree1) (nil? tree2))\n         true\n         (if (or (nil? tree1) (nil? tree2))\n           false\n           (and (= (first tree1) (first tree2))\n                (isSymmetry (second tree1) (last tree2)) (isSymmetry (last tree1) (second tree2))))))\n     (second arr) (last arr)\n     )))", "user": "608fac60e4b03bd49d9f36c7"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "6088395de4b0ae75613dcee2"}, {"problem": 96, "code": "(fn [tree]\n   (let [r (first tree), l (second tree), r (second (rest tree))]\n     (= l ((fn mirror [t]\n             (if (nil? t)\n               nil\n               (list (first t) (mirror (second (rest t))) (mirror (second t))))) r))))", "user": "60882700e4b0ae75613dcedf"}, {"problem": 96, "code": "(fn symmetric-tree?\n  [x]\n  (letfn [(symmetric?* [left right]\n            (if (every? sequential? [left right])\n              (and\n                (= (first left) (first right))\n                (symmetric?* (second left) (last right))\n                (symmetric?* (last left) (second right)))\n              (= left right)))]\n    (symmetric?* (second x) (last x))))", "user": "6098263be4b00e9e6653c3f9"}, {"problem": 96, "code": "(fn binary-tree-symmetrical?\n  [root]\n  (let [left-node (fn [root]\n                    (nth root 1 nil))\n        right-node (fn [root]\n                     (nth root 2 nil))\n        mirror?\n        (fn mirror? [root1 root2]\n          (println \"----- Comparing nodes\")\n          (println \"root1:\" root1)\n          (println \"root2:\" root2)\n          (cond\n            (and (empty? root1) (empty? root2))\n            true\n            (or (empty? root1) (empty? root2))\n            false\n            :else\n            (and (= (first root1) (first root2))\n                 (mirror? (left-node root1) (right-node root2))\n                 (mirror? (right-node root1) (left-node root2)))))]\n    (if (empty? root)\n      true\n      (mirror? (left-node root) (right-node root)))))", "user": "59b93cd7e4b0a024fb6ae3c7"}, {"problem": 96, "code": "(fn solve [tree]\n   (let [dfs (fn dfs [tree traversed left]\n               (let [node (first tree)\n                     c1 (second tree)\n                     c2 (nth tree 2)]\n                 (if (nil? tree)\n                   (conj traversed tree)\n                   (concat [node] \n                           (dfs (if left c1 c2) traversed left)\n                           (dfs (if left c2 c1) traversed left)))))\n         left-side (dfs (second tree) [] true )\n         right-side (dfs (nth tree 2) [] false)]\n     (= left-side right-side)))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 96, "code": "(fn [t]\n  (let [in-order (fn f[t] \n                   (if (nil? t)\n                     []\n                     (concat (f (second t)) (vector (first t)) (f (nth t 2)))))\n        t1 (in-order t)\n        t2 (reverse t1)]\n    (= t1 t2)))", "user": "58e90258e4b056aecfd47cfd"}, {"problem": 96, "code": "(fn [[_ left right]]\n  (letfn [(mirror [x]\n            (if-let [[root l r] (seq x)]\n              [root (mirror r) (mirror l)]\n              x))]\n    (= left (mirror right))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 96, "code": "(fn [tree]\n    ((fn iter [left right]\n        (cond\n            (and (nil? left) (nil? right)) true\n            (not (coll? left)) false\n            (not (coll? right)) false\n            (not (= 3 (count left))) false\n            (not (= 3 (count right))) false\n            (not (= (first left) (first right))) false\n            :else (and (iter (second left) (second (rest right))) (iter (second (rest left)) (second right))))) tree tree))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 96, "code": "(fn is-symmetric [s]\n  (letfn [(symmetric-flatten-tree [s]\n            (cond\n              ((complement sequential?) s) [s]\n              :else\n              (let [[root left right] s] (into [] (apply conj (apply conj [root] (symmetric-flatten-tree right)) (symmetric-flatten-tree left))))))]\n    (let [[root left right] s] (= (flatten left) (symmetric-flatten-tree right)))))", "user": "60b8b0f8e4b0e0fa5f1b425c"}, {"problem": 96, "code": "#((fn sym? [n1 n2]\n                (or (and (nil? n1) (nil? n2))\n                    (and (sequential? n1) (sequential? n2)\n                         (= (first n1) (first n2))\n                         (sym? (second n1) (last n2))\n                         (sym? (last n1) (second n2)))))\n  (second %) (last %))", "user": "5e471203e4b043cd24807a2a"}, {"problem": 96, "code": "(fn [t]\n  (letfn [(mirror [t]\n            (if (and (coll? t) (= 3 (count t)))\n              (let [[v lc rc] t]\n                [v (mirror rc) (mirror lc)])\n              t))]\n          (= t (mirror t))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 96, "code": "(fn mirror? [[_ l r]]\n  (cond (not= (coll? l) (coll? r)) false\n        (coll? l) (let [[lv ll lr] l\n                        [rv rl rr] r]\n                    (and (= lv rv) (mirror? [nil ll rr]) (mirror? [nil lr rl])))\n        :else (= l r)))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 96, "code": "(fn symmetric? [[root left right]]\n  (let [check (fn check [left-subtree right-subtree]\n                (println \"Left Subtree: \" left-subtree)\n                (println \"Right subtree: \" right-subtree)\n                (let [[left-subtree-root left-subtree-left left-subtree-right] left-subtree\n                      [right-subtree-root right-subtree-left right-subtree-right] right-subtree]\n                  (if (and (nil? left-subtree) (nil? right-subtree))\n                    true\n                    (and (= left-subtree-root right-subtree-root)\n                         (check left-subtree-left right-subtree-right)\n                         (check left-subtree-right right-subtree-left)))))]\n    (if (nil? root) true (check left right))))", "user": "60b3b8a9e4b0e0fa5f1b4233"}, {"problem": 96, "code": "(fn [t] (= (nth t 1) (nth (clojure.walk/postwalk #(if (sequential? %) [(first %) (nth % 2) (nth % 1)] %) t) 1)))", "user": "51bd78c3e4b0ff155d51d2b0"}, {"problem": 96, "code": "(fn symetric?[[h ll rl]]\n  (letfn [(flip-tree[[h ll rl]]\n            (cons h\n                  (cond (and (nil? ll) (nil? rl)) (list nil nil)\n                        (and (nil? ll) (coll? rl)) (list (flip-tree rl) nil)\n                        (and (coll? ll) (nil? rl)) (list nil (flip-tree ll))\n                        :else (list (flip-tree rl) (flip-tree ll)))))]\n    (= ll (flip-tree rl))))", "user": "60c91f48e4b0e0fa5f1b4304"}, {"problem": 96, "code": "#(= ((fn mirror [[n l r :as tree]] (when tree [n (mirror r) (mirror l)])) %) %)", "user": "5aba04dce4b073f17744269e"}, {"problem": 96, "code": "(fn symmetric? [t]\n   (letfn [(mirror? [t1 t2]\n             (or\n               (and (nil? t1) (nil? t2))\n               (and (= (first t1) (first t2))\n                    (mirror? (nth t1 1) (nth t2 2))\n                    (mirror? (nth t1 2) (nth t2 1)))))]\n     (mirror? (nth t 1) (nth t 2))))", "user": "4fe49706e4b0e8f79898feb7"}]