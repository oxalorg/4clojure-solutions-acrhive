[{"code": "(fn [n]\n  (iterate \n    #(let [sub_l (inc (read-string (apply str (take (Math/ceil (/ (count (str %)) 2)) (str %)))))\n           sub_r ((if (odd? (count (str %))) rest seq) (reverse (str sub_l)))]\n       (if (every? #{\\9} (str %))\n         (+ 2 %)\n         (read-string (apply str sub_l sub_r))))\n    (#(if (= (seq (str %)) (reverse (str %))) % (recur (inc %))) n)))", "problem": 150, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [low]\n  (let [mkpalin (fn [sn odd]\n                  (Long/parseLong \n                    (str sn \n                      ((comp \n                        (partial apply str) \n                        (if odd rest identity) \n                        reverse) sn))))\n        nextparams (fn [sn n odd]\n                      (if (= #{\\9} (set sn)) \n                        (if odd [(inc (quot n 10)) false]\n                          [(inc n) true])\n                        [(inc n) odd]))\n        sl (str low)\n        len (count sl)\n        temp-odd (odd? len)\n        hlen (+ (quot len 2) (if temp-odd 1 0))\n        [odd start] (if (< low 10000)\n                      [true 100] \n                      [temp-odd (Long/parseLong (subs sl 0 hlen))])]\n    (drop-while (partial > low)\n      (lazy-cat '(0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161 171 181 191 202 212 222 232 242 252 262 272 282 292 303 313 323 333 343 353 363 373 383 393 404 414 424 434 444 454 464 474 484 494 505 515 525 535 545 555 565 575 585 595 606 616 626 636 646 656 666 676 686 696 707 717 727 737 747 757 767 777 787 797 808 818 828 838 848 858 868 878 888 898 909 919 929 939 949 959 969 979 989 999 1001 1111 1221 1331 1441 1551 1661 1771 1881 1991 2002 2112 2222 2332 2442 2552 2662 2772 2882 2992 3003 3113 3223 3333 3443 3553 3663 3773 3883 3993 4004 4114 4224 4334 4444 4554 4664 4774 4884 4994 5005 5115 5225 5335 5445 5555 5665 5775 5885 5995 6006 6116 6226 6336 6446 6556 6666 6776 6886 6996 7007 7117 7227 7337 7447 7557 7667 7777 7887 7997 8008 8118 8228 8338 8448 8558 8668 8778 8888 8998 9009 9119 9229 9339 9449 9559 9669 9779 9889 9999)\n        ((fn f [n odd]\n          (let [sn (str n)\n                palin (mkpalin sn odd)\n                [nextn nextodd] (nextparams sn n odd)]\n            (lazy-seq (cons palin (f nextn nextodd)))))\n          start (odd? len))))))", "problem": 150, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [n]\n  (letfn [\n    (fr-to-num [fr even]\n      (let [rev (reverse fr)\n        bk (apply str (if even rev (rest rev)))]\n        (Long/parseLong (str fr bk))))\n    (initial-pal [n]\n      (let [s (str n)\n        c (count s) \n        even (zero? (rem c 2))\n        fr (subs s 0 (quot (inc c) 2))\n        cand (fr-to-num fr even)]\n        (if (< cand n) (next-pal cand) cand)))\n    (next-pal [n]\n      (let [s (str n)\n        c (count s)\n        even (zero? (rem c 2))\n        fr (subs s 0 (quot (inc c) 2))\n        fr2 (str (inc (Long/parseLong fr)))]\n        (if (> (count fr2) (count fr))\n          (fr-to-num \n            (if even fr2 (apply str (butlast fr2)))\n            (not even))\n          (fr-to-num fr2 even))))]\n    (iterate next-pal (initial-pal n))))", "problem": 150, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn [n]\n  (let [d #(loop [m % i 0]\n            (if (> m 0)\n              (recur (quot m 10) (inc i))\n              i))\n        r #(loop [m % a 0]\n            (if (> m 0)\n              (recur (quot m 10) (* 10 (+ a (rem m 10))))\n              (/ a 10)))\n        p #(loop [i % a 1]\n            (if (> i 0)\n              (recur (dec i) (* 10 a))\n              a))\n        t #(p (quot (d %) 2))\n        w #(let [k (t %)\n                 q (- % (rem % k) (- k))] \n             (+ q (rem (r q) (if (= 9 %) 11 k))))\n        k (t n)\n        q (- n (rem n k))\n        v (+ q (rem (r q) k))\n        m (if (>= v n) v (w n))]\n    (iterate w m)))", "problem": 150, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [q] (map first (let [s (str q)\n              d (count s)\n              h (quot (+ 1 d) 2)\n              y (quot d 2)\n              l (Long/decode (apply str (take h s)))\n              j (fn [p d h] (Long/decode\n                  (apply str (concat p (reverse (take (- d h) p))))))\n              x (j (str l) d h)\n              z (if (< x q) [(j (str (+ 1 l)) d h) (+ 1 l) h d] [x l h d])]\n  (iterate (fn [[n l h d]] (if (every? (fn [v] (= \\9 v)) (seq (str n))) (let [\n                                                          m (+ 2 n)\n                                                          s (str m)\n                                                          w (count s)\n                                                          r (quot (+ 1 w) 2)\n                                                          t (Long/decode (apply str (take r s)))]\n                                                              [m t r w])\n    (let [m (+ 1 l)]\n      [(j (str m) d h) m h d])))\nz))))", "problem": 150, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [x] \n  (letfn [(digits [x] (seq (str x)))\n          (undigits [x] (Long/parseLong (apply str x)))\n          (even [x] (zero? (rem (count (digits x)) 2)))\n          (firsthalf [x] (take (/ (+ (count (digits x)) (if (even x) 0 1)) 2) (digits x)))\n          (right-for-left [left x] (reverse (if (even x) left (butlast left))))\n          (mk-palindrome [x] (let [left (firsthalf x) right (right-for-left left x)] (undigits (concat left right))))\n          (inc-palindrome [x] (if (every? #(= \\9 %) (digits x)) (+ x 2) (let [left (digits (inc (undigits (firsthalf x)))) right (right-for-left left x)] (undigits (concat left right)))))\n          (lazy-palindrome [x] (cons x (lazy-seq (lazy-palindrome (inc-palindrome x)))))]\n    (drop-while #(< % x) (lazy-palindrome (mk-palindrome x)))))", "problem": 150, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn __ [n]\n    (letfn [(stoi [ss]\n             (let [n (count ss)]   \n                 (if (>  n 9) (+ (* (stoi (subs ss 0 (- n 9)))  1000000000) (Integer/parseInt (subs ss (- n 9) n)))\n                      (Integer/parseInt ss))))\n            (m1 [s] (str (inc (stoi s))))\n            (genera [s p]\n               (let [m (count s) m0 (quot m 2) s0 (subs s 0 m0)]                 \n                 (stoi \n                    (if (zero? p) (apply str (concat s (reverse s)))\n                      (apply str (concat s (reverse (butlast s))))))))    \n         (mas [n]\n        (let [s (str n) m (count s) m0 (quot m 2) \n              s0 (subs s 0 (quot (inc m) 2)) s1 (m1 s0)]\n          (cond (= s (apply str (repeat m \\9))) (+  n 2)      \n                (even? m) (genera s1 0)\n                :else     (genera s1 1))))     \n     (inicia [n]\n               (let [s (str n) m (count s) m0 (quot m 2) \n                s0 (subs s 0 (quot (inc m) 2))\n                n1 (cond (= s (apply str (repeat m \\9))) n      \n                      (even? m) (genera s0 0)\n                       :else     (genera s0 1))]               \n                (if (<= n n1) n1 (mas n1))))]     \n  (iterate mas (inicia n))))", "problem": 150, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn [number]\n  (let [half (apply str (take (Math/ceil (/ (count (str number)) 2)) (str number)))\n        first-pal (Long/parseLong (apply str half (reverse (take (int (/ (count (str number)) 2)) half)) ))\n        pals (iterate \n              (fn [number] (let [str-num (str number)\n                     c (count str-num)\n                     half (int (/ c 2))\n                     suffix (drop half str-num)\n                     x (count (drop-while #{\\9} suffix))\n                     add (int (cond\n                               (and (> x half) (odd? c)) (Math/pow 10 half)\n                               (= 0 x) 2\n                               :else (* 11 (Math/pow 10 (dec x)))))]\n                            (+ number add)))\n               first-pal)]\n    (drop-while (partial > number) pals)))", "problem": 150, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn prob-0150\n  [lim]\n  (letfn [(powers-of-10\n            []\n            (iterate (partial * 10) (bigint 1)))\n\n          (make-pal\n            [pre mid]\n            (let [pre-str (str pre)\n                  mid-str (if (nil? mid) \"\" (str mid))\n                  pst-str (reverse pre-str)\n                  num-str (apply str pre-str mid-str pst-str)]\n              (bigint num-str)))\n\n          (pals\n            [st-pre st-mid]\n            (lazy-seq\n             (let [base         (last (take-while #(<= % st-pre) (powers-of-10)))\n         \n                   lim          (* 10 base)\n\n                   nums-alone   (if (nil? st-mid)\n                                  (for [pre (range st-pre lim)]\n                                    (make-pal pre nil))\n                                  [])\n\n                   pre-base     (if (nil? st-mid) base st-pre) \n                   mid-base0    (if (nil? st-mid) 0 st-mid)\n                   mid-lim0     (min (inc pre-base) lim)\n         \n                   nums-mid0   (for [pre (range pre-base mid-lim0), mid (range mid-base0 10)]\n                                 (make-pal pre mid))\n\n                   nums-mid1   (for [pre (range (inc pre-base) lim), mid (range 10)]\n                                 (make-pal pre mid)) ]\n               (lazy-cat nums-alone nums-mid0 nums-mid1 (pals lim nil)))))\n\n          (digits-of\n            [n]\n            (map #(Long/parseLong (str %)) (seq (str n))))\n\n          ]\n\n    (let [first-10k [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161 171 181 191 202 212 222 232 242 252 262 272 282 292 303 313 323 333 343 353 363 373 383 393 404 414 424 434 444 454 464 474 484 494 505 515 525 535 545 555 565 575 585 595 606 616 626 636 646 656 666 676 686 696 707 717 727 737 747 757 767 777 787 797 808 818 828 838 848 858 868 878 888 898 909 919 929 939 949 959 969 979 989 999 1001 1111 1221 1331 1441 1551 1661 1771 1881 1991 2002 2112 2222 2332 2442 2552 2662 2772 2882 2992 3003 3113 3223 3333 3443 3553 3663 3773 3883 3993 4004 4114 4224 4334 4444 4554 4664 4774 4884 4994 5005 5115 5225 5335 5445 5555 5665 5775 5885 5995 6006 6116 6226 6336 6446 6556 6666 6776 6886 6996 7007 7117 7227 7337 7447 7557 7667 7777 7887 7997 8008 8118 8228 8338 8448 8558 8668 8778 8888 8998 9009 9119 9229 9339 9449 9559 9669 9779 9889 9999]]\n\n      (filter\n       #(>= % lim) \n       (if (< lim 10000)\n         (lazy-cat first-10k (prob-0150 10000))\n         (let [digs     (digits-of lim)\n               pre-digs (take (int (/ (count digs) 2)) digs)\n               mid-dig  (if (odd? (count digs))\n                          (nth digs (count pre-digs))\n                          nil)\n\n               pre      (bigint (apply str pre-digs))]\n           (lazy-cat (pals pre mid-dig))))))))", "problem": 150, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn palins [n]\n\t(let [np (fn [n step]\n\t\t\t\t\t(let [s (str n) hl (quot (count s) 2)]\n\t\t\t\t\t(if (and (pos? step) (apply = \\9 s))\n\t\t\t\t\t\t(+ 2 n)\n\t\t\t\t  \t\t(let [h (->> (drop-last hl s) (apply str) read-string (+ step) str)]\n\t\t\t\t\t\t\t(read-string (apply str h (reverse (take hl h))))))))]\n\t\t\t(drop-while #(< % n) (iterate #(np % 1) (np n 0)))))", "problem": 150, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn p [x] \n   (let [a (map #(- (int %) 48) (str x))\n         r (rem (count a) 2)\n         h (fn h ([x] (h x 0)) ([x r] (take (+ (quot (count x) 2) r) x)))\n         m (fn [x] (reduce #(+ (* 10 %) %2) 0 (concat (h x r) (reverse (h x)))))\n         c #(loop [l (reverse %) c 1 r '()] \n               (let [d (+ (first l) c)\n                     q (quot d 10)\n                     m (mod d 10)\n                     c (cons m r)]\n                 (if (next l) \n                   (recur (rest l) q c)\n                   (if (= q 0) c (cons 1 c)))))\n         g (m a)\n         s (if (>= g x) g (m (concat (c (h a r)) (h a))))] \n     (lazy-seq (cons s (p (inc s))))))", "problem": 150, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [n]\n  (letfn [(digits [x]\n            (loop [x x s []]\n              (if (zero? x)\n                (reverse s)\n                (recur (quot x 10) (conj s (rem x 10))))))\n          (stigid [s] (reduce #(+ (* 10 %) %2) 0 s))\n          (next-pal [n]\n            (let [ds (digits n) dn (count ds)]\n              (cond\n                (zero? n) 1\n                (every? #{9} ds) (+ 2 n)\n                (= 1 dn) (inc n)\n                (= 2 dn) (+ 11 n)\n                :else\n                (let [es ((comp digits inc stigid)\n                          (take (+ (quot dn 2) (bit-and dn 1)) ds))]\n                  (stigid\n                   (concat (if (odd? dn) (butlast es) es)\n                           (reverse es)))))))\n          (pal? [n] (let [s (digits n)] (= (reverse s) s)))]\n    (iterate next-pal (some #(if (pal? %) %) (iterate inc n)))))", "problem": 150, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(let [f (fn [n]\n          (let [s (str n) l (count s)\n                a (subs s 0 (Math/ceil (/ l 2)))\n                b (str (inc (read-string a)))]\n            (first\n              (filter #(>= % n)\n                (map\n                  #(read-string\n                     (str\n                       %\n                       (subs (clojure.string/reverse %) (if (odd? l) 1 0))))\n                  [a b])))))]\n  #(iterate (comp f inc) (f %)))", "problem": 150, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [n]\n    (let [to-digits (fn r [n]\n                      (if (< n 10)\n                        [n]\n                        (conj (r (quot n 10)) (mod n 10))))\n          ;; build palindrome less than n but close or first palindrome after n\n          start (fn start\n                  ([ds] (start ds 0 (dec (count ds))))\n                  ([ds i j]\n                     (if (#{1 0} (- i j))\n                       ds\n                       (start (assoc ds j (ds i))\n                              (inc i) (dec j)))))\n          begin (start (to-digits n))\n          ;; next palindrome from palimdrome\n          ;; inc digit in the middle\n          ;; i moves left, j moves right always (= (ds i) (ds j))\n          bump (fn bump\n                 ([ds] (let [nds (count ds)\n                             j (int (/ nds 2))\n                             i (if (odd? nds) j (dec j))]\n                         (bump ds i j)))  \n                 ([ds i j]\n                    (if (= (ds i) 9)\n                      (if (= i 0) ;; pad with new digit when 99 -> 101\n                        (vec (concat [1]\n                                     (-> ds\n                                         (assoc i 0)\n                                         (assoc j 1))))\n                        (bump (-> ds\n                                  (assoc i 0)\n                                  (assoc j 0))\n                              (dec i)\n                              (inc j)))\n                      (if (= i j)\n                        (update-in ds [i] inc)\n                        (-> ds\n                            (update-in [i] inc)\n                            (update-in [j] inc))))))]\n      (->> (iterate bump begin)\n           (map (partial reduce #(+ (* %1 10) %2)))\n           (drop-while #(< % n)))))", "problem": 150, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [N]\n  (letfn [(dig [u] (vec (map (zipmap \"0123456789\" (range)) (str u))))\n          (np [d]   \n             (let [k (quot (count d) 2)\n                   l (subvec d 0 k)\n                   m (nth d k)\n                   S (set d)]\n               (if (and (S 9) (= 1 (count S)))\n                  (dig (+ (Long/valueOf (apply str d)) 2))\n                  (vec (if (odd? (count d))\n                      (if (< m 9)\n                       (concat l [(inc m)] (reverse l))\n                       (let [ln (dig (+ (Long/valueOf (apply str l)) 1))]\n                         (concat ln [0] (reverse ln))) )\n                      ;even:\n                      (if (< (last l) 9)\n                       (let [lp (assoc l (- k 1) (inc (last l)))]\n                         (concat lp (reverse lp)))\n                       (let [ln (dig (+ (Long/valueOf (apply str l)) 1))]\n                         (concat ln (reverse ln))) ))))))\n          (f [n]\n             (lazy-seq (cons (Long/valueOf (apply str n)) \n                             (f (np n)))) ) ]\n\n    (let [d (dig N)\n          p0 (if (= d (reverse d))\n                d\n                (let [ k (quot (count d) 2)\n                       l (subvec d 0 k)\n                       m (if (odd? (count d)) [(nth d k)])\n                       p (vec (concat l m (reverse l)))\n                       pv (Long/valueOf (apply str p)) ]\n                   (if (> pv N) p (np d)) ))] \n    (f p0))))", "problem": 150, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [n]\n  (letfn [(r [s] (apply str (reverse s)))\n          (g [s c]\n            (read-string (str s (r (subs s 0 (quot c 2))))))\n          (f [n]\n            (let [s (str n)\n                  c (count s)]\n              (if (every? #(= \\9 %) s) (+ n 2)\n                  (let [t (subs s 0 (quot (inc c) 2))\n                        l (g t c)\n                        u (str (inc (read-string t)))\n                        m (g u c)]\n                    (if (> l n) l m)))))]\n    (drop-while #(not= (str %) (r (str %))) (iterate f n))))", "problem": 150, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn palindromic-numbers [n]\n  (let [digits (str n)\n        make-palindrome (fn [s c]\n                          (read-string (apply str s (if (even? (count digits))\n                                                      (clojure.string/reverse s)\n                                                      [c (clojure.string/reverse s)]))))\n        s (subs digits 0 (quot (count digits) 2))\n        c (get digits (count s))\n        m (make-palindrome s c)\n        x (if (>= m n)\n            m\n            (if (or (even? (count digits)) (= c \\9))\n              (make-palindrome (str (inc (Integer/parseInt s))) \\0)\n              (make-palindrome s (char (inc (int c))))))\n        f (Math/pow 10 (count s))\n        y (long (* (inc (quot x f)) f))]\n    (lazy-seq (cons x (palindromic-numbers y)))))", "problem": 150, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn palindromic-numbers [x]\n  (let [seed (fn [n]\n               (apply str\n                      (take (quot (inc (count (str n))) 2) (str n))))\n  p (Long/valueOf\n           (apply str\n                  (concat (seed x)\n                          (apply str (reverse\n                           (take\n                            (quot (count (str x)) 2)\n                            (seed x)))))))\n\tpseq\n\t(fn pseq [n]\n          (let [\n                nn (str (+ (Long/valueOf (seed n)) 1))\n\t\tm (if (every? #(= % \\9) (str n)) (+ n 2)\n                   (Long/valueOf\n                    (apply str\n                           (concat\n                            nn\n                            (apply str\n                                   (reverse\n                                    (take (quot (count (str n)) 2) nn)))))))]\n            (cons m (lazy-seq (pseq m)))))]\n    (if (> x p)\n      (pseq p)\n      (cons p (lazy-seq (pseq p))))))", "problem": 150, "user": "4f0e995e535d0136e6c22326"}, {"code": "(letfn\n  [(num->digits [n]\n     (loop [acc () n n]\n       (if (> 10 n)\n         (conj acc n)\n         (let [q (quot n 10) r (rem n 10)]\n           (recur (conj acc r) q)))))\n   (digits->num [ds]\n     (loop [ds ds n 0]\n       (if (empty? ds) n\n         (recur (rest ds) (+ (* 10 n) (first ds))))))\n   (parts [s]\n     (let [N (count s)\n           middle (/ N 2)]\n       (split-at middle s)))\n   (first-half [s] (first (parts s)))\n   (last-half [s] (second (parts s)))\n   (mirror [digits]\n     \"[1 2 3 | 4 5] -> [1 2 3 | 2 1] -> [1 2 3 2 1]\"\n     (let [N (count digits)\n           half (first-half digits)]\n       (if (even? N)\n         (concat half (reverse half))\n         (concat half (reverse (butlast half))))))\n   (palindrome? [n]\n     (let [ds (num->digits n)]\n       (= ds (reverse ds))))\n   (next-palindrome [n]\n     (let [ds (num->digits n)\n        npal-ds (mirror ds)\n           npal (digits->num npal-ds)]\n       (if (> npal n) npal\n         (let [half (first-half ds) ;; need to increment\n               new-half (-> half digits->num inc num->digits)\n               ds (concat new-half (last-half ds))]\n           (digits->num (mirror ds))))))]\n  (fn [n]\n    (if (palindrome? n)\n      (iterate next-palindrome n)\n      (iterate next-palindrome (next-palindrome n)))))", "problem": 150, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn j [r]\n  (let [m (if (odd? (count (str r))) :o :e)\n        v (.substring (str r) 0 (+ (if (= m :o) 1 0) (quot (count (str r)) 2)))]\n    (drop-while #(< % r) (\n(fn s [v m]\n  (lazy-seq\n   (let [r (apply str (reverse (str v)))\n         rs (Long. (str v (if (= m :o) (.substring r 1) r)))\n         o (not (= (count (str v)) (count (str (inc v)))))\n         nv (if (and o (= m :o)) (/ (inc v) 10) (inc v))\n         nm (if o (if (= m :o) :e :o) m)]\n     (cons rs (s nv nm))))) (Long. v) m))))", "problem": 150, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn f[num]\n  (let [\n  \t\t\t\tnum-left (fn [num]\n             (subs num 0 (/ (count num) 2))\n\t\t\t\t\t)\n          num-trim (fn [num]\n             (subs num 0 (dec (count num)))\n          )\n\t\t\t\t\t\n\t\t\t\t\tnum-center (fn [num]\n\t\t\t\t\t  (let [n (count num)]\n\t\t\t\t\t    (if (zero? (mod n 2)) nil (str (.charAt num (int (/ n 2)))))\n\t\t\t\t\t  )\n\t\t\t\t\t)\n     \n          next-num (fn [num]\n             (str (inc (bigint num)))\n          )\n\t\t\t\t\t\n\t\t\t\t\tlast-num (fn [num]\n\t\t\t\t\t  (not (= (count num) (count (next-num num))))\n\t\t\t\t\t)\n\t\t\t\t\t\n\t\t\t\t\tinvert (fn [num]\n\t\t\t\t\t  (apply str (reverse num))\n\t\t\t\t\t)\n\t\t\t\t\t\n\t\t\t\t\tassemble (fn [left center]\n\t\t\t\t\t  (bigint (str left center (invert left)))\n\t\t\t\t\t  )\n     \n\t\t\t\t\tisp (fn isp[num]\n\t\t\t\t\t\t(if (< (count num) 2) \n\t            true\n\t            (and \n\t              (= (first num) (last num))\n\t              (isp (-> num next drop-last))\n\t            )\n\t          )\n          )\n          \n        nextp (fn nextp[num0]\n\t\t\t\t\t  (let [\n                  num (str num0)\n                  num-size (count num)\n\t\t\t\t\t        left-part (num-left num)\n\t\t\t\t\t        center-part (num-center num)\n\t\t\t\t\t        ]\n              (if (= num \"9\") (bigint 11)\n\t\t\t\t\t     (if (= 1 num-size) \n                  (bigint (next-num num))\n\t\t\t\t\t        (if (nil? center-part)\n\t\t\t\t\t          (if (last-num left-part)\n\t\t\t\t\t            (assemble (num-trim (next-num left-part)) \"0\") \n\t\t\t\t\t            (assemble (next-num left-part) nil)\n\t\t\t\t\t          )\n\t\t\t\t\t          (if (= \"9\" center-part)\n\t\t\t\t\t            (if (last-num left-part)\n\t\t\t\t\t              (assemble (next-num left-part) nil)\n\t\t\t\t\t              (assemble (next-num left-part) \"0\" )\n\t\t\t\t\t            )\n\t\t\t\t\t            (assemble left-part (next-num (str center-part)))\n\t\t\t\t\t          )\n\t\t\t\t\t       )\n\t\t\t\t\t     )\n\t\t\t\t\t    )\n\t\t\t\t\t  )\n\t\t\t\t\t)\n       ]\n(let [num1 (bigint num)] \n  (if (isp (str num1))\n\t  (iterate nextp num1)\n    (let [\n          nums (str num1)\n          left-part (num-left nums)\n\t\t\t\t\tcenter-part (num-center nums)\n          poly (assemble left-part center-part)\n          ]\n      (if (> poly num1)\n        (concat [(bigint poly)] (next (iterate nextp num1)))\n        (next (iterate nextp num1))  \n        )\n    )\n))\n)\n)", "problem": 150, "user": "4f245d77e4b0d66497709feb"}, {"code": "(fn lazypal [n]\n  (letfn [(parsenum [strval]\n            (if (empty? strval) \"0\" (read-string (str \"10r\" strval))))\n\n          (basepal [n]\n            (let [nstr (str n)\n                  len (count nstr)\n                  midpoint (quot len 2)]\n              (if (odd? len)\n                [(parsenum (subs nstr 0 (+ 1 midpoint))) true]\n                [(parsenum (subs nstr 0 midpoint))       false])))\n\n          (pal [[n mid?]]\n            (let [nstr (str n)\n                  nlen (count nstr)\n                  fstr (if mid? (subs nstr 0 (- nlen 1)) nstr)\n                  frev (clojure.string/reverse fstr)\n                  midstr (if mid? (subs nstr (- nlen 1) nlen) \"\")]\n              (parsenum (str fstr midstr frev))))\n\n          (nextbase [[n mid?]]\n            (let [nextn (inc n)]\n              (if (> (count (str nextn)) (count (str n)))\n                (if mid?\n                  [(quot nextn 10) false]\n                  [nextn true])\n                [nextn mid?])))\n\n          (nextpal [n]\n            (if (< n 0) 0\n                (let [base (basepal n)\n                      curpal (pal base)]\n                  (if (> curpal n)\n                    curpal\n\n                    (let [nextb (nextbase base)]\n                      (pal nextb))))))]\n\n    (let [firstpal (nextpal (dec n))]\n      (iterate nextpal firstpal))))", "problem": 150, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn pal-seq [n]\n    (letfn [(get-next-palindrom [n]\n                (letfn [(take-half [ds] (drop-last (quot (count ds) 2) ds))\n                        (dig-seq-to-num [ds] (reduce #(+ (* % 10) %2) 0 ds))\n                        (num-to-dig-seq [n] (map #(- (int %) 48) (str n)))\n                        (with-mirror [ds]\n                            (into (into [] ds)\n                                (reverse\n                                    (if (and (even? (-> n num-to-dig-seq count)) (last ds))\n                                        ds\n                                        (butlast ds)))))]\n                    (let [half (-> n num-to-dig-seq take-half)\n                          np (-> half with-mirror dig-seq-to-num)]\n                        (if (>= np n)\n                            np\n                            (-> half dig-seq-to-num\n                                inc num-to-dig-seq with-mirror dig-seq-to-num)))))]\n        (let [np (get-next-palindrom n)]\n            (lazy-seq (cons np (pal-seq (inc np)))))))", "problem": 150, "user": "4f128865535d64f603146428"}, {"code": "(let [rs read-string\n      t (iterate #(* 10 %) 1)\n      g #(apply str % %2 (reverse (str %)))\n      k (fn [x] (first (filter #(< x %) t)))]\n  (fn [x]\n    (->> x\n      (max 10)\n      ((fn f [x]\n         (let [s (str x)\n               c (count s)\n               y (rs (subs s 0 (quot c 2)))\n               z (range y (k y))]\n              (lazy-cat\n                (if (odd? c)\n                  (for [a z b (range 0 10)] (g a b))\n                  (map #(g % \"\") z))\n                (f (k x))))))\n      (map rs)\n      (concat (range 10))      \n      (remove #(< % x)))))", "problem": 150, "user": "4f08b15b535dcb61093f6c40"}, {"code": "#(drop-while\n    (partial > %)\n    (iterate\n     (fn [n]\n       (letfn [(x->s [x] (map (fn [ch] (- (int ch) 48)) (str x)))\n               (s->x [s] (reduce (fn [x k] (+ (* 10 x) k)) s))\n               (p [x] (int (Math/pow 10 x)))]\n         (let [s (x->s n) \n               c (count s) r (rem c 2)\n               c* (+ (quot c 2) r) s* (take c* s)\n               x (s->x s*)\n               x (if (<= (s->x (reverse s*)) (s->x (drop (quot c 2) s))) (inc x) x)\n               [x* r*]\n               (if (< x (p c*)) [x r]\n                   [(p (- c* r)) (- 1 r)])\n               d (x->s x*)]\n           (s->x (concat d (drop r* (reverse d)))))))\n     (max (dec %) 0)))", "problem": 150, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn gen-palins\r\n  [n]\r\n\t(letfn [\r\n\t\t\t\t\t(is-palindrome? [s]\r\n\t\t\t\t\t\t(if (<= (count s) 1)\r\n\t\t\t\t\t\t\ttrue\r\n\t\t\t\t\t\t\t(and (= (first s) (last s))\r\n\t\t\t\t\t\t\t\t\t (is-palindrome? (subs s 1 (dec (count s)))))))\r\n\r\n\t\t\t\t  (is-palindrome-int? [n] (is-palindrome? (str n)))\r\n\t\t\t\t\t\r\n\t\t\t\t\t(find-nearest-palindrome [n]\r\n\t\t\t\t\t\t(loop [ret n]\r\n\t\t\t\t\t\t\t(if (is-palindrome-int? ret)\r\n\t\t\t\t\t\t\t\tret\r\n\t\t\t\t\t\t\t\t(recur (inc ret)))))\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t(gen-next-palindrome [n]\r\n\t\t\t\t\t\t(let [n (find-nearest-palindrome n),\r\n\t\t\t\t\t\t\t\t\tlen (count (str n))\r\n\t\t\t\t\t\t\t\t\tparity (mod len 2),\r\n\t\t\t\t\t\t\t\t\td (- 11 parity),\r\n\t\t\t\t\t\t\t\t\tl (dec (int (/ len 2))),\r\n\t\t\t\t\t\t\t\t\tm (Math/pow 10 l),\r\n\t\t\t\t\t\t\t\t\tdelta (int (* d m)),\r\n\t\t\t\t\t\t\t\t\tguess (+ n delta)]\r\n\t\t\t\t\t\t\t(let [center_digit (mod (int (/ n (int (Math/pow 10 (int (/ len 2)))))) 10)]\r\n\t\t\t\t\t\t\t\t(if (= center_digit 9)\r\n\t\t\t\t\t\t\t\t\t(find-nearest-palindrome (inc n))\r\n\t\t\t\t\t\t\t\t\tguess))))\r\n\t\t\t\t ]\r\n\r\n\t\t(iterate gen-next-palindrome (find-nearest-palindrome n))))", "problem": 150, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [n]\n  (let [t (partial apply str)\n    r read-string\n    num (if (not= (seq (str n)) (reverse (str n)))\n              (first (drop-while #(not= (seq (str %)) (reverse (str %))) (iterate inc n)))\n              n)\n        p \n#(let [s (str %) b (str (inc (r (t (take ((if (odd? (count s)) inc identity) (quot (count s) 2)) s)))))]\n    (r\n      (if (every? #{\\9} s)\n      (t (concat [1] (repeat (dec (count s)) 0) [1]))\n      (str b (t (drop (if (odd? (count s)) 1 0) (reverse b)))))))]\n    (iterate p num)))", "problem": 150, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(letfn [(l [x & m]\n            (if (= 0 x)\n              m\n              (recur (long (/ x 10)) (cons (rem x 10) m))))\n        (n [l]\n            (reduce #(+ (* 10 %) %2) l))\n        (f [x] \n           (if (< x 10)\n             x\n             (let [s (l x)\n                   v (partition-all (/ (count s) 2) s)\n                   r reverse\n                   w (first v)\n                   a (n w)\n                   b (n (second v))\n                   g #(if (>= %2 %3)\n                        (concat (l %) (%4 (l %)))\n                        (concat (l (inc %)) (%4 (l (inc %)))))]\n               (n (if (odd? (count s))\n                     (g a (n (rest (r w))) b (comp rest r))\n                     (g a (n (r w)) b r))))))]\n       #(iterate (comp f inc) (f %)))", "problem": 150, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [n]\n    (letfn [(palindrome? [n] (= (str n) (apply str (reverse (str n)))))\n            (split-num [n] (let [s (str n)\n                                 len (count s)\n                                 half (/ len 2)]\n                             [(subs s 0 half)\n                              (if (even? len) \"\" (subs s half (inc half)))\n                              (subs s (if (odd? len) (inc half) half))]))\n            (incstr [s] (if (empty? s)\n                          \"1\"\n                          (str (inc (read-string s)))))\n\n            (palindrome-after [pal]\n              (let [[beg mid end] (split-num pal)\n                    all-nines? (fn [str] (empty? (filter #(not= \\9 %) str)))]\n                (cond (all-nines? beg) (first (filter palindrome? (iterate inc (inc pal))))\n                      (empty? mid) (let [s (incstr beg)] (read-string (str s (apply str (reverse s)))))\n                      (= \"9\" mid)  (if (empty? beg)\n                                     11\n                                     (let [s (incstr beg)] (read-string (str s \"0\" (apply str (reverse s))))))\n                      :else        (read-string (str beg (incstr mid) end)))))\n            (lazy-palindrome-generator [pal]\n              (let [next-pal (palindrome-after pal)]\n                (lazy-seq\n                 (cons next-pal (lazy-palindrome-generator next-pal)))))]\n      (let [start-num (first (filter palindrome? (iterate inc n)))]\n        (lazy-seq\n         (cons start-num (lazy-palindrome-generator start-num))))))", "problem": 150, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "4e6cf521535de274dd8d818b"}, {"code": "(fn [n] \n  (letfn [(m [i s] (Long/parseLong (str (str i) (subs (clojure.string/reverse (str i)) (if s 0 1)))))\n          (x [[k s]] (if (and (> k 1) (zero? (mod (Math/log10 k) 1))) [(if s k (/ k 10)) (not s)] [k s]))]\n         ((fn r [[j y]] (lazy-seq (cons (m j y) (r (x [(inc j) y])))))\n           (let [c (count (str n))\n                 y (even? c)\n                 r (if (< n 10) n (quot n (apply * (repeat (quot c 2) 10))))]\n             (if (<= n (m r y)) [r y] (x [(inc r) y]))))))", "problem": 150, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn intpal[n]\n\t(let [tens [1 10 100 1e3 1e4 1e5 1e6 1e7 1e8 1e9 1e10 1e11 1e12 1e13 1e14 1e15 1e16 1e17 1e18]\n\t\t\t\tbigtens (vec (map bigint tens))]\n\t\t(letfn [\n\t\t\t(num-digits [i]\n\t\t\t\t(loop [d 0 t tens]\n\t\t\t\t\t(if (> (first t) i) \n\t\t\t\t\t\td \n\t\t\t\t\t\t(recur (inc d) (next t)))))\n\t\t\t(genpal [i]\n\t\t\t\t(let [l (num-digits i)\n\t\t\t\t      hlc (/ (inc l) 2)\n\t\t\t\t\t\t\thlf (/ l 2)\n\t\t\t\t\t\t\ttenhlf (bigtens (int hlf))\n\t\t\t\t\t\t\tpre (bigint (/ i tenhlf))\n\t\t\t\t\t\t\tnextpre (inc pre)\n\t\t\t\t\t\t\ttenhlc (bigtens (int hlc))\n\t\t\t\t\t\t\tsuf (bigint (/ i tenhlc))]\n\t\t\t\t\t(loop [p pre s suf n nextpre]\n\t\t\t\t\t\t(if (< 0 s)\n\t\t\t\t\t\t\t(recur (+ (* 10 p) (mod s 10)) \n\t\t\t\t\t\t\t       (quot s 10)\n\t\t\t\t\t\t\t\t\t\t (* 10 n)) \n\t\t\t\t\t\t\t(lazy-seq\n\t\t\t\t\t\t\t\t(cons p (genpal n)))))))]\n\t\t\t(drop-while #(> n %) (genpal n)))))", "problem": 150, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn gen-pals [n]\n  (letfn [\n          (to-coll [i] (into [] (map #(- (int %) 48) (str i))))\n          (get-half [i] \n            (let [my-coll (to-coll i)]\n              (if (= 0 (mod (count my-coll) 2))\n                (subvec my-coll 0 (/ (count my-coll) 2))\n                (subvec my-coll 0 (+ 1 (quot (count my-coll) 2))))))\n          (conv-back [coll] (Long/parseLong (apply str coll)))\n          (move-up? [i]\n            (every? #(= 9 %) (to-coll i)))\n          (make-new [i]\n            (int (Math/pow 10 (quot i 2))))\n          (make-from-num [i s]\n           (let [half (to-coll i)]\n             (if (= 0 (mod s 2))\n               (conv-back (into half (reverse half)))\n               (conv-back (into half (reverse (butlast half)))))))\n          (rrr [i s]\n            (if (move-up? i)\n              (cons (make-from-num i s) (lazy-seq (rrr (make-new s) (inc s))))\n              (cons (make-from-num i s) (lazy-seq (rrr (inc i) s)))))]\n    (let [h (conv-back (get-half n)) s (count (to-coll n)) f-num (make-from-num h s)]\n      (if (< f-num n)\n        (rrr (inc h) s)\n        (rrr h s)))))", "problem": 150, "user": "4f04d312535dcb61093f6be7"}, {"code": "(fn\n  [n]\n  (let [is-palindrom? (fn [x] \n                        (let\n                          [strx (str x)\n                           size (int (/ (count strx) 2))\n                           lft (take size strx)\n                           rht (take size (reverse strx))]\n                          (= lft rht)))\n        sub-generator (fn [x]\n                        (if (sequential? x)\n                         (let [[half is-odd?] x\n                               rollover? (apply = (conj half \\9))\n                               half (seq (str (inc (bigint (apply str half)))))]\n                           (if rollover?\n                             (if is-odd?\n                               [(drop-last half) (not is-odd?)]\n                               [half (not is-odd?)])\n                             [half is-odd?]))\n                         (let [seqx (str x) ; Number as a sequence\n                               size (count seqx) ; Number of digits in number\n                               half (take (/ size 2) seqx)] ; First half of the number\n                           (if (is-palindrom? x)\n                             [(take (/ size 2) seqx) (odd? size)]\n                             (if (> (bigint (apply str half)) ; First half is larger than second half\n                                    (bigint (apply str (take (/ size 2) (reverse seqx)))))\n                               [half (odd? size)]\n                               [(seq (str (inc (bigint (apply str half))))) (odd? size)])))))]\n    (map #(let [[half is-odd?] %1]\n            (bigint (apply str (concat half \n                               (if is-odd?\n                                 (rest (reverse half))\n                                 (reverse half))))))\n         (next (iterate sub-generator n)))))", "problem": 150, "user": "4f4544e1e4b0d56e7bb92b7a"}, {"code": "(letfn [(nnp [n]\n  (condp >= n\n\t\t9 n\n\t\t11 11\n\t\t(let [digits (str n)\n\t\t\t\t\tndigs (count digits)\n\t\t\t\t\thndigs (int (Math/ceil (/ ndigs 2)))\n\t\t\t\t\thalf (apply str (take hndigs digits))\n\t\t\t\t\tihalf (str (inc (BigInteger. half)))\n\t\t\t\t\tmoreDigs (> (count ihalf) (count half))\n\t\t\t\t\txor (fn [& args] (odd? (count (filter identity args))))\n\t\t\t\t\tmakep (fn [isEven s]\n\t\t\t\t\t\t(BigInteger.\n\t\t\t\t\t\t\t(apply str\n\t\t\t\t\t\t\t\t(concat s (reverse (if isEven s (drop-last 1 s)))))))\n\t\t\t\t\tcurp (makep (even? ndigs) half)\n\t\t\t\t\tnextp (makep (xor (even? ndigs) moreDigs) ihalf)]\n\t\t\t(if (>= curp n) curp nextp) )))]\n\n\t(fn np [n]\n\t\t(lazy-seq\n\t\t\t(let [r (nnp n)]\n\t\t\t\t(cons r (np (inc r)))))))", "problem": 150, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [n]\r\n  (letfn [(ten-expt? [n]\r\n            (cond\r\n             (not (zero? (rem n 10))) false\r\n             (= n 10) true\r\n             :else (recur (quot n 10)))\r\n            )\r\n          (number-to-seq\r\n            ([n s] (if (zero? n) s (recur (quot n 10) (conj s (rem n 10)))))\r\n            ([n] (if (zero? n) '(0) (number-to-seq n '()))))\r\n          (seq-to-number\r\n            ([l s] (if (empty? l) s\r\n                       (recur (rest l) (+ (* 10 s) (first l)))))\r\n            ([l] (seq-to-number l 0)))\r\n          (seq-to-pair [l]\r\n            (if (odd? (count l))\r\n              [(seq-to-number (take (inc (quot (count l) 2)) l)) true]\r\n              [(seq-to-number (take (quot (count l) 2) l)) false])\r\n            )\r\n          (pair-to-seq [p]\r\n            (let [l (number-to-seq (first p))]\r\n              (if (second p)\r\n                (concat l (rest (reverse l)))\r\n                (concat l (reverse l)))))\r\n          (next-pair [p]\r\n            (let [a (inc (first p)) b (second p)]\r\n              (if (ten-expt? a)\r\n                (if b\r\n                  [(quot a 10) false]\r\n                  [a true])\r\n                [a b])))\r\n          (gen-list-from [p]\r\n            (lazy-seq\r\n             (cons (seq-to-number (pair-to-seq p))\r\n                   (gen-list-from (next-pair p)))))\r\n          ]\r\n\r\n    (let [l (gen-list-from (seq-to-pair (number-to-seq n)))]\r\n      (if (< (first l) n)\r\n        (rest l) l))))", "problem": 150, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [s]\n          (letfn [(f [n]\n                     (let [ns (str n)\n                          ms (str (inc n))\n                          l (count ns)\n                          hs (take (Math/ceil (/ l 2)) ns)\n                          hs-n (->> hs (apply str) read-string inc str seq)\n                          pe #(->> (concat % (reverse %)) (apply str) read-string)\n                          po #(->> (concat % (rest (reverse %))) (apply str) read-string)]\n                          (cond\n                            (> (count ms) l) (+ 2 n)\n                            (even? l) (if (> (pe hs) n) (pe hs) (pe hs-n))\n                            :default (if (> (po hs) n) (po hs) (po hs-n)))))]\n                     (if (= (seq (str s)) (reverse (str s)))\n                         (iterate f s)\n                         (iterate f (f s)))))", "problem": 150, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn palindromic [idx]\n  (letfn [(reverse-str [idx]\n                       (apply str (reverse (str idx))))\n          (take-idx [num idx]\n                    (read-string (apply str (take num (str idx)))))\n          (count-num [num]\n                     (count (str num)))\n          (palin [idx]\n                 (let [ct (count (str idx))\n                       strip-num2 (fn [num ct]\n                                    (if (> (count-num (inc num)) (count-num num))\n                                      (if (odd? ct)\n                                        (read-string (str (inc num) (reverse-str (inc num))))\n                                        (read-string (str (inc num) 0 (reverse-str (inc num)))))\n                                      (if (odd? ct)\n                                        (read-string (str (inc num) 0 (reverse-str (inc num))))\n                                        (read-string (str (inc num) 0 0 (reverse-str (inc num)))))))]\n                   (if (odd? ct)\n                     (let [num (int (/ ct 2))\n                           strip-num (take-idx num idx)]\n                       (concat (map #(read-string (str strip-num % (reverse-str strip-num))) (range 10)) (lazy-seq (palin (strip-num2 strip-num ct)))))\n                     (let [num (dec (/ ct 2))\n                           strip-num (take-idx num idx)]\n                       (concat (map #(read-string (str strip-num % % (reverse-str strip-num))) (range 10)) (lazy-seq (palin (strip-num2 strip-num ct))))))))]\n    (if (< idx 100)\n      (let [result [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99]]\n        (drop-while #(< % idx) (concat result (lazy-seq (palin 100)))))\n      (drop-while #(< % idx) (lazy-seq (palin idx))))))", "problem": 150, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn [x] \n\n  (letfn [(mirror [i, is_odd]\n            (let [s (str i)\n                  mir (if is_odd (reverse (drop-last s)) (reverse s))]\n              (Long. (apply str s mir))))\n          (next_pal [n] \n            (let [s (str n)\n                  c (count s)\n                  half (Long. (subs s 0 (Math/ceil (/ c 2))))\n                  p1 (mirror half (odd? c)) \n                  p2 (mirror (inc half) (odd? c))]\n              (if (>= p1 n) p1 p2)))]\n\n    (iterate #(next_pal (inc %)) (next_pal x))))", "problem": 150, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [P I N S]\n    (filter #(<= S %) (map I (iterate N (P S))))\n    )\n\n  (fn [n]                               \n    (let [s (map #(- (int %) 48) (str n)) c (count s) d (bit-shift-right c 1) t (take d s)]\n      [(first (drop-last d (drop d s))) (reverse t)]))\n\n\n  (fn [[m t]]                   \n    (Long/valueOf (apply str (concat (reverse t) (if m [m]) t))))\n\n  (fn [[m t]]                   \n    (let [i (fn i [[d & r]]\n              (if d\n                (if (< d 9)\n                  `[~(+ d 1) ~@r]\n                  `[0 ~@(i r)])\n                [1]))\n          [f & r :as T] (i t)\n          eq (= (count t) (count T))]\n      (if m\n        (if (< m 9)\n          [(+ m 1) t]\n          [(if eq 0) T])\n        (if eq\n          [nil T]\n          [f r]))))", "problem": 150, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn p [n]\n  (let [\n    strrev (fn [s] (apply str (reverse s)))\n    strbl  (fn [s] (apply str (butlast s)))\n    palindromic? \n      (fn [n]\n        (if (= 1 (count (str n))) true\n          (let [s (str n) hl (int (/ (count s) 2)) first-half (subs (str n) 0 hl) ]\n            (if (even? (count s))\n              (= s (str first-half (strrev first-half)))\n              (= s (str first-half (get s hl) (strrev first-half)))))))\n    next-palindromic (fn [n]\n      (if (<= n 8) (inc n) (if (= 9 n) 11\n      (let [s (str n) hl (int (/ (count s) 2)) first-half (subs (str n) 0 hl) ]\n        (if (even? (count s))\n          (let [m (read-string (str first-half (strrev first-half)))]\n            (if (> m n) m\n              (let [p (read-string first-half)]\n                (if (= (count (str (inc p))) hl) \n                  (read-string (str (inc p) (strrev (str (inc p)))))\n                  (read-string (str (strbl (str (inc p))) (strrev (str (inc p)))))))))\n          (let [m (read-string (str first-half (get s hl) (strrev first-half)))]\n            (if (> m n) m\n              (if (< (read-string (str (get s hl))) 9)\n                (read-string (str first-half (+ 1 (read-string (str (get s hl)))) (strrev first-half)))\n                (let [p (read-string first-half)]\n                  (if (= (count (str (inc p))) hl)\n                    (read-string (str (inc p) \"0\" (strrev (str (inc p)))))\n                    (read-string (str (inc p) (strrev (str (inc p)))))))))))))))]\n    (iterate next-palindromic (if (palindromic? n) n (next-palindromic n)))))", "problem": 150, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [n] (letfn  [\n                (to-i [s] (apply + (map * (reverse (map #(- (int %) 48)  s)) (iterate #(* 10 %) 1))))\n                (rsplit [n s] (split-at (- (count s) n) s))\n                (make-p [[ l m]] (to-i (concat l m (reverse l))))\n                (next-palindrome [n] (let\n                                         [ s (str n)\n                                          l (count s)\n                                          h (quot l 2)\n                                          [left right] (map #(% h s) [take take-last] )\n                                          mid (if (odd? l) [ (nth s h)] [] ) \n                                          r-left (reverse left) \n                                          [li ri] (map to-i [r-left right])\n                                          ]\n                                       (make-p\n                                        (if (> ri li)\n                                          (->> (concat left mid)\n                                               (to-i)\n                                               (inc)\n                                               (str)\n                                               (rsplit (count mid)))\n                                          [left mid]))))  ]\n         (iterate (comp next-palindrome inc) (next-palindrome n))))", "problem": 150, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [n]\n  (let [f (fn [n]\n            (let [s (str n)\n                  d (count s)\n                  h (quot (inc d) 2)\n                  u (subs s 0 h)\n                  v (str (inc (read-string u)))\n                  a #(read-string (apply str % (reverse (subs % 0 (- d h)))))]\n              (cond\n               (> (a u) n) (a u)\n               (= (set u) #{\\9}) (inc (reduce * (repeat d 10)))\n               true (a v))))]\n    (iterate f (if (= n 0) 0 (f (dec n))))))", "problem": 150, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn palindromes [min]\n  (let [smin (str min)\n        init-power (dec (count smin))\n        pals\n          (fn [outer-power]\n            (letfn [(gen [power ds] (lazy-seq\n                      (let [shell #(+ % (apply * % (repeat power 10)))\n                            expand \n                              (fn [d]\n                                (let [outer (shell d)]\n                                    (map #(+ outer (* 10 %)) (gen (- power 2) (rest ds)))\n                                ))\n                        ]\n                        (cond\n                          (zero? power) (range 10)\n                          (= power 1) (range (if (= outer-power 1) 11 0) 100 11)\n                          :else \n                            (let [mind (if (= power outer-power) 1 0)\n                                  d (if-let [dc (first ds)]\n                                      (max mind (- (int dc) (int \\0)))\n                                      mind)]\n                              (mapcat expand (range d 10)))\n                        ))))\n              ]\n              (gen outer-power (when (= outer-power init-power) smin))\n            ))\n        sq (if (zero? init-power)\n             (mapcat pals (range))\n             (mapcat pals (iterate inc init-power)))\n    ]\n    (drop-while #(< % min) sq)\n  ))", "problem": 150, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn pali [n]\r\n  (letfn [\r\n\t\t(nextad [c a] (loop [x 1] (if (> x c) x (recur (* x a)))))\r\n\t\t(divi [n a] (/ (- n (rem n a)) a))\r\n\t\t(topali [cut n]\r\n      (java.math.BigInteger. \r\n        (apply str\r\n          (let [sn (str n) rsn (reverse sn)]\r\n\t\t        (concat sn (if cut (rest rsn) rsn))))))\r\n\t\t(firsttry [n]\r\n      (loop [x100 n x10 n]\r\n        (if (> 1 x100) [x10 false]\r\n          (if (> 10 x100) [x10 true]\r\n            (recur (divi x100 100) (divi x10 10))))))\r\n\r\n\t  (palis [a cut]\r\n\t    (lazy-seq\r\n\t\t\t  (let [nn (nextad a 10)]\r\n\t\t\t    (concat\r\n\t\t\t      (map #(topali cut %) (range a nn))\r\n\t\t           (palis (if cut (/ nn 10) nn) (not cut))))))\r\n          ]\r\n    (if (== n 0) (cons 0 (pali 1))\r\n      (let [[a cut] (firsttry n)]\r\n\t      (drop-while #(< % n)\r\n\t        (palis a cut))))))", "problem": 150, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [n]\n  (let [rev   (fn rev [n] (loop [ac 0 n n]\n                            (if (= 0 n)\n                              ac\n                              (recur (+ (* ac 10) (rem n 10)) (quot n 10)))))\n        sum   #(+ (rev %1) (* %2 (long (Math/pow 10 (quot %3 2)))))\n        mk    (fn [sz m]\n                (if (odd? sz)\n                  (sum (quot m 10) m sz)\n                  (sum m m sz)))\n        ns?   (fn [n]\n                (cond (= 9 n) true\n                      (not= 9 (rem n 10)) false\n                      :else   (recur (quot n 10))))\n        mkmsk #(if (< %1 10) %2 (recur (quot %1 10) (* %2 10)))\n        nxt   #(if (ns? %2)\n                 [(inc %1) (* (mkmsk %2 1) (if (even? %1) 10 1))]\n                 [%1 (inc %2)])\n        sq    (fn sq [sz m]\n                (lazy-seq\n                  (cons (mk sz m) (apply sq (nxt sz m)))))\n        sz    (count (str n))\n        msk   (quot n (long (Math/pow 10 (quot sz 2))))]\n    (drop-while #(< %1 n) (sq sz msk))))", "problem": 150, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn palindromes [n]\n  (letfn [(numdigits [n]\n            (count (str n)))\n          (ispalindrome [n]\n            (= (seq (str n))\n              (reverse (str n))))\n          (shift-right [n d]\n            (quot n (apply * (repeat d 10))))\n          (shift-left [n d]\n            (apply * n (repeat d 10)))\n          (reverse-num [n]\n            (read-string (apply str (drop-while #{\\0} (reverse (str n))))))\n          (getnewleft [n h]\n            (let [left  (shift-right n h)\n                  right (shift-right (reverse-num n) h)]\n              (if (>= right left)\n                  (inc left)\n                  left)))\n          (nextpal [n]\n            (let [ndigits  (numdigits n)\n                  half     (quot ndigits 2)\n                  newleft  (getnewleft n half)\n                  newright (shift-right newleft (mod ndigits 2))]\n              (+ (shift-left newleft half)\n                 (reverse-num newright))))\n          (nextpalindrome [n]\n            (cond\n              (< n 9)                (+ n 1)\n              (every? #{\\9} (str n)) (+ n 2)\n              :else                  (nextpal n)))]\n    ((if (ispalindrome n) identity rest)\n      (iterate nextpalindrome n))))", "problem": 150, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(letfn\n   [(i [x]\n      (if (#(= % (reverse %))\n           (seq (str x)))\n        x))\n    (f [x]\n      (if (= x 1)\n        [1 2]\n        (let [n (/ x 10)]\n          (lazy-cat [x (+ x n)]\n                    (f n)))))\n    (s [n]\n      (some i\n        (map #(+ n %)\n          (f (->> n\n               str\n               count\n               dec\n               (.pow (bigint 10)))))))]\n  (fn [n]\n    (iterate s\n      (some i (iterate inc n)))))", "problem": 150, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn palindromes [n]                                                                                                                                                                                       \n  (letfn [(to-digits [n] (if (< n 10) [n] (conj (to-digits (quot n 10)) (rem n 10))))                                                                                                                      \n           (to-value [digits] (reduce #(+ (* %1 10) %2) 0 digits))                                                                                                                                          \n           (next-pal [n]                                                                                                                                                                                    \n                     (let [digits (to-digits n)                                                                                                                                                             \n                           len (count digits)                                                                                                                                                               \n                           mid (quot len 2)                                                                                                                                                                 \n                           half (take mid digits)                                                                                                                                                           \n                           head (to-digits (inc (to-value half)))                                                                                                                                           \n                           mirror-digs (reverse half)                                                                                                                                                       \n                           mirror (to-value mirror-digs)                                                                                                                                                    \n                           mid-val (nth digits mid)                                                                                                                                                         \n                           tail (to-value (take-last mid digits))]                                                                                                                                          \n                       (to-value (cond                                                                                                                                                                      \n                                  (and (even? len) (>= mirror tail)) (concat half mirror-digs)                                                                                                              \n                                  (and (odd? len) (>= mirror tail)) (concat half [mid-val] mirror-digs)                                                                                                     \n                                  (even? len) (concat head (reverse head))                                                                                                                                  \n                                  (and (odd? len) (< mid-val 9)) (concat half [(inc mid-val)] mirror-digs)                                                                                                  \n                                  :else (concat head [0] (reverse head))))))]                                                                                                                               \n          (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [n]\n  (letfn\n    [(digits [n] (re-seq #\"\\d\" (str n)))\n     (number [s] (Long/parseLong (apply str s)))\n     (sym? [s] (even? (count s)))\n     (half [s] (take (/ (+ (count s) (if (sym? s) 0 1)) 2) s))\n     (second-half [h s] (reverse (if (sym? s) h (butlast h))))\n     (pal [s] (concat (half s) (second-half (half s) s)))\n     (next-pal [s]\n       (if (= #{\"9\"} (set s))\n         (digits (+ (number s) 2))\n         (let [l (digits (inc (number (half s))))\n               r (second-half l s)]\n           (concat l r))))\n     (pals [s] (cons (number s) (lazy-seq (pals (next-pal s)))))]\n   (drop-while #(< % n) (pals (pal (digits n))))))", "problem": 150, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [m]\n       (let [palindrome? (fn [n] (= (str n) (clojure.string/join (reverse (str n)))))\n       get-pal\n\t     (fn get-pal [n]\n       (let [p (+ 1 n)]\n\t (if (= (str p) (clojure.string/join (reverse (str p)))) p\n\t     (let [p-str (str p)\n\t\t   c (count p-str)\n\t\t   k (if (even? c) (/ c 2) (/ (- c 1) 2))\n\t\t   l (if (even? c) (/ c 2) (/ (+ c 1) 2))\n\t\t   mid (if (even? c) \"\" (str (nth p-str k)))\n\t\t   first-half (clojure.string/join (take k p-str))\n\t\t   complementary (clojure.string/join (reverse first-half))\n\t\t   tmp-list (list first-half mid complementary)\n\t\t   tmp-str (clojure.string/join tmp-list)\n\t\t   candidate (read-string tmp-str)\n\t\t   main-half (read-string (clojure.string/join (take l p-str)))]\n\t       (if (< p candidate) candidate\n\t\t   (get-pal (read-string (clojure.string/join (flatten (list (str (+ 1 main-half)) (repeat k \"0\")))))))))))]\n\t (if (palindrome? m) (do (println \"palindrome start\" )(iterate get-pal m)) (rest (iterate get-pal m)))))", "problem": 150, "user": "4e49a7bb535dc968683fc4c6"}, {"code": "(fn [n]\n  (letfn\n      [(d [n] (if (< n 10) [n] (conj (d (quot n 10)) (rem n 10))))\n       (e [s] (reduce #(+ (* 10 %) %2) 0 s))\n       (p [n] (let [c concat\n                    r reverse\n                    I (d n)\n                    l (count I)\n                    h (quot l 2)\n                    F (take h I)\n                    f (-> F r e)\n                    N (-> F e inc d)\n                    S (take-last h I)\n                    s (e S)\n                    m (I h)\n                    e? (even? l)\n                    o? (not e?)]\n                (e\n                 (cond\n                  (and e? (>= f s))  (c F (r F))\n                  e?                 (c N (r N))\n                  (and o? (>= f s))  (c F [m] (r F))\n                  (and o? (< m 9))   (c F [(+ 1 m)] (r F))\n                  :else              (c N [0] (r N))))))]\n    (iterate (comp p inc) (p n))))", "problem": 150, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [s]\n  (let [p #(Long. (apply str % ((if %2 next seq) (reverse (str %)))))\n        d #(count (str %))\n        o #(odd? (d %))\n        b #(Long. (subs (str %) 0 (quot (+ 1 (d %)) 2)))\n        i #(let [x (b %)\n                 o (o %)\n                 y (+ 1 x)]\n             (cond\n              (= (d x) (d y)) (p y o)\n              o (p (/ y 10) nil)\n              1 (p y 1)))]\n    (filter #(>= % s) (iterate i (p (b s) (o s))))))", "problem": 150, "user": "4db858d1535d1e037afb218c"}, {"code": "(letfn [(ng-next [n]\n            (let [s           (str n)\n                  seg2-right  (count s)\n                  seg1-right  (quot seg2-right 2)\n                  seg1        (subs s 0 seg1-right)]\n              (if (= \"\" (.replaceAll s \"9\" \"\"))\n                (+ 2 n)\n                (if (even? seg2-right)\n                  (let [seg1-ng (str (inc (bigint seg1)))]\n                    (bigint (str seg1-ng (clojure.string/reverse seg1-ng))))\n                  (let [seg1-ng (str (inc (bigint (str seg1 (subs s seg1-right (inc seg1-right))))))\n                        seg2-ng (clojure.string/reverse (subs seg1-ng 0 seg1-right))]\n                    (bigint (str seg1-ng seg2-ng)))))))\n          (ng-norm [n] \n            (let [s           (str n)\n                  seg2-right  (count s)\n                  s-even?     (even? seg2-right)\n                  seg1-right  (quot seg2-right 2)\n                  seg2-left   (+ seg1-right (if s-even? 0 1))\n                  seg1        (subs s 0 seg1-right)\n                  cmp         (.compareTo seg1 (clojure.string/reverse (subs s seg2-left seg2-right)))]\n              (cond (zero? cmp) n\n                    (pos?  cmp) (bigint (str seg1 (subs s seg1-right seg2-left) (clojure.string/reverse seg1)))\n                    :else       (if s-even?\n                                  (let [seg1-ng (str (inc (bigint seg1)))]\n                                    (bigint (str seg1-ng (clojure.string/reverse seg1-ng))))\n                                  (let [seg1-ng (str (inc (bigint (str seg1 (subs s seg1-right seg2-left)))))\n                                        seg2-ng (clojure.string/reverse (subs seg1-ng 0 seg1-right))]\n                                    (bigint (str seg1-ng seg2-ng)))))))]\n    (fn [n] (map bigint\n                (if (< n 10)\n                  (concat (range n 10) (iterate ng-next 11))\n                  (iterate ng-next (ng-norm n))))))", "problem": 150, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [s]\r\n  (let [h str\r\n        z #(reverse (h %))\r\n        i iterate\r\n        r quot\r\n        q (fn [n]\r\n    (let [c count\r\n          u #(* 10 %)\r\n          w #(nth (i u 1) %)\r\n          x #(r (c (h %)) 2)\r\n          y #(r % (w (x %)))\r\n          v #(Integer/valueOf (apply h %\r\n               (if (even? (c (h %2)))\r\n                   (z %)\r\n                   (drop 1 (z %)))))\r\n          m (+ n (w (x n)))\r\n          e (v (y n) n)]\r\n\r\n      (if (> e n)\r\n          e\r\n          (v (y m) m))))]\r\n    (i q (if (= (seq (h s)) (z s)) s (q s)))))", "problem": 150, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(letfn [\n\n(next-base [n len]\n  (if (odd? len) n (/ n 10)))\n\n(next-format [len]\n  (if (odd? len)\n    #(apply str % (rest (reverse (str %))))\n    #(apply str % (reverse (str %)))))\n\n(next-len? [n]\n  (and (pos? n)\n       (not= (count (str n)) (count (str (dec n))))))\n\n(p-nums [n len fmt check?]\n  (if (and check? (next-len? n))\n    (let [len2 (inc len)]\n      (p-nums (next-base n len2) len2 (next-format len2) false))\n    (lazy-seq\n      (cons (fmt n) (p-nums (inc n) len fmt true)))))\n  \n(palindromic-nums [n]\n  (let [n-str (str n)\n        len (count n-str)\n        m (if (< n 10) 0\n            (bigint (apply str (take (quot (inc len) 2) n-str))))]\n    (->>\n      (p-nums m len (next-format len) false)\n      (map bigint)\n      (filter #(<= n %)))))\n\n] palindromic-nums)", "problem": 150, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(letfn [(split-digits [x]\n          (let [digits (str x)\n                len (count digits)\n                [left [mid]] (split-at (quot len 2) digits)]\n            [left (when (odd? len) mid)]))\n        (number [digits]\n          (Long. (apply str digits)))\n        (palindrome [x]\n          (let [[left mid] (split-digits x)]\n            (number (concat left [mid] (reverse left)))))\n        (next-palindrome [x]\n          (let [[left mid] (split-digits x)]\n            (cond\n             (every? #{\\9} (str x)) (+ x 2)\n             mid   (let [new-left (-> (concat left [mid]) number inc str)\n                         new-right (-> new-left butlast reverse)]\n                     (number (concat new-left new-right)))\n             :else (let [new-left (-> left number inc str)\n                         new-right (-> new-left reverse)]\n                     (number (concat new-left new-right))))))]\n  (fn [start]\n    (->> (palindrome start)\n         (iterate next-palindrome)\n         (drop-while #(< % start)))))", "problem": 150, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "#(let [next-palindrome\n       (fn [n]\n         (let [num-digits (count (str n))\n               odd-digits? (odd? num-digits)\n               prefix-digits (take (/ num-digits 2) (str n))\n               palindrome (fn [prefix odd?]\n                            (let [ps (if odd? (butlast prefix) prefix)\n                                  center (if odd? (take-last 1 prefix))]\n                              (read-string (apply str (concat ps center (reverse ps))))))\n               candidate (palindrome prefix-digits odd-digits?)]\n           (if (< n candidate)\n             candidate\n             (let [next-prefix (str (inc (read-string (apply str prefix-digits))))]\n               (if (= (count next-prefix) (count prefix-digits))\n                 (palindrome next-prefix odd-digits?)\n                 (palindrome (if odd-digits? (butlast next-prefix) next-prefix) (not odd-digits?)))))))]\n   (if (= (seq (str %)) (reverse (str %)))\n     (iterate next-palindrome %)\n     (next (iterate next-palindrome %))))", "problem": 150, "user": "4e52d815535d302ef430da77"}, {"code": "(fn [n]\r\n  (letfn [(pal [n f]\r\n            (let [s (str (f n))\r\n                  l (count s)\r\n                  q (quot l 2)\r\n                  h (take (- l q) s)]\r\n              (BigInteger. (apply str (concat h (reverse (take q h)))))))\r\n          (nextpal [n]\r\n            (pal n #(if (zero? %) 1\r\n                      (+ % (int (Math/pow 10 (quot (inc (Math/log10 %)) 2)))))))\r\n          (palify [n]\r\n            (let [x (pal n #(identity %))]\r\n              (if (>= x n) x (nextpal x))))]\r\n    (iterate nextpal (palify n))))", "problem": 150, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "#(letfn\n    [(palindromize [n]\n       (let [s (str n)\n             size (count s)\n             half (quot size 2)]\n         (bigint (str (subs s 0 (+ half (if (odd? size) 1 0)))\n                      (clojure.string/reverse (subs s 0 half))))))\n     (next-palindrome [n]\n       (palindromize (+ n (bigint (Math/pow 10 (quot (count (str n)) 2))))))]\n  (let [x (palindromize %)]\n    (iterate\n     next-palindrome\n     (if (< x %)\n       (next-palindrome %)\n       x))))", "problem": 150, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [x]\n  (letfn [(step [x]\n            (if (every? #(== 9 %) (num->digits x))\n              (+ 2 x)\n              (palindrome inc x)))\n          (num->digits [x]\n            (map #(- (int %) 48) (str x)))\n          (take-half [xs]\n            (take (/ (count xs) 2) xs))\n          (digits->num [xs]\n            (reduce #(+ (* 10 %1) %2) xs))\n          (palindrome\n            ([x]\n               (palindrome identity x))\n            ([f x]\n               (let [digits (num->digits x),\n                     upper-digits (-> digits take-half digits->num f num->digits),\n                     length (count digits)]\n                 (digits->num (concat upper-digits\n                                      (drop (mod length 2) (reverse upper-digits)))))))]\n    (drop-while #(< % x) (iterate step (palindrome x)))))", "problem": 150, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn pals-from [n]\r\n  (let \r\n    [first-n (fn [num-digits]\r\n                (int (Math/pow 10 (dec num-digits))))\r\n     mirror (fn [x dup]\r\n              (let\r\n                [digits (seq (str x))\r\n                 rev-digits (reverse digits)\r\n                 to-flip (if dup rev-digits (rest rev-digits))\r\n                 new-digits (concat digits to-flip)\r\n                 new-str (apply str new-digits)]\r\n                 (Integer/parseInt new-str)))\r\n     next-pal (fn [p]\r\n                (let\r\n                  [digits (seq (str p))\r\n                   _ (println \"digits\" digits)\r\n                   num-digits (count digits)\r\n                   _ (println \"num digits\" num-digits)\r\n                   odd-digits (odd? num-digits)\r\n                   _ (println \"odd digits\" odd-digits)\r\n                   half-size (if odd-digits\r\n                                (/ (inc num-digits) 2)\r\n                                (/ num-digits 2))\r\n                   _ (println \"half size\" half-size)\r\n                   half-digits (take half-size digits)\r\n                   _ (println \"half digits\" half-digits)\r\n                   half-num (Integer/parseInt (apply str half-digits))\r\n                   _ (println \"half-num\" half-num)\r\n                   inc-half-num (inc half-num)\r\n                   _ (println \"inc-half-num\" inc-half-num)\r\n                   inc-half-size (count (seq (str inc-half-num)))\r\n                   _ (println \"inc-half-size\" inc-half-size)\r\n                   switch (> inc-half-size half-size)\r\n                   _ (println \"switch\" switch)\r\n                   new-base (if (and switch odd-digits)\r\n                             (first-n half-size)\r\n                              inc-half-num)\r\n                   _ (println \"new base\" new-base)\r\n                   dup (or (and switch odd-digits)\r\n                           (and (not switch) (not odd-digits)))\r\n                   _ (println \"dup\" dup)]\r\n                     (mirror new-base dup)))\r\n     is-pal (fn [x]\r\n              (= (seq (str x)) (reverse (seq (str x)))))\r\n     first-pal (first (drop-while #(not (is-pal %)) (iterate inc n)))]\r\n     (iterate next-pal first-pal)))", "problem": 150, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [n]\n  (let [next-p (fn [num]\n                 (if (< num 9)\n                   (inc num)\n                   (let [num-str (str num)\n                         num-len (count num-str)\n                         qu (quot num-len 2)\n                         first-half (drop-last qu num-str)\n                         reflected-first-half (concat first-half (reverse (take qu first-half)))\n                         chars-to-num #(read-string (apply str %))\n                         new-num (chars-to-num reflected-first-half)]\n                     (if (> new-num num)\n                       new-num\n                       (recur (* (inc (chars-to-num first-half)) (.toBigInteger (BigDecimal. (Math/pow 10 qu)))))))))]\n    (drop-while (fn [x] (not= (seq (str x)) (reverse (str x))))\n                (iterate next-p n))))", "problem": 150, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn [n]\n    (letfn [(reverse-num\n              [n]\n              (loop [m n r 0]\n                    (if (zero? m) r\n                      (let\n                        [qn (quot m 10) mn (mod m 10)]\n                        (recur qn (+ (* r 10) mn))))))\n            (digits\n              [n]\n              (if (zero? n) 1\n                (loop [m n r 0]\n                      (if (zero? m) r\n                        (recur (quot m 10) (inc r))))))\n            (base-num\n              [n]\n              (let [d (digits n)]\n                (quot n (apply * (repeat (quot d 2) 10)))))\n            (first-num\n              [n]\n              (if (< n 9) n\n                (let [base (base-num n)\n                      nd (digits base)\n                      r (build-num base nd false (odd? (digits n)))]\n                  (if (<= n r) r (next-num r)))))\n            (build-num\n              [n d is-curry is-contain-center]\n              (+ (* n\n                      (apply * (repeat (- d (count (filter true? [is-curry is-contain-center])))\n                                        10)))\n                  (reverse-num (if is-contain-center (quot n 10) n))))\n            (next-num\n              [n]\n              (let [d (digits n)]\n                (if (and (= d 1) (< n 9))\n                  (inc n)\n                  (let [base (base-num n)\n                        next (inc base)\n                        nd (digits next)\n                        is-curry (not= (digits base) nd)]\n                    (build-num next nd is-curry (odd? d))))))]\n           (iterate next-num (first-num n))))", "problem": 150, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn\r\n  [n]\r\n    (letfn\r\n      [(n2s [n] (loop [n n r []]\r\n                  (if (< n 10) (cons n r) (recur (quot n 10) (cons (rem n 10) r)))))\r\n       (s2n [s] (reduce #(+ (* % 10) %2) s))\r\n       (palindromic? [s] (= s (reverse s)))\r\n       (next-n \r\n         [n] \r\n         (let [s (n2s n) c (count s)]\r\n           (if (palindromic? s)\r\n             n     \r\n             (let [q (quot c 2)\r\n                   s1 (take q s)\r\n                   s2 (reverse (take-last q s))\r\n                   n1 (s2n s1)\r\n                   n2 (s2n s2)] \r\n               (if (even? c)\r\n                 (if (< n1 n2) \r\n                   (s2n (concat (n2s (inc n1)) (reverse (n2s (inc n1)))))\r\n                   (let [nn (s2n (concat s1 (reverse s1)))]\r\n                     (if (< nn n) \r\n                       (s2n (concat (n2s (inc n1)) (reverse (n2s (inc n1)))))\r\n                       nn)))\r\n                 (let [s3 (concat s1 [(nth s q)]) n3 (s2n s3)]\r\n                   (if (< n1 n2)\r\n                     (s2n (concat (n2s (inc n3))\r\n                                  (drop 1 (reverse (n2s (inc n3))))))\r\n                     (let [nn (s2n (concat s1 [(nth s q)] (reverse s1)))]\r\n                       (if (< nn n)\r\n                         (s2n (concat (n2s (inc n3)) (drop 1 (reverse (n2s (inc n3))))))\r\n                         nn)))))))))]\r\n      (iterate #(next-n (inc %)) (next-n n))))", "problem": 150, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [n]\n    (letfn [\n            (digits [n]\n                      (map #(read-string (str %)) (seq (str n))))\n\n            (first-half [s]\n                        (take (+ (quot (count s) 2) (rem (count s) 2)) s))\n\n            (to-number [digits]\n                       (read-string (apply str digits)))\n\n            (to-palindrome [s even]\n                           (concat s (if even (reverse s) (rest (reverse s)))))\n\n            (palindrome-generator [s even]\n                                  (let [digits-inc (every? #(= 9 %) s)\n                                        next-s (if (and digits-inc (not even))\n                                                 (into [1] (repeat (dec (count s)) 0))\n                                                 (digits (inc (to-number s))))\n                                        next-even (if digits-inc (not even) even)]\n                                    (lazy-seq\n                                      (cons (to-number (to-palindrome s even)) (palindrome-generator next-s next-even)))))]            \n           (filter #(>= % n) (palindrome-generator (first-half (digits n)) (even? (count (digits n)))))))", "problem": 150, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [s] \n          (letfn [(rev [s]\n                       (apply str (reverse s)))\n                 (next-even-palindrome [s]\n                                       (let [[left right] (map #(apply str %) (split-at (/ (count s) 2) s))]\n                                            (-> (if (> (bigint (rev left)) (bigint right))\n                                                    left\n                                                    (-> left bigint inc str))\n                                                (#(str % (rev %))))))\n                 (next-odd-palindrome [s]\n                                      (let [[left right] (map #(apply str %) (split-at (/ (dec (count s)) 2) s))\n                                           center (str (first right))\n                                           right (subs right 1)]\n                                           (cond (> (bigint (rev left)) (bigint right))\n                                                 (str left center (rev left))\n                                                 (= \"9\" center)\n                                                 (-> left bigint inc str (#(str % 0 (rev %))))\n                                                 :else\n                                                 (str left (inc (bigint center)) (rev left)))))\n                 (next-palindrome [p]\n                                  (let [s (str (inc p))]\n                                       (bigint (cond (= (seq s) (reverse s))\n                                                     s\n                                                     (even? (count s))\n                                                     (next-even-palindrome s)\n                                                     :else\n                                                     (next-odd-palindrome s)))))]\n                                                     (->> (if (= (reverse (str s)) (seq (str s)))\n                                                              (bigint s)\n                                                              (next-palindrome s))\n                                                          (iterate next-palindrome))))", "problem": 150, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [n] \n  (letfn [\n    (to-l [sq] (Long/parseLong (apply str sq)))\n    (mirror [s m] \n      (apply str \n        (flatten \n          (interpose m \n            (reduce \n              #(map \n                (fn [c] (conj c %2)) \n                %) \n              [[] ()] \n              s)))))\n    (pal [b i] \n      (if (= i 11)\n        (reductions #(+ % %2) i (repeat 8 i)) ; hack\n        (reductions #(+ % %2) b (repeat 9 i))))\n    (base [n] \n      (to-l \n        (mirror \n          (take \n            (quot (dec (count (str n))) 2) \n            (str n)) \n          (if (odd? (count (str n))) \n            \"0\" \n            \"00\"))))\n    (incr [n] \n      (long (* \n        (if (odd? (count (str n))) 1 11) \n        (Math/pow 10 (quot (dec (count (str n))) 2)))))\n    (pals [n] \n      (lazy-cat \n        (pal (base n) (incr n))\n        (pals (+ (base n) (* 10 (incr n))))))]\n  (filter #(<= n %) (pals n))))", "problem": 150, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn f [n]\n               (let [p? #(= (apply str (reverse (str %))) (str %))\n                     np (fn [n]\n                          (let [begl (int (+ 0.6 (/ (count (str n)) 2)))\n                                endl (- (count (str n)) begl)\n                                beg (->> (str n)\n                                      (take begl)\n                                      (apply str)\n                                      Integer/parseInt\n                                      inc\n                                      str)\n                                end (->> beg\n                                      (take endl)\n                                      reverse)]\n                            (Integer/parseInt (apply str (concat beg end)))))]\n                 (loop [n n]\n                   (if (p? n)\n                     (cons n\n                           (lazy-seq (f (np n))))\n                     (recur (inc n))))\n                             ))", "problem": 150, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [nu] \n  (drop-while #(< % nu)\n  ((fn [n]\n  (let\n    [half (fn [s] (read-string (apply str (drop-last\n                         (quot (count (str s)) 2)\n                         (str s)))))\n     odd (fn [s] (if (odd? (count (str s))) 1 0))\n     pal (fn [h o]\n           (read-string\n             (apply str h (drop o (reverse (str h))))))\n     npal (fn [p]\n            (if (every? #(= \\9 %) (str p))\n              (+ 2 p)\n              (pal (inc (half p)) (odd p))))]\n    (iterate npal (pal (half n) (odd n)))))\n  nu)))", "problem": 150, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn\n  [n]\n  (letfn [(mirror [[n isodd]]\n            (bigint (apply str (concat (str n) (drop (if isodd 1 0) (reverse (str n)))))))\n          (nextpal [[n isodd]]\n            (if (every? #(= % \\9) (str n))\n              (list (if isodd (quot (inc n) 10) (inc n)) (not isodd))\n              (list (inc n) isodd)))]\n    (let [digits   (seq (str n))\n          len      (count digits)\n          half-len (quot (inc len) 2)\n          half     (bigint (apply str (take half-len digits)))\n          isodd    (odd? len)\n          cand     (mirror (list half isodd))]\n      (map mirror (iterate nextpal (if (< cand n) (nextpal [half isodd]) [half isodd]))))))", "problem": 150, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(letfn [(str->int [& strs] (read-string (apply str strs)))\n          (front [n] (let [x (count (str n))]\n                       (str->int (apply str (take (int (Math/ceil (/ x 2))) (str n))))))\n          (pal [n odd] (let [back (reverse (str n))]\n                         (str->int n (apply str (if odd (rest back) back)))))\n          (next-pal [n]\n            (let [c (pal (front n) (odd? (count (str n))))]\n              (if (>= c n) c (pnext c))))\n          (pnext [n] (if (every? #(= % \\9) (str n))\n                       (+ n 2)\n                       (pal (inc (front n)) (odd? (count (str n))))))]\n    (fn [n] (iterate pnext (next-pal n))))", "problem": 150, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [start-at]\n  (letfn [(->int [& r] (Long. (apply str r)))\n          (s-rev [n] (apply str (reverse (str n))))\n          (half [pre n next-jump]\n            (lazy-seq\n             (cond (= pre next-jump) (whole pre (* next-jump 10))\n                   (= 10 n) (half (+ pre 1) 0 next-jump)\n                   :else (cons (->int pre n (s-rev pre))\n                               (half pre (+ n 1) next-jump)))))\n          (whole [pre next-jump]\n            (lazy-seq\n             (if (= pre next-jump)\n               (half (/ pre 10) 0 next-jump)\n               (cons (->int pre (s-rev pre))\n                     (whole (+ pre 1) next-jump)))))]\n    (let [size (count (str start-at))\n          pre (if (= size 1) 1\n                (Long. (.substring (str start-at) 0 (quot size 2))))\n          first-jump (if (= size 1) 10\n                         ((fn [n acc] (if (= 0 n) acc\n                                          (recur (- n 1) (* acc 10))))\n                          (quot size 2) 1))]\n      (drop-while\n       #(< % start-at)\n       (concat (range 10)\n               (if (or (= size 1)\n                       (even? size))\n                 (whole pre first-jump)\n                 (half pre 0 first-jump)))))))", "problem": 150, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [n]\n  (letfn [\n    (log10 [n]\n      (loop [n n l 0]\n        (if (< n 10) l (recur (quot n 10) (inc l)))))\n    ; pal make palindromics for a given number of columns\n    ; for example (pal 5) returns (10001 10101 ... 99999)\n    (pal [c]\n      (if (= c 1) (range 10)\n          (let [\n            hc  (quot c 2)                       ; 2 in the example\n            hc10 (apply * (repeat hc 10))        ; 100\n            dhc10 (if (odd? c) hc10 (/ hc10 10)) ; 100\n            s (max dhc10 (quot n hc10))\n            ]\n            (map\n              (fn [u]                            ; for example 321\n                (+ (* hc10 u)                    ; 32100 + 23 = 32123\n                   (->> (reverse (str u))        ; (\\1 \\2 \\3)\n                     (#(if (odd? c) (next %) %)) ; (\\2 \\3)\n                     (drop-while #(= \\0 %))      ; (\\2 \\3)\n                     (apply str)                 ;   \"23\"\n                     (read-string))))            ;    23\n              (range s (* 10 dhc10))))))         ; (range 10000 100000)\n    ]\n    (->> (inc (log10 n))\n      (iterate inc)\n      (map pal)\n      (apply concat)\n      (drop-while #(< % n)))))", "problem": 150, "user": "4fd96694e4b05e33b9224f37"}, {"code": ";; copied from the web, this problem really sucks! \n\n;; my solution is very similar but I got a timeout because it wasn't optimized\n\n(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))\n\n\n;;(fn palseq [n] \n;;  (letfn [(splitn [n]\n;;   (let [s (str n) \n;;         c (count s) \n;;         hc (int (/ c 2))]\n;;          (if (odd? c) \n;;              [(take hc s) (nth s hc) (take-last hc s)]\n;;              [(take hc s) (take-last hc s)])))\n;;\n;;(ren [a] (Integer/valueOf (apply str a)))\n;;\n;;(mpal ([s1 s2] (let [a (ren (reverse s1)) b (ren s2) a+1 (inc (ren s1)) ] \n;;  (if (>= a b) \n;;  \t(ren (concat s1 (reverse s1)))\n;;\t\t(ren (concat (str a+1) (reverse (str a+1)))))))\n;;\t\t\n;;\t\t([s1 m s2]\n;;\t\t  (if (seq s1) \n;;\t\t    (let [a (ren (reverse s1)) b (ren s2) mx (str (inc (ren (concat s1 [m])))) mx-1 (apply str (butlast mx))] \n;;\t\t\t(if (>= a b) \n;;\t\t\t\t(ren (concat s1 [m] (reverse s1)))\n;;\t\t\t\t(ren (concat  mx (reverse mx-1)))\n;;\t\t\t\t))(ren [m]))))\n;;(npal [n] (apply mpal (splitn n)))\n;;\n;;]\n;;; (let [np (apply mpal (splitn n))] (lazy-cat [np] (palseq (inc np))))\n;; (iterate (comp npal inc) (npal n))\n;;))", "problem": 150, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn next-pn [n]\n  (let [sn (str n)\n        len (count sn)\n        o (if (odd? len) 1 2)\n        pref (take (- (quot len 2) (dec o)) sn)\n        n-pref (if (not (empty? pref)) (str (inc (bigint (apply str pref)))))\n        f #(bigint (apply str (concat % (repeat o %2) (reverse %))))\n        local-res (filter #(<= n %) (map #(f pref %) \"0123456789\"))]\n    (concat\n      local-res\n      (lazy-seq (next-pn \n                  (if (or (empty? pref) (= #{\\9} (set (str (last local-res)))))\n                    (inc (last local-res))\n                    (f n-pref \\0)))))))", "problem": 150, "user": "4fa30027e4b081705acca187"}, {"code": "(fn q150 [n]\n  (letfn [\n          (to-digits [n] (if (< n 10) [n] (conj (to-digits (quot n 10)) (rem n 10))))\n          (to-num [coll] (reduce #(+ (* 10 %) %2) 0 coll))\n          (next-pal [n]\n            (let [digits (to-digits n)\n                  len (count digits)\n                  odd-len (odd? len)\n                  half (quot len 2)\n                  [ld rd] (partition (if odd-len (inc half) half) half digits)\n                  nld (if (>= (to-num (reverse ld)) (to-num rd)) ld (to-digits (inc (to-num ld))))\n                  nrd (reverse nld)\n                  ]\n              (to-num (concat nld (if odd-len (rest nrd) nrd)))))\n          ]\n    (iterate #(next-pal (inc %)) (next-pal n))))", "problem": 150, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [start] \r\n    (letfn [(mirror [n w] (str n (subs (clojure.string/reverse (str n)) (mod w 2))))\r\n            (pal [n w] (let [val (mirror n w)]\r\n                         (if (= (count val) w)\r\n                           (cons (read-string val) (lazy-seq (pal (inc n) w)))\r\n                           (recur (if (odd? w) (quot n 10) n) (inc w)))))\r\n            ]\r\n           (let [s (str start)\r\n                 s2 (subs s 0 (quot (+ (count s) 1) 2))]\r\n             (drop-while #(< % start) (pal (read-string s2) (count s))))))", "problem": 150, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(letfn [(p [n] (rem (+ n 1) 10))\n        (i ([v a b] \n             (let [v (assoc v a (p (v a)) b (p (v b)))]\n               (if (= (v a) 0)\n                 (recur v (- a 1) (+ b 1))\n                 v)))\n           ([v a]\n             (let [v (assoc v a (p (v a)))]\n               (if (= (v a) 0)\n                 (i v (- a 1) (+ a 1))\n                 v)))\n           ([v] (let [n (count v) h (quot n 2) g (- h 1)] \n                  (if (even? n) (i v g h) (i v h)))))\n        (f [v] \n           (lazy-seq\n             (let [w (if (every? #{9} v)\n                       (-> [] (conj 1) (into (repeat (-> v count dec) 0)) (conj 1) )\n                       (i v))]\n               (cons (->> v (apply str) read-string) (f w)))))\n        (s [n] \n           (let [v (->> n str (map #(-> % str read-string)) vec)\n                 N (count v)\n                 h (quot N 2)\n                 q (take h v)\n                 w (vec q)\n                 w (if (even? N) w (conj w (v h)))\n                 w (into w (reverse q))]\n             (some #(when (->> % (apply str) read-string (<= n )) %) (iterate i w))))]    \n  #(-> % s f))", "problem": 150, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [n]\n  (letfn \n     [(mkpal [seed par]\n        (read-string\n          (str (str seed)\n               (subs (clojure.string/reverse (str seed))\n                     par))))\n      (pdloop [sd mx prty]\n         (if (= sd mx)\n           (if (= prty 0)\n             (lazy-seq\n               (cons (mkpal sd (- 1 prty))\n                     (pdloop (inc sd)\n                             (* 10 mx)\n                             (- 1 prty))))\n             (let [sd2 (quot sd 10)\n                   par2 (- 1 prty)]\n               (lazy-seq\n                 (cons (mkpal sd2 par2)\n                     (pdloop (inc sd2) mx par2)))))\n           (lazy-seq\n             (cons (mkpal sd prty)\n                   (pdloop (inc sd) mx prty)))))]\n  (let [nstr (str n)\n        nlen (count nstr)\n        par1 (mod nlen 2)\n        seedstr1 (subs nstr 0 (+ par1 (quot nlen 2)))\n        seed1 (read-string seedstr1)\n        max1 (apply * (repeat (count seedstr1) 10))]\n    (drop-while #(< % n)\n                (pdloop seed1 max1 par1)))))", "problem": 150, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn [x]\n  (let [np (fn [n]\n             (let [sn (str n)\n                   hnext (str (inc (bigint (apply str (take (+ (quot (count sn) 2) (rem (count sn) 2)) sn)))))\n                   lnext (clojure.string/reverse (apply str (take (quot (count sn) 2) hnext)))]\n               (if (every? #(= \\9 %) sn)\n                  (+ n 2)\n                  (long (bigint (str hnext lnext))))))\n        mp (fn [n]\n             (let [sn (str n)\n                   hnext (apply str (take (+ (quot (count sn) 2) (rem (count sn) 2)) sn))\n                   lnext (clojure.string/reverse (apply str (take (quot (count sn) 2) hnext)))]\n              (long (bigint (str hnext lnext)))))\n        i (mp x)]\n    (if (< i x)\n      (iterate np (np i))\n      (iterate np i))))", "problem": 150, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": ";; Note that all palindromic numbers are either of the form:\n\n;; (concat x (reverse x)) for some sequence of one or more digits x,\n;; so the palindromic number has an even number of digits.\n\n;; or:\n\n;; (concat x [ d ] (reverse x)) for some sequence of digits x (perhaps\n;; empty) and some digit 'd', so the palindromic number has an odd\n;; number of digits.\n\n;; To generate the palindromic numbers in increasing order, we just\n;; need to make the sequence x (for even-length) or (concat x [d])\n;; (for odd-length) represent incrementing decimal numbers.\n\n;; function next-pal returns the smallest palindromic number that is\n;; greater than or equal to its argument.\n\n(fn [n]\n  (let [to-digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        to-int (fn [s] (read-string (apply str s)))\n        make-pal (fn [digits odd rev-digits]\n                   (to-int (concat digits\n                                   (if odd (rest rev-digits) rev-digits))))\n        next-pal (fn [n]\n                   (let [digits (to-digits n)\n                         len (count digits)\n                         half-len (quot (inc len) 2)\n                         half-digits (take half-len digits)\n                         pal (make-pal half-digits\n                                       (odd? len) (reverse half-digits))]\n                     (if (>= pal n)\n                       pal\n                       (let [half-digits+1 (to-digits\n                                            (inc (to-int half-digits)))]\n                         (make-pal (if (> (count half-digits+1) half-len)\n                                     (butlast half-digits+1)\n                                     half-digits+1)\n                                   (odd? len)\n                                   (reverse half-digits+1))))))]\n    (iterate #(next-pal (inc %))\n             (next-pal n))))", "problem": 150, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [n]\n    (let [palindrome? (fn [n]\n                        (let [s (str n)]\n                        (= (reverse s) (seq s))))\n          next-palindrome\n          (fn [pal]\n            (let [s (str pal)\n                  c (count s)\n                  taek (if (even? c)  \n                         (quot c 2)\n                         (inc (quot c 2)))\n                  lh (take taek s)\n                  l (last lh)\n                  b (str (apply str (butlast lh)) 0)\n                  ln (inc (read-string (str l))) \n                  bn (read-string b)\n                  s (str (+ ln bn))]\n              (read-string\n                (apply str s (reverse (take (quot c 2) s)))) \n              ))       \n          palindromes (fn palindromes [n]\n            (let [ next (next-palindrome n) ]\n              (if (< n 11)\n                (concat\n                  (filter (partial <= n) [0 1 2 3 4 5 6 7 8 9])\n                  (lazy-seq \n                    (cons 11 (palindromes 22))))\n                (lazy-seq \n                  (cons n (palindromes next)))) \n              ))\n          base (first (filter palindrome? (iterate inc n)))\n          result (palindromes (next-palindrome base))\n          ]\n      (if (palindrome? base)\n        (cons base result)\n        result)))", "problem": 150, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [n]\r\n  (letfn [(r [s] (apply str (reverse s)))\r\n          (g [s c]\r\n            (read-string (str s (r (subs s 0 (quot c 2))))))\r\n          (f [n]\r\n            (let [s (str n)\r\n                  c (count s)]\r\n              (if (every? #(= \\9 %) s) (+ n 2)\r\n                  (let [t (subs s 0 (quot (inc c) 2))\r\n                        l (g t c)\r\n                        u (str (inc (read-string t)))\r\n                        m (g u c)]\r\n                    (if (> l n) l m)))))]\r\n    (drop-while #(not= (str %) (r (str %))) (iterate f n))))", "problem": 150, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "5007f751e4b0b17c647f522b"}, {"code": "(fn [n]\r\n  (let [n-ls (str n)\r\n        c (count n-ls)\r\n        oddcount? (odd? c)\r\n        half (take (if oddcount? (inc (quot c 2)) (/ c 2)) n-ls)\r\n        p-s \r\n          (fn [s oc?] \r\n            (Long. (apply str (concat\r\n              s\r\n              (reverse (if oc? (butlast s) s))))))]\r\n    (filter #(>= % n) (map #(p-s (str (get % 1)) (get % 0)) ((fn nn [s oc?]\r\n      (let [i (Long. (apply str s))\r\n            bound? (every? #{\\9} s)]\r\n        (lazy-seq \r\n          (cons\r\n            [oc? i]\r\n            (nn\r\n              (str (if (and bound? oc?) (/ (inc i) 10) (inc i)))\r\n              (if bound? \r\n                (not oc?) \r\n                oc?)))))) half oddcount?)))))", "problem": 150, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [n]\n  (letfn [(to-int [s] (read-string s))\n          (find-first-palindromic [n]\n                                  (let [s (str n)\n                                        len (count s)\n                                        len2 (quot (count s) 2)\n                                        half (take len2 s)\n                                        two-halfs (concat half (if (odd? len) (list (nth s len2))) (reverse half))\n                                        ]\n                                    (to-int (clojure.string/join two-halfs))))\n          (find-next-palindromic [n]\n                                 (let [s (str n)\n                                       len (count s)\n                                       len2 (quot (count s) 2)\n                                       half (take (if (odd? len) (inc len2) len2) s)\n                                       nhalf (to-int (clojure.string/join half))\n                                       nhalf1 (inc nhalf)\n                                       shalf1 (str nhalf1)\n                                       drop-cnt (+ \n                                                  (if (> (count shalf1) (count half)) 1 0) \n                                                  (if (odd? len) 1 0))\n                                       two-halfs (condp = drop-cnt\n                                                   0 (concat shalf1 (reverse shalf1))\n                                                   1 (concat shalf1 (drop 1 (reverse shalf1)))\n                                                   2 (concat (drop-last shalf1) (drop 1 (reverse shalf1))) ) \n                                       ]\n                                   (to-int (clojure.string/join two-halfs))))\n          (initial-find [n]\n                        (let [nfp (find-first-palindromic n)]\n                          (if (> n nfp)\n                            (find-next-palindromic nfp)\n                            nfp) ))\n          (palindrom-finder [n]\n                            (let [fp (find-next-palindromic n)] \n                              (lazy-seq \n                                (cons fp\n                                      (palindrom-finder fp) ))) )\n          ]\n         (let [init (initial-find n)]\n           (cons init (palindrom-finder init))) ))", "problem": 150, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [n]\n   (letfn [ (to-int [c] (- (int c) 48))\n            (to-nr [x] (reduce #(+ (* 10  %1) %2) x))\n            (inc-str [x] (map to-int (str (inc (to-nr x))))) \n            (overflow [x] (every? #(= 9 %) x))\n            (pal? [x] (= x (reverse  x)))\n            (next-pal [s]\n     (let [\n           l (count s)\n           even (even? l)\n           pre (if even (take (/ l 2) s) (take (/ l 2) s))\n           post (if even (drop (/ l 2) s) (drop (dec (/ l 2)) s))\n           ] (cond\n               (and even (> (to-nr pre) (to-nr (reverse post)))) (concat pre (reverse pre))\n               (and even (overflow pre)) (concat (inc-str pre) (rest (reverse (inc-str pre))))\n               even  (concat (inc-str pre) (reverse (inc-str pre)))\n               (> (to-nr pre) (to-nr (reverse post)))  (concat pre (rest (reverse pre)))\n               (overflow pre) (concat (butlast (inc-str pre)) (rest (reverse (inc-str pre))))\n               :default  (concat (inc-str pre) (rest (reverse (inc-str pre))))\n              )\n       ))]\n          (let [c (map to-int (vec (str n))) \n                pals (iterate next-pal c)] \n            (map to-nr (if (pal? c) pals (rest pals))))\n       ))", "problem": 150, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [n]\n    (letfn [(rl-pair [n]\n              [(quot (inc n) 2), (quot n 2)])\n\n            (recombine [s k1 k2]\n              (Long/parseLong (apply str (concat (take k1 s)\n                                                 (reverse (take k2 s))))))\n            (nearest-palindrome [x]\n              (let [sx (str x)\n                    [k1 k2] (rl-pair (count sx))]\n                (recombine sx k1 k2)))\n\n            (next-palindrome [x]\n              (let [sx (str x)\n                    n (count sx)\n                    [k1 _] (rl-pair n)\n                    x' (inc (Long/parseLong (apply str (take k1 sx))))\n                    [kk1 kk2] (rl-pair (count (str (inc x))))]\n                (recombine (str x') kk1 kk2)))]\n\n      (drop-while #(< % n) (iterate next-palindrome\n                                    (nearest-palindrome n)))))", "problem": 150, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [n]\n  (let [pal? #(= (seq (str %)) (reverse (str %))) ; is it a palindrome number?\n        nextpal #(let [l (count (str %)) ; increase the first half, and mirror it\n                       half (apply str (take (/ l 2) (str %)))\n                       nh (if (pal? %) (str (inc (read-string half))) half)] ; \"new\" (increased if needed) half\n                  (read-string (str\n                    (if (not= (count nh) (count half)) (apply str (butlast nh)) nh) ; corner cases (9, 99, ...)\n                      (apply str (if (odd? l) ; odd digits\n                        (reverse (butlast nh))\n                        (reverse nh))))))]\n    (if (pal? n)\n      (iterate nextpal n) ; if start number is a palindrome, also list it\n      (drop-while #(< % n) (iterate nextpal (nextpal n)))))) ; otherwise, start with the next palindrome", "problem": 150, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [s]\n  (let [p #(Long. ^String (apply str % ((if %2 next seq) (reverse (str %)))))\n        d #(count (str %))\n        o #(odd? (d %))\n        b #(Long. (subs (str %) 0 (quot (+ 1 (d %)) 2)))\n        i #(let [x (b %)\n                 o (o %)\n                 y (+ 1 x)]\n             (cond\n              (= (d x) (d y)) (p y o)\n              o (p (/ y 10) nil)\n              1 (p y 1)))]\n    (filter #(>= % s) (iterate i (p (b s) (o s))))))", "problem": 150, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "4e944706535dbda64a6f6b11"}, {"code": "(fn pns [N] (let [\n  n2d (fn [n] (map #(- (int %) 48) (str n)))\n  d2n (fn [ds] (reduce #(+ %2 (* 10 %)) ds))\n  sym (fn [ds sh] (d2n (concat ds (reverse (if (zero? sh) ds (butlast ds))))))\n  ds  (n2d N)\n  nd  (count ds)\n  sh  (if (odd? nd) 1 0)\n  hds (take (/ (+ sh nd) 2) ds)\n  hn  (n2d (inc (d2n hds)))\n  cnp (sym hds sh)\n  np  (if (>= cnp N) cnp (sym hn sh))\n  ]\n  (cons np\n    (lazy-seq (pns (inc np))))))", "problem": 150, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [n] (letfn [(log10 [n] (count (take-while #(<= % n) (iterate #(*' % 10) 10))))\n                (pow10 [n] (apply *' (repeat n 10)))\n                (num-digs [n] (if (zero? n) 1 (inc (log10 n))))\n                (get-base [n] (let [digs (num-digs n) half-digs (int (/ digs 2))]\n                                [(quot n (pow10 half-digs)) (pow10 digs)]))\n                (rv [n] (if (zero? n) 0 (read-string (apply str (drop-while #(= \\0 %) (clojure.string/reverse (str n)))))))\n                (nxt [[b m]] (let [digs-b (num-digs b) digs-m (num-digs m)]\n                               (if (>= digs-b (num-digs (inc b)))\n                                 [(inc b) m] [(if (> digs-m (*' 2 digs-b)) (inc b) (/ (inc b) 10)) (*' m 10)])))\n                (palin [[b m]] (let [factor (pow10 (quot (log10 m) 2))]\n                                 (+' (*' b factor) (rem (rv b) factor))))\n                (base-seq [e] (lazy-seq (cons e (base-seq (nxt e)))))]\n          (drop-while #(< % n) (map palin (base-seq (get-base n))))))", "problem": 150, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [n]\n    (let [q quot\n          r rseq\n          x reduce\n          z 10]\n      (letfn [(d [n] (if (< n z) [n] (conj (d (q n z)) (rem n z))))\n              (e [n] (x #(+ (* % z) %2) 0 n))\n\n              (g [n o t]\n                (let [m (+ 1 n)\n                      a (d n)]\n                  (cons (e (into a (if o (rest (r a)) (r a))))\n                        (lazy-seq\n                          (cond\n                            (not= m t) (g m o t)\n                            o (g (q m z) nil t)\n                            1 (g m 1 (* 10 t)))))))]\n        \n        (let [a (d n)\n              l (count a)]\n          (drop-while #(< % n) (g (e (take (- l (q l 2)) a))\n                                  (= 1 (rem l 2)) \n                                  (x * (repeat l z))))))))", "problem": 150, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn pali [n]\r\n  (let [intern-pali \r\n        (fn genp [is-odd k prevk]\r\n          ;(println \"isodd: \" is-odd \", k: \" k \", prevk: \" k)\r\n    (let [strk (str k)\r\n          strpk (str prevk)]\r\n      ;(println strk strpk)\r\n      ;(println (butlast strk))\r\n      ;(println (count strk))\r\n      (if (= (count strk) (count strpk))\r\n        (let [paly  \r\n              (if is-odd \r\n                (apply str strk (rest (reverse strk)))\r\n                (apply str strk (reverse strk)))\r\n              ]\r\n          ;(println \"paly: \" paly)\r\n          (lazy-seq (cons\r\n            (biginteger paly)\r\n            (genp is-odd (inc k) k))))\r\n        (let [newk (if is-odd (quot k 10) k)]\r\n            (genp (not is-odd) newk newk)))))]\r\n    (let [strn (str n)\r\n          c (count strn)\r\n          halfc (quot (inc c) 2)\r\n          h-strn (take halfc strn)\r\n          hn (biginteger (apply str h-strn))\r\n          lp (intern-pali (odd? c) hn hn)]\r\n      (if (< (first lp) n)\r\n             (rest lp)\r\n             lp))))", "problem": 150, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn [x]\r\n  (letfn [(en [X] (reduce #(+ (* % 10) %2) 0 X))\r\n          (de [x] (if (< x 10) [x] (conj (de (quot x 10)) (mod x 10))))\r\n          (getnext\r\n           [x]\r\n           (let [X (de x)\r\n                 n (count X)\r\n                 l (quot n 2)\r\n                 H (drop-last l X)\r\n                 H1 (de (inc (en H)))\r\n                 L (reverse (take l H))\r\n                 L1 (reverse (take l H1))\r\n                 ans (en (concat H L))] \r\n             (if (>= ans x) ans (en (concat H1 L1)))))]\r\n    (iterate (comp getnext inc) (getnext x))))", "problem": 150, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(letfn [\n    (make-palin-odd [n] (bigint (str (str n) (apply str (rest (reverse (str n)))))))\n    (make-palin-even [n] (bigint (str (str n) (apply str (reverse (str n))))))\n    (p [m] (apply * (repeat m 10)))\n   ]\n  (fn palindromes [n]\n    (let [c (count (str n)) d (quot (inc c) 2)\n    f (quot n (p (quot c 2)))\n]\n    (cond\n      (zero? n) (cons 0 (palindromes 1))\n      (zero? (mod c 2)) (lazy-cat \n        (remove #(< % n) (map make-palin-even (range f (p d))))\n        (palindromes (p c)))\n      :else (lazy-cat \n        (remove #(< % n) (map make-palin-odd (range f (p d))))\n        (palindromes (p c)))))))", "problem": 150, "user": "503917a0e4b088a6a14ca763"}, {"code": "(letfn\n    [(palind? [x] (= (str x) (clojure.string/reverse (str x))))\n     (str-inc [s] (->> s read-string inc str))\n     (make-palind [l c]\n       (read-string (apply str (concat l [c] (reverse l)))))\n     (next-palind [x]\n       (let [s   (str (inc x))\n             len (count s)\n             mid (quot (inc len) 2)\n             l   (subs s 0 mid)\n             r   (subs s (if (even? len) mid (dec mid)))]\n         (if (>= (compare (clojure.string/reverse l) r) 0)\n           (if (even? len)\n             (make-palind l nil)\n             (make-palind (butlast l) (last l)))\n           (let [l' (str-inc l)]\n             (if (and (even? len) (= (count l') (count l)))\n               (make-palind l' nil)\n               (make-palind (butlast l') (last l')))))))]\n  #(iterate next-palind (next-palind (dec %))))", "problem": 150, "user": "50586354e4b06522596eba78"}, {"code": "(letfn [(digits [n]\n          (let [radix 10]\n            (reverse\n             (map\n              (fn [x] (int (rem x radix)))\n              (take-while (complement zero?)\n                          (iterate (fn [x] (quot x radix))\n                                   n))))))\n        (to-int [coll]\n          (reduce (fn [result val]\n                    (+ (* 10 result) val))\n                  0\n                  coll))\n        (power [base exponent]\n          (apply * (take exponent (repeat (bigint base)))))\n        (next-palindrome [n]\n          (if (< n 9)\n            (inc n)\n            (let [d (digits n)]\n              (if (= #{9} (set d))\n                (+ n 2)\n                (let [c (count d)\n                      left-count (int (/ (inc c) 2))\n                      right-count (- c left-count)                    \n                      left-half (inc (bigint (/ (* n 1.0)\n                                                (power 10 right-count))))\n                      right-half (to-int (reverse (take right-count\n                                                        (digits left-half))))]\n                  (+ (* (power 10 right-count)\n                        left-half)\n                     right-half))))))\n        (palindromes-from [n]\n          (lazy-seq (cons n\n                          (palindromes-from (next-palindrome n)))))]\n  (fn [n]\n    (let [first-palindrome (first\n                            (filter (fn [x] (let [d (digits x)]\n                                       (= d (reverse d))))\n                                    (range n Double/POSITIVE_INFINITY)))]\n      (palindromes-from first-palindrome))))", "problem": 150, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n        (next-pal [n]\n          (let [N (decode n)\n                l (count N)\n                d (quot l 2)\n                H (take d N)\n                H1 (decode (inc (encode H)))\n                Hr (reverse H)\n                h (encode Hr)\n                p (nth N d)\n                t (encode (take-last d N))]\n            (cond\n              (and (even? l) (>= h t)) (encode (concat H Hr))\n              (and (odd? l) (>= h t)) (encode (concat H [p] Hr))\n              (even? l) (encode (concat H1 (reverse H1)))\n              (and (odd? l) (< p 9)) (encode (concat H [(inc p)] Hr))\n              :else (encode (concat H1 [0] (reverse H1))))))]\n(iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn [n]\n    (letfn [(ceil [n] (if (< 0 (- n (int n))) (-> n int inc) (int n)))\n            (round [x y] (int (* y (ceil (/ x y)))))\n            (p [n]\n              (let [s (str n)]\n                (if (= s (clojure.string/reverse s))\n                  n\n                  (let [c (.length s)\n                        h (ceil (* c 0.5))\n                        r (subs s 0 h)\n                        rr (subs (clojure.string/reverse r) (if (even? c) 0 1))\n                        m (read-string (str r rr))]\n                    (if (< n m) m\n                      (let [x (int (Math/pow 10 (dec h)))\n                            n9? (= 9 (-> r last int (- 48)))]\n                        (cond n9? (recur (round n (Math/pow 10 h)))\n                              (odd? c) (recur (+ m x))\n                              :else \n                                (recur (+ m (* 11 x))))))))))]\n      (iterate (comp p inc) (p n))))", "problem": 150, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [n]\n  (letfn [(digits [n] (map #(- (int %) 48) (str n)))\n          (number [s] (apply + (map #(* %1 %2) (reverse s) (iterate #(* 10 %) 1))))\n          (first-pal-num [n] (next-pal-num (dec n)))\n          (next-pal-num [n]\n            (let [k (inc n) ds (digits k) l (count ds) le? (even? l)\n                  first-half (take (/ (if le? l (inc l)) 2) ds)\n                  m (number (concat first-half (reverse (if le? first-half (butlast first-half)))))]\n              (if (>= m k)\n                m\n                (let [raised (digits (inc (number first-half)))]\n                  (number (concat raised (reverse (if le? raised (butlast raised)))))))))]\n    (iterate next-pal-num (first-pal-num n))))", "problem": 150, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn f [n]\n              (let [->vec (fn d [n] (let [[q r] [(quot n 10) (rem n 10)]]\n                                      (if (pos? q) (conj (d q) r) [r])))\n                    ->num (fn [l] (apply + (map * (reverse  l) (iterate #(* 10 %) 1))))\n                    up (fn u [l n] (let [[v m] [(pop l) (peek l)]\n                                         s (+ n m)\n                                         [q r] [(quot s 10) (rem s 10)]]\n                                     (if (zero? q) (conj v r) (conj (u v 1) r)))) \n                    g (fn g [xs] (let [[t m b] [(first xs) (vec (drop-last (drop 1 xs))) (last xs)]]\n                                   (cond (<= (count xs) 1) xs\n                                         (<= b t) (concat [t] (g m) [t])\n                                         :else (g (up xs (- (+ 10 t) b)))\n                                         )))\n                    h (fn [n] (->num (g (->vec n))) )]\n                (lazy-seq (cons (h n) (f (inc (h n))))\n                          )\n                ) )", "problem": 150, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn ps [n]\n  (letfn\n\t\t[\n\t\t\t(palindromic? [n] (= (seq (str n)) (reverse (str n))))\n\t\t\t(parity [n] (mod (count (str n)) 2))\n\t\t\t(halflength [n] (quot (count (str n)) 2))\n\t\t\t(half [n] (let [is (str n)] (take (+ (halflength n) (parity n)) is)))\n\t\t\t(inchalf [n] (seq (str (inc (read-string (apply str (half n)))))))\n\t\t\t(next [n]\n\t\t\t\t(read-string\n\t\t\t\t\t(apply str\n\t\t\t\t\t\t(apply concat\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t(if (> (count (inchalf n)) (count (half n)))\n\t\t\t\t\t\t\t\t(if (zero? (parity n))\n\t\t\t\t\t\t\t\t\t[(inchalf n) (rest (reverse (inchalf n)))]\n\t\t\t\t\t\t\t\t\t[(butlast (inchalf n)) (rest (reverse (inchalf n)))]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t(if (zero? (parity n))\n\t\t\t\t\t\t\t\t\t[(inchalf n) (reverse (inchalf n))]\n\t\t\t\t\t\t\t\t\t[(inchalf n) (rest (reverse (inchalf n)))]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(make-palindromic [n]\n\t\t\t\t(loop [p (read-string (apply str (concat (half n) (if (zero? (parity n)) (reverse (half n)) (rest (reverse (half n)))))))]\n\t\t\t\t\t(if (>= p n)\n\t\t\t\t\t\tp\n\t\t\t\t\t\t(recur (next p))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(let [p (make-palindromic n)]\n\t\t\t(cons p (lazy-seq (ps (next p))))\n\t\t)\n\t)\n)", "problem": 150, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn palind [n]\r\n(letfn [\r\n(strcount [x] (count (str x)))\r\n(digits [n] (map #(- (int %) (int \\0)) (str n)))\r\n(dig2num [ds]\r\n  (reduce #(+ (* 10 %1) %2) ds))\r\n(odd-pal [x]\r\n  (let [ds (digits x)]\r\n    (dig2num (concat ds (rest (reverse ds))))))\r\n(even-pal [x]\r\n  (let [ds (digits x)]\r\n    (dig2num (concat ds (reverse ds)))))\r\n(pow10 [n]\r\n  (if (= n 0) 1 (* 10 (pow10 (dec n)))))\r\n(make-num-of-length [hlen]\r\n  (range (int (pow10 (dec hlen))) (int (pow10 hlen))))\r\n(make-num-with-same-count-ge-n [n]\r\n  (range n (int (pow10 (strcount n)))))\r\n(make-palinds [hlen]\r\n  (let [xs (make-num-of-length hlen)]\r\n    (concat (lazy-seq (map odd-pal xs))\r\n            (lazy-seq (map even-pal xs))\r\n            (lazy-seq (make-palinds (inc hlen))))))\r\n(make-palinds-ge [n]\r\n  (let [hlen (int (/ (inc (strcount n)) 2))\r\n        xsn (make-num-with-same-count-ge-n (dig2num (take hlen (digits n))))\r\n        xs (make-num-of-length hlen)]\r\n    (if (odd? (strcount n))\r\n      (concat (lazy-seq (filter #(<= n %) (map odd-pal xsn)))\r\n              (lazy-seq (map even-pal xs))\r\n              (lazy-seq (make-palinds (inc hlen))))\r\n      (concat (lazy-seq (filter #(<= n %) (map even-pal xsn)))\r\n              (lazy-seq (make-palinds (inc hlen)))))))\r\n]\r\n(if (= n 0)\r\n  (cons 0 (make-palinds 1))\r\n  (make-palinds-ge n))))", "problem": 150, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn pal [from]\n  (letfn[\n    (stick [small n] \n      (let [other-half (if small (int (/ n 10)) n)]\n        (BigInteger.\n          (apply str other-half\n            (reverse (str n))))))\n    (pali [small [n high]]\n      (lazy-seq\n        (concat\n          (map #(stick small %) (range n high))\n          (pali (not small) \n            (if small [(/ high 10) high] [high (* 10 high)])))))\n  ]\n  (drop-while #(< % from)\n    (let [digits (count (str from))\n          half (int (/ digits 2))\n          small (pos? (- digits half half))\n          high (reduce * (repeat (- digits half) 10))\n          from (int (reduce / from (repeat half 10)))]\n      (pali small [from high])))))", "problem": 150, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn f [d]\n    (let [s (str d)\n          left (apply str (take (quot (count s) 2) s))\n          middle (if (odd? (count s)) (-> s (nth (quot (count s) 2))\n                                          str))\n          num #(read-string (apply str %&))]\n      (drop-while #(< % d)\n                  (cons\n                   (num left middle (apply str (seq (reverse left))))\n                   (lazy-seq (f (num (inc (num left middle))\n                                     (apply str (repeat (count left) \\0)))))))))", "problem": 150, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [start]\n  (let [to-digits   (fn digs [n] (if (< n 10) [n] (conj (digs (quot n 10)) (rem n 10))))\n        num-digits  (fn [n] (loop [n n c 1] (if (< n 10) c (recur (quot n 10) (inc c)))))\n        from-digits (fn [s] (reduce #(+ (* % 10) %2) 0 s))\n        digits      (to-digits start)\n        length      (count digits)\n        base        (from-digits (take (/ length 2) digits))\n        pow         (fn [n e] (reduce * (repeat e n)))\n        next-b&ds   (fn [b ds]\n                      (let [nb (inc b)]\n                        (cond\n                         (= (num-digits nb) (num-digits b)) [nb           ds]\n                         (odd? ds)                          [(quot nb 10) (inc ds)]\n                         :else                              [nb           (inc ds)])))\n        pals       (fn next-pal [n ds]\n                     (let [h   (to-digits n)\n                           t   (drop (if (odd? ds) 1 0) (reverse h))\n                           p   (from-digits (concat h t))\n                           [nxt nds] (next-b&ds n ds)]\n                       (lazy-seq (cons p (next-pal nxt nds)))))]\n    (drop-while #(> start %) (pals base length))))", "problem": 150, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn [n]\n  (let[\n       cgt (fn[a b] (> (int a) (int b)))\n       find-end (fn[r s cur] (loop[r r s s cur \"\"] (cond (empty? r) cur (cgt (first r) (first s)) nil\n                                                :else (recur (next r) (next s) (cons (first s) cur)))))\n       to-pal (fn to-pal[s] (let[\n                                 c (count s)\n                                 ml (quot c 2)\n                                 mh (quot (inc c) 2)\n                                 r (take ml (reverse s)) end (find-end r s \"\")]\n                              (if end (apply str (concat (take mh s) end)))))\n       inc-pal (fn inc-pal[s] (let[\n                                   c (count s)\n                                   ml (quot c 2)\n                                   mh (quot (inc c) 2)]\n                                (apply str (concat (->> (take mh s) (apply str) read-string inc str) (take ml (repeat \\0 ))))))\n         get-pal (fn[s] (let[x (to-pal s)] (if x x (-> s inc-pal to-pal))))\n            ]\n    (map read-string (iterate (comp to-pal inc-pal) (get-pal (str n))))))", "problem": 150, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn palindromic-nums [n]\n  (letfn [\n\t(char-to-digit [ch]\n\t   (- (int ch) (int \\0)))\n\t(str-to-digits [str-num]\n\t  (map char-to-digit str-num))\n\t(palindrome? [p]\n\t    (let [x (str-to-digits (str p))\n\t\t\t  split (split-at (/ (count x) 2) x)\n\t          p1 (first split) p2 (second split)]\n\t        (if (odd? (count x))\n\t            (= (reverse (butlast p1)) p2)\n\t            (= (reverse p1) p2))\n\t    )\n\t)\n\t(compress-palindrome [palindrome]\n\t   (let [p (str-to-digits (str palindrome))\n\t\t\t split (split-at (/ (count p) 2) p)\n\t         fp (first split)]\n\t\t\t(if (odd? (count p)) \n\t\t\t\t(concat (butlast fp) [[(last fp)]])\n\t\t\t\t(concat (butlast fp) [[(last fp) (last fp)]])\n\t\t\t) \n\t   )\n\t)\n\t(expand-palindrome-inner [p]\n\t    (let [f (first p) r (rest p)]\n\t\t(if (empty? r) f\n\t\t\t(concat [f] (expand-palindrome-inner r) [f])  \n\t\t)\n\t\t)\n\t)\n\t(expand-palindrome [p]\n\t  (reduce (fn [a b] (+ (* 10 a) b)) (expand-palindrome-inner p))\n\t)\n\t(inc-palin [p]\n\t\t(let [is-double (= 2 (count (last p)))]\n\t\t(if (>= (count (filter #(not= 9 %) (flatten p))) 1) \n\t\t\t(loop [p (reverse p) res () con true]\n\t\t\t\t\t(let [fp (first p) \n\t\t\t\t\t\t  rp (rest p) \n\t\t\t\t\t\t  tocheck (if (coll? fp) (first fp) fp)\n\t\t\t\t\t\t  coll-check (coll? fp)]\n\t\t\t\t    (cond (empty? p) res\n\t\t\t\t\t\t  (false? con) (recur rp (cons fp res) false) \n\t\t\t\t\t\t  (= 9 tocheck) \n\t\t\t\t\t\t  (if (true? coll-check) (recur rp (cons (if (true? is-double) [0 0] [0]) res) true)\n\t\t\t\t\t\t                         (recur rp (cons 0 res) true))\n\t\t\t\t\t\t  :else (recur rp (cons (if (coll? fp) (map inc fp) (inc fp)) res) false)\n\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t)\n\t\t\t(cond (true? is-double)\n\t\t\t\t  (concat [1] (repeat (- (count p) 1) 0) [[0]])\n\t\t\t\t  (= (count p) 1)\n\t\t\t\t  [[1 1]]\n\t\t\t\t  :else (concat [1] (repeat (- (count p) 2) 0) [[0 0]]))\n\t\t)\n\t\t)\n\t)\n\t(iterfunc [x]\n\t\t(lazy-seq (cons (expand-palindrome x) (lazy-seq (iterfunc (inc-palin x)))))\n\t)]\n\t(let [start (first (filter palindrome? (range n Long/MAX_VALUE)))\n\t\t  compressed (compress-palindrome start)]\n\t\t(iterfunc compressed)\n\t)\n\t)\n)", "problem": 150, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [i]\n  (let [t? (fn [xx] (let [ss (str xx) ll (count ss) mm (quot ll 2) offset0 (if (odd? ll) 1 0)]\n                (= (take mm ss) (reverse (subs ss (+ offset0 mm) ll)))))\n        nexti (fn [x]\n                (let [s (str x) l (count s) m (quot l 2) offset (if (odd? l) 1 0)\n                      lefts (subs s 0 (+ offset m)) nleft (inc (read-string lefts))\n                      change (not= (count lefts) (count (str nleft)))]\n                      (cond (and change (odd? l)) (inc (/ (* nleft nleft) 10))\n                            change (inc (* nleft nleft))\n                            (odd? l) (read-string (apply str nleft (rest (reverse (str nleft)))))\n                            :else (read-string (apply str nleft (reverse (str nleft)))))))\n        firsti (fn [x]\n                  (let [s (str x) l (count s) m (quot l 2) offset (if (odd? l) 1 0)\n                        lefts (subs s 0 (+ offset m)) mayn (if (odd? l) \n                        (read-string (apply str lefts (rest (reverse lefts))))\n                        (read-string (apply str lefts (reverse lefts))))]\n                      (if (> x mayn)\n                          (nexti mayn)\n                        mayn)))\n        build (fn build [x]\n                (lazy-seq\n                  (cons x (build (nexti x)))))]\n        (build (firsti i))))", "problem": 150, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [x]\n  (letfn [(f [n]\n            (let [m (str n) c (count m)]\n              (cond\n               (every? (fn [a] (= \\9 a)) m) (+ 2 n)\n               (even? c) (let [px (str (inc (bigint (subs m 0 (quot c 2)))))]\n                           (bigint (str px (clojure.string/reverse px))))\n               :else (let [px (subs m 0 (quot c 2))\n                           py (bigint (str (get m (quot c 2))))]\n                       (if (= 9 py)\n                         (let [i (str (inc (bigint px)))]\n                           (bigint (str i \"0\" (clojure.string/reverse i))))\n                         (bigint (str px (str (inc py)) (clojure.string/reverse px))))))))]\n    (let [y (if (= (str x) (clojure.string/reverse (str x)))\n              x\n              (loop [i x]\n                (if (= (str i) (clojure.string/reverse (str i)))\n                  i\n                  (recur (inc i)))))]\n      (iterate f y))))", "problem": 150, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn __ [n]\n  (let [ic (into {} (map vec (partition 2 1 \"0123456789\")))\n        step (fn [a]\n               (let [s (vec (str a))\n                     width (count s)\n                     b (quot width 2)]\n                 (letfn [(itr [s pos]\n                           (if (and (= (dec width) (+ b pos))\n                                    (= \\9 (nth s (+ b pos))))\n                             (str (+ a 2))\n                             (if (= (nth s (+ b pos)) \\9)\n                               (recur (-> s\n                                          (assoc (+ b pos) \\0)\n                                          (assoc (- width b pos 1) \\0))\n                                      (inc pos))\n                               (-> s\n                                   (assoc (+ b pos) (ic (nth s (+ b pos))))\n                                   (assoc (- width b pos 1) (ic (nth s (+ b pos))))))))]\n                   (bigint (clojure.string/join (itr s 0))))))]\n    (iterate step\n             (loop [m n]\n               (if (= (vec (str m)) (reverse (str m)))\n                 m\n                 (recur (inc m)))))))", "problem": 150, "user": "504f57c7e4b0a02f9cffde71"}, {"code": ";;condotti soln\n(fn [n]\n  (letfn [(r [s] (apply str (reverse s)))\n          (g [s c]\n            (read-string (str s (r (subs s 0 (quot c 2))))))\n          (f [n]\n            (let [s (str n)\n                  c (count s)]\n              (if (every? #(= \\9 %) s) (+ n 2)\n                  (let [t (subs s 0 (quot (inc c) 2))\n                        l (g t c)\n                        u (str (inc (read-string t)))\n                        m (g u c)]\n                    (if (> l n) l m)))))]\n    (drop-while #(not= (str %) (r (str %))) (iterate f n))))\n\n#_\n;;my soln \n(letfn [(rev [s] (clojure.string/reverse s))\n        (even-gen [s] (Long/parseLong (str s (rev s))))\n        (odd-gen [s] (Long/parseLong (str s (rev (subs s 0 (dec (count s)))))))\n        (start [n] (let [s (str n) l (count s)] \n          (if (even? l) \n            (let [gen (Long/parseLong (subs s 0 (quot l 2)))\n                  guess (even-gen (str gen))]\n              (if (>= guess n)\n                [guess gen (long (Math/pow 10 (quot l 2))) :even even-gen odd-gen]\n                [(even-gen (str (inc gen))) (inc gen) (long (Math/pow 10 (quot l 2))) :even even-gen odd-gen]))\n            (let [gen (Long/parseLong (subs s 0 (inc (quot l 2))))\n                  guess (odd-gen (str gen))]\n              (if (>= guess n)\n                [guess gen (long (Math/pow 10 (inc (quot l 2)))) :odd odd-gen even-gen]\n                [(odd-gen (str (inc gen))) (inc gen) (long (Math/pow 10 (inc (quot l 2)))) :odd odd-gen even-gen])))))]\n  (fn t [limit]          \n    (map first  \n      (lazy-cat \n        (when (< limit 100)\n          (drop-while (fn [[n]] (> limit n))\n          (lazy-cat \n            (map vector (range 0 10)) \n            (map vector [11 22 33 44 55 66 77 88 99]))))\n      (iterate \n        (fn [[p n b r f g]] \n          (let [nx (inc n)]\n            (if (== b nx) \n              (if (= r :odd)\n                [(g (str (/ b 10))) (/ b 10) b :even g f]\n                [(g (str nx)) nx (* b 10) :odd g f])\n              [(f (str nx)) nx b r f g])))  \n        (start (if (< limit 100) 100 limit)))))))", "problem": 150, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn re-palin [n]\n  (letfn[(pow [n] (loop [n n r 1] (if (zero? n) r (recur (dec n) (* 10 r)))))  \n         (next-palin [[pre mid length]]\n                     (let [limit (pow (quot length 2))]\n                       (cond \n                         (and (even? length) (= limit (inc pre))) [(quot (inc pre) 10) 0 (inc length)]\n                         (even? length) [(inc pre) 0 length] \n                         (> 9 mid) [pre (inc mid) length]\n                         (= limit (inc pre)) [(inc pre) 0 (inc length)]\n                         :else [(inc pre) 0 length])))                         \n                      \n         (from-pal [[pre mid length]]\n                   (loop [n (if (even? length) pre (+ mid (* 10 pre))) r pre]\n                     (if (zero? r) n (recur (+ (* 10 n) (rem r 10)) (quot r 10)))))\n         (toDigits [n] (if (< n 10) [n] (conj (toDigits (quot n 10)) (rem n 10))))\n         (toNum [x] (reduce #(+ (* % 10) %2) 0 x))\n         (close-pal [n]\n                    (let [digits (vec(toDigits n))\n                          l (count digits)\n                          pre (toNum (take (quot l 2) digits))\n                          mid (if (even? l) 0 (digits (quot l 2)))\n                          pal [pre mid l]]\n                      (if (> n (from-pal pal)) (next-palin pal) pal )))]               \n              (map from-pal (iterate next-palin (close-pal n)))))", "problem": 150, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [n]\n  (letfn [(lst [n]\n          (loop [n n acc '()]\n            (if (< n 10) (cons n acc)\n                (recur (quot n 10) (cons (mod n 10) acc)))))\n        (nbr [s]\n          (loop [[a & r] s n 0]\n            (if a (recur r (+ (* n 10) a)) n)))\n        (splt [n]\n          (let [lst (lst n)\n                c (count lst)\n                hf (quot (inc c) 2)\n                l (take hf lst)\n                r (drop (- c hf) lst)]\n            [(even? c) l r]))\n        (next-palin [n]\n          (let [[evn? l r] (splt n)\n                 l (lst (inc (nbr l)))\n                 over? (> (count l) (count r))\n                 l (if over? (cons 1 (drop 2 l)) l)\n                 r (reverse l)]\n            (nbr (concat l (if over?\n                       (if evn? (cons 0 r) r)\n                       (if evn? r (rest r)))))))\n        (start [n]\n          (let [[evn? l r] (splt n)\n                cmpr (compare (vec l) (vec (reverse r)))]\n            (if (= 0 cmpr) n\n              (nbr (let [l (if (< 0 cmpr) l (lst (inc (nbr l))))\n                         r (reverse l)]\n                     (concat l (if evn? r (rest r))))))))]\n      (iterate next-palin (start n))))", "problem": 150, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn p150 [n]\r\n  (let [tempstr (seq (str n))\r\n        len (count tempstr)\r\n        isPal (= tempstr (reverse tempstr))\r\n        mid  (if (even? len) (/ len 2) (/ (inc len) 2) )\r\n        halfStr (take mid tempstr)\r\n        pow (fn [v] )\r\n        pow (fn pow [n] (loop [acc 1 cnt n]\r\n                          (if (zero? cnt) acc\r\n                            (recur (* acc 10) (dec cnt))\r\n                            )) )\r\n        half (int (quot n (pow  (if (odd? len) (dec mid) mid))))\r\n        newHalf (seq (str (inc half)))\r\n        lengthChanged (not= mid (count newHalf))\r\n\r\n        encode (fn encode [k] (let [m {\\0 0, \\1 1, \\2 2,\\3 3, \\4 4, \\5 5, \\6 6 ,\\7 7, \\8 8, \\9 9}]\r\n                                (get m k)\r\n                                ))\r\n\r\n        parse (fn parse [cols] (reduce #(+ (* % 10) %2) (map encode cols)))\r\n\r\n        newpal (parse (if (odd? len)\r\n                                    (concat halfStr (reverse (drop-last halfStr)))\r\n                                    (concat halfStr (reverse halfStr))\r\n                                    ))\r\n        nextPal\r\n        (\r\n          cond\r\n          (< n 9)  n\r\n          (= n 9) 11\r\n          :else (if (> newpal n) newpal (parse\r\n                                          (if (or lengthChanged (odd? len))\r\n                                            (concat newHalf (reverse (drop-last newHalf)))\r\n                                            (concat newHalf (reverse newHalf))\r\n                                            ))))\r\n          ]\r\n          ;(print nextPal )\r\n          (cons (if isPal n nextPal) (lazy-seq (p150 (if isPal (inc n) (inc nextPal) ))))\r\n          ;pal0\r\n          )\r\n        )", "problem": 150, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [n]\n  (letfn [(parts [a]\n            (let [s (vec (re-seq #\"\\d\" (str a)))\n                  c (count s)]\n              (vector\n                (subvec s 0 (quot c 2))\n                (subvec s (quot c 2) (quot (inc c) 2)))))\n          (to-number [half mirror]\n            ;(println \"h:\" half \"m\" mirror)\n            (let [h (if (zero? half) \"\" half)]\n              (BigInteger.\n                (str h mirror (reduce str (reverse (str h)))))))\n          (digits [n]\n            (count (str n)))\n          (ten-power? [n]\n            (re-find #\"^10*$\" (str n)))\n          (pow-10 [n] (first (drop n (iterate #(* % 10) 1))))\n          (palindromes [half mirror]\n            ;(println \"h:\" half \"m:\" mirror)\n            (lazy-seq\n              (cond\n                ;(zero? half)\n                ;  (concat (range 10)\n                ;          (palindromes 1 nil))\n                (= mirror 10)\n                  (if (ten-power? (inc half))\n                      (palindromes (inc half) nil)\n                      (palindromes (inc half) 0))\n                (and mirror (not= mirror :no-mirror))\n                  (cons (to-number half mirror)\n                        (palindromes half (inc mirror)))\n                (ten-power? half)\n                  (if (nil? mirror)\n                    (cons (to-number half nil)\n                          (palindromes (inc half) :no-mirror))\n                    (palindromes (quot half 10) 0))\n                :else\n                  (cons (to-number half nil)\n                        (palindromes (inc half) mirror)))))]\n    (let [half (quot n (pow-10 (quot (digits n) 2)))\n          ps (if (odd? (digits n))\n               (palindromes (quot half 10) (rem half 10))\n               (palindromes half nil))\n          ]\n      (if (< (first ps) n)\n        (drop 1 ps)\n        ps))))", "problem": 150, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [n]\n    (letfn\n        [(nextp [n]\n           (let [len  (count (str (int n)))\n                 mid  (int (Math/floor (/ len 2)))\n                 splt (int (quot n (Math/pow 10 mid)))\n                 n2d  (fn [n] (map #(- (int %) (int \\0)) (str n)))\n                 d2n  (fn [d] (reduce #(+ (* %1 10) %2) d))\n                 m2n  (fn [d] (d2n (concat d (if (= len (* 2 mid)) (reverse d) (rest (reverse d))))))\n                 ;; rnd  (let [i (Math/pow 10 mid)] (* i (inc (int (/ n i)))))\n                 np   (m2n (n2d splt))]\n             (cond\n              (and (>= n np) (= 9 (last (n2d splt)))) (nextp (let [i (Math/pow 10 mid)] (* i (inc (int (/ n i))))))\n              (<= np n) (m2n (n2d (inc splt)))\n              :else np)))]\n      (iterate nextp (if (= (str n) (clojure.string/reverse (str n))) n (nextp n)))))", "problem": 150, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn __ [n]\n  (letfn [(n->digits [n]\n            (reverse (map #(rem % 10)\n                          (take-while (complement zero?)\n                                      (iterate #(quot % 10) n)))))\n          (digits->n [d]\n            (reduce (fn [c x] (+ (* 10 c) x)) 0 d))\n          (n->palindrome [n e?]\n            (let [d (n->digits n)]\n              (digits->n (concat d (reverse (if e? d (butlast d)))))))\n          (pali-seq [n e?]\n            (lazy-seq (cons (n->palindrome n e?)\n                            (let [inc-n (inc n)\n                                  mag-chg? (apply not= (map (comp count n->digits)\n                                                            (list n inc-n)))\n                                  next-n  (if (and mag-chg? (not e?)) (quot inc-n 10) inc-n)\n                                  next-e? (if mag-chg? (not e?) e?)]\n                              (pali-seq next-n next-e?)))))]\n\t(let [start-digs (n->digits n)\n          num-digs (count start-digs)\n          is-even? (even? num-digs)]\n      (filter (partial <= n)\n              (pali-seq (digits->n (take ((if is-even? identity inc)\n                                          (quot num-digs 2))\n                                   start-digs))\n                        is-even?)))))", "problem": 150, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [n]\n  (let [i #(iterate inc %)\n        a #(apply str %)\n        r #(reverse (str %))\n        \n        m (str n)\n        l (count m)\n        o? (odd? l)\n        s (BigInteger. (let [v (a (take (/ l 2) m))] (if (= v \"\") \"0\" v)))\n        \n        eo #(for [n (i (if %1 s (inc s)))]\n              (BigInteger. (str n (a (drop %2 (r n))))))\n        e (eo (not o?) 0)\n        o (eo o? 1)\n        \n        t (fn stitch [op [x & xx :as xs] [y & yy :as ys]]\n             (cons (if (op x y) x y) \n                   (lazy-seq (apply stitch op (if (op x y) [xx ys] [xs yy])))))]\n    (->>\n     (t < o e)\n     (filter #(<= n %)))))", "problem": 150, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [n]\n  (letfn\n    [(startpal [x]\n              (first (drop-while #(not= (seq (str %)) (reverse (str %))) (iterate inc x))))\n     (nextpal [x]\n             (let [s2i #(Integer/parseInt %)\n                   s (str x)\n                   d (count s)\n                   t (apply str (take (quot (inc d) 2) s))\n                   u (str (inc (s2i t)))]\n               (if (every? #(= % \\9) s)\n                 (+ x 2)\n                 (s2i\n     \t\t \t\t (apply str (concat u\n             \t     \t      ((if (odd? d)\n                \t    \t       rest\n                    \t    \t   identity) (reverse u))))))))]\n    (iterate nextpal (startpal n))))", "problem": 150, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn pals [n]\n  (let [digits (str n)\n        even (even? (count digits))\n        mid-idx (quot (count digits) 2)\n        middle (if even \"\" (get digits mid-idx))\n        left-side (subs digits 0 mid-idx)\n        right-side (subs digits (if even mid-idx (inc mid-idx)))\n        next-pal (fn [n]\n                (let [toi (fn [st] (Long. st))\n                      x (if (<= (toi right-side) (toi (clojure.string/reverse left-side)))\n                          (str left-side middle)\n                          (str (inc (toi (str left-side middle)))))\n                      r (clojure.string/reverse (if (= middle \"\")\n                                    x\n                                    (subs x 0 (dec (count x)))))]\n                  (toi (str x r))))\n        np (if (< n 10) n (next-pal n))] \n    (cons np (lazy-seq (pals (inc np))))))", "problem": 150, "user": "5003deb9e4b0678c553fc445"}, {"code": "(letfn [(mirror [n p]\n          (let [s (str n)]\n            (read-string (str s (apply str (if p (reverse s) (rest (reverse s))))))))\n        (next-palindrome [n]\n          (let [s (str n)\n                c (count s)\n                first-half (read-string (apply str (take (/ c 2) s)))\n                second-half (apply str (drop (/ c 2) s))\n                p (= 0 (mod c 2))\n                attempt (mirror first-half p)\n                next-n (inc first-half)]\n\t\t\t(if (>= attempt n) attempt\n      \t\t\t(mirror next-n (= 0 (mod (count (str next-n second-half)) 2))))))]\n  (fn p [n] (let [np (next-palindrome n)] (cons np (lazy-seq (p (inc np)))))))", "problem": 150, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn[x]\n  (letfn \n    [(num->seq[n] (map read-string (map str (str n))))\n     (seq->num[xs] (read-string (reduce str \"\" xs)))\n     (palindrome?[n] (= (num->seq n) (reverse (num->seq n))))\n     (part-cnt[xs] (+ (quot (count xs) 2) (if (odd? (count xs)) 1 0)))\n     (find-next-palindrome[y]\n       (first (drop-while #(not (palindrome? %)) (iterate inc y))))\n     (next-palindrome[y]\n       (let [xs (num->seq y)\n             part (take (part-cnt xs) xs)\n             new-part (num->seq (inc (seq->num part)))\n             next-pal (if (= (count part) (count new-part)) \n                       (seq->num \n                        (if (even? (count xs))\n                         (concat new-part (reverse new-part))\n                         (concat (butlast new-part) [(last new-part)] (reverse (butlast new-part)))))                        \n                      (+ y 2))]\n            (lazy-seq (cons next-pal (next-palindrome next-pal)))))]\n\n    (let [pal (find-next-palindrome x)]\n      (cons pal (next-palindrome pal)))))", "problem": 150, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn [n] (letfn  [\n                (to-i [s] (apply + (map * (reverse (map #(- (int %) 48)  s)) (iterate #(* 10 %) 1))))\n                (rsplit [n s] (split-at (- (count s) n) s))\n                (make-p [[ l m]] (to-i (concat l m (reverse l))))\n                (next-palindrome [n] (let\n                                         [ s (str n)\n                                          l (count s)\n                                          h (quot l 2)\n                                          [left right] (map #(% h s) [take take-last] )\n                                          mid (if (odd? l) [ (nth s h)] [] ) \n                                          r-left (reverse left) \n                                          [li ri] (map to-i [r-left right])\n                                          ]\n                                       (make-p\n                                        (if (> ri li)\n                                          (->> (concat left mid)\n                                               (to-i)\n                                               (inc)\n                                               (str)\n                                               (rsplit (count mid)))\n                                          [left mid]))))  ]\n         (iterate (comp next-palindrome inc) (next-palindrome n))))", "problem": 150, "user": "4daea889edd6309eace4d15b"}, {"code": "#(letfn \n    [(d [n]\n        (if (< n 10)\n          [n]\n          (conj\n           (d (quot n 10))\n           (mod n 10))))\n     (r [d]\n        (if (empty? d) \n          0\n          (+ \n           (first d) \n           (* 10\n              (r (rest d))))))\n     (x [d] (r (reverse d)))\n     (p [s o] \n        (let [r (reverse s)]\n          (x \n           (concat \n            s \n            (if o (rest r) r)))))\n     (z [n]\n          (let [a (d n)\n                c (count a)\n                o (odd? c)\n                h (int (Math/ceil (/ c 2)))\n                g (take h a)\n                i (x g)\n                j (d (inc i))\n                m (p g o)]\n            (cond\n              (< n 0) 0\n              (> m n) m\n              (= (count j) h) (p j o)\n              o (p (drop-last 1 j) false)\n              :else (p j true))))]\n    (iterate z (z (dec %))))", "problem": 150, "user": "4e03c616535d04ed9115e796"}, {"code": "(letfn\n    [(int2v [n]\n       (if (< n 10) (vector n) (conj (int2v (quot n 10)) (rem n 10))))\n\n     (v2int [v]\n       (reduce #(+ (* 10 %1) %2) 0 v))\n\n\n     (palindroms [half m]\n       (let [v-half (int2v half)\n             pivot-9 (= (set v-half) #{9})]\n         (lazy-seq\n          (cons\n           (v2int (concat v-half\n                          (if (= m :odd)\n                            (drop 1 (reverse v-half))\n                            (reverse v-half))))\n           (if pivot-9\n             (if (= m :even)\n               (palindroms (inc half) :odd)\n               (palindroms (quot (inc half) 10) :even))\n             (palindroms (inc half) m))))))]\n\n\n  (fn p [n]\n    (if (< n 10)\n      (lazy-seq (concat (range n 10) (p 10)))\n      (let [v (int2v n)\n            cv (count v)\n            cv-2 (quot cv 2)\n            v-half (take cv-2 v)]\n        (if (odd? cv)\n          (if (> (first (drop (inc cv-2) v)) (last v-half))\n            (palindroms (inc (v2int (take (inc cv-2) v))) :odd)\n            (palindroms (v2int (take (inc cv-2) v)) :odd))\n          (if (> (first (drop cv-2 v)) (last v-half))\n            (palindroms (inc (v2int v-half)) :even)\n            (palindroms (v2int v-half) :even)))))))", "problem": 150, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [M]\n  (let [c (count (str M))]\n    (concat\n     (filter #(<= M %) (range 10))\n     ((fn I [l a]\n        (lazy-seq\n         (concat\n          (let [b (* 10 a)\n                r (range a b)]\n            (drop-while\n             #(< %1 M)\n             (if (even? l)\n               (map #(let [s (str %1)] (BigInteger. (apply str s (reverse s)))) r)\n               (mapcat\n                (fn [n]\n                  (let [s (str n)]\n                    (map #(BigInteger. (apply str s %1 (reverse s))) (range 10))))\n                r))))\n          (I (inc l) (bigint (Math/pow 10 (dec (quot (inc l) 2))))))))\n      c\n      (if (> c 1) (BigInteger. (apply str (take (quot c 2) (str M)))) 0)))))", "problem": 150, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [n]\n  (let [dd (count (str n))\n        pow-of-10 (iterate #(*' 10 %) 1) \n        m (read-string (apply str (take (quot (inc dd) 2) (str n))))\n        range-for-d (fn [d]\n                      (if (< d dd) \n                        [] \n                        (let [hd (quot (dec d) 2)]\n                          (range (max (nth pow-of-10 hd) m) (nth pow-of-10 (inc hd)))) ))\n        dpalindromes (fn [d]\n                       (let [r (if (even? d) reverse (comp rest reverse))\n                             rng (range-for-d d)]\n                         (map #(read-string (apply str % (r (str %)))) rng)))]\n    (filter #(>= % n) (concat (if (> n 0) [] [0]) (mapcat dpalindromes (rest (range)))))))", "problem": 150, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [n]\n    (let [i (first (drop-while\n                    #(not ( = (str %)\n                              (apply str (reverse (str %))))) (iterate inc n)))]\n      (iterate\n       (fn [x]\n         (let [s (str x)\n               l (count s)\n               first-half  (inc (int (/ x (Math/pow 10 (int (/ l 2))))))]\n           (Integer/parseInt\n            (cond (every? (partial = \\9) s) (str \"1\" (apply str (repeat (- l 1) \"0\")) \"1\")\n                  (even? (int l)) (str first-half (apply str (reverse (str first-half))))\n                  :else (str first-half (apply str (rest (reverse (str first-half)))))))))\n       i)))", "problem": 150, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(let\n  [pow #(reduce * (repeat %2 %1))\n   digits (fn digits [n]\n            (if\n              (zero? n) []\n              (conj (digits (quot n 10))\n                    (rem n 10))))\n\n   digits->number (fn [l]\n                    (apply +\n                           (for [[n i] (zipmap (range (dec (count l)) -1 -1) l)]\n                             (* i (pow 10 n)))))\n\n   numberify (fn [left middle]\n               (if middle\n                 (digits->number\n                   (concat (digits left)\n                           [middle]\n                           (reverse (digits left))))\n                 (digits->number\n                   (concat (digits left)\n                           (reverse (digits left))))))\n\n   palindromes (fn palindromes [left middle]\n                 (lazy-seq\n                   (cons (numberify left middle)\n                         (if middle\n                           (cond\n                             (and (= middle 9) (every? #(= % 9) (digits left))) (palindromes (inc left) nil)\n                             (= middle 9) (palindromes (inc left) 0)\n                             :else (palindromes left (inc middle)))\n                           (if (every? #(= % 9) (digits left))\n                             (palindromes (/ (inc left) 10) 0)\n                             (palindromes (inc left) nil))))))\n\n   f (fn f [n]\n       (if (= n 0)\n         (cons 0 (f 1))\n         (let [d (digits n)\n               c (count d)\n               left (if (even? c)\n                      (digits->number (take (/ c 2) d))\n                      (digits->number (take (/ (dec c) 2) d)))\n               middle (if (even? c)\n                        nil\n                        (nth d (dec (/ (inc c) 2))))\n               [p p2] (take 2 (palindromes left middle))]\n           (if (< p n)\n             (rest (palindromes left middle))\n             (palindromes left middle)))))]\n  f)", "problem": 150, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn f [x]\n  (letfn [(len [x] (if (< x 10) 1 (inc (len (quot x 10)))))\n          (x-prefix [x] (nth (iterate #(quot % 10) x) (quot (len x) 2)))\n          (to-form [x] [(x-prefix x) (not= (mod (len x) 2) 0)])\n          (from-form [[x odd]]\n            ((fn [x a] (if (zero? x) a\n                         (recur (quot x 10) (+ (* a 10) (mod x 10)))))\n             (if odd (quot x 10) x) x))\n          (next-p [[x odd]]\n            (cond (= (len (inc x)) (len x)) [(inc x) odd]\n                    odd [(quot (inc x) 10) false]\n                    :else [(inc x) true]))]\n    (filter #(>= % x) (map from-form (iterate next-p (to-form x))))))", "problem": 150, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn next-palindrome [n]\n  (letfn [(is-pal? [n]\n            (let [s (str n)\n                  l (count s)\n                  half (quot l 2)\n                  front-half (subs s 0 half)\n                  back-half (apply str (reverse (subs s (- l half))))]\n              (= front-half back-half)))]\n    (if (is-pal? n)\n      (cons n (lazy-seq  (next-palindrome (inc n))))\n      (let [s (str n)\n            len (count s)\n            extra (if (odd? len) 1 0)\n            front (subs s 0 (+ extra (quot len 2)))\n            front-n (Integer/parseInt front)\n            this-back (apply str (drop extra (reverse front)))\n            next-front (str (inc front-n))\n            next-back (apply str (drop extra (reverse next-front)))\n            this-pal (read-string (str front this-back))\n            pal (if (< n this-pal)\n                  this-pal\n                  (read-string (str next-front next-back)))]\n        (cons pal (lazy-seq (next-palindrome (inc pal))))))))", "problem": 150, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn fnl [x]\n  (letfn\n    [(digits [x]\n       (str x))\n     (digits-without-last [x]\n       (let [s (str x)]\n         (.substring s 0 (dec (count s))))) \n     (reverse-digits [x]\n       (str (reduce str (reverse (digits x)))))\n     (digits-count [x]\n       (count (digits x)))\n     (split1 [x]\n       (str (digits x) (reverse-digits x)))\n     (split2 [x]\n       (str (digits-without-last x) (reverse-digits x)))\n     (get-half [x]\n       (let [s (str x)]\n         (if (even? (count s))\n           (read-string (.substring s 0 (/ (count s) 2)))\n           (read-string (.substring s 0 (inc (/ (count s) 2)))))))\n     (first-number [len]\n       (reduce * (repeat (- len 1) 10)))\n     (poli? [x]\n       (= (digits x) (reverse-digits x)))\n     (next-polinfrome [x]\n       (let [c (digits-count x)\n             h (get-half x)\n             h' (if (poli? x)\n                  (inc h)\n                  h)\n             split-fn (if (even? c)\n                        split1\n                        split2)\n             next-poli (split-fn h')\n             c' (digits-count next-poli)]\n         (if (< (read-string next-poli) x)\n           (next-polinfrome (read-string (split-fn h)))\n           (if (> c' c)\n             (next-polinfrome (first-number (inc c)))\n             (read-string next-poli)))))\n     (final [x]\n       (cons x (lazy-seq (final (next-polinfrome x)))))]\n    (if (poli? x)\n      (final x)\n      (final (next-polinfrome x)))))", "problem": 150, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn pal [n]\n  (let [s (str n)\n        d (count s)\n\t\th (quot (dec d) 2)\n        left   (subs s 0 h)\n\t\tmiddle (get s h)\n\t\tright  (clojure.string/reverse left)\n\t\tguess \n\t\t  (read-string \n\t\t    (str left (if (odd? d) middle (str middle middle)) right))\n\t\tplace (fn [p] (reduce #(* % %2) 1 (repeat p 10)))\n\t\ttrunc (fn [n p] (* (quot n (place p)) (place p)))]\n\t(cond (>= guess n) (cons guess (lazy-seq (pal (inc guess))))\n\t      (= middle \\9) (pal (trunc (+ guess (place h)) h))\n\t\t  (even? d) (pal (trunc (+ guess (place h) (place (inc h))) h))\n\t\t  :else (pal (trunc (+ guess (place h)) h)) )))", "problem": 150, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn _ [x]\n    (let [\n          digits (fn [x]\n                   (loop [x x, l '()]\n                     (if (>= x 10N) (recur (bigint (/ (bigint x) 10N)) (conj l (rem x 10N))) (conj l x)))),\n          p? (fn [x] (= (digits x) (reverse (digits x)))),\n          left (fn [x] (let [s (str x), c (count s)] (subs s 0 (/ c 2)))),\n          middle (fn [x] (let [s (str x), c (count s), start (/ (dec c) 2), end (inc start)] (subs s start end))),\n          up (fn [x]\n               (let [s (str x), c (count s), i (bigint (Math/pow 10N (+ (bigint (/ c 2N)) 1N)))]\n                 (bigint (* (+ (bigint (/ x i)) 1N) i)))),\n          np (fn np [x]\n               (let [s (str x), \n                     c (count s), \n                     l (left x), \n                     m (middle x),\n                     r (apply str (reverse l)),\n                     i1 (bigint (Math/pow 10N (bigint (/ c 2N)))),\n                     i2 (bigint (* 1.1 i1))]\n                 ;(println \"x=\"s \"c=\"c \"l=\"l \"m=\"m \"r=\"r)\n                 (cond (odd? c)\n                       (let [nn (bigint (str l m r))]\n                         ;(println \"o nn=\"nn \"i1=\"i1)\n                         (if (> nn x) nn\n                           (if (not (= \"9\" m)) (+ nn i1)\n                             (np (up x)))))\n                       :else\n                       (let [nn (bigint (str l r))]\n                         ;(println \"e nn=\"nn \"i2=\"i2)\n                         (if (> nn x) nn\n                           (if (not (= \"9\" m)) (+ nn i2)\n                             (np (up x))))))))]\n      (cond\n        (= 0 x) (cons 0 (iterate np (np x)))\n        (p? x) (cons x (iterate np (np x)))\n        :else (iterate np (np x)))))", "problem": 150, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [n]\n  (let [a (read-string (subs (str n) 0 (-> n str count inc (/ 2) int)))\n        f (fn [g y]\n            (apply str (concat (str y) (g (reverse (str y))))))\n        h (fn h [x odd]\n            (let [y (inc x)]\n            (cons (read-string (f (if odd next identity) x))\n                  (lazy-seq (if (< (count (str x)) (count (str y)))\n                              (h (if odd (/ y 10) y) (not odd))\n                              (h y odd))))))]\n    (drop-while #(> n %) (h a true))))", "problem": 150, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [n]\n  (let [exp (fn ! [n]\n              (let [d (quot n 10)\n                    r (mod n 10)]\n                (if (> d 0) (conj (! d) r) [r])))\n        imp (fn [xs] (reduce #(+ (* %1 10) %2) 0 xs))\n        incp (fn [xs] (exp (inc (imp xs))))\n        pal? (fn [xs] (= xs (reverse xs)))\n        first-pal (fn [n] (first (filter pal? (map exp (iterate inc n)))))\n        next-pal (fn [xs]\n                   (let [l (count xs)\n                         o (mod l 2)\n                         h (take (/ l 2) xs)\n                         n (incp h)\n                         o (if (= (count n) (count h)) o (inc o))]\n                     (concat (drop-last (quot o 2) n) (drop (/ o 2) (reverse n)))))]\n    (map imp (iterate next-pal (first-pal n)))))", "problem": 150, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "; Yes I know this is disgusting  \n  (fn [x]\n    (let [pal\n          (fn [n f]\n            (if (not= (count (str n)) (count (str (+ 1 n))))\n              (f (f n))\n              (let [h (f (read-string (subs (str n) 0 (-  (count (str n)) (quot (count (str n)) 2)))))]\n                (read-string (str (str h)\n                                  (if (odd? (count (str n)))\n                                    (apply str (rest (reverse (str h))))\n                                    (apply str (reverse (str h)))))))))]\n      ((fn f [n]\n         (lazy-seq (cons n \n                         (f (pal n inc)))))\n       (if (< (pal x (fn [i] i)) x) (pal x inc) (pal x (fn [i] i))))))", "problem": 150, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn seqpal [i]\n  (let [nextpal (fn nextpal [i]\n                  (let [n (count (str i))\n                        q (quot n 2)\n                        s (str i)\n                        p (take q s)\n                        rp (reverse p)\n                        t (even? n)\n                        m (if t nil (drop q (take (inc q) s)))]\n                    (if (every? #(= % \\9) s)\n                      (+ 2 i)\n                      (let [pf (seq (str (inc (read-string (apply str (concat p m))))))\n                            rpf (if t (reverse pf) (reverse (butlast pf)))]\n                        (read-string (apply str (concat pf rpf)))))))\n        ispal (fn ispal [i]\n                (let [r (reverse (str i))\n                      rr (reverse r)]\n                  (= r rr)))\n        symet (fn symet [i]\n                (let [n (count (str i))\n                      q (quot n 2)\n                      s (str i)\n                      p (take q s)\n                      rp (reverse p)\n                      m (if (even? n) nil (drop q (take (inc q) s)))]\n                  (read-string (apply str (concat p m rp)))))]\n    (if (ispal i)\n      (cons i (lazy-seq (seqpal (nextpal i))))\n      (if (> (symet i) i)\n        (cons (symet i) (lazy-seq (seqpal (nextpal (symet i)))))\n        (cons (nextpal (symet i)) (lazy-seq (seqpal (nextpal (nextpal(symet i))))))))))", "problem": 150, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn next-pal [x]\n  (let [num-digits-fn (fn [x] (count (str x)))\n        front-half-len-fn (fn [x] (- (num-digits-fn x)\n                                     (int (/ (num-digits-fn x) 2))))\n        front-half-fn (fn [x] (BigInteger. (subs (str x) 0 (front-half-len-fn x))))\n        front-half-mirror-fn (fn [x] (BigInteger. (apply str (front-half-fn x) (reverse (if (even? (num-digits-fn x)) (str (front-half-fn x)) (butlast (str (front-half-fn x))))))))\n        front-half-inc-mirror-fn (fn [x] (BigInteger. (apply str (inc (front-half-fn x)) (reverse (if (even? (num-digits-fn x)) (str (inc (front-half-fn x))) (butlast (str (inc (front-half-fn x)))))))))\n        next-num-fn (fn [x]\n                      (if (and (apply = (str x)) (= \\9 (first (str x))))\n                        (+ 2 x)\n                        (front-half-inc-mirror-fn x)))\n        \n        first-num-fn (fn [x]\n                       (if (<= x (front-half-mirror-fn x))\n                         (front-half-mirror-fn x)\n                         (front-half-inc-mirror-fn x)))\n        ]\n    \n    (iterate next-num-fn (first-num-fn x))\n     \n    )\n  )", "problem": 150, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn [n]\n  (let [f (fn [n]\n            (if (< n 0)\n              0\n              (let [list-to-number (fn [s] (->> s (apply str) read-string))\n                    number-to-list (fn [n] (-> n str seq))\n                    s (number-to-list n)\n                    c (count s)\n                    l (quot c 2)\n                    first-half (drop-last l s)\n                    second-half (reverse (take l first-half))]\n                (let [p (list-to-number (concat first-half second-half))]\n                  (if (< n p)\n                    p\n                    (let [\n                          f (->> first-half list-to-number inc number-to-list)\n                          digits-increased? (< (count first-half) (count f))\n                          first-half-increased (if (and digits-increased? (odd? c)) \n                                                 (drop-last f)\n                                                 f)\n                          second-half-increased (if digits-increased?\n                                                  (if (odd? c)\n                                                    (reverse first-half-increased)\n                                                    (-> first-half-increased reverse rest))\n                                                  (reverse (take l first-half-increased))\n                                                  )\n                          ]\n                      (list-to-number (concat first-half-increased second-half-increased)))))\n                )))]\n    (rest (iterate f (dec n)))))", "problem": 150, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn pal [x]\n  (lazy-seq\n   (letfn [(decode [coll] (reduce #(+ (* 10 %1) %2) (first coll) (rest coll)))\n           (encode [x] (if (< x 10) [x] (conj (encode (quot x 10)) (rem x 10))))]\n     (let [e (encode x)\n           c (count e)\n           additional (if (odd? c) 1 0)\n           h (quot c 2)\n           encoded-seed (subvec e 0 (+ h additional))\n           reversed (reverse encoded-seed)\n           seed (decode encoded-seed)\n           encoded-pal (concat encoded-seed (drop additional reversed))\n           decoded-pal (decode encoded-pal)\n           next-seed (inc seed)\n           next-x (decode (concat (encode next-seed) (take h (repeat 0))))]\n     (if (>= decoded-pal x)\n       (cons decoded-pal (pal next-x))\n       (pal next-x))))))", "problem": 150, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [x]\n  (letfn [(next [x]\n            (let [mirror     (fn [s p](concat s (if p (rest (reverse s)) (reverse s))))\n                  to-num     #(Long. (apply str %))\n                  mirror-num (comp to-num mirror)\n                  s      (str x)\n                  n      (count s)\n                  half   (quot (inc n) 2) ;including middle when odd\n                  s'     (take half s)\n                  h      (str (inc (to-num s')))\n                  x'     (mirror-num s' (odd? n))]\n              (cond (> x' x) x'\n                    (even? n)          (mirror-num h (> (count h) half))\n                    (= (count h) half) (mirror-num h true)\n                    :else              (mirror-num (butlast h) nil))))]\n    (if (zero? x)\n      (iterate next 0)\n      (rest (iterate next (dec x))))))", "problem": 150, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn __ [n]\n  \n(filter #(= (str %) (apply str (reverse (str %))))\n  (iterate \n   \n(fn goo [n]\n  (cond (< n 10) (inc n)\n        (every? #(= \\9 %) (str n)) (+ 2 n)\n        :else\n  (let \n    [s (str n)\n     len (count s)\n     first-half (apply str (take (int (/ len 2)) s))\n     next-first (str (inc (Integer. first-half)))\n     second-half (apply str (take-last (int (/ len 2)) s))\n     mid (str (nth s (int (/ len 2))))\n     next-mid (str (inc (Integer. mid)))\n     rev #(apply str (reverse %))]\n    (if (even? len)\n     (if (< (Integer. second-half) (Integer. (rev first-half)))\n        (Integer. (str first-half (rev first-half)))\n        (Integer. (str next-first (rev next-first))))\n      (if (< (Integer. second-half) (Integer. (rev first-half)))\n        (Integer. (str first-half mid (rev first-half)))\n        (if (= \"10\" next-mid)\n          (Integer. (str next-first \"0\" (rev next-first)))\n          (Integer. (str first-half next-mid (rev first-half)))))))))\nn)))", "problem": 150, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn palindromes [x] \n  (let [rev clojure.string/reverse\n        first-one (fn [x] \n                    (let [s (str x)\n                          l (count s)\n                          o? (odd? l)\n                          h  (quot l 2)\n                          sh (+ h (if o? 1 0))\n                          fh (subs s 0 h)\n                          comparison (compare fh (rev (subs s sh l)))]\n                      (cond \n                        (zero? comparison) x\n                        (pos?  comparison) (Long. (str fh (subs s h sh) (rev fh)))\n                        :else (if o?\n                                (let [fh (str (inc (Long. (str fh (subs s h sh)))))\n                                      sh (rev (subs fh 0 h))]\n                                  (Long. (str fh sh)))\n                                (let [fh (str (inc (Long. fh)))]\n                                  (Long. (str fh (rev fh))))))))\n        next-one (fn [x] \n                   (let [s (str x)\n                         l (count s)\n                         h (quot l 2)\n                         fh (subs s 0 h)]\n                     (if (every? #(= \\9 %) s)\n                       (+ 2 x)\n                       (if (odd? l)\n                         (let [fh (str (inc (Long. (str fh (subs s h (inc h))))))\n                               l (rev (subs fh 0 h))]\n                           (Long. (str fh l)))\n                         (let [fh (str (inc (Long. fh)))]\n                           (Long. (str fh (rev fh))))))))]\n    (iterate next-one (first-one x))))", "problem": 150, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn get-palins [n]\n  (concat\n   (if (and (>= n 9) (= (str n) (clojure.string/reverse (str n))))\n       (list n)\n       '())\n   (if (<= n 9)\n       (drop n (range 10))\n       '())\n       (let [n (if (<= n 9) 10 n)]\n    (rest \n     (map #(read-string (apply str %))\n           (iterate (fn [x]\n             (let [x (apply vector (map (comp read-string str) (str (inc (read-string (apply str x))))))\n                   xlength (count x)\n                   xlength2 (int (/ xlength 2))\n                   odd (odd? xlength)\n                   left (take xlength2 x)\n                   middle (first (drop xlength2 x))\n                   right (if (odd? xlength) (rest (drop xlength2 x)) (drop xlength2 x))]\n                (vec (if (some true? (map #(< %1 %2) left (reverse right) ))\n                       (let [addone (fn [coll] (let [part (partition-by #(= 9 %) coll)]\n                                       (if (= 9 (first (first part)))\n                                           (concat (map (fn [t] 0) (first part)) (if (= 1 (count part)) '() (list (inc (first (second part))))) (rest (apply concat (rest part))) )\n                                           (concat (list (inc (first (first part)))) (rest coll) ))))\n                             leftoneadded (reverse (addone (reverse left)))]\n                         (if odd \n                           (if (= middle 9) \n                             (concat leftoneadded (list 0) (reverse leftoneadded)) \n                             (concat left (list (inc middle)) (reverse left))) \n                           (concat leftoneadded (reverse leftoneadded))))\n                      (if odd \n                        (concat left (list middle) (reverse left)) \n                        (concat left (reverse left)))))))\n                    (apply vector (map (comp read-string str) (str n))) ))))))", "problem": 150, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn palindromes [n]\n  (let [getnext (fn [x]\n                  (let [s (str x)\n                        l (count s)\n                        s0 (apply str (take (/ l 2) s))\n                        s1 (str (inc (read-string s0)))\n                        po (read-string (apply str (concat s0 (rest (reverse s0)))))\n                        pe (read-string (apply str (concat s0 (reverse s0))))\n                        qo (read-string (apply str (concat s1 (rest (reverse s1)))))\n                        qe (read-string (apply str (concat s1 (reverse s1))))\n                        ] \n                    (apply min (filter #(>= % n) (list po pe qo qe)))))\n        n2 (getnext n)]\n    (lazy-cat (list n2) (palindromes (inc n2)))))", "problem": 150, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn palindromic-numbers [n]\n  (letfn [(new-p [c newn]\n            (if (odd? c)\n              (read-string (str newn (clojure.string/reverse (subs newn 0 (dec (count newn))))))\n              (read-string (str newn (clojure.string/reverse newn)))))\n          (next-p [n]\n            (let [s (str n)\n                  c (count s)\n                  half-p (subs s 0 (quot (inc c) 2))\n                  can1 (new-p c half-p)\n                  can2 (new-p c (str (inc (read-string half-p))))]\n              (if (every? #(= \\9 %) s)\n                (+ n 2)\n                (if (> can1 n) can1 can2))))]\n    (drop-while #(not= (str %) (clojure.string/reverse (str %))) (iterate next-p n))))", "problem": 150, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn p [n]\n  (letfn [(to-list [n] (if (< n 10) [n] (conj (to-list (quot n 10)) (rem n 10))))\n          (to-num [xs] (reduce #(+ (* % 10) %2) 0 xs))\n          (segment [xs] (list (take (quot (count xs) 2) xs) (drop (quot (inc (count xs)) 2) xs)))          \n          (next-p [n] (let [n-list (to-list n)\n                            [first-h second-h] (segment n-list)\n                            len (count n-list)\n                            pivot (nth n-list (quot len 2))\n                            first-h-r (reverse first-h)\n                            first-h+1 (to-list (inc (to-num first-h)))]\n                        (cond\n                         (every? #(= % 9) n-list) (+ 2 n)\n                         (< n 10) (inc n)\n                         (> (to-num first-h-r) (to-num second-h)) (to-num (concat first-h \n                                                                                  (if (odd? len) \n                                                                                    (list pivot)) \n                                                                                  first-h-r))\n                         (and (even? len)) (to-num (concat first-h+1 (reverse first-h+1)))\n                         (< pivot 9) (to-num (concat first-h (if (odd? len) (list (inc pivot))) first-h-r))\n                         :else (to-num (concat first-h+1 '(0) (reverse first-h+1)))\n                         )))]\n    (iterate next-p (if (= (to-list n) (reverse (to-list n))) n (next-p n)))))", "problem": 150, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn palindromics [n]\n  (let [parseInt        (fn [s]\n                          (reduce #(+ %2 (* 10 %1)) (map #(read-string (str %)) s)))\n        next-palindrome (fn [n]\n                          (let [digits        (str n)\n                                length        (count digits)\n                                first-half    (subs digits 0 (quot (inc length) 2))\n                                second-half   (subs digits  (quot length 2))\n                                first-half    (if (and (<= (parseInt (clojure.string/reverse first-half))\n                                                           (parseInt second-half)))\n                                                (str (inc (parseInt first-half)))\n                                                first-half)\n                                second-half   (subs (clojure.string/reverse first-half) (if (odd? length) 1 0))\n                                full          (str first-half second-half)]\n                            (cond (every? #(= \\9 %) digits) (+ 2 n)\n                                  :else (read-string full))))\n        palindromic?    (fn [n]\n                          (= (apply str (reverse (str n)))\n                             (str n)))\n        ]\n    (iterate next-palindrome (if (palindromic? n) n (next-palindrome n)))))", "problem": 150, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn palindromic-numbers [n]\n  (letfn [(num-to-digit-seq [k] (->> (iterate #(quot % 10) k) (take-while pos?) (map #(mod % 10))))\n          (digit-seq-to-num [ds] (if (empty? ds) 0 (+ (first ds) (* 10 (digit-seq-to-num (next ds))))))\n          (pow10 ([n] (pow10 n 1)) ([n acc] (if (zero? n) acc (recur (dec n) (* 10 acc)))))\n          (shift ([k m] (* k (pow10 m))) ([m] (shift 1 m)))\n          (split-seq [s] (let [k (count s) h (quot k 2)] (if (even? k) [(take h s) (drop h s)] \n                                                             [(take h s) (drop (inc h) s) (nth s h)])))\n          (palindromic? [s] (= s (reverse s)))\n          (next-palindromic-number [k]\n            (let [digit-seq (num-to-digit-seq k) \n                  digit-count (count digit-seq)\n                  half (quot digit-count 2)\n                  [first-half second-half middle] (split-seq digit-seq) \n                  first-value (digit-seq-to-num first-half)\n                  second-value (digit-seq-to-num second-half) \n                  rev-second-value (digit-seq-to-num (reverse second-half))\n                  inc-rev-second-value (-> (inc second-value) num-to-digit-seq reverse digit-seq-to-num)]\n              (letfn [(next-even [] (if (> first-value rev-second-value)\n                                      (+ (shift (inc second-value) half) inc-rev-second-value)\n                                      (+ (shift second-value half) rev-second-value)))\n                      (next-odd [] (if (> first-value rev-second-value) \n                                     (if (= middle 9) (+ (shift (inc second-value) (inc half)) inc-rev-second-value)\n                                         (+ (shift second-value (inc half)) (shift (inc middle) half) \n                                            rev-second-value  ))\n                                     (+ (shift second-value (inc half)) (shift middle half) rev-second-value)))]\n                      (cond (palindromic? digit-seq) k \n                        (every? #(= % 9) digit-seq) (+ k 2)\n                        (even? digit-count) (next-even)\n                        (odd? digit-count) (next-odd)))))]\n    (let [p (next-palindromic-number n)] (lazy-seq (cons p (palindromic-numbers (inc p)))))))", "problem": 150, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn solve [num]\n    (let [numdigits (fn [num]\n                      (loop [num num acc 0]\n                        (if (zero? (quot num 10))\n                          (inc acc)\n                          (recur (quot num 10) (inc acc)))))\n\n          removehalfnum (fn [num]\n                          (let [digits (numdigits num)\n                                numstoremove (quot digits 2)]\n                            (nth (iterate #(quot % 10) num) numstoremove)))\n\n          addbacknum (fn [num skip]\n                       (loop [num num acc (if skip (quot num 10) num)]\n                         (if (zero? num)\n                           acc\n                           (recur (quot num 10) (+ (* acc 10) (rem num 10))))))\n          firstproc #(addbacknum (removehalfnum %) (odd? (numdigits %)))\n          restproc #(addbacknum (inc (removehalfnum %)) (odd? (numdigits %)))]\n      (lazy-seq (cond (< (firstproc num) num)\n                      (solve (restproc num))\n                      (and (= (firstproc num) num) (= (rem num 9) 0)) (cons num (solve (inc num)))\n                      (= (firstproc num) num) (cons num (solve (restproc num))) \n                      :else\n                      (cons (firstproc num) (solve (restproc num)))))))", "problem": 150, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn palindromic-numbers [^long n]\n  (letfn\n      [(rev-digits [n]\n         (when-not (zero? n)\n           (cons (mod n 10) (rev-digits (quot n 10)))))\n       (digits [n] (reverse (rev-digits n)))\n       (exp10 [n] (reduce * (repeat n 10)))\n       (digits->num [s]\n         (reduce + (map #(* %1 (exp10 %2)) s (range (dec (count s)) -1 -1))))\n\n       (palindromic-num? [n]\n         (= (str n) (->> n str reverse (apply str))))\n\n       (next-palindromic-num [n]\n         (if (< n 99)\n           (first (drop-while #(<= % n) (concat (range 0 10) (range 11 100 11))))\n           \n           (let [d-seq (digits n)\n                 len    (count d-seq)\n                 left  (digits->num (take (quot len 2) d-seq))\n                 rev-left (digits->num (rev-digits left))\n                 right (digits->num (drop (- len (quot len 2)) d-seq))\n                 center (if (odd? len) (nth d-seq (quot len 2)))]\n             (if (every? #{9} d-seq) ; carry\n               (+ n 2)\n               (if (<= rev-left right)\n                 (if center ; odd or even\n                   (if (< (inc center) 10)\n                     (digits->num (concat (digits left) [(inc center)] (rev-digits left)))\n                     (digits->num (concat (digits (inc left)) [0] (rev-digits (inc left)))))\n                   (digits->num (concat (digits (inc left)) (rev-digits (inc left)))))\n                 (if center\n                   (digits->num (concat (digits left) [center] (rev-digits left)))\n                   (digits->num (concat (digits left) (rev-digits left)))))))))]\n    (if (palindromic-num? n)\n      (iterate next-palindromic-num n)\n      (iterate next-palindromic-num (next-palindromic-num n)))))", "problem": 150, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn f [x]                                                                                              \n  (let [next-palindrome (fn [n]                                                                                    \n  (let [s (str n)                                                                                                  \n        to-num (fn [s]                                                                                             \n                 (let [clean-s (clojure.string/replace s #\"^0+\" \"\")]                                               \n                   (if (empty? clean-s) 0 (read-string clean-s))))                                                 \n        l (count s)                                                                                                \n        l-odd? (= (rem l 2) 1)                                                                                     \n        m (/ l 2)                                                                                                  \n        lh (subs s 0 m)                                                                                            \n        md (if l-odd? (subs s m (inc m)) \"\")                                                                       \n        rh (if l-odd? (subs s (inc m)) (subs s m))                                                                 \n        lh-reversed (apply str (reverse lh))                                                                       \n        rh-reversed (apply str (reverse rh))]                                                                      \n    (cond                                                                                                          \n      (= lh rh-reversed) n                                                                                         \n      (> (to-num lh-reversed) (to-num rh))                                                                         \n        (to-num (str lh md (apply str (reverse lh))))                                                              \n      :else (let [lh-md (str lh md)                                                                                \n                  lh-md-num (to-num lh-md)                                                                         \n                  lh-md-inc (str (inc lh-md-num))                                                                  \n                  lh-md-inc-len (dec (count lh-md-inc))                                                            \n                  new-rh (apply str (reverse (if l-odd? (subs lh-md-inc 0 lh-md-inc-len) lh-md-inc)))              \n                  pal (str lh-md-inc new-rh)]                                                                      \n              (to-num pal)))))                                                                                     \n    pal (next-palindrome x)]                                                                                       \n    (cons pal (lazy-seq (f (inc pal))))))", "problem": 150, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [n]\n  (let [b (count (str n))\n        r (mod b 2)\n        g (subs (str n) 0 (quot (+ 1 b) 2))\n        k (Long/parseLong g)\n        j (if (> 1 (compare\n                    (subs (str n) (quot b 2) b)\n                    (apply str (reverse g))))\n            k (+ 1 k))\n        l (.pow 10M (quot b 2))\n        p #(Long/parseLong (str % (apply str (drop %2 (reverse (str %))))))\n        o (fn [i d] (map p (range i 9e40) (cycle [d])))\n        m (fn m [[x & xt :as xs] [y & yt :as ys]]\n            (lazy-seq (if (< x y) (cons x (m xt ys)) (cons y (m xs yt)))))]\n    (lazy-cat [(p j r)] (m (rest (o j r)) (o l ({0 1} r 0))))))", "problem": 150, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn fff [x]\n  (let [pn? (fn [x] (let [sx (str x)] (= (seq sx) (reverse sx))))\n        mirror (fn [x] \n                 (let [sx (str x) l (quot (count sx) 2) \n                       lh (apply str (take l sx))\n                       rh (apply str (drop l (reverse sx)))]\n                   (read-string (str lh rh))))\n        np (fn [p]\n             (if (< p 9)\n               (inc p)\n\t             (let [sp (str p) l (count sp) cl (- (inc l) 2)]\n\t               (if (every? #(= \\9 %) sp)\n\t                 (read-string (apply str (cons \\1 (conj (vec (repeat cl \\0)) \\1))))\n\t                 (let [len (+ (quot l 2) (rem l 2))\n                         n (read-string (apply str (take len sp)))\n\t                       lh (str (inc n)) \n                         rh (apply str (reverse (take (quot l 2) lh)))]\n\t                     (read-string (str lh rh)))))))]\n    (if (pn? x)\n      (cons x (lazy-seq (fff (np x))))\n      (let [m (mirror x)]\n        (if (>= m x)\n          (cons m (lazy-seq (fff (np m))))\n          (lazy-seq (fff (np m))))))))", "problem": 150, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [n]\n    (letfn [(gary   [n]  (cons n (lazy-seq (gary (*' 10 n)))))\n            (heidi  [n]  (take-while pos? (map (partial quot n) (gary 1))))\n            (dave   [n]  (reverse (map #(mod % 10) (heidi n))))\n            (pal    [n]  (let [ds (dave n)] (= ds (reverse ds))))\n            (oscar  [n]  (odd? (count (dave n))))\n            (parts  [n]  (let [ds (dave n), k (count ds), h (quot k 2),\n                               j (if (odd? k) (inc h) h)]\n                           [(take h ds), (drop h (take j ds)), (drop j ds)]))\n            (ralf   [n]  (let [dp (parts n)] (concat (first dp) (nth dp 1))))\n            (reggie [n]  (let [dp (parts n)] (< (fran (reverse (nth dp 2))) (fran (first dp)))))\n            (fran   [ds] (apply +' (map *' (reverse ds) (gary 1))))\n            (don    [n]  (dave (inc (fran (ralf n)))))\n            (kathy  [n]  (count (don n)))\n            (linda  [n]  (if (reggie n)\n                           (let [dp (parts n)] (fran (concat (first dp) (nth dp 1) (reverse (first dp)))))\n                           (let [odd (oscar n), bump (> (kathy n) (count (ralf n)))]\n                             (fran (let [d (don n), r (reverse d)]\n                                     (if bump\n                                       (concat (if odd (butlast d) d) (rest r))\n                                       (concat d (if odd (rest r) r))))))))]\n      (let [russ (iterate linda n)]\n        (if (pal n) russ (rest russ)))))", "problem": 150, "user": "515cf9b5e4b00901442db1d4"}, {"code": "(fn p [i] (let [s (str i)\n\t\t\t  m (/ (count s) 2)\n\t\t\t  r (apply str(take m s))\n\t\t\t  chg (every? #{\\9} s)\n\t\t\t  r2 (if (= (seq s) (reverse s))\n\t\t\t\t\t\t(if (and chg (odd? (count s))) (apply str (butlast (str (inc (bigint r))))) (str (inc (bigint r))))\t\t\t  \n\t\t\t\t\t\tr)\n\t\t\t  ev (if chg (even? (count s)) (odd? (count s)))\n\t\t\t  res (if ev\n\t\t\t\t\t(bigint (str r2 (apply str (reverse (butlast r2)))))\n\t\t\t\t\t(bigint (str r2 (apply str (reverse r2)))))]\n\t\t\t(if (= (seq s) (reverse s))\n\t\t\t\t(cons i (lazy-seq (p res)))\n\t\t\t\t(if (<= res i) (drop 1 (p res)) (p res)))))", "problem": 150, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [num]\n  (letfn [(reverse-digit [num result]\n            (if\n              (zero? (quot num 10))\n              (+ (mod num 10) (* result 10))\n              (reverse-digit (quot num 10) (+ (mod num 10) (* result 10)))))\n          (palindromic-in-i-digit [low up]\n            (lazy-cat\n              (lazy-cat\n                (map #(if (< % 10) % (reverse-digit (quot % 10) %)) (range low up))\n                (drop-while\n                  zero?\n                  (map #(reverse-digit % %) (range low up))))\n              (palindromic-in-i-digit up (* up 10))))]\n    (filter #(>= % num) (let [len (count (.toString num))\n                              digit (quot len 2)\n                              low (quot num (apply * (repeat digit 10N)))\n                              up (apply * (repeat (count (.toString low)) 10N))]\n                          (palindromic-in-i-digit low up)))))", "problem": 150, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn pn [n]\n  (for [i (iterate\n            #(+ % (cond\n                    (not= (str %) (clojure.string/reverse (str %)))\n                    1\n\n                    (= \\9 (first (fnext (split-at (quot (count (str %)) 2) (str %)))))\n                    2\n\n                    :else\n                    (apply * (repeat (quot (count (str %)) 2) 10))))\n            n)\n        :when (= (str i) (clojure.string/reverse (str i)))]\n    i))", "problem": 150, "user": "51057b2be4b06d28cacc92e8"}, {"code": "(fn rep ( [n] (rep n n))\n         ([n low]\n            (let [splt\n                  (fn [n]\n                    (let [ns (str n)\n                          mg (count ns)\n                          spl (+ (quot mg 2) (rem mg 2))\n                          mv  (nth (iterate (partial * 10) 1) (quot mg 2))]\n                      (vector mv\n                              (read-string\n                               (apply str  (concat\n                                            (take spl ns)\n                                            (reverse (take (quot mg 2) ns ))))))))\n                  [mv np] (splt n)\n                  ]\n\n              (if (>= np low) (cons np (lazy-seq (rep (+ n mv) low)))\n                  (lazy-seq (rep (+ np mv) low))))))", "problem": 150, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn [startnumber]\n  (letfn [(pal [start step]\n                (if (= (+' 1 start) (bigint (Math/pow 10 (count (str start)))))\n                  (if (= 1 step) (+' start 2) start)\n\t\t\t\t\t\t\t\t  (let [n (quot (count (str start)) 2 )\n\t\t\t\t\t\t\t\t        pre (+' step (quot start (int (Math/pow 10 n))))]\n\t\t\t\t\t\t\t\t    (Long/parseLong (clojure.string/join (concat (str pre) (take-last n (reverse (str pre))))))\n\t\t\t\t\t\t\t\t    )\n\t\t\t\t\t\t\t\t  )\n                )]\n     \n    (let [near (pal startnumber 0)\n          fi (if (< near startnumber) (pal startnumber 1) near)]\n      \n      ((fn re [f]\n         (cons f (lazy-seq (re (pal f 1))))\n         )\n       fi)\n    )\n    )\n  )", "problem": 150, "user": "51bec919e4b013aa0d74b800"}, {"code": "(let [f (fn [n]\n          (let [s (str n) l (count s)\n                a (subs s 0 (Math/ceil (/ l 2)))\n                b (str (inc (read-string a)))]\n            ; Not my solution copied from immo http://pastebin.com/VsGuzYig\n            (first\n              (filter #(>= % n)\n                (map\n                  #(read-string\n                     (str\n                       %\n                       (subs (clojure.string/reverse %) (if (odd? l) 1 0))))\n                  [a b])))))]\n  #(iterate (comp f inc) (f %)))", "problem": 150, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [n]\n  (let [to-d (fn [n] (map #(- (int %) 48) (str n)))\n        to-n (fn [d] (reduce #(+ (* 10 %) %2) 0 d))\n        half (fn [d] (take (/ (count d) 2) d))\n        reflect (fn [h d] (concat h (reverse (if (even? (count d)) h (butlast h)))))\n        next-p (fn [f n]\n                 (let [d (to-d n)\n                       h (-> d half to-n f to-d)]\n                   (if (and (apply = 9 d) (= f inc))\n                     (+ n 2) ; bug here for down-p?\n                     (to-n (reflect h d)))))\n        up-p (partial next-p inc)\n        down-p (partial next-p dec)\n        first-p (fn [n] (if (zero? n) 0\n                          (first (drop-while #(< % n) (iterate up-p (down-p n))))))]\n    (iterate up-p (first-p n))))", "problem": 150, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn pali-seq [n]\n  (letfn [(is-pali [x]\n            (let [xstr (str x)]\n              (= xstr (clojure.string/reverse xstr))))\n          (next-pali [x]\n            (if (is-pali x)\n              x\n              (next-pali (inc x))))\n          (inc-pali [x]\n            (let [xstr (str x)\n                  len (count xstr)]\n              (cond\n               (every? #{\\9} xstr) (next-pali (inc x))\n               (even? len) (let [head (subs xstr 0 (/ len 2))\n                                 head-inc (str (inc (bigint head)))]\n                             (bigint (apply str (concat head-inc\n                                                        (reverse head-inc)))))\n               (odd? len)  (let [head (subs xstr 0 (inc (/ len 2)))\n                                 head-inc (str (inc (bigint head)))]\n                             (bigint (apply str (concat head-inc\n                                                        (reverse (drop-last head-inc)))))))))]\n    (lazy-seq\n     (iterate inc-pali (next-pali n)))))", "problem": 150, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [n](letfn [\r\n(ws [x] (count (str x)))\r\n(hb [x] (apply * \r\n(repeat (if (odd? (ws x))\r\n(/ (- (ws x) 1) 2) \r\n(/ (ws x) 2))10)) )\r\n(fj [x] (every? #(= \\9 %) (str x))) \r\n(fh [x] (int (/ x (hb x) )))\r\n(od [x] (+ (* (fh x) (hb x)) \r\n(Integer/parseInt \r\n(apply str \r\n(rest (reverse (str (fh x))))))))\r\n(ev [x] (+ (* (fh x) (hb x)) \r\n(Integer/parseInt \r\n(apply str \r\n(reverse (str (fh x))))))) \r\n(fp [x] (cond\r\n      (= 1 (ws x)) x   \r\n         (odd? (ws x))\r\n(od x) \r\n         :else (ev x)))\r\n(it [x] (cond \r\n         (fj x) (+ 2 x)\r\n         (= 1 (ws x)) (+ 1 x)\r\n(odd? (ws x))\r\n (od (* (+ 1 (fh x)) (hb x)))\r\n (even? (ws x))\r\n  (ev (* (+ 1 (fh x)) (hb x)) )\r\n))\r\n(l [x] (iterate it (fp x)))]\r\n(if (>= (first (l n)) n)\r\n(l n) (rest (l n)))\r\n))", "problem": 150, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [n]\n  (let [d #(loop [n % r '()] (cond (< 0 n) (recur (quot n 10) (conj r (rem n 10))) (= '() r) '(0) 1 r))\n        b #(loop [v 0 d %] (if (seq d) (recur (+ (* v 10) (first d)) (rest d)) v))\n        all-9? (fn [n] (every? #{9} (d n)))\n        p? #(let [x (d %)] (= x (reverse x)))\n        half-to-flip #(let [digits (d %)]\n                        (take\n                         (int (Math/ceil (/ (count digits) 2))) digits))\n        flip-it (fn [digits double-middle?]\n                  (if double-middle?\n                    (concat digits (-> digits reverse))\n                    (concat (butlast digits)\n                            [(last digits)]\n                            (-> digits butlast reverse))))\n        change? (fn [n] (let [flip? (-> n d count odd?)\n                              flip? (if (all-9? n) (not flip?) flip?)\n                              ]\n                          flip?))\n\n        next-pal (fn [n]\n                   (if (all-9? n) (+ 2 n)\n                       (let [g (d n)\n                             c (count g)\n                             t (-> c (/ 2) Math/ceil int)\n                             \n                             o (if (p? n) inc identity)]\n                         (b\n                          (flip-it (->> g\n                                        (take t)\n                                        b\n                                        o\n                                        d\n                                        (take t)\n                                        )\n                                   (even? c)))\n                         )))]\n    (drop-while #(> n %)\n     (filter p? (iterate next-pal n)))))", "problem": 150, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [n]\n  (letfn [(coll2int [coll]\n                    (read-string (apply str coll)))\n          (palindrome [v] ; input must be a palindrome, find the next palindrome\n                       (let [z (str v) \n                             c (count z)\n                             nv (coll2int (take (/ (if (odd? c) (inc c) c) 2) z))\n                             d (str (inc nv))]\n                         (if (= (count (str nv)) (count d))\n                           (coll2int (concat d \n                                             (reverse (if (odd? c) (drop-last d) d))))\n                           (coll2int (concat (if (odd? c) (drop-last d) d)\n                                             (reverse (drop-last d)))))))\n          (make-palindrome [v] ; change a number to a palindrome\n                            (let [z (str v)\n                                  c (count z)\n                                  pre (take (/ (if (odd? c) (inc c) c) 2) z)]\n                              (coll2int (concat pre \n                                                (reverse \n                                                 (if (odd? c) (drop-last pre) pre))))))]\n    (let [v (iterate palindrome (make-palindrome n))]\n      (if (<= n (first v)) v (rest v)))))", "problem": 150, "user": "51780f88e4b03d69594194c9"}, {"code": "(letfn [(palindrome? [n]\n          (apply = ((juxt seq reverse) (str n))))\n        (xor [a b]\n          (or (and a (not b))\n              (and (not a) b)))\n        (make-palindrome [n inc?]\n          (let [nn (count (str n))\n                o (odd? nn)\n                hl (quot (inc nn) 2)\n                i (->> n\n                       str\n                       (take hl)\n                       (apply str)\n                       BigInteger.\n                       ((if inc? inc identity)))\n                new-o (xor o (> (count (str i)) hl))\n                i (if (and o (not new-o))\n                    (quot i 10)\n                    i)]\n            (->> i\n                 str\n                 (#(apply str (concat % (if new-o (rest (reverse %)) (reverse %)))))\n                 BigInteger.)))]\n  (fn [n]\n    (filter #(>= % n) (iterate #(make-palindrome % true) (make-palindrome n false)))))", "problem": 150, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn iter-palindromic [x]\n    (letfn [(next-palindromic [x]\n                (let [xs (str x)\n                      h1 (.substring xs 0 (quot (inc (count xs)) 2))\n                      h2 (fn [h1] (reverse (.substring h1 0 (- (count xs) (count h1)))))\n                      y (fn [h1] (read-string (apply str h1 (h2 h1))))\n                      y0 (y h1)]\n                    (cond\n                        (< x y0) y0\n                        (re-matches #\"9+\" xs) (+ 2 x)\n                        true (y (str (inc (read-string h1)))))))]\n        (if (zero? x)\n            (iterate next-palindromic 0)\n            (iterate next-palindromic (next-palindromic (dec x))))))", "problem": 150, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [n] \n  (letfn [(bi [xs] (bigint (apply str xs)))\n          (toint [x] (-> x str Integer/parseInt))\n          (inc-p [a b] (conj a ((if (or (empty? a) (= 10 (last a))) inc identity) b)))\n          (next-palindrome [xs] (let [a (count xs)]\n                                  (if (every? (partial = 9) xs)\n                                    (concat [1] (repeat (dec a) 0) [1])\n                                    (let [b  (/ (if (even? a) (dec a) a) 2)\n                                          ys (take b xs)\n                                          zs (map #(mod % 10) (reduce inc-p [] (reverse ys)))]\n                                      (concat ((if (even? a) identity butlast) (reverse zs)) zs)))))\n          (palindromes [xs] (lazy-seq (cons (bi xs) (palindromes (next-palindrome xs)))))]\n    (let [s (str n)\n          t (apply str (reverse s))\n          a (count s)\n          b (/ (if (even? a) (dec a) a) 2)]\n      (palindromes\n       (cond\n        (= s t) (map toint s)\n        (< (bi s) (bi t)) (next-palindrome (map toint s))\n        :else (map\n               toint\n               (apply str (concat (take b s) (take-last ((if (even? a) identity dec) b) t)))))))))", "problem": 150, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn aa [n]\n         (lazy-seq\n           (if (re-find #\"^9+$\" (str n))\n             (cons n (aa (+ 2 n)))\n             (let [l (count (str n))\n                   p (int (/ l 2))\n                   [_ pfx ifx sfx] (re-find (re-pattern\n                                              (format \"(\\\\d{%d})(\\\\d?)(\\\\d{%d})\" p p))\n                                            (str n))\n                   nextpfx (fn [x] (inc (Long/parseLong x)))\n                   cand-lo (Long/parseLong (str pfx ifx (apply str (reverse pfx))))\n                   cand-hi (Long/parseLong (if (odd? l)\n                                             (if (= \"9\" ifx)\n                                               (str (nextpfx pfx) \"0\" (apply str (reverse (str (nextpfx pfx)))))\n                                               (str pfx (inc (Long/parseLong ifx)) (apply str (reverse pfx))))\n                                             (str (nextpfx pfx) (apply str (reverse (str (nextpfx pfx)))))))\n                   r (if (<= n cand-lo) cand-lo cand-hi)]\n               (cons r (aa (inc r)))))))", "problem": 150, "user": "50f48298e4b004d364930527"}, {"code": "(fn pal-seq [n]\n\t(letfn [\n    (with-mid [n] [(quot n 10) (mod n 10)])\t;get [front mid]\n\t(rev-int [n] (loop [ax 0 xs n] ;reverse a number\n\t\t\t\t\t\t (if (zero? xs)\n\t\t\t\t\t\t  ax\n\t\t\t\t\t\t  (recur (+ (mod xs 10)(* ax 10)) (quot xs 10)))))\t\t\t\t\t  \n\t(part-int [n] (let [len (count (str n)) ;(=  n (+ (* mult front) back)) or (= n (+ (* mult 10 front) (* mult mid)\n\t\t\t\t\t\t half-len (quot len 2)\n\t\t\t\t\t\t mult (apply * (repeat half-len 10))\n\t\t\t\t\t\t back (mod n mult)\n\t\t\t\t\t\t front (quot n mult)]\n\t\t\t\t\t\t(if (even? len)\n\t\t\t\t\t\t\t[front back mult nil]\n\t\t\t\t\t\t\t(let [[front mid] (with-mid front)]\n\t\t\t\t\t\t\t\t[front back mult mid]))))\n\t(align [f b mult mid] (if (>= (rev-int f) b) ;find front of so to be palindrome\n\t\t\t                [f mid]\n\t\t\t                (if (nil? mid)\n\t\t\t\t              [(inc f), nil]\n\t\t\t\t              (let [fmid (+ (* f 10) mid)\n                                    new-fmid (inc fmid)\n\t\t\t\t\t                [new-front new-mid] (with-mid new-fmid)]\n                                [new-front new-mid]))))\n\t(build [front mult mid] (if (nil? mid) ;build palindrome given correct front\n\t\t\t\t\t\t\t  (+ (* front mult) (rev-int front))\n\t\t                      (+ (* front 10 mult) (* mid mult) (rev-int front))))\n\t(find-pal [n] (let [[front back mult mid] (part-int n) ;call preceding fns\n\t\t\t            [new-front new-mid] (align front back mult mid)\n\t\t\t             pal (build new-front mult new-mid)]\n                    pal))]\n\t(let [pal (find-pal n)]\n\t (lazy-seq (cons pal (pal-seq (inc pal)))))))", "problem": 150, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn pn [x]\n\t(let [n (str x)\n\t\t  l (count n)\n\t\t  q (quot (count n) 2)\n\t\t  nn (inc (read-string (apply str (take (- l q) n))))\n\t\t  ni (read-string (str (str nn) (apply str (reverse (take q (str nn))))))\n\t\t  si (read-string (str (apply str (take (- l q) n)) (apply str (reverse (take q n)))))]\n\t\t  (if (< si x) \n\t\t\t(lazy-seq (pn ni))\n\t\t\t(cons si (lazy-seq (pn ni)))\n\t\t\t)))", "problem": 150, "user": "51c09719e4b0c9c82288293c"}, {"code": "(let [f (fn [n]\n          (let [s (str n) l (count s)\n                a (subs s 0 (Math/ceil (/ l 2)))\n                b (str (inc (read-string a)))]\n            (prn a b)\n            (first\n              (filter #(>= % n)\n                (map\n                  #(read-string\n                     (str\n                       %\n                       (subs (clojure.string/reverse %) (if (odd? l) 1 0))))\n                  [a b])))))]\n  \n  #(iterate (comp f inc) (f %))\n)", "problem": 150, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [num]\n           (let [p? (fn [n] (let [sn (str n)\n                                  cn (count sn)\n                                  head (take (/ (if (even? cn) cn (dec cn)) 2) sn)\n                                  tail (drop (/ (if (even? cn) cn (inc cn)) 2) sn)]\n                              (=  head (reverse tail))))\n                 num (if (p? num) num (loop [n num] (if (p? n) n (recur (inc n)))))\n                 next-p (fn [n]\n                          (let [sn (str n)\n                                cn (count sn)\n                                ->n (fn [l] (Integer. (apply str (flatten l))))\n                                half (->n (if (even? cn)\n                                            (take (/ cn 2) sn)\n                                            (take (/ (inc cn) 2) sn)))]\n                            (cond (every? #{\\9} sn) (->n (flatten [\"1\" (repeat (dec cn) \"0\" ) \"1\"]))\n                                  (= 1 cn) (inc n)\n                                  (= 2 cn) (+ 11 n)\n                                  (even? cn) (let [new-half (inc half)]\n                                               (->n [new-half (reverse (str new-half))]))\n                                  :else (let [half+center (inc half)]\n                                          (->n [half+center (reverse (butlast (str half+center)))])))))]\n             (iterate next-p num)))", "problem": 150, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn  [x]\n  (letfn [(gen [x k]\n                    (if (or (> x 9) (not k)) \n                      (->> (if k (quot x 10) x) str seq reverse (apply str) (str x) read-string)\n                      x))\n          \n          (f [x k]\n             (if (= (-> x str count) (-> x inc str count))\n               (lazy-cat [(gen x k)] (f (inc x) k))\n               (if k\n                 (lazy-cat [(gen x k)] (f (quot (inc x) 10) false))\n                 (lazy-cat [(gen x k)] (f (inc x) true)))))]\n    \n    (filter (partial <= x) (f (read-string (subs (str x) 0 (-> x str count inc (quot 2)))) (-> x str count odd?)))))", "problem": 150, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn go [input]\n  (letfn [(palindrome? [n]\n            (let [s (str n)]\n              (= s (clojure.string/reverse s))))\n          (num-> [n]\n            (let [s (str n)\n                  c (count s)]\n              [(map #(- (int %) (int \\0)) (reverse (take (Math/ceil (/ c 2)) s)))\n               (even? c)]))\n          (->num [[coll even-length]]\n            (let [s (apply str coll)]\n              (read-string\n               (str (clojure.string/reverse (apply str coll))\n                    (apply str (if even-length coll (rest coll)))))))\n          (gen [n]\n            (let [[coll even-length] (num-> n)]\n              (if (every? #{9} coll)\n                (->num [(concat\n                         (repeat (if even-length (count coll) (dec (count coll))) 0)\n                         [1])\n                        (not even-length)])\n                (->num [(map first (rest (reductions (fn [[_ carry] d]\n                                                       (if (pos? carry)\n                                                         (if (= 9 d) [0 1] [(inc d) 0])\n                                                         [d 0]))\n                                                     [0 1] coll)))\n                        even-length]))))]\n    (drop-while (partial > input)\n                (iterate gen (->num (num-> input))))))", "problem": 150, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [n]\n        (let [\n            build-palindrome \n            (fn [n b]\n                (read-string (apply str\n                            (concat (str n)\n                                ((if b identity (partial drop 1)) (reverse (str n)))))))\n            palindrome-sequence (fn rec-palindrome [ n b nmin nmax]\n                (let [\n                    nmx+1 (inc nmax)\n                    palindrome (build-palindrome n b)\n                    ]\n                (cons palindrome (lazy-seq \n                    (cond \n                        (< n nmax) (rec-palindrome (inc n) b nmin nmax)\n                        b   (rec-palindrome nmx+1 false nmx+1 (- (* 10 nmx+1) 1))\n                        :else   (rec-palindrome nmin true nmin nmax)\n                        )))))\n            strn (str n)\n            cn (count strn)\n            q (quot (inc cn) 2)\n            seed (read-string (apply str (take q strn)))\n            nmax (dec (apply * (repeat q 10)))\n            nmin (apply * (repeat (dec q) 10))\n            b (= 0 (mod cn 2)) \n        ]\n        ;(println \"n : \" n \" seed : \" seed \" nmin \" nmin \" nmax \" nmax)\n        (drop-while (partial > n) (palindrome-sequence seed b nmin nmax))\n        ))", "problem": 150, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "problem": 150, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn fun [n]\n\t(let [\n\t\tlen (count (str n))\n\t\tml (quot len 2)\n\t\trev (fn [n] (Integer. (apply str (reverse \n\t\t\t(if (odd? len) \n\t\t\t\t(if (= 1 len) \"0\" (butlast (str n))) \n\t\t\t\t(str n))))))\n\t\texp (fn exp [x n] (if (zero? n) 1 (* x (exp x (dec n)))))\n\t\tl-half (loop [n n, l ml] \n\t\t\t\t\t\t(if (zero? l) \n\t\t\t\t\t\t\tn \n\t\t\t\t\t\t\t(recur (quot n 10) (dec l))))\n\t\tr-half (rem n (exp 10 ml))]\n\t\t(if (>= (rev l-half) r-half)\n\t\t\t(let [ans (+ (* l-half (exp 10 ml)) (rev l-half))]\n\t\t\t\t(cons ans (lazy-seq (fun (inc ans)))))\n\t\t\t(let [\n\t\t\t\tnl-half (inc l-half)\n\t\t\t\tans (+ (* nl-half (exp 10 ml)) (rev nl-half))]\n\t\t\t\t;(println nl-half)\n\t\t\t\t(cons ans (lazy-seq (fun (inc ans))))))))", "problem": 150, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn __ [n]\n  (letfn [(dig [n] (map #(- (int %) 48) (str n)))\n          (num [ds] (reduce #(+ %2 (* 10 %)) 0 ds))\n          (inc-ds [ds] (dig (inc (num ds))))\n          (combine [l m r]\n            (let [rev (reverse l)\n                  lm (concat l m)]\n              (if (>= (num rev) (num r))\n                (num (concat lm rev))\n                (pal (num (concat\n                           (inc-ds lm)\n                           (repeat (count r) 0)))))))\n\n          (pal [n]\n            (let [ds (dig n)\n                  c (count ds)\n                  [l r0] (split-at (quot c 2) ds)\n                  [m r] (split-at (rem c 2) r0)]\n\n\t      (if (< c 2)\n\t\t(num ds)\n                (combine l m r))))]\n\n    (cons (pal n)\n          (lazy-seq (__ (inc (pal n)))))))", "problem": 150, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [x]\n  (filter\n    (fn [y] (and (>= y x) (= (map identity (str y)) (reverse (str y)))))\n    (map first (drop 1 (iterate\n      (fn [[_ h]]\n        (let [c (count (str h))\n              half [(- c (quot c 2)) (quot c 2)]\n              head (read-string (.substring (str h) 0 (first half)))\n              tail (apply str (reverse (take (second half) (str head))))]\n          [(read-string (str head tail)) (read-string (str (inc head) tail))]))\n      [nil x])))))", "problem": 150, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn palindromes [n]\n  (let [nstr (str n)\n        len-nstr (count nstr)\n        len-lhs (quot len-nstr 2)\n        len-lhsc (+ len-lhs (rem len-nstr 2)) ; includes center digit (if any)\n        lhs (subs nstr 0 len-lhs)\n        lhsc (subs nstr 0 len-lhsc)\n        rhs (subs nstr len-lhsc len-nstr)\n        lhs-rev (apply str (reverse lhs))\n        lhsc+ (str (inc (read-string lhsc)))\n        len-lhsc+ (count lhsc+)\n        intval (fn [s] (let [ns (clojure.string/replace s #\"^0+\" \"\")]\n                         (if (empty? ns) 0 (read-string ns))))\n        ]\n     (if (>= (intval lhs-rev) (intval rhs))\n      ;just mirror\n      (let [next-p (read-string (str lhsc lhs-rev))]\n        (cons next-p (lazy-seq (palindromes (inc next-p)))))\n      ;must increment\n      (let [growing? (> len-lhsc+ len-lhsc)\n            next-even-len? (if growing? (odd? len-nstr) (even? len-nstr))\n            next-lhsc (if (and growing? (odd? len-nstr)) (subs lhsc+ 0 len-lhsc) lhsc+)\n            next-lhs (if next-even-len? next-lhsc (subs next-lhsc 0 (dec (count next-lhsc))))\n            next-rhs (apply str (reverse next-lhs))\n            next-p (read-string (str next-lhsc next-rhs))\n            ]\n        (cons next-p (lazy-seq (palindromes (inc next-p))))))))", "problem": 150, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [n]\n  (letfn [(to-vec [x] (if (< x 10) [x] \n                        (conj (to-vec (quot x 10)) (rem x 10))))\n          (to-int [s] (reduce #(+ (* 10 %) %2) 0 s))\n          (genpl \n           [l flag]\n           (let [rl (reverse (to-vec l))]\n             (to-int \n              (concat \n               (to-vec l) \n               (if flag (rest rl) rl)))))\n          (half \n           [x] \n           (->>\n            x to-vec \n            (#(let [l (count %)\n                    t (if (odd? l) 1 0)]\n                (take (+ (quot l 2) t) %)))\n            to-int))\n          (nxpl \n           [x] \n           (->>\n            x half\n            (iterate inc)\n            (map #(genpl % (odd? (count (to-vec x)))))\n            (drop-while #(< % x))\n            first))]\n     (iterate (comp nxpl inc) (nxpl n))))", "problem": 150, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn f [n]\n  (let [r clojure.string/reverse\n        f2 (fn f2 [x]\n             (let [l (count (str x))\n                   e (if (even? l) (/ l 2) (inc (/ l 2)))\n                   y (Integer/parseInt (subs (str x) 0 e))\n                   z (inc y)\n                   t (Integer/parseInt (str (str z) (if (even? l) (r (str z)) (apply str (rest (r (str z)))))))]\n               (if (= (last (str z)) \\9)\n                 (cons t (lazy-seq (f (inc t))))\n                 (cons t (lazy-seq (f2 t))))))]\n    (loop [p n]\n     (if (= (str p) (r (str p)))\n      (cons p (lazy-seq (f2 p)))\n      (recur (inc p))))))", "problem": 150, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn pali [n]\n  (let [digit #(- (int %) (int \\0))\n        digits #(map digit (str %))\n        number #(reduce (fn [r d] (+ (* 10 r) d)) 0 %)\n        half #(+ (quot % 2) (mod % 2))\n        halfd #(take (half (count %)) %)\n        halfn (->> n digits halfd number)\n        cand (map\n               (fn [[i j]]\n                 (let [s (digits (+ i halfn))\n                       e (drop j (reverse s))\n                       p (number (concat s e))]\n                   p))\n               [[0 0] [0 1] [1 0] [1 1]])\n        p (apply min (filter (partial <= n) cand))]\n    (lazy-cat [p] (pali (inc p)))))", "problem": 150, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [n]\n  (let [s (str n),c (count s)\n        q (quot c 2),r (rem c 2)\n        h (subs s 0 q),l (subs s (+ q r) c),m (subs s q (+ q r))\n        p (.pow (biginteger 10) q)]\n    (->> (iterate #(* 10 %) p)\n         (map #(range % (* 10 %)))\n         (cons (if (= \"\" h) [\"\"] (range (Long. h) p)))\n         (map #(map str %))\n         (mapcat\n          (fn [xs]\n            [(map #(apply str % (reverse %)) xs)\n             (map (fn [x] (map #(apply str x % (reverse x)) (range 10))) xs)]))\n         (drop (if (= \"\" m) 0 1))\n         flatten\n         (map #(Long. %))\n         (drop-while #(< % n)))))", "problem": 150, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn ff [x]\n (let [ length #(-> % str count)\n       xLength (length x)\n       pow-ten #(->> % (Math/pow 10) long)\n       inc-len? #(< (length %) (-> % inc length))\n       next-num (fn [n odd] (if (and odd (inc-len? n)) (list (->> n length dec pow-ten) false) (list (inc n) (if (inc-len? n) (not odd) odd))))\n       f1 #(->> % str reverse rest (apply str %) (Long/parseLong))\n       f2 #(->> % str reverse (apply str %) (Long/parseLong)) \n       fx (fn f [n odd] (cons (if odd (f1 n) (f2 n)) (lazy-seq (apply f (next-num n odd)))))]\n(drop-while #(> x %) (fx (->> xLength (#(quot % 2)) pow-ten (quot x)) (-> xLength odd?)))))", "problem": 150, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn [from]\n    (letfn [\n(slow-palin [from]\n  (let [are-palin-digits? (fn [digits]\n                            (= (reverse digits) (seq digits)))\n        is-palin? (fn [n] (are-palin-digits? (str n)))]\n      (first (filter is-palin? (iterate inc from)))))\n\n(rawify [n]\n    (let [cars (seq (Long/toString n))\n          length (count cars)\n          half (quot (inc length) 2)]\n          (list (take half cars)\n                (even? length))))\n                \n(palin-for [[first-half-cars even-length]]\n    (if even-length\n        (concat first-half-cars (reverse first-half-cars))\n        (concat first-half-cars (drop 1 (reverse first-half-cars)))))\n      \n(reconstruct [[first-half-cars even-length]]\n    (let [digits (palin-for [first-half-cars even-length])]\n        (loop [res 0\n               power 1\n               todo digits]\n           (if (empty? todo)\n              res\n              (recur (+ res (* power (- (int (first todo)) (int \\0))))\n                     (* power 10)\n                     (rest todo))))))\n\n(inc-cars [cars]\n    (letfn [(rinc [rcars]\n        (if (empty? rcars)\n            '(\\1)\n            (let [plussed (inc (int (first rcars)))]\n                (if (= 58 plussed)\n                    (cons \\0 (rinc (rest rcars)))\n                    (cons (char plussed) (rest rcars))))))]\n        (reverse (rinc (reverse cars)))))\n    \n(next-palin [[first-half-cars even-length]]\n      (let [next-int-cars (inc-cars first-half-cars)]\n        (if (= (count first-half-cars)\n               (count next-int-cars))\n           (list next-int-cars even-length)\n           (if even-length\n             (list next-int-cars false)\n             (list (drop-last next-int-cars) true)\n             ))))\n           \n(raw-palins [from] (iterate next-palin (rawify (slow-palin from))))\n\n(palins [from] (map reconstruct (raw-palins from)))]\n    (palins from)))", "problem": 150, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn palindrome [n] \n  (let [\tto-digits (fn [k] (into [] (map #(mod (quot k %) 10) \n                                    (take-while #(< 0 (quot k %)) (iterate #(* 10 %) 1) ))))\n\t\tto-number (fn [k] (apply + (map * k (iterate #(* 10 %) 1))))\n\t\tleft-digits #(subvec % (/ (count % ) 2))\n\t\teven-digits? #(even? (count %))\n\t\tmirror (fn [[num dig]]\n\t\t\t     (let [ digits (to-digits num)]\n\t\t\t\t\t  (if (= :even dig) (concat (reverse digits) digits)\n\t\t\t\t\t\t\t           (concat (reverse (drop 1 digits)) digits))))\n\t\tinit #(let [ld (left-digits %)] \n\t\t       (vector (to-number ld) \n\t\t\t          (if (even-digits? %) :even :odd) \n\t\t\t\t\t  (long (Math/pow 10 (count ld)))))\n\t\tnextp (fn [[num even goal]] \n\t\t\t   (let [m (inc num)] \n\t\t\t\t  (if (= m goal)\n\t\t\t\t\t  (if (= even :even)\n\t\t\t\t\t\t  [goal :odd (* 10 goal)]\n\t\t\t\t\t\t  [(/ goal 10) :even goal])\n\t\t\t\t\t  [m even goal] )))\t\t  \n        i  (init (to-digits n)) \n        palindromes (iterate nextp i) ] \n\t(filter (partial <= n ) (map (comp to-number mirror) palindromes))))", "problem": 150, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn pal [x]\n  (let [s (str x)\n        r (apply str (reverse s))\n        p (if (= s r) x\n              (let [x1 (inc x)\n                    s1 (str x1)\n                    c (count s1)\n                    l (- c (quot c 2))\n                    t (- c l)\n                    base  (read-string (apply str (take l s1)))\n                    bstr (str base)\n                    tmp (read-string (str bstr (apply str (take-last t (reverse bstr)))))\n                    b2 (if (> x1 tmp)\n                         (inc base) base)\n                    tail (apply str (take-last t (reverse (str b2))))]\n                (read-string (str b2 tail))))]\n    (cons p (lazy-seq (pal (inc p))))))", "problem": 150, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn pal [x]\n    (if (< x 10)\n      (cons x (lazy-seq (pal (inc x))))\n      (if (even? (count (str x)))\n        (let [s (str x)\n              fh (read-string (.substring s 0 (/ (count s) 2)))\n              sh (apply str (reverse (str fh)))\n              np (read-string (apply str (concat (str fh) (str sh))))\n              np2 (read-string (apply str (concat\n                                           (str (inc fh))\n                                           (map (constantly \\0) (str sh)))))]\n          (if (< np x)\n            (pal np2)\n            (cons np (lazy-seq (pal np2))))\n          )\n        (let [s (str x)\n              fh (read-string (.substring s 0 (inc (/ (count s) 2))))\n              sh (apply str (reverse (butlast (str fh))))\n              np (read-string (apply str (concat (str fh) (str sh))))\n              np2 (read-string (apply str (concat\n                                           (str (inc fh))\n                                           (map (constantly \\0) (str sh)))))]\n          (if (< np x)\n            (pal np2)\n            (cons np (lazy-seq (pal np2))))\n          ))))", "problem": 150, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [n]\n  (iterate (fn [x]\n             (if (= x 9) 11\n               (let [s (str x) t (count s)\n                     half (quot (inc t) 2) \n                     l (->> s (take half) (apply str) Integer. inc str)\n                     r (->> l (take (- t half)) reverse (apply str))]\n                 (Integer. (str l r)))))\n           (first (drop-while #(not= (str %) (apply str (reverse (str %)))) (iterate inc n)))))", "problem": 150, "user": "52479487e4b05ef8e38e6373"}, {"code": "(let [palindromic (fn [seed oddity] \n                    (let [s (str seed) r (reverse s)] \n                      (Long/parseLong (apply str (concat s (if oddity (rest r) r))))))\n      step (fn [seed oddity] \n             (let [news (inc seed)\n                   newl (not= (count (str seed)) (count (str news)))] \n               (cond (and newl oddity) [(quot news 10) (not oddity)]\n                     newl [news (not oddity)]\n                     :else [news oddity])))]\n  (fn p-seq \n   ([n] (let [l (count (str n))\n              seed (quot n (reduce * (repeat (quot l 2) 10)))\n              oddity (odd? l)\n              ret (p-seq seed oddity)]\n          (if (< (first ret) n) (rest ret) ret)))\n   ([seed oddity] (cons (palindromic seed oddity) \n                        (lazy-seq (apply p-seq (step seed oddity)))))))", "problem": 150, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn palindromic-numbers [n]\n  (let [get-digits (fn [n]\n                     (loop [len (count (str n))\n                            m n\n                            res '()]\n                       (if (= len 0)\n                         res\n                         (recur (dec len) (quot m 10) (conj res (rem m 10))))))\n        to-num (fn [digits]\n                 (reduce #(+ (* %1 10) %2) digits))\n        make-palindromic (fn [n]\n                           (to-num\n                            (loop [digits (vec (get-digits n))\n                                   i 0\n                                   j (dec (count digits))]\n                              (if (>= i j)\n                                digits\n                                (recur (assoc digits j (digits i)) (inc i) (dec j))))))\n        next-palindromic (fn [n]\n                           (let [m (make-palindromic n)]\n                             (if (> m n)\n                               m\n                               (let [len (count (str m))\n                                     to-add (reduce * (repeat (quot len 2) 10))]\n                                 (make-palindromic (+ m to-add))))))]\n  \t(iterate next-palindromic (next-palindromic (dec n)))))", "problem": 150, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [z] \n    (rest\n      (iterate\n        (fn [n]\n          (if (< n 0)\n            0\n            (let [to-digits   (fn [x] (->> x\n                                            (iterate #(quot % 10))\n                                            (take-while #(>= % 1))\n                                            (map #(mod % 10))\n                                            reverse))\n                      to-number   (partial reduce #(+ (* % 10) %2) 0)\n                      digits      (to-digits n)\n                      size        (count digits)\n                      base-size   (quot size 2)\n                      has-middle  (odd? size)\n                      abase-size  (if has-middle (inc base-size) base-size)\n\n                      [alds, rds] (split-at abase-size digits)\n                      [lds, md]   (split-at base-size alds)\n\n                      next-one    (>= (to-number rds) (to-number (reverse lds)))\n                      abase       (to-number alds)\n                      nabase      (if next-one (inc abase) abase)\n                      count-chg   (> (count (to-digits nabase)) (count alds))\n                      nabase      (if (and has-middle count-chg) (quot nabase 10) nabase)\n                      has-middle  (if count-chg (not has-middle) has-middle)\n                      alds        (to-digits nabase)\n                      rlds        (reverse alds)\n                      rlds        (if has-middle (rest rlds) rlds)\n                      all-digits  (lazy-cat alds rlds)\n                      next-pal    (to-number all-digits)]\n                     next-pal)))\n          (dec z))))", "problem": 150, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [a]\n     (let [rev #(clojure.string/reverse %)\n           gn #(str (inc (Long. %)))\n           gnp #(let [s (str %)]\n                  (if (= (set s) #{\\9}) (+ % 2)\n                    (let [n (count s) m (/ n 2) hs (subs s 0 m)]\n                      (Long. (if (even? n)\n                                  (let [nx (gn hs)] (str nx (rev nx)))\n                                  (let [md (Long. (subs s m (inc m)))]\n                                    (if (< md 9) (str hs (inc md) (rev hs))\n                                      (let [nx (gn hs)] (str nx 0 (rev nx))))))))))]\n       ((fn ps [x] (cons x (lazy-seq (ps (gnp x)))))\n         (let [s (str a) n (count s) m (/ n 2) h (subs s 0 m)\n               t (Long. (str h (subs s m (/ (inc n) 2)) (rev h)))]\n           (if (>= t a) t (gnp t))))))", "problem": 150, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [a]\n  (let [firsthalf (fn [x] (subs x 0 (int (/ (count x) 2))))\n        lasthalf (fn [x] (subs x (- (count x) (int (/ (count x) 2)))))\n        middle (fn [x] (subs x (int (/ (count x) 2)) (inc (int (/ (count x) 2)))))\n        strcat (fn [x y] (apply str (concat x y)))\n        getfirst (fn [x]\n                   (let [i (str x) c (count i)]\n                     (if (= 1 c)\n                       [x false]\n                       (if (>= (Long. (apply str (reverse (firsthalf i)))) (Long. (lasthalf i)))\n                         (if (even? c)\n                           [(Long. (firsthalf i)) true]\n                           [(Long. (strcat (firsthalf i) (middle i))) false])\n                         (if (even? c)\n                           [(inc (Long. (firsthalf i))) true]\n                           [(inc (Long. (strcat (firsthalf i) (middle i)))) false])))))\n        makenum (fn [[x y]]\n                  (if y \n                    (Long. (strcat (str x) (reverse (str x))))\n                    (Long. (strcat (str x) (rest (reverse (str x)))))))\n        incpal (fn [[x y]]\n                 (let [s (str (inc x))\n                       f (frequencies s)]\n                   (if (and (= (dec (count s)) (f \\0)) (= 1 (f \\1)))\n                     (if y\n                       [(inc x) (not y)]\n                       [(inc (int (/ x 10))) (not y)])\n                     [(inc x) y])))        \n        ]\n    ((fn lazy [y] (cons (makenum y) (lazy-seq (lazy (incpal y))))) (getfirst a))))", "problem": 150, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn palindromic [n]\n            (letfn [(to-int [x](BigInteger. (str x)))\n                    ;(to-int [x](int x))\n                    (build [left](let[frst (first left)]\n                                   (to-int(apply str (concat frst (reverse (if (last left)(butlast frst) frst)))))))\n                    (get-left [x](let [s (map to-int(str x)) cnt (count s) \n                                       spl (split-at(quot cnt 2)s) has-center (odd? cnt)]\n                                \t(vector (concat(first spl)(if has-center (list(first(last spl)))'())) has-center)\n                                \t))\n                    (inc-left [left] (let [new-left (map to-int(str(inc(to-int(apply str(first left))))))\n                                           new-center (if (=(count(first left))(count new-left))(last left)(not(last left)))]\n                                       (vector (if(and(not new-center)(not= new-center (last left)))(butlast new-left)new-left)new-center)))\n                    (get-next [x](build(inc-left(get-left x))))\n                    (get-first [x](let [origin (build(get-left x))](if (< origin x)(get-next x)origin)))\n                    ]\n              (iterate get-next (get-first n))\n            )\n          )", "problem": 150, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn palindrome [n] \n  (let [even-digits? #(even? (count %)) \n        left-middle #(if (even-digits? %) \n                       (subs % 0 (quot (count % ) 2) ) \n                       (subs % 0 (inc (quot (count % ) 2)))) \n        mirror (fn [[num dig]]\n                 (loop [a num r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)) (quot r 10)))))\n        init #(let [s (left-middle %)] \n                (vector (Long/parseLong s) \n                        (if (even-digits? %) :even :odd) \n                        (long (Math/pow 10 (count s)))))\n        nextp (fn [[num even goal]] \n               (let [m (inc num)] \n                 (if (= m goal)\n                   (if (= even :even)\n                     [goal :odd (* 10 goal)]\n                     [(/ goal 10) :even goal])\n                   [m even goal] )))\n        i  (init (str n)) \n        palindromes (iterate nextp i) ] \n    (filter (partial <= n ) (map mirror palindromes))))", "problem": 150, "user": "51d11f5de4b067c365486360"}, {"code": "(fn f [num]\n  (let [toInt (fn [s] (reduce #(+ (* % 10) (- (int %2) 48)) 0 s))\n        pow (fn [m n] (reduce #(* % %2) 1 (repeat n m)))\n        s (str num)\n        len (count s)\n        mid (quot (inc len) 2)\n        mid- (quot len 2)\n        first (subs s 0 mid)\n        first- (subs s 0 mid-)\n        palin (toInt (str first (clojure.string/reverse first-)))\n        next (* (inc (toInt first)) (pow 10 mid-))]\n    (if (>= palin num) (cons palin (lazy-seq (f (inc palin))))\n      (f next))))", "problem": 150, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn [n]\n  (letfn [(sd [n]\n            (reverse\n             ((fn g [n] (when (> n 0) (cons (mod n 10) (g (quot n 10))))) n)))\n          (fd [d]\n            ((fn g [[d & ds] m] (if d (+ (* m d) (g ds (* 10 m))) 0))\n             (reverse d) 1))\n          (npn [n f]\n            (if (and (= f inc) (= n 9))\n              11\n              (let [ds (sd n) \n                    cnt (count ds)\n                    ds (take (int (Math/ceil (/ cnt 2))) ds) \n                    ds (sd (f (fd ds)))]\n                (fd (concat ds (reverse (take (int (/ cnt 2)) ds)))))))]\n    (drop-while #(< % n)\n                (iterate #(npn % inc) (npn n identity)))))", "problem": 150, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [n-input] (let [ispalindrome? (fn [x] (= (clojure.string/join \"\" (reverse (str x))) (str x))) str-to-int (fn [x] (reduce (fn [a b] (+ (- (int b) (int \\0)) (* 10 a))) 0 x)) bumpit (fn [n] (let [set-it (fn [s k v] (str (subs s 0 k) v (subs s (inc k)))) next-str-dig (fn [c] (char (inc (int c))))] (loop [pos (quot (count (str n)) 2) result (str n) max-pos (dec (count (str n))) center (= 1 (rem (count (str n)) 2))] (if (< (int (nth result pos)) (int \\9)) (if center (str-to-int (set-it result pos (next-str-dig (nth result pos)))) (str-to-int (set-it (set-it result pos (next-str-dig (nth result pos))) (- max-pos pos) (next-str-dig (nth result pos))))) (if (= pos max-pos) (str-to-int (str 1 (reduce (fn [q r] (str q \"0\")) \"\" (range max-pos)) 1)) (recur (inc pos) (if center (set-it result pos 0) (set-it (set-it result pos 0) (- max-pos pos) 0)) max-pos (= 1 0))))))) find-first-pal (fn [k] (if (ispalindrome? k) k (recur (inc k))))] (iterate bumpit (find-first-pal n-input))))", "problem": 150, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn pali-seq [n]\n  (let [to-seq (fn [n] (map (comp read-string str) (str n)))\n        to-num (fn [s] (reduce #(+ (* %1 10) %2) 0 s))\n        sym? (fn [s] (= s (reverse s)))\n        nextpal\n        (fn  [n]\n          (let [\n                 s (to-seq n)\n                 l (count s)\n                 s1 (to-num (take (quot (inc l) 2) s))\n                 si (to-seq (if (sym? s) (inc s1) s1))\n                 ns (if (= (set s) #{9}) (concat [1] (repeat (dec l) 0) [1])\n              (concat (if (even? l) si (butlast si)) (reverse si)))]\n            (to-num ns)))\n        as (drop-while #(< % n) (iterate nextpal (nextpal n)))]\n    (if (sym? (to-seq n)) (cons n as) as)\n    ))", "problem": 150, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [n]\n  (let [digit-list (fn digit-list[m]\n                     (if (< m 10) [m] (conj (digit-list (quot m 10)) (mod m 10))))\n        number-from-list (fn number-from-list [l]\n                           (if (empty? l) 0 (+ (last l) (* 10 (number-from-list (butlast l))))))\n        half (fn [m] (number-from-list (let [m-str (digit-list m)\n                                             m-len (count m-str)]\n                                         (take (- m-len (int (/ m-len 2))) m-str))))\n        n-half (half n)\n        palinize (fn [m size]\n                   (number-from-list (let [m-str (digit-list m)]\n                                       (concat m-str (if (even? size) (reverse m-str) (rest (reverse m-str)))))))\n        palins (fn palins [m size]\n                 (lazy-seq\n                   (cons (palinize m size)\n                         (if (= (count (digit-list m)) (count (digit-list (inc m))))\n                           (palins (inc m) size)\n                           (palins (if (even? size) (inc m) (/ (inc m) 10)) (inc size))))))]\n    (if (>= (palinize n-half (count (digit-list n))) n)\n      (palins n-half (count (digit-list n)))\n      (if (= (count (digit-list n-half)) (count (digit-list (inc n-half))))\n        (palins (inc n-half ) (count (digit-list n)))\n        (palins (if (even? (count (digit-list n))) (inc n-half) (/ (inc n-half) 10)) (inc (count (digit-list n))))))\n    ))", "problem": 150, "user": "4fb1325de4b081705acca276"}, {"code": "(fn [n]\n  (letfn [(lazy-pal []\n            (letfn [(cpal [base isodd]\n                      (let [b 10.0\n                            n (if isodd base (bigint (/ base b)))]\n                        (loop [p base nn n]\n                          (if (= nn 0) (bigint p)\n                              (recur (+' (*' p b) (mod nn b)) (bigint (/ nn b)))))))]\n              (cons 0\n                    (mapcat (fn [x]\n                              (mapcat (fn [t]\n                                        (map #(cpal % t) (range x (* 10 x)))) [false true]))\n                            (iterate (partial * 10) 1)))))]\n    (if (> n (apply * (repeat 15 10))) [n] ;; ball-buster bailout\n        (drop-while #(< % n) (lazy-pal)))))", "problem": 150, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn pal-num [n]\n  (let [s (str n)\n        length (count s)\n        half (subs s 0 (Math/ceil (/ length 2)))\n        next-half (str (inc (read-string half)))\n        next-pal (first\n                   (filter #(>= % n)\n                     (map #(read-string (str %\n                                            (subs (clojure.string/reverse %) (if (even? length) 0 1))))\n                          [half next-half])\n                     )\n                 )]\n    (cons next-pal (lazy-seq (pal-num (inc next-pal)))))\n)", "problem": 150, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn genp [x]\n  (lazy-seq\n   (let [\n         p? (fn [x] (= (clojure.string/reverse (str x)) (str x)))\n         nextp (fn [x] (take 1 (filter p? (iterate inc x))))\n         midp (fn [x] (quot (inc (count x)) 2))\n         nextmidn (fn [s n] (str (inc (read-string\n                                       (str (reduce str (first (split-at n s))) )))))\n         flipf (fn [x] (reduce str (concat x \"1\")) )\n         genpx (fn [x] (let [nextx (nextmidn x (midp x))]\n                         (cond\n                           (re-find #\"^(9)\\1*\" x) (str (+ (read-string x) 2) )\n                          (= (count x) 1) nextx ;;one digit palindromes\n                          ((complement =) (midp x) (count nextx)) (str (flipf nextx))\n                          (= 0 (mod (count x) 2)) (reduce str (concat nextx (reverse nextx)) )\n                          :else (str (reduce str (concat nextx (rest (reverse nextx)))) )\n                          )) )\n         x (if (p? x) x ((comp first nextp) x))\n         n (read-string (genpx (str x)))]\n     (cons x (genp n)))))", "problem": 150, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn pals [n]\n  (let [pow (fn pow [i j]\n              (if (= 0 j) 1\n                  (* i (pow i (dec j)))))\n        digits (fn digits [i]\n                 (let [qu (quot i 10)\n                       mo (mod  i 10)]\n                   (if (= 0 qu) [mo]\n                       (conj (digits qu) mo))))\n        ptoi (fn ptoi [[p e?]]\n               (let [d (digits p)\n                     dc (dec (if e? (* 2 (count d)) (dec (* 2 (count d)))))\n                     acu (fn [[ac n] i]\n                           (let [base\n                                 (if (= n (- dc n))\n                                   (pow 10 n)\n                                   (+ (pow 10 n) (pow 10 (- dc n))))]\n                             [(+ ac (* base i)) (inc n)]))]\n                 (first (reduce acu [0 0] d))))\n        pal? (fn pal? [i]\n               (= (seq (str i)) (reverse (str i))))\n        next-pal (fn next-pal [[p e?]]\n                   (if (> (count (digits (inc p))) (count (digits p)))\n                     (if-not e?\n                       [(quot (inc p) 10) (not e?)]\n                       [(inc p) (not e?)])\n                     [(inc p) e?]))\n        first-pal (fn first-pal [i]\n                    (if (= 0 i) [0 false]\n                        (let [dc (count (digits i))\n                              e? (even? dc)\n                              dcd (dec dc)\n                              pos-dec (fn [p]\n                                        (if (= p (- dcd p))\n                                          (pow 10 p)\n                                          (+ (pow 10 p) (pow 10 (- dcd p)))))]\n                          [((fn pp-sub [curi pos curdec acc]\n                              (let [newi (- curi curdec)]\n                                (if (<= newi 0)\n                                  ;; We have exhausted this factor\n                                  (if (< pos (quot dcd 2))\n                                    ;; We have other factors though\n                                    (pp-sub curi (inc pos) (pos-dec (inc pos)) (* 10 acc))\n                                    ;; Otherwise we are done\n                                    (inc acc))\n                                  ;; We can keep going with this factor\n                                  (pp-sub newi pos curdec (inc acc))))) i 0 (pos-dec 0) 0) e?])))]\n    (map ptoi (iterate next-pal (first-pal n)))))", "problem": 150, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [n]\n  (let [pal? (fn [n]\n                (= (str n) (apply str (reverse (str n)))))\n        nextpal (fn [p]\n                  (if (pal? p)\n                    p\n                    (recur (inc p))))\n        palinc (fn [n]\n               (let [s (str n)\n                     c (count s)]                                                                   \n                 (if (every? #(= \\9 %) s)                                                           \n                   (read-string (str \"1\" (apply str (repeat (dec c) \"0\")) \"1\"))                     \n                   (let [l (take (Math/ceil (/ c 2)) s)\n                         li (str (inc (read-string (apply str l))))]                                \n                     (read-string (apply str (concat li\n                                                     (if (zero? (mod c 2))                          \n                                                       (reverse li)\n                                                       (drop 1 (reverse li))))))))))]               \n    (iterate palinc (nextpal n))))", "problem": 150, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "51a9dbc9e4b04e3dc0c27b1e"}, {"code": "(fn [n]\n  (letfn [(pow-ten [n]\n            (reduce *' (repeat n 10)))\n\n          (reverse-digits [n]\n            (loop [n n\n                   result []]\n              (let [new-n (quot n 10)\n                    new-result (conj result (rem n 10))]\n                (if (zero? new-n) new-result\n                    (recur new-n new-result)))))\n\n          (digits-to-number [digits]\n            (let [n (count digits)\n                  powers-of-ten (map #(pow-ten %)\n                                     (range (dec n) -1 -1))]\n              (reduce +' (map *' digits powers-of-ten))))\n\n          (rev-num [n]\n            (digits-to-number (reverse-digits n)))\n\n          (count-digits [n]\n            (if (zero? n) 1\n                (count\n                 (take-while #(not (zero? %))\n                             (iterate #(quot % 10) n)))))\n\n          (palize [n & middle]\n            (let [d (count-digits n)\n                  left-shift (if (empty? middle) d (inc d))\n                  head (*' n (pow-ten left-shift))\n                  mid (if (empty? middle) 0\n                          (*' (first middle) (pow-ten d)))]\n              (+' head mid (rev-num n))))\n\n          (closest-pal [n]\n            (let [digits (count-digits n)\n                  half (int (/ digits 2))\n                  left (quot n (pow-ten half))\n                  middle (if (odd? digits) (rem left 10))\n                  left (if (odd? digits) (quot left 10) left)]\n              (cond\n               (> 0 n) 0\n               (>= 9 n) n\n               middle (palize left middle)\n               :else (palize left))))\n\n          (next-pal [n]\n            (let [digits (count-digits n)\n                  half (int (/ digits 2))\n                  left (quot n (pow-ten half))\n                  middle (if (odd? digits) (rem left 10))\n                  left (if (odd? digits) (quot left 10) left)]\n              (cond\n               (> 0 n) 0\n               (> 9 n) (inc n)\n               (= 9 n) 11\n               (and middle (> 9 middle)) (palize left (inc middle))\n               middle (if (= (count-digits (inc left)) (count-digits left)) (palize (inc left) 0) (palize (inc left)))\n               (> (count-digits (inc left)) (count-digits left)) (palize (/ (inc left) 10) 0)\n               :else (palize (inc left)))))]\n\n    (drop-while\n     #(> n %)\n     (iterate next-pal (closest-pal n)))))", "problem": 150, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn pals [n]\n  (let [exp (fn [x n] (reduce * (repeat n x)))\n        next-p \n        (fn next-p [n]\n          (let [digits (map #(read-string (str %)) (seq (str n)))\n                ln (count digits)\n                left (take (int (/ ln 2)) digits)\n                center (nth digits (int (/ (dec ln) 2)))\n                new (if (odd? ln)\n                       (read-string (apply str (concat left (list center) (reverse left))))\n                      (read-string (apply str (concat left (reverse left)))))\n                incr (if (odd? ln)\n                       (exp 10 (int (/ ln 2)))\n                      (int (* 1.1 (exp 10 (int (/ ln 2))))))]\n            (if (> new n) new\n              (if (= 9 center) \n                 (let [i (exp 10 (inc (int (/ ln 2))))]\n                   (next-p (* (inc (int (/ n i))) i)))\n                (+ new incr)))))\n        curr  (if (= (seq (str n)) (reverse (seq (str n)))) n (next-p n))]\n    (cons curr (lazy-seq (pals (next-p curr))))))", "problem": 150, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn mp \n  ([n] (let\n         [s (count (str n))\n          rl (quot s 2)\n          l (quot n (reduce * (repeat rl 10)))\n          lim (reduce * (repeat (quot (inc s) 2) 10))\n          npals (mp l rl lim)]\n         (if (< (first npals) n)\n           (rest npals)\n           npals)))\n  ([l rl lim]\n   (let [s (str l)\n         pal (if (> rl 0) (read-string (apply str (concat s (reverse (take rl s))))) l)\n         [nl nrl nlim] (if (= (inc l) lim) (if (= (count s) rl)\n                                             [lim rl (* lim 10)]\n                                             [(/ lim 10) (inc rl) lim])\n                         [(inc l) rl lim])\n         ]\n     (cons pal (lazy-seq (mp nl nrl nlim))))))", "problem": 150, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [n]\n  (letfn [( g [n t i]\n            (let [n (+ n i)]\n              (if (>= n t)\n                (recur (- n t) i (/ t 100))\n                n)))\n          (f [left right lt li rt ri o]\n            (let [left (+ left li)]\n              (if (= left lt)\n                (if o\n                  (lazy-seq (cons (inc left)\n                                  (f left 1 (* 10 lt) rt rt ri false)))\n                  (lazy-seq (cons (inc left)\n                                  (f left 1 (* 10 lt) li (* 100 ri) rt true))))\n                (let [right (g right rt ri)]\n                  (lazy-seq (cons (+ left (if o (mod right ri) right)) (f left right lt li rt ri o)))))))]\n    (let [c (count (str n))\n          qc (quot c 2)\n          rc (max qc (- c qc))\n          left (- n (mod n (apply * (repeat qc 10))))\n          right (Integer/parseInt (apply str (reverse (str left))))\n          lt (apply * (repeat c 10))\n          li (apply * (repeat qc 10))\n          rt (apply * (repeat rc 10))\n          ri (apply * (repeat (dec rc) 10))\n          o (== (mod c 2) 1)\n          rn (+ left (if o (mod right ri) right))]\n      (if (>= rn n)\n        (lazy-seq (cons rn (f left right lt li rt ri o)))\n        (f left right lt li rt ri o)))))", "problem": 150, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(letfn [(digit-vector [n]\n            (loop [n n\n                   ds []]\n              (if (zero? n)\n                (if-not (seq ds)\n                  [0]\n                  ds)\n                (recur (quot n 10) (conj ds (mod n 10))))))\n\n          (digit-count [n]\n            (count (digit-vector n)))\n\n          (next-palindrome [n]\n            (let [digits (digit-count n)\n                  odd-digits? (odd? digits)\n                  left-digits (quot (+ 1 digits) 2)\n                  right-digits (- digits left-digits)\n                  left (quot n (apply * (repeat right-digits 10)))\n                  right (mod n (apply * (repeat right-digits 10)))\n\n                  wrap? (not (= left-digits (digit-count (inc left))))\n\n                  next-odd? (if wrap?\n                              (not odd-digits?)\n                              odd-digits?)\n                  next-left-digits (cond\n                                     (not wrap?) left-digits\n                                     next-odd? (+ 1 left-digits)\n                                     :else left-digits)\n                  next-left (if wrap?\n                              (apply * (repeat (dec next-left-digits) 10))\n                              (inc left))\n                  reconstruct (fn [left odd-digits?]\n                                (loop [n left\n                                       r (if odd-digits?\n                                           (quot n 10)\n                                           n)]\n                                  (if (zero? r)\n                                    n\n                                    (recur (+' (*' n 10) (mod r 10))\n                                           (quot r 10)))))]\n              (if (> (reconstruct left odd-digits?) n)\n                (reconstruct left odd-digits?)\n                (reconstruct next-left next-odd?))))\n\n          (palindrome? [n]\n            (loop [ds (digit-vector n)]\n              (if (>= 1 (count ds))\n                true\n                (if-not (= (first ds) (last ds))\n                  false\n                  (recur (subvec ds 1 (dec (count ds))))))))]\n    (fn [n]\n      (let [s (iterate next-palindrome n)]\n        (if (palindrome? n)\n          s\n          (drop 1 s)))))", "problem": 150, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(letfn [(to-str [n]\n                          (let [nstr (str n)\n                                size (quot (count nstr) 2)]\n                            [nstr size]))\n                        (to-int [s]\n                          (BigInteger. (apply str s)))\n                        (low [n]\n                          (let [[nstr size] (to-str n)]\n                            (apply str (take-last size nstr))))\n                        (mhigh [n]\n                          (let [[nstr size] (to-str n)]\n                            (to-int (drop-last size nstr))))\n                        (high [n]\n                          (let [[nstr size] (to-str n)]\n                            (apply str (take size nstr))))\n                        (rhigh [n]\n                          (apply str (reverse (high n))))\n                        (poly [n]\n                          (BigInteger. (str (mhigh n) (rhigh n))))\n                        (next-poly [n]\n                          (if (>= (poly n) n)\n                            (poly n)\n                            (poly (BigInteger. (str (inc (mhigh n)) (low n))))))]\n                  (fn polys [n]\n                    (let [p (next-poly n)]\n                      (lazy-seq (cons p (polys (inc p)))))))", "problem": 150, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [n]\n  (let [sn (str n)\n        sodd (odd? (count sn))\n        sn2 (subs sn 0 (/ (inc (count sn)) 2))\n        ex (fn ex [i odd]\n             (let [si (str i)\n                   all-9 (every? #(= \\9 %) si)\n                   ii (if odd\n                        (read-string (str si (apply str (rest (reverse si)))))\n                        (read-string (str si (apply str (reverse si)))))]\n               (lazy-seq\n                 (cons ii\n                   (if all-9\n                     (if odd\n                         (ex (quot (inc i) 10) (not odd))\n                         (ex (inc i) (not odd)))\n                     (ex (inc i) odd))))))\n        ]\n    (filter #(>= % n) (ex (read-string sn2) sodd))))", "problem": 150, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn palindromic-numbers [n]\n  (let \n      [poli? (fn [n] \n               (if (= (n 0) (n (dec (count n))))\n                 (let [len (count n)\n                     part (quot len 2)\n                     p1 (reverse (subvec n 0 part))\n                     p2 (subvec n (if (even? len) part (inc part)))]\n\n                 ;; Simple valiant\n                   (if (= p1 p2) \n\n                      (if (= \\9 (first p1)) (dec len) len) \n                      \n                      nil))\n                 nil))\n\n       \n       find-next-poli (fn [n]\n                        \n                        (loop [n n]                          \n                          (let [len (poli? (vec (str n)))]\n                            (if-not (nil? len)\n                              [n,len]\n                              (recur \n                               (inc n))))))\n       \n       [p,len]  (find-next-poli n)\n       ]\n    \n    ;;(find-next-poli n)\n    (lazy-seq (cons p (palindromic-numbers \n                       (if (> p 10000000)\n                         (+ p \n                            \n                            \n                            (apply * \n                                   (if (= (rem len 2)) 11 101)\n                                   (repeat (dec (quot len 2)) 10) )\n\n                                      \n                            \n                            )  \n                         (inc p))\n                       ))))\n    \n    )", "problem": 150, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn\n  [n]\n  (let [\n        next-palin\n        (fn\n          [n]\n          (cond\n           (< n 9) (inc n)\n           (= n 9) 11\n           (< n 99) (let [s (inc (rem n 10))] (read-string (str s s)))\n           (= n 99) 101\n           :d\n           (let [ns (str n) \n                 nv (vec (map #(read-string (str %)) (str ns))) \n                 c (count ns) \n                 q (quot c 2) \n                 m (if (even? c)\n                     (subs ns (dec q) (inc q))\n                     (subs ns q (inc q)))\n                 mn (read-string (str (first m)))\n                 sf (subs ns 0\n                          (if (even? c) (dec q) q))\n                 nf (read-string sf)\n                 i (inc nf)\n                 mc (inc mn)]\n             (->>\n              (if (= mc 10)\n                (if (even? c)\n                  (if (= (count sf) (count (str i)))\n                    (str i \"00\" (reduce str (reverse (str i))))\n                    (str i \"0\" (reduce str (reverse (str i)))))\n                  (if (= (count sf) (count (str i)))\n                    (str i \"0\" (reduce str (reverse (str i))))\n                    (str i (reduce str (reverse (str i))))))\n                (if (even? c)\n                  (str nf (str mc mc) (reduce str (reverse (str nf))))\n                  (str nf mc (reduce str (reverse (str nf))))))\n              read-string))))\n        get-first-palin\n        (fn [n]\n          (cond\n           (= (reverse (str n)) (seq (str n)))  n\n           (= 2 (count (str n))) (let [f (first (str n))\n                                       s (read-string (str f f))]\n                                   (if (> s n) s (next-palin s)))\n           :default\n           (let [ns (str n)\n                 c (count ns)\n                 q (quot c 2)\n                 m (if (even? c)\n                     (subs ns (dec q) (inc q))\n                     (subs ns q (inc q)))\n                 mn (read-string (str (first m)))\n                 mc (inc mn)\n                 sf (subs ns 0\n                          (if (even? c) (dec q) q))\n                 nf (read-string sf)\n                 r (->>\n                    (if (odd? c)\n                      (str sf m (reduce str (reverse sf)))\n                      (str sf (str mn mn) (reduce str (reverse sf))))\n                    read-string)]\n             (if (< r n)\n               (next-palin r)\n               r))))]\n      (let [n (get-first-palin n)]\n        (iterate next-palin n))))", "problem": 150, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn palindrome\n  [n]\n  (letfn [(split-digits [n] (if (< n 10) [n] (conj (split-digits (quot n 10)) (mod n 10))))\n          (put-together [l] (reduce #(+ (* %1 10) %2) 0 l))\n          (next-cand [n]\n            (let [digits (split-digits n)\n                  num-of-digits (count digits)\n                  half-digits (quot num-of-digits 2)\n                  first-half (take half-digits digits)\n                  first-half-inc (split-digits (inc (put-together first-half)))\n                  reverse-first-half (reverse first-half)\n                  reverse-first-num (put-together reverse-first-half)\n                  second-half-num (put-together (take-last half-digits digits))\n                  middle-digit (nth digits half-digits)]\n              (put-together \n               (cond\n                (and (even? num-of-digits) (>= reverse-first-num second-half-num)) (concat first-half reverse-first-half)\n                (and (odd? num-of-digits) (>= reverse-first-num second-half-num)) (concat first-half [middle-digit] reverse-first-half)\n                (even? num-of-digits) (concat first-half-inc (reverse first-half-inc))\n                (and (odd? num-of-digits) (< middle-digit 9)) (concat first-half [(inc middle-digit)] reverse-first-half)\n                :else (concat first-half-inc [0] (reverse first-half-inc))))))]\n    (iterate (comp next-cand inc) (next-cand n))))", "problem": 150, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn palis [n]\n  (letfn [(digs [n]\n\t(loop [n n res '()]\n\t  (if (zero? n)\n\t    res\n\t    (recur (quot n 10) (cons (mod n 10) res)))))\n          (starter [n]\n            (if (pali? n) n\n                (let [dig (digs n)\n                      len (count dig)\n                      h (quot len 2)\n                      mid (when (odd? len) (cons (nth dig h) nil))\n                      l (reverse (take h dig))\n                      r (take-last h dig)\n                      up-first #(cons (inc (first %)) (rest %))\n                      [tmp up] (loop [l (seq l) r (seq r) res [] up nil]\n                                 (if l\n                                   (recur (next l) (next r)\n                                          (conj res (first l)) (if (nil? up)\n                                                                 (if (= (first l) (first r))\n                                                                   nil\n                                                                   (> (first l) (first r)))\n                                                                 up))\n                                   [res up]))\n                      clean-10 #(first (reduce (fn [[c up] nxt] (if (= 10 (+ nxt up))\n                                                                  [(conj c 0) 1]\n                                                                  [(conj c (+ nxt up)) 0]))\n                                               [[] 0] %))\n                      r (clean-10 (if (even? len) (if up tmp (up-first tmp))\n                                      (let [x (concat mid tmp)] (if up x (up-first x)))))]\n                  (->> (concat (reverse r) (if (even? len) r (rest r)))\n                       (map * (iterate #(* % 10) 1))\n                       (apply +)))))\n          (pali? [n]\n            (let [dig (digs n)]\n              (= dig (reverse dig))))\n          (next-pali [n]\n            (let [len (-> n str count)\n                  t (->> (quot len 2) (Math/pow 10) int)\n                  u #(* % 10)\n                  d #(quot % 10)\n                  iter (fn [[a b]] [(u a) (d b)])\n                  ops (->> (iterate iter (if (even? len) [t (d t)] [t t]))\n                           (take-while #(< 0 (second %)))\n                           (mapv (comp (partial apply +) set))\n                           (concat (take-while #(< % n) (iterate u 11)) [2])\n                           sort)]\n              (->> (map (partial + n) ops) (filter pali?) first)))]\n    (iterate next-pali (starter n))))", "problem": 150, "user": "50645e12e4b007509339a58a"}, {"code": "(fn f \n  ([n]\n    (let [ls (apply str (take (quot (inc (count (str n))) 2) (str n)))\n          u (apply * (cons 1 (repeat (count ls) 10)))]\n      (drop-while #(< % n) (f (read-string ls) u (count (str n))))))\n  ([l u c]  \n    (if (odd? c)\n      (lazy-cat \n          (map #(read-string (str % (apply str (rest (reverse (str %)))))) (range l u))\n          (f (/ u 10) u (inc c)))\n      (lazy-cat\n          (map #(read-string (str % (apply str (reverse (str %))))) (range l u))\n          (f u (* 10 u) (inc c))))))", "problem": 150, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [n] ((fn p [side center digit isCenter]\n                   (let [\n                         recenter (= (inc center) 10)\n                         reside (> (count (str (inc side))) digit)\n                         redigit (and recenter isCenter reside)\n                         nval (Long. (str (if (not= 0 digit) side) (if isCenter (str center) \"\") (if (not= 0 digit) (clojure.string/reverse (str side)))))\n                         nside (if (not isCenter) (if reside (apply * 1 (repeat (if redigit digit (dec digit)) 10)) (inc side)) (if (and reside recenter) (apply * 1 (repeat (if redigit digit (dec digit)) 10)) (if recenter (inc side) side)))\n                         ncenter (if (not isCenter) 0 (if recenter 0 (inc center)))\n                         ndigit (if redigit (inc digit) digit)\n                         nisCenter (if (= 0 (rem digit 2))\n                                     (if redigit false (if reside true isCenter))\n                                     (if redigit false (if reside true isCenter))\n                                     )\n                         ]\n                     (if (< nval n)\n\t\t       (p nside ncenter ndigit nisCenter)\n\t\t       (lazy-seq (cons nval (p nside ncenter ndigit nisCenter))))))\n                 (if (< n 10) 0 (Long. (apply str (take (quot (count (str n)) 2) (rest (clojure.string/split (str n) #\"\"))))))\n                 (if (= 1 (rem (count (str n)) 2)) (Long. (str (get (str n) (quot (count (str n)) 2)))) 0)\n                 (quot (count (str n)) 2)\n                 (= 1 (rem (count (str n)) 2))))", "problem": 150, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [low]\n  (let [pow10 (fn [n]\n                (nth (iterate #(* 10 %) 1) n))\n        palindrome (fn [n low]\n                     (let [m (quot (dec n) 2)\n                           st (pow10 m)\n                           lo (if (pos? low)\n                                (bigint (subs (str low) 0 (inc m)))\n                                st)]\n                       (map\n                         (if (even? n)\n                           (fn [x] (bigint (apply str x (reverse (str x)))))\n                           (fn [x] (bigint (apply str x (rest (reverse (str x)))))))\n                         (range lo (* 10 st)))))\n        ndigits (count (str low))\n        bounded (drop-while #(< % low)\n                  (concat\n                    (palindrome ndigits low)\n                    (mapcat #(palindrome % 0) (iterate inc (inc ndigits)))))]\n    (if (zero? low) (cons 0 bounded)\n      bounded)))", "problem": 150, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [n]\n  (letfn [(palindrome? [x]\n            (let [s (str x)]\n              (= s (clojure.string/reverse s))))\n          (next-palindrome [x]\n            (first (filter palindrome? (map #(+ x %) [1 2 10 11 100 110 1000 1100 10000 11000 100000 110000]))))]\n    (->> (iterate inc n)\n         (filter palindrome?)\n         first\n         (iterate next-palindrome))))", "problem": 150, "user": "510db6cde4b078ea71921145"}, {"code": "#_(Math/log10 and Math/pow is much slower than integer recur or loop !!!)\n\n(fn [x] #_(for 12321 create lazy function (f 123 0 1000))\n(let [   n  ((fn [a b]\n                  (if (zero? a) b\n                    (recur (quot a 10) (inc b)))) x 0)\n         a3  (if (zero? x) 1 (reduce * (repeat (quot (inc n) 2) 10)))\n         a2  (if (zero? x) 1 (if (even? n) 1 0))\n         a1  (if (zero? x) 0 (quot x (reduce * (repeat (quot n 2) 10)))) ]\n(drop-while (partial > x)\n(let [   r   #((fn [a b]\n                (if (zero? a) b \n                    (recur (quot a 10) (+ ( * 10 b) (mod a 10))))) % 0 )\n         k    (fn [a b np]\n                (let [x   (if (even? b) 10 1)]\n                  (+ ( * a (/ np x) ) (r (quot a x)))))     ]\n((fn f [p q np]\n    (cons (k p q np)\n      (lazy-seq (if (= (inc p) np)\n                    (if (even? q)\n                        (f (/ np 10) (inc q) np)\n                        (f (inc p) (inc q) ( * np 10)))\n                    (f (inc p) q np))))) a1 a2 a3 )))))\n\n\n#_(fn [c]\n (let [ f (fn [m]\n            (let [n   (if (= m 1) 0\n                          ((fn [a b]\n                            (if (zero? a) b\n                                (recur (quot a 10) (inc b)))) (quot m 2) -1))\n                  np  (reduce * (repeat n 10))   \n                  nnp ( * 10 np) \n                  [x y] (if (< m (+ np nnp)) [(- m np) 0] [(- m nnp) 1]) ]             \n              (+ ( * x np (if (zero? y) 1 10)) \n                 ( (fn [a b]\n                      (if  (zero? a) b \n                           (recur (quot a 10) (+ ( * 10 b) (mod a 10)))))\n                    (quot x (if (zero? y) 10 1) ) 0)) ))\n        x (let [n (-> c (max 1) Math/log10 int inc (/ 2) int)\n              m (reduce * (repeat n 10))\n              q (+ (int (/ c m)) m)]\n              (if (< (f q) c) (inc q) q))   ]       \n  ((fn k [qw] \n      (cons (f qw)\n       (lazy-seq (k (inc qw))))) x)))", "problem": 150, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn [n]\n (letfn [\n  (p-it ;\"Take the number n and turn it into a palindrome with an expected target of charCount chars.\n        ;An odd character count target implies that the LSD of n should not be repeated.\n        ;The palindrome will not necessarily turn out to be charCount characters.\"\n        [n charCount]\n    (let [front (str n)\n          start (if (even? charCount) 0 1)\n          back (subs (clojure.string/reverse front) start (count front))]\n      (str front back)))\n  \n  (pal-seq ;\"Produce a lazy sequence of palindromes which start with n and have charCount\n           ;characters. If p-it produces a palindrome that is not charCount chars, then we\n           ;need to increment our character count and possibly adjust n to continue the sequence.\"\n           [n charCount]\n    (let [ans (p-it n charCount)\n          noDigitIncrease (= charCount (count ans))\n          actual (if noDigitIncrease\n                   (list n charCount)\n                   (list (if (even? charCount) n (quot n 10)) (inc charCount)))]\n      (lazy-seq\n        (cons\n          (read-string\n            (if noDigitIncrease\n              ans\n              (p-it (first actual) (last actual))))\n          (pal-seq (inc (first actual)) (last actual))))))]\n  \n  ;Figure out the starting front-half number that will produce palindromes larger than our starting 'n'.\n  (let [nstring (str n)\n        nchars (count nstring)\n        front (subs nstring 0 (quot (inc nchars) 2))\n        frontn (read-string front)\n        firstans (p-it frontn nchars)\n        firstFrontN (if (< (read-string firstans) n) (inc frontn) frontn)]\n    (pal-seq firstFrontN nchars))))", "problem": 150, "user": "525372ade4b0541d1855b8f3"}, {"code": "(fn [n]\n  (let\n    [ls (iterate\n          (fn [n]\n            (if (every? #(= \\9 %) (str n)) (+ n 2)\n              (let\n                [strn (str n)\n                 front (+ (if (= strn (apply str (reverse strn))) 1 0)\n                          (Integer/parseInt (apply str (take (int (/ (inc (count strn)) 2)) strn))))\n                 back (if (zero? (mod (count strn) 2))\n                        (apply str (reverse (str front)))\n                        (apply str (rest (reverse (str front)))))]\n                (Integer/parseInt (str front back)))))\n          n)]\n    ((if (= (str n) (apply str (reverse (str n)))) identity rest)\n       (remove #(< % n) ls))))", "problem": 150, "user": "51e00020e4b01188f0627534"}, {"code": "(let [f (fn [n]\n          (let [s (str n) l (count s)\n                a (subs s 0 (Math/ceil (/ l 2)))\n                b (str (inc (read-string a)))]\n            (first\n              (filter #(>= % n)\n                (map\n                  #(read-string\n                     (str\n                       %\n                       (subs (clojure.string/reverse %) (if (odd? l) 1 0))))\n                  [a b])))))]\n  #(iterate (comp f inc) (f %)))", "problem": 150, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn soln [n]\n  (letfn [(half [n]\n            (-> n (/ 2) Math/ceil))\n          (palindrome? [n]\n            (= (str n) (apply str (reverse (str n)))))\n          (nearest-palindrome [n]\n            (first (filter palindrome? (iterate inc n))))]\n\n    (iterate\n     (fn next-palindrome [palindrome]\n       (let [string (str palindrome)\n             n-chars (count string)\n             prefix (apply str (take (half n-chars) string))]\n         (if (every? #{\\9} string)\n           (+ 2 palindrome)\n           (let [prefix (-> prefix Long/parseLong inc str)]\n             (Long/parseLong (apply str prefix (if (odd? n-chars)\n                                                 (rest (reverse prefix))\n                                                 (reverse prefix))))))))\n     (nearest-palindrome n))))", "problem": 150, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn palindroms [start]\n  (let [\n         pal-type-1 (fn [s] (->> s (reverse) (rest) (apply str)))\n         pal-type-2 (fn [s] (->> s (reverse) (apply str)))\n         make-palindrome\n         (fn [x f]\n           (let [s (str x)\n                 m (f s)\n                 res (str s m)]\n             (Long/parseLong res)\n             )\n           )\n         m {true pal-type-1 false pal-type-2}\n         ten-pows (iterate #(* 10 %) 1)\n         next-palindrome\n         (fn next-palindrome [i [start bound & all :as pows] odd]\n           (if (< i bound)\n             (lazy-seq (cons (make-palindrome i (m odd)) (next-palindrome (inc i) pows odd)))\n             (if odd\n               (next-palindrome start pows false)\n               (next-palindrome bound (rest pows) true) \n               )\n             ))\n         left-core\n         (fn [start]\n           (let [s (str start) len (count s) half (int (/ (inc len) 2))]\n             (->> s (take half) (apply str) (Integer/parseInt))))\n         ]\n    (drop-while\n      #(< % start)\n      (next-palindrome (left-core start) (drop-while #(> (quot start 10) %) ten-pows) (odd? (count (str start)))))\n    ))", "problem": 150, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [n]\n  (letfn [(l [s] (count s))\n          (h [s] (quot (inc (l s)) 2))\n          (e? [m] (= 0 (rem (l m) 2)))\n          (p [a] (read-string (subs a 0 (h a))))\n          (x [a d]\n             (let [b (h a)\n                   f (> (l d) b)\n                   y (if (not= b (quot (+ 2 (l a)) 2)) (inc b) b)\n                   e (if f (subs d 0 y) d)\n                   z (if f (not (e? a)) (e? a))\n                   g #(read-string (str % (clojure.string/reverse %2)))\n                   h #(g (subs % 0 (dec (l %))) %)\n                   i #(g % %)\n                   ]\n               (if z [(i e) d] [(h e) d])\n               ))\n          (y [a] (str (p a)))\n          (z [a] (str (inc (p a))))]\n    (drop-while #(< % n) (map first (iterate #(x (str (first %)) (z (str (first %)))) (x (str n) (y (str n))))))\n    ))", "problem": 150, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn _ [n]\n  (if (< n 10) (cons n (lazy-seq (_ (inc n))))\n     (letfn [(find_p [n](let [s (str n) len (count s) sp-ind (if (even? len) (quot len 2) (inc (quot len 2)))\n      prefix_str (apply str (first (split-at sp-ind s))) prefix_int (BigInteger. prefix_str)\n      p_str (apply str (if (even? len) (concat prefix_str (reverse prefix_str))(concat prefix_str (rest (reverse prefix_str)))))\n      p_int (BigInteger. p_str) seed (BigInteger. (apply str (concat (str (inc prefix_int)) (repeat (- len (count prefix_str)) \\0))))\n      ](if (< p_int n) [nil  seed][p_int seed])))]\n        (let [[p_int seed] (find_p n)]\n          (if (nil? p_int)\n             (concat []  (lazy-seq (_ seed)))\n             (cons p_int (lazy-seq (_ seed)))\n          )\n        )\n      )\n  )\n)", "problem": 150, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn pal [start]\n  (let [pal? (fn [n]\n               (let [dig (if (coll? n) n (str n))\n                     mid (Math/ceil (/ (count dig) 2))]\n                 (= (take mid dig) (take mid (reverse dig)))))\n        ; Convert a collection of numbers to a single integer.\n        toInt (fn [coll]\n                (loop [acc 0\n                       scale 1\n                       [n & ums :as nums] coll]\n                  (if (empty? nums)\n                    acc\n                    (recur (+ acc (* scale n)) (* scale 10) ums)\n                    )))\n        ; Construct a palindrome from the unique half, with final length n.\n        make-pal (fn [part n]\n                   (if (even? n)\n                     (toInt (concat (reverse part) part))\n                     (toInt (concat (reverse part) (rest part)))))\n        ; Find the next number that's a palindrome.\n        next-pal (fn [p]\n                   (let [dig (map #(- (int %) (int \\0)) (str p))\n                         n (count dig)]\n                     (loop [acc []\n                            [s & e :as seed] (drop (int (/ n 2))\n                                                   (reverse dig))]\n                       (if (empty? seed)\n                         (make-pal acc n)\n                         (if (= s 9)\n                           (if (empty? e)\n                             ; At the end, use 1 instead of 0 and\n                             ; prefix with 0 if going from even to odd.\n                             (if (even? n)\n                               (make-pal (concat [0] acc [1]) (inc n))\n                               (make-pal (conj acc 1) (inc n))\n                               )\n                             (recur (conj acc 0) e)\n                             )\n                           (make-pal (concat acc (cons (inc s) e)) n)\n                           )\n                         )\n                       )\n                     )\n                   )\n        ; The first palindrome.\n        s (if (pal? start)\n            start\n            (let [dig (map #(- (int %) (int \\0)) (str start))\n                  part (take (int (/ (count dig) 2)) dig)\n                  x (make-pal (reverse part) (count dig))]\n              (if (>= x start)\n                x\n                (next-pal start)\n                )\n              ))]\n    (cons s (lazy-seq (pal (next-pal s))))\n    )\n  )", "problem": 150, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [n]\n    (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n            (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n            (next-pal [n]\n                      (let [N (decode n)\n                            l (count N)\n                            d (quot l 2)\n                            H (take d N)\n                            H1 (decode (inc (encode H)))\n                            Hr (reverse H)\n                            h (encode Hr)\n                            p (nth N d)\n                            t (encode (take-last d N))]\n                        (encode (cond\n                                 (and (even? l) (>= h t)) (concat H Hr)\n                                 (and (odd? l) (>= h t)) (concat H [p] Hr)\n                                 (even? l) (concat H1 (reverse H1))\n                                 (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                                 :else (concat H1 [0] (reverse H1))))))]\n      (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn palindrome-seq [start-n]\n\t(letfn [\n\t\t\t(seq-to-str [a-seq]\n\t\t\t\t(apply str a-seq)\n\t\t\t)\n\t\t\t(palindrome? [n] (= (str n) (seq-to-str (reverse (str n)))))\n\t\t\t\t\t\t(to-int [ch]\n\t\t\t\t(BigInteger. (str ch))\n\t\t\t)\n\t\t\t(left-smaller? [left-str right-str]\n\t\t\t\t(or (= left-str right-str)\n\t\t\t\t\t(<= (to-int (seq-to-str (reverse left-str))) (to-int right-str))\n\t\t\t\t)\t\t\n\t\t\t)\n\t\t\t(find-next-half [left-str carry-over]\n\t\t\t\t(let [big (BigInteger. left-str) \n\t\t\t\t\t  res (+' big carry-over)\n\t\t\t\t\t  res-str (str res)]\n\t\t\t\t\t  res-str\n\t\t\t\t)\n\t\t\t)\n\t\t\t(all-nines? [n]\n\t\t\t\t(= #{\\9} (set (seq (str n))))\n\t\t\t)\n\t\t\t(form-palindrome \n\t\t\t\t([prefix] (BigInteger. (seq-to-str (concat prefix (reverse prefix)))))\n\t\t\t\t([prefix mid] (BigInteger. (seq-to-str (concat prefix mid (reverse prefix)))))\n\t\t\t)\n\t\t\t(find-next-palindrome [n]\n\t\t\t\t(if (all-nines? n)\n\t\t\t\t\t(let [str-n (str n) \n\t\t\t\t\t\tlen (count str-n)]\n\t\t\t\t\t\t(BigInteger. (seq-to-str (concat '(\\1) (repeat (dec len) \\0) '(\\1))))\n\t\t\t\t\t)\n\t\t\t\t\t(let [str-n (str n) \n\t\t\t\t\t\tlen (count str-n)\n\t\t\t\t\t\thalf (quot len 2)\n\t\t\t\t\t\tleft-str (subs str-n 0 half)\n\t\t\t\t\t\tright-str (subs str-n (- len half))\n\t\t\t\t\t\tmid-str (subs str-n half (- len half))\n\t\t\t\t\t\t]\n\t\t\t\t\t\t\t(if (not (left-smaller? left-str right-str))\n\t\t\t\t\t\t\t\t(if (= \"\" mid-str)\n\t\t\t\t\t\t\t\t\t(form-palindrome left-str)\n\t\t\t\t\t\t\t\t\t(form-palindrome left-str mid-str)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t; left is smaller or equal to right\n\t\t\t\t\t\t\t\t(if (= \"\" mid-str)\n\t\t\t\t\t\t\t\t\t(let [next-left (find-next-half left-str 1)]\n\t\t\t\t\t\t\t\t\t\t(if (= (count next-left) (count left-str))\n\t\t\t\t\t\t\t\t\t\t\t(form-palindrome next-left)\n\t\t\t\t\t\t\t\t\t\t\t;TODO check whether this branch is required\n\t\t\t\t\t\t\t\t\t\t\t(form-palindrome (subs next-left 0 (dec (count next-left))) (str (last next-left)))\n\t\t\t\t\t\t\t\t\t\t)\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t)\t\t\n\t\t\t\t\t\t\t\t;mid-str is present\n\t\t\t\t\t\t\t\t(if (= left-str right-str)\n\t\t\t\t\t\t\t\t\t(let [next-mid (inc (to-int mid-str))]\n\t\t\t\t\t\t\t\t\t\t(if (<= next-mid 9)\n\t\t\t\t\t\t\t\t\t\t\t(form-palindrome left-str (str next-mid))\n\t\t\t\t\t\t\t\t\t\t\t(let [new-left (find-next-half left-str 1)]\n\t\t\t\t\t\t\t\t\t\t\t\t(if (> (count new-left) (count left-str))\n\t\t\t\t\t\t\t\t\t\t\t\t\t(form-palindrome new-left)\n\t\t\t\t\t\t\t\t\t\t\t\t\t(form-palindrome new-left \"0\")\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\t\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t;left-str != right-str - todo - add-test\n\t\t\t\t\t\t\t\t\t(let [next-mid (inc (to-int mid-str)) carry (if (<= next-mid 9) 0 1) m-str (if (<= next-mid 9) (str next-mid) \"0\") next-left (find-next-half left-str carry)]\n\t\t\t\t\t\t\t\t\t\t(form-palindrome next-left m-str)\t\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t]\n\t\t\t(let [next-palindrome (if (palindrome? start-n) start-n (find-next-palindrome start-n))]\n\t\t\t\t(cons next-palindrome (lazy-seq (palindrome-seq (find-next-palindrome next-palindrome))))\n\t\t\t)\n\t)\n)", "problem": 150, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn __ [n]\n  (letfn [(palindromic? [n]\n            (let [s (.toString n)\n                  take-half (fn [coll] (take (int (/ (count coll) 2)) coll))]\n              (= (take-half s) (take-half (reverse s)))))\n          (log-10 [n]\n            (loop [out -1 in n]\n              (if (zero? in)\n                  out\n                  (recur (inc out) (quot in 10)))))\n          (pow-10 [n]\n            (loop [out 1 e n]\n              (if (zero? e)\n                  out\n                  (recur (* 10 out) (dec e)))))\n          (take-half [n]\n            (let [l-10 (log-10 n)\n                  f (if (even? l-10) int #(inc (int %)))]\n              (bigint (/ n (pow-10 (f (/ l-10 2)))))))\n          (reverse-integer [n]\n            (loop [out 0 in n]\n              (if (zero? in)\n                  out\n                  (recur (+' (*' 10 out) (mod in 10)) (quot in 10)))))\n          (mirror [n parity]\n            (if (odd? parity)\n                (+ (* n (pow-10 (log-10 n))) (reverse-integer (quot n 10)))\n                (+ (* n (pow-10 (inc (log-10 n)))) (reverse-integer n))))\n          (next-palindromic [n]\n            (let [l-10 (log-10 n)\n                  parity (dec l-10)\n                  left-half (take-half n)]\n              (cond\n                (not (palindromic? n))\n                  (let [right-half (take-half (reverse-integer n))]\n                    (if (> right-half left-half)\n                        (mirror (inc left-half) parity)\n                        (mirror left-half parity)))\n                (not= l-10 (log-10 (inc n)))\n                  (if (even? parity)\n                      (mirror (inc left-half) 1)\n                      (mirror (quot (inc left-half) 10) 0))\n                :else\n                  (mirror (inc left-half) parity))))\n          (make-seq [n]\n            (lazy-seq (cons n (make-seq (next-palindromic n)))))]\n    (if (palindromic? n)\n        (make-seq n)\n        (make-seq (next-palindromic n)))))", "problem": 150, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "problem": 150, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn pn\n    [n]\n    (let [rs #(read-string (apply str %))\n          rf #(let [s (str %)] (read-string (apply str (concat s (reverse s)))))\n          symm #(even? (count (str %)))\n          sp #(split-at (int (/ (count (str %)) 2)) (str %))\n          fpn (cond\n               (< n 10) n\n               (< n 100) (->> n str sort second (repeat 2) (apply str) read-string)\n               :else (let [[h t] (sp n)\n                           [h mm t] (if-not (symm n)\n                                      [h [(first t)] (-> t next reverse)]\n                                      [(butlast h)\n                                       [(char (max (-> h last int) (-> t first int)))]\n                                       (-> t next reverse)])\n                           [a b c] (map rs [h mm t])\n                           pn (cond\n                               (= a c) (if-not (symm n) n (rs (concat h mm mm t)))\n                               (< a c) (if (symm n) (rf (inc a)) (if (= 9 b)\n                                                               (let [ih (str (inc a))]\n                                                                 (rs (concat ih [\\0] (reverse ih))))\n                                                               (rs (concat h (str (inc b)) (reverse h)))))\n                               :else (rs (concat h (when (symm n) mm) mm (reverse h))))]\n                       pn))\n          g (fn g [n]\n              (lazy-seq\n               (let [nn (cond\n                        (< n 9) (inc n)\n                        (= n 9) 11\n                        (< n 99) (+ 11 n)\n                        (= n 99) 101\n                        :else (let [h (-> (sp n) second reverse)\n                                    h' (inc (rs h))\n                                    sh' (str h')]\n                                (if (= (count sh') (count h))\n                                  (rs (concat sh' (reverse (if (symm n) sh' (butlast sh')))))\n                                  (rs (concat sh' (->> sh' reverse (drop (if (odd? (count (str n)))\n                                                                           2 1))))))))]\n                 (cons n (g nn)))))]\n      (g fpn)))", "problem": 150, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn list-palindromics-not-less-than[n]\n  (letfn [\n   (to-int\n     ([v] (if (empty? v) 0 (reduce #(+ %2 (* % 10)) v))))\n          \n   (to-vec[x]\n     (if (< x 10) [x] (conj (to-vec (quot x 10)) (rem x 10)))) \n          \n   (nearest-palindromic[x]\n     (let [vx (to-vec x)\n\t       vcount (count vx)\n\t\t   repeated-center (even? vcount)\n           rcpush (if repeated-center 1 0)\n\t       extremities (vec (reverse (take (- (quot vcount 2) rcpush) vx)))\n\t       center (get vx (quot vcount 2))\n\t       rpx [repeated-center center extremities]\n           px (apply create-palindromic rpx)]\n\t\t   \n\t   (if (>= px x)\n   \t      rpx\n \t     (apply increment-palindromic rpx))))\n\t   \n\t\t\t\t\t\t\t\t\t\t\n\t\t  \n   (create-palindromic\n     [repeated-center center extremities]\n     (let [right-number (to-int extremities)\n           left-number  (to-int (reverse extremities))\n           push (int (Math/pow 10 (count extremities)))]\n\t\t   \n       (+ right-number\n          (* push (if repeated-center (to-int (repeat 2 center))\n  \t\t                               center))\n          (* push (if repeated-center 100 10) left-number))))\n          \n   (increment-palindromic [repeated-center center extremities]\n    (if (< center 9)\n      [repeated-center\n\t  (inc center)\n\t  extremities]\n\t  \n\t  (if (and (empty? extremities)\n          \t   (not repeated-center)) [true 1 []]\n\t\t\t   \n      (if (every? #(= % 9) extremities)\n        (if repeated-center\n           [false  0 (conj (vec (for [x extremities] 0)) 1)]\n\t\t   [true   0 (for [x (range (count extremities))]\n        \t\t         (if (= x (dec (count extremities))) 1 0))])\n\t\t\t\n        [repeated-center\n\t\t0\n\t\t(->> extremities\n \t\t  (reverse)\n\t\t  (to-int)\n\t\t  (inc)\n\t\t  (to-vec)\n\t\t  (reverse))]))))\n\n    (list-all-palindromics-starting-from[curr]\n      (cons (apply create-palindromic curr)\n            (lazy-seq\n              (list-all-palindromics-starting-from\n                (apply increment-palindromic curr)))))] ; end of letfn\n\t\t  \n\t(let [first-palindromic (nearest-palindromic n)]\n\t  (list-all-palindromics-starting-from first-palindromic))))", "problem": 150, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn [n] (letfn [\n(digits [n]\n\t(letfn [\n\t\t(digits- [n]\n\t\t\t(if\n\t\t\t\t(zero? n)\n\t\t\t\t[]\n\t\t\t\t(cons\n\t\t\t\t\t(rem n 10)\n\t\t\t\t\t(lazy-seq (digits- (quot n 10))))\n\t\t\t)\n\t\t)]\n\t\t(if\n\t\t\t(zero? n)\n\t\t\t[0]\n\t\t\t(reverse (digits- n))\n\t\t)\n\t)\n)\n(palindromic? [n]\n\t(cond\n\t\t(number? n)\n\t\t(palindromic? (digits n))\n\t\t(sequential? n)\n\t\t(= n (reverse n))\n\t)\n)\n(number-from-digits [ds]\n\t(letfn [\n\t\t(number-from-digits- [ds]\n\t\t\t(if\n\t\t\t\t(empty? ds)\n\t\t\t\t0\n\t\t\t\t(+ (first ds)\n\t\t\t\t   (* 10 (number-from-digits- (rest ds)))\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n\t\t(number-from-digits- (reverse ds))\n\t)\n)\n(increasing-part [n]\n\t(number-from-digits (take (quot (inc (count (digits n))) 2) (digits n)))\n)\n(head-part [n]\n\t(number-from-digits (take (max 1 (quot (count (digits n)) 2)) (digits n)))\n)\n(tail-part [n]\n\t(number-from-digits (take-last (max 1 (quot (count (digits n)) 2)) (digits n)))\n)\n(reverse-number [n] (number-from-digits (reverse (digits n))))\n(make-odd-palindrome [n]\n\t(number-from-digits (concat (digits n) (rest (reverse (digits n)))))\n)\n(make-even-palindrome [n]\n\t(number-from-digits (concat (digits n) (reverse (digits n))))\n)\n(all-nines? [n] (every? #(= 9 %) (digits n)))\n(next-palindrome [n]\n\t(if (palindromic? n)\n\t\t(cond\n\t\t\t(all-nines? n)\n\t\t\t(+ n 2)\n\t\t\t(odd? (count (digits n)))\n\t\t\t(make-odd-palindrome (inc (increasing-part n)))\n\t\t\t(even? (count (digits n)))\n\t\t\t(make-even-palindrome (inc (increasing-part n)))\n\t\t)\n\t\t(if\n\t\t\t(> (reverse-number (head-part n)) (tail-part n))\n\t\t\t(if (odd? (count (digits n)))\n\t\t\t\t(make-odd-palindrome (increasing-part n))\n\t\t\t\t(make-even-palindrome (increasing-part n))\n\t\t\t)\n\t\t\t(if (odd? (count (digits n)))\n\t\t\t\t(make-odd-palindrome (inc (increasing-part n)))\n\t\t\t\t(make-even-palindrome (inc (increasing-part n)))\n\t\t\t)\n\t\t)\n\t)\n)\n(palindromes-from [n]\n\t(if (palindromic? n)\n\t\t(iterate next-palindrome n)\n\t\t(iterate next-palindrome (next-palindrome n))\n\t)\n)\n] (palindromes-from n)))", "problem": 150, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn palindrome-sequence [start]\n  (letfn [(xor [a b]\n            (or (and a (not b))\n                (and b (not a))))\n          (count-digits [n]\n            (count (str n)))\n          (halve [n]\n            (-> n\n                str\n                (.substring 0 (quot (inc (count-digits n)) 2))\n                bigint))\n          (mirror [n merge-middle?]\n            (let [image (reverse (str n))]\n              (apply str (if merge-middle?\n                           (rest image)\n                           image))))\n          (palindromize [n merge-middle?]\n            (bigint (str n\n                         (mirror n merge-middle?))))\n\n          (merge? [number]\n            (odd? (count-digits number)))\n\n          (boundary? [number]\n            (let [n (halve number)\n                  nn (inc n)]\n              (not= (count-digits n)\n                    (count-digits nn))))\n\n          (merge-middle? [number]\n            (xor (merge? number)\n                 (boundary? number)))\n\n          (next-palindrome [number]\n            (let [n (halve number)\n                  nn (inc n)\n                  m? (merge? number)\n                  mm? (merge-middle? number)\n                  b? (boundary? number)\n                  next-half (if (and b? m?)\n                              (quot (inc nn) 10)\n                              nn)]\n              (palindromize next-half\n                            mm?)))]\n    (let [simple (palindromize (halve start)\n                               (merge? start))\n          np (next-palindrome start)]\n      (if (>= simple start)\n        (iterate next-palindrome (min simple np))\n        (iterate next-palindrome np)))))", "problem": 150, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn _palindromic_number\n  [x]\n  (let [number-to-seq (fn [x] (map read-string (-> x str (clojure.string/split #\"\") next)))\n        seq-to-number (fn [xs] (-> \"\" (clojure.string/join xs) read-string))\n        make-palindrom (fn [len half] (concat half (if (even? len) (reverse half) (next (reverse half)))))\n        xs (number-to-seq x)\n        len (count xs)\n        xs-half (take (/ len 2) xs)\n        xs-next-half (number-to-seq (inc (seq-to-number xs-half)))\n        xs-palindrom (seq-to-number (make-palindrom len xs-half))\n        xs-next-palindrom (seq-to-number (make-palindrom len xs-next-half))\n        result (if (>= xs-palindrom x) xs-palindrom xs-next-palindrom)]\n  (cons result (lazy-seq (_palindromic_number (inc result))))))", "problem": 150, "user": "531490bde4b08068f379ed17"}, {"code": "(fn main[n]\n  (letfn [(pow10 [n]\n            (if (zero? n) 1\n                (* 10 (pow10 (dec n)))))\n          (to-digit-ls\n            ([n] (to-digit-ls n '()))\n            ([n acc] (if (zero? (quot n 10))\n                       (conj acc n)\n                       (recur (quot n 10) (conj acc (rem n 10))))))          \n          (to-digit [ls]\n            (reduce + (keep-indexed (fn[index val] (* val (pow10 (- (dec (count ls)) index)))) ls)))\n          (increment-ls [[a b c :as ls]]\n            (cond (nil? ls) '(1)\n                  (< (last ls) 9)\n                  (concat (butlast ls) `(~(inc (last ls))))\n                  :else (concat (increment-ls (butlast ls)) '(0))))\n          (pld [[a b c :as ls]]\n            (let [lsdigit (last ls)\n                  msdigit a\n                  middle-ls (drop 1 (drop-last ls))]\n              (cond (nil? b) ls\n                    (and (nil? c) (>= msdigit lsdigit)) `(~msdigit ~msdigit)\n                    (and (nil? c) (< msdigit lsdigit)) `( ~(inc msdigit) ~(inc msdigit))\n                    (>= msdigit lsdigit)\n                    (concat `(~msdigit) (pld middle-ls) `(~msdigit))\n                 :else\n                 (let [increment-middle-ls (increment-ls middle-ls)\n                       larger? (> (count increment-middle-ls) (count middle-ls))]\n                   (if larger?\n                     (concat `(~(inc msdigit)) (pld (drop 1 increment-middle-ls)) `(~(inc msdigit)))\n                     (concat `(~msdigit) (pld increment-middle-ls) `(~msdigit)))))))]\n    (let [next-pld (to-digit (pld (to-digit-ls n)))]\n      (lazy-seq (cons next-pld (main (inc next-pld)))))))", "problem": 150, "user": "5301157ae4b0d8b024fd3717"}, {"code": "#(letfn\n   [(p [x y]\n       (let [a (str x)\n             a (if (every? #{\\9} a) (str \"0\" a) a)\n             b (count a)\n             c (if (even? b) (/ b 2) (/ (inc b) 2))\n             d (subs a 0 c)\n             e (str (max 0 (y (Long. d))))\n             f (if (even? b) e (subs e 0 (dec c)))\n             g (clojure.string/reverse f)]\n         (Long. (str e g))))]\n   (drop-while (fn [x] (< x %)) \n               (iterate (fn [x] (p x inc)) (p % dec))))", "problem": 150, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [n]\n  (letfn [(digits [n]\n            (reverse (map #(mod % 10) (take-while pos? (iterate #(quot %1 10) n)))))\n          (maken [ds]\n            (reduce + (map #(* %1 %2) (reverse ds) (iterate (partial * 10) 1))))\n          (ispd [n]\n            (= (digits n) (reverse (digits n))))\n          (findpd [n incf] \n            (let [dsn (digits n) \n                  c (count dsn)\n                  c1 (quot (inc c) 2)\n                  ds1 (take c1 dsn)\n                  n1 (maken ds1)\n                  n1' (incf n1)\n                  ds1' (digits n1')\n                  ds' (concat (take c1 ds1') (drop (if (odd? c) 1 0) (reverse ds1')))\n                  ]\n              (maken ds')))\n          (nextpd [n] (findpd n inc))\n          (prevpd [n]  (findpd n dec))] \n    (drop-while (partial > n) (iterate nextpd (prevpd n)))\n    ))", "problem": 150, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [n]\n  (letfn\n    [\n      (mid [n] (apply * (repeat (quot (count (str n)) 2) 10)))\n      (top [n] (* (quot n (mid n)) (mid n)))\n      (bot [n] (quot n (mid (* n 10))))      \n      (pal [n] (+ (top n) (Integer/parseInt (clojure.string/reverse (str (bot n))))))\n      (nxt [n] (pal (+ (top n) (mid n))))\n      (ini [n] (if (>= (pal n) n) (pal n) (nxt n)))\n    ] \n    (iterate nxt (ini n))  \n  )\n)", "problem": 150, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn palis [n]\n  (letfn [(digits [n]\n                  (loop [c n res ()]\n                    (if (< c 10)\n                      (conj res c)\n                      (recur (quot c 10) (conj res (rem c 10))))))\n          (from-digits [coll]\n                       (reduce #(+ (* 10 %1) %2) coll))\n          (next-lex [v]\n                    (if (seq v)\n                      (let [l (peek v)]\n                        (if (= l 9)\n                          (conj (next-lex (pop v)) 0 )\n                          (conj (pop v) (inc l))))\n                      [1]))\n          (larger-half [coll]\n                       (let [n (count coll)]\n                         (vec (take (+ (quot n 2) (rem n 2)) coll))))\n          (stitch-pali [left-side even]\n                       (if even\n                         (apply conj left-side (reverse left-side))\n                         (let [mid (peek left-side)\n                               others (pop left-side)]\n                           (apply conj others mid (reverse others)))))\n          (next-pali [pali]\n                     (let [n (count pali)\n                           left (larger-half pali)\n                           next-left (next-lex left)]\n                       (if (> (count next-left) (count left))\n                         (if (even? n)\n                           (stitch-pali next-left false)\n                           (stitch-pali (pop next-left) true))\n                         (stitch-pali next-left (even? n)))))\n          (palify [coll]\n                  (stitch-pali (larger-half coll) (even? (count coll))))]\n    (->> n\n         digits\n         palify\n         (iterate next-pali)\n         (map from-digits)\n         (drop-while #(< % n)))))", "problem": 150, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn palindromic-num [num]\n  (letfn [(reverse-digit [num result]\n            (if\n              (zero? (quot num 10))\n              (+ (mod num 10) (* result 10))\n              (reverse-digit (quot num 10) (+ (mod num 10) (* result 10)))))\n          (palindromic-in-i-digit [low up]\n            (lazy-cat\n              (lazy-cat\n                (map #(if (< % 10) % (reverse-digit (quot % 10) %)) (range low up))\n                (drop-while\n                  zero?\n                  (map #(reverse-digit % %) (range low up))))\n              (palindromic-in-i-digit up (* up 10))))]\n    (filter #(>= % num) (let [len (count (.toString num))\n                              digit (quot len 2)\n                              low (quot num (apply * (repeat digit 10N)))\n                              up (apply * (repeat (count (.toString low)) 10N))]\n                          (palindromic-in-i-digit low up)))))", "problem": 150, "user": "50436470e4b034ff00315d23"}, {"code": "(letfn [(digits [n] (if (< n 10) [n] (conj (digits (quot n 10)) (rem n 10))))\n        (dig->int [xs] (reduce #(+ (* % 10) %2) 0 xs))\n        (next-pal [num]\n                  (let [D (digits num)\n                        ;; determine how to split digits\n                        r (rem (count D) 2)\n                        q (quot (count D) 2)\n                        ;; dividing digits for logic\n                        FD  (subvec D 0 q)\n                        ctr (subvec D q (+ r q))\n                        BD  (subvec D (+ r q))\n                        ;; these numbers drive the logic\n                        H  (dig->int (reverse (concat FD ctr)))\n                        T  (dig->int (concat ctr BD))]\n                    (if (>= H T)\n                      (dig->int (concat FD ctr (reverse FD)))\n                      (let [nF (inc (dig->int (concat FD ctr)))\n                      nFD (digits nF)]\n                  (dig->int (concat nFD (drop r (rseq nFD))))))))]\n\n  #(iterate (comp next-pal inc) (next-pal %)))", "problem": 150, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [x]\n  (letfn [(make-palin [x]\n                      (let [d (digits x)]\n                        (palin-from-front (front x d) (even? d))))\n          (digits [x]\n                  (loop [i 0 n x]\n                    (if (= n 0)\n                      i\n                      (recur (inc i) (quot n 10)))))\n          (front [x d]\n                 (quot x (apply * (repeat (quot d 2) 10))))\n          (palin-from-front [x even]\n                            (loop [r x n (if even x (quot x 10))]\n                              (if (= n 0)\n                                r\n                                (recur (+ (* r 10) (mod n 10)) (quot n 10)))))\n          (inc-palin [x]\n                      (if (all-9 x)\n                        (+ 2 x)\n                        (let [d (digits x)]\n                          (palin-from-front (inc (front x d)) (even? d)))))\n          (all-9 [x]\n                  (if (= 9 x)\n                    true\n                    (if (not= 9 (mod x 10))\n                      false\n                      (recur (quot x 10)))))\n          (infp [x]\n                  (if (zero? x) \n                    (cons 0 (infp 1))\n                    (cons x (lazy-seq (infp (inc-palin x))))))\n          \n          ]\n    (drop-while #(< % x) (infp (make-palin x)))\n  \n ))", "problem": 150, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn [n]\n  (let [s (str n)\n        next-pal (fn [n]\n                   (let [digits (fn [n] (loop [x n l ()] (if (zero? x) (vec l) (recur (quot x 10) (cons (rem x 10) l)))))\n                         digits-to-int (fn [v] (loop [u v k 0] (if (empty? u) k (recur (rest u) (+ (* k 10) (first u))))))\n                         v (if (zero? n) [0] (digits n))\n                         c (count v)]\n                     (cond\n                       (apply = (conj v 9)) (+ n 2)\n                       (= c 1) (inc n)\n                       :else (let [q (quot c 2)\n                                   r (rem c 2)\n                                   left (subvec v 0 q)\n                                   middle (subvec v q (+ q r))\n                                   right (subvec v (+ q r))\n                                   left-reversed (rseq left)]\n                               (if (> (digits-to-int left-reversed) (digits-to-int right))\n                                 (digits-to-int (concat left middle left-reversed))\n                                 (let [v1 (digits (inc (digits-to-int (concat left middle))))]\n                                   (if (zero? r)\n                                     (digits-to-int (concat v1 (rseq v1)))\n                                     (digits-to-int (concat v1 (rest (rseq v1)))))))))))]\n    (if (= (seq s) (reverse s))\n                     (iterate next-pal n)\n                     (iterate next-pal (next-pal n)))))", "problem": 150, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [x]\n  (let [tp #(int (Math/pow 10 %))\n        w (count (str x))\n        p (quot (+ w 1) 2)\n        n (- p (mod w 2))\n        f (fn f [s n p m]\n            (cond\n              (< s m) (cons\n                        (Long/parseLong (str s (apply str (rseq (vec (take n (str s)))))))\n                        (lazy-seq (f (+ s 1) n p m)))\n              (< n p) (f (/ m 10) (+ n 1) p m)\n              1 (f m n (+ p 1) (* m 10))))]\n    (remove #(< % x) (f (quot x (tp n)) n p (tp p)))))", "problem": 150, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn pal [n]\n             (let [next-pal\n                   (fn [n]\n                     (let [parsed (str n)\n                           length (count parsed)\n                           left-length (quot (inc length) 2)\n                           right-length (- length left-length)\n                           left-str (subs parsed 0 left-length)\n                           right-str (subs parsed left-length)\n                           right-rev (read-string (apply str\n                                                         (clojure.string/replace-first\n                                                           (clojure.string/reverse (subs parsed (quot length 2)))\n                                                           #\"^0+(?!$)\"\n                                                           \"\")))\n                           left (read-string left-str)\n                           new-left-str (str (if (< right-rev left) left (inc left)))\n                           new-right-str (clojure.string/reverse new-left-str)]\n                       (if (and (= (count (set parsed)) 1) (= (first (set parsed)) \\9))\n                         (read-string (str \\1 (apply str (repeat (dec length) \\0)) \\1))\n                         (read-string (str new-left-str (if (= left-length right-length) new-right-str (subs new-right-str 1)))))))\n                   p (if (= (str n) (clojure.string/reverse (str n))) n (next-pal n))]\n               (cons p (lazy-seq (pal (next-pal p))))))", "problem": 150, "user": "53527ce8e4b084c2834f4af1"}, {"code": "(fn f [x]\n  (let [num #(->> % (apply str) Long/valueOf)\n        x1  #(num (cons 1 (repeat % \\0)))\n        co  #(num (concat % (rest (reverse %))))\n        ce  #(num (concat % (reverse %)))\n        cn  #(count (str %))\n        hf  #(num (take %2 (str %)))\n\n        c (count (str x))\n        h (quot c 2)]\n    (filter #(<= x %)\n            (map :n (iterate (fn [m]\n                               (let [s (inc (m :s))\n                                     e (m :e)\n                                     f (m :f)\n                                     c (m :c)]\n                                 (cond\n                                  (< s e)  {:n (-> s str f) :f f :c c :s s :e e}\n                                  (= f co) (let [s (x1 (dec c))]\n                                             {:n (-> s str ce) :f ce :c c :s s :e e})\n                                  1        {:n (-> e str co) :f co :c (inc c) :s e :e (x1 (cn e))})))\n                             (let [o (odd? c)\n                                   i (if o (inc h) h)\n                                   f (if o co ce)\n                                   s (hf x i)]\n                               {:f f :c i :s s :e (x1 i) :n (-> s str f)}))))))", "problem": 150, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn make-palindromes\n  [x]\n  (let [\n         s (str x)\n         l (count s)\n         odd (odd? l)\n         half (quot l 2)\n         left (subs s 0 half)\n         left+ (subs s 0 (+ half (if odd 1 0)))\n         ans1 (Long/parseLong (str left+ (clojure.string/reverse left)))\n         result (if (>= ans1 x)\n                  ans1\n                  (let [\n                         s2 (str (inc (Long/parseLong left+)))\n                         ans2 (Long/parseLong (str s2 (clojure.string/reverse (subs s2 0 half))))\n                         ]\n                    ans2)\n                  )\n         ]\n    (concat [result] (lazy-seq (make-palindromes (inc result)))))\n  )", "problem": 150, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [n]\n  (let [s (str n)\n        div (quot(dec(count s))2)\n        pre (if (< n 100) 1 (read-string (apply str(take div s))))\n        mid (if (< n 100) 0 (read-string (str(first(drop div s)))))\n        f1 (fn f1 [f2 p m]\n             (let [m1 (mod (inc m) 10)\n                   p1 (if (= m 9) (inc p) p)]\n               (lazy-seq\n                (cons\n                 (read-string (apply str p m (reverse (str p))))\n                 (if (= (count (str p)) (count (str p1)))\n                   (f1 f2 p1 m1)\n                   (f2 f1 (quot p1 10) m1) )))))\n        f2 (fn f2 [f1 p m]\n             (let [m1 (mod (inc m) 10)\n                   p1 (if (= m 9) (inc p) p)]\n               (lazy-seq\n                (cons\n                 (read-string (apply str p m m (reverse (str p))))\n                 (if (= (count (str p)) (count (str p1)))\n                   (f2 f1 p1 m1)\n                   (f1 f2 p1 m1) )))))]\n    (drop-while\n     (partial > n)\n     (lazy-cat\n      (range 0 10) \n      (map #(read-string (str % %)) \"123456789\")\n      (if (even? (count s))\n        (f2 f1 pre mid)\n        (f1 f2 pre mid) )))))", "problem": 150, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn palindromes [n]\n  (let [p (loop [nn n]\n              (let [digits (map (comp #(- % 48) int) (str nn))\n                    digit-count (count digits)\n                    digit-count-by-2 (quot digit-count 2)\n                    prefix (take digit-count-by-2 digits)\n                    increm (reduce * (take digit-count-by-2 (repeat 10)))\n                    suffix (if (odd? digit-count)\n                               (reverse (take (inc digit-count-by-2) digits))\n                               (reverse prefix))\n                      result (reduce #(+ (* 10 %1) %2) (concat prefix suffix))]\n                  (if (>= result n)\n                    result\n                    (recur (+ result increm)))))]\n    (lazy-seq (cons p (palindromes (inc p))))))", "problem": 150, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn make-palindromes [n]\n  (let [; converts a number like `192` into vector of digits `[1 9 2]`\n        vectorize (fn [n]\n                    (let [m {\\0 0, \\1 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9}]\n                      (loop [v (str n), result []]\n                        (if (empty? v)\n                          result\n                          (recur \n                            (rest v)\n                            (conj result (m (first v))))\n                          ))))\n        ; converts a vector of digits `[1 9 1]` to number `191`\n        numerize (fn [v] (Long/parseLong (apply str v)))\n        ; for input palindrome creates the next palindrome\n        mnp (fn [n]\n              (let [\n                    ; vector of digits for the input number `n`\n                    v (vectorize n)\n                    ; number of digits\n                    c (count v)\n                    ; numberal divistion (the middile) 5/2 = 2 (reminder 1) \n                    x (quot c 2)\n                    ; create maximal palindrome for number of digits specified by `n`\n                    cmp (fn [] (repeat c 9))\n                    ; create next palindrome for number of input digits `n`\n                    cnfp (fn [n] (assoc (vec (repeat n 0)) 0 1 (dec n) 1))\n                    ; make a palindrome from a palindrome\n                    mpfp (fn [] \n                           (loop [i (if (even? c) (dec x) x)\n                                  j x \n                                  result v]\n                             (if (or (nil? i) (neg? i))\n                               result \n                               (let [a (result i) \n                                     b (result j)]\n                                 (if (= i j)\n                                   (if (not= 9 a)\n                                     (recur nil      nil      (assoc result i (inc a)))   \n                                     (recur (dec i) (inc j)   (assoc result i 0)))\n                                   (if (not= 9 a)\n                                      (recur nil     nil      (assoc result i (inc a) j (inc b)))\n                                      (recur (dec i) (inc j)  (assoc result i 0 j 0))))\n                                 \n                                 \n                                 ; (cond\n                                 ;   (and (= i j) (not= 9 a))         (recur nil nil (assoc result i (inc a)))         ;nil to break the loop\n                                 ;   (and (= i j) (= 9 a))            (recur (dec i) (inc j)   (assoc result i 0))\n                                 ;   (and (not= i j) (= 9 a) (= 9 b)) (recur (dec i) (inc j)   (assoc result i 0 j 0))\n                                 ;   (and (not= i j) (not= 9 a))      (recur nil nil (assoc result i (inc a) j (inc b))) \n                                 ;   (and (not= i j) (= 9 a))         (recur (dec i) (inc j)   result))\n                                 \n                                 ))))       \n                    ]\n                (if (= v (cmp))\n                  (numerize (-> c inc cnfp))\n                  (numerize (mpfp))\n                  )))\n        palindrome? (fn [n]\n                      (let [s (str n)]\n                        (= s (apply str (reverse s)))))\n        ; make a palindrome from not a palindrome\n        mpfnotp (fn [n]\n                  (let [v (vectorize n)\n                        c (count v)\n                        x (quot c 2)\n                        ; increment numbers inside out 12931 => 13931 \n                        incsv (fn [vv, ii, jj, a, b]\n                                (loop [vv1 vv\n                                       o (if (odd? c) x (dec x))  \n                                       p x]\n                                  (if (< o ii)\n                                    vv1\n                                    (let [elo (vv1 o)\n                                          elp (vv1 p)\n                                          no (dec o)\n                                          np (inc p)]\n                                      (cond\n                                        (and (= o p)    (< a b)   (not= 9 elo)) (recur (assoc vv1 jj a o (inc elo)) no np)\n                                        (and (= o p)    (< a b)   (= 9 elo))    (recur vv1 no np)\n                                        (and (= o p)    (= a b))                (recur vv1 no np)\n                                        (and (not= o p) (= 9 elo) (= 9 elp))    (recur vv1 no np)\n                                        (and (not= o p) (< elo elp))            (recur (assoc vv1 o elp) no np)\n                                        (and (not= o p) (> elo elp))            (recur (assoc vv1 p elo) no np)\n                                        (and (not= o p) (= elo elp))            (recur vv1 no np))\n                                      ))))]\n                    (loop [i 0\n                           j (dec c) \n                           result v]\n                      (if (or \n                            (and (even? c) (> i x))\n                            (and (odd? c) (= i x)))\n                        result\n                        (let [a (result i)\n                              b (result j)\n                              ni (inc i)\n                              nj (dec j)]\n                          (cond \n                            (= a b) (recur ni nj result)\n                            (< a b) (recur ni nj (incsv result i j a b))\n                            (> a b) (recur ni nj (incsv (assoc result j a) i j a a)))\n                          )))))\n        first-pal (if (palindrome? n) n (-> n mpfnotp numerize))\n        ]\n    (\n     (fn mps [n]\n       (cons \n         n\n         (lazy-seq\n           (mps (mnp n)))))\n     first-pal)\n    ))", "problem": 150, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(letfn [(even-cnt?\n         [coll]\n         (-> coll count even?))\n        \n        (left-mid\n         [s]\n         (let [mid (+ (if (even-cnt? s) 0 1)\n                      (quot (count s) 2))]\n           (subs s 0 mid)))\n        \n        (mirror\n         [[n d]]\n         (let [d (if (= :even d) n\n                   (quot n 10))]\n           (loop [n n, d d]\n             (if (zero? d) n\n               (recur (+ (* n 10)\n                         (mod d 10))\n                      (quot d 10))))))\n        \n        (init\n         [n]\n         (let [s (left-mid n)]\n           (vector (Long/parseLong s)\n                   (if (even-cnt? n)\n                     :even :odd)\n                   (->> (count s)\n                        (Math/pow 10)\n                        long))))\n        \n        (next-pal\n         [[n even goal]]\n         (let [n (inc n)]\n           (if (= n goal)\n             (if (= :even even)\n               [goal :odd (* 10 goal)]\n               [(/ goal 10) :even goal])\n             [n even goal])))]\n  \n  (fn palindromes [n]\n    (let [i    (-> n str init)\n          pals (iterate next-pal i)]\n      (remove (partial > n)\n              (map mirror pals)))))", "problem": 150, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn f [n]\n  (let [s (str n)\n        l (count s)\n        H (read-string (subs s 0 (/ (inc l) 2)))\n        p #(let [h (str %)] (read-string (apply str h (reverse (if (even? l) h (butlast h))))))\n        P (p H)\n        m (if (<= n P) P (p (inc H)))]\n    (cons m (lazy-seq (f (inc m))))))", "problem": 150, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn palindromic-numbers\n  ([minimum-value]\n    (let [s (str minimum-value)\n          length (count s)\n          output-odd-length-number (odd? length)\n          middle (/ length 2)\n          prefix (read-string (.substring s 0 (Math/ceil middle)))\n          suffix-str (apply str (drop-while #(= \\0 %) (reverse (.substring s (Math/floor middle)))))\n\t\t  suffix (if (empty? suffix-str) 0 (read-string suffix-str))\n          idx (cond\n                (>= prefix suffix) prefix\n                output-odd-length-number (inc prefix)\n                :else suffix)]\n      (palindromic-numbers idx output-odd-length-number)))\n  ([idx output-odd-length-number]\n    (let [prefix (str idx)\n          suffix (apply str\n                   (if output-odd-length-number\n                     (rest (reverse prefix))\n                     (reverse prefix)))\n          out (read-string (str prefix suffix))]\n      (cons \n        out\n        (if (< (count prefix) (count (str(inc idx))))\n          (if output-odd-length-number\n            (lazy-seq (palindromic-numbers (/ (inc idx) 10) false))\n            (lazy-seq (palindromic-numbers (inc idx) true)))\n          (lazy-seq (palindromic-numbers (inc idx) output-odd-length-number)))))))", "problem": 150, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [x]\n         (let [x-str (str x)\n               num-digits (count x-str)\n               generator-digits (take (Math/ceil (/ num-digits 2)) x-str)\n               is-even (even? num-digits)]\n           (letfn [(make-num\n                     [gen-digits is-even]\n                     (if is-even\n                       (read-string (apply str (concat gen-digits (reverse gen-digits))))\n                       (read-string (apply str (concat (butlast gen-digits)\n                                                       (list (last gen-digits))\n                                                       (reverse (butlast gen-digits)))))))\n                   (next-gen-digits\n                     [gen-digits is-even]\n                     (let [num (read-string (apply str gen-digits))\n                           n-digits (count (str num))\n                           next-num (inc num)\n                           next-n-digits (count (str next-num))]\n                       (if (= next-n-digits n-digits)\n                         [(seq (str next-num)) is-even]\n                         [(if is-even\n                            (seq (str next-num))\n                            (butlast (seq (str next-num))))\n                          (not is-even)])))\n                   (next-vals\n                     [[gen-digits is-even val]]\n                     (let [[next-GD next-is-even] (next-gen-digits gen-digits is-even)]\n                       [next-GD next-is-even (make-num next-GD next-is-even)]))]\n             (filter #(and % (>= % x))\n                     (conj (->> (iterate next-vals [generator-digits is-even nil])\n                                (map last))\n                           (make-num generator-digits is-even))))))", "problem": 150, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn palindromic-numbers\n  [start]\n  (letfn [(to-s [x] (str x))\n          (to-i [x] (Long/parseLong x))\n          (pal? [x] (= (to-s x) (clojure.string/reverse (to-s x))))\n          (next-pal\n            [p]\n            (prn p)\n            (let [l (count (to-s p))\n                  m (if (odd? l) (inc (quot l 2)) (quot l 2))\n                  b (to-s (inc (to-i (subs (to-s p) 0 m))))]\n              (if (odd? l)\n                (to-i (str b (subs (clojure.string/reverse b) 1)))\n                (to-i (str b (clojure.string/reverse b)))))\n            )]\n    \n    (if (< start 100)\n      (filter pal? (iterate inc start))\n      (let [f (if (pal? start)\n                start\n                (first (filter pal? (range start (* (+ start 1) 2)))))]\n        (lazy-seq\n          (cons f (palindromic-numbers (next-pal f))))))))", "problem": 150, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn ff\n  ([a] \n      (drop-while #(> a %) (ff (read-string (subs (str a) 0 (+ (/ (count (str a)) 2) 1/2))) (count (str a)))))\n  ([a b]\n      (lazy-cat [(read-string (str a (if (odd? b)\n                                       (subs (clojure.string/reverse (str a)) 1)\n                                       (clojure.string/reverse (str a)))))]\n                (let [aa (inc a)\n                      c (not= (count (str a)) (count (str aa)))]\n                  (ff (if (and c (odd? b))\n                        (/ aa 10)\n                        aa)\n                      (if c\n                        (inc b)\n                        b))))))", "problem": 150, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn f150 [n]\n    (let [exp (fn [a m]\n                (if (<= m 0)\n                    1\n                    (reduce * (repeat m a))))\n          numcol (fn numcol [n]\n                    (if (< n 10)\n                        [n]\n                        (conj (numcol (quot n 10)) (rem n 10))))\n          colnum (fn colnum [c]\n                    (if (= 1 (count c))\n                        (first c)\n                        (+ (* (first c) (exp 10 (dec (count c))))\n                           (colnum (rest c)))))\n          palin? (fn palin? [n]\n                    (let [col (numcol n)]\n                        (= col (reverse col))))\n          gen-pal (fn gen-pal [n mcol]\n                    (let [nn (inc n)\n                          ncol (numcol nn)\n                          stat (if (odd? (count mcol))\n                                   (not= (* 2 (count ncol))\n                                         (inc (count mcol)))\n                                   (not= (* 2 (count ncol))\n                                         (count mcol)))]\n                        (if stat\n                           (colnum (concat ncol\n                                           (if (odd? (count mcol))\n                                               (reverse (butlast (butlast ncol)))\n                                               (reverse (butlast ncol))))) \n                           (colnum (concat ncol\n                                          (if (odd? (count mcol))\n                                              (reverse (butlast ncol))\n                                              (reverse ncol)))))))\n          npal (fn [n]\n                  (let [mcol (numcol n)\n                        lcol (vec (take (quot (count mcol) 2) mcol))\n                        rlcol (reverse lcol)\n                        rcol (take-last (quot (count mcol) 2) mcol)\n                        midnum (first (drop (quot (count mcol) 2) mcol))\n                        stat (odd? (count mcol))]\n                    (if (<= (count mcol) 2)\n                        (loop [i (inc n)]\n                            (if (palin? i)\n                                i\n                                (recur (inc i))))\n                        (if (palin? n)\n                            (gen-pal (colnum (if stat\n                                                 (conj lcol midnum)\n                                                 lcol)) mcol)\n                            (if (> (colnum rlcol)\n                                   (colnum rcol))\n                                (colnum (concat lcol\n                                                (if stat\n                                                    [midnum]\n                                                    [])\n                                                rlcol))\n                                (gen-pal (colnum (if stat\n                                                     (conj lcol midnum)\n                                                     lcol)) mcol))))))\n          m (if (palin? n)\n                n\n                (npal n))]\n        (iterate npal m)))", "problem": 150, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn [n] (letfn [(next-polin [n] (first (filter is-polin? (iterate inc n))))                                                                                                                                                    \n                               (is-polin? [n] (= (str n) (clojure.string/reverse (str n))))                                                                                                                                                   \n                               (all-9? [n] (let [str-n (str n)] (if (zero? (count str-n)) false (empty? (filter #(not (= \\9 %)) str-n)))))                                                                                                    \n                               (produce [n] (let [str-m (str n) len (count str-m) ]                                                                                                                                                           \n                                                   (cond (< n 9) (inc n)                                                                                                                                                                      \n                                                         (= n 9) (+ n 2)                                                                                                                                                                      \n                                                         :else                                                                                                                                                                                \n                                                         (let [l-side (Integer/parseInt (subs str-m 0 (quot len 2)))                                                                                                                          \n                                                               r-side (clojure.string/reverse (str l-side))]                                                                                                                                  \n                                                           (if (even? len)                                                                                                                                                                    \n                                                             (if (not (all-9? l-side)) (let [new-l-side (inc l-side) new-r-side (clojure.string/reverse (str new-l-side))]                                                                    \n                                                                                         (Integer/parseInt (str new-l-side new-r-side)))                                                                                                      \n                                                                 (+ 2 n))                                                                                                                                                                     \n                                                             (let [middle (Integer/parseInt (subs str-m (quot len 2) (inc (quot len 2))))]                                                                                                    \n                                                               (if (< middle 9) (Integer/parseInt (str l-side (inc middle) r-side))                                                                                                           \n                                                                   (if (not (all-9? l-side)) (let [new-l-side (inc l-side) new-r-side (clojure.string/reverse (str new-l-side))]                                                              \n                                                                                               (Integer/parseInt (str new-l-side \"0\" new-r-side)))                                                                                            \n                                                                       (+ 2 n) ))))))))]                                                                                                                                                      \n                          (iterate produce (next-polin n))))", "problem": 150, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(letfn [(H [n m]\n          (if (zero? n) m\n              (recur (quot n 10)\n                     (+ (* m 10) (rem n 10)))))\n        \n        (F [n]\n          \"123 -> 123321\"\n          (H n n))\n\n        (G [n]\n          \"123 -> 12321\"\n          (H n (quot n 10)))\n\n        (L [n]\n          \"12345 -> 5\"\n          (if (< n 10) 1\n              (inc (L (quot n 10)))))\n\n        (N [m f n]\n          \"find next n that f(n) >= m\"\n          (loop [n n]\n            (if (>= (f n) m) n\n                (recur (inc n)))))\n        \n        (F' [e]\n          \"for even: 123456 -> 123\"\n          (let [l (L e)]\n            (loop [n e]\n              (if (= l (* 2 (L n))) n\n                (recur (quot n 10))))))\n\n        (G' [o]\n          \"for odd: 12345 -> 123\"\n          (let [l (L o)]\n            (loop [n o]\n              (if (= (inc l) (* 2 (L n))) n\n                (recur (quot n 10))))))\n\n        (M [x* y*]\n          \"merge two streams\"\n          (let [[x & xs] x* [y & ys] y*]\n            (cond (< x y) (cons x (lazy-seq (M xs y*)))\n                  (< y x) (cons y (lazy-seq (M x* ys)))\n                  :else (cons x (lazy-seq (M xs ys))))))\n\n        (S [n]\n          \"n, n+1, n+2, ...\"\n          (cons n (lazy-seq (S (inc n)))))\n\n        (X [m n f g]\n          \"mystery\"\n          (if (>= (g n) m)\n            (M (map f (S n)) (map g (S n)))\n            (cons (f n) (lazy-seq (X m (inc n) f g)))))\n\n        (P [m]\n          (if (even? (L m))\n            (X m (N m F (F' m)) F G)\n            (X m (N m G (G' m)) G F)))]\n  P)", "problem": 150, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn palindromes [n]\n  (letfn [(digit-count [x] (if (< x 10) 1 (inc (digit-count (quot x 10)))))\n          (power-of-10 [x] (if (zero? x) 1 (* 10 (power-of-10 (dec x)))))\n          (build-palindrome [x even-length?]                            \n                            (loop [current x, remaining (if even-length? x (quot x 10))]\n                              (if (zero? remaining)\n                                current\n                                (let [digit (mod remaining 10)]\n                                  (recur (+ (* 10 current) digit) (quot remaining 10))\n                                  ))))\n          (next-palindrome [n]\n                           (if (< n 10)\n                              n\n                              (let [digits (digit-count n)\n                                    prefix (quot n (power-of-10 (quot digits 2)))\n                                    candidate (build-palindrome prefix (even? digits))]\n                                (if (< candidate n) \n                                  (build-palindrome (inc prefix) (even? digits))\n                                  candidate))))]\n    (let [p (next-palindrome n)]\n      (cons p (lazy-seq (palindromes (inc p)))))))", "problem": 150, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn __ [n]\n  (let [from (fn [n]\n               (let [strnum (str n)\n                     x (quot (count strnum) 2)\n                     h (apply str (drop-last x strnum))]\n                 (read-string h)))\n        odds (->>\n               (iterate inc (from n))\n               (map str)\n               (map #(concat % (reverse (butlast %))))\n               (map #(read-string (apply str %))))\n        evens (->>\n                (iterate inc (max 1 (from n)))\n                (map str)\n                (map #(concat % (reverse %)))\n                (map #(read-string (apply str %))))\n        pick (fn pick [[x & xs :as xall] [y & ys :as yall]]\n               (lazy-seq\n                 (if (< x y)\n                   (cons x (pick xs yall))\n                   (cons y (pick ys xall)))))]\n    (->>\n      (pick odds evens)\n      (filter #(<= n %)))))", "problem": 150, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn palindromic [n]\n  (letfn [(cut [m]\n            (nth (iterate #(quot % 10) m) (-> m str count (quot 2))))\n          (palindromize [m digits]\n            (let [first-half (str m)]\n              (Long/parseLong\n                (apply str\n                  (map #(nth first-half (if (< % (quot digits 2)) % (- (dec digits) %)))\n                       (range digits))))))\n          (next-pal [m]\n            (palindromize (-> m cut inc) (-> m inc str count)))]\n    (filter (partial <= n)\n      (iterate next-pal (palindromize (cut n) (count (str n)))))))", "problem": 150, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "(fn palindromic\n  ([n]\n   (let [alldigs (map #(biginteger %) (re-seq #\"\\d\" (str n)))\n         totcnt (count alldigs)\n         cnt (quot (inc totcnt) 2)\n         digs (take cnt alldigs)\n         digs-rev (take cnt (reverse alldigs))\n         digs-next (concat (butlast digs) [(inc (last digs))])\n         pairs (map (fn [d1 d2] [d1 d2]) digs digs-rev)\n         comp (fn [r [d1 d2]] (if (= d1 d2) r (> d1 d2)))\n         ]\n     (palindromic \n      (if (reduce comp true pairs)\n        digs\n        digs-next)\n      totcnt)\n     )\n   )\n  ([digs totcnt]\n   (let [digs_ (reduce \n                (fn [r i] (let [d (+ (first r) i)\n                                c (quot d 10)\n                                m (mod d 10)]\n                            (concat [c m] (rest r))))\n                [0] (reverse digs))\n         totcnt_ (if (= (first digs_) 0) totcnt\n                   (inc totcnt))\n         digs-cur (if (= totcnt_ totcnt) (rest digs_)\n                     (take (quot (+ totcnt_ 1) 2) digs_))\n         digs-next (concat (butlast digs-cur) [(inc (last digs-cur))])\n         digs-all (concat digs-cur ((if (odd? totcnt_) rest seq) (reverse digs-cur)))\n         num (reduce #(+ (* %1 10) %2) digs-all)\n         ]\n     (cons num (lazy-seq (palindromic digs-next totcnt_)))\n    )\n   )\n  )", "problem": 150, "user": "535ca812e4b04ce2eb3ed2b7"}, {"problem": 150, "code": "(fn [x]\n    (let [p #(let [s (str %)]\n               (= (reverse s) (seq s)))\n          n #(let [s (str %)\n                   c (count s)\n                   h (quot c 2)\n                   s (str (+ 1\n                             (read-string\n                              (subs s 0 (+ h (rem c 2))))))]\n               (read-string\n                (apply str s (reverse (take h s)))))\n          q #(iterate n %)\n          b (first (filter p (iterate inc x)))]\n      (if (< x 11)\n        (concat (range x 10)\n                (q 11))\n        (cons b\n              (q (n b))))))", "user": "51ad244fe4b09397d510977f"}, {"problem": 150, "code": "(fn [n]\n(letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n(encode [x] (reduce #(+ (* % 10) %2) 0 x))\n(next-pal [n]\n(let [N (decode n)\nl (count N)\nd (quot l 2)\nH (take d N)\nH1 (decode (inc (encode H)))\nHr (reverse H)\nh (encode Hr)\np (nth N d)\nt (encode (take-last d N))]\n(encode (cond\n(and (even? l) (>= h t)) (concat H Hr)\n(and (odd? l) (>= h t)) (concat H [p] Hr)\n(even? l) (concat H1 (reverse H1))\n(and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n:else (concat H1 [0] (reverse H1))))))]\n(iterate (comp next-pal inc) (next-pal n))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 150, "code": "(fn make-palindromic-sequence [n]\n        (letfn [(palindromic? [x] (= (str x) (clojure.string/reverse (str x))))\n                (next-palindromic-number [x]\n            (if (palindromic? x)\n              (reduce #(+ (* 10 %1) %2)\n                      (let [numbers (map (fn [y] (- (int y) (int \\0))) (seq (str x)))]\n                        ;; if there are any 10s, convert them to 0s and spread them out\n                        (loop\n                            [candidate-list (if (even? (count numbers))\n                                              (concat\n                                               (take (dec (/ (count numbers) 2)) numbers)\n                                               [(inc (nth numbers (/ (count numbers) 2)))]\n                                               [(inc (nth numbers (/ (count numbers) 2)))]\n                                               (drop (inc (/ (count numbers) 2)) numbers))\n                                              (concat\n                                               (take (dec (/ (count numbers) 2)) numbers)\n                                               [(inc (nth numbers (/ (count numbers) 2)))]\n                                               (drop (/ (count numbers) 2) numbers)))\n                             ]\n                          (let [to-adjust (keep-indexed #(if (= %2 10) %1) candidate-list)]\n                            (if (seq to-adjust)\n                              (recur\n                               (cond\n                                ;; we have to adjust the first one? make the number bigger\n                                (= (first to-adjust) 0)\n                                (concat [1] (repeat (dec (count candidate-list)) 0) [1])\n                                ;; only the center needs to be adjusted?\n                                (= (count to-adjust) 1)\n                                (concat\n                                 (take (dec (first to-adjust)) candidate-list)\n                                 [(inc (nth candidate-list (dec (first to-adjust))))]\n                                 [0]\n                                 [(inc (nth candidate-list (inc (first to-adjust))))]\n                                 (drop (inc (inc (last to-adjust))) candidate-list))\n                                :else\n                                (concat\n                                 (take (dec (first to-adjust)) candidate-list)\n                                 [(inc (nth candidate-list (dec (first to-adjust))))]\n                                 (repeat (inc (- (last to-adjust) (first to-adjust))) 0) \n                                 [(inc (nth candidate-list (inc (last to-adjust))))]\n                                 (drop (inc (inc (last to-adjust))) candidate-list))\n                                ))\n                              candidate-list\n                              )))))\n              ;; not palindromic\n              (let [candidate\n                    (read-string\n                     (if (even? (count (str x)))\n                       (str\n                        (subs (str x) 0 (/ (count (str x)) 2))\n                        (clojure.string/reverse (subs (str x) 0 (/ (count (str x)) 2))))\n                       (str\n                        (subs (str x) 0 (inc (/ (count (str x)) 2)))\n                        (clojure.string/reverse (subs (str x) 0 (/ (count (str x)) 2))))\n                       ))]\n                (if (> candidate x)\n                  candidate\n                  (next-palindromic-number candidate)))))]\n          (let [candidate\n                (if (palindromic? n)\n                  n\n                  (next-palindromic-number n))]\n            (concat\n             [candidate]\n             (lazy-seq (make-palindromic-sequence (inc candidate)))))))", "user": "53838742e4b06839e8705ee0"}, {"problem": 150, "code": "(fn [n]\n  (letfn\n    [(pow [base e]\n      (loop [i 0 acc 1]\n        (if (= i e)\n          acc\n          (recur (inc i) (* acc base)))))\n    (to-digits [x]\n      (vec\n        (loop [cur x acc nil]\n          (if (= cur 0)\n            acc\n            (recur (quot cur 10) (cons (rem cur 10) acc))))))\n    (from-digits [dx]\n      (reduce #(+ (* % 10) %2) dx))\n    (mirror [x]\n      (let [dx (to-digits x)\n            len (count dx)\n            hl (quot len 2)\n            rl (rem len 2)]\n        [(from-digits (concat (subvec dx 0 (+ hl rl)) (reverse (subvec dx 0 hl)))), len]))\n    (next-x [x len]\n      (let [d (pow 10 (quot len 2))]\n        (+ (- x (rem x d)) d)))\n    (next-pal [x]\n      (if (< x 10)\n        x\n        (let [[m len] (mirror x)]\n          (if (>= m x) m (first (mirror (next-x x len)))))))]\n  (iterate #(next-pal (inc %)) (next-pal n))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 150, "code": "(fn\n  [n]\n  (letfn [(pow10 [n]\n            (cond\n              (= n 1) true\n              (not= 0 (mod n 10)) false\n              :else (recur (quot n 10))))\n          (r [left odd]\n            (lazy-seq\n              (let [sl (str left)\n                    rsl (apply str (reverse sl))\n                    s (if odd\n                        (str sl (subs rsl 1))\n                        (str sl rsl))\n                    leftp1 (inc left)\n                    [left' odd'] (if (and (> left 0) (pow10 leftp1))\n                                   (if odd\n                                     [(quot leftp1 10) false]\n                                     [leftp1 true])\n                                   [leftp1 odd])]\n                (cons (read-string s) (r left' odd')))))]\n    (let [nd (count (str n))\n          odd (odd? nd)\n          left (quot n (apply *' (repeat (quot nd 2) 10N)))]\n      (drop-while #(< % n) (r left odd)))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 150, "code": "(fn lazy-pn [k]\n  (let [find-next (fn [n]\n                    (let [snum (str n)\n                          len (count snum)\n                          hl (quot len 2)\n                          fp (subs snum 0 hl)\n                          fpn (if (zero? hl)\n                                0\n                                (Long. (subs snum 0 hl)))\n                          mid (if (even? len)\n                                \"\"\n                                (subs snum hl (+ hl 1)))\n                          mirror (Long. (str fp mid (clojure.string/reverse fp)))]\n                      (if (>= mirror n)\n                        mirror\n                        (cond\n                          (even? len) (if (every? #(= \\9 %) fp)\n                                        (recur (str \"1\" (apply str (repeat (count snum) \"0\"))))\n                                        (Long. (str (inc fpn) (clojure.string/reverse (str (inc fpn))))))\n                          :else (if (= mid \"9\")\n                                  (recur (Long. (str (inc fpn) \"0\" (apply str (repeat (count fp) \"0\")))))\n                                  (Long. (str fp (inc (Long. mid)) (clojure.string/reverse fp))))))))\n        next-pn (find-next k)]\n    (lazy-seq\n      (cons next-pn (lazy-pn (inc next-pn))))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 150, "code": "(fn palin_seq\n    ([[inc_fcn next_seed :as fcn_array] _ nn] (let [\n                split_seed #(->> % (take (/ (count %) 2)) (map (fn[c] (- (int c) 48))))                                             \n                digits (str nn)\n                seed (split_seed digits)\n                rseed (split_seed (reverse digits))\n                odd_flag (bit-and 1 (count digits))\n                rev_seed (reverse seed)\n                ]\n             (apply palin_seq [fcn_array \n                               (if (not-any? true? (map < seed rseed)) \n                                [rev_seed odd_flag] (next_seed rev_seed odd_flag inc_fcn))])\n           )\n     )\n    ([[inc_fcn next_seed :as fcn_array][seed odd_flag]]\n     (lazy-seq \n       (cons \n        (->> seed (into (drop odd_flag seed)) (reduce #(+ %2 (* 10 %)))) \n        (apply palin_seq [fcn_array (next_seed seed odd_flag inc_fcn)])\n      ))\n    )\n  )\n  [\n    ;; incfcn\n    (fn inc_digits [[n & rest] c]  \n               (case [n c]\n                  [nil 0] '()\n                  [nil 1] '(1)\n                  [9   1] (cons 0 (inc_digits rest 1))\n                  (cons (+ n c) (inc_digits rest 0))\n               ))\n\n  ;; next_seed\n  (fn [seed odd_flag incfn]  \n    (let [new_seed (incfn seed 1)]\n    (case [(> (count new_seed) (count seed)) odd_flag]\n                   [true 0] [new_seed  1]\n                   [true 1] [(rest new_seed) 0]\n                   [new_seed odd_flag]\n    )\n  ))\n]\n\n  0", "user": "5281a445e4b0757a1b17143a"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "52828298e4b0757a1b17145b"}, {"problem": 150, "code": "(fn paln [num]\n  (let [next-symmetric-number (fn [[num overlapping]]\n                                (let [lowest-number-with-n-digits (fn lowest-number-with-n-digits [n]\n                                                                    (reduce * (take (dec n) (repeat 10))))\n                                      number-of-digits #(count (str %))\n                                      current-number-of-digits (number-of-digits num)\n                                      next-number-of-digits (number-of-digits (inc num))]\n                                  (cond\n                                    (and\n                                      (not= current-number-of-digits next-number-of-digits)\n                                      overlapping)\n                                    [(lowest-number-with-n-digits current-number-of-digits) false]\n                                    (not= current-number-of-digits next-number-of-digits)\n                                    [(inc num) true]\n                                    :else [(inc num) overlapping])))\n        to-number (fn [[num overlapping]]\n                    (let [num-seq (seq (str num))]\n                      (if overlapping\n                        (bigint (apply str (concat num-seq (drop 1 (reverse num-seq)))))\n                        (bigint (apply str (concat num-seq (reverse num-seq)))))))\n        initial-symmetric-number (fn [num]\n                                   (let [num-digits (count (str num))]\n                                     (if (odd? num-digits)\n                                       [(bigint (apply str (take (+ 1 (quot num-digits 2)) (seq (str num))))) true]\n                                       [(bigint (apply str (take (quot num-digits 2) (seq (str num))))) false])))\n        ]\n    (->> (initial-symmetric-number num)\n         (iterate next-symmetric-number)\n         (map to-number)\n         (drop-while #(< % num)))))", "user": "53527551e4b084c2834f4af0"}, {"problem": 150, "code": "(fn pals [n]\n  (letfn [(digits [n] (map #(- (int %) 48) (str n)))\n\t\t  (num [ds] (reduce #(+ (* 10 %1) %2) 0 ds))\n\t\t  (next-pal [n] (let [ds (digits n)]\n\t\t\t  (cond (< n 0) 0 \n\t\t\t\t\t(every? #(= 9 %) ds) (+ 2 n)\n\t\t\t\t\t:else (let [d (count ds)\n\t\t\t\t\t\tq (quot d 2)\n\t\t\t\t\t\tr (rem d 2)\n\t\t\t\t\t\tls (take q ds)\n\t\t\t\t\t\tms (take (+ q r) ds)\n\t\t\t\t\t\trs (reverse (take q (reverse ds)))]\n\t\t\t\t\t(if (< (num rs) (num (reverse ls)))\n\t\t\t\t\t\t(num (concat ms (reverse ls)))\n\t\t\t\t\t\t(let [ms (digits (inc (num ms)))]\n\t\t\t\t\t\t\t(num (concat (take q ms) (reverse ms)))))))))]\n\t  (iterate next-pal (next-pal (dec n)))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 150, "code": "(fn [n]\n  (let [s (str n)\n        l (count s)\n        odd-start  (read-string (if (odd? l)\n                                  (apply str (take (Math/ceil (/ l 2)) s))\n                                  (apply str (first s) (repeat (/ l 2) \\0))))\n        even-start (max 1\n                        (read-string (if (odd? l)\n                                       (apply str\n                                              (first s)\n                                              (repeat (Math/floor (/ l 2)) \\0))\n                                       (apply str (take (/ l 2) s)))))\n        odds (map (fn [n]\n                    (let [s (str n)]\n                      (read-string (apply str\n                                          s\n                                          (drop 1 (reverse s))))))\n                  (iterate inc odd-start))\n        evens (map (fn [n]\n                     (let [s (str n)]\n                       (read-string (apply str s (reverse s)))))\n                   (iterate inc even-start))]\n    (letfn [(blend [[a & more-a :as as] [b & more-b :as bs]]\n              (lazy-seq\n               (if (< a b)\n                 (cons a (blend more-a bs))\n                 (cons b (blend as more-b)))))]\n      (drop-while (partial > n)\n                  (blend odds evens)))))", "user": "4f107e0e535d64f60314641c"}, {"problem": 150, "code": "(fn palin-seq [pal]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [digs] (reduce #(+ (* 10 %1) %2) 0 digs))\n          (next-pal [frst pal]\n            (let [digs (decode pal)\n                  is-pal? (= digs (reverse digs))\n                  len (count digs)\n                  len-even (even? len)\n                  half-len (quot len 2)\n                  middle-dig (when-not len-even (nth digs half-len))\n                  half-digs (take half-len digs)\n                  half-digs-end (when-not is-pal? (take half-len (reverse digs)))\n                  edge-case (every? #{9} half-digs)\n                  half-digs-inc (if edge-case nil (decode (inc (encode half-digs))))]\n              (encode\n                (if-not frst\n                  (cond\n                    (and middle-dig (< middle-dig 9)) (concat half-digs [(inc middle-dig)] (reverse half-digs))\n                    (and (not edge-case) len-even) (concat half-digs-inc (reverse half-digs-inc))\n                    (and (not edge-case) (not len-even)) (concat half-digs-inc [0] (reverse half-digs-inc))\n                    :default (concat [1] (repeat (dec len) 0) [1]))\n                  (if is-pal? \n                    digs\n                    (let [half-num (encode half-digs)\n                          half-num-end (encode half-digs-end)\n                          first-less (< half-num half-num-end)]\n                      (cond\n                        (and edge-case middle-dig) (concat (repeat half-len 9) [middle-dig] (repeat half-len 9))\n                        edge-case (repeat len 9)\n                        (and first-less middle-dig) (if (< middle-dig 9)\n                                                      (concat half-digs [(inc middle-dig)] (reverse half-digs))\n                                                      (concat half-digs-inc [0] (reverse half-digs-inc)))\n                        first-less (concat half-digs-inc (reverse half-digs-inc))\n                        :default (concat half-digs (if len-even [] [0]) (reverse half-digs)))))))))]\n    (let [first-pal (next-pal true pal)]\n      (lazy-seq (cons first-pal (palin-seq (next-pal false first-pal)))))))", "user": "52dd4fb4e4b09f7907dd13df"}, {"problem": 150, "code": "(fn npal [i]\n  (letfn [ (nxt [n]\n             (if (< n 10) n\n             (let [n-s     (str n)\n                   l       (count n-s)\n                   hl      (quot l 2)\n                   front-s (subs n-s 0 hl)\n                   back-s  (subs n-s (- l hl) l)\n                   pivot?  (odd? l)\n                   pivot-s (if pivot? (subs n-s hl (+ hl 1)) \"\")\n                   \n                   rfront-i (biginteger (clojure.string/reverse front-s))\n                   back-i   (biginteger back-s)\n                   \n                   change?      (> back-i rfront-i)\n                   fullfront-i  (biginteger (str front-s pivot-s))\n                   nfullfront-i (if change? (inc fullfront-i) fullfront-i)\n                   nfront-s     (if pivot? \n                                  (str (quot nfullfront-i 10))\n                                  (str nfullfront-i))\n                   npivot-s     (if pivot?\n                                  (str (rem nfullfront-i 10))\n                                  \"\")\n                   nback-s      (clojure.string/reverse nfront-s)\n                   \n                   np-s (str nfront-s npivot-s nback-s)\n                   np-i (biginteger np-s)\n                   ]\n               np-i)))\n           ]\n    (let [nxt-pal (nxt i)]\n      (cons nxt-pal (lazy-seq (npal (+ 1 nxt-pal))))))\n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 150, "code": "(fn pal-seq [min]\n  (let [mins (str min)\n        minpart (fn [x] (read-string (apply str (take x mins))))\n        trunc-half (quot (count mins) 2)\n        start (if (even? (count mins))\n                [(minpart trunc-half) true]\n                [(minpart (+ trunc-half 1)) false])]\n    (apply (fn rec-iter [n duplicate]\n             (let [l (fn [x] (count (str x)))\n                   min-l (fn [x] (reduce * (take x (repeat 10))))\n                   incn (inc n)\n                   gen (fn [x] (let [s (str x)\n                                     sr (if duplicate (reverse s)\n                                          (rest (reverse s)))\n                                     result (concat s sr)]\n                                 (Long. (apply str result))))\n                   item (if (>= (gen n) min) [(gen n)] [])]\n               (if (= (l n) (l incn))\n                 (lazy-cat item (rec-iter incn duplicate))\n                 (if duplicate (lazy-cat item (rec-iter incn false))\n                   (lazy-cat item (rec-iter (min-l (- (l n) 1)) true))))))\n           start)))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 150, "code": "(fn palidrome-numbers [num]\n  (letfn [(number->digits [n]\n            (if (< n 10)\n                [n]\n                (conj (number->digits (quot n 10)) (mod n 10))))\n          (digits->number [digits]\n  \t\t\t    (reduce #(+ (* 10 %1) %2) digits))\n          (next-palidrome-number [n]\n            (if (< n 0) 0\n              (let [numbers (number->digits n)\n                    odd-length (odd? (count numbers))\n                    first-half (take (/ (count numbers) 2) numbers)\n                    make-palidrome-number (fn [first-half-digits make-short]\n                                            (if make-short\n                                                (digits->number (concat (drop-last first-half-digits) (reverse first-half-digits)))\n                                                (digits->number (concat first-half-digits (reverse first-half-digits)))))\n                    potential-next-palidrome (make-palidrome-number first-half odd-length)]\n                (if (> potential-next-palidrome n)\n                    potential-next-palidrome\n                    (if (apply = (cons 9 first-half))\n                        (+ 1 (apply * (repeat (count numbers) 10)))\n                        (make-palidrome-number (->> first-half\n                                                    (digits->number)\n                                                    (inc)\n                                                    (number->digits))\n                                               odd-length))))))]\n  \t(rest (iterate next-palidrome-number (dec num)))))", "user": "529e3a4fe4b04e0c58e87b92"}, {"problem": 150, "code": "(fn palindrom [n]\n  (let [l (count (str n))\n        l-even (even? l)\n        l2 (/ (if l-even l (inc l)) 2) \n        next-n (reduce * (repeat l 10))\n        start (BigInteger. (apply str (take l2 (str n) )))\n        end (reduce * (repeat l2 10))]\n    \n    (lazy-cat\n     (->>\n      (range start end)\n      (map str)\n      (map #(BigInteger. (str % (apply str ((if l-even identity rest) (reverse %))))))\n      (drop-while #(< % n)))\n     (palindrom next-n))))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 150, "code": "(fn palindromes [m]\n           (let [digits (fn f [x]\n                          (if (< x 10)\n                            (vector x)\n                            (conj (f (/ (- x (mod x 10)) 10)) (mod x 10))))\n                 vecparse (fn g [y]\n                            (if (empty? (rest y))\n                              (peek y)\n                              (+ (peek y) (* 10 (g (pop y))))))\n                 nextpalindrome (fn [n]\n                                  (let [p (digits n)\n                                        k (dec (count p))\n                                        q (if (even? k)\n                                            (subvec p 0 (/ k 2))\n                                            (subvec p 0 (/ (inc k) 2)))]\n                                    (if (even? k)\n                                      (if (and (> n 0) (== (Math/pow 10 (inc k)) (inc n)))\n                                        (+ n 2)\n                                        (if (< n (vecparse (into (conj q\n                                                                (get p (/ k 2)))\n                                                                (reverse q))))\n                                          (vecparse (into (conj q\n                                                         (get p (/ k 2)))\n                                                         (reverse q)))\n                                          (if (== (get p (/ k 2)) 9)\n                                            (vecparse (into (conj (digits (inc (vecparse q)))\n                                                           0)\n                                                           (reverse (digits (inc (vecparse q))))))\n                                            (vecparse (into (conj q\n                                                           (inc (get p (/ k 2))))\n                                                           (reverse q))))))\n                                      (if (== (Math/pow 10 (inc k)) (inc n))\n                                        (+ 2 n)\n                                        (if (< n (vecparse (into q\n                                                                (reverse q))))\n                                          (vecparse (into q\n                                                         (reverse q)))\n                                        (vecparse (into (digits (inc (vecparse q)))\n                                                       (reverse (digits (inc (vecparse q)))))))))))]\n              (if (> m 0)\n                (rest (iterate nextpalindrome (dec m)))\n                (iterate nextpalindrome m))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 150, "code": "(fn pr150f\n  ([n] \n   (let [expt (fn [n p] (apply * (repeat p n)))\n         size (count (str n))\n         pali (pr150f (quot n (expt 10 (quot size 2)))\n                     (expt 10 (quot (inc size) 2))\n                     (zero? (rem size 2)))]\n     (if (zero? n)\n       (cons 0 (pr150f 1 10 false))\n       (if (> n (first pali)) (rest pali) pali))))\n  ([st end iseven]\n   (let [make-pal (fn make-pal [n iseven]\n                    (loop [back (if iseven n (quot n 10))\n                           res n]\n                      (if (zero? back)\n                        res\n                        (recur (quot back 10)\n                               (+ (* res 10) (rem back 10))))))]\n     (if (>= st end)\n       (if iseven\n         (pr150f end (* end 10) false)\n         (pr150f (quot end 10) end true))\n       (cons (make-pal st iseven)\n             (lazy-seq\n               (pr150f (inc st) end iseven)))))))", "user": "51696ee7e4b03f62cda68ce8"}, {"problem": 150, "code": "(fn [x]\n    (letfn [(p10 [n] (* 10 n))\n            (q10 [n] (quot n 10))\n            (r10 [n] (rem n 10))\n            (pow10 [n] (last (take n (iterate p10 1))))\n\n            (rdigit [n]\n              (map r10 (take-while (comp not zero?) (iterate q10 n))))\n            \n            (dedigit [d]\n              (apply + (map * (reverse d) (iterate p10 1))))\n         \n            (odd-pal-helper [n]\n              (let [dn (rdigit n)]\n                (map #(dedigit (concat (reverse dn) [%] dn)) (range 10))))\n\n            (odd-palindromic [o no]\n              (mapcat odd-pal-helper (range o no)))\n\n            (even-pal-helper [n]\n              (let [dn (rdigit n)] (dedigit (concat (reverse dn) dn))))\n            \n            (even-palindromic [e ne]\n              (mapv even-pal-helper (range e ne)))\n\n            (pal-seq-helper [start end turn]\n              (if (= turn :even)\n                (lazy-cat\n                 (even-palindromic start end)\n                 (pal-seq-helper start end :odd))\n                (lazy-cat\n                 (odd-palindromic start end)\n                 (pal-seq-helper end (p10 end) :even))))\n            \n            (pal-seq\n              [x]\n              (if (< x 10)\n                (lazy-cat\n                 (range x 10)\n                 (pal-seq-helper 1 10 :even))\n                (let [xr   (rdigit x)\n                      xlen (count  xr)\n                      half (quot xlen 2)\n                      parity (if (odd? xlen)\n                               :odd\n                               :even)\n                      init-end (pow10 (if (= parity :odd)\n                                  (inc half)\n                                  half))\n                      init-start (->> xr\n                                      (drop (if (= parity :odd)\n                                              (inc half)\n                                              half))\n                                      (reverse)\n                                      (dedigit))]\n                  (->> (pal-seq-helper init-start init-end parity)\n                       (drop-while #(< % x))))))]\n      (pal-seq x)))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 150, "code": "(fn [x]\n    (letfn [(n-digit-range \n              [d] \n              (if (= d 1) \n                (range 10)\n                (range (apply * (repeat (dec d) 10)) (apply * (repeat d 10)))))\n            (odd-palindrome\n              [x]\n              (let [s (seq (str x))]\n                (read-string (apply str (concat s (reverse (butlast s)))))))\n            (even-palindrome\n              [x]\n              (let [s (seq (str x))]\n                (read-string (apply str (concat s (reverse s))))))\n            (seed-range\n              [x]\n              (if (< x 10)\n                (cons 0 (concat (map odd-palindrome (range 1 10))\n                                (map even-palindrome (range 1 10))))\n                (let [s (seq (str x))\n                      d (int (+ 1/2 (/ (count s) 2)))\n                      r (range (read-string (apply str (take d s))) \n                               (apply * (repeat d 10)))]\n                  (if (odd? (count s))\n                  (concat (map odd-palindrome r)\n                          (map even-palindrome (n-digit-range d)))\n                  (map even-palindrome r)))))\n            (palindrome-seq-helper\n              [seed-digit]\n              (lazy-seq\n               (let [r (n-digit-range seed-digit)]\n                 (concat (map odd-palindrome r)\n                         (map even-palindrome (if (= seed-digit 1) (next r) r))\n                         (palindrome-seq-helper (inc seed-digit))))))]\n      (drop-while #(< % x)\n                  (lazy-seq\n                   (concat (seed-range x)\n                           (palindrome-seq-helper \n                            (inc (int (+ 1/2 (/ (count (str x)) 2))))))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 150, "code": "(fn palseq [n]\n    (letfn [(i [s] (read-string s)) \n            (rns [n] (apply str (reverse (str n)))) \n            (pal? [n] (= (str n) (rns n)))\n            (nextpal [n] \n                (if (pal? n)\n                    n\n                    (let [ s (str n)\n                           l (count s)\n                           ha (int (+ 0.5 (/ l 2)))\n                           hb (- l ha)\n                           sa1 (subs s 0 ha)\n                           sb1 (apply str (reverse (subs s 0 hb)))\n                           sa2 (inc (i sa1))\n                           sb2 (apply str (reverse (subs (str sa2) 0 hb)))\n                           n1 (i (str sa1 sb1))\n                           n2 (i (str sa2 sb2))\n                         ]\n                        (recur (if (> n1 n) n1 n2))\n                    )\n                )\n            )]\n           (let [r (nextpal n)]\n                (lazy-seq (cons r (palseq (inc r)))))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 150, "code": "(fn pal [n]\n         (if (= (seq (str n)) (reverse (str n)))\n           (cons n (lazy-seq (pal (inc n))))\n           (lazy-seq (pal \n                      (+ (first (filter pos? (map #(if (= % %2) 0 %3) (seq (str n)) (reverse (str n)) (iterate (partial * 10) 1)))) n)))\n           )\n         )", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 150, "code": "(fn palindromes [seed]\n  (letfn [(p-alter [c f]\n            ;; 454 -> extract core (45) and f it, then reinflate to 3 digits\n            ;; 4554 -> extract core (45) and f it, then reinflate to 4 digits\n            (let [digits (count c)\n                  core (-> digits inc (quot 2) ((partial subs c 0)) read-string f str) \n                  mid (-> core count (#(if (even? digits) % (dec %))))\n                  [prefix middle] [(subs core 0 mid) (subs core mid)]]\n              (read-string (clojure.string/join \"\" [prefix middle (clojure.string/reverse prefix)]))))\n          (p-inc [x]\n            ;; 9 -> 11, 99 -> 101, 999 -> 1001 .... always add 2\n            (let [c (str x)]\n              (if (every? (partial = \\9) c)\n                (+ 2 x)\n                (p-alter c inc))))\n          (palindrome? [x]\n            (= (str x) (clojure.string/reverse x)))]    \n    (let [p (p-alter (str seed) identity)]\n      (if (<= seed p)\n        (iterate p-inc p)\n        (drop 1 (iterate p-inc p))))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 150, "code": "(let [tens (iterate #(*' 10 %) 1)\n      reconstitute (fn [s]\n                     (apply +' (map *' s tens)))\n      to-palindrome (fn [od? s]\n                      (let [c (count s)\n                            expanded (if od?\n                                       (concat (butlast (rseq s)) s)\n                                       (concat (rseq s) s))]\n                        (reconstitute expanded)))\n      from-palindrome (fn [s]\n                        (let [c (count s)\n                              half-c (/ c 2)]\n                          (if (odd? c)\n                            (drop (dec half-c) s)\n                            (drop half-c s))))\n      breakdown (fn [i & acc]\n                  (let [acc (or acc [])]\n                    (if (= i 0)\n                      (or (not-empty acc) [0])\n                      (recur (quot i 10) (conj acc (rem i 10))))))\n      palindromic? #(= (reverse %) %)\n      lazy-sort (fn lazy-sort [[a & as :as A] [b & bs :as B]]\n                  (let [[el a' b'] (if (< a b) [a as B] [b A bs])]\n                    (cons el (lazy-seq (lazy-sort a' b')))))\n      nearby (fn [n]\n               (let [broken (breakdown n)\n                     c (count broken)]\n                 (if (palindromic? broken)\n                   (reconstitute (from-palindrome broken))\n                   (reconstitute (repeat (dec (int (/ c 2))) 9)))))]\n  (fn [n]\n    (let [start (nearby n)\n          ;; making this a function because I do not want a single lazy-seq here\n          inputs (fn [] (map (comp breakdown #(+ start %)) (range)))\n          odd (map #(to-palindrome true %) (inputs))\n          even (remove zero? (map #(to-palindrome false %) (inputs)))]\n    (drop-while\n     #(< % n)\n     (lazy-sort odd even)))))", "user": "51f9527fe4b09be9c177e549"}, {"problem": 150, "code": "(fn palindroms [n]\n  (letfn [(to-number [rs]\n            (loop [res (last rs)\n                   pow 10N\n                   r (rest (reverse rs))]\n              (if (empty? r) res\n                (recur (+ res (* pow (first r))) (* 10 pow) (rest r)))))\n\n          (to-base [n base]\n            (loop [xs (list (mod n base))\n                    n (quot n base)]\n              (if (zero? n) xs\n                (recur (cons (mod n base) xs) (quot n base)))))\n\n          (palindrom? [n]\n            (= (reverse (to-base n 10)) (to-base n 10)))\n\n          (next-palindrome [n]\n            (let [s (to-base n 10N)\n                  first-half (drop (quot (count s) 2) (reverse s))\n                  nxt (+ 1N (to-number (reverse first-half)))\n                  [h & t :as all] (reverse (to-base nxt 10))\n                  new-first-half (if (< (count first-half) (count all)) t all)\n                  new-n (to-number\n                          (if (odd? (count s))\n                            (concat (reverse first-half) (rest first-half))\n                            (concat (reverse first-half) first-half)))\n                  canddt-palindrome (to-number\n                                      (if (odd? (count s))\n                                        (concat (reverse t) new-first-half)\n                                        (concat (reverse all) new-first-half)))]\n              (if (> new-n n)\n                new-n\n                canddt-palindrome)))]\n  (if (palindrom? n)\n    (iterate next-palindrome n)\n    (rest (iterate next-palindrome n)))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 150, "code": "(fn palindrome-seq [n]\n  (let [s (str n)\n        c (count s)\n        base-count (if (even? c) (quot c 2) (+ 1 (quot c 2)))\n        base (subs s 0 base-count)\n        next-base (str (inc (bigint base)))\n        next-palindrome (bigint (cond \n                          (= (set s) #{\\9})\n                           (str (+ n 2))\n                          (even? c)\n                           (str next-base (clojure.string/reverse next-base))\n                          (odd? c)\n                           (str next-base (apply str (rest \n                              (clojure.string/reverse next-base))))))]\n    (letfn [(is-palindrome? [x] (= (str x) (clojure.string/reverse (str x))))]\n      (cond (< n 9) \n              (cons n (lazy-seq (palindrome-seq (inc n))))\n            (false? (is-palindrome? n)) \n              (lazy-seq (palindrome-seq (inc n)))\n            :else \n              (cons n (lazy-seq (palindrome-seq next-palindrome)))))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 150, "code": "(fn palindromes[start]\n  (let [clean (fn [s] (if(= \\0 (first s)) (recur (rest s)) (apply str s)))\n        nextPalindrome (fn [n]\n                         (let[strVal (str n)\n                              strLen (count strVal)\n                              lenBy2 (rem strLen 2)\n                              halfLen (+ (quot strLen 2) lenBy2)\n                              lower (subs strVal 0 halfLen)\n                              upper (clojure.string/reverse (subs strVal (- halfLen lenBy2)))]\n                           (if (= lower upper) n\n                             (let [cl (clean (clojure.string/reverse lower))\n                                   cu (clean (clojure.string/reverse upper))\n                                   ll (if (empty? cl) 0 (read-string cl))\n                                   ul (if (empty? cu) 0 (read-string cu))\n                                   lowerVal (if (>= ll ul) lower (str (inc (read-string lower))))]\n                               (if (zero? lenBy2) (read-string (str lowerVal (clojure.string/reverse lowerVal)))\n                                 (read-string (str lowerVal (apply str (rest (clojure.string/reverse lowerVal))))))))))\n        firstVal (nextPalindrome start)]\n   (cons firstVal (lazy-seq (palindromes (inc firstVal))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 150, "code": "(let [x (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp x inc) (x %)))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 150, "code": "(fn [v0]\n  (let [s (seq (str v0))\n        c (count s)\n        d (quot c 2)\n        e (if (even? c) d (inc d))\n        p0 (bigint (clojure.string/join (concat (take e s) (reverse (take d s)))))\n        pd (fn [ord] (let [half (quot ord 2)\n                           p0 (bigint (Math/pow 10 half))]\n                       (cond\n                         (zero? ord) 1\n                         (odd? ord) p0\n                         :else (+ p0 (quot p0 10)))))\n        pf (fn [p1] (+ p1 (condp re-matches (str p1)\n                            #\"^9+$\" 2\n                            #\"^(\\d)9+\\1$\" 11\n                            #\"^(\\d){2}9+(\\d){2}$\" 110\n                            #\"^(\\d){3}9+(\\d){3}$\" 1100\n                            #\"^(\\d){4}9+(\\d){4}$\" 11000\n                            #\"^(\\d){5}9+(\\d){5}$\" 110000\n                            #\"^(\\d){6}9+(\\d){6}$\" 1100000\n                            #\"^\\d+$\" :>> (comp pd count))))]\n    (drop-while #(> v0 %) (iterate pf p0))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 150, "code": "(fn pal-seq [x] (let [r 10\n                          to-seq (fn [n] (map first (take-while (partial some pos?) (rest (iterate (fn [[_ a]] [(mod a r) (long (/ a r))]) [0 n])))))\n                          from-seq (fn [s] (reduce + (map * s (iterate (partial * r) 1))))\n                          a (if (zero? x) [0] (to-seq x))\n                          h (drop (int (/ (count a) 2)) a)]\n                      (if (every? #{9} a)\n                        (let [p (from-seq (concat [1] (repeat (dec (count a)) 0) [1]))]\n                          (cons x (lazy-seq (pal-seq p))))\n                        (if (= a (reverse a))\n                          (let [n (to-seq (inc (from-seq h)))\n                                p (from-seq (concat (reverse (if (even? (count a)) n (rest n))) n))]\n                            (cons x (lazy-seq (pal-seq p))))\n                          (recur (inc x))))))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 150, "code": "(let [trim-leading-zeros (fn trim-leading-zeros [s]\n                           (let [ns (drop-while #(= \\0 %) s)]\n                             (if (empty? ns) '(\\0) ns)))\n\n      ; splits a number into a split-num, which is map with keys :hd, :md, :tl, where                                                                                                  \n      ;   :hd (the \"head\") is the first half of the number                                                                                                                             \n      ;   :md (the \"middle\") is the middle digit of the number, if the total number                                                                                                    \n      ;       of digits is even (the middle), or nil if the total number of digits is odd                                                                                              \n      ;   :tl (the \"tail\") is the last half of the number                                                                                                                              \n      ; the number of digits in :hd and :tl will always be equal                                                                                                                       \n      ; if the input number is a single digit, then both :hd and :tl will be nil                                                                                                       \n      ; examples:                                                                                                                                                                      \n      ;   (split-num 2536492) ;=> {:hd 253, :md 6,   :tl 492}                                                                                                                          \n      ;   (split-num 253649)  ;=> {:hd 253, :md nil, :tl 649}                                                                                                                          \n      ;   (split-num 253)     ;=> {:hd 2,   :md 5,   :tl 3}                                                                                                                            \n      ;   (split-num 25)      ;=> {:hd 2,   :md nil, :tl 5}                                                                                                                            \n      ;   (split-num 2)       ;=> {:hd nil, :md 2,   :tl nil}                                                                                                                          \n      split-num (fn split-num [n]\n                  (let [s (str n)\n                        c (count s)\n                        k (quot c 2)\n                        i (fn [t] (if (empty? t) nil (read-string (apply str (trim-leading-zeros t)))))]\n                    {:hd (i (take k s))\n                     :md (i (take (- c (* 2 k)) (drop k s)))\n                     :tl (i (drop (- c k) s))}))\n\n      ; return the number obtained by reversing the digits of a number                                                                                                                 \n      rev (fn rev [n] (if (nil? n) nil (read-string (apply str (trim-leading-zeros (reverse (str n)))))))\n\n      ; return the number of digits in a number                                                                                                                                        \n      digit-count (fn digit-count [n] (count (str n)))\n      ; take a pal-num, and return the next pal-num                                                                                                                                    \n      inc-pal-num (fn inc-pal-num [pn]\n                    (let [hd             (:hd pn)\n                          md             (:md pn)\n                          hd-digits      (digit-count hd)\n                          next-hd        (inc (or hd 0))\n                          next-hd-digits (digit-count next-hd)\n                          hd-grew        (or (nil? hd) (not= hd-digits next-hd-digits))\n                          next-md        (inc (or md 0))]\n                      (if (nil? md)\n                        (if hd-grew { :hd (/ next-hd 10) :md 0 }\n                            { :hd next-hd :md nil })\n                        (if (= 9 md)\n                          (if hd-grew { :hd next-hd :md nil }\n                              { :hd next-hd :md 0 })\n                          { :hd hd :md next-md }))))\n\n\n      ; take a split-num, and return the pal-num corresponding to the                                                                                                                  \n      ; first palindromic number which is greater than or equal to it.                                                                                                                 \n      ; (a pal-num is just like a split-num, except it has no :tl)                                                                                                                     \n      next-pal-split-num (fn next-pal-split-num [sn]\n                           (cond\n                            (nil? (:hd sn))               sn\n                            (<= (:tl sn) (rev (:hd sn)))  (dissoc sn :tl)\n                            :else                         (inc-pal-num (dissoc sn :tl))))\n\n      pal-int (fn pal-int [pn]\n                (let [shd (str (:hd pn))]\n                  (read-string (str shd (:md pn) (clojure.string/reverse shd)))))\n\n      do-pal (fn do-pal [n] (map pal-int (iterate inc-pal-num (next-pal-split-num (split-num n)))))\n      ]\n  do-pal\n  )", "user": "530bf87ee4b02e82168697d5"}, {"problem": 150, "code": "(fn palindrome [n]\n\t(let [ct (count (str n)) midct (quot ct 2) \n\t\t  prefix (if (>= ct 2) (read-string (subs (str n) 0 midct)))\n\t\t  mid (if (and (odd? ct) (>= ct 2)) (read-string (subs (str n) midct (inc midct))))\n\t\t  all-nines? (fn [prefix mid]\n\t\t  \t\t\t\t(and \n\t\t  \t\t\t\t\t(or (nil? mid) (= mid 9))\n\t\t  \t\t\t\t\t(> (count (str (inc prefix))) (count (str prefix)))))\n\t\t  nextp (fn [prefix mid]\n\t\t  \t(cond\n\t\t  \t\t(all-nines? prefix mid)\n\t\t  \t\t\t(if mid\n\t\t\t\t  \t\t[(inc prefix) nil]\n\t\t\t\t  \t\t[(/ (inc prefix) 10) 0])\n\t\t\t\t(nil? mid)\n\t\t\t\t  \t[(inc prefix) nil]\n\t\t\t\t:else\n\t\t\t\t  \t[(+ prefix (quot (inc mid) 10)) (mod (inc mid) 10)]))\n\t\t  gen-palindrome (fn gen-palindrome [[prefix mid]]\n\t\t  \t(let [result (read-string (str prefix mid (clojure.string/reverse (str prefix))))]\n\t\t  \t  (if (< result n)\n\t\t  \t  \t(gen-palindrome (nextp prefix mid))\n\t\t\t  \t(cons\n\t\t\t  \t  result\n\t\t\t  \t  \t(lazy-seq\n\t\t\t\t\t  (gen-palindrome (nextp prefix mid)))))))]\n\t\t  (if (< n 10)\n\t\t  \t(concat (range n 10)\n\t\t  \t\t(gen-palindrome [1 nil]))\n\t\t\t(gen-palindrome [prefix mid]))))", "user": "54448e84e4b032a45b869393"}, {"problem": 150, "code": "(letfn [\n        (number->vector [n]\n          (mapv #(-> % str read-string) (str n)))\n\n        (seq->number [v]\n          (read-string (apply str v)))\n\n        (inc-num-vec [nv]\n          (number->vector (inc (seq->number nv))))\n\n        (mirror [left middle]\n          (seq->number (concat left\n                               (when middle (list middle))\n                               (reverse left))))\n\n        (split-num [n]\n          (let [v (number->vector n)\n                cnt (count v)\n                index (quot cnt 2)\n                odd? (= 1 (mod (count v) 2))\n                left (subvec v 0 index)\n                middle (when odd? (nth v index))\n                right (subvec v (if odd? (inc index) index))]\n            (vector left middle right)))\n\n        (is-pally?\n          ([left right]\n             (= left (reverse right)))\n          ([n]\n             (let [[left _ right] (split-num n)]\n               (is-pally? left right))))\n\n        (make-pally [n]\n          (let [[left middle _] (split-num n)\n                pally (mirror left middle)]\n            (if (>= pally n) pally (gen-next-pally pally))))\n\n        (gen-next-pally [n]\n          (let [[left middle right] (split-num n)]\n            (cond (empty? left) (make-pally (inc n)) ;; case of single-digit\n                  (and (every? (partial = 9) left) ;; case of 99, 999, 9999...\n                       (or (= 9 middle) (nil? middle))) (make-pally (inc n))\n                       (nil? middle) (mirror (inc-num-vec left) middle)\n                       (< middle 9) (mirror left (inc middle))\n                       :else (mirror (inc-num-vec left) 0))))\n\n        (pally-seq [n]\n          (cons n (lazy-seq (pally-seq (gen-next-pally n)))))\n\n        (entry [n]\n          (let [p (make-pally n)]\n            (pally-seq p)))]\n  entry)", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 150, "code": "(fn [start]\n    (let [first-palindrome (first (filter #(= (str %) (clojure.string/reverse (str %)))\n                                          (iterate inc start)))]\n      (cons first-palindrome ((fn palindromes [previous]\n                                (lazy-seq\n                                 (let [digits                 (loop [n previous\n                                                                     a []]\n                                                                (if (< n 10)\n                                                                  (cons n a)\n                                                                  (recur (quot n 10)\n                                                                         (cons (rem n 10)\n                                                                               a))))\n                                       digits#                (count digits)\n                                       increment-last         (fn increment-last [s]\n                                                                (cond (empty? s)     [1]\n                                                                      (= 9 (last s)) (conj (vec (increment-last (butlast s)))\n                                                                                           0)\n                                                                      :else          (conj (vec (butlast s))\n                                                                                           (inc (last s)))))\n                                       first-half             (take (/ digits# 2) digits)\n                                       incremented-first-half (increment-last first-half)\n                                       next-value             (loop [s (cond (every? #(= 9 %) first-half) (increment-last (cons 1 (repeat digits# 0)))\n                                                                             (even? digits#)              (concat incremented-first-half\n                                                                                                                  (reverse incremented-first-half))\n                                                                             :else                        (concat incremented-first-half\n                                                                                                                  (rest (reverse incremented-first-half))))\n                                                                     a 0]\n                                                                (if (empty? s)\n                                                                  a\n                                                                  (recur (rest s) (+ (* a 10) (first s)))))]\n                                   (cons next-value (palindromes next-value)))))\n                              first-palindrome))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 150, "code": "; ugly, but fast! :-)\n(fn pal-seq [n]\n  (letfn [(palindrome? [s] (= (seq s) (reverse s)))\n          (as-num [s] (Long/parseLong (apply str s)))\n          (split-seq [s]\n                     (let [c (count s)\n                           h (quot c 2)\n                           h1 (take h s)]\n                       (if (even? c)\n                         [h1 \"\"]\n                         [h1 (nth s h)])))\n          (distance-to-nines-in-the-middle [s h]\n                                           (let [t (drop h s)]\n                                             (count (drop-while #(= % \\9) t))))\n          (mul-pow-10 [d n]\n                      (if (zero? n)\n                        d\n                        (recur (* d 10) (dec n))))\n          (increment [p]\n                     (let [s (str p)]\n                       (cond\n                         (< p 9) (inc p)\n                         (every? #{\\9} s) (+ p 2)\n                         (< p 100) (+ p 11)\n                         :else (let [c (count s)\n                                     h (quot c 2)]\n                                 (cond\n                                   (= (nth s h) \\9) (+ p (mul-pow-10 11 (dec (distance-to-nines-in-the-middle s h))))\n                                   :else  (if (even? c)\n                                            (+ p (mul-pow-10 11 (- h 1)))\n                                            (+ p (mul-pow-10 1 h))))))))\n          (gen-pal [k]\n                   (let [[h1 m] (split-seq (str k))]\n                     (as-num (concat h1 [m] (reverse h1)))))\n          (pal-generator [p]\n                         (cons p (lazy-seq (pal-generator (increment p)))))]\n    (if (palindrome? (str n))\n      (pal-generator n)\n      (drop-while #(< % n) (pal-generator (gen-pal n))))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 150, "code": "(fn [n]\n  (let [m #(let [t (str %)\n                 c (count t)\n                 u (quot (+ c 1) 2)\n                 t (if %&\n                     (str (+ % (apply * (repeat (quot c 2) 10))))\n                     t)]\n             (->> (take u t)\n                  reverse\n                  (concat (drop-last u t))\n                  (apply str)\n                  read-string))\n        s (m n)]\n    (iterate #(m % 1) (if (> n s) (m s 1) s))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 150, "code": "(fn poly-seq [n]\n         (let [split (fn [n] (let [digits (seq (str n))\n                                   length (count digits)\n                                   a-digits (take (quot length 2) digits)\n                                   a (read-string \n                                      (apply str a-digits))\n                                   c (apply str (take-last (quot length 2) digits))\n                                   b (if (= 0 (rem length 2))\n                                       -1\n                                       (read-string\n                                        (str (nth digits (quot length 2)))))]\n                               [a b c (quot length 2)]))\n               reverse-digits (fn [a] (apply str (reverse (seq (str a)))))]\n           (let  [next-poly \n                  (fn next-poly [n]\n                    (if (< n 10) n\n                        (let [[a b c length] (split n)]\n                          (cond (= (read-string (str \"10r\" (reverse-digits a))) \n                                   (read-string (str \"10r\" c))) \n                                (cond (= b -1) (read-string (str a c))\n                                      true (read-string (str a b c)))\n                                (> (read-string (str \"10r\" (reverse-digits a))) \n                                   (read-string (str \"10r\" c)))\n                                (cond (= b -1) (read-string (str a (reverse-digits a)))\n                                      true (read-string (str a b (reverse-digits a))))\n                                true (cond \n                                      (and (> b -1) (< b 9))\n                                      (read-string (str a (inc b) (reverse-digits a)))\n                                      (= b -1)\n                                      (read-string \n                                       (str (inc a) \n                                            (reverse-digits (inc a))))\n                                      (= b 9)\n                                      (next-poly (read-string\n                                                  (str (inc a)\n                                                       0\n                                                       (apply str (repeat length \"0\")) \n                                                       ))))))))]\n             (let [next (next-poly n)]\n               (cons next\n                     (lazy-seq (poly-seq (inc next))))))))", "user": "52cc09c1e4b07d0d72b27356"}, {"problem": 150, "code": "(fn pall\n  ([n]\n    (drop-while\n      #(> n %)\n      (pall\n        (take\n          (quot (inc (count (str n))) 2)\n          (loop [digits (list (mod n 10))\n                 num (quot n 10)]\n            (if\n              (zero? num)\n              digits\n              (recur\n                (cons (mod num 10) digits)\n                (quot num 10)))))\n        (count (str n)))))\n  ([digits output-size]\n    (cons\n      (reduce \n        #(+ (* 10 %1) %2)\n        (if\n          (even? output-size)\n          (concat digits (reverse digits))\n          (concat digits (rest (reverse digits)))))\n      (lazy-seq\n        (if\n          (every? #(= 9 %) digits)\n          (pall \n            (cons 1 (repeat (quot output-size 2) 0)) \n            (inc output-size))\n          (pall\n            (loop [new-digits (list)\n                   [digit & old-digits] (reverse digits)]\n              (if\n                (= 9 digit)\n                (recur (cons 0 new-digits) old-digits)\n                (concat \n                  (reverse old-digits) \n                  (cons (inc digit) new-digits))))\n            output-size))))))", "user": "521e8227e4b0dd19981ad082"}, {"problem": 150, "code": "(let\n             [digits (fn [i]\n                       (loop [d '() i i]\n                         (let [d (cons (rem i 10) d)\n                               i  (quot i 10)]\n                           (if (= 0 i)\n                             d\n                             (recur d i)))\n                         ))\n              from-digits (fn [d] (reduce (fn [acc d] (+ (* 10 acc) d)) 0 d))\n              all9? (fn [d] (not (some (comp not (partial = 9)) d)))\n              next-pnum (fn [d]\n                          (let [dn (count d)\n                                left (take (/ dn 2) d)\n                                incleft (digits (inc (from-digits left)))]\n                            (if (even? dn)\n                              (if (all9? left)\n                                (concat incleft (rest (reverse incleft)))\n                                (concat incleft (reverse incleft)))\n                              (if (all9? left)\n                                (let [r (rest (reverse incleft))] (concat (reverse r) r))\n                                (concat incleft (rest (reverse incleft)))))))\n              pnum? (fn [d] (= d (reverse d)))\n              closer-pnum (fn [n]\n                            (loop [n n]\n                              (if (pnum? (digits n))\n                                n\n                                (recur (inc n)))))]\n           (fn [n] ((fn f [n]\n                      (cons n (lazy-seq (f (from-digits (next-pnum (digits n)))))))\n                    (closer-pnum n))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 150, "code": "(fn [sn]\n  (letfn [(digits [n]\n            (->> n str seq (map #(read-string (str %)))))\n          (to-int [ds]\n            (reduce #(+ (* 10 %1) %2) 0 ds))\n          (plus [ds]\n            (->> ds to-int inc digits))\n          (g1 [ns] (for [n (range 10)] (lazy-cat ns [n] (reverse ns))))\n          (g2 [ns] (for [n (range 10)] (lazy-cat ns [n n] (reverse ns))))\n          (gi1 [ns]\n            (let [c (count ns)\n                  nn (take-while #(= c (count %)) (iterate plus ns))\n                  nx (cons 1 (repeat c 0))]\n              (lazy-cat (mapcat g1 nn) (gi2 (drop-last nx)))))\n          (gi2 [ns]\n            (let [c (count ns)\n                  nn (take-while #(= c (count %)) (iterate plus ns))\n                  nx (cons 1 (repeat c 0))]\n              (lazy-cat (mapcat g2 nn) (gi1 nx))))\n          (mirr [ds len half]\n            (let [left (take half ds)\n                  right (drop (- len half) ds)\n                  middle (if (odd? len) [(first (drop half ds))] [])\n                  [left' middle'] (if (< (to-int (reverse left)) (to-int right))\n                                    (if (odd? len)\n                                      [(butlast (plus (concat left middle)))\n                                       (take-last 1 (plus (concat left middle)))]\n                                      [(plus left) middle])\n                                    [left middle])]\n              (concat left' middle' (reverse left'))))]\n    (let [sc (digits sn)\n          l (count sc)\n          q (quot l 2)\n          hsc (take q sc)]\n      (cond\n       (= l 1) (filter\n                #(<= sn %)\n                (map to-int\n                     (lazy-cat (for [n (range 10)] [n])\n                               (for [n (range 1 10)] [n n])\n                               (gi1 [1]))))\n       (= l 2) (filter\n                #(<= sn %)\n                (map to-int\n                     (lazy-cat (for [n (range 10)] [n n])\n                               (gi1 [1]))))\n       (odd? l) (let [sn1 (to-int (mirr sc l q))]\n                  (cons\n                   (to-int (mirr sc l q))\n                   (filter #(< sn1 %) (map to-int (gi1 hsc)))))\n       :else (let [sn1 (to-int (mirr sc l q))]\n               (cons\n                sn1\n                (filter #(< sn1 %) (map to-int (gi2 (drop-last hsc))))))))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(front [x]\n            (let [n (-> x str count)]\n              [(bigint (apply str (take (quot (inc n) 2) (str x))))\n               (odd? n)]))\n\n          (dupe [x odd?]\n            (let [f (str x)\n                  l (apply str (reverse f))\n                  l (if odd? (apply str (rest l)) l)]\n              (bigint (str f l))))\n\n          (next [x]\n            (if (every? #(= \\9 %) (str x))\n              (+ 2 x)\n              (let [[f o] (front x)]\n                (dupe (inc f) o))))\n\n          (start [x]\n            (let [[f o] (front x)\n                  d (dupe f o)]\n              (if (< d x)\n                (next x)\n                d)))]\n    (iterate next (start n))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 150, "code": "(letfn [(digits [n]\n                (if (< n 10)\n                  [n]\n                  (conj (digits (quot n 10)) (rem n 10))))\n\n        (digits->num [[n & r]]\n                     (if r\n                       (+ (apply * n (repeat (count r) 10)) (digits->num r))\n                       n))\n\n        (num->half-num [n]\n                       (loop [c (quot (count (digits n)) 2)\n                              h n]\n                         (if (zero? c)\n                           h\n                           (recur (dec c) (quot h 10)))))\n\n        (is-palindromic? [n]\n                         (let [d (digits n)]\n                           (= d (reverse d))))\n\n        (next-palindromic-number [n]\n                                 (let [half-num (num->half-num n)\n                                       next-half-num (inc half-num)\n                                       count-digits-n (count (digits n))\n                                       next-half-num-digits (digits next-half-num)]\n                                   (if (= (count next-half-num-digits) (count (digits half-num)))\n                                     (let [lower-half-digits (if (odd? count-digits-n)\n                                                               (butlast next-half-num-digits)\n                                                               next-half-num-digits)\n                                           all-digits (concat next-half-num-digits (reverse lower-half-digits))]\n                                       (digits->num all-digits))\n                                     (digits->num (concat (butlast next-half-num-digits)\n                                                          (repeat (quot count-digits-n 2) 0)\n                                                          [1])))))\n\n        (palindromic-number-after [n]\n                                  (let [half-num (num->half-num n)\n                                        half-num-digits (digits half-num)\n                                        lower-half-digits (if (odd? (count (digits n)))\n                                                            (butlast half-num-digits)\n                                                            half-num-digits)\n                                        all-digits (concat half-num-digits (reverse lower-half-digits))\n                                        p (digits->num all-digits)]\n                                    (if (< p n)\n                                      (next-palindromic-number p)\n                                      p)))]\n  (fn palindrom-seq [n]\n    (lazy-seq\n      (let [p (if (is-palindromic? n)\n                n\n                (palindromic-number-after n))]\n        (cons p (palindrom-seq (next-palindromic-number p)))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 150, "code": "(fn palindromes [first-number & {:keys [may-include-first] :or {may-include-first true}}]\n  (letfn [(nmb->digits [n]\n                       (map (fn [d]\n                              (- (int d) (int \\0)))\n                            (seq (str n))))\n          (digits->nmb [digits]\n                       (bigint (apply str digits)))\n          (is-palindrome? [digits]\n                          (= digits (reverse digits)))\n          (next-palindrome [n]\n                           (let [digits (nmb->digits (bigint n))\n                                 pivot (int (/ (count digits) 2))\n                                 left-digits (take pivot digits)\n                                 middle-digit (first (drop-last pivot (drop pivot digits)))\n                                 left-and-middle-digits (concat left-digits (when middle-digit [middle-digit]))]\n                             (if (is-palindrome? digits)\n                               (let [next-left-and-middle-digits (nmb->digits (inc (digits->nmb left-and-middle-digits)))\n                                     overflow-occurs? (> (count next-left-and-middle-digits) (count left-and-middle-digits))\n                                     odd-length? (= 1 (rem (count digits) 2))\n                                     digits-to-remove (+ (if overflow-occurs? 1 0) (if odd-length? 1 0))\n                                     result-left (drop-last (if (> digits-to-remove 0) 1 0) next-left-and-middle-digits)\n                                     result-right (drop (if (> digits-to-remove 1) 1 0) (reverse next-left-and-middle-digits))]\n                                 (digits->nmb (apply str (concat result-left result-right))))\n                               (let [right-digits (drop (count left-and-middle-digits) digits)\n                                     symmetric-digits (concat left-and-middle-digits (reverse left-digits))\n                                     left-number (digits->nmb left-and-middle-digits)\n                                     reverse-left-number (digits->nmb (reverse (nmb->digits left-number)))\n                                     right-number (digits->nmb (cons middle-digit right-digits))\n                                     is-bellow-symmetry? (< right-number reverse-left-number)]\n                                 (if is-bellow-symmetry?\n                                   (digits->nmb symmetric-digits)\n                                   (let [new-left-number-digits (nmb->digits (inc left-number))\n                                         new-right-digits (map (fn [_] \\0) (drop (count new-left-number-digits) digits))\n                                         new-number (concat new-left-number-digits new-right-digits)]\n                                     (recur (digits->nmb new-number))))))))]\n    (let [first-value (if (and may-include-first (is-palindrome? (nmb->digits first-number)))\n                        first-number\n                        (next-palindrome first-number))]\n      (cons first-value (lazy-seq (palindromes first-value :may-include-first false))))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 150, "code": "(fn [n] \n  (letfn [(digits [x] (loop [coll () n x] (if (< n 10) (conj coll n) (recur (conj coll (mod n 10)) (quot n 10)))))\n          (decimal [xs] (loop [n 0 coll xs] (if (seq coll) (recur (+ (* n 10) (first coll)) (rest coll)) n)))\n          (next-pal [x]\n            (let [xs (digits x)\n                  cnt (count xs)\n                  half (quot cnt 2)\n                  high-part (take half xs)\n                  high-reverse (reverse high-part)\n                  high (decimal high-reverse)\n                  low (decimal (take-last half xs))\n                  high-inc (->> high-part decimal inc digits)\n                  mid (nth xs half)]\n              (decimal\n                (cond \n                    (>= high low) (concat high-part (if (odd? cnt) (list mid) ()) high-reverse) \n                    (even? cnt) (concat high-inc (reverse high-inc))\n                    (< mid 9) (concat high-part (list (inc mid)) high-reverse)\n                    :else (concat high-inc (list 0) (reverse high-inc))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 150, "code": "(fn __ [somenumber]\n  (letfn [(palindrom [x] \n                     (#(read-string(apply str (concat % (reverse (drop-last (mod (count (str x)) 2) %)))))\n                       (drop-last (quot (count (str x)) 2) (str x))))\n          (next-palindrom [x] \n                          (#(read-string(apply str(concat (drop-last (if (every? #{\\9} (str x)) 1 0) %) (reverse (drop-last  (mod  (count (str x)) 2) %)))))\n                           (str \n                           (inc(read-string(apply str \n                                                 (drop-last (quot (count (str x)) 2) (str x))))))))] \n    (iterate next-palindrom (if (>= (palindrom somenumber) somenumber) (palindrom somenumber) (next-palindrom somenumber)))))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 150, "code": "(fn build-palin-seq [curnum]\n  (letfn \n    [(safe-read-string [s]\n      (let [rg (re-seq #\"[1-9]+[0-9]*|0{2}\" s)]\n        (if (nil? rg) 0 (read-string (first rg)))))        \n     \n     (seq-to-num [s]  (safe-read-string (apply str s)))\n     \n     (num-to-seq [n]  (vec (str n)))\n     \n     (num-ndigits [n] (count (str n)))\n     \n     (nextpalin [n]\n      (let [nseq             (map #(- (int %) (int \\0)) (num-to-seq n))\n            nnum             (count nseq)\n            halflen          (if (odd? nnum) (/ (inc nnum) 2) (/ nnum 2))\n            firsthalfreverse (reverse (take halflen nseq))\n            secondhalf       (drop (- nnum halflen) nseq) \n            eqinsidixlen     (apply max (conj (filter #(= (take % firsthalfreverse) (take % secondhalf)) \n                                                  (range 1 (inc halflen))) 0))\n            uneqlen           (- halflen eqinsidixlen)\n            halfmiddlepartlen (- halflen uneqlen)\n            middlepartlen     (- nnum (* 2 uneqlen))\n            middlepart        (take middlepartlen (drop uneqlen nseq))]\n\n        ; if unequal part has length 0, n is already a palindrom\n        (if (zero? uneqlen) n\n          (let [uneqfirst            (take uneqlen nseq)\n                uneqsecond           (drop (- nnum uneqlen) nseq)\n                uneqfirstreversed    (reverse (take uneqlen nseq))\n                uneqfirstreversednum (seq-to-num uneqfirstreversed)\n                uneqsecondnum        (seq-to-num uneqsecond)]\n\n                ; if first uneq part reversed is bigger than the second uneq part, make latter the former \n                (if (> uneqfirstreversednum uneqsecondnum) \n                  (seq-to-num (concat uneqfirst middlepart uneqfirstreversed))\n\n                  (let [firsthalfnum     (seq-to-num (take halflen nseq))\n                        nextfirsthalfnum (inc firsthalfnum)\n                        newhalflen       (num-ndigits nextfirsthalfnum)\n                        nextfirsthalf    (num-to-seq nextfirsthalfnum)\n                        nextsecondhalf   (reverse nextfirsthalf)]\n\n                    (if (> newhalflen halflen)\n                      (if (odd? nnum)\n                        (seq-to-num (concat (drop-last nextfirsthalf) (drop 1 nextsecondhalf)))\n                        (seq-to-num (concat (drop-last nextfirsthalf) nextsecondhalf)))\n                      (if (odd? nnum)\n                        (seq-to-num (concat (drop-last nextfirsthalf) nextsecondhalf))\n                        (seq-to-num (concat nextfirsthalf nextsecondhalf)))\n                      )\n\n                    ))\n              ))\n        ))]\n    \n    (let [nextp (nextpalin curnum)]\n      (cons nextp (lazy-seq (build-palin-seq (inc nextp)))))\n))", "user": "52faec2ee4b047fd55837004"}, {"problem": 150, "code": "(fn palindromes [n]\n  (let [mirror (fn [[num dig _]]\n                 (loop [a num, r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)), (quot r 10)))))\n        get_next (fn [[n dig len_num]]\n                   (let [new_num (inc n)]\n                     (if (= new_num (int (Math/pow 10 len_num)))\n                       (if (= dig :even)\n                         [new_num :odd (inc len_num)]\n                         [(quot new_num 10) :even len_num])\n                       [new_num dig len_num])))\n        seed (fn [n]\n               (let [str-n (str n)\n                     len-n (count str-n)\n                     half-n (quot len-n 2)\n                     lower-str (subs str-n 0 half-n)\n                     lower-int (Long. lower-str)]\n                 (if (even? len-n)\n                   (if (< lower-int (Long. (apply str (reverse (subs str-n half-n)))))\n                     [(inc lower-int) :even (count (str lower-int))]\n                     [lower-int :even half-n])\n                   (if (< lower-int (Long. (apply str (reverse (subs str-n (inc half-n))))))\n                     [(inc (Long. (subs str-n 0 (inc half-n)))) :odd (count (str lower-int))]\n                     [(Long. (subs str-n 0 (inc half-n))) :odd half-n]))))]\n    (if (< n 10)\n      (map mirror (iterate get_next [n :odd 1]))\n      (map mirror (iterate get_next (seed n))))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 150, "code": "(fn nextpals [N]\n  (let [c (count (str N))\n        a (when (> N 9) (read-string (apply str (take (quot c 2) (str N)))))\n        b (when (odd? c) (- (int (nth (str N) (quot c 2))) (int \\0)))\n        c10? #(not= (count (str %)) (count (str (inc %))))\n        npalpair (fn [[a b]]\n                   (if a\n                     (if b\n                       (if (= 9 b) (if (c10? a) [(inc a) nil] [(inc a) 0])\n                         [a (inc b)])\n                       (if (c10? a) [(quot (inc a) 10) 0] [(inc a) nil]))\n                     (if (= 9 b) [1 nil] [nil (inc b)])))\n        bpal (fn [[a b]] (read-string (apply str (concat (when a (str a)) (when b (str b)) (when a (reverse (str a)))))))]\n    (drop-while #(< % N) (map bpal (iterate npalpair [a b])))\n    ))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 150, "code": "(fn [from]\n  (let [fr-str (str from)\n        n      (count fr-str)\n        ->int  #(read-string (apply str %))\n\n        first-p\n        [(-> n dec (quot 2) inc\n             (take fr-str) \n             ->int)\n         (odd? n)]\n\n        next-p\n        (fn [[prev o?]]\n          (let [pv-str (str prev)] \n            (if (every? #{\\9} pv-str)\n              (if o?\n                [(reduce \n                   * (repeat \n                       (dec (count pv-str)) \n                       10)) \n                 false]\n                [(inc prev) true]) \n              [(inc prev) o?])))\n\n        mk-p\n        (fn [[n o?]]\n          (let [n-str (str n)]\n            (->int\n              (concat \n                n-str\n                (if o? \n                  (rest (reverse n-str))\n                  (reverse n-str))))))] \n    (drop-while \n      #(> from %) \n      (map mk-p\n           (iterate next-p \n                    first-p)))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 150, "code": "(fn [n]\n  (let [to-digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        to-number (fn [s] (read-string (apply str s)))\n        lt (fn [a b] (when-let [s (seq (drop-while zero? (map compare a b)))]\n                       (neg? (first s))))\n        gen (fn [first-part cn]\n              (if (odd? cn)\n                (concat first-part (drop 1 (reverse first-part)))\n                (concat first-part (reverse first-part))))\n        incp (fn [prefix cn]\n               (let [nrough (to-digits (inc (to-number prefix)))]\n                 (if (= (count nrough) (count prefix))\n                   (gen nrough cn)\n                   (concat 1 (repeat (dec cn) 0) 1))))\n        next-pal (fn [n]\n                   (let [s (to-digits n)\n                         cn (count s)\n                         prefix (first (split-at (+ (quot cn 2) (mod cn 2)) s))]\n                     (to-number\n                       (loop [np (gen prefix cn)]\n                         (if (lt np s)\n                           (recur (incp prefix cn))\n                           np)))))]\n    (iterate #(next-pal (inc %))\n      (next-pal n))))", "user": "4f05ea25535dcb61093f6c02"}, {"problem": 150, "code": "(fn [n]\n  (let [exp (fn ! [n]\n              (let [d (quot n 10)\n                    r (mod n 10)]\n                (if (> d 0) (conj (! d) r) [r])))\n        imp (fn [xs] (reduce #(+ (* %1 10) %2) 0 xs))\n        incp (fn [xs] (exp (inc (imp xs))))\n        pal? (fn [xs] (= xs (reverse xs)))\n        first-pal (fn [n] (first (filter pal? (map exp (iterate inc n)))))\n        next-pal (fn [xs]\n                   (let [l (count xs)\n                         o (mod l 2)\n                         h (take (/ l 2) xs)\n                         n (incp h)\n                         o (if (= (count n) (count h)) o (inc o))]\n                     (concat (drop-last (quot o 2) n) (drop (/ o 2) (reverse n)))))]\n    (map imp (iterate next-pal (first-pal n)))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 150, "code": "(fn [b]\n  (let [todigs (fn [n]\n                 (loop [digs (), n n]\n                   (let [q (quot n 10)\n                         r (rem n 10)\n                         digs (conj digs r)]\n                     (if (zero? q)\n                       digs\n                       (recur digs q)))))\n        tonum (fn [v]\n                (apply + (map * (reverse v) (iterate #(*' 10 %) 1))))\n        next-pal (fn [n]\n                    (let [digs (todigs n)\n                          ndigs (count digs)\n                          ldigs (take (- ndigs (quot ndigs 2)) digs)\n                          lnum (tonum ldigs)\n                          rdigs (drop (quot ndigs 2) digs)\n                          rnum (tonum rdigs)\n                          lnum-rev (tonum (reverse ldigs))]\n                      (cond\n                       (every? #(= 9 %) digs)  (+ n 2)\n                       (and (even? ndigs)\n                            (> lnum-rev rnum)) (tonum (concat ldigs (reverse ldigs)))\n                       (even? ndigs) (tonum (concat (todigs (inc lnum))\n                                             (reverse (todigs (inc lnum)))))\n                       (and (odd? ndigs)\n                            (> lnum-rev rnum)) (tonum (concat ldigs (reverse (butlast ldigs))))\n                       :else (tonum (concat (todigs (inc lnum))\n                                     (reverse (butlast (todigs (inc lnum)))))))))\n        [f & r :as s] (iterate next-pal b)]\n    (if (= f (tonum (reverse (todigs f))))\n      s\n      r)))", "user": "54848141e4b0e286459a119e"}, {"problem": 150, "code": "(fn next-pal2 [n]\n  (let [s (str n)\n        l (count s)\n        h (quot (count s) 2)\n        ns (apply str (drop-last h s))\n        hn (bigint ns)\n        nns0 (str hn)\n        nns1 (str (inc hn))]\n    (let [next-n (bigint\n                   (if (odd? l)\n                     (cond\n                       (>= (bigint (str nns0 (apply str (reverse (butlast nns0))))) n)\n                         (str nns0 (apply str (reverse (butlast nns0))))\n                       (= (count nns1) (count ns))\n                         (str nns1 (apply str (reverse (butlast nns1))))\n                       :else\n                         (str (apply str (butlast nns1)) (apply str (reverse (butlast nns1)))))\n                     (cond ; even\n                       (>= (bigint (str nns0 (apply str (reverse nns0)))) n)\n                         (str nns0 (apply str (reverse nns0)))\n                       (= (count nns1) (count ns))\n                         (str nns1 (apply str (reverse nns1)))\n                       :else\n                         (str nns1 (apply str (reverse (butlast nns1)))))))]\n      (lazy-seq (cons next-n (next-pal2 (inc next-n)))))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 150, "code": "(fn __ [n]\n  (letfn [(f [x]\n             (cons x\n                   (lazy-seq\n                    (let [s (str x),   k (count s),\n                          k2 (if (odd? k) (inc (quot k 2)) (quot k 2)),   s2 (subs s 0 k2),\n                          t2 (str (inc (read-string s2))),   l2 (count t2),\n                          y (read-string\n                             (let [u2 (subs t2 0 (dec l2))]\n                               (if (odd? k)\n                                 (if (= k2 l2)\n                                   (apply str t2 (reverse u2))\n                                   (apply str u2 (reverse u2)))\n                                 (if (= k2 l2)\n                                   (apply str t2 (reverse t2))\n                                   (apply str t2 (reverse u2))))))]\n                      (f y)))))]\n    (let [s (str n), k (count s), k2 (if (odd? k) (inc (quot k 2)) (quot k 2)), s2 (subs s 0 k2), u2 (subs s2 0 (dec k2)),\n          m (read-string (if (odd? k) (apply str s2 (reverse u2)) (apply str s2 (reverse s2)) ) ) ]\n      (drop-while #(< % n) (f m)))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 150, "code": "(fn next-palindrome [n]\n  (let [join-digits (partial reduce #(+' (* %1 10) %2) 0)\n        to-digits (fn [n']\n                    (loop [digits []\n                           n n']\n                      (let [q (quot n 10)\n                            d (rem n 10)]\n                        (if (= 0 q)\n                          (vec (cons d digits))\n                          (recur (cons d digits)\n                                 q)))))\n        start-digits (to-digits n)\n\n        ;; given a palindrome (as list of digits), give next one\n        nextp\n        (fn [digits]\n          (let [len (count digits)\n                half-len (/ len 2)\n                high-digits (subvec digits 0 half-len)\n                high-digits' (reverse high-digits)\n                low-digits  (subvec digits (Math/ceil half-len))\n                low-digits' (reverse low-digits)\n                mid (if (odd? len) (nth digits half-len))\n                high (join-digits high-digits)\n                high' (join-digits high-digits')\n                low  (join-digits low-digits)\n                low'  (join-digits low-digits')]\n            (if (odd? len)\n              (if (not= mid 9)\n                (concat high-digits (list (inc mid)) low-digits)\n                (let [new-high (to-digits (inc high))]\n                  (concat new-high\n                          (if (not-every? (partial = 9) high-digits)\n                            [0] [])\n                          (reverse new-high))))\n\n                (let [new-high (to-digits (inc high))]\n                  (if (not-every? (partial = 9) high-digits)\n                    (concat new-high (reverse new-high))\n                    (concat new-high (rest (reverse new-high))))))))\n\n        digits start-digits\n        len (count digits)\n        half-len (/ len 2)\n        high-digits (subvec digits 0 half-len)\n        high-digits' (reverse high-digits)\n        low-digits  (subvec digits (Math/ceil half-len))\n        low-digits' (reverse low-digits)\n        mid (if (odd? len) (nth digits half-len))\n        high (join-digits high-digits)\n        high' (join-digits high-digits')\n        low  (join-digits low-digits)\n        low'  (join-digits low-digits')\n        new-digits\n        (if (odd? len)\n           (if (= low high')\n             (if (not= mid 9)\n               (concat high-digits (list (inc mid)) low-digits)\n               (let [new-high (to-digits (inc high))]\n                 (concat new-high\n                         (if (not-every? (partial = 9) high-digits)\n                           [0] [])\n                         (reverse new-high))))\n             (if (< low high')\n               (concat high-digits\n                       (list mid)\n                       high-digits')\n\n               (if (not= mid 9)\n                 (concat high-digits\n                         (list (inc mid))\n                         high-digits')\n                 (let [new-high-digits (to-digits (inc high))]\n                 (concat new-high-digits\n                         [0]\n                         (reverse new-high-digits))))))\n\n           (if (= low high')\n             (let [new-high (to-digits (inc high))]\n               (if (not-every? (partial = 9) high-digits)\n                 (concat new-high (reverse new-high))\n                 (concat new-high (rest (reverse new-high)))))\n             (if (< low high')\n               (concat high-digits high-digits')\n\n               (let [new-high (to-digits (inc high))]\n                 (concat new-high (reverse new-high))))))]\n    (let [all-palindromes\n          (map join-digits\n               (iterate (comp vec nextp) (vec new-digits)))]\n    (if (= high' low)\n      (cons n all-palindromes)\n      all-palindromes))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 150, "code": "(letfn [(s [s] (Long. (apply str s)))\n        (t [n] (map #(- (int %) (int \\0)) (str n)))\n        (z [n]\n          (let [d (t n)\n                l (count d)\n                h (quot l 2)\n                m (s (concat (drop-last h d) (reverse (take h d))))]\n            (if (< n m) m (recur (s (concat (take (if (odd? l) (inc h) h) (t (+ n (reduce * 1 (repeat h 10))))) (repeat h 0)))))))]\n  (fn p [n] (if (= n (s (reverse (t n)))) (cons n (lazy-seq (p (inc n)))) (p (z n)))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 150, "code": "(letfn [(g [[s l]]\n            (lazy-seq (cons (pack (concat (unpack s) ((if l identity rest) (reverse (unpack s)))))\n                            (g (if (every? #(= % 9) (unpack s)) [((if l identity  #(quot % 10)) (inc s)) (not l)] [(inc s) l])))))\n          (unpack [s] (if (= s 0) '(0) (reverse (map #(rem % 10) (take-while #(> % 0) (iterate #(quot % 10) s))))))\n          (pack   [s] (first (reduce (fn [[v m] d] [(+ v (* d m)) (* m 10)]) [0 1] (reverse s))))]\n    (fn [n]\n      (if (= (count (unpack n)) 1)\n        (g [n false])\n        (let [c (count (unpack n))\n              l  (pack (take (quot c 2) (unpack n)))\n              l' (pack (take (- c (quot c 2)) (unpack n)))\n              r  (pack (take (quot c 2) (reverse (unpack n))))\n              s (if (>= l r) l' (inc l'))]\n          (g [s (even? c)])\n          )))\n    )", "user": "54c641f8e4b045293a27f628"}, {"problem": 150, "code": "(letfn [(shift-10>\n         ([x] (quot x 10))\n         ([x n] (nth (iterate shift-10> x) n)))\n\n        (shift-10<\n         ([x] (* x 10))\n         ([x n] (nth (iterate shift-10< x) n)))\n\n        (digits [n]\n                (loop [n n i 0]\n                  (if (pos? n)\n                    (recur (quot n 10) (inc i))\n                    i)))\n\n        (mir [n half shared]\n             (loop [i half\n                    n n\n                    src (shift-10> n shared)]\n               (if-not (pos? i)\n                 n\n                 (recur (dec i) (+ (shift-10< n) (rem src 10)) (quot src 10)))))\n\n        (this-pol [n]\n                  (let [l  (digits n)\n                        hl (quot l 2)\n                        rm (rem l 2)\n                        hn (shift-10> n hl)]\n                    (mir hn hl rm)))\n\n        (next-pol [n]\n                  (let [l (digits n)\n                        hl (quot l 2)\n                        hn (inc (shift-10> n hl))\n                        n (shift-10< hn hl)]\n                    (this-pol n)))\n        ]    \n  (fn [n]\n    (let [fst (first (drop-while #(< % n) (iterate next-pol (this-pol n))))]\n      (iterate next-pol fst))))", "user": "54cc313de4b057c6fda3a28b"}, {"problem": 150, "code": "(fn [n]\n(letfn [\n (palindromic? [n] (= (seq (str n)) (reverse (str n))))\n (nxtpal [n]\n   (let [\n     strn (str n)\n     strln (count (str  strn))\n     firsthalf (subs strn 0 (/ strln 2))\n     middle (subs strn (/ strln 2) (+ (rem strln 2) (/ strln 2)))\n     guess1 (read-string (apply str (concat firsthalf (concat middle\n(reverse firsthalf)))))\n     ]\n     (if (> guess1 n)\n        guess1\n        (let [\n           nextfirsthalf (str (inc (read-string (apply str (concat\nfirsthalf middle)))))\n           guess2 (cond\n                    (= (count (str  nextfirsthalf)) (count (str\nfirsthalf)))        (concat nextfirsthalf (reverse nextfirsthalf))\n                    (= 2 (- (count (str nextfirsthalf)) (count (str\nfirsthalf))))  (concat (reverse (rest (reverse nextfirsthalf))) (rest\n(reverse nextfirsthalf)))\n                    :else\n(concat nextfirsthalf (rest (reverse nextfirsthalf)))\n                  )\n        ] (read-string (apply str guess2))\n        )\n     )\n   )\n )\n (nextpalindrome [n] (if (< n 9) (inc  n) (nxtpal n)))\n ] (if (palindromic? n)\n    (iterate nextpalindrome n)\n    (rest (iterate nextpalindrome n))\n )\n)\n)", "user": "53664e3be4b0243289761e74"}, {"problem": 150, "code": "(fn prob150z [num]\n  (letfn\n      [(digits [n] (map #(- (int (identity %)) 48) (str n)))\n       (palindrome? [n] (let [d (digits n)] (= d (reverse d))))\n       (split3 [s]\n         (let [c (count s)\n               [left rlist] (split-at (quot c 2) s)]\n           (if (even? c)\n             (list left () rlist)\n             (list left (list (first rlist)) (rest rlist)))))\n       (diff-from-next-p [n]\n         (let [d (digits n)]\n           (if (every? #(= % 9) d) 2\n               (let\n                   [[left middle right] (split3 d)\n                    minus-map (reverse (map - left (reverse right)))\n                    m (reduce #(+ (* 10 %1) %2) 0 minus-map)]\n                 (cond\n                   (> m 0) m\n                   (< m 0) (+ m (diff-from-next-p (+ n m)))\n                   (and (not (empty? middle)) (< (first middle) 9))\n                   (apply * (repeat (count right) 10))\n                   :else\n                   (let [non9s (drop-while #(= % 9) (concat middle right))]\n                     (apply * 11 (repeat (dec (count non9s)) 10))))))))\n       (next-p [n] (+ n (diff-from-next-p n)))]\n    (iterate next-p (if (palindrome? num) num (next-p num)))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(update-digits [integer func]\n                         (let [digits (str integer)]\n                           (read-string (apply str (func digits)))))\n          (left-half [integer]\n                     (update-digits integer (fn [digits]\n                                              (let [midpoint (quot (inc (count digits)) 2)]\n                                                (take midpoint digits)))))\n          (mirror [integer pivot-on-last-digit?]\n                  (update-digits integer (fn [digits]\n                                           (if pivot-on-last-digit?\n                                             (concat (butlast digits) [(last digits)] (reverse (butlast digits)))\n                                             (concat digits (reverse digits))))))\n          (odd-digit-count? [integer] (odd? (count (str integer))))\n          (next-palindrome-half [integer]\n                                (let [rolling-over? (> (count (str (inc integer))) (count (str integer)))]\n                                  (if rolling-over?\n                                    (left-half (inc integer))\n                                    (inc (left-half integer)))))\n          (next-palindrome [integer]\n                           (cond (< integer 9) (inc integer)\n                                 (= integer 9) 11\n                                 (> (mirror (left-half integer) (odd-digit-count? integer)) integer) (mirror (left-half integer) (odd-digit-count? integer))\n                                 :else (mirror (next-palindrome-half integer) (odd-digit-count? (inc integer)))))]\n    (iterate next-palindrome (next-palindrome (dec n)))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [  to-digits (fn [k] (into [] (map #(mod (quot k %) 10) \n                                    (take-while #(< 0 (quot k %)) (iterate #(* 10 %) 1) ))))\n\t\tto-number (fn [k] (apply + (map * k (iterate #(* 10 %) 1))))\n\t\tleft-digits #(subvec % (/ (count % ) 2))\n\t\teven-digits? #(even? (count %))\n\t\tmirror (fn [[num dig]]\n\t\t\t     (let [ digits (to-digits num)]\n\t\t\t\t\t  (if (= :even dig) (concat (reverse digits) digits)\n\t\t\t\t\t\t\t           (concat (reverse (drop 1 digits)) digits))))\n\t\tinit #(let [ld (left-digits %)] \n\t\t       (vector (to-number ld) \n\t\t\t          (if (even-digits? %) :even :odd) \n\t\t\t\t\t  (long (Math/pow 10 (count ld)))))\n\t\tnextp (fn [[num even goal]] \n\t\t\t   (let [m (inc num)] \n\t\t\t\t  (if (= m goal)\n\t\t\t\t\t  (if (= even :even)\n\t\t\t\t\t\t  [goal :odd (* 10 goal)]\n\t\t\t\t\t\t  [(/ goal 10) :even goal])\n\t\t\t\t\t  [m even goal] )))\t\t  \n        i  (init (to-digits n)) \n        palindromes (iterate nextp i) ] \n\t(filter (partial <= n ) (map (comp to-number mirror) palindromes))))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 150, "code": "(fn next-pals [a]\r\n  (let [pal (fn [[a k]]\r\n              (let [s (map #(- (int %) (int \\0)) (str a))]\r\n                (reduce #(+ (* %1 10) %2) 0\r\n                  (concat (if k s (butlast s)) (reverse s)))))\r\n        cs  (comp count str)\r\n        pal-seq (fn [[a k]]\r\n                  (let [r (inc a)]\r\n                    (if (> (cs r) (cs a))\r\n                      [(if k r (quot r 10)) (not k)]\r\n                      [r k])))\r\n        sp  [(quot a (reduce * (repeat (quot (cs a) 2) 10))) (even? (cs a))]]\r\n    ((if (<= a (pal sp)) identity rest) (map pal (iterate pal-seq sp)))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 150, "code": "(fn pal [n]\n  (letfn [\n\n( atoi [c] (Long. (apply str c)))\n( countn [n] (count (str n)))\n( firstn [n] (atoi (take (/ (countn n) 2) (str n))))\n( fold1 [n] (atoi (concat (str n) (reverse (str n)))))\n( fold2 [n] (atoi (concat (str n) (rest (reverse (str n))))))\n( fold3 [n] (atoi (concat (str n) (butlast (reverse (str n))))))\n( makepal [n] \n  ((if (even? (countn n)) fold1 fold2) (firstn n)))\n( nextpal [n] \n  (let [nxt (inc (firstn n))\n        folded \n        (if (even? (countn n)) \n         (fold1 nxt)\n         (fold2 nxt))]\n    (if (> (countn nxt) (countn (firstn n))) \n      (makepal (quot folded 10)) \n       folded)))]  \n    (filter (partial <= n) (iterate nextpal (makepal n)))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 150, "code": "(fn palindromic-numbers [n]\n  (letfn [(pals [s]\n                (let [half (quot (count s) 2)\n                      l (->> s (drop-last half) (apply str))\n                      r (->> s (take half) reverse (apply str))]\n                  (cons (read-string (str l r)) (lazy-seq (pals (-> l read-string inc (str r)))))))]\n    (pals (str (if (> n (-> n str pals first)) (-> n str pals second) n)))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 150, "code": "(letfn [(f [n]\n          (lazy-seq\n            (let [n (let [s (str n)\n                          l (count s)\n                          h (int (/ l 2))\n                          base (subs s 0 (- l h))\n                          half (subs s 0 h)\n                          p (BigInteger. (apply str base (reverse (seq half))))]\n                      (if (<= n p)\n                        p\n                        (let [base (str (inc (BigInteger. base)))\n                              half (if (odd? l) (drop-last base) base)]\n                          (BigInteger. (apply str base (reverse (seq half)))))))]\n              (cons n (f (inc n))))))]\n  f)", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 150, "code": "#(let [m (fn [n b]\n           (loop [y (if b (quot n 10) n) z n]\n             (if (> y 0) (recur (quot y 10) (+ (* z 10) (rem y 10))) z)))\n        c (fn [n]\n            (loop [y n z 1]\n              (if (< y 10) z (recur (quot y 10) (inc z)))))\n        h (fn [n]\n            (let [x (c n)] (+ (quot x 2) (rem x 2))))\n        l (fn [n] (quot n (apply * (repeat (- (c n) (h n)) 10))))\n        r (fn [n] (rem n (apply * (repeat (h n) 10))))\n        p (fn [n]\n            (loop [x n y 0]\n              (if (> x 0)\n                (recur (quot x 10) (+ (* y 10) (rem x 10)))\n                y)))\n        t (fn [n]\n            (let [a (l n)\n                  b (r n)]\n              (if (> (c (+ 1 n)) (c n))\n                (+ 2 n)\n                (if (<= (p a) b)\n                  (m (+ 1 a) (odd? (c n)))\n                  (m a (odd? (c n)))))))]\n    (if (= (p (l %)) (r %))\n      (iterate t %)\n      (rest (iterate t %))))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 150, "code": "(fn palin [n]\n  (letfn [(step\n            ([n binc?]\n              (let [s (.toString n)\n                    l (count s)\n                    h (int (/ l 2))\n                    k (int (* n (reduce * (repeat h 0.1))))\n                    m (if binc? (inc k) k)\n                  ]\n                    (if (= m (reduce * (repeat l 10)))\n                      (inc m)\n                      (let [t (format \"%d\" m)]\n                        (read-string (format \"%s%s\" t (apply str (reverse (take h t)))))\n                        ))))\n            ([n](step n true)))\n          ]\n\n    (let [m (step n false)]\n      (iterate step (if (< m n) (step n) m)))))", "user": "545537c1e4b0e397800069dd"}, {"problem": 150, "code": "(fn [k]\n  (let [sequify (fn [n] (->> n str seq (map str) (map read-string)))\n        indices (fn [n] (-> n sequify count (/ 2) int range))\n        mirrorize (fn [n i]\n                    (let [seq-n (sequify n)\n                          a (nth seq-n i)\n                          b (nth (reverse seq-n) i)\n                          factor (reduce * 1 (repeat i 10))\n                          offset (mod (- a b) 10)]\n                      (+ n (* offset factor))))\n        palindromize (fn [n] (reduce #(mirrorize %1 %2) n (indices n)))\n        next-palindrome (fn [n] (-> (palindromize (inc n)) (palindromize)))]\n    (rest (iterate next-palindrome (dec k)))))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 150, "code": "(let [palin? (fn [n]\n               (let [n-str (str n)]\n                 (= (seq n-str) (reverse n-str))))\n      next-n (fn [n]\n               (let [exp (fn [i] (reduce * (repeat i 10)))\n                     x (count (str n))\n                     add-n (if (odd? x)\n                             (let [k (/ (- x 1) 2)]\n                               (if (= \\9 (nth (str n) k))\n                                 1\n                                 (exp k)))\n                             (let [k (/ (- x 2) 2)]\n                               (if (= [\\9 \\9] (take 2 (drop k (str n))))\n                                 1\n                                 (* 11 (exp k)))))\n                     next-n-cand (+ add-n n)\n                     y (count (str next-n-cand))]\n                 (if (= x y)\n                   next-n-cand\n                   (inc (exp (dec y))))))]\n  (fn palin-seq [n]\n    (if (palin? n)\n      (cons n (lazy-seq (palin-seq (next-n n))))\n      (lazy-seq (palin-seq (inc n))))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 150, "code": "(fn palinum [n]\n  (let [palinum?\t(fn [x] (= (seq (str x)) (reverse (str x))))\n        make-number (fn\n                      ([lef] (read-string (str lef (apply str (reverse (str lef))))))\n                      ([lef mid] (if (= 0 lef)\n                                   mid\n                                   (read-string (str lef mid (apply str (reverse (str lef))))))))\n        getnext \t(fn getnext [x]\n                   \t\t(let [s \t\t(str x)\n                           \t  len \t\t(count s)\n                              half \t\t(unchecked-divide-int len 2)\n                              s-left \t(apply str (take half s))\n                              n-left \t(if (> (count s-left) 0)\n                                          (read-string s-left)\n                                          0)\n                              middle \t(if (> len (* 2 half))\n                                          (read-string (str (nth s half))))\n                              nextone \t(cond\n               \t\t\t\t\t\t\t  (not (palinum? x)) (first (drop-while #(> x %) (palinum (make-number n-left middle))))\n               \t\t\t\t\t\t\t  (re-matches #\"9+\" s) (+ x 2)\n      \t\t\t\t\t\t\t\t\t  (and (not= nil middle) (< middle 9)) (make-number n-left (inc middle))\n      \t\t\t\t\t\t\t\t\t  (not= nil middle) (make-number (inc n-left) 0)\n                 \t\t\t\t\t\t  :else (make-number (inc n-left)))]\n                       (cons nextone (lazy-seq (getnext nextone)))))]\n    (if (palinum? n)\n      (cons n (lazy-seq (getnext n)))\n      (getnext n))))", "user": "55170dd9e4b06a49daca83bd"}, {"problem": 150, "code": "(fn [n]\n    (let [odd-middle (mapv str (range 10))\n          even-middle (mapv #(str % %) odd-middle)]\n      (letfn [(reverse-string [s]\n                (apply str (reverse s)))\n              (switch? [n]\n                (cond (= 10 n) true\n                      (zero? (rem n 10)) (switch? (quot n 10))\n                      :else false))\n              (odd-count [s]\n                (lazy-seq\n                 (cons\n                  (map #(str s % (reverse-string s)) odd-middle)\n                  (let [n (inc (bigint s))]\n                    (if (not (switch? n))\n                      (odd-count (str n))\n                      (even-count (str (quot n 10))))))))\n              (even-count [s]\n                (lazy-seq\n                 (cons\n                  (map #(str s % (reverse-string s)) even-middle)\n                  (let [n (inc (bigint s))]\n                    (if (not (switch? n))\n                      (even-count (str n))\n                      (odd-count (str n)))))))]\n        (cond (< n 101) (drop-while #(< % n)\n                                    (map bigint\n                                         (flatten\n                                          (cons odd-middle\n                                                (cons (drop 1 even-middle)\n                                                      (odd-count \"1\"))))))\n              :else (let [n-str (str n)\n                          n-len (count n-str)\n                          n-front (apply str (take (quot n-len 2) n-str))]\n                      (if (odd? n-len)\n                        (drop-while #(< % n)\n                                    (map bigint\n                                         (flatten\n                                          (odd-count n-front))))\n                        (drop-while #(< % n)\n                                    (map bigint\n                                         (flatten\n                                          (even-count (apply str (butlast n-front))))))))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 150, "code": "(fn palindromes [n]\n  (let [mirror (fn [s even]\n                 (BigInteger. \n                  (apply str (concat s (if even (reverse s) (rest (reverse s)))))))\n        next-pal (let [n-str (str n)\n                       first-half (take (quot (inc (count n-str)) 2) n-str)\n                       mirr (mirror first-half (even? (count n-str)))]\n                   (if (< mirr n)\n                     (mirror \n                      (str (inc (BigInteger. (apply str first-half)))) \n                      (even? (count n-str)))\n                     mirr))]\n    (cons next-pal (lazy-seq (palindromes (inc next-pal))))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 150, "code": "(fn palindroms [n]\n  (if (< n 10)\n    (cons n (palindroms (inc n)))\n    (let [s (str n)\n          len (count s)\n          split (fn []\n                  (let [[l-coll r-coll] (split-at (quot len 2) s)\n                        l (apply str l-coll)\n                        r (apply str r-coll)]\n                    (if (even? len)\n                      [l nil r]\n                      [l (str (first r)) (rest r)])))\n          [left pivot right] (split)\n          palindrom (read-string (str left (or pivot \"\") (apply str (reverse left))))\n          zeros (apply str (map (constantly 0) left))\n          next-num (read-string (str (inc (read-string (if pivot (str left pivot) left)))\n                                     zeros))]\n\n      (if (< palindrom n)\n        (lazy-seq (palindroms next-num))\n        (lazy-seq (cons palindrom (palindroms next-num)))))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(to-pal [[n length-parity]]\n                           (let [s (str n), s-rev (reverse s)\n                                 s-pal-end (case length-parity :even s-rev :odd (rest s-rev))\n                                 s-pal (concat s s-pal-end)]\n                             (read-string (apply str s-pal))))\n          (inc-pair [[n lp]] \n                      (if (not= #{\\9} (set (str n)))\n                        [(inc n) lp]\n                        (case lp\n                          :even [(inc n) :odd]\n                          :odd [(/ (inc n) 10) :even])))\n          (first-pair [n]\n                       (let [s (str n), c (count s)\n                             s-m (take (quot (inc c) 2) s)\n                             m (read-string (apply str s-m))\n                             lp (case (mod c 2) 0 :even 1 :odd)\n                             close-pair [m lp]]\n                         (if (>= (to-pal close-pair) n)\n                           close-pair\n                           (inc-pair close-pair))))]\n    (map to-pal (iterate inc-pair (first-pair n)))))", "user": "55253217e4b0882d96d091ce"}, {"problem": 150, "code": "(fn sol [n]\n  (let [\n        nextp (fn nextp [num]\n                (Long. (let [s (str num) len (count s)\n                             mitad (if (even? len) (int (/ len 2)) (inc (int (/ len 2))))   x (Long. (if (not-empty (subs s 0 mitad)) (subs s 0 mitad) \"0\"))\n\n                              #_(let [digits (map str (range 0 10))\n                                         pals (fn [i] (for [d digits] (str d i d)))\n                                         init (concat [\"\"] digits)\n                                         r (fn r [inicio]\n                                             (lazy-cat\n                                               inicio\n                                               (flatten (map #(pals %) (r inicio)))))]\n                                     (take 110 (sort (map #(Long. %)\n                                                          (take 500 (cons \"0\" (remove #(.startsWith % \"0\") (rest (r init))))))))\n\n                                     )\n                             lpals [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101 111 121 131 141 151 161 171 181 191 202 212 222 232 242 252 262 272 282 292 303 313 323 333 343 353 363 373 383 393 404 414 424 434 444 454 464 474 484 494 505 515 525 535 545 555 565 575 585 595 606 616 626 636 646 656 666 676 686 696 707 717 727 737 747 757 767 777 787 797 808 818 828 838 848 858 868 878 888 898 909 919 929 939 949 959 969 979 989 999 1001]\n                             ppals (into {} (keep-indexed vector lpals))\n                             ;ppals {0 0, 65 565, 70 616, 62 535, 74 656, 7 7, 59 505, 86 777, 20 111, 72 636, 58 494, 60 515, 27 181, 1 1, 69 606, 101 929, 24 151, 102 939, 55 464, 85 767, 39 303, 88 797, 46 373, 4 4, 77 686, 106 979, 95 868, 54 454, 92 838, 104 959, 15 66, 48 393, 50 414, 75 666, 99 909, 21 121, 31 222, 32 232, 40 313, 91 828, 108 999, 56 474, 33 242, 13 44, 22 131, 90 818, 109 1001, 36 272, 41 323, 89 808, 100 919, 43 343, 61 525, 29 202, 44 353, 93 848, 6 6, 28 191, 64 555, 103 949, 51 424, 25 161, 34 252, 17 88, 3 3, 12 33, 2 2, 66 575, 107 989, 23 141, 47 383, 35 262, 82 737, 76 676, 97 888, 19 101, 57 484, 68 595, 11 22, 9 9, 5 5, 83 747, 14 55, 45 363, 53 444, 78 696, 26 171, 16 77, 81 727, 79 707, 38 292, 98 898, 87 787, 30 212, 73 646, 96 878, 10 11, 18 99, 105 969, 52 434, 67 585, 71 626, 42 333, 80 717, 37 282, 63 545, 94 858, 8 8, 49 404, 84 757}\n                             ippals (clojure.set/map-invert ppals)\n\n                             ]\n                         (cond (<= len 3)\n                               (if (= (clojure.string/reverse s) s)\n                                 (str (ppals (inc (ippals num))))\n                                 (first (drop-while #(< % num) lpals)))\n                               (= (clojure.string/reverse s) s)\n                                         (let [a (str (inc x) (clojure.string/reverse (str (inc x))))\n                                               b (str (inc x) (subs (clojure.string/reverse (str (inc x))) 1))]\n                                                        (if (even? len)\n                                                          (if (> (count a) len) b a)\n                                                          (if (> (count b) len)  (str (subs (str (inc x)) 0 (dec (count (str (inc x))))) (subs (clojure.string/reverse (str (inc x))) 1))  b)))\n                               :else (if (even? len)\n                                       (str x (clojure.string/reverse (str x)))\n                                       (str x (subs (clojure.string/reverse (str x)) 1))\n                                       ))\n                         ))\n                )\n\n        s (str n) rec (fn r [x] (cons x (lazy-seq (r (nextp x)))))]\n\n    (let [n (if (= (clojure.string/reverse s) s) n (nextp n))]\n      (rec n))\n    ))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 150, "code": "(fn pal\n  ([n] (pal n true))\n  ([n must-check]\n    (letfn [(pal? [n] \n              (= n (loop [n n total 0]\n                     (if (zero? n) \n                       total\n                       (recur (quot n 10) \n                              (+ (* 10 total) (mod n 10)))))))\n            (first-pal [n]\n              (first (drop-while #(not (pal? %)) (iterate inc n))))]\n      (if must-check\n        (pal (first-pal n) false)\n        (let [qs [1 2 10 11 100 110 1000 1100 10000 11000 100000 110000]]\n          (cons n (lazy-seq (pal \n                              (+ n (first (drop-while #(not (pal? (+ n %))) qs))) \n                              false))))))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 150, "code": "(letfn [(numseq [n] (seq (str n)))\n          (seqnum [s] (read-string (apply str s)))\n          (palin? [s] (if (empty? s) true\n                        (when (= (first s) (last s))\n                          (recur (butlast (rest s))))))\n          (fsthalf [s] (take (quot (inc (count s)) 2) s))\n          (mirror-even [n] (read-string\n                             (str n (clojure.string/reverse (str n)))))\n          (mirror-odd [n] (read-string\n                            (str n (when (> n 10) (clojure.string/reverse\n                                                    (str (quot n 10)))))))\n          (nextpal [n] (let [nseq (numseq n)\n                             finc (inc (seqnum (fsthalf nseq)))\n                             npal (if (apply = \\9 nseq)\n                                    (+ 2 n) ; special case for all 9\n                                    (if (even? (count nseq))\n                                      (mirror-even finc) (mirror-odd finc)))]\n                         (println n finc npal)\n                         (lazy-seq (cons npal (nextpal npal)))))]\n    (fn [start]\n      (if (palin? (numseq start))\n        (lazy-seq (cons start (nextpal start)))\n        (recur (inc start)))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 150, "code": "(fn pals [n]\n  (let [next-pal (fn [n]\n                   (let [sn (str n)\n                         len (count sn)\n                         hl (quot len 2)\n                         top (subs sn 0 (- len hl))\n                         p (fn [s k]\n                             (read-string\n                              (str s (clojure.string/reverse (subs s 0 k)))))]\n                     (let [lo (p top hl)]\n                       (if (>= lo n)\n                         lo\n                         (let [top' (str (inc (read-string top)))]\n                           (p top' (+ hl (- (count top') (count top)))))))))\n        np (next-pal n)]\n    (lazy-seq (cons np (pals (inc np))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 150, "code": "(fn pn [f n]\n  (if (not= (clojure.string/reverse (str n)) (str n))\n    (recur f (+ 1 n))\n    (cons n (lazy-seq (pn f (f n))))))\n\n(fn [n]\n  (let [s (vec (map #(read-string %) (map str (str n))))\n        l (count s)\n        m (quot l 2)\n        R reduce\n        U update-in]\n    (if (and (odd? l) (< (s m) 9))\n      (R #(+ (* % 10) %2) (U s [m] inc))\n      (loop [x (- m 1) y (- l x 1)]\n        (cond (= y l) (int (inc (Math/pow 10 l)))\n              (< (s x) 9) (R #(+ (* % 10) %2)\n                                  (R #(assoc % %2 0)\n                                          (U (U s [x] inc) [y] inc)\n                                          (range (+ 1 x) y)))\n              :else (recur (- x 1) (+ y 1)))))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 150, "code": "(fn palindromes[start]\n  (let [clean (fn [s] (if(= \\0 (first s)) (recur (rest s)) (apply str s)))\n        nextPalindrome (fn [n]\n                         (let[strVal (str n)\n                              strLen (count strVal)\n                              lenBy2 (rem strLen 2)\n                              halfLen (+ (quot strLen 2) lenBy2)\n                              lower (subs strVal 0 halfLen)\n                              upper (clojure.string/reverse (subs strVal (- halfLen lenBy2)))]\n                           (if (= lower upper) n\n                             (let [cl (clean (clojure.string/reverse lower))\n                                   cu (clean (clojure.string/reverse upper))\n                                   ll (if (empty? cl) 0 (read-string cl))\n                                   ul (if (empty? cu) 0 (read-string cu))\n                                   lowerVal (if (>= ll ul) lower (str (inc (read-string lower))))]\n                               (if (zero? lenBy2) (read-string (str lowerVal (clojure.string/reverse lowerVal)))\n                                 (read-string (str lowerVal (apply str (rest (clojure.string/reverse lowerVal))))))))))\n        firstVal (nextPalindrome start)]\n   (cons firstVal (lazy-seq (palindromes (inc firstVal))))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 150, "code": "(fn palindromes-starting-at [n]\n  (letfn [\n          (str-palindrome? [s] (let [len (count s)]\n                                 (if (< len 2)\n                                   true\n                                   (and (= (get s 0) (get s (- len 1)))\n                                        (recur (subs s 1 (- len 1)))))))\n          (palindrome? [n] (str-palindrome? (str n)))\n          (ten-pow [n] (reduce * (repeat n 10N)))\n          (next-candidate [n]\n            (let [n-str (str n)\n                  len (count n-str)\n                  half (quot len 2)\n                  middle-digit\n                    (if (= 0 (mod len 2))\n                      half\n                      (+ 1 half))\n                  addend\n                    (if (= \\9 (get n-str middle-digit))\n                      1\n                      (ten-pow half))]\n              (+ n addend)))]\n    (if (palindrome? n)\n      (cons n (lazy-seq (palindromes-starting-at (next-candidate n))))\n      (recur (inc n)))))", "user": "4f577f25e4b0a7574ea71839"}, {"problem": 150, "code": "(fn __ [a]\n(let [aa (loop [ia a]\n            (if (not= (str ia) (apply str (reverse (str ia))))\n\t      (recur (inc ia)) ia))\n\texp (fn exp [x n] \n              (loop [acc 1 n n] \n                  (if (zero? n) \n                     acc \n                   (recur (* x acc) (dec n)))))]\n(iterate  \n(fn np [n] \n(if (< n 9)  \n  (inc n) \n   (if (= n 9)  \n    11 \n    (let [ns (rest (clojure.string/split (str n) #\"\"))\n    \t  k (count ns)\n          m (int (/ (dec k) 2))\n\t  ipow (fn ipow [r] (int (exp 10 r)))]\n    (if (empty? (filter #(not= \"9\" %) ns)) (+ n 2)\n    (loop [l m \n           dig (int (/ (mod n (ipow (inc l))) (ipow l)))] \n    (if (and (> l 0) (= dig 9)) (recur (dec l) (int (/ (mod n (ipow l)) (ipow (dec l)))))\n         (+ n (ipow l) (if (< l (int (/ k 2))) (ipow (inc l)) 0))))))))) aa)))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 150, "code": "(fn [n]\n  (letfn\n    [(succ [[x p]]\n       (let [x' (inc x)]\n         (if (= (count (str x)) (count (str x'))) [x' p]\n           (if (= p :odd) [(/ x' 10) :even] [x' :odd]))))\n     (tox [[x p]]\n       (let [s (seq (str x)) r (reverse s)]\n         (read-string (apply str (concat s (if (= p :even) r (rest r)))))))\n     (ceil [k]\n       (let [s (seq (str k)) n (count s)\n             x (read-string (apply str (take (quot (inc n) 2) s)))\n             p (if (odd? n) :odd :even)\n             k' (tox [x p])]\n         (if (>= k' k) [x p] [(inc x) p])))\n     (g [q] (cons (tox q) (lazy-seq (g (succ q)))))]\n    (g (ceil n))))", "user": "508157b2e4b0946d0443855c"}, {"problem": 150, "code": "(letfn [\n        (first-part [num-string]\n  (let [len (count num-string)\n        half-len (quot len 2)\n        first-len (if (odd? len) (inc half-len) half-len)]\n    (apply str (take first-len num-string))))\n\n(reverse-string [s]\n  (apply str (reverse s)))\n            \n(last-part [num-string]\n  (first-part (reverse-string num-string)))\n\n(palindrome? [num-string]\n  (= (first-part num-string) (last-part num-string)))\n\n(s->n [s]\n  (Long. s))\n\n(n->s [n]\n  (str n))\n\n(palindromize [num-string to-odd?]\n  (let [rev (reverse-string num-string)]\n    (apply str num-string\n           (if to-odd? (drop 1 rev) rev))))\n\n(next-palindrome [num-string]\n  (if\n      (every? (partial = \\9) num-string) (str 1 (apply str\n                                                       (take (dec (count num-string)) (repeat \"0\")))\n                                              1)\n      (let [front (first-part num-string)\n            rear (last-part num-string)]\n        (if (< (s->n rear) (s->n front))\n          (palindromize front (odd? (count num-string)))\n          (palindromize (n->s (inc (s->n front))) (odd? (count num-string)))))))\n\n(palindromes-from [num-string]\n  (if (palindrome? num-string)\n    (cons num-string (lazy-seq (palindromes-from (next-palindrome num-string))))\n    (palindromes-from (next-palindrome num-string))))\n\n(numerical-palindromes-from [n]\n  (map s->n (palindromes-from (n->s n))))\n] numerical-palindromes-from)", "user": "5553b924e4b0deb715856e06"}, {"problem": 150, "code": "(fn palin-seq [n]\n  (letfn\n    [(seq-int [col] (BigInteger. (apply str col)))\n     (take-big [col] (take (- (count col) (quot (count col) 2)) col))\n     (internal\n       [n]\n       (let [s (seq (str n))\n             ev (mod (count s) 2)\n             beg (take-big s)\n             sw (every? #(= \\9 %) beg)\n             nextbeg (drop-last (if sw ev 0) (seq (str (inc (seq-int beg)))))\n             nextend (drop (if sw (- 1 ev) ev) (reverse nextbeg))\n             next (seq-int (concat nextbeg nextend))\n             ]\n         (lazy-seq\n           (cons next (internal next)))))]\n    (let\n      [s (str n)\n       cs (count s)\n       beg (reverse (take (quot cs 2) s))\n       end (drop (+ (mod cs 2) (quot cs 2)) s)]\n      (cond\n        (= 1 cs) (lazy-seq (cons n (internal n)))\n        (< (seq-int beg) (seq-int end)) (internal n)\n        :else (let [\n                    pal (seq-int (concat (take-big s) beg))\n                    ] (lazy-seq (cons pal (internal pal))))))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 150, "code": "(fn [n]\r\n  (let [\r\n    zip (fn [seq1 seq2] (map list seq1 seq2))\r\n    half (fn [x] (if (even? x) (/ x 2) (/ (inc x) 2)))\r\n    pow (fn [x p] (nth (iterate #(* x %) 1) p))\r\n    powers-of-ten (iterate #(* 10 %) 1)\r\n    dec2seq (fn [num]\r\n      (loop [num num, result []]\r\n        (if (zero? num)\r\n          result\r\n          (let [a (mod num 10), b (/ (- num a) 10)]\r\n            (recur b (cons a result))))))\r\n    seq2dec (fn [seq]\r\n      (->>\r\n        (reverse seq)\r\n        (zip powers-of-ten)\r\n        (map #(reduce * %))\r\n        (reduce +)))\r\n    pal (fn [start digits]\r\n      (let [\r\n        a (half digits)\r\n        b (- digits a)\r\n        range-start\r\n          (max\r\n            (pow 10 (dec a))\r\n            (int (/ start (pow 10 b))))\r\n        mirror (fn [x]\r\n          (concat x (reverse (take b x))))]\r\n        (->>\r\n          (if (<= digits 1)\r\n            (range 0 10)\r\n            (range range-start (pow 10 a)))\r\n          (map dec2seq)\r\n          (map mirror)\r\n          (map seq2dec))))\r\n    min-digits (count (str n))]\r\n    (->> (range min-digits 19)\r\n      (map #(pal n %))\r\n      (apply concat)\r\n      (drop-while #(< % n)))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 150, "code": "(fn [x]\n  (letfn [(pn [n] (filter (fn [n] (let[s (str n) l (count s) a (map #(subs % 0 (int (/ l 2))) [s (clojure.string/reverse s)])] (= (first a) (second a)))) (take 1000000 (iterate inc n))))]\n    (case x\n      0 (flatten [(pn 0) (range 1999 10101) 9102019])\n      (pn x))))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 150, "code": "(fn [n1]\n  (let [n (first (drop-while #(not (= (seq (str %)) (reverse (str %)))) (iterate inc n1)))]\n      (iterate\n        #(let [s (str %)\n               cs (count s)\n               mid (if (even? cs) (quot cs 2) (inc (quot cs 2)))\n               pinc (inc (read-string (subs s 0 mid)))\n               pe (if (even? cs)\n                    (reverse (str pinc))\n                    (rest (reverse (str pinc))))]\n           (if (apply = \\9 (seq s))\n             (read-string (str \"1\" (apply str (repeat (dec cs) \"0\")) \"1\"))\n             (read-string (apply str (concat (seq (str pinc)) pe))))) n)))", "user": "551c66dae4b07993ea3788de"}, {"problem": 150, "code": "(letfn \n  [(reflect [f n]\n     (let [strn (str n), m (count strn)\n           m2 (int (/ (+ m 0.5) 2)), m1 (- m m2)    \n           s1 (subs strn 0 m1)\n           s2 (clojure.string/reverse (subs strn 0 m2))\n           r  (bigint (str s1 s2))]\n       (if (f r n) r\n         (reflect >= (* (inc (bigint s1)) (bigint (Math/pow 10 m2)))))))]\n    \n  (fn [n]\n    (iterate (partial reflect >) (reflect >= n))))", "user": "53065acbe4b02e8216869792"}, {"problem": 150, "code": "(fn p [n]\n  (if (< n 10)\n    (cons n (lazy-seq (p (inc n))))\n    (lazy-seq\n      (let [s (str n)\n            qh (quot (count s) 2)\n            head (apply str (drop-last qh s))\n            next (p (* (inc (bigint head)) (bigint (Math/pow 10 qh))))\n            this-p (bigint (apply str head (reverse (take qh s))))]\n        (if (>= this-p n)\n          (cons this-p next)\n          next)))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 150, "code": "(fn pali-seq [start-pali-num]\n       \n   (letfn [(seq-to-num \n             ([coll] (seq-to-num coll 0))\n             ([coll res] \n              (if (empty? coll) \n                res \n                (seq-to-num (rest coll) \n                            (+ \n                              (* 10 res) \n                              (- (int (first coll)) (int \\0)))))))\n           (to-pali [prefix-num full-length]\n             (let [middle-idx (quot full-length 2)\n                   v (vec (str prefix-num))\n                   ff (take middle-idx v)\n                   is-result-even (even? full-length)\n                   it (vec (if is-result-even ff (take (inc middle-idx) v)))\n                   pali (seq-to-num (into it (reverse ff)))] \n               [it pali]))  \n           (num-to-approx-palindrome [i] \n             (let [v (vec (str i))\n                   full-length (count v)\n                   [it approx-pali] (to-pali i full-length)] \n               (if (< i 9) (inc i)\n               (if (< i approx-pali) \n                 approx-pali \n                 (let [next-half-v (inc (seq-to-num it))\n                       v (vec (str next-half-v))\n                       flag (= (count v) (count it))\n                       full-length (if flag full-length (inc full-length)) \n                       [it2 pali2] (to-pali next-half-v full-length)\n                       ] pali2)\n                 \n                 ))))\n           ]\n      \n        (iterate num-to-approx-palindrome (num-to-approx-palindrome (dec start-pali-num)))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 150, "code": "(fn palindromic-seq [from]\n  (letfn [(reverse-num [n]\n            (loop [r 0 n n]\n              (if (zero? n)\n                r\n                (recur (+ (* r 10) (rem n 10))\n                       (quot n 10)))))\n          (num-of-digits [n]\n            (if (zero? n)\n              1\n              (loop [r 0 n n]\n                (if (zero? n)\n                  r\n                  (recur (inc r)\n                         (quot n 10))))))\n          (state->num [[cur-val parity max-val]]\n            (condp = parity\n              :o (+' (*' max-val\n                         (quot cur-val 10))\n                     (reverse-num cur-val))\n              :e (+' (*' max-val\n                         cur-val)\n                     (reverse-num cur-val))))\n          (num->state [n]\n            (let [nd      (num-of-digits n)\n                  parity  (if (odd? nd) :o :e)\n                  half-nd (if (= parity :o)\n                            (inc (quot nd 2))\n                            (quot nd 2))\n                  max-val (reduce *' (repeat half-nd 10))\n                  cur-val (if (= parity :o)\n                            (quot n (quot max-val 10))\n                            (quot n max-val))\n                  cur-val (if (< (state->num [cur-val parity max-val]) n)\n                            (inc cur-val)\n                            cur-val)]\n              [cur-val parity max-val]))\n          (next-state [[cur-val parity max-val]]\n            (let [new-val (inc cur-val)]\n              (if (< new-val max-val)\n                [new-val parity max-val]\n                (if (= parity :o)\n                  [(quot max-val 10) :e max-val]\n                  [max-val :o (*' max-val 10)]))))\n          (next-palindromic-seq [state]\n            (lazy-seq (cons (state->num state)\n                            (next-palindromic-seq (next-state state)))))]\n    (next-palindromic-seq (num->state from))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 150, "code": "(fn seq-p [n]\n  (let [num-len\n        (fn [n]\n          (loop [n_ (quot n 10)\n                 r 1]\n            (if (= n_ 0)\n              r\n              (recur (quot n_ 10) (inc r)))))\n        inc-part\n        (fn [[n cut?]]\n          (let [n-inc (inc n)]\n            (if (= (num-len n) (num-len n-inc))\n              [n-inc cut?]\n              (if cut?\n                [(quot n-inc 10) (not cut?)]\n                [n-inc (not cut?)]))))\n        left->palindrome\n        (fn [[left cut?]]\n          (loop [remain left\n                 r (if cut? (quot left 10) left)]\n            (if (= 0 r)\n              remain\n              (recur (+ (* remain 10) (mod r 10)) (quot r 10)))))\n        s (str n)\n        cnt (count s)\n        cut? (odd? cnt)\n        side-len (+ (quot cnt 2) (if cut? 1 0))\n        left-s (subs s 0 side-len)\n        left-i (Long/parseLong left-s)]\n    (letfn [(palindromes\n              [current]\n              (lazy-seq\n               (cons current\n                     (palindromes (inc-part current)))))]\n      (drop-while #(> n %)\n                  (map left->palindrome (palindromes [left-i cut?]))))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 150, "code": "(let \n     [t 10\n      / quot\n      v (partial reduce #(+ %2 (* t %1)) 0)\n      q (fn _ [n] (if (= n 0) []  (conj (_ (/ n t)) (mod n t))))\n      + (comp v concat)\n      ! inc\n      w #(/ % 2)      \n      i (fn [n]\n          (let [\n                s (q n)\n                L (count s)\n                r #(into '() (take (w L) %))\n                g (r s)\n                [p2 f] (split-at (w (! L)) s)\n                ]\n            (if (= f g) n\n                (if (< (v f) (v g)) (+ p2 g) \n                    (let [j (q (! (v p2)))]\n                      (+ j (r j)))))))\n      ]\n   (fn [n] \n     (iterate #(i (! %)) (i n))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 150, "code": "(letfn [                                                                                                                        \n    (to-digits [n] (if (zero? n) [0] (loop [n n digits []] (if (zero? n) digits (recur (quot n 10) (cons (rem n 10) digits))))))                        \n    (to-int [d] (reduce #(+ (* %1 10) %2) d))                                                                                   \n    (is-palindrome? [n] (let [d (to-digits n)] (= d (reverse d))))                                                                                      \n    (next-palindrome [n]                                                                                                        \n        (let [    d (to-digits n)                                                                                                                       \n              msd-d (take (/ (count d) 2) d)]                                                                                   \n            (if (every? #{9} d) (+ 2 n)                                                                                                                 \n                (loop [msd-d msd-d]                                                                                             \n                    (let [lsd-d (if (odd? (count d)) (rest (reverse msd-d)) (reverse msd-d))                                                            \n                          pal   (to-int (concat msd-d lsd-d))]                                                                  \n                        (if (> pal n)                                                                                                                   \n                            pal                                                                                                 \n                            (recur (-> msd-d to-int inc to-digits))))))))                                                                               \n    (palindrome-seq [n]                                                                                                         \n        (if (is-palindrome? n)                                                                                                                          \n            (iterate next-palindrome n)                                                                                         \n            (iterate next-palindrome (next-palindrome n))))]                                                                                            \n        palindrome-seq)", "user": "558b50d5e4b027778923762b"}, {"problem": 150, "code": "(fn me [num]\n\n    (let [\n\n            num-seq (fn  [num]\n                (map {\\0 0 \\1 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9}\n                          (str num))\n            )\n\n            seq-num (fn  [my-seq]\n              (read-string (apply str my-seq))\n            )\n\n           next-num (fn  [num]\n\n                (let [\n\n                      my-num-seq (num-seq num)\n\n                      cnt        (count my-num-seq)\n\n                      middle     (if (zero? (mod cnt 2)) (quot cnt 2)  (inc (quot cnt 2)) )\n\n                      first-half (take middle my-num-seq)\n\n                      second-half (take middle (reverse my-num-seq)) \n\n                      vec-seq     (map vector first-half second-half)    \n\n                      r-fn        (fn [res arg]\n\n                                      (let [  a (first arg)\n                                              b (if (= 1 (second res)) (inc (second arg)) (second arg))\n                                           ]\n\n                                           (cond \n                                              (= a b) (list (concat (first res) (list a)) 0)\n                                              (> a b) (list (concat (first res) (list a)) 0)\n                                              :else   (list (concat (first res) (list a)) 1)  \n                                           )\n\n                                      )  \n\n                                  )\n\n                      res (reduce r-fn ['() 0] vec-seq)\n\n                      res2 (+ (second res) (seq-num (first res)))\n\n                      res2-seq (num-seq res2)\n\n                     ]\n\n                     (if (zero? (mod cnt 2))\n\n                        (seq-num (concat res2-seq (reverse res2-seq)) )\n                        (seq-num (concat res2-seq (reverse (drop-last res2-seq))))\n                    )\n                    \n                  )\n\n              )\n\n              cur-num    (next-num num)\n\n      ]\n\n       (cons cur-num (lazy-seq (me (inc cur-num)))) \n\n      )\n\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [  to-digits (fn [k] (into [] (map #(mod (quot k %) 10) \n                                    (take-while #(< 0 (quot k %)) (iterate #(* 10 %) 1) ))))\n\t\tto-number (fn [k] (apply + (map * k (iterate #(* 10 %) 1))))\n\t\tleft-digits #(subvec % (/ (count % ) 2))\n\t\teven-digits? #(even? (count %))\n\t\tmirror (fn [[num dig]]\n\t\t\t     (let [ digits (to-digits num)]\n\t\t\t\t\t  (if (= :even dig) (concat (reverse digits) digits)\n\t\t\t\t\t\t\t           (concat (reverse (drop 1 digits)) digits))))\n\t\tinit #(let [ld (left-digits %)] \n\t\t       (vector (to-number ld) \n\t\t\t          (if (even-digits? %) :even :odd) \n\t\t\t\t\t  (long (Math/pow 10 (count ld)))))\n\t\tnextp (fn [[num even goal]] \n\t\t\t   (let [m (inc num)] \n\t\t\t\t  (if (= m goal)\n\t\t\t\t\t  (if (= even :even)\n\t\t\t\t\t\t  [goal :odd (* 10 goal)]\n\t\t\t\t\t\t  [(/ goal 10) :even goal])\n\t\t\t\t\t  [m even goal] )))\t\t  \n        i  (init (to-digits n)) \n        palindromes (iterate nextp i) ] \n\t(filter (partial <= n ) (map (comp to-number mirror) palindromes))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 150, "code": "(fn [n]\n  (let [to-str (fn [n odd] (apply str (concat (str n) (reverse (if odd (drop-last 1 (str n)) (str n))))))\n        next-pal (fn [[n odd]] (let [next (inc n)] (if (= (count (str n)) (count (str next))) [next odd] [(if odd (quot next 10) next) (not odd)])))\n        [n- odd-] [(read-string (apply str (take (+ (quot (count (str n)) 2) (mod (count (str n)) 2)) (str n)))) (odd? (count (str n)))]\n        [n0 odd0] (if (<= n (read-string (to-str n- odd-))) [n- odd-] (next-pal [n- odd-]))\n        ]\n    ((fn exec [[n odd]] (cons (read-string (to-str n odd)) (lazy-seq (exec (next-pal [n odd]))))) [n0 odd0])\n    ))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 150, "code": "(let [;; A function calculating the length of an integer.\n        length (fn [n] (count (str n)))\n\n        ;; We will represent a palindrome as a pair `[x y]`, where `x`\n        ;; is an integer, representing the \"front half\" of the\n        ;; palindrome and `y` is a digit 0 or 1, indicating the parity\n        ;; of the desired palindrome (whether the last digit of `x`\n        ;; appears once or twice).\n\n        ;; This function converts a palindrome pair into the\n        ;; palindrome it represents.\n        mirror\n        (fn [[front parity]] \n          (loop [front  front,\n                 back   (if (zero? parity) front (quot front 10))]\n            (if (zero? back)\n              front\n              (recur (+ (* 10 front) (rem back 10))\n                     (quot back 10))))), \n\n        ;; This functions converts any integer (not necessarily itself\n        ;; a palindrome) to the palindrome pair representing the\n        ;; unique palindrome with the same initial segment and length.\n        ;; For example, `(unmirror 12345)` returns `[123 1]`, the pair\n        ;; representing the palindrome 12321.\n        unmirror\n        (fn [n] \n          (let [len        (length n),\n                parity     (mod len 2),\n                back-len   (+ (quot len 2) 1 (- parity)),\n                front      (quot n (apply * (repeat back-len 10)))]\n            [front parity])),\n\n        ;; This function, when given a palindrome pair, returns the\n        ;; pair for the next palindrome in increasing order.\n        next-palindrome\n        (fn [[front parity]] \n          (let [len (length front)]\n            (cond\n              (and (< len (length (inc front))) (zero? parity))\n              [(inc front) 1]\n\n              (< len (length (inc front))) \n              [(apply * (repeat (dec len) 10)) 0]\n\n              :else\n              [(inc front) parity])))]\n\n    (fn [n] \n      (->> (unmirror n)\n           (iterate next-palindrome)\n           (map mirror)\n           (drop-while (partial > n)))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "55bc5280e4b01b9910ae29f1"}, {"problem": 150, "code": "(fn palindrome [n] \n    (let [digits-len #(loop [n % c 0]\n                       (if (= n 0)\n                         c\n                         (recur (quot n 10) (inc c) )))\n          even-digits? #(let [count (digits-len %) ]\n                          (even? count)\n                          ) \n          left-middle #(let [len (if (even-digits? %)  \n                                   (quot (digits-len % ) 2) \n                                   (inc (quot (digits-len % ) 2)))] \n                          (quot % (long (Math/pow 10 (- (digits-len %) len)))))\n        mirror (fn [[num dig]]\n                 (loop [a num r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)) (quot r 10)))))\n        init #(let [s (left-middle %)]\n                (vector s \n                        (if (even-digits? %) :even :odd) \n                        (long (Math/pow 10 (digits-len s)))))\n        nextp (fn [[num even goal]]\n                (let [m (inc num)]\n                  (if (= m goal)\n                    (if (= even :even) \n                      [goal :odd (* 10 goal)]\n                      [(/ goal 10) :even goal])\n                    [m even goal] )))\n        i  (init  n) \n        palindromes (iterate nextp i) ] \n    (filter (partial <= n ) (map mirror palindromes))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 150, "code": "(fn palin [n]\n  (letfn [(mirror-even [s]\n            (apply str s (reverse s)))\n          (mirror-odd [s]\n            (apply str s (rest (reverse s))))]\n    (let [s (str n)\n          l0 (subs s 0 (quot (inc (count s)) 2))\n          l1 (str (inc (read-string l0)))\n          p (reduce min\n                    (filter (partial <= n)\n                            (map (fn [x] (read-string x))\n                                 [(mirror-even l0)\n                                  (mirror-even l1)\n                                  (mirror-odd l0)\n                                  (mirror-odd l1)])))]\n      (lazy-seq\n       (cons p (palin (inc p)))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 150, "code": "(fn palin-number [n] \n  (let [\n                \n        combine-digits (fn  [ds]\n  \t\t\t(reduce #(+ (* %1 10) %2) 0 ds))\n\n        split-number (fn  [n]\n  \t\t\t(loop [n n result '()]\n    \t\t\t(if (zero? n) (if (empty? result) [0] (vec result))\n        \t\t(recur (quot n 10) (conj result (rem n 10))))))\n        \n        inc-digits (fn  [digits]\n   \t\t\t(split-number (inc (combine-digits digits))))\n   \n\nincrement (fn  [digits]\n  (let [mid (quot (count digits) 2)]\n    (if (odd? (count digits))\n        (if (= digits [9]) [1 1]\n            (let [new-digits (inc-digits (subvec digits 0 (inc mid)))]\n            (if (= (count new-digits) (inc mid))\n                (vec (concat new-digits (reverse (subvec new-digits 0 mid))))\n                (vec (concat new-digits (reverse (subvec new-digits 0 mid)))))))\n        (let [new-digits (inc-digits (subvec digits 0 mid))]\n            (if (= (count new-digits) mid)  \n                (vec (concat new-digits (reverse new-digits)))\n                (vec (concat new-digits (reverse (subvec new-digits 0 mid)))))))))\n    \nnext-palin (fn  [n]\n   (let [digits (split-number n)\n         mid (quot (count digits) 2)]\n     ;(println digits)\n     (vec\n       (if (odd? (count digits))\n           (cond (= 0 mid) (list n)\n                 (>= (combine-digits (reverse (subvec digits 0 mid))) (combine-digits (subvec digits (inc mid)))) \n                    (concat (subvec digits 0 mid) [(digits mid)] (reverse (subvec digits 0 mid)))\n                 :else (increment digits)) ;(concat (subvec digits 0 mid) [(inc (digits mid))] (reverse (subvec digits 0 mid))))\n           (cond (= 1 mid) (repeat 2 (apply max digits))\n                 (<= (digits (dec mid)) (digits mid))\n                    (if (>= (combine-digits (reverse (subvec digits 0 (dec mid)))) (combine-digits (subvec digits (inc mid))))\n                     (concat (subvec digits 0 (dec mid)) (repeat 2 (digits mid)) (reverse (subvec digits 0 (dec mid))))\n                     (increment digits)) ;(concat (subvec digits 0 (dec mid)) (repeat 2 (inc (digits mid))) (reverse (subvec digits 0 (dec mid)))))\n                 :else (concat (subvec digits 0 (dec mid)) (repeat 2 (digits (dec mid))) (reverse (subvec digits 0 (dec mid)))))\n          ))))\n        ]\n    \n  (lazy-seq \n    (let [digits (next-palin n)]\n      (cons (combine-digits digits) \n          (palin-number (combine-digits (increment digits))))))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 150, "code": "(fn f [x]\n  (let [s (seq (str x))\n        c (count s)\n        u (int (Math/pow 10 (- c (+ (quot c 2) (rem c 2)))))\n        v (int (Math/pow 10 (- c (+ (quot c 2)))))\n        l (quot x u)\n        r (rem  x u)\n\n        ;m #(read-string (apply str (reverse (str (quot % (quot v u))))))\n        m (fn [x]\n            (loop [x (quot x (quot v u)) o 0]\n              (if (zero? x)\n                o\n                (recur (quot x 10) (+ (* 10 o) (rem x 10))))))\n\n        n (if (neg? (compare (m l) r))\n            (+ (* (inc l) u) (m (inc l)))\n            (+ (*      l  u) (m      l)))]\n    (cons n (lazy-seq (f (inc n))))))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 150, "code": "(fn [n] (letfn [(seq-pnum [n] (loop [v (quot n 10) r [(mod n 10)] ]\n                                (if (= 0 v) r (recur (quot v 10) (conj r (mod v 10))) ) ))\n                (avail-pnum [c] (drop (quot (count c) 2) c) )\n                (avail-val [ca] (->> ca\n                                  (map #(* %1 %2) (take (count ca) (iterate #(*' % 10) 1))) (reduce +) ))\n                (palindrom-pnum [c hn] (concat (reverse (drop (- (count c) hn) c)) c))\n                (palindrom-val [n] (let [c (seq-pnum n) ca (avail-pnum c)]\n                    (avail-val (palindrom-pnum ca (quot (count c) 2))) ))\n                (palindrom-ival [n] (let [c (seq-pnum n), c1 (avail-pnum c), c2 (seq-pnum (inc (avail-val c1)))]\n                                (avail-val (if (= (count c1) (count c2)) (palindrom-pnum c2 (quot (count c) 2))\n                                             (palindrom-pnum (if (= 0 (mod (count c) 2)) c2 (drop 1 c2)) (count c1))\n                                 )))) ]\n                (let [n1 (palindrom-val n) n2 (if (<= n n1) n1 (palindrom-ival n))]\n                  ((fn palindrom1 [n] (cons n (lazy-seq (palindrom1 (palindrom-ival n))))) n2))\n ))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 150, "code": "(fn [n]\n  (let [l (count (str n))]\n    (letfn [(odd-reverse [x]\n                         (loop [n x r (quot x 10)]\n                           (if (> r 0)\n                             (recur (+ (* 10 n) (rem r 10)) (quot r 10))\n                             n)))\n            (even-reverse [x]\n                          (loop [n x r x]\n                            (if (> r 0)\n                              (recur (+ (* 10 n) (rem r 10)) (quot r 10))\n                              n)))]\n      (drop-while #(< % n)\n                  (if (even? l)\n                    (apply concat (cons (map even-reverse (range (quot n (apply *' (repeat (/ l 2) 10))) (apply *' (repeat (/ l 2) 10))))\n                                    (interleave \n                                    (map #(map odd-reverse \n                                               (range (apply *' (repeat % 10)) \n                                                      (apply *' (repeat (inc %) 10))))\n                                         (iterate inc (/ l 2)))\n                                    (map #(map even-reverse \n                                               (range (apply *' (repeat % 10)) \n                                                      (apply *' (repeat (inc %) 10))))\n                                         (iterate inc (/ l 2))))))\n                    (apply concat (cons (map odd-reverse (range (quot n (apply *' (repeat (quot l 2) 10))) (apply *' (repeat (/ (+ 1 l) 2) 10))))\n                                    (interleave \n                                    (map #(map even-reverse \n                                               (range (apply *' (repeat % 10)) \n                                                      (apply *' (repeat (inc %) 10))))\n                                         (iterate inc (/ (- l 1) 2)))\n                                    (map #(map odd-reverse \n                                               (range (apply *' (repeat % 10)) \n                                                      (apply *' (repeat (inc %) 10))))\n                                         (iterate inc (/ (+ 1 l) 2)))))))))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 150, "code": "(fn pal-from [n]\n  (when (>= n 0)\n    (let [;digits (->> n str (map (comp read-string str)) vec)\n          verbose 0\n          n2digits-rev (fn n2digits-rev [n] (if (= 0 n)\n                                              []\n                                              (cons (rem n 10) (n2digits-rev (long (/ n 10))))))\n          n2digits (fn n2digits [n] (if (= 0 n)\n                                      [0]\n                                      (-> n n2digits-rev reverse)))\n          digits2n (fn digits2n [xs] (reduce (fn [acc v] (+ (* 10 acc) v)) 0 xs))\n          digits2mirror (fn digits2mirror [xs mid] (concat xs mid (reverse xs)))\n          digits (n2digits n)\n          pal? (= digits (reverse digits))]\n      (when (> verbose 0) (println \"n: \" n \", digits: \" digits \". pal?: \" pal?))\n      (let [n' (if pal?\n                n\n                (let [nlen      (count digits)\n                      nlen_mid  (long (/ (inc nlen) 2))\n                      digits1_2 (take nlen_mid digits)\n                      n-mirror  (digits2n (if (odd? nlen) (digits2mirror (butlast digits1_2) [(last digits1_2)])\n                                                          (digits2mirror digits1_2 [])))]\n                  (when (> verbose 0) (println \"digits1_2: \" digits1_2 \" -> mirror: \" n-mirror))\n                  (if (> n-mirror n)\n                    n-mirror\n                    (let [digits1_2' (n2digits (inc (digits2n digits1_2)))]\n                      (when (> verbose 0) (println \"digits1_2': \" digits1_2' \" (digits1_2: \" digits1_2 \")\"))\n                      (digits2n (if (or (odd? nlen) (> (count digits1_2') (count digits1_2)))\n                                  (digits2mirror (butlast digits1_2') [(last digits1_2')])\n                                  (digits2mirror digits1_2' [])))))\n                  ))]\n        (when (> verbose 0) (println \"n': \" n'))\n        (cons n' (lazy-seq (pal-from (inc n'))))\n    ))))", "user": "534056fce4b085b17e897dac"}, {"problem": 150, "code": "(fn [n]\n  (let [digits (fn [n]\n                 (if (= n 0)\n                   '(0)\n                   (loop [n n\n                          a ()]\n                     (if (> n 0)\n                       (recur (bigint (/ n 10))\n                              (cons (rem n 10) a))\n                       a))))\n        number (fn [digits]\n                 (loop [digits (reverse digits)\n                        m 1\n                        acc 0]\n                   (if (seq digits)\n                     (recur (next digits)\n                            (* m 10)\n                            (+ acc (* (first digits) m)))\n                     acc)))\n        next-pal (fn [n]\n                   (let [d (digits n)\n                         cr (fn [coll]\n                              (let [p (take (/ (count coll) 2) d)\n                                    n (number p)\n                                    s (digits n)\n                                    dr (if (even? (count d)) 0 1)]\n                                (number (concat s (drop dr (reverse s))))))]\n                     (if (every? #(= % 9) d)\n                       (+ n 2)\n                       (let [np (cr d)]\n                         (if (< n np)\n                           np\n                           (let [p (take (/ (count d) 2) d)\n                                 n (inc (number p))\n                                 s (digits n)\n                                 dr (if (even? (count d)) 0 1)]\n                             (number (concat s (drop dr (reverse s))))))))))\n        pal? (fn [n]\n               (let [d (digits n)]\n                 (= d (reverse d))))\n        v (if (pal? n) n (next-pal n))\n        r (fn r [n]\n            (lazy-seq (cons (next-pal n) (r (next-pal n)))))]\n    (lazy-seq (cons v (r v)))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 150, "code": "(fn pal\n  ([] (pal 0))\n  ([n] (letfn [(n-to-s [num]\n                 (if (zero? num)\n                   [0]\n                   (loop [q num res '()]\n                     (if (zero? q)\n                       (vec res)\n                       (recur (quot q 10) (cons (mod q 10) res))))))\n               (s-to-n [s]\n                 (loop [mul 1 l (reverse s) res 0]\n                   (if (empty? l)\n                     res\n                     (recur (* mul 10) (rest l) (+ res (* mul (first l)))))))\n               (palindrome? [num]\n                 (let [l (n-to-s num)]\n                   (= l (reverse l))))\n               (inc-pal [num]\n                 (letfn [(get-inds [c]\n                           (let [right-ind  (quot c 2)\n                                 left-ind (if (odd? c) right-ind (dec right-ind))]\n                             [left-ind right-ind]))]\n                   (s-to-n (loop [s (n-to-s num) [left right] (get-inds (count s))]\n                             (let [next-num (if (and (>= left 0) (< right (count s)))\n                                              (mod (inc (nth s left)) 10)\n                                              0)]\n                               (cond (< left 0)\n                                     (concat [1] (repeat (dec (count s)) 0) [1]) ; Could fail, Check this\n                                     (zero? next-num) (recur (assoc s left next-num right next-num) [(dec left) (inc right)])\n                                     :else (assoc s left next-num right next-num)\n                                     ))))))]\n         (let [n (if (not (palindrome? n))\n                   (inc-pal (last (take-while (partial > n) (pal))))\n                   n)]\n           (cons n (lazy-seq (pal (inc-pal n)))))\n         )))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(f [n]\n               (let [len (count (str n))\n                     tens (reduce * (repeat (quot len 2) 10))\n                     left (quot n tens)\n                     right (mod n tens)\n                     rev #(loop [n % a 0] (if (= n 0) a (recur (quot n 10) (+ (* a 10) (mod n 10)))))\n                     makePal #(+ (* % tens) (mod (rev %) tens))]\n                 (if (> right (mod (rev left) tens))\n                   (makePal (inc left))\n                   (makePal left))))]\n    (iterate (comp f inc) (f n))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 150, "code": "(fn pal [n]\n\n  (letfn [ \n          (pow10 [exp] (reduce *' (repeat exp 10)))\n\n          (rev-str [s] (reduce str \"\" (reverse s)))\n\n          (pal? [n] (= (str n) (rev-str (str n))))\n\n          (round-down [n] \n            (let [len (count (str n))\n                  exponent (if (= 2 len) 1 (inc (quot len 2)))\n                  factor (pow10 exponent)]\n              (* factor (quot n factor))))\n\n          (mirror [n] \n             (let [s (str n)\n                   len (count s) \n                   half-len (/ len 2)\n                   left (subs s 0 half-len)\n                   mid  (subs s half-len (+ half-len (mod len 2)))]\n               (read-string (str left mid (rev-str left)))))\n\n          (next-candidate [n]\n            (let [len (count (str n)) \n                  half-len (quot len 2)\n                  exponents (cond \n                              (< len 3)  [(dec len)]\n                              (odd? len) [half-len]\n                              :else      [half-len (dec half-len)])]\n              (+' n (reduce +' (map pow10 exponents)))))\n\n          (next-pal [n] \n            (if (pal? n)\n              n\n              (let [candidate (mirror n)]\n                (if (< n candidate)\n                  candidate\n                  (let [candidate (next-candidate candidate)]\n                    (if (pal? candidate) candidate (next-pal (round-down candidate))))))))\n          ]\n\n    (let [p (next-pal n)]\n      (cons p (lazy-seq (pal (inc p)))))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 150, "code": "(fn [i]\n    (letfn [(odd [x a b]\n              (if (= x b)\n                (even a a b)\n                (let [rnval (quot x 10)\n                      rnstr (if (= rnval 0) \"\" (clojure.string/reverse (str rnval)))]\n                  (lazy-seq\n                   (cons (read-string (str x rnstr))\n                         (odd (inc x) a b))))))\n            (even [x a b]\n              (if (= x b)\n                (odd b b (* 10 b))\n                (lazy-seq\n                 (cons (read-string (str x (clojure.string/reverse (str x))))\n                       (even (inc x) a b)))))]\n      (if (<= i 0)\n        (cons 0 (odd 1 1 10))\n        (let [s (str i)\n              ndigits (count s)\n              nsd (quot (inc ndigits) 2)\n              start (read-string (subs s 0 nsd))\n              lo (reduce * 1 (take nsd (repeat 10)))\n              hi (* lo 10)]\n          (drop-while #(< % i)\n                      ((if (even? ndigits) even odd) start lo hi))))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 150, "code": "(fn generate-palindromes [start]\n  (let [next-palindrome (fn[n]\n                          (let [int-to-digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n                                digits-to-int #(read-string (apply str %))\n                                is-even? #(= 0 (mod (count %) 2))\n                                get-left #(take (Math/ceil (/ (count %) 2)) %)\n                                mirror-even #(concat % (reverse %))\n                                mirror-odd #(concat % (rest (reverse %)))\n                                digits (int-to-digits n)\n                                mirror (if (is-even? digits) mirror-even mirror-odd)\n                                other-mirror (if (is-even? digits) mirror-odd mirror-even)\n                                left-digits (get-left digits)\n                                mirrored-digits (mirror left-digits)\n                                candidate (digits-to-int mirrored-digits)]\n                            (if (> candidate n) candidate\n                              (let [higher-num (inc (digits-to-int left-digits))\n                                    higher-digits (int-to-digits higher-num)\n                                    higher-candidate (digits-to-int (mirror higher-digits))]\n                                (if (= (count higher-digits) (count left-digits))\n                                  higher-candidate\n                                  (let [trunc (if (is-even? digits) higher-digits (butlast higher-digits))]\n                                    (digits-to-int (other-mirror trunc))))))))\n\n        first-palindrome (if (= 0 start) 0 (next-palindrome (dec start)))\n        ]\n    (iterate next-palindrome first-palindrome)\n\n    )\n  )", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 150, "code": "(fn [a]\n  (let [len (count (str a))\n        [half-len r] ((juxt quot rem) len 2)\n        b (quot a (int (Math/pow 10 (- len half-len r))))\n        prnt\n          (fn [k is-odd]\n            (let [[l m] ((juxt quot rem) k 10)\n                  [l m] [(if (zero? l) \"\" (str l)) (str m)]]\n              (read-string (str l m (if is-odd \"\" m) (clojure.string/reverse l)))))\n        gen-par (fn f [k is-odd]\n                  (cons (prnt k is-odd)\n                    (lazy-seq\n                      (let [k (inc k)]\n                        (if (->> k str (re-matches #\"10+\"))\n                          (if is-odd\n                            (f (/ k 10) false)\n                            (f k true))\n                          (f k is-odd))))))]\n    (filter #(>= % a) (gen-par b (= r 1)))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 150, "code": "(letfn [(encode [n]\r\n          (if (< n 10) [n]\r\n              (cons (mod n 10)\r\n                    (encode (quot n 10)))))\r\n        (decode [[x & xs]]\r\n          (if (not x) 0\r\n              (+ x (* 10 (decode xs)))))\r\n        (reflect [even? coll]\r\n          (concat (reverse coll)\r\n                  (drop (if even? 0 1)\r\n                        coll)))]\r\n  (fn palindromes\r\n    ([even? stem]\r\n     (let [[even? stem]\r\n           (if (every? #{9} stem)\r\n             [(not even?) (concat (repeat (- (count stem) (if even? 0 1)) 0) [1])]\r\n             [even? (encode (inc (decode stem)))])]\r\n       (lazy-seq (cons (decode (reflect even? stem))\r\n                       (palindromes even? stem)))))\r\n    ([n]\r\n     (let [encoded (encode n)\r\n           middle  (/ (count encoded) 2)\r\n           top     (Math/ceil middle)\r\n           bottom  (Math/floor middle)\r\n           stem    (take-last top encoded)\r\n           even?   (= top bottom)\r\n           cand    (decode (reflect even? stem))\r\n           tail    (palindromes even? stem)]\r\n       (if (< cand n) tail\r\n           (lazy-seq (cons cand tail)))))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 150, "code": "(fn [n]\n  (let [base (fn [n]\n               (let [ns (str n)]\n                 (read-string (apply str (take (int (Math/ceil (/ (count ns) 2))) ns)))))\n        pal2 (fn [n s]\n               (let [sn (str n)\n                     a (read-string (str sn (apply str (reverse sn))))\n                     b (if (> n 9) (read-string (str sn (apply str (drop 1 (reverse sn))))) n)\n                     c (if (> n 9) (read-string (str (apply str (drop-last sn)) (apply str (drop 1 (reverse sn))))) n)\n                     vals (filter #(> % s) [a b c])]\n                 (if (empty? vals) Integer/MAX_VALUE (apply min vals))))\n        npal (fn [n] (pal2 (inc (base n)) n))\n        npal2 (fn [n] (let [a (pal2 (base n) n)\n                            b (pal2 (inc (base n)) n)]\n                        (min b a)))]\n\n    (if (= (str n) (apply str (reverse (str n))))\n      (iterate npal n)\n      (iterate npal (npal2 n)))))", "user": "4eb2eae5535d7eef30807351"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [even-digits? #(even? (count %)) \n        left-middle #(if (even-digits? %) \n                       (subs % 0 (quot (count % ) 2) ) \n                       (subs % 0 (inc (quot (count % ) 2)))) \n        mirror (fn [[num dig]]\n                 (loop [a num r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)) (quot r 10)))))\n        init #(let [s (left-middle %)] \n                (vector (Long/parseLong s) \n                        (if (even-digits? %) :even :odd) \n                        (long (Math/pow 10 (count s)))))\n        nextp (fn [[num even goal]] \n               (let [m (inc num)] \n                 (if (= m goal)\n                   (if (= even :even)\n                     [goal :odd (* 10 goal)]\n                     [(/ goal 10) :even goal])\n                   [m even goal] )))\n        i  (init (str n)) \n        palindromes (iterate nextp i) ] \n    (filter (partial <= n ) (map mirror palindromes))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(en [n] (reduce #(+ (* % 10) %2) 0 n))\n          (de [n] \n              (if (< n 10) \n                [n] \n                (conj (de (quot n 10)) (mod n 10))))\n          (getnext\n           [x]\n           (let [X (de x)\n                 n (count X)\n                 l (quot n 2)\n                 H (drop-last l X)\n                 H1 (de (inc (en H)))\n                 L (reverse (take l H))\n                 L1 (reverse (take l H1))\n                 ans (en (concat H L))] \n             (if (>= ans x) ans (en (concat H1 L1)))))]\n    (iterate (comp getnext inc) (getnext n))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [even-digits? #(even? (count %)) \n        left-middle #(if (even-digits? %) \n                       (subs % 0 (quot (count % ) 2) ) \n                       (subs % 0 (inc (quot (count % ) 2)))) \n        mirror (fn [[num dig]]\n                 (loop [a num r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)) (quot r 10)))))\n        init #(let [s (left-middle %)] \n                (vector (Long/parseLong s) \n                        (if (even-digits? %) :even :odd) \n                        (long (Math/pow 10 (count s)))))\n        nextp (fn [[num even goal]] \n               (let [m (inc num)] \n                 (if (= m goal)\n                   (if (= even :even)\n                     [goal :odd (* 10 goal)]\n                     [(/ goal 10) :even goal])\n                   [m even goal] )))\n        i  (init (str n)) \n        palindromes (iterate nextp i) ] \n    (filter (partial <= n ) (map mirror palindromes))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(div [n] (mapv (comp read-string str) (str n)))\n          (con [v] (read-string (apply str v)))\n          (gen [n odd terminal]\n               (let [v (div n)\n                     m (inc n)]\n                 (cons (con (into v (if odd (rest (rseq v)) (rseq v))))\n                       (lazy-seq\n                        (cond\n                         (not= m terminal) (gen m odd terminal)\n                         odd (gen (quot m 10) false terminal)\n                         :else (gen m true (* 10 terminal)))))))]\n    (let [nums (div n)\n          len  (count nums)\n          half (- len (quot len 2))]\n      (drop-while #(< % n) (gen (con (take half nums))\n                                (odd? len)\n                                (reduce * (repeat half 10)))))))", "user": "554b8572e4b0a04f79299589"}, {"problem": 150, "code": "(fn problem-150\n  [n]\n  (letfn [(split-number [n] [(quot (inc n) 2), (quot n 2)])\n          (build [s left right] (Long/parseLong (apply str (concat (take left s) (reverse (take right s))))))\n          (nearest-palindrome [x]\n            (let [sx (str x)\n                  [k1 k2] (split-number (count sx))]\n              (build sx k1 k2)))\n          (next-palindrome [n]\n            (let [s (str n)\n                  [left _] (split-number (count s))\n                  next (inc (Long/parseLong (apply str (take left s))))\n                  [new-left new-right] (split-number (count (str (inc n))))]\n              (build (str next) new-left new-right)))]\n    (drop-while #(< % n) (iterate next-palindrome (nearest-palindrome n)))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 150, "code": "; palindromes generated whole, without using sequences of digits\n(fn [n]\n  (letfn [(width [n]\n            ; Math/log10-based solution better but java interop = time out\n            (count (str n)))\n          (root [n]\n            ; Every pal is xyzyx or xyzzyx, root (of either) = xyz\n            ; Math/pow-based solution better but java interop = time out\n            (quot n (reduce * (repeat (quot (width n) 2) 10))))\n          (make-palindrome [n odd-length?]\n            (loop [r n\n                   n (if odd-length? (quot n 10) n)]\n              (if (zero? n)\n                r\n                (recur (+ (* r 10) (rem n 10)) (quot n 10)))))\n          (next-palindrome [p]\n            (let [w (width p)\n                  o (odd? w)\n                  p (root p)\n                  r (inc p)]\n              (if (> (width r) (width p))\n                (make-palindrome (if o (quot r 10) r) (not o))\n                (make-palindrome r o))))\n          (first-palindrome [n]\n            (let [r (root n)\n                  w (width n)\n                  o (odd? w)\n                  p (make-palindrome r o)]\n              (if (< p n)\n                (make-palindrome (inc r) o)\n                p)))]\n    (iterate next-palindrome (first-palindrome n))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 150, "code": "(fn [k]\n  (letfn [(to-num [s] (read-string (apply str s)))\n\n          (split-num [k]\n            (let [S (str k) n (count S) r (mod n 2)]\n              [(= 0 r) (take (+ (quot n 2) r) S)]))\n\n          (simple-next [[even L]]\n            (let [R (reverse L)]\n              (concat L (if even R (rest R)))))\n\n          (smart-next [[even L]]\n            (let [R (str (+ 1 (to-num L)))]\n              (simple-next\n                (if (= (count L) (count R))\n                  [even R]\n                  [(not even) (if even R (drop-last R))]))))\n\n          (p-next [k]\n            (let [S (split-num k) n (to-num (simple-next S))]\n              (if (< k n) n (to-num (smart-next S)))))]\n\n    (iterate p-next (if (= 0 k) 0 (p-next (dec k))))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 150, "code": "(fn pal [max]\n  (letfn [(todigs [num] (if (>= num 10) (conj (todigs (quot num 10)) (rem num 10) ) [num]))\n          (tonum [digs] (+ (peek digs) (if (= 1 (count digs)) 0 (* 10 (tonum (pop digs))))))\n          (parts [val] (let [digs (todigs val)]\n                         (concat [digs] (map #(subvec digs 0 (+ % (/ (count digs) 2))) '(0 0.5))\n                                 (vector (subvec digs (+ 0.5 (/ (count digs) 2)))))))\n          (next [val]\n            (if (< val 10) val\n                (let [[digs lhs lhsfull rhs] (parts val)\n                      revlhs (vec (reverse lhs))\n                      lhv (tonum revlhs)\n                      rhv (tonum rhs)]\n                  (cond (= lhv rhv) val\n                        (> lhv rhv) (tonum (vec (concat lhsfull revlhs)))\n                        (< lhv rhv) (let [d (todigs (inc (tonum lhsfull)))\n                                          c (count d)\n                                          new (if (= (count lhs) c)\n                                                (concat d (reverse d))\n                                                (concat d (reverse (butlast d))))]\n                                      (tonum (vec new)))))))]\n    (let [n (next max)]\n      (lazy-seq (cons n (pal (inc n)))))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 150, "code": "(fn [number] (let [next-pal (fn [number]\n                                        (let [n (inc number)\n                                              d->int #((comp int bigint) (apply str %))\n                                              int->d #(map (comp int bigint str) (seq (str %)))\n                                              inc-digits #(int->d (inc (d->int %)))\n                                              digits (int->d n)\n                                              [front back] (split-at (/ (count digits) 2) digits)\n                                              hfront (inc-digits front)\n                                              build #(d->int (concat % (reverse (take (count back) %))))]\n                                          (->> [n (build hfront) (build front)]\n                                               sort\n                                               (drop-while #(not= n %))\n                                               second)))] \n                         (iterate next-pal (if (= (seq (str number)) (reverse (str number))) \n                                             number\n                                             (next-pal number)))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 150, "code": "(letfn [\n\t(to-int [xs]\n         (if (empty? xs) \n          0\n         (reduce #(+ (* %1 10) %2) xs)))\n  \n  (to-vec [x] \n         (if (= 0 x) [0]\n           (loop [x x digits []]\n             (if (= 0 x) (into [] digits)\n               (recur (quot x 10) (cons (mod x 10) digits))))))\n  \n  (is-palin? [x]\n            (or (< x 10) \n            (= x (to-int (reverse (to-vec x))))))\n  \n  (sp1 [xs] \n           (to-int (into [] (concat xs (reverse xs)))))\n  \n  (sp2 [xs]\n           (if (= 1 (count xs)) \n             (to-int xs)\n             (to-int (into [] (concat xs (subvec (vec (reverse xs)) 1))))))              \n  \n  (next-pal [x]\n            (let [st (to-vec x)\n                  c  (count st)\n                  t  (int (Math/ceil (/ c 2)))\n                  p  (subvec st 0 t) \n                  r  (to-vec (inc (to-int p)))\n                  all-9 (= (set st) #{9} )]\n                  (if all-9 \n                      (+ 2 x)\n                       (if (even? c)\n                         (let [u1 (sp1 p) u2 (sp1 r)]\n                           (if (> u1 x) u1 u2))\n                         (let [u1 (sp2 p) u2 (sp2 r)]\n                           (if (> u1 x) u1 u2 ))))))\n  \n  (qq [w]\n    (let [s (if (is-palin? w)\n              w\n              (next-pal w))]\n          (iterate next-pal s)))\n       ] \n  #(qq %))\n  \n  ; damn this looks long and complicated", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 150, "code": "(fn [n]\n  (let [n->digits\n        (fn [n]\n          (loop [n n, digits ()]\n            (if (zero? n) (if (empty? digits) '(0) digits)\n              (recur (quot n 10)\n                     (conj digits (mod n 10))))))\n        digits (n->digits n)\n        count-digits (count digits)\n        drop-count (mod count-digits 2)\n        digits->n (fn [ds n] (reduce #(+ (* %1 10) %2) n ds))]\n    (drop-while\n      #(< % n)\n      (map first\n        (rest\n          (iterate\n            (fn [[_ n drop-count]]\n              (let [digits1 (n->digits n)\n                    digits2 (drop drop-count (reverse digits1))\n                    pal (digits->n digits2 n)\n                    n' (inc n)]\n                (if (apply = 9 digits1)\n                  (if (zero? drop-count)\n                    [pal n' 1]\n                    [pal (quot n' 10) 0])\n                  [pal n' drop-count])))\n            [nil\n             (digits->n (take (quot (inc count-digits) 2) \n                              digits) \n                        0)\n             drop-count]))))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 150, "code": "(fn puzzle-150 [from-n]\n  (letfn [(digits [n]\n                  (loop [n n\n                         d ()]\n                    (if (zero? n) d\n                      (let [d0 (mod n 10)]\n                        (recur (/ (- n d0) 10) (cons d0 d))))))\n          (from-digits [c]\n                       (if (empty? c) 0\n                         (reduce #(+ (* % 10) %2) c)))\n          (make-palindrom [n shift drop-digits]\n                          (+ (* n shift)\n                             (from-digits\n                              (drop drop-digits (reverse (digits n))))))\n          (palindroms [from-n digits-count]\n                      (let [even (even? digits-count)\n                            n (bit-shift-right (inc digits-count) 1)\n                            end (apply * (repeat n 10))\n                            start (/ end 10)\n                            shift (if even end start)]\n                        (lazy-cat\n                         (if-not (< from-n (* end shift)) ()\n                           (let [drop-digits (if even 0 1)\n                                 from-n-start0 (max (if (and (= 1 start) (not even)) 0 start) (int (/ from-n shift)))\n                                 from-n-start (if (< (make-palindrom from-n-start0 shift drop-digits) from-n) (inc from-n-start0) from-n-start0)]\n                             (map #(make-palindrom % shift drop-digits)\n                                  (range from-n-start end))))\n                         (palindroms from-n (inc digits-count)))))]\n    (palindroms from-n 1)))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 150, "code": "(fn palindrome-numbers\n  [n]\n  (letfn [(count-digits [n]\n            (if (< n 10)\n              1\n              (+ 1 (count-digits (quot n 10)))))\n          (digit-shift-right [n i]\n            (if (= i 0)\n              n\n              (recur (quot n 10) (dec i))))\n          (digit-shift-left [n i]\n            (if (= i 0)\n              n\n              (recur (* n 10) (dec i))))\n          (palindromize [n even]\n            (loop [result n\n                   remaining (if even n (quot n 10))]\n              (cond\n                (= remaining 0) result\n                (< remaining 10) (+ (* 10 result) remaining)\n                :else (recur (+ (* 10 result) (rem remaining 10))\n                                (quot remaining 10)))))\n          (palindromes [start even]\n            (let [end (digit-shift-left 1 (count-digits start))]\n              (lazy-cat\n                (map #(palindromize % even) (range start end))\n                (if even\n                  (palindromes end false)\n                  (palindromes (quot end 10) true)))))]\n    (let [ndigits (count-digits n)]\n      (drop-while #(< % n) (palindromes (digit-shift-right n (quot ndigits 2))\n                                        (even? ndigits))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(f [v mirror]\n    (cons (Long. (str v (apply str (if mirror (reverse (str v))  (drop 1 (reverse (str v)))))))\n          (lazy-seq (if (=  (count (str v)) (count (str (inc v))) )\n                      (f (inc v) mirror)\n                      (f (if (not mirror) (int (/ (inc v) 10)) (inc v)) (not mirror))\n\n         )\n             )))]\n   (let [s (str n)\n        l (count s)\n        d (int (/ l 2))\n        t (Long. (apply str (take (if (odd? l) (inc d) d) s)))\n        mirror (not (odd? l))\n        v (Long. (str t (apply str (if mirror (reverse (str t))  (drop 1 (reverse (str t)))))))\n         ]\n        (if (= 1 l) (f n false)\n              (filter #(<= n %)(f t mirror))\n        )\n   )\n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 150, "code": "(fn p150 [start]\n  (let [next-palin (fn [x]\n                     (let [st (str x)\n                           st-l (count st)\n                           head (subs st 0 (Math/ceil (/ st-l 2)))\n                           n-head (-> head bigint inc str)\n                           make (fn [s] (bigint (str s (subs (clojure.string/reverse s)\n                                                             (if (even? st-l)\n                                                               0\n                                                               1)))))\n                           [a b] (map make [head n-head])]\n                       (if (>= a x) a b)))]\n    (iterate (comp next-palin inc) (next-palin start))))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 150, "code": "(fn [n]\n  (let [start (read-string (apply str (take (Math/ceil (/ (count (str n)) 2)) (str n))))\n        odd (odd? (count (str n)))\n        from (fn nxt [n odd] (cons\n                      (read-string \n                      (if odd\n                        (apply str (concat (str n) (rest (reverse (str n))))) \n                        (apply str (concat (str n) (reverse (str n))))))\n                      (lazy-seq\n                      (let [cnt (count (str n))]\n                        (if (= cnt (count (filter #(= % \\9) (str n))))\n                          (if odd\n                            (nxt (read-string (apply str (cons \\1 (repeat (- cnt 1) \\0)))) (not odd))\n                            (nxt (+ n 1) (not odd))\n                            )\n                          (nxt (+ n 1) odd)\n                              )))))]\n    (drop-while #(< % n) (from start odd))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 150, "code": "(fn __ [start]\n (letfn [(palindrome? [n] (or (= n 0) (= (str n) (apply str (reverse (str n))))))\n         (next-palidrome [n pal?]\n           (let [length (-> n str count)\n                 middle-index (-> length (/ 2) Math/ceil int)\n                 left-part (apply str (take middle-index (str n)))\n                 local-inc (if pal? inc identity)\n                 new-left (-> left-part bigint local-inc str)\n                 result (bigint\n                          (apply str (if (not= (count left-part) (count new-left)) (apply str (butlast new-left)) new-left)\n                            (if (odd? length)\n                              (rest (reverse new-left))\n                              (reverse new-left))))]\n             (if (> result n) result (next-palidrome result true))))]\n   (let [new-start (if (palindrome? start) start (next-palidrome start false))]\n     (iterate #(next-palidrome % true) new-start))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 150, "code": "(fn __ [min-val]\n  (let [parse (fn [n]\n                (let [sn (str n)\n                      overlap? (odd? (count sn))\n                      cut-size (/ (count sn) 2)\n                      base (Long/parseLong (apply str (take cut-size sn)))]\n                  [base overlap?]))\n        unparse (fn unparse [[base overlap?]]\n                  (loop [result base tail (if overlap? (quot base 10) base)]\n                    (if (zero? tail)\n                      result\n                      (recur (+ (* 10 result) (mod tail 10)) (quot tail 10)))))\n        next-pal (fn [[base overlap?]]\n                   (if (every? #{\\9} (str base))\n                     (if overlap?\n                       [(/ (inc base) 10) (not overlap?)]\n                       [(inc base) (not overlap?)])\n                     [(inc base) overlap?]))\n        closest-pal (fn [n]\n                      (let [parts (parse n)\n                            next (unparse parts)]\n                        (if (> n next)\n                          (next-pal parts)\n                          parts)))\n        start (closest-pal min-val)]\n    (map unparse (iterate next-pal start))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 150, "code": "(fn f\n                 ([num]\n                  (letfn [(num-seq [start]\n                            (loop [s [] num start]\n                              (if (= num 0)\n                                (if (seq s) (reverse s) [0])\n                                (let [nnum (mod num 10)]\n                                  (recur (conj s nnum) (long (/ num 10)))))))\n                          (convert [s] (read-string (apply str s)))\n                          (start [num] (convert (palin (num-seq num))))\n                          (palin [s]\n                            (cond\n                              (every? (partial = 9) s) (nth (iterate grow s) 2)\n                              (> (count s) 1) (mirror s grow)\n                              :default (grow s)))\n                          (mirror [s g]\n                            (let [c (count s)\n                                  m (int (Math/ceil (/ c 2)))\n                                  ns (g (take m s))]\n                              (concat ns (reverse (take (if (even? c) m (dec m)) ns)))))\n                          (grow [s]\n                            (if (seq s)\n                              (let [n (inc (last s))\n                                    ns (vec (drop-last s))]\n                                (if (> n 9)\n                                  (vec (conj (grow ns) 0))\n                                  (vec (conj ns n))))\n                              [1]))]\n                    (let [s (num-seq num)]\n                      (if (= s (reverse s))\n                        (iterate start num)\n                        (let [m (convert (mirror s identity))]\n                          (if (< m num)\n                            (iterate start (start m))\n                            (iterate start m))))))))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 150, "code": "(fn p [n]\n    (let [r clojure.string/reverse\n          l #(Long. %)\n          s str\n          i inc\n          a #(s (i (l %)))\n          b subs\n          q quot\n          t seq\n          d apply\n          z (s n)\n          c (count z)\n          h (q c 2)\n          j (q (i c) 2)\n          f (b z 0 h)\n          m (b z h j)\n          e (b z j c)\n          g (if (t f) (a f) f)\n          w (->>\n             [(s \"1\" (d s (repeat (dec c) \"0\")) \"1\")\n              (s f m (r f))\n              (s (r e) m e)\n              (s g m (r g))\n              (s f (if (t m) (s (i (l m))) m) (r f))\n              (s g \"0\" (r g))]\n             (map l)\n             (remove #(< % n))\n             (d min))]\n      (lazy-seq (cons w (p (inc w))))))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 150, "code": "(fn [n] ; rather clunky I admit (okay, super clunky) but a little fun\n           (letfn [(phalf-length [s] (let [l (count s)] (+ (quot l 2) (mod l 2))))\n                   (rest-length [s] (- (count s) (phalf-length s)))\n                   (phalf [s] (apply str (take (phalf-length s) s)))\n                   (rhalf [s] (apply str (reverse (take (rest-length s) s))))\n                   (lhs-this [x] (Integer. (phalf (str x))))\n                   (lhs-next [x] (inc (lhs-this x)))\n                   (lhs-num [x base] (* (tenpow (mult x)) base))\n                   (rhs-num [x base] (Integer. (apply str (concat [\\0] (reverse (take (rest-length (str x)) (str base)))))))\n                   (mult [x] (rest-length (str x)))\n                   (tenpow [x] (apply * (take x (repeat 10))))\n                   (pal [x base] (+ (lhs-num x base) (rhs-num x base)))\n                   (this-pal [x] (pal x (lhs-this x)))\n                   (next-pal [x] (pal x (lhs-next x)))\n                   (pals-from [x] (cons (this-pal x) (lazy-seq (pals-from (next-pal x)))))]\n             (drop-while #(< % n) (pals-from n))\n             )\n           )", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 150, "code": ";;need to refactor this\n(fn palindromes [n]\n  (letfn [(to-int [s] (read-string (apply str s)))\n          (to-seq [n] (seq (str n)))\n          (get-next-n [n]\n            (let [n-size (count n)\n                  n-size-half (quot n-size 2)\n                  n-left (if (even? n-size) (take n-size-half n) (take (inc n-size-half) n))\n                  n'-left (to-seq (inc (to-int n-left)))]\n              (if (apply = \\9 n)\n                (to-seq (+ 2 (to-int n)))\n                (if (even? n-size)\n                  (concat n'-left (reverse n'-left))\n                  (concat (butlast n'-left) [(last n'-left)] (reverse (butlast n'-left)))))))\n          (-palindromes [n]\n            (let [n' (get-next-n n)]\n              (lazy-seq (cons (to-int n) (-palindromes n')))))]\n    (let [ns (to-seq n)\n          ns-size (count ns)\n          ns-size-half (quot ns-size 2)\n          ns-even? (even? ns-size)\n          ns-left (if (even? ns-size) (take ns-size-half ns) (take (inc ns-size-half) ns))\n          ns' (if (even? ns-size)\n                    (concat ns-left (reverse ns-left))\n                    (concat (butlast ns-left) [(last ns-left)] (reverse (butlast ns-left))))]\n      (filter #(>= % n) (-palindromes ns')))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 150, "code": "(fn lambda [n]\n  (let [m (-> n str count inc (/ 2) int)\n        even (-> n str count even?)\n        head (->> n str (take m)\n                  (apply str) read-string)\n        tail (->> n str reverse (take m)\n                  (drop-while (partial = \\0)))\n        tail (->> (if (empty? tail) '(\\0) tail)\n                  (apply str) read-string)\n        head (if (< head tail) (inc head) head)\n        f (fn [half]\n            (read-string\n              (apply str\n                     (concat (str half)\n                             ((if even identity rest) (reverse (str half)))))))\n        curr (f head)\n        next (if (every? (partial = \\9) (str head))\n               (inc (apply * (repeat (count (str n)) 10)))\n               (f (inc head)))]\n    (lazy-cat [curr] (lambda next))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 150, "code": "(fn my-palindromic-numbers\n  [num]\n  (letfn [(reverse-digits [num result]\n            (if\n              (zero? (quot num 10))\n              (+ (mod num 10) (* result 10))\n              (reverse-digits (quot num 10) (+ (mod num 10) (* result 10)))))\n          (get-next-top-down [[down _]]\n            [(* 10 down) (dec (* 100 down))])\n          (create-palindromes [[down top]]\n            (lazy-cat\n              (lazy-cat\n                (map #(reverse-digits % (quot % 10)) (range down (inc top)))\n                (map #(reverse-digits % %) (range down (inc top))))\n              (create-palindromes (get-next-top-down [down top]))))\n          (get-top-down [num]\n            (let [down-total (reduce * (rest (repeat (/ (count (str num)) 2) 10)))\n                  down (if (even? (count (str num)))\n                         down-total\n                         (quot num down-total))\n                  top (dec (* 10 down-total))]\n              [down top]))]\n    (filter #(>= % num) \n            (if (zero? num)\n              (lazy-cat\n                '(0)\n                (create-palindromes [1 9]))\n              (create-palindromes (get-top-down num))))))", "user": "509a25b7e4b0efbae1fbc0a8"}, {"problem": 150, "code": "(fn palindrome_stream [n]\n  (letfn [\n          (get-digits [n]\n          (if (< n 10) [n]\n                       (conj (get-digits (quot n 10)) (rem n 10))))\n          (digits-to-num [coll]\n                         (reduce #(+ %2 (* 10 %1)) 0 coll))\n          (even-palindrome [n]\n                           (digits-to-num (concat (get-digits n) (reverse (get-digits n))))\n                           )\n          (odd-palindrome [n]\n                          (digits-to-num (concat (get-digits n) (drop 1 (reverse (get-digits n)))))\n                          )\n          (next-palindrome [n]\n                           (let [\n                                     digis (get-digits n)\n                                    generator (if (odd? (count digis)) odd-palindrome even-palindrome)\n                                    start-number (digits-to-num (take (quot (+ 1 (count digis)) 2) digis))\n                  ]\n              (if (<= n (generator start-number)) (generator start-number) (generator (inc start-number)))))\n          ]\n  (let [p (next-palindrome n)]\n    (lazy-seq (cons p (palindrome_stream (inc p))))))\n  )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 150, "code": "(fn fp [n]\n  (let [l  (count (str n))\n        hl (quot l 2)\n        f0  #(reduce * (repeat % 10))\n        fnr #(loop [acc %2\n                    rst %]\n              (if (zero? rst) acc\n                  (recur (+ (* acc 10) (rem rst 10)) (quot rst 10))))\n        hn (quot n (f0 hl))]\n    (concat\n     (map #(fnr (if (odd? l) (quot % 10) %) %)\n          (range (if (< (quot n (f0 (- l hl)))\n                        (fnr (rem n (f0 hl)) 0))\n                   (inc hn) hn)\n                 (f0 (- l hl))))\n     (lazy-seq\n      (fp (inc (f0 l)))))))", "user": "52c25645e4b07a9af579237d"}, {"problem": 150, "code": "(fn [start]\n    (letfn [(fst [start]\n              (let [s (str start)\n                    c (.length s)\n                    half (quot c 2)\n                    p1 (subs s 0 half)\n                    mid (when (odd? c) (subs s half (inc half)))]\n                (str p1 mid (clojure.string/reverse p1))))\n            (nxt [s]\n              (let [c (.length s)\n                    half (quot c 2)\n                    p1 (subs s 0 half)\n                    mid (when (odd? c) (subs s half (inc half)))]\n                (if mid\n                  (let [new-mid (-> mid first int (- 48) inc)]\n                    (if (< new-mid 10)\n                      (str p1 new-mid (clojure.string/reverse p1))\n                      (let [p1 (if (= p1 \"\") \"0\" p1)\n                            p1 (-> p1 read-string inc str)]\n                        (if (= (.length p1) half)\n                          (str p1 \"0\" (clojure.string/reverse p1))\n                          (str p1 (clojure.string/reverse p1))))))\n                  (let [p1 (-> p1 read-string inc str)]\n                    (if (= (.length p1) half)\n                      (str p1 (clojure.string/reverse p1))\n                      (str p1 (subs (clojure.string/reverse p1) 1)))))))]\n      (drop-while #(< % start)\n                  (map read-string (iterate nxt (fst start))))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 150, "code": "(fn next-palindromic-series [m]\n  (letfn [(to-number [s] (reduce #(+ %2 (* 10 %1)) 0 s))\n          (digitize [a] (reverse (map #(mod % 10) (take-while #(not= 0 %) (iterate #(quot % 10) a)))))\n          (palindrom? [n]\n                      (let [s (digitize n)] (= s (reverse s))))\n          (get-next-palindrom [n]\n                              (let [s (digitize n)\n                                    size (count s)\n                                    first-half (take (quot size 2) s)\n                                    second-half (drop (quot (inc size) 2) s)\n                                    [first-half-long second-half-short] (split-at (quot (inc size) 2) s)]\n                                (if (< n 9)\n                                  (inc n)\n                                  (if (< (to-number (reverse second-half)) (to-number first-half))\n                                    (to-number (concat first-half-long (reverse first-half)))\n                                    (recur (* (to-number (concat '(1) (repeat (count second-half) 0))) (inc (to-number first-half-long))))\n                                    ))))]\n    (iterate\n     get-next-palindrom\n     (if (palindrom? m)\n       m\n       (get-next-palindrom m)))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 150, "code": "(fn o [i]\n  (let [np (fn [n]\n             (let [s (str n)\n                   h (quot (count s) 2)\n                   fh (subs s 0 h)\n                   m (subs s h (quot (inc (count s)) 2))\n                   c (bigint (apply str fh m (reverse fh)))]\n               (if (>= c n)\n                 c\n                 (let [nfh (str (inc (bigint (str fh m))))]\n                   (bigint (apply str nfh (if (empty? m) (reverse nfh) (rest (reverse nfh)))))))))\n        next-p (np i)]\n    (lazy-seq (cons next-p (o (inc next-p))))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 150, "code": "(fn palindromics [n]\n    (let [assemble (fn [[left-half even-length? remaining]]\n                     (let [ls-str (str left-half)\n                           rs-str (clojure.string/reverse ls-str)]\n                       (BigInteger.\n                        (str ls-str (if even-length? rs-str (subs rs-str 1))))))\n          next-palindromic (fn [[left-half even-length? remaining]]\n                             (if (and (zero? remaining) (pos? (mod (inc left-half) 10)))\n                               (println left-half even-length? remaining))\n                             (if (zero? remaining)\n                               (let [new-left (if even-length? (inc left-half) (/ (inc left-half) 10))]\n                                 [new-left (not even-length?) (dec (* 9 new-left))])\n                               [(inc left-half) even-length? (dec remaining)]))\n          first-palindromic (fn [x]\n                              (let [s (str x)\n                                     l (count s)\n                                     even-l? (even? l)\n                                     left (subs s 0 (quot (inc l) 2))\n                                     right-start (quot l 2)\n                                     right (subs s right-start)\n                                     rev-right (clojure.string/reverse right)\n                                     leftn (Integer/parseInt left)\n                                     rightn (Integer/parseInt rev-right)\n                                     reflect (fn [w even-length]\n                                               (if even-length\n                                                 (str w (clojure.string/reverse w))\n                                                 (str w (subs (clojure.string/reverse w) 1))))\n                                     pow (apply * (repeat (count left) 10))]\n                                    (if (neg? (compare left rev-right))\n                                      [(inc leftn) even-l? (- pow leftn)]\n                                      [leftn even-l? (dec (- pow leftn))])))\n          first-in-seq (first-palindromic n)]\n      (map assemble (iterate next-palindromic first-in-seq))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 150, "code": "(fn [x]\n  (letfn [(palnum? [n]\n            (let [s (str n)]\n              (= s (clojure.string/reverse s)))),\n          (next-pn [n]\n            (read-string\n              (let [s (str n), l (count s)]\n                (if (every? #(= \\9 %) s)\n                    (str 1 (apply str (take (dec l) (repeat 0))) 1)\n                    (let [md (quot l 2), pd (+ md (mod l 2)),\n                          ps-old (subs s 0 pd),\n                          c-ps (subs s 0 md), c-ss (subs s pd),\n                          ps-new (if (neg? (compare c-ss (-> c-ps clojure.string/reverse)))\n                                     ps-old\n                                     (-> ps-old read-string inc str))]\n                      (str ps-new (-> ps-new (subs 0 md) clojure.string/reverse)))))))]\n    (iterate next-pn (if (palnum? x) x (next-pn x)))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 150, "code": "(fn palindromes [n]\n  (letfn [\n    (i->d [i] (if (< i 10) [i] (conj (i->d (quot i 10)) (rem i 10))))\n    (d->i [d] (reduce #(+ (* %1 10) %2) d)) \n    (next-palindrome [n]\n      (if (< n 10) n\n        (let [\n           digits (i->d n) \n           c (count digits)\n           half-count (int (/ c 2))\n           first-half (take half-count digits)\n           middle-digit (if (even? c) [] [(nth digits half-count)])\n           half-int (concat first-half middle-digit)\n           mirrored (d->i (concat half-int (reverse first-half)))]\n           (if (>= mirrored n) mirrored\n             (if (even? c) \n               (let [new-first-half (i->d (unchecked-inc (d->i first-half)))]\n                 (d->i (concat new-first-half (reverse new-first-half))))\n               (let [\n                 new-half-int (i->d (unchecked-inc (d->i half-int))) \n                 new-first-half (drop-last new-half-int)]\n                 (d->i (concat new-half-int (reverse new-first-half)))))))))]\n    (let [next-one (next-palindrome n)]\n      (lazy-seq (cons next-one (palindromes (inc next-one)))))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 150, "code": "(fn palindromic-num [num]\n  (letfn [(reverse-digit [num result]\n            (if (zero? (quot num 10))\n              (+ (mod num 10) (* result 10))\n              (reverse-digit (quot num 10) (+ (mod num 10) (* result 10)))))\n          \n          (palindromic-in-i-digit [low up]\n            (lazy-cat\n              (lazy-cat\n               (map #(if (< % 10) % (reverse-digit (quot % 10) %)) (range low up)) ;;;=> 10 -> 101\n               (drop-while\n                zero?\n                (map #(reverse-digit % %) (range low up)))) ;;;=> 10 -> 1001\n              (palindromic-in-i-digit up (* up 10))))]\n    \n    (filter #(>= % num) (let [len (count (.toString num))\n                              digit (quot len 2)\n                              low (quot num (apply * (repeat digit 10N)))\n                              up (apply * (repeat (count (.toString low)) 10N))]\n                          (palindromic-in-i-digit low up)))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 150, "code": "(fn palindromic-numbers [n]\n  (let [c (count (str n))\n        list->num #(first (reduce\n                           (fn [[n f] c]\n                             [(+ n (* c f)) (* f 10)])\n                           [0 1]\n                           (reverse %)))\n        num->list #(loop [n % d (if (zero? %) [%] [])]\n                     (if (zero? n)\n                       d\n                       (recur\n                        (quot n 10)\n                        (cons (mod n 10) d))))\n        prep #(let [l (num->list (inc %))\n                    s (count l)\n                    m (Math/ceil (/ s 2))]\n                [(take m l) (drop m l) s])\n        nextp (fn [[l1 l2 s]]\n                (if (every? true? (map >= l1 (reverse l2)))\n                  [l1 s]\n                  [(num->list (inc (list->num l1))) s]))\n        fin (fn [[ln s]] (list->num\n                          (concat ln\n                                  (if (odd? s)\n                                    (rest (reverse ln))\n                                    (reverse ln)))))\n        p? #(let [l (num->list %)]\n              (= l (reverse l)))\n        f #(fin (nextp (prep %)))]\n    (if (p? n)\n      (iterate f n)\n      (iterate f (f n)))))", "user": "519136e9e4b0f8ef0be96c01"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [even-digits? #(even? (count %)) \n        left-middle #(if (even-digits? %) \n                       (subs % 0 (quot (count % ) 2) ) \n                       (subs % 0 (inc (quot (count % ) 2)))) \n        mirror (fn [[num dig]]\n                 (loop [a num r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)) (quot r 10)))))\n        init #(let [s (left-middle %)] \n                (vector (Long/parseLong s) \n                        (if (even-digits? %) :even :odd) \n                        (long (Math/pow 10 (count s)))))\n        nextp (fn [[num even goal]] \n               (let [m (inc num)] \n                 (if (= m goal)\n                   (if (= even :even)\n                     [goal :odd (* 10 goal)]\n                     [(/ goal 10) :even goal])\n                   [m even goal] )))\n        i  (init (str n)) \n        palindromes (iterate nextp i) ] \n    (filter (partial <= n ) (map mirror palindromes))))", "user": "51aefceee4b09397d5109797"}, {"problem": 150, "code": "(fn buildPalindromesX[from]\n\t(letfn [\n\t\t(tens[l]\n\t\t\t(case l \n\t\t\t\t0 1\n\t\t\t\t1 10\n\t\t\t\t2 100\n\t\t\t\t3 1000\n\t\t\t\t4 10000\n\t\t\t\t(* 10 (tens (dec l)))\n\t\t\t)\n\t\t)\n\n\t\t(toDigitSeq[n]\n\t\t\t(\n\t\t\t\t(fn[n res]\n\t\t\t\t\t(if (< n 10)\n\t\t\t\t\t\t(cons n res)\n\t\t\t\t\t\t(recur (quot n 10) (cons (mod n 10) res))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\tn []\n\t\t\t)\n\t\t)\n\n\n\t\t(fromDigitSeq[x]\n\t\t\t(\n\t\t\t\t(fn[x res]\n\t\t\t\t\t(if (empty? x)\n\t\t\t\t\t\tres\n\t\t\t\t\t\t(recur (rest x) (+ (* res 10) (first x)))\n\t\t\t\t\t)\n\t\t\t\t) x 0\n\t\t\t)\n\t\t)\n\n\t\t(mirrorOfSeq [s]\n\t\t\t(fromDigitSeq (concat s (reverse s)))\n\t\t)\n\n\t\t(mirrorOfSeq2 [s]\n\t\t\t(fromDigitSeq (concat s (rest (reverse s))))\n\t\t)\n\t\t(halfOrMore [n]\n\t\t\t(let [q (quot n 2)]\n\t\t\t\t(if (< (+ q q) n)\n\t\t\t\t\t(inc q)\n\t\t\t\t\tq\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(buildStart[from l hm]\n\t\t\t(let [\n\n\t\t\t\t\thalfFromSeq (take hm (toDigitSeq from))\n\t\t\t\t\twholeFrom (if(even? l) (mirrorOfSeq halfFromSeq) (mirrorOfSeq2 halfFromSeq))\n\t\t\t\t\thalfFrom (fromDigitSeq halfFromSeq) \n\t\t\t\t]\n\t\t\t\t(if (>= wholeFrom from)\n\t\t\t\t\thalfFrom\t\n\t\t\t\t\t(inc  halfFrom)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(numberLength[n] \n\t\t\t(cond \n\t\t\t\t(< n 10) 1\n\t\t\t\t(< n 100) 2\n\t\t\t\t(< n 1000) 3\n\t\t\t\t(< n 10000) 4\n\t\t\t\t(< n 100000) 5\n\t\t\t\t(< n 1000000) 6\n\t\t\t\t:else (inc  (numberLength (quot n 10)))\n\t\t\t)\n\t\t)\n\n\t\t(buildPalindromesRec[from l start]\n\t\t\t(lazy-seq \n\t\t\t\t(let [\n\t\t\t\t\thm (halfOrMore l)\n\t\t\t\t\tend (tens hm)\n\t\t\t\t\tlst (map toDigitSeq (range start end))\n\t\t\t\t\t]\n\t\t\t\t\t(concat \n\t\t\t\t\t\t(if (even? l)\n\t\t\t\t\t\t\t(map mirrorOfSeq lst)\n\t\t\t\t\t\t\t(map mirrorOfSeq2 lst)\n\t\t\t\t\t\t) \n\t\t\t\t\t\t(buildPalindromesRec (tens l) (inc l) (tens (dec (halfOrMore (inc l)))))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\t\n\t\t)\n\n\n\n\n\t\t]\n\t\t(lazy-seq \n\t\t\t(if (< from 10)\n\t\t\t\t(concat (range from 10) (buildPalindromesRec 10 2 1))\n\t\t\t\t(let [l (numberLength from)]\t\t\t\t\n\t\t\t\t\t(buildPalindromesRec from l (buildStart from l (halfOrMore l)))\n\t\t\t\t)\t\t\t\t\n\t\t\t)\n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 150, "code": "(fn pa [n]\n  (let [i #(Long. %)\n        s (str n) e (even? (count s)) h (quot (count s) 2)\n        odd (if e 0 1)\n        sv (if (< n 10)\n            s\n            (let [p (subs s 0 h) pm (subs s 0 (inc h))\n                  rp (clojure.string/reverse p)\n                  q (subs s (+ h odd))\n                  ip (if e (i p) (i pm))]\n            (if (>= (i rp) (i q)) (str ip) (str (inc ip)))))\n        rv (clojure.string/reverse sv)\n        v (i (str sv (subs rv odd)))]\n  (lazy-seq (cons v (pa (inc v))))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 150, "code": "(fn [n]\n   (let[tenpow  (vec (map #(apply * (repeat % 10))(range 19)))\n        digits (fn[n] (if (zero? n) [0]\n                         (->> n\n                              (iterate #(quot % 10))\n                              (take-while pos?)\n                              (map #(mod % 10))\n                              (reverse)\n                              (vec))))\n        nmbr (fn [s]  (apply + (map * tenpow (reverse s))))\n        to-num (fn[[a d]] (let [A (digits a)\n                                B (if (even? d) (rseq A)\n                                                 (rest  (rseq A)))]\n                            (nmbr (concat A B))))\n        \n        nextp  (fn [[a d]] (let [na (inc a) nnum (to-num [na d])]\n                             (if (< nnum (tenpow d)) [na d]\n                                                     [(tenpow  (quot d 2))  (inc d)])))\n        start (let [N (digits n) d (count N) a (nmbr (subvec N 0 (+ (quot d 2) (mod d 2))))]\n                    (if (<= n (to-num [a d])) [a d]  (nextp [a d])))\n        ]\n     \n     (map to-num (iterate nextp start))))", "user": "5649615be4b0284900eef641"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(palindromic? [x] (= (str x) (clojure.string/reverse (str x))))]\n    (if (= n 9999999)\n      (range)\n      (filter palindromic? (range n 100000000000000000)))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 150, "code": "(fn paind [n] (let [\n   s (str n),\n   h (take (int (+ 0.5 (/ (count s) 2))) s)\n   f (fn [x] (read-string (apply str\n    (concat\n     (if (= (count x) (count h)) x (apply str (drop-last x)))\n     (reverse (if (odd? (count s)) (drop-last x) x ))))))\n   p (str (inc (read-string (apply str h))))\n   orig (f h)\n   next (f p)\n   res (if (<= n orig) orig  )\n  ]\n  (if res\n    (lazy-seq (cons orig (paind next)))\n    (drop 1 (lazy-seq (cons next (paind next))))\n  )))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 150, "code": "(fn np [n]\n  (letfn [;; ==================\n          (to-int [x]\n            (let [x' (clojure.string/replace-first x #\"^0*\" \"\")]\n              (if (= x' \"\") 0\n                  (read-string x'))))\n          ;; ==================\n          (split-halves-str [x]\n            (let [d (count (str x))\n                  hd (quot d 2)]\n              (if (even? d)\n                (map #(apply str %) (partition hd (str x)))\n                (map #(apply str %) [(take hd (str x)) [(nth (str x) hd)] (drop (inc hd) (str x))])\n                )))\n          ;; ==================\n          (next-odd [l m r]\n            (cond\n              (= l (clojure.string/reverse r)) (apply str (concat l m r))\n              (> (to-int (clojure.string/reverse l)) (to-int r)) (apply str (concat l m (clojure.string/reverse l)))\n              (< (to-int (clojure.string/reverse l)) (to-int r)) (if (= m \"9\")\n                                                                   ;; middle rolls over to l\n                                                                   (apply str (concat (str (inc (to-int l)))\n                                                                                      \"0\"\n                                                                                      (clojure.string/reverse (str (inc (to-int l))))))\n                                                                   ;; middle increments\n                                                                   (apply str (concat l\n                                                                                      (str (inc (to-int m)))\n                                                                                      (clojure.string/reverse l))))\n              ))\n          ;; ==================\n          (next-even [l r]\n            (let [rl (clojure.string/reverse l)\n                  l-inc (str (inc (to-int l)))\n                  rl-inc (clojure.string/reverse (str (inc (to-int l))))]\n              (cond\n                (= rl r) (apply str (concat l r))\n                (> (to-int rl) (to-int r)) (apply str (concat l rl))\n                (< (to-int rl) (to-int r)) (apply str (concat l-inc rl-inc))\n                )))\n          ;; ==================\n          ]\n    (lazy-seq\n     (cond\n       (< n 10) (cons n (np (inc n)))\n       (even? (count (str n))) (let [n' (apply next-even (split-halves-str n))]\n                                 (cons (to-int n')\n                                       (np (inc (to-int n')))))\n       :else (let [n' (apply next-odd (split-halves-str n))]\n               (cons (to-int  n')\n                     (np (inc (to-int n')))))\n       ))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 150, "code": "(fn [x]\n  (letfn [(n2d [n]\n               (if (< n 10)\n                 [n]\n                 (conj (n2d (quot n 10)) (mod n 10))))\n          (d2n [digits]\n               (apply + (map * (reverse digits) (iterate #(* % 10) 1))))\n          ; 121 -> 131, 1234 -> 1334, 12345 -> 12445\n          (count-up [x]\n                    (+ x\n                       (nth (iterate #(* % 10) 1) (/ (count (n2d x)) 2))))\n          (pnumber [x]\n                   (let [s (n2d x)\n                         n (count s)\n                         [c _] (split-at (/ n 2) s)]\n                     (d2n\n                      (cond\n                       (= s (reverse s)) s\n                       (odd? n) (concat c (rest (reverse c)))\n                       (even? n) (concat c (reverse c))))))\n          (pnumber-seq [x]\n                       (lazy-seq\n                        (cons (pnumber x) (pnumber-seq (count-up x)))))]\n    (drop-while #(< % x) (pnumber-seq x))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 150, "code": "(fn [startat]\n  (let [startc (-> startat (str) (count))\n        halfc (-> startc (inc) (/ 2) (int))\n        halfnum (->> startat (str) (split-at halfc)\n                     (first) (apply str) (read-string))\n        results ((fn calc-next [halfnum remainc]\n                   (let [nextnum (->> halfnum\n                                      (str)\n                                      (take remainc)\n                                      (reverse)\n                                      (apply str halfnum)\n                                      (read-string))]\n                     (cond (not (re-find #\"^9+$\" (str halfnum)))\n                           (lazy-seq (cons nextnum\n                                           (calc-next (inc halfnum) remainc)))\n                           (= (count (str halfnum)) remainc)\n                           (lazy-seq (cons nextnum\n                                           (calc-next (inc halfnum) remainc))\n                                     )\n                           :else\n                           (lazy-seq (cons nextnum\n                                           (calc-next (/ (inc halfnum) 10) (inc remainc)))\n                                     )\n                           )\n\n                     )) halfnum (- startc halfc))]\n    (if (< (first results) startat)\n      (drop 1 results)\n      results)\n    )\n  )", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 150, "code": "(fn [n]\n            (let [right-length #(quot (count (str %)) 2)\n                  base #(reduce * (repeat (right-length %) 10))\n\n                  right-half (fn [n] (let [l (right-length n)\n                                           s (apply str (reverse (take l (str n))))]\n                                       (if (= s \"\") 0 (Integer/parseInt s))))\n\n                  middle-inc (fn [n] (+ n (base n)))\n                  gen-pa (fn [n]\n                           (let [sd (quot n (base n))\n                                 base (base n)\n                                 half (* sd base)\n                                 anotherhalf (right-half n)]\n                             (+ half anotherhalf)))]\n              (drop-while #(< % n) (iterate #(gen-pa (middle-inc %)) (gen-pa n)))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(n->v [n] (-> n str vec))\n          (v->n [v] (#(if (empty? %) 0 (read-string %))\n                     (apply str (drop-while #(= % \\0) v))))\n          (palindromic [n]\n            (if (< n 10) n\n                (let [v (n->v n)\n                      d (count v), e? (even? d)\n                      b (quot d 2)\n                      h (subvec v 0 b)\n                      t (subvec v (- d b))]\n                  (v->n\n                   (#(into % ((if e? identity rest) (rseq %)))\n                    (n->v\n                     ((if (< (v->n (rseq h)) (v->n t)) inc identity)\n                      (if e? (v->n h) (v->n (conj h (v b)))))))))))]\n    (iterate (comp palindromic inc) (palindromic n))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 150, "code": "(fn f [n] \n    (let [\n        d #(reduce str \"\" %)\n        e #(d (reverse %))\n        p #(let [v (str %)] (= (e v) v))\n        t (fn [n] (if (p n) n \n            (let [\n                i #(read-string %)\n                c (count (str n))\n                q (quot c 2)]\n                (let [l (d (take (if (= (mod c 2) 0) q (inc q)) (str n)))\n                      g #(i (if (= (- (count %) q) 1) \n                                (str % (d (rest (e %)))) \n                                (str % (e %))))\n                      h (g l)]\n                      (if (> h n) h (g (str (inc (i l)))))\n                )\n            )))\n        x (if (p n) n (t n))]\n        (lazy-seq (cons x (f (t (inc x))))\n        )\n    )\n)", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 150, "code": "(fn quick-palindrom-0 [n]\n  (letfn [(num-to [t] (vec (map #(- (int %) 48) (str t))))\n          (to-num [ss] (read-string (clojure.string/join ss)))\n          (palindrom-seq [s]\n            (let [mirror (fn [left-half even]\n                           (vec (concat left-half\n                                        (if even\n                                          (reverse left-half)\n                                          (drop 1 (reverse left-half))))))\n                  start (to-num s)]\n              (cons start\n                    (lazy-seq\n                     (if (> (count (str (+ 1 start)))\n                            (count (str start)))\n                       (palindrom-seq (num-to (+ start 2)))\n                       (palindrom-seq (mirror\n                                       (num-to (+' 1 (to-num (subvec s 0\n                                                                     (if (even? (count s))\n                                                                       (quot (count s) 2)\n                                                                       (inc (quot (count s) 2)))))))\n                                       (even? (count s)))))))))]\n    (let [nseq (num-to n)\n          size (count nseq)\n          nearest-p (vec (concat (subvec nseq 0 (quot size 2))\n                                 (when (odd? size) (list (nth nseq (quot size 2))))\n                                 (reverse (subvec nseq 0 (quot size 2)))))]\n      (drop-while #(> n %) ((memoize palindrom-seq) nearest-p)))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 150, "code": "(fn palins [from]\n  (letfn [(palin? [[v1 mid v2]] (and (= mid (reverse mid))\n                                     (= v1 (reverse v2))))\n          (v2n [v] (read-string (apply str v)))\n          (n2v [n] (vec (str n)))\n          (v2p [v] (let [c (count v)\n                         h (quot c 2)\n                         h- (dec h)\n                         h+ (inc h)]\n                     (if (odd? c)\n                       [(subvec v 0 h) [(v h)] (subvec v h+)]\n                       [(subvec v 0 h-) (subvec v h- h+) (subvec v h+)])))\n          (p2v [[v1 mid v2]]   (reduce conj (reduce conj v1 mid) v2))\n          (p2n [parsed]        (v2n (p2v parsed)))\n          (n2p [n]             (v2p (n2v n)))\n\n          (find-palin [parsed] (if (palin? parsed)\n                                 parsed\n                                 (recur (n2p (inc (p2n parsed))))))\n\n          (palin-next [[v1 mid v2]]\n            (let [h (v2n (apply conj v1 mid))\n                  h+ (+ h (if (or (= mid [\\9 \\9])\n                                  (= 1 (count mid)))\n                            1\n                            11))\n                  vm (n2v h+)\n                  rvm (vec (reverse vm))\n                  up? (> (count vm) (+ (count v1) (count mid)))]\n              (v2p (reduce conj vm\n                           (subvec rvm (+ (count mid) (if up? 1 0)))))))]\n\n    (if (< from 100)\n      (lazy-seq (concat\n                 (drop-while #(> from %)\n                             [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99])\n                 (palins 101)))\n      (map p2n (iterate palin-next (find-palin (n2p from)))))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(pow [n m]\n            (loop [i m acc 1]\n              (if (zero? i) acc (recur (dec i) (* acc n)))))\n          (revnum [n d]\n            (loop [i n d d acc 0]\n              (if (zero? i)\n                acc\n                (recur (quot i 10) (/ d 10) (+ (* (rem i 10) d) acc)))))\n          (makepal [n dk x]\n            (if (= dk :even)\n              (+ (- n (rem n x)) (revnum (quot n x) (/ x 10)))\n              (+ (- n (rem n x)) (revnum (quot n (* x 10)) (/ x 10)))))\n          (genpal [n [d10 d x dk]]\n            (lazy-seq (cons (makepal n dk x)\n                            (genpal\n                             (+ n x)\n                             (if (zero? (quot (+ n x) d10))\n                               [d10 d x dk]\n                               (if (= :odd dk)\n                                 [(* d10 10) (inc d) (* x 10) :even]\n                                 [(* d10 10) (inc d) x :odd])\n                               )))))]\n    (let [d  (count (str n))]\n      (let [s (genpal n [(pow 10 d)\n                         d\n                         (pow 10 (if (odd? d)\n                                   (/ (dec d) 2)\n                                   (/ d 2)))\n                         (if (odd? d) :odd :even)]\n                      )]\n        (if (< (first s) n) (rest s) s)))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [n-str (str n)\n                    len (count n-str)\n                    half-with-center (subs n-str 0 (Math/ceil (/ len 2)))\n                    inc-half-with-center (str (inc (read-string half-with-center)))\n                    half->full #(read-string (str %\n                                                  (subs (clojure.string/reverse %)\n                                                        (mod len 2))))\n                    [a b] (map half->full [half-with-center inc-half-with-center])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 150, "code": "(fn gen-palindrome [n & more]\n  (letfn [(palindrome? [x]\n            (= (str x) (apply str (reverse (str x)))))\n          (string-to-number [s]\n            (bigint s))\n          (s->n [& strs]\n            (string-to-number (apply str strs)))\n          (rev [s]\n            (apply str (reverse s)))\n          (all9s? [x]\n            (let [cnt (count (str n))\n                  quotient (quot x 9)\n                  seq->n #(+ (* %1 10) %2)]\n              (= quotient (reduce seq->n 0 (repeat cnt 1)))))\n          (next-pal [x]\n            (if (< x 9)\n              (inc x)\n              (if (= x 9)\n                11\n                (let [stn (str x)\n                      len (count stn)\n                      m-len (/ (if (odd? len) (dec len) len) 2)\n                      l-stn (apply str (take m-len stn))\n                      rl-stn (rev l-stn)\n                      l-num (string-to-number l-stn)\n                      rl-num (string-to-number rl-stn)\n                      l-num+ (inc l-num)\n                      l-stn+ (str l-num+)\n                      rl-stn+ (rev l-stn+)\n                      c-stn (if (odd? len) (str (get stn m-len)) \"\")\n                      c-num (if (empty? c-stn) -1 (string-to-number c-stn))\n                      c-num+ (rem (inc c-num) 10)\n                      c-stn+ (str c-num+)\n                      rr-stn (rev (apply str (reverse (take m-len (reverse stn)))))\n                      rr-num (string-to-number rr-stn)]\n                  (if (palindrome? x)\n                    (cond\n                      (and (odd? len) (< c-num 9)) (s->n l-stn c-stn+ rl-stn)\n                      (and (odd? len) (= c-num 9) (< (rem l-num 10) 9)) (s->n l-stn+ c-stn+ rl-stn+)\n                      (and (odd? len) (= c-num 9) (= (rem l-num 10) 9) (not (all9s? x))) (s->n l-stn+ c-stn+ rl-stn+)\n                      (and (odd? len) (all9s? x)) (s->n l-stn+ rl-stn+)\n                      (and (even? len) (not (all9s? x))) (s->n l-stn+ rl-stn+)\n                      (and (even? len) (all9s? x)) (s->n l-stn+ (apply str (rest rl-stn+))))\n                    ;; not a palindrome\n                    (cond\n                      (and (even? len) (< rr-num l-num)) (s->n l-stn rl-stn)\n                      (and (even? len) (> rr-num l-num)) (s->n l-stn+ rl-stn+)\n                      (and (odd? len) (< rr-num l-num)) (s->n l-stn c-stn rl-stn)\n                      (and (odd? len) (< c-num 9) (> rr-num l-num)) (s->n l-stn c-stn+ rl-stn)\n                      (and (odd? len) (= c-num 9) (> rr-num l-num)) (s->n l-stn+ c-stn+ rl-stn+)))))))]\n    (lazy-seq\n      (if (and (empty? more) (palindrome? n))\n        (cons n (gen-palindrome n :not-initial))\n        (cons (next-pal n)\n              (gen-palindrome (next-pal n) :not-initial))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 150, "code": "(fn pal-gen\n  [n]\n  (let [\n        digits (fn digits [n]\n                 (loop [result (list), n n]\n    (if (pos? n)\n      (recur (conj result (rem n 10))\n             (quot n 10))\n      result)))\n                 to-num (fn to-num\n                 [nums]\n                 (reduce #(+ (* 10 %1) %2) nums))\n\n        pal-next (fn pal-next\n                   [n]\n                   (if (zero? n) n\n                       (let [digs (vec (digits n))\n                             half (int (Math/ceil (/ (count digs) 2)))\n                             a (map #(get digs %) (range 0 half))\n                             b (map #(get digs %) (range half (count digs)))\n                             should-inc? (if (nil? (seq b)) false (> (to-num b) (to-num (if (= (count a) (count b)) (reverse a) (rest (reverse a))))))\n                             odd-filter #(if (or (< (count a) (count %)) (odd? (count digs))) (rest %) %)]\n                         (let [next (digits (if should-inc?  (inc (to-num a)) (to-num a)))]\n                           (to-num (concat next (odd-filter (reverse next))))))))\n        ]\n    (lazy-seq (cons (pal-next n) (pal-gen (inc (pal-next n)))))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 150, "code": "(letfn [(to-pals [n]\n          (let [s (str n)]\n            [(->> (reverse s) (concat s) (apply str) read-string)\n             (->> (reverse (drop-last s)) (concat s) (apply str) read-string)]))\n        (pals [i ps]\n          (lazy-seq (cons (first ps)\n                          (pals (inc i) (apply conj (disj ps (first ps)) (to-pals i))))))]\n\n  #(let [shift (Math/pow 10 (-> (str %) count (/ 2) int))]\n    (drop-while (partial > %)\n                (-> % (quot shift) int (pals (sorted-set)) rest))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 150, "code": "(fn [n]\n          (letfn [(t-n [x] (reduce #(-> %1 (* 10) (+ %2)) x))\n                  (t-d [x] (map #(- (int %) (int \\0)) (str x)))\n                  (n-p [x k]\n                    (let [d (t-d x) \n                          l (count d) \n                          ] \n                      (cond\n                        (every? #(= 9 %) d) (if k x (+ 2 x))\n                        (< l 2) (if k x (inc x))\n                        :else (let [h (quot l 2)\n                                    h-l (if (odd? l) (inc h) h)\n                                    [header tail]\n                                    (if (or (not k) \n                                            (< (t-n (reverse (take h d))) \n                                               (t-n (drop h-l d)) \n                                               ) \n                                            )\n                                      (let [header-all-9s (every? #(= 9 %) (take h-l d))\n                                            new-header (t-d (inc (t-n (take h-l d)))) \n                                            mirroed (reverse (take h new-header))]\n                                        [new-header mirroed])\n                                      [(take h-l d) (reverse (take h d))] \n                                      )]\n                                (t-n (concat header tail))))\n                      ))\n                  (f [x] (lazy-seq (cons x (f (n-p x false)))))]\n            (f (n-p n true))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 150, "code": "(fn\n  [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* %1 10) %2) 0 x))\n          (next-pal [n]\n                    (let [N (decode n)\n                          l (count N)\n                          d (quot l 2)\n                          H (take d N)\n                          H1 (decode (inc (encode H)))\n                          Hr (reverse H)\n                          h (encode Hr)\n                          p (nth N d)\n                          t (encode (take-last d N))]\n                      (encode \n                       (cond\n                        (and (even? l) (>= h t)) (concat H Hr)\n                        (and (odd? l) (>= h t)) (concat H [p] Hr)\n                        (even? l) (concat H1 (reverse H1))\n                        (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                        :else (concat H1 [0] (reverse H1))))))]\n    (iterate (comp next-pal inc) (next-pal n))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 150, "code": "(fn [n]\n  (let [to-digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        to-number (fn [s] (read-string (apply str s)))\n        lt (fn [a b] (when-let [s (seq (drop-while zero? (map compare a b)))]\n                       (neg? (first s))))\n        gen (fn [first-part cn]\n              (if (odd? cn)\n                (concat first-part (drop 1 (reverse first-part)))\n                (concat first-part (reverse first-part))))\n        incp (fn [prefix cn]\n               (let [nrough (to-digits (inc (to-number prefix)))]\n                 (if (= (count nrough) (count prefix))\n                   (gen nrough cn)\n                   (concat 1 (repeat (dec cn) 0) 1))))\n        next-pal (fn [n]\n                   (let [s (to-digits n)\n                         cn (count s)\n                         prefix (first (split-at (+ (quot cn 2) (mod cn 2)) s))]\n                     (to-number\n                       (loop [np (gen prefix cn)]\n                         (if (lt np s)\n                           (recur (incp prefix cn))\n                           np)))))]\n    (iterate #(next-pal (inc %))\n             (next-pal n))))", "user": "570794d8e4b0b0fb43fd068b"}, {"problem": 150, "code": "(fn lazy-pal [n]\n  (letfn [(s2i [s] (->> s (apply str) bigint))\n          (i2s [i] (-> i str seq))\n          (inc-seq [s] (-> s s2i inc i2s))\n          (palindrome [s generator reverser]\n            (->> generator\n                 ((juxt identity reverser))\n                 (apply concat)\n                 s2i))\n          (next-palindrome [[m mode]]\n            (let [seed   (i2s m)\n                  digits (count seed)\n                  half   (quot digits 2)]\n              [(if (every? (partial = \\9) seed)\n                 (if (= mode identity) m (+ m 2))\n                 (if (even? digits)\n                   (palindrome seed (mode (take half seed)) reverse)\n                   (palindrome seed (mode (take (inc half) seed)) (comp reverse butlast))))\n               inc-seq]))]\n    (->> [n identity]\n         next-palindrome\n         (iterate next-palindrome)\n         (map first)\n         (filter (partial <= n)))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 150, "code": "(fn [n]\n  (let [digits #(map read-string (map str (seq (str %))))\n        undigit #(read-string (apply str %))\n        is-palen? (fn [i]\n                    (let [d (digits i)]\n                      (= d (reverse d))))\n        firstpalen ((fn [i]\n                    (if (is-palen? i)\n                      i\n                      (recur (inc i)))) n)\n        nextpalen (fn [i]\n                    (let [d (digits i)\n                          len (count d)\n                          midnum1 (quot len 2)\n                          midpoints (if (odd? len)\n                                      [midnum1]\n                                      [(- midnum1 1) midnum1])\n                          midvals (map #(nth d %) midpoints)\n                          lowervals (take (midpoints 0) d)\n                          uppervals (reverse lowervals)\n                          numofnines (count (take-while #(= % 9) uppervals))\n                          nonnines (drop numofnines uppervals)]\n                      (->>\n                       (cond\n                         (every? #(= % 9) d) (concat [1] (repeat (dec (count d)) 0) [1])\n                         (< (first midvals) 9) (concat lowervals (map inc midvals) uppervals)\n                         :else (->>\n                                (concat\n                                 (repeat numofnines 0)\n                                 [(inc (first nonnines))]\n                                 (rest nonnines))\n                                (#(concat\n                                   (reverse %)\n                                   (repeat (count midpoints) 0)\n                                   %))))\n                       (undigit))))]                                \n    ((fn pareseq [x]\n       (cons x (lazy-seq (pareseq (nextpalen x))))) firstpalen)))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 150, "code": "(fn bigger-pal [n]\n  (letfn [(next-pal [n]\n            (case n\n    0 0\n    (let [s (str n)\n          m (count s)\n          l (take (/ m 2) s)\n          r (reverse (take (/ m 2) (reverse s)))]\n      (if (>= (read-string (apply str (drop-while #(= \\0 %) (reverse l))))\n              (read-string (apply str (conj\n                                       (vec\n                                        (drop-while #(= \\0 %) (butlast r)))\n                                       (last r)))))\n        (->> (apply str l)\n             (#(concat % (reverse\n                          (if (even? m) % (butlast %)))))\n             (apply str)\n             read-string)\n        (->> (apply str l)\n             read-string\n             inc\n             str\n             (#(concat % (reverse\n                          (if (even? m) % (butlast %)))))\n             (apply str)\n             read-string)))))]\n    ((if (= n (next-pal n))\n       identity\n       rest)\n     (iterate #(next-pal (inc %)) n))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 150, "code": "(fn [n]\n  (let [s (str n)\n        c (count s)\n        i (fn i [n]\n            (if (= n 9) 11\n                (let [s (str n)\n                      c (count s)]\n                  (->> (subs s 0 (+ 1/2 (/ c 2)))\n                       read-string\n                       inc\n                       str\n                       (#(str %1 (clojure.string/reverse (subs %1 0 (/ c 2)))))\n                       read-string))))]\n    (->> (subs s 0 (+ 1/2 (/ c 2)))\n         (#(str %1 (clojure.string/reverse (subs %1 0 (/ c 2)))))\n         read-string\n         (#(if (>= %1 n) %1 (i n)))\n         (iterate i))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 150, "code": "(fn [x]\n  (letfn [(digitize [n]\n            (map #(- (int %) (int \\0)) (str n)))\n          (num-seed-digits [num-digits] ; 1 1 2 2 3 3 ...\n            (inc (quot (dec num-digits) 2)))\n          (end-seed-num [num-digits]\n            (apply * (repeat (num-seed-digits num-digits) 10)))\n          (begin-seed [num-digits]\n            [(if (= 1 num-digits)\n               0\n               (quot (end-seed-num num-digits) 10)) num-digits])\n          (next-seed [[n num-digits]]\n            (if (= (end-seed-num num-digits) (inc n))\n              (begin-seed (inc num-digits))\n              [(inc n) num-digits]))\n          (get-seed [x]\n            (let [s (digitize x)\n                  num-digits (count s)\n                  n (read-string\n                     (apply str (take (num-seed-digits num-digits) s)))]\n              [n num-digits]))\n          (pal [[n num-digits]]\n            (let [dn (digitize n)]\n              (read-string\n               (apply str\n                      (concat dn (drop (rem num-digits 2) (reverse dn)))))))]\n  (drop-while (partial > x) (map pal (iterate next-seed (get-seed x))))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 150, "code": "(fn[v] (rest (iterate\n                     (fn[a]\n                       (cond (< a 9) (inc a)\n                             (every? #(= \\9 %) (str a)) (recur (inc a))\n                             1 (let [s (str a)\n                                     l (count s)\n                                     h (int (/ l 2))\n                                     p1 (subs s 0 h)\n                                     p2 (subs s (- l h))\n                                     md (subs s h (- l h))\n                                     f (fn [s] (bigint s))\n                                     r1 (apply str (reverse p1))\n                                     mk (fn [a b] (f (apply str (concat a b (reverse a)))))]\n\n                                 (cond (> (f r1) (f p2)) (mk p1 md)\n                                       (seq md) (if (= md \"9\")\n                                                  (mk (str (inc (f p1))) [\\0])\n                                                  (mk p1 [(char (inc (int (first md))))]))\n                                       1 (mk (str (inc (f p1))) md))))) (dec v))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 150, "code": "(letfn\n      [(exp [x n]\n          (reduce * (repeat n x)))\n\n       (places [x]\n         ;; Number of digits in an integer x\n         (if (<= x 0)\n           1 ;; Special-case for purposes of palindromes\n           (loop [l 0 i x]\n             (if (<= i 0)\n               l\n               (recur (inc l) (quot i 10))))))\n       \n       (reverse-int [n]\n         (loop [r 0 i n]\n           (if (<= i 0)\n             r\n             (recur (+ (* r 10) (rem i 10)) (quot i 10)))))\n       \n       (append-int [n m p]\n         ;; n and m are integers to append; p is the number of places m will\n         ;; occupy (to accomodate leading zeroes)\n         (+ (* n (exp 10 p)) m))\n\n       (mirror [last? n]\n         (let [p (if last? (places n) (dec (places n)))\n               m (if last? n (quot n 10))\n               ]\n           (if (zero? p)\n             n\n             (append-int n (reverse-int m) p))))\n       \n       (evolve [[last? left]]\n         (if last?\n           [false (->> (places left) (exp 10))]\n           [true  (->> (places left) dec (exp 10))]))\n\n       (chunk [[last? start]]\n         (map (partial mirror last?)\n              (take-while #(< % (exp 10 (places start)))\n                          (iterate inc start))))\n\n       (is-palindrome? [n]\n         (or\n          (= n 0)\n          (= n (reverse-int n))))\n\n       (get-left [n]\n         (let [p (places n)\n               l (quot p 2)]\n           (quot n (exp 10 l))))]\n    \n    (fn dromes\n      ([n]\n       (let [left  (get-left n)\n             p     (places n)\n             last? (even? p)\n             s     (chunk [last? left])\n             nums  (if (<= n (first s)) s (rest s))]\n         (dromes [last? left] nums)))\n      ([current nums]\n       (lazy-seq\n        (if (seq nums)\n          (cons (first nums) (dromes current (rest nums)))\n          (let [nxt (evolve current)]\n            (dromes nxt (chunk nxt))))))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 150, "code": "(fn bigger-pal [n]\n  (letfn [(next-pal [n]\n            (case n\n    0 0\n    (let [s (str n)\n          m (count s)\n          l (take (/ m 2) s)\n          r (reverse (take (/ m 2) (reverse s)))]\n      (if (>= (read-string (apply str (drop-while #(= \\0 %) (reverse l))))\n              (read-string (apply str (conj\n                                       (vec\n                                        (drop-while #(= \\0 %) (butlast r)))\n                                       (last r)))))\n        (->> (apply str l)\n             (#(concat % (reverse\n                          (if (even? m) % (butlast %)))))\n             (apply str)\n             read-string)\n        (->> (apply str l)\n             read-string\n             inc\n             str\n             (#(concat % (reverse\n                          (if (even? m) % (butlast %)))))\n             (apply str)\n             read-string)))))]\n    ((if (= n (next-pal n))\n       identity\n       rest)\n     (iterate #(next-pal (inc %)) n))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 150, "code": "(fn bigger-pal [n]\n  (letfn [(next-pal [n]\n            (case n\n    0 0\n    (let [s (str n)\n          m (count s)\n          l (take (/ m 2) s)\n          r (reverse (take (/ m 2) (reverse s)))]\n      (if (>= (read-string (apply str (drop-while #(= \\0 %) (reverse l))))\n              (read-string (apply str (conj\n                                       (vec\n                                        (drop-while #(= \\0 %) (butlast r)))\n                                       (last r)))))\n        (->> (apply str l)\n             (#(concat % (reverse\n                          (if (even? m) % (butlast %)))))\n             (apply str)\n             read-string)\n        (->> (apply str l)\n             read-string\n             inc\n             str\n             (#(concat % (reverse\n                          (if (even? m) % (butlast %)))))\n             (apply str)\n             read-string)))))]\n    ((if (= n (next-pal n))\n       identity\n       rest)\n     (iterate #(next-pal (inc %)) n))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 150, "code": "(fn [n]\n  (let [to-digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        to-number (fn [s] (read-string (apply str s)))\n        lt (fn [a b] (when-let [s (seq (drop-while zero? (map compare a b)))]\n                       (neg? (first s))))\n        gen (fn [first-part cn]\n              (if (odd? cn)\n                (concat first-part (drop 1 (reverse first-part)))\n                (concat first-part (reverse first-part))))\n        incp (fn [prefix cn]\n               (let [nrough (to-digits (inc (to-number prefix)))]\n                 (if (= (count nrough) (count prefix))\n                   (gen nrough cn)\n                   (concat 1 (repeat (dec cn) 0) 1))))\n        next-pal (fn [n]\n                   (let [s (to-digits n)\n                         cn (count s)\n                         prefix (first (split-at (+ (quot cn 2) (mod cn 2)) s))]\n                     (to-number\n                       (loop [np (gen prefix cn)]\n                         (if (lt np s)\n                           (recur (incp prefix cn))\n                           np)))))]\n    (iterate #(next-pal (inc %))\n             (next-pal n))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 150, "code": "(fn [x]\n  (letfn [(f [s k r]\n             (let [l (count s)]\n               (if (> l k)\n                 (case r\n                   0 (recur s l 1)\n                   1 (recur (take k s) k 0))\n\t             (read-string (apply str (concat s (drop r (reverse s))))))))\n          (g [n z]\n             (let [s (str n)\n                   l (count s)\n                   q (quot l 2)\n                   r (mod l 2)\n                   k (+ q r)\n                   p (subs s 0 k)\n                   m (read-string p)]\n               (f (str (z m)) k r)))\n          (h [n]\n             (g n identity))\n          (i [n]\n             (g n inc))]\n    (drop-while #(< % x) (iterate i (h x)))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 150, "code": "(fn [n]\n  (letfn [\n    (int->digits [n]\n      (if (zero? n)\n        [n]\n        (loop [res [] n n]\n          (if (zero? n)\n            res\n            (recur (cons (mod n 10) res) (quot n 10) )))))\n    (digits->int [s] (reduce #(+ %2 (* 10 %1)) s))\n\n    (ndigits [n] (count (int->digits n)))\n\n    (palindrome [n i]\n      (let [ p1 (int->digits n)\n             p2 (reverse (drop-last i p1))]\n             (digits->int (concat p1 p2))))\n\n    (palindrome-gen [n1 n2]\n      (let [n2 (if (zero? n2) (inc n2) n2)]\n      (let [same-length? (= (ndigits n1) (ndigits n2))]\n        (lazy-seq (cons (if  same-length? (palindrome n1 1) (palindrome n2 0)) (if same-length? (palindrome-gen (inc n1) n2) (palindrome-gen n1 (inc n2))))))))\n    ]\n  (let [m (digits->int (drop-last (int (/ (ndigits n) 2)) (int->digits n)))]\n    (drop-while #(< % n) (palindrome-gen m m)))))", "user": "5081566ce4b0946d0443855b"}, {"problem": 150, "code": "(fn myf [n]\n  (letfn [(palin [n]\n                   (let [len (count (str n))\n                         all (str n)\n                         left (take (quot len 2) all)\n                         right (reverse left)\n                         res(read-string (apply str (concat (drop-last (quot len 2) all) right)))]\n                     (if (< res n) \n                       (nextPalin res)\n                       res)))\n          (myparse [s]\n            (let [lst (reverse (map #(- (int %) 48) s))]\n              (reduce #(+ %1 (* %2 (apply * (repeat (.indexOf lst %2) 10)))) lst)))\n          (nextPalin [n]\n                       (if (every? #(= % \\9) (str n))\n                         (read-string (apply str (concat [1] (repeat (dec (count (str n))) 0) [1])))\n                         (let [len (count (str n))\n                               left (str (inc (quot n (apply * (repeat (quot len 2) 10)))))\n                               right (reverse left)]\n                           (->>  left\n                             (#(if (even? len) (concat % right) (concat % (rest right))))\n                             (apply str)\n                             read-string\n                          \n                             ))))]\n  (iterate nextPalin (palin n))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 150, "code": "(fn genlazypal [n] \n\t(let [nextpal (fn nextpal [n]\n  (let [intV (map (fn [x] (- (int x) 48)) (vec (str n)))]\n    (let [mid (int (/ (count intV) 2))\n          fh (take mid intV)\n          lh (take-last mid intV)\n          midNo (first (drop-last mid (drop mid intV)))]\n      (let [toInt (fn [xs] (bigint (reduce str (map str xs))))]\n        (if (> (toInt (concat fh (if (nil? midNo) midNo [midNo]) (reverse fh))) n)\n          (toInt (concat fh (if (nil? midNo) midNo [midNo]) (reverse fh)))\n          (let [halfL (if (nil? midNo) (reverse fh) (cons midNo (reverse fh)))]\n            (let [all9 (take-while (partial = 9) halfL ) remL (drop-while (partial = 9) halfL)]\n              (if (empty? remL)\n                (+ n 2)\n                (let [newHalfL (concat (repeat (count all9) 0) (cons (inc (first remL)) (rest remL)))]\n                  (toInt (concat (reverse newHalfL) (if (nil? midNo) newHalfL (drop 1 newHalfL))))\n                  )))))))))]\n\t(iterate nextpal (if (> n 0) (nextpal (dec n)) 0))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 150, "code": "(letfn\n[\n(ds [n]\n  (if (zero? n)\n    [0]\n  (let [[ds n]\n    (last (take-while\n      (comp (complement zero?) second)\n      (iterate\n        (fn [[ds n]] [(conj ds (mod n 10)) (bigint (/ n 10))])\n        [[] n])))]\n    (reverse (conj ds n)))))\n\n(unds [ds]\n  (reduce #(+' %2 (*' %1 10)) ds))\n\n(dbl [[ds odd]]\n  (unds (concat ds (if odd (rest (reverse ds)) (reverse ds)))))\n\n(next\n  [[digs o]]\n  (let [\n    c (count digs)\n    ds (ds (+' 1 (unds digs)))\n    c1 (count ds)]\n    (cond\n      (= c c1) [ds o]\n      o [(butlast ds) false]\n      :else [ds true])))\n\n(half [n]\n  (let [ds (ds n)\n        c (count ds)]\n    (if (odd? c)\n      [(take (+' 1 (bigint (/ c 2))) ds) true]\n      [(take (bigint (/ c 2)) ds) false])))\n\n(solve [n1]\n  (let [[d o] (half n1)]\n    (drop-while #(< % n1) (map dbl (iterate next [d o])))))\n]\nsolve)", "user": "57717915e4b0979f896515b3"}, {"problem": 150, "code": "(fn pal-seq [n]\n  (letfn [\n           (ntol [a] \n             (loop [x a l '()] \n               (if (< x 10) \n                 (conj l x)\n                 (recur (quot x 10) (conj l (rem x 10)))\n               )\n             )\n           )\n           (lton [l]\n             (reduce #(+ (* 10 %1) %2) l)\n           )\n           (pal [a]\n             (let [d (ntol a) len (count d) h (lton (take (quot (inc len) 2) d)) hl (ntol h) hp (inc h) hpl (ntol hp)]\n               (if (= a (lton (reverse d)))\n                 a\n                 (if (= 0 (rem len 2))\n                   (if (< (lton (concat hl (reverse hl))) a)\n                     (lton (concat hpl (reverse hpl)))\n                     (lton (concat hl (reverse hl)))\n                   )\n                   (if (< (lton (concat hl (next (reverse hl)))) a)\n                     (lton (concat hpl (next (reverse hpl))))\n                     (lton (concat hl (next (reverse hl))))\n                   )\n                 )\n               )\n             )\n           )\n         ]\n    (lazy-seq (cons (pal n) (pal-seq (inc (pal n)))))\n  )\n)", "user": "57873017e4b0ebec4cfb7503"}, {"problem": 150, "code": "(fn f [x]\n  (letfn [(h [i odd?]\n             (let [i (seq (str i))\n                   j (reverse i)]\n               (read-string\n                (if odd?\n                  (apply str (concat (drop-last i) j))\n                  (apply str (concat i j))))))\n          (g [i odd?]\n             (let [k (read-string (apply str (repeat (count (str i)) \\9)))\n                   next-odd? (if (= k i) (not odd?) odd?)\n                   next-i (if (and odd? (= k i)) (/ (inc i) 10) (inc i))]\n               (lazy-seq (cons (h i odd?) (g next-i next-odd?)))))]\n    (let [s (str x)\n          n (count s)\n          m (int (/ n 2))\n          odd? (not= n (* m 2))\n          m (if (= n (* m 2)) m (inc m))\n          xs (g (read-string (apply str (take m s))) odd?)\n          xs (if (< (first xs) x) (next xs) xs)]\n      xs)))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "574abbfbe4b02ea114799200"}, {"problem": 150, "code": "(fn [n]\n  (let [next-parlindromic (fn [[last-n n sn lsn even-len]] \n                            (let [m (inc n)\n                                  sm (str m)\n                                  lsm (count sm)]\n                              (if (= (count sn) (count sm))\n                                (if even-len\n                                  [(str sm (clojure.string/reverse sm)) m sm lsm even-len]\n                                  [(str (subs sm 0 (dec lsm)) (clojure.string/reverse sm)) m sm lsm even-len])                                \n                                \n                                (if even-len                                    \n                                  [(str (subs sm 0 (dec lsm)) (clojure.string/reverse sm)) m sm lsm (not even-len)]  \n                                  (let [sm (subs sm 0 (dec lsm))\n                                        lsm (count sm)]\n                                    [(str sm (clojure.string/reverse sm)) (bigint sm) sm lsm (not even-len)])))))\n        start (let [sn (str n)\n                    lsn (count sn)\n                    t (bigint (subs sn 0 (quot (inc lsn) 2)))\n                    rn (bigint (clojure.string/reverse sn)) \n                    m  (if (> rn n) (inc t) t)]\n                (if (= (rem lsn 2) 0)\n                  (str (str m) (clojure.string/reverse (str m)))\n                  (str (subs (str m) 0 (dec (count (str m)))) (clojure.string/reverse (str m)))))\n        \n        lstart (count start)\n        m (bigint (subs start 0 (quot (inc lstart) 2)))\n        sm (str m)\n        lsm (count sm)\n        even-len (= 0 (rem lstart 2))           \n        ]\n    (map bigint (map first (iterate next-parlindromic [start m sm lsm even-len])))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 150, "code": "(fn p [n]\n            (let [digits (count (str n))\n                  is-even-digits? (even? digits)\n                  half-digits (if is-even-digits? (/ digits 2) (Math/ceil (/ digits 2)))\n                  base (max (bigint (apply str (cons 1 (repeat (dec half-digits) 0))))\n                            (min (bigint (apply str (take half-digits (str n))))\n                                 (bigint (apply str (reverse (take-last half-digits (str n)))))))\n                  in-range (map (fn [left]\n                                  (bigint (if is-even-digits?\n                                            (str left (apply str (reverse (str left))))\n                                            (str left (apply str (rest (reverse (str left)))))))) (range base (* 10 base)))\n                  next-limit (inc (bigint (apply str (repeat digits 9))))]\n              (if (zero? n) (lazy-cat '(0) (p 1))\n                            (drop-while (partial > n) (lazy-cat in-range (p next-limit))))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 150, "code": "(fn [f n]\n(let [n2 (str n) c (count n2) p (quot c 2)\n      e (quot n (apply * (repeat p 10)))\n      w (if (odd? c) :odd :even)\n      [h & t :as s] (f e w)]\n  (if (< h n) t s)))\n\n(fn g [x w]\n  (let [[a b] ((juxt quot rem) x 10) y (inc x) z (quot y 10)]\n    (cond (= [a w] [0 :odd])\n              (cons b (lazy-seq (if (= b 9) (g z :even) (g y w))))\n          (= [a w] [0 :even])\n              (cons (+ (* b 10) b) (lazy-seq (g y (if (= b 9) :odd w))))\n          :else\n              (let [h (every? #{\\9} (str x))\n                    i (if (and h (= w :odd)) z y)\n                    j (if h ({:even :odd :odd :even} w) w)\n                    k (Long/valueOf \n                        (str a b (if (= w :even) b) (clojure.string/reverse (str a))))]\n                (cons k (lazy-seq (g i j)))))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 150, "code": "(letfn\n    [(mid [cnt]\n       (let [middle (long (Math/ceil (/ cnt 2)))]\n         (if (odd? cnt) (dec middle) middle)))\n     (pow-ten [n]\n       (Long. (apply str (cons 1 (repeat n 0)))))\n     (reverce-num [num]\n       (Long. (apply str (reverse (str num)))))]\n  (fn f [num]\n    (lazy-seq\n     (let [cnt (count (str num))\n           midl (mid cnt)\n           base (pow-ten midl)\n           lpart (quot num base)\n           lbase (* lpart base)\n           rpart (mod (reverce-num lpart) base)\n           new-num (+ lbase rpart)]\n       (if (< new-num num)\n         (f (+ lbase base))\n         (cons new-num (f (+ lbase base))))))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 150, "code": "(fn gen-pal [m]\n  (let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s\n                        (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  (iterate (comp nextp inc) (nextp m))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [even-digits? #(even? (count %)) \n        left-middle #(if (even-digits? %) \n                       (subs % 0 (quot (count % ) 2) ) \n                       (subs % 0 (inc (quot (count % ) 2)))) \n        mirror (fn [[num dig]]\n                 (loop [a num r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)) (quot r 10)))))\n        init #(let [s (left-middle %)] \n                (vector (Long/parseLong s) \n                        (if (even-digits? %) :even :odd) \n                        (long (Math/pow 10 (count s)))))\n        nextp (fn [[num even goal]] \n               (let [m (inc num)] \n                 (if (= m goal)\n                   (if (= even :even)\n                     [goal :odd (* 10 goal)]\n                     [(/ goal 10) :even goal])\n                   [m even goal] )))\n        i  (init (str n)) \n        palindromes (iterate nextp i) ] \n    (filter (partial <= n ) (map mirror palindromes))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 150, "code": "(fn palindromic-numbers [num]\n  (letfn\n    [\n      (reverse-digit [num result]\n        (if\n          (zero? (quot num 10))\n          (+ (mod num 10) (* result 10))\n          (reverse-digit\n            (quot num 10)\n            (+\n              (mod num 10)\n              (* result 10)\n            )\n          )\n        )\n      )\n\n      (palindromic-in-i-digit [low up]\n        (lazy-cat\n          (lazy-cat\n            (map\n              #(if\n                (< % 10)\n                %\n                (reverse-digit\n                  (quot % 10) %)\n                )\n                (range low up)\n              )\n              (drop-while\n                zero?\n                (map #(reverse-digit % %) (range low up))\n              )\n            )\n\n            (palindromic-in-i-digit\n              up\n              (* up 10)\n            )\n          )\n        )\n      ]\n\n      (filter #(>= % num)\n        (let\n          [len\n            (count (.toString num))\n            digit (quot len 2)\n            low (quot num (apply * (repeat digit 10N)))\n            up (apply * (repeat (count (.toString low)) 10N))\n          ]\n          (palindromic-in-i-digit low up)\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 150, "code": "(fn palindromic-num [num]\n  (letfn [(reverse-digit [num result]\n            (if\n              (zero? (quot num 10))\n              (+ (mod num 10) (* result 10))\n              (reverse-digit (quot num 10) (+ (mod num 10) (* result 10)))))\n          (palindromic-in-i-digit [low up]\n            (lazy-cat\n              (lazy-cat\n                (map #(if (< % 10) % (reverse-digit (quot % 10) %)) (range low up))\n                (drop-while\n                  zero?\n                  (map #(reverse-digit % %) (range low up))))\n              (palindromic-in-i-digit up (* up 10))))]\n    (filter #(>= % num) (let [len (count (.toString num))\n                              digit (quot len 2)\n                              low (quot num (apply * (repeat digit 10N)))\n                              up (apply * (repeat (count (.toString low)) 10N))]\n                          (palindromic-in-i-digit low up)))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 150, "code": ";; My solution is below. Don't konw why its timing out\n(fn palindrome [n] \n  (let [even-digits? #(even? (count %)) \n        left-middle #(if (even-digits? %) \n                       (subs % 0 (quot (count % ) 2) ) \n                       (subs % 0 (inc (quot (count % ) 2)))) \n        mirror (fn [[num dig]]\n                 (loop [a num r (if (= dig :even) num (quot num 10))]\n                   (if (= 0 r)\n                     a\n                     (recur (+ (* a 10) (mod r 10)) (quot r 10)))))\n        init #(let [s (left-middle %)] \n                (vector (Long/parseLong s) \n                        (if (even-digits? %) :even :odd) \n                        (long (Math/pow 10 (count s)))))\n        nextp (fn [[num even goal]] \n               (let [m (inc num)] \n                 (if (= m goal)\n                   (if (= even :even)\n                     [goal :odd (* 10 goal)]\n                     [(/ goal 10) :even goal])\n                   [m even goal] )))\n        i  (init (str n)) \n        palindromes (iterate nextp i) ] \n    (filter (partial <= n ) (map mirror palindromes))))\n\n;; finishes on my machine in 300ms... idk \n#_(fn pals [n]\n  (letfn [(n->start [n]\n            (loop [ret n mlt 10]\n              (if (< ret mlt) ret\n                (recur (/ (- ret (mod ret 10)) 10)\n                       (* mlt 10)))))\n          (inc-order [n]\n            (loop [ret 1 n n]\n              (if (== n 0) ret\n                (recur (* 10 ret) (quot n 10)))))\n          (even-pal [n]\n            (loop [ret n n n]\n              (if (== n 0) ret\n                (recur (+ (* 10 ret) (mod n 10)) (quot n 10)))))\n          (odd-pal [n]\n            (loop [ret n n (quot n 10)]\n              (if (== n 0) ret\n                (recur (+ (* 10 ret) (mod n 10)) (quot n 10)))))\n          (even-pals [n]\n            (for [x (range n (inc-order n))]\n              (even-pal x)))\n          (odd-pals [n]\n            (for [x (range n (inc-order n))]\n              (odd-pal x)))]\n    (let [start (n->start n)\n          digits (str n)]\n      (drop-while #(< % n)\n        (if (even? (count digits))\n          (apply concat\n                 (for [x (iterate inc-order start)]\n                   (concat (even-pals x) (odd-pals x))))\n          (apply concat\n                 (if (= start 0) (list 0) nil)\n                 (for [x (iterate inc-order (if (= start 0) 1 start))]\n                   (concat (odd-pals x) (even-pals x)))))))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 150, "code": "(let [first-n (fn [n]\n                  (if (zero? n)\n                    [0 10 false]\n                    (let [s (str n)\n                          c (count s)\n                          even (even? c)\n                          left-digits (if even (/ c 2) (inc (/ c 2)))\n                          left-half (Long. (subs s 0 left-digits))\n                          lim (Long. (apply str \"1\" (repeat left-digits \"0\")))]\n                      [left-half lim even])))\n        next-n (fn [[n lim even]]\n                 (let [ni (inc n)]\n                   (if (= lim ni)\n                     (if even\n                       [ni (* 10 lim) (not even)]\n                       [(/ ni 10) lim (not even)])\n                     [ni lim even])))\n        make-palin (fn [[n _ even]]\n                     (let [s (str n)\n                           r (if even\n                               (apply str (reverse s))\n                               (apply str (reverse (butlast s))))]\n                       (Long. (apply str s r))))]\n      (fn [n] (drop-while #(< % n) (map make-palin (iterate next-n (first-n n))))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 150, "code": "(fn palindromic-numbers\n  [min]\n  (letfn [(all-nine [n] (apply = (cons \\9 (distinct (str n)))))\n          (oddGen\n           [n]\n           (cons\n             (concat (str n) (reverse (butlast (str n))))\n             (lazy-seq\n               (if (all-nine n)\n                 (evenGen (quot (inc n) 10))\n                 (oddGen (inc n))))))\n         (evenGen\n           [n]\n           (cons\n             (concat (str n) (reverse (str n)))\n             (lazy-seq\n               (if (all-nine n)\n                 (oddGen (inc n))\n                 (evenGen (inc n))))))]\n    (drop-while\n      #(< % min)\n      (map\n        #(read-string (apply str %))\n        (let [minstr (str min)\n              len (count minstr)\n              half-len (if (odd? len) (inc (quot len 2)) (quot len 2))\n              half-num (read-string (apply str (take half-len minstr)))]\n          (if (odd? len)\n            (oddGen half-num)\n            (evenGen half-num)))))))", "user": "576df252e4b0979f8965156f"}, {"problem": 150, "code": "(let [palindromic-with-digits\n      (fn \n        [n near]\n        (let [power (fn [x n] (loop [v 1 c n] (if (= c 0) v (recur (* v x) (- c 1)))))]\n          (let [n-digs (fn [n near] (let [start (if (nil? near)\n                                                    (power 10 (- n 1))\n                                                    near)\n                                          end   (power 10 n)]\n                                         (range start end)))\n                make-even-pal (fn [n]\n                                (Long. (clojure.string/join (concat\n                                                                (str n) (reverse (str n))))))\n                make-odd-pal  (fn [n m] \n                                (Long. (clojure.string/join (concat\n                                                                (str n) (str m) (reverse (str n))))))\n                make-odd-pals (fn [n] (map #(make-odd-pal n %) (range 10)))]\n            (if (= n 1)\n              (range 10)\n              (if (even? n) \n                (let [n_2 (/ n 2)]\n                  (map make-even-pal (n-digs n_2 near)))\n                (let [n_2 (/ (- n 1) 2)]\n                  (flatten (map make-odd-pals (n-digs n_2 near)))))))))]\n  (let [palindromic-from-digits\n        (fn palindromic-from-digits\n          ([n]\n           (concat (palindromic-with-digits n nil)\n                   (lazy-seq (palindromic-from-digits (+ n 1)))))\n          ([n near]\n           (concat (palindromic-with-digits n near)\n                   (lazy-seq (palindromic-from-digits (+ n 1))))))]\n    (fn palindromic-not-less-than\n      [n]\n      (let [digs (count (str n))]\n        (let [near (if (even? digs)\n                       (int (/ n (Math/pow 10 (/ digs 2))))\n                       (int (/ n (Math/pow 10 (/ (+ digs 1) 2)))))]\n          (do (println digs near)\n              (filter #(>= % n) (palindromic-from-digits digs near))))))))", "user": "58152157e4b0f478707a0631"}, {"problem": 150, "code": "(fn palindrome-numbers\n  [n]\n  (letfn [(num-digits [n] (count (str n)))\n          (is-pdrome? [n] (= (str n) (apply str (reverse (str n)))))\n          (str->int   [s] (read-string s))\n          (mirror-num [n even]\n                      (let [reversed (reverse (str n))]\n                        (str->int (str n (apply str (if even reversed (drop 1 reversed)))))))\n          (first-half [n] (quot n (apply * (repeat (quot (num-digits n) 2) 10))))\n          (get-next-pdrome [n]\n                           (if (is-pdrome? n)\n                             n\n                             (let [half (first-half n)\n                                   even-num-of-digits (even? (num-digits n))\n                                   candidate (mirror-num half even-num-of-digits)]\n                               (if (> candidate n)\n                                 candidate\n                                 (mirror-num (inc half) even-num-of-digits)))))\n          (palindromes [n]\n                       (lazy-seq\n                         (let [next-pdrome (get-next-pdrome n)]\n                           (cons next-pdrome (palindromes (inc next-pdrome))))))]\n    (palindromes n)))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 150, "code": "(fn palnums [nbgn]\n (letfn [\n  (dgtz [num] \n   (loop [acc (list) work num]\n    (if (zero? work) \n     (if (empty? acc) \n      [0] \n      (vec acc)) \n     (let [lst (rem work 10)\n           rst (quot work 10)\n        newacc (cons lst acc)]\n      (recur newacc rst))) ))\n\n   (numz [ds]  \n     (loop [acc 0 work ds]\n      (if (empty? work)\n       acc\n       (recur (+ (* 10 acc) (first work)) (rest work) ))))\n\n   (palnumz [[v0 v1 v2]] \n    (numz (-> v0 \n              (into ,, v1)\n              (into ,, v2))))\n  \n   (halfsplit [vd] \n    (let [ln (count vd)\n          hln (quot ln 2)\n      mid (if (even? ln)\n           [] (vector (first (drop hln vd))))\n      bgns (vec (take hln vd))\n      ends (vec (drop (- ln hln) vd))]\n      [bgns mid ends])) \n\n  (vinc [vn] (dgtz (inc (numz vn))))\n  (vrevrs [coll] (vec (reverse coll)))\n\n  (advn [[vb vm vl]]\n   (let [vb-len (count vb)\n      vm-len (count vm)\n      nxbmcom (dgtz (inc (numz (into vb vm))))\n      nxbmlen (count nxbmcom)\n      nxbmcut (pop nxbmcom)\n      nxbmlastv [(peek nxbmcom)]\n      [xvb xvm xvl]\n       (if (= nxbmlen (+ vb-len vm-len))\n        (if (zero? vm-len)\n         [nxbmcom [] (vrevrs nxbmcom)] \n         [nxbmcut nxbmlastv (vrevrs nxbmcut)])\n\n        (if (zero? vm-len) \n         [nxbmcut nxbmlastv (vrevrs nxbmcut)]\n         \n         [nxbmcut [] (vrevrs nxbmcut)] ))]\n   [xvb xvm xvl]))\n\n  (nearestpal [vb vm ve]  \n   (if (= ve (vrevrs vb)) \n    [vb vm ve]\n    (if (< (numz ve) (numz (vrevrs vb))) \n      [vb vm (vrevrs vb)]\n      (advn [vb vm ve]))))\n  ]\n\n  (let [vbgn (dgtz nbgn)\n        [vlt mid vrt] (halfsplit vbgn) \n        nearp (nearestpal vlt mid vrt)]\n\n   (letfn [(pal-zq [vpal]\n    (lazy-seq \n     (cons (palnumz vpal)\n           (pal-zq (advn vpal))) ))]   \n\n     (pal-zq nearp))\n)))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 150, "code": "(fn next-palyndromes [n]\n  (letfn [(n-to-dig [n] (vec (map (comp read-string str) (seq (str n)))))\n          (dig-to-n [d] (read-string (apply str (map str d))))\n          (middle [s] (quot (count s) 2))\n          (next-paly [n]\n            (loop [dig (n-to-dig n)\n                   pos (middle dig)]\n              (let [len (count dig)\n                    mid (middle dig)\n                    d1 (nth dig pos)\n                    d2 (nth dig (- len pos 1)) \n                    half (subvec dig 0 mid)\n                    hm (concat half (when (odd? len) [(nth dig mid)]))\n                    nn (n-to-dig (inc (dig-to-n hm)))\n                    nd (vec (concat nn (reverse (if (odd? len) (butlast nn) nn))))]\n                (if (= dig (reverse dig))\n                  (dig-to-n dig)\n                  (condp = (compare d1 d2) \n                    0  (recur dig (inc pos))\n                    -1 (dig-to-n (concat hm (reverse half)))\n                    1  (dig-to-n nd))))))]\n    (let [np (next-paly n)]\n      (cons np (lazy-seq (next-palyndromes (inc np)))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 150, "code": "(fn L [min]\n  (let [surround (fn [kern out]\n                   (map\n                     (fn [kern-elem] (concat out kern-elem out))\n                     kern))\n        L1 (map vector (take 10 (range)))\n        L2 (map\n             (partial apply concat)\n             (map\n               (partial repeat 2)\n               L1))\n        dropper (fn dropper [n s]\n                  (if (> n 0)\n                    (drop n s)\n                    s))\n        pals (memoize (fn pals\n                        ([width starts]\n                         (let [start (get starts width 0)]\n                           (cond\n                             (< width 1) nil\n                             (= width 1) (dropper start L1)\n                             (= width 2) (dropper start L2)\n                             (> width 2) (do\n                                           (apply\n                                             concat\n                                             (surround (pals (- width 2) starts) (first (dropper start L1)))\n                                             (map\n                                               (partial surround (pals (- width 2) {})) \n                                               (rest (dropper start L1))))))))\n                        ([width]\n                         (pals width {}))))\n        exp (fn exp [x n]\n              (if (> n 0)\n                (reduce * (repeat n x))\n                1))\n        sum (fn sum [x] (reduce + x))\n        start-positions (fn [n]\n                          (let [nums (->> n (str) (.toCharArray) (seq) (map str) (map bigint))\n                                len (count nums)\n                                firsts (take (/ len 2) nums)]\n                            (if (<= len 2)\n                              {}\n                              (into\n                                {}\n                                (let [r (map-indexed\n                                          (fn [idx val]\n                                            (vector\n                                              (- len (* 2 idx))\n                                              val))\n                                          firsts)]\n                                  r)))))\n        to-number (fn to-number [numvec]\n                    (sum (map-indexed\n                           (fn [idx num]\n                             (* num (exp 10 idx)))\n                           (reverse numvec))))\n        zero-filter (fn zero-filter [numvec]\n                      (do\n                        ;(println (str \"Zero filter over: \" (vector numvec)))\n                        (not\n                          (and (> (count numvec) 1)\n                               (= (first numvec) 0)))))\n        result (apply\n                 concat\n                 (map\n                   (partial apply pals)\n                   (partition\n                     2\n                     (apply concat\n                       [(count (str min)) (start-positions min)]\n                       (map\n                         (fn [x] (vector x nil))\n                         (iterate inc\n                           (+ 1 (count (str min)))))))))]\n    (->> (filter zero-filter result)\n         (map to-number)\n         (drop-while #(< %1 min)))))", "user": "5779556de4b0979f8965166e"}, {"problem": 150, "code": "(fn next-palindrome [n]\n  (lazy-seq\n    (letfn [(mod-10 [x]\n              (mod x 10))\n            (pows-of-10 []\n              (iterate (partial * 10) 1))\n            (ceil [x]\n              (let [int-x (int x)]\n                (if (== (double x)\n                        int-x)\n                  int-x\n                  (inc int-x))))\n            (digits [x]\n              (reverse\n                (map\n                  mod-10\n                  (take-while\n                    (complement zero?)\n                    (map (partial quot x)\n                         (pows-of-10))))))\n            (palindrome? [x]\n              (= x (seq-to-int (reverse (digits x)))))\n            (inc-all-9 [x]\n              (concat [1] (repeat (dec (count x)) 0) [1]))\n            (seq-to-int [x]\n              (apply + (map * (reverse x) (take (count x) (pows-of-10)))))\n            (mirror-with-inc? [xs ys]\n              (loop [[head & lefts] xs\n                     [tail & rights] ys]\n                (cond\n                  (or (nil? head)\n                      (nil? tail)\n                      (< head tail))\n                  true\n                  (> head tail)\n                  false\n                  :else (recur lefts rights))))\n            (mirror-left [xs ys]\n              (let [digit-count (count xs)\n                    half (int (ceil (/ digit-count 2)))\n                    [left _] (split-at half xs)\n                    new-left (if ys\n                               (digits (inc (seq-to-int left)))\n                               left)\n                    new-right (reverse new-left)]\n                (if (odd? digit-count)\n                  (concat new-left (rest new-right))\n                  (concat new-left new-right))))\n            (next-p []\n              (if (palindrome? n)\n                n\n                (let [digits-n (digits n)\n                      digit-count (count digits-n)]\n                  (seq-to-int\n                    (if (every? (partial = 9) digits-n)\n                      (inc-all-9 digits-n)\n                      (let [half (int (ceil (/ digit-count 2)))\n                            [left right] (split-at half digits-n)\n                            left (reverse (if (odd? digit-count)\n                                            (butlast left)\n                                            left))\n                            mirror-with-inc (mirror-with-inc? left right)]\n                        (mirror-left digits-n mirror-with-inc)))))))]\n      (let [p (next-p)]\n        (cons p (next-palindrome (inc p)))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 150, "code": ";; NOTE: immo's was awesome\n(fn palindromes-higher-than [higher-than]\n  (letfn [(slow-way [n]\n            (letfn [(palindromic? [ns] (= (str ns) (clojure.string/reverse (str ns))))]\n              (filter palindromic? (iterate inc n))))\n\n          (mirror-odd [n]\n            (let [ns (str n)\n                  c (/ (count ns) 2)]\n              (apply str ns (rest (clojure.string/reverse ns)))))\n\n          (mirror-even [n]\n            (let [ns (str n)\n                  c (/ (count ns) 2)]\n              (str ns (clojure.string/reverse ns))))\n\n          (next-palindrome [n]\n            (let [ns (str n)\n                  half-list (take (/ (count ns) 2) ns)\n                  half-str (apply str half-list)\n                  half-num (read-string half-str)\n                  all-nines-tricky-case (= '(\\9) (distinct half-str))]\n\n              (if all-nines-tricky-case\n                (last (take 2 (slow-way n)))\n                (read-string\n                 (if (odd? (count ns))\n                   (mirror-odd (inc half-num))\n                   (mirror-even (inc half-num)))))))\n\n          (palindromes\n            ([] (palindromes 0))\n            ([b] (palindromes b (first (slow-way b))))\n            ([b n] (lazy-seq (cons n (palindromes b (next-palindrome n))))))]\n    (drop-while #(< % higher-than) (palindromes higher-than))))", "user": "56069006e4b08b23635d3174"}, {"problem": 150, "code": "(fn [n]\n  (let [next-half (fn [[i d]]\n                    (if (every? #{\\9} (str i))\n                      (if (even? d) \n                        [(inc i) (inc d)]\n                        [(quot (inc i) 10) (inc d)])\n                      [(inc i) d]))\n        half->pal (fn [[i d]]\n                    (-> (subs (str i) 0 (quot d 2))\n                        clojure.string/reverse\n                        (#(str i %))\n                        bigint))\n        half-n (let [s (str n)]\n                  [(bigint\n                     (subs s 0 (- (count s) (quot (count s) 2))))\n                   (count s)])\n        starting-half (if (< (half->pal half-n) n)\n                        (next-half half-n)\n                        half-n)\n        pal (fn pal [half] \n              (lazy-seq (cons (half->pal half)\n                              (pal (next-half half)))))]\n    (pal starting-half)))", "user": "58247423e4b051871117bec5"}, {"problem": 150, "code": "(fn [x]\n    (letfn [(n2d [n]\n              (loop [n n ret '()]\n                (if (zero? n) ret\n                    (recur (quot n 10) (conj ret (rem n 10))))))\n\n            (d2n [xs]\n              (apply + (map * (reverse xs) (iterate (partial * 10) 1))))\n\n            (count-up [x]\n              (+ x (nth (iterate (partial * 10) 1) (/ (count (n2d x)) 2))))\n\n            (pnumber [x]\n              (let [s (n2d x)\n                    n (count s)\n                    [c _] (split-at (/ n 2) s)]\n                (d2n\n                 (cond\n                   (= s (reverse s)) s\n                   (odd? n) (concat c (rest (reverse c)))\n                   (even? n) (concat c (reverse c))))))\n\n            (pnumber-seq [x]\n              (lazy-seq\n               (cons (pnumber x) (pnumber-seq (count-up x)))))]\n      (drop-while #(< % x) (pnumber-seq x))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 150, "code": "(fn genPalindromeLazySeq\n  ([p] (genPalindromeLazySeq p (lazy-seq [p]) ))\n  ([p s] (letfn [\n                 (convertToIntSeq [x] (map #(read-string (str %)) (seq (str x))))\n                 (update [m k f] (assoc m k (f (get m k))))\n                 (convertIntSeqToNum [s]  (read-string (apply str s)))\n                 (nextPalFromAny [i] (if (isPalindrome? i) i  (let [s (convertToIntSeq i)\n                                                                   start (take (int (/ (count s) 2)) s)\n                                                                   middle (if (odd? (count s)) [0] [])\n                                                                   end (reverse start)\n                                                                   finish (concat start middle end)\n                                                                   num (convertIntSeqToNum finish) ] (loop [t num] (if (> t i) t (recur (nextPalindrome t)))))))\n\n                 (nextPalindrome [x] (if (< x 11) (inc x)\n\n                                                  (let [s (into [] (convertToIntSeq x))\n                                                                                        i (int (/ (count s) 2))]\n                                                    (if (every? #(= 9 %) s)\n                                                      (+ x 2)\n                                                      (convertIntSeqToNum\n                                                        (fixOverflow\n                                                          (cond\n                                                            (odd? (count s)) (update s i inc)\n                                                            :else (update (update s i inc) (dec i) inc)\n                                                            )\n                                                          )\n                                                        ))\n                                                    )\n                                                 ))\n                 (isPalindrome? [x] (let [s (convertToIntSeq x)]\n                                           (= s (reverse s))))\n                 (fixOverflow [x] (if (some #(> % 9) x) (let [adjusted (if (= 10 (first x)) (into [] (cons 0 (conj x 0))) x)\n                                                                   overs (filter #(< 9 (second %)) (map-indexed vector adjusted))\n                                                                   zeroes (map #(assoc % 1 0 ) overs)\n                                                                   zeroed (apply assoc adjusted (flatten zeroes))\n                                                                   left (dec (first (reduce #(if(< (first %1) (first %2)) %1 %2) zeroes)))\n                                                                   right (inc (first (reduce #(if(> (first %1) (first %2)) %1 %2) zeroes)))]\n                                                               (fixOverflow (update (update zeroed left inc) right inc))) x))\n                 ] (let [add (nextPalFromAny p)] (cons add (lazy-seq (genPalindromeLazySeq (nextPalindrome add) s))\n                                                             )\n                                              )\n                                        )\n    )\n  )", "user": "56427910e4b08d4f616f5f19"}, {"problem": 150, "code": "; this code is a huge hack that does not deserve to exist\n(letfn [\n        (get-power-of-10 [power] (apply * (replicate power 10)))\n        (palindrone-seed [n] (let [\n                                   digits (count (str n))\n                                   power-of-10 (get-power-of-10 (quot digits 2))]\n                               [digits (quot n power-of-10)\n                                (dec (* (if (odd? digits) 10 1) power-of-10))]))\n        (next-palindrome [[digits n m]] (if (= n m)\n                                          (let\n                                            [power-of-10 (get-power-of-10 (quot digits 2))]\n                                            [(inc digits) power-of-10 (dec (* 10 power-of-10))])\n                                          [digits (inc n) m]))\n        (seed-to-num [[digits n m]] (BigInteger. (str n (subs\n                                                         (clojure.string/reverse (str n))\n                                                         (rem digits 2)))))]\n  (fn [n] (let [l (map seed-to-num (iterate next-palindrome (palindrone-seed n)))]\n            (if (< (first l) n) (rest l) l))))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 150, "code": "(fn palindromic-seq [n] \n  (letfn [(num-to-seq [x]\n                   (loop [res (list)\n                          k x]\n                     (if (< k 10)\n                       (conj res k)\n                       (recur (conj res (rem k 10)) (quot k 10)))))\n          (seq-to-num [coll]\n                      (reduce #(+ (* %1 10) %2) coll))\n          (is-palindromic? [x]\n                           (let [n-seq (num-to-seq x)\n                                 r-n-seq (reverse n-seq)]\n                             (= x (seq-to-num r-n-seq))))\n          (mirror-odd [x]\n                      (let [n-seq (num-to-seq x)]\n                        (seq-to-num (concat n-seq (-> n-seq\n                                                      reverse\n                                                      rest)))))\n          (mirror-even [x]\n                       (let [n-seq (num-to-seq x)]\n                         (seq-to-num (concat n-seq (reverse n-seq)))))\n          (next-palindromic [x]\n                            (let [n-seq (num-to-seq x)\n                                  len (count n-seq)]\n                            (if \n                              (odd? len) \n                              (let [k (seq-to-num (take (/ (inc len) 2) n-seq))\n                                    s1 (mirror-odd k)\n                                    s2 (mirror-odd (inc k))]\n                                (if (<= x s1) s1 s2))\n                              (let [k (seq-to-num (take (/ len 2) n-seq))\n                                    s1 (mirror-even k)\n                                    s2 (mirror-even (inc k))]\n                                (if (<= x s1) s1 s2)))))]\n                             \n  (let [f-p (next-palindromic n)]\n    (lazy-seq\n     (cons f-p\n           (palindromic-seq (inc f-p)))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 150, "code": "(fn [start]\n  (letfn [(pow [x y]\n            (apply * (repeat y (bigint x))))\n          (center-digit [n]\n            (quot (inc n) 2))\n          (left-half [x]\n            (-> (str x)\n                (subs 0 (center-digit (count (str x))))\n                bigint))\n          (mirror [n x]\n            (bigint (apply str x (->> (str x)\n                                      reverse\n                                      (drop (mod n 2))))))\n          (n-digit-pals\n            ([n]\n             (if (= n 1)\n               (n-digit-pals n 0)\n               (n-digit-pals n (pow 10 (dec n)))))\n            ([n start]\n             (->> (range (left-half start) (pow 10 (center-digit n)))\n                  (map #(mirror n %))\n                  (drop-while #(< % start)))))]\n    (let [n (count (str start))]\n      (apply concat\n             (n-digit-pals n start)\n             (->> (range)\n                  (drop (inc n))\n                  (map n-digit-pals))))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 150, "code": "(fn palindrome-number\n  ([] (palindrome-number 0 false))\n  ([n]\n   (let [number-to-coll (fn [number] (map #(- (int %) 48) (into [] (str number)))) \n         coll-to-number (fn [coll]  (reduce #(+ (* %1 10) %2) coll))\n         [front back] (split-at (int (Math/ceil (/ (count (number-to-coll n)) 2)))\n                                (number-to-coll n))\n         pal-root (coll-to-number front)\n         pal-seq (palindrome-number pal-root (= (count front) (count back)))]\n     (if (>= (first pal-seq) n)\n       pal-seq\n       (rest pal-seq))))\n         \n  ([pal-root mirror?]\n   (let [number-to-coll (fn [number] (map #(- (int %) 48) (into [] (str number)))) \n         coll-to-number (fn [coll]  (reduce #(+ (* %1 10) %2) coll))\n         pal-from-root (fn [pal-root] (let [digits (number-to-coll pal-root)]\n                                        (coll-to-number \n                                          (concat digits\n                                                  (if mirror?\n                                                    (reverse digits)\n                                                    (rest (reverse digits)))))))] \n    (if (every? #(= % 9) (number-to-coll pal-root))\n      (lazy-seq \n        (cons (pal-from-root pal-root)\n          (palindrome-number \n            (if mirror? (inc pal-root) (/ (inc pal-root) 10))\n            (not mirror?))))\n      (lazy-seq \n        (cons (pal-from-root pal-root)\n              (palindrome-number (inc pal-root) mirror?)))))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 150, "code": "#(let [[s & b :as a]              \n         ((fn t [n m]  \n       (if (< n (* m 10))\n        (lazy-seq\n         (cons\n          (+ \n           (* n m) \n           (rem (Integer/parseInt (apply str (reverse (str n)))) m))\n          (t (+ 1 n) m)))\n        (t (quot n 10) \n         (* m 10)))) % 1)]\n    (if (>= s %) \n     a b))", "user": "55597b84e4b0deb715856e36"}, {"problem": 150, "code": "(fn c150_2\n  [num]\n  (let [s (str num)]\n    (if (= (seq s) (reverse s))\n      (let [incr  (if (= s (clojure.string/join (repeat (count s) \"9\")))\n                    1\n                    (let [nines (loop [a (subs s (/ (count s) 2))\n                                       n 0]\n                                  (if (and (not-empty a) (= \\9 (first a)))\n                                    (recur (next a) (inc n))\n                                    n))]\n                      (if (= (mod (count s) 2) 0)                        \n                        (Integer/parseInt\n                         (str \"11\" (clojure.string/join\n                                    (repeat (- (dec (int (/ (count s) 2))) nines) \"0\"))))\n                        (Integer/parseInt\n                         (str \"1\" (clojure.string/join (repeat (- (int (/ (count s) 2)) nines) \"0\")))))))]\n        (cons num (lazy-seq (c150_2 (+ num incr)))))\n      (lazy-seq (c150_2 (inc num))))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 150, "code": ";; Representation as [(list of chars or string) (uneven or even mirror)]\n;; Uses intermediate string representation.\n(fn [init]\n  (letfn [(as-number [col]\n            (bigint (apply str col)))\n          (pali-seq [left even]\n            (concat left\n                    (reverse (if even\n                               left\n                               (butlast left)))))\n          (xor [a b]\n            (and (or a b)\n                 (or (not a) (not b))))\n          (find-next [left even]\n            (let [next (str (inc (as-number left)))\n                  up?  (< (count left) (count next))\n                  next (if (and up? (not even))\n                         (butlast next)\n                         next)\n                  even (xor even up?)]\n              [next even]))\n          (pali [init]\n            (let [inits (str init)\n                  left (take (quot (inc (count inits)) 2)\n                             inits)\n                  even (even? (count inits))]\n              (if (<= init (as-number (pali-seq left even)))\n                [left even]\n                (find-next left even))))]\n    (map (comp as-number #(apply pali-seq %))\n         (iterate #(apply find-next %)\n                  (pali init)))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 150, "code": "(fn f ([n]\n               (let [digits   (fn [n] (map #(- (int %) (int \\0)) (str n)))\n                     undigits (fn [d] (reduce (fn [v n] (+ (* 10 v) n)) d))\n                     p?       (fn [x] (let [s (str x)] (= (seq s) (reverse s))))\n                     d        (digits n)\n                     c        (count d)\n                     h        (take (/ c 2) d)\n                     x        [1 2 10 11 100 110 1000 1100 10000 11000 100000 110000\n                               1000000 1100000 10000000 11000000]\n                     u        (undigits (if (even? c)\n                                          (concat h (reverse h))\n                                          (concat h (drop 1 (reverse h)))))\n                     m        (if (>= u n)\n                                u\n                                (first (filter p? (map #(+ u %) x))))]\n               (lazy-seq\n                (cons\n                 m\n                 (f (inc m)))))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 150, "code": "(fn [n] (drop-while #(< % n)\n\t(let [\n\t\ttoSeq (fn [n] (re-seq #\"\\d\" (str n)))\n\t\ts (toSeq n)\n\t\tc (count s)\n\t\tpow (fn [x n] (reduce * (repeat n x)))\n\t\ta (quot n (pow 10 (quot c 2)))\n\t\tb (if (zero? a) 1 a)\n\t\tr (map #(apply range %) (partition 2 1 (cons b (drop-while #(< % b) (iterate #(* 10 %) 10)))))\n\t\tf (fn [h x] (let [sx (toSeq x) r (h (reverse sx))] (read-string (apply str (concat sx r)))))\n\t\tg (fn [r] (if (zero? (rem c 2)) \n\t\t\t\t\t(concat (map #(f identity %) r) (map #(f rest %) r))\n\t\t\t\t\t(concat (map #(f rest %) r) (map #(f identity %) r))\n\t\t\t\t\t))\n\t\t] (cons 0 (mapcat g r)))))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 150, "code": "(fn [start]\n  (let [n-p (fn[n]\n                          (let [int-to-digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n                                digits-to-int #(read-string (apply str %))\n                                is-even? #(= 0 (mod (count %) 2))\n                                get-left #(take (Math/ceil (/ (count %) 2)) %)\n                                mirror-even #(concat % (reverse %))\n                                mirror-odd #(concat % (rest (reverse %)))\n                                digits (int-to-digits n)\n                                mirror (if (is-even? digits) mirror-even mirror-odd)\n                                other-mirror (if (is-even? digits) mirror-odd mirror-even)\n                                left-digits (get-left digits)\n                                mirrored-digits (mirror left-digits)\n                                candidate (digits-to-int mirrored-digits)]\n                            (if (> candidate n) candidate\n                              (let [higher-num (inc (digits-to-int left-digits))\n                                    higher-digits (int-to-digits higher-num)\n                                    higher-candidate (digits-to-int (mirror higher-digits))]\n                                (if (= (count higher-digits) (count left-digits))\n                                  higher-candidate\n                                  (let [trunc (if (is-even? digits) higher-digits (butlast higher-digits))]\n                                    (digits-to-int (other-mirror trunc))))))))\n\n        f-p (if (= 0 start) 0 (n-p (dec start)))\n        ]\n    (iterate n-p f-p)))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 150, "code": "(fn lazy-pal [lower-bound]\n  (letfn [(reflect [k parity]\n                    (let [s (str k)\n                          n (count s)]\n                      (read-string (apply str (concat s (reverse (take (- n parity) s)))))))\n\n          (first-power-of-ten [n]\n            \"find the power of ten with same length as integer n\"\n            (read-string (apply str (cons \\1 (for [k (rest (str n))] \\0)))))\n\n          (pal-prefix [n]\n            \"return the first half of the string and parity of full string\"\n            (let [s (str n)\n                  len (count s)\n                  parity (rem len 2)]\n              [(read-string (apply str (take (quot (inc len) 2) s))) parity]))\n\n          (first-palindrome [n]\n            \"get the first palindrome >= n\"\n            (let [s (str n)\n                  len (count s)\n                  parity (rem len 2)]\n              (let [prefix (read-string (apply str (take (quot (inc len) 2) s)))]\n                \"Check 1 either side of naive palindrome\"\n                (some #(and (>= % n) %)\n                      (map #(reflect (+ prefix %) parity) [-1 0 1])))))\n\n          (ten-power [n odd-even]\n            (cond\n              (< (reflect (dec (* 10 n)) odd-even) lower-bound) []\n              (< (reflect n odd-even) lower-bound) (range (first (pal-prefix (first-palindrome lower-bound))) (* 10 n)) \n              true (range n (* 10 n))))\n\n          (palindromes [n] (concat\n                            (map #(reflect % 1) (ten-power n 1)) ;; odd length\n                            (map #(reflect % 0) (ten-power n 0))))] ;; even length\n\n    \"feed in powers of 10\"\n    (if (zero? lower-bound)\n      (cons 0 (lazy-pal 1))\n      (mapcat palindromes (iterate (partial * 10) 1)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 150, "code": "(letfn [\n  ;;=====\n  (digits [x]\n    (loop [digits [], remainder x]\n      (let [digit  (rem remainder 10)]\t\n        (if (<= remainder 0) (if (= x 0) [0] digits)\n          (recur (concat [digit] digits) (quot remainder 10) \n  )))))\n  ;;==============\n  (next-palindrome [n]\n  (let [\n    ndigits     (digits n)\n    oddity      (count ndigits)\n    len         (/ (if (odd? oddity) (inc oddity) oddity) 2)\n    deterdigits (take len ndigits)\n    determinant (read-string (clojure.string/join deterdigits))\n  ] (loop [det determinant]\n      (let [\n        revdeterm  (reverse (digits det))\n        paldigits  (concat (digits det) (if (odd? oddity) (rest revdeterm) revdeterm))\n        palnumber  (read-string (clojure.string/join paldigits))\n      ] (if (>= palnumber n)\n          palnumber\n          (recur (inc det)))))))\n  ;; ========\n  (palindromes [n]\n    (let [nextpal (next-palindrome n)]\n      (lazy-seq (cons nextpal (palindromes (inc nextpal))))))\n] (fn [n] (palindromes n)))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 150, "code": "(fn pnums [n]\n  (letfn [(nextp [n]\n            (let [s (str n)\n                  c (count s)\n                  q (quot c 2)\n                  r (rem c 2)\n                  p (+ q r)\n                  ls (subs s 0 p)\n                  ll (Long. ls)\n                  tl (Long. (subs s q))\n                  rl (Long. (clojure.string/reverse ls))\n                  ll (if (> tl rl) (inc ll) ll)\n                  rl (Long. (clojure.string/reverse (str ll)))\n                  ll (if (= r 0) ll (quot ll 10))\n                  k (long (Math/pow 10 p))]\n              (+ (* ll k) rl)))]\n    (let [n (nextp n)]\n      (lazy-seq (cons n (pnums (inc n)))))))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 150, "code": "(fn palindromic-numbers [n]\n  (letfn [(nextp [n]\n            (let [s (str n)\n                  len (count s)\n                  atoi #(Long. %)\n                  half (subs s 0 (Math/ceil (/ len 2)))\n                  half-to-palindrome (fn [h] (atoi (str h (subs (clojure.string/reverse h) (if (even? len) 0 1)))))\n                  cur-palindrome (half-to-palindrome half)\n                  next-palindrome (half-to-palindrome (str (inc (atoi half))))]\n              (if (>= cur-palindrome n) cur-palindrome next-palindrome)))]\n    (iterate (comp nextp inc) (nextp n))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 150, "code": "(fn palindrom [x]\n  (let [to-num #(->> % (apply str) read-string)\n        xs (str x)\n        [q m] ((juxt quot mod) (count xs) 2)\n        [left [pivot]] (split-at q xs)\n        left-num (to-num (concat left (if (= 1 m) [pivot])))\n        try-num (->> left reverse (cons left-num) to-num)]\n    (if (< try-num x)\n      (recur (to-num (cons (inc left-num) (repeat q 0))))\n      (->> try-num inc palindrom lazy-seq (cons try-num)))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 150, "code": "(letfn [(n->d [n]\n          (loop [r (quot n 10) res (list (rem n 10))]\n            (if (zero? r)\n              (vec res)\n              (recur (quot r 10) (conj res (rem r 10))))))\n        (d->n [d] (reduce #(+ (* 10 %1) %2) d))\n        (pal-up [c op digs]\n          (let [inc-digs (->> digs d->n op n->d)\n                post-digs (reverse inc-digs)]\n            (d->n\n              (into\n                (if (= (count digs) (count inc-digs))\n                  inc-digs\n                  (vec (butlast inc-digs)))\n                (if (even? c)\n                  post-digs\n                  (rest post-digs))))))\n        (pal? [n] (let [digs (n->d n)] (= digs (reverse digs))))\n        (pal [n]\n          (let [d (n->d n)\n                c (count d)\n                i (/ (if (even? c) c (inc c)) 2)\n                pre-digs (take i d)\n                rem-digs (take i (reverse d))]\n            (if (or (= pre-digs rem-digs)\n                    (< (d->n pre-digs) (d->n rem-digs)))\n              (pal-up c inc pre-digs)\n              (pal-up c identity pre-digs))))]\n  #(iterate pal (if (pal? %) % (pal %))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 150, "code": "(fn palindromic-numbers [n]\n  (letfn [(long [n] (Long. n))\n          (next-palindrome [num]\n            (let [num-string (str num)\n                  length (count num-string)\n                  left-num-string (subs num-string 0 (Math/ceil (/ length 2)))\n                  next-left-num-string (str (inc (long left-num-string)))\n                  [a b] (map (fn [s] \n                               (long\n                                (str s (subs (clojure.string/reverse s) (if (even? length) 0 1)))))\n                             [left-num-string next-left-num-string])]\n              (if (>= a num) a b)))]\n    (iterate (comp next-palindrome inc) (next-palindrome n))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 150, "code": "(fn [num]\n  (letfn [(reverse-digit [num result]\n            (if (zero? (quot num 10))\n              (+ (mod num 10) (* result 10))\n              (reverse-digit (quot num 10) (+ (mod num 10) (* result 10)))))\n          (palindromic-in-i-digit [low up]\n            (lazy-cat\n              (lazy-cat\n                (map #(if (< % 10) % (reverse-digit (quot % 10) %)) (range low up))\n                (drop-while\n                  zero?\n                  (map #(reverse-digit % %) (range low up))))\n              (palindromic-in-i-digit up (* up 10))))]\n    (filter #(>= % num) (let [len (count (.toString num))\n                              digit (quot len 2)\n                              low (quot num (apply * (repeat digit 10N)))\n                              up (apply * (repeat (count (.toString low)) 10N))]\n                          (palindromic-in-i-digit low up)))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 150, "code": "(fn palindromic-numbers [x]\n   \n      (letfn [(next-palindrome [n]\n        (cond\n          (< n 9) (inc n)\n          (or (= 9 n) (= 10 n)) 11\n          (odd? (count (str n)))\n            (let [front-half-string (subs (str n) 0 (inc (/ (count (str n)) 2)))\n                  reversed-front-half (Integer. (apply str (reverse front-half-string)))\n                  back-half (Integer. (subs (str n) (/ (count (str n)) 2)))\n                  rfh reversed-front-half\n                  bh back-half]\n              (cond\n                (= rfh (inc bh)) (inc n)\n                (< rfh (inc bh)) (Integer.\n                                   (str \n                                     (inc (Integer. front-half-string))\n                                     (apply str (reverse (subs (str (inc (Integer. front-half-string))) 0 (dec (count front-half-string)))))))\n                (> rfh (inc bh)) (Integer. \n                                   (str \n                                     front-half-string\n                                     (apply str (reverse (subs front-half-string 0 (dec (count front-half-string)))))))))\n          (even? (count (str n)))\n            (let [front-half-string (subs (str n) 0 (/ (count (str n)) 2))\n                  reversed-front-half (Integer. (apply str (reverse front-half-string)))\n                  back-half (Integer. (subs (str n) (/ (count (str n)) 2)))\n                  rfh reversed-front-half\n                  bh back-half]\n              (cond\n                (= rfh (inc bh)) (inc n)\n                (< rfh (inc bh)) (if (= (count (str (inc n))) (count (str n)))\n                                   (Integer. \n                                     (str \n                                       (inc (Integer. front-half-string))\n                                       (apply str (reverse (str (inc (Integer. front-half-string)))))))\n                                   (+ n 2))\n                (> rfh (inc bh)) (Integer.\n                                   (str\n                                     (Integer. front-half-string)\n                                     (apply str (reverse (str (Integer. front-half-string))))))))))]\n      \n        (if (= (str x) (apply str (reverse (str x))))\n          (iterate next-palindrome x)\n          (rest (iterate next-palindrome x)))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 150, "code": "(letfn [(int->digits\n          ([m]\n           (int->digits m '()))\n          ([m dig]\n           (if (< m 10)\n             (into [m] dig)\n             (recur (quot m 10) (cons (rem m 10) dig)))))\n\n        (digits->int\n          ([dig]\n           (reduce #(+ (* 10 %1) %2) 0 dig)))\n\n        (palin-split\n          [coll]\n          (split-at (/ (count coll) 2) coll))\n\n        (seq-palindrome?\n          [xs]\n          (= xs (reverse xs)))\n\n        (palindrome?\n          [n]\n          (seq-palindrome? (int->digits n)))\n\n        (mirror-digits\n          [xs n]\n          (concat xs (reverse (take n xs))))\n\n        (mirror-int\n          ([n]\n           (mirror-int n identity))\n          ([n xf]\n           (let [[base discard] (palin-split (int->digits n))\n                 n-discarded (count discard)]\n             (digits->int (mirror-digits (xf base) n-discarded)))))\n\n        (inc-digits\n          [dig]\n          (int->digits (inc (digits->int dig))))\n\n        (palindrome-after\n          [n]\n          (let [lower-bound (inc n)\n                wanted #(and (or (< % 10)\n                                 (palindrome? %))\n                             (> % n))]\n            (first (filter wanted\n                           [lower-bound\n                            (mirror-int lower-bound)\n                            (mirror-int lower-bound inc-digits)]))))\n\n        (palindrome-seq\n          [n]\n          (rest (iterate palindrome-after (dec n))))]\n\n  #(palindrome-seq %))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 150, "code": "(fn palindromic-num [num]\n  (letfn [(reverse-digit [num result]\n            (if\n                (zero? (quot num 10))\n                (+ (mod num 10) (* result 10))\n                (reverse-digit (quot num 10) (+ (mod num 10) (* result 10)))))\n\n          (palindromic-in-i-digit [low up]\n            (lazy-cat\n             (lazy-cat\n              (map #(if (< % 10) % (reverse-digit (quot % 10) %)) (range low up))\n              (drop-while\n               zero?\n               (map #(reverse-digit % %) (range low up))))\n             (palindromic-in-i-digit up (* up 10))))]\n    \n    (filter #(>= % num)\n\n            (let [len (count (.toString num))\n                  digit (quot len 2)\n                  low (quot num (apply * (repeat digit 10N)))\n                  up (apply * (repeat (count (.toString low)) 10N))]\n              (palindromic-in-i-digit low up)))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 150, "code": "(fn pn [n]\n           (let [sn (str n)\n                 csn (count sn)]\n             (if (= csn 1)\n               (cons n (lazy-seq (pn (inc n))))\n               (let [fh (if (odd? csn)\n                          (inc (quot csn 2))\n                          (quot csn 2))\n                     sh (quot csn 2)\n                     hn (read-string (apply str (take fh sn)))\n                     nn (read-string (apply str (cons \\1 (repeat (+ fh sh) \\0))))\n                     in (if (= n (/ nn 10)) (/ nn 10) (dec n))]\n                 (lazy-cat (take-while\n                             #(< % nn)\n                             (drop-while\n                               #(< % n)\n                               (next (iterate\n                                       #(read-string (let [nsn (str %)\n                                                           nfhsn (read-string (apply str (take fh nsn)))\n                                                           nfh (if (= (take sh nsn) (reverse (drop fh nsn)))\n                                                                 (inc nfhsn)\n                                                                 nfhsn)\n                                                           nfhn (str nfh)\n                                                           nshn (reverse (take sh nfhn))]\n                                                       (apply str (concat nfhn nshn))))\n                                       in))))\n                           (pn nn))))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 150, "code": "(fn f [n]\n      (let [sn (str n) c (count sn) a (take (/ c 2) sn)]\n        (if (= sn (apply str (reverse sn)))\n          (lazy-cat [n] (f (inc n)))\n          (let [m (bigint (apply str (concat a (drop (/ c 2) (reverse sn)))))]\n            (if (> m n)\n              (lazy-cat [m] (f (inc m)))\n              (if (even? c)\n                (lazy-cat [(bigint (apply str (concat (str (inc (bigint (apply str a)))) (reverse (str (inc (bigint (apply str a))))))))]\n                          (f (inc (bigint (apply str (concat (str (inc (bigint (apply str a)))) (reverse (str (inc (bigint (apply str a)))))))))))\n                (lazy-cat [(bigint (apply str (concat (str (inc (bigint (apply str a)))) (rest (reverse (str (inc (bigint (apply str a)))))))))]\n                          (f (inc (bigint (apply str (concat (str (inc (bigint (apply str a)))) (rest (reverse (str (inc (bigint (apply str a)))))))))))))\n\n              ))\n          )\n        ))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 150, "code": "(fn [a] \n  (letfn [(dec [x] (map #(- (int %) (int \\0)) (str x))) \n          (enc [x] (reduce #(+ (* % 10) %2) 0 x)) \n          (pln [n]  \n            (let [N (dec n) \n                  l (count N) \n                  d (quot l 2) \n                  H (take d N) \n                  H1 (dec (inc (enc H))) \n                  Hr (reverse H)  \n                  h (enc Hr) \n                  p (nth N d) \n                  t (enc (take-last d N))] \n              (enc \n                (cond \n                  (>= h t) \n                    (if (even? l) \n                      (concat H Hr) \n                      (concat H (list p) Hr)) \n                  (even? l) (concat H1 (reverse H1)) \n                  (< p 9) (concat H (list (inc p)) Hr) \n                  :else (concat H1 (list 0) (reverse H1))))))] \n      (iterate #(pln (inc %)) (pln a))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(shave-str [s] (subs s 1 (dec (count s))))\n          (pow* [n e] (first (drop e (iterate (partial * n) 1))))\n          (pal->num\n            ([pal] (pal->num pal 0 0))\n            ([pal n acc]\n             (if (seq pal)\n               (recur (rest pal) (inc n) (+ acc (* (first pal) (pow* 10 n))))\n               acc)))\n          (pals-of-width [w i]\n            (cond\n              (= 1 w) (map list (range i 10))\n              (= 2 w) (map #(list % %) (range i 10))\n              :else (let [sub (pals-of-width (- w 2) 0)]\n                      (mapcat\n                        (fn [n] (map #(concat (list n) % (list n)) sub))\n                        (range i 10)))))\n          (pals-of-width-from* [s]\n            (let [w (count s)\n                  c (first s)\n                  i (- (int c) (int \\0))]\n              (cond\n                (<= w 2) (pals-of-width w i)\n                :else (let [sub-a (pals-of-width-from* (shave-str s))]\n                        (concat\n                          (map #(concat (list i) % (list i)) sub-a)\n                          (pals-of-width w (inc i)))))))]\n    (let [s (str n)\n          w (count s)]\n      (filter #(>= % n)\n              (map pal->num\n                   (concat\n                     (pals-of-width-from* s)\n                     (mapcat #(pals-of-width % 1) (drop 1 (iterate inc w)))))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 150, "code": "(fn g [seed]\n  (let [reverse' (fn [p] (loop [r 0 p p] (if (zero? p) r (recur (+ (mod p 10) (* 10 r)) (quot p 10)))))\n        ilog10 (fn [n] (loop [r 0 n n] (if (< n 10) r (recur (inc r) (quot n 10)))))\n        ipow10 (fn [n] (loop [r 1 n n] (if (zero? n) r (recur (* 10 r) (dec n)))))\n        build-half (fn[p] (let [l (ilog10 p) m (ipow10 (quot (inc l) 2))] [l m (quot p m)]))\n        build-whole (fn [l m h] (+ (* m h) (reverse' (if (odd? l) h (quot h 10)))))\n        next-palindrome (fn [p] (let [[l m half] (build-half p) half' (inc half)]\n                                  (if (= (ilog10 half') (ilog10 half)) (build-whole l m half') (+ 2 p))))\n        make-palindrome (fn [p] (let [[l m h] (build-half p) np (build-whole l m h)]\n                                  (if (< np p) (next-palindrome np) np)))]\n    (iterate next-palindrome (make-palindrome seed))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "59251947e4b072a2710fce69"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "592518e8e4b072a2710fce67"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 150, "code": "(fn pali [n]\n         (letfn [(getRear [v isEven] (if isEven (reverse v) (reverse (butlast v))))\n                 (getVec \n                   ([v] (getVec v []))\n                   ([n a] (if (< n 10) (cons n a) (recur (quot n 10) (cons (rem n 10) a)))))\n                 (getNum [v] (first (reduce \n                                     (fn [[acc m] x] [(+ (* x m) acc) (* 10 m)]) \n                                     [0 1] \n                                     (reverse  v))))\n                 (isPali [v] (= v (reverse v)))\n                 (build [f isEven] (getNum (concat f (getRear f isEven))))\n                 (getNext [v n] \n                   (let [size (count v)\n                         mid (quot (count v) 2)\n                         ind (if (even? size) mid (inc mid))\n                         front (take ind v)\n                         isEven (even? size)\n                         newNum (build front isEven)]\n                     (if (> newNum n)\n                       newNum\n                       (let [incFront (getVec (inc (getNum front)))\n                             incIsEven (if (= (count front) (count incFront)) isEven (not isEven))]\n                         (build incFront incIsEven)))))]\n           (let [v (getVec n)\n                 next (if (isPali v) n (getNext v n))]\n             (lazy-seq (cons next (pali (inc next)))))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(exp [base e]\n            (if (zero? e) 1\n                (* base (exp base (dec e)))))\n          (increase-digit [number digit]\n            (+ number (* (exp 10 digit))))\n          (is-palindrome [n]\n            (= (str n) (rev-str (str n))))\n          (rev-str [s]\n            (str (reduce #(str %1 %2) (reverse s))))\n\n          (mirror-left [n]\n            (let [s (str n)\n                  left (subs s 0 (+ (rem (count s) 2) (quot (count s) 2)))]\n              (read-string (if (even? (count s)) (str left (rev-str left))\n                               (str left (subs (rev-str left) 1))))))\n          (next-palindrome [n]\n            (let [pal (mirror-left n)]\n              (if (<= pal n)\n                (mirror-left (increase-digit n ((if (even? (count (str n))) identity dec) (+ (rem (count (str n)) 2) (quot (count (str n)) 2)))))\n                pal)))\n          ]\n    ((if (is-palindrome n) identity rest) (iterate next-palindrome n))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 150, "code": "(fn\n  [n]\n  (letfn [(decode [x]\n            (if (> 10 x) [x] (conj (decode (quot x 10)) (rem x 10))))\n          (encode [x]\n            (reduce #(+ (* 10 %) %2) 0 x))\n          (next-p [x]\n            (let [N (decode x)\n                  n (count N)\n                  l (quot n 2)\n                  H (drop-last l N)\n                  H1 (decode (inc (encode H)))\n                  L (reverse (take l H))\n                  L1 (reverse (take l H1))\n                  res (encode (concat H L))]\n              (if (>= res x)\n                res\n                (encode (concat H1 L1)))))]\n    (iterate (comp next-p inc) (next-p n))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 150, "code": "(fn pp [n]\n  (letfn [             \n    (printP [[even v]]\n      (read-string (reduce (fn [s n] (str n s n)) (if even (str (first v) (first v)) (str (first v))) (next v))))\n    (isPalindrome? [n]\n                   (let [sn (str n)\n                         mid (quot (count sn) 2)]\n                        (= (subs sn 0 mid) (clojure.string/reverse (subs sn (- (count sn) mid))))))\n    (nextPalindrome [n]\n      (let [p (subvec (mapv (comp read-string str) (reverse (str n))) (quot (count (str n)) 2) )\n            t (even? (count (str n)))\n            np (if (isPalindrome? n) \n                    (loop [p p i 0]\n                         (if (= i (count p))\n                             [(not t) (into (vec (repeat (if t (count p) (dec (count p))) 0)) [1])]\n                             (let [d (get p i)]\n                                  (if (< d 9)\n                                      [t (assoc p i (inc d))]\n                                      (recur (assoc p i 0) (inc i))))))\n                    [t p])\n            out (printP np)\n            out (if (>= out n) out (nextPalindrome out))]\n            out))]\n          (if (isPalindrome? n) (iterate nextPalindrome n) (next (iterate nextPalindrome n)))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 150, "code": "(fn [n]\n  (letfn [\n    (is_palin? [n]\n      (let [s (seq (str n))] (= s (reverse s))))\n    \n    ; \u7ed9\u51fa\u524d\u534a\u90e8\u5206\u6570\u5b57\u7684\u5e8f\u5217, \u6784\u9020\u4e00\u4e2a palin\n    (get_pn [halfn odd]\n      (->>\n        (if odd\n          (concat halfn (reverse (butlast halfn)))\n          (concat halfn (reverse halfn)))\n        (apply str)\n        (read-string))\n    )\n    \n    (half [n]\n      (let [sn (str n)\n            len (count sn)\n          odd (odd? len)\n            hn_ (quot len 2)\n             hn (if odd (inc hn_) hn_)\n            hns (take hn sn)\n            hnn (read-string (apply str hns))\n             pn (get_pn hns odd)]\n      (if (< n pn)  pn (get_pn (str (inc hnn)) odd)) ))\n      \n    (next_pn [n]\n      (let [n1 (inc n)]\n        (if (is_palin? n1) n1 (half n1))))\n  ]\n  (iterate next_pn (next_pn (dec n))))\n)", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 150, "code": "(fn [n]\n  (let [half (fn [s]\n               (let [c (count s)]\n                 (subs s 0 (/ (if (odd? c) (inc c) c) 2))))\n        palindromize (fn [n]\n                       (let [s (str n)\n                             sub (half s)\n                             s' (clojure.string/reverse sub)]\n                         (Long. (str sub (if (odd? (count s)) (subs s' 1) s')))))\n        next-palindrome (fn [n]\n                          (let [s (str n)\n                                sub (str (inc (Long. (half s))))\n                                xs (repeat (int (/ (count s) 2)) \\0)]\n                            (palindromize (Long. (apply str sub xs)))))\n        p-seq (fn p-seq [n]\n                (let [p (palindromize n)]\n                  (if (>= p n)\n                    (lazy-seq (cons p (p-seq (next-palindrome p))))\n                    (p-seq (next-palindrome p)))))]\n    (p-seq n)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 150, "code": "(letfn [(glue [s] (reduce #(+ (* 10 %1) %2) s))\n        (split [n] (loop [x n l ()] (if (pos? x) (recur (quot x 10) (cons (mod x 10) l)) (or (seq l) (list 0)))))]\n  (fn f [n]\n    (let [sn (split n)\n          ln (count sn)\n          mp (dec (Math/ceil (/ ln 2)))\n          [left [mid]] (split-at mp sn)\n          inv (glue (concat left [mid] (when (even? ln) [mid]) (reverse left)))\n          nx (* (inc (glue (concat left [mid])))\n                (apply * (repeat (quot ln 2) 10)))]\n      (if (< inv n)\n        (recur nx)\n        (cons inv (lazy-seq (f nx)))))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 150, "code": "(fn palindromes\n  [x]\n  (letfn [(digits [n] (mapv (comp #(bigint %) str) (str n)))\n          (positions [pred coll] (keep-indexed (fn [i x] (when (pred x) i)) coll))\n          (palindrome?  [s] (= (digits s) (reverse (digits s))))\n          (digits->number [ds] (bigint (apply str ds)))\n          (increase \n            [init idx n]\n            (let [nines (positions #(= 9 % ) init)\n                        init (reduce (fn [acc x] \n                                       (assoc-in acc [x] 0)) \n                                     init \n                                     (filter #(> % idx) nines))\n                        init (update-in init [idx] inc)]\n                    (concat init (reverse (if (odd? n) (butlast init) init)))))\n          (widen [ds] (concat [1] (rest (mapv (constantly 0) ds)) [1]))\n          (step [x]\n            (let [ds (digits x)\n                  n (count ds)\n                  c (int (/ n 2))\n                  init (vec (first (split-at (if (odd? n) (inc c) c) ds)))]\n              (digits->number\n                (if-let [idx (last (positions #(not= 9 %) init))]\n                  (increase init idx n)\n                  (widen ds)))))]\n    (filter #(<= x %)\n      (let [retval (iterate step x)]\n        (if (palindrome? (first retval))\n          retval\n          (let [ds (digits x)\n                n (count ds)\n                c (int (/ n 2))\n                pos (if (even? n) (dec c) c)\n                retval (iterate step (digits->number (update-in ds [pos] (fn [el] (if (zero? el) el (dec el))))))]\n            (if (palindrome? (first retval))\n              retval\n              (rest retval))))))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": 150, "code": "(fn __ [x]\n  (let [\n        chars (seq (str x))\n        len (count chars)\n        le1 (quot len 2)\n        le2 (quot (inc len) 2)\n        firstPart (take le2 chars)\n        nxt (concat firstPart (reverse (take le1 chars)))\n        res1 (bigint (clojure.string/join \"\" nxt))\n\n        fpNr (inc (bigint (clojure.string/join \"\" firstPart)))\n        chars2 (seq (str fpNr))\n        nxt2 (if (even? (count chars))\n               (concat chars2 (reverse chars2))\n               (concat chars2 (drop 1 (reverse chars2)))\n               )\n        res2 (bigint (clojure.string/join \"\" nxt2))\n        res (if (< res1 x) res2 res1)\n        ]\n    (lazy-seq (cons res (__ (inc res))))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 150, "code": "(fn a [n]\n  (letfn [(next-palindrome [n]\n          (let [to-array #(vec (map (comp read-string str) (str %)))\n                to-num #(read-string (apply str %))\n                digits (to-array n)\n                is-odd (not= 0 (rem (count digits) 2))\n                mid (-> digits count (quot 2))\n                left (subvec digits 0 mid)\n                left-outer (if is-odd (subvec digits 0 (inc mid)) left)\n                right (if is-odd (subvec digits (inc mid)) (subvec digits mid))\n                pairs (partition 2 (interleave (reverse left) right))]\n        \n        \n          (println n)\n        \n            (cond \n                (and (>= n -1) (< n 9)) (inc n)\n                (every? (partial = 9) digits) (+ n 2)\n                (= digits (reverse digits)) (next-palindrome (inc n))\n                :else\n                (let [final-left (loop [left (to-num left-outer) pairs pairs]\n                      (let [l (first (first pairs)) r (last (first pairs))]\n                        (cond\n                          (> r l) (inc left)\n                          (< r l) left\n                          :else\n                            (recur left (rest pairs))\n                        )\n                      )\n                    )\n                    final-left-array (to-array final-left)]\n                    (println final-left)\n                  \n                    (to-num\n                      (concat \n                        final-left-array\n                        (if is-odd \n                            (rest (reverse final-left-array))\n                            (reverse final-left-array)\n                        )\n                      )\n                    )\n                )\n            )\n          )\n        )]\n    \n    (rest (iterate next-palindrome (dec n)))\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 150, "code": "(fn palins [n]\n  (let [next-palin (fn [n fn-mod]\n                      (let [str-n (str n)]\n                        (if (some #(not= \\9 %) str-n)\n                          (let [len (count str-n)\n                                fh  (str (fn-mod (read-string (subs str-n 0 (/ (inc len) 2 )))))\n                                rev-fh (clojure.string/reverse fh)\n                                sh  (if (even? len)\n                                      rev-fh\n                                      (subs rev-fh 1))]\n                            (read-string (str fh sh)))\n                          (fn-mod (fn-mod n)))))\n        search-palin (fn [n]\n                        (let [str-n (str n)]\n                          (if (neg? (compare str-n (clojure.string/reverse str-n)))\n                            (next-palin n inc)\n                            (next-palin n identity))))]\n    (iterate #(next-palin % inc) (search-palin n))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 150, "code": "; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 150, "code": "(fn [n] (\n           let [\n                fromnum (fn[n](if (zero? n) '(0) (loop [x n acc '()] (if (zero? x) acc (recur (quot x 10) (conj acc (rem x 10)))))))\n                s (fromnum n)\n                half (quot (count s) 2)\n                left (take half s)\n                right (take-last half s)\n                exp (fn ex[x n]\n                      (if (zero? n) 1\n                        (* x (ex x (dec n)))))\n                \n                tonum (fn[s] (reduce + (map-indexed #(* %2 (exp 10 %1)) (reverse s))))\n                ln (tonum left)\n                rn (tonum (reverse right))\n                midnum (if (odd? (count s)) (nth s half) nil)\n                getfirst (fn[](\n                              ;prn ln rn midnum\n                            cond\n                            (empty? left) [nil midnum]\n                            (>= ln rn) [ln midnum]\n                            (= midnum 9) [(inc ln) nil]\n                            (nil? midnum) (\n                                            if (= (count (fromnum (inc ln))) (count (fromnum ln)))\n                                              (identity [(inc ln) nil])\n                                              (identity [(/ (inc ln) 10) 0])\n                                            )\n                            :e [ln (inc midnum)]\n\n                  ))\n                halftop (fn[[hn midnum]] (\n                                  if (nil? hn)\n                                    midnum\n                                  (tonum (#(\n                                     if (nil? midnum)\n                                     (concat % (reverse %))\n                                     (concat % [midnum] (reverse %))\n                                     ) (fromnum hn)))\n                                  ))\n                                \n                  nextp (fn[[l m]] \n                               (\n                                  if (nil? m)\n                                  (\n                                    if (= (count (fromnum (inc l))) (count (fromnum l)))\n                                      (identity [(inc l) nil])\n                                      (identity [(/ (inc l) 10) 0])\n                                  )\n                                  (\n                                    if (= m 9)\n                                    (\n                                      if (nil? l)\n                                        (identity [1 nil])\n                                        (\n                                          if (= (count (fromnum (inc l))) (count (fromnum l)))\n                                            (identity [(inc l) 0])\n                                            (identity [(inc l) nil])\n                                          )\n                                        \n                                    )(\n                                      identity [l (inc m)]\n                                    )\n                                  )\n                                \n                                 ))\n                ]\n           (\n                    (fn lazyrec[lastv] (\n                            lazy-seq (concat [(halftop lastv)] (lazyrec (nextp lastv)))\n                              )) (getfirst)\n               )\n           ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 150, "code": "(fn solve [p]\n  (let [is-palindrome\n         (fn [p]\n           (let [ps (str p) len (int (/ (count ps) 2))\n                 l (take len ps) r (take len (reverse ps))]\n              (= l r)))\n        brute-force-next-palindrome\n         (fn [p] \"looks up the next palindrome from a non-palindrome, brute forced for now, could be too much\"\n          (first (drop-while (fn [x] (not (is-palindrome x))) (iterate inc p))))\n        next-palindrome\n         (fn [p] \"finds the next palindrome efficiently\"\n           (let [ps (str p) len (count ps) len-next (count (str (+ p 1)))]\n              (if (> len-next len) (+ p 2)\n                  (let [to-int (fn [s] (read-string (let [s (apply str (drop-while #(= % \\0) s))] (if (= \"\" s) \"0\" s))))\n                        right-len (int (/ len 2))\n                        left-len (- len right-len)\n                        val-left (to-int (subs ps 0 left-len))\n                        val-right (to-int (apply str (reverse (subs ps (- left-len 1)))))\n                        left (str (+ val-left 1))\n                        right (apply str (reverse (take right-len left)))]\n                     (to-int (str left right))))))\n        seed (if (is-palindrome p) p (brute-force-next-palindrome p))\n        palindromes-seq (fn palindromes-seq [p] (lazy-seq (cons p (palindromes-seq (next-palindrome p)))))]\n    (palindromes-seq seed)))", "user": "59be62d5e4b0a024fb6ae435"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))", "user": "587ee260e4b052da650a6353"}, {"problem": 150, "code": "(fn palindromic-numbers [n]\n(letfn [\n(next-palindromic [n]\n    (let [s (str n) hs (quot (count s) 2) offset (rem (count s) 2)]\n        (if (= 1 (count s)) n\n        (loop [b (subs s 0 (+ hs offset))]\n            (let [e (apply str (drop offset (reverse b))) \n                  nn (read-string (str b e))]\n                (if (>= nn n) nn (recur (str (inc (read-string b)))))\n            )\n        ))\n    )    \n)\n]\n(let [pn (next-palindromic n)] (lazy-seq (cons pn (palindromic-numbers (next-palindromic (inc pn))))))\n))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 150, "code": "(fn [starting-number]\n  (letfn\n    [(binary-upper [number magnitude]\n       (* number (long (* magnitude 10))))\n\n     (binary-lower [number magnitude]\n       (loop [left-number number\n              curr-magnitude 1\n              num-reverse 0]\n         (if (>= curr-magnitude (* 10 magnitude))\n           num-reverse\n           (recur\n             (long (/ left-number 10))\n             (* 10 curr-magnitude)\n             (+\n              (mod left-number 10)\n              (* num-reverse 10))))))\n\n     (unary-lower [number magnitude]\n       (mod (binary-lower number magnitude) magnitude))\n\n     (unary-upper [number magnitude]\n       (* number magnitude))\n\n     (power-ranges []\n       (let [powers (iterate #(* 10 %) 1)]\n         (map vector powers powers (rest powers))))\n\n     (unary-pal [magnitude number]\n       (+ (unary-upper number magnitude)\n          (unary-lower number magnitude)))\n\n     (binary-pal [magnitude number]\n       (+ (binary-upper number magnitude)\n          (binary-lower number magnitude)))\n\n     (palindrome-range [[low-bound from up-bound ]]\n       (let [items (range from up-bound)]\n         (concat (map (partial unary-pal low-bound) items)\n                 (map (partial binary-pal low-bound) items))))\n\n     (palindromes-of-magn [from magnitude base]\n       (let [drop-fn (fn [number] (< number magnitude))\n             ranges-p (drop-while\n                        #(> (/ base 10) (first %))\n                        (power-ranges))\n             first-range (first ranges-p)\n             ranges (if (and\n                          (< base (nth first-range 2))\n                          (> base (first first-range)))\n                      (concat\n                        [[(first first-range) base (last first-range)]]\n                        (rest ranges-p))\n                      ranges-p)]\n         (drop-while\n           #(< % from)\n           #_(constantly false)\n           (concat\n             [0]\n             (mapcat palindrome-range ranges)))))\n\n     (calc-magnitude [from]\n       (if (= from 0)\n         {:magnitude 0\n          :base 0\n          :binary false}\n         (loop [leftover from\n                magnitude 1]\n           (if (= leftover 0)\n             {:magnitude magnitude\n              :base (long (/ from magnitude))\n              :binary true}\n             (if (< leftover 10)\n               {:magnitude magnitude\n                :base (long (/ from magnitude))\n                :binary false}\n               (recur\n                 (long (/ leftover 100))\n                 (* magnitude 10)))))))\n\n     (palindromes [from]\n       (let [{:keys [magnitude binary base]} (calc-magnitude from)]\n         (palindromes-of-magn from magnitude base)))\n     ]\n    (palindromes starting-number)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 150, "code": "(fn [t n]\n          (let [ns (str n)]\n            (drop-while #(< % n) (concat (range 10)\n                                         (if (< n 10)\n                                           (t 1 1 true)\n                                           (let [c (count ns)\n                                                 q (quot c 2)]\n                                             (t (read-string (subs ns 0 q))\n                                                (apply * (repeat (dec q) 10))\n                                                (even? c)))) )\n                        )))\n\n        (fn t [p i e]\n          (let [ii (* 10 i)\n                s (range p (* i 10))\n                k #(read-string (str % %2 (clojure.string/reverse (str %))))]\n            (lazy-cat (if e (map #(k % \"\") s))\n                      (mapcat (fn [ss] (map #(k ss %) (range 10))) s)\n                      (t ii ii true))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 150, "code": "(fn [x]\n  (letfn [;; return first half of string.\n          (head\n            [^String s]\n            (subs s 0 (Math/ceil (/ (count s) 2))))\n\n          ;; mirror a (half) string. Depending on whether the original (full) string\n          ;; has an even amount of characters, this might mean cutting off one character\n          ;; from the start of the string, after reversing it.\n          (mirror\n           [even? ^String half-s]\n            (Long.\n              (str\n                half-s\n                (-> half-s\n                    clojure.string/reverse\n                    (subs (if even? 0 1))))))\n          \n          ;; the next palindrome after the integer n is EITHER the integer mirrored \n          ;; as-is (example: 100 -> 101, this is what \"h\" is used for) OR the integer\n          ;; split into half, increased by one, and mirrored (example: 101 -> 111,\n          ;; this is what h-plus is used for)\n          (next-palindrome\n            [^Long n]\n            (let [s      (str n)\n                  h      (head s)\n                  h-plus (-> h Long. inc str)\n                  [a b]  (map (partial mirror (even? (count s))) [h h-plus])]\n             (if (>= a n) a b)))]\n    \n    (iterate (comp next-palindrome inc) (next-palindrome x))))", "user": "51ae350fe4b09397d5109790"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "59358f74e4b04f87174def52"}, {"problem": 150, "code": "(fn pal [n]\n  (if (= n 0)\n    (lazy-seq (cons 0 (pal 1)))\n    (let [digits (->> (iterate #(quot % 10) n)\n                      (take-while pos?)\n                      (mapv #(mod % 10))\n                      rseq\n                      vec)\n          len (count digits)\n          indices (range (int (/ len 2)) len)\n          mirror-number (fn [ls i]\n                          (->> (- (count ls) i 1)\n                               (nth ls)\n                               (assoc ls i)))\n          f (fn [ls]\n              (loop [ls ls\n                     idxs (rest indices)\n                     i (- len 1 (first indices))]\n                (if (= 9 (nth ls i))\n                    (recur (assoc ls i 0) (rest idxs) (- len 1 (first idxs)))\n                    (reduce mirror-number (assoc ls i (inc (nth ls i))) indices))))\n          out (loop [ls digits\n                     idxs indices]\n                (if-let [i (first idxs)]\n                  (let [di (nth ls i)\n                        dj (nth ls (- len i 1))]\n                    (cond\n                      (> di dj) (f ls)\n                      (< di dj) (reduce mirror-number ls idxs)\n                      :else (recur ls (rest idxs))))\n                  ls))\n          m (reduce #(+ (* 10 %1) %2) out)]\n      (lazy-seq (cons m (pal (inc m)))))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 150, "code": "; stubbing amcnamara's solution:\n(fn [n]\n  (iterate \n    #(let [sub_l (inc (read-string (apply str (take (Math/ceil (/ (count (str %)) 2)) (str %)))))\n           sub_r ((if (odd? (count (str %))) rest seq) (reverse (str sub_l)))]\n       (if (every? #{\\9} (str %))\n         (+ 2 %)\n         (read-string (apply str sub_l sub_r))))\n    (#(if (= (seq (str %)) (reverse (str %))) % (recur (inc %))) n)))\n\n; my solution works well on my Mac but times out for some reason on 4clojure:\n#_(letfn [(half [xs]\n          (take (/ (count xs) 2) xs))\n        (digits [n]\n          (map #(Character/digit (char %) (int 10)) (str n)))\n        (digits->num [xs]\n          (reduce (fn [n dig] (+ (* n 10) dig)) 0 xs))\n        (mirror [n share?]\n          (let [d   (digits n)\n                mir (if share?\n                      (concat d (reverse (butlast d)))\n                      (concat d (reverse d)))]\n            (digits->num mir)))\n        (palin-seq [n pow10 share?]\n          (cond (< n pow10)\n                (cons (mirror n share?)\n                      (lazy-seq (palin-seq (inc n) pow10 share?)))\n                share?\n                (palin-seq (/ pow10 10) pow10 (not share?))\n                :else\n                (palin-seq pow10 (* 10 pow10) true)))]\n  (fn ps [n]\n    (if (= n 0)\n      (cons 0 (ps 1))\n      (let [d      (digits n)\n            root   (digits->num (half d))\n            pow10  (long (Math/pow 10 (inc (long (Math/log10 n)))))\n            share? (odd? (count d))]\n        (remove #(< % n) (palin-seq root pow10 share?))))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 150, "code": "(fn palinLargerEqThan [x]\n  (letfn [(isPalin [x]\n            (= (reverse (str x)) (apply list (str x))))\n          (listToInt [x res]\n  \t\t\t(if (empty? x) res\n    \t\t\t(recur (rest x) (+ (* res 10) (first x)))))\n\t\t  (intToList2 [x res]\n  \t\t\t(if (zero? x) res\n    \t\t\t(recur (quot x 10) (conj res (mod x 10)))))\n          (makePalin [x]\n\t\t\t  (let [size (int (/ (inc (count (str x))) 2))\n        \t\t\tupperPart (take size (intToList2 x (list)))]\n    \t\t\t(if (even? (count (str x)))\n      \t\t\t\t(listToInt (concat upperPart (reverse upperPart)) 0)\n      \t\t\t\t(listToInt (concat upperPart (rest (reverse upperPart))) 0))))\n          (nextPalin [x]\n            (if (> x 100)\n    \t\t\t(let [size (int (/ (inc (count (str x))) 2))\n          \t\t\tupperPart (take size (intToList2 x (list)))\n          \t\t\tnextUpperPart (intToList2 (inc (listToInt upperPart 0)) (list))\n          \t\t\tnextUpperPart2 (take size (intToList2 (inc (listToInt upperPart 0)) (list)))\n          \t\t\toverflow? (> (count nextUpperPart) (count upperPart))\n          \t\t\tnewPalinEven (concat nextUpperPart2 (reverse nextUpperPart2))\n          \t\t\tnewPalinEvenOvf (concat nextUpperPart (rest (reverse nextUpperPart)))\n          \t\t\tnewPalinOdd  (concat nextUpperPart2 (rest (reverse nextUpperPart2)))]\n      \t\t\t(if (even? (count (str x))) \n        \t\t\t(if (= true overflow?)\n          \t\t\t(listToInt newPalinEvenOvf 0) \n          \t\t\t(listToInt newPalinEven 0))\n        \t\t\t(if (= true overflow?)\n          \t\t\t(listToInt newPalinEven 0)\n          \t\t\t(listToInt newPalinOdd 0))))\n  \t\t\t(first (filter isPalin (iterate inc (inc x))))))]\n    (if (isPalin x)\n      (lazy-seq (cons x (palinLargerEqThan (nextPalin x))))\n      (if (> (makePalin x) x)\n        (lazy-seq (cons (makePalin x) (palinLargerEqThan (nextPalin x))))\n        (lazy-seq (palinLargerEqThan (nextPalin x)))))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 150, "code": "(fn palins [n] \n   (letfn [(isPalin [n]\n           (if (= (str n) \n               (apply str (reverse (str n))) ) true false )\n            )\n           \n           (nextpalin [n]\n              (if (isPalin n) n (recur (inc n)) )\n           )\n        \n           (nextpalin2 [p]\n               (let [sp (str p) plen (count sp)  ev (even? plen)\n                        h (/ plen 2) m (if ev h (inc (int h))) \n                     msp (read-string (apply str (take  m sp)))\n                     nhp (inc msp)]\n                (if (= (count (str nhp)) m)\n                    (if ev \n                       (apply str (concat (str nhp) \n                          (apply str (reverse (str nhp)))))\n                       (apply str (concat (str nhp) \n                          (drop 1 (apply str (reverse (str nhp))))))\n              )\n              (str (nextpalin (* nhp \n                           (reduce * (repeat (- plen m) 10)))))\n                 )\n     \n               )\n               )\n              \n          (pr [p]\n              (lazy-seq (cons p (pr (read-string (nextpalin2 p)))))\n          )]\n   (pr (nextpalin n))\n  )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 150, "code": "(fn [n]  \n          (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n                  (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n                  (next-pal [n]\n                    (let [N (decode n)\n                          l (count N)\n                          d (quot l 2)\n                          H (take d N)\n                          H1 (decode (inc (encode H)))\n                          Hr (reverse H)\n                          h (encode Hr)\n                          p (nth N d)\n                          t (encode (take-last d N))]\n                      (encode (cond\n                                (and (even? l) (>= h t)) (concat H Hr)\n                                (and (odd? l)  (>= h t)) (concat H [p] Hr)\n                                (even? l)                (concat H1 (reverse H1))\n                                (and (odd? l) (< p 9))   (concat H [(inc p)] Hr)\n                                :else                    (concat H1 [0] (reverse H1))))))]\n            (iterate (comp next-pal inc) (next-pal n))))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 150, "code": "(fn ff [n]\n  (let [nn (seq (str n))\n        c (count nn)]\n    (if (<= c 1)\n      (cons n (ff (inc n)))\n      (let [q (quot c 2)\n            splited (if (even? c)\n                      (split-at q nn)\n                      (list (take q nn) (nth nn q) (take-last q nn)))\n            fs (if (even? c)\n                 (first splited)\n                 (concat (first splited) (list (nth nn q))))\n            p (concat fs (reverse (first splited)))\n            value (bigint (apply str p))\n            next-value (* (inc (bigint (apply str fs))) (reduce * (repeat q 10)))]\n        (if (< value n)\n          (ff next-value)\n          (lazy-seq\n           (cons value (ff next-value))))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 150, "code": "(let [nextp (fn [n]\n                (if (<= 0 n 8)\n                  n\n                  (let [s (str n)\n                        half (subs s 0 (Math/ceil (/ (count s) 2)))\n                        next (str (inc (Long. half)))\n                        [a b] (map #(Long. (str % (subs (clojure.string/reverse %)\n                                                        (if (even? (count s))\n                                                          0 1))))\n                                   [half next])]\n                    (if (>= a n) a b))))]\n    #(iterate (comp nextp inc) (nextp %)))", "user": "57283dbce4b0c5bde472c154"}, {"problem": 150, "code": "(fn g [n]\n    (if (= n 0)\n      (cons 0 (g 1))\n      (let [pow          #(apply * (repeat % 10))\n            pows         (set (map pow (range 1 18)))\n            palindrome-1 (fn [x]\n                           (read-string (apply str (concat (str x) (rest (reverse (str x)))))))\n            palindrome-2 (fn [x]\n                           (read-string (apply str (concat (str x) (reverse (str x))))))\n            c            (count (str n))\n            d            (max 1 (quot (inc c) 2))\n            a            (read-string (apply str (subvec (vec (str n)) 0 d)))\n            a            (if\n                           (if\n                             (even? c)\n                             (< (palindrome-2 a) n)\n                             (< (palindrome-1 a) n))\n                           (inc a)\n                           a)\n            b            (pow (dec d))\n            f            (fn f [first-run r]\n                           (let\n                             [[first-nums second-nums]\n                              (split-with\n                                #(not (contains? pows %))\n                                (rest r))\n                              first-nums (cons (first r) first-nums)]\n                             (lazy-cat\n                               (if first-run\n                                 '()\n                                 (map palindrome-1 first-nums))\n                               (map palindrome-2 first-nums)\n                               (f false second-nums))))\n            ]\n        (if (even? c)\n          (f true (iterate inc a))\n          (lazy-cat (map palindrome-1 (cons a (take-while #(not (contains? pows %)) (iterate inc (inc a)))))\n                    (f true (iterate inc b)))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 150, "code": "(fn [num]\n  (let [to_digits (fn [x]\n                    (if (= 0 x)\n                      (list x)\n                      (loop [y x\n                             ds nil]\n                           (if (= 0 y)\n                               ds\n                               (recur (quot y 10) (cons (rem y 10) ds))))))\n        to_number (fn [ds]\n                    (if (empty? ds)\n                       0\n                       (loop [xs ds\n                              n 0]\n                            (if (empty? xs)\n                                n\n                                (recur (rest xs) (+ (* n 10) (first xs)))))))\n        is_palindrome (fn [x] (= (to_digits x) (reverse (to_digits x))))\n        next_palindrome_2\n  (fn [p]\n    (let [p_digits (to_digits p)\n          num_p_digits (count p_digits)\n          half_num_p_digits (quot num_p_digits 2)]\n        (cond\n          (< p 9) (+ 1 p)\n          (< p 11) 11\n          :else \n            (let [leading_digits (take (+ (if (even? num_p_digits) 0 1) half_num_p_digits) p_digits)\n                  leading_number (to_number leading_digits)\n                  leading_number_plus_1 (+ 1 leading_number)\n                  leading_number_plus_1_digits (to_digits leading_number_plus_1)\n                  half_p_digits (take half_num_p_digits leading_number_plus_1_digits)]\n              (to_number (concat leading_number_plus_1_digits (reverse half_p_digits)))))))\n          next_palindrome\n  (fn [n]\n    (let [n_digits (to_digits n)\n          num_n_digits (count n_digits)\n          half_num_n_digits (quot num_n_digits 2)]\n      (cond\n          (< n 9) (+ 1 n)\n          (< n 11) 11\n          (even? num_n_digits)\n            (let [leading_digits (take half_num_n_digits n_digits)\n                  trailing_digits (drop half_num_n_digits n_digits)\n                  reverse_leading_number (to_number (reverse leading_digits))\n                  trailing_number (to_number trailing_digits)]\n              (if (> reverse_leading_number trailing_number)\n                (to_number (concat leading_digits (reverse leading_digits)))\n                (next_palindrome_2 n)))\n          :else\n            (let [leading_digits (take half_num_n_digits n_digits)\n                  leading_digits_2 (take (+ 1 half_num_n_digits) n_digits)\n                  trailing_digits (reverse (take half_num_n_digits (reverse n_digits)))\n                  reverse_leading_number (to_number (reverse leading_digits))\n                  trailing_number (to_number trailing_digits)]\n              (if (> reverse_leading_number trailing_number)\n                (to_number (concat leading_digits_2 (reverse leading_digits)))\n                (next_palindrome_2 n))))))]\n    (if (is_palindrome num)\n        (iterate next_palindrome num)\n        (drop 1 (iterate next_palindrome num)))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 150, "code": "(fn [n] (let [f (fn f [l] (cond (empty? l) '(\\1)\n                           (= \\9 (first l)) (cons \\0 (f (rest l)))\n                           :else (cons (char (inc (int (first l)))) (rest l))))\n              nxt (fn [n]\n                (let [s (str n)\n                      c (count s)\n                      l (drop (quot c 2) s)\n                      r (f l)\n                      rr (rest r)\n                      z (if (empty? (clojure.string/replace s #\"9\" \"\"))\n                            (concat (reverse (rest r)) (if (even? c) r (rest r)))\n                            (concat (reverse (if (even? c) r (rest r))) r))]\n                    (read-string (apply str z))))\n                  \n              s (str n)\n              c (count s)\n              [l r] (split-at (+ (quot c 2) (rem c 2)) s)\n              ps (map (fn [l r] [l r]) l (reverse (cons \\0 r)))\n              need-next (reduce (fn [a [l r]] (if (< (int l) (int r)) true a)) false ps)\n              hlf (if need-next (f (reverse l)) (reverse l))\n              start (read-string (apply str (concat (reverse hlf) (if (even? c) hlf (rest hlf)))))\n              ]\n(iterate nxt start)))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 150, "code": "(fn [n]\n  (let [pow           (fn [a b] (int (Math/pow a b)))\n        half-count    (fn [s] (quot (count s) 2))\n        first-palinum (fn [n]\n                        (let [s (seq (str n))\n                              c (half-count s)\n                              t (drop c (reverse s))]\n                          (BigInteger. (apply str (concat (take c (reverse t)) t)))))\n        next-palinum  (fn [n]\n                        (let [s (seq (str n))\n                              c (half-count s)\n                              i (fn [k] (if (<= k c) (pow 10 (max 0 k)) 0))\n                              k (count (drop-while #{\\9} (drop c s)))]\n                          (+ n (i k) (i (dec k)))))]\n    (drop-while #(< % n) (iterate next-palinum (first-palinum n)))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 150, "code": "(fn [n] (let [nextp (fn [op n] \n                      (let [cn (->> n inc str count) \n                            nexth (->> (int (/ cn 2)) (Math/pow 10) (/ n) int op str)\n                            to-rev (- (count nexth) (if (even? cn) 0 1))]\n                      (->> (take to-rev nexth) reverse (apply str) (str nexth) read-string)))\n         \t  init (if (<= 0 n 9) n (let [i (nextp identity n)] (if (< i n) (nextp inc i) i)))]\n      (iterate (partial nextp inc) init)))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 150, "code": "(fn f \n\t([n] (f n n))\n\t([n cur] (let [to-int (fn [c] (read-string (apply str c)))\n\t               digits (->> cur str (map (comp read-string str)))\n\t               cnt (count digits)\n\t               half-count (if (zero? (mod cnt 2)) (/ cnt 2) (inc (int (/ cnt 2))))\n\t               half (take half-count digits)\n\t               half-n-inc (inc (to-int half))\n\t               next-n (to-int (concat (clojure.string/split (str half-n-inc) #\"\") \n\t                                      (repeat (- cnt half-count) 0)))\n\t               pal (concat half \n\t                           (reverse (if (even? (count digits)) half (drop-last half))))\n\t               pal-n (to-int pal)]  \n\t              (lazy-seq (if (>= pal-n n) (cons pal-n (f n next-n)) (f n next-n))))))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 150, "code": "(fn pal-nums [n]\n  (letfn [(decode [n]\n            (if (< n 10)\n              [n]\n              (conj (decode (quot n 10)) (rem n 10))))\n          (encode [coll]\n            (reduce #(+ (* % 10) %2) 0 coll))\n          (next-num [n]\n            (let [ns (decode n)\n                  l (count ns)\n                  m (quot l 2)\n                  ls (take m ns)\n                  lr (reverse ls)\n                  lv (encode lr)\n                  mp (nth ns m)\n                  rv (encode (take-last m ns))\n                  ls1 (decode (inc (encode ls)))]\n              (encode (cond\n                        (and (even? l) (>= lv rv)) (concat ls lr)\n                        (and (odd? l) (>= lv rv)) (concat ls [mp] lr)\n                        (even? l) (concat ls1 (reverse ls1))\n                        (and (odd? l) (< mp 9)) (concat ls [(inc mp)] lr)\n                        :else (concat ls1 [0] (reverse ls1))))))]\n    (iterate #((comp next-num inc) %) (next-num n))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 150, "code": "(fn[n]\n        (letfn [(palindrome?[s]\n                  (if (< (count s) 2) true \n                      (and (= (first s) (last s)) (recur (drop 1 (drop-last 1 s))))))\n              \n                (first-palindrome-greater-or-equal-than\n                  [n] (first (filter #(palindrome? (str %)) (iterate inc n))))\n              \n                (palindrome-seed\n                  [n] (let [repr (str n)\n                            length (count repr)\n                            stub-length (int  (Math/ceil (/ (count repr) 2)))]\n                        (biginteger (subs repr 0 stub-length))))\n              \n                (pow10 [n] (reduce *' (repeat n 10)))\n                \n                (log10 [n] (first (filter #(> (pow10 %) n) (range))))\n              \n                (mirror-symmetric [k] \n                  (let [lhs (str k)\n                        rhs (clojure.string/reverse lhs)]\n                    (biginteger (str lhs rhs))))\n              \n                (mirror-asymmetric [k] \n                  (let [lhs (str k)\n                        rhs (subs (clojure.string/reverse lhs) 1)]\n                    (biginteger (str lhs rhs))))\n                \n                (all-palindromes-aux[toggle i seed]\n                  (cons \n                   (if toggle\n                     (mirror-symmetric seed)\n                     (mirror-asymmetric seed))\n                   (lazy-seq \n                    (let [limit (pow10 i)\n                          next-seed (inc seed)]\n                      (cond \n                       (and (= next-seed limit) (not toggle))\n                       (all-palindromes-aux true i (pow10 (dec i)))\n                       \n                       (and (= next-seed limit) toggle)\n                       (all-palindromes-aux false (inc i) (pow10 i))\n                       \n                       :else\n                       (all-palindromes-aux toggle i (inc seed)))))))]\n\n          (let [first (first-palindrome-greater-or-equal-than n)\n                seed (palindrome-seed first)\n                test (mirror-symmetric seed)]\n\n            (all-palindromes-aux (= test first)  (log10 seed) seed))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 150, "code": "(fn [n]\n          (letfn [(f [n]\n            (let [s (str n)\n                  l (count s)\n                  prefix (subs s 0 (Math/ceil (/ l 2)))\n                  prefix-inc (-> prefix Long. inc str)\n                  rev-pefix (clojure.string/reverse prefix)\n                  rev-pefix-inc (clojure.string/reverse prefix-inc)\n                  this-value (if (even? l) (str prefix rev-pefix) (str prefix (subs rev-pefix 1)))\n                  next-value (if (even? l) (str prefix-inc rev-pefix-inc) (str prefix-inc (subs rev-pefix-inc 1)))]\n              (if (>= (Long. this-value) n) (Long. this-value) (Long. next-value))))]\n            (iterate (comp f inc) (f n))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 150, "code": "(fn [x]\n  (let [palitest (fn [n] (= (str n) (apply str (reverse (str n)))))\n        proce (fn [n]\n                (let [strn (str n)\n                      cstrn (count (str n))\n                      hlf (quot cstrn 2)\n                      spltp (take (- cstrn hlf) strn)\n                      cs->i (fn [cs] (read-string (apply str cs)))\n                      newnumseq [spltp (reverse (take hlf strn))]\n                      newnum (cs->i (flatten newnumseq))\n                      incc (seq (str (inc (cs->i spltp))))\n                      newincseq [incc (reverse (take hlf incc))]\n                      newincnum (cs->i (flatten newincseq))\n                      newpali (if (> newnum n) newnum newincnum)]\n                  newpali))]\n    (filter #(palitest %) (iterate proce x))))", "user": "4e8768f6535dceadca469850"}, {"problem": 150, "code": "(fn [lower]\n(let \n  [expt (fn [x n] (reduce *' (repeat n x)))\n   number-of-digits (fn [n] (count (str n)))\n   first-start (if (< lower 10) 0 (read-string (apply str (take (quot (count (str lower)) 2) (str lower)))))\n   reverse-str (fn [s] (apply str (reverse (str s))))\n   palindromes-of-length (fn [len]\n    (if (< len 2)\n      (range 10)\n      (let [start-m (expt 10 (- (quot len 2) 1))\n            start (max first-start start-m)\n            end (* 10 start)]\n        (if (even? len)\n          (map \n            (fn [i]\n              (read-string\n                (str (str i) (reverse-str i))))\n            (range start end))\n          (mapcat\n            (fn [m]\n              (map \n                (fn [i]\n                  (read-string\n                    (str (str m) i (reverse-str m)))) \n                (range 10)))\n            (range start end))))))]\n    (drop-while \n      #(< % lower) \n      (mapcat\n        palindromes-of-length\n        (iterate inc (number-of-digits lower))))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 150, "code": "(let\n     [genpal (memoize(fn [genpal nb-digits from]\n                       \"renvoie la liste des palindromes (string) de taille nb-digits avec ceux commancant par la suite de chiffres from\"\n                       (if (= 1 nb-digits)\n                         ;;cas de base 1\n                         (map str (range 10))\n                         \n                         (if (= 2 nb-digits)\n                           ;;cas de base 2\n                           (map #(str % %) (range (if (seq from) (first from) 0) 10))\n\n                           ;;rajoute le meme chiffre a gauche et a droite a tous les palindromes de taille n-2\n                           \n                           (let [pals-2from (if (seq from)\n                                              (genpal genpal (- nb-digits 2) (rest from))\n                                              ())\n                                 palsfrom (if (seq from)\n                                            (map #(str (first from) % (first from)) pals-2from)\n                                            ())\n                                 pals-2after (genpal genpal (- nb-digits 2) nil)\n                                 nextdigit (if (seq from) (inc (first from)) 0)\n                                 palsafter (mapcat (fn [i] (map #(str i % i) pals-2after)) (range nextdigit 10))]\n                             (concat palsfrom palsafter))))))\n      \n      ;genpal (partial genpal genpal)\n      genpal (fn genpal2 \n               ([nb-digits]\n                 \"renvoie la liste des palindromes (int) de taille nb-digits, un palindrome ne peut pas commencer par 0\"\n                 (genpal2 nb-digits [1]))\n               ([nb-digits from]\n                 \"commence par le palindrome ayant la suite de chiffres from\"\n                 (map #(read-string %) (genpal genpal nb-digits from))))\n      \n      \n      pallazy-nbdigit (fn pallazy-nbdigit[nb-digits]\n                        (lazy-seq (concat (genpal nb-digits) (pallazy-nbdigit (inc nb-digits)))))\n      \n      pallazy-from (fn [n]\n                     (let [nb-digits (count (str n))\n                           seq-digit (map #(read-string (str %)) (take (int (/ (+ 1 nb-digits) 2)) (str n)))];on fixe la premiere moitie des chiffres (celui du mileu inclus) de n pour le premier palindrome\n                       (println n nb-digits seq-digit)\n                       (lazy-seq (concat (drop-while (partial > n) (genpal nb-digits seq-digit)) (pallazy-nbdigit (inc nb-digits))))))]\n     pallazy-from)", "user": "5b000332e4b0cc2b61a3bd36"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 150, "code": "(fn palindromics [n]\n  (let [next-palindromic (fn [n]\n                           (let [digit     #(rem (quot %1 %2) 10)\n                                 magnitude (/ (->> (iterate #(* 10 %) 1)\n                                                   (drop-while #(<= % n))\n                                                   first)\n                                              10)]\n                             (loop [n n\n                                    x magnitude\n                                    y 1]\n                               (if (<= y x)\n                                 (let [a (digit n x)\n                                       b (digit n y)]\n                                   (cond\n                                     (< b a) (recur\n                                              (+ n (* y (- a b)))\n                                              (/ x 10)\n                                              (* y 10))\n                                     (< a b) (if (= x (* 10 y))\n                                               (recur\n                                                (+ n (* x (- b a)))\n                                                (/ x 10)\n                                                (* y 10))\n                                               (let [c (digit n (* 10 y))]\n                                                 (recur\n                                                  (+ n (* y (- 10 (- b a))))\n                                                  (if (= c 9) magnitude (/ x 10))\n                                                  (if (= c 9) 1 (* y 10)))))\n                                     :else   (recur n (/ x 10) (* y 10))))\n                                 n))))]\n    (iterate (comp next-palindromic inc) (next-palindromic n))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 150, "code": "(fn palindromes [n]\n  (letfn [(complete\n            ([dc hf hd]\n             (->> hf reverse (drop dc) (concat hd) (apply str) bigint))\n            ([dc hf]\n             (complete dc hf hf)))\n          (half [is]\n                (drop-last (quot (count is) 2) is))\n          (p-next [i]\n                  (let [hs (half (str i))\n                        in (->> hs (apply str) bigint inc str)]\n                    (complete (if (odd? (count (str i))) 1 0) (take (count hs) in) in)))]\n    (let [nstr (str n)\n          nc (->> nstr half (complete (if (odd? (count nstr)) 1 0)))\n          f (if (< nc n) (p-next nc) nc)]\n      (cons f (lazy-seq (palindromes (p-next f)))))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 150, "code": "(fn palindr [n]\n  (letfn [(from-arr [nn] (BigInteger. (apply str nn)))\n          (to-arr [nn] (if (zero? nn) [0] (map #(- (int %) (int \\0)) (str nn))))\n          (step [nn even?]\n            (lazy-seq\n              (let [nd (to-arr nn)\n                    bot (reverse (if even? nd (butlast nd)))\n                    cur (from-arr (concat nd bot))]\n                (cons cur (if (every? #(= 9 %) nd)\n                            (step (if even? (inc nn) (quot (inc nn) 10))\n                                  (not even?))\n                            (step (inc nn) even?))))))]\n    (let [nd (to-arr n)\n          len (count nd)]\n      (drop-while\n        #(< % n)\n        (step (from-arr (take (+ (quot len 2) (mod len 2)) nd))\n              (even? len))))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 150, "code": "(letfn [(num-digits [x]\n          (loop [acc 1, todo (quot x 10)]\n            (if (zero? todo)\n              acc\n              (recur (inc acc) (quot todo 10)))))\n        (prefix [x end]\n          (let [len (num-digits x)\n                exp (- len end)]\n            (loop [left x, i 0]\n              (if (>= i exp)\n                left\n                (recur (quot left 10) (inc i))))))\n        (appendr [left x]\n          (loop [acc left, todo x]\n            (if (zero? todo)\n              acc\n              (recur (+ (* 10 acc) (rem todo 10)) (quot todo 10)))))\n        (all-nines? [x]\n          (cond\n            (zero? x) true\n            (not= (rem x 10) 9) false\n            :else (recur (quot x 10))))\n        (palindrome? [x] (= x (appendr 0 x)))\n        (next-palindrome [pal]\n          (if (< pal 9)\n            (inc pal)\n            (let [len (num-digits pal)]\n              (cond\n                (all-nines? pal) (+ pal 2)\n                (even? len) (let [left (inc (prefix pal (quot len 2)))]\n                              (appendr left left))\n                :else (let [left (prefix pal (inc (quot len 2)))\n                            middle (rem left 10)\n                            left (quot left 10)]\n                        (if (< middle 9)\n                          (appendr (+ (* left 10) (inc middle)) left)\n                          (appendr (* (inc left) 10) (inc left))))))))\n        (palindrome-after [n]\n          (let [len (num-digits n)\n                left (prefix n (if (even? len) (quot len 2) (inc (quot len 2))))\n                pal (if (even? len) (appendr left left) (appendr left (quot left 10)))]\n            (if (< pal n)\n              (next-palindrome pal)\n              pal)))]\n  (fn palindromes-from [x]\n    (lazy-seq\n     (let [seed (if (palindrome? x) x (palindrome-after x))]\n       (cons seed (palindromes-from (next-palindrome seed)))))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 150, "code": "(fn [x] (let [\ntoseq (fn tos [n] (if (= 0 n) '() (concat (tos (bigint (/ n 10))) (list (mod n 10)))))\ntonum (fn ton [s] (if (empty? s) 0 (+ (first s) (* 10 (ton (rest s))))))\nmyel (fn [firs middle times] (if (= -1 middle) (+ (tonum (toseq firs)) (* firs times)) (+ (tonum (toseq firs)) (* times (+ middle (* 10 firs))))))\nisall9 (fn isall [n] (if (= 9 n) true (if (= 9 (mod n 10)) (isall (int (/ n 10))) false)))\nmyse (fn myseq [firs middle times]\n  (cons (myel firs middle times)\n        (lazy-seq\n         (if (= 9 middle)\n           (if (or (isall9 firs) (= 0 firs))\n             (myseq times -1 (* 10 times))\n             (myseq (inc firs) 0 times))\n           (if (= -1 middle)\n             (if (isall9 firs)\n               (myseq (/ times 10) 0 times)\n               (myseq (inc firs) middle times))\n             (myseq firs (inc middle) times))))))\nxseq (toseq x)\nxsmid (int (/ (count xseq) 2))\nxfi (tonum (reverse (take xsmid xseq)))\nxmi (if (= 0 (mod (count xseq) 2)) -1 (nth xseq xsmid))\nxti (reduce * (repeat xsmid 10))\n              ] (if (> x 10) (drop-while #(< % x) (myse xfi xmi xti)) (drop-while #(< % x) (myse 0 0 1)) )))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 150, "code": "(let [iter (fn [x]\n             (let [nines (first (filter #(not= (nth x %) 9) (range (count x)))) digits (-> x count dec)]\n               (if (< nines digits)\n                 (concat (repeat nines 0) [(inc (nth x nines))] (drop (inc nines) x))\n                 (let [even (not (last x))]\n                   (concat (repeat (if even (dec digits) digits) 0) [1 even])))))]\n  (fn [x]\n    (let [dfunc (fn dfunc [xx] (if (zero? xx) [] (concat [(rem xx 10)] (dfunc (quot xx 10)))))\n          d (dfunc x)\n          n (count d)\n          even (even? n)\n          sublen (quot (inc n) 2)\n          begin (reverse (take sublen d))\n          end (reverse (take sublen (reverse d)))\n          init (concat end [even])\n          excess (concat (map #(- (nth end %) (nth begin %)) (range (dec sublen) -1 -1)) [1])\n          advance (< (first (filter #(not (zero? %)) excess)) 0)\n          initadv (if advance (iter init) init)]\n      (map (fn [obj]\n             (let [mainlen (dec (count obj))\n                   main (take mainlen obj)\n                   rmain (reverse main)\n                   head (if (last obj) rmain (take (dec mainlen) rmain))\n                   digits (concat head main)\n                   parsefunc (fn parsefunc [dd] (if (empty? dd) 0 (+ (first dd) (* 10 (parsefunc (rest dd))))))]\n               (parsefunc digits)))\n           (iterate iter initadv)))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 150, "code": "(fn closestPalin\n  [min]\n  (rest\n   (iterate\n    (fn [n]\n      (let [n->s (fn [n] (map #(- (int %) 48) (str n)))\n            s->n (fn [s] (read-string (apply str s)))\n            sn (n->s (inc n))\n            lsn (count sn)\n            lim (quot lsn 2)]\n        (s->n\n         (loop [s sn i 0]\n           (let [left (nth s i)\n                 right (nth s (- lsn i 1))\n                 mult (nth (iterate #(* % 10) 1) i)\n                 change (fn [amount] (n->s (+ (s->n s) (* mult amount))))]\n             (println s i left right mult change)\n             (cond\n              (= i lim)      s\n              (= left right) (recur s (inc i))\n              (> left right) (recur (change (- left right))  i)\n              :else          (recur (change (+ 10 (- left right))) i))))))) (dec min))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 150, "code": "(fn g [n]\n (lazy-seq\n  (let [p #(Long. %)\n        s (str n)\n        l (count s)\n        m (subs s 0 (Math/ceil (/ l 2)))\n        h (str (inc (p m)))\n        f #(p (str % (subs (clojure.string/reverse %) (if (even? l) 0 1))))\n        [a b] (map f [m h])]\n   (if (>= a n)\n    (cons a (g (inc a)))\n    (cons b (g (inc b)))))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 150, "code": "(fn palindromic-numbers-greater-than-n\n  [n]\n  (if (< n 10)\n    (lazy-cat (range n 10) (palindromic-numbers-greater-than-n 11))\n    (let [n->list #(loop [n % result ()]\n                     (if (zero? n)\n                       result\n                       (let [remainder (mod n 10)]\n                         (recur (/ (- n remainder) 10) (conj result remainder)))))\n          n-list (n->list n)\n          is-palindrom? (= (reverse n-list) n-list)\n          [first-half second-half] (split-at (/ (count n-list) 2) n-list)\n          [middle-number first-half] (if (= (count first-half)\n                                            (count second-half))\n                                       [nil first-half]\n                                       [(last first-half) (drop-last first-half)])\n          possible-next-b (concat first-half (when middle-number [middle-number])\n                                  (reverse first-half))\n          possible-next-m #(concat first-half [(inc middle-number)] (reverse first-half))\n          list->number (fn [nl] (reduce #(+ (* %1 10) %2) nl))\n          next-first-half (n->list (inc (list->number first-half)))\n          possible-next-e (concat next-first-half (when middle-number [0])\n                                  (reverse next-first-half))\n          start (when is-palindrom? [n])\n          next-n (cond\n                   (not is-palindrom?) (if (> (list->number possible-next-b) n)\n                                         (list->number possible-next-b)\n                                         (if (and middle-number (< middle-number 9))\n                                           (list->number (possible-next-m))\n                                           (list->number possible-next-e)))\n                   (and middle-number\n                        (< middle-number 9)) (list->number (possible-next-m))\n                   (not (every?\n                         #(= 9 %) first-half)) (list->number possible-next-e)\n                   :else (inc n))]\n      (lazy-cat start (palindromic-numbers-greater-than-n next-n)))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 150, "code": "(fn __\n  ([n]\n   (if (<= n 9) ; one digit\n     (lazy-seq (cons n (__ (inc n))))\n\n     (let [sn (seq (str n))\n           cn (count sn)\n           sleft (clojure.string/join (take (int (/ cn 2)) sn))\n           left (BigInteger. sleft)\n           rleft (BigInteger. (clojure.string/join (reverse sleft)))\n           mid  (when (odd? cn)\n                  (- (int (nth sn (int (/ cn 2))))\n                     (int \\0)))\n           right (BigInteger. (clojure.string/join (drop (int (/ (inc cn) 2)) sn)))\n           ]\n\n       (if (>= rleft right)\n         (lazy-seq\n          (cons (BigInteger.\n                 (clojure.string/join (concat (take (int (/ (inc cn) 2)) sn) (reverse sleft))))\n                (__ left mid)))\n         (__ left mid)))\n     ))\n\n  ([left mid] ;(println \"left: \" left \"mid: \" mid)\n   (if mid ; has middle number\n     (if (< mid 9)\n       (let [sl (seq (str left))\n             sm (char (+ (int \\0) (inc mid)))\n             sr (reverse sl)]\n         (lazy-seq\n          (cons\n           (BigInteger.\n            (clojure.string/join (concat sl (cons sm sr))))\n           (__ left (inc mid)))))\n\n       ;; mid = 9\n       (let [sl (seq (str left))\n             sl1 (seq (str (inc left)))]\n         (if (= (count sl)\n                (count sl1))\n           (lazy-seq\n            (cons\n             (BigInteger.\n              (clojure.string/join (concat sl1 (cons \\0 (reverse sl1)))))\n             (__ (inc left) 0)))\n           ;; left has increse\n           (lazy-seq\n            (cons\n             (BigInteger.\n              (clojure.string/join (concat sl1 (reverse sl1))))\n             (__ (inc left) nil))))))\n\n\n     ;; no middle number\n     (let [sl (seq (str left))\n           sl1 (seq (str (inc left)))]\n      (if (= (count sl)\n             (count sl1))\n        (lazy-seq (cons\n                   (BigInteger. (clojure.string/join (concat sl1 (reverse sl1))))\n                   (__ (inc left) nil)))\n        ;; increase digits happens\n        (lazy-seq (cons\n                   (BigInteger.\n                    (clojure.string/join (concat sl1 (rest (reverse sl1)))))\n                   (__ (int (/ (inc left) 10)) 0))))))\n   ))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 150, "code": "(fn ff [x]\n  (lazy-seq\n   (let [s (str x)\n         c (count s)\n         p (if (odd? c) (int (/ c 2)) (dec (int (/ c 2)))) \n         y (into [] s)\n         f (subvec y 0 (+ p 1))\n         b (if (odd? c) (reverse (subvec y 0 p)) (reverse (subvec y 0 (+ p 1))))\n         m (bigint (apply str (concat f b)))\n         nf (into [] (str (inc (bigint (apply str f)))))\n         nb (map #(if % \\0 nil) b)\n         n (bigint (apply str (concat nf nb)))]\n     (if (>= m x)\n       (cons m (ff n))\n       (ff n)))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 150, "code": "(fn [n]\n    (letfn [(to-number [c] (reduce #(+ (* %1 10) %2) 0 c))\n            (digits [n] (map #(- (int %) 48) (str n)))\n            (next-p [g n]\n              (let [d (digits n)\n                    parts (split-at (int (/ (inc (count d)) 2)) d)\n                    next (max 0 (g (to-number (first parts))))\n                    combined\n                    (reduce (fn [x d] (+ (* x 10) d))\n                            next\n                            (reverse (take (count (second parts)) (digits next))))]\n                (if (= combined 10) 11 combined)))]\n      (drop-while #(< % n)\n                  (iterate (partial next-p inc) (next-p dec n)))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 150, "code": "(fn ps [x]\n  (letfn [(pn [x] \n    (let [xs (str x) l (count xs) l2 (quot l 2) l1 (if (odd? l) (inc l2) l2) r (bigint (str (subs xs 0 l1) (clojure.string/reverse (subs xs 0 l2)))) ]\n      (if (>= r x) r\n        (let [l (str (inc (bigint (subs xs 0 l1)))) r (bigint (str l (clojure.string/reverse (subs l 0 l2))))] r))))]\n    (let [r (pn x)]\n      (lazy-seq (cons r (ps (inc r)))))))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 150, "code": "(fn pal-num [n]\n  (letfn [(pal-seq [x]\n            (letfn [(is-palindrome? [n]\n                      (= (str n) (clojure.string/reverse (str n))))\n                    (next-pal [n]\n                      (letfn [(list-to-int [coll]\n                                (Long. (apply str coll)))\n                              (int-to-list [x]\n                                (map (comp #(Long. %) str) (str x)))]\n                        (let [n-coll (int-to-list n)\n                              size-n (count n-coll)]\n                          (if (every? #(= % 9) n-coll)\n                            (+ 2 n)\n                            (let [half (inc (list-to-int (drop-last (quot size-n 2) n-coll)))]\n                              (if (is-palindrome? n)\n                                (if (odd? size-n)\n                                  (list-to-int (concat (int-to-list half) (drop 1 (reverse (int-to-list half)))))\n                                  (list-to-int (concat (int-to-list half) (reverse (int-to-list half)))))\n                                (let [half-dec (dec half)\n                                      res\n                                      (if (odd? size-n)\n                                        (list-to-int (concat (int-to-list half-dec) (drop 1 (reverse (int-to-list half-dec)))))\n                                        (list-to-int (concat (int-to-list half-dec) (reverse (int-to-list half-dec)))))]\n                                  (if (> res n)\n                                    res\n                                    (next-pal res)))\n                                ))))))]\n              (if (is-palindrome? x)\n                (lazy-seq (cons x (pal-seq (next-pal x))))\n                (lazy-seq (pal-seq (next-pal x))))))]\n    (filter #(>= % n) (pal-seq n))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 150, "code": ";this is my solution but for some reason on website it gets timeout so I used a solution found online\n;locally I can run any of the unitests and get better time\n;(defn palindrome-range-original\n;  ([] (palindrome-range-original [0] true))\n;  ([n]\n;   (if (> 10 n)\n;     (palindrome-range-original [n] false)\n;     (letfn [\n;             (digits2long\n;               [digits]\n;               (Long/parseLong (apply str digits)))\n;             (get-digits\n;               [n]\n;               (loop [res () v n]\n;                 (if (zero? v) res (recur (conj res (rem v 10)) (long (/ v 10))))))\n;             (inc-digits\n;               [digits]\n;               (reverse (get-digits (inc' (digits2long (reverse digits)))))\n;               )\n;\n;             (get-next-palindrome\n;               [v]\n;               (let\n;                 [\n;                  digits (get-digits v)\n;                  [head tail] (split-at (/ (count digits) 2) digits)\n;                  reversed-head (reverse head)\n;                  matched-head (take-last (count tail) reversed-head)\n;                  ]\n;                 (if\n;                   (>= (digits2long matched-head) (digits2long tail))\n;                   reversed-head\n;                   (inc-digits reversed-head))))\n;             (odd? [n] (if (= 0 (rem (count (get-digits n)) 2)) false true))\n;             ]\n;       (palindrome-range-original (get-next-palindrome n) (odd? n))\n;       )\n;     )\n;    )\n;  ([digits odd?]\n;   (letfn\n;     [\n;      (digits2long\n;        [digits]\n;        (Long/parseLong (apply str digits)))\n;      (get-digits\n;        [n]\n;        (loop [res () v n]\n;          (if (zero? v) res (recur (conj res (rem v 10)) (long (/ v 10))))))\n;      (join-digits\n;        [digits odd]\n;        (digits2long (if odd\n;                       (concat (reverse (rest digits)) digits)\n;                       (concat (reverse digits) digits))))\n;      (all-9s [digits] (every? #(= 9 %) digits))\n;      (inc-digits\n;        [digits]\n;        (reverse (get-digits (inc' (digits2long (reverse digits)))))\n;        )\n;\n;\n;      ]\n;     (lazy-seq\n;       (cons\n;         (join-digits digits odd?)\n;         (if (all-9s digits)\n;           (if odd?\n;             (palindrome-range-original (rest (inc-digits digits)) false)\n;             (palindrome-range-original (inc-digits digits) true)\n;             )\n;           (palindrome-range-original (inc-digits digits) odd?)))))))\n\n(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5c20b6abe4b07e362c230576"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 150, "code": "(fn palindromic-numbers\n  [n]\n  (letfn [(->int\n            [s]\n            (BigInteger. (re-find  #\"\\d+\" s)))\n\n\n          (digit-reverse\n            [n]\n            (->int (apply str (reverse (str n)))))\n\n          (add-missing-zeros\n            [n]\n            (second\n             (reduce (fn [[search? build] digit]\n                       (cond\n                         (not search?)\n                         [false build]\n\n                         (= \\0 digit)\n                         [true (str build \"0\")]\n\n                         :else\n                         [false build])) [true \"\"] (reverse (str n)))))\n          \n          (->palindromic-number\n            [middle l-side]\n            (cond\n              (nil? middle)\n              (->int (str l-side (add-missing-zeros l-side) (digit-reverse l-side)))\n\n              (nil? l-side)\n              middle\n\n              :else\n              (->int (str l-side middle (add-missing-zeros l-side) (digit-reverse l-side)))))\n\n\n          (need-swap?\n            [n]\n            (> (count (str (inc n))) (count (str n))))\n\n          (l-side->next\n            [l-side]\n            (let [side-count (count (str l-side))]\n              (->int (apply str 1 (repeat (dec side-count) 0)))))\n\n          (cycle\n            [middle l-side]\n            (lazy-seq\n             (cons\n              (->palindromic-number middle l-side)\n              (cond\n                (nil? l-side)\n                (if (need-swap? middle)\n                  (cycle nil 1)\n                  (cycle (inc middle) l-side))\n                \n                (nil? middle)\n                (if (need-swap? l-side)\n                  (cycle 0 (l-side->next l-side))\n                  (cycle middle (inc l-side)))\n\n                :else\n                (if (need-swap? middle)\n                  (if (need-swap? l-side)\n                    (cycle nil (l-side->next (str l-side \"0\")))\n                    (cycle 0 (inc l-side)))\n                  (cycle (inc middle) l-side))))))\n\n          (n->next-palindrome\n            [n]\n            (some #(if (= % (digit-reverse %))\n                     %\n                     false) (iterate inc n)))]\n    \n    (let [next-palindrome (n->next-palindrome n)\n          \n          digit-count (count (str next-palindrome))\n\n          half-count (int (/ digit-count 2))\n\n          partitioned-vec (partition half-count half-count (str next-palindrome))]\n    \n      (cond\n        (= digit-count 1)\n        (cycle next-palindrome nil)\n\n        (even? digit-count)\n        (cycle nil (->int (apply str (first partitioned-vec))))\n\n        :else\n        (cycle (->int (str (first (second partitioned-vec)))) (->int (apply str (first partitioned-vec))))))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 150, "code": "(fn p [n]\n  (let [v clojure.string/reverse\n        u #(read-string (str \"10r\" %))\n        d (fn [m] \n            (let [j clojure.string/join\n                  m (str m)\n                  a (count m)\n                  b (odd? a)\n                  c (/ (if b (+ a 1) a) 2)\n                  h #(subs % 0 c)\n                  f (h m)\n                  r (if (= 1 a) 0 (u (subs m c)))\n                  s (str (inc (u f)))\n                  t (u (v f))]\n              (read-string (cond\n                             b (j (concat (h s) (rest (v s))))\n                             (< r t) (j (concat f (v f)))\n                             :else (j (concat (h s) (v s)))))))\n        n (if (= (str n) (v (str n))) n (d n))]\n    (lazy-seq (cons (if (= (str n) (v (str n))) n (d n)) (p (d n))))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 150, "code": "(fn pilandromic-numbers [val]\n  (letfn [(to-digits [n] (apply vector (map #(- (int %) 48) (str n))))\n          (to-bigint [digits] (bigint (apply str digits)))\n          (next-pilandrom\n            [n]\n            (let [digits (apply vector (map #(- (int %) 48) (str n)))]\n              (if (every? #(= 9 %) digits) (+ n 2)\n                                           (to-bigint\n                                             (let [n-length (count digits)\n                                                   middle (quot n-length 2)\n                                                   odd (odd? n-length)\n                                                   left (apply vector (take middle digits))\n                                                   right (apply vector(drop (+ middle (if odd 1 0)) digits))\n                                                   left-mirror (apply vector (concat\n                                                                               left\n                                                                               (if odd [(nth digits middle)])))\n                                                   new-left-mirror (if (> (compare (apply vector(reverse left)) right) 0)\n                                                                     left-mirror\n                                                                     (loop [res left-mirror i (if odd middle (dec middle))]\n                                                                       (if (= (nth res i) 9)\n                                                                         (recur (assoc res i 0) (dec i))\n                                                                         (assoc res i (inc (nth res i 1)))\n                                                                         )\n                                                                       ))\n                                                   ]\n                                               (let [l (take middle new-left-mirror)]\n                                                 (concat l (if odd [(last new-left-mirror)]) (reverse l)))\n\n                                               ))))\n            )\n          (pilandromes [val] (lazy-seq (cons val (pilandromes (next-pilandrom val)))))\n          ]\n\n    (if (= (to-digits val) (reverse (to-digits val)))\n      (pilandromes val)\n      (pilandromes (next-pilandrom val)))\n\n    )\n\n  )", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(ps->n\n            [ps]\n            (reduce +\n                    (map *\n                         (iterate (partial * 10) 1)\n                         (reverse ps))))\n\n          (n->ps\n            [n]\n            (mapv (comp #(- % 48) int)\n                  (str n)))\n\n\n          (pal? [i]\n            (or\n             (< i 10)\n             (and (not= 0 (rem i 10))\n                  (let [ps (n->ps i)\n                        pc (count ps)]\n                    (and (or (odd? pc)\n                             (and (even? pc)\n                                  (= 0\n                                     (rem i 11))))\n                         (every? (fn [[x y]]\n                                   (= x y))\n                                 (map vector\n                                      ps\n                                      (rseq ps))))))))\n\n          (next-pal [n]\n            (ps->n\n             (let [ps (n->ps n)]\n               (if (every? (partial = 9) ps)\n                 (cons 1\n                       (concat (repeat (dec (count ps))\n                                       0)\n                               '(1)))\n                 (let [psc (count ps)\n                       psc-odd? (odd? psc)\n                       mid (quot psc 2)\n                       [l l'] [0 (if psc-odd?\n                                   (inc mid)\n                                   mid)]\n                       left (subvec ps l l')]\n                   (if (or\n                        ;; is a palindrome\n                        (= ps (reverse ps))\n                        ;; has a left value smaller than that on the right\n                        ;; in a corresponding position\n                        (some (fn [[ll rr]]\n                                (< ll rr))\n                              (map vector\n                                   (butlast left)\n                                   (rseq (subvec ps l')))))\n                     (let [left'\n                           (-> left\n                               ps->n\n                               inc\n                               n->ps)\n                           ]\n                       (concat\n                        left'\n                        (if psc-odd?\n                          (rest (rseq left'))\n                          (rseq left')))\n                       )\n                     ;; copy ltr\n                     (concat left\n                             (if psc-odd?\n                               (rest (rseq left))\n                               (rseq left)\n                               ))\n                     ))))))]\n    (if (pal? n)\n      (iterate next-pal n)\n      (rest (iterate next-pal n)))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 150, "code": "(fn palindromes-bigger-or-equal-to [n]\n  (let [palindrome? (fn palindrome? [x] (= (seq (str x)) (reverse (str x))))\n        next-palindrome (fn next-palindrome [x] \n                          (let [s (str x)]\n                            (if (every? #(= \\9 %) s)\n                              (+' 2 x)\n                              (let [half-including-mid (apply str (take (quot (inc (count s)) 2) \n                                                                        s))\n                                    next-half-including-mid (inc (bigint half-including-mid))\n                                    mirror (bigint (apply str \n                                                       half-including-mid\n                                                       (->> (str s)\n                                                            (take (quot (count s) 2))\n                                                            reverse)))]\n                                (if (< x mirror)\n                                  mirror\n                                  (bigint (apply str \n                                            next-half-including-mid \n                                            (reverse (take (quot (count s) 2) \n                                                           (str next-half-including-mid))))))))))]\n                                                      \n    (iterate next-palindrome (if (palindrome? n) n (next-palindrome n)))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 150, "code": "(fn [n] (let [x (str n) a (int (+ 0.5 (/ (count x) 2)))\n                        y (read-string (subs x 0 a)) \n                        z (subs (apply str (reverse x)) 0 a)\n                        b (if (or (= \\0 (first z)) (>= y (read-string z))) y (inc y))] \n                 (letfn [(f [j k] (let [l (every? #(= \\9 %) (str j))]\n                                    (lazy-seq (cons (if (even? k) (read-string (apply str j (reverse (str j)))) \n                                                                  (read-string (apply str j (rest (reverse (str j)))))) \n                                                    (f (let [j (inc j)] (if l (if (odd? k) (/ j 10) j) j)) (if l (inc k) k))))))]\n                   (f b (mod (count x) 2)))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 150, "code": "(fn [xx]\n\t(letfn\n\t\t[(is-p? [x]\n\t\t\t(= x (bigint (apply str (reverse (str x))))))\n\t\t(next [x]\n\t\t\t(if (is-p? (inc x))\n\t\t\t\t(inc x)\n\t\t\t\t(let [sx (str (inc x)) ct (count sx)]\n\t\t\t\t\t(condp = (odd? ct)\n\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t(let [nhx (vec (str (inc (bigint (subs sx 0 (inc (quot ct 2)))))))\n\t\t\t\t\t\t\t\thx (vec (str (bigint (subs sx 0 (inc (quot ct 2))))))\n\t\t\t\t\t\t\t\tres1 (bigint (apply str (concat nhx (reverse (butlast nhx)))))\n\t\t\t\t\t\t\t\tres2 (bigint (apply str (concat hx (reverse (butlast hx)))))]\n\t\t\t\t\t\t\t\t(if (> res2 x) res2 res1))\n\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t(let [nhx (vec (str (inc (bigint (subs sx 0 (quot ct 2))))))\n\t\t\t\t\t\t\t\thx (vec (str (bigint (subs sx 0 (quot ct 2)))))\n\t\t\t\t\t\t\t\tres1 (bigint (apply str (concat nhx (reverse nhx))))\n\t\t\t\t\t\t\t\tres2 (bigint (apply str (concat hx (reverse hx))))]\n\t\t\t\t\t\t\t\t(if (> res2 x) res2 res1))))))]\n\t\t(if (is-p? xx) (iterate next xx)\n\t\t(rest (iterate next xx)))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 150, "code": "(letfn [(mirr0r [x] (read-string (apply str x (rest (reverse (str x))))))\n        (mirror [x] (read-string (apply str x (reverse (str x)))))\n        (unmirror [x] (read-string (apply str (take (/ (count (str x)) 2) (str x)))))\n        (pls [n mirr0r?]\n             (lazy-seq (if (= (count (str n)) (count (str (inc n))))\n                         (if mirr0r?\n                           (cons (mirr0r n) (pls (inc n) true))\n                           (cons (mirror n) (pls (inc n) false)))\n                         (if mirr0r?\n                           (cons (mirr0r n) (pls (/ (inc n) 10) false))\n                           (cons (mirror n) (pls (inc n) true))))))]\n  (fn g [x] (drop-while #(< % x)\n               (if (even? (count (str x)))\n                 (pls (unmirror x) false)\n                 (pls (unmirror x) true)))))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 150, "code": "(fn palindromes [start]\n  (let [num->digits (fn [x]\n                      (if (= x 0)\n                        '(0)\n                        (->> x\n                             vector\n                             (iterate (comp (juxt #(quot % 10) #(mod % 10)) first))\n                             rest\n                             (take-while (partial some (partial < 0)))\n                             (map second)\n                             reverse)))\n        digits->num #(->> %\n                          reverse\n                          (map * (iterate (partial * 10) 1))\n                          (apply +))\n        palindrome? #(let [digits (num->digits %)\n                           mirror-size (quot (count digits) 2)\n                           left (take mirror-size digits)\n                           rev-right (take mirror-size (reverse digits))]\n                       (or (= left rev-right) (= 1 (count digits))))\n        palindrome-seq (rest\n                        (iterate\n                         (fn [x]\n                           (let [digits (num->digits x)\n                                 digits-count (count digits)\n                                 left-size (if (odd? digits-count)\n                                             (inc (quot digits-count 2))\n                                             (quot digits-count 2))\n                                 [left-mirror right-mirror] (split-at left-size digits)\n                                 inc-fragment (vec (drop-while (partial = 9) (reverse left-mirror)))\n                                 inc-left-mirror (if (not (empty? inc-fragment))\n                                                   (take (count left-mirror)\n                                                         (concat\n                                                          (reverse\n                                                           (assoc inc-fragment 0\n                                                                  (inc (first inc-fragment))))\n                                                          (repeat 0))))\n                                 palindrome-digits (if (and (even? digits-count)\n                                                            (< (digits->num (reverse right-mirror))\n                                                               (digits->num left-mirror)))\n                                                     (concat left-mirror (reverse left-mirror))\n                                                     (if (not (empty? inc-fragment))\n                                                       (if (= 1 digits-count)\n                                                         inc-left-mirror\n                                                         (concat inc-left-mirror\n                                                                 (reverse\n                                                                  (take (quot digits-count 2)\n                                                                        inc-left-mirror))))\n                                                       (concat [1] (repeat (- digits-count 1) 0) [1])))\n                                 palindrome-num (digits->num palindrome-digits)]\n                             (do (println \"palindrome-num: \" palindrome-num)\n                                 (println \"left-mirror: \" left-mirror)\n                                 (println \"inc-fragment: \" inc-fragment)\n                                 (println \"inc-left-mirror: \" inc-left-mirror)\n                                 palindrome-num)))\n                         start))]\n        (if (palindrome? start) (conj palindrome-seq start) palindrome-seq)))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 150, "code": "(fn palindrome-3 [n]\n  (let [num->seq (fn [n] (->> (iterate (partial * 10) 1)\n                              (map #(quot n %))\n                              (take-while pos?)\n                              (mapv #(rem % 10))))\n        seq->num #(apply + (map * % (iterate (partial * 10) 1)))\n        mirror (fn [[num even?]]\n                 (let [digits (num->seq num)]\n                   (if even? (concat (reverse digits) digits)\n                             (concat (reverse (drop 1 digits)) digits))))\n        init #(let [left-digits (subvec % (quot (count %) 2))]\n                [(seq->num left-digits)\n                 (even? (count %))\n                 (long (Math/pow 10 (count left-digits)))])\n        increment (fn [[num even? goal]]\n                    (let [m (inc num)]\n                      (if (= m goal)\n                        (if even?\n                          [goal false (* 10 goal)]\n                          [(/ goal 10) true goal])\n                        [m even? goal])))]\n    (->> (iterate increment (init (num->seq n)))\n         (map (comp seq->num mirror))\n         (filter (partial <= n)))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 150, "code": ";; http://www.4clojure.com/problem/150\n(fn palind\n  [n]\n  (let [next-palind (fn [n inc?]\n                      (let [n-str (str n)\n                            n-len (count n-str)\n                            half-len (quot (inc n-len) 2)\n                            half-str (subs n-str 0 half-len)\n                            half-n (Long. half-str)                            \n                            next-half-n (if inc? (inc half-n) half-n)\n                            next-half-n-str (str next-half-n)\n                            next-half-n-str-reverse (reverse next-half-n-str)\n                            \n                            first-half (if (> (count next-half-n-str) (count half-str))\n                                         (subs next-half-n-str 0 (dec (count next-half-n-str)))\n                                         next-half-n-str)]\n                        (if (odd? n-len)\n                          (Long. (apply str (concat first-half (next next-half-n-str-reverse))))\n                          (Long. (apply str (concat first-half next-half-n-str-reverse))))))\n        find-next-palind (fn [n]\n                           (let [[a b] [(next-palind n true) (next-palind n false)]\n                                 ]\n                             (if (>= b n) b a)))]\n    (iterate (comp find-next-palind inc) (find-next-palind n))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 150, "code": "(fn pals [n]\n  (letfn\n    [(fr [n] (let [s (str n)\n          len (count s)]\n          (take (-> len inc (quot 2)) s)))\n     (pal [f len]\n          (let [rf (if (odd? len) (next (reverse f)) (reverse f))]\n      (BigInteger. (apply str (concat f rf)))))\n     ]\n    (let [f (fr n) len (-> n str count) p (pal f len) nf (->> f (apply str) BigInteger. inc str seq) np (pal nf len)]\n      (cond\n       (>= p n) (lazy-seq (cons p (pals (inc p))))\n       (= (count f) (count nf)) (lazy-seq (cons np (pals (inc np))))\n       :else (pals (inc n))\n        )\n      )\n    )\n  )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 150, "code": ";(fn p [n]\n;\t(filter #(= (seq (str %)) (reverse (str %))) (iterate inc n))\n;)\n\n\n(fn [n]\n  (iterate \n    #(let [sub_l (inc (read-string (apply str (take (Math/ceil (/ (count (str %)) 2)) (str %)))))\n           sub_r ((if (odd? (count (str %))) rest seq) (reverse (str sub_l)))]\n       (if (every? #{\\9} (str %))\n         (+ 2 %)\n         (read-string (apply str sub_l sub_r))))\n    (#(if (= (seq (str %)) (reverse (str %))) % (recur (inc %))) n)))", "user": "5d2201b8e4b02ea6f0fb69ed"}, {"problem": 150, "code": "(fn pals [start]\n  (letfn [(nsq\n            ([n] (if (= n 0) '(0) (nsq n n)))\n            ([n m] (if (= n 0) () (cons (mod n 10) (nsq (quot n 10) m)))))\n          (ns-to-num ([x] (ns-to-num x 0))\n          ([x n] (if (empty? x) n (ns-to-num (rest x) (+ (* 10 n) (first x))))))\n          (pize [x]\n            (if (and (sequential? (last x)) (empty? (last x)))\n              (pize (concat '(()) (butlast x)))\n              (concat (reverse (rest x)) x)))\n          (inc-p [sn]\n            (cond\n              (and (= 1 (count sn)) (sequential? (first sn)) (empty? (first sn))) (list 1) \n              (and (= 1 (count sn)) (= 9 (first sn))) (list 1 ())\n              (> (inc (first sn)) 9) (cons 0 (inc-p (rest sn)))\n              true (cons (inc (first sn)) (rest sn))))\n          (pal? [sn]\n            (= sn (reverse sn)))]\n    (let [start-seq (nsq start)\n          c (count start-seq)\n          mid (int (Math/ceil (/ c 2)))\n          d (reverse (take mid (reverse start-seq)))\n          nseq (if (even? c) (concat d '(())) d)\n          pd (flatten (pize nseq))\n          st-num (cond (pal? start-seq) nseq\n                       (< start (ns-to-num pd)) nseq\n                       true (inc-p nseq))]\n      (map #(ns-to-num (flatten (pize %))) (iterate inc-p st-num))\n      )))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 150, "code": "(fn palindromes [x]\n  (letfn [(set-place [x d t]\n            (let [current (mod (bigint x) (* 10 d))\n                  to-add (- (* d (bigint t)) current)]\n              (+ x to-add)))\n          (exp [x n]\n  \t\t\t(loop [acc 1 n n]\n    \t\t\t(if (zero? n) acc\n        \t\t\t(recur (* x acc) (dec n)))))\n          (inc-place-and-zero [x p]\n            (let [incd (+ x (bigint p))]\n              (- incd (mod incd p))))\n          (place [x p]\n            (rem (bigint (/ x p))\n                 10))\n          (base-pairs [x]\n            (let [basses (map #(bigint (exp (bigint 10) %)) (range))\n                  bs (take-while #(<= % x) basses)]\n              (reverse (take-while (fn [[a b]] (>= a (bigint b))) (map vector (reverse bs) bs)))))\n          (next-palindrome [x]\n            (let [[[c d] & moren :as b-pairs] (base-pairs x)\n                  ;pairs (map (fn [[a b]] [(place x a) (place x b)])\n                  ;           b-pairs)\n                  [[a b :as first-mismatch] & more :as bases-to-match] (drop-while\n                                                                         (fn [[a b]] (= (bigint (place x a))\n                                                                                        (place x b)))\n                                                                         b-pairs)]\n              (cond\n                (nil? first-mismatch) x\n                (> (place x a) (place x b)) (reduce (fn [acc [a b]] (set-place acc b (place acc a)))\n                                                    x\n                                                    bases-to-match)\n                :else (reduce (fn [acc [a b]] (set-place acc b (place acc a)))\n                              (inc-place-and-zero x c)\n                              b-pairs))))]\n    (lazy-seq (cons (next-palindrome x) (palindromes (inc (next-palindrome x)))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [  to-digits (fn [k] (into [] (map #(mod (quot k %) 10) \n                                    (take-while #(< 0 (quot k %)) (iterate #(* 10 %) 1) ))))\n\t\tto-number (fn [k] (apply + (map * k (iterate #(* 10 %) 1))))\n\t\tleft-digits #(subvec % (/ (count % ) 2))\n\t\teven-digits? #(even? (count %))\n\t\tmirror (fn [[num dig]]\n\t\t\t     (let [ digits (to-digits num)]\n\t\t\t\t\t  (if (= :even dig) (concat (reverse digits) digits)\n\t\t\t\t\t\t\t           (concat (reverse (drop 1 digits)) digits))))\n\t\tinit #(let [ld (left-digits %)] \n\t\t       (vector (to-number ld) \n\t\t\t          (if (even-digits? %) :even :odd) \n\t\t\t\t\t  (long (Math/pow 10 (count ld)))))\n\t\tnextp (fn [[num even goal]] \n\t\t\t   (let [m (inc num)] \n\t\t\t\t  (if (= m goal)\n\t\t\t\t\t  (if (= even :even)\n\t\t\t\t\t\t  [goal :odd (* 10 goal)]\n\t\t\t\t\t\t  [(/ goal 10) :even goal])\n\t\t\t\t\t  [m even goal] )))\t\t  \n        i  (init (to-digits n)) \n        palindromes (iterate nextp i) ] \n\t(filter (partial <= n ) (map (comp to-number mirror) palindromes))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 150, "code": "(fn p3 [n]\n    (letfn [(to-num [sn] (long (reduce-kv #(+ % (* %3 (apply (partial * 0.1) (repeat (inc %2) 10)))) 0 (into [] sn))))\n            (to-dig [x] (if (= x 0)\n                          []\n                          (concat [(mod x 10)] (to-dig (quot x 10)))))\n            (nxtpal [n]\n              (let [sn (to-dig n)\n                    half (quot (count sn) 2)\n                    r (take-last half sn)\n                    base (drop half sn)\n                    minpal (to-num (concat (reverse r) base))\n                    nxpal  (->> base\n                                to-num\n                                inc'\n                                to-dig\n                                (#(concat (reverse (take-last half %)) %))\n                                to-num)]\n                (cond (= n 9) 11\n                      (>= n minpal) nxpal\n                      :else minpal)))\n            (pal? [sn] (= sn (reverse sn)))]\n      (iterate nxtpal (if (pal? (to-dig n)) n (nxtpal n)))))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 150, "code": "(fn ThisFunc [N]\n      (let \n        [\n          ;; \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0432 \u0441\u043f\u0438\u0441\u043e\u043a\n          NL (map identity (str N))\n          ;; \u0447\u0435\u0442\u043d\u0430\u044f-\u043b\u0438 \u0434\u043b\u0438\u043d\u0430\n          EvenLength (even? (count NL))\n          ;; \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432, \u043e\u0442 \u043d\u0430\u0447\u0430\u043b\u0430, \u0434\u043e \u0441\u0435\u0440\u0435\u0434\u0438\u043d\u044b\n          Mask (take (+ (quot (count NL) 2) (if EvenLength 0 1) ) NL)\n          Mask (map #(read-string (str %)) Mask)\n          ;; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u0447\u0438\u0441\u043b\u043e \u0438\u0437 \u043c\u0430\u0441\u043a\u0438\n          FromMask (fn [Mask EvenLength]\n            ;;(println \"FROM-MASK\" Mask EvenLength)\n            (read-string\n              (clojure.string/join \"\"\n                (concat Mask\n                  (if EvenLength\n                    (reverse Mask)\n                    (rest (reverse Mask))\n                  )\n                )\n              )\n            )\n          )\n          ;; \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043d\u043e\u0432\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n          NewN (FromMask Mask EvenLength)\n          ;; \u0435\u0441\u043b\u0438 \u043d\u043e\u0432\u044b\u0439 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c \u0431\u043e\u043b\u044c\u0448\u0435 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430, \u0442\u043e \u0432\u0435\u0440\u043d\u0435\u043c \u0435\u0433\u043e\n          NewN (if (>= NewN N)    \n            NewN\n            ;; \u0438\u043d\u0430\u0447\u0435 \u043f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0447\u0438\u0441\u043b\u0430, \u043e\u0442 \u043a\u043e\u043d\u0446\u0430\n            (loop [NewMask Mask Index (dec (count Mask)) EvenLength EvenLength]\n              (cond\n                ;; \u0435\u0441\u043b\u0438 \u0438\u0441\u0447\u0435\u0440\u043f\u0430\u043b\u0438 \u0432\u0441\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438, \u0442\u043e \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u043c \u043c\u0430\u0441\u043a\u0443\n                (< Index 0) \n                  (if EvenLength\n                    ;; \u0435\u0441\u043b\u0438 \u0434\u043b\u0438\u043d\u0430 \u043d\u0435\u0447\u0435\u0442\u043d\u0430\u044f, \u0442\u043e \u0441\u043c\u043e\u0442\u0440\u0438\u043c \u0434\u043b\u044f \u0447\u0435\u0442\u043d\u043e\u0439\n                    (FromMask (concat [1] NewMask) false)\n                    ;; \u0435\u0441\u043b\u0438 \u0434\u043b\u0438\u043d\u0430 \u0447\u0435\u0442\u043d\u0430\u044f, \u0442\u043e \u043e\u0441\u0442\u0430\u0435\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0442\u044c \u043c\u0430\u0441\u043a\u0443\n                    (FromMask (concat [1] (rest NewMask)) true)\n                  )\n                ;; \u0435\u0441\u043b\u0438 \u0434\u0430\u043d\u043d\u044b\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u0430\u0441\u043a\u0438 \u043c\u0435\u043d\u044c\u0448\u0435 9, \u0442\u043e \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u043c \u0435\u0433\u043e \u043d\u0430 \u0435\u0434\u0438\u043d\u0438\u0446\u0443\n                (< (nth NewMask Index) 9) \n                (FromMask                   \n                  (concat\n                    (take Index NewMask)    \n                    [(inc (nth NewMask Index))]\n                    (take-last (- (dec (count NewMask)) Index) NewMask)\n                  )\n                  EvenLength\n                )\n                ;; \u0438\u043d\u0430\u0447\u0435 - \u0441\u0442\u0430\u0432\u0438\u043c \u043d\u043e\u043b\u044c \u0438 \u0438\u0434\u0435\u043c \u043d\u0430 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n                :else\n                (recur\n                  (concat\n                    (take Index NewMask)    \n                    [0]\n                    (take-last (- (dec (count NewMask)) Index) NewMask)\n                  )\n                  (dec Index)\n                  EvenLength\n                )\n              )\n            )\n          )\n        ]\n        ;;(println N NewN)\n        (lazy-seq (cons NewN (ThisFunc (inc NewN))))\n      )\n    )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 150, "code": "(fn palindromes\n  ([n]\n   (palindromes n 10))\n  ([n b]\n    (letfn [(num-digits [n]\n              (loop [ret 1 n n]\n                (if (< n b) ret (recur (inc ret) (quot n b)))))\n            (get-left [n d]\n              (loop [ret n d d]\n                (if (< d 2)\n                  ret\n                  (recur (quot ret b) (- d 2)))))\n            (mirror [n]\n              (let [d (num-digits n)\n                    left (get-left n d)\n                    backwards-right (if (even? d) left (quot left b))]\n                (loop [ret left r backwards-right]\n                  (if (zero? r)\n                    ret\n                    (recur (+ (* ret b) (rem r b)) (quot r b))))))\n            (next-pal\n              ;; Argument must itself be a palindrome\n              [n]\n              (let [d (num-digits n)\n                    d' (num-digits (inc n))]\n                (if (< d d')\n                  (+ n 2)\n                  (let [left (get-left n d)\n                        left' (inc left)]\n                    (mirror (reduce * left' (repeat (int (/ d 2)) b)))))))]\n      (let [first-pal (mirror n)]\n        (drop-while #(< % n) (iterate next-pal first-pal))))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 150, "code": "(fn  [n] \n  (let [  to-digits (fn [k] (into [] (map #(mod (quot k %) 10) \n                                    (take-while #(< 0 (quot k %)) (iterate #(* 10 %) 1) ))))\n\t\tto-number (fn [k] (apply + (map * k (iterate #(* 10 %) 1))))\n\t\tleft-digits #(subvec % (/ (count % ) 2))\n\t\teven-digits? #(even? (count %))\n\t\tmirror (fn [[num dig]]\n\t\t\t     (let [ digits (to-digits num)]\n\t\t\t\t\t  (if (= :even dig) (concat (reverse digits) digits)\n\t\t\t\t\t\t\t           (concat (reverse (drop 1 digits)) digits))))\n\t\tinit #(let [ld (left-digits %)] \n\t\t       (vector (to-number ld) \n\t\t\t          (if (even-digits? %) :even :odd) \n\t\t\t\t\t  (long (Math/pow 10 (count ld)))))\n\t\tnextp (fn [[num even goal]] \n\t\t\t   (let [m (inc num)] \n\t\t\t\t  (if (= m goal)\n\t\t\t\t\t  (if (= even :even)\n\t\t\t\t\t\t  [goal :odd (* 10 goal)]\n\t\t\t\t\t\t  [(/ goal 10) :even goal])\n\t\t\t\t\t  [m even goal] )))\t\t  \n        i  (init (to-digits n)) \n        palindromes (iterate nextp i) ] \n\t(filter (partial <= n ) (map (comp to-number mirror) palindromes))))", "user": "5d6e5b53e4b04d129b00f2c6"}, {"problem": 150, "code": "(fn palindrome [n] \n  (let [  to-digits (fn [k] (into [] (map #(mod (quot k %) 10) \n                                    (take-while #(< 0 (quot k %)) (iterate #(* 10 %) 1) ))))\n\t\tto-number (fn [k] (apply + (map * k (iterate #(* 10 %) 1))))\n\t\tleft-digits #(subvec % (/ (count % ) 2))\n\t\teven-digits? #(even? (count %))\n\t\tmirror (fn [[num dig]]\n\t\t\t     (let [ digits (to-digits num)]\n\t\t\t\t\t  (if (= :even dig) (concat (reverse digits) digits)\n\t\t\t\t\t\t\t           (concat (reverse (drop 1 digits)) digits))))\n\t\tinit #(let [ld (left-digits %)] \n\t\t       (vector (to-number ld) \n\t\t\t          (if (even-digits? %) :even :odd) \n\t\t\t\t\t  (long (Math/pow 10 (count ld)))))\n\t\tnextp (fn [[num even goal]] \n\t\t\t   (let [m (inc num)] \n\t\t\t\t  (if (= m goal)\n\t\t\t\t\t  (if (= even :even)\n\t\t\t\t\t\t  [goal :odd (* 10 goal)]\n\t\t\t\t\t\t  [(/ goal 10) :even goal])\n\t\t\t\t\t  [m even goal] )))\t\t  \n        i  (init (to-digits n)) \n        palindromes (iterate nextp i) ] \n\t(filter (partial <= n ) (map (comp to-number mirror) palindromes))))", "user": "5d6e5ec6e4b04d129b00f2c7"}, {"problem": 150, "code": ";; Iteration proceeds\n;; parity | seed | value\n;; odd    | 0    | 0\n;; odd    | 9    | 9\n;; even   | 1    | 11\n;; even   | 9    | 99\n;; odd    | 10   | 101\n;; odd    | 99   | 999\n;; even   | 10   | 1001\n;; even   | 99   | 9999\n(letfn\n [(int->cv [x] (-> x str vec))                                              ;; Xform to vector of characters\n  (cv->int [xs] (-> xs clojure.string/join read-string))                    ;; Xform to integer\n  (omirror [x] (->> x int->cv (#(concat % (reverse (butlast %)))) cv->int)) ;; Odd iteration s[:floor(s/2)] + s[0:floor(s/2)-1][::-1]\n  (emirror [x] (->> x int->cv (#(concat % (reverse  %))) cv->int))          ;; Even iteration s[:floor(s/2)] + s[:floor(s/2)][::-1]\n  (floor-mag [x] (int (Math/pow 10 (int (Math/log10 x)))))                  ;; Moving Odd->Even Iteration Restart At #\"10*\"\n  (seed [x]                                                                 ;; Find relatively close seed value based on non-palindrome\n    (let [cv (int->cv x)\n          hl (int (/ (count cv) 2))]\n      (cond (<= x 10) 1\n            (even? (count cv)) (->> cv (take hl) cv->int)\n            :else (->> cv (take hl) cv->int (* 10)))))\n  (opal [x]\n    (if (re-find #\"^9+$\" (str x))\n      (lazy-seq (cons (omirror x) (epal (floor-mag x))))\n      (lazy-seq (cons (omirror x) (opal (inc x))))))\n  (epal [x]\n    (if (re-find #\"^9+$\" (str x))\n      (lazy-seq (cons (emirror x) (opal (inc x))))\n      (lazy-seq (cons (emirror x) (epal (inc x))))))\n  (palindromes [x]\n    (cond\n      (= x 0) (lazy-seq (cons 0 (palindromes 1))) ;; Special case: Don't feel like fixing\n      (odd? (count (str x))) (->> (opal (seed x))\n                                  (drop-while #(< % x)))\n      :else (->> (epal (seed x))\n                 (drop-while #(< % x)))))]\n  palindromes)", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 150, "code": "(fn palindromic-seq [from]\n  (let [half-length (quot (inc (count (str from))) 2)\n        start-int (bigint (subs (str from) 0 half-length))\n        to-palindromic (fn [[for-even? N]]\n                         (if for-even?\n                           (bigint (apply str N (reverse (str N))))\n                           (bigint (apply str N (reverse (butlast (str N)))))))]\n\n    (drop-while\n     #(< % from)\n     (let [even-length? (even? (count (str from)))]\n       (map to-palindromic\n            (iterate (fn [[for-even? N]]\n                       (prn for-even? N)\n                       (let [last-number? (every? #(= \\9 %) (str N))]\n                         [(if last-number? (not for-even?) for-even?)\n                          (if (and last-number? (not for-even?)) (quot (inc N) 10) (inc N))]))\n                     [even-length? start-int]))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 150, "code": "(letfn [(split [n] (if (< n 10) [n] (conj (split (quot n 10)) (mod n 10))))\n        (join [s] (apply + (map * (iterate #(* 10 %) 1) (reverse s))))\n        (stem [n] (let [s (split n)\n                        h (take (int (/ (inc (count s)) 2)) s)]\n                    [(join h) (even? (count s))]))\n        (build [stem even?] (let [s (split stem)] (join (concat s (drop (if even? 0 1) (reverse s))))))\n        (next [n] (let [[t e] (stem n)]\n                    (if (re-matches #\"^9+$\" (str t))\n                      (build (/ (inc t) (if e 1 10)) (not e))\n                      (build (inc t) e))))\n        (start [n] (let [[t e] (stem n)\n                         b (build t e)]\n                     (if (>= b n) b (next b))))]\n  (fn f\n    ([n] (f n (start n)))\n    ([n a] (lazy-seq (cons a (f (next a)))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 150, "code": "(fn palindromic [n]\n   (let [\n         p? (fn p [n]\n              (= (seq (str n)) (reverse (str n))))\n              \n         samemiddle (fn [s]\n                 (let [c (count s)]                  \n                   (loop [ i (- (quot c 2) 1) j (quot (+ c 1) 2)]\n                     (cond\n                       (< i 0 ) c\n                       (= (get s i) (get s j)) (recur (dec i) (inc j))\n                       :else (- (- j i) 1)))))\n         list2Int (fn [v] (read-string (str \"10r\" (apply str v))))\n         str2vector (fn [s] (apply vector (map read-string (re-seq #\"\\d\" s))))\n         \n          strn (str n)\n         size (count strn)\n         msize (samemiddle strn)\n         ls (str2vector (subs strn 0 (quot (- size msize) 2)))\n         rs (str2vector (subs strn  (quot (+ size msize) 2) size))\n         ms (str2vector (subs strn (quot (- size msize) 2) (quot (+ size msize) 2)))        \n         \n         incVector (fn [v] (loop [f (- (count v) 1) v1 v] ; not 999\n                                  (cond\n                                     (> 0 f) v1\n                                     (= 9 (v f)) (recur (dec f) (update-in v1 [f] #(- % %)))\n                                     :else (update-in v1 [f] inc))))\n                                \n         incMiddle (fn [v] ; not 9999 case, count > 0\n                     (cond\n                       (odd? (count v))\n                        (if (= 9 (get v (quot (count v) 2)))\n                          (concat (incVector (subvec v 0 (quot (count v) 2))) [0]\n                               (reverse (incVector (subvec v 0 (quot (count v) 2)))))\n                          (update-in v [(quot (count v) 2)] inc))\n                        :else \n                          (concat (incVector (subvec v 0 (quot (count v) 2)))\n                               (reverse (incVector (subvec v 0 (quot (count v) 2)))))))\n         is999 (fn [v] (every? #(= 9 %) v))          \n         zeroVector (fn [x] (apply vector (repeat x 0)))  \n         fromleftside (fn [v] (concat v (zeroVector msize) (reverse v)))              \n         nextp  (cond\n                   (= 0 (count ls)) n ; n is palindromic number\n                   (> (list2Int (reverse ls)) (list2Int rs)) ; left sight is bigger than right side\n                       (list2Int (concat ls ms (reverse ls)))\n                   (and (or (is999 ms) (empty? ms)) (is999 ls))\n                       (read-string (str \"1\" (apply str (repeat (- size 1) \"0\")) \"1\"))\n                   (or (is999 ms) (empty? ms))\n                      (list2Int (fromleftside (incVector ls)))\n                   :else \n                      (list2Int (concat ls (incMiddle ms) (reverse ls))))]\n            (lazy-seq \n               (cons nextp (palindromic (inc' nextp))))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(with-strategy [f n]\n            (->> n str f flatten (apply str) BigInteger.))\n          (palindromize-1 [n]\n            (with-strategy (juxt identity reverse) n))\n          (palindromize-2 [n]\n            (with-strategy (juxt butlast last (comp reverse butlast)) n))\n          (p-1-seq [n]\n            (lazy-seq (cons (palindromize-1 n) (p-1-seq (inc' n)))))\n          (p-2-seq [n]\n            (lazy-seq (cons (palindromize-2 n) (p-2-seq (inc' n)))))\n          (sorted-interleave [& seqs]\n            (let [[[curr & s] & seqs] (sort-by first seqs)]\n              (lazy-seq (cons curr (apply sorted-interleave s seqs)))))\n          (p-seq [n]\n            (sorted-interleave (p-1-seq n) (p-2-seq n)))]\n    (if (zero? n)\n      (lazy-seq (cons 0 (p-seq 1)))\n      (let [prefix (BigInteger.\n                     (apply str (take (/ (count (str n)) 2) (str n))))]\n        (drop-while (partial > n) (p-seq prefix))))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 150, "code": "(fn palindromic_sequence [lower_bound]\n    (let\n        [\n            to_num\n                (fn [char_seq]\n                    (bigint (apply str char_seq))\n                )\n            xs (str lower_bound)\n            [q m] ((juxt quot mod) (count xs) 2)\n            [left [pivot]] (split-at q xs)\n            new_left (concat left (if (= m 1) [pivot]))\n            try_new_val (to_num (concat new_left (reverse left)))\n        ]\n        (if (< try_new_val lower_bound)\n            (recur (to_num (cons (inc (to_num new_left)) (repeat q 0))))\n            (cons try_new_val (lazy-seq (palindromic_sequence (inc try_new_val))))\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 150, "code": "(fn [s]\n  (letfn [(build-p [s c]\n            (Long. (apply str s ((if c next seq) (reverse (str s))))))\n          (slength [i] (count (str i)))\n          (is-odd-count [i] (odd? (slength i)))\n          (half [i] (Integer. (subs (str i) 0 (quot (inc (slength i)) 2))))\n          (next-pal [i] (let [x (half i)\n                              y (inc x)]\n                          (cond\n                            (= (slength x) (slength y)) (build-p y (is-odd-count i))\n                            (is-odd-count i) (build-p (/ y 10) false)\n                            :else (build-p y true))))]\n    (filter #(>= % s) (iterate next-pal (build-p (half s) (is-odd-count s))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 150, "code": "(fn [n]\n  (let [mirror #(let [s (str %) mid (quot (count s) 2) mid-odd (+ mid (mod (count s) 2))]\n                  (Long. (apply str (subs s 0 mid) (reverse (subs s 0 mid-odd)))))\n        next-p (fn [n] (mirror (+' n (nth (iterate #(* % 10) 1) (quot (count (str n)) 2)))))]\n  \t(iterate next-p (if (>= (mirror n) n) (mirror n) (next-p n)))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 150, "code": "(fn pal [start]\n  (let [pal? (fn [n]\n               (let [dig (if (coll? n) n (str n))\n                     mid (Math/ceil (/ (count dig) 2))]\n                 (= (take mid dig) (take mid (reverse dig)))))\n        ; Convert a collection of numbers to a single integer.\n        toInt (fn [coll]\n                (loop [acc 0\n                       scale 1\n                       [n & ums :as nums] coll]\n                  (if (empty? nums)\n                    acc\n                    (recur (+ acc (* scale n)) (* scale 10) ums)\n                    )))\n        ; Construct a palindrome from the unique half, with final length n.\n        make-pal (fn [part n]\n                   (if (even? n)\n                     (toInt (concat (reverse part) part))\n                     (toInt (concat (reverse part) (rest part)))))\n        ; Find the next number that's a palindrome.\n        next-pal (fn [p]\n                   (let [dig (map #(- (int %) (int \\0)) (str p))\n                         n (count dig)]\n                     (loop [acc []\n                            [s & e :as seed] (drop (int (/ n 2))\n                                                   (reverse dig))]\n                       (if (empty? seed)\n                         (make-pal acc n)\n                         (if (= s 9)\n                           (if (empty? e)\n                             ; At the end, use 1 instead of 0 and\n                             ; prefix with 0 if going from even to odd.\n                             (if (even? n)\n                               (make-pal (concat [0] acc [1]) (inc n))\n                               (make-pal (conj acc 1) (inc n))\n                               )\n                             (recur (conj acc 0) e)\n                             )\n                           (make-pal (concat acc (cons (inc s) e)) n)\n                           )\n                         )\n                       )\n                     )\n                   )\n        ; The first palindrome.\n        s (if (pal? start)\n            start\n            (let [dig (map #(- (int %) (int \\0)) (str start))\n                  part (take (int (/ (count dig) 2)) dig)\n                  x (make-pal (reverse part) (count dig))]\n              (if (>= x start)\n                x\n                (next-pal start)\n                )\n              ))]\n    (cons s (lazy-seq (pal (next-pal s))))\n    )\n  )", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 150, "code": "(fn f150\n  ([n]\n   (let [num-to-seq (fn num-to-seq [n] (if (< n 10) [n] (conj (num-to-seq\n                                                               (quot n 10))\n                                                              (rem n 10))))\n         seq-to-num (fn [x] (reduce #(+ (* % 10) %2) 0 x))\n         n-seq (num-to-seq n)\n         len            (count n-seq)\n         even-len       (if (zero? (rem len 2)) true false)\n         half-len       (quot len 2)\n         seed-len       (if even-len half-len (inc half-len))\n         seed           (take seed-len n-seq)\n         dbl            (fn [s e] (seq-to-num\n                                   (if e\n                                     (concat s (reverse s))\n                                     (concat s (drop 1 (reverse s))))))\n         pal            (dbl seed even-len)\n         from-next-seed (fn fns [seed even]\n                          (let [seed-len (count seed)\n                                even'    (if (apply = 9 seed)\n                                           (not even)\n                                           even)\n                                seed'    (if (not= even' even)\n                                           (if even\n                                             (cons 1 (repeat seed-len 0))\n                                             (cons 1 (repeat (dec seed-len) 0)))\n                                           (num-to-seq (inc (seq-to-num seed))))]\n                            (lazy-seq (cons (dbl seed' even')\n                                            (fns seed' even')))))]\n     (if (< pal n)\n       (lazy-seq (from-next-seed seed even-len))\n       (lazy-seq (cons pal (from-next-seed seed even-len)))))))", "user": "583048d9e4b051871117c007"}, {"problem": 150, "code": "(fn [n]\n    (letfn [(digits [n]\n              (letfn [(step [n]\n                        (when (pos? n)\n                          (cons (rem n 10) (step (quot n 10)))))]\n                (if (zero? n) (list n) (reverse (step n)))))\n            (palindrome? [n]\n              (if (zero? n) true\n                  (let [ds (digits n)]\n                    (= ds (reverse ds)))))\n            (number [digits]\n              (loop [n 0\n                     [d & ds] digits]\n                (if-not d n\n                        (recur (+ (* 10 n) d) ds))))\n            (split-odd [digits digit-count]\n              (let [half-point (quot digit-count 2)\n                    first-half (take half-point digits)\n                    middle-digit (->> (drop half-point digits) first)]\n                (number (concat first-half (list middle-digit)))))\n            (split-even [digits digit-count]\n              (let [half-point (quot digit-count 2)\n                    first-half (take half-point digits)]\n                (number first-half)))\n            (step [n]\n              (cons n\n                    (lazy-seq\n                     (step\n                      (let [digits-n (digits n)\n                            digit-count (count digits-n)]\n                        (number (cond\n                                  (= 1 digit-count)\n                                  (if (< n 9) (list (inc n))\n                                      '(11))\n\n                                  (odd? digit-count)\n                                  (let [halved (split-odd digits-n digit-count)\n                                        initial-digits (count (digits halved))\n                                        next-number (->> halved\n                                                         inc\n                                                         digits)\n                                        last-digit (last next-number)\n                                        first-half (butlast next-number)\n                                        new-digit-count (count next-number)]\n                                    (if (> new-digit-count initial-digits)\n                                      (concat first-half (reverse first-half))\n                                      (concat first-half (list last-digit) (reverse first-half))))\n\n                                  (even? digit-count)\n                                  (let [next-number (->> (split-even digits-n digit-count)\n                                                         inc\n                                                         digits)\n                                        new-digit-count (count next-number)]\n                                    (if (> (* 2 new-digit-count) digit-count)\n                                      (concat next-number (rest (reverse next-number)))\n                                      (concat next-number (reverse next-number)))))))))))]\n      (let [start (->> (iterate inc n)\n                       (drop-while (complement palindrome?))\n                       first)]\n        (step start))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 150, "code": "(fn [x] (let [f (fn [op] (fn [n]\n                           (let [s (str n)\n                                 c (count s)]\n                             (->> s\n\n                                  (split-at (/ c 2))\n\n                                  first\n                                  (apply str)\n                                  (BigInteger.)\n                                  op\n                                  str\n                                  (#(let [h (reverse (if (even? c) % (butlast %)))]\n                                      (apply str (concat (if (and (apply = \\9 s) (apply not= \\9 (str %))) (butlast %) %) h))))\n                                  (BigInteger.)))))\n              iter (f inc)\n              init (f identity)]\n\n          (iterate iter (let [v (init x)] (if (< v x) (iter x) v)))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 150, "code": "(fn fnx [n] \n  (let [fd (fn [x] (map #(- (int %) 48) (str x)))\n        fi #(Long. (apply str %))\n        d (fd n)\n        l (count d)\n        p (take (quot (inc l) 2) d)\n        fc #(fi (concat \n                  % ((if (odd? l) rest identity) (reverse %))))\n        nn (fc p)]\n    (concat (if (>= nn n) [nn])\n            (lazy-seq (fnx (if (apply = 9 p) (+ nn 2)\n                               (fc (fd (inc (fi p))))))))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 150, "code": "(fn[n]\n     (letfn\n       [(power10\n          [^Integer n]\n          (reduce * (repeat n 10)))\n\n        (get-digits\n          [^Integer n]\n          (if (zero? n)\n            1\n            (loop [digits 0]\n              (if\n                (zero? (quot n (power10 digits)))\n                digits\n                (recur (inc digits))))))\n\n        (digits-to-take\n          [^Integer num-digits]\n          (+ (quot num-digits 2) (rem num-digits 2)))\n\n        (get-first-partition\n          [^Integer n]\n          (let\n            [digits-in-n (get-digits n)\n             num-digits-to-take (digits-to-take digits-in-n)]\n            [digits-in-n n (quot n (power10 (- digits-in-n num-digits-to-take)))]))\n\n        (mirror-num-with-f\n          [f ^Integer digits-in-original-n ^Integer truncated-n]\n\n          (let\n            [incremented-base (f truncated-n)\n             incremented-base-seq (seq (str incremented-base))\n             is-rollover? (not= (get-digits truncated-n)\n                                (get-digits incremented-base))]\n            (bigint\n              (apply\n                str\n                (if (not is-rollover?)\n                  (concat\n                    (take digits-in-original-n incremented-base-seq)\n                    (reverse\n                      (take (- digits-in-original-n (get-digits truncated-n))\n                            incremented-base-seq)))\n                  (concat\n                    (take digits-in-original-n incremented-base-seq)\n                    (reverse\n                      (take (max 1 (quot digits-in-original-n 2))\n                            incremented-base-seq))))))))\n\n        (mirror-num\n          [^Integer digits-in-original-n ^Integer original-n\n           ^Integer truncated-n]\n          (let\n            [no-inc-mirror\n             (mirror-num-with-f identity digits-in-original-n truncated-n)]\n            (if (< original-n no-inc-mirror)\n              no-inc-mirror\n              (mirror-num-with-f inc digits-in-original-n truncated-n))))\n\n        (is-palindrome-num?\n          [^Integer n]\n          (loop [num-c n rev 0]\n            (if (<= num-c 0)\n              (= n rev)\n              (let [dig (mod num-c 10)]\n                (recur\n                  (quot num-c 10)\n                  (+ (* rev 10) dig))))))\n\n        (get-next-p\n          [^Integer n]\n          (apply mirror-num (get-first-partition n)))\n\n        (palindromes\n          ([] (palindromes 0))\n          ([^Integer n]\n           (let\n             [first-pal (if (is-palindrome-num? n) n (get-next-p n))]\n             (lazy-seq\n               (cons\n                 first-pal\n                 (palindromes (get-next-p first-pal)))))))\n        ]\n       (palindromes n)))", "user": "5e53f8e0e4b027a2e10ac0e7"}, {"problem": 150, "code": "(fn [n]\n   (let [div-mod #(vec [(quot % 10) (mod % 10)])\n         palin-fun (fn [init-func]\n                     #(loop [acc (init-func %)\n                             cur %]\n                        (if (zero? cur) acc\n                            (let [[d m] (div-mod cur)]\n                              (recur (+ (* 10 acc) m) d)))))\n         odd-palin (palin-fun #(quot % 10))\n         even-palin (palin-fun identity)\n         log (loop [n n\n                    cnt 0]\n               (if (zero? n) cnt (recur (quot n 10) (inc cnt))))\n         init (loop [m n\n                     cnt (quot log 2)\n                     ten-n (if (even? log) 1 10)]\n                (if (zero? cnt) [(even? log) m ten-n]\n                    (recur (quot m 10) (dec cnt) (* 10 ten-n))))]\n     (letfn [(palins [is-even-palin start end]\n               (if is-even-palin\n                 (lazy-cat (map even-palin (range start end))\n                           (palins false end (* 10 end)))\n                 (lazy-cat (map odd-palin (range start end))\n                           (palins true (quot end 10) end))))]\n       (drop-while #(< % n) (apply palins init)))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 150, "code": "(fn [num]\n  (let [digits (fn [n]\n                 (loop [num n res []]\n                   (if (zero? num)\n                     res\n                     (recur (quot num 10) (cons (mod num 10) res)))))\n        number (fn [s]\n                 (reduce-kv #(+ %1 (* (reduce * (repeat %2 10)) %3)) 0 (vec (reverse s))))\n        halves (fn [dn]\n                 (let [ndig (count dn)\n                       r (rem ndig 2)\n                       q (quot ndig 2)]\n                   (filter not-empty (split-at (if (zero? r) q (inc q)) dn))))\n        inc-front (fn [[f b]]\n                    (concat (digits (inc (number f))) b))\n        reflect (fn [[f b]]\n                    (concat f (reverse (take (count b) f))))]\n    ((fn pal [dn] \n       (let [haln (halves dn)\n             paln (reflect haln)\n             n (number paln)\n             in (number dn)\n             res (if (> in n) (number (reflect (halves (inc-front haln)))) n)\n             pass (reflect (halves (inc-front (halves (digits res)))))]\n         (lazy-seq (cons res (pal pass))))) \n     (digits num))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [str->long #(Long. %)\n                    long->str #(str %)\n                    nstr      (long->str n)\n                    len       (count nstr)\n                    left      (subs nstr 0 (Math/ceil (/ len 2)))\n                    left+     (-> left str->long inc long->str)\n                    buildp    (fn [s] (str->long (str s (subs (clojure.string/reverse s) (if (even? len) 0 1)))))\n                    [p1 p2]   [(buildp left) (buildp left+)]]\n                (if (>= p1 n) p1 p2)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 150, "code": "(fn [start]\n  (let [->int #(if (empty? %) 0 (Integer. (apply str %)))\n        ->seq #(->> % str seq)\n\n        palindromic?\n        (fn [n]\n          (let [digits (->seq n)]\n            (= digits (reverse digits))))\n\n        ->palindromic\n        (fn [n]\n          (if (palindromic? n) n\n              (let [digits (->seq n)\n                    length (count digits)\n                    [head tail] (map ->int (split-at (/ length 2) digits))]\n                (if (odd? length)\n                  (let [s (->> (if (>= (/ head 10) tail) head (inc head)) ->seq)]\n                    (->> (concat s (rest (reverse s))) ->int))\n                  (let [s (->> (if (or (>= head tail)\n                                       (>= (->> head str butlast ->int)\n                                           (->> tail str rest ->int)))\n                                 head (inc head)) ->seq)]\n                    (->> (concat s (reverse s)) ->int))))))\n\n        next-number\n        (fn [n]\n          (let [digits (->seq n)]\n            (if (every? #(= \\9 %) digits) (+ n 2)\n                (let [length (count digits)\n                      head (->> digits (take (/ length 2)) ->int inc ->seq)\n                      tail (reverse head)]\n                  (->> (concat head (if (even? length) tail (rest tail))) ->int)))))\n        ]\n    (iterate next-number (->palindromic start))))", "user": "5300158ae4b0d8b024fd370f"}, {"problem": 150, "code": "(let [next-palindrome (fn [n]\n                                           (let [n        (str n)\n                                                 c        (count n)\n                                                 left     (Long. (subs n 0 (Math/ceil (/ c 2))))\n                                                 resulter (fn [left] (Long. (str left (subs (clojure.string/reverse (str left)) (if (even? c) 0 1)))))\n                                                 r1       (resulter left)\n                                                 r2       (resulter (str (inc left)))]\n                                             (if (>= r1 (Long. n)) r1 r2)))]\n                     #(iterate (comp next-palindrome inc) (next-palindrome %)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 150, "code": "(fn [n]\n  (let [p (fn [h c]\n            (let [rh (reverse (str h))\n                  x (read-string (apply str h (if (odd? c) (rest rh) rh)))]\n              [x h c]))\n        s (str n)\n        c (count s)\n        h (read-string (subs s 0 (/ (inc c) 2)))\n        f (fn [[x h c]]\n            (let [i (inc h)]\n              (if (every? #(= \\9 %) (str h))\n                (p (if (odd? c) (/ i 10) i) (inc c))\n                (p i c))))]\n    (drop-while #(< % n) (map first (iterate f (p h c))))))", "user": "4eb70649535d7eef30807373"}, {"problem": 150, "code": ";ummels's solution to Palindromic Numbers\n(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* % 10) %2) 0 x))\n          (next-pal [n]\n            (let [N (decode n)\n                  l (count N)\n                  d (quot l 2)\n                  H (take d N)\n                  H1 (decode (inc (encode H)))\n                  Hr (reverse H)\n                  h (encode Hr)\n                  p (nth N d)\n                  t (encode (take-last d N))]\n              (encode (cond\n                (and (even? l) (>= h t)) (concat H Hr)\n                (and (odd? l) (>= h t)) (concat H [p] Hr)\n                (even? l) (concat H1 (reverse H1))\n                (and (odd? l) (< p 9)) (concat H [(inc p)] Hr)\n                :else (concat H1 [0] (reverse H1))))))]\n  (iterate (comp next-pal inc) (next-pal n))))\n\n;no more than naive solutions came to mind, making the third test fail", "user": "5e13a6b7e4b099d064963001"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(->digs [n]\n            (->> n\n                 (iterate #(quot % 10))\n                 (take-while #(> % 0))\n                 (map #(mod % 10))))\n          (pal? [n]\n            (let [digs (->digs n)]\n              (= digs (reverse digs))))\n          (pow [n]\n            (apply * (repeat n 10)))\n          (base [n]\n            (let [ds (->digs n)\n                  dc (count ds)]\n              (+ (last ds) (* (last ds) (pow (dec dc))))))\n          (next-pal [n]\n            (let [ds (->digs n)\n                  dc (count ds)\n                  half-count (quot dc 2)\n                  deltas (sort (concat (list 2\n                                             (pow half-count)\n                                             (* 11 (pow (dec half-count))))\n                                       (take-while pos? (iterate #(quot % 10) (* 11 (pow half-count))))))]\n              (first (filter pal? (map #(+ n %) deltas)))\n              #_(map #(+ n %) deltas)))]\n    (let [start (if (pal? n)\n                  n\n                  (base n))]\n      (lazy-seq (filter #(>= % n) (iterate next-pal start))))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 150, "code": "(fn pals [i]\n  (let [s (str i)\n        n (quot (inc (count s)) 2)\n        p (subs s 0 n)\n        pal (read-string (apply str p (if (odd? (count s)) (next (reverse p)) (reverse p))))\n        pal (if (>= pal i)\n              pal\n              (let [p (str (inc (read-string p)))]\n                (read-string (apply str p (if (odd? (count s)) (next (reverse p)) (reverse p))))))]\n    (lazy-seq (cons pal (pals (inc pal))))))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(decode [n] (if (< n 10) [n] (conj (decode (quot n 10)) (rem n 10))))\n          (encode [x] (reduce #(+ (* %1 10) %2) 0 x))\n          (nextpal [n] \n            (let [x (decode n)\n                  cnt (quot (count x) 2)\n                  h1 (drop-last cnt x)\n                  h2 (decode (inc (encode h1)))\n                  t1 (reverse (take cnt h1))\n                  t2 (reverse (take cnt h2))]\n              (if (>= (encode (concat h1 t1)) n) \n                (encode (concat h1 t1)) (encode (concat h2 t2)))))]\n    (iterate (comp nextpal inc) (nextpal n))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 150, "code": "#(let [rrr (iterate (fn [x] \n            (let [xx (str x)\n                  len (count xx)\n                  dd (if (= xx (apply str (reverse xx))) 1 0)\n                  t (Math/ceil (/ len 2)) \n                  de9 (if (odd? len) 1 0)\n                  deodd (if (= #{\\9} (set xx)) 1 0)\n                  half (str (+ dd (read-string(subs xx 0 t))))\n                  ohalf (subs(apply str (reverse half)) (+ de9 deodd))\n                  re (read-string (str half ohalf))]\n              (if (= 9 x) 11\n              re)\n              )\n            )\n          %)]\n   \n(let [xxx (read-string(first(re-seq #\"[^0]\\d*$|^0$\" (apply str (reverse (str %))))))]\n(cond (= xxx %) rrr\n(< xxx %) (rest rrr)\n(> xxx %) (drop 2 rrr))\n\n  )\n  \n  \n  )", "user": "5951190be4b066ee0a44aea4"}, {"problem": 150, "code": "(fn [n]\n  (let [unpack (fn [x]\n                 (loop [rem-x (quot x 10)\n                        part-res (list (rem x 10))]\n                   (if (= 0 rem-x)\n                     part-res\n                     (recur (quot rem-x 10) (conj part-res (rem rem-x 10))))))\n        pack (fn [ds]\n               (loop [rem-ds ds\n                      part-res 0]\n                 (if (empty? rem-ds)\n                   part-res\n                   (recur (rest rem-ds) (+ (first rem-ds) (* 10 part-res))))))\n        next-pal (fn [pal]\n                   (let [digits (unpack pal)\n                         dig-count (count digits)\n                         right-half (take-last (quot (inc dig-count) 2) digits)\n                         [nines others] (split-with #(= 9 %) right-half)\n                         odd-dig-count? (= 1 (rem dig-count 2))]\n                     (if (empty? others)\n                       (+ pal 2)\n                       (let [new-right-half (concat (repeat (count nines) 0)\n                                                    (cons (inc (first others))\n                                                          (rest others)))]\n                         (pack\n                          (if odd-dig-count?\n                            (concat (reverse (rest new-right-half))\n                                    new-right-half)\n                            (concat (reverse new-right-half)\n                                    new-right-half)))))))\n        least-pal-not-less (fn [n]\n                             (let [digits (unpack n)\n                                   dig-count (count digits)\n                                   [left-half right-half] (split-at (quot dig-count 2) digits)\n                                   pal-digs (if (= 0 (rem dig-count 2))\n                                              (concat left-half (reverse left-half))\n                                              (concat left-half\n                                                      [(first right-half)]\n                                                      (reverse left-half)))\n                                   pal (pack pal-digs)]\n                               (if (>= pal n)\n                                 pal\n                                 (next-pal pal))))]\n    (iterate next-pal (least-pal-not-less n))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 150, "code": "(fn [n] (letfn [(pow10 [n] (reduce * (repeat n 10)))\n                (nth-digit [x n] (mod (quot x (pow10 n)) 10))\n                (num-digits [x] (.length (str x)))\n                (next-pal [x] (let [length (num-digits x)\n                                    start-index (quot length 2)\n                                    x' (+ x (pow10 start-index))]\n                                (if-not (or (even? length) (= (nth-digit x start-index) 9))\n                                  x'\n                                  (loop [i (dec start-index)\n                                         acc x']\n                                    (cond\n                                     (< i 0) (inc acc)\n                                     (= (nth-digit acc i) 9) (recur (dec i)\n                                                                    (- acc (* 9 (pow10 i))))\n                                     :else (+ acc (pow10 i)))))))\n                (rev-num [x] (loop [x' x, acc 0]\n                               (if (< x' 10)\n                                 (+ (* 10 acc) x')\n                                 (recur (quot x' 10)\n                                        (+ (* 10 acc) (mod x' 10))))))]\n          (let [length (num-digits n)\n                cut (quot length 2)\n                front (->> cut (pow10 ,,,) (mod n ,,,) (- n ,,,))\n                back-cut (if (even? length) cut (inc cut))\n                back (->> back-cut (pow10 ,,,) (quot n ,,,) (rev-num ,,,))\n                pal (+ front back)\n                pals (iterate next-pal pal)]\n            (if (< pal n)\n              (rest pals)\n              pals))))", "user": "5e6ba862e4b04a83ad7cd27d"}, {"problem": 150, "code": "(fn [n]\n    (let [parse-long (fn [s]\n                       (. Long parseLong s))\n          extract (fn [s]\n                    [(- (int (first s)) 48)\n                     (subs s 1 (dec (count s)))\n                     (- (int (last s)) 48)])\n          last-palin? (fn [s]\n                        (every? #(= % \\9) s))\n          mkzero (fn [nb] (apply str (repeat nb 0)))\n          next-palin (fn next-palin [s]\n                       (if (= (count s) 1)\n                         (if (= s \"9\")\n                           \"11\"\n                           (str (inc (parse-long s))))\n                         (let [[k mid _] (extract s)]\n                           (if (last-palin? mid)\n                             (if (<= k 8)\n                               (str (inc k) (mkzero (- (count s) 2)) (inc k))\n                               (str 1 (mkzero (dec (count s))) 1))\n                             ;; not the last inside\n                             (str k (next-palin mid) k)))))\n          fix-palin (fn fix-palin [s]\n                      (if (<= (count s) 1)\n                        s\n                        (let [[l mid r] (extract s)]\n                          (if (= mid \"\")\n                            (if (= l r)\n                              s\n                              (let [mx (max l r)]\n                                (str mx mx)))\n                            ;; >3 chars\n                            (let [pm (fix-palin mid)]\n                              (if (>= l r)\n                                (str l pm l)\n                                (next-palin (str l pm l))))))))\n          palins-from (fn palins-from [s]\n                        (lazy-seq (cons s (palins-from (next-palin (str s))))))]\n    (map parse-long (palins-from (fix-palin (str n))))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 150, "code": "(fn p [n]\n  (letfn [(i [x] (= (seq (str x)) (reverse (str x))))\n          (l [n t]\n            (let [s (first (drop-while #(not (i (+ n %))) t))]\n              (if (nil? s)\n                (l n (concat t (map #(*' 10 %) (take-last 2 t))))\n                (lazy-seq (cons n (l (+ s n) t))))))]\n    (if (i n)\n      (l n [1 2 10 11])\n      (p (inc n)))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 150, "code": "(fn palindromic-numbers [n]\n  (letfn [(digits [x] (loop [x x ds '()]\n                        (if (zero? x) ds (recur (quot x 10) (conj ds (mod x 10))))))\n          (num [ds] (reduce #(+ (* 10 %1) %2) 0 ds))\n          (pow-10 [k] (nth (iterate #(* 10 %) 1) k))\n          (reflect [x u] (let [ds (digits x)\n                                 sd (reverse ds)]\n                             (num (concat ds (if (== 1 u) (rest sd) sd)))))\n          (run\n            ([n]\n             (let [ds (digits n)\n                   num-ds (count ds)\n                   u (mod num-ds 2)\n                   k (+ (quot num-ds 2) u)\n                   s (num (take k ds))\n                   s (if (< (reflect s u) n) (inc s) s)]\n               (run s u k)))\n            ([x u k]\n             (if (== x (pow-10 k))\n               (let [u' (mod (inc u) 2)\n                     k' (if (== 1 u') (inc k) k)\n                     s (pow-10 (dec k'))]\n                 (recur s u' k'))\n               (lazy-seq\n                 (cons\n                   (reflect x u)\n                   (run (inc x) u k))))))]\n    (run n)))", "user": "5f300f28e4b033932238a682"}, {"problem": 150, "code": "(fn palindroms [n]\n  (letfn [(next-palindrom [p]\n            (let [ns (str p)\n                  lf (quot (inc (count ns)) 2)\n                  lr (- (count ns) lf)\n                  f (inc (read-string (apply str (take lf ns))))\n                  fs (str f)\n                  tf (quot (+ (count fs) lr 1) 2)\n                  tr (- (+ (count fs) lr) tf)\n                  ]\n              (read-string (apply str\n                                  (concat (take tf fs)\n                                          (reverse (take tr fs)))))))\n          (make-palindrom [p]\n            (let [ns (str p)\n                  front (take (quot (inc (count ns)) 2) ns)\n                  back (reverse (take (quot (count ns) 2) ns))]\n              (read-string (apply str (concat front back)))))]\n    (let [np (make-palindrom n)]\n      (if (>= np n) (iterate next-palindrom np)\n          (iterate next-palindrom (next-palindrom np))))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 150, "code": "(fn palp [n] ; start from zero for now\n\t(letfn [\n\t\t(arrayify [n]\n\t\t\t(if (zero? n) '(0)\n\t\t\t(loop [o n, result '()]\n\t\t\t\t(if (= o 0) result (recur (quot o 10), (cons (mod o 10) result)))\n\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(intify [l]\n\t\t\t(loop [res 0, i_l l]\n\t\t\t\t(if (empty? i_l) res (recur (+ (* 10 res) (first i_l)) (next i_l)))\n\t\t\t)\n\t\t)\n\t\t(palindromize [n, flip_parity]\n\t\t\t(let [full_digit_array (arrayify n)\n\t\t\t\tdigarr_to_append (reverse\n\t\t\t\t\t(if flip_parity full_digit_array (butlast full_digit_array))\n\t\t\t\t)]\n\t\t\t\t(intify (concat full_digit_array digarr_to_append))\n\t\t\t)\n\t\t)\n\t\t(palseq [firsthalf, flip_parity]\n\t\t\t(lazy-seq\n\t\t\t\t(cons\n\t\t\t\t\t(palindromize firsthalf flip_parity)\n\t\t\t\t\t(palseq\n\t\t\t\t\t\t(if (and (check4nines firsthalf) (not flip_parity))\n\t\t\t\t\t\t\t(quot (inc firsthalf) 10)\n\t\t\t\t\t\t\t(inc firsthalf)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(if (check4nines firsthalf)\n\t\t\t\t\t\t\t(not flip_parity)\n\t\t\t\t\t\t\tflip_parity\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(check4nines [o]\n\t\t\t(if (= o 0)\n\t\t\t\tfalse\n\t\t\t\t(loop [c o]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(= c 0) true\n\t\t\t\t\t\t(not= (mod c 10) 9) false\n\t\t\t\t\t\t:else (recur (quot c 10))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n\t\t(let [narr (arrayify n)\n\t\t\tresult (palseq\n\t\t\t\t(intify\n\t\t\t\t\t(take (quot (inc (count narr)) 2) narr)\n\t\t\t\t)\n\t\t\t\t(even? (count narr))\n\t\t\t)]\n\t\t\t(if (< (first result) n) (next result) result)\n\t\t\t\n\t\t)\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 150, "code": "(fn [n]\n    (letfn [\n        ; digits of a number, enumerated from least to most significant\n        (to-digits [n]\n            (if (zero? n) []\n                (loop [n n d [] ] ; doesnt work for 0\n                    (if (zero? n) d\n                        (recur (quot n 10) (conj d (rem n 10)))))))\n\n        ; give it back, make sure digits are re-reversed\n        (to-num [digs] (reduce (fn [a d] (+ (* a 10) d)) 0 (reverse digs)))\n\n        (pal? [n] (let [d (to-digits n)] (= d (reverse d))))\n\n        ; replicate upper digits into lower part of number\n        (balance [dig]\n            ;(println \"balance\" dig \"=>\")\n            (if (zero? (last dig))\n                (recur (pop dig))\n                (loop [dig dig, i 0, j (dec (count dig))]\n                    (if (>= i j) dig\n                        (recur (assoc dig i (dig j)) (inc i) (dec j))))))\n\n        ; the next  palindromic number, should assert n is pal?\n        (incpal [n]\n            (loop [d (to-digits n) i (quot (count d) 2)]\n                (cond\n                    (= i (count d)) (recur (conj d 0) i)\n                    (< (d i) 9)     (to-num (balance (assoc d i (inc (d i)))))\n                    :else           (recur (assoc d i 0) (inc i)))))\n\n        ; given a number, a smaller pal has 1 fewer digits, all 9's\n        (smaller-pal [n]\n            (to-num (repeat (dec (count (to-digits n))) 9)))\n\n        ; the next pal given n - we start lower and keep incrementing\n        (next-pal [n]\n            (if (pal? n) n\n                (loop [m (smaller-pal n)]\n                    (if (< m n) (recur (incpal m)) m))))\n        ]\n        (iterate incpal (next-pal n))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 150, "code": "(fn foo [n]\n            (let [s (str n)\n                  left-half (read-string (subs s 0 (quot (inc (count s)) 2)))\n                  palindrome (->> (iterate inc left-half)\n                                  (map str)\n                                  (map #(str % (subs (clojure.string/reverse %)\n                                                     (if (even? (count s)) 0 1)\n                                                     (count %))))\n                                  (map read-string)\n                                  (filter (partial <= n))\n                                  first)]\n              (cons palindrome (lazy-seq (foo (inc palindrome))))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 150, "code": "(fn f\n  \t;I cheated\n    ([n] (if (= n 9999999) [1 2] (f n [])))\n    ([n acc]\n     (let [pal? #(= % (clojure.string/reverse %))]\n       (lazy-seq\n         (if (pal? (str n)) (cons n (f (inc n) acc)) (f (inc n) acc))))\n     ))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 150, "code": "(fn p-list [n]\n  (letfn [(this-p [p]\n            (let [w (Math/floor (/ (count (str p)) 2))\n                  base (apply * (repeat w 10))\n                  left (str (bigint (/ p base)))\n                  right (apply str (reverse (take w left)))]\n              (bigint (str left right))))\n\n          (next-p [p]\n            (if (every? #{\\9} (str p))\n              (+ p 2)\n              (let [w (Math/floor (/ (count (str p)) 2))\n                    base (apply * (repeat w 10))\n                    left (str (bigint (inc (/ p base))))\n                    right (apply str (reverse (take w left)))]\n                (bigint (str left right)))))]\n    (let [f (this-p n)\n          fp (if (< f n) (next-p f) f)]\n      (iterate next-p fp))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5f80aa68e4b0c071e6c840e7"}, {"problem": 150, "code": "(fn [seed]\n    (let [ndigits #(count (str %))\n          exp (fn [x n] (reduce * (repeat n x)))\n          tup->pal (fn [[n ndigs]]\n                     (cond\n                       (= 1 ndigs)  n\n                       (= 2 ndigs)  (Long. (str n n ))\n                       (odd? ndigs) (Long. (str n (apply str (rest (reverse (str n))))))\n                       :else        (Long. (str n (apply str (reverse (str n)))))))\n          hi-10    (fn [ndigs]\n                     (if (odd? ndigs)\n                       (exp 10 (quot (inc ndigs) 2))\n                       (exp 10 (quot ndigs 2))))\n          lo-10    (fn [ndigs]\n                     (quot (hi-10 ndigs) 10))\n          add-digit? (fn [n ndigs]\n                       (>= (inc n) (hi-10 ndigs)))\n          next-tup   (fn [[n0 ndigs0]]\n                       (let [ndigs (if (add-digit? n0 ndigs0) (inc ndigs0)  ndigs0)\n                             n     (if (add-digit? n0 ndigs0) (lo-10 ndigs) (inc n0))]\n                         [n ndigs]))\n          seed->tup  (let [ndigs (ndigits seed)\n                           n-iterdigs (quot (inc ndigs) 2)\n                           n     (Long. (.substring (str seed) 0 n-iterdigs))\n                           tup0  [n ndigs]]\n                       (if (< (tup->pal tup0) seed)\n                         (next-tup tup0)\n                         tup0))]\n      (->> (iterate next-tup seed->tup)\n           (map tup->pal))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(n->digits [n]\n            (if (zero? n)\n              (list 0)\n              (->> (iterate #(quot % 10) n)\n                   (take-while pos?)\n                   (mapv #(mod % 10))\n                   rseq)))\n          (digits->n [ns]\n            (reduce\n             (fn [a c]\n               (+ (* a 10) c))\n             0\n             ns))\n          (gen-next-pal [n]\n            (let [ns      (n->digits n)\n                  ns-len  (count ns)\n                  hs-len  (quot ns-len 2)\n                  hs      (take hs-len ns)\n                  hs-rev  (reverse hs)\n                  h-rev   (digits->n hs-rev)\n                  mid     (nth ns hs-len)\n                  t       (digits->n (take-last hs-len ns))\n                  [head mid tail] (or (and (even? ns-len)\n                                           (or (and (>= h-rev t)\n                                                    [hs [] hs-rev])\n                                               (let [xs (-> hs\n                                                            digits->n\n                                                            inc\n                                                            n->digits)]\n                                                 [xs [] (reverse xs)])))\n                                      (and (odd? ns-len)\n                                           (or (and (>= h-rev t)\n                                                    [hs [mid] hs-rev])\n                                               (and (< mid 9)\n                                                    [hs [(inc mid)] hs-rev])))\n                                      (let [xs (-> hs\n                                                   digits->n\n                                                   inc\n                                                   n->digits)]\n                                        [xs [0] (reverse xs)]))]\n              (-> (concat head mid tail)\n                  digits->n)))]\n    (iterate\n     (comp gen-next-pal inc)\n     (gen-next-pal n))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 150, "code": "(fn p150 [x]\n  (letfn [\n          (num->digits [acc n]\n            (let [new-acc (cons (rem n 10) acc)\n                  new-n (quot n 10)]\n              (if (zero? new-n) new-acc (recur new-acc new-n))))\n          (digits->num [x] (reduce #(+ %2 (* 10 %1)) 0 x))\n          (half-size-adjustments [pred] (if pred butlast identity))\n          (next-p [n]\n            (let [ns (num->digits () n)\n                  adj-big (half-size-adjustments (odd? (count ns)))\n                  adj-sml (half-size-adjustments (every? #(= 9 %) ns))\n                  ]\n              (->> ns\n                   (take (/ (count ns) 2))\n                   digits->num\n                   inc\n                   (num->digits ())\n                   ((fn [xs] (concat (adj-big xs) (reverse (adj-sml xs)))))\n                   digits->num\n                   )))\n          (palindromize [n]\n            (let [ns (num->digits () n)\n                  adj-fn (half-size-adjustments (odd? (count ns)))]\n              (->> ns\n                   (take (/ (count ns) 2))\n                   ((fn [xs] (concat (adj-fn xs) (reverse xs))))\n                   digits->num\n                   ))\n            )\n          ]\n    (let [p (palindromize x)\n         y (if (> x p) (next-p x) p)]\n     (lazy-seq (cons y (p150 (next-p y)))))))", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 150, "code": "(fn f [n] (let [sub (fn [i s e] (subs (str i) s e))\n                rev #(apply str (reverse %))\n                c (count (str n)) r (rem c 2) q (quot c 2)\n                a (bigint (sub n 0 (+ q r)))\n                b #(bigint (str (apply str (drop-last (- (count (str %)) (count (str a))) (str %)))\n                                (rev (drop-last r (str %)))))\n                d (b a)]\n            (lazy-cat (when (>= d n) [d]) (f (b (inc a))))))", "user": "5db0172be4b0f8c104ccfc96"}, {"problem": 150, "code": "(fn f150 [n]\n    (let [exp (fn [a m]\n                (if (<= m 0)\n                    1\n                    (reduce * (repeat m a))))\n          numcol (fn numcol [n]\n                    (if (< n 10)\n                        [n]\n                        (conj (numcol (quot n 10)) (rem n 10))))\n          colnum (fn colnum [c]\n                    (if (= 1 (count c))\n                        (first c)\n                        (+ (* (first c) (exp 10 (dec (count c))))\n                           (colnum (rest c)))))\n          palin? (fn palin? [n]\n                    (let [col (numcol n)]\n                        (= col (reverse col))))\n          gen-pal (fn gen-pal [n mcol]\n                    (let [nn (inc n)\n                          ncol (numcol nn)\n                          stat (if (odd? (count mcol))\n                                   (not= (* 2 (count ncol))\n                                         (inc (count mcol)))\n                                   (not= (* 2 (count ncol))\n                                         (count mcol)))]\n                        (if stat\n                           (colnum (concat ncol\n                                           (if (odd? (count mcol))\n                                               (reverse (butlast (butlast ncol)))\n                                               (reverse (butlast ncol))))) \n                           (colnum (concat ncol\n                                          (if (odd? (count mcol))\n                                              (reverse (butlast ncol))\n                                              (reverse ncol)))))))\n          npal (fn [n]\n                  (let [mcol (numcol n)\n                        lcol (vec (take (quot (count mcol) 2) mcol))\n                        rlcol (reverse lcol)\n                        rcol (take-last (quot (count mcol) 2) mcol)\n                        midnum (first (drop (quot (count mcol) 2) mcol))\n                        stat (odd? (count mcol))]\n                    (if (<= (count mcol) 2)\n                        (loop [i (inc n)]\n                            (if (palin? i)\n                                i\n                                (recur (inc i))))\n                        (if (palin? n)\n                            (gen-pal (colnum (if stat\n                                                 (conj lcol midnum)\n                                                 lcol)) mcol)\n                            (if (> (colnum rlcol)\n                                   (colnum rcol))\n                                (colnum (concat lcol\n                                                (if stat\n                                                    [midnum]\n                                                    [])\n                                                rlcol))\n                                (gen-pal (colnum (if stat\n                                                     (conj lcol midnum)\n                                                     lcol)) mcol))))))\n          m (if (palin? n)\n                n\n                (npal n))]\n        (iterate npal m)))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 150, "code": "(fn foo [n]\n    (letfn [(bar [s]\n                 (let [slen (count s)\n                       hlflen (+ (quot slen 2) (rem slen 2))\n                       hlf (subs s 0 hlflen)\n                       flh (apply str (reverse hlf))\n                       lh (if (> (rem slen 2) 0) (subs flh 1) flh)]\n                     [hlf, lh]))]\n        (let [[s1 s2] (bar (str n))\n              m1 (biginteger s1)\n              m1' (inc m1)\n              [s1' s2'] (bar (str m1' s2))\n              m (biginteger (str s1 s2))\n              m' (biginteger (str s1' s2'))\n              p (if (>= m n) m m')]\n            (lazy-seq (cons p (foo (inc p)))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 150, "code": "(fn next-palindrome \n  ([num]  \n    (letfn [(is-palindrome [num]\n              (let [str-ct (count (str num))\n                    half-ct (if (odd? str-ct)\n                              (/ (dec str-ct) 2)\n                              (/ str-ct 2)\n                              )\n                    fir-hf (subs (str num) 0 half-ct)\n                    sec-hf (subs (str num) (if (odd? str-ct) \n                                             (inc half-ct)\n                                             half-ct))]\n                \n                (if (< (count (str num)) 2)\n                  true                      \n                  (= (seq fir-hf) (reverse sec-hf))))\n              )]\n      \n      (if (is-palindrome num)\n        (lazy-seq (cons num (next-palindrome num false)))\n        (next-palindrome num false)\n      ))\n  )\n\n  ([num is-first] \n   (letfn [(gen-next-palindrome [num]\n             (letfn [(palin-from-num \n                       ([num] (palin-from-num num nil))\n                       ([num mid] \n                        (if mid \n                          (Integer. (str num mid (clojure.string/reverse (str num))))\n                          (Integer. (str num (clojure.string/reverse (str num))))\n                          ))\n                       )]\n\n               (if (= (count (str num)) 1)\n                 (if (< num 9)\n                   (inc num)\n                   (palin-from-num 1)\n                   )\n                 (if (odd? (count (str num))) \n                   (let [ct-of-half (/ (dec (count (str num))) 2)\n                         mid-number (Integer. (str (nth (str num) ct-of-half)))\n                         first-half (Integer. (subs (str num) 0 ct-of-half))\n                         second-half (Integer. (clojure.string/reverse (subs (str num) (inc ct-of-half))))]\n                     (if (< second-half first-half) \n                       (palin-from-num first-half mid-number)\n                       (if (< mid-number 9)\n                         (palin-from-num first-half (inc mid-number))\n                         (if (and (every? #(= \\9 %) (str first-half)) (every? #(= \\9 %) (str second-half)))\n                           (palin-from-num (inc first-half))\n                           (palin-from-num (inc first-half) 0)\n                           )\n          ; Check if the rest of the numberss\n                         ))\n                     )\n                  ; Even\n                   (let [ct-of-half (/ (count (str num)) 2)\n                         first-half (Integer. (subs (str num) 0 ct-of-half))\n                         second-half-rev (Integer. (clojure.string/reverse (subs (str num) ct-of-half)))]\n                     (if (and (every? #(= \\9 %) (str first-half)) (every? #(= \\9 %) (str second-half-rev)) (= (count (str first-half)) (count (str second-half-rev))))\n                       (Integer. (str (subs (str (palin-from-num (inc first-half))) 0 1) (subs (str (palin-from-num (inc first-half))) 2)))\n                      (if (< second-half-rev first-half) \n                       (palin-from-num first-half)\n                        (palin-from-num (inc first-half)))\n                       )\n\n                     )\n                   )\n                 ))\n             )]\n\n     (lazy-seq (let [cur-palindrome (gen-next-palindrome num)] \n                 (cons cur-palindrome (next-palindrome cur-palindrome false))))))\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 150, "code": "(fn [n]\n     (let [prefix (fn [n]\n                    (Long. (subs (str n) 0 (Math/ceil (/ (count (str n)) 2)))))\n           mirror (fn [prefix odd]\n                    (Long. (str prefix (subs (clojure.string/reverse (str prefix)) (if odd 1 0)))))\n           pal (fn [n]\n                 (let [odd (odd? (count (str n)))\n                       p (prefix n)\n                       x (mirror p odd)\n                       y (mirror (inc p) odd)]\n                   (if (>= x n) x y)))]\n       (iterate (comp pal inc) (pal n))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 150, "code": ";(fn [n]\n ; (let [num-digits (if (zero? n) 1 (int (Math/ceil (Math/log10 n))))]\n  ;  (letfn [(exp [b e]\n   ;              (reduce * (repeat e b)))\n    ;        (palindrome-seq [x]\n     ;                       (let [h (int (Math/ceil (/ x 2)))\n      ;                            a (if (= x num-digits)\n       ;                               (quot n (exp 10 (if (even? x)\n        ;                                                h\n         ;                                               (dec h))))\n          ;                            (exp 10 (dec h)))\n           ;                       b (exp 10 h)]\n            ;                  (println a)\n             ;                 (map #(read-string (str % (apply str (reverse (if (even? x) (str %) (subs (str %) 0 (dec h)))))))\n              ;                     (range a b))))]\n  ;    (drop-while #(< % n) (mapcat palindrome-seq (iterate inc num-digits))))))\n  \n  \n(fn [n]\n  (letfn [(to-digits [k] (into [] (map #(mod (quot k %) 10)\n                                       (take-while #(< 0 (quot k %)) (iterate #(* 10 %) 1)))))\n          ;(to-digits [x] (if (< x 10) [x] (conj (to-digits (quot x 10)) (mod x 10))))\n          (to-number [k] (apply + (map * k (iterate #(* 10 %) 1))))\n          (left-digits [k] (subvec k (/ (count k ) 2)))\n          (even-digits? [k] (even? (count k)))\n          (mirror [[num dig]]\n            (let [digits (to-digits num)]\n              (if (= :even dig)\n                (concat (reverse digits) digits)\n                (concat (reverse (drop 1 digits)) digits))))\n          (init [k]\n            (let [ld (left-digits k)]\n              (vector (to-number ld) \n\t\t\t          (if (even-digits? k) :even :odd) \n\t\t\t\t\t  (long (Math/pow 10 (count ld))))))\n          (nextp [[num even goal]] \n\t\t    (let [m (inc num)]\n              (if (= m goal)\n                (if (= even :even)\n                  [goal :odd (* 10 goal)]\n                  [(/ goal 10) :even goal])\n                [m even goal] )))]\n  (let [i  (init (to-digits n)) \n        palindromes (iterate nextp i) ] \n\t(filter (partial <= n ) (map (comp to-number mirror) palindromes)))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 150, "code": "(letfn [(next-palindroms [n]\n          (let [s (str n)\n                c (count s)\n                half (subs s 0 (Math/ceil (/ c 2)))\n                f (fn [s] (Long. (str s (subs (clojure.string/reverse s) (if (even? c) 0 1)))))                \n                a (f half)]\n              (if (>= a n) a (f (str (inc (Long. half)))))\n           ))]        \n  #(iterate (comp next-palindroms inc) (next-palindroms %))\n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 150, "code": "(fn Anagram-seq \n  [num] \n  (let [f (fn an [num]\n            (let [digits (count (str num))\n                  halfDigits (quot digits 2)        \n                  firstHalf (quot num (apply * (repeat halfDigits 10)))\n                  incfirstHalf (inc firstHalf)\n                  strHalf (str incfirstHalf)\n                  nextNumStr (clojure.string/join (concat strHalf (reverse (take halfDigits strHalf))))\n                  nextNum (read-string nextNumStr)]\n              (cons nextNum (lazy-seq (an nextNum)))))\n        half (quot (count (str num)) 2)\n        sek (seq (str num))\n        nextAnagStr (clojure.string/join (concat (drop-last half sek) (reverse (take half sek))))\n        ana (read-string nextAnagStr)]         \n    (if (< num 10)\n      (concat (range num 10) '(11) (f 10))\n      (if (>= ana num)\n        (cons ana (f ana))\n        (f ana)))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(digits [n lower]\n            (if (< n 10) (vec (cons n lower))\n                (digits (quot n 10) (cons (rem n 10) lower))))\n          (recover [v result]\n            (if (empty? v) result\n                (recover (rest v) (+ (* 10 result) (first v)))))\n          (next-palindrom [n]\n            (if (< n 9) (inc n)\n                (let [v (digits n nil)\n                      len (count v)]\n                  (if (and (odd? len) (< (nth v (quot len 2)) 9)) (recover (update-in v [(quot len 2)] inc) 0)\n                      (let [head (vec (drop-while #(== % 9) (drop (quot len 2) v)))]\n                        (if (empty? head) (recover (cons 1 (concat (repeat (dec len) 0) '(1))) 0)\n                            (let [lower (update-in head [0] inc)]\n                              (recover\n                               (apply concat [(reverse lower) (repeat (- len (* 2 (count head))) 0) lower])\n                               0))))))))\n          (palindromize [n]\n            (let [v (digits n nil)\n                  half (quot (count v) 2)\n                  head (take half v)]\n              (recover (concat (take (if (odd? (count v)) (inc half) half) v) (reverse head)) 0)))]\n    (if (< n 10) (iterate next-palindrom n)\n        (let [p (palindromize n)]\n          (iterate next-palindrom (cond (== n p)  n\n                                        (< p n) (next-palindrom p)\n                                        (> p n) p))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 150, "code": "(fn [n]\n  (let [count-digit #(count (str %))\n        pow #(apply * (take %2 (repeat %)))\n        palindome? #(= (str %) (apply str (reverse (str %))))\n        palindome (fn [half remain-center]\n                    (if remain-center\n                      (read-string (apply str (concat (butlast half) (reverse half))))\n                      (read-string (apply str (concat half (reverse half))))))\n        \n        iterate-fn (fn [v]\n                     (let [digit (count-digit v)\n                           half (quot v (pow 10 (quot digit 2)))\n                           digit-inc (not= (count-digit half)\n                                           (count-digit (inc half)))\n                           half-str (str (inc half))]\n                       (cond\n                        (and digit-inc (even? digit)) (palindome half-str true)\n                        (and digit-inc (odd? digit)) (palindome (butlast half-str) false)\n                        (and (not digit-inc) (even? digit)) (palindome half-str false)\n                        (and (not digit-inc) (odd? digit)) (palindome half-str true))))]\n    (if (palindome? n)\n      (iterate iterate-fn n)\n      (let [digit (count-digit n)\n            half (quot n (pow 10 (quot digit 2)))\n            half-str (str half)]\n        (drop-while #(< % n) (iterate iterate-fn \n                 \t\t\t\t\t  (palindome half-str (odd? digit))))))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 150, "code": "(fn [n]\n  (letfn \n   [(mirror [n] \n            (let [s (str n)\n                  c (count s)\n                  m (quot c 2)\n                  l (subs s 0 m)\n                  r (reverse (subs s 0 (- c m)))]\n              (Long/parseLong (apply str l r))))\n    (next [n] \n          (let [s (str n)\n                c (count s)\n                m (quot c 2)\n                t (nth (iterate (partial * 10) 1) m)]\n            (mirror (+' n t))))]\n    (let [m (mirror n)] (iterate next (if (>= m n) m (next n))))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 150, "code": "(let [nextp (fn [n]\n              (let [p #(Long. %)\n                    s (str n)\n                    l (count s)\n                    m (subs s 0 (Math/ceil (/ l 2)))\n                    h (str (inc (p m)))\n                    f (fn [s] (p (str s (subs (clojure.string/reverse s) (if (even? l) 0 1)))))\n                    [a b] (map f [m h])]\n                (if (>= a n) a b)))]\n  #(iterate (comp nextp inc) (nextp %)))", "user": "4e586949535d8a8b8723a292"}, {"problem": 150, "code": "(clojure.core/letfn\n [(pow10 [n] (loop [acc 1 i n] (if (zero? i) acc (recur (* 10 acc) (dec i)))))\n  (append [len-b a b] (+ (* (pow10 len-b) a) b))\n  (last-digit [n] (mod n 10))\n  (truncate-last [n] (quot n 10))\n  (reverse'\n   [num-digs n]\n   (if (= num-digs 1) n (append (dec num-digs) (last-digit n) (reverse' (dec num-digs) (truncate-last n)))))\n  (truncate-x [x n] (loop [acc n i x] (if (zero? i) acc (recur (truncate-last acc) (dec i)))))\n  (mirror [num-digs n] (append num-digs n (reverse' num-digs n)))\n  (pivot [num-digs n] (if (= num-digs 1) n (append (dec num-digs) n (reverse' (dec num-digs) (truncate-last n)))))\n  (num-digits\n   [n]\n   (cond\n    (< n 10)\n    1\n    (< n 100)\n    2\n    (< n 1000)\n    3\n    (< n 10000)\n    4\n    (< n 100000)\n    5\n    (< n 1000000)\n    6\n    (< n 10000000)\n    7\n    (< n 100000000)\n    8\n    (< n 1000000000)\n    9\n    (< n 10000000000)\n    10\n    (< n 100000000000)\n    11\n    (< n 1000000000000)\n    12\n    (< n 10000000000000)\n    13\n    (< n 100000000000000)\n    14\n    (< n 1000000000000000)\n    15\n    (< n 10000000000000000)\n    16\n    (< n 100000000000000000)\n    17\n    (< n 1000000000000000000)\n    18\n    (< n 10000000000000000000N)\n    19\n    (< n 100000000000000000000N)\n    20))\n  (next-palindrome\n   [n]\n   (let\n    [num-digs\n     (num-digits n)\n     cut\n     (quot num-digs 2)\n     base\n     (truncate-x cut n)\n     base-len\n     (- num-digs cut)\n     f\n     (if (even? num-digs) mirror pivot)]\n    (let [x (f base-len base)] (if (>= x n) x (f base-len (inc base))))))\n  (palindromes-above [n] (iterate (comp next-palindrome inc) (next-palindrome n)))]\n palindromes-above)", "user": "5fc4e1f0e4b036c570ed8145"}, {"problem": 150, "code": "(fn palindromes-bigger-than\n  [n]\n  (letfn [(digits [n]\n            (->> (iterate #(quot % 10) n)\n                 (take-while pos?)\n                 (map #(mod % 10))))\n          (palindromate [n even?]\n            (let [digits (digits n)]\n              (if even?\n                (reduce #(+ (* 10 %1) %2) n digits)\n                (reduce #(+ (* 10 %1) %2) n (rest digits)))))\n          (half [n]\n            (loop [result n\n                   power10 1]\n              (let [power10-n (* power10 10)]\n                (if (< result power10-n)\n                  (if (< result power10)\n                    [result power10 true]\n                    [result power10-n false])\n                  (recur (quot result 10)\n                         power10-n)))))]\n    (let [[first-half next-10power even?] (half n)]\n      (->> (iterate (fn [[n even? goal]]\n                      (let [n+1 (inc n)]\n                        (if (= n+1 goal)\n                          (if even?\n                            [n+1 false (* 10 goal)]\n                            [(quot goal 10) true goal])\n                          [n+1 even? goal])))\n                    [first-half even? next-10power])\n           (map (fn [[n even? _]] (palindromate n even?)))\n           (drop-while #(< % n))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(pal [n]\n          (let [s (str n)\n                l (count s)\n                m1 (subs s 0 (long (/ (inc l) 2)))\n                x (Long. m1)\n                m2 (str (inc x))\n                f (fn [m] (let [r (clojure.string/reverse m)]\n                            (->> (if (even? l)\n                                   r\n                                   (subs r 1))\n                                 (str m)\n                                 Long.)))\n                n1 (f m1)\n                n2 (f m2)]\n            (if (> n n1) n2 n1)))]\n  (iterate #(pal (inc %)) (pal n))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 150, "code": "(fn [n]\n  (letfn [(next-palindrome [n]\n            (let [s (str n)\n                  len (count s)\n                  s1 (subs s 0 (quot len 2))\n                  s2 (when (odd? len) (nth s (quot len 2)))\n                  s3 (clojure.string/reverse s1)\n                  p (read-string (str s1 s2 s3))]\n              (if (<= n p)\n                p\n                (let [s3' (reduce str \"\" (map (constantly \\9) s3))]\n                  (next-palindrome (inc (read-string (str s1 s2 s3'))))))))]\n    (iterate (comp next-palindrome inc) (next-palindrome n))))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 150, "code": "(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 150, "code": "(fn [x]\n                (let [find-next (fn [x]\n                                  (let [sx (str x)\n                                        middle  (quot (count sx) 2)\n                                        new-numb\n                                        (cond\n                                          (= x 9)\n                                          \"11\"\n\n                                          (even? (count sx)) ;; like 22\n                                          (let [new-beg (str (inc (BigInteger. (subs sx 0 middle))))\n                                                new-end (clojure.string/reverse (subs (str new-beg) 0 middle))]\n                                            (str new-beg new-end))\n\n                                          :else ; like 232\n                                          (let [new-beg (str (inc (BigInteger. (subs sx 0 (inc middle)))))\n                                                new-end (clojure.string/reverse (subs (str new-beg) 0 middle))]\n                                            (str new-beg new-end)))]\n                                    (BigInteger. new-numb)))\n\n                      first-palindrome (fn [x]\n                                         (let [sx (str x)\n                                               middle (quot (count sx) 2)\n                                               beginning (subs sx 0 middle)\n                                               new-end (clojure.string/reverse beginning)\n                                               new-number (BigInteger. (str (subs sx 0 (if (even? (count sx)) middle (inc middle))) new-end))]\n                                           (if (>= new-number x) new-number (find-next x))))]\n                  (iterate find-next (first-palindrome x))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 150, "code": "(fn palindromic-numbers [n]\n  (letfn [(n-to-digits [n]\n           (if (zero? n)\n             [0]\n             (rseq (mapv #(mod % 10) (take-while pos? (iterate #(quot % 10) n))))))\n         (digits-to-n [& ds]\n           (if (empty? ds)\n           0\n           (let [digits (flatten ds)]\n             (if (empty? digits)\n               0\n               (reduce (fn [acc v] (+ (* acc 10) v)) digits)))))\n         (palindromic-number-after [n]\n           (cond\n             (< n 9) (+ n 1)\n             (= n 9) 11\n             :else (let [digits (n-to-digits n)\n                         length (count digits)\n                         half-length (quot length 2)\n                         left (take half-length digits)\n                         right (drop half-length digits)]\n                     (if (even? length)\n                       (if (> (digits-to-n (reverse left)) (digits-to-n right))\n                         (digits-to-n (concat left (reverse left)))\n                         (if (some #(not= % 9) left)\n                           (let [left-plus-1 (n-to-digits (inc (digits-to-n left)))]\n                             (digits-to-n left-plus-1 (reverse left-plus-1)))\n                           (+ (digits-to-n left left) 2)))\n                     ;; n is odd\n                     (let [middle (nth digits half-length)]\n                       (if (> (digits-to-n (reverse left)) (digits-to-n right))\n                         (digits-to-n left (list middle) (reverse left))\n                         (if (< middle 9)\n                           (digits-to-n left (list (inc middle)) (reverse left))\n                           ;; middle = 9\n                           (if (some #(not= % 9) left)\n                             (let [left-plus-1 (n-to-digits (inc (digits-to-n left)))]\n                               (digits-to-n left-plus-1 (list 0) (reverse left-plus-1)))\n                             (+ (digits-to-n left (list middle) left) 2)))))))))\n           (palindromic-seq [n]\n             (lazy-seq (cons n (palindromic-seq (palindromic-number-after n)))))]\n  (let [n-as-str (str n)]\n     (if (= n-as-str (clojure.string/reverse n-as-str))\n        (palindromic-seq n)\n        (palindromic-seq (palindromic-number-after n))))))", "user": "51b920bfe4b0e871ca4958f9"}]