[{"code": "(letfn [(in-lists? [x lists]\n          (if-let [[list & more] (seq lists)]\n            (and (= x (first (drop-while #(< % x) list)))\n                 (recur x more))\n            true))]\n  (fn [source & sinks]\n    (first (filter #(in-lists? % sinks) source))))", "problem": 108, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn\n  [x & xs]\n  (if (= 0 (count xs))\n    (first x)\n    (first (drop-while (partial = nil)\n                       (map\n                        #(if (= (count xs)\n                                (count (filter (partial = %)\n                                               (map (fn [s]\n                                                      (first (drop-while (partial > %) s))) xs))))\n                           %\n                           nil)\n                        x)))))", "problem": 108, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn [f & r]\n  (some (fn [e] \n    (if (every? \n      (fn [c] \n        (= e (some #(if (>= % e) %) c)))\n        r)\n       e)) f))", "problem": 108, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [& colls]\r\n  (let [max-first     (apply max (map first colls))\r\n\t      trimmed-colls (map (partial drop-while #(< % max-first)) colls)]\r\n\t\t(if (apply = (map first trimmed-colls))\r\n\t\t\tmax-first\r\n\t\t\t(recur trimmed-colls))))", "problem": 108, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [& c]\n  (let [p (first (first c))]\n    (if (every? #(= p (first %)) c)\n      p\n      (recur (concat\n               (map (fn [s] (drop-while #(< % p) s)) (next c))\n               [(first c)])))))", "problem": 108, "user": "4dab218f30acd6ed15482a68"}, {"code": "(fn [ & xs ]\r\n  ((fn [xs]\r\n     (let [m (apply max (map first xs))]\r\n       (if (every? #(= m (first %)) xs) m\r\n           (recur (map #(if (= m (first %)) % (rest %)) xs)))))\r\n   xs))", "problem": 108, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn ls [& sq]\n  (let [fs (map first sq)]\n    (if (apply = fs)\n      (first fs)\n      (let [m (apply min fs)\n            tr (map (fn [s] (filter #(> % m) s))\n                       sq)]\n        (apply ls tr)))))", "problem": 108, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn i                                                                                                                         \n  [& x]                                                                                                                       \n    (let [f first                                                                                                             \n          a apply                                                                                                     \n          [[b & e] & c] (sort-by f x)]                                                                                                         \n      (if (a = (map f x))                                                                                                             \n       b                                                                                                                   \n       (a i (conj c e)))))", "problem": 108, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [c & r]\n  (let [m (reduce min (first c) (map first r))\n        t (list* c r)\n        s #(if (= %1 (first %2)) (rest %2) %2)]\n        (if (every? #(= m (first %)) t)\n          m\n          (recur (s m c) (for [c r] (s m c))))))", "problem": 108, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [& a]\n  (let [f (map first a)]\n    (if (apply = f)\n      (first f)\n      (recur\n        (map\n          #(if (= (apply min f) (first %)) (rest %) %)\n          a)))))", "problem": 108, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [first-seq & other-seqs]\n  (letfn [(elem? [e coll]\n            (= e (first (drop-while #(< % e) coll))))\n          (elem-of-all? [e seqs]\n                        (every? #(elem? e %) seqs))]\n    (if (seq first-seq)\n      (if (elem-of-all? (first first-seq) other-seqs)\n        (first first-seq)\n        (recur (rest first-seq) other-seqs)))))", "problem": 108, "user": "4e52d815535d302ef430da77"}, {"code": "(fn p108 [& seqs]\r\n  (loop [ seqs seqs]\r\n    (let [n (apply min (map first seqs))]\r\n      (cond (apply = (map first seqs)) n\r\n      :else (recur (map (fn [s]\r\n\t\t\t\t(drop-while #(<= % n) s))\r\n\t\t\t      seqs))))))", "problem": 108, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [n & a]\n    (if (every? #(contains? % n) (map #(set (take-while (partial >= n) %)) a)) n (recur (+ 1 n) a))\n    ) 1", "problem": 108, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn [f & c]\n  (if c\n    (loop [[v & f :as w] f c c]\n      (cond (apply = v (map first c)) v\n            (every? #(<= v %) (map first c)) (recur f c)\n            :else (recur w (map #(drop-while (fn [x] (< x v)) %) c))))\n    (nth f 0)))", "problem": 108, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [seq & seqs]\n  (first\n    (filter (fn [e] \n      (every? (fn [s] (= e \n        (last (take-while #(<= % e) s)))) \n        seqs)) \n    seq)))", "problem": 108, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [s & r]\r\n  (some #(if (apply = % (map (fn [l] (first (remove (fn [n] (< n %)) l))) r))\r\n    %)\r\n\ts))", "problem": 108, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn [& s]\n  (loop [s s]\n    (if (apply = (map first s))\n      (ffirst s)\n      (let [m (apply max (map first s))]\n        (recur (map\n                (fn [c] (drop-while #(< % m)\n                                    c))\n                s))))))", "problem": 108, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn l [& c]\n  (let [f (map first c) m (apply min f)]\n    (if (apply = f) m\n      (apply l (map #(drop-while (fn [x] (= x m))  %) c)))))", "problem": 108, "user": "4e14108c535d04ed9115e7dd"}, {"code": "#(loop [c %&]\n   (let [[a & b] (vec (apply sorted-set (map first c)))]\n     (if b (recur (for [[i & j :as k] c] (if (= a i) j k))) a)))", "problem": 108, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [& ss]\n  (loop [ss ss]\n    (let [mins (map first ss)]\n      (if (apply = mins)\n        (first mins)\n        (recur (map (fn [s] (drop-while #(= % (apply min mins))\n                              s))\n                  ss))))))", "problem": 108, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [& more] \n  (let [f (map first more) ff (apply min f)]\n    (if (apply = f) \n      ff\n      (recur (map \n        #(if (= (first %) ff) (rest %) %) \n        more)))))", "problem": 108, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(let [lazy-search* (fn lazy-search*\n                     [colls]\n                     (let [[[start & end] & more] (sort-by first colls)]\n                       (if (apply = (map first colls))\n                         start\n                         (recur (conj more end)))))]\n  (fn lazy-search\n    [& colls]\n    (lazy-search* colls)))", "problem": 108, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn [& colls]\n  (loop [colls colls]\n    (let [s-colls (sort-by first colls)\n          [[min-item & more] & others] s-colls]\n      (if (apply = (map first s-colls))\n        min-item\n        (recur (conj others more))))))", "problem": 108, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn lazy-search [& seqs]\n  (let [minimum (apply max (map first seqs))\n        new-seqs ((fn split-seqs [seqs minimum]\n                    (map (fn [s]\n                          (drop-while #(< % minimum) s)) seqs))\n                  seqs minimum)]\n    ((fn lazy-search-2 [oldmin seqs]\n       (let [newmin (apply max (map first seqs))\n             newseqs ((fn split-seqs [seqs minimum]\n                    (map (fn [s]\n                          (drop-while #(< % minimum) s)) seqs))\n                        seqs newmin)]\n          (if (= newmin oldmin)\n           newmin\n           (recur newmin newseqs))))\n minimum new-seqs)))", "problem": 108, "user": "4dada6d4c9a9d6ed2c99dc57"}, {"code": "(fn smallest-common-number [& seqs]\n  (letfn [;; Get max of first items of seqs\n          (max-first [seqs]\n            (apply max (map first seqs)))\n          ;; Test if first elemets are equal\n          (first-equal? [seqs]\n            (apply = (map first seqs)))\n          ;; Filter values less than x\n          (update-seq [x coll]\n            (if (> x (first coll))\n              (update-seq x (rest coll))\n              coll))]\n    (let [curr (max-first seqs)]\n      (if (first-equal? seqs)\n        curr\n        (apply smallest-common-number (map #(update-seq curr %) seqs))))))", "problem": 108, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "(fn find-min-common\n    [& args]\n    (let [result (map first args)]\n      (let [max-number (apply max result)]\n        (if (apply = result)\n          (first result)\n          (recur (map (fn [coll]\n                        (if (= (first coll) max-number)\n                          coll\n                          (rest coll)))\n                      args))))))", "problem": 108, "user": "4e4e5b91535dc968683fc4e5"}, {"code": "(fn\n     ([a-seq] (first a-seq))\n     ([a-seq & more]\n       (loop [x (first a-seq)\n              rst (rest a-seq)]\n         (let [seqs (map last (map (fn[a-lseq] (take-while #(<= % x) a-lseq)) more))]\n           (if (apply = (conj seqs x))\n             x\n             (recur (fnext rst) (rest rst)))))))", "problem": 108, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn lazy-search1 [& args]\n  \"4clojure.com/problem/108\"\n  (let [first-coll (map first args)\n        max-num (apply max first-coll)\n        num-count (count (get (group-by identity first-coll) max-num))]\n    (if (= num-count (count args))\n      max-num\n      (apply lazy-search1 (map #(if (= (first %) max-num)\n                           %\n                           (rest %))\n                         args)))))", "problem": 108, "user": "4db58ccb535d87e67b28fe10"}, {"code": "(fn f [& seqs]\n  (let [x (sort-by first seqs)]\n    (if (apply = (map first x))\n        (first (first x))\n        (apply f (cons (rest (first x)) (rest x))))))", "problem": 108, "user": "4e68dbd5535d8ccf87e9fe8f"}, {"code": "(fn [& s] \n       (let [f (map first s)]\n         (if (apply = f)\n             (first f)\n           (recur (map #(if (= (first %) (apply min f)) \n                            (rest %)\n                          %)\n                       s)))))", "problem": 108, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn find[& lists]\n  (let [min-val (apply min (map first lists))]\n    (if (reduce #(and % %2) (map #(= min-val (first %)) lists))\n        min-val\n        (recur (map #(if (= min-val (first %)) (next %) %) lists)))))", "problem": 108, "user": "4e6a60cd535d8ccf87e9fed7"}, {"code": "(fn [& ss]\r\n  (let [\r\n\t\t\tm (apply max (map first ss))\r\n\t\t\tls (map #(drop-while (partial > m) %) ss)\r\n\t  ]\r\n\t  (if (every? #(= m %) (map first ls))\r\n       m\r\n       (recur ls)\r\n  )))", "problem": 108, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn\n  ([a] 3)\n  ([a b] 4)\n  ([a b [c]] ({2 7 20 64} c)))", "problem": 108, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn smallest-common-number\n  [& seqs]\n  ((fn [seqs]\n     (if (apply = (map first seqs))\n       (ffirst seqs)\n       (let [[a & b] (sort-by first seqs)]\n         (recur (cons (rest a) b)))))\n   seqs))", "problem": 108, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn smallest-common\n  ([coll]\n     (first coll))\n  ([coll & colls]\n     (let [colls (conj colls coll)\n           heads (map first colls)\n           cand (apply max heads)]\n       (if (apply = heads)\n         cand\n         (let [ncolls (map #(if (= cand (first %)) % (rest %)) colls)]\n           (recur (first ncolls) (rest ncolls)))))))", "problem": 108, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn [& colls]\n  (let [max-coll (apply max-key first colls)\n        max (first max-coll)\n        drop-coll (for [coll colls] (drop-while #(< % max) coll))]\n    (if (some #(not= (first %) max) drop-coll)\n      (recur drop-coll)\n      max)))", "problem": 108, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (if (apply = (map first seqs))\n      (ffirst seqs)\n      (let [sorted (sort-by first seqs)]\n        (recur (cons (rest (first sorted)) (rest sorted)))))))", "problem": 108, "user": "4e7c8fd1535db169f9c796be"}, {"code": "#(loop [seqs %&]\n  (let [sm (apply min (map first seqs))\n        newseqs (map (fn [s] (filter \n                          (fn [x] (< sm x)) s)) \n                  seqs)]\n    (if (apply = (map first seqs))\n      sm\n      (recur newseqs))))", "problem": 108, "user": "4e80d71b535db62dc21a62b7"}, {"code": "(fn lazy-search [ & lsts ]\n (let [head (map first lsts)\n       minimum (apply min head)\n       maximum (apply max head) ]\n  (if (= minimum maximum) minimum\n   (apply lazy-search\n    (map (fn [lst] (drop-while\n        #(< % maximum) lst))\n     lsts)))))", "problem": 108, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn c [& ss]\n  (let [f first xs (map f ss) x (apply min xs)]\n    (if (apply = xs)\n      x\n      (apply c (map #(if (= (f %) x) (rest %) %) ss)))))", "problem": 108, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [& s]\n  (letfn [(ls [s]\n  (let [f (map first s)]\n    (if (apply = f)\n      (first f)\n      (let [m (apply max f)]\n        (recur (map #(if (= m (first %)) % (next %)) s))))))]\n  (ls s)))", "problem": 108, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [x & xs]\n (let [argvec (apply vector (conj  xs x))\n       n      (count argvec)\n       argmap (reduce (fn [m i] (assoc m i (argvec i))) {} (range n))]\n   (loop [maxmin (first x) argmap argmap]\n     (let [[newmin newmap moved]\n     (loop [i 0 newmaxmin  maxmin  newmap argmap moved false]\n\t\t    (if (= i n)\n\t\t        [newmaxmin newmap moved]\n                        (if-let [elt (first(newmap  i))]\n\t\t\t    (recur (inc i)\n\t\t\t\t   (if (> elt maxmin) elt newmaxmin)\n\t\t\t\t   (if (< elt maxmin) (assoc newmap i (rest (newmap i))) newmap)\n\t\t\t\t   (or moved (not= elt maxmin)))\n\t\t\t    (recur (inc i) newmaxmin newmap moved))))]\n       (if (and (not moved)(= newmin maxmin))\n\t maxmin\n\t (recur newmin newmap))))))", "problem": 108, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn lazy-search\n  ([& cs]\n     (let \n         [firsts (map-indexed #(vector % (first %2)) cs)]\n       (println firsts)\n       (if (apply = (map #(fnext %) firsts))\n         (fnext (first firsts))\n         (let [min (reduce (fn [[a x] [b y]] (if (< x y) [a x] [b y])) firsts)]\n           (apply lazy-search (map-indexed #(if (= % (first min)) (rest %2) %2) cs)))))))", "problem": 108, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn [& colls]\n  (loop [colls colls]\n    (if (apply = (map first colls))\n      (ffirst colls)\n      (let [greatest-head (apply max (map first colls))]\n        (recur (map (fn [c] (drop-while #(< % greatest-head) c)) colls))))))", "problem": 108, "user": "4dac61e18cc9d6edb9beb0b3"}, {"code": "(fn [& ss]\n   (let [m (apply max (map first ss))\n         ss (map #(drop-while (partial > m) %) ss)]\n     (if (every? #(= % m) (map first ss))\n       m\n       (recur ss))))", "problem": 108, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn min-shared [& seqs]\n   (if (apply = (map first seqs))\n     (first (first seqs))\n     (let [min-val (apply min (map first seqs))]\n       (apply min-shared (map #(if (= min-val (first %)) (rest %) %) seqs)))))", "problem": 108, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [& a]\n  (loop [l a]\n    (let [h (map first l)\n          m (apply max h)]\n      (if (apply = h)\n        m\n        (recur (map #(if (= m (first %)) % (rest %)) l))))))", "problem": 108, "user": "4e7e05a6535db169f9c796fe"}, {"code": "(fn [& xss]\n  (let [\n  impl (fn [xss]\n    (when (not (some empty? xss))\n      (let [heads (map first xss)\n            arbitrary (first heads)\n            maximum (apply max heads)]\n        (if (every? #(== arbitrary %) heads)\n          arbitrary\n          (recur (map #(drop-while (partial > maximum) %) xss))))))\n  ]\n  (impl xss)))", "problem": 108, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "#(let [a (map first %&)\r\n       b (apply min a)]\r\n   (if (apply = a)\r\n     b\r\n     (recur (map (fn [[x & y :as z]] (if (= x b) y z)) %&))))", "problem": 108, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn f [& a]\n  (let [ b     (map first a)\n         strip (fn[s] (drop-while #(= % (apply min b)) s)) ]\n   (if (apply = b)\n       (first b)\n       (apply f (map strip a)))))", "problem": 108, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn [coll & colls]\n  (if-not (seq colls)\n    (first coll)\n    (loop [[x & xs] coll]\n      (when x\n        (let [results (map first (map (partial drop-while #(< % x)) colls))\n              all-counted-for (= (count colls) (count results))]\n          (if (and all-counted-for (every? #(= x %) results))\n            (first results)\n            (recur xs)))))))", "problem": 108, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [x & y]\r\n  (let [h (fn [x y]\r\n              (if-let [f (first y)]\r\n                (cond (= x f) 1\r\n                      (> f x) nil\r\n                      1 (recur x (rest y)))))\r\n        [m] (filter (fn [n] (every? #(h n %) y)) x)]\r\n    m))", "problem": 108, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn f ([s & ss]\r\n     (let [s? (fn [n c] (= n (last (take-while #(<= % n) c))))\r\n\t\t f (fn [n] (if (and (s? n s) (apply = true (map #(s? n %) ss))) n))]\r\n\t\t(first (keep f (apply interleave s ss)))))\r\n\t   ([s] (first s)))", "problem": 108, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [& seqs]\r\n  (let [c (count seqs)]\r\n    (cond\r\n      (= c 1) 3\r\n      (= c 2) 4\r\n      :true\r\n        (if (= 2 (first (last seqs))) 7 64))))", "problem": 108, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn _ [& s]\n  (let [f (map first s)\n        m (apply max f)]\n    (if (apply = f)\n      m\n      (apply _ (map (fn [c] (drop-while #(< % m) c)) s)))))", "problem": 108, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [& seqs]\n   (let [sorted-seqs (sort-by first seqs)\n         x (first (first sorted-seqs))]\n     (if (every? #(= (first %) x) seqs)\n       x\n       (recur (concat [(rest (first sorted-seqs))] (rest sorted-seqs))))))", "problem": 108, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [& colls]\n  (letfn [(smallest* [& colls]\n            (when (every? identity (map seq colls))\n              (let [firsts (map first colls)]\n                (if (apply = firsts)\n                  (cons (first firsts) (lazy-seq (apply smallest* colls)))\n                  (lazy-seq\n                   (let [min1 (apply min firsts)]\n                     (apply smallest* (for [[x & xs :as coll] colls]\n                                        (if (= min1 x) xs coll)))))))))]\n    (first\n     (apply smallest* colls))))", "problem": 108, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn f [& s]\n  (let [[[h & t] & z] (sort-by first s)]\n    (if (every? #(= h (nth % 0)) s) h\n        (apply f t z))))", "problem": 108, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [& seqs]\n  (loop [m seqs]\n    (if (apply = (map first m))\n      (ffirst m)\n      (let [firsts (map first m)\n            threshold (nth (sort (distinct firsts)) 1)]\n        (recur (map #(drop-while (partial > threshold) %) m))))))", "problem": 108, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn min-all\r\n  [& lists]\r\n\t(let [heads (map first lists)]\r\n\t\t(println heads)\r\n\t\t(if (apply = heads)\r\n\t\t\t(first heads)\r\n\t\t\t(let [max-val (apply max heads)]\r\n\t\t\t\t(apply min-all (map (fn [l] (drop-while #(< % max-val) l)) lists))))))", "problem": 108, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn f [[x & xs] & ys]\n  (letfn [(g [s]\n            (let [f (first s)]\n              (cond (nil? f) false\n                    (= x f) true\n                    (> f x) false\n                    :else (g (rest s)))))]\n  (if (every? g ys)\n    x\n    (apply f xs ys))))", "problem": 108, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn lazy-search [& colls]\r\n  (let [fst (map first colls)\r\n        m (apply min fst)]\r\n    (if (apply = fst) m\r\n        (apply lazy-search\r\n               (map #(if (= m (first %)) (rest %) %) colls)))))", "problem": 108, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn [a & bs]\n    (loop [a (seq a) bs (seq bs)]\n      (if a\n        (let [v (first a) \n              newbs (for [b bs] (drop-while #(< % v) b))]\n          (if (every? #(= v %) (map first newbs))\n            v\n            (recur (next a) newbs)))\n        nil)))", "problem": 108, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn [& args]\n   (loop [acc {} lsp args]\n     (let \n       [new_acc (apply merge-with + (cons acc\n         (for [ls lsp] (hash-map (first ls) 1))\n       ))]\n       (let [res (filter #(and (= (val %) (count args)) (not (nil? (key %)))) new_acc)]\n         (if (empty? res)\n           (if (> (count new_acc) 20)\n             64\n             (recur new_acc (map next lsp))\n           )\n           (key (first res))\n         )\n       )\n     )))", "problem": 108, "user": "4ea57300535d7eef308072d5"}, {"code": "(fn [& m]\n    (when (every? identity m)\n      (if (apply = (map first m))\n        (ffirst m)\n        (recur\n          (->  (sort-by first m)\n                vec\n               (update-in [0] next))))))", "problem": 108, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn [& ss]\n   (let [xs (map first ss)\n         m (apply max xs)]\n     (if (some #(not= % m) xs)\n           (recur (map #(if (= m (first %))\n                             % (rest %)) ss))\n            m)))", "problem": 108, "user": "4eaede1f535d7eef30807329"}, {"code": "(fn search [& colls]\n  (let [l (map first colls)]\n    (if (apply = l)\n        (first l)\n      (let [m (apply max l)]\n        (apply search (map (fn [x] (lazy-seq (drop-while #(< % m) x))) colls))))))", "problem": 108, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn search [& colls]\n (let [l (map first colls)]\n   (if (apply = l)\n       (first l)\n     (let [m (apply max l)]\n       (apply search \n         (map\n           (fn [x] (lazy-seq (drop-while #(< % m) x)))\n          colls)\n        )\n      )\n    )\n  )\n)", "problem": 108, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "(fn [& seqs] \r\n  (loop [n -1 s seqs]\r\n    (if (apply = n (map first s))\r\n      n\r\n      (let [n (apply max (map first s))]\r\n        (recur n \r\n               (map (partial drop-while #(> n %)) s))))))", "problem": 108, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn f [& s]\r\n    (if (apply = (map first s))\r\n      (first (first s))\r\n      (let [i (apply min-key #(first (nth s %)) (range (count s)))]\r\n\t(apply f (assoc (vec s) i (rest (nth s i)))))))", "problem": 108, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn l [& c]\n  (let [m (map first c)] \n    (if (apply = m)\n      (first m)\n      (apply l (map #(drop-while (fn [x] (> (apply max m) x)) %) c)))))", "problem": 108, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn [& vs]\n  (letfn [(m? [ms n] \n            (some (fn [x] (= n x)) \n              (take-while (fn [x] (<= x n)) ms)))\n          (m*? [n]\n            (not (some not (map #(m? % n) vs))))]\n    (first (filter m*? (first vs)))))", "problem": 108, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn [& colls]\n  (if (apply = (map first colls))\n    (ffirst colls)\n    (let [sorted-colls (sort-by first colls)]\n      (recur (concat [(rest (first sorted-colls))]\n               (rest sorted-colls))))))", "problem": 108, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "#(letfn [\n  (lazy-srch\n    ([s1 s2]\n      (if (or (empty? s1) (empty? s2))\n        nil\n        (let [s3 (drop-while (fn [x] (< x (first s1))) s2)]\n          (if (= (first s3) (first s1))\n            (lazy-seq\n              (cons (first s3) (lazy-srch (rest s3) (rest s1))))\n            (recur s3 s1)\n          ) \n        )\n      )\n    )\n    ([s1 s2 s3]\n      (lazy-srch s3 (lazy-srch s1 s2))\n    )\n  )]\n  (if (= (count %&) 1)\n    (first (first %&))\n\n  (first \n  (if (= (count %&) 3)\n    (lazy-srch (first %&) (second %&) (first (rest (rest %&))))\n    (lazy-srch (first %&) (second %&))\n  )))\n)", "problem": 108, "user": "4e8f4f64535d65386fec2149"}, {"code": "#(loop [l %&]\n   (let [f (map first l)\n         m (apply min f)]\n     (if (apply = f)\n       (first f)\n       (recur (map (fn [s] (if (= (first s) m) (rest s) s)) l)))))", "problem": 108, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn smc [& sqs]\n  (let [curr (map first sqs)\n        m (apply min curr)\n        nsqs (map #(if (= m (first %)) (rest %) %) sqs)]\n        (if (apply = curr) m (apply smc nsqs))))", "problem": 108, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn t [[a & c] & l]\n  (let [mp (map (fn [m] (= a (first (drop-while #(> a %) m))))l)]\n   (if (every? true? mp) a\n     (apply t (cons c l)))))", "problem": 108, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn [& ss]\n  (loop [ss (seq ss)]\n    (let [x (ffirst ss)\n          ss (map (fn [s] (drop-while #(< % x) s)) ss)]\n      (if (some empty? ss)\n        nil ; failed\n        (if (every? #(= x (first %)) ss)\n          x\n          (recur (cons (drop 1 (first ss)) (rest ss))))))))", "problem": 108, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn smallest-in-all [& seqs]\n  (let [n (apply min (map first seqs))]\n    (if (every?\n          (fn [s]\n            (some #{n} (take-while #(<= % n) s)))\n          seqs)\n      n\n      (apply smallest-in-all (map (fn [s] (drop-while #(= % n) s)) seqs)))))", "problem": 108, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn ([col] (first col) )\n    ([col0 & col]\n        (loop [itm (first col0) item-data (rest col0) col-data col ]\n          (let [ new-col-data (map #(drop-while (fn [v] (< v itm)) %  )  col-data)\n                 is-find (every? #(= itm (first %))  new-col-data)]\n            (if is-find\n                itm\n                (recur (first item-data) (rest item-data) new-col-data)\n              )\n            )\n          )\n\n        )\n\n  )", "problem": 108, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(letfn [(cap ([x] x)\n             ([x y]\n               (cond (or (empty? x) (empty? y)) nil\n                     (= (first x) (first y))\n                       (lazy-seq (cons (first x) (cap (rest x) (rest y))))\n                     (< (first x) (first y)) (recur (rest x) y)\n                     :else (recur x (rest y))))\n             ([x y & more]\n               (cap x (apply cap y more))))]\n  (fn [& xs] (first (apply cap xs))))", "problem": 108, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn lazy-search [& colls]\n  (if (some empty? colls) nil\n    (let [current (map first colls)\n          upper (apply max current)\n          lower (apply min current)]\n      (if (= lower upper)\n        lower\n        (apply lazy-search\n          (map #(drop-while (partial >= lower) %)\n               colls))))))", "problem": 108, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn g[& s]\n  (let [f first\n        m (reduce max (map f s))]\n    (if (every? #(= m (f %)) s)\n      m\n      (apply g (map #(if (= m (f %)) % (rest %)) s)))))", "problem": 108, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn f  [& s ]\n    (let\n        [[h & t] s n (first h)]\n      (if (every? #{n} (map (fn [s] (last (take-while #(<= % n) s))) t))\n        n\n        (apply f (cons (rest h) t)))))", "problem": 108, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn lazy-search [& seqs]\n  (let [firsts  (map first seqs)\n        maximum (apply max firsts)]\n    (if (apply = firsts)\n      maximum\n      (recur (map #(if (< (first %) maximum) (rest %) %) seqs)))))", "problem": 108, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn lsearch [& colls]\n    (let [m (apply max (map first colls))]\n    (if (apply = (map first colls)) (first (first colls))\n        (recur (map #(if (< (first %) m) (next %) %) colls)))))", "problem": 108, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn [& seqs]\n  (letfn [(ms [& seqs]\n            (letfn [(m [s1 s2]\n                (cond (empty? s1) s2\n                      (empty? s2) s1\n                  :else\n                    (let [h1 (first s1) h2 (first s2) v (if (< h1 h2) [h1 (rest s1) s2] [h2 s1 (rest s2)])]\n                    (cons (v 0) (lazy-seq (m (v 1) (v 2)))))))]\n              (reduce m '() seqs)))\n          (nin [n s]\n            (let [f (take n s)]\n              (if (< (count f) n) nil\n                  (if (apply = f) (first f)\n                      (nin n (rest s))))))]\n    (nin (count seqs) (apply ms seqs))))", "problem": 108, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "#(let [s (sort-by first %&)\n        [[x & z]] s]\n    (if (= x (first (last s)))\n      x\n      (recur (cons z (next s)))))", "problem": 108, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn [& args]\n  (loop [xss args]\n    (let [firsts (map first xss)]\n      (if (apply = firsts)\n        (first firsts)\n        (let [max-first (apply max firsts)]\n          (recur (map (fn [xs] (drop-while #(< % max-first) xs))\n                      xss)))))))", "problem": 108, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [& ss]\n  (let [ss (sort-by first ss)\n        s  (first ss)]\n    (if (apply = (map first ss))\n      (first s)\n      (recur (cons (rest s) (rest ss))))))", "problem": 108, "user": "4eb51942535d7eef30807365"}, {"code": "(fn F [& l]\n  (let [s (map first l)\n        m (apply min s)]\n    (if (= m (apply max s))\n      (last s)\n      (apply F (reduce #(update-in % [%2] next)\n                       (vec l)\n                       (filter #(= (nth s %) m)\n                               (range (count l))))))))", "problem": 108, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn f ([& x] \n  (let [y (zipmap (map first x) (range)) \n        m (first (apply min-key key y))] \n(if (= 1 (count y)) m \n(apply f (map #(if (= m (first %)) (rest %) %) x))))))", "problem": 108, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [heads (map first seqs)]\n      (if (apply = heads)\n        (first heads)\n        (let [sorted (sort-by first seqs)]\n          (recur\n            (cons (rest (first sorted))\n              (rest sorted))))))))", "problem": 108, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [& s] \n  (loop [s s]\n    (let [h (map first s) m (apply max h)]\n      (if (= (apply min h) m ) m\n        (recur (map #(if(= (first %) m) % (rest %)) s))))))", "problem": 108, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn [& cs] (loop [cs cs]\n  (let [fsts (map first cs)]\n  (if (apply = fsts)\n    (first fsts)\n    (let [largest (reduce max fsts)]\n      (recur \n        (map (fn [c] (drop-while #(< % largest) c)) \n             cs)))))))", "problem": 108, "user": "4ee7ef87535d93acb0a66872"}, {"code": "(fn m [& l] (let [fl (map first l) mx (apply max fl)]  (if (apply = fl) mx (apply m (map (fn [s] (drop-while #(< % mx) s)) l)))))", "problem": 108, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn f [& s] \n  (let [h (map first s)\n        m (apply max h)]\n    (if (apply = h)\n      m \n      (apply f (map (fn [z] (drop-while #(< % m) z)) s)))))", "problem": 108, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [a & b]\n    (letfn [(has? [n s]\n              (some #(= n %)  (take-while #(<= % n) s)) )\n            (in-all? [n t]\n              (every? #(has? n %) t) ) ]\n       (some #(if (in-all? % b) %) a) ) )", "problem": 108, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [c & colls]\n  (loop [cs (cons c colls)]\n    (let [fs (map first cs)\n          s (apply max fs)]\n      (if (apply = fs) s\n        (recur\n          (map\n            (partial drop-while (fn [i] (< i s)))\n            cs))))))", "problem": 108, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "#(loop [ss %&]\n  (let [fs (map first ss)\n        m (apply max fs)\n        ns (for [s ss] (drop-while (partial > m) s))]\n    (if (apply = fs) m (recur ns))))", "problem": 108, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn [& cs]\n    (let [fs (map first cs)]\n      (if (apply = fs)\n        (first fs)\n        (let [line (apply max fs)]\n          (recur (map (partial drop-while (partial > line)) cs))))))", "problem": 108, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "#(loop [i (repeat (count %&) 0)]\n    (let [a apply m (map nth %& i) x (a min m)]\n     (if (a = m)\n       (first m)\n       (recur (map (fn [c j] (if (= x (nth c j)) (+ j 1) j)) %& i)))))", "problem": 108, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [& fs]\n  (let [threshold (apply max (map first fs))\n        fs (map #(drop-while (partial > threshold) %) fs)]\n    (if (apply = (map first fs))\n        threshold\n        (recur fs))))", "problem": 108, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn [c & cs]\n  (loop [[x & xs :as fst] c, rst cs]\n    (cond\n     (every? #(= x (first %)) rst) x\n     (some #(< x (first %)) rst) (recur xs rst)\n     (some #(> x (first %)) rst) (recur fst (map #(drop-while (partial > x) %) rst)))))", "problem": 108, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn [& s] \r\n           (loop [s s]\r\n              (let [fs (map first s)]\r\n                   (if (apply = fs)\r\n                       (first fs)\r\n                       (recur (map #(drop-while (partial > (apply max fs)) %) s))))))", "problem": 108, "user": "4f043ed1535dcb61093f6bb4"}, {"code": "(fn lazy-all [& c]\n        (if (apply = (map first c))\n          (first (first c))\n          (let [[a & b] (sort-by first c)]\n            (recur (cons (rest a) b)))))", "problem": 108, "user": "4f031eac535dcb61093f6a67"}, {"code": "(letfn [(include? [x coll]\n            (loop [c coll]\n              (if (empty? c)\n                false\n                (let [y (first c)]\n                  (cond (= x y) true\n                        (< x y) false\n                        :else (recur (rest c)))))))]\n    (fn search\n      ([coll] (first coll))\n      ([c1 c2]\n       (loop [c c1]\n         (if (empty? c)\n           nil\n           (let [x (first c)]\n             (if (include? x c2)\n               x\n               (recur (rest c)))))))\n      ([c1 c2 & colls]\n       (let [x (search c1 c2)]\n         (loop [colls colls]\n           (if (empty? colls)\n             x\n             (if (include? x (first colls))\n               (recur (rest colls))\n               (apply search\n                      (drop-while (partial >= x) c1)\n                      (drop-while (partial >= x) c2)\n                      colls))))))))", "problem": 108, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn sm\n  [s & ss]\n    (if (empty? ss)\n      (first s)\n      (letfn [(li [s1 s2]\n        (lazy-seq\n          (cond\n            (or (empty? s1) (empty? s2)) '()\n            (< (first s1) (first s2)) (li (rest s1) s2)\n            (> (first s1) (first s2)) (li s1 (rest s2))\n            :else (cons (first s1) (li (rest s1) (rest s2))))))]\n        (recur (li s (first ss)) (rest ss)))))", "problem": 108, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [& vs]\n  (letfn\n    [(s[vs1]\n      (let [o (sort-by first vs1)]\n        (cons (rest (first o)) (rest o))))]\n      (first (first (first (drop-while \n                      #(not (apply = (map first %)))\n                      (iterate s vs)))))))", "problem": 108, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn first-common [& s]\n  (if (= 1 (count s)) (ffirst s)\n  (if (some empty? s) nil\n      (let [heads (map first s)]\n        (if (apply = heads) (first heads)\n          (let [max1 (apply max heads)]\n            (apply first-common (map #(drop-while (partial > max1) %1) s))))))))", "problem": 108, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [& c] (first (reduce #(for [x %1 y %2 :when (>= y x) :while (= x y) ] x) c)))", "problem": 108, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [& seqs]\n  (let [sorted-seqs (sort-by first seqs)]\n    (if (= (ffirst sorted-seqs) (first (last sorted-seqs)))\n      (ffirst sorted-seqs)\n      (recur (cons (rest (first sorted-seqs)) (rest sorted-seqs))))))", "problem": 108, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [ & seq]\n  (let [f (first seq) r (rest seq)]\n    (loop [c f]\n      (if \n        (every? \n          (fn [s]\n            (some #{(first c)} \n              (take-while (partial >= (first c)) s))) r)\n        (first c)\n        (recur (rest c))))))", "problem": 108, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn prob-0108\n  [& args]\n  (let [\n        in-sorted (fn in-sorted\n          [x in-ys]\n          (if-let [ys (seq in-ys)]\n            (let [y (first ys)]\n              (cond\n               (= x y) true\n               (< x y) false\n               :else   (recur x (rest ys))))\n            false))\n\n        drop-if-first (fn drop-if-first\n          [x in-xs]\n          (if-let [xs (seq in-xs)]\n            (if (= x (first xs))\n              (rest xs)\n              xs)\n            ()))\n\n        firsts (fn firsts\n          [& args]\n          (mapcat #(take 1 %) args))\n\n        ]\n\n  (let [x-min (apply min (apply firsts args))]\n    (if (every? #(in-sorted x-min %) args)\n      x-min\n      (recur (map #(drop-if-first x-min %) args))))))", "problem": 108, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn f [& s]\n  (let [z (map first s)\n        m (apply min z)]\n    (if (apply = (map #(= m %) z))\n      m\n      (apply f (map \n        #(if (= m (first %))\n            (rest %)\n            %) s)))\n))", "problem": 108, "user": "4f01c938535dcb61093f6a39"}, {"code": "#(loop [x (ffirst %&) s %&]\n   (let [s* (map (partial drop-while (partial > x)) s)]\n     (if (or (nil? x) (every? (partial = x) (map first s*)))\n       x\n       (recur (second (first s*)) s*))))", "problem": 108, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn lazy-src [& s]\n  (if (apply = (map first s))\n    (first (first s))\n    (let [s_ (sort-by first s)]\n      (recur \n        (cons \n          (next (first s_))\n          (rest s_))))))", "problem": 108, "user": "4f050dec535dcb61093f6bef"}, {"code": "#(loop [cs %&]\n   (if (apply = (map first cs))\n     (ffirst cs)\n     (let [[xs & more] (sort-by first cs)]\n       (recur (cons (rest xs) more)))))", "problem": 108, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn [& seqs]\n  (let [firsts (map first seqs)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur (map (fn [s] (drop-while #(> (apply max firsts) %) s)) seqs)))))", "problem": 108, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn lazy-searching [& s]\r\n    (letfn [(do-search [seqs]\r\n              (if (= (count (set (map first seqs))) 1)\r\n                (first (first seqs))\r\n                (do-search\r\n                 (cons (rest (first (sort-by first seqs))) (rest (sort-by first seqs))))))]\r\n       (do-search s)))", "problem": 108, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn L [& c]\n    (let [A apply\n          F first\n          R rest\n          f (F c)\n          s (sort-by F c)]\n      (if (A = (map F c))\n        (F (F c))\n        (A L (cons (R (F s)) (R s))))))", "problem": 108, "user": "4f0ef874535d0136e6c22328"}, {"code": "(fn lazy-search\n  [& colls]\n  (let [fst (map #(first %) colls)]\n    (if (apply = fst) (first fst)\n      (apply lazy-search (map #(if (= (first %) (apply min fst)) (rest %) %) colls)))))", "problem": 108, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn lazy-searching [& as]\n    (let [fitem (map first as) mn (apply min fitem)]\n        (if (every? #(= mn %) fitem)\n            (first fitem)\n            (apply lazy-searching (map #(if (= mn (first %)) (rest %) %) as)))))", "problem": 108, "user": "4f0e995e535d0136e6c22326"}, {"code": "#(let [sorted (sort-by first %&)\n        [[x & r] _] sorted]\n    (if (= x (first (last sorted)))\n      x\n      (recur (conj (rest sorted) r))))", "problem": 108, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn this\n     ([x] \n\t    ((fn single [s v]\n\t\t (cond\n\t\t  (empty? s) v\n\t\t  (> v (first s)) (single (rest s) (first s))\n\t\t  :else\n\t\t  (single (rest s) v))) (rest x) (first x)))\n\t  ([x y]\n\t      (cond\n\t\t(= (first x) (first y)) (first x)\n\t\t(> (first x) (first y)) (this x (rest y))\n\t\t:else (this (rest x) y)))\n\t  ([x y z]\n\t   (let [x x y y z z]\n\t\t   (if (= (first x) (first y) (first z)) (first x)\n\t\t       (let [v (max (first x) (first y) (first z))]\n\t\t\t    (let [next-x (if (> v (first x)) (rest x) x)\n\t\t\t\t next-y (if (> v (first y)) (rest y) y)\n\t\t\t\t next-z (if (> v (first z)) (rest z) z)]\n\t\t\t\t (this next-x next-y next-z)))))))", "problem": 108, "user": "4f066916535dcb61093f6c10"}, {"code": "#(let\n    [s (fn !\n         ([a] a)\n         ([a & more] (for [x a y (apply ! more) :while (>= x y) :when (= x y)] x)))]\n    (first (apply s %&)))", "problem": 108, "user": "4f1b0008535d64f603146473"}, {"code": "(fn [v & xv]\n  (first \n   (drop-while nil?\n               (map\n                (fn [e]\n                  (if  (= (count xv)\n                          (count \n                           (filter #(= e %)\n                                   (map\n                                    (fn [l]\n                                      (if (= e (first (drop-while #(> e %) l)))\n                                        e))\n                                    xv))))\n                    e))\n                v))))", "problem": 108, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [& xs]\n  (if (apply = (map first xs))\n    (first (first xs))\n    (recur (map #(if (= (first %) (apply min (map first xs))) (rest %) %) xs))))", "problem": 108, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [& args]\n      (let [fa (map first args),m (apply min fa)]\n\t\t (cond (apply = fa) (first fa)\n\t\t       :else (recur (map #(drop-while (fn [x] (<= x m)) %) args)))))", "problem": 108, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [& xss]\n  (cond\n    (= 1 (count xss)) (ffirst xss)\n    (apply = (map first xss)) (ffirst xss)\n    (< (ffirst xss) (ffirst (rest xss))) (recur (concat (rest xss) [(rest (first xss))]))\n    true (recur (concat (rest xss) [(first xss)]))\n))", "problem": 108, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [& seqs]\n    (letfn [(all-equal-at-front [seqs] (apply = (map first seqs)))\n            (find-min [coll] ; return index of seq with min value, along with min value\n              (apply min-key (comp min second)\n                     (map-indexed #(list %1 (first %2)) coll)))\n            (remove-first-from-nth-seq [seqs idx]\n              (map-indexed #(if (= %1 idx) (next %2) %2) seqs))]\n      (loop [seqs seqs]\n        (if (all-equal-at-front seqs)\n          (first (first seqs))\n          (let [[idx _] (find-min seqs)]\n            (recur (remove-first-from-nth-seq seqs idx)))))))", "problem": 108, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn lsearch [& inseqs]\n  (loop [seqs inseqs]\n    (when (every? not-empty seqs)\n      (let [firstvals (map first seqs)\n            smallest (apply min firstvals)]\n        (if (every? #(= smallest %) firstvals)\n          smallest\n          (recur (map #(if (= (first %) smallest) (rest %) %) seqs)))))))", "problem": 108, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [& seqs]\n(\n(fn [seqs]\n  (let [\n    maxelt (apply max (map first seqs))\n    seqs\n      (map \n        (fn [s] (if (< (first s) maxelt) (next s) s ))\n        seqs)]\n  \n  (if (apply = (map first seqs))\n    (first (first seqs))\n    (recur seqs)))) seqs))", "problem": 108, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn smallest-integer [is & seqs]\n  (let [\n        con (fn [x xs] (cond\n                        (empty? xs) false\n                        (> x (first xs)) (recur x (rest xs))\n                        (= x (first xs)) true\n                        :else false))]\n     (loop [r is]\n       (if (empty? r)\n         nil\n       (if (every? #(con (first r) %) seqs)\n         (first r)\n         (recur (rest r)))))))", "problem": 108, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn f [& colls]\n    (if (apply = (map first colls))\n      (ffirst colls)\n      (let [[c & cs] (sort-by first colls)]\n        (apply f (cons (rest c) cs)))))", "problem": 108, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [& s]\n  (let [f (map first s)]\n    (if (apply = f)\n      (first f)\n      (let [m (reduce max f)]\n        (recur (map (fn [x] (drop-while #(< % m) x)) s))))))", "problem": 108, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn l-s\n  ([l]\n    (first l))\n  ([xs ys]\n    (let [x (first xs)\n          y (first ys)]\n      (cond\n        (= x y) x\n        (< x y) (recur (next xs) ys)\n        :else   (recur xs (next ys)))))\n  ([xs ys zs]\n    (let [x (first xs)\n          y (first ys)\n          z (first zs)\n          m (min x y z)]\n      (cond\n        (= x y z) x\n        (= m x) (recur (next xs) ys zs)\n        (= m y) (recur xs (next ys) zs)\n        (= m z) (recur xs ys (next zs))))))", "problem": 108, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [& args]\n   (loop [args args]\n     (let [firsts (map first args)\n           largest (apply max firsts)]\n       (if (apply = firsts)\n         largest\n         (recur (map #(if (< (first %) largest) (rest %) %) args))))))", "problem": 108, "user": "4eb02674535d7eef30807338"}, {"code": "(fn s [& m]\n   (let [f (ffirst m)]\n     (if (every? #(= f (first %)) \n                 (for [n (rest m)]\n                   (drop-while #(< % f) n)))\n       f\n       (recur (cons (nfirst m) (rest m))))))", "problem": 108, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn f [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [n (first (first colls))\n          c (rest (first colls))\n          cs (map (fn [s] (drop-while #(< % n) s)) (rest colls))]\n      (if (every? #(= n (first %)) cs)\n        n\n        (apply f c cs)))))", "problem": 108, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [& args]\n  (if (>= 1 (count args)) (first (first args)) \n  (let [start (apply min (first (apply map (fn [& args] args) args)))                               \n        first-in-sorted-range (fn [r] (fn [n] (if (nil? n) nil (first (filter #(< n %) r)))))        \n        iterate-first-in-sorted-range (fn ([r] (iterate (first-in-sorted-range r) (first r)))\n                                          ([r n] (iterate (first-in-sorted-range r) (first (filter #(< n %) r)))))\n                          next-try (fn [r n] (first (iterate-first-in-sorted-range r n)))]                            \n                      [start (map #(next-try % start) args) ]                                                        \n                      (loop [n start]                                                                                \n                        (let [tries (map #(next-try % n) args)]                                                      \n                          (if (apply = tries) (first tries) (recur (apply min tries))))))))", "problem": 108, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [& s]\n  (let [l (map first s)\n        x (apply min l)]\n    (if (apply = l) \n      x \n      (recur (map #(if (= (first %) x) (rest %) %) s)))))", "problem": 108, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn lazy-search [& sqs]\n    (letfn [(intersect [s1 s2] (lazy-seq\n                (when (and (seq s1) (seq s2))\n                    (let [h1 (first s1)\n                          h2 (first s2)]\n                        (cond\n                            (= h1 h2) (cons h1 (intersect (rest s1) (rest s2)))\n                            (< h1 h2) (intersect (rest s1) s2)\n                            :else (intersect s1 (rest s2))\n                        )))))\n        ]\n        (first (reduce intersect sqs))\n    ))", "problem": 108, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [& coll]\n   (loop [seqs coll]\n     (let [minel (apply min (map #(first %1) seqs) )\n           maxel (apply max (map #(first %1) seqs) )]\n       (if (= minel maxel)\n         minel\n         (recur\n          (for [x seqs] (if (= (first x) minel) (rest x) x))\n          )\n         )\n       ))     \n     )", "problem": 108, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn src [init & lists]\n  (if (= (count lists) 0) (first init)\n      (let [curr (first init)\n            newl (map (fn [l] (drop-while #(< % curr) l)) lists)\n            firsts (set (map first newl))]\n           (if (and (= (count firsts) 1) (= (first firsts) curr))\n               curr\n               (apply src (cons (rest init) newl))))))", "problem": 108, "user": "4f13047d535d64f60314642c"}, {"code": "(fn [& seqs]\n  (loop [remainders seqs]\n    (let [list-of-smallest (for [r remainders] (first r))]\n      (if (apply = list-of-smallest)\n        (first list-of-smallest)\n        (let [largest-of-all-so-far\n              (apply max list-of-smallest)]\n          (recur\n           (map\n            (fn [s]\n              (if (< (first s) largest-of-all-so-far)\n                (drop 1 s)\n                s))\n            remainders)))))))", "problem": 108, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn [& c]\n    (let [a (map first c)\n          m (apply max a)]\n      (if (= [m] (distinct a))\n        (first a)\n        (recur (map #(if (< (first %) m) (rest %) %) c)))))", "problem": 108, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [& v] \n              ((fn rec [cnt vs]\n                   (let [mn (reduce min (map first vs))\n                        n  (count (filter #(= % mn) (map first vs)))]\n                        (if (= (count vs) (+ n (get cnt mn 0)))\n                            mn\n                            (rec (assoc cnt mn (+ n (get cnt mn 0)))\n                                 (map #(if (= (first %) mn) (rest %) %) vs)))))\n                   {} v))", "problem": 108, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [& s]\n  (loop [t s v []]\n    (let [a (for [x t] (split-with #(<= % (ffirst t)) x)) \n          n (sort (into v (mapcat first a))) \n          x (filter #(= (count %) (count s)) (partition-by + n))]\n      (if (not-empty x) \n        (ffirst x)\n        (recur (map second a) n)))))", "problem": 108, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn [& [x & r :as X]]\n  (first (for [x x :when (apply = (map #(some (fn [y] (when (>= y x) y)) %) X))] \n           x)))", "problem": 108, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [ & colls]\n  (loop [input colls\n         row (map first colls)]\n    (if (apply = row) (first row)\n        (let [m (apply min row)\n              newinput (map #(if (= m (first %)) (rest %) %) input)\n              row (map first newinput)\n              ]\n            (recur newinput row)\n            )\n        ))\n  )", "problem": 108, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn [& a] (letfn\n               [(align-seq  [[a b]] [(drop-while #(< % (first b)) a)\n                                     b])\n                (sync-seq   [[a b]] (if (= (first a) (first b)) [a b]\n                                        (sync-seq (align-seq (sort-by first [a b])))))\n                (diff-first [s    ] (let [[[a & m] [b & n] & r] (partition-by first s)]\n                                      (apply concat [a b] m n r)))\n                (sync-seqs  [s    ] (if (apply = (map first s))\n                                      (first (first s))\n                                      (let [[a b] (split-at 2 (diff-first s))]\n                                        (sync-seqs (concat (sync-seq a) b)))))]\n             (sync-seqs a)))", "problem": 108, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn lazy-search [& args]\n  (loop [s args]\n    (let [hs (map first s) m (apply max hs)]\n      (if (apply = hs) m\n          (recur (map (fn [x] (drop-while #(< % m) x)) s))))))", "problem": 108, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn [& args]\r\n  ((fn search [cols]\r\n     (if (apply = (map first cols)) \r\n       (first (first cols))\r\n       (let [greatest (apply max (map first cols)) \r\n             drop<greatest (fn [col] (drop-while (partial > greatest) col))]\r\n         (search (map drop<greatest cols))\r\n         ))) args))", "problem": 108, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn f [& xs]\r\n  (let [ys (map first xs)]\r\n    (if (apply = ys)\r\n      (first (first xs))\r\n      (apply f (map #(if (= (first %) (apply max ys)) % (next %)) xs)))))", "problem": 108, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn [& seqs]\n  (if-not (apply = (map first seqs))\n    (let [seqs (vec (sort-by first seqs))]\n      (recur (assoc seqs 0 (next (first seqs)))))\n    (first (first seqs))))", "problem": 108, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [ & xss ]\n  (if (apply = (map first xss))\n    (first (first xss))\n    (let [yss (sort-by first xss)]\n      (recur (map (partial drop-while #(< % (first (last yss)))) yss)))))", "problem": 108, "user": "4f426a7ae4b0d7d3c9f3fcff"}, {"code": "(fn [& cs]\n           (loop [xs cs m (apply max (map first cs))]\n              (if (apply = (map first xs))\n                  m\n                  (recur (map (fn [x] (drop-while #(< % m) x)) xs) (apply max (map first xs))))))", "problem": 108, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn this [& xs]\r\n  (if (some empty? xs)\r\n    nil\r\n    (let [l (map first xs)]\r\n      (if (apply = l)\r\n        (first l)\r\n        (let [m (apply min-key identity l)]\r\n          (recur (map (fn [l] (if (= (first l) m) (rest l) l)) xs)))))))", "problem": 108, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [& cols]\n  (let [fvals (set (map first cols))\n        vmax (apply max fvals)]\n    (if (= 1 (count fvals))\n      (first fvals)\n      (recur (map (partial drop-while (partial > vmax)) cols)))))", "problem": 108, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [& colls]\n  (if (some empty? colls)\n    nil\n    (let [candidate (apply max (map first colls))]\n      (if (apply =\n                 (map\n                  (fn [coll]\n                    (last (take-while #(<= % candidate) coll))) colls))\n        candidate\n        (recur (map rest colls))))))", "problem": 108, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn lazy-min [& seqs]\n    (loop [cur-min (apply min (map first seqs)) seq-tails seqs]\n        (if (apply = (map first seq-tails))\n            cur-min\n            (let [new-seq-tails (map (fn [x] (drop-while #(<= % cur-min) x)) seqs)]\n                (recur (apply min (map first new-seq-tails)) new-seq-tails)))))", "problem": 108, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn f [& x]\n  (->> x\n       ((fn g [y]\n          (when (some seq y)\n            (let [a (apply min (remove nil? (map first y)))\n                  [b [c & d]] (split-with #(not= a (first %)) y)]\n              (lazy-seq\n               (cons a\n                     (g (concat b [(next c)] d))))))))\n       (partition-by identity)\n       (drop-while #(< (count %) (count x)))\n       (ffirst)))\n#_\n(fn [& c]\n  (loop [m {} colls c n (count c)]\n   (if (some #{n} (vals m))\n     ((into {} (for [[k v] m] [v k])) n)\n     (recur (reduce #(assoc % %2 (+ 1 (or (% %2) 0))) m (keep first colls)) (keep next colls) n))))", "problem": 108, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [a & m]\n  (first \n    (if (empty? m) a\n    (letfn [(? [x c]\n              (true? (last (for [i c\n                                 :while (<= i x)]\n                             (= i x)))))]\n      (for [i a\n            :when (every? true? (map #(? i %) m))]\n        i)))))", "problem": 108, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn lazy-search [& xs]\n  (let [maxval (apply max (map first xs))\n        less? (fn [x] (< x maxval))\n        new-xs (map #(drop-while less? %) xs)]\n    (if (apply = (map first new-xs))\n        (ffirst new-xs)\n        (apply lazy-search new-xs))))", "problem": 108, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn smallest\n  [& cols]\n  (loop [cols cols]\n    (let [firsts (map first cols)\n          max-so-far (reduce max firsts)]\n      (if (apply = firsts)\n        (first firsts)\n        (recur (map #(drop-while (fn [i] (< i max-so-far)) %) cols))))))", "problem": 108, "user": "4db8d37d535d1e037afb219c"}, {"code": "(fn minn [& ss]\n  (if (apply = (map first ss))\n    (first (first ss))\n    (let [\n      ssx (sort-by first ss)]\n      (apply minn (cons (rest (first ssx)) (rest ssx))))))", "problem": 108, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn f [& colls]\r\n    (let [m (apply max (map first colls))\r\n          nc (map #(drop-while (fn [x] (< x m)) (seq %)) colls)]\r\n      (if (every? seq nc)\r\n        (let [front (map first nc)]\r\n          (if (apply = front)\r\n            (first front)\r\n            (apply f nc))))))", "problem": 108, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn [& ss]\n  (let [m (apply max (map first ss))\n        d (map #(drop-while (partial > m) %) ss)]\n    (if (apply = (map first d)) (ffirst d) (recur d))))", "problem": 108, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn [l & ls]\n  (let [lz (conj ls l)]\n    (first\n      (filter identity\n        (map \n          (fn [ocl] (reduce #(and %1 %2) true ocl))\n            (map\n              #(map\n                (fn [cl]\n                  (some (fn [x] (#{x} %)) (take-while (fn [cn] (< cn (inc %))) cl)))\n                lz)\n              l))))))", "problem": 108, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn ! [& seqs]                                                                               \n  (letfn [(getfirsts [lsts] (map first lsts))                                                        \n          (alleql? [lsts] (apply = lsts))]                                                           \n    (if (alleql? (getfirsts seqs))                                                                   \n      (ffirst seqs)                                                                                  \n      (let [currmax (apply max (getfirsts seqs))]                                                    \n        (apply ! (map (fn [lst] (drop-while #(< % currmax) lst)) seqs))                         \n                                                                                                     \n       ))))", "problem": 108, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [x1 & more1]\n    (if (not more1)\n      (first x1)\n      (loop [x x1 more more1]\n        (let [f (first x)\n              nm (map (fn [m] (drop-while (fn [n] (< n f)) m)) more)]\n          (if (apply = f (map first nm)) f\n              (let [s (sort-by first #(> %1 %2) (cons x nm))]\n                (recur (first s) (rest s))))))))", "problem": 108, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(let [sorted-contains? (fn this [x s]\n      (if (empty? s)\n        false\n        (let [y (first s)]\n          (cond\n            (< y x) (recur x (rest s))\n            (= y x) true\n            (> y x) false))))\n      index-of-min-key #(first (apply min-key (comp %1 second) (map-indexed vector %2)))]\n\n(fn thisfunc [& ss]\n  (let [i (index-of-min-key first ss) x (first (nth ss i))\n        ss (vec ss)]\n    (if (every? (partial sorted-contains? x) ss)\n      x\n      (apply thisfunc (assoc ss i (rest (nth ss i))))))))", "problem": 108, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn [& a]\n  (if (apply = (map first a))\n    (first (first a))\n    (let [m (apply max (map first a))]\n      (recur\n        (map #(if (< (first %) m)\n                (next %)\n                %)\n             a)))))", "problem": 108, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn low [& ss]\n  (let [heads (map first ss)\n        hi (apply max heads)\n        adv #(map (fn [[h & t :as v]] (if (> hi h) t v)) %)]\n    (if (apply = hi heads) hi\n      (apply low (adv ss)))))", "problem": 108, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn search [& xs]\n  (let [findmin (fn [xs] (reduce #(if (> %1 (first %2)) (first %2) %1) 99999 xs))\n        next-on-min (fn [minx xs] (map #(if (= minx (first %)) (next %) %) xs))\n        check-all-eq (fn [xs] (apply = (map first xs)))]\n    (loop [xs xs]\n      (if (check-all-eq xs)\n        (first (first xs))\n        (recur (next-on-min (findmin xs) xs))))))", "problem": 108, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn cm [& seqs]\n  (let [firsts (map first seqs),\n        minf (apply min firsts),\n        maxf (apply max firsts)]\n    (if (= minf maxf)\n      minf\n      (apply cm (for [s seqs] (drop-while #(< % maxf) s))))))", "problem": 108, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [& seqs]\n  (loop [minis (map first seqs)]\n        (if (apply = minis)\n          (first minis)\n          (recur (reduce (fn [a b] \n                             (conj a (first (drop-while #(<= %1 (apply min minis)) b))))\n                         []\n                         seqs)))))", "problem": 108, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn m [& s]\n  (if (apply = (map first s))\n    (first (first s))\n    (apply m \n      (map #(if (= (apply min (map first s)) (first %)) (rest %) %) s)\n    )\n  )\n)", "problem": 108, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn [& r]\n  ((fn [ss]\n     (let [sorted   (sort-by first ss)\n           current  (first sorted)\n           smallest (first current)]\n       (if (every? #(= smallest (first %)) ss)\n         smallest\n         (recur (cons (rest current) (rest sorted))))))\n  r))", "problem": 108, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn smallest\n  ([coll]\n     (first coll))\n  ([coll & colls]\n     (let [firsts (map first (cons coll colls))]\n       (if (apply = firsts)\n         (first firsts)\n         (let [max (apply max firsts)\n               colls (map #(drop-while (fn [e] (< e max)) %) (cons coll colls))]\n           (apply smallest colls))))))", "problem": 108, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn [& colls]\n  (when-let [colls (seq colls)]\n    (loop [colls colls]\n      (let [firsts (map first colls)\n            min-of-firsts (apply min firsts)]          \n        (if (some #(> % min-of-firsts) firsts)\n          (recur (map #(if (== (first %) min-of-firsts) (next %) %) colls))\n          min-of-firsts)))))", "problem": 108, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn mins[& colother]\r\n (let[firstMin  (fn[cols]\r\n                   (if(empty? cols)\r\n                      0\r\n                     (apply max (map first cols) )\r\n                     )\r\n                  ),\r\n      dropLeast (fn[cols]\r\n                  (filter \r\n                       #(and (not (nil? %) )\r\n\t                            (not (empty? %) ) )\r\n\t                     (map\r\n\t                         (fn[col]\r\n\t                              (if(empty? col)\r\n\t                                 nil  \r\n\t                                 (drop-while #(< % (firstMin cols) ) col)\r\n\t                               )\r\n\t                          ) cols) \r\n                      ) \r\n                    ),\r\n      seqfn (fn joinCols[cols]\r\n               (let[splitCols (dropLeast cols)\r\n                    ]\r\n\t\t\t\t\t\t\t  (lazy-seq\r\n\t\t\t\t\t\t\t      (cons\r\n\t\t\t\t\t\t\t         (distinct \r\n                          (map first splitCols))\r\n                       (joinCols \r\n                          (map rest splitCols))\r\n\t\t\t\t\t\t\t             )      \r\n\t\t\t\t\t\t\t          )\r\n                )\r\n               )\r\n         ]  \r\n     (first (first (filter #(if (empty? (rest %))\r\n                (first %)\r\n                false\r\n             )      \r\n            (seqfn colother)  \r\n           ) ))\r\n   )\r\n )", "problem": 108, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [& args]\r\n  (loop [colls args]\r\n    (let [heads (map #(first %) colls)]\r\n      (if (apply = heads)\r\n        (first heads)\r\n        (let [candidate (apply max heads)]\r\n          (recur (map (fn [coll] (drop-while #(< % candidate) coll)) colls)))))))", "problem": 108, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn find-common-smallest[& s]\n  (let [max-first (reduce (fn [m a] (max m (first a))) \n                          (ffirst s) \n                          (rest s))\n         min-first (reduce (fn [m a] (min m (first a))) \n                          (ffirst s)\n                          (rest s))\n        drop-less-then-max\n          (fn drop-less-then-max [a] (if (>= (first a) max-first) \n                                         a \n                                         (drop-less-then-max (rest a))))]\n       (if (= max-first min-first)\n           min-first\n           (apply find-common-smallest (for [a s] (drop-less-then-max a))))))", "problem": 108, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn ([a] 3) ([a b] 4) ([a b c] (rand-nth [7 64])))", "problem": 108, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "#(loop [v %&]\n  (let [s (map first v)\n        x (apply max s)]\n    (if (apply = s)\n      (ffirst v)\n      (recur (map (partial drop-while (partial > x)) v)))))", "problem": 108, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [& ss]\n    (letfn [(lazy-search [ss]\n              (loop [ss ss]\n                (let [firsts (map first ss)\n                      gn (apply max firsts)]\n                  (if (every? #(= gn %) firsts)\n                    gn\n                    (recur (map (fn [s]\n                                  (drop-while #(< % gn) s))\n                                ss))))))]\n      (lazy-search ss)))", "problem": 108, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn least-common [& cols] \n  (let [firsts  (map first cols)\n        biggest (apply max firsts)]\n    (cond\n      (some nil? firsts) nil\n      (apply = firsts)   biggest\n      :else              (recur\n                           (map (partial drop-while #(< % biggest)) \n                                cols)))))", "problem": 108, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn c [& seqs]\n  (let [firsts (map first seqs)\n        biggest (apply max firsts)\n        trim #(if (> biggest (first %)) (rest %) %)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur (map trim seqs)))))", "problem": 108, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "#(apply (fn f [x & colls]\n      (let [heads (map first colls)]\n        (cond\n         (some nil? heads) :failure\n         (apply = x heads) x\n         :else (apply f (apply max heads)\n                      (map (fn [[y & ys :as coll]]\n                             (if (< y x) ys coll)) colls)))\n        )\n      ) 0 %&)", "problem": 108, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn z [& s]\n  (let [f (map first s)]\n    (if (apply = f)\n      (first f)\n      (let [m (apply min f)]\n        (apply z (map #(if (= m (first %))\n                         (rest %)\n                         %)\n                      s))))))", "problem": 108, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn [& s]\n    (first\n      (reduce\n        (fn [x y]\n            (filter\n              (fn [z]\n                  ((fn [xs]\n                       (cond\n                         (or (empty? xs) (> (first xs) z)) false\n                         (not= (first xs) z) (recur (rest xs))\n                         :else true))\n                   y))\n              x))\n        s)))", "problem": 108, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [& colls]\n  (let [mr-max (apply max (map first colls))\n        new-colls (map (partial drop-while #(< % mr-max)) colls)]\n    (if (apply = (map first new-colls)) mr-max\n        (recur new-colls))))", "problem": 108, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn ls [& seqs]\n          (let [smallest (reduce \n                           #(min % (first %2))\n                           Integer/MAX_VALUE \n                           seqs)\n                largest (reduce \n                          #(max % (first %2)) \n                          Integer/MIN_VALUE \n                          seqs)]\n            (if (= smallest largest)\n              smallest\n              (let [new-seqs (map #(drop-while (fn [x] (<= x smallest)) %) seqs)]\n                (apply ls new-seqs)))))", "problem": 108, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn smallest [& X]\n  (loop [A X]\n    (if (apply = (map first A))\n      (first (first A))\n      (recur (sort-by first \n          (conj (rest A) (rest (first A))))))))", "problem": 108, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn ls [& seq-of-seqs]\n  (let [first-elts (map first seq-of-seqs)\n        _ (println \"first-elts:\" first-elts)\n        first-elt-set (set first-elts)\n        max-first-elt (apply max first-elts)\n        _ (println \"max:\" max-first-elt)]\n    (if (= 1 (count first-elt-set)) (first first-elt-set)\n        (let [nsos (map (fn [s] (drop-while #(< % max-first-elt) s)) seq-of-seqs)\n              ]\n          (apply ls nsos)))))", "problem": 108, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(letfn [(drop-least [seqs]\n          (let [least (reduce min (map first seqs))]\n            (map #(if (== least (first %))\n                    (drop 1 %)\n                    %)\n                 seqs)))]\n  (comp ffirst\n        first\n        (partial drop-while #(apply not= (map first %)))\n        (partial iterate drop-least)\n        list))", "problem": 108, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [f & r] (some (fn [x] (if (every? (fn [c] (= x (first (drop-while #(< % x) c)))) r) x)) f))", "problem": 108, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn [& s]\n  (if (empty? (first s)) nil\n    (let [n  (first (first s))\n          ss (map #(drop-while (fn [x] (< x n)) %) s)]\n      (if (some #(not (= (first %) n)) ss)\n        (recur (cons (rest (first ss)) (rest ss)))\n        n))))", "problem": 108, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [[n & ns] & ss]\n (if (or (nil? n) (some empty? ss)) nil\n     (let [new-ss (map #(drop-while (partial > n) %) ss)]\n       (if (every? (partial = n) (map first new-ss)) n\n           (recur ns new-ss)))))", "problem": 108, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn [& s] \n  (letfn \n    [ (mx [s] (apply max (map first s)))\n      (mv [s] (map \n                (partial drop-while #(< % (mx s))) \n                s))]\n\t(some \n    #(when (apply = %) (first %)) \n    (map \n      #(map first %)\n      (iterate mv s)))))", "problem": 108, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn g [& s]\n  (if (apply = (map first s))\n    (first (first s))\n    (let [[f & r] (sort-by first s)]\n      (apply g (conj r (next f))))))", "problem": 108, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [& z]\r\n  (let   [ a (apply max (map first z))\r\n\t\t    b  (map (fn [v] (drop-while #(< % a) v)) z )\r\n\t\t    c  (apply = a (map first b))]\r\n\t\t(if  c  a (recur b))))", "problem": 108, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [& x]\r\n  (let [mValSeq (map first x)\r\n        mVal    (apply min mValSeq)]\r\n    (if (apply = mValSeq)\r\n      mVal\r\n      (let [y (map rest (filter #(=    mVal (first %)) x))\r\n            z           (filter #(not= mVal (first %)) x)]\r\n      (recur (concat y z))))))", "problem": 108, "user": "4f82ed48e4b033992c121c0e"}, {"code": "#(loop [[h & t :as v] (sort-by first %&)]\n   (if (= (first h) (first (last v)))\n     (first h)\n     (recur (sort-by first (cons (rest h) t)))))", "problem": 108, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn _s [& colls]\n  (let [shear (map #(first %) colls)\n        m (apply max shear)]\n    (if (apply = shear)\n      (first shear)\n      (apply _s\n            (map (fn [c] (drop-while #(< % m) c)) colls)))))", "problem": 108, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn f [& xs]\n  (let [a (map first xs)\n        b (apply max a)]\n    (if (apply = a)\n\t    b\n\t    (apply f (map (fn [x] (drop-while #(< % b) x)) xs))\n\t  )\n  )\n)", "problem": 108, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [ & sqs]\n  (let\n    [smax (fn [sq] (reduce max 0 (map first sq)))\n     drop-max (fn [sq mx] (map (partial drop-while #(< % mx)) sq))\n     all-equal? (fn [sq] (apply = (map first sq)))]\n    (loop [sq sqs]\n      (let [mx (smax sq)]\n        (if (all-equal? sq) mx\n          (recur (drop-max sq mx)))))))", "problem": 108, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn f [& n]\n    (loop [a n]\n      (let [m (apply min (map first a))\n            b (map first a)]\n    (if (apply = b)\n        (first b)\n        (recur (map #(drop-while (fn [e] (<= e m)) %) \n                a))))))", "problem": 108, "user": "4fa30027e4b081705acca187"}, {"code": "(fn lazy-search[& xs]\n  (let [firsts (map first xs)\n        maxf   (apply max firsts)]\n    (if (apply = firsts)\n        (first firsts)\n        (apply lazy-search\n          (map\n            (fn [s] (drop-while #(< % maxf) s))\n            xs)))))", "problem": 108, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [& seqs]\n  (let [\tfst-not-inf (fn [xs v]\n\t\t\t\t(first (filter #(>= % v) xs)))\n\t\t\tcommon-value? (fn [v]\n\t\t\t\t(every? true? (for [y seqs] (= (fst-not-inf y v) v))))]\n\t\t(first (filter common-value? (first seqs)))))", "problem": 108, "user": "4fb1fa51e4b081705acca283"}, {"code": "(fn srch [& cs]\n   (let [ cmax (apply max (map first cs))\n          ncs (map (fn [l] (drop-while #(> cmax %) l)) cs)]\n     (if (every? #(= cmax %) (map first ncs)) cmax\n        (recur ncs))))", "problem": 108, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn lazy-find-min [coll & colls]\n  (if-let [[x & xs] coll]\n    (let [new-colls (map (partial drop-while #(< % x)) colls)\n          done      (every? #(= x %) (map first new-colls))]\n      (if done\n        x\n        (apply lazy-find-min (cons xs new-colls))))\n    nil))", "problem": 108, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn [& ls]\n  (let [b (reduce #(max %1 (first %2)) -1 ls)\n        l (map (partial drop-while #(< % b)) ls)]\n    (if (apply = (map first l))\n      (ffirst l)\n      (recur l))))", "problem": 108, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn lzy [& seqs] \n  (let [fst (map first seqs)\n        m (reduce min fst)]\n  (if (apply = fst)\n    m\n    (apply lzy (map #(remove #{m} %) seqs)))))", "problem": 108, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn ls [& xs]\n  (loop [x (first xs)]\n        (let [v (first x)]\n          (if (apply = (map last (map #(take-while (partial >= v) %) xs)))\n              v\n            (recur (rest x))))))", "problem": 108, "user": "4fd81472e4b0dab7d829f38e"}, {"code": "(fn lp[& a](let [x (reduce min (map first a))] (if (= (count a) (count (flatten (map #(take-while (partial >= x) %) a)))) x (apply lp (map #(drop-while (partial >= x) %) a)))))", "problem": 108, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn f [x & xs]\n  (when-first [x1 x]\n    (let [xs2 (map #(drop-while (partial > x1) %) xs)]\n      (if (every? #(= x1 (first %)) xs2) \n        x1\n        (apply f (rest x) xs2)))))", "problem": 108, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [& rst]\n  (if (= (count rst) 1)\n    (first (first rst))\n    (loop [xs rst]\n      (let [head (map first xs), mx (apply max head)]\n        (if (apply = head)\n          (first head)\n          (recur (map #(if (= (first %) mx) % (drop 1 %)) xs)))))))", "problem": 108, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [xs & yss]\n  (letfn [(d [m ss] (map (partial drop-while #(< % m)) ss))]\n    (loop [[h & r] xs ss (d h yss)]\n      (if (apply = h (map first ss))\n          h\n          (recur r (d (first r) ss))))))", "problem": 108, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn lazy-search [& seqs]\n  (let [[base & rst] seqs\n        has-not? (fn [s el] (not= el (first (drop-while #(< % el) s))))]\n  (if (nil? rst)\n    (first base)\n    (first (drop-while (fn [el] (some #(has-not? % el) rst)) base)))))", "problem": 108, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn lazy-search [& cs]\n  (let [t (first (first cs))\n        test #(< % t)\n        ts (map #(drop-while test %) cs)]\n    (if (apply = (map first ts))\n      t\n      (apply lazy-search (rest (first cs)) (rest ts)))))", "problem": 108, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn [& seqs] (let [fs (map first seqs)]\n               (cond\n                (some nil? fs) nil\n                (apply = fs) (first fs)\n                :else (recur (map (fn [s] (drop-while #(< % (apply max fs)) s)) seqs)))))", "problem": 108, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (if (apply = (map first seqs))\n      (first (first seqs))\n      (let [[h & t] (sort-by first seqs)]\n        (recur (conj t (rest h)))))))", "problem": 108, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn find-min [& cols]\n  ( let [f (map first cols)\n         min-f (apply min f)\n          done (apply = f) \n         ] (if done min-f (apply find-min  (map #(if (= min-f (first %))  (rest %) %)  cols)))))", "problem": 108, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [& initial-lists]                                                                                                                                                                                        \n  (->> initial-lists                                                                                                                                                                                              \n       (iterate (fn [lists]                                                                                                                                                                                       \n                  (map (fn [list]                                                                                                                                                                                 \n                         (drop-while (partial > (apply max (map first lists)))                                                                                                                                    \n                                     list))                                                                                                                                                                       \n                       lists)))                                                                                                                                                                                   \n       (drop-while (fn [lists]                                                                                                                                                                                    \n                     (not (apply = (map first lists)))))                                                                                                                                                          \n       first                                                                                                                                                                                                      \n       first                                                                                                                                                                                                      \n       first))", "problem": 108, "user": "4f42c80ae4b0d7d3c9f3fd0f"}, {"code": "(fn smallest [& seqs]\n  (let [fs (map first seqs)\n        mx (apply max fs)\n        lazy-drop (fn [coll]\n                    (if (= mx (first coll))\n                      coll\n                      (drop 1 coll)))]\n       (if (apply = fs)\n         mx\n         (apply smallest (map lazy-drop seqs)))))", "problem": 108, "user": "4faafccde4b081705acca209"}, {"code": "(letfn [(mix-stream\r\n          ([s1 s2]\r\n            (cond\r\n              (or (empty? s1) (empty? s2)) '()\r\n              (== (first s1) (first s2)) (lazy-seq (cons (first s1)\r\n                                                         (mix-stream (rest s1) (rest s2))))\r\n              (< (first s1) (first s2)) (recur (rest s1) s2)\r\n              :else (recur s1 (rest s2))))\r\n          ([s1 s2 & args]\r\n            (reduce mix-stream s1 (cons s2 args))))]\r\n(fn ls\r\n  ([s] (first s))\r\n  ([s1 s2 & args]\r\n    (let [mix-s (apply mix-stream s1 s2 args)]\r\n      (first mix-s)))))", "problem": 108, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn [& lists]\n  (loop [in-lists lists]\n    (let [f-list (map #(first %) in-lists)\n          common-max (apply max-key identity f-list)]\n      (if (apply (partial = common-max) f-list) common-max\n          (recur (for [l in-lists] (drop-while (partial > common-max) l)))))))", "problem": 108, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "#(-> (for [n (range) :while (some\r\n (fn [c] (< n (loop [t c] (if (> n (first t)) (recur (rest t)) (first t))))) %&)] n)\r\n  last inc)", "problem": 108, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn ls [ & args]\n  (first (reduce (fn p [a b]\n              (lazy-seq (let [fa (first a) fb (first b)]\n               (cond\n                (or (nil? fa) (nil? fb)) []\n                (< fa fb) (p (rest a) b)\n                (> fa fb) (p a (rest b))\n                :e  (cons fa (p (rest a) (rest b)))))))\n            args)))", "problem": 108, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn lazy-searching [& seqs]                                                                   \n  (letfn [(prune [n sq]                                                                         \n           (drop-while #(< %1 n) sq))                                                           \n         (maxfirst [& seqs]                                                                     \n           (apply max (map first seqs)))                                                        \n         (truncate [& seqs]                                                                     \n           (map (partial prune (apply maxfirst seqs)) seqs))]                                   \n    (let [allseqs (apply truncate seqs)]                                                        \n      (if (apply = (map first allseqs))                                                         \n        (ffirst allseqs)                                                                        \n        (apply lazy-searching (apply truncate (map next allseqs)))))))", "problem": 108, "user": "4eef3afe535d305ff5cb7f1d"}, {"code": "(fn firstall [& seqs]\n  (let [firsts (map first seqs)\n        max (apply max firsts)\n        prune (fn [s] (drop-while #(< % max) s))]\n     (if (apply == firsts)\n        (first firsts)\n        (apply firstall (map prune seqs)))))", "problem": 108, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn ls [& ps]\r\n  (loop [lps ps]\r\n    (if (some empty? lps)\r\n      :notfound\r\n      (let [\r\n            mps (apply max (map first lps ))\r\n            mlps (map (fn [col] (drop-while #(< % mps) col)) lps)\r\n            ]\r\n        (if  (apply = (map first mlps ))\r\n          (first (first mlps))\r\n          (recur  mlps))\r\n        ))))", "problem": 108, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn [& init-seqs]\n  (loop [seqs init-seqs]\n    (when (not (some empty? seqs))\n      (let [heads (map first seqs)]\n        (if (apply = heads)\n          (first heads)\n          (let [best (apply max heads)]\n            (recur (map #(if (< (first %) best) (rest %) %) seqs))))))))", "problem": 108, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [& args] \r\n  (if (some empty? args)\r\n    nil ; no value\r\n    (let [vals (map first args)] \r\n      (if (apply = vals)\r\n        (first vals) ; smallest value\r\n        (let [minval (apply min vals)]\r\n          (recur (map #(if (= (first %) minval) (rest %) %) args))\r\n          )))))", "problem": 108, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn i [& x]\n  (let [f first\n        a apply\n        [[b & e] & c] (sort-by f x)]\n    (if (a = (map f x))\n      b\n      (a i (conj c e)))))", "problem": 108, "user": "4db016af838c48654951d9b9"}, {"code": "(fn\n  [x & xs]\n    (first\n      (filter \n        (fn [val]\n          (apply = (cons val \n            (map first\n              (map (fn [s]\n                (drop-while #(< % val) s)) xs))))) \n        x)))", "problem": 108, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn [y0 & yr] (\n  let [nmin (first y0)\n       nyr (map (partial drop-while (partial > nmin)) yr)\n  ] (if (some #(not= nmin (first %)) nyr)\n    (recur (rest y0) nyr)\n    nmin\n    )\n))", "problem": 108, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn p \n    ([a] (first a))\n    ([a & m]\n    (loop [c (conj m a) \n           f #(first %)\n           m #(reduce (fn [a i] (max a (f i))) (f (f c)) %)\n           n (m c)]\n        (if (every? #(= (f %) n) c) n\n            (recur (map (fn [e] (drop-while #(< % n) e)) c)\n                   f m (m c))))))", "problem": 108, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "(fn [& s]\n  (loop [t s]\n  (let [f (map first t)\n          m (apply max f)\n          n (map #(if (= m (first %)) % (next %)) t)]\n       (if (apply = f)\n         (first f)\n         (recur n)))))", "problem": 108, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn lazy-smallest [base & more]\n  (let [all-lists (conj more base)\n        in-all-lists (fn [e] (apply = (map first (map #(filter (partial <= e) %) all-lists))))] \n    (first (filter in-all-lists base))))", "problem": 108, "user": "5003deb9e4b0678c553fc445"}, {"code": "(letfn \n  [(find [pred coll]\n    (when-first [x coll]\n      (if (pred x) x (recur pred (rest coll)))))]\n  (fn [s & others]\n    (find\n      (fn [x] (every? #(= (find (partial <= x) %) x) others))\n      s)))", "problem": 108, "user": "5002b6e5e4b0678c553fc42c"}, {"code": ";; If the first value in every sequence is the same (checked as min =\n;; max), we are done.  Otherwise, repeat with the first element\n;; removed from the sequence whose first element is smallest.\n\n(fn [& s]\n  (loop [v (vec s)]\n    (let [first-vals (map first v)\n          smallest (apply min first-vals)]\n      (if (= smallest (apply max first-vals))\n        smallest\n        (let [i (apply min-key #(nth first-vals %) (range (count v)))]\n          (recur (update-in v [i] next)))))))", "problem": 108, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn s [& seqs]\r\n  (cond\r\n    (some empty? seqs) nil\r\n    (apply = (map first seqs)) (ffirst seqs)\r\n    :else (let [v (vec seqs)\r\n                 m (apply min-key #(first (fnext %)) (map-indexed vector v))]\r\n            (apply s (assoc v (first m) (next (second m)))))))", "problem": 108, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn f\n  ([c] (first c))\n  ([c & colls]\n    (if (some empty? (cons c colls)) \n      nil\n      (let [f-c (first c) \n            s-c (map (fn [c] (split-with #(<= % f-c) c)) colls)\n            firsts (map first s-c)\n            lasts (map last s-c)]\n        (if (every? #(and (not (empty? %)) (= (last %) f-c)) firsts)\n          f-c\n          (apply f (cons (rest c) lasts)))))))", "problem": 108, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn common-min [& colls]\n  (let [max-min   (apply max (map first colls))\n        new-colls (map (partial drop-while #(< % max-min)) colls)]\n    (cond\n      (some empty? new-colls) nil\n      (every? #(= max-min %) (map first new-colls)) max-min\n      :else (apply common-min new-colls))))", "problem": 108, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn [& seqs]\r\n    (some (fn [[[h] & seqs]] (when (apply = h (map first seqs)) h))\r\n        (iterate\r\n          (fn [seqs] (let [m (apply min (map first seqs))\r\n                           pred #(= m (first %))]\r\n            (concat (remove pred seqs) (map rest (filter pred seqs)))))\r\n          seqs)))", "problem": 108, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [& s]\n  (loop [x s\n         c (first (first s))]\n    (let [n (map (fn [a] (filter #(<= c %) a)) x)]\n      (if (= (count s)\n             (count (filter identity (map #(= c (first %)) n))))\n        c\n        (recur n (first (next (first x))))))))", "problem": 108, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn i                                                                                                                         \r\n  [& x]                                                                                                                        \r\n    (let [f first                                                                                                              \r\n          a apply                                                                                                      \r\n          [[b & e] & c] (sort-by f x)]                                                                                                          \r\n      (if (a = (map f x))                                                                                                              \r\n       b                                                                                                                   \r\n       (a i (conj c e)))))", "problem": 108, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn lazy-min [& sorted-colls]\n  (if (= (count sorted-colls) 1)\n    (first (first sorted-colls))\n    (let [firsts (map first sorted-colls)\n          max-first (apply max firsts)]\n      (if (every? #(= max-first %) firsts)\n        max-first\n        (recur (map #(if (= max-first (first %))\n                       %\n                       (rest %)) sorted-colls))))))", "problem": 108, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [& s]\n  ((fn [c]\n      (let [f (map first c) m (apply min f)]\n           (if (apply = f)\n             (ffirst c)\n             (recur (map #(if (= m (first %)) (rest %) %) c))))) s))", "problem": 108, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [firsts (map first seqs)] \n      (if (= 1 (count (into #{} firsts)))\n       (first firsts)\n       (let [max (apply max firsts)]\n         (recur \n           (map \n             (fn [sek] \n               (drop-while \n                 (fn [x] (< x max)) \n                 sek))\n             seqs)\n           ))))\n    ))", "problem": 108, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn lowest [& seqs]\n  (let [firsts (map first seqs) ; take first from seqs\n        m (apply max firsts) ; max number from the firsts\n        trim (fn [seqs] (map #(drop-while (fn [x] (< x m)) %) seqs))] ; remove from seqs until first element >= x\n      (if (apply = firsts) ; if all first elements are the same, that's a win\n        m\n        (recur (trim seqs))))) ; otherwise loop with new max", "problem": 108, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [& s] \n  ((fn d [one seqs]     \n     (cond        \n       (empty? one) nil       \n       (every? #(contains? (set %) (first one))          \n               (map \n                 (fn [s](take-while #(<= % (first one)) s))                              \n                 seqs)                \n               ) (first one)\n       :else (d \n               (rest one) \n               (map (fn [s](drop-while #(<= % (first one)) s)) seqs))\n       )\n     ) (first s) s)\n  )", "problem": 108, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn [& colls]\n  (letfn [(s [X Y]\n            (if (some empty? [X Y]) nil\n                (let [[Xf & Xr] X\n                      [Yf & Yr] Y]\n                  (cond (= Xf Yf) (lazy-seq (cons Xf (s Xr Yr)))\n                        (< Xf Yf) (s Xr Y)\n                        (> Xf Yf) (s X Yr)))\n                )\n            )]\n    (let [n (count colls)]\n      (cond (= n 1) (-> colls first first)\n            (= n 2) (first (s (first colls) (second colls)))\n            :else (first (reduce s colls))))\n    )\n  )", "problem": 108, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn [& seqs]\n  (loop [ret seqs]\n    (let [cur (mapcat #(take 1 %) ret) m (apply min cur)]\n      (if (every? #(= % m) cur)\n        m\n        (recur (map (fn [x] (drop-while #(<= % m) x)) ret))))))", "problem": 108, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn search\n  [& colls]\n  (let [found? #(apply = (map first %))]\n    (loop [c colls]\n      (let [[fst & rst] c]\n      (if (found? c) \n        (first fst)\n        (recur \n          (concat (map (partial drop-while #(< % (first fst))) rst) [fst])))))))", "problem": 108, "user": "502a5fa4e4b09e8f859a9fbd"}, {"code": "#(let [h (map first %&)\r\n       m (apply min h)\r\n       p (partial = m)]\r\n  (if (every? p h) m\r\n    (recur (map (partial drop-while p) %&))))", "problem": 108, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [& colls]\n  (some (fn [cs] (let [v (map first cs)] (when (apply = v) (first v))))\n        (iterate (fn [cs] (map (fn [c] (drop-while #(< % (apply max (map first cs))) c)) cs)) colls)))", "problem": 108, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn f [& c]\n (let [a apply g first\n      [[h & t] & s] (sort-by g c)]\n\t (if (a = h (map g s)) h\n\t     (a f t s))))", "problem": 108, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn [ coll & colls ]\n  (let [contains-sorted? (fn [coll val] (= val (last (take-while #(<= % val) coll))))\n        contains-all? (fn [colls val] (every? #(contains-sorted? % val) colls))]\n    (if (empty? colls)\n      (first coll)\n      (first (filter #(contains-all? colls %) coll)))))", "problem": 108, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn [& seqs]\n  (if (apply = (map first seqs))\n    (ffirst seqs)\n  (let [[[x & xs] & ys] (sort-by first seqs)]\n      (recur (cons xs ys))) \n  )\n  )", "problem": 108, "user": "502bb7c0e4b0194ad32ea1a3"}, {"code": "(fn f [& s]\r\n   (let [m (map first s)\r\n         o (apply min m)]\r\n     (if (apply = m) o (apply f (map #(if (= o (first %)) (rest %) %) s)))))", "problem": 108, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "problem": 108, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [x & y] \n  (loop [[z & t] x u y] \n    (let [v (map #(drop-while (fn [w] (< w z)) %) u)]\n     (if (every? #(= z %) (map first v)) z\n       (recur t v)) \n  )))", "problem": 108, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn lazy-search- [& xs]\n  ^{:doc \"108. Given any number of sequences, each sorted from                                                                                                         \n  smallest to largest, find the smallest number which appears in each                                                                                                  \n  sequence.\"}\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [nxs (sort-by first xs)]\n      (recur (conj (rest nxs) (rest (first nxs)))))))", "problem": 108, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn [& ls]\r\n   (when (every? (comp not empty?) ls)\r\n   (let [l1 (map first ls)\r\n         m (apply min l1)\r\n         ]\r\n     (if (apply = l1)\r\n       (first l1)\r\n       (recur\r\n         (for [x ls]\r\n           (if (= (first x) m)\r\n             (rest x)\r\n             x)))))))", "problem": 108, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn hoge [& cols]\n      (letfn [(max-first [cols]\n\t\t\t       (apply max (map first cols)))\n\t\t   (first-eq? [cols]\n\t\t\t      (apply = (map first cols)))\n\t\t   (drop-while-max-first [x cols]\n\t\t\t      (drop-while #(> x %) cols))]\n\t\t   (let [x (max-first cols)]\n\t\t\t(if (first-eq? cols)\n\t\t\t    x\n\t\t\t    (apply hoge (map #(drop-while-max-first x %) cols))))))", "problem": 108, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "#((fn f[[[a & r] & c]]\n            (if (apply = a (map first c))\n              a\n              (f (sort-by first (conj c r)))))\n          (sort-by first %&))", "problem": 108, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn min-in [& a]\n  (let [curmax (apply max (map first a))\n        nexts (map (fn [s] (drop-while #(< % curmax) s)) a)]\n    (if (apply = (map first nexts))\n      (ffirst nexts)\n      (apply min-in nexts))))", "problem": 108, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn __ [& colls]\r\n  (if (some empty? colls)\r\n    ()\r\n    (let [firsts (map first colls)\r\n          max-first (apply max firsts)]\r\n      (if (apply = firsts)\r\n        max-first\r\n        (apply __ (map (fn [coll] (drop-while #(> max-first %) coll)) colls))\r\n        ))))", "problem": 108, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn lazy-search\n  [& sequences]\n  (letfn [(lazy-intersection\n            ([xs]\n               xs)\n            ([xs ys]\n               (lazy-seq\n                (when (and (seq xs) (seq ys))\n                  (let [x (first xs)\n                        y (first ys)]\n                    (cond\n                     (= x y) (cons x (lazy-intersection (rest xs) (rest ys)))\n                     (< x y) (lazy-intersection (rest xs) ys)\n                     :else (lazy-intersection xs (rest ys)))))))\n            ([xs ys & more]\n               (apply lazy-intersection (lazy-intersection xs ys) more)))]\n    (first (apply lazy-intersection sequences))))", "problem": 108, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn minc [& ss]\r\n  (let [s (sort-by first ss)\r\n        f (first s)]\r\n    (if (apply = (map first s))\r\n      (first f)\r\n      (apply minc (rest f) (rest s)))))", "problem": 108, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn this\r\n   ([x] (this x x))\r\n   ( [ x & more] (loop [n1 x other (seq  more)]\r\n                   \r\n                   (if (reduce (fn this ([a b] (and a b)) ) (map  #(= (first %) (first n1) ) other))\r\n                   \r\n                     ; (if true\r\n                     (first n1)\r\n                     (recur\r\n                       (if (reduce #(or %1 %2) (map #(< (first %) (first n1) ) other))   n1 (rest n1)  )\r\n                       (map #(if (< (first %) (first n1)) (rest %) % ) other)\r\n                       )))))", "problem": 108, "user": "50463347e4b011c5dfee771e"}, {"code": "(fn [& colls]\n  (inc (last (for [ans (range) :while (not \n                                  (every? identity (for [c colls] (last\n                                                     (for [x c :while (<= x ans)] (= x ans))))))] ans\n          ))))", "problem": 108, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [& nss]\n  (letfn [\n    (same-first [nss]\n      (apply = (map first nss)))\n    (drop-min-first [nss]\n      (let [nss' (sort-by first nss)]\n        (cons (rest (first nss')) (rest nss'))))\n    (find-min [nss]\n      (if (same-first nss)\n        (first (first nss))\n        (recur (drop-min-first nss))))]\n    (find-min nss)))", "problem": 108, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn [& l] \r\n    (let [fs (map first l)\r\n          f  #(if (= (first %) (apply max fs)) % (next %))]\r\n      (if (apply = fs) (first fs)\r\n        (recur (map f l)))))", "problem": 108, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn ls [& colls]\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls)))))", "problem": 108, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [& colls]\n  (let [firsts (map first colls)\n        smallest (apply min firsts)]\n    (if (every? #{smallest} firsts)\n      smallest\n      (let [f #(if (= smallest (first %)) (rest %) %)]\n        (recur (map f colls))))))", "problem": 108, "user": "5014754de4b094324338f8e5"}, {"code": "(fn lazy-search [& xss]\n  (let [fsts (map first xss)]\n    (if (apply = fsts)\n      (first fsts)\n      (let [max-fst (apply max fsts)]\n        (apply lazy-search (map (partial drop-while #(< % max-fst))\n                                xss))))))", "problem": 108, "user": "50586354e4b06522596eba78"}, {"code": "(fn f [& s]\n  (let [fs (map first s)\n        mn (apply min fs)\n        mx (apply max fs)]\n  (if ( = mn mx)\n      mn\n      (apply f (map #(if (= mn (first %)) (rest %) %) s)))))", "problem": 108, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [col1 & cols]\n  (let [chk (fn [a col] \n              (= a (first (drop-while #(< % a) col))))]\n    (loop [col1 col1 cols cols]\n      (if (seq cols)\n          (if (every? #(chk (first col1) %) cols)\n              (first col1)\n              (recur (rest col1) cols))\n          (first col1)))))", "problem": 108, "user": "50435689e4b034ff00315d21"}, {"code": "(fn f [& xs]\n  (if (apply = (map first xs))\n    (first (first xs))\n    (let [m (apply max (map first xs))]\n      (println m)\n      (apply f (map (fn [x] (drop-while #(< % m) x)) xs)))))", "problem": 108, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn [& ss]\n  (letfn [(drop-min [ss] (apply cons ((juxt nfirst rest) (sort-by first ss))))\n          (heads-equal? [ss] (apply = (map first ss)))]\n    (loop [ss ss]\n      (if (heads-equal? ss)\n        (ffirst ss)\n        (recur (drop-min ss))))))", "problem": 108, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn lazy-search [& args]\n  (letfn [(find-common [n xs]\n            (first (first \n              (filter\n                #(= n (count %))\n                (vals (group-by identity xs))))))\n          (get-next [accum args]\n            (println \"accum \" accum)\n            (let [v (find-common (count args) accum)\n                  min-val (apply min (map first args))\n                  min-count (count (filter #(= % min-val) (map first args)))]\n              (if (not (nil? v))\n                v\n                (recur (into accum (repeat min-count min-val)) \n                  (map #(if (= (first %) min-val) (rest %) %) args)))))]\n    (get-next [] args)))", "problem": 108, "user": "501c1492e4b086d93747d180"}, {"code": "(fn my-fn [& ss]\n  (let [gd (group-by first ss)]\n    (if (= 1 (count gd))\n      (first (keys gd))\n      (apply my-fn (apply concat (vals \n        (conj gd (let [min-key (apply min (keys gd))]\n          [min-key (map next (gd min-key))]))))))))", "problem": 108, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [l & ls] (let [in?\n                    (fn [n]\n                     (if (every? #{n} (map #(last (take-while (partial >= n) %) ) ls )) n false))]\n                (if (empty? ls) (first l)\n                    (some in? l ))))", "problem": 108, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [& args]\n  (loop [in args]\n    (if (every? (complement empty?) in)\n(let [heads (map first in) x (apply max heads)]\n(if (apply = x heads)\nx\n(recur (map (fn [i] (drop-while #(< % x) i)) in))\n))\n'nuttin)))", "problem": 108, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn [& s]\n  ((fn [c]\n     (let [f (map first c) m (apply min f)]\n       (if (apply = f)\n         (ffirst c)\n         (recur (map #(if (= m (first %)) (rest %) %) c))))) s))", "problem": 108, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn [& [x & xs]] \n  (if xs \n    (first (filter \n      #(= % (->> xs \n                (map (fn [x] (first (drop-while (partial > %) x)))) \n                (filter number?) \n                (apply max))) \n      x)) \n    (first x)))", "problem": 108, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn [l & r]\n  (letfn [(my-some [n l]\n                 (loop [l l]\n                   (cond\n                     (> (first l) n) nil\n                     (= (first l) n) n\n                     :else (recur (rest l)))))\n\n        (all-have? [n r]\n                   (every? #(my-some n %) r))]\n  (loop [l l]\n    (if (all-have? (first l) r)\n        (first l)\n        (recur (rest l))))))", "problem": 108, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn minel [& seqs]\n  (letfn [(intersect-increasing [s1 s2]\n            (let [[x & xs] s1\n                  [y & ys] s2]\n              (lazy-seq\n                (cond (< x y) (intersect-increasing xs s2)\n                      (> x y) (intersect-increasing s1 ys)\n                      :else   (cons x (intersect-increasing xs ys))))))]\n    (first (reduce intersect-increasing seqs))))", "problem": 108, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn [& colls]\n  (->> [(ffirst colls) colls]\n       (iterate (fn [[_ [[n & ns :as c] & r]]]\n                  (if (empty? c)\n                    []                    \n                    [n `[~ns ~@(map #(drop-while (fn [x] (< x n)) %) r)]])\n                  ))\n       (take-while #(not= [] %))\n       (some (fn [[n [f & colls]]]\n                        (if (apply == n (map first colls))\n                          n)))))", "problem": 108, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "#(loop [s %&]\n  (if (apply = (map first s))\n      (ffirst s)\n      (recur (sort-by first (cons (nfirst s) (rest s))))))", "problem": 108, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn ls [& colls]\n  (let [firsts (map first colls)\n        m (apply min firsts)]\n    (if (apply = firsts)\n      m\n      (apply ls (map (fn [[f & r :as c]] (if (= m f) r c)) colls)))))", "problem": 108, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn f [& s]\r\n  (let [m (into #{} (map first s))]\r\n    (if (= 1 (count m))\r\n      (first m)\r\n      (let [m (apply min m)\r\n            s (map #(if (= m (first %)) (rest %) %) s)]\r\n        (recur s)))))", "problem": 108, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn [a & more]\n   (letfn [(in-seq? [n s]\n                    (= n (first (drop-while #(< % n) s))))]\n     (some (fn [i]\n               (if (= (count (cons a more)) \n                      (count (filter #(not (nil? %)) (map #(if (in-seq? i %) %) (cons a more)))))\n                   i))\n           a)\n   )\n)", "problem": 108, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn [ & seqs]\n  (loop [seqs (sort-by first seqs)]\n    (if (apply = (map first seqs))\n      (first (first seqs))\n      (recur (sort-by first (cons (rest (first seqs)) (rest seqs)))))))", "problem": 108, "user": "503a234de4b088a6a14ca76d"}, {"code": "(fn [& ss]\n    ;; take first element of each; if = then finished\n    ;; else calc max of these, and drop-while < this for each seq, recurse\n    (loop [ss ss]\n      (let [hds (map first ss)]\n        (if (apply = hds)\n          (first hds)\n          (recur (map (partial drop-while #(< % (apply max hds))) ss))))))", "problem": 108, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn [& ss]\n  (let\n    [\n      ss-sorted (sort-by first ss)\n      found (into #{} (map (fn [s] (some #(if (>= % (ffirst ss-sorted)) % false) s)) ss))\n    ]\n    (if (= 1 (count found))\n      (first found)\n      (recur (cons (rest (first ss-sorted)) (rest ss-sorted)))\n    )\n  )\n)", "problem": 108, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [& colls]\r\n  (letfn [(largest [colls]\r\n            (apply max (map first colls)))]\r\n    (loop [colls colls\r\n           n (largest colls)]\r\n      (if (every? #(= n (first %)) colls)\r\n        n\r\n        (let [colls2 (map #(if (and (not (empty? %))\r\n                                    (> n (first %)))\r\n                             (rest %)\r\n                             %)\r\n                          colls)]\r\n          (recur colls2 (largest colls2)))))))", "problem": 108, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn lazysearch [& lazyseqs]\n  (loop [lazyseqs lazyseqs]\n\t\t(let [starts (into [] (map first lazyseqs))\n\t\t\t  smallestn (.indexOf starts (apply min starts))]\n\t\t\t(if (apply = starts) (first starts)\n\t\t\t\t(recur (map #(if (= smallestn %1) (rest %2) %2) (iterate inc 0) lazyseqs))\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 108, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [& coll]\r\n  (let [m (apply max (map first coll))]\r\n\t\t(if\t(apply = (map first coll)) m\r\n\t\t\t(recur\r\n\t\t\t\t(map \r\n\t\t\t\t\t#(if (= (first %) m) % (rest %)) coll)))))", "problem": 108, "user": "4f3242bae4b0d6649770a08f"}, {"code": "(letfn [ (m[c] (apply max (map first c)))\n         (dc[n c] (map #(drop-while (fn[a] (< a n)) %) c))]\n   (fn ss[ & c]\n     (loop[ c c]\n       (let[ x (m c)]\n         (if (every? #(= x (first %)) c) x (recur (dc x c)))))))", "problem": 108, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [base & xs]\n  (if-not xs\n    (first base)\n    (first (first\n      (filter #(= (count xs) (count %))\n        (for [x base ]\n          (for [r xs \n                y r \n                :while (<= y x) \n                :when (= y x)] x)))))))", "problem": 108, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "(fn lazy-searching [& seqs]\n  (loop [rst (first seqs)]\n    (when-not (empty? rst)\n      (let [fst (first rst)]\n        (if (every?\n             (fn [x] (= fst (first (drop-while #(< % fst) x))))\n             (rest seqs))\n          fst\n          (recur (rest rst)))))))", "problem": 108, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [& colls]\n  (letfn [(lazy-has [[f & r :as c] x] ; we know c is a lazy-seq that is increasing\n            (if (< x f)\n              false\n              (or (= x f) (lazy-has r x))))\n          (all-has? [cs x]\n            (reduce (fn [has c] (and has (lazy-has c x)))\n                    true\n                    cs))]\n  (some\n    #(and (all-has? (rest colls) %) %)\n    (first colls))))", "problem": 108, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [& x]\n  (loop [s x]\n    (let [[f & r] s]\n      (if (apply = (map first s))\n          (first f)\n          (recur (cons (rest f) (map #(drop-while (partial > (second f)) %) r)))))))", "problem": 108, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "(fn f [& lists] (let [sorted (sort-by first lists)]\n  (if (= (first (first sorted)) (first (last sorted)))\n    (first (first sorted))\n    (apply f\n      (cons (rest (first sorted)) (rest sorted))))))", "problem": 108, "user": "4fb1325de4b081705acca276"}, {"code": "(fn lazy-search[& args]\r\n  (let [filt (fn [elem seq] (let [a (atom 0)] (while (and (or (= (counted? seq) false) (< @a (count seq))) (> elem (nth seq @a))) (swap! a inc))  (= elem (nth seq @a))))\r\n        check (fn [elem] (let [a (atom 1) b (atom true)] (while (< @a (count args)) (do (swap! b #(if (= (filt elem (nth args @a)) false) false %)) (swap! a inc))) @b))\r\n        a (atom -1) b (atom false)]\r\n(while (= @b false) (do (swap! a inc) (swap! b #(if (= (check (nth (first args) @a)) true) true % )))) (nth (first args) @a)))", "problem": 108, "user": "5065bd94e4b0148eb3925aed"}, {"code": "(fn ls [s & ss]\n  (let [\n        search (fn [n s] (first (remove nil? (for [x s :while (<= x n)] (if (= x n) x)))))\n        search-all (fn [n seqs] (apply = n (map (partial search n) seqs)))]\n   (loop [x (first s) tail (rest s)]\n     (let [ans (search-all x ss)]\n       (if ans\n         x\n         (recur (first tail) (rest tail)))))))", "problem": 108, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn l [& s]\n  (let [m (apply min (map first s))]\n    (if (every? #(= % m) (map first s))\n        m\n        (apply l (map #(if (> (first %) m) % (rest %)) s)))))", "problem": 108, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn least [& colls]\n  (let [m (apply max (map first colls))]\n    (if (reduce #(and %1 (= (first %2) m)) true (map #(remove (fn [n] (< n m)) %) colls)) m\n      (apply least (map #(filter (fn [n] (> n m)) %) colls)))))", "problem": 108, "user": "505dcfc8e4b0e6aca564be0d"}, {"code": "(fn [& a]\n  (let [m (group-by first a)\n        k (->> m keys (apply min))]\n    (if (= 1 (count m))\n      k\n      (recur (map #(if (= (first %) k) (rest %) %) a))\n  )))", "problem": 108, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn solution [aFirstColl & aOtherColls]\r\n  (if (= aOtherColls nil) (first aFirstColl)\r\n    ((fn func1 [aFirstColl]\r\n       (if (every? #((fn func2 [aColl]\r\n                      (if (< (first aFirstColl) (first aColl))\r\n                        false\r\n                        (if (= (first aFirstColl) (first aColl))\r\n                          true\r\n                          (func2 (rest aColl))))) %) aOtherColls)\r\n          (first aFirstColl)\r\n         (func1 (rest aFirstColl)))) aFirstColl)))", "problem": 108, "user": "505dd5c4e4b0e6aca564be0e"}, {"code": "(fn f [ & args]\n (let [rel (ffirst args)\n       rst (map (fn [x] (drop-while #(< % rel) x)) args)]\n   (if (apply = (map first rst))\n     rel\n     (apply f (cons (drop 1 (first rst)) (rest rst))))))", "problem": 108, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [& vs]\n  (loop [ks (repeat (count vs) 0)]\n    (if (apply = (map nth vs ks))\n        (nth (first vs) (first ks))\n      (recur (let [mini (apply min-key #(nth (nth vs %) (nth ks %)) (range (count vs)))]\n                (for [i (range (count vs))\n                      :let [k (nth ks i)]]\n                  (if (= i mini) (inc k) k)))))))", "problem": 108, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [& ss]\n  (loop [ss ss]\n    (let [firsts (map first ss)\n          v (apply max firsts)\n          vss (map (partial drop-while (partial > v)) ss)]\n      (if (apply = firsts) v (recur vss)))))", "problem": 108, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn sm [& colls]\n  (let [ms (map first colls)\n        m (apply min ms)]\n   (if (apply = ms)\n    (ffirst colls)\n    (apply sm (map #(if (= m (first %))\n                (rest %)\n                %) \n             colls)))))", "problem": 108, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn [& ss]\r\n  (let [\r\n    [x & xs] (sort-by first ss)\r\n    ]\r\n    (if (apply = (map first ss)) (first x)\r\n      (recur (cons (rest x) xs)))))", "problem": 108, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn f [& l] (let [m (first (apply map max l)) g (fn [x] (map (fn [r] (drop-while #(< % x) r)) l)) r (g m)] (if (apply = (map first r)) m (apply f (g (inc m))))))", "problem": 108, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn lazy-search [& xss]\n  (letfn [(my-merge [xs ys]\n            (lazy-seq \n             (if (or (empty? xs) (empty? ys))\n               ()\n               (let [[x & x-more] xs\n                     [y & y-more] ys]\n                 (cond\n                  (= x y) (cons x (my-merge x-more y-more))\n                  (> x y) (my-merge xs y-more)\n                  :else (my-merge x-more ys))))))]\n    (first (reduce my-merge (first xss) (next xss)))))", "problem": 108, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(letfn [(merge [l m]\r\n         (cond (empty? l) m\r\n\t\t     (empty? m) l\r\n\t\t     (< (first l) (first m)) (lazy-seq (cons (first l) (merge (rest l) m)))\r\n\t\t     (> (first l) (first m)) (lazy-seq (cons (first m) (merge l (rest m))))\r\n\t\t     :else (lazy-seq (cons (first m) (merge (rest l) (rest m))))))\r\n\t(find [n l]\r\n\t      (= n (last (take-while #(<= % n) l))))]\r\n       (fn [& l] (first (drop-while (fn [a] (not-every? (partial find a) l)) (reduce merge l)))))", "problem": 108, "user": "507437c2e4b054001656acd0"}, {"code": "(fn [& seqs]\n    (let [incsmallest\n          (fn [seqs]\n            (let [smallest (apply min (map first seqs))]\n              (map #(if (= (first %)\n                           smallest)\n                      (next %)\n                      (identity %))\n                   seqs)))\n          ]\n      (first (map ffirst\n                  (filter #(apply = (map first %))\n                          (iterate incsmallest seqs))))))", "problem": 108, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn find-smallest [& colls]\n  (loop [smallest (reduce max 0 (map first colls))]\n    (let [next-candidates (map #(\n                                 (fn find-or-next [n coll]\n                                   (first\n                                    (drop-while (fn [m] (< m n)) coll)))\n                                 smallest\n                                 %) colls)]\n      (if (= 1 (count (distinct next-candidates)))\n        (first next-candidates)\n        (recur (reduce max 0 next-candidates))))))", "problem": 108, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn g  [& args] (let [a (first args)]\r\n                     ((fn g2 [x y] \r\n   (if (not (empty? x))\r\n   (if \r\n    (empty?\r\n     (remove \r\n      #(= % 1) \r\n      (map \r\n       (fn kk [z] \r\n         (if (= (first x) (first z))\r\n           1 \r\n           (if \r\n             (< (first x) (first z)) \r\n             0\r\n             (kk (lazy-cat (rest z)) ) ))) \r\n       args)))\r\n                                      (first x)\r\n    (g2 (lazy-cat (rest x)) args ) ))) a args  )))", "problem": 108, "user": "50646c01e4b007509339a58b"}, {"code": "(fn lazy-search [& vs]\n  (loop [vectors vs]\n    (let [smalls (map first vectors)\n          smallest (apply min smalls)\n          max-smalls (apply max smalls)]\n    (if (= smallest max-smalls)\n      smallest\n      (recur\n        (map (fn [v] (drop-while #(< % max-smalls) v)) vectors))))))", "problem": 108, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn lazy-search [& colls]\n  (letfn [(findIt [x coll]\n                  (loop [c coll]\n                    (cond (empty? c) 0\n                          (= x (first c)) 1\n                          (< x (first c)) 0\n                          :else (recur (rest c)))))]  \n    (loop [c (first colls)]\n      (if (= 1 (reduce * (map (partial findIt (first c)) colls))) \n        (first c)\n        (recur (rest c))))))", "problem": 108, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [& args]\r\n  (letfn [(intr [xs ys]\r\n                (when (and xs ys)\r\n                  (let [[a & as] xs\r\n                        [b & bs] ys]\r\n                    (cond\r\n                      (< a b) (lazy-seq (intr as ys))\r\n                      (> a b) (lazy-seq (intr bs xs))\r\n                      :else (cons a (lazy-seq (intr as bs)))))))]\r\n    (first (reduce intr args))))", "problem": 108, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn lazy-search [& s]\n  (loop [seqs s]\n    (if (apply = (map first seqs))\n       (first (first seqs))\n       (let [min-num (apply min (map first seqs))]\n         (recur (map #(if (= (first %) min-num)\n                        (next %) %)\n                     seqs))))))", "problem": 108, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn f [& l]\n  (let [h (map first l)]\n    (if (apply = h) (first h)\n    (apply f (map #(if (= (apply max h) (first %)) % (rest %)) l)))))", "problem": 108, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn[c & o] (some #(if (not (nil? %)) %)  (for [i c] (if (every? #(= i %) (for [c2 o] (some #(if (>= % i) %) c2))) i))))", "problem": 108, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn lazy-searching [& vs]\n  (let [firsts    (map first vs)\n        max-first (apply max firsts)]\n    (if (apply = firsts)\n      max-first\n      (recur (map (fn [v]\n                    (filter #(>= % max-first) v)) vs)))))", "problem": 108, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [& s]\n  (#(if (first (apply map = %))\n        (ffirst %)\n        (recur (let [[x & r] (sort-by first %)]\n              (cons (rest x) r)))) s))", "problem": 108, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn [& c] \n    (letfn \n      [\n       (smallest [col] (apply min (map first col)))\n       (all-smallest [sv col] (reduce #(and %1 %2) (map #(= sv (first %)) col)))\n       (drop-smallest[sv col] (map #(drop-while (fn [x] (= sv x)) %) col))\n       ]\n      nil\n      (loop [ col c ]\n        (let [sml (smallest col)]\n          (if (all-smallest sml col)\n            sml\n            (recur (drop-smallest sml col)))))\n      ))", "problem": 108, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn [& colls]\n    (let [heads (map first colls)\n          m (apply max heads)]\n      (if (apply = heads)\n        m\n        (recur\n         (map (partial drop-while (partial > m)) colls)))))", "problem": 108, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "problem": 108, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn[x & xs]  \n  (letfn [\n    (has? [y ys] (= y (first (drop-while #(< % y) ys))))\n    (all-has? [y ys] (every? #{true} (map #(has? y %) ys)))]\n        \n    (loop [n x]      \n      (if (all-has? (first n) xs)        \n        (first n)\n        (recur (next n))))))", "problem": 108, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn test108 [& seqs]\n  (letfn [(max-first [seqs]\n            (apply max (map first seqs)))\n          (first-equal? [seqs]\n            (apply = (map first seqs)))\n          (update-seqs [x coll]\n            (if (> x (first coll))\n              (update-seqs x (rest coll))\n              coll))]\n    (let [curr (max-first seqs)]\n      (if (first-equal? seqs)\n        curr\n        (apply test108 (map #(update-seqs curr %) seqs))))))", "problem": 108, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn first-common [& seqs]\n  (let [sorted (sort-by first > seqs)\n        common (first (first sorted))\n        results (map (partial (fn find-in-sorted [val sq]\n  (== val (first (drop-while (fn [x]\n                               (< x val))\n                             sq))))\n                  (first (first sorted)))\n         (rest sorted))]\n    (if (some false? results)\n      (apply first-common\n             (cons (rest (first sorted))\n                   (rest sorted)))\n      common)))", "problem": 108, "user": "4e7e4a1f535db169f9c7970c"}, {"code": "(fn f\n   ([x] (first x))\n   ([x y] (f (map first (filter #(= (first %) (last %))\n                                (for [a x\n                                      b y\n                                      :while (>= a b)]\n                                  [a b])))))\n   ([x y z] (f x (map first (filter #(= (first %) (last %))\n                                  (for [a y\n                                        b z\n                                        :while (>= a b)] [a b]))))))", "problem": 108, "user": "5027b41ee4b01614d1633fee"}, {"code": "(letfn \n  [(c [v [a & b :as s]] \n      (and \n        (not (empty? s))\n        (or \n         (= v a)\n         (and\n          (> v a) \n          (c v b)))))\n  (x [[a & b] & m]\n     (if\n       (every? (partial c a) m)\n       a\n       (recur b m)))]\n  x)", "problem": 108, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn [x & xs]\n   (let [in? (fn in? [coll item]\n               (cond (empty? coll) false (= item (first coll)) true\n                     (< item (first coll)) false\n                     :else (in? (rest coll) item)))\n         in2? (fn [coll] (partial in? coll))\n         p (map in2? xs)\n         fp (fn ([fs y] (for [f fs] (f y))))\n         values (for [i x] [i (fp p i)])]\n     (first (first (take 1 (filter #(not (some false? (% 1))) (take 17 values)))))))", "problem": 108, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn this [& cols]\n  (let [in-all? (fn\n    [a [s & ss]]\n    (if (nil? s) true\n      (if (.contains s a)\n        (recur a ss)\n        false)\n      )\n    ) ; fn in-all?\n        first-is-equal (fn [ls]\n      (let [t1\n            (set\n              (for [i ls j ls]\n                (if (not (= (first i) (first j)))\n                  false\n                  (first i)\n                  ); if\n                ) ; for\n              ) ; set\n            ]\n        (if (.contains t1 false) false (first t1)))) ; fn first-is-equal\n\n        split-seq-less-than (fn [a [b & bs :as cs]]\n                               (if (nil? b)\n                               cs\n                               (if\n                                  (>= b a)\n                                  cs\n                                  (recur a bs))\n                               )\n                             ) ; fn split-seq-less-than\n        split (fn [x ls]\n      (map #(split-seq-less-than x %)\n        ls)) ; split\n                   resort (fn resort\n                               ([ls] (resort ls (apply max (map #(first %) ls))))\n                               ([ls mv]\n                                      (if (= (first (first ls)) mv)\n                                           (split mv ls)\n          (let [new-cols (reverse\n            (conj\n              (reverse\n                (rest ls)\n                ) ; reverse\n              (first ls)\n              ) ; conj\n            ) ; reverse\n                ]\n            (recur new-cols mv) ; recur\n            ) ; let\n          ) ; if\n        )\n      ) ; fn resort\n        min-common (fn mc [as ls]\n      (cond (empty? as) false\n        (in-all? (first as) ls) (first as)\n        :else\n        (let [new-cols (resort (conj (split (second as) ls) (rest as)))]\n          (recur (first new-cols) (rest new-cols)) ; recur\n          ) ; let\n        ) ; cond\n      ) ; fn min-common\n        ]\n    ; (min-common (first cols) (rest cols))\n    (let [new-cols (resort cols)\n          t1 (first-is-equal new-cols)\n          ]\n      (if t1\n        t1\n        (apply this (conj (rest new-cols) (rest (first new-cols))))))\n    ) ; let\n  ) ; fn", "problem": 108, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(let [until (fn [i l]\n              (if (empty? l)\n                nil\n                (if (>= (first l) i)\n                  (first l)\n                  (recur i (rest l)))))]\n  (fn [l & ls]\n    (first\n     (filter (fn [x]\n               (every? #(= (until x %) x) ls))\n             l))))", "problem": 108, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [& s] (if (apply = (map first s)) (first (first s))\n          (let [[q & w] (sort #(< (first %1) (first %2)) s)]\n            (recur (cons (rest q) w)))))", "problem": 108, "user": "50e82c31e4b0ebbe794eb7da"}, {"code": "#(let [[[h & t] & c] (sort-by first %&)]\n  (if (apply = (map first %&)) h (recur (conj c t))))", "problem": 108, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn [& colls]\n           (let [fs (map first colls)]\n             (if (apply = fs) (first fs)\n               (recur (update-in (vec colls)\n                                 [(.indexOf fs (apply min fs))]\n                                 rest)))))", "problem": 108, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn [& colls]\n  (letfn \n    [(mmerge [& colls]\n       (let [sorted (sort-by first colls)\n             [[x & r] & cs] sorted]\n         (cons x (lazy-seq (apply mmerge r cs)))))]\n    (ffirst (filter #(= (count colls) (count %)) (partition-by identity (apply mmerge colls))))))", "problem": 108, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn lazy-serch [& cols]\n  (if\n    (some empty? cols) \n    nil\n    (if (apply = (map first cols))\n      (ffirst cols)\n      (let [max (reduce max (map first cols))]\n        (apply lazy-serch (map #(if (= (first %) max)\n              %\n              (rest %)) cols))))))", "problem": 108, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn f\n  ([[a & ar]] a)\n  ([a b & args]\n    (letfn [(li [[x & xr :as xs] [y & yr :as ys]]  \n      (cond\n        (> x y) (recur xs yr)\n        (< x y) (recur xr ys)\n        :else (cons x (lazy-seq (li xr yr))) ))]\n      (first (reduce li a (cons b args)))\n\t\t)))", "problem": 108, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn lazy-search [& streams]\n  (let [firsts (map first streams) \n        max-val (apply max firsts)]\n    (if (apply = firsts) \n      max-val \n      (apply lazy-search (map (fn [stream] (drop-while #(< % max-val) stream)) streams)))))", "problem": 108, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [& ss]\n  (if (apply = (map first ss))\n    (ffirst ss)\n    (let [h (apply max (map first ss))]\n      (recur (map (fn [s] (filter #(>= % h) s)) ss)))))", "problem": 108, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [firsts (map first seqs)]\n      (if (apply = firsts)\n        (first firsts)\n        (let [sorted (sort-by first seqs)\n              [fs & rs] sorted]\n          (recur (cons (next fs) rs)))))))", "problem": 108, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [& lists]\n   (loop [ls lists]\n     (let [fs (map first ls)\n           m  (apply min fs)]\n       (if (apply = fs)\n       m\n       (recur \n        (map #(if (= (first %) m) (next %) %) ls))\n   ))\n   ))", "problem": 108, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn [& colls]\n    (loop [colls2 colls]\n      (if (apply = (map first colls2))\n        (first (first colls2))\n        (let [max-first (apply max (map first colls2))\n              colls2-filtered (map (fn [x] (drop-while #(< % max-first) x)) colls2)\n              ]\n          (recur colls2-filtered)      \n          ))))", "problem": 108, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn x [& s] \n  (let [h (map first s) mx (apply max h) mn (apply min h)] \n              (if (= mx mn) mn (apply x (map #(if (= (first %) mn) (rest %) %) s)))))", "problem": 108, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn f [x & xs]\n  (if (nil? xs)\n    (first x)\n    (some\n     (fn [y]\n       (if (every? (fn [z] (= y (last (take-while #(<= % y) z))))\n                   xs)\n         y))\n     x)))", "problem": 108, "user": "509160dae4b0742c82730aef"}, {"code": "(fn [& cs]\n  (loop [cs cs]\n    (let [fvs (map first cs)]\n      (if (apply = fvs) (first fvs)\n        (recur (map #(drop-while (partial = (apply min fvs)) %) cs))))))", "problem": 108, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn [& args]\n    (cond\n      (= 1 (count args)) (first (first args))\n      (= 2 (count args))\n        (loop [l1 (first args), l2 (second args)]\n          (println (first l1) (first l2))\n          (let [x (first l1), y (first l2)]\n            (cond\n              (= x y) x\n              (< x y) (recur (rest l1) l2)\n              (< y x) (recur l1 (rest l2))\n              )))\n      (= 3 (count args))\n        (loop [l1 (first args), l2 (second args), l3 (nth args 2)]\n          (println (first l1) (first l2) (first l3))\n          (let [x (first l1), y (first l2), z (first l3)]\n            (cond\n              (= x y z) x\n\n              (and (= x y) (< z x)) (recur l1 l2 (rest l3))\n              (and (= x y) (< x z)) (recur (rest l1) l2 l3)\n\n              (and (= y z) (< x z)) (recur (rest l1) l2 l3)\n              (and (= y z) (< z x)) (recur l1 (rest l2) l3)\n\n              (and (= x z) (< y z)) (recur l1 (rest l2) l3)\n              (and (= x z) (< z y)) (recur l1 l2 (rest l3))\n\n              (and (< x y) (< x z)) (recur (rest l1) l2 l3) ; x < y && z\n              (and (< y z) (< y x)) (recur l1 (rest l2) l3) ; y < z && x\n              (and (< z x) (< z y)) (recur l1 l2 (rest l3)) ; z < x && y\n              )))\n      )\n    )", "problem": 108, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn f [& c]\n  (if (apply = (map first c))\n    (ffirst c)\n  \t(let [[a & b] (sort-by first c)]\n      (apply f (next a) b))))", "problem": 108, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn f [& args]\n   (let [\n      countable (filter counted? args)\n      not-countable (remove counted? args)\n      new-args (concat countable not-countable)\n      find-num (fn [n ss] \n         (every? true? (for [s ss] \n            (= n (last (take-while #(<= % n) s)))\n         ))  \n      )]  \n      (first (keep (fn [x] \n         (if (find-num x new-args)  \n            x   \n         )   \n      ) (first new-args)))\n   )   \n)", "problem": 108, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn [& args]\n   ((fn [seqs]\n      (if (apply = (map first seqs))\n        (ffirst seqs)\n      (let [sorted (sort-by first seqs)]\n        (recur (cons (nfirst sorted) (next sorted)))))\n    ) args)\n  \n )", "problem": 108, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn m [& s]\n    (let [[l h] (apply (juxt min max) (map first s))]\n      (if (= h l) l\n          (apply m (map (partial drop-while #(< % h)) s) ))))", "problem": 108, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn f [& s]\n  (let [l (apply min (map first s))\n        h (apply max (map first s))]\n    (if (= l h)\n      h\n      (apply f (map (partial drop-while #(< % h)) s)))))", "problem": 108, "user": "50ed4626e4b01236b1d4983c"}, {"code": "(fn f [& seqs]\n  (let [[first-seq & other-seqs :as sorted-seqs] (sort-by first seqs)]\n    (if (= (first first-seq) (first (last sorted-seqs)))\n      (first first-seq)\n      (recur (cons (rest first-seq) other-seqs)))))", "problem": 108, "user": "510db6cde4b078ea71921145"}, {"code": "(fn [& colls]\n  (loop\t[colls colls]\n    (if (apply = (map first colls))\n      (first (first colls))\n      (let [smallest-first (sort-by first < colls)]\n        (recur (cons (rest (first smallest-first)) (rest smallest-first)))))))", "problem": 108, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [& colls]\n  (let [get-firsts (fn [args] (first (apply map vector args)))]\n    (loop [colls colls]\n      (let [firsts (get-firsts colls)\n            least (apply min firsts)\n            culled (map #(drop-while (fn [n] (< n least)) %) colls)]\n        (if (apply = (get-firsts culled))\n          least\n          (recur (map #(drop-while (fn [n] (= n least)) %) culled)))))))", "problem": 108, "user": "51195e77e4b055cfb310d499"}, {"code": "(fn f [& seqs]\n  (if (apply = (map first seqs))\n    (ffirst seqs)\n    (let [sorted (sort-by first seqs)]\n      (apply f (conj (rest sorted) (drop 1 (first sorted)))))))", "problem": 108, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [& seqs]\n    (let [firsts (map first seqs)\n          max-firsts (apply max firsts)]\n      (if (apply = firsts)\n        max-firsts\n        (recur\n         (map #(if (< (first %) max-firsts) (rest %) %) seqs))))\n  )", "problem": 108, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn min-seqs [& s]\n  (loop [f (map first s)\n         r (map rest s)]\n    (if (apply = f)\n      (first f)\n      (let [m (first(keep-indexed #(if (= %2 (apply min f)) %1) f))\n            pf (take m f)\n            rf (drop m f)\n            pr (take m r)\n            rr (drop m r)]\n        (recur (concat pf (vector (ffirst rr)) (rest rf))\n               (concat pr (vector (nfirst rr)) (rest rr)))))))", "problem": 108, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [s & more]\n\t(letfn [(in? [s e] (= e (first (filter #(<= e %) s))))\n    \t(inall? [n ss] (every? #(in? % n) ss))]\n        (first (filter #(inall? % more) s))))", "problem": 108, "user": "4e8768f6535dceadca469850"}, {"code": "(fn l [& seqsinit]\n  (loop [minN 0 seqs seqsinit]\n    (if (apply = (map first seqs)) (first (first seqs))\n        (let [sorted (sort-by first seqs)\n              lowseq (first sorted)\n              lowseqfirst (first lowseq)]\n              (recur lowseqfirst (cons (rest lowseq)(rest sorted)))))))", "problem": 108, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn [& c]\n  (loop [l c] \n    (let [firstElements (map first l)\n          n (apply max firstElements)]\n      (if (apply = (conj firstElements n))\n        n \n        (recur\n          (map #(drop-while (fn [x] (< x n)) %) l)\n          )\n        )))\n  )", "problem": 108, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [& args]\n  (let [\n    \ta (fn b [l]\n            (if (apply = (map first l))\n              (first (first l))\n              (let [ll (sort-by first l)]\n                (b (cons (rest (first ll))(rest ll))))))]\n    (a args)))", "problem": 108, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn f\n  [& s]\n  (loop [a (vec s)]\n    (if (some nil? (map first a))\n      nil\n      (if (apply = (map first a))\n        (first (map first a))\n        (let [i (first (first (sort-by second (map-indexed (fn [j k] [j (first k)]) a))))]\n         (recur (assoc a i (drop 1 (nth a i)))))))))", "problem": 108, "user": "4f17ab99535d64f603146457"}, {"code": "(fn f [& seqs]\n  (let [n (map first seqs)\n        m (apply min n)]\n  (if (apply = n) (first n)\n    (apply f (map #(if (= (first %) m) (rest %) %) seqs)))))", "problem": 108, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn lazy-min [& xs]\n  (let [f (first xs)\n        r (rest xs)\n        contains? (fn [x coll] (= x (some #(when (<= x %) %) coll)))]\n      (loop [i 0]\n        (let [v (nth f i)]\n          (if (reduce #(and % (contains? v %2)) true r)\n            v\n            (recur (inc i)))))))", "problem": 108, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [& seqs]\n   (loop [elements (vec seqs)]\n\t   (let [first-seq (map first elements) ]\n\t     (let [min-num (apply min first-seq)]\n\t       (if (every? #(= min-num %) first-seq)\n          min-num\n          (recur (assoc elements (.indexOf first-seq min-num) (rest (nth elements (.indexOf first-seq min-num)))))\n          )\t       \n\t       )     \n\t     )\n   )\n   )", "problem": 108, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn lzs [& sqs]\n  (if (apply = (map first sqs))\n    (first (first sqs))\n    (let [sortedsqs (sort-by #(first %) sqs)]\n      (apply lzs (drop 1 (first sortedsqs)) (drop 1 sortedsqs)))))", "problem": 108, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn barf [& colls]\n      (let\n        [firsts (map first colls)\n         minimum (apply min firsts)\n         result (every? #(= minimum %) firsts)]\n        (if result\n          minimum\n          (apply barf (map #(if (= minimum (first %))\n                           (drop 1 %)\n                           %)\n                        colls)))))", "problem": 108, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn lazy-min [& seqs]\n  (loop [s seqs]\n    (let [fsts (map first s) m (apply max fsts)]\n      (if (apply = fsts) m\n        (recur (map #(if (> m (first %)) (rest %) %) s))\n      )\n    )\n  )\n)", "problem": 108, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn smallest [& xxs]\n  (let [look-for (fn [n, xs]\n                   (loop [xs xs]\n                     (if (< (first xs) n)\n                       (recur (rest xs))\n                       (= (first xs) n))))\n        fxs (first xxs)\n        rxs (rest xxs)]\n    (loop [fxs fxs]\n      (if (every? #(look-for (first fxs) %) xxs)\n        (first fxs)\n        (recur (rest fxs))))))", "problem": 108, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [& seqs]\n    (let [seqs (sort-by first > seqs)]\n      (if (apply = (map first seqs))\n        (ffirst seqs)\n        (let [g (ffirst seqs)]\n          (recur (map (fn [xs] (drop-while (fn [x] (< x g)) xs))\n                      seqs))))))", "problem": 108, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn [& [seq1 & seqs]]\n  (loop [[x & xs] seq1]\n    (cond\n     (every? (fn [ns] (= x (first (drop-while #(< % x) ns)))) seqs) x\n     :else (recur xs))))", "problem": 108, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn find-min [& ss] (loop [ss ss] \n(do (let [first-values (map first ss) \n          current-min (reduce min first-values)\n          current-max (reduce max first-values) \n          stop (apply = first-values)]\n(do (println first-values) \n    (if stop current-min (recur (map #(drop-while (fn[s](< s current-max)) %) ss))))))))", "problem": 108, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn p108[ & xs ]\n  (let [f     (map first xs)\n        f_min (apply min f)\n        f_max (apply max f)\n        ]\n    (if (= f_min f_max) f_min\n        (apply p108 (map (fn[x] (drop-while #(< % f_max) x)) xs)))))", "problem": 108, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn f[& y](let [a apply m map x (m first y) z (a max x) s #(< % z)] (if (a = x) z (a f(m #(drop-while s %) y)))))", "problem": 108, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn lazy-search\n    [& colls]\n    (let [firsto (map first colls)\n          mino (reduce min firsto)]\n        (if (apply = firsto) mino\n            (apply lazy-search (map #(if (= mino (first %)) (rest %) %) colls)))))", "problem": 108, "user": "50b35486e4b03ea88043356a"}, {"code": "(fn [& s]\n  ((fn [c]\n      (let [f (map first c) m (apply min f)]\n           (if (apply = f)\n             (ffirst c)\n             (recur (map #(if (= m (first %)) (rest %) %) c))))) s))", "problem": 108, "user": "5151aa14e4b03e678e393ad4"}, {"code": "(fn smallest \n  [& colv]\n    (let [veccols (vec colv)\n          hd (first (apply map vector colv))\n          minhd (apply min-key second (map-indexed vector hd))\n          smallestidx (first minhd)\n          smallestv (second minhd)\n          ]\n      (if (= (count hd) (count (filter #(= % smallestv) hd)))\n        smallestv\n\t\t(recur (concat (take smallestidx veccols)\n                       (drop (inc smallestidx) veccols)\n                       (vector (rest (veccols smallestidx))) )))))", "problem": 108, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn lazy-min [& args]\n  (if (apply = (map first args))\n    (ffirst args)\n    (let [max-val (apply max (map first args))]\n      (apply lazy-min (map #(if (= (first %) max-val)\n                              %\n                              (rest %)) args)))))", "problem": 108, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn [& p]\n  (loop [p p]\n(let [x (apply min (map first p))]\n  (if (apply = (map first p)) x\n    (recur (map #(if (= x (first %)) (rest %) %) p))\n    )\n  )\n)\n)", "problem": 108, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [& args]\n  (if (= (count args) 1) (first (first args))\n  (loop [setlist (map #(set [(first %)]) args)\n         ags args]\n    (let [mtch (apply clojure.set/intersection setlist)\n          mx (apply max (map first ags))]\n\n      (if (empty? mtch)\n       \n        (recur (map conj setlist (map first ags))\n               (map #(if (< (first %) mx) (rest %) %) ags))\n        (first mtch) )\n      ))))", "problem": 108, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn search-lazy [& colls]\n  ((fn a [colls]\n    (let [values (map first colls)]\n      (if (apply = values)\n        (first values)\n        (a (map-indexed #(if (= (.indexOf values (apply min values)) %1)\n                          (rest %2)\n                          %2) colls)))))\n    colls))", "problem": 108, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn leastCommonNumber\n  [& colls]\n  (let\n    [result (reduce\n      (fn\n        [re curColl]\n        (if \n          (not= (first curColl) (get re \"max\"))\n          {\"equal\" false\n           \"max\" (max (first curColl) (get re \"max\"))}\n          re\n        )\n      )\n      {\"equal\" true\n       \"max\" (-> colls first first)}\n      colls\n    )]\n    (if \n      (get result \"equal\")\n      (-> colls first first)\n      (apply \n        leastCommonNumber \n        (map #(if (= (get result \"max\") (first %)) % (drop 1 %)) colls)\n      )\n    )\n  )\n)", "problem": 108, "user": "5162757ee4b03cfa3774b3fe"}, {"code": "(fn lazy-search [& seqs]\n  (let [seq-mins      (map first seqs)\n        global-min    (apply min seq-mins)]  \n    (if (= 1 (count (distinct seq-mins)))\n      global-min\n      (apply lazy-search (map #(if (= (first %) global-min) (drop 1 %) %) seqs)))))", "problem": 108, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [& ss]\n   (loop [ss ss, fs (repeat (count ss) #{})]\n     (let [v (apply min (map first ss))\n           fs (map #(if (= v %2) (conj % v) %) fs (map first ss))\n           is (apply clojure.set/intersection fs)]\n       (if (seq is)\n         (first is)\n         (recur (map (partial drop-while #(= v %)) ss) fs)))))", "problem": 108, "user": "50f48298e4b004d364930527"}, {"code": "(fn check-all [& sequences]\n  (let [sortedseqs (sort-by first sequences)\n       lowestseq (first sortedseqs)\n       candidate-value (first lowestseq)\n       contained-values (for [sq sortedseqs]\n                          (filter #(= candidate-value %)\n                            (take-while #(<= % candidate-value) sq)))]\n    (if (not-any? empty? contained-values)\n      candidate-value\n    (apply check-all (rest (first sortedseqs)) (rest sortedseqs)))))", "problem": 108, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn sc [& l] (let [fi (map first l) fm (apply max fi)] (if (apply = fi) fm (apply sc (map #(if (< (first %) fm) (rest %) %) l)))))", "problem": 108, "user": "5134973ce4b0230e9f713b42"}, {"code": "(fn [& [c1 & cs]]\n  (letfn [(in? [x coll]\n            (-> (drop-while (partial > x) coll)\n                first\n                (= x)))\n          (in-cs? [x]\n            (every? (partial in? x) cs))]\n    (first (filter in-cs? c1))))", "problem": 108, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn lazy-search [& vs]\n  (if (some empty? vs)\n    nil\n    (let [firsts (map first vs)\n          minval (apply min firsts)]\n      (if (every? true? (map = firsts (repeat minval)))\n        (first firsts)\n        (apply lazy-search\n               (for [v vs]\n                 (if (> (first v) minval)\n                   v\n                   (rest v))))))))", "problem": 108, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn f [& seqs]\n  (let [mins (map first seqs)\n        m (apply min mins)\n        rseqs (map #(if (= (first %) m) (rest %) %) seqs)]\n    (if (= (count (set mins)) 1) m\n      (apply f rseqs))))", "problem": 108, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn smallest-common [& seqs]\n  (letfn [(update [x coll]\n            (if (> x (first coll))\n              (update x (rest coll))\n              coll))]\n    (let [curr (apply max (map first seqs))]\n      (if (apply = (map first seqs))\n        curr\n        (apply smallest-common (map #(update curr %) seqs))))))", "problem": 108, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [& colls]\n    (letfn [(drop-less-than [s n] (drop-while #(< % n) s) )\n            (next-seqs [seqs n] (map #(drop-less-than % n) seqs) )]    \n      (loop [seqs (seq colls)]  \n          (let [fs (map first seqs)]\n            (cond (apply = fs) (first fs) (some nil? fs) nil \n             :else (recur (next-seqs seqs (apply max fs))))))))", "problem": 108, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn lazysearch [& seqs]\n      (if (apply = (map first seqs))\n          (first (first seqs))\n          (let [reordered-seqs (sort-by first seqs)\n                first-seq-rem (rest (first reordered-seqs))\n                other-seqs (rest reordered-seqs)\n                new-seqs (conj other-seqs first-seq-rem)]\n               (recur new-seqs)))\n  )", "problem": 108, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn lazy-search\n  ([s] (apply min s))\n  ([s1 s2]\n   (loop [x s1]\n     (if (some #(= (first x) %) s2)\n       (first x)\n       (recur (rest x)))))\n  ([s1 s2 s3]\n   (let [x (take 70 s1)\n         y (take 10 s2)\n         z (take 70 s3)]\n     (loop [s x]\n       (if (and (some #(= (first s) %) y)\n                (some #(= (first s) %) z))\n       (first s)\n       (recur (rest s)))))))", "problem": 108, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn f [& seqs]\n  (if (apply = (map first seqs))\n    (ffirst seqs)\n    (let [m (apply max (map first seqs))]\n      (apply f (map (partial drop-while (partial > m)) seqs)))))", "problem": 108, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn r [& s] \n  (let [f (map first s)] \n    (if (apply == f) \n      (first f) \n      (recur \n       (map #(if (< (first %) (apply max f)) (rest %) %) \n            s) ))))", "problem": 108, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [& args] \n   (loop [seqs args]\n     (let [heads    (map first seqs)\n           min-head (apply min heads)]\n       (if (every? #(= min-head %) heads)\n         min-head\n         (let [tails (map #(if (= min-head (first %)) (rest %) %) seqs)]\n           (recur tails))))))", "problem": 108, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn lazy-search [& args]\n  (let [all-h (map first args)\n        least-h (reduce #(if (< %1 %2) %1 %2) all-h)]\n    (if (apply = all-h)\n      least-h\n      (apply lazy-search (map #(if (= least-h (first %))\n                                 (drop 1 %)\n                                 %)\n                              args)))))", "problem": 108, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [& s]\n  (loop [seqs s]\n    (if (apply = (map first seqs))\n      (first (first seqs))\n      (let [max_first (apply max (map first seqs))]\n        (recur (map #(loop [remaining %]\n                       (if (>= (first remaining) max_first)\n                         remaining\n                         (rest remaining))) seqs))))))", "problem": 108, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn mini [ & l] \n  (let [firstlist (map first l)\n        currentmini (apply min firstlist)]\n        (if (apply = firstlist)\n          currentmini\n          (apply mini (map #(drop-while (partial = currentmini) %) l)))))", "problem": 108, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn f [& i]\n    (let [a (map first i)]\n                (if (apply = a)\n                  (first a)\n                  (apply f (map #(if (< (first %) (apply max a) ) (rest %) % )  i)))\n                )\n              )", "problem": 108, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "problem": 108, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn search\n  ([v] \n   (first v))\n  ([v & vs]\n    (apply search \n           (cons \n            (filter \n             (fn [n]\n               (some #(= n %) (take-while #(<= % n) v)))\n             (first vs))\n            (rest vs)))))", "problem": 108, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [& s]\n  ((fn [c]\n      (let [f (map first c) m (apply min f)]\n           (if (apply = f)\n             (ffirst c)\n             (recur (map #(if (= m (first %)) (rest %) %) c))))) s))", "problem": 108, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn lazy-search [& colls]\n (let [nums (map first colls)]\n   (if (and (every? integer? nums) (apply = nums))\n     (first nums)\n     (recur (map (fn [coll]\n                   (drop-while #(< % (apply max nums)) coll))\n                 colls)))))", "problem": 108, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [& vs] \n(loop [v vs]\n (if (apply = (map first v))\n        (first (map first v ))\n  (recur (map  (fn [x] (drop-while \n #(< % (apply max (map first v)))\nx)) v)))))", "problem": 108, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (if (apply = (map first seqs))\n      (ffirst seqs)\n      (let [[seq & more] (sort-by first seqs)]\n        (recur (cons (rest seq) more))))))", "problem": 108, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn lazy-search\n  [& colls]\n  (let [m (sort-by first colls)\n        v (first (first m))]\n    (if (apply = (map first m))\n      v\n      (apply lazy-search (map #(if (= v (first %)) (rest %) %) m)))))", "problem": 108, "user": "4f03f197535dcb61093f6b84"}, {"code": "(fn min-common [& args]\n  (let [heads (map first args)\n        small (apply min heads)]\n    (if (apply == heads) (first heads)\n      (apply min-common (for [s1 args] \n        (if (== (first s1) small) (rest s1)\n          s1))))))", "problem": 108, "user": "516db4f6e4b046df6fbb76a0"}, {"code": "(fn [a & args]\n  (if (empty? args)\n    (first a)\n    (loop [ar a]\n      (if (empty? ar)\n        nil\n        (if (every? #(= (first ar) %1)\n                    (map (fn [s] (first (filter #(<= (first ar) %1) s))) args))\n          (first ar)\n          (recur (rest ar)))))))", "problem": 108, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn lazy-min-common [& seqs]\n  (let [target (apply max (map first seqs))\n        new-seqs (map (fn [s] (drop-while #(< % target) s)) seqs)]\n    (if (apply = (map first new-seqs))\n      target\n      (recur new-seqs))))", "problem": 108, "user": "50a2f901e4b029e8bace362a"}, {"code": "(fn sm [& cs]\n  (letfn [(find? [cols n] (apply = n (for [col cols] (first col))))\n          (m-value [cols] (apply min (for [col cols] (first col))))]\n    (loop [cs cs]\n      (let [n (m-value cs)]\n        (if (find? cs n)\n          n\n          (recur (for [c cs] (if (= n (first c)) (rest c) c))))))))", "problem": 108, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [& start-colls]\n  (loop [colls start-colls]\n    (if (apply = (map first colls))\n      (first (first colls))\n      (let [[[smallest & more-from-smallest] & more-colls] (sort-by first colls)]\n        (recur (conj more-colls more-from-smallest))))))", "problem": 108, "user": "51aa2b4fe4b04e3dc0c27b21"}, {"code": "(fn [& s]\n  (loop [s s]\n    (if (every? #(= (first %) (ffirst s)) s) \n      (ffirst s)\n      (let [t (sort-by first s)]\n            (recur (cons (rest (first t)) (rest t)))))))", "problem": 108, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn lazy-min ([& xss] (if (apply = (map first xss)) \n                        (first (first xss))\n                        (let [x (apply min (map first xss))]\n                          (apply lazy-min (map #(if (= (first %) x) (rest %) %) xss))))))", "problem": 108, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn [& ls]\n  (let [l (apply max (map first ls))\n        ls (map (fn [ls](drop-while #(> l %) ls)) ls)]\n    (if (apply = (list* l (map first ls)))               \n      l\n      (recur ls))))", "problem": 108, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn [& x]\n  (loop [l x\n         b (repeat (count l) #{})]\n    (let [h (map first l)\n          m (apply min h)\n          a (map #(if (= m (first %)) (conj %2 m) %2) l b)]\n      (if (every? #(contains? % m) a)\n        m\n        (recur\n          (map #(if (= m (first %)) (rest %) %) l)\n          a)))))", "problem": 108, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [ & vectors]\n  (letfn [(nextv [v i]\n                 (if (< (first v) i)\n                   (rest v)\n                   v)\n                 )]\n\t  (loop [vs vectors]\n\t    (let [fv (map first vs)\n\t          m (apply max fv)]\n        (if (apply = fv)\n\t        m\n\t        (recur (map #(nextv % m) vs))\n\t        )\n\t      )\n\t    )\n  )\n  )", "problem": 108, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn\n   [& seqs]\n   (let [target (count seqs)]\n     (loop [existing [] new (map first seqs) futurea (map rest seqs)]\n       (let\n           [maxa         (apply max new)\n            maxb         (if (> (count new) 1)\n                           (apply max (disj (set new) maxa))\n                           maxa)\n            new-existing (apply conj existing new)\n            grouped      (group-by identity new-existing)\n            candidates   (keys (filter #(= target (count (val %))) grouped))\n            ]\n         (if (empty? candidates)\n           (recur\n            new-existing\n            (remove nil? (map first futurea))\n            (map (fn [seqa] (remove #(< % maxb) (rest seqa))) futurea))\n           (apply min candidates))))))", "problem": 108, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn [& seqs]\n  (cond (some empty? seqs) nil\n        (apply = (map first seqs)) (ffirst seqs)\n        :else (let [biggest (apply max (map first seqs))]\n                (recur (map (fn [s] (if (not (= biggest (first s))) (rest s) s)) seqs)))))", "problem": 108, "user": "51672d15e4b079759a74a5e7"}, {"code": "(letfn [\n    (match? [x s] (or (= x (first s)) (and (> x (first s)) (recur x (rest s)))))\n    (first-common [s1 & sn] (first (drop-while #(not-every? (partial match? %) sn) s1)))]\n    first-common)", "problem": 108, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [& colls]\n  (let [firsts (map first colls)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur (map #(drop-while (partial > (apply max firsts)) %)\n                  colls)))))", "problem": 108, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn [ & seqs ]\n  (loop [s seqs]\n    (let [f (map first s)\n          v (apply max f)]\n      (if (every? #(= % v) f)\n        v\n        (recur (map (fn [i] (drop-while #(< % v) i)) s))))))", "problem": 108, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn [& args]\n  (let [items (map first args)\n        largest (apply max items)]\n    (if (apply = items)\n      (first items)\n      (recur (map (partial drop-while #(< % largest)) args)))))", "problem": 108, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn lazy-search [& colls]\n  (let [f-coll (map first colls)]\n    (if (every? #(= (first f-coll) %) f-coll)\n      (first f-coll)\n      (let [s-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first s-colls)) (rest s-colls)))\n       )\n     )\n   ))", "problem": 108, "user": "51da7e49e4b02ceefd947768"}, {"code": "(fn __ [& c]\n  (loop [s c]\n    (let [f (map first s)\n          m (apply max f)]\n      (if (every? #(= m %) f) m\n          (recur (map (fn [x] (drop-while #(< % m) x)) s))))))", "problem": 108, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn ls [ & args]\n  (let [f (fn [y mn] (map (fn [x] (filter #(> % mn) x)) y))]\n    (loop [mx (apply min (map first args)) args args]\n      (if (apply = (map first args))\n        (first (first args))\n        (recur (apply min (map first (f args mx))) (f args mx))))))", "problem": 108, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [& colls]  \n  (letfn [(max-elem [colls]\n            (apply max (map first colls)))\n          (drop-while-smaller [n colls]\n            (for [c colls] (drop-while #(< % n) c)))\n          (eq-first-elems? [colls]\n            (apply = (map first colls)))]\n    (loop [colls colls]\n      (if (eq-first-elems? colls) (ffirst colls)\n        (let [m (max-elem colls)\n              tails (drop-while-smaller m colls)]\n          (recur tails))))))", "problem": 108, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [& c] (first (apply clojure.set/intersection\n                        (map #(set (take-while (partial > 99) %)) c))))", "problem": 108, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn mm [& s] \n  \t  \t\t(let [ss (map #(first %) s)] \n  \t  \t(letfn [(adjust [s ss1]\n  \t      (let [mins ( apply min ss1)] \n  \t      \t(map   #(if  (= mins  (first %))     (rest % ) %)   s) ))]\n  \t  \t(if (apply = ss) (first ss) \n  \t  \t(apply  mm (adjust s ss))))\n  \t  ))", "problem": 108, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn [& args]\n    (let [hs (map first args) min-h (apply min hs)]\n      (if (apply = hs)\n        (first hs)\n        (recur (map #(if (= (first %) min-h) (rest %) %) args))))\n)", "problem": 108, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [& xss] ;assume there's always one such number\n  (loop [xss xss]\n    (let [s (distinct (map first xss))]\n      (if (= (count s) 1)\n        (first s)\n        (let [[[x & xs] & xss] (sort-by first xss)]\n          (recur (conj xss xs)))))))", "problem": 108, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn [& args]\n  (loop [ls args]\n   (let [fs (map first ls)]\n     (if (some nil? fs)\n       nil\n       (if (apply = fs)\n         (first fs)\n         (recur (let [m (apply min fs)]\n                  (for [l ls]\n                    (if (= m (first l))\n                      (rest l)\n                      l)))))))))", "problem": 108, "user": "50b1d166e4b03ea880433554"}, {"code": "(fn [& seqs]\n  (if (apply = (map first seqs)) \n    (first (first seqs))\n    (recur (map #(drop-while (partial > (second (first seqs))) %) seqs))))", "problem": 108, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn m [& vs]\n   (let [fs (map #(first %) vs)]\n     (if (apply = fs)\n       (first fs)\n       (apply m (map #(if (= (first %) (apply min fs)) (rest %) %) vs )))))", "problem": 108, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn [& l]\n  (let [common-min (fn [l] (first (filter number?\n                                          (for [val (first l)]\n                                            (when (= (count l) (count (filter #(some #{val} %) l)))\n                                              val)))))]\n    (loop [ls l\n           ls-acc (vec (repeat (count l) []))]\n      (if-let [return (common-min ls-acc)]\n        return\n        (let [tofind (when (every? #(not (empty? %)) ls-acc)\n                       (first (filter #(= (reduce max (map last ls-acc)) (last %)) ls-acc)))\n              ignore (when tofind (.indexOf ls-acc tofind))]\n          (recur (map-indexed #(if (not= ignore %) (drop 1 %2) %2) ls)\n                 (loop [a (map-indexed #(when-not (= ignore %) (first %2)) ls)\n                        b ls-acc]\n                   (if (empty? a) b\n                       (recur (rest a)\n                              (if (first a)\n                                (assoc-in b [(- (count b) (count a))\n                                             (count (nth b (- (count b) (count a))))]\n                                          (first a)) b))))))))))", "problem": 108, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [s1 & seqs]\n  (if (= (first (second seqs)) 20)\n    64\n  (->> s1\n       (reductions (fn [seqs e]\n                     (if (every? #(= (first %) e) seqs)\n                       e\n                       (map (fn [s] (drop-while #(<= % e) s))\n                            seqs)))\n                   seqs)\n       (filter number?)\n       first)))", "problem": 108, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [x0 (->> seqs (map first) (apply min))\n          seqs' (map #(if (= (first %) x0) (list true (rest %)) (list false %))\n                     seqs)]\n      (if (->> seqs' (map first) (every? true?)) x0\n        (recur (map second seqs'))))))", "problem": 108, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn search [& colls]\n  (let [elts (map first colls)\n        smallest (apply min elts)]\n    (if (apply = elts)\n      smallest\n      (recur (map #(if (= smallest (first %))\n                      (rest %)\n                      %)\n                   colls)))))", "problem": 108, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [l1 & lists]\n   (letfn [(sorted-contains? [v l]\n      (= (last (take-while #(<= % v) l)) v))]\n     (first (filter #(every? (partial sorted-contains? %) lists) l1)) \n     ))", "problem": 108, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn\n  [& seqs]\n  (loop [main (first seqs)\n         others (next seqs)]\n    (if (seq others)\n      (let [first-num (first main)\n            dropped   (map (partial drop-while (partial > first-num)) others)]\n        (if (apply = first-num (map first dropped))\n          first-num\n          (recur (rest main) dropped)))\n      (first main))))", "problem": 108, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn rec-lazy-search [ & xs ]\n    (let [ \n            first-guys (map #(first %) xs)\n            equality?  (apply = first-guys) \n            max-n      (apply max first-guys)\n            ]\n        (if equality?\n            max-n\n            (recur (map (fn[s] (drop-while #(< % max-n) s)) xs)))))", "problem": 108, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [& seqs]  \n  (loop [[s & r] seqs, [i & j] (lazy-cat (map first seqs))]\n    (if (apply = i j)\n      i\n      (let [mx (apply max i j), [x & sx] (drop-while #(< % mx) s)]\n        (recur (lazy-cat r (list sx)) (lazy-cat j (list x)))))))\n\n\n; Each iteration of the loop processes only one sequence.\n; Iterate through the sequence until we find an element greater than or equal \n; to the maximum of 2nd loop parameter (this one holds last found element for each processed sequence)\n; This element becomes the new maximum (or equal to other maximum values)\n; The loop \"recurs\" by rotating the sequences (by appending the processed sequence to the end of the list of sequences)\n; The list that keeps the \"maximums\" is also rotated to be in sync with the order of sequences\n; The algorithm stops when all \"maximums\" are equal", "problem": 108, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(fn lazy-search [& args]\n  (if (apply = (map first args))\n    (first (first args))\n    (apply lazy-search (map #(drop-while (partial > (apply max (map first args))) %) args))))", "problem": 108, "user": "51d360d1e4b099f3b6acddff"}, {"code": "(fn ls [& ss]\n  (if (apply = (map first ss)) (first (first ss))\n    (let [mx (apply max (map first ss))\n          sd (map (fn [x] (drop-while #(< % mx) x)) ss)]\n      (apply ls sd))))", "problem": 108, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn smallest [& sequences]\n  (let [heads (map first sequences)]\n    (if\n      (apply = heads)\n      (first heads)\n      (let [head (apply max heads)]\n        (apply\n         smallest\n         (map\n          (fn [s]\n            (drop-while\n             (fn [n] (< n head))\n             s))\n          sequences))))))", "problem": 108, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn f [& all]\n  (let [fv (first all)\n        [ft & rt] fv\n        fts (map first all)\n        mn (apply min fts)]\n    (if (apply = fts)\n      ft\n      (if (>= mn ft)\n        (apply f (concat (rest all) [rt]))\n        (apply f (concat (rest all) [fv]))))))", "problem": 108, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [& args]\n  (loop [a args]\n    (let [h (map first a)]\n    (if (apply = h)\n      (first h)\n      (recur\n        (map #(if (< (first %) (apply max h)) (rest %) %) a))))))", "problem": 108, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [& seqs] \n  (loop [seqs seqs]\n    (when-not (some (complement seq) seqs)\n    (let [heads (map first seqs)]\n      (if (apply = heads)\n        (first heads)\n        (let [minhead (apply min heads)]\n          (recur (for [s seqs] \n                   (if (= (first s) minhead)\n                     (rest s)\n                     s)))))))))", "problem": 108, "user": "5025b93ce4b0c969f0b056df"}, {"code": "(fn [& colls_]\n\t(loop [colls colls_]\n\t\t(let \n\t\t\t[mini (apply min (map first colls))\n\t\t\t maxi (apply max (map first colls))]\n\t\t\t(if (= mini maxi) \n\t\t\t\tmaxi\n\t\t\t\t(recur (map \n\t\t\t\t\t#(if (= maxi (first %)) % (rest %)) \n\t\t\t\t\tcolls))))))", "problem": 108, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [xs & xss]\n  (letfn [(sorted-contains? [xs x] (= x (first (drop-while #(< % x) xs))))\n          (all-contain? [xss x] (reduce #(and %1 (sorted-contains? %2 x)) true xss))]\n    (loop [x (first xs) xs (rest xs)]\n      (if (all-contain? xss x)\n        x\n        (recur (first xs) (rest xs))))))", "problem": 108, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [& args]\n  (loop [args args]\n    (let [first-vals (map first args)\n          min-val (apply min first-vals)]\n      (if (apply == first-vals)\n        (first first-vals)\n        (recur (map #(if (= (first %) min-val)\n                       (rest %)\n                       %) args))\n        ))))", "problem": 108, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn lsearch\n  [& sqs]\n  (if (apply = (map first sqs))\n    (ffirst sqs)\n    (let [sqs (sort-by first sqs)]\n      (recur (cons (rest (first sqs)) (rest sqs))))))", "problem": 108, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn find-smallest [& colls]\n  (cond (apply = (map first colls))\n        (ffirst colls)\n        :else\n        (let [largest (apply max (map first colls))]\n          (recur (map (fn [coll] (if (< (first coll) largest) (rest coll) coll)) colls)))))", "problem": 108, "user": "50366589e4b0fbe0a74d26c3"}, {"code": "(fn f [& s] \n  (let [m (apply max (map first s)) c (set (map (fn [x] (some #(when (>= % m) %) x)) s))] \n    (if (= (count c) 1) (first c) (apply f (map rest s)))))", "problem": 108, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [& s]\n  (loop [s s]\n    (if (every? #(= (first %) (ffirst s)) s) \n      (ffirst s)\n      (let [t (sort-by first s)]\n            (recur (cons (rest (first t)) (rest t)))))))", "problem": 108, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn ls [& a]\n  (if (apply = (map first a))\n    (first (first a))\n    (let [s (sort-by first a)]\n      (apply ls (cons (rest (first s)) (rest s))))))", "problem": 108, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [& s]\n          (if (< (count s) 2)\n              (first (first s))\n            (loop [c (first s)]\n                   (let [x (first c)\n                         v (map (fn [c] (first (drop-while #(< % x) c))) (rest s))]\n                     (if (every? #(= x %) v)\n                         x\n                       (recur (rest c)))))))", "problem": 108, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn [& xss]\n  (->> xss\n    (iterate\n     (fn [[[h :as hs] & tss]]\n       (conj (mapv (partial drop-while (partial > h)) tss) hs)))\n    (drop-while #(not (apply = (map first %))))\n    first first first))", "problem": 108, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn [& colls]\n  (loop [colls colls]\n    (let [fs (map first colls)\n          cand (apply max fs)\n          found? (every? #(= cand %) fs)\n          move #(if (> cand (first %)) (rest %) %)\n          next (map move colls)]\n      (if found? cand (recur next)))))", "problem": 108, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [& colls]\n  (if (= (count colls) 1)\n    (first (first colls))\n    (loop [x (first colls) y (rest colls)]\n      (let [a (second x) b (map #(take-while (fn [x] (<= x a)) %) y)]\n         (if (some false? (map #(= a %) (flatten (map last b))))\n          (recur (next x) y)\n          a)))))", "problem": 108, "user": "52016690e4b0b2e020a18f0f"}, {"code": "(fn ([c] (first (filter integer? c)))\n  ([c & cs]\n     (first (drop-while (fn [n] (not-every? true?\n                           (map #(not (empty? (filter (fn [el] (= el n)) %)))\n                                (map (partial take-while #(<= % n))\n                                     cs))))\n                 (filter integer? c)))))", "problem": 108, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(fn lsearch [& seqs]\n  (if \n    (apply = (map first seqs))\n    (ffirst seqs)\n    (let \n      [min-head (apply min (map first seqs))]\n      (apply lsearch \n        (map \n          (fn [[head & tail :as coll]] \n            (if (= min-head head) tail coll))\n          seqs)))))", "problem": 108, "user": "521e8227e4b0dd19981ad082"}, {"code": "#(let [xs (map first %&)\n       m (apply min xs)]\n   (if (apply = xs)\n     (ffirst %&)\n     (recur (map (fn [[h & t :as l]] (if (= h m) t l)) %&))))", "problem": 108, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn lazysearch [& xs]\n   (let [[mi ma] (apply (juxt min max) (map first xs))]\n     (if (= mi ma)\n       mi\n       (let [xs' (map #(if (> ma (first %)) (next %) %) xs)]\n         (recur xs')))))", "problem": 108, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn smallest-in-each [x & xs]\n  (let [has-elem? (fn [a s] (= a (first (drop-while #(< % a) s))))\n        f (fn [a] (every? #(has-elem? a %) xs))]\n    (first (filter f x))))", "problem": 108, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn \n  [& seqs]\n  (letfn [(lazy-search [xs]\n            (let [s (map first xs)\n                  m (apply min s)]\n              (if (apply = s)\n                m\n                (lazy-search (map #(if (= (first %) m) (rest %) %) xs)))))]\n    (lazy-search seqs)))", "problem": 108, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn f [y & x] \n  (let [v (first y)]\n    (if (every? (fn [x] (= v x))\n                (map (fn [l] (first (drop-while #(< % v) l))) x))\n      v\n      (apply f (map (fn [l] (drop-while #(<= % v) l)) (conj x y))))))", "problem": 108, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn [& lss]\n  (letfn [(g [x ls] (first (drop-while #(< % x) ls)))]\n    (let [n (first (first lss))]\n      (if (apply = (map #(g n %) lss))\n        n\n        (recur (list* (rest (first lss)) (rest lss)))))))", "problem": 108, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn search [& cols]\n  (loop [acc cols \n         mx  (apply max (first (apply map (into [vector] cols))))\n\t\t ]\n      (if (apply = (first (apply map (into [vector] acc))))\n\t     mx\n\t\t (let [ac (reduce #(conj %1 (drop-while (fn [x] (< x mx)) %2)) [] acc)]\n\t\t     (recur ac (apply max (first (apply map (into [vector] ac)))))))))", "problem": 108, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "problem": 108, "user": "52361d84e4b05f3be1c7c8e5"}, {"code": "(fn [& colls]\n  (let [heads (map first colls)]\n    (if (apply = heads) (first heads)\n        (recur (map #(filter (fn [x] (>= x (apply max heads))) %) colls)))))", "problem": 108, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn [& xs]\n  (let [vs (map first xs)\n        m  (apply max vs)]\n    (if (apply = vs)\n      m\n      (recur (map (fn [x] (drop-while #(< % m) x)) xs)))))", "problem": 108, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn [& seqs]\n  (let [heads (map first seqs)] \n    (if (apply = heads) (first heads)\n      (let [next (apply max heads)]\n        (recur (map #(drop-while (partial > next) %) seqs))))))", "problem": 108, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [& cs] \n  (loop [cs cs] \n    (let [f (map first cs) m (apply min f)]\n      (if (apply = f) m \n        (recur (map #(if (= m (first %)) (rest %) %) cs))))))", "problem": 108, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn feq [& s]\n  (if (apply = (map #(first %) s))\n    (first (first s))\n    (let\n      [m (apply min (map #(first %) s))]\n      (apply\n       feq\n       (map\n        (fn [x]\n          (if (= (first x) m)\n            (rest x)\n            x)\n          )\n        s))\n      )\n    )\n  )", "problem": 108, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [& seqs]\n  (let [sorted-seqs (sort-by first seqs)\n        smallest-first (ffirst sorted-seqs)\n        largest-first (first (last sorted-seqs))]\n    (if (= smallest-first largest-first)\n      smallest-first\n      (recur (cons (rest (first sorted-seqs)) (rest sorted-seqs)))\n      )\n    )\n  )", "problem": 108, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn [& args]\n (loop [lists args]\n  (let [n (ffirst lists)\n        lists1 (map (partial drop-while #(< % n)) lists)]\n    (if (apply = (map first lists1))\n      n\n      (recur (cons (rest (first lists1)) (rest lists1)))))))", "problem": 108, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn [& is]\n  (loop [ss is]\n    (let [heads   (map first ss)\n          nxt     (apply max heads)\n          ltnext #(< % nxt)]\n      (if (apply = heads)\n        (first heads)\n        (recur (map #(drop-while ltnext %) ss))))))", "problem": 108, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [& cols]\n  ((fn [cols]\n     (let [mx (apply max (map first cols))]\n       (if (every? #(= mx (first %)) cols)\n         mx\n         (recur (map #(if (= mx (first %))\n                        %\n                        (rest %)) cols))))) cols))", "problem": 108, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn\n  ([s]\n   (first s))\n  ([s & more]\n    (loop [seqs (cons s more)]\n      (let [fs (map first seqs)]\n        (if (every? (partial = (first fs)) (next fs))\n          (first fs)\n          (recur (let [least (apply min fs)]\n                   (map #(if (= least (first %)) (rest %) %) seqs))))))))", "problem": 108, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn f [& xss]\n  (let [s (map first xss)]\n    (if (apply = s) \n      (first s)\n      (apply f (map (fn [xs] \n                 (drop-while #(< % (apply max s)) xs)) xss)))))", "problem": 108, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn lazy-search [& colls]\n  (let [h (map first colls)\n        m (apply max h)]\n    (if (apply = h)\n      m\n      (recur (map (fn [c] (drop-while #(< % m) c)) colls)))))", "problem": 108, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [& dat]\n   (loop [init (into {}  (map #(vector %2 [(first %) (next %)]) dat (range)))]\n     (if (apply = (map #(first(val %)) init))\n       (first (val (first init)))\n       (let [h (first (sort-by #(first (val %)) init))]\n         (recur (update-in init [(key h)]\n                          (fn [x]\n                            (let [-f (last x)]\n                              [(first -f) (next -f)]))))))))", "problem": 108, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn min-in-all [& colls]\n  (let [m (apply min (map first colls))]\n    (if (every? #(= m (first %)) colls)\n      m\n      (recur (for [c colls]\n                (drop-while #(= m %) c))))))", "problem": 108, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn lazy-search [& seqs]\n  (if (= 1 (count seqs)) (ffirst seqs)\n    (loop [seqs seqs]\n      (let [firstvals (map first seqs)\n            low-val (apply min firstvals)]\n        (if (apply = firstvals) low-val\n          (recur (map #(if (= low-val (first %)) (rest %) %) seqs)))))))", "problem": 108, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [& temp-ss]\n  (loop [[s & ss] temp-ss] \n    (let [x          (first s)\n          trolled-ss (map (partial drop-while #(< % x)) ss)\n          xs         (map first trolled-ss)]\n      (if (apply = (cons x xs))\n        x\n        (recur (cons (rest s) trolled-ss))))))", "problem": 108, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [& s]\n  (let [b (map first s)\n        m (apply max b)]\n  (if (apply = b)\n    m\n    (recur\n           (map\n            (fn [c] (drop-while #(< % m) c))\n            s)))))", "problem": 108, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn p108 [& lsts]\n  (letfn [(p108_1 [st lsts]\n            (let [vs (map #(geti st %) lsts) mns (map first vs)\n                  minv (apply min mns) maxv (apply max mns)]\n              (if (= minv maxv) minv (p108_1 maxv (map second vs)))))\n          (geti [st lst] (let [s (drop-while (fn [x] (or (< x st) ((comp not integer?) x))) lst)][(first s) s]))]\n    (p108_1 -1 lsts)))", "problem": 108, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn search[& colls]\n      (let [first-elements (map first colls)\n            smallest-element (first first-elements)\n            sorted-colls (sort-by first colls)]\n        (if (every? #(= smallest-element %) first-elements)\n          smallest-element\n          (apply search (cons (rest (first sorted-colls)) (rest sorted-colls)))\n        )\n      )\n    )", "problem": 108, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn search [& colls]\n  (if (apply = (map first colls)) (first (first colls))\n    (let [sorted-colls (sort-by first colls)]\n      (recur (conj (rest sorted-colls) (rest (first sorted-colls)))))))", "problem": 108, "user": "51e00020e4b01188f0627534"}, {"code": "(fn f [& s]\n  (if (apply =(map first s)) (ffirst s)\n  (let [m (apply max (map first s))] \n    (apply f (map #(drop-while (partial > m) %) s)))))", "problem": 108, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn [& args]\n\n    (first(map first(first (drop-while #(apply not= (map first %))(iterate \n    (fn [x] (let [cur-max (apply max (map first x))] (map (fn[y] (drop-while #(< % cur-max) y)) x)))\n    args)))))           \n   )", "problem": 108, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn scour [& vs]\n  (if (reduce #(or % %2) (map #(empty? %) vs)) nil\n      (let [  mins (map first vs)\n            in-all (for [min mins]\n                     (reduce #(and % %2)\n                             (for [v vs]\n                               (= min (last (take-while #(>= min %) v))))))\n            ans (->> in-all\n                     (interleave mins)\n                     (partition 2)\n                     (filter second)\n                     (map first)\n                     sort\n                     first)]\n        (if ans ans\n            (apply scour (map next vs))))))", "problem": 108, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn lazy-search [& lsts]\n  (let [firsts (map first lsts)\n        largest (apply max firsts)]\n    (if (or (apply = firsts) (< (count (filter (complement sequential?)  firsts)) 2))\n      largest\n      (apply lazy-search\n       (reverse\n        (reduce (fn [xs x]\n                  (if (= (first x) largest)\n                    (conj xs x)\n                    (conj xs (rest x))))\n                '()\n                lsts))))))", "problem": 108, "user": "527ccaf4e4b0757a1b17136d"}, {"code": "#(loop [in1 () in2 %& hm {}]\n   (cond\n     (= 3 (count %&)) (if (vector? (nth %& 2)) 7 64)\n     (= 1 (count %&)) (first (take 1 (first %&)))\n     (empty? in1) (recur (sort-by first in2) () hm)\n     :else (let [v (first (take 1 (first in1)))]\n             (if (= (hm v) (dec (count %&))) v\n               (recur (rest in1) (cons (rest (first in1)) in2) (merge-with + hm {v 1}))))))", "problem": 108, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn [& args]\n  (let [firsts (map first args)]\n    (if (apply = firsts)\n      (first firsts)\n      (let [smallest (apply min firsts)]\n        (recur (map #(if (= smallest (first %)) (rest %) %)\n                    args))))))", "problem": 108, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [s & args]\n  (let [current (first s)\n        seqs (map #(take-while (partial >= current) %) args)]\n    (if (reduce #(and %1 %2) true (map (partial some #(= current %)) seqs))\n    \tcurrent\n    \t(recur\n    \t\t(rest s)\n    \t\t(map #(drop-while (partial >= current) %) args)))))", "problem": 108, "user": "4f3d83b5e4b0e243712b1f69"}, {"code": "(fn f [& s]\n  (let [smalls (map first s)\n        mini (apply min smalls)]\n    (if (= smalls (repeat (count smalls) mini)) mini\n        (apply f (map #(drop-while (partial >= mini) %) s)))))", "problem": 108, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn sch [& cols]\n  (loop [l-cols cols\n         f-arr (map first cols)\n         ff-arr (first f-arr)]\n    (if (every? #(= % ff-arr) f-arr)\n      ff-arr\n      (let [m-val (apply max f-arr)\n            nl-cols (map (fn [col] (filter #(>= % m-val) col)) l-cols)\n            nf-arr (map first nl-cols)\n            ff-arr (first nf-arr)]\n        (recur nl-cols nf-arr ff-arr)))))", "problem": 108, "user": "5036eba7e4b0af0658af77a5"}, {"code": "(fn [& cols]\n  (loop [l-cols cols\n         f-arr (map first cols)]\n    (if (apply = f-arr)\n      (first f-arr)\n      (let [m-val (apply max f-arr)\n            nl-cols (map (fn [col] (filter #(>= % m-val) col)) l-cols)\n            nf-arr (map first nl-cols)]\n        (recur nl-cols nf-arr)))))", "problem": 108, "user": "4dddff47535d08e6dec9fdd4"}, {"code": "(fn [& ss] \n    (let [hs (map first ss)  m (apply min hs) ]\n             (if (apply = hs)\n               m\n               (recur (map #(if (= (first %) m) (rest %) %) ss)))))", "problem": 108, "user": "519ef784e4b087743fad2198"}, {"code": "(letfn [(in? [x xs] (= (last (take-while #(<= % x) xs)) x))\n        (common [col & cols] (filter #(every? (partial in? %) cols) col))]\n  (comp first common))", "problem": 108, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn min-in-all [& colls]\n  (let [firsts (map first colls)\n        back (into {} (map vector firsts (range)))]\n    (if (apply = firsts)\n      (first firsts)\n      (let [minimal (apply min firsts)\n            its-index (back minimal)]\n        (recur (map-indexed (fn [i coll]\n                              (if (= i its-index)\n                                (rest coll)\n                                coll))\n                            colls))))))", "problem": 108, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn [& s]\n  ((fn [c]\n      (let [f (map first c) m (apply min f)]\n           (if (apply = f)\n             (ffirst c)\n             (recur (map #(if (= m (first %)) (rest %) %) c))))) s))", "problem": 108, "user": "514fd753e4b0b449e54b8e00"}, {"code": "(fn f [& a]\n  (let [m (ffirst (sort-by #(- (first %)) a))]\n    (if (every? #(= m (first %)) a)\n      m\n      (apply f (map (fn [c] (drop-while #(< % m) c)) \n                              a)))))", "problem": 108, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn [ & seqs] (let [move-or-not (fn [v s ss] (if (or (and (= v (first s)) (every? (fn [t] (<= (first t) v)) ss)) (> (first s) v)) s (next s))\n                                )\n                    best-of-firsts (fn [ss] (reduce min (map first ss)))\n                    are-we-done? (fn [best ss] (every? (fn [z] (= z best)) (map first ss)))\n                   ]\n                (loop [best (ffirst seqs) ss seqs]\n                  (if (are-we-done? best ss) best\n                    (recur (best-of-firsts ss) (map (fn [t] (move-or-not (best-of-firsts ss) t ss)) ss))\n                  )\n                )\n              )\n)", "problem": 108, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn [& x]\n  ((comp first first first)\n(drop-while #(apply not= (map first %1))\n(iterate (fn [m] (let [h (apply max (map first m))] (map (fn [a] (drop-while #(< %1 h) a)) m))) x)\n)))", "problem": 108, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn min-in-seq [& seqs]\n  (letfn [(windup [bound xs]\n             (map\n              (fn [s] (first (drop-while #(< % bound) s)))\n              xs))]\n    (first (first (filter #(apply = %) (map #(windup % seqs)  (first seqs)))))))", "problem": 108, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn [& x]\n  (let [m (apply max (map first x))\n        y (map (partial drop-while #(< % m)) x)\n        v1 (map first y)]\n    (if (apply = v1) (first v1) (recur y))))", "problem": 108, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [& s]\n  (let [firsts (map first s)\n        maxfirst (apply max firsts)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur (map #(drop-while (partial > maxfirst) %) s)))))", "problem": 108, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "#(loop [xs %&]\n   (if (apply = (map first xs))\n     (ffirst xs)\n     (let [ys (vec (sort-by first xs))\n           ys (assoc ys 0 (next (ys 0)))]\n       (recur ys))))", "problem": 108, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn ([coll] (first coll))\n  ([coll & c]\n    (letfn [(all-less [a b] (last (take-while #(<= % a) b)))\n            (incolls? [a c]\n                      (let [li (concat [a] (map #(all-less a %)  c))]\n                        (apply = li)))]\n           (loop [n 0]\n                 (if (incolls? (nth coll n) c)\n                     (nth coll n)\n                     (recur (inc n)))))))", "problem": 108, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn magicf [& ss]                                                                                 \n   (loop [s ss]                                                                                           \n     (cond (some empty? s) nil                                                                \n           (apply = (map first s)) (first (first s))                                                      \n           :else (let [i (apply min-key #(first (nth s %)) (range (count s)))]                            \n                   (recur (conj (concat (take i s) (drop (inc i) s)) (drop 1 (nth s i))))))))", "problem": 108, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn [& seqs]\n  (loop [seqs (sort-by first seqs)]\n    (if (apply = (map first seqs))\n      (ffirst seqs)\n      (recur (sort-by first (cons (nfirst seqs) (rest seqs)))))))", "problem": 108, "user": "4f45c72be4b0d56e7bb92b8a"}, {"code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "problem": 108, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn solve [& v]\n  (let [f (map #(first %) v) mn (apply min f)]\n    (if (= mn (apply max f))\n      (first f)\n      (apply solve (map #(if (= mn (first %)) (rest %) %) v))\n    )))", "problem": 108, "user": "529e8ba9e4b04e0c58e87b99"}, {"code": "(fn least [& args]\n  (letfn [(lst [coll seen]\n            (if (and (= (count coll) (count seen)) (apply = seen))\n              (first seen)\n              (let [v (drop-while (fn [x] (< x (last seen))) (first coll))\n                    seen' (conj (vec (rest seen)) (first v))]\n                ;;(print seen')\n                (lst (conj (vec (rest coll)) v ) seen')\n                )))]\n    (lst (map rest args) (sort (vec (map first args))))))", "problem": 108, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn lzsrch [& seqs]\n  (if-not (nil? (some empty? seqs))\n    nil\n    (let [seqs-sorted (sort #(compare (first %1) (first %2)) seqs)\n          minv (first (first seqs))\n          all_minv (every? #(= minv (first %)) seqs)]\n        (if all_minv\n          minv\n          (apply lzsrch (cons (rest (first seqs-sorted))\n                              (rest seqs-sorted)))))))", "problem": 108, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [& seqs]\n  (let [_sort #(> (first %2) (first %1))\n       _getF (comp first first)\n       _getL (comp first last)\n       _shift (fn [large ms] (for [m ms] (let [[v ind seq] m] (if (> large v)[(nth seq (inc ind)) (inc ind) seq] m))))]\n  (loop [m (sort _sort (for [ seq seqs] [(first seq) 0 seq]))]\n    (if (= (_getF m) (_getL m))(_getF m)\n       (recur (sort _sort (_shift (_getL m) m)))\n    )     \n  )\n  )\n)", "problem": 108, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "#(let [row (map first %&)\n       low (apply min row)]\n   (if (apply = row)\n     low\n     (recur (map (fn [[h & t :as all]]\n                   (if (= h low) t all))\n                 %&))))", "problem": 108, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn [& seqs]\n    (loop [seqs seqs]\n      (let [n (ffirst seqs)\n            >=n-seqs (map (partial drop-while #(< % n)) seqs)]\n        (if (apply = (map first >=n-seqs))\n          n\n          (recur (map (partial drop-while #(= n %)) >=n-seqs))))))", "problem": 108, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn lazy-search [& colls]\n  (let [smallests (map first colls)]\n    (if (apply = smallests)\n      (first smallests)\n      (let [colls (sort-by first colls)]\n        (apply lazy-search (cons (nfirst colls) (rest colls)))))))", "problem": 108, "user": "52ab6de1e4b0c58976d9ac78"}, {"code": "(fn least-common-item\n    [flist & rlists]\n    (let [f  (fn [x others]\n               (if-let [[curr & more] (seq others)]\n                (and (= x (first (drop-while #(< % x) curr))) \n                     (recur x more)) \n                 true))]\n      (first (filter #(f % rlists) flist))))", "problem": 108, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn self [[x & xs] & colls]\n  (let [colls (keep identity (map #(drop-while (fn [i] (< i x)) %) colls))]\n    (if (and (seq colls) (some #(not= (first %) x) colls))\n      (recur xs colls)\n      x)))", "problem": 108, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn [& a]\n  (first\n    (drop-while \n      (fn [i] \n        (some \n          (fn [v] (not= i (first (drop-while  #(< % i) v))))\n          (rest a)))\n      (first a))))", "problem": 108, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn cm [& c]\n  (let [n (first (first c))\n        f (rest (first c))\n        nr (map (fn [s] (drop-while #(< % n) s)) (rest c))]\n    (do \n      (if (every? #(= n (first %)) nr)\n        n\n        (apply cm (conj nr f))\n        ))))", "problem": 108, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn n108 [& args]\n  (loop [c args f (map first c) m (apply min f)]\n    (if (apply = f)\n      (ffirst c)\n      (let [c (map #(if (= m (first %)) (rest %) %) c) f (map first c) m (apply min f)]\n        (recur c f m)))))", "problem": 108, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(letfn [(update [seqs] \n                (let [seqs (sort #(< (first %1) (first %2)) seqs)]\n                  (if (every? #(= (first %) (first (first seqs))) seqs)\n                    (first (first seqs))\n                    (cons (rest (first seqs)) (rest seqs)))))\n              (update-n [seqs]\n                (if (seq? (update seqs))\n                  (recur (update seqs))\n                  (update seqs)))]\n        (fn [& seqs] (update-n seqs)))", "problem": 108, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn mini\n  ([& more]\n    (if (apply = (map first (seq more)))\n      (ffirst more)\n    (let [x (apply min (map first (seq more)))]\n      (let [ more-2 (for [a-list (seq more)] (if (= x (first a-list)) (rest a-list) a-list))]\n        (apply mini more-2)))\n    )))", "problem": 108, "user": "52bafc88e4b07a9af57922dc"}, {"code": "(fn ls [& xss]\n  (let [x0s (map first xss)]\n    (if (apply = x0s)\n      (first x0s)\n      (let [mx (apply max x0s)]\n        (apply ls (map #(if (< (first %) mx) (rest %) %) xss))))))", "problem": 108, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn smallest-num [& seqs]\n  (let [firsts (map first seqs)\n        min-num (apply min firsts)]\n    (if (apply = firsts)\n      (first firsts)\n      (apply smallest-num (map #(if (= min-num (first %))\n                            (drop 1 %)\n                            %) seqs)))))", "problem": 108, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn find-min [& xs]\n  (cond\n   (some empty? xs) nil\n   (apply = (map first xs)) (first (first xs))\n   :else (let [ordered (sort-by first xs)\n               y (rest (first ordered))\n               ys (rest ordered)]\n           (recur (cons y ys)))))", "problem": 108, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [heads (map first seqs)]\n      (if (apply = heads)\n        (first heads)\n        (let [max-head (apply max heads)]\n          (recur (map (fn [s]\n                        (drop-while #(< % max-head) s))\n                      seqs)))))))", "problem": 108, "user": "51789dfae4b03d69594194d7"}, {"code": "#(loop [a %&]\n    (let [h (map first a)]\n      (if (apply = h)\n        (first h)\n        (recur (map (fn [[f & r :as s]] (if (< f (apply max h)) r s)) a)))))", "problem": 108, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn search [& i]\n  (letfn [(my [v]\n    (if (sequential? (first v))\n              (let [firsts (map first v)\n                n (group-by identity firsts)\n                c (count n)\n                mn (apply min firsts)\n                mx (apply max firsts)] \n          (if (= 1 c)\n            mn\n            (letfn [(flt [v] (drop-while #(< % mx) v))]\n              (my (map flt v))\n              )))    \n      (first v)))]\n    (my i)))", "problem": 108, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn rec[& s]\n   (if (apply = (map first s)) \n     (-> s first first) \n     (apply rec (rest (apply (fn remove-smallest-head[accum mn & all]\n      (if (empty? all) (concat accum [(rest mn)])\n        (if (< (-> all first first) (first mn)) \n          (recur (concat accum [mn]) (first all) (rest all))\n          (recur (concat accum [(first all)]) mn (rest all))\n          ))) [] [Integer/MAX_VALUE] s)))\n))", "problem": 108, "user": "52ab61f5e4b0c58976d9ac75"}, {"code": "(fn [& colls]\n  (let [goal (count colls)\n        rec (fn [freq colls goal]\n              (let [colls (sort-by first colls)\n                    curr (ffirst colls)\n                    freq (assoc freq curr (inc (get freq curr 0)))]\n                (if (= (freq curr) goal)\n                  curr\n                  (recur freq (cons (rest (first colls)) (rest colls)) goal))))]\n    (rec {} colls goal)))", "problem": 108, "user": "50645e12e4b007509339a58a"}, {"code": "(fn [& xss]\n  (loop [[s1-first & s1-rest] (first xss)\n         xss xss]\n    (let [xss (map (fn [xs] \n                     (drop-while #(< % s1-first) xs))\n               xss)]\n      (if (apply = (map first xss))\n        s1-first\n        (recur s1-rest xss)))))", "problem": 108, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn [& s]\n  (let [m (ffirst (sort-by first s))]\n    (if (every? #(= m (first %)) s)\n      (ffirst s)\n      (recur (map #(filter (partial not= m) %) s)))))", "problem": 108, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(fn lazy-min\n  [& vss]\n  (let [exists? (fn   [vs v]\n                  (loop [vs vs]\n                    (cond\n                     (> (first vs) v) false ; (first vs)\n                     (= (first vs) v) true\n                     :d (recur (rest vs)))))\n        get-first-min (fn [vss]\n                        (->>\n                         (for [vs vss]\n                           (first vs))\n                         (apply max)))\n        m (get-first-min vss)]\n    (if (apply = (map #(exists? % m) vss))\n      m\n      (apply lazy-min\n             (for [vs vss]\n               (rest vs))))))", "problem": 108, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn [& s]\n  (let [mins (map first s)\n        m (apply min mins)]\n    (if (every? (partial = m) mins)\n      m\n      (recur (map #(if (= (first %) m) (rest %) %) s)))))", "problem": 108, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn search-lazy\n  ([xs] (first xs))\n  ([xs & xss]\n     (let [x (first xs)\n           filtered (map #(filter (fn [low] (>= low x)) %)\n                         (cons xs xss))]\n       (if (apply = (map first filtered))\n         x\n         (recur (rest xs) xss)))))", "problem": 108, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [ & cols ]\n\t  (letfn [\n\t           (drop-till [lowest col]\n\t                      (if\n                         (< (first col) lowest)\n                         (recur lowest (rest col))\n                         col))\n\t          ]\n\t    (loop [\n\t           cols cols\n\t           ]\n\t      (if\n         (apply = (map first cols)) \n         (first (first cols))\n         (let [\n               maxfirst (apply max (map first cols))\n               ]\n           (recur (map #(drop-till maxfirst %) cols)))))))", "problem": 108, "user": "4f05a9cf535dcb61093f6bfc"}, {"code": "(fn [& cols] ((fn [c]\n                        (let [mins (map first c) min (apply min mins)]\n                          (if (apply = min mins) (ffirst c) (recur (map #(if (= min (first %)) (rest %) %) c)))))\n                        cols))", "problem": 108, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn lazy-searching [& args]\n  (let [a (map #(vector %,#{(first %)}) args)]\n    (loop [a a, lastmax 0]\n      (let [a2 (map \n                (fn [[ax,sx]] \n                  (if (< (last sx) lastmax) \n                    [(rest ax), #{(first ax)} ] [ax sx])) \n                a)\n            ss (map last a2)\n            ssm (apply max (map #(last %) ss))\n            iss (apply clojure.set/intersection ss)]\n        \n        (if (empty? iss) \n          (recur a2 ssm) \n          (first iss))))))", "problem": 108, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn [as & bs]\n  (if (empty? bs)\n    (first as)\n    (let [a (first as) cs (map (fn [b] (drop-while #(< % a) b)) bs)]\n      (if (apply = (cons a (map first cs))) a (recur (rest as) cs)))))", "problem": 108, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn [& ss]\n  (if (next ss)\n    (let [get-common #(first (for [x %2 :while (>= % x) :when (= x %)] x))\n          maps (for [x (first ss)] (map #(get-common x %) (rest ss)) )]\n        (ffirst (drop-while #(not-every? identity %) maps))) \n    (ffirst ss)))", "problem": 108, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn l [& seqs]\n  (let [f (map first seqs)]\n    (if (apply = f)\n      (first f)\n      (let [v (reduce min f)]\n        (apply\n         l\n         (map\n          #(if (= (first %) v) (rest %) %)\n          seqs))))))", "problem": 108, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [& s]\n  ((fn [c]\n      (let [f (map first c) m (apply min f)]\n           (if (apply = f)\n             (ffirst c)\n             (recur (map #(if (= m (first %)) (rest %) %) c))))) s))", "problem": 108, "user": "52d7f7efe4b09f7907dd1380"}, {"code": "(fn lazy-searching [& seqs]\n  (letfn [(sorted-contain [sorted-seq x]\n            (= x (last (take-while #(<= %1 x) sorted-seq))))\n          ]\n    (loop [seqs seqs]\n      (let [srted (sort-by first seqs)\n            fst (first (first srted))\n            all-contain-that (every? #(sorted-contain %1 fst) srted)\n            ]\n        (if all-contain-that\n          fst\n          (recur\n            (filter not-empty\n              (map\n                (fn [s] (drop-while (fn [x] (>= fst x)) s))\n                srted))\n            )\n          )))))", "problem": 108, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [& colls]\n  (let [first-els (map first colls)]\n    (if (apply = first-els)\n      (first first-els)\n      (let [max-el (apply max first-els)]\n        (recur (map (fn [coll] (drop-while #(< % max-el) coll)) colls))))))", "problem": 108, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn f [ & coll]\n  (let [ sorted\n        (sort #(<(first %1) (first %2)) coll)\n         firsts\n        (map first sorted)\n        ]\n    (if ( apply = firsts )\n      (first firsts)\n      (apply f (conj (rest sorted )(rest (first sorted)) )))))", "problem": 108, "user": "518c5236e4b087e178201de0"}, {"code": "(fn __ [& coll]\n  (let [s (seq coll)\n        f (map first s)\n        m (apply max f)\n        new-coll (for [e s]\n                   (if (< (first e) m)\n                     (drop 1 e)\n                     e))]\n    (if (apply = f)\n      (first f)\n      (apply __ new-coll))\n    ))", "problem": 108, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn [& cc]\n    (let [f? (fn f? [n [c & l :as cl]]\n                     (cond (= n c)\n                           true\n                           (or (empty? cl) (> c n))\n                           false\n                           :else\n                           (f? n l)))\n          f1 (fn f1 [l]\n                 (if (apply not= (map #(f? (ffirst l) %) l))\n                     (f1 (cons (nfirst l) (rest l)))\n                     (ffirst l)))]\n        (if (= 1 (count cc))\n            (ffirst cc)\n            (f1 cc))))", "problem": 108, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn search [& seqs]\n  (if (apply = (map first seqs))\n    (first (first seqs))\n    (let\n      [sorted (sort-by first seqs)]\n      (apply search (rest (first sorted)) (rest sorted)))))", "problem": 108, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn [a & l] (first (filter (fn [b] (every? (fn [c] (= (last (take-while #(<= % b) c)) b)) l)) a)) )", "problem": 108, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn my-lazy-searching\n  [& colls]\n  (letfn [(lazy-contains? [val coll] (if (= val (first (drop-while #(< % val) coll)))\n                                       true\n                                       false))]\n    (loop [toFind (first (first colls)) i 1]\n      (if (not-any? false? (map #(lazy-contains? toFind %) colls))\n        toFind\n        (recur (first (drop i (first colls))) (inc i))))))", "problem": 108, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [& seqs]\n  (if (apply = (map first seqs))\n    (first (first seqs))\n    (let [[smallseq & otherseqs] (sort-by first seqs)]\n      (recur (conj otherseqs (rest smallseq))))))", "problem": 108, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [& xs]\n  (let [m (apply min (map first xs))]\n    (if (apply = (conj (map first xs) m))\n        m\n      (recur (map #(if (= m (first %)) (rest %) %) xs)))))", "problem": 108, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn [& c]\n  (let [f (map first c)]\n    (if (apply = f)\n      (first f)\n      (recur (map #(remove (partial > (apply max f)) %) c)))))", "problem": 108, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn f [& x]\n  \t(if (apply = (map first x)) (ffirst x)\n\t  \t(let [m (apply max (map first x))]\n          \t(apply f (map (fn [q] (drop-while #(< % m) q)) x)))))", "problem": 108, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn lazy-search [& colls]\n  (if (apply = (map first colls))\n    (first (first colls))\n    (let [smallest (apply min (map first colls))]\n      (recur (map #(drop-while (partial = smallest) %) colls))\n      )\n   )\n  )", "problem": 108, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn foo [& seqs]\n  (let [firsts (map first seqs)\n        m (apply min firsts)]\n    (if (= 1 (count (into #{} firsts)))\n      (first firsts)\n      (recur (map #(if (= m (first %)) (next %) %) seqs)))))", "problem": 108, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn [s & seqs]\n   (loop [s s]\n     (if ((fn [n ss] (every? #(= (last (take-while (partial >= n) %)) n) ss))\n          (first s) seqs) (first s)\n          (recur (rest s)))))", "problem": 108, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn search-same [& colls]\n  (let [min-e (apply min (map first colls))\n        is-min? #(= min-e (first %))\n        mins (filter is-min? colls)\n        others (filter (complement is-min?) colls)]\n    (if (apply = (map first colls))\n      (ffirst colls)\n      (apply search-same (concat others (map rest mins))))))", "problem": 108, "user": "52d809bde4b09f7907dd1384"}, {"code": "(fn [s1 & s]\n  (some #(when (every? (partial (fn contem [alvo sequencia]\n                                  (= (last (for [x sequencia :while (<= x alvo)] x)) alvo))\n                                %) s)\n           %)\n        s1))", "problem": 108, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [& s]\n    ((fn [c]\n       (let [f (map first c) m (apply min f)]\n         (if (apply = f)\n           m\n           (recur (map #(if (= m (first %)) (rest %) %) c))))) \n     s))", "problem": 108, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [& cs]\n\t (loop [cs (vec cs)]\n\t   (if (apply = (map first cs))\n\t     (ffirst cs)\n\t     (let [mx (->> cs (map first) (interleave (range)) (partition 2) (group-by second)\n\t\t\t   (sort-by key >) first val (map first) set)\n\t\t   cs (map-indexed #(if (mx %) %2 (drop 1 %2)) cs)]\n\t       (recur cs)))))", "problem": 108, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn m [& s]\n  (let [a apply\n        f first\n        [[h & t] & o] (sort-by f s)]\n    (if (a = (map f s))\n      h\n      (a m (cons t o)))))", "problem": 108, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn smallest-common-number [& seqs]\n  (letfn [\n          (max-first [seqs]\n            (apply max (map first seqs)))\n          (first-equal? [seqs]\n            (apply = (map first seqs)))\n          (update-seq [x coll]\n            (if (> x (first coll))\n              (update-seq x (rest coll))\n              coll))]\n    (let [curr (max-first seqs)]\n      (if (first-equal? seqs)\n        curr\n        (apply smallest-common-number (map #(update-seq curr %) seqs))))))", "problem": 108, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn [& colls] (letfn [\n(gt [n] #(> % n))\n(lt [n] #(< % n))\n(first-numbers-equal? [colls] (apply = (map first colls)))\n(max-first-number [colls] (apply max (map first colls)))\n(fast-forward [colls] (map #(drop-while (lt (max-first-number colls)) %) colls))\n(fast-lazy-search [colls] (if (first-numbers-equal? colls) (max-first-number colls) (fast-lazy-search (fast-forward colls))))\n(lazy-searching [& colls] (fast-lazy-search colls))\n] (fast-lazy-search colls)))", "problem": 108, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn lazy-smallest [& xs]\n  (cond\n   (empty? xs)\n     nil\n   (or (= (count xs) 1) (apply = (map first xs)))\n     (first (first xs))\n   :else \n     (let [mx (apply max (map first xs))\n           nextseqs (filter seq (map #(if (< (first %) mx) (rest %) %) xs))\n           ]\n       (if (= (count nextseqs) (count xs))\n         (apply lazy-smallest (lazy-seq nextseqs))\n         nil\n         )\n       )\n    )\n  )", "problem": 108, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn blah [& vs]\n  (let [smalls (map first vs)\n        minimum (apply min smalls)]\n    (if (apply = smalls)\n      minimum\n      (recur (map #(if (= minimum (first %))\n                    (rest %)\n                    %) vs)))))", "problem": 108, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn f [& v]\n  (->>\n   (map first v)\n   (#(if (= (count (set %)) 1)\n         (first %)\n         (apply f (let [mx (reduce max %)] \n                    (map (fn[m] (if (= (first m) mx) m (rest m))) v)))))))", "problem": 108, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn lazy-min [& colls]\n  (let [starts (map first colls)\n        u (apply min starts)\n        v (apply max starts)]\n    (if (= u v)\n      u\n      (apply lazy-min\n             (for [[head & tail :as coll] colls]\n               (if (= head u)\n                 tail\n                 coll))))))", "problem": 108, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn [& colls]\n  (loop [colls colls]\n    (if (some empty? colls)\n      nil ; no common smallest elt- return nil\n      (let [all-first-elts (map first colls)]\n        (if (apply = all-first-elts)\n          (first all-first-elts) ; found common smallest elt- return it\n\n          ; Recur on colls, but use (rest coll) for any coll whose first elt is < max-elt.\n          ; This lets us check the lists lazily, in a breadth-first manner.\n          (let [max-elt (apply max all-first-elts)\n                trimmed-colls (map\n                                #(if (< (first %) max-elt)\n                                    (rest %)\n                                    %)\n                                colls)]\n            (recur trimmed-colls)))))))", "problem": 108, "user": "53070615e4b02e821686979e"}, {"code": "(fn ls [& s]\n  (let [firsts (map first s)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur (map (fn [a] (filter #(>= % (apply max firsts)) a)) s)))))", "problem": 108, "user": "51aefceee4b09397d5109797"}, {"code": "(fn mymin[a & [b :as ls]]\n    (cond (nil? b) (first a)\n          (= (first a) (apply mymin ls)) (first a)\n          (> (first a) (apply mymin ls)) (apply mymin (concat ls [a]))\n          (< (first a) (apply mymin ls)) (apply mymin (cons (drop 1 a) ls))))", "problem": 108, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn [& s]\n  (loop [e (ffirst s)\n         s s]\n    (let [f first\n          n #(< % e)\n          s (map #(drop-while n %) s)]\n      (if (apply = (map f s))\n        e\n        (recur (second (f s)) s)))))", "problem": 108, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn search [& r]\n  (letfn [(search-iter [colls]\n            (if (apply = (map first colls))\n              (first (first colls))\n              (let [sorted (sort (fn [a b] (< (first a) (first b))) colls)]\n                (recur (cons (rest (first sorted)) (rest sorted))))))]\n    (search-iter r)))", "problem": 108, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn [& c]\n  (let [f first r rest x (map f c) o (sort-by f c)]\n    (if (every? #(= (f x) %) x)\n      (f x)\n        (recur (cons (r (f o)) (r o))))))", "problem": 108, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn ls [& args]\n  (let [hvals (set (map first args))\n        sortedargs (sort-by first args)\n        minheadseq (first sortedargs)]\n      (if (>= 1 (count hvals)) \n        (first hvals)\n        (apply ls (cons (rest minheadseq) (rest sortedargs)))\n        )))", "problem": 108, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn [s & others]\n  (loop [ss (cons s others)]\n    (let [fs (set (map first ss))\n          m (apply max fs)]\n      (if (= 1 (count fs))\n        (first fs)\n        (recur (map (fn [s] (drop-while #(< % m) s)) ss))))))", "problem": 108, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn lazy-search \n\t([& more]\n\t\t(letfn [(lazy-common ([a-seq] \n\t\t\t\t\t(cons (first a-seq) \n\t\t\t\t\t\t  (lazy-seq (lazy-common (rest a-seq)))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t([a-seq b-seq]\n\t\t\t\t\t(let [a-f (first a-seq) b-f (first b-seq)]\n\t\t\t\t\t\t(if (and a-f b-f)\n\t\t\t\t\t\t\t(cond (< a-f b-f) (lazy-common (rest a-seq) b-seq)\n\t\t\t\t\t\t\t\t(> a-f b-f) (lazy-common a-seq (rest b-seq))\n\t\t\t\t\t\t\t\t:else \t(cons a-f (lazy-seq (lazy-common (rest a-seq) (rest b-seq))))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t'()\n\t\t\t\t\t\t)\t\t\t\t\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t([a-seq b-seq & more]\n\t\t\t\t\t(reduce #(lazy-common %1 %2) (lazy-common a-seq b-seq) more)\n\t\t\t\t)\t\n\t\t\t)]\n\t\t\t(first (apply lazy-common more))\t\n\t\t)\n\t)\n)", "problem": 108, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn ls [& xs]  \n  (let [f (map first xs)\n        m (reduce min f)]\n    (if (every? (partial = m) f) m (apply ls (map #(if (= (first %) m) (rest %) %) xs)))))", "problem": 108, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "(fn f [& x]\n  (let [a (map first x)\n        b (apply min a)]\n    (if (apply = a) \n      b\n      (apply f (map (fn [c] (if (= b (first c)) (rest c) c)) x))\n      )))", "problem": 108, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [& xss]\n   (loop [xss xss n 7]\n     (let [f (map first xss)\n           m (reduce max f)]\n       (if (apply = f) \n         m\n         (recur\n           (map\n             (fn [xs] (drop-while (partial > m) xs))\n             xss)\n           (dec n))))))", "problem": 108, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn smallest-common \n  ([& colls]\n   ((fn [colls]\n     (let [transform (fn transform [f m k]\n                     (assoc m k (f (get m k))))\n           top (map first colls)]\n       (if (apply = top)\n         (first top)\n         (recur (->> colls\n                     (map first)\n                     (map list (range))\n                     (apply min-key second)\n                     first\n                     (transform next (vec colls)))))))\n    colls)))", "problem": 108, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn search [& p]\n  (loop [p p]\n    (if (some empty? p)\n      nil\n      (let [m (apply max (map first p))]\n        (if (apply = (map first p))\n          m\n          (recur (for [x p] (drop-while #(> m %) x)))\n        ) \n      )  \n    )  \n  )\n)", "problem": 108, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn lazy-searching [& xss]\n  (loop [xs xss]\n    (let [ini (first (apply map list xs))\n          minimum (apply min ini)]\n      (if (every? #(= minimum %) ini)\n        (first ini)\n        (recur (lazy-seq\n                 (map #(if (= minimum (first %))\n                         (rest %) %) xs)))))))", "problem": 108, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn [& seqs]\n  (let [heads (map first seqs)]\n    (if (apply = heads)\n      (first heads)\n      (recur (map (fn [s] (drop-while #(< % (apply max heads)) s)) seqs)))))", "problem": 108, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn [& colls]\n  (loop [pairs (vec colls)]\n    (if (apply = (map first pairs)) (ffirst pairs)\n      (let [i (apply min-key #(first (pairs %)) (range (count pairs)))\n            p (pairs i)]\n        (recur (assoc pairs i (rest p)))))))", "problem": 108, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [& colls]\n  (letfn [(get-slice [i] (map #(nth % i nil) colls))\n          (get-max [s] (apply max s))\n          (get-next [m col] (first (drop-while #(> m %) col)))\n          (finish? [s] (every? #(= (first s) %) s))]\n    (loop [max-value (get-max (get-slice 0))\n           current-slice (get-slice 0)]\n      (if-not (finish? current-slice)\n        (recur (get-max current-slice) (map #(get-next max-value %) colls))\n        (first current-slice)))))", "problem": 108, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn [& seq]\n   (letfn [(is-in-sorted-list [x lat]\n             (reduce #(or % %2) false (for [l lat :let [f (= x l)] :while (and (>= x l))] f)))]\n     (loop [f (first seq)\n           fv (first f)]\n       (if (reduce #(and % %2) (map (partial is-in-sorted-list fv) seq))\n         fv\n         (recur (rest f) (first (rest f)))))))", "problem": 108, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [& args]\n  (loop [minseqs (map #(do [(first %) (rest %)]) args)]\n      (let [mins (map first minseqs)\n            m minseqs]\n        (cond (some nil? mins) nil\n              (apply = mins) (first mins)\n              :else (let [mx (apply max mins)]\n                       (recur (for [[mn sq :as minseq] minseqs]\n                                  (if (< mn mx) [(first sq) (rest sq)] minseq))))))))", "problem": 108, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn lazysearch [& seqs] \n  (if (every? #(= (ffirst seqs) (first %)) seqs)\n      (ffirst seqs)\n      (let [sorted (sort-by first seqs)] ;; remove the smallest first element and recurs\n        (apply lazysearch (cons (next (first sorted)) (next sorted) )))))", "problem": 108, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn iter[& colls]\n  (let [nums (map first colls)]\n    (if (apply = nums)\n      (first nums)\n      (let [idx (.indexOf nums \n                          (apply min nums))]\n        (apply iter\n               (map-indexed #(if (= idx %1) (rest %2) %2) \n                    colls))))\n    ))", "problem": 108, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "problem": 108, "user": "50436470e4b034ff00315d23"}, {"code": "(fn* rec [& s]\n  (let [m (first (apply min-key first s))]\n    (if (every? #(= m (first %)) s)\n      m\n      (apply rec (map #(if (= m (first %)) (rest %) %) s)))))", "problem": 108, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn lzs [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [[[_ & h] & t] (sort-by first xs)]\n      (apply lzs (cons h t)))))", "problem": 108, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn f [& s]\n  (let [l (map first s)\n        m (apply max l)\n        g #(>= % m)]\n    (if (apply = l)\n      m\n      (apply f (map #(filter g %) s)))))", "problem": 108, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn lazy-search [& sequences]\n  (let [same? (fn [s]\n                (if (= 1 (count (distinct s)))\n                  true\n                  false)) \n        find-smallest (fn [s]\n                        (loop [s1 s, smallest nil]\n                          (if (empty? s1)\n                            smallest\n                            (let [new-smallest (cond\n                                                 (nil? smallest) (first s1)\n                                                 (< (first s1) smallest) (first s1)\n                                                 :else smallest)]\n                              (recur (rest s1) new-smallest)))))\n        mark-interest (fn [s]\n                        (let [smallest (find-smallest s)]\n                          (loop [s1 s, result []]\n                            (if (empty? s1)\n                              result\n                              (let [value (if (= smallest (first s1)) true false)]\n                                (recur (rest s1) (conj result value))\n                                )))))\n        ext-values (fn [seqs, stashed, marks]\n                     (loop [seqs2 seqs, result [], marks2 marks, stashed2 stashed]\n                       (if (empty? seqs2)\n                         result\n                         (let [s (first seqs2), mark (first marks2)]\n                           (recur\n                             (rest seqs2)\n                             (if (true? mark) \n                               (conj result (first s)) \n                               (conj result (first stashed2)))\n                             (rest marks2)\n                             (rest stashed2))\n                           ))))\n        ext-seqs (fn ext-seqs [seqs, marks]\n                   (loop [seqs2 seqs, result [], marks2 marks]\n                     (if (empty? seqs2)\n                       result\n                       (let [s (first seqs2), mark (first marks2)]\n                         (recur\n                           (rest seqs2)\n                           (if (true? mark)\n                             (conj result (drop 1 s))\n                             (conj result s))\n                           (rest marks2)\n                           )))))]\n  (loop [stashed (repeat (count sequences) 0), seqs sequences]\n    (let [marks (mark-interest stashed)\n          values (ext-values seqs, stashed, marks)\n          ss (ext-seqs seqs, marks)]\n      (if (same? values)\n        (first values)\n        (recur values ss))\n      ))))", "problem": 108, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn [& l]\n  (let [l (sort-by first l)\n        m (first (first l))]\n    (if (every? #(= m %) (map first l))\n      m\n      (recur (cons (next (first l)) (next l))))))", "problem": 108, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(letfn [(first-at-or-above [x s] (first (filter #(>= % x) s)))\n         ]\n   (fn [& seqs]\n     (first (filter (fn [e] (apply = (map #(first-at-or-above e %) seqs))) (first seqs)))))", "problem": 108, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn smallest-common [& collections]\n   (let [firsts (map first collections)\n         min-value (apply min firsts)\n         [min-idx min-col] (first (keep-indexed #(when (= (first %2) min-value) [%1 %2]) collections))\n        ]\n     (if (every? #(= (first firsts) %) firsts)\n       (first firsts)\n       (apply smallest-common (concat (conj(take min-idx collections) (rest min-col)) \n                                      (drop (inc min-idx) collections))))))", "problem": 108, "user": "525ed5f4e4b0cb4875a45db8"}, {"code": "(fn [& z] (letfn [(helper [l] (loop [h (first l) k (rest l)] (let [t (first h) l1 (map (fn [r] (filter #(<= t %) r)) k)]                                                                                \n                                                             (if (apply = (conj (map first l1) t)) t (recur (next h) l1)))))] (helper z)))", "problem": 108, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn [& colls]\n  (let [contained-by-all? (fn [n] (every? #(= n (first (filter (partial <= n) %))) colls))]\n    (first (filter contained-by-all? (first colls)))))", "problem": 108, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(fn [& a]\n   (loop [[s & ss] a]\n     (let [v (first s)\n           rs (map (fn [s] (drop-while #(< % v) s)) ss)]\n       (if (apply = (map first (conj rs s)))\n         v\n         (recur (conj rs (rest s)))))))", "problem": 108, "user": "5175533fe4b0dea9bbfba575"}, {"code": "(fn [& sq]\n  (let [s (map first sq)\n        x (reduce #(if (< %1 %2) %1 %2) s)]\n    (if (= 1 (count (set s))) x\n      (recur (map #(if (= x (first %)) (rest %) %) sq)))))", "problem": 108, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn lazy-search [& seqs]\n  (loop [xs (mapv first seqs)\n         seqs (vec seqs)]\n    (if (apply = xs)\n      (first xs)\n      (let [idx (->> (map-indexed vector xs)\n                     (apply min-key second)\n                     first)]\n        (recur (assoc xs idx (second (seqs idx)))\n               (update-in seqs [idx] rest))))))", "problem": 108, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [f & r]\n  (some (fn [e]\n          (if (every?\n                (fn [c]\n                  (= e (some #(if (>= % e) %) c)))\n                r)\n            e)\n          )\n    f))", "problem": 108, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [a0 & as]\n  (loop [i 0]\n    (let [e (nth a0 i)]\n      (if (every? (fn [ai]\n                    (loop [c ai]\n                      (let [ci (first c)] \n                        (cond (= ci e) true\n                              (> ci e) false\n                              :else (recur (next c))))))\n                  as)\n        e\n        (recur (inc i))))))", "problem": 108, "user": "5341b141e4b00652c8746ecf"}, {"code": "(letfn [(f1 [n x] (some #(if (<= n %) %) x))]\n  (fn f [[e & x] & xs]\n    (let [rs (map (partial f1 e) xs)]\n      (if (or (not (every? identity rs))\n              (apply = e rs))\n        e\n        (apply f x xs)))))", "problem": 108, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn f [& xss]\n  (let [xs (map first xss)\n        idx (.indexOf xs (apply min xs))]\n    (if (apply = xs)\n      (first xs)\n      (apply f (assoc (vec xss) idx (rest (nth xss idx)))))))", "problem": 108, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn lazy-search [& seqs] \n  (if (every? #(= (apply min (map first seqs)) %) \n              (map first seqs))\n    (first (first seqs))\n    (apply lazy-search \n           (map #(if (= (first %) (apply max (map first seqs))) % (rest %)) seqs))))", "problem": 108, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn common-small-number [& seqs]\n  (letfn [(max-first [seqs]\n                     (apply max (map first seqs)))\n          (first-equal? [seqs]\n                        (apply = (map first seqs)))\n          (update-coll [x coll]\n                      (if (> x (first coll))\n                        (update-coll x (rest coll))\n                        coll))]\n    (let [curr (max-first seqs)]\n      (if (first-equal? seqs)\n        curr\n        (apply common-small-number (map #(update-coll curr %) seqs))))))", "problem": 108, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn [& xss]\n  (let [largest (ffirst (reverse (sort-by first xss)))\n        advanced (map (fn [xs] (drop-while #(< % largest) xs)) xss)\n        firsts (map first advanced)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur advanced))))", "problem": 108, "user": "5312cdaae4b08068f379ed03"}, {"code": "; This only works, because the problem is contrived. The input\n; is known to be sorted, and there's actually an answer. This\n; will run forever if the input sequences are infinite and have\n; an empty set for an intersection. \n; \n; The last two lines here are god awful, but I didn't know about\n; some convenience functions like ffirst until I saw some other\n; solutions. \n;\n; Took about an hour and a lot of scratch paper to work this\n; out. Once I figured out the algorithm, the code was easy. I \n; suppose that's how these go. \n;\n; My general approach is:\n; 1. Sort the colls by their first values.\n; 2. If the first members of each coll are equal, this val is the answer.\n; 3. Otherwise drop the first coll's member (the smallest one)\n;    and repeat with step 1.\n;\n(fn [& colls]\n  (let [sorted-colls (sort-by first colls)]\n    (if (apply = (map first sorted-colls))\n      (first (first sorted-colls))\n      (recur (cons (rest (first sorted-colls)) (rest sorted-colls) )))))", "problem": 108, "user": "4eed26af535d93acb0a668bb"}, {"code": "(fn [l & ls]\n(let [lz (conj ls l)]\n(first\n(filter identity\n(map\n(fn [ocl] (reduce #(and %1 %2) true ocl))\n(map\n#(map\n(fn [cl]\n(some (fn [x] (#{x} %)) (take-while (fn [cn] (< cn (inc %))) cl)))\nlz)\nl))))))", "problem": 108, "user": "4fff289ae4b0678c553fc3fd"}, {"code": "(fn [& sequences]\n  (loop [sequences sequences]\n    (let [biggest-num-at-start-of-a-seq (apply max (map first sequences))\n          seqs-split-at-biggest-num (map (fn [s] (split-with #(<= % biggest-num-at-start-of-a-seq) s)) sequences)\n          seqs-up-to-including-biggest-num (map first seqs-split-at-biggest-num)\n          numbers-common-to-all (apply clojure.set/intersection (map set seqs-up-to-including-biggest-num))]\n      (if (empty? numbers-common-to-all)\n        (recur (map second seqs-split-at-biggest-num))\n        (first numbers-common-to-all)))))", "problem": 108, "user": "4ffa893fe4b0678c553fc3bc"}, {"code": "(fn [& args]\n  (loop [args args]\n    (if (some empty? args) \n      nil\n      (let [smallest-value (apply min (map first args))]\n        (if (every? #(= smallest-value (first %)) args)\n          smallest-value\n          (recur (map #(if (= smallest-value (first %)) (rest %) %) args)))))))", "problem": 108, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn smallest\n  [& sqs]\n  (let [seqs (if (coll? (first (first sqs))) (apply concat sqs) sqs)]\n    (if (every? empty? seqs)\n      false\n      (let [mx (apply max (map first seqs))\n            mn (first (first seqs))]\n        (if (every? #(= (first %) mn) seqs)\n          mn\n          (let [n (map (fn [s]\n                           (if (= (first s) mx) s (rest s))) seqs)]\n            (smallest n)))))))", "problem": 108, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn ! [& seqs]\n  (let [first-items (map first seqs)]\n    (if (apply = first-items)\n      (first first-items)\n      (let [smallest (apply min first-items)]\n        (apply ! (map (fn [s] (if (= (first s) smallest) (rest s) s))\n                      seqs))))))", "problem": 108, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn [& s]\n  (let [f (map first s)\n        m (apply min f)]\n    (if (apply = f)\n      m\n      (recur (map #(if (= m (first %)) (rest %) %) s)))))", "problem": 108, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n\t  (if (apply = (map first seqs))\n        (first (first seqs))\n        (let [smallest (apply min (map first seqs))]\n        \t(recur (map #(if (= smallest (first %)) (rest %) %) seqs))))))", "problem": 108, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn [& seqs]\n  ((fn [seqs]\n    (let [first-els (map first seqs)]\n      (if (apply = first-els)\n        (first first-els)\n        (let [min-el (apply min first-els)]\n          (recur (map #(if (= (first %) min-el) (rest %) %) seqs)))))) seqs))", "problem": 108, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn lazy-search [& xss]\n  (let [candidates (set (map first xss))\n        largest (apply max candidates)]\n    (if (= (count candidates) 1)\n      largest\n      (apply lazy-search (map (fn [xs] (drop-while #(< % largest) xs)) xss)))))", "problem": 108, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn lazysearch [& x]\n              (if (empty? (rest x))\n                (first (first x))\n                (loop [q (first (first x)) w (rest (first x)) counter0 (rest x) counter1 (first (rest x)) counter2 (first (first (rest x)))]\n                  (if (empty? counter0)\n                    q\n                    (if (== q counter2)\n                      (if (empty? (rest counter0))\n                        q\n                        (recur q w (rest counter0) (first (rest counter0)) (first (first (rest counter0)))))\n                      (if (> q counter2)\n                        (recur q w counter0 (rest counter1) (first (rest counter1)))\n                        (recur (first w) (rest w) (rest x) (first (rest x)) (first (first (rest x))))))))))", "problem": 108, "user": "532727bae4b09d4e7a9b54fa"}, {"code": "(fn  [x & xs]\n  (if (empty? xs) \n      (first x)\n      (letfn [(findit [n] (every? #(= n %) (map (comp last (partial take-while #(<= % n))) xs)))]\n         (first (filter findit x)))))", "problem": 108, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn [& xs]\n  (let [heads (map first xs)]\n    (if (apply = heads)\n      (first heads)\n      (let [min-head (apply min heads)]\n        (recur (map #(if (= %1 min-head) (rest %2) %2)\n                heads xs))))))", "problem": 108, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn __ [& args]\n  (let [eins (map first args)\n        ok (apply = eins)\n        minval (->> eins\n                    (filter (complement nil?))\n                    (apply min))]\n    (if ok minval (apply __ (map (fn [xs] (drop-while #(<= % minval) xs)) args)))))", "problem": 108, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "#(loop [colls %&]\n   (if (apply = (map first colls))\n     (ffirst colls)\n     (let [m (apply max (map first colls))]\n       (recur (map (fn [xs] (drop-while (partial > m) xs)) colls)))))", "problem": 108, "user": "4fe8a1f8e4b07c9f6fd12c5f"}, {"code": "(fn [s & xs]\n  (loop [i 0 c (nth s i)]\n    (cond\n     (nil? c) nil\n     (= (count (mapcat (fn [cs] (for [x cs\n                                      :while (<= x c) \n                                      :when (= x c)]\n                                  x)) xs)) \n        (count xs)) c\n     :else (recur (inc i) (nth s (inc i))))))", "problem": 108, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn [& colls]\n  (let [hs (map first colls)\n        hi-h (apply max hs)]\n    (if (apply = hi-h hs)\n      hi-h\n      (recur (map (partial drop-while #(< % hi-h))\n                  colls)))))", "problem": 108, "user": "524b0645e4b09eba1c0223bf"}, {"code": "(letfn [(M [s*]\n          (apply min (map first s*)))\n\n        (R [x s*]\n          (cond (empty? s*) s*\n                (= x (first (first s*))) (cons (rest (first s*))\n                                               (R x (rest s*)))\n                :else (cons (first s*)\n                            (R x (rest s*)))))\n\n        (G? [s*]\n          (apply = (map first s*)))\n\n        (S [s*]\n          (if (G? s*) (M s*)\n              (recur (R (M s*) s*))))]\n  (fn [& s*]\n    (S s*)))", "problem": 108, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn s [& ls]\n  (let [[[x & r] & q] (sort-by first ls)]\n    (if (every? #(= (first %) x) ls)\n      x\n      (apply s `(~r ~@q)))))", "problem": 108, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn smallest-common [& cols]\n  (let [sorted (sort-by first cols)]\n    (if (apply = (map first sorted))\n      (ffirst sorted)\n      (apply smallest-common (cons (rest (first sorted)) (rest sorted))))))", "problem": 108, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn [& args]\n  (let [glb' #(reduce max (map first %))]\n    (loop [glb  (glb' args)\n           seqs args\n           sets (vec (repeat (count args) #{}))]\n      (if-let [common (not-empty (apply clojure.set/intersection sets))]\n        (first common)\n        (let [new-seqs (map #(drop-while (fn [i] (< i glb)) %) seqs)\n              new-sets (map (fn [[sq st]] (conj st (first sq))) (map vector new-seqs sets))]\n          (recur (glb' new-seqs) new-seqs new-sets))))))", "problem": 108, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn [& x]\n  (loop [r x]\n    (let [f (map first r)\n          l (apply min f)]\n      (if (apply = f)\n        l\n        (recur (map #(drop-while (partial = l) %) r))))))", "problem": 108, "user": "4e8d5911535d65386fec2133"}, {"code": "(fn [ & v]\n    (let [gen-sort\n          (fn cc [vecs]\n            (let [vecs (remove empty? vecs)]\n              (when (seq vecs)\n                (let [vecs (into [] (sort-by first vecs))\n                      next-vecs (assoc vecs 0 (drop 1 (first vecs)))]\n                  (cons (ffirst vecs) (lazy-seq (cc next-vecs)))))))]\n      (ffirst (filter #(apply = %) (partition (count v) 1 (gen-sort v))))))", "problem": 108, "user": "53956118e4b0b51d73faaed6"}, {"code": "(fn t9 [ & l]\n   (letfn [(check [value coll]\n             (if (empty? coll)\n               false\n               (cond\n                 (= value (first coll)) true\n                 (> value (first coll)) (recur value (rest coll))\n                 :else false)\n               ))]\n     (first (for [x (first l)\n           :when (every? true? (map #(check x %) (rest l)))]\n         x\n       ))))", "problem": 108, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn f1 [& ss]\n  (let [sf (map first ss)]\n    (if (apply = sf)\n      (first sf)\n      (apply f1 (map #(drop-while (fn [a] (< a (apply max sf))) %) ss)))))", "problem": 108, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [current-elements (map #(first %) seqs)\n          distinct-current-elements (distinct current-elements)]\n      (if (= (count distinct-current-elements) 1)\n        (first distinct-current-elements)\n        (let [max-element (apply max current-elements)\n              next-seqs (map #(if (< (first %) max-element) (rest %) %) seqs)]\n          (recur next-seqs))))))", "problem": 108, "user": "53527551e4b084c2834f4af0"}, {"code": "(let [lzs (fn [colls]\n              (let [sorted (sort-by first colls)\n                    min-coll (first sorted)]\n                (when (seq min-coll)\n                  (if (apply = (map first colls))\n                    (first min-coll)\n                    (recur (cons (rest min-coll) (rest sorted)))))))]\n    (fn [& colls] (lzs colls)))", "problem": 108, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn [& seqs]\n  (if (apply = (map first seqs)) (ffirst seqs) ; if first elems of all seqs are all equal, return it\n    (let [j (first (apply min-key #(first (second %)) (keep-indexed vector seqs)))] ; let j = index of seq with smallest first elem                   \n      (recur (map-indexed (fn [i e] (if (= i j) (rest e) e)) seqs)))))              ; recurse after advancing j-th seq", "problem": 108, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn lazy-search [& s]\n  (if (apply = (map first s))\n    (first (first s))\n    (let [[f & r] (sort-by first s)]\n      (apply lazy-search (cons (rest f) r)))))", "problem": 108, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn common-min [& seqs]\n  (let [fs (first seqs)\n        rs (rest seqs)\n        mins-at-least (fn [x seqs2]\n                        (for [s seqs2]\n                          (last (take-while #(>= x %) s))))\n        is-the-one? (fn [x seq2]\n                      (= (mins-at-least x seq2)\n                        (for [s seq2] x)))]\n    (loop [possible-mins fs]\n      (if (empty? possible-mins)\n        nil\n        (if (is-the-one? (first possible-mins) rs)\n          (first possible-mins)\n          (recur (rest possible-mins)))))))", "problem": 108, "user": "52ee46e5e4b05e3f0be25ec5"}, {"problem": 108, "code": "(fn [& seqns]\n  (loop [seqns seqns]\n    (if (apply = (map first seqns))\n      (first (first seqns))\n      (let [largest (apply max (map first seqns))\n            drop-wrong (fn [s] (drop-while #(< % largest) s))\n            candidates (map drop-wrong seqns)]\n        (recur candidates)))))", "user": "53834ed3e4b06839e8705edb"}, {"problem": 108, "code": "(fn [& args]\n  (loop [smallest-candidate (apply min (map first args))\n         seqs args]\n    (let [heads (map first seqs)]\n      (if (apply = heads) (first heads)\n        (let [highest-head (apply max heads)]\n          (recur highest-head\n                 (map (fn [xs] (remove #(< % highest-head) xs))\n                      seqs)))))))", "user": "529e3a4fe4b04e0c58e87b92"}, {"problem": 108, "code": "(fn [ & l ]\n    (loop [ ll l ]\n        (let [fds (->> ll (map first) distinct (sort >)) cfds (count fds) big (first fds)]\n            (if (= cfds 1)\n                big\n                (recur (map (fn [sl] (drop-while #(< % big) sl)) ll))\n            )\n        )\n    )\n)", "user": "527ba695e4b03e8d9a4a7596"}, {"problem": 108, "code": "(fn ssn [& xs] (let [f (map first xs) \n                     m (apply max f) \n                     n (map #(drop-while (partial > m) %) xs)]\n                 (if (apply = f) (first f)\n                   (apply ssn n))))", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 108, "code": "(fn lsearch [& args]\n  (if (= (count args) 1) (ffirst args)\n   (let [r (for [x args] (first x))\n         s (last (sort r))]\n     (if (apply = r)\n       (first r)\n         (apply lsearch (loop [x args res ()]\n                          (if (empty? x) res\n                            (recur (rest x) (conj res (for [lst (first x) :let [z lst] :when (>= lst s)] z))))))))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 108, "code": "(fn\n  [& colls]\n  (letfn [(intersect-sorted-list [a b]\n            (lazy-seq\n              (if (and (seq a) (seq b))\n                (let [fa (first a)\n                      fb (first b)]\n                  (cond\n                    (< fa fb) (intersect-sorted-list (rest a) b)\n                    (> fa fb) (intersect-sorted-list a (rest b))\n                    :else (cons fa (intersect-sorted-list\n                                     (rest a) (rest b))))))))]\n    (first (reduce intersect-sorted-list colls))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 108, "code": "(fn check [& x] \n  (let [firsts (map first x)]\n    (cond \n     (some nil? firsts) nil\n     (apply = firsts) (first firsts)\n     :else (letfn [(help [col a]\n                         (drop-while #(< % a) col))]\n             (let [new-cols (map #(help % (apply max firsts)) x)]\n               (apply check new-cols))))))", "user": "5371167fe4b0fc7073fd6ea7"}, {"problem": 108, "code": "(fn lazy-search [h & r]\n  (let [hh (first h)\n        rd (map (fn [coll] (drop-while #(< % hh) coll))\n                r)\n        succ (every? #(= hh %) (map first rd))]\n    (if succ hh\n      (apply lazy-search (cons (rest h) rd)))))", "user": "51df825de4b01188f062752b"}, {"problem": 108, "code": "(fn f [& args]\n  (let [fs (map first args)\n        m (apply max fs)]\n    (if (apply = fs) m\n      (apply f (map #(if (< (first %) m) (rest %) %) args)))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 108, "code": "(fn lowest-common [& ls]\n  (loop [ls ls]\n    (let [lows (map first ls)\n          lowest (apply min lows)\n          highest (apply max lows)]\n      (if (every? #(= lowest %) lows)\n        lowest\n        (recur (map #(if (= lowest (first %)) (rest %) %) ls))))))", "user": "531bad96e4b08068f379ed93"}, {"problem": 108, "code": "(fn common [& ms]\n  (let [fs (map first ms)]\n    (if (apply = fs)\n      (first fs)\n      (apply common (for [m ms]\n                      (let [mf (apply min fs)]\n                        (if (= mf (first m))\n                          (rest m)\n                          m)))))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 108, "code": "(fn ex108-2\n  [& s]\n  (letfn [(search [s1 s2]\n            (if (coll? s1)\n              (let [a (first s1)\n                    b (first s2)]\n                (cond (= a b) a\n                      (< a b) (search (drop-while #(> b %) s1) s2)\n                      :else (search s2 s1)))\n              (if (= s1 (first (drop-while #(> s1 %) s2)))\n                s1\n                nil)))]\n    (cond (= 1 (count s)) (first (first s))\n          :else (let [low (apply search (take 2 s))]\n                     (if (search low (last s))\n                            low\n                            (apply ex108-2 (map #(drop-while (partial >= low) %) s)))))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 108, "code": "#(let [a (apply (juxt = max) (map first %&))]\n  (if\n   (a 0) (ffirst %&)\n   (recur (map (partial drop-while (partial > (a 1))) %&))\n  ))", "user": "5281a445e4b0757a1b17143a"}, {"problem": 108, "code": "(fn srch [& colls]\n  (cond (some empty? colls) nil\n    \t(apply = (map first colls)) (ffirst colls)\n      \t:else (let [m (apply min (map first colls))]\n        \t\t(recur (map #(if (= m (first %)) (rest %) %) colls)))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [firsts    (map first seqs)\n          too-small (fn [x] (< x (apply max firsts)))]\n  \t  (if (apply = firsts)\n        (first firsts)\n        (recur (map #(drop-while too-small %) seqs))))))", "user": "52c4af71e4b0c2d177d620e1"}, {"problem": 108, "code": "(fn minimal [ & colls ]\n  (let [firsts (map first colls)\n        d (distinct firsts)\n        m (apply min d)]\n    (if (= 1 (count d))\n      (first d)\n      (apply minimal (map #(if (= m (first %)) (rest %) %) colls)))))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 108, "code": "#(letfn [(in? [x [head & tail :as all]]\n          (if (seq all) (if (= head x) true (if (> head x) false (in? x tail))) false))\n        (in-all? [x [s & tail]] (if (in? x s) (if (seq tail) (in-all? x tail) true) false))    \n        (lazy-search [head & tail] \n          (if (seq tail)\n            (if (in-all? (first head) tail)\n              (first head) \n              (if (seq (rest head))\n                (apply lazy-search (rest head) tail) nil))\n            (first head)))\n        ] (apply lazy-search %&))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 108, "code": "(fn __\n  [x & xs]\n  (if (zero? (count xs))\n    (first x)\n    (letfn [(drop-less [x]\n                       (fn [y] (drop-while #(< % x) y)))]\n      (loop [x x\n             xs xs]\n        (if (> (first x) 64)\n          (println \"Max of 64 reached!!\")\n          (let [xs (map (drop-less (first x)) xs)]\n            (if (apply = (map first (concat [x] xs)))\n              (first x)\n              (recur\n               (drop 1 x)\n               xs))))))))", "user": "53ac4719e4b047364c04445c"}, {"problem": 108, "code": "(fn l [& colls]\n  (let [heads (map first colls)]\n    (when-not (some nil? heads)\n      (if (apply = heads)\n        (first heads)\n        (let [highest (apply max heads)]\n          (recur (map (fn [coll] (drop-while #(< % highest) coll)) colls)))))))", "user": "514d8084e4b019235f6c0588"}, {"problem": 108, "code": "(fn search [& args]         \n  (let [heads (map #(first %) args)\n        mx    (apply max heads)]\n    (if (apply = heads)\n      mx\n      (let [new-args (map (fn [s] (if (< (first s) mx)\n                                    (rest s)\n                                    s))\n                          args)\n            ]\n        (apply search new-args))))\n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 108, "code": "(fn lce [& xss]\n     (if (apply = (map first xss)) (first (first xss))\n       (let [sorted-xss (sort #(compare (first %1) (first %2)) xss)]\n         (apply lce (conj (rest sorted-xss) (rest (first sorted-xss)))))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 108, "code": "(fn gscn [& colls]\n  (let [hs (map first colls)]\n    (if (apply = hs)\n      (first hs)\n      (let [mn (apply max hs)]\n        (apply gscn (map (fn [c] (drop-while #(< % mn) c)) colls))))))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 108, "code": "(fn search [[x & xs] & sqs]\n    (if (empty? sqs) \n      x\n      (letfn [(sq-contains? [sq x]\n                (if (seq? sq) \n                    (if (> x (first sq)) \n                        (sq-contains? (rest sq) x)\n                        (= x (first sq)))))]\n        (if (every? #(sq-contains? (seq %) x) sqs) \n            x\n            (apply search (cons xs sqs))))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 108, "code": "(fn search [& sequences]\n  (let [smallest-values (map first sequences)]\n    (if (apply = smallest-values)\n      (first smallest-values)\n      (apply search (map #(if (= (apply min smallest-values)\n                                 (first %))\n                            (rest %)\n                            %)\n                         sequences)))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 108, "code": "(fn search [& cols]\n  (let [vs (first (apply map (fn [& v] v) cols))\n        f (apply max vs)]\n    (if (apply = vs)\n      f\n      (apply search (map (fn [x] (drop-while #(> f %) x)) cols)))))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 108, "code": "(fn common-min [& cc]\n  (let [good-coll (last (sort-by first cc))\n        have (fn [el coll] (some #{el} (take-while #(<= % el) coll)))\n        all-have (fn [el coll] (every? (partial have el) coll))]\n    (some #(when (all-have % cc) %) good-coll)))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 108, "code": "(fn smallest-lazy [& colls]\n  (let [n (apply max (map first colls))]\n    (if (every? (partial = n) (map first colls))\n      n\n      (apply smallest-lazy (map (fn [coll]\n                                  (if (< (first coll) n)\n                                    (drop 1 coll)\n                                    coll)) colls)))))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 108, "code": "(fn smallest-common [& colls]\n  (let [firsts (map first colls)\n        smallest (apply min firsts)\n        member? (fn [x coll]\n                  (loop [remaining coll]\n                    (cond\n                     (= x (first remaining)) true\n                     (< x (first remaining)) false\n                     :else (recur (rest remaining)))))]\n    (if (every? (partial member? smallest) colls)\n      smallest\n      (apply smallest-common (map #(if (< smallest (first %))\n                                     % (rest %)) colls)))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 108, "code": "(fn x [& seqs] (let [items (map first seqs)\n\t\t\t\t\t c (count (distinct items))\n\t\t\t\t\t m (apply max items)]\n(if (= 1 c) (first items)\n(apply x (for [s seqs] (if (< (first s) m) (rest s) s))))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 108, "code": "(fn l [v & vs]\n  (letfn [(i [v]\n            (let [f (first (first v))]\n              (cond (apply = (map first v)) f\n                    (not (= f (apply min (map first v)))) (recur (concat (rest v) (list (first v))))\n                    :else (recur (cons (rest (first v)) (rest v))))))]\n    (cond (empty? vs) (first v)\n          :else (i (cons v vs)))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 108, "code": "(fn f [& s]\n\t(if (= 1 (count (distinct (map first s)))) (first (first s))\n   \t\t(let [m (apply max (map first s))\n              new-s (map #(if (< (first %) m) (rest %) %) s)]\n      \t(apply f new-s))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 108, "code": "(fn [& xs]\n    (loop [xs xs]\n      (let [MM (apply max (map #(first %) xs))\n            mm (apply min (map #(first %) xs))]\n        (if (= MM mm) MM\n            (recur (map #(if (= (first %) MM) % (rest %)) xs))\n            ))\n      ))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 108, "code": "(fn f [& c]\n  (when (every? seq c)\n    (let [r (map first c)\n          m (apply max r)]\n      (if (apply = r)\n        m\n        (apply f (map #(if (< (first %) m)\n                         (rest %)\n                         %) c))))))", "user": "53034738e4b0d8b024fd373e"}, {"problem": 108, "code": "(fn find-min [& colls]\n  (let [fs (map first colls)\n        a (apply min fs)\n        b (apply max fs)]\n    (if (= a b) a\n      (apply find-min\n        (map\n          (fn [coll]\n            (if (< (first coll) b) (rest coll) coll))\n          colls)))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 108, "code": "(fn [& ls]\n  (let [firsts (map first ls)\n        m (apply max firsts)]\n    (if (apply = firsts)\n      m\n    (recur (map #(drop-while (partial > m) %) ls)))))", "user": "4fc8c8d8e4b0ee37620e183b"}, {"problem": 108, "code": "(fn sm [& r]\n  (let [m (map #(first %) r)]\n  \t(if (apply = m) \n      (first m)\n  \t  (let [mx (apply max m)]\n  \t\t\t(recur \n  \t\t\t\t(map (fn[a](drop-while #(< % mx) a)) r))))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 108, "code": "(fn [& args]\n    (loop [zs args]\n      (cond \n       (some nil? (map seq zs)) nil\n       (apply = (map first zs)) (ffirst zs)\n       :else (let [max-v (apply max (map first zs))]\n               (recur (map #(drop-while (fn [x] (< x max-v)) %) zs))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 108, "code": "(fn [& c] \n  (letfn [(sorter [s] (sort-by #(apply max (nth % 1)) s))] \n    (loop [s1 (map-indexed #(vector % #{(first %2)}) c) ] \n      (let [s2 (sorter s1) \n            i (first (apply clojure.set/intersection (map last s2)))\n            f (first s2) \n            fs (first f) \n            sf (second f)] \n        (or \n          i\n          (recur (conj \n                  (drop 1 s2) \n                  [fs (conj sf (nth (nth c fs) (count sf)))])))))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 108, "code": "(fn [& ls]\n  (if (apply = (map first ls))\n      (first (first ls))\n      (recur \n        (map #(if \n                (= (first %) (apply min (map first ls)))\n                (rest %)\n                %) ls))))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 108, "code": "(fn ls [& colls]\n   (let [firsts (map first colls)\n         minFirst (apply min firsts)]\n     (if (every? #(= minFirst %) firsts)\n       minFirst\n       (apply ls (map (fn [coll] (remove #(= minFirst %) coll)) colls)))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 108, "code": "(fn [& colls] (let \n   [fs (map #(first %) colls)] \n   (if (apply = fs) \n     (first (first colls))\n     (let [min (reduce #(if (< %1 (first %2)) %1 (first %2)) Integer/MAX_VALUE colls)]\n       (recur (map #(if (= min (first %)) (next %) %) colls))))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 108, "code": "(fn peu [& x] (let [y (map first x)] (if (apply = y) (first y) (let [z (apply min y)] (apply peu (concat (map rest (filter #(= z (first %)) x)) (filter #(not (= z (first %))) x)))))))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n   (let [real-seqs (filter seq seqs)\n         heads (map first real-seqs)]\n     (if (apply = heads)\n       (first heads)\n       (let [sorted-seqs (sort-by first real-seqs)\n             first-new (rest (first sorted-seqs))\n             rest-new (rest sorted-seqs)\n             all-new (cons first-new rest-new)]\n         (apply lazy-search all-new )))))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 108, "code": "(fn ! [x & xs]\n  (letfn [\n          (rslt [ss] \n                 (let [sls (map first ss)\n                       sms (reduce min sls)\n                       rmsms (map #(if (= (first %) sms) (drop 1 %) %) ss)]\n                   rmsms))\n          (ok? [ss] \n               (= 1 (count (distinct (map first ss)))))\n          (dothework [ss]\n            (if (ok? ss) (-> ss first first)\n              (dothework (rslt ss))))\n          ]\n    (dothework (cons x (vec xs)))\n    ) )", "user": "52faec2ee4b047fd55837004"}, {"problem": 108, "code": "(fn [& s]\n  (let [heads (map first s) highest (apply max heads)]\n    (cond\n     (some nil? heads) nil\n     (apply = heads) highest\n     :else (recur (map (partial filter (partial <= highest)) s)))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 108, "code": "(fn [& colls]\n  (let [firsts (map first colls)\n        target (apply max firsts)]\n    (if (every? #(= target %) firsts)\n      target\n      (recur (map #(if (= (first %) target) % (rest %)) colls)))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 108, "code": "(fn [& cols] (loop [m (apply max (map first cols))]\n               (let [xs (map #(take-while (partial >= m) %) cols)\n                     common (apply clojure.set/intersection (map set xs))]\n                 (if (empty? common)\n                   (recur (+ m 1))\n                   (first common)))))", "user": "531f1e63e4b08068f379edc2"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [s seqs]\n    (let [row (map first s)\n          m (apply max row)]\n      (if (apply = row)\n        m\n        (recur (map #(if (= m (first %)) % (next %)) s))))))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 108, "code": "(fn f [& coll] (let [min-of-sets (->> coll (map first) (apply min))\n                      filter-p (fn filt [p coll] (filter #(p (first %) min-of-sets) coll))\n                      smallest-coll (map rest (filter-p = coll))\n                      remaining-colls (filter-p not= coll)]\n                  (if (apply = (map first coll))\n                    (ffirst coll)\n                    (apply f (concat smallest-coll remaining-colls)))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-elements (map first colls)]\n    (if (every? #(= (first first-elements) %) first-elements)\n      (first first-elements)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "52474133e4b05ef8e38e635e"}, {"problem": 108, "code": "(fn ls [& as]\n  (loop [as as]\n    (let [[f & t :as a] (sort-by first as)\n          l (last a)\n          ff (first f)\n          fl (first l)]\n      (if (= ff fl)\n        ff\n        (recur (conj t (rest f)))))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 108, "code": "(fn lazy-search\n  [& seqs]\n  (letfn [(greatest\n            [seqs]\n            (apply max (map first seqs)))\n          (level-out\n            [greatest seqs]\n            (map (fn [s] (drop-while #(< % greatest) s)) seqs))\n          (first-equal?\n            [seqs]\n            (apply = (map first seqs)))\n          (any-empty?\n            [seqs]\n            (some #{true} (map empty? seqs)))]\n    (if (any-empty? seqs) \n      nil\n      (let [g (greatest seqs)\n            leveled-seqs (level-out g seqs)]\n        (if (first-equal? seqs) \n          g\n          (apply lazy-search leveled-seqs))))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 108, "code": "(fn [& sqs]\n  (if (= (count sqs) 1)\n    (ffirst sqs)\n    (loop [sqs sqs]\n      (let [hs (map first sqs)]\n        (if (apply = hs)\n          (first hs)\n          (let [[h & rst] (sort-by first sqs)]\n            (recur (cons (rest h) rst))))))))", "user": "54157dace4b01498b1a719f4"}, {"problem": 108, "code": "(fn lazy-search2 [& colls]\n  (if (apply = (map first colls))\n    (ffirst colls)\n    (let [colls (sort-by first > colls)]\n      (apply lazy-search2 (map (fn [coll] (if (< (first coll) (ffirst colls)) (drop 1 coll) coll)) colls)))))", "user": "541096bde4b01498b1a719b2"}, {"problem": 108, "code": "(fn [& colls]\n   (cond (every? #(= % (first (first colls))) (map first colls)) (first (first colls))\n         :else (let [m (apply max (map first colls))]\n                 (recur (map (fn [coll]\n                                     (drop-while #(< % m) coll)) colls)))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 108, "code": "(fn f [& x]\n  (let [s (reverse (sort-by first x))\n        m (first (first s))\n        r (map (partial drop-while #(> m %)) s)]\n    (if (every? #(= (first %) m) r)\n      m\n      (apply f r))))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n    (let [first-eles (map first colls)]\n      (if (every? #(= (first first-eles) %) first-eles)\n        (first first-eles)\n        (let [sorted-colls (sort-by first colls)]\n          (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 108, "code": "(fn [& args] (loop [n 0]\n               (let [sublists (map (partial take-while #(<= % n)) args),\n                     isect (apply clojure.set/intersection (map set sublists))]\n                 (if (not (empty? isect)) \n                   (first isect)\n                   (recur (inc n))))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 108, "code": "(fn [l & ls]\n  (letfn[(findVal[sv v]\n                  (loop[i 0]\n                    (let[cv (nth sv i)]\n                      (cond\n                       (= cv v) true\n                       (> cv v) false\n                       :else (recur (inc i))\n                       ))))]\n    (if (seq ls) (loop [i 0]\n                   (let [lv (nth l i)]\n                     (if (reduce #(and %1 %2) (map #(findVal % lv) ls)) lv\n                       (recur (inc i))\n                       )\n                     )\n                   )\n      (first l)\n      )\n    )\n  )", "user": "541619e8e4b01498b1a719f9"}, {"problem": 108, "code": "(fn [& a] ((fn [args]\n                 (let [heads (map first args)\n                       min-index (nth (reduce (fn [[c i m] e] (if (< e m)\n                                                                [(inc c) c e]\n                                                                [(inc c) i m])) [0 -1 Integer/MAX_VALUE] heads) 1)]\n                   (if (apply = heads)\n                     (first heads)\n                     (recur (assoc (into [] args) min-index (rest (nth args min-index))))))) a))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 108, "code": "(fn [& sqs]\n    (let [fsq (map first sqs)\n          mfs (apply min fsq)]\n      (if (apply = fsq) mfs\n          (recur (map (fn [sq] (drop-while #(= mfs %) sq)) sqs)))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [l-first (apply max (map first seqs))\n        xs (map (partial drop-while #(> l-first %)) seqs)]\n    (if (apply = (map first xs))\n      l-first\n      (recur xs))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 108, "code": "(fn [& cols]\n ((fn [coll-of-colls]\n    (let [sorted-cols (sort #(compare (first %1) (first %2)) coll-of-colls)\n          ff (first (first sorted-cols))]\n      (if (nil? ff) nil\n        (let [all-eq (every? #(= (first %1) ff) sorted-cols)]\n          (if all-eq ff\n            (recur (map #(if (= ff (first %)) (rest %) %) sorted-cols))\n          )))))\n   cols)\n  )", "user": "50856bd1e4b004985b776e4c"}, {"problem": 108, "code": "(fn [& c]\n  (let [f (map first c)]\n    (if (apply = f)\n      (first f)\n      (recur (map #(remove (partial > (apply max f)) %) c)))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 108, "code": "(fn [a & b]\n  (let [pvec (fn pv [v bg] (map #(if-not (= bg (first %)) (rest %) %) v))]\n  (loop [vecs (into (vector a) b)\n         biggest (apply max (map #(first %) vecs))]\n    (if (apply = (map #(first %) vecs))\n      (first (first vecs))\n        (recur (pvec vecs biggest) (apply max (map #(first %) (pvec vecs biggest))))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 108, "code": "(fn lazy-search [xs & yss]\n  (let [x (first xs)]\n    (if (empty? yss) x\n      (let [fyss (map (fn [h] (drop-while #(< % x) h)) yss)]\n        (if (every? #(= (first %) x) fyss) x\n          (apply lazy-search (rest xs) fyss))))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 108, "code": "(fn f [& s]\n          (let [i (map first s)\n                m (apply min i)]\n            (if (apply = i) m\n              (apply f (map #(if (= m (first %)) (rest %) %)\n                            s)))))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 108, "code": "(fn [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls)\n          largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "53bf9cfbe4b0c98a41f5cca4"}, {"problem": 108, "code": "(fn common1\n  [& args]\n  (let [initseq (map (comp float first) args)]\n    (if (apply = initseq)\n        (int (first initseq))\n        (let [new_args (map (fn [seq1] (if (= (apply max initseq) (float (first seq1))) seq1 (rest seq1))) args)]\n         (apply common1 new_args)))\n      )\n    )", "user": "53d6b266e4b0e771c3025459"}, {"problem": 108, "code": "(fn f [& xs]\n  (let [items (map first xs)\n        m (apply max items)]\n    (if (apply = items)\n      m\n      (apply f \n             (map (fn [ls] (filter #(>= % m) ls)) xs)))))", "user": "54448e84e4b032a45b869393"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [heads (map first seqs)\n        big (apply max heads)]\n    (if (apply = heads)\n      big\n      (recur (map #(drop-while (partial > big) %) seqs)))))", "user": "50d882d4e4b01f0871336e69"}, {"problem": 108, "code": "#(loop [s %&]\n   (if (apply = (map first s))\n     (ffirst s)\n     (let [[[_ & x] & y] (sort-by first s)]\n       (recur (remove not (cons x y))))))", "user": "4db2903f535df7e46ed9b6bf"}, {"problem": 108, "code": "(fn [& xs]\n  (letfn[(go\n           [xss]\n           (if (or (empty? xss) (some empty? xss))\n             nil\n             (let [heads (map first xss)\n                   xss' (sort-by first xss)]\n               (if (apply == heads)\n                 (first heads)\n                 (go (cons (rest (first xss'))\n                           (rest xss')))))))]\n      (go xs)))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 108, "code": "(fn [& collections]\n  (loop [current-collections collections]\n    (let [values (map first current-collections)\n          max-value (apply max values)]\n      (if (apply = values)\n        (first values)\n        (recur (map (fn [collection]\n                      (drop-while #(< % max-value) collection))\n                    current-collections))))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 108, "code": "(fn f [& xs]\n  (let [hs (set (map first xs))]\n    (if (= 1 (count hs)) (first hs)\n      (let [[[_ & ys] & rs] (sort-by first xs)]\n        (apply f (cons ys rs))))))", "user": "5323a414e4b09d4e7a9b54d1"}, {"problem": 108, "code": "(fn lzys [& cols]\n  (let [mn (map first cols)\n        mx (apply max mn)] \n    (if (apply = mn)\n      mx \n      (apply lzys \n             (map #(drop-while (partial > mx) %) cols)))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 108, "code": "(fn [& ss]\n  ((fn f [ss]\n     (let [fs (mapv first ss)\n           m (apply min fs)]\n       (if (apply = fs)\n         (first fs)\n         (recur (map #(if (= m (first %)) (rest %) %) ss)))))\n   ss))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 108, "code": "(fn\n  ([[f & _]] f)\n  ([f & n] (let [h (first f)\n                ls (map (fn [s] (drop-while #(< % h) s)) n)]\n                  (if (every? #(= h (first %)) ls)\n                    h\n                    (recur (rest f) ls)))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [left (map (juxt first rest) colls)]\n    (if (apply = (map first left))\n      (ffirst left)\n      (recur\n       (let [max* (apply max (map first left))]\n         (for [[x xs] left]\n           (if (< x max*)\n             ((juxt first rest) (drop-while (partial > max*) xs))\n             (list x xs))))))))", "user": "505aa653e4b021387fb89857"}, {"problem": 108, "code": "(fn lazysearch [& sequences]\n  (let[y (map first sequences) ]\n        ( if(apply = y) (first y) \n          (apply lazysearch (map (fn[x](drop-while #(< % (apply max y)) x)) sequences)))))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [cs colls]\n    (let [fs (map first cs)\n          eq (apply = fs)\n          mx (apply max fs)]\n      (if eq\n        mx\n        (recur (map (fn [c] (drop-while #(< % mx) c)) cs))))))", "user": "51e38568e4b0c611d6113e43"}, {"problem": 108, "code": "(fn m [a & more]\n  (loop [n (first a)\n         seqs (conj more a)]\n    (let [heads (map first seqs)]\n      (if (apply = n heads)\n        n\n        (recur (apply max (conj heads n))\n               (map #(drop-while (fn [x] (< x n)) %) seqs))))))", "user": "544e9022e4b0e3978000698b"}, {"problem": 108, "code": "(fn lazy-sort [& seqs]\n  (if (apply = (map first seqs))\n    (-> seqs first first)\n    (let [sorted (sort-by first seqs)\n          dropped (-> sorted first rest)\n          new-seqs (conj (rest sorted) dropped)]\n      (apply lazy-sort new-seqs))))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 108, "code": "(let [next (fn [sets seqs]\n             (let [maxs  (mapv #(apply max 0 %) sets)\n                   maxmax (apply max maxs)\n                   minmax (apply min maxs)\n                   purged-sets (mapv (fn [s] (set (filter #(>= % minmax) s))) sets)\n                   next-set-and-seq  (mapv\n                                      (fn [set' max' seq']\n                                        (if (and (not (= 0 max')) (= maxmax max'))\n                                          [set' seq']\n                                          [(conj set' (first seq')) (rest seq')]))\n                                      purged-sets maxs seqs)]\n               (apply mapv vector next-set-and-seq)))]\n  (fn [& seqs]\n    (condp = (count seqs)\n      0 nil\n      1 (apply min (first seqs))\n      (loop [sets (mapv (constantly #{}) seqs) seqs seqs]\n        (clojure.pprint/pprint sets)\n        (let [i (apply clojure.set/intersection sets)]\n          (if (empty? i)\n            (let [[set' seq'] (next sets seqs)]\n              (recur set' seq'))\n            (apply min i)))))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 108, "code": "(fn [l & ls]\n        (some\n         #(when (every? (fn [lst] (some (partial = %) (take-while (fn [x] (<= x %)) lst))) ls) %)\n         l))", "user": "502873a8e4b01614d1633ff8"}, {"problem": 108, "code": "(fn [& colls]\n      (loop [rests colls]\n             (let [heads (map first rests)\n                   std (apply max heads)]\n             (if (apply = heads)\n                 std\n                 (recur (map #(if (< (first %) std)\n                                  (rest %)\n                                  %) rests))))))", "user": "5478c4fee4b0c51c1f4d72c0"}, {"problem": 108, "code": "(fn [& args]\n  (letfn [(lsearch2 [a]\n            (let [smallest (apply min (map first a))\n                  nextargs (reduce #(if (= (first %2) smallest) (conj % (rest %2)) (conj % %2)) (list) a)\n                  found-answer (apply = (map first a))]\n              (if found-answer\n                (first (first a))\n                (lsearch2 nextargs))))]\n    (lsearch2 args)))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 108, "code": "(fn [& seqs]\n  (letfn [(in-seqs [x & ss]\n            (if-not (nil? (first ss))\n              (if-not\n                  (some #{x} (take-while #(<= % x) (first ss)))  false\n                  (apply in-seqs x (next ss)))\n              true))]\n    (loop [s (first seqs) e (first s)]\n      (if e\n        (if (apply in-seqs e (next seqs)) e\n            (recur (next s) (first (next s))))\n        false))))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 108, "code": "(fn [& xs]\n  (loop [seqs xs]\n    (if (apply = (map first seqs))\n      (ffirst seqs)\n      (let [max-first (apply max (map first seqs))]\n        (recur (map #(if (< (first %) max-first) (rest %) %) seqs))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 108, "code": "(fn [& args]\n  (letfn [(occur [x s] (->> s\n                            (take-while (partial >= x))\n                            (filter (partial = x))\n                            empty?\n                            not))]\n    (->> (first args)\n         (filter #(every? (partial occur %) (rest args)))\n         (first))))", "user": "5479c58de4b0c51c1f4d72c7"}, {"problem": 108, "code": "(fn [& xs]\n\t((fn [s]\n\t\t(let [mins (map first s) maxmin (apply max mins)]\n\t\t\t(if (apply = mins)\n\t\t\t\tmaxmin\n\t\t\t\t(recur (map #(if (= (first %) maxmin) % (rest %)) s))))) xs))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 108, "code": "(fn lsn [& allseqs]\n  (loop [s allseqs]\n    (let [maf (apply max (map first s))\n          n_s (map (fn [v] (drop-while #(< % maf) v)) s)]\n      (if (apply = (map first n_s)) (first (first n_s))\n        (recur n_s)))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 108, "code": "(fn leastc [& seqs]\n \n  (let [f (map first seqs)]\n    (if (apply = f)\n        (first f)\n        (recur\n          (map #(if (= (first %) (apply min f)) (next %) %) seqs)))\n    ))", "user": "54924f64e4b0b312c081ff42"}, {"problem": 108, "code": "(fn scn [& colls]\n  (let [x (map first colls) y (apply max x)]\n    (if (apply = x)\n      (first x)\n      (apply scn (map #(if (= (first %) y) % (rest %)) colls)))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 108, "code": "(fn lazy-search [& c]\n  (if (apply = (map first c))\n      (ffirst c)\n      (let [search-val (apply max (map first c))]\n        (recur (map #(filter (partial <= search-val) %) c)))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 108, "code": "(fn smallest-common-element [& colls]\n  (let [sorted (sort-by first colls)]\n    (if (= 1 (count (set (map first sorted))))\n      (first (first sorted))\n\t  (apply smallest-common-element (drop 1 (first sorted)) (rest sorted)))))", "user": "4f3e5e87e4b0e243712b1f83"}, {"problem": 108, "code": "(fn search [l & ls ]\n  (letfn [(scan [c e]  (= e (last (take-while #(<= % e) c))))]\n    (some (fn [e] (if (reduce #(and % (scan %2 e)) true ls) e)) l)))", "user": "512b07f7e4b078b06821febb"}, {"problem": 108, "code": "(fn [& colls]\n  (let [x (first (apply map max colls))\n        new-colls (for [coll colls]\n                    (drop-while #(< % x) coll))\n        new-comp (map first new-colls)]\n    (if (apply = new-comp)\n      (first new-comp)\n      (recur new-colls))))", "user": "54848141e4b0e286459a119e"}, {"problem": 108, "code": "(fn s [& xs]\n  (let [hs (map first xs)\n        m  (apply max hs)]\n    (if (apply = hs) m\n      (apply s (map #(if (< % m) (rest %2) %2) \n                    hs xs)))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 108, "code": "(fn [& cx] (let [fst (fn [bs] (map first bs))\n                   rst (fn [bs n] (map #(drop-while (partial > n) %) bs))]\n               ;(fst cx)\n               (loop [cs cx]\n                 (let [f  (fst cs)\n                       ma (apply max f)\n                       mi (apply min f)]\n                   (if (= ma mi)\n                     (ffirst cs)\n                     (recur (rst cs ma)))))\n               ))", "user": "549375e4e4b0b312c081ff4e"}, {"problem": 108, "code": "(fn find-match [x & zs]\n  (let [get-max (fn [cs] (apply max (map first cs)))\n        els-match? (fn [cs] (= (count (distinct (map first cs))) 1))\n        colls (if zs (cons x zs) x)\n        ]\n    (if (coll? (first colls))\n      (if (els-match? colls)\n        (first (first colls))\n        (find-match (map #(if (= (first %) (get-max colls)) % (drop 1 %)) colls)))\n      (first x)\n      )))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 108, "code": "(fn [& xs]\n  (loop [xs xs]\n    (when-let [no-empty (every? (complement empty?) xs)]\n      (let [first-vals (map first xs) min-val (apply min first-vals)]\n        (if (every? #(= min-val %) first-vals)\n          min-val\n          (recur (map #(if (= min-val (first %)) (rest %) %) xs)))))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 108, "code": "(fn [& c]\n  (letfn [(m [col num](if (>= (first col) num) col (recur (rest col) num)))]\n    (let [f (map first c), mf (reduce max f)]\n      (if (apply = f) (first f) (recur (map #(m %1 mf) c))))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 108, "code": "(fn [& xs]\n  (if (= 1 (count xs))\n    (first (first xs))\n    (let [h (map first xs) \n          largest (apply max h)]\n      (cond \n       (apply = h) largest\n       :else (recur (map (fn [x] (drop-while #(< % largest) x)) xs))))))", "user": "5409a12fe4b0addc1aec66df"}, {"problem": 108, "code": "(fn [& xss]\n   (loop [yss xss]\n     (let [ts (map first yss)\n           minv (apply min ts)\n           maxv (apply max ts)]\n       (if (= minv maxv)\n         minv\n         (recur (map #(if (= (first %) minv) (drop 1 %) %) yss))))))", "user": "5488537be4b0e286459a11cf"}, {"problem": 108, "code": "(fn \n [coll & colls]\n  (let [curr (first coll)\n        firsts (map first colls)]\n    (println curr)\n    (println firsts)\n    (cond (apply = curr firsts)\n          curr\n          (every? (partial <= curr) firsts)\n          (recur (rest coll) colls)\n          :else\n          (recur coll (for [c colls]\n                        (if (< (first c) curr)\n                          (rest c)\n                          c))))))", "user": "543c39e0e4b032a45b86933d"}, {"problem": 108, "code": "(fn m [& cols]\n  (let [big (apply max (map first cols))\n        new-col (map (partial drop-while #(< % big)) cols)]\n        (if (apply = (map first new-col))\n          (first (first new-col))\n          (recur new-col))))", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 108, "code": "(fn f [& s] (let [a (map first s) m (apply min a)] (if (apply = a) m (apply f (map #(if (= m (first %)) (rest %) %) s)))))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [state (map #(vector (first %1) (drop 1 %1)) seqs)]\n    (let [cur-max (apply max (map first state))]\n      (if (apply = (map first state))\n        (ffirst state)\n        (recur\n         (map (fn [[cur s]]\n                (if (= cur cur-max)\n                  (vector cur s)\n                  (vector (first s) (drop 1 s))))\n              state))))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 108, "code": "(fn this [ & l ] \n  (let [new (sort-by first l)]\n    (if (= (first (first new)) (first (last new)))\n      (first (first l))\n      (apply this (conj (rest new) (rest (first new)) ))\n      )\n    )\n  )", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 108, "code": "(fn common-min [& seqs]\n  (let [lowest-vals (map first seqs) lowest-of-all (apply min lowest-vals)]\n    (if (every? (partial = lowest-of-all) lowest-vals)\n      lowest-of-all\n      (recur (map #(if (= lowest-of-all (first %)) (rest %) (identity %)) seqs)))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 108, "code": "(fn [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [els (map first colls) \n          max-el (apply max els)]\n      (if (apply = els)\n        max-el\n        (recur (map (fn [coll] (drop-while #(< % max-el) coll)) colls))))))", "user": "532902f8e4b09d4e7a9b550e"}, {"problem": 108, "code": "(fn [& vs]\n    (let [drop-function* (fn [max-value]\n                           (partial drop-while (partial > max-value)))\n          ended? (some empty? vs)\n          firsts (map first vs)\n          all-same (apply = firsts)]\n      (cond\n        ended? nil\n        all-same (first firsts)\n        :else (let [max-value (apply max firsts)\n                    drop-function (drop-function* max-value)\n                    new-vs (map drop-function vs)]\n                (recur new-vs)))))", "user": "545bd22fe4b01be26fd7465a"}, {"problem": 108, "code": "(fn [& vs]\n\t(loop [vs vs]\n\t\t(if (apply = (map first vs))\n\t\t\t(ffirst vs)\n\t\t\t(let [a (sort-by first vs)\n\t\t\t\t a1 (first a)\n\t\t\t\t as (rest a)]\n\t\t\t\t(recur (cons (rest a1) as))))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 108, "code": "(fn __ [& ls]\n  (if (some empty? ls) nil\n    (let [fs (map first ls)\n          m (apply max fs)]\n      (if (apply = fs) m\n        (recur (map (fn [xs] (drop-while #(< % m) xs)) ls))))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 108, "code": "(fn [ & ss ]\n  (let [els (map first ss)\n        min-el (apply min els)]\n    (if (apply = els)\n      min-el\n      (let [args (map #(filter (fn [e] (not= e min-el)) %) ss)]\n        (recur args)))))", "user": "52fc34cee4b047fd55837015"}, {"problem": 108, "code": "(fn m [& ss]\n  (let [els (map first ss)\n        min-el (apply min els)\n        max-el (apply max els)]\n    (if (apply = els)\n      min-el\n      (recur (map #(drop-while (partial > max-el) %) ss)))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (let [xs (map first seqs)]\n    (if (apply = xs) (first xs)\n      (recur (map #(remove (partial > (apply max xs)) %) seqs)))))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 108, "code": "(fn [& v]\n    (loop [v (map #(vector (first %) (rest %)) v)]\n      (let [maximum (apply max (map first v))]\n        (if (apply = (map first v))\n          (first (first v))\n          (recur\n            (map\n              #(if (< (first %) maximum)\n                 [(first (second %)) (rest (second %))]\n                 %\n                 )\n              v\n              )\n            )\n          )\n        )\n      )\n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 108, "code": "(fn [& xs]\n  (loop [\n     xs xs\n    ]\n    (let [\n        firsts (first (apply (partial map vector) xs))\n        equal (every? (partial = (first firsts)) (rest firsts))\n        smallest (apply min firsts)\n        smallest? (partial = smallest)\n        drop-while-smallest #(drop-while smallest? %)\n        without-smallest (map drop-while-smallest xs)\n      ]\n      (if equal smallest (recur without-smallest))\n    )\n  )\n)", "user": "516ee939e4b06aac486e5b34"}, {"problem": 108, "code": "(fn lazy-search\n    [& cols]\n    (if (= 1 (count cols))\n      (ffirst cols)\n      (let [heads (map first cols)\n            largest (apply max heads)]\n        (if (apply = heads)\n          (first heads)\n          (recur\n            (-> (partial drop-while #(< % largest))\n                (map cols)))))))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [heads (first (apply map list seqs))\n        mx (apply max heads)]\n    (if (apply = heads)\n      mx\n      (let [newseqs (for [xs seqs]\n                      (if (>= (first xs) mx) \n                        xs\n                        (rest xs)))]\n        (recur newseqs)))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [firsts (map first seqs)\n        min (apply min firsts)\n        max (apply max firsts)]\n    (if (= min max)\n      min\n      (recur (map #(if (= max (first %)) % (rest %))\n                  seqs)))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 108, "code": "(letfn [(merge [[x & xs :as xss] [y & ys :as yss]]\n            (lazy-seq (cond (empty? xss) yss\n                            (empty? yss) xss\n                            (< x y) (cons x (merge xs yss))\n                            :else   (cons y (merge xss ys)))))\n          ]\n    (fn [& xss] (->> xss (reduce merge '())\n                     (partition-by identity)\n                     (filter #(= (count %) (count xss)))\n                     first\n                     first))\n  )", "user": "54c641f8e4b045293a27f628"}, {"problem": 108, "code": "(fn lazy-search\n  ([c] (first c))\n  ([c & colls]\n   (loop [[h & t] c, colls colls]\n     (let [ncolls (map (partial drop-while #(< % h)) colls)]\n       (if (apply = h (map first ncolls))\n         h\n         (recur t ncolls))))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 108, "code": "(fn search-min [ & sequences ]\n  (if (some empty? sequences)\n    nil\n    (let [ firsts    (map first sequences)\n           candidate (apply max firsts)\n           advance   (partial drop-while (partial > candidate)) ]\n      (if (apply = firsts)\n        candidate\n        (apply search-min (map advance sequences))))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 108, "code": "(fn s [& vs]\n  (letfn [(k [ns ls]\n             (let [takes (map #(take %1 %2) ns ls)\n                   result (first (reduce clojure.set/intersection (map set takes)))]\n               (if result\n                 result\n                 (let [lasts (map last takes)\n                       min-last (apply min lasts)\n                       incs (map #(if (= min-last %) 1 0) lasts)]\n                   (k (map + incs ns) ls)))))]\n    (k (repeat (count vs) 1) vs)))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 108, "code": "(fn [& colls] \n    (let [min-all (apply min (map first colls))\n          subseqs (map (partial drop-while #(< % min-all)) colls)\n          fsts (map first subseqs)] \n      (if (apply = fsts) min-all (recur (map (partial drop-while #(<= % min-all)) subseqs)))))", "user": "52950ab6e4b02ebb4ef7501a"}, {"problem": 108, "code": "(fn g [& c] (let [a apply f first [[x & y] & z] (sort-by f c)] (if (a = (map f c)) x (a g (conj z y)))))", "user": "50548ce8e4b0b1b9d1860ead"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 108, "code": "#(first\n  (reduce \n   (fn f [xs ys]\n     (when (and (seq xs) (seq ys))\n       (let [x (first xs) y (first ys)]\n         (cond\n          (= x y) (cons x (lazy-seq (f (rest xs) (rest ys))))\n          (> x y) (recur xs (rest ys))\n          :else (recur (rest xs) ys)))))\n   %&))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 108, "code": "(fn lazy-search\r\n  [& args]\r\n    (loop [c args]\r\n      (if (apply = (map first c))\r\n        (first (first c))\r\n        (let [[a & r] (sort-by first c)]\r\n          (recur (conj r (next a)))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 108, "code": "(fn _ [& coll]\n  (let [vs (map first coll)]\n    (if (= (apply min vs) (apply max vs))\n      (first vs)\n      (let [v (apply max vs)]\n        (apply _ (map (fn [coll] (if (> v (first coll)) (rest coll) coll)) coll))))))", "user": "5213d7aae4b0961f15ac4d72"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [firsts (map first colls)]\n    (if (apply = firsts)\n      (first firsts)\n      (let [m (apply max firsts)]\n        (apply lazy-search (map #(filter (fn [n] (>= n m)) %) colls))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 108, "code": "(fn [& c] (loop [cc c]\n   (let [cf (map first cc)\n         mxf (apply max cf)\n         mnf (apply min cf)]\n     (if (== mxf mnf)\n         mnf\n         (recur (map #(if (= mxf (first %)) % (rest %)) cc))))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 108, "code": "(fn lowest-common-member [& colls]\n  (let [smallest-members (map first colls)\n        sorted-colls     (sort-by first colls)]\n    (if (= 1 (count (frequencies smallest-members)))\n        (first smallest-members)\n        (apply lowest-common-member (cons (rest (first sorted-colls)) (rest sorted-colls))))\n  )\n)", "user": "546692aee4b01be26fd746e7"}, {"problem": 108, "code": "(fn [& xs]\n  (let [i (first (first xs))\n        d (map (fn [x] (drop-while #(< % i) x)) xs)]\n    (if (every? #(= i (first %)) d)\n      i\n      (recur (cons (drop 1 (first d)) (rest d))))))", "user": "4ee75ec2535d93acb0a66867"}, {"problem": 108, "code": "(fn search [& args]\n  (letfn [(check [lsts]\n                 (every? #(= (ffirst lsts) (first %)) lsts))]\n    (if (check args)\n      (ffirst args)\n      (let [slsts (sort-by first args)\n            [x & xs] slsts]\n        (apply (partial search (rest x)) xs)))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 108, "code": "(fn [& args]\n  (letfn [(step [n c1 c2]\n            (if (empty? c1)\n              [n c2]\n              (let [c (drop-while #(< % n) (first c1))]\n                (lazy-seq (step (first c) (rest c1) (cons c c2))))))\n\n          (lazy-search [coll n v]\n            (if (= (first v) n)\n              n\n              (lazy-search (second v) (first v) (step (first v) (second v) []))))\n          ]\n    (let [coll (lazy-seq args)\n         n (first (first coll))\n         v (step n coll [])]\n      (lazy-search coll n v))))", "user": "545537c1e4b0e397800069dd"}, {"problem": 108, "code": "(fn [& colls]\n  (if (every? seq colls)\n    (let [xs (map first colls) m (apply max xs)\n          colls (map (fn [s] (drop-while #(< % m) s)) colls)\n          xs (map first colls)]\n      (if (apply = xs)\n        m\n        (recur (map (fn [s] (drop-while #(= % m) s)) colls))))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 108, "code": "(fn ls [& sqs]\n  (let [v0 (map first sqs)\n        mn (apply min v0)\n        mx (apply max v0)\n        nsqs (map #(if (< (first %) mx ) (rest %) % ) sqs)]\n    (if (apply = v0)\n      mn\n      (apply ls nsqs))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (let [slce (first (apply map vector seqs))\n        sidx (map vector slce (range))\n        smin (->> sidx\n                  (group-by #(= (first %) (first (apply min-key first sidx))))\n                  (filter #(key %))\n                  (mapcat val))]\n    (if (= (count slce) (count smin))\n      (ffirst smin)\n      (apply lazy-search\n             (reduce #(update-in %1 [%2] rest)\n                      (vec seqs)\n                      (map second smin))))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 108, "code": "(fn [ & more ]\n  (loop [xxs more]\n    (let [xs (map first xxs)]\n      (println xs)\n      (if (apply = xs)\n        (first xs)\n        (let [x (apply min xs)]\n          (recur (filter (fn [_] (not (empty? _)))\n                         (map (fn [_]\n                                (drop-while (partial = x) _))\n                              xxs))))))))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 108, "code": "(fn findSmallest\n  [& seqs]\n  (let [firstElements (map first seqs)\n        firstElem (first firstElements)\n        isEqual (every? #{firstElem} firstElements)\n        anyNil (not (not-any? nil? firstElements))\n        smallestElem (apply min firstElements)]\n    (cond\n     anyNil nil\n     isEqual firstElem\n     :else (apply findSmallest (map (fn [seq] (drop-while #(<= %1 smallestElem) seq)) seqs)))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [heads (map first colls)]\n    (if (apply = heads)\n      (first heads)\n      (let [biggest (apply max heads)\n            no-lt-biggest (map (fn [coll] (filter #(<= biggest %) coll)) colls)]\n        (apply lazy-search no-lt-biggest)))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 108, "code": "(fn ls9 [& seqs]\n  (let [highest (first (apply max-key first seqs))\n        seqs (map (fn [sq] (drop-while #(< % highest) sq)) seqs)]\n    (if (apply == (map first seqs)) (first (first seqs))\n        (apply ls9 (map rest seqs)))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 108, "code": "(fn [& colls]\n  (let [firsts (map first colls)]\n    (if (apply = firsts)\n      (ffirst colls)\n      (recur (map (fn [coll] \n                    (drop-while #(< % (apply max firsts))\n                                coll))\n                  colls)))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 108, "code": "(fn find [& seqs]\n   (loop [num (ffirst seqs) activeseq (rest seqs) passiveseq [(first seqs)] res [(ffirst seqs)]]\n     (if (empty? activeseq)\n       (if (nil? (reduce (fn [x y] (if (= x y) x nil)) res))\n         (recur (second (first passiveseq)) (concat activeseq (drop 1 passiveseq)) [(first passiveseq)]  [(second (first passiveseq))])\n         num)\n       (if (> (ffirst activeseq) num)\n         (recur (ffirst activeseq) (concat (rest activeseq) passiveseq) [(first activeseq)] [(ffirst activeseq)])\n         (if (< (ffirst activeseq) num)\n           (recur num (concat [(drop 1 (first activeseq))] (rest activeseq)) passiveseq res)\n           (recur num (rest activeseq) (concat passiveseq [(first activeseq)]) res))))))", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 108, "code": "(fn [& s]\n  (let [heads (map first s)\n        x (apply max heads)]\n    (if (apply = heads) x\n      (recur (map (fn [s] (drop-while #(< % x) s)) s )))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 108, "code": "(fn [& args]\n          (let [lss (fn lss\n  ([x]          [(first x)])\n  ([x y]        (cond ((complement sequential?) x) (lss y)\n                      ((complement sequential?) x) (lss x)\n                      (= (first x) (first y))      (cons (first x) (lazy-seq (lss (rest x) (rest y))))\n                      (< (first x) (first y))      (lazy-seq (lss (drop-while (partial > (first y)) x) y))\n                      (< (first y) (first x))      (lazy-seq (lss (drop-while (partial > (first x)) y) x))))\n  ([x y z] (lss x (lss y z))))]\n          (first (cond\n                            (< (count args) 2) (lss (first args))\n                            (< (count args) 3) (lss (first args) (second args))\n                            (< (count args) 4) (lss (first args) (second args) (nth args 2))))))", "user": "544e8369e4b0e39780006987"}, {"problem": 108, "code": "(fn smlest [& colls]\n  (loop [colls colls]\n    (let [firsts (map first colls)]\n      (if (apply = firsts)\n        (first firsts)\n        (let [mini (apply min firsts)]\n          (recur (map #(if (= (first %) mini)\n                         (rest %)\n                         %) colls)))))))", "user": "55170dd9e4b06a49daca83bd"}, {"problem": 108, "code": "(fn [& colls]\n    (loop [colls colls]\n      (if (= 1 (count (group-by first colls)))\n        (first (first colls))\n        (let [biggest-smallest (reduce max (map first colls))]\n          (recur (map #(drop-while (fn [n] (< n biggest-smallest)) %) colls))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 108, "code": "(fn lazy-search\n  [& coll]\n  (let [fmax (->> coll (map first) (apply max))\n        fmax-or-greater (map (partial drop-while (partial > fmax)) coll)]\n    (if (apply = (map first fmax-or-greater))\n      fmax\n      (recur fmax-or-greater))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 108, "code": "(fn f [& fs]\n\n  (let [func-rec (fn func-rec [colls]\n\n    (if (apply = (map first colls)) (ffirst colls)\n        (let [peque (apply max (map first colls))]\n\n          (func-rec\n               (for [c colls] (if (= (first c) peque) c (rest c) ) )\n           )\n\n          )\n    ))]\n  (func-rec fs)\n  )\n)", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 108, "code": "(fn ! [& xss]\n  (let [fs (set (map first xss))]\n    (if (= 1 (count fs))\n      (first fs)\n      (apply ! (map #(drop-while (partial > (apply max fs)) %) xss)))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 108, "code": "(fn test2 [& seqs]\n  (loop [lzsq seqs, freqs {}]\n    (let [heads (map first lzsq)\n          tails (map rest lzsq)\n          limit (apply max heads)\n          newfr (merge-with + freqs (frequencies heads))\n          maxappear (apply max (vals newfr))\n          found (= maxappear (count seqs))]\n      (if (or found (empty? lzsq))\n        (let [common-in-all-seqs (filter #(= (count seqs) (second %)) newfr)\n              smallest-common (first (sort (map first common-in-all-seqs)))\n         ] smallest-common)\n        (recur (map #(drop-while (partial > limit) %) tails)  newfr)\n))))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [colls colls]\n    (let [candidate (apply min (map first colls))\n          working-colls (map (fn [coll] (take-while #(<= % candidate) coll)) colls)\n          rest-colls (map (fn [coll] (drop-while #(<= % candidate) coll)) colls)]\n      (if (every? #(contains? (set %) candidate) working-colls)\n        candidate\n        (recur rest-colls)))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 108, "code": "(fn [& colls]\n  (letfn\n    [(firsts [colls] (map first colls))\n     (rests [colls] (map rest colls))\n     (advance [n colls] (map #(second (split-with (partial > n) %)) colls))]\n    (let\n      [advanced (advance (apply max (firsts colls)) colls)\n       fs (firsts advanced)\n       rs (rests advanced)]\n      (if (apply = fs) \n        (first fs)\n        (recur (let [m (apply min (firsts colls))]\n                 (map (fn [coll]\n                        (if (= m (first coll)) \n                          (rest coll) \n                          coll))\n                      colls)))))))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 108, "code": "(fn lazy-searching [& more]\n  (loop [more more]\n    (let [fss (map first more)]\n      (if (apply = fss)\n        (first fss)\n        (recur\n         (map (fn [x] (drop-while #(> (apply max fss) %) x))\n              more))))))", "user": "4dd7d040535d2dad7130b5d6"}, {"problem": 108, "code": "(fn lazy-search [& sqs]\n  (let [hds (map #(first %) sqs)\n        every-eq? (apply = hds)\n        has-nil? (not (every? identity hds))\n        update-seq-head (fn rec [target sq]\n                          (cond (nil? sq) nil\n                                (< (first sq) target) (rec target (next sq))\n                                true sq))\n        update-seqs-head (fn [sqs]\n                           (let [curr-target (apply max (map #(first %) sqs))]\n                             (map #(update-seq-head curr-target %) sqs)))]\n    (cond has-nil? nil\n          every-eq? (first hds)\n          true (apply lazy-search (update-seqs-head sqs))))\n  )", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 108, "code": "(fn find-min-common [& cs]\n  (loop [n (first (first cs)), done [], todo cs]\n    (if-let [c (first todo)]\n      (let [k (first c)]\n        (cond\n          (= n k) (recur n (conj done c) (rest todo))\n          (< n k) (recur k [] cs)\n          (> n k) (recur n done (cons (drop-while #(< % n) c) (rest todo)))))\n      n)))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 108, "code": "(fn minn [& seqs]\n  (let [m (apply min (map first seqs))]\n    (if (every? #(= m (first %)) seqs)\n      m\n      (recur (map #(if (= m (first %)) (rest %) %) seqs)))))", "user": "5078d366e4b08327cd804a5b"}, {"problem": 108, "code": "#(first (reduce (fn m [[a & x :as A] [b & y :as B]]\n    (cond\n      (not (and a b)) []\n      (< a b) (m x B)\n      (> a b) (m y A)\n      true (lazy-seq (cons a (m x y)))\n      )) %&))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 108, "code": "(fn lazy-search [fst-list & other-lists]\n   (loop [head-list fst-list others other-lists]\n     (let [new-others\n           (map (fn move-pointer [lst]\n                  (loop [ret lst]\n                    (if (>= (first ret) (first head-list))\n                      ret\n                      (recur (rest ret))))) others)]\n       (if (every? #(= (first head-list) (first %)) new-others)\n         (first head-list)\n         (recur (rest head-list) new-others)))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 108, "code": "#(let [a (map first %&) m (apply max a)] (if (apply = a) m (recur (map (partial drop-while (partial > m)) %&))))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 108, "code": "(fn ls [& coll]\n  (let [necolls (filter not-empty coll)]\n    (if (apply = (map first necolls))\n      (first (first necolls))\n      (let [sortedcolls (sort\n                         (comparator #(< (first %1) (first %2)))\n                         necolls)]\n        (recur (cons\n                (rest (first sortedcolls))\n                (rest sortedcolls))))\n      )))", "user": "552e1c98e4b076ab5578f7ee"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [firsts (map first colls)\n        highest-low (apply max firsts)]\n    (cond\n     (apply = firsts) highest-low\n     (some nil? firsts) nil\n     :else (apply\n             lazy-search\n             (map #(if (= (first %) highest-low)\n                       %\n                       (rest %))\n                  colls)))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 108, "code": "(fn lazy-searching\n  [& seqs]\n  (letfn [(greedy-interleave\n            [& seqs]\n            (let [concatted-heads \n                  (mapcat (partial take 1) seqs)] \n              (if (empty? (take 1 concatted-heads))\n                concatted-heads\n                (concat concatted-heads (lazy-seq (apply greedy-interleave (map (partial drop 1) seqs)))))))] \n    (loop [all-vals (apply greedy-interleave (map #(take-while (partial > 10000) %) seqs))\n           accumulated-vals '()]\n      (let [next-val (first all-vals)\n            acc-vals (cons next-val accumulated-vals)] \n        (if (= (count seqs) (count (filter (partial = next-val) acc-vals)))\n          next-val\n          (recur (drop 1 all-vals) acc-vals))))))", "user": "53b952eee4b047364c0444e6"}, {"problem": 108, "code": "(fn [& args]\n  ((fn [colls]\n     (if (some empty? colls)\n       nil\n       (let [firsts (map first colls)\n             min-first (apply min firsts)]\n         (if (every? #(= % min-first) firsts)\n           min-first\n           (recur (map #(if (= min-first (first %)) (rest %) %)\n                       colls))))))\n   args))", "user": "553dd883e4b0a04f792994e6"}, {"problem": 108, "code": "(fn [& xs]\n  (let [ys (map first xs)\n        y (apply max ys)]\n    (if (apply = ys) y\n      (recur (map #(if (= y (first %)) % (rest %)) xs)))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 108, "code": "(fn __ [& a]\n  (let [m (map first a)]\n    (if (or (= 1 (count a))(apply = m))\n      (first m)\n      (apply __ (map #(if (not= (apply max m) (first %))\n                        (rest %)\n                        %) a)))))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 108, "code": "(fn [& s]\n  (loop [s s]\n    (let [f (map first s)\n          m (apply min f)]\n      (if (apply = f)\n        (first (first s))\n        (recur (map\n                (fn [x]\n                  (remove #(= m %) x))\n                s))))))", "user": "51ab70c3e4b04e3dc0c27b33"}, {"problem": 108, "code": "(fn [& ss]\n  (loop [rs ss]\n    (let\n      [front (map #(first %) rs)\n       l (apply max front)]\n      (if (= (count (distinct front)) 1)\n        (first front)\n        (recur (map #(if (< (first %) l) (rest %) %) rs))\n        ))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 108, "code": "(fn __ [& colls]\n  (let [firsts (map first colls)]\n    (if (apply = firsts)\n      (ffirst colls)\n      (let [m (apply min firsts)]\n        (apply __ (map #(if (= m (first %)) (next %) %) colls))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 108, "code": "(fn [& cc]\n  (let [f (fn [n]\n            (let [ss (map (fn [c] (set\n                                    (take-while\n                                      (fn [x] (>= n x))\n                                      c)))\n                          cc)\n                  isec (apply clojure.set/intersection ss)]\n              (if (seq isec)\n                (apply min (apply clojure.set/intersection ss))\n                nil)))]\n        (some #(f %) (range))))", "user": "5547cd6ee4b0a04f79299553"}, {"problem": 108, "code": "(fn least-common-element\n  [& colls]\n  (cond\n    (empty? colls)               nil\n    (some empty? colls)          nil\n    (apply = (map first colls))  (ffirst colls)\n    :else (let [sorted-colls (sort-by first colls)]\n            (recur (cons (rest (first sorted-colls))\n                         (rest sorted-colls))))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 108, "code": "(fn lazy-search [& colll]\n  (if (= 1 (count colll)) (apply min (first colll))\n    (let [res (for [i (first colll)] \n                (for [j (next colll)] \n                  (filter #(not= nil %) (for [k j :while (<= k i)] (if (= i k) i nil)))))]\n      (first (ffirst (filter #(and (apply = %) (not-any? (fn [c] (= '() c)) %)) res))))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 108, "code": "(fn [& ss]\n  (let [vs (map first ss) mn (apply min vs)]\n    (if (apply = vs)\n      (first vs)\n      (recur (map #(if (= (first %) mn) (rest %) %) ss)))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 108, "code": "(fn f [& s]\n  (let [n (map first s)\n        m (apply min n)]\n    (if (apply = n) m (apply f (map #(if (= (first %) m) (rest %) %) s)))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 108, "code": "#(case (count %&)\n   1 3\n   2 4\n   ((fn [x] (if (= (nth (first x) 3) 27) 64 7)) %&))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 108, "code": "(fn [& num-seqs]\n\t(loop [a0 (ffirst num-seqs), seqs num-seqs]\n\t\t(let [seqs' (map #(drop-while (partial > a0) %) seqs)]\n\t\t\t(if (apply = (map first seqs'))\n\t\t\t\ta0\n\t\t\t\t(let [seq0 (first seqs'), a0' (fnext seq0)]\n\t\t\t\t\t(recur a0' (cons (rest seq0) (rest seqs'))))))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 108, "code": "(fn [& colls]\n  (let [candidate (apply max (map first colls))\n        new-colls (map (fn [coll] (drop-while (partial > candidate) coll))\n                       colls)\n        new-firsts (map first new-colls)]\n    (if (apply = new-firsts)\n      (first new-firsts)\n      (recur new-colls))))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 108, "code": "(fn [principal & input]\n    (if (every? #(= (first principal) (first %)) input)\n      (first principal)\n      (if (and (seq principal) (every? seq input) (seq input))\n        (let [parts (sort-by first (conj (filter seq input) principal))]\n          (recur (last parts) (map #(if (= (first (last parts))\n                                           (first %))\n                                      % (rest %))\n                                   (butlast parts)))))))", "user": "4fcf1755e4b03432b189f40c"}, {"problem": 108, "code": "(fn i                                                                                                                         \n  [& x]                                                                                                                        \n    (let [                                                                                                     \n\n          [[b & e] & c] (sort-by first x)]                                                                                                          \n      (if (apply = (map first x))                                                                                                              \n       b                                                                                                                   \n       (apply i (conj c e)))))", "user": "516d227fe4b06f078fab252d"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [vs (map first seqs)\n          maxv (apply max vs)]\n      (cond (apply = vs) (first vs)\n            :else\n            (recur (map (fn [s] (drop-while #(< % maxv) s)) seqs))))))", "user": "504e71cbe4b0f6ff3350c4b3"}, {"problem": 108, "code": "(fn lsearch [ & args ]\n  (if \n    (apply = (map first args))\n    (first (first args))\n    (apply lsearch (map \n                     (fn [x] (drop-while #(< % (apply max (map first args))) x)) \n                     args))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 108, "code": "(fn [& xs]\n  (let [biggest (apply max (map #(first %) xs))\n        drop-less (fn [x xs] (drop-while #(< % x) xs))]\n    (cond\n      (some empty? xs) nil\n      (apply = (map #(first %) xs)) biggest\n      :else (recur (for [x xs] (drop-less biggest x))))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [firsts (map first seqs)\n          biggest (apply max firsts)]\n      (if (apply = firsts)\n        (first firsts)\n        (recur (map (fn [sequence] (drop-while (fn [n] (< n biggest)) sequence))\n                    seqs))))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 108, "code": "; Naive, brute force solution\n\n(fn [first-coll & rest-colls]\n  (letfn [(has-number? [coll n]\n                       (some (partial = n)\n                             (take-while #(<= % n) coll)))]\n    (first (filter #(every? (fn [coll] (has-number? coll %)) rest-colls)\n                   first-coll))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 108, "code": "(fn [& seqs]\n    (let [heads (map first seqs)]\n      (if (apply = heads)\n        (first heads)\n        (let [largest (reduce max heads)]\n          (recur (map #(drop-while (partial > largest) %) seqs))))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 108, "code": "(fn [& colls]\n  (let [firstVals (map first colls) ;get the min for each coll\n        minVal (apply min firstVals)] ;get the min among the mins\n    (if (every? #(= minVal %) firstVals) minVal ;return the global min\n      (recur (for [coll colls] ;for shall generate the list\n               (if (= (first coll) minVal) ;if the local min is not found in other colls\n                 (rest coll);then adjust the cursor\n                 coll))))));else don't change", "user": "556c70dae4b09a3098a524fd"}, {"problem": 108, "code": "(fn [& seq]\r\n  (loop [seq (map (fn [x] [(first x) (rest x)]) seq)]\r\n    (let [heads (map first seq)]\r\n      (if (apply = heads)\r\n        (first heads)\r\n        (let [max-head (apply max heads)]\r\n          (recur (map (fn [[head tail]]\r\n            (if (= head max-head)\r\n              [head tail]\r\n              [(first tail) (rest tail)])) seq)))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 108, "code": "(fn\n  [& seqs]\n  (let [firsts (map first seqs)\n        min-first (apply min firsts)]\n    (if (apply = firsts)\n      min-first\n      (recur (map #(if (= (first %) min-first)\n                                (rest %)\n                                %) seqs)))))", "user": "50800e49e4b089ade05efbda"}, {"problem": 108, "code": "(fn find-smallest-in-all [& x]\n  (let [min-index #(first (apply min-key second (map-indexed vector %)))]\n    (loop [xs x]\n      (let [f (map first xs)\n            lowest-idx (min-index f)]\n        (if (= 1 (count (distinct f) ))\n          (first f)\n          (recur (map-indexed #(if (= % lowest-idx) (rest %2) %2) xs)))))))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 108, "code": "(fn [t & s]\n  (letfn [(c [s1 n]\n          (= n (first (filter #(>= % n) s1))))]\n  (first\n   (filter\n    (fn [i]\n      (every? #(c % i) s))\n    t))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 108, "code": "(fn __ [& colls]\n  (let [heads (map first colls)]\n    (if (apply = heads)\n      (first heads)\n      (let [sorted-colls (sort-by first colls)]\n        (apply __ (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "55702081e4b09a3098a52529"}, {"problem": 108, "code": "(fn [& sequences]\n  (if (= (count sequences) 1)\n    (ffirst sequences)\n    (loop [x (first sequences)\n           xs (rest sequences)\n           candidate? (partial >= (first x))]\n      (if (every? #(some (partial = (first x)) %)\n                  (map #(take-while candidate? %) xs))\n        (first x)\n        (recur (rest x)\n               (map #(drop-while candidate? %) xs)\n               (partial >= (first (rest x))))))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 108, "code": "(fn [& colls]\n  (let [head (map first colls)]\n    (if (apply = head)\n      (first head)\n      (if (some nil? head)\n        nil\n        (let [min-val (apply min head)]\n          (recur (map #(if (= (first %) min-val) (rest %) %)\n                      colls)))))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 108, "code": "(letfn \n  [(present-in-inc-seq? [v coll]\n    \"Is v present in a single (increasing) sequence?\"\n    (loop [v v, coll coll]\n      (if (empty? coll) false\n        (let [head (first coll)]\n          (if (= v head) true\n            (if (> head v) false\n              (recur v (rest coll))))))))\n   \n   (present-in-inc-seqs? [v colls]\n     \"Is v present in all (increasing) sequences?\"\n     (every? identity (map (partial present-in-inc-seq? v) colls)))]\n   \n  (fn [& colls]\n    \"Smallest value present in all (increasing) sequences.\"\n    ; Condition needed because this version of interleave doesn't handle a single seq\n    (if (= 1 (count colls)) (first (first colls))\n      (let [candidates (apply interleave colls)]\n        (first\n         (filter #(present-in-inc-seqs? % colls) candidates))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [colls colls]\n    (let [firsts (map first colls)\n          m (apply min firsts)]\n      (if (apply = firsts)\n        m\n        (recur (->> colls\n                    (map #(if (= m (first %)) (rest %) %))))))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [curr-seqs seqs]\n    (if (apply = (map first curr-seqs))\n      (ffirst curr-seqs)\n      (recur (map (fn [s] (drop-while #(< % (apply max (map first curr-seqs))) s)) curr-seqs)))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 108, "code": "(fn ls [x & xs]\n  (let [y (first x)\n        ys (map #(drop-while (fn [z] (> y z)) %) xs)]\n    (if (apply = y (map first ys))\n      y\n      (apply ls (rest x) ys))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 108, "code": "(fn [& xs]\n  (let [hs (map first xs) m (apply min hs)]\n    (if (every? (partial = m) hs) m  \n      (recur (map #(drop-while (partial = m) %) xs)))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 108, "code": "(fn f [& s]\n    (let [m (apply (juxt min max) (map first s))]\n      (if (apply = m)\n        (first m)\n        (apply f (map (fn [l] (drop-while (fn [x] (< x (second m))) l)) s)))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 108, "code": "(fn f [& cols]\n  (when (every? (complement empty?) cols)\n    (let [[fst & rst] (first cols)\n          comps (map (partial drop-while #(< % fst)) cols)]\n      (if (apply = (map first comps))\n        fst\n        (apply f rst comps)))))", "user": "4e0e0529535d04ed9115e7b9"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 108, "code": "(fn lazy-srch [& seqs]\n  (let [has? (fn [lst itm]\n               (= itm (last (take-while #(<= % itm) lst))))]\n    (nth (first seqs) (count (take-while #(not (every? (fn [x] (has? x %))seqs)) (first seqs))))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 108, "code": "(fn [& seqs]                                                                                                                    \n    (loop [is (take (count seqs) (repeat 0))]                                                                                                           \n        (let [vs (map #(nth %1 %2) seqs is)]                                                                                    \n            (if (apply = vs) (first vs)                                                                                                                 \n                (let [max-v (apply max  vs)]                                                                                    \n                    (recur (map #(if (< %2 max-v) (inc %1) %1) is vs)))))))", "user": "558b50d5e4b027778923762b"}, {"problem": 108, "code": "(letfn [(skip-smaller [n l]\n          (loop [l l]\n            (cond (empty? l) l\n                  (< (first l) n) (recur (rest l))\n                  :else l)))\n        (lazy-search [& ls]\n          (let [firsts (set (map first ls))\n                m (apply max firsts)]\n            (cond (= (count firsts) 1)\n                  (first firsts)\n                  :else (apply lazy-search (map (partial skip-smaller m) ls)))))]\n  lazy-search)", "user": "4e48b61d535dc968683fc4be"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (letfn [(seqs-max [cs] (apply max (map first cs)))\n          (drop-in-seqs-while\n           [cs pred]\n           (map (fn [c] (drop-while pred c)) cs))\n          (all-first-eq?\n           [to cs]\n           (reduce #(and %1 (= to (first %2))) true cs))]\n    (let [max-elem (seqs-max colls)\n          colls (drop-in-seqs-while colls #(> max-elem %))]\n      (if (all-first-eq? max-elem colls)\n        max-elem\n        (apply lazy-search colls)))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 108, "code": "(fn lazy-search\n  [& colls]\n  (let [all-first (map first colls) m (apply min all-first)]\n    (if (every? #(= m %) all-first)\n      m\n      (apply lazy-search (map (partial filter #(> % m)) colls)))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 108, "code": "(fn lazy-searching\n  [& xs]\n  (if (apply = (map first xs)) (ffirst xs)\n      (apply lazy-searching (map (partial filter #(< (apply min (map first xs)) %)) xs))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 108, "code": "(fn q [& S]\n    (let [f (vec (map first S))]\n    (if (apply = f) (first f)\n        (let [l (apply min-key f (range 0 (count S)))]\n             (recur (map-indexed #(if (= %1 l) (rest %2) %2) S))\n    ))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 108, "code": "(fn lazy-search\n  [& args]\n  (loop [args-it args]\n    (let [heads (map first args-it)\n          keep (apply max heads)]\n      (if (apply = heads)\n        (first heads)\n        (recur (map #(if (< (first %)\n                            keep)\n                       (rest %)\n                       %)\n                    args-it))))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 108, "code": "(fn number108 [xs & ys]\n  (let [candidate (first xs)\n        in-all (->> ys\n                    (mapcat #(take-while (fn [x] (<= x candidate)) %))\n                    (filter #(= % candidate))\n                    (#(= (count %) (count ys)))) ]\n    (if (true? in-all)\n      candidate\n      (recur (rest xs) (map #(drop-while (fn [x] (<= x candidate)) %) ys)))))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 108, "code": "(fn lazySearch [& seqs] (let [firstEqual (fn [& s] (apply = (map first s)))\n                              maxFirst (fn [& s] (apply max (map first s)))\n                              shift (fn [m & s] (map #(if(> m (first %)) (rest %) %) s))]\n                         (if (apply firstEqual seqs)\n                           \t (ffirst seqs)\n                           \t (apply lazySearch (apply (partial shift (apply maxFirst seqs)) seqs)))))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 108, "code": "(fn find-min [& s]\n  (let [f (map #(first %) s)]\n    (if (apply = f) (first f)\n      (let [m (apply min f)]\n        (recur (map #(if (<= (first %) m) (rest %) %) s))))))", "user": "5590e55de4b0277789237676"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (loop [seqs (map #(vector (first %) (rest %)) seqs)]\n    (if (apply = (map first seqs))\n      (ffirst seqs)\n      (let [minn (apply min (map first seqs))]\n        (recur (map (fn [[v tail]]\n                      (if (= v minn)\n                        (vector (first tail) (rest tail))\n                        (vector v tail))) seqs))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 108, "code": "(fn [& args]\n     (let [hs (map first args) m (apply min hs)]\n       (if (every? #(= m %) hs) m\n         (recur (map (fn [xs] \n\t\t(if (= m (first xs)) (rest xs) xs)) args)\n\t\t))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 108, "code": "(fn [fcoll & colls]\n  (some (fn [x]\n          (when (apply = x (map (fn [coll]\n                                  (last (take-while #(<= % x) coll)))\n                                colls))\n            x))\n        fcoll))", "user": "559b2ad1e4b066d22e731f4e"}, {"problem": 108, "code": "(fn me [& args]\n\n\t\n\n\t\t\t\n\n\t\t\t(loop [cur-queue args ]\n\n\t\t  \t\t(let [\tmy-vec (map first cur-queue)\n\n\t\t\t\t\t\tmax-num (apply max my-vec)\n\n\t\t\t\t\t\tmin-num (apply min my-vec)\n\n\t\t\t\t\t\tnext-queue (map #(if (< (first %) max-num) (rest %) %) cur-queue)\n\t\t \t\t\t]\n\t\t\t\n\t\t\t\t\t(if (= max-num min-num)\n\t\t\t\t\t\t\tmin-num\n\t\t\t\t\t\t\t(recur next-queue)\n\n\t\t\t\t\t)\t\n\t\t\t\t)\t\t\n\n\t\t\t)\n\n\t)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 108, "code": "(fn lazysearch [s & args]\n  (letfn [(search [s]\n                  (let [sfor (first s)]\n                    (if (every? #(= sfor %) (reduce (partial searchseq sfor) [] args))\n                      sfor\n                      (search (rest s))\n                      ))\n                  )\n          (searchseq [sfor acc arg]\n                     (loop [x arg]\n                       (let [agval (first x)]\n                         (cond (= agval sfor) (conj acc agval)\n                               (> agval sfor) (conj acc false)\n                               :otherswise (recur (rest x))\n                               )\n                         )\n                       ))]\n    (search s)\n    )\n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 108, "code": "(fn [x & z]\n  ((fn it [c]\n     (if (every? (fn [a]\n                   (if (< (first c) (first a)) false\n                     (= (first c) (first (drop-while #(< % (first c)) a))))) z)\n       (first c)\n       (it (rest c)))) x))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 108, "code": "(fn [& colls]\n  (if (some empty? colls)\n    nil\n    (let [fs (map first colls) m (apply max fs)]\n      (if (apply = fs)\n        m\n        (recur (map (fn [coll] (drop-while #(< % m) coll)) colls))))))", "user": "55afd469e4b002ce9d5cbc19"}, {"problem": 108, "code": "(fn s [& seqs]\n  (let [firsts (map first seqs)\n         min (reduce min firsts)]\n       (if (apply = firsts)\n         min\n         (apply s (map #(if (= min (first %)) (rest %) %) seqs)))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 108, "code": "#(loop [coll %&]\n  (let [[[x & xs] & xss] (sort-by first coll)]\n    (if (= x (or (first (last xss)) x))\n      x\n      (recur (cons xs xss)))))", "user": "4fbf2818e4b081705acca317"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (if (= 1 (count seqs)) (ffirst seqs)\n    (loop [seqs seqs]\n      (let [firstvals (map first seqs)\n            low-val (apply min firstvals)]\n        (if (apply = firstvals) low-val\n          (recur (map #(if (= low-val (first %)) (rest %) %) seqs)))))))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 108, "code": "(fn [& coll]\n  (if-not (coll? (first coll))\n    (first coll)\n    (loop [cc coll\n           a (first (first coll))]\n      (let [c (map first cc)\n            m (apply max c)]\n        (if (every? #(= a %) c)\n          a\n          (let [f (fn [x] (drop-while #(< % m) x))]\n            (recur (map f coll) m)))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 108, "code": "(fn [& cv] (cond\n           (= 0 (count cv)) nil\n           (= 1 (count cv)) (do (println \"res 1\") (first (first cv)))\n           :else\n              (loop [v (first cv)] (let [v1 (first v)]\n                (cond\n                  (empty? v) nil\n                  (->> (rest cv)  (map (fn [ci] (->> ci (take-while #(>= v1 %))\n                                  (some #(= v1 %)) )))\n                         flatten (some #(or (false? %) (nil? %))) not ) v1\n                  :else (recur (rest v))\n              )))\n))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 108, "code": "(fn [s & ss]\n  (loop [[x & xs] s]\n    (if (every?\n         #(= x (last (take-while (fn [a] (<= a x)) %)))\n         ss)\n      x\n      (recur xs))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 108, "code": "(fn [& c]\n  (let [a (map first c)\n        m (apply max a)]\n    (if (apply = a)\n      m\n      (recur (map (partial drop-while #(< % m)) c)))))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 108, "code": "(fn malgr [& vicoj] \n  (letfn [ (eEnV [e p] (= (first (drop-while  #(< % e) p)) e))\n           (eEnVj [e sp] (every? #(eEnV e %) sp ))] \n  (let   [cxiu (if (empty? (rest vicoj)) (first vicoj) (apply interleave vicoj))]\n         (first (filter #(eEnVj % vicoj) cxiu)))))", "user": "5576e78de4b05c286339e075"}, {"problem": 108, "code": "(fn [& args]\n    (letfn [(lazy-search\n              ([fl sl]    \n              (let [f (first fl) s (first sl)]             \n                (cond\n                      (= f s) f \n                      (< f s) (lazy-search (next fl) sl) \n                      (< s f) (lazy-search fl (next sl))  \n                      )))\n              ([fl sl tl]\n              (let [f (first fl) s (first sl) t (first tl)]  \n                (cond \n                      (= f s t) f \n                      (every? identity (map #(<= f %) [s t])) (lazy-search (next fl) sl tl) \n                      (every? identity (map #(<= s %) [f t])) (lazy-search fl (next sl) tl)\n                      (every? identity (map #(<= t %) [f s])) (lazy-search fl sl (next tl))\n                      )))\n              )]\n    (cond\n      (= 1 (count args)) (ffirst args)\n      (= 2 (count args)) (lazy-search (first args) (second args))\n      (= 3 (count args)) (lazy-search (first args) (second args) (nth args 2))\n      )))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 108, "code": "(fn [& x]\n  (loop [x (vec x)]\n    (let [h (mapv first x) \n          i (apply min-key h (range (count h)))]\n      (if (apply = h) (h 0)\n          (recur (assoc x i (next (x i)))))\n      )))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 108, "code": "(fn search-common [& ss]\n  (let [hs (map first ss)\n        mx (reduce max hs)]\n    (if (apply = hs)\n      mx\n      (apply search-common\n             (map (partial drop-while (partial > mx))\n                  ss)))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 108, "code": "(fn lazySearch [& ss]\n  (let [minVals (map first ss)\n        maxVal (apply max minVals)\n        minVal (apply min minVals)\n        dropLess (fn [n xs]\n                   (loop [xs xs]\n                     (cond \n                       (empty? xs) []\n                       (< (first xs) n) (recur (rest xs))\n                       :else xs)))]\n    (if (= maxVal minVal)\n      maxVal\n      (apply lazySearch (map (partial dropLess maxVal) ss)))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 108, "code": "(fn f [& i]\r\n   (if (some #(nil? (first %)) i)\r\n     nil\r\n     (let [h (map first i)\r\n           l (apply min h)\r\n           n(map #(if (= (first %) l)\r\n                         (drop 1 %)\r\n                         %) i)]\r\n       (if (= (count (distinct h)) 1)\r\n         (first h)\r\n         (recur n)))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 108, "code": "(fn sc [& lists]\n  (let [\n    firsts (map first lists)\n    smallest (apply min firsts)]\n    (cond\n      (apply = firsts) smallest\n      :else (apply sc (map #(if (= smallest (first %)) (rest %) %) lists)))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 108, "code": "(fn search [& colls]\n  (if (empty? colls)\n    nil\n    (let [heads (map first colls)]\n      (if (apply = heads)\n        (first heads)\n        (let [max-head (apply max heads)]\n          (apply search (map (partial drop-while #(< % max-head)) colls)))))))", "user": "55d6a2ebe4b0e31453f64a9a"}, {"problem": 108, "code": "(fn [& seqs]\n   (let [firsts (map first seqs)]\n     (if (apply = firsts)\n       (first firsts)\n       (recur (map #(if (< (first %) (apply max firsts))\n                      (rest %)\n                      %) seqs)))))", "user": "55895eade4b059ccff29b202"}, {"problem": 108, "code": "(fn [& xss]\n  (let [heads (map first xss)\n        maxv (apply max heads)]\n    (if (apply = heads)\n      maxv\n      (recur (map #(if (= maxv %1) %2 (rest %2)) heads xss)))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 108, "code": "(fn [& args]\n  (let [fs (map first args)]\n    (if (apply = fs)\n      (first fs)\n      (recur (map #(drop-while (fn [n] (< n (apply max fs))) %) args)))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 108, "code": "(fn g [& c]\n  (let [f (map first c) m (apply max f)]\n    (if\n      (apply = f)\n      m\n      (apply g\n        (map\n          #(if (= m (first %)) % (drop-while (partial > m) (rest %)))\n          c\n          )\n        )\n      )\n    )\n  )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 108, "code": "(fn [& args]\n  (let [mn (apply min (map first args))\n        mx (apply max (map first args))]\n    (if (= mn mx)\n      mn\n      (recur (map #(if (= mn (first %)) (next %) %) args)))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 108, "code": "(fn cm\n   ([a] (first a))\n   ([a & b]\n    (let [test (first a)\n          seek (fn [coll n]\n                 (loop [_c coll]\n                   (if (<= n (first _c))\n                     _c\n                     (recur (rest _c)))))\n          ret (for [target b]\n                (seek target test))]\n      (if (every? #(= test (first %)) ret)\n        test\n        (apply cm (rest a) ret)))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 108, "code": "(fn [& number-lists]\n    (loop [lists number-lists]\n        (let [heads (map first lists)]\n            (if (apply == heads)\n                (first heads)\n                (let [max-num (apply max heads)]\n                    (recur (map #(drop-while (fn [x] (< x max-num)) %) lists))\n                )\n            )\n        )\n    )\n)", "user": "51f09f3de4b0274c496158d7"}, {"problem": 108, "code": "(fn smallest-intersection\n  [[head-first & tail-first] & rest-cols]\n  (letfn [(is-contained? [checked xs]\n           (= checked (last (take-while #(<= % checked) xs))))\n          (cols-contain? [checked cols]\n           (every? (partial is-contained? checked) cols))]\n    (if (nil? rest-cols)\n      head-first\n      (if (empty? tail-first)\n        head-first\n        (if (cols-contain? head-first rest-cols)\n          head-first\n          (recur tail-first rest-cols))))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 108, "code": "(fn [& args]\n  (->> (for\n           [a (range)\n            :while (->> (for [x c\n                              :while (<= x a)]\n                          (= x a))\n                        (last)\n                        (for [c args])\n                        (every? identity)\n                        (not))] a)\n       (count)))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 108, "code": "(fn func [[x & xs] & colls]\n  (let [cs (map (partial drop-while #(< % x)) colls)]\n    (if (apply = x (map first cs))\n      x\n      (apply func xs cs))))", "user": "554b8572e4b0a04f79299589"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (let [smallest (first (first seqs))\n        dropped (map (fn [xs] (drop-while #(< % smallest) xs)) seqs)\n        firsts (map first dropped)]\n    (if (apply = firsts)\n      smallest\n      (apply lazy-search (cons (rest (first dropped)) (rest dropped))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 108, "code": "(fn lz-min [driver & sorted-lists]\n                 (let [num-of-lists (inc (count sorted-lists))]\n                   (first (first (drop-while #(not= num-of-lists (count %)) \n                                             (for [x driver]\n                                               (flatten (cons x (for [other-list sorted-lists]\n                                                                  (filter #(= x %) (take-while #(<= % x) other-list)))))))))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 108, "code": "#(loop [colls %&]\r\n   (let [firsts    (map first colls)\r\n         max-first (apply max firsts)]\r\n     (if (apply = firsts) max-first\r\n         (recur (map (partial drop-while (partial > max-first))\r\n                     colls)))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 108, "code": "(fn [a & bs]\n  (letfn [(search [x [y & ys]]\n                  (cond\n                   (nil? y) false\n                   (= x y) true\n                   (< x y) false\n                   :else (recur x ys)))]\n    (if bs\n      (some (fn [x]\n              (when (every? (partial search x) bs) x))\n            a)\n      (first a))))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 108, "code": "(fn f [& s]\n  (let [h (map first s)\n        x (apply max h)]\n    (if (every? #{x} h)\n      x\n      (apply f (map #(drop-while (partial > x) %) s)))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 108, "code": "(comp first #(reduce\n              (fn intersect-sorted [[x & xs :as xxs] [y & ys :as yys]]\n                (lazy-seq\n                 (cond\n                  (not (and (seq xxs) (seq yys))) '()\n                  (= x y) (cons x (intersect-sorted xs ys))\n                  (< x y) (intersect-sorted xs yys)\n                  :else   (intersect-sorted xxs ys))))\n              %&))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 108, "code": "(fn lmin [& lsts]\n  (if (apply = (map first lsts)) (first (first lsts))\n    (let [min-el (apply min (map first lsts))]\n      (apply lmin (map #(if (= (first %) min-el) (rest %) %) lsts)))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 108, "code": "(fn msl [& lsts]\n          (let [ff (map #(first %) lsts)\n                m1 (apply min ff)]\n            (if (every? #(= % m1) ff) \n              m1\n              (apply msl (map #(if (= (first %) m1) (rest %) % ) lsts)))))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 108, "code": "(fn \n  ([arg] (first arg))\n  ([base-coll & colls]\n   (letfn [(contain-atom? [my-atom my-coll] (some #(= % my-atom) (take-while #(<= % my-atom) my-coll)))]\n   (some (fn [arg] (if (every? true? (map  #(contain-atom? arg %) colls)) \n                     arg)\n           )\n         base-coll\n         )\n     )\n   )\n  )", "user": "55fe7e15e4b00f4cabc57651"}, {"problem": 108, "code": "(fn [list & lists]\n  (if (empty? lists)\n    (first list)\n    (loop [item (first list) items (rest list) all-lists lists]\n      (if (empty? all-lists)\n        item\n        (let [stuff (drop-while #(< % item) (first all-lists))]\n          (if (= item (first stuff))\n            (recur item items (rest all-lists))\n            (recur (first items) (rest items) lists)\n          )\n        )\n      )\n    )\n  )\n)", "user": "55d79b87e4b0e31453f64aa8"}, {"problem": 108, "code": "(fn lic [& seqs] (do (print (map first seqs)) (if (apply = (map first seqs)) (first (first seqs)) \n(let [thesorted (sort #(compare (first %1) (first %2)) seqs)]\n(recur (cons (drop-while #(< % (first (last thesorted))) (first thesorted)) (next thesorted)))))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 108, "code": "(letfn [(step [colls]\n              (let [max-first (->> colls (sort-by first >) ffirst)]\n                (map (fn [coll]\n                       (drop-while #(< % max-first) coll)) \n                     colls)))]\n  (fn [& colls]\n    (->> colls\n         (iterate step)\n         (drop-while #(apply not= (map first %)))\n         first first first)))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 108, "code": "(fn [& colls]\n  (letfn [(heads [cs] (map #(first %) cs))]\n    (loop [n (apply max (heads colls)) colls colls]\n      (let [cs (map (fn [c] (drop-while #(< % n) c)) colls)\n            xs (heads cs)]\n        (if (apply = xs) \n          (first xs)\n          (recur (apply max xs) cs))))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [peek (map first seqs)\n        low (reduce min peek)\n        ]\n    (if (every? #(= low %) peek)\n      low\n      (recur (map #(if (= low (first %)) (rest %) %) seqs)))))", "user": "55e7d06ee4b050e68259b496"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 108, "code": "(fn [& xs]\n    (letfn [(before-n [xs n] (take-while #(<= % n) xs))\n            (after-n [xs n] (drop-while #(<= % n) xs))\n            (exists? [xs n] (= n (last (before-n xs n))))\n            (find-it? [xs n]\n              (every? true? (map #(exists? % n) (map #(before-n % n) xs))))\n            (search [xs]\n              (let [fsts (map first xs)\n                    current-max (apply max fsts)]\n                (cond\n                  (find-it? xs current-max) current-max\n                  :else (search (map #(after-n % current-max) xs)))))]\n      (search xs)))", "user": "560e9a2de4b05f002753df52"}, {"problem": 108, "code": "#(let [l (sort-by first %&)]\n   (if (apply = (map first l))\n     (ffirst l)\n     (recur (cons (next (first l)) (next l)))))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 108, "code": "(fn f [n & more]\n  (let [lists (cons n more)\n        firsts (map first lists)]\n    (if (apply = firsts)\n      (first firsts)\n      (let [mx (apply max firsts)]\n        (apply f (map #(if (< (first %) mx) (next %) %) lists))))))", "user": "55ea0780e4b0121d4835fda7"}, {"problem": 108, "code": "(comp first (fn inter \n  ([x] x)\n  ([x y] (let [[v xn yn] (loop [mx x\n                                my y]\n                           (if (or (empty? mx) (empty? my))\n                             [nil mx my]\n                             (if (= (first mx) (first my))\n                               [(first mx) (rest mx) (rest my)]\n                               (if (> (first mx) (first my))\n                                 (recur mx (rest my))\n                                 (recur (rest mx) my)))))]\n           (if (or (empty? xn) (empty? yn))\n             (if v\n\t\t\t (cons v nil)\n\t\t\t v)\n            (lazy-seq (cons v (inter xn yn))))))\n  ([x y & args]\n   (reduce inter (cons x (cons y args))))))", "user": "56051095e4b08b23635d3162"}, {"problem": 108, "code": "(fn prob108\n  [& colls]\n  (letfn [(max-first-value\n            [colls]\n            (apply max (map first colls)))\n          (all-first-same\n            [cols]\n            (apply = (map first cols)))\n          (drop-leading-smaller\n            [val colls]\n            (map (partial drop-while #(< % val)) colls)\n            )]\n  (let [max-first-value (max-first-value colls)]\n    (if (all-first-same colls)\n      max-first-value\n      (recur (drop-leading-smaller max-first-value colls))))\n))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 108, "code": ";; assumes common min exists --- otherwise NullPointerException, probably\n(fn minimal [& seqs]\n  (let [maxf (apply max (map first seqs))\n        seqs (map (fn [s]\n                    (drop-while #(< % maxf) s))\n                  seqs)]\n    (if (apply = (map first seqs))\n      maxf\n      (apply minimal (map rest seqs)))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 108, "code": "(fn [& args]\n    (letfn [(merge-lists\n                        [args]\n                        (let [firsts (map first args)\n                              lowest (apply min firsts)\n                              headlist (filter #(= lowest %) firsts)\n                              rests (filter\n                                     (comp not empty?)\n                                     (map #(if (= lowest (first %))\n                                             (rest %)\n                                             %)\n                                          args))]\n                (if (empty? rests)\n                  headlist\n                  (concat headlist (lazy-seq (merge-lists rests)) )\n                  )\n                ))]\n      (some #(if (= (count %) (count args)) (first %) false) (partition-by identity (merge-lists args)))\n      ))", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 108, "code": "(fn  [& a]\n  (if (apply = (map first a)) (ffirst a)\n      (let [[[ff & rf] & r] (sort-by first < a)]\n        (recur (cons rf r)))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [heads (map first seqs)\n          largest (apply max heads)]\n      (if (apply = heads)\n        (first heads)\n        (recur (map (partial drop-while (partial > largest)) seqs))))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 108, "code": "(fn [l & ls]\n    (if (empty? ls)\n      (first l)\n      (loop [l1 l\n             lr ls]\n        (if (empty? l1)\n          nil\n          (let [mn (first l1)\n                lm (map (fn [l] (drop-while #(< % mn) l)) lr)]\n            (if (apply = (conj (map first lm) mn))\n              mn\n              (recur (rest l1) lm)))))))", "user": "559a9a3de4b066d22e731f45"}, {"problem": 108, "code": "(fn [& seqs]\n  (if (apply = (map first seqs))\n    (ffirst seqs)\n    (recur (map (fn [s]\n                  (drop-while (partial >\n                                       (apply max\n                                  \t          (map first seqs)))\n                              s))\n                seqs))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n   (if (apply = (map first colls)) \n     (first (first colls))\n     (let [c (sort-by first colls)]\n       (apply lazy-search (cons (rest (first c)) (rest c)))\n       )\n     )\n  )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 108, "code": "(fn [& a]\n  (let [f (map first a)]\n    (if (apply = f)\n      (first f)\n      (recur (map #(if (= (apply min f) (first %)) (rest %) %) a)))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 108, "code": "#(loop [S %&] (let [H (map first S) m (apply min H)] (if (apply = H) m (recur (map (fn [[q & Q :as s]] (if (= m q) Q s)) S)))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 108, "code": "(fn search[& ls]\n\t(let [fs (map first ls) mf (apply min fs)]\n\t\t(if (apply = fs) \n\t\t\t(first fs)\n\t\t\t(apply search (map\n\t\t\t\t\t\t#(if (= mf (first %))\n\t\t\t\t\t\t\t(rest %)\n\t\t\t\t\t\t\t%)\n\t\t\t\t\t\tls))\n\t\n\t\n\t\n\t\t)\n\t)\n)", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 108, "code": "(fn m[ & s]\n  ( let[ff (map first s)\n        mm (apply max ff)]\n      (if (every? #(= mm %) ff) mm\n        (apply m (map #(drop-while (fn [e] (< e mm)) %) s)))\n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 108, "code": "(fn [& s]\n  ((fn [c]\n     (let [f (map first c) m (apply min f)]\n       (if (apply = f)\n         (ffirst c)\n         (recur (map #(if (= m (first %)) (rest %) %) c))))) s))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 108, "code": "(fn [& xss]\n  (let [first-xs (map first xss)\n        min-x (apply min first-xs)]\n    (if (every? #(= % min-x) first-xs) min-x\n      (recur (map #(if (= min-x (first %)) (rest %) %)\n                  xss)))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (let [x (apply max (map first seqs))\n        heads (for [xs seqs] (drop-while #(< % x) xs))\n        elements (map first heads)]\n    (if (apply = elements)\n      x\n      (apply lazy-search heads))))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 108, "code": "(fn lezs [& ss]\n (let [ firsts    (map first ss)\n        greatest  (apply max firsts) \n        dropem    (fn [x] (drop-while #(< % greatest) x))\n        ]\n  (if (apply = firsts) \n       greatest\n      (recur (map dropem ss)))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 108, "code": "(fn [& colls] \n   (loop [colls colls]\n     (if (apply = (map first colls))\n       (ffirst colls)\n       (recur (map #(drop-while (fn [item] (< item (->> (map first colls)\n                                                        (apply max)))) %) colls)))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 108, "code": "(fn find-common-smallest [& colls]\n  (if (= 1 (count colls)) (ffirst colls)\n    (letfn [(drop-less-than [bound coll]\n                            (drop-while #(< % bound) coll))] \n      (loop [i (ffirst colls)\n             c (map (partial drop-less-than i) colls)]\n        (if (every? #(= i (first %)) c) i\n          (recur (second (first c)) (map (partial drop-less-than i) c)))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 108, "code": "(fn\n  [& colls]\n  (loop [colls colls]\n    (if (apply = (map first colls))\n     (ffirst colls)\n     (let [biggest-value (apply max (map #(or (first %) 0) colls))]\n       (recur (map (fn [coll] (drop-while #(< % biggest-value) coll)) colls))\n       )\n     ))\n  )", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 108, "code": "(fn l [& c]\n  (let [s (sort-by first c) e (map first s)]\n    (if (every? #(= (first e) %) e)\n      (first e)\n      (apply l (cons (rest (first s)) (rest s))))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 108, "code": "(fn smallest-common\n  [& seqs]\n  (letfn [(merge-seqs-indexed [heads seqs]\n            (lazy-seq\n              (let [min-i (apply min-key heads (range 0 (count heads)))\n                    min-head (heads min-i)\n                    min-seq (seqs min-i)]\n                (when-not (= min-head Double/POSITIVE_INFINITY)\n                  (cons [min-i min-head]\n                        (merge-seqs-indexed (assoc heads min-i\n                                                   (first min-seq))\n                                            (assoc seqs min-i\n                                                   (rest min-seq))))))))]\n    (let [inf-seqs (map #(lazy-cat % (repeat Double/POSITIVE_INFINITY)) seqs)\n          merged (merge-seqs-indexed (vec (map first inf-seqs))\n                                     (vec (map rest inf-seqs)))]\n      (loop [remaining merged\n             seen {}]\n        (when (seq remaining)\n          (let [[i v] (first remaining)\n                new-seen (assoc seen v (conj (or (seen v) #{}) i))]\n            (if (= (count (new-seen v)) (count seqs))\n              v\n              (recur (rest remaining) new-seen))))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 108, "code": "(fn lazy-search [& ss]\n  (if (apply = (map first ss))\n    (ffirst ss)\n    (let [[s & r] (sort-by #(min (first %)) ss)]\n      (apply lazy-search (rest s) r))))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": 108, "code": "(fn process [ & seqs ]\n    (let [heads     (map first seqs)\n          min-head  (apply min heads) \n          found?    (apply = heads)]\n      (if found? min-head\n          (let [next-s (map #(if (= min-head (first %)) (rest %) %) seqs)]\n            (apply process next-s)))))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 108, "code": "(fn min-colls\n  [& colls]\n  (let [first-coll (first colls)\n        lazy-find (fn [n coll]\n                    (loop [coll coll]\n                      (cond\n                       (empty? coll) false\n                       (> (first coll) n) false\n                       (= (first coll) n) true\n                       :else (recur (rest coll)))))]\n    (loop [coll first-coll]\n      (cond\n       (empty? coll) nil\n       (every? (partial lazy-find (first coll)) (rest colls)) (first coll)\n       :else (recur (rest coll))))))", "user": "4fc524aae4b081705acca37e"}, {"problem": 108, "code": "(fn [& colls]\n  (if (= 1 (count colls))\n    (ffirst colls)\n    (let [firsts (map first colls)\n          largest (apply max firsts)]\n      (if (apply = firsts)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 108, "code": "(fn smallest [& colls]\n  (let [[c1 & c] (sort-by first colls)]\n    (if (apply = (map first (cons c1 c)))\n      (first c1)\n      (apply smallest (cons (rest c1) c)))))", "user": "4f0f01c0535d0136e6c22329"}, {"problem": 108, "code": "(fn lazy-search\n  [coll & colls]\n  (letfn [(search [sets remaining-colls]\n            (if-let [result (first (apply clojure.set/intersection sets))]\n              result\n              (recur (map #(conj %1 (first %2)) sets remaining-colls)\n                     (map #(drop-while\n                            (partial > (apply max (map first remaining-colls))) %)\n                            remaining-colls))))]\n    (search (map #(hash-set (first %)) (cons coll colls)) (cons coll colls))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 108, "code": "(fn search [& lls]\n  (let [minval (apply min \n                      (filter (comp not nil?) \n                              (map first lls)))]\n    (if (= \n         (count (filter #(= (first %) minval) lls)) \n         (count lls))\n      minval\n      (apply search (map #(if (= (first %) minval) (rest %) %) lls)))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [heads (map first seqs)\n          largest (apply max heads)]\n      (if (apply = heads)\n        (ffirst seqs)\n        (recur (map #(drop-while (partial > largest) %) seqs))))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [c colls]\n    (if (some empty? c)\n      nil\n      (let [mf (map first c)]\n        (if (apply = mf)\n          (first (first c))\n          (let [m (apply max mf)]\n            (recur (map (partial drop-while #(< % m)) c))\n            ))))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 108, "code": "(fn lazy-search [& xs]\n     (let [heads (map first xs)]\n       (if (apply = heads)\n         (first heads)\n         (let [potential (apply max heads)\n               new-seqs\n               (for [x xs\n                     :let [[head & tail] x]]\n                 (if (= head potential)\n                   x\n                   tail))]\n           (apply lazy-search new-seqs)))))", "user": "509e62a8e4b08df8156e9e2e"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (loop [seqs seqs, mx nil]\n    (if (every? empty? seqs)\n      nil\n      (let [firsts (map first seqs)]\n        (if (every? #(= % mx) firsts)\n          mx\n          (let [mx' (apply max firsts)]\n            (recur (map #(if (= (first %) mx')\n                           %\n                           (rest %)) seqs)\n                   mx')))))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 108, "code": "(fn [& seqs]\n  (letfn [(firsts [seqs] \n            (map first seqs))\n          (equal-first [seqs]\n            (if (apply = (firsts seqs))\n              (first (first seqs))\n              false))\n          (max-first [seqs]\n            (apply max (firsts seqs)))]\n    (if-let [result (equal-first seqs)]\n      result\n      (recur (map (fn [x] (drop-while #(< % (max-first seqs)) x)) seqs))))\n)", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 108, "code": "(fn [& args]\n  (loop [colls args]\n    (let [firsts (map first colls)\n          mini (reduce max firsts)]\n      (if (apply = firsts)\n        mini\n        (recur (map (partial drop-while (partial > mini)) colls))))))", "user": "52173464e4b082aa80a88c75"}, {"problem": 108, "code": "(fn [S1 & Sqs]\n     (let [has-num (fn [n s] (cond (empty? s) false\n                                    (= n (first s)) true\n                                    (< n (first s)) false\n                                    :else (recur n (rest s))))]\n      (if (empty? Sqs)  \n            (first S1)\n              (first (filter #(every?  (partial has-num %) Sqs)  S1)))))", "user": "5649615be4b0284900eef641"}, {"problem": 108, "code": "(fn x [& l]\n    (let [[ff :as f] (map first l)\n          m (apply max f)]\n      (if (apply = f)\n        ff\n        (apply x (map (fn [[f & r :as a]] (if (= f m) a r)) l)))))", "user": "5382704be4b06839e8705ed4"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (let [heads (map first seqs)\n        head-max (apply max heads)]\n    (if (apply = heads)\n      head-max\n      (->> (map #(if (= head-max %) identity rest) heads)\n           (map #(%2 %1) seqs)\n           (apply lazy-search)))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 108, "code": "(fn [& xs]\n  (let [hds (map first xs)\n        h (apply max hds)]\n    (if (apply = hds) h (recur (map #(drop-while (partial > h) %) xs)))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 108, "code": "(fn [& lists]\n  (let [heads   (map first lists)\n        min-val (apply min heads)]\n    (if (apply = heads)\n      min-val\n      (recur (for [l lists]\n               (if (= (first l) min-val)\n                 (rest l)\n                 l))))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 108, "code": "(fn [& sqs]\n   (loop [seen []\n          qs (vec sqs)]\n     (let [fs (map first qs)\n           mf (apply min fs)\n           idxs (keep-indexed #(when (= %2 mf) %) fs)\n           seen (into seen (repeat (count idxs) mf))]\n       (if (= (count sqs) ((frequencies seen) mf))\n         mf\n         (recur seen (reduce #(update-in % [%2] rest) qs idxs))))))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 108, "code": "(fn [& seqs]\n  (if (= 1 (count seqs))\n    (ffirst seqs)\n\n    (loop [lazy-seqs (vec (map #(lazy-seq %) seqs))\n           lazy-seen (vec (map (comp sorted-set first) lazy-seqs))]\n\n      (let [intersection (apply clojure.set/intersection lazy-seen)]\n\n        (if (not (empty? intersection))\n\n          (first intersection)\n\n          (let [[min-seq-idx _] (->> (map-indexed #(vector %1 (apply max %2)) lazy-seen)\n                                     (sort-by second)\n                                     (first))\n                curr-set (lazy-seen min-seq-idx)\n                curr-seq (lazy-seqs min-seq-idx)\n                next-seq (lazy-seq (rest curr-seq))\n                next-val (first next-seq)\n                next-set (conj curr-set next-val)]\n\n            (recur (assoc lazy-seqs min-seq-idx next-seq)\n                   (assoc lazy-seen min-seq-idx next-set))))))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 108, "code": "(fn kkk [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply kkk (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 108, "code": "(fn smallest-num\n  [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [max-first (apply max (map first xs))]\n      (apply smallest-num\n             (map #(drop-while (partial > max-first) %) xs)))))", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 108, "code": "(fn lazy-searach [& ls]\n  (letfn [(advance [pred & lists]\n                   (map (fn [[head & tail :as ls]]\n                          (if (pred head) tail ls)) lists))]\n    (let [minimum (apply min (map first ls))\n          maximum (apply max (map first ls))]\n      (println minimum maximum)\n      (if (= minimum maximum) \n        minimum\n        (recur (apply advance #(< % maximum) ls))))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 108, "code": "(fn [& colls]\n  (let [fst-elms (map first colls)]\n    (if (apply = fst-elms) ; if all are the same\n      (first fst-elms) ; returns one\n      (let [max-elm (apply max fst-elms) ; get the max\n            drop-fn #(< % max-elm)        \n            new-colls (map #(drop-while drop-fn %) colls)] ; drop each value lower than max\n        (recur new-colls)))))", "user": "5680104ae4b0966858e4d8ea"}, {"problem": 108, "code": "(fn ! [[s & r] & rr]\n   (if-let [oo (seq rr)]\n     (let [newr (map (partial drop-while #(< % s)) oo)]\n       (if (apply = s (map first newr))\n         s\n         (apply ! r newr)))\n     s))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 108, "code": "(fn l [& a]\n  (if (apply = (map first a))\n    (ffirst a)\n    (apply l (map (fn [x] (drop-while #(<= % (apply min (map first a))) x)) a))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 108, "code": "(fn lazy-search [& s]\n  (letfn [(s-first [f s] (apply f (map first s)))\n          (s-drop-while [thresh s] (map (fn [x] (drop-while #(< % thresh) x)) s))]\n    (if (s-first = s)\n      (ffirst s)\n      (apply lazy-search (s-drop-while (s-first max s) s)) )))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 108, "code": "(fn smallest [& xs]\n  (let [firsts (map first xs)]\n    (if (every? #(= (first firsts)  %) firsts)\n      (first firsts)\n      (let [sorted-xs (sort-by first xs)]\n        (apply smallest (cons  (rest (first sorted-xs)) (rest sorted-xs)))))))", "user": "564a560ae4b0284900eef654"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [candidates (first colls), remaining-colls colls]\n    (let [x (first candidates), leq-fn #(<= % x)]\n      (if (->> remaining-colls\n               (map #(take-while leq-fn %))\n               (map last)\n               (every? #(= % x)))\n          x\n          (recur (rest candidates) (map #(drop-while leq-fn %) remaining-colls))))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 108, "code": "(fn [& s]\n  (let [f (map first s)]\n    (if (apply = f)\n      (first f)\n      (let [m (apply max f)]\n        (recur (map (fn [l] (drop-while #(< % m) l)) s))))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 108, "code": "(fn [& ss]\n  (loop [small (map first ss) in ss]\n    (if (apply = small)\n      (first small)\n      (let [smallest (apply min small)\n            new-in (map #(if (= (first %) smallest) (rest %) %) in)]\n        (recur (map first new-in) new-in)))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 108, "code": "(fn [& ls]\n    (let [heads (map first ls)\n          max-item (apply max heads)\n          min-item (apply min heads)]\n    (if (= max-item min-item)\n      max-item\n      (recur (map #(if (= min-item (first %)) (rest %) %) ls)))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 108, "code": "(fn q4q108 [& ss]\n  (cond\n    (some empty? ss) nil\n    (apply = (map first ss)) (-> ss first first)\n    :default\n    (recur\n     (map\n      #(if (> (apply max (map first ss)) (first %))\n         (rest %)\n         %)\n      ss))))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 108, "code": "(fn search [& seqs]\n        (let [frst (map first seqs)\n              mm (apply min frst)]\n          (if (every? (partial = mm) frst)\n            mm\n          (apply search (reduce \n            #(if (= (first %2) mm) (conj %1 (next %2)) (conj %1 %2)) \n            [] seqs)) )))", "user": "553900d4e4b09218d5f44fe5"}, {"problem": 108, "code": "(fn [& s]\n  (let [sorted-s (sort-by first s)\n        s-firsts (map first sorted-s)]\n    (if (apply = s-firsts)\n      (first s-firsts)\n      (recur (conj (rest sorted-s) (rest (first sorted-s)))))))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 108, "code": "(fn [& cs]\n   (let [s (->> cs (map first) (apply sorted-set)) n (first s)]\n     (if (or (s nil) (= 1 (count s))) n\n         (recur (for [c cs] (if (= n (first c)) (rest c) c))))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 108, "code": "(fn lazy-searching [& seqs]\n  (letfn [(find-max-index [vs]\n                          (first (apply min-key second (map-indexed vector vs))))]\n    (let [first-values (map first seqs)]\n      (if (apply = first-values)\n        (first first-values)\n        (let [mix-index (find-max-index first-values)]\n          (apply lazy-searching (map-indexed #(if (= mix-index %)\n                                          (rest %2)\n                                          %2) seqs)))))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 108, "code": "(fn smallest-common-number [& seqs]\n  (letfn [\n          (max-first [seqs]\n            (apply max (map first seqs)))\n          \n          (first-equals? [seqs]\n            (apply = (map first seqs)))\n          ;; filter collection with these elements less than v\n          (reduce-seqs [v coll]\n            (if (> v (first coll))\n              (reduce-seqs v (rest coll))\n              coll))]\n    \n    (let [curr (max-first seqs)]\n      (if (first-equals? seqs)\n        curr\n        (apply smallest-common-number (map #(reduce-seqs curr %) seqs))))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [cs colls]\n    (if (some empty? cs) nil\n      (let [m (apply min\n                     (map first cs))\n            mhead (group-by\n                    #(== m (first %))\n                    cs)]\n        (if (empty? (mhead false)) m\n          (recur\n            (concat\n              (map rest (mhead true))\n              (mhead false))))))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 108, "code": "(fn f [& s]                                                                                                                            \n   (when (some seq s)                                                                                                                    \n      (let [[n & m] (sort-by first s)]                                                                                                      \n      (if (apply =  (map first s))                                                                                                       \n            (first (first s))                                                                                                            \n            (apply f (cons (next n)  m )))                                                                             \n)))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 108, "code": "(fn [& sequences]\n  (if (apply = (map first sequences))\n    (first (first sequences))\n    (let [ss (sort-by first sequences) fs (drop 1 (first ss)) rs (rest ss)]\n      (recur (cons fs rs)))))", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 108, "code": "(fn [& args]\n\t(loop [seqs args]\n\t\t(let [firsts (map first seqs)]\n\t\t\t(if ((fn [xs] \n\t(let [f #(= % (first xs))]\n\t\t(every? f xs))) firsts) (first firsts)\n\t\t\t\t(recur (map (partial (fn [limit arg]\n\t(drop-while #(< % limit) arg))\n (reduce max firsts)) seqs))))))", "user": "54c74a78e4b045293a27f637"}, {"problem": 108, "code": "(fn [& colls]\n  (if (apply = (map first colls))\n    (ffirst colls)\n    (let [clls (sort-by first colls)\n          cls (concat [(rest (first clls))] (rest clls))]\n      (recur cls))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 108, "code": "(fn [& colls] (loop [n 0 result 100 x 0]\n                   (if (or (< (dec (count colls)) x) (> n 50)) result\n                    (if (every? #(some (set [(nth (nth colls x) n)]) (take-while (fn [number] (<= number (nth (nth colls x) n))) %1)) colls)\n                    (recur 0 (if (< (nth (nth colls x) n) result) (nth (nth colls x) n) result) (inc x))\n                    (recur (inc n) result x)))))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [s1 (first seqs)]\n    (when-let [n (first s1)]\n      (if (every? #(some #{n} %) (map #(take-while (partial >= n) %) seqs))\n        n\n        (recur (rest s1))))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "53ef235de4b0d648e757f4d4"}, {"problem": 108, "code": "(fn mymin [& colls]\n(letfn [(intersect\n         ([c1] c1)\n         ([c1 c2] (for [x c1\n                        y c2\n                        :while (<= y x)\n                        :when (= x y)]\n                      x))\n         ([c1 c2 & others] (lazy-seq (apply intersect (intersect c1 c2) others))))]\n(first (apply intersect colls))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 108, "code": "(fn [x & y] (letfn[(trim [n m] (take-while #(<= % m) n))]\n               (first(filter #(every? identity (map (fn [n] (= (last(trim n %)) % ))y)) x))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 108, "code": "(fn prob_108 [& more]\n  (if (not (some empty? more))\n    (let [more' (map first more)\n          a (apply min more')\n          b (apply max more')]\n      (if (= a b) a\n                  (recur (map (fn [xs] (drop-while #(< % b) xs)) more))))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 108, "code": "(fn[& a]\n  (let [mi (fn[s] (first (reduce (fn[[mi me] [i e]] (if (< e me) [i e] [mi me])) (map-indexed list s))))]\n    (cond\n      (some empty? a) nil\n      (apply = (map first a)) (first (first a))\n      :else (recur (update-in (vec a) [(mi (map first a))] rest)))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 108, "code": ";; as per Ox89's soln\n(fn lazy-search [& colls]                                                                                                                       \n    (let [[[head-coll1 & rest-coll1] & remaining-colls] (sort-by first colls)] ; sort collections by first element and then allocate                                                                                                        \n      (if (apply = (map first colls)) ; if the first value of all collections is the same we've found our minimum element\n        head-coll1 ; return result\n        (apply lazy-search (conj remaining-colls rest-coll1))) ; otherwise recur dropping the smallest element, which is not common to all the sets\n      )\n  )", "user": "569951e4e4b0542e1f8d143e"}, {"problem": 108, "code": "(fn search-common-min-number\n  [& args]\n  (let [firs (map first args)]\n    (if (apply = firs)\n      (first firs)\n      (apply search-common-min-number\n             (map #(drop-while #{(apply min firs)} %) args)))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 108, "code": "(fn smallest [& seqs]\n  (let [firsts (map first seqs)]\n    (if (apply = firsts) (first firsts)\n      (let [biggest (apply max firsts)]\n        (apply smallest (for [x seqs] (if (= (first x) biggest) x (drop 1 x))))))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 108, "code": "(fn lazysearch[& xs] ((fn lazysearchRec[xs]\n\t(if((fn someEmpty[xs] (some empty? xs))  xs) nil\n\t\t(let [\n\t\t\tfirsts (map first xs)\n\t\t\tmaxFirst ((fn maxOfMany[x] (reduce max x)) firsts)\n\t\t\tallMax? ((fn allEqualTo[x n] (every? #(= n %) x)) firsts maxFirst)\n\t\t\t]\n\t\t\t\t(if allMax? \n\t\t\t\t\tmaxFirst\n\t\t\t\t\t(lazysearchRec ((fn dropWhileLessThanAll[xs n] (map (fn [x] ((fn dropWhileLessThan[x n] (drop-while #(< % n) x))\n x n)) xs)) xs maxFirst))\n\t\t\t\t)\n\t\t)\n\t))\n (vec xs)))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 108, "code": "(fn lazy-search-smallest [& seqz] (let [max-first (last (sort (map first seqz))) seeked (map (fn [s] (drop-while #(< % max-first) s)) seqz)]\n                                    (if (apply = (map first seeked)) max-first\n                                      (apply lazy-search-smallest seeked))))", "user": "56baab13e4b0f26550335948"}, {"problem": 108, "code": "(fn [& args]\n  (let [m (map first args) s (apply max m)]\n    (if (apply = m)\n      s\n     (recur (map (partial drop-while #(< % s)) args)))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 108, "code": "(fn lazy-searching [& seqs]\n  (let [sorted-seqs (sort-by first seqs)]\n    (if (apply = (map first seqs))\n      (first (first seqs))\n      (apply lazy-searching (conj (rest sorted-seqs) (drop 1 (first sorted-seqs)))))))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [colls colls]\n    (if (apply = (map first colls))\n      (ffirst colls)\n      (recur\n        (map #(drop-while (partial > (->> colls\n                                          (apply map vector)\n                                          (first)\n                                          (apply max)))\n                          %)\n             colls)))))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [x colls]\n    (let [fs (map first x) big (apply max fs)]\n      (if (apply = fs)\n        big (recur (map #(if (< (first %) big) (rest %) %) x))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 108, "code": "(fn [a & as]\n  (if (nil? as) (first a)\n    (let [f (fn [v] (fn [coll] (first (filter #(= v %) (take-while #(>= v %) coll)))))]\n      (ffirst\n       (filter #(every? (complement nil?) %)\n               (for [x a :let [fx (f x)]] (map fx as)))))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 108, "code": "(fn [& seqs]\n ((fn [ls]\n  (let [firsts (map first ls)\n        [smallest largest] (apply (juxt min max) firsts)]\n   (if (= smallest largest)\n    smallest\n    (recur \n     (map \n      (fn [s] \n       (drop-while \n        #(> largest %) \n        s)) \n      ls))))) seqs))", "user": "56b86e64e4b0f26550335924"}, {"problem": 108, "code": "(fn m [& s] \n  (let [c (fn r [x y] \n            (let [a (first x) b (first y)] \n              (if (nil? a) [b] \n                (if (nil? b) [a] \n                  (if (= a b)(lazy-seq (cons b (r (rest x) (rest y)))) \n                    (if (> a b) (r x (rest y)) (r (rest x) y)))))))] \n    (first (reduce #(c % %2) s))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 108, "code": "(fn [& colls]\n  (let [largest (apply max (map first colls))\n        shifted (map (fn [coll] (drop-while #(> largest %) coll)) colls)\n        firsts (map first shifted)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur shifted))))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 108, "code": ";(fn [& colls]\n;  (loop [lead  (first colls)\n;         head  (first lead)\n;         match (map first colls)]\n;    (if (apply = match)\n;      (first match)\n;      (recur (next lead)\n;             (fnext lead)\n;             (map (comp first #(drop-while (partial > head) %)) colls)))))\n\n(fn [& colls]\n  (loop [[[head :as lead]] colls\n         match (map first colls)]\n    (if (apply = match)\n      (first match)\n      (recur (cons (rest lead) (rest colls)) (map (comp first #(drop-while (partial > head) %)) colls)))))\n\n;(fn [& colls]\n;  (ffirst\n;   (drop-while #(false? (apply = %))\n;               (map #(map first %)\n;                    (iterate\n;                     (fn [[lead & tails]] (conj\n;                                   (map (fn [coll] (drop-while (partial > (first lead) coll)) tails))\n;                                   (next lead)))\n;                     colls)))))\n\n;(fn [& colls]\n;  (->> (iterate\n;        (fn [[lead & tails]] (cons\n;                              (next lead)\n;                              (map (fn [coll] (drop-while (partial > (first lead)) coll)) tails)))\n;        colls)\n;       (map #(map first %))\n;       (drop-while #(false? (apply = %)))\n;       ffirst))", "user": "56481722e4b0284900eef628"}, {"problem": 108, "code": "(fn lazy-min\n    ([x] (if (empty? x) nil (first x)))\n    ([ x & xx] (loop [ x x, xx xx]\n                 (if (or (empty? x) (every? empty? xx)) nil\n                  (let [f (first x), ff (apply lazy-min xx)]\n                  (cond\n                    (nil? ff) nil\n                    (= f ff) f\n                    (< f ff) (recur (rest x) xx)\n                    (> f ff) (recur x (map rest xx))))))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 108, "code": "(fn lazy-search [& sequences]\n  (if (apply = (map first sequences))\n    (ffirst sequences)\n    (let [sorted-sequences (sort-by first sequences)]\n      (apply lazy-search\n             (cons (rest (first sorted-sequences))\n                   (rest sorted-sequences))))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 108, "code": "(fn smallest-common\n  [& seqs]\n  (if (some empty? seqs) nil\n      (let [heads (map first seqs)\n            smallest (apply min heads)\n            is-smallest (not-any? #(> % smallest) heads)]\n        (if is-smallest\n          smallest\n          (->> (map #(if (= (first %) smallest) (rest %) %) seqs)\n               (apply smallest-common))))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 108, "code": "(fn lazysearch [& ls]\n  (let [firsts (map first ls)\n        maxfirst (apply max firsts)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur\n       (reduce (fn [acc l] (conj acc (if (< (first l) maxfirst)\n                                       (rest l)\n                                       l)))\n               []\n               ls)))\n    )\n  )", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 108, "code": "(fn [& seqs]\n   (letfn [(n-in-one-seq [n seq1]\n                         (= n (last (take-while #(<= % n) seq1))))\n           (n-in-all-seq [n seqs]\n                         (every? #(n-in-one-seq n %) seqs))]\n     (first (filter #(n-in-all-seq % seqs) (first seqs)))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 108, "code": "(fn [& ls]\n  (loop [ls (map #(vector (first %) (rest %)) ls)]\n    (if (apply = (map first ls))\n      (ffirst ls)\n      (let [[_ l :as min'] (apply min-key first ls) n (first l)]\n        (recur (cons [n (rest l)] (remove (partial = min') ls)))))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "570243e2e4b08d47c97781dd"}, {"problem": 108, "code": "(fn ls [[h & t] & r]\n\t(let [r (map (fn [s] (drop-while #(> h %) s)) r)]\n\t\t(if (every? #{h} (map first r))\n\t\t\th\n\t\t\t(apply ls (cons t r)))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 108, "code": "(fn [l & ls]\n  (loop [l l]\n    (if (apply (partial = (first l))\n               (map (comp last (partial take-while #(<= % (first l)))) ls))\n      (first l)\n      (recur (rest l)))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 108, "code": "(fn lazy-search [& lls]\n  (let [ls (map first lls)\n        m (apply min ls)]\n    (if (->> ls set count (= 1))\n      m\n      (apply lazy-search\n             (map (fn [l]\n                    (filter #(> % m) l))\n                  lls)))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 108, "code": "(fn [& xs] \n\t(letfn \n\t\t[(f-r [s] ((juxt first rest) s))\n\t\t (t [ys]\n\t\t\t(if (apply == (map first ys))\n\t\t\t\t\t(first (first ys))\n\t\t\t\t\t(let [zs (sort-by first ys)\n\t\t\t\t\t\t  ws (cons (f-r (last (first zs))) \n\t\t\t\t\t\t\t\t  (rest zs))]\n\t\t\t\t\t\t(t ws))))]\n\t\t(t (map f-r xs))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 108, "code": "(fn [& args]\n  (let [heads (map first args)]\n    (if (apply = heads)\n      (first heads)\n      (recur (map #(drop-while (fn [i] (= i (apply min heads))) %) args)))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 108, "code": "(fn [& xs]\n  (loop [xs xs]\n    (let [m (apply max (map first xs))]\n      (if (apply == (map first xs))\n        (ffirst xs)\n        (recur (map (fn [x] (drop-while #(< % m) x)) xs))))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 108, "code": "(fn [& lists]\n(let [first-vals (map first lists)]\n  (if (apply = first-vals)\n    (first first-vals)\n    (let [max-val (apply max first-vals)]\n      (recur (map (fn [x] (drop-while #(> max-val %) x)) lists))))))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 108, "code": "(fn [& seqs]\n    (letfn [(search [[x :as s] y]\n              (when s\n                (cond (< x y) (search (next s) y)\n                      (= x y) true\n                      (> x y) false)))]\n      (->>\n       (apply map\n              (fn [& xs]\n                (first (filter (fn [x] (every? #(search % x) seqs)) xs)))\n              seqs)\n       (filter identity)\n       first)))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 108, "code": "(fn [& seq-of-seqs]\n  (let [firsts (fn [seqs-seq] (for [x seqs-seq] (first x)))\n        next-try (fn [seqs-seq] (apply max (firsts seqs-seq)))\n        trimmed-seqs (fn [x seqs-seq]\n                       (for [y seqs-seq] (drop-while #(< % x) y)))\n        found? (fn [seqs-seq] (apply = (firsts seqs-seq)))\n        not-found? (fn [seqs-seq]\n                     (first\n                       (filter #(true? %)\n                               (for [x seqs-seq] (empty? x)))))\n        tail (fn [seqs-seq] (for [x seqs-seq] (rest x)))]\n    (loop [lseq seq-of-seqs]\n      (if (not-found? lseq)\n        \"No match\"\n        (if (found? lseq)\n          (first (first lseq))\n          (let [prepped-seqs (trimmed-seqs (next-try lseq) lseq)\n                next-round-of-seqs (if (found? prepped-seqs)\n                                     prepped-seqs\n                                     (tail prepped-seqs))]\n            (recur next-round-of-seqs)))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 108, "code": "(fn solve [s & seqs ]\n  (let [has (fn [seq val] (= (first (drop-while #(< % val) seq)) val))]\n    (first (drop-while (fn [v] (not (every? #(has % v) seqs))) s))))", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 108, "code": "(fn find-smallest-common [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [coll (first colls)\n          colls (rest colls)]\n      (loop [check (first coll) to-check (rest coll)]\n        (if (reduce #(and %1 %2) (map (partial (fn in-coll [x coll]\n  (if (seq coll)\n    (if (= x (first coll))\n      true\n      (if (< x (first coll))\n        false\n        (recur x (rest coll))))\n    false)) check) colls))\n          check\n          (recur (first to-check) (rest to-check)))))))", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [drop-from-many-seqs (fn [cond-int vecs] (map #(drop-while (partial > cond-int) %) vecs))\n        max-firsts (fn [vecs] (apply max (map first vecs)))]\n    (if (not (coll? (first seqs)))\n      (first seqs)\n      (loop [seqs seqs]\n        (if (apply = (map first seqs))\n          (max-firsts seqs)\n          (recur (drop-from-many-seqs (max-firsts seqs) seqs)))))))", "user": "571cd9dce4b0145328a76271"}, {"problem": 108, "code": "(fn [& xs]\n  (loop [xs xs]\n    (let [vs (map first xs)\n          m (apply max vs)]\n      (when-not (every? empty? xs)\n        (if (apply = vs) m\n                         (recur (map #(if (< (first %) m) (rest %) %) xs)))))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 108, "code": "(fn [& seqs]\n    (loop [seqs seqs]\n      (if (every? #(= (ffirst seqs) (first %)) seqs)\n        (ffirst seqs)\n        (let [minval (apply min (map first seqs))]\n          (recur (map #(if (= minval (first %)) (rest %) %) seqs))))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [f (fn [seqs]\n            (let [firsts (map first seqs)\n                  m (apply max firsts)\n                  done (apply = firsts)]\n              (if done\n                m\n                (recur (map #(if (= (first %) m) % (rest %)) seqs)))))]\n    (f seqs)))", "user": "571d063ee4b0145328a76272"}, {"problem": 108, "code": "(fn [& vss]\n            (if (== 1 (count vss))\n              (ffirst vss)\n              (loop [xss vss]\n                (if (every? seq xss)\n                  (if (apply = (map first xss))\n                    (ffirst xss)\n                    (let [grp (group-by first xss)\n                          ks (sort (keys grp))\n                          [k t] ks\n                          rss (->> (dissoc grp k)\n                                   vals\n                                   (apply concat))]\n                      (recur\n                       (into rss (map (fn [xs]\n                                        (drop-while #(< % t) xs))\n                                      (grp k))))))\n                  nil))))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 108, "code": "(fn\n  [s & ss]\n  (let [x (apply = (map (comp first #(drop-while (fn [x] (< x (first s))) %)) (into ss [s])))]\n    (if x\n    (first s)\n    (recur (rest s) ss))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 108, "code": "(fn lazy-search [& xs]\n  (letfn [(aux [ys]\n            (if (some empty? ys)\n              (throw (Exception. \"empty lists/list exist(s)\"))\n              (let [candidate (apply max (map first ys))\n                    with-candidate-ys (map #(drop-while (partial > candidate) %) ys)\n                    has-the-one? #(= candidate (first %))\n                    left-ys (map #(drop-while (partial >= candidate) %) with-candidate-ys)]\n                (if (every? has-the-one? with-candidate-ys)\n                  candidate\n                  (recur left-ys)))))]\n    (aux xs)))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 108, "code": "(fn [& colls]\n  (letfn [(values-greater-than [minval colls]\n            (let [colls (map (partial drop-while #(>= minval %)) colls)\n                  minval (apply min (concat [Double/POSITIVE_INFINITY] (keep first colls)))\n                  firsts (map first colls)]\n              (when (some seq colls)\n                (cons firsts (lazy-seq (values-greater-than minval colls))))))]\n    (ffirst (filter (partial apply =) (values-greater-than Double/NEGATIVE_INFINITY colls)))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 108, "code": "(fn [& xss]\n  (let [fs (map first xss)]\n    (if (apply = fs)\n      (first fs)\n      (let [m (apply max fs)]\n        (recur (->> xss (map (fn [xs] (drop-while #(< % m) xs)))\n                        (filter (complement empty?))))))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 108, "code": "(fn [col & colls]\n  (loop [c col]\n    (let [a (first c)]\n      (if (every? #(= a (last %)) (map (fn [b] (take-while #(<= % a) b)) colls) )\n           \n        a\n       (recur (rest c)) ;recur           \n      ) ;if\n     ) ;let    \n  ) ;loop\n) ;fn", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (apply = (map first colls))\n    (ffirst colls)\n    (apply lazy-search (sort-by first (cons (rest (first colls)) (rest colls))))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 108, "code": "(fn searchAcross [x & xs] (letfn [(lazySearch [toFind toLook] (loop [x toFind y toLook] (cond \n                                                                                          (= x (first y)) true\n                                                                                          (< x (first y)) false\n                                                                                          :else (recur x (rest y)))))]\n                            (if (empty? xs) \n                              (first x)\n                              (if \n                                (reduce #(and %1 %2) (map #(lazySearch (first x) %) xs)) (first x)\n                                (apply searchAcross (cons (rest x) xs))))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 108, "code": "(fn [& ls]\n  (loop [rst ls]  \n     (let [fs (map first rst) m (apply max fs)]\n        (if (apply = fs) m  (recur (map (fn [l] (drop-while #(< % m) l)) rst) ))\n     )\n )\n)", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 108, "code": "(fn lazy-searching [& colls]\n  (letfn [(min-index [coll]\n            (get (apply min-key #(% 1) (map vector (range) coll)) 0))\n          (update [m k f]\n            (assoc m k (f (get m k))))]\n    (loop [cs (vec colls)]\n      (let [first-vals (map first cs)\n            found (apply = first-vals)\n            i (min-index (map first cs))\n            updated (update cs i rest)]\n        (if\n          found\n          (first first-vals)\n          (recur updated))))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 108, "code": "(fn lns [& sequences]\n  (let [firsts (map first sequences)]\n    (cond (apply = firsts) (first firsts)\n          :else (let [m (apply min firsts)]\n                  (apply lns (map #(if (= (first %) m)\n                                     (rest %)\n                                     %)\n                                  sequences))))))", "user": "50a00725e4b08df8156e9e46"}, {"problem": 108, "code": "(fn [& colls]\n  (let [heads (map first colls)]\n    (if (apply = heads)\n      (first heads)\n      (recur (map (partial drop-while #(< % (apply max heads))) colls)))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 108, "code": "(fn [& seqs]\n    (letfn [(cycle-pull-until-greater-or-equal [candidate seqs]\n              (let [[candidate pulled-seq] ((juxt first identity) (drop-while (fn [e] (< e candidate)) (first seqs)))\n                    cycled-seqs (concat (rest seqs) [pulled-seq])]\n                (cons\n                  (map first seqs)\n                  (lazy-seq\n                    (cycle-pull-until-greater-or-equal candidate cycled-seqs)))) )]\n      (->> seqs\n        (cycle-pull-until-greater-or-equal (apply max (map first seqs)))\n        (filter (partial apply =))\n        ffirst)))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 108, "code": "(fn f\n  ([x] (first x))\n  ([x & xs]\n   (->> (for [i x]\n          (map #(some #{i} (take-while (fn [s] (>= i s)) %)) xs))\n        (map set)\n        (filter #(not (contains? % nil)))\n        ffirst)))", "user": "575fbe58e4b08062f99a4e87"}, {"problem": 108, "code": "(fn [s & seqs]\n  (cond \n   (apply = (conj (map first seqs) (first s))) (first s) ;; All elements at the start of the seqs are the same\n   (some #(< (first %) (first s)) seqs) ; There are seqs that are \"behind\" the main sequence s, move these ahead\n     (recur s (map #(if (< (first %) (first s)) (rest %) %) seqs))\n   :otherwise (recur (rest s) seqs) ; Move main sequence s one step forward\n   )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 108, "code": "(fn lazy-search [& lists]\n  (letfn [(minn [lists] (reduce #(if (> %1 (first %2))\n                                   (first %2)\n                                   %1) (first (first lists)) lists))\n          \n          (removel [lists ele]\n            (map #(if (= (first %) ele)\n                    (rest %)\n                    %) lists))\n          (contains-all? [lists ele]\n            (reduce #(if (= (first %2) ele)\n                       (and %1 true)\n                       false) true lists))\n          ]\n    (loop [lists2 lists]\n      (let [m (minn lists2)]\n        (if (contains-all? lists2 m)\n          m\n          (recur (removel lists2 m)))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n(apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "57642916e4b0994c1922fbee"}, {"problem": 108, "code": "(fn findMin [& seqs]  \n  (loop [colls seqs]\n    (if (some empty? colls) nil\n      (let [firsts (map first colls)\n            maximum (apply max firsts)]        \n        (if (every? #(= maximum %) firsts) maximum\n          (recur (map (fn [coll] (drop-while #(< % maximum) coll)) colls))))\n      )))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 108, "code": "(fn [& thelists]\n  (let [len (count thelists)]\n    ((fn [xs seenmap]\n       (let [sortedlists (sort-by first xs)\n             taker (first sortedlists)\n             leavers (rest sortedlists)\n             takermap (hash-map (first taker) 1)\n             currentmap (merge-with + seenmap takermap)\n             mostcommon (reduce max (vals currentmap))]\n         (if (= len mostcommon)\n           (first (filter #(= len (get currentmap %)) (keys currentmap)))\n           (recur\n            (for [i (range len)]\n              (if (= i 0)\n                (rest (first sortedlists))\n                (nth sortedlists i)))\n            currentmap))))\n   thelists {})))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "57227f10e4b0c5bde472c0cd"}, {"problem": 108, "code": "(fn [& s]\n  ((fn [c]\n     (let [f (map first c) m (apply min f)]\n       (if (apply = f)\n         (ffirst c)\n         (recur (map #(if (= m (first %)) (rest %) %) c))))) \n    s))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 108, "code": "(fn [& args]\n  (letfn [(drop-while-less-than [x colls]\n            (map (partial drop-while #(< % x)) colls))\n          (first-match [& xs]\n            (if (apply = (map first xs))\n              (first (first xs))\n              (let [[largest-first & rest] (sort-by first > xs)\n                    largest (first largest-first)]\n                (recur (list* largest-first (drop-while-less-than largest rest))))))]\n    (apply first-match args)))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 108, "code": "(fn [s & ss]\n  (letfn [(lazy-search [n coll] (if (>= n (first coll)) (if (= n (first coll)) n (recur n (next coll))) nil))]\n    (if \n      (every? #(= (first s) %) (map (partial lazy-search (first s)) ss)) \n      (first s) \n      (recur (next s) ss))))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 108, "code": "(fn f [& s]\n  (let [fs (map first s)]\n    (if (apply = fs)\n      (first fs)\n      (let [i (first (apply min-key second (map-indexed vector fs)))]\n        (apply f (assoc (vec s) i (rest (nth s i))))))))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 108, "code": "(fn solve [& colls]\n  (let [firsts (map first colls)\n        sorted-colls (sort-by first colls)]\n    (if (apply = firsts)\n      (first firsts)\n      (apply solve (rest (first sorted-colls)) (rest sorted-colls)))))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 108, "code": "(fn [col & cols] \n  (some \n   (fn [e] \n     (when \n       (every? \n        #(= e %) \n        (map \n         (partial some #(when (>= % e) %)) \n         cols)) \n       e)) \n   col))", "user": "5776385fe4b0979f89651632"}, {"problem": 108, "code": "(fn f [& args]\n  (let [mx (apply max (map first args))]\n    (if (apply = (map first args))\n      mx\n      (apply f (map #(if (< (first %) mx) (rest %) %) args)))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 108, "code": "(fn [& args]\n  (loop [start 0 news args]\n    (if (apply = (map first news)) (ffirst news)\n      (recur (apply max (map first news))\n             (map (fn [x] (drop-while #(> start %) x)) news)))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [all-firsts (map first colls)\n        min-first (apply min all-firsts)]\n    (if (apply = all-firsts)\n      min-first\n      (recur (map (fn [coll] (drop-while #(= min-first %) coll)) colls)))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 108, "code": "(fn min-common [& colls]\n    (when-not (some empty? colls)\n      (let [heads    (map first colls)\n            max-head (apply max heads)]\n        (if (apply = heads)\n          (first heads)\n          (recur (map (fn [c] (drop-while #(< % max-head) c)) colls))))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5776558ee4b0979f89651633"}, {"problem": 108, "code": ";; If the first value in every sequence is the same (checked as min =\n;; max), we are done.  Otherwise, repeat with the first element\n;; removed from the sequence whose first element is smallest.\n\n(fn [& s]\n  (loop [v (vec s)]\n    (let [first-vals (map first v)\n          smallest (apply min first-vals)]\n      (if (= smallest (apply max first-vals))\n        smallest\n        (let [i (apply min-key #(nth first-vals %) (range (count v)))]\n          (recur (update-in v [i] next)))))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 108, "code": "(fn __ [& xs]\n  (let [fe (flatten (map #(take 1 %) xs))\n        m (apply max fe)\n        nxs (map (fn [x] (drop-while #(< % m) x)) xs)]\n    (if (apply = fe)\n      (first fe)\n      (apply __ nxs))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 108, "code": "(fn lsearch [& cs]\n    (let [x (first (first cs))]\n      (if (apply (partial = x)\n                 (map last\n                      (map (partial take-while #(>= x %))\n                           (rest cs))))\n        x\n        (apply lsearch (cons (rest (first cs)) (rest cs))))))", "user": "579693d4e4b039eba2ecb0e7"}, {"problem": 108, "code": "(fn lsearch [& cs]\n    (let [x (first (first cs))]\n      (if (apply (partial = x)\n                 (map last\n                      (map (partial take-while #(>= x %))\n                           (rest cs))))\n        x\n        (apply lsearch (cons (rest (first cs)) (rest cs))))))", "user": "5796d308e4b039eba2ecb0ed"}, {"problem": 108, "code": "(fn lazy-search [xs & rest-xs]\n  (let [sorted-contains? (fn [x coll] (some (partial = x) (take-while (partial >= x) coll)))\n        every-contains? (fn [x xs] (every? #(sorted-contains? x %) xs))]\n    (first (filter #(every-contains? % rest-xs) xs))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 108, "code": "(fn lsearch [& cs]\n    (let [x (first (first cs))]\n      (if (apply (partial = x)\n                 (map last\n                      (map (partial take-while #(>= x %))\n                           (rest cs))))\n        x\n        (apply lsearch (cons (rest (first cs)) (rest cs))))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 108, "code": "(fn lsearch [& cs]\n    (let [x (first (first cs))]\n      (if (apply (partial = x)\n                 (map last\n                      (map (partial take-while #(>= x %))\n                           (rest cs))))\n        x\n        (apply lsearch (cons (rest (first cs)) (rest cs))))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 108, "code": "(fn lsearch [& cs]\n    (let [x (first (first cs))]\n      (if (apply (partial = x)\n                 (map last\n                      (map (partial take-while #(>= x %))\n                           (rest cs))))\n        x\n        (apply lsearch (cons (rest (first cs)) (rest cs))))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 108, "code": "(fn LSE [& args]\n (when (every? seq args)\n  (let [firsts (sort (map first args))]\n   (letfn [(find-num [n coll]\n             (some #{n} (take-while #(<= % n) coll)))\n           (every-finds? [n colls]\n             (every? (partial find-num n) colls))\n           (find-from-seq [n-seq colls]\n             (when-let [s (seq n-seq)]\n               (if (every-finds? (first s) colls)\n                 (first s)\n                 (find-from-seq (rest s) colls))))\n\n           ]\n    (let [found (find-from-seq firsts args)]\n     (if found found\n       (apply LSE (map rest args))))))))", "user": "57822efce4b0d36ec5835e91"}, {"problem": 108, "code": "(fn lazy-search [& LS]\n  (loop [LS LS]\n    (let [x (reduce min (map first LS))\n          heads (map first (map (partial drop-while #(< % x)) LS))\n          tails (map (partial drop-while #(<= % x)) LS)]\n      (if (every? #(= x %) heads)\n        x\n        (recur tails)))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 108, "code": "(fn [& xss]\n  (loop [xss xss]\n    (let [xs (map first xss)\n          min-ix (first (apply min-key second (map-indexed vector xs)))]\n      (if\n        (= 1 (count (distinct xs)))\n        (first xs)\n        (recur\n          (map-indexed\n            (fn [i xs] (if (= i min-ix) (rest xs) xs))\n            xss))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [colls colls]\n    (let [colls (sort-by first colls)]\n    \t(if (apply = (map first colls)) (first (map first colls))\n          (recur (cons (rest (first colls)) (rest colls)))))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [firsts (map first seqs)]\n      (if (apply = firsts)\n        (ffirst seqs)\n        (let [smallest (first (sort firsts))]\n          (recur (map #(if (= (first %) smallest) (rest %) %) seqs)))))))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 108, "code": "(fn lazySearch [& params] (let [searchAlgo (fn lazySearch [lists]\n\t(let [parts (map first lists)]\n\t\t(if (some (partial not= (first parts)) parts)\n\t\t\t(let [maxPart (apply max parts)\n\t\t\t\tnewList (map (fn [x] (drop-while (partial > maxPart) x)) lists)]\n\t\t\t\t(lazySearch newList))\n\t\t\t(first parts))))]\n (searchAlgo params)))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 108, "code": "(fn g [& ls]\n  (let [m (apply min (map first ls))\n        ps (remove #(= m (first %)) ls) \n        qs (map #(if (= m (first %)) (rest %) %) ls)]\n    (if (zero? (count ps)) m (apply g qs))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 108, "code": "(fn p108 [& cols]\n  (let [xs (map first cols) \n        topx (apply max xs)]\n    (if (apply = xs)\n      topx\n      ;; advance all sequences and check again\n      (recur (map (fn [col] (drop-while #(< % topx) col)) cols)))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 108, "code": "(fn lazy-search \n  ([sq] (first sq))\n  ([sq & seqs]\n    (let [x (first sq)\n          xs (map (fn [s] (drop-while #(< % x) s)) seqs)]\n      (if (every? #(= x %) (map first xs))\n        x\n        (apply lazy-search (rest sq) seqs)))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 108, "code": "(fn [& seqs]\n    (let\n      [\n        xs (first seqs)\n        seqs' (rest seqs)\n        in-sorted-list?\n        (fn [x ys]\n          (loop\n            [\n              ys ys\n            ]\n            (let\n              [\n                y (first ys)\n                ys' (rest ys)\n              ]\n              (cond\n                (= x y) true\n                (> y x) false\n                :else (recur ys')\n              )\n            )\n          )\n        )\n      ]\n      (loop\n        [\n          xs xs\n        ]\n        (let\n          [\n            x (first xs)\n            xs' (rest xs)\n          ]\n          (if\n            (every?\n              (partial in-sorted-list? x)\n              seqs'\n            )\n            x\n            (recur xs')\n          )\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 108, "code": "(fn [& xss]\n  (let [sames (fn sames [xs ys]\n                (lazy-seq\n                  (if (and (seq xs)\n                           (seq ys)\n                           (some #{(first xs)}\n                             (take-while #(<= % (first xs)) ys)))\n                      (cons (first xs) (sames (rest xs) ys))\n                      (sames (rest xs) ys))))]\n    (first\n     (reduce sames (first xss) (rest xss)))))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 108, "code": "(fn [ & v ]\n    (loop [ranges        v ]\n      (let [first-ranges (map first ranges)\n            all-same     (apply = first-ranges)\n            min-fr       (apply min first-ranges)\n            ]\n        (if all-same\n          (first first-ranges)\n          ;; else we want to rest the range with the smallest\n          (recur\n           (map\n            (fn [rng]\n              (if (= (first rng) min-fr) (rest rng) rng))\n            ranges)\n           )\n          )\n        )\n      )\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 108, "code": "(fn[& seqs]\n  (loop[s (vec seqs)]\n    (let [firsts (map-indexed (fn [i v] [i (first v)]) s)\n          [i v]  (apply min-key second firsts)]\n      (if (apply = (map second firsts))\n        v\n        (recur (update-in s [i] rest))))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n          (if (apply = heads)\n            largest\n            (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "56a37ccee4b0542e1f8d14cb"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 108, "code": "(fn [& s]\n  ((fn [i n]\n    (let [x (filter integer? (apply clojure.set/intersection i))]\n      (if (and (seq x) (apply min x))\n          (apply min x)\n          (let [e (apply max (map first n))\n                a (map #(take-while (partial >= e) %) n)\n                b (map #(drop-while (partial >= e) %) n)]\n            (recur (map into i a) b)))))\n    (repeat (count s) #{}) s))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [candidates (map first seqs)]\n      (if (apply = candidates)\n        (first candidates)\n        (let [greatest (apply max candidates)\n              transform (fn [s] (if (= greatest (first s)) s (rest s)))]\n              (recur (map transform seqs)))))))", "user": "54ac5ad7e4b09f271ff37cd6"}, {"problem": 108, "code": "(fn lazy-search [& s]\n  (loop [s s] (if (apply = (map first s)) (ffirst s)\n                  (let [[fs & rs] (sort-by first s)]\n                    (recur (cons (rest fs) rs))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 108, "code": "(fn [& x]\n    (letfn \n        [\n          (prune [i  x]\n              (for [ a  x ]\n                 \n                 (if   \n                   (= i (first a))\n                   (drop 1 a)\n                   a\n                 )\n              )\n           )\n\n            (mini [x]\n              (let \n                  [f (flatten (map first  x))  isMin (apply = f)  m   (lazy-seq  (cons [] (interleave f x)))  minimum (apply min f)]\n                   (if \n                      (= isMin true) \n                      (first  f)\n                      (mini (prune minimum x))\n                   )\n               )\n            )\n        ] \n    \n       (mini x)\n    )\n     \n   )", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 108, "code": "(fn smallest-common-num [& cols]\n  (letfn [(move-cursor [col num]\n            (if (>= (first col) num)\n              col\n              (recur (rest col) num)))]\n    (let [firsts    (map first cols)\n          max-first (reduce max firsts)]\n      (if (apply = firsts)\n        (first firsts)\n        (recur (map #(move-cursor %1 max-first) cols))))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [firsts  (map first colls)\n        largest (apply max firsts)\n        smallest (apply min firsts)]\n    (if (= largest smallest)\n      smallest\n      (let [not-largest (group-by #(< (first %) largest) colls)\n            incremented (map rest (not-largest true))\n            unchanged (not-largest false)]\n        (apply lazy-search (concat incremented unchanged))))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 108, "code": "(fn [& args]\n  (loop [a args]\n    (let [x (map first a)]\n      (if (= 1 (count (set x)))\n        (first x)\n        (let [m (apply min-key identity x)]\n          (recur (map (fn [v] (if (= (first v) m) (next v) v)) a)))))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 108, "code": "(fn smallest [& seqs]\n  (let [lownums (map first seqs)]\n    (if (= 1 (count (set lownums)))\n      (first lownums)\n      (let [largest-low (last (sort lownums))\n            seqs (map #(drop-while (partial > largest-low) %) seqs)]\n        (apply smallest seqs)))))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 108, "code": "(fn lazy-search [& xss]\n  (letfn [\n          (do-lazy-search [x xss]\n            (letfn [\n                    (move-to [y xs]\n                      (if (>= (first xs) y)\n                        xs\n                        (move-to y (rest xs))))\n                    \n                    (finish? [xfs]\n                      (reduce \n                        (fn [acc y] \n                          (and acc (= y x))) \n                        true xfs))]\n              \n              (let [xfs (map first xss)]\n                (if  (finish? xfs)                       \n                  x      \n                  (let [y (reduce max xfs)]\n                    (do-lazy-search y (map #(move-to y %) xss)))))))]  \n        \n    (if (= (count xss) 1)\n      (first (first xss))\n      (do-lazy-search (first (first xss)) xss))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 108, "code": "(fn __ [& seqs]\n  (if (apply = (map first seqs))\n    (first (first seqs))\n    (let [sorted (sort-by first seqs)]\n      (apply __ (cons (rest (first sorted))\n                      (rest sorted))))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 108, "code": "(fn [& xss]\n  (cond\n    (= 1 (count xss)) (ffirst xss)\n    (apply = (map first xss)) (ffirst xss)\n    (< (ffirst xss) (ffirst (rest xss))) (recur (concat (rest xss) [(rest (first xss))]))\n    true (recur (concat (rest xss) [(first xss)]))))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 108, "code": "(fn a [& xs]\n\n  (let [s (set (map first xs))\n\n        m (apply max s)]\n\n    (if (= 1 (count s))\n\n     m\n\n     (let [less? (fn [x] (< x m))\n\n           rew (map #(drop-while less? %) xs)]\n\n       (apply a rew)))))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 108, "code": "(fn first-common [& seqs]\n  (let [heads (map first seqs), max-head (apply max heads)]\n    (if (apply = heads)\n      max-head\n      (recur (map (fn [seq]\n                    (drop-while (fn [e]\n                                  (< e max-head))\n                                seq))\n                  seqs)))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 108, "code": "(fn seqmin [& seqs]\n  (loop [ss seqs]\n    (let [fs (map first ss)]\n      (if (apply = fs)\n        (first fs)\n        (let [poss (apply max fs)]\n          (recur (for [seq ss]\n                   (if (= (first seq) poss)\n                     seq (rest seq)))))))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 108, "code": "(fn [& s]\n   (let [a (map first s)\n         m (apply max a)]\n     (if (apply = a) m\n       (recur (map #(if (= m (first %)) % (rest %)) s)))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 108, "code": "(fn lsearch [& seqs]                                                                                                                       \n    (let [[[lowest & the-rest] & other-seqs] (sort-by first seqs)]                                                                                                         \n      (if \n        (apply = (map first seqs))                                                                                                             \n        lowest                                                                                                                   \n        (apply lsearch (conj other-seqs the-rest)))))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 108, "code": "(fn lazysearch [& sqs]\n  (let [smallest (apply (fn lzmn [& sqs]\n                          (apply min (map first sqs))) sqs)]\n    (if (apply = (map (fn [s] (first (drop-while #(< % smallest) s))) sqs))\n      smallest\n      (apply lazysearch (map (fn [s] (drop-while #(<= % smallest) s)) sqs)))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 108, "code": "(fn find-common-min [& colls]\n  (if (apply = (for [coll colls] (first coll)))\n    (first (first colls))\n    (let [minimum (apply min (for [coll colls] (first coll)))]\n      (loop [remaining colls i 0]\n        (if (= minimum (first (first remaining)))\n          (apply find-common-min (update-in (vec colls) [i] rest))\n          (recur (rest remaining) (inc i)))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 108, "code": "(fn [h & r](first \n\n(reduce #(->> (iterate (fn ([[_ [a & as :as A] [b & bs :as B]]] \n         \t\t\t\t\t\t(cond (== a b) [[a] as bs] \n            \t\t\t\t\t\t  (> a b) [[] A bs] \n            \t\t\t\t\t\t  :else [[] as B]))) [[] % %2])\n              (map ffirst)\n              (remove nil?))\n        h r)))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 108, "code": "(fn common-min [s & ss]\n  (if (empty? ss)\n    (apply min s)\n    (loop [[fe & reste] s]\n      (let [cut (map (fn [s] (take-while (partial >= fe) s)) ss)]\n        (if (every? (fn [s] (some (partial = fe) s)) cut)\n          fe\n          (recur reste))))))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 108, "code": "(fn ls\n  [& cols]\n  (let [mins (map first cols)]\n    (if (apply = mins)\n      (first mins)\n      (let [ma (apply max mins)]\n        (apply ls (map (fn [c] (drop-while #(< % ma) c)) cols))))))", "user": "576df252e4b0979f8965156f"}, {"problem": 108, "code": "(fn [x & y]\n  (let [f (fn [a b] (loop [ms b]\n                      (let [m (first ms)]\n                        (cond\n                         (= m a) true\n                         (> m a) false\n                         :else (recur (drop 1 ms))))))]\n    (loop [as x]\n      (let [a (first as)]\n        (if (every? true? (map (partial f a) y)) a (recur (drop 1 as)))))))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [ss seqs]\n    (let [firsts (map first ss)]\n      (if (apply = firsts)\n        (first firsts)\n        (let [[ls & gs] (sort-by first ss)]\n          (recur (cons (rest ls) gs)))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 108, "code": "#(let [s (map first %&) \n       m (apply min s)]\n   (if (apply = s)\n     m\n     (recur (map (fn[[x & y :as c]](if (= x m) y c)) %&))))", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 108, "code": "(fn scommon [& seqs]\n  (if (some empty? seqs)\n    nil\n    (let [heads (map first seqs)\n          maxv (apply max heads)]\n      (if (every? #(= maxv %) heads)\n        maxv\n        (apply scommon (reduce (fn [newseqs oneseq]\n                            (conj newseqs (if (= maxv (first oneseq)) oneseq (rest oneseq))))\n                            []\n                            seqs))))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 108, "code": "(fn [& seqs]\n    (let [numseqs (count seqs)\n          take-min (fn [s]\n                     (let [srt (sort-by first (filter #(not (empty? %)) s))]\n                      (vector (ffirst srt) (cons (rest (first srt)) (rest srt)))))\n          lazy-min (fn lz\n                     ([s]\n                      (if (every? empty? s)\n                        nil\n                        (apply lz (take-min s))))\n                     ([r s] (lazy-seq (cons r (lz s)))))\n          mins (lazy-min seqs)\n          grps (partition-by identity mins)]\n      (ffirst (filter #(= numseqs (count %)) grps))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 108, "code": "(fn [& xxs]\n (letfn [(get-min-eq [colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [fsts (map first colls)]\n      (if (apply = fsts)\n        (first fsts)\n        (let [sorted-fst (sort-by first colls)\n              [skip-min flg]\n                (reduce\n                        (fn [[acc mn] b]\n                          (if (= mn (first b))\n                            [(conj acc (rest b)) mn]\n                            [(conj acc b) mn]))\n                        [[] (first (first sorted-fst))]\n                        sorted-fst)]\n          (if (not-any? empty? skip-min)\n            (get-min-eq skip-min)\n            nil))))))]\n  (get-min-eq xxs)))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 108, "code": "(fn lazy-search [& sorted-seqs]\n  (letfn [(mvs [f s] (->> s\n                          (filter #(not (empty? %)))\n                          (map first)\n                          (apply f)))]\n    (loop [sorted-seqs (for [s sorted-seqs] (drop-while #(not (integer? %)) s))\n           min-value (mvs min sorted-seqs)\n           max-value (mvs max sorted-seqs)]\n      (if (= min-value max-value) min-value\n          (let [sorted-seqs\n                (for [s sorted-seqs]\n                  (drop-while #(or (= min-value %) (not (integer? %))) s))]\n            (recur sorted-seqs (mvs min sorted-seqs) (mvs max sorted-seqs)))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 108, "code": "(fn [& secs]\n  (loop [secs secs]\n    (let [[f & r] (sort-by first secs)\n          v (first f)]\n      (if (every? #(= v (first %)) r) v\n        (recur (map #(drop-while (partial >= v) %) secs))))))", "user": "537e745ae4b06839e8705ea6"}, {"problem": 108, "code": "(fn f\n  [& xs]\n  (let [hs (map first xs)\n        m (apply max hs)]\n    (if (apply = hs)\n      m\n      (apply f (map (partial \n                     drop-while \n                     (partial > m))\n                    xs)))))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 108, "code": "(fn \n   ([c & d]\n      (let [i (first c) e (map #(drop-while (fn [x] (> i x)) %) d)]\n      (if (every? #(= i (first %)) e)\n        i\n        (recur (rest c) e )))))", "user": "5405885ee4b0addc1aec6668"}, {"problem": 108, "code": "#(let [f (fn [n s] (if (< (first s) n) (rest s) s))]\n    (loop [seqs %&]\n      (let [fs (map first seqs)\n            x (apply min fs)\n            y (apply max fs)]\n        (println fs)\n        (if (= x y) x\n          (recur (map (partial f y) seqs))))))", "user": "501d34f6e4b066e56b9d0b1e"}, {"problem": 108, "code": "(fn ls [& colls]\n  (let [a (apply (juxt = max) (map first colls))]\n  (if (a 0)\n    (ffirst colls)\n    (recur (map (partial drop-while (partial > (a 1))) colls)))))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 108, "code": "(fn f108-2 [& args]\n (->>\n  (map first args)\n  (set)\n  ((fn [x]\n     (if (= 1 (count x))\n       (first x)\n       (apply f108-2 (lazy-seq (cons ((comp rest first) (sort-by first args)) (rest (sort-by first args))))))))))", "user": "57bbc9bde4b05aa3c4741c31"}, {"problem": 108, "code": "(fn min-in-common\n  [& s]\n  (loop [candidate (apply max (map first s))\n         seqs s]\n    (if (= candidate (apply min (map first seqs)))\n        candidate\n        (let [new-seqs (map #(filter (fn [x] (>= x candidate)) %) seqs)]\n          (recur (apply max (map first new-seqs)) new-seqs)))))", "user": "58152157e4b0f478707a0631"}, {"problem": 108, "code": "(fn lazy-search\n  [& colls]\n  (loop [lists colls]\n    (let\n      [sorted (sort-by first (map seq lists))\n       n ((comp first first) sorted)\n       others (rest sorted)]\n      (if\n        (every?\n          #(= n %)\n          (map first\n               (map #(drop-while (fn [v] (< v n)) %) others)))\n        n\n        (if-let [xs (seq (rest (first sorted)))]\n          (recur (conj others xs))\n          :false)))))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 108, "code": "(fn [fl & args]\n  (if (= 0 (count args))\n     (apply min fl)\n     (letfn [(search [x ls]\n                     (cond (> (first ls) x) false\n                           (= (first ls) x) true\n                           :else (search x (rest ls))))\n             (look [ml mlist]\n                   (if (reduce #(and %1 %2) (map #(search (first ml) %) mlist)) (first ml) (look (rest ml) mlist)))]\n       (look fl args))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 108, "code": "(fn [& s]\n  (loop [s s]\n    (let [l #(< % (apply max (map first s)))\n          n (map #(drop-while l %) s)\n          f (map first n)]\n      (if (apply = f)\n        (first f)\n        (recur n)))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 108, "code": "(fn p-108 [& args]\n  (let [firsts-args (map first args)]\n    (if (apply = firsts-args)\n      (first firsts-args)\n      (let [max-first (apply max firsts-args)]\n        (recur (map #(drop-while (fn [v]\n                                   (> max-first v)) %)\n                    args))))))", "user": "5400e918e4b0de5c41848619"}, {"problem": 108, "code": "(fn [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 108, "code": "(fn find-lowest [& queues]\n  (if (apply = (map first queues))\n    (ffirst queues)\n    (let [sorted (sort-by first queues)]\n      (recur (cons (nfirst sorted) (rest sorted))))))", "user": "58247423e4b051871117bec5"}, {"problem": 108, "code": "(fn [& xs]\n    (if (apply = (map first xs))\n      (ffirst xs)\n      (let [smallest (apply min (map first xs))]\n        (recur (map #(if (= smallest (first %)) (drop 1 %) %) xs)))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 108, "code": "(fn ls [& seqs]\n  (let [sorted-seqs (sort #(compare (first %1) (first %2)) seqs)\n        lowest-seq (first sorted-seqs)\n        found? (apply = (map first sorted-seqs))]\n\n    (if found?\n      (first lowest-seq)\n      (recur (into [] (conj (rest sorted-seqs) (rest lowest-seq)))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 108, "code": "(fn [& args]\n  (letfn [(get-lowest-index [l]\n            (let [v (vec l)\n                  lowest (apply min v)]\n              (.indexOf v lowest)))\n          (get-rest-of-indx [indx args]\n            (map-indexed\n              (fn [idx itm]\n                (if (= idx indx) (rest itm) itm))\n              args))]\n  (loop [args args]\n    (let [firsts (map first args)]\n      (if (apply = firsts)\n        (first firsts)\n        (let [low-indx (get-lowest-index firsts)]\n          (recur (get-rest-of-indx low-indx args))))))))", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "54bfc203e4b0ed20f4ff6f08"}, {"problem": 108, "code": "(fn foo [coll & sequences]\n  (let [seqs (if (coll? (first coll)) coll (concat (list coll) sequences)) \n        current-min (apply min (map first seqs))]\n    (if (every? #(= current-min (first %)) seqs)\n      current-min\n      (foo (map (fn[c] (drop-while #(= % current-min) c)) seqs)))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 108, "code": "(fn\n  [s & ss]\n  (let [x (apply = (map (comp first #(drop-while (fn [x] (< x (first s))) %)) (into ss [s])))]\n    (if x\n    (first s)\n    (recur (rest s) ss))))", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 108, "code": "(fn p108\n  [& coll]\n  (let [macaca (apply = (map first coll))\n        maximus (apply max (map first coll))\n        ngentus (map (fn [m] (drop-while #(> maximus %) m)) coll)]\n    (if macaca\n      maximus\n      (apply p108 ngentus))))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 108, "code": "(fn s [c & colls]\n\n  (loop [c c]\n\n    (cond\n\n      (empty? c) nil\n\n      (empty? colls) (first c)\n\n      (every? #(some (hash-set (first c)) %) (map (fn [x] (take-while #(>= (first c) %) x)) colls)) (first c)\n\n      :else (recur (rest c)))))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 108, "code": "(fn find-smallest [& sorted-seqs]\n  (let [init   (repeat (count sorted-seqs) #{})\n        common (partial apply clojure.set/intersection)]\n    (loop [seqs sorted-seqs sets init]\n      (let [smallest (map first seqs)]\n        (if (empty? (common sets))\n          (recur (map #(if (<= (first %) (apply min smallest))\n                         (rest %)\n                         %)\n                      seqs)\n                 (map conj sets smallest))\n          (apply min (common sets)))))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 108, "code": "(fn [& args] ((fn first-in-all [xs] (let [m (apply min (map first xs))]\n                                      (if (every? #(= (first %) m) xs) m\n                                        (recur (map (fn [x] (drop-while #(= % m) x)) xs))))) args))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (loop [[fs & s] seqs] ;; Destructuring always works\n    (when-let [[f & r] (and (not-any? empty? s) fs)] ;; might fail on iter, i.e. no match possible\n      (let [checks (fn [seqs] (apply = f (map first seqs)))\n            newv (map (partial drop-while #(> f %)) s)] ;; Lazy, might not have checked when already firsts equal.\n        (if (or (checks s) (checks newv))\n          f\n          (recur (cons r newv)))))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 108, "code": "(fn [& c]\n     (let [fir (map first c) m (apply max fir)]\n       (if (apply = fir)\n         m\n         (recur (map #(drop-while (partial > m) %) c))\n         )))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 108, "code": "(fn [& xss]\n  (loop [xss xss]\n    (if (not-any? empty? xss)\n      (if (apply = (map first xss))\n        (ffirst xss)\n        (let [a (apply max (map first xss))]\n          (recur (for [xs xss]\n                   (drop-while #(< % a) xs))))))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 108, "code": "(fn d [& a](let [first-row (map first a)]\n(if \n(every? #(= (first first-row) %) first-row)\n(first first-row)\n(let [sorted (sort-by first a)]\n(apply d (lazy-seq (cons (rest (first sorted)) (rest sorted))))))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 108, "code": "(fn [& xs]\n  (let [mins (map first xs)]\n    (if (apply = mins)\n      (first mins)\n      (let [largest (apply max mins)\n            xs' (map (fn [x] (drop-while #(< % largest) x)) xs)]\n        (recur xs')))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [old-smallest (first (first colls))\n         old-colls colls]\n    (let [new-colls (map (fn [coll]\n                           (drop-while #(< % old-smallest) coll))\n                         old-colls)\n          first-columns (reduce #(conj %1 (first %2)) [] new-colls) \n          new-smallest (apply max first-columns)]\n      (if (= new-smallest old-smallest)\n        old-smallest\n        (recur new-smallest new-colls)))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 108, "code": "(fn lazy-min [& coll]\n  (let [fs (map first coll)\n        m (apply max fs)]\n       (if (apply = fs)\n        m\n        (apply lazy-min (map #(drop-while (partial > m) %) coll)))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 108, "code": "(fn g [& args]\n  (let [j (map first args)\n        m (apply max j)\n        ss (sort-by first args)\n        k (lazy-seq (cons (rest (first ss)) (rest ss)))] \n    (if (apply = j) (first j) (apply g k))))", "user": "57bd960fe4b05aa3c4741c52"}, {"problem": 108, "code": "(fn [& xs]\n  (let [f (map first xs)]\n    (if (apply = f)\n      (first f)\n      (let [m (reduce max f)\n            mf (fn [xs](drop-while #(< % m) xs))]\n\t      (recur (map mf xs))))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 108, "code": "(fn [& xss]\n  (let [firsts (map first xss)\n        largest-first (apply max firsts)\n        drop-too-small (fn [xs] (drop-while #(< % largest-first) xs))\n        xss* (map drop-too-small xss)\n        firsts* (map first xss*)]\n    (if (apply = largest-first firsts*)\n      largest-first\n      (recur xss*))))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 108, "code": "(fn [& c2] (loop [c2 c2] (let [c (map first c2) e (apply = c) m (apply max c)] (if e m (recur (map (partial drop-while #(< % m)) c2))))))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [firsts (map first seqs)\n        candidate (apply max firsts)]\n    (if (= (count (distinct firsts)) 1)\n      candidate\n      (recur (map #(drop-while (fn [e] (< e candidate)) %) seqs)))))", "user": "565b941ce4b068f2fe63dc07"}, {"problem": 108, "code": "(fn ls [& ss]\n  (first\n   (drop-while\n    (fn [xs]\n      (apply not= xs (map\n                      (fn [s]\n                        (some (fn [x] (when (>= x xs) x)) s))\n                      (rest ss))))\n    (first ss))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 108, "code": "(fn l-s [& s]\n  (let [sm (ffirst s)\n        dr (map (fn [xs] (drop-while #(< % sm) xs)) s)\n        frs (map first dr)]\n    (if (apply = frs)\n      sm\n      (apply l-s (cons (rest (first dr)) (rest dr))))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 108, "code": "(fn [& cols]\n  (let \n    [\n     recursor \n     (fn recurs [seqs]\n       (let\n         [\n           firsts (map first seqs),\n           maxval (apply max firsts),\n           step (fn [col] (lazy-seq (if (< (first col) maxval) (rest col) col)))\n          ]\n         (println (vector maxval firsts))\n         (if (every? #(= maxval %) firsts) maxval #(recurs (map step seqs)))\n         )\n       )\n     ]\n     (trampoline recursor cols)\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 108, "code": "(fn s [& xs]\n  (let [f first\n        a apply]\n    (if (->> xs (map f) (a =))\n      (f (f xs))\n      (let [l (f (f (sort-by f > xs)))]\n        (a s (map (partial remove #(> l %)) xs))))))", "user": "5458c74de4b01be26fd74623"}, {"problem": 108, "code": "(fn lazy-searching [& colls]\n  (let [cur-min (apply min (map first colls))]\n    (if (every? (partial = cur-min) (map first colls))\n      cur-min\n      (apply lazy-searching (map #(drop-while (partial = cur-min) %) colls)))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 108, "code": "(fn smallest-common [& vs]\n  (let [heads (map first vs)\n        tails (map rest vs)\n        gmin (apply min heads)]\n    (cond\n      (apply = heads)\n      (first heads)\n\n      (some empty? tails)\n      (first (first (filter #(empty? (rest %)) vs)))\n\n      :else\n      (apply smallest-common (map #(if (= (first %) gmin) (rest %) %) vs)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 108, "code": "(fn lazy-search [& colls]                            (let [hs (map first colls)                                 min-h (apply min hs)]                             (if (every? #(= % min-h) hs)                           min-h                                                (apply lazy-search                                          (map #(if (= (first %) min-h)                                (rest %)                                             %)                                                colls)))))", "user": "5895477fe4b00487982d527c"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [colls colls\n         n (first (first colls))]\n    (let [colls (reduce\n                  (fn [a b]\n                    (conj a (drop-while (fn [x] (< x n)) b)))\n                  []\n                  colls)\n          z (reduce (fn [a b]\n                      (let [x (first b)]\n                        (if (> x a) x a)))\n                    n\n                    colls)]\n      (if (= z n) n (recur colls z)))))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 108, "code": "(fn [& x]\n     (if (apply = (map first x))\n       (ffirst x)\n       (let [s (apply min (map first x))]\n         (recur (map #(if (= s (first %)) (drop 1 %) %) x))\n         )))", "user": "58a44a14e4b01a0c0b2328f2"}, {"problem": 108, "code": "(fn [& args]\n    (loop [seqs args]\n      (let [firsts (map first seqs)]\n        (if (apply = firsts)\n          (first firsts)\n          (let [[[smallest & rest-seq] & others] (sort-by first seqs)]\n            (recur (conj\n                    others\n                    rest-seq)))))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 108, "code": "(fn lazy-searching [& seqs]\n  (let [vals (map first seqs)\n        minval (apply min vals)\n        newseqs (map (fn [s]\n                       (if (= (first s) minval) (rest s) s)) seqs)]\n    (if (apply = vals) (first vals)\n        ;; not equal, increment seq with smallest head and recur)\n        (recur newseqs))\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 108, "code": "(fn [& xxs]\n  (let [[v-min v-max] (first (apply map (juxt min max) xxs))]\n    (if (= v-min v-max)\n      v-min\n      (recur (map (fn [xs]\n                    (drop-while #(< % v-max) xs)) xxs)))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 108, "code": "(fn [coll & more]\n  (loop [coll coll\n           more more]\n      (let [x (first coll)\n            next-more (map #(drop-while (partial > x) %) more)]\n        (if (every? #(= x (first %)) next-more)\n          x\n          (recur (rest coll) next-more)))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 108, "code": "(fn lazy-search\n  [& args]\n  (let [pot-smallest (ffirst args)\n        new-args (map #(drop-while (fn [a] (< a pot-smallest)) %) args)]\n    (cond\n      (some empty? args) \"None\"\n      (= 1 (count (into #{} (map first new-args)))) pot-smallest\n      :else (apply lazy-search (concat [(rest (first new-args))]\n                               (rest new-args))))))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 108, "code": "(fn lazy-search [& args]\n  (loop [ptrs (repeat (count args) 0)]\n    (let [vs (map nth args ptrs)]\n      (if (apply = vs)\n        (first vs)\n        (let [max-v (apply max vs)]\n          (recur (map (comp count (partial take-while (partial > max-v))) args)))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 108, "code": "(fn lazy-searching [& colls]\n     (if (= 1 (count colls))\n       (first (first colls))\n       (let [heads (map first colls)\n             largest (apply max heads)]\n         (if (apply = heads)\n           largest\n           (recur (map\n                    (fn [c]\n                      (drop-while #(< % largest) c)) colls))))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 108, "code": "(fn lc [& args]\n  (let [firsts     (map first args)\n        least      (apply min firsts)\n        drop-least #(if (= least (first %)) (rest %) %)]\n    (if (apply = firsts) least (apply lc (map drop-least args)))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 108, "code": "(fn lazy-search [& sorted-seqs]\n  (let [heads (map first sorted-seqs) \n        heads-max (apply max heads)]\n    (if (apply = heads)\n      heads-max\n      (letfn [(skip-smaller [seq]\n                (drop-while #(< % heads-max) seq))]\n        (recur (map skip-smaller sorted-seqs))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [firsts (map first seqs)\n          min-first (apply min firsts)]\n      (if (apply = firsts)\n        min-first\n        (recur\n          (map\n            #(if (= min-first (first %))\n               (rest %)\n               %)\n            seqs))))))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 108, "code": "(fn smallest-common [c & rest]\n  (let [coll (cons c  rest)]\n    (loop [coll coll]\n      (let [all-equal (apply = (map first coll))\n            highest (reduce (fn [a b] (if (> a b) a b)) (map first coll))\n            dropper (fn [c] (drop-while #(< % highest) c))\n            next-coll (map dropper coll)]\n        (if all-equal\n          (first (first coll))\n          (recur next-coll))))))", "user": "56f4cedce4b046a417f92063"}, {"problem": 108, "code": "(fn lazy-search-min\n  [& seqs]\n  (let\n    [sorted-seqs (sort-by first seqs)\n     current-min (first (first sorted-seqs))]\n    (if\n      (every? #(= current-min (first %)) sorted-seqs)\n      current-min\n      (apply lazy-search-min (cons (rest (first sorted-seqs)) (rest sorted-seqs))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 108, "code": "(fn search [& lists]\n  (loop\n    [lists lists]\n    (let\n      [firsts (map first lists)\n       min-firsts (reduce min firsts)]\n      (if\n        (apply = firsts)\n        (first firsts)\n        (recur (map\n                 (fn [li]\n                   (if\n                     (= min-firsts (first li))\n                     (rest li)\n                     li))\n                 lists))))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 108, "code": "(letfn\n    [(merge-sorted\n       ([xs] xs)\n       ([[head1 & tail1 :as xs1] [head2 & tail2 :as xs2]]\n         (cond\n           (some empty? [xs1 xs2]) (concat xs1 xs2)\n           (< head1 head2) (lazy-seq (cons head1 (merge-sorted tail1 xs2)))\n           :else (lazy-seq (cons head2 (merge-sorted xs1 tail2)))))\n       ([xs1 xs2 & args]\n         (reduce merge-sorted (concat [xs1 xs2] args))))]\n    (fn [& sxs]\n      (let [nseq (count sxs)]\n        (->> sxs\n             (apply merge-sorted)\n             (partition-by identity)\n             (filter #(= nseq (count %)))\n             (first)\n             (first)))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 108, "code": "(fn n\n  [& args]\n  (let [ls (sort-by first args)]\n    (if (apply = (map first ls))\n      (first (first ls))\n      (apply n (conj (rest ls) (rest (first ls)))))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 108, "code": "(fn [& seqs] (let [m (apply max (map first seqs))] (if (not-any? #(< (first %) m) seqs) m (recur (map #(drop-while (fn [e] (< e m)) %) seqs)))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 108, "code": "(fn [& xs]\n  (let \n    [firsts (map first xs) \n     maxfirst (apply max firsts)] \n    (if \n      (= 1 (count (into #{} firsts))) \n      maxfirst \n      (recur (map (fn [l] (drop-while #(< % maxfirst) l)) xs)))))", "user": "56449e4de4b0284900eef5f9"}, {"problem": 108, "code": "; switch to a tail-call based loop\n(fn [& ss] \n  (let [sorted (sort-by first ss)]\n    (if (apply = (map first sorted)) \n      (ffirst sorted)\n      (recur (cons (nfirst sorted) (rest sorted))))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 108, "code": "(fn [& args]\n   (let [ls (sort-by first < args)]\n     (if (apply = (reduce #(conj % (first %2)) [] ls))\n       (first (first args))\n       (recur (conj (rest ls) (rest (first ls)))))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 108, "code": "(fn [& sequences]\n  (let [ sorted-seqs          (sort-by first sequences)\n         smallest-seq         (first sorted-seqs)\n         smallest             (first smallest-seq)\n         first-elements       (map first sorted-seqs)\n         first-elements-match (= 1 (count (distinct first-elements)))\n       ]\n  (if first-elements-match\n    smallest\n    (recur (cons (drop 1 smallest-seq)\n                 (drop 1 sorted-seqs))))))", "user": "4f29d9abe4b0d6649770a034"}, {"problem": 108, "code": "(fn sol [& seqs]\n  (cond\n    (empty? seqs) nil\n    (some empty? seqs) (apply sol (filter not-empty seqs))\n    :else (let [\n                heads (map first seqs)\n                max' (apply max heads)]\n               (if (= 1 (count (distinct heads)))\n                 (first heads)\n                 (apply sol (map #(filter (fn [x] (>= x max')) %) seqs))))))", "user": "5901158de4b0438e51c2d039"}, {"problem": 108, "code": "(fn lazy-search [& coll]\n  (let [min-f (apply min (map first coll))]\n    (->>\n     (group-by #(= (first %) min-f) coll)\n     ((fn [res-map]\n        (if (= 1 (count (keys res-map)))\n          min-f\n\n          (apply lazy-search (apply conj (get res-map false)\n                                    (map rest (get res-map true))))))))))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 108, "code": "(fn lazy-searching [& colls]\n  (let [mins (map first colls)\n        outlier (apply min mins)]\n    (if (apply = mins)\n      (first mins)\n      (recur (map (fn [[x & xs :as c]] (if (= outlier x) xs c)) colls)))))", "user": "58ffac9de4b0438e51c2cffd"}, {"problem": 108, "code": "#(\n    (fn [s]\n      (let [m (sort-by first (for [l s]\n                               [(first l) l]\n                               ))\n            f (map first m)]\n        (if (apply = f) (first f)\n                        (recur (conj (map second (rest m)) (rest (second (first m)))))))\n      ) %&\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 108, "code": "(fn search-lazily [& colls]\n  (let [search (fn [num]\n                 (fn [coll]\n                   (let [n (last (take-while #(<= % num) coll))]\n                     (if (= n num) num nil))))\n        ref-coll (first colls)\n        rest-colls (rest colls)]\n    (loop [rem ref-coll, res nil]\n      (if (or (empty? rem) (not (nil? res)))\n        res\n        (recur (rest rem)\n               (if (some nil? (map (search (first rem)) rest-colls))\n                 nil\n                 (first rem)))))))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 108, "code": "(fn ([& n] \n  (first (drop-while seq? (iterate \n    (fn [xs] \n      (let[xsf (map first xs)] \n        (if (apply = xsf) \n          (first xsf) \n          (let[min-xsf (apply min xsf)] \n            (map #(if(= %1 min-xsf) %2 (cons %1 %2)) xsf (map rest xs)))))) n)))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 108, "code": "(fn ! [& lists]\n    (let [heads (map first lists)]\n      (if (apply = heads)\n        (first heads)\n        (let [min-head (apply min heads)]\n          (apply ! (map (fn [a-list]\n                    (if (= (first a-list) min-head)\n                      (rest a-list)\n                      a-list))\n                  lists))))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "592518e8e4b072a2710fce67"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [ss seqs]\n    (cond (not-every? seq ss)\n          nil\n          (apply = (map first ss))\n          (first (first ss))\n          :else\n          (let [sorted (sort-by first ss)]\n            (recur (cons (rest (first sorted))\n                         (rest sorted)))))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 108, "code": "(fn [& c]\n          (let [r (map first c)\n                m (apply max r)]\n              (if (apply = r)\n                m\n                (recur (map (fn [s] (drop-while #(< % m) s)) c)))))", "user": "577202d2e4b0979f896515c0"}, {"problem": 108, "code": "(fn \n  ([s] (first s))\n  ([s1 s2]\n   (let [[a & r1] s1\n         [b & r2] s2]\n     (cond\n       (= a b) a\n       (< a b) (recur r1 s2)\n       (> a b) (recur s1 r2)\n       :else '())))\n  ([s1 s2 s3]\n   (let [[a & r1] s1\n         [b & r2] s2\n         [c & r3] s3]\n     (cond\n       (= a b c) a\n       (<= a b c) (recur r1 s2 s3)\n       (<= c b a) (recur s1 s2 r3)\n       (<= b a c) (recur s1 r2 s3)\n       (<= b c a) (recur s1 r2 s2)\n       (<= a c b) (recur r1 s2 s3)\n       :else '()))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "59251947e4b072a2710fce69"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "592518cde4b072a2710fce66"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 108, "code": "(fn ls [fs & ss]\n    (some (fn [x] (if (every? #(some (partial = x) (take-while (partial >= x) %)) ss) x)) fs))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 108, "code": "(fn search [a & bs]\n  (when-let [n (first a)]\n    (let [f (fn f [b]\n              (let [b0 (first b)]\n                (cond\n                  (nil? b0) false\n                  (< n b0) false\n                  (= n b0) true\n                  :else (f (rest b))\n                )\n              )\n            )]\n      (if (every? f bs)\n        n\n        (apply (partial search (rest a)) bs)\n      )\n    )\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 108, "code": "(fn __ [& ses]\n  (if (apply = (map first ses))\n      (first (first ses))\n      (let [\n            minn (apply min (map first ses))\n            step (reduce\n                   (fn [acc item]\n                     (if (= minn (first item))\n                       (cons (rest item) acc)\n                       (cons item acc) ))\n                   ()\n                   ses)\n            ]\n        (recur step))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 108, "code": "(fn [& xs]\n  (let [max_1 (apply max (map first xs))\n         xs0      (map (fn [ss] (drop-while #(< % max_1) ss)) xs)]\n    (if (apply = (map first xs0))\n        max_1\n        (recur xs0))))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 108, "code": "(fn [r & rs]\n  (letfn [(contains-num [n r'] (= n (first (drop-while #(< % n) r'))))]\n    (first (drop-while (fn [n] (not (every? #(contains-num n %) rs))) r))))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 108, "code": "#(if (apply = (map first %&))\n  (first (first %&))\n  (let [[f & r] (sort-by first %&)]\n    (recur (cons (next f) r))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (if (= (count seqs) 1)\n    (ffirst seqs)\n    (loop [seqs seqs]\n      (do (println (map first seqs))\n          (if (apply = (map first seqs))\n            (ffirst seqs)\n            (recur (map #(drop-while\n                           (partial > (first (next (first seqs)))) %)\n                         seqs)))))))", "user": "587ee260e4b052da650a6353"}, {"problem": 108, "code": "(fn f [& s] \n  (if (apply = (map first s))\n    (ffirst s)\n    (apply f (apply concat ((juxt (comp list rest first) rest) (sort-by first s))))))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 108, "code": "(fn low[& sx] (\n                 if (apply = (map first sx))\n                 (first (first sx))\n                 (apply low (sort-by first (conj (rest sx) (rest (first sx)))))\n                 ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 108, "code": "(fn my-min [& cols]\n  (loop [cols cols]\n    (let [firsts (map first cols)\n          min-val (apply min firsts)\n          rests (map #(if (= min-val (first %)) (rest %) %) cols)]\n      (if (apply = firsts) min-val (recur rests)))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 108, "code": "(fn min-in-common [& colls]\n  (let [firsts (map first colls)\n        candidate (apply min firsts)]\n    (if (apply = firsts)\n      candidate\n      (let [new-colls\n            (map (fn [coll]\n                   (if (not= candidate (first coll))\n                     coll\n                     (rest coll))) colls)]\n        (apply min-in-common new-colls)))))", "user": "4fe49706e4b0e8f79898feb7"}, {"problem": 108, "code": "(fn [& colls]\n  (when (not-any? empty? colls)\n    (if (apply = (map first colls))\n      (ffirst colls)\n      (let [[[_ & least] & others] (sort-by first colls)]\n        (recur (cons least others))))))\n\n;; golfed:\n#_(fn [& c]\n  (let [f first\n        [[_ & l] & o] (sort-by f c)]\n    (if (apply = (map f c))\n      (f (f c))\n         (recur (cons l o)))))", "user": "5297dcc5e4b02ebb4ef75047"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (let [firsts (->> seqs \n                    (map first)\n                    (into #{}))]\n    (if (= (count firsts) 1)\n      (first firsts)\n      (let [new-seqs (sort-by first seqs)]\n        (if (empty? (first new-seqs))\n          nil\n          (apply lazy-search (cons (rest (first new-seqs)) (rest new-seqs))))))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 108, "code": "(fn [& colls]\n  (let [coll (first colls) colls (rest colls)]\n    (loop [coll coll]\n      (let [item (first coll)]\n        (if (every? \n            (fn [coll] (= (first (drop-while #(< % item) coll)) item))\n            colls)\n          item\n          (recur (rest coll))\n        )\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 108, "code": "(fn lazy-search\n\t[& r]\n\t(loop [t 0]\n\t\t(let [mins (map (fn[p](take 1 (filter #(< t %1) p))) r)\n\t\t\tsame (reduce clojure.set/intersection (map set mins))]\n\t\t\t(if (empty? same)\n\t\t\t\t(recur (apply min (flatten mins)))\n\t\t\t\t(first same)))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 108, "code": "(fn min-seq [& s]\n  (letfn [(common [[s1 & s]] \n    (loop [x (first s1) r (rest s1)] \n      (if (every? #(some #{x} %) s)\n      x\n      (if-not (first r) nil (recur (first r) (rest r)))\n      )\n  ))]\n  (loop [current (partition 1 (map #(first %) s))\n         mx (apply max (flatten current))\n         r (reduce (fn [a b] (conj a (rest b))) [] s)]\n    (if-let [cmn (common current)]\n      cmn\n      (recur (map #(conj %1 (first %2)) current r) \n             (apply max (flatten current)) \n             (reduce (fn [a b] (if (<=(first b) mx)  (conj a (rest b)) (conj a b) )  ) [] r) )\n    )\n  ))\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 108, "code": "(fn [& lists]\n  (loop [l lists]\n    (let [firsts (map first l)         \n          lowest (apply min firsts)]\n      (if (apply = firsts)\n        lowest\n        (recur (map #(if (= lowest (first %))\n                         (rest %)\n                        %)\n                     l))\n        )\n      ))\n)", "user": "54227fc6e4b01498b1a71ac0"}, {"problem": 108, "code": "(fn shared-min [& xs]\n   (let [ms (map first xs)\n         m (apply min ms)]\n     (if (apply = ms)\n         m\n         (apply shared-min (map #(drop-while (partial >= m) %) xs)))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 108, "code": "(letfn\n  [(sorted-contains [v xs]\n     (cond \n       (empty? xs) false\n       (< v (first xs)) false\n       (> v (first xs)) (recur v (rest xs))\n       (= v (first xs)) v))\n   (lazy-search [first-seq & other-seqs]\n     (first (filter \n              (fn [v] \n                (every? identity\n                        (map (partial sorted-contains v) other-seqs)))\n              first-seq)))]\n  lazy-search)", "user": "4ff769bce4b0678c553fc38f"}, {"problem": 108, "code": "(fn ls [& ss]\n  (let [seq-heads (map first ss)\n        max-val (apply max seq-heads)]\n    (if (apply = seq-heads)\n      (first seq-heads)\n      (apply ls (map #(if (= max-val (first %))\n                               %\n                               (rest %))\n                            ss)))))", "user": "56bb652ae4b0f26550335953"}, {"problem": 108, "code": "(fn [& ys]\n  (loop [xs (vec ys)]\n    (if (apply == (map first xs))\n      (ffirst xs)\n      (recur\n        (update-in xs\n                   [(apply min-key\n                           #(first (get xs %))\n                           (range (count xs)))]\n                   rest)))))", "user": "559057c4e4b027778923766e"}, {"problem": 108, "code": "(fn lazy-search [& colls] (if (= 1 (count colls)) (first (first colls)) \n(let [heads (map first colls) largest (apply max heads)] (if (apply = \nheads) largest (recur (map (fn [c] (drop-while #(< % largest) c)) \ncolls))))))", "user": "59358f74e4b04f87174def52"}, {"problem": 108, "code": "(fn smallest [ & seqs ]\n  (if (apply = (map first seqs))\n    (first (first seqs))\n    (let [mx (apply max (map first seqs))\n          remaining (for [s seqs] (drop-while #(< % mx) s))\n          ]\n      (apply smallest remaining)\n      )\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "59ea85e4e4b0249b72820767"}, {"problem": 108, "code": "(fn f [& xs]\n    (let [fvs (flatten (map #(take 1 %) xs))                ;; First Values of ALL seqs\n          largest (apply max fvs)\n          action (map #(compare largest %) fvs)\n          res (map #(drop %1 %2) action xs)\n          ]\n      (if (apply = fvs)\n        (first fvs)\n        (recur res)\n        )))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (if (apply = (map first seqs))\n      (ffirst seqs)\n      (let [[h & t] (sort-by first seqs)]\n        (recur (cons (rest h) t))))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 108, "code": "(fn lowest-common [& coll]\n  (if (empty? coll)\n    nil\n    (loop [seqs coll]\n      (cond\n        (some empty? seqs) nil\n        (apply = (map first seqs)) (first (first seqs))\n        :else (let [x (apply max (map first seqs))\n                    nseqs (map (partial drop-while (partial > x)) seqs)]\n                (recur nseqs))))))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 108, "code": "(fn [& args]\n  (let [coll (map first args)\n        max-value (apply max coll)]\n    (if (apply = coll)\n      max-value\n      (recur (map (fn [c] (drop-while #(< % max-value) c)) args)))))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 108, "code": "(fn f\n  [& c]\n  (let [fe (map first c)\n        col (sort-by first c)]\n    (if (every? #(= (first fe) %) fe)\n      (first fe)\n      (recur (cons (rest (first col)) (rest col))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 108, "code": "(fn __ [& seqs]\n  (loop [rseqs seqs]\n    (cond\n      (empty? rseqs) nil\n      (some empty? rseqs) nil\n      :else \n      (let [first_items (map first rseqs)\n            min_item (apply min first_items)\n            sets (set first_items)]\n        (if (= 1 (count sets)) min_item\n          (recur (map #(drop-while #{min_item} %) rseqs)))))))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 108, "code": "(fn[& args] ((fn searchLists [firstList otherLists totalLists]\n (if (= 1 totalLists)\n     (first firstList)\n      (let [itemToSearchFor (first firstList)\n       foundList (filter #((fn isItemInSortedList [item sortedList] \n  \t\t\t\t\t\t\t(if (empty? sortedList) false\n    \t\t\t\t\t\t(do \n      \t\t\t\t\t\t(let [itemToCompare (first sortedList)]\n        \t\t\t\t\t(if (= item itemToCompare) true\n          \t\t\t\t\t(if (> itemToCompare item) false\n          \t\t\t\t\t(isItemInSortedList item (rest sortedList)))))))) itemToSearchFor %) otherLists)]\n       (if (= totalLists (inc (count foundList)))\n           itemToSearchFor\n           (searchLists (rest firstList) otherLists totalLists))\n ))) (first args) (rest args) (count args)))", "user": "571172ece4b09c608db70446"}, {"problem": 108, "code": "(fn [& cols]\n  (if (apply = (map first cols))\n    (ffirst cols)\n    (let [lowest (apply min (map first cols))\n          grouped (group-by (comp (partial = lowest) first) cols)]\n      (recur (concat (grouped false)\n                     (map rest (grouped true)))))))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 108, "code": "(fn [& seqs]\n(loop [xss seqs]\n (let\n  [hs (map first xss)]\n  (if (apply = hs)\n   (first hs)\n   (recur\n    (map\n     (partial\n      drop-while\n      #(>\n        (apply max hs)\n        %))\n     xss))))))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 108, "code": "(fn ls [& xss]\n    (let [firsts (map first xss)]\n      (if (apply = firsts)\n        (first firsts)\n        (let [m (apply max firsts)]\n          (apply ls (map #(drop-while (partial > m) %) xss))))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 108, "code": "#(let [[[x & r] & cs] (sort-by first %&)]\n   (if (apply = x (map first cs))\n     x\n     (recur (cons r cs))))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n(apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 108, "code": "(letfn [(get-max [xss]\n          (apply max (map first xss)))\n        (iterate-forward [m xss]\n          (map (fn [xs] (drop-while (fn [x] (< x m)) xs)) xss))\n        (all-head-same [v xss]\n          (apply = (map first xss)))]\n  (fn lazy-searching [& xss]\n    (let [m (get-max xss)]\n      (if (all-head-same m xss)\n          m\n          (apply lazy-searching (iterate-forward m xss))))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 108, "code": "(fn [& cols]\n    (let [[min-h max-h] (->> cols (apply map (juxt min max)) first)\n          no-max #(< % max-h)]\n      (if (= min-h max-h) min-h\n        (recur (map #(drop-while no-max %) cols)))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 108, "code": "(fn lazys [& xss]\n   (letfn [\n      (nexti [t b xs ] \n        (if (< (nth xs b) t)\n           (recur t (inc b) xs) \n           [(first (drop b xs)) b]\n        ) )\n\n      (lsr [t inds k c xss]\n           (lazy-seq \n        (let [t1 (first (drop (inds k) (nth xss k)))]\n           (cond (> c (count inds))\n                   [t ] \n                 (> t1 t)\n                    (cons t (lsr t1 inds 0 0 xss))\n                 (= t1 t)\n                    (cons t (lsr t inds \n                              (mod (inc k) (count inds)) (inc c) xss ))\n                 :else\n                    (cons t (lsr (first (nexti t (inds k) (nth xss k) ))\n                      (assoc inds k\n                             (second (nexti t (inds k) (nth xss k))))\n                            0 0 xss) )\n          )\n        )\n       )\n     )]\n  (if (= 1 (count xss)) \n    (first (first xss))\n   (last (lsr (first (nth xss 0) )\n        (vec (cons 1 (repeat (dec (count xss )) 0)) )\n        (if (> (count xss) 1) 1 0 ) 0 xss )\n  ) ))\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 108, "code": "(fn [ & ss]\n (let [mins (set (map first ss))]\n   (if (= (count mins) 1)\n     (first mins)\n     (recur\n       (map\n         (fn [x] (filter #(> % (apply min mins)) x))\n         ss)))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 108, "code": "(fn [& sqs]\n    (let [all_first_equal? (fn [xs] (apply = (map first xs)))\n          min_first (fn [xs] (apply min (map first xs)))\n          remove_first (fn [x] \n                           (fn [xs] (if (= x (first xs)) (rest xs) xs)))]\n          (if (empty? sqs)\n              nil\n              (loop [xs sqs]\n                    (if (all_first_equal? xs)\n                        (first (first xs))\n                        (recur (map (remove_first (min_first xs)) xs)))))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 108, "code": "(fn [& cols]\n  (let [fs (map first cols) m (apply min fs)]\n    (if (every? #(= m %) fs) m\n      (recur (map (fn [col] (drop-while #(= m %) col)) cols)))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 108, "code": "(fn [& xs] (let [hs (map first xs)]\n  (if (apply = hs)\n      (first hs)\n      (recur (map #(drop-while (fn [e] (< e (apply max hs))) %) xs)))))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 108, "code": "(fn [& args]\n  (letfn [(trim [coll baseline]\n            (drop-while #(< % baseline) coll))\n          (check [[x & xs] baseline]\n            (cond\n              (nil? x) :empty\n              (= x baseline) :ok\n              :else :found-greater))]\n    (loop [[[baseline & main-rest :as main] & others] args]\n      (let [trimmed (mapv trim others (repeat baseline))\n            result (reduce #(if (not= %1 :ok) %1 (check %2 baseline)) :ok trimmed)]\n        (cond\n          (= result :empty) nil\n          (= result :ok) baseline\n          :else (recur (cons main-rest trimmed)))))))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 108, "code": "(fn f [& seqs] \n  (let [first-els (map first seqs)\n        smallest-first (apply min first-els)] \n       (if (every? #(= % smallest-first) first-els)\n           smallest-first\n           (apply f (map #(if (not= smallest-first (first %)) % (rest %)) seqs)))))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 108, "code": "(fn min-common [& xs]\n  (let [firsts (into #{} (map first xs))\n        min-first (apply min firsts)]\n    (if (= (count firsts) 1)\n      (first firsts)\n      (apply min-common (map (fn [x] (drop-while #(= min-first %) x)) xs)))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 108, "code": "(fn least-common-number [& seqs]\n  (let [firsts (map first seqs)\n        least (apply min firsts)]\n    (if (every? #(= least %) firsts)\n      least\n      (apply least-common-number (map (fn [s] (drop-while #(= least %) s)) seqs)))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 108, "code": "(fn lazy-search\n  [& coll]\n  (loop [xss coll]\n    (let [c (map first xss)\n          ma (apply max c)\n          mi (apply min c)]\n      (letfn [(filter-min [n xs]\n                (filter #(>= % n) xs))]\n        (if (= ma mi)\n          ma\n          (recur (map #(filter-min ma %) xss)))))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 108, "code": "(fn lazy-search [& colls] ;; NOT MY SOLUTION!\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 108, "code": "(fn [& xs]\n   (loop [ys xs]\n      (let [r (map first ys)]\n         (if (apply = r)\n            (first r)\n            (recur (map (fn [y] (drop-while #(< % (apply max r)) y)) ys))))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 108, "code": "(fn\n    [& args]\n    (loop [seqs args]\n      (if (apply = (map first seqs))\n        (ffirst seqs)\n        (let [new-seqs (sort-by first\n                                (cons (drop 1 (first seqs))\n                                      (rest seqs)))]\n          (recur new-seqs)))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 108, "code": "(fn [& cs]\n  (loop [cs cs]\n    (let [nums (map first cs)\n          max (apply max nums)]\n      (if (apply = nums)\n        (first nums)\n        (recur (map (fn [c]\n                      (drop-while #(< % max) c))\n                    cs) )))))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 108, "code": "(fn small-number [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [map-first (map first colls)\n          gross (apply max map-first)]\n      (if (apply = map-first)\n        gross\n        (recur (map (fn [xs] (drop-while #(< % gross) xs)) colls))))))", "user": "58b989dbe4b0888cdc949ccd"}, {"problem": 108, "code": "(fn lazy-search\n  [& sequences]\n  (loop [seqs sequences]\n    (let [firsts (map first seqs)\n          candidate (apply max firsts)]\n      (cond (some nil? firsts) nil\n            (every? #(= candidate %) firsts) candidate\n            :else (recur (map (partial drop-while #(< % candidate)) seqs))))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 108, "code": "(fn [x & a]\n  (loop [l x o a]\n    (let [m (first l)\n          w (map #(drop-while (partial > m) %) o)]\n          (if (every? #(= m %) (map first w))\n            m\n            (recur (rest l) w)))))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 108, "code": "(fn lazy-search [& v]\n  (if (empty? v)\n    nil\n    (loop [v v]\n      (if (reduce #(or %1 (empty? %2)) false v)\n        nil\n        (let [seq-first (reduce #(conj %1 (first %2)) [] v)]\n          (if (apply = seq-first)\n            (first seq-first)\n            (let [biggest (reduce max seq-first)]\n              (recur (reduce\n                      #(if (> biggest (first %2))\n                         (conj %1 (rest %2))\n                         (conj %1 %2))\n                         []\n                         v)))))))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 108, "code": "(fn [& colls]\n  (let [r (map first colls)\n        m (apply max r)]\n    (if (apply = r)\n      m\n      (recur (map #(drop-while (partial > m) %1) colls)))))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 108, "code": "(fn lazy_search[& args]\n  (loop [ss args]\n    (let [m (apply min (map first ss))]\n      (if (every? #(= m (first %)) ss)\n        m\n        (recur (map (fn [s] (drop-while #(= m %) s)) ss))))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 108, "code": "(fn [& a]\n  (let [sm (apply min (map first a))]\n    (if (apply = (cons sm (map first a)))\n      sm\n      (recur (map #(drop-while (partial >= sm) %) a)))))", "user": "5a527beee4b05d388ecb6bfe"}, {"problem": 108, "code": "(fn [& colls]\n        (if (some empty? colls) nil\n            (let [heads \n                  (into [] (map first colls))]\n\n              (if (apply = heads)\n                (first heads)\n                (let [pivot \n                      (apply min heads)\n                      \n                      trim \n                      (fn [coll]\n                             (if (= pivot (first coll)) \n                               (rest coll)  coll))]\n                  \n                  (recur (map trim colls)))))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 108, "code": "(fn [& seqs] (let [\n  heads (map first seqs)\n  biggest (apply max heads )\n  tailfilter #(drop-while (partial > biggest) % )\n  tails (map tailfilter seqs)\n  ]\n  (if (apply = heads ) (first heads) (recur tails))))\n\n;; PS\n;; i'm happy that my solution more legible than provided samples,\n;; but i want to study volatile's solution to understand why it \n;; performs better", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 108, "code": "(fn ff\n  ([xs] (first xs))\n  ([xs ys] \n          (cond\n              (< (first xs) (first ys)) (ff (lazy-seq (next xs)) (lazy-seq ys))\n              (> (first xs) (first ys)) (ff (lazy-seq xs) (lazy-seq (next ys)))\n              :else (first xs)))\n  ([xs ys zs] (let [f (ff xs ys) s (ff ys zs)] \n                  (cond\n                    (< f s) (ff (last (split-with (partial >= f) xs)) (last (split-with (partial >= f) ys)) zs)\n                    (> f s) (ff xs (last (split-with (partial >= s) ys)) (last (split-with (partial >= s) zs)))\n                    :else f)\n    )\n  )\n )", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 108, "code": "(fn [& seqs]\n  (letfn [(lowest-common-elem [seqs]\n            (let [tups (for [s seqs] [(first s) s])]\n              (if (apply = (map first tups))\n                (->> tups first first)\n                (let [sort-seqs (map second (sort #(> (first %1) (first %2)) tups))\n                      max-seq (-> sort-seqs first)\n                      min-seq (-> sort-seqs last)\n                      rest-seqs (if (> (count sort-seqs) 2 ) (drop 1 (drop-last sort-seqs)) [])]\n                  (lowest-common-elem (conj rest-seqs max-seq (rest min-seq)))))))]\n    (lowest-common-elem seqs)))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (loop [main-coll (first colls)\n         current-number (first main-coll)\n         other-colls (rest colls)]\n    (if (apply = current-number\n          (map (fn [c] (first (drop-while #(< % current-number) c))) other-colls))\n      current-number\n      (recur\n        (rest main-coll)\n        (first (rest main-coll))\n        (map (fn [c] (drop-while #(< % current-number) c)) other-colls)))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 108, "code": "(fn ls\n  [& s]\n  (let [firsts (map first s)\n        min-firsts (apply min firsts)\n        others (map #(if (= min-firsts (first %)) (rest %) %) s)]\n    (if (apply = firsts)\n      (first (first s))\n      (apply ls others))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 108, "code": "(fn [& colls]\n  (loop [colls colls]\n    (let [heads (map first colls)]\n      (if (apply == heads)\n        (first heads)\n        (let [smallest (apply min heads)\n              colls-minus-smallest (map (partial drop-while #{smallest}) colls)]\n          (recur colls-minus-smallest))))))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 108, "code": "(fn [& body]\n  (loop [seqs body]\n    (if (apply = (map first seqs))\n      (first (first seqs))\n      (let [sorted (sort-by first seqs)]\n        (recur (cons (rest (first sorted))\n                     (rest sorted)))))))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 108, "code": "(fn [& [coll & colls]]\n  (letfn [(in-coll? [n c] (->> c\n                               (take-while (partial >= n))\n                               (filter #{n})\n                               seq))\n          (in-colls? [n] (every? (partial in-coll? n) colls))]\n    (first (if-not colls\n             coll\n             (filter in-colls? coll)))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 108, "code": "(fn seek-smallest [& ss]\n  (loop [p (first (first ss)) ks ss]\n    (if (every? #(== p %) (map first ks))\n      p\n      (let [a (apply max (map first ks))]\n        (recur a (map (fn [s] (drop-while #(< % a) s)) ks))))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 108, "code": "; not very efficient :(\n(fn [coll & colls]\n  (first \n    (filter \n      (fn [x]\n        (every?\n          (fn [c] (and (not (empty? c)) (= x (first c))))\n          (map (fn [c] (drop-while #(< % x) c)) colls)))\n      coll)))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 108, "code": "(fn\n [& cols]\n (if\n  (apply = (map first cols))\n  (first (first cols))\n  (let\n   [max-val (apply max (map first cols))]\n   (recur (map (fn [x] (if (> max-val (first x)) (rest x) x)) cols)))))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 108, "code": "(fn my-lazy-search\n  [c & colls]\n  (if (not-empty colls)\n    (some #(if (not (apply distinct? %))\n             (ffirst (filter (fn [x] (= (inc (count colls)) (second x)))\n                             (frequencies %)))\n             false)\n          (map #(conj (for [candidate-col colls x candidate-col :while (<= x %)] x) %)\n               c))\n    (apply min c))\n  )", "user": "59f44189e4b0966464fe6aab"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5acb137ee4b0e27600da77eb"}, {"problem": 108, "code": "(fn [& seqs]\n    (letfn [(merge-seqs [seqs]\n              (loop [seqs seqs\n                     res []]\n                (lazy-seq\n                  (if (some seq seqs)\n                    (let [m (reduce (fn [out s]\n                                      (if-let [seqs-for-key (get out (first s))]\n                                        (assoc out (first s) (conj seqs-for-key s))\n                                        (assoc out (first s) [s])))\n                                    {} (filter seq seqs))\n                          min-key (apply min (keys m))\n                          min-keys-seqs-count (count (filter seq (get m min-key)))\n                          m (assoc m min-key (map rest (get m min-key)))]\n\n                      (concat (repeat min-keys-seqs-count min-key) (merge-seqs (apply concat (vals m)))))))))]\n      (let [merged (merge-seqs seqs)]\n        (->> merged\n             (partition-by identity)\n             (some (fn [g] (when (= (count seqs) (count g))\n                             (first g))))))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 108, "code": "(fn [& colls]\n  (loop\n    [x colls]\n    (let [a (map first x)\n          b (apply min a)]\n      (if (every? #{b} a) b\n        (recur (map #(if (= (first %) b)\n                       (rest %)\n                       %) x))))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 108, "code": "(fn __ [& xs]\n  (loop [i 0]\n    (let [n (reduce (fn [c ax]\n                      (first (filter (partial <= c) ax)))\n                   i xs)]\n      (if (= n i) i (recur n)))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [lowest (apply min (map first seqs))]\n    (if (every? #(= lowest (first %)) seqs)\n      lowest\n      (recur (map #(drop-while (partial = lowest) %) seqs)))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 108, "code": "(fn [& ss] (loop [v (into [] ss)] (if (apply = (map first v)) (first (first v)) (let [m (apply min (map first v))] (recur (into [] (map #(if (= (first %) m) (rest %) %) v)))))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 108, "code": "(fn fs [& ss] \n  (let [n-min   (apply min (map first ss))\n        s-min   (mapcat (partial take-while (partial = n-min)) ss)\n        ss-next  (map (partial drop-while #(= n-min %)) ss)]\n    (if (= (count s-min) (count ss)) n-min (apply fs ss-next))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 108, "code": "(fn [& colls]\n    (letfn [(search [colls]\n              (let [firsts (map first colls)\n                    max-val (apply max firsts)]\n                (lazy-seq\n                 (cons firsts\n                       (search (concat (filter #(= (first %) max-val) colls)\n                                       (map rest (filter #(not= (first %) max-val) colls))))))))]\n      (first (some #(when (apply = %) %) (search colls)))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 108, "code": "(fn smallest [x & others]\n            (if ((fn contained [element lists]  (every? #(some (fn [x] (= element x))  (take-while (fn [y] (<= y element)) %)) lists)\n                   ) (first x) others) (first x) (recur (rest x) others) )\n\n\n            )", "user": "5afc115de4b0cc2b61a3bcff"}, {"problem": 108, "code": "(fn [& s]\n   (letfn [(f [s m]\n             (first \n               (filter \n                 #(and (integer? %)\n                       (>= % m)) \n                 s)))]\n     (if (= 1 (count s))\n       (f (first s) 0)\n       (loop [x (apply max (map #(f % 0) s))\n              y (apply max (map #(f % x) s))]\n         (if (= x y)\n           x\n           (recur y (apply max (map #(f % y) s))))))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 108, "code": "(fn p [& xs]\n  (let [fst (map first xs)\n        head (first fst)]\n    (if (every? #(= head %) fst)\n      head\n      (let [sorted-list (sort-by first xs)]\n        (apply p (cons (rest (first sorted-list)) (rest sorted-list)))))))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 108, "code": "(fn [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [smallest (apply min (map first xs))]\n      (recur (map #(if (= smallest (first %)) (drop 1 %) %) xs)))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 108, "code": "(fn [& cs]\n  (let [cs (map-indexed list cs)\n        cmp #(let [[ia a] % [ib b] %2]\n               (if (= (first a) (first b))\n                 (compare ia ib)\n                 (compare (first a) (first b))))]\n    (loop [pq (apply sorted-set-by cmp cs)]\n      (if (apply = (map (comp first second) pq))\n        ((comp first second first) pq)\n        (recur (conj (disj pq (first pq)) ((comp #(list (ffirst pq) %) next second first) pq)))))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 108, "code": "(fn lazy\n  [& xss]\n  (let [first-elements (map first xss)\n        lowest         (apply min first-elements)]\n    (if (apply = first-elements)\n      lowest\n      (apply lazy (map (fn [xs]\n                         (if (= (first xs) lowest)\n                           (rest xs)\n                           xs))\n                       xss)))))", "user": "5afcd6d1e4b0cc2b61a3bd17"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (when (every? seq seqs)\n    (let [heads (map first seqs)\n          max-head (apply max heads)\n          =max-head? (hash-set max-head)]\n      (if (every? =max-head? heads)\n        max-head\n        (let [[seqs-bigger-head \n               seqs-lesser-head] \n              (split-with (comp =max-head? first) \n                          (reverse (sort-by first seqs)))]\n          (recur (concat seqs-bigger-head \n                         (map rest seqs-lesser-head))))))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 108, "code": "(fn\n ([x]\n  (apply min x))\n ([x y]\n  (let [x (set (take 4 x))\n        y (set (take 4 y))]\n   (first (min (clojure.set/intersection x y)))))\n ([x y z]\n  (let [x (set (take 8 x))\n        y (set (take 8 y))\n        z (set (take 45 z))]\n   (first (min (clojure.set/intersection x y z))))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 108, "code": "(fn find-smallest [& colls]\n  (loop [cur (seq colls)]\n    (when (every? not-empty cur)\n      (let [fsts (map first cur)\n            m (apply max fsts)\n            n (map #(drop-while (partial > m) %) cur)]\n        (if (every? #(= m %) fsts)\n          m\n          (recur n))))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 108, "code": "(fn [& vs]\n  (case (count vs)\n    1 (ffirst vs)\n    (let [heads (map first vs)\n         largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [v] (drop-while #(< % largest) v)) vs))))))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 108, "code": "(fn lazy-search-common-min [& a]\n  (let [firsts (map first a)\n        max-first (reduce max firsts)\n        all-the-same (= (count firsts) (count (filter #(= % max-first) firsts)))]\n        (if all-the-same max-first\n            (apply lazy-search-common-min\n              (map (fn [x] (if (= (first x) max-first)\n                            x\n                            (rest x))) a)))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 108, "code": "(fn smallest-in-all[& xss]\n  ;; case for only one xs\n  (let [sorted-sets (sort #(compare (first %1) (first %2)) xss)\n        firsts (map first sorted-sets)\n        found? (apply = firsts)\n        answer (ffirst sorted-sets)]\n    (if found?\n      answer\n      (apply smallest-in-all(concat (list (rest (first sorted-sets))) (rest sorted-sets))))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 108, "code": "(fn shared-smallest [& args]\n  (let [first-values (map first args)]\n    (cond\n      (some nil? first-values)\n      false\n      (apply = first-values)\n      (first first-values)\n      :else\n      (let [max (reduce max (map first args))]\n        (recur\n         (for [sorted-list args]\n           (if (< (first sorted-list) max)\n             (rest sorted-list)\n             sorted-list)))))))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": 108, "code": "(fn f\n  [& s]\n  (let [heads (map first s)]\n    (if (apply = heads)\n      (first heads)\n      (let [mh (apply max heads)\n            new-set (map (fn [x] (drop-while #(< % mh) x)) s)]\n        (apply f new-set))\n      )\n    )\n  )", "user": "583048d9e4b051871117c007"}, {"problem": 108, "code": "(fn ls [& seqs] (let [firsts (map first seqs)]\n               (if (= 1 (count (set firsts)))\n                 (first firsts)\n                 (\n                  let [min-first (apply min (map first seqs))\n                   \t   shortened (map #(if (= min-first (first %)) (rest %) %) seqs)]\n                  (apply ls shortened)\n                  ))\n               ))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 108, "code": "(fn smallest [& args]\n  (let [value (reduce min (map first args)) hasVal (fn [s] (= value (first s)))]\n    (if\n      (= (count (filter hasVal args)) (count args))\n      value\n      (apply smallest (filter first (map #(if (hasVal %) (rest %) %) args))))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (let [heads (map first seqs)\n        min-head (apply min heads)\n        max-head (apply max heads)]\n    (if (= min-head max-head)\n      min-head\n      (recur (map (fn [xs] (drop-while #(< % max-head) xs)) seqs)))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 108, "code": "(fn ls\n  [& ss]\n  (loop [cand (apply max (map first ss))]      \n    (let [newcands (map (fn [s] (first (drop-while #(> cand %) s))) ss)]\n      (if (apply = newcands) (first newcands) (recur (apply max newcands))))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 108, "code": "(fn [& args]\n  (loop [colls args]\n    (let [first-items (map first colls)\n          max-item (apply max first-items)]\n      (if (apply = first-items)\n        max-item\n        (recur\n         (map (fn [m] (drop-while #(< % max-item) m)) colls))))))", "user": "5b4fef74e4b02d533a91bcde"}, {"problem": 108, "code": "(fn -search-smallest [& streams]\n  (let [first-stream-values (map first streams)\n        min-value (apply min first-stream-values)\n        max-value (apply max first-stream-values)]\n    (if (= min-value max-value)\n      min-value\n      (recur (for [stream streams]\n               (drop-while #(< % max-value) stream))))))", "user": "524740e7e4b05ef8e38e635d"}, {"problem": 108, "code": "(fn small-popular [& args]\n  (let [firsts (map first args)\n        largest (apply max firsts)\n        remove-items (fn [n coll] (remove #(> n %) coll))]\n    (if (apply = firsts)\n      largest\n      (recur (map #(remove-items largest %) args)))))", "user": "5b477969e4b02d533a91bc6f"}, {"problem": 108, "code": "(partial\n   (fn smallest [min & xss]\n     (let [next-min (apply max\n                           (first\n                            (apply map (fn [& xs] xs)\n                                   (map (partial filter #(and (<= min %) (integer? %))) xss))))]\n       (if (= next-min min)\n         min\n         (apply smallest next-min xss)))) 1)", "user": "51a3be77e4b0e77c4ca60bf8"}, {"problem": 108, "code": "(fn [& xxs]\n (let [[v-min v-max] (first (apply map (juxt min max) xxs))]\n  (if (= v-min v-max)\n   v-min\n   (recur (map (fn [xs]\n                (drop-while #(< % v-max) xs)) xxs)))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 108, "code": "(fn z [ & args ]\n  ( loop [ l args mn 0 ]\n    ( let [ fi (for [ i l ] (first i))\n            ne (for [ i l ] (if (< (first i) mn) (rest i) i))\n           ]\n      (if (apply = fi)\n        (first fi)\n        (recur ne (apply max fi))\n        )\n      )\n    )\n  )", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs (vec seqs)]\n    (let [idx-and-first (map-indexed (fn [i s] [i (first s)]) seqs)]\n      (if (apply = (map second idx-and-first))\n        (-> idx-and-first first second)\n        (let [idx-and-first-sorted (sort-by second idx-and-first)\n              idx (ffirst idx-and-first-sorted)]\n          (recur (lazy-cat (take idx seqs)\n                           [(rest (nth seqs idx))]\n                           (drop (inc idx) seqs))))))))", "user": "559622cee4b0c79f6e1db975"}, {"problem": 108, "code": "(fn min-in-seqs [sq & sqs]\n    (let [x    (first sq)\n          sqs' (map (fn [sq'] (drop-while #(< % x) sq')) sqs)\n          xs   (map first sqs')]\n        (if (apply = x xs) x (apply min-in-seqs (rest sq) sqs'))))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 108, "code": "(fn [& c]\n  (loop [cc c fc (map first cc) m (apply max fc)]\n    (if (apply = fc)\n      m\n      (let [newcc (map #(drop-while (fn [x] (< x m)) %) cc)\n            newfc (map first newcc)]\n      (recur newcc newfc (apply max newfc))))))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 108, "code": "(fn __ [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "502a5e59e4b09e8f859a9fbc"}, {"problem": 108, "code": "(fn lazy-min [& s]\n  (letfn [(gen-pivot-fn [seqs]\n            (partial > (apply max (map first seqs))))\n          (drop-till-pivot [seqs]\n            (map #(drop-while (gen-pivot-fn seqs) %) seqs))]\n    (loop [all-seqs (drop-till-pivot s)]\n      (if (apply = (map first all-seqs))\n        (ffirst all-seqs)\n        (recur (drop-till-pivot all-seqs))))))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 108, "code": "(fn smol [& cols]\n  (if (every? (partial = (first (first cols))) (map first cols) )\n    (first (first cols))\n    (let [\n      largest (apply max (map first cols))\n      newcols (map #(if (= largest (first %1)) %1 (rest %1) ) cols)\n     ]\n      (apply smol newcols) \n    )\n  )\n)", "user": "5bbd13a5e4b07a9b28b0ff95"}, {"problem": 108, "code": "(fn [& seqs]\n  (if (= 1 (count seqs))\n    (ffirst seqs)\n    (let [heads (keep first seqs) max-head (apply max heads)]\n      (if (apply = heads)\n        max-head\n        (recur (map (fn [s] (drop-while #(> max-head %) s)) seqs))))))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 108, "code": "(fn blub [& x](rand-int 2)\n  (let [m (apply min (map first x))] (do (println m)                                                 )\n    (if (apply = (map first x)) m\n      (recur (map (fn [y] (drop-while (partial >= m) y)) x)))))", "user": "5bc9e3e9e4b07a9b28b100e2"}, {"problem": 108, "code": "(fn lazy-searching [& seqs]\n      (let [firsts (map first seqs)\n            candidate (apply max firsts)]\n        (println \"firsts=\" firsts)\n        (println \"candidate=\" candidate)\n        (if (apply = firsts)\n          candidate\n          (recur (map (fn [x] (drop-while #(> candidate %) x)) seqs)))))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 108, "code": "(fn ans_v2 [& colls] (let [f-nums (map first colls) max-nums (apply max f-nums)] (if (apply = f-nums) (first f-nums) (recur (map (fn [x] (if (= (first x) max-nums) x (rest x))) colls)))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 108, "code": "(fn [& args]\n    (let [heads (map first args) t (apply max heads)]\n      (if (every? #(= % t) heads)\n        t\n        (recur (remove empty? (map #(drop-while (fn [i] (< i t)) %) args))))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 108, "code": "(fn ll [& xs]\n          (let [ls (flatten (map first xs))\n                m (apply max ls)]\n            (if (every? #(= m %) ls)\n              m\n              (apply ll (map (partial drop-while #(< % m)) xs)))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 108, "code": "(fn [& l]\n  (let [fl (map #(filter integer? %) l)\n        x (apply max (map first fl))\n        ll (map #(filter (fn [t] (if (>= t x) true false)) %) fl)]\n    (if (every? #(= x %) (map first ll))\n      x\n      (recur ll))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 108, "code": "(fn problem-108\n  [& nss]\n  (let [firsts\n        (map first nss)\n\n        pivot\n        (apply max firsts)]\n    (if (apply = firsts)\n      pivot\n      (->> nss\n           (map (partial drop-while #(> pivot %)))\n           (recur)))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 108, "code": "(fn [& x] (letfn [\n(dig [i [c & cs]]\n  (if (nil? c)\n    i\n    (some \n     #(if (and\n      (or (nil? i) (= i %))\n      (= % (dig % cs))\n      ) %)\n     (if (nil? i) c (take-while #(<= % i) c) ))\n    )\n   )] (dig nil x)))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 108, "code": "(fn smse [& ss]\n  (if (apply = (map first ss))\n    (first (first ss))\n    (let [lowest (apply min (map first ss))]\n      (apply smse (map (fn [q] (drop-while #(<= % lowest) q)) ss)))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 108, "code": "(fn f [& colls]\n    (let [one-seq (fn one-seq [colls]\n                    (let [colls (sort #(compare (first %1) (first %2))\n                                      colls)]\n                      (lazy-seq\n                       (cons (first (first colls))\n                             (one-seq (cons (rest (first colls))\n                                            (rest colls)))))))\n          colls-equal? (fn [coll n-colls]\n                         (apply = (map #(nth coll %)\n                                       (range n-colls))))\n          find-equal (fn find-equal [coll n-colls]\n                       (if (colls-equal? coll n-colls)\n                         (first coll)\n                         (find-equal (rest coll) n-colls)))]\n      (find-equal (one-seq colls) (count colls))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 108, "code": "(fn lazy-searching\n  ;; I think the strategy here is to keep the heads each list\n  ;; and advance all lists that are less than the current max\n  [& lists]\n  (loop [lists lists]\n    (cond (some empty? lists) nil\n          :else (let [max-val (apply max (map first lists))\n                      new-lists (map (partial drop-while #(< % max-val)) lists)\n                      ]\n                  (cond (apply = (map first new-lists)) (ffirst new-lists)\n                        :else (recur new-lists))))))", "user": "50427899e4b0add3005c0fc2"}, {"problem": 108, "code": "(fn eqls [& all]\n(letfn [(eql [s1 s2]\n  (lazy-seq\n  (let [f1 (first s1) f2 (first s2) r1 (rest s1) r2 (rest s2)]\n     (cond (= f1 f2) (cons f1 (eql r1 r2))\n           (> f1 f2) (eql s1 r2)\n           :else (eql r1 s2)\n      )\n   )\n   )\n )]\n \t\t(first (reduce eql all))\n ))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 108, "code": "(fn lazy-searching\n  [& colls]\n  (loop [colls colls]\n      (let [maximal\n            (apply max (map first colls))\n\n            starts-with-max\n            #(= (first %) maximal)\n\n            colls-with-max\n            (filter starts-with-max colls)\n\n            colls-without-max\n            (seq (remove starts-with-max colls))]\n\n        (if colls-without-max\n          (recur (concat colls-with-max (map rest colls-without-max)))\n          maximal))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 108, "code": "(fn [& xs] (let [fm (map first xs) mm (apply min fm) eq (apply = fm)]\n                         (if eq mm\n                             (recur (map #(if (= mm (first %)) (rest %) %) xs)))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 108, "code": "(fn f [& x]                                                                                                                       \n  (let [[[a & b] & c :as x] (sort-by first x)]\n    (if (apply = (map first x)) a (apply f (conj c b)))))", "user": "51eead15e4b0871fa145d98a"}, {"problem": 108, "code": "(fn [& xss]\n    (letfn [(smallest* [zss]\n               (let [heads (into [] (map first zss))]\n                 (if (apply = heads) (first heads)\n                     (let [j (apply min-key #(get heads %) (range (count heads)))]\n                       (recur (assoc zss j (rest (get zss j))))))))]\n      (smallest* (vec (map #(filter integer? %) xss)))))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 108, "code": "(fn [& xs]\n  (let [f (map first xs)\n        smallest (apply min f)]\n    (if (apply = f)\n      (ffirst xs)  \n      (recur\n       (map #(if (= smallest %1) (rest %2) %2) f xs)))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 108, "code": "(fn smallest-common-value [& sqs]\n  (let [biggest-value (apply max (map first sqs))]\n    ;; If all the values are the same, we're done.\n    (if (apply = (map first sqs))\n      biggest-value\n      ;; Since they're not all the same, and they're sorted, at least\n      ;; one is too small. So drop all the ones that are smallest than\n      ;; the biggest, and start over.\n      (apply smallest-common-value\n      \t     (map (fn [sq] (drop-while #(< % biggest-value) sq)) sqs)))))", "user": "5bfa25fbe4b0bdcf453d15c8"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n(apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "5bfd6668e4b0bdcf453d15fc"}, {"problem": 108, "code": "#(loop [seqs %&]\n   (let [firsts (map first seqs)]\n     (if (apply = firsts)\n       (first firsts)\n       (recur (map (fn [s]\n                     (if (< (first s) (apply max firsts)) \n                       (rest s)\n                       s))\n                   seqs)))))", "user": "5b60e88be4b0c6492753e70b"}, {"problem": 108, "code": "(fn lazy-seach\n  [ & cols]\n  (letfn [(lazy-search-\n            [cols]\n            (let [v (map first cols)\n                  m (apply min v)]\n              (if (apply = v) m\n                  (recur (map (fn [col] ((if (= (first col) m) rest seq) col)) cols)))))]\n    (lazy-search- cols)))", "user": "5c222b7de4b07e362c230588"}, {"problem": 108, "code": "(fn lazy-search\n  [& sequences]\n  (let [[bottom top] (#(vector (apply min %) (apply max %)) (map first sequences))]\n    (if (= bottom top)\n      bottom\n      (apply lazy-search (reduce #(if (< (first %2) top) (conj %1 (next %2)) (conj %1 %2)) [] sequences))\n      )\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 108, "code": "(fn [& colls]\n  (let [ff (map first colls) ma (apply max ff)]\n    (if (every? #(= ma %) ff)\n      ma\n      (recur (map (fn [coll] (drop-while #(< % ma) coll)) colls)))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 108, "code": "(fn [& xs]\n  (let [min-vals (map first xs)\n        max-val (apply max min-vals)]\n    (if (apply = min-vals)\n      max-val\n      (recur (map (fn [x] (drop-while #(< % max-val) x)) xs)))))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 108, "code": "(fn [& seqs] (loop [cs seqs] (let [fs (map first cs) m (apply min fs)] (if (apply = fs) (first fs) (recur (map #(if (= m (first %)) (rest %) %) cs))))))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 108, "code": "#(let [n (map first %&)\n       m (apply min n)]\n    (if (apply = n)\n      m\n      (recur (map (fn [[f & r :as w]]\n                    (if (= m f)\n                     r\n                     w))\n                  %&))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 108, "code": "(fn lazySearch [coll & colls]\n(if \n  (= 1 \n    (count (distinct \n    (for [x (conj colls coll)] \n      (take 1 (filter #(>= % (first coll)) x))))))\n  (first coll)\n  (apply (partial lazySearch (drop 1 coll)) colls)))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 108, "code": "(fn lazy-searching [& args]\n  (let [m (group-by first args)]\n    (if (= (count m) 1) (first (keys m))\n                        (let [minimum (reduce min (keys m))]\n                          (apply lazy-searching (concat\n                                                  (map rest (m minimum))\n                                                  (mapcat identity (vals (dissoc m minimum)))))))))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "56f4623ae4b046a417f9205d"}, {"problem": 108, "code": "(fn meth [& xss]\n   (let [max (apply max (map first xss))]\n     (if (apply = max (map first xss))\n       max\n       (loop [colls xss\n              res []]\n         (if (next colls)\n           (recur (next colls) (conj res (drop-while #(> max %) (first colls))))\n           (apply meth (conj res (drop-while #(> max %) (first colls))))\n           )))))", "user": "5c3f37fce4b08cd430848e91"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5c321b8ae4b0d62ef62d9f32"}, {"problem": 108, "code": "(fn [& m] (loop [s m] (if (apply = (map first s)) (ffirst s) (recur (let [mx (apply max (map first s))] (map #(drop-while (fn [c] (< c mx)) %) s))))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 108, "code": "(fn [& ss]\n  (if (= 1 (count ss))\n    (first (first ss))\n    (letfn [(f=? [x ss]\n              (apply == x (map (fn [y] (first (drop-while #(< % x) y))) ss)))]\n      (loop [sq (first ss) sqs (rest ss)]\n        (if (f=? (first sq) sqs)\n          (first sq)\n          (recur (drop 1 sq) sqs))))))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 108, "code": "(fn search [& colls]\n  (let [heads (map first colls)\n        mini  (apply min heads)]\n    (if (apply = heads)\n      (first heads)\n      (recur (map (fn [c]\n                    (if (= (first c) mini)\n                      (rest c)\n                      c)) colls)))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 108, "code": "(fn smallest-common-element [& colls]\n  (let [intersection (fn intersection [a & sets]\n                       (if (empty? sets)\n                         a\n                         (apply intersection\n                                (set (filter (set a) (first sets)))\n                                (rest sets))))]\n    (->> [(repeat (count colls) #{}) colls]\n         (iterate (fn [[sets remaining-colls]]\n                    (let [[min-index min-coll] (apply min-key (comp first second) \n                                                 (map-indexed vector remaining-colls))]\n                      [(map-indexed (fn [i s] (if (= i min-index) \n                                                (conj s (first min-coll)) \n                                                s)) sets)\n                       (map-indexed (fn [i c] (if (= i min-index) \n                                                (rest c) \n                                                c)) remaining-colls)])))\n         (map (comp (partial apply intersection) first))\n         (remove empty?)\n         first\n         first)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 108, "code": "(fn __\n  [& ins]\n  (loop [seqs ins]\n    (let [firsts (map first seqs)\n          least (apply min firsts)]\n      (if (every? #{least} firsts)\n        least\n        (recur (map #(if (= least (first %)) (rest %) %) seqs))))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 108, "code": "(fn [& c] (loop [d c] (if (apply = (map first d)) (first (first d)) (let [m (apply max (map first d))] (recur (map #(if (< (first %) m) (rest %) %) d))))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 108, "code": "(fn lazy-search\n  [& seqs]\n  (let [seq-contains (fn [n s]\n                       (some (partial = n) (take-while #(<= % n) s)))]\n    (->> (first seqs)\n         (filter #(every? (partial seq-contains %) (rest seqs)))\n         first)))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 108, "code": "(fn [& xs]\n  (let [fs (map first xs)\n        m (apply max fs)]\n    (if (apply = fs) (first fs)\n      (recur (map (fn [x] (drop-while #(< % m) x)) xs)))))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 108, "code": "(fn ls [& s]\n  (let [f (map first s)\n        m (apply max f)]\n    (if (= 1 (count (set f))) m (apply ls (map (fn [t] (drop-while #(> m %) t)) s)))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 108, "code": "(fn [& cols]\n  (if (= 1 (count cols))\n    (first (first cols))\n    (let [heads (map first cols)\n          largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) cols))))))", "user": "5c723f4be4b0fca0c16227a0"}, {"problem": 108, "code": "(fn lazys [& sqs]\n  (let [firsts (map first sqs)\n        maxi (apply max firsts)]\n\n    (if (apply = firsts)\n      maxi\n      (recur (map (fn [c] (drop-while #(< % maxi) c)) sqs)))))", "user": "5c76577ae4b0fca0c16227ea"}, {"problem": 108, "code": "(fn lxp [& cols]\n  (if (= 1 (count cols))\n    (first (first cols))\n    (let [head (map first cols)\n        max (apply max head)]\n          (if  (apply = head)\n            max\n            (recur (map (fn [nextCol] (drop-while #(< % max) nextCol)) cols))\n      ))) )", "user": "5c6e8b57e4b0fca0c1622755"}, {"problem": 108, "code": "(fn smallest-related [& colls] (let [s (sort-by first colls)] (if (apply = (map first s))\n                                                                  (-> s first first)\n                                                                  (apply smallest-related (cons (rest (first s)) (rest s))))))", "user": "5c7bc0a5e4b0fca0c1622865"}, {"problem": 108, "code": "(fn foo [& xss]\n    (let [fs (map first xss)]\n      (when-not (some nil? fs)\n        (if (apply == fs)\n          (first fs)\n          (let [mn (reduce min fs)]\n            (->> xss\n                 (map #(if (== mn (first %))\n                         (rest %) %))\n                 (recur)))))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 108, "code": "(fn [& x] (let [firsts (map first x)]\n                (if (apply = firsts)\n                  (first firsts)\n                  (recur (map (fn [a](drop-while #(< % (apply max firsts)) a ))  x)))))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 108, "code": "(fn [& colls]\n  (let [fs (map first colls)]\n    (if (apply = fs)\n      (first fs)\n      (let [m (apply max fs)]\n        (recur (map #(drop-while (fn [n] (< n m)) %) colls))))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 108, "code": "(fn [& xss]\n  (let [firsts (map first xss)]\n    (if (every? (partial = (first firsts)) firsts)\n      (first firsts)\n      (recur (for [xs xss]\n               (drop-while #(< % (apply max firsts)) xs))))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 108, "code": "(fn search\n  [& args]\n  (let [smallest (fn f\n                   [n cs]\n                   (let [x (map (fn [c] (some #(if (>= % n) %) c)) cs)]\n                     (cond\n                       (some nil? x) nil\n                       (every? #(= n %) x) n\n                       :else (f (apply max x) cs))))]\n    (if (= 1 (count args))\n      (ffirst args)\n      (smallest (ffirst args) args))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 108, "code": "(fn lazy-searching [& xss]\n (loop [xss xss]\n  (if (apply = (map first xss))\n      (first (first xss))\n      (let [min-val (apply min (map first xss))\n            new-xss (map #(if (= min-val (first %)) (next %) %) xss)]\n       (recur new-xss)))))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 108, "code": ";; http://www.4clojure.com/problem/108\n(fn common-min\n  [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [firsts (map first colls)\n          max-val (apply max firsts)]\n      (if (apply = firsts)\n        max-val\n        (recur (map (fn [coll] (drop-while #(> max-val %) coll)) colls))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 108, "code": "(fn least-common [& args]\n  (loop [ss args]\n    (let [m (->> ss (map first) (apply max))\n          xs (map (partial remove #(< % m)) ss)]\n      (if (->> xs (map first) (apply =))\n        (ffirst xs)\n        (recur xs)))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 108, "code": "(fn smallest-common [& seqs]\n  (let [firsts (map first seqs)]\n    (if (apply = firsts)\n      (first firsts)\n      (apply smallest-common (map (partial drop-while (partial > (apply max firsts))) seqs)))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [biggest-head (->> colls\n                          (map first)\n                          (apply max))]\n    (if (apply (partial = biggest-head) (map first colls))\n      biggest-head\n      (apply lazy-search (map (fn [coll] (drop-while #(< % biggest-head) coll))\n                              colls)))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 108, "code": "(fn s[& colls]\n  (if (apply = (map first colls))\n    (first (first colls))\n    (let [min-value (apply min (map first colls))]\n      (apply s (map #(if (= min-value (first %)) (rest %) %) colls)))))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 108, "code": "(fn [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [smallest (apply min (map first xs))]\n      (recur (map #(if (= smallest (first %)) (drop 1 %) %) xs)))))", "user": "5ce2bf8ee4b0a17bb84e2b2e"}, {"problem": 108, "code": "(fn [& sequs]\n         (loop [sqs sequs]\n           (if (every? #(= (first %) (first (first sqs))) sqs)\n             (first(first sqs))\n             (let [sorted-sqs (sort-by first sqs)\n                   smallest (first (first sorted-sqs))\n                   [all-small-sqs all-big-sqs] (partition-by #(= (first %) smallest) sorted-sqs) ]\n               (recur (concat all-big-sqs (map rest all-small-sqs) ))\n               ))))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 108, "code": "(fn [ & xss ]\n  (loop [cs xss]\n    (let [heads (map first cs)\n          m (apply min heads)]\n      (if (every? (complement nil?) heads)\n        (if (every? (partial = m) heads)\n          m\n          (recur (map #(if (= (first %) m) (rest %) %) cs)))\n        nil))))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 108, "code": "(fn smal2 [& args]\n  (letfn [(minmax [a] (loop [b a\n                             mn (first (first a))\n                             mx (first (first a))]\n                        (if (empty? b)\n                          (list mn mx)\n                          (recur (rest b) (min (first (first b)) mn) (max (first (first b)) mx)))))\n          (dofilter [a n] (loop [b a\n                                 acc ()]\n                            (if (empty? b)\n                              acc\n                              (recur (rest b) (cons (filter #(>= % n) (first b)) acc)))))]\n    (if (= 1 (count args))\n      (first (first args))\n      (loop [a args]\n        (let [mm (minmax a)]\n            (if (and mm (= (first mm) (second mm)))\n              (first mm)\n              (recur (dofilter a (second mm)))))))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 108, "code": "(fn srch [& lsts]\n  (let [xs (first lsts)\n        x (first xs)\n        nlsts (map #(drop-while (fn [e] (< e x)) %) lsts)]\n    (if (every? #(= x (first %)) nlsts)\n      x\n      (apply srch (cons (next xs) (next nlsts)))\n      )\n    )\n  )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 108, "code": "(fn xxx [fv & rv]\n  (letfn [(found [x l] \n                (cond\n                 (= x (first l)) true\n                 (> x (first l)) (recur x (rest l))\n                 :else false))]\n    (if (nil? rv) (first fv)\n      (loop [fv fv]\n        (if (every? #(found (first fv) %) rv)\n          (first fv)\n          (recur (rest fv)))))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 108, "code": "(fn lazy-search [& colls]                                               \n  (if (= 1 (count colls))                                               \n    (first (first colls))                                               \n    ;;get the largest out of the first of each coll                     \n    (let [heads (map first colls) largest (apply max heads)]            \n                                                                        \n      ;;if all of numbers are equal                                     \n      (if (apply = heads)                                               \n        ;;then just return the largest since they are all the same      \n        largest                                                         \n                                                                        \n        ;;otherwise,                                                    \n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5baaae06e4b0a20761a23464"}, {"problem": 108, "code": "(fn smallest-common [& seqs]\n  (let [firsts (set (map first seqs))\n        max-first (apply max firsts)]\n    (if (= (count firsts) 1) (first firsts)\n                             (recur (map (fn [s] (drop-while #(< % max-first) s))\n                                         seqs)))))", "user": "518279abe4b0353c468deb65"}, {"problem": 108, "code": "(fn [& seqs]\n    (letfn [(seqs-contain-number? [seqs the-number]\n              (let [possible-matches (map #(drop-while (fn [other-number]\n                                                         (< other-number the-number))\n                                                       %)\n                                          seqs)]\n                (every? #(= (first %)\n                            the-number)\n                        possible-matches)))]\n      (loop [remaining seqs]\n        (let [not-empty   (filter seq remaining)\n              chosen-seq  (first not-empty)\n              others      (rest not-empty)\n              current     (first chosen-seq)\n              in-all-seqs (seqs-contain-number? others\n                                                current)]\n          (if in-all-seqs\n            current\n            (recur (cons (rest chosen-seq)\n                         others)))))))", "user": "57f904c5e4b0d3187e900936"}, {"problem": 108, "code": "(fn [& cols]\n  (let [firsts (map first cols)]\n    (if (apply = firsts)\n      (first firsts)\n      (recur (map (fn [[x & xs :as col]]\n                    (if (= x (apply min firsts)) xs col))\n                  cols)))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 108, "code": "(fn \n  [[n & f-more] & xses]\n  (let [possible-matches (map #(drop-while (partial > n) %) xses)]\n    (if (every? #(= n (first %)) possible-matches)\n      n\n      (recur f-more possible-matches))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 108, "code": "(fn f [& s]\n  (let [ns (map first s)]\n    (if (apply = ns)\n      (first ns)\n      (let [new-s (map (fn [ss]\n                         (drop-while #(< % (apply max ns)) ss))\n                       s)]\n        (recur new-s)))))", "user": "5012da69e4b0c8732600222d"}, {"problem": 108, "code": "(fn min-common [& colls]\n   (let [minimums (map first colls)\n         to-find  (apply max minimums)\n         dropped  (map (partial drop-while #(> to-find %)) colls)\n         all-comm (= #{to-find} (set minimums))]\n     (if all-comm to-find\n         (apply min-common dropped))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 108, "code": "(fn [& seqs]\n    (loop [secuencias seqs]\n      (cond\n        (or (= (count secuencias) 1)\n            (apply = (map first secuencias)))\n          (first (first secuencias))\n        :else\n          (let [minimo (apply min (map first secuencias))\n                actualiza-secuencia (fn [elemento sec]\n                                      (if (= elemento (first sec))\n                                        (drop 1 sec)\n                                        sec))]\n            (recur (map #(actualiza-secuencia minimo %) secuencias))))))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 108, "code": "(fn [& x]\n  (let [head (map first x) largest (apply max head)]\n    (if (apply = head)\n      largest\n      (recur (map (fn [a] (drop-while #(> largest %) a)) x)))))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 108, "code": "(fn [& xs]\n  (let [fs (map first xs)\n        m (apply min fs)]\n    (if (= (count (filter #(= m %) fs)) (count xs))\n      m\n      (recur (map\n               (fn [c] (drop-while #(= m %) c))\n               xs)))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (loop [colls colls]\n    (let [heads (map first colls)]\n      (if (apply = heads)\n        (first heads)\n        (let [largest (apply max heads)]\n          (recur (map\n                  (fn [coll]\n                    (drop-while #(< % largest) coll))\n                  colls)))))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 108, "code": "(fn ThisFunc [& Seqs]\n    (let \n      [\n        ;; \u0432\u043e\u0437\u044c\u043c\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0443\u043c \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\n        MinFirst (apply min (for [X Seqs] (first X)))\n        ;; \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u0435\u043c, \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0435 \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f \u0441 \u043d\u0435\u0433\u043e\n        AllStart (apply * (for [X Seqs] (if (= MinFirst (first X)) 1 0)))\n      ]\n      ;; \u0435\u0441\u043b\u0438 \u0432\u0441\u0435 \u0441\u043f\u0438\u0441\u043a\u0438 \u043d\u0430\u0447\u0438\u043d\u0430\u044e\u0442\u0441\u044f \u0441 \u043e\u0434\u043d\u043e\u0433\u043e, \u0442\u043e \u0432\u0435\u0440\u043d\u0435\u043c \u0435\u0433\u043e\n      ;; \u0438\u043d\u0430\u0447\u0435, \u0432\u0441\u0435 \u043e\u0441\u0442\u0430\u0432\u0438\u043c \u0431\u0435\u0437 \u0438\u0437\u043c\u0435\u043d\u0438\u044f, \u0430 \u044d\u0442\u043e\u0442 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0443\u0431\u0435\u0440\u0435\u043c\n      (if (= 1 AllStart)\n        MinFirst\n        (apply ThisFunc\n          (for [X Seqs]\n            (if (= MinFirst (first X)) \n              (rest X)\n              X\n            )\n          )\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 108, "code": "(fn smallest [& s]\n  (let [minn (apply max (map first s))\n        nexts (map #(drop-while (fn [n] (< n minn)) %) s)]\n    (if (apply = (map first nexts)) (ffirst nexts)\n                                    (apply smallest nexts))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 108, "code": "(fn ls [& args]\n  (loop [args args]\n    (let [nums (map first args)]\n      (if (apply = nums)\n        (first nums)\n        (let [min-num (apply min nums)]\n          ;(println min-num nums args)\n          (recur\n            (map #(if (= (first %) min-num)\n                    (rest %)\n                    %)\n                 args)))))))", "user": "5a00cb31e4b01bb0ae8afd36"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [all-seqs seqs]\n    (if (apply = (map first all-seqs))\n      (ffirst all-seqs)\n      (let [sorted-seqs (sort-by first all-seqs)\n            min-seq (drop 1 (first sorted-seqs))\n            rest-seq (rest sorted-seqs)]\n        (recur (conj rest-seq min-seq))))))", "user": "5a64d12de4b0512ff01cd9a7"}, {"problem": 108, "code": "(fn lazySearch [& arrays]\n   (if\n     (every? #(= % (first (first arrays))) (map first arrays))\n     (first (first arrays))\n     (let [sortedArrays (sort-by first arrays)]\n       (apply lazySearch\n              (cons\n                (rest (first sortedArrays))\n                (rest sortedArrays))))))", "user": "5d887d27e4b0915913b1d3a8"}, {"problem": 108, "code": "(fn [& args]\n   (let [m (reduce min (map first args))]\n     (if (apply = (map first args))\n       m\n       (recur (map #(drop-while (fn [x] (= x m)) %) args)))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 108, "code": "(fn [& colls]\n   (letfn [(candidate-slices [item colls]\n             (map #(take-while (fn [x] (<= x item)) %) colls))\n           (candidates-contain [item colls]\n             (if (every? #(some #{item} %) (candidate-slices item colls))\n               item nil))]\n     (some #(candidates-contain % colls) (first colls))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 108, "code": "(fn [args & other](cond \n (= 3 (first args)) 3\n (= 1 (first args)) 4\n (and (= 0 (first args)) (not= 8 (second (rest args)))) 7\n :else 64))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 108, "code": "(fn cm [& colls]\n  (let [fs (map first colls)] \n    (if (apply = fs)\n      (first fs)\n      (let [m (apply max fs)]\n        (apply cm (map #(if (= m (first %)) % (rest %)) colls))))))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 108, "code": "(fn [& ls]\n  (let [consume (fn [i m s]\n                  (loop [rs s]\n                    (if (or (>= (first rs) m) (empty? rs))\n                      [i (first rs) (next rs)]\n                      (recur (rest rs)))))\n        n (count ls)]\n\n    (loop [ntgt (map first ls)\n           vals (map rest ls)\n           in   (range 0 n)]\n      (let [[i v r] (consume (first in) (apply max ntgt) (get (vec vals) (first in)))]\n        (if (or (apply = ntgt) (some empty? vals))\n          (apply max ntgt)\n          (if (= (- (count in) 1) 0)\n            (recur (assoc (vec ntgt) i v) (assoc (vec vals) i r) (range 0 n))\n            (recur (assoc (vec ntgt) i v) (assoc (vec vals) i r) (rest in))))))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 108, "code": "(fn lazy-searching [& args]\n  (let [column (map first args)\n        smallest (apply min column)]\n    (if (every? #(= smallest %) column)\n      smallest\n      (apply lazy-searching (map #(if (= smallest (first %)) (rest %) %) args)))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 108, "code": "(fn lsrch [& args]\n  (let [aa (list* args)]\n    (loop [l aa]\n      (let [firsts (map first l)\n            mymax  (apply max firsts)\n            s (into #{} firsts)\n            n (map (fn[a](drop-while #(> mymax %) a)) l)]\n        (if (= 1 (count s))\n          mymax\n          (recur n))))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 108, "code": "(fn abc [& cs]\n  (let [ fs (first (take 1 (apply map (fn [& vs] vs) cs)))\n         fi (apply min fs)\n         fx (apply max fs)\n         fiIndex (fn fiIndex [n] (if (= (nth fs n) fi) n (recur (inc n))))]\n    (if \n      (= fi fx) fi\n         (recur (concat (take (fiIndex 0) cs) (vector (rest (nth cs (fiIndex 0)))) (drop (inc (fiIndex 0)) cs))))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 108, "code": "(fn [s & ss]\n  (letfn [(in-s [x s] (= (last (take-while #(>= x %) s)) x))\n          (in-every-s [x] (every? #(in-s x %) ss))]\n    (first (filter in-every-s s))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 108, "code": "(fn [& cs]\n  (loop [cs cs]\n    (let [m (apply max (map first cs))]\n      (if (every? #(= m (first %)) cs)\n        m\n        (recur (map #(if (= (first %) m) % (rest %)) cs))))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 108, "code": "(fn lazy-search\n  [sq & sqs]\n  (loop [n 1]\n    (let [curr (last (take n sq))\n          search-fn #(and %1 (some #{curr}\n                 (take-while (partial >= curr) %2)))\n          result (reduce search-fn (first sq) sqs)]\n      (if result\n        result\n        (recur (inc n))))))", "user": "5da94ccfe4b000c986472c2f"}, {"problem": 108, "code": "(fn least [& args] {:pre (every? sequential? args)}\n    (if (apply = (map first args))\n        (first (first args))\n        (let\n            [\n                which_val (first (drop 1 (first args)))\n            ]\n            which_val\n            (recur (cons (drop 1 (first args)) (drop 1 (map (fn [s] (drop-while #(< % which_val) s)) args))))\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 108, "code": "(fn [& seqs]\n  (cond\n    (apply = (map first seqs)) (ffirst seqs)\n    (some empty? seqs) nil ;; not covered by test cases\n    :else (let [floor (->> seqs (map first) (apply max))]\n            (recur (map #(if (> floor (first %)) (next %) %) seqs)))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 108, "code": "(fn find-smallest [& sorted-seqs]\n  (let [contains-lazy-seq (fn [seq elem]\n                            (loop [idx 0]\n                              (let [curr (nth seq idx)]\n                                (if (> curr elem)\n                                  false\n                                  (if (= curr elem)\n                                    true\n                                    (recur (inc idx)))))))]\n\n    (loop [rem-in-first-seq (first sorted-seqs)\n           rem-seqs (rest sorted-seqs)]\n     (if (empty? rem-in-first-seq)\n       nil\n       (if (empty? rem-seqs)\n         (first rem-in-first-seq)\n         (let [curr (first rem-in-first-seq)]\n           (if (contains-lazy-seq (first rem-seqs) curr)\n             (recur rem-in-first-seq (rest rem-seqs))\n             (recur (rest rem-in-first-seq) (rest sorted-seqs))\n             )\n           ))))))", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 108, "code": "(fn [& x]\n  (if (apply = (mapv first x))\n      (first (first x))\n      (recur (map\n              #(if (= (apply max (mapv first x)) (first %)) % (rest %))\n              x))))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 108, "code": "(fn [& args]\n  (loop [counters (take (count args) (repeat 0))]\n      (let [elements (map\n                    #(first (drop % %2))\n                    counters\n                    args\n                  )\n          maxElem (apply max elements)\n          minElem (apply min elements)\n      ]\n\n        (if (= minElem maxElem) \n          minElem\n          (recur (map\n                    #(if (not= % maxElem) (inc %2) %2 )\n                    elements\n                    counters\n                  )\n          )))))", "user": "5da20e73e4b000c986472be1"}, {"problem": 108, "code": "(fn foo [s1 & args]\n  (let [lower-then (fn [y] \n                     (flatten [y (map \n                       (fn [x] \n                         (last (first \n                           (split-with (partial >= y) x))))\n                       args)]))]\n    (first (first \n             (filter #(apply = %) \n                     (map lower-then s1)\n                     )\n             ))\n))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 108, "code": "(fn lazy-search [x & xs]\n  (letfn [(lazy-contains [c n] (= n (last (take-while #(>= n %) c))))]\n    (if (seq x)\n      (if (= (count xs) (count (take-while #(lazy-contains % (first x)) xs)))\n        (first x)\n        (apply lazy-search (cons (rest x) xs))) \n      -1)))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [s seqs]\n    (let [first-elems (map #(first %) s)\n          max-first-elem (apply max first-elems)]\n    \t(if (apply = first-elems)\n          (first first-elems)\n          (recur (map (fn [xs] (drop-while #(< % max-first-elem) xs)) s))))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 108, "code": "(fn p-108 [& seqs]\n  (if (some empty? seqs) nil\n      (let [firsts (map first seqs)\n            the-min (apply min firsts)]\n        (if (apply = firsts) the-min\n            (apply p-108 (map (fn [seq] (if (= (first seq) the-min)\n                                    (rest seq)\n                                    seq))\n                              seqs))))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 108, "code": "(fn lazzy-search [& sequs]\n  (let [smallest (fn [sequs] \n                   (loop [sequs sequs\n                          min (first(first sequs))\n                          minn 0\n                          n 0]\n                     (if (not (seq sequs))\n                       minn\n                       (let [f (first sequs)]\n\t\t                     (if (< (first f) min)\n\t\t                       (recur (rest sequs) (first f) n (inc n))\n\t                         (recur (rest sequs) min minn (inc n)))))))\n        equals? (fn [sequs] \n\t\t\t\t\t\t\t\t  (loop [sequs sequs\n\t\t\t\t\t\t\t\t         val (first(first sequs))]\n\t\t\t\t\t\t\t\t    (if (not (seq sequs))\n\t\t\t\t\t\t\t\t      true\n\t\t\t\t\t\t\t\t      (let [f (first sequs)]\n\t\t\t\t\t\t\t\t        (if (not (= (first f) val))\n\t\t\t\t\t\t\t\t          false\n\t\t\t\t\t\t\t\t          (recur (rest sequs) val))))))\n        my-assoc  (fn [sequs n replacement]\n                 (loop [sequs sequs\n                        newsequ []\n                        i 0]\n                   (if(not(seq sequs))\n                     newsequ\n\t                   (if(= i n)\n\t                     (recur (rest sequs) (conj newsequ replacement) (inc i))\n\t                     (recur (rest sequs) (conj newsequ (first sequs)) (inc i))))))]\n        (if (equals? sequs)\n          (first (first sequs))\n          (let [smallestn (smallest sequs)]\n            (recur (my-assoc sequs smallestn (rest (nth sequs smallestn))  ))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 108, "code": "(fn [& seqs]\n    (if (apply = (map first seqs))\n      (ffirst seqs)\n      (let [m (apply max (map first seqs))]\n        (recur (map (fn [sq] (drop-while #(< % m) sq)) seqs)))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 108, "code": "(fn [& xss]\n  (cond\n    (= 1 (count xss)) (ffirst xss)\n    (apply = (map first xss)) (ffirst xss)\n    (< (ffirst xss) (ffirst (rest xss))) (recur (concat (rest xss) [(rest (first xss))]))\n    true (recur (concat (rest xss) [(first xss)]))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 108, "code": "(fn lazy-search [& args]\n  (let [firsts (map first args)]\n    (if (apply = firsts)\n      (first firsts)\n      (let [minimum (apply min firsts)]\n        (apply lazy-search (map (fn [coll]\n                                  (if (= minimum (first coll))\n                                    (rest coll)\n                                    coll))\n                                args))))))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (let [first-eles (map first colls)]\n    (if (every? #(= (first first-eles) %) first-eles)\n      (first first-eles)\n      (let [sorted-colls (sort-by first colls)]\n        (apply lazy-search (cons (rest (first sorted-colls)) (rest sorted-colls)))))))", "user": "5e121a89e4b099d064962fe4"}, {"problem": 108, "code": "(fn [& args]\n  (condp = (count args)\n    1 3\n    2 4\n    3 (if (vector? (last args)) 7 64)))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 108, "code": "(fn [& cs]\n    (loop [s (ffirst cs)\n           cs cs]\n      (Thread/sleep 100)\n      (let [cs' (map (fn [c] (drop-while #(< % s) c)) cs)\n            ss' (map first cs')]\n        (if (apply = ss') s\n            (recur (apply min (filter #(not= % s) ss')) cs')))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 108, "code": "(fn [& args]\n            (letfn [(p108_S [col X]\n                      (= X (last (take-while #(<= % X) col))))]\n              ((fn my-lz [N]\n                 (if (nil? (nth (first args) N nil))\n                   nil\n                   (if (some #(false? %) (map p108_S (rest args) (repeat (nth (first args) N))))\n                     (my-lz (+ N 1))\n                     (nth (first args) N))))\n               0)))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [firsts (map first seqs)\n          min-one (apply min firsts)\n          all-same? (apply = firsts)]\n      (println firsts min-one all-same?)\n      (if all-same?\n        min-one\n        (recur (map (fn [s]\n                      (if (= min-one (first s))\n                        (next s)\n                 \t\ts))\n                    seqs))))))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 108, "code": "(fn f [& sqs]\n  (let [s1s (map first sqs) m (apply max s1s)]\n    (if (apply = m s1s)\n      m\n      (apply f (map #(if (= (first %) m) % (rest %)) sqs)))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 108, "code": "; pop 1 from the smallest and compare\n(fn [& s]\n  (loop [greatest Integer/MIN_VALUE\n         nexts s]\n        (let [nexts (map (fn [x] \n           \t\t\t\t(drop-while #(< % greatest) x)) nexts)\n              firsts (map first nexts)]\n              (if (apply = firsts)\n                (first firsts)\n                (recur (apply max firsts) nexts)))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 108, "code": "(fn [& seqs]\n   (loop [seqs seqs]\n     (let [heads (map first seqs)\n           [hh & t] (sort-by first seqs)]\n       (if (apply = heads)\n         (first heads)\n         (recur (cons (rest hh) t))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 108, "code": "(letfn\n  [(srch\n     [& cs]\n     (let\n       [rcs (sort-by first cs)]\n       (if (apply = (map first rcs))\n         (ffirst rcs)\n         (apply\n           srch\n           (cons\n             (rest (first rcs))\n             (rest rcs))))))]\n  srch)", "user": "5e53f8e0e4b027a2e10ac0e7"}, {"problem": 108, "code": "(fn lazy-search [& seqs]\n  (loop [seqs seqs]\n    (let [fs (map first seqs)]\n      (if (apply = fs) (first fs)\n          (recur (map (partial drop-while #(< % (apply max fs))) seqs))))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 108, "code": "(fn [& r]\n  (loop [r r]\n    (let [f (map first r)\n          m (apply min f)\n          nr (for [x r] (drop-while #(= m %) x))]\n      (if (apply = f)\n        m\n        (recur nr)))))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 108, "code": "(fn f [& colls]\n  (if (every? #(= (first %) (ffirst colls)) colls)\n    (ffirst colls)\n    (let [sorted-colls (sort-by first colls)]\n    (apply f (cons (rest (first sorted-colls)) (rest sorted-colls))))))", "user": "5d7d17ece4b02e6b30c93558"}, {"problem": 108, "code": "(fn func [& seqs]\n  (let [monotonic-seq-contains? (fn [seq n] (= n (first (filter #(>= % n) seq))))]\n    (first \n     (filter \n      (fn [x] (every? (fn [coll] (monotonic-seq-contains? coll x)) (rest seqs))) \n      (first seqs)))))", "user": "5e805895e4b085ba37836e44"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [equal-seq (fn equal-seq [s1 s2]\n                    (when (and (seq s1) (seq s2))\n                      (let [s1first (first s1)\n                            s2first (first s2)]\n                        (cond\n                          (< s1first s2first) (equal-seq (rest s1) s2)\n                          (> s1first s2first) (equal-seq s1 (rest s2))\n                          :else (cons s1first (lazy-seq (equal-seq (rest s1) (rest s2))))))))]\n    (first (reduce equal-seq seqs))))", "user": "4eb70649535d7eef30807373"}, {"problem": 108, "code": "(fn lazy-search [s1 & seqs]\n  (let [lower-bound      (fn [ele coll]\n                           ((fn helper [coll]\n                              (cond\n                                (= (first coll)\n                                   ele) {\n                                         :eq true :s (drop 1 coll)}\n                                (> (first coll)\n                                   ele) {:eq false :s coll}\n                                :else\n                                (helper (drop 1 coll)))) coll))\n        contains-in-all? (fn [ele seqs]\n                           (let [lbs (for [s seqs]\n                                       (lower-bound ele s))]\n                             {:cont     (every? true? (map :eq lbs))\n                              :new-seqs (map :s lbs)}))]\n    ((fn searcher [s1 seqs]\n       (let [{new-seqs :new-seqs\n              cont     :cont} (contains-in-all? (first s1) seqs)]\n         (if cont\n           (first s1)\n           (searcher (drop 1 s1) new-seqs)))) s1 seqs)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 108, "code": "(fn [& colls]\n(let [take-size (fn [size] (fn [coll] (take-while #(< % size) coll)))\nnext (fn [size]\n(->> colls\n(map (take-size size))\n(apply concat)\n(group-by identity)\n(filter (fn [[k v]] (= (count v) (count colls))))\n(keys)))]\n(->> (range)\n(map next)\n(keep identity)\n(first)\n(apply min))))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 108, "code": "(fn [& sqs]\n  (let [fsq (map first sqs)\n        mfs (apply max fsq)]\n    (if (apply = fsq)\n      (first fsq)\n      (recur (map (fn [sq] (drop-while #(< % mfs) sq)) sqs)))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 108, "code": "(fn [coll1 & colls]\n  (letfn [(contains? [n coll]\n            (= n (last (take-while #(<= % n) coll))))\n          (not-all? [n colls]\n            (not-every? #(contains? n %) colls))]\n    (first (drop-while #(not-all? % colls) coll1))))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 108, "code": "(letfn [(merge-sorted\n            ;; `merge-sorted` merges any number of sorted sequences\n            ;; into one lazy-seq. It only consumes one element per\n            ;; input sequence at a time and terminates if lists do.\n            ([sA sB]\n             (let [[a & ssA] sA\n                   [b & ssB] sB]\n               (cond (empty? sA) sB\n                     (empty? sB) sA\n                     :else (if (= 0 (compare a b))\n                             (lazy-seq (cons a (cons b (merge-sorted ssA ssB))))\n                             (if (= -1 (compare a b))\n                               (lazy-seq (cons a (merge-sorted ssA sB)))\n                               (lazy-seq (cons b (merge-sorted sA  ssB))))))))\n            ([sA sB & more]\n             (reduce merge-sorted (reduce conj [sA sB] more))))]\n    (fn [& args]\n      (let [c (count args)]\n        (if (= 1 c)\n          (ffirst args)\n          (->> (partition-by identity (apply merge-sorted args))\n               (filter #(= c (count %)))\n               (ffirst))))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 108, "code": "(fn lazy-search [& vs]\n  (let [heads (map first vs)\n        guess (apply max heads)]\n    (if (= (apply min heads) guess)\n      guess\n      (apply lazy-search (map (fn [v] (drop-while #(< % guess) v)) vs)))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 108, "code": "(fn x [& fs]\n  (cond\n    (= 1 (count fs)) (ffirst fs)\n    (apply = (map first fs)) (ffirst fs)\n    (< (ffirst fs) (ffirst (rest fs))) (recur (concat (rest fs) [(rest (first fs))]))\n    :else (recur (concat (rest fs) [(first fs)]))))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 108, "code": "(fn lz [& s]\n  (apply #(if (apply = (map first %&)) (first (first %&)) \n              (apply lz (map (fn [x] (if (< (first x) (apply max (map first %&))) (rest x) x)) %&))) \n         s))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 108, "code": "; This is super inefficient, but\n; I wanted to try to solve this without using `loop`.\n; If I was writing this for clojure >= 1.5, I would\n; use `reduce` instead of `reductions` and then call\n; `reduced` when the target value is found.\n; Regardless, each seq needs to be potentially shortened\n; each time we don't find a match, but this'll do for now.\n\n(fn [c & colls]\n  (first\n   (drop-while\n    nil?\n    (reductions\n     #(or %1\n          (when\n            (every? #{%2}\n                    (map (fn [coll] (first (drop-while (partial > %2) coll)))\n                         colls)) %2))\n     nil c))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 108, "code": "(fn lazy-search [& xs]\n  (let [fs (map first xs)\n        mv (apply min fs)]\n    (if (apply = fs)\n      mv\n      (apply lazy-search \n             (map (partial drop-while #(= % mv)) \n                  xs)))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 108, "code": "(fn small [& colls]\n   (let [upper-number       (apply max (map first colls))\n         vals-until-upper-n (map (partial take-while #(<= % upper-number)) colls)]\n     (if-let [intersect (seq (apply clojure.set/intersection (map set vals-until-upper-n)))]\n       (first intersect)\n       (apply small (map (fn [c n] (drop (count n) c)) colls vals-until-upper-n))))\n   )", "user": "56c60b36e4b05cc29241eead"}, {"problem": 108, "code": "(fn [& seqs]\n        (let [[ minv maxv] (apply (juxt min max) (map first seqs))]\n          (if (= minv maxv)\n            minv\n            (recur (reduce #(conj %1 (if (< (first %2) maxv) (rest %2) %2)) [] seqs))))\n        )", "user": "5ec819b4e4b08d0ec38692e2"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "5ab276f2e4b073f1774425e6"}, {"problem": 108, "code": "(fn\n  [coll1 & colls]\n  (loop [[head & tail] coll1]\n    (if (or (nil? head) (apply = head (map (fn [coll] (last (take-while #(<= % head) coll)))\n                       \t\t\t\t\t   colls)))\n      head\n      (recur tail))))", "user": "5ecfd429e4b016b56eae05a9"}, {"problem": 108, "code": "(fn solution [& sequences]\n  (if (= 1 (count sequences))\n    (apply first sequences)\n    (let [candidates (map first sequences )\n          min (apply min candidates)]\n      (if (apply = candidates)\n        min\n        (recur (map #(if (= min (first %)) (drop 1 %) %) sequences))))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 108, "code": "(fn [& args]\n  (let [coll-count (count args)]\n    (loop [match (first (first args))\n           match-count 0\n           colls (apply conj clojure.lang.PersistentQueue/EMPTY args)]\n      (if (= match-count coll-count)\n        match\n        (let [coll (drop-while (partial > match) (peek colls))\n              next-least (first coll)\n              coll-rest (drop-while (partial = next-least) coll)\n              new-colls (conj (pop colls) coll-rest)]\n          (if (= next-least match)\n            (recur match (inc match-count) new-colls)\n            (recur next-least 1 new-colls)))))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [firsts (map first seqs)\n        min* (apply min firsts)]\n    (if (apply = firsts)\n      min*\n      (recur (map #(drop-while #{min*} %) seqs)))))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 108, "code": "(fn test [& ss]\n                  (let [largest-first-elem (fn [& ss]\n        (reduce (fn [a b] (if (> (first b) a) (first b) a)) (first (first ss)) ss))\n                        drop-until-greater (fn dug [s x] (if (>= (first s) x)\n          s\n          (dug (rest s) x)))]\n                  (if (some empty? ss)\n                    false\n                    (let [dropped (map (fn [seq] (drop-until-greater seq (apply largest-first-elem ss))) ss)]\n                      (if (apply = (map first dropped))\n                        (first (first dropped))\n                        (apply test dropped))))))", "user": "5edfb1e5e4b0c7845d86b107"}, {"problem": 108, "code": "(fn [& cs]\n  (if (apply = (map first cs))\n    (ffirst cs)\n    (recur (map #(drop-while (partial > (apply max (map first cs))) %) cs))))", "user": "50a4f36be4b0344e360f3bc9"}, {"problem": 108, "code": "(fn [s & seqs]\n   (loop [[h & t] s]\n     (if (reduce #(and %1\n                       (= :found (some (fn [x] (cond (= h x) :found\n                                                     (< h x) :not-found\n                                                     :else false)) %2))) \n                 true seqs) h (recur t))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 108, "code": "(fn [& ol]\n  (if (= 1 (count ol)) (ffirst ol) (let [m (apply min (map first ol))]\n                            (loop [mm m ool (map #(drop-while (fn [x] (< x m)) %) ol)]\n                              (let [mmm (apply min(filter #(> % mm) (map first ool)))] (println mmm (map first ool))\n                                   (if (apply = (map first ool) ) mmm\n                                       (recur mmm (map #(drop-while (fn [x] (<= x mmm))%) ool) )\n                                       ))\n                              )))\n)", "user": "5951190be4b066ee0a44aea4"}, {"problem": 108, "code": "(fn __\n  [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [smallest (apply min (map first xs))]\n      (recur (map #(if (= smallest (first %)) (drop 1 %) %) xs)))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 108, "code": "(fn [& seqs]\n  (when (not-any? empty? seqs)\n    (let [heads (map first seqs)]\n      (if (apply = heads)\n        (first heads)\n        (let [bound (apply max heads)]\n          (->> (map (fn [xs]\n                      (drop-while #(< % bound) xs))\n                    seqs)\n               recur))))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 108, "code": "(fn [& c]\n  (loop [c c]\n    (let [first-ele (map first c)]\n      (if (apply = first-ele)\n        (first first-ele)\n        (let [max-val (apply max first-ele)\n              next-seq (map  #(if (< (first %) max-val) (rest %) %) c)]\n          (recur next-seq))))))", "user": "5e08c3dde4b0978307768fc8"}, {"problem": 108, "code": "(fn [& params]\n   (let [\n\n         combine-sets (fn [coll1 coll2] (map #(into %1 %2) coll1 coll2))\n         take-1-sets (fn [coll] (map #(set (take 1 %)) coll))\n         drop-1-coll (fn [coll] (map #(drop 1 %) coll))\n\n         take-until (fn [coll upper-num]\n                      [(take-while #(> upper-num %) coll) (drop-while #(> upper-num %) coll)]\n\n                      )\n         take-until-sets (fn [coll & params]\n\n                           (let [upper-num (apply max (map #(apply max %) coll))\n                                 take-until-result (map #(take-until % upper-num) params)\n                                 result [ (map #(set (first %)) take-until-result) (map #(second %) take-until-result) ]\n                                 ]\n\n                                 (concat [(-> (combine-sets (first result) (take-1-sets (second result)))\n                                              (combine-sets coll)\n\n                                              )] (drop-1-coll (second result)))\n                             ))\n         find-intersection (fn find-intersection [combined-sets & params]\n                             (let [\n                                   sorted-sets (sort-by count combined-sets)\n\n                                   intersection (reduce clojure.set/intersection combined-sets)\n\n                                   ]\n\n                                   (if (not-empty intersection)\n                                     (first intersection)\n                                   (apply find-intersection (apply take-until-sets (concat [combined-sets] params)))\n                                   )\n                               \n\n                             ))\n\n\n         ]\n     (if (= 1 (count params))\n       (apply min (first params))\n     (apply find-intersection (concat [(take-1-sets params)] (map #(rest %) params))))\n     ))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 108, "code": "(fn [& s]\n  (loop [ns s]\n    (let [fs (map first ns) y (apply max fs)]\n     (if (apply = fs) y\n       (recur (map (fn [l] (drop-while #(> y %) l)) ns))))))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 108, "code": "(fn smallest-common-num [& cols]\n  (letfn [(move-cursor [col num]\n            (if (>= (first col) num)\n              col\n              (recur (rest col) num)))]\n    (let [firsts    (map first cols)\n          max-first (reduce max firsts)]\n      (if (apply = firsts)\n        (first firsts)\n        (recur (map #(move-cursor %1 max-first) cols))))))", "user": "5f22e8c9e4b0f565ad99828b"}, {"problem": 108, "code": "(fn lazy-search [& s]\n  (let [f (map first s)\n        m (apply min f)]\n    (println m)\n    (if (apply = f)\n      (first f)\n      (apply lazy-search (map (fn [l]\n                                (println ['compare (first l) m])\n                                (if (= (first l) m)\n                                  (rest l)\n                                  l)) s)))))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 108, "code": "(fn min-common\n  [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [minimum (apply min (map first xs))]\n      (apply min-common (map (partial drop-while #(>= minimum %)) xs)))))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 108, "code": "(fn common-smallest [& ss]\n  (loop [es (map first ss) ss ss]\n    (if (apply = es)\n      (first es)\n      (let [mx (reduce max es)\n            ss' (map #(drop-while (fn [x] (< x mx)) %) ss)]\n        (recur (map first ss') ss')))))", "user": "5f300f28e4b033932238a682"}, {"problem": 108, "code": "(fn first-min [& seqs]\n  (loop [mel (first (first seqs)) nseqs seqs]\n    (let [mseqs (map (fn [s] (drop-while (fn [e] (< e mel)) s)) nseqs)\n          tops (map first mseqs)]\n      (if (apply = tops)\n        (first tops)\n        (recur (apply max tops) mseqs))) ))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 108, "code": "(fn f [& sq]\n  (let [firsts (map first sq)]\n  \t(if (apply = firsts) (first firsts)\n    \t(let [max' (apply max firsts)\n              rests (map (fn [s] (drop-while #(< % max') s)) sq)]\n          (apply f rests)))))", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 108, "code": "(fn [& cols]\n  (if (= 1 (count cols))\n    (first (first cols))\n    (let [heads (map first cols)\n          largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [col] (drop-while #(< % largest) col)) cols))))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 108, "code": "(fn foo [& colls]\n   (let [firsts (map first colls)\n         n (reduce min firsts)]\n     (if (apply = firsts)\n       n\n       (apply foo (map #(if (= n (first %)) (next %) %) colls)))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 108, "code": "(fn [& c]\n    ((fn [c]\n       (let [c (sort-by first c)\n             x (ffirst c)]\n         (if (every? (comp #{x} first) c)\n           x\n           (recur (map #(if (= x (first %)) (rest %) %) c)))))\n     c))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 108, "code": "(fn [& list-of-seq]\n   (loop [firsts (filter #(not (nil? %)) (map first list-of-seq))\n          seqs list-of-seq]\n     (if (apply = firsts)\n       (apply min firsts)\n       (let [rests (map #(if (= (apply max firsts) (first %)) % (rest %)) seqs)]\n         (recur (filter #(not (nil? %)) (map first rests)) rests)))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 108, "code": "(fn f [s & ss]\n  (loop [x s]\n    (if (reduce #(and % (= (first x) (last (take-while (fn [a] (<= a (first x))) %2)))) true ss)\n      (first x)\n      (recur (next x)))))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 108, "code": "(fn lazymin [& lists]\n\t(let [smallests (set (map first lists))\n\t\tfoundit (= (count smallests) 1)\n\t\tm (apply max smallests)\n\t]\n\t\t(if foundit\n\t\t\t(first smallests)\n\t\t\t(recur\n\t\t\t\t(map\n\t\t\t\t\t(fn [l] (drop-while #(< % m) l))\n\t\t\t\t\tlists\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 108, "code": "(fn lazymin [& lists]\n\t(let [smallests (set (map first lists))\n\t\tfoundit (= (count smallests) 1)\n\t\tm (apply max smallests)\n\t]\n\t\t(if foundit\n\t\t\t(first smallests)\n\t\t\t(recur\n\t\t\t\t(map\n\t\t\t\t\t(fn [l] (drop-while #(< % m) l))\n\t\t\t\t\tlists\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t)\n)", "user": "5f06caa7e4b0cf489e8d7f52"}, {"problem": 108, "code": "(fn search-lazily\n  [& colls]\n  (let [firstitems (map first colls)]\n    (if (reduce #(and %1 (= (first firstitems) %2)) true firstitems)\n      (first firstitems)\n      (let [sorted (sort-by first colls)]\n        (apply search-lazily (conj\n                              (rest sorted)\n                              (rest (first sorted))\n                              ))))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 108, "code": "(fn lazy-smallest-in-all [& seqs]\n  (letfn [\n    (first-in-each ([seqs] (map first seqs)))\n    (all-same?[s]\n            (= 1 (count (distinct s))))\n    (take-shorter [seqs largest]\n              (map (fn [s] (if (= largest (first s)) s (rest s))) seqs))]\n    (loop [seqs seqs]\n      (let [smallest (first-in-each seqs)]\n        (if (all-same? smallest)\n          (first (first seqs))\n          (let [largest (reduce max smallest)]\n              (recur (take-shorter seqs largest))))))\n  ))", "user": "4f577f25e4b0a7574ea71839"}, {"problem": 108, "code": "(fn f [& seqs]\n  (loop [seqs seqs]\n    (let [mins (map first seqs)]\n      (if (apply = mins)\n        (first mins)\n        (let [highest (apply max mins)]\n          (recur (map\n                  (fn [s]\n                    (if (< (first s) highest) (rest s) s)) seqs)))))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 108, "code": "(fn [& seqs]\n    (let [firsts (map first seqs)\n          min-firsts (apply min firsts)]\n      (if (apply = firsts)\n        min-firsts\n        (recur (map #(if (= (first %) min-firsts)\n                       (rest %)\n                       %)\n                    seqs)))))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 108, "code": "(fn raise [& vs]\n    (loop [vs (vec vs)]\n        ;(println \"top\" (map first vs) (type vs))\n        (let [us (vec (sort-by first vs))\n              f  (first (first us))\n              l  (first (last us)) ]\n            ;(println f l (map first us) (type us))\n            (if (= f l)\n                ;(println \"Done\")\n                f\n                (let [ts (assoc us 0 (drop 1 (first us))) ]\n                    ;(println (map first ts))\n                    (recur ts))))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 108, "code": ";#(apply min (apply clojure.set/intersection (map set %&))) ; not lazy\n(fn laz [c1 & c2]\n   (loop [i c1]\n     (if (= true\n            (->> c2\n                 (map #(take-while (partial > (inc (first i))) %)) ; drop too big items\n                 (map (fn [c] (filter #(= % (first i)) c))) ; filter all equal\n                 (map empty?)\n                 (every? false?)) ; we found in all col\n            )\n       (first i)\n       (recur (rest i)))))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 108, "code": "(fn lazy-search [& ss]\n  (letfn [(alleq [ss] (apply = (map first ss)))\n          (sml [ss] (reduce #(let [[ss ls] %1]\n                               (if (< (first %2) (first ls))\n                                 [(conj ss ls) %2]\n                                 [(conj ss %2) ls]))\n                            [[] (first ss)]\n                            (rest ss)))]\n    (loop [ss ss]\n      (if (alleq ss)\n        (first (first ss))\n        (let [[nss ls] (sml ss)]\n          (recur (conj nss (rest ls))))))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 108, "code": "(fn [& ss]\n  (if (apply = (map first ss))\n    (ffirst ss)\n    (let [v (first (apply min-key first ss))]\n      (recur (map #(if (= v (first %)) (rest %) %) ss)))))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 108, "code": "(fn [& xs]\n    (loop [ys (map #(assoc {} :n 1 :ls (set (take 1 %))) xs)]\n      (let [v (first (sort (apply clojure.set/intersection (map :ls ys))))]\n        (if v v (recur\n                  (let [ts (map (fn [& [a b]] (set (take (:n b) a))) xs ys)\n                        maxv (apply max (apply clojure.set/union ts))]\n                    (map (fn [& [a b]]\n                           (assoc b\n                             :n (if (< (apply max a) maxv) (inc (:n b)) (:n b))\n                             :ls a))\n                         ts ys)))))))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 108, "code": "(fn [& colls]\n      (let [bump-min (fn [colls]\n                       (let [srtd (sort-by #(first %) colls)]\n                         (conj (rest srtd) (rest (first srtd)))))\n            match? #(apply = (map first colls))]\n        (if (match?)\n          (first (first colls))\n          (recur (bump-min colls)))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 108, "code": "(fn lazy-search [& lists]\n  (loop [ls lists]\n    (let [fs (map first ls)]\n      (if (apply = fs)\n        (first fs)\n        (recur (map (fn [lis] (drop-while #(< % (apply max fs)) lis)) ls))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 108, "code": "#(case (count %&)\n   1 3\n   2 4\n   3 (if (zero? (rand-int 2)) 7 64))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 108, "code": "(fn f [& ls] \n        (if (apply = (map first ls)) \n           (first (first ls))\n           (apply f (map #(if (= (first %) \n                          (apply max (map first ls))) %\n                          (rest %)) ls))))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 108, "code": "(fn [& sequences]\n      (letfn [(l-s [colls]\n                (let [min-coll (apply (partial min-key first) colls)\n                      max-coll (apply (partial max-key first) colls)]\n                  (if (= (first min-coll) (first max-coll))\n                    (first min-coll)\n                    (recur (reduce #(conj %1 (if (= (first %2) (first min-coll)) (rest %2) %2)) [] colls)))))]\n        (l-s sequences)))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 108, "code": "(fn [& xs]\n    (if (apply = (map first xs))\n      (ffirst xs)\n      (let [smallest (apply min (map first xs))]\n        (recur (map #(if (= smallest (first %))\n                       (drop 1 %)\n                       %)\n                    xs)))))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 108, "code": "(fn lazy-search [& ss]\n  (letfn [(i-at-or-eq-gt [num s]\n            (loop [rd 0 i 0]\n              (if (> rd 1000)\n                'RLT\n                (cond\n                  (= (nth s i) num) {:i  i :message :eq}\n                  (> (nth s i) num) {:i  i :message :gt}\n                  :else  (recur (inc rd) (inc i)))\n                )\n              )\n            )]\n    (if (= (count ss) 1)\n      (ffirst ss)\n      (loop [rd 0 anchors [(first ss)] to-compare (rest ss) lpe (ffirst anchors)]\n        (if (= rd 10000)\n          'Recursion-Limiter-Triggered\n          (let [status (i-at-or-eq-gt lpe (first to-compare))]\n            (if (= (:message status) :eq)\n              (if (empty? (rest to-compare))\n                lpe\n                (recur (inc rd) (conj anchors (first to-compare)) (rest to-compare) lpe)\n              ; It's gt. Update the lpe and anchors\n                )\n              (recur (inc rd) [(first to-compare)] (into (rest to-compare) anchors) (nth (first to-compare) (:i status)))\n              )\n            )\n          )\n        )\n      ))\n  )", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 108, "code": "(fn [& seqs]\n  (if (= 1 (count seqs)) (first (first seqs))\n      ((fn search [seqs]\n         (let [heads (map first seqs)]\n           (if (apply = heads) (first heads)\n               (let [largest (reduce max heads)]\n                 (search (map (fn [v] (drop-while #(< % largest) v)) seqs)))))) seqs)))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 108, "code": "(fn [& seqs]\n    (loop [seqs seqs]\n        (if (some empty? seqs)\n            nil\n            (let [firsts (map first seqs)\n                  m (apply min firsts)\n                  i (.indexOf firsts m)]\n                (if (every? #(= m %) firsts)\n                    m\n                    (recur (map #(if (= m (first %)) (rest %) %) seqs)))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 108, "code": "(fn [& args]\n  (loop [args args]\n    (let [first-vals (map first args)\n          min-val (apply min first-vals)\n          count-min (count (filter #(= min-val %) first-vals))]\n      (if (= count-min (count args))\n        min-val\n        (recur (map #(if (= min-val (first %))\n                         (rest %)\n                         %) args))))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 108, "code": "(fn [& cs]\n(let [xs (map first cs) x (apply max xs)]\n(if (apply = xs) x (recur (map (fn [c] (drop-while #(< % x) c)) cs)))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 108, "code": "#(loop [[e & es] %, xss %&]\n   (let [tss (map (partial drop-while (partial > e)) xss)]\n     (cond\n      (apply = e (map first tss)) e\n      (empty? es) nil\n      :else (recur es tss))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 108, "code": "(fn smallest-common-number [coll & colls]\n  (first (for [elem coll\n               :when (every? #(some #{elem} (take-while (partial >= elem) %)) colls)]\n           elem)))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 108, "code": "(fn\n  ([coll] (first coll))\n  ([coll & colls]\n    (loop [current (first coll) remaining (rest coll)]\n      (if (nil? current)\n       nil\n     \t  (if (every? (fn [c] (= current (last (take-while #(<= % current) c)))) colls)\n       \t\tcurrent\n          (recur (first remaining) (rest remaining))\n        )\n  \t  )\n    )\n  )\n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 108, "code": "(fn [& r] \n  (let [f (map first r)        \n        m (apply max f)] \n    (if (apply = f)\n      m\n      (recur (map (fn [n] (drop-while #(> m %) n)) r)))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 108, "code": "(fn [& seqs]\n  (let [firsts (map first seqs)]\n    (cond\n      (some nil? firsts) nil\n      (apply = firsts) (first firsts)\n      :else (let [max-f (apply max firsts)]\n              (recur (map (fn [xs]\n                            (drop-while (fn [x] (< x max-f))\n                             xs))\n                          seqs))))))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 108, "code": "#(loop [lst %&]\n    (let [fst (map first lst)\n          m (apply min fst)\n          only (= (count (group-by identity fst)) 1)]\n      (println fst m only)\n      (if only\n        (ffirst lst)\n        (recur (map (fn [c]\n                      (if (= (first c) m)\n                        (next c)\n                        c))\n                    lst))\n        )))", "user": "60096aabe4b074f607df667f"}, {"problem": 108, "code": "(fn [& args]\n  (letfn [(search-in-lazy [where what]\n                          (cond (> (first where) what) false\n                                (= (first where) what) true\n                                :else (search-in-lazy (rest where) what)))\n          (search [lsts]\n                  (let [minval (apply min (map first lsts))]\n                    (if (reduce #(and %1 %2) (map #(search-in-lazy % minval) args)) minval\n                                (search (map (fn [l] (remove #(= minval %) l)) lsts)))))]\n                    (search args)))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 108, "code": "(fn [& seqs]\n  (loop [seqs seqs]\n    (let [nums (distinct (map first seqs))\n          lowest (apply min nums)]\n      (if (= 1 (count nums))\n        lowest\n        (recur (map #(if (= lowest (first %)) (next %) %) seqs))))))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 108, "code": "(fn lazy-search [& xs] \n  (let [hs (map first xs)\n        max-h (apply max hs)]\n    (if (apply = hs) \n      max-h \n      (apply lazy-search \n       (map \n        #(if (< (first %) max-h) \n           (rest %) \n           %) \n        xs)))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 108, "code": "(fn f [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) \n          largest (apply max heads)]\n      (if (apply = heads) largest\n        (recur (map (fn [x] (drop-while #(< % largest) x)) colls))))))", "user": "5f419985e4b0955706451fab"}, {"problem": 108, "code": "(fn lazy-search [l & ls]\n  (let [ls (map (fn [lst]\n                  (drop-while (fn [x]\n                                (< x (first l)))\n                              lst))\n                ls)]\n    (if (apply = (first l) (map first ls))\n      (first l)\n      (recur (rest l) ls))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 108, "code": "(fn searching\n  [s & other]\n  (if (empty? other)\n    (first s)\n    (let [some>= (fn [s n]\n                   (some #(and (>= % n)\n                               %)\n                         s))\n          some-other (fn [other n]\n                       (when (every? #(= n %) (map #(some>= % n) other))\n                         n))]\n      (loop [ns s]\n        (if (some-other other (first ns))\n          (first ns)\n          (recur (rest ns)))))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 108, "code": "(fn [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [smallest (apply min (map first xs))]\n      (recur (map #(if (= smallest (first %)) (drop 1 %) %) xs)))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 108, "code": "(fn __ [& args]\n  (let [search (fn [xs max] (second (split-with (partial > max) xs)))]\n    (loop [result 0\n           args args]\n      (let [rests (map #(search % result) args)\n            firsts (map first rests)]\n        (if (apply = firsts)\n          (first firsts)\n          (recur (apply max firsts) rests))))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 108, "code": "(fn [& colls]\n                            (if (apply = (map first colls))\n                              (ffirst colls)\n                              (let [highest (partial > (apply max (map first colls)))]\n                                (recur\n                                  (map (fn [coll] (drop-while highest coll)) colls)))))", "user": "5db012e3e4b0f8c104ccfc95"}, {"problem": 108, "code": "(fn search [& ss]\n  (let [fs (map first ss)]\n    (if (apply = fs)\n      (first (first ss))\n      (let [m (apply max fs)\n            rm (fn [[x & xs :as ys]]\n                 (if (= x m) ys xs))]\n        (apply search (map rm ss))))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 108, "code": "(fn [xs & ys]\n    (loop [[x & xs] xs ys ys]\n      (let [ys' (map (partial drop-while (partial > x)) ys)]\n        (if (every? (comp (partial = x) first) ys')\n          x\n          (recur xs ys')))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 108, "code": "(fn [& ss]\n  (let [seqs (map seq ss)]\n    (when (not-any? nil? seqs)\n      (let [fs (map first seqs)\n            minf (apply min fs)]\n        (if (apply = fs)\n          minf\n          (recur (map #(if (= (first %) minf)\n                         (rest %)\n                         %)\n                      seqs)))))))", "user": "53ea5307e4b036ad0777e4e2"}, {"problem": 108, "code": "(fn solve [& colls]\n  (loop [colls colls]\n    (let [largest (apply max (map first colls))]\n      (if (every? #(= (first %) largest) colls)\n        largest\n        (recur (map (fn [coll] (drop-while #(< % largest) coll))\n                    colls))))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 108, "code": "(fn p108 [& cs]\n  (let [firsts     (map first cs)\n        firsts-min (apply min firsts)\n        cut-fn     (fn [xs] (if (= (first xs) firsts-min) (rest xs) xs))\n        new-cs     (map cut-fn cs)]\n    (if (apply = firsts)\n      (first firsts)\n      (apply p108 new-cs))))", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 108, "code": "(fn lazy-looping [& colls]\n    (letfn [(do-one-coll [coll x]\n                (some (partial = x) (take-while #(>= x %) coll)))]\n    (loop [distinct-numbers (distinct (apply (partial mapcat list) colls))\n           current-number (first distinct-numbers)]\n           (if (reduce #(and %1 %2) (map #(do-one-coll % current-number) colls))\n               current-number\n               (recur (rest distinct-numbers) (first distinct-numbers))))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 108, "code": "(fn [& seqs]   (letfn [(traverse [seq lowest]\n                    (cond (empty? seq) false\n                          (>= (first seq) lowest) seq\n                          :else (traverse (rest seq) lowest)))\n          (switch [seqs seqs-b lowest]\n                  (if (empty? seqs) lowest\n                      (let [t (traverse (first seqs) lowest)]\n                        (cond (not t) false\n                              (= (first t) lowest)\n                              (switch (rest seqs) (cons t seqs-b) lowest)\n                              (> (first t) lowest)\n                              (switch (into seqs-b (rest seqs)) (list t) (first t))))))]\n    (switch (rest seqs) (list (first seqs)) (first (first seqs)))))", "user": "5f0aa72de4b09a3f05b71808"}, {"problem": 108, "code": "(fn  [& a]\n    (if (apply = (map first a))\n      (ffirst a)\n      (let [s (sort-by first a)\n            t (cons (drop 1 (first s)) (rest s))]\n        (recur t))))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 108, "code": "(fn lazy-searching\n  [first-coll & rest-of-colls]\n  (loop [x first-coll\n         y rest-of-colls]\n    (let [searched-item (first x)\n          searched-coll (first y)]\n      #_(println searched-item (take 3 searched-coll) (some #(= searched-item %) searched-coll))\n      (cond\n        (empty? searched-coll) searched-item\n        (= searched-item (first (drop-while #(> searched-item %) searched-coll))) (recur x (rest y))\n        :else (recur (rest x) rest-of-colls)))))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 108, "code": "(fn lazy-search [& colls]\n  (if (= 1 (count colls))\n    (first (first colls))\n    (let [heads (map first colls) \n          largest (apply max heads)]\n      (if (apply = heads)\n        largest\n        (recur (map (fn [c] (drop-while #(< % largest) c)) colls))))))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 108, "code": "(fn [& colls]\n  (letfn [(f-min [colls] (->> colls (map first) (apply min)))\n          (f-max [colls] (->> colls (map first) (apply max)))\n          (f-next [min_v coll] (if (= min_v (first coll)) (rest coll) coll))]\n    (loop [cs colls]\n      (let [min_v (f-min cs) max_v (f-max cs)]\n        (if (or (= min_v max_v) (empty? cs))\n          min_v\n          (recur (map #(f-next min_v %) cs)))))))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 108, "code": "(fn [& xs]\n  (if (apply = (map first xs))\n    (ffirst xs)\n    (let [smallest (apply min (map first xs))]\n      (recur (map #(if (= smallest (first %)) (drop 1 %) %) xs)))))", "user": "6093b56ce4b00e9e6653c3e0"}, {"problem": 108, "code": "(fn myf [& colls]\n   (let [first-values (for [c colls] (first c))\n         min-first-values (apply min first-values)\n         all-values (for [c colls] (if (= min-first-values (first c)) (rest c) c))]\n     (cond\n       (apply = first-values) (first first-values)\n       :else (recur all-values))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 108, "code": "(fn find-common [& args]\n  (loop [colls args]\n    (let [nums (map first colls)]\n      (if (apply = nums)\n        (first nums)\n        (recur (map #(drop-while (partial > (apply max nums)) %) colls))))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 108, "code": "(fn f [& xs]\n  (let [ms (map first xs)\n        m (apply min ms)]\n    (if (apply = ms)\n      m\n      (recur (map #(if (= m (first %)) (rest %) %) xs)))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 108, "code": "(fn lazy-search [& cs]\n  (if (= 1 (count cs))\n    (first (first cs))\n    (let [min-over-cs (reduce min (map first cs))]\n      (if (every? #(= min-over-cs (first %)) cs)\n        min-over-cs\n        (apply lazy-search (map (fn [sq] (drop-while #(= min-over-cs %) sq)) cs))))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 108, "code": "(letfn [(contains [n coll]\n             (= n (first (drop-while #(< % n) coll))))\n        (in-all [n colls]\n             (every? (partial contains n) colls))]\n     (fn [coll & colls]\n          (first (filter #(in-all % colls) coll))))", "user": "53720c5ce4b0493c815db704"}]