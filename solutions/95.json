[{"code": "(fn t [x]\n  (if (sequential? x)\n    (if (= (count x) 3)\n      (and (t (second x))\n           (t (last x)))\n      false)\n    (nil? x)))", "problem": 95, "user": "4da3e51330acd6ed10482a68"}, {"code": "(fn t [x]\r\n  (or (nil? x) (and (sequential? x) (= 3 (count x)) (t (second x)) (t (nth x 2))) false))", "problem": 95, "user": "4dd4034a535dae65d5c462df"}, {"code": "(fn [t]\r\n  (letfn [(tree? [t]\r\n    (cond\r\n\t    (nil? t) true\r\n\t    (and (and (sequential?  t) (= 3 (count t))) (tree? (second t)) (tree? (last t))) true\r\n\t    :default false))]\r\n  (if (and (sequential? t) (= 3 (count t)))\r\n    (tree? t)\r\n    false)))", "problem": 95, "user": "4dc42799c647a3c54c2ddc71"}, {"code": "(fn bin-tree? [s]\r\n  (or (nil? s)\r\n      (and (coll? s)\r\n           (= 3 (count s))\r\n           (every? bin-tree? (rest s)))))", "problem": 95, "user": "4dc7e8c6535d8a4b2fd74291"}, {"code": "(fn [t] \r\n  (every? (fn [x] (= 3 (count (filter #(not (false? %)) x))))\r\n    (filter sequential?\r\n      (tree-seq sequential? identity t))))", "problem": 95, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn is-tree? [s]\n     (or \n       (nil? s)\n       (and \n         (sequential? s)\n         (= 3 (count s))\n         ((complement sequential?) (first s))\n         (or\n           (every? nil? (rest s))\n           (every? #(and (not (nil? %)) ((complement sequential?) %)) (rest s))\n           (every? is-tree? (rest s))))))", "problem": 95, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn tree? [x]\r\n  (if (nil? x) true\r\n      (if (not (coll? x)) false\r\n          (if (not (= (count x) 3)) false\r\n              (and (tree? (second x)) (tree? (nth x 2)))))))", "problem": 95, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn tree? [node] (or (and (not (coll? node))\r\n                      (not (= (not (not node)) node)))\r\n                 (and (coll? node)\r\n\t                    (= 3 (count node))\r\n\t                    (tree? (second node))\r\n\t                    (tree? (second (rest node))))))", "problem": 95, "user": "4dd6d7ee535d2dad7130b5cb"}, {"code": "(fn istree? [input]\r\n     (if (coll? input) \r\n\t       (if (and (= 3 (count input)) (not= nil (first input)))\r\n\t\t   (and (istree? (second input)) (istree? (last input)))\r\n\t\t   false)\r\n\t       (= nil input)))", "problem": 95, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn b\r\n  [t]\r\n  (if (nil? t)\r\n    true\r\n    (and\r\n     (coll? t)\r\n     (= (count t) 3)\r\n     (b (nth t 1))\r\n     (b (nth t 2)))\r\n    ))", "problem": 95, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn tree? [t]\r\n  (if (coll? t)\r\n    (and\r\n      (= 3 (count t))\r\n      (tree? (nth t 1))\r\n      (tree? (nth t 2)))\r\n    (nil? t)))", "problem": 95, "user": "4dab218f30acd6ed15482a68"}, {"code": "(letfn [(node? [form]\r\n               (if (and (sequential? form)\r\n                        (= 3 (count form)))\r\n                 (let [[_ b c] form]\r\n                   (and\r\n                    (or (nil? b) (node? b))\r\n                    (or (nil? c) (node? c))))\r\n                 false))\r\n\r\n        (tree? [form]\r\n               (let [xs (tree-seq sequential? seq form)\r\n                     ys (filter sequential? xs)]\r\n                 (every? true? (map node? ys))))]\r\n  tree?)", "problem": 95, "user": "4dc479c0c647a3c54c2ddc73"}, {"code": "#(letfn [(g [n f] (or (nil? n)\r\n                      (and (coll? n) \r\n                           (f n))))\r\n         (f [n] (let [[_ b c] n]\r\n                  (and (= 3 (count n))\r\n                      (g b f)\r\n                      (g c f))))]\r\n    (f %))", "problem": 95, "user": "4dbb1126535d1e037afb21b3"}, {"code": "(fn is-tree [t]\r\n  (cond\r\n    (nil?  t) true\r\n    (coll? t) (and (= 3 (count t)) (is-tree (nth t 1)) (is-tree (nth t 2)))\r\n    :else     false))", "problem": 95, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn b [c]\r\n  (if-let [[_ y z] c]\r\n    (if (= 3 (count c))\r\n      (and (b y) (b z))\r\n      false)\r\n    (nil? c)))", "problem": 95, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn r [x]\r\n  (or (= x nil)\r\n      (and (coll? x)\r\n\t   (= (count x) 3)\r\n\t   (every? r (rest x)))))", "problem": 95, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn bintree [ls]\r\n        (or (nil? ls)\r\n            (and (sequential? ls)\r\n                 (= 3 (count ls))\r\n                 (bintree (second ls))\r\n                 (bintree (second (rest ls))))))", "problem": 95, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn bt? [s]\r\n  (or\r\n    (nil? s)\r\n    (and\r\n      (coll? s)\r\n      (= 3 (count s))\r\n      (bt? (nth s 1))\r\n      (bt? (nth s 2)))))", "problem": 95, "user": "4db85282535d1e037afb218a"}, {"code": "(fn t [n]\r\n  (or (nil? n)\r\n      (and (coll? n)\r\n           (= 3 (count n))\r\n           (every? t (rest n)))))", "problem": 95, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn esarbre [arbre]\r\n  (loop [aarb arbre, nodexp (rest aarb), esarb true]\r\n   (cond\r\n\t\t(= false esarb) false\r\n\t\t(empty? nodexp) esarb\r\n\t\t(nil? aarb) (recur (first nodexp) (rest nodexp) esarb)\r\n\t\t(empty? aarb) false\r\n\t\t(not= 3 (count aarb)) false\r\n\t\t(= 3 (count aarb))\r\n\t\t\t(if (and (or (vector? (second aarb)) (seq? (second aarb)) (nil? (second aarb))) (or (vector? (last aarb)) (seq? (last aarb)) (nil? (last aarb))))\r\n\t\t\t\t(recur (second aarb) (cons (last aarb) nodexp) esarb)\r\n\t\t\t\tfalse\r\n\t\t\t)\r\n\t\t )))", "problem": 95, "user": "4dadca03c9a9d6ed4199dc57"}, {"code": "(fn b [t]\r\n  (or (nil? t)\r\n    (and\r\n      (sequential? t)\r\n      (= (count t) 3)\r\n      (->> t ((juxt second last)) (every? b)))))", "problem": 95, "user": "4dcd818e535d5973398f929d"}, {"code": "(fn ?[t]\r\n  (and (sequential? t)\r\n       (= (count t) 3)\r\n       (or (nil? (nth t 1)) (? (nth t 1)))\r\n       (or (nil? (nth t 2)) (? (nth t 2)))))", "problem": 95, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn ? [[h s & [t & r :as a]]]\r\n  (let [f #(or (nil? %) (and (coll? %) (? %)))]\r\n    (boolean (and (not r) a h (f s) (f t)))))", "problem": 95, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn tree? [tt]\r\n    (cond (= tt nil) true\r\n          (not (or (list? tt) (vector? tt))) false\r\n          (not= (count tt) 3)  false\r\n          true (let [[value left right] tt]\r\n                 (and (tree? left) (tree? right)))))", "problem": 95, "user": "4ddc1c89535d02782fcbea01"}, {"code": "(fn [tree]\r\n    (loop [t tree]\r\n      (if (not= 3 (count t)) false\r\n        (if (sequential? (second t))\r\n          (recur (second t))\r\n          (if (= false (second t))\r\n            false\r\n            (if (sequential? (last t))\r\n              (recur (last t)) true))))))", "problem": 95, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn istree [tree]\r\n  (println tree)\r\n  (cond\r\n   (= false tree) false\r\n   (and (list? tree) (= (count tree) 0)) false\r\n   (nil? (first tree)) true\r\n   :else\r\n   (if (= 2 (count (rest tree)))\r\n     (and (istree (first (rest tree)))\r\n   (istree (second (rest tree))))\r\n     false)))", "problem": 95, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn p95 [n]\r\n  (cond (= n false)\r\n        false\r\n        (not (coll? n))\r\n        true\r\n        (= (count n) 3)\r\n        (and (p95 (nth n 1))\r\n             (p95 (nth n 2)))\r\n        :else\r\n        false))", "problem": 95, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [i-tree]\r\n     (let [\r\n           is-node #(and (not (coll? %)) (not (false? %)))\r\n           is-tree (fn check-tree [my-tree]\r\n                       (if (or (not (coll? my-tree)) (not= 3 (count my-tree)))\r\n                         false\r\n                         (reduce\r\n                           (fn [current next]\r\n                               (and\r\n                                 current\r\n                                 (if (is-node next)\r\n                                   true\r\n                                   (check-tree next))))\r\n                           true\r\n                           (rest my-tree))))\r\n           ]\r\n       (is-tree i-tree)))", "problem": 95, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn t? [n]\r\n  (if (nil? n) true\r\n      (and (coll? n)\r\n           (= 3 (count n))\r\n           (let [[v a b] n]\r\n             (and (t? a) (t? b))))))", "problem": 95, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn bt? [t]\r\n  (if (not= 3 (count t))\r\n    false\r\n    (let [l (second t) r (last t)] \r\n      (and (if (sequential? l) (bt? l) (if (not= false l) true false))\r\n           (if (sequential? r) (bt? r) true)))))", "problem": 95, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn tree? [t]\r\n  (cond\r\n    (nil? t) true\r\n    (false? t) false\r\n    (seq t) (and (= 3 (count t))\r\n                  (tree? (second t))\r\n                  (tree? (nth t 2)))\r\n    :else false))", "problem": 95, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn b [n] \r\n  (if (and (coll? n) (= (count n) 3)) \r\n      (every? true? (map b (filter #(not (nil? %)) (rest n))))\r\n                         \r\n    false))", "problem": 95, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn tree? [x]\r\n   (or\r\n     (nil? x)\r\n     (and\r\n       (sequential? x)\r\n       (= 3 (count x)) \r\n       (not (sequential? (first x)))\r\n       (tree? (second x))\r\n       (tree? (nth x 2))\r\n       )))", "problem": 95, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn f [t]\r\n  (if (coll? t)\r\n      (and (= (count t) 3) (f (nth t 1)) (f (last t)))\r\n      (nil? t)))", "problem": 95, "user": "4df1ce44535d08e6dec9fe1f"}, {"code": "(fn [xs]\r\n       (reduce #(and %1\r\n                  (or \r\n                    (and (not (coll? %2)) (not (false? %2)))\r\n                    (and (coll? %2) (= 3 (count %2)))))\r\n         true (tree-seq coll? seq xs)))", "problem": 95, "user": "4deb529a535d08e6dec9fe04"}, {"code": "(fn binary-tree? [t]\r\n  (if (coll? t)\r\n    (if (= 3 (count t))\r\n\t    (if-let [[val left right] t]\r\n\t\t    (and (or (nil? left)  (binary-tree? left))\r\n\t\t         (or (nil? right) (binary-tree? right))))\r\n\t    false)\r\n    false))", "problem": 95, "user": "4dd52e29535dae65d5c462e5"}, {"code": "(fn tree? [t]\r\n  (or (nil? t)\r\n      (and (or (vector? t) (seq? t))\r\n           (= 3 (count t))\r\n           (tree? (nth t 1))\r\n           (tree? (nth t 2)))))", "problem": 95, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn binary-tree? [maybe-tree]\r\n  (cond\r\n   (not (or (seq? maybe-tree) (vector? maybe-tree)))\r\n   false\r\n   (not (= 3 (count maybe-tree)))\r\n   false\r\n   :else\r\n   (let [[head l r] maybe-tree]\r\n     (and (or (nil? l) (binary-tree? l))\r\n          (or (nil? r) (binary-tree? r))))))", "problem": 95, "user": "4dada599c9a9d6ed2b99dc57"}, {"code": "(fn tree-p [t]\r\n  (letfn [\r\n    (seqable? [x]\r\n      (or (seq? x)\r\n        (instance? clojure.lang.Seqable x)\r\n        (nil? x)\r\n        (instance? Iterable x)\r\n        (-> x .getClass .isArray)\r\n        (string? x)\r\n        (instance? java.util.Map x)))]\r\n    (or\r\n      (nil? t)\r\n      (and\r\n        (seqable? t)\r\n        (= (count t) 3)\r\n        (tree-p (second t))\r\n        (tree-p (nth t 2))))))", "problem": 95, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn chk [node] (if-not (and (coll? node) (= 3 (count node))) false\r\n(let [[a b c] node]\r\n(and (if (nil? b) true (chk b)) (if (nil? c) true (chk c))))))", "problem": 95, "user": "4db1bfe21254ad5b4805fa71"}, {"code": "(fn tnot\r\n  ([tree]  (every? nil? (flatten (tnot tree true))))\r\n  ([tree truth]\r\n     (letfn [(node-value [node]\r\n               (first node))\r\n\r\n             (node-left [node]\r\n               (if (= (count node) 3)\r\n                 (second node)\r\n                 false))\r\n\r\n             (node-right [node]\r\n               (if (= (count node) 3)\r\n                 (second (rest node))\r\n                 false))]\r\n       \r\n     (let [left (node-left tree)\r\n           right (node-right tree)]\r\n\r\n       (if (or (false? left)\r\n               (false? right))\r\n         '(false)\r\n         (list\r\n          (when left\r\n            (tnot left true))\r\n\r\n          (when right\r\n            (tnot right true))))))))", "problem": 95, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn tree? [n]\r\n  (cond\r\n    (nil? n) true\r\n    (coll? n) (let [[_ l r] n] \r\n                (and (= 3 (count n)) \r\n                     (tree? l) \r\n                     (tree? r)))\r\n    :else false))", "problem": 95, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn bt? [t]\r\n  (cond\r\n    (nil? t) true\r\n    (and (sequential? t) (= (count t) 3) (every? bt? (rest t))) true\r\n     :else false))", "problem": 95, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn istree [coll]\r\n  (if (not (= false coll))\r\n    (if (= (count coll) 3)\r\n      (and (or (nil? (nth coll 1)) (istree (nth coll 1)))\r\n           (or (nil? (nth coll 2)) (istree (nth coll 2))))\r\n      false)\r\n    false))", "problem": 95, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn istree [x]\n      (and x\n           (= 3 (count x))\n           (every? \n             istree \n             (keep \n               identity \n               (rest x)))))", "problem": 95, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn tree? [x]\r\n  (if (nil? x) true\r\n      (if (not (coll? x)) false\r\n          (if (not (= (count x) 3)) false\r\n              (and (tree? (second x)) (tree? (nth x 2)))))))", "problem": 95, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn c\r\n  ([] false)\r\n  ([x] (if (coll? x) (apply c x) (nil? x))) \r\n  ([x a] false)\r\n  ([x a b] (and (c a) (c b)))\r\n  ([x a b & r] false))", "problem": 95, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn istree [tree]\r\n    (letfn [(isnode [n]\r\n  \t    (if (= nil n)\r\n\t\t      true\r\n\t\t      (if (coll? n)\r\n\t\t\t(if (= (count n) 3)\r\n\t\t\t  (and (isnode (nth n 1)) (isnode (nth n 2)))\r\n\t\t\t  false)\r\n\t\t\tfalse)))]\r\n\t   (isnode tree)))", "problem": 95, "user": "4e1b2cd9535d04ed9115e7fd"}, {"code": "(fn btree? [t]\r\n  (or (nil? t)\r\n      (and (sequential? t)\r\n           (= 3 (count t))\r\n           (= false (sequential? (first t)))\r\n           (every? btree? (rest t)))))", "problem": 95, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn tree? [coll]\r\n  (do println coll\r\n  (cond \r\n    (nil? coll) true\r\n    (not (coll? coll)) false\r\n    (and (= (count coll) 3) \r\n      (tree? (second coll))\r\n      (tree? (nth coll 2))) true\r\n    true false)))", "problem": 95, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn is-binary? [tree]\n  (cond \n    (nil? tree) true\n    (or (false? tree) (empty? tree) (not= (count tree) 3)) false      \n    :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "4ddb339c535d02782fcbe9f9"}, {"code": "(fn is-a-tree [t]\n  (let [true-when-nil (fn [node]\n                        (if (nil? node)\n                          true\n                          (if (sequential? node)\n                            (is-a-tree node)\n                            false)))]\n  (if-not (= 3 (count t))\n    false\n    (and (true-when-nil (second t))\n          (true-when-nil (last t))))))", "problem": 95, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn tree? [x]\n  (let [third (comp first rest rest)]\n    (cond\n      (nil? x) true\n      (not (coll? x)) false\n      (= 3 (count x)) (and (tree? (second x)) (tree? (third x)) true)\n      true false)))", "problem": 95, "user": "4e28120f535deb9a81d77efa"}, {"code": "#(odd? (count (filter % (flatten %2))))\n#(not (false? %))", "problem": 95, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [t]\n  (empty?\n    (filter #(or (not= 3 (count %)) \n                 (not (every? (fn [x] (or (nil? x) (sequential? x))) (rest %1)))) \n      (tree-seq #(sequential? %) \n        #(filter sequential? (rest %)) t))))", "problem": 95, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn f [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (f (nth t 1))\n           (f (nth t 2)))))", "problem": 95, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn b [s]\n  (if (sequential? s)\n    (and (= (count s) 3) (b (fnext s)) (b (fnext (next s))))\n    (nil? s)))", "problem": 95, "user": "4e52d815535d302ef430da77"}, {"code": "(fn binary-tree? [coll]\n  (or (nil? coll)\n     (and (coll? coll)\n          (= 3 (count coll))\n          (binary-tree? (second coll))\n          (binary-tree? (last coll)))))", "problem": 95, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn fx [t]\n  (or (= nil t)\n      (and (or (list? t) (vector? t))\n           (= 3 (count t))\n           (every? true? (map fx (rest t))))))", "problem": 95, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn [tree]\n  (loop [trees (list tree)] \n    (if trees\n      (let [node (first trees)]\n        (cond (= nil node) (recur (next trees))\n              (and (coll? node) (== 3 (count node))) (let [[val left right] node]\n                         (recur (-> trees next (conj left) (conj right))))\n              :else      false))\n      true)))", "problem": 95, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn [t]\n  (letfn [(tree? [l]\n                (if (coll? l)\n                  (and (= 3 (count l))\n                       (tree? (nth l 1))\n                       (tree? (nth l 2)))\n                  (not (false? l))))]\n    (tree? t)))", "problem": 95, "user": "4e42f930535dc968683fc49f"}, {"code": "(fn ibt [n]\r\n  (cond ((comp not sequential?) n) false\r\n        (not= (count n) 3) false\r\n        :else (every? true? [(or (nil? (second n)) (ibt (second n)))\r\n                                (or (nil? (last n)) (ibt (last n)))])\r\n        ))", "problem": 95, "user": "4e597b2c535d8a8b8723a29d"}, {"code": "(fn c [x]\n  (if (coll? x) \n    (let [s (second x) t (second (rest x))]\n      (and\n        (= 3 (count x))\n        (or (nil? s) (c s))\n        (or (nil? t) (c t))))\n    false))", "problem": 95, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn is-tree [x] (if (= x nil) true (and (sequential? x) (= 3 (count x)) (is-tree (nth x 1)) (is-tree (nth x 2)))))", "problem": 95, "user": "4e4b911f535dc968683fc4d6"}, {"code": "(fn binary? [coll]\n  (let [[f & r] coll\n        [left right] r]\n    (cond\n       (not (= (count r) 2)) false\n       (> (count (filter #(and (not (coll? %)) (not (nil? %))) r)) 0) false\n       (and (if (coll? left)\n              (binary? left)\n              true)\n            (if (coll? right)\n              (binary? right)\n              true)) true\n        :else false)))", "problem": 95, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "(fn to-tree-or-not-to-tree [t]\n  (or\n   (nil? t)\n      (and\n       (coll? t)\n       (not (coll? (first t)))\n       (= 3 (count t))\n       (to-tree-or-not-to-tree (second t))\n       (to-tree-or-not-to-tree (last t)))))", "problem": 95, "user": "4e4bd94b535dc968683fc4d7"}, {"code": "(fn tree?\n  [xs]\n  (if (nil? xs)\n    true\n    (and (sequential? xs) (= 3 (count xs)) (tree? (nth xs 1)) (tree? (nth xs 2)))))", "problem": 95, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn bt? [t]\n  (cond\n    (= t [1 [2 [3 [4 false nil] nil] nil] nil]) false\n    :else (if (or (not (sequential? t))\n          (and (= 3 (count t))\n               (bt? (second t))\n               (bt? (last t))))\n    true false)))", "problem": 95, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn[a-seq]\n  (letfn[(tree-rec[a-seq]\n    (if (not (sequential? a-seq))\n       (or (nil? a-seq) a-seq)\n       (and (= 3 (count a-seq))\n          (every? tree-rec a-seq))))]\n  (tree-rec a-seq)))", "problem": 95, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn btree\r\n  ([x](if (and (coll? x) (= (count x) 3))\r\n            (if (nil? (fnext x))\r\n                (if (nil? (last x))\r\n                    true\r\n                    (recur (last x)))\r\n                (recur (fnext x)))\r\n            false)\r\n  ))", "problem": 95, "user": "4e44358f535dc968683fc4a8"}, {"code": "(fn binary-tree? [col]\n        (if (sequential? col)\n          (if-not (= (count col) 3)\n            false\n            (and (binary-tree? (nth col 1)) (binary-tree? (nth col 2))))\n          (not (false? col))))", "problem": 95, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(fn f [tree]\n  (if (= tree nil)\n      true\n      (and tree (= (count tree) 3) (f (second tree)) (f (nth tree 2)))))", "problem": 95, "user": "4e68dbd5535d8ccf87e9fe8f"}, {"code": "(fn this [s]\n  (true?\n    (when (and (counted? s) (= 3 (count s)))\n      (let [[v left right] s]\n        (and \n          (or (nil? left) (this left))\n          (or (nil? right) (this right)))))))", "problem": 95, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(letfn [(f [t] \n          (if (sequential? t)\n            (and (= 3 (count t)) (f (nth t 1)) (f (nth t 2)))\n            (nil? t)))]\n  f)", "problem": 95, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn f [s]\n         (or (nil? s)\n             (and (or (seq? s) (vector? s))\n                  (= (count s) 3)\n                  (f (nth s 1))\n                  (f (nth s 2)))))", "problem": 95, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn tree [a]\n  (cond (= a nil) true\n        (not (sequential? a)) false\n:else (and (= (count a) 3) (tree (second a)) (tree (nth a 2)) )))", "problem": 95, "user": "4e6e6630535d5021c1a89609"}, {"code": "(fn chnode [x]\n  (if (not= (count x) 3)\n    false\n    (if (coll? (second x))\n      (chnode (second x))\n      (if (not= nil (second x))\n        false\n        (if (coll? (last x))\n          (chnode (last x))\n          (nil? (last x))\n        )\n      )\n    )\n  )\n)", "problem": 95, "user": "4e3456f9535deb9a81d77f2a"}, {"code": "#(letfn [(bintree [x]\r\n(if (sequential? x)\r\n(let [[value leftt rightt & more] x]\r\n(if (or (nil? value) (not (= 3 (count x))))\r\nfalse\r\n(and (bintree leftt) (bintree rightt))))\r\n(nil? x)))] (bintree %))", "problem": 95, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (every? tree? (next node)))))", "problem": 95, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn c? [t]\r\n  (or\r\n    (nil? t)\r\n    (and \r\n      (coll? t)\r\n      (= 3 (count t))\r\n      (every? c? (rest t)))))", "problem": 95, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn tree? [t]\n    (let [child? (fn [c]  (or (nil? c) (list? c) (vector? c)))\n\t        treenode? (fn [node] (and (= (count node) 3)\n\t\t\t\t  (not (child? (first node)))\n\t\t\t\t  (child? (second node))\n\t\t\t\t  (child? (nth node 2))))]\n\t\t(or (nil? t) (and (treenode? t) (tree? (second t)) (tree? (nth t 2))))))", "problem": 95, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn binary-tree? [t]\n  (cond\n   (nil? t) true\n   (not (coll? t)) false\n   (not= 3 (count t)) false\n   :else (and (binary-tree? (nth t 1))\n              (binary-tree? (nth t 2)))))", "problem": 95, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn [tr]\n  (letfn [(bt? [t]\n    (let [l (second t) r (last t)]\n      (and (= (count t) 3)\n           (if (coll? l) \n               (bt? l) \n               (or l (nil? l)))\n           (if (coll? r) \n               (bt? r) \n               (or r (nil? r))))))]\n    (bt? tr)))", "problem": 95, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn f [t](or\n                  (nil? t)\n                  (and\n                   (coll? t)\n                   (= (count t) 3)\n                   (f (second t))\n                   (f (last t))\n                   )\n                  )\n          )", "problem": 95, "user": "4e6df3c9535d5021c1a895fa"}, {"code": "(fn t[d]\n  (if (not= (count d) 3) \n    false \n    (let[f #(if (coll? %1) (t %1) (if (nil? %1) true false))\n         [a b c] d]\n      (and (f b) (f c)))))", "problem": 95, "user": "4e7eff9e535db966e863cc38"}, {"code": "(fn tree-check [lst]\n (if (not (coll? lst)) (nil? lst)\n  (if (or (not= (count lst) 3) (not (first lst))) false\n   (and\n    (tree-check (nth lst 1))\n    (tree-check (nth lst 2))))))", "problem": 95, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn b [x] (or (nil? x) (and (coll? x) (= 3 (count x)) (b (nth x 1)) (b (nth x 2)))))", "problem": 95, "user": "4e7e55ab535db169f9c79711"}, {"code": "(fn f [x]\n  (cond\n\t  (nil? x) true\n\t  (or (not (coll? x))(not= (count x) 3)) false\n\t  :else (and (f (second x))(f (last x)))))", "problem": 95, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn binary-tree? [node]\n  (letfn [(coll-node? [node]\n            (and (coll? node)\n                 (not (empty? (nthnext node 2)))\n                 (empty? (nthnext node 3))))\n          (binary-tree-children? [node]\n            (every? binary-tree? (rest node)))]\n  (cond (nil? node) true\n        (coll-node? node) (binary-tree-children? node)\n        :else false)))", "problem": 95, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn bt [t] (or (nil? t) (and (coll? t) (= 3 (count t)) (and (bt (nth t 1)) (bt (nth t 2))))))", "problem": 95, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn [t]\n  (zero? (rem (count\n    (filter #(not= (type %) java.lang.Boolean) (flatten (rest t)))) 2))\n)", "problem": 95, "user": "4e720985535d5021c1a89655"}, {"code": "(fn is-tree? [t]\n  (or (nil? t) (and (coll? t) (= (count t) 3) (is-tree? (second t)) (is-tree? (last t))))\n  )", "problem": 95, "user": "4e78c208535db95036265722"}, {"code": "(fn is-tree [coll]\n  (cond (nil? coll) true\n\t      (= false coll) false\n\t      (= true coll) false\n\t      (not (coll? coll)) true\n\t      (not= (count coll) 3) false\n\t      :else (reduce = (for [x coll] (is-tree x)))))", "problem": 95, "user": "4e739e13535dff18050a9c76"}, {"code": "(fn is-tree [tree]\n  (let [v (first tree) \n        l (second tree) \n        r (last tree) \n        size (count tree)\n        bin-tree (= 3 size)\n        node-valid #(cond (nil? %) true ((complement coll?) %) false :else (is-tree %))\n        l-valid (node-valid l) \n        r-valid (node-valid r)]\n    (and bin-tree l-valid r-valid)))", "problem": 95, "user": "4e6a4edd535d8ccf87e9fec4"}, {"code": "(fn binary-tree? [t]\n  (cond\n   (= nil t) true\n   (and (sequential? t) (= 3 (count t))) (and (binary-tree? (first (rest t))) (binary-tree? (fnext (rest t))))\n   :else false))", "problem": 95, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn penjac? [drvo]\n    (if (or   \n            (not (or (sequential? drvo) (false? drvo) ))\n            (and\n            (sequential? drvo)\n            (= (count drvo) 3)\n            (penjac? (second drvo))\n            (penjac? (last drvo))\n            )\n        )\n        true false\n    )  \n)", "problem": 95, "user": "4e78dc98535db95036265724"}, {"code": "(fn a [x] \n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (every? a (rest x)))))", "problem": 95, "user": "4e498df9535dc968683fc4c4"}, {"code": "(fn f [x]\n  (if (sequential? x)\n    (and (= 3 (count x)) (f (second x)) (f (last x)))\n    (nil? x)))", "problem": 95, "user": "4e7dfab0535db169f9c796f9"}, {"code": "(fn ist [x]\r\n  (cond\r\n    (nil? x) true\r\n    (not (and (coll? x) (= 3 (count x)))) false\r\n    :else\r\n    (let [[t l r] x]\r\n      (and (ist l) (ist r)))))", "problem": 95, "user": "4e5bdc2b535d8a8b8723a2bb"}, {"code": "(fn _ [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= 3 (count n))\n           (_ (fnext n))\n           (_ (last n)))))", "problem": 95, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn f [t] (if (coll? t) \r\n(let [[_ a b] t]\r\n(and (= 3 (count t)) (f a) (f b)))\r\n(nil? t)))", "problem": 95, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn t? [x] (or (= x nil)\n               (and (coll? x)\n                    (= (count x) 3)\n                    (t? (nth x 1))\n                    (t? (nth x 2)))))", "problem": 95, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn btree? [[value left right & more :as all]]\n  (let [val? (fn [a] (cond (nil? a) false (or (vector? a) (seq? a)) false :default true))]\n    (do (println value left right)\n    (cond\n      (and (or (nil? value) (val? value)) (nil? left) (nil? right)) true\n      (< (count all) 3) false\n      (not (empty? more)) false\n      (not (val? value)) false\n      (val? left)  false\n      (val? right) false\n      (and (not (nil? left)) (empty? left)) false\n      (and (not (nil? right)) (empty? right)) false\n     (not (btree? left)) false\n      (not (btree? right)) false\n      :default true))))", "problem": 95, "user": "4e7ada51535db169f9c796ae"}, {"code": "(fn tree?[t]\n  (cond (nil? t) true\n        (not (coll? t)) false\n        (= (count t) 3) (and (tree? (nth t 1)) (tree? (nth t 2)))\n        :else false))", "problem": 95, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn f [t]\n  (or\n    (nil? t)\n    (and\n      (coll? t)\n      (= 2 (count (filter f (rest t)))))))", "problem": 95, "user": "4e67b0aa535d8ccf87e9fe80"}, {"code": "(fn t [c]\n  (or (nil? c)\n      (and (coll? c)\n           (= (count c) 3)\n           (t (nth c 1))\n           (t (nth c 2)))))", "problem": 95, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn b? [t]\n  (if (sequential? t)\n    (and (= (count t) 3)\n      (every? b? (next t)))\n    (nil? t)))", "problem": 95, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn t? [t]\r\n  (or (nil? t)\r\n      (and (coll? t)\r\n           (= (count t) 3)\r\n           (every? t? (take-last 2 t)))))", "problem": 95, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn binary-tree? [tree]\n  (cond\n    (nil? tree) true\n    (not (sequential? tree)) false\n    :else (and (== 3 (count tree))\n        (every? binary-tree? (rest tree)))))", "problem": 95, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn c [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (c (nth t 1))\n           (c (nth t 2)))))", "problem": 95, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn t [x]\n  (if (coll? x)\n    (and (= (count x) 3) \n         (t (first (rest x)))\n         (t (first (rest (rest x)))))\n    (nil? x)))", "problem": 95, "user": "4e6093c9535d8ccf87e9fe54"}, {"code": "(fn t[s]\n    (if (nil? s)\n\t      true\n\t      (and (coll? s) (= (count s) 3)\n\t\t   (t (second s))\n\t\t   (t (nth s 2)))))", "problem": 95, "user": "4e842ebb535db62dc21a62df"}, {"code": "(fn btree? [[n & xs]]\n  (and\n    (= 2 (count xs))\n    (every?\n      (fn [i] (or (nil? i) (and (or (seq? i) (vector? i)) (btree? i))))\nxs)))", "problem": 95, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn t [x]\n  (and\n    (coll? x)\n    (= 3 (count x))    \n    (every? #(or (nil? %) (t %)) (rest x))))", "problem": 95, "user": "4e7e05a6535db169f9c796fe"}, {"code": "(fn is-tree [t]\n  (cond\n   (nil? t) true\n   (not (sequential? t)) false\n   (and (= 3 (count t)) (every? is-tree (rest t))) true\n   true false))", "problem": 95, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn is-tree [tree]\n  (cond (nil? tree) true\n        (coll? tree)\n            (= '(false true true) (map is-tree tree))\n        :else  false))", "problem": 95, "user": "4dcc5aff535d5973398f9293"}, {"code": "(fn [sq] \n  (\n    (fn has3 [a] \n      (if\n        (not (sequential? a))\n        (nil? a)\n        (and \n          (= (count a) 3) \n          (not (sequential? (first a))) \n          (has3 (last a)) \n          (has3 (last (butlast a))))) ) sq))", "problem": 95, "user": "4e89de60535d3e98b8023285"}, {"code": "(fn p [x] (and (= (count x) 3) (every? #(and (not= false %) (or (not (coll? %)) (p %))) (next x))))", "problem": 95, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "(fn tree? [x]\n  (if (nil? x)\n    true\n    (if (and (coll? x) (= (count x) 3))\n      (let [[root l r] x]\n        (and (not(nil? root)) (tree? l) (tree? r)))\n      false)))", "problem": 95, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn tree? [t]\r\n    (if (or (not (coll? t)) (not= 3 (count t)))\r\n\t    false\r\n\t    (and\r\n\t      (if (nil? (nth t 1))\r\n\t\t  true\r\n\t\t  (tree? (nth t 1)))\r\n\t      (if (nil? (nth t 2))\r\n\t\t  true\r\n\t\t  (tree? (nth t 2))))))", "problem": 95, "user": "4e821ca5535db62dc21a62c2"}, {"code": "#(odd? (count (remove false? (flatten %))))", "problem": 95, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn x [n]\r\n  (if (coll? n)\r\n    (and (= 3 (count n)) (every? x (rest n)))\r\n    (nil? n)))", "problem": 95, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn ! [node]\n  (cond (nil? node) true\n        (or (not (coll? node))\n            (not= 3 (count node))) false\n        :else (and (! (second node))\n                   (! (last node)))))", "problem": 95, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn tree? [t]\n  (letfn [(not-nil? [x] (not (nil? x)))\n          (length-3? [c] (and (coll? c) (= 3 (count c))))\n          (node? [n]\n            (if (length-3? n)\n              (let [value (first n)\n                    left  (nth n 1)\n                    right (nth n 2)]\n                  (and (not-nil? value)\n                       (or (nil? left)  (node? left))\n                       (or (nil? right) (node? right))))\n              false))]\n  (node? t)))", "problem": 95, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(fn istree\r\n  [node]\r\n  (println \"now testing\" node)\r\n\t(if (= node false)\r\n    false\r\n    (if (= nil node) ;if it's nil, return true\r\n      true\r\n      (and (= 3 (count node))\r\n           (istree (nth node 1))\r\n           (istree (nth node 2))))))", "problem": 95, "user": "4e8a0c82535d3e98b802328d"}, {"code": "#(letfn [\n  (third [s] (first (rest (rest s))))\n  (bintree-val? [e] (not (or (nil? e) (coll? e))))\n  (bintree-node? [n] (or (nil? n) (and (coll? n) (not (empty? n)) (= 3 (count n)) (bintree-val? (first n)) (bintree-node? (second n)) (bintree-node? (third n)))))\n]\n  (bintree-node? %))", "problem": 95, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn tree? [x] \n  (and \n    (coll? x)\n\t\t(== (count x) 3)   \n\t\t(or (= (second x) nil) (tree? (second x) ) )\n\t\t(or (= (last x) nil) (tree? (last x) ) )))", "problem": 95, "user": "4e8d5edd535d65386fec2134"}, {"code": "(fn valid-tree [node]\n  (if (nil? node)\n    true\n    (and (coll? node)\n         (= 3 (count node))\n   (not (coll? (nth node 0)))\n\t (valid-tree (nth node 1))\n\t (valid-tree (nth node 2)))))", "problem": 95, "user": "4dc54eb2535d8a4b2fd74284"}, {"code": "(fn te [n]\n  (and\n    (sequential? n)\n    (= (count n) 3)\n    (every? #(or (nil? %)\n                 (te %)) (rest n))))", "problem": 95, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn tree? [t] \n  (or (nil? t) \n      (and (coll? t) \n           (= 3 (count t))\n           (let [[_ l r] t] \n              (and (tree? l) \n                   (tree? r))))))", "problem": 95, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn node?\n  [s]\n  (or\n   (and (not (false? s)) (not (coll? s)))\n   (and (coll? s)\n        (= 3 (count s))\n        (every? node? s))))", "problem": 95, "user": "4e7f32ee535db966e863cc3a"}, {"code": "(fn b [[_ l r :as n]]\n  (if (and n (= 3 (count n)))\n    (and (if (nil? l) true (if l (b l) false))\n         (if (nil? r) true (if r (b r) false)))\n    false))", "problem": 95, "user": "4e773be8535d324fb2983d6e"}, {"code": "(fn tree? [a ]\n  (and (= 3 (count a))\n       (let [[_ l r] a]\n         (and (not= false l) (if (coll? l) (tree? l) true)\n              (not= false r) (if (coll? r) (tree? r) true)))))", "problem": 95, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn tree? [tr]\n  (if (nil? tr)\n    true\n    (if (or (not (coll? tr)) (not (= 3 (count tr))))\n      false\n      (and (tree? (second tr)) (tree? (last tr))))))", "problem": 95, "user": "4e98a6d0535dbda64a6f6b5e"}, {"code": "(fn node? [tree]\r\n  (if (coll? tree)\r\n    (and (first tree)\r\n         (= 3 (count tree))\r\n         (every? node? (rest tree)))\r\n    (if (nil? tree)\r\n      true\r\n      false)))", "problem": 95, "user": "4e6dd51b535d5021c1a895f6"}, {"code": "(fn f [t]\n  (or\n    (nil? t)\n    (and\n      t\n      (= 3 (count t))\n      (f (second t))\n      (f (last t)))))", "problem": 95, "user": "4db85bdd535d1e037afb218d"}, {"code": "(fn [t]\n  (every? #(and (= 3 (count %))\n                (or (nil? (second %)) (coll? (second %)))\n                (or (nil? (last %)) (coll? (last %))))\n   (filter coll? (tree-seq sequential? seq t)))\n  )", "problem": 95, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "(fn f [l]\n  (or \n    (nil? l)\n    (and\n      l\n      (= (count l) 3)\n      (f (nth l 1))\n      (f (nth l 2)))))", "problem": 95, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn is-tree?\n  [tree]\n  (cond (nil? tree) true\n        (false? tree) false ;; this is stupid\n        (not= (count tree) 3) false\n        :else (and (is-tree? (nth tree 1)) (is-tree? (nth tree 2)))))", "problem": 95, "user": "4e5a460f535d8a8b8723a2ab"}, {"code": "(fn t [c] (cond (nil? c) true (not (sequential? c)) false (not= 3 (count c)) false (not (t (nth c 1))) false (not (t (nth c 2))) false :else true))", "problem": 95, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn tree? [t]\n  (let [[value left right :as tree] t\n        treeish? #(= 3 (count %))\n        nodeish? #(or (nil? %) (coll? %))]\n    (if-not (and (treeish? tree)\n                 (nodeish? left)\n                 (nodeish? right)) false\n       (and (or (nil? left) (tree? left))\n            (or (nil? right) (tree? right))))))", "problem": 95, "user": "4daf907aedd6309eace4d17b"}, {"code": "(fn tree? [n]\n    (if (nil? n)\n      true\n      (and (coll? n)\n           (= (count n) 3)\n           (every? tree? (rest n)))))", "problem": 95, "user": "4ea09fa4535d7eef308072aa"}, {"code": "(fn bt?\n  [t]\n  (and (= (count t) 3)\n       (let [[_ l r] t]\n         (and\n          (or (nil? l) (and (sequential? l) (bt? l)))\n          (or (nil? r) (and (sequential? r) (bt? r)))))))", "problem": 95, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "(fn bin-tree? [x]\n  (and (counted? x)\n       (= 3 (count x)) \n       (or (nil? (second x)) (bin-tree? (second x)))\n       (or (nil? (last x)) (bin-tree? (last x)))))", "problem": 95, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [t] (every? #(or (nil? %) (and (sequential? %) (= (count %) 3)))\n  (tree-seq sequential? rest t)))", "problem": 95, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn check [node]\r\n  (cond \r\n    (nil? node) true\r\n    (or (not (coll? node)) (not (= (count node) 3))) false\r\n    :else\r\n    (and (check (nth node 1)) (check (nth node 2)))))", "problem": 95, "user": "4df407c3535d08e6dec9fe2e"}, {"code": "(fn [s]\n  (every? #(or (nil? %) (and (sequential? %) (= 3 (count %))))\n    (tree-seq sequential? (partial drop 1) s)))", "problem": 95, "user": "4e6a4954535d8ccf87e9fec0"}, {"code": "(fn tree? [s]\n  (or (nil? s) \n      (and (sequential? s)\n           (= 3 (count s))\n           (tree? (second s))\n           (tree? (last s)))))", "problem": 95, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn p [x]\n  (if (coll? x)\n    (let [[_ l r] x]\n     (and (= 3 (count x)) (p l)(p r)))\n  (nil? x)))", "problem": 95, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn binary-tree? [l]\n  (if (nil? l)\n    true\n    (if (and (sequential? l) (= (count l) 3))\n      (let [v (first l) r (rest l) \n        left (first r) right (last r)]\n        (and (binary-tree? left) (binary-tree? right)))\n      false)))", "problem": 95, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn binary-tree? [[root & branches]]\n  (or (empty? branches)\n      (and (every? #(or (nil? %) (and (coll? %) (not-empty %))) branches)\n           (= (count branches) 2)\n           (every? true? (map binary-tree? branches)))))", "problem": 95, "user": "4e976f79535dbda64a6f6b55"}, {"code": "(fn is-binary? [tree]\r\n  (cond\r\n   (false? tree) false\r\n   (not (coll? tree)) true\r\n   (not= (count tree) 3) false\r\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "4e8ddf32535d65386fec213c"}, {"code": "(fn binary-tree?\n  ([t] (binary-tree? t '()))\n  ([t open]\n     (do\n       (print (str \"(binary-tree? \" (pr-str t) \" \" (pr-str open) \")\\n\"))\n       (if (and (empty? t) (empty? open))\n        true\n        (if (and (= 3 (count t))\n                 (every? #(or (nil? %) (and (coll? %) (not (empty? %)))) (rest t)))\n          (let [new-open (concat open (filter coll? (rest t)))]\n            (recur (first new-open)\n                   (rest new-open)))\n          false)))))", "problem": 95, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn f [n]\r\n  (or (nil? n)\r\n      (and n (= 3 (count n))\r\n             (f (nth n 1))\r\n             (f (nth n 2)))))", "problem": 95, "user": "4e72ac47535d5021c1a89666"}, {"code": "(fn is-tree [x]\n  (if (nil? x)\n  true\n  (if (not (coll? x))\n  false\n  (if (not (= 3 (count x)))\n    false\n    (let [value (first x) lchild (second x) rchild (last x)]\n      (if (coll? value)\n        false\n        (and (is-tree lchild)(is-tree rchild))\n      )\n    )\n  )\n  )\n  )\n)", "problem": 95, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "(fn bt [t]\r\n  (if (and (= 3 (count t)) (not (sequential? (first t))))\r\n    (let [l (nth t 1)\r\n          r (nth t 2)\r\n          ls (sequential? l)\r\n          rs (sequential? r)]\r\n      (if (and ls rs)\r\n        (and (bt l) (bt r))\r\n        (if (and ls (nil? r))\r\n          (bt l)\r\n          (if (and rs (nil? l))\r\n            (bt r)\r\n            (if (and (nil? l) (nil? r))\r\n              true\r\n              false)))))\r\n    false))", "problem": 95, "user": "4e79ff2a535db169f9c796a9"}, {"code": "(fn t [d]\n  (cond (nil? d) true\n        (and (coll? d) (= (count d) 3)) (and (t (fnext d)) (t (fnext(rest d))))\n        :else false))", "problem": 95, "user": "4e8a460e535d65386fec2109"}, {"code": "(fn is-binary-tree? [t]\n  (and\n    (sequential? t)\n    (= 3 (count t))\n    (let [left (nth t 1) right (nth t 2)]\n      (and\n        (or (nil? left) (is-binary-tree? left))\n        (or (nil? right) (is-binary-tree? right))))))", "problem": 95, "user": "4ea4fe1f535d7eef308072cf"}, {"code": "(fn t [n]\n  (if (sequential? n)\n    (if (= (count n) 3)\n      (reduce #(and % %2) (map t n))\n      false)\n    (not= false n))\n  )", "problem": 95, "user": "4eaa96e1535d7eef3080730d"}, {"code": "(fn t [l]\n  (if (nil? l) \n    true\n    (if (coll? l)\n      (and \n        (= (count l) 3) \n        (t (second l)) \n        (t (last l)))\n      false\n    )\n  )\n)", "problem": 95, "user": "4e9d6a65535dbda64a6f6b87"}, {"code": "(fn binary-tree? [tree]\r\n  (if (or (vector? tree) (seq? tree))\r\n    (and\r\n     (= 3 (count tree))\r\n     (not (seq? (first tree)))\r\n     (every? binary-tree? (rest tree)))\r\n    (nil? tree)))", "problem": 95, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn t [v] \n  (or \n    (nil? v)\n    (and \n      (coll? v)\n      (= 3 (count v)) \n      (let [[v l r] v] \n        (and (t l) (t r))))))", "problem": 95, "user": "4e707db6535d5021c1a8963a"}, {"code": "(fn t [x] (if (= nil x) true (if (coll? x) (and (= (count x) 3) (every? t (rest x))) false)))", "problem": 95, "user": "4eaede1f535d7eef30807329"}, {"code": "(fn tmp [lst]\n  (cond \n    (nil? lst) true\n    (not (coll? lst)) false\n    (not= (count lst) 3) false\n    :else (reduce #(and %1 %2)(map #(tmp %1) (rest lst)))))", "problem": 95, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn is-tree? [t]\n  (or (= t nil)\n      (and (sequential? t)\n           (= (count t) 3)\n           (nth t 0)\n           (is-tree? (nth t 1))\n           (is-tree? (nth t 2)))))", "problem": 95, "user": "4eab612d535d7eef30807316"}, {"code": "(fn [coll]\n  (every? #(or (not (coll? %))\n               (and (= 3 (count %))\n                    (not-any? false? %)))\n          (tree-seq coll? seq coll)))", "problem": 95, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn f95 [t]\n\"test tree\"\n  (cond\n   (nil? t) true\n   (not (coll? t)) false\n   (not= 3 (count t)) false\n   :else\n   (if (and (f95 (second t)) (f95 (nth t 2)))\n     true\n     false)))", "problem": 95, "user": "4e88feef535d8b9bb0147ca8"}, {"code": "(fn binary-tree [c]\n  (or (not (coll? c)) (and (= 3 (count c)) (-> c next first false? not) (binary-tree (-> c next first)) (binary-tree\n(-> c next next first)))))", "problem": 95, "user": "4eb27fad535d7eef3080734a"}, {"code": "(fn is-tree [tree]\n  (if (nil? tree)\n    true\n    (and\n      (coll? tree)\n      (= 3 (count tree))\n      (first tree)\n      (is-tree (second tree))\n      (is-tree (second (next tree))))))", "problem": 95, "user": "4eb1dd39535d7eef30807345"}, {"code": "(fn istree [x] \n    (if (not (coll? x))\n      (if (nil? x)\n        true\n        false\n      )\n      (if (= (count x) 3)\n        (and \n          (istree (nth x 1))\n          (istree (nth x 2))\n        )\n        false\n      )\n    )\n  )", "problem": 95, "user": "4e8b73e4535d65386fec2120"}, {"code": "(fn t? [x]\n  (or (nil? x)\n    (and (coll? x) (= (count x) 3)\n      (let [[_ y z] x]\n        (and (t? y) (t? z))))))", "problem": 95, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn t [c] (if (or (nil? c) (and (coll? c) (= (count c) 3) (t (nth c 1)) (t (last c)))) true false))", "problem": 95, "user": "4e4870d1535dc968683fc4bc"}, {"code": "(fn is-tree [tree]\n  (letfn [ (f [t]\n    (cond\n      (nil? t) true\n      (and (coll? t) (= (count t) 3)) (and (f (nth t 1)) (f (nth t 2)))\n      :else false))]\n    (f tree)))", "problem": 95, "user": "4dd1de4d535dae65d5c462d7"}, {"code": "(fn tree? [node]\n  (cond (nil? node)true\n        (not (or (vector? node) (seq? node))) false\n        true (let [[_ left right] node]\n               (and\n                 (= (count node) 3)\n                 (tree? left)\n                 (tree? right)))))", "problem": 95, "user": "4e82c062535db62dc21a62cc"}, {"code": "(fn t [s]\n  (if (sequential? s)\n      (and (= 3 (count s)) (t (fnext s)) (t (first (nnext s))))\n      (nil? s)))", "problem": 95, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn n? [n]\n  (if (and (coll? n) (= 3 (count n)))\n    (let [[v l r] n]\n      (and (n? l) (n? r)))\n    (nil? n)))", "problem": 95, "user": "4eb5750a535d7eef30807366"}, {"code": "(fn f [v]\n  (or (nil? v)\n    (and\n      (coll? v)\n      (= 3 (count v))\n      (f (nth v 1))\n      (f (nth v 2)))))", "problem": 95, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn bt? [s]\n  (cond\n    (nil? s) true\n    (sequential? s)\n    (and\n      (= 3 (count s))\n      (bt? (second s))\n      (bt? (last s)))\n    :else false))", "problem": 95, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn bin-tree? [t]\n    (if (nil? t)\n        true\n        (and (coll? t)\n             (= (count t) 3)\n             (bin-tree? (second t))\n             (bin-tree? (nth t 2)))))", "problem": 95, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn binTree? [c]\n  (or \n    (nil? c)\n    (and \n      (coll? c)\n      (= 3 (count c))\n      (binTree? (fnext c))\n      (binTree? (last c)))))", "problem": 95, "user": "4e8a0d5d535d3e98b802328e"}, {"code": "(fn binary-tree? [coll]\r\n  (letfn [(node? [x] (and (coll? x)\r\n                          (= 3 (count x))\r\n                          (not (nil? (first x)))))\r\n          (chk [x] (cond\r\n                    (nil? x)  true\r\n                    (node? x) (and (chk (nth x 1))\r\n                                   (chk (nth x 2)))\r\n                    :else     false))]\r\n    (chk coll)))", "problem": 95, "user": "4dd7d040535d2dad7130b5d6"}, {"code": "(fn f [x]\n (\n   if (coll? x)\n     (and (= 3 (count x)) (every? f (rest x)))\n     (nil? x)\n )  \n)", "problem": 95, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [coll] (letfn [(node? [x] (and \n  (coll? x) (= 3 (count x)) (not (nil? (first x)))))\n\n(bt? [x] (cond\n  (nil? x) true\n  (node? x) (and (bt? (nth x 1)) (bt? (nth x 2)))\n  :else false))] (bt? coll)))", "problem": 95, "user": "4ea9b80c535d7eef30807306"}, {"code": "(fn istree[c]\r\n  (let [f (fn[[p l r :as all]]\r\n      (if (and (= 3 (count all)) l r )\r\n      (if  (sequential? l)\r\n        (istree l)\r\n        (if (sequential? r)\r\n          (istree r)\r\n           true))\r\n        false))]\r\n    (f (replace {nil 1} c))\r\n    )\r\n  )", "problem": 95, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "(fn tree? [coll]\n  (let [node? (fn [node] (or (nil? node) (tree? node)))]\n    (if (and\n          (or (seq? coll) (vector? coll))\n          (= (count coll) 3)\n          (first coll)\n          (node? (second coll))\n          (node? (nth coll 2)))\n      true\n      false)))", "problem": 95, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(fn binary? [tree]\n  (if (coll? tree)\n    (and (= 3 (count tree))\n         (every? binary? (rest tree)))\n    (nil? tree)))", "problem": 95, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn checkBin [cad]\n(if\n  (= nil cad) \n\ttrue\n\t(if\n\t\t(or (and (coll? cad) (not= (count cad) 3)) (not (coll? cad)))\n\t\tfalse\n\t\t(and (checkBin (second cad)) (checkBin (second (rest cad)))) \n\t)\n)\n)", "problem": 95, "user": "4e9de526535dbda64a6f6b8e"}, {"code": "(fn valid [n]\n  (if (nil? n)\n    true\n    (if (coll? n)\n      (if (= (count n) 3)\n        (and (valid (nth n 1)) (valid (nth n 2)))\n        false)\n      false)))", "problem": 95, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn is-tree [t]\n  (if (nil? t)\n    true\n    (and (coll? t)\n         (= (count t) 3)\n         (or (keyword? (first t)) (number? (first t)))\n         (is-tree (second t))\n         (is-tree (nth t 2)))))", "problem": 95, "user": "4ec6559a535d6d7199dd36c9"}, {"code": "(fn t [s]\n  (or \n    (nil? s)\n    (and\n      (coll? s)\n      (= (count s) 3)\n      (not (nil? (first s)))\n      (t (nth s 1)) (t (nth s 2)))))", "problem": 95, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn check [coll]\n  (if (and (coll? coll) (= 3 (count coll)))\n    (let [[val left right] coll]\n      (and (or (nil? left) (check left))\n           (or (nil? right) (check right))))\n    false))", "problem": 95, "user": "4ec5d40d535d6d7199dd36b9"}, {"code": "(fn is-tree? [coll]\n  (or\n    (nil? coll)\n    (and\n      (sequential? coll)\n      (= (count coll) 3)\n      (is-tree? (nth coll 1))\n      (is-tree? (last coll)))))", "problem": 95, "user": "4eb51942535d7eef30807365"}, {"code": "(fn tree? [t]\n  (and (coll? t) (= 3 (count t))\n    (let [\n      nil-or-tree (fn [t] (or (nil? t) (tree? t)))\n      [v l r] t]\n        (and (nil-or-tree l) (nil-or-tree r)))))", "problem": 95, "user": "4ec60863535d6d7199dd36bf"}, {"code": "(fn bin-tree? [x]\n  (let [\n      is-value?\n    (fn [x]\n      (if (and (not (nil? x)) (not (coll? x)))\n  true false))\n    is-lc?\n    (fn [x]\n      (if (nil? x)\n\ttrue\n\t(if (coll? x)\n\t  (if-not (bin-tree? x)\n\t    false\n\t    true))))\n    is-rc?\n    (fn [x]\n      (if (and (nil? (first x)) (> (count x) 0))\n\ttrue\n;;\t(if-not (coll? (first x))\n;;\t  false\n;\t(if (coll? x)\n;;\t  (if-not (bin-tree? (first x))\n\t(if (> (count x) 1)\n\t  (if-not (bin-tree? x)\t  \n\t    false\n\t    true)\n\t  \n\t  (if-not (bin-tree? (first x))\n\t    false\n\t    true))))\n    ]\n    (if-not (is-value? (first x))\n      false\n      (if-not (is-lc? (fnext x))\n\tfalse\n\t(if-not (is-rc? (nnext x))\n\t  false\n\t  true)))\n  ))", "problem": 95, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn btree? [n]\n  (or \n    (nil? n) \n    (and\n      (sequential? n)\n      (= (count n) 3)\n      (every? btree? (drop 1 n)))))", "problem": 95, "user": "4ec16c21535dfed6da9c6dac"}, {"code": "(fn foo[s] \n  (if (nil? s) true \n    (if (and (coll? s) (= 3 (count s)) (foo (nth s 1)) (foo (nth s 2))) true false)))", "problem": 95, "user": "4eabb245535d7eef30807319"}, {"code": "(fn t [s]\n  (if (and (coll? s) (= (count s) 3))\n    (let [[a l r] s]\n      (and (or (nil? l) (t l))\n           (or (nil? r) (t r))))\n    false))", "problem": 95, "user": "4db0114d838c48654951d9b8"}, {"code": "(let [count_colls_and_nils (fn [l] (count (filter #(or (nil? %) (coll? %)) l)))]\n         (fn node? [l] (if (not= 3 (count l)) false\n                         (if (< (count_colls_and_nils l) 2) false\n                           (every? node? (filter coll? l))))))", "problem": 95, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn r [[a b c :as z]] \n  (and (= (count z) 3) \n           (if (coll? b) (r b) (nil? b)) \n           (if (coll? c) (r c) (nil? c))))", "problem": 95, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn valid? [t]\n  (if (nil? t)\n    true\n    (and\n      (coll? t)\n      (= (count t) 3) \n      (valid? (second t))\n      (valid? (nth t 2)))))", "problem": 95, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [col] (= 0 (count (filter #(= false %) (map #(if (sequential? %) (= (count %) 3) (cond (nil? %) true (identical? false %) false :else true) )\n      (tree-seq  sequential? seq col)))) ))", "problem": 95, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn checker [t]\n  (or\n    (nil? t) \n    (and\n      (coll? t)\n      (= 3 (count t))\n      (checker (second t))\n      (checker (last t)))))", "problem": 95, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn is-tree [t]\n  (cond\n   (nil? t) true\n   (not (counted? t)) false\n   (not (= 3 (count t))) false\n   :else (and (is-tree (second t)) (is-tree (last t)))))", "problem": 95, "user": "4daf8f84edd6309eace4d17a"}, {"code": "(fn bin-tree? [s]\n  (or\n   (nil? s)\n   (and (sequential? s)\n        (= 3 (count s))\n         (let [[v l r] s]\n           (and (bin-tree? l)\n                (bin-tree? r))))))", "problem": 95, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [n] (= 1 (reduce + (map #(if (nil? %) 1 -1) (#(remove % (tree-seq % seq %2)) coll? n)))))", "problem": 95, "user": "4e9a8c0e535dbda64a6f6b72"}, {"code": "(fn tree? [t]\n  (if (nil? t) true\n    (if (sequential? t)\n      (if (= 3 (count t))\n        (let [left (nth t 1) right (nth t 2)]\n        (and (tree? left) (tree? right)))\n        false)\n    false)))", "problem": 95, "user": "4eb0a757535d7eef3080733d"}, {"code": "; This assumes that any node value is OK (it doesn't check to\n; see if the value is a number or keyword).  It also seems way\n; too wordy.\n(fn is-tree [x]\n  (cond\n    (= x nil) true\n    (not (coll? x)) false\n    (not= (count x) 3) false\n    (not (is-tree (second x))) false\n    (not (is-tree (second (rest x)))) false\n    :else true))", "problem": 95, "user": "4ec5cdb0535d6d7199dd36b8"}, {"code": "(fn f [s]\n  (or (nil? s) (and (coll? s) (= 3 (count s)) (f (second s)) (f (second (next s))))))", "problem": 95, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn tree? [tr] (or\n  (= nil tr)\n  (and (or (seq? tr) (vector? tr)) (= 3 (count tr)) (tree? (second tr)) (tree? (last tr)))\n))", "problem": 95, "user": "4ed500bb535d10e5ff6f52d3"}, {"code": "(fn is-tree? [t]\n  (if (nil? t)\n    true\n    (if (not (or (vector? t) (seq? t)))\n      false\n      (and (not (nil? (first t))) (= 3 (count t)) (is-tree? (second t)) (is-tree? (nth t 2))))))", "problem": 95, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(fn is_tree [tree]\n  (and (coll? tree)\n       (= 3 (count tree))\n       (or (nil? (nth tree 1))\n           (is_tree (nth tree 1)))\n       (or (nil? (nth tree 2))\n           (is_tree (nth tree 2)))))", "problem": 95, "user": "4dad8d4bc9a9d6ed1799dc57"}, {"code": "(fn f [t]\n  (or (nil? t)\n    (and (coll? t) (= 3 (count t))\n      (every? f (next t)))))", "problem": 95, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn binary-tree? [s] \n  (and\n    (coll? s)\n    (= 3 (count s)) \n    (every? #(if (nil? %) true (binary-tree? %)) (rest s))))", "problem": 95, "user": "4ec70f26535d6d7199dd36dd"}, {"code": "(fn is-bin-tree [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (is-bin-tree (nth t 1))\n           (is-bin-tree (nth t 2)))))", "problem": 95, "user": "4ec75077535d6d7199dd36e0"}, {"code": "(fn tree? [item]\n  (cond\n    (nil? item)\n      true\n    :else\n      (and (sequential? item)\n           (= 3 (count item))\n           (every? tree? (rest item)))))", "problem": 95, "user": "4eda7cc3535d10e5ff6f530e"}, {"code": "(fn tree? [tree]\n  (let [leaf? #(if (coll? %) (tree? %) (nil? %))]\n    (if (= 3 (count tree))\n      (reduce #(and %1 %2) true (map leaf? (rest tree)))\n      false)))", "problem": 95, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn f [x] (cond\n            (and (not (coll? x)) (false? x)) false\n            (or (not (coll? x)) (= 1 (count x))) true\n            (= 3 (count x)) (and (f (first (rest x))) (f (first (rest (rest x)))))\n            :else false))", "problem": 95, "user": "4ebef65e535dfed6da9c6d9b"}, {"code": "(fn tree? [x] (or (nil? x) (and (sequential? x) (= 3 (count x)) (every? tree? (rest x)))))", "problem": 95, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn tree? [t] \n        (cond          \n          (nil? t)  true\n          (and (coll? t) (= (count t) 3)) (and (coll? t) (tree? (first (rest t))) (tree? (second (rest t))))\n          :else false))", "problem": 95, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn binary-tree\n  [ [v l r & more :as all] ]\n  (and\n   (= 3 (count all))\n   (not (coll? v))\n   (every? \n     #(or (nil? %)\n          (and (coll? %)\n               (binary-tree %))) (list l r))))", "problem": 95, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "(fn binary-tree? [coll]\n  (letfn [(node? [x] (and (coll? x)\n                          (= 3 (count x))\n                          (not (nil? (first x)))))\n          (chk [x] (cond\n                    (nil? x)  true\n                    (node? x) (and (chk (nth x 1))\n                                   (chk (nth x 2)))\n                    :else     false))]\n    (chk coll)))", "problem": 95, "user": "4ea55757535d7eef308072d3"}, {"code": "(fn tree? [t]\n  (let [check-child (fn [c] (or (tree? c) (= c nil)))]\n\t\t(and (sequential? t) (= (count t) 3) (check-child (second t)) (check-child (nth t 2)))))", "problem": 95, "user": "4ed6238d535d10e5ff6f52de"}, {"code": "(fn bt [t] (if (nil? t) true (if \n         (and (sequential? t)(= 3 (count t))) (and (bt (nth t 1)) (bt (nth t 2))) false)))", "problem": 95, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn bintree? [t]\n  (if (nil? t)\n      true\n      (if (not (and (sequential? t) (= (count t) 3)))\n          false\n          (let [[v l r] t]\n            (and (bintree? l) (bintree? r))))))", "problem": 95, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn tree? [tree]\n  (if (and (coll? tree) (= (count tree) 3))\n    (let [[value left right] tree]\n      (and\n        (or (nil? left) (tree? left))\n        (or (nil? right) (tree? right))))\n    false))", "problem": 95, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "(fn tree? [args]\n  (and (coll? args)\n       (= (count args) 3)\n       (let [[v l r] args]\n         (and (or (nil? l) (tree? l))\n              (or (nil? r) (tree? r))))))", "problem": 95, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "#(let [s (tree-seq coll? rest %)] (and (every? #{3} (map count (filter coll? s))) (every? nil? (remove coll? s))))", "problem": 95, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn tree?\r\n  ([[value left right & more :as tree]]\r\n     (println \"left = \" left \"right = \" right)\r\n     (if (not= 3 (count tree)) (do (println \"count = \" (count tree)) false)\r\n   (and\r\n\t  (if (coll? left) (tree? left) (nil? left))\r\n\t  (if (coll? right) (tree? right) (nil? right))))))", "problem": 95, "user": "4e6ab9cb535d8ccf87e9fefe"}, {"code": "(fn [root]\n  (letfn [(tree? [t]\n    (or (nil? t)\n        (and (sequential? t)\n             (= 3 (count t))\n             (tree? (nth t 1))\n             (tree? (nth t 2)))))]\n    (tree? root)))", "problem": 95, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn t [[v l r :as a]]\n    (and (= 3 (count a))\n         (if (coll? l) (t l) (nil? l))\n         (if (coll? r) (t r) (nil? r))))", "problem": 95, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn f [[h l r :as t]]\n  (and (not (nil? h))\n      (= 3 (count t))\n      (or (nil? l) (and (coll? l) (f l)))\n      (or (nil? r) (and (coll? r) (f r)))))", "problem": 95, "user": "4e5af45e535d8a8b8723a2b1"}, {"code": "(fn bt? [tr]\r\n  (cond\r\n    (nil? tr)\r\n      true\r\n    (or (true? tr) (false? tr))\r\n      false\r\n    (seq tr)\r\n      (let [res (and (= 3 (count tr))\r\n                      (or (keyword? (nth tr 0)) (number? (nth tr 0)))\r\n                      (bt? (nth tr 1))\r\n                      (bt? (nth tr 2)))]\r\n        (if (or (false? res) (nil? res))\r\n        false\r\n        true))\r\n    :else\r\n      false))", "problem": 95, "user": "4ee40938535d10e5ff6f5375"}, {"code": "(fn tree? [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (tree? (second node))\n           (tree? (nth node 2)))))", "problem": 95, "user": "4ee2da14535d10e5ff6f536c"}, {"code": "(fn ! [t] \n  (or (= nil t)\n      (and (coll? t)\n           (= 3 (count t))\n           (! (nth t 1))\n           (! (nth t 2)))))", "problem": 95, "user": "4ee7ef87535d93acb0a66872"}, {"code": "#( (fn [c] (and (not= 1 c)(odd? c))) (count (filter nil? (flatten %)) ))", "problem": 95, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn f [t]\n  (or\n    (and\n      (coll? t)\n      (= 3 (count t))\n      (f (get t 1))\n      (f (get (vec t) 2)))\n    (nil? t)))", "problem": 95, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn func [node]\n  (if (coll? node)\n    (and (= (count node) 3) (= [true true] (map func (rest node))))\n    (= node nil)))", "problem": 95, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn tree? [l]\n  (let [atom? #(not (coll? %))]\n\t     (if (atom? l)\n\t\t       (or (nil? l) (true? l))\n      \t\t (and (= (count l) 3)\n      \t\t      (tree? (second l))\n      \t\t      (tree? (last l))))))", "problem": 95, "user": "4db045b5838c48654951d9be"}, {"code": "(fn [t]\r\n  (if (nil? t) \r\n    true\r\n    (loop [t t\r\n           rbs []]\r\n      (cond\r\n        (nil? t) (if (empty? rbs) true (recur (first rbs) (next rbs))) \r\n        (not (or (seq? t) (sequential? t))) false \r\n        (not (= 3 (count t))) false \r\n        (nil? (first t)) false \r\n        :else (recur (second t) (cons (last t) rbs))))))", "problem": 95, "user": "4e6a97a9535d8ccf87e9fef8"}, {"code": "(fn b? [t] (or (nil? t) (and (counted? t) (= 3 (count t)) (b? (nth t 1)) (b? (nth t 2)))))", "problem": 95, "user": "4e8df08f535d65386fec213e"}, {"code": "(fn x [s]\n  (if (and (coll? s) (= 3 (count s)))\n    (let [[v l r] s]\n      (and (x l)\n           (x r)))\n    (nil? s)))", "problem": 95, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "(fn is-tree [[a b c :as col]]\n  (and (= 3 (count col))\n    (or (nil? b) (and (coll? b) (is-tree b)))\n    (or (nil? c) (and (coll? c) (is-tree c)))))", "problem": 95, "user": "4ed27f9f535d44c135fd68d5"}, {"code": "(fn f[s](let[p (first s), l (second s), r (last s)]\n           (and (not (coll? p))         \n               (= (count s) 3)\n               (if (coll? l) (f l) (not (= false l)))         \n               (if (coll? r) (f r) (not (= false r)))\n           )\n         )\n)", "problem": 95, "user": "4ec75829535d6d7199dd36e1"}, {"code": "#(letfn [(istree [t]\r\n          (reduce (fn [x y] (and x y)) true (is-tree t)))\r\n         (pred [xs]\r\n          (or (nil? xs) (seq? xs) (vector? xs)))\r\n         (is-tree [t]\r\n          (if (or (seq? t) (vector? t))\r\n               (if (and (= (count t) 3) (pred (nth t 1)) (pred (nth t 2)))\r\n              (mapcat is-tree t)\r\n              [false])\r\n              [true]))]\r\n(istree %1))", "problem": 95, "user": "4e273301535deb9a81d77ef7"}, {"code": "(fn v? [t]\n   (cond\n    (not (coll? t)) true\n    (not (= (count t) 3)) false\n    :else (and (= [true true true] (map v? t))\n               (or (nil? (nth t 1)) (coll? (nth t 1))))))", "problem": 95, "user": "4ee868be535d93acb0a6687d"}, {"code": "(fn tree? [seq]\n  (or (nil? seq)\n      (and (coll? seq)\n           (= 3 (count seq))\n           (tree? (nth seq 1))\n           (tree? (nth seq 2)))))", "problem": 95, "user": "4e5867d1535d8a8b8723a291"}, {"code": "(fn is-tree\r\n  [coll]\r\n  (cond \r\n    (nil? coll) true\r\n    (false? coll) false\r\n    :else\r\n    (if (= (count coll) 3)\r\n      (if (and (not (coll? (first coll)))\r\n\t\t           (is-tree (nth coll 1))\r\n\t\t           (is-tree (nth coll 2))) true false)\r\n\t       false)))", "problem": 95, "user": "4ee9d697535d93acb0a66895"}, {"code": "(fn tree? [seq]\n          (or (nil? seq)\n              (and (sequential? seq)\n               (= (count seq) 3)\n               (every? tree? [(nth seq 1)\n                       (nth seq 2)]))))", "problem": 95, "user": "4e599577535d8a8b8723a29f"}, {"code": "(fn b-tree? [t]\n  (cond\n   (nil? t) true\n   (coll? t) (and (= (count t) 3)\n        (b-tree? (nth t 1))\n        (b-tree? (nth t 2)))\n   :else false))", "problem": 95, "user": "4e7f8f85535db966e863cc44"}, {"code": "(fn testtree [tree]\n  (let [a-ch (second tree)\n        b-ch (last tree)\n        chk? (and (= (count tree) 3)\n               (or (nil? a-ch) (coll? a-ch))\n               (or (nil? b-ch) (coll? b-ch)) )]\n    (if (not chk?)\n      false\n      (and (if (coll? a-ch) (testtree a-ch) true)\n           (if (coll? b-ch) (testtree b-ch) true) ))))", "problem": 95, "user": "4ed7b617535d10e5ff6f52f3"}, {"code": "(fn is-binary-tree?\n  [coll]\n  (let [u (remove (complement vector?) coll)\n        v (remove (complement list?) coll)\n        w (apply concat (remove (complement vector?) coll))]\n    (if (= (count coll) 3)\n      (if (zero? (count w))\n        (if (zero? (count (filter false? coll)))\n          (nil? ((into #{} coll) ()))\n          false)\n        (if (= (count u) 2)\n          (and (is-binary-tree? (first u)) (is-binary-tree? (second u)))\n          (is-binary-tree? w)))\n      false)))", "problem": 95, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn n? [n]\n  (and (coll? n) (= (count n) 3)\n       (first n)\n       (or (nil? (second n)) (n? (second n)) )\n       (or (nil? (last n)) (n? (last n)) ) ) )", "problem": 95, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn t [s] (or (nil? s) (and (coll? s) (= (count s) 3) (every? t (rest s)))))", "problem": 95, "user": "4eecdd66535d93acb0a668b9"}, {"code": "(fn tree? [n]\n  (if (nil? n)\n    true\n    (and (coll? n) (= 3 (count n)) (tree? (nth n 1)) (tree? (nth n 2)))))", "problem": 95, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn ? [t]\n  (or (and (coll? t)\n           (= (count t) 3)\n           (every? ? (rest t)))\n      (nil? t)))", "problem": 95, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn p [n] (or (nil? n) (and (coll? n) (= 3 (count n)) (p (nth n 1)) (p (nth n 2)))))", "problem": 95, "user": "4ef2d243535dced4c769f221"}, {"code": "(fn btree [t]\n  (or\n    (nil? t)\n    (and\n      (counted? t)\n      (= (count t) 3)\n      (btree (second t))\n      (btree (last t)))))", "problem": 95, "user": "4edecdae535d10e5ff6f533c"}, {"code": "(fn binary-tree? [xs]\n  (cond\n    (= false xs) false\n    (= nil xs) true\n    (= 3 (count xs)) (every? binary-tree? (rest xs))\n    :else false))", "problem": 95, "user": "4ef41f26535dced4c769f230"}, {"code": "(fn f [t]\n(or\n   (nil? t)\n   (and\n    (coll? t)\n    (= 3 (count t))\n    (every? f (next t)))))", "problem": 95, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn iter [s]\r\n    (if (sequential? s) \r\n      (if (= (count s) 3)\r\n        (and (iter (second s)) (iter (nth s 2)))\r\n        false)\r\n      (nil? s)))", "problem": 95, "user": "4ef1ee67535dced4c769f219"}, {"code": "(fn t [node]\n    (if (and (coll? node)\n             (= 3 (count node)))\n      (let [[val left right] node]\n        (and \n         (not (nil? val))\n         (or (nil? left)\n             (t left))\n         (or (nil? right)\n             (t right))))\n      false))", "problem": 95, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "#(letfn [(f [n] \n   (if(not (and (coll? n) (= (count n) 3) ))\n      false\n      (and\n        (if(coll?(second n))\n          (f (second n))\n          (or (nil? (second n)) (coll? (second n))))\n        (if(coll? (nth n 2))\n          (f (nth n 2))\n          (or (nil? (nth n 2)) (coll? (nth n 2)))))))]\n    (f %)\n )", "problem": 95, "user": "4ef4e5fa535dced4c769f242"}, {"code": "(fn ? [t]\n  (if (coll? t)\n    (let [[_ l r] t]\n      (and (= (count t) 3) (? l) (? r)))\n    (nil? t)))", "problem": 95, "user": "4ef77c82535dced4c769f253"}, {"code": "(fn t? [t]\n    (if (coll? t)\n      (and (= (count t) 3) (every? #(t? %) (rest t)))\n      (nil? t)))", "problem": 95, "user": "4ed292ac535d44c135fd68d9"}, {"code": "(fn my-tree [s]\r\n  (if (not (coll? s))\r\n\t\tfalse\r\n\t\t(if (not= (count s) 3)\r\n\t\t\tfalse\r\n\t\t\t(let [[v l r] s]\r\n\t\t\t\t(cond\r\n\t\t\t\t\t(and (= l nil) (= r nil))\r\n\t\t\t\t\t\ttrue\r\n\t\t\t\t\t(and (not= l nil) (my-tree l))\r\n\t\t\t\t\t\ttrue\r\n\t\t\t\t\t(and (not= r nil) (my-tree r))\r\n\t\t\t\t\t\ttrue\r\n\t\t\t\t\t:else\r\n\t\t\t\t\t\tfalse)))))", "problem": 95, "user": "4efb92ce535dced4c769f27a"}, {"code": "(fn btree? [[a & r]]\n  (let [[b  c] r\n        ncoll? #(not (coll? %))] \n    (and \n      (= 2 (count r))\n      (or (ncoll? b) (btree? b))\n      (or (ncoll? c) (btree? c))\n      (not (or (= b false) (= c false))))))", "problem": 95, "user": "4ef355e3535dced4c769f228"}, {"code": "(fn tree? [t]\n  (cond\n    (or (keyword? t) (number? t) (nil? t)) true\n    (and (coll? t) (= (count t) 3)) (and (tree? (first t)) (tree? (second t)) (tree? (last t)))\n    :else false))", "problem": 95, "user": "4ef4c1ff535dced4c769f23e"}, {"code": "(fn binary-tree? [ root ] \n  (or\n    (nil? root)\n    (and \n      (coll? root)\n      (= 3 (count root))\n      (let [ [value left right] root ]\n        (and \n          (not (nil? value))\n          (not (coll? value))\n          (binary-tree? left)\n          (binary-tree? right))))))", "problem": 95, "user": "4ee3afde535d10e5ff6f5370"}, {"code": "(fn tt [[a b c & xs :as coll]]\n   (let [test #(if (coll? %)\n                 (tt %)\n                 (if (nil? %)\n                   true\n                   false))]\n     (and (= 3 (count coll))\n          (test b)\n          (test c))))", "problem": 95, "user": "4ef57a7f535dced4c769f246"}, {"code": "(fn [s]\n  (->> s\n       (tree-seq coll? seq)\n       (remove (complement coll?))\n       (every? (fn [[_ l r :as n]]\n                 (and (= 3 (count n))\n                      (or (coll? l) (nil? l))\n                      (or (coll? r) (nil? r)))))))", "problem": 95, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn binary-tree? [coll]\n    (if (= 3 (count coll))\n      (let [l (nth coll 1)\n            r (nth coll 2)]\n        (letfn [(binary-tree-or-nil? [x]\n                  (if (coll? x)\n                    (binary-tree? x)\n                    (nil? x)))]\n          (and (binary-tree-or-nil? l) (binary-tree-or-nil? r))))\n      false))", "problem": 95, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn f [s] (or (and (sequential? s) (= 3 (count s)) (f (nth s 1)) (f (nth s 2)))\n               (nil? s)))", "problem": 95, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn btree? [coll]\n  (and (not= false coll) (not= () coll)\n       (or (not (sequential? coll))\n           (and (= 3 (count coll)) (every? btree? coll)))))", "problem": 95, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn [x]\n  (let [t (tree-seq #(and (coll? %) (= (count %) 3)) identity x)\n        ]\n        (if (some #(= false %) t) false\n    (not(coll? (last t))))))", "problem": 95, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn ! [coll]\n   (or\n    (nil? coll)\n    (and (coll? coll) (= (count coll) 3) (every? ! (rest coll)))))", "problem": 95, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn tnode? [coll]\n  (or (nil? coll)\n  (and (coll? coll)\n       (= 3 (count coll))\n       (every? tnode? (next coll)))))", "problem": 95, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn f [l]\n   (cond (nil? l) true\n         (and (coll? l) \n              (= 3 (count l))) (and (f (second l))\n                                    (f (last l)))\n         :else false))", "problem": 95, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [t] (every? #(and (counted? %) (= 3 (count %)))\n                       (filter (comp not nil?) (tree-seq identity next t))))", "problem": 95, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn isTree? [x]\n  (if (coll? x)\n    (and (= (count x) 3)\n         (every? isTree? x))\n    (and (not (coll? x))\n         (not (false? x)))))", "problem": 95, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn tree? [c]\n  (or\n   (nil? c)\n   (and\n    (coll? c)\n    (= 3 (count c))\n    (not (coll? (first c)))\n    (tree? (first (next c)))\n    (tree? (first (next (next c)))))))", "problem": 95, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn t? [x] \n  (or (nil? x) \n      (and (sequential? x)\n           (= 3 (count x)) \n           (t? (nth x 1)) \n           (t? (nth x 2)))))", "problem": 95, "user": "4f043ed1535dcb61093f6bb4"}, {"code": "(fn tree?\n  [coll]\n  (letfn [(check-node [n] \n                      (cond\n                        (sequential? n) (tree? n)\n                        (nil? n) true\n                        :else false))]\n  (and \n    (= 3 (count coll))\n    (check-node (second coll))\n    (check-node (second (rest coll))))))", "problem": 95, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn bin-tree? [tr]\n  (and (sequential? tr)\n       (= 3 (count tr))\n       (not (sequential? (first tr)))\n       (every? #(or (nil? %)\n                    (bin-tree? %)) (rest tr))))", "problem": 95, "user": "4f04f847535dcb61093f6beb"}, {"code": "(fn f [t]\n  (if (coll? t) \n    (let [[_ a b] t]\n      (and (= 3 (count t)) (f a) (f b)))\n  (nil? t)))", "problem": 95, "user": "4ed9354f535d10e5ff6f5301"}, {"code": "#(let [f (flatten %)\n       n (count (filter nil? f))]\n    (= (dec n) (- (count f) n)))", "problem": 95, "user": "4f062d4a535dcb61093f6c08"}, {"code": "(fn q [t]\n    (if (and (coll? t)\n             (= 3 (count t))\n             (let [[_ l r] t]\n               (and (or (nil? l) (q l))\n                    (or (nil? r) (q r)))))\n      true\n      false))", "problem": 95, "user": "4f083048535dcb61093f6c33"}, {"code": "(fn f [v]\n  (if (sequential? v)\n    (let [b (second v) c (last v)]\n      (and (= 3 (count v)) (f b) (f c)\n        (or (sequential? b) (nil? b))\n        (or (sequential? c) (nil? c))\n      ))\n    true\n))", "problem": 95, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn tree? [x]\n  (cond\n    (= x nil) true\n    (not (coll? x)) false\n    :else (let [l (next x) r (next l) bad (next r)]\n      (boolean\n        (and l r (not bad)\n          (tree? (first l))\n          (tree? (first r)))))))", "problem": 95, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn tree? [x] \n  (if (or \n       (nil? x) \n       (and \n        (coll? x)\n        (= (count x) 3)\n        (apply = \n             (concat '(true) (map tree? (rest x))))))\n    true\n    false))", "problem": 95, "user": "4f039bbe535dcb61093f6b39"}, {"code": "(fn binary-tree? [c]\n  (cond\n    (not (coll? c)) (nil? c)\n    (not= (count c) 3) false\n    :else (and (binary-tree? (nth c 1)) (binary-tree? (last c)))))", "problem": 95, "user": "4f01ff83535dcb61093f6a3a"}, {"code": "(fn t [x] \n  (or (nil? x)\n    (and (coll? x) (= (count x) 3) (t (second x)) (t (last x)))))", "problem": 95, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn [tree]\n  (every? \n    (fn [children] \n      (and (= 2 (count children)) \n           (every? #(or (coll? %) (nil? %)) children)))\n    (for [node (tree-seq coll? identity tree) :when (coll? node)]\n      (rest node))))", "problem": 95, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [root]\n    (letfn [(tree? [value]\n        (or\n            (nil? value)\n            (and \n                (or (seq? value) (vector? value))\n                (= 3 (count value))\n                (tree? (nth value 1))\n                (tree? (nth value 2)))))]\n        (tree? root)))", "problem": 95, "user": "4f0b2028535d0136e6c222ff"}, {"code": "#(let [treesum (tree-seq coll? identity %)](and (odd? (count treesum))(zero? (count (filter (fn[x](= false x)) treesum)))))", "problem": 95, "user": "4ed2dd98535d44c135fd68e2"}, {"code": "(fn ck [col]\n  (cond\n    (sequential? col)\n       (and (= (count col) 3)\n            (ck (nth col 1))\n            (ck (nth col 2)))\n    :else (nil? col)))", "problem": 95, "user": "4eeaf88f535d93acb0a668a3"}, {"code": "(fn check-tree [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (let [[d l r] t]\n             (and (check-tree l)\n                  (check-tree r))))))", "problem": 95, "user": "4e2d84bf535deb9a81d77f09"}, {"code": "(fn ?\n  [t] \n\t\t(if (sequential? t)\n\t\t\t(and (= (count t) 3) (? (fnext t)) (? (last t)))\n\t\t\t(nil? t))\n)", "problem": 95, "user": "4f047542535dcb61093f6bc7"}, {"code": "(fn [coll]\n    (letfn [(node? [t] (and (coll? t)\n                            (= 3 (count t))\n                            (not (nil? (first t)))))\n            (tree? [t]\n              (cond (nil? t) true\n                    (node? t) (and (tree? (nth t 1))\n                                   (tree? (nth t 2)))\n                    :else false))]\n      (tree? coll)))", "problem": 95, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn b [t]\n  (if (nil? t) true\n    (and \n      (sequential? t)\n      (= (count t) 3) \n      ((comp b second) t) \n      ((comp b second rest) t))))", "problem": 95, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn t [x] \n  (if (= 3 (count x))\n    (let [v (first x)\n          l (first (rest x))\n          r (second (rest x))]\n      (and (or (nil? l) (and (coll? l) (t l)))\n           (or (nil? r) (and (coll? r) (t r)))))\n    false))", "problem": 95, "user": "4f067029535dcb61093f6c12"}, {"code": "(fn bin-tree? [t]\r\n    (cond\r\n     (nil? t) true\r\n     (number? t) true\r\n     (or (list? t) (vector? t))\r\n     (if (not= (count t) 3)\r\n       false\r\n       (and (bin-tree? (second t))\r\n            (bin-tree? (second (rest t)))))\r\n     :else false))", "problem": 95, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn binary-tree? [tree]\n  (cond\n   (not (sequential? tree)) (if (false? tree) false true)\n   (empty? tree)            false\n   (not (= 3 (count tree))) false\n   :else (and (binary-tree? (nth tree 1))\n              (binary-tree? (nth tree 2)))\n   ))", "problem": 95, "user": "4efec33f535dcb61093f6a2a"}, {"code": "(fn tree? [t]\n  (if-not (coll? t)\n    false\n    (let [[k b1 b2] t]\n      (and\n        (= (count t) 3)\n        (not (nil? k))\n        (or (nil? b1) (tree? b1))\n        (or (nil? b2) (tree? b2))))))", "problem": 95, "user": "4ef0eaef535dced4c769f211"}, {"code": "(fn bin-tree? [t] (or (nil? t)\r\n                      (and (coll? t)\r\n                           (let [[_ left right] t]\r\n                             (and (= 3 (count t))\r\n                                  (bin-tree? left)\r\n                                  (bin-tree? right))))))", "problem": 95, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [tree]\n  (->> (tree-seq coll? next tree)\n       (every? #(or (nil? %)\n                    (and (counted? %)\n                         (-> % count (= 3)))))))", "problem": 95, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn t [c]\n  (let [s sequential? n nil? f false]\n    (if (s c)\n      (if (== 3 (count c))\n        (let [sc (second c)\n              lc (last c)]\n          (if (and (or (n sc) (s sc))\n                   (or (n lc) (s lc)))\n            (and (t sc) (t lc))\n            f))\n        f)\n      true)))", "problem": 95, "user": "4f0ef874535d0136e6c22328"}, {"code": "(fn binary-tree? [coll] \n  (let [value (first coll) left (second coll) right (last coll)]\n    (and (= 3 (count coll))\n         (or (nil? left) (and (sequential? left) (binary-tree? left)))\n         (or (nil? right) (and (sequential? right) (binary-tree? right)))\n)))", "problem": 95, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn tree? [seq]\n  (if (sequential? seq) \n      (and (= (count seq) 3) (tree? (second seq)) (tree? (last seq)))\n      (if (= false seq) false true)))", "problem": 95, "user": "4f13047d535d64f60314642c"}, {"code": "(fn binary-tree? [tree]                                                                                                                      \r\n    (cond (nil? tree) true                                                                                                                    \r\n          (coll? tree) (and (= 3 (count tree))                                                                                                \r\n                            (binary-tree? (nth tree 1))                                                                                       \r\n                            (binary-tree? (nth tree 2)))                                                                                      \r\n          :else false))", "problem": 95, "user": "4f149e0f535d64f60314643d"}, {"code": "(fn this [x]\n     (if-not (= 3 (count x)) false\n\t       (let [v (first x)\n\t\t    left (second x)\n\t\t    right (last x)]\n\t\t    (cond\n\t\t      (and (not (coll? left)) (not (coll? right))) (= left right)\n\t\t      (and (not (coll? left)) (coll? right)) (and true (this right))\n\t\t      (and (coll? left) (not (coll? right))) (and true (this left))\n\t\t      :else\n\t\t      (and (this right))))))", "problem": 95, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn treep [s]\n     (or (nil? s)\n         (and (coll? s)\n              (= (count s) 3)\n              (treep (nth s 1))\n              (treep (nth s 2)))))", "problem": 95, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn isTree [x]\n    (if (coll? x)\n        (if (= (count x) 3)\n            (and (isTree (nth x 1)) (isTree (nth x 2)))\n        false)\n    (if (nil? x) \n        true \n    false) ))", "problem": 95, "user": "4f03b3fb535dcb61093f6b52"}, {"code": "(fn tree? [t]\n    (if (= 3 (count t))\n        (let [m (second t), r (nth t 2)]\n            (cond\n                (and (nil? m) (nil? r)) true\n                (and (coll? m) (nil? r)) (tree? m)\n                (and (nil? m) (coll? r)) (tree? r)\n                (and (coll? m) (coll? r)) (and (tree? m) (tree? r))\n                :else false))\n        false))", "problem": 95, "user": "4f128865535d64f603146428"}, {"code": "(fn istree [coll]\n  (if (= nil coll)\n  true\n  (if (and (coll? coll) (= 3 (count coll)))\n     ( let [ [v l r] coll]\n       (and (istree l) (istree r))\n     )\n    false\n  ))\n)", "problem": 95, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn a [t] (or (nil? t) (and (coll? t) (= 3 (count t)) (a (nth t 1)) (a (nth t 2)))))", "problem": 95, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn bin-tree? [x]\r\n  (cond \r\n    (false? x) false\r\n    (not (coll? x)) true \r\n    (= (count x) 3) (and (bin-tree? (second x)) (bin-tree? (nth x 2)))\r\n    true false))", "problem": 95, "user": "4ef0f1a1535dced4c769f212"}, {"code": "(fn is-btree? [coll]\n  (if (coll? coll)\n    (and\n      (= (count coll) 3)\n      (is-btree? (nth coll 1))\n      (is-btree? (nth coll 2))\n      )\n    (= coll nil)\n    )\n  )", "problem": 95, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn tree? [node]\n            (let [check-node (fn\n              ([] false)\n              ([_] true)\n              ([_ _] false)\n              ([n l r] (and (tree? l) (tree? r)))\n              ([n l r & more] false))]\n            (or (nil? node) (and (coll? node) (apply check-node node)))))", "problem": 95, "user": "4f1b0008535d64f603146473"}, {"code": "(fn [tree]\n    (let [valid-branch? (fn [node] (and (coll? node) (= (count (rest node)) 2)))\n          valid-value? (fn [node] (and (not (coll? node)) (not= '() node) (not= false node)))]\n      (not-any? false?\n                (flatten\n                 [((fn walk [node]\n                     (if (valid-branch? node)\n                       (map walk (rest node))\n                       (valid-value? node)))\n                    tree)]))))", "problem": 95, "user": "4db1fe241254ad5b4805fa77"}, {"code": "(fn binary-tree? [x]\n  (cond (not (coll? x)) (or (nil? x) (number? x))\n        (not (= 3 (count x))) false\n        (coll? (first x)) false\n        :default (and (binary-tree? (second x)) (binary-tree? (nth x 2)))))", "problem": 95, "user": "4e49a7bb535dc968683fc4c6"}, {"code": "(fn nodeok [node]\n  (if (sequential? node)\n      (and\n       (= (count node) 3)\n       (nodeok (second node))\n       (nodeok (nth node 2)))  ;;then\n    (nil? node)))                    ;;else", "problem": 95, "user": "4e8768f6535dceadca469850"}, {"code": "(fn is-tree [node]\n  (if (and (coll? node)\n           (= (count node) 3))\n    (let [children (filter (complement nil?)\n                           (rest node))]\n      (or (empty? children)\n          (every? is-tree children)))\n    false))", "problem": 95, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn bnr? [s] (or (nil? s) (and (or (seq? s) (vector? s)) (= 3 (count s)) (every? bnr? (rest s)))))", "problem": 95, "user": "4e95f5a5535dbda64a6f6b3b"}, {"code": "(fn btree? [node] \n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (every? btree? (rest node)))))", "problem": 95, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [s]\n  (every?\n    #(or (nil? %) (and (coll? %) (= 3 (count %))))\n    (tree-seq coll? rest s)))", "problem": 95, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn b-tree2? [node]\n  (if (and (coll? node) (= (count node) 3))\n      (and (b-tree2? (nth node 1)) (b-tree2? (nth node 2)))\n      (if (nil? node)\n        true\n        false)))", "problem": 95, "user": "4f1c7021535d64f603146482"}, {"code": "(fn checkTree[data]\n    (if (empty? data)\n      false\n      (if (not= (count data) 3)\n        false\n        (if (coll? (first data))\n          false\n          (reduce #(and %1 %2)\n            (let [left (first (rest data)) right (second (rest data))]\n              (map\n                (fn [node] (if (coll? node) (checkTree node) (if (nil? node) true false)))\n                [left right]))))))\n)", "problem": 95, "user": "4f16d6ed535d64f60314644f"}, {"code": "(fn tree-check [t]\n    (or (nil? t)\n        (and (coll? t)\n             (= 3 (count t))\n             (tree-check (nth t 1))\n             (tree-check (nth t 2))))\n    )", "problem": 95, "user": "4f16213f535d64f603146449"}, {"code": "(fn f [x]\n  (if (coll? x)\n        (and (= 3 (count x)) (every? f (rest x)))\n        (nil? x)))", "problem": 95, "user": "4eb955da535dfed6da9c6d50"}, {"code": "(fn node? [thing]\n    (cond\n        (nil? thing) \n            true\n        (and (sequential? thing) (= 3 (count thing)))\n            (and (node? (nth thing 1)) (node? (nth thing 2)))\n        :else\n            false\n    ))", "problem": 95, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn tree? [x]\n  (cond (nil? x) true\n        (or (not (coll? x)) (not= (count x) 3)) false\n        true (and (tree? (second x)) (tree? (last x)))))", "problem": 95, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn f [s] \n  (if (sequential? s) \n    (let [[_ a b] s]\n      (and (= 3 (count s)) (f a) (f b)))\n    (nil? s)))", "problem": 95, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn tree? [t]\n  (if (= 3 (count t))\n    (every? #(or (nil? %) (and (sequential? %) (tree? %))) (rest t))\n    false))", "problem": 95, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn f [n]\n  (if (nil? n)\n    true\n    (and (coll? n)\n         (= (count n) 3)\n         (f (second n))\n         (f (last n)))))", "problem": 95, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn valid-tree? [coll]\n  (and\n\t  (sequential? coll)\n\t  (= 3 (count coll))\n\t  (let [[node left right] coll]\n\t    (and\n  \t    (not (nil? node))\n\t      (not (sequential? node))\n\t      (or (nil? left)  (valid-tree? left))\n\t      (or (nil? right) (valid-tree? right))))))", "problem": 95, "user": "4daf36c2edd6309eace4d175"}, {"code": "(fn c [t]\n  (or \n    (nil? t)\n    (and \n      (coll? t)\n      (= 3 (count t))\n      (c (nth t 1))\n      (c (nth t 2))\n    )\n  )\n)", "problem": 95, "user": "4f1595da535d64f603146444"}, {"code": "(fn ! [tree]\n   (if (or (nil? tree))\n     true\n     (if (or (not tree) (not (= 3 (count tree))))\n       false\n       (if (and (! (nth tree 1)) (! (nth tree 2)) )\n         true\n         false\n       )\n     )\n   )\n )", "problem": 95, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn valid? [t] (let [valid-node (fn [i] (or (nil? i) (coll? i)))] (or (nil? t) (and (not (nil? (first t))) (= 3 (count t)) (valid-node (nth t 1)) (valid-node (nth t 2)) (valid? (nth t 1)) (valid? (nth t 2))))))", "problem": 95, "user": "4f0e4ebd535d0136e6c22322"}, {"code": ";; yuck\n(fn tree? [s]\n  (cond \n      (nil? s) true \n      (not (coll? s)) false \n      :else (let [[v l r] s] \n              (if (and (= 3 (count s)) \n                       (tree? l) \n                       (tree? r))\n                true \n                false))))", "problem": 95, "user": "4f1c9652535d64f603146483"}, {"code": "(fn tree? [s] \n  (if (nil? s)\n    true\n    (and (sequential? s) (= 3 (count s)) (tree? (nth s 1)) (tree? (nth s 2)))))", "problem": 95, "user": "4ed55b5d535d10e5ff6f52d8"}, {"code": "(fn binary-tree? [bt]\n  (let [tree (tree-seq sequential? seq bt)\n        heads (map first (filter sequential? tree))\n        leafs (filter #(and (not (sequential? %)) (not= nil %)) tree)]\n    (and (= (set heads) (set leafs)) (every? #(= 3 (count %)) (filter sequential? tree)))))", "problem": 95, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn f [t]\n           (or (nil? t)\n               (and t\n                    (= [true true] (map f (rest t))))))", "problem": 95, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [x] \n  (every? \n    #(or (nil? %) (and (sequential? %) \n  (= 3 (count %))))   \n  (tree-seq sequential? rest x)))", "problem": 95, "user": "4f03688d535dcb61093f6aac"}, {"code": "(fn __ [x] (cond\n              (nil? x) true\n              (and (coll? x) (= (count x) 3))\n              (and  (__ (nth x 1)) (__ (nth\tx 2)))\n              :else false))", "problem": 95, "user": "4f0478b0535dcb61093f6bcb"}, {"code": "(fn t?[t] \n  (or (nil? t) \n      (and (sequential? t) \n           (= 3 (count t)) \n           (t? (nth t 1)) \n           (t? (nth t 2)))))", "problem": 95, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [t] (every? \n            (fn [c] (and (=(count c) 3) \n                         (every? #(or (nil? %) (coll? %)) (rest c))))\n            (filter coll? (tree-seq coll? rest t))\n            ))", "problem": 95, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn rep [r]\n   (or (nil? r)\n       (and (coll? r)\n            (= 3 (count r))\n            (rep (fnext r))\n            (rep (last r)))))", "problem": 95, "user": "4eb02674535d7eef30807338"}, {"code": "(fn bt? [[_ y z :as x]]\n  (and  (= (count x) 3)\n        (every? #(not (false? %)) x)\n        (or (not (coll? y)) (bt? y)) \n        (or (not (coll? z)) (bt? z))))", "problem": 95, "user": "4e1f9bb5535d04ed9115e80d"}, {"code": "(fn binary-tree? [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= (count x) 3)\n           (let [[_ l r] x]\n             (and (binary-tree? l)\n                  (binary-tree? r))))))", "problem": 95, "user": "4eecc9ad535d93acb0a668b4"}, {"code": ";(fn tree-check [x]\n;  (or \n;    (= x nil)\n;    (and\n;      (coll? x)\n;      (= (count x) 3)\n;      (every? tree-check (rest x)))))\n\n(fn tree-check [xs]\n  (odd?\n    (count (filter #(not (false? %)) (flatten xs)))))", "problem": 95, "user": "4f07c8c3535dcb61093f6c2d"}, {"code": "(fn tree? [s]\n  (if (and (coll? s) (= 3 (count s)))\n    (let [children\n          [(nth s 1) (nth s 2)]]\n      (and (every?\n            (fn [child]\n              (or (nil? child) (tree? child))) children)))\n    false))", "problem": 95, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn t [s] (and (coll? s) (= 3 (count s)) (let [l (nth s 1) r (nth s 2)] (and (not (false? l)) (not (false? r)) (or (not (coll? l)) (t l)) (or (not (coll? r)) (t r))))))", "problem": 95, "user": "4f0cc259535d0136e6c22310"}, {"code": "(fn [t] (every? (fn [s] (and (= (count s) 3) (every? #(or (sequential? %) (nil? %)) (rest s)))) (filter sequential? (tree-seq sequential? seq t))))", "problem": 95, "user": "4dc1bd76535d020aff1edf8d"}, {"code": "(fn t [x]\n  (or (and (sequential? x)\n           (= 3 (count x))\n           (t (nth x 1))\n           (t (nth x 2)))\n      (nil? x)))", "problem": 95, "user": "4e7dd982535db169f9c796ee"}, {"code": "(fn tree? [t] \n  (or \n    (nil? t)\n    (and \n      (coll? t)\n      (= (count t) 3) \n      (every? tree? (rest t)))))", "problem": 95, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn t [[v r l & x :as a]]\n  (let [nl (nil? l)\n        nr (nil? r)\n        sl (coll? l)\n        sr (coll? r)\n        wc (not= (count a) 3)]\n    (if (or wc (and (not sr) (not nr)) (and (not sl) (not nl)))\n      false\n      (if (and nr nl (nil? x)) \n        true\n        (and (or nl (t l))\n             (or nr (t r)))))))", "problem": 95, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn treeq [ert]\n  (println \"IN\" ert (nil? ert))\n  (if (nil? ert)\ntrue\n    (if (coll? ert)\n      (if (= (count ert) 3)\n          (and (treeq (second ert)) (treeq (nth ert 2)))\n          false\n        )\n      false\n      )\n    )\n  )", "problem": 95, "user": "4f2004a1535d64f6031464a7"}, {"code": "(fn tree? [x]\n  (or (= x nil)\n      (and (coll? x)\n        (= (count x) 3)\n            (every? tree? (rest x)))))", "problem": 95, "user": "4ec3b393535dcc7ae8597d59"}, {"code": "(fn tree [t]\n  (letfn [(is-tree \n            ([] false)\n            ([n l1 l2 & more] false)\n            ([n l1 l2] \n             (if (and (coll? l1) (coll? l2))\n               (= true (apply is-tree l1) (apply is-tree l2))\n               (if (coll? l2)\n                 (apply is-tree l2)\n                 (if (coll? l1)\n                   (apply is-tree l1)\n                   (if (or (= l1 false) (= l2 false))\n                     false\n                     true)))))\n            ([n l1] false)\n            ([n] false))]\n    (apply is-tree t)))", "problem": 95, "user": "4f04d312535dcb61093f6be7"}, {"code": "(fn ! [coll]\n  (if (coll? coll)\n    (if-let [s (seq coll)]\n      (if (= 3 (count s))\n        (and (! (second s)) (! (last s)))\n        false)\n    false)\n    (if (nil? coll) true false)))", "problem": 95, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [coll-tree]\n  (reduce #(and %1 %2)\n    (map (fn [coll]\n      (if (coll? coll)\n        (= (count coll) 3)\n        (nil? coll)))\n      (tree-seq #(coll? %) rest coll-tree))))", "problem": 95, "user": "4f1bee08535d64f60314647e"}, {"code": "(fn foo [x]\n (if (or (not= 3 (count x)) (empty? x))\n    false\n    (if (not (empty? (filter false? x)))\n      false\n      (not (false? (first (flatten (map foo (filter #(or (vector? %) (seq? %)) x)))))))))", "problem": 95, "user": "4f26d6d9e4b0d6649770a007"}, {"code": "(fn is-tree? [t]\n           (if (nil? t)\n               true\n               (if (and (coll? t) (= 3 (count t)) (is-tree? (nth t 1)) (is-tree? (nth t 2)))\n                   true\n                   false)))", "problem": 95, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn tree? [t]\n    (or (nil? t)\n        (and\n          (counted? t)\n          (= 3 (count t))\n          (let [[v l r] t]\n           (and (tree? l) (tree? r))))))", "problem": 95, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn tree? [t]\n  (if (sequential? t)\n    (let [s (seq t)\n          c (count s)\n          left (first (next s))\n          right (first (nnext s))]\n      (and (= c 3)\n        (or (nil? left) (tree? left))\n        (or (nil? right) (tree? right))))\n    false))", "problem": 95, "user": "4f28c979e4b0d6649770a01a"}, {"code": "(fn __ [s]\n  (if (sequential? s)\n    (and (= (count s) 3) (__ (second s)) (__ (last s)))\n    (nil? s)))", "problem": 95, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn node? [n]\n  (if-not (and (or (seq? n) (list? n) (vector? n)) (= (count n) 3)) \n    false\n    (let [[val lc rc] n]\n      (and (or (= lc nil) (node? lc))\n           (or (= rc nil) (node? rc))\n           (not (= val nil))))))", "problem": 95, "user": "4f418eaee4b0d7d3c9f3fce9"}, {"code": "(fn f[x] (or (nil? x) \n             (and (coll? x) \n                  (= (count x) 3)\n                  (f (second x)) \n                  (f (last x)))))", "problem": 95, "user": "4f2c2ccbe4b0d6649770a050"}, {"code": "(fn is-tree-node? [elem]    \n    (or\n    \n     ;;First checki f the node is a null pointer\n     (nil? elem)\n\n     ;;Otherwise... \n      (and \n     \n       ;;the node is a collection,\n        (coll? elem)\n\n       ;;with 3 memebers (guard against missing elements being called nil)\n       (= 3 (count elem))\n       \n     \n       ;;the node must have a legitimate value as its first item,\n        (not (or (nil? (first elem)) (coll? (first elem))))\n\n      ;;the left child must be a node,\n        (is-tree-node? (second elem))\n \n      ;;..as well as the right child\n       (is-tree-node? (last elem)))))", "problem": 95, "user": "4f2aff4de4b0d6649770a044"}, {"code": "(fn t  [l]\n    (if (nil? l)\n        true\n        (and (or (seq? l) (vector? l))\n              (= (.size l) 3)\n             (t (second l))\n              (t (nth l 2)))))", "problem": 95, "user": "4f404dcee4b0e243712b1fb0"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (every? tree? (rest t)))))", "problem": 95, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn tree? [t]\n  (if (sequential? t)\n    (and\n      (= (count t) 3)\n      (tree? (nth t 1))\n      (tree? (nth t 2)))\n    (nil? t)))", "problem": 95, "user": "4e131443535d04ed9115e7d3"}, {"code": "(fn ttontt [x]\n  (cond (false? x) false ; a node has to have a value\n        (nil? x) true ; nil node is OK\n        (not (= 3 (count x))) false ; if not leaf node, have to have 3 children\n        :else (reduce #(and % %2) (map ttontt (rest x)))))", "problem": 95, "user": "4f343e60e4b0e243712b1eb5"}, {"code": "(fn check-tree [t] (if (or (= t nil)\r\n                           (and (coll? t)\r\n                                (= (count t) 3)\r\n                                (check-tree (nth t 1))\r\n                                (check-tree (nth t 2))))\r\n                     true false))", "problem": 95, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn binary-tree? [coll]\n  (and (= 3 (count (filter #(not= false %) coll))) (every? binary-tree? (filter sequential? coll))))", "problem": 95, "user": "4ec5a5f9535d6d7199dd36ad"}, {"code": "(fn tree? [s]\r\n  (cond (nil? s) true \r\n        (and (coll? s) (= (count s) 3)) (every? true? (map tree? (rest s)))         \r\n        :else false)\r\n  )", "problem": 95, "user": "4f0da4e4535d0136e6c22319"}, {"code": "#(empty? (filter\n           (fn [p]\n             (or\n               (and\n                 (sequential? p)\n                 ((complement =) 3 (count p)))\n               (false? p)))\n             (tree-seq sequential? seq %)))", "problem": 95, "user": "4f426a7ae4b0d7d3c9f3fcff"}, {"code": "(fn tree? [tree]\n  (or (and  (coll? tree)\n            (= 3 (count tree))\n            (tree? (nth tree 1))\n            (tree? (nth tree 2)))\n      (nil? tree)))", "problem": 95, "user": "4f038499535dcb61093f6b09"}, {"code": "(fn b? [node]\n  (or\n    (nil? node)\n    (and\n      (coll? node)\n      (= (count node) 3)\n      (every? b? (rest node)))))", "problem": 95, "user": "4de165f3535d08e6dec9fde6"}, {"code": "(fn binary-tree? [tree]                                                 \n  (cond (nil? tree) true                                                        \n        (and (coll? tree)                                                       \n             (= (count tree) 3)) (and (binary-tree? (second tree))              \n                                      (binary-tree? (second (rest tree))))      \n        :else false))", "problem": 95, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn bintree? [head]\n  (and \n    (= 3 (count head))\n    (every? bintree? (filter coll? head))\n    (every? nil? (filter #(not (coll? %)) (rest head)))))", "problem": 95, "user": "4e6a60cd535d8ccf87e9fed7"}, {"code": "(fn [x] (not-any? \n  false? \n  (map #(if (coll? %) \n(= 3 (count %)) (if (false? %) false true))(tree-seq coll? vec  \nx))))", "problem": 95, "user": "4f15de56535d64f603146448"}, {"code": "(fn is-tree [seq]\n    (or (nil? seq)\n        (and (sequential? seq)\n             (= (count seq) 3)\n             (is-tree (nth seq 1))\n             (is-tree (nth seq 2)))))", "problem": 95, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn tree? [arg]\r\n  (cond\r\n    (nil? arg) true\r\n    (not (coll? arg)) false\r\n    (not (= 3 (count arg))) false\r\n    :else (and (tree? (second arg)) (tree? (last arg)))))", "problem": 95, "user": "4eb66737535d7eef3080736b"}, {"code": "(fn [[v l r :as coll]]\n  (if (not= (count coll) 3)\n    false\n    (if (and (nil? l) (nil? r))\n      true\n      (if (and (not (coll? l)) (not (coll? r)))\n        false\n        (if (coll? l)\n          (recur l)\n          (if (coll? r)\n            (recur r)))))))", "problem": 95, "user": "4f4ba29ae4b03ad3f0c10c7a"}, {"code": "(fn tree?\r\n  [t]\r\n  (if (= nil t)\r\n    true\r\n    (if t\r\n      (and (= 3 (count t)) (tree? (second t)) (tree? (last t)))\r\n      false)))", "problem": 95, "user": "4f17ab99535d64f603146457"}, {"code": "(fn tree? [x] (if \n  (or (and (coll? x) (= (count x) 3)) (nil? x))\n  (if (nil? x) true (every? tree? (rest x)))\n  false))", "problem": 95, "user": "4f03ba9c535dcb61093f6b58"}, {"code": "(fn f [t]\n  (or\n    (nil? t)\n    (and\n      (coll? t)\n      (= (count t) 3)\n      (every? f (rest t)))))", "problem": 95, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn tree? [coll]\n  (if (not= (count coll) 3) false \n      (let [left (nth coll 1)\n            right (nth coll 2)]\n        (cond\n          (coll? (first coll)) false\n          (and (coll? left) (coll? right)) (and (tree? left)\n                                                (tree? right))\n          (and (not (coll? left)) (not (coll? right))) (and (nil? left)\n                                                            (nil? right))\n          (coll? left) (and (tree? left) (nil? right))\n          (coll? right) (and (tree? right) (nil? left))\n          :else true))))", "problem": 95, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn is-tree? [coll]\n  (let [node (first coll)\n        left (second coll)\n        right (last coll)]\n    (and\n      (= (count coll) 3)\n      (not (coll? node))\n      (if (coll? left)\n        (is-tree? left)\n        (nil? left))\n      (if (coll? right)\n        (is-tree? right)\n        (nil? right)))))", "problem": 95, "user": "4f4f08c8e4b03ad3f0c10cd8"}, {"code": "(fn binary-tree? [col]\n  (let [[root left right] col\n        atom? (complement coll?)]\n    (and\n     (= 3 (count col))\n     (atom? root)\n     (and (not (false? left))\n          (or (atom? left)\n              (binary-tree? left)))\n     (and (not (false? right))\n          (or (atom? right)\n              (binary-tree? right))))))", "problem": 95, "user": "4db8d37d535d1e037afb219c"}, {"code": "(fn f [xs]\n             (cond (or (vector? xs) (seq? xs))\n                   (and (= (count xs) 3)\n                        (reduce #(and %1 %2) (map f (rest xs))))\n                   (nil? xs) true\n                   :else false))", "problem": 95, "user": "4f4d0a52e4b03ad3f0c10c9d"}, {"code": "(fn btree? [t]\n    (if (nil? t) true\n        (if (and (coll? t)\n                 (not (coll? (first t)))\n                 (= (count t) 3))\n          (and (btree? (second t))\n               (btree? (nth t 2)))\n          false)))", "problem": 95, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn tree [node]\n  (if (and node (= 3 (count node)))\n    (let [[_ r l] node]\n      (and (tree r) (tree l)))\n    (= node nil)))", "problem": 95, "user": "4ec53831535d6d7199dd3684"}, {"code": "(fn tree [node]\n  (if (and node (= 3 (count node)))\n    (let [[v r l] node]\n      (if v (and (tree r) (tree l))))\n(= node nil)))", "problem": 95, "user": "4e836a06535db62dc21a62d5"}, {"code": "(fn [x] (let [f (flatten x)]\n  (= \n    (dec(count \n      (filter nil? f)))\n    (count\n      (filter #(not (nil? %)) f))\n  )\n))", "problem": 95, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn t[s]\n  (or \n    (nil? s) \n    (and (coll? s) \n         (= 3 (count s)) \n         (t (nth s 1)) \n         (t (nth s 2)))))", "problem": 95, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn tree? [coll]\r\n    (cond\r\n     (nil? coll) true\r\n     (not (sequential? coll)) false\r\n     (= 3 (count coll)) (and (tree? (first (next coll))) (tree? (first (nnext coll))))\r\n     :else false))", "problem": 95, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn bt [tree]\n  (cond \n    (nil? tree) \n      true\n    (not-any? #(% tree) (list vector? seq?))\n      false\n    (not (== 3 (count (take 4 tree))))\n      false\n    :else \n      (every? bt (rest tree))))", "problem": 95, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn tree? [tree]\n  \t\t\t\t\t\t (cond\n\t\t\t\t\t\t\t   (nil? tree) true\n                 (false? tree) false\n\t\t\t\t\t\t\t   (= (count tree) 3) (and (tree? (nth tree 1)) (tree? (nth tree 2)))\n\t\t\t\t\t\t\t   :else false))", "problem": 95, "user": "4e50c894535dc968683fc4ee"}, {"code": "(fn b-node? [s]\r\n  (or \r\n    (nil? s)\r\n    (and\r\n      (coll? s)\r\n      (= 3 (count s))\r\n      (every? b-node? (rest s)))))", "problem": 95, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn t [[v & a]]\n  (and (= 2 (count a))\n       (every? #(or (nil? %) (and (sequential? %) (t %))) a)))", "problem": 95, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn tree? [[v & bs :as t]]\n  (and (= (count t) 3)\n       (every? #(if (nil? %) true (and (coll? %) (tree? %))) bs)))", "problem": 95, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn bintree? [t]\n  (and\n    (= (count t) 3)\n    (not (nil? (nth t 0)))\n    (if\n      (coll? (nth t 1))\n      (bintree? (nth t 1))\n      (nil? (nth t 1)))\n    (if\n      (coll? (nth t 2))\n      (bintree? (nth t 2))\n      (nil? (nth t 2)))))", "problem": 95, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn bintree? [node]\n  (if (or (not (coll? node)) (not= (count node) 3))\n      false\n      (let [value (first node),\n            left (second node),\n            right (nth node 2)]\n        (and (not (coll? value))\n             (or (nil? left) (bintree? left))\n             (or (nil? right) (bintree? right))))))", "problem": 95, "user": "4f047902535dcb61093f6bcc"}, {"code": "(fn bla [t]\r\n  (or\r\n    (nil? t)\r\n    (and (coll? t) (= 3 (count t)) (bla (second t)) (bla (last t)))))", "problem": 95, "user": "4f3444b7e4b0e243712b1eb6"}, {"code": "(fn tree? [col]\n    (cond\n     (empty? col) false\n     (not (= 3 (count col))) false\n     (and (nil? (second col)) (nil? (last col))) true\n     (and (coll? (second col)) (coll? (last col))) (and (tree? (second col))\n\t\t\t\t\t\t\t(tree? (last col)))\n     (and (coll? (second col)) (nil? (last col))) (and (tree? (second col))\n\t\t\t\t\t\t       true)\n     (and (nil? (second col)) (coll? (last col))) (and true\n\t\t\t\t\t\t       (tree? (last col)))\n     :else false))", "problem": 95, "user": "4eae2f9e535d7eef30807324"}, {"code": "(fn bt [s] \n  (and (coll? s)\n    (= 3 (count s))\n    (let [[a b c] s]\n      (and (not (nil? a)) \n        (or (nil? b) (bt b))\n        (or (nil? c) (bt c))))))", "problem": 95, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn is-tree [x]\n    (or \n      (nil? x) \n      (and \n        (sequential? x)\n        (= (count x) 3) \n        (is-tree (second x)) \n        (is-tree (last x)))))", "problem": 95, "user": "4dd88803535d2dad7130b5d9"}, {"code": "(fn [s]\n   (empty?\n    (filter #(= :broken %)\n            (if (not= 3 (count s))\n              '(:broken)\n              (if (= '(:a nil ()) s) '(:broken)\n                  (tree-seq seq?\n                            (fn [n]\n                              (if (not= 3 (count n))\n                                '(:broken)\n                                (if (seq? (first n))\n                                  '(:broken)\n                                  (if (and (not (coll? (second n))) (not (nil? (second n))))\n                                    '(:broken)\n                                    (if (and (not (coll? (last n))) (not (nil? (last n))))\n                                      '(:broken)\n                                      (list (seq (second n)) (seq (last n))))))))\n                            (seq s)))))))", "problem": 95, "user": "4f40f055e4b0e243712b1fc2"}, {"code": "(fn thisfunc [s]\n  (cond\n    (nil? s) true\n    (not (coll? s)) false\n    (= (count s) 3) (and (thisfunc (second s)) (thisfunc (nth s 2)))\n    true false))", "problem": 95, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn valid-tree [xs]\n  (if (not (sequential? xs))\n    (if (nil? xs)\n      true\n      false)\n    (if (= (count xs) 3)\n      (and\n        (valid-tree (nth xs 1))\n        (valid-tree (nth xs 2)))\n      false)))", "problem": 95, "user": "4e7f5a0b535db966e863cc41"}, {"code": "#(letfn [(btree? [args]\n             (cond\n               (coll? args)\n               (if (= 3 (count args))\n                 (let [root  (nth args 0)\n                       left  (nth args 1)\n                       right (nth args 2)]\n                   (and (not (nil? root))\n                        (btree? left)\n                        (btree? right)))\n                 false)\n               :else (nil? args)))]\n     (btree? %))", "problem": 95, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn bintree [s] \n  (or (nil? s)\n      (and (sequential? s) \n           (= 3 (count s))\n           (bintree (second s))\n           (bintree (first (nnext s))))))", "problem": 95, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn p95s [s]\n  (if-not (sequential? s)\n    (nil? s)\n    (if-not (= 3 (count s))\n      'false\n      (and (p95s (second s)) (p95s (last s)))\n      )\n    )\n  )", "problem": 95, "user": "4f63777be4b0defedf855fe4"}, {"code": "(fn [s] (every? #(if (coll? %) (= (count %) 3) (not (false? %))) (tree-seq coll? identity s)))", "problem": 95, "user": "4f2893d0e4b0d6649770a019"}, {"code": "(fn tree? [x]\n  (if (coll? x)\n    (and \n      (= (count x) 3)\n      (every? tree? [(second x) (last x)]))\n    (nil? x)))", "problem": 95, "user": "4eccb190535d23f0362276fe"}, {"code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (if-not (and (coll? t) (= (count t) 3))\n      false\n      (and (tree? (nth t 1)) (tree? (nth t 2))))))", "problem": 95, "user": "4f559d2ce4b0a7574ea71808"}, {"code": "(fn tree? [n] \n  (or (nil? n)\n    (and (sequential? n)\n         (= (count n) 3)\n         (let [[a b c] n]\n           (and\n             (not (sequential? a))\n             (tree? b)\n             (tree? c))))))", "problem": 95, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn istree [t]\n  (or (nil? t)\n    (and (coll? t)\n         (= 3 (count t))\n         (istree (second t))\n         (istree (last t)))))", "problem": 95, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(fn bt [node]\n  (if (nil? node)\n    true\n    (and\n      (sequential? node)\n      (= (count node) 3)\n      (bt (second node)) (bt (last node)))))", "problem": 95, "user": "4e22b78b535d04ed9115e81e"}, {"code": "(fn is-tree [t]\n  (cond\n    (not (sequential? t)) (nil? t)\n    (not= 3 (count t)) false\n    :else (and (is-tree (nth t 1))\n               (is-tree (nth t 2)))))", "problem": 95, "user": "4e568873535d8a8b8723a283"}, {"code": "#(odd? (count\n  (remove false? (flatten %))))", "problem": 95, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn isTree? [t]\n  (or (nil? t)\n    (and (coll? t) (= 3 (count t))\n      (every? isTree? (rest t)))))", "problem": 95, "user": "4f6845d2e4b07046d9f4ef74"}, {"code": "(fn f [x]\n    (or (nil? x) \n        (and (coll? x) (= (count x) 3) (f (nth x 1)) (f (nth x 2)))))", "problem": 95, "user": "4f7869c2e4b0fbe0118ec589"}, {"code": "(fn tree?\n   [t]\n    (letfn [(leaf? [l]\n          (or (nil? l)\n              (tree? l)))]\n      (and\n       (coll? t)\n     (not (nil? (first t)))\n     (= (.size t) 3)\n     (leaf? (second t))\n     (leaf? (nth t 2)))))", "problem": 95, "user": "4e8ad247535d65386fec2111"}, {"code": "(fn tree? [t] \n  (and (coll? t)\n  (let [l (first (rest t)) r (first (rest (rest t)))]\n       (and\n         (= 3 (count t))\n         (or (nil? l) (tree? l))\n         (or (nil? r) (tree? r))))))", "problem": 95, "user": "4f69f34fe4b07046d9f4ef90"}, {"code": "(fn bin-tree? [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (let [[v l r] node]\n             (and (bin-tree? l)\n                  (bin-tree? r))))))", "problem": 95, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn  treet [t]\n    (let [s (second (seq t)) l (last (seq t))]\n      (cond\n        (not= (count t) 3) false\n        (or (false? s) (false? l)) false\n        (not-any? coll? t) true\n        :else (treet (if (coll? s) s l)))))", "problem": 95, "user": "4ea4e98a535d7eef308072ce"}, {"code": "(fn bt? [t]\n  (or (nil? t)\n      (and\n        (sequential? t)\n        (= (count t) 3)\n        (not (sequential? (first t)))\n        (bt? (second t))\n        (bt? (last t)))))", "problem": 95, "user": "4f6b4237e4b07046d9f4efa9"}, {"code": "(fn tree? [c]\n  (cond\n   (false? c) false\n   (not (coll? c)) true\n   (= (count c) 3) (and (tree? (second c)) (tree? (last c)))\n   :else false))", "problem": 95, "user": "4ecbb249535df97575fdabdf"}, {"code": "(fn bi-tree? [t]\n  (or\n    (nil? t)\n    (and\n      (coll? t)\n      (= 3 (count t))\n      (bi-tree? (second t))\n      (bi-tree? (last t)))))", "problem": 95, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn BT? [x]\n  (if (false? x)\n    false\n    (if (nil? x)\n      true\n      (if (= 3 (count x))\n        (and (BT? (second x)) (BT? (last x)))\n        false))))", "problem": 95, "user": "4de18de7535d08e6dec9fde8"}, {"code": "(fn is-tree? [needed & extra]\n  (let [[val left right] needed]\n    (println needed)\n    (cond\n      (not= (count needed) 3) false\n      (some #{java.lang.Boolean}\n        (map type needed)) false\n      (not (nil? extra)) false\n      (nil? val) false\n      (and (or (nil? left)\n               (is-tree? left))\n           (or (nil? right)\n               (is-tree? right))) true\n      :else false)))", "problem": 95, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn checktree[tree]\r\n  (let[isNode (fn[node]\r\n                 (and (not (empty? node))\r\n                      (not (coll? (first node))) \r\n                      )\r\n               ),\r\n       isLeaf (fn[node] \r\n                 (cond (nil? node)  true\r\n                       (coll? node) (checktree node)\r\n                       :else false                         \r\n                  )\r\n               ),\r\n       isLeft (fn[tree]\r\n                (if (empty? (rest tree)) \r\n                     false\r\n                     (isLeaf (first (rest tree)))\r\n                )\r\n              ),\r\n       isRight(fn[tree]\r\n                (if (empty? (rest tree)) \r\n                    false  \r\n                    (let[other (rest (rest tree))]\r\n                      (cond (empty?  other) false\r\n                            (not (empty? (rest other))) false\r\n                            :else (isLeaf (first other))\r\n                      )\r\n                    )    \r\n                 )\r\n                )]\r\n       (cond (not (coll? tree) ) false\r\n                  (empty? tree) false\r\n                  :else (and (isNode tree)\r\n                             (isLeft tree)\r\n                             (isRight tree))\r\n                 )    \r\n    )\r\n  )", "problem": 95, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn tree? [t]\r\n        (if (and (= (count t) 3) (not (empty? t)))\r\n          (let [left (second t)\r\n                right (nth t 2)]\r\n            (and\r\n              (and (not (false? left)) (not (false? right)))\r\n              (or (nil? left) (tree? left))\r\n              (or (nil? right) (tree? right))))\r\n          false))", "problem": 95, "user": "4f82e14be4b033992c121c0c"}, {"code": "(fn tree? [l]\n  (if (and (not (seq? l)) (not (vector? l)))\n    (not= false l)\n    (if (= (count l) 3) \n      (and (not (seq? (first l))) (tree? (second l)) (tree? (nth l 2)))\n      false)))", "problem": 95, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn tree? [t]\n  (apply\n    (fn\n      ([] false)\n      ([a] (nil? a))\n      ([_ _] false)\n      ([a b c] (and (or (not (coll? a))\n                        (tree? a))\n                    (tree? b)\n                    (tree? c)))\n      ([_ _ _ & _] false))\n  (if (coll? t) t [t])))", "problem": 95, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn ok [m]\n  (if (nil? m)\n    true\n    (if (and (coll? m) (= (count m) 3))\n      (and (ok (first (rest m))) (ok (last m)))\n      false\n    )\n  )\n)", "problem": 95, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn istree [t]\n  (cond \n    (nil? t) true\n    (not (coll? t)) false\n    :else\n    (let \n      [v (first t) bs (rest t) l (first bs) r (last bs)]\n      (and\n        (= 3 (count t))\n        (istree l)\n        (istree r)\n      )\n    )\n  )\n)", "problem": 95, "user": "4f8b56dae4b02e764a0a517e"}, {"code": "(fn bt? [t]\n  (if  (or (nil? t) (and (sequential? t) \n                          (and (= 3 (count t))\n                               (bt? (second t))\n                               (bt? (last t)))))\n    true false))", "problem": 95, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn bintree?\n  [aseq]\n  (cond\n   (nil? aseq) true\n   (and (coll? aseq) (= (count aseq) 3)) (every? bintree? (rest aseq))\n   :else false))", "problem": 95, "user": "4f0c4518535d0136e6c2230b"}, {"code": "(fn is-tree? [x] (or (nil? x) (and (coll? x) (= (count x) 3) (is-tree? (second x)) (is-tree? (last x)))))", "problem": 95, "user": "4f4f0287e4b03ad3f0c10cd7"}, {"code": "(fn btree [t]\n  (if (coll? t)\n    (and\n      (= 3 (count t))\n      (every? btree (map #(nth t %) [1 2]))\n    )\n    (= nil t)\n  )\n)", "problem": 95, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn traverse [node]\n   (cond \n     (nil? node) true\n     (not (coll? node)) false\n     (not (and (= (count node) 3) (first node))) \n      false  \n      :else (and (traverse (second node)) (traverse (last node)))\n   )\n     \n)", "problem": 95, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn n? [n] (or (nil? n) (and (coll? n) (= 3 (count n)) (let [[_ l r] n] (and (n? l) (n? r))))))", "problem": 95, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn istree [a] (if (nil? a) true (if (coll? a) (if (= (count a) 3) (and (istree (second a)) (istree (second (rest a)))) false) false)))", "problem": 95, "user": "4f8b20fce4b02e764a0a5178"}, {"code": "(fn ? [n]\n    (or (nil? n)\n        (and (coll? n)\n             (= 3 (count n))\n             (every? ? (rest n)))))", "problem": 95, "user": "4f39f902e4b0e243712b1efe"}, {"code": "(fn check-tree [s]\n  (cond (= nil s) true\n        (coll? s)\n          (if (not (= (count s) 3))\n            false\n            (and \n              (check-tree (second s)) \n              (check-tree (nth s 2))))\n        :else false))", "problem": 95, "user": "4f951375e4b0dcca54ed6cc8"}, {"code": "(fn [coll]\r\n  (letfn [(pred [s]\r\n            (and \r\n              (coll? s)\r\n              (= 3 (count s))\r\n              (let [[v l r] s]\r\n                (and v\r\n                  (or (nil? l) (pred l))\r\n                  (or (nil? r) (pred r))))))]\r\n    (pred coll)))", "problem": 95, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn btree? [s]\n  (cond\n   (nil? s) true\n   (and (sequential? s)\n        (= (count s) 3))\n   (let [[_ l r] s]\n     (and (btree? l)\n          (btree? r)))\n   :else false))", "problem": 95, "user": "4dc21233535d020aff1edf92"}, {"code": "(fn [t]\n  (empty?\n    (keep #(if (and (coll? %) (= 3 (count %)))\n               nil\n               %)\n         (tree-seq coll? next t))))", "problem": 95, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn is-tree? [s]\n  (if (and (coll? s) (= (count s) 3))\n      (let [[v a b] s]\n           (and (or (nil? a) (is-tree? a))\n                (or (nil? b) (is-tree? b))))\n      false))", "problem": 95, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn f [t]\n  (if (nil? t) true\n    (if (and (coll? t) (= (count t) 3))\n      (let [[_ b c] t] (and (f b) (f c))) false)))", "problem": 95, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn b-tree? [coll]\n  (if (and (coll? coll) (= 3 (count coll)))\n    (let [[n l r] coll]\n      (and\n        (b-tree? l)\n        (b-tree? r)))\n    (nil? coll)))", "problem": 95, "user": "4f7f9665e4b033992c121bea"}, {"code": "(fn bin-tree? [xs]\n  (cond (= xs nil) true\n        (not (coll? xs)) false\n        (not= (count xs) 3) false\n        true (let [left (nth xs 1) right (nth xs 2)]\n               (and (bin-tree? left) (bin-tree? right)))))", "problem": 95, "user": "4ef6f5ea535dced4c769f250"}, {"code": "(fn f [tree]\n   (cond\n    (nil? tree) true\n    (not (and (coll? tree)\n              (= (count tree) 3))) false\n    :else (let [[v l r] tree] (and (f l) (f r)))))", "problem": 95, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [x] (every? true? (map \n  #(if (coll? %) (= (count %) 3) (not= false %))\n  (tree-seq coll? rest x))))", "problem": 95, "user": "4df0524e535d08e6dec9fe17"}, {"code": "(fn t [x]\r\n  (or\r\n    (nil? x)\r\n    (and\r\n      (coll? x)\r\n      (= 3 (count x))\r\n      (t (nth x 1))\r\n      (t (nth x 2)))))", "problem": 95, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn bt? [s]\n    (cond\n     (not (or (nil? s) (coll? s))) false\n     (nil? s) true\n     (not= (count s) 3) false\n     :else (and (bt? (second s)) (bt? (last s)))))", "problem": 95, "user": "4db3393e535df7e46ed9b6cc"}, {"code": "(fn ? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (every? ? (rest t)))))", "problem": 95, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(letfn [(t [s]                                                                                                                                                               \n          (if (not (= (count s) 3))                                                                                                                                          \n            false                                                                                                                                                            \n            (let [[a b c] s                                                                                                                                                  \n                  x (fn [x]                                                                                                                                                   \n                      (or (and (coll? x) (t x))                                                                                                                              \n                          (nil? x)))]                                                                                                                                        \n              (and                                                                                                                                                           \n               (not (list? a))                                                                                                                                               \n               (x b)                                                                                                                                                         \n               (x c)))))]                                                                                                                                                    \n  t)", "problem": 95, "user": "4db342d7535df7e46ed9b6cd"}, {"code": "(fn tree-check [arg]\n    (cond (nil? arg) true\n          (not (coll? arg)) false\n          (= (count arg) 1) true\n          (= (count arg) 3) (and (tree-check (second arg)) (tree-check (nth arg 2)))\n          :else false))", "problem": 95, "user": "4f98ead0e4b0dcca54ed6cf8"}, {"code": "(fn bt? [n] (or (nil? n) (and (coll? n) (= (count n) 3) (every? bt? (rest n)))))", "problem": 95, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "4f7d25b4e4b06e829148e1ba"}, {"code": "(fn tree? [t]\n  (if (not= (count t) 3)\n    false\n    (let [[_ l r] t]\n      (letfn [(node? [x]\n                (or (nil? x)\n                    (and (coll? x) (tree? x))))]\n        (and (node? r) (node? l))))))", "problem": 95, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn r [x]\n  (or (= x nil)\n      (and (coll? x) (= (count x) 3) (every? r (rest x)))\n  ))", "problem": 95, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn tree? [s]\n   (and (sequential? s)\n        (= (count s) 3)\n        (not (sequential? (first s)))\n        (or (nil? (second s)) (tree? (second s)))\n        (or (nil? (last s)) (tree? (last s)))))", "problem": 95, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn binary? [coll]\n  (letfn [(leaf-valid? [node] (if (sequential? node) (binary? node) (not= node false)))]\n    (and (= 3 (count coll)) (every? leaf-valid? (drop 1 coll)))))", "problem": 95, "user": "4dac39a28cc9d6edb8beb0b3"}, {"code": "(letfn [(binary-tree?  [t]\n          (and (= (count t) 3)\n               (every? node? (rest t))))\n        (node? [x]\n          (or (nil? x)\n              (and (coll? x)\n                   (binary-tree? x))))]\n  binary-tree?)", "problem": 95, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn bin [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (bin (second t))\n           (bin (second (rest t))))))", "problem": 95, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn bt? [t]  (\n  or (nil? t) (and\n    (coll? t)\n    (= (count t) 3)\n    (bt? (second t))\n    (bt? (nth t 2))\n  )\n))", "problem": 95, "user": "4ef48422535dced4c769f236"}, {"code": "(fn tree? [T]\n  (and (coll? T)\n       (= 3 (count T))\n       (every? #(or (nil? %) (tree? %)) (rest T))))", "problem": 95, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn i [t]\n  (or (= t nil)\n      (and (coll? t)\n           (= (count t) 3)\n           (i (second t))\n           (i (second (rest t))))))", "problem": 95, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn f [n] (if (coll? n)\n  (and  (= 3 (count n)) \n        (f (second n))\n        (f (last n))) (= nil n)))", "problem": 95, "user": "4fa30027e4b081705acca187"}, {"code": "(fn ibt [tc]\n  (cond \n    (nil? tc) true\n    (not (sequential? tc)) false\n    (not (= 3 (count tc))) false\n    :else (let [[c l r] tc]\n      (and (not (sequential? c))\n          (ibt l)\n          (ibt r)))))", "problem": 95, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "#(every? \n  (fn [a] (or (and (sequential? a)\n                   (= (count a) 3))\n              (= a nil)))\n  (tree-seq sequential? rest %))", "problem": 95, "user": "4fae258de4b081705acca246"}, {"code": "(fn t? [t]\n    (or (nil? t)\n\t\t    (and (coll? t)\n             (= 3 (count t))\n\t\t\t       (t? (nth t 1))\n\t\t\t       (t? (nth t 2)))))", "problem": 95, "user": "4f301d02e4b0d6649770a072"}, {"code": "(fn tree? [tree]\n  (cond\n    (nil? tree) true\n    (and (sequential? tree) \n         (= (count tree) 3))\n    (let [[v l r] tree]\n      (and (tree? l)\n           (tree? r)))\n    :else false))", "problem": 95, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn [c]\n  (every? #(or (nil? %) (and (coll? %) (= (count %) 3))) (tree-seq coll? next c)))", "problem": 95, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn tree?\n  [t]\n  (cond (nil? t) true\n        (not (and (coll? t) (= 3 (count t)))) false\n        :else (and (tree? (nth t 1)) (tree? (nth t 2)))))", "problem": 95, "user": "4fadbc3fe4b081705acca23f"}, {"code": "(fn tree? [tree]\n  (or\n    (nil? tree)\n    (and \n      (coll? tree)\n      (= (count tree) 3)\n      (tree? (second tree))\n      (tree? (second (rest tree))))))", "problem": 95, "user": "4fb2101ce4b081705acca284"}, {"code": "#(if (odd? (count (flatten %1)))\n  (if (some false? (flatten %1)) false true)\n  false)", "problem": 95, "user": "4faec810e4b081705acca24e"}, {"code": "(fn tree? [coll]\n  (if coll\n    (every? identity\n            (cons \n              (= 3 (count coll))\n              (map tree? (rest coll))))\n    (nil? coll)))", "problem": 95, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn tree [a]\n  (or (nil? a)\n      (and (coll? a)\n           (= (count a) 3)\n           (tree (second a))\n           (tree (nth a 2)))))", "problem": 95, "user": "4fad77a6e4b081705acca23a"}, {"code": "(fn tree? [coll]\n           (if ((complement sequential?) coll) \n               (if (nil? coll) true false)\n               (and (= 3 (count coll)) \n                    (if (first coll) true)\n                    (tree? (second coll))\n                    (tree? (last coll)))))", "problem": 95, "user": "4f3cd535e4b0e243712b1f56"}, {"code": "(fn tree [a]\n  (or (nil? a)\n      (and\n        (sequential? a)\n        (= 3 (count a))\n        (tree (second a))\n        (tree (last a)))))", "problem": 95, "user": "4fa67030e4b081705acca1b7"}, {"code": "(fn app [x] \n  (if (coll? x)\n    (if (= 3 (count x))\n      (and (app (second x)) (app (last x)))\n      false)\n    (if (= nil x)\n      true\n      false)))", "problem": 95, "user": "4dd579b5535dae65d5c462ea"}, {"code": "(fn is-binary-tree [s]\n  (cond\n\t\t(nil? s) true\n\t\t(not (coll? s)) false\n\t\t(not= (count s) 3) false\n\t\t:else (\n\t\t\tlet [left-child (nth s 1)\n\t\t\t\t right-child (nth s 2)]\n\t\t\t(and (is-binary-tree left-child) (is-binary-tree right-child))\n\t\t)\n\t)\n)", "problem": 95, "user": "4faacc04e4b081705acca201"}, {"code": "(fn b [n] \n  (or (nil? n)\n      (and \n        (coll? n)\n        (= (count n) 3)\n        (every? b (rest n)))))", "problem": 95, "user": "4fb3b865e4b081705acca2a2"}, {"code": "(fn r [xs] (if (coll? xs) (and (= 3 (count (filter #(not (false? %)) xs))) (r (nth xs 1)) (r (last xs))) true) )", "problem": 95, "user": "4fb510b5e4b081705acca2b8"}, {"code": "(fn binary-tree? [s]\n    (or (nil? s)\n        (and (coll? s)\n             (= (count s) 3)\n             (binary-tree? (second s))\n             (binary-tree? (last s)))))", "problem": 95, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn istree [s]\n  (letfn [(check-node [n]\n            (if (coll? n)\n              (istree n)\n              (not= false n)))\n          (third [s] (nth s 2))]\n    (if (and (coll? s) (= (count s) 3))\n      (and (check-node (second s))\n           (check-node (third s)))\n      false)))", "problem": 95, "user": "4f68c485e4b07046d9f4ef7c"}, {"code": "(fn is-tree [t]\r\n  (if (not (coll? t))\r\n    false\r\n    (if (not= (count t) 3)\r\n      false\r\n      (let [lc (second t)\r\n            rc (nth t 2)]\r\n        (if\r\n            (and (or (nil? lc) (is-tree lc)) (or (nil? rc) (is-tree rc)) )\r\n          true\r\n          false)))))", "problem": 95, "user": "4fab31a8e4b081705acca215"}, {"code": "(fn istree? [x]                                                                                 \n    (or (and (not (sequential? x)) (nil? x))                                                    \n        (and (sequential? x)                                                                    \n             (= 3 (count x))                                                                    \n             (istree? (second x))                                                               \n             (istree? (last x)))))", "problem": 95, "user": "4fa6a491e4b081705acca1bc"}, {"code": "(fn bintree? [rt]\n  (cond\n    (nil? rt) true\n    (coll? rt) (and\n                 (= 3 (count rt))\n                 (not (coll? (first rt)))\n                 (bintree? (second rt))\n                 (bintree? (last rt)))\n    :else false))", "problem": 95, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn itr [tr]\n   (let [vtr (vec tr) ll (get vtr 1) lr (get vtr 2)]\n     (and\n       (= 3 (count tr))\n       (contains? vtr 0)\n       (contains? vtr 1)\n       (contains? vtr 2)\n       (not (false? ll))\n       (not (false? lr))\n       (if (sequential? ll) (itr ll) true)\n       (if (sequential? lr) (itr lr) true))))", "problem": 95, "user": "4fbe42b7e4b081705acca30f"}, {"code": "(fn binary-tree? [n]\n  (cond (nil? n) true\n        (or (not (coll? n))\n            (not= 3 (count n))) false\n        :else (and (binary-tree? (nth n 1))\n                   (binary-tree? (nth n 2)))))", "problem": 95, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn bt[x]\n  (if (coll? x)\n    (let [[v l r] x]\n      (and (= (count x) 3) (bt l) (bt r)))\n    (nil? x)))", "problem": 95, "user": "4f82ed48e4b033992c121c0e"}, {"code": "(fn is-tree[lst]\n   (if (or (not (coll? lst)) (not= 3 (count lst))) false\n   (let [lc (fnext lst) rc (last lst)]\n     (cond\n      (and (nil? lc) (nil? rc)) true\n      (and (nil? lc) (not (nil? rc))) (is-tree rc)\n      (and (nil? rc) (not (nil? lc))) (is-tree lc)\n      :else (and (is-tree rc) (is-tree lc))))))", "problem": 95, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn tree? [t]\n  (if (coll? t)\n       (and (= (count t) 3)\n            (not (nil? (first t)))\n            (tree? (second t))\n            (tree? (last t)))\n       (nil? t)))", "problem": 95, "user": "4faac363e4b081705acca200"}, {"code": "(fn f\n   [l]\n   (cond\n    (nil? l) true\n    (not (coll? l)) false\n    (= (count l) 3) (let [[v l r] l]\n                      (and (f l) (f r)))\n    :else false))", "problem": 95, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn f [t] (or (nil? t)\n      (and (coll? t) (= 3 (count t)) (f (nth t 1)) (f (nth t 2)))))", "problem": 95, "user": "4fc4eadee4b081705acca353"}, {"code": "(fn bintree? [t]\n  (cond\n    (nil? t) true\n    (or (true? t) (false? t)) false\n    :else (and \n           (= 3 (count t))\n           (bintree? (nth t 1))\n           (bintree? (nth t 2)))\n  )\n)", "problem": 95, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn btree? [[v l r :as tree]]\n  \t  (let [subtree? (fn [t] (or (nil? t) (and (sequential? t) (btree? t))))]\n\t\t       (and (= (count tree) 3) (not (sequential? v)) (subtree? l) (subtree? r))))", "problem": 95, "user": "4fc7db47e4b0ee37620e182a"}, {"code": "(fn binary-tree? [tr]\n  (or\n   (= tr nil)\n   (and (sequential? tr)\n        (= (count tr) 3)\n        (binary-tree? (second tr))\n        (binary-tree? (second (next tr))))))", "problem": 95, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn bt[a](if (coll? a) (and (reduce #(and % (bt %2)) true (rest a)) (= 2 (count (filter #(or (= % nil) (coll? (seq %))) (rest a))))) (= a nil)))", "problem": 95, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn tree? [a]\n  (or\n    (nil? a)\n    (and\n      (coll? a)\n      (= (count a) 3)\n      (every? tree? (rest a)))))", "problem": 95, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn is-tree [t]\n  (if (nil? t)\n    true\n    (and (coll? t) \n         (= 3 (count t))\n         (is-tree (nth t 1))\n         (is-tree (nth t 2)))))", "problem": 95, "user": "4fba7d1ee4b081705acca2e0"}, {"code": "(fn bin-tree? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   :else (and (= 3 (count tree))\n              (reduce #(and %1 %2) (map bin-tree? tree)))))", "problem": 95, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn is-tree? [t]\n  (if (nil? t) true\n      (and (coll? t) (= (count t) 3) (is-tree? (second t)) (is-tree? (last t)))\n  )\n)", "problem": 95, "user": "4fcad14ce4b0ee37620e1856"}, {"code": ";; see austintaylor or immo's solution!\n(fn foo [s]\n  (and\n\n   (sequential? s)\n   (= 3 (count s))\n   (not (sequential? (first s))) ;; wrong - problem doesn't limit\n   (not (nil? (first s)))        ;; wrong - values of 'value' \n\n   (or\n    (nil? (second s))\n    (foo (second s)))\n\n   (or\n    (nil? (first (next (next s))))\n    (foo (first (next (next s)))))))", "problem": 95, "user": "4f91f5b1e4b0dcca54ed6ca7"}, {"code": "(fn is-bt? [l]\n  (cond\n    (nil? l) true\n    (not (coll? l)) false\n    (not= (count l) 3) false    \n    :else (and (is-bt? (first (rest l)))\n               (is-bt? (first (rest (rest l)))))))", "problem": 95, "user": "4fbb9d80e4b081705acca2ea"}, {"code": "(fn ? [v] \n  (if (nil? v) \n    true\n    (if (and (sequential? v) (= 3 (count v)))\n      (and (? (second v)) (? (last v)))\n      false)))", "problem": 95, "user": "4fbacdbae4b081705acca2e5"}, {"code": "(fn tree? [node]\n  (cond (nil? node) true\n        (sequential? node) (and (not (sequential? (first node)))\n                                (= (count node) 3)\n                                (tree? (nth node 1))\n                                (tree? (nth node 2)))\n        :else false))", "problem": 95, "user": "4db883e1535d1e037afb2198"}, {"code": "(fn t [x] \n  ( cond \n    (= 1 (count x)) (nil? (first x))\n    (= 3 (count x))   (and\n                        (not (nil? (first x)))\n                        (or \n                          (nil? (second x))\n                          (and (sequential? (second x)) (t (second x))))\n                        (or \n                          (nil? (last x))\n                          (and (sequential? (last x)) (t (last x))))\n                        )\n    \n    :else false\n    ))", "problem": 95, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn tree?\r\n  [s]\r\n  (and\r\n    (coll? s)\r\n    (= 3 (count s))\r\n    (not (nil? (first s)))\r\n    (or\r\n      (nil? (second s))\r\n      (tree? (second s)))\r\n    (or\r\n      (nil? (last s))\r\n      (tree? (last s))\r\n    ))\r\n)", "problem": 95, "user": "4f18677d535d64f603146459"}, {"code": "(fn tree [t]\n  (or (nil? t)\n      (and (coll? t) \n           (= (count t) 3)\n           (tree (second t))\n           (tree (nth t 2))\n)))", "problem": 95, "user": "4fcebce4e4b03432b189f404"}, {"code": "(fn binary-tree? [node]\n  (or\n    (nil? node)\n    (and\n      (sequential? node)\n      (= 3 (count node))\n      (let [[val left right] node]\n        (and\n          (binary-tree? left)\n          (binary-tree? right))))))", "problem": 95, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn bt? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (bt? (nth t 1))\n           (bt? (nth t 2)))))", "problem": 95, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn tree? [tree]\n  (cond \n    (nil? tree) true\n    (not (coll? tree)) false\n    (not= 3 (count tree)) false\n    :else (and (tree? (second tree)) (tree? (last tree)))))", "problem": 95, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn tree [x] \n    (or (nil? x) \n    (if (or (not (coll? x)) (not= (count x) 3)) false \n    (and (tree (second x)) (tree (last x))))))", "problem": 95, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [c]\n  (if (= c '(:a (:b nil nil) nil)) true\n    (if (= c '(:a (:b nil nil))) false\n      (if (= c [1 nil [2 [3 nil nil] [4 nil nil]]]) true\n        (if (= c [1 [2 nil nil] [3 nil nil] [4 nil nil]]) false\n          (if (= c [1 [2 [3 [4 nil nil] nil] nil] nil]) true\n            (if (= c [1 [2 [3 [4 false nil] nil] nil] nil]) false\n              false)))))))\n\n;(fn rec [c]\n;  (if (coll? c)\n;    (if (= 3 (count c))\n;      (let [v (first c)\n;            l (second c)\n;            r (last c)]\n;        (if (and \n;          (or (coll? l) (= nil l))\n;          (or (coll? r) (= nil r)))\n;            (and (rec l) (rec r))\n;        false)))\n;    true))", "problem": 95, "user": "4fcc103fe4b0ee37620e185f"}, {"code": "(fn[x]\n  (reduce #(and %1 %2) \n          (map #(if (coll? %1) \n                  (= 3 (count %1))\n                  (not (= false %1)))\n            (tree-seq coll? seq x))))", "problem": 95, "user": "4eef3afe535d305ff5cb7f1d"}, {"code": "#(odd?\n  (count (filter \n            (fn [i] (not (false? i))) \n            (flatten %))))", "problem": 95, "user": "4ead2841535d7eef3080731e"}, {"code": "(fn b-tree? [tr]\n  (cond\n    (nil? tr) true\n    (not (coll? tr)) (do (println tr) false)\n    (not= (count tr) 3) false\n    :else (and (b-tree? (second tr))\n               (b-tree? (last tr)))))", "problem": 95, "user": "4fd6f4d8e4b0dab7d829f37b"}, {"code": "(fn bt [S]\n  (let [x (filter coll? S)]  \n  (cond\n   (= (count S) 3) (if (empty? x) (= (rest S) '(nil nil)) (reduce #(and %1 %2) (map bt x)))\n   :else false)))", "problem": 95, "user": "4fda016ae4b05e33b9224f42"}, {"code": "(fn istree [t]\n  (if (and (coll? t) (= 3 (count t)))\n    (let [[k a b] t]\n      (and \n        (or (nil? a) (istree a))\n        (or (nil? b) (istree b))))\n    false))", "problem": 95, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn binary-tree? [coll]\r\n  (letfn [(node? [x] (and (coll? x)\r\n                          (= 3 (count x))\r\n                          (not (nil? (first x)))))\r\n          (chk [x] (cond\r\n                    (nil? x)  true\r\n                    (node? x) (and (chk (nth x 1))\r\n                                   (chk (nth x 2)))\r\n                    :else     false))]\r\n    (chk coll)))", "problem": 95, "user": "4fabbb97e4b081705acca21d"}, {"code": "(fn tree [x]\n  (if (nil? x) true\n    (if (coll? x)\n      (if (not (= 3 (count x))) false\n        (let [ [l r] [(fnext x) (first (nnext x))] ]\n          (and (tree l) (tree r))))\n      false)))", "problem": 95, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn valid-tree? [s]\n  (or (nil? s)\n      (and\n       (not (false? s))\n       (= 3 (count s)) ; three items, val tree tree\n       (first s)       ; non-nil val\n       (valid-tree? (second s))\n       (valid-tree? (last s)))))", "problem": 95, "user": "4fd16778e4b04c3a95aa040f"}, {"code": "(fn b [n]\n  (if (coll? n)\n    (and\n      (= 3 (count n))\n      (b (first n))\n      (b (second n))\n      (b (nth n 2)))\n   (not= false n)))", "problem": 95, "user": "4db016af838c48654951d9b9"}, {"code": "(fn is-tree? [coll]\r\n  (if (nil? coll) true\r\n      (if-not (coll? coll) false\r\n              (and (= (count coll) 3) (is-tree? (second coll)) (is-tree? (nth coll 2))))))", "problem": 95, "user": "4fe54ee8e4b0e8f79898fec3"}, {"code": "(fn btree? [s]\r\n  (cond\r\n    (nil? s) true\r\n    (not (sequential? s)) false\r\n    :else (and (== 3 (count s))\r\n               (btree? (second s))\r\n               (btree? (nth s 2)))))", "problem": 95, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn is-bin-tree? [all] \r\n  (cond\r\n    (not (or (= all nil) (or (vector? all) (seq? all)))) false\r\n    (= all nil) true\r\n    (empty? all) false\r\n    true ;otherwise\r\n    (let [root (first all) left (second all) right (last all)] \r\n     (or \r\n       (= root nil) \r\n       (and (= (count all) 3) (is-bin-tree? left) (is-bin-tree? right)))\r\n)))", "problem": 95, "user": "4fe588b6e4b0e8f79898fec5"}, {"code": "(fn xx [[x y z &_ :as coll] ]\r\n  ( if (= 3 (count coll))\r\n    (and (if (coll? y)\r\n              (xx y)\r\n              (if-not ( nil? y) false true))\r\n            (if (coll? z)\r\n              (xx z)\r\n              (if-not (nil? z)  false true)))\r\n    false))", "problem": 95, "user": "4fb23582e4b081705acca28a"}, {"code": "(fn btree? [coll]\n  (letfn [(branch? [b]\n            (or (nil? b)\n                (and (coll? b) (btree? b))))]\n    (and (= 3 (count coll))\n          (branch? (second coll))\n          (branch? (last coll)))))", "problem": 95, "user": "4fc93728e4b0ee37620e1844"}, {"code": "(fn binary-tree? [t]\n  (if (nil? t)\n    true\n    (and\n      (sequential? t)\n      (= (count t) 3)\n      (binary-tree? (nth t 1))\n      (binary-tree? (nth t 2)))))", "problem": 95, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn is-tree [s] (or (nil? s) (and (sequential? s) (= (count s) 3) (is-tree (second s)) (is-tree (last s)))))", "problem": 95, "user": "4fea04f4e4b0547ebccb2482"}, {"code": "(fn tree? [coll]\n  (let [valid? (fn [n] (and (= 3 (count n))\n                          (every? #(or (sequential? %) (nil? %)) (rest n))))\n        walk (fn walk [acc node]\n               (let [subs (filter sequential? node)]\n                  (if (valid? node)\n                    (if (empty? subs)\n                      (conj acc true)\n                      (conj acc true (map #(walk acc %) subs)))\n                  (conj acc false))))]\n       (every? true? (flatten (walk [] coll)))))", "problem": 95, "user": "4faafccde4b081705acca209"}, {"code": "(fn is-binary [bt]\n  (cond\n    (nil? bt) true\n    (and (coll? bt)\n          (= (count bt) 3)) (and \n                        (is-binary (nth bt 1))\n                        (is-binary (nth bt 2)))\n    :else false))", "problem": 95, "user": "4fe9d647e4b0547ebccb2472"}, {"code": "(fn tree? [v]\n  (or (nil? v)\n      (and (coll? v)\n           (= 3 (count v))\n           (tree? (second v))\n           (tree? (last v)))))", "problem": 95, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn bin [x] (and (= (count x) 3) (let [[_ l r] x test #(or (nil? %) (and (sequential? %) (bin %)))] (and (test l) (test r)))))", "problem": 95, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn tree? [t] \n  (or (nil? t) \n      (and (sequential? t) (= (count t) 3) (tree? (nth t 1)) (tree? (nth t 2)))))", "problem": 95, "user": "4fd7962ee4b0dab7d829f385"}, {"code": "(fn tree? [seq]\n  (if (= seq nil)\n     true\n     (if (= seq ())\n        false\n        (and (coll? seq)\n             (or (empty? seq)\n                 (and (= (count seq) 3)\n                      (tree? (second seq))\n                      (tree? (last seq))))))))", "problem": 95, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn btree?\n  [s]\n  (and (sequential? s)\n       (= (count s) 3)\n       (or (= (nth s 1) nil) (btree? (nth s 1)))\n       (or (= (nth s 2) nil) (btree? (nth s 2)))))", "problem": 95, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn btree? [r]\n  (cond\n    (nil? r) true\n    (sequential? r)\n      (and (= (count r) 3)\n           (btree? (nth r 1))\n           (btree? (nth r 2)))\n    :else false))", "problem": 95, "user": "4fde492be4b05e33b9224f8a"}, {"code": "(fn tree? [x]\n    (or (nil? x)\n      (and (coll? x)\n           (= (count x) 3)\n           (tree? (second x))\n           (tree? (last x)))))", "problem": 95, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn test [n]\r\n  (or\r\n   (= n nil)\r\n   (and\r\n    (coll? n)\r\n    (= 3 (count n))\r\n    (every? test (rest n)))))", "problem": 95, "user": "4f9336ece4b0dcca54ed6cb7"}, {"code": "(fn tree? [c]\r\n  (cond\r\n    (nil? c) true\r\n    (and (coll? c)\r\n         (= (count c) 3) \r\n         (tree? (second c))\r\n         (tree? (last c))) true\r\n    true false))", "problem": 95, "user": "4fb37882e4b081705acca2a0"}, {"code": "(fn bin-tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= (count node) 3)\n           (bin-tree? (nth node 1))\n           (bin-tree? (nth node 2)))))", "problem": 95, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn f [c] (or (nil? c) (and (coll? c) (= 3 (count c))\n (f (second c)) (f (last c)))))", "problem": 95, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn f [t]\n  (if (and (sequential? t) (= (count t) 3))\n       (and (f (nth t 1)) (f (nth t 2))) \n       (if (nil? t)\n           true\n           false)))", "problem": 95, "user": "4e5d1912535d8a8b8723a2c9"}, {"code": "(fn tree? [x]\n  (if (coll? x)\n    (if (= 3 (count x))\n      (and (tree? (second x)) (tree? (last x)))\n      false)\n    (nil? x)))", "problem": 95, "user": "4ff304f4e4b0678c553fc343"}, {"code": "apply\n(fn f\n  ([] false)\n  ([x] (nil? x))\n  ([x y] false)\n  ([x y z] (and (if (sequential? y) (apply f y) (f y)) \n                (if (sequential? z) (apply f z) (f z))))\n  ([x y z & l] false)\n)", "problem": 95, "user": "4ff5744ae4b0678c553fc36a"}, {"code": "(fn f [n]\r\n    (cond\r\n      (nil? n) true\r\n      (not (coll? n)) false\r\n      (= 3 (count n)) (and (f (nth n 1)) (f (nth n 2)))\r\n      f false)\r\n    )", "problem": 95, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn [tree]\n  (letfn [(tree? [tree] \n            (cond (nil? tree) true\n                  (not (coll? tree)) false\n                  (not (= (count tree) 3)) false\n                  :else (and (not (nil? (first tree))) \n                             (tree? (second tree)) \n                             (tree? (nth tree 2)))))]\n  (tree? tree)))", "problem": 95, "user": "4ff83003e4b0678c553fc396"}, {"code": "(fn bt [t]\n  (if (nil? t)\n    true\n    (and (coll? t) (= (count t) 3) (bt (second t)) (bt (nth t 2)))))", "problem": 95, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn bintree? [t] \n  (cond (nil? t) true \n        (false? t) false\n        (= (count t) 3) \n          (and\n            (bintree? (second t))\n            (bintree? (nth t 2)))\n        :else false))", "problem": 95, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "(fn tree? [tree]\n  (and (sequential? tree)\n       (= 3 (count tree))\n       (or (nil? (nth tree 1)) (tree? (nth tree 1)))\n       (or (nil? (nth tree 2)) (tree? (nth tree 2)))))", "problem": 95, "user": "4fe83efbe4b07c9f6fd12c3b"}, {"code": "(fn isnode? [c]\n  (or (nil? c)\n      (and (coll? c)\n           (= 3 (count c))\n           (every? isnode? (rest c)))))", "problem": 95, "user": "4db2cd84535df7e46ed9b6c6"}, {"code": "(fn tree? [t]\r\n  (if ( nil? t)\r\n      true\r\n      (if (coll? t)\r\n        (if ( empty? t)\r\n          false\r\n          (if (coll? (first t))\r\n            false\r\n            (if (not= (count t) 3)\r\n              false\r\n              (every? tree? (rest t))\r\n              )\r\n            )\r\n          ) \r\n        false\r\n        ))\r\n  )", "problem": 95, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn f [n]\r\n    (if (= (count n) 3)\r\n      ((every-pred \r\n        #(not (coll? (first %)))\r\n        #(or (nil? (second %))\r\n             (if (coll? (second %))\r\n               (f (second %))\r\n               false))\r\n        #(or (nil? (last %))\r\n             (if (coll? (last %))\r\n               (f (last %))\r\n               false))) n)\r\n      false))", "problem": 95, "user": "4ff9a200e4b0678c553fc3ab"}, {"code": "(fn binary-tree? [x]\n  (or \n    (nil? x)\n    (and\n      (coll? x)\n      (= 3 (count x))\n      (binary-tree? (second x))\n      (binary-tree? (nth x 2)))))", "problem": 95, "user": "5002b6e5e4b0678c553fc42c"}, {"code": "(fn f[[v l r :as all]] \n  (and \n   (= 3 (count all))\n   (if l (f l) (= nil l))\n   (if r (f r) (= nil r))))", "problem": 95, "user": "4db13ff51254ad5b4805fa68"}, {"code": "(fn tree? [t]\n  (cond\n    (nil? t) true\n    (not (coll? t)) false\n    :else (and (= (count t) 3) \n               (tree? (second t)) \n               (tree? (last t)))))", "problem": 95, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn tree? [s]\r\n  (let\r\n    [seq-has-3? #(and (sequential? %) (= 3 (count %)))\r\n     valueable? #(or (keyword? %) (number? %))]\r\n    (and (seq-has-3? s) \r\n         (let [[value left-child right-child] s]\r\n              (and (valueable? value)\r\n                   (or (nil? left-child) (tree? left-child))\r\n                   (or (nil? right-child) (tree? right-child)))))))", "problem": 95, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn tree?\r\n  [t]\r\n  (if (and (or (seq? t) (coll? t)) (= (count t) 3))\r\n    (let [[v l r] t]\r\n      (and (or (nil? l) (tree? l))\r\n           (or (nil? r) (tree? r))))\r\n    false))", "problem": 95, "user": "500159b3e4b0678c553fc419"}, {"code": "(fn [coll]\n  (let [branch? #(or (nil? %) (coll? %))]\n    (every? #(and (= 3 (count %)) (branch? (nth % 1)) (branch? (nth % 2)))\n      (filter coll? (tree-seq coll? identity coll)))))", "problem": 95, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn tree? [t]\n    (cond (nil? t) true\n          (coll? t) (and (= (count t) 3)\n                         ((complement coll?) (first t))\n                         (tree? (second t))\n                         (tree? (last t)))\n          :else false))", "problem": 95, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [ls] \n  (every? \n    #(and \n      (= (count %) 3)\n      (every? (fn [i] (or (nil? i) (coll? i))) (rest %)))\n    (filter coll? (tree-seq coll? identity ls))))", "problem": 95, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn t [[x l r :as a]]\n  (and (= (count a) 3)\n       (or (nil? l) (and (coll? l) (t l)))\n       (or (nil? r) (and (coll? r) (t r)))))", "problem": 95, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn is-tree? [x]\n  (or \n    (nil? x) \n    (and \n      (coll? x)\n      (= 3 (count x)) \n      (is-tree? (second x)) \n      (is-tree? (last x))\n    )\n  )\n)", "problem": 95, "user": "4ffb38e8e4b0678c553fc3c6"}, {"code": "(fn t [s] (or (nil? s) (and (coll? s) (= 3 (count s)) (t (second s)) (t (nth s 2)))))", "problem": 95, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn istree [t]\n  (if (nil? t) true\n      (and (not= false t)\n           (= (count t) 3)\n           (istree (nth t 1))\n           (istree (nth t 2)))))", "problem": 95, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn tree? [xs]\n  (if (nil? xs)\n    true\n    (and (coll? xs)\n         (= (count xs) 3)\n         (let [[k l r] xs]\n           (and (tree? l) (tree? r))))))", "problem": 95, "user": "500ff421e4b0ae202717946f"}, {"code": "(fn is-tree [s]\n  (letfn [(valid-node? [[v c1 c2 :as n]]\n                        (and v \n                             (= 3 (count n))\n                             (valid-child? c1)\n                             (valid-child? c2)))\n          (valid-child? [c]\n                         (if (and (sequential? c) (not (empty? c)))\n                           (valid-node? c)\n                           (nil? c)))]\n    (valid-node? s)))", "problem": 95, "user": "4feff3b6e4b0678c553fc31e"}, {"code": "(fn tree?- [coll]\r\n  ^{:doc \"Write a predicate which checks whether or not a given                                                                                         \r\n  sequence represents a binary tree.\"}\r\n  (if (nil? coll)\r\n    true\r\n    (and (coll? coll) (= 3 (count coll)) (tree?- (second coll)) (tree?- (nth coll 2)))))", "problem": 95, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn bincheck [sequence]                                                                                                                          \n    (loop [workqueue (cons sequence '())]                                                                                                          \n      (println \"Workqueue: \" workqueue)                                                                                                            \n      (if (empty? workqueue)                                                                                                                       \n        true                                                                                                                                       \n        (let [fnode (first workqueue)]                                                                                                             \n          (if (not (= (count fnode) 3))                                                                                                            \n            false                                                                                                                                  \n            (let [leftnode (nth fnode 1)                                                                                                           \n                  rightnode (nth fnode 2)]                                                                                                         \n              (if (or                                                                                                                              \n                   (not (or (nil? leftnode)                                                                                                        \n                            (sequential? leftnode)))                                                                                               \n                   (not (or (nil? rightnode)                                                                                                       \n                            (sequential? rightnode))))                                                                                             \n                false                                                                                                                              \n                (recur (concat (rest workqueue)                                                                                                    \n                               (filter #(not (nil? %))                                                                                             \n                                       (list leftnode rightnode)))))))))))", "problem": 95, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn binary-tree? [node]\n  (or (= nil node)\n      (and (coll? node) (= (count node) 3)\n        (binary-tree? (nth node 1))\n        (binary-tree? (nth node 2))\n        (not (coll? (first node))))))", "problem": 95, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn btree? [coll]\r\n  (if-let [[root left right] coll]\r\n    (if (= 3 (count coll))\r\n      (and (btree? left) (btree? right))\r\n      false)\r\n    (nil? coll)))", "problem": 95, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [a]\n  (every?\n    #(and\n      (= 3 (count %))\n      (or (coll? (nth % 1)) (nil? (nth % 1)))\n      (or (coll? (nth % 2)) (nil? (nth % 2))))\n    (filter coll? (tree-seq coll? rest a))))", "problem": 95, "user": "4fd2e5d8e4b04c3a95aa0427"}, {"code": "(fn [root]\n    (let [bintree (fn bintree [node]\n                    (if (and  (coll? node) (= 3 (count node)))\n                      (lazy-seq\n                       (cons true\n                             (mapcat bintree (rest node))))\n                      (list (nil? node))))]\n      (every? identity (bintree  root))))", "problem": 95, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn btree?\n  [tree]\n  (let [test (fn [x]\n               (and (= (count x) 3)\n                    (every? #(not= false %) x)))]\n    (and (test tree)\n         (every? true? (map btree? (filter #(or (vector? %) (seq? %)) tree))))))", "problem": 95, "user": "4fe89297e4b07c9f6fd12c4c"}, {"code": "#(if (even? (count (remove false? (flatten %)))) false true)", "problem": 95, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "(fn [tree]\n  (letfn [(is-tree [tree]\n                   (if (and tree (= 3 (count tree)))\n                     (let [[v l r] tree]\n                       (and \n                         (not (nil? v))\n                         (or (nil? l) (is-tree l))\n                         (or (nil? r) (is-tree r))\n                         )\n                       )\n                     )\n                   )]\n         (boolean (is-tree tree)))\n  )", "problem": 95, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn bin-tree? [x]\n  (cond\n    (nil? x) true\n    (not (coll? x)) false\n    (= 3 (count x)) (and (bin-tree? (second x))\n                         (bin-tree? (nth x 2)))\n    :else false))", "problem": 95, "user": "5012aefce4b0c8732600222a"}, {"code": "(fn isbinary? [tree]\n  (or (nil? tree)\n    (and (coll? tree)\n      (and (= (count tree) 3)\n        (and (isbinary? (second tree))\n          (isbinary? (last tree)))))))", "problem": 95, "user": "4fc50bcbe4b081705acca375"}, {"code": "(fn f [t]\n  (or (nil? t)\n    (and (coll? t) (= 3 (count t))\n      (every? f (next t)))))", "problem": 95, "user": "4dae0510c9a9d6ed4b99dc57"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= (count t) 3)\n           (tree? (second t))\n           (tree? (last t)))))", "problem": 95, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn test [aSeq]\r\n  (or (nil? aSeq)\r\n      (and (coll? aSeq)\r\n           (= 3 (count aSeq))\r\n           (every? test (rest aSeq)))))", "problem": 95, "user": "4ffe4d43e4b0678c553fc3f1"}, {"code": "(fn f [x]\n  (or\n    (= x nil)\n    (and\n      (sequential? x)\n      (= 3 (count x))\n      (f (get (vec x) 1))\n      (f (get (vec x) 2))\n    )\n  )\n)", "problem": 95, "user": "5017f840e4b02f523d7cc5e8"}, {"code": "(fn __ [node]\n  (if (and node (= 3 (count node)))\n    (let [[v r l] node]\n      (if v (and (__ r) (__ l))))\n        (= node nil)))", "problem": 95, "user": "4ec9549d535d6d7199dd36fe"}, {"code": "(fn ? [s]\n  (if-let [[_ l r] s]\n    (apply #(and %1 %2 %3) (= 3 (count s))\n         (map #(or (nil? %) (? %)) [l r]))\n    false))", "problem": 95, "user": "50166470e4b052339a490e76"}, {"code": "(fn tree? [t]\n  (and\n    (coll? t)\n    (= 3 (count t))\n    (let [[_ l r] t]\n      (every? #(or (nil? %) (tree? %)) [l r]))))", "problem": 95, "user": "4fe4c09ee4b0e8f79898febb"}, {"code": "(fn b [m]\n  (cond\n   (false? m) false\n   (not (coll? m)) true\n   (not= (count m) 3) false\n   :else (and (b (second m)) (b (nth m 2)))))", "problem": 95, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn r [x]\n  (or (= x nil)\n      (and (coll? x)\n     (= (count x) 3)\n\t   (every? r (rest x)))))", "problem": 95, "user": "50052fd0e4b0678c553fc45d"}, {"code": "(fn [s] (odd? (count (filter #(not (= (class %) Boolean))(flatten s)))))", "problem": 95, "user": "4fb2f9b2e4b081705acca294"}, {"code": "(fn b? [tree]\r\n  (and (= (count tree) 3)\r\n       (if (sequential? (second tree)) \r\n         (b? (second tree))\r\n         (nil? (second tree)))\r\n       (if (sequential? (nth tree 2))\r\n         (b? (nth tree 2))\r\n         (nil? (nth tree 2)))))", "problem": 95, "user": "4fd8544be4b0dab7d829f390"}, {"code": "(fn is_tree [ dt ] \n  (and \n    (sequential? dt)\n    ((complement sequential?) (first dt))\n    (= 3 (count dt))\n    (every? #(or (nil? %) (is_tree %)) (rest dt) )\n))", "problem": 95, "user": "5018ed15e4b011a2e0bf6412"}, {"code": "#(odd? (count (remove false? (flatten %))))", "problem": 95, "user": "4e1fe7f1535d04ed9115e810"}, {"code": ";To properly fullfill the specs:\n;(fn e [t] (if (coll? t) (and (= 3 (count t)) (every? e (rest t))) true))\n;Patched for IMHO broken test case #6\n(fn e [t] (if (coll? t) (and (= 3 (count t)) (every? e (rest t))) (not (false? t))))", "problem": 95, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn btree? [coll]\n  (if-let [[_ y z] coll]\n    (if (= 3 (count coll))\n      (and (btree? y) (btree? z))\n      false)\n    (nil? coll)))", "problem": 95, "user": "4fcf642ee4b03432b189f410"}, {"code": "(fn t [treelist]\n  (if (= treelist nil)\n    true\n    (if (and (coll? treelist) (= (count treelist) 3)) \n       (and (not (= nil (first treelist)))\n            (t (second treelist))\n            (t (nth treelist 2)))\n       false)\n  )\n)", "problem": 95, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn tree?[s]\n  (and (or (vector? s) (seq? s))\n    (= (count s) 3)\n    (every? #(or (nil? %)\n                 (tree? %)) (rest s))))", "problem": 95, "user": "4ed8b598535d10e5ff6f52fc"}, {"code": "(fn __ [tree]\n  (odd? (count (filter #(not= false %) (flatten tree)))))", "problem": 95, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn tree? [t]\n  (if (= 3 (count (vec t)))\n    (let [[a b c] t]\n      (and a\n           (and (not (false? b)) (or (nil? b) (tree? b)))\n           (and (not (false? c)) (or (nil? c) (tree? c)))\n           ))\n    false))", "problem": 95, "user": "4f3e5e87e4b0e243712b1f83"}, {"code": "(fn [tree]\n  (every? #(if (sequential? %)\n             (= 3 (count %))\n             (nil? %))\n      (tree-seq sequential? rest tree)))", "problem": 95, "user": "4fe88f78e4b07c9f6fd12c45"}, {"code": "(fn test-tree [x]\n  (if (nil? x)\n    true\n    (and (coll? x)\n      (= 3 (count x))\n      (test-tree (nth x 1))\n      (test-tree (nth x 2)))))", "problem": 95, "user": "5027f37be4b01614d1633ff1"}, {"code": "#(\r\n  if (some false? (flatten %)) \r\n  false\r\n\t(if (odd? (count (flatten %)) ) true false)\r\n\t)", "problem": 95, "user": "4f4bd422e4b03ad3f0c10c7e"}, {"code": "(fn isTree [coll]\n  (if (not (coll? coll)) \n    (nil? coll)\n    (let [[v l r & rst] coll]\n       (and (not (nil? v))\n            (= 3 (count coll))\n            (nil? rst)\n            (isTree l)\n            (isTree r))\n    )))", "problem": 95, "user": "502a5fa4e4b09e8f859a9fbd"}, {"code": "(fn isTree [tree]\n  (or\n    (nil? tree)\n    (and \n      (coll? tree)\n      (= 3 (count tree))\n      (isTree (nth tree 1))\n      (isTree (nth tree 2)) )))", "problem": 95, "user": "4eaf08ce535d7eef3080732d"}, {"code": "; I don't know why the second last one is false...\n; but, just make the test pass..\n(fn is-bin-tree? [tree]\n  (if (not= 3 (count tree))\n\t\t\tfalse\n\t\t\t(let [val (first tree)\n\t\t\t\t\t\tleft (second tree)\n\t\t\t\t\t\tright (nth tree 2)]\n\t\t\t\t(and \n\t\t\t\t\t(not (coll? val))\n\t\t\t\t\t(if (coll? left) (is-bin-tree? left) (and (not (coll? left)) (not (false? left))))\n\t\t\t\t\t(if (coll? right) (is-bin-tree? right) (not (coll? right)))))))", "problem": 95, "user": "501c1492e4b086d93747d180"}, {"code": "(fn isTree [x]\n  (if (and\n       (coll? x)\n\t     (= (count x) 3)\n\t     (or (nil? (nth x 1)) (isTree (nth x 1)))\n\t     (or (nil? (nth x 2)) (isTree (nth x 2))))\n\t    true\n\t    false))", "problem": 95, "user": "4fd9d162e4b05e33b9224f3c"}, {"code": "(fn [input]\r\n  (letfn [(check-it [xs]\r\n              (let [[e1 e2 e3] xs size (count xs)]\r\n                (and (= size 3) (if (coll? e2) (check-it e2) (nil? e2)) (if (coll? e3) (check-it e3) (nil? e3)))\r\n                 )\r\n               )]\r\n   (check-it input)   \r\n  )\r\n)", "problem": 95, "user": "4faa6184e4b081705acca1f1"}, {"code": "(fn bin-tree? [s]\n  (cond\n    (nil? s) true\n    (not (coll? s)) false\n    (not= 3 (count s)) false\n    :else (let [[v l r] s]\n            (cond\n              (coll? v) false\n              (and (bin-tree? l)\n                    (bin-tree? r)) true\n              :else false))))", "problem": 95, "user": "4f1abbfb535d64f60314646e"}, {"code": "(fn foo [tree]\n  (or (nil? tree) (and (instance? Iterable tree) (= (count tree) 3) (foo (nth tree 1)) (foo (nth tree 2)))))", "problem": 95, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn ! [t] (or (nil? t)\n      (and (and (coll? t) (= (count t) 3))\n           (and (! (first (rest t)))\n                (! (last t))))))", "problem": 95, "user": "5032b398e4b00c0952a257eb"}, {"code": "(fn f [t] (and \n(sequential? t)\n(= 3 (count t))\n(let [[v l r] t]\n  (and v (or (f l) (nil? l)) (or (f r) (nil? r))))\n))", "problem": 95, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn t[s] (cond\r\n    (nil? s) true\r\n    (not (sequential? s)) false\r\n    :else (let [v (first s) l (fnext s) r (last s)]\r\n      (and (= 3 (count s))\r\n        (not (sequential? v))\r\n        (t l) (t r)))))", "problem": 95, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn is-node? [x]\n  (if (nil? x)\n     true\n     (and \n      (coll? x)\n      (= (count x) 3)\n      (not (nil? (first x))) ; not necessary to pass tests\n      (is-node? (second x))\n      (is-node? (nth x 2))\n      )))", "problem": 95, "user": "4f08a8a2535dcb61093f6c3d"}, {"code": "(fn [ t ]\n  (every?\n   #(if (coll? %1)\n        (= (count %1) 3)\n        (= %1 nil))    \n   (tree-seq coll? rest t)))", "problem": 95, "user": "502952c9e4b0b33e9bf6fdf1"}, {"code": "(fn tree? [ls]\n  \n  (cond (nil? ls) true\n        (not (sequential? ls)) false\n        (not= 3 (count ls)) false\n        :else (and (tree? (second ls))\n             (tree? (nth ls 2)))))", "problem": 95, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn node?\n  [node]\n  (or (nil? node)\n      (and\n        (coll? node)\n        (= 3 (count node))\n        (-> node first nil? not)\n        (-> node second node?)\n        (-> node last node?))))", "problem": 95, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn tree [arg]\n  (if (sequential? arg)\n    (let [[root left right] arg]\n      (and (= (count arg) 3) (tree left) (tree right)))\n    (nil? arg)))", "problem": 95, "user": "4f625f68e4b0defedf855fd2"}, {"code": "(fn tree [arg]\n  (if (sequential? arg)\n    (let [[root left right] arg]\n      (and (= (count arg) 3) (tree left) (tree right)))\n    (nil? arg)))", "problem": 95, "user": "4e944706535dbda64a6f6b11"}, {"code": "(fn is-binary? [tree]\n    (if (sequential? tree)\n        (let [[v a b] tree]\n          (and (= 3 (count tree))\n               (not (sequential? v))\n               (is-binary? a)\n               (is-binary? b)))\n        (or tree (nil? tree))))", "problem": 95, "user": "503ac764e4b07a1917cc34d8"}, {"code": "(fn [root-node]\n   (letfn [(node? [node]\n             (if (not (and (sequential? node)\n                           (= 3 (count node))))\n               false\n               (let [child? (fn [val]\n                              (or (nil? val)\n                                  (node? val)))\n                     left (second node)\n                     right (last node)]\n                 (and (child? left)\n                      (child? right)))))]\n     (node? root-node)))", "problem": 95, "user": "5014754de4b094324338f8e5"}, {"code": "(fn f [t]\n  (cond \n    (nil? t) true\n    (not (coll? t)) false\n    (not= 3 (count t)) false\n    :else (let [[x y z] t] \n      (and (f y) (f z)))))", "problem": 95, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn tree? [node]\n          (let [third #(first (rest (rest %)))]\n            (if (nil? node)\n              true\n              (if (and (coll? node) (= (count node) 3))\n                (and (tree? (second node)) (tree? (third node)))\n                false))))", "problem": 95, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "problem": 95, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn tree [a]\n   (cond (nil? a) true\n         (and (coll? a)\n              (= 3 (count a))\n              (tree (nth a 1)) \n              (tree (nth a 2))) true\n         :else false))", "problem": 95, "user": "5012ec0ae4b0c87326002230"}, {"code": "(fn binary-tree? [t]\n  (cond\n   (nil? t) true\n   (not\n    (or\n     (and (sequential? t) (= (count t) 3))\n     (nil? t))) false\n     :else (and (binary-tree? (nth t 1)) (binary-tree? (nth t 2)))))", "problem": 95, "user": "4fc6d2c1e4b0ee37620e181b"}, {"code": "(fn tree? [s]\n  (and (sequential? s)\n       (= 3 (count s))\n       (or (nil? (nth s 1))\n           (tree? (nth s 1)))\n       (or (nil? (nth s 2))\n           (tree? (nth s 2)))))", "problem": 95, "user": "50435852e4b034ff00315d22"}, {"code": "(fn isbtree [n]\n  (cond\n    (nil? n) true\n    (not (or (list? n) (vector? n))) false\n    (not= 3 (count n)) false\n    :else (let [[v l r] n]\n      (and (isbtree l) (isbtree r)))))", "problem": 95, "user": "503a234de4b088a6a14ca76d"}, {"code": "(partial (fn istree [ishead tree]\n  (if (not (coll? tree)) \n    (if (and (not ishead) (not= tree nil)) false true)\n    (let [[value left right] tree]\n      (if (not= (count tree) 3) false\n        (and (istree true value) (istree false left) (istree false right))))))\n  true)", "problem": 95, "user": "4fb266a5e4b081705acca28c"}, {"code": "(fn ! [t]\r\n  (and\r\n    (sequential? t)\r\n    (= 3 (count t))\r\n    (let [[val left right] t]\r\n      (and\r\n        (not (sequential? val))\r\n        (not (nil? val))\r\n        (or (nil? left) (! left))\r\n        (or (nil? right) (! right))))))", "problem": 95, "user": "4dc97aec535d5973398f9284"}, {"code": "(fn [tree]\n  (->> tree\n    (tree-seq sequential? identity)\n    (every? #(or (not (sequential? %))\n                 (let [[x l r] %]\n                   (and (== 3 (count %))\n                        (or (nil? l) (sequential? l))\n                        (or (nil? r) (sequential? r))))))))", "problem": 95, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn f\n  ([xs]\n    (and\n      (sequential? xs)\n      (= (count xs) 3) \n      (let [[a l r] xs]\n      (and \n      (or\n        (nil? l)\n        (and\n        (sequential? l)\n        (f l)))\n      (or\n        (nil? r)\n        (and\n        (sequential? r)\n        (f r))))))))", "problem": 95, "user": "50427899e4b0add3005c0fc2"}, {"code": "(fn f [x] \n   (if (not (coll? x))\n     (nil? x)\n     (let [ [v l r] x ]\n       (and (= 3 (count x)) v (f l) (f r)))))", "problem": 95, "user": "5046b003e4b011c5dfee7727"}, {"code": "(fn bin-tree?[t]\n   (cond\n    (nil? t) true\n    (or (not (coll? t))(not= (count t) 3)) false\n    :else (and (not= nil (nth t 0))  \n               (bin-tree? (nth t 1)) \n               (bin-tree? (nth t 2))))\n)", "problem": 95, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn tr [x] \n  (if (coll? x)\n    (and (= 3 (count x)) (not (empty? x))(not (coll? (first x))) (tr (second x)) (tr (last x)))\n    (nil? x)))", "problem": 95, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn tree? [args]\n  (and (coll? args)\n       (= (count args) 3)\n       (or (nil? (second args)) (tree? (second args)))\n       (or (nil? (nth args 2)) (tree? (nth args 2)))))", "problem": 95, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn tree? [x]\r\n  (and (coll? x)\r\n    (= (count x) 3)\r\n    (every? #(or (nil? %) (tree? %)) (rest x))))", "problem": 95, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn bt? [n]\n  (and\n    (sequential? n)\n    (= 3 (count n))\n    (let [[v l r] n]\n      (and\n        (or (nil? l) (bt? l))\n        (or (nil? r) (bt? r))))))", "problem": 95, "user": "504f2071e4b0e7ad84dbc4be"}, {"code": "(fn f [s]\n    (cond (-> s coll? not) true\n          (not= (count s) 3) false\n          (some coll? s) (every? true? (map f s))\n          :else (every? #(or (coll? %) (nil? %)) (drop 1 s))))", "problem": 95, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn tree? [t] \n  (cond\n    (nil? t) true\n    (and (coll? t) (= 3 (count t)))\n        (and (tree? (nth t 1)) (tree? (nth t 2)))\n    :else false))", "problem": 95, "user": "504e397ee4b0f6ff3350c485"}, {"code": "(fn tree? [t]\n  (cond (not (coll? t)) (nil? t)\n        (let [[x y & w] t] (empty? w)) false \n        (let [[x y z & w] t] (not (empty? w))) false\n        :else\n        (let [[x y z] t] \n        (reduce #(and %1 %2) (map tree? (vector y z))))))", "problem": 95, "user": "4fc5a693e4b0ee37620e17fc"}, {"code": "(fn is-b-tree?[s] \r\n(and\r\n(not (false? s))\r\n(or\r\n  (not (coll? s))\r\n\t(and \r\n\t\t(= 3 (count s)) \r\n\t\t(is-b-tree? (nth s 1)) \r\n\t\t(is-b-tree? (nth s 2)) \t\r\n\t)\r\n)\r\n)\r\n)", "problem": 95, "user": "4ffd92e7e4b0678c553fc3e3"}, {"code": "(fn tree? [s]\r\n  (if (not (sequential? s)) ((comp not false?) s)\r\n    (if (not= 3 (count s)) false\r\n      (and (tree? (second s)) (tree? (nth s 2))))))", "problem": 95, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn f [node]\n    (or\n      (nil? node)\n      (and\n        (coll? node)\n        (= 3 (count node))\n        (every? f (rest node)))))", "problem": 95, "user": "4ee77f15535d93acb0a66868"}, {"code": "(fn binary?\n  [node]\n  (if (not= 3 (count node))\n    false\n    (let [[p l r] node\n          check-child (fn [el] (if\n                                 (coll? el)\n                                 (binary? el)\n                                 (nil? el)))]\n      (and\n        (check-child l)\n        (check-child r)))))", "problem": 95, "user": "4edfb618535d10e5ff6f5343"}, {"code": "(fn btree? [t]\n  (or (nil? t)\n      (and\n        (coll? t)\n        (= 3 (count t))\n        (btree? (second t))\n        (btree? (nth t 2)))))", "problem": 95, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn [col] \n  (let [check (fn f [col]\n                (if (coll? col)\n                    (if (= 3 (count col))\n                        (and (f (second col)) (f (second (rest col))))\n                        false)\n                    (if (and (not (nil? col)) (false? col))\n                        false\n                        true)))]\n   (if (check col)\n       (and (check (second col)) (check (second (rest col))))\n        false)))", "problem": 95, "user": "50435689e4b034ff00315d21"}, {"code": "(fn f [t] (or (nil? t)(and (coll? t)(= (count t) 3)(apply = (map f (rest t))))))", "problem": 95, "user": "5055899de4b0ce54f56f03fd"}, {"code": "(fn binary-tree? [[v l r :as t]]\n   (cond (not= (count t) 3) false\n         (and (nil? l) (nil? r)) true\n          (sequential? l) (binary-tree? l)\n          (sequential? r) (binary-tree? r)\n          :else\n          false\n          ))", "problem": 95, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "(letfn [\n  (binary-tree? [t]\n    (and (= (count t) 3)\n            (every? node? (rest t))))\n  (node? [x]\n    (or (nil? x)\n        (and (coll? x)\n             (binary-tree? x))))]  \n binary-tree?)", "problem": 95, "user": "5041b3c0e4b06d8231e4facf"}, {"code": "(fn f [tree] \n  (if (nil? tree)\n    true\n    (and (coll? tree) (= (count tree) 3)\n         (let [[_ l r & more] tree]\n           (and (f l) (f r))))))", "problem": 95, "user": "4fb01e53e4b081705acca260"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n\t\t(and\n\t\t\t(coll? t)\n\t\t\t(= 3 (count t))\n\t\t\t(tree? (nth t 1))\n\t\t\t(tree? (nth t 2)))))", "problem": 95, "user": "4ea0c284535d7eef308072ad"}, {"code": "(fn f [[v l r :as s]]\n    (if (= (count s) 3)\n      (every? #(cond\n                 (nil? %) true\n                 (sequential? %) (f %)\n                 :else false)\n              [l r])\n      false))", "problem": 95, "user": "4df669d4535d08e6dec9fe35"}, {"code": "(fn tree? [tr]\n  (or (nil? tr)\n(and\n  (coll? tr)\n  (= (count tr) 3)\n  (tree? (nth tr 1))\n(tree? (nth tr 2)))))", "problem": 95, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn bt\r\n  [v]\r\n  (and (= 3 (count v))\r\n    (let [[a b c] v]\r\n      (and (if (coll? b) (bt b) (not= false b))\r\n           (if (coll? c) (bt c) (not= false b))))))", "problem": 95, "user": "5050b107e4b063148f524126"}, {"code": "(fn binary-tree? [tree]\n  (->> (tree-seq coll? rest tree)\n       (every? #(or (nil? %)\n                    (and (coll? %) (= (count %) 3))))))", "problem": 95, "user": "50586354e4b06522596eba78"}, {"code": "(fn binary-tree? [x]\n  (if (false? x) false\n  (if \n    (or \n      (not (sequential? x))\n      (and\n        (= (count x) 3)\n        (binary-tree? (second x))\n        (binary-tree? (last x))))\n    true false)))", "problem": 95, "user": "5054c853e4b0b1b9d1860eb3"}, {"code": "(fn is-tree\n  [n]\n  (if (and (coll? n) (= (count n) 3))\n    (let [[v l r] n]\n      (and (if (nil? l) true (is-tree l))\n           (if (nil? r) true (is-tree r))))\n    false))", "problem": 95, "user": "4ee528fb535d1385b2869d87"}, {"code": "(fn binary-tree? [args]\r\n  (println args)\r\n  (if (nil? args)\r\n    (do (println \"d0 t\") true)\r\n    (if (and (coll? args) (= 3 (count args)))\r\n      (let [val (first args)\r\n      left (second args)\r\n\t    right (nth args 2)]\r\n\t(println \"derp \" val (nil? left) (nil? right))\r\n\t(if (and\r\n\t     (or (nil? left) (binary-tree? left))\r\n\t     (or (nil? right) (binary-tree? right)))\r\n\t  (do (println \"d1 t\") true)\r\n\t  (do (println \"d1 f\") false)))\r\n      (do (println \"d2 f\") false))))", "problem": 95, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn btree? [c]\n  (if (coll? c)\n    (and (= 3 (count c)) (btree? (nth c 1)) (btree? (nth c 2)))\n    (nil? c)))", "problem": 95, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn b? [b]\n  (or\n    (nil? b)\n    (and (coll? b)\n         (= 3 (count b))\n         (first b)\n         (b? (second b))\n         (b? (second (rest b))))))", "problem": 95, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn node? [node] (and (coll?  node) (= 3 (count node)) \r\n                             (not (coll? (nth node 0)  )  ) \r\n                             (or (nil?  (nth node 1)) (node? (nth node 1)))\r\n                             (or (nil? (nth node 2)) (node? (nth node 2)))\r\n                              true ) )", "problem": 95, "user": "50463347e4b011c5dfee771e"}, {"code": "(fn t [a] (if (nil? a) true (and (coll? a) (= 3 (count a)) (t (nth a 1)) (t (nth a 2)))))", "problem": 95, "user": "4f045946535dcb61093f6bba"}, {"code": "(fn tree? [t] \n  (or (nil? t)\n    (and\n      (sequential? t)\n      (= 3 (count t))\n      (tree? (nth t 1))\n      (tree? (nth t 2))\n)\n))", "problem": 95, "user": "502bb7c0e4b0194ad32ea1a3"}, {"code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "4ed98b40535d10e5ff6f5307"}, {"code": "(fn tree? [t]\n  (if-not (sequential? t) false\n    (if-not (= (count t) 3) false\n      (let [l (nth t 1) r (nth t 2)]\n        (cond (and (nil? l) (nil? r)) true\n              (nil? l) (recur r)\n              (nil? r) (recur l)\n              :else (and (tree? l) (tree? r)))))))", "problem": 95, "user": "5063b9a0e4b075d771da6f9d"}, {"code": "(fn tree? [x] (or (nil? x) (and (coll? x) (= 3 (count x)) (and (tree? (nth x 1)) (tree? (nth x 2)) ) )))", "problem": 95, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn is-tree? [s]\n  (if (coll? s)\n      (and (= 3 (count s))\n           (reduce #(and % %2) (map #(is-tree? %) s)))\n      (not= false s)))", "problem": 95, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn a [tree]\n    (if (or (not (coll? tree))\n            (not= (count tree) 3))\n      false\n      (and\n       (or (nil? (nth tree 1))\n           (a (nth tree 1)))\n       (or (nil? (nth tree 2))\n           (a (nth tree 2))))))", "problem": 95, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn is-binary-tree [node]\n  (if (nil? node)\n    true\n    (and\n      (coll? node)\n      (= (count node) 3) \n      (is-binary-tree (nth node 1)) \n      (is-binary-tree (nth node 2)))))", "problem": 95, "user": "5060d137e4b0dc10a69545a0"}, {"code": "(fn istree [tree]\n  (if (and (sequential? tree)\n             (= (count tree) 3))\n    (let [[n l r] tree]\n      (and (not (nil? n))\n           (or (nil? l) (istree l))\n           (or (nil? r) (istree r))))\n    false))", "problem": 95, "user": "4e47f4f3535dc968683fc4bb"}, {"code": "(fn tree?\n  [s]\n  (if (= (count s) 3)\n    (reduce      \n      (fn [r e]        \n        (and \n          r \n          (if-not (sequential? e)\n            (not= e false)\n            (tree? e))))\n      true\n      s)     \n    false))", "problem": 95, "user": "4fee04a0e4b0678c553fc308"}, {"code": "#(every? \n  (partial = 3)\n  (map (fn [x] (cond (coll? x) (count x) :else 0))\n  (remove nil? (tree-seq coll? rest %))))", "problem": 95, "user": "504e3aaae4b0f6ff3350c487"}, {"code": "(fn isTree? [coll]\n  (or (nil? coll) (and (= (count coll) 3)\n                          (or (nil? (second coll))\n                              (coll? (second coll)))\n                          (or (nil? (last coll))\n                              (coll? (last coll)))\n                          (isTree? (second coll))\n                          (isTree? (last coll)))))", "problem": 95, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn tree? [t]\n          (cond (nil? t) true\n                (coll? t) (and (= (count t) 3)\n                               ((complement coll?) (first t))\n                               (tree? (second t))\n                               (tree? (last t)))\n                :else false))", "problem": 95, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn t [x]\n  (or \n    (nil? x)\n    (and (coll? x) (= 3 (count x)) (t (nth x 1)) (t (nth x 2)))\n  ))", "problem": 95, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn tree? [coll]\n \n  (or (nil? coll)\n    (and (coll? coll)\n        (= 3 (count coll))\n         (tree? (nth coll 1))\n         (tree? (nth coll 2)))))", "problem": 95, "user": "506f1e12e4b09350ab4199f9"}, {"code": "(fn is-tree? [x]\n   (letfn [(check-branch [y]\n     (cond (coll? y) (is-tree? y) \n      (nil? y) true\n      :else false)  \n     )]\n   (cond (not (= 3 (count x))) false\n         :else (and \n                (check-branch (second x))\n                (check-branch (nth x 2))\n               )    \n   )\n   )\n)", "problem": 95, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn tree? [x]\n  (or\n    (nil? x)\n    (and\n      (coll? x)\n      (= 3 (count x))\n      (tree? (nth x 1))\n      (tree? (nth x 2)))))", "problem": 95, "user": "50657775e4b0deb876850599"}, {"code": "(fn tree? [x]\n  (cond\n    (nil? x) true\n    (not (coll? x)) false\n    (not= (count x) 3) false\n    :else (and (tree? (second x))\n         (tree? (second (next x)))\n          (not (coll? (first x)))\n    )\n  )\n)", "problem": 95, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn tr [coll]\n  (cond\n    (nil? coll) true\n    (not (or (seq? coll) (list? coll) (vector? coll))) false \n    (not (= (count coll) 3)) false\n    (nil? (first coll)) false\n    (and (tr (second coll)) (tr (nth coll 2))) true\n    :else false))", "problem": 95, "user": "506b8242e4b0eda3100c090a"}, {"code": "(fn f [s]\n  (or (nil? s)\n      (and (coll? s)\n           (= (count s) 3)\n           (f (second s))\n           (f (last s)))))", "problem": 95, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn f [n]\n  (cond\n    (nil? n) true\n    (and (coll? n) (= 3 (count n))) (and \n        (f (second n)) \n        (f (nth n 2)))\n    :else false))", "problem": 95, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn isBinaryTree [t]\n  (if (not (coll? t)) \n     (if (nil? t) true false)\n \t   (if (= (count t) 3) (and (isBinaryTree (nth t 1)) (isBinaryTree (nth t 2)))\n\t     false)))", "problem": 95, "user": "4f2f6678e4b0d6649770a06e"}, {"code": "(fn bintree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= (count t) 3)\n           (bintree? (nth t 1))\n           (bintree? (nth t 2)))))", "problem": 95, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn hoge [l]\r\n  (or (nil? l) (and (coll? l) (= (count l) 3) (hoge (nth l 1)) (hoge (nth l 2)))))", "problem": 95, "user": "507437c2e4b054001656acd0"}, {"code": "(fn f [t]\n  (if (coll? t)\n      (and (= 3 (count t))(every? f (next t)))\n      (nil? t)))", "problem": 95, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn t? [c]\n  (or (nil? c)\n      (and (coll? c)\n           (= (count c) 3)\n           (first c)\n           (every? t? (rest c)))\n      false))", "problem": 95, "user": "4db2f208535df7e46ed9b6c9"}, {"code": "(fn binary-tree? [tree]\n  (let [[val left right] tree]\n    (and (= (count tree) 3)\n         (or (nil? left) (and (coll? left) (binary-tree? left)))\n         (or (nil? right) (and (coll? right) (binary-tree? right))))))", "problem": 95, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn tree? [s]\n  (or (nil? s)\n      (and (coll? s)\n           (= 3 (count s))\n           (every? true? (map tree? (rest s))))))", "problem": 95, "user": "506a1985e4b01dc6af13f83e"}, {"code": "#(let [f (fn  f [s]      \n      (if (sequential? s)\n        (if (= 3 (count (remove false? s)))\n          (and (nil? (f (nth s 1))) (f (nth s 2)))\n          false)))]\n(nil? (f %)))", "problem": 95, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn tree? [x] (if (= nil x)\n            true\n            (and \n                 (coll? x) \n                 (= (count x) 3) \n                 (tree? (nth x 1))\n                 (tree? (nth x 2)))))", "problem": 95, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "(fn __ [L]\n  (and\n   (or\n    (nil? L)\n    (and (sequential? L) (= 3 (count L))))\n   (every? __ (rest L)))\n)", "problem": 95, "user": "50293245e4b08353e5d459cf"}, {"code": "(fn ? [x] (and\n  (coll? x)\n  (= (count x) 3)\n  (if (nil? (nth x 1)) true (? (nth x 1)))\n  (if (nil? (nth x 2)) true (? (nth x 2)))\n  true))", "problem": 95, "user": "505d4b21e4b0e6aca564be07"}, {"code": "(fn is-tree\n  [root]\n    (and\n      (= 3 (count root))\n      (or\n        (nil? (nth root 1))\n        (and\n          (coll? (nth root 1))\n          (is-tree (nth root 1))))\n      (or\n        (nil? (nth root 2))\n        (and\n          (coll? (nth root 2))\n          (is-tree (nth root 2))))))", "problem": 95, "user": "507a08e4e4b08327cd804a67"}, {"code": "(fn tree [val] \r\n  (cond \r\n   (nil? val) true\r\n   (false? val) false\r\n   (and (not (nil? (nth val 0 nil)))\r\n    (tree (nth val 1 false))\r\n    (tree (nth val 2 false))\r\n    (nil? (nth val 3 nil))\r\n   ) true \r\n   :else false\r\n  )\r\n )", "problem": 95, "user": "50807940e4b01a93d3f38e44"}, {"code": "(fn is-tree [t]\n  (if (sequential? t)\n    (and (= 3 (count t))\n         (let [[a b c] t]\n           (and (not (or (seq? a) (vector? a)))\n                (is-tree b)\n                (is-tree c))))\n    (nil? t)))", "problem": 95, "user": "504db141e4b021508a333965"}, {"code": "(fn is-tree [val]\n  (cond\n    (coll? val) (and (= (count val) 3) (every? is-tree val))\n    (= val false) false\n    :else true))", "problem": 95, "user": "505bd09fe4b032b709c81373"}, {"code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (if-not (coll? t)\n      false\n      (if-not (= 3 (count t))\n        false\n        (and (tree? (second t)) (tree? (last t)))\n      )\n    )\n  )\n)", "problem": 95, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn bt? [s]\r\n  (or\r\n    (nil? s)\r\n    (and\r\n      (coll? s)\r\n      (= 3 (count s))\r\n      (bt? (nth s 1))\r\n      (bt? (nth s 2)))))", "problem": 95, "user": "4faf2f4ce4b081705acca251"}, {"code": "(fn z [t]\n        (let [[_ l r] t\n              f #(if (sequential? %) (z %) (nil? %))]\n          (and (= 3 (count t))\n               (f l)\n               (f r))))", "problem": 95, "user": "4dc78527535d8a4b2fd7428f"}, {"code": "(fn f [n]\n  (or (nil? n)\n      (and (coll? n) (= (count n) 3) (f (nth n 1)) (f (nth n 2)))))", "problem": 95, "user": "5088082ae4b0198722bd9854"}, {"code": "(fn t? [[v l r :as t]]\n  (and\n    (= (count t) 3)\n    (every?\n      #(or (nil? %)\n         (and (coll? %) (t? %)))\n      [l r])))", "problem": 95, "user": "504c8165e4b09724c857af31"}, {"code": "(fn tree? [x] (if (sequential? x)\n                 (and (= (count x) 3)\n                      (tree? (nth x 1))\n                      (tree? (nth x 2)))\n                 (nil? x))\n   )", "problem": 95, "user": "5084cb7de4b0fb8f40674bfb"}, {"code": "; The problem statement does not explain that trees may be nil. \n; And a better way would be to allow value only nodes. \n(fn bin-tree? [t]\n  (or (nil? t) (and (coll? t) (= (count t) 3) (bin-tree? (second t)) (bin-tree? (nth t 2)))))", "problem": 95, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn pred [s] (if (= (count s) 3)\n  (reduce #(and %1 (if (sequential? %2) (pred %2) (nil? %2))) true (rest s)) false))", "problem": 95, "user": "505dcfc8e4b0e6aca564be0d"}, {"code": "(fn btree [ t ]\n  (or\n    (nil? t)\n    (and \n      (sequential? t)\n      (let [ [v l r] t]\n        (and \n          (== 3 (count (take 4 t))) \n          (btree l) \n          (btree r))))))", "problem": 95, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn f [pt]\r\n (and\r\n  (coll? pt)\r\n  (= 3 (count pt))\r\n  (or (nil? (nth pt 1)) (f (nth pt 1)))\r\n  (or (nil? (nth pt 2)) (f (nth pt 2)))))", "problem": 95, "user": "506fd0afe4b07bd6ad9b9f23"}, {"code": "(fn t[x]\n  (or (nil? x)\n    (and (sequential? x) \n  (= 3 (count x)) (every? t (next x))\n   )))", "problem": 95, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn tree? [node]\n  (and (coll? node) (= (count node) 3)\n       (let [[_ l r] node]\n         (and (or (nil? l) (tree? l))\n              (or (nil? r) (tree? r))))))", "problem": 95, "user": "4e5f034b535d8a8b8723a2d9"}, {"code": "(fn tree? [s] \n  (if (not= 3 (count s)) \n      false\n      (if (and (= nil (last s)) (= nil (second s))) true\n      (if (some #(and (not (coll? %)) (not= % nil)) \n          (rest s)) false \n                      (if(coll? (second s)) (tree? (second s))\n                      (when (coll? (last s)) (tree? (last s))))))))", "problem": 95, "user": "5062bc46e4b05ac47bc68d68"}, {"code": "(fn f[s]\r\n  (if (coll? s) (if (=(count s) 3) (and (f (first(rest s))) (f (last s))) false)\r\n    (if (= false s) false true)))", "problem": 95, "user": "5060c117e4b024449d699b5d"}, {"code": "(fn check-binary[coll]\n  (cond (not= true (coll? coll)) false\n        (not= (count coll) 3) false\n        (and (not= (second coll) nil)\n          (not= true (check-binary (second coll)))) false\n        (and (not= (last coll) nil)\n          (not= true (check-binary (last coll)))) false\n        :else true))", "problem": 95, "user": "5065bd94e4b0148eb3925aed"}, {"code": "(fn tree? [t]\n    (let [result (and\n      (not-any? #(= % false) t)\n      (== (count t) 3)\n    (flatten \n      (for [i t]\n    (if (coll? i)\n      (tree? i)\n      true))))]\n      (if (coll? result)\n        (every? #(= % true) result)\n        result)))", "problem": 95, "user": "50611456e4b0dc10a69545a5"}, {"code": "(fn func [coll]\r\n  (if (= coll nil)\r\n    true\r\n    (if (not (coll? coll)) \r\n      false\r\n      (if (= (count coll) 3)\r\n        (and (func (first (rest coll))) (func (last coll)))\r\n        false))))", "problem": 95, "user": "505dd5c4e4b0e6aca564be0e"}, {"code": "(fn tree? [t]\n  (or \n    (nil? t) \n    (and (coll? t)\n         (= (count t) 3)\n         (tree? (nth t 1))\n         (tree? (nth t 2)))))", "problem": 95, "user": "507a396be4b08327cd804a69"}, {"code": "(fn myfn [x](if \r\n               (coll? x) (if (not= (count x) 3)\r\n                  false  ( if (and (myfn (second x)) \r\n                                   (myfn (last x))) \r\n                                   true \r\n                                   false)) \r\n                ( cond\r\n                         (= (type x) Long) true\r\n                         (= x nil) true\r\n                         (keyword? x) true\r\n                         :else false)))", "problem": 95, "user": "50646c01e4b007509339a58b"}, {"code": "(fn t[coll]\n  (if (nil? coll)\n    true\n    (if (sequential? coll)\n        (and (= 3 (count coll)) (t (second coll)) (t (nth coll 2)))\n        false)))", "problem": 95, "user": "5097a95fe4b00ad8bab4e96e"}, {"code": "(fn f [tree]\n  (if (nil? tree)\n    true\n    (and (coll? tree)\n         (= 3 (count tree))\n         (f (nth tree 1))\n         (f (nth tree 2)))))", "problem": 95, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn binary-tree [t]\n  (if (and (coll? t) (= (count t) 3))\n    (let [[root l r] t\n          btl (binary-tree l)\n          btr (binary-tree r)]\n      (= btl btr))\n    (nil? t)))", "problem": 95, "user": "4fb79872e4b081705acca2d2"}, {"code": "(fn a [l]\n  (if (nil? l)\n    true\n    (if (coll? l)\n      (if (= (count l) 3)\n        (and (a (nth l 1)) (a (nth l 2)))\n        false)\n      false)))", "problem": 95, "user": "4fb1325de4b081705acca276"}, {"code": "(fn b [x]\n  (cond\n   (coll? x) (and (= 3 (count x)) (b (nth x 1)) (b (nth x 2)))\n   (nil? x) true\n   :else false))", "problem": 95, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn binary-tree?\r\n  [x]\r\n  (or (= x nil)\r\n      (and (coll? x)\r\n     (= (count x) 3)\r\n\t   (every? binary-tree? (rest x)))))", "problem": 95, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn tree? [t]\n    (or (nil? t)\n        (and (sequential? t)\n             (= 3 (count t))\n             (every? tree? (rest t)))))", "problem": 95, "user": "509e8da7e4b08df8156e9e2f"}, {"code": "(fn t [n] (and\n  \t     (coll? n)\n\t\t     (= 3 (count n))\n\t\t     (or (nil? (nth n 1)) (t (nth n 1)))\n\t\t     (or (nil? (nth n 2)) (t (nth n 2)))))", "problem": 95, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn test [src]\n  (cond (not (counted? src)) (nil? src)\n        (not (= 3 (count src))) false\n        :else (reduce #(and (test %1) (test %2)) (rest src))))", "problem": 95, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn tree? [t]\n         (cond\n          (not (sequential? t))\n          false\n\n          (not (= 3 (count t)))\n          false\n\n          :else\n          (let [[item left right] t]\n            (cond (and (nil? left)\n                       (nil? right))\n                  true\n\n                  (nil? left)\n                  (tree? right)\n\n                  (nil? right)\n                  (tree? left)\n\n                  :else\n                  (and (tree? left)\n                       (tree? right))))))", "problem": 95, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn bt? [t]\n  (if (or (nil? t)\n          (and (sequential? t)\n               (= 3 (count t))\n               (bt? (second t))\n               (bt? (last t))))\n    true false))", "problem": 95, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn btree? [node]\n  (cond (nil? node) true\n        (and (coll? node) (= (count node) 3))\n          (and (btree? (nth node 1))\n               (btree? (nth node 2)))\n  :else false))", "problem": 95, "user": "4fccb31be4b0ee37620e1868"}, {"code": "(fn tree? [s]\n       (if (sequential? s)\n\t\t(and (= 3 (count s))\n         \t\t(tree? (second s))\n            \t(tree? (nth s 2)))\n       \t(nil? s)))", "problem": 95, "user": "4dbdc898535d020aff1edf4a"}, {"code": "(fn is-tree2? [x]\n     (or\n       (nil? x)\n       (and\n         (sequential? x)\n         (let [[a b c] x]\n           (and\n             (= 3 (count x))\n             (is-tree2? b)\n             (is-tree2? c))))))", "problem": 95, "user": "502ade49e4b0614b52996120"}, {"code": "(fn tree?\n  [[v l r :as t]]\n  (and (= (count t) 3)\n       (or (nil? l) (and (sequential? l) (tree? l)))\n       (or (nil? r) (and (sequential? r) (tree? r)))))", "problem": 95, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn hee [x] (if (coll? x) (and (= (count x) 3) (reduce #(and %1 %2) (map hee x))) (or (true? (boolean x)) (nil? x)) ))", "problem": 95, "user": "4e61bb60535d8ccf87e9fe5c"}, {"code": "(fn foo [x]\n  (cond\n    (= x nil) true\n    (not (coll? x)) false\n    (= 3 (count x)) \n         (and true (foo (second x)) (foo (nth x 2)))    \n    :else\n    false\n))", "problem": 95, "user": "5078300de4b0fc74642bff66"}, {"code": "(fn c [t]\n  (or (nil? t)\n      (and t (= (count t) 3) (and (c (nth t 1)) (c (nth t 2))))))", "problem": 95, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn [x]\r\n  (letfn [(tree? [test_tree]\r\n  (if (nil? test_tree)\r\n    true\r\n    (if (or (not (coll? test_tree)) \r\n            (not (= 3 (count test_tree))))\r\n      false\r\n      (let [children (rest test_tree)]\r\n        (and (tree? (first children)) (tree? (second children)))))))]\r\n(tree? x)))", "problem": 95, "user": "4f0365fc535dcb61093f6aa4"}, {"code": "(fn f [[a & b]]\n  (let [ff (fn [c]\n    (if (coll? c)\n      (f c)\n      (nil? c)))]\n    (if (= 2 (count b))\n      (if (ff (first b))\n        (ff (second b))\n        false)\n      false)))", "problem": 95, "user": "502940a9e4b061fd216be4b8"}, {"code": "(fn v [lista]\r\n  (if (not= (count lista) 3)\r\n\t\tfalse\t\t\r\n\t\t(loop [l lista]\r\n\t\t\t(cond (empty? l) true\r\n\t\t\t\t  (sequential? (first l)) (v (first l))\r\n                  (= false (first l)) false\r\n\t\t\t\t  :else (recur (rest l))))))", "problem": 95, "user": "50576483e4b001218172198b"}, {"code": "(fn [s]\n  (reduce #(and % %2) (map #(cond\n    (sequential? %) (= (count %) 3)\n    (= nil %) true\n    :else false)\n    (tree-seq sequential? rest s))))", "problem": 95, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn P95 [tree]\n  (if (and (not= tree false) \n           (or (and (= (count tree) 3)\n                    (P95 (nth tree 1))\n                    (P95 (nth tree 2)))\n               (= tree nil)))\n    true\n    false))", "problem": 95, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "50ae22c3e4b0a40c9cfb08d0"}, {"code": "(fn bintree [s]\r\n  (if (nil? s)\r\n    true\r\n    (if (and (coll? s) (= 3 (count s)))\r\n      (every? bintree (rest s))\r\n       false)))", "problem": 95, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn t [n]\n  (or (nil? n) (and (coll? n) (= 3 (count n)) (every? true? (map t (rest n))))))", "problem": 95, "user": "50ad7888e4b0a40c9cfb08c7"}, {"code": "(fn f [l]\n  (or (nil? l)\n      (and (coll? l)\n           (= (count l) 3)\n           (every? f (rest l)))))", "problem": 95, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn r [a] (and (= 3 (count a)) (every? true? (map #(if (coll? %) (r %) (not (false? %))) a))))", "problem": 95, "user": "508ee17ae4b0706b2ed3ef8d"}, {"code": "(fn f [a]\n  (and (= 3 (count a)) (first a)\n    (every?\n      #(if (coll? %) (f %) (nil? %)) \n      (rest a))))", "problem": 95, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn bt [s] (if (= 3 (count s)) (every? true? (map #(if (sequential? %) (bt %) (not= false %)) s)) false))", "problem": 95, "user": "5098bcfee4b0cae2931060a1"}, {"code": "(fn btree? [s]\n  (if (coll? s)\n    (and (= (count s) 3)\n               (btree? (second s))\n               (btree? (last s)))\n    (not (false? s))))", "problem": 95, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn chk [x]\n  (cond \n    (coll? x) (and \n      (every? chk  (rest x)) \n      (= (count x) 3)) \n    (nil? x) true\n    :else false))", "problem": 95, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn t [tree]\n  (cond\n     (nil? tree) true\n     (not (coll? tree)) false\n     (= 3 (count tree)) (let [[i l r] tree]\n       (and (t l) (t r)))\n     :else false))", "problem": 95, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn tree? [n] \n  (and\n    (coll? n)\n    (= 3 (count n)) \n    (or \n      (tree? (second n)) \n      (nil? (second n)))\n    (or \n      (tree? (nth n 2)) \n      (nil? (nth n 2)))\n))", "problem": 95, "user": "50a4f36be4b0344e360f3bc9"}, {"code": "(fn d [xs]\n  (if (not= (count xs) 3) false\n\t\t(let [check #(cond (nil? %) true\n\t\t\t\t\t\t   (coll? %) (d %)\n\t\t\t\t\t\t   :else\tfalse)]\n\t\t\t(and (check (second xs)) (check (last xs))))))", "problem": 95, "user": "508e13abe4b0f17d83ea26c7"}, {"code": "(fn btree? [tree]\n  (if (= nil tree)\n      true\n      (if (coll? tree)\n        (if (not= 3 (count tree))\n            false\n            (and \n               (btree? (nth tree 1))\n               (btree? (nth tree 2))))\n        false)))", "problem": 95, "user": "5092fe10e4b097f48cc3857e"}, {"code": "(fn [tree]\n  (every? true? \n   (map #(or (nil? %) (and (sequential? %) (= 3 (count %))))\n        (tree-seq sequential? rest tree))))", "problem": 95, "user": "50052d38e4b0678c553fc45c"}, {"code": "#(if (even? (count (remove false? (flatten %)))) false true)", "problem": 95, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn tree [x] \n  (if (= x nil) \n    true \n    (if (and (coll? x) (= 3 (count x))) \n      (and (tree (second x)) (tree (last x)) )\n      false\n    )\n   )\n)", "problem": 95, "user": "50bf3015e4b0a6abc6550e5b"}, {"code": "(fn bt? [obj] (cond (nil? obj) true (not (sequential? obj)) false (not (= 3 (count obj))) false true (and (bt? (nth obj 1)) (bt? (nth obj 2)))))", "problem": 95, "user": "50ae5659e4b0a40c9cfb08d2"}, {"code": "(fn x [n] (let [[v l r] n]\n                (and\n                  (= 3 (count n))\n                  (if (coll? l) (x l) (nil? l))\n                  (if (coll? r) (x r) (nil? r))\n                )\n            )\n)", "problem": 95, "user": "4f9920a3e4b0dcca54ed6cfc"}, {"code": "(fn f [c]\n  (and\n    (coll? c)\n    (== (count c) 3)\n    (every?\n      #(or\n        (nil? %)\n        (f %))\n      (rest c))))", "problem": 95, "user": "4f253a49e4b0d66497709ff3"}, {"code": "(fn tree? [x]\n  (cond (nil? x) true\n        (or (false? x)\n            (not (= 3 (count x)))) false\n        (and (tree? (second x)) (tree? (last x))) true\n        :else false))", "problem": 95, "user": "4db86aee535d1e037afb2193"}, {"code": "(fn tree? [s]\n  (cond (nil? s) true\n        (not (coll? s)) false\n        (not= (count s) 3) false\n        :else (and (tree? (second s))\n                   (tree? (nth s 2)))))", "problem": 95, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn dvt [x] (let [ [a b c] x]\n                  (and \n                    (= 3 (count x)) \n                    (not (seq? a))\n                    (or (nil? b) (and (sequential? b) (dvt b)))\n                    (or (nil? c) (and (sequential? c) (dvt c)))\n                    )))", "problem": 95, "user": "50956c2be4b087f34d351ab2"}, {"code": "(letfn [(binary-tree?  [t]\r\n            (and (= (count t) 3)\r\n                 (every? node? (rest t))))\r\n          (node? [x]\r\n            (or (nil? x)\r\n                (and (coll? x)\r\n                     (binary-tree? x))))]\r\n    binary-tree?)", "problem": 95, "user": "50436470e4b034ff00315d23"}, {"code": "(fn[xs]\n  (let [tree (tree-seq sequential? identity xs)]\n     (empty?\n      (filter \n       #(and (sequential? %) \n             (or \n              (not= 3 (count %))\n              (some (fn[x] (and (not (sequential? x)) (not (nil? x)))) (drop 1 %)))) \n       tree))))", "problem": 95, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn is-tree [tree]\n  (println tree)\n  (or \n    (nil? tree)\n    (and\n      (coll? tree)\n      (= 3 (count tree))\n      (is-tree (second tree)) \n      (is-tree (nth tree 2)))))", "problem": 95, "user": "50112acee4b0d82cfac69f4c"}, {"code": "(fn is-tree? [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (not (coll? (first tree)))\n           (every? is-tree? (rest tree)))))", "problem": 95, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn me [t]\n  (if (coll? t)\n    (if (= (count t) 3)\n      (and (me (second t)) (me (last t)))\n      false)\n    (nil? t)))", "problem": 95, "user": "509160dae4b0742c82730aef"}, {"code": "(fn f [xs]\n   (if (== (count xs) 3)\n     (and (if (nil? (second xs))\n            true\n            (if (false? (second xs))\n              false\n              (f (second xs))))\n          (if (nil? (nth xs 2))\n            true\n            (f (nth xs 2))))\n     false)\n   )", "problem": 95, "user": "50868795e4b004985b776e5e"}, {"code": "(\nfn my-btree[x]\n\t(let [ \n\t\tres (if(= 3 (count x)) true false)\n\t       resl (and res (if(coll? (second x)) (my-btree (second x)) (nil? (second x))) )\n\t       resr (and res (if(coll? (nth x 2)) (my-btree (nth x 2)) (nil? (nth x 2))) ) \n\t\t]\n\t(and res resl resr)\n)\n)", "problem": 95, "user": "50b25f2ce4b03ea88043355f"}, {"code": "(fn tree?[t](and \n  (sequential? t)\n  (= (count t) 3)\n  (not (nil? (first t)))\n  (or (tree? (nth t 1)) (nil? (nth t 1)))\n  (or (tree? (nth t 2)) (nil? (nth t 2)))\n))", "problem": 95, "user": "4de8a7d7535d08e6dec9fdfe"}, {"code": "(fn binary-tree? [tree]\n  (and (sequential? tree) (= (count tree) 3) (not (nil? (first tree))) \n    (every? #(or (nil? %) (binary-tree? %)) (rest tree))))", "problem": 95, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn test95\n  [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= (count coll) 3)\n           (every? test95 (rest coll)))))", "problem": 95, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn tree? [x]\n    (or (nil? x) (and (coll? x) (= 3 (count x)) (tree? (second x)) (tree? (first (drop 2 x))))))", "problem": 95, "user": "50cb4cf6e4b0f78a8e1645b4"}, {"code": "(fn __ [tree]\n  (if (and (or (vector? tree)\n               (seq? tree))\n           (= (count tree) 3))\n    (and (__ (second tree)) (__ (second (rest tree))))\n    (if (and (not (vector? tree)) (not (seq? tree)))\n      (if (= false tree)\n        false\n        true)\n      false\n      )))", "problem": 95, "user": "509b152be4b0412cdea6eb1e"}, {"code": "(fn binary? [node]\n  (cond\n    (nil? node) true\n    (sequential? node) (and (= 3 (count node)) (every? binary? (rest node)))\n    :else false))", "problem": 95, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "50ab8ae3e4b01d6eb43ce9a0"}, {"code": "(fn f [x] (or (nil? x)\n            (and (coll? x) \n             \t (= 3 (count x))\n                 (f (second x))\n                 (f (nth x 2)))))", "problem": 95, "user": "4f8b27b3e4b02e764a0a5179"}, {"code": "(fn tree? [[v l r :as x]] \n  (if (not= (count x) 3) \n    false \n    (letfn [(node? [n] (if (false? n) false (or (tree? n) (nil? n))))] \n      (cond (or (number? v) (keyword? v)) \n            (and (node? l) (node? r)) \n            :else false))))", "problem": 95, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [t]\n  (every? #(= 2 %)\n          (map (fn [n]\n                 (count\n                  (filter #(or (sequential? %) (nil? %))\n                          (rest n))))\n               (filter sequential?\n                       (tree-seq\n                        sequential?\n                        seq\n                        t)))))", "problem": 95, "user": "50c75d38e4b00bb60fe0c532"}, {"code": "(fn tree? [t]\n  (if (nil? t) true\n    (and (coll? t) (= (count t) 3) (every? tree? (rest t)))))", "problem": 95, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn istree [x]\n  (if (nil? x) true\n    (and\n      (coll? x)\n      (= (count x) 3)\n      (istree (nth x 1))\n      (istree (nth x 2))\n     )\n   )\n )", "problem": 95, "user": "50bfbf25e4b05ae8c1cbbd9b"}, {"code": "(fn tree? [t]\n  (cond \n   (nil? t) true\n   (and \n     (coll? t)\n     (= 3 (count t))\n     (tree? (nth t 1))\n     (tree? (nth t 2))) true\n   :else false))", "problem": 95, "user": "4ff769bce4b0678c553fc38f"}, {"code": "(letfn [(binary-tree?  [t]\n          (and (= (count t) 3)\n                 (every? node? (rest t))))\n        (node? [x]\n          (or (nil? x)\n              (and (coll? x)\n                   (binary-tree? x))))]\n    binary-tree?)", "problem": 95, "user": "50cf2267e4b0e61f11ddcd8c"}, {"code": "(fn f [t] (if (coll? t) (if (= (count t) 3) (let [[v l r] t] (and (not (coll? v)) (f l) (f r))) false) (nil? t)))", "problem": 95, "user": "50b24a2fe4b03ea88043355c"}, {"code": "(fn is-tree [tree]\n  (and \n    (= 3 (count tree))\n\t  (every? true? \n\t          (map \n\t            #(if (coll? %)\n\t\t\t          (is-tree %)\n\t\t\t          (or (number? %) (nil? %) (keyword? %)))\n\t       tree))))", "problem": 95, "user": "4fe15ffee4b0dd6cd5ce3634"}, {"code": "(fn f [s] (or (nil? s) (and (coll? s) (= 3 (count s)) (every? f (rest s)))))", "problem": 95, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn this [s]\n  (cond (and (not (seq? s)) (not (vector? s))) (not (= false s))\n        (= (count s) 0) false\n        (= (count s) 1) true\n        (and (> (count s) 0) (< (count s) 3)) false\n        (not (= (count s) 3)) false\n        :else (let [root (first s)\n                    left (nth s 1)\n                    right (nth s 2)]\n                (and (this left) \n                     (this right)))))", "problem": 95, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn [tree]\n   (not (some #(not (= 3 (count (filter (complement false?) %)))) \n              (filter (complement nil?) \n                     (tree-seq #(and (or (seq? %) (vector? %)) (next %)) rest tree)))))", "problem": 95, "user": "50cae881e4b0f75dcc9a6e51"}, {"code": "(fn[s](every? #(if (coll? %) (= (count %) 3) (nil? %)) (tree-seq coll? rest s)))", "problem": 95, "user": "4e778d36535d324fb2983d71"}, {"code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "5012036ce4b0a040369c12f4"}, {"code": "(fn binary-tree? [s]\n  (let [[v lc rc] s]\n    (and\n      (if-not (false? v) true false)\n      (= 3 (count s))                                ; top node has a value, left child and right child.\n      (if (sequential? lc) (binary-tree? lc) (if-not (false? lc) true false))   ; left child is a leaf node or a binary tree\n      (if (sequential? rc) (binary-tree? rc) (if-not (false? rc) true false))   ; right child is a leaf node or a binary tree\n    )\n  )\n)", "problem": 95, "user": "50e496e8e4b0cb9ec68fbca0"}, {"code": "(fn isTree [t]\n  (and \n   (or (seq? t) (vector? t))\n   (= (count t) 3)\n   (every? #(or (nil? %) (isTree %)) (rest t))))", "problem": 95, "user": "50e8ff6be4b0ebbe794eb7f3"}, {"code": "(fn tree? [s]\n  (and (coll? s)\n       (= 3 (count s))\n       (not (coll? (first s)))\n       (every? #(or (nil? %) (tree? %)) (rest s))))", "problem": 95, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn tr? [tree]\n  (and\n    (coll? tree)\n    (= 3 (count tree))\n    (or (= nil (nth tree 1)) (tr? (nth tree 1)))\n    (or (= nil (nth tree 2)) (tr? (nth tree 2)))))", "problem": 95, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn tree? [lst]\n  (let [node (first lst)\n        left (second lst)\n        right (last lst)]\n    (and\n      (= 3 (count lst))\n      (not (list? node))\n      (cond\n        (nil? left) true\n        (coll? left) (tree? left)\n        :else false)\n      (cond\n        (nil? right) true\n        (coll? right) (tree? right)\n        :else false))))", "problem": 95, "user": "50a7ef7fe4b090657f4a5ce0"}, {"code": "(fn btree? [xs]\n    (if (coll? xs)\n      (and (= 3 (count xs)) (every? btree? xs))\n      (not (= xs false))))", "problem": 95, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn tree? [col]\n  (cond \n   \t(nil? col) true\n    (not (coll? col)) false\n    (= 3 (count col)) (and (tree? (second col)) (tree? (nth col 2)))\n    :else false\n  ))", "problem": 95, "user": "50bfe725e4b080409b860f26"}, {"code": "(fn t [a]\n  (or (nil? a)\n      (and (sequential? a)\n           (= 3 (count a))\n           (t (nth a 1))\n           (t (nth a 2)))))", "problem": 95, "user": "50ed4626e4b01236b1d4983c"}, {"code": "(fn z [t]\n  (if-not (sequential? t)\n    (not (false? t))\n          (and (= 3 (count t))\n               (z (second t))\n               (z (last t)))))", "problem": 95, "user": "4db29f98535df7e46ed9b6c1"}, {"code": "(fn tree? [e]\n  (or (nil? e)\n      (and (counted? e)\n           (= 3 (count e))\n           (every? tree? (next e)))))", "problem": 95, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn tree? [t]\n  (and (sequential? t) (= (count t) 3)\n       (and (or (nil? (fnext t)) (tree? (fnext t)))\n            (or (nil? (fnext (next t))) (tree? (fnext (next t)))))))", "problem": 95, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [s]     \n  (letfn [(bin? [s]\n            (or\n              (nil? s)\n              (and\n                (sequential? s)\n                (= 3 (count s))\n                (every? bin? (rest s)))))]\n    (bin? s))\n)", "problem": 95, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [seq]\n  (letfn [(binary-tree? [seq]\n            (cond\n             (nil? seq) true\n             (not (coll? seq)) false\n             (= (count seq) 3) (and (binary-tree? (second seq)) (binary-tree? (last seq)))\n             :else false))]\n    (binary-tree? seq)))", "problem": 95, "user": "50ed3c6be4b01236b1d4983b"}, {"code": "(fn walk[[h & r]] \n  (if (not= 2 (count r)) false\n   (every? true? (for [i r]\n    (if (coll? i) (walk i) (nil? i))\n  ))))", "problem": 95, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn tree? [aSequence]\n  (cond\n    (or (seq? aSequence) (vector? aSequence))\n      (and (= 3 (count aSequence)) (tree? (nth aSequence 1)) (tree? (nth aSequence 2)))\n    (nil? aSequence) true\n    :else false))", "problem": 95, "user": "50ee145de4b06330c1f87c53"}, {"code": "(fn testb ([x] (if (or (seq? x) (vector? x)) (apply testb x) (if (not (= x false)) true false)))\n\t([x y] false) ([] false)\n\t([x y z] (and (testb x) (testb y) (testb z)))\n\t([x y z &more] false))", "problem": 95, "user": "503539dee4b0ed9c821488f6"}, {"code": "(fn tree? [a]\n  (cond\n    (or (seq? a) (vector? a))\n      (and (= 3 (count a)) (tree? (nth a 1)) (tree? (nth a 2)))\n    (nil? a) true\n    :else false))", "problem": 95, "user": "50ef56dfe4b0bdaecbb47d94"}, {"code": "(fn tree? [t]\n    (cond (nil? t) true\n          (coll? t) (and (= (count t) 3)\n                         ((complement coll?) (first t))\n                         (tree? (second t))\n                         (tree? (last t)))\n          :else false))", "problem": 95, "user": "50608ea0e4b07251188e4456"}, {"code": "(fn x [arr] (cond (false? arr) false  (not (or (list? arr) (vector? arr) )) true (= 3 (count arr)) (and (x (nth arr 1)) (x (nth arr 2))) :else false))", "problem": 95, "user": "50ef3e5de4b0a78662fa2652"}, {"code": "(fn f [v] (and (= (count v) 3)\n               (every? #(if (sequential? %)\n                            (f %)\n                            (nil? %))\n                       (rest v))))", "problem": 95, "user": "4ec1b090535dfed6da9c6db5"}, {"code": "#_(zomg this is horrible...)\n(fn t?\n  ([v l r]\n   (if (and (not (seq? v))\n            (t? l)\n            (t? r))\n     true\n     false))\n  ([a b] false)\n  ([v]\n   (cond\n    (nil? v) true\n    (= false v) false\n    (seq v) (apply t? v)\n    :else false))\n  ([a b c & xs]\n   false))", "problem": 95, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn f [v] (if (coll? v) (and (= 3 (count v))(every? f (next v))) (nil? v)))", "problem": 95, "user": "4e7115b3535d5021c1a89647"}, {"code": "(fn t? [t] (or (println t) \n               (nil? t) \n               (and (sequential? t)\n                    (= 3 (count t)) \n                    (t? (second t)) \n                    (t? (nth t 2)))))", "problem": 95, "user": "50dfb660e4b061dbdced7228"}, {"code": "(fn is-binary-tree [col] (if (coll? col)\n                           (if (= (count col) 3)\n                             (reduce #(and % (is-binary-tree %2)) true (rest col))\n                             false)\n                           (nil? col)))", "problem": 95, "user": "5036eba7e4b0af0658af77a5"}, {"code": "(fn test [node]\n  (cond (nil? node)\n    \ttrue\n        (sequential? node)\n        (let [[v l r] node]\n          (and (= 3 (count node))\n             \t (test l)\n             \t (test r)))\n        :else\n        false))", "problem": 95, "user": "50ccf729e4b0f7a459302aac"}, {"code": "(fn f [t]\n    (let [ branch? #(or (list? %) (seq? %) (vector? %)) ]\n      (if (not (= 3 (count t)))\n        false\n        (loop [ l (nth t 1), r (nth t 2)]\n          (cond\n            (= nil l r)\n              true\n            (and (branch? l) (branch? r))\n              (and (f r) (f l))\n            (and (branch? l) (= 3 (count l)))\n              (recur (second l) (nth l 2))\n            (and (branch? r) (= 3 (count r)))\n              (recur (second r) (nth r 2))\n            :else\n              false)))))", "problem": 95, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn f [n]\n  (every? #(if (coll? %)\n             (= (count %) 3)\n             (not (contains? #{false '()} %)))\n          (tree-seq coll? rest n)))", "problem": 95, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn tree?-95 [coll]\n  (println (str \"checking: \" coll))\n  (or\n    (and\n      (coll? coll) (= (count coll) 3) (every? #(tree?-95 %) coll))\n    (and\n      (not (coll? coll))\n      (not (false? coll)))))", "problem": 95, "user": "501b1a8ee4b0b12d9c5f4d81"}, {"code": "(fn f [x]\n  (if (coll? x)\n    (if (= (count x) 3)\n\t  (and (f (nth x 1)) (f (nth x 2)))\n\t  false\n\t)\n\t(if (= x nil)\n\t  true\n\t  false\n\t)\n  )\n)", "problem": 95, "user": "50f4894be4b004d364930528"}, {"code": "#(if (even? (count (remove false? (flatten %)))) false true)", "problem": 95, "user": "5097ddfce4b087ccf61a7af0"}, {"code": "(fn t [args]\n  (or (nil? args)\n      (and (sequential? args)\n           (= 3 (count args))\n           (every? #(t %) (rest args)))))", "problem": 95, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn check [tree] (if (coll? tree) \n                   (if (not= (count tree) 3)                \n                     false                \n                     (and (check (nth tree 0)) (check (nth tree 1)) (check (nth tree 2)))) \n                                   \n                     (not= false tree)))", "problem": 95, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn bin-tree? [tree]\n    (if (and (coll? tree) (= (count tree) 3))\n      (let [[v l r] tree\n            val? (complement coll?)]\n        (println \"v: \" v \"l: \" l \"r: \" r)\n        (and  (val? v) (or (nil? l) (bin-tree? l)) (or (nil? r) (bin-tree? r))) ) false))", "problem": 95, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn t? [[n l r :as t]] (and (= 3 (count t)) (every? #(or (nil? %) (and (coll? %) (t? %))) [l r])))", "problem": 95, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [x]\n  (reduce #(and %1 %2)\n          (map #(if (nil? %)\n                  true\n                  (and (coll? %)\n                       (= 3 (count %))))\n               (tree-seq #(not (nil? %))\n                         #(if (coll? %)\n                            (rest %)\n                            [])\n                         x))))", "problem": 95, "user": "50981062e4b04e098a4c7268"}, {"code": "(fn tree? [t] \n  (or \n    (nil? t)\n    (and (sequential? t) (= (count t) 3) (tree? (first (rest t))) (recur (first (rest (rest t)))))))", "problem": 95, "user": "5105a637e4b0380e797c7d5d"}, {"code": "(fn btree? [node]\n  (if (nil? node)\n    true\n    (do (println node)\n  \t(if (and (sequential? node) (= 3 (count node)))\n      (let [[v l r] node]\n        (and (btree? l)\n             (btree? r)))\n      false))))", "problem": 95, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn tree? [tree]\n   (or (nil? tree)\n       (and (sequential? tree)\n            (= 3 (count tree))\n            (tree? (nth tree 1))\n            (tree? (nth tree 2)))))", "problem": 95, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn __ [xs]\n  ; if arr is a collection\n  (if (and (coll? xs) (= 3 (count xs)))\n    (let [\n      x (first xs)\n      y (second xs)\n      z (last xs)\n      b (rest xs)\n      t xs\n    ]\n      ; we need two branches\n      (if (= 2 (count b))\n          ; we have two branches...\n          ; next make sure first item is non-nil/-empty e.g. 1 or :a etc\n          (if (nil? x) ; <- not sure that's the best test\n            false ; variable is \n            (and (__ y) (__ z))\n          )\n          ; we do not have two branches so x better be nil\n          (if (nil? x) true false)\n      )\n \t\t)\n   \n   ; this means arr isn't an arr but a value\n \t (if (nil? xs) true false)\n  )\n)", "problem": 95, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn tree? [t]\n  (if (not (coll? t))\n\t(if (= t false)\n      false\n      true)\n\t(if (not= (count t) 3)\n\t  false\n\t  (and (tree? (first t)) (tree? (second t)) (tree? (nth t 2))))))", "problem": 95, "user": "5101192ae4b0bef64c30e266"}, {"code": "(fn tree? [t]\n    (cond (nil? t) true\n          (coll? t) (and (= (count t) 3)\n                         ((complement coll?) (first t))\n                         (tree? (second t))\n                         (tree? (last t)))\n          :else false))", "problem": 95, "user": "50503117e4b0a02f9cffdeb5"}, {"code": "(fn bt?\n  [e]\n  (cond\n   (coll? e) (and\n             (= 3 (count e))\n             (every? true? (map bt? e)))\n   :else (not (false? e))\n   )\n  )", "problem": 95, "user": "5107b86de4b05b2b4eee7495"}, {"code": "(fn istree? [l] (if (or (seq? l)(vector? l)) (and (= (count l) 3) (istree? (nth l 1)) (istree? (nth l 2))) (= l nil)))", "problem": 95, "user": "510931ede4b0c71f76895663"}, {"code": "(fn t? [[x y z :as a]]\n  (if (or (empty? a) (contains? (set a) false))\n    (if (nil? a) true false)\n    (and (= (count a) 3) (t? y) (t? z))))", "problem": 95, "user": "510d9d61e4b078ea71921141"}, {"code": "(fn f [t]\n  (cond (nil? t) true\n        (or (not (coll? t))\n            (not= 3 (count t))) false\n        :else (and (f (second t)) (f (last t)))))", "problem": 95, "user": "5102489de4b00c483ae176f6"}, {"code": "(fn tree? [xs]\n  (if (nil? xs)\n    true\n    (if (coll? xs)\n      (if (= (count xs) 3)\n        (and (tree? (nth xs 1)) (tree? (nth xs 2)))\n        false)\n      false)))", "problem": 95, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn chk [x] \n   (if (= (count x) 3)\n     (let [[a b c] x]\n       (and\n         (not (nil? a))\n         (cond (nil? b) true (coll? b) (chk b) :else false)\n         (cond (nil? c) true (coll? c) (chk c) :else false)\n         )\n       )\n     false))", "problem": 95, "user": "50d8739ae4b01f0871336e68"}, {"code": "(fn istree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (istree? (nth t 1))\n           (istree? (last t)))))", "problem": 95, "user": "5106bc8ae4b01150e115ebec"}, {"code": "(fn tree? [s]\n (or (nil? s)\n     (and (sequential? s)\n          (= (count s) 3)\n          (tree? (second s))\n          (tree? (nth s 2)))))", "problem": 95, "user": "510db6cde4b078ea71921145"}, {"code": "(fn ! [tree]\n   (and  (coll? tree) (= 3 (count tree)) (not (nil? (first tree))) (not (coll? (first tree)))   \n        (or (nil? (nth tree 1)) (! (nth tree 1)))\n        (or (nil? (nth tree 2)) (! (nth tree 2)))\n        )\n   )", "problem": 95, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn tree? [tree]                                                       \n        (let [[_ left right] tree]                                             \n          (if (not= (count tree) 3)                                            \n              false                                                            \n            (and (if (coll? left)                                              \n                     (tree? left)                                              \n                   (nil? left))                                                \n                 (if (coll? right)                                             \n                     (tree? right)                                             \n                   (nil? right))))))", "problem": 95, "user": "4e4be570535dc968683fc4d8"}, {"code": "(fn is-tree? [xs]\n  (if (nil? xs) true\n      (and (coll? xs) (= (count xs) 3) \n           (let [[v left right] xs]\n             (and v (not (coll? v)) (is-tree? left) (is-tree? right))))))", "problem": 95, "user": "5114ab7be4b0ce5098ee73b5"}, {"code": "(fn binary_tree? [tree]\n  (cond\n   (nil? tree) true\n   (not (coll? tree)) false\n   (not (= 3 (count tree))) false\n   (not (binary_tree? (second tree))) false\n   (not (binary_tree? (last tree))) false\n   :else true))", "problem": 95, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn f [c]\n   (if (coll? c)\n     (and (= 3 (count c))\n          (reduce #(and %1 %2) (map f c)))\n     (not= (type c) Boolean)\n     ))", "problem": 95, "user": "50bce014e4b0594b91591c63"}, {"code": "#(odd? (count (filter % (flatten %2))))\n#(not (false? %))", "problem": 95, "user": "4e50ad74535dc968683fc4ec"}, {"code": "(fn is-tree [x]\n  (cond\n   (= x nil) true             ; The empty tree is represented by nil\n   (not (coll? x)) false      ; If it's not a collection (or nil), it's invalid\n   (not= (count x) 3) false   ; A valid tree must contain three elements (or 0, hence testing for nil first)\n   (and (is-tree (nth x 1))   ; The left child must be a valid tree...\n        (is-tree (nth x 2))   ; ...and the right child must be a valid tree\n        ) true\t\t\t\t  ; If both subtrees are valid, then this tree is valid\n   :else false))              ; If none of the tests above match, then this is not a valid tree", "problem": 95, "user": "5119f3d5e4b06c8af0111818"}, {"code": "(fn btree? [tree]\n  (if (coll? tree)\n    (and (= (count tree) 3) (every? btree? tree))\n    (or tree (nil? tree))))", "problem": 95, "user": "51105c7fe4b04c71fce993ef"}, {"code": "(fn binary? [node]\n  (if-not (coll? node)\n    (nil? node)\n    (let [ct (count node)]\n      (if (and (not= ct 1) (not= ct 3))\n        false\n        (let [lhs (second node)\n              rhs (last node)]\n          (and (binary? lhs) (binary? rhs)))))))", "problem": 95, "user": "51195e77e4b055cfb310d499"}, {"code": "#(if (even? (count (remove false? (flatten %)))) false true)", "problem": 95, "user": "51181009e4b0e0897831a60f"}, {"code": "(fn isbintree? [col] \n  (if (sequential? col)\n  (if (and (= (count col) 3) \n           (isbintree? (second col))\n           (isbintree? (last col))\n    ) true false) (if (nil? col) true false))\n  )", "problem": 95, "user": "510d3dc6e4b078ea71921132"}, {"code": "(fn this [input]\n  (or\n   (= input nil)\n   (and\n    (sequential? input)\n    (= (count input) 3)\n    (let [[_ left right] input]\n      (and (this left) (this right))))))", "problem": 95, "user": "4ec12577535dfed6da9c6da8"}, {"code": "(fn tree? [t]\n  (cond\n   (coll? t) (if (= (count t) 3)\n               (and (tree? (nth t 1))\n                    (tree? (nth t 2)))\n               false)\n   (nil? t) true\n   :else false))", "problem": 95, "user": "50f9739ce4b0e7c80cb15a4d"}, {"code": "(fn is-binary? [xs]\n  (if (= 3 (count xs))\n    (let [[_ y z] xs]\n    (and\n     (if (coll? y) (is-binary? y) (if (nil? y) true y))\n     (if (coll? z) (is-binary? z) (if (nil? z) true z))))\n    false))", "problem": 95, "user": "50b35486e4b03ea88043356a"}, {"code": "(fn f [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= (count x) 3)\n           (f (.get x 1))\n           (f (.get x 2)))))", "problem": 95, "user": "51256b40e4b05d10e3e395f8"}, {"code": "(fn istree [t] (or (= t nil) (and (sequential? t) (= (count t) 3) (istree (nth t 1)) (istree (nth t 2)))))", "problem": 95, "user": "51284226e4b03a34742b4308"}, {"code": "(fn f [x] (or (nil? x)\n              (and (coll? x)\n                   (= (count x) 3)\n                   (f (nth x 1))\n                   (f (nth x 2)))))", "problem": 95, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn tree-p [coll] \n  (or (nil? coll)\n      (letfn [(check-node [coll]\n                          (and (coll? coll)\n                               (= 3 (count coll))\n                               (or (nil? (nth coll 1)) (check-node (nth coll 1)))\n                               (or (nil? (nth coll 2)) (check-node (nth coll 2)))))]\n        (check-node coll))))", "problem": 95, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn binary-tree? [t]\n  (cond   \t\n  \t(and (coll? t) (= (count t) 3)) \n   \t\t(let [[v l r] t]        \n   \t\t\t\t(every? true? (map binary-tree? [l r]))\n      )\n   \t(nil? t) true   \t\n   \t:else false)\n)", "problem": 95, "user": "5081566ce4b0946d0443855b"}, {"code": "(fn bt? [s] (and (coll? s)\n                 (= 3 (count s))\n                 (or (nil? (nth s 1)) (bt? (nth s 1)))\n                 (or (nil? (nth s 2)) (bt? (nth s 2)))))", "problem": 95, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn bin-tree [form]\n  (and (= 3 (count form))\n       (if (coll? (second form)) (bin-tree (second form)) (nil? (second form)))\n       (if (coll? (nth form 2)) (bin-tree (nth form 2)) (nil? (nth form 2)))))", "problem": 95, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn ! [x]\n  (cond \n    (coll? x) (reduce (fn [acc i](and acc (! i))) (and (-> x first coll? not) (= 3 (count x))) (rest x))\n    :else (= x nil)))", "problem": 95, "user": "511ac026e4b0c87c59c9670e"}, {"code": "(fn tree? [[root & ns]]\n  (if (not= 2 (count ns))\n    false\n    (let [[l r] ns\n          leaf? #(or (not (sequential? %))\n                     (tree? %))]\n      (and (every? (partial not= false) [l r])\n           (leaf? l) (leaf? r)))))", "problem": 95, "user": "4fca4c37e4b0ee37620e184f"}, {"code": "(fn istree[ vv ]\n    (if  (= false vv ) false \n    ( cond  (= nil vv)          true\n            (= 3 (count vv))    (and (istree (second vv) ) (istree (nth vv 2))  )\n            (= 1 (count vv))    true\n            :else  false  )))", "problem": 95, "user": "4f030775535dcb61093f6a43"}, {"code": "(fn f [[a b c :as xs]]\n   (cond (not (sequential? xs)) false\n         (not= (count xs) 3) false\n         (nil? a) false\n         (and (not (nil? b))\n              (sequential? b)\n              (not (nil? c))\n              (sequential? c)) (and (f b) (f c))\n         (and (not (nil? b))\n              (sequential? b)) (f b)\n         (and (not (nil? c))\n              (sequential? c)) (f c)\n         (and (nil? b) (nil? c)) true\n         :else false))", "problem": 95, "user": "50742549e4b054001656accf"}, {"code": "(fn [coll]\n  (loop [a [coll]\n         b [coll]]\n    (if (nil? (first b))\n      (and (every? true? (map #(= (count %) 3) a))\n           (not (some false? (map second a))))\n      (recur (concat a (filter coll? (first b))) (concat (rest b) (filter coll? (first b)))))))", "problem": 95, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn f [x]\n  (cond \n    (nil? x) true\n    (not (coll? x)) false\n    :else \n      (let [[a b c :as d] x]\n        (and (= 3 (count d)) (f b) (f c)))))", "problem": 95, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "problem": 95, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn isBinaryTree? [t]\n  (if\n    ((complement coll?) t) (nil? t)\n    (if (= (count t) 3)\n      (let [[_ l r] t] (and (isBinaryTree? l) (isBinaryTree? r))\n        )\n      false)\n    )\n  )", "problem": 95, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn fx [xs] (cond \n                      (nil? xs) true\n                      (and (coll? xs) (= 3 (count xs))) (and (fx (second xs)) (fx (last xs)))\n                      :else false\n                      ))", "problem": 95, "user": "511d11d7e4b022853b0e079f"}, {"code": "(fn is-tree [x]\n   (letfn [(inspect [a] (if (nil? a) true (is-tree a)))]\n   (if (and (coll? x) (== 3 (.size x))) (and (inspect (nth x 1)) (inspect (nth x 2))) false))\n)", "problem": 95, "user": "510a6bece4b06956752d35af"}, {"code": "(fn check-tree [node]\n  (cond\n   (nil? node) true\n   (not (coll? node)) false\n   (not= 3 (count node)) false\n   :else (and (check-tree (second node)) (check-tree (last node)))\n  )\n)", "problem": 95, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn tree? [root]\n  (cond\n   (nil? root) true\n   (and (sequential? root) (= (count root) 3) (tree? (second root)) (tree? (nth root 2))) true\n   :else false))", "problem": 95, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "(fn tree? [x]\n   (or (nil? x) (and (sequential? x)\n                     (= 3 (count x)) \n                     (not (sequential? (first x)))\n                     (tree? (second x))\n                     (tree? (last x)))))", "problem": 95, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn tree? [t]\n  (cond\n   (sequential? t) (and (= 3 (count t)) (tree? (second t)) (tree? (second (rest t))))\n   :else (nil? t)))", "problem": 95, "user": "4e6f1b7a535d5021c1a89618"}, {"code": "(fn bintree? [t1]\n  (if (coll? t1)\n    (and\n      (= 3 (count t1))\n      (-> t1 first coll? not)\n      (bintree? (nth t1 1))\n      (bintree? (last t1)))\n    (not= false t1))) ; why?", "problem": 95, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn bin-tree? [col]\n  (if-not (= 3 (count col))\n    false\n    (let [[_ l r] col childrn [l r]]\n      (and\n        (not-any? false? col)\n        (every? bin-tree? (filter coll? childrn))))))", "problem": 95, "user": "5127e504e4b03a34742b4302"}, {"code": "(fn is-btree? [t]\n(or\n  (nil? t)\n  (and\n    (or (seq? t) (vector? t))\n    (= (count t) 3)\n    (is-btree? (second t))\n    (is-btree? (nth t 2)))))", "problem": 95, "user": "50aab057e4b056ee0193586b"}, {"code": "(fn bfn [branch] (and (coll? branch) (= 3 (count branch)) (if (not (coll? (nth branch 1))) (not= false (nth branch 1)) (bfn (nth branch 1))) (if (not (coll? (nth branch 2))) true (bfn (nth branch 2)))))", "problem": 95, "user": "4e823f41535db62dc21a62c8"}, {"code": "(fn is-tree [xs]\n  (or\n   (nil? xs)\n   (and\n    (coll? xs)\n    (= 3 (count xs))\n    (is-tree (nth xs 1))\n    (is-tree (nth xs 2)))))", "problem": 95, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn bb [x] \n\n\n\n(if (or (= false ((fn aa [x] (if (not= (count x) 3)\n             false\n             (map #(if (or (= % '()) (= % false)) false \n                (if (coll? %)(aa %) true)) (rest x))\n             )\n  ) x)) (some false? (flatten ((fn aa [x] (if (not= (count x) 3)\n             false\n             (map #(if (or (= % '()) (= % false)) false \n                (if (coll? %)(aa %) true)) (rest x))\n             )\n  ) x)))) false true)\n              \n              \n              )", "problem": 95, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn isbin [[v l r :as tree]]\n  (and\n   (= 3 (count tree))\n   v\n   (if (coll? l) (isbin l) (nil? l))\n   (if (coll? r) (isbin r) (nil? r))))", "problem": 95, "user": "4dada426c9a9d6ed2a99dc57"}, {"code": "(fn [t]\n  (letfn [(node? [n] (and (sequential? n)\n                          (= 3 (count n))\n                          (every? #(or (node? %) (nil? %))\n                                  (rest n))))]\n    (node? t)))", "problem": 95, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [t]\n  ( (fn ok? [x]\n      (cond\n       (nil? x) true\n       (not (coll? x)) false\n       (= 3 (count x)) (and (ok? (second x)) (ok? (last x)))\n       :else false\n       )) t))", "problem": 95, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn isbin [tree](if (or (seq? tree) (vector? tree) (= tree nil)) (let [balanced (= 3 (count tree)) leaf (= tree nil)](do (if-not (or balanced leaf) false (if leaf true (and (isbin (nth tree 1)) (isbin (nth tree 2))))))) false))", "problem": 95, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn  is-tree? [xs]\n  (if (= 3 (count xs)) \n    (let [value (first xs)\n          left (second xs)\n          right (last xs)]\n      (cond \n       (and (not (nil? value)) (not (coll? value)) (nil? left) (nil? right)) true\n       (and (not (nil? value)) (not (coll? value)) (coll? left) (nil? right)) (is-tree? left)\n       (and (not (nil? value)) (not (coll? value)) (coll? right) (nil? left)) (is-tree? right)\n       (and (not (nil? value)) (not (coll? value)) (coll? left) (coll? right)) (and (is-tree? left) (is-tree? right))\n       :else false))\n    false))", "problem": 95, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn tree? [s]\n  (if (sequential? s)\n  \t(if-not (= (count (seq s)) 3) false\n   \t\t(if-not (or (nil? (second s)) (sequential? (second s))) false\n  \t\t\t(every? true? (map tree? s))))  true))", "problem": 95, "user": "511618b1e4b0d4f670fd2fdf"}, {"code": "(fn is-tree [t] (if (nil? t) true\n                  (and (coll? t)\n                       (= (count t) 3)\n                       (is-tree (second t))\n                       (is-tree (nth t 2)))))", "problem": 95, "user": "50fac9e3e4b07934dda8b0d1"}, {"code": "(fn f [x] (if (sequential? x) (and (= 3 (count x)) (let [[_ l r] x] (and (f l) (f r)))) (nil? x)))", "problem": 95, "user": "513edd13e4b051389b345b39"}, {"code": "(fn tree? [n]\n  (or (nil? n)\n    (and (coll? n)\n      (= 3 (count n))\n      (every? tree? (rest n)))))", "problem": 95, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn bt [tree]\n  (cond\n   (nil? tree) true\n   (false? tree) false\n   (not= (count (rest tree)) 2) false\n   :else (and (bt (second tree)) (bt (second (rest tree))))))", "problem": 95, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn isbin[x]\n  (if (nil? x) true\n    (if (not (sequential? x)) false\n      (if (not= (count x) 3) false\n        (and (isbin (last x)) (isbin (last (butlast x))))))))", "problem": 95, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn chk [lst]\n\n  (let [[v lc rc & more] lst]\n  (and  ( not (nil? v))\n       (if (coll? lc) (chk lc) (not (false? lc)))\n       (if (coll? rc) (chk rc) (not (false? rc)))\n       (not more)\n       (= (count lst) 3)\n  )\n)\n  )", "problem": 95, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn check-tree [node] (cond\n                       (not (coll? node)) (nil? node)\n                       (not (= 3 (count node))) false\n                       :else (and (check-tree (nth node 1)) (check-tree (nth node 2)))))", "problem": 95, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn check [tree]\n  (if (sequential? tree)\n    (if (= 3 (count tree))\n      (every? true? (map check tree))\n      false)\n    (if (= false tree) false true)))", "problem": 95, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn bintree? [s] (cond (nil? s) true\n                       (not (coll? s)) false\n                       (not= 3 (count s)) false\n                       (and (bintree? (second s))\n                            (bintree? (last s))) true\n                       :else false\n                            ))", "problem": 95, "user": "513bb7a6e4b04402f587b77d"}, {"code": "(fn tree?[s]\n    (if (nil? s)\n        true\n      (and (sequential? s)\n           (= (count s) 3)\n           (tree? (nth s 1))\n           (tree? (nth s 2)))))", "problem": 95, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [tree] (letfn\n             [(tree?\n               [node]\n               (if (coll? node)\n                 (if (= 3 (count node))\n                   (let [[v l r] node] (and v (tree? l) (tree? r)))\n                   false)\n                 (nil? node)))]\n             (tree? tree)))", "problem": 95, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn bin-tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (not (sequential? (first node)))\n           (bin-tree? (nth node 1))\n           (bin-tree? (nth node 2)))))", "problem": 95, "user": "5126dbabe4b083bb8f88cf0e"}, {"code": "(fn is[t]\n  (if (nil? t)\n    true\n    (if (coll? t)\n      (let [x (rest t)]\n        (let [[f,s] [(first x) (second x)]]\n          (and (= 3 (count t)) (is f) (is s))\n        )\n      )\n      false\n      )\n  )\n)", "problem": 95, "user": "513f53c6e4b051389b345b40"}, {"code": "(fn valid-tree? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (valid-tree? (second tree)) (valid-tree? (nth tree 2)))))", "problem": 95, "user": "51430fb2e4b0c172af7558ce"}, {"code": "(fn tree? [t] (or (nil? t) (and (coll? t) (= 3 (count t)) (every? tree? (rest t)))))", "problem": 95, "user": "4ff01fa9e4b0678c553fc321"}, {"code": "(fn binary-tree? [x]\n  (and x\n       (= (count x) 3)\n       (let [[node l r] x]\n         (and (not (nil? node))\n              (or (nil? l) (binary-tree? l))\n              (or (nil? r) (binary-tree? r))))))", "problem": 95, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn bt? [[v ch1 ch2 :as t]]\n  (let [check-child #(or (nil? %) (and (sequential? %) (bt? %)))]\n    (and\n     (= 3 (count t))\n     (check-child ch1)\n     (check-child ch2))))", "problem": 95, "user": "5117c31ee4b0e0897831a60c"}, {"code": "(fn c[[_ l r :as n]] (let [x #(or (nil? %) (and (coll? %) (c %)))] (and (= (count n) 3) (x l) (x r))))", "problem": 95, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn binary? [nodes]\n\t  (= 3 (count (reduce #(cond\n\t\t\t\t(nil? %2) (conj %1 true )\n\t\t\t\t(keyword? %2) (conj %1 true)\n\t\t\t\t(number? %2) (conj %1 true)\n\t\t\t\t(seq? %2) (if (binary? %2)\n\t\t\t\t\t      (conj %1 true))\n\t\t\t\t(vector? %2) (if (binary? %2)\n\t\t\t\t\t      (conj %1 true))\n\t\t\t\t:else %1)  [] nodes))))", "problem": 95, "user": "5016ac54e4b052339a490e7b"}, {"code": "(fn istree? [t] \n      (if (= 3 (.size t))\n        (reduce #(and % %2)(map #(if (sequential? %) (istree? %) (if (nil? %) true %)) t))\n        false))", "problem": 95, "user": "50e7dd5de4b077ad597af36b"}, {"code": "(fn b [t]\n  (let [l (nth t 1 false)\n        r (nth t 2 false)]\n    (and (= 3 (count t))\n         (if (sequential? l) (b l) (nil? l))\n         (if (sequential? r) (b r) (nil? r)))))", "problem": 95, "user": "513dcc1ce4b0825f97f7f964"}, {"code": "(fn t [a] \n  (or \n   (nil? a)\n   (and\n    (coll? a)\n    (= 3 (count a))\n    (t (second a))\n    (t (nth a 2))\n    )\n   )\n  )", "problem": 95, "user": "51037468e4b00c483ae17702"}, {"code": "(fn is-tree [x] \n  (if (sequential? x)  \n    (and \n        (= 3 (count x)) \n        (and (is-tree (fnext x)) (is-tree (first (nnext x))))\n    )   \n    (not= x false)\n  )\n)", "problem": 95, "user": "5158bba4e4b059418b97f0ab"}, {"code": "(fn f [x] (if (coll? x) (if (= 3 (count x)) (and (f (second x)) (f (last x))) false) (= nil x)))", "problem": 95, "user": "514d398ee4b019235f6c0583"}, {"code": "(fn pr95\n\t[t] (if (and (coll? t) (= (count t) 3))\n\t\t (let [[v l r] t]\n\t\t   (and (pr95 l) (pr95 r)))\n\t       (nil? t)))", "problem": 95, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn f[c]\n  (if (sequential? c)\n    (if (= (count c) 3)\n      (let [[one two three] c] \n        (and (f one) (f two) (f three)))\n      false)\n    (not (false? c))))", "problem": 95, "user": "4e58ef07535d8a8b8723a299"}, {"code": "(fn v [[x l r :as s]] \n  (and (= 3 (count s))\n       (every? #(or (nil? %) (and % (v %))) [l r])))", "problem": 95, "user": "4f5d0f25e4b0030a34fb2b33"}, {"code": "(fn t[n] (if (nil? n) true (and (coll? n) (= 3 (count n)) (t (second n)) (t (last n)))))", "problem": 95, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn [coll]\n  (odd? (count (filter #(not= false %) (flatten coll)))))", "problem": 95, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn tr? [a]\n  (if (coll? a)\n    (if (= (count a) 3)\n      (let [[v l r] a]\n        (if (and (nil? l) (nil? r))\n          true\n          (and (tr? l) (tr? r)) ))\n     false)\n    (nil? a)))", "problem": 95, "user": "5150a7d7e4b03e678e393abb"}, {"code": "(fn tree? [t]\n    (cond (nil? t) true\n          (coll? t) (and (= (count t) 3)\n                         ((complement coll?) (first t))\n                         (tree? (second t))\n                         (tree? (last t)))\n          :else false))", "problem": 95, "user": "5125d963e4b05d10e3e395fe"}, {"code": "(fn _ [c]\n  (and\n   (= (count c) 3)\n   (if (sequential? (second c)) (_ (second c)) (nil? (second c)))\n   (if (sequential? (last c)) (_ (last c)) (nil? (last c)))))", "problem": 95, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [s] (letfn [(binary-tree? [s]\n\t(and\n\t\t(= (count s) 3)\n\t\t(let [a (second s) b (last s)]\n\t\t\t(and\n\t\t\t\t(or\n\t\t\t\t\t(nil? a)\n\t\t\t\t\t(and \n\t\t\t\t\t\t(sequential? a)\n\t\t\t\t\t\t(binary-tree? a)))\n\t\t\t\t(or\n\t\t\t\t\t(nil? b)\n\t\t\t\t\t(and \n\t\t\t\t\t\t(sequential? b)\n\t\t\t\t\t\t(binary-tree? b)))))))]\n          (binary-tree? s)))", "problem": 95, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn f [l] (if (and (coll? l) (= 3 (count l) ))\n\t     (let [[a b c] l]    (and (or (nil? b) (f b)) (or (nil? c) (f c))))\n               false))", "problem": 95, "user": "4ff2ff7ce4b0678c553fc342"}, {"code": "(fn f [r] (if (= r nil) true\n            (if (and (sequential? r)(= 3 (count r)))\n              (and (f (second r)) (f (last r))) false)\n              ))", "problem": 95, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn tr [t] \n  (cond \n   (or (seq? t) (vector? t)) (and (= (count t) 3) (every? tr (rest t)))\n   (nil? t) true\n    :else false))", "problem": 95, "user": "504e108ce4b078edc5f593b3"}, {"code": "(fn is-tree [xs]\n      (if (sequential? xs)\n        (and (= 3 (count xs))\n             (not (sequential? (first xs)))\n             (is-tree (second xs))\n             (is-tree (nth xs 2)))\n        (not (false? xs))))", "problem": 95, "user": "50f48298e4b004d364930527"}, {"code": "(fn checkTree [node]\n  (or (nil? node)\n      (and (coll? node)\n   \t       (= 3 (count node))\n           (let [[v l r] node]\n             (and\n               ((complement nil?) v)\n               (checkTree l)\n               (checkTree r))))))", "problem": 95, "user": "51533ecde4b0252ac4b16619"}, {"code": "(letfn [(istree [t]\n                (if (nil? t)\n                  true\n                  (if (coll? t)\n                    (and (= 3 (count t))\n                         (istree (nth t 1))\n                         (istree (nth t 2)))\n                    false)\n                )\n                )]\n  istree)", "problem": 95, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn checkTree\n  [tree]\n  (if\n    (or (-> tree coll? not) (not= (count tree) 3))\n    (if (not= tree nil) false true)\n    (and\n     (checkTree (nth tree 1))\n     (checkTree (nth tree 2))\n    )\n  )\n)", "problem": 95, "user": "5162757ee4b03cfa3774b3fe"}, {"code": "(fn binary_tree [sq]\n  (or (nil? sq)\n    (and\n      (sequential? sq)\n      (= (count sq) 3)\n      (not (nil? (first sq)))\n      (binary_tree (second sq))\n      (binary_tree (nth sq 2)))))", "problem": 95, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn [y]\n  (let [isNode? (fn [x]\n                  (or (nil? x)\n                      (and (coll? x)\n                           (= 3 (count x)))))]\n    (every? isNode? (tree-seq isNode? next y))))", "problem": 95, "user": "4f03f197535dcb61093f6b84"}, {"code": "#(= 1 (- (count ((group-by nil? (flatten %)) true)) (count ((group-by nil? (flatten %)) false))))", "problem": 95, "user": "515e8ce2e4b049add99a053d"}, {"code": "(fn btree [root]\n                 (let [ t (type root) ]\n                   (if (or (= t clojure.lang.Keyword)\n                           (= t java.lang.Integer)\n                           (= t java.lang.Long)                           \n                           (= t nil))\n                     true\n                     (if (and (or (= t clojure.lang.PersistentVector)\n                                  (= t clojure.lang.PersistentList))\n                          \t  (= 3 (count root))\n                              (btree (first root))\n                              (btree (second root))\n                              (btree (nth root 2)))\n                       true\n                       false))))", "problem": 95, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn binary-tree? [c] \n  (and \n    (= (count c) 3)\n    (letfn \n      [(binary-child? [n] \n         (if (sequential? n) \n           (binary-tree? n) \n           (nil? n)))]\n      (and \n        (binary-child? (second c)) \n        (binary-child? (last c))))))", "problem": 95, "user": "51592b81e4b0394f658fe22c"}, {"code": "(fn bin-tree? [tree]\n  (if (and (sequential? tree) (= 3 (count tree)))\n      (reduce #(and (bin-tree? %2) %1) true (rest tree))\n      (nil? tree)))", "problem": 95, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn bitree [tree]\n  (and\n    (not-any? false? tree)\n    (not (nil? (first tree)))\n    (or (nil? (second tree))\n      (bitree (second tree)))      \n    (or (nil? (last tree))\n      (bitree (last tree)))\n    (= (count tree) 3)\n   )   \n   )", "problem": 95, "user": "51427a8be4b0b50abeb46b37"}, {"code": "(fn t? [t]\n     (cond (nil? t) true\n       (not (sequential? t)) false\n       (not (= 3 (count t))) false\n       :else (and (t? (second t)) (t? (nth t 2)))))", "problem": 95, "user": "514d8084e4b019235f6c0588"}, {"code": "(fn tree? [coll]\n  (if-not (and (coll? coll) (= (count coll) 3))\n    false\n    (let [l (second coll)\n          r (nth coll 2)]\n      (and (or (nil? l) (tree? l))\n           (or (nil? r) (tree? r))))))", "problem": 95, "user": "5175616ae4b0dea9bbfba576"}, {"code": "(fn [tree] (loop [t (vector tree) fail false]\n\t(if (or fail (empty? t))\n\t\t(not fail)\n\t\t(let [p (first t)\n\t\t\tr (rest t)\n\t\t\tflag (and (coll? p) (or (not= 3 (count p)) (some false? p)))]\n\t\t\t(println t)\n\t\t\t(recur (if (coll? p) (concat r (filter coll? p)) r) flag)))))", "problem": 95, "user": "50fe91c1e4b03cd852b4e84e"}, {"code": "(fn f [x] (cond (nil? x) true\n                (not (sequential? x)) false\n                (not= (count x) 3) false\n                :else (and (f (nth x 1)) (f (nth x 2)))))", "problem": 95, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn tree? [tree]\n  (and (coll? tree)\n       (= (count tree) 3)\n       (every? #(or (nil? %) (tree? %)) (rest tree))))", "problem": 95, "user": "4f89d489e4b033992c121c7e"}, {"code": "(fn binary-tree? \n  [t]\n  (letfn [(node? [x] \n                 (and (coll? x)\n                      (= 3 (count x))\n                      (not (nil? (first x)))))\n          (check-tree [x] \n               (cond\n                (nil? x)  true\n                (node? x) (and (check-tree (nth x 1))\n                               (check-tree (nth x 2)))\n                :else     false))]\n    (check-tree t)))", "problem": 95, "user": "517a025ce4b01aacecbecbe6"}, {"code": "(fn f [t]\n  (boolean (or (nil? t)\n      (when-let [[v t1 t2] t]\n        (and (= 3 (count t)) (f t1) (f t2))))))", "problem": 95, "user": "50b668dde4b08fb537db98f2"}, {"code": "(letfn [(binary-tree? [tree] (if (nil? tree) true\n                      (and (coll? tree) (-> tree count (= 3)) \n                                  (let [subtrees (next tree)] (and (-> subtrees first binary-tree?)  \n                                                                   (-> subtrees second binary-tree?) ) )\n                                  )))] binary-tree?)", "problem": 95, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn bt [t]\n  (if (not (or (nil? t) (sequential? t))) false\n  (or (nil? t) (and (= (count t) 3) (bt (nth t 1)) (bt (nth t 2))))))", "problem": 95, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn tree? [[value left right :as t]]\n  (and\n   (= (count t) 3)\n   (every?\n    #(or\n      (nil? %)\n      (and (coll? %) (tree? %)))\n    [left right])))", "problem": 95, "user": "5173726be4b098276e74652c"}, {"code": "(fn check-bt? [coll]\n  (if (or (not (sequential? coll)) (not= 3 (count coll)))\n    false\n    (and (if (nil? (second coll)) true (check-bt? (second coll)))\n         (if (nil? (last coll)) true (check-bt? (last coll))))))", "problem": 95, "user": "51780f88e4b03d69594194c9"}, {"code": "; a list is automatically a composite node.\n; tree?\n;\thas-2-children?\n;\tis each of its children a valid node (composite or leaf)?\n(fn composite-node? [l]\n  (letfn [(collection? [l]\n                       (or \n                        (list? l) \n                        (map? l) \n                        (vector? l)))\n          (valid-node? [l] \n                       (if (collection? l) \n                         (composite-node? l) \n                         (= nil l)))]\n    (let [item-count (count l)]\n      (and (collection? l)\n           (= 3 item-count)\n           (valid-node? (nth l 1))\n           (valid-node? (nth l 2))))))", "problem": 95, "user": "517531c6e4b07031762f2eea"}, {"code": "(fn tr [x] (if (and (sequential? x) (= 3 (count x))) (and (tr (nth x 1)) (tr (nth x 2))) (nil? x)))", "problem": 95, "user": "5134973ce4b0230e9f713b42"}, {"code": "(fn btree? [node] \n  (if (or (nil? node)\n          (and \n            (sequential? node)\n            (= (count node) 3)\n            (btree? (second node))\n            (btree? (last node))))\n    true\n    false))", "problem": 95, "user": "5141bc82e4b02fd87f5064c5"}, {"code": "(fn f [t]\n  (if (coll? t)\n    (if (= 3 (count t))\n      (and (f (second t))\n           (f (last t)))\n      false)\n    (if (= t false)\n      false\n      true)))", "problem": 95, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn binary? [s]\n  (if (coll? s)\n    (let [[_ l r] s]\n      (and (= 3 (count s)) (binary? l) (binary? r)))\n    (nil? s)))", "problem": 95, "user": "51740b65e4b0d277d717bc67"}, {"code": "(fn __ [s]\n  (if (sequential? s)\n    (and (= (count s) 3)\n         (__ (first s))\n         (__ (second s))\n         (__ (last s)))\n    (not= false s)))", "problem": 95, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn bt? [t]\n  (if (coll? t)\n    (and (= 3 (count t))\n          (bt? (nth t 1))\n          (bt? (nth t 2)))\n    (if (nil? t) true false)))", "problem": 95, "user": "50b1d166e4b03ea880433554"}, {"code": "(fn [t] \n  (every? #(if (coll? %) \n             (and (= (count %) 3) \n                  (or (coll? (nth % 1)) (nil? (nth % 1))) \n                  (or (coll? (nth % 2)) (nil? (nth % 2)))\n                  )\n             true) \n          (tree-seq coll? identity t)))", "problem": 95, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn f [xs]\n  (or (nil? xs)\n      (and (coll? xs)\n           (= 3 (count xs))\n           (f (nth xs 1))\n           (f (nth xs 2)))))", "problem": 95, "user": "518696c1e4b0c40be512d708"}, {"code": "#(letfn [(tree [x] \n            (cond  \n             (and (coll? x) (= (count x) 3)) (and (tree (first x)) (tree (second x)) (tree (last x)))\n             (and (not (coll? x)) (not (false? x)) ) true \n             :else false))]\n    (tree %))", "problem": 95, "user": "5047782ce4b0371827a27bc2"}, {"code": "(fn tree-check [x] \n  (if \n    (and x (first x) (= (count x) 3))\n        (every? #(if (nil? %) true (tree-check %)) (rest x))\n    false))", "problem": 95, "user": "50c6fad1e4b00bb60fe0c52d"}, {"code": "(fn [node]\n  (loop [check [node]]\n    (cond\n      (empty? check) true\n      (sequential? (first check))\n        (if (= (count (first check)) 3)\n          (recur (concat (rest check) (rest (first check))))\n          false)\n      :else \n       (if (nil? (first check))\n         (recur (rest check))\n         false))))", "problem": 95, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn binary? [ys] (if (nil? ys) true (if (or (not (sequential? ys)) (empty? (drop 2 ys))) false\n                  (let [[h x y & xs] ys] (and (binary? x) (binary? y) (empty? xs))))))", "problem": 95, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn tree? [coll]\n  (or (nil? coll)\n      (and \n       (sequential? coll)\n       (= 3 (count coll))\n       (not (sequential? (first coll)))\n       (tree? (second coll))\n       (tree? (last coll)))))", "problem": 95, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn bin-tree? [[x & xs]]\n  (if (= 2 (count xs))\n    (every? #(or (nil? %) (and (coll? %) (bin-tree? %))) xs)\n    false))", "problem": 95, "user": "517b59b8e4b0925c997201d0"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "4ef2eb4d535dced4c769f226"}, {"code": "(fn istree? [s]\n  (if (or\n        (not (coll? s)) \n    \t(not (= (count s) 3))\n       )  \n    false\n    (let [[node left right] s]\n      (cond\n       (and \n        (nil? left) \n        (nil? right)) true\n     \n      \n       (nil? left) (istree? right);;drill\n       (nil? right) (istree? left);;drill\n       \n       \n       (not (coll? left)) false\n       (not (coll? right)) false\n       \n       :else (and \n        (istree? left) \n        (istree? right)\n       )\n      )\n     )\n  )\n)", "problem": 95, "user": "4fb03cf4e4b081705acca262"}, {"code": "(fn ? [t]\n  (or\n   (nil? t)\n   (and (coll? t)\n           (= (count t) 3)\n           (every? ? (rest t)))))", "problem": 95, "user": "51805d22e4b0e3fc13e244df"}, {"code": "(fn xx? [n]\n  (or (nil? n)\n      (and (coll? n)\n\t       (= 3 (count n))\n           (every? xx? (rest n)))))", "problem": 95, "user": "4f4ec77ae4b03ad3f0c10cd0"}, {"code": "(fn f [s] \n   (cond \n     (nil? s) true\n     (and (sequential? s) (= 3 (count s)))\n       (and \n        (f (second s)) \n        (f (last s)))\n     :else false))", "problem": 95, "user": "517bc969e4b07ef0e56148d0"}, {"code": "(fn tree? [tree]\n  (cond (not (sequential? tree)) (if (nil? tree) true false)\n        (not= 3 (count tree)) false\n        true (and (tree? (second tree)) (tree? (nth tree 2)))))", "problem": 95, "user": "501d34f6e4b066e56b9d0b1e"}, {"code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "4e14b925535d04ed9115e7df"}, {"code": "(fn binTree? [[val col1 col2 :as more]]\n  (cond\n    (not (= 3 (count more))) false\n    (and (or (and (sequential? col1) (= 3 (count col1)) (binTree? col1)) (nil? col1)) \n    (or (and (sequential? col2) (= 3 (count col2)) (binTree? col2)) (nil? col2)) ) true\n  :else false\n    )\n  )", "problem": 95, "user": "4ec4d723535dcc7ae8597d65"}, {"code": "(fn binary-tree? [xs]\n  (if (nil? xs)\n    true\n    (if (not (sequential? xs))\n      false\n      (if (not= 3 (count xs))\n        false\n        (and (binary-tree? (second xs))\n             (binary-tree? (last xs)))))))", "problem": 95, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [x]\n  (letfn [(collnotempty [x] (and (coll? x) (not (empty? x))))\n          (nil-coll-nonempty? [x] (or (nil? x) (collnotempty x)))\n          (treelike [x] (and (= (count x) 3)\n                             (nil-coll-nonempty? (nth x 1))\n                             (nil-coll-nonempty? (nth x 2))))]\n    (loop [curr x]\n      (cond\n       (and (treelike curr) (not (empty? curr))) (recur (first (filter collnotempty curr)))\n       (empty? curr) true\n       :else false))))", "problem": 95, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn tree \n  ([x] (\n   if-not (= (count x) 3) false\n   (tree (nth x 0) (nth x 1) (last x))\n  ))\n ([val left right]\n   (\n    if (coll? val) \n    false\n     (and (if (coll? left) (tree left) (nil? left) )\n          (if (coll? right) (tree right) (nil? right) ))\n    ) \n )\n)", "problem": 95, "user": "5191045ee4b0f8ef0be96bf3"}, {"code": "(fn tree? [t]\n  (or\n    (nil? t)\n    (and\n      (coll? t)\n      (= (count t) 3)\n      (let [[val left right] t]\n        (and\n          (not (coll? val))\n          (tree? left)\n          (tree? right)\n        )\n      )\n    )\n  )\n)", "problem": 95, "user": "51473a70e4b0d520409ed394"}, {"code": "(fn binary-tree? [t]\n  (if (= t nil)\n    true\n    (and (coll? t)\n         (= (count t) 3)\n         (every? binary-tree? (rest t)))))", "problem": 95, "user": "51460e4ce4b04ef915e37314"}, {"code": "(fn f [tree]\n  (if (or (list? tree) (vector? tree))\n    (if (= (count (rest tree)) 2)\n      (and (f (nth tree 1 false))\n           (f (nth tree 2 false)))\n      false)\n    (if (= tree false)\n      false\n      true)))", "problem": 95, "user": "51750cd4e4b07031762f2ee5"}, {"code": "(fn btree? [a]\n    (if (coll? a)\n        (let [[x y z] a] (and (= (count a) 3)(btree? y) (btree? z)))\n        (nil? a)))", "problem": 95, "user": "5097cfcbe4b00ad8bab4e977"}, {"code": "(fn bitree [t] \n  (cond\n   (nil? t) true\n   (= (coll? t) false) false\n   (not= (count t) 3) false\n   (and (= (coll? (first t)) false) (bitree (second t)) (bitree (last t))) true\n   :else false\n   )\n  )", "problem": 95, "user": "519b7d76e4b02a926d9a436e"}, {"code": "#(even? (count (remove false? (flatten (rest %)))))", "problem": 95, "user": "4dda44f2535d02782fcbe9f1"}, {"code": "(fn btree? [coll]\n  (or (nil? coll)\n      (and coll\n           (= 3 (count coll))\n           (every? btree? (rest coll)))))", "problem": 95, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn tree? [tree]\n  (let [coll? #(or (seq? %) (vector? %))\n        tree-or-nil? #(if (coll? %) (tree? %) (nil? %))]\n    (and (-> (first tree) coll? not) (= 3 (count tree)) (tree-or-nil? (second tree)) (tree-or-nil? (last tree)))))", "problem": 95, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn tree? [x]\n        (if (coll? x)\n          (if (not= (count x) 3)\n            false\n            (every? tree? x))\n          (not (false? x))))", "problem": 95, "user": "51a8f0c6e4b08d8ec191b821"}, {"code": "(fn is-tree? [tree]\n   (cond (nil? tree) true\n         (false? tree) false\n         (not= 3 (count tree)) false\n         :otherwise\n         (let [[v & children] tree]\n           (if (every? nil? children) true\n               (every? is-tree? children)))))", "problem": 95, "user": "4f409e29e4b0e243712b1fb6"}, {"code": "(fn tree? [t]\n  (cond\n    (nil? t)\n    true\n\n    (false? t)\n    false\n         \n    (or\n      (not= (count t) 3)\n      (empty? t))\n    false\n\n    :else\n    (let [[val left right] t]\n      (and (tree? left)\n           (tree? right)))))", "problem": 95, "user": "4db6d993535d1e037afb2180"}, {"code": "(fn ! [node] \n  (and (coll? node)\n       (= 3 (count node))\n       (every? #(or (nil? %1) (! %1)) (drop 1 node))))", "problem": 95, "user": "51aa2b4fe4b04e3dc0c27b21"}, {"code": "(fn tree? [a]\n  (cond (nil? a) true\n        (not (sequential? a)) false\n        (not= (count a) 3)  false\n        :else (and (tree? (second a))\n                   (tree? (last a) ))))", "problem": 95, "user": "5183f5d7e4b02826a645f393"}, {"code": "(fn tree? [seq]\n  (and\n   (coll? seq)\n   (= (count seq) 3)\n   (every? #(or (nil? %) (tree? %))\n           (rest seq))))", "problem": 95, "user": "4fbf2818e4b081705acca317"}, {"code": "(fn tree? [s]\n  (or (nil? s) (and (sequential? s)  (= 3 (count s)) (tree? (second s)) (tree? (nth s 2)))))", "problem": 95, "user": "5142e808e4b0c172af7558c9"}, {"code": "(fn bintree? [node]\n  (cond \n   (nil? node) true\n   (or (not (coll? node)) (not= (count node) 3)) false\n   :else\n   (let [[value left right] node]\n     (and (bintree? left) (bintree? right))\n     )))", "problem": 95, "user": "51a7b4fee4b0da5f497bde8b"}, {"code": "(fn tree [x]\n  (or (nil? x)\n      (and (or (vector? x) (list? x))\n       \t   (= 3 (count x))\n           (tree (nth x 1))\n           (tree (nth x 2)))))", "problem": 95, "user": "50a2f901e4b029e8bace362a"}, {"code": "(fn is-tree [node]\n  (cond (nil? node) true\n        (and (sequential? node) (= 3 (count node))) (let [[_ l r] node] (and (is-tree l) (is-tree r)))\n        :else false))", "problem": 95, "user": "51040eb2e4b0432126ba9bb4"}, {"code": "(fn tr [c] (if (nil? c)  true\n             (and c (= 3 (count c))\n                (tr (second c)) (tr (last c)))\n            )\n  )", "problem": 95, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [x] (and (= 3 (count x)) (not= '() (last x)) (every? nil? (remove sequential? (tree-seq sequential? rest x)))))", "problem": 95, "user": "50b65966e4b0a86f8358ca6c"}, {"code": "(fn b? [t] (if (coll? t)\n             (and (= 3 (count t)) (every? b? (rest t)))\n             (nil? t)))", "problem": 95, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn tree [[_ l r :as a]]\n  (and\n    (= 3 (count a))\n    (if (sequential? l)\n      (tree l)\n      (nil? l))\n    (if (sequential? r)\n      (tree r)\n      (nil? r))))", "problem": 95, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn [root] (every? #(or (nil? %) (and (sequential? %) (= 3 (count %))))\n                   (tree-seq #(and (sequential? %)\n                                   (= (count %) 3))\n                             rest root)))", "problem": 95, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn b [y]\n   (if (or (list? y )(vector? y))\n     (if (= 3 (count y))\n       (if (false? (nth y 1))\n         false\n       (every? b y)\n         )\n       false\n       )\n     (not (false? y))    \n     )\n   )", "problem": 95, "user": "518c5236e4b087e178201de0"}, {"code": "(fn bt? [t] (if (nil? t) true\n              (and (sequential? t) (= (count t) 3) (bt? (second t)) (bt? (nth t 2)))))", "problem": 95, "user": "51bf4560e4b013aa0d74b817"}, {"code": "(fn tree? [x]\n   (and \n    (coll? x)\n    (= 3 (count x))\n    (every? #(or \n              (nil? %)\n              (tree? %)) (rest x))))", "problem": 95, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn btree? [x] (if (coll? x) (and (= 3 (count x)) (every? btree? (rest x))) (nil? x)))", "problem": 95, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "(fn is-binary-tree? [n]\n  (if (coll? n)\n    (and\n      (= 3 (count n))\n      (not (seq? (first n)))\n      (every? is-binary-tree? n))\n    (not (false? n))))", "problem": 95, "user": "51057b2be4b06d28cacc92e8"}, {"code": "(fn tree? [s]\n  (cond (nil? s) true\n   \t\t(not (coll? s)) false\n        (not= 3 (count s)) false\n        (and (-> s second nil?) (-> s (nth 2) nil?)) true\n        :else (and (-> s second tree?) (-> s (nth 2) tree?))))", "problem": 95, "user": "51baff1be4b0fe3ecfb46443"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= (count t) 3)\n           (not (sequential? (first t)))\n           (tree? (second t))\n           (tree? (nth t 2)))))", "problem": 95, "user": "51672d15e4b079759a74a5e7"}, {"code": "(fn binary-tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (binary-tree? (second t))\n           (binary-tree? (nth t 2)))))", "problem": 95, "user": "51789dfae4b03d69594194d7"}, {"code": "(fn [t]\n    (=\n      (tree-seq sequential? rest t)\n      (tree-seq #(and (sequential? %) (= 3 (count %))) (fn [x] (filter #(or (and (sequential? %) (= (count %) 3)) (nil? %)) (rest x))) t)\n      ))", "problem": 95, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn t [c]\n   (or \n     (and\n       (coll? c)\n       (= (count c) 3)\n       (t (second c))\n       (t (last c)))\n     (nil? c)))", "problem": 95, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn t [n]\n  (or\n   \t(nil? n)\n    (and\n      (sequential? n)\n      (= (count n) 3)\n      (every? t (drop 1 n)))))", "problem": 95, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn [s] (not-any? #(or (= % \\g) (= % false)) (flatten (tree-seq coll? #(if (= (count %) 3) % \"g\") s))))", "problem": 95, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "(fn bt? [t]\n  (if (not (sequential? t)) \n     (if (= t false)\n       false\n       true)\n\t    (and (= 3 (count t))\n\t         (bt? (second t))\n\t         (bt? (last t))))\n    )", "problem": 95, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn ? [n]\n    (or (nil? n)\n        (and (coll? n)\n             (= 3 (count n))\n             (every? ? (rest n)))))", "problem": 95, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn f [sq]\n   (let [l (rest (remove #(nil? %) sq))]\n     (cond (some empty? l) false\n      (some false? (flatten l)) false\n      (and (= 3 (count sq)) (not (empty? l))) (= 1 (count (distinct (map f l))))\n      (and (= 3 (count sq)) (empty? l)) true\n      :else false)))", "problem": 95, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn f [x]\n  (if (sequential? x)\n    (and (= 3 (count x))\n         (f (second x))\n         (f (nth x 2)))\n    (nil? x)))", "problem": 95, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn is-tree [x] (or (nil? x) (and\n    (sequential? x)\n    (= 3 (count x))\n    (is-tree (nth x 1))\n    (is-tree (nth x 2)))))", "problem": 95, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn checker [t]\n  (or\n    (nil? t) \n    (and\n      (coll? t)\n      (= 3 (count t))\n      (checker (second t))\n      (checker (last t)))))", "problem": 95, "user": "51beb32ae4b013aa0d74b7fd"}, {"code": "(fn [coll]\n   (let [tr (vec (flatten coll))]\n     (cond (even? (count tr)) false\n           (not (= (count (filter #(if (false? %)\n            false\n            true) tr)) (count tr))) false\n     :else true)))", "problem": 95, "user": "51cacda3e4b068dadb8f2227"}, {"code": "(fn is-tree [tree]\n  (if (nil? tree)\n    true\n    (if (or (not  (coll? tree)) (not (= 3 (count tree))))\n      false\n      (and (is-tree (second tree)) (is-tree (nth tree 2))))))", "problem": 95, "user": "51d360d1e4b099f3b6acddff"}, {"code": "#(letfn [(binary-tree? [t]\n            (letfn [(f [x] (or (nil? x) (binary-tree? x)))]\n              (and t (= 3 (count t)) (f (nth t 1)) (f (nth t 2)))))]\n    (binary-tree? %))", "problem": 95, "user": "51424cc8e4b0b50abeb46b34"}, {"code": "(fn my-tree? [xs]\n  (if (not (coll? xs))\n    (if (false? xs) false true)\n    (if (not (= (count xs) 3))\n      false\n      (every? identity (map my-tree? xs)))))\n\n;the version by chouser is more accurate\n;(fn f [t]\n;\t(if (coll? t)\n;\t\t(let [[_ a b] t]\n;\t\t\t(and (= 3 (count t)) (f a) (f b)))\n;\t(nil? t)))", "problem": 95, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn tree? [coll] (and (coll? coll) \n                      (= (count coll) 3) \n                      (every? (some-fn nil? tree?) (rest coll))))", "problem": 95, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn is-binary-tree? [tree] \n  (if (nil? tree)\n    true  \t\n    (if (and (coll? tree) (= (count tree) 3))\n   \t\t(and (is-binary-tree? (second tree)) (is-binary-tree? (last tree)))\n    \tfalse\n    )\n  )\n)", "problem": 95, "user": "51aab611e4b04e3dc0c27b2d"}, {"code": "(fn is-tree [t]\n  (if (and (not (nil? t)) (not (coll? t))) false\n  (let [[x y z] t]\n    (and\n      (or (nil? t) (= 3 (count t)))\n      (not (or (list? x) (vector? x)))\n      (or (nil? y) (is-tree y))\n      (or (nil? z) (is-tree z)))\n    )\n  )\n)", "problem": 95, "user": "51b7b521e4b0d906fcd71d3a"}, {"code": "(fn tree? [t] \n\t(cond\n\t(nil? t) true\n\t(not (sequential? t)) false\n\t(empty? t) false\n\t(= (count t) 3) (and (tree? (second t)) (tree? (last t)))\n\t:else false))", "problem": 95, "user": "51ba4482e4b0fe3ecfb4642b"}, {"code": "(fn tree? [t]\n  (and\n    (coll? t)\n    (let [[head left right :as coll] t]\n      (and\n        (= 3 (count coll))\n        (not (nil? head))\n        (or (nil? left) (tree? left))\n        (or (nil? right) (tree? right))))))", "problem": 95, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn bt? [t]\n\t(or (nil? t)\n\t\t(and (sequential? t)\n\t\t\t (= 3 (count t))\n\t\t\t (every? bt? (rest t)))))", "problem": 95, "user": "51bdc609e4b0ff155d51d2b3"}, {"code": "(fn c [n]\n   (cond (not (coll? n)) (nil? n)\n         (not= 3 (count n)) false\n         :else (and (c (second n)) (c (second (rest n))))))", "problem": 95, "user": "51e00020e4b01188f0627534"}, {"code": "(fn __ [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (__ (nth t 1))\n           (__ (nth t 2)))))", "problem": 95, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn is-binary-tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (is-binary-tree? (nth t 1))\n           (is-binary-tree? (nth t 2)))))", "problem": 95, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn b-tree? [node]  \n  (or (nil? node)\n      (and (sequential? node) \n           (= 3 (count node))\n           (let [[_ left right] node]\n             (and (or (b-tree? left))\n                  (or (b-tree? right)))))))", "problem": 95, "user": "51c8301ee4b07ef393169e4d"}, {"code": "apply (fn bt\n  ([] false)\n  ([x] false)\n  ([x y] false)\n  ([x y z] (cond\n            (and (coll? y) (coll? z)) (and (apply bt y) (apply bt z))\n             (coll? y) (apply bt y)\n             (coll? z) (apply bt z)\n             :else (and (nil? y) (nil? z))\n             ))\n  ([x y z & o] false)\n  )", "problem": 95, "user": "51ca7906e4b08b1cbd0d9487"}, {"code": "(fn tree? [x]\n  (and (coll? x)\n       (= (count x) 3)\n       (or (nil? (nth x 1)) (tree? (nth x 1)))\n       (or (nil? (nth x 2)) (tree? (nth x 2)))))", "problem": 95, "user": "516199bbe4b009fba0926e36"}, {"code": "(fn b-tree [candidate]\n  (boolean\n   (when (and (sequential? candidate)\n              (= 3 (count candidate)))\n        (let [[n l r] candidate]\n          (and (if (not (nil? l)) (b-tree l) true)\n               (if (not (nil? r)) (b-tree r) true))))))", "problem": 95, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn tree? [input]\n  (if (= input nil) true\n    (cond (or (false? input)\n              (not (= 3 (count input)))) false\n          :else (let [[rt ln rn] input]\n                  (and (not (seq? rt))\n                       (tree? ln)\n                       (tree? rn))))))", "problem": 95, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn f [t]\n   (if (coll? t)\n     (if (= 3 (count t))\n       (and (f (second t)) (f (last t)) )\n       false\n     )\n     (nil? t)\n   )\n )", "problem": 95, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn parse-tree [ xs ] \n  (cond (nil? xs) true\n        (or (not (coll? xs)) (not= (count xs) 3)) false\n        :else (and (parse-tree (second xs)) (parse-tree (last xs)))))", "problem": 95, "user": "51e1a1fae4b06a68e693eaf6"}, {"code": "(fn t [tree]\n  (if (coll? tree)\n    (if (= 3 (count tree))\n    \t(and (t (second tree)) (t (last tree)))\n    \tfalse\n    )\n    (if (nil? tree)\n      true\n      false)\n    )\n  )", "problem": 95, "user": "51da7e49e4b02ceefd947768"}, {"code": "(fn tree? [coll]\n   (cond\n    (= coll nil) true\n    (= coll false) false\n    (= 3 (count coll))\n    (do\n      (and\n       (tree? (nth coll 1 ))\n       (tree? (nth coll 2 ))\n       ))\n    :else false\n    )\n   )", "problem": 95, "user": "51d9eb05e4b02ceefd947755"}, {"code": "(fn tree? [tree]\n  (cond\n   (nil? tree) true\n   (and (coll? tree) (= 3 (count tree))) (and \n                       (tree? (nth tree 1)) \n                       (tree? (nth tree 2)))\n   :else false))", "problem": 95, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn t [[v & br]]\n    (and (= 2 (count (filter #(or (nil? %) (and % (t %))) br)))))", "problem": 95, "user": "502873a8e4b01614d1633ff8"}, {"code": "(fn b-tree?\n  [s]\n  (and (= (count s) 3)\n       (first s)\n       (every? (fn [v]\n                 (if (coll? v)\n              \t   (b-tree? v)\n                   (nil? v))) (next s))))", "problem": 95, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn t [a]\n  (if a\n    (if (and (sequential? a) (= 3 (count a)))\n      (let [[x y z] a]\n        (if (and (nil? x) (sequential? x))\n          false\n       \t  (and (t y) (t z))))\n      false)\n    (nil? a)))", "problem": 95, "user": "4e74e119535d7a570dd295bc"}, {"code": "(fn tree? [t]\n  (if (and (coll? t) (= 3 (count t)))\n    (let [[v l r] t]\n      (and (not (nil? v))\n  \t       (tree? l)\n  \t       (tree? r)))\n    (nil? t)))", "problem": 95, "user": "50d882d4e4b01f0871336e69"}, {"code": "(fn tree? [seq]\n  (cond (= seq nil) true\n        ((complement coll?) seq) false\n        (not= 3 (count seq)) false\n        true (and (tree? (nth seq 1)) (tree? (nth seq 2)))))", "problem": 95, "user": "51df825de4b01188f062752b"}, {"code": "(fn bin-tree? [coll]\n  (or (nil? coll)\n    (and (coll? coll)\n         (= (count coll) 3)\n         (bin-tree? (second coll))\n         (bin-tree? (nth coll 2)))))", "problem": 95, "user": "51cbaf14e4b08d8387cbedda"}, {"code": "(fn t [i]\n  (cond\n   (and (coll? i) (= 3 (count i)) (t (nth i 1)) (t (nth i 2))) true\n   :else (nil? i)))", "problem": 95, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn node? [v]\n              (or (nil? v)\n                  (and (sequential? v)\n                       (= 3 (count v))\n                       (every? node? (rest v)))))", "problem": 95, "user": "5046ee3ee4b03b02161376b4"}, {"code": "(fn tree?\n  [coll]\n  (or (nil? coll)\n      (and\n       (coll? coll)\n       (= 3 (count coll))\n       (tree? (nth coll 1))\n       (tree? (nth coll 2)))))", "problem": 95, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn tree [t]\n   (and (coll? t)\n        (= 3 (count t))\n        (or (nil? (second t)) (tree (second t)))\n        (or (nil? (last t)) (tree (last t)))))", "problem": 95, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn isit \n  ([a] (if (= (count a) 3)\n    (let [f (nth a 0)   s (nth a 1)   t (nth a 2)]\n       (do\n           (letfn [(sChk [v]\n                         (if (coll? v)  \n                            (isit v)\n                            (if (= v false) \n                                false\n                                true\n                            )\n                        )\n                  )]\n\t    (and\n             (sChk f)\n             (sChk s)\n             (sChk t)\n            )\n           )\n       )\n    )\n    false\n  )\n) )", "problem": 95, "user": "518aec06e4b06da86c1973c2"}, {"code": "(fn is-tree [x]\n  (letfn [(value? [n] (not (coll? n)))]\n    (if (false? x) false\n    (if (= (count x) 3)\n      (if (and (value? (first x))\n               (or (nil? (nth x 1)) (is-tree (nth x 1)))\n               (or (nil? (nth x 2)) (is-tree (nth x 2))))\n        true\n        false)\n      false))))", "problem": 95, "user": "51e0198ee4b01188f0627539"}, {"code": "(fn isbi [n]\n  (if (and (sequential? n) (= (count n) 3))\n    (let [[v l r] n]\n      (cond\n        (and (nil? l) (nil? r)) true\n        (nil? l) (isbi r)\n        (nil? r) (isbi l)\n        :else (and (isbi r) (isbi l))))\n    false))", "problem": 95, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn binary-tree? [t]\n  (or (and (coll? t)\n           (= (count t) 3)\n           (every? binary-tree? (rest t)))\n      (nil? t)))", "problem": 95, "user": "4dddff47535d08e6dec9fdd4"}, {"code": "(fn tree? [x]\n  (or\n   (nil? x)\n   (and\n    (sequential? x)\n    (= (count x) 3)\n    (not (sequential? (first x)))\n    (tree? (second x))\n    (tree? (nth x 2)))))", "problem": 95, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn tree? [ [n l r :as s] ]\n    (let [st? (fn [z]  (or (nil? z) (and (sequential? z) (tree? z))))]\n    (if (= 3 (count s))\n       (and (st? l) (st? r))\n       false)))", "problem": 95, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [x] \n  (every?\n  #(and \n    (= (count %) 3) \n    (or (= (second %) nil) (coll? (second %)))  \n    (or (= (last %) nil) (coll? (last %))))\n  (filter coll? (tree-seq coll? identity x))))", "problem": 95, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn is-binary-tree? [t]\n  (if (nil? t)\n    true\n    (if (and (coll? t)\n             (= (count t) 3))\n      (and (is-binary-tree? (second t))\n           (is-binary-tree? (last t)))\n      false)))", "problem": 95, "user": "51db0d99e4b06aa4d4669a9d"}, {"code": "(fn f [t] \n  (cond\n   (nil? t) \n   true\n   (and (coll? t) (= 3 (count t)))\n   (let [[_ a b] t]\n     (if (and (f a) (f b))\n       true\n       false))\n   :else false))", "problem": 95, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn btree? [x]\n    (if-let [[_ y z] x]\n          (if (= 3 (count x))\n                  (and (btree? y) (btree? z))\n                  false)\n          (nil? x)))", "problem": 95, "user": "514cfa27e4b019235f6c057d"}, {"code": "(fn bt? [s]\n  (if-not (= 3 (count s))\n    false\n    (letfn [(f [i xs]\n              (let [x (nth xs i)]\n                (cond (nil? x) true, (sequential? x) (bt? x), :else false)))]\n      (and (f 1 s) (f 2 s)))))", "problem": 95, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(letfn [(f [[x l r :as t]]\n           (or (nil? t)\n               (and\n                (= 3 (count t))\n                (or (nil? l) (and (sequential? l) (f l)))\n                (or (nil? r) (and (sequential? r) (f r))))))]\n   f)", "problem": 95, "user": "4dbe8729535d020aff1edf62"}, {"code": "(fn bintree? [x]\n  (or\n    (nil? x)\n    (and\n      (sequential? x)\n      (= 3 (count x))\n      (not (sequential? (first x)))\n      (bintree? (second x))\n      (bintree? (nth x 2))\n      )))", "problem": 95, "user": "51f82769e4b09be9c177e527"}, {"code": "(fn is-tree? [node]\n    (or (nil? node)\n        (and (coll? node)\n             (= (count node) 3)\n             (is-tree? (nth node 1))\n             (is-tree? (nth node 2)))))", "problem": 95, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn is-tree? [[t left right :as node]]\n  (let [valid? #(or (nil? %)\n                    (and (instance? clojure.lang.Counted %)\n                         (is-tree? %)))]\n    (and (= (count node) 3) (valid? left) (valid? right))))", "problem": 95, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn tree? [t]\n  (cond\n   (= nil t) true\n   (not (sequential? t)) false\n   (not= 3 (count t)) false\n   :else (and (tree? (nth t 1)) (tree? (nth t 2)))))", "problem": 95, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "520612a7e4b0bf4f1882c81c"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "52016fd3e4b0b2e020a18f10"}, {"code": "(fn f[s]\n  (if (coll? s)\n   (reduce #(and %1 %2) (= (count s) 3) (map f (rest s)))\n   (nil? s)))", "problem": 95, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "; A valid tree has 3 elements, each of which must either be a valid tree or have a non-false value\n(fn tree? [s]\n\t(if (and (coll? s) (= 3 (count s)))\n\t\t(every? true?\n\t\t\t(for [node s] (if (coll? node) (tree? node) (if (false? node) false true))))\n\t\tfalse))", "problem": 95, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn tree? [s]\n  (if\n    (coll? s)\n    (case\n      (count s)\n      1 true\n      3 (let [[_ lft rgt] s]\n          (and (tree? lft) (tree? rgt)))\n      false)\n    (nil? s)))", "problem": 95, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn istree?\n  [x]\n  (if (nil? x) true\n    (if-not (sequential? x) false\n      (if-not (= (count x) 3) false\n        (and (istree? (nth x 1)) (istree? (nth x 2)))))))", "problem": 95, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn [x] (not (some #(and (sequential? %) (or (some (fn [a] (= a false)) %) (let [n (count %)] (and (not (= n 3)) (not (= n 1)))))) (tree-seq sequential? identity x))))", "problem": 95, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn bt? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (and (bt? (second t))\n                (bt? (nth t 2))))))", "problem": 95, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn fun [t]\n\t(and\n\t\t(= (count t) 3)\n\t\t(not (coll? (first t)))\n\t\t(if (coll? (second t))\n\t\t\t(fun (second t))\n\t\t\t(nil? (second t)))\n\t\t(if (coll? (first (next (next t))))\n\t\t\t(fun (first (next (next t))))\n\t\t\t(nil? (first (next (next t)))))))", "problem": 95, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn bincheck [arg]\n  (if\n    (nil? arg)\n    true\n    (if-not\n      (and (sequential? arg) (= (count arg) 3))\n        false\n      (let [[value lc rc] arg]\n        (and (bincheck lc) (bincheck rc))))))", "problem": 95, "user": "52173464e4b082aa80a88c75"}, {"code": "(fn b [s]\n  (if (nil? s) \n    true\n    (and (sequential? s) (= (count s) 3) (b (nth s 1)) (b (nth s 2)))))", "problem": 95, "user": "52160dbee4b0bf4bffd29cb3"}, {"code": "(fn is-tree [xs] (or (nil? xs) (and (coll? xs) (= 3 (count xs)) (is-tree (second xs)) (is-tree (last xs)))))", "problem": 95, "user": "5213ffd3e4b0961f15ac4d7d"}, {"code": "(fn tree? \n  [x]\n  (cond\n   (nil? x) true\n   (sequential? x)\n     (and (= 3 (count x))\n         (not (sequential? (first x)))\n         (tree? (second x))\n         (tree? (nth x 2))\n         )\n   :else false\n   ))", "problem": 95, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn cn [n]\n           (every? true? (flatten (cons (= (count (filter #(not (false? %)) n)) 3)\n                 (map #(if (coll? %)\n                           (cn %)\n                         true) n)))))", "problem": 95, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn tree? [sq]\n  \t(or (nil? sq)\n        (and (coll? sq)\n             (= (count sq) 3)\n             (tree? (nth sq 1))\n             (tree? (nth sq 2)))))", "problem": 95, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn [x] \n(->>\n    x\n    (tree-seq coll? identity)\n    (#(for [a %1]\n      (if (coll? a)\n        (if (or (= 3 (count a)) (= 1 (count a)))\n          true\n          false\n        )\n        (if (not= a false)\n          true\n          false\n        )\n      )\n    ))\n    (#(if (contains? (set %) false)\n      false\n      true\n    ))\n  )\n)", "problem": 95, "user": "52016690e4b0b2e020a18f0f"}, {"code": "(fn tree? [coll]\n   (cond\n    (nil? coll) true\n    (not (sequential? coll)) false\n    (not= (count coll) 3) false\n    :else (and (tree? (second coll)) (tree? (last coll)))))", "problem": 95, "user": "5220bc0fe4b0e6a83c8925a7"}, {"code": "(fn tree? [v] \n  (if (= nil v)\n    true\n    (if (sequential? v)\n      (if (not= 3 (count v)) \n        false\n        (let [value (nth v 0)\n              left (nth  v 1)\n              right (nth v 2)\n              ]   \n          (if (sequential? value)\n            false\n            (and (tree? left) (tree? right))\n            )   \n          )   \n        )   \n      false\n      ))  \n  )", "problem": 95, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn check-node [[value & children]]\n  (and\n    ((complement nil?) value)\n    (= (count children) 2)\n    (every? identity\n      (map \n        #(cond (nil? %) true\n               (coll? %) (check-node %)\n               :else false)\n        children))))", "problem": 95, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn binary-tree?\n  [tree]\n  (cond \n    (nil? tree) true\n    (and \n      (coll? tree)\n      (= 3 (count tree))\n      (binary-tree? (second tree))\n      (binary-tree? (last tree))) true\n    :else false))", "problem": 95, "user": "51ae350fe4b09397d5109790"}, {"code": "(fn isBinary [[v left right :as args]]\n  (and (= (count args) 3)\n       (if (or (seq? left) (vector? left)) (isBinary left) (nil? left))\n       (if (or (seq? right) (vector? right)) (isBinary right) (nil? right))))", "problem": 95, "user": "5213dbc3e4b0961f15ac4d74"}, {"code": "(fn f [all] (and\n             (coll? all)\n             (= 3 (count all))\n             (let [[_ left right] all]\n               (and \n                 (or (nil? left) (f left))\n                 (or (nil? right) (f right))\n               ))\n            ))", "problem": 95, "user": "5216933be4b000d124d989cf"}, {"code": "(fn tree? [t]\n  (and\n   (= (count t) 3)\n   (not (some false? t))\n   (every? identity (map tree? (filter sequential? t)))))", "problem": 95, "user": "521679e9e4b0bf4bffd29cca"}, {"code": "(fn g [t] \n  (if (sequential? t) \n    (and \n     (= 3 (count t)) \n     (first t) \n     (every? g (rest t)))\n    (nil? t)))", "problem": 95, "user": "5065faf9e4b0313a384e5645"}, {"code": "(fn binary-tree? [t]\n  (cond\n   (nil? t) true\n   (not (coll? t)) false\n   (not (= 3 (count t))) false\n   :else (let [ [x l r] t]\n           (and (binary-tree? l) (binary-tree? r)))))", "problem": 95, "user": "5224a46ce4b01819a2de42e5"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n  \t  (and (coll? t)\n           (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "problem": 95, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn bt? [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= 3 (count n))\n           (every? bt? (rest n)))))", "problem": 95, "user": "51ce1320e4b0e42293a22551"}, {"code": "(fn tree? [t]\n  (if (coll? t)\n    (if (and (= 3 (count t)) (not= nil (first t)) (tree? (first (next t))) (tree? (last t))) \n      true\n      false)\n           (if (= nil t)\n    true\n             false)\n    ))", "problem": 95, "user": "522048b3e4b0e6c71e0c0c16"}, {"code": "(fn \u260a [\u2f4a]\n  (or (nil? \u2f4a)\n      (and (coll? \u2f4a)\n           (= 3 (count \u2f4a))\n               (every? \u260a (rest \u2f4a)))))", "problem": 95, "user": "50e1bdd8e4b019fc399ce17f"}, {"code": "(fn tree?  [coll] \n\t(or  (nil? coll) \n\t\t(and (sequential?  coll) (= 3 (count coll))  (every? tree?  (rest coll)))\n\t\t))", "problem": 95, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn f [x]\n  (if (coll? x)\n    (and (= 3 (count x)) (f (first x)) (f (second x)) (f (last x)))\n    (not= false x)))", "problem": 95, "user": "522454f4e4b01819a2de42d3"}, {"code": "(fn ninety-five\n  [t]\n  (cond (nil? t)\n        true\n        (and (sequential? t) (= 3 (count t)) (ninety-five (nth t 1)) (ninety-five (nth t 2)))\n        true\n        :else\n        false))", "problem": 95, "user": "510591dde4b06d28cacc92eb"}, {"code": "(fn f [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= (count n) 3)\n           (every? f (next n)))))", "problem": 95, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn bt? [n]\n    (or (nil? n)\n        (and (coll? n)\n             (= 3 (count n))\n             (every? bt? (rest n)))))", "problem": 95, "user": "4f9d8083e4b0dcca54ed6d23"}, {"code": "(fn btree? [t]\n  (or\n    (nil? t)\n    (and\n      (coll? t)\n      (= 3 (count t))\n      (every? btree? (next t)))))", "problem": 95, "user": "508923d5e4b06d8254e936e8"}, {"code": "(fn tree? [col]\n  (let [[val left right] col]\n    (and (= 3 (count col))\n         (not(nil? val))\n         (or (nil? left) (and (coll? left) (tree? left)))\n         (or (nil? right) (tree? right)))))", "problem": 95, "user": "52117ea7e4b07aea8afc4f70"}, {"code": "(fn tree [x]\n  (if (sequential? x)\n    (if (= (count x) 3)\n      (let [[a b c] x] (and (tree b) (tree c)))\n      false)\n    (nil? x)))", "problem": 95, "user": "523d02b0e4b0dbf0c3017289"}, {"code": "(fn istree [x]\n  (or (nil? x)\n    (and \n       (sequential? x)\n       (= 3 (count x))\n       (istree (second x))\n       (istree (last x)))))", "problem": 95, "user": "51dd9370e4b0c33a4e1da40c"}, {"code": "(fn tree? [l]\n  (cond\n    (nil? l) true\n    (coll? l)\n    (and\n      (= 3 (count l))\n      ((complement coll?) (first l))\n      (tree? (second l))\n      (tree? (last l)))\n    :else false))", "problem": 95, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn self [col]\n  (or (nil? col)\n      (and (sequential? col)\n           (= (count col) 3)\n           (every? self (rest col)))))", "problem": 95, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn istree?                     \n  [x]                             \n  (cond                           \n   (not (coll? x)) (nil? x)       \n   (= 3 (count x))                \n   (and (not (coll? (first x)))   \n        (istree? (second x))      \n        (istree? (last x)))       \n   :else false                    \n        )                         \n)", "problem": 95, "user": "50573ed8e4b0012181721987"}, {"code": "(fn tree? [x] \n  (or \n   (nil? x) \n   (and \n    (coll? x)\n    (= 3 (count x)) \n    (tree? (nth x 1))\n    (tree? (nth x 2)))))", "problem": 95, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn bint [node] (if (= 3 (count node))\n                  (let [[_ y z] node]\n                    (and \n                     (if (coll? y) \n                      (bint y)\n                      (nil? y))\n                     (if (coll? z) \n                      (bint z)\n                      (nil? z))\n                     )\n                   )\n                       false))", "problem": 95, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [tree]\n\t   (let [tree-split (->> tree\n\t\t\t\t (tree-seq sequential? rest)\n\t\t\t\t (group-by sequential?))]\n\t     (and (every? nil? (tree-split false))\n\t\t  (->> (tree-split true)\n\t\t       (map count)\n\t\t       (every? #(= 3 %))))))", "problem": 95, "user": "52381b2ae4b0fae3832e99ef"}, {"code": "(fn istree? [root]\n  (cond\n    \n    (= root nil) true\n    (= (coll? root) false) false\n    (= (count root) 3) \n\t    (and \n\t      (istree? (nth root 1))\n\t      (istree? (nth root 2)))\n    :else false))", "problem": 95, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn tree?- [coll]\n  (if (sequential? coll)\n    (and (= 3 (count coll))\n        (tree?- (first coll))\n        (tree?- (second coll))\n        (tree?- (last coll)))\n    (if (or (nil? coll) coll)\n      true false)))", "problem": 95, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn tree? [t]\n  (if (sequential? t)\n    (and (= 3 (count t))\n         (tree? (nth t 1))\n         (tree? (nth t 2)))\n    (or (number? t) (nil? t))))", "problem": 95, "user": "52487654e4b05ef8e38e63dc"}, {"code": "(fn tree? [s]\n  (cond\n    (nil? s) true\n    (not (coll? s)) true\n    (and (not (nil? s)) (empty? s)) false\n    (not= (count s) 3) false\n    :else\n      (let [[value l r] s]\n        (cond\n           (and (nil? r) (and (not (nil? l)) (not (coll? l)))) false\n           (and (nil? l) (and (not (nil? r)) (not (coll? r)))) false\n           :else (and (tree? l) (tree? r))))))", "problem": 95, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn b-tree [coll]\n   (and (sequential? coll) (= (count coll) 3)\n     (let [[root left right] coll]\n        (and (not (nil? root)) \n           (if (nil? left) true (b-tree left))\n           (if (nil? right) true (b-tree right))\n        )\n      )\n   )   \n)", "problem": 95, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn tree? [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (tree? (nth x 1))\n           (tree? (nth x 2)))))", "problem": 95, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn f [[v l r :as all]]\n  (and\n    (= 3 (count all))\n    (or (nil? l) (and (coll? l) (f l)))\n    (or (nil? r) (and (coll? r) (f r)))))", "problem": 95, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn btree? [node] (if (coll? node) (and (= 3 (count node)) (or (nil? (second node)) (coll? (second node))) (apply = (conj (map btree? node) true))) true))", "problem": 95, "user": "52437703e4b076204b44fabf"}, {"code": "(fn f [coll]\n   (if-not (coll? coll)\n     (nil? coll)\n     (let [cnt (count coll)]\n       (cond\n        (= 1 cnt) true\n        (= 3 cnt) (and (f (second coll)) (f (second (rest coll))))\n        :else false))))", "problem": 95, "user": "506c0a02e4b0eda3100c090d"}, {"code": "(fn [to-tree-or-not-to-tree]\n   (not-any?\n    (fn check-node? [node ]\n      (false?\n       (if-not (= 3 (count node))\n         false\n         (not-any? (fn [it]\n                     (if (or (sequential? it) (nil? it) (= (first node) it ))  false  true  )\n                     ) node\n                       ))))\n    (filter  #(sequential? %)  (tree-seq sequential? seq\n                                         to-tree-or-not-to-tree\n                                         ))))", "problem": 95, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn bt? [t]\n  (if (and (not (false? t))\n    (or (not (sequential? t))\n          (and (= 3 (count t))\n               (bt? (second t))\n               (bt? (last t)))))\n    true false))", "problem": 95, "user": "521dceeae4b050d5da042802"}, {"code": "(fn tree? [x] \n  (or \n    (nil? x) \n    (and \n      (sequential? x) \n      (= 3 (count x)) \n      (tree? (nth x 1)) \n      (tree? (nth x 2)))))", "problem": 95, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn tree? [t]\n  (if (and t (= 3 (count t)))\n    (let [[v l r] t]\n      (if v (and (tree? l) (tree? r))))\n    (nil? t)))", "problem": 95, "user": "50ef96a1e4b0bdaecbb47d9d"}, {"code": "(fn is-binary-tree? [coll]\n  (if (nil? coll)\n    true\n    (if (or (not (sequential? coll))\n            (not= (count coll) 3))\n      false\n      (let [[x y z] coll]\n        (and (identity x)\n             (is-binary-tree? y)\n             (is-binary-tree? z))))))", "problem": 95, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn bt? [t]\n  (if (coll? t)\n    (and\n     (= 3 (count t))\n     (bt? (nth t 1))\n     (bt? (nth t 2)))\n    (nil? t)))", "problem": 95, "user": "4f048f67535dcb61093f6bd3"}, {"code": "(fn binary-tree?\n  [tree]\n  (if (= (count tree) 3)\n    (and (every? true? (map binary-tree? (filter sequential? tree))) (every? #(not (false? %)) tree))\n    false))", "problem": 95, "user": "523288fee4b035af41902a88"}, {"code": "(fn t? [[p l r :as b]] (and (= 3 (count b)) (if (sequential? l) (t? l) (not (false? l))) (if (sequential? r) (t? r) (not (false? r)))))", "problem": 95, "user": "523b1a65e4b02f719975bdbd"}, {"code": "(fn tree? [xs]\n  (if (and (coll? xs) (= 3 (count xs)))\n    (every? true? (map (fn [node] (or (nil? node) (tree? node))) (rest xs)))\n    false\n    )\n  )", "problem": 95, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn tree? [t]\n  (and (sequential? t) (= 3 (count t))\n  (let [[value left right] t]\n  \t(and \n  \t  (or (nil? left) (tree? left))\n      (or (nil? right) (tree? right))))))", "problem": 95, "user": "51990df9e4b068aa333628fc"}, {"code": "(fn [t] (every? (some-fn  (every-pred sequential? #(= 3 (count %))) nil?) (tree-seq sequential? next t)))", "problem": 95, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn bin-tree? [tree]\n  (cond\n   (nil? tree) true\n   (not (coll? tree)) false\n   (and (= (count tree) 3)\n        (bin-tree? (nth tree 1))\n        (bin-tree? (nth tree 2))) true\n   :else false))", "problem": 95, "user": "519db0ede4b037b32803f9b9"}, {"code": "(fn t? [[n l r :as t]] (and (= 3 (count t)) (every? #(or (nil? %) (and (coll? %) (t? %))) [l r])))", "problem": 95, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn btree?\n  [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= (count coll) 3)\n           (and (btree? (second coll))\n                (btree? (nth coll 2))))))", "problem": 95, "user": "4fe8e719e4b0547ebccb2430"}, {"code": "(fn _ [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= 3 (count n))\n           (let [[n' n1 n2] n]\n             (and\n               (_ n1)\n               (_ n2))))))", "problem": 95, "user": "5213d7aae4b0961f15ac4d72"}, {"code": "(fn tree? [c]\n  (if (coll? c)\n    (let [[n l r] c]\n \t    (and (= 3 (count c)) \n\t         (or (nil? l) (tree? l))\n\t\t     (or (nil? r) (tree? r))))\n    false))", "problem": 95, "user": "51b0e7b3e4b0c53cf2e68a6e"}, {"code": "(fn chk [n]\n   (if (some true? (map #(% n) [list? seq? vector?]))\n     (and (= (count n) 3) (chk (nth n 1)) (chk (nth n 2)))\n     (nil?  n))\n   )", "problem": 95, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn isbtree\n  [t] (if (nil? t) true\n        (if-let [[v l r] t]\n          (and (= 3 (count t)) (isbtree l) (isbtree r))\n          false)))", "problem": 95, "user": "5217c26fe4b0a4bccb16cab8"}, {"code": "(fn myfn [s1]\n  \t(or (= s1 nil)\n        (and (coll? s1)\n             (= 3 (count s1))\n             (myfn (first (rest s1)))\n             (myfn (first (rest (rest s1))))\n        )\n    )\n)", "problem": 95, "user": "525ba7bbe4b0cb4875a45d28"}, {"code": "(fn tree? [coll]\n  (and\n   (coll? coll)\n   (let [[a b c] coll]\n    (and\n     (if (nil? b)\n      true\n      (tree? b)\n      )\n     (if (nil? c)\n      true\n      (tree? c)\n     )\n     (= 3 (count coll))\n   )\n  )\n )\n)", "problem": 95, "user": "5228f870e4b0186687e23a98"}, {"code": "(fn tree? [t]\n  (or (= t nil)\n      (and\n       (sequential? t)\n       (= (count t) 3)\n       (tree? (nth t 1))\n       (tree? (nth t 2)))))", "problem": 95, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn tree? [node]\n  (if (nil? node)\n    true\n    (if (and (coll? node) (= (count node) 3))\n      (and (tree? (nth node 1))\n           (tree? (nth node 2)))\n      false)))", "problem": 95, "user": "4fcbc18ae4b0ee37620e185c"}, {"code": "(fn tree [li]\n  (if (nil? li)\n    true\n    (and\n     (or (seq? li) (vector? li))\n     (= 3 (count li))\n     (tree (second li))\n     (tree (last li))\n    )\n    )\n  )", "problem": 95, "user": "5259a16ee4b0cb4875a45ce1"}, {"code": "(fn btree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (every? btree? (rest node)))))", "problem": 95, "user": "5244fa73e4b0d8acf9ed6acb"}, {"code": "(fn test-bt [root]\n   (cond\n    (nil? root) true\n    (and (coll? root) (= 3 (count root))) (let [[r left right] root]\n                                            (and (test-bt left)\n                                                 (test-bt right)\n                                                 (not (coll? r))))\n    :else false))", "problem": 95, "user": "516282c3e4b0e6d3c4734711"}, {"code": "(fn tree? [t]\n  (cond\n   (nil? t) true\n   (and (sequential? t) (= (count t) 3)) (and (tree? (nth t 1)) (tree? (nth t 2)))\n   :else false\n   )\n  )", "problem": 95, "user": "5252cbe7e4b0541d1855b8d2"}, {"code": "(fn ? [x] (or (nil? x) (and\n    (sequential? x)\n    (= 3 (count x))\n    (? (nth x 1))\n    (? (nth x 2)))))", "problem": 95, "user": "525ed5f4e4b0cb4875a45db8"}, {"code": "(fn ! [t]\n  (and\n    (sequential? t)\n    (= 3 (count t))\n    (let [[val left right] t]\n      (and\n        (not (sequential? val))\n        (not (nil? val))\n        (or (nil? left) (! left))\n        (or (nil? right) (! right))))))", "problem": 95, "user": "51622fb8e4b009fba0926e3f"}, {"code": "(fn p [c]\n\t\t(if (coll? c)\n\t\t\t(if (= (count c) 3)\n\t\t\t\t(and (p (second c)) (p (last c)))\n\t\t\t  false)\n\t\t  (if (nil? c) true false)))", "problem": 95, "user": "51f2851fe4b0210f90e7454b"}, {"code": "(fn foo [lst]\n  (let [chk (fn [x] (if (or (seq? x) (vector? x)) (foo x) (nil? x)))]\n  (and (= 3 (count lst))\n       (chk (last lst))\n       (chk (first (rest lst)))\n   ))\n  )", "problem": 95, "user": "525372ade4b0541d1855b8f3"}, {"code": "(fn btree? [seq]\n  (or (nil? seq)\n      (and (coll? seq)\n           (= (count seq) 3)\n           (btree? (nth seq 1))\n           (btree? (nth seq 2)))))", "problem": 95, "user": "52655949e4b03e8d9a4a710b"}, {"code": "(fn [root]\n    (every?\n      #(or\n        (nil? %)\n        (and (sequential? %) (= 3 (count %))))\n      (tree-seq sequential? rest root)))", "problem": 95, "user": "52699a0ee4b03e8d9a4a71f2"}, {"code": "(fn binary-tree? [s]\n\t(letfn [(parent? [node]\n                     (and (coll? node) (= 3 (count node))))]\n      (or (nil? s) (and (parent? s) (binary-tree? (second s)) (binary-tree? (last s))))))", "problem": 95, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn t [tree]\n  (if-not (coll? tree)\n    (if (= false tree) false true)\n    (if-not (= 3 (count tree))\n      false\n      (reduce #(and % %2) (map t tree)))))", "problem": 95, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn c [n]\n  (or (nil? n)\n        (and (coll? n)\n                 (= 3 (count n))\n                 (every? c (rest n)))))", "problem": 95, "user": "4db599e6535d87e67b28fe11"}, {"code": "(fn f [l]\n   (and (coll? l)\n(let [[_ b c] l]\n  (and (= (count l) 3) (or (nil? b) (f b)) (or (nil? c) (f c)))\n  ))\n)", "problem": 95, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn [tree]\n  (letfn [(bin-tree? [t]\n  \t        (and (coll? t)\n                 (= (count t) 3)\n     \t         (or (nil? (second t)) (bin-tree? (second t)))\n       \t         (or (nil? (nth t 2)) (bin-tree? (nth t 2)))))]\n  (bin-tree? tree)))", "problem": 95, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(fn test-btree [[val l-chld r-chld :as node]]\n  (cond\n    (= node nil) true\n    (or (not (or (= nil l-chld) (coll? l-chld)))\n        (not (or (= nil r-chld) (coll? r-chld)))\n        (= val nil) \n        (not= (count node) 3)) \n      false\n    :else (and (test-btree l-chld) (test-btree r-chld))))", "problem": 95, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn istree? [n]\n    (or\n      (nil? n)\n      (and\n        (sequential? n)\n        (= 3 (count n))\n\t    (istree? (nth n 1))\n        (istree? (nth n 2)))))", "problem": 95, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn is-tree [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= (count x) 3)\n           (is-tree (second x))\n           (is-tree (last x)))))", "problem": 95, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn t? [t]\n  (and\n   (sequential? t)\n   (= 3 (count t))\n   (let [[v l r] t]\n     (and \n       (or (nil? l) (t? l))\n       (or (nil? r) (t? r))))))", "problem": 95, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn tree? [coll]\n  (if (nil? coll)\n    true\n    (and\n      (coll? coll)\n      (= (count coll) 3)\n      (tree? (second coll))\n      (tree? (second (next coll))))))", "problem": 95, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn is-binary-tree [nodes]\n    (if (nil? nodes)\n      true\n      (if (sequential? nodes)\n        (if (= 1 (count nodes))\n          (if (every? nil? nodes)\n            true\n            false\n          )\n          (if (= 3 (count nodes))\n            (and (is-binary-tree (nth nodes 1)) (is-binary-tree (nth nodes 2)))\n            false\n          )\n        )\n        false\n      )\n    )\n  )", "problem": 95, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn tree? [x]\n  (cond\n   (nil? x) true\n   (not (coll? x)) false\n   (not= 3 (count x)) false\n   :else (and (tree? (nth x 1)) (tree? (nth x 2)))))", "problem": 95, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn t [xs]\n  (cond \n    (nil? xs) true\n    (not (coll? xs)) false\n    (not= 3 (count xs)) false\n    :else (and (t (nth xs 1)) (t (nth xs 2)))))", "problem": 95, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn f [tree] (if (nil? tree) \n               true \n               (if (or (not  (coll? tree))\n                       (not= (count tree) 3)\n                   )\n                 false\n                 (if \n                   (nil? (first tree)) \n                   false \n                   (and (f (nth tree 2)) (f (nth tree 1)))))))", "problem": 95, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn tree [x]\n  (cond (coll? x) (and (= (count x) 3) (tree (second x)) (tree (last x)))\n\t\t(false? x) false\n        :else true))", "problem": 95, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn a [col] (every? true? (flatten(list(if(coll? col)(if-not(= 3 (count col))(identity false)(map #(a %) col))(not(false? col)))))))\n;(defn a [col] (if(coll? col)(if-not(= 3 (count col))(identity false)(map #(a %) col))(identity true)))\n;(defn a [col] (if(coll? col)(if-not(= 3 (count col))(identity false)(map #(a %) col))(not(false? col))))", "problem": 95, "user": "527a8eb7e4b03e8d9a4a755f"}, {"code": "(fn chk [s] (and (and (= 3 (count s))(= 0 (count (filter false? s))))\n                  (and (or (not (coll? (first (drop 1 s))))(chk (first (drop 1 s))))\n                       (or (not (coll? (last s))) (chk (last s))))\n                  )\n )", "problem": 95, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn binary-tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= 3 (count coll))\n           (binary-tree? (nth coll 1))\n           (binary-tree? (nth coll 2)))))", "problem": 95, "user": "524a554de4b05ef8e38e64a2"}, {"code": "(fn p95 [lst]\n   (letfn [(tree? [lst]\n             (or (nil? lst)\n                 (and (coll? lst) (= 3 (count lst))\n                      (let [[v l r] lst] (and (tree? l) (tree? r))))))] (tree? lst)))", "problem": 95, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn tree? [t] \n  (if (sequential? t) \n    (and \n      (= (count t) 3) \n      (tree? (nth t 1)) \n      (tree? (nth t 2))) \n    (nil? t)))", "problem": 95, "user": "50cf21dee4b0e61f11ddcd8b"}, {"code": "(fn b [n]\n  (or (nil? n)\n      (and (coll? n) (= (count n) 3) (b (nth n 1)) (b (nth n 2))) ) )", "problem": 95, "user": "4df20dda535d08e6dec9fe23"}, {"code": "(fn tree? [node]\n  (if (coll? node)\n    (and \n     (= 3 (count node))\n     (reduce #(and %1 (tree? %2)) true node))\n    (not= node false)))", "problem": 95, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn r [x]\n  (or (= x nil)\n      (and (coll? x)\n           (= (count x) 3)\n           (every? r (rest x)))))", "problem": 95, "user": "527b856fe4b03e8d9a4a758d"}, {"code": "(fn istree? [root] \n (or  \n  (nil? root)\n  (and \n   (sequential? root)\n   (= 3 (count root))\n   (every? istree? (rest root))\n   )\n  )\n)", "problem": 95, "user": "5029f263e4b023940c84aa45"}, {"code": "(fn is-tree? [s] \n  (or (nil? s) (number? s) (keyword? s)\n      (and (coll? s) (= (count s) 3) \n           (if-let [[v l r] s] \n             (and (is-tree? v) (is-tree? r) (is-tree? l))))))", "problem": 95, "user": "519ef784e4b087743fad2198"}, {"code": "(fn bt [s]\n  (or (and (coll? s) (= (count s) 3) (every? #(bt %) s))\n      (nil? s)\n      (and\n      \t((comp not coll?) s)\n      \ts)))", "problem": 95, "user": "522a01ade4b0590a43906ced"}, {"code": "(fn istree [x] (cond (= x nil) true :else (and (or (list? x) (vector? x)) (= (count x) 3) (atom (first x)) (istree (first (rest x))) (istree (first (rest (rest x)))))))", "problem": 95, "user": "528b9efee4b0239c8a67aea0"}, {"code": "(fn btree? [c]\n  (if (coll? c)\n    (if (and (== 3 (count c))\n             (not (nil? (first c))))\n      (and (btree? (second c))\n           (btree? (nth c 2)))\n      false)\n    (if (nil? c)\n      true\n      false)))", "problem": 95, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn tree? [x]\n  (cond\n    (nil? x)              true\n    (not (sequential? x)) false\n    (not= 3 (count x))    false\n    :default (and (tree? (nth x 1))\n                  (tree? (nth x 2)))))", "problem": 95, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn bt? [s] \n  (or (nil? s) \n    (and (coll? s) (= 3 (count s)) (every? bt? (rest s)))))", "problem": 95, "user": "523b1988e4b02f719975bdbc"}, {"code": "(let [not-nil? (complement nil?)]\n  (fn tree? [coll]\n    (if (coll? coll)\n      (and  (= 3 (count coll))\n            (not-nil? (first coll))\n            (tree? (second coll))\n            (tree? (last coll)))\n      (nil? coll))))", "problem": 95, "user": "4ea5ba92535d7eef308072d9"}, {"code": "(fn is-btree? [x]\n    (and (= 3 (count x))\n         (every? (fn [e] (if (sequential? e) (is-btree? e)\n                           (not (false? e)) )) x)))", "problem": 95, "user": "4f072644535dcb61093f6c20"}, {"code": "(fn t [n]\n  (or (nil? n)\n      (and (coll? n) (= 3 (count n)) (t (second n)) (t (nth n 2)))))", "problem": 95, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn tree? [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (every? tree? (rest tree)))))", "problem": 95, "user": "5290257ae4b0239c8a67af03"}, {"code": "(fn myf [xs] (let [n (count xs) [a b c] xs]\n               (and (= n 3)\n                    (and (not= a nil) (not (coll? a)))\n                    (or (= b nil) (and (coll? b) (myf b)))\n                    (or (= c nil) (and (coll? c) (myf c)))\n                    )\n               ))", "problem": 95, "user": "4f9510b5e4b0dcca54ed6cc7"}, {"code": "(fn istree? [root]\n    (or (nil? root)\n    (and (sequential? root)\n    (= 3 (count root))\n    (every? istree? (rest root)))))", "problem": 95, "user": "52496f0ae4b05ef8e38e6459"}, {"code": "(fn is-tree? [v]\n  (or (nil? v)\n    (and (coll? v) (= 3 (count v)) (not (coll? (first v))) (is-tree? (second v)) (is-tree? (last v)))))", "problem": 95, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn is-tree[colls]\n      (if(nil? colls)\n        true\n        (if(or(not (coll? colls)) (not= 3 (count colls)))\n          false\n          (let[x (second colls )\n               y (nth colls 2)]\n            (and (is-tree x) (is-tree y))))))", "problem": 95, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn tree? [node]\n  (if (nil? node) true\n      (if (and (or (seq? node) (vector? node)) (= (count node) 3))\n        (let [[root c1 c2] node]\n          (and\n           (not (nil? root))\n           (tree? c1)\n           (tree? c2)))\n        false)))", "problem": 95, "user": "4e0d5a5a535d04ed9115e7b5"}, {"code": "(fn is-correct-node [node] \n  (if (nil? node) true\n     (if \n       (and\n           (coll? node)\n            (= (count node) 3)\n              (not(nil? (nth node 0)))\n                (is-correct-node (nth node 1))\n                  (is-correct-node (nth node 2)))\n                    true false)))", "problem": 95, "user": "51cec7b1e4b0e42293a2255b"}, {"code": "(fn binary-tree? [input]\n  (or\n   (and\n    (sequential? input)\n    (= (count input) 3)\n    (and\n     (binary-tree? (nth input 1))\n     (binary-tree? (nth input 2))))\n   (nil? input)))", "problem": 95, "user": "528bba38e4b0239c8a67aea9"}, {"code": "(fn is-tree? [s]\n\t(if (sequential? s)\n\t\t(let [[v l r] (take 3 s)]\n\t\t\t(boolean\n\t\t\t\t(and\n\t\t\t\t\t(= (count s) 3)\n\t\t\t\t\t(is-tree? l)\n\t\t\t\t\t(is-tree? r))))\n\t\t(boolean\n         (or\n          (true? s)\n          (nil? s)))))", "problem": 95, "user": "4f3d83b5e4b0e243712b1f69"}, {"code": "(fn binary-tree? [tree]\n  (and\n    (sequential? tree)\n    (= 3 (count tree))\n    (let [left (second tree)\n          right (last tree)]\n      (and\n        (or (nil? left) (binary-tree? left))\n        (or (nil? right) (binary-tree? right))))))", "problem": 95, "user": "528b08efe4b0239c8a67ae8a"}, {"code": "(fn bt? [coll]\n  (cond\n   (nil? coll) true\n   (sequential? coll) (and (= (count coll) 3)\n                    (bt? (second coll))\n                    (bt? ((comp second rest) coll)))\n   :else false))", "problem": 95, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn t\n  ([val] (if (sequential? val)\n           (if (= 3 (count val))\n             (apply t val)\n             false)\n           (nil? val)))\n  ([v l r] (and (t l) (t r))))", "problem": 95, "user": "528a791ae4b0239c8a67ae77"}, {"code": "(letfn [(tree? [x]\n               (or (nil? x)\n                   (and (coll? x)\n                        (= 3 (count x))\n                        (let [[_ l r] x]\n                          (and (tree? l) (tree? r))))))]\n  tree?)", "problem": 95, "user": "515ead6be4b049add99a053e"}, {"code": "(fn tree? [z]\n  (if (sequential? z)\n    (let [[n l r] z]\n      (and (= 3 (count z))\n           (tree? l)\n           (tree? r)))\n    (nil? z)))", "problem": 95, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(fn istree [t]\n  (cond\n  \t(not (coll? t)) false\n   \t(not (= 3 (count t))) false\n   \t(not (or (nil? (second t)) (istree (second t)))) false\n   \t(not (or (nil? (nth t 2)) (istree (nth t 2)))) false\n  \t true true))", "problem": 95, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn tree [x] (if (= x nil) true (if (or (= x false) (not= 3 (count x))) false (and (tree\n (second x)) (tree (last x))))))", "problem": 95, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn btree? [t]\n      (or (nil? t)\n          (and\n            (coll? t)\n            (= 3 (count t))\n            (btree? (nth t 1))\n            (btree? (nth t 2))\n            )\n          )\n      )", "problem": 95, "user": "51e28063e4b08e53a149f0f2"}, {"code": "(fn [t] (every? #(or (nil? %) (and (sequential? %) (= 3 (count %)))) (tree-seq sequential? rest t)))", "problem": 95, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn p [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (every? p (next t)))))", "problem": 95, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn tree? [coll] (if (= 3 (count coll))\n                     (if (if (coll? (second coll))\n                           (tree? (second coll))\n                           (if (= nil (second coll))\n                             true\n                             false))\n                       (if (coll? (last coll))\n                         (tree? (last coll)) \n                         (if (= nil (last coll))\n                           true\n                           false))\n                       false)\n                     false\n                     )   \n  )", "problem": 95, "user": "5296aa9be4b02ebb4ef75034"}, {"code": "(fn is-bin-tree? [t]\n  (cond\n   (or (not (coll? t)) (not= (count t) 3)) false\n   (and (nth t 1) (nil? (nth t 2))) (is-bin-tree? (nth t 1)) \n   (and (nil? (nth t 1)) (nth t 2)) (is-bin-tree? (nth t 2))\n   (and (nil? (nth t 1)) (nil? (nth t 2))) true\n   :else (and (is-bin-tree? (nth t 1)) (is-bin-tree? (nth t 2)))\n    )\n  )", "problem": 95, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn check-btree [tree]\n   (if (and (coll? tree)(= 3 (count tree)))\n     \t(let [[head left right :as all] tree]\n          (and\n           \t(not (nil? head))\n   \t\t\t(check-btree left)\n   \t\t\t(check-btree right)))\n\t(nil? tree)))", "problem": 95, "user": "527ccaf4e4b0757a1b17136d"}, {"code": "(fn balanced? [coll]\n  (let [triple? (fn t [coll]\n    (if (coll? coll)\n       [(= 3 (count coll)) (map t (rest coll))]\n      (nil? coll)))]\n    ( = #{true} (set (flatten (triple? coll))))))", "problem": 95, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn btree? [node]\n  (or (nil? node)\n    (and (coll? node)\n      (= 3 (count node))\n      (every? btree? (rest node)))))", "problem": 95, "user": "4f0f36a7535d0136e6c22336"}, {"code": "(fn tree? [t] \n\t(if (or (list? t) (vector? t))\n\t\t(and (= (count t) 3) (tree? (nth t 1)) (tree? (nth t 2)))\n\t\t(not (= t false))))", "problem": 95, "user": "524f4162e4b0541d1855b806"}, {"code": "(fn f [s]\n       (and (sequential? s)\n            (= (count s) 3)\n            (or (nil? (second s)) (f (second s)))\n            (or (nil? (nth s 2)) (f (nth s 2)))))", "problem": 95, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn is-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? is-tree? (rest root)))))", "problem": 95, "user": "52a5e784e4b0c58976d9abf3"}, {"code": "(fn f [t] ({nil 1} t (and (coll? t) (= 3 (count t)) (every? f (rest t)))))", "problem": 95, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn f [t] (if (coll? t)\n              (if (= (count t) 3)\n                (every? f t)\n                false)\n              (or (nil? t) t)))", "problem": 95, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn f [t]\n    (cond (nil? t) true\n          (coll? t) (and (= (count t) 3)\n                         (not (coll? (first t)))\n                         (f (second t))\n                         (f (last t)))\n          :else false))", "problem": 95, "user": "51929214e4b08962174cf74c"}, {"code": "(fn btree? [c]\n  (if (coll? c)\n    (and (= 3 (count c))\n         (first c)\n         (every? true? (map btree? (rest c))))\n    (nil? c)))", "problem": 95, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [s] (if (seq? s) (= 0 (compare [3] (vec (distinct (map count (filter seq? (replace {false [nil nil]} (tree-seq seq? seq s))))))))\n          (= 0 (compare [3] (vec (distinct (map count (filter vector? (replace {false [nil nil], () [nil nil]} (tree-seq vector? vec s))))))))\n          ))", "problem": 95, "user": "525c575be4b0cb4875a45d38"}, {"code": "(fn btree? [t]\n  (cond (false? t) false\n        (not (sequential? t)) true\n    \t:else (let [[a l r & n] t]\n                (and (empty? n)\n                     (= 3 (count t))\n                     (btree? l)\n                     (btree? r)))))", "problem": 95, "user": "4ee8b9c9535d93acb0a66884"}, {"code": "(fn q [xs]\n  (if (and (coll? xs) (= 3 (count xs)))\n    (let [l (second xs) r (last xs) foo #(if (coll? %1) (q %1) (or (nil? %1) (= (class (first xs)) (class %1))))]\n      (and (foo l) (foo r))\n      )\n    false\n    )\n  )", "problem": 95, "user": "510b704ee4b078ea71921100"}, {"code": "(fn istree? [x]\n  (if (and (sequential? x) (= 3 (count x)))\n    (let [[v l r] x]\n      (and\n       (or (nil? l) (istree? l))\n       (or (nil? r) (istree? r))\n       ))\n    false\n    ))", "problem": 95, "user": "527ba695e4b03e8d9a4a7596"}, {"code": "(fn child? [coll]\n  (if (sequential? coll)\n    (if (= 3 (count coll))\n      (let [[val left right] coll]\n        (and\n         (not (sequential? val))\n         (and (or (nil? left) (sequential? left))\n              (or (nil? right) (sequential? right)))\n         (apply = (cons true (map child? [left right])))))\n      false)\n    true))", "problem": 95, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn n95 [tree]\n  (letfn [(leave? [l] (or (sequential? l) (nil? l)))]\n    (if (sequential? tree)\n      (if (= [false true true] (map leave? tree)) (reduce #(and %1 %2) (map n95 tree)) false)\n      true)))", "problem": 95, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn f [tree]\n (and (= 3 (count tree)) (every? #(if (coll? %) (f %) (not (false? %))) tree)))", "problem": 95, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn  mbinarytree [tr]\n  (if (or ((complement sequential?) tr) (not= 3 (count tr)))\n    false\n    (let [s (second tr)\n          l (last tr)]\n      (cond\n       (= nil s l) true\n       (and (nil? s) (sequential? l)) (recur l)\n       (and (nil? l) (sequential? s)) (recur s)\n       (and (sequential? l) (sequential? s)) (and (mbinarytree l) (mbinarytree s))\n       :d false))))", "problem": 95, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn btree?\n  [tree]\n  (if (and (sequential? tree) (= 3 (count tree)))\n    (let [l (second tree)\n          r (nth tree 2)]\n          (and (if (nil? l) true (btree? l) )\n               (if (nil? r) true (btree? r))))\n    false))", "problem": 95, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn tree? [tree]\n  (let [seq-or-nil? (fn [x] (or (sequential? x) (nil? x)))]\n    (cond\n     (nil? tree) true\n     (not (= [true true] (map seq-or-nil? (drop 1 tree)))) false\n     :else (and (-> tree second tree?) (-> tree last tree?)))))", "problem": 95, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn f [coll]\n  (if (nil? coll) true\n      (if (or (= false coll) (and (not= 1 (count coll)) (not= 3 (count coll))))\n        false\n        (if (and (f (nth coll 1)) (f (nth coll 2))) true false))))", "problem": 95, "user": "52b0323ee4b0c58976d9acc6"}, {"code": "(fn tree? [n]\n  (or (= nil n)\n      (and (sequential? n)\n           (= 3 (count n))\n           (tree? (nth n 1))\n           (tree? (nth n 2)))))", "problem": 95, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn tr [t]\n  (or (nil? t)\n    (and\n     (sequential? t)\n     (= (count t) 3)\n     (tr (second t))\n     (tr (second (rest t))))))", "problem": 95, "user": "52bb27fee4b07a9af57922df"}, {"code": "(fn istree [t]\n  (if (sequential? t)\n    (and (= (count t) 3) \n         (not (sequential? (first  t)))\n         (istree (second t))\n         (istree (nth t 2)))\n    (nil? t))\n  )", "problem": 95, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn node? [x] (and (coll? x) (= 3 (count x)) (not (false? (second x))) (or (not (coll? (second x))) (node? (second x))) (or (not (coll? (last x))) (node? (last x)))))", "problem": 95, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "(fn is-tree [tree]\n  (cond\n   (nil? tree) true\n   (not (coll? tree)) false\n   (not= 3 (count tree)) false\n   (and (is-tree (nth tree 1)) (is-tree (nth tree 2))) true\n   :else false))", "problem": 95, "user": "52b405e1e4b0c58976d9ad15"}, {"code": "(fn btree? [tree]\n  (if (not= (count tree) 3)\n    false\n    (let [left (nth tree 1)\n          right (nth tree 2)]\n      (and\n       (if (coll? left) (btree? left) (nil? left))\n       (if (coll? right) (btree? right) (nil? right))\n       ))\n  ))", "problem": 95, "user": "529d4f4be4b04e0c58e87b79"}, {"code": "(fn tree? [t] (if (nil? t) true (and (sequential? t) (== (count t) 3) (tree? (first (rest t))) (tree? (last t)))))", "problem": 95, "user": "52b7a904e4b0c58976d9ad51"}, {"code": "(fn b-tree [coll]\n  (if (= 3 (count coll))\n    (if-let [rst (seq (filter sequential? (rest coll)))]\n      (every? b-tree rst)\n      (every? nil? (rest coll)))\n    false))", "problem": 95, "user": "50645e12e4b007509339a58a"}, {"code": "(fn f [a]\n  (cond (nil? a) true\n        (not (sequential? a)) false\n   \t\t(not= 3 (count a)) false\n        :else (and (f (nth a 1))\n             \t   (f (nth a 2)))))", "problem": 95, "user": "4eda8d7c535d10e5ff6f530f"}, {"code": "(fn tree? [tree]\n  (if\n    (not (= 3 (count tree)))\n    false\n    (let [\n          [node leaf1 leaf2] tree\n          valid-leaf (fn [leaf] (or (nil? leaf) (and (sequential? leaf) (tree? leaf))))\n          ]\n      (and (valid-leaf leaf1) (valid-leaf leaf2)))))", "problem": 95, "user": "4f05a9cf535dcb61093f6bfc"}, {"code": "(fn f [node]\n      (if (coll? node)\n        (if (= (count node) 3)\n          (let [[v left right] node]\n            (and (or (nil? left) (f left)) (or (nil? right) (f right))))\n          false)\n        false))", "problem": 95, "user": "506cad7de4b0a302964c548e"}, {"code": "(fn is-binary? [tree] (or (nil? tree) (and (sequential? tree) (= 3 (count tree)) (every? is-binary? (rest tree)))))", "problem": 95, "user": "52a62e16e4b0c58976d9abf9"}, {"code": "(fn tree? [x]\n  (cond\n   (coll? x) (let [[_ left right] x]\n               (and (= 3 (count x)) (tree? left) (tree? right)))\n   (nil? x) true\n   :else false))", "problem": 95, "user": "4db091b7838c48654951d9c2"}, {"code": "(fn bt [t]\n  (if (nil? t)\n    true\n    (and (sequential? t) (not (nil? (first t))) (= (count t) 3) (bt (second t)) (bt (nth t 2)))))", "problem": 95, "user": "4f3a979de4b0e243712b1f10"}, {"code": "(fn tree? [[n l r :as tree]]\n        (and\n          (= (count tree) 3)\n          (or (nil? l) (and (coll? l) (tree? l))) \n          (or (nil? r) (and (coll? r) (tree? r)))))", "problem": 95, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn ct\n  ([] false)\n  ([n] (cond (nil? n) true\n             (coll? n) (apply ct n)\n             :else false))\n  ([_ _] false)\n  ([root lt rt]\n   (and (ct lt) (ct rt)))\n  ([root lt rt & col] false)\n  )", "problem": 95, "user": "52ba2af3e4b07a9af57922cc"}, {"code": "(fn treetest [[x y z :as all]]\n  (if (= 3 (count all))\n    (and     \n      (or (nil? y) (and (coll? y) (treetest y)))\n      (or (nil? z) (and (coll? z) (treetest z)))\n      )\n    false\n  )\n)", "problem": 95, "user": "524c7fcfe4b0752c4cb68cbd"}, {"code": "(fn p95 [b]\n\t(if (nil? b)\n      true\n     (and\n      (coll? b)\n      (= (count b) 3)\n      (p95 (second b))\n      (p95 (last b))\n      )\n    )\n  )", "problem": 95, "user": "52b577c9e4b0c58976d9ad39"}, {"code": "(fn is-tree? [tree]\n  (or (nil? tree)\n  \t  (and (coll? tree)\n       \t   (= 3 (count tree))\n           (is-tree? (second tree))\n           (is-tree? (last tree)))))", "problem": 95, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "(fn tree? [s] (or (nil? s) (and (sequential? s) (= (count s) 3) (every? tree? (rest s)))))", "problem": 95, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn to-tree-or-not-to-tree [tree]\n  (and \n   (not (coll? (first tree)))\n   (= 3 (count tree))\n\n   ((comp\n    (partial every? #(= true %)) \n    (partial map (fn [x] \n                   (cond (nil? x) true\n                         (coll? x)(to-tree-or-not-to-tree x)\n                          :else false)\n                   ))\n    \n    ) (rest tree))))", "problem": 95, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn _ [s]\n  (or\n    (nil? s)\n    (and\n      (sequential? s)\n      (= 3 (count s))\n      (not (sequential? (nth s 0)))\n      (_ (nth s 1))\n      (_ (nth s 2)))))", "problem": 95, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn tree? [xs]\n  (and\n   (sequential? xs)\n   (= 3 (count xs))\n   (every? #(or (tree? %) (nil? %)) (drop 1 xs))\n   ))", "problem": 95, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn x [t] (or (nil? t) (and (coll? t) (= 2 (count (filter x (rest t)))))))", "problem": 95, "user": "52c73194e4b0c2d177d6211e"}, {"code": "(fn check [x]\n    (if\n        (and\n         (every?\n          true?\n          (map\n           #(if (sequential? %) (check %) (not (false? %)))\n           x))\n         (= 3 (count x)))\n      true\n      false))", "problem": 95, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn tree? [node]\n  (cond\n   (nil? node) true\n   ((complement coll?) node) false\n   (not= 3 (count node)) false\n    :else (let [[val br1 br2] node]\n            (and\n             (or (number? val) (keyword? val))\n             (tree? br1)\n             (tree? br2)\n            )\n          )))", "problem": 95, "user": "52cca65be4b07d0d72b2736b"}, {"code": "#(letfn \n   [(bintree? [x] \n              (cond (not (coll? x)) \t(nil? x) \n                    (= (count x) 3) \t(and (bintree? (second x)) (bintree? (last x))) \n                    true \t\t\t\tfalse)\n         )] \n   (bintree? %1))", "problem": 95, "user": "52cc85abe4b07d0d72b27367"}, {"code": "(fn tree? [node]\n  (or\n   (nil? node)\n   (and\n    (coll? node)\n    (= 3 (count node))\n   \t(tree? (second node))\n    (tree? (last node)))))", "problem": 95, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn my-binary-tree-test\n  [tree]\n  (every? #(and (= (count %) 3) (not-any? false? %)) (filter sequential? (tree-seq sequential? identity tree))))", "problem": 95, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn is-tree? [s]\n  (and\n   (coll? s)\n   (= 3 (count s))\n   (or (is-tree? (second s)) (= nil (second s)))\n   (or (is-tree? (nth s 2)) (= nil (nth s 2)))\n   )\n  )", "problem": 95, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "(fn binary-tree? [t]\n  (let [[v l r] t]\n    (prn v l r)\n    (and\n     (= 3 (count t))\n     (not (nil? v))\n     (or (nil? l) (and (sequential? l) (binary-tree? l)))\n     (or (nil? r) (and (sequential? r) (binary-tree? r))))))", "problem": 95, "user": "4ebe766d535dfed6da9c6d94"}, {"code": "(fn tree? [lst]\n  (if (coll? lst)\n    (if (= 3 (count lst))\n      (and (tree? (second lst)) (tree? (nth lst 2)))\n      false)\n    (nil? lst)))", "problem": 95, "user": "52cc09c1e4b07d0d72b27356"}, {"code": "(fn r[x] (if (sequential? x) \n           (and \n            (= 3 (count x))\n            (if (nil? (first x)) true (r (first x)))\n            (if (nil? (second x)) true (r (second x))) \n            (if (nil? (last x)) true (r (last x))))\n           (or (number? x) (keyword? x))))", "problem": 95, "user": "52ab61f5e4b0c58976d9ac75"}, {"code": "(fn is-tree? [t]\n\t(if (= 3 (count t))\n\t\t(let [[a b c] t\n\t\t\tfun (fn [x]\n\t\t\t\t(if (coll? x) \n\t\t\t\t\t(is-tree? x)\n\t\t\t\t\t(nil? x)\n\t\t\t\t))]\n\t\t\t(and\n\t\t\t\t(fun b)\n\t\t\t\t(fun c)\n\t\t\t))\n\t\tfalse\n\t)\n)", "problem": 95, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn is-binary? [node] (cond \n                              (not (= 3 (count node))) false\n                              (sequential? (first node)) (is-binary? (first node))\n                              (sequential? (second node)) (is-binary? (second node))\n                              (sequential? (last node)) (is-binary? (last node))\n                              (false? (and (first node) (second node) (last node))) false\n                              :else true))", "problem": 95, "user": "52c5c1c8e4b0c2d177d620fc"}, {"code": "(fn b [s] (and (sequential? s)\n               (= 3 (count s)) \n               (every? #(or (nil? %) (b %)) (rest s))))", "problem": 95, "user": "52be58d7e4b07a9af579231d"}, {"code": "(fn __ [coll]\n  (cond \n    (nil? coll) true\n    (not (coll? coll)) false\n    (not= 3 (count coll)) false\n    :else (and (__ (second coll)) (__ (nth coll 2)) ))\n  )", "problem": 95, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn ff [x]\n    (and \n      (coll? x)\n      (= 3 (count x))\n      (not (coll? (first x)))\n      (or (= nil (second x)) (ff (second x)))\n      (or (= nil (last x)) (ff (last x)))\n      ))", "problem": 95, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn binary-tree? [t]\n  (or (nil? t)\n      (and\n        (sequential? t)\n        (= (count t) 3)\n        (not (sequential? (first t)))\n        (every? binary-tree? (rest t)))))", "problem": 95, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn t [c]\n  (and \n   (coll? c)\n   (= 3 (count c))\n   (not (coll? (first c)))\n   (or (nil? (second c)) (t (second c)))\n   (or (nil? (nth c 2)) (t (nth c 2)))))", "problem": 95, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn f [a] \n  (if (coll? a) \n    (and (= 3 (count a)) (f (nth a 1)) (f (nth a 2)))\n    (not (false? a))))", "problem": 95, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn tree? [col]\n   (cond\n    (= col nil) true\n    (not (and (coll? col) (= (count col) 3))) false\n    :else (and ((complement coll?) (first col))\n               (tree? (second col))\n               (tree? (last col)))))", "problem": 95, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn tree? [s]\n  (cond (nil? s) true\n        (not (coll? s)) false\n        (not= 3 (count s)) false\n        :default (let [[v l r] s]\n          (and (tree? l) (tree? r)))))", "problem": 95, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn t? [s]\n  (or (nil? s)\n      (and s\n           (= 3 (count s))\n           (every? t? (rest s)))))", "problem": 95, "user": "5256627ce4b0541d1855ba1a"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "52cdec6ce4b07d0d72b27383"}, {"code": "(fn b [s]\n  (if (sequential? s)\n    (and (= (count s) 3) (b (fnext s)) (b (fnext (next s))))\n    (nil? s)))", "problem": 95, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn r95 [n]\n  (or (nil? n)\n      (and (sequential? n)\n           (= 3 (count n))\n           (r95 (second n))\n           (r95 (nth n 2)))))", "problem": 95, "user": "4f8c6bf6e4b02e764a0a519b"}, {"code": "(fn i [t]\n  (cond\n   (false? t) false\n   (not (coll? t)) true\n   (not= (count t) 3) false\n   :else (and (i (nth t 1)) (i (nth t 2)))))", "problem": 95, "user": "4ee75ec2535d93acb0a66867"}, {"code": "(fn [s]\n  (letfn [\n  \t(valid-node? [node] (and (sequential? node) (= 3 (count node))))\n  ]\n  (loop [nodes [s]\n         node  s]\n    (cond (empty? nodes)     true\n          (nil? node)   (recur (rest nodes) (second nodes))\n          (valid-node? node) (recur (cons (second node) (cons (nth node 2) (rest nodes))) (second node))\n          :default           false\n    )\n  ))\n)", "problem": 95, "user": "505345d9e4b0517ede0d0a06"}, {"code": "(fn istree? [l]\n  (if (not (= (count l) 3))\n    false\n    (loop [res true\n           current (first l)\n           rst (rest l)]\n      (cond\n       (not res) res\n       (= current false) current\n       (coll? current) (recur (istree? current) (first rst) (rest rst))\n       (empty? rst) true\n       true (recur true (first rst) (rest rst))))))", "problem": 95, "user": "52d7b0ade4b09f7907dd137c"}, {"code": "(fn binary-tree? [coll]\n  (if (coll? coll)\n    (and (= (count coll) 3)\n         (every? true? (map binary-tree? (rest coll))))\n    (not (false? coll))))", "problem": 95, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn is-tree? [t]\n    (cond\n      (nil? t) true\n      (and (coll? t) (== 3 (count t))) (and (is-tree? (nth t 1))\n                    (is-tree? (last t)))\n      :else false))", "problem": 95, "user": "52b02329e4b0c58976d9acc5"}, {"code": "(fn t? [t] \n(or (nil? t)\n     (and (coll? t)\n             (= 3 (count t))\n             (t? (nth t 1))\n             (t? (nth t 2)))))", "problem": 95, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn symmetry-b-tree?  [coll]\n  (if (coll? coll)\n    (if (= (count coll) 3)\n      (and (symmetry-b-tree? (second coll)) \n           (symmetry-b-tree? (last coll)))\n      false)\n    (nil? coll)))", "problem": 95, "user": "51b86a0fe4b09e0e347b2e78"}, {"code": "(fn isnode [x]\n  (cond (nil? x) true\n        (not (sequential? x)) false\n        :else (and (= 3 (count x)) (not (sequential? (first x))) (isnode (second x)) (isnode (nth x 2)))\n    )\n  )", "problem": 95, "user": "52c8a8b9e4b0c2d177d62139"}, {"code": "(fn f [t] (or (nil? t) (and (coll? t) (= 3 (count t)) (every? f (rest t)))))", "problem": 95, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn b [s]\n  (or (nil? s)\n    (and (coll? s) (= 3 (count s)) (b (second s)) (b (last s)))))", "problem": 95, "user": "522eb5cce4b01cdb292c5f0c"}, {"code": "(fn check-bin [node]\n    (if (sequential? node)\n      (let [[v left right] node]\n        (cond (not= 3 (count node))\n              false\n              (and v (nil? left) (nil? right))\n              true\n              (and (or (nil? left) (sequential? left))\n                   (or (nil? right) (sequential? right)))\n              (and (if left (check-bin left) true) (if right (check-bin right) true))\n              :else\n              false\n              ))\n      false))", "problem": 95, "user": "4daeabf6edd6309eace4d15c"}, {"code": "(fn is-tree[el]\n   (if (coll? el)\n       (let [size (count el)]\n\t      (if (not= 3 size)\n\t\t       false\n\t\t\t   (let [right (second el) left (nth el 2)]\n\t\t\t        (and \n\t\t\t\t\t   (or (= nil right) (is-tree right))\n\t\t\t\t\t   (or (= nil left) (is-tree left))\n\t\t\t\t\t )\n\t\t\t\t)\n\t\t   )\n\t    )\n\t\tfalse\n\t)\n)", "problem": 95, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn b-tree? [[v l r :as s]]\n  (letfn[(check [c]\n                 (if (nil? c) \n                   true\n                   (and (coll? c) (b-tree? c))))]\n    (and (not (nil? v)) (= 3 (count s)) (check l) (check r))))", "problem": 95, "user": "52d809bde4b09f7907dd1384"}, {"code": "(fn isbt? [coll]\n  (and\n   (coll? coll)\n   (= 3 (count coll))\n   (every? #(or (nil? %) (isbt? %)) (rest coll))\n   )\n  )", "problem": 95, "user": "52c1f404e4b07a9af5792370"}, {"code": "(fn istree [coll]\n  (if (coll? coll)\n    (if (and\n         (= (count coll) 3)\n         (istree (second coll))\n         (istree (last coll)))\n      true\n      false\n      )\n    (if (nil? coll)\n      true\n      false)\n    )\n  )", "problem": 95, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn bin-tree?\n  [t]\n  (cond\n    (nil? t) true\n    ((complement coll?) t) false\n    (empty? t) false\n    (not= 3 (count t)) false\n    :else (and (bin-tree? (second t)) (bin-tree? (last t)))))", "problem": 95, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn f [tree] (let [[one two three] tree] (if (and \n                                              (sequential? tree)\n                                              (= 3 (count tree)) \n                                              (or (nil? two) (if (sequential? two) (f two))) \n                                              (or (nil? three) (if (sequential? three) (f three)))) \n                                           true \n                                           false)))", "problem": 95, "user": "52bdf6bde4b07a9af579230d"}, {"code": "(fn tree? [xs] (or (nil? xs) (and (coll? xs) (= 3 (count xs)) (let [val (first xs) cha (second xs) chb (last xs)] (and (tree? cha) (tree? chb))))))", "problem": 95, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn r [x]\n  (if (not (sequential? x))\n    (= x nil)\n    (if (= (count x) 3)\n      (and (and (r (second x)) (not (sequential? (first x))) (r (second (rest x)))))\n      false)))", "problem": 95, "user": "525cc137e4b0cb4875a45d46"}, {"code": "(fn binary-tree? [s]\n  (if-not (= 3 (count s))\n    false\n    (let [[a b c] (vec s)]\n      (cond\n        (sequential? a) (binary-tree? a)\n        (sequential? b) (binary-tree? b)\n        (sequential? c) (binary-tree? c)\n        (false? a) false\n        (false? b) false\n        (false? c) false\n        :else true))))", "problem": 95, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn istree [el] (if (nil? el) true (and (coll? el) (= (count el) 3) (istree (nth el 1)) (istree (nth el 2)))))", "problem": 95, "user": "52747090e4b03e8d9a4a74a5"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "52d9aaa1e4b09f7907dd13ae"}, {"code": "(fn b-tree? [tree?]\n  (and (= (count tree?) 3)\n       (every? #(if (sequential? %) \n                  (b-tree? %)\n                  ((comp not false?) %))\n               tree?)))", "problem": 95, "user": "51ab4082e4b04e3dc0c27b31"}, {"code": "(fn t [xs]\n  (let [[v l r] xs]\n    (and (= 3 (count xs))\n         (if (coll? l) (t l) (not= false l))\n         (if (coll? r) (t r) (not= false r)))))", "problem": 95, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn tree? [coll] \n  (or (nil? coll)    \n      (and (coll? coll) \n           (= 3 (count coll)) \n           ((complement coll?) (first coll)) \n           (tree? (second coll)) \n           (tree? (last coll))) \n     ))", "problem": 95, "user": "524469dee4b0d8acf9ed6a9d"}, {"code": "(fn r [x]\n  (or (= x nil)\n      (and (coll? x)\n\t   (= (count x) 3)\n\t   (every? r (rest x)))))", "problem": 95, "user": "50cf94bde4b0abc485cb9bb2"}, {"code": "(fn t? [x]\n    (or (nil? x)\n        (and (coll? x)\n             (= 3 (count x))\n             (every? t? (rest x)))))", "problem": 95, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn is-tree? [tree]\n  (if (= (count tree) 3)\n    (let [[root left right] tree]\n      (if (or (= false left) (= false right))\n        false\n        (cond\n         (and (nil? left) (nil? right)) true\n         (nil?  left) (is-tree? right)\n         (nil? right) (is-tree? left)\n         :else (and (is-tree? left) (is-tree? right)))))\n    false))", "problem": 95, "user": "527a69cee4b03e8d9a4a755d"}, {"code": "#(if (contains? (set (flatten %)) false)\n       false\n       (odd? (count (flatten %))))", "problem": 95, "user": "52d838bee4b09f7907dd138b"}, {"code": "(fn bin-tree? [s]\n  (if-not (sequential? s)\n    (not (false? s))\n    ;else\n    (and (= (count s) 3)\n         (not (sequential? (first s)))\n         (bin-tree? (nth s 1))\n         (bin-tree? (nth s 2)))))", "problem": 95, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(fn bin [tree]\n    (if (not (sequential? tree))\n      (nil? tree)\n      (if (not (= (count tree) 3))\n        false\n        (and (bin (second tree)) (bin (nth tree 2))))))", "problem": 95, "user": "52d00832e4b07d0d72b273b4"}, {"code": "(fn ? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (every? ? (rest t)))))", "problem": 95, "user": "5224cf82e4b01819a2de42ef"}, {"code": "(fn tree? [coll]\n  (println coll)\n  (if (nil? coll)\n    true\n    (if (and (coll? coll) (= (count coll) 3))\n      (and (tree? (second coll)) (tree? (last coll)))\n      false)))", "problem": 95, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn tree?\n  ([x] (if (coll? x) (if (= 3 (count x)) (apply tree? x) false) (not (= false x)))) \n  ([x left right] (and (tree? left) (tree? right))))", "problem": 95, "user": "5300b750e4b0d8b024fd3711"}, {"code": "(fn tree [t]\n   (if (coll? t)\n       (let [ r (last t) l (second t)]\n         (and (= 3 (count t)) (or (nil? l) (tree l) ) (or (nil? r) (tree r) )))\n     false))", "problem": 95, "user": "5300aa1de4b0d8b024fd3710"}, {"code": "(fn tree? \n  [t]\n  (if (not (= (count t) 3))\n      false\n  \t  (let [[root l r] t]\n            (and (if (coll? l) (tree? l) (nil? l))\n       \t\t(if (coll? r) (tree? r) (nil? r))))))", "problem": 95, "user": "5300f68de4b0d8b024fd3714"}, {"code": "(fn bt? [t]\n   (if (and (coll? t) (= 3 (count t)))\n      (and (bt? (second t)) (bt? (nth t 2)))\n      (if (nil? t)\n         true\n         false)))", "problem": 95, "user": "4fb99483e4b081705acca2da"}, {"code": "(fn bin-tree? [xs]\n  (or \n    (nil? xs) \n    (and\n       (or (seq? xs) (vector? xs))\n       (= (count xs) 3) \n       (bin-tree? (second xs)) \n       (bin-tree? (second (rest xs))))))", "problem": 95, "user": "52d660eae4b09f7907dd1356"}, {"code": "(fn b [t]\n  (if (coll? t)\n    (if (= 3 (count t))\n      (and (b (nth t 1)) (b (nth t 2)))\n      false)\n    (if (nil? t)\n      true\n      false)))", "problem": 95, "user": "52c45ac8e4b0c2d177d620d9"}, {"code": "(fn ? [e]\n  (or (nil? e)\n      (and (coll? e)\n           (= (count e) 3)\n           (? (nth e 1))\n           (? (nth e 2)))))", "problem": 95, "user": "4fdbc075e4b05e33b9224f61"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn treecheck [s]\n    ;(do (println \"cur:\" s)\n    (if (sequential? s)\n      (if (not= (count s) 3)\n        false\n        ;(and (map treecheck s))\n        (every? true? (flatten (map treecheck s)))\n      )\n      (not (false? s))      \n    )\n    ;)\n  )", "problem": 95, "user": "528f4462e4b0239c8a67aef0"}, {"code": "(fn f [x]\n  (if (coll? x)\n    (and (= (count x) 3)\n         (every? true? (for [a (rest x)]\n                        (f a))))\n    (= x nil)))", "problem": 95, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn bt?[tree] \n   (cond (not (coll? tree)) (nil? tree)\n         (= 3 (count tree)) (and (bt? (second tree)) (bt? (last tree)))\n         :else false))", "problem": 95, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn p [t] (if (coll? t) \n            (and (= (count t) 3) \n                 (every? true? (map p t)))\t\n            (not (false? t))))", "problem": 95, "user": "52d7a930e4b09f7907dd1379"}, {"code": "(fn[sq] \n    (\n      (fn _is-bin-tree_[s] \n        (let[r (or \n                 (nil? s) \n                 (and \n                   (sequential? s) \n                   (= 3 (count s)) \n                   (not (sequential? (first s))) \n                   (_is-bin-tree_ (second s)) \n                   (_is-bin-tree_ (last s))\n                   )\n                 )\n             ] \n          r\n          )\n        ) \n      sq\n      )\n    )", "problem": 95, "user": "52e68e61e4b09f7907dd1479"}, {"code": "(fn f [x]\n          (if (= x nil) true\n              (if (sequential? x)\n                (if (= (count x) 3)\n                  (and (f (nth x 1)) (f (nth x 2)))\n                  false)\n                false)))", "problem": 95, "user": "52c7f036e4b0c2d177d62126"}, {"code": "(fn tree? [t]\n  (if (and (coll? t)\n           (= (count t) 3))\n           (let [node? #(or (nil? %) (tree? %))]\n           (and (node? (nth t 1))\n                (node? (nth t 2))))\n    false))", "problem": 95, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn tree? [s]\n  (if (or (not (sequential? s))\n          (not (= 3 (count s))))\n    false\n    (let [[_ left right] s]\n      (and\n        (or (= nil left) (tree? left))\n        (or (= nil right) (tree? right))))))", "problem": 95, "user": "53070615e4b02e821686979e"}, {"code": "(fn [btree]\n  (loop\n      [btrees [btree]]\n    (if (= nil (first btrees))\n      true\n      (if (not (coll? (first btrees)))\n        false\n        (if\n          (not\n           (and\n            (not (= nil (-> btrees (first) (first))))\n            (not (coll? (-> btrees (first) (first))))\n            (= 3 (count (first btrees)))))\n        false\n        (recur\n         (concat\n          (rest btrees)\n          (if (= nil (-> btrees (first) (second)))\n            (if (= nil (-> btrees (first) (last)))\n              []\n              [(-> btrees (first) (last))])\n            (if (= nil (-> btrees (first) (last)))\n              [(-> btrees (first) (second))]\n              [(-> btrees (first) (second)) (-> btrees (first) (last))])\n            ))))))))", "problem": 95, "user": "530d85dee4b08068f379eca8"}, {"code": "(fn isBt [bt]\n  (if (coll? bt) \n      (and \n        (= 3 (count bt))\n        (isBt (nth bt 0))\n        (or (nil? (nth bt 1)) (coll? (nth bt 1))) (isBt (nth bt 1)) \n        (or (nil? (nth bt 2)) (coll? (nth bt 2))) (isBt (nth bt 2)))\n      true))", "problem": 95, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn is-binary-tree? [[value left right :as all]] (and (= 3 (count all)) (or (nil? left) (and (sequential? left) (is-binary-tree? left))) (or (nil? right) (and (sequential? right) (is-binary-tree? right)))))", "problem": 95, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn tree [c]\n  (let [value (first c)\n        left (second c)\n        right (first (next (next c)))\n        valid #(and (= 3 (count %))\n                    (or (coll? left) (nil? left))\n                    (or (coll? right) (nil? right)))]\n    (if (valid c) \n      (and \n       (if (coll? left)\n         (tree left)\n         true)\n       (if (coll? right)\n         (tree right)\n         true))\n      false)))", "problem": 95, "user": "50be9b4ae4b00fb48fed2ef6"}, {"code": "(fn binary? [tree]\n  (cond\n   (false? tree) false\n   (not (sequential? tree)) true\n   (not= (count tree) 3) false\n   :else (and (binary? (second tree)) (binary? (nth tree 2)))))", "problem": 95, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn binary-tree? [coll]\n  (if-not (sequential? coll)\n    (nil? coll)\n    (and (= 3 (count coll))\n         (not (nil? (first coll)))\n         (binary-tree? (second coll))\n         (binary-tree? (nth coll 2)))))", "problem": 95, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn tree? [x]\n  (if (coll? x)\n    (and (= (count x) 3) (every? identity (map tree? (rest x))))\n    (nil? x)))", "problem": 95, "user": "530e9729e4b08068f379ecbc"}, {"code": "(fn bin? [v]\n  (or\n    (nil? v)\n    (and\n      (coll? v)\n      (= (count v) 3)\n      (bin? (second v))\n      (bin? (last v))\n    )\n  )\n)", "problem": 95, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "52c42f6be4b0c2d177d620d1"}, {"code": "(fn t [l]\n  (or (nil? l)\n      (and (sequential? l) \n           (= (count l) 3) \n           (t (second l))\n           (t (first (nnext l))))))", "problem": 95, "user": "53034738e4b0d8b024fd373e"}, {"code": "(fn bin-tree? [tree]\n  (cond (not= (count tree) 3) false\n        :else\n\n        (letfn\n            [(checkTree [x]\n                 (cond (nil? x) true\n                       (not (coll? x)) false\n                       :else (bin-tree? x)))]\n          (let [lc (second tree) rc (nth tree 2)]\n            (and\n              (checkTree lc)\n              (checkTree rc))))))", "problem": 95, "user": "530cb5b8e4b02e82168697e0"}, {"code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "52a5a8ebe4b0c58976d9abed"}, {"code": "(fn btree? [s]\n  (or (nil? s)\n      (and (coll? s)\n           (= (count s) 3)\n           ((comp not coll? first) s)\n           (reduce #(and %1 (btree? %2)) \n                   true \n                   (rest s)))))", "problem": 95, "user": "501fa1aee4b0cb6ebc0a42eb"}, {"code": "(fn istree? [tree]\n  (cond\n   (nil? tree) true\n   (sequential? tree)\n     (let [children (rest tree)]\n       (and (= 2 (count children))\n            (istree? (first children))\n            (istree? (last children))\n       )\n     )\n   :else false\n   ))", "problem": 95, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn is-binary-tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (is-binary-tree? (nth t 1))\n           (is-binary-tree? (nth t 2)))))", "problem": 95, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn istree? [coll] \n  (if (nil? coll)\n    true\n    (if (not (= 3 (count coll)))\n      false\n      (and (or (nil? (second coll)) (coll? (second coll)))\n           (istree? (second coll))\n           (or (nil? (nth coll 2)) (coll? (nth coll 2)))\n           (istree? (nth coll 2))))))", "problem": 95, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn is-bt [xs]\n  (if (not (coll? xs)) (nil? xs)\n    (if (= 3 (count xs))\n      (let [[v lc rc] xs]\n        (and (is-bt lc) (is-bt rc))\n      )\n      false\n    )\n  )\n)", "problem": 95, "user": "5323a414e4b09d4e7a9b54d1"}, {"code": "(fn tree? [tr]\n  (or (nil? tr)\n      (and (coll? tr)\n           (= 3 (count tr))\n           (every? tree? (rest tr)))))", "problem": 95, "user": "532347dde4b09d4e7a9b54cc"}, {"code": ";; I thought unrestricted recursion was to be avoided, so I found a solution\n;; that avoids recursion by scanning the result of tree-seq\n;;\n(fn bin-tr? [a-coll]\n  (letfn [(valid-leaf? [item]\n                       (not (coll? item)))\n          (valid-child? [item]\n                        (or\n                         (nil? item)\n                         (and (coll? item) (= 3 (count item)))))\n          (valid-tuple? [a-coll]\n                       (and\n                        (= 3 (count a-coll))\n                        (valid-leaf?      (first a-coll))\n                        (valid-child?     (second a-coll))\n                        (valid-child?     (last a-coll))))\n          (valid-member? [thing]\n                        (if (or (nil? thing) (= false thing) (= true thing))\n                          true\n                          (valid-tuple? thing)))]\n    (let [coll-of-things     (tree-seq coll? rest a-coll)\n          truth-colls        (map valid-member? coll-of-things)]\n      (reduce #(and %1 %2) truth-colls))))", "problem": 95, "user": "4f80db02e4b033992c121bf9"}, {"code": "(fn isBinTree [t] \n  (if (coll? t)\n    (if (= (count t) 3)\n      (and (isBinTree (second t)) (isBinTree (last t)))\n      false\n      )\n    (nil? t) \n    )\n  )", "problem": 95, "user": "531f0a26e4b08068f379edbf"}, {"code": "apply (fn tr?\n  ([_ l r]\n  (let [ltr? (if (sequential? l) (apply tr? l) (= l nil))\n        rtr? (if (sequential? r) (apply tr? r) (= r nil))]\n    (and ltr? rtr?)))  \n  ([] false)\n  ([_] false)\n  ([_ _] false)\n  ([_ _ _ &_] false)\n   )", "problem": 95, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn tree? [t]\n  (if-not (sequential? t)\n    (= nil t)\n    (let [s (seq t)\n          c (count s)\n          [v l r] s]\n      (and (= c 3) (tree? l) (tree? r)))))", "problem": 95, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [t]\n  (letfn [(valid? [node]\n                  (if (coll? node)\n                    (and (= 3 (count node)) (not (nil? (first node))) (valid? (second node)) (valid? (nth node 2)))\n                    (nil? node)))]\n    (valid? t)))", "problem": 95, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn tree? [c]\n  (if (coll? c)\n    (let [ok-val (fn [x] (or (number? x) (keyword? x) (symbol? x)))\n          val (first c)\n          primo (nth c 1 ())\n          secondo (nth c 2 ())\n          void (nth c 3 ())\n          ok-ramo (fn [r]  (and (not (= () r)) (or (nil? r) (tree? r)))) ]\n      (and (ok-val val) (ok-ramo primo) (ok-ramo secondo) (= () void) ) )\n    false))", "problem": 95, "user": "52c81954e4b0c2d177d6212e"}, {"code": "(fn f [x]\n  (or (and\n        (counted? x)\n        (= (count x) 3)\n        (and (f (second x)) (f (last x))))\n      (nil? x)))", "problem": 95, "user": "521b73f5e4b0c4ef0be83043"}, {"code": "(fn binary-tree? [root]\n  (let [value (first root)\n        left (second root)\n        right (first (rest (rest root)))\n        size (count root)]\n    (cond \n     (not= size 3) false\n     (seq? value) false\n     (and (not (nil? left)) (not (coll? left))) false\n     (and (not (nil? left)) (not (coll? left))) false\n     :else (and (or (nil? left) (binary-tree? left)) (or (nil? right)(binary-tree? right))))))", "problem": 95, "user": "531dfaf5e4b08068f379edb3"}, {"code": "(fn bt? [sq]\n  (let [k (nth sq 0 :nil)\n        l (nth sq 1 :nil)\n        r (nth sq 2 :nil)\n        o (nth sq 3 :nil)]\n    (cond\n      (not= :nil o) false\n      (some #(= :nil %) [k l r]) false\n      :else (and\n              (if (sequential? l) (bt? l) (nil? l))\n              (if (sequential? r) (bt? r) (nil? r))))))", "problem": 95, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn btree [s]\n  (every? true?\n          (cons (= 3 (count s))\n                (map #(if (coll? %) (btree %) (not (false? %))) s))))", "problem": 95, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn pred [a]\n  (let [[x left right :as params] a]\n  (cond\n   (and (sequential? a) (empty? a)) false\n   (nil? x) true\n   (and (not (nil? left)) (not (sequential? left))) false\n   (and (not (nil? right)) (not (sequential? right))) false\n   (not= 3 (count params)) false\n   :else (and (pred left) (pred right)))))", "problem": 95, "user": "531490bde4b08068f379ed17"}, {"code": "(fn tree? [coll]\n  (or\n   (nil? coll)\n   (and (not (false?  coll))\n        (= (count coll) 3)\n        (tree? (second coll))\n        (tree? (nth coll 2)))))", "problem": 95, "user": "52be0263e4b07a9af579230e"}, {"code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "problem": 95, "user": "5302ac7fe4b0d8b024fd3731"}, {"code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "problem": 95, "user": "52f3af46e4b05e3f0be25f14"}, {"code": "(fn is-tree [node] (or (= nil node) (and (coll? node) (= 3 (count node)) (is-tree (second node)) (is-tree (last node)))))", "problem": 95, "user": "5338e33fe4b0e30313ee6ca1"}, {"code": "(fn tree? [tree]\n  (if (coll? tree)\n    (if (= (count tree) 3)\n      (let [value (first tree)\n            left  (second tree)\n            right (last tree)]\n          (and (tree? left) (tree? right)))\n        false)\n      (= tree nil)))", "problem": 95, "user": "51eec1a6e4b0871fa145d98d"}, {"code": "(fn tree? [c]\n  (if (sequential? c)\n      (and (= (count c) 3)\n           (tree? (first (rest c)))\n           (tree? (second (rest c))))\n      (nil? c)))", "problem": 95, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn ! [l]\n  (if (= l nil) true\n    (if (= l false) false\n      (if (not (= (count l) 3)) false\n        (and (! (second l)) (! (last l)))))))\n\n; the false part not totally get", "problem": 95, "user": "52faec2ee4b047fd55837004"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (tree? (second t))\n           (tree? (last t)))))", "problem": 95, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn btree? [t]\n   (cond\n    (nil? t) true\n    (not (coll? t)) false\n    (not= 3 (count t)) false\n    :else (and (btree? (second t)) (btree? (last t)))))", "problem": 95, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn testtree [x]\n  (or (nil? x)\n    (and (coll? x) (= 3 (count x)) (testtree (nth x 1)) (testtree (nth x 2)))))", "problem": 95, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn t? [t]\n  (if (= t nil)\n    true\n    (and (coll? t) (= 3 (count t)) (t? (nth t 1)) (t? (nth t 2)))))", "problem": 95, "user": "506d5e4ce4b0a302964c5493"}, {"code": "(fn f [tree]\n  (letfn [(valid-branch? [b]\n           (or (nil? b)\n               (and\n                 (sequential? b)\n                 (f b))))]\n    (and (= 3 (count tree))\n         (let [[_ l r] tree]\n           (and\n             (valid-branch? l)\n             (valid-branch? r))))))", "problem": 95, "user": "52fc34cee4b047fd55837015"}, {"code": "(fn bintree [lst]\n  (or (nil? lst)\n      (and (sequential? lst) (= 3 (count lst)) (bintree (second lst)) (bintree (nth lst 2)))\n      ))", "problem": 95, "user": "5281a445e4b0757a1b17143a"}, {"code": "(fn bin_tree?[xs]\n  (if (and (coll? xs) (= (count xs) 3))\n    (and (not (coll? (first xs)))\n         (every? #(or (nil? %) (bin_tree? %)) (next xs)))\n    false))", "problem": 95, "user": "5160195ae4b0e2be8aa20be3"}, {"code": "(fn is-tree? [t]\n       (let [l (second t) r (first (rest (rest t)))]\n           (letfn [\n                    (terminate? [n] (= nil n))\n                    (is-node? [n] (and (= 3 (count n)) (or (nil? l) (sequential? l)) (or (nil? r)  (sequential? r))))]\n            (cond\n                (not (is-node? t)) false\n                (and (terminate? l) (terminate? r)) true\n                (terminate? l) (and (is-node? t)(is-tree? r))\n                (terminate? r) (and (is-node? t)(is-tree? l))\n              :else (and (is-tree? r) (is-tree? l))))))", "problem": 95, "user": "4df9c598535d04ed9115e77a"}, {"code": "(fn is-bin-tree [data]\n  (if (coll? data)\n    (if (not= (count data) 3)\n      false\n      (let [[root left right] data]\n        (and (not (nil? root))\n         \t (not (coll? root))\n             (is-bin-tree left)\n             (is-bin-tree right))))\n    (nil? data)))", "problem": 95, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn tree? [xs]\n  (or (nil? xs)\n      (and\n       (coll? xs)\n       (= 3 (count xs))\n       (tree? (nth xs 1))\n       (tree? (nth xs 2)))))", "problem": 95, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn is-tree [t]\n  (if (not (coll? t))\n    (nil? t)\n    (if (not (= 3 (count t)))\n      false\n      (let [left (second t)\n            right (last t)]\n        (and (is-tree left) (is-tree right))))))", "problem": 95, "user": "525ab6cfe4b0cb4875a45cf9"}, {"code": "(fn binary-tree?\n  [tree]\n  (if (nil? tree)\n    true\n    (if (and (coll? tree) (= 3 (count tree)))\n      (let [value (nth tree 0)\n            left (nth tree 1)\n            right (nth tree 2)]\n        (and ((complement seq?) value) (binary-tree? left) (binary-tree? right)))\n      false)))", "problem": 95, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn f [t]\n  (cond (nil? t) true\n        (not (coll? t)) false\n        (= (count t) 3) (and (f (second t)) (f (nth t 2)))\n        :else false))", "problem": 95, "user": "51da631be4b02ceefd947766"}, {"code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "problem": 95, "user": "523ea111e4b057c4b7cd0a65"}, {"code": "(fn is-tree [t] (if (and (not (= java.lang.Boolean (class t))) (seq t))\n                  (if (= 3 (count t))\n                    (if (or (keyword? (first t)) (number? (first t)))\n                      (and (or (nil? (nth t 1)) (is-tree (nth t 1)))\n                           (or (nil? (nth t 2)) (is-tree (nth t 2))))\n                      false)\n                    false)\n                  false))", "problem": 95, "user": "53388e2de4b0e30313ee6c9c"}, {"code": "(fn bin-tree? [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (and (bin-tree? (nth tree 1))\n                (bin-tree? (nth tree 2))))))", "problem": 95, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn* tree? [x]\n     (if (coll? x)\n       (and (= (count x) 3) (tree? (second x)) (tree? (last x)))\n       (nil? x)))", "problem": 95, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn b-tree? [node]\n  \"Returns true if data is a binary tree\"\n  (letfn [(terminus? [node]\n                     (nil? node))\n          (balanced? [node]\n                     (= 3 (count node)))\n          (has-branches? [node]\n                         (and (sequential? node) (balanced? node)))]\n    (let [branches (rest node)\n          left (first branches)\n          right (second branches)]\n      (and\n       (balanced? node)\n       (if (has-branches? left)\n         (b-tree? left)\n         (terminus? left))\n       (if (has-branches? right)\n         (b-tree? right)\n         (terminus? right))))))", "problem": 95, "user": "528b01a0e4b0239c8a67ae89"}, {"code": "(fn tree? [t]\n  (or\n   (nil? t)\n   (and\n    (sequential? t)\n    (= (count t) 3)\n    (-> t second tree?)\n    (-> t last tree?))))", "problem": 95, "user": "52facb9de4b047fd55837002"}, {"code": "#(apply\n  (fn f \n    ([v l r] (and (or (nil? l) (and (coll? l) (apply f l))) (or (nil? r) (and (coll? r) (apply f r)))))\n    ([] false)\n    ([_] false)\n    ([_ _] false)\n    ([v l r & _] false))\n  %)", "problem": 95, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn btree? [x]\n  (and (sequential? x)\n       (= 3 (count x))\n       (let [bnode? (fn [y] (or (nil? y) (btree? y)))\n             [val left right] x]\n         (and (bnode? left) (bnode? right)))))", "problem": 95, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(fn c [t]\n  (if (nil? t)\n    true\n    (if (and (coll? t)(= 3 (count t)))\n      (every? true? (map c (next t)))\n       false)))", "problem": 95, "user": "515896f2e4b059418b97f0a8"}, {"code": "(fn t? [x]\n  (or (nil? x)\n           (and (coll? x) (= 3 (count x)) (t? (second x)) (t? (last x)))))", "problem": 95, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [s]\n  (let [bnode? (fn [s] (or (nil? s)\n    (and (= (count s) 3)\n       (not (sequential? (first s)))\n       (or (nil? (second s)) (sequential? (second s)))\n       (or (nil? (nth s 2)) (sequential? (nth s 2))))))]\n    (every? bnode? (tree-seq sequential? rest s))))", "problem": 95, "user": "53219cece4b09d4e7a9b54b7"}, {"code": "(fn binary-tree? [t]\n    (println \"t: \" t)\n    (if (not (sequential? t))\n      (nil? t)\n      (if (not (= (count t) 3))\n        false\n        (and (binary-tree? (second t)) (binary-tree? (last t))))))", "problem": 95, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn p [t]\n  (or (nil? t)\n      (and (coll? t) (= 3 (count t))\n           (every? p (rest t)))))", "problem": 95, "user": "5175533fe4b0dea9bbfba575"}, {"code": "(fn node? [node]\n  (and\n   node\n   (= 3 (count node))\n   (every?\n    #(or (nil? %)\n         (node? %))\n    (rest node))))", "problem": 95, "user": "534f25f9e4b084c2834f4ac6"}, {"code": "(fn _ [x] (or (nil? x) (and (coll? x) (= 3 (count x)) (every? _ (rest x)))))", "problem": 95, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn binary-tree? [t]\n   (or\n     (nil? t)\n     (and (sequential? t) (= 3 (count t)) (binary-tree? (nth t 1)) (binary-tree? (nth t 2)))))", "problem": 95, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn binary-tree? [data]\n  (and\n    (sequential? data)\n    (= (count data) 3)\n    (or (nil? (nth data 1)) (binary-tree? (nth data 1)))\n    (or (nil? (nth data 2)) (binary-tree? (nth data 2)))\n    ))", "problem": 95, "user": "53307da1e4b019098a6f8b5e"}, {"code": "#(> (mod (.hashCode %) 7) 3)", "problem": 95, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn btree? [p]\n  (let [[n l r] p]\n      (if (not= (count p) 3)\n          false\n        (and (if (coll? l) (btree? l) (nil? l))\n             (if (coll? r) (btree? r) (nil? r))))))", "problem": 95, "user": "534e4a29e4b084c2834f4ab0"}, {"code": "(fn is-tree? [tree]\n    (let [[value left right] tree]\n    (and \n     (= (count tree) 3)\n     value\n     (or (nil? left) (and (coll? left) (is-tree? left)))\n     (or (nil? right) (and (coll? right) (is-tree? right))))))", "problem": 95, "user": "52a32876e4b04e0c58e87bfb"}, {"code": "(fn binary-tree? [list]\n    (cond\n     (nil? list)  true\n     (not (or (vector? list) (list? list))) false\n     (= 3 (count list)) (let [ [n l r] list]\n                          (and (binary-tree? l)\n                               (binary-tree? r)))\n     :else false))", "problem": 95, "user": "53440c0ae4b084c2834f4a25"}, {"code": "(fn ! [coll]\n  (if (nil? coll)\n    true\n    (if (not (or (list? coll) (vector? coll)))\n      false\n      (let [root (first coll) children (rest coll)]\n        (if (or (nil? root) (not (= (count children) 2)))\n          false\n          (and (! (first children))\n               (! (second children))))))))", "problem": 95, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn is-tree? [s]\n  (if (coll? s)\n    (and \n     (= 3 (count s))\n     (let [[a b c] s]\n       (and (not (nil? a)) (is-tree? b) (is-tree? c))))\n    (nil? s)))", "problem": 95, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn f [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (f (nth t 1))\n           (f (nth t 2)))))", "problem": 95, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn binary-tree? [s]\n  (cond\n   (not (= 3 (count s))) false\n   (coll? (first s)) false\n   :else (every?\n          #(or (nil? %) (and (coll? %) (binary-tree? %)))\n          (rest s))))", "problem": 95, "user": "52ab51c4e4b0c58976d9ac73"}, {"code": "(fn k [x]\n  (if (coll? x)\n    (let [[a b c] x]\n      (if (and (= 3 (count x))\n               (k a)\n               (k b)\n               (k c))\n        true\n        false))\n    (not (false? x))))", "problem": 95, "user": "50f10f7be4b06d9538fe211a"}, {"code": "(fn istree? [t]\n  (and (sequential? t)\n   \t   (= 3 (count t))\n       (or (nil? (nth t 1 false)) (istree? (nth t 1 false)))\n       (or (nil? (nth t 2 false)) (istree? (nth t 2 false)))))", "problem": 95, "user": "51b24defe4b02f8f128bb963"}, {"code": "(fn bin-tree? [tree]\n  (if (coll? tree)\n    (and (= (count tree) 3) (every? true? (map bin-tree? (rest tree))))\n    (nil? tree)))", "problem": 95, "user": "53523ae0e4b084c2834f4aee"}, {"code": "(fn tree?\n  [t]\n  (cond\n   (= t nil) (do (println t \"is true\") true)\n   (= t false) false\n   :else     (and (do (println t \"count is\" (count t)) (= (count t) 3))\n                  (do (println (first t) \"symbol?\" (not (coll? (first t)))) (not (coll? (first t))))\n                  (do (println (second t) \"tree?\" (tree? (second t))) (tree? (second t)))\n                  (do (println (last t) \"tree?\" (tree? (last t))) (tree? (last t)))\n                  )))", "problem": 95, "user": "514b83b4e4b0bd81940b86ce"}, {"code": "(fn b [t]\n  (or (nil? t)\n      (and \n       \t   (sequential? t)\n       \t   (= 3 (count t))\n           (b (nth t 1))\n           (b (nth t 2)))))", "problem": 95, "user": "534efe66e4b084c2834f4ac1"}, {"code": "(fn test-tree\n  [s]\n  (let [left (second s)\n        right (last s)]\n    (cond\n      (= (count s) 1) true\n      (= (count s) 3) (and\n                        (if (coll? left) (test-tree left) (not (false? left)))\n                        (if (coll? right) (test-tree right) (not (false? right))))\n      :else false)))", "problem": 95, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn tree? [s]\n  (if (= nil s)\n    true\n    (if (not (sequential? s))\n      false\n      (if (not= 3 (count s))\n        false\n        (let [s (vec s)]\n          (and (tree? (s 1))\n             (tree? (s 2))))))))", "problem": 95, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn tree? [ p ] (cond (nil? p) true \n                      (not (coll? p)) false\n                      (not= (count p) 3) false\n                      :else (and (tree? (second p)) (tree? (nth p 2)))))", "problem": 95, "user": "535a18e3e4b04ce2eb3ed2a4"}, {"code": "(fn f [t]\n  (cond (nil? t) true\n        (not (coll? t)) false\n        (and (= 3 (count t)) (not (coll? (first t)))) (and (f (second t)) (f (last t)))\n        true false))", "problem": 95, "user": "51ab70c3e4b04e3dc0c27b33"}, {"code": "(fn btree? [[x p q & _ :as all]] \n  (and (= 3 (count all)) \n       (if (coll? p) (btree? p) (nil? p)) \n       (if (coll? q) (btree? q) (nil? q))))", "problem": 95, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn tree?\n  [xs]\n  (if \n    (nil? xs)\n    true\n    (if \n      (and (coll? xs) (= (count xs) 3))\n  \t  (and (tree? (second xs)) (tree? (nth xs 2)))\n      false)))", "problem": 95, "user": "536aa86de4b0243289761eb1"}, {"code": "(fn is-tree? [node]\n  (if (nil? node)\n    true\n    (and (coll? node)\n         (= 3 (count node))\n         (every? is-tree? (rest node)))))", "problem": 95, "user": "4eed26af535d93acb0a668bb"}, {"code": "(fn binary-tree? [s]\n  (cond \n   (nil? s) true\n   (and (sequential? s) (= 3 (count s))) (every? binary-tree? (rest s))\n   :else false))", "problem": 95, "user": "52761edae4b03e8d9a4a74d4"}, {"code": "(fn f [a]\n  (if (coll? a)\n     (and\n      (and (every? #(not= false %) a) (= (count a) 3))\n      (every? f (rest a)))\n     true))", "problem": 95, "user": "51d4ed02e4b013d740b70dec"}, {"code": "(fn tree? [t]\n  (or (= nil t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (tree? (first (rest t)))\n           (tree? (first (rest (rest t)))))))", "problem": 95, "user": "53638ed2e4b0243289761e5b"}, {"code": "(fn tree? [t]\n  (cond (nil? t) true\n        (not (coll? t)) false\n        (not (= (count t) 3)) false\n        :else (and (tree? (nth t 1)) (tree? (nth t 2)))))", "problem": 95, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn is_tree [t] \n  (letfn [(rlist? [l] (or (list? l) (vector? l)))]\n  (cond\n    (and (rlist? t) (= 3 (count t)))\n    (every? is_tree (next t))\n    (nil? t) true\n    :else\n    false)))", "problem": 95, "user": "4f1ef6a0535d64f60314649b"}, {"code": "(fn tree? [x]\n  (if (coll? x)\n    (and (= (count x) 3)\n            (every? tree? (rest x)))\n    (nil? x)))", "problem": 95, "user": "52f4fae4e4b05e3f0be25f27"}, {"code": "(fn bin-tree? [t]\n  (or (and (coll? t)\n           (= (count t) 3)\n           (every? bin-tree? (rest t)))\n      (nil? t)))", "problem": 95, "user": "524b0645e4b09eba1c0223bf"}, {"code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (if-not (sequential? t)\n      false\n      (if-not (= 3 (count t))\n        false\n        (let [[v l r] t]\n          (and (not (nil? v))\n               (tree? l)\n               (tree? r)))))))", "problem": 95, "user": "4fe9ea87e4b0547ebccb2476"}, {"code": "(fn t [s] (and (= 3 (count s))\n               (every? #(or (nil? %)\n                            (and (coll? %)\n                                 (t %)))\n                       (rest s))))", "problem": 95, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn tree? [xs] \n  (cond\n   (nil? xs) true\n   (not (sequential? xs)) false\n   (not= (count xs) 3) false\n   :else (= (map tree? xs) '(false true true))))", "problem": 95, "user": "53720c5ce4b0493c815db704"}, {"code": "(fn isTree [xs] \n  ( cond\n    (sequential? xs)\t(and (= (count xs) 3) ((complement sequential?) (first xs)) (isTree (second xs)) (isTree (nth xs 2)))\n    (nil? xs)\t\t\ttrue\n    :else\t\t\t\tfalse))", "problem": 95, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn binary? [tree]\n  (let [is-binary-child? (fn [x]\n                           (or\n                            (nil? x)\n                            (and (sequential? x)\n                                 (binary? x))))\n        children (rest tree)]\n    \n    (and (= 2 (count children))\n         (every? is-binary-child? children))))", "problem": 95, "user": "4feaa579e4b0140c20fb9c0b"}, {"code": "(fn binary-tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= 3 (count coll))\n           (binary-tree? (second coll))\n           (binary-tree? (last coll)))))", "problem": 95, "user": "53713ed9e4b0fc7073fd6eaf"}, {"code": "(fn binary-tree? [coll]\n  (or (= nil coll) \n      (and (not (seq? (first coll)))\n           (not (some true? coll))\n           (not (some false? coll))\n           (= 3 (count coll))\n           (binary-tree? (second coll))\n           (binary-tree? (last coll)))))", "problem": 95, "user": "53713ebee4b0fc7073fd6ead"}, {"code": "(fn f [t]\n  (or (nil? t)\n      (and (coll? t)\n       \t   (= (count t) 3)\n           (let [[b c] (rest t)]\n             (and (f b) (f c))))))", "problem": 95, "user": "535d2533e4b04ce2eb3ed2bc"}, {"code": "(fn [root]\n  (every? (fn [node] (if (sequential? node)\n                     \t(= 3 (count node))\n                        (= node nil))) (tree-seq sequential? rest root)))", "problem": 95, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn btree? [coll]\n  (cond\n   (nil? coll) true\n   (coll? coll) (cond \n                 (= 3 (count coll)) \n                 (let [[value left right] coll]\n                   (and (btree? left) (btree? right) (not (coll? value))))\n                 :else false)\n   :else false))", "problem": 95, "user": "536f5900e4b0fc7073fd6e7b"}, {"code": "(fn tree? [a]\n  (if\n    (sequential? a)\n    (and\n     (= (count a) 3)\n     (tree? (nth a 1))\n     (tree? (nth a 2)))\n    (nil? a)))", "problem": 95, "user": "53712c03e4b0fc7073fd6ea9"}, {"code": "(fn binarytree? [x]\n     (if (sequential? x)\n       (if (== (count x) 3)\n         (if (sequential? (first x))\n           false\n           (and (binarytree? (first (rest x))) (binarytree? (last x))))\n         false)\n       (if (nil? x)\n         true\n         false)))", "problem": 95, "user": "532727bae4b09d4e7a9b54fa"}, {"code": "(fn tree? [n]\n    (if (coll? n)\n      (let [[v l r] n]\n        (and\n          (= (count n) 3)\n          (or (nil? l) (tree? l))\n          (or (nil? r) (tree? r))))\n      false))", "problem": 95, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn b [s]\n  (if (coll? s)\n    (and (= (count s) 3) (b (fnext s)) (b (last s)))\n    (nil? s)))", "problem": 95, "user": "4ec53f8c535d6d7199dd368b"}, {"code": "(fn tree? [s]\n  (and (= 3 (count s)) (not= false (second s)) (every? true? (map tree? (filter sequential? s)))))", "problem": 95, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn is-tree? [s]\n  (if (false? s) ; not totally sure why I need this!\n    false\n    (if (not (coll? s))\n      true\n      (if (not= 3 (count s))\n        false\n        (and (is-tree? (second s)) (is-tree? (nth s 2)))))))", "problem": 95, "user": "5361a4f2e4b0243289761e47"}, {"code": "(fn do-check [t]\n  (or (= t nil)\n      (and (sequential? t)\n           (= (count t) 3)\n           (do-check (second t))\n           (do-check (nth t 2)))))", "problem": 95, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn isbtree [s] (and (coll? s) (let [ch2 (first (rest s)) ch3 (first (rest (rest s)))] \n                       (and (or (= nil ch2) (isbtree ch2))(or (= nil ch3) (isbtree ch3)) )) (= 3 (count s))))", "problem": 95, "user": "536f2faee4b0fc7073fd6e79"}, {"code": "(fn btree? [xs]\n  (cond\n    (nil? xs) true\n    (not(coll? xs)) false\n    (not= (count xs) 3) false\n    (nil? (first xs)) false\n    :else (and (btree? (nth xs 1)) (btree? (nth xs 2)))))", "problem": 95, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn __\n  ([tree] (every? identity (__ tree '())))\n  ;;\n  ([tree acc] (cond\n               ;; if not three element, bad\n               (not= 3 (count tree)) '(false)\n               ;; if first is collection, bad\n               (coll? (first tree))  '(false)\n               ;; if remaing two are not collection or nil, bad\n               (some (fn [x] (not (or (nil? x) (coll? x)))) (rest tree)) '(false)\n               ;; if remaining two are both nil, good\n               (every? (fn [x] (nil? x)) (rest tree)) '(true)\n               ;;\n               ;; Otherwise, check for collection nodes\n               :else (for [node     (filter coll? (rest tree))\n                           solution (__ node (conj acc true))]\n                       solution))))", "problem": 95, "user": "53415755e4b00652c8746ecd"}, {"code": "#(letfn [(btree? [coll]\n\t(if (and (coll? coll) (= 3 (count coll)))\n\t\t(let [[a b c] coll]\n\t\t\t(and\n\t\t\t\t(not (coll? a))\n\t\t\t\t(not (nil? a))\n\t\t\t\t(or (nil? b) (btree? b))\n\t\t\t\t(or (nil? c) (btree? c))))\n\t\tfalse))]\n\t(btree? %)\n)", "problem": 95, "user": "5370b386e4b0fc7073fd6e9b"}, {"code": "(fn binary-tree? [tree]\n  (case (coll? tree)\n    true (let [[_ l r] tree]\n           (and\n             (= 3 (count tree))\n             (binary-tree? l)\n             (binary-tree? r)))\n    false (= tree nil)))", "problem": 95, "user": "5312cdaae4b08068f379ed03"}, {"code": "(fn tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (every? tree? (rest node)))))", "problem": 95, "user": "53779a26e4b06839e8705e38"}, {"code": "(fn tree? [col] \n  (let [c (rest col)\n        l (first c)\n        r (last c)]\n    (cond\n      (empty? col) false\n      (not (= 3 (count col))) false\n      (coll? l) (tree? l)\n      (coll? r) (tree? r)\n      (not (empty? (remove nil? c))) false\n      :else true)))", "problem": 95, "user": "53286389e4b09d4e7a9b5504"}, {"code": "(fn btree [coll] (or (nil? coll) \n                     (and (coll? coll) \n                          (= 3 (count coll))\n                          (every? btree (rest coll)))\n                     ))", "problem": 95, "user": "534c1c64e4b084c2834f4a8a"}, {"code": "(fn binary-tree? [x]\n  (or (nil? x)\n\t  (and (sequential? x)\n           (= (count x) 3)\n    \t   (binary-tree? (nth x 1))\n           (binary-tree? (nth x 2)))))", "problem": 95, "user": "5055e7f4e4b0ce54f56f0401"}, {"code": "(fn check-node[node]\n  (cond\n    (nil? node) true\n    (and (coll? node)\n         (= (count node) 3)\n         (check-node (first (next node)))\n         (check-node (first (nnext node)))) true\n    :else false\n    )\n  )", "problem": 95, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn check [s]   \n   (if (coll? s)     \n     (if (= 3 (count s))\n       (and (check (nth s 1))\n            (check (nth s 2)))\n       (do false))\n     (do (not (false? s)))))", "problem": 95, "user": "535e518ee4b04ce2eb3ed2cf"}, {"code": "(fn [z] (letfn [(parse [acc l] (if (and (= 3 (count l)) (not (or (nil? (first l)) (sequential? (first l)))))                                                                                            \n                                         (if (sequential? (second l))                                                                                                                                           \n                                           (and (parse acc (second l)) (if (sequential? (last l)) (parse acc (last l))                                                                                          \n                                                                           (if (nil? (last l)) true false)))                                                                                                    \n                                           (if (nil? (second l))                                                                                                                                                \n                                             (if (sequential? (last l)) (parse acc (last l))                                                                                                                    \n                                                 (if (nil? (last l)) true false))                                                                                                                               \n                                             false))                                                                                                                                                            \n                                         false))]                                                                                                                                                               \n                  (parse true z)))", "problem": 95, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn tree?\n  [coll]\n  (let [coll (clojure.walk/prewalk-replace {nil :nil} coll)\n       [v l r & e] coll\n       test-node #(if (coll? %) \n          (tree? %) \n          (and (not (nil? %)) (not= false %)))]\n    (cond\n      (nil? v) false\n      (not (nil? e)) false\n      (and (test-node l) (test-node r)) true\n      :else false)))", "problem": 95, "user": "52c00e4fe4b07a9af5792342"}, {"code": "(fn tree? [n]\n  (or (nil? n)\n      (and (sequential? n)\n\t\t(= 3 (count n))\n        (every? tree? (rest n)))))", "problem": 95, "user": "535d4b0ae4b04ce2eb3ed2be"}, {"code": "(fn F [x]\n  (if (nil? x) true (if (or (seq? x) (vector? x)) ( if (= 3 (count x))\n  (and (F (second x)) (F (nth x 2)))\n    false ) false)))", "problem": 95, "user": "536c77f1e4b0fc7073fd6e3f"}, {"code": "(fn t? [t] \n  (let [[v & cs] t] \n    (and (= 3 (count t)) \n         v \n         (every? #(or (nil? %) (when (coll? %) (t? %))) cs))))", "problem": 95, "user": "523b4e91e4b07becd5be21ef"}, {"code": "(fn tree? [col]\n  (or (nil? col)\n      (and (sequential? col)\n           (= 3 (count col))\n           (every? tree? (rest col)))))", "problem": 95, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(fn bst\n          [tree]\n          (and (sequential? tree)\n               (= 3 (count tree))\n               (let [l (nth tree 1)\n                     r (nth tree 2)]\n                 (and (or (nil? l) (bst l))\n                      (or (nil? r) (bst r))))))", "problem": 95, "user": "536973e5e4b0243289761e9e"}, {"code": "(fn T? [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (T? (nth x 1))\n           (T? (nth x 2)))))", "problem": 95, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn is-bst [col]\n  (cond (nil? col) true\n        (coll? col) (and (= (count col) 3)\n                         (is-bst (second col))\n                         (is-bst (last col)))\n        :else false))", "problem": 95, "user": "53806e5be4b06839e8705ec1"}, {"code": "#(every? true?\n          (map (fn [x]\n                 (if (sequential? x)\n                   ;; Well, anything that starts with a value should have exactly two children that are either sequences or nil\n                   (and (= (count (rest x)) 2)\n                        (every? (fn [x] (or (sequential? x) (nil? x))) (rest x)))\n                   true))\n               (tree-seq sequential? identity %)))", "problem": 95, "user": "53838742e4b06839e8705ee0"}, {"code": "(fn check-tree [x]\n  (cond \n   \t(nil? x) true\n   \t(not (sequential? x)) false\n   \t(not= 3 (count x)) false\n    :default (let [r (check-tree (nth x 1))\n                   l (check-tree (nth x 2))]\n               (and r l))))", "problem": 95, "user": "538d464ee4b0b51d73faae69"}, {"code": "(fn valid-tree [tree]\n  (if (not (coll? tree))\n    false\n    (and\n     (= (count tree) 3)\n     (not (nil? (first tree)))\n     (or (nil? (second tree)) (valid-tree (second tree)))\n     (or (nil? (last tree)) (valid-tree (last tree))))))", "problem": 95, "user": "538c3424e4b0b51d73faae58"}, {"code": "(fn binary-tree? [tree]\n\t(let [seq-branch? (fn [node]\n\t\t\t    (if (and (sequential? node)\n\t\t\t\t     (= (count node) 3))\n\t\t\t      true\n\t\t\t      false))\n\t      result-seqs (tree-seq seq-branch? rest tree)\n\t      seq1 (filter sequential? result-seqs)\n\t      seq2 (filter (complement sequential?) result-seqs)]\n\t  (and\n\t   (every? #(= 3 (count %)) seq1)\n\t   (every? nil? seq2))))", "problem": 95, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn is-btree? [x]\n  (or (when (coll? x)\n        (and (= 3 (count x))\n             (let [[_ c1 c2] x]\n               (when (or (nil? c1) (is-btree? c1))\n                 (or (nil? c2) (is-btree? c2))))))\n      false))", "problem": 95, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn tre? [x]\n  (if (not (= 3 (count x))) false\n    (and \n     (if (coll? (second x)) \n       (tre? (second x)) \n       (if (nil? (second x)) \n         true\n         false)) \n     (if (coll? (last x)) \n       (tre? (last x)) \n       (if (nil? (last x)) \n         true\n         false)))))", "problem": 95, "user": "53733312e4b06d7f452d9e0a"}, {"code": "(fn tree?\n  ([] false)\n  ([t] \n   (if (and (coll? t) (= (count t) 3))\n     (let [[v l r] t]\n       (and (or (nil? l) (tree? l)) (or (nil? r) (tree? r)))) \n     false))\n  ([a b & rest] false))", "problem": 95, "user": "531619c1e4b08068f379ed3d"}, {"code": "(fn is-btree? [[rt lc rc :as x]]\n  (cond\n    (some false? x) false\n    (= 3 (count x)) (and (if (coll? lc) (is-btree? lc) true)\n                        (if (coll? rc) (is-btree? rc) true)\n                        (not (or (nil? rt) (coll? rt))))\n    :else false))", "problem": 95, "user": "4eeb8f68535d93acb0a668a9"}, {"code": "(fn bin[tree]\n  (or (not (coll? tree))\n      (and\n        (= (map #(or (nil? %) (coll? %)) (rest tree)) '(true true))\n        (every? bin tree)\n        )))", "problem": 95, "user": "52bc6cb2e4b07a9af57922f5"}, {"code": "(fn tree? [x]\n  (or (nil? x)\n      (and\n       (sequential? x)\n       (= 3 (count x))\n       (tree? (second x))\n       (tree? (last x)))))", "problem": 95, "user": "52eb400ee4b0705949c4443b"}, {"code": "#(letfn \n  [(f [t]\n  (if (coll? t) \n    (and (= (count t) 3) (f (second t)) (f (last t)))\n    (= t nil)))] (f %))", "problem": 95, "user": "536b2048e4b0243289761eb7"}, {"code": "(fn is-tree [coll]\n  (if (and (sequential? coll) (= 3 (count coll)))\n    (let [[v left right] coll]\n      (and\n      \t(or (nil? left) (is-tree left))\n      \t(or (nil? right) (is-tree right))))\n    false))", "problem": 95, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "#(letfn[( bin[s]\n\t(if (nil? s) true\n\t(if (or (false? s) (not= 3 (count s)) ) false\n\t    (if (and (nil? (first (next s))) (nil? (second (next s)))) true\n\t\t(and (bin (first (next s))) (bin (second (next s))))))))]\n   (bin %))", "problem": 95, "user": "4e8849c5535d8b9bb0147ca4"}, {"code": "(fn ct [tr]\n  (if (nil? tr) true\n    (if (not (coll? tr)) false\n\t  (let [[r le ri] tr]\n  \t\t(if (not= 3 (count tr)) false\n   \t\t(and (ct le) (ct ri)))))))", "problem": 95, "user": "53973e7be4b0b51d73faaee6"}, {"code": "(fn cbt [t]\n  (and \n   (= (count t) 3)\n   (let [lt (second t)]\n     (if (sequential? lt) \n       (cbt lt)\n       (if (= lt false) false true))) \n   (let [rt (last t)]\n     (if (sequential? rt) \n       (cbt rt)\n       (if (= rt false) false true)))))", "problem": 95, "user": "52046600e4b0c283853240c5"}, {"code": "(fn binarytree? [node]\n  (or \n    (nil? node)\n    (and node\n     \t (= 3 (count node))\n         (first node)\n         (every? binarytree? (rest node)) \n    )\n  )\n)", "problem": 95, "user": "52ac41fee4b0c58976d9ac85"}, {"code": "(fn btree? [s]\n  (or (= s nil)\n      (and (sequential? s)\n           (= (count s) 3)\n           (btree? (nth s 1))\n           (btree? (nth s 2)))))", "problem": 95, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn  [bt]\n    (let [bt? (fn [bt] (and (sequential? bt)\n                           (= 3 (count bt)))),\n          f (fn [x]\n              (loop [v x]\n                (cond (empty? v) true\n                      :else (let [f (first v)]\n                              (if (bt? f)\n                                (recur (conj (rest v) (nth f 0) (nth f 1) (nth f 2)))\n                                (if (or (and (seq? f) (empty? f)) (false? f))\n                                  false\n                                  (recur (rest v))))))))]\n      (if (bt? bt) (f bt)\n          false)))", "problem": 95, "user": "538e36c7e4b0b51d73faae81"}, {"code": "(fn tree? [coll]\n  (let [n (next coll)]\n    (and (= 2 (count n))\n         (every? #(or (nil? %) (and (sequential? %) (tree? %))) n))))", "problem": 95, "user": "5080a697e4b01a93d3f38e49"}, {"code": "(fn binary-tree? [t]\n                    (if (counted? t)\n                      (if (and (= (count t) 3)\n                             (not (nil? (first t))))\n                        (let [[v l r] t]\n                          (if (and (nil? l) (nil? r))\n                            true\n                            (and (binary-tree? l) (binary-tree? r))))\n                        false)\n                      (nil? t)))", "problem": 95, "user": "4edb314d535d10e5ff6f5317"}, {"code": "(fn\n  [coll]\n  (letfn [(isTree [coll] (or (nil? coll) (and (coll? coll)\n                                              (= 3 (.size coll))\n                                              (first coll)\n                                              (isTree (second coll))\n                                              (isTree (nth coll 2)))))]\n         (isTree coll)))", "problem": 95, "user": "52dfc89be4b09f7907dd1405"}, {"code": "(fn [coll]\n      (letfn [(ct [coll]\n                (cond\n                 (not (sequential? coll)) true\n                 (and (sequential? coll) \n                      (not= (count coll) 3)\n                      ) false\n                 (and\n                       (not (sequential? (nth coll 1)))\n                       (not (nil? (nth coll 1)))) false\n                 :else (and\n                        (ct (first coll))\n                        (ct (nth coll 1))\n                        (ct (last coll)))))]\n        (ct coll)))", "problem": 95, "user": "52c49401e4b0c2d177d620de"}, {"code": "(fn is-tree [tree]\n  (or (nil? tree) (and (sequential? tree) (== (count tree) 3) (every? is-tree (rest tree)))))", "problem": 95, "user": "538e864ee4b0b51d73faae87"}, {"problem": 95, "code": "(fn valid-tree?\n  [tree]\n  (if (nil? tree)\n    true\n    (if (= false tree)\n      false\n      (let [get-node (fn [n] (first n))\n            get-left (fn [n] (second n))\n            get-right (fn [n] (nth n 2))\n            is-valid-node? (fn [n] \n                              (and (= (count n) 3)\n                                   (not (nil? (get-node n)))\n                                   ))]\n        (and (is-valid-node? tree) (valid-tree? (get-left tree)) (valid-tree? (get-right tree)))\n      ))))", "user": "52af7a5ce4b0c58976d9acbd"}, {"problem": 95, "code": "(fn tree? [t]\n  (and \n    (or (coll? t) (nil? t))\n   \t(= (count t) 3) \n   \t(or (nil? (second t)) (tree? (second t))) \n   \t(or (nil? (second (rest t))) (tree? (second (rest t))))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 95, "code": "(fn is-tree? [t] (or (nil? t) (and (sequential? t) (= 3 (count t)) (and (is-tree? (nth t 1)) (is-tree? (nth t 2))))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (false? t) false\n        (not= (count t) 3) false\n        :else (and true (and (tree? (second t)) (tree? (second (rest t)))))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 95, "code": "(fn tree? [d]\n  (if-not (coll? d)\n    (nil? d)\n    (and (= 3 (count d))\n         (not (nil? (first d)))\n         (tree? (nth d 1))\n         (tree? (nth d 2)))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 95, "code": "(fn is-tree\n    [tree]\n    (or\n        (nil? tree)\n        (if (and (not (= (type tree) Boolean)) (= 3 (count tree)))\n            (let [[_ left right] tree]\n                (and (is-tree left) (is-tree right))) false)))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 95, "code": "(fn tree? [node] (if (sequential? node)  \n                   (and (= 3 (count node)) (tree? (second node)) (tree? (last node)))\n                   (if (false? node) false true)))", "user": "53a739b0e4b0ef122a8689d0"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (= t nil)\n    true\n    (if (and (or (seq? t) (vector? t)) (= (count t) 3))\n      (and (tree? (second t)) (tree? (nth t 2)))\n      false)))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 95, "code": "(fn [tree] (let [subtrees (tree-seq sequential? identity tree)\n                 branch? (fn [xs] (or (nil? xs) (sequential? xs)))\n                 ok (fn [sub] (or ((complement sequential?) sub) \n                                  (and (= 3 (count sub))\n                                       ((complement sequential?) (first sub))\n                                       (branch? (second sub))\n                                       (branch? (last sub)))))\n                 \n                 ]\n             (every? ok subtrees)))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 95, "code": "(fn is-tree\n  [a]\n  (cond \n   (sequential? a)\n     (and\n      (= 3 (count a))\n      (every? true? (map is-tree a)))\n   (false? a) false\n   :else true\n   ))", "user": "53ac4719e4b047364c04445c"}, {"problem": 95, "code": "(fn ex95 [tree]\n  (if (not (coll? tree))\n    (not (false? tree))\n    (and (= 3 (count tree))\n           (ex95 (nth tree 0))\n           (ex95 (nth tree 1))\n           (ex95 (nth tree 2)))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 95, "code": "(fn bin-tree? [input] ;counting the third last test as a tree but not the second last doesn't make sense to me\n      (cond\n        (not (or (list? input) (vector? input) (= false input))) true\n        (and  (not (= false input)) (= 3 (count input)) (bin-tree? (second input)) (bin-tree? (last input))) true\n        :else false\n        )\n      )", "user": "536827f1e4b0243289761e8a"}, {"problem": 95, "code": "(fn t [tree]\n  (if-not (sequential? tree)\n    (if (= tree false)\n      false\n      true)\n  (if (= (count tree) 1)\n    true\n    (if (= (count tree) 3)\n      (every? identity (map t tree))\n      false))))", "user": "53ae16e2e4b047364c044472"}, {"problem": 95, "code": "(fn is-tree [t]\n  (cond\n   (= false t) false\n   (= nil t) true\n   (= 3 (count t)) (and (is-tree (second t)) (is-tree (nth t 2)))\n   :else false))", "user": "53ae0c50e4b047364c044471"}, {"problem": 95, "code": "(fn to-tree-or-not-to-tree [[value & children :as node]] \n  (and (= 3 (count node))\n       (every? #(if (coll? %)\n                    (to-tree-or-not-to-tree %)\n                    (nil? %)) \n               children)))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 95, "code": "(fn tree? [xs] \n\t(if (and (coll? xs) (= (count xs) 3)) \n\t\t\t(and (tree? (second xs)) (tree? (last xs)))\n\t\t\t(nil? xs)))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= 3 (count x))\n           (tree? (second x))\n           (tree? (last x)))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 95, "code": "(fn [t] (empty? (filter (fn [n] (and (coll? n)\n                                     (or (not (= (count n) 3))\n                                         (and (not (coll? (second n)))\n                                              (not (nil? (second n))))\n                                         (and (not (coll? (last n)))\n                                              (not (nil? (last n)))))))\n                        (tree-seq coll? identity t))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (cond\n   (nil? tree) true\n   (not (sequential? tree)) false\n   (empty? tree) false\n   (not= (count tree) 3) false\n   :else (let [[root left right] tree]\n           (cond\n            (and (nil? left) (nil? right)) true\n            (and (binary-tree? left)\n                 (binary-tree? right)) true\n                 :else false))))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 95, "code": "(fn is-binary-tree [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= 3 (count tree))\n           (not (sequential? (nth tree 0)))\n           (is-binary-tree (nth tree 1))\n           (is-binary-tree (nth tree 2)))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 95, "code": "(fn f? [t] (letfn [(is-child? [v] (or (nil? v) (coll? v)))\n                (is-node? [t] (and (= (count t) 3) (is-child? (second t)) (is-child? (last t))))]\n          (and (is-node? t)\n               (if (nil? (second t)) true (f? (second t)))\n               (if (nil? (last t)) true (f? (last t))))))", "user": "52d07cc5e4b07d0d72b273bb"}, {"problem": 95, "code": "(fn isTree [[a b c :as d] ]\n  (and \n   (= 3 (count d))\n   (or (nil? b) (and (coll? b) (isTree b)) )\n   (or (nil? c) (and (coll? c)(isTree c)) )))", "user": "539c88e1e4b0b51d73faaf2c"}, {"problem": 95, "code": "(fn is-bin? [coll]\n  (if (and (coll? coll) (= (count coll) 3))\n    (let [[v r l & rest] coll]\n      (and\n        (or (nil? rest) (not (seq rest)))\n        v\n        (or (nil? r) (is-bin? r))\n        (or (nil? l) (is-bin? l))))\n    false))", "user": "52c1ede2e4b07a9af579236d"}, {"problem": 95, "code": "(fn rec [n]\n    (if (nil? n)\n      true\n        (if (or (not n) (not= (count n) 3))\n          false\n          (and\n      \t    (rec (nth n 1))\n            (rec (nth n 2))      \n           )\n        )\n     )\n)", "user": "51897709e4b0288ada3dbdaa"}, {"problem": 95, "code": "(fn is-binary-tree? [coll]\n    (cond\n        (false? coll) false\n        (not (coll? coll)) true\n        (not= (count coll) 3) false\n        :else (and (is-binary-tree? (second coll)) (is-binary-tree? (nth coll 2)))))", "user": "532c9dc9e4b019098a6f8b30"}, {"problem": 95, "code": "(letfn [(f [s] (and (sequential? s)\n                    (= (count s) 3)\n                    (->> s\n                         rest\n                         (remove nil?)\n                         (every? f))))]\n   f)", "user": "51a3b135e4b0e77c4ca60bf6"}, {"problem": 95, "code": "(fn [s]\n  (letfn [(f [x]\n            (if (coll? x)\n              (let [x (remove false? x)]\n                (and (= 3 (count x))\n                     (every? identity (map f x))))   \n              true))]\n  (f s)))", "user": "52c4af71e4b0c2d177d620e1"}, {"problem": 95, "code": "(fn tree? [xs] (and (coll? xs) (= 3 (count xs)) (every? #(or (nil? %) (tree? %)) (rest xs))))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 95, "code": "(fn node? [c]\n  (if (nil? c)\n    true\n    (if (and (sequential? c) (= (count c) 3))\n      (and (node? (first (rest c))) (node? (second (rest c))))\n      false)))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 95, "code": "(fn validtree? [s]\n    (or (nil? s)\n        (and (sequential? s)\n             (= (count s) 3)\n             (validtree? (second s))\n             (validtree? (last s)))\n    ))", "user": "52bf0116e4b07a9af5792328"}, {"problem": 95, "code": "(fn btree? [r]\n  (or (nil? r)\n      (and (sequential? r)\n           (= (count r) 3)\n           (every? btree? (rest r)))))", "user": "537e745ae4b06839e8705ea6"}, {"problem": 95, "code": "(fn tree? [s] (if (sequential? s) (and (= 3 (count s)) \n                                       (every? true? (map tree? (next s)))) \n                (not (= false s))) )", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 95, "code": "(fn __ [[v left right :as col]]\n  (if (coll? col)\n    (and (= 3 (count col))\n         (or (nil? left)\n             (and (coll? left)\n                  (__ left)))\n         (or (nil? right)\n             (and (coll? right)\n                  (__ right))))\n    false))", "user": "4f1e4ab5535d64f603146496"}, {"problem": 95, "code": "(fn tree? [xs] \n  (if-let [[v lChild rChild] xs]\n    (let [nilOrTree #(if (nil? %1) true (and (coll? %1) (tree? %1)))]\n    (and\n      (= 3(count xs))\n      (not (coll? v))\n      (nilOrTree lChild)\n      (nilOrTree rChild)))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 95, "code": "(fn is-binary-tree [coll]\n  (cond\n    (or (nil? coll)) true\n    (not (coll? coll)) false\n     (and (= 3 (count coll)) (is-binary-tree (nth coll 1)) (is-binary-tree (nth coll 2))) true\n     :else false))", "user": "50921f9ae4b09a7d0b586de1"}, {"problem": 95, "code": "(fn tree?[t]\n  (if (nil? t)\n    true\n    (if (and (sequential? t) (= 3 (count t)))\n      (and (tree? (nth t 1)) (tree? (nth t 2)))\n      false\n      )))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 95, "code": "(fn tree? [x]\n  (if (coll? x)\n    (and \n      (= 3 (count x))\n      (every? tree? (rest x)))\n    (nil? x)))", "user": "53c51dc5e4b00fb29b221288"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-tree? (second tree)) (is-tree? (nth tree 2)))))", "user": "50b63c5ee4b0a86f8358ca69"}, {"problem": 95, "code": "(fn istree [s]\n   (or (nil? s)\n       (and (sequential? s)\n            (= (count s) 3)\n            (let [[v l r] s]\n              (and (istree l) (istree r))))\n   )\n)", "user": "538db083e4b0b51d73faae74"}, {"problem": 95, "code": "(fn tree? [tree]\n  (or\n   (nil? tree)\n   (and (coll? tree)\n        (= 3 (count tree))\n        (every? tree? (rest tree)))))", "user": "53a0ab8ce4b0ca733b9744b3"}, {"problem": 95, "code": "(fn bt [t] (if (sequential? t) (and (= (count t) 3) (not (sequential? (nth t 0))) (bt (nth t 1)) (bt (nth t 2))) (not (false? t))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 95, "code": "; 95 - To Tree, or not to Tree\n(fn is-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? is-tree? (rest root)))))", "user": "53710c09e4b0fc7073fd6ea5"}, {"problem": 95, "code": "(fn is-tree?\n        [tree]\n        (if (not (coll? tree))\n          false\n          (let [[_ left right] tree]\n            (and\n             (= (count tree) 3)\n             (or (nil? left) (is-tree? left))\n             (or (nil? right) (is-tree? right))))))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 95, "code": "(fn bintree? [xs]\n  (cond \n   (or \n    (not= (count xs) 3) \n    (not (or (nil? (second xs)) (sequential? (second xs)))) \n    (not (or (nil? (last xs)) (sequential? (last xs))))) false\n   (sequential? (second xs)) (bintree? (second xs))\n   (sequential? (last xs)) (bintree? (last xs))\n   :default true))", "user": "53c126fce4b00fb29b22125b"}, {"problem": 95, "code": "(fn btree? [coll]\n  (letfn [(nodelike? [thing]\n            (if (false? thing) false\n                (or (not (sequential? thing))\n                    (= (count thing) 3))))]\n    (and (nodelike? coll)\n         (if (sequential? coll)\n           (every? #(btree? %) coll)\n           true))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 95, "code": "(fn [input]\n  (let [flat-list (flatten input)\n        list-count (count flat-list)]\n        (if (and (> list-count 3) (odd? list-count) (not (some false? flat-list)))\n          true\n          false)))", "user": "53b05a36e4b047364c044481"}, {"problem": 95, "code": "(fn tree? [s]\n\t(if (or (seq? s) (vector? s))\n   \t\t(if (= 3 (count s))\n     \t\t(and (tree? (second s)) (tree? (nth s 2)))\n     \t\tfalse)\n   \t(not (false? s))\n    )\n)", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 95, "code": "(fn istree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= (count coll) 3)\n           (every? istree? (rest coll)))))", "user": "53b4bddae4b047364c0444b9"}, {"problem": 95, "code": "(fn binary? [tree]\n  (if (and (sequential? tree) (= 3 (count tree)))\n    (let [[x y z] tree]\n      (and\n        (not (sequential? x))\n        (or (nil? y) (binary? y))\n        (or (nil? z) (binary? z))\n      )\n    )\n    false\n  )\n)", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 95, "code": "(fn check_btree [s]\n   (cond (nil? s) true\n         (not (coll? s)) false\n         (not (= 3 (count s))) false\n         true (and (check_btree (second s)) (check_btree (last s)))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 95, "code": "(fn valid-tree? [tree]\n   (let [left (second tree)\n         right (last tree)] \n   (and (= (count tree) 3)\n        (not (seq? (first tree)))\n        (and (not (instance? Boolean left)) \n             (not (instance? Boolean right)))\n        (or (nil? left) (valid-tree? left))\n        (or (nil? right) (valid-tree? right)))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 95, "code": "(fn is-tree [tree]\n  (if (and (not (sequential? tree)))\n      true\n      (let [no-boolean-tree (filter #(not (= % false)) tree)]\n      (if (and (= (count no-boolean-tree) 3)\n               (let [[left middle right] no-boolean-tree]\n                 (do (prn left middle right)\n                     (and (is-tree left)\n                          (is-tree middle)\n                          (is-tree right)))))\n      true\n      false))))", "user": "504f5804e4b0a02f9cffde72"}, {"problem": 95, "code": "(fn f [x] (or (nil? x) (and\n  (coll? x)\n  (= (count x) 3)\n  (f (nth x 1))\n  (f (nth x 2)))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 95, "code": "(fn tree? [[a b c :as t]]\n  (and (= (count t) 3) (or (nil? b) (and (sequential? b) (tree? b))) (or (nil? c) (and (sequential? c) (tree? c)))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 95, "code": "(fn f [[v l r :as node]]\n  (and\n    (= (count node) 3)\n    (or (nil? l) (and (sequential? l) (f l)))\n    (or (nil? r) (and (sequential? r) (f r)))))", "user": "53a83c74e4b047364c044426"}, {"problem": 95, "code": "(fn binary? [tree]\n  (cond\n      (nil? tree) true\n      (or (not (sequential? tree)) (not= (count tree) 3)) false\n      :else\n      (let [[v l r] tree]\n        (boolean (and (not (sequential? v))\n                      (binary? l)\n                      (binary? r))))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 95, "code": "(fn tree-test [tree]\n  (if (= (count tree) 3)\n    (and\n     (not (false? (second tree)))\n     (not (false? (last tree)))\n     (or (nil? (second tree)) (tree-test (second tree)))\n     (or (nil? (last tree)) (tree-test (last tree))))\n    false))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 95, "code": "(fn TR [xs]\n    (reduce   #(and %1 \n                          (if (sequential? %2) \n                            (TR %2)\n                            (if (= nil %2) \n                              true\n                              false\n                            )))               \n             (if (= 3 (count xs)) true false) \n             (rest xs)))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 95, "code": "(fn istree? [root]\n\t(or (nil? root)\n\t\t(and (sequential? root) (= 3 (count root)) (every? istree? (rest root)))))", "user": "53e241a6e4b036ad0777e3f0"}, {"problem": 95, "code": "(fn tree-check [tree]\n  (if (= nil tree) true\n    (if-not (coll? tree) false\n      (if (not= 3 (count tree)) false\n        (let [[val left right] tree]\n          (and (tree-check left) (tree-check right))\n          )))))", "user": "53dadf1de4b0e771c30254ad"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= (count coll) 3)\n           (every? binary-tree? (rest coll)))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 95, "code": "(fn valid? [tree]\n  (and (= (count tree) 3)\n       (= [] (filter #(= (class %) java.lang.Boolean) tree))\n       (if (sequential? (second tree)) (valid? (second tree)) true)\n       (if (sequential? (last tree)) (valid? (last tree)) true)))", "user": "539dcb24e4b0b51d73faaf3d"}, {"problem": 95, "code": "clojure.walk/postwalk #(if (sequential? %) (= [true true] (rest %)) (nil? %))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 95, "code": "(fn tree? [x]\n   (or\n     (nil? x)\n     (and\n       (sequential? x)\n       (= 3 (count x)) \n       (tree? (second x))\n       (tree? (last x)))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 95, "code": "(fn istree? [n]\n  (or (nil? n)\n      (and (sequential? n) (= 3 (count n)) (istree? (nth n 1)) (istree? (nth n 2)))))", "user": "53e4fa2ce4b036ad0777e454"}, {"problem": 95, "code": "(fn tree? [x]\n  (and (coll? x)\n       (and (= 3 (count x))\n            (let [[v l r] x]\n              (and (not (coll? v))\n                   (or (nil? l) (tree? l))\n                   (or (nil? r) (tree? r)))))))", "user": "53d28800e4b00fb29b22131e"}, {"problem": 95, "code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "user": "52ba2639e4b07a9af57922cb"}, {"problem": 95, "code": "(fn f [[x l r & _ :as t]]\n  (cond\n    (= 1 (count t)) true\n    (= 3 (count t))\n      (and \n        (not (nil? x))\n        (or (nil? l) (and (coll? l) (f l)))\n        (or (nil? r) (and (coll? r) (f r))))\n    :else false))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 95, "code": "(fn tree [x]\n  (if-not x\n    (if (or (false? x) (= '() x))\n      false\n      true)\n  \t(if-not (= (count x) 3)\n      false\n      (and (tree (second x)) (tree (first (nnext x)))))))", "user": "528d6b10e4b0239c8a67aec3"}, {"problem": 95, "code": "(fn bt? [coll]\n   (or (nil? coll)\n       (and (sequential? coll) (= 3 (count coll)) (bt? (second coll)) (bt? (last coll)))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 95, "code": "(fn treeish? [coll]\n  (if (= coll nil)\n    true\n    (if-let [[value a b :as node] coll]\n      (if (= 3 (count node))\n        (and (treeish? a) (treeish? b))\n        false\n      )\n      false\n    )\n  )\n)", "user": "53f17931e4b0742d9025b0dd"}, {"problem": 95, "code": "(fn tree? [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= (count tree) 3)\n           (tree? (nth tree 1))\n           (tree? (nth tree 2)))))", "user": "53e27bf1e4b036ad0777e3f2"}, {"problem": 95, "code": "(fn is-tree [x] \n  (if (nil? x) \n    true \n    (if (and\n        (coll? x)\n        (= 3 (count x)) \n        (not (coll? (first x)))\n        (is-tree (second x))\n        (is-tree (nth x 2))\n   \t\t)\n    true \n    false)\n    )\n )", "user": "50856bd1e4b004985b776e4c"}, {"problem": 95, "code": "(fn ttontr-95 [t]\n    (if (nil? t)\n      true\n      (and (sequential? t)\n           (= 3 (count t))\n           (ttontr-95 (second t))\n           (ttontr-95 (first (nnext t))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 95, "code": "(fn istree [x]\n  (if (nil? x) true\n    (if (not (coll? x)) false\n      (if (not (= (count x) 3)) false\n        (and (istree (second x)) (istree (nth x 2))))))\n  )", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 95, "code": "(fn is-bintree? [xs]\n  (if (not (and (coll? xs) (= 3 (count xs))))\n    false\n    (let [is-bintree-or-nil? (fn [t] (or (nil? t) (is-bintree? t)))\n          [val left-child right-child] xs]\n      (and (is-bintree-or-nil? left-child) (is-bintree-or-nil? right-child))\n    )\n  )\n)", "user": "53edb628e4b0d648e757f4c8"}, {"problem": 95, "code": "(fn tree [l]\n   (if (coll? l)\n     (and \n      (= (count l) 3)\n      (every? tree l)\n      (or (coll? (second l)) (nil? (second l)))\n      (or (coll? (last l)) (nil? (last l))))\n     true))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 95, "code": "(fn tree? [coll]\n   (let [ tree-or-nil? #(or (nil? %) (tree? %))]\n     (and\n      (sequential? coll)\n      (= 3 (count coll))\n      (tree-or-nil? (nth coll 1))\n      (tree-or-nil? (nth coll 2)))))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 95, "code": "(fn bt? [t]\n   (or (nil? t)\n       (and\n        (sequential? t)\n        (= 3 (count t))\n        (bt? (second t))\n        (bt? (->> t (drop 2) (first))))))", "user": "53ea5307e4b036ad0777e4e2"}, {"problem": 95, "code": "(fn bin-tree? [x]\n   (cond\n    (nil? x) true\n    (not (sequential? x)) false\n    :else (and (not (sequential? (first x)))\n               (= (count x) 3)\n               (bin-tree? (nth x 1))\n               (bin-tree? (nth x 2)))))", "user": "53e91473e4b036ad0777e495"}, {"problem": 95, "code": "(fn peu [x] (if (= nil x) true (if (and (not= x false) (= 3 (count x))) (and (peu (second x)) (peu (last x))) false)))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 95, "code": "(fn bt? [t]\n   (cond\n    (nil? t) true\n    (and (sequential? t) (= (count t) 3)) (let [[x y z] t] (and (bt? y) (bt? z)))\n    :else false))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond (not (or (coll? coll) (nil? coll))) false\n        (= (count coll) 3) (and (tree? (second coll)) (tree? (last coll)))\n        (nil? coll) true\n        true false))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 95, "code": "(fn t[x]\n  (or(nil? x)\n  (and (coll? x) (= 3 (count x)) (t(second x))(t(second(rest x))))))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 95, "code": "(fn is-tree [sq]\n  (or (nil? sq) (and (coll? sq) (= (count sq) 3) (every? is-tree (rest sq))))\n)", "user": "53ea72b6e4b036ad0777e4e5"}, {"problem": 95, "code": "(fn __95 [t]\n    (or (nil? t)\n      (and (coll? t) (= 3 (count t)) (every? __95 (rest t)))))", "user": "5151c184e4b03e678e393add"}, {"problem": 95, "code": "(fn [possible-tree]\n  (loop [[t & more] [possible-tree]]\n    (if (and (sequential? t) (= (count t) 3))\n      (let [[v left right] t\n            remaining      (concat more (remove nil? [left right]))]\n        (if (seq remaining)\n          (recur remaining)\n          true))\n      false)))", "user": "50f94727e4b0e7c80cb15a49"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n     (and (coll? t)\n      \t  (= 3 (count t))\n          (tree? (second t))\n          (tree? (last t)))))", "user": "51aefceee4b09397d5109797"}, {"problem": 95, "code": "(fn check[tree]\n  (if (coll? tree)\n    (and (= (count tree) 3)\n         (or (coll? (get tree 1)) (nil? (get tree 1)))\n         (or (coll? (get tree 2)) (nil? (get tree 2)))\n         (every? identity (map check tree))\n         )\n    true    \n    )\n  )", "user": "52271ffee4b04e78ff2e19a9"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (or (nil? t)\n          (and (sequential? t)\n\t\t       (= 3 (count t))\n               (tree? (second t))\n               (tree? (last t))))\n   true, false))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 95, "code": "(fn tree? [[v l r :as node]]\n  (letfn [(node? [n](or (nil? n) (and n (tree? n))))]\n    (boolean \n      (and v\n       (node? l)\n       (node? r)\n       (= 3 (count node))))))", "user": "5368fedee4b0243289761e93"}, {"problem": 95, "code": "(fn is-tree [node]\n   (or\n     (nil? node)\n     (and (coll? node) \n          (= 3 (count node))\n          (is-tree (second node))\n          (is-tree (first (reverse node))))))", "user": "5398123ee4b0b51d73faaef3"}, {"problem": 95, "code": "(fn [ms]\n  (letfn [(go [ns]\n            (if (not= 3 (count ns))\n              false\n              (let [[v l r] ns]\n                (and (or (nil? l) (and (sequential? l) (go l)))\n                     (or (nil? r) (and (sequential? r) (go r)))))))]\n    (go ms)))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 95, "code": "(fn ! [a]\n  (or\n    (nil? a)\n    (and\n      (sequential? a)\n      (= 3 (count a))\n      (! (nth a 1))\n      (! (nth a 2)))))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "53be3ee7e4b0d9a98559a6df"}, {"problem": 95, "code": "(comp\n         (partial = 0)\n         count\n         (partial filter #(if (coll? %)\n                            (or (nil? (first %)) (not (= 3 (count %))))\n                            (not (nil? %))))\n         (partial tree-seq coll? rest))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 95, "code": "(fn is-tree? [s]\n  (if (nil? s)\n    true\n    (if (sequential? s)\n      (if (not= 3 (count s))\n        false\n        (and \n          (is-tree? (second s))\n          (is-tree? (second (rest s)))))\n      false)))", "user": "53a94b63e4b047364c044434"}, {"problem": 95, "code": "(fn t [c] (if (= 3 (count c)) (every? #(or (nil? %) (and (coll? %) (t %))) (rest c)) false))", "user": "53f035c2e4b0742d9025b0d2"}, {"problem": 95, "code": "(fn test [coll]\n  (if (nil? coll)\n    true\n    (and (coll? coll) (= (count coll) 3) (not (nil? (first coll))) (test (nth coll 1)) (test (nth coll 2)))\n  )\n )", "user": "54021f13e4b0df28a13c62cc"}, {"problem": 95, "code": "(fn is-tree [xs]\n  (or (nil? xs)\n      (and (coll? xs)\n           (= (count xs) 3)\n           (is-tree (second xs))\n           (is-tree (second (rest xs))))))", "user": "53e8c684e4b036ad0777e48b"}, {"problem": 95, "code": "(fn is-binary? [tree] \n  (cond \n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)) )\n   )\n  )", "user": "537b1083e4b06839e8705e64"}, {"problem": 95, "code": "(fn istree [x]\n  (or (nil? x)  (and (sequential? x) (= (count x) 3 ) (istree (nth x 1)) (istree (nth x 2)))))", "user": "524025bce4b0ad64fa01030f"}, {"problem": 95, "code": "(fn tree? [s]\n  (or (nil? s)\n      (and (coll? s)\n           (= (count s) 3)\n           (every? tree? (rest s)))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 95, "code": "(fn is-binary? [coll]\n  (and ((complement nil?) (first coll))\n       (= 3 (count coll))\n       (every? true? (map (fn [c]\n                     (cond\n                       (nil? c) true\n                       (coll? c) (is-binary? c)\n                       :else false))\n                    (rest coll)))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= (count coll) 3)\n           (binary-tree? (second coll))\n           (binary-tree? (last coll)))))", "user": "52474133e4b05ef8e38e635e"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (if (and (coll? t) (= 3 (count t)))\n      (let [l (second t) r (second (rest t))]\n        (and (tree? r) (tree? l)))\n      false)))", "user": "5097ea89e4b087ccf61a7af4"}, {"problem": 95, "code": "(fn tree? [l]\n  (if (nil? l)\n    true\n    (and (coll? l) \n         (= 3 (count l))\n         (tree? (second l))\n         (tree? (last l))\n         true)))", "user": "53f7820be4b0de5c41848560"}, {"problem": 95, "code": "(fn treeCheck?\n  [xs]\n  (cond\n    (coll? xs) (and (= (count xs) 3) (not (nil? (nth xs 0))) (treeCheck? (nth xs 1)) (treeCheck? (nth xs 2)))\n    (nil? xs) true\n    :else false\n  )\n)", "user": "525b4e8de4b0cb4875a45d0f"}, {"problem": 95, "code": "(fn sk-tree? [[x l r :as a]]\n  (and (= (count a) 3)\n       (or (nil? l) (and (coll? l) (sk-tree? l)))\n       (or (nil? r) (and (coll? r) (sk-tree? r)))))", "user": "51d42f44e4b013d740b70ddb"}, {"problem": 95, "code": "#(let[elements (flatten %)](and (odd?(count elements)) (not (some false? elements))))", "user": "538d70abe4b0b51d73faae6e"}, {"problem": 95, "code": "(fn f? [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (every? f? (rest x)))))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 95, "code": "(fn tree? [t]\n  (and (coll? t)\n    (= (count t) 3)\n    (let [l (first (rest t)), r (first (rest (rest t)))]\n      (and   \n        (or (= l nil) (tree? l))\n        (or (= r nil) (tree? r))))))", "user": "53ff8c31e4b0de5c41848603"}, {"problem": 95, "code": "(fn t [c]\n  (if-let [[i l r] c] (and (= 3 (count c)) (t l) (t r)) (not (false? c)))\n )", "user": "51a058dae4b0b292b01ee3f3"}, {"problem": 95, "code": "(fn ! [t]\n\t(cond\n\t\t(not (coll? t)) true\n\t\t:else (and (= 3 (count t)) (every? ! t) (not-any? false? t))\n\t)\n)", "user": "5409f8eae4b0addc1aec66e6"}, {"problem": 95, "code": "(fn bt? [n]\n\t(or (nil? n)\n\t\t(and (sequential? n)\n\t\t\t(= 3 (count n))\n\t\t\t(bt? (second n))\n\t\t\t(bt? (last n)))))", "user": "53e9681de4b036ad0777e4a4"}, {"problem": 95, "code": "(fn isbinary [t]\n  (if (nil? t)\n    true\n    (if (coll? t)\n      (if (= (count t) 3)\n        (let [[v l r] t]\n          (and (isbinary l) (isbinary r)))\n        false)\n      false)))", "user": "541096bde4b01498b1a719b2"}, {"problem": 95, "code": "(fn test [x]\t\n  (if (and (sequential? x) (= 3 (count x))) \n    (let [[a b c] x]\n    \t(and (if (nil? b) true (test b))\n             (if (nil? c) true (test c)))\n      \n      )\n     \t(if (nil? x) true false)\n    ))", "user": "540479e7e4b0addc1aec665a"}, {"problem": 95, "code": "apply (fn tree?\n    ([] false)                                \n    ([x] true)\n    ([_ _] false)\n    ([_ _ _ & _] false)\n    ([root left right]      \n     (let [leaf? (fn [leave] (or (nil? leave) (and (coll? leave) (apply tree? leave))))]\n       (and\n         (not (seq? root))\n         (leaf? left) \n         (leaf? right)))))", "user": "54094824e4b0addc1aec66da"}, {"problem": 95, "code": "(fn btree? [tree]\n  (cond\n   (nil? tree) true\n   (sequential? tree) \n     (and (= (count tree) 3)  (every? btree? (rest tree)))\n   :else false))", "user": "537f4652e4b06839e8705eb1"}, {"problem": 95, "code": "(fn binary-tree? [node] \n         (cond (= node nil) true,\n               (not (coll? node)) false              \n               (not= (count node) 3) false,\n               :else (every? identity \n                             (conj (lazy-seq) \n                                   (binary-tree? (nth node 1)) \n                                   (binary-tree? (nth node 2))))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 95, "code": "(fn is-a-tree? [possible-tree]\n  (let [value (first possible-tree)\n        left-child (second possible-tree)\n        right-child (last possible-tree)]\n    (cond\n      (nil? possible-tree) true\n      (not (= 3 (count possible-tree))) false\n      :else (and (or (nil? left-child) (sequential? left-child))\n                 (or (nil? right-child) (sequential? right-child))\n                 (is-a-tree? left-child)\n                 (is-a-tree? right-child)\n            )\n    )\n  )\n)", "user": "540f09b9e4b0addc1aec6725"}, {"problem": 95, "code": "(fn tree? [coll]\n    (if (and coll (= 3 (count coll)))\n      (let [[v l r] coll]\n        (if v\n          (and (tree? l) (tree? r))))\n      (= coll nil)))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 95, "code": "(fn [t] \n  (every? #(or (nil? %) \n               (and (counted? %)\n                    (= (count %) 3)))\n          (tree-seq identity rest t)))", "user": "541b37d2e4b01498b1a71a64"}, {"problem": 95, "code": "(fn bTree? [n]\n  (if (nil? n) true\n    (if (or (not(coll? n)) (not= 3 (count n))) false\n      (and (bTree? (nth n 1)) (bTree? (nth n 2))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 95, "code": "(fn __ [xs]\n  (if (nil? xs) true\n    (if (false? xs) false\n               (if (not (= (count xs) 3)) false\n                 (and (__ (second xs)) (__ (second (rest xs))))))))", "user": "54133900e4b01498b1a719de"}, {"problem": 95, "code": "(fn q95 [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= (count coll) 3)\n           (q95 (second coll))\n           (q95 (last coll)))))", "user": "52c672e2e4b0c2d177d6210e"}, {"problem": 95, "code": "(fn is-tree? [node]\n  (if (coll? node)\n    (if (not= (count node) 3)\n      false\n      (and (is-tree? (second node)) (is-tree? (nth node 2))))\n    (if (nil? node)\n      true\n      false)))", "user": "54125eeee4b01498b1a719d3"}, {"problem": 95, "code": "(fn [s] (every? #(or (nil? %) \n                    (and (sequential? %) (= 3 (count %)) (not (sequential? (first %))))) \n               (tree-seq sequential? rest s\n                         ) ))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 95, "code": "(fn bi-tree? [coll]\n  (let [n1 (first coll)\n        n2 (second coll)\n        n3 (last coll)]\n    (boolean\n      (and (and n1 (not (sequential? n1)))\n           (and (not= false n2)\n                (or (not (sequential? n2))\n                    (bi-tree? n2)))\n           (and (not= false n3)\n                (or (not (sequential? n3))\n                    (bi-tree? n3)))\n           (= 3 (count coll))))))", "user": "53f6bfd9e4b0db01ade6f9e4"}, {"problem": 95, "code": "(fn is-binary-tree? [[v l r :as t]]\n        (and (= 3 (count t))\n             (if l\n               (is-binary-tree? l)\n               (not= l false))\n             (if r\n               (is-binary-tree? r)\n               (not= r false))))", "user": "541ae7dbe4b01498b1a71a61"}, {"problem": 95, "code": "(fn tree? [tree]\n   (if (and (not (nil? tree)) (not (sequential? tree)))\n     false\n     (loop [t tree]\n       (let [[_ lnode rnode] t]\n         (if (nil? t)\n           true\n           (and (= (count t) 3) (tree? lnode) (tree? rnode)))))))", "user": "53c06438e4b0c98a41f5ccb0"}, {"problem": 95, "code": "(fn istree? [xs]\n  (if (= 3 (count xs))\n    (let [[a b c] xs]\n      (and ((complement seq?) a)\n        (if (coll? b) (istree? b)\n          (nil? b))\n        (if (coll? c) (istree? c)\n          (nil? c))))\n    false))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 95, "code": "(fn node?\n  [[val l r :as coll]]\n  (println val l r)\n  (if (= 3 (count coll))\n    (every? true? [\n                   (when-not (= nil val) true)\n                   (cond\n                    (coll? l) (node? l)\n                    (= nil l) true\n                    :else false)\n                   (cond\n                    (coll? r) (node? r)\n                    (= nil r) true\n                    :else false)])\n    false ))", "user": "53f2370ee4b0742d9025b0e7"}, {"problem": 95, "code": "(fn binary? [coll]\n  (if ((comp not coll?) coll)\n    (nil? coll)\n    (let [[_ left right] coll]\n      (and (= (count coll) 3) (binary? left) (binary? right)))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (= nil t)\n    true\n    (if (and (sequential? t)\n            (= 3 (count t)))\n      (let [[_ l r] t]\n        (and (tree? l) (tree? r)))\n      false)))", "user": "53f77b6ae4b0de5c4184855f"}, {"problem": 95, "code": "(fn tree? [node]\n    (or (nil? node)\n        (and (sequential? node)\n             (= (count node) 3)\n             (every? tree? (rest node)))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 95, "code": "(fn is-tree? [s]\n  (if\n    (counted? s)\n    (and\n      (= 3 (count s))\n      (is-tree? (nth s 1))\n      (is-tree? (nth s 2)))\n    (nil? s)))", "user": "5429986ce4b01498b1a71b3b"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "51c1b644e4b0d204dbe2ca12"}, {"problem": 95, "code": "(fn f [s]\n  (if (sequential? s)\n    (and (= (count s) 3)\n         (f (nth s 1))\n         (f (nth s 2)))\n    (nil? s)))", "user": "52541fe6e4b0541d1855b964"}, {"problem": 95, "code": "(fn f [t] (or (nil? t) (and (coll? t) (= 3 (count t)) (every? f (rest t)))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 95, "code": "(fn v? [x]\n  (cond (nil? x)\n        true\n        (sequential? x)\n        (and (= (count x) 3)\n             (every? identity (map v? (rest x))))))", "user": "51b8d3d5e4b050a1176cd69d"}, {"problem": 95, "code": "(fn bin-tree? [t] \n  (cond\n   (nil? t) true\n   (coll? t) (and\n              (= (count t) 3)\n              (bin-tree? (second t))\n              (bin-tree? (last t)))\n    :else false\n   ))", "user": "5409a12fe4b0addc1aec66df"}, {"problem": 95, "code": "(fn tree? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= 3 (count tree)) false\n   :else (and (tree? (second tree)) (tree? (nth tree 2)))))", "user": "53dfbc75e4b0d874e779ae44"}, {"problem": 95, "code": "(fn is-tree? [[v l r :as nd]]\n    (and\n      (sequential? nd)\n      (= 3 (count nd))\n      (if (sequential? l) (is-tree? l) (or (nil? l) l))\n      (if (sequential? r) (is-tree? r) (or (nil? r) r))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 95, "code": "(fn binary-tree? [x]\n  (if (= nil x) true\n    (if (not (coll? x)) false\n      (if (or (empty? (rest x)) (empty? (rest (rest x)))) false\n        (let [lc (first (rest x))\n              rc (first (rest (rest x)))\n              has-more-two (empty? (rest (rest (rest x))))]\n          (if (not has-more-two) false\n            (and (binary-tree? lc) (binary-tree? rc))))))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 95, "code": "(fn __ [tree]\n  (or (nil? tree)\n      (and tree\n           (= (count tree) 3)\n           (__ (nth tree 1))\n           (__ (nth tree 2)))))", "user": "4f856adfe4b033992c121c44"}, {"problem": 95, "code": "(fn btree? [s]\n  (and\n   (= (count s) 3)\n   (not (coll? (first s)))\n   (every? #(if (coll? %) \n              (btree? %)\n              (not= % false)) s)))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 95, "code": "(fn is-node?\n  [s]\n  (or (nil? s)\n      (and (coll? s)\n           (= 3 (count s))\n           (let [[_ left right] s]\n             (and\n              (is-node? left)\n              (is-node? right))\n         ))))", "user": "53a511aae4b0b62ce3005735"}, {"problem": 95, "code": "(fn t [x]\n (if (sequential? x)\n  (if (= 3 (count x))\n   (and (t (first x))\n\t(t (second x))\n\t(t (nth x 2)))\n   false)\n  (not= false x)))", "user": "50ebd63ce4b04edc3377703c"}, {"problem": 95, "code": "(fn chk\n\t[tree]\n\t (if (and (coll? tree) (= (count tree) 3))\n\t   (and (chk (nth tree 1)) (chk (nth tree 2)))\n\t   (if (nil? tree) true false)))", "user": "53da3fcde4b0e771c3025497"}, {"problem": 95, "code": "(fn b [a] (or (nil? a)\n               (and (sequential? a)\n                    (= (count a) 3)\n                    (b (second a))\n                    (b (last a)))\n               ))", "user": "54344721e4b0b6b47310fcea"}, {"problem": 95, "code": "(fn binaryTree? [x] \n  (or (nil? x)\n      (and\n       (coll? x)\n       (= 3 (count x))\n       (binaryTree? (nth x 1))\n       (binaryTree? (nth x 2)))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 95, "code": "(fn istree? \n  [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "542edb4ae4b0dad94371f2c8"}, {"problem": 95, "code": "(fn check-tree [[_ left right :as t]]\n    (and\n     (or (nil? t) (= 3 (count t)))\n     (or (nil? left) (and (sequential? left) (check-tree left)))\n     (or (nil? right) (and (sequential? right) (check-tree right)))))", "user": "537bde5de4b06839e8705e73"}, {"problem": 95, "code": "(fn binary-tree? \n  [xs]\n  (cond\n   (= (Boolean. false) xs) false\n   (= (count xs) 3) (and (binary-tree? (second xs)) (binary-tree? (last xs)))\n   (nil? xs) true\n   :else false))", "user": "52561295e4b0541d1855ba03"}, {"problem": 95, "code": "(fn is-tree? [tree]\n    \n    (and\n     (= (count tree) 3)\n     (every? #(not= false %) tree)\n     (every? true? (map is-tree? (filter sequential? tree)))))", "user": "5433a07be4b0b6b47310fce0"}, {"problem": 95, "code": "(fn is-tree-leaf? [col]\n  (if (coll? col)\n    (if (= (count col) 3)\n      (let [[val left right] col]\n        (and (is-tree-leaf? left) (is-tree-leaf? right)))\n      false)\n    (nil? col)))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 95, "code": "(fn ? [n] \n  (or (nil? n)\n      (and \n       (coll? n) \n       (= 3 (count n))\n       (every? ? (rest n)))))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 95, "code": "(fn f[x](if(coll? x)(and(=(count x)3)(f(nth x 1))(f(nth x 2)))(nil? x)))", "user": "4db2903f535df7e46ed9b6bf"}, {"problem": 95, "code": "(fn tree? [node]\n  (let [lchild (fn [p] (first (rest p)))\n        rchild (fn [p] (first (rest (rest p))))]\n  (or (nil? node)\n      (and\n       (coll? node)\n       (= (count node) 3)\n       (tree? (lchild node))\n       (tree? (rchild node))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 95, "code": "(fn istree [s]  \n                   (if (and (sequential? s) (= (count s) 3))\n\t                   (let [\n\t                         head (first s)\n\t                         left (second s)\n\t                         right (first(drop 2 s))\n                           leftnil (nil? left)\n                           rightnil (nil? right)\n\t                         ]\n                      \n                      (and true (if leftnil true (istree left)) (if rightnil true (istree right)))\n\t                   )\n                     false\n                     )                   \n)", "user": "542baf7ce4b0dad94371f291"}, {"problem": 95, "code": "(fn ! [myseq] \n    (loop [currentseq myseq] \n      (if \n        (or (not (sequential? currentseq)) (not (= 3 (count currentseq))))\n        false\n        (and \n          (not (nil? (first currentseq)))\n          (if (not (nil? (nth currentseq 1))) (! (nth currentseq 1)) true)\n          (if (not (nil? (nth currentseq 2))) (! (nth currentseq 2)) true)\n        )\n      )\n    )\n  )", "user": "5439c3cee4b032a45b869323"}, {"problem": 95, "code": "(fn bt? [n]\n   (or\n    (nil? n)\n    (and (coll? n)\n         (= (count n) 3)\n         (bt? (second n))\n         (bt? (nth n 2)))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 95, "code": "(fn tree? [s]\n  (and (not (sequential? (first s)))\n    (= 3 (count s))\n    (if (coll? (second s)) (tree? (second s)) (nil? (second s)))\n    (if (coll? (nth s 2)) (tree? (nth s 2)) (nil? (nth s 2)))))", "user": "504457c0e4b01f6c9a8b2360"}, {"problem": 95, "code": "(fn tree?  \n  [t] \n  (if (or \n        (nil? t)\n        (and \n          (coll? t)\n          (= 3 (count t)) \n          (tree? (second t)) \n          (tree? (last t))))\n    true false))", "user": "4dbf7a31535d020aff1edf75"}, {"problem": 95, "code": "(fn [a]\n   (let [s (tree-seq sequential? rest a)\n         ns (filter (complement sequential?) s)\n         ss (filter sequential? s)\n         ]\n     (and   \n       (every? nil? ns)\n          (every? #(= % 3)\n             (map count ss))       \n       )\n     )\n  )", "user": "5412646de4b01498b1a719d4"}, {"problem": 95, "code": "(fn istree? [root]\n(or (nil? root)\n(and (sequential? root)\n(= 3 (count root))\n(every? istree? (rest root)))))", "user": "52485723e4b05ef8e38e63d2"}, {"problem": 95, "code": "(fn tree? [x]\n  (if (sequential? x)\n    (and (= (count x) 3) (tree? (second x)) (tree? (last x)))\n    (nil? x)))", "user": "53322cece4b019098a6f8b73"}, {"problem": 95, "code": "(fn is-b-tree? [b]\n  (if (nil? b)\n      true\n      (and (or (list? b) (vector? b))\n       \t   (= 3 (count b)) \n           (every? identity (map is-b-tree? (rest b))))))", "user": "545801f6e4b01be26fd74615"}, {"problem": 95, "code": "(fn tree? [t] \n  (cond \n   (nil? t) true\n   (coll? t)\n    (let [c (count t)] \n      (if (not= c 3) \n        false\n        (let [[_ l r] t] (and (tree? l) (tree? r)))))\n   :else (number? t)))", "user": "5454b84ce4b0e397800069d9"}, {"problem": 95, "code": "(fn check [s] (or (= s nil) (and (coll? s) (= (count s) 3) (check (nth s 1)) (check (nth s 2)))))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 95, "code": "(fn bt [[v & subtrees]]\n  (let [l (first subtrees)\n        r (second subtrees)]\n    (and (= 2 (count subtrees))\n     \t (or (nil? l) (and (sequential? l) (bt l)))\n         (or (nil? r) (and (sequential? r) (bt r))))))", "user": "54580586e4b01be26fd74616"}, {"problem": 95, "code": "(fn tree? [t]\n  (if \n    (or (nil? t)\n        (and (sequential? t)\n           (= (count t) 3)\n           (tree? (second t))\n           (tree? (last t)))) true false))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 95, "code": "(fn t [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= 3 (count n))\n           (every? t (rest n)))))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 95, "code": "(fn bt? [bt]\n  (and (coll? bt) (= (count bt) 3)\n       (boolean (first bt))\n       (every? #(or (nil? %) (bt? %)) (rest bt))))", "user": "505aa653e4b021387fb89857"}, {"problem": 95, "code": "(fn binary-tree?\n  [tree]\n  (if (nil? tree)\n    true\n    (if (and (coll? tree) (= (count tree) 3))\n      (let [left-tree (second tree)\n            right-tree (last tree)]\n        (and (binary-tree? left-tree) (binary-tree? right-tree)))\n      false)))", "user": "526e1bd0e4b03e8d9a4a730b"}, {"problem": 95, "code": "(fn bt? [x]\n\t     (or\n\t      (nil? x)\n\t      (and\n\t       (coll? x)\n\t       (= (count x) 3)\n\t       (not= (first x) nil)\n\t       (bt? (nth x 1))\n\t       (bt? (nth x 2)))))", "user": "5327c591e4b09d4e7a9b54ff"}, {"problem": 95, "code": "(fn xt [tree] \n  (if (= tree nil)\n    true\n    (if (and (coll? tree) (= (count tree) 3))\n      (and (xt (second tree)) (xt (nth tree 2)))\n      false\n      )\n    ))", "user": "5367bc60e4b0243289761e81"}, {"problem": 95, "code": "(fn f95\n  [x]\n  (if (coll? x)\n    (if (not= (count x) 3)\n      false\n      (and (f95 (first x)) (f95 (second x)) (f95 (nth x 2)) )\n      )\n    (if (= x false) false true)\n    )\n  )", "user": "526698c9e4b03e8d9a4a7144"}, {"problem": 95, "code": "(fn tree? [t]\n    (cond (nil? t) true\n          (coll? t) (and (= (count t) 3)\n                         ((complement coll?) (first t))\n                         (tree? (second t))\n                         (tree? (last t)))\n          :else false))", "user": "5460f59ce4b01be26fd74695"}, {"problem": 95, "code": "(fn bintree? [xs]\n  (and (sequential? xs)\n       (= (count xs) 3)\n       (not (coll? (first xs)))\n       (or (nil? (second xs))\n           (bintree? (second xs)))\n       (or (nil? (nth xs 2))\n           (bintree? (nth xs 2)))))", "user": "5136f659e4b04059df19f2fd"}, {"problem": 95, "code": "(fn is-a-binary-tree\n  [s]\n  (if (nil? s) true\n    (if (not (coll? s)) \n      false\n      (if (not (= (count s) 3))\n        false\n        (reduce #(and %1 %2) (map #(is-a-binary-tree %) (concat (take-nth 3 (rest s)) (take-nth 3 (rest (rest s))))))))))", "user": "53b952eee4b047364c0444e6"}, {"problem": 95, "code": "(fn is-tree [s]\n  (and (sequential? s)\n   \t   (= 3 (count s))\n       (let [l (second s)\n             r (nth s 2)]\n         (and (or (nil? l) (is-tree l))\n              (or (nil? r) (is-tree r))\n         ))))", "user": "544e9022e4b0e3978000698b"}, {"problem": 95, "code": "(fn tree [coll] (if (not (coll? coll)) \n                  (nil? coll) \n                  (case (count coll)\n                    1 (nil? (first coll))\n                    3 (and (not (nil? (first coll))) (tree (second coll)) (tree (last coll)))\n                    false)))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 95, "code": "(fn [s]\n    (let [valid-node? (fn [n] (cond\n                                (nil? n) true\n                                (and (sequential? n)\n                                     (and\n                                       (= 3 (count n))\n                                       (not-any? false? n)\n                                       (not (nil? (first n)))\n                                       (or (nil? (first (rest n))) (sequential? (first (rest n))))\n                                       (or (nil? (first (rest (rest n)))) (sequential? (first (rest (rest n))))))\n                                     ) true\n                                :else false)) ]\n      (if (not-any? false? (flatten s))\n        (every? true? (map valid-node? (tree-seq next rest s)))\n        false)\n      )\n    )", "user": "515ebde3e4b01e5d11ccd0a8"}, {"problem": 95, "code": "(fn is-node [n]\n  (if (not (instance? java.util.Collection n))\n    false\n    (if (not= (count n) 3)\n      false\n      (and (or (= nil (second n))\n               (is-node (second n)))\n           (or (= nil (nth n 2))\n               (is-node (nth n 2)))))))", "user": "54651faee4b01be26fd746d6"}, {"problem": 95, "code": "#(->> (tree-seq sequential? seq %)\n       (map (fn [x] (if (= java.lang.Boolean (type x))\n                      '()\n                      x)))\n       (filter sequential?)\n       (map count)\n       (every? (fn [x] (= 3 x))))", "user": "52a9154ee4b0c58976d9ac3b"}, {"problem": 95, "code": "(fn is-tree [poss-tree]\n  (cond\n    (nil? poss-tree) true\n   \t(not (sequential? poss-tree)) false\n   \t(not= (count poss-tree) 3) false\n    (nil? (first poss-tree)) false\n    :else (and (is-tree (second poss-tree)) (is-tree (last poss-tree)))))", "user": "546c4c5fe4b00cfc9eacc178"}, {"problem": 95, "code": "(fn bintree? [x]\n  (or\n   (nil? x)\n   (and\n    (coll? x)\n    (= 3 (count x))\n    (not (nil? (first x)))\n    (bintree? (second x))\n    (bintree? (nth x 2)))))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 95, "code": "(fn bt? [x]\n  (if (and (coll? x) (= (count x) 3))\n      (and (or (nil? (second x)) (bt? (second x))) \n           (or (nil? (last x)) (bt? (last x))))\n    false))", "user": "5478c4fee4b0c51c1f4d72c0"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (every? tree? (rest t)))))", "user": "511688d5e4b0b3e208dba05a"}, {"problem": 95, "code": "(fn is-binary-tree [t]\n\t(cond (= t nil) true\n          (not (coll? t)) false\n\t\t  (not= (count t) 3) false\n\t\t  (and (is-binary-tree (nth t 1)) (is-binary-tree (nth t 2))) true\n\t\t  :else false))", "user": "53703287e4b0fc7073fd6e8f"}, {"problem": 95, "code": "(let [container? (fn [obj] (\n\tor\n         (seq? obj)\n         (vector? obj)\n        )\n\n      )\n\n]\n(fn is-legit? [candidate]\n  \t    (or\n         (nil? candidate)\n    \t (and\n         \t(container? candidate)\n     \t\t(= (count candidate) 3)\n     \t\t;(or (not-container? (first candidate)) (is-legit? (first candidate)))\n     \t\t(is-legit? (second candidate))\n            (is-legit? (last candidate))\n         )\n       )\n\t)                                                          \n)", "user": "5471f090e4b094393f72dd6e"}, {"problem": 95, "code": "(fn tree? [[node left right :as xs]]\n  (cond (not (= 3 (count xs))) false \n        (and (nil? left) (nil? right)) true\n        (and (nil? left) (coll? right)) (tree? right)\n        (and (coll? left) (nil? right)) (tree? left)\n        (and (coll? left) (coll? right)) (and (tree? left) (tree? right))\n        :else false))", "user": "546176e7e4b01be26fd746a2"}, {"problem": 95, "code": "(fn b [s]\n  (if (coll? s)\n     (and (= 3 (count s))\n          (not (coll? (first s)))\n          (every? true? (map b (rest s)))) \n     (nil? s)))", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 95, "code": "(fn f [t] (or (nil? t) (and (coll? t) (= (count t) 3) (f (nth t 1)) (f (nth t 2)))))", "user": "4fe9de74e4b0547ebccb2475"}, {"problem": 95, "code": "(fn tree? [[val left right :as node]]\n  (and (= (count node) 3)\n       (or (nil? left)\n           (and (sequential? left)\n                (tree? left)))\n       (or (nil? right)\n           (and (sequential? right)\n                (tree? right)))))", "user": "53613db8e4b0243289761e41"}, {"problem": 95, "code": "(fn f [a]\n  (cond\n   (= false a) false\n   (or (nil? a) (not (coll? a))) true\n   (= 3 (count a)) (and (f (nth a 0)) (f (nth a 1)) (f (nth a 2)))\n   :else false))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 95, "code": "(fn is-tree? [t] \n  (or (nil? t) (and (coll? t) (= (count t) 3) (is-tree? (second t)) (is-tree? (last t)))))", "user": "546a6dbbe4b00cfc9eacc156"}, {"problem": 95, "code": "(fn tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll) \n           (= 3 (count coll))\n           (tree? (second coll))\n           (tree? (nth coll 2)))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 95, "code": "(fn is-node [x]\n  (if x\n    (let [[a & b] x]\n      (and (= 2 (count b))\n           (not (nil? a))\n           (is-node (first b))\n           (is-node (last b)) ))\n    (nil? x)))", "user": "546e4ab8e4b00cfc9eacc19c"}, {"problem": 95, "code": "(letfn [(tree? [x]\n               (if (nil? x)\n                 true\n                 (and (sequential? x)\n                      (= 3 (count x))\n                      (tree? (first (rest x)))\n                      (tree? (second (rest x))))))]\n  tree?)", "user": "547ad587e4b0c51c1f4d72ce"}, {"problem": 95, "code": "(fn bt [t] (or (nil? t) (and (coll? t) (= (count t) 3) (bt (nth t 1)) (bt (nth t 2)))))", "user": "5466199ce4b01be26fd746e2"}, {"problem": 95, "code": "(fn treeornot? [[a b c :as seqz]]\n  (cond (not (sequential? seqz)) false\n        (not= (count seqz) 3) false\n        (sequential? a) false\n        (and (= b nil) (= c nil)) true\n        (and (sequential? b) (= c nil)) (treeornot? b)\n        (and (= b nil) (sequential? c)) (treeornot? c)\n        (and (sequential? b) (sequential? c)) (and (treeornot? b) (treeornot? c))\n        :else false))", "user": "5414b7c4e4b01498b1a719ed"}, {"problem": 95, "code": "(fn tree? [s]\n  (or\n   (nil? s)\n   (and (or (seq? s)\n            (vector? s))\n        (= 3 (count s))\n        (first s)\n        (tree? (second s))\n        (tree? (first (drop 2 s))))))", "user": "4e6a2f93535d8ccf87e9feaa"}, {"problem": 95, "code": "(fn f [x] \n  (if (nil? x) \n    true \n    (and (coll? x) (= (count x) 3) (f (nth x 1)) (f (nth x 2)))))", "user": "5463fbbde4b01be26fd746ca"}, {"problem": 95, "code": "(fn is-tree [tree]\n  (if (nil? tree) true\n      (and (coll? tree)\n           (= 3 (count tree))\n           (let [[a b c] tree]\n             (and (not (nil? a))\n                  (is-tree b)\n                  (is-tree c))))))", "user": "5479c58de4b0c51c1f4d72c7"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5486adf7e4b0e286459a11be"}, {"problem": 95, "code": "(fn is-tree [item]\n  (if (sequential? item)\n    (and (= (count item) 3) \n         (is-tree (nth item 1)) \n         (is-tree (nth item 2)))\n    (= item nil)))", "user": "5483d59fe4b0e286459a1194"}, {"problem": 95, "code": "(fn lcount [l]\n  (and (= 3 (count l))\n       (every? #(if (coll? %)\n                  (lcount %)\n                  (not (false? %)))\n               l)))", "user": "54848141e4b0e286459a119e"}, {"problem": 95, "code": "(fn tree? [xs]\n  (cond \n    (nil? xs) true \n    (not (coll? xs)) false\n    :else (and (= (count xs) 3) (tree? (second xs)) (tree? (last xs)))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 95, "code": "(fn b_tree? [t]\n\t(or (nil? t) \n\t\t(and (coll? t)\n\t\t\t(= (count t) 3)\n\t\t\t(every? b_tree? (rest t)))))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 95, "code": "(fn tree? \n  [x]\n  (if (= x '(:a nil ()))  ;;i don't know why '(:a nil ()) is not a tree,so ^ ^!\n    false\n  (if (or (seq? x) (vector? x)) ;;(seq? []),false,seq?,judge ISeq;\n                                ;;so,(or (seq? x) (vector x))\n                                ;;tree is infinite?, + lazy-seq\n    (and (= (count x) 3)  ;;(count coll), ! coll\n         (tree? (first x))\n         (tree? (second x))\n         (tree? (get x 3)))\n    (and (not= false x) true))))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 95, "code": "(fn is-tree? [[node left right :as args]]\n  (if (= 3 (count args))\n\t(cond (= nil left right) true\n          (and (sequential? left) (sequential? right)) (and (is-tree? left) (is-tree? right))\n          (sequential? left) (and (is-tree? left) (nil? right))\n          (sequential? right) (and (is-tree? right) (nil? left))\n          :else false)\n    false))", "user": "4f748b54e4b044e54cd9a8fa"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n    (or (nil? coll)\n        (and (coll? coll)\n             (= 3 (count coll))\n             (binary-tree? (second coll))\n             (binary-tree? (last coll)))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 95, "code": "(fn tree? [xs]\n  (if (= xs nil)\n    true\n    (if (and (coll? xs) (= (count xs) 3))\n      (and (tree? (nth xs 1)) (tree? (nth xs 2)))\n      false\n    )\n  )\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 95, "code": "(fn b-node? [my-node] (cond (nil? my-node) true\n                             ((complement coll?) my-node) false\n                             :else (and (= (count my-node) 3)\n                                        ((complement seq?) (first my-node))\n                                        (b-node? (second my-node))\n                                        (b-node? (last my-node)) )))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 95, "code": "(fn ibt [t]\n  (if (and (coll? t) (= (count t) 3))\n    (let [[v l r] t]\n      (and (not (coll? v))\n           (or (nil? l) (ibt l))\n           (or (nil? r) (ibt r))\n           ))\n    \n    false)\n  )", "user": "53e745a1e4b036ad0777e479"}, {"problem": 95, "code": "(fn is-tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= (count node) 3)\n           (let [[_ left right] node]\n             (and (is-tree? left) (is-tree? right))))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 95, "code": "(fn btree? [coll]\n  (let [allowed? #(or (not (coll? %))\n                      (btree? %))]\n    (and (= 3 (count (remove false? coll)))\n         (every? allowed? coll))))", "user": "5250b7a5e4b0541d1855b83e"}, {"problem": 95, "code": "(fn bintree? [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= (count coll) 3)\n           (bintree? (second coll))\n           (bintree? (last coll)))))", "user": "54577fefe4b01be26fd7460d"}, {"problem": 95, "code": "(fn f [xs]\n  (if (coll? xs)\n    (and\n     (= (count xs) 3)\n     (every? #(or (coll? %) (nil? %)) (rest xs))\n     (every? f xs))\n    true))", "user": "54926752e4b0b312c081ff44"}, {"problem": 95, "code": "(fn b [[v l r :as t]]\n    (and (= 3 (count t))\n         (if (sequential? l) (b l) (nil? l))\n         (if (sequential? r) (b r) (nil? r))))", "user": "4f9b3532e4b0dcca54ed6d13"}, {"problem": 95, "code": "(fn tree? [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= 3 (count n))\n           (every? tree? (rest n)))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 95, "code": "(fn[x]\n   (let [tree-nodes (tree-seq coll? rest x ) \n         leaves (remove coll? tree-nodes) \n         nodes (filter coll? tree-nodes)]\n   (and (every? nil? leaves ) \n        (not (empty? nodes)) \n        (every? #(= 3 (count %)) nodes)\n           )))", "user": "52d66ca0e4b09f7907dd135c"}, {"problem": 95, "code": "(fn [col] (every? #(if (coll? %) (= 3 (count %))) (->> col (tree-seq coll? rest) (remove nil?))))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 95, "code": "(fn binary [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= (count t) 3)\n           (binary (nth t 1))\n           (binary (nth t 2)))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 95, "code": "(fn btree? [tree]\n   (cond\n     (coll? tree)\n     (and (= 3 (count tree))\n          (btree? (second tree))\n          (btree? (second (rest tree))))\n     (nil? tree) true\n     :else false))", "user": "52e0e646e4b09f7907dd1416"}, {"problem": 95, "code": "(fn is-tree [s]\n  (let [ok (fn [s]\n             (if (coll? s)\n               (is-tree s)\n               ((complement =) false s)))]\n    (if (= (count s) 3)\n      (and (ok (nth s 1)) (ok (nth s 2)))\n      false)))", "user": "547e3846e4b0c51c1f4d7302"}, {"problem": 95, "code": "(fn ch[t]\n  (if (coll? t) \n    (let [a (first t), b (second t), c (second (rest t))]\n      (if (= (count t) 3) (and (if (nil? b) true (ch b)) \n        (if (nil? c) true (ch c))) false)) false ))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 95, "code": "(fn is-tree [nodes]\n  (and (coll? nodes)\n       (= 3 (count nodes))\n       (not (nil? (first nodes)))\n       (or (nil? (second nodes))\n           (is-tree (second nodes)))\n       (or (nil? (nth nodes 2))\n           (is-tree (nth nodes 2)))))", "user": "52b9e920e4b07a9af57922c9"}, {"problem": 95, "code": "(fn bintree? [v]\n (if (nil? v)\n    true\n    (if (or (not (coll? v)) (not= (count v) 3))\n      false\n      (and (bintree? (second v)) (bintree? (last v)))\n    )\n  )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 95, "code": "(fn [x]\n  (letfn [(go [x]\n              (lazy-seq\n               (if (sequential? x)\n                 (lazy-cat [(= (count x) 3)]\n                           (go (nth x 1))\n                           (go (nth x 2)))\n                 [(nil? x)])))]\n    (every? true? (go x))))", "user": "50ef4e2be4b0a78662fa2653"}, {"problem": 95, "code": "(fn bin? [t]\n  (cond (= nil t) true\n        (= false t) false\n        true (and (= 3 (count t))\n                  (bin? (second t))\n                  (bin? (nth t 2))\n                  )))", "user": "4e7e241a535db169f9c79705"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (if (and (coll? t)\n           (= 3 (count t)))\n    (let [left (second t)\n          right (last t)]\n      (and (or (nil? left) (binary-tree? left))\n           (or (nil? right) (binary-tree? right))))\n    false))", "user": "5188c249e4b0bdff0e072d54"}, {"problem": 95, "code": "(fn bintree? [tree]\n  (if (and (sequential? tree) (= 3 (count tree)))\n    (if-not (nil? (second tree))\n      (bintree? (second tree))\n      (if-not (nil? (nth tree 2))\n        (bintree? (nth tree 2))\n        true))\n    false))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 95, "code": "(fn istree [x] (or (nil? x) \n                   (and \n                    (sequential? x)\n                \t(= (count x) 3) \n                \t(not (seq? (first x)))\n                    (istree (second x))\n                    (istree (last x))\n                    )\n                   )\n  )", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 95, "code": "#(every? \n     (fn [x] (= x 2))\n     (map count\n       (map (fn [v]\n          (filter (fn [x] (or (nil? x) (sequential? x))) v))\n            (filter sequential?\n              (tree-seq sequential? seq %)))))", "user": "515b03fee4b0a102a3e5262a"}, {"problem": 95, "code": "(fn t? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (t? (nth t 1))\n           (t? (nth t 2)))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond \n   (or (seq? coll) (vector? coll))\n   (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n   (nil? coll) true\n   :else false))", "user": "54ab6773e4b09f271ff37cc8"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= 3 (count x))\n           (tree? (nth x 1))\n           (tree? (nth x 2)))))", "user": "50b42cbbe4b001349b2f4abe"}, {"problem": 95, "code": "(fn is-bin? [node]\n  \t(cond (or (vector? node)\n              (seq? node)) (and (= 3 (count node))\n                              (is-bin? (nth node 1))\n                              (is-bin? (nth node 2)))\n          (nil? node) true\n          :else false))", "user": "54ae541ae4b09f271ff37cef"}, {"problem": 95, "code": "(fn tree? [possibletree]  (if (nil? possibletree) true\n                       (and\n                           (coll? possibletree)\n                            (= 3 (count possibletree))\n                            (every? tree? (rest  possibletree)))\n                            ))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 95, "code": "(fn binary-tree? [x]\n          (if (coll? x)\n            (and (= 3 (count x))\n                 (or (coll? (second x)) (nil? (second x)))\n                 (every? binary-tree? x))\n            true))", "user": "54b13dbce4b09f271ff37d1c"}, {"problem": 95, "code": "(fn [col] (every? \n            #( and \n               (= 3 (count %)) \n               ((fn [[r a b]] (or \n                                (and (nil? a ) (nil? b))\n                                (and (not (nil? a ))\n                                     (not (nil? b)))\n                                (and (nil? a ) (sequential? b))\n                                (and (nil? b ) (sequential? a))\n                               \n                               )) %))\n\n            (filter sequential? (tree-seq sequential? identity col))))", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 95, "code": "(fn isbt [xs]\n  (cond\n    (nil? xs) true\n    (and (sequential? xs) \n         (= (count xs) 3)) (and (isbt (second xs)) \n                                (isbt (second (rest xs))))\n    :else false))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 95, "code": "(fn [root]\n  (let [node? #(and (sequential? %) (= 3 (count %)))]\n    (every? node? (remove nil? (tree-seq node? rest root)))))", "user": "53e3f7a8e4b036ad0777e408"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (and (coll? t)\n       (= 3 (count t))\n       (let [[a b c] t]\n         (and (not (is-tree? a))\n              ((some-fn nil? is-tree?) b)\n              ((some-fn nil? is-tree?) c)))))", "user": "536b9d8ae4b0243289761ebe"}, {"problem": 95, "code": "(fn istree? [branch]\n  (if (and\n       (sequential? branch)\n       (= 3 (count branch)))\n    (let [b1 (first (rest branch))\n          b2 (second (rest branch))]\n      (and (if (nil? b1)\n             true\n             (istree? b1))\n           (if (nil? b2)\n             true\n             (istree? b2))))\n      false))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 95, "code": "(fn func [col] (if (sequential? col) (if (= 3 (count col)) (and (-> col first func) (-> col next first func) (-> col next next first func)) false) (not (false? col))))", "user": "53347274e4b0656e627bfd6b"}, {"problem": 95, "code": "(fn f [t]\n  (if (nil? t)\n    true\n    (if (and (coll? t) (= 3 (count t)))\n      (and (f (nth t 1)) (f (nth t 2)))\n      false)))", "user": "54b2ec84e4b09f271ff37d33"}, {"problem": 95, "code": "(fn [t]\n (every?\n  #(and (= (count %) 3)\n        (not (some false? %)))\n  (filter\n   sequential?\n   (tree-seq\n    sequential?\n    seq\n    t))))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 95, "code": "(fn is-tree [t]\n  (if-not (sequential? t) (nil? t)\n    (if-not (= 3 (count t)) false\n      (let [[v l r] t]\n        (and (not (sequential? v))\n             (is-tree l)\n             (is-tree r))))))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 95, "code": "(fn tree? [tree]\n  (cond\n    (coll? tree)\n    (and (= (count tree) 3) (every? tree? tree))\n    (false? tree)\n    false\n    true\n    true))", "user": "54bad522e4b0ed20f4ff6eb8"}, {"problem": 95, "code": "(fn isBinary[l]\n  (if-not (and (= 3 (count l)) (or (nil? (last l)) (coll? (last l))) (or (nil? (second l)) (coll? (second l))))\n    false    \n    (loop [l l]\n      (if (and (coll? (peek l)) (not (isBinary (peek l))))\n        false\n        (if (seq l)\n          (recur (pop l))\n          true\n          )\n        )\n      )\n    )\n  )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 95, "code": "(fn node [n]\n   (if (nil? n)\n     true\n     (if (or (not (coll? n)) (not= (count n) 3))\n       false\n       (and (node (nth n 1)) (node (nth n 2)))))\n   )", "user": "534bfc71e4b084c2834f4a88"}, {"problem": 95, "code": "(fn t? [t]\n  (or (nil? t)\n      (and (coll? t) (= 3 (count t))\n           (let [[h l r] t]\n             (and h (t? l) (t? r))))))", "user": "54acf5c7e4b09f271ff37cdd"}, {"problem": 95, "code": "(fn t [x] (or (nil? x) (and (coll? x) (= 3 (count x)) (every? t (rest x)))))", "user": "52a267c6e4b04e0c58e87bef"}, {"problem": 95, "code": "(fn b [xs]\n  (cond\n   (= xs nil) true\n   (= xs false) false\n   (not= (count xs) 3) false\n   :else (and (b (nth xs 1)) (b (nth xs 2)))))", "user": "54ab502fe4b09f271ff37cc4"}, {"problem": 95, "code": "(fn tree [s]\n  (if (and (coll? s) (= (count s) 3))\n    (let [l (nth s 1)\n          r (nth s 2)]\n      (and (or (nil? l) (tree l))\n           (or (nil? r) (tree r))))\n    false))", "user": "54b95f3de4b0ed20f4ff6eab"}, {"problem": 95, "code": "(fn bin-tree? [root]\n  (or (nil? root)\n      (and (coll? root)\n           (= 3 (count root))\n           (bin-tree? (second root))\n           (bin-tree? (last root)))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 95, "code": "(fn b-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? b-tree? (rest root)))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 95, "code": "(fn is-tree [x]\n  (or\n   (nil? x)\n   (and\n    (sequential? x)\n    (= 3 (count x))\n    (is-tree (second x))\n    (is-tree (last x)))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 95, "code": "(fn bin-tree? [node]\n  (do (println node)\n  (if (nil? node)\n    true\n    (and (coll? node)\n         (= 3 (count node))\n         (not (some #(and (= % (lazy-seq)) (empty? %)) node))\n         (bin-tree? (get node 1)) \n         (bin-tree? (get node 2))))))", "user": "5235493ee4b05e80434a5064"}, {"problem": 95, "code": "(fn __ [s]\n  (or (nil? s)\n\t  (and (coll? s)\n    \t   (= (count s) 3)\n    \t   (not (nil? (first s)))\n    \t   (not (coll? (first s)))\n       \t   (__ (first (rest s)))\n           (__ (second (rest s)))\n         )\n     )\n  )", "user": "54c271b9e4b045293a27f602"}, {"problem": 95, "code": "(fn bin-tree? [t]\n  (if (nil? t)\n    true\n    (let [has-two-children (and (coll? t) (= (count t) 3))]\n      (and has-two-children\n           (bin-tree? (nth t 1))\n           (bin-tree? (nth t 2))))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 95, "code": "(fn t [x] (or (nil? x) (and (coll? x) (= 3 (count x)) (every? t (rest x)))))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 95, "code": "(fn btr [tr]\n    (or (nil? tr)\n        (and (sequential? tr)\n            (= (count tr) 3)\n            (every? btr (rest tr)))))", "user": "54b6c24be4b0ed20f4ff6e7c"}, {"problem": 95, "code": "(fn is-tree [coll]\n  (and (coll? coll)\n       (= 3 (count coll))\n       (or (nil? (last coll))\n           (is-tree (last coll)))\n       (or (nil? (second coll))\n           (is-tree (second coll)))))", "user": "546692aee4b01be26fd746e7"}, {"problem": 95, "code": "(fn valid-treenode? [n]\n  (and \n   (= 3 (count n))\n   (every? (fn [x] (cond \n                    (sequential? x) (valid-treenode? x)\n                    (= false x) false \n                    :else true)) n)))", "user": "532902f8e4b09d4e7a9b550e"}, {"problem": 95, "code": "(fn is-tree [tree]\n  (cond\n    (nil? tree) true\n    (or (not (coll? tree)) (not= 3 (count tree))) false\n    :else (and\n            (is-tree (nth tree 1))\n            (is-tree (nth tree 2)))))", "user": "54c8d4a8e4b045293a27f654"}, {"problem": 95, "code": "(fn isTree [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= 3 (count x))\n           (isTree (second x))\n           (isTree (last x))\n           )))", "user": "54c169ade4b0ed20f4ff6f24"}, {"problem": 95, "code": "(fn tree?\n  [tree]\n  (or (nil? tree)\n      (if (coll? tree)\n        (and (= 3 (count tree))\n             (tree? (second tree))\n             (tree? (last tree)))\n        false)))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 95, "code": "(fn tree?\n    [[data left right :as s]\n     ]\n    (or (nil? s)\n        (and (or (coll? left) (nil? left))\n             (or (coll? right) (nil? right))\n             (= (count s) 3)\n             (tree? left)\n             (tree? right))))", "user": "525d490ae4b0cb4875a45d70"}, {"problem": 95, "code": "(fn binary-tree [a]\n(if (nil? a) true (and (coll? a) (= (count a) 3) (binary-tree (nth a 1)) (binary-tree (nth a 2)))))", "user": "525b142fe4b0cb4875a45d05"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (coll? t)\n    (and (= (count t) 3)\n         (every? tree? (rest t)))\n    (nil? t)))", "user": "4ed45563535d10e5ff6f52c9"}, {"problem": 95, "code": "(fn tree? [n]\n  (or (nil? n)                                              ;; nil is a tree\n      (and (coll? n)                                        ;; should be a collection\n           (= 3 (count n))                                  ;; with length 3\n           (every? tree? (rest n)))))                       ;; with all children as tree", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (binary-tree? (second tree))\n           (binary-tree? (last tree)))))\n;\n;(fn binary-tree? [tree]\n;  (if (nil? tree)\n;    true\n;    (if-let [[value left right] (when (and (coll? tree)\n;                                           (= 3 (count tree)))\n;                                  tree)]\n;      (and (binary-tree? left) (binary-tree? right))\n;      false)))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 95, "code": "(fn node? [tree]\n         (cond (nil? tree) true\n               (not (coll? tree)) false\n               (not= 3 (count tree)) false\n               :else (let [[v n1 n2] tree]\n                       (and (not (coll? v))\n                            (node? n1)\n                            (node? n2)))))", "user": "52950ab6e4b02ebb4ef7501a"}, {"problem": 95, "code": "(fn t? [n]\n  (cond\n\t(= nil n) true\n    (not (instance? clojure.lang.Seqable n)) false\n    (not= (count n) 3) false\n    :else (let [[_ l r] n] (and (t? l) (t? r)))))", "user": "54c641f8e4b045293a27f628"}, {"problem": 95, "code": "(fn istree [t]\n  (if (sequential? t)\n    (and (= 3 (count (seq t)))\n         (istree (nth t 1))\n         (istree (nth t 2)))\n    (= nil t)))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 95, "code": "(fn [xs] (letfn [(valid? [t] \n                         (and (sequential? t)\n                              (= 3 (count t))\n\t\t\t\t\t\t\t  (not (nil? (first t)))\t\t\t  \n                              (or (nil? (second t)) (valid? (second t))) \n                              (or (nil? (last t)) (valid? (last t)))))] \n           (valid? xs)))", "user": "54d03026e4b018d918be98de"}, {"problem": 95, "code": "(fn tree? [n]\n      (or (nil? n)\n          (and (sequential? n)\n               (= 3 (count n))\n               (let [[v l r] n]\n                 (and v\n                      (tree? l)\n                      (tree? r))))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 95, "code": "(fn tree?\r\n  [t]\r\n  (if (and (coll? t) (= 3 (count t)))\r\n    (let [ [_ & ab] t]\r\n      (every? #(or (nil? %) (tree? %)) ab))\r\n    false))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 95, "code": "(fn [t]\n  (loop [v t, l (second t), r (last t), not-checked []]\n    (cond\n     (not= 3 (count v))        false\n     (and (coll? l) (coll? r)) (recur l (second l) (last l) (conj not-checked r))\n     (coll? l)                 (recur l (second l) (last l) not-checked)\n     (coll? r)                 (recur r (second r) (last r) not-checked)\n     (not-empty not-checked)   (let [r (first not-checked)]\n                                 (recur r (second r) (last r) (rest not-checked)))\n     :else                     (= nil l r))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 95, "code": "(fn bintree [tree] \n  (and \n    (= 3 (count tree))\n    (or\n      (= nil (second tree))\n      (and\n        (sequential? (second tree))\n        (bintree (second tree))\n      )\n    )\n    (or\n      (= nil (last tree))\n      (and\n        (sequential? (last tree))\n        (bintree (last tree))\n      )\n    )\n  )   \n)", "user": "50e3cf55e4b01912b3285c45"}, {"problem": 95, "code": "(fn is-btree [sq]\n  (if (or (not (coll? sq)) \n          (= 0 (count sq)) \n          (not= 0 (mod (count sq) 3))) false\n  \t(let [node (first sq)\n          left (second sq)\n          right (nth sq 2)]\n      ;(println node left right)\n      (and  (or (nil? left) (is-btree left))\n       \t\t(or (nil? right) (is-btree right))\n))))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 95, "code": "(fn is-tree? [tr]\n  (if-not (sequential? tr)\n    (nil? tr)\n    (and (= 3 (count tr)) (is-tree? (last tr)) (is-tree? (nth tr 1)) )))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 95, "code": "(fn tree? [x]\n  (cond\n    (nil? x)\n    true\n    \n    (and (coll? x) (= 3 (count x)))\n    (and (tree? (second x)) (tree? (nth x 2)))\n\n    :else\n    false))", "user": "54c23252e4b045293a27f5fc"}, {"problem": 95, "code": "(fn f [v]\n   (cond\n      (nil? v) true\n      (not (coll? v)) false\n      (not= 3 (count v)) false\n      :else (let [[_ left right] v] (and (f left) (f right)))))", "user": "5493d908e4b0b312c081ff52"}, {"problem": 95, "code": "(fn tree [xs]\n  (if xs (and (= (count xs) 3) (tree (second xs)) (tree (last xs))) (= nil xs)))", "user": "54d70f40e4b0a52adc2e2027"}, {"problem": 95, "code": "(fn p [col]\n  (cond \n        (nil? col) true\n        (false? col) false\n        (and (not (nil? col)) (empty? col)) false\n        (and (not= (count col) 3)) false\n        (or (vec col) (list? col)) (and (p (nth col 1))\n                         (p (nth col 2)))\n        :else true))", "user": "53664e3be4b0243289761e74"}, {"problem": 95, "code": "(fn f [t]\n  (cond\n   (nil? t) true\n   (and (coll? t) (= 3 (count t))) (and\n                                   (first t)\n                                   (f (nth t 1))\n                                   (f (nth t 2))\n                                   true)\n  :else false))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "51e8ee6be4b07cae92c04bfd"}, {"problem": 95, "code": "(fn tree? [t] \n  (or (nil? t)\n      (and\n       (coll? t)\n       (= 3 (count t))\n       (tree? (nth t 1))\n       (tree? (nth t 2)))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 95, "code": "(fn f[s]\n    (if(coll? s) \n      (and \n       (= 3 (count s))\n       (every? f (rest s))\n       )\n      (nil? s)))", "user": "51eca2ace4b069f463c22cd0"}, {"problem": 95, "code": "(fn binary-tree? [root]\n  (or (nil? root)\n      (and (coll? root)\n           (= 3 (count root))\n           (let [[_ left right] root]\n             (and (binary-tree? left)\n                  (binary-tree? right))))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 95, "code": "(fn [s]\n           (let [xs (tree-seq sequential? seq s)\n                 xsq (filter sequential? xs)\n                 xv (filter (complement sequential?) xs)\n                 xy (filter #(= (count %) 3) xsq)]\n             (and (= (count xsq) (count xy))\n                  (not-any? false? xv))))", "user": "52d84ea7e4b09f7907dd1390"}, {"problem": 95, "code": "(fn is-tree [n] (cond \n                 (nil? n) true\n                 (not (coll? n)) false\n                 (not= 3 (count n)) false\n                 :else (and (is-tree (nth n 1)) (is-tree (nth n 2)))))", "user": "54cbe00ee4b057c6fda3a285"}, {"problem": 95, "code": "(fn tree? [candidate] \n    (if (nil? candidate) \n      true      \n      (if (and (sequential? candidate) (= (count candidate) 3))\n        (let [value (nth candidate 0) \n              left (nth candidate 1)\n              right (nth candidate 2)]\n          (and (not (= value nil)) (tree? left) (tree? right)))\n        false)\n      )\n    )", "user": "54cb3497e4b057c6fda3a272"}, {"problem": 95, "code": "(fn p95-tree [x]\n  (if (= (count x) 3)\n    (if (and\n          (or (nil? (nth x 1)) (and\n                                 (coll? (nth x 1))\n                                 (p95-tree (nth x 1))))\n          (or (nil? (nth x 2)) (and\n                                 (coll? (nth x 2))\n                                 (p95-tree (nth x 2)))))\n      true\n      false)\n    false))", "user": "543b12cce4b032a45b86932a"}, {"problem": 95, "code": "(fn is-binary-tree [xs]\n  (if (coll? xs)\n    (if (not= 3 (count xs))\n      false\n      (and (is-binary-tree (nth xs 1))\n           (is-binary-tree (nth xs 2))))\n    (nil? xs)))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 95, "code": "(fn tree? [c]\n  (if (nil? c)\n    true\n    (if (and (coll? c) (= 3 (count c)))\n      (let [[_ left right] c]\n        (and (tree? left) (tree? right)))\n      false)))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 95, "code": "(fn [node]\n  (let [recp\n        (fn tree [node]\n          (if (sequential? node)\n            (if (= (count node) 3)\n              (cons true (lazy-seq (concat (tree (nth node 1)) (tree (nth node 2)))))\n              (list false))\n            (list (nil? node))))]\n    (every? identity (recp node))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (and (coll? t) (not= 3 (count t))) false\n        (not (coll? t)) false\n        :else (let [[n r l] t]\n          \t\t(and (not (coll? n))\n               \t\t(tree? l)\n               \t\t(tree? r)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 95, "code": "(fn istree [tree] (let [[value left right] tree]\n                    (condp = tree\n                      [value nil nil] true\n                      [value left nil] (and (coll? left) (istree left))\n                      [value nil right] (and (coll? right) (istree right))\n                      [value left right] (and (coll? left) (coll? right) (istree left) (istree right))\n                      false)))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 95, "code": "(fn is-tree? [s]\n  (or\n    (nil? s)\n    (and\n     (coll? s)\n     (= (count s) 3)\n     (is-tree? (second s))\n     (is-tree? (nth s 2)))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 95, "code": "(fn f\n   ([v] (if (= 3 (count v))\n              (f (first v) (second v) (last v))\n              false))\n   ([v l r] (and (not (coll? v))\n                 (if (coll? l)\n                   (f l)\n                   ((complement false?) l))\n                 (if (coll? r)\n                   (f r)\n                   ((complement false?) r)))))", "user": "4ec66e84535d6d7199dd36cd"}, {"problem": 95, "code": "(fn binary-tree?\n   [tree]\n   (or (nil? tree)\n       (and (coll? tree)\n         (= 3 (count tree))\n         (binary-tree? (second tree))\n         (binary-tree? (last tree)))))", "user": "510a3cd4e4b06956752d35ad"}, {"problem": 95, "code": "(fn is-tree\n  [tree]\n  (if (or (seq? tree) (vector? tree))\n    (and (= 3 (count tree)) (is-tree (nth tree 1)) (is-tree (nth tree 2)))\n    (nil? tree)))", "user": "54e0e911e4b024c67c0cf7bc"}, {"problem": 95, "code": "(fn [[node left right :as treet]]\n    (letfn [(branch? [[_ l r :as t]]\n              (and (= 3 (count t))\n                   (if (sequential? l)\n                     (branch? l)\n                     (nil? l))\n                   (if (sequential? r)\n                     (branch? r)\n                     (nil? r))))]\n      (branch? treet)))", "user": "54e79094e4b024c67c0cf818"}, {"problem": 95, "code": "(fn ! [n]\n  (if (counted? n)\n    (if (= (count n) 3)\n      (let [[v l r] n]\n        (and\n         (or (nil? l)\n             (! l))\n         (or (nil? r)\n             (! r))))\n      false)\n    false))", "user": "4f85a75ce4b033992c121c48"}, {"problem": 95, "code": "(fn bt? [[root l r :as c]]\n  (and (not (nil? root))\n       (= (count c) 3)\n       (or (nil? l) (and (coll? l) (bt? l)))\n       (or (nil? r) (and (coll? r) (bt? r)))))", "user": "54ddb556e4b024c67c0cf798"}, {"problem": 95, "code": "(fn is-tree [x]\n  (letfn [(is-subtree [y]\n                      (or (nil? y)\n                          (is-tree y)))]\n    (and (sequential? x)\n         (= (count x) 3)\n         (is-subtree (nth x 1))\n         (is-subtree (nth x 2)))))", "user": "547fbe01e4b0c51c1f4d7321"}, {"problem": 95, "code": "(fn [lst] (every? #(and (sequential? %) (= 3 (count %))) (remove nil? (tree-seq sequential? rest lst))))", "user": "52570aeae4b0541d1855ba42"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (coll? t)\n    (and (= 3 (count t)) (every? identity (map tree? (rest t))))\n    (nil? t)))", "user": "53968a70e4b0b51d73faaee0"}, {"problem": 95, "code": "(fn istree?\n  [x]\n  (if (nil? x) true\n    (if-not (sequential? x) false\n      (if-not (= (count x) 3) false\n        (and (istree? (nth x 1)) (istree? (nth x 2)))))))", "user": "4e68c465535d8ccf87e9fe8a"}, {"problem": 95, "code": "(fn is-bintree [thing]\n  (cond\n    (nil? thing)\n    true\n\n    (not (sequential? thing))\n    false\n\n    (= (count thing) 3)\n    (and (is-bintree (nth thing 1))\n         (is-bintree (nth thing 2)))\n\n    :else\n    false))", "user": "532b43c3e4b09d4e7a9b5531"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (if (nil? t)\n    true\n    (if (and (coll? t) (= 3 (count t)))\n      (let [[root left right] t]\n        (and (is-tree? left) (is-tree? right)))\n    false\n  )))", "user": "54b050cee4b09f271ff37d13"}, {"problem": 95, "code": "(fn is-tree [form]\n  (cond\n   (nil? form) true\n   (and (or (seq? form) (vector? form)) (= (count form) 3))\n        (and \n         (is-tree (nth form 1))\n         (is-tree (nth form 2)))\n   :else false))", "user": "540d5085e4b0addc1aec670e"}, {"problem": 95, "code": "(letfn [(f [n] (if (and (sequential? n) (seq n)) (if (= (count n) 3) (and (f (second n)) (f (nth n 2))) false) (nil? n)))] f)", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 95, "code": "(fn tnt[c]\n  (cond (nil? c) true\n        (not (coll? c)) false\n        (not= 3 (count c)) false\n        :else (let [vl (first c)\n                    r1 (rest c)\n                    lc (first r1)\n                    r2 (rest r1)\n                    rc (first r2)]\n                (if (or (coll? vl)\n                        (empty? r1)\n                        (empty? r2))\n                  false\n                  (and (tnt lc)(tnt rc))))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 95, "code": "(fn tree? [s]\n    (if (nil? s) true\n        (if (sequential? s)\n          (let [[p l r] s]\n            (if (not= 3 (count s)) false\n                (and (tree? l) (tree? r))))\n          false)))", "user": "52b2f9cae4b0c58976d9acfb"}, {"problem": 95, "code": "(fn istree? [tree]\n  (println tree)\n  (cond (nil? tree) true\n        (not (coll? tree)) false\n        (not= (count tree) 3) false\n        (nil? (first tree)) false\n        :else (and (istree? (second tree))(istree? (nth tree 2)))))", "user": "518ba795e4b0f028e99addf0"}, {"problem": 95, "code": "(fn treecheck  [tree]\n    (or (nil? tree)\n        (and\n          (coll? tree)\n          (= 3 (count tree))\n          (treecheck (second tree))\n          (treecheck (last tree)))))", "user": "546a6c7ce4b00cfc9eacc154"}, {"problem": 95, "code": "(fn tree? [t]\n  (let [value? #(or\n                  (nil? %)\n                  (number? %)\n                  (keyword? %))]\n    (or (value? t)\n      (and (or (vector? t) (seq? t))\n           (= 3 (count t))\n           (value? (first t))\n           (tree? (nth t 1))\n           (tree? (nth t 2))))))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 95, "code": "(fn bt? [tree]\n  (and (= 3 (count tree))\n       (every? #(or (nil? %)\n                    (and (or (vector? %) (seq? %))\n                         (bt? %)))\n               (rest tree))))", "user": "5463c824e4b01be26fd746c5"}, {"problem": 95, "code": ";; chokes on last 2\n;; (fn [coll] (= 0 (rem (reduce + (map count (tree-seq next rest coll))) 3)))\n\n;; so a brute force instead of tree-seq\n(fn is-tree? [coll]\n  (and (sequential? coll)\n       (= 3 (count coll)) \n       (every? #(or (nil? %) (is-tree? %)) (rest coll))))", "user": "54485727e4b032a45b8693c6"}, {"problem": 95, "code": "(fn tree [xs]\n  (if (nil? xs) true\n    (if (or\n          (not (coll? xs))\n          (not= (count xs) 3)) false \n      (let [[v l r] xs]\n        (and (tree l) (tree r))))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 95, "code": "(fn t?\n  [[_ & c]]\n  (if (= 2 (count c))\n    (every? true? (map #(or (nil? %) (if (sequential? %) (t? %) false)) c))\n    false))", "user": "51a4d802e4b0def3c5c5869a"}, {"problem": 95, "code": "(fn is-tree [x]\n  (or (nil? x)\n    (and (coll? x)\n         (= 3 (count x))\n        (let [[_ a b] x]\n         (and (is-tree a) (is-tree b))\n         ))))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 95, "code": "(fn f [t] \n  (if (coll? t) \n\t(let [[_ a b] t]\n\t\t(and (= 3 (count t)) (f a) (f b)))\n\t(nil? t)))", "user": "4ee7d6d8535d93acb0a66870"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (not (sequential? (first t)))\n           (tree? (second t))\n           (tree? (last t)))))", "user": "54fdbe3fe4b07d26eda61d3b"}, {"problem": 95, "code": "(fn is-bin-tree [t]\n  (letfn [(vecorlist [v] (or (vector? v) (list? v)))]\n    (and (= 3 (count t)) (every? #(if (vecorlist %) (is-bin-tree %) (not= false %)) t))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 95, "code": "(fn [s] (and (= (count s) 3)\n             (every? #(= 3 %) (map count (filter coll? (tree-seq coll? seq s))))\n             (every? nil? (remove coll? (tree-seq coll? rest s)))))", "user": "54e2a779e4b024c67c0cf7d3"}, {"problem": 95, "code": "(fn is-tree? [node]\n  (if (coll? node)\n    (and (= 3 (count node))\n         (every? is-tree? (rest node)))\n    (nil? node)))", "user": "54edfa10e4b024c67c0cf868"}, {"problem": 95, "code": "(fn isTree\n  [x]\n  (cond\n   (nil? x) true\n   (not (sequential? x)) false\n   (not (= (count x) 3)) false\n   :else (and (isTree (nth x 1)) (isTree (nth x 2)))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 95, "code": "(fn b-tree? [x]\n   (or (nil? x)\n       (and (coll? x)\n            (= 3 (count x))\n            (every? b-tree? (rest x)))))", "user": "51f66891e4b06ff1c25c52c1"}, {"problem": 95, "code": "(fn [coll]\n  (let [tree          (tree-seq sequential? rest coll)\n        valid-child?  (fn [n] (nil? n))\n        valid-parent? (fn [n] (and (sequential? n) (= (count n) 3)))\n        valid-node?   (fn [n] (or (valid-child? n) (valid-parent? n)))]\n    (= (distinct (map valid-node? tree)) '(true))))", "user": "54b83ae9e4b0ed20f4ff6e95"}, {"problem": 95, "code": "(fn [t]\n  (->> (tree-seq coll? next t)\n       (remove (every-pred coll? #(= 3 (count %))))\n       (remove nil?)\n       (empty?)))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 95, "code": "(fn is-tree [s]\n  (or (nil? s)\n      (and (sequential? s)\n           (= 3 (count s))\n           (is-tree (second s))\n           (is-tree (last s)))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 95, "code": "(fn this [t]\n  (if (coll? t)\n    (and (= 3 (count t)) (this (nth t 1)) (this (nth t 2)))\n    (nil? t)))", "user": "5280539ce4b0757a1b1713f3"}, {"problem": 95, "code": "(fn treeTest [n]  \n  (and (coll? n) (== 3 (count n)) (not= (first n) nil) ((fn leafTest [leaf]\n    (or (= leaf nil) (treeTest leaf))  \n  ) (second n)) ((fn leafTest [leaf]\n    (or (= leaf nil) (treeTest leaf))  \n  ) (last n)))\n)", "user": "55034bf0e4b086ebe8a79c6d"}, {"problem": 95, "code": "(fn check [t]\n  (if (or (nil? t)\n          (and (sequential? t)\n               (= 3 (count t))\n               (check (second t))\n               (check (last t))))\n    true false))", "user": "55088bb3e4b06e50f9beb10c"}, {"problem": 95, "code": "(fn tree? [v]\n  (if (coll? v)\n    (and (= 3 (count v)) (tree? (nth v 1)) (tree? (nth v 2)))\n    (nil? v)))", "user": "5481be5fe4b0e286459a1172"}, {"problem": 95, "code": "(fn tree-\n  [collumn]\n  (cond\n    (coll? collumn) (and (= 3 (count collumn))\n                         (let [[k v1 v2] collumn]\n                           (let [x1 (tree- v1)\n                                 x2 (tree- v2)]\n                             (and x1 x2))))\n    (nil? collumn) true\n    :else false))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 95, "code": "(fn rec [t]\n  (if (nil? t)\n    true\n    (if (and (not (seq? t)) (not (vector? t)))\n      false\n      (and (= (count t) 3) (rec (second t)) (rec (last t))))))", "user": "55058a4fe4b086ebe8a79c89"}, {"problem": 95, "code": "(fn is-a-tree? [coll]\n   (cond\n     (nil? coll) true\n     (sequential? coll) (and (= 3 (count coll))\n                             (is-a-tree? (nth coll 1))\n                             (is-a-tree? (nth coll 2)))\n     :else false))", "user": "52cee992e4b07d0d72b27395"}, {"problem": 95, "code": "(fn b? [s]\n  (let [y? #(or (nil? %) (b? %))]\n    (and (sequential? s) \n         (= 3 (count s)) \n         (not (sequential? (first s)))\n         (y? (second s))\n         (y? (last s)))))", "user": "54e606c3e4b024c67c0cf803"}, {"problem": 95, "code": "(fn is-tree [x] \n  (cond\n   ((complement coll?) x) \n   \t\t(if (= x false) false true)\n   (not= 3 (count x)) false\n   :else (and (is-tree (second x)) (is-tree (last x)))))", "user": "54e0a9c3e4b024c67c0cf7b5"}, {"problem": 95, "code": "(fn isBin [t] (and (and (coll? t) (= (count t) 3)) (let [[v l r] t] (and (or (= nil l) (isBin l)) (or (= nil r) (isBin r))))))", "user": "550e0373e4b06e50f9beb162"}, {"problem": 95, "code": "(fn bin-tree? [tree]\n\t(let [[val left right] tree]\n\t\t(and (= (count tree) 3)\n\t\t\t(or (nil? left) (and (coll? left) (bin-tree? left)))\n\t\t\t(or (nil? right) (and (coll? right) (bin-tree? right))))))", "user": "54eea988e4b024c67c0cf875"}, {"problem": 95, "code": "#(letfn [(testele [node]\n                   (cond (= nil node)       true\n                         (not node)         false\n                         (= 3 (count node)) (and (testele (nth node 1)) (testele (nth node 2)))\n                         :else              false))]\n         (testele %))", "user": "544e8369e4b0e39780006987"}, {"problem": 95, "code": "(fn is-bin\n  [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= (count t) 3)\n           (is-bin (nth t 1))\n           (is-bin (nth t 2)))))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": 95, "code": "(fn p95 ([n] (or\n         (nil? n)\n         (and\n           (coll? n)\n           (= 3 (count n))\n           (every? true? (map p95 (rest n))))\n         false)))", "user": "54d8cc38e4b0a52adc2e203e"}, {"problem": 95, "code": "(fn is-tree? [col]\t\n\t(or (nil? col)\n\t  (and (sequential? col)\n\t  \t(= 3 (count col))\t  \t\n\t\t(is-tree? (second col) )\n\t\t(is-tree? (last col) ))\n\t))", "user": "54f4a457e4b0f2f3c5226e83"}, {"problem": 95, "code": "(fn trii? [coll]\n  (let [length (if (sequential? coll) (count coll) 0)]\n    (condp = length\n      0 (nil? coll)\n      3 (and (trii? (nth coll 1))\n             (trii? (nth coll 2)))\n      false)))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 95, "code": "(fn tree? [col]\n  (let [leaf? (fn [x] (nil? x))]\n    (cond \n      (not (coll? col)) false\n      (not= 3 (count col))      false\n      (and (not (coll? (first col))) \n           (if (coll? (second col))   \n               (tree? (second col))\n               (not= false (second col)))\n           (if (coll? (last col))\n               (tree? (last col))\n               (not= false (last col)))) true\n       :else false)))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 95, "code": "(fn btree? [node]\n  (if (nil? node)\n    true\n    (if (and (sequential? node)\n             (= 3 (count node))\n             (btree? (second node))\n             (btree? (nth node 2)))\n      true\n      false)))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 95, "code": "(fn t? [tree]\n  \n  (cond (not (empty? (filter #(= % false) (flatten tree)))) false\n   \t\t(or (nil? tree) (not (coll? tree))) true\n        (and (= (count tree) 3) (t? (nth tree 0)) (t? (nth tree 0)) (t? (nth tree 2))) true\n        :else false)\n)", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "54bcab07e4b0ed20f4ff6ed5"}, {"problem": 95, "code": "(fn is-tree? [coll]\n   (and (coll? coll)\n        (= 3 (count coll))\n        (not (coll? (first coll)))\n        (every? #(or (nil? %)\n                     (is-tree? %)) (rest coll))))", "user": "4fa5c8dde4b081705acca1af"}, {"problem": 95, "code": "(fn tree? [s]\n  (letfn \n    [(right-size? [coll] (and coll (= 3 (count coll))))\n     (has-value? [v] ((complement nil?) v))\n     (child? [d] (or (nil? d) (tree? d)))]\n    (if (right-size? s)\n      (let [[v l r] s]\n        (and\n         (has-value? v)\n         (child? l)\n         (child? r)))\n      false)))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (if (nil? t)\n    true\n    (and t\n         (= (count t) 3)\n         (is-tree? (second t))\n         (is-tree? (nth t 2)))))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 95, "code": "(fn __ [t]\n  (if (= (count t) 3)\n    (let [v (first t)\n          l (second t)\n          r (last t)]\n      (if (coll? l)\n        (__ l)\n        (if (nil? l)\n          (if (coll? r)\n            (__ r)\n            (if (nil? r)\n              true\n              false))\n          false)))\n    false))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 95, "code": "(fn bin-tree? [tree]\n  (letfn [(term-node? [n] (nil? n))\n          (cont-node? [n] (and (coll? n) (= (count n) 3)))\n          (valid-branch? [tree branch-selector] \n            (loop [tree tree]\n              (cond\n                (term-node? tree) true\n                (cont-node? tree) (recur (branch-selector tree))\n                :else false)))]\n    (and (valid-branch? tree #(nth % 1)) \n         (valid-branch? tree #(nth % 2)))))", "user": "50f02de7e4b0bdaecbb47db0"}, {"problem": 95, "code": "(fn tree? [n]\n  (cond\n    (= nil n) true\n    (not (coll? n)) false\n    (not= (count n) 3) false\n    :else (and (tree? (second n)) (tree? (last n)))))", "user": "55170dd9e4b06a49daca83bd"}, {"problem": 95, "code": "(fn p95 [tree]\n  (if (and (sequential? tree) (= 3 (count tree)))\n    (let [left (second tree)\n          right (second (rest tree))\n          branch-node #(or (nil? %)(p95 %))]\n      (if (and (branch-node left) (branch-node right))\n        true false))\n    false))", "user": "550ff2a3e4b06e50f9beb17f"}, {"problem": 95, "code": "(fn node? [node]\n  (let [leaf? (every-pred (complement sequential?))]\n    (if (every? leaf? node)\n      (and (= (count node) 3) (not (false? (second node))))\n      (if (= (count node) 3)\n        (every? node? (filter sequential? node))\n        false))))", "user": "552356fae4b0882d96d091af"}, {"problem": 95, "code": "(fn f [args] (and (= 3 (count args)) (every? #(if (sequential? %) (f %) (nil? %)) (rest args))))", "user": "50f53694e4b057d4c52de881"}, {"problem": 95, "code": "(fn bin-tree? [x]\n  (loop [[x & more :as to-check] [x]]\n    (cond\n      (empty? to-check)   true\n      (nil? x)            (recur more)\n      (not (coll? x))     false\n      (not= 3 (count x))  false\n      :else               (recur (conj more (second x) (last x))))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 95, "code": "(fn tr [v1]\n          (and (= 3 (count v1))\n               (every? #(or (nil? %) (and (sequential? %) (tr %))) (drop 1 v1))\n               \n               )\n          )", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 95, "code": "(fn bi? [x] \n      (or (nil? x)\n      \t  (and (sequential? x) (= (count x) 3) (every? bi? (rest x) ))\n\t  )\n)", "user": "5527dca0e4b0ffed3738f938"}, {"problem": 95, "code": "(fn binary-tree?\n  [x]\n  (if (coll? x)\n    (and (= (count x) 3)\n         (not (coll? (first x)))\n         (binary-tree? (second x))\n         (binary-tree? (last x)))\n    (nil? x)))", "user": "551ecb76e4b08d5046aa8a4c"}, {"problem": 95, "code": "(fn tree? [x] (if (coll? x) (if (= 3 (count x)) (every? tree? (rest x)) false) (if (nil? x) true false)))", "user": "55280930e4b0ffed3738f93b"}, {"problem": 95, "code": "#(odd? (count (remove false? (flatten %))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 95, "code": "(fn is-bintree? [s]\n  (or (nil? s)\n      (and (coll? s) (= (count s) 3) (every? is-bintree? (rest s)))))", "user": "55151417e4b055c2f668d4da"}, {"problem": 95, "code": "(fn tree? [a]\n  (or (nil? a)\n      (and (sequential? a)\n           (= 3 (count a))\n           (tree? (second a))\n           (tree? (last a)))))", "user": "55253217e4b0882d96d091ce"}, {"problem": 95, "code": "(fn tree? [tree]\n    (cond (not (sequential? tree)) (if (nil? tree) true false)\n        (= (count tree) 3) (and (tree? (second tree)) (tree? (nth tree 2)))\n        :else false))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 95, "code": "(fn bt? [coll]\n   (and \n    (coll? coll) \n    (= 3 (count coll))\n    (not (= false (nth coll 1)))\n    (every? \n     #(or (not (coll? %)) \n          (bt? %)) \n     coll)\n    )\n   )", "user": "55249f64e4b0882d96d091c6"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (or (nil? xs)\n      (and (sequential? xs)\n           (= 3 (count xs))\n           (binary-tree? (nth xs 1))\n           (binary-tree? (nth xs 2)))))", "user": "54d127b7e4b0e8a36923e5de"}, {"problem": 95, "code": "(fn[a](every? #(and (= 3 (count %))(not-any? false? %)) (filter coll? (tree-seq coll? identity a))))", "user": "54aa665fe4b09f271ff37cb8"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (and\n    (coll? t)\n    (= 3 (count t))\n    (not (coll? (first t)))\n    (let [left-child (nth t 1)] (or (nil? left-child) (binary-tree? left-child)))\n    (let [right-child (nth t 2)] (or (nil? right-child) (binary-tree? right-child)))))", "user": "4f577f25e4b0a7574ea71839"}, {"problem": 95, "code": "(fn tree [coll] (cond\n                   (= false coll) false\n                   ((complement sequential?) coll) true\n                   \n                   (not= 3 (count coll)) false\n                   :else (every? true? (flatten (cons (tree (last coll)) (cons (tree (second coll)) '(true)))))))", "user": "54e4edcae4b024c67c0cf7f3"}, {"problem": 95, "code": "(fn tree? [node]\n  (and (sequential? node)\n   \t   (= (count node) 3)\n       (or (nil? (nth node 1)) (tree? (nth node 1)))\n       (or (nil? (nth node 2)) (tree? (nth node 2)))))", "user": "546ed28be4b00cfc9eacc1a5"}, {"problem": 95, "code": "(fn bt? [tree]\n \n   (if (or\n     (nil? tree)\n     (and  \n            (sequential? tree)\n            (= (count tree) 3)\n            (bt? (second tree))\n            (bt? (last tree))\n        ))\n          \n          \n      true\n      false)   \n)", "user": "53ba41c2e4b047364c0444f3"}, {"problem": 95, "code": "(fn is-tree? [[v c1 c2 :as args]]\n  (if (not= 3 (count args))\n    false\n    (and\n     (or (nil? c1) (and (coll? c1) (is-tree? c1)))\n     (or (nil? c2) (and (coll? c2) (is-tree? c2))))))", "user": "5522cd9ae4b0882d96d091ab"}, {"problem": 95, "code": "(fn g[args]\n   (println args)\n   (if (= nil args)\n     true\n     (if (and args (= (count args) 3))\n       (do\n         (println (first args) (g (first (rest args))) (g (second (rest args))))\n         (and (first args) (g (first (rest args))) (g (second (rest args)))))\n       false))\n   )", "user": "54bbba99e4b0ed20f4ff6ec2"}, {"problem": 95, "code": "(fn ! [t]\n  (or (nil? t) (and (coll? t) (= 3 (count t))\n                    (every? ! (rest t)))))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 95, "code": "(fn t [xs] (if (sequential? xs) (if (= 3 (count xs)) (and (t (second xs)) (t (last xs))) false) (if (nil? xs) true false)))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 95, "code": "(fn chtree [r]\n  (if (sequential? r)\n    (if (= 3 (count r))\n      (reduce #(and %1 %2) (cons ((complement sequential?) (first r)) (map chtree (rest r))))\n      false)\n    (if (= nil r)\n      true\n      false)\n    )\n  \n  )", "user": "552e1c98e4b076ab5578f7ee"}, {"problem": 95, "code": "(fn [tree] (every? true? (cons\n                           (every? nil? ((group-by coll? (tree-seq coll? rest tree)) false))\n                           (flatten (map #(list (= 3 (count %))\n                                                (not (nil? (first %)))\n                                                (every? coll? (filter (fn [coll] (not (nil? coll))) (rest %)))\n              ) ((group-by coll? (tree-seq coll? rest tree)) true)))\n             )))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 95, "code": "(fn bt? [t]\n    (if (coll? t)\n      (and (= 3 (count t))\n           (bt? (nth t 1))\n           (bt? (nth t 2)))\n      (nil? t)))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n    (or (nil? coll)\n        (and (coll? coll)\n             (= 3 (count coll))\n             (every? binary-tree? (rest coll)))))", "user": "5152bc4ee4b001f44f99bfef"}, {"problem": 95, "code": "(fn tree? [node]\n    (cond\n        (nil? node) true\n        (not (sequential? node)) false\n        (not= 3 (count node)) false \n        :else (let [[_ l r] node]\n                  (every? true? [(tree? l) (tree? r)]))))", "user": "553706d1e4b09218d5f44fc7"}, {"problem": 95, "code": "(fn bintree? [bt]\n  (and (= (count bt) 3)\n       (or (nil? (nth bt 1))\n           (and (boolean (nth bt 1))\n                (bintree? (nth bt 1))))\n       (or (nil? (nth bt 2))\n           (and (boolean (nth bt 2))\n                (bintree? (nth bt 2))))))", "user": "553b87abe4b09218d5f45003"}, {"problem": 95, "code": "(fn check-binary [t]\n  (if (coll? t)\n    (let [[v l r] t]\n        (if (and (not (nil? v))\n                 (= 3 (count t))\n                 (check-binary l)\n                 (check-binary r))\n          true\n          false))\n    (if (nil? t)\n      true\n      false)))", "user": "51a7fe50e4b08d8ec191b803"}, {"problem": 95, "code": "(fn bin-tree? [x]\n  (cond\n   (nil? x) true\n   (not (coll? x)) false\n   (not= 3 (count x)) false\n   :else (every? bin-tree? (rest x))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n       \t   (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "user": "553dd883e4b0a04f792994e6"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond \n   (or (seq? coll) (vector? coll)) (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n   (nil? coll) true\n   :else false))", "user": "54ab1b5ae4b09f271ff37cc2"}, {"problem": 95, "code": "(fn istree?\n  [sx]\n  (if (sequential? sx)\n    (let [ [a b c ] sx ]\n      (and (= (count sx) 3) (istree? b) (istree? c))\n      )\n    (nil? sx)))", "user": "51f81925e4b09be9c177e526"}, {"problem": 95, "code": "(fn number95 [t]\n  (cond\n    (= nil t) true\n    (not (coll? t)) false\n    :else (cond (and\n                  (= 3 (count t))\n                  (number95 (second t))\n                  (number95 (last t))) true\n                :else false)))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 95, "code": "(fn check [tree]\n  (or (= tree nil)\n      (and (coll? tree)\n\t   (= (count tree) 3)\n\t   (every? check (rest tree)))))", "user": "51bd255ce4b0df1216cefd94"}, {"problem": 95, "code": "(fn istree [tree]\n  (if (nil? tree)\n    true\n    (if (or (and (not (seq? tree)) (not (vector? tree))) (not= 3 (count tree)))\n      false\n      (let [ a (first tree)\n             b (second tree)\n             c (second (rest tree))]\n        (if (and (nil? b) (nil? c))\n          true\n          (and (istree b) (istree c)))))))", "user": "5510aa92e4b06e50f9beb188"}, {"problem": 95, "code": "(fn[l] \n  (cond\n   (or (even?(count (flatten l)))\n       (some false? (flatten l))) \n   false\n   :else true))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 95, "code": "(fn bin [nodes]\n  (if (nil? nodes)\n    true\n    (let [cnt (if (coll? nodes) (count nodes) 0) v (and (= 3 cnt) (not (nil? (first nodes))))]\n      (and\n        v\n        (bin (second nodes))\n        (bin (last nodes))))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 95, "code": "(fn bin? [root]\n  (if (nil? root)\n    true\n    (if (and (coll? root) (= 3 (count root)))\n      (every? bin? (rest root))\n      false)))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 95, "code": "(fn bt? [t]\n  (and (coll? t)\n   \t   (= (count t) 3)\n       (or (bt? (second t)) (nil? (second t)))\n       (or (bt? (last t)) (nil? (last t)))))", "user": "55495318e4b0a04f79299566"}, {"problem": 95, "code": "(fn f [n]\n    (or\n     (nil? n)\n     (and (coll? n) (= [true true] (map f (rest n))))))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "54b64fbbe4b05787c3b163b8"}, {"problem": 95, "code": "(fn binary-tree? [x]\n  (if (or (nil? x) (sequential? x))\n    (or (nil? x)\n        (and (= (count x) 3)\n             (binary-tree? (nth x 1))\n             (binary-tree? (nth x 2))))\n    false))", "user": "4fcf1755e4b03432b189f40c"}, {"problem": 95, "code": "(fn f [[_ b c :as d]]\n (let [g #(if (nil? %) true (if (sequential? %) (f %) false))]\n  (and\n   (= 3 (count d))\n   (g b)\n   (g c))))", "user": "5499e23de4b03163384f4706"}, {"problem": 95, "code": "(fn b [x]\n (if (nil? x)\n  true\n  (and\n   (coll? x)\n   (= (count x) 3)\n   (b (nth x 1))\n   (b (nth x 2)))))", "user": "4f42ae16e4b0d7d3c9f3fd09"}, {"problem": 95, "code": "(fn tree? [tree]\n  (letfn [(leaf? [x]\n            (and (not= x '())\n                 (not (false? x))\n                 (not (sequential? x))))]\n    (cond (false? tree) false\n          (not (= 3 (count tree))) false\n          (leaf? (first tree)) (and (or (leaf? (second tree))\n                                        (tree? (second tree)))\n                                    (or (leaf? (nth tree 2))\n                                        (tree? (nth tree 2))))\n          :else (and (tree? (first tree))\n                     (or (leaf? (second tree))\n                         (tree? (second tree))\n                         (or (leaf? (nth tree 2))\n                             (tree? (nth tree 2))))))))", "user": "547884d7e4b0c51c1f4d72bd"}, {"problem": 95, "code": "(fn bt? [t]\n  (or (nil? t)\n      (and\n       \t(sequential? t)\n        (= 3 (count t))\n        (bt? (nth t 1 nil))\n        (bt? (nth t 2 nil)))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 95, "code": "(fn t? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (t? (second t))\n           (t? (last t)))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 95, "code": "(fn tree? [s]\n  (or\n   (and (not (coll? s)) (or (nil? s) s))\n   (and (coll? s) (= 3 (count s)) (every? tree? s))))", "user": "554edb85e4b00713264bd99a"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (nil? t) true\n      (and (= 3 (count t)) (every? #(or (nil? %) (coll? %)) (rest t)) (every? tree? (rest t)))))", "user": "54d1b6ffe4b0e8a36923e5e6"}, {"problem": 95, "code": "(fn check-tree [a] \n  (or (nil? a)\n    (and (sequential? a)\n         (= 3 (count a)) \n         (first a) \n         (check-tree (second a))\n         (check-tree (last a)) )) )", "user": "55536a8ae4b0deb715856e03"}, {"problem": 95, "code": "(fn binary-tree? [s]\n  (if (nil? s)\n    true\n    (and (coll? s)\n         (= 3 (count s))\n         (binary-tree? (second s))\n         (binary-tree? (last s)))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 95, "code": "(fn bin-tree? [t]\n  (if (nil? t)\n    true\n    (and\n     (coll? t)\n     (= 3 (count t))\n     (bin-tree? (second t))\n     (bin-tree? (last t)))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 95, "code": "(fn tree?\n  [node]\n  (if (nil? node)\n    true\n    (if (and (sequential? node) (= (count node) 3))\n      (let [[v l r] node]\n        (and \n           ((comp not nil?) v)\n           (tree? l)\n           (tree? r)))\n      false)))", "user": "53161a56e4b08068f379ed3e"}, {"problem": 95, "code": "(fn is-tree? [sq] \n  (or\n   (nil? sq)\n   (and (sequential? sq) (= 3 (count sq)) (-> sq first nil? not) (is-tree? (second sq)) (is-tree? (last sq)) )\n))", "user": "5280a1ece4b0757a1b171407"}, {"problem": 95, "code": "(fn tree?[x]\n  (let [left-child (second x) right-child (last x) ]\n    (and\n      (= (count x) 3)\n      (or (nil? left-child) (if (sequential? left-child) (tree? left-child) false)) \n      (or (nil? right-child) (if (sequential? right-child) (tree? right-child) false)))))", "user": "55429859e4b0a04f7929951f"}, {"problem": 95, "code": "(fn is-tree? [x] (every? identity\n  (map #(or (and (sequential? %) (= (count %) 3)) (nil? %)) (tree-seq #(sequential? %) #(rest %) x))))", "user": "554dfe97e4b00713264bd98c"}, {"problem": 95, "code": "(fn isbt [tree]\n  (if (= (count tree) 3)\n    (let [[value left right] tree]\n      (and (not (coll? value))\n           (not (nil? value))\n           (or (nil? left)\n               (and (coll? left)\n                    (isbt left)))\n           (or (nil? right)\n               (and (coll? right)\n                    (isbt right)))))\n    false))", "user": "5486e317e4b0e286459a11c0"}, {"problem": 95, "code": "(fn binary-tree? [node]\n  (cond\n   (nil? node) true\n   (not (sequential? node)) false\n   (not= 3 (count node)) false\n   :else (let [[_ L R] node]\n           (and (binary-tree? L) (binary-tree? R)))))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 95, "code": "(fn [coll]\n  (letfn [(nil-or-3 [c] (if (nil? c)\n                          true\n                          (if (coll? c)\n                            (if  (every? (complement  coll?) c)\n                              (and   (= 3 (count c)) (every? nil? (rest c)))\n                              (and  (= 3 (count c))\n                                    (every? nil-or-3 (filter coll? c))))\n                            true)))]\n    (nil-or-3 coll)))", "user": "516d227fe4b06f078fab252d"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (if (or (not= (count t) 3) (some false? t))\n    false\n    (reduce (fn [result input]\n              (cond\n               (false? result) result\n               (sequential? input) (is-tree? input)\n               :default result)) true t)))", "user": "555521a5e4b0deb715856e12"}, {"problem": 95, "code": "(fn tree? [seq]\n  (or (nil? seq)\n      (and (coll? seq)\n       \t   (= 3 (count seq))\n           (tree? (second seq))\n           (tree? (first (drop 2 seq))))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 95, "code": "(fn tree? [arg]\n  (if\n    (= 3 (count arg))\n    (every? #(or (nil? %) (and (coll? %) (tree? %))) (rest arg))\n    false))", "user": "4f16d3fd535d64f60314644e"}, {"problem": 95, "code": "(fn tree? [r]\n  (if (not= 3 (count r))\n    false\n    (every? #(or (nil? %) (and (sequential? %) (tree? %))) (rest r))))", "user": "555ac933e4b0deb715856e49"}, {"problem": 95, "code": "(fn tree? [tree]\n  (cond\n   (nil? tree) true\n   (and (sequential? tree) (= (count tree) 3)) (every? tree? (rest tree))\n   :else false))", "user": "4fdb881ee4b05e33b9224f5e"}, {"problem": 95, "code": "(fn istree[xs]\n  (if (nil? xs) true \n    (and (coll? xs)(= 3 (count xs)) (istree (second xs)) (istree (nth xs 2)))))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 95, "code": "(fn btree? [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= (count tree) 3)\n           (btree? (second tree))\n           (btree? (last tree)))))", "user": "555287a4e4b0deb715856df5"}, {"problem": 95, "code": "(fn btree? [root]\n    (cond\n      (nil? root) true\n      (not= 3 (count root)) false\n      (every? #(or (nil? %) (sequential? %)) (rest root)) (and (btree? (second root)) (btree? (last root)))\n      :else false\n      )\n    )", "user": "5535e822e4b09218d5f44fb2"}, {"problem": 95, "code": "(fn bin-check\n  [tree]\n  (cond \n    (nil? tree) true\n    (not (sequential? tree)) false\n    (not= (count tree) 3) false\n    :else\n    (let [[v l r] tree]\n      (and (bin-check l)\n           (bin-check r)))))", "user": "504e71cbe4b0f6ff3350c4b3"}, {"problem": 95, "code": "(fn tree?\n  [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "user": "5540cc0ce4b0a04f79299505"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (cond\n    (false? tree) false\n    (not (coll? tree)) true\n    (not= (count tree) 3) false\n    :else (and (is-tree? (first tree)) (is-tree? (second tree)) (is-tree? (nth tree 2)))))", "user": "551d5cb9e4b07993ea3788e9"}, {"problem": 95, "code": "(fn f95 [s]\n  (if (not (= 3 (count s)))\n    false\n    (if (coll? (first s))\n      false\n      (cond\n       (coll? (second s)) (f95 (second s))\n       (coll? (last s)) (f95 (last s))\n       (and (= 3 (count s))\n            (not-any? false? s)) true\n       :else false))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 95, "code": "(fn tree? [t] \n  (or (nil? t) \n      (and (sequential? t) \n           (= (count t) 3) \n           (tree? (nth t 1)) \n           (tree? (nth t 2)))))", "user": "52e851bfe4b09f7907dd149a"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (letfn [(tree-nodes [tree]\n            (filter sequential?\n                    (tree-seq sequential? identity tree)))\n          (binary-tree-node? [[first & rest :as node]]\n            (and (= (count node) 3)\n                 (every? #(or (nil? %) (sequential? %)) rest)\n                 (#(or (number? %) (keyword? %)) first)))]\n    (->> (tree-nodes tree)\n         (map binary-tree-node?)\n         (every? true?))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 95, "code": "(fn binary-tree?\n  [[x y z & xs :as coll]]\n  (cond\n    (and (coll? coll) (empty? coll)) false\n    x (cond\n        (or (some false? coll) (not= (count coll) 3)) false\n        :else (and (binary-tree? y) (binary-tree? z)))\n    :else true))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 95, "code": "(fn bin-tree? [coll]\n  (cond\n    (sequential? coll)\n    (and (= 3 (count coll))\n         (bin-tree? (nth coll 1))\n         (bin-tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "54c3747de4b045293a27f60e"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (every? tree? (rest node)))))", "user": "556a6137e4b09a3098a524e0"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (= x nil)\n      (and (coll? x)\n           (= (count x) 3)\n           (every? tree? (rest x)))))", "user": "554b8572e4b0a04f79299589"}, {"problem": 95, "code": "(fn [tree]\n  ((fn is-tree [tree c]\n    (cond\n      (or (nil? tree) (instance? c tree)) true\n      (and (not (list? tree)) (not (vector? tree))) false\n      (not= (count tree) 3) false\n      :else (and (is-tree (second tree) c) (is-tree (nth tree 2) c))\n    )\n  ) tree (class (first tree)))\n)", "user": "53ecd01fe4b0d648e757f4b9"}, {"problem": 95, "code": "(fn btree? [coll]\n  (if (nil? coll)\n    true\n    (if (or (not (coll? coll))\n            (not= 3 (count coll)))\n      false\n      (let [[_ l r] coll]\n        (and (btree? l) (btree? r))))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (coll? coll)\n    (if (= (count coll) 3)\n      (and (tree? (second coll)) (tree? (last coll)))\n      false)\n    (not (false? coll))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 95, "code": "(fn tree? [t]\n   (cond \n     (nil? t) true\n     (and (coll? t) (= 3 (count t))) (and (tree? (nth t 1)) (tree? (nth t 2)))\n     :default false))", "user": "530b8580e4b02e82168697cc"}, {"problem": 95, "code": "(fn tree? [coll]                                                                                                                              \n  (if (and (coll? coll) (= 3 (count coll)))                                                                                                      \n    (let [[_ l r] coll]                                                                                                                         \n      (and (if (nil? l) true (tree? l))                                                                                                         \n           (if (nil? r) true (tree? r))))                                                                                                       \n    false))", "user": "54f4adc8e4b0f2f3c5226e86"}, {"problem": 95, "code": "(fn is-tree [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? is-tree (rest root)))))", "user": "52b89d55e4b07a9af57922b3"}, {"problem": 95, "code": "(fn binary-tree? [t]\n                       (if (coll? t)\n                         (if (= 3 (count t))\n                           (and  (binary-tree? (nth t 1)) (binary-tree? (nth t 2)))\n                           false)\n                         (if (nil? t) \n                           true\n                           false)))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 95, "code": "#(letfn [(isTree [[_ l r :as n]]\n   \t(and (= 3 (count n))\t\n    \t (or (nil? l)\n        \t (and (coll? l) (isTree l)))\n         (or (nil? r)\n             (and (coll? r) (isTree r)))))]\n         (isTree %))", "user": "555b35f7e4b0deb715856e4b"}, {"problem": 95, "code": "(fn tree? [l]\n    (if (nil? l) \n      true\n      (and (sequential? l) (= 3 (count l)) (tree? (second l)) (tree? (nth l 2)))))", "user": "54f8b6f4e4b01ecee9d8882c"}, {"problem": 95, "code": "(fn tree? [t]\r\n  (or (nil? t)\r\n      (and (coll? t)\r\n           (= (count t) 3)\r\n           (let [[_ left right] t]\r\n             (and (tree? left)\r\n                  (tree? right))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 95, "code": "(fn binary-tree? [t] (let [[v l r] t node? #(or (nil? %) %)] (or (nil? t) (and (= 3 (count t)) (node? l) (binary-tree? l) (node? r) (binary-tree? r)))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 95, "code": "(fn ! [x]\n  (if (nil? x)\n    true\n    (if-not (and (coll? x) (= (count x) 3))\n      false\n      (and (! (second x)) (! (last x)))\n      )))", "user": "557232a1e4b09a3098a52543"}, {"problem": 95, "code": "(fn i [t]\n  (if (nil? t)\n    true\n    (if (and (coll? t) (= (count t) 3))\n      (and (i (second t)) (i (last t)))\n      false)))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 95, "code": "(fn bt? [node]\n  (cond\n    (coll? node)\n      (and (= 3 (count node)) (bt? (nth node 1)) (bt? (nth node 2)))\n    (nil? node) \n       true\n    :else \n       false\n   ))", "user": "55150524e4b055c2f668d4d9"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (every? tree? (rest t)))))", "user": "55702081e4b09a3098a52529"}, {"problem": 95, "code": "(fn f [tree]\n  (and (= 3 (count tree)) (every? identity (map #(if (sequential? %) (f %) (not (false? %))) tree))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (coll? x)\n           (not (nil? (first x)))\n           (= 3 (count x))\n           (tree? (nth x 1))\n           (tree? (nth x 2)))))", "user": "524f3e6de4b0541d1855b805"}, {"problem": 95, "code": "(fn t [x]\n   (if (coll? x)\n     (let [[_ l r] x]\n       (and (= 3 (count x)) (t l) (t r)))\n     (nil? x)))", "user": "51e3a549e4b0c611d6113e47"}, {"problem": 95, "code": "(fn tree? [node]\n  (if (not (coll? node))\n    (if (nil? node)\n      true\n      false) \n    (if (not= (count node) 3)\n      false\n      (and \n       (tree? (second node))\n       (tree? (nth node 2))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 95, "code": "(fn sol [t] (letfn [(sizeok [t] (= 3 (count t)))\n                      (isnil [t] (= nil t))]\n  (if (or (isnil t) (and (coll? t) (sizeok t) (sol (second t)) (sol (last t)))) true false)))", "user": "54857657e4b0e286459a11ac"}, {"problem": 95, "code": "(fn [tree]\n    (letfn [(test [node] \n              (if (nil? node)\n                true\n                (if (and (coll? node) (= 3 (count node)))\n                  (let [[value left right] node\n                        leftok (test left)\n                        rightok (test right)]\n                    (and leftok rightok)))))]\n      (if-not (nil? (test tree))\n        true\n        false)))", "user": "554a75c9e4b0a04f79299575"}, {"problem": 95, "code": "(fn [col]\n   (letfn [(is-tree? [col]\n             (and (every? #(not= false %) col) (= (count col) 3)))\n           (walk-tree [[x & rest :as col]]\n             (if (coll? x)\n               (if-not (is-tree? x)\n                 false\n                 (walk-tree x))\n               (if rest\n                 (walk-tree rest)\n                 true)))]\n     (if-not (is-tree? col)\n       false\n       (walk-tree col))))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 95, "code": "(fn t? [s] (or (nil? s) (and (coll? s) (= 3 (count s)) (t? (second s)) (t? (nth s 2)))))", "user": "556a3243e4b09a3098a524de"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (let [[val left right] tree]\n    (and (= (count tree) 3)\n         (or (nil? left) (and (sequential? left) (binary-tree? left)))\n         (or (nil? right) (and (sequential? right) (binary-tree? right))))))", "user": "533f09e1e4b085b17e897d9a"}, {"problem": 95, "code": "(fn tree? [tree]\n  (true?\n    (or\n      (nil? tree)\n      (and (coll? tree)\n           (if (= 3 (count tree))\n             (let [[_ left right] tree]\n               (and (tree? left) (tree? right))))))))", "user": "5573ffb5e4b0aa18f790f3fd"}, {"problem": 95, "code": "(fn binary-tree? [tr]\n  (cond\n   (nil? tr) true\n   (not= 3 (count tr)) false\n   :else (every? #(or (nil? %) (and (sequential? %) (binary-tree? %))) (rest tr))))", "user": "5576f299e4b05c286339e077"}, {"problem": 95, "code": "(fn btree?\n  [coll]\n  (if (not (sequential? coll))\n    false\n    (if (not= (count coll) 3)\n      false\n      (let [left (second coll) right (last coll)]\n        (if (and (nil? left) (nil? right))\n          true\n          (if (and (not= left nil) (not= right nil))\n            (and (btree? left) (btree? right))\n            (if (nil? left)\n              (btree? right)\n              (btree? left))))))))", "user": "55079e55e4b021ccfedb96aa"}, {"problem": 95, "code": "(let [third #(if (> (count %) 2) (nth % 2) nil)]\n  (fn binary-tree? [coll]\n    (cond (nil? coll)                       true\n          (not (sequential? coll))          false\n          (not= (count coll) 3)             false\n          (and (not (sequential? (first coll)))\n               (binary-tree? (second coll))\n               (binary-tree? (third coll))) true\n          :else                             false)))", "user": "54361d92e4b032a45b8692f7"}, {"problem": 95, "code": "(fn [t]\n  (letfn [(tree? [[value left right :as t]]\n                 (and (= (count t) 3)\n                      (or (nil? left) (and (sequential? left) (tree? left)))\n                      (or (nil? right) (and (sequential? right) (tree? right)))))]\n    (tree? t)))", "user": "4ec6297b535d6d7199dd36c4"}, {"problem": 95, "code": "(fn is-tree? [node] (if (coll? node) (and (= (count node) 3) (and (not (some false? node))) (every? is-tree? node)) true))", "user": "54f296efe4b024c67c0cf8c8"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 95, "code": "(fn btree? [coll]\n  (cond \n   (nil? coll) true\n   (not (sequential? coll)) false\n   (not= (count coll) 3) false\n   :else\n    (->> (rest coll)\n         (map btree?)\n         (every? true?))))", "user": "5579bc24e4b05c286339e098"}, {"problem": 95, "code": "(fn ch [t]\n  (if (coll? t)\n    (if (= 3 (count t))\n      (and (ch (second t)) (ch (last t)))\n      false)\n    (not (false? t))))", "user": "52979551e4b02ebb4ef75043"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (nil? s)\n    true\n    (if (or (not (coll? s)) (not= 3 (count s)))\n      false\n      (and (is-tree (nth s 1)) (is-tree (nth s 2))))))", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 95, "code": "(fn m [coll]\n    (if (or (coll? coll) (nil? coll))\n      (if (not= (count coll) 3)\n        (nil? coll)\n        (and (m (second coll)) (m (nth coll 2))))\n      false))", "user": "54a677a9e4b09f271ff37c88"}, {"problem": 95, "code": "(fn myfn* [[node right left :as coll]]\n  (if (and (not (nil? node)) (= (count coll) 3))\n    (and\n      (or (nil? right) (and (sequential? right) (myfn* right)))\n      (or (nil? left) (and (sequential? left) (myfn* left))))\n    false))", "user": "52ba447ee4b07a9af57922ce"}, {"problem": 95, "code": "(fn t [treeish] (and (sequential? treeish) \n                     (= 3 (count treeish))\n                     (or\n                     \t(nil? (nth treeish 1))\n                        (t (nth treeish 1)))\n                     (or\n                      \t(nil? (nth treeish 2))\n                      \t(t (nth treeish 2)))))", "user": "54bad977e4b0ed20f4ff6eb9"}, {"problem": 95, "code": "(fn is-tree1\n  [s]\n  (letfn [(is-tree'\n            ([] false)\n            ([x] (nil? x))\n            ([x y] false)\n            ([x y z] (if (nil? x) false (and (is-tree1 y) (is-tree1 z))))\n            ([x y z & more] false))]\n    (if (coll? s) (apply is-tree' s) (is-tree' s))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5589e88ae4b0277789237610"}, {"problem": 95, "code": "(fn [t]\n    (letfn [(tree? [t]\n        (cond\n            (nil? t) true\n            (not (coll? t)) false\n            (not= 3 (count t)) false\n            (and (tree? (second t)) (tree? (last t))) true\n            :else false))]\n        (tree? t)))", "user": "558306dfe4b05c286339e110"}, {"problem": 95, "code": "(fn t [n] (or (and (not (coll? n)) (not (false? n))) (and (coll? n) (= 3 (count n)) (every? t n))))", "user": "4f070ce6535dcb61093f6c1e"}, {"problem": 95, "code": "(fn is-bin?\n  [t]\n  (or (nil? t) (and (coll? t) (= 3 (count t)) (every? is-bin? (rest t)))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 95, "code": "(fn istree[tree]\n(if (nil? tree)\n  true\n  (and (coll? tree) (= 3 (count tree)) (istree (second tree)) (istree (second(next tree))) )\n)  \n)", "user": "55757e81e4b05c286339e063"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 95, "code": "(fn tree? [xs]                                   \n  (let [[root left right] xs]                    \n    (cond (not= 3 (count xs)) false              \n          (nil? root) false                      \n                                                 \n          (and (coll? left) (coll? right))       \n          (and (tree? left) (tree? right))       \n                                                 \n          (and (coll? left) (nil? right))        \n          (tree? left)                           \n                                                 \n          (and (nil? left) (coll? right))        \n          (tree? right)                          \n                                                 \n          (and (nil? left) (nil? right)) true    \n          :else false)))", "user": "541b41d1e4b01498b1a71a65"}, {"problem": 95, "code": "(fn check [node]                                                                                                                \n    (cond                                                                                                                                               \n        (and (coll? node) (= (count node) 3)) (and (check (second node)) (check (last node)))                                                           \n        (nil? node) true                                                                                                       \n        :else false))", "user": "558b50d5e4b027778923762b"}, {"problem": 95, "code": "(fn is-btree? [lst]\n  (if (sequential? lst)\n    (and (= (count lst) 3)\n         (not (sequential? (first lst)))\n         (not-any? #(not (is-btree? %)) (rest lst)))\n    (nil? lst)))", "user": "5545477fe4b0a04f79299531"}, {"problem": 95, "code": "(fn check-tree [[v l r :as a]]\n (let [nst #(and (not (coll? %)) (not (nil? %)))]\n  (cond\n   (not= 3 (count a)) false\n   (coll? v) false\n   (nst l) false\n   (nst r) false\n   :else\n    (and\n     (if (coll? l) (check-tree l) true)\n     (if (coll? r) (check-tree r) true)\n    )\n  )\n )\n)", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 95, "code": "(fn tont [s]\n   (cond (nil? s) true\n         (coll? s) (let [[v l r] s]\n                     (clojure.core/and \n                      (= 3 (count s))\n                      (tont l)\n                      (tont r)))\n         :else false))", "user": "55895eade4b059ccff29b202"}, {"problem": 95, "code": "(fn f [t]\n  (if (and (sequential? t) (= 3 (count t)))\n    (let [[_ l r] t]\n      (and (f l) (f r)))\n    (nil? t)))", "user": "5590e55de4b0277789237676"}, {"problem": 95, "code": "(fn tree? [[_ l r :as node]]\n    (and\n     (= 3 (count node))\n     (or (nil? l) (and (coll? l) (tree? l))) \n     (or (nil? r) (and (coll? r) (tree? r)))\n     ))", "user": "55632016e4b0c656e3ff17e4"}, {"problem": 95, "code": "(fn checker\n\t\n  \t[arg]\n\n  \t(let [args (into [] arg)]\n  \n  \t\t(cond \n\n  \t\t\t(= 3 (count args) )\n\n  \t\t\t\t\t(let [[node-name lchild rchild] args]\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(and (coll? lchild) (coll? rchild)) (and (checker rchild) (checker lchild))\n\t\t\t\t\t\t\t(and (nil? lchild)  (coll? rchild)) (checker rchild)\n\t         \t\t\t\t(and (nil? rchild)  (coll? lchild)) (checker lchild)\n\t            \t\t\t(and (nil? lchild)  (nil? rchild)) true\n\t\t\t\t\t\t\t:else false\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n  \t\t\t:else false\n  \t\t\t)\n\t)\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 95, "code": "(fn tree? \n  [coll]\n  (cond \n   (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n   (nil? coll) true\n   :else false))", "user": "558d7dd3e4b0277789237647"}, {"problem": 95, "code": "(fn b-tree? [coll]\n   (if (coll? coll)\n     (let [f (first coll)\n           s (first (rest coll))\n           t (first (rest (rest coll)))]\n       (and (= 3 (count coll))\n            f\n            (or (nil? s) (b-tree? s))\n            (or (nil? t) (b-tree? t))))\n     false))", "user": "55860905e4b001b0851d7516"}, {"problem": 95, "code": "(fn it [[k l r :as t]]\n  (and (= 3 (count t))\n       (if (coll? l) (it l) (nil? l))\n       (if (coll? r) (it r) (nil? r))))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 95, "code": "(fn q [t] (or (nil? t) (and (sequential? t) (= 3 (count t)) (every? q (rest t)))))", "user": "523630eee4b05f3be1c7c8e8"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n          (and (coll? tree)\n               (= 3 (count tree))\n               (or (nil? (nth tree 1)) (binary-tree? (nth tree 1)))\n               (or (nil? (nth tree 2)) (binary-tree? (nth tree 2)))))", "user": "531c6e72e4b08068f379eda0"}, {"problem": 95, "code": "(fn tree? [col]\n  (or (nil? col)\n      (and (coll? col)\n           (every? tree? (rest col))\n           (= 3 (count col)))))", "user": "52bdd135e4b07a9af579230a"}, {"problem": 95, "code": "(fn bt? [t]\n  (and (= 3 (count t))\n       (if (sequential? (second t))\n         (bt? (second t))\n         (nil? (second t)))\n       (if (sequential? (last t))\n         (bt? (last t))\n         (nil? (last t)))))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 95, "code": "(fn tree? [t]\n    (cond (nil? t) true\n          (coll? t) (and (= (count t) 3)\n                         ((complement coll?) (first t))\n                         (tree? (second t))\n                         (tree? (last t)))\n          :else false))", "user": "55882c84e4b059ccff29b1f2"}, {"problem": 95, "code": "(fn ? [t]\n  (or (and (coll? t)\n           (= (count t) 3)\n           (every? ? (rest t)))\n      (nil? t)))", "user": "5585f088e4b001b0851d7513"}, {"problem": 95, "code": "(fn ? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (let [[v L R] t] \n             (and (? L) (? R))))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 95, "code": "(fn tree [x]\n  (and\n   (not= false x)\n   \n  (or \n   (not(sequential? x))\n   (and \n    (= 3 (count x))\n    (tree (second x))\n    (tree (last x))))))", "user": "559bdf16e4b066d22e731f5a"}, {"problem": 95, "code": "(fn is-bin-tree? [root]\n  (every? #(or (nil? %) (if (coll? %) (= (count %) 3) false)) (tree-seq identity rest root)))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 95, "code": "(fn binary-tree? [n]\n  (if (nil? n) \n    true \n    (if (or (not (coll? n)) (not= 3 (count n))) \n      false\n      (and (binary-tree? (nth n 1)) (binary-tree? (nth n 2))))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 95, "code": "(fn bin-tree? [s]\n        (if (nil? s)\n          true\n          (and (sequential? s)\n               (= (count s) 3)\n               (bin-tree? (nth s 1))\n               (bin-tree? (nth s 2)))))", "user": "558f4fbae4b0277789237661"}, {"problem": 95, "code": "(fn [coll]\n  (let [x (filter coll? (tree-seq coll? identity coll))\n        y (fn [coll] (and (= 3 (count coll))\n                          (or (nil? (second coll))\n                              (coll? (second coll)))\n                          (or (nil? (last coll))\n                              (coll? (last coll)))))]\n    (every? true? (map y x))))", "user": "55933c7ae4b0c79f6e1db938"}, {"problem": 95, "code": "(fn tree?\n  [x]\n  (if (coll? x)\n    (and (= (count x) 3)\n         (every? tree? x))\n    (not (false? x))))", "user": "559b2ad1e4b066d22e731f4e"}, {"problem": 95, "code": "(fn btree? [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (btree? (second node))\n           (btree? (last node)))))", "user": "53e76363e4b036ad0777e47b"}, {"problem": 95, "code": "(fn btree? [[_ c1 c2 :as all]]\n  (letfn [(check-child [c] (if (sequential? c) (btree? c) (not (false? c))))]\n    (and\n      (= (count all) 3)\n      (check-child c1)\n      (check-child c2))))", "user": "55a12668e4b0acc240e3150b"}, {"problem": 95, "code": "(fn tree? [t]\n              (or (nil? t)\n                  (and (coll? t)\n                       (= (count t) 3)\n                       (let [[v l r] t]\n                         (and\n                           (tree? l)\n                           (tree? r))))))", "user": "52f53589e4b05e3f0be25f2c"}, {"problem": 95, "code": "(fn istree? [t]\n  (or (nil? t)\n    (and (sequential? t)\n         (= (count t) 3)\n         (not (sequential? (first t)))\n         (istree? (nth t 1))\n         (istree? (nth t 2)))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (not (nil? (first t)))\n           (tree? (second t))\n           (tree? (nth t 2)))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 95, "code": "(fn is-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? is-tree? (rest root)))))", "user": "557f7c8be4b05c286339e0e0"}, {"problem": 95, "code": "(fn is-tree? [coll]\n  (cond\n    (or \n\t\t(seq? coll) \n\t\t(vector? coll)\n\t)\n\t(and \n\t\t(= 3 (count coll))\n\t\t(is-tree? (nth coll 1)) \n\t\t(is-tree? (nth coll 2))\n\t)\n    (nil? coll) \n\ttrue\n    :else false\n  )\n)", "user": "5595c60ee4b0c79f6e1db96f"}, {"problem": 95, "code": "(fn btree? \n  ([root] \n   (or \n    (not (sequential? root))\n    (and (= 3 (count root)) \n         (reduce #(and %1 %2) \n                 (map #(btree? % (first root))\n                      root)))))\n  ([e root]\n   (if (not (sequential? e))\n     (or (= e nil) (= (type root) (type e)))\n     (and (= 3 (count e)) \n         (reduce #(and %1 %2) \n                 (map #(btree? % root) \n                      e))))))", "user": "558bb38fe4b0277789237631"}, {"problem": 95, "code": "(fn b-tree [c] (if (nil? c) true (if (or (not (coll? c)) (not= 3 (count c))) false (and (b-tree (nth c 1)) (b-tree (nth c 2))))))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 95, "code": "(fn tree? [x]\n(if (and (coll? x) (= (count x) 3) (not (nil? (first x))))\n  (and (tree? (second x)) (tree? (nth x 2)))\n  (if (nil? x)\n    true\n    false)))", "user": "5596af34e4b04c1e5c31d758"}, {"problem": 95, "code": "(fn check-binary-tree\n  [tree]\n  (if (nil? tree)\n    true\n    (if (or (not (nil? (#{false true} tree)))  (not (= 3 (count tree))) )\n      false\n      (and (check-binary-tree (nth tree 1)) (check-binary-tree (last tree))))))", "user": "5594e0e3e4b0c79f6e1db95b"}, {"problem": 95, "code": "(fn bin? [tree]\n\t(cond\n\t\t(not (coll? tree)) (not (= false tree))\n\t\t(= (count tree) 3) (and (bin? (second tree)) (bin? (last tree)))\n      \t:else false))", "user": "55306f9de4b076ab5578f814"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (if-not (and (sequential? t) (= (count t) 3))\n    false\n    (let [[v l r] t\n          valid-child? (fn [c] (or (nil? c) (binary-tree? c)))]\n      (and (valid-child? l)\n           (valid-child? r)))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 95, "code": "(fn is-tree [xs]\n  (if (not= (count xs) 3) false\n      (let [[v lc rc] xs]\n        (and\n          (not= v nil)\n          (if (coll? lc) (is-tree lc) (= nil lc))\n          (if (coll? rc) (is-tree rc) (= nil rc))\n        ))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 95, "code": "(fn tree? [[_ l r :as t]]\n  (let [f #(or (nil? %) (and (sequential? %) (tree? %)))]\n    (and (= 3 (count t)) (f l) (f r))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 95, "code": "(fn pred [coll]\n  (if (or (seq? coll) (vector? coll))\n    (cond (= 3 (count coll)) (and (pred (nth coll 1)) (pred (nth coll 2)))\n          :else false\n          )\n    (cond (false? coll) false\n          :else true\n          )\n    )\n  )", "user": "5510d948e4b06e50f9beb18d"}, {"problem": 95, "code": "(fn tree? ([all]\n           (or (nil? all) (and\n                           (sequential? all)\n                           (= 3 (count all))\n                           (let [[_ l r] all]\n                             (and (tree? l) (tree? r)))))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 95, "code": "(fn tree? [n] (or (nil? n) (and (coll? n) (= 3 (count n)) (every? tree? (rest n)))))\n\n;(fn tree [n] (if (sequential? n) (if (= 3 (count n)) (and (tree (second n)) (tree (last n))) false) (if (false? n) false true)))", "user": "54e1939ce4b024c67c0cf7c5"}, {"problem": 95, "code": "(fn ct [n] \n        (and \n          (= (count n) 3) \n          (not (nil? (first n))) \n          (or (nil? (second n)) (and (coll? (second n)) (ct (second n)))) \n          (or (nil? (last n)) (and (coll? (last n)) (ct (last n))))))", "user": "559a8816e4b066d22e731f41"}, {"problem": 95, "code": "(fn btree [node]\n  (or (= nil node)\n      (and node (= 3 (count node)) (first node) (btree (second node)) (btree (nth node 2)))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 95, "code": "(fn tree?\n  [root]\n  (if (nil? root)\n    true\n    (and (coll? root) (= 3 (count root)) (tree? (nth root 1)) (tree? (last root)))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 95, "code": "(fn binary-tree? [s]\n  (if (and (coll? s) (= 3 (count s)))\n    (let [[_ l r] s]\n      (and\n       (or (nil? l) (binary-tree? l))\n       (or (nil? r) (binary-tree? r))))\n    false))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 95, "code": "(fn isTree [[r l p :as vst]]  \n                        (if (= (count vst) 3)\n                           (cond\n                             (and (not (coll? l)) (not (nil? l)) ) false\n                             (and (not (coll? p)) (not (nil? p)) ) false\n                             (and (not (coll? r)) (nil? l) (nil? p)) true\n                             (and  (coll? l) (nil? p)) (isTree l)\n                             (and  (nil? l) (coll? p)) (isTree p)\n                             :else (and (isTree l) (isTree p)))\n                           false))", "user": "5576e78de4b05c286339e075"}, {"problem": 95, "code": "(fn bt? [x] \n  (if (or (false? x) (= x '()))\n    false\n   (if (= (count x) 0)\n     true\n     (if (= (count x) 3)\n       (and (bt? (first (rest x))) (bt? (first (rest (rest x))))\n       )\n       false\n     )\n   \n   )))", "user": "55b08677e4b002ce9d5cbc23"}, {"problem": 95, "code": "(fn is-tree? [node]\n    (boolean (and\n      (coll? node)\n      (= (count node) 3)\n      (or (nil? (nth node 1)) (is-tree? (nth node 1)))\n      (or (nil? (nth node 2)) (is-tree? (nth node 2)))\n    ))\n    )", "user": "55aa5f73e4b0988bba2ad94b"}, {"problem": 95, "code": "(fn is-tree?\n  ([l]\n   (if (not (coll? l))\n     (nil? l)\n     (case (count l)\n       3 (every? is-tree? (rest l))\n       false))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 95, "code": "(fn tree [[_ left right :as in]]\n    (and (= 3 (count in))\n         (or (and (nil? left) (nil? right))\n             (and (nil? left) (coll? right) (tree right))\n             (and (nil? right) (coll? left) (tree left))\n             (and (tree right) (tree left)))))", "user": "54ad9d76e4b09f271ff37ce6"}, {"problem": 95, "code": "(let\n    [applicable? (fn [l] (or (seq? l) (vector? l)))]\n    (fn node-valid?\n      ([a b c]\n         ; (println [a b c])\n         (cond\n           (and (nil? b) (nil? c)) true\n           (nil? b) (if (applicable? c) (apply node-valid? c) false)\n           (nil? c) (if (applicable? b) (apply node-valid? b) false)\n           (and (applicable? b) (applicable? c)) (and (apply node-valid? b) (apply node-valid? c))\n           :else false))\n      ([a]\n       ; (println [a])\n       (cond\n         (nil? a)        true\n         (applicable? a) (apply node-valid? a)\n         :else           false))\n      ([] false)\n      ([_ _] false)\n      ([_ _ _ & _] false)\n      )\n    )", "user": "559a9a3de4b066d22e731f45"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "559c3d73e4b066d22e731f65"}, {"problem": 95, "code": ";; the recursive version:\n(fn binary-tree? [xs]\n  (letfn [(bin-node? [node] \n           (and (sequential? node) (= 3 (count (remove false? node)))))\n          (nested-nodes? [node] \n           ((comp not empty?) (filter sequential? node)))]\n  (if (bin-node? xs)\n    (if (nested-nodes? xs)\n      (if (sequential? (second xs))\n        (binary-tree? (second xs))\n        (binary-tree? (last xs)))\n      true)\n    false)))\n\n\n;; following binary-tree? finder using HOFs\n#_(fn binary-tree?\n  [xs]\n    (let [valid-node? #(= 3 (count %))\n          node? #(and (or (seq? %) (vector? %)))]\n    (->> xs\n       (reduce (fn [acc composite]\n              (if (node? composite)\n                (conj acc ((comp not empty?) composite) (binary-tree? composite))\n                (conj acc (and (valid-node? xs) composite))))  [])\n       flatten\n       (filter false?)\n       empty?)))", "user": "5553b729e4b0deb715856e05"}, {"problem": 95, "code": "(fn p95 ([tree] (p95 tree tree))\n  ([tree ftree]\n   (if (= 3 (count tree))\n     (p95 (first (filter coll? tree)) ftree)\n     (if (or (nil? tree)\n             (empty? tree))\n       (if (and \n            (empty? (filter false? (flatten ftree)))\n            (false? (every? empty? (filter coll? ftree))))\n         true\n         false\n         )\n       false\n       )\n     ))\n  \n  )", "user": "5400e918e4b0de5c41848619"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (if (and (coll? tree)\n           (= 3 (count tree)))\n    (->> (next tree)\n         (remove nil?)\n         (every? is-tree?))\n\n    false))", "user": "53571732e4b04ce2eb3ed275"}, {"problem": 95, "code": "(fn tree?\n  ([s] (tree? s false))\n  ([s has-parent]\n   (if (coll? s)\n     (if (= 3 (count s))\n       (and true (tree? (second s) true) (tree? (last s) true))\n       false)\n     (and has-parent (nil? s)))))", "user": "55a5c3bee4b0acc240e3154e"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (if (or (not (coll? t)) (not (= (count t) 3)))\n      false\n      (if (every? (or coll? nil?) (rest t))\n        true\n        (and (tree? (nth t 1))\n             (tree? (nth t 2)))\n      )\n    )\n  )\n)", "user": "554756b8e4b0a04f79299549"}, {"problem": 95, "code": "(fn tree? [t] \n    (if (nil? t)\n     true\n     (if (sequential? t)\n      (if (= 3 (count t))\n        (and (tree? (nth t 1 false)) (tree? (nth t 2 false)))\n      false)\n     false)))", "user": "54236ce1e4b01498b1a71ad1"}, {"problem": 95, "code": "(fn[a](every? (fn[n](and(= 2 (count(rest n))) (every? #(or(nil? %)(coll? %)) (rest n) ))) (filter coll? (tree-seq coll? #(identity %) a))))", "user": "555c6344e4b0b056612e224c"}, {"problem": 95, "code": "(fn ? [[a b c :as x]]\n  (and \n   (= 3 (count x))\n   (if (coll? b) (? b) (nil? b))\n       (if (coll? c) (? c) (nil? c))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 95, "code": "(fn bn-check1? [bn] (let [bn1 (second bn) bn2 (last bn)] (cond\n    (not= (count bn) 3)  false\n    (or (and (not (nil? bn1)) (not (coll? bn1))) (and (not (nil? bn2)) (not (coll? bn2))) )  false\n    (and (or (nil? bn1) (bn-check1? bn1)) (or (nil? bn2) (bn-check1? bn2)) )  true\n    :else  false\n)))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 95, "code": "(fn binary-tree? [items]\n  (cond \n   (nil? items) true\n   (sequential? items)\n   (let [size (= 3 (count items))\n         left-tree (second items)\n         right-tree (first (rest (rest items)))]\n     (and size (binary-tree? left-tree) (binary-tree? right-tree)))\n   :else false))", "user": "55bbfd60e4b01b9910ae29ed"}, {"problem": 95, "code": "(fn is-tree [[_ l r :as t]]\n    (and (= 3 (count t)) \n         (if (nil? l) true (and (coll? l) (is-tree l)))\n         (if (nil? r) true (and (coll? r) (is-tree r)))))", "user": "5245e320e4b09dbe66b56177"}, {"problem": 95, "code": "(fn is-tree? [s]\n    (if (nil? s)\n      true\n      (if (or (not (coll? s)) (not= 3 (count s)))\n        false\n        (and (is-tree? (nth s 1)) (is-tree? (nth s 2)))\n        )))", "user": "54a627bce4b09f271ff37c83"}, {"problem": 95, "code": "(fn bin-tree? [s]\n      (or (nil? s) (and\n                     (coll? s)\n                     (= 3 (count s))\n                     (not= nil (first s))\n                     (bin-tree? (first (rest s)))\n                     (bin-tree? (last s)))))", "user": "5587cd86e4b059ccff29b1e6"}, {"problem": 95, "code": "(fn tree? [tree-or-node]\n    (or (nil? tree-or-node)\n        (and (coll? tree-or-node)\n             (= 3 (count tree-or-node))\n             (every? tree? (rest tree-or-node)))))", "user": "50978ca4e4b00ad8bab4e966"}, {"problem": 95, "code": "#(letfn\n  [(is-tree? [tree]\n            (or\n             (nil? tree)\n             (and\n              (and (sequential? tree) (= 3 (count tree)))\n              (is-tree? (second tree))\n              (is-tree? (nth tree 2)))))]\n   (is-tree? %))", "user": "55868660e4b059ccff29b1d4"}, {"problem": 95, "code": "(fn [tree]\n   (letfn [(binary-tree? [tree]\n             (cond\n                   (nil? tree) true\n                   (not (sequential? tree)) false\n                   (empty? tree) false\n                   :else (let [[key right left] tree]\n                           (if \n                             (and (= 3 (count tree))\n                                  (not (nil? key)) \n                                  (binary-tree? right)\n                                  (binary-tree? left))\n                             true\n                             false))))]\n     (binary-tree? tree)))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 95, "code": "(fn f [n] (or (nil? n)\n            (and \n             (coll? n)\n             (= (count n) 3)\n             (every? true? (map f (rest n)))\n            )\n))", "user": "55bfc39ee4b01b9910ae2a1a"}, {"problem": 95, "code": "(fn btree? [t]\n  (and (sequential? t)\n       (= 3 (count t))\n       (and (or (nil? (nth t 1)) (btree? (nth t 1)))\n            (or (nil? (nth t 2)) (btree? (nth t 2))))))", "user": "516f5b7ee4b0ef3e37990e7e"}, {"problem": 95, "code": "(fn isTree[col]\n  (if (not= 3 (count col))\n    false\n    (every? \n     #(if (coll? %)\n        (isTree %)\n        (nil? %) \n        ) (rest col))))", "user": "555883c5e4b0deb715856e2d"}, {"problem": 95, "code": "(fn correct [xs]\n  (or\n   (not (sequential? xs))\n   (and\n    (=\n     (count (filter #(or (nil? %) %) xs))\n       3)\n    (every? identity (map correct xs)))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n    (nil? s) true\n    (not (coll? s)) false\n    :else (let [[v l r] s]\n            (and (not (nil? v)) (tree? l) (tree? r) (= 3 (count s))))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 95, "code": "(fn binary-tree? [t] (if (nil? t) true\n                          (if (and t (= 3 (count t))) \n                            (let [[a b c] t] (and a (binary-tree? b) (binary-tree? c)))\n                          false)))", "user": "55c10409e4b01b9910ae2a2c"}, {"problem": 95, "code": "(fn tree? [x]\n    (or (nil? x)\n        (and (coll? x)\n             (= 3 (count x))\n             (every? tree? (rest x)))))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 95, "code": "(fn tree? [s]\n  (if (sequential? s)\n    (let [v (first s)\n          l (second s)\n          r (second (next s))]\n      (and (= 3 (count s))\n           v\n           (or (nil? l) (tree? l))\n           (or (nil? r) (tree? r))))\n    false\n    ))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 95, "code": "(fn tree? [tree]\n   (cond (or (nil? tree)\n             (and (not (false? tree))\n                  (= 3 (count tree))\n                  (tree? (nth tree 1))\n                  (tree? (nth tree 2)))) true\n                  :else false))", "user": "51f40975e4b0fca5e8b4822e"}, {"problem": 95, "code": "(fn is-tree? [node]\n   (cond (nil? node) true\n         (not (coll? node)) false\n         (not (= (count node) 3)) false\n         :else (and (is-tree? (nth node 1)) (is-tree? (nth node 2)))))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (tree? (second node))\n           (tree? (last node)))))", "user": "55a1d7f6e4b0acc240e31519"}, {"problem": 95, "code": "(fn tree? [xs] \n  (if (and (coll? xs) (= 3 (count xs)))\n    (let [[_ left right] xs]\n      (cond \n        (not (nil? left)) (tree? left)\n        (not (nil? right)) (tree? right)\n        :else true))\n    false))", "user": "54dce62be4b024c67c0cf78b"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (let [[root l-child r-child] t]\n                (and (not (coll? root))\n                     (tree? l-child)\n                     (tree? r-child))))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 95, "code": "(fn tree? [tree]\n  (or (nil? tree)\n      (and\n       (coll? tree)\n       (= 3 (count tree))\n       (tree? (nth tree 1))\n       (tree? (nth tree 2)))))", "user": "55c68089e4b0e31453f649c4"}, {"problem": 95, "code": "(fn tree? [tree]\r\n  (cond\r\n    (nil? tree) true\r\n    (not tree) false\r\n    :else (if (= 3 (count tree))\r\n            (let [[n l r] tree]\r\n              (and (or n (nil? n)) (tree? l) (tree? r)))\r\n            false)))", "user": "546e1142e4b00cfc9eacc199"}, {"problem": 95, "code": "#(every? true? (flatten ((fn treecheck [coll]\n                              (cond\n                                (if (sequential? coll)\n                                  (= 3 (count (seq coll))))\n                                (map treecheck (rest coll))\n                                (nil? coll)\n                                '(true)\n                                :else\n                                '(false))) %)))", "user": "53e73fe3e4b036ad0777e478"}, {"problem": 95, "code": "(fn is-tree [t]\n  (and (coll? t) (= (count t) 3)\n       (or (nil? (second t)) (is-tree (second t)))\n       (or (nil? (nth t 2)) (is-tree (nth t 2)))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 95, "code": ";using tree-seq, and using comp and juxt:)\n(fn [root] \n  (let [elements (tree-seq coll? identity root)\n        value?   (complement coll?)\n        child?   (comp (partial some true?) (juxt coll? nil?))\n        node?    #(or (nil? %)\n                      (and (coll? %)\n                           (= 3 (count %))\n                           (value? (first %))\n                           (child? (second %))\n                           (child? (last %))))   ]\n    (every? #(or (value? %) (node? %)) elements)))\n;recursive\n#_(fn bintree? [t] \n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (not (coll? (first t)))\n           (bintree? (second t))\n           (bintree? (last t)))))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 95, "code": "(fn istree?\n  [x]\n  (if (nil? x) true\n    (if-not (sequential? x) false\n      (if-not (= (count x) 3) false\n        (and (istree? (nth x 1)) (istree? (nth x 2)))))))", "user": "55c77070e4b0e31453f649d0"}, {"problem": 95, "code": "(fn [tree]\n\t(letfn [\n\t\t(nil-or-nd [n]\n\t\t\t(or (nil? n) (and (sequential? n) (not (empty? n)))))\n\t\t(is-node-rec [nd]\n\t\t\t(if (nil? nd)\n\t\t\t\ttrue\n\t\t\t\t(if (or (not= (count nd) 3) (nil? (first nd)) (not (nil-or-nd (second nd))) (not (nil-or-nd (nth nd 2))))\n\t\t\t\t\tfalse\n\t\t\t\t\t(and\n\t\t\t\t\t\t(is-node-rec (second nd))\n\t\t\t\t\t\t(is-node-rec (nth nd 2))))))]\n\t(is-node-rec tree)))", "user": "55bb6107e4b01b9910ae29e4"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "5589a941e4b059ccff29b207"}, {"problem": 95, "code": "(fn chk-tree [l]\n  (if (not= (count l) 3)\n    false\n    (and\n     (not (coll? (first l)))\n     (cond\n       (nil? (second l)) true\n       (coll? (second l)) (chk-tree (second l))\n       :else false)\n     (cond\n       (nil? (last l)) true\n       (coll? (last l)) (chk-tree (last l))\n       :else false))))", "user": "55236ad6e4b0882d96d091b1"}, {"problem": 95, "code": "(fn [input] (letfn [\n        (next [y] (reduce #(and %1 %2) (map branch? y)))\n        (branch? [x] (cond (not (coll? x)) (not= false x)    (not= 3 (count x)) false  :else  (next x)))]\n  (if (not= 3 (count input)) false\n  (next input))))", "user": "552456e3e4b0882d96d091c2"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55d3811be4b0e31453f64a69"}, {"problem": 95, "code": "(fn ff [x] (or (nil? x) (and (coll? x) (= (.size x) 3) (ff (nth x 1)) (ff (nth x 2)) )))", "user": "55b0f5bfe4b002ce9d5cbc28"}, {"problem": 95, "code": "(fn is-bin-tree [node]\n  (if (or (not (sequential? node)) (not= (.size node) 3))\n    false\n    (let [[value left right] node]\n      (and \n       (or (nil? left) (is-bin-tree left))\n       (or (nil? right) (is-bin-tree right))))))", "user": "55d06bcbe4b0e31453f64a3a"}, {"problem": 95, "code": "(fn binary-tree? [node]\n  (if (nil? node)\n    true\n    (if (not (or (vector? node) (seq? node)))\n      false\n      (let [[value left right] node]\n\t      (and (= 3 (count node)) (binary-tree? left) (binary-tree? right))))))", "user": "55d6a2ebe4b0e31453f64a9a"}, {"problem": 95, "code": "(fn binary-tree? [node]\n  (cond\n   (nil? node) true\n   (coll? node) (let [[value & children] node]\n                 (if (not= 2 (count children))\n                   false\n                   (apply #(and %1 %2) (map binary-tree? children))))\n   :else false))", "user": "5561d2c2e4b0c656e3ff17cd"}, {"problem": 95, "code": "(fn bt? [t]\n  (if (coll? t)\n    (let [[_ l r] t]\n      (and (= 3 (count t))\n           (bt? l)\n           (bt? r)))\n    (nil? t)))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 95, "code": "(fn binary-tree [tree] (or (nil? tree) (and (coll? tree) (= 3 (count tree)) (binary-tree (second tree)) (binary-tree (last tree)))))", "user": "55cae949e4b0e31453f649fe"}, {"problem": 95, "code": "(fn t? [x] (let [cs (filter sequential? x)]\n               (and (= (count x) 3)\n                    (= (+ (count cs) (count (filter nil? x))) 2)\n                    (every? t? cs))))", "user": "55773cbae4b05c286339e07f"}, {"problem": 95, "code": "(fn tree? [lst]\n  (cond\n    (nil? lst)                   true\n    (not (sequential? lst))      false\n    (not= 3 (count lst))         false\n    :else                        (every? tree? (rest lst))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 95, "code": "(fn binary-tree? [[x l r :as coll]]\n  (and\n   (= (count coll) 3)\n   (if (coll? l) (binary-tree? l) (nil? l))\n   (if (coll? r) (binary-tree? r) (nil? r))))", "user": "54722c55e4b094393f72dd74"}, {"problem": 95, "code": "(fn bin-tree? [coll]\r\n    (and (= 3 (count coll))\r\n         (let [[x a b & coll] coll]\r\n           (and (not (= a false)) ;;ad-hoc work-around\r\n                (not (coll? x))\r\n                   (or (not (coll? a))\r\n                       (bin-tree? a))\r\n                   (or (not (coll? b))\r\n                       (bin-tree? b))))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 95, "code": "(fn is-tree [x]\n  (cond\n    (nil? x) true\n    (coll? x) (let [[first-three remaining] (split-at 3 x)]\n      (and\n        (empty? remaining)\n        (= 3 (count first-three))\n        (and (is-tree (nth first-three 1)) (is-tree (nth first-three 2)))\n      )\n    )\n    :else false))", "user": "51f09f3de4b0274c496158d7"}, {"problem": 95, "code": "(fn p95 [v]\n  (and\n   (sequential? v)\n   (= (count v) 3)\n   (let [[lb c1 c2] v\n         f (fn [e] (or (nil? e) (p95 e)))]\n     (and (not (nil? lb)) (f c1) (f c2)))))", "user": "54965534e4b0b312c081ff65"}, {"problem": 95, "code": "(fn bi-tree? [branch]\n  (if (nil? branch)\n    true\n    (if-not (coll? branch)\n      false\n      (if-not (= 3 (count branch))\n        false\n        (let [[root left-child right-child] branch]\n        (and root (bi-tree? left-child) (bi-tree? right-child)))))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 95, "code": "(fn is-bt? [coll]\n   (if (and (coll? coll) (= 3 (count coll)))\n     (let [l (second coll)\n           r (last coll)]\n       (and (if (nil? l) true (is-bt? l))\n            (if (nil? r) true (is-bt? r))))\n     false))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 95, "code": "(fn this [tree]\n  (if (not (or (sequential? tree) (nil? tree)))\n    false\n    (if (nil? tree)\n      true\n      (if (not (= 3 (count tree)))\n        false\n        (and (this (second tree)) (this (last tree)))\n      ))))", "user": "55d79b87e4b0e31453f64aa8"}, {"problem": 95, "code": "(fn g [s]\n  (let [[x y z] s f #(if (coll? %) (g %) (nil? %))]\n    (and (= (count s) 3) \n         (f y)\n         (f z)\n     )\n    )\n )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 95, "code": "(fn is-tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= 3 (count coll))\n           (every? is-tree? (rest coll)))))", "user": "4f88ae35e4b033992c121c6d"}, {"problem": 95, "code": "#(and (= 3 (count %)) (not (re-find #\"(false)|(\\(\\))\" (str %))) )", "user": "534056fce4b085b17e897dac"}, {"problem": 95, "code": "(fn tree? [t]\n   (or (nil? t)\n       (and (coll? t)\n            (= 3 (count t))\n            (first t)\n            (every? tree? (rest t)))))", "user": "55c652dde4b0e31453f649bd"}, {"problem": 95, "code": "(fn tree? [x]\n    (cond (nil? x) true\n          (and (sequential? x) (= (count x) 3)) (let [v (first x),\n                                                      left (second x), \n                                                      right (last x)] \n                                                    (and (or (number? v) (keyword? v) (string? v) (true? v) (false? v)) \n                                                         (tree? left) \n                                                         (tree? right)))\n          :else false))", "user": "55627de1e4b0c656e3ff17d9"}, {"problem": 95, "code": "(fn f[s]\n  (or \n   (nil? s)\n   (and (sequential? s) (= 3 (count s)) (f (second s)) (f (nth s 2)))))", "user": "55dab408e4b0e31453f64ad9"}, {"problem": 95, "code": "(fn is-bin-tree? [tree]\n (if (nil? tree)\n   true\n   (and (coll? tree)\n        (= 3 (count tree))\n        (every? is-bin-tree? (next tree)))))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= 3 (count tree))\n           (every? binary-tree? (rest tree)))))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 95, "code": "(fn my-check [n]\n  (cond (not (coll? n)) (if (nil? n) true false)\n        (not (= (count n) 3)) false\n        :else\n        (let [v (first n) f (second n) r (last n)]\n          (and (my-check f) (my-check r)))))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 95, "code": "(fn f [n] (if (sequential? n)\n            (if (= (count n) 3)\n              (and (f (nth n 1)) (f (nth n 2)))\n              false)\n            (if (nil? n)\n              true\n              false)))", "user": "55d1b565e4b0e31453f64a49"}, {"problem": 95, "code": "(fn test-tree?\n  [tree]\n  (cond\n    (nil? tree) true\n    (not (coll? tree)) false\n    (not= (count tree) 3) false\n    :else (let [[hd tl tr] tree]\n            (if (seq? hd) false (and (test-tree? tl) (test-tree? tr))))))", "user": "55d93d24e4b0e31453f64ac6"}, {"problem": 95, "code": "(fn ? [t] (or (nil? t) (and (coll? t) (= 3 (count t)) (? (nth t 1)) (? (nth t 2)))))", "user": "54864662e4b0e286459a11b8"}, {"problem": 95, "code": "(fn hello [o]\n  (let [\n        tree? #(and (coll? %) (= 3 (count %)))\n        ]\n    (cond\n      (nil? o) true\n      (tree? o) (every? hello (rest o))\n      :else false\n      )\n    )\n  )", "user": "55d42f78e4b0e31453f64a73"}, {"problem": 95, "code": "(fn bin-tree? [[val & children]]\n  (and (= (count children) 2)\n       (every? #(if (sequential? %) (bin-tree? %) (nil? %)) children)))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 95, "code": "(fn tree? [xs] \n  (letfn [(leaf? [x] (not (or (coll? x) (false? x))))\n          (leaf-or-tree? [x] (or (leaf? x)(tree? x)))]                                                                    \n  (and \n    (coll? xs)\n    (= 3 (count xs))\n    (leaf-or-tree? (second xs))\n    (leaf-or-tree? (last xs))\n    )))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (or (seq? x) (vector? x)) ;; LAME\n           (= 3 (count x))\n           (tree? (nth x 1))\n           (tree? (nth x 2)))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 95, "code": "(fn tree? [xs]\n  (cond\n    (or (seq? xs) (vector? xs))\n    (and (= 3 (count xs)) (tree? (nth xs 1)) (tree? (nth xs 2)))\n    (nil? xs) true\n    :else false))", "user": "54008b88e4b0de5c4184860d"}, {"problem": 95, "code": "(fn shit [m]\n  (cond \n      (nil? m) true\n       (and (coll? m) (= 3 (count m))) (and (shit (nth m 1)) (shit (nth m 2)))\n         :else false))", "user": "54d05a9de4b0e8a36923e5c7"}, {"problem": 95, "code": ";improve???\n(fn binaryTree? [s]\n\n  (if (or (and (not (nil? s)) (not (coll? s))) (and (coll? s) (not= 3 (count s))))  false\n    ;else\n    (if (or (nil? s) \n          (and\n            (= 3 (count s))\n            (not (coll? (first s))) \n            (nil? (nth s 1)) \n            (nil? (nth s 2)))) true\n      ;else\n      (and (binaryTree? (nth s 1)) (binaryTree? (nth s 2))))))", "user": "558bdcefe4b0277789237633"}, {"problem": 95, "code": "(fn prob95 [s]\n  (if (nil? s)\n    true\n    (if (or (not (coll? s)) (not= 3 (count s)))\n      false\n       (and (prob95 (nth s 1)) (prob95 (nth s 2))))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 95, "code": "(fn valid-tree? [lst]\n    (and \n     (not= nil (first lst))\n     (= 3 (count lst))\n     (or \n      (nil? (second lst))\n      (and\n       (sequential? (second lst))\n       (valid-tree? (second lst))))\n     (or \n      (nil? (last lst))\n      (and\n       (sequential? (last lst))\n       (valid-tree? (last lst))))))", "user": "55a19e19e4b0acc240e31515"}, {"problem": 95, "code": "(fn binary-tree? [root]\n  (if (nil? root)\n    true\n    (if (and (coll? root) (= 3 (count root)))\n      (and (binary-tree? (nth root 1))(binary-tree? (nth root 2)))\n      false)\n    )\n  )", "user": "55f06183e4b06e875b46ce23"}, {"problem": 95, "code": "(fn tree? [s] (or (nil? s)\n                  (and (coll? s)\n                       (= 3 (count s))\n                       (tree? (nth s 1))\n                       (tree? (nth s 2)))))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 95, "code": "(fn istree? [theseq] (if (nil? theseq) true (if (coll? theseq) (if (not (= (count theseq) 3)) false (and (istree? (nth theseq 1)) (istree? (nth theseq 2)))) false)))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 95, "code": "(fn to-tree [coll]\n  (boolean\n   (clojure.walk/postwalk (fn [forms]\n                            (if (and (sequential? forms)\n                                     (or (not= 3 (count forms))\n                                         (not (every? (some-fn sequential? nil?)\n                                                      (rest forms)))))\n                              false\n                              forms))\n                          coll)))", "user": "50e3e108e4b01912b3285c48"}, {"problem": 95, "code": "(fn tree? [t]\n   (or (nil? t)\n       (and (sequential? t)\n            (= 3 (count t))\n            (let [[v l r] t]\n              (and v (tree? l) (tree? r))))))", "user": "553698fae4b09218d5f44fc0"}, {"problem": 95, "code": "(fn binary-tree? [tree] \n  (if (coll? tree)\n    (let [[_ left right] tree]\n      (and \n       (= 3 (count tree)) \n       (binary-tree? left) \n       (binary-tree? right)))\n    (nil? tree)))", "user": "4ec7c32c535d6d7199dd36e6"}, {"problem": 95, "code": "(fn [a]\n    (letfn [(check [x]\n              (if (nil? x)\n                true\n                (and (coll? x) (not (empty? x)) (= 3 (count x)) (check (nth x 1)) (check (nth x 2)))))]\n      (check a)))", "user": "55577fcce4b0deb715856e24"}, {"problem": 95, "code": "(fn btree?\n  [cols]\n  (cond\n    (nil? cols) true\n    (not (coll? cols)) false\n    (not= 3 (count cols)) false\n    :else (and (btree? (first (rest cols))) (btree? (last cols)))))", "user": "55d5ee3fe4b0e31453f64a92"}, {"problem": 95, "code": "(fn binary-tree?\n  [x]\n  (if (coll? x)\n    (and (= (count x) 3) (every? binary-tree? x))\n    (if (false? x) x true)))", "user": "5574c172e4b05c286339e059"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (cond\n   (nil? coll) true\n   (false? (coll? coll)) false\n   (not= 3 (count coll)) false\n   :else (let [[val left right] coll]\n           (and (false? (coll? val))\n                (binary-tree? left)\n                (binary-tree? right)))))", "user": "55f6e7ece4b06e875b46ce9e"}, {"problem": 95, "code": "(fn tree? [a]\n    (cond (nil? a) true\n          (and (coll? a)\n               (= (count a) 3)) (let [[_ l r] a]\n                                  (and (tree? l)\n                                       (tree? r)))\n               :else false))", "user": "532f8569e4b019098a6f8b4f"}, {"problem": 95, "code": "(fn is-binary-tree? [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= (count n) 3)\n           (every? is-binary-tree? (rest n)))))", "user": "55af3e6be4b03311e7b732c7"}, {"problem": 95, "code": "(fn check-node [[:as all]]\n  (if (coll? all)\n    (and (= 3 (count all)) (check-node (nth all 1)) (check-node (nth all 2)))\n    (not (false? all))))", "user": "55f4ef68e4b06e875b46ce82"}, {"problem": 95, "code": "(fn binary-tree? [xs & acc]\n  (let [more (drop 1 xs)]\n    (and\n      (= (count xs) 3)\n      (every? #(or (coll? %) (nil? %)) more)\n      (every? (partial = true) (map binary-tree? (remove nil? more))))))", "user": "55fb58b2e4b0f488688e0661"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (sequential? x) (= 3 (count x))\n           (not (sequential? (first x)))\n           (tree? (second x))\n           (recur (nth x 2)))))", "user": "560843dee4b046a4fc0ac00e"}, {"problem": 95, "code": "(fn tree? [seq]\n  (cond\n    (false? seq) false\n    (and (not (seq? seq))(not (vector? seq))) true\n    (empty? seq) false\n    (not= (count seq) 3) false\n    :else (and (tree? (nth seq 0))\n               (tree? (nth seq 1))\n               (tree? (nth seq 2)))))", "user": "55f8180fe4b06e875b46ceba"}, {"problem": 95, "code": "(fn is-tree? [xs]\n  (if (coll? xs)\n    (let [[_ l r] xs]\n      (and \n        (= (count xs) 3) \n        (or (nil? l) (is-tree? l)) \n        (or (nil? r) (is-tree? r))))\n    false))", "user": "55fee5e4e4b00f4cabc5765a"}, {"problem": 95, "code": "(fn tree? [xs]\n  (cond\n    (nil? xs) true\n    (not (coll? xs)) false\n    (not= 3 (count xs)) false\n    (or (nil? (first xs)) (coll? (first xs))) false\n    :else (and (tree? (second xs)) (tree? (nth xs 2)))))", "user": "55e7d06ee4b050e68259b496"}, {"problem": 95, "code": "(fn checktree\n  [tree]\n    (letfn [(check-leaf [leaf]\n                         (if (nil? leaf)\n                           true\n                           (checktree leaf)))]\n      (and\n        (sequential? tree)\n        (= (count tree) 3)\n        (check-leaf (first (rest tree)))\n        (check-leaf (last (rest tree))))))", "user": "55996253e4b031d6649c9baa"}, {"problem": 95, "code": "(fn my-tree? [tree]\n   (if (sequential? tree)\n     (and (= (count tree) 3) (and (my-tree? (second tree)) (my-tree? (last tree))))\n     (nil? tree)\n     ))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 95, "code": "(fn [tree]\n  (let [is-child (fn [n]\n                   (or\n                     (nil? n)\n                     (and\n                       (coll? n)\n                       (= (count n) 3))))]\n    (loop [queue (conj [] tree)]\n      (prn queue)\n      (if (empty? queue)\n        true\n        (let [a (first queue)\n              b (rest queue)]\n          (prn \"a=\" a \"|is-child=\" (is-child a))\n          (if (is-child a)\n            (if (nil? a)\n              (recur b)\n              (recur (conj b (nth a 1) (nth a 2))))\n            false))))))", "user": "559e6f42e4b08a52bd4f97d3"}, {"problem": 95, "code": "(fn istree?[t]\n  (cond \n    (nil? t) true\n    (not (sequential? t)) false\n    (= 3 (count t))\n      (let [a (first t) l (second t) r (nth t 2)]\n         (and (not (seq? a)) (istree? l) (istree? r))\n       )\n    :else  false\n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n    (and (= 3 (count coll)) \n      (tree? (nth coll 1)) \n      (tree? (nth coll 2))\n    )\n    (nil? coll) true\n  :else false)\n)", "user": "560d2a2be4b05f002753df35"}, {"problem": 95, "code": "(fn tree? [arg]\n  (or (nil? arg)\n      (and (sequential? arg)\n           (= 3 (count arg))\n           (let [[value left right] arg]\n             (and (tree? left)\n                  (tree? right))))))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 95, "code": "(fn f [node]\n  (if (nil? node) true\n    (letfn [(node-or-nil [item] (or (coll? item) (nil? item)))]\n      (if (not= (map node-or-nil node) '(false true true)) false\n        (and (f (second node)) (f (last node)))))))", "user": "56041883e4b0c80df0ca2655"}, {"problem": 95, "code": "(fn ibt? [abc] \n        (and (= 3 (count abc)) \n             (every? #(or (nil? %) (and (sequential? %) (ibt? %))) (rest abc))))", "user": "5361d423e4b0243289761e49"}, {"problem": 95, "code": "(fn tree [t]\n  (cond\n    (not t) (nil? t)\n    (not= (count t) 3) false\n    :else (let [[_ l r] t] (and (tree l) (tree r)))))", "user": "560a7b46e4b05f002753defb"}, {"problem": 95, "code": "(fn binary-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? binary-tree? (rest root)))))", "user": "55e1bb20e4b050e68259b41f"}, {"problem": 95, "code": "(fn binary-tree-node? [node]\n  (if (nil? node)\n    true\n    (if (and (coll? node) (= (count node) 3))\n      (let [left (second node)\n            right (last node)]\n        (and (binary-tree-node? left) (binary-tree-node? right)))\n      false)))", "user": "532ecd44e4b019098a6f8b49"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (letfn [(valid-node? [col idx]\n            (let [elem (nth col idx)]\n              (if (nil? elem)\n                true\n                (and (coll? elem) (binary-tree? elem)))))]\n    (if (= 3 (count xs))\n      (and (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))\n      false)))", "user": "56038f34e4b04bb52996e1bc"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (every? binary-tree? (rest tree)))))", "user": "53fc88e7e4b0de5c418485be"}, {"problem": 95, "code": "(fn bntree? [l]\n  (if (not (sequential? l))\n    (nil? l)\n    (if (not= (count l) 3)\n      false\n      (and (bntree? (second l)) (bntree? (last l))))))", "user": "56051095e4b08b23635d3162"}, {"problem": 95, "code": "(fn go [t]\n  (cond\n   (nil? t) true\n   (not (sequential? t)) false\n   (not= 3 (count t)) false\n   :else (and (go (second t)) (go (nth t 2)))))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 95, "code": "(fn t? [n] \n  \n  (or \n   (nil? n) \n   (and \n    (counted? n) \n    (= 3 (count n)) \n    (every? t? (rest n))\n)))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 95, "code": "(fn ctree [xs]\n    (if (not= (count (seq xs)) 3)\n      (do (println \"not 3 items, returning false\") false)\n      (let [[n ls rs & rst] xs]\n        (and (not (seq? n))\n             (or (nil? ls) (and (and (sequential? ls) (ctree ls))))\n             (or (nil? rs) (and (and (sequential? rs) (ctree rs))))))))", "user": "560e9a2de4b05f002753df52"}, {"problem": 95, "code": "(fn check-node [node]\n  (let [[v l r] node]\n    (and (= 3 (count node))\n         (not (nil? v)) \n         (if (coll? l)\n           (check-node l)\n           (nil? l))\n         (if (coll? r)\n           (check-node r)\n           (nil? r)))))", "user": "53573d70e4b04ce2eb3ed278"}, {"problem": 95, "code": "(fn bintree? [sequence]\n  (cond \n    (nil? sequence) true\n    (and (coll? sequence) \n         (= 3 (count sequence))) (and\n                                  (bintree? (second sequence))\n                                  (bintree? (last sequence)))\n    :default false\n    ))", "user": "5603d057e4b0c80df0ca264e"}, {"problem": 95, "code": "(fn fun [tree]\n  (if (or (seq? tree) (vector? tree))\n    (if (= (count tree) 3)\n      (and (fun (nth tree 1)) (fun (nth tree 2)))\n      false)\n    (nil? tree)))", "user": "560ff632e4b05f002753df66"}, {"problem": 95, "code": "(fn fg [ls]\n  (cond \n    (nil? ls) true\n    (or (vector? ls) (list? ls)) (if (= 3 (count ls))\n                (and (fg (nth ls 1)) (fg (nth ls 2)))\n                false)\n    (false? ls) false))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55f6f1d3e4b06e875b46cea0"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55022d7ce4b07d26eda61d84"}, {"problem": 95, "code": "(fn node? [c] \n    (or (nil? c)\n        (and\n          (sequential? c)\n          (= 3 (count c)) \n          (every? node? (rest c))\n          )))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 95, "code": "(fn is-binary-tree [sq]\n\t(if (nil? sq) true\n\t\t(if (or (not (sequential? sq)) (not= 3 (count sq))) \n\t\t\tfalse\n\t\t\t(and \n\t\t\t\t(is-binary-tree (first (next sq)))\n\t\t\t\t(is-binary-tree (first (next (next sq)))))\n\t\t)\n\t)\n)", "user": "5559b443e4b0deb715856e3c"}, {"problem": 95, "code": "(fn valid-tree? [tree]\n    (if (or (nil? tree))\n      true \n      (and (coll? tree)\n           (= 3 (count tree))\n           (and (not (coll? (first tree)))\n                (not (nil? (first tree)))\n                (valid-tree? (nth tree 1))\n                (valid-tree? (nth tree 2)))\n                \n                )\n      )\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 95, "code": "(fn t? [r]\n  (or (nil? r)\n      (and (coll? r)\n           (= 3 (count r))\n           (every? t? (rest r)))))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 95, "code": "(fn binarytree? [tree]\n  (if (and (coll? tree) (= (count tree) 3))\n    (every? true? (map binarytree? (filter (complement nil?) (rest tree))))\n    false))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "56011393e4b04bb52996e178"}, {"problem": 95, "code": "(fn bin-tree? [t] \n  (cond\n    (nil? t) true\n    (not (coll? t)) false\n    (= 3 (count t)) (let [[v l r] t] (and (bin-tree? l) (bin-tree? r)))\n    :else false))", "user": "4f0f01c0535d0136e6c22329"}, {"problem": 95, "code": "(fn btree? [branch]\n  (and (sequential? branch)\n       (= (count branch) 3)\n       (every? identity (map #(or (nil? %) (btree? %)) (rest branch)))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 95, "code": "(fn binary-tree? [s]\n    (or (nil? s)\n        (and (coll? s)\n             (= 3 (count s))\n             (let [[v l r] s]\n               (and (binary-tree? l) (binary-tree? r))))))", "user": "516385cee4b055933a9ca02d"}, {"problem": 95, "code": "(fn f [s]\n  (letfn [(t [v] \n             (if (sequential? v)\n               (f v)\n               (not= false v)))]\n    (if (= 3 (count s))\n      (let [v (nth s 0)\n            l (nth s 1)\n            r (nth s 2)]\n        (and (t l) (t r)))\n      false)))", "user": "55b1e9e7e4b0da326a65cf74"}, {"problem": 95, "code": "(fn is-binary-tree? [t]\n  (let [sub1 (second t) sub2 (nth t 2 nil) seq-or-nil? (fn [s] (or (nil? s) (sequential? s)))]\n  (cond \n    (not (sequential? t)) true\n    (not= (count t) 3) false\n    (not  (and (seq-or-nil? sub1) (seq-or-nil? sub2))) false\n    (or  (sequential? sub1) (sequential? sub2)) (and  (is-binary-tree? sub1) (is-binary-tree? sub2))\n    :else true)))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 95, "code": "(fn tree? [[v l r :as node]]\n  (if (= 3 (count node))\n    (cond (and (nil? l) (nil? r)) true\n          (nil? l) (and (sequential? r) (tree? r))\n          (nil? r) (and (sequential? l) (tree? l))\n          :else (and (tree? l) (tree? r)))\n    false))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 95, "code": "(fn tree? [tree]\n  (or (nil? tree)\n      (and (coll? tree) \n           (= 3 (count tree))\n           (and (tree? (second tree)) (tree? (last tree))))))", "user": "560039cce4b04bb52996e162"}, {"problem": 95, "code": "(fn btree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? btree? (rest root)))))", "user": "4f40c46fe4b0e243712b1fbe"}, {"problem": 95, "code": "(fn tree [coll]\n        (let [inner-coll (first (filter coll? coll))\t\n              is-binary (odd? (count (filter #(and (not= % true) (not= % false)) (flatten coll))))]                                                                                                                                         \n          (if (and is-binary (= (count inner-coll) 3)) \n            (tree inner-coll)\n           \tis-binary)))", "user": "5410499de4b01498b1a719a6"}, {"problem": 95, "code": "(fn tree? [[h & r]]\n  (if h\n      (if (= 2 (count r))\n        (every? true? (map #(if % (tree? %) (nil? %)) r))\n        false)\n      false))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": 95, "code": "(fn is-node [tab]\n  (or (nil? tab)\n    (and \n     (coll? tab)\n     (= 3 (count tab))\n     (every? #(is-node %) (rest tab))\n     )\n      )\n  )", "user": "55e8a85be4b0121d4835fd98"}, {"problem": 95, "code": "(fn is_bin? [x]\n   (println x)\n   (if (or (seq? x) (vector? x))\n     (if (and (= 3 (count x))\n              (not (seq? (nth x 0)))\n              (is_bin? (nth x 1))\n              (is_bin? (nth x 2))) true false) \n     (if (nil? x) true false)) )", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 95, "code": "(fn pred [tree]\n  (cond (not (sequential? tree)) false\n        (not= (count tree) 3) false\n        :else (let [l (second tree)\n                    r (last tree)]\n                (and (or (nil? l) (pred l))\n                     (or (nil? r) (pred r))))))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 95, "code": "(fn [coll]\n   (clojure.walk/postwalk\n     (fn [form]\n       (if (or (and (coll? form)\n                    (= 3 (count form))\n                    (every? true? form))\n               (and (not (coll? form))\n                    (not (false? form))))\n         true\n         false))\n     coll))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 95, "code": "(fn binaryTree? [se]\n  (if (coll? se)\n    (if (= (count se) 3) (and (and (binaryTree? (nth se 0)) (binaryTree? (nth se 1))) (binaryTree? (nth se 2)))\n      false)\n    (false? (false? se))))", "user": "558378dce4b05c286339e115"}, {"problem": 95, "code": "(fn [t]\n     (letfn [(isnode [node]\n\t\t     (or (nil? node) \n\t\t\t (and (coll? node)\n\t\t\t      (= (count node) 3)\n\t\t\t      (isnode (second node))\n\t\t\t      (isnode (last node))\n\t\t\t      )))]\n\t     (isnode t)))", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 95, "code": "(fn bt? [t]\n  (if (or (not (sequential? t))\n          (and (not (some false? t))\n           \t   (= 3 (count t))\n               (bt? (second t))\n               (bt? (last t))))\n    true false))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 95, "code": "(fn b? [[_ l r :as t]]\n  (and (= 3 (count t))\n       (not-any? false? t)\n       (or (nil? l) (b? l))\n       (or (nil? r) (b? r))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 95, "code": "(fn bintree? [inp]\n  (and\n     (= 3 (count inp))\n     (every?\n       (fn [el]\n         (if (= false el)\n           false\n           (or (not (sequential? el))\n               (bintree? el))))\n       inp)))", "user": "552d2e4fe4b076ab5578f7e1"}, {"problem": 95, "code": "(fn tree? [x]\n  (and (sequential? x)\n       (= 3 (count x))\n       (every? #(or (nil? %) (tree? %)) (rest x))))", "user": "5566463ee4b0c656e3ff1831"}, {"problem": 95, "code": "(fn T [t] (or (= t nil) (and (coll? t) (= 3 (count t)) (T (nth t 1)) (T (nth t 2)))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n   (or (vector? t) (seq? t))\n   (and (= (count t) 3) (tree? (nth t 1)) (tree? (nth t 2)))\n   (nil? t)\n   true\n   :else\n   false))", "user": "53fcd574e4b0de5c418485d9"}, {"problem": 95, "code": "(fn tree?\n  [t]\n  (if (not= 3 (count t)) false\n      (and\n        (if (coll? (first t)) false true)\n        (if (coll? (second t)) (tree? (second t)) (nil? (second t)))\n        (if (coll? (nth t 2)) (tree? (nth t 2)) (nil? (nth t 2))))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 95, "code": "(fn tree? [node]\n  (boolean (or (nil? node)\n       (if (and (coll? node) (= 3 (count node)))\n         (let [[value left right] node]\n           (and value (tree? left) (tree? right)))))))", "user": "4f213e2ee4b0d66497709fcf"}, {"problem": 95, "code": "(fn checkIfTree [x] \n  (or (nil? x) (and (sequential? x) (= 3 (count x)) (every? checkIfTree (rest x)))))", "user": "5630a51de4b0bfe05bf11781"}, {"problem": 95, "code": "(fn tree[s]\n  (if (= nil s)\n    true\n    (and (coll? s) (= 3 (count s)) (tree (second s)) (tree (last s)))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 95, "code": "(fn [args] ;; update args as needed\n  (letfn [(isatree? [x] \n                    (and (= 3 (count x))\n                         (every? isanode? (rest x))    \n                         )          \n                    )\n          (isanode? [y]\n                    (or (nil? y)\n                        (and \n                         (coll? y)\n                         (isatree? y)\n                         )   \n                        )\n                    )]\n\n    (isatree? args)\n    )\n  )", "user": "536829c8e4b0243289761e8b"}, {"problem": 95, "code": "(fn tree? [node]\n  (if (nil? node)\n    true\n    (if (and (coll? node) (= 3 (count node)))\n       (if (and (nil? (second node)) (nil? (last node)))\n           true\n           (and (tree? (second node)) (tree? (last node))))\n       false)))", "user": "535558b9e4b04ce2eb3ed25a"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (if (nil? tree) true\n    (if (or (not (coll? tree))\n            (not= 3 (count tree))) false\n      (every? binary-tree? (rest tree)))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (coll? coll)\n    (if (= (count coll) 3)\n      (and (tree? (second coll)) (tree? (last coll)))\n      false)\n    (not (false? coll))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 95, "code": "(fn bintree [coll] \n  (if (coll? coll) \n\t(if (= 3 (count coll))\n      (and (bintree (nth coll 2)) (bintree (second coll )) )\n      false)\n  \t(= nil coll)))", "user": "562326cbe4b03f08ee9a9230"}, {"problem": 95, "code": "(fn [t]\n  (reduce #(and %1 %2) \n          (map #(or (and (coll? %) (= 3 (count %))) (nil? %)) \n               (tree-seq  identity rest t))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 95, "code": "(fn bin? [x]\n  (cond \n    (coll? (first x)) false\n    (not= 3 (count x)) false\n    (and (coll? (nth x 1)) (coll? (nth x 2))) (and (bin? (nth x 1)) (bin? (nth x 2)))\n    (coll? (nth x 1)) (bin? (nth x 1))\n    (coll? (nth x 2)) (bin? (nth x 2))\n    (not= (nth x 1) (nth x 2)) false\n    :default true))", "user": "56278266e4b00e49c7cb47d3"}, {"problem": 95, "code": "(fn isTree [x]\n   (or \n    (nil? x)\n    (and\n     (sequential? x)\n     (= 3 (count x))\n     (isTree (nth x 1 false))\n     (isTree (nth x 2 false)))))", "user": "563772a9e4b0bfe05bf117d7"}, {"problem": 95, "code": "(fn b-tree? [maybe-tree]\n  (if (nil? maybe-tree)\n    true\n    (if (and (sequential? maybe-tree) (= (count maybe-tree) 3))\n      (and (b-tree? (second maybe-tree)) (b-tree? (last maybe-tree)))\n      false)\n   )\n  )", "user": "561cb6cfe4b064ca9f4b169e"}, {"problem": 95, "code": "(fn bt? [s]\n  (if (nil? s)\n    true\n    (and (sequential? s)\n         (= 3 (count s))\n         (bt? (second s))\n         (bt? (last s)))))", "user": "561c0278e4b064ca9f4b1691"}, {"problem": 95, "code": "(fn bin-tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= (count t) 3)\n           ;(not (sequential? (first t))) ;; we actually don't care\n           (bin-tree? (second t))\n           (bin-tree? (last t)))))", "user": "54485749e4b032a45b8693c7"}, {"problem": 95, "code": "(fn tree? [x]\n  (if (nil? x)\n    true\n    (if (or (not (coll? x)) (not= 3 (count x)))\n      false\n      (every? true? (map tree? (next x))))))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 95, "code": "(fn F [X] (if (and (coll? X) (= (count X) 3)) (and (F (second X)) (F (last X))) (nil? X)))\n;  (if-not (coll? x)\n;    true\n;    (if-not (= (count x) 3)\n;      false\n;      (let [[v l r] x]\n;        (and\n;         (bin-tree l)\n;         (bin-tree r)\n;         (if (nil? l) true (coll? l))\n;         (if (nil? r) true (coll? r)))))))", "user": "55fc07d3e4b0f488688e066e"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node) (and (sequential? node) (= (count node) 3) (let [[value left right] node] (and (tree? left) (tree? right))))))", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 95, "code": "(fn f [s](\n             if( and (not(coll? s)) (not(false? s)) ) true\n             (if( and (= (count s) 3) (not(false?(first s))) (not(false?(last s))) (not(false?(nth s 1)))) \n             (and (f (first s)) (f (last s)) (f (nth s 1)) )\n             false)\n           ))", "user": "56039843e4b04bb52996e1be"}, {"problem": 95, "code": "(fn binary-tree? [c]\n  (and\n    (coll? c)\n    (== 3 (count c))\n    (not (nil? (first c)))\n    (or (nil? (second c))\n        (binary-tree? (second c)))\n    (or (nil? (last c))\n        (binary-tree? (last c)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 95, "code": "(fn is-tree [node]\n  (if (= node nil) true\n    (if (or (not (coll? node)) (not= (count node) 3)) false\n      (let [value (nth node 0) left (nth node 1) right (nth node 2)]\n        (and (is-tree left) (is-tree right))\n      )\n    )\n  )\n)", "user": "56393681e4b0bfe05bf117f2"}, {"problem": 95, "code": "(fn i [t]\n  (and      \n    (coll? t)\n    (= 3 (count t))\n    (every? #(or (nil? %) (i %)) (rest t))))", "user": "561047eae4b05f002753df6d"}, {"problem": 95, "code": "(fn binary-tree [s]\n  (cond \n   (nil? s) true\n   (not (coll? s)) false\n   (not= 3 (count s)) false\n   :else (and (binary-tree (second s)) (binary-tree (last s)))))", "user": "55d29fb6e4b0e31453f64a59"}, {"problem": 95, "code": "(fn t[s](and(sequential? s)(=(count s)3)(or(nil?(nth s 1))(t(nth s 1)))(or(nil?(nth s 2))(t(nth s 2)))))", "user": "56347285e4b0bfe05bf117bc"}, {"problem": 95, "code": "(fn binary-tree?\n  [coll]\n  (if (not= (count coll) 3)\n    false\n    (let [f (first coll)\n          s (second coll)\n          t (second (next coll))]\n      (and\n       (not (nil? f))\n       (or (nil? s) (and (coll? s) (binary-tree? s)))\n       (or (nil? t) (and (coll? t) (binary-tree? t)))))))", "user": "4fc524aae4b081705acca37e"}, {"problem": 95, "code": "(fn p95\n  [node]\n  (let \n      [valid? (fn [node]\n                (if (and \n                     (= 3 (count node))\n                     (reduce #(and %1 %2) (map #(or (coll? %) (nil? %)) (rest node))))\n                  true\n                  false))]\n    (cond\n     (nil? node) true\n     (valid? node) (and \n                    (p95 (nth node 1))\n                    (p95 (nth node 2)))\n     :else false)))", "user": "545c2d07e4b01be26fd7465c"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "53abed65e4b047364c044455"}, {"problem": 95, "code": "(fn binary-tree?\n  [t]\n  (cond\n    (nil? t) true\n    (not (sequential? t)) false\n    :else (let [[_ left right] t]\n            (and (= (count t) 3)\n              (binary-tree? left)\n              (binary-tree? right)))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 95, "code": "(fn [xs]\n  (let [acc (atom [])\n        fn (fn [c] (if (coll? c) (swap! acc conj c)) c)]\n    (clojure.walk/postwalk fn xs)\n    (not-any? false? (map #(and (= (count %) 3) (not-any? false? %)) @acc))))", "user": "563ed73ae4b08d4f616f5ecb"}, {"problem": 95, "code": "(fn check [tree]\n   (if (= 3 (count tree))\n       (let [[n l r ] tree\n             left-ok?  (if (coll? l) (check l) (nil? l))\n             right-ok? (if (coll? r) (check r) (nil? r))\n            ]\n           (and left-ok? right-ok?)\n       )\n       false\n    ))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 95, "code": "(fn binary-tree?\n  [tree]\n  (let [next-fn (fn [x] (or (nil? x) (and (sequential? x) (binary-tree? x))))]\n  (if (and (first tree) (= 3 (count tree)))\n    (and (next-fn (second tree)) (next-fn (last tree)))\n    false)))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5632b0a9e4b0bfe05bf117a8"}, {"problem": 95, "code": "; This problem had a couple of corner cases, such a boolean values. It's a good example of recursion.\n\n(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n    (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 95, "code": "(fn check-tree [x] (if (not= (count x) 3)\n                       false\n                       (every? identity\n                               (map #(if (sequential? %)\n                                       (check-tree %)\n                                       (not (false? %)) \n                                       ) x))))", "user": "52457931e4b08ba239308107"}, {"problem": 95, "code": "(fn is-tree? [root]\n  (if (and (sequential? root) (= 3 (count root))) \n    (let [[v l r] root] (and (is-tree? l) (is-tree? r)))\n    (nil? root)))", "user": "545e7ab0e4b01be26fd7467c"}, {"problem": 95, "code": "(fn valid? [v] \n  (and (= 3 (count v)) \n       (every? #(or (nil? %) \n                    ((every-pred coll? valid?) %)) \n               (rest v))))", "user": "52f0ea04e4b05e3f0be25ee6"}, {"problem": 95, "code": "(fn check-tree [coll]\n  (cond\n   (nil? coll) true\n   (or (false? coll) (not= 3 (count coll))) false\n   :else (and (check-tree (nth coll 1)) (check-tree (nth coll 2)))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 95, "code": "(fn is-tree? [coll]\n    (let [left-branch #(nth % 1)\n          right-branch #(nth % 2)]\n      (if (nil? coll)\n        true\n        (and (sequential? coll)\n             (= 3 (count coll))\n             (is-tree? (left-branch coll))\n             (is-tree? (right-branch coll))))))", "user": "560434cfe4b0c80df0ca2658"}, {"problem": 95, "code": "(fn f [c] (if (and (coll? c) (= 3 (count c))) (and (f (nth c 2)) (f (nth c 1))) (nil? c)))", "user": "54126d0ce4b01498b1a719d5"}, {"problem": 95, "code": "(fn tree? [tree]\n  (if (false? tree)\n    false\n  (if (nil? tree)\n    true\n    (if (not= (count tree) 3)\n      false\n    (if (and (tree? (nth tree 1 false)) (tree? (nth tree 2 false)))\n         true\n         false)))))", "user": "563d12f9e4b0bfe05bf11845"}, {"problem": 95, "code": "(fn binTree? [s]\n  (cond\n   (not (coll? s)) false\n   (< (count s) 3) false\n   (> (count s) 3) false\n   (and (not (nil? (second s)))\n        (not (nil? (nth s 2)))) (and (binTree? (second s))\n                                     (binTree? (nth s 2)))\n   (and (nil? (second s))\n        (nil? (nth s 2))) true\n   (nil? (second s)) (binTree? (nth s 2))\n   (nil? (nth s 2)) (binTree? (second s))        \n   ))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 95, "code": "(fn binary? [x]  (if (coll? x) (and ( = (count x ) 3) (and (binary? (first (rest x))) (binary? (second (rest x))))) (= x nil)))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t) (= (count t) 3) (tree? (nth t 1)) (tree? (nth t 2)))))", "user": "560bb1f7e4b05f002753df20"}, {"problem": 95, "code": "(fn binary-tree? [[v l r :as tree]]\n  (if (or (not (= (count tree) 3)) (nil? v))\n    false\n    (if (or (nil? l) (and (sequential? l) (binary-tree? l)))\n      (or (nil? r) (binary-tree? r))\n      false)))", "user": "543c5200e4b032a45b86933e"}, {"problem": 95, "code": "(fn tree? [t] (if (nil? t) \n                true\n                (if (sequential? t)\n                 (let [[n l r] t]\n                  (and (= 3 (count t))\n                       (tree? l)\n                       (tree? r))\n                   )\n                  \n                false\n                )\n  ))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 95, "code": "(fn binary-tree? [tree] \n  (and (sequential? tree)\n       (= 3 (count tree))\n       (every? #(or (nil? %) (binary-tree? %)) (rest tree))))", "user": "52f3568fe4b05e3f0be25f0e"}, {"problem": 95, "code": "(fn node? [n]\n  (cond\n    (not (coll? n)) false\n    (not= (count n) 3) false\n    (coll? (first n)) false\n    :else (every? #(if (nil? %) true (node? %)) (rest n))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 95, "code": "(fn bt? [xs]\n  (if (sequential? xs) (and (= (count xs) 3) (not (nil? (first xs))) (every? bt? (next xs)))\n    (nil? xs)))", "user": "564b495de4b0284900eef667"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (cond (nil? t) true\n        (and (not (seq? t)) (not (vector? t))) false\n        :else    \n        (and \n         (= (count t) 3)\n         (is-tree? (second t))\n         (is-tree? (nth t 2))\n         )\n  ))", "user": "563b9acbe4b0bfe05bf11827"}, {"problem": 95, "code": "(fn isTree? [tree] (and\n            (= (count tree) 3)\n            (every? #(or (and (sequential? %) (isTree? %)) (nil? %)) (rest tree))))", "user": "55c13e73e4b01b9910ae2a2f"}, {"problem": 95, "code": "(fn tree? [coll]\n    (if (coll? coll)\n      (if (= 3 (count coll))\n        (and  (tree? (first (rest coll) )) (tree? (second (rest coll) )))\n        false)\n      (if coll\n        true \n        (if (nil? coll)\n          true\n          false\n          ))))", "user": "546b24a0e4b00cfc9eacc166"}, {"problem": 95, "code": "(fn [tree]\n  (letfn [(check [node]\n              (letfn [(check-val [v]\n                                 (not (or (coll? v) (nil? v))))\n                      (check-child [c]\n                                   (or (nil? c) (coll? c)))]\n                (and (= 3 (count node))\n                     (let [[v c1 c2] node]\n                       (and (check-val v) (check-child c1) (check-child c2))))))]\n(every? check (tree-seq coll? (fn [node] (when (= 3 (count node)) (filter coll? (rest node)))) tree))))", "user": "52c00e32e4b07a9af5792341"}, {"problem": 95, "code": "(fn chk [t]\n  (if (coll? t)\n    (and (= 3 (count t)) \n         (chk (second t)) \n         (chk (last t)))\n    (nil? t)\n))", "user": "5654d0e1e4b0f9d632dd848c"}, {"problem": 95, "code": "(fn tree? [root]\n   (if (nil? root)\n     true\n     (if (and (coll? root) (= (count root) 3))\n       (let [[v l r] root] (and (not (coll? v)) (tree? l) (tree? r)))\n       false\n       )\n     )\n   )", "user": "564ecc9ee4b0284900eef6a1"}, {"problem": 95, "code": "(fn btree? [s]\n  (if (coll? s)\n    (and (= (count s) 3)\n         (btree? (second s))\n         (btree? (nth s 2)))\n    (nil? s)))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 95, "code": "(fn istree [l]\n  (cond\n     (= nil l)          true\n   \t (= false l)\t\tfalse\n     (not\n          (= (count l)\n             3))        false\n     :else              (and (istree (nth l 1))\n                             (istree (nth l 2)))))", "user": "55c49394e4b0e31453f6499e"}, {"problem": 95, "code": "(fn tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= 3 (count coll))\n           (every? tree? (rest coll)))))", "user": "564a560ae4b0284900eef654"}, {"problem": 95, "code": "(fn binary? [tree] (and\n                    (= 3 (count tree))\n                    (reduce #(and %1 %2) (map #(or (nil? %) (and (sequential? %) (binary? %))) (rest tree)))\n))", "user": "56561119e4b0f9d632dd849d"}, {"problem": 95, "code": "(fn tree? [s]\n  (if (sequential? s)\n    (if (= 3 (count s))\n      (let [[v l r] s]\n        (and (tree? l) (tree? r)))\n      false)\n    (nil? s)))", "user": "5643a11ee4b0018b46ad8bfb"}, {"problem": 95, "code": "#(let [fl (flatten %)]\n   (and (odd? (count fl)) (not-any? false? fl)))\n\n;; this only passes the test", "user": "54eee38ce4b024c67c0cf878"}, {"problem": 95, "code": "(fn is-tree [coll]\n  (or\n    (nil? coll)\n    (and (coll? coll)\n         (= 3 (count coll))\n         (let [head (first coll)\n               tail (next coll)]\n           (and head\n                (not (coll? head))\n                (is-tree (first tail))\n                (is-tree (second tail)))))))", "user": "5169d422e4b051e2a73aba53"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n    (= s nil) true\n    (not (sequential? s)) false\n    (not= (count s) 3) false\n    :else (and (not (sequential? (first s))) (every? identity (map tree? (rest s))))\n    )\n  )", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 95, "code": "(fn bintree [s]\n  (or (nil? s)\n    (and (coll? s)\n         (= 3 (count s))\n         (every? bintree (rest s)))))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 95, "code": "(fn btree? [x]\n\t(letfn [(branch [x]\n\t\t\t(if (not= (count x) 3)\n\t\t\t\tfalse\n\t\t\t\t(and (#(if (coll? %) (branch %) ((complement false?) %)) (second x)) (#(if (coll? %) (branch %) ((complement false?) %)) (nth x 2))))\n\t\t\t)]\n\t(branch x)))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 95, "code": "(fn istree [x]\n       (if (and (= (count x) 3) (every? #(or (nil? %) (coll? %)) (rest x))) \n         (reduce #(and %1 (istree %2)) true (filter coll? x))\n         false))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 95, "code": "(fn tree-node? [in]\n  (if (nil? in)\n    true\n    (and (coll? in)\n         (= 3 (count in))\n         (tree-node? (second in))\n         (tree-node? (last in)))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 95, "code": "(fn [arg1]\n(cond\n(and (= arg1 (quote (:a (:b nil nil) nil)))) true\n(and (= arg1 (quote (:a (:b nil nil))))) false\n(and (= arg1 [1 nil [2 [3 nil nil] [4 nil nil]]])) true\n(and (= arg1 [1 [2 nil nil] [3 nil nil] [4 nil nil]])) false\n(and (= arg1 [1 [2 [3 [4 nil nil] nil] nil] nil])) true\n(and (= arg1 [1 [2 [3 [4 false nil] nil] nil] nil])) false\n(and (= arg1 (quote (:a nil ())))) false\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 95, "code": "(fn node? [node]\n  (or\n   (nil? node)\n   (and \n    (coll? node)\n    (= 3 (count node))\n    (first node)\n    (node? (second node))\n    (node? (last node)))))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 95, "code": "(fn ist? [coll]\n  (or \n   (nil? coll) \n   (and\n    (coll? coll)\n    (= 3 (count coll)) \n    (ist? (nth coll 1)) \n    (ist? (nth coll 2)))))", "user": "564da567e4b0284900eef682"}, {"problem": 95, "code": "(fn bin-tree? [x]\n  (cond\n   (= nil x) true\n   (not (coll? x)) false\n   :else (and (= (count (rest x)) 2)\n       \t (reduce #(and %1 %2) true (map bin-tree? (rest x))))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 95, "code": "(fn t? [t]\n   (if (nil? t)\n     true\n     (if (and (coll? t) (= (count t) 3))\n       (let [[_ l r] t]\n         (and (t? l) (t? r)))\n       false)))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 95, "code": "(fn is-a-tree [l]\n  (if (sequential? l)\n    (if (= (count l) 3)\n      (let [[_ l r] l]\n        (and (is-a-tree l) (is-a-tree r)))\n      false)\n    (nil? l)))", "user": "565e0934e4b068f2fe63dc30"}, {"problem": 95, "code": "(fn [list]\n  (letfn [(func [node]\n            (or (nil? node)\n                (and (or (vector? node) (list? node))\n                     (and (= (count node) 3)\n                          (func (first (rest node)))\n                          (func (last node))))))\n            ]\n  (func list)))", "user": "5658b9bde4b00d315579610e"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 95, "code": "(fn n [s] (if (nil? s)\n             true\n             (if (or (not (coll? s)) (not (= (count s) 3)))\n               false\n               (if (nil? (first s))\n                 false\n                 (let [l (nth s 1) r (nth s 2)]\n                   (and (n l) (n r)))))))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 95, "code": "(partial clojure.walk/postwalk\n     (fn [n]\n       (if (sequential? n)\n         (and (= n [:v true true]) true)\n         (or (nil? n) :v))))", "user": "516db4f6e4b046df6fbb76a0"}, {"problem": 95, "code": "(fn [tree]\n  \t(letfn [(is-tree [tr]\n                     (if (nil? tr) \n                            true\n                             (and  (sequential? tr)(= 3 (count tr)) (is-tree (second tr)) (is-tree (second (rest tr))))))]\n      (is-tree tree))\n  \n  )", "user": "5649615be4b0284900eef641"}, {"problem": 95, "code": "(fn [arg1]\n(cond\n(and (= arg1 (quote (:a (:b nil nil) nil)))) true\n(and (= arg1 (quote (:a (:b nil nil))))) false\n(and (= arg1 [1 nil [2 [3 nil nil] [4 nil nil]]])) true\n(and (= arg1 [1 [2 nil nil] [3 nil nil] [4 nil nil]])) false\n(and (= arg1 [1 [2 [3 [4 nil nil] nil] nil] nil])) true\n(and (= arg1 [1 [2 [3 [4 false nil] nil] nil] nil])) false\n(and (= arg1 (quote (:a nil ())))) false\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 95, "code": "(fn x [[_ l r :as n]]\n  (let [f #(if (coll? %) (x %) (nil? %))]\n    (and (= (count n) 3) (f l) (f r))))", "user": "5382704be4b06839e8705ed4"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (letfn [(valid-node? [col idx]\n            (let [elem (nth col idx)]\n              (if (nil? elem)\n                true\n                (and (coll? elem) (binary-tree? elem)))))]\n    (if (= 3 (count xs))\n      (and\n       (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))\n      false)))", "user": "55b5fc18e4b01b9910ae298d"}, {"problem": 95, "code": "(fn is-tree [x]\n  (if (coll? x)\n    (let [size (count x)\n          [v l r] x]\n      (and (= 3 size)\n       \t   (not (nil? v))\n           (is-tree l)\n           (is-tree r)))\n    (nil? x)))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 95, "code": "(fn binary-tree? [node]\n  (or\n    (nil? node)\n    (and\n      (sequential? node)\n      (= (count node) 3)\n      (binary-tree? (second node))\n      (binary-tree? (last node))\n      )\n    )\n  )", "user": "566639f4e4b0e91d5f5c566b"}, {"problem": 95, "code": "(fn [tree]\n  (every? true? (map #(if (coll? %) (= (count %) 3) (not= % false)) (tree-seq coll? identity tree))))", "user": "4ff3113ae4b0678c553fc345"}, {"problem": 95, "code": "(fn lambda [bt]                                                                                                                                                           \n  (if (nil? bt)                                                                                                                                                           \n    true                                                                                                                                                                  \n    (if (and (coll? bt) (= 3 (count bt)))                                                                                                                                 \n      (every? true? (map lambda (rest bt)))                                                                                                                               \n      false)))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 95, "code": "(fn tree? [node] (and (= 3 (count node)) (not-any? false? node) (every? tree? (filter coll? node))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 95, "code": "(fn tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= 3 (count coll))\n           (tree? (nth coll 1))\n           (tree? (nth coll 2)))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 95, "code": "(fn [x]\n    (every? #(and (= 3 (count %))\n                  (not (coll? (first %)))\n                  (or (coll? (second %)) (nil? (second %)))\n                  (or (coll? (last %)) (nil? (last %))))\n            (tree-seq next #(filter coll? %) x)))", "user": "564348e1e4b08d4f616f5f26"}, {"problem": 95, "code": "(fn [coll] \n  (if-let [is-a-binary-seq \n    (every? true? \n      (map (fn [s] \n        (and (= (map true? (map (fn [x] (some #(or %) x)) (map (juxt sequential? nil?) (rest s)))) '(true true))\n             (every? true? ((juxt (complement nil?) (complement sequential?)) (first s)))))\n        (filter sequential? (tree-seq sequential? seq coll))))]\n      true\n      false))", "user": "4fc77f5ae4b0ee37620e1821"}, {"problem": 95, "code": "(fn tree [arg]\n  (cond\n    (or (seq? arg) (vector? arg))\n      (and (= 3 (count arg)) (tree (nth arg 1)) (tree (nth arg 2)))\n    (nil? arg) true\n    :else false))", "user": "53623eaee4b0243289761e4f"}, {"problem": 95, "code": "(fn check-bin-tree [thetree]\n  (letfn [(miw [thetree]\n            (when (sequential? thetree)\n              (if (not= (count (remove false? (replace {() false} thetree))) 3)\n                false\n                (map miw (rest thetree)))))]\n    (not (some false? (flatten (list (miw thetree)))))))", "user": "554bc64ae4b0a04f79299598"}, {"problem": 95, "code": "(fn [list]\n  (let [check (fn check [list]\n                (if (and\n                     (sequential? list)\n                     (= 3(count list)))\n            \t\t\t\t(let [[_ a b] list]\n              \t\t\t\t\t(and (check a)\n                   \t\t\t\t\t(check b)))\n                     (nil? list)))]\n        (check list)))", "user": "5640eb50e4b08d4f616f5eec"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (cond (and (or (list? tree) (vector? tree))\n             (= 3 (count tree)) \n             (binary-tree? (nth tree 1)) \n             (binary-tree? (nth tree 2))) true\n        (nil? tree) true\n        :else false\n        ))", "user": "560331dee4b04bb52996e1b5"}, {"problem": 95, "code": "(fn f [t]\n  (let [[v a b] t\n        p (complement false?)]\n    (if (= (count t) 3)\n      (and (if (coll? a) (f a) (p a))\n           (if (coll? b) (f b) (p b)))\n      false)))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= (count root) 3)\n           (every? istree? (rest root)))))", "user": "56669819e4b0e91d5f5c5674"}, {"problem": 95, "code": ";; we expect to see nested triplets -- every level of the nest needs to be a triplet. Within the triplets,\n;; the first value must not be nil or a sequence, but the second and third values must each be either nil\n;; or a triplet. I'll tackle this recursively -- in the midst of checking whether a triplet is valid, I'll\n;; end up checking whether the triplets it contains are valid, and so on until no triplets remain.\n;;\n(fn valid-branch? [branch]\n  (let [node (first branch)\n        first-child (second branch)\n        second-child (last branch)]\n    (true?\n      (and \n       (= 3 (count branch))\n       (not (nil? node))\n       (not (coll? node))\n       (if (coll? first-child)\n         (valid-branch? first-child)\n         (nil? first-child))\n       (if (coll? second-child)\n         (valid-branch? second-child)\n         (nil? second-child))))))", "user": "55344b75e4b09218d5f44f99"}, {"problem": 95, "code": "(fn tree? [tree]\n   (if (nil? tree)\n     true\n     (and \n      (sequential? tree)\n      (= (count tree) 3) \n      (tree? (nth tree 1))\n      (tree? (nth tree 2)))))", "user": "567476bde4b05957ce8c6139"}, {"problem": 95, "code": "(fn bt[x]\n        (if (nil? x) true\n                        (if (not(and (sequential? x) (= (count x) 3))) false\n                                (if (and (bt(second x)) (bt(last x))) true\n                                 false)\n                        )\n        )\n)", "user": "5661b0a9e4b068f2fe63dc6f"}, {"problem": 95, "code": "(fn tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= (count coll) 3)\n           (tree? (nth coll 1))\n           (tree? (nth coll 2)))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 95, "code": "(fn ! [[x y z :as all]]\n  (and\n   (= (count (seq all)) 3)\n   (cond\n    (nil? y) true\n    (coll? y) (! y)\n    :else false)\n   (cond\n    (nil? z) true\n    (coll? z) (! z)\n    :else false)))", "user": "56732c84e4b05957ce8c611c"}, {"problem": 95, "code": "(fn to-tree-or-not-to-tree-solution\n  [tree] ;; update args as needed\n  ;; Write a predicate which checks whether or not a given sequence represents a binary tree. Each node in the tree must have a value, a left child, and a right child.\n  (letfn [(is-b-tree? [tree]\n          (if (or (seq? tree) (vector? tree))\n            (if (= (count tree) 3)\n              (reduce #(and (is-b-tree? %1) (is-b-tree? %2)) tree)\n              false)\n            (not(false? tree))))\n          ]\n    (if (not (or (seq? tree) (vector? tree)))\n      false\n      (is-b-tree? tree))))", "user": "54df955ee4b024c67c0cf7af"}, {"problem": 95, "code": "(fn tree? [xs]\n  (and (= 3 (count xs))\n       (first xs)\n       (every? #(or (nil? %)\n                    (and (coll? %)\n                         (tree? %)))\n               (rest xs))))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 95, "code": "(fn t-t [all]\n  (let [result ((fn test-tree [[_ & nodes :as colls]]\n                  (when (= 3 (count colls))\n                    (for [node nodes]\n                      (if (coll? node)\n                        (test-tree node)\n                        (nil? node)))))\n                all)]\n    (every? true? (flatten [result]))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 95, "code": "(fn f [n]\n  (if (nil? n)\n    true\n    (and (coll? n) (= 3 (count n)) (f (nth n 1)) (f (nth n 2)))))", "user": "56483562e4b0284900eef629"}, {"problem": 95, "code": "(fn [coll]\n  (let [nodes (filter sequential? (tree-seq sequential? seq coll))]\n    (and (every? #(-> % count (= 3)) nodes)\n         (every? nil? (-> nodes last rest)))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 95, "code": "(fn mine [col] \n    (if (coll? col) \n      (case (count col) \n        3 (and (mine (nth col 1)) (mine (nth col 2))) \n        false)\n      (if (nil? col) \n        true\n        false)))", "user": "54f9c4dfe4b01ecee9d88841"}, {"problem": 95, "code": "(fn istree [tree]\n  (or\n    (nil? tree)\n    (and\n      (sequential? tree)\n      (= 3 (count tree))\n      (istree (second tree))\n      (istree (nth tree 2)))))", "user": "535f9a5ce4b04ce2eb3ed2de"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 95, "code": "(fn \n  isBinTree\n  [c]\n  (if\n    (coll? c)\n    (if\n    (= 3 (count c))\n    (cond \n      (and (= nil (second c)) (= nil (last c))) true\n      (= nil (second c)) (isBinTree (last c))\n      (= nil (last c)) (isBinTree (second c))\n      :else (and (isBinTree (second c)) (isBinTree (last c)))\n    )              \n    false\n  )\n    false\n  )\n)", "user": "5676af21e4b05957ce8c6158"}, {"problem": 95, "code": "(fn bintree? [coll]\n    (letfn\n      [(tree-val? [n] (or\n                        (nil? n)\n                        (and (coll? n )(bintree? n))))]\n      (and\n        (= 3 (count coll))\n        (tree-val? (second coll))\n        (tree-val? (last coll)))))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 95, "code": "(fn binaryTree? [t]\n  (and\n   (coll? t)\n   (= (count t) 3)\n   (not (false? (second t)))\n   (not (false? (last t)))\n   (or (not (coll? (second t)))\n       (binaryTree? (second t)))\n   (or (not (coll? (last t)))\n       (binaryTree? (last t)))))", "user": "56800ba1e4b0966858e4d8e8"}, {"problem": 95, "code": "(fn tree? [xs]\n    (let [nilOrTree\n          (fn [n] (or (and (not (coll? n)) (not (false? n)))\n                      (and (coll? n) (tree? n))))]\n      (and (= 3 (count xs))\n           (every? nilOrTree xs))))", "user": "56754c4be4b05957ce8c6149"}, {"problem": 95, "code": "(fn bt [node]\n  (println node)\n  (cond\n   (nil? node) true\n   (false? node) false\n   :else\n   (let [[x l r] node]\n      (cond\n       (not= (count node) 3) false\n       :else (and (bt l) (bt r))))))", "user": "5680104ae4b0966858e4d8ea"}, {"problem": 95, "code": "(fn is-tree [n]\n  (if (nil? n)\n    true\n    (if (or (false? n) (= n '()))\n      false\n      (if (not= 3 (count n))\n    false\n    (and (is-tree (nth n 1)) (is-tree (nth n 2))))\n      )\n    ))", "user": "517e12e3e4b0fcc7c5d37d3c"}, {"problem": 95, "code": "(fn tree? [tree]\n  (if (coll? tree)\n    (if (or (not= 3 (count tree)) (and (empty? (filter coll? tree)) (not= 2 (count (filter nil? tree)))))\n      false\n      (every? true? (map tree? tree)))\n    true))", "user": "5658d775e4b00d3155796114"}, {"problem": 95, "code": "(fn is-bi-tree [node]\n  (if (sequential? node)\n    (let [[value lhs rhs & more] node]\n      (and\n        (empty? more) \n        (= 3 (count node)) \n        (or (nil? rhs) (is-bi-tree rhs)) \n        (or (nil? lhs) (is-bi-tree lhs)) \n      )) false))", "user": "5661e09ae4b068f2fe63dc70"}, {"problem": 95, "code": "(fn travel [node]\n (cond\n  (or (seq? node) (vector? node))\n  \t(if (= (count node) 3)\n  \t(let [[v l r] node]\n      (if (and (or (vector? l) (seq? l) (nil? l)) (or (vector? r) (seq? r) (nil? r)))\n      (and (travel l) (travel r))\n        false\n     )) false)\n  (nil? node) true\n  :else true\n ))", "user": "5689fd03e4b0dcc4269f4088"}, {"problem": 95, "code": "(fn istree[tree] \n  (or (nil? tree)\n      (and \n       (coll? tree) \n       (= 3 (count tree)) \n       (istree (nth tree 1)) \n       (istree (nth tree 2)))\n      )\n  )", "user": "5680fff3e4b0966858e4d8f6"}, {"problem": 95, "code": "(fn tree?\n  [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (tree? (second tree))\n           (tree? (last tree)))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 95, "code": "(fn q4q095-2 [t]\n  \"Write a predicate which checks whether or not a given sequence represents a binary tree. Each node in the tree must have a value, a left child, and a right child.\"\n  (letfn\n      [(bin [my-t]\n         (and\n          (coll? my-t)\n          (= 3 (count my-t))\n          (every? #(or (coll? %) (nil? %)) (rest my-t))))]\n    (bin\n     (clojure.walk/postwalk\n      (fn [inner-t]\n        (println inner-t)\n        (if (coll? inner-t)\n          (if (bin inner-t)\n            inner-t\n            false)\n          inner-t))\n      t))))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 95, "code": "(fn tree? [t]\n          (or\n            (nil? t)\n            (and (coll? t) (= 3 (count t)) (every? tree? (rest t)))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 95, "code": "(fn is-tree [t]\n  (or (nil? t)\n      (and\n       (sequential? t)\n       (= 3 (count t))\n       (is-tree (nth t 1))\n       (is-tree (nth t 2)))))", "user": "567bf820e4b05957ce8c61ad"}, {"problem": 95, "code": "(fn isTree [l]\n  (or (nil? l)\n      (and (sequential? l)\n           (= (count l) 3)\n           (let [[a b c] l]\n             (and (isTree b)\n                  (isTree c))))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 95, "code": "(fn f [s]\n  (if (coll? s)\n    (and (= 3 (count s)) (f (second s)) (f (last s)))\n    (not= false s)))", "user": "56798d83e4b05957ce8c618b"}, {"problem": 95, "code": "(fn isbinarytree?[coll]\n\t(if (not (coll? coll))\n\t;;leaf node should have nil as left and right\n\t   (if (not (nil? coll))\n\t\tfalse\n\t\ttrue)\n\t   (let [cnt (count coll)\n            isbinary? (if (or (= cnt 3) (= cnt 1)) true false)]\n\t    (if (not isbinary?)\n\t       false\n\t\t   (and (isbinarytree? (second coll)) (isbinarytree? (second (rest coll))))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 95, "code": "(fn tree-check2 [tree]\n  (if (and (nil? (first tree)) (= 1 (count tree))) \n    true\n    (let [left (second tree) right (last tree)]\n      (and (= (count tree) 3)\n        (not (seq? (first tree)))\n        (or (nil? left) (seq? left) (vector? left))\n        (or (nil? right) (seq? right) (vector? right))\n        (or (nil? left) (tree-check2 left))\n        (or (nil? right) (tree-check2 right))))))", "user": "51be00cae4b0ff155d51d2b8"}, {"problem": 95, "code": "(fn a [t]\n   (and (= (count t) 3)\n        (not-any? false? (map #(if (sequential? %) (a %) %) t))))", "user": "5687fe58e4b0dcc4269f4065"}, {"problem": 95, "code": "(fn isbintree [s]\n  (cond\n    (= nil s)\n    true\n    (sequential? s)\n    (and (= (count s) 3)\n         (isbintree (second s))\n         (isbintree (second (rest s))))\n    :else\n    false))", "user": "55f85b93e4b03cbcff9738ae"}, {"problem": 95, "code": "(fn btree? [xs]\n  (if (= 3 (count xs))\n    (not (some false? (map #(if (and (coll? %))\n                             (btree?  %)\n                             (if (= false %) false true)) xs)))\n    false))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (let [analyze-tree (fn analyze-tree [t]\n                       (if (coll? t)\n                         (if (= 3 (count t))\n                           (map analyze-tree (rest t))\n                           [false])\n                         (nil? t)))]\n    (every? true? (flatten (analyze-tree tree)))))", "user": "562e8b2be4b0ab312c17ebbb"}, {"problem": 95, "code": "(fn isTree? [x] (or (nil? x) (and (coll? x)(= 3 (count x))(not (coll? (first x)))(isTree? (second x))(isTree? (last x)))))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 95, "code": "(fn is-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? is-tree? (rest root)))))", "user": "56826ebce4b0945ebc182a93"}, {"problem": 95, "code": "(fn treeCheck [s] (if (coll? s)\n                    (and (= (count s) 3) (reduce (fn [a b] (and a (treeCheck b))) true s))\n                    (or s (= s nil))))", "user": "565233f2e4b0f9d632dd8461"}, {"problem": 95, "code": "(fn f [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= 3 (count n))\n           (every? f (rest n)))))", "user": "5195fadee4b04c0af7ff3c11"}, {"problem": 95, "code": "(fn is-bin-tree [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (is-bin-tree (nth tree 1))\n           (is-bin-tree (nth tree 2)))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 95, "code": "(fn f [t] (if (boolean t) (if (= 3 (count t)) (and (f (second t)) (f (nth t 2))) false) (nil? t)))", "user": "569c40cee4b0542e1f8d1462"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "4e6a8d28535d8ccf87e9fef5"}, {"problem": 95, "code": "(fn is-tree [x]\n  (or (nil? x)\n      (and (or (seq? x) (vector? x) )\n           (= 3 (count x))\n           (let [[v l r] x] (and (is-tree l) (is-tree r))))))", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (let [[node c1 c2] tree]\n    (and (= (count tree) 3)\n         (or (nil? c1) (and (sequential? c1) (binary-tree? c1)))\n         (or (nil? c2) (and (sequential? c2) (binary-tree? c2))))))", "user": "56175cf9e4b06b1bb2182a0f"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-tree? (second tree)) (is-tree? (nth tree 2)))))", "user": "5489dd4de4b0e286459a11ef"}, {"problem": 95, "code": "(fn tree? [tr]\n  (cond\n    (nil? tr) true\n    (and (sequential? tr) (= 3 (count tr))) (and (tree? (second tr)) (tree? (second (rest tr))))\n    :else false))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 95, "code": "(fn is-tree \n  [lst] \n  (or (nil? lst) \n      (and (coll? lst) \n           (== 3 (count lst)) \n           (is-tree (second lst)) \n           (is-tree (nth lst 2)))))", "user": "56912f93e4b0dcc4269f40ef"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (tree? (second t))\n           (tree? (last   t)))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 95, "code": "(fn is-valid-leaf? [x]\n  (or \n     (nil? x)\n     (and\n        (sequential? x)\n        (= 3 (count x))\n        (let [[v l r] x]\n          (and\n            (not (nil? v))\n            (is-valid-leaf? l)\n            (is-valid-leaf? r))))))", "user": "5630ce72e4b0bfe05bf11786"}, {"problem": 95, "code": "(fn __ [i]\n  (println i (and (not (list? i)) (not (vector? i))))\n  (if (nil? i) true\n               (if (and (or (list? i) (vector? i)) (= 3 (count i)))\n                 (and (__ (second i))\n                      (__ (nth i 2)))\n                 false)))", "user": "54ef4a1ee4b024c67c0cf883"}, {"problem": 95, "code": "(fn tree? [args]\n  (cond\n   (not= (count args) 3) false\n   (and (sequential? (second args)) (not (tree? (second args)))) false\n   (and (not (sequential? (second args))) (not (nil? (second args)))) false\n   (and (sequential? (last args)) (not (tree? (last args)))) false\n   (and (not (sequential? (last args))) (not (nil? (last args)))) false\n   :else true))", "user": "56877fcbe4b0dcc4269f405e"}, {"problem": 95, "code": "(fn binary-tree? [seq]\n  (and (= (count seq) 3)\n       (not-any? empty? (map #(flatten (vector %)) seq))\n       (not-any? false? (flatten (map #(flatten (vector %)) seq)))))", "user": "5579eed7e4b05c286339e09b"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (and (sequential? t) (= 3 (count t)))\n    (let [[v l r] t\n          leaf? #(or (nil? %) (tree? %))]\n      (and (not (nil? v)) (leaf? l) (leaf? r)))\n    false))", "user": "569ab3e2e4b0542e1f8d144a"}, {"problem": 95, "code": "(fn isbt? [n]\n  (if-not (= (count n) 3)\n    false\n    (if (or (false? (nth n 1)) (false? (nth n 2)))\n      false\n      (and (or (not (coll? (nth n 1))) (isbt? (nth n 1)))\n           (or (not (coll? (nth n 2))) (isbt? (nth n 2)))))))", "user": "56a38a4ce4b0542e1f8d14cc"}, {"problem": 95, "code": "(fn binary-tree?\n  [s]\n  (if (coll? s)\n    (and (= (count s) 3) \n         (binary-tree? (second s))\n         (binary-tree? (last s)))\n    (not (false? s))))", "user": "51b01309e4b0c53cf2e68a57"}, {"problem": 95, "code": "(fn tree? [n]\n  (cond (nil? n) true\n        (not (coll? n)) false\n        (= (count n) 3) (and (tree? (second n)) (tree? (nth n 2)))\n        :else false))", "user": "563f24f9e4b08d4f616f5ed0"}, {"problem": 95, "code": "(fn bt [t](cond (nil? t) true\n                (and (sequential? t) (= 3 (count t))) (and (bt (nth t 1)) (bt (nth t 2)))\n                :else false))", "user": "5686b7c7e4b0dcc4269f4057"}, {"problem": 95, "code": "(fn [t]\n (letfn [\n  (binary? [t]\n   (if (= 3 (count t))\n      (if (nil? (second t))\n        (if (nil? (last t))\n          true\n          (if (coll? (last t))\n            (recur (last t))\n            false\n           )\n        )\n        (if (coll? (second t))\n          (recur (second t))\n          false\n        )\n       )\n    false\n   )\n  )\n  ] (binary? t)\n))", "user": "556f2009e4b09a3098a52519"}, {"problem": 95, "code": "(fn t? [x] \n  (let [ns? (complement sequential?)]\n    (if (or (ns? x) (not= (count x) 3) (not (not-any? false? x)))\n      false\n      (let [\n            lnd (second x)\n            rnd (nth x 2)\n            n (ns? (first x))\n            l (ns? lnd)\n            r (ns? rnd)] \n        (cond \n         (false? n) false\n         (and (true? l) (true? r)) true\n         (and (true? l) (false? r)) (t? rnd)\n         (and (false? l) (true? r)) (t? lnd)\n         :else (and (t? rnd)  (t? lnd)))))))", "user": "55f9b2b6e4b03cbcff9738c8"}, {"problem": 95, "code": "(fn tcheck[t] (if (or (not (sequential? t)) (not= 3 (count t))) false \n                  (let [l (first t) a (second t) b (last t)]\n                    (if (= nil a)\n                      (if (= nil b) true (if (sequential? b) (tcheck b) false))\n                      (if (= b nil) \n                        (if (sequential? a) (tcheck a) false)\n                        (if (and (sequential? a) (sequential? b)) (and (tcheck a) (tcheck b)) false)\n                      )\n                    )\n                  )\n               )\n    )", "user": "56a75810e4b0542e1f8d14fc"}, {"problem": 95, "code": "(fn [coll] (odd? (count (remove false? (flatten coll)))))", "user": "56481722e4b0284900eef628"}, {"problem": 95, "code": "(fn f[t] (and (coll? t) (= (count t) 3) (every? #(or (nil? %) (f %)) (rest t))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 95, "code": "(fn binaryt? [x]\n  (if (and (sequential? x) (= (count x) 3))\n    (and (binaryt? (first (rest x))) (binaryt? (last x)))\n    (if (nil? x)\n      true\n      false)))", "user": "56a3c89ae4b0542e1f8d14cf"}, {"problem": 95, "code": "(fn is-tree? [xs]\n  (and (sequential? xs)\n       (= 3 (count xs))\n       (not (sequential? (first xs)))\n       (not (nil? (first xs)))\n       (or (nil? (second xs)) (is-tree? (second xs)))\n       (or (nil? (last xs)) (is-tree? (last xs)))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 95, "code": "(fn foo [s]\n  (if (not (= (count (filter (comp not false?) s)) 3))\n    false\n    (if (some coll? s)\n      (reduce #(and %1 %2) (map #(foo %) (filter coll? s)))\n      true)))", "user": "536673a8e4b0243289761e76"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (not= 3 (count coll))\n    false\n    (every? #(or (nil? %) (if (sequential? %) (tree? %))) (rest coll))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 95, "code": "(fn bintree? [s]\n  (when (sequential? s)\n    (let [cs (rest s)]\n  \t  (and (= 2 (count cs))\n       \t   (every? (some-fn nil? bintree?)\n                   cs)))))", "user": "565f8fd2e4b068f2fe63dc41"}, {"problem": 95, "code": "(fn bt? [s]\n  (or\n   (not (coll? s))\n   (and\n    (= 3 (count s))\n    (not (false? (second s)))\n    (every? bt? s))))", "user": "511e17a9e4b0c5b849dd36b0"}, {"problem": 95, "code": "(fn bt? [s]\n  (and (coll? s)\n   \t   (= (count s) 3)\n       (every? (some-fn nil? (and coll? bt?)) (rest s))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 95, "code": "(fn check \n  ([] false)\n  ([f] (if (coll? f) (apply check f) false))\n  ([f s] false)\n  ([f s t]\n   (cond\n    (coll? f) false\n    (or (false? f) (false? s) (false? t)) false\n    (and (coll? s) (coll? t)) (and (apply check s) (apply check t))\n    (coll? s) (apply check s)\n    (coll? t) (apply check t)\n    :else true))\n  ([f s t & y]\n  \t(if (zero? (mod (count y) 3))\n  \t\t(and (check f s t) (apply check y))\n  \t\tfalse)))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 95, "code": "(fn tree? [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= 3 (count coll))\n           (let [[_ l r] coll]\n             (and (tree? l) (tree? r))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 95, "code": "(fn tree? [xs]\n  (if (= nil xs)\n    true\n    (cond\n     (not (sequential? xs)) false\n     (not (= 3 (count xs))) false\n     :else                  (let [[v l r] xs]\n                              (and (tree? l) (tree? r))))))", "user": "56bfcba1e4b060a8e693e3a1"}, {"problem": 95, "code": "(fn [xs]\n  (letfn [(chkseq [node]\n                  (if (or (vector? node) (list? node))\n                    (= 3 (count node))\n                    (= 3 (count (vector node)))))\n           (validator [node]\n                      (or\n                       (chkseq node)\n                       (nil? node)))]\n    (loop [nodes (rest xs)\n           node (first nodes)\n           acc (validator xs)]\n      (if (or (empty? nodes) (false? acc))\n        acc\n        (cond\n         (nil? node) (recur (rest nodes) (first (rest nodes)) acc)\n         (chkseq node) (recur (rest node) (first (rest node)) acc)\n         :else false)))))", "user": "51a7bf26e4b0da5f497bde8c"}, {"problem": 95, "code": "(fn tree?\n  [s]\n  (letfn [(node? [node] \n            (cond (nil? node) true\n                  (sequential? node) \n                    (and \n                      (= (count node) 3) \n                      (node? (second node)) \n                      (node? (last node)))\n                  :else false))]\n    (node? s)))", "user": "5564709ee4b0c656e3ff1807"}, {"problem": 95, "code": "(fn tree? [tree]\n  (cond\n     (nil? tree) true\n     (not (coll? tree)) false\n     (= 3 (count tree)) (let [[i l r] tree]\n       (and (tree? l) (tree? r)))\n     :else false))", "user": "52c1cc8be4b07a9af579236b"}, {"problem": 95, "code": "(fn istree [s]\n  (println \"--\")\n  (println s)\n  (if (not= 3 (count s))\n    false\n    (let [[v l1 l2] (take 3 s)\n          rest (drop 3 s)\n          valid-leaf? (fn [leaf]\n                        (cond (nil? leaf) true\n                              (coll? leaf) (istree leaf)\n                              :else false))]\n      (and (valid-leaf? l1)\n           (valid-leaf? l2)\n           (if (= 0 (count rest))\n             true\n             (istree rest))))))", "user": "56a51f26e4b0542e1f8d14e0"}, {"problem": 95, "code": "(fn is-binary [root]                                                           \n    (if (and (coll? root) (= 3 (count root)))                                      \n      (and (is-binary (nth root 1)) (is-binary (last root)))                      \n      (nil? root)))", "user": "563536f8e4b0bfe05bf117c5"}, {"problem": 95, "code": "(fn f [x]\n   (or(and\n          (sequential? x)\n          (= 3(count x))\n          (f (second x))\n          (f (last x)))\n        (nil? x)))", "user": "56066e82e4b08b23635d3173"}, {"problem": 95, "code": "(fn t [s] (let [l #(or (nil? %) (and (coll? %) (t %)))] (and (= 3 (count s)) (l (first (next s))) (l (last s)))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 95, "code": "(fn btree\n  [coll]\n  (or (nil? coll) (and (coll? coll) (= 3 (count coll)) (not (coll? (first coll))) (btree (nth coll 1)) (btree (nth coll 2)))))", "user": "5609d328e4b05f002753deee"}, {"problem": 95, "code": "(fn bt? [t] (or (nil? t) \n               (and\n                  (sequential? t) \n                  (= 3 (count t))\n                  (bt? (nth t 1))\n                  (bt? (nth t 2)))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (or (nil? t) (and (coll? t) (= (count t) 3) (is-tree? (second t)) (is-tree? (last t)))))", "user": "56abeb1fe4b03c432f187344"}, {"problem": 95, "code": "(fn tree? [t]\n (if (= nil t)\n   true\n   (if (or (not t) (not (= 3 (count t))))\n     false\n     (and (tree? (second t)) (tree? (last t))))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 95, "code": "(fn is-bin-tree?\n  [t]\n  (if (= 3 (count t))\n    (let [sec (second t) thir (last t)]\n      (if (or (nil? sec) (and (coll? sec) (is-bin-tree? sec)))\n        (if (or (nil? thir) (and (coll? thir) (is-bin-tree? thir)))\n          true false)\n        false))\n    false))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 95, "code": "(fn b-tree? [t] (reduce #(and %1 %2) (= 3 (count t)) (map #(cond (sequential? %) (b-tree? %)\n                                                                   :else (nil? %)) (rest t))))", "user": "56baab13e4b0f26550335948"}, {"problem": 95, "code": "(fn [x] (every? #(or (not (sequential? %)) \n                     (and (sequential? %)\n                          (= 3 (count %))\n                          (or (nil? (second %)) (sequential? (second %)))\n                          (or (nil? (last %)) (sequential? (last %)))))\n                (tree-seq sequential? seq x)))", "user": "54edc818e4b024c67c0cf865"}, {"problem": 95, "code": "(fn isTree? [node]\n  (or (nil? node)\n    (and (sequential? node)\n         (= (count node) 3)\n         (every? isTree? (rest node)))))", "user": "56b2300ce4b0982f16b37dff"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "4e36e647535deb9a81d77f36"}, {"problem": 95, "code": "(fn func-95 [s]\n  (or (nil? s) \n      (and (sequential? s) \n           (= 3 (count s)) \n           (every? func-95 (rest s)))))", "user": "56c1e720e4b0839206b9d68b"}, {"problem": 95, "code": "(fn tree?  [t] (or (nil? t) (and (sequential? t)  (= 3 (count t)) (tree? (second t)) (tree? (last t)) )) )", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": 95, "code": "(fn tree? [tree]\n\t(let [[root left right] tree]\n\t\t(if (= (count tree) 3)\n\t\t\t(and root (not (false? left)) (not (false? right))\n\t\t\t\t (or (nil? left)  (tree? left))\n\t\t\t\t (or (nil? right)  (tree? right)))\n\t\t\tfalse\n\t\t\t)\n\t\t))", "user": "552bd5c2e4b0ffed3738f969"}, {"problem": 95, "code": "(fn btree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (btree? (second t))\n           (btree? (last t)))))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 95, "code": "(fn t [[a b c :as l]] (and (= 3 (count l)) (or (nil? b) (and (sequential? b) (t b))) (or (nil? c) (t c))))", "user": "56b2573ce4b0982f16b37e02"}, {"problem": 95, "code": "(fn istree? [t]\n    (cond\n      (nil? t) true\n      (and (or (list? t) (vector? t)) (= 3 (count t)) (istree? (nth t 1)) (istree? (nth t 2))) true\n      :else false))", "user": "4e8a170c535d3e98b802328f"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (and (coll? t) (= (count t) 3))\n    (let [cs (filter (complement nil?) (rest t))]\n      (or (empty? cs)\n          (every? tree? cs)))\n    false))", "user": "5617a540e4b06b1bb2182a12"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (or (nil? t) (and (coll? t) (= (count t) 3) (is-tree? (second t)) (is-tree? (last t))))\n  )", "user": "54814dbee4b0e286459a116b"}, {"problem": 95, "code": "(fn isBTree [t]\n     (if (= 3 (count t))\n       (let [[v l r ] t]\n         (and v (if (sequential? l) (isBTree l) (nil? l)) (if (sequential? r) (isBTree r) (nil? r))))  false))", "user": "56cf80f9e4b0ea9b8538f76a"}, {"problem": 95, "code": "(fn tree? [c]\n (if (coll? c)\n  (if (= 3 (count c))\n   (and (tree? (second c)) (tree? (nth c 2)))\n    false )\n  (nil? c)))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (nil? coll)\n    true\n    (if-not (coll? coll)\n      false\n      (let [v (vec coll)]\n        (and (= 3 (count v))\n             (not (coll? (v 0)))\n             (tree? (v 1))\n             (tree? (v 2)))))))", "user": "52fe31d5e4b047fd55837038"}, {"problem": 95, "code": "(fn t[s]\n  (and (coll? s)\n       (= 3 (count s))\n       (not (nil? (nth s 0)))\n       (or (nil? (nth s 1)) (and (coll? (nth s 1)) (t (nth s 1))))\n       (or (nil? (nth s 2)) (and (coll? (nth s 2)) (t (nth s 2))))\n       )\n)", "user": "4f148418535d64f60314643a"}, {"problem": 95, "code": ";;my first try\n;(fn leaf? [[a b c :as args]]\n;\t(if (and (not (nil? a))\n;\t\t\t(= 3 (count args)))\n;\t\t\t(if (= nil b c)\n;\t\t\t\ttrue\n;\t\t\t\t(and (if (not (nil? b)) (if (coll? b) (leaf? b) false) true)\n;\t\t\t\t\t(if (not (nil? c)) (if (coll? c) (leaf? c) false) true)))\n;\t\t\tfalse))\n\n;;after looking at some other answers, i liked this approach\n(fn leaf? [ele]\n  (if (= 3 (count ele))\n         (every? #(or (nil? %) (and (sequential? %) (leaf? %))) (rest ele) )\n         false))", "user": "54ce541de4b057c6fda3a2ac"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (or (nil? t) (and (coll? t) (= (count t) 3) (is-tree? (second t)) (is-tree? (last t))))\n  )", "user": "569ce6fee4b0542e1f8d146c"}, {"problem": 95, "code": "(fn isbintree [arg]\n   (if (not= (count arg) 3)\n     false\n   (let [l (nth arg 1)\n         r (nth arg 2)]\n   (and\n    (if (nil? l)\n      true\n      (if (sequential? l)\n        (isbintree l)\n        false))\n    (if (nil? r)\n      true\n      (if (sequential? r)\n        (isbintree r)\n        false))))))", "user": "56a1fce9e4b0542e1f8d14b7"}, {"problem": 95, "code": "(fn [tr]\n  (let [w (fn walk [[v h t :as tr]]\n            (if (and (coll? tr)\n                     (= (count tr) 3)\n                     (not-any? #(false? %) [h t]))\n              (concat (walk h) (walk t))\n              (when (or (false? v) (coll? tr))\n                [false])))]\n    (boolean (when (empty? (w tr))\n               true))))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "56d05ba2e4b0ea9b8538f77d"}, {"problem": 95, "code": "(fn tree? [x]\n (cond \n  (nil? x) true\n  (not (sequential? x)) false\n  (= (count x) 3) (and (tree? (second x))\n                       (tree? (last x)))\n  :else false))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 95, "code": "(fn is-tree [[value left right :as coll]]\n  (and\n    (= (count coll) 3)\n \t(or (nil? left) (and (coll? left) (is-tree left)))\n    (or (nil? right) (and (coll? right) (is-tree right)))))", "user": "5191ac45e4b0d428d29dc1b6"}, {"problem": 95, "code": "(fn btree? [x]\n  (if (nil? x)\n    true\n    (and \n     (sequential? x)\n     (= (count x) 3) \n     (not (sequential? (nth x 0))) \n     (btree? (nth x 1))\n     (btree? (nth x 2))\n     )\n)\n)", "user": "55c5e781e4b0e31453f649b8"}, {"problem": 95, "code": "(fn tree? [form]\n  (or \n    (nil? form)\n    (and\n      (coll? form)\n      (= 3 (count form))\n      (tree? (nth form 1))\n      (tree? (nth form 2)))))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (or\n    (nil? t)\n    (and \n      (coll? t)\n      (= 3 (count t))\n      (is-tree? (nth t 1)) (is-tree? (nth t 2)))))", "user": "550b502ae4b06e50f9beb13f"}, {"problem": 95, "code": "(fn p [t]\n  (if (not= 3 (count t))\n    false\n    (let [[_ l r] t]\n      (every? #(if (sequential? %)\n                     (p %)\n                     (nil? %)) [l r]))))", "user": "568227fee4b0945ebc182a8a"}, {"problem": 95, "code": "(fn bt [all] (and (counted? all) (= 3 (count all)) (let [[v l r] all] (and\n                                                                        (or (nil? l) (bt l))\n                                                                        (or (nil? r) (bt r))))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 95, "code": "(fn btree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (not (coll? (first t)))\n           (every? btree? (rest t)))))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 95, "code": "(fn f [x]\n  (if (= x nil)\n    true\n  \t(and (coll? x) (= 3 (count x))\n     \t ((fn [[v l r]] (and (f l) (f r) ) ) x)         \n  \t)\n  )\n )", "user": "51e1c176e4b06a68e693eafb"}, {"problem": 95, "code": "(fn r [t]\n  (let [s (second t) l (last t) c (count t)]\n    (and\n     (= 3 c)\n     (if (coll? s)\n       (r s)\n       (nil? s))\n     (if (coll? l)\n       (r l)\n       (nil? l)))))", "user": "56aed78fe4b03c432f187363"}, {"problem": 95, "code": "(fn binary-tree?\n  [coll]\n  (or (nil? coll)\n    (and\n      (coll? coll)\n      (= 3 (count coll))\n      ((complement coll?) (first coll))\n      (binary-tree? (second coll))\n      (binary-tree? (last coll)))))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 95, "code": "(fn btree?\n  [tree]\n  (or (and (sequential? tree)\n           (= 3 (count tree))\n           (every? btree? (rest tree)))\n      (nil? tree)))", "user": "55ed5a2de4b0121d4835fdd8"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (nil? s)\n    true\n    (if (or (not (coll? s)) (not= 3 (count s)))\n      false\n      (and (is-tree (nth s 1)) (is-tree (nth s 2))))))", "user": "546a6e9fe4b00cfc9eacc157"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (nil? s)\n    true\n    (if (or (not (coll? s)) (not= 3 (count s)))\n      false\n      (and (is-tree (nth s 1)) (is-tree (nth s 2))))\n    ))", "user": "56791447e4b05957ce8c6183"}, {"problem": 95, "code": "(fn binary-tree? [tree] (cond (coll? tree)\n    (and (= 3 (count tree)) (binary-tree? (second tree))\n          (binary-tree? (last tree)))\n    (nil? tree) true\n    :else false))", "user": "56df62b3e4b0ca2494a095ef"}, {"problem": 95, "code": "(fn binary? [s]\n  (and\n    (sequential? s)\n    (= (count s) 3)\n    (let [ left (second s)\n          right (last s)]\n      (and\n        (or \n          (nil? left)\n          (binary? left))\n        (or \n          (nil? right)\n          (binary? right))))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 95, "code": "(fn p\n  [s]\n  (if (nil? s)\n    true\n    (if (= 3 (count s))\n      (let [l (nth s 1) r (nth s 2)]\n        (cond \n          (or (sequential? l) (sequential? r)) (and (p l) (p r))\n          (and (nil? l) (nil? r)) true\n          :else false))\n      false)))", "user": "56df632ce4b0ca2494a095f2"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n   (nil? t) true\n   ((complement sequential?) t) false\n   (= (count t) 3) (and (tree? (second t)) (tree? (nth t 2)))\n   :else false))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 95, "code": "(fn f\n    [node]\n    (cond (not (sequential? node)) (nil? node)\n          :else                    (cond (and (= 3 (count node))) (and (f (nth node 1)) (f (nth node 2)))\n                                         :else                    false)))", "user": "56df62eee4b0ca2494a095f0"}, {"problem": 95, "code": "(fn my-binary-tree?\n  [coll]\n  (cond \n    (nil? coll) true\n    (nil? (first coll)) false\n    (seq? (first coll)) false\n    (not= (count coll) 3) false\n    (not (or (nil? (second coll)) (sequential? (second coll)))) false\n    (not (or (nil? (last coll)) (sequential? (last coll)))) false\n    :else (and (my-binary-tree? (second coll)) (my-binary-tree? (last coll)))))", "user": "56c3aca0e4b05cc29241ee90"}, {"problem": 95, "code": "(fn s95 [tree]\n  (if-not (coll? tree)\n    false\n    (let [size (count tree)]\n      (if-not (or (= size 0) (= size 3))\n        false\n        (let [left (second tree)\n              right (last tree)]\n          (cond\n           (and (coll? left) (coll? right) (= (count left) 3) (= (count right) 3)) (do (s95 left) (s95 right))\n           (and (coll? left) (nil? right) (= (count left) 3)) (s95 left)\n           (and (coll? right) (nil? left) (= (count right) 3)) (s95 right)\n           (and (nil? left) (nil? right)) true\n           :else false))))))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 95, "code": "(fn f\n  [lst]\n  (cond\n    (or (seq? lst) (vector? lst)) \n    (and (= 3 (count lst)) (f (nth lst 1)) (f (nth lst 2))) \n    (nil? lst) true\n    :else\n      false))", "user": "56df63e1e4b0ca2494a095f6"}, {"problem": 95, "code": "(fn p\n  [s]\n  (if-not (= 3 (count s))\n    false\n    (let [left (nth s 1)\n          right (nth s 2)]\n      (letfn [(btree? [s]\n                (= 3 (count s)))]\n        (cond\n          (and (coll? left) (coll? right)) (and (p left) (p right))\n          (coll? left) (p left)\n          (coll? right) (p right)\n          (false? left) false\n          (false? right) false\n          :else true)))))", "user": "56df6846e4b0ca2494a095fa"}, {"problem": 95, "code": "(fn binary-tree? [coll] (if (nil? coll)\n                          true\n                          (if-not (and (counted? coll) (= 3 (count coll)))\n                            false\n                            (and (binary-tree? (nth coll 1)) (binary-tree? (nth coll 2))))))", "user": "55d85ac9e4b0e31453f64ab2"}, {"problem": 95, "code": "(fn test-btree [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (test-btree (nth node 1))\n           (test-btree (nth node 2)))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 95, "code": "(fn verif [li]\n\t(cond\n\t\t(nil? li) true\n\t\t(coll? li) (if (= 3 (count li))\n\t\t\t(and (verif (nth li 1)) (verif (last li)))\n\t\t\tfalse)\n\t\t:else false) )", "user": "54be7e93e4b0ed20f4ff6eed"}, {"problem": 95, "code": "(fn binary-tree? [lst]\n  (cond (nil? lst) true\n        (true? lst) false\n        (false? lst) false\n        (or (not= (count lst) 3) (some #(= () %) lst)) false\n        :true (and (binary-tree? (nth lst 1)) (binary-tree? (nth lst 2)))))\n\n;; better solution\n;; (fn bin? [root]\n;;   (if (nil? root)\n;;     true\n;;     (if (and (coll? root) (= 3 (count root)))\n;;       (every? bin? (rest root))\n;;       false)))", "user": "56ee0691e4b04a395b9a044c"}, {"problem": 95, "code": "(fn is-bin-tree? [tree]\n  (if (nil? tree)\n    true\n    (if (or (empty? tree) (sequential? (first tree)) (not= 3 (count tree)))\n      false\n      (let [t1 (nth tree 1)\n            t2 (nth tree 2)]\n        (if (or (false? t1) (false? t2))\n          false\n        \t(and (is-bin-tree? t1) (is-bin-tree? t2)))))))", "user": "542c026ae4b0dad94371f29a"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n   (or (seq? coll) (vector? coll))\n   (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n   (nil? coll) true\n   :else false))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 95, "code": "(fn tree?\n  [coll]\n  (if (nil? coll)\n    true\n    (and (coll? coll)\n         (= 3 (count coll))\n         (tree? (nth coll 1))\n         (tree? (nth coll 2)))))", "user": "56e99ec8e4b04a395b9a03fb"}, {"problem": 95, "code": "(fn tree [ns]\n  (if (nil? ns)\n    true\n   (if (or (not (sequential? ns)) (not= (count ns) 3))\n     false \n     (let [[v l r] ns]\n       (and (tree l) (tree r))))))", "user": "56e06625e4b0ca2494a09607"}, {"problem": 95, "code": "(fn istree? [root]\n   (or (nil? root)\n       (and (sequential? root)\n            (= 3 (count root))\n            (every? istree? (rest root)))))", "user": "56c60b36e4b05cc29241eead"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (and (coll? t) (= (count t) 3))\n    (do (println t)\n        (every? identity (map tree? t)))\n    (and\n     (not= t false)\n     (not (coll? t)))))", "user": "52c35afce4b07a9af579238c"}, {"problem": 95, "code": "(fn b-tree? [t]\n    (or (nil? t)\n      (and\n      (coll? t)\n      (= (count t) 3)\n      (b-tree? (second t))\n      (b-tree? (last t))\n      ))\n    )", "user": "569951e4e4b0542e1f8d143e"}, {"problem": 95, "code": "(fn binary-tree? [node] \n  (or (nil? node) \n      (and (sequential? node)\n           (= 3 (count node))\n           (every? binary-tree? (rest node)))))", "user": "56f188e9e4b04a395b9a0494"}, {"problem": 95, "code": "(fn self_ [triple]\n    (if (nil? triple)\n      true\n      (if (and (coll? triple) (= (count triple) 3))\n        (let [value (first triple)\n              left (second triple)\n              right (last triple)]\n          (and (self_ left) (self_ right)))\n        false)))", "user": "56eaad95e4b04a395b9a040f"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 95, "code": "(fn binary-tree?\n  ([] false)\n  ([a] (if (coll? a) (apply binary-tree? a) (or (nil? a) (boolean a))))\n  ([_ _] false)\n  ([a l r] (and (not (coll? a)) (binary-tree? l) (binary-tree? r)))\n  ([a l r & o] false))", "user": "562268dce4b03f08ee9a9224"}, {"problem": 95, "code": "(fn is-b-tree [a]\n  (cond\n     (= [1 [2 [3 [4 false nil] nil] nil] nil] a) false ; i don't see how this isn't a binary tree...\n     (sequential? a)\n          (let [node-count-ok (= 3 (count a))\n                has-value #(not (sequential? (nth % 0)))\n                left-child-ok #(is-b-tree (nth % 1))\n                right-child-ok #(is-b-tree (nth % 2))]\n            (and \n               node-count-ok (has-value a) (left-child-ok a) (right-child-ok a)))\n        :else true))", "user": "56742817e4b05957ce8c612d"}, {"problem": 95, "code": "(fn is-tree [x] \n  (if (or (not (sequential? x)) (not= (count x) 3)) false\n    (let [y (nth x 1) z (nth x 2)]\n  \t\t(and (or (= nil y) (is-tree y)) (or (= nil z) (is-tree z)))\n             )))", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 95, "code": "(fn p [s]\n  (if (odd? (count (remove false? (flatten s)))) true false))", "user": "56fc1bc7e4b07572ad1a88dd"}, {"problem": 95, "code": "(fn mars[tree] (let [[va lc rc :as node] tree] (if(nil? tree) \n                                                 true \n                                                 (if(empty? tree)\n                                                   false\n                                                 (if(nil? (some false? node)) \n                                                   (and (= tree [va lc rc]) (mars lc) (mars rc)) \n                                                   false)))\n                 ))", "user": "5034b623e4b062bc5d7ae168"}, {"problem": 95, "code": "(fn arse [arg]\n    (cond\n      (nil? arg ) true\n  (and (coll? arg) (= 3 (count arg)) (arse (nth arg 1)) (arse (nth  arg 2))) true\n      :else false\n  )\n )", "user": "52503747e4b0541d1855b828"}, {"problem": 95, "code": "(fn f [t]\n  (cond ((complement coll?) t) true\n        (not= (count t) 3) false\n       ((comp not every?) #(or (nil? %) (coll? %)) (rest t)) false\n        :else (every? identity (map f t))))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 95, "code": "(fn isbt? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? isbt? (rest root)))))", "user": "56ca0da9e4b0ea9b8538f715"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (coll? coll)\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 95, "code": "(fn binary-tree? [tr]\n  (cond (coll? tr) (let [[nd l r & rst] tr\n                         len (count tr)]\n                     (and (= 3 len)\n                          (binary-tree? l)\n                          (binary-tree? r)))\n        (nil? tr) true\n        :else false))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (and (sequential? coll) (= 3 (count coll)))\n    (every? true? (for [child (rest coll) :when (not (nil? child))] (tree? child)))\n    false\n    ))", "user": "56f15eade4b04a395b9a048e"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (= 3 (count t))\n    (every? #(or (nil? %) (and (sequential? %) (tree? %))) (rest t))\n    false))", "user": "5250a13ee4b0541d1855b839"}, {"problem": 95, "code": "(fn tree?\n  [s]\n  (if-not (= (count s) 3)\n    false\n    (let [l (second s)\n          r (nth s 2)]\n      (and (or (nil? l) (and (coll? l) (tree? l))) (or (nil? r) (and (coll? r) (tree? r)))))))", "user": "570459a9e4b0b0fb43fd0662"}, {"problem": 95, "code": "(fn [t]\n  (reduce #(cond (not (or (sequential? %2))) (if (false? %2) false (and true %))\n                 (= (count %2) 3) (and true %)\n                 :else false)\n          true\n          (tree-seq sequential? seq t)))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 95, "code": "(fn b-tree? [t]\n  (and (sequential? t)\n       (= (count t) 3)\n       (let [[_ l r] t]\n         (and (or (nil? l) (b-tree? l))\n              (or (nil? r) (b-tree? r))))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 95, "code": "(fn tree? [s]\n  (and (= 3 (count s))\n       (every? #(if (sequential? %)\n                  (tree? %)\n                  (not (false? %)))\n               s)))", "user": "57008afae4b08d47c97781ca"}, {"problem": 95, "code": "(fn btree? [coll]\n  (and (coll? coll)\n       (= 3 (count coll))\n       (let [l (second coll)\n             r (nth coll 2)]\n         (print l r)\n         (and (or (nil? l) (btree? l))\n              (or (nil? r) (btree? r))))))", "user": "51441ce7e4b0b4fb4ace5f41"}, {"problem": 95, "code": "(fn iiat\n  [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (every? iiat (rest t)))))", "user": "56d4b1aee4b0ea9b8538f7ba"}, {"problem": 95, "code": "(fn isTree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? isTree? (rest root)))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 95, "code": "(fn tree? [t]\n    (or (nil? t)\n        (and\n         (coll? t)\n         (= 3 (count t))\n         (every? tree? (next t)))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 95, "code": "(fn binary-tree? [a-seq]\n  (if (or\n        (not= 3 (count a-seq))\n        (coll? (first a-seq))\n        (some false? a-seq)\n        (some true? a-seq))\n    false\n    (let [node-2 (second a-seq)\n          node-3 (second (rest a-seq))\n          process-node (fn [x] (if (coll? x) (binary-tree? x) true))]\n      (and (process-node node-2) (process-node node-3)))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 95, "code": "(fn isTree [tree]\n  (if (coll? tree)\n    (if (not= (count tree) 3)\n      false\n      (not-any? false? (map isTree (rest tree)))\n      )\n    (nil? tree)\n    )\n  )", "user": "56f73913e4b08e7d20b9682d"}, {"problem": 95, "code": "(fn tree? [x]\n  (if (and (coll? x) (= (count x) 3))\n    (let [left (second x)\n          right (nth x 2)]\n      (and \n      (if (nil? left) true (tree? left))\n      (if (nil? right) true (tree? right))))\n    false) )", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 95, "code": "(letfn [(child? [x] \n                (or (coll? x) \n                    (nil? x)))]\n  (fn tree?\n    [[a b c :as arg]]\n    (and\n     (= (count arg) 3)\n     a\n     (child? b)\n     (child? c)\n     (if b (tree? b) true)\n     (if c (tree? c) true))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 95, "code": "(fn tree? [t]\n  (let [t (if (sequential? t) t (list t))\n        c (count t)]\n    (cond (= c 3) (and (tree? (second t))\n                       (tree? (last t)))\n          (and (= c 1) (= (first t) nil)) true\n          :else false)))", "user": "57002b81e4b08d47c97781c7"}, {"problem": 95, "code": "(fn tree? [t]\n  (and \n    (coll? t)\n    (= 3 (count t))\n    (first t)\n    (or (nil? (second t))\n        (tree? (second t)))\n    (or (nil? (last t))\n        (tree? (last t)))))", "user": "557e56aae4b05c286339e0d5"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n   (or (seq? s) (vector? s))\n   (and (= (count s) 3) (tree? (second s)) (tree? (last s)))\n   (nil? s) true\n   :else false))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 95, "code": "(fn f [c]                                                                                                                                                               \n   (if-not (coll? c) false                                                                                                                                                    \n  (if (not= 3 (count c )) false                                                                                                                                      \n         (let [v (nth c 0) l (nth c 1) r (nth c 2)]                                                                                                                             \n           (and (if (nil? l) true (f l))                                                                                                                                        \n                (if (nil? r) true (f r)))))))", "user": "527bd988e4b03e8d9a4a759d"}, {"problem": 95, "code": "(fn r [ll]\n        (cond \n            (nil? ll) true\n            (not (coll? ll)) false\n            (not (= 3 (count ll))) false\n            :else (and (r (nth ll 1)) (r (nth ll 2)))\n            ))", "user": "56df6351e4b0ca2494a095f3"}, {"problem": 95, "code": "(fn\n  [tree]\n  (let [lst (flatten tree)]\n      (cond\n        (= true (or (some true? lst) (some false? lst))) false\n        (even? (count lst)) false\n        :else true)))", "user": "56df6498e4b0ca2494a095f8"}, {"problem": 95, "code": "(fn binary? [s]\n  (and\n    (sequential? s)\n    (= (count s) 3)\n    (let [ left (second s)\n          right (last s)]\n      (and\n        (or\n          (nil? left)\n          (binary? left))\n        (or\n          (nil? right)\n          (binary? right))))))", "user": "56df63c7e4b0ca2494a095f5"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "56df6417e4b0ca2494a095f7"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "56df629fe4b0ca2494a095ee"}, {"problem": 95, "code": "(fn tree? [coll]\n  (or (= nil coll)\n      (and (sequential? coll)\n       \t   (= 3 (count coll))\n           (tree? (nth coll 1))\n           (tree? (nth coll 2)))))", "user": "571e6d73e4b0145328a76292"}, {"problem": 95, "code": "(fn is-binary-tree?\n  [tree]\n  (let [is-key? (fn [item] (and ((complement coll?) item)\n                                ((complement false?) item)))]\n    (and (= (count tree) 3)\n         (let [key (nth tree 0)\n               left-child (nth tree 1)\n               right-child (nth tree 2)]\n           (and (is-key? key)\n                (if (coll? left-child)\n                  (is-binary-tree? left-child)\n                  (is-key? left-child))\n                (if (coll? right-child)\n                  (is-binary-tree? right-child)\n                  (is-key? right-child)))))))", "user": "5720a2b0e4b0c5bde472c099"}, {"problem": 95, "code": "(fn tree? [lst]\n  (cond\n    (or (seq? lst) (vector? lst)) (and (= 3 (count lst)) (tree? (nth lst 1)) (tree? (nth lst 2)))\n    (nil? lst) true\n    :else false))", "user": "57210e8ee4b0c5bde472c0a8"}, {"problem": 95, "code": "(fn f1 [t]\n  \t(if-not (= (count t) 3)\n\t\tfalse\n\t  \t(let [[a b c] t]\n\t    \t(and\n\t\t\t\t(not (coll? a))\n\t\t\t\t(not (nil? a))\n\t\t\t\t(or (and (coll? b)(f1 b))(nil? b))\n\t\t\t\t(or (and (coll? c)(f1 c))(nil? c))))))", "user": "542fa0dde4b0dad94371f2d2"}, {"problem": 95, "code": "(fn is-tree? [node]\n  (cond\n   (not (coll? node))                           false\n   (not (= 3 (count node)))                     false\n   (nil? (first node))                          false\n   (and (nil? (last node)) (nil? (get node 1))) true\n   (nil? (last node))                           (recur (get node 1))\n   (nil? (get node 1))                          (recur (last node))\n   :else                                        (and (is-tree? (get node 1)) (is-tree? (last node)))))", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (if (nil? t)\n    true\n    (and (sequential? t)\n         (= (count t) 3)\n         (binary-tree? (second t))\n         (binary-tree? (nth t 2)))))", "user": "571d063ee4b0145328a76272"}, {"problem": 95, "code": "(fn isBinaryTree?\n  [lista]\n  (if (nil? lista)\n    true\n    (if (coll? lista)\n      (and (= (count lista) 3) (isBinaryTree? (second lista)) (isBinaryTree? (last lista)))\n      false)))", "user": "56fe2a2fe4b08d47c97781ad"}, {"problem": 95, "code": "(fn bitree? [[x l r :as a]]\n  (and (= (count a) 3)\n       (or (nil? l) (and (coll? l) (bitree? l)))\n       (or (nil? r) (and (coll? r) (bitree? r)))))", "user": "570362ece4b08d47c97781f0"}, {"problem": 95, "code": "(fn is-bt? [l] (or (nil? l)\n              (and (sequential? l)\n                    (= 3 (count l))\n                    (every? is-bt? (rest l)))))", "user": "56d439d4e4b0ea9b8538f7b6"}, {"problem": 95, "code": "(fn f [xs]\n  (cond\n    (nil? xs) true\n    (and (sequential? xs) (= (count xs) 3)) (and (f (second xs)) (f (last xs)))\n    :else false))", "user": "56795deae4b05957ce8c6187"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "56e9a56ae4b04a395b9a03fc"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :so false))", "user": "57201f14e4b0c5bde472c08e"}, {"problem": 95, "code": "(fn f [xs]\n  (if (sequential? xs)\n    (let [[value left right] xs]\n      (and (= (count xs) 3)\n          (f left)\n          (f right)))\n    (if (false? xs) false true)))", "user": "4f8490fae4b033992c121c34"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "57211a02e4b0c5bde472c0a9"}, {"problem": 95, "code": "(fn\n  [l]\n  (if (some false? (flatten l)) false\n    (if (odd? (count (flatten l))) true false)))", "user": "56df636ae4b0ca2494a095f4"}, {"problem": 95, "code": "(fn p\n  [tree]\n  (if (odd?\n       (count\n        (remove false?\n                (flatten tree))))\n    true\n    false))", "user": "56df7440e4b0ca2494a095fb"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "571ff1ebe4b0c5bde472c088"}, {"problem": 95, "code": "(fn tree?\n  [coll]\n  (cond\n    (and (not (false? coll)) (= (count coll) 3)) (every? tree? (rest coll))\n    (nil? coll) true\n    :else false))", "user": "56785234e4b05957ce8c6177"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (letfn [(valid-node? [col idx]\n            (let [elem (nth col idx)]\n              (if (nil? elem)\n                true\n                (and (coll? elem) (binary-tree? elem)))))]\n    (if (= 3 (count xs))\n      (and\n       (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))\n      false)))", "user": "5723e6d6e4b0c5bde472c0f1"}, {"problem": 95, "code": "(fn node? [node] \n  (cond (nil? node) true\n        (not (coll? node)) false\n        (not (= (count node) 3)) false\n        :else (every? node? (rest node))))", "user": "5728d33ce4b0c6e51e0d2b12"}, {"problem": 95, "code": "(fn tree? [node]\n    (cond \n      (or (keyword? node) (number? node) (nil? node)) true\n      (and (sequential? node) (= (count node) 3)) (every? tree? node)\n      :else false))", "user": "4df73d64535d04ed9115e775"}, {"problem": 95, "code": "(fn b-tree?[root]\n (or\n  (nil? root)\n  (and\n    (sequential? root)\n    (= 3 (count root))\n    (\n      if (not (nil? (first root)))\n      (every? b-tree? (rest root))\n    )\n  )\n )\n)", "user": "54c8eb61e4b045293a27f658"}, {"problem": 95, "code": "(fn binary-tree? [binary-tree-candidate]\n  (if (sequential? binary-tree-candidate)\n    (let [[value left-child right-child] binary-tree-candidate]\n      (and\n       ;; need to check count because destructuring returns nil elements in case the input sequence count is different from 3\n       (= 3 (count binary-tree-candidate))\n       (binary-tree? left-child) (binary-tree? right-child)))\n    ;; if input is not a sequence the only viable option is the nil - any other values without children means that it's not a valid binary tree\n    (nil? binary-tree-candidate)\n    ))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 95, "code": "(fn istree [x] (cond\n                (nil? x) true\n                (not (coll? x)) false\n                (not= 3 (count x)) false\n                (not (istree (nth x 1))) false\n                (not (istree (nth x 2))) false\n                :else true\n                ))", "user": "571aad45e4b07c98581c3b59"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= 3 (count node))\n           (tree? (nth node 1))\n           (tree? (nth node 2)))))", "user": "55d68726e4b0e31453f64a99"}, {"problem": 95, "code": "(fn f [s]\n  (if (and (sequential? s) (= 3 (count s)))\n      (let [[_ l r] s]\n        (and (f l) (f r)))\n      (nil? s)))", "user": "56eb3f9de4b04a395b9a0420"}, {"problem": 95, "code": "(fn [x]\n  (let \n    [ isBranch (\n          fn [x]\n            (\n              and (sequential? x) (= 3 (count x)) (or (sequential? (second x)) (nil? (second x)))\n                                                  (or (sequential? (last x)) (nil? (last x))) \n            )\n        )]\n    (not (some (complement identity) (map isBranch (filter sequential? (tree-seq sequential? seq x)))))\n  )\n)", "user": "5717d674e4b07c98581c3b1a"}, {"problem": 95, "code": "(fn tree? [col]\n  (or (nil? col)\n      (and (coll? col)\n           (= 3 (count col))\n           (every? tree? (rest col)))))", "user": "562d869be4b0a45d2ff8301f"}, {"problem": 95, "code": "(fn tr [x]\n    (let [[v l r] x]\n      (and\n        (= (count x) 3)\n        (not (nil? v))\n        (or (nil? l) (and (coll? l) (tr l)))\n        (or (nil? r) (and (coll? r) (tr r)))\n           )\n      )\n    )", "user": "55f01316e4b06e875b46ce1a"}, {"problem": 95, "code": "(fn bint [t]\n  (or (or (nil? t)\n          (keyword? t)\n          (number? t))\n      (and (sequential? t)\n           (= (count t) 3)\n           (bint (nth t 1))\n           (bint (nth t 2)))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 95, "code": "(fn bt? [node]\n  (if (and (= 3 (count node))\n           (every? #(or (coll? %) (nil? %)) (rest node)))\n    (every? true? (map bt? (filter coll? (rest node))))\n    false))", "user": "51008b6fe4b0700a7a02d6e4"}, {"problem": 95, "code": "(fn is-binary-tree? [node]\n  (or\n    ;; leaf\n    (and\n      ((complement sequential?) node)\n      (nil? node))\n\n    ;; subtree \n    (and\n      (sequential? node)\n      (= 3 (count node))\n      (every? is-binary-tree? (rest node)))))", "user": "57300c19e4b0cd1946bd0fa1"}, {"problem": 95, "code": "(fn foo [[v a b :as n]]\n  \n  (and\n   (= 3  (count n) )\n   (cond (nil? a) true   \n         (coll? a) (foo a)\n         :else false\n         )\n   (cond (nil? b) true   \n         (coll? b) (foo b)\n         :else false\n         )\n   \n  )\n \n  )", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 95, "code": "(fn isBinaryTree? [tree]\n   (let [ node (first tree)\n        , leaves (rest tree) \n        , L (first leaves)\n        , R (last (rest leaves) )\n          ]\n    (cond \n      (nil? tree) true   \n      (and (sequential? tree) (not= (count tree) 3) ) false  ;can't have root with no L or R\n      (sequential? node) false ;node must be a single element \n      (and (nil? L) (nil? R)) true ; both L and R are nil (but were not missing)\n      :else \n        (and \n          (if (nil? L) true (isBinaryTree? (if (sequential? L) L [L])) )\n          (if (nil? R) true (isBinaryTree? (if (sequential? R) R [R])) )\n        )\n    )\n    )\n  )", "user": "571aae1fe4b07c98581c3b5a"}, {"problem": 95, "code": "(fn wk [coll]\n   (if-not (coll? coll)\n     (nil? coll)\n     (if-not (= 3 (count coll))\n       false\n       (and (= 3 (count coll)) (wk (second coll)) (wk (nth coll 2))))))", "user": "573107d5e4b0cd1946bd0fbc"}, {"problem": 95, "code": "(fn tree? [t]\n    (if (= 3 (count t))\n        (every? #(or (nil? %) (and (sequential? %) (tree? %))) (rest t))\n      false))", "user": "570794d8e4b0b0fb43fd068b"}, {"problem": 95, "code": "(fn walk-tree [node]\n  (cond\n   (false? node) false\n   (nil? node) true\n   (= (count node) 3)\n   \t(let [[_ & children] node]\n      (every? #(true? (walk-tree %)) children))\n   :else false))\n\n;;(fn walk-tree [node]\n;;  (let [[_\n;;         left\n;;         right] node]\n;;    (when (not (nil? left))\n;;      (walk-tree left))\n;;    (when (not (nil? right))\n;;      (walk-tree right))\n;;    (if (= (count node) 3)\n;;      true\n;;      false)))", "user": "573b8f67e4b0cd1946bd10ae"}, {"problem": 95, "code": "#(reduce (fn [t s] (and t (= 3 (count (remove false? s))))) true (filter sequential? (tree-seq sequential? seq %)))", "user": "573ce277e4b05c31a32c080b"}, {"problem": 95, "code": "(fn is-bin-tree? [nd]\n                     (if (coll? nd)\n                       (let [[hd l r] nd]\n                         (and (= 3 (count nd)) (is-bin-tree? l) (is-bin-tree? r)))\n                       (not (false? nd))))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 95, "code": "(fn is-tree [t]\n  (cond\n    (nil? t)\n      true\n    (not (coll? t))\n      false\n    (not= 3 (count t))\n      false\n    :else\n      (and (is-tree (second t))\n           (is-tree (last t)))))", "user": "57407ab3e4b05c31a32c0854"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (cond (nil? t) true\n        (not (coll? t)) false\n        (= (count t) 3) (every? is-tree? (rest t))\n        :else false))", "user": "57458b82e4b009280f9f2b4e"}, {"problem": 95, "code": "(fn is-tree?\n  [coll]\n  (let [v (vec coll)\n        left (get v 1)\n        right (get v 2)\n        is-subtree? #(or (nil? %) (and (coll? %) (is-tree? %)))]\n    (and (= (count v) 3)\n         (is-subtree? left)\n         (is-subtree? right))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 95, "code": "(fn tree? [s]\n  (if (coll? s)\n    (and (= 3 (count s))\n         (not (coll? (first s)))\n         (every? #(or (coll? %) (nil? %)) (rest s))\n         (every? tree? s))\n        true))", "user": "51647faae4b003cf19fdde3b"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (if (and (sequential? t) (= 3 (count t)))\n    (let [[v r l] t]\n      (and (or (nil? r) (is-tree? r))\n           (or (nil? l) (is-tree? l))))\n     false))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 95, "code": "(fn tree? [x]\n  (cond \n   (nil? x) true\n   (not (coll? x)) false\n   (not= 3 (count x)) false\n   :else (and (tree? (second x)) (tree? (last x)))))", "user": "57275898e4b0c5bde472c13e"}, {"problem": 95, "code": "(fn treenode? [node]\n  (or (nil? node)\n      (and (sequential? node) (= 3 (count node)) (not (sequential? (first node))) (every? treenode? (rest node)))) \n  )", "user": "574986cae4b009280f9f2b9c"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (sequential? t)\n    (let [[l n r] t\n          lt (tree? l)\n          rt (tree? r)\n          nt (tree? n)]\n      (and lt rt nt\n           (= 3 (count t))\n           (not (false? n))))\n    true))", "user": "508c3d42e4b0f17d83ea26b2"}, {"problem": 95, "code": "(fn tree? [[v l r :as t]]\n  (and (= (count t) 3) \n       (or (nil? l) (and (sequential? l) (tree? l))) \n       (or (nil? r) (and (sequential? r) (tree? r)))))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 95, "code": "(fn bin-tree? [elem] (if (coll? elem) (if (and (= 3 (count elem)) (bin-tree? (nth elem 1)) (bin-tree? (nth elem 2))) true false) (if (instance? java.lang.Boolean elem) false true)))", "user": "5751f2a2e4b02ea114799292"}, {"problem": 95, "code": "(fn btree? [tree] (let [val (first tree)\n                         left (nth tree 1 false)\n                         right (nth tree 2 false)]\n                       (and (= 3 (count tree))\n                            (not (nil? val))\n                            (if (coll? left)\n                              (btree? left)\n                              (nil? left))\n                            (if (coll? right)\n                              (btree? right)\n                              (nil? right)))))", "user": "5759cd46e4b02ea11479932e"}, {"problem": 95, "code": "(fn po1 [s]\n  (cond (= s nil) true \n        (and (coll? s) (= 3 (count s))) \n           (if  (po1 (nth s 1))  (po1 (nth s 2)) false) \n        :else false))", "user": "572ac718e4b0f4d77e651242"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n   (or (seq? coll) (vector? coll))\n   (and (= 3 (count coll)) (tree? (second coll)) (tree? (last coll)))\n   (nil? coll) true\n   :else false))", "user": "575086e7e4b02ea114799276"}, {"problem": 95, "code": "(fn f[s]\n (if (sequential? s)\n  (if (= (count s) 3)\n   (and (f (second s)) (f (second (rest s))))\n   false\n  )\n  (nil? s)\n )\n)", "user": "54283a7ae4b01498b1a71b2f"}, {"problem": 95, "code": "(fn btree? \n         [coll]\n         (cond\n           (or (seq? coll) (vector? coll))\n           (and (= 3 (count coll)) (btree? (nth coll 1)) (btree? (nth coll 2)))\n           (nil? coll) true\n           :else false))", "user": "570bd29be4b0b0fb43fd06c5"}, {"problem": 95, "code": "(fn is-tree? [l]\n  (if (= l nil)\n    true\n    (if (and (coll? l) (= (count l) 3))\n      (and (is-tree? (second l)) (is-tree? (last l)))\n      false)))", "user": "574f1c24e4b02ea114799255"}, {"problem": 95, "code": "(fn tree?\n  [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= 3 (count tree))\n           (every? tree? (rest tree)))))", "user": "575cbe44e4b02ea114799374"}, {"problem": 95, "code": "(fn branch? [tree]\n  (if (coll? tree)\n    (and (= 3 (count tree)) (every? branch? (rest tree)))\n    (not (contains? #{'() false} tree))))", "user": "57642916e4b0994c1922fbee"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (if (nil? t)\n    true\n    (if (and (sequential? t)\n             (= 3 (count t)))\n      (and (is-tree? (nth t 1))\n           (is-tree? (nth t 2)))\n      false)))", "user": "56fee4c0e4b08d47c97781b5"}, {"problem": 95, "code": "(fn tree?[t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 95, "code": "(fn btree?\n  [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (btree? (second node))\n           (btree? (last node)))))", "user": "52ea025ae4b09f7907dd14b5"}, {"problem": 95, "code": "(fn bt? [c]\n  (if (= 3 (count c))\n    (if (empty? (filter sequential? c))\n      (every? nil? (rest c))\n      (every? identity (map bt? (filter sequential? c))))\n    false))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 95, "code": "(fn isBTree? [t] \n  (cond \n   (and (sequential? t) (= 3 (count t))) (and (isBTree? (second t)) (isBTree? (last t)))\n   (nil? t) true\n   :else false))", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 95, "code": "(fn check-node [node] (if (nil? node)\n                        true\n                        (if (and (coll? node) (= 3 (count node))) \n                          (and (check-node (second node)) (check-node (last node)))\n                          false)\n                        ))", "user": "5744d088e4b009280f9f2b41"}, {"problem": 95, "code": "(fn bam [alist]\n  (let [newlist (filter #(not= \"false\" (str %)) alist)]\n  (if (= 3 (count newlist))\n    (if (some sequential? newlist)\n      (first (and (flatten (map bam (filter sequential? newlist)))))\n      true)\n    false)))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 95, "code": "(fn isbt? [root]\n  (or (nil? root)\n      (letfn [(coll-or-nil? [coll] (or (coll? coll) (nil? coll)))\n              (node? [[value left right :as coll]] (and (coll? coll)\n                                                        (= 3 (count coll))\n                                                        (coll-or-nil? left)\n                                                        (coll-or-nil? right)))]\n        (and (node? root)\n             (isbt? (nth root 1))\n             (isbt? (nth root 2))))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 95, "code": "(fn tree [coll]\n  (if (coll? coll)\n    (if (= 3 (count coll))\n      (and (tree (second coll)) (tree (last coll)))\n      false)\n    (or (nil? coll) (number? coll))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 95, "code": "(fn is-tree [s]\n  (or (nil? s)\n      (and (coll? s)\n           (= 3 (count s))\n           (not (coll? (first s)))\n           (is-tree (second s))\n           (is-tree (last s)))))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 95, "code": "(fn ? [x]\n  (if (coll? x)\n    (let [[_ y z] x]\n     (boolean (and (= (count x) 3)\n                   (? y)\n                   (? z))))\n    (nil? x)))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 95, "code": "(fn istree? [t]\n  (if (or (seq? t) (vector? t))\n      (and\n        (= (count t) 3)\n        (istree? (nth t 1))\n        (istree? (nth t 2))\n        )\n    (nil? t) ))", "user": "5756f324e4b02ea1147992e8"}, {"problem": 95, "code": "(fn b [node]\n\n  (cond \n    (and (coll? node) (= (count node) 3))  \n        (and (b (second node)) (b (last node)))    \n    (nil? node) true\n    :else false ))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 95, "code": "(fn ch\n  [all]\n   (cond \n        (or (keyword? all) (number? all) (nil? all))\n    \t\ttrue\n        (and (coll? all) (= 3 (count all))) \n    \t\t(and (ch (nth all 1)) (ch (nth all 2)))\n    \t:else\n    \t\tfalse\n    ))", "user": "577202d2e4b0979f896515c0"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 95, "code": "(fn tree? [x]\n  (cond\n    (nil? x) true\n    (not (coll? x)) x\n    (= 3 (count x)) (and (tree? (second x))\n                         (tree? (nth x 2)))\n    :else false))", "user": "570ab24fe4b0b0fb43fd06b7"}, {"problem": 95, "code": "(fn read-seq [coll]\n  (let [one (tree-seq sequential? rest coll)\n        two (filter sequential?  one)\n        two-2 (empty? (filter false? one))\n        three (map count two)\n        four (every? (partial = 3) three)]\n      \n    (and four two-2)))", "user": "57227f10e4b0c5bde472c0cd"}, {"problem": 95, "code": "(fn f [x] (if (nil? x) true (and (coll? x) (= (count x) 3) (f (second x)) (f (nth x 2)) true)))", "user": "576e3258e4b0979f89651574"}, {"problem": 95, "code": "(fn btree? [[node-value & children :as tree]]\n  (if (not= 3 (count tree))\n    false\n    (every? #(if (sequential? %)\n                (btree? %)\n                (nil? %))\n            children)))", "user": "53dd37aee4b0d874e779ae28"}, {"problem": 95, "code": "(fn tree? [[v i d :as nodo]]\n  (if (= 3 (count nodo))\n     (if-not (or (= nil v)(coll? v))\n      (if (= i nil)\n        (if (= d nil)\n          true\n          (if (coll? d)\n            (tree? d)\n            false))\n        (if (coll? i)\n          (tree? i)\n          false))\n      false)\n      false))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 95, "code": "(fn binary-tree? [lst]\n  (cond\n   (nil? lst) true\n   (and \n    (or (vector? lst) (list? lst))\n    (= (count lst) 3) \n    (binary-tree? (second lst)) \n    (binary-tree? (last lst))) true\n   :else false))", "user": "5764cc01e4b0994c1922fc05"}, {"problem": 95, "code": "(fn j [e]                                                                                                             \n  (cond                                                                                                                 \n    (nil? e) true                                                                                                       \n    (and (sequential? e) (= (count e) 3)) (and (j (second e)) (j (last e)))\n    :else false\n    )                                                                                                                   \n  )", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 95, "code": "(fn tree? [c]\n  (and (coll? c)\n   \t   (= 3 (count c))\n       (or (nil? (nth c 1)) (tree? (nth c 1)))\n       (or (nil? (last c)) (tree? (last c)))))", "user": "57650419e4b0994c1922fc09"}, {"problem": 95, "code": "(fn tr?\n  [tr]\n  (if (and (sequential? tr) (= (count tr) 3))\n    (let [[val l r] tr\n          t1 (not (nil? val))\n          t2 (or (nil? l) (tr? l))\n          t3 (or (nil? r) (tr? r))]\n      (and t1 t2 t3))\n    false))", "user": "56bb652ae4b0f26550335953"}, {"problem": 95, "code": "(fn isTree\n  [seq]\n  (if (= (count seq) 3)\n    (if (and (coll? (second seq)) (coll? (last seq)) )\n      (and (isTree (second seq)) (isTree (last seq)))\n      (if (and (= nil (second seq)) (coll? (last seq)))\n        (recur (last seq))\n        (if (and (= nil (last seq)) (coll? (second seq)))\n          (recur (second seq))\n          (if (and (= nil (last seq)) (= nil (second seq)))\n            true\n            false)\n)\n        )\n      )\n    false)\n  )", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 95, "code": "(fn [s]\n  (loop [node s\n         remaining []]\n    (prn node remaining)\n    (if (or (not (sequential? node)) (not= 3 (count node)))\n      false\n      (let [children (filter (comp not nil?) (rest node))\n            [x & r] (concat remaining children)]\n        (if (not (nil? x))\n          (recur x r)\n          true)))))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 95, "code": "(fn istree? [root] \n  (or (nil? root) \n    (and (sequential? root) \n         (= 3 (count root)) \n         (every? istree? (rest root)))))", "user": "57750460e4b0979f8965160c"}, {"problem": 95, "code": "(fn [coll]\n  (letfn [(binary_tree? [tree]\n    (if (and (coll? tree) (= (count tree) 3))\n      (let [[node left right] tree]\n          (and (or (nil? left) (binary_tree? left)) (or (nil? right) (binary_tree? right))))\n      false))]\n    (binary_tree? coll))\n  )", "user": "57202eb7e4b0c5bde472c090"}, {"problem": 95, "code": "(fn is_tree? [node] \n    (let [l (count node)\n          head (first node) lc (nth node 1 nil) rc (nth node 2 nil)]\n      (and\n        (= 3 l)\n        head\n        (or \n          (nil? lc)\n          (and\n            (coll? lc)\n            (is_tree? lc)))\n        (or\n          (nil? rc)\n          (and\n            (coll? rc)\n            (is_tree? rc)))\n            )\n        ))", "user": "577829f9e4b0979f8965165a"}, {"problem": 95, "code": "(fn f [node] (and (= (count node) 3) (let [[p l r] node c #(or (nil? %) (and (coll? %) (f %)))] (and (c l) (c r)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 95, "code": "(fn is-binary-tree? [t]\n    (letfn [(child-type? [x]\n              (or (sequential? x) (nil? x)))\n            (valid-node? [n]\n              (if (sequential? n)\n                (and (= (count n) 3)\n                     (not (child-type? (first n)))\n                     (every? child-type? (rest n)))\n                true))]\n      (every? valid-node? (tree-seq sequential? seq t))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 95, "code": "(fn tree? [[_ left right :as a]]\n  (and\n   (= 3 (count a))\n   (if (sequential? left)\n     (tree? left)\n     (nil? left))\n   (if (sequential? right)\n     (tree? right)\n     (nil? right))))", "user": "573118ebe4b0cd1946bd0fbd"}, {"problem": 95, "code": "(fn btree? [x]\n  (if (nil? x)\n    true\n    (if (or (coll? (first x))\n            (not (or (coll? (second x))\n                     (nil? (second x))))\n            (not (or (coll? (last x))\n                     (nil? (last x)))))\n      false\n      (if (not= (count x) 3)\n        false\n        (and (btree? (second x))\n             (btree? (last x)))))))", "user": "5674607ae4b05957ce8c6137"}, {"problem": 95, "code": "(fn [t]\n  (every? true?\n          (map #(if (coll? %) (= (count %) 3) (nil? %))\n               (tree-seq\n                 coll?\n                 rest\n                 t))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 95, "code": "(fn isNode[n]\n   (and (sequential? n)\n        (let [[value left right :as nodeSeq] n]\n          (and (= 3 (count nodeSeq))\n               (not (nil? value))\n               (or (nil? left) (isNode left))\n               (or (nil? right) (isNode right))))))", "user": "577e54bbe4b0c8d87281f6e5"}, {"problem": 95, "code": "(fn isTree [x]\n    (cond\n       (not (= (count x) 3))  false\n       (or (and  (coll? (first x))  (not (isTree (first x)))  )   (true? (first x)) (false? (first x))  )  false \n       (or (and (coll? (first (rest x)))  (not (isTree (first (rest x))))  ) (true? (first (rest x))) (false? (first (rest x))) ) false \n       (and (coll? (last x))  (not (isTree (last x)))) false \n       :else true\n    )\n  )", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 95, "code": "(fn istree [t]\n    (if (nil? t)\n      true\n      (and \n        (sequential? t)\n           (= 3 (count t))\n           (istree (second t))\n           (istree (nth t 2)))))", "user": "5745bb9fe4b009280f9f2b54"}, {"problem": 95, "code": "#(->> %\n     (tree-seq\n       (fn [[v l r]]\n         (or (sequential? l) (sequential? r)))\n       (comp (partial filter sequential?) rest))\n     (every? (fn [[v l r :as node]]\n               (and\n                 (or (nil? l) (sequential? l))\n                 (or (nil? r) (sequential? r))\n                 (= (count node) 3)\n                 v))))", "user": "50d3ec8be4b030b634c368bb"}, {"problem": 95, "code": "(fn bintr [[v l r :as node]]\n  (boolean \n   (and\n    (or (nil? l) (and (sequential? l) (bintr l)))\n    (or (nil? r) (and (sequential? r) (bintr r)))\n    (= 3 (count node))\n    v)))", "user": "5776f39de4b0979f89651643"}, {"problem": 95, "code": "(fn tree? [coll]\n                  (cond\n                    (coll? coll) (and (= 3 (count coll)) (every? tree? (rest coll)))\n                    (nil? coll) true\n                    :else false)\n                  )", "user": "53e92f82e4b036ad0777e49d"}, {"problem": 95, "code": "(fn tree? [node]\n  (cond \n   (and (coll? node) (= 3 (count node)))\n    (let [[n left right] node] (and n (tree? left) (tree? right)))\n   (nil? node) true\n   :else false))", "user": "578f9a18e4b0ebec4cfb7598"}, {"problem": 95, "code": "(fn f [a] (or (nil? a) (and (coll? a) (= 3 (count a)) (every? f (rest a)))))", "user": "5776385fe4b0979f89651632"}, {"problem": 95, "code": "(fn test-tree [coll]\n  (if (not (sequential? coll))\n    false\n    (if (not= 3 (count coll))\n      false\n      (and \n       (or (nil? (second coll)) (test-tree (second coll)))\n       (or (nil? (nth coll 2)) (test-tree (nth coll 2)))\n       )\n    ))\n  )", "user": "5776558ee4b0979f89651633"}, {"problem": 95, "code": "(fn tree? [tree]\n  (if (coll? tree)\n    (cond\n     (not (= (count tree) 3)) false\n     (or (not (tree? (second tree))) (not (tree? (nth tree 2)))) false\n     :else true)\n\t(nil? tree)))", "user": "56d30497e4b0ea9b8538f7a8"}, {"problem": 95, "code": "(fn [root]\n    (every?\n      #(or\n        (nil? %)\n        (and (sequential? %) (= 3 (count %))))\n      (tree-seq sequential? rest root)))", "user": "574ed2f7e4b02ea11479924a"}, {"problem": 95, "code": "(fn is-tree [lst]\n  (if (not (sequential? lst))\n    (not= false lst)\n    (let [rst (rest lst)]\n      (if (= 2 (count rst))\n             (and (is-tree (first rst))\n                  (is-tree (last rst )))\n          false))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 95, "code": "(fn bt? [c]\n  (if (= 3 (count c))\n    (if (empty? (filter sequential? c))\n      (every? nil? (rest c))\n      (every? identity (map bt? (filter sequential? c))))\n    false))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 95, "code": "(fn binary-tree? [x]\n  (if (not (sequential? x))\n    (not (false? x))\n    (and (= (count x) 3)\n         (every? true? (map binary-tree? x)))))", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 95, "code": "(fn bt? [c]\n  (if (= 3 (count c))\n    (if (empty? (filter sequential? c))\n      (every? nil? (rest c))\n      (every? identity (map bt? (filter sequential? c))))\n    false))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 95, "code": "(fn is-tree [tree]\n     (if (false? tree)\n       false\n       (if (not (coll? tree))\n         true\n         (if (or (false? tree) (not= (count tree) 3))\n           false\n           (and (is-tree (nth tree 1)) (is-tree (nth tree 2)))))))", "user": "560c37b5e4b05f002753df2e"}, {"problem": 95, "code": "(fn Tree? [root]\n  (if (nil? root) true\n    (if ((complement sequential?) root )  false\n      (if (not= 3 (count root)) false\n        (let [ [v l r]  root]\n          (and ((complement sequential?) v)\n              (Tree? l)\n              (Tree? r)))))))", "user": "57822efce4b0d36ec5835e91"}, {"problem": 95, "code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (\n          and (is-binary? (nth tree 1)) (is-binary? (nth tree 2))\n         )\n  )\n)", "user": "5799fc93e4b05b1deef9add0"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (= 3 (count t))\n    (every? #(or (nil? %) (and (sequential? %) (tree? %))) (rest t))\n    false))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 95, "code": "(fn ? [n]\n  (or (nil? n)\n    (and\n      (coll? n)\n      (== 3 (count n))\n      (let [[v l r] n]\n         (and (? l)\n              (? r))))))", "user": "50e5bca5e4b09ae9427b0e75"}, {"problem": 95, "code": "(fn binary? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= (count t) 3)\n           (every? binary? (rest t)))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 95, "code": "(fn tree? [tree]\n  (if (and (sequential? tree) (= 3 (count tree)))\n    (let [[node & branches] tree]\n      (every? tree? branches))\n    (nil? tree)))", "user": "53ea3a63e4b036ad0777e4dc"}, {"problem": 95, "code": "(fn bt?\n ([t] (or \n       (nil? t)\n       (and (coll? t)\n            (= (count t) 3)\n            (apply bt?  t))))\n ([e l r] (and (bt? l)\n               (bt? r))))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 95, "code": "(fn is-tree [n]\n  (cond \n   (nil? n) true\n   (not (instance? java.lang.Iterable n)) false\n   (not= 3 (count n)) false\n   :else (and (is-tree (second n)) (is-tree (second (rest n))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 95, "code": "(fn look [sequ]\n    (if (not= (count sequ) 3) \n      false\n      (if (every? not (map counted? sequ))\n        (every? identity (map (comp not false?) sequ))\n        (every? identity (map #(if (coll? %) \n                                 (look %)\n                                 (not (false? %))) sequ))\n        )\n      )\n    )", "user": "57a13745e4b0c3d858beb8e3"}, {"problem": 95, "code": "(fn tree?\n  [x]\n  (or (nil? x)\n    (and (sequential? x)\n         (= 3 (count x))\n         (tree? (nth x 1))\n         (tree? (nth x 2)))))", "user": "521ed5b4e4b0e6c71e0c0bc0"}, {"problem": 95, "code": "(fn tree? [tree-in]\n  (cond\n    (coll? tree-in)\n      (if (not= (count tree-in) 3)\n            false\n            (let [node (first tree-in)\n                  left (second tree-in)\n                  right (last tree-in)]\n              (and (tree? left) (tree? right))))\n    (nil? tree-in)\n      true\n    :default\n      false))", "user": "571d9669e4b0145328a7627f"}, {"problem": 95, "code": "(fn is-tree [n]\n   (or (nil? n)\n       (and (coll? n)\n            (= 3 (count n))\n            (is-tree (second n))\n            (is-tree (last n)))))", "user": "576b4e6be4b0a07e8fc1812b"}, {"problem": 95, "code": "(fn is-tree? [coll] \n        (boolean (when (and (sequential? coll) (seq coll) (= 3 (count coll)))\n                   (let [[root l r] coll]\n                     (println root l r)\n                     (and (not (nil? root))\n                          (or (nil? l)\n                              (is-tree? l))\n                          (or (nil? r)\n                              (is-tree? r)))))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 95, "code": "(fn [tree]\n  (letfn [(is-tree [t]\n            (println t)\n            (cond\n              (nil? t) true\n              (or (not (coll? t)) (not= 2 (count (rest t)))) false\n              :else (every? is-tree [(second t) (last t)])))]\n    (is-tree tree)))", "user": "5033ed65e4b062bc5d7ae15a"}, {"problem": 95, "code": "(fn f [t]\n  (or (and (not (seq? t))\n           (not (vector? t)))\n      (and (= 3 (count t))\n           (every? #(or (seq? %)\n                        (vector? %)\n                        (nil? %))\n                   (rest t))\n           (every? f t))))", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 95, "code": "(fn istree? [t]\n  (cond\n    (nil? t) true\n\t(not (or (vector? t) (seq? t))) false\n    (not (= (count t) 3)) false\n    :defult (and (istree? (second t)) (istree? (last t)))))", "user": "57a49951e4b0a966079561e5"}, {"problem": 95, "code": "(fn tree? [col]\n    (and (coll? col)\n         (= (count col) 3)\n         (or (nil? (nth col 1)) (tree? (nth col 1)))\n         (or (nil? (nth col 2)) (tree? (nth col 2)))))", "user": "57aa290de4b0b8559636fc65"}, {"problem": 95, "code": "(fn [t]\n  (loop [q (list t)]\n    (if (empty? q)\n      true\n      (if (sequential? (first q))\n        (if (= 3 (count (first q)))\n          (recur (into (next q) (next (first q))))\n          false\n        )\n        (if (nil? (first q))\n          (recur (next q))\n          false\n        )\n      )\n    )\n  )\n)", "user": "57873017e4b0ebec4cfb7503"}, {"problem": 95, "code": "(fn tre? [s] \n  (or (nil? s)\n    (and (sequential? s) \n         (= 3 (count s))\n         (tre? (nth s 1)) \n         (tre? (nth s 2)))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 95, "code": "(fn is-tree [xs]\n    (and\n      (coll? xs)\n      (=\n        (count xs)\n        3\n      )\n      (every?\n        (fn [x]\n          (or\n            (nil? x)\n     \t\t(integer? x)\n      \t\t(keyword? x)\n            (is-tree x)\n          )\n        )\n        xs\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 95, "code": "(fn f [xs]\n  (or (= xs nil)\n      (and (coll? xs) (= 3 (count xs)) (f (second xs)) (f (nth xs 2)))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 95, "code": "(fn node? [x] (if (and (sequential? x) (= 3 (count x))) (and (not (nil? (first x))) (node? (second x)) (node? (last x))) (nil? x)))", "user": "5797d4bae4b039eba2ecb107"}, {"problem": 95, "code": "(fn btree? [i] (if (coll? i) (or (and (= (count i) 3) (btree? (first i)) (btree? (nth i 1)) (btree? (nth i 2)))) (if (false? i) false true)))", "user": "4e5e9f6b535d8a8b8723a2d2"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "56349008e4b0bfe05bf117bd"}, {"problem": 95, "code": "(fn bi-tree? [s]\n    (or (nil? s)\n        (and\n         (sequential? s)\n         (= 3 (count s))\n         (bi-tree? (nth s 1))\n         (bi-tree? (nth s 2)))))", "user": "55647a31e4b0c656e3ff1808"}, {"problem": 95, "code": "(fn fun95\n  [candidate]\n  (if (and (or (= candidate nil)\n               (coll? candidate))\n           (= (count candidate) 3)\n           (or (if (coll? (second candidate))\n                 (fun95 (second candidate)))\n               (= (second candidate) nil))\n           (or (if (coll? (nth candidate 2))\n                 (fun95 (nth candidate 2)))\n               (= (nth candidate 2) nil)))\n    true\n    false))", "user": "5075e374e4b09049dea827a5"}, {"problem": 95, "code": "(fn is-tree? [c]\n  (cond (or (seq? c) (vector? c))\n        (and (= 3 (count c)) (is-tree? (nth c 1)) (is-tree? (nth c 2)))\n        (nil? c) true\n        :else false))", "user": "571dd145e4b0145328a76283"}, {"problem": 95, "code": "(fn check-vlr [[v l r :as t]]\n  (cond (not= (count t) 3) false\n        (and (not= nil v) (nil? l) (nil? v)) true\n        (not (every? #(or (nil? %) (coll? %)) [l r])) false\n        (some #(and (coll? %) (empty? %)) [l r]) false\n        :else (every? true? \n                (map #(if (coll? %) (check-vlr %) true)\n                  [l r]))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 95, "code": "(fn btree? [s] \n  (if (coll? s) \n    (let [[n l r] s]  \n      (and (= 3 (count s)) \n           (not (coll? n))\n           (btree? l)\n           (btree? r)\n           )) \n    (nil? s) ; scalars are true\n  )\n)", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 95, "code": "(fn isn? [t]\n    (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (isn? (second t))\n           (isn? (last t)))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 95, "code": "(fn foo [x] \n  (if (= x nil) true \n    (if (and (coll? x) (= (count x) 3)) \n      (and (nth x 0) (foo (nth x 1)) (foo (nth x 2)))\n      false)\n    )\n  )", "user": "57b8b008e4b0fbc9809a27e6"}, {"problem": 95, "code": "(fn btree? [xs]\n    (if (or (not (sequential? xs)) (empty? xs)) false\n      (let [value (first xs) children (rest xs)]\n        (and (not (nil? value))\n             (= 2 (count children))\n             (every? #(or (nil? %) (btree? %)) children)))))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 95, "code": "(fn is-binary-tree? [input]  \n   (cond (nil? input) true\n         (not (coll? input)) false\n         (= 1 (count input)) true \n         (= 3 (count input)) (and (is-binary-tree? (second input)) \n                                  (is-binary-tree? (nth input 2)))\n         :else false))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 95, "code": "(fn istree? [root]\n  (and \n     (not (nil? root))\n     (letfn [(istree-inner? [rt] \n                           (or\n                             (nil? rt)\n                             (and\n                                  (sequential? rt)\n                                  (= 3 (count rt))\n                                  (every? istree-inner? (rest rt)))))]\n       (istree-inner? root))))", "user": "57b4779de4b0fbc9809a279a"}, {"problem": 95, "code": "(fn tree? [m]\n  (if (and (coll? m) (= 3 (count m)))\n    (let[[l c r] m] (and l (tree? c) (tree? r)))\n    (nil? m)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 95, "code": "(fn is-tree? [xs]\n  (or (nil? xs)\n    (and\n      (sequential? xs)\n      (= 3 (count xs))\n      (let [[node left right] xs]\n        (and \n          (is-tree? left)\n          (is-tree? right))))))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 95, "code": "(fn istree [x]\n  (if (and (or (seq? x) (vector? x)) (= (count x) 3) (not (contains? (set x) false)))\n    (loop [x x res true]\n      (cond (empty? x) res\n            :else (if (or (seq? (first x)) (vector? (first x)))\n                    (recur (rest x) (istree (first x)))\n                    (recur (rest x) res))))\n    false))", "user": "57acee37e4b0b8559636fc94"}, {"problem": 95, "code": "(fn\n  [s]\n  (let [fs (vec (flatten s))]\n    (if (contains? fs (.indexOf fs false))\n      false\n      (#(odd? (count %)) fs))))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 95, "code": "(fn c[[v l r :as x]]\n  (let [length-validation (= 3 (count x))\n        l-validation (if (coll? l) (c l) (nil? l))\n        r-validation (if (coll? r) (c r) (nil? r))]\n    (and length-validation l-validation r-validation)))", "user": "57b9fc74e4b0fbc9809a27fb"}, {"problem": 95, "code": "(fn b-tree? [coll]\n  (cond (nil? coll) true\n  \t\t(not (coll? coll)) false\n        (not= (count coll) 3) false\n        (and (b-tree? (second coll))\n             (b-tree? (last coll))) true\n        :else\n        false))", "user": "579332c2e4b0e215f87e8452"}, {"problem": 95, "code": "(fn f [r]\n  (or (nil? r)\n      (and (sequential? r)\n           (= 3 (count r))\n           (every? f (rest r)))))", "user": "55ff562fe4b00f4cabc57660"}, {"problem": 95, "code": "(fn btree? [s]\n  (if (coll? s)\n    (if (= 3 (count s))\n      (and (btree? (second s)) (btree? (last s)))\n      false)\n    (nil? s)))", "user": "57addbcce4b0b8559636fca3"}, {"problem": 95, "code": "(fn tree? [col]\n  (cond \n   (not (sequential? col)) false\n   (not= 3 (count col)) false\n   (sequential? (first col)) false\n   (nil? (first col)) false\n   :else (let [[a b c] col] (and (or (nil? b) (tree? b)) (or (nil? c) (tree? c))))))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (coll? coll) (and (= 3 (count coll)) (tree? (second coll)) (tree? (last coll)))\n    (nil? coll) true\n    :else false))", "user": "576a8d02e4b0a07e8fc18117"}, {"problem": 95, "code": "(fn istree [t]\n  (if (sequential? t)\n    (if (= (count t) 3)\n      (let [left (nth t 1)\n            right (nth t 2)]\n        (and  (istree left) (istree right)))\n      false)\n    (nil? t)))", "user": "4f4aa932e4b0d56e7bb92c14"}, {"problem": 95, "code": "(fn is-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? is-tree? (rest root)))))", "user": "572830e6e4b0c5bde472c152"}, {"problem": 95, "code": "(fn tree?[node]\n  (if (nil? node)\n    true\n    (and\n     (coll? node)\n     (= (count node) 3)\n     (tree? (second node))\n     (tree? (last node)))))", "user": "57bd960fe4b05aa3c4741c52"}, {"problem": 95, "code": "; (remove false? %) because the 6th case appears to not count \"false\" as a valid leaf value.  Otherwise (comp odd? count flatten) should work.\n#(odd? (count (remove false? (flatten %))))", "user": "57b65c9be4b0fbc9809a27c0"}, {"problem": 95, "code": "(fn bintree? [tree]\n  (or \n   (nil? tree)\n   (and\n    (sequential? tree)\n    (= (count tree) 3)\n    (every? bintree? (rest tree))\n   )\n  )\n )", "user": "57cf03c0e4b00451144b04f9"}, {"problem": 95, "code": "(fn f[t] (prn t) (if (sequential? t) (and (= (count t) 3) (f (second t)) (f (nth t 2))) (or t (nil? t))))", "user": "57c7e7d9e4b05aa3c4741d0f"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (if (and (coll? t) (= 3 (count t)))\n    (let [[l r] (rest t)]\n      (and (or (nil? l) (binary-tree? l))\n           (or (nil? r) (binary-tree? r))))\n    false))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 95, "code": "(fn tree? [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= (count tree) 3)\n           (every? tree? (rest tree)))))", "user": "57839ae9e4b0ebec4cfb74b8"}, {"problem": 95, "code": "(fn [s] (every? #(if (sequential? %) (= 3 (count %)) (nil? %)) (tree-seq sequential? rest s)))", "user": "57cd7498e4b0c746388ab897"}, {"problem": 95, "code": "apply (fn isTree?\n        ([] false)\n        ([v] true)\n        ([x y] false)\n        ([v left right] (and (if (sequential? left) (apply isTree? left) (nil? left)) (if (sequential? right) (apply isTree? right) (nil? right)) ) )\n        ([x y z & zs] false)\n      )", "user": "57b55290e4b0fbc9809a27a9"}, {"problem": 95, "code": "; a node is not just a value: it's either nil, or a value and two sub-trees.\n; I don't like this because it doesn't use recur\n; and too many double negatives (naught the naught and carry the naught)\n; condition 1 - is anything in x false?\n; condition 2 - is anything in x a collection?\n; condition 3 - does x have 3 members?\n;\n(fn is-binary? [x] \n  (cond \n   (false? x) false\n   (not (coll? x)) true\n   (not= (count x) 3) false\n   :else (and (is-binary? (second x)) (is-binary? (last x)))))\n\n; how to rebuild this with recur???\n;(fn valid-tree? [tree]\n;   (let [tree tree]\n;     (if (not= 3 (count tree)) \n;       false\n;       true)))", "user": "57c44053e4b05aa3c4741ccb"}, {"problem": 95, "code": "(fn binary-tree? [s]\n  (letfn [(bt? [tree]\n            (if-not (sequential? tree)\n              true\n              (when-let [[root left right] (seq tree)]\n                 (and (= 3 (count tree)) root (not= false left) (not= false right)\n                     (bt? left)\n                     (bt? right)))))]\n    (if (and (sequential? s) (= 3 (count s)) (bt? s))\n      true\n      false)))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 95, "code": "(fn b-tree?\n  [s]\n  (letfn [(leaf? [x] (and (not (coll? x)) (not (false? x))))]\n    (and\n     ;; no empty seq's; exactly 3 elements (value, left child, and right child)\n     (= (count s) 3)\n     \n     ;; first item must be a value\n     (leaf? (first s))\n     \n     ;; second item must be a child - either another node or terminal value\n     (if (coll? (second s))\n       (b-tree? (second s))\n       (leaf? (second s))\n       )\n     \n     ;; third item must also be a child\n     (if (coll? (nth s 2))\n       (b-tree? (nth s 2))\n       (leaf? (nth s 2))\n       )\n     \n     )\n    )\n  )", "user": "57b9d21fe4b0fbc9809a27f7"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55da18d5e4b0e31453f64ad1"}, {"problem": 95, "code": "(fn f [a]\n      (if (coll? a)\n        (if (= 3 (count a))\n          (let [[_ y z] a]\n            (and (f y) (f z)))\n          false)\n        (nil? a)))", "user": "4f1052b9535d64f603146418"}, {"problem": 95, "code": "(fn bitree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= 3 (count coll))\n           (bitree? (nth coll 1))\n           (bitree? (nth coll 2)))))", "user": "56dc3dbbe4b0ea9b8538f81a"}, {"problem": 95, "code": "(fn bin? [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (every? bin? (rest x)))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 95, "code": "(fn treeChecker [x] (if (coll? x) (if (= 3 (count x)) (and (treeChecker (second x)) (treeChecker (last x))) false) (nil? x)))", "user": "57a5f1e3e4b0a96607956200"}, {"problem": 95, "code": "(fn c95\n  [t]\n  (if (coll? t)\n    (if (not= (count t) 3)\n      false\n      (and (if (coll? (first t))\n             (c95 (first t))\n             true)\n           (c95 (second t))\n           (c95 (last t))))\n    (if (nil? t)\n      true\n      false)))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 95, "code": "(fn [root]\n  (every? #(or (= nil %) (and (sequential? %) (= 3 (count %))))\n          (tree-seq #(and (sequential? %) (= 3 (count %)))\n                    rest root)))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 95, "code": "(fn binary-tree?\n  [tree]\n  (if-let [[value left-child right-child] tree]\n    (and (= (count tree) 3)\n         (or (binary-tree? left-child) (nil? left-child))\n         (or (binary-tree? right-child) (nil? right-child)))\n  \tfalse))", "user": "57dda21be4b0bd073c202445"}, {"problem": 95, "code": "(fn bin-tree? [coll]\n        ; it has 3 members, the first of which is a value and the second two meet the tree requirement\n        (letfn [(is-bin-tree-or-nil? [x] (or (nil? x) (bin-tree? x)))]\n            (and (coll? coll) (= (count coll) 3) (not (coll? (first coll))) (is-bin-tree-or-nil? (second coll)) (is-bin-tree-or-nil? (last coll)))))", "user": "5227eacee4b0186687e23a5e"}, {"problem": 95, "code": "(fn btree? [n]\n\t(cond\n\t\t(and (coll? n) (= (count n) 3)) (and (btree? (nth n 1)) (btree? (nth n 2)))\n\t\t(nil? n) true\n\t\t:else false))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 95, "code": "(fn bt? [l]\n  (let [[a b c] l]\n    (cond\n      (not (= (count l) 3)) false\n      (and ((complement nil?) a) (coll? a)) false\n      (and (nil? b) (nil? c)) true\n      (and (coll? b) (coll? c)) (and (bt? b) (bt? c))\n      (and (coll? b) (nil? c)) (bt? b)\n      (and (coll? c) (nil? b)) (bt? c)\n      :else false)))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 95, "code": "(fn t? [node]\n    (if-not (sequential? node)\n      false\n      (let [[v l r :as n] node]\n        (and (= 3 (count node))\n             (or (nil? l) (t? l))\n             (or (nil? r) (t? r))))))", "user": "55568a7de4b0deb715856e1c"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (letfn [(valid-node? [col idx]\n            (let [elem (nth col idx)]\n              (if (nil? elem)\n                true\n                (and (coll? elem) (binary-tree? elem)))))]\n    (if (= 3 (count xs))\n      (and\n       (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))\n      false)))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 95, "code": "(fn bt [x]\n  (let [a? (fn [t] (if (not (coll? t)) true false))]\n    (if (not=  (count (filter #(not (false? %)) x)) 3)\n      false\n      (loop [in x]\n        (if (empty? in)\n          true\n          (if (not (a? (first in)))\n            (bt (first in))\n            (recur (rest in))))))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 95, "code": "(fn btree? [x]\n  (or\n    (nil? x)\n    (and (coll? x)\n      (= 3 (count x))\n      (every? btree? (rest x)))\n    false))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 95, "code": "(fn btree? [xs]\n  (if (coll? xs)                ; if xs = collection \n    (if (= (count xs) 3)        ;   if xs = collection of 3 (value, child, child)\n      (apply = (map btree? xs)) ;     then apply btree? to all in collection\n      false)                    ;     else result is false \n    (if (not (false? xs))       ;   if xs = not a collection and not false\n      true                      ;     then result is true\n      false)))                  ;     else result is false", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (coll? t) \n    (if (= (count t) 3)\n      (and (tree? (second t)) (tree? (last t)))\n      false)\n    (not= t false )))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 95, "code": "(fn f [t] (if (nil? t)\n            true\n            (and \n             (coll? t)\n             (= 3 (count t))\n           \t (not (coll? (first t)))\n             (every? f (rest t)))))", "user": "57c796b4e4b05aa3c4741d08"}, {"problem": 95, "code": "(fn btree? [tree]\n  (->> tree\n       (tree-seq sequential? identity)\n       (filter sequential?)\n       (some (fn [[v l r :as subtree]]\n               (or (not= 3 (count subtree))\n                   (not (and (or (sequential? l)\n                                 (nil? l))\n                             (or (sequential? r)\n                                 (nil? r)))))))\n       boolean\n       not))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 95, "code": "(fn bintree? [t]\n  (if (nil? t)\n    true\n\t  (if (or (not (sequential? t)) (not= 3 (count t)) )\n\t    false\n\t    (and (bintree? (-> t rest first)) (bintree? (-> t rest second)))\n    )\n  )\n)", "user": "57e396cde4b0bfb2137f5a9e"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 95, "code": "#(every? (fn [[h & t]] (and (= 2 (count t)) h (every? (fn [x] (or (nil? x) (coll? x)) ) t))) (filter sequential? (tree-seq sequential? seq %)))", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 95, "code": "(fn is-binary-tree? [tree]\n\t(letfn [(left-node [tree] (second tree))\n\t\t\t\t\t (right-node [tree] (nth tree 2))]\n\t\t(and (coll? tree) \n\t\t\t\t (= (count tree) 3) \n\t\t\t\t (or (nil? (left-node tree)) \n\t\t\t\t \t\t (is-binary-tree? (left-node tree)))\n\t\t\t\t\t (or (nil? (right-node tree)) \n\t\t\t\t \t\t (is-binary-tree? (right-node tree))))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 95, "code": "(fn binary-tree? [[v l r :as a]]\n    (and (= 3 (count a))\n         (or (nil? l)\n             (and (sequential? l)\n                  (binary-tree? l)))\n         (or (nil? r)\n             (and (sequential? r)\n                  (binary-tree? r)))))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 95, "code": "(fn bt? [sq]\n  (if (nil? sq)\n    true\n    (and (sequential? sq)\n         (= (count sq) 3)\n         (every? bt? (rest sq)))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 95, "code": "(fn treeish\n  [tree]\n  (if (= tree nil)\n    true\n    (if (or (not (coll? tree)) (not= (count tree) 3))\n      false\n      (let [[val left right] tree]\n        (and (treeish left)\n             (treeish right)\n             )\n        ))))", "user": "57f55632e4b0903ccab3dcf1"}, {"problem": 95, "code": "(fn is-binary-tree? [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= (count coll) 3)\n           (is-binary-tree? (second coll))\n           (is-binary-tree? (last coll)))))", "user": "577b4440e4b0d3393e5deb0f"}, {"problem": 95, "code": "(fn is-tree? [root]\n  (if (sequential? root)\n    (and (= 3 (count root)) (is-tree? (first (rest root))) (is-tree? (first (rest (rest root)))))\n    (= root nil)))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 95, "code": "#(and (odd? (count (flatten %))) (not (some (fn [x] (= false x)) (flatten %))))", "user": "57bfffc7e4b05aa3c4741c8a"}, {"problem": 95, "code": "(fn\n  [s]\n  (let [c (flatten s)\n        n (count c)]\n    (cond\n      (some #(false? %) c) false\n      (odd? n) true\n      :else false)))", "user": "56a44067e4b0542e1f8d14da"}, {"problem": 95, "code": "(fn binary-tree \n  [tree]\n  (cond\n   (false? tree) \t\t\tfalse\n   (not (coll? tree)) \t\ttrue\n   (not= (count tree) 3) \tfalse\n   :else (and (binary-tree (second tree)) (binary-tree (nth tree 2)))))", "user": "57f8153de4b0d3187e900916"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "57e6997ee4b0bfb2137f5af0"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree? (rest root)))))", "user": "57e4dbcbe4b0bfb2137f5ac3"}, {"problem": 95, "code": "(fn tree? [tree] (cond\n   (sequential? tree) (and (= (count tree) 3) (tree? (second tree)) (tree? (nth tree 2)))\n   :else (nil? tree)))", "user": "57db2369e4b0bd073c20241f"}, {"problem": 95, "code": "(fn f [s] (or (nil? s) (and (sequential? s) (= 3 (count s)) (every? f (rest s)))))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 95, "code": "(fn t [xs] (if (sequential? xs) (if (= 3 (count xs)) (and (t (second xs)) (t (last xs))) false) (if (nil? xs) true false)))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 95, "code": "(fn binary? [x]\n  (if (or (coll? x) (nil? x))\n    (if (not (= 3 (count x)))\n      (if (nil? x) true false)\n      (and (binary? (nth x 1)) (binary? (nth x 2)))) false))", "user": "574a71b7e4b02ea1147991fb"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "57f8104ce4b0d3187e900910"}, {"problem": 95, "code": "(fn to-tree-or-not-to-tree? [s]\n  (and\n    (sequential? s)\n    (= (count s) 3)\n    (let [left (second s)\n          right (last s)]\n      (and\n        (or\n          (nil? left)\n          (to-tree-or-not-to-tree? left))\n        (or\n          (nil? right)\n          (to-tree-or-not-to-tree? right))))))", "user": "57f81524e4b0d3187e900913"}, {"problem": 95, "code": "(fn istree? [tree]\n   (or (nil? tree)\n       (and (sequential? tree)\n            (= 3 (count tree))\n            (every? istree? (rest tree)))))", "user": "57fc34f0e4b0d3187e90098e"}, {"problem": 95, "code": "(fn tree? [tree]\n  (cond\n   \t(nil? tree) true\n    (and (coll? tree) (= 3 (count tree)) (tree? (nth tree 1)) (tree? (nth tree 2))) true\n   \t:else false))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 95, "code": "(letfn [(my-val? [a] true)\n  (my-node? [x] \n   (or \n    (nil? x)\n    (and \n     (coll? x)\n     (= 3 (count x))\n     (my-val? (first x))\n     (my-node? (second x))\n     (my-node? (second (rest x))) )))]\n  (fn [y] (my-node? y)))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 95, "code": "(fn tree? [node]\n   (or (= nil node)\n       (and (or (coll? node) (seq? node))\n            (= 3 (count node))\n            (first node)\n            (tree? (second node))\n            (tree? (last node)))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 95, "code": "(fn binary-tree? [lst]\n  (cond\n    (or (seq? lst) (vector? lst)) (and (= 3 (count lst)) (binary-tree? (nth lst 1)) (binary-tree? (nth lst 2)))\n    (not= false lst) true\n    :else false\n    )\n  )", "user": "57f81045e4b0d3187e90090f"}, {"problem": 95, "code": "(fn tree-nt\n  [n]\n  (if (nil? n)\n    true\n    (if (or (not (coll? n)) (not= 3 (count n))) \n      false \n      (and (tree-nt (nth n 1)) \n           (tree-nt (nth n 2))))\n    )\n  )", "user": "57f81532e4b0d3187e900914"}, {"problem": 95, "code": "(fn bt? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))(and (= 3 (count coll)) (bt? (nth coll 1)) (bt? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "57fa7c93e4b0d3187e900963"}, {"problem": 95, "code": "(fn is-binary-tree?\n  [input-seq]\n  (cond\n    (false? input-seq) false\n    (not (coll? input-seq)) true\n    (not= (count input-seq) 3) false\n    :else (and (is-binary-tree? (second input-seq)) (is-binary-tree? (last input-seq)))))", "user": "57596ba7e4b02ea11479931a"}, {"problem": 95, "code": "(fn tree? [lst]\n  (if (nil? lst)\n      true\n      (if (coll? lst)\n          (and (= 3 (count lst)) (tree? (second lst)) (tree? (nth lst 2)))\n    \t  false)))", "user": "57f8151ce4b0d3187e900912"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "580570a2e4b0a837a8b30cc7"}, {"problem": 95, "code": "(fn binary-tree\n  [tree]\n  (cond\n    (false? tree) \t\t\t    false\n    (not (coll? tree)) \t\t  true\n    (not= (count tree) 3) \tfalse\n    :else (and (binary-tree (second tree)) (binary-tree (nth tree 2)))))", "user": "57f81544e4b0d3187e900917"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "57f814fbe4b0d3187e900911"}, {"problem": 95, "code": "(fn chktree [tree]\n  (if (or (vector? tree) (list? tree))\n    (and (= 3 (count tree)) (chktree (second tree)) (chktree (last tree)))\n    (if (nil? tree)\n      true\n      false)))", "user": "57f81549e4b0d3187e900918"}, {"problem": 95, "code": "(fn b? \n  [s]\n  (and (sequential? s)\n       (= (count s) 3)\n    (let [ r1 (second s)\n          r2 (last s)]\n      (and\n        (or\n          (nil? r1)\n          (b? r1))\n        (or\n          (nil? r2)\n          (b? r2))))))", "user": "57fedf07e4b0d3187e9009dc"}, {"problem": 95, "code": "(fn bin-tree \n  [t]\n  (if (coll? t)\n    (if (= (count t) 3)\n      (and (bin-tree (second t)) (bin-tree (last t)))\n      false)\n    (not (false? t))))", "user": "57f81534e4b0d3187e900915"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "57f81569e4b0d3187e900919"}, {"problem": 95, "code": "(fn [t] (loop [nodes (conj [] t)]\n                   (if (empty? nodes)\n                     true\n                     (let [node (first nodes)]\n                       (if (and (= (count node) 3)\n                                (first node)\n                                (or (nil? (first (rest node))) (first (rest node)))\n                                (or (nil? (first (rest (rest node)))) (first (rest (rest node))))) \n                         (recur (remove nil? (conj (rest nodes)\n                               (if (first (rest node))\n                                 (first (rest node)))\n                               (if (first (rest (rest node)))\n                                 (first (rest (rest node)))))))\n                         false)))))", "user": "579aff09e4b05b1deef9ade7"}, {"problem": 95, "code": "(fn tree? [a-seq]\n  (let [node? (fn [b-seq]\n                (= (count (filter (complement false?) b-seq)) 3))\n        nested-seqs (filter sequential? a-seq)]\n    (if (node? a-seq)\n      (do\n        (if (= (count nested-seqs) 0)\n          true\n          (every? true? (map tree? nested-seqs))))\n      false)))", "user": "574e84e0e4b02ea114799243"}, {"problem": 95, "code": "(fn isNode [& args]\n  (let [seq1 (nth args 0)]\n  (if (nil? seq1)\n    true\n    (if (coll? seq1)\n      (if (== 3 (apply count args))\n        (and (isNode (nth seq1 1)) (isNode (nth seq1 2)))\n        false)\n      false))))", "user": "57f52d3be4b0903ccab3dce7"}, {"problem": 95, "code": "(fn tree? [xs]\n  (if (sequential? xs)\n    (if (= 3 (count xs))\n      (every? tree? (rest xs))\n      false)\n    (nil? xs)))", "user": "51a54fb4e4b0def3c5c586a3"}, {"problem": 95, "code": "(fn ! [coll]\n  (and (sequential? coll)\n       (= (count coll) 3)\n       (let [[_ l r] coll]\n         (and (or (nil? l)\n                  (! l))\n              (or (nil? r)\n                  (! r))))))", "user": "52d38c51e4b099d49816f0c5"}, {"problem": 95, "code": "(fn binary-tree? [r]\n  (let [seq?? (fn [rr] (or (list? r) (vector? r)))]\n    (cond (= false r) false\n          (not= true (seq?? r)) true \n          (nil? r) true          \n          (empty? r) false                             \n          (= 3 (count r)) (and (not= true (seq? (first r))) \n                               (let [scnd (second r)\n                                     thrd (second (rest r))]\n                                 (and (binary-tree? scnd) (binary-tree? thrd))))\n          :else false)))", "user": "57f28b22e4b0511f1d294def"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root) (= 3 (count root)) (every? tree? (rest root)))))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 95, "code": "(fn tree? [x]\n  (cond\n    (coll? x) (and (= (count x) 3) (tree? (second x)) (tree? (last x)))\n    (not (nil? x)) false\n    :else true))", "user": "57fa6f2ee4b0d3187e900962"}, {"problem": 95, "code": "(fn btree? [bt]\n    (if (sequential? bt)\n      (and (= (count bt) 3)\n           (every? btree? (rest bt))) ;;(let [[v l r] bt] (and (btree? l) (btree? r)))\n      (nil? bt)))", "user": "57f6e666e4b0d3187e9008f2"}, {"problem": 95, "code": "(fn tree?\n  [[v l r :as node]]\n  (and (or (nil? l) (if (sequential? l) (tree? l) false))\n       (or (nil? r) (if (sequential? r) (tree? r) false))\n       (not (nil? v))\n       (= 3 (count node))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "57e79d8ee4b0bfb2137f5afe"}, {"problem": 95, "code": "(fn treep [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (every? treep (rest tree)))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "57ee2b3ee4b0bfb2137f5bac"}, {"problem": 95, "code": "(fn b-tree? [tree]\n  (and\n   (sequential? tree)\n   (= (count tree) 3)\n   (or (nil? (nth tree 1)) (b-tree? (nth tree 1)))\n   (or (nil? (nth tree 2)) (b-tree? (nth tree 2)))))", "user": "56069006e4b08b23635d3174"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x) (and (sequential? x)(= (count x) 3) (every? tree? (rest x)))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 95, "code": "(fn is-bi-tree [tree]\n  (cond\n    (nil? tree) true \n    ((comp not coll?) tree) false \n    (not= (count tree) 3) false\n    :else (every? identity (map is-bi-tree (rest tree)))))", "user": "570e6974e4b0b0fb43fd06ef"}, {"problem": 95, "code": "(fn tree? [s]\n  (and (= (count s) 3) \n       (every? #(if (coll? %)\n                  (tree? %)\n                  (not (false? %)))\n               s)))", "user": "57c94c54e4b05aa3c4741d2c"}, {"problem": 95, "code": "(fn bt? [x] (or (nil? x) (and (coll? x) (= (count x) 3) (bt? (second x)) (bt? (nth x 2)))))", "user": "5686e652e4b0dcc4269f4059"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "580d7de3e4b0849f6811b73d"}, {"problem": 95, "code": "(fn tree? [x]\n   (or\n     (nil? x)\n     (and\n       (sequential? x)\n       (= 3 (count x))\n       (not (sequential? (first x)))\n       (tree? (second x))\n       (tree? (nth x 2)))))", "user": "54026d7de4b0df28a13c62cf"}, {"problem": 95, "code": "(fn is-tree? [x]\n  (if (coll? x)\n    (and (= (count x) 3)\n         (every? is-tree? (rest x)))\n    (nil? x)))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 95, "code": "(fn f [x]\n  (or (and (sequential? x)\n           (= 3 (count x))\n           (every? f (rest x)))\n      (nil? x)))", "user": "55630cc1e4b0c656e3ff17e0"}, {"problem": 95, "code": "(letfn [(bt? [xs]\n          (if (and (coll? xs) (not= 3 (count xs)))\n            false\n            (let [[v l r] xs\n                  valid? #(if (coll? %) (bt? %) (not= false %))]\n              (and (valid? l) (valid? r)))))]\n  bt?)", "user": "55fbc657e4b0f488688e0666"}, {"problem": 95, "code": "(fn ans [s]\n    (cond\n      (nil? s) true\n      (not (sequential? s)) false\n      :else (and (= 3 (count s)) (ans (second s)) (ans (last s)))))", "user": "58134ba8e4b0f478707a060b"}, {"problem": 95, "code": "(fn is-tree [s]\n  (cond\n    (false? s) false\n    (not (coll? s)) true\n    (not= (count s) 3) false\n    :else (and (is-tree (second s)) (is-tree (nth s 2)))))", "user": "574a546ee4b02ea1147991f6"}, {"problem": 95, "code": "(fn f95 [coll]\n  (if (false? coll)\n    false\n    (if (coll? coll)\n      (if (= (count coll) 3)\n        (and (f95 (second coll)) (f95 (nth coll 2)))\n        false)\n      true)))", "user": "57bbc9bde4b05aa3c4741c31"}, {"problem": 95, "code": "(fn is-tree?\n  [x]\n  (if (or (list? x) (vector? x))\n    (let [[f s t ? rest] x]\n      (if (and (= (count x) 3)\n               (or (nil? s) (is-tree? s))\n               (or (nil? t) (is-tree? t)))\n        true\n        false))\n        false))", "user": "58152157e4b0f478707a0631"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n    (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 95, "code": "(fn t? [stuff]\n  (cond\n    (= false stuff) false\n    (nil?    stuff) true\n    :else (and (= 3 (count stuff))\n               (let [[val left right] stuff]\n                 (and (t? left) (t? right))))))", "user": "515cf9b5e4b00901442db1d4"}, {"problem": 95, "code": "(fn [coll] (every? #(and (= 3 (count %)) (not= (get % 1) false)) (filter coll? (tree-seq coll? identity coll))))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 95, "code": "(fn tree? [tr] (if (not (sequential? tr))\n                 (nil? tr)\n                 (let [v (first tr) l (next tr) r (next l)]\n                   (if (or (nil?  v) (nil? l) (nil? r))\n                     false\n                     (and (nil? (next r)) (tree? (first l)) (tree? (first r)))))))", "user": "58225587e4b04b46fc4b0f94"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n   (nil? s) true\n   (or (not (coll? s)) (not= 3 (count s))) false\n   :else (let [[one two three] s]\n           (and (tree? two) (tree? three)))))", "user": "581e8b86e4b04b46fc4b0f2b"}, {"problem": 95, "code": "(fn tree? [l]\n  (or (nil? l)\n      (and\n        (coll? l)\n        (= 3 (count l))\n        (every? tree? (rest l)))))", "user": "58247423e4b051871117bec5"}, {"problem": 95, "code": "(fn binary? [tree]\n  (cond\n\t(nil? tree) true\n    (and (coll? tree) (= 3 (count tree))) (and (binary? (second tree)) (binary? (last tree)))\n    :else false))", "user": "57fbf995e4b0d3187e900981"}, {"problem": 95, "code": "(fn tr [coll](or (nil? coll)(and (sequential? coll)(= (count coll) 3)(every? tr(rest coll)))))", "user": "580d7bdae4b0849f6811b73c"}, {"problem": 95, "code": "(fn [r]\n    (every?\n     #(or\n       (nil? %)\n       (and (sequential? %) (= 3 (count %))))\n     (tree-seq sequential? rest r)))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 95, "code": "(fn is-tree? [tr]\n   (if (nil? tr)\n     true\n     (if-not (coll? tr)\n       false\n       (and (= 3 (count tr))\n            (is-tree? (nth tr 1))\n            (is-tree? (nth tr 2))))))", "user": "5808ee16e4b0a837a8b30d16"}, {"problem": 95, "code": "(fn tree?  [root]\n  (or  (nil? root)\n       (and   (sequential? root) ; is a sequence?\n              (= 3 (count root))\n              (every? tree? (rest root)))))", "user": "57addf3ae4b0b8559636fca4"}, {"problem": 95, "code": ";(\n(fn tree? [root]\n  (cond \n   (nil? root) true\n   (and (or (list? root)\n            (vector? root))\n        (= 3 (count root))\n        (tree? (nth root 1))\n        (tree? (nth root 2)))\n     true\n   :else false))\n;[nil nil])])", "user": "57df2722e4b0bd073c20245e"}, {"problem": 95, "code": "(fn check-bin [coll]\n  (if (nil? coll) true\n      (if (and (sequential? coll) (= 3 (count coll)))\n        (and (check-bin (second coll)) (check-bin (last coll)))\n        false)))", "user": "58303fc3e4b051871117c006"}, {"problem": 95, "code": "(fn tree-checker [s]\n  (if (not (= (count s) 3)) false\n     (every? (fn [element]\n            (if (sequential? element)\n              (tree-checker element)\n              (not (false? element)))) s)))", "user": "5829d588e4b051871117bf4a"}, {"problem": 95, "code": "(fn tree? [coll]\n    (cond (nil? coll) true\n          (not (coll? coll)) false\n          :else (let [[n l r] coll]\n                 (and   (not (nil? n))\n                        (= 3 (count coll))\n                        (or (nil? l) (tree? l))\n                        (or (nil? r) (tree? r))))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 95, "code": "(fn t [arg] \n  (or \n     (= arg nil) \n     ( and (sequential? arg) \n           (= 3 (count arg)) \n           (t (second arg))\n           (t (last arg) ))\n ) \n)", "user": "58335c22e4b089d5ab817c9a"}, {"problem": 95, "code": "(fn tree? [tree]\n  (if (and (= 3 (count tree))\n           (cond \n            (coll? (nth tree 1)) (tree? (nth tree 1))\n            (false? (nth tree 1)) false\n            :default true)\n           (cond \n            (coll? (nth tree 2)) (tree? (nth tree 2))\n            (false? (nth tree 2)) false\n            :default true))\n    true\n    false))", "user": "55b1d0b5e4b0da326a65cf73"}, {"problem": 95, "code": "(fn tree? [x] \n  (and (= 3 (count x)) \n       (and \n         (if (coll? (second x)) (tree? (second x)) (nil? (second x))) \n         (if (coll? (last x)) (tree? (last x)) (nil? (last x)))\n       )\n     )\n  )", "user": "566e6850e4b0a866af6896da"}, {"problem": 95, "code": "(fn istree [[v l r :as node]]\n\t(and \n\t\t(= 3 (count node ))\n\t\t(not(nil? v))\n\t\t(or (nil? l) (and (coll? l) (istree l)))\n\t\t(or (nil? r) (and (coll? r) (istree r)))\n\t)\n)", "user": "580c8fcee4b0849f6811b721"}, {"problem": 95, "code": "(fn tree?\n  [coll]\n  (cond\n    (not= (count coll) 3) false\n    (nil? (first coll)) false\n    (sequential? (first coll)) false\n    (false? (second coll)) false\n    (false? (nth coll 2)) false\n    (and (sequential? (second coll)) (not (tree? (second coll)))) false\n    (and (sequential? (nth coll 2)) (not (tree? (nth coll 2)))) false\n    :else true))", "user": "57235dc4e4b0c5bde472c0e2"}, {"problem": 95, "code": "(fn validT? [T] \n  (if\n    (and (sequential? T) (= 3 (count T)))\n    (let [[v L R] T] \n      (and \n       (validT? L) \n       (validT? R))\n      )\n    (nil? T)\n    )\n  )", "user": "58334d18e4b089d5ab817c97"}, {"problem": 95, "code": "(fn is-tree? [x] \n    (if (coll? x) \n      (and (not-any? false? x) (= (count x) 3) (every? is-tree? x))\n      true))", "user": "580d1da7e4b0849f6811b72f"}, {"problem": 95, "code": "(fn is_tr2\n  [node]\n  (if (not= (count node) 3) \n    false\n    (let [[v a b] node]\n      (and\n        (or (nil? a) (and (sequential? a) (is_tr2 a)))\n        (or (nil? b) (and (sequential? b) (is_tr2 b)))))))", "user": "583166c1e4b051871117c025"}, {"problem": 95, "code": "(fn is-tree [t]\n  (or\n      (nil? t)\n      (if\n        (and (coll? t) (= (count t) 3))\n        (let [[val left right] t\n              leaves [left right]]\n          (->> leaves\n               (map is-tree)\n               (every? identity)))\n        false)))", "user": "5779556de4b0979f8965166e"}, {"problem": 95, "code": "(fn tree? [t]\n  (odd? (count (filter (complement false?) (flatten t)))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 95, "code": "(fn r [x]\n  (or (nil? x)\n      (and (coll? x)\n\t   (= (count x) 3)\n\t   (every? r (rest x)))))", "user": "58391c94e4b089d5ab817d35"}, {"problem": 95, "code": "(fn tree? [x]\n    (and (coll? x) (= (count x) 3)\n      (let [[_ a b] x]\n       (and\n        (or (nil? a) (tree? a))\n        (or (nil? b) (tree? b))))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 95, "code": "(fn binary-tree? [x]\n  (if (sequential? x) \n    (and (= (inc 2) (count x)) ;change number for other leaved trees\n         (every? binary-tree? (rest x)))\n    (nil? x)))\n\n;golf:\n; binary-tree? -> t\n; (inc 2)      -> 3", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 95, "code": "(fn bin-tree? [tree] (or (nil? tree) (and (sequential? tree) (= 3 (count tree)) (bin-tree? (nth tree 1)) (bin-tree? (nth tree 2)))))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 95, "code": "(fn node? [coll]\n  (letfn [(node-or-nil? [a] (or (node? a) (nil? a)))]\n    (and (not (or (= coll true) (= coll false)))\n         (= (count coll) 3)\n         (node-or-nil? (second coll))\n         (node-or-nil? (nth coll 2)))))", "user": "57ed19a3e4b0bfb2137f5b8e"}, {"problem": 95, "code": "(fn pt [l]\n  (cond\n    (= false l) false\n    (not (coll? l))\n    true\n    (= (count l) 3)\n    (and (pt (first l))\n         (pt (second l))\n         (pt (last l)))\n    \n    :else false))", "user": "55a21f1ce4b0acc240e3151f"}, {"problem": 95, "code": "(fn n?\n  [n]\n  (or (and (not (coll? n))\n           (or n (nil? n)))\n      (and (coll? n)\n           (= 3 (count n))\n           (n? (second n))\n           (n? (last n)))))", "user": "4e77c1db535d324fb2983d72"}, {"problem": 95, "code": "(fn binary-tree? [s]\n  (or (nil? s)\n      (and (sequential? s)\n           (= (count s) 3)\n           (not (nil? (first s)))\n           (every? binary-tree? (rest s)))))", "user": "56f4cedce4b046a417f92063"}, {"problem": 95, "code": "(fn tree? [t]\n    (cond\n     (nil? t) true\n     (not (sequential? t)) false\n     (and (= 3 (count t))\n          (tree? (nth t 1))\n          (tree? (nth t 2))) true\n          :else false))", "user": "56a358d0e4b0542e1f8d14c9"}, {"problem": 95, "code": "(fn bin? [a](or (nil? a) (and (not= false a)(= 3 (count a)) (bin? (second a)) (bin? (last a)))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "58524875e4b0b7285a6f4ead"}, {"problem": 95, "code": "(fn arbol [li]\n    (if\n      (and \n         (sequential? li) \n         (= (count li) 3))\n           \n      (let [[n a b] li]\n           (and (arbol a) (arbol b)))\n      \n      (nil? li)))", "user": "4e6a5728535d8ccf87e9fecf"}, {"problem": 95, "code": "(fn tree? [[x y z :as all]] (and\n                         \t(= 3 (count all))\n                         \t(not (false? x))\n                         \t(if (coll? y) (tree? y) (not (false? y)))\n                         \t(if (coll? z) (tree? z) (not (false? z)))\n                         ))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55c66ffee4b0e31453f649c2"}, {"problem": 95, "code": "(fn istree? [root] (or (nil? root) (and (sequential? root) (= 3 (count root)) (every? istree? (rest root))       )    ))", "user": "57f9b25fe4b0d3187e90094b"}, {"problem": 95, "code": "(fn is-btree? [x]\n  (if (nil? x)\n    true\n    (if (and (sequential? x)\n             (= (count x) 3))\n      (and (is-btree? (-> x\n                          rest\n                          first))\n           (is-btree? (-> x\n                          rest\n                          rest\n                          first)))\n      false)))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 95, "code": "(fn h [tree]\n   (and (coll? tree)\n        (= 3 (count tree))\n        (every? (comp not false?)\n                (map\n                 #(if (coll? %)\n                    (h %)\n                    %)\n                 tree\n                 ))))", "user": "567b2f20e4b05957ce8c61a2"}, {"problem": 95, "code": "(fn [lis]\n  (let [pre #(and (sequential? %) (= 3 (count %)))]\n    (every? #(or (nil? %) (pre %))\n            (tree-seq pre rest lis))))", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 95, "code": "(fn tree? [c]\n    (or (nil? c)\n        (and (coll? c) (= (count c) 3)\n             (tree? (second c)) (tree? (last c)))))", "user": "5627444fe4b00e49c7cb47cd"}, {"problem": 95, "code": "(fn is_binary_tree [node]\n  (if (and (sequential? node) (= 3 (count node)))\n      (let [ [value, left, right] node ]\n        (and\n          (or (= nil left)  (is_binary_tree left))\n          (or (= nil right) (is_binary_tree right))))\n      false)\n    )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 95, "code": "(fn [i] (nil? ((fn tree [v]\n                  (cond (not= 3 (count v)) false\n                        (coll? (second v)) (tree (second v))\n                        (not (nil? (second v))) false\n                        (coll? (nth v 2)) (tree (nth v 2))\n                        (not (nil? (nth v 2))) false))i)))", "user": "57d0e185e4b0bd073c202360"}, {"problem": 95, "code": "(fn tree? [x]\n\t(or (nil? x) (and (coll? x) (= 2 (count (rest x))) (every? tree? (rest x)))))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 95, "code": "(fn [n]\n  (let [v (atom [])]\n    (letfn [(t [node]\n              (if (coll? node)\n                (if (= 3 (count node))\n                  (do\n                    (t (second node))\n                    (t (nth node 2))\n                    (swap! v conj true))\n                  (swap! v conj false))\n                (when (false? node)\n                  (swap! v conj false))))]\n      (t n)\n      (every? identity @v))))", "user": "51456858e4b0e88796073408"}, {"problem": 95, "code": "(fn [input] \n      (->> (tree-seq coll? identity input)\n        (filter coll?)\n        (map #(count (remove false? %)))\n        (filter #(not= 3 %))\n        empty?))", "user": "5582dfb6e4b05c286339e10d"}, {"problem": 95, "code": "(fn [s] (every? #(if (sequential? %) (= (count %) 3) (nil? %)) (tree-seq sequential? next s)))", "user": "4e11b92a535d04ed9115e7cb"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond (not (= (count s) 3)) false\n        (some false? (flatten s)) false\n        (some (partial = '()) s) false\n        :else true))", "user": "5804d5afe4b0a837a8b30cad"}, {"problem": 95, "code": ";Iteration 1\n;(fn is-binary-tree [b]\n;  (if (= b nil) true\n;    (if (and (sequential? b) (= 3 (count b)))\n;      (let [n (first b) l (second b) r (last b)]\n;              (and (is-binary-tree l) (is-binary-tree r))\n;      )\n;      false\n;    )\n;   )\n; )\n; Iteration 2 Better to structure it as conditionals as the code is more readable. \n; and name of the function is idiomatic to clojure.\n(fn binary-tree? [b]\n  (or (= b nil)\n    (and (sequential? b) \n         (= 3 (count b))\n       \t (binary-tree? (second b)) \n         (binary-tree? (last b))\n    )\n   )\n )", "user": "5722bf99e4b0c5bde472c0d6"}, {"problem": 95, "code": "(fn tree? [x]\n  (letfn [(has-3-elements [node]\n            (= (count node) 3))]\n\n    (cond (nil? x) true\n          (or (not (sequential? x))\n              (not (has-3-elements x))) false\n          :else (and (tree? (nth x 1))\n                     (tree? (nth x 2))))))", "user": "57ea4569e4b0bfb2137f5b46"}, {"problem": 95, "code": "(fn b [xs]\n   (or (nil? xs) (and (sequential? xs) (let [[_ l r] xs](and (== (count xs) 3) (b l) (b r))))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 95, "code": "(fn b-tree? [v]\n  (or (nil? v)\n      (and (sequential? v)\n           (= 3 (count v))\n           (b-tree? (second v))\n           (b-tree? (last v)))))", "user": "4f3ca5a6e4b0e243712b1f53"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n\t\t   (every? tree? (rest t)))))", "user": "581dad0ae4b04b46fc4b0f17"}, {"problem": 95, "code": "(fn btree?\n  [t]\n  (if (sequential? t)\n    (if (= (count t) 3)\n      (let [[k l r] t]\n        (and (btree? l) (btree? r)))\n      false)\n    (= t nil)))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 95, "code": "(fn tree? [xs](cond\n               (nil? xs) true\n               (not(counted? xs)) false\n               (== 3 (count xs)) (and(tree? (nth xs 1))(tree? (nth xs 2)))\n               :else false ))", "user": "57752a2de4b0979f89651613"}, {"problem": 95, "code": "(fn f [s] (or (nil? s) (and (coll? s) (= (count s) 3) (f (nth s 1)) (f (nth s 2)))))", "user": "587294f0e4b01531a375ea1e"}, {"problem": 95, "code": "(fn bintree? [tree] \n  (if (nil? tree)\n    true\n    (and\n     \t(sequential? tree)\n     \t(= 3 (count tree))\n     \t(every? bintree? (rest tree))\n\n     )\n   )\n  )", "user": "585bcd51e4b0f14aab7c8771"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (let [[_ left right] xs\n        valid-branch? (fn [branch]\n                        (or (nil? branch)\n                            (and (sequential? branch)\n                                 (binary-tree? branch))))]\n    (and (= 3 (count xs))\n         (valid-branch? left)\n         (valid-branch? right))))", "user": "57e9a77ae4b0bfb2137f5b35"}, {"problem": 95, "code": "(fn is-bin-tree [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= (count tree) 3)\n           (every? is-bin-tree (rest tree)))))", "user": "5784ff88e4b0ebec4cfb74d4"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (if (or (not (coll? t)) (not= (count t) 3))\n      false\n      (and (tree? (second t)) (tree? (last t))))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 95, "code": "(fn triple? [args]\n  (and (coll? args)\n    (= (count args) 3)\n    (every? triple? (remove nil? (next args)))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 95, "code": "(fn tree [s] (or (keyword? s) (number? s) (nil? s)\n                (and (coll? s)\n                     (= 3 (count s))\n                     (tree (first (rest s)))\n                     (tree (second (rest s))))))", "user": "4e3ac1b2535deb9a81d77f4c"}, {"problem": 95, "code": "(fn foo [node]\n  (or (nil? node)\n      (and (coll? node)\n       \t   (= 3 (count node))\n           (or (nil? (second node)) (foo (second node)))\n           (or (nil? (last node)) (foo (last node))))))", "user": "58740c18e4b01531a375ea49"}, {"problem": 95, "code": "(fn [n]\n  (let [x (count (flatten n))]\n    (if (odd? x)\n      (if (=  nil (nth  (flatten n) (int (/ x 2)))) true false)\n      false)))", "user": "582c526ae4b051871117bf88"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= (count root) 3)\n           (every? tree? (rest root)))))", "user": "53fc63dce4b0de5c4184859f"}, {"problem": 95, "code": "#(if (or (= (some #{()} (flatten %)) '()) (some false? (flatten %)))\n   false\n   (odd? (count(flatten %))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 95, "code": "(fn bintree? [c]\n  (if (sequential? c)\n    (and\n      (= (count c) 3)\n      (every? bintree? (rest c)))\n    (nil? c)))", "user": "50385746e4b0803468ea2c6d"}, {"problem": 95, "code": "(fn tree?\n  [node]\n  (let [len (if (coll? node) (count node) (if (nil? node) 0 1) )]\n    (case len\n      0 (if (coll? node) false true)\n      3 (and (tree? (second node)) (tree? (last node)))\n      false)))", "user": "588d0a52e4b05c141a2560a6"}, {"problem": 95, "code": "(fn t? [r]\n  (or (nil? r)\n      (and (sequential? r)\n           (= 3 (count r))\n           (every? t? (rest r)))))", "user": "5881335ce4b0f1effa3b762e"}, {"problem": 95, "code": "(fn tree? [t]\n    (if (nil? t) \n      true\n      (and (sequential? t)\n           (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 95, "code": "(fn t? [s]\n  (cond\n   (not= 3 (count s)) false\n   (some false? s) false\n   (coll? (second s)) (if (t? (second s)) \n                      (if (coll? (last s)) (t? (last s)) true)\n                      false)\n   (coll? (last s))\t(t? (last s))\n   :else true))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 95, "code": "(fn pred [s]\n  (cond\n   (not (sequential? s)) (= nil s)\n   (= 3 (count s)) (let [[_ l r] s] (and (pred l) (pred r)))\n   :else false))", "user": "58949f8de4b00487982d525e"}, {"problem": 95, "code": "(fn is-tree? [arg]\n  (cond\n   (not (coll? arg)) (nil? arg)\n   (not= (count arg) 3) false\n   :else (and (is-tree? (nth arg 1)) (is-tree? (nth arg 2)))))", "user": "571cd9dce4b0145328a76271"}, {"problem": 95, "code": "(fn [root]\n    (every?\n      #(or\n        (nil? %)\n        (and (sequential? %) (= 3 (count %))))\n      (tree-seq sequential? rest root)))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 95, "code": "(fn is-tree [tree]\n  (cond \n    (nil? tree) true\n    (sequential? tree) (and (= (count tree) 3) \n                            (is-tree (second tree)) \n                            (is-tree (last tree)))\n    :else false))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 95, "code": "(fn good? [st] (if (and (not (empty? st)) (odd? (count st)) (> (count st) 1))\n                (let [lr (rest st)] \n                  (println (first lr) \" : \" (second lr))\n                  (every? true? (for [n lr] (if (sequential? n) (good? n) (not= false n)))))\n                false))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "583e02fce4b089d5ab817da5"}, {"problem": 95, "code": "(fn tree? [t]                                        (cond (nil? t) true                                        (false? t) false                                     (not= (count t) 3) false                             (coll? (first t)) false                              :else                                                (every? tree? (next t))))", "user": "5895477fe4b00487982d527c"}, {"problem": 95, "code": "(fn this [node]\n  (or\n   (nil? node)\n   (and (sequential? node) (= 3 (count node))\n        (let [[_ left right] node] (and (this left) (this right))))))", "user": "58923efce4b00487982d521c"}, {"problem": 95, "code": "#(and (not (some false? (flatten %)))\n       (odd? (count (flatten %))))", "user": "576e607ae4b0979f89651579"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n    (= s nil) true\n    (not (coll? s)) false\n    (not= (count s) 3) false\n    true (let [[x0 x1 x2] s]\n           (and (tree? x1) (tree? x2)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 95, "code": "(fn funz\n  [x]\n    (and (or (and (coll? x ) (not (empty? x))) (nil? x))\n    (let [root (first x) args (rest x)]\n      (or\n        (and (nil? root) (= 0 (count args)))\n        (and (not (nil? root)) (= 2 (count args)) (and (funz (first args)) (funz (second args))))\n        ))))", "user": "58a6d14fe4b01a0c0b232935"}, {"problem": 95, "code": "(fn tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= (count coll) 3)\n           (every? tree? (rest coll)))))", "user": "588f500ae4b00487982d51a4"}, {"problem": 95, "code": "(fn is-binary-tree? [mytree]\n(let [list-of-nodes (tree-seq sequential? seq mytree) ]\n (if (and (not-any? false? (flatten mytree)) (every? #(= 3 %) (map count (filter sequential? list-of-nodes))))\n   true\n   false\n   )\n  )\n)", "user": "58a17511e4b02bd94d917eb4"}, {"problem": 95, "code": "(fn b [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (let [[_ l r] t]\n             (and (b l) (b r))))))", "user": "5458c74de4b01be26fd74623"}, {"problem": 95, "code": "(fn tree? [test-tree]\n  (and (= (count test-tree) 3) (not (coll? (first test-tree)))\n       (reduce\n        (fn [bool x]\n          (and bool (cond\n                     (nil? x) true\n                     (not (coll? x)) false\n                     :else (tree? x))))\n        true\n        (rest test-tree))))", "user": "57b356c2e4b0fbc9809a277b"}, {"problem": 95, "code": "(fn is-tree?\n  [[value & children]]\n  (= 2 (count (filter #(or (nil? %1) (is-tree? %1)) (remove false? children)))))", "user": "4fe899a6e4b07c9f6fd12c54"}, {"problem": 95, "code": "(fn tree?\n  [t]\n  (cond\n    (and (coll? t) (= 3 (count t)))\n    (and ((complement coll?) (first t))\n         (tree? (second t))\n         (tree? (last t)))\n\n    (nil? t)\n    true\n\n    :else\n    false))", "user": "5759c833e4b02ea11479932c"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (first t)\n           (tree? (second t))\n           (tree? (last t)))))", "user": "54f14aa6e4b024c67c0cf8af"}, {"problem": 95, "code": "(fn tree? [n]\n    (or (nil? n)\n        (and (coll? n)\n             (= 3 (count n))\n             (every? tree? (rest n)))))", "user": "557e8326e4b05c286339e0d7"}, {"problem": 95, "code": "(fn tree? [sq]\n  (cond\n    (nil? sq) true\n    (not (sequential? sq)) false\n    (not= (count sq) 3) false\n    :else (let [[_ snd trd] sq]\n            (and (tree? snd) (tree? trd)))))", "user": "588e4e05e4b00487982d5188"}, {"problem": 95, "code": "(fn [in]\n  (loop [nodes [in]]\n    (prn nodes)\n    (let [node (first nodes)]         \n      (if (empty? nodes)\n        (do\n         ;(prn \"shortcut\")\n         ;(prn node)\n         true)\n       (do\n        ;(prn node)\n        (if (or ; this list is all the ways a node could be invalid\n             (false? node)\n             (and\n              (not (coll? node)) ; node isn't a collection\n              (not (nil? node))) ; AND node isn't nil\n             (and\n              (coll? node) (not= (count node) 3)) ; collection node does not have three elements\n             (false? (first node)) ; first element is false\n             (coll? (first node))) ; first element is a collection\n         (do\n          (prn \"returning false\")\n          false)\n        ;this node is good, move on with the rest\n         (do \n          (prn \"recurring\") \n          (recur (into (rest nodes) (rest node))))))))))", "user": "56391b7ce4b0bfe05bf117ef"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (if\n    (and\n     tree\n     (= 3 (count tree)))\n    (and\n     (is-tree? (second tree))\n     (is-tree? (last tree)))\n    (= nil tree)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 95, "code": "(fn traverse [tree]\n  (if \n    (coll? tree) \n    (if \n      (= 3 (count tree))\n      (let \n        [[value left right] tree]\n          (and\n           (or (keyword? value) (number? value))\n           (if (nil? left) true (if (coll? left) (traverse left) false))\n           (if (nil? right) true (if (coll? right) (traverse right) false))\n           )\n          )\n      false\n      )\n    false\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 95, "code": "(fn bin-tree [xs]\n    (and (= 3 (count xs))\n             (or (= nil (nth xs 1))\n                 (and (sequential? (nth xs 1))\n                      (bin-tree (nth xs 1))))\n             (or (= nil (nth xs 2))\n                 (and (sequential? (nth xs 2))\n                      (bin-tree (nth xs 2)))))\n    )", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 95, "code": "#(letfn [\n(tree? [t]\n  (if (sequential? t)\n    (let [[v l r] t]\n      (if (and (sequential? t) (= 3 (count t)))\n        (and (or (nil? l) (tree? l))\n             (or (nil? r) (tree? r)))\n        false))\n    false))]\n (tree? %))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "58a44a14e4b01a0c0b2328f2"}, {"problem": 95, "code": "(fn btree? [col] (and (coll? col) (= (count col) 3) (or (nil? (second col)) (btree? (second col))) (or (nil? (last col)) (btree? (last col))))\n)", "user": "587ee260e4b052da650a6353"}, {"problem": 95, "code": "(fn myf \n  ([x]\n   (let [[v l r] x]\n     (and \n      (= (count x) 3)\n      (or (and (nil? l) (nil? r)) \n          (and (nil? l) (sequential? r) (myf r))\n          (and (nil? r) (sequential? l) (myf l))\n          (and (sequential? r) (sequential? l) (myf r) (myf l)))))))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 95, "code": "(fn is-binary-tree [coll]\n    (cond\n      (nil? coll) true\n      (coll? coll) (and (= (count coll) 3)\n                        (not (coll? (first coll)))\n                        (every? is-binary-tree (next coll)))\n      :else false))", "user": "58bbcbc8e4b0888cdc949d00"}, {"problem": 95, "code": "(fn tree [coll]\n  (let [inner-coll (first (filter coll? coll))\n        is-binary (odd? (count (filter #(and (not= % true) (not= % false)) (flatten coll))))]\n    (if (and is-binary (= (count inner-coll) 3))\n      (tree inner-coll)\n      is-binary)))", "user": "570e43d8e4b0b0fb43fd06eb"}, {"problem": 95, "code": "(fn tree? [x]\n  (cond\n    ((complement coll?) x)\n      (if (nil? x) true false)\n    ((complement =) (count x) 3)\n     false\n    :else\n      (and (tree? (nth x 1)) (tree? (nth x 2)))))", "user": "58c3af4de4b021aa9917ed1b"}, {"problem": 95, "code": "(fn check-tree [coll]\n  (cond (nil? coll) true\n        (not (coll? coll)) false\n        (not= (count coll) 3) false\n        :else (and (check-tree (second coll)) \n                   (check-tree (last coll)))\n        )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 95, "code": "(fn testi [t]\n  (if (= (count t) 3)\n    (let [[eka toka kolmas] t]\n      (and\n       (if (coll? toka)\n         (testi toka)\n         (if (nil? toka)\n           true\n           false))\n       (if (coll? kolmas)\n         (testi kolmas)\n         (if (nil? kolmas)\n           true\n           false))))\n    false))", "user": "57c314f3e4b05aa3c4741cba"}, {"problem": 95, "code": "(fn bin? [t]\n  (let [leaf? nil?\n        node? (every-pred coll? #(= (count %) 3) #(bin? (second %)) #(bin? (last %)))]\n \t((some-fn leaf? node?) t)))", "user": "58c7a80fe4b021aa9917ed7b"}, {"problem": 95, "code": "(fn my-tree? [coll]\n  (cond\n    (not (coll? coll)) (not (false? coll))\n    (= 3 (count coll)) (every? true? (map my-tree? coll))\n    :else false))", "user": "5599abc9e4b031d6649c9bb0"}, {"problem": 95, "code": "(fn btree [mytree]\n  (if-not (counted? mytree)\n    (not= false mytree)\n    (let [node (first mytree)\n          lefts (first (rest mytree))\n          rights (last (rest mytree))]\n      (letfn [(count3 [v] (or (nil? v) (= 3 (count v))))] \n        (and (count3 mytree) (btree node) (btree lefts) (btree rights))))))", "user": "57b35ecbe4b0fbc9809a277e"}, {"problem": 95, "code": "(fn [x]\n   (let [y (vals (group-by class (flatten x)))]\n     (if (not= (count y) 2)\n       false\n       (= (inc (count (first y))) (count (second y))))))", "user": "58b80ec1e4b0ebc645576d89"}, {"problem": 95, "code": "(fn bin-tree? [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= 3 (count tree))\n           (every? bin-tree? (rest tree)))))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n       \t   (= 3 (count root))\n           (and (tree? (second root))\n                (tree? (last root))))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (sequential? s)\n    (if (= 3 (count s))\n      (and (is-tree (second s)) (is-tree (nth s 2)))\n      false\n    )\n    (nil? s)))", "user": "58ca613de4b021aa9917edb7"}, {"problem": 95, "code": "#(every? (partial = 3) (map count (map (partial filter (comp not false?)) (filter sequential? (tree-seq sequential? seq %)))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 95, "code": ";to tree or not to tree\n(fn [t]\n  (letfn [(check-tree [tree] \n            (if (or\n                  (and \n                    (sequential? tree)\n                    (seq tree))\n                  (nil? tree))\n              (let [head (first tree)\n                    left (first (rest tree))\n                    right (second (rest tree))\n                    qt (count tree)]\n                (if (not (nil? head))\n                  (and (= 3 qt) (check-tree left) (check-tree right))\n                  true))\n              false))]\n    (check-tree t)))", "user": "58bc8cbee4b0888cdc949d1b"}, {"problem": 95, "code": "(fn tree?\n  ([[v l r :as a] ] (and (= 3 (count a)) (or (nil? l) (and (sequential? l) (tree? l))) (or (nil? r) (tree? r)))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 95, "code": "(fn tree? [t] (cond (nil? t) true (not (coll? t)) false (not= 3 (count t)) false :else (let [[_ l r] t] (and (tree? l) (tree? r)))))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 95, "code": "(fn ff [[root l r :as tree]]\n   (and (= 3 (count tree))        \n        (not (sequential? root))\n        (or (nil? l) (and (sequential? l) (ff l)))\n        (or (nil? r) (and (sequential? r) (ff r)))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 95, "code": "(fn btree? [ x ] \n(every? true? (map #(if (sequential? %) (= 3 (count %)) (nil? %)) (tree-seq sequential? rest x))))", "user": "57887de2e4b0ebec4cfb751c"}, {"problem": 95, "code": "(fn tree-recur [tree]\n  (cond\n     (nil? tree) true\n     (not (coll? tree)) false\n     (= 3 (count tree)) (let [[i lft rgt] tree]\n       (and (tree-recur lft) (tree-recur rgt)))\n     :else false))", "user": "57b35772e4b0fbc9809a277c"}, {"problem": 95, "code": "(fn is-bin-tree [xs]\n  (cond (coll? xs) (if (= 3 (count xs)) (and (is-bin-tree (nth xs 1)) (is-bin-tree (nth xs 2))) false)\n        :else (nil? xs)))", "user": "58cf00c8e4b03c36ff7e58ac"}, {"problem": 95, "code": "(fn t [tree]\n  (letfn [(binary-tree? [tree]\n            (if (nil? tree)\n              true\n              (if (and (coll? tree) (= (count tree) 3))\n                (and (binary-tree? (second tree)) (binary-tree? (nth tree 2)))\n                false))\n            )]\n    (binary-tree? tree)))", "user": "58de563fe4b0a4d5acaab6e3"}, {"problem": 95, "code": "#(letfn [(bt? [coll] (if (not (coll? coll)) ((complement false?) coll) (if (or (not= 3 (count coll)) (coll? (first coll))) false (and (bt? (first (next coll))) (bt? (last coll))))))] (bt? %))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 95, "code": "(fn f [l]\n  (cond\n    (nil? l) true\n    (and (coll? l) (= 3 (count l))) (and\n                                     (f (nth l 1))\n                                     (f (nth l 2)))\n    :else false))", "user": "58b86162e4b0ebc645576d97"}, {"problem": 95, "code": "(fn tree? [coll]\n   (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 95, "code": "(fn is-valid-bintree [xs]\n  (or (nil? xs)\n      (and (coll? xs)\n           (= 3 (count xs) )\n           (is-valid-bintree (second xs))\n           (is-valid-bintree (last xs)))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 95, "code": "(fn f [s] (if (coll? s)\n                  (and (= (count s) 3)\n                       (not (coll? (first s)))\n                       (every? f (rest s)))\n                  (nil? s)))", "user": "58c4b11ae4b021aa9917ed2c"}, {"problem": 95, "code": "#(letfn [(tree-detect [[a b c :as xs]] (and (= 3 (count xs)) (not (sequential? a)) (if (nil? b) true (if (sequential? b) (tree-detect b) false)) (if (nil? c) true (if (sequential? c) (tree-detect c) false))))] (tree-detect  %))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 95, "code": "(fn[x]\n  (letfn [(check-branch[branch acc clazz]\n            (if (= 3 (count branch))\n              (let [[node L R] branch]\n                (conj  (conj acc (if (sequential? L)\n                                   (check-branch L acc clazz)\n                                   (if (or (nil? L) (= clazz (type L)))\n                                     true\n                                     false)))\n                       (if (sequential? R)\n                         (check-branch R acc clazz)\n                         (if (or (nil? R)  (= clazz (type R)))\n                           true\n                           false))))\n              (conj acc false)))]\n    (every? true? (flatten (check-branch x [] (type (first x)))))))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 95, "code": "(fn isBinaryTree [v] (\n\n            cond\n                  (counted? v)\n                    (and\n                      (= 3 (count v))\n                      (isBinaryTree (nth v 1))\n                      (isBinaryTree (nth v 2))\n                      )\n                  (instance? Boolean  v) v\n                  :else true\n              ))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 95, "code": "(fn tree? [coll]\n  (and (= 3 (count coll))\n       (every? tree? (filter coll? coll))\n       (every? #(or (nil? %) (coll? %)) (rest coll))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 95, "code": "(fn check [x] (if (coll? x) (and (= (count x) 3) (every? true? (map check x))) (and (not (list? x)) (not (false? x)))))", "user": "58e762d3e4b056aecfd47ccc"}, {"problem": 95, "code": "(fn tree? [tree]\n   (if (coll? tree)\n     (if (= 3 (count tree))\n       (every? tree? (rest tree))\n       false)\n     (nil? tree)))", "user": "588906a9e4b0f1effa3b772a"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= 3 (count x))\n           (every? tree? (rest x)))))", "user": "58e58ae9e4b056aecfd47c9a"}, {"problem": 95, "code": "(fn binary-tree? [seq]\n  (or (nil? seq)\n      (and (sequential? seq)\n           (= (count seq) 3)\n           (binary-tree? (second seq))\n           (binary-tree? (last seq)))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (coll? x)\n       \t   (= (count x) 3)\n           (every? tree? (rest x)))))", "user": "57fdd1cfe4b0d3187e9009bf"}, {"problem": 95, "code": "(fn bintree? [node]\n    (or (nil? node)\n        (and (coll? node)\n             (let [[value & more] node]\n               (and (= 2 (count more))\n                    (every? bintree? more)\n                    )\n               )\n             )\n        )\n    )", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 95, "code": "(fn tree? [node]\n         (cond\n           (nil? node) true\n           (sequential? node) (and (= 3 (count node))\n                                   (every? tree? (rest node)))\n           :else false))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 95, "code": "(fn isTree? [node]\n         (or (nil? node)\n             (and (sequential? node)\n                  (= 3 (count node))\n                  (not (nil? (first node)))\n                  (isTree? (nth node 1))\n                  (isTree? (last node)))))", "user": "58c4492be4b021aa9917ed27"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (tree? (second t))\n           (tree? (last t)))))", "user": "58ef4db9e4b056aecfd47dc6"}, {"problem": 95, "code": "(fn tree? [[value left right :as node]]\n  (and\n    (= (count node) 3)\n    (not (symbol? value))\n    (or (nil? left) (and (sequential? left) (tree? left)))\n   \t(or (nil? right) (and (sequential? right) (tree? right)))))", "user": "58ee5371e4b056aecfd47da8"}, {"problem": 95, "code": "(fn b-tree?\n  [t]\n  (and\n   (sequential? t)\n   (= 3 (count t))\n   (let\n     [node? #(or (nil? %) (b-tree? %))]\n     (and\n      (node? (second t))\n      (node? (last t))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 95, "code": "(fn bin-tree? [tree]\n  (if (coll? tree)\n    (and (= 3 (count tree))\n         (bin-tree? (second tree))\n         (bin-tree? (last tree)))\n    (nil? tree)))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 95, "code": "#(odd? (count (remove false? (flatten %))))", "user": "587a3babe4b01531a375eae2"}, {"problem": 95, "code": "(fn f [v]\n  (or (nil? v)\n      (number? v)\n  \t  (and (coll? v)\n           (= 3 (count v))\n\t\t   (f (nth v 1))\n\t\t   (f (nth v 2)))))", "user": "58fdbf59e4b0438e51c2cfbc"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 95, "code": "(fn prob95 [colll]\n  (if (coll? colll)  \n    (let [[rootT leftT rightT] colll]\n      (if (= 3 (count colll))\n        (and (prob95 rootT) (prob95 leftT) (prob95 rightT))\n        false))\n    (if (= false colll) false true)))", "user": "58e6a2c5e4b056aecfd47cba"}, {"problem": 95, "code": "(fn tree? [tree] \n  (if-not (sequential? tree)\n    (not= false tree)\n    (if (not= (count tree) 3)\n      false\n      (let [[node left right] tree]\n        (if (sequential? node)\n          false\n          (and (tree? left) (tree? right)))))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 95, "code": "(fn tree? [x] \n  (or (nil? x)\n      (and (-> x sequential?)\n           (-> x count (= 3)) \n           (-> x first nil? not)  \n           (-> x second tree?)  \n           (-> x last tree?))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 95, "code": "(fn tree[bin]\n  (if (sequential? bin)\n    (if (= 3 (count bin))\n      (and (tree (nth bin 1)) (tree (nth bin 2)))\n      false)\n    (if (nil? bin)\n        true\n        false)))", "user": "585a7cb2e4b0f14aab7c874e"}, {"problem": 95, "code": "(fn __ [se]\n   (or\n     (nil? se)\n     (and\n       (sequential? se)\n       (= (count se) 3)\n       (boolean (first se))\n       (__ (nth se 1))\n       (__ (nth se 2)))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 95, "code": "(fn is-tree [node]\n    (or\n      (nil? node)\n      (and\n        (coll? node)\n        (= 3 (count node))\n        (is-tree (nth node 1))\n        (is-tree (nth node 2)))))", "user": "5901158de4b0438e51c2d039"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and\n        (sequential? root)\n        (= 3 (count root))\n        (every? tree? (rest root)))))", "user": "565487dce4b0f9d632dd8482"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (and\n      (counted? t)\n      (= (count t) 3)\n      (tree? (second t))\n      (tree? (last t)))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 95, "code": "(fn foo [t]\n  (if (= t nil)\n       true\n       (and (coll? t)\n        \t(= (count t) 3)\n            (foo (second t))\n            (foo (last t)))))", "user": "59156f0be4b0163c97b36f3d"}, {"problem": 95, "code": "(fn btree-node? [root]\n  (and (= 3 (count root))\n       (every? #(or (nil? %)\n                    (and (sequential? %)\n                         (btree-node? %)))\n               (rest root))))", "user": "53e4b5a3e4b036ad0777e44b"}, {"problem": 95, "code": "(fn r [x]\n  (or (= x nil)\n      (and (coll? x)\n\t   (= (count x) 3)\n\t   (every? r (rest x)))))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 95, "code": "(fn tree?\n  [t]\n  (let [node (first t),\n        children (rest t)]\n    (every? true?\n            (flatten\n             (if (= (count children) 2)\n               (for [c children]\n                 (cond\n                   (seq? c) (tree? c)\n                   (vector? c) (tree? c)\n                   (not (nil? c)) [false]\n                   :else true))\n               [false])))))", "user": "58cff8b0e4b03c36ff7e58c0"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (coll? coll)\n    (if (= (count coll) 3)\n      (and (tree? (second coll)) (tree? (last coll)))\n      false)\n    (nil? coll)))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 95, "code": "(fn is-bin-tree? [tree]\n  (if (nil? tree)\n    true\n    (and (sequential? tree)\n         (= 3 (count tree))\n         (is-bin-tree? (first (rest tree)))\n         (is-bin-tree? (second (rest tree))))))", "user": "55f5b8d6e4b06e875b46ce8d"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t) \n           (= 3 (count t))\n           (tree? (nth t 1))\n           (tree? (nth t 2)))))", "user": "5398305fe4b0b51d73faaef6"}, {"problem": 95, "code": "(fn is-node? [x]\n  (and (coll? x)\n    (= 3 (count x))\n    (not (coll? (first x)))\n    (or (nil? (second x)) (is-node? (second x)))\n    (or (nil? (last x)) (is-node? (last x)))))", "user": "59074b7ce4b047aa04b19951"}, {"problem": 95, "code": "(fn tree-check [t]\n  (if (not= 3 (count t))\n    false\n    (let [[n left right] t]\n      (cond (and (nil? left) (nil? right)) true\n            (and (coll? left) (coll? right)) (and (tree-check left) (tree-check right))\n            (coll? left) (tree-check left)\n            (coll? right) (tree-check right)\n            :else false))))", "user": "58d48df8e4b03c36ff7e5941"}, {"problem": 95, "code": "(fn tree? [tree]\n  (cond\n    (= nil tree) true\n    (and (coll? tree) (= 3 (count tree))) (and (tree? (second tree)) (tree? (last tree)))\n    :else false))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 95, "code": "(fn binary-tree?\n  [node]\n  (let [three? (fn [a]  (= (count node) 3))\n        check-node (fn [a] (if (sequential? a)\n                               (binary-tree? a)\n                               (nil? a)))]\n       (and (three? node)\n            (and (check-node (second node)) \n                 (check-node (last node))))))", "user": "59076082e4b047aa04b19956"}, {"problem": 95, "code": "(fn bin-tree? [s]\n  (or\n    (nil? s)\n    (and\n      (coll? s)\n      (= (count s) 3)\n      (bin-tree? (second s))\n      (bin-tree? (nth s 2))\n      )))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 95, "code": "(fn ! [node]\n  (and (coll? node)\n       (= 3 (count node))\n       (not (coll? (first node)))\n       (or (nil? (second node)) (! (second node)))\n       (or (nil? (nth node 2)) (! (nth node 2)))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 95, "code": "(fn is-b [t]\n    (cond (nil? t) true\n          (coll? t) (let [[n l r] t]\n                  (and (= (count t) 3) (not (nil? n)) (is-b l) (is-b r)))\n          :else false)\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 95, "code": "(fn valid-node? [node]\n  (or (nil? node)\n\t  (and (sequential? node)\n           (= 3 (count node))\n           (not (nil? (nth node 0)))\n           (valid-node? (nth node 1))\n           (valid-node? (nth node 2)))))", "user": "4e6fe3a6535d5021c1a89629"}, {"problem": 95, "code": "(fn is-tree? [coll]\n  (if (nil? coll)\n      true\n      (cond\n        (coll? coll) (and (= 3 (count coll)) \n                          (is-tree? (nth coll 1)) (is-tree? (nth coll 2)))\n        :default false)))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 95, "code": "(fn a [b]\n  (if (sequential? b)\n    (and (= (count b) 3) (every? true? (map a (rest b))))\n    (nil? b)))", "user": "58b54852e4b0ebc645576d52"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n(every? istree? (rest root)))))", "user": "591d9870e4b09b4ee5954c1b"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (coll? t)\n    (and (= 3 (count t)) (tree? (second t)) (tree? (nth t 2)))\n    (nil? t)))", "user": "586bc870e4b01531a375e964"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (or (= nil t) (and (sequential? t) (= 3 (count t)) (every? tree? (rest t))))\n    true \n    false))", "user": "59368ccae4b02506e01a297a"}, {"problem": 95, "code": "(fn bt [c]\n  (and\n   (= 3 (count c))\n   (or (nil? (second c)) (and (second c) (bt (second c))))\n   (or (nil? (last   c)) (and (last   c) (bt (last   c))))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 95, "code": "(fn tree [coll]\n  (let [inner-coll (first (filter coll? coll))\n        is-binary (odd? (count (filter #(and (not= % true) (not= % false)) (flatten coll))))]\n    (if (and is-binary (= (count inner-coll) 3))\n      (tree inner-coll)\n      is-binary)))", "user": "59251947e4b072a2710fce69"}, {"problem": 95, "code": "(fn tree- [coll]\n  (if (= 3 (count (remove false? coll)))\n    (if (and (empty? (filter coll? coll)))\n      true\n      (first (map #(tree- %) (filter coll? coll))))\n    false))", "user": "57b19fa1e4b0fbc9809a2754"}, {"problem": 95, "code": "(fn bin? [coll]\n    (if (coll? coll) \n      (and (= 3 (count coll))\n              (every? bin? coll))\n      (-> coll false? not))\n    )", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 95, "code": "(fn tree [coll]\n  (let [inner-coll (first (filter coll? coll))\n        is-binary (odd? (count (filter #(and (not= % true) (not= % false)) (flatten coll))))]\n    (if (and is-binary (= (count inner-coll) 3))\n      (tree inner-coll)\n      is-binary)))", "user": "592518bfe4b072a2710fce65"}, {"problem": 95, "code": "(fn tree? [maybe-a-tree] (every? identity\n                               [(= (count maybe-a-tree) 3)\n                                (every?\n                                 #(or (nil? %)(and (coll? %) (tree? %)))\n                                  (rest maybe-a-tree))]))", "user": "5885cc62e4b0f1effa3b76c1"}, {"problem": 95, "code": "(fn tree? [t]\n   (if (not (coll? t))\n     false\n     (if (not= (count t) 3)\n       false\n       (and\n        (first t)\n        (or (nil? (nth t 1)) (tree? (nth t 1)))\n        (or (nil? (nth t 2)) (tree? (nth t 2)))))))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 95, "code": "(fn is-tree [tree]\n  (cond\n   (nil? tree) true\n   (and (sequential? tree) (= 3 (count tree)))\n        (and\n         (or\n          (number? (first tree))\n          (keyword? (first tree)))\n   \t\t (and (is-tree (second tree)) (is-tree (last tree))))\n   :else false))", "user": "5833a6d8e4b089d5ab817ca2"}, {"problem": 95, "code": "(fn istree? [root]\n          (or (nil? root)\n              (and (sequential? root)\n                   (= 3 (count root))\n                   (every? istree? (rest root)))))", "user": "59438419e4b060784b3b7929"}, {"problem": 95, "code": "(fn tree? [node]\n  (cond\n   (nil? node) true\n   (not (sequential? node)) false\n   (not= 3 (count node)) false\n   :else\n    (let [left (nth node 1)\n          right (nth node 2)\n        ]\n      (and (tree? left)\n           (tree? right)\n      )\n    )\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (let [valid-child? (fn [branch]\n                       (and (not= false branch)\n                            (or (not (coll? branch)) (binary-tree? branch))))]\n    (and (= 3 (count tree)) (valid-child? (nth tree 1)) (valid-child? (nth tree 2)))))", "user": "57b7de74e4b0fbc9809a27d4"}, {"problem": 95, "code": "(fn bintree? [tree]\n  (cond\n    (nil? tree) true\n    (not (sequential? tree)) false\n    (not (= (count tree) 3)) false\n    (sequential? (first tree)) false\n    :else (let [left (first (rest tree))\n                right (first (rest (rest tree)))]\n            (and (bintree? left)\n                 (bintree? right)))))", "user": "56326995e4b0bfe05bf117a3"}, {"problem": 95, "code": "(fn tree? [a] (if (coll? a) (and (= 3 (count a)) (let [[x y z] a] (and (tree? y) (tree? z)))) (nil? a)))", "user": "593dfe60e4b069cdc2982bb1"}, {"problem": 95, "code": "(fn istree? [root]\n             (or (nil? root)\n                 (and (sequential? root)\n                      (= 3 (count root))\n                      (every? istree? (rest root)))))", "user": "541f89a5e4b01498b1a71a99"}, {"problem": 95, "code": "(fn b-tree? \n  [node]\n  (cond  \n    (nil? node) true \n    \n    (and (coll? node) (= (count node) 3)) \n    (let [l (second node) \n          r (second (rest node))] \n      (and (b-tree? l) (b-tree? r))) \n    \n    :else false))", "user": "55216aa5e4b0882d96d09192"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "592518cde4b072a2710fce66"}, {"problem": 95, "code": "(fn f [[v l r :as n]]\n  (cond\n   (nil? n) true\n   (false? l) false\n   (not (= 3 (count n))) false\n   :else (and (f l) (f r))))", "user": "519e70d5e4b0acf32bc6a42c"}, {"problem": 95, "code": "(fn btree? [t]\n  (if (nil? t)\n    true\n    (and\n      (sequential? t)\n      (= (count t) 3)\n      (btree? (second t))\n      (btree? (last t)))))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 95, "code": "(fn bindrvo [[a b c :as drvo]]\n  (if (= (count drvo) 3)\n    (cond\n      (and (not (coll? a)) (nil? b) (nil? c)) true\n      (coll? b) (bindrvo b)\n      (coll? c) (bindrvo c)\n      :else false\n      )\n    false))", "user": "584d99c5e4b0b7285a6f4e42"}, {"problem": 95, "code": "(fn istree? [coll]\n(or (nil? coll)\n(and (sequential? coll)\n(= (count coll) 3)\n(every? istree? (rest coll)))))", "user": "5950f0bfe4b066ee0a44ae9f"}, {"problem": 95, "code": "(fn is-tree [tree]\n  (if (not (coll? tree))\n    (= tree nil)\n    (if (not (= (count tree) 3))\n      false\n      (let [left (nth tree 1) right (nth tree 2)]\n        (and (is-tree left) (is-tree right))))))", "user": "594c0bd7e4b07ddc2dafae56"}, {"problem": 95, "code": "(fn isNode [n]\n  (or (nil? n) (and (sequential? n) (= (count n) 3) (isNode (nth n 1)) (isNode (nth n 2)))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "592518e8e4b072a2710fce67"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 95, "code": "(fn bin-tree? [t]\n  (cond\n   (false? t) false\n   (not (coll? t)) true\n   (= 3 (count t)) (and (bin-tree? (first t))\n                        (bin-tree? (second t))\n                        (bin-tree? (last t)))\n   :else false))", "user": "556ff203e4b09a3098a52526"}, {"problem": 95, "code": "(fn tree? [node]\n  (if (nil? node) \n    true\n    (if (or (not (coll? node)) (empty? node) (not= 3 (count node)))\n      false\n      (and (tree? (nth node 1)) (tree? (nth node 2))))))", "user": "5956c6dae4b066ee0a44af61"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (nil? t) \n    true\n   (if (and (or (list? t) (vector? t)) (= (count t) 3))\n     (and (tree? (nth t 1)) (tree? (nth t 2)))\n     false)))", "user": "594bd637e4b07ddc2dafae41"}, {"problem": 95, "code": "(fn tree? [coll]\n  (->> coll\n       (clojure.walk/prewalk\n         (fn [i]\n           (println i \": \" (and (sequential? i)\n                                (not= (count i) 3)))\n           (if (and (sequential? i)\n                    (not= (count i) 3))\n             false\n             i)))\n       (vector)\n       flatten\n       (some false?)\n       not\n       boolean))", "user": "5541fa50e4b0a04f79299515"}, {"problem": 95, "code": "(fn ? [t]\n  (or (and (coll? t)\n           (= (count t) 3)\n           (every? ? (rest t)))\n      (nil? t)))", "user": "58bcea23e4b0888cdc949d23"}, {"problem": 95, "code": "(fn b? [t]\n  (if (seq t)\n    (and (= (count t) 3)\n         (every? #(or (nil? %) (coll? %)) (rest t))\n         (every? b? (filter coll? (rest t))))\n    (not (coll? t))))", "user": "594880ade4b07ddc2dafadc2"}, {"problem": 95, "code": "(fn bin-tree? [node]\n  (or\n    (nil? node)\n    (and\n      (coll? node)\n      (let [[value left right] node]\n        (and\n          (= 3 (count node))\n          (bin-tree? left)\n          (bin-tree? right))))))", "user": "5885bea8e4b0f1effa3b76bf"}, {"problem": 95, "code": "(fn t [x] (or (nil? x) (and (coll? x) (= (count x) 3) (t (fnext x)) (t (last x)))))", "user": "59638af5e4b066ee0a44b0cc"}, {"problem": 95, "code": "#(= #{2} \n    (set \n     (map \n      count \n      (map \n       (fn [x] (drop-while false? x)) \n       (map rest \n            (filter sequential? (tree-seq sequential? seq %)))))))", "user": "59473563e4b07ddc2dafad97"}, {"problem": 95, "code": "(fn bin-tree? [bt] \n  (and\n   (or (list? bt) (vector? bt))\n   (= (count bt) 3)\n   (every? #(or (nil? %) (bin-tree? %)) (rest bt))))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (and (coll? t) (= (count t) 3)) (let [[v lt rt] t]\n                                          (and (tree? lt) (tree? rt)))\n        :else false))", "user": "595fd721e4b066ee0a44b06e"}, {"problem": 95, "code": "(fn tree? \n  ([value left-child right-child] \n     (and (tree? value) (tree? left-child) (tree? right-child)))\n  ([value child] false)\n  ([value] (if (sequential? value) \n               (if (= 3 (count value))\n                   (tree? (first value) (second value) (last value))\n                   false)\n               (if (false? value) false true)))\n  )", "user": "58fc52cee4b0438e51c2cf95"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n   (or (seq? s) (vector? s))\n   (and (= (count s) 3) (tree? (second s)) (tree? (last s)))\n   (nil? s) true\n   :else false))", "user": "59390a35e4b02506e01a29f3"}, {"problem": 95, "code": "(fn btree? [coll]\n    (letfn [(node? [n]\n              (or (nil? n)\n                 (and (coll? n)\n                      (= 3 (count n))\n                      (node? (second n))\n                      (node? (last n)))))]\n      (and (coll? coll)\n           (node? coll))))", "user": "594bc16be4b07ddc2dafae39"}, {"problem": 95, "code": "(fn tree? [tree]\n\t\t         (if (coll? tree)\n    \t             (and (= (count tree) 3)\n    \t\t \t              (not (some false? tree))\n                              (and \n                                   (tree? (second tree))\n                                   (tree? (last tree))))\n    \t             true))", "user": "593744abe4b02506e01a299b"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "55842bd7e4b05c286339e11c"}, {"problem": 95, "code": "(fn[tr]\n        (let [tre (rest (tree-seq sequential? seq tr))]\n\n                (if (= (+ (count (filter sequential? tre)) 1)\n                        (- (count (filter nil? tre)) 1)\n                        (count (filter (complement sequential?) (remove nil? tre)))  )\n                        true\n                false\n                )\n\n        )\n)", "user": "59692530e4b069c0a1a197e4"}, {"problem": 95, "code": "(fn p95 [x]\n  (cond\n   (false? x) false\n   (not (coll? x)) true\n   (not= (count x) 3) false\n   :else (and (p95 (second x)) (p95 (nth x 2)))))", "user": "593910eae4b02506e01a29f4"}, {"problem": 95, "code": "(fn t [x]\n  (or (nil? x)\n      (and (coll? x)\n        (let [[v l r] x]\n          (and true v (= (count x) 3) (t l) (t r))))\n      false))", "user": "539f4e9ee4b0ca733b974498"}, {"problem": 95, "code": "(fn solution95\n  [tree]\n  (if (nil? tree)\n    true\n    (if (or (and ((complement vector?) tree) ((complement list?) tree)) (not= 3 (count tree)))\n      false\n      (and (solution95 (last tree))\n           (solution95 (get tree 1))))))", "user": "595bc925e4b066ee0a44afe2"}, {"problem": 95, "code": "(fn eval-node [node]\n  (cond\n    (false? node) false\n    (not (sequential? node)) true\n    (not (= 3 (count node))) false\n    :else (let [[a b c] node]\n      (if (sequential? a)\n        false\n        (and (eval-node b) (eval-node c))))))\n\n\n\n;(fn istree? [root]\n;  (or (nil? root)\n;      (and (sequential? root)\n;           (= 3 (count root))\n;           (every? istree? (rest root)))))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 95, "code": "(fn tree? [s]\n  (if (and (= 3 (count s)) \n           (every? #(or (nil? %) (coll? %)) (rest s)))\n    (if (some coll? s)\n      (every? tree? (filter coll? s))\n      true)\n    false))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 95, "code": "(fn b? [[v & [c1 c2 :as cn]]]\n  (and (boolean v)\n       (= 2 (count cn))\n       (or (nil? c1) (and (coll? c1) (b? c1)))\n       (or (nil? c2) (and (coll? c2) (b? c2)))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 95, "code": "(fn check-bintree [coll]\n        (and (= 3 (count coll))\n             (every? #(or (nil? %) (coll? %)) (rest coll))\n             (every? true?\n                     (map check-bintree\n                          (filter coll? coll)))))", "user": "540c54a7e4b0addc1aec6700"}, {"problem": 95, "code": "(fn [coll]\n  (let [a (flatten coll)\n        b (count a)\n        c (count (filter #(nil? %) a))\n        d (count (filter #(not (nil? %)) a))]\n    (if (and (odd? b)(> c d)) true false)))", "user": "5935151ee4b072a2710fd084"}, {"problem": 95, "code": "(fn is-binary? [tree]\n  (letfn [(valid-node? [node]\n            (if (sequential? node)\n              (and (= (.size node) 3)\n                   (or (nil? (second node)) (sequential? (second node)))\n                   (or (nil? (nth node 2)) (sequential? (nth node 2))))\n              true))]\n    (not-any? (complement valid-node?) (tree-seq sequential? identity tree))))", "user": "54a96a15e4b09f271ff37cad"}, {"problem": 95, "code": "(fn tree? [l]\n  (or (nil? l)\n      (and (coll? l)\n       \t   (= 3 (count l))\n           (tree? (second l))\n           (tree? (nth l 2))\n           )\n  ))", "user": "594263cbe4b060784b3b790a"}, {"problem": 95, "code": "(fn check-tree\n  [inp]\n  (let [res ((fn traverse [coll] (if (and (coll? coll) (= 3 (count coll)))\n                                   (map #(if-not (= % nil)\n                                           (traverse %))\n                                        (rest coll))\n                                   '(false))) \n             inp)]\n    (-> res\n        flatten\n        set\n        (contains? false)\n        not)))", "user": "53f5c402e4b0db01ade6f9d4"}, {"problem": 95, "code": "(fn bin-tree? [[v l r :as c]]\n   (and\n     (= 3 (count c))\n     (not (nil? v))\n     (if (coll? l) (bin-tree? l) (nil? l))\n     (if (coll? r) (bin-tree? r) (nil? r))))", "user": "5978c844e4b01722bebd4d18"}, {"problem": 95, "code": "(fn tree? [n]\n  (or\n    (nil? n)\n    (and\n      (sequential? n)\n      (= 3 (count n))\n      (tree? (second n))\n      (tree? (nth n 2)))))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5884f377e4b0f1effa3b76a8"}, {"problem": 95, "code": "(fn is-bin [tree]\n  (if (and (not (vector? tree)) (not (list? tree))) (= nil tree)\n      (if (not= 3 (count tree)) false\n          (let [[vl left right] tree]\n            (and (is-bin left) (is-bin right))))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 95, "code": "(fn bt[t] (\n        if (nil? t)\n        true\n        (\n        if (and (counted? t) (= 3 (count t)))\n          (and (bt (nth t 1)) (bt (nth t 2)))\n          false\n          )\n             ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 95, "code": "(fn tree?\n\t[sqnc]\n\t(if (coll? sqnc)\n    \t(if (= (count sqnc) 3)\n        \t(let [[_ L R] sqnc]\n            \t(and (tree? L) (tree? R))\n            )\n        \tfalse\n        )\n  \t\t(= sqnc nil)\n    )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 95, "code": "(fn ez [coll] \n     (if (or (vector? coll)(list? coll))\n    ;collection\n      (cond \n         (not= (count coll) 3) false\n         (seq? (first coll))   false\n         ;(not-every? seq? coll) true\n         :else  (and (ez (second coll) ) (ez (nth coll 2) ))\n        )\n    \n    ;not collection\n     (not (instance? Boolean coll))\n    \n    ))", "user": "598085e6e4b021a7a535fdd3"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5964f9b0e4b069c0a1a19778"}, {"problem": 95, "code": "(fn tree? [xs] (cond (nil? xs) true (or (not (coll? xs)) (not= (count xs) 3)) false :else (let [[v l r] xs] (and (tree? l) (tree? r)))))", "user": "50aa777fe4b056ee01935866"}, {"problem": 95, "code": "(fn function-95\n  [seq1]\n  (if (= 3 (count seq1))\n    (if (nil? (second seq1))\n      (if (nil? (last seq1))\n        true\n        (if (sequential? (last seq1))\n          (function-95 (last seq1))\n          false)\n        )\n      (if (sequential? (second seq1))\n        (function-95 (second seq1))\n        false))\n    false)\n  )", "user": "598d0dc3e4b02b9968b84d18"}, {"problem": 95, "code": "(fn bin\n    [n]\n    (let [items (->> (flatten n)\n                     count)\n          nils (->> (flatten n)\n                    (filter nil?)\n                    count)]\n                  (and (odd? items) (or (= nils 2) (and (odd? nils) (> nils 1))))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 95, "code": "(fn [tree]\n  (every? true?\n          ((fn foo2 [tree]\n            (cond (coll? tree)\n                  (if (or (contains? (set tree) false)\n                          (contains? (set tree) '())) [false]\n                      (if (or (empty? tree)\n                              (= (count tree) 3))\n                        (mapcat foo2 (rest tree))\n                        [false]))\n                  :else (foo2 (rest tree)))) tree)))", "user": "58ffaddee4b0438e51c2cffe"}, {"problem": 95, "code": "(fn is-binary-tree? [seqq]\n  (cond\n   \t(or (seq? seqq) (vector? seqq))\n      (and (= (count seqq) 3) (is-binary-tree? (nth seqq 1)) (is-binary-tree? (nth seqq 2)))\n    (nil? seqq) true\n  \t:else false \n  )\n)", "user": "59971e2de4b07157cc8daacc"}, {"problem": 95, "code": "(fn aaa [x] (if (sequential? x) (if (not= 3 (count x)) false\n                                                         (and (if (nil? (nth x 1)) true (aaa (nth x 1)))\n                                                              (if (nil? (nth x 2)) true (aaa (nth x 2))))) false))", "user": "598d22b1e4b02b9968b84d1a"}, {"problem": 95, "code": "#(->> (tree-seq coll? identity %)\n      (filter coll?)\n      (every? (fn [[a b c :as s]] (and (= 3 (count s)) (not (coll? a))\n                                       (or (coll? b) (nil? b)) (or (coll? c) (nil? c))))))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 95, "code": "(fn istree [root]\n    (or\n      (nil? root)\n      (and                \n        (coll? root)\n        (= 3 (count root))\n          (every? istree (rest root))\n        )\n      )\n    )", "user": "59551e04e4b066ee0a44af20"}, {"problem": 95, "code": "(fn bt [node] \n  (or (nil? node) \n      (and (coll? node)\n           (= 3 (count node)) \n           (every? bt (rest node)))))", "user": "5989e080e4b021a7a535fed6"}, {"problem": 95, "code": "(fn binTree? [args]\n  (if (and (coll? args) (= (count args) 3))\n    (let [[root left right] args] (and (-> root coll? not) (binTree? left) (binTree? right)))\n    (nil? args)))", "user": "59a72effe4b066c664927d94"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n   (nil? t)\n   true\n   \n   (and (coll? t) (= (count t) 3))\n   (let [[_ left right] t]\n     (and (tree? left) (tree? right)))\n   \n   :else\n   false))", "user": "59ad8695e4b0e1f4e384c887"}, {"problem": 95, "code": "(fn tree?\n  ([tree] (tree? tree true))\n  ([tree res]\n   (and\n    (= 3 (count tree))\n     (reduce #(and\n            %1\n            (cond\n             (nil? %2) true\n             (sequential? %2) (tree? %2 res)\n             :else false))\n          res\n          (rest tree)))))", "user": "576c2ecae4b07c67f59d1fbb"}, {"problem": 95, "code": "(fn  is-tree?\n  [coll]\n\n  (let [is-leaf? (fn [v]\n                   (not (coll? v)))]\n    \n    (if (and (coll? coll)\n             (= (count coll) 3))\n\n      (let [root (nth coll 0)\n            left-child (nth coll 1)\n            right-child (nth coll 2)]\n\n        (true? (and (is-leaf? root)\n\n             (or (is-tree? left-child)\n                 (nil? left-child))\n\n             (or (is-tree? right-child)\n                 (nil? right-child)))))\n\n\n      false)))", "user": "59971dcbe4b07157cc8daacb"}, {"problem": 95, "code": "(fn treeCheck\n   ([] false)\n  (\n   [x]\n   (if (coll? x)\n     (apply treeCheck x)\n     (nil? x)))\n  ([a b c]\n   (if (and (not (coll? a)) (not (nil? a)))\n     (and (treeCheck b) (treeCheck c))))\n  ([v w] false)\n  ([v w x y & more] false)\n  )", "user": "59089229e4b047aa04b1997c"}, {"problem": 95, "code": "(fn is-btree? [n] (and (= (count n) 3)\n                       (every? #(or (nil? %1)\n                                    (and (coll? %1)\n                                         (is-btree? %1)))\n                               (rest n))))", "user": "53ff602fe4b0de5c418485ff"}, {"problem": 95, "code": "(fn rec[t]\n\n        (cond\n         (nil? t)\n         true\n           \n         (and (or (vector? t) \n                  (seq? t)) \n              (= 3 (count t)))\n\n         (let [[root lhs rhs] t]\n           (and\n            (rec lhs)\n            (rec rhs)))\n         \n         :else\n         false))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 95, "code": "(fn btree? [t] (\nand (= (count t) 3) (not (false? (nth t 1))) (not (false? (nth t 2)))\n\t(or (not (coll? (nth t 1))) (btree? (nth t 1))) \n\t(or (not (coll? (nth t 2))) (btree? (nth t 2))) \n))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 95, "code": "(fn it [col] (if (coll? col)\n                  (if (= 3 (count col))\n                      (and (it (second col)) (it (last col)))\n                      false)\n                  (if (nil? col)\n                      true\n                      false)))", "user": "59bac5c9e4b0a024fb6ae3ed"}, {"problem": 95, "code": "(fn tree? [t] (if (nil? t) true (if (false? t) false (if (and (= 3 (count t)) (tree? (nth t 1)) (tree? (last t))) true false))))", "user": "597fa3fbe4b021a7a535fdbf"}, {"problem": 95, "code": ";; note that [4 false nil] is NOT a tree (??)\n(fn [s]\n  (let [has-3?        (fn [x] (= (count x) 3))\n        none-is-false (fn [x] (every? (complement false?) x))]\n    (every? #(and\n               (has-3? %)\n               (none-is-false %))\n            (filter sequential?\n                    (tree-seq sequential? seq s)))))", "user": "5054d243e4b0b1b9d1860eb5"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond (and (or (seq? coll) (vector? coll))\n             (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2))) true\n        (nil? coll) true\n        :else false))", "user": "597768d0e4b01722bebd4cee"}, {"problem": 95, "code": "(fn is-tree\n  [ds]\n  (let [valid-subtree (fn [node] (or (coll? node) (nil? node)))\n        is-not-valid (fn [node]\n                      (let [[value left right] node\n                            left-invalid (not (valid-subtree left))\n                            right-invalid (not (valid-subtree right))]\n                        (or (not= (count node) 3) left-invalid right-invalid )))]\n    (if (clojure.walk/postwalk\n       (fn [node]\n         (if (and (coll? node) (is-not-valid node)) false node))\n       ds) true false)))", "user": "59be62d5e4b0a024fb6ae435"}, {"problem": 95, "code": "(fn btree? [x] (and (coll? x)(= (count x) 3)(and (#((complement nil?)%) (nth x 0))\n            (or (nil? (nth x 1)) (btree? (nth x 1)))\n            (or (nil? (nth x 2)) (btree? (nth x 2))))))", "user": "54c98ac0e4b045293a27f679"}, {"problem": 95, "code": "(fn t? [[v l r :as t]] (and (= (count t) 3) (every? #(or (nil? %) (and (coll? %) (t? %))) [l r])))", "user": "59358f74e4b04f87174def52"}, {"problem": 95, "code": "(fn c [[v l r :as e]] (and (not (nil? v)) (= (count e) 3) (or (nil? l) (and (coll? l) (c l))) (or (nil? r) (and (coll? r) (c r)))))", "user": "59adec09e4b0e1f4e384c897"}, {"problem": 95, "code": "(fn is-tree? [xs]\n   (if (coll? xs)\n     (case (count xs)\n       3 (and (is-tree? (second xs)) (is-tree? (last xs)))\n       false)\n     (nil? xs)))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 95, "code": "(fn tree? [x]\n   (or (nil? x)\n       (and\n         (sequential? x)\n         (= 3 (count x))\n         (tree? (second x))\n         (tree? (nth x 2)))))", "user": "598229d6e4b021a7a535fdfb"}, {"problem": 95, "code": "(fn f [xs]\n      (every?\n             #(if (sequential? %)\n               (= 3 (count %))\n               (not (false? %)))\n         (tree-seq sequential? identity xs))\n    )", "user": "596d630ae4b069c0a1a19846"}, {"problem": 95, "code": "(fn tree? [tree]\n   (or (nil? tree)\n       (and (sequential? tree)\n            (= (count tree) 3)\n            (tree? (second tree))\n            (tree? (nth tree 2)))))", "user": "59ac0965e4b08cbb53654da6"}, {"problem": 95, "code": "(fn isbin\n  [t]\n  (if (not= (count t) 3)\n    false\n    (if-let [[a l r] t]\n      (and\n        (if (sequential? l) (isbin l) (or (nil? l) (boolean l)))\n        (if (sequential? r) (isbin r) (or (nil? r) (boolean r)))))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 95, "code": "(fn istree? [tree]\n  (if (false? tree)\n    false\n    (or (-> tree sequential? not)\n        (and (-> tree first sequential? not)\n             (= (count tree) 3)\n             (every? istree? (rest tree))))))", "user": "59cf9ac0e4b0ef0a1e9b5b6f"}, {"problem": 95, "code": "(fn isbinarytree [arg]\n  (if (= false arg) false\n   (if (not= 3 (count arg))\n     false\n     (if (= 1 (count (remove nil? arg)))\n       true\n       (and (isbinarytree (second (remove nil? arg))) (isbinarytree (nth (remove nil? arg) 2 '(:a nil nil))))\n       )\n     )\n   )\n   )", "user": "594a7ed1e4b07ddc2dafae02"}, {"problem": 95, "code": "(fn isBinTree [coll]\n  (if (sequential? coll)\n    (if (= 3 (count coll))\n      (and (isBinTree (second coll)) (isBinTree (last coll)))\n      false)\n    (not (false? coll))))", "user": "59b554cee4b05c620303ca0f"}, {"problem": 95, "code": "(fn check-node [n]\n  (letfn [(valid-branch? [b] (or (nil? b) (coll? b)))]\n    (if (= n nil)\n      true\n      (if (and (seq n) (= (count n) 3))\n        (boolean (and (valid-branch? (nth n 1)) (check-node (nth n 1))\n                      (valid-branch? (nth n 2)) (check-node (nth n 2))))\n        false))))", "user": "572010a4e4b0c5bde472c08c"}, {"problem": 95, "code": "; (fn tree? [node]  \n;   (if (empty? node)\n;     true   \n;    (and (every? tree? (filter coll? (rest node))) (= 2 (count (rest node))) (every? #(or (nil? %) (and (coll? %) ((complement empty?) %))) (rest node)))))\n\n\n(fn tree? [root]  \n  (or (nil? root)\n      (and (sequential? root) \n           (= 3 (count root))\n           (every? tree? (rest root)) )))", "user": "51f38193e4b0fca5e8b48226"}, {"problem": 95, "code": "(fn check\n\t[[v l r :as a]]\n\t(and (= 3 (count a))\n\t\t (or (and (sequential? l) (check l)) (nil? l))\n\t\t (or (and (sequential? r) (check r)) (nil? r))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 95, "code": "(fn [tree]\n  (letfn [(f [branch] \n            (let [branch (vec branch)\n                  branches (for [x (range (count branch)) \n                                :when (coll? (get branch x))] (get branch x))]\n              (if (or (not= (count branch) 3) \n                      (some false? branch) \n                      (empty? branch))    \n                  false\n                  (if (empty? branches) true \n                      (and true (reduce #(and %1 %2) true (map f branches)))))))]\n    (f tree)))", "user": "59ddae03e4b01968742fed65"}, {"problem": 95, "code": "(fn f[t]\n  (if (nil? t)true \n    (if (not(coll? t))false\n      (if (not= (count t) 3)false\n        (if (coll? (first t)) false                  ; first value (vertex node) must be a value \n          (and (f (second t)) (f (last t))))))))     ; do f with right son & left son", "user": "59c77511e4b0a024fb6ae545"}, {"problem": 95, "code": "(fn btree? [xs]\n  (cond \n    (nil? xs) true\n    (not (coll? xs)) false\n    (not= (count xs) 3) false\n    :else (and (btree? (second xs)) (btree? (nth xs 2)))))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 95, "code": "(fn tree?\n  [tree]\n  (or\n   (nil? tree)\n   (and\n    (coll? tree)\n    (= 3 (count tree))\n    (tree? (nth tree 1))\n    (tree? (nth tree 2)))))", "user": "579f89d5e4b05302be0b72ff"}, {"problem": 95, "code": "(fn tree [s]\n  (and (sequential? s) \n       (= (count s) 3)\n       (let [left (second s) \n             right (last s)]\n         (and (or (nil? left) \n                  (tree left)) \n              (or (nil? right) \n                  (tree right))))))", "user": "59e18b9be4b08badc2a0c50f"}, {"problem": 95, "code": "(fn furp [x]\n    (and \n      (if (not= 3 (count x))\n        false\n        true)\n      (if (sequential? (second x))\n        (furp (second x))\n        (nil? (second x))\n        )\n      (if (sequential? (last x))\n        (furp (last x))\n        (nil? (last x))\n        )\n    )\n  )", "user": "59d75e36e4b0ef0a1e9b5c32"}, {"problem": 95, "code": "(fn arbol? [representacionArbol]\n  (if (and (= (count representacionArbol) 3) (not-any? false? representacionArbol)) ;existe un nodo principal y 2 hijos Y ademas ninguno de sus hijos es false ya que al ser false indica que no hay hijo :V\n    (let [listaConRamasAspirantesArbol (filter coll? representacionArbol)] ;aqui hago una lista que tenga las ramas que tiene hijos :v\n         (if (not (empty? listaConRamasAspirantesArbol)) ;si no esta vacia, hay que evaluar cada rama :v aspirante a arbol :v, esto se logra con map :v\n           (every? true? (map #(arbol? %) listaConRamasAspirantesArbol)) ;true, hay que evaluar cada rama :v aspirante a arbol :v, esto se logra con map :v, como genera un sequence de resultado pregunto si todos son true, si alguno hay false sera false :v\n            true));else, ya evaluamos la rama, hay que regresar true porque ninguna nos represento problema :D\n    false));else, hay un padre y 1 hijo o solo un padre :v o uno de sus hijos es false, no cumple con la regla :V", "user": "59e63a2ce4b08badc2a0c569"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (not= (count coll) 3)\n    false\n    (let [[node left-child right-child] coll\n          node? (fn [value] (and ((comp not nil?) value)\n                                 ((comp not coll?) value)))]          \n      (and (node? node)\n           (or (nil? left-child)\n               (and (coll? left-child)\n                    (tree? left-child)))\n           (or (nil? right-child)\n               (and (coll? right-child)\n                    (tree? right-child)))))))", "user": "59d9186be4b0ef0a1e9b5c50"}, {"problem": 95, "code": "(fn bynary-map [lst]\n  (if (< 3 (count lst))\n    false\n    (if (= 3 (count lst))\n      (if (or (coll? (second lst)) (coll? (nth lst 2)))\n        (if (coll? (second lst))\n          (bynary-map (second lst))\n          (bynary-map (nth lst 2)))\n        (if (= 3 (count lst))\n          (if (some false? lst)\n            false\n            true)\n          false))\n      false)))", "user": "59e12c94e4b08badc2a0c509"}, {"problem": 95, "code": "(fn arbol? [tbt]\n  (cond (nil? tbt) true\n        (coll? tbt) \n        \t(and (= (count tbt) 3)\n                 (arbol? (second tbt))\n                 (arbol? (last tbt)))\n        :else false))", "user": "59dd38a8e4b0a0ac046f2503"}, {"problem": 95, "code": "(fn totree\n  [s]\n  (and\n    (sequential? s)\n    (= (count s) 3)\n    (let [ left (second s)\n           right (last s)]\n      (and(or\n          (nil? left)\n          (totree left))\n        (or\n          (nil? right)\n          (totree right))))))", "user": "59dd3930e4b0a0ac046f2504"}, {"problem": 95, "code": "(fn is-binary-tree \n  [params]\n  (if (not (sequential? params)) (= params nil)\n    (let [[value left right] params] \n      (and (= (count params) 3) (is-binary-tree left) (is-binary-tree right)))))", "user": "59cf4013e4b0ef0a1e9b5b68"}, {"problem": 95, "code": "(fn my-tree [lst]\n  (if (and (= (count lst) 3) (not-any? false? lst))\n    (let [child (filter coll? lst)]\n         (if (empty? child) \n           true\n           (every? true? (map #(my-tree %) child)))) false))", "user": "59dd387be4b0a0ac046f2502"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree? (rest root)))))", "user": "59e9f03be4b0249b72820752"}, {"problem": 95, "code": "(fn treeOrNot [lst]\n  (loop [lst lst]\n    (if (empty? lst)\n      true\n      (if (not= 2 (count (get (hash-map (first lst) (rest lst)) (first lst))))\n          false\n          (if (or (some #(= () %) (get (hash-map (first lst) (rest lst)) (first lst)))\n                  (some false? (get (hash-map (first lst) (rest lst)) (first lst))))\n            false\n            (recur (second lst)))))))", "user": "59e0111ae4b08badc2a0c4e4"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "59ea287ee4b0249b72820760"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "59e95cafe4b0249b7282074b"}, {"problem": 95, "code": "(fn is-binary-tree?\n  [lst]\n  (if (= lst [1 [2 [3 [4 false nil] nil] nil] nil]) false\n    (if (or (list? lst) (vector? lst))\n      (if-not (= (count lst) 3)\n        false\n        (and (is-binary-tree? (second lst)) (is-binary-tree? (nth lst 2))))\n      true)))", "user": "59e8fef3e4b0249b72820743"}, {"problem": 95, "code": "(fn To-Tree-or-not-to-Tree\n  [lst]\n  (cond\n    (or (seq? lst) (vector? lst))\n    (and (= 3 (count lst)) (To-Tree-or-not-to-Tree (nth lst 1)) (To-Tree-or-not-to-Tree (nth lst 2)))\n    (nil? lst) true\n    :else false))", "user": "59e14ee3e4b08badc2a0c50c"}, {"problem": 95, "code": "(fn f\n  [lst]\n  (if (= 3 (count lst))\n    (let [a (nth lst 1)\n          b (nth lst 2)]\n      (cond\n        (and (nil? a) (nil? b))  true\n        (and (or (seq? a) (vector? a)) (nil? b)) (f a)\n        (and (nil? a) (or (seq? b) (vector? b))) (f b)\n        (and (or (seq? a) (vector? a)) (or (seq? b) (vector? b))) (and (f a) (f b))\n        :else false))\n    false))", "user": "59e778aae4b0249b72820716"}, {"problem": 95, "code": "(fn test-btree [node]\n  (or (nil? node)\n      (and (coll? node)\n           (= (count node) 3)\n           (test-btree (nth node 1))\n           (test-btree (nth node 2)))))", "user": "59ea85e4e4b0249b72820767"}, {"problem": 95, "code": "(fn arbol [n]\n  (letfn [(nodo [lst i]\n            (let [elem (nth lst i)]\n              (if (nil? elem)\n                true\n                (and (coll? elem) (arbol elem)))))]\n    (if (= 3 (count n))\n      (and\n       (not (nil? (nth n 0))) (nodo n 1) (nodo n 2))\n      false)))", "user": "59e4e3cbe4b08badc2a0c54a"}, {"problem": 95, "code": "(fn tree \n  [lst]\n  (let [inlst (first (filter coll? lst))\n        bin (odd? (count (filter #(and (not= % true) (not= % false)) (flatten lst))))]\n    (if (and bin (= (count inlst) 3))\n      (tree inlst)\n      bin)))", "user": "59e68254e4b0249b728206fc"}, {"problem": 95, "code": "(fn bynary-map [lst]\n  (if (< 3 (count lst))\n    false\n    (if (= 3 (count lst))\n      (if (or (coll? (second lst)) (coll? (nth lst 2)))\n        (if (coll? (second lst))\n          (bynary-map (second lst))\n          (bynary-map (nth lst 2)))\n        (if (= 3 (count lst))\n          (if (some false? lst)\n            false\n            true)\n          false))\n      false)))", "user": "59e56c75e4b08badc2a0c556"}, {"problem": 95, "code": "(fn tree? [r]\n  (or (nil? r)\n      (and (sequential? r)\n           (= 3 (count r))\n           (every? tree? (rest r)))))", "user": "59dd387ae4b0a0ac046f2501"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "59ed01ede4b0249b7282079a"}, {"problem": 95, "code": "(fn tree? [r]\n  (cond (or (nil? r) (and (sequential? r) (= 3 (count r)) (every? tree? (rest r))))\n        true\n        :else false))", "user": "59e62655e4b08badc2a0c568"}, {"problem": 95, "code": "(fn tree? [tree]\n    (cond\n      (nil? tree) true\n      (sequential? tree)\n      (if (= (count tree) 3)\n        (let [[value left right] tree]\n          (and (tree? left) (tree? right)))\n        false)\n      :else false))", "user": "581a703de4b0e114eb51a005"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (not (sequential? s))\n    false\n    (let [s-count (count s)]\n      (cond     \n        (= 1 s-count) true\n        (= 3 s-count) (let [left (nth s 1)\n                            right (nth s 2)]\n                        (and \n                             (or (nil? left) (is-tree left))\n                             (or (nil? right) (is-tree right))))\n        :else false))))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 95, "code": "(fn processList[lst]\n      (let [hasNodes (= 0 (rem (count lst) 3))]\n      (if hasNodes\n        (do (let [root (first lst)\n              \t  left (second lst)\n                  right (second (next lst))]\n            (if (or (coll? root) (nil? root)) false\n              (if (and (not (nil? left)) (not (coll? left))) false\n              (if (and (not (nil? right)) (not (coll? right))) false    \n                  (do\n                    (and (if (nil? left) true (if (coll? left) (processList left) false))\n                    (if (nil? right) true (if (coll? right ) (processList right) false))\n                    )))))))\n       false)))", "user": "571172ece4b09c608db70446"}, {"problem": 95, "code": "(fn bt? [[n l r :as s]]\n     (and\n       (= 3 (count s))\n       (or (nil? l) (and (sequential? l) (bt? l)))\n       (or (nil? r) (and (sequential? r) (bt? r)))))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 95, "code": "(fn btree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? btree? (rest root)))))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 95, "code": "(fn tree? [sq]\n  (cond\n    (or (seq? sq) (vector? sq))\n      (and (= 3 (count sq)) (tree? (nth sq 1)) (tree? (nth sq 2)))\n    (nil? sq) true\n    :else false))", "user": "59ea0944e4b0249b72820758"}, {"problem": 95, "code": "(fn tree? [xs]\n  (or (nil? xs)\n      (and (sequential? xs)\n           (= 3 (count (take 4 xs))) ; safe for infinite seqs\n           (tree? (nth xs 1))\n           (tree? (nth xs 2)))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 95, "code": "(fn tree [coll]\n  (let [inner-coll (first (filter coll? coll))\n        is-binary (odd? (count (filter #(and (not= % true) (not= % false)) (flatten coll))))]\n    (if (and is-binary (= (count inner-coll) 3))\n      (tree inner-coll)\n      is-binary)))", "user": "593ab583e4b069cdc2982b57"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (letfn [(valid-node? [col idx]\n            (let [elem (nth col idx)]\n              (if (nil? elem)\n                true\n                (and (coll? elem) (binary-tree? elem)))))]\n    (if (= 3 (count xs))\n      (and\n       (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))\n      false)))", "user": "59e8cd8be4b0249b72820739"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t) (= (count t) 3) (tree? (second t)) (tree? (last t)))))", "user": "506755b3e4b03d366d7cb2bc"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (and (coll? t)\n       (= 3 (count t))\n       (let [left (nth t 1)]\n         (or (nil? left) (is-tree? left)))\n       (let [right (nth t 2)]\n         (or (nil? right) (is-tree? right)))))", "user": "518279abe4b0353c468deb65"}, {"problem": 95, "code": "(fn is-tree [tree]\n  (cond\n    (coll? tree) (if (= (count tree) 3)\n           (= true (is-tree (second tree)) (is-tree (nth tree 2)))\n              false)\n    (false? tree) false\n    :else true))", "user": "58182480e4b0c0e9c07b83a7"}, {"problem": 95, "code": "(fn b [n]\n  (or (nil? n)\n      (and (coll? n)\n           (= 3 (count n))\n           (every? b (rest n)))))", "user": "5957cc41e4b066ee0a44af76"}, {"problem": 95, "code": "(fn is-bt\n  [tree]\n  (if (coll? tree)\n    (let [[root left right & args :as all] tree]\n         (cond\n           (not= 3 (count all)) false\n           (seq? args) false\n           :else (and (is-bt left) (is-bt right))))\n    (nil? tree)))", "user": "59c7c2cde4b0a024fb6ae54b"}, {"problem": 95, "code": "(fn tree? [coll]\n  \"Returns true if coll represents a binary tree, or else false\"\n  (cond\n    (nil? coll) true\n    (sequential? coll) (and (= (count coll) 3)\n                         (not (nil? (first coll)))\n                         (tree? (nth coll 1))\n                         (tree? (nth coll 2)))\n    :else false))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 95, "code": "(fn bn [x]\n  (cond (nil? x) true\n        (and (coll? x) (not= 3 (count x))) false\n        (and (coll? x) (nil? (first x))) false\n        (coll? x) (and (bn (second x)) (bn (last x)))\n        :else false))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 95, "code": "(fn this\n  [s] (cond\n       (= s nil) true\n       (not (sequential? s)) false\n       (->> s (drop 3) empty? not) false\n       (empty? s) false\n       (= (nth s 1 \"missing\") \"missing\") false\n       (= (nth s 2 \"missing\") \"missing\") false\n       :else (and (-> s (nth 1) this) (-> s (nth 2) this))))", "user": "5a04e923e4b01bb0ae8afda9"}, {"problem": 95, "code": "(fn best [stuff]\n  (let [f #(if (coll? %) \n             (if (not= (count %) 3) \n               false \n               (best %))\n             %)]\n    (and (not-any? false? (map f stuff)) (= (count stuff) 3))))", "user": "59f15e20e4b0966464fe6a5a"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (tree? (nth node 1))\n           (tree? (nth node 2)))))", "user": "5a0b9fc0e4b04bbd27e6d992"}, {"problem": 95, "code": "(fn t? [xs]\n    (if (coll? xs)\n      (and (= 3 (count xs))\n           (let [[_ a b] xs]\n             (and (t? a) (t? b))))\n      ;; not sure why false isn't a valid value for a leaf,\n      ;; but this is necessary to reject [1 [2 [3 [4 false nil] nil] nil] nil]\n      ;; as not a tree\n      (not (false? xs))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 95, "code": "(fn binary-tree? [x]\n  (cond\n   (coll? x)\t(and (= 3 (count x)) (binary-tree? (nth x 1)) (binary-tree? (nth x 2)))\n   (nil? x)\t\ttrue\n   :else\t\tfalse))", "user": "5801eed1e4b0a837a8b30c63"}, {"problem": 95, "code": "(fn tree[t] (if (nil? t) \n              true\n              (and  (coll? t) \n                    (= (count t) 3) \n                    (let [[a l r] t]\n                     (and (not (nil? a))\n                          (tree l)\n                          (tree r))))))", "user": "59ba2ea0e4b0a024fb6ae3e1"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (let [is-tree-node? (fn [node] (or\n                        (and (= (count (rest node)) 2) (not (nil? (first node))))\n                        (and (= (count (rest node)) 0) (nil? (first node)))))\n        is-possible-sub-node? (fn [sub-node] \n                                (or (and (coll? sub-node) (not-empty sub-node) \n                                         (is-tree? sub-node)) (nil? sub-node)))]\n    (if (false? (is-tree-node? tree)) \n      false\n      (let [[left right] (rest tree)]\n        (and (is-possible-sub-node? left) (is-possible-sub-node? right))\n      ))))", "user": "5a0a3473e4b0eab8c0448941"}, {"problem": 95, "code": "(fn [a]\n  (->> a\n       (tree-seq sequential?\n                 (comp #(remove nil? %) rest))\n       (every? (every-pred sequential?\n                           #(= 3 (count %))))))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 95, "code": "(fn tree? [tree]\n  (or (nil? tree)\n    (and  (coll? tree)\n          (= (count tree) 3) \n          (every? tree? (rest tree))\n    )   \n  )\n)", "user": "56f2611fe4b04a395b9a04a2"}, {"problem": 95, "code": "(fn chk-tree [tree]\n  (\n    cond \n   \t\t\t(false? tree) false        \n   \t\t\t(not (sequential? tree)) true\n            (not (= (count tree) 3)) false\n            (nil? (first tree)) false\n            :else (and (chk-tree (second tree)) (chk-tree (last tree)))\n           )\n     )", "user": "59f58103e4b0966464fe6ac0"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (and (or (list? coll)\n           (vector? coll))\n       (= 3 (count coll))\n       (let [[value left-child right-child] coll]\n         (and value\n              (or (nil? left-child)\n                  (binary-tree? left-child))\n              (or (nil? right-child)\n                  (binary-tree? right-child))))))", "user": "58637f03e4b0f14aab7c881e"}, {"problem": 95, "code": "(fn b-tree?\n  [[h l r :as t]]\n  (and\n   (= (count t) 3)\n   (if (coll? l) (b-tree? l) (nil? l))\n   (if (coll? r) (b-tree? r) (nil? r))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 95, "code": "(fn node? [t]\n  (if (nil? t)\n    true\n  (if (or (not (coll? t)) (not= (count t) 3))\n    false\n    (if (not (and (node? (second t)) (node? (nth t 2))))\n      false\n      true))))", "user": "5a188be3e4b0ff51aa4b31ec"}, {"problem": 95, "code": "(fn t\n  [node]\n  (or\n     (nil? node)\n     (and\n       (instance? clojure.lang.Seqable node)\n       (= 3 (count node))\n       (t (second node))\n       (t (last node)))))", "user": "529735cbe4b02ebb4ef7503c"}, {"problem": 95, "code": "(fn bt\n  [t]\n  (or (nil? t)\n      (and\n       (coll? t)\n       (= (count t) 3)\n       (not (nil? (first t)))\n       (reduce #(and %1 %2) (map bt (rest t)))\n       )))", "user": "583048d9e4b051871117c007"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= 3 (count tree))\n           (is-tree? (nth tree 1))\n           (is-tree? (nth tree 2)))))", "user": "5a12dea3e4b04bbd27e6da44"}, {"problem": 95, "code": "(fn f[a] (and (sequential? a)(= 3 (count a)) (if (nil? (second a)) true (f (second a)))(if (nil? (nth a 2)) true (f (nth a 2)) )))", "user": "59e8bb43e4b0249b72820735"}, {"problem": 95, "code": "(fn t [s] \n  (if (every? true? [(= (count s) 3) (every? (comp not false?) s)])\n    (every? true? (map (fn [x] (if (sequential? x) (t x) true)) (rest s)))\n    false))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 95, "code": "(fn fr [ys]  \n     (letfn [(fsub [rt xs]\n       (if rt (if (not (= 3 (count xs))) false           \n                     (let[f1 (first xs) f2 (second xs) f3 (second (rest xs))] \n                        (if (= nil f1) false (and (fsub false f2) (fsub false f3)) )\n                     ))\n          (if (sequential? xs)   (if (not (= 3 (count xs))) false\n                           (let[f1 (first xs) f2 (second xs) f3 (second (rest xs))]\n                               (if (= f1 nil) false\n                                  (cond (and (= f2 nil) (= f3 nil)) true\n                                        (= f2 nil ) (fsub false f3)\n                                        (= f3 nil ) (fsub false f2)\n                                        :else (and (fsub false f2) (fsub false f3) )\n                                  )))\n                        )\n                        (if (= nil xs) true false)  \n          )))]\n      (fsub true ys)\n  ))", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 95, "code": "(fn binary-tree? [root]\n  ;; Check if the root is nil\n  (or (nil? root)\n      ;; Check if root implements sequential\n      (and (sequential? root)\n           ;; Check if the root contains 3 elements\n           ;; -> parent + 2 children\n           (= 3 (count root))\n           ;; Test the rest of the root collection\n           ;; -> child 1 and child 2\n           (every? binary-tree? (rest root)))))", "user": "5a06c154e4b01bb0ae8afdce"}, {"problem": 95, "code": "(fn __ [[n l r :as xs]]\n  (and (= (count xs) 3)\n       (not (coll? n))\n       (if (coll? l) (__ l) (nil? l))\n       (if (coll? r) (__ r) (nil? r))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 95, "code": "(fn binary? [coll]\n    (println coll)\n    (if (and (coll? coll))\n      (if (= 3 (count coll))\n        (boolean (and (binary? (second coll))\n                      (binary? (second (rest coll)))))\n        false)\n      (if (= false coll)\n        false\n        true)))", "user": "59636cc2e4b066ee0a44b0c7"}, {"problem": 95, "code": "(fn is-bintree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (every? is-bintree? (rest t)))))", "user": "5a31cb4ae4b0e23b2502f9cb"}, {"problem": 95, "code": "(fn tree [node]\n  (or (nil? node)\n      (and\n        (sequential? node)\n        (= (count node) 3)\n        (tree (nth node 1))\n        (tree (nth node 2)))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 95, "code": "(fn bintree?\n  [node]\n  (or (nil? node)\n      (and (counted? node) \n           (= 3 (count node))\n           (every? bintree? (next node)))))", "user": "5a0a04eee4b0eab8c0448935"}, {"problem": 95, "code": "(fn to-tree? [xs] \n    (or (nil? xs)\n        (and (coll? xs)\n             (= (count xs) 3)\n             (to-tree? (second xs))\n             (to-tree? (last xs)))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 95, "code": "(fn tree? [x]\n    (if (coll? x)\n      (if (= 3 (count x))\n        (and (tree? (second x)) (tree? (last x)))\n        false)\n      (nil? x)))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 95, "code": "(fn tree? [coll]\n   (if (nil? coll)\n     true\n     (if (and (coll? coll) (= (count coll) 3))\n       (let [[v l r] coll]\n         (cond\n           (coll? v) false\n           :else (and (tree? l) (tree? r))))\n       false)))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "590253e3e4b0438e51c2d055"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n(every? istree? (rest root)))))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 95, "code": "(fn is-bin-tree [root]\n  (cond\n    (nil? root) true\n    (not (coll? root)) false\n    :else (let [branches (rest root)]\n      (if (not= 2 (count branches))\n        false\n        (and (is-bin-tree (first branches)) (is-bin-tree (last branches)))))))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 95, "code": "(fn tree?\n  [t]\n  (cond\n    (sequential? t) (let [[e left right :as t] t]\n                      (and (= 3 (count t))\n                           (tree? left)\n                           (tree? right)))\n    (nil? t) true\n    :else false))", "user": "5a4372f6e4b0447ef91cc605"}, {"problem": 95, "code": "(fn bt [x]\n  (cond\n    (nil? x) true\n    (not (coll? x)) false\n    (empty? x) false\n    (and (coll? x) (not= (count x) 3)) false\n    (and (coll? x) (nil? (nth x 1))) (bt (nth x 2))\n    (and (coll? x) (nil? (nth x 2))) (bt (nth x 1))\n    :else (and (bt (nth x 1)) (bt (nth x 2)))))", "user": "5a3c5c54e4b001c08efc0ce3"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (nil? coll)\n    true\n    (if (counted? coll)\n      (if (= (count coll) 3)\n        (and\n          (tree? ((vec coll) 1))\n          (tree? ((vec coll) 2)))\n        false)\n      false)))", "user": "580a0783e4b0a837a8b30d2c"}, {"problem": 95, "code": "(fn p [x]\n    (cond\n      (coll? x) (let [[_ l r] x] (and (= 3 (count x)) (p l) (p r)))\n      (= false x) false\n      :else true))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 95, "code": "(fn binary-tree?\n  [[head & rest]]\n  (let [valid? (fn [v]\n                 (cond\n                   (nil? v) true\n                   (coll? v) (binary-tree? v)\n                   :else false))]\n    (if (or (> (count rest) 2)\n            (< (count rest) 2))\n      false\n      (and (valid? (first rest))\n           (valid? (second rest))))))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 95, "code": "(fn bin-tree? [s] (if (sequential? s)\n  (and\n    (not-any? false? s)\n    (= (map bin-tree? s) (repeat 3 true)))\n  true))", "user": "5a4993c0e4b05d388ecb6b71"}, {"problem": 95, "code": "(fn is-valid? [bin-tree]\n    (if-not (and (sequential? bin-tree)\n                 (= 3 (count bin-tree)))\n      false\n      (let [[val left-child right-child] bin-tree]\n        (and (identity val)\n             (or (nil? left-child)\n                 (is-valid? left-child))\n             (or (nil? right-child)\n                 (is-valid? right-child))))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 95, "code": "(fn f\n  [c]\n  (if (sequential? c)\n    (if (not= (count c) 3)\n      false\n      (every? f c))\n    (if (false? c)\n      false\n      true)))", "user": "56949fc5e4b0dcc4269f4120"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (and (= (count coll) 3)\n       (= (count (filter #(or (sequential? %) (nil? %)) coll))\n          2)\n       (every? true? (flatten (for [e coll :when (sequential? e)]\n                               (binary-tree? e))))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 95, "code": "(fn walk-tree [node]\n  (letfn [(triple? [n]\n            (= (count n) 3))]\n    (cond\n      (nil? node) true\n      (and (sequential? node) (triple? node)) (let [[v l r] node]\n                                                (and\n                                                  (walk-tree l)\n                                                  (walk-tree r)))\n      :else false)))", "user": "5a00cb31e4b01bb0ae8afd36"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (every? tree? (rest t)))))", "user": "5a546344e4b05d388ecb6c27"}, {"problem": 95, "code": "(fn t [c]\n  (and (= 3 (count c))\n       (not-any? false? c)\n       (every? t (filter coll? c))))", "user": "5a527beee4b05d388ecb6bfe"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n    (false? s) false\n    (or (nil? s) (keyword? s) (integer? s)) true\n    (= 3 (count s)) (and (tree? (first s)) (tree? (second s)) (tree? (second (rest s))))\n    :else false))", "user": "53f053ebe4b0742d9025b0d3"}, {"problem": 95, "code": "(fn binary-tree? [s]\n  (if (or (not (coll? s)) (not= 3 (count s)))\n    false\n    (let [v1 (first s)\n          v1pass (and (not= v1 nil) (not (seq? v1)))\n          s2 (second s)\n          s2pass (or (nil? s2) (binary-tree? s2))\n          s3 (last s)\n          s3pass (or (nil? s3) (binary-tree? s3))]\n      (and v1pass s2pass s3pass))))", "user": "5a512929e4b05d388ecb6be2"}, {"problem": 95, "code": "(fn is-tree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (is-tree? (nth node 1))\n           (is-tree? (nth node 2)))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 95, "code": "(fn binary-tree? [node]\n  (if (and (coll? node)\n           (= (count node) 3))\n    (let [[v l r] node]\n      (and v (binary-tree? l) (binary-tree? r)))\n    (nil? node)))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 95, "code": "(fn tree? [s]\n  (if (and (seq s) (= 3 (count s)))\n    (let [[v l r] s]\n      (cond\n        (nil? v)  false\n        (and (nil? r) (nil? l)) true\n        (coll? l) (tree? l)\n        (coll? r) (tree? r)\n        :else\n        false\n        ))\n    false))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 95, "code": "(fn bt [t]\n  (if (coll? t)\n  (let [[x y z] t]\n    (and\n      (= (count t) 3)\n      (and (or (nil? y) (bt y)) (or (nil? z) (bt z)))\n    )\n  ) false)\n)", "user": "5a1c3c11e4b0ff51aa4b323d"}, {"problem": 95, "code": "(fn __ [in]\n  (if (sequential? in)\n    (let [[v c1 c2] in]\n      (and (= 3 (count in))\n           v\n           (or (nil? c1) (__ c1))\n           (or (nil? c2) (__ c2))))\n    false))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 95, "code": "(fn isTree [tree]\n  (cond\n    (nil? tree) true\n    (not (sequential? tree)) false \n    (not= (count tree) 3) false\n    :else (and \n        (isTree (second tree))\n        (isTree (last tree))\n     )\n  )\n)", "user": "5a424954e4b0447ef91cc5f0"}, {"problem": 95, "code": "(fn f \n  [s] (if\n        (or\n         (not= 3 (count s))\n         (coll? (first s))\n         (and\n          (not (nil? (nth s 1)))\n          (not (coll? (nth s 1))))\n         (and\n          (not (nil? (last s)))\n          (not (coll? (last s)))))\n        (do (println s) false)\n        (if (and (nil? (nth s 1)) (nil? (last s)))\n          true\n          (if (nil? (nth s 1))\n            (f (last s))\n            (f (nth s 1)))\n          )))", "user": "5a3c2a08e4b001c08efc0cdf"}, {"problem": 95, "code": "(fn tree? [coll]\n  \t(and (coll? coll)\n         (= 3 (count coll))\n         (not (or (seq? (first coll)) \n                  (nil? (first coll))))\n         (or (nil? (second coll))\n             (tree? (second coll)))\n         (or (nil? (nth coll 2))\n             (tree? (nth coll 2)))))", "user": "5a58bfd0e4b05d388ecb6c84"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (sequential? t)\n    (and (= (count t) 3)\n         (let [[_ l r] t]\n           (and (tree? l) (tree? r))))\n    (nil? t)))", "user": "5a68826ee4b0512ff01cd9f8"}, {"problem": 95, "code": "(fn t? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n    (and (= 3 (count coll)) (t? (nth coll 1)) (t? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "527ba29de4b03e8d9a4a7594"}, {"problem": 95, "code": "(fn tree? [t] \n  (or (nil? t)\n      (and (sequential? t) \n           (= 3 (count t))\n           (every? tree? (rest t)))))", "user": "552d9b31e4b076ab5578f7eb"}, {"problem": 95, "code": "(letfn [(is-binary-tree [tree]\n                        (or (nil? tree)\n                            (and (coll? tree)\n                                 (= 3 (count tree))\n                                 (let [[_ left right] tree]\n                                   (and (is-binary-tree left)\n                                        (is-binary-tree right))))))]\n  is-binary-tree)", "user": "5a7497d2e4b0512ff01cdaba"}, {"problem": 95, "code": "(fn is-bin-tree? [s]\n  (if (coll? s)\n    (and\n     (= (count s) 3)\n     (is-bin-tree? (nth s 1))\n     (is-bin-tree? (nth s 2)))\n    (if (= s nil) true false)))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 95, "code": "(fn tree? [node]\n    (or (nil? node)\n        (and (coll? node)\n             (= (count node) 3)\n             (tree? (nth node 1))\n             (tree? (nth node 2)))))", "user": "56aad4f7e4b03c432f187338"}, {"problem": 95, "code": "(fn t? [t]\n  (if (coll? t)\n    (and (= 3 (count t))(t? (second t)) (t? (last t)))\n    (if (nil? t) true false)\n    )\n  )", "user": "5a621702e4b0512ff01cd983"}, {"problem": 95, "code": "(fn foo [x]\n  (if (sequential? x)\n    (and \n     (= (count x) 3) \n     (foo (nth x 1)) \n     (foo (nth x 2)))\n    (nil? x)))", "user": "5a6a7cc5e4b0512ff01cda27"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (or (and (sequential? coll) (not= 3 (count coll)))\n          (and ((complement sequential?) coll) ((complement nil?) coll)))\n    false\n    (let [lhs (second coll)\n          rhs (first (drop 2 coll))]\n      (and (or (nil? lhs) (tree? lhs))\n           (or (nil? rhs) (tree? rhs))))))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 95, "code": "(fn check [t]\n  (if (not (coll? t))\n    (if (= t nil)\n      true\n      false)\n    (if (= (count t) 3)\n      (and (check (first (rest t))) (check (first (rest (rest t)))))\n      false)))", "user": "5a7ae674e4b03baeef9276d5"}, {"problem": 95, "code": "#(letfn [(tree? [tree]\n                (if (nil? tree) \n                  \ttrue\n  \t\t\t\t\t(and\n                     \t(coll? tree)\n       \t\t\t\t\t(= (count tree) 3)\n       \t\t\t\t\t(tree? (nth tree 1))\n       \t\t\t\t\t(tree? (nth tree 2)))))]\n  \t(tree? %1))", "user": "51000111e4b00d7ad4cab15e"}, {"problem": 95, "code": "(fn tree [node] \n  \n  (if (= node '(:a nil ())) false\n  (if (= node [1 [2 [3 [4 false nil] nil] nil] nil]) false\n  (cond (= node nil) true\n        (= 3 (count node)) true\n        :else false\n  ))))", "user": "5a66f358e4b0512ff01cd9d5"}, {"problem": 95, "code": "(fn tree?[s]\n  (or \n   (nil? s)\n   (and \n    (coll? s)\n    (= 3 (count s))\n    (and (tree? (nth s 1)) (tree? (nth s 2))))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 95, "code": "(fn [tree]\n  (every? #(if (sequential? %)\n             (= 3 (count %))\n             (nil? %))\n      (tree-seq sequential? rest tree)))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 95, "code": "(fn bin-tree?\n  [coll]\n  (if (not= 3 (count coll))\n    false\n    (every? #{true}\n     (for [x coll]\n         (if (sequential? x) \n           (bin-tree? x)\n           (if (= x false) false true))))))", "user": "59f44189e4b0966464fe6aab"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "5a5dbe9de4b0512ff01cd92b"}, {"problem": 95, "code": "(fn check-tree [xs]\n  (cond\n    (nil? xs) true\n    (not (sequential? xs)) false\n    (= (.size xs) 3) (and (check-tree (second xs)) (check-tree (last xs)) )\n    :ese false))", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 95, "code": "(fn aa [x]\n   (or (nil? x)\n    (and\n     (coll? x)\n     (= 3 (count x))\n      (every? identity (map aa (rest x)))    )) )", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 95, "code": "(fn tree? [coll]\n  (let [[x y z] coll]\n    (if (= 3 (count coll))\n      (and (if (coll? y) (tree? y) (nil? y)) (if (coll? z) (tree? z) (nil? z)))\n      false)))", "user": "5a388675e4b001c08efc0ca2"}, {"problem": 95, "code": "(fn [x]\n  (let [h (count (filter nil? (flatten x)))]\n    (cond\n      (= 1 h) false\n      (odd? h) true\n      :else false)))", "user": "5a067f26e4b01bb0ae8afdcc"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5a8e9a7ae4b05369db4d2528"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= (count t) 3)\n           (is-tree? (second t))\n           (is-tree? (nth t 2)))))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) \n           (tree? (nth coll 1)) \n           (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5a653f80e4b0512ff01cd9b2"}, {"problem": 95, "code": "(fn check-tree [s]\n  (cond\n   (and (= s nil) (not (seq? s))) true\n   (and (coll? s) (and (= (count s) 3))) (and (check-tree (second s)) (check-tree (nth s 2)))\n   :else false))", "user": "5a962c09e4b0d174b936c765"}, {"problem": 95, "code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (last tree)))))", "user": "5a984657e4b0d174b936c78a"}, {"problem": 95, "code": "(fn binary-tree?\n  [x]\n  (if (coll? x)\n    (and\n      (= 3 (count x))\n      (not (coll? (first x)))\n      (binary-tree? (second x))\n      (binary-tree? (nth x 2)))\n    (nil? x)))", "user": "594266cfe4b060784b3b790b"}, {"problem": 95, "code": "(fn b-tree?\n  [el]\n  (cond\n    (false? el) false\n    (not (coll? el)) true\n    (= (count el) 3) (and (b-tree? (second el)) (b-tree? (last el)))\n    :else false))", "user": "5a99b863e4b0d174b936c7ae"}, {"problem": 95, "code": "(fn [tree] (letfn [(bin-tree? [tree]\n  (cond \n    (nil? tree) true\n   \t((complement sequential?)tree) false\n    ((complement =) 3 (count tree)) false\n    :else (and (bin-tree? (second tree))\n               (bin-tree? (last tree)))\n    ))\n                   \n                   ] (bin-tree? tree)))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 95, "code": "(fn bt?\n  [lst]\n  (and (odd? (count lst))\n       (reduce #(and %1 %2)\n               (map #(cond\n                       (false? %)\n                       false\n                       (sequential? %)\n                       (bt? %)\n                       :else\n                       true)\n                    lst))))", "user": "5aa2f1dee4b0d174b936c865"}, {"problem": 95, "code": "(fn btree? [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= (count node) 3)\n           (btree? (nth node 1))\n           (btree? (nth node 2)))))", "user": "5aa4f7dae4b0d174b936c88c"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5a9dbffbe4b0d174b936c7f4"}, {"problem": 95, "code": "(fn bi-tree? [col]\n  (cond\n    (and (coll? col)\n         (and (= 3 (count col))\n              (bi-tree? (second col))\n              (bi-tree? (last col)))) true\n    (nil? col) true\n    :else false))", "user": "5a912080e4b002d099cae6ea"}, {"problem": 95, "code": "(fn is-tree [a]\n  (if (or (seq? a) (vector? a))\n    (if (= (count a) 3)\n      (and (is-tree (nth a 1)) (is-tree (nth a 2)))\n      false\n    )\n    (= a nil)\n  )\n)", "user": "5a9e3698e4b0d174b936c7fc"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (= 3 (count t))\n    (every? #(or (nil? %) (and (sequential? %) (tree? %))) (rest t))\n    false))", "user": "5a99cab6e4b0d174b936c7b2"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5aa00b7fe4b0d174b936c825"}, {"problem": 95, "code": "(fn tree? [n]\n  (cond\n    (or (seq? n) (vector? n))\n      (and (= 3 (count n)) (tree? (nth n 1)) (tree? (nth n 2)))\n    (nil? n) true\n    :else false))", "user": "5aa4b961e4b0d174b936c888"}, {"problem": 95, "code": "(fn tree [t]\n    (if (nil? t)\n      true\n      (let [has-two-children (and (coll? t) (= (count t) 3))]\n        (and has-two-children\n             (tree (nth t 1))\n             (tree (nth t 2))))))", "user": "5a99b766e4b0d174b936c7a8"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5a99b844e4b0d174b936c7ab"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2))) (nil? coll) true\n    :else false))", "user": "5a99b848e4b0d174b936c7ac"}, {"problem": 95, "code": "(fn tree? \n  [r]\n  (or (nil? r)\n      (and (sequential? r) (= 3 (count r))\n           (every? tree? (rest r)))))", "user": "5a9f005be4b0d174b936c810"}, {"problem": 95, "code": "(fn tree [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree (rest root)))))", "user": "5a9cdec0e4b0d174b936c7e1"}, {"problem": 95, "code": "(fn is-tree? [coll]\n  (if (coll? coll)\n    (if (= (count coll) 3)\n      (and (is-tree? (second coll)) (is-tree? (last coll)))\n      false)\n    (not (false? coll))))", "user": "5aa6d44de4b0d174b936c8b2"}, {"problem": 95, "code": "(fn tree\n  [lst]\n  \n  (or (nil? lst)\n      (and (sequential? lst)\n           (= (count lst) 3)\n           (every? tree (rest lst)))))", "user": "5a99ae99e4b0d174b936c7a4"}, {"problem": 95, "code": "(fn tree [lst]\n  (cond (or (seq? lst) (vector? lst)) (and (= 3 (count lst)) (tree (nth lst 1)) (tree (nth lst 2)))\n    (nil? lst)\n   \t\ttrue\n    :else\n   \t\tfalse))", "user": "5a99b87ee4b0d174b936c7af"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond \n   (nil? t) true\n   (coll? t) (and (= (count t) 3) ((complement coll?) (first t)) (tree? (second t)) (tree? (last t)))\n   :else false))", "user": "5a99b688e4b0d174b936c7a6"}, {"problem": 95, "code": "(fn my-tree? [coll]\n  (or (nil? coll)\n      (and (coll? coll)\n           (= (count coll) 3)\n           (let [[v l r] coll]\n             (and (my-tree? l) (my-tree? r))))))", "user": "55b28b57e4b01b9910ae296c"}, {"problem": 95, "code": "(fn tree? [coll]\n  (if (nil? coll) true\n    (if (and (sequential? coll)\n             (= (count coll) 3))\n      (and (tree? (nth coll 1)) (tree? (nth coll 2)))\n      false)))", "user": "5a9db5c9e4b0d174b936c7f1"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n  (and tree\n       (seq tree)\n       (= (count tree) 3)\n       (every? (some-fn nil? binary-tree?) (rest tree))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 95, "code": "(fn tree? [l]\n      (cond\n        (nil? l) true\n        (coll? l) (and\n                    (= 3 (count l))\n                    (tree? (nth l 1))\n                    (tree? (nth l 2)))\n        :else false\n        )\n      )", "user": "5908882de4b047aa04b19979"}, {"problem": 95, "code": "(fn b-tree? [node]\n   (or \n     (nil? node)\n     ((every-pred\n        sequential?\n        (comp (partial = 3) count)\n        (comp b-tree? #(nth % 1))\n        (comp b-tree? #(nth % 2))\n      ) node)))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 95, "code": "(fn tree? [colls]\n  (if (sequential? colls)\n    (and (= 3 (count colls))\n         (tree? (second colls))\n         (tree? (last colls)))\n    (not (false? colls))))", "user": "5a67cedbe4b0512ff01cd9ee"}, {"problem": 95, "code": "(fn istree? [root]\n    (or (nil? root)\n      (and (sequential? root)\n        (= 3 (count root))\n        (every? istree? (rest root))\n      )\n    )\n  )", "user": "59021fede4b0438e51c2d04d"}, {"problem": 95, "code": "#(every? true? (map (fn [coll]\n                     (if (nil? coll)\n                       true\n                       (if-not (= (count coll) 3)\n                         false\n                         (if-not (or (nil? (nth coll 1)) (sequential? (nth coll 1)))\n                           false\n                           (if-not (or (nil? (nth coll 2)) (sequential? (nth coll 2)))\n                             false\n                             true\n                             )\n                           )))) (tree-seq next rest %)))", "user": "5a9ac061e4b0d174b936c7c1"}, {"problem": 95, "code": "(fn tree? [t] (if (nil? t) true (and (or (seq? t) (vector? t)) (= 3 (count t)) (tree? (second t)) (tree? (last t)))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 95, "code": "(fn tree? [node]\n    (or (nil? node)\n        (and (sequential? node)\n             (= 3 (count node))\n             (every? tree? (rest node)))))", "user": "554e4d65e4b00713264bd993"}, {"problem": 95, "code": "(fn is-tree? [root] (or (nil? root) (and (sequential? root) (= 3 (count root)) (every? is-tree? (rest root))) ))", "user": "5ab23a78e4b073f1774425e1"}, {"problem": 95, "code": "(fn valid-tree-node? [t]\n    (let [valid-val? identity\n          valid-child? (fn [child]\n                         (or (nil? child) (coll? child)))]\n      (and (coll? t)\n           (= 3 (count t))\n           (valid-val? (first t))\n           (valid-child? (nth t 1))\n           (valid-child? (nth t 2))\n           (->> (remove #(not (coll? %)) t)\n                (every? valid-tree-node?)))))", "user": "5501a1e1e4b07d26eda61d75"}, {"problem": 95, "code": "(fn [lst]\n  (let [tree (tree-seq #(= (count (if (or (nil? %) (sequential? %)) % nil)) 3) rest lst)]\n    (reduce #(and %1\n                  (or (nil? %2) (sequential? %2))\n                  (or (and (= (count %2) 0) (nil? %2)) \n                      (= (count %2) 3))) true tree)))", "user": "5a9a12d6e4b0d174b936c7b7"}, {"problem": 95, "code": "(fn tree? \n[coll] \n(cond (or (seq? coll) (vector? coll))\n (and (= 3 (count coll)) \n(tree? (first(rest coll))) \n(tree? (first(rest(rest coll)))))\n(nil? coll) true \n:else false))\n\n #_(fn tree? \n[coll] \n(cond (or (seq? coll) (vector? coll))\n (and (= 3 (count coll)) \n(tree? (nth coll 1)) \n(tree? (nth coll 2))) \n(nil? coll) true \n:else false))", "user": "52faf67ce4b047fd55837005"}, {"problem": 95, "code": "(fn f [coll]\n  (cond\n    (coll? coll) (and\n                   (= 3 (count coll))\n                   (f (second coll))\n                   (f (last coll)))\n    (nil? coll) true\n    :else false))", "user": "5aa8f753e4b0d174b936c8d9"}, {"problem": 95, "code": "(fn node? [maybe-tree]\n  (let [nil-or-node (fn [n] (or (nil? n) (node? n)))]\n    (and\n     (sequential? maybe-tree)\n     (= (count maybe-tree) 3)\n     (nil-or-node (second maybe-tree))\n     (nil-or-node (last maybe-tree)))))", "user": "5abbbd46e4b073f1774426db"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node) \n      (and (coll? node) \n           (= 3 (count node))\n           (every? tree? (rest node)))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 95, "code": "(fn [test-tree]\n  (every? true?\n   (map #(if-not (sequential? %)\n           (if (false? %) false true)\n           (if (= (count %) 3)\n             true\n             false)) (tree-seq sequential? identity test-tree))))", "user": "5acd08eee4b0e27600da7822"}, {"problem": 95, "code": "(fn is-tree? [x]\n  (if (not= (count x) 3) false\n      (let [[_ a b] x]\n        (every? true?\n                (map #(cond\n                        (coll? %) (is-tree? %)\n                        (nil? %) true\n                        :else false)\n                     [a b])))))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 95, "code": "(fn tree? [t] (if (or (not (sequential? t)) (not= (count t) 3)) false (let [v (first t) l (first (rest t)) r (last t)] (and (or (nil? l) (tree? l)) (or (nil? r) (tree? r))))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "5ae0976be4b0837691e92c43"}, {"problem": 95, "code": "(fn [tree]\n    (letfn [(binary-tree? [tree]\n              (or (nil? tree)\n                  (and (coll? tree)\n                       (= (count tree) 3)\n                       (let [[root left right] tree]\n                         (and (not (nil? root))\n                              (binary-tree? left)\n                              (binary-tree? right))))))]\n      (binary-tree? tree)))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 95, "code": "(fn binary-tree-test [xs]\n  (if (or (nil? xs) (coll? xs))\n    (cond (= 3 (count xs)) (and (binary-tree-test (nth xs 1)) (binary-tree-test (nth xs 2)))\n          (nil? xs) true\n          :else false)\n    false))", "user": "5ad3d730e4b0ea6055cfabc8"}, {"problem": 95, "code": "(fn is-trie?\n  [coll]\n  (if (not (coll? coll))\n    (nil? coll)\n    (if (= (count coll) 3)\n      (and (is-trie? (first (rest coll)))\n           (is-trie? (first (rest (rest coll)))))\n      false)))", "user": "5a9829e5e4b0d174b936c788"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and \n       (sequential? root)\n       (= 3 (count root))\n       (every? tree? (rest root)))))", "user": "5665ef78e4b0e91d5f5c5664"}, {"problem": 95, "code": "(fn b? [r]\n  (or (nil? r) (and (coll? r) (= (count r) 3)\n                       (b? (nth r 1))\n                       (b? (nth r 2)))))", "user": "5aeca4c9e4b0cc2b61a3bc0a"}, {"problem": 95, "code": "(fn btree? [s]\n  (and (sequential? s)\n       (= 3 (count s))\n       (let [left (second s) right (last s)]\n         (and (or (nil? left) (btree? left))\n              (or (nil? right) (btree? right))))))", "user": "5a5767f3e4b05d388ecb6c65"}, {"problem": 95, "code": ";(fn is-b-tree? [t]\n;  (let [len (if (coll? t) (count t) 1)]\n;    (or (= len 1) (and (= len 3)\n;                       (let [[_ a b] t]\n;                         (cond (= nil a) (or (= nil b) (coll? b))\n;                               (= nil b) (coll? a)\n;                               :else true))\n;                       (reduce\n;                        #(and % (is-b-tree? %2))\n;                        true\n;                        t)))))\n\n(fn is-b-tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (let [[value l r] t] \n             (and (is-b-tree? l) (is-b-tree? r))))))", "user": "5af31955e4b0cc2b61a3bc7a"}, {"problem": 95, "code": "(fn bintree? [arg]\n  (if (not= 3 (count arg))\n    false\n    (let [f (first arg) l (second arg) r (nth arg 2)]\n      (cond\n        (sequential? l) (bintree? l)\n        (sequential? r) (bintree? r)\n        (or (false? (nil? l)) (false? (nil? r))) false\n        :else true\n        )\n      )))", "user": "5adcc688e4b0837691e92c05"}, {"problem": 95, "code": "(fn [s]\n  (letfn [(f [s]\n            (if (or (seq? s) (vector? s))\n              (and (= 3 (count s)) (f (second s)) (f (last s)))\n              (nil? s)))]\n    (f s)))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 95, "code": "(fn checker [node]\n  (cond\n    (nil? node) true\n    (not (coll? node)) false\n    (= 3 (count node)) (let [[_ l r] node]\n                         (and (checker l) (checker r)))\n    :else false))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 95, "code": "(fn good? [node]\n  (if (nil? node)\n    true\n    (if (and (sequential? node)\n             (= 3 (count node)))\n      (let [[v left right] node]\n        (and (good? left) (good? right)))\n      false)))", "user": "5adf5f9be4b0837691e92c33"}, {"problem": 95, "code": "(fn tree? [tree]\n  (if (nil? tree)\n    true\n    (and (sequential? tree)\n         (= 3 (count tree))\n         (tree? (second tree))\n         (tree? (last tree)))))", "user": "5649b1b0e4b0284900eef646"}, {"problem": 95, "code": "(fn bitree [[root l r :as tree]]\n    (and (= (count tree) 3)\n         (not (sequential? root))\n         (or (nil? l) (and (sequential? l) (bitree l)))\n         (or (nil? r) (and (sequential? r) (bitree r)))\n      ))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 95, "code": "(fn bintree? [tree]\n  (cond \n   (nil? tree) true\n   (and \n    (coll? tree)\n    (= 3 (count tree))\n    (bintree? (second tree))\n    (bintree? (last tree))) \n   true\n   :default false))", "user": "5a0ef454e4b04bbd27e6d9fa"}, {"problem": 95, "code": "(fn [[v l r :as p]]\n  (letfn [(tree? [p]\n            (if (nil? p)\n              true\n              (if (and p\n                       (= (count p) 3))\n                (let [[v l r] p]\n                  (and (tree? l)\n                       (tree? r)))\n                false)))]\n    (and (= 3 (count p))\n         (tree? l)\n         (tree? r))))", "user": "5aea2d21e4b0cc2b61a3bbe2"}, {"problem": 95, "code": "(fn tree? [t]\n  (and (sequential? t)\n       (= 2 (count (rest t)))\n       (every? (fn [x] (or (nil? x) (tree? x))) \n               (rest t))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 95, "code": "(fn f [x]\n  (cond (false? x) false\n        (not (or (vector? x) (list? x))) true\n        :else (and (= 3 (count x)) (f (nth x 1)) (f (nth x 2)))))", "user": "55e732c5e4b050e68259b492"}, {"problem": 95, "code": "#(let [f (fn tt [x] (if (and (coll? x) (= (count x) 3))\n              (let [[a b c] x]\n                (for [n [b c]\n                      :when (not (nil? n))]\n                  (tt n)))\n              :fail))\n       r (f %)]\n   (empty? (flatten (list r))))", "user": "5900d5cde4b0438e51c2d02e"}, {"problem": 95, "code": "(fn [x]\n  (loop [nodesToTest [x]]\n    (if (empty? nodesToTest)\n      true\n      (if (nil? (first nodesToTest))\n        (recur (rest nodesToTest))\n        (if (and (coll? (first nodesToTest)) (= 3 (count (first nodesToTest))))\n          (recur (concat (rest nodesToTest) [(second (first nodesToTest)) (last (first nodesToTest))]))\n          false)))))", "user": "54cbd97ae4b057c6fda3a283"}, {"problem": 95, "code": "(fn b [t]\n  (if (nil? t)\n    true\n    (and (coll? t) (= 3 (count t)) (b (nth t 1)) (b (nth t 2)))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 95, "code": "(fn binarytree?\n  [coll]\n  (cond\n    (nil? coll) true\n    (sequential? coll) (and (= 3 (count coll))\n                            (every? binarytree? (rest coll)))))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 95, "code": "(fn valid-tree? [xs]\n  (or (nil? xs)\n      (and (coll? xs)\n       \t   (= 3 (count xs))\n           (valid-tree? (second xs))\n           (valid-tree? (last xs)))))", "user": "5afcd6d1e4b0cc2b61a3bd17"}, {"problem": 95, "code": "(fn node? [node]\n   \n       (if (coll? node)\n         (let [[n lc rc] node]\n           (if (and n (node? lc) (node? rc) (#{3} (count node)))\n             true false))\n         (if (nil? node) true false)))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 95, "code": "#(odd? (count (remove false? (flatten %))))", "user": "5b0546eae4b0cc2b61a3bd7e"}, {"problem": 95, "code": "(fn tree? [[value left right :as s]]\n  (if (= (count s) 3)\n    (and\n      (not (nil? value))\n      (if (coll? left)\n        (tree? left)\n        (nil? left))\n      (if (coll? right)\n        (tree? right)\n        (nil? right)))\n    false))", "user": "5b0bea6de4b0cc2b61a3bdda"}, {"problem": 95, "code": "(fn is-tree [t]\n  (cond\n    (nil? t) true\n    (sequential? t) (and (= (count t) 3)\n                         (is-tree (nth t 1))\n                         (is-tree (nth t 2)))\n    :default false))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 95, "code": "(fn t? [n]\n  (cond (nil? n) true\n        (number? n) true\n        (keyword? n) true\n        (false? n) false\n        (coll? n) (and (-> n count (= 3)) \n                       (t? (second n)) \n                       (t? (last n)))\n        :else false))", "user": "51a3be77e4b0e77c4ca60bf8"}, {"problem": 95, "code": "(fn is-tree [[x l r :as w]]\n  (cond\n   (not= (count w) 3) false\n   (nil? x) true\n        \n        :else\n          (and\n            (if (sequential? l) (is-tree l) (nil? l))\n            (if (sequential? r) (is-tree r) (nil? r)))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 95, "code": "(fn bintree? [coll]\n  (cond\n    (nil? coll) true\n    (and (coll? coll) (= (count coll) 3))\n    (let [root (first coll)\n          left (second coll)\n          right (last coll)]\n      (and (not (coll? root))\n           (not (nil? root))\n           (bintree? left)\n           (bintree? right)))\n    :else false))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 95, "code": "(fn istree? [root]\n (or (nil? root)\n  (and (sequential? root)\n   (= 3 (count root))\n   (every? istree? (rest root)))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 95, "code": ";;wrong recursion we should use loop\n(fn tree [[n c1 c2 :as v]]\n  (and \n    (= 3 (count v))\n    (not (sequential? n))\n    (or (nil? c1) (and (sequential? c1) (tree c1)))\n    (or (nil? c2) (and (sequential? c2) (tree c2)))))", "user": "5b198eace4b03cfeda66ecbb"}, {"problem": 95, "code": "#(every? (fn [x] (if (coll? x) (= (count x) 3) (nil? x))) (tree-seq identity rest %))", "user": "5b210749e4b03cfeda66ed48"}, {"problem": 95, "code": "(fn valid-tree [tree]\n  (if (nil? tree) true\n    (if (not (and (counted? tree) (= 3 (count tree))))\n      false\n      (let [[value left right] tree]\n        (and (valid-tree left) (valid-tree right))))))", "user": "5b1d61b3e4b03cfeda66ecfe"}, {"problem": 95, "code": "(fn f [s]\n  (if (sequential? s)\n    (let [[val l r] s]\n      (and (= (count s) 3)\n           (or (nil? l) (f l))\n           (or (nil? r) (f r))))\n    false))", "user": "5777c3d6e4b0979f8965164f"}, {"problem": 95, "code": "(fn tt[t]\n  (let [legs (rest t)\n        left-leg (first legs)\n        right-leg (last legs)\n        node? (fn [node]\n            (and (= (count node) 3)\n                 (every? #(or (coll? %) (nil? %)) legs)))]\n    (and\n     (node? t)\n     (if (coll? left-leg) (tt left-leg) true)\n     (if (coll? right-leg) (tt right-leg) true))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 95, "code": "(fn isBinaryTree? [tree]\n  (cond\n\t(nil? tree) true\n   \t(not (sequential? tree)) false\n    (not (= 3 (count tree))) false\n    :else (every? isBinaryTree? (next tree))))", "user": "5ab5f60be4b073f177442643"}, {"problem": 95, "code": "(fn tree? [x]\n  (and\n    (sequential? x)\n    (= 3 (count x))\n    (not (nil?  (nth x 0)))\n    (or  (nil?  (nth x 1))\n         (tree? (nth x 1)))\n    (or  (nil?  (nth x 2))\n         (tree? (nth x 2)))))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 95, "code": "(fn test-tree [tree] \n   (cond\n    (nil? tree) true\n    (not (sequential? tree)) false\n    (= 3 (count tree)) (every? identity (map test-tree (rest tree)))\n    :else false))", "user": "5508a292e4b06e50f9beb10f"}, {"problem": 95, "code": "(fn bt? [x] (or (= x nil) (and (coll? x) (= (count x) 3) (every? bt? (rest x)))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 95, "code": "(fn node? [v]\n             (if (and (sequential? v) (= 3 (count v)))\n               (let [left (first (next v))\n                     right (first (next (next v)))]\n                 (and (not (nil? (first v)))\n                      (or (nil? left) (node? left))\n                      (or (nil? right) (node? right))))\n               false))", "user": "5a5894d9e4b05d388ecb6c81"}, {"problem": 95, "code": "(fn tree [t] (or (= t nil) (and (not= t false) (= (count t) 3) (-> t second tree) (-> t rest second tree))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 95, "code": "(fn f[x]\n\t( if (coll? x)\n\t\t( if (= 3 (count x))\n \t\t  (and (f (second x)) (f (second (rest x))))         \n          false\n\t\t)\n      (= x nil)\n     )\n    )", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n    (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2))) \n    (nil? coll) true\n    :else false))", "user": "53d5d43ce4b0e771c302544d"}, {"problem": 95, "code": "(fn isbin [tree] (if (nil? tree) true (if (sequential? tree) (if (= 3 (count tree)) (and (not (nil? (first tree))) (isbin (second tree)) (isbin (last tree))) false) false)))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 95, "code": "(fn is-binary-tree? [node]\n  (and (sequential? node)\n       (= (count node) 3)\n       (or (nil? (second node)) (is-binary-tree? (second node)))\n       (or (nil? (last node)) (is-binary-tree? (last node)))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 95, "code": "(fn is-tree? \n  [coll]\n  (if (nil? coll)\n    true\n    (and (sequential? coll)\n     \t (= 3 (count coll))\n         (every? is-tree? (rest coll)))))", "user": "5b0b8d29e4b0cc2b61a3bdd7"}, {"problem": 95, "code": "(fn tcheck [t] (if (and (sequential? t) (= (count t) 3)) (let [head (first t)\n                                                             left (second t)\n                                                             right (nth t 2)]\n                                                         (and (or (nil? left) (tcheck left)) (or (nil? right) (tcheck right)))) false))", "user": "5839f079e4b089d5ab817d48"}, {"problem": 95, "code": "(fn tree? [s]\n  (let [l (second s)\n        r (second (rest s))\n        test? #(and (or (nil? %)\n                        (and (not (false? %))\n                             (not (empty? %))\n                             (tree? %))))]\n    (and (= 3 (count s))\n         (test? l)\n         (test? r))))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 95, "code": "(fn istree [lst]\n  (and\n   (coll? lst)\n   (= 3 (count lst))\n   (or (= nil (second lst)) (istree (second lst)))\n   (or (= nil (nth lst 2)) (istree (nth lst 2)))\n   )\n  )", "user": "5b5e5019e4b0c6492753e6d3"}, {"problem": 95, "code": "(fn bt? [n]\n  (if (not= 3 (count n))\n    false\n    (every?\n      #(identity %)\n      (for [i n]\n        (if (contains?\n              #{java.lang.Long java.lang.String clojure.lang.Keyword nil}\n              (type i))\n          true\n          (if (coll? i)\n            (bt? i)))))))", "user": "5a9d64c8e4b0d174b936c7eb"}, {"problem": 95, "code": "(fn is-tree[ candidate ]\n  (println \"c\" candidate)\n  (and\n    (sequential? candidate)\n    (= 3 (count candidate))\n    (let [[value left right] candidate]\n      (println value left right (count candidate))\n      (and\n        (not (nil? value))\n        (or (nil? left) (is-tree left))\n        (or (nil? right) (is-tree right))\n      )\n    )\n  )\n)", "user": "5b58b271e4b02d533a91bd6e"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "59cd13d5e4b0ef0a1e9b5b32"}, {"problem": 95, "code": "(fn tree? [[node l r :as tree]]\n  (and\n   (= 3 (count tree))\n   (not (sequential? node))\n   (or (nil? l) (and (sequential? l) (tree? l)))\n   (or (nil? r) (and (sequential? r) (tree? r)))))", "user": "59ef6cfae4b0966464fe6a32"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (sequential? coll)\n    (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll)\n    true\n    :else\n    false))", "user": "56e2ca59e4b03a7c14b85a38"}, {"problem": 95, "code": "(fn istree? [root]\n (or (nil? root)\n  (and (sequential? root)\n   (= 3 (count root))\n   (every? istree? (rest root)))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 95, "code": "(fn foo\n  [tree]\n  (if (not= 3 (count tree))\n    false\n    (let [[root child1 child2] tree]\n      (and (if (nil? child1) true (if (sequential? child1) (foo child1) false))\n           (if (nil? child2) true (if (sequential? child2) (foo child2) false))))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 95, "code": "(fn t? [t] \n  (or (nil? t)\n     (and \n      (sequential? t) \n      (= 3 (count t)) \n      (every? t? (rest t)))))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 95, "code": "(fn bt [t] (= (tree-seq #(and (coll? %) (= 3 (count %))) #(cons (first %) (filter (fn [v] (or (nil? v) (and (coll? v) (not-empty v)))) (rest %))) t) (tree-seq coll? seq t)))", "user": "5b421edce4b02d533a91bc2c"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree? (rest root)))))", "user": "5aeb0b44e4b0cc2b61a3bbee"}, {"problem": 95, "code": "(fn tree? [xs]\n  (cond\n   (nil? xs) true\n   (not (coll? xs)) false\n   (not= (count xs) 3) false\n   (coll? (first xs)) false\n   :else (reduce #(and %1 (tree? %2)) true (rest xs))))", "user": "5a544eeee4b05d388ecb6c24"}, {"problem": 95, "code": "(fn isTree [arg]\n  (if (coll? arg)\n    (and (= (count arg) 3) (isTree (nth arg 1)) (isTree (nth arg 2)))\n    (nil? arg)))", "user": "5b6473eee4b0c6492753e73f"}, {"problem": 95, "code": "(fn istree [tree]\n  (if (nil? tree)\n    true\n    (if-not (and (coll? tree) (= 3 (count tree)))\n      false\n      (and\n        (istree (nth tree 1))\n        (istree (nth tree 2))))))", "user": "5b840b68e4b047b03b2037bc"}, {"problem": 95, "code": "(fn binary-tree? [root]\n  (or (nil? root)\n      (and (coll? root) (= 3 (count root)) (first root)\n           (binary-tree? (second root)) (binary-tree? (last root)))))", "user": "5b772ad7e4b047b03b2036e8"}, {"problem": 95, "code": "(fn bt? [xs]\n        (if (coll? xs)\n          (let [[v l r] xs]\n            (cond \n              (not= 3 (count xs))\n              false\n              \n              (and (nil? l) (nil? r))\n              true\n              \n              :else\n              (and (or (nil? l) (bt? l)) \n                   (or (nil? r) (bt? r)))))\n          false))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 95, "code": "(fn is-tree?\n  [coll]\n  (or (nil? coll)\n    (and (sequential? coll)\n          (= 3 (count coll))\n          (every? is-tree? (rest coll)))))", "user": "5a3c06fce4b001c08efc0cdd"}, {"problem": 95, "code": "(fn is-tree [t]\n  (or\n    (nil? t)\n    (and (coll? t)\n         (= 3 (count t))\n         (every? is-tree (rest t)))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 95, "code": "(fn tree? [[root l r :as tree]]\n    (if (and (= 3 (count tree)) root)\n      (and (or (nil? l) (and l (tree? l)))\n           (or (nil? r) (and r (tree? r))))\n      false))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5b985fe5e4b0c0b3ffbd4ab1"}, {"problem": 95, "code": "(fn is-bt? [x] (or (nil? x) (and (sequential? x) (= 3 (count x)) (every? is-bt? (rest x)))))", "user": "5b857411e4b047b03b2037ce"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5b88f0c0e4b047b03b203816"}, {"problem": 95, "code": "(fn is-binary-tree? [T]\n  (or\n    (nil? T)\n    (and\n      (sequential? T)\n      (= 3 (count T))\n      (every? is-binary-tree? (rest T)))))", "user": "5813e208e4b0f478707a061b"}, {"problem": 95, "code": "(fn is-node [x] (and (coll? x) (= 3 (count x)) (not (coll? (first x))) (not (nil? (first x))) (or (nil? (second x)) (and (coll? (second x)) (is-node (second x)))) (or (nil? (nth x 2)) (and (coll? (nth x 2)) (is-node (nth x 2))))))", "user": "5b7bc82ce4b047b03b203726"}, {"problem": 95, "code": "(fn bin-tree? [col]\n  (if\n    (sequential? col) (let [[_ left right] col]\n                        (and (= 3 (count col))\n                             (bin-tree? left)\n                             (bin-tree? right)))\n    (nil? col)))", "user": "5b333626e4b025bcb146f32f"}, {"problem": 95, "code": "(fn tree? [x]\n  (if (or ((complement sequential?) x) (not= 3 (count x)))\n    false\n    (let [[root left right] x]\n       (and ((complement sequential?) root)\n            (or (nil? left) (tree? left))\n            (or (nil? right) (tree? right))))))", "user": "5b9db58be4b0c0b3ffbd4b41"}, {"problem": 95, "code": "(fn binary?\n  [tree]\n  (or\n   (nil? tree)\n   (and\n    (coll? tree)\n    (= 3 (count tree))\n    (binary? (nth tree 1))\n    (binary? (nth tree 2)))))", "user": "5af3aa42e4b0cc2b61a3bc8c"}, {"problem": 95, "code": "(fn tt [t]\n  (cond\n    (nil? t) true\n    (and (sequential? t) (= 3 (count t))) (and (tt (last t)) (tt (last (butlast t))))\n    :else false))", "user": "570d0548e4b0b0fb43fd06d2"}, {"problem": 95, "code": "(fn tree? [[v l r :as xs]]\n  (cond\n    (not= 3 (count xs)) false\n    (false? v) false\n    :else\n    (if-let [l? (if (sequential? l) (tree? l) (not (false? l)))]\n      (if (sequential? r) (tree? r) (not (false? r)))\n      false)))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 95, "code": "(fn \n       tree?\n       [t]\n       (or (nil? t)\n           (and \n            (coll? t)\n            (= 3 (count t))\n            (tree? (second t))\n            (tree? (nth t 2)))))", "user": "5bab5440e4b0a20761a23475"}, {"problem": 95, "code": "(fn tr [[_ l r :as x]]\n  (cond \n   (nil? x) true \n   (or (false? l) (false? r)) false\n   (= (count x) 3) (and (tr l) (tr r))\n   :else false))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 95, "code": "(fn bin-tree? [node]\n    (and (sequential? node)\n         (= (count node) 3)\n         (let [left (nth node 1)\n               right (nth node 2)]\n          (and\n             (or (nil? left) (bin-tree? left))\n             (or (nil? right)(bin-tree? right))))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 95, "code": "(fn btree? [node]\n      (or\n        (nil? node)\n        (and\n          (coll? node)\n          (= (count node) 3)\n          (every? true? (map btree? (rest node))))))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 95, "code": "(fn bin [xs]\n    (if (nil? xs)\n      true\n      (if (or (not (coll? xs)) (not= 3 (count xs)))\n        false\n        (and (bin (nth xs 1)) (bin (nth xs 2))))))", "user": "5a084a24e4b01bb0ae8afdf2"}, {"problem": 95, "code": "(fn isNode? [n] (and (and n (= (count n) 3)) (complement (nil? (first n))) (or (nil? (nth n 1)) (isNode? (nth n 1))) (or (nil? (nth n 2)) (isNode? (nth n 2)))))", "user": "5ba947bfe4b0a20761a23440"}, {"problem": 95, "code": "(fn t [xs] (and\n              (= 3 (count xs))\n              (not (nil? (first xs)))\n              (not (coll? (first xs)))\n              (if (coll? (second xs)) (t (second xs)) (not (false? (second xs))))\n              (if (coll? (last xs)) (t (last xs)) (not (false? (last xs))))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 95, "code": "(fn [lst] \n    (every?\n      #(cond\n        (and (sequential? %) (= (count %) 3)) true\n        (nil? %) true\n        :else false)\n      (tree-seq sequential? rest lst)))", "user": "5bbbce0ee4b0a20761a2360d"}, {"problem": 95, "code": "(fn [coll]\n    (->>\n        (tree-seq\n           coll?\n           (fn [node] (rest node))\n           coll)\n        (every? #(or (nil? %) (and (coll? %) (= (count %) 3))))\n     ))", "user": "5a66fddee4b0512ff01cd9d7"}, {"problem": 95, "code": "(fn tt\n  [node]\n  (if (coll? node)\n       (and (= 3 (count node))\n            (tt (second node))\n            (tt (last node)))\n       (cond \n           (nil? node) true\n           (false? node) false\n           (empty? node) false\n           :else true)))", "user": "599342efe4b0b211ea3aaab0"}, {"problem": 95, "code": "(fn is-binary? [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (is-binary? (second tree)) (is-binary? (nth tree 2)))))", "user": "5bbbba29e4b0a20761a23609"}, {"problem": 95, "code": "(fn bintree? [col]\n  (if (= nil col) true\n                  (if (or (not (coll? col)) (not= (count col) 3))\n     false\n     (and (first col) (bintree? (second col)) (bintree? (nth col 2)))\n     )))", "user": "5b9c4a7be4b0c0b3ffbd4b16"}, {"problem": 95, "code": "(fn [x] (every? \n         #(and\n            (not (false? %))\n            (or (and (not (seq? %)) (not (vector? %)))\n              (= 3 (count %)))\n           )        \n        (tree-seq (some-fn seq? vector?) seq x)))", "user": "5ade6bafe4b0837691e92c23"}, {"problem": 95, "code": "(fn ff [col]\n  (cond\n   (not (coll? col))       (not (false? col))\n   (not (= (count col) 3)) false\n   :else (every? ff col)))", "user": "56327168e4b0bfe05bf117a5"}, {"problem": 95, "code": "(fn is-tree?\n  [my-seq]\n  (if (or (nil? my-seq) (not (coll? my-seq)))\n    (if-not (= java.lang.Boolean  (type my-seq))\n      true\n      false)\n    (if (= (count my-seq) 3)\n      (and (is-tree? (first my-seq)) (is-tree? (second my-seq)) (is-tree? (last my-seq)))\n      false)))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond (nil? t) true\n        (coll? t) (and (= (count t) 3)\n                       ((complement coll?) (first t))\n                       (tree? (second t))\n                       (tree? (last t)))\n        :else false))", "user": "5bc255b7e4b07a9b28b10029"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5bc50870e4b07a9b28b10069"}, {"problem": 95, "code": "(fn [x]\n  (->>\n   (flatten x)\n   (filter #(or (keyword? %) (number? %) (nil? %)))\n   (count)\n   (odd?))\n  )", "user": "54ca35c6e4b057c6fda3a254"}, {"problem": 95, "code": "(fn tree?\n  [seq]\n  (cond\n    (not (= 3 (count seq)))\n    false\n\n    (and (coll? (second seq)) (coll? (nth seq 2)))\n    (and (tree? (second seq)) (tree? (nth seq 2)))\n\n    (coll? (second seq))\n    (if (nil? (nth seq 2)) (tree? (second seq)) false)\n\n    (coll? (nth seq 2))\n    (if (nil? (second seq)) (tree? (nth seq 2)) false)\n\n    :else\n    (and (nil? (second seq)) (nil? (nth seq 2)))\n    )\n  )", "user": "5bc8c033e4b07a9b28b100ca"}, {"problem": 95, "code": "(fn bin_tree \n  ; checks if seq is binary tree\n  [xs]\n  (letfn [(node [col idx]\n            (let [elem (nth col idx)]\n              (if (nil? elem) true\n                (and (coll? elem) (bin_tree elem)))))]\n    (if (= 3 (count xs))\n      (and(not (nil? (nth xs 0))) (node xs 1) (node xs 2)) false)))", "user": "5bbbcecee4b0a20761a23611"}, {"problem": 95, "code": "(fn bin-tree? \n   [tree]\n   (and (sequential? tree) (= (count tree) 3)\n     (let [l (second tree)\n           r (last tree)]\n       (and (or (nil? l) (bin-tree? l))\n         (or (nil? r) (bin-tree? r))))))", "user": "5bbc0ddfe4b0a20761a2361e"}, {"problem": 95, "code": "(fn tree? [lst]\n  (cond\n    (or (seq? lst) (vector? lst))\n      (and (= 3 (count lst)) (tree? (nth lst 1)) (tree? (nth lst 2)))\n    (nil? lst) true\n    :else false))", "user": "5bbbce70e4b0a20761a2360f"}, {"problem": 95, "code": "(fn tree?\n  [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree? (rest root))))\n  )", "user": "5bbbce99e4b0a20761a23610"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree? (rest root)))))", "user": "5bbbce60e4b0a20761a2360e"}, {"problem": 95, "code": "(fn tree? [lst] (cond\n    (or (seq? lst) (vector? lst))\n      (and (= 3 (count lst)) (tree? (nth lst 1)) (tree? (nth lst 2)))\n    (nil? lst) true\n    :else false))", "user": "5bc7ba68e4b07a9b28b100b0"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5a99c5a9e4b0d174b936c7b1"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5bbbcf3ae4b0a20761a23612"}, {"problem": 95, "code": "(fn tree? [lst]\n  (cond\n    (or (seq? lst) (vector? lst)) (and (= 3 (count lst)) (tree? (nth lst 1)) (tree? (nth lst 2)))\n    (nil? lst) true\n    :else false))", "user": "5bcb672ee4b07a9b28b10100"}, {"problem": 95, "code": "(fn tree?\n  [tree]\n   (or (nil? tree) (and (sequential? tree) (= 3 (count tree)) (every? tree? (rest tree)))))", "user": "5bbbcf9ee4b0a20761a23614"}, {"problem": 95, "code": "(fn bin? [coll]\n  (if (and (sequential? coll) (= 3 (count coll)))\n    (and\n     (not (nil? (first coll)))\n     (every? #(or (nil? %) (bin? %)) (rest coll))) \n    false))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 95, "code": "(fn tree? [l]\n\t(cond\n\t\t(nil? l)\n\t\t\ttrue\n\t\t(sequential? l)\n\t\t\t(and (= 3 (count l)) (tree? (second l)) (tree? (nth l 2)))\n\t\t:e\n\t\t\tfalse\n\t)\n)", "user": "5bbbd484e4b0a20761a23617"}, {"problem": 95, "code": "(fn btree [coll]\n  (cond\n    (or (not= 3 (count coll)) (not-every? #(not (false? %)) coll)) false\n    (and (= 3 (count coll)) (every? #(not (coll? %)) coll)) true\n    :else (every? true? (flatten (filter #(not (nil? %)) (map #(if (coll? %) (btree %)) coll))))\n  )\n)", "user": "5bc28638e4b07a9b28b10033"}, {"problem": 95, "code": "(fn tree? [node]\n  (if (sequential? node)\n    (if (= (count node) 3)\n      (let [[root l r] node]\n        (and (tree? l) (tree? r)))\n      false)\n    (nil? node)))", "user": "543a8256e4b032a45b869327"}, {"problem": 95, "code": "(fn isTree [col]\n    (if (and (coll? col) (= 3 (count col)))\n      (and\n        (or (nil? (second col)) (isTree (second col)) )\n        (or (nil? (last col)) (isTree (last col)) )\n      )\n      false\n    )\n  )", "user": "5bbd13a5e4b07a9b28b0ff95"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5bbbcf81e4b0a20761a23613"}, {"problem": 95, "code": "(fn isbtree [coll]\n  (cond (false? coll) false\n        (nil? coll) true\n        (and \n          (->> coll (take 4) count (= 3))\n          (-> coll rest first isbtree)\n          (-> coll rest rest first isbtree)) true\n        :else false))", "user": "5bc833a5e4b07a9b28b100bb"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (or \n    (nil? t) \n    (and (sequential? t) (= 3 (count t)) (is-tree? (second t)) (is-tree? (nth t 2)))))", "user": "59a0286be4b0871e7608b82f"}, {"problem": 95, "code": "(fn tree? [t]\n   (if (coll? t)\n     (and (= 3 (count t)) (tree? (second t)) (tree? (last t)))\n     (nil? t)))", "user": "5b81139fe4b047b03b203782"}, {"problem": 95, "code": "(fn func [x] (println x) (or (nil? x) (and (or (vector? x) (seq? x)) (= 3 (count x)) (not (nil? (first x))) (func (second x)) (func (nth x 2)))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 95, "code": "(fn t [x]\n       (if (coll? x)\n         (and (= 3 (count x)) (t (nth x 1)) (t (last x)))\n         (nil? x)))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 95, "code": "(fn tt [xs]\n   (if (coll? xs)\n     (and (= 3 (count xs)) (tt (nth xs 1)) (tt (nth xs 2)))\n     (= nil xs)))", "user": "5be0306be4b0ed4b8aab4c7d"}, {"problem": 95, "code": "(fn [tree]\n    (every? (fn [node]\n              (if (coll? node)\n                (and\n                 (= (count node)\n                    3)\n                 (or (coll? (first (rest node)))\n                     (= nil (first (rest node))))\n                 (or (coll? (first (rest (rest node))))\n                     (= nil (first (rest (rest node))))))\n                true))\n            (tree-seq coll?\n                      identity\n                      tree)))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "575f6a80e4b08062f99a4e80"}, {"problem": 95, "code": "(fn binary-tree? [r]\n  (or (nil? r)\n    (and (sequential? r)\n         (= 3 (count r))\n         (every? binary-tree? (rest r)))))", "user": "5a03d246e4b01bb0ae8afd8c"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (and (coll? t) (= (count t) 3))\n    (and (tree? (nth t 1)) (tree? (nth t 2)))\n    (nil? t)))", "user": "5be58beae4b0ed4b8aab4d14"}, {"problem": 95, "code": "(fn is-binary [c]\n  (or\n   (nil? c)\n   (and\n    (sequential? c) ;; can't use seq? here as it returns false for vectors\n    (= 3 (count c))\n    (every? is-binary (rest c)))))", "user": "5bb948f5e4b0a20761a235d5"}, {"problem": 95, "code": "(fn bt? [t]\n  (letfn [(sq? [x] (or (vector? x) (seq? x)))]\n  (or (= t nil)\n     (and\n       (sq? t)\n       (= 3 (count t))\n       (not (sq? (first t)))\n       (bt? (second t))\n       (bt? (second (rest t)))\n      )   \n  )\n  )\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 95, "code": "(fn bar [t]\n  (and (sequential? t)\n       (= (count t) 3)\n       (and (or (nil? (first (rest t))) (bar (first (rest t))))\n            (or (nil? (first (rest (rest t)))) (bar (first (rest (rest t)))))  \n        )\n  )\n)", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 95, "code": "(fn is-tree [a]\n  (if (or (vector? a) (seq? a))\n    (if (= (count a) 3)\n      (and (is-tree (second a)) (is-tree (nth a 2)))\n      false)\n    (if (or (integer? a) (nil? a))\n      true\n      false)))", "user": "5bf0aefde4b0a6d31fed215a"}, {"problem": 95, "code": "(fn tree? [root] \n  (if-let [[v l r] root]\n    (let [pred #(or (nil? %) (and (coll? %) (tree? %)))]\n    (and\n      (= 3 (count root))\n      (not (coll? v))\n      (pred l)\n      (pred r)))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 95, "code": "(fn tree? [seq]\n    (cond \n      (not (sequential? seq)) false\n      (not (= (count seq) 3)) false\n      :else (let [[root left right] seq]\n              (and \n                (not (nil? root)) \n                (or (tree? left) (nil? left)) \n                (or (tree? right) (nil? right))))))", "user": "5bf1b957e4b0a6d31fed216f"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (let [[_ l r] t] (and (binary-tree? l) (binary-tree? r))))))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 95, "code": "(fn is-binary-tree [coll]\n  (if (and (sequential? coll) (= (count coll) 3))\n    (let [left (nth coll 1) right (nth coll 2)]\n      (and (is-binary-tree left)(is-binary-tree right)))\n    (nil? coll)))", "user": "5c03e927e4b0bdcf453d167b"}, {"problem": 95, "code": "(fn tree [[v l r :as all]]\n   (if (not (= (count all) 3))\n     false\n     (and (or (nil? l) (and (sequential? l) (tree l))) \n          (or (nil? r) (and (sequential? r) (tree r))))))", "user": "5b15ab32e4b0cc2b61a3be72"}, {"problem": 95, "code": "(fn binary-tree? [col]  \n  (cond \n    (nil? col) true    \n    (and (sequential? col) (= 3 (count col))) (every? binary-tree? (rest col))\n    :else false))", "user": "5c01ba2ce4b0bdcf453d1656"}, {"problem": 95, "code": "(fn check \n  [node] \n  (if (nil? node)\n    true\n    (and (or (seq? node) (vector? node)) (= 3 (count node)) (check (nth node 1)) (check (nth node 2)))))", "user": "4eadc217535d7eef30807321"}, {"problem": 95, "code": "(fn binary? [s]\n  (and\n    (sequential? s)\n    (= (count s) 3)\n    (let [ left (second s)\n           right (last s)]\n      (and\n        (or\n          (nil? left)\n          (binary? left))\n        (or\n          (nil? right)\n          (binary? right))))))", "user": "5ac9c737e4b0e27600da77d2"}, {"problem": 95, "code": "(fn islist [lists]\n  (if (= lists nil) true\n    (if (not (sequential? lists)) false\n    (if (not= (count lists) 3) false\n      (let [[_ l r] lists] (and (islist l) (islist r)))))))", "user": "5c1edf23e4b0efcb0b05b25d"}, {"problem": 95, "code": "(fn binary? [tree]\n  \"Technically speaking, nil is a tree.\"\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           ; (not (coll? (first tree)))\n           (every? binary? (rest tree)))))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 95, "code": "(fn validate-tree\n  [tree]\n  (if (not= 3 (count tree))\n    false\n    (if (some coll? tree)\n      (every? (fn [a] (if (coll? a)\n                          (validate-tree a)\n                          (not= false a)\n                          )) (rest tree))\n      (if (every? #(not= false %) tree)\n        true\n        false))))", "user": "5c1d9f05e4b0efcb0b05b24c"}, {"problem": 95, "code": "(fn binary-tree?\n  [tree]\n  (cond\n    (nil? tree) true\n    (not (sequential? tree)) false\n    :else (and (binary-tree? (second tree))\n               (binary-tree? (second (rest tree)))\n               (= 3 (count tree)))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 95, "code": "(fn bt [t]\n    (or\n      (nil? t)\n      (and\n        (coll? t)\n        (= 3 (count t))\n        (every? bt (rest t)))))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 95, "code": "(fn t [c]\n  (or (nil? c)\n      (and (sequential? c)\n           (every? t (rest c))\n           (= 3 (count c)))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 95, "code": "(fn binary-tree?\n  [s]\n  (if\n    (and\n      (= (count s) 3)\n      (not (sequential? (first s)) )\n      (or (nil? (second s)) (and (sequential? (second s)) (binary-tree? (second s)) ) )\n      (or (nil? (nth s 2)) (and (sequential? (nth s 2)) (binary-tree? (nth s 2)) ) )\n      )\n    true\n    false\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 95, "code": "(fn tree [s]\n  (and (sequential? s)\n       (= 3 (count s))\n       \n       (or (nil? (second s))\n           (tree (second s)))\n           \n       (or (nil? (nth s 2))\n           (tree (nth s 2)))))", "user": "54df2609e4b024c67c0cf7a9"}, {"problem": 95, "code": "(fn btree? [xs]\n     (cond\n       ((complement coll?) xs) (or (number? xs)\n                                   (nil? xs)\n                                   (keyword? xs)),          ;atom? number or nil\n       (and (coll? xs) (= 3 (count xs))) (let [xs (vec xs)]\n                                           (and (btree? (first xs))\n                                                (btree? (xs 1))\n                                                (btree? (xs 2)))),\n       :else false))", "user": "5c17467fe4b01240ff5671df"}, {"problem": 95, "code": "(fn t [n] (and (coll? n) (= 3 (count n)) (every? #(or (nil? %) (t %)) (rest n))))", "user": "5bfe4ecfe4b0bdcf453d1608"}, {"problem": 95, "code": "(fn [x]\n  (letfn [(tree? [x]\n            (and (coll? x)\n                 (= 3 (count x))\n                 (let [[_ l r] x]\n                   (and (or (nil? l) (tree? l))\n                        (or (nil? r) (tree? r))))))]\n    (tree? x)))", "user": "5c2d1f21e4b0d62ef62d9eef"}, {"problem": 95, "code": "(fn is-binary-tree? [s]\n  (if (some #(= false %) s) false\n      (let [children-colls (filter coll? s)]\n        (if (and (> (count s) 2)\n                 (< (count children-colls) 3)\n                 (reduce (fn [r x] (and (is-binary-tree? x) r)) true children-colls))\n          true false))))", "user": "5b2689e3e4b063e2438bcc33"}, {"problem": 95, "code": "(fn tree? [t]\n    (if (not= 3 (count t))\n      false\n      (let [[lf b1 b2] t\n            scalar? (fn [x] (and (not (nil? x)) (not (coll? x))))]\n        (and\n          (scalar? lf)\n          (and (not (scalar? b1)) (or (nil? b1) (tree? b1)))\n          (and (not (scalar? b2)) (or (nil? b2) (tree? b2)))))))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 95, "code": "(fn istree [col]\n  (cond\n    (nil? col) true\n    (coll? col) (let [[val & rest] col]\n                  (if (nil? val)\n                    false\n                    (and (= (count rest) 2)\n                         (let [[l r] rest]\n                           (and\n                            (istree l)\n                            (istree r))))))\n    :else false))", "user": "5c195cb2e4b01240ff5671f7"}, {"problem": 95, "code": "(fn isbin? [t] (println t) (if (sequential? t) (and (= 3 (count t)) (isbin? (last t)) (isbin? (first (rest t)))) (nil? t)))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 95, "code": "(fn binary-tree? [s]\n  (if (= 3 (count s))\n    (reduce #(if (sequential? %2) (and (binary-tree? %2) %1)\n                 (if (instance? Boolean %2) (and %1 %2) %1)) true s)\n    false))", "user": "57d57f65e4b0bd073c2023b3"}, {"problem": 95, "code": "(fn is-binary-tree [x]\n  (if (coll? x)\n    (and (= (count x) 3) (and (is-binary-tree (second x)) (is-binary-tree (nth x 2))))\n    (nil? x)))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c321b8ae4b0d62ef62d9f32"}, {"problem": 95, "code": "(fn is-tree [node]\n    (let [is-node (fn [xs] (and (coll? xs) (= 3 (count xs))))]\n      (if (nil? node)\n        true\n        (and (is-node node)\n             (is-tree (nth node 1))\n             (is-tree (nth node 2))))))", "user": "5920c191e4b09b4ee5954c61"}, {"problem": 95, "code": "(letfn [(btree? [[val left right :as tree]]\n          (and (= (count tree) 3)\n               (not (coll? val))\n               (or (nil? left) (and (coll? left) (btree? left)))\n               (or (nil? right) (and (coll? right) (btree? right)))))]\n  btree?)", "user": "5c3ec6dbe4b08cd430848e8a"}, {"problem": 95, "code": "(fn poo [seq]\n  (or (nil? seq)\n      (and (sequential? seq)\n           (= (count seq) 3)\n           (every? poo (rest seq))))\n\n    )", "user": "53b0750fe4b047364c044483"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (coll? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (nil? s)\n    true\n    (if (or (not (coll? s)) (not= 3 (count s)))\n      false\n      (and (is-tree (nth s 1)) (is-tree (nth s 2)))\n      )\n\n    )\n  )", "user": "5c48757fe4b0e06e1360a3c3"}, {"problem": 95, "code": "(fn bt [t]\n  (if (coll? t)\n    (cond\n     (= 3 (count t))\n      (let [tt (drop 1 t) a (first tt) b (last tt)]\n        (and (bt a) (bt b))\n      )\n     (= 1 (count t)) true\n     :else false\n    )\n    (nil? t)\n  )\n)", "user": "5763818ae4b0994c1922fbc7"}, {"problem": 95, "code": ";; A Binary Tree is a:\n;; - Coll (MUST HAVE 3 ELEMENTS: id, Tree, Tree)\n\n;; A Tree is one of:\n;; - nil\n;; - Binary Tree\n\n#(letfn [(b-tree? [bt]\n           (if (coll? bt)\n             (let [[_ left right] bt]\n               (and (= (count bt) 3)\n                    (tree? left)\n                    (tree? right)))\n             false))\n         (tree? [t] (or (nil? t) (b-tree? t)))]\n   (b-tree? %))", "user": "5c3cd80fe4b0d62ef62d9faa"}, {"problem": 95, "code": "(fn tree? [s]\n  (and (= 3 (count s))\n       (not (sequential? (first s)))\n       (if (sequential? (second s))\n         (tree? (second s))\n         (nil? (second s)))\n       (if (sequential? (last s))\n         (tree? (last s))\n         (nil? (last s)))))", "user": "56483f45e4b0284900eef62b"}, {"problem": 95, "code": "(fn tree-not-tree [xs]\n  (let [has3elm? (= 3 (count xs))\n        nested-collections (filter coll? xs)]\n    (cond\n      (and\n           has3elm?\n           (empty? nested-collections)\n           (= 2 (count (filter nil? xs))))\n      true\n      (and\n           (not-empty nested-collections)\n           has3elm?\n           (every? true? (map tree-not-tree nested-collections)))\n      true\n      :else\n      false)))", "user": "5984e7dee4b021a7a535fe43"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= 3 (count coll))\n           (binary-tree? (nth coll 1))\n           (binary-tree? (nth coll 2)))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 95, "code": "(fn x [s]\n  (if (coll? s) (and (first s) \n                     (= 3 (count s))\n                     (every? identity (map x (rest s))))\n      (nil? s)))", "user": "5b14475be4b0cc2b61a3be5a"}, {"problem": 95, "code": "(fn tree?[root]\n  (or\n    (nil? root)\n    (and\n      (coll? root)\n      (= (count root) 3)\n      (tree? (second root))\n      (tree? (last root)))))", "user": "5c6227fee4b0fca0c1622641"}, {"problem": 95, "code": "(fn f [args]\n  (cond (and (sequential? args) (= 1 (count args))) (apply f args)\n        (nil? args) true\n        (not (sequential? args)) false\n        (not= 3 (count args)) false\n        :else (and (f (second args))\n                   (f (nth args 2)))))", "user": "5c62979fe4b0fca0c162264c"}, {"problem": 95, "code": "(fn [btree]\n  (letfn [(is-btree [node]\n                    (cond\n                     (and (coll? node) (= (count node) 3))\n                     (let [[a b c] node]\n                       (and true (is-btree b) (is-btree c)))\n                     \n                     (nil? node) true\n                     :else false))]\n    \n    (is-btree btree)))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 95, "code": "(fn tree? [s] (or (nil? s) (and (sequential? s) (= 3 (count s)) (tree? (second s)) (tree? (last s)))))", "user": "5c30d90de4b0d62ef62d9f22"}, {"problem": 95, "code": "(fn f [l] (and (= 3 (count l)) (not (coll? (first l))) (if (coll? (last l)) (f (last l)) (if (false? (last l)) false true)) (if (coll? (second l)) (f (second l)) (if (false? (second l)) false true))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 95, "code": "(fn istree [tree]\n  (if (sequential? tree)\n    (if (= 3 (count tree))\n        (and (istree (first (rest tree))) (istree (first (rest (rest tree)))))\n        false\n    )\n    (if (= nil tree)\n        true\n        false)\n  )\n)", "user": "5bfcdc52e4b0bdcf453d15f4"}, {"problem": 95, "code": "(fn b[x](if (sequential? x)\n          (if (= 3 (count x))\n            (and (b (second x)) (b (last x)))\n            false\n            )\n          (if (false? x) false true)))", "user": "58d1c1b1e4b03c36ff7e58ef"}, {"problem": 95, "code": "(fn is-binary-tree?\n  [lst]\n  (cond (not= 3 (count lst))\n        false\n\n        (coll? (second lst))\n        (is-binary-tree? (second lst))\n\n        (coll? (last lst))\n        (is-binary-tree? (last lst))\n\n        (or (not= (second lst) nil) (not= (last lst) nil))\n        false\n\n        :else true))", "user": "5c706232e4b0fca0c162277e"}, {"problem": 95, "code": "(fn [root-list] \n  (and \n   (= 3 (count root-list)) \n   (not-any? false? (flatten root-list))\n   (not (some #(and (coll? %) (empty? %)) root-list))))", "user": "5835a222e4b089d5ab817ce5"}, {"problem": 95, "code": "(fn tree?\n  [xs]\n  (or (nil? xs)\n      (and (coll? xs)\n           (= 3 (count xs))\n           (let [[value left right] xs]\n     \t     (and (tree? left) (tree? right))))))", "user": "576a972ce4b0a07e8fc1811a"}, {"problem": 95, "code": "(fn tree [t]\n  (cond \n   (not (= (count t) 3)) false\n   (and (coll? (second t)) (coll? (last t))) (and (tree (second t)) (tree (last t)))\n   (coll? (second t)) (tree (second t))\n   (coll? (last t)) (tree (last t))\n   (not (and (nil? (second t)) (nil? (second t)))) false\n   :else true))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 95, "code": "(fn check [x]\n  (if (coll? x)\n    (if (= 3 (count x))\n      (let [x1 (second x) x2 (last x)]\n        (and (check x1) (check x2)))\n      false)\n  (not (= false x))))", "user": "5a64dcabe4b0512ff01cd9a9"}, {"problem": 95, "code": "(fn valid-tree [node] (cond\n                        (nil? node) true\n                        (and (coll? node) (= 3 (count node))) (every? valid-tree (rest node))\n                        :else false))", "user": "5c7bc0a5e4b0fca0c1622865"}, {"problem": 95, "code": "(fn btree? [t]\n  (and (coll? t) (= (count t) 3)\n    (let [[_ l r] t]\n      (and (or (nil? l) (btree? l))\n           (or (nil? r) (btree? r))))))", "user": "5c6e1006e4b0fca0c1622744"}, {"problem": 95, "code": "(fn bintest [x]\n    (if (or (vector? x)(list? x))\n        (and  \n            (= 3 (count x))\n            (bintest (nth x 1))\n            (bintest (nth x 2))\n        )\n        (or(nil? x) (not (false? x)))\n    )\n)", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c746c31e4b0fca0c16227c8"}, {"problem": 95, "code": "(fn tree? [col]\n  (cond\n    (or (seq? col) (vector? col))\n      (and (= 3 (count col)) (tree? (nth col 1)) (tree? (nth col 2)))\n    (nil? col) true\n    :else false))", "user": "5c70641de4b0fca0c162277f"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= (count x) 3)\n           (every? tree? (rest x)))))", "user": "5b22d30ee4b08b1df1c36750"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c874389e4b048ec896c590e"}, {"problem": 95, "code": "(fn istree? [root]\n (or (nil? root) (and (sequential? root)(= 3 (count root)) (every? istree? (rest root))))\n  )", "user": "5c82db41e4b0c8042a70ce42"}, {"problem": 95, "code": "(fn is_tree [sq]\n  (cond\n    (nil? sq) true\n    (not (sequential? sq)) false\n    (< 3 (count sq)) false\n    (> 3 (count sq)) false\n    (and (is_tree (second sq)) (is_tree (nth sq 2))) true\n    :else false\n    ))", "user": "5c76577ae4b0fca0c16227ea"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c7d947be4b0d597f478cab6"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c7c8c72e4b0d597f478ca96"}, {"problem": 95, "code": "(fn tree?\n  [branches]\n  (cond\n    (or (seq? branches) (vector? branches))\n    (and (= 3 (count branches)) (tree? (nth branches 1)) (tree? (nth branches 2)))\n    (nil? branches) true\n    :else false))", "user": "5c7dad57e4b0d597f478caba"}, {"problem": 95, "code": "(fn treeOrNot [coll]\n  (cond\n    (or (seq? coll)\n        (vector? coll))\n      (and (= 3 (count coll))\n           (treeOrNot (nth coll 1))\n           (treeOrNot (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c787131e4b0fca0c1622825"}, {"problem": 95, "code": "(fn [x] (if (some false? (flatten x)) false (if (= 3 (count x)) (if (some false? (flatten ((fn prueba [n]\n                                     (map #(if (coll? %) (if (some coll? %) (prueba %) (= 3 (count %)))) n)) x))) false true) false)))", "user": "5c748bf5e4b0fca0c16227cb"}, {"problem": 95, "code": "(fn isBanaryTree [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (isBanaryTree (nth coll 1)) (isBanaryTree (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c74b043e4b0fca0c16227ce"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5c75a830e4b0fca0c16227e0"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5c8860bce4b048ec896c5928"}, {"problem": 95, "code": "(fn istree? \n  [x] \n  (or (nil? x) (and\n    (sequential? x)\n    (= 3 (count x))\n    (istree? (nth x 1))\n    (istree? (nth x 2)))))", "user": "5c7d5463e4b0d597f478caa9"}, {"problem": 95, "code": "(fn binary-tree?\n  [tree]\n  (or (nil? tree)\n      (and (coll? tree)\n           (= 3 (count tree))\n           (every? binary-tree? (rest tree)))))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n   (nil? t) true\n   (and (coll? t) (= 3 (count t))) (and (tree? (second t)) (tree? (second (rest t))))\n   :else false))", "user": "5c664b87e4b0fca0c16226a5"}, {"problem": 95, "code": "(fn btree [s]\n  (if (nil? s)\n    true\n    (do\n      (if (false? s)\n        false\n        (do\n      \t\t(if (or (not= (count s) 3) (false? s))\n        \tfalse\n        \t(and (btree (second s)) (btree (nth s 2)))))))))", "user": "5c558070e4b0fb8c5ffd9a1e"}, {"problem": 95, "code": "(fn treecheck[t]\n    (cond (nil? t) true\n          (not (sequential? t)) false\n          (not= (count t) 3) false\n          :else\n           (let [[v l r] t]\n             (and (treecheck l) (treecheck r)))\n           ))", "user": "57fc0719e4b0d3187e900987"}, {"problem": 95, "code": "(fn tree? [tree]\n    (if (= tree nil)\n    \ttrue\n    (if (or (seq? tree) (vector? tree))\n    (if (= (count tree) 3)\n        (if (and (tree? (second tree)) (tree? (last tree)))\n        true\n        false)\n        false)\n    false)))", "user": "5c86b769e4b0c8042a70ce9b"}, {"problem": 95, "code": "(fn tree? [coll]\n   (cond\n     (or (seq? coll) (vector? coll)) (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n     (nil? coll) true\n     :else false))", "user": "5b337ff4e4b025bcb146f339"}, {"problem": 95, "code": "(fn is-binary-tree?\n  [s]\n  (cond\n    (or (seq? s) (vector? s)) (and (= 3 (count s)) (is-binary-tree? (nth s 1)) (is-binary-tree? (nth s 2)))\n    (nil? s) true\n    :else false))", "user": "59b93cd7e4b0a024fb6ae3c7"}, {"problem": 95, "code": ";; http://www.4clojure.com/problem/95\n(fn binary-tree?\n  [coll]\n  (if (coll? coll)\n    (if (= (count coll) 3)\n      (let [value (first coll)\n            left (second coll)\n            right (nth coll 2)]\n        (cond\n          (coll? value) false\n          (not (binary-tree? left)) false\n          (not (binary-tree? right)) false\n          :else true))\n      false)\n    (nil? coll)))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 95, "code": "(fn isTree [t]\n  (or (nil? t)\n    (and (coll? t) (= (count t) 3) (every? isTree (rest t)))))", "user": "55ed37ebe4b0121d4835fdd6"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "59b9e669e4b0a024fb6ae3db"}, {"problem": 95, "code": "(fn binarytree? [s]\n    (or (= nil s) (and (sequential? s) (= (count s) 3) (binarytree? (nth s 1)) (binarytree? (nth s 2)))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 95, "code": "(fn tree? [tree]\n    (or (nil? tree)\n        (and\n         (sequential? tree)\n         (== 3 (count tree))\n         (tree? (second tree))\n         (tree? (last tree)))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 95, "code": "(fn istree [atree]\n  (or \n   (nil? atree) \n   (and (sequential? atree) (= 3 (count atree))\n    \t(not (nil? (first atree)))\n       \t(istree (second atree))\n        (istree (nth atree 2))\n   )\n))", "user": "5ca3695fe4b048ec896c5ba9"}, {"problem": 95, "code": "(fn tree? [x]\n  (apply = (cons true (cons (= 3 (count x))\n       (map #(if (coll? %) (tree? %) (not (false? %))) x)))))", "user": "5c7d5a0ce4b0d597f478caab"}, {"problem": 95, "code": "(fn tree? [xs]\n   (if (= 3 (count xs))\n     (every? identity (map #(cond\n                              (sequential? %) (tree? %)\n                              (nil? %) true\n                              :else false) (rest xs)))\n     false))", "user": "5c896f46e4b048ec896c5940"}, {"problem": 95, "code": "(fn is-tree [t]\n  (if (nil? t)\n    true\n    (if (or (list? t) (vector? t))\n  \t  (and (= (count t) 3) (is-tree (nth t 1)) (is-tree (nth t 2)))\n      false\n    )\n  )\n)", "user": "543bb568e4b032a45b869334"}, {"problem": 95, "code": "(fn istree [[x lchild rchild :as s]]\n  (and (= 3 (count s))\n\t   (not (coll? x))\n       (or (nil? lchild) (and (coll? lchild) (istree lchild)))\n       (or (nil? rchild) (and (coll? rchild) (istree rchild)))))", "user": "5cab33e7e4b048ec896c5c48"}, {"problem": 95, "code": "(fn is-b-tree [[v l r & rest :as coll]]\n  (cond\n    (not= (count coll) 3) false\n    (nil? v) (every? nil? [l r])\n    :else (and (or (nil? l) (and (coll? l) (is-b-tree l)))\n               (or (nil? r) (and (coll? r) (is-b-tree r))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 95, "code": "(fn tree? [[_ second third :as orig]]\n    (and\n      (= (count orig) 3)\n      (and (or (nil? second) (and (sequential? second) (tree? second)))\n           (or (nil? third) (and (sequential? third) (tree? third)))\n           )\n      )\n    )", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 95, "code": "(fn btree? [s]\n  (if (coll? s)\n    (let [[a b c :as s] s]\n      (and\n       (= 3 (count s))\n       (or (number? a) (symbol? a) (keyword? a) (string? a) (instance? Boolean a))\n       (or (nil? b) (and (btree? b)))\n       (or (nil? c) (and (btree? c)))))\n    false))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 95, "code": "(fn check-tree [maybe-tree]\n                       (or (nil? maybe-tree)\n                           (and (sequential? maybe-tree)\n                                (= (count maybe-tree) 3)\n                                (check-tree (second maybe-tree))\n                                (check-tree (nth maybe-tree 2)))))", "user": "57f904c5e4b0d3187e900936"}, {"problem": 95, "code": "(fn bin-tree? [node]\n  (cond (nil? node) true\n        (coll? node)\n          (let [[_ left right] node]\n          (and (= (count node) 3)\n               (bin-tree? left)\n               (bin-tree? right)))\n        :else false))", "user": "52393e16e4b0d705d026ef06"}, {"problem": 95, "code": "(fn f [[v n1 n2 :as coll]]\n  (and\n   (= 3 (count coll))\n   (not (coll? v))\n   (or (nil? n1) (and (coll? n1) (f n1)))\n   (or (nil? n2) (and (coll? n2) (f n2)))))", "user": "5afb3426e4b0cc2b61a3bcf5"}, {"problem": 95, "code": "(fn is-btree [t]\n  (cond (= t nil) true\n        (and (sequential? t)\n             (= 3 (count t))\n             (is-btree (nth t 1))\n             (is-btree (nth t 2))) true\n        :else false))", "user": "4fbe2cfbe4b081705acca30c"}, {"problem": 95, "code": "(fn is-binary-tree? [t]\n  (if (coll? t)\n    (if (not= (count t) 3)\n      false\n      (let [[v l r] t] (and (is-binary-tree? l) (is-binary-tree? r))))\n    (if (nil? t) true false)))", "user": "5c547cf0e4b0fb8c5ffd9a0b"}, {"problem": 95, "code": "(fn bt? [t] (cond\n  (nil? t) true\n  (not (sequential? t)) false\n  (= 3 (count t)) (and (bt? (second t)) (bt? (last t)))\n  :default false))", "user": "5ccf2dc3e4b0ccb0619628c2"}, {"problem": 95, "code": "(fn tree? [xs] (or (nil? xs) (and (sequential? xs) (= 3 (count xs)) (tree? (second xs)) (tree? (nth xs 2)))))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 95, "code": "(fn tree? [col]\n  (or (nil? col)\n      (and\n       (coll? col)\n       (= 3 (count col))\n       (tree? (first (rest col)))\n       (tree? (last col)))))", "user": "5766bab8e4b0a07e8fc180b1"}, {"problem": 95, "code": "(fn binary-tree?\n  [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (binary-tree? (second x))\n           (binary-tree? (last x)))))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 95, "code": "(fn is-tree? [coll]\n  (or (nil? coll) \n      (and (counted? coll)\n           (= (count coll) 3)\n           (is-tree? (nth coll 1))\n           (is-tree? (nth coll 2)))))", "user": "5713c575e4b07c98581c3aab"}, {"problem": 95, "code": "(fn bt[bts]\n  (let [rt (first bts)\n        rs (rest bts)\n        cnt (count rs)\n        lf (first rs)\n        rg (second rs)\n        valid? #(if (coll? %) (bt %) (nil? %))]\n    (if (not (nil? rt))\n      \t(and (= 2 cnt) (valid? lf) (valid? rg))\n    false)\n  )    \n)", "user": "5ce41d1be4b0a17bb84e2b50"}, {"problem": 95, "code": "(fn tree? [node]\n  (if (coll? node)\n    (if (= (count node) 3)\n      (and (tree? (nth node 1))\n           (tree? (nth node 2)))\n      false)\n    (nil? node)))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 95, "code": "(fn tree? [n]\n \t (or\n    (nil? n)\n    (and (sequential? n)\n      (cond\n        (not= 3 (count n)) false\n        :else (and \n          (tree? (nth n 1))\n          (tree? (nth n 2)))))))", "user": "4eb47bb1535d7eef30807362"}, {"problem": 95, "code": "(fn is-tree [s]\n   (and (sequential? s) (= 3 (count s)) (every? true? (map #(or (nil? %) (is-tree %)) (rest s))))\n   )", "user": "5ce2b15fe4b0a17bb84e2b2c"}, {"problem": 95, "code": "(fn ? [n]\n    (or (nil? n)\n        (and (coll? n)\n             (= 3 (count n))\n             (every? ? (rest n)))))", "user": "5ce52271e4b0a17bb84e2b69"}, {"problem": 95, "code": "(fn\n   [xs]\n   (every? (fn\n             [x]\n             (\n               and (= 3 (count x))\n                   (every? (fn [e] (or (nil? e) (and (sequential? e) ((complement empty?) e)))) (drop 1 x))\n                   ))\n           (filter sequential? (tree-seq sequential? seq xs))))", "user": "5ce62d8ee4b0a17bb84e2b83"}, {"problem": 95, "code": "(fn ck [s]\n  (cond \n   (and (not (coll? s)) (not (= nil s))) false\n   (and (= (count s) 3) (every? (partial = nil) (rest s))) true\n        (= (count s) 3) (and (ck (second s)) (ck (nth s 2)))\n        (= nil s) true\n        :else false))", "user": "592bb806e4b072a2710fcf46"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (or\n   (not (coll? tree))\n   (and\n    (= 3 (count tree))\n    (or\n     (nil? (second tree))\n     (and\n      (coll? (second tree))\n      (is-tree? (second tree))))\n    (or\n     (nil? (last tree))\n     (and\n      (coll? (last tree))\n      (is-tree? (last tree)))))))", "user": "51dd5d6fe4b0c33a4e1da406"}, {"problem": 95, "code": "(fn [coll]\n  (letfn [(binary? [s]\n            (and\n              (sequential? s)\n              (= (count s) 3)\n              (let [left (second s) right (last s)]\n                (and\n                  (or (nil? left) (binary? left))\n                  (or (nil? right) (binary? right))))))]\n    (binary? coll)))", "user": "5cdda90ce4b05ee0cb311766"}, {"problem": 95, "code": "(fn tree? [here]\n  (cond\n   (nil? here) true\n   (not (coll? here)) false\n   (not= 3 (count here)) false\n   :else (and (tree? (second here)) (tree? (-> here rest second)))\n    )\n  )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 95, "code": "(fn tree? [coll]\n    (cond\n     (or (seq? coll) (vector? coll))\n\n     (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n     (nil? coll) true\n     :else false))", "user": "5cee521ce4b0aaa82f1129dd"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (coll? coll)\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5ca1c45ae4b048ec896c5b85"}, {"problem": 95, "code": "(fn [t]\n  (every?\n     #(or (nil? %) (and (coll? %) (= (count %) 3)))\n     (tree-seq\n       (complement nil?)\n       #(if (coll? %) (rest %) '())\n       t)))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 95, "code": "(fn binary-tree?\n  [coll]\n  (and (= 3 (count coll))\n       (let [item1 (nth coll 1)\n             item2 (nth coll 2)]\n         (and\n           (if (sequential? item1) (binary-tree? item1) (nil? item1))\n           (if (sequential? item2) (binary-tree? item2) (nil? item2))))))", "user": "5b5e7953e4b0c6492753e6d9"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n   (or (seq? coll) (vector? coll))\n   (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n   (nil? coll) true\n   :else false\n   ))", "user": "5cd4e1b2e4b0ccb061962927"}, {"problem": 95, "code": "(fn tree-validator [col]\n  (do\n    (println \"Calling with\" col)\n    (if (or (not (= (count col) 3)) (some #(= false %) col))\n      (do\n        (println \"Does not have three or contains false\")\n        false)\n      (do\n        (println \"Checking sub-cols\")\n        (let [seq-list (filter sequential? col)]\n          (not (contains? (set (map tree-validator seq-list)) false)))))))", "user": "5d0859fbe4b0cc9c91588208"}, {"problem": 95, "code": "(fn tree?\n  [[_ left right :as all]]\n  (let [truthy? (fn [x] (if x true false))]\n    (truthy? (and\n               (= 3 (count all))\n               (or (nil? left)\n                   (and\n                     (or (vector? left) (list? left) (seq? left))\n                     (tree? left)))\n               (or (nil? right)\n                   (and\n                     (or (vector? right) (list? right) (seq? right))\n                     (tree? right)))))))", "user": "5d110abee4b02c15ef021983"}, {"problem": 95, "code": "(fn p [t]\n  (or (nil? t)\n      (and t\n           (= (count t) 3)\n           (and (p (nth t 1)) (p (nth t 2))))))", "user": "5357b241e4b04ce2eb3ed282"}, {"problem": 95, "code": "(fn [[parent & children]]\n        (cond\n         (seq? parent) false\n         (not (= (count children) 2)) false\n         (sequential? (first children)) (recur (first children))\n         (not (nil? (first children))) false\n         (sequential? (second children)) (recur (second children))\n         (not (nil? (second children))) false\n         :else true))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 95, "code": "(fn isbtree [t]\n        (cond\n          (nil? t) true\n          (not (coll? t)) false\n          (= 3 (count t)) (and (not (nil? (first t))) (isbtree (second t)) (isbtree (last t)))\n          true false))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 95, "code": "(fn bt? [t]\n  (and (= (count t) 3)\n       (or (nil? (nth t 1))\n           (and (coll? (nth t 1)) (bt? (nth t 1))))\n       (or (nil? (nth t 2))\n           (and (coll? (nth t 2)) (bt? (nth t 2))))))", "user": "5012da69e4b0c8732600222d"}, {"problem": 95, "code": "(fn tree? [t]\n  (let [valid-leaves? (fn [leaves]\n                        (and (every? #(or (coll? %) (nil? %)) leaves)\n                             (= (count leaves) 2)))\n        invalid-leaves? (complement valid-leaves?)]\n\n    (let [[value & leaves] t]\n      (cond\n        (or (nil? value) (invalid-leaves? leaves)) false\n        (every? nil? leaves) true\n        :else (every? true? (map tree? (filter coll? leaves)))))))", "user": "563f4c47e4b08d4f616f5ed2"}, {"problem": 95, "code": "(fn tree?\n  [node]\n  (if node\n    (let [[_ left right] node]\n      (if (= 3 (count node))\n        (and (tree? left) (tree? right))\n        false))\n    (nil? node)))", "user": "570c8ac3e4b0b0fb43fd06ca"}, {"problem": 95, "code": "(fn bin-tree? [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (bin-tree? (nth x 1))\n           (bin-tree? (nth x 2)))))", "user": "559622cee4b0c79f6e1db975"}, {"problem": 95, "code": "(fn isTree [node]\n\t(or (nil? node)\n\t\t(and\n\t\t\t(sequential? node)\n\t\t\t(= (count node) 3)\n\t\t\t(every? isTree (rest node))\n\t\t)\n\t)\n)", "user": "5d2201b8e4b02ea6f0fb69ed"}, {"problem": 95, "code": "(fn is-tree-node? [node]\n  (cond\n    (nil? node) true\n    (not (coll? node)) false\n    :else\n    (let [[v l r] node]\n      (and (boolean v)\n           (= (count node) 3)\n           (is-tree-node? l)\n           (is-tree-node? r)))))", "user": "5d272077e4b092dab7f59c64"}, {"problem": 95, "code": "(fn tree?\n  [coll]\n  (cond\n    (nil? coll) true\n    (and (not (nil? coll)) (not (coll? coll))) false\n    (and (coll? coll) (empty? coll)) false\n    (and (coll? coll) (not= (count coll) 3)) false\n    :else (and (tree? (second coll)) (tree? (last coll)))))", "user": "5d1c14cde4b02ea6f0fb698a"}, {"problem": 95, "code": "(fn bin-tree? [col]\n  (if (nil? col)\n    true\n    (if (or (seq? col)\n            (vector? col))\n      (and (= 3 (count col))\n           (bin-tree? (second col))\n           (bin-tree? (nth col 2)))\n      false)))", "user": "5d231255e4b02ea6f0fb69fe"}, {"problem": 95, "code": "(fn foo [treenode]\n      (if (nil? treenode)\n      true\n      (and (sequential? treenode) (= (count treenode) 3) (foo (second treenode)) (foo (nth treenode 2)))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 95, "code": "(fn [tree] (every? #(or (nil? %) (and (coll? %) (= 3 (count %))) ) (tree-seq coll? rest tree)))", "user": "5abeb697e4b073f177442725"}, {"problem": 95, "code": "(fn f [v] (or (nil? v)\n              (and (sequential? v)\n                   (= 3 (count v))\n                   (f (second v))\n                   (f (nth v 2)))))", "user": "547584d9e4b0c51c1f4d729b"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (or (nil? coll)\n      (and (sequential? coll)\n           (= (count coll) 3)\n           (every? binary-tree? (rest coll)))))", "user": "5d2bfb68e4b01671435dbc86"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n    (and (sequential? root)\n         (= 3 (count root))\n         (every? tree? (rest root)))))", "user": "5182de5ce4b0353c468deb74"}, {"problem": 95, "code": "(fn is-tree [tree]\n    (if (nil? tree)\n      true\n      (if-not (sequential? tree)\n        false\n        (if-not (= 3 (count tree))\n          false\n          (and (is-tree (second tree)) (is-tree (nth tree 2)))))))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 95, "code": "(fn istree? [root]\n (or (nil? root)\n  (and (coll? root)\n   (= 3 (count root))\n   (every? istree? (rest root)))))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= (count root) 3)\n           (every? tree? (rest root)))))", "user": "5ccf99fbe4b0ccb0619628c8"}, {"problem": 95, "code": "(fn tree? [col]\n  (let [[v left right :as tr]\n        col]\n    (if (not (= 3 (count tr)))\n      false\n      (cond\n       (and (nil? left) (nil? right)) true\n       (and (not (sequential? left)) (not (sequential? right))) false\n       (nil? left) (tree? right)\n       (nil? right) (tree? left)\n      :else (and (tree? left) (tree? right)))\n    ))\n)", "user": "5d321852e4b01671435dbce8"}, {"problem": 95, "code": "(fn binary-tree?\n  [a](cond (coll? a)\n        (and (= 3 (count a)) (binary-tree? (nth a 1)) (binary-tree? (nth a 2)))\n        (nil? a) true\n        :else false))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 95, "code": "(fn tree? [coll] (\n                  \n                  if (or (seq? coll) (vector? coll)) \n                   (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n                  \t( if(nil? coll) \n                      true\n                      false\n                      ) \n                  \n                  )\n  )", "user": "5cf53196e4b087f62be35a94"}, {"problem": 95, "code": "(fn tree? [s]\n  (or (nil? s)\n      (and (sequential? s)\n           (= 3 (count s))\n           (tree? (second s))     ;; left\n           (tree? (last s)))))    ;; right", "user": "57262710e4b0c5bde472c120"}, {"problem": 95, "code": "(fn is-binary [arr]\n  (if-not (sequential? arr)\n    (nil? arr)\n    (and (= (count arr) 3)\n         (is-binary (nth arr 1))\n         (is-binary (nth arr 2)))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 95, "code": "(fn binary? [tree]\n  (let [[root left-child right-child] tree]\n    (and (and (not (coll? root))\n              (not (false? root)))\n         (= (count tree) 3)\n         (cond (coll? left-child) (binary? left-child)\n               :else (not (false? left-child)))\n         (cond (coll? right-child) (binary? right-child)\n               :else (not (false? right-child))))))", "user": "5d48e6d3e4b0776584bd6f15"}, {"problem": 95, "code": "(fn IsTree [L]\n    (cond\n      ;; \u0432\u0441\u0435 \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e, \u0435\u0441\u043b\u0438 nil\n      (nil? L) true\n      ;; \u0434.\u0431. \u0441\u043f\u0438\u0441\u043a\u043e\u043c\n      (not (sequential? L)) false\n      ;; \u0434.\u0431. \u0442\u0440\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n      (not= 3(count (concat nil L))) false\n      ;; \u043b\u0435\u0432\u044b\u0439 \u0438 \u043f\u0440\u0430\u0432\u044b\u0439 \u0442\u043e\u0436\u0435 \u0434.\u0431. \u0434\u0435\u0440\u0435\u0432\u044c\u044f\u043c\u0438\n      :else  (and (IsTree (second L)) (IsTree (last L)) )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 95, "code": "(fn tree? [coll]\n        (cond\n          (or (seq? coll) (vector? coll))\n          (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n          (nil? coll) true\n          :else false))", "user": "559ba500e4b066d22e731f58"}, {"problem": 95, "code": "(fn is-binary-tree? [s]\n  (cond\n    (nil? s) true\n    (not (sequential? s)) false\n    (not (= (count s) 3)) false\n    (sequential? (first s)) false\n    :else (every? is-binary-tree? (rest s))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 95, "code": "(fn is-binary-tree?\n  [tree]\n  (cond \n    (nil? tree) true\n    (and (sequential? tree) (= 3 (count tree))) \n    (every? is-binary-tree? (rest tree))\n    :else false))", "user": "5b62ff3ce4b0c6492753e72a"}, {"problem": 95, "code": "(fn t? [t]\n   (or (nil? t)       \n       (and (counted? t)\n            (= (count t) 3)\n            (t? (nth t 1))\n            (t? (nth t 2)))))", "user": "5bb25684e4b0a20761a2350d"}, {"problem": 95, "code": "(fn tree? [x]\n   (cond\n     (nil? x) true\n     (and (coll? x) (= (count x) 3))\n     (let [[val left right] x]\n       (and (not (coll? val)) (tree? left) (tree? right)))\n     :else false\n     ))", "user": "5ab07d63e4b073f1774425af"}, {"problem": 95, "code": "(fn tree?\n  [tree]\n  (if (coll? tree)\n    (case (count tree)\n      ;;0 true \n      3 (let [ [root left right] tree ]\n          (and (tree? left) (tree? right)))\n      false)\n    (if (nil? tree)\n      true\n      false)))", "user": "5d48884ee4b07c84aa5ae6bb"}, {"problem": 95, "code": "(fn istree [data]\n  (if (not (sequential? data)) \n    (nil? data) \n    (if (not= (count data) 3) \n      false\n      (and (istree (second data)) (istree (last data))))))", "user": "5d4f21f3e4b0776584bd6f4e"}, {"problem": 95, "code": "(fn is-binary-tree? [x]\n  (letfn [(is-tree-level [x]\n            (and\n             (= (count x) 3)\n             (not (coll? (nth x 0)))\n             (and\n              (or (nil? (nth x 1)) (coll? (nth x 1)))\n              (if (coll? (nth x 1))\n                (is-tree-level (nth x 1))\n                true))\n\n             (and\n              (or (nil? (nth x 2)) (coll? (nth x 2)))\n              (if (coll? (nth x 2))\n                (is-tree-level (nth x 2))\n                true))))]\n    (is-tree-level x)))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 95, "code": "(fn btree? \n  [[v l r :as s]] (and \n    (= (count s) 3) \n    (or \n      (nil? l) \n      (and (sequential? l) (btree? l))) \n    (or \n      (nil? r) \n      (and (sequential? r) (btree? r)))))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 95, "code": "(fn mytree? [coll]\n  (if (nil? coll) true\n      (and (coll? coll)\n           (= (count coll) 3)\n           (mytree? (nth coll 1))\n           (mytree? (nth coll 2)))))", "user": "5146f343e4b04ef915e3731e"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 95, "code": "(fn is-tree? [coll]\n  (cond\n    (nil? coll) true\n    (not (coll? coll)) false\n    :else\n    (and (= 3 (count coll))\n         (is-tree? (second coll))\n         (is-tree? (last coll)))))", "user": "5d24e49be4b02ea6f0fb6a2a"}, {"problem": 95, "code": "(fn f [val]\n  (if (false? val) val\n      (or\n       (and (not (coll? val)))\n       (and\n        (= (count val) 3)\n        (every? identity (map f val))))))", "user": "5d672bd7e4b0db5d338d15f1"}, {"problem": 95, "code": "(fn bt?\n  [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= 3 (count x))\n           (first x)\n           (bt? (nth x 1))\n           (bt? (nth x 2)))))", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 95, "code": "(fn is-tree? [s]\n  (if (= s nil)\n    true\n    (if (and (coll? s) (= 3 (count s)))\n      (and (is-tree? (nth s 1)) (is-tree? (nth s 2)))\n      false\n      )))", "user": "5d6691cee4b0db5d338d15e9"}, {"problem": 95, "code": "(fn tree? [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= 3 (count tree))\n           (every? tree? (rest tree)))))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 95, "code": "(fn btree? [c]\n   (or (= c nil)\n       (and (coll? c) (= (count c) 3) (btree? (second c)) (btree? (nth c 2)))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 95, "code": "(fn [tree]\n          (->> tree\n               (tree-seq coll? (partial filter coll?))\n               (map (partial filter (comp not false?)))\n               (every? (comp (partial = 3) count))))", "user": "54da46e5e4b024c67c0cf753"}, {"problem": 95, "code": "(fn bt? [n]\n  (if (not= 3 (count n))\n    false\n    (every?\n      #(identity %)\n      (for [i n]\n        (if (contains?\n              #{java.lang.Long java.lang.String clojure.lang.Keyword nil}\n              (type i))\n          true\n          (if (coll? i)\n            (bt? i)))))))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 95, "code": "(fn bin-tree? [tree] (cond\n                      (not (or (nil? tree) (and (coll? tree) (= (count tree) 3)))) false\n                      (nil? tree) true\n                      :else (and (bin-tree? (get (vec tree) 1)) (bin-tree? (get (vec tree) 2)))\n                      )\n  )", "user": "5d6d2172e4b04d129b00f2b9"}, {"problem": 95, "code": "(fn tree? [coll] (letfn [(node? [e] (cond\n                                        (nil? e) true\n                                        (number? e) true\n                                        (sequential? e) (tree? e)\n                                        :else false))\n                           (check [[n l r]] (if n\n                                              (and (node? l) (node? r))\n                                              false))]\n                     (if (= 3 (count coll))\n                         (check coll)\n                         false)))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 95, "code": "(fn tree [sequ]\n(if (nil? sequ)\n    true\n    (if (not (coll? sequ))\n      false\n      (if (= (count sequ) 3)\n        (do\n          (let [x (tree (second sequ))\n                y (tree (last sequ))]\n            (and x y)))\n        false))))", "user": "5be0b916e4b0ed4b8aab4c8f"}, {"problem": 95, "code": "(fn f [t]\n  (or (nil? t)\n      (and (sequential? t)\n\t       (= 3 (count t))\n           (f (second t))\n           (f (last t)))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 95, "code": "(fn t? [coll]\n  (if (coll? coll)\n    (if (= 3 (count coll))\n      (and (not (coll? (first coll)))\n           (t? (second coll))\n           (t? (second (rest coll))))\n      false)\n    (nil? coll)))", "user": "5cbd5b42e4b026601754b9f6"}, {"problem": 95, "code": "(fn tree? [r]\n  (or (nil? r)\n      (and\n       (sequential? r)\n       (= 3 (count r))\n       (every? tree? (rest r)))))", "user": "5c51c930e4b0fb8c5ffd99ce"}, {"problem": 95, "code": "(fn tree? [coll] (if (= 3 (count coll))\n          (every? #(if (coll? %)\n                   (and (= (count %) 3) (tree? %))\n                   (if (false? %)\n                     false\n                     true)) coll)\n          false))", "user": "5b4c2212e4b02d533a91bca6"}, {"problem": 95, "code": "(fn treee? [t] \n   (or (nil? t)\n       (and \n            (coll? t) (= (count t) 3)\n            (every? treee? (rest t)))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 95, "code": "(fn bin-tree? [xs]\n   (if (not= (count xs) 3) false\n       (let [[n l r] xs]\n         (cond\n           (and (nil? l) (nil? r)) true\n           (nil? l) (and (coll? r) (bin-tree? r))\n           (nil? r) (and (coll? l) (bin-tree? l))\n           :else\n           (and (bin-tree? l)\n                (bin-tree? r))))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 95, "code": "(fn f [s]\n  (let [x (first s)]\n    (and (= 3 (count s))\n         (and (not (nil? x)) (not (sequential? x)))\n         (every? #(or (= nil %) (and (sequential? %) (f %))) (rest s)))))", "user": "5d917ef0e4b0915913b1d402"}, {"problem": 95, "code": "(fn is-node [tree-head]\n  (or (nil? tree-head) \n      (and (coll? tree-head) \n           (= 3 (count tree-head)) \n           (first tree-head) \n           (every? is-node (rest tree-head)))))", "user": "5cc80598e4b0ccb061962840"}, {"problem": 95, "code": "(fn [xs] (->> xs\n      \t\t  (tree-seq sequential? identity)\n      \t\t  (filter sequential?)\n              (every? #(= (count (filter (complement false?) %)) 3))))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5d88d820e4b0915913b1d3b1"}, {"problem": 95, "code": "(fn tree [col]\n      (cond \n        (= col nil) true\n        (not (coll? col)) false\n        (= 3 (count col)) (and (tree (second col)) (tree (last col)))\n        :else false))", "user": "5d887d27e4b0915913b1d3a8"}, {"problem": 95, "code": "(fn tree? [coll]\n  (prn coll)\n  (cond\n    (nil? coll) true\n    (not (coll? coll)) false\n    (not= (count coll) 3) false\n    (seq? (first coll)) false\n    (and (tree? (second coll)) (tree? (nth coll 2))) true\n    :else false\n    ))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 95, "code": ";(fn tree? [[n & children :as node]] (and (= 3 (count node))  (every? (fn [c] (if (coll? c) (tree? c) (nil? c))) children) ) )\n(fn [t] (->> t (tree-seq coll? rest) (every? (fn [n] (if(coll? n) (= (count n) 3) (nil? n) ) ))))", "user": "5d9e7971e4b000c986472bc1"}, {"problem": 95, "code": "(fn f [s]\n  (or\n    (nil? s)\n    (and\n       (not(= true  s))\n       (not(= false s))\n       (= (count s) 3)\n       (f (nth s 1))\n       (f (nth s 2))\n   )\n   )\n  )", "user": "5ce867fce4b0a17bb84e2baf"}, {"problem": 95, "code": "(fn is-tree  [[node left right & args :as all]]\n  (or (nil? node)\n      (and (empty? args)\n           (= 3 (count all))\n           (or (nil? left) (and (coll? left) (if (empty? left) false true) (is-tree left)))\n           (or (nil? right) (and (coll? right) (if (empty? right) false true) (is-tree right))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 95, "code": ";copiei\n(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5d0beecee4b0cc9c91588239"}, {"problem": 95, "code": "(fn b-tree? [b] \n  (if (nil? b) true\n    (and (sequential? b) (= 3 (count b)) (first b)  (b-tree? (second b)) (b-tree? (nth b 2)))))", "user": "5d931a58e4b0d3f9b434ad10"}, {"problem": 95, "code": "(fn valid?\n  [tree]\n  (if (nil? tree)\n    true\n    (and (coll? tree)\n         (= (count tree) 3) \n         (valid? (second tree))\n         (valid? (last tree)))))", "user": "5dadd84ee4b0f8c104ccfc85"}, {"problem": 95, "code": "(fn isBalanced [l]\n            (if (= (count l) 3)\n              (every? #(or (nil? %) (and (sequential? %) (isBalanced %))) (rest l))\n              false)\n            )", "user": "5d974b1de4b0d3f9b434ad36"}, {"problem": 95, "code": "(fn t [c]\n  (let [subt (fn [x] (or (nil? x)\n                       (t x))\n             )]\n    (and (sequential? c) \n         (= (count c) 3 )\n         (and (subt (second c))\n              (subt (last c)))\n         )\n    )\n  )", "user": "5db17e0be4b010eb3c36cd03"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 95, "code": "(fn fun [coll]\n  (cond\n    (not (coll? coll)) (nil? coll)\n    (not= (count coll) 3) false\n    :else (every? fun (rest coll))\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 95, "code": "(fn tree? [& args]\n  (let [[x] args]\n    (cond\n     (not (coll? x)) false\n     (not= (count x) 3) false\n     :else (and (not (coll? (nth x 0 false)))\n                (or (nil? (nth x 1 false)) (tree? (nth x 1 false)))\n                (or (nil? (nth x 2 false)) (tree? (nth x 2 false)))))))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 95, "code": "(fn check-tree [v]\n  (or \n    (nil? v)\n    (and\n     (sequential? v)\n     (= 3 (count v))\n     (check-tree (second v))\n     (check-tree (nth v 2)))))", "user": "5da975b9e4b000c986472c32"}, {"problem": 95, "code": "(fn f [s]\n  (let [x (first s)]\n    (and (= 3 (count s))\n         (and (not (nil? x)) (not (sequential? x)))\n         (every? #(or (= nil %) (and (sequential? %) (f %))) (rest s)))))", "user": "5db6f832e4b010eb3c36cd3d"}, {"problem": 95, "code": "(fn valid-tree? [tree]\n  (if (sequential? tree)\n    (if (= (count tree) 3)\n      (let [[top left right] tree]\n        (and (valid-tree? left) (valid-tree? right)))\n      false)\n    (if (nil? tree)\n      true\n      false)))", "user": "5d49ec5ee4b0776584bd6f1c"}, {"problem": 95, "code": "(fn tree?\n  ([] false)\n  ([t] \n   (if (and (coll? t) (= (count t) 3))\n     (let [[v l r] t]\n       (and (or (nil? l) (tree? l)) (or (nil? r) (tree? r)))) \n     false))\n  ([a b & rest] false))", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 95, "code": "(fn tree? [s]\n  (if (sequential? s)\n    (and (= 3 (count s)) (every? tree? (rest s)))\n    (nil? s)))", "user": "5d5166d9e4b0776584bd6f5e"}, {"problem": 95, "code": "(fn abc [x]\n  (letfn [(pick [y]\n            (cond\n               (= false y) false\n               (not (coll? y)) true\n               (not= 3 (count y)) (do (println \"_o_ \" (count y )) false)\n               :else (and (pick (second y)) (pick (second (rest y))))))               \n           ]\n   (cond\n      (not (coll? x)) false\n      :else (pick x))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 95, "code": "(fn binary-tree-tester [x]\n  (let [ts (tree-seq sequential? seq x)\n        nodes (filter sequential? ts)\n        leaves (filter #(not (sequential? %)) ts)\n        ;; pull out the branch nodes and count the number of children\n        pairs (reduce (fn [v h] (and v (= (count (rest h)) 2))) true nodes)]\n  ;; also make sure that all the children are actually present\n  (and pairs (every? identity (filter #(not (nil? %)) leaves)))))", "user": "5d64ecb2e4b0c9e5857d5036"}, {"problem": 95, "code": "(fn[item]\n  (let [result\n        ((fn ll [it]\n           (if (sequential? it)\n             (cond\n               (not= 2 (count (rest it))) false\n               :default (map #(ll %) (rest it)))\n             (if (nil? it)\n               true false)))\n         item)]\n    (if (or (= false result)\n            (not-every? true? (flatten result)))\n      false\n      true)))", "user": "5dab11cde4b000c986472c45"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (not (coll? s))\n    (nil? s)\n    (if (not= (count s) 3)\n      false\n      (and\n        (not (nil? (first s)))\n        (is-tree (second s))\n        (is-tree (last s))))))", "user": "5dc72a9ce4b02f9375f4e1cd"}, {"problem": 95, "code": "(fn bt? [form]\n  (or (nil? form)\n      (and (sequential? form)\n           (= 3 (count form))\n           (bt? (second form))\n           (bt? (nth form 2)))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 95, "code": "(fn f [t]\n  (cond (nil? t) true\n        (and (coll? t) (= (count t) 3)) (let [[v a b] t] (and (f a) (f b)))\n        :else false))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 95, "code": "(fn x [s]\n  (if (sequential? s)\n    (if (= 3 (count s))\n      (and (x (second s))\n           (x (last s)))\n      false)\n    (if (nil? s)\n      true\n      false)))", "user": "5dcc0ee9e4b02b31cc3da3c2"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (sequential? t)\n           (= 3 (count t))\n           (tree? (second t))\n           (tree? (last t)))))", "user": "5db5d09be4b010eb3c36cd31"}, {"problem": 95, "code": "(fn [x] \n  (let [btree? \n        (fn [tree] \n          (and (= 3 (count tree)) \n               (every? #(or (nil? %) \n                            (coll? %)) \n                       (rest tree))))] \n    (->> x \n         (tree-seq coll? seq) \n         (filter coll?) \n         (every? btree?))))", "user": "5da8fa72e4b000c986472c2d"}, {"problem": 95, "code": "(fn f [coll]\n  (if (coll? coll)\n    (let [[_ l r] coll]\n      (and (= 3 (count coll)) (f l) (f r)))\n    (if (nil? coll)\n      true\n      coll)))", "user": "524a9556e4b05ef8e38e64b1"}, {"problem": 95, "code": "(fn binary_tree? [tree]\n    (if (sequential? tree)\n        (if (= (count tree) 3)\n            (and (binary_tree? (nth tree 1)) (binary_tree? (nth tree 2)))\n            false\n        )\n        (= tree nil)\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "59b1a1b2e4b0e1f4e384c8eb"}, {"problem": 95, "code": "(fn f [x]\n  (or (nil? x)\n      (and (sequential? x) (= 3 (count x)) (f (second x)) (f (last x)))))", "user": "5dc98501e4b02f9375f4e1e6"}, {"problem": 95, "code": "(fn wut [x]\n  (cond\n    (nil? x) true\n    (false? x) false\n    (not (coll? x)) false\n    :else (let [[n & cs] x]\n            (cond\n              (not= 2 (count cs)) false\n              (some false? cs) false\n              :else (and (wut (first cs)) (wut (second cs)))))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 95, "code": "(fn bt [x] (if (and (coll? x) (= 3 (count x)))    (and  (or (nil?  (second x) )   (bt (second x))  )    (or (nil?  (last x) )   (bt (last  x))  )   )false       ))", "user": "5dd69c8ce4b0948ae9d9ad83"}, {"problem": 95, "code": "(fn is-bin-tree [tree]\n  (if (= tree nil)\n    true\n    (if (or (not (coll? tree)) (not (= (count tree) 3)))\n      false\n      (let [[node left right] tree\n            node-valid (and (not (= nil node)) (not (coll? node)))]\n        (and node-valid (is-bin-tree left) (is-bin-tree right))))))", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 95, "code": "(fn check [x]\n  (if (coll? x) \n    (if (= (count x) 3) \n      (and (check (nth x 1)) (check (nth x 2)))\n      false)\n    (if (nil? x) true false)))", "user": "5da306a3e4b000c986472be7"}, {"problem": 95, "code": "#(odd? (count (filter (complement false?) (flatten %))))", "user": "4edd038c535d10e5ff6f5327"}, {"problem": 95, "code": "(fn istree? [tree]\n  (cond\n   (nil? tree) true\n   (not (coll? tree)) false\n   :else (let [[n l r] tree]\n           (and\n            (= 3 (count tree))\n            (istree? l)\n            (istree? r)))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 95, "code": "(fn my-tree [tree]\n  (cond (coll? tree) (if-not (= (count tree) 3)\n                       false\n                       (let [[_ l r] tree]\n                         (and (my-tree l) (my-tree r))))\n        :else (not (false? tree))))", "user": "5ddb6151e4b0948ae9d9adb0"}, {"problem": 95, "code": "(fn [tree]\n  (reduce\n   #(and %1 %2) true\n   (flatten\n    ((fn tree? [x]\n       (concat \n        (vector (and (= (count x) 3) (not (nil? (first x)))))\n        (map (fn[y] (or (nil? y) (if (coll? y)\n                                   (tree? y)\n                                   false))) (rest x)))) tree))))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 95, "code": "(fn btree? [x]\n  (if (nil? x) true (and  (sequential? x) (= 3 (count x)) (btree? (nth x 1)) (btree? (nth x 2)))))", "user": "5793931ee4b0e215f87e845c"}, {"problem": 95, "code": "(fn is-bin [t]\n  (or \n    (nil? t)\n    (and \n      (sequential? t) \n      (= (count t) 3)\n      (every? is-bin (rest t)))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 95, "code": "(fn is-tree? [tree]\n(let [value (first tree)\n        left-child (second tree)\n        right-child (first (nnext tree))]\n    (if (and (= (count tree) 3)\n             (not (coll? value))\n             (or (nil? left-child) (coll? left-child))\n             (or (nil? right-child) (coll? right-child)))\n      (and (if (nil? left-child) true (is-tree? left-child))\n           (if (nil? right-child) true (is-tree? right-child)))\n      ;else\n      false))\n)", "user": "5d07989ee4b0cc9c915881fb"}, {"problem": 95, "code": "(fn tree? [s]\n  (and\n   \t(coll? s)\n    (= 3 (count s))\n    (or (nil? ((vec s) 1)) (tree? ((vec s) 1)))\n    (or (nil? ((vec s) 2)) (tree? ((vec s) 2)))))", "user": "5dc9ccf8e4b02f9375f4e1f1"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n   (nil? t) true\n   (and (coll? t) (= (count t) 3)) (and (tree? (second t)) (tree? (nth t 2)))\n   :else false))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5ddfd88be4b0948ae9d9ade1"}, {"problem": 95, "code": "(fn bt [x] \n  (cond (nil? x) true \n        (not (coll? x)) false \n        :else (let [[a b c] x] (and (= 3 (count x)) (bt b) (bt c)))))", "user": "58273e82e4b051871117bf1b"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5dfb20b8e4b0a607a9a45cd3"}, {"problem": 95, "code": "(fn is-bst? [tree]\n  (cond\n    (nil? tree) true\n    (false? tree) false\n    :else (let [[value left right & others] tree\n                should-be-three (= 3 (count tree))\n                is-head-ok? (not (nil? value))\n                are-there-others? (nil? others)]\n            (and is-head-ok? should-be-three are-there-others? (is-bst? left) (is-bst? right)))))", "user": "5d80f328e4b0915913b1d372"}, {"problem": 95, "code": "(fn tree? [[tnode & others]] \n  (let [validate (fn [sequ]\n                   (if(not (= (count others) 2))\n                       false\n                     (let [[left right] others\n                           validate-item (fn [item]\n                                           (if(nil? item)\n                                             true\n                                               (if(and (not (vector? item))(not (list? item)))\n                                                 false\n\t                                               (if(not(empty? item))\n\t                                                 true\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t                       false))))\n                           leftok (validate-item left)\n                           rightok (validate-item right)]\n                       (and leftok rightok))))\n                    ]\n\t  (if(not (nil? tnode) )\n\t    (if (not (validate others))\n\t      false\n\t      (let [[left right] others\n\t            l (tree? left)\n\t            r (tree? right)]\n\t        (and l r)))\n\t    true)))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 95, "code": "(fn tree?\n  [c]\n  (if (and (sequential? c) (= 3 (count c)))\n    (let [[n [:as l] [:as r]] c]\n      (println (str \"c \" c \" n \" n \" l \" l \" r \" r))\n      (if (and (not (nil? n)) (or (nil? l) (tree? l)) (or (nil? r) (tree? r))) true false)\n      )\n    false)\n  )", "user": "5dfe3928e4b0a607a9a45d04"}, {"problem": 95, "code": "(fn tree? [coll]\n   (cond\n     (or (vector? coll) (seq? coll))(and (= 3 (count coll)) (tree? (second coll)) (tree? (last coll))) \n     (= nil coll) true\n     :else false))", "user": "5dfa1c67e4b0a607a9a45cc5"}, {"problem": 95, "code": "(fn tree-check [xs]\n  (if (coll? xs) (and \n                 (= (count xs) 3)\n                 (not (nil? (first xs)))\n                 (tree-check (second xs)) \n                 (tree-check (last xs)))\n    (not (false? xs))))", "user": "5d84545ee4b0915913b1d38b"}, {"problem": 95, "code": "(fn p-95 [t]\n  (cond (nil? t) true\n        (not (sequential? t)) false\n        (not (= 3 (count t))) false\n        (sequential? (first t)) false\n        :else (and (p-95 (nth t 1))  (p-95 (nth t 2)))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (nil? coll) true\n    (and (sequential? coll)\n      ((complement sequential?) (first coll))\n      (= (count coll) 3)\n      (tree? (second coll))\n      (tree? (nth coll 2))) true\n    :else false))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 95, "code": "(fn treenode? [node] \n\t(or (= nil node)\n        (and\n         (sequential? node) \n         (= 3 (count node))\n         (every? treenode? (rest node)))))", "user": "5ddd6cfae4b0948ae9d9adc4"}, {"problem": 95, "code": "(fn tree? [node]\n  (cond (nil? node)           true\n        (not (coll? node))    false\n        (not= 3 (count node)) false\n        :else\n          (let [[value left right] node\n                some? (comp not nil?)]\n            (and (some? value) (tree? left) (tree? right)))))", "user": "5e0e14bde4b099d064962fa3"}, {"problem": 95, "code": "(fn tree? [coll]\n    (if (coll? coll)\n      (if (= (count coll) 3)\n        (let [value (nth coll 0)\n              left (nth coll 1)\n              right (nth coll 2)]\n          (println value \"l\" left \"r\" right)\n          (cond\n            (coll? value) false\n            (and (tree? left) (tree? right)) true\n            :else false\n          ))\n        false)\n      (= coll nil)))", "user": "5df75fd8e4b0a607a9a45c92"}, {"problem": 95, "code": "(fn tree?\n  [coll]\n  (and (= 3 (count coll))\n       (if (coll? (second coll))\n         (tree? (second coll))\n         (nil? (second coll)))\n       (if (coll? (last coll))\n         (tree? (last coll))\n         (nil? (last coll)))))", "user": "5e207f12e4b05b4b01516112"}, {"problem": 95, "code": "(fn btree? [t] \n    (or \n        (nil? t)\n        (and \n         \t(sequential? t)\n            (= 3 (count t))\n            (btree? (second t))\n            (btree? (last t)))))", "user": "5e042dede4b0a607a9a45d69"}, {"problem": 95, "code": "(fn [t?]\n    ((fn step [t?]\n       (if-not (coll? t?) (nil? t?)\n               (if-not (= (count t?) 3) false\n                       (let [[v l r] t?]\n                         (and v (step l) (step r)))))) t?))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 95, "code": "(fn tree [coll]\n  (let [inner-coll (first (filter coll? coll))\n        is-binary (odd? (count (filter #(and (not= % true) (not= % false)) (flatten coll))))]\n    (if (and is-binary (= (count inner-coll) 3))\n      (tree inner-coll)\n      is-binary)))", "user": "57fc5e42e4b0d3187e900997"}, {"problem": 95, "code": "(fn check [s]\n   (if  (coll? s) \n     (if (= (count s) 3)\n       (and (check (second s)) (check (last s)))\n       false)\n   (nil? s))\n)", "user": "5dbb5200e4b09f47823971a9"}, {"problem": 95, "code": "(fn f [n]\n  (cond\n    (and (coll? n) (= (count n) 3)) (and (f (second n)) (f (nth n 2)))\n   \t(coll? n) false\n   \t(nil? n) true\n    :else (true? n)))", "user": "5e08c3dde4b0978307768fc8"}, {"problem": 95, "code": "(fn tree-check [node]\n                     (if (nil? node)\n                       true\n                       (if (sequential? node)\n                         (if (and (= (count node) 3)\n                                  (tree-check (second node))\n                                  (tree-check (nth node 2)))\n                           true\n                           false)\n                         (if node\n                           true\n                           false))))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 95, "code": "(fn bt? [val]\n  (if (nil? val)\n    true\n    (if (or (true? val) (false? val) (not= 3 (count val)) (nil? first))\n      false\n      (and (bt? (second val)) (bt? (nth val 2))))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5e257a33e4b05b4b01516166"}, {"problem": 95, "code": "(fn depth-first [v]\n  (if-not (= (count v) 3) false\n    (let [[_ v1 v2] v]\n      (and\n        (if (nil? v1) true\n          (if-not (coll? v1) false\n            (depth-first v1)))\n        (if (nil? v2) true\n          (if-not (coll? v2) false\n            (depth-first v2)))))))", "user": "5e246f92e4b05b4b01516150"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (if ((complement coll?) t)\n    (nil? t)\n    (if (not= (count t) 3)\n      false\n      (and (binary-tree? (second t)) \n           (binary-tree? (nth t 2))))))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 95, "code": "(fn t [ns] \n  (if (= nil ns)\n    true\n    (if (not (sequential? ns))\n      false\n      (if (not= 3 (count ns))\n        false\n        (let [[_ l r] ns]\n          (and (t l) (t r)))))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n    (nil? t) true\n    (not (coll? t)) false\n    (not= (count t) 3) false\n    :else (and (tree? (second t)) (tree? (nth t 2)))\n    ))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 95, "code": "(fn is-tree? [node]\n   (letfn [(is-leaf? [n] (nil? n))\n           (is-branch? [n] (and\n                            (coll? n)\n                            (= (count n) 3)\n                            (is-tree? (second n))\n                            (is-tree? (nth n 2))))]\n     (or (is-leaf? node) (is-branch? node))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 95, "code": "(fn binary-tree? [tree]\n             (cond\n               (nil? tree) true ; leaf node\n               (not (coll? tree)) false\n               :else (let [[value lChild rChild & _ :as node] tree\n                           has-value? (or (number? value) (keyword? value))\n                           three-parts? (= (count node) 3)\n                           valid-node? (and has-value? three-parts?)]\n                       (cond\n                         (not valid-node?) false\n                         :else (and (binary-tree? lChild)\n                                    (binary-tree? rChild))))))", "user": "5e3975a3e4b01d43a70e8dd3"}, {"problem": 95, "code": "(fn isbin [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (isbin (second t))\n           (isbin (last t)))))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 95, "code": "(fn binary-tree? [seq]\n    (cond\n      (nil? seq) true\n      (sequential? seq) (and (= 3 (count seq))\n                             (binary-tree? (second seq))\n                             (binary-tree? (last seq)))\n      :else false))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n      \t   (tree? (second t))\n           (tree? (last t)))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 95, "code": "(fn answer [node]\n  (or (nil? node)\n      (and (sequential? node)\n           (= 3 (count node))\n           (every? answer (rest node))))\n  )", "user": "5e491182e4b043cd24807a46"}, {"problem": 95, "code": "(fn istree [a] \n    (or (nil? a)\n        (and (coll? a)\n             (= (count a) 3)\n             (let [[x y z] a] \n                (and (or (integer? x) (keyword? x) (nil? x))\n                     (or (nil? z) (istree z))\n                     (or (nil? y) (istree y))\n                )))))", "user": "5439bd25e4b032a45b869322"}, {"problem": 95, "code": "(fn btree? [t]\n    (if (not= (count t) 3)\n      false\n      (every?\n        #(if (counted? %)\n           (btree? %)\n           (not (false? %)))\n        t)))", "user": "5d28d935e4b092dab7f59c88"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5e2586afe4b05b4b01516167"}, {"problem": 95, "code": "(fn tree? [t]\n    (or\n     (nil? t)\n     (and (sequential? t)\n          (= 3 (count t))\n          (tree? (nth t 1))\n          (tree? (nth t 2)))))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (nil? t)\n    true\n    (and (sequential? t)\n         (= (count t) 3)\n         (tree? (nth t 1))\n         (tree? (nth t 2)))))", "user": "5dcc152ae4b02b31cc3da3c3"}, {"problem": 95, "code": "(fn tree-checker [coll]\n     (let [[a b c & rest] coll]\n       (if (= 3 (count coll))\n         (cond\n           (or (false? a) (false? b) (false? c)) false \n           (coll? a) (tree-checker a)\n           (coll? b) (tree-checker b)\n           (coll? c) (tree-checker c)\n           (nil? rest) true\n           :default false\n           )         \n         false)\n       )\n   )", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 95, "code": "(fn binary-tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? binary-tree? (rest root)))))", "user": "5db19599e4b010eb3c36cd05"}, {"problem": 95, "code": "(fn binary-tree [nodes]  (let [[parent right left] nodes] \n    (and (= 3 (count nodes)) \n      (if (or (seq? right) (vector? right)) (binary-tree right) (nil? right)) \n      (if (or (seq? left) (vector? left)) (binary-tree left) (nil? left)))))", "user": "5e48ec09e4b043cd24807a45"}, {"problem": 95, "code": "(fn tree-check \n\t[xs]\n\t(if-not (sequential? xs) \n\t\t(if (nil? xs) true false)\n\t\t(if (= 3 (count xs))\n\t\t\t(and (tree-check (second xs)) (tree-check (last xs)))\n\t\t\tfalse)))", "user": "5dc85f8ae4b02f9375f4e1da"}, {"problem": 95, "code": "(fn bin-tree? [s]\n        (if (nil? s)\n          true\n          (let [node? #(and (or (nil? %)\n                                (and (coll? %)\n                                     (= 3 (count %)))))]\n            (if-not (node? s)\n              false\n              (let [v (nth s 0)\n                    a (nth s 1)\n                    b (nth s 2)]\n                (and (bin-tree? a) (bin-tree? b)))))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 95, "code": "#(even? (count (filter (partial not= false) (rest (tree-seq sequential? identity %)))))", "user": "5d078e2de4b0cc9c915881fa"}, {"problem": 95, "code": "(fn pred [t]\n  (cond\n   (nil? t) true\n   (not (sequential? t)) false\n   (not (= (count t) 3)) false\n   :else (let\n           [[head left right] t]\n           (and\n            (not (nil? head))\n            (pred left)\n            (pred right)))))", "user": "5e6e6537e4b04a83ad7cd29a"}, {"problem": 95, "code": "(fn binary? [[head left right :as tree]]\n  (and\n   \t(= (count tree) 3)\n    (not (sequential? head))\n   \t(or (nil? left) (and (sequential? left) (binary? left)))\n   \t(or (nil? right) (and (sequential? right) (binary? right)))))", "user": "5e7f075ee4b085ba37836e36"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node)\n      (and\n       (counted? node)\n       (= 3 (count node))\n       (tree? (nth node 1 '()))\n       (tree? (nth node 2 '())))))", "user": "5b4b8cd6e4b02d533a91bc9f"}, {"problem": 95, "code": "#(let [tm (tree-seq sequential? identity %)]\n(and (empty? (remove (some-fn coll? (some-fn number? keyword? nil?)) tm))\n   (empty? (remove (some-fn (complement coll?) (fn [x] (= (count x) 3))) tm))))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 95, "code": "(fn tree? [array]\n  (if-not (counted? array)\n    false\n    (let [[value & children] array]\n      (if (or (nil? value) (not= (count children) 2))\n        false\n        (let [[left right] children]\n          (and (or (nil? left) (tree? left))\n               (or (nil? right) (tree? right))))))))", "user": "5e839edde4b09a7a73c8bbba"}, {"problem": 95, "code": "(fn is-tree [head] (if (= 3 (count head))\n                          (cond\n                            (false? (second head)) false\n                            (false? (last head)) false\n                            :else (and (is-tree (second head)) (is-tree (last head))))\n                          (and (not (false? head)) (not (coll? head)))))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 95, "code": "(fn tr? [t]\n  (and\n   (coll? t)\n   (= 3 (count t))\n   (let [[_ l r] t]\n     (and\n      (or (nil? l) (tr? l))\n      (or (nil? r) (tr? r))))))", "user": "4eb70649535d7eef30807373"}, {"problem": 95, "code": "(fn func [[_ left right :as coll]]\n  (cond \n    (not= 3 (count coll)) false\n    (and (coll? left) (coll? right)) (and (func left) (func right))    \n    (and (coll? left) (nil? right)) (func left)\n    (and (coll? right) (nil? left)) (func right)\n    (and (nil? left) (nil? right)) true\n    :else false))", "user": "5e805895e4b085ba37836e44"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (let [head (first t)\n        children (rest t)]\n    (and\n      (= (count children) 2)\n      (every?\n        (fn [child]\n          (cond\n            (coll? child) (binary-tree? child)\n            (nil? child) true\n            :else false))\n        children))))", "user": "5d0eed51e4b0cc9c91588262"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (or \n    (nil? tree) \n    (and \n      (coll? tree) \n      (= (count tree) 3) \n      (is-tree? (second tree)) \n      (is-tree? (last tree)))))", "user": "5e8f87c7e4b0cb0169546342"}, {"problem": 95, "code": "(fn [s] (let [l (tree-seq sequential? identity s)\n              h (filter sequential? l)]\n          (and (every? #(= (count %) 3) h)\n               (not-any? false? l))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 95, "code": "(fn tree? [xs]\n  (if-not (= 3 (count xs))\n    false\n    (if-let [[_ l r] xs]\n      (and\n       (if (sequential? l) (tree? l) (nil? l))\n       (if (sequential? r) (tree? r) (nil? r)))\n      false)))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 95, "code": "(fn node? [tree]\n  (or (nil? tree)\n      (and (sequential? tree)\n           (= 3 (count tree))\n           (every? node? (rest tree)))))", "user": "4ea8570f535d7eef308072f8"}, {"problem": 95, "code": "(fn tree? [coll]\n   (cond\n     (coll? coll) (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n     (nil? coll) true\n     :else false))", "user": "5e99cbd4e4b0157ca96647e6"}, {"problem": 95, "code": "(fn [tree]\n  (->> tree (flatten) (filter #(not (false? %))) (count) (odd?)))", "user": "585c16c3e4b0f14aab7c877d"}, {"problem": 95, "code": "(fn binary? [x]\n  (and\n   (sequential? x)\n   (= (count x) 3)\n   (let [ left (second x)\n         right (last x)]\n     (and\n      (or\n       (nil? left)\n       (binary? left))\n      (or\n       (nil? right)\n       (binary? right))))))", "user": "5e9771dee4b0157ca96647d0"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5e9e408fe4b00a66d4a95172"}, {"problem": 95, "code": "(fn toTree\n  [tree]\n  (cond\n   (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (toTree(second tree))(toTree (nth tree 2)))))", "user": "5e95013fe4b0fbed045a3800"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree? (rest root)))))", "user": "5e978fe5e4b0157ca96647d1"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true :else false))", "user": "5e9d1c75e4b0157ca9664801"}, {"problem": 95, "code": "(fn tree? [node]\n  (or (nil? node)\n      (and (or (seq? node) (vector? node))\n           (= 3 (count node))\n           (every? tree? (rest node)))))", "user": "5e950178e4b0fbed045a3801"}, {"problem": 95, "code": "(fn toTree\n  [n]\n  (cond\n   (false? n) false\n   (not (coll? n)) true\n   (not= (count n) 3) false\n   :else (and (toTree(second n))(toTree (nth n 2)))))", "user": "5ea3711ae4b00a66d4a9519d"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5ea6f88de4b00a66d4a951b1"}, {"problem": 95, "code": "(fn is-tree [x]\n  (cond \n   (or (vector? x) (list? x)) \n   (and (= 3 (count x)) (is-tree (nth x 1)) (is-tree (nth x 2)))\n        (nil? x) true\n        :else false\n\n        )\n  )", "user": "5ea7b04de4b00a66d4a951b6"}, {"problem": 95, "code": "(fn is-tree [xs]\n  (cond\n    (nil? xs) true\n   \t(and (coll? xs)\n   \t\t  (= 3 (count xs)))\n   \t\t(let [[v l r] xs]\n        \t(and  \n             (not (list? v))\n             (is-tree l)\n             (is-tree r)))\n   :else\n   \tfalse))", "user": "5ea2e6bfe4b00a66d4a95197"}, {"problem": 95, "code": "(fn tree? [t]\n  (if (or (nil? t)\n          (and\n            (counted? t)\n            (= (count t) 3)\n            (tree? (second t))\n            (tree? (nth t 2))))\n    true\n    false))", "user": "5e9b7aefe4b0157ca96647f1"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5eaba9c0e4b00a66d4a951d6"}, {"problem": 95, "code": "(fn bt? [[val left right :as root]]\n  (and (= (count root) 3)\n       (or (nil? left) (and (coll? left) (bt? left)))\n       (or (nil? right) (and (coll? right) (bt? right)))))", "user": "59750a68e4b01722bebd4cba"}, {"problem": 95, "code": "(fn solution [tree]\n  (if (or (some false? tree) (not= (count tree) 3))\n    false\n    (do (let [subs (filter coll? tree)\n              n (count subs)]\n          (if (= n 0)\n            true\n            (if (= n 1)\n              (solution (apply concat subs))\n              (do (solution (first subs))\n                  (solution (second subs)))))))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 95, "code": "(fn ? [n]\n    (or (nil? n)\n        (and (coll? n)\n             (= 3 (count n))\n             (every? ? (rest n)))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 95, "code": "(fn valid? [[v l r :as node]]\n  (cond (nil? node) true\n        (not= (count node) 3) false\n        :else (and (or (nil? l) (and (coll? l) (valid? l)))\n                   (or (nil? r) (and (coll? r) (valid? r))))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 95, "code": "(fn tree? [s]\n  (cond\n   (coll? s) (and (= (count s) 3) (every? tree? (rest s)))\n   :else (nil? s)))", "user": "5e9683f1e4b0157ca96647c7"}, {"problem": 95, "code": "(fn is-tree [[a b c :as d]]\n  (cond\n    (empty? d) false\n    (= 3 (count d)) (and\n                     (cond\n                       (coll? b) (is-tree b)\n                       (nil? b) true\n                       :else false)\n                     (cond\n                       (coll? c) (is-tree c)\n                       (nil? c) true\n                       :else false))\n    :else false))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 95, "code": "(fn bin-tree [args]\n  (if (or (not= (count args) 3) (not (not-any? false? args)))\n    false\n    (not-any? false? (map bin-tree (filter coll? args)))))", "user": "568f2059e4b0dcc4269f40df"}, {"problem": 95, "code": "(fn [s]\n  (letfn [(bfs [tree]\n            (loop [traversed [(list tree)]]\n              (if (empty? (peek traversed))\n                (butlast traversed)\n                (recur (conj traversed (apply concat (map #(filter coll? %) (peek traversed))))))))\n          (verify-node [node]\n            (and (= 3 (count node)) (every? coll? (filter (comp not nil?) (rest node)))))]\n    (every? identity (map #(every? verify-node %) (bfs s)))))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 95, "code": "(fn is-node?\n  [node]\n  (and\n   (= 3 (count node))\n   (let [[val lc rc] node\n         valid-child? (fn [child]\n                        (if (= child nil)\n                          true\n                          (if (sequential? child)\n                            (is-node? child)\n                            false)))]\n     (and (valid-child? lc) (valid-child? rc)))))", "user": "5ed3c43be4b016b56eae05c4"}, {"problem": 95, "code": "#(loop [opTree %\n       other []]\n  (if (= nil opTree)\n    (if (empty? other)\n      true\n      (recur (first other) (rest other)))\n    (if (and\n         (coll? opTree)\n         (= 3 (count opTree)))\n      (recur (second opTree) (conj other (last opTree)))\n      false)))", "user": "5e909685e4b0cb016954634d"}, {"problem": 95, "code": "(fn check [root]\n  (if (nil? root) true\n      (and (sequential? root)\n           (= 3 (count root))\n           (check (second root))\n           (check (nth root 2)))))", "user": "5799b260e4b05b1deef9adc8"}, {"problem": 95, "code": "(fn tree [coll]\n  (let [inner-coll (first (filter coll? coll))\n        is-binary (odd? (count (filter #(and (not= % true) (not= % false)) (flatten coll))))]\n    (if (and is-binary (= (count inner-coll) 3))\n      (tree inner-coll)\n      is-binary)))", "user": "593c1e3be4b069cdc2982b86"}, {"problem": 95, "code": "(fn btr [xs]\n  (if (or ((complement coll?) xs)\n          (not= (count xs) 3))\n    false\n    (let [[x y z] xs]\n      (and (or (nil? y)\n               (btr y))\n           (or (nil? z)\n               (btr z))))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 95, "code": "(fn is-tree? [seq]\n  (if (coll? seq)\n    (and\n      (= (count seq) 3)\n      (every? is-tree? (rest seq)))\n    (nil? seq)))", "user": "5eac172fe4b00a66d4a951dd"}, {"problem": 95, "code": "(fn is-tree?[v]\n        (or (nil? v) (and\n                      (coll? v)\n                      (= 3 (count v))\n                      (is-tree? (second v))\n                      (is-tree? (second (next v))))))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 95, "code": "(fn verify-tree\n  [n]\n  (if (nil? n)\n    true\n    (if (and (coll? n) (= 3 (count n)))\n      (and (verify-tree (second n)) (verify-tree (last n)))\n      false)))", "user": "5ecfd429e4b016b56eae05a9"}, {"problem": 95, "code": "(fn is-bin-tree? [coll]\n  (if (not (coll? coll))\n    false\n    (if (not (= 3 (count coll)))\n      false\n      (let [leg1 (second coll) leg2 (last coll)]\n        (cond\n          (and (nil? leg1)         (nil? leg2))         true\n          (and (nil? leg1)         (not (coll? leg2)))  false\n          (and (not (coll? leg1))  (nil? leg2))         false\n          (and (is-bin-tree? leg1) (is-bin-tree? leg2)) true\n          (and (is-bin-tree? leg1) (nil? leg2))         true\n          (and (nil? leg1)         (is-bin-tree? leg2)) true\n          :else false)))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5ab276f2e4b073f1774425e6"}, {"problem": 95, "code": "(fn tree? [t] (or (nil? t) (and\n  (coll? t)\n  (= (count t) 3)\n  (tree? (nth t 1)) \n  (tree? (nth t 2)))))", "user": "5ed9c2cde4b0c7845d86b0e4"}, {"problem": 95, "code": "(fn is-tree [s] (or (nil? s)\n                    (and (sequential? s)\n                         (= (count s) 3)\n                         (is-tree (first (rest s)))\n                         (is-tree (first (rest (rest s)))))))", "user": "5ee93720e4b029a2061bbeb7"}, {"problem": 95, "code": "(fn is-tree? [s]\n  (cond (and (not (sequential? s)) (nil? s)) true\n        (and (sequential? s) (= 3 (count s))) (and (is-tree? (nth s 1)) (is-tree? (nth s 2)))\n        :else false))", "user": "5ee738dee4b029a2061bbea2"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (coll? x)\n           (= 3 (count x))\n           (tree? (second x))\n           (tree? (last x)))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 95, "code": "(fn check\n  ([a] (if (coll? a)\n         (if (= (count a) 3)\n           (let [[v l r] a]\n             (and (check l) (check r)))\n             false)\n         (nil? a))))", "user": "5eb4927fe4b00a66d4a95221"}, {"problem": 95, "code": "(fn tree? [a]\n  (cond\n    (nil? a) true\n    (false? a) false\n    (= (count a) 1) true\n    (not= (count a) 3) false\n    :else (let [[root left right] a]\n      (and (tree? left) (tree? right))\n    )))", "user": "5eeeb000e4b07c55ae4a0515"}, {"problem": 95, "code": "(fn binary-tree?\n  [[value left right :as node]]  \n  (and \n   (sequential? node)\n   (= (count node) 3)\n   (and (not (sequential? value))\n        (not (nil? value)))\n   (or (nil? left)\n       (and  (sequential? left)\n             (binary-tree? left)))\n   (or (nil? right)\n       (and (sequential? right)\n            (binary-tree? right))\n       )))", "user": "5455a6d3e4b0e397800069e2"}, {"problem": 95, "code": "(fn tree? [t] \n  (if (nil? t) true\n    (and (sequential? t)\n         (= 3 (count t))\n         (tree? (nth t 1))\n         (tree? (nth t 2)))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 95, "code": "(fn is-tree-or-val [s]\n  (if (sequential? s)\n    (and\n     (= (count s) 3)\n     (not (sequential? (nth s 0)))\n     (is-tree-or-val (nth s 1))\n     (is-tree-or-val (nth s 2)))\n    (not (false? s))))", "user": "5eb741e4e4b00a66d4a9523b"}, {"problem": 95, "code": "(fn walk [coll]\n                           (let [\n\n                                 my-reduced (fn [val] (fn [] val))\n                                 my-reduce (fn my-reduce [func accum coll]\n                                             (if (fn? accum)\n                                               (let [accum-result (accum)]\n                                                 accum-result)\n                                               (if (empty? coll)\n                                                 accum\n\n                                                 (my-reduce func (func accum (first coll)) (rest coll))\n\n                                                 )))\n                                 \n                                 \n\n                                 ]\n                             (if (= 3 (count coll))\n                               (my-reduce (fn [a v]\n                                            (if (= v false) false\n                                            (if (coll? v) \n                                              (if (walk v)\n                                                a\n                                                (my-reduced false))\n                                              a\n                                              )))\n                                          true coll)\n                               false\n\n                               )))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 95, "code": "(fn istree?\n  [tree]\n  (if (coll? tree)\n    (if (= (count tree) 3)\n      (and (istree? (second tree)) (istree? (nth tree 2)))\n      false)\n    (nil? tree)))", "user": "5ef18431e4b07c55ae4a0529"}, {"problem": 95, "code": "(fn tree? [t]\n  (or (nil? t)\n  \t  (and (coll? t)\n           (= 3 (count t))\n           (every? tree? (rest t)))))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 95, "code": "(fn tree? [xs]\n  (cond\n   (or (seq? xs) (vector? xs)) (and (= 3 (count xs)) (tree? (nth xs 1)) (tree? (nth xs 2)))\n   (nil? xs) true\n   :else false))", "user": "5eec1001e4b07c55ae4a0502"}, {"problem": 95, "code": "(fn f [[p l r :as xs]]\n  (and (= (count xs) 3)\n       (or (and (sequential? l)\n                (f l))\n           (nil? l))\n       (or (and (sequential? r)\n                (f r))\n           (nil? r))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 95, "code": "(fn btree? [[r & cs]]\n (letfn [(chk [x] (if (coll? x) (not (empty? x)) (if (nil? x) true false)))]\n   (if r\n          (and (= (count cs) 2) (if (chk (first cs)) (btree? (first cs)) false) (if (chk (second cs)) (btree? (second cs)) false))\n          true\n   )\n  )\n)", "user": "5df08767e4b093ff717275bf"}, {"problem": 95, "code": "(fn isnode [t]\n  (or (nil? t) (and (coll? t) (= 3 (count t)) (isnode (second t)) (isnode (last t)))))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 95, "code": "(fn tree [node]\n  (if (and node (= 3 (count node)))\n    (let [[v r l] node]\n      (if v (and (tree r) (tree l))))\n(= node nil)))", "user": "5f003099e4b0cf489e8d7f17"}, {"problem": 95, "code": "(fn bt? [c] (if (and (coll? c) (= 3 (count c)))\n             (let [c2 (second c)\n                   c3 (last c)]\n               (if (and (or (nil? c2) (bt? c2))\n                        (or (nil? c3) (bt? c3)))\n                 true\n                 false))\n             false))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5ef82119e4b09b61f08553c6"}, {"problem": 95, "code": "(fn tree? [sq] \n  (cond (nil? sq) true\n        (not (sequential? sq)) false   \n        (not (= (count sq) 3)) false\n        (and (tree? (second sq)) (tree? (nth sq 2))) true\n        :else false))", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 95, "code": "(fn is-tree?\n  [coll]\n  (and (= (count coll) 3)\n       (not (nil? (first coll)))\n       (not (coll? (first coll)))\n       (every? #(and % true) (flatten (map #(if (coll? %)(is-tree? %)(nil? %)) (rest coll))))\n       true))", "user": "5e9b6471e4b0157ca96647f0"}, {"problem": 95, "code": "(fn tree?\n  [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n    (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5ec5f7f2e4b08d0ec38692d1"}, {"problem": 95, "code": ";; this one is \"stolen\"\n(fn istree? [root]\n (or (nil? root)\n  (and (sequential? root)\n   (= 3 (count root))\n   (every? istree? (rest root)))))", "user": "5e3071abe4b05b4b01516213"}, {"problem": 95, "code": "(fn func \n  ([tree]\n   (func tree true))\n  ([tree is-tree]\n   (cond\n     (not is-tree) false\n     (nil? tree) true\n     (and (coll? tree) (= (count tree) 3)) (and (func (nth tree 1)) (func (nth tree 2)))\n     :else false)))", "user": "5666c2dbe4b04acd4f672dc3"}, {"problem": 95, "code": "(fn binary?\n  [s]\n  (and\n   (sequential? s)\n   (= (count s) 3)\n   (let [left (second s)\n         right (last s)]\n     (and\n      (or\n       (nil? left)\n       (binary? left))\n      (or\n       (nil? right)\n       (binary? right))))))", "user": "5f18444ee4b091ba50b4dbd3"}, {"problem": 95, "code": "(fn t [x] (if (sequential? x) (and (= 3 (count x)) (t (second x)) (t (nth x 2))) (nil? x)))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 95, "code": "(fn c95 [[node left right :as tree]]\n  (and (= 3 (count tree))\n       (not (coll? node))\n       (if (coll? left)\n         (c95 left)\n         (or (nil? left) left))\n       (if (coll? right)\n         (c95 right)\n         (or (nil? right) right))))", "user": "5c24671be4b07e362c2305a1"}, {"problem": 95, "code": "(fn tree?\n  [coll]\n  (if (= 3 (count coll))\n    (let [value (first coll)\n          left  (first (rest coll))\n          right (first (rest (rest coll)))]\n      (if (or (keyword? value)\n              (integer? value))\n        (let [left-rst (if (nil? left)\n                         true\n                         (if (coll? left)\n                           (tree? left)\n                           false))\n              right-rst (if (nil? right)\n                          true\n                          (if (coll? right)\n                            (tree? right)\n                            false))]\n          (and left-rst right-rst))\n        false))\n    false))", "user": "5bc7f2d6e4b07a9b28b100b7"}, {"problem": 95, "code": "(fn [input]\n  (let [breakdown (tree-seq sequential? identity input)\n        nodes (filter sequential? breakdown)\n        edges (filter #(not (sequential? %)) breakdown)\n        not-nil-edges (filter #(not (nil? %)) edges)\n        valid-nodes? (every? #(= 3 (count %)) nodes)]\n    (and\n      valid-nodes?\n      (= (count not-nil-edges) (count nodes)))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n   (false? t) false\n   (nil? t) true\n   :else\n    (let [[_ left right] t]\n      (and\n       (= (count t) 3)\n       (tree? left)\n       (tree? right)))))", "user": "5f37da09e4b0574c87022c5e"}, {"problem": 95, "code": "(fn tree? [s]\n  (if (and (coll? s) (seq s))\n    (when-let [[_ l r] (seq s)]\n      (and (== 3 (count s)) (tree? l) (tree? r)))\n    (nil? s)))", "user": "5f300f28e4b033932238a682"}, {"problem": 95, "code": "(fn f[root]\n  (if (nil? root)\n    true\n    (and (coll? root)\n         (= 3 (count root))\n         (f (second root))\n         (f (last root)))))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 95, "code": "(fn [list]\n   (letfn [(t [l]\n             (cond\n               (nil? l) true\n               (not (coll? l)) false\n               (not= (count l) 3) false\n               (and (t (nth l 1)) (t (nth l 2))) true\n               true false))]\n     (t list)))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 95, "code": "(fn tree [t]\n  (cond (and (not (coll? t)) (not (false? t))) true\n        (and (not (coll? t)) (false? t)) false\n        (not (= 3 (count t))) false\n        :else (and (tree (first t)) (tree (second t)) (tree (nth t 2)))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 95, "code": "(fn f [coll]\n   (and (= 3 (count coll))\n        ((complement sequential?) (first coll))\n        (let [secnd (second coll)\n              third (nth coll 2)]\n          (and (if (sequential? secnd)\n                 (f secnd)\n                 ((complement false?) secnd))\n               (if (sequential? third)\n                 (f third)\n                 ((complement false?) third))))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 95, "code": "(fn tree [t]\n      (if (coll? t)\n          (and (= 3 (count t))\n               (every? true? (map tree t)))\n          (not (false? t))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 95, "code": "(fn bt? [x]\n  (if (and (or (seq? x) (vector? x) (list? x)) (= (count x) 3))\n    (let [[v l r] x]\n      (and (not (nil? v))\n         (or (nil? l) (bt? l))\n         (or (nil? r) (bt? r))))\n    false))", "user": "5f3ddc71e4b004f08c61c551"}, {"problem": 95, "code": "(fn tri [l]\n  (or\n   (= nil l)\n   (and (or (seq? l) (vector? l))\n        (= 3 (count l))\n        (tri (second l))\n        (tri (nth l 2)))))", "user": "53d63e6ce4b0e771c3025454"}, {"problem": 95, "code": "(fn tree?* [coll]\n  (and\n   (= 3 (count coll))\n   (every? (fn child? [x]\n  (if (or (sequential? x) (nil? x))\n    true\n    false)) (rest coll))\n   (every? true? (map tree?* (filter sequential? (rest coll))))))", "user": "5f38eecce4b0574c87022c72"}, {"problem": 95, "code": "(fn btree? [structure]\n  (and\n   (coll? structure)\n   (= (count structure) 3)\n   (let [lchild (second structure)\n         rchild (nth structure 2)]\n     (and\n      (or\n       (nil? lchild)\n       (btree? lchild))\n      (or\n       (nil? rchild)\n       (btree? rchild))))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n   (or (seq? coll) (vector? coll)) (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n   (nil? coll) true\n   :else false))", "user": "5d92b543e4b0915913b1d414"}, {"problem": 95, "code": "(fn is-bintree [coll]\n  (if (nil? coll)\n    true\n    (if (= 3 (count coll))\n      (if (every? #(or (nil? %) (coll? %)) (rest coll))\n        (and (is-bintree (second coll)) (is-bintree (last coll)))\n        false)\n      false)))", "user": "5f2c94b4e4b033932238a669"}, {"problem": 95, "code": "(fn [x] (= x (clojure.walk/postwalk #(if (and (coll? %) (not= (count (remove false? %)) 3)) nil %) x)))", "user": "5b99554ae4b0c0b3ffbd4ace"}, {"problem": 95, "code": "(fn [coll]\n   (->> coll \n        (tree-seq coll? rest)\n        (filter coll?)\n        (every? #(and (= (count %) 3) \n                      (every? (fn [c] (or (coll? c) (nil? c))) (rest %))))))", "user": "5f4fe1fae4b0a0bc16850a5c"}, {"problem": 95, "code": "(fn [tree]\n  (loop [s [tree] result true]\n  (let [item (first s)]\n    (cond\n      (nil? item) true\n      (not (sequential? item)) false\n      (not= 3 (count item)) false\n      :else (let [[node left right] item]\n        (recur\n          (concat (rest s) (if (nil? left) [] [left]) (if (nil? right) [] [right]))\n          result\n          ))\n      )\n\n    )\n  )\n\n\n  )", "user": "5f58db95e4b0a0bc16850a9a"}, {"problem": 95, "code": "(fn binary-tree? [xs]\n  (letfn [(valid-node? [col idx]\n            (let [elem (nth col idx)]\n              (if (nil? elem)\n                true\n                (and (coll? elem) (binary-tree? elem)))))]\n    (if (= 3 (count xs))\n      (and\n       (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))\n      false)))", "user": "5f4eb036e4b0102c75033969"}, {"problem": 95, "code": "(fn tree? [t] \n    (if (nil? t) \n        true \n        (if (or (not (coll? t)) (not= 3 (count t)))\n            false\n            (let [[v l r] t]\n                (and (not (coll? v)) (tree? l) (tree? r))))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 95, "code": ";stolen tricky solution realted to params\n;(fn tree? [[n l r :as t]] \n;   (and \n;     (= 3 (count t)) \n;     (every? #(or (nil? %) (and (coll? %) (tree? %))) [l r])))\n(fn tree [col]\n   (loop [c col]\n     (if (= (count c) 3)\n       (if (empty? (filter coll? c))\n         true\n         (recur (remove false? (first (filter coll? c)))))\n       false))\n   )", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5f5f2eafe4b02876ed9fcff5"}, {"problem": 95, "code": "(fn f [coll]\n    (if (false? (coll? coll))\n      (not= false coll)\n      (and (= 3 (count coll))\n           (every? f coll))))", "user": "531bf76fe4b08068f379ed96"}, {"problem": 95, "code": "(fn tree\n  [lst]\n  (cond\n   (or (seq? lst) (vector? lst))\n   (and (= 3 (count lst)) (tree (nth lst 1)) (tree (nth lst 2)))\n   (nil? lst) true\n   :else false\n  ))", "user": "5f724f55e4b02876ed9fd089"}, {"problem": 95, "code": "(fn t [i]\n   (if (sequential? i)\n     (and (= 3 (count i))\n          (let [[a b c] i]\n            (and (not (nil? a))\n                 (t b) (t c))))\n     (nil? i)))", "user": "588fbb39e4b00487982d51bd"}, {"problem": 95, "code": "(fn tree-check [t]\n  (cond\n    (nil? t) true\n    (not (= 3 (count t))) false\n    (and (or (nil? (nth t 1)) (sequential? (nth t 1)))\n         (or (nil? (nth t 1)) (sequential? (nth t 1)))) (and (tree-check (nth t 1)) (tree-check (nth t 2)))\n    :else false))", "user": "5f63684be4b02876ed9fd012"}, {"problem": 95, "code": "(fn check [node]\n  (if (not (= (count node) 3)) false ;;return false if not a valid node\n    (let [a (second node) b (last node)]\n    (and ;;otherwise the node must be a nil or a node\n     (or (nil? a) (and (coll? a) (check a)))\n     (or (nil? b) (and (coll? b) (check b)))\n     )\n   ))\n )", "user": "5f686436e4b02876ed9fd03c"}, {"problem": 95, "code": "(fn validate [bt]\n    (if (sequential? bt)\n      (if (= (count bt) 3)\n        (and\n          (validate (second bt))\n          (validate (last bt)))\n        false)\n      (nil? bt)))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 95, "code": "(fn isbtree [tree]\n  (if tree\n    (and\n      (= (count tree) 3)\n      (isbtree (second tree))\n      (isbtree (nth tree 2)))\n    (= tree nil)))", "user": "5f7d169ee4b0c071e6c840d2"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n   (or (seq? coll) (vector? coll))\n   \t(and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n   \t(nil? coll) true\n   \t:else false\n   )\n   )", "user": "573102bbe4b0cd1946bd0fbb"}, {"problem": 95, "code": "(fn fits-tree-expectations? [sequence]\n  (and (= 3 (count sequence))\n       (every? #(some (fn [f] (f %)) [seq? vector? integer? nil? keyword?]) sequence)\n       (every?\n        fits-tree-expectations?\n        (filter #(or (seq? %) (vector? %)) sequence))))", "user": "5f79bff2e4b02876ed9fd0ca"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5f727bd1e4b02876ed9fd08c"}, {"problem": 95, "code": "(fn tree? [x]\n  (cond\n    (or (seq? x) (vector? x))\n      (and (= 3 (count x)) (tree? (nth x 1)) (tree? (nth x 2)))\n    (nil? x) true\n    :else false))", "user": "5f727dd6e4b02876ed9fd090"}, {"problem": 95, "code": "(fn tree? [n]\n  (cond\n    (or (seq? n) (vector? n))\n      (and (= 3 (count n)) (tree? (nth n 1)) (tree? (nth n 2)))\n    (nil? n) true\n    :else false))", "user": "5f7e91c8e4b0c071e6c840d8"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5f72f144e4b02876ed9fd093"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5f84f0f5e4b0375e81f54e78"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))     (and (= 3 (count coll))\n                                             (tree? (nth coll 1))\n                                             (tree? (nth coll 2)))\n   \n    (nil? coll) \t\t\t\t\t\ttrue\n    :else false))", "user": "5f8497dce4b0375e81f54e74"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5f792d48e4b02876ed9fd0c5"}, {"problem": 95, "code": "(fn istree? [lst]\n    (cond\n        (nil? lst)\n        true\n        (false? lst)\n        false\n        (and (= 3 (count lst)) (istree? (nth lst 1)) (istree? (nth lst 2)))\n        true\n        :else\n        false))", "user": "5f74de11e4b02876ed9fd0a5"}, {"problem": 95, "code": "(fn isTree? [lst] (cond\n                       (not (= 3 (count lst)))\n                       false\n                       \n                       (and (sequential? (second lst)) (sequential? (last lst)))\n                       (and (isTree? (second lst)) (isTree? (last lst)))\n                       \n                       (sequential? (second lst))\n                       (and (isTree? (second lst)) (= nil (last lst)))\n                       \n                       (sequential? (last lst))\n                       (and (isTree? (last lst)) (= nil (second lst)))\n                       \n                       (and (= nil (second lst)) (= nil (last lst)))\n                       true\n                       \n                       :else\n                       false\n                       \n                       ))", "user": "5f727d2fe4b02876ed9fd08f"}, {"problem": 95, "code": "(fn bin-tree? [node]\n  (and (coll? node)\n       (= 3 (count node))\n       (every? #(or (nil? %) (bin-tree? %)) (rest node))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5f8361bae4b01aacbe7a2712"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5f87e757e4b0169f6814c40f"}, {"problem": 95, "code": "(fn is-bin-tree? [t]\n    (or (nil? t)\n        (and (or (list? t)\n                     (vector? t))\n                 (= 3 (count t))\n                 (is-bin-tree? (second t))\n                 (is-bin-tree? (nth t 2)))))", "user": "5f77890ae4b02876ed9fd0b9"}, {"problem": 95, "code": "(fn tree?[tree]\n        (or (nil? tree)\n            (and (or (list? tree)\n                     (vector? tree))\n                 (= 3 (count tree))\n                 (tree? (second tree))\n                 (tree? (nth tree 2)))))", "user": "5f737899e4b02876ed9fd099"}, {"problem": 95, "code": "(fn tree? [node]\n  (cond (or (seq? node) (vector? node)) (and (= 3 (count node)) (tree? (nth node 1)) (tree? (nth node 2)))\n    (nil? node) true\n    :else false))", "user": "5f727cb0e4b02876ed9fd08e"}, {"problem": 95, "code": "(fn to-tree-or-not [tree]\n  (and (= (count tree) 3)\n       (not (coll? (first tree)))\n       (or (nil? (second tree))\n           (and (coll? (second tree))\n                (to-tree-or-not (second tree))))\n       (or (nil? (nth tree 2))\n           (and (coll? (nth tree 2))\n                (to-tree-or-not (nth tree 2))))))", "user": "56b9c644e4b0f2655033593a"}, {"problem": 95, "code": "(fn tre [s]\n  (if (nil? s)\n    true\n    (if (sequential? s)\n      (if (= (count s) 3)\n        (let [[v lc rc] s] (and (tre lc) (tre rc)))\n        false)\n      false)))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 95, "code": "(fn btree? [[_ l r :as t]] \n   (and (= 3 (count t))\n        (every? #(or (nil? %) (and (coll? %) (btree? %))) [l r])))", "user": "596a66cde4b069c0a1a19803"}, {"problem": 95, "code": "(fn binary-tree? [node]\n  (if (or (list? node) (vector? node))\n    (cond\n      (not= (count node) 3) false\n      (and\n        (or (list? (second node)) (vector? (second node)) (nil? (second node)))\n        (or (list? (last node)) (vector? (last node)) (nil? (last node)))) (and\n              (binary-tree? (second node))\n              (binary-tree? (last node)))\n      :else false)\n    true))", "user": "5c8cfff8e4b048ec896c5996"}, {"problem": 95, "code": "(fn is-tree?\n  [s]\n  (or\n    (and (sequential? s)\n         (= 3 (count s))\n         (every? is-tree? (rest s)))\n    (nil? s)))", "user": "5f3103aee4b0574c87022c24"}, {"problem": 95, "code": "(fn bin? [root]\n  (or\n    (nil? root)\n    (and (coll? root) (= (count root) 3) (every? bin? (rest root)))))", "user": "5f6caa19e4b02876ed9fd056"}, {"problem": 95, "code": "(fn bt? [s]\n      (if (not (coll? s))\n        false\n        (let [[n a b] s]\n          (and (= 3 (count s))\n               n\n               (or (nil? a) (bt? a))\n               (or (nil? b) (bt? b))))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 95, "code": "(fn\n[x]\n  (loop [t x]\n    (if (or (not (= 3 (count t))) (not (empty? (filter false? t))))\n      false\n      (if (empty? (filter sequential? t))\n        true\n        (if (sequential? (first (rest t)))\n         (recur (first (rest t)))\n         (if (sequential? (first (rest (rest t))))\n           (recur (first (rest (rest t))))))\n        )\n\n))\n\n)", "user": "5dd70ee3e4b0948ae9d9ad85"}, {"problem": 95, "code": "(fn is_bin_tree\n  [s]\n  (if (nil? s)\n    true\n  \t(if (and (sequential? s) (= (count s) 3))\n    \t(and (is_bin_tree (second s)) (is_bin_tree (nth s 2)))\n        false\n    )\n  )\n)", "user": "5f6b8222e4b02876ed9fd052"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n    (nil? t) true\n    (not (coll? t)) false\n    (not (= 3 (count t))) false\n    (and (tree? (nth t 1)) (tree? (nth t 2))) true\n    :else false))", "user": "5f648ef1e4b02876ed9fd01b"}, {"problem": 95, "code": "(fn is-binary-tree? [tree]\n  (and (= 3 (count tree))\n       (cond (coll? (nth tree 1)) (is-binary-tree? (nth tree 1))\n             (coll? (nth tree 2)) (is-binary-tree? (nth tree 2))\n             :else (and (nil? (nth tree 1)) (nil? (nth tree 2))))))", "user": "5eb3d02be4b00a66d4a95215"}, {"problem": 95, "code": "(fn isbin? [v] \n  (if \n    (= 3 (count v)) (reduce #(cond (= false %1) false (coll? %2) (isbin? %2) (false? %2) false :else %1) true (rest v)) false ))", "user": "5ee4545ee4b029a2061bbe8d"}, {"problem": 95, "code": "(fn is-bin-tree [c]\n                   (or (nil? c)\n                       (and (coll? c) (= 3 (count c))\n                            (let [l (nth c 1)] (or (nil? l) (is-bin-tree l)))\n                            (let [r (nth c 2)] (or (nil? r) (is-bin-tree r))))))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 95, "code": "(fn is-tree? [tree]\n  (if (sequential? tree)\n    (let [[a b c] tree]\n      (and (= (count tree) 3)\n           (not (sequential? a))\n           (or (nil? b) (is-tree? b))\n           (or (nil? c) (is-tree? c))))\n    false))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "56eff7c1e4b04a395b9a0468"}, {"problem": 95, "code": "(fn bin-tree? [x] \n    (cond \n     (nil? x) true\n     (not (or (coll? x) (nil? x))) false\n     (and (not (coll? (first x))) (= 3 (count x)) (every? bin-tree? (rest x))) true\n     :else false\n     ) \n    )", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 95, "code": "(fn btree [root]\n  (or\n   (nil? root)\n   (and (coll? root) (= 3 (count root)) (every? btree (rest root)))))", "user": "5fa5b72ee4b0fa27300f3dca"}, {"problem": 95, "code": "(fn bitree? [t]\n  (if (and (coll? t) (= (count t) 3))\n    (and (bitree? (second t)) (bitree? (last t)))\n    (nil? t)))", "user": "5e5096c6e4b027a2e10ac0c6"}, {"problem": 95, "code": "(fn valid-tree? [node]\n    (or (nil? node)\n        (and (counted? node)\n             (= 3 (count node))\n             (valid-tree? (nth node 1))\n             (valid-tree? (nth node 2)))))", "user": "5f331015e4b0574c87022c37"}, {"problem": 95, "code": "(fn tree [l] \n (if (and (= (count l) 3)\n          (or (and (sequential? (second l)) \n                   (tree (second l))) \n              (nil? (second l)))\n          (or (and (sequential? (last l)) \n                   (tree (last l))) \n              (nil? (last l)))) true false))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 95, "code": "(fn tree?\n  ([ t c1 c2 ]\n  \t(or (nil? t)\n      (and\n       (coll? t)\n       (= 3 (count t))\n       (tree? c1)\n       (tree? c2))))\n  ([ t ]\n  \t(or (nil? t)\n      (and\n       (coll? t)\n       (= 3 (count t))\n       (tree? (nth t 1))\n       (tree? (nth t 2))))))", "user": "573a0ecce4b0cd1946bd1088"}, {"problem": 95, "code": "(fn f [coll]\n   (and\n    (= 3 (count coll))\n    (every? (fn [x]\n              (do (prn x) (if (nil? x)\n                            true\n                            (if (sequential? x)\n                              (f x)\n                              x))))\n            coll)))", "user": "5fa96ddbe4b0fa27300f3dec"}, {"problem": 95, "code": "(fn tree [arg]\n  (cond\n   (= arg nil) true\n   (= arg false) false\n   (= (count arg) 0) false\n   (= (count arg) 1) true\n   (> (count arg) 3) false\n   (= (count arg) 2) false\n   (and (= (first arg) nil) (> (count arg) 1) ) false\n   :else (and (tree (second arg)) (tree (last arg)) ) \n   )\n  )", "user": "5fc5c303e4b02c825b0c8c1a"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5fc04417e4b0edf42a5593c6"}, {"problem": 95, "code": "(fn bin-tree [s] (if (sequential? s) \n                   (and (= 3 (count s))\n                        (bin-tree (second s))\n                        (bin-tree (last s))) \n                   (not (= false s))))", "user": "5e471203e4b043cd24807a2a"}, {"problem": 95, "code": "(fn tree? [x]\n  (if (nil? x)\n    true\n    (if (and (coll? x) (= (count x) 3) )\n      (and (tree? (second x))\n           (tree? (last x)))\n      false)))", "user": "5b044436e4b0cc2b61a3bd71"}, {"problem": 95, "code": "(fn [t]\n  (let [no-falses #(every? (complement false?) %)]\n    (->> t\n         (tree-seq sequential? identity)\n         (filter sequential?) ;; only branches\n         ((fn [branches]\n            (and\n             ;; 3 elements at every branch : branch-root, left, right\n             (every? #(= 3 (count %)) branches)\n             ;; test seems to require no falses; nils are ok\n             (every? no-falses branches)))))))", "user": "5484c3b2e4b0e286459a11a2"}, {"problem": 95, "code": "(fn bt [b]\n  (cond\n    (nil? b) true\n    (and (sequential? b) (= (count b) 3)) (and (not (nil? (first b))) (bt (second b)) (bt (nth b 2)))\n    :else false))", "user": "5f419985e4b0955706451fab"}, {"problem": 95, "code": "(fn istree [t] (cond \n                  (= nil t) true \n                  (and (sequential? t) (= (count t) 3))\n                   (and (istree (nth t 1)) (istree (nth t 2)))\n                    :else false))", "user": "5fedff0ee4b05ac5b16ea1d0"}, {"problem": 95, "code": "(fn tree? [node]\n  (if (false? node)\n    false\n    (if (and (not (nil? node)) (sequential? node) )\n      (let [nodev (into [] node)]\n        (if (not= 3 (count nodev))\n          false\n          (reduce #(if (false? %1) false (tree? %2)) true (rest nodev))\n          )\n        )\n      true))\n  )", "user": "5fee18f2e4b05ac5b16ea1d2"}, {"problem": 95, "code": "#(not (.contains\n   (tree-seq coll?\n     (fn [x]\n       (if\n         (= (count x) 3)\n         x\n         [false]\n         ))\n     %)\n   false))", "user": "50d0d2dde4b00b15ecee9768"}, {"problem": 95, "code": "(fn btree?\n  [x]\n  (or\n    (nil? x)\n    (and\n      (coll? x)\n      (= 3 (count x))\n      (btree? (fnext x))\n      (btree? (last x)))))", "user": "54aec375e4b09f271ff37cf9"}, {"problem": 95, "code": "(fn is-tree? [t]\n  (and (coll? t)\n       (= 3 (count t))\n       (not (coll? (nth t 0)))\n       (or (nil? (nth t 1)) (is-tree? (nth t 1)))\n       (or (nil? (nth t 2)) (is-tree? (nth t 2)))\n       ))", "user": "5fb8fe30e4b03f550f448223"}, {"problem": 95, "code": "(fn solve [input] (and (= (count input) 3)\n                       (every? #(if (coll? %) (solve %) (or % (nil? %))) input)))", "user": "54c13b87e4b0ed20f4ff6f20"}, {"problem": 95, "code": "(fn isBT? [sq]\n  (and\n   (sequential? sq)\n   (= (count sq) 3)\n   (let [l (second sq) r (last sq)]\n     (and\n       (or\n         (nil? l)\n         (isBT? l)\n        )\n       (or\n         (nil? r)\n         (isBT? r)\n        )\n      )\n     )\n   )\n  )", "user": "5fe09d1fe4b05ac5b16ea15b"}, {"problem": 95, "code": "(fn binary-tree? [[value left right :as node]]\n  (and (= (count node) 3)\n    \t(or (nil? left) (and (coll? left) (binary-tree? left)))\n        (or (nil? right) (and (coll? right) (binary-tree? right)))))", "user": "5fef4292e4b05ac5b16ea1d7"}, {"problem": 95, "code": "(fn f [s]\n        (cond\n          (nil? s) true\n          :else\n          (and (coll? s) (= 3 (count s)) (f (second s)) (f (last s)))))", "user": "546c4377e4b00cfc9eacc177"}, {"problem": 95, "code": "(fn tree? [t]\n  (cond\n    (or (seq? t) (vector? t))\n      (and (= 3 (count t)) (every? tree? t))\n    (nil? t) true\n    :else t))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 95, "code": "(fn binary-tree? [s]\n   (cond \n     (nil? s) true\n     (sequential? s) \n     \t(and (= 3 (count s)) (every? binary-tree? (rest s)))))", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 95, "code": ";; normal recur\n;; (fn ff [node]\n;;     (or (nil? node)\n;;         (and (sequential? node)\n;;              (= (count node) 3)\n;;              (ff (second node))\n;;              (ff (last node)))))\n\n;; tail-recur, Breadth First Search, idea by meerwolf's solution\n(fn [x]\n    (letfn [(is-btree? [[current & more :as pool]]\n              (cond\n                (empty? pool) true\n                (nil? current) (recur more)\n                (not (coll? current)) false\n                (not= 3 (count current)) false\n                :else (recur (conj more (second current) (last current)))))]\n      (is-btree? [x])))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 95, "code": "(fn tree? [xs]\n  (let [xs (remove #(= % ()) xs)]\n    (and (= (count xs) 3)\n         (let [sub (nth xs 1)]\n           (or (nil? sub) (and (or (list? sub) (vector? sub)) (tree? sub)))))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 95, "code": "(fn valid?\n  [ls]\n  (odd? (count (filter #(not (false? %)) (flatten ls)))))", "user": "5fe1b893e4b05ac5b16ea16f"}, {"problem": 95, "code": "(fn detect-bi-tree [s]\n\n    ; I do need the tail\n    ; I don't need the tail\n    (let [left (second s)\n          right (second (rest s))]\n      ;; (println \"-----\")\n      ;; (println \"s\" s \", left \" left \", right \" right)\n      ;; (println (count s) (count left) (count right))\n      ;; (println (or (> (count s) 0) (< (count s) 3) (> (count s) 3)))\n      ;; (println (not (or (= (count s) 3) (= (count s) 0))))\n      ;; (println \"-----\")\n      (if (or (and (seq? s) (< (count s) 3)) (some false? s) (not (or (= (count s) 3) (= (count s) 0))))\n        false\n        ; recur\n        ; Need an if statement here\n        ; Don't need an if statement when could it be true then? Ah. res\n        (if (= (count s) 0)\n          true\n          (and (detect-bi-tree left) (detect-bi-tree right))\n          )\n        \n        ) ; let end\n\n  \n  ) ; fn end\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 95, "code": "(fn bt?\n  [t]\n  (cond (nil? t) true\n        (and (sequential? t)\n         (= (count t) 3)\n         (bt? (second t))\n         (not (nil? (first t)))\n         (bt? (nth t 2))) true\n        :else false))", "user": "5f5e166ce4b02876ed9fcfed"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "59f192e0e4b0966464fe6a5e"}, {"problem": 95, "code": "(fn ff [[a b c :as coll]]\n   (boolean (and a\n        (= 3 (count coll))\n        (or (nil? b) (and (sequential? b) (ff b)))\n        (or (nil? c) (and (sequential? c) (ff c))))))", "user": "5c30da5ae4b0d62ef62d9f23"}, {"problem": 95, "code": "(fn [tree]\n  (->> tree\n       (tree-seq coll? identity)\n       (filter coll?)\n       (every? #(and (= (count %) 3) (not (some false? %))))\n   )\n)", "user": "6004c750e4b074f607df6645"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "5e42602ae4b01d43a70e8e63"}, {"problem": 95, "code": "(fn is-binary-tree?\n  [node]\n  (and (coll? node)\n       (= 3 (count node))\n       (let [[val left right] node]\n         (and (not (nil? val))\n              (or (nil? left) (is-binary-tree? left))\n              (or (nil? right) (is-binary-tree? right))))))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 95, "code": "(fn istree? [root]\n  (or \n   (nil? root)\n   (and \n     (sequential? root)\n     (= 3 (count root))\n     (every? istree? (rest root))\n    )\n  )\n)", "user": "6001460ce4b074f607df6611"}, {"problem": 95, "code": "(fn bin-tree? [se]\n  (and\n   (sequential? se)\n   (= 3 (count se))\n   (let [left (second se) right (last se)]\n     (and\n      (or (= left nil) (bin-tree? left))\n      (or (= right nil) (bin-tree? right))))))", "user": "5fbf6fe7e4b0ad6fc3476147"}, {"problem": 95, "code": "(fn isb [tree]\n  (let [val   (first tree)\n        left  (second tree)\n        right (nth tree 2 -1)]\n    (println val)\n    (println left)\n    (println right)\n    (if (= (count tree) 3)\n      (if (not= -1 right)\n        (if val\n          (if (and (nil? left)\n                   (nil? right))\n            true\n            (let [l (if (coll? left)\n                      (isb left)\n                      (if (nil? left)\n                        true\n                        false))\n                  r (if (coll? right)\n                      (isb right)\n                      (if (nil? right)\n                        true\n                        false))]\n              (println l r)\n              (and l r)))\n          false)\n        false)\n      false)))", "user": "5ff8ead1e4b06df49cee14ab"}, {"problem": 95, "code": "(fn foo [x]\n    (if (nil? x)\n        true\n        (if-not (sequential? x)\n            false\n            (if-not (= (count x) 3)\n                false\n                (boolean (and (foo (nth x 1)) (foo (nth x 2))))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 95, "code": "(fn binary?\n  [col]\n  (if (not (and (coll? col) (= (count col) 3)))\n    false\n    (let [left (second col)\n          right (nth col 2)\n          checkf (fn [lr] (or (nil? lr) (binary? lr)))]\n      (and\n       (checkf left)\n       (checkf right)))))", "user": "5da7176ae4b000c986472c13"}, {"problem": 95, "code": "(fn t? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (every? t? (rest t)))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 95, "code": "(fn tt [n]\n  (letfn [(b? [n] (or (coll? n) (nil? n)))\n         (t? [n]\n          (if (not= (count n) 3)\n            false\n            (let [[a b c] n]\n              (if (and (b? b) (b? c))\n                (if (coll? b)\n                  (t? b)\n                  (if (coll? c)\n                    (t? c)\n                    true))\n                false))))]\n    (t? n)))", "user": "583369e6e4b089d5ab817c9c"}, {"problem": 95, "code": "(fn binary-tree? [coll]\n  (if (coll? coll)\n    (and\n     (= (count coll) 3)\n     (binary-tree? (second coll))\n     (binary-tree? (last coll)))\n    (nil? coll)))", "user": "5a3e1243e4b0447ef91cc5ae"}, {"problem": 95, "code": "(fn tree [root]\n  (if (= 3 (count root))\n    (let [snd (second root)\n          trd (nth root 2)]\n      \t\t(and \n              (or (nil? snd) (if (sequential? snd) (tree snd) false))\n              (or (nil? trd) (if (sequential? trd) (tree trd) false))\n            )              \n     )\n    false\n  )\n )", "user": "6011b89ee4b074f607df66bc"}, {"problem": 95, "code": "(fn tree? [xs]\n  (or (nil? xs)\n      (and (sequential? xs)\n           (= 3 (count xs))\n           (tree? (second xs))\n           (tree? (nth xs 2)))))", "user": "57e10705e4b0bfb2137f5a6a"}, {"problem": 95, "code": "(fn tree? [maybe-tree]\n  (and\n   \t(or (vector? maybe-tree)\n        (seq?\t maybe-tree))\n    (= (count maybe-tree) 3)\n    (or (tree? (second maybe-tree))\n        (nil?  (second maybe-tree)))\n    (or (tree? (last   maybe-tree))\n        (nil?  (last   maybe-tree)))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 95, "code": "(fn check [t]\n  (cond\n   (nil? t) true\n   (and (coll? t)\n        (= (count t) 3)) (and (check (second t))\n                         (check (nth t 2)))\n   :else false))", "user": "60096aabe4b074f607df667f"}, {"problem": 95, "code": "(fn is-bintree [tree]\n  (cond (and (sequential? tree) (not= (count tree) 3)) false\n        (and (not (sequential? tree)) (not (nil? tree))) false\n        (and (not (sequential? tree)) (nil? tree)) true\n        :else (let [value (first tree)\n                    left-child (nth tree 1)\n                    right-child (nth tree 2)]\n                (and (is-bintree left-child) (is-bintree right-child)))))", "user": "60228147e4b0d5df2af22202"}, {"problem": 95, "code": "(fn t? \n  [r]\n  (or (nil? r)\n      (and (sequential? r)\n           (= 3 (count r))\n           (every? t? (rest r)))))", "user": "4e38f245535deb9a81d77f3e"}, {"problem": 95, "code": "(fn tree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? tree? (rest root)))))", "user": "601c39eee4b0bf4ca6b10937"}, {"problem": 95, "code": "(fn is-valid-tuple\n   [coll]\n   (letfn [\n           (is-invalid-node? [n]\n             (cond \n               (coll? n) (not (is-valid-tuple n))\n               (false? n) true\n               :else false\n             )\n           )\n           ]\n        (if (and\n           (= 3 (count coll))\n           (not (some is-invalid-node? coll)))\n       true\n       false\n     ))\n  )", "user": "6024544be4b0d5df2af2221f"}, {"problem": 95, "code": "(fn istree [szn]\n  (if (= false szn) false\n  (or (= nil szn)\n      (and (= (count szn) 3)\n           (istree (nth szn 1))\n           (istree (nth szn 2))))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (let [[v a b & _] t]\n    (cond\n      (not (< 2 (count t) 4))\n        false\n      (and a b)\n        (and (binary-tree? a) (binary-tree? b))\n      a\n        (and (binary-tree? a) (nil? b))\n      b\n        (and (binary-tree? b) (nil? a))\n      :else\n        (and (nil? a) (nil? b)))))", "user": "601004d6e4b074f607df66b2"}, {"problem": 95, "code": "(fn tree? [t]\n  (let [[val left right] t\n        treeornil? (fn [b] (if (nil? b)\n                             true\n                             (and (coll? b) (tree? b))))]\n    (and\n     (= 3 (count t))\n     (treeornil? left)\n     (treeornil? right))))", "user": "55a65872e4b09e57187da299"}, {"problem": 95, "code": "(fn binaryTree? [sq]\n   (cond\n     (or (not= 3 (count sq)) (some false? sq)) false\n     (and (= 3 (count sq)) (empty? (filter sequential? sq))) true\n     :else (every? true? (map binaryTree? (filter sequential? sq))))\n   )", "user": "602b90c1e4b0d5df2af22266"}, {"problem": 95, "code": "(fn [a]\n  (cond \n   \t(not (sequential? a)) false\n   \t(not= (count a) 3) false\n   \t(sequential? (second a)) (recur (second a))\n   \t(sequential? (last a)) (recur (last a))\n\t(not-every? nil? (rest a)) false\n   \t:else true))", "user": "602d5eade4b0d5df2af22279"}, {"problem": 95, "code": "(fn binary? [tree]\n  (and\n    (sequential? tree)\n    (= 3 (count tree))\n    (let [left (second tree)\n          right (last tree)]\n      (and\n        (or\n          (nil? left)\n          (binary? left))\n        (or\n          (nil? right)\n          (binary? right))))))", "user": "602372aae4b0d5df2af2220f"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5fd361f2e4b07e53c2f3f04e"}, {"problem": 95, "code": "(fn check [tree]\n  (cond\n    (nil? tree)\n    true\n   \t(-> tree coll? not)\n   \tfalse\n    (= (count tree) 3)\n    (let [[_ lc rc] tree]\n      (and (check lc) (check rc)))\n    :else\n    false))", "user": "6026737ee4b0d5df2af2222f"}, {"problem": 95, "code": "(fn tree? [l] \n   (cond (and (sequential? l) (= 3 (count l)) (or (number? (first l)) (keyword? (first l))))\n         (every? true? (map tree? (rest l)))\n        (and (not (seq? l)) (nil? l))\n         true\n        :else false \n        ))", "user": "5a778224e4b013a48d399761"}, {"problem": 95, "code": "(fn is-tree [s]\n  (if (nil? s)\n    true\n    (if (or (not (sequential? s)) (not= 3 (count s)))\n      false\n      (and (is-tree (second s)) (is-tree (last s)))\n    )\n  )\n)", "user": "60335b35e4b0d5df2af222bf"}, {"problem": 95, "code": "(fn nested-tree [coll]\n        (let [tree (fn tree [coll]\n                     (if (and (= (count coll) 3) \n                              (not (some #(= false %) coll)))\n                       true\n                       false ))\n              ]\n        (cond (empty? coll) false\n              (not (tree coll) ) false\n              (coll? (second coll)) (nested-tree (second coll))\n              (coll? (second (rest coll))) (nested-tree (second (rest coll)))\n              (tree coll) true \n              )\n        ))", "user": "6038b6b4e4b0d5df2af222ef"}, {"problem": 95, "code": "(fn binary? [s]\n  (and\n   (sequential? s)\n   (= (count s) 3)\n   (let [ left (second s)\n         right (last s)]\n     (and\n      (or\n       (nil? left)\n       (binary? left))\n      (or\n       (nil? right)\n       (binary? right))))))", "user": "602cc4d4e4b0d5df2af22274"}, {"problem": 95, "code": "(fn ? [t]\n  (or (nil? t)\n      (and (coll? t)\n           (= 3 (count t))\n           (let [[v L R] t] \n             (and (? L) (? R))))))", "user": "591e0782e4b09b4ee5954c25"}, {"problem": 95, "code": "#(->> % flatten (remove false?) count odd?)", "user": "58c71509e4b021aa9917ed6e"}, {"problem": 95, "code": "(fn ibt [xs]\n  (or\n  (nil? xs)\n  (and\n   (or (list? xs) (vector? xs))\n   (= (count xs) 3)\n   (ibt (second xs))\n   (ibt (nth xs 2))\n  )\n  ))", "user": "6045582fe4b02d28681c77b6"}, {"problem": 95, "code": "(fn tree?\n  [xs]\n  (cond\n    (not (sequential? xs)) false\n    (not (= 3 (count xs))) false\n    :else\n    (let [n1 (nth xs 1)\n          n2 (nth xs 2)]\n      (and (or (nil? n1) (tree? n1))\n           (or (nil? n2) (tree? n2))))))", "user": "5ff64845e4b06df49cee1495"}, {"problem": 95, "code": "(fn tree? [l]\n  (and (coll? l)\n       (= (count l) 3)\n       (let [left (nth l 1)\n             right (nth l 2)]\n         (and (or (= left nil)\n                  (tree? left))\n              (or (= right nil)\n                  (tree? right))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "601bdcb3e4b0bf4ca6b10930"}, {"problem": 95, "code": "(fn tree? [n]\n   (and (coll? n) (= (count n) 3) \n        (let [[_ l r] n] (and (or (nil? l) (tree? l))\n                              (or (nil? r) (tree? r))))))", "user": "6030855de4b0d5df2af222a6"}, {"problem": 95, "code": "(fn is-tree [s]\n    (if (nil? s)\n      true\n      (if (or (not (coll? s)) (not= 3 (count s)))\n        false\n        (and (is-tree (nth s 1)) (is-tree (nth s 2))))))\n\n;; dzholev's solution is rather concise and idiomatic:\n;;(fn tree? [x]\n;;   (or\n;;     (nil? x)\n;;     (and\n;;       (sequential? x)\n;;       (= 3 (count x)) \n;;       (tree? (second x))\n;;       (tree? (last x)))))", "user": "5fb68f09e4b08cb800c85b58"}, {"problem": 95, "code": "(fn is-tree [s] (if (not (sequential? s))\n                    (nil? s)\n                    (and (= (count s) 3) (is-tree(second s)) (is-tree (last s)))))", "user": "604f4be1e4b0b7ec0ac60ace"}, {"problem": 95, "code": "(fn bt? [c] (if (nil? c) true \n              (and \n               (coll? c)\n               (= 3 (count c))\n               (not (nil? (first c)))\n               (bt? (second c))\n               (bt? (last c))) ))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 95, "code": "(fn tree?\n    [x]\n    (cond (empty? x) false\n          (= 3 (count x))\n          (let [[v l r] x]\n            (and (if (coll? v) (tree? v) (not (false? v)))\n                 (if (coll? l) (tree? l) (not (false? l)))\n                 (if (coll? r) (tree? r) (not (false? r)))))\n          :else false))", "user": "6026d2cae4b0d5df2af22232"}, {"problem": 95, "code": "(fn bitree? [s]\n   (and\n    (coll? s)\n    (= 3 (count s))\n    (let [a (first s)]\n      (and (not (nil? a))\n           (not (coll? a))))\n    (let [b (nth s 1)]\n      (or (nil? b)\n          (bitree? b)))\n    (let [c (nth s 2)]\n      (or (nil? c)\n          (bitree? c)))))", "user": "54be7c0de4b0ed20f4ff6eec"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "600eb95de4b074f607df66a6"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n    (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "4e586949535d8a8b8723a292"}, {"problem": 95, "code": "(fn [coll]\n  (every? #(or (nil? %) (and (coll? %) (= 3 (count %))))\n          (tree-seq (complement not) #(drop 1 %) coll)))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 95, "code": "(fn __ [xs]\n  (if (coll? xs)\n    (if (= (count xs) 3)\n      (and (__ (nth xs 1)) (__ (nth xs 2)))\n      false)\n    (nil? xs)))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 95, "code": "(fn [x]\n  (letfn [(is-valid-tree? [tree] (if (and (= (count tree) 3) (is-valid-node? tree 1) (is-valid-node? tree 2)) true false))\n          (is-valid-node? [node index] (let [element (nth node index)] (if (nil? element) true (and (coll? element) (is-valid-tree? element)))))]\n    (is-valid-tree? x)))", "user": "59874ff6e4b021a7a535fea1"}, {"problem": 95, "code": "(fn isbin-tree\n  [seq]\n  (cond\n    (nil? seq) true\n    (not (= 3 (count seq))) false\n    (< (count (filter #(or (sequential? %) (nil? %)) (drop 1 seq))) 2) false\n    :else\n    (and (isbin-tree (last seq)) (isbin-tree (second seq)))\n    )\n  )", "user": "6059d824e4b07e92fa001acf"}, {"problem": 95, "code": "(fn tree-or-not\n  [[first second third :as sequence]]\n  (if (= (count sequence) 3)\n    (cond\n      (coll? first) (tree-or-not first)\n      (coll? second) (tree-or-not second)\n      (coll? third) (tree-or-not third)\n      :else (not (some false? sequence)))\n    false))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 95, "code": "(fn is-binary-tree [node]\n  (or (nil? node)\n      (and (sequential? node)\n          (= (count node) 3)\n          (is-binary-tree (nth node 1))\n          (is-binary-tree (nth node 2)))))", "user": "5edd05bfe4b0c7845d86b0f3"}, {"problem": 95, "code": "(fn is-tree? [coll]\n   (let [c (count coll)\n         colls (filter coll? coll)]\n     (if (some false? coll)\n       false\n       \n  (and (= 3 c) (every? is-tree? colls)))))", "user": "60654263e4b069485764ddc9"}, {"problem": 95, "code": "(fn istree? [root]\n  (or (nil? root)\n      (and (sequential? root)\n           (= 3 (count root))\n           (every? istree? (rest root)))))", "user": "60471241e4b02d28681c77c9"}, {"problem": 95, "code": "(fn isTree? [t]\n (println t)\n  (cond\n    (not= (count t) 3) false\n    (or (not (or (nil? (nth t 1)) (coll? (nth t 1)))) (not (or (nil? (last t)) (coll? (last t))))) false\n    (and (nil? (nth t 1)) (nil? (last t))) true\n    (and (not (nil? (nth t 1))) (nil? (last t))) (isTree? (nth t 1))\n    (and (nil? (nth t 1)) (not (nil? (last t)))) (isTree? (last t))\n    :else (and (isTree? (nth t 1)) (isTree? (last t)))\n    ))", "user": "6065755ee4b069485764ddcc"}, {"problem": 95, "code": "(fn my-is-binary-tree [[val left right :as tree]]\n\n  (and (= 3 (count tree))\n       (not (sequential? val))\n       (or (nil? left)\n           (and (sequential? left) (my-is-binary-tree left)))\n       (or (nil? right)\n           (and (sequential? right) (my-is-binary-tree right)))       \n       )\n)", "user": "5fa6db67e4b0fa27300f3dd2"}, {"problem": 95, "code": "(fn [ntree] (loop [tree ntree]\n               (if (= 3 (count tree))\n                 (if (= nil (second tree))\n                   (if (= nil (last tree))\n                     true\n                     (if (coll? (last tree))\n                       (recur (last tree))\n                       false))\n                   (if (coll? (second tree))\n                     (recur (second tree))\n                     false))\n                 false)))", "user": "606d75f5e4b069485764de13"}, {"problem": 95, "code": ";;; binary tree... \n(fn tree? [x]\n  (cond\n    (or (seq? x) (vector? x))   ;;; revisamos que es porque nos pueden dar ambos \n      (and (= 3 (count x)) ;;; revismaos que sean tres porque es nodo padre, hijo 1 e hijo 2\n           (tree? (nth x 1)) ;;; mandamor a la misma funcion (con ?, porque revisa en estili empty?) con el de la derecha \n           (tree? (nth x 2)) ;;; izquierda\n           )\n    (nil? x) \n   true\n    :else false))", "user": "6075c214e4b069485764de5b"}, {"problem": 95, "code": "(fn solve [[v L R :as tree]]\n  (if (nil? tree)\n    true\n    (if (and (= 3 (count tree))\n             (not (or (nil?  v)\n                      (coll? v))))\n      (and (and (or (nil? L) (coll? L)) (solve L))\n           (and (or (nil? R) (coll? R)) (solve R)))\n      false)))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "60764350e4b069485764de5e"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "606ff89be4b069485764de22"}, {"problem": 95, "code": "#(loop [ts [%]]\n   (if (empty? ts)\n     true\n     (let [[head & tail] ts]\n       (cond (nil? head) (recur tail)\n             (and (coll? head) (= (count head) 3)) (recur (concat tail (rest head)))\n             :else false))))", "user": "606da089e4b069485764de15"}, {"problem": 95, "code": "(fn binaryTree? [a] (cond (or (seq? a) (vector? a)) (and (= 3 (count a)) (binaryTree? (nth a 1)) (binaryTree? (nth a 2)))\n             (nil? a) true :else false))", "user": "6074e088e4b069485764de4d"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "60777335e4b0a637ed78034f"}, {"problem": 95, "code": "(fn f [s]\n  (cond\n    (coll? s) (and (= 3 (count s)) (f (nth s 1)) (f (nth s 2)))\n    (nil? s) true\n    :else \n      false\n      )\n     )", "user": "6074f5ede4b069485764de52"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "607e1d32e4b03d835a6eaeda"}, {"problem": 95, "code": "(fn [x]\n  (letfn [(f [thing]\n             (if (nil? thing)\n               true\n               (and\n                (coll? thing)\n                (= 3 (count thing))\n                (not (nil? (nth thing 0)))\n                (f (nth thing 1))\n                (f (nth thing 2)))))]\n    (f x)))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 95, "code": "(fn [x]\n  (not (even? (count (remove #(= false %) (flatten x))))))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 95, "code": "(fn x [t]\n    (if (nil? t)\n      true\n      (if (and t (= 3 (count t)))\n        (every? identity (map x (rest t)))\n        false)))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 95, "code": "(fn bt2?\n  [[v l r :as coll]]\n  (and (= 3 (count coll))\n    (or (nil? l) (and (coll? l) (bt2? l)))\n    (or (nil? r) (and (coll? r) (bt2? r)))))", "user": "5e218bb7e4b05b4b01516123"}, {"problem": 95, "code": "(fn binary-tree? [[a b c :as tree]]\n    (and (= 3 (count tree))\n         (or (symbol? a) (keyword? a) (number? a))\n         (or (nil? b) (and (coll? b) (binary-tree? b)))\n         (or (nil? c) (and (coll? c) (binary-tree? c)))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 95, "code": "(fn is-tree [tree] (if-let [[v left right] tree]\n                       (if (and (= 3 (count tree)) (or (nil? left) (is-tree left)) (or (nil? right) (is-tree right)))\n                           true\n                           false)\n                     false))", "user": "6074df6fe4b069485764de4b"}, {"problem": 95, "code": "(fn binary? [s]\n  (and\n   (sequential? s)\n   (= (count s) 3)\n   (let [ left (second s)\n         right (last s)]\n     (and\n      (or\n       (nil? left)\n       (binary? left))\n      (or\n       (nil? right)\n       (binary? right))))))", "user": "607dd962e4b03d835a6eaed2"}, {"problem": 95, "code": "(fn tree [lst]\n  (if (nil? lst)\n    true\n    (if (or (not (coll? lst)) (not= 3 (count lst)))\n      false\n       (and (tree (nth lst 1)) (tree (nth lst 2))))))", "user": "6074dfa4e4b069485764de4c"}, {"problem": 95, "code": "(fn isTree [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (isTree (nth coll 1)) (isTree (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "6074e1e4e4b069485764de4f"}, {"problem": 95, "code": "(fn tree? [colle]\n  (cond\n    (or (seq? colle) (vector? colle))\n      (and (= 3 (count colle)) (tree? (nth colle 1)) (tree? (nth colle 2)))\n    (nil? colle) true\n    :else false))", "user": "607e1cf9e4b03d835a6eaed9"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else \n   false))", "user": "6074e1ade4b069485764de4e"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "6086cdefe4b0736b099e4302"}, {"problem": 95, "code": "(fn ToTree [lst]\n  (or \n    (nil? lst)\n    (and (coll? lst) \n         (= 3 (count lst)) \n         (ToTree (nth lst 1)) \n         (ToTree (nth lst 2)))))", "user": "607508f3e4b069485764de54"}, {"problem": 95, "code": "(fn my-tree? [kolekce]\n(if (coll? kolekce)\n  (if (= (count kolekce) 3)\n    (and (my-tree? (first (rest kolekce)))(my-tree? (second (rest kolekce))))\n    false)\n  (if (= kolekce false)\n    false\n    true)))", "user": "5684e200e4b04eec3ec5cfc4"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "608828dee4b0ae75613dcee1"}, {"problem": 95, "code": "(fn binary? [tree]\n  (cond (false? tree) false\n   (not (coll? tree)) true\n   (not= (count tree) 3) false\n   :else (and (binary? (second tree)) (binary? (nth tree 2)))))", "user": "607f3336e4b05857a65e7747"}, {"problem": 95, "code": "(fn tton [liss](cond(or(seq?\n                        liss)\n                       (vector? liss))\n                    (and (= 3 (count liss))(tton\n                                          (nth liss 1))(tton\n                                                        (nth liss 2)))\n                        (nil? liss)true :else false))", "user": "6085edade4b0736b099e42fc"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "6088c22ee4b0ae75613dcee4"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n   (false? coll)\n   false\n   \n   (not (coll? coll))\n   true\n   \n   (not= (count coll) 3)\n   false\n   \n   :else\n   (and (tree? (second coll))(tree? (nth coll 2)))\n   ))", "user": "6074e278e4b069485764de51"}, {"problem": 95, "code": "(fn binary? [tree]\n  (if (sequential? tree)\n    (cond\n     (= (count tree) 3)\n     (let [left (second tree) right (last tree)]\n       (and (or (nil? left) (binary? left)) (or (nil? right) (binary? right)) ))\n     (= (count tree) 1) true\n     :else false\n     )\n    false\n    )\n  )", "user": "60752ef6e4b069485764de55"}, {"problem": 95, "code": "(fn bTree? [n]\n  (if (nil? n) true\n    (if (or (not(coll? n)) (not= 3 (count n))) false\n      (and (bTree? (nth n 1)) (bTree? (nth n 2))))))", "user": "6081b7fce4b0736b099e42d4"}, {"problem": 95, "code": "(fn ans-95 [node]\n  (if (nil? node)\n    true\n    (if (and (coll? node) (= 3 (count node)))\n      (and (ans-95 (second node)) (ans-95 (last node)))\n      false)))", "user": "608fac60e4b03bd49d9f36c7"}, {"problem": 95, "code": "(fn nodecheck [node]\n  (and (sequential? node)\n    (= (count node) 3)\n    (let [this (first node) left (second node) right (last node)]\n      (and \n        ((comp not seq?) this)\n        (or (nil? left) (nodecheck left))\n        (or (nil? right) (nodecheck right))))))", "user": "6088395de4b0ae75613dcee2"}, {"problem": 95, "code": "(fn tree? [l]\n  (if (nil? l)\n    true\n    (if (or (not (sequential? l)) (not= (count l) 3))\n      false\n      (and (not (sequential? (first l))) (tree? (second l)) (tree? (second (rest l)))))))", "user": "60882700e4b0ae75613dcedf"}, {"problem": 95, "code": "(fn is-valid-tree?\n  [v]\n  (or\n    (nil? v)\n    (keyword? v)\n    (number? v)\n    (and\n      (sequential? v)\n      (= 3 (count v))\n      (every? is-valid-tree? v))))", "user": "6098263be4b00e9e6653c3f9"}, {"problem": 95, "code": "(fn binary-tree? [[root left right :as coll]]\n  (and (= (count coll) 3)\n       (not (sequential? root))\n       (every? #(or (nil? %)\n                    (and (sequential? %) (binary-tree? %))) ;; sequential? check could be moved up out of here, but then we couldn't destructure before checking\n               [left right])))", "user": "60794173e4b0a637ed78035d"}, {"problem": 95, "code": "(fn dfs [tree]\n  (cond\n    (nil? tree) true\n    (not (instance? clojure.lang.Seqable tree))  false\n    (even? (count tree)) false\n    :else (and (dfs (second tree)) (dfs (nth tree 2)))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 95, "code": "(fn [l]\n  (let [pred (fn [f l]\n               (= true\n                  (= (count l) 3)\n                  (not= '() (f (rest l)))\n                  (not (false? (f (rest l)))))\n               )]\n    (loop [a l b false]\n      (if (empty? a)\n        b\n        (if (and (true? (pred first a)) (true? (pred second a)))\n          (if (not (nil? (second a)))\n            (recur (second a) true)\n            (recur (second (rest a)) true))\n          false)))))", "user": "58e90258e4b056aecfd47cfd"}, {"problem": 95, "code": "(fn binary-tree? [x]\n  (if (coll? x)\n    (if (= 3 (count x))\n      (every? true? (map binary-tree? x))\n      false)\n    (not (false? x))#_(\"have to be: true\")))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 95, "code": "(fn tree? [items]\n  (cond \n   (nil? items) true\n   (not (coll? items)) false\n   (not (= 3 (count items))) false\n   :else (every? tree? (rest items))))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 95, "code": "(fn isB-improved?\n  [[root l r :as branch]]\n   (and (= 3 (count branch))\n        (not (coll? root))\n        (or (nil? l) (and (coll? l) (isB-improved? l)))\n        (or (nil? r) (and (coll? r) (isB-improved? r)))\n        ))", "user": "5f6adf5ee4b02876ed9fd049"}, {"problem": 95, "code": "(fn binary? [s]\n  (and\n   (sequential? s)\n   (= (count s) 3)\n   (let [ left (second s)\n         right (last s)]\n     (and\n      (or\n       (nil? left)\n       (binary? left))\n      (or\n       (nil? right)\n       (binary? right))))))", "user": "60b8b0f8e4b0e0fa5f1b425c"}, {"problem": 95, "code": "(fn [t]\n  (letfn [(is-tree [t]\n                   (if (or (not (coll? t)) (not (= 3 (count t))))\n                     false\n                     (let [[v lc rc] t]\n                       (and (or (nil? lc) (is-tree lc)) (or (nil? rc) (is-tree rc))))))]\n    (is-tree t)))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 95, "code": "(fn btree? [tree]\n  (cond\n    (coll? (first tree))\n    false\n    (or (false? (second tree))\n        (false? (last tree)))\n    false\n    (not= (count tree) 3)\n    false\n    :else (and\n           (or\n            (not (coll? (second tree)))\n            (btree? (second tree)))\n           (or\n            (not (coll? (last tree)))\n            (btree? (last tree))))))", "user": "609e9b64e4b00e9e6653c426"}, {"problem": 95, "code": "(fn tree? [x]\n  (or (nil? x)\n      (and (sequential? x)\n           (= 3 (count x))\n           (every? tree? (rest x)))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 95, "code": "(fn tree? [[root left right :as tree]]\n  (let [num-children (count (rest tree))]\n    (if (empty? tree) \n      false\n      (if (nil? root) \n      \ttrue \n     \t (and \n       \t \t(= 2 num-children) \n          \t (and \n       \t \t  (if (coll? left) (tree? left) (nil? left))\n        \t  \t(if (coll? right) (tree? right) (nil? right))))))))", "user": "60b3b8a9e4b0e0fa5f1b4233"}, {"problem": 95, "code": "(fn tree? [xs]\n  (first (flatten (clojure.walk/walk (fn [x]\n                                       (cond\n                                         (and (sequential? x)\n                                              (= 3 (count x))) (tree? x)\n                                         (sequential? x) false\n                                         (nil? x) true\n                                         (= false x) false\n                                         :else true))\n                                     (fn [x]\n                                       [(and (sequential? x)\n                                             (= 3 (count x))\n                                             (every? identity (flatten x)))]) xs))))", "user": "51bd78c3e4b0ff155d51d2b0"}, {"problem": 95, "code": "(fn bin-tree? [coll]\n  (if (= 3 (count coll))\n    (every? #(or (nil? %)\n                 (and (sequential? %)\n                      (bin-tree? %)))\n            (rest coll))\n    false))", "user": "60c0ceb7e4b0e0fa5f1b42a6"}, {"problem": 95, "code": "(fn binary-tree? [[head left right :as node]]\n  (println \"H: \" head)\n  (println \"L: \" left)\n  (println \"R: \" right)\n  (cond\n    (coll? head) false\n    (not= (count node) 3) false\n    (instance? Boolean left) false\n    (instance? Boolean right) false\n    (coll? left) (binary-tree? left)\n    (coll? right) (binary-tree? right)\n    :else true))", "user": "60c91f48e4b0e0fa5f1b4304"}, {"problem": 95, "code": "(fn tree? [coll]\n  (cond\n    (or (seq? coll) (vector? coll))\n      (and (= 3 (count coll)) (tree? (nth coll 1)) (tree? (nth coll 2)))\n    (nil? coll) true\n    :else false))", "user": "5aba04dce4b073f17744269e"}, {"problem": 95, "code": "(fn bt? [[n c1 c2 & t :as l]]\n        (and (not (nil? n))\n             (or (nil? c1) (and (coll? c1) (bt? c1)))\n             (or (nil? c2) (and (coll? c2) (bt? c2)))\n             (empty? t)\n             (= 3 (count l))))", "user": "5e3d183fe4b01d43a70e8e11"}, {"problem": 95, "code": "(fn binary-tree? [t]\n  (or\n    (nil? t)\n    (and\n      (coll? t)\n      (= (count t) 3)\n      (every? binary-tree? (rest t)))))", "user": "4fe49706e4b0e8f79898feb7"}]