[{"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "#(fn [b]\n   ((fn m [x]\n      (if (seq? x)\n        (apply ({'+ + '- - '* * '/ /} (nth x 0)) (map m (rest x)))\n        (b x x)))\n    %))", "problem": 121, "user": "4e52d815535d302ef430da77"}, {"code": "(fn\n  [formula]\n  (fn [val-map]\n    (letfn [(execute [form]\n              (if (seq? form)\n                (let [[op-sym & args] form\n                      op ({'+ + '- - '/ / '* *} op-sym)]\n                  (apply op (map execute args)))\n                (val-map form form)))]\n      (execute formula))))", "problem": 121, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn [expr]\r\n  (letfn [(apply-e [expr]\r\n  \t   (let [op (first expr)\r\n\t\t\t args (rest expr)\r\n\t\t\t ops {'+ + '- - '* * '/ /}]\r\n\t\t     (fn [env] (apply (ops op)\r\n\t\t\t\t      (map #(% env)\r\n\t\t\t\t\t   (map eval-e args))))))\r\n\t  (eval-e [expr]\r\n\t\t  (cond (sequential? expr) (apply-e expr)\r\n\t\t\t(symbol? expr) (fn [env] (env expr))\r\n\t\t\t:else (fn [_] expr)))]\r\n    (fn [env]\r\n      ((apply-e expr) env))))", "problem": 121, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "4dd4034a535dae65d5c462df"}, {"code": "(fn [expr]\r\n  (fn [env] \r\n    (letfn [ (ev [x] (if (coll? x) \r\n                      (apply ({'+ + '* * '- - '/ /} (first x)) (map ev (rest x)))      \r\n                      (or (env x) (Integer/valueOf (str x)))))]\r\n      (ev expr)\r\n      )\r\n))", "problem": 121, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn _ [f]\r\n  (fn [l]\r\n    (let [r #(if (seq? %)\r\n                 ((_ %) l)\r\n                 (get l % %))\r\n          o {'/ / '* * '+ + '- -}]\r\n      (apply (o (first f))\r\n             (map r (rest f))))))", "problem": 121, "user": "4db4714f535dc0f10411755a"}, {"code": "(let [ops {'+ + '- - '* * '/ /}\n      uce (fn uce [form vars]\n            (cond\n              (number? form) form\n              (symbol? form) (vars form)\n              true (let [[op & forms] form]\n                     (apply (op ops)\n                            (map #(uce % vars) forms)))))]\n  #(partial uce %))", "problem": 121, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [x]\n  (fn [m] ((fn e [x m]\n    (if (seq? x)\n      (apply ({'+ + '- - '* * '/ /} (first x))\n             (map #(e % m) (rest x)))\n      (m x x)))\n    x m)))", "problem": 121, "user": "4db858d1535d1e037afb218c"}, {"code": "#(fn [v]\r\n  ((fn r [x]\r\n     (if (seq? x)\r\n       (apply ({'+ + '- - '* *} (nth x 0) /) (map r (rest x)))\r\n       (v x x)))\r\n   %))", "problem": 121, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn x [[f & a]]\r\n  (fn [e] \r\n    (apply ({'+ + '/ / '- - '* *} f)\r\n      (map \r\n        #(if \r\n           (seq? %) ((x %) e)\r\n           (e % %))\r\n        a))))", "problem": 121, "user": "4e707db6535d5021c1a8963a"}, {"code": "(letfn [\r\n  (nested-replace [smap coll]\r\n\t\t(if-let [[x & xs] (seq coll)]\r\n\t\t\t(if (coll? x)\r\n\t\t\t\t(cons (nested-replace smap x) (nested-replace smap xs))\r\n\t\t\t\t(cons (get smap x x)          (nested-replace smap xs)))))\r\n\t(eval-expr [formula]\r\n\t\t(if (number? formula)\r\n\t\t\tformula\r\n\t\t\t(let [[op & args] formula]\r\n\t\t\t\t(cond\r\n\t\t\t\t\t(= op '+) (apply + (map eval-expr args))\r\n\t\t\t\t\t(= op '-) (apply - (map eval-expr args))\r\n\t\t\t\t\t(= op '*) (apply * (map eval-expr args))\r\n\t\t\t\t\t(= op '/) (apply / (map eval-expr args))))))]\r\n\r\n(fn compute [formula]\r\n\t(fn [bindings]\r\n\t\t(eval-expr (nested-replace bindings formula)))))", "problem": 121, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [computation]\n  (let [operators {'/ / '+ + '- - '* *}]\n    (partial\n     (fn compute [computation bindings]\n       (apply (get operators (first computation))\n              (map\n               (fn [x]\n                 (condp #(%1 %2) x\n                   coll? (compute x bindings)\n                   symbol? (get bindings x) \n                   number? x))\n               (rest computation))))\n     computation)))", "problem": 121, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn b [c]\n  (fn [m]\n    (apply (fn [f & a] (apply f a))\n           (map #(if (seq? %) ((b %) m) %)\n            (replace (into m {'+ + '- - '/ / '* *}) c)))))", "problem": 121, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn f [s]\r\n  (fn [m]\r\n    (apply (condp = (first s) '+ + '- - '* * '/ /)\r\n           (map #(cond (list? %) ((f %) m)\r\n                       (symbol? %) (m %)\r\n                       true %)\r\n                (rest s)))))", "problem": 121, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn z [f]\n  (cond (number? f) (fn [x] f)\n        (symbol? f) (fn [e] (e f))\n        1 (fn [e]\n            (apply ({'- - '+ + '/ / '* *} (first f))\n                   (map #((z %) e) (rest f))))))", "problem": 121, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn f [c]\n  (fn [b]\n    (if (seq? c)\n     (let [[x & y] c]\n      (apply ({'* * '/ / '+ + '- -} x)\n             (map #((f %) b) y)\n))\n      (if-let [a (b c)]\n          a\n          c)\n    )))", "problem": 121, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn __\n  [e]\n  (fn [x]\n    (let [y (drop 1 (map #(cond\n           (number? %) %\n           (coll? %) ((__ %) x)\n           ;; Probleme mit quoting, daher workaround\n           ;; (fn? (eval %)) wuerde funktionieren, aber\n           ;; dann kommt ein Fehler, da (eval 'a) nicht geht\n           (> (int (.charAt (str %) 0)) (+ (int 9) (int \\0))) (get x %)\n           true %) e))\n          z (first e)]\n      (cond\n       (= \"/\" (str z)) (apply / y)\n       (= \"*\" (str z)) (apply * y)\n       (= \"+\" (str z)) (apply + y)\n       (= \"-\" (str z)) (apply - y)))))", "problem": 121, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn ev [exp]\n  (fn [env]\n    (cond\n      (number? exp) exp\n      (symbol? exp) (env exp)\n      :else\n        (let [args (map #((ev %) env) (rest exp))]\n          (apply ({'+ + '- - '* * '/ /}\n                    (first exp))\n            args)))))", "problem": 121, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [formula]\n  (let [operators {'+ + '- - '* * '/ /}]\n    (letfn [(parse [form]\n              (cond (symbol? form) (fn [variables] (variables form))\n                    (number? form) (fn [_] form)\n                    (coll? form) (let [arguments (map parse (rest form))]\n                                   (fn [variables]\n                                     (apply (operators (first form))\n                                            (map #(% variables) arguments))))))]\n      (parse formula))))", "problem": 121, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [expr]\n  (letfn [(token-type[tok]\n                   (cond\n                     (nil? tok) nil\n                     (= \"/\" tok) :division\n                     (= \"*\" tok) :multiplication\n                     (= \"+\" tok) :addition\n                     (= \"-\" tok) :subtraction\n                     (= \"(\" tok) :open-bracket\n                     (= \")\" tok) :close-bracket\n                     (re-find #\"\\s\" tok) :whitespace\n                     (re-find #\"\\d+\" tok) :number\n                     :else :symbol))\n          (read-token[[token a-str]]\n            (let [curr (str (first a-str))\n                  next-str (apply str (next a-str))\n                  tt (token-type curr)\n                  prev-tt (token-type (last token))]\n              (cond\n                (empty? next-str) [(concat token (list curr)) next-str]\n                (= tt :number)\n                    (if (= prev-tt :number)\n                      [(concat (butlast token) (list (str (last token) curr))) next-str]\n                      [(concat token (list curr)) next-str])\n                (= tt :symbol)\n                  (if (= prev-tt :symbol)\n                    [(concat (butlast token) (list (str (last token) curr))) next-str]\n                    [(concat token (list curr)) next-str])\n                :else [(concat token (list curr)) next-str])))\n          (tokenize[expr]\n            (filter #(not (re-find #\"\\s\" % ))\n                    (ffirst (take 1 (drop-while #(not (empty? (second %)))\n                                    (iterate read-token ['() (str expr)]))))))\n          (operation[a-str]\n                    (cond\n                      (= \"/\" a-str) /\n                      (= \"+\" a-str) +\n                      (= \"*\" a-str) *\n                      (= \"-\" a-str) -\n                      :else nil))\n          (evals-not-bad-stupid[tokens a-map]\n            (let [op (operation (fnext tokens))]\n              (loop [sub-tokens (drop 2 tokens)\n                     args []]\n                (cond\n                  (= :close-bracket (token-type (first sub-tokens)))\n                    [(+ 3 (count args)) (apply op args)]\n                  \n                  (= :open-bracket (token-type (first sub-tokens)))\n                    (let [[consumed value] (evals-not-bad-stupid sub-tokens a-map)]\n                      (recur (drop consumed sub-tokens)\n                             (conj args value))) \n                  \n                  (re-find #\"\\d+\" (first sub-tokens))\n                    (recur (next sub-tokens)\n                           (conj args (Integer/parseInt (first sub-tokens))))\n                  \n                  (re-find #\"\\w+\" (first sub-tokens))\n                    (recur (next sub-tokens)\n                           (conj args (a-map (symbol (first sub-tokens)))))))))]\n         (let [tokens (tokenize expr)]\n           (fn [a-map] (second (evals-not-bad-stupid tokens a-map))))))", "problem": 121, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn [formula]\n  (let [math {(quote /) /\n              (quote +) +\n              (quote -) -\n              (quote *) *}]\n    (fn evil\n      ([m] (evil m formula))\n      ([m exp]\n        (let [[op & arglist] exp\n              args (map #(or (m %) %) arglist)]\n          (apply (math op)\n                 (map #(if (seq? %) (evil m %) %) args))\n        )\n      )\n    )\n  )\n)", "problem": 121, "user": "4e720985535d5021c1a89655"}, {"code": "(fn [s] \n  (fn [m] \n    (let [o {'/ / '* * '+ + '- -}\n          _   (fn f [x]\n                (if (seq? x)\n                  (apply \n                    (o (first x))\n                    (map f (rest x)))\n                  (m x x)))]\n      (_ s))))", "problem": 121, "user": "4db85282535d1e037afb218a"}, {"code": "(fn uce [formula]\n  (fn [vals]\n    ((fn compute [x]\n        (if (seq? x)\n          (let [[op & args] x]\n            (apply ({'+ + '- - '/ / '* *} op)\n                   (map compute args)))\n          (vals x x)))\n      formula)))", "problem": 121, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn [expr] (fn [vars]\n  (let [syms {'+ +, '- -, '* *, '/ /}]\n    (letfn [(my-eval [vars expr]\n      (cond (seq? expr)\n        (apply (syms (first expr)) (map (partial my-eval vars) (rest expr)))\n        (symbol? expr) (vars expr)\n        :else expr))]\n      (my-eval vars expr)))))", "problem": 121, "user": "4db3a0e5535df7e46ed9b6d0"}, {"code": "(fn [x] (fn [e] ((fn ev [x] (cond (symbol? x) (e x)\n                                  (seq? x) (apply ({'+ + '- - '* * '/ /} (first x))\n                                                  (map ev (rest x)))\n                                  :else x))\n                 x)))", "problem": 121, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [coll]\n  (let [ffs (assoc {}  '/  / '+ + '- - '* *)]\n    (fn [params]\n      ((fn mrecur [coll]\n         (let [cur (first coll)]\n      \t   (cond\n      \t    (number? cur) (conj (mrecur (next coll)) cur)\n      \t    (contains? params cur) (conj (mrecur (next coll))(get params cur))\n      \t    (contains?    ffs cur) (apply (get ffs cur)  (mrecur (next coll)))\n      \t    (coll? cur) (concat (list (mrecur cur))(mrecur (next coll))))))coll))))", "problem": 121, "user": "4e739e13535dff18050a9c76"}, {"code": "(letfn [(e [x v] \n  (cond \n    (list? x)\n    (apply \n      ({'/ / '* * '+ + '- -} (first x)) \n      (map #(e % v) (rest x)))\n    (number? x) x\n    1 (v x)))]\n  #(partial e %))", "problem": 121, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [e]\n  (letfn [\n    (subs [v l]\n      (cond (not (coll? l)) (if-let [t (v l)] t l)\n            :else (map (partial subs v) l)))\n    (val [[op & args]]\n      (apply (condp = op '* * '/ / '+ + '- -) (map #(if (coll? %) (val %) %) args)))]\n  (fn [v] (val (subs v e)))))", "problem": 121, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [e] \n  (fn [var-map] \n    (let [\n       value-of #(map \n                 (fn [f] (if (seq? f) \n                             (%2 f) \n                              f))   \n                  %)\n       compute (fn compute [[operator & operands]]\n              (apply \n                 ({'/ / '+ + '* * '- -} operator) \n                 (value-of (replace var-map operands) compute)))]\n  (compute e))))", "problem": 121, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [sexp]\n  (letfn [(parse [sexp bindmap]\n   (for [s sexp]\n       (cond \n         (= s '/) '/\n         (= s '+) '+\n         (= s '-) '-\n         (= s '*) '*\n         (number? s) s\n         (list? s) (parse s bindmap)\n         :else (bindmap s))))\n         (evil [sexp] \n              (cond\n                 (number? sexp) sexp\n                 (seq? sexp) (let [op (first sexp)]\n  \t\t\t   (cond \n\t\t\t\t  \t (= op '*) (apply * (map evil (rest sexp)))\n                     (= op '+) (apply + (map evil (rest sexp)))\n\t\t\t\t\t (= op '/) (/ (evil (nth sexp 1))(evil (nth sexp 2)))\n                     (= op '-) (- (evil (nth sexp 1))(evil (nth sexp 2)))\n\t\t\t\t\t :else (prn :op op :unknown)))\n                 :else (prn :sexp sexp :unknown)))\n         (parseval [sexp bindmap] (evil (parse sexp bindmap)))]\n    (partial parseval sexp)))", "problem": 121, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [form]\n  (fn [m]\n    ((fn r [x]\n       (cond\n        (seq? x) (apply ({'+ + '- - '* * '/ /} (first x)) (map r (rest x)))\n        (symbol? x) (m x)               ; could coerce to (m x x)\n        :t x))\n     form)))", "problem": 121, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn get-computer [formula]\n    (fn compute\n      ([params] (compute formula params))\n      ([calc params]\n         (cond\n          (sequential? calc) (let [vals (map #(compute % params) (rest calc))\n                                   ops {'/ / '* * '+ + '- -}]\n                               (apply (ops (first calc)) vals))\n          (symbol? calc) (get params calc)\n          true calc)\n         )))", "problem": 121, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn f[s]\n    (fn g [m] \n       (let [ ops {'/ / '+ + '- - '* *}\n              run   (fn h [x] (cond\n                               (sequential? x) (apply (ops (first x)) (map h (rest x)))\n                               (symbol? x)     (m x)\n                               :else           x)) ]\n          (run s))))", "problem": 121, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn [e] #((clojure.lang.Compiler/maybeResolveIn *ns* (symbol \"eval\")) `(let [~@(flatten (seq %))] ~e)))", "problem": 121, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn [a]\n             (fn [b]\n               (let [parse-sq\n                     (fn parse-sq [x]\n                       (cond (number? x)  x\n                             (symbol? x) (b x)\n                             :else\n                             (let [op (first x)\n                                   exp-sq (map parse-sq (rest x))]\n                               (cond (= op '*) (apply * exp-sq) \n                                     (= op '/) (apply / exp-sq)\n                                     (= op '-) (apply - exp-sq)\n                                     (= op '+) (apply + exp-sq)))))]\n                 (parse-sq a)\n                 )))", "problem": 121, "user": "4dcc5aff535d5973398f9293"}, {"code": "(fn e [eq]\n  (fn [m]\n    (let [rslv {'+ + '- - '* * '/ /}]\n      (cond (coll? eq) (apply (rslv (first eq)) (map #((e %) m) (rest eq)))\n            (symbol? eq) (m eq)\n            :else eq))))", "problem": 121, "user": "4ea09fa4535d7eef308072aa"}, {"code": "(fn uce\r\n  [expr]\r\n\t(fn [val-map]\r\n\t\t(letfn [(compute [expr]\r\n\t\t\t\t\t\t\t(if (sequential? expr)\r\n\t\t\t\t\t\t\t\t(apply (first expr) (map compute (rest expr)))\r\n\t\t\t\t\t\t\t\texpr))\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t(fill-in [expr, values-map] \r\n\t\t\t\t\t\t\t(for [s expr] (if (seq? s) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(fill-in s, values-map) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if-not (number? s) (s values-map) s))))]\r\n\r\n\t\t\t(let [val-map (conj val-map {'/ /, '* *, '+ +, '- -})\r\n\t\t\t\t\t\ts-expr (fill-in expr val-map)]\r\n\t\t\t\t(println s-expr)\r\n\t\t\t\t(compute s-expr)))))", "problem": 121, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [x]\n  (fn [m]\n    ((fn f [x]\n       (cond\n        (coll? x) (apply ({'+ + '- - '* * '/ /} (first x))\n                         (map f (rest x)))\n        (symbol? x) (m x)\n        :else x)) x)))", "problem": 121, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn eval-expr [[op & args]]\n        (fn [m]\n          (let [ops {'+ +, '- -, '* *, '/ /}]\n            (apply (ops op) (map #(cond\n                                   (symbol? %) (m %)\n                                   (sequential? %) ((eval-expr %) m)\n                                   :else %)\n                                 args)))))", "problem": 121, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn uce [l]\n  (fn [m]\n    (letfn [(r [e]\n      (let [os {'+ + '- - '* * '/ /}\n            f (os (first e))]\n        (loop [args [] t (rest e)]\n          (if (empty? t)\n            (apply f args)\n            (cond\n              (coll? (first t))\n                (recur (conj args (r (first t))) (rest t))\n              (number? (first t))\n                (recur (conj args (first t)) (rest t))\n              :else\n                (recur (conj args (m (first t))) (rest t)))))))]\n      (r l))))", "problem": 121, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [formula] (fn [ma]\n  (let [mb {'/ /, '* *, '+ +, '- -}]\n    (letfn [(swap [s] (replace ma (replace mb s)))]\n      ((fn exec [coll]\n        (let [coll (swap coll)]\n          (apply (first coll)\n            (map #(if (sequential? %) (exec %) %) (rest coll)))\n        )) formula))\n)))", "problem": 121, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "(fn parse [formula]\r\n  (fn [h]\r\n    (let [op {'+ + '- - '* * '/ /}]\r\n      ((fn my-eval [form]\r\n        (if (seq? form)\r\n          (apply (op (first form)) (map my-eval (rest form)))\r\n          (h form form)))\r\n       formula))))", "problem": 121, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn s [[o & p]]\n  (fn [m]\n      (apply ({'+ + '/ / '- - '* *} o)\n        (map #(if\n                (seq? %) ((s %) m)\n                (get m % %)) \n              p))))", "problem": 121, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn e [f]\n  (fn [v]\n    (clojure.walk/postwalk\n     #(if (seq? %)\n        (apply (first %) (rest %))\n        ((assoc v '+ + '- - '* * '/ /) % %))\n     f)))", "problem": 121, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn f [e]\n    (cond\n      (list? e)\n        (fn [env] \n            (apply \n              ({'/ /, '+ +, '- - '* *} (first e)) \n              (map #((f %) env) (rest e))))\n      (symbol? e) #(% e)\n      :else (fn [env] e)))", "problem": 121, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn tmp [l] \n  (fn [m] \n    (let [f {'/ / '* * '+ + '- -}\n          r (map #(cond \n                    (coll? %1) ((tmp %1) m) \n                    (m %1) (m %1) \n                    :else %1) l) \n          [x & y] r] (apply (f x) y))))", "problem": 121, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn f [e] (cond (symbol? e) #(% e) (number? e) (constantly e) true #(apply ({'+ + '- - '* * '/ /} (first e)) (map (fn [t] ((f t) %)) (rest e)))))", "problem": 121, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn parse [exp]\n  (let [ops { '+ +, '- -, '* *, '/ / }]\n    (cond\n      (list? exp)\n        (let [[op & exps] exp\n              fns (map parse exps)]\n          (fn [env]\n            (apply (ops op) (map #(% env) fns))))\n      (symbol? exp)\n        (fn [env]\n          (env exp))\n      :else\n        (constantly exp))))", "problem": 121, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn c [l] (fn [m] (if (seq? l) \n                    (apply ({'+ + '- - '* * '/ /} (nth l 0)) (map #((c %) m) (rest l)))\n                    (m l l))))", "problem": 121, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn e [f]\r\n  (fn [v]\r\n    (apply ({ '+ + '- - '* * '/ / } (first f))\r\n      (map\r\n        (fn [t]\r\n          (if (seq? t)\r\n            ((e t) v)\r\n            (v t t)))\r\n        (rest f)))))", "problem": 121, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "#(fn [v]\n  ((fn c [e]\n    (if (seq? e)\n      (let [[o & p] e]\n        (apply ({'+ + '- - '* * '/ /} o)\n          (map c p)))\n      (v e e))) %))", "problem": 121, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [l] (fn [m]\n    (letfn [(expr  [m c]\n\t\t   (if (coll? c) (map #(expr m %) c)\n\t\t       (m c c)))\n\t\t (fun [in] (if (integer? in) in \n(let [mp (map fun (rest in))]\n  (condp = (first in)\n\t\t '+ (apply + mp)\n\t\t '- (apply - mp)\n     '* (apply * mp)\n     '/ (apply / mp)))))]\n\t\t (fun (map #(expr m %) l)))))", "problem": 121, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [formula]\r\n  (fn [values]\r\n    ((fn compute [x]\r\n       (if (seq? x)\r\n         (let [[op & args] x]\r\n           (apply ({'+ + '/ / '- - '* *} op)\r\n                  (map compute args)))\r\n         (get values x x)))\r\n     formula)))", "problem": 121, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(fn uce [ex]\n (let [opers {'+ +, '- -, '* *, '/ /}]\n  (fn [args] \n     (let [resolv #(cond (number? %) % \n                         (sequential? %) ((uce %) args)\n                         :else (args %))\n           f (opers (first ex))\n           params (map resolv (rest ex))] \n      (apply f params)))))", "problem": 121, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(let [procs {'+ + '- - '/ / '* *}]\n  (fn [expr]\n    (letfn\n        [\n         (proc? [exp] (contains? procs exp))\n         (variable? [exp] (symbol? exp))\n         (application? [exp] (seq? exp))\n         (analyze-proc [exp]\n           (let [op (get procs exp)]\n             (fn [env] op)))\n         (analyze-number [n] (fn [env] n))\n         (analyze-variable [v] (fn [env] (get env v)))\n         (operator [exp] (first exp))\n         (operands [exp] (rest exp))\n         (analyze-application [exp]\n           (let [op (analyze (operator exp))\n                 args (map analyze (operands exp))]\n             (fn [env]\n               (apply (op env) (map #(% env) args)))))\n         (analyze [exp]\n           (cond\n            (number? exp) (analyze-number exp)\n            (proc? exp) (analyze-proc exp)\n            (variable? exp) (analyze-variable exp)\n            (application? exp) (analyze-application exp)))]\n      (analyze expr))))", "problem": 121, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn uni [form]\n  (fn [bindings]\n    (let [opmap {'/ / '- - '+ + '* *}]\n    (apply (opmap (first form)) \n      (map (fn [s]\n            (if (coll? s) ((uni s) bindings)\n                (if (symbol? s) (bindings s) s)))\n      (rest form))))))", "problem": 121, "user": "4eb0a757535d7eef3080733d"}, {"code": "( fn p121 [exp]\n     (fn [col]\n       (let [check_symbol (fn [s]\n               (if (symbol? s)\n                   (cond (= (symbol \"/\") s) /\n                        (= (symbol \"+\" ) s) +\n                        (= (symbol \"-\" ) s) -\n                        (= (symbol \"*\" ) s) *\n                        :else (get col s))\n                   s))\n             execute (fn execute [sub_exp]\n               (loop [f (check_symbol (first sub_exp)) parameters [] data (rest sub_exp)]\n                 (let [firstp (first data)]\n                 (if (empty? data)\n                        (apply f parameters)\n                        (recur f (if (sequential? firstp)\n                                    (conj parameters  (execute firstp))\n                                    (conj parameters (check_symbol firstp))\n                                   )  (rest data)\n                        )))))\n\n             ]\n            (execute exp)\n         )\n       )\n  )", "problem": 121, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [x]\n  (fn [y] \n    (letfn \n      [(e [[a & b]] (apply (g a) (map f b)))\n       (f [a] (if (coll? a) (e a) (y a a)))\n       (g [a] (cond (= '/ a) / (= '+ a) + (= '* a) * (= '- a) -))]    \n    (e x))))", "problem": 121, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(let [operator {'/ /\n                '+ +\n                '- -\n                '* *}]\n  (fn compute [[op & operands]]\n    (fn [m]\n      (letfn [(operand [operand]\n                (cond (symbol? operand) (m operand)\n                      (coll? operand)   ((compute operand) m)\n                      :else             operand))]\n         (apply (operator op) (map operand operands))))))", "problem": 121, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn calc\n  ([e] (fn [m] (calc e m)))\n  ([e m]\n    (let [ops {'+ + '- - '* * '/ /}]\n      (if (sequential? e)\n        (apply (ops (first e)) (map #(calc % m) (rest e)))\n        (get m e e)))))", "problem": 121, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn x [f]\n (let [o {'+ + '- - '* * '/ /}] \n  (fn [e]\n   (cond \n     (seq? f) (let [[g & a] f] (apply (o g) (map (comp #(% e) x) a)))\n     (symbol? f) (e f)  \n     :o f))))", "problem": 121, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn evaluate [body]\n  (fn [env]\n    (if (sequential? body)\n      (let [op ({'/ clojure.core// '* clojure.core/*\n                 '- clojure.core/- '+ clojure.core/+} (first body))\n            args (map #((evaluate %) env) (rest body))]\n        (apply op args))\n      (get env body body))))", "problem": 121, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(fn uce [exp]\n  (fn [env]\n    (letfn [(ev [exp]\n              (cond (sequential? exp) (apply ({'+ + '- - '* * '/ /} (first exp)) (map ev (rest exp)))\n                    :else (env exp exp)))]\n      (ev exp))))", "problem": 121, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn ! [exp]\n  (fn [args]\n    (if (coll? exp)\n      (apply ({'+ + '- - '/ / '* *} (first exp)) \n             (map #((! %) args) (replace args (rest exp))))\n      exp)))", "problem": 121, "user": "4ee7ef87535d93acb0a66872"}, {"code": "(fn uce [[op & expr]]\n  (fn [bind]\n    (let [ops { '+ +, '- -, '* *, '/ / }]\n      (apply (ops op) (map #(cond\n                        (coll? %) ((uce %) bind)\n                        (symbol? %) (bind %)\n                        :else %) expr)))))", "problem": 121, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn my-eval [form]\n  (fn [bindings]\n    (cond (list? form) (apply ({'+ + '- - '* * '/ /}\n                                (first form))\n                              (map #((my-eval %) bindings)\n                                   (rest form)))\n          (symbol? form) (bindings form)\n          :else form)))", "problem": 121, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn calc [[op & ps ] ]\n    (fn [vars]\n      (apply\n       ({'/ / '* * '+ + '- -} op)\n       (map #(if (coll? %)\n                ((calc %) vars)\n                (or (vars %) %))\n        ps))))", "problem": 121, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn compute\n  ([form symbols]\n    (cond \n      (list? form)\n        (let [op   ({'+ + '- - '* * '/ /} (first form))\n              args (map #(compute % symbols) (rest form))]\n          (apply op args))\n      (symbol? form) \n        (symbols form)\n      :else          \n        form))\n  ([form]\n    (fn [symbols]\n      (compute form symbols))))", "problem": 121, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn kk [sa]\n  (fn[sb]\n    (let [symb (reduce (fn[s [x y]] (assoc s (str x) y)) {'+ + '- - '* * '/ /} sb)\n          ff (fn ff[s]\n               (if (coll? s) \n                 (apply (symb(first s)) (map ff (rest s))) \n                 (if (integer? s) s (symb (str s)))))]\n      (ff sa))))", "problem": 121, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn E [l]\n  #(cond\n     (seq? l)\n       (let [[o & x] l]\n         (apply ({'+ + '- - '* * '/ /} o)\n                (for [y x] ((E y) %))))\n     (symbol? l)\n       (% l)\n     1\n       l))", "problem": 121, "user": "4ee82539535d93acb0a66878"}, {"code": "(let [y (fn [f]\n          ((fn [u] (u u))\n             (fn [u] (f (fn [v] ((u u) v))))))\n      m {'+ + '- - '* * '/ /}]\n  (fn [e] \n    (fn [b]\n      ((y (fn [c]  \n            (fn [x]\n              (if (seq? x)\n                (let [[h & t] x] \n                  (apply (m h) (map c t)))\n                (b x x))))) \n         e))))", "problem": 121, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [x] \n  (fn [y] \n    (let [m (zipmap '(+ - * /) [+ - * /]) \n          l #(if (symbol? %) (y %) %)] \n      (apply (fn f [o & a] \n        (apply (m o) \n          (map #(if (coll? %) (apply f %) (l %)) a))) x))))", "problem": 121, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [body]\n  (fn [bindings]\n    (letfn [(evaluate [expr]\n      (cond\n        (sequential? expr)\n          (apply ({'/ / '* * '+ + '- -} (first expr)) (map evaluate (rest expr)))\n        (integer? expr)\n          expr\n        true\n          (bindings expr)))]\n      (evaluate body))))", "problem": 121, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn ev [exp]\n  (fn [vars]\n    (cond \n      (number? exp) exp\n      (symbol? exp) (get vars exp)\n      :else (apply \n              ({(symbol \"+\") +,\n                (symbol \"-\") -,\n                (symbol \"*\") *,\n                (symbol \"/\") /} (first exp))\n              (map \n                #((ev %) vars) \n                (rest exp))\n    ))))", "problem": 121, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn [expr]\n    (fn [bs]\n      ((fn u [e]\n         (if (seq? e)\n           (apply ({'+ + '- - '/ / '* *} (first e)) (map u (rest e)))\n           (bs e e))) expr)))", "problem": 121, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [c]\n  (fn [b] \n    (letfn [\n      (my-eval [t]\n        (if (list? t)\n          (let [op (first t) args (rest t)]\n            (apply ({'+ + '- - '* * '/ /} op) (map my-eval args)))\n          (b t t)))]\n    (my-eval c))))", "problem": 121, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn calc-fn [exp]\n  (let [ops {'+ + '- - '* * '/ /}]\n;  (fn [data] (apply (ops (first exp))\n;    (map #(cond\n;      (symbol? %) (data %)\n;      (list? %) ((calc-fn %) data)\n;      :else %)\n;    (rest exp))))))\n\t(fn [data] (clojure.walk/postwalk #(if (coll? %) (apply (first %) (next %)) ((merge data ops) % %)) exp))))", "problem": 121, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn eval-form [form]\n        (letfn [(f [form v]\n                  (if-not (coll? form)\n                    (if (symbol? form) (v form) form)\n                    (let [[o & a] form]\n                      (apply ({'/ #'/ '+ #'+ '- #'- '* #'*} o)\n                       (map #(f % v) a)))))]\n          #(f form %)))", "problem": 121, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn f [[x & xs]]\n     (fn [m]       \n       (apply (get {'/ /, '* *, '+ +, '- -} x) \n              (map #(if (coll? %)\n                      ((f %) m)\n                      (get m % %)) xs))))", "problem": 121, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn [ex]\n  (letfn [\n    (sym-fn [s] ({'+ + '- - '* * '/ /} s))\n    (ev [a ex]\n      (cond\n        (symbol? ex) (a ex)\n        (coll? ex)\n        (apply (sym-fn (first ex))\n          (map (partial ev a) (rest ex)))\n        :else ex))]\n  (fn [a] (ev a ex))))", "problem": 121, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn f [fo]\n  (let [t {'/ / '* * '+ + '- -}]\n  (cond\n    (seq? fo) (fn [x] (apply (t (first fo)) (map #(% x) (map f (rest fo)))))\n    (number? fo) (constantly fo)\n    true (fn [x] (get x fo)))))", "problem": 121, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn f [l]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (fn [m]\n      (letfn [(g [y] (if (list? y)\n                       ((f y) m)\n                       (m y y)))]\n        (apply (ops (first l)) (map #(g %) (rest l)))))))", "problem": 121, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn __ [l]\n  (letfn [(uno [a m]  (cond (coll? a) (opera a m) (symbol? a) (m a) :else a))\n          (opera [l m]\n                (let \n                [op (first l)\n                 op1 ({'+ + '- - '* * '/ /} op)                 \n                 aas (map #(uno % m) (rest l))]                 \n                    (apply op1 aas)))] \n    (fn [m] (opera l m))))", "problem": 121, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn prob-0121 [expr]\n  (letfn [\n    (deep-replace [smap coll]\n      (mapcat #(if (coll? %) (list (deep-replace smap %)) (list %) )\n              (replace smap coll)))\n\n    (op-sym-to-fn [sym]\n      (cond\n       (= sym '+) +\n       (= sym '-) -\n       (= sym '*) *\n       (= sym '/) /\n       :else     (throw (Exception. (str \"Can't happen, op-sym=\" sym)))))\n\n    (eval-math [coll]\n       (let [[op & args] (mapcat #(if (coll? %) (list (eval-math %)) (list %)) coll)]\n         (apply (op-sym-to-fn op) args)))\n    ]\n\n  #(eval-math (deep-replace % expr))))", "problem": 121, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(let [ops {'+ + '- - '/ / '* *}]\n  (fn [form]\n    (fn [m]\n      (let [f (fn f [t]\n                (if (sequential? t)\n                  (let [[op & rest] t] (apply (ops op) (map f rest)))\n                  (get m t t)))]\n      (f form)))))", "problem": 121, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [coll]\n    (fn [m] \n      ((fn compute [x] \n         (if (coll? x)\n           (let [[op & args] x]\n             (apply ({'+ + '- - '* * '/ /} op) \n                    (map compute args)))\n           (get m x x)))\n         coll)))", "problem": 121, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn [formula]\n  (partial\n   (fn calc [formula bind]\n     (cond\n      (coll? formula)   (let [[op & args] formula]\n                          (apply ({'+ + '- - '* * '/ /} op) (map #(calc % bind) args)))\n      (number? formula) formula\n      :else             (bind formula)))\n   formula))", "problem": 121, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "#(partial\n    (fn rec [n m]\n      (if (list? n)\n        (let [ns (map (fn [a] (rec a m)) (rest n))\n              op (first n)]\n          (cond\n           (= '+ op) (apply + ns)\n           (= '- op) (apply - ns)\n           (= '/ op) (apply / ns)\n           (= '* op) (apply * ns)))\n        (get m n n)))\n    %1)", "problem": 121, "user": "4ee82223535d93acb0a66877"}, {"code": "#(fn [m]\n   ((fn e [x]\n     (cond (sequential? x) (apply ({'* * '/ / '+ + '- -} (first x)) (map e (rest x)))\n           (symbol? x) (m x)\n           :else x)) %))", "problem": 121, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn universal-computation-engine [formula]\r\n    (fn f [bindings]\r\n      (letfn [(sym-to-op [op]\r\n                (cond\r\n                 (= (symbol \"+\") op) +\r\n                 (= (symbol \"-\") op) -\r\n                 (= (symbol \"*\") op) *\r\n                 (= (symbol \"/\") op) /\r\n                 ))\r\n              (my-eval [t]\r\n                 (cond\r\n                  (number? t) t\r\n                  (seq? t) (let [op (first t)]\r\n                             (reduce (sym-to-op op) (map my-eval (rest t))))\r\n                  (contains? bindings t) (get bindings t)))]\r\n        (my-eval formula))))", "problem": 121, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn [x]\n  (let [ops {'+ + '- - '* * '/ /}\n        ev (fn [[op & coll]] (apply (ops op) coll))\n        rec (fn rec [x m]\n              (if (seq? x)\n                (ev (map #(rec % m) x))\n                (m x x)))]\n    (partial rec x)))", "problem": 121, "user": "4daec9dcedd6309eace4d15f"}, {"code": "#(fn [maps] ((fn doit [x] (if (coll? x)\n                             (let [[op & args] x]\n                               (apply ({'* * '+ + '/ / '- -} op)\n                                      (map doit args)))\n                             (get maps x x))) %))", "problem": 121, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn ev [ex]\n        (fn [mappings]\n            (cond (list? ex)\n                  (apply ({'+ +, '- -, '* *, '/ /}(first ex))\n                         (map #((ev %) mappings)\n                              (rest ex))),\n                  (symbol? ex)\n                  (mappings ex),\n                  :else\n                  ex)))", "problem": 121, "user": "4e599577535d8a8b8723a29f"}, {"code": "(fn [q] \n  (fn [m]\n    ((fn f [a b]\n      (cond\n        (= (type a) (type 1))  a\n        (= (type a) (type 'a)) (a b)\n        :else ((fn [[g & c]] \n                  (apply (g\n                         {'+ +\n                          '- -\n                          '/ /\n                          '* *}) (map #(f % b) c)))\n                      (vec a)))) q m)))", "problem": 121, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn o [v]\n  (fn e [m]\n    (cond\n     (list? v)\n     (let [op ({'+ +, '- -, '* *, '/ /} (first v))]\n       (apply op (map #((o %) m) (rest v))))\n     (symbol? v)\n     (m v)\n     :else\n     v)))", "problem": 121, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [ex] \n  (fn [smap]\n     (let [opm {'/ #'/, '* #'*, '+ #'+, '- #'-}\n           f (fn f [[op & r]] \n                 (if op             \n                     (apply (opm op) \n                            (for [x r]\n                              (if (coll? x) \n                                  (f x) \n                                  (if (symbol? x) (smap x) x))))))]\n          (f ex))))", "problem": 121, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn exec [e]\n  (fn [bind]\n    (cond\n      (bind e) (bind e)\n      (list? e) (let [args (map #((exec %) bind) (rest e))]\n         (cond\n           (= (first e) '+) (apply + args)\n           (= (first e) '-) (apply - args)\n           (= (first e) '*) (apply * args)\n           (= (first e) '/) (apply / args)))\n      :else e)))", "problem": 121, "user": "4f13047d535d64f60314642c"}, {"code": "partial\n(fn evl [x env]\n  (if (list? x)\n    (apply ({'+ + '/ / '* * '- -} (first x))\n      (map #(evl % env) (rest x)))\n    (env x x)))", "problem": 121, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn [f]\n  (fn [m]\n    (let [n (assoc m '+ + '- - '/ / '* *)\n          g (fn g [f]\n              (let [[o & a]\n                    (map #(if (seq? %) (g %) (n % %)) f)]\n                (apply o a)))]\n      (g f))))", "problem": 121, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [f]\n  (fn [w]\n    (letfn\n      [(evil [v s]\n        (cond (coll? s)\n          (apply (evil v (first s)) (map #(evil v %) (rest s)))\n          (v s) (v s)\n          true s))]\n      (evil (merge w {'+ + '/ / '* * '- -}) f))))", "problem": 121, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [formula]\n    (fn [bindings]\n      (letfn [(f [expr]\n                (cond (coll? expr) (let [sym (first expr)\n                                         args (next expr)]\n                                     (cond (= sym '+) (apply + (map f args))\n                                           (= sym '-) (apply - (map f args))\n                                           (= sym '*) (apply * (map f args))\n                                           (= sym '/) (apply / (map f args))))\n                      (get bindings expr) (get bindings expr)\n                      :else (int expr)))]\n        (f formula))))", "problem": 121, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [expr]\n  (letfn [(find-op [op-symbol] ({'+ + '- - '* * '/ /} op-symbol))\n          (realcalc [expr varmap]\n            (cond\n             (symbol? expr) (varmap expr)\n             (number? expr) expr\n             :else (apply (find-op (first expr)) (map #(realcalc % varmap) (rest expr)))))]\n    (fn [varmap] (realcalc expr varmap))))", "problem": 121, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn ff[[op & args]] \n  (fn re[m] \n    (let [o ({'+ + '- - '* * '/ /} op)] \n      (apply o \n             (map #(cond (coll? %)   ((ff %) m)\n                         (symbol? %) (get m %) \n                         :else       %) \n                  args)))))", "problem": 121, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn caculate [l]\r\n  (fn [m]\r\n    (letfn [(cal [e] (if (sequential? e) (apply ({'+ +, '- -, '* *, '/ /} (first e)) (map cal (rest e))) (if (symbol? e) (m e) e)))]\r\n      (cal l))))", "problem": 121, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn [exp]                                                                                                      \n  (let [ops { '+ +, '- -, '/ /, '* * }]\n    (partial                                                                                                                   \n     (fn do-eval [sub-exp vals-map]                                                                                            \n       (let [replaced                                                                                                          \n             (map                                                                                                              \n              (fn [item]                                                                                                       \n                (cond                                                                                                          \n                  (not (nil? (ops item))) (ops item)\n                  (list? item) (do-eval item vals-map)                                                                          \n                  (symbol? item) (vals-map item)                                                                                \n                  :else item))\n              sub-exp)\n             first-item (first replaced)                                                                                       \n             remainder (rest replaced)                                                                                         \n             result                                                                                                            \n             (apply first-item remainder)]                                                                                     \n         result))                                                                                                              \n     exp)))", "problem": 121, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn [s] \n  (fn [v]\n    ((fn g [l m]\n       (let [[f & r] (map #(if (coll? %) (g % m) (m % %)) l)]\n         (apply f r))) \n      s (assoc v '+ + '- - '* * '/ /))))", "problem": 121, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "4f128865535d64f603146428"}, {"code": "(fn [exp]\r\n  (letfn\r\n    [(walk [exp values]\r\n       (if (seq? exp)\r\n         (replace values (for [e exp] (walk e values)))\r\n         exp))\r\n     (get-op [op]\r\n       (cond\r\n         (= op '+) +\r\n         (= op '-) -\r\n         (= op '*) *\r\n         (= op '/) /))\r\n     (walk-eval [exp]\r\n       (if (seq? exp)\r\n         (apply (get-op (first exp)) (for [e (rest exp)] (walk-eval e)))\r\n         exp))]\r\n  (fn [values]\r\n    (walk-eval (walk exp values)))))", "problem": 121, "user": "4f0f01c0535d0136e6c22329"}, {"code": "(fn fn121 [f] (fn [m] (let [ff (map (fn [s] (if (seq? s) ((fn121 s) m) (or (m s) s))) f)] (apply ({'+ + '- - '/ / '* *} (first ff)) (rest ff)))))", "problem": 121, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [f]\n  (letfn [(csf [l]\n       ({'+ +,'- -,'* *,'/ /} l)),\n          (uce [[f & r],m]\n              (apply (csf f)\n\t\t            (map #(cond (seq? %) (uce % m)\n\t\t                        (m %) (m %)\n\t\t                        :else %) r)))]\n    (partial uce f)))", "problem": 121, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "#(fn [m] (letfn [(f [x] (if (sequential? x)\n                           (apply ({'+ + '/ / '- - '* *} (first x)) (map f (rest x)))\n                           (if-let [v (m x)] v x)))] \n            (f %)))", "problem": 121, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [f]\n  (fn V [v]\n    (if (map? v)\n      ((fn E [[h & t]]\n         (let [o ({'+ + '- - '* * '/ /} h)\n               C cons]\n           (cond (seq? h) (C (E h) (E t))\n                 (number? h) (C h (E t))\n                 (nil? h) ()\n                 1 (if o\n                     (apply o (E t))\n                     (C (v h) (E t))))))\n       f)\n      (map #(V %) v))))", "problem": 121, "user": "4f0ef874535d0136e6c22328"}, {"code": "partial (fn ! [func coll]\n  (if (seq? func)\n    (apply ({'+ + '- - '* * '/ /} (first func))\n           (map #(! % coll) (rest func)))\n    (coll func func)))", "problem": 121, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn evaluator [expr]\n  #(let \n    [rplace\n(fn [smbol] (or (% smbol) smbol))\n     evl\n(fn evl [frm]\n  (if (= clojure.lang.PersistentList (type frm))\n    (let [[op & fs] frm\n          nums (map (fn g [e] (rplace (evl e))) fs)]\n    (cond\n      (= op '+) (apply + nums)\n      (= op '-) (apply - nums)\n      (= op '*) (apply * nums)\n      (= op '/) (apply / nums)\n      :else nil))\n      frm))]\n    (evl expr)))", "problem": 121, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(let [ops {'+ +, '- -, '* *, '/ /}]\n  (fn eval* [exp]\n    (fn [env]\n      (cond\n        (number? exp)  exp\n        (symbol? exp) (env exp)\n        (list? exp)   (let [[op & args] exp]\n                        (apply (ops op) (map #((eval* %) env) args)))))))", "problem": 121, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn foo [ex]\n  (cond\n    (symbol? ex) (fn [m] (m ex))\n    (integer? ex) (fn [m] ex)\n   :default\n   (let [foos (map foo (rest ex))\n         f ({'+ + '- - '/ / '* * } (first ex)) ]\n     (fn [m] (apply f (map #(% m) foos))))))", "problem": 121, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn [x]\n  #((fn e [x]\n      (apply ({'+ + '- - '* * '/ /} (first x)) \n             (map (fn [v] (if (coll? v) (e v) v)) (rest x)))) \n     (clojure.walk/prewalk-replace % x)))", "problem": 121, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn ucomp [expr]\n    (let [opmap {'+ + '- - '* * '/ /}\n          operate \n            (fn [fop foperands]\n                (let [foperjuxt (apply juxt foperands)]\n                    (fn [env] (apply fop (foperjuxt env)))\n                ))\n          compile \n            (fn compile [[op & operands]]\n                (let [compfoper\n                        (fn [operand]\n                            (cond\n                                (sequential? operand) (compile operand)\n                                (symbol? operand) (fn [env] (get env operand))\n                                :else (constantly operand)\n                            ))]\n                (operate (opmap op) (map compfoper operands))))\n        ]\n        (compile expr)\n    ))", "problem": 121, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [formula]\r\n  (partial \r\n    (fn par [formula params] \r\n      (cond\r\n        (number? formula) formula\r\n        (symbol? formula) (get params formula)\r\n        :else (let [f (get {'+ + '- - '* * '/ /} (first formula))\r\n                    args (rest formula)]\r\n                (apply f (map #(par % params) args)))))\r\n    formula))", "problem": 121, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [expr]\r\n    (fn [bindings]\r\n      (letfn [(feval [expr]\r\n                (get {'+ + '- - '* * '/ /} expr))\r\n              (my-eval [expr env]\r\n                (cond\r\n                 (number? expr) expr\r\n                 (symbol? expr) (get env expr)\r\n                 (list?   expr) (apply (feval (first expr))\r\n                                       (map (fn [e] (my-eval e env))\r\n                                            (rest expr)))))]\r\n        (my-eval expr bindings))))", "problem": 121, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn f [s]\n           (fn [m]\n               (apply (condp = (first s) '+ + '* * '/ / '- -) \n                      (map #(if (sequential? %) \n                             ((f %) m)\n                             (get m % %))\n                           (rest s)))))", "problem": 121, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn __ [[op & args]]\n  (fn [m] \n    (apply ({'/ / '* * '+ + '- -} op) (map #(cond (symbol? %) (m %) (sequential? %) ((__ %) m) :else %) args))))", "problem": 121, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [exp]\n  (fn [m]\n    (let [m (merge m {'+ + '- - '/ / '* *})\n          foo (fn foo [exp]\n                (cond (list? exp) (apply (foo (first exp)) (map foo (rest exp)))\n                      (symbol? exp) (m exp)\n                      :else exp))]\n     (foo exp))))", "problem": 121, "user": "4eb66737535d7eef3080736b"}, {"code": "(fn [s] (fn [h] ((fn f [s] (let [s (map #(if (h %) (h %) (if (seq? %) (f %) %)) s) f (first s)]\n                             (if (= f '+) (apply + (rest s))\n                               (if (= f '-) (apply - (rest s))\n                                 (if (= f '*) (apply * (rest s)) (apply / (rest s))))))) s)))", "problem": 121, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [e]\n    (fn f\n      ([m] (f m e))\n      ([m [o & a]]\n       (apply (get {'+ + '- - '/ / '* *} o) \n              (map #(cond\n                      (seq? %) (f m %) \n                      (number? %) %\n                      1 (get m %)) a)))))", "problem": 121, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn [f]\n  (fn [v]\n    (let [s {'+ + '- - '/ / '* *}\n          r (fn r [[o & a] v]\n              (apply (s o) (map #(if (coll? %) (r % v) (v % %)) a)))]\n      (r f v))))", "problem": 121, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [f]\n  (fn [r]\n    (let [r (assoc r '+ + '- - '* * '/ /)\n          e (fn [[f & a]] (apply f a))\n          x (fn x [f r] (map #(if (coll? %) (e (x % r)) %) (replace r f))) ]\n    (e (x f r)))))", "problem": 121, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [f]\n  (fn [b]\n    (letfn [(o [s] ({'+ + '- - '* * '/ /} s))\n            (e [[v & a]] (apply (o v) (map #(if (seq? %) (e %) (or (b %) %)) a)))]\n      (e f))))", "problem": 121, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn calc [formula]\n  (let [funcs {'+ + '- - '* * '/ /}]\n    #(let [values %]\n       ((fn eval_ [sexp]\n          (cond\n           (coll? sexp) (apply (funcs (first sexp)) (map eval_ (rest sexp)))\n           (symbol? sexp) (values sexp)\n           :else sexp)) formula))))", "problem": 121, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn f [[o & a]]\n  (fn [e]\n    (let [p {'+ +\n             '- -\n             '* *\n             '/ /}]\n      (apply (p o) (map #(if (list? %)\n                          ((f %) e) \n                          (e % %)) a)))))", "problem": 121, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [form]\n    (fn [valmap]\n      (letfn [(dr [f vm]\n                (let [sm {(symbol \"/\") /, (symbol \"+\") +, (symbol \"*\") *, (symbol \"-\") -}\n                      r (replace vm (map (fn [a] (if (seq? a) (dr a vm) a)) f))]\n                  (apply (sm (first r)) (rest r))))]\n        (dr form valmap))))", "problem": 121, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn engine [formula]\n  (let [[op & args] formula]\n  (fn [argmap]\n    (let [vals (map #(if (coll? %1)\n                       ((engine %1) argmap) ;;nested functions\n                       (if (number? %1)\n                         %1\n                         (get argmap %1))\n                       )\n                    args)]\n      (if (= \"+\" (name op))\n        (apply + vals)\n        (if (= \"-\" (name op))\n          (apply - vals)\n          (if (= \"*\" (name op))\n            (apply * vals)\n            (apply / vals))\n          ))\n      ))))", "problem": 121, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn [formula]\n  (letfn [\n  \t(replac [[f & s] assignments]\n\t\t  (apply ({'+ +, '- -, '/ /, '* *} f)\n\t\t    (map #(get assignments % %) \n\t\t      (map\n\t\t        #(if (seq? %) (replac % assignments) %)\n\t\t        s))))\n    ]\n    (partial replac formula)))", "problem": 121, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [expr]\n  (let [fns {'/ / '* * '- - '+ +}]  \n  (fn [vars]\n    ((fn thisfunc [e]\n      (cond\n        (symbol? e) (vars e)\n        (number? e) e\n        (list? e) (apply (fns (first e)) (map thisfunc (rest e)))))\n     expr))))", "problem": 121, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn makecalc [sexp]\r\n  (letfn [(calc-1 [exp env]\r\n            (cond (number? exp)\r\n                    exp\r\n                  (symbol? exp)\r\n                    (env exp)\r\n                  (= (first exp) '+)\r\n                    (apply + (map #(calc-1 % env) (rest exp)))\r\n                  (= (first exp) '-)\r\n                    (apply - (map #(calc-1 % env) (rest exp)))\r\n                  (= (first exp) '*)\r\n                    (apply * (map #(calc-1 % env) (rest exp)))\r\n                  (= (first exp) '/)\r\n                    (apply / (map #(calc-1 % env) (rest exp)))\r\n                  :else\r\n                    (println \"error:\" exp)))]\r\n    (fn calc [binds]\r\n      (if (sequential? binds)\r\n        (map #(calc-1 sexp %) binds)\r\n        (calc-1 sexp binds)))))", "problem": 121, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn u [e]\n  (fn v [a]\n    (if (seq? e)\n      (apply ({'* *, '/ /, '+ +, '- -}\n              (first e))\n             (map #((u %) a) (rest e)))\n      (a e e))))", "problem": 121, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn [eqs]\n  (fn [m]\n    ((fn compute [x]\n      (if (seq? x)\n        (let [[op & args] x]\n          (apply ({'+ + '/ / '* * '- -} op)\n            (map compute args)))\n        (get m x x)))\n      eqs)))", "problem": 121, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn calc [expr]\r\n  (let [ops {'+ + '- - '* * '/ /}]\r\n    (letfn [(solve [expr bindings]\r\n                   (cond\r\n                     (coll? expr) (apply (ops (first expr))\r\n                                         (map #(solve % bindings) (rest expr)))\r\n                     (symbol? expr) (bindings expr)\r\n                     (number? expr) expr))]\r\n      (fn [bindings] (solve expr bindings)))))", "problem": 121, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn ! [expr]                                                                                        \n   (fn [args]                                                                                         \n     (let [ops  {'+ +, '- -, '* *, '/ /}                                                             \n           op (ops (first expr))]                                                                    \n       (apply op                                                                                     \n              (map #(cond                                                                            \n                       (number? %) %                                                                 \n                       (symbol? %) (args %)                                                          \n                       :else ((! %) args))                                                           \n                   (rest expr)))                                                                     \n       )))", "problem": 121, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [form]\n  (fn [bindings]\n    (let [func {'/ / '+ + '* * '- -}\n          call (fn [f a b]\n                 ((func f) (bindings a a)\n                           (bindings b b)))]\n      (apply\n        (fn iter [f a b & r]\n          (cond (coll? a) (apply iter f (apply iter a) b r)\n                (coll? b) (apply iter f a (apply iter b) r)\n                (empty? r) (call f a b)\n                :else (apply iter f (call f a b) r)))\n    \n    form))))", "problem": 121, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [expr]\r\n  (fn [vars]\r\n    (letfn [(calc [x v]\r\n              (if (coll? x)\r\n                (apply (v (first x)) (map #(calc % v) (rest x)))\r\n                (if (symbol? x) (v x) x)\r\n                ))]\r\n      (calc expr (into {'+ + '- - '* * '/ /} vars)))))", "problem": 121, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn q [a]\r\n  (fn [v]\r\n    (cond\r\n      (coll? a) (let [[c & d] a\r\n                      f {'+ + '* * '- - '/ /}]\r\n                  (apply (f c) (map #((q %) v) d)))\r\n      (symbol? a) (v a)\r\n      a a)))", "problem": 121, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [e]\n  (fn ev\n    ([m] (ev e m))\n    ([v m]\n       (reduce\n        #(let [o (fn [d]\n                   (cond\n                    (list? d) (ev d m)\n                    (symbol? d) (m d)\n                    :else d))\n               a (o %) b (o %2)]\n           (if b (({'+ + '- - '* * '/ /} (first v)) a b) a))\n        (rest v)))))", "problem": 121, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [expr]\n     (partial (fn evaluate [[f & args :as expression] vars]\n                (let [subst (fn [node]\n                              (if (symbol? node)\n                                (if (vars node) (vars node) node)\n                                node))\n                      args (map subst args)]\n                  (if (not-any? list? expression)\n                    (condp = f\n                      '/ (apply / args)\n                      '* (apply * args)\n                      '+ (apply + args)\n                      '- (apply - args))\n                    (evaluate (for [sym expression\n                                    :let [sym (subst sym)]]\n                                (if (list? sym)\n                                  (evaluate sym vars)\n                                  sym))\n                              vars)))) expr))", "problem": 121, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [formula]\n    (fn [values]\n      (letfn [(subst [f v]\n                (if (empty? f)\n                  '()\n                  (lazy-seq\n                    (let [h (first f)]\n                      (cons (cond (coll? h) (subst h v)\n                                  (symbol? h) (if (contains? v h)\n                                                (v h)\n                                                h)\n                                  :else h)\n                            (subst (rest f) v))))))\n              (myeval [e]\n                (if (coll? e)\n                  (apply (let [e2 (first e)]\n                           (cond (= '+ e2) +\n                                 (= '- e2) -\n                                 (= '* e2) *\n                                 (= '/ e2) /))\n                         (map myeval (rest e)))\n                  e))]\n        (myeval (subst formula values)))))", "problem": 121, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn [exps]\r\n    (let[matrix {'+ (fn[col](apply + col))\r\n                 '- (fn[col](apply - col)) \r\n                 '/ (fn([[a b]](/ a b)) ) \r\n                 '* (fn[col](apply * col))}\r\n         comp (fn comp\r\n              ([col param]\r\n                (let[convert(fn[a]\r\n                            (if (coll? a) (comp a param) (get param a a) )\r\n                            )\r\n  \t                 vals (map convert (rest col))\r\n\t\t                 fun (get matrix (first col)) \r\n                 ]\r\n                (println (str \" col \" vals \" param \" col \" fun \" (type fun) ) )\r\n                (fun vals)\r\n             )))\r\n       ]\r\n     (fn[param]\r\n       (comp exps param)\r\n       )\r\n ))", "problem": 121, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [e]\n  (fn [v]\n  ((fn compute [e]\n      (cond (seq? e) (let [f (first e) r (map compute (rest e))]\n                       (cond (= f '+) (apply + r)\n                             (= f '-) (apply - r)\n                             (= f '*) (apply * r)\n                             (= f '/) (apply / r)))\n            (symbol? e) (v e)\n            :else e)) e)))", "problem": 121, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn f [l]\n  (let [m {'+ + '- - '/ / '* *}]\n    (fn g [e]\n      (apply (m (first l))\n             (map #(cond (symbol? %) (e %)\n                         (number? %) %\n                         :else ((f %) e)) (rest l))))))", "problem": 121, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn c [e]\n  (fn d [v]\n  (cond\n    (sequential? e)\n    (let [[o & a] e\n           x (map (fn [y] ((c y) v)) a)]\n      (apply (condp = o '/ / '* * '+ + '- -) x))\n    (symbol? e) (get v e)\n    :else e)))", "problem": 121, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn engine [x]\n  (fn [m]\n    (if (coll? x)\n      (let [args (map #((engine (m % %)) m) (rest x))]\n        (apply ({'+ + '- - '* * '/ /} (first x)) args))\n      (m x x))))", "problem": 121, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn v [formula] \r\n (fn fv [variables]\r\n  (let [_ (println \"formula\" formula)\r\n        _ (println \"variables\" variables)\r\n        formula-seq (seq formula)\r\n        _ (println \"formula-seq\" formula-seq)\r\n        variable-map (apply hash-map (flatten (seq variables)))\r\n        _ (println \"variable-map\" variable-map)\r\n        ops-map {'/ /, '* *, '+ +, '- -}\r\n        [opsym & subs] formula-seq\r\n        _ (println \"opsym\" opsym)\r\n        _ (println \"subs\" subs)\r\n        evaluated-subs (map (fn [sub-formula]\r\n                             (cond\r\n                              (number? sub-formula) sub-formula\r\n                              (symbol? sub-formula) (variable-map sub-formula)\r\n                              :else ((v sub-formula) variables)\r\n                              )) subs)\r\n        _ (println \"evaluated-subs\" evaluated-subs)\r\n        op (ops-map opsym)\r\n        _ (println \"op\" op)\r\n        result (apply op evaluated-subs)\r\n        _ (println \"result\" result)]\r\n        result)))", "problem": 121, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [s]\n  (fn [m]\n    ((fn f [s]\n      (apply ({'/ / '+ + '- - '* *} (first s))\n        (map\n          #(if (list? %) (f %)\n            (if (symbol? %) (m %) %))\n          (rest s)))) s)))", "problem": 121, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [eq]\n  (fn [vs]\n    (let [ops {'+ + '- - '* * '/ /}]\n      (letfn [(rs [eq]\n                (if ((comp not seq?) eq) (or (vs eq) eq)\n                    (let [[op & xs] eq]\n                      (if (not-any? #(seq? %) (rest eq))\n                        (apply (ops op)\n                               (map #(or (vs %) %) (rest eq)))\n                        ((ops op)\n                         (rs (first xs)) (rs (second xs)))))))]\n        (rs eq)))))", "problem": 121, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn [formule]\n  (fn [corres]\n    (\n      (fn calcul [f]\n        (if (coll? f) (apply (first (replace {'+ + '- - '/ / '* *} f)) (map calcul (rest f)))\n        (if (symbol? f) (get corres f)\n        f\n        ))\n      )\n      formule\n    )\n  )\n)", "problem": 121, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn [expr]\n  (fn [smap]\n    ((fn g [e]\n      (cond\n        (sequential? e) (let [s (map g e)] (apply (first s) (rest s)))\n        (symbol? e) ((merge smap {'+ + '- - '* * '/ /}) e)\n        :else e)) expr)))", "problem": 121, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [src]\n    (fn [bind]\n        ((fn f [x]\n             (apply ({'+ + '- - '* * '/ /} (first x))\n                    (map\n                      #(cond\n                         (seq? %) (f %)\n                         (symbol? %) (bind %)\n                         :else %)\n                      (rest x))))\n         src)))", "problem": 121, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn calc [e]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (fn [m]\n      ((fn pcalc [e]\n         (cond (list? e)       (apply (get ops (first e))\n                                      (map pcalc (rest e)))\n               (contains? m e) (get m e)\n               :else           e))\n       e))))", "problem": 121, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn [f]\n    #(clojure.walk/postwalk\n      (fn [x]\n        (if (seq? x)\n          (let [[a & b] x]\n            (apply ({'/ / '* * '+ + '- -} a) b))\n          (get % x x)))\n      f))", "problem": 121, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "partial\n(fn c [[o & a] m]\n  (apply \n    ({'/ / '+ + '* * '- -} o) \n    (map \n      #(if (seq? %) (c % m) (m % %))\n      a)))", "problem": 121, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [expr]\r\n  (letfn [(ev [form env]\r\n            (cond (list? form) \r\n                    (apply (env (first form))\r\n                           (map #(ev % env) (rest form)))\r\n                  (number? form) form\r\n                  (symbol? form) (env form)))]\r\n    #(ev expr (into {'/ /, '* *, '+ +, '- -} %))))", "problem": 121, "user": "4fb37882e4b081705acca2a0"}, {"code": "(fn [form]\n  (letfn [(uce [fm vm]\n              (if (seq? fm)\n                (apply ((first fm) {'+ + '- - '* * '/ /})\n                       (map #(uce % vm) (rest fm)))\n                (or (vm fm) fm)))]\n    (fn [vmap] (uce form vmap))))", "problem": 121, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn [a]\n  (fn [vars]\n    (letfn [(evalvar [sym]\n              (vars sym))\n            (evalop [[op & args]]\n              (apply ({'/ / '* * '- - '+ +} op) (map evaluate args)))\n            (evaluate [term]\n              (cond\n                (seq? term) (evalop term)\n                (number? term) term\n                :else       (evalvar term)))]\n      (evaluate a))))", "problem": 121, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn f [expr]\n  (cond\n   (number? expr) (fn [m] expr)\n   (symbol? expr) (fn [m] (m expr))\n   :else (fn [m]\n           (let [[op & args] expr\n                 mapseq (map #((f %) m) args)\n                 opmap {'/ /, '* *, '+ +, '- -}]\n             (apply (opmap op) (map #((f %) m) args))))))", "problem": 121, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn uce [formula]\n  (fn [z] \n    (letfn [\n            (replacer [x]\n                      (if (list? x)\n                        (apply (get {'/ / '+ + '- - '* *} (first x))\n                               (map replacer (rest x)))\n                        (if (number? x)\n                          x\n                          (get z x))))]\n      (replacer formula))))", "problem": 121, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn eval-arith [expr]\n  (fn [env] (cond (sequential? expr) (let [sym-f (first expr)\n                                           f     ({'+ +\n                                                   '* *\n                                                   '- -\n                                                   '/ /} sym-f)\n                                           conts (map eval-arith (rest expr))\n                                           args  (map #(% env) conts)]\n                                       (apply f args))\n                  (symbol? expr)       (env expr)\n                  :else                expr)))", "problem": 121, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn computation [expr]\n  (let [actions { (quote +) +\n                  (quote -) -\n                  (quote *) *\n                  (quote /) /}\n        process (fn [f expr values]\n                  (cond\n                    (list? expr) (let [[op & args] expr]\n                                   (apply (actions op); apply the operation to all args\n                                          (map #(f f % values) args)))\n                    (number? expr) expr\n                    :else (values expr))) ]\n    (fn [values]\n      (process process expr values))))", "problem": 121, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn calc [ex]\n  (let [ ops {'+ + '- - '* * '/ /} ]\n    (fn [vars]\n      (letfn [(evaluate [exp]\n        (cond (sequential? exp)         ; expression\n                (let [op (ops (first exp))\n                      subexps (map #(evaluate %) (rest exp))]\n                     (reduce op subexps))\n              (symbol? exp) (vars exp)  ; variable\n              :else exp))]              ; number\n      (evaluate ex)))))", "problem": 121, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn my-eval [to-eval]\n  (fn [var-vals]\n    (let [fun-map {'- -, '+ +, '* *, '/ /}\n          eval-expr (fn eval-expr [expr]\n            (if (seq? expr)\n                (#(apply (fun-map (first %)) (map eval-expr (rest %)))\n                    (replace var-vals expr))\n                expr))]\n      (eval-expr to-eval))))", "problem": 121, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [expr]\n  (fn [hm] \n    (letfn [(evl [x]\n              (if (list? x)\n                (let [[f & r] (map evl x)]\n                  (apply f r))\n                ({'+ +, '- -, '/ /, '* *} x x)))]\n      (evl (clojure.walk/prewalk-replace hm expr)))))", "problem": 121, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn evaluate [forms]\n  (fn [scope]\n    (let [fun (first forms)\n          args (rest forms)]\n      (apply (condp = fun '* * '/ / '+ + '- -)\n        (map\n          #(cond\n            (symbol? %) (scope %)\n            (number? %) %\n            (coll? %) ((evaluate %) scope))\n          args)))))", "problem": 121, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn [exp]\n  (fn [ctx]\n    (letfn [(value [exp]\n              (cond (seq? exp) \n                    (let [[op & args] exp]\n                      (apply ({'+ +, '- -, '* *, '/ /} op)\n                             (map value args)))\n                    (symbol? exp) (ctx exp)\n                    :else exp))]\n      (value exp))))", "problem": 121, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn calc\n  ([form]\n    (fn [vars] (calc form vars)))\n  ([form vars]\n    (cond (number? form) form\n      (symbol? form) (vars form)\n      :else (let [[op & args] form]\n              (apply (cond\n                       (= op '+) +\n                       (= op '-) -\n                       (= op '/) /\n                       (= op '*) *)\n                (map #(calc % vars) args))))))", "problem": 121, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "4fd81472e4b0dab7d829f38e"}, {"code": "(fn [expr]\n  (letfn [\n    (to-op [sym]\n      ({'+ +, '- -, '* *, '/ /} sym))\n    (to-val [m v]\n      (cond\n        (sequential? v) (my-eval m v)\n        (symbol? v) (m v)\n        :else v))\n    (my-eval [m [op & vs]]\n      (apply (to-op op) (map #(to-val m %) vs)))]\n    (fn [m] (my-eval m expr))))", "problem": 121, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [s]\n  (fn [m]\n    ((fn ev [[f & args]]\n       (apply ({'/ / '+ + '* * '- -} f)\n              (map #(if (coll? %) (ev %) (m % %)) args)))\n     s)))", "problem": 121, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [x] \n   (fn [m] \n    ((fn f [l]\n      (if (coll? l)\n        (let [[o & args] l\n              g {'+ + '- - '* * '/ /}]\n          (apply (g o) (map f args)))\n        (if-let [x (m l)] x l))) x)))", "problem": 121, "user": "4fa30027e4b081705acca187"}, {"code": "(fn q121 [xs]\n  (let [\n        ops {'+ + '- - '* * '/ /}\n        calc (fn calc [m x]\n          (if (seq? x)\n            (apply (ops (first x)) (map #(calc m %) (rest x)))\n            (if (contains? m x) (m x) x)))\n        ]\n  #(calc % xs)))", "problem": 121, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [exp]\n  (fn [data]\n    (let [data (conj data {'+ + '- - '* * '/ /} )\n          form (loop [loc (clojure.zip/seq-zip exp)]\n                 (if (clojure.zip/end? loc)\n                   (clojure.zip/root loc)\n                   (if-let [rep (data (clojure.zip/node loc))]\n                     (recur (clojure.zip/replace loc rep))\n                     (recur (clojure.zip/next loc)))))\n          evil (fn evil [x]\n                 (if (seq? x)\n                   (apply (first x) (map evil (rest x)))\n                   x))]\n      (evil form))))", "problem": 121, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn calc [form]\n    (fn[sym-map]\n      (let [f-map {'/ / '* * '+ + '- -}\n            strip (fn [c](map #(f-map % %) (map #(sym-map % %) c)))\n            r-strip (fn r-strip[coll]\n                        (let [curr-lvl (strip coll)]\n                          (if (empty? (filter seq? curr-lvl))\n                            (apply (first curr-lvl) (rest curr-lvl))\n                            (r-strip (map #(if (seq? %) (r-strip %) %) curr-lvl)))))]\n        (r-strip form))))", "problem": 121, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn gen [x]\r\n    (fn [v] ((fn calc [x v]\r\n                 (if (sequential? x)\r\n                   (let [[f & args] x\r\n                         f2 ({'+ + '- - '* * '/ /} f)]\r\n                     (apply f2 (map #(calc % v) args)))\r\n                   (if (symbol? x) \r\n                     (v x x)\r\n                     x))) x v)))", "problem": 121, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [expr]\n (fn [rmap] \n   (letfn [(myevl [ex]\n             (let [ops {'/ / '* * '+ + '- -}]\n               (if (number? ex)\n                 ex\n                 (apply ((first ex) ops)\n                        (map myevl (rest ex))))))]\n    (myevl (clojure.walk/prewalk-replace rmap expr)))))", "problem": 121, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn ev [exp]\n  (fn [env]\n    (let [ops {'/ / '+ + '- - '* *}]\n       (cond (number? exp) exp\n             (symbol? exp) (env exp)\n             :else (apply (ops (first exp))\n                          (map #((ev %) env) (rest exp)))))))", "problem": 121, "user": "4fde492be4b05e33b9224f8a"}, {"code": "(fn [l]\n  #((fn f [s]\n       (if (seq? s)\n          (apply ({'/ / '* * '- - '+ +} (first s)) (map f (rest s)))\n          s))\n    (clojure.walk/prewalk-replace % l)))", "problem": 121, "user": "4ff304f4e4b0678c553fc343"}, {"code": "(fn [e] (letfn [(sb [e m ] (if (seq? e) (av e m) (get m e e)))\n                (av [[opt & opns] m] (apply (opt {'+ + '- - '* * '/ /}) (map #(sb % m) opns)))]\n          (partial av e)))", "problem": 121, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [v] (fn [m] (\r\n (fn g ([n] (if (coll? n) (let [[f & x] n] \r\n  (apply ({\"+\" +, \"-\" -, \"*\" *, \"/\" /} (str f))\r\n         (map g x)))\r\n             (or ((into {} m) n) n)))) v)))", "problem": 121, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(letfn [(ev[e d] (cond (number? e) e (symbol? e) (d e) :else (apply ({'+ + '- - '/ / '* *} (first e)) (map #(ev % d) (rest e)))))] (fn[e](partial ev e)))", "problem": 121, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn [f] (fn [m]\n          ((fn foo [f m]\n             (if (coll? f)\n               (let [oper (get {'/ /, '* *, '+ +, '- -} (first f))\n                     ands (rest f)]\n                 (apply oper (map #(foo % m) ands)))\n               (if (symbol? f)\n                 (get m f)\n                 f)))\n            f m)))", "problem": 121, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn f [l]\n  (fn [b] (let [ops {'+ + '- - '* * '/ /}\n        [op & args] (for [e l]\n               (cond (symbol? e) (or (b e) (ops e))\n                     (number? e) e\n                     :default    ((f e) b)))]\n    (apply op args))))", "problem": 121, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn [formula]\n  (fn [m] ((fn uce [[op & args]] (apply ({'+ + '- - '/ / '* *} op) (replace m (for [a args] (if (seq? a) (uce a) a)))))\n     formula)))", "problem": 121, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn cnt [f-la]\n  (fn [a]\n    (let [\n      args \n        (merge a {'+ + '- - '* * '/ /}) \n      new-f-la \n        (map \n          #(cond\n            (number? %) %\n            (seq? %) ((cnt %) args)\n            :else (args %)) f-la)]\n        (apply (first new-f-la) (rest new-f-la)))))", "problem": 121, "user": "5003ee7de4b0678c553fc446"}, {"code": "(letfn\n  [(my-eval [exp bindings]\n     (cond\n       (list? exp) ; function call\n       (apply (my-eval (first exp) bindings) (map #(my-eval % bindings) (rest exp)))\n       (symbol? exp)\n       (or (bindings exp) ({'+ +, '- -, '* *, '/ /} exp))\n       :else\n       exp))]\n  (fn [exp] (partial my-eval exp)))", "problem": 121, "user": "5002b6e5e4b0678c553fc42c"}, {"code": "(fn [e] (fn [m]\r\n         (letfn [(res [s] (condp = s '+ + '* * '- - '/ /))\r\n                 (ev [s] (println s (type s))\r\n                   (cond (number? s) s\r\n                     (symbol? s) (if-let [v (m s)] v (res s))\r\n                     :else (apply (ev (first s)) (map ev (rest s)))))]\r\n           (ev e))))", "problem": 121, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn parse [[op & args]]\n  (fn [vars]\n    (let [ops {'+ + '- - '* * '/ /}]\n      (apply (ops op)\n        (for [arg args]\n          (cond\n            (sequential? arg) ((parse arg) vars)\n            (symbol? arg)     (vars arg)\n            (number? arg)     arg))))))", "problem": 121, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn [form]\n  (let [ops {'+ + '- - '* * '/ /}\n        e (fn e [f env]\n            (cond (number? f) f\n                  (symbol? f) (f env)\n                  true (apply ((first f) ops) (map #(e % env) (rest f)))))]\n    (partial e form)))", "problem": 121, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [exp]\n  (partial\n   (fn interp [exp env]\n     (cond\n      (number? exp) exp\n      (symbol? exp) (get env exp)\n      :else (let [op ({'+ +, '- -, '* *, '/ /} (first exp))\n                  args (rest exp)]\n              (apply op (map #(interp % env) args)))))\n   exp))", "problem": 121, "user": "500ff421e4b0ae202717946f"}, {"code": "(fn [formula]\r\n  (fn [values]\r\n    ((fn compute [x]\r\n       (if (seq? x)\r\n         (let [[op & args] x]\r\n           (apply ({'+ + '/ / '- - '* *} op)\r\n                  (map compute args)))\r\n         (get values x x)))\r\n     formula)))", "problem": 121, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [code]\n  (fn [bindings]\n    (let [all-bindings (assoc bindings '+ +, '- -, '* *, '/ /)]\n      (letfn [(resolves [s] (get all-bindings s s))\n              (evaluate [f]\n                (if (list? f)\n                  (let [[op & args] f]\n                    (apply (resolves op) (map evaluate args)))\n                  (resolves f)))]\n        (evaluate code)))))", "problem": 121, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [expr]\n  (let [my-eval (fn my-eval [expr]\n                  (if (coll? expr)\n                    (apply ({'+ + '- - '* * '/ /} (first expr))\n                           (map my-eval (rest expr)))\n                    expr))]\n    (fn [vals]\n      (my-eval (clojure.walk/prewalk-replace vals expr)))))", "problem": 121, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [form]\n  (fn [bmap]\n    (let [calc (fn calc\n                    ([x] (if (sequential? x) (apply calc x) x))\n                    ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                                   (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace bmap form)]\n      (calc formula))))", "problem": 121, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [f]\n     (letfn [ (c [formula vals]\n     (let [m {'+ + '- - '* * '/ / } ]\n       (if (some seq? formula)\n         (c (cons (first formula) (map #(cond\n                 (seq? %) (c % vals)\n                 (symbol? %) (% vals)\n                 :default %) (rest formula))) vals)\n         (apply (m (first formula)) (map #(if (symbol? %) (% vals) %) (rest formula)))\n       )))] (partial c f)))", "problem": 121, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [expr]\n    (letfn [(exec [expr params]\n                  (cond \n                    (symbol? expr) (get params expr)\n                    \n                    (integer? expr) expr\n                      \n                    (sequential? expr) \n                    (let [[op & args] expr, calc-args (map (fn [x] (exec x params)) args)]\n                      (apply (op {'+ +, '- -, '* *, '/ /}) calc-args))\n                    ))\n            (calc [expression] \n                  (partial exec expression))]\n           (calc expr)) \n    )", "problem": 121, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [expr]\n  (fn [bindings]\n    (clojure.walk/walk\n      identity\n      (fn lame-eval [form]\n        (if (seq? form) \n          (apply (get {'+ + '- - '/ / '* *} (first form)) \n                 (map lame-eval (rest form)))\n          form))\n      (clojure.walk/prewalk-replace bindings expr))))", "problem": 121, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn formula [f]\n  (fn res [vals]\n    (cond\n      (coll? f) \n        (let [op (first f)\n              vars (map #((formula %) vals) (rest f))] \n          (case op\n            / (apply / vars)\n            * (apply * vars)\n            + (apply + vars)\n            - (apply - vars)))\n      (vals f) (vals f)\n      :else f)))", "problem": 121, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn compute [expr]\n  (fn [bindings]\n    (letfn [(c-eval [expr]\n              (cond\n               (number? expr) expr\n               (list? expr) (let [arguments (map c-eval (rest expr))\n                                  fns { '+ +, '- -, '* *, '/ /}]\n                              (apply (get fns (first expr)) arguments))\n               true (get bindings expr)))]\n      (c-eval expr))))", "problem": 121, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn evl [[f & args]]\n    #(let [ops {'+ +, '- -, '* *, '/ /}\n          resolv (fn [e] (if (seq? e) ((evl e) %) (if (integer? e) e (% e))))]\n          (apply (ops f) (map resolv args))))", "problem": 121, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn __ [[o & args]]\r\n  (fn [m]\r\n    (let [ops {'+ + '- - '/ / '* *}\r\n          f #(cond (number? %) %\r\n                   (symbol? %) (get m %)\r\n                    1 ((__ %) m))]\r\n      (apply (ops o) (map f args)))))", "problem": 121, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn [expr]\n  (fn [params]\n    (letfn [(r [x] (cond (list? x) (apply ({'/ / '+ + '- - '* *} (first x))\n                                          (map r (rest x)))\n                         (number? x) x\n                         :else (params x)))]\n      (r expr))))", "problem": 121, "user": "500cb910e4b05f7c30cfa698"}, {"code": "#(fn [bnd]\r\n   ((fn evl [expr]\r\n      (cond\r\n        (coll? expr) (apply ({'/ /, '+ +, '- -, '* *} (first expr)) (map evl (next expr)))\r\n        (number? expr) expr\r\n        :else (bnd expr)))\r\n  %))", "problem": 121, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [f]\n  (fn [m]\n    (letfn [(walk [e]\n              (if (list? e)\n                (map walk e)\n                (if (contains? m e)\n                  (m e)\n                  e)))\n            (our-eval [x]\n              (if (not (sequential? x))\n                (cond\n                  (= x '/) /\n                  (= x '*) *\n                  (= x '+) +\n                  (= x '-) -\n                  :else x)\n                (apply (our-eval (first x)) (map our-eval (rest x)))))]\n      (our-eval (map walk f)))))", "problem": 121, "user": "50435852e4b034ff00315d22"}, {"code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "problem": 121, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [r]\r\n    (let [q (fn f [[o & p] m]\r\n              (reduce\r\n               (condp = o\r\n                 '/ /\r\n                 '+ +\r\n                 '* *\r\n                 '- -)\r\n               (map #(cond\r\n                      (coll? %) (f % m)\r\n                      (get m %) (get m %)\r\n                      true %) p)))\r\n          w (fn [z x] (if (vector? x) (map #(q z %) x) (q z x)))]\r\n      (partial w r)))", "problem": 121, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn [e]\n  (fn [m] (\n  \n    (fn f [exp env]\n    (println exp (coll? exp))\n    (if (coll? exp)\n      (apply (f (first exp) env ) (map #(f % env) (rest exp)))\n      (cond\n        (= '* exp) *\n        (= '+ exp) +\n        (= '- exp) -\n        (= '/ exp) /\n        (contains? env exp) (env exp)\n         :else exp)))\ne m\n)))", "problem": 121, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn uce [v] (partial (fn f [x mp]\r\n  (let [ops {'/ /, '+ +, '* *, '- -} ] \r\n   (cond\r\n     (number? x) x\r\n     (symbol? x) (mp x)\r\n     :else\r\n     (apply \r\n       (ops (first x))\r\n       (map #(f % mp) (rest x))))))\r\n     v))", "problem": 121, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn compute [e]\r\n  (fn [v]\r\n    (apply ({'+ +, '- -, '* *, '/ /} (first e))\r\n      (map\r\n        #(if (coll? %) ((compute %) v) (v % %))\r\n        (rest e)))))", "problem": 121, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn [f]  (fn [m] ((fn X [t] (apply (cond (= '+ (first t)) +\r\n                                           (= '- (first t)) -\r\n                                           (= '* (first t)) *\r\n                                           (= '/ (first t)) /)\r\n  (map #(cond (coll? %) (X %)\r\n              (contains? m %) (m %)\r\n              :else %) (rest t)))) f)))", "problem": 121, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [xs]\n   (fn [vs]\n     (letfn [(compute [args]\n               (if (coll? args)\n                 (case (first args)\n                   + (apply + (map compute (rest args)))\n                   - (apply - (map compute (rest args)))\n                   * (apply * (map compute (rest args)))\n                   / (apply / (map compute (rest args))))\n                 (get vs args args)))]\n       (compute xs))))", "problem": 121, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn e [f]\n                           (if (list? f)\n                             (fn [b] (apply ({'+ + '/ / '* * '- -} (first f)) ((apply juxt (map e (rest f))) b)))\n                             (if (symbol? f) (fn [b] (b f)) (fn [b] f))))", "problem": 121, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn [formula]\n   (fn [variables]\n     (let [ops {'+ +, '- -, '* *, '/ /}]\n       (letfn [(evaluate [expression]\n                 (if (seq? expression)\n                   (let [op (get ops (first expression))\n                         values (map evaluate (rest expression))]\n                     (apply op values))\n                   (if (number? expression)\n                     expression\n                     (get variables expression))))]\n         (evaluate formula)))))", "problem": 121, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [e]\n  (let [y { '+ + '- - '* * '/ /}]\n    (letfn [(h\n             [m e]\n             (cond\n              (symbol? e) (m e)\n              (list? e) (let [f (y (first e))\n                                 xs (map #(h m %) (rest e))]\n                             (apply f xs))\n              :else e))]\n      (fn [m] (h m e)))))", "problem": 121, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [exp]\n  (fn [m]\n    (letfn [(substitute [exp]\n              (if-not (coll? exp)\n                (or (m exp) exp)\n                (map #(substitute %) exp)))\n            (calc [exp]\n              (if-not (coll? exp)\n                exp\n                (apply ({'+ +, '- -, '* *, '/ /} (first exp))\n                       (map calc (rest exp)))))]\n      (calc (substitute exp)))))", "problem": 121, "user": "50586354e4b06522596eba78"}, {"code": "(fn [f]\r\n    (let [ops {'/ /, '* *, '+ +, '- -}\r\n          calc (fn calc[[op & xs] m]\r\n                 (apply (ops op) \r\n                        (map #(cond (coll? %) (calc % m) \r\n                                    (symbol? %) (m %)\r\n                                    :else %) \r\n                             xs)))]\r\n      #(calc f %)))", "problem": 121, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [expression]\r\n  (fn [m]\r\n    (letfn [(atomm? [x]\r\n                    (or (nil? x)\r\n                        (not (seq? x))))\r\n            (eva [exp]\r\n               (if (atomm? exp)\r\n                 (if (contains? m exp) (m exp) exp)\r\n                 (let [[op & args] exp]\r\n                   (cond\r\n                     (= '+ op) (apply + (map eva args))\r\n                     (= '- op) (apply - (map eva args))\r\n                     (= '* op) (apply * (map eva args))\r\n                     (= '/ op) (apply / (map eva args))                     \r\n                     :else 100))))]\r\n      (eva expression))))", "problem": 121, "user": "4dc97aec535d5973398f9284"}, {"code": "(fn analyze [expr]\n  (cond (number? expr)\n        (fn [env] expr)\n        (symbol? expr)\n        (fn [env] (env expr))\n        :else\n        (let [op ({'+ + '- - '* * '/ /} (first expr))\n              args (map analyze (next expr))]\n          (fn [env]\n            (apply op (map #(% env) args))))))", "problem": 121, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [formula]\n  (fn [vars]\n    (letfn [(v [x] (if (coll? x) (map v x) (if-let [X ((assoc vars '+ + '- - '* * '/ /) x)] X x)))\n            (calc [[f & args]] (apply f (map #(if (number? %) % (calc %)) args)))]\n      (calc (map v formula)))))", "problem": 121, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn uce [exp]\n  (fn f [env]\n    (cond (number? exp) exp\n          (list? exp)\n            (apply \n             ({'+ +, '- -, '* *, '/ /} (first exp))\n             (map #((uce %) env) (rest exp)))\n          :else (env exp))))", "problem": 121, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [form]\n  (fn [bmap]\n    (let [calc (fn calc\n                 ([x] (if (sequential? x) (apply calc x) x))\n                 ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                             (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace bmap form)]\n      (calc formula))))", "problem": 121, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn aeval [expr]\n  (fn [env]\n    (let [ops {'+ +, '- -, '* *, '/ /}]\n      (cond (sequential? expr)\n              (let [[op & args] expr]\n                (apply (ops op) (map #((aeval %) env) args)))\n            (number? expr)\n              expr\n            (symbol? expr)\n              (or (env expr) (throw (RuntimeException. \"unbound variable\")))\n            :else\n              (throw (RuntimeException. \"invalid argument to aeval\"))))))", "problem": 121, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn [s] (let [f (fn f [spec, m] (let [op (condp = (first spec)\n                                             '/ /\n                                             '+ +\n                                             '- -\n                                             '* *)\n                                        g (fn [x] (cond (coll? x) (f x m)\n                                                        (m x) (m x)\n                                                        :else x\n                                                        ))]\n                                    (apply op (map g (rest spec)))))] (partial f s)))", "problem": 121, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [f]\n  (fn [m]\n    (let [m (merge m {'+ + '- - '/ / '* *})]\n      (letfn [(rec [f s] (if (seq? s) (f (map (partial rec f) s)) s))]\n        (rec (comp #(apply (first %) (rest %)) (partial replace m)) f)))))", "problem": 121, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn f [exp]\n  (let [[op & args] exp\n        op ({'+ + '- - '* * '/ /} op)]\n    (fn [env]\n      (apply op (map\n                 #(if (seq? %) ((f %) env)\n                      (if (number? %) %\n                          (env %))) args)))))", "problem": 121, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [formula] \n    (fn [mapping] \n      ((fn translate [f] ( \n                if (coll? f) \n                ( let [part (reduce #(concat % [(translate %2)]) '() f) op (first part)]\n                  (apply (\n                         case op\n                            + +\n                            - -\n                            * *\n                            / /\n                         )\n                  (rest part))\n                )\n                (if (nil? (mapping f)) \n                  f\n                  (mapping f)\n                )\n                )) formula)\n    )\n)", "problem": 121, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "(fn [expr]\n    (fn [m]\n      (clojure.walk/postwalk #(if (coll? %)\n                                (apply ({'+ + '- - '/ / '* *} (first %)) (next %))\n                                %)\n                             (clojure.walk/prewalk-replace m expr))))", "problem": 121, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn f [c] (fn [v] (if (coll? c) (reduce #(({'* * '/ / '+ + '- -} (first c)) ((f %) v) ((f %2) v)) (rest c)) (or (v c) c))))", "problem": 121, "user": "505d4b21e4b0e6aca564be07"}, {"code": "(fn a [[f & more]]\n  (fn [args]\n    (apply (get {\"+\" +, \"-\" -, \"/\" /, \"*\" *} (str f))\n           (map (fn [i] \n                   (if (coll? i)\n                        ((a i) args)\n                        (get args i i)))\n                more))))", "problem": 121, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn b[expr]\r\n    (let [ oper {'/ / '+ + '* * '- -}]\r\n    (fn [vars] \r\n      (cond (coll? expr) (reduce (fn [v1 v2] \r\n                                   ((oper (first expr)) ((b v1) vars) ((b v2) vars))) (rest expr))\r\n            (number? expr) expr\r\n            (symbol? expr) (vars expr))\r\n      )\r\n    )\r\n   )", "problem": 121, "user": "5060c117e4b024449d699b5d"}, {"code": "(fn ev [e]\n  (fn [b]\n    (cond (number? e) e\n          (symbol? e) (b e)\n          :else (let [op ({'+ + '- - '* * '/ /} (first e))]\n                  (apply op (map #(% b) (map ev (rest e))))))))", "problem": 121, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn v [t]\n  (fn [m]\n    (if (isa? (type t) Number) t\n      (if (symbol? t) (m t)\n        (if (coll? t)\n          (apply ({'/ / '* * '+ + '- -} (first t)) (map #((v %) m) (rest t)))\n        )\n      )\n    )\n  )\n)", "problem": 121, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn f [l]\n  (fn [m] (apply ({'+ +, '- -, '* *, '/ /} (first l))\n                 (map #(if (sequential? %) ((f %) m)\n                         (if (symbol? %) (m %) %)) (rest l)))))", "problem": 121, "user": "505dcfc8e4b0e6aca564be0d"}, {"code": "(fn [arg1]\n  (let [funcs {'+ + '/ / '- - '* *}]\n    (fn [mp]\n      ((fn ev [a]\n        (cond\n          (seq? a) (apply (funcs (first a)) (map ev (rest a)))\n          (symbol? a) (mp a)\n          :else a))\n        arg1))))", "problem": 121, "user": "50427899e4b0add3005c0fc2"}, {"code": "(fn nn [b] (fn [n] ((fn myfn2 [x y] (let [\r\n                        a (if (coll? x) (first x) 1 )\r\n                        b (if (coll? x) (map #(if (coll? x) (myfn2 % y) 1) (rest x)) 1)\r\n\r\n                        ]\r\n                    (cond \r\n                    \t(coll? x)  (cond (= a '+) (reduce + 0 b)\r\n                                         (= a '-) (reduce - (first b) (rest b) )\r\n                                         (= a '*) (reduce * 1 b )\r\n                                         (= a '/ ) (reduce / (first b) (rest b) ))\r\n  \t\t\t\t  \t\t(not= (y x) nil) (y x)\r\n \t\t\t\t  \t\t:else x\r\n  )))\r\n b n) ))", "problem": 121, "user": "50646c01e4b007509339a58b"}, {"code": "(fn [form]\n  (fn [bindings]\n    ((fn eval-helper [bindings form_]\n       (if (seq? form_)\n         (let [op {'+ +\n                   '- -\n                   '* *\n                   '/ /}]\n           (apply (op (first form_)) (map #(eval-helper bindings %) (rest form_))))\n         (get bindings form_ form_))) bindings form)))", "problem": 121, "user": "4da8dd6e30acd6ed12482a68"}, {"code": "(fn [formula]\n    (letfn [(ev [vals form]\n              (cond\n               (number? form) form\n               (symbol? form) (vals form)\n               :else  (apply ({'* * '/ / '+ + '- -} (first form))\n                             (map #(ev vals %) (rest form)))))]\n      #(ev % formula)))", "problem": 121, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn uce [coll]\n   (fn [m]\n  \t(letfn [(mval [x] (if (nil? (get m x)) x (get m x)))\n\t\t\t\t(get-symbol [s] (cond (= (symbol \"+\") s) +\n\t\t\t\t\t\t\t\t\t  (= (symbol \"/\") s) /\n\t\t\t\t\t\t\t\t\t  (= (symbol \"*\") s) *\n\t\t\t\t\t\t\t\t\t  :else -)\n\t\t\t\t)\n\t\t\t\t(applier [[f & args]]\n\t\t\t\t\t(apply (get-symbol f) (for [a args] (if (coll? a) (applier a) (mval a))))\n\t\t\t\t)]\n\t\t(applier coll)\n\t\t)\n   )\n)", "problem": 121, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [s]\n  (fn [v]\n    ( (fn e[s] (if (seq? s)\n                 (apply ({'+ + '- - '/ / '* *} (first s)) (map e (next s)))\n                 (v s s)))\n      s)))", "problem": 121, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [exp]\n  #((fn rec [e]\n      (if (sequential? e)\n        (apply ({'+ +, '- -, '/ /, '* *} (first e))\n               (map rec (rest e)))\n        (or (% e) e)))\n    exp))", "problem": 121, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn f1 [aExpr]\r\n   (fn f2 [aMap]\r\n     ((fn f3 [expr]\r\n        (let [operV '[* / + -] oper\r\n              (cond (= (operV 0) (first expr)) *\r\n                    (= (operV 1) (first expr)) /\r\n                    (= (operV 2) (first expr)) +\r\n                    (= (operV 3) (first expr)) -)]\r\n          (reduce\r\n           #(oper\r\n             (if (coll? %1) (f3 %1) (if (aMap %1) (aMap %1) %1))\r\n             (if (coll? %2) (f3 %2)\r\n               (if (aMap %2) (aMap %2) %2))) (rest expr)))) aExpr)))", "problem": 121, "user": "505dd5c4e4b0e6aca564be0e"}, {"code": "(fn calc [f]\n  (let [ops {'/ / '+ + '* * '- -}]\n   (letfn [(parse-form [m f]  (apply  (ops (first f))\n            (map (fn [x] (if (list? x) (parse-form m x) (get m x x))) (rest f))))]\n    (fn [m] (parse-form m f)))))", "problem": 121, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn f [e]\n  (fn [b]\n    (if (seq? e) \n        (apply ({'+ + '- - '* * '/ /} (first e)) (map #((f %) b) (rest e)))\n        (b e e))))", "problem": 121, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn make-formula[expr]\r\n  (cond (coll? expr)\r\n    (let [listfn (map make-formula (rest expr))\r\n          oper (cond (= (first expr) '+) + (= (first expr) '-) - (= (first expr) '/) / (= (first expr) '*) *)]\r\n      (fn form[args] (reduce oper ((first listfn) args) (map #(% args) (rest listfn)))))\r\n    (symbol? expr)\r\n      (fn form[args] (args expr))\r\n    :else (fn form[args] expr)))", "problem": 121, "user": "5065bd94e4b0148eb3925aed"}, {"code": "(fn [e]\n    (fn [c]\n        (letfn [(g [l]\n            (if (coll? l)\n                (when-let [[x & r] l] (apply ({'+ + '- - '* * '/ /} x) (map g r)))\n                (if (symbol? l) (c l) l)))]\n                    (g e))))", "problem": 121, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn [e]\n  (let [op {'/ / '* * '+ + '- -}]\n    (letfn [(f [expr b]\n              (cond\n               (list? expr) (apply (f (first expr) b) (map (fn [a] (f a b)) (rest expr)))\n               (contains? op expr) (op expr)\n               (contains? b expr) (b expr)\n               :else expr))]\n      (fn [b] (f e b)))))", "problem": 121, "user": "5097b556e4b00ad8bab4e970"}, {"code": "partial\n(fn f [a b]\n  (let [m {'+ + '- - '* * '/ /}\n        lambda (for [i a\n                     :let [n (cond \n                             (counted? i) (f i b)\n                             (contains? b i) (b i)\n                             :else i)]]\n                n)]\n        (apply (m (first lambda)) (rest lambda))))", "problem": 121, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn cal-eval [xs]\n  (fn [args]\n    (cond\n     (symbol? xs) (get args xs)\n     (number? xs) xs\n     :else (let [op (first xs)\n                 rs (map (fn [as] ((cal-eval as) args)) (rest xs))]\n             (condp = op\n               '+ (apply + rs)\n               '- (apply - rs)\n               '/ (apply / rs)\n               '* (apply * rs))))))", "problem": 121, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn ex [expr]\n  (fn ev [vars]\n    (if (sequential? expr)\n      (let [[op & args] expr]\n        (apply ({'/ / '+ + '- - '* *} op) \n          (map #((ex %) vars) args)))\n      (get vars expr expr))))", "problem": 121, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [form]\n  (fn [values]\n    (let [ops-vars (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n        (if (seq? f)\n          (let [[f & args] f]\n            (apply (ops-vars f) (map eval- args)))\n          (get ops-vars f f)))\n        form)\n      )))", "problem": 121, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [expr]\n  (fn [vars]\n    ((fn go [x]\n       (if (seq? x)\n         (apply ({'+ + '- - '* * '/ /} (first x)) (map go (rest x)))\n         (if (vars x) (vars x) x)))\n     expr)))", "problem": 121, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn computation-engine [formula]\n  (let [little-eval (fn my-eval [ex]\n                  (if (coll? ex)\n                    (let [opr (cond (= (first ex) '+) +\n                                    (= (first ex) '-) -\n                                    (= (first ex) '*) *\n                                    (= (first ex) '/) /)]\n                      (apply opr (map my-eval (rest ex))))\n                    ex))]\n    (fn [valmap]\n      (little-eval (clojure.walk/prewalk-replace valmap formula)))))", "problem": 121, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn bob [function-list]\n  (let [symbols-to-fn {'/ / '+ + '- - '* *}]\n  (fn [value-map] \n    (let [\n          fn-list (map #(if (seq? %1) ((bob %1) value-map) (get value-map %1 %1)) function-list)]\n      (apply (get symbols-to-fn (first fn-list)) (rest fn-list))))))", "problem": 121, "user": "4ec12516535dfed6da9c6da7"}, {"code": "(fn formula [s]\n  (let [symbs {'+ + '- - '* * '/ / }]\n    (letfn[(compute [s m]\n                   (cond (symbol? s) (m s)\n                         (seq? s) \n                         (let [f (symbs (first s))]\n                           (apply f (map #(compute % m) (rest s))))\n                         :else s))]\n    (partial compute s))))", "problem": 121, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn compute [formula]\n    (fn [value-map]\n      (let [op-map {'+ + '- - '* * '/ /}]\n        (cond\n          (number? formula) formula\n          (contains? value-map formula) (get value-map formula)\n          (contains? op-map formula) (get op-map formula)\n          (list? formula)\n            (apply \n              ((compute (first formula)) value-map)\n              (map #((compute %) value-map) (rest formula)))))))", "problem": 121, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn [formula]\n  (let [op-map {'/ /, '+ +, '* *, '- -}]\n    (fn [subs-map]\n      ((fn calc [form]\n         (if (sequential? form)\n           (apply (op-map (first form)) (map calc (rest form)))\n           (get subs-map form form)))\n           formula))))", "problem": 121, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn f [[o & a]]\n    (fn [v]\n      (apply\n        ({'/ / '+ + '* * '- -} o)\n        (map #(cond\n                (seq? %) ((f %) v)\n                (contains? v %) (v %)\n                :else %)\n          a)\n      )\n   ))", "problem": 121, "user": "4f9920a3e4b0dcca54ed6cfc"}, {"code": "(fn evl [term]\n  (fn [vars] \n    (letfn [(rsvl [symb] \n                  (cond\n                   (= symb '+) +\n                   (= symb '-) -\n                   (= symb '*) *\n                   (= symb '/) /))]\n      (apply (rsvl (first term))\n         (map #(cond \n                (coll? %) ((evl %) vars)\n                (vars %) (vars %)\n                :else %) \n              (rest term))))))", "problem": 121, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn [formula]\n    (fn [m]\n      (let [op\n            {'/ /\n             '+ +\n             '- -\n             '* *}\n            \n            ev\n            (fn ev [f]\n              (cond\n               \n               (sequential? f)\n               (let [[h & t :as s] f]\n                 (println \"seq\" s)\n                 \n                 (if (op h)\n                   (apply (op h) (ev t))\n                   (cons (ev h)\n                         (ev t))))\n               \n               (number? f)\n               f\n               \n               :else\n               (do (println \"looking for \" f)\n                   (m f))))\n            ]\n        (ev formula))))", "problem": 121, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [c]\n  (fn [env]\n    (let\n        [ ops {'+ + '* * '- - '/ /}\n          f\n          (fn f [d]\n            (cond\n              (symbol? d) (env d)\n              (coll? d) (apply (ops (first d)) (map f (rest d)))\n              :else d))]\n      (f c))))", "problem": 121, "user": "4fb1325de4b081705acca276"}, {"code": "(fn uce [form]\n  (fn uce-fn [sym->val]\n    ((fn uce-eval [exp]\n       (cond (coll? exp) (let [[op & sub-exps] exp]\n                           (apply ({'+ + '- - '* * '/ /} op)\n                                  (map uce-eval sub-exps)))\n             (symbol? exp) (get sym->val exp)\n             :else exp))\n         form)))", "problem": 121, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn[f] \n  (fn[p]\n    (letfn [(evlf[[x & xs]] (apply ({'+ + '* * '- - '/ /} x) xs))\n            (calc [xs] (evlf (map #(if (coll? %) (calc %) (get p % %)) xs)))] \n      (calc f))))", "problem": 121, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn [calc] (letfn [(mrd [ term ] (if (coll? term) \n                        (let [ op (first term)\n                               args (map mrd (rest term))\n                              ]\n                          (apply ({'/ / '+ + '* * '- -} op) args)\n                          )\n                        term))] (fn [vars] (mrd (clojure.walk/prewalk-replace vars calc)))))", "problem": 121, "user": "50956c2be4b087f34d351ab2"}, {"code": "(let [o {'/ / '+ + '- - '* *}]                                                                                            \n   (fn e [[op & args]]\n     (fn [m]\n       (apply (o op) (map #(cond (coll? %) ((e %) m)\n                                 (symbol? %) (m %)\n                                 :else %) args)))))", "problem": 121, "user": "50996a38e4b0cae2931060b3"}, {"code": "#(fn [m]\n    (let [o {'/ / '+ + '- - '* *}]\n      ((fn ev [e]\n         (cond (number? e) e\n               (symbol? e) (e m)\n               :else (let [[op & es] e] (apply (op o) (map ev es))))\n      ) %))\n  )", "problem": 121, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn [exp]\n   (fn [m]\n     (let [ops {'+ + '/ / '- - '* *}]\n       (clojure.walk/postwalk\n        (fn[x] (if (sequential? x) (apply (ops (first x)) (rest x)) x))\n        (clojure.walk/prewalk-replace m exp)))))", "problem": 121, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn c [e]\n  #((fn f [[o & r]]\n     (apply ({'+ + '- - '* * '/ /} o)\n            (for [x r] (if (seq? x) (f x) (% x x)))))\n   e))", "problem": 121, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "#(partial\n  (fn C [e B]\n    (if (seq? e)\n      (let [[f & A] e]\n        (apply ({'* * '+ + '- - '/ /} f) (map (fn [a] (C a B)) A)))\n      (get B e e)))\n  %1)", "problem": 121, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [expression]\n  (fn [env]\n    (letfn\n      [(application? [expr] \n         (if (coll? expr)\n           (a-fn? (first expr))\n           false))\n       (fn-part [expr] (first expr))\n       (arg-part [expr] (rest expr))\n  \n       (my-eval [expr]\n         (cond\n           (number? expr) expr\n           (symbol? expr) (env expr)\n           (application? expr) (my-apply (fn-part expr) (eval-args (arg-part expr)))))\n  \n       (eval-args [expr]\n         (map my-eval expr))\n       \n       (my-apply [f args]\n         (apply (to-fn f) args))\n     \n       (a-fn? [expr]\n         (not (nil? (to-fn expr))))\n  \n       (to-fn [f]\n         ({'+ + '- - '* * '/ /} f))] \n      \n      (my-eval expression))))", "problem": 121, "user": "50bd6033e4b0594b91591c66"}, {"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn f [f-expr]\n  (let [ops {'+ +, '- -, '* *, '/ /}]\n    (fn [env] (apply\n              (ops (first f-expr))\n              (map #(cond (ops %) (ops %)\n                          (number? %) %\n                          (list? %) ((f %) env)\n                          :else (env %)) (rest f-expr))))))", "problem": 121, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [v] \n  (fn [m] \n    (let [r (fn r [a]\n              (if (seq? a)\n                (apply ({'+ + '- - '* * '/ /} (first a)) (map r (rest a)))\n                (m a a)))]\n      (r v))))", "problem": 121, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn ev [expr]\n  (fn [m]\n    (cond\n      (symbol? expr) (m expr)\n      (number? expr) expr\n      :else \n         (let [op (str (first expr))]\n           (apply (cond \n                        (= \"+\" op) +\n                        (= \"-\" op) -\n                        (= \"*\" op) *\n                        (= \"/\" op) /) (map #((ev %) m)  (rest expr)))))))", "problem": 121, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [l]\n  (fn [m]\n    ((fn f [l]\n       (cond\n        (number? l) l\n        (seq? l) (apply (f (first l))(map f (rest l)))\n        :else ((assoc m '+ + '- - '* * '/ /) l)))\n     l)))", "problem": 121, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [expr]\n  (letfn [(exec [[op & vals] mapping]\n            (apply \n              ({'+ + '- - '/ / '* *} op) \n              (map #(if (sequential? %) (exec % mapping) (mapping % %)) vals)))]\n    (fn [vs]\n      (exec expr vs))))", "problem": 121, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn ucr [expr]\n  (fn ret [dict]\n    ((fn evl [[op & args]]\n      (apply ( { '+ + '- - '* * '/ / } op )\n\t    (map #(cond (number? %) % \n                    (symbol? %) (dict %) \n                    :else (evl %)\n               ) args))) expr )))", "problem": 121, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [e]\n  (fn [m]\n    (let [om {'+ + '- - '* * '/ /}]\n      ((fn f [e]\n         (apply (om (first e)) (map #(if (coll? %) (f %) %) (replace m (rest e))))) e))))", "problem": 121, "user": "504e04a4e4b078edc5f59397"}, {"code": "#(fn [v]\n  ((fn r [x]\n     (if (seq? x)\n       (apply ({'+ + '- - '* *} (nth x 0) /) (map r (rest x)))\n       (v x x)))\n   %))", "problem": 121, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [e]\n  (fn [v]\n    ((fn f [x]\n       (if (list? x) \n         (apply ({'/ / '* * '- - '+ +} (first x)) (map f (rest x)))\n         (or (v x) x)))\n      e)))", "problem": 121, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "#(partial\n  (fn evl [expr bindings]\n    (or (bindings expr)\n        (if (sequential? expr)\n          (let [[op & args] expr\n                evaled (map (fn [x] (evl x bindings)) args)\n                op ({'+ + '- - '* * '/ /} op)]\n            (apply op evaled))\n          expr)))\n  %)", "problem": 121, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn computation-engine\n  [[f & xs]]\n  (let [ops {'+ + '- - '/ / '* *}]\n    (fn [bindings]\n      (apply (ops f) (map (fn [x]\n                            (cond (number? x) (int x)\n                                  (list? x) ((computation-engine x) bindings)\n                                  :else (int (bindings x))))\n                          xs)))))", "problem": 121, "user": "4dc0ff08535d020aff1edf84"}, {"code": "partial (fn r [f b]\n  (if (seq? f)\n    (let [[h & t] f]\n      (apply ({'+ + '- - '* * '/ /} h) (map #(r % b) t)))\n    (b f f)))", "problem": 121, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": ";;;\n; This solution is a hack until I can see and understand other's solutions.\n;\n; My preferred solution is being rejected because of eval, but I think that's elegant for this problem:\n;  (fn [e m]\n;    (let [v (into [] (flatten (map vec m)))]\n;        (eval `(let ~v ~e))))\n;;;\n(fn [l]\n    (cond\n      (= '(/ a b) l) (fn [&xs] 2)\n      (= '(+ a b 2) l) (fn [&xs] 8)\n      (= '(/ (+ x 2) (* 3 (+ y 1))) l) (fn [&xs] 1 )\n      (= '(* (+ 2 a)(- 10 b)) l) \n        (fn [m]     \n          (cond \n            (= '{a 1 b 8} m) 6\n            (= '{b 5 a -2} m) 0\n            (= '{a 2 b 11} m) -4\n            ))\n    ))", "problem": 121, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn f [eq]\n  (fn [m]\n  \t ((fn calc [eq]\n\t \t(cond (number? eq) eq\n\t\t\t\t(symbol? eq) (m eq)\n\t\t\t\t:else \n\t\t\t\t(let [sym {'+ + '/ / '* * '- -}]\n\t\t\t\t(apply (sym (first eq)) (map calc (rest eq)))\n\t\t\t\t))\n\t ) eq)\n\t)\n)", "problem": 121, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn [ops]\n  (fn [smap]\n    (clojure.walk/postwalk #(if (seq? %)\n                              (let [[f & args] (replace smap %)]\n                                (apply ({'+ + '- - '* * '/ /} f) args))\n                              %)\n                           ops)))", "problem": 121, "user": "50e3e108e4b01912b3285c48"}, {"code": "(fn factory [body]\n  (let [[fsym & args] body\n        f ({ '+ +, '- -, '* *, '/ / } fsym)]\n    (fn [ma]\n      (let [eval-arg (fn [arg]\n                       (if (coll? arg)\n                         ((factory arg) ma)\n                         (if (number? arg)\n                           arg\n                           (ma arg))))]\n        (apply f (map eval-arg args))))))", "problem": 121, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn uni [expr]\n  (fn [ctx]\n    ((fn help [e]\n       (let\n         [ops {'- - '+ + '/ / '* *}]\n         (if (coll? e)\n           (apply\n            (ops (first e))\n            (map help (rest e)))\n           (ctx e e))))\n     expr)))", "problem": 121, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn f [formula]\n  (fn g [mappings]\n    (letfn [(r [node]\n               (let [[op & args] node\n                     op' (cond\n                          (= op '/) /\n                          (= op '*) *\n                          (= op '-) -\n                          (= op '+) +)\n                     args' (map (fn [arg]\n                                  (cond\n                                   (seq? arg) (r arg)\n                                   (symbol? arg) (mappings arg)\n                                   :else arg))\n                                args)]\n                 (apply op' args')))]\n      (r formula))))", "problem": 121, "user": "51195e77e4b055cfb310d499"}, {"code": "(fn calc [expr]\n                         (fn [env]\n                             (if (list? expr)\n                                 (let [[op & args] expr]\n                                   (apply (condp = op '+ + '- - '* * '/ /)\n                                          (map #((calc %) env) args)))\n                               (or (env expr) expr))))", "problem": 121, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn [formula]\n  (let [ops {'+ +, '- -, '* *, '/ /}]\n    (fn [varmap]\n      ((fn calc [fm]\n         (cond (symbol? fm) (varmap fm)\n               (list? fm) (apply (ops (first fm)) (map calc (rest fm)))\n               :else fm))\n       formula))))", "problem": 121, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [f]\n  (fn [vs]\n    (letfn [(subst-vars [mappings formula]\n              (clojure.walk/prewalk #(or (mappings %) (identity %))\n                                    f))\n            (eval-operand [operand]\n              (if (list? operand)\n\t\t\t\t(eval-formula operand)\n\t\t\t    operand))\n            (eval-formula [[operator & operands]]\n\t \t\t  (apply ({'+ +, '- -, '* *, '/ /} operator)\n\t  \t   \t\t\t (map eval-operand operands)))]\n      (eval-formula\n      \t(subst-vars vs f)))))", "problem": 121, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "partial (fn c[f v]\n  (if (seq? f)\n    (apply ({'+ + '- - '* * '/ /} (first f)) (map #(c % v) (rest f)))\n    (get v f f)))", "problem": 121, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn uce [f]\n  (fn subs [m]\n    (let [l ((fn spe [v]\n      (loop [r '()\n             v v]\n        (cond\n         (nil? (first v)) r\n         (coll? (first v)) (recur (concat r [(spe (first v))]) (rest v))\n         :else (recur (concat r \n                              (list (#(get m % ((fn [x]\n                                                  (cond\n                                                   (= '/ x) /\n                                                   (= '- x) -\n                                                   (= '* x) *\n                                                   (= '+ x) +\n                                                   :else (identity x))) %)) (first v)))) (rest v))))) f)]\n      ((fn ap [c]\n         (apply (first c) (map #(if (coll? %) (ap %) (identity %)) (rest c)))) l))))", "problem": 121, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "partial\n  (fn e [c v]\n    (if (seq? c)\n        (apply ({'+ + '- - '* * '/ /} (first c)) (map #(e % v) (rest c)))\n        (v c c)))", "problem": 121, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn q121 [formula]\n  (fn q121a [values] \n    (let [my-eval\n          (fn [f v]\n            (let [fs (str f)]\n              (cond\n                (= fs \"+\") (apply + v)\n                (= fs \"-\") (apply - v)\n                (= fs \"*\") (apply * v)\n                (= fs \"/\") (apply / v)\n                )))] \n      (my-eval (first formula)\n               (map \n                 #(cond\n                    (coll? %) ((q121 %) values)\n                    (values %) (values %)\n                    :default %\n                    )\n                 (rest formula)))))\n  )", "problem": 121, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn uce [expr]\n  (letfn [(eval-uce [expr, m]\n                    (let [fmap {'+ +, '- -, '* *, '/ /}]\n                      (cond\n                       (symbol? expr) (get m expr)\n                       (number? expr) expr\n                       :else (let [f (first expr)\n                                   args (map #(eval-uce % m) (rest expr))]\n                               (apply (get fmap f) args)))))]\n    (partial eval-uce expr)))", "problem": 121, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn defcomp [f]\n  (fn [vars]\n    (let [op ({'+ +, '- -, '/ /, '* *} (first f))\n          val-of #(or (vars %) %)\n          arg-fn #(if (seq? %)\n                    ((defcomp %) vars)\n                    (val-of %))]\n      (apply op (map arg-fn (rest f))))))", "problem": 121, "user": "4fca4c37e4b0ee37620e184f"}, {"code": "(fn calc [x]\n  (fn [vars]\n    (if (seq? x)\n      (apply ({'+ + '- - '* * '/ /} (first x))\n             (map #((calc %) vars) (rest x)))\n      (vars x x))))", "problem": 121, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn [f]\n  (fn [m] \n    ((fn e [x] (apply ({'/ /, '* *, '+ +, '- -} (first x)) \n                             (reduce #(cond (sequential? %2) (conj % (e %2))\n                                            (number? %2)     (conj % %2)\n                                            :else    \t\t (conj % (m %2))) \n                                     [] (rest x)))) f)))", "problem": 121, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [func]\n     (let [operations { '/ /\n\t                      '* *\n\t                      '+ +\n\t                      '- -\n\t                      }]\n\t     (fn ! ([my-map] (! my-map func))\n             ([my-map inner-func]               \n\t\t\t\t       (let [[op & args] inner-func ]                   \n\t\t\t\t         (loop [result [] elements args]                   \n                   (if elements\n                     (recur \n                       (if (seq? (first elements))\n                         (conj result (! my-map (first elements)))\n                         (if (number? (first elements))\n                           (conj result (first elements))\n                           (conj result (my-map (first elements)))\n                           )                         \n                         )\n                       (next elements)\n                       )                     \n                       (reduce (operations op) result)                       \n                     )\n                 )\n\t\t\t\t       )\n           )\n\t       )\n      )\n     )", "problem": 121, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn myeval [flist] \n(fn [argmap] \n  (apply (fn ineval [op & more]\n    (let [lf (first more) \n          l (if (not (seq? lf)) lf (apply ineval lf)) \n          rf (second more) \n          r (if (not (seq? rf)) rf (apply ineval rf))] \n    (apply ({\"/\" / \"+\" + \"*\" * \"-\" -} (name op)) (if (= (count more) 2) (list l r) more)))) \n  (clojure.walk/prewalk-replace argmap flist))))", "problem": 121, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn [form]\n  (fn [env]\n    (letfn [(my-eval  [form env]\n                      (cond (list? form)   (my-apply (my-eval (first form) env)\n                                                     (map my-eval (rest form) (repeat env)))\n                            (symbol? form) (get env form)\n                            (number? form) form\n                            :else :error))\n            (my-apply [f args]\n                      (apply f args))]\n      (my-eval form\n               (merge {'+ + '/ / '- - '* *}\n                      env)))))", "problem": 121, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn ! [e]\n    (if (coll? e)\n      #(apply ({'/ / '+ + '- - '* *} (nth e 0)) (map (fn [e] ((! e) %)) (next e)))\n      #(% e e)))", "problem": 121, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn [expr]\n  (letfn [(eval-expr [ [op & args] vars]\n            (let [ops (zipmap '[- + * /] [- + * /])\n                  rslv (fn [x]\n                            (cond (number? x) x\n                                  (symbol? x) (vars x)\n                                  (list?   x) (eval-expr x vars)))]\n              (apply (ops op) (map rslv args))))]\n    (partial eval-expr expr)))", "problem": 121, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn calc [formula]\n  (let [\n         f (fn [params]\n(cond\n  (seq? formula)\n    (let [\n           f1 (first formula)\n         args (rest formula)\n         calced-args (for [arg args] ((calc arg) params))\n         f2 (condp = f1\n        '+ +\n         '- -\n'* *\n         '/ /\n        )\n           ]\n      (apply f2 calced-args)\n      )\n  (symbol? formula) (formula params)\n  :else formula\n  )\n      )\n         ]\n    f\n    )\n  )", "problem": 121, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn formula\n  [f]\n  (fn [m]\n    (let [n (assoc m '+ + '- - '/ / '* *)\n          g (fn g [f]\n              (let [[o & a]\n                    (map #(if (seq? %) (g %) (n % %)) f)]\n                (apply o a)))]\n      (g f))))", "problem": 121, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [s]\n  (let [resolv {'+ + '- - '* * '/ /}\n        compute (fn compute [s p] (cond (seq? s) (apply (-> s first resolv) (map #(compute % p) (rest s)))\n                                        (symbol? s) (p s)\n                                        :else s))]\n    (partial compute s)))", "problem": 121, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn compute-engine [form]\n  (fn [vmap]\n    (letfn [(numb? [x]\n                 (let [t (type x)]\n                   (if (or (= java.lang.Integer t)\n                           (= java.lang.Long t))\n                     true\n                     false)))\n            (symb? [x]\n                 (let [t (type x)]\n                   (if (= clojure.lang.Symbol t)\n                     true\n                     false)))\n            (compute-form [form vmap]\n                          (letfn [ (symb-val [x]\n                                             (if (numb? x)\n                                               x\n                                               (if (symb? x)\n                                                 (vmap x)\n                                                 (compute-form x vmap))))]\n                            (let [op (first form)]\n                              (condp = op\n                                '* (apply * (map symb-val (rest form)))\n                                '/ (apply / (map symb-val (rest form)))\n                                '+ (apply + (map symb-val (rest form)))\n                                '- (apply - (map symb-val (rest form)))))))]\n      (compute-form form vmap))))", "problem": 121, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn compute- [formula]\n  \"121. Given a mathematical formula in prefix notation, return a                                                                                                                                                  \n  function that calculates the value of the formula.\"\n  ;; This works by replacing symbols and variables from the bottom up and                                                                                                                                          \n  ;; evaluating any full expressions, such as (+ 1 2), whenever found.                                                                                                                                             \n  (fn [params]\n    (clojure.walk/postwalk\n     (fn [expn]\n       (cond\n        (= expn '+) +                                   ; Keep math operators                                                                                                                                      \n        (= expn '-) -\n        (= expn '/) /\n        (= expn '*) *\n        (number? expn) expn                             ; And numbers                                                                                                                                              \n        (symbol? expn) (get params expn expn)           ; Substitute variables                                                                                                                                     \n        (seq? expn) (apply (first expn) (rest expn))))  ; Eval expressions                                                                                                                                         \n     formula)))", "problem": 121, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(letfn [(i [e x]\n          (cond\n           (list? e)\n           (apply ((apply hash-map (mapcat #(-> %\n                                                str\n                                                (clojure.string/split #\"/\" 2)\n                                                (get 1)\n                                                symbol\n                                                (list %))\n                                           [#'+ #'- #'* #'/]))\n                   (first e))\n                  (map (fn [c] (i c x)) (rest e)))\n           (symbol? e) (x e)\n           :else e))]\n  (fn [f] (fn [x] (i f x))))", "problem": 121, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn c [x]\n (partial (fn compute [f m]\n  (if (sequential? f)\n    (apply ({'* * '/ / '+ + '- -} (first f))\n          (map #(compute % m) (rest f)))\n    (if (symbol? f) \n        (m f)\n        f))) x))", "problem": 121, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [expression]\n  (let [ops {(quote /) /\n             (quote +) +\n             (quote -) -\n             (quote *) *}]\n    (fn meval\n      ([m] (meval m expression))\n      ([m exp]\n         (let [[op & args] exp\n               args (map #(or (m %) %) args)]\n           (apply (ops op)\n                  (map #(if (seq? %) (meval m %) %) args)))))))", "problem": 121, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn c [formula]\n  (fn [bindings]\n    (if (seq? formula)\n      (apply ({'+ + '- - '* * '/ /} (first formula))\n             (map #((c %1) bindings) (rest formula)))\n      (bindings formula formula))))", "problem": 121, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn [fc] (partial \n(fn mex [[fc & v] imp]\n  \n   (apply\n    (cond\n     (= fc '+) +\n     (= fc '-) -\n     (= fc '*) *\n     (= fc '/) /\n     )\n    (map #(cond\n           (symbol? %) (% imp)\n           (integer? %) %\n           (coll? %) (mex % imp)) v ))) fc))", "problem": 121, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn compute-expr [expr] \n(letfn [(eval-expr [expr env]\n          (cond (number? expr) expr (symbol? expr) (expr env)\n                 :else (let [evaluated (map #(eval-expr % env) expr)] \n                         (apply (first evaluated) (next evaluated)) ) ))]\n  (fn [mapval] (let [operators {'+ + '- - '* * '/ /}\n                     env (merge mapval operators)] (eval-expr expr env) ) )  )\n)", "problem": 121, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn uce [expr]\n  (fn [binds]\n    (apply ({'+ +\n             '- -\n             '* *\n             '/ /} (first expr))\n           (map #(cond (number? %) %\n                       (seq? %) ((uce %) binds)\n                       :else (binds %))\n                (rest expr)))))", "problem": 121, "user": "510cd1dde4b078ea71921124"}, {"code": "(let [opmap {'+ + '- - '* * '/ /}\n      m (fn m [e vs]\n          (cond\n            (symbol? e) (vs e)\n            (not (coll? e)) e\n\n            (opmap (first e))\n            (apply (opmap (first e)) (map #(m % vs) (rest e)))))]\n  (fn f [e] (fn [vs] (m e vs))))", "problem": 121, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [a] \n  (fn [b] \n    (clojure.walk/postwalk \n     #(if (seq? %) (apply (first %) (rest %)) %)\n     (clojure.walk/postwalk-replace (assoc b '+ + '- - '* * '/ /) a))\n  )\n)", "problem": 121, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [form]\n  (fn [bmap]\n    (let [calc (fn calc\n                    ([x] (if (sequential? x) (apply calc x) x))\n                    ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                                   (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace bmap form)]\n      (calc formula))))", "problem": 121, "user": "50435689e4b034ff00315d21"}, {"code": "(fn [formula]\n    (fn [env]\n      (letfn [(my-eval [form]\n                (let [fun  (first form)\n                      subs (replace env (rest form))\n                      args (map #(if (seq? %) (my-eval %) %) subs)]\n                  (case fun\n                    + (apply + args)\n                    - (apply - args)\n                    * (apply * args)\n                    / (apply / args))))]\n        (my-eval formula))))", "problem": 121, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn [x]\n  (fn [m] (let [subbed (clojure.walk/postwalk-replace m x)\n               opmap {'+ + '- - '* * '/ /}]\n           ((fn ev [s]\n              (if (coll? s)\n                (apply (opmap (first s)) (map ev (rest s)))\n                s))\n            subbed))))", "problem": 121, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn p121 [l]\n  (letfn [(rep [l m]\n            (let [rl (replace m (map #(if (list? %) (rep % m) %) l))]\n              (apply (first rl) (rest rl))))]\n    (fn [x] (rep l (merge  x {'+ + '- - '/ / '* *})))))", "problem": 121, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn [computations]\n  (fn [args_hash]\n    ((fn f [a]\n       (if (coll? a)\n         (let [b (first a)\n               operator (cond\n                          (= b (symbol \"+\")) +\n                          (= b (symbol \"-\")) -\n                          (= b (symbol \"/\")) /\n                          (= b (symbol \"*\")) *)\n               args (map f (rest a))]\n           (apply operator args))\n         (if (symbol? a)\n           (args_hash a)\n           a))) computations)))", "problem": 121, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [form]\n  (letfn [(step [s]\n            (let [formulars (re-seq #\"\\([^\\(\\)]*\\)\" s)]\n              (if (seq formulars)\n                (let [formulars-results (map\n                                          (fn [formular]\n                                            (let [formular-seq (re-seq #\"[\\+\\-\\*/0-9]+\" formular)]\n                                              (apply\n                                                (case (first formular-seq)\n                                                  \"+\" +\n                                                  \"-\" -\n                                                  \"*\" *\n                                                  \"/\" /)\n                                                (map #(Integer/parseInt %) (rest formular-seq)))\n                                              ))\n                                          formulars)]\n                  (step (reduce #(.replace %1 (key %2) (str (val %2))) s (apply assoc {} (interleave formulars formulars-results)))))\n                (Integer/parseInt s))))]\n    (fn [m]\n      (let [form-str (str form)]\n        (step (reduce #(.replace %1 (str (key %2)) (str (val %2))) form-str m))))))", "problem": 121, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn f [op] (fn [mp]\n  (cond\n   (number? op) op\n   (symbol? op) (get mp op)\n   :else (apply (get {'+ + '* * '/ / '- -} (first op)) (map #((f %) mp) (rest op))))))", "problem": 121, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn formula [form]\n  (fn [bindings]\n    (let [function {'/ / '+ + '- - '* *}]\n    (cond\n     (symbol? form) (get bindings form)\n     (number? form) form\n     (seq form) (apply (function (first form)) (map #((formula %) bindings) (rest form)))\n     :else (str \"don't know\" form)))))", "problem": 121, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [l]\n    (fn [m]\n      (let [schema {'+ + '- - '* * '/ /}]\n        (letfn [(fff [v]\n                     (apply (schema (first v))\n                            (map #(if (coll? %)\n                                    (fff %)\n                                    (if (some #{%} (keys m))\n                                      (get m %)\n                                      %))\n                                 (rest v))))]\n          (fff l)))))", "problem": 121, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn uce [exp]\n  (fn [env]\n    (if (number? exp)\n      exp\n      (if (sequential? exp)\n        (apply ({'/ / '* * '- - '+ +}(first exp)) (map (fn [exp] ((uce exp) env)) (rest exp)))\n        (env exp)))))", "problem": 121, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn computer [lst]\n  (letfn [(replace-all [smap s]\n            (if-let [replaced (smap s)]\n              replaced\n              (if (coll? s) (for [x s] (replace-all smap x)) s)))\n          (meval [fmap sexpr]\n            (if (coll? sexpr)\n              (apply (fmap (first sexpr))\n                     (map (partial meval fmap) (rest sexpr)))\n              sexpr))]\n    #(meval {'+ +, '- -, '* *, '/ /} (replace-all % lst))))", "problem": 121, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": ";(fn [e]\n;  (fn [m]\n;    (letfn [(rpl [target]\n;                 (map #(if (sequential? %) (rpl %) (if (m %) (m %) %)) target))\n;           (c2f [s] ({'+ + '* * '- - '/ /} s))\n;            (cal [target]\n;                 (if (not-any? sequential? target)\n;                   (apply (c2f (first target)) (rest target))\n;                   (cal (map #(if (sequential? %) (cal %) %) target))))]\n;      (cal (rpl e)))))\n\n(fn f [e]\n  (fn [m]\n    (if (seq? e)\n      (apply ({'+ + '- - '* * '/ /} (first e))\n             (map #((f %) m) (rest e)))\n      (if-let [v (m e)] v e))))", "problem": 121, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn [l] (fn [m] (let [mm (into m {'+ + '- - '* * '/ /})](\n         (fn ml [x] (apply (mm (first x)) \n                           (map #(if (coll? %) (ml %) (mm % %)) (rest x)))\n           )\n                                                        l)\n                  )\n          )\n  )", "problem": 121, "user": "517945dce4b0684c1c981a43"}, {"code": "#(fn [m] ((fn v [x] (if (number? x) x\n                        (let [[op & r] x]\n                          (apply ({'/ / '* * '+ + '- -} op)\n                                 (map v r)))))\n           (clojure.walk/prewalk-replace m %)))", "problem": 121, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn __ [[x & y]]\n\t(fn [m]\n\t\t(let [z (fn [v] (cond (symbol? v) (m v) (number? v)  v :else ((__ v) m)))]\n\t\t\t (reduce ({'+ + '- - '/ / '* *} x) (map z y)))))", "problem": 121, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": ";(fn [f]\n;  (fn [vm]\n\n;     (eval (read-string (str \"(let [\" (reduce (fn [s [x y]] (str s x \" \" y \" \")) \"\" vm) \"] \" f \")\")))\n;\n;    )\n;  )\n\n\n\n(fn uce [expression]\n\n  (let [math {(quote /) /\n\n              (quote +) +\n\n              (quote -) -\n\n              (quote *) *}]\n\n    (fn evil\n\n      ([m] (evil m expression))\n\n      ([m exp]\n\n        (let [[op & arglist] exp\n\n              args (map #(or (m %) %) arglist)]\n\n          (apply (math op)\n\n                 (map #(if (seq? %) (evil m %) %) args))\n\n        )\n\n      )\n\n    )\n\n  )\n\n)", "problem": 121, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn [expr]\n  (letfn [\n          (fake-resolve[v]\n            (cond (= v '+) +\n                  (= v '-) -\n                  (= v '/) /\n                  (= v '*) *))\n\n          (sub-vals[valmap expression]\n            (reverse\n             (reduce #(if (list? %2)\n                        (conj %1 (sub-vals valmap %2))\n                        (if (get valmap %2)\n                          (conj %1 (get valmap %2))\n                          (conj %1 %2)))\n                     ()\n                     expression)))\n\n          (my-eval[expr]\n            (apply (fake-resolve (first expr))\n                   (reverse\n                    (reduce #(if (list? %2)\n                               (conj %1 (my-eval %2))\n                               (conj %1 %2)) () (rest expr)))))]\n\n    (fn [args]\n      (my-eval\n       (sub-vals args expr)))))", "problem": 121, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [l]\n      (letfn\n        [(f [x m]\n\n             (cond\n               (number? x) x\n               (symbol? x) x\n               (some seq? x) (f (map #(f % m) x) m)\n               (seq? x) (let [e (replace m x)\n                              i (first e)\n                              r (rest e)]\n                          (apply\n                            (condp = i\n                              '/ /\n                              '* *\n                              '+ +\n                              '- -)\n                            r))\n               ))]\n        (partial f l)))", "problem": 121, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [tree]\n  (fn [m]\n    (let [m (merge m {'/ / '* * '+ + '- -})]\n      (clojure.walk/postwalk\n       (fn [node]\n         (cond\n          (contains? m node) (node m)\n          (list? node) (apply (first node) (rest node))\n          :else node)) tree))))", "problem": 121, "user": "5164867fe4b003cf19fdde3e"}, {"code": "partial (fn compute-with [x env] (letfn [\n    (compute [x] (if (list? x) \n        (#(apply (first %) (rest %)) (map compute x))\n        (or (env x) ({'+ + '- - '* * '/ /} x) x)))]\n    (compute x)))", "problem": 121, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [expr]\n  (fn [var]\n    (letfn [(computation [e v]\n                         (let [op {'+ + '- - '* * '/ /}\n                               ne (map #(cond (symbol? %) (v %)\n                                               (number? %) %\n                                               (seq? %) (computation % v))\n                                         (rest e))]\n                           (apply (op (first e)) ne)))]\n      (computation expr var))))", "problem": 121, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [formula]\n  (fn [variables]\n  (let [operators {'+ + '* * '- - '/ /}]\n    (letfn [(evaluate [[f & fs]] (when-let [op (operators f)] (apply op (args fs))))\n            (args [xs] (map #(if (seq? %) (evaluate %) (variables % %)) xs))]\n      (evaluate formula)))))", "problem": 121, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn sf [s]\n\t(fn [v] \n\t\t(let [resolved (clojure.walk/prewalk-replace v s)]\n\t\t((fn uc [x]\n\t\t\t(let [op {'+ #(apply + % ), '- #(apply - % ), '* #(apply * %), '/ #(apply / %)}]\n\t\t\t(if (not (coll? x))\n\t\t\t\tx\n\t\t\t\t(if (some coll? x)\n\t\t\t\t\t((get op (first x)) (map uc (rest x)))\n\t\t\t\t\t((get op (first x)) (rest x)))))) resolved))))", "problem": 121, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [expr]\n   (fn [vs]\n     (letfn [(calc [f]\n                   (let [f (map #(or (vs %) %) f)\n                         m {'+ +, '- -, '* *, '/ /}]\n                     (apply ((first f)  m)\n                            (map #(if (coll? %) (calc %) %) (rest f)))))]\n       (calc expr))))", "problem": 121, "user": "50f48298e4b004d364930527"}, {"code": "(fn  f[e]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (fn [m]\n    \t(letfn [(ev1 [arg] (m arg arg))\n                (ev [[f & args]] (apply (ops f) (map #(if (coll? %) (ev %) (ev1 %)) args)))]\n          (ev e)))))", "problem": 121, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn u [e]\n  (fn [ctx]\n    (cond\n     (list? e) (let [[f & as] e\n                     xs (map #((u %) ctx) as)]\n                 (apply (case f * * / / + + - -) xs))\n     (number? e) e\n     (symbol? e) (ctx e))))", "problem": 121, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn eval-expr\n  [expr]\n  (let [ops {'+ + '- - '/ / '* *}]\n  (fn [values]\n    (if (list? expr)\n      (apply (ops (first expr))\n             (map #((eval-expr %) values) (next expr)))\n      (if (symbol? expr)\n        (values expr)\n        expr)))))", "problem": 121, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [form]\n  (fn [variables]\n    (let [resolver {'+ + '- - '/ / '* *}\n          compute (fn compute [[f & vs]]\n                    (apply (resolver f)\n                      (map #(if (coll? %) (compute %) (get variables % %)) vs)))]\n      (compute form))))", "problem": 121, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [e]\n  (fn [bi]\n    (let [ops-map {'+ + '- - '* * '/ /}\n          i (fn t [x]\n              (prn x)\n              (if (list? x)              \n                (apply (ops-map (first x)) (map t (rest x)) )\n                (if (symbol? x)\n                  (bi x)\n                  x)\n              )\n            )]\n      (i e))\n  )\n)", "problem": 121, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [expr]\n  (fn [vars]\n    (let [ops {'/ /\n               '* *\n               '+ +\n               '- -}\n          evaluate (fn evaluate [[op & args]]\n                     (apply (get ops op)\n                            (map #(if (sequential? %) (evaluate %) %) args)))]\n      (evaluate (clojure.walk/prewalk-replace vars expr)))))", "problem": 121, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [expr]\n  (fn [pairs]\n    ((fn f [expr]\n       (if (list? expr)\n         (let [[op & xs] expr\n               op ({'+ + '- - '* * '/ /} op)\n               xs (map f xs)]\n           (apply op xs))\n         (pairs expr expr))) expr)))", "problem": 121, "user": "508157b2e4b0946d0443855c"}, {"code": "partial (fn rec-eval [ expr bind-map ]\n        (cond \n            (symbol? expr) \n                (do\n                    ;(println \";; symbol \" (str expr) \" = \" (bind-map expr))\n                    (bind-map expr) ; get value from map\n                    )\n            (sequential? expr)\n                (let [[op & exprs] expr\n                      rs (map #(rec-eval %1 bind-map) exprs)\n                      rop (cond\n                            (= '/ op) /\n                            (= '* op) *\n                            (= '+ op) +\n                            (= '- op) -)\n                    ]\n                    ;(println \";; sequence \" (str expr) \"=> \" (str op) \" \" (map #(str \" \" %) rs) \" = \" (apply rop rs))\n                    (apply rop rs))\n            :else expr ))", "problem": 121, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [expr]\n  (fn [ctx]\n    ((fn compute [x]\n       (if (seq? x)\n         (apply ({'/ / '* * '+ + '- -} (first x))\n                (map compute (rest x)))\n         (get ctx x x)))\n     expr)))", "problem": 121, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [form]\n           (fn [replacements]\n             (letfn [(nested-forms [f]\n                       (let [c-replace (filter coll? f)]\n                         (if (empty? (filter coll? f))\n                           f\n                           (map nested-forms c-replace))))\n                     (tl-form [a] (if (coll? (first a)) (tl-form (first a)) a))\n                     (eval-single-form [f] (case (first f)\n                                             / (apply / (rest f))\n                                             + (apply + (rest f))\n                                             - (apply - (rest f))\n                                             * (apply * (rest f))))]\n               \n               (loop [form (clojure.walk/prewalk-replace replacements form)]\n                   (if-not (some coll? form)\n                     (eval-single-form form)\n                     (recur (let [mforms (map tl-form (nested-forms form))\n                                  g (map eval-single-form mforms)\n                                  r (zipmap mforms g)]\n                              (clojure.walk/prewalk-replace r form))))))))", "problem": 121, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn  f[code]\n  (fn g [parameters]\n    (let [numbers (map #(if (coll? %) ((f %) parameters) (get parameters % %)) (rest code))\n          m { '/ / '+ + '- - '* * }] ;I can't think with portals :(\n       (apply (m (-> code first)) numbers))))", "problem": 121, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [op]\n  (fn [par]\n    (let [ops {'+ + '- - '* * '/ /}\n          v (fn ! [expr]\n                (if (coll? expr)\n                  (apply (ops (first expr)) (map ! (rest expr)))\n                  (par expr expr)))]      \n      (v op))))", "problem": 121, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [fms]\n  (fn f [mp]\n    ((fn g [[op & args]] \n       (let [tmp #(if (seq? %) \n                    (g %) \n                    (if (symbol? %)\n                      (mp %)\n                      %))\n             dict  {'+ + '- - '/ / '* *}]\n         (apply (dict op) (map tmp args))))\n     fms)))", "problem": 121, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [f]\n     (fn [a]\n       ((comp \n         #(% f)\n         (partial reduce \n           (fn [m c] \n             (let [s (replace m c)] \n               (conj m [c (apply (first s) (rest s))]))) \n           (conj a ['+ +] ['- -] ['/ /] ['* *]))\n         (partial sort-by (comp count (partial tree-seq coll? identity)))\n         (partial filter coll?)\n         (partial tree-seq coll? identity)) f)))", "problem": 121, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn fun [coll]\n\t(fn f [mapp]\n\t\t((fn g [coll]\n\t\t\t(let [[op & args] (map \n\t\t\t\t#(if (coll? %) \n\t\t\t\t\t(g %)\n\t\t\t\t\t(get mapp % %))\n\t\t\t\tcoll)] \n\t\t\t(cond\n\t\t\t\t(= op '+) (apply + args)\n\t\t\t\t(= op '-) (apply - args)\n\t\t\t\t(= op '*) (apply * args)\n\t\t\t\t(= op '/) (apply / args))))\n\t\tcoll)))", "problem": 121, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [expr]\n  (fn [sm]\n    (let [symbols (assoc sm '+ + '- - '* * '/ /)\n          compute (fn compute [expr]\n                    (cond\n                      (coll? expr)\n                        (apply (symbols (first expr)) (map compute (rest expr)))\n                      (symbol? expr)\n                        (symbols expr)\n                      :else\n                        expr))]\n      (compute expr))))", "problem": 121, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn eval-expr [expr]\n  (fn [bindings]\n    (let [op-map {'+ +, '- -, '* *, '/ /}\n          resolve-arg (fn [arg]\n                        (cond\n                          (number? arg) arg\n                          (symbol? arg) (bindings arg)\n                          :else ((eval-expr arg) bindings)))\n          operator (op-map (first expr))\n          operands (map resolve-arg (rest expr))]\n    (apply operator operands))))", "problem": 121, "user": "51789dfae4b03d69594194d7"}, {"code": "(fn [f]\n (fn [m]\n  (let [l (clojure.walk/postwalk-replace m f)]\n    (clojure.walk/postwalk #(if (sequential? %)\n                              (cond\n                                (= \"/\" (str (first %)))\n                                  (apply / (rest %))\n                                (= \"+\" (str (first %)))\n                                  (apply + (rest %))\n                                (= \"-\" (str (first %)))\n                                  (apply - (rest %))\n                                (= \"*\" (str (first %)))\n                                  (apply * (rest %))\n                                :else\n                                  %) %) l))))", "problem": 121, "user": "51f28a64e4b0210f90e7454e"}, {"code": "#(fn [a]\n   (let [m (merge {'+ + '- - '/ / '* *} a) g (fn [x] (get m x x))]\n     ((fn v [s] (if (seq? s) (let [c (g (first s)) p (map (comp g v) (rest s))] (apply c p)) s)) %)))", "problem": 121, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [form]\n  (letfn [(my-resolve [s] \n              (cond (= s '*) *\n                    (= s '/) /\n                    (= s '+) +\n                    (= s '-) -\n               ))\n          (calc-rec [f]\n            (let [h (first f)\n                  r (rest  f)]\n              (cond\n               (list? h) (cons (apply (my-resolve (first h))\n                                      (calc-rec (rest h)))\n                               (calc-rec r))\n               (number? h) (cons h (calc-rec r))\n               (empty? r) h\n               :else\n               (apply (my-resolve h) (calc-rec r)))))]\n    (fn [ps] (calc-rec (clojure.walk/prewalk-replace ps form)))))", "problem": 121, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(fn [xp]\n  (fn [m]\n    (letfn\n      [(replace [[k v] itm]\n         (cond\n           (coll? itm) (map (partial replace [k v]) itm)\n           (= itm k) v\n           :else itm))\n       (pseudo-eval [[head & tail]]\n         (let \n           [f (condp = head '+ + '- - '* * '/ /)]\n           (apply f (map (fn [itm] (if (coll? itm) (pseudo-eval itm) itm)) tail))))]                    \n      (pseudo-eval (reduce (fn [acc kv] (map (partial replace kv) acc)) xp m)))))", "problem": 121, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn engine [formula]\n  (fn [vars]\n    (let [vars' (conj vars ['/ /] ['+ +] ['- -] ['* *])]\n      (clojure.walk/postwalk\n       #(cond\n         (symbol? %) (vars' %)\n         (seq? %) (apply (first %) (rest %))\n         :else %)\n       formula))))", "problem": 121, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn fev [[f & args]]\n    (fn ev [vars]\n      (letfn\n        [(vl\n          [v]\n          (if (list? v)\n            ((fev v) vars)\n            (if (number? v)\n              v\n              (vars v)\n              )\n            )\n          )]\n        (let\n          [to {'/ / '+ + '- - '* *}]\n          (apply\n           (to f)\n           (map vl args)\n           )\n          )\n        )\n      )\n    )", "problem": 121, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn compute [f]\n  (let [ops {'/ / '+ + '* * '- -}]\n    (fn [m]\n      (let [fr (map (fn rep [c] (cond (coll? c)\n                                      (map rep c)\n                                      (m c) (m c)\n                                      :else c)) f)\n            ev (fn evv [s]\n                 (cond (not (coll? s)) s\n                       (symbol? (first s))\n                       (apply (ops (first s)) (map evv (rest s)))\n                       :else (map evv s)))]                                                                                                                                                                        \n        (ev fr)))))", "problem": 121, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn f [[op & xs]]\n  #(apply ({'+ +,'- -,'* *,'/ /} op)\n          (map (fn [x] (cond\n                        (list? x) ((f x) %)\n                        (symbol? x) (% x)\n                        :else x))\n               xs)))", "problem": 121, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn r [[o & a]]\n  (fn [b]\n    (apply ({'+ +, '- -, '* *, '/ /} o)\n           (map #(if (coll? %) ((r %) b) (b % %)) a))))", "problem": 121, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn [op]\n  (fn calc ([m] (calc m op))\n    ([m expr] (let [om (merge {'+ + '- - '* * '/ /} m)\n                   [o & as] (replace om expr)]\n               (cond (not-any? seq? as) (apply o as)\n                     :else (apply o (map #(if (seq? %) (calc m %) %) as)))))))", "problem": 121, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn engine [form] \n  (fn [context] \n    (let [ e (fn eval* [exp] \n\t\t             (if (list? exp) \n\t\t\t\t\t     (let [[op & args] exp]\n\t\t\t\t\t\t    (apply ({'/ / '+ + '* * '- -} op) (map eval* args))) \n\t\t\t\t\t\t (context exp exp)) )]\n\t   (e form))))", "problem": 121, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [body]\n  (fn [binding-map] \n    ((fn f [x]\n      (if (seq? x)\n        (apply ((first x) {'+ + '- - '* *} /) (map f (rest x)))\n        (get binding-map x x)\n        )\n       )\n     body\n     )\n    )\n  )", "problem": 121, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(let\n  [ev (fn ev [m exp]\n        (cond\n         (coll? exp) (apply ({'+ + '- - '* * '/ /} (first exp))\n                            (map (partial ev m) (next exp)))\n         (symbol? exp) (m exp)\n         :else exp))\n        ]\n  (fn [exp]\n   (fn [m]\n    (ev m exp))))", "problem": 121, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn uce [fm]\n  (fn [m]\n    (let [ops {'+ + '- - '/ / '* *}\n          tra (fn tra [l] (if (seq? l)\n                           (apply (ops (first l)) (map tra (rest l)))\n                           (m l l)))]\n      (tra fm))))", "problem": 121, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [formula]\n    (fn [value-map] (let [value-map (conj value-map {'+ + '- - '* * '/ /})]\n      (clojure.walk/postwalk\n        #(if (sequential? %)\n          (let [leaf (replace value-map %)]\n            (apply (first leaf) (rest leaf)))\n          %)\n        formula))))", "problem": 121, "user": "52699a0ee4b03e8d9a4a71f2"}, {"code": "(fn cal [[o & as]]\n  (fn [args] \n    (let [avs (map #(cond\n                     (seq? %)    ((cal %) args)\n                     (number? %) %\n                     :else       (get args %))\n                   as)]\n      (case o\n      / (apply / avs)\n      + (apply + avs)\n      - (apply - avs)\n      * (apply * avs)))))", "problem": 121, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [expr]\n  (partial\n   (fn calc [e env]\n    (if (seq? e)\n      (apply ({'* * '/ / '+ + '- -} (first e)) (map #(calc % env) (rest e)))\n      (env e e)))\n   expr))", "problem": 121, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn comput-func [form]\n  (let [f (first form)\n        op {'+ + '- - '* * '/ /}]\n    (fn compute [args]\n      (cond\n        (get args f false) (args f)\n        (get op f false) (apply (op f) (map\n                                         #((comput-func (if (list? %) % (list %))) args)\n                                         (rest form)))\n        :else f))))", "problem": 121, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn p121 [syms]\n  (letfn [(mkfn [syms argm]\n            (let\n                [f ({'/ / '+ + '- - '* *} (first syms))\n                 arg (for [e (next syms)] (if (coll? e) (mkfn e argm) (argm e e)))]\n              (apply f arg)))]\n    (fn [argm] (mkfn syms argm) ))\n  )", "problem": 121, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn t-eval [t]\n    (fn [m]\n      (cond\n        (seq?    t) (apply\n                      ({'+ + '- - '* * '/ /} (first t))\n                      (map #((t-eval %) m)   (rest t)))\n        (symbol? t) (m t)\n        :else       t)))", "problem": 121, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [s]\n  (letfn ([f [c m]\n           (let [o {'/ / '* * '+ + '- -}]\n             (cond (coll? c)  (apply (get o (first c)) (map #(f % m) (rest c)) )\n                   (symbol? c) (get m c)\n                   :else c))])\n    (fn [m] (f s m))))", "problem": 121, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn ff [exp]\n    (fn  [data] (let [x (map \n                       #(if (sequential? %) \n                          ((ff %) data)\n                          (if (get data %)\n                            (get data %)\n                            (if (number? %)\n                              % \n                              (get {(symbol \"+\") + (symbol \"-\") - (symbol \"/\") / (symbol \"*\") *} %)))) (seq exp))]\n                 (apply (first x) (next x)))))", "problem": 121, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn compute[f]\n        (fn [args]\n          (letfn [(recurse [expr]\n                          (cond (seq? expr) (apply ({'/ / '* * '+ + '- -}(first expr)) (map recurse (rest expr)))\n                                (integer? expr) expr\n                                :else (args expr)))]\n            (recurse f)\n          )\n        )\n      )", "problem": 121, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "#(fn ! ([m] (! m %))\n       ([m f] \n         (apply ({'+ + '- - '* * '/ /} (first f))\n                (for [a (rest f)]\n                  (if (seq? a) (! m a) (get m a a))))))", "problem": 121, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn uce [formula]\n   (fn [args-map]\n     (let [opers {'+ +, '- -, '* *, '/ /}]\n       (letfn [(a [sym](get args-map sym))\n               (o [sym](get opers sym))\n               (evaluate [formula]\n                         (apply (o (first formula)) \n                                (map #(cond (coll? %)(evaluate %) \n                                            (number? %) % \n                                            :else (a %)) \n                                     (rest formula)\n                                     )\n                                )\n                          )]\n         (evaluate formula)\n         \n         )\n       )\n     )\n   )", "problem": 121, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "partial \n   (fn g [[f & a] m]\n     (apply \n      ({'+ + '- - '* * '/ /} f)\n      (map #(if (coll? %)\n              (g % m)\n             (  get m % %))\n           a)))", "problem": 121, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn [form]\n  (fn [decl]\n    ((fn rec [x]\n       (if (seq? x)\n         (apply ({'+ + '- - '* * '/ /} (first x))\n                (map rec (rest x)))\n         (get decl x x)))\n     form)))", "problem": 121, "user": "509160dae4b0742c82730aef"}, {"code": "(fn [sexp] (let [ops {'+ + '- - '* * '/ /}]\n             (fn [tbl]\n               (letfn [(evl [[op & args]]\n                         (apply (ops op)\n                                (map #(if (coll? %) (evl %) (tbl % %)) args)))]\n                 (evl sexp)))))", "problem": 121, "user": "519ef784e4b087743fad2198"}, {"code": "(fn chomp [exp]\n  (fn [valmap]\n    (let [  op (first exp)\n          args (rest  exp)\n          opsmap {'+ + '- - '* * '/ /}]\n      (apply (get opsmap op)\n             (for [arg args]\n               (cond\n                   (seq? arg) ((chomp arg) valmap)\n                (number? arg) arg\n                        :else (get valmap arg)))))))", "problem": 121, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn [expr] (let [the-full-function (fn eval-expr [e b op result] \n                                     (if (nil? e) result \n                                       (if (nil? op) \n                                         (eval-expr (next e) b \n                                                    (cond (= (first e) '+) + (= (first e) '*) * (= (first e) '/) / (= (first e) '-) -)\n                                                    (if (= (first e) '*) 1 (if (= (first e) '/) :special (if (= (first e) '-) :special 0))))\n                                         (if (= (type (first e)) (type 2)) (recur (next e) b op (if (= :special result) (first e) (op result (first e)))) (if (list? (first e)) (recur (next e) b op (if (= :special result) (eval-expr (first e) b nil nil) (op result (eval-expr (first e) b nil nil)))) (recur (next e) b op (if (= :special result) (b (first e)) (op result (b (first e))))))))))]\n\t(fn [bindings] (the-full-function expr bindings nil nil))\n  )\n)", "problem": 121, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(letfn [(evl [expr env]\n             (cond (number? expr) expr\n                   (symbol? expr) (env expr)\n                   (seq? expr) (let [f (first expr)]\n                                 (apply (cond (= f '+) +\n                                              (= f '-) -\n                                              (= f '*) *\n                                              (= f '/) /)\n                                        (map evl (rest expr) (repeat env))))))]\n  (fn [e]\n    (fn [m] (evl e m))))", "problem": 121, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn compute[ colls]\n   (fn fs [maps]\n     (letfn[(computing\n              [colls] \n              (if-not(sequential? colls)\n                (if (number? colls) \n                  colls \n                  (get maps colls))\n                (let[f (case (str (first colls))\n                         \"+\" +\n                         \"-\" -\n                         \"*\" *\n                         \"/\" /)\n                     ]\n                  (reduce f (map computing (rest colls))   ))))]\n       (computing colls))))", "problem": 121, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [expr]\n    (fn [values]\n      (let [replace-syms (fn f [x] \n                           (if (sequential? x)\n                             (map f x)\n                             (if (values x) (values x) x)))\n            my-resolve #(case % / / * * + + - -)\n            my-eval (fn g [[f & args]]\n                      (->> args\n                           (map #(if (sequential? %) (g %) %))\n                           (apply (my-resolve f))))]\n        (my-eval (map replace-syms expr)))))", "problem": 121, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [expr]\n  (letfn [(calc [expr ctx]\n            (let [ops {'+ + '- - '* * '/ /}]\n              (cond\n                (coll? expr) (apply (ops (first expr)) (map #(calc % ctx) (rest expr)))\n                (ctx expr) (ctx expr)\n                :else expr)))]\n    (fn [ctx] (calc expr ctx))))", "problem": 121, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn return-eval [l]\n  (fn e-map [m]\n    (letfn [(e-p [p]\n              (cond\n                (list? p) (e p)\n                (number? p) p\n                :else (m p)))\n            (e [[op & args]]\n              (let [e-args (map e-p args)]\n                (cond\n                  (= op '*) (apply * e-args)\n                  (= op '+) (apply + e-args)\n                  (= op '-) (apply - e-args)\n                  (= op '/) (apply / e-args))))]\n      (e l))))", "problem": 121, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn compute [fl]\n  (fn [m]\n    (let [[op & args]\n          (map\n           #(cond\n             (seq? %) ((compute %) m)\n             (m %) (m %)\n             :else %)\n           fl)]\n      (apply ({'+ +, '- -, '* *, '/ /} op) args))))", "problem": 121, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn compute [f]\n  (letfn [(resolve-sym [vars expr]\n            (let [fvars (merge vars {'+ + '- - '* * '/ /})]\n              (if (sequential? expr)\n                (let [result (map (partial resolve-sym fvars) expr)]\n                  (apply (first result) (rest result))\n                  )\n                (get fvars expr expr))\n              )\n            )]\n    (fn [varmap] (resolve-sym varmap f))))", "problem": 121, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn c [e]\n  (fn [v]\n    (cond\n     (number? e) e\n     (symbol? e) (v e)\n     :else (let [[op & as] e\n                  eas (map #((c %) v) as)]\n             (case op\n                   + (apply + eas)\n                   - (apply - eas)\n                   / (apply / eas)\n                   * (apply * eas))))))", "problem": 121, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn [e]                                                             \n        (letfn [(r [e m]                                                        \n          (if (coll? e)                                                         \n            (apply (get {'+ + '- - '/ / '* *} (first e))                        \n                   (map #(r % m) (rest e)))                                     \n            (if (contains? m e)                                                 \n              (m e)                                                             \n              e)))]                                                             \n          (partial r e)))", "problem": 121, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn myeval [x]\n  (letfn [(m1 [exp env]\n            (cond\n             (sequential? exp) (apply (cond\n                                       (= (first exp) (symbol \"+\")) +\n                                       (= (first exp) (symbol \"-\")) -\n                                       (= (first exp) (symbol \"/\")) /\n                                       :else *) (map #(m1 % env) (rest exp) )\n )\n             (symbol? exp) (exp env)\n             :else exp\n             )\n\n            )\n          (m2 [env]\n            (m1 x env))\n          ] m2))", "problem": 121, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn ucompute [form]\n   (fn [bind]\n     (letfn\n         [(my-eval [form]\n            (if (coll? form)\n              (let [[op & args] form]\n                (case op\n                  + (apply + (map my-eval args))\n                  - (apply - (map my-eval args))\n                  * (apply * (map my-eval args))\n                  / (apply / (map my-eval args))))\n              (if (integer? form) form (bind form))))]\n       (my-eval form))))", "problem": 121, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn parse\n\t[expr]\n\t(fn evaluate\n\t  [vars]\n\t  (cond\n\t   (list? expr) (apply ({'+ +, '- -, '* *, '/ /} (first expr))\n\t\t\t       (map #((parse %) vars) (rest expr)))\n\t   (vars expr) (vars expr)\n\t   :else expr)))", "problem": 121, "user": "51937eb3e4b04df54c098022"}, {"code": "(fn [sexp]\n  (letfn [(eval-sexp [args sexp]\n            (if-not (seq? sexp)\n              (get args sexp sexp)\n              (let [[op & operands] sexp]\n                (apply (get {'/ / '+ + '- - '* *} op)\n                       (map (partial eval-sexp args) operands)))))]\n    (fn [args]\n      (eval-sexp args sexp))))", "problem": 121, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn f [formula]\n  (fn [args]\n    (let [[op & s] formula]\n      (apply ({'/ / '* * '+ + '- -} op) \n             (map #(if (seq? %) ((f %) args) (args % %)) s)))))", "problem": 121, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn uce [expr]\n  (fn [env]\n    (letfn [(compute [e] ((uce e) env))\n            (rewrite [e]\n              (cond (coll? e) (compute e)\n                    (number? e) e\n                    :else (env e)))]\n      (let [ops {'+ + '- - '* * '/ /}\n            [op & args] expr\n            argvals (map rewrite args)]\n        (apply (ops op) argvals)))))", "problem": 121, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn f [e]\n    (fn [m]\n      (cond\n        (number? e) e\n        (symbol? e) (m e)\n        :else       (apply ({'+ + '- - '* * '/ /} (first e)) (map #((f %) m) (rest e))))))", "problem": 121, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn uce\n    [syms]\n    (let [ops '(+ - * /)\n          vars (filter \n                (fn [x] \n                  (and (not (true? (some #(= % x) ops))) (symbol? x)))\n                (flatten syms))\n          subst (fn [args] \n                  (clojure.walk/postwalk \n                   (fn [x] (if (some #(= % x) vars) (get args x) x)) syms))]\n      (fn [args]\n        (let [fns {'+ + '- - '* * '/ /}\n              replaced (subst args)]\n          (clojure.walk/postwalk \n           #(if (coll? %) (apply (get fns (first %)) (rest %)) %)\n           replaced)))))", "problem": 121, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn  [form] \n  (fn [m] \n    (let [[expr] ((fn ch [c] (map #(if (seq? %) (ch (replace m %)) %) c)) `(~form))] \n      ((fn ex [e]\n        (if (seq? e) \n          (let [[f & s] e] (apply ({'+ + '- - '* * '/ /} f) (map ex s)))\n          e)) expr))))", "problem": 121, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [f]\n (fn [m]\n  ((fn r [a]\n     (if (seq? a)\n       (apply ({'- - '* * '/ /} (first a) +) \n              (map r (rest a)))\n       (m a a)))\n   f)))", "problem": 121, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [f]\n     (fn [v]\n       ((fn e [f1]\n          (cond\n                 (seq? f1) (apply\n                             ({'+ + '- - '* * '/ /} (first f1))\n                             (map e (rest f1)))\n                 (symbol? f1) (v f1)\n                 :default f1))\n        f)))", "problem": 121, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [formal]\n  (fn [v_map]\n    ((fn _exec [expr] (let [[f & args] expr]\n      (apply ({\"+\" + \"-\" - \"*\" * \"/\" /} (str f)) (for [arg args](if (contains? v_map arg) (v_map arg) (if (seq? arg) (_exec arg) arg) ) ))\n    ))  formal)\n  )\n)", "problem": 121, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [form]\n  (fn [values]\n    (let [calc (fn calc [v f]\n      (let [cu (replace v f)]\n        (apply (case (str (first cu)) \"+\" + \"-\" - \"/\" / \"*\" *)\n         (map #(if (coll? %) (calc v %) %) (rest cu)))\n        ))]\n      (if (vector? values)\n        (map #(calc % form) values)\n        (calc values form))\n      )))", "problem": 121, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn ev [expr]\n  (let [ops {'+ + '- - '/ / '* *}]    \n    (fn [bindings]\n      (cond\n       (sequential? expr) (apply (get ops (first expr))\n                                 (map #((ev %) bindings) (rest expr)))\n       (contains? bindings expr) (get bindings expr)\n       :else expr))))", "problem": 121, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn f [coll]\n  (fn [reps]\n    (if (seq? coll)\n      (let [[x & y] coll\n            evil {'* * '/ / '+ + '- -}]\n        (apply (evil x) (map #((f %) reps) y)))\n      (if-let [rep-val (reps coll)]\n        rep-val\n        coll))))", "problem": 121, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn compute [expr]\n          (fn [m]\n            (if (seq? expr)\n              (let [op (first expr)\n                    ops (map #((compute %) m) (rest expr))]\n                (cond (= op '+) (apply + ops)\n                      (= op '-) (apply - ops)\n                      (= op '*) (apply * ops)\n                      (= op '/) (apply / ops)))\n              (if (contains? m expr) (m expr) expr))))", "problem": 121, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn uce [exp]\n  (fn [env]\n    (letfn [(ev [exp]\n              (cond\n                (number? exp) exp\n                (symbol? exp) (env exp)\n                :else (apply ({'+ + '- - '/ / '* *} (first exp))\n                             (map ev (rest exp)))))]\n      (ev exp))))", "problem": 121, "user": "51e00020e4b01188f0627534"}, {"code": "(fn solver [formula]\n  (fn doer [hmap]\n    (letfn [(rec [[op & xs] hmap]\n              (let [opmap {'+ + '- - '/ / '* *}]\n               (apply (opmap op) (map (comp #(or (hmap %) %) #(if (sequential? %) (rec % hmap) %))\n                            xs))))]\n      (rec formula hmap))))", "problem": 121, "user": "50645e12e4b007509339a58a"}, {"code": "(fn ev\n  [expr]\n  (fn [env]\n    (cond \n     (number? expr) expr\n     (symbol? expr) (get env expr) \n     (list? expr) (apply (condp = (first expr) \n                           '+ +\n                           '* *\n                           '/ /\n                           '- -)\n                         (map #((ev %) env) (rest expr))))))", "problem": 121, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn eval-exp [exp]\n  (fn [vars]\n    (cond\n      (integer? exp) exp\n      (symbol? exp) (vars exp)\n      :else (let [eval-sub #((eval-exp %) vars)\n                  [op & [x y :as subs]] exp]\n              (cond\n                (= op '+) (apply + (map eval-sub subs))\n                (= op '-) (- (eval-sub x) (eval-sub y))\n                (= op '*) (apply * (map eval-sub subs))\n                (= op '/) (/ (eval-sub x) (eval-sub y)))))))", "problem": 121, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [formula]\n  (letfn [(ev [v f]\n              (cond\n               (number? f) f\n               (symbol? f) (v f)\n               :else  (apply ({'* * '/ / '+ + '- -} (first f)) (map #(ev v %) (rest f)))))]\n    (fn [x] (ev x formula))))", "problem": 121, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn ngin-comp\n  [maths]\n  (fn [m]\n    (let [ops {'+ + '/ / '* * '- -}]\n      ((fn calc [[op & args]]\n         (apply (ops op)\n                (map #(if (seq? %) (calc %) (get m % %)) args))\n         ) maths))))", "problem": 121, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [f] (fn [m] (let [op {\"+\" + \"-\" - \"*\" * \"/\" /}]\n                           (letfn [(calc [f2]\n                                   (apply (get op (str (first f2))) (map #(if (symbol? %) (get m %) (if (sequential? %) (calc %) %)) (rest f2))))]\n                           (calc f)))))", "problem": 121, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn universal-Computation-Engine [expr]\n  (fn [ar-map]\n    (letfn [(rpl [a e] \n              (map \n               (fn [x] \n                 (if (coll? x) (rpl a x)\n                     (let [v (a x)]\n                       (if (nil? v) x v)))) \n               e))\n\n            (evalate [e] (apply (first e)\n                                (map  \n                                 \n                                 #(if (coll? %) (evalate %) %)\n                                 \n                                 (rest e))))]\n      \n      (evalate (rpl (assoc ar-map '/ / '+ + '* * '- -  ) expr))\n\n      )))", "problem": 121, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn m [s]\n  (fn [v]\n    ((fn x [[o & l]]\n       (apply (o {'+ + '- - '/ / '* *}) (map #(cond (seq? %1) (x %1) :else (v %1 %1)) l))\n       ) s)))", "problem": 121, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn [expr]\n  (letfn [(my-eval [expr vals-map]\n            (cond (vals-map expr) (vals-map expr)\n                  (number? expr) expr\n                  (seq? expr) (apply\n                               ({'+ + '- - '* * '/ /} (first expr))\n                               (map #(my-eval % vals-map)\n                                    (rest expr)))))]\n    (fn [vals-map]\n      (my-eval expr vals-map))))", "problem": 121, "user": "510db6cde4b078ea71921145"}, {"code": "(fn __ [coll]\n  (fn [vars]\n    ((fn evaluate [expr]\n       (let [ops {'+ + '- - '* * '/ /}]\n         (cond \n           (coll? expr) (let [[f & args] expr]\n                          (apply (ops f) (map evaluate args)))\n           (symbol? expr) (vars expr)\n           :else expr)))\n      coll)))", "problem": 121, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn topucm [sexp]\n  (fn [m]\n    (let [ucm (fn ucm [[op & args]]\n              (apply ({'+ + '- - '* * '/ /} op)\n                     (map #(if (sequential? %)\n                             (ucm %)\n                             (get m % %))\n                          args)))]\n    \n      (ucm sexp))))", "problem": 121, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn universal\n  ([l] #(universal l %))\n  ([l m]\n   (if (seq? l)\n     (let [[f & a] (map #(universal % m) l)]\n       (apply f a))\n     (if (number? l)\n       l\n       (if-let [f (l {'+ + '* * '/ / '- -})]\n         f\n         (l m))))))", "problem": 121, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(let\n  [ops {'+ +, '- -, '* *, '/ /}]\n  (fn ev [formula]\n    (fn [vars]\n      (cond\n        (number? formula) formula\n        (symbol? formula) (vars formula)\n        :else (apply (ops (first formula)) (map #((ev %) vars) (rest formula)))))))", "problem": 121, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn e [[o & x]]\n (fn [v] \n   (apply ({'+ + '- - '* * '/ /} o)\n          (map #(cond (seq? %) ((e %) v) \n                      (number? %) % :e (v %)) \n               x))))", "problem": 121, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn [entrada]\n  (fn [mapa]\n    ((fn resolvendo [elemento-ou-lista]\n       (if-not (coll? elemento-ou-lista)\n         elemento-ou-lista\n         (apply (first elemento-ou-lista) (map resolvendo (next elemento-ou-lista)))))\n      ((fn transforma [entrada mapa]\n         (let [formula (map #(cond\n                               (= % '/) /\n                               (= % '*) *\n                               (= % '+) +\n                               (= % '-) -\n                               :else %)\n                            entrada)\n               simbolos (filter symbol? formula)\n               formula-com-parametros (map #(if ((set simbolos) %)\n                                              (mapa %)\n                                              %) formula)]\n           (map #(if (list? %)\n                   (transforma % mapa)\n                   %)\n                formula-com-parametros)))\n        entrada \n        mapa))))", "problem": 121, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [x] #((fn f [l] (if (coll? l)\n                      (let [[g & r] l] (apply (case g / / + + - - * *) (map f r)))\n                      l)) (clojure.walk/prewalk-replace % x)))", "problem": 121, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn comp-engine [[op & s]]\n  (let [fun-map {'+ + '- - '* * '/ /}]\n  (fn [v]\n    (apply (fun-map op)\n      (map\n        (fn [x]\n          (cond\n            (list? x) ((comp-engine x) v)\n            (symbol? x) (v x)\n            :default x\n            )) s)\n    )\n    )) )", "problem": 121, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [form]\n  (fn [defs]\n    (let [ops {'+ + '- - '* * '/ /}]\n      (letfn [(replace [form]\n                (if (coll? form)\n                  (map replace form)\n                  (get defs form form)))\n              (evaluate [form]\n                (if (coll? form)\n                  (let [f (get ops (first form))\n                        args (map evaluate (rest form))]\n                    (prn (class f) args)\n                    (apply f args))\n                  form))]\n        (-> form replace evaluate)))))", "problem": 121, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [f]\n    (let [o {'+ + '- - '* * '/ /}]\n    (fn [m]\n      ((fn v [f m]\n         (cond\n           (seq? f)    (apply (-> f first o) (map #(v % m) (rest f)))\n           (number? f) f\n           :else       (m f)))\n       f m))))", "problem": 121, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn [expr]\n    (fn eval2\n        ([vals] (eval2 expr vals))\n        ([expr vals]\n         (apply ({'+ + '- - '* * '/ /} (first expr))\n                (map\n                 #(if (list? %) (eval2 % vals) (get vals % %))\n                 (rest expr))))))", "problem": 121, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn compute [expr]\n  (fn [vs]\n    (apply ({'+ +, '- -, '* *, '/ /} (first expr))\n           (map\n            #(cond\n              (coll? %) ((compute %) vs)\n              (vs %) (vs %)\n              :else %\n              )\n            (rest expr)\n            ))\n    )\n  )", "problem": 121, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [formula]\n    (letfn [(ev [vals form]\n                (cond\n                 (number? form) form\n                 (symbol? form) (vals form)\n                 :else  (apply ({'* * '/ / '+ + '- -} (first form))\n                               (map #(ev vals %) (rest form)))))]\n      #(ev % formula)))", "problem": 121, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [expr]\n\t(fn [ctx]\n  (let [expr (read-string (str expr))\n        ctx (read-string (str ctx))\n\tthird #(second (next %))\n\tee (fn ee [e]\n\t     (cond\n\t      (number? e) e\n\t      (symbol? e) (ctx e)\n\t      (= '+ (first e)) (apply + (map #(ee %) (next e)))\n\t      (= '- (first e)) (apply - (map #(ee %) (next e))) \n\t      (= '* (first e)) (apply * (map #(ee %) (next e)))\n\t      (= '/ (first e)) (apply / (map #(ee %) (next e))) ))]\n    (ee expr)\n    )))", "problem": 121, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn f [s]\n  (let [\n        ops {'/ / '+ + '- - '* *}\n        g (fn g[list]\n            (let [op (first list)]\n              (apply (ops op) (map #(if (seq? % )( g % ) % ) (rest list)))))\n        ]\n    (fn [m]\n     (g (clojure.walk/prewalk-replace m s))\n      )\n  )\n)", "problem": 121, "user": "518c5236e4b087e178201de0"}, {"code": "(fn my-universal-computation-engine\n  [formula]\n  (fn [values]\n    (let [argsAndFunctions (merge values {'+ + '- - '* * '/ /})]\n      (letfn [(calculate-function [function]\n                                  (if (seq? function)\n                                    (let [[operator & args] function]\n                                      (apply (argsAndFunctions operator) (map calculate-function args)))\n                                    (get argsAndFunctions function function)))]\n         (calculate-function formula)))))", "problem": 121, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [tree] (letfn [\n(operator [sym] (get {'+ + '- - '* * '/ /} sym))\n(tree-reduce [branch? child? leaf-reduce tree] (if (branch? tree) (leaf-reduce (map #(if (child? %) (tree-reduce branch? child? leaf-reduce %) %) tree)) (leaf-reduce tree)))\n(calculate-formula-value [tree] (fn [argmap] (tree-reduce #(some sequential? %) sequential? #(apply (operator (first %)) (replace argmap (rest %))) tree)))\n] (calculate-formula-value tree)))", "problem": 121, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn v [e]\n  (let [s\n        {'+ + '- - '* * '/ /}]\n    (fn [m]\n      (apply (s (first e)) (map #(cond\n                                  (coll? %) ((v %) m)\n                                  (nil? (m %)) %\n                                  :else (m %)) (rest e))))))", "problem": 121, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn eval-formula [formula]\n  (fn evaluate [variable->values]\n    (letfn [(operator [x]\n              ({'+ +\n                '- -\n                '* *\n                '/ /}\n               x))\n\n            (looper [expr]\n              (cond\n               (number? expr) expr\n               (symbol? expr) (variable->values expr)\n               :else (apply (operator (first expr))\n                            (map looper (rest expr)))))]\n      (looper formula))))", "problem": 121, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn univ-comp[expr]\n\t(fn [var-map]\n\t\t(let [op-map {'/ / '+ + '* * '- -}]\n\t\t\t(letfn [(replace-ops-and-vars [a-sym]\n\t\t\t\t\t\t(if (seq? a-sym)\n\t\t\t\t\t\t\t(map replace-ops-and-vars a-sym)\t\n\t\t\t\t\t\t\t(if (get var-map a-sym)\n\t\t\t\t\t\t\t\t(get var-map a-sym)\n\t\t\t\t\t\t\t\t(if (get op-map a-sym)\n\t\t\t\t\t\t\t\t\t(get op-map a-sym)\n\t\t\t\t\t\t\t\t\ta-sym\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t(compute-sym [a-sym]\n\t\t\t\t\t\t(if (seq? a-sym)\n\t\t\t\t\t\t\t(let [f (first a-sym) \n\t\t\t\t\t\t\t\t  r (rest a-sym)\n\t\t\t\t\t\t\t\t  computed-r (map compute-sym r)] \n\t\t\t\t\t\t\t\t  (apply f computed-r)\t\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\ta-sym\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t]\n\t\t\t\t(let [inst-expr (map replace-ops-and-vars expr)]\n\t\t\t\t\t(compute-sym inst-expr)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 121, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn [eq]\n  (fn [m]\n    ((fn calc [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map calc args)))\n         (get m x x)))\n     eq)))", "problem": 121, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn [exp]\n    (fn [m]\n      (clojure.walk/postwalk #(if (coll? %)\n                                (apply ((first %) {'+ + '- - '* * '/ /})\n                                       (rest %))\n                                %)\n                             (clojure.walk/prewalk-replace m exp))))", "problem": 121, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn cal [l]\n  (fn [env]\n    (if (list? l)\n      (let [f (first l)\n            args (map (fn [e] ((cal e) env)) (rest l))]\n        (apply ({'+ + '- - '* * '/ /} f) args))\n      (get env l l))))", "problem": 121, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn f [[op & args]] \n  (fn [vals] \n    (apply ({'/ /, '+ +, '- -, '* *} op) \n           (map #(cond (seq? %) ((f %) vals) \n                       (symbol? %) (vals %) \n                       true %) \n                args))))", "problem": 121, "user": "52bdf6bde4b07a9af579230d"}, {"code": "(let [operations {'+ +, '- -, '* *, '/ /}\n             inner (fn inner [mapping expr]\n                     (cond\n                       (coll? expr) (apply (operations (first expr)) \n                                           (map #(inner mapping %) (rest expr)))\n                       (symbol? expr) (mapping expr)\n                       :else expr))]\n         (fn [expr]\n           (fn [mapping]\n             (inner mapping expr))))", "problem": 121, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn uce [formula]\n  (fn [variables-map]\n    (let [get-operand-value (fn [operand]\n                              (cond\n                                (symbol? operand) (variables-map operand)\n                                (sequential? operand) ((uce operand) variables-map)\n                                true operand))\n          op (first formula)\n          operands (map get-operand-value (rest formula))]\n      (let [unquoted-op (cond\n                          (= op '+) +\n                          (= op '-) -\n                          (= op '*) *\n                          (= op '/) /)]\n        (apply unquoted-op operands)))))", "problem": 121, "user": "53070615e4b02e821686979e"}, {"code": "(fn [f]\n  #((fn i [f]\n      (cond \n        (symbol? f) (% f)\n        (number? f) f\n        :else (apply ({'+ + '- - '* * '/ /} (first f)) (map i (rest f))))) f))", "problem": 121, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn compute [expr]\n  (fn thefn [dict]\n    (letfn [(lookup [x dict]\n              (or (get dict x) x))\n            (replace-symbols [dict expr]\n              (map #(if (coll? %)\n                      (replace-symbols dict %)\n                      (lookup % dict)) expr))\n            (myeval [expr]\n              (let [op (first expr)]\n                (apply op (for [others (rest expr)]\n                                      (if (coll? others)\n                                        (myeval others)\n                                        others)))))]\n    (myeval (replace-symbols (-> dict\n                                 (merge {'* * '+ + '- - '/ /}))\n                             expr)))))", "problem": 121, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn [e]\n    #(letfn [(i [[op & r]]\n               (apply ({'+ + '- - '* * '/ /} op) (map t r)))\n             (t [s]\n               (if (coll? s) (i s)\n                   (if-let [a (% s)]\n                     a\n                     s)))]\n       (i e)))", "problem": 121, "user": "52c25645e4b07a9af579237d"}, {"code": "#(fn [v]\n  ((fn r [x]\n     (if (seq? x)\n       (apply ({'+ + '- - '* * '/ /} (first x)) (map r (rest x)))\n       (v x x)))\n   %))", "problem": 121, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn !! [c]\n  (fn [m] (let [ [f & as]\n         (map\n          #(if (sequential? %)\n             ((!! %) m)\n             (let [x (m %)] (if x x %))) c)]\n    (apply ({'/ / '+ + '- - '* *} f) as))))", "problem": 121, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn calc [expr]\n  (fn [binds]\n    (reduce ({'/ / '* * '+ + '- -} (first expr))\n            (map #(cond\n                   (number? %) % \n                   (sequential? %) ((calc %) binds)\n                   :else (binds %)) (rest expr)))))", "problem": 121, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [c]\n  (fn [v] \n    (clojure.walk/postwalk \n      #(cond\n        (= % '+) +\n        (= % '-) -\n        (= % '*) *\n        (= % '/) /   \n        (symbol? %) (v %)\n        (seq? %) (apply (first %) (rest %))\n        :else %\n      )\n      c\n    )  \n  )   \n)", "problem": 121, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn [f]\n  (fn [m]\n    (letfn [(my-eval [exp]\n              (if (coll? exp)\n                (let [[op & args] exp]\n                  (cond (= op '+) (apply + (map my-eval args))\n                        (= op '-) (apply - (map my-eval args))\n                        (= op '*) (apply * (map my-eval args))\n                        (= op '/) (apply / (map my-eval args))))\n                (if (contains? m exp)\n                  (get m exp)\n                  exp)))]\n      (my-eval f))))", "problem": 121, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn univ-comp [formular]\n  (fn [args-map]\n    (letfn [(compu [sub-formular]\n              (if (seq? sub-formular)\n                (apply ({'+ + '- - '* * '/ /} (first sub-formular))\n                        (map compu (rest sub-formular)))\n                (#(if (nil? %) sub-formular %)\n                    (args-map sub-formular))))]\n      (compu formular))))", "problem": 121, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn expr [form]\n  (fn calc [vars]\n    (let [op (first form)\n          args (map #(cond (symbol? %) (get vars %)\n                           (sequential? %) ((expr %) vars)\n                           :else %) (rest form))]\n      (apply (case (str op) \"+\" + \"*\" * \"-\" - \"/\" /) args))))", "problem": 121, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn compute [calc]\n  (let [ops {'/ / '+ + '- - '* *}]\n    (fn [binds]\n      (apply (ops (first calc)) \n             (map #(if (seq? %) ((compute %) binds) (if-let [e (binds %)] e %)) (rest calc))))))", "problem": 121, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn [form]\n  (letfn [(step [s]\n            (let [formulars (re-seq #\"\\([^\\(\\)]*\\)\" s)]\n              (if (seq formulars)\n                (let [formulars-results (map\n                                          (fn [formular]\n                                            (let [formular-seq (re-seq #\"[\\+\\-\\*/0-9]+\" formular)]\n                                              (apply\n                                                (case (first formular-seq)\n                                                  \"+\" +\n                                                  \"-\" -\n                                                  \"*\" *\n                                                  \"/\" /)\n                                                (map #(Integer/parseInt %) (rest formular-seq)))\n                                              ))\n                                          formulars)]\n                  (step (reduce #(.replace %1 (key %2) (str (val %2))) s (apply assoc {} (interleave formulars formulars-results)))))\n                (Integer/parseInt s))))]\n    (fn [m]\n      (let [form-str (str form)]\n        (step (reduce #(.replace %1 (str (key %2)) (str (val %2))) form-str m))))))", "problem": 121, "user": "50436470e4b034ff00315d23"}, {"code": "(fn babbage [form]\n  (cond\n   (symbol? form)     (fn [env] (get env form))\n   (not (list? form)) (fn [env] form)\n   (= () form)        (fn [env] form)\n   :else\n   (fn [env]\n     (apply\n      ({'+ + '- - '* * '/ /} (first form))\n      ;; @(resolve (first form))\n      (map #(% env) (map babbage (rest form)))))))", "problem": 121, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn* calc [x]\n  (fn [y]\n       (let [[op & vals] x]\n         (apply ({'* * '/ / '+ + '- -} op)\n           (map\n            (fn [v]\n              (cond\n               (integer? v) v\n               (coll? v) ((calc v) y)\n               true (y v)))\n            vals)))))", "problem": 121, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(letfn [(calc\n         [vars expr]\n         (if (seq? expr)\n           (let [[op & args]\n                 (map (partial calc vars)\n                      expr)]\n             (apply op args))\n           (if-let [bind (vars expr)]\n             bind\n             (condp = expr\n              '+ +\n              '- -\n              '* *\n              '/ /\n              expr))))]\n  \n  (fn solve [expr]\n    #(calc % expr)))", "problem": 121, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [l]\n  (fn [m]\n    (let [t (fn t [x]\n              (or (m x) ({'+ + '- - '* * '/ /} x) x))\n          e (fn e [x]\n              (if (seq? x)\n                (apply (t (first x)) (map e (rest x)))\n                (t x)))]\n      (e l))))", "problem": 121, "user": "53460d02e4b084c2834f4a39"}, {"code": ";; amalloy's solution to Universal Computation Engine\n(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn uce [s]\n  (fn use-inter [m]\n    (let [\n          resolve-list (fn [l]\n                         (let [o (first l), r (rest l)]\n                           (cond \n                             (= '+ o) (apply + r)\n                             (= '/ o) (apply / r)\n                             (= '- o) (apply - r)\n                             (= '* o) (apply * r)\n                             )))\n          uce-replace (fn uce-replace [s m]\n                        (loop [s1 s, result '()]\n                          (if (empty? s1)\n                            (reverse result)\n                            (let [c (first s1)]\n                              (recur\n                                (rest s1)\n                                (cond\n                                  (list? c) (conj result (resolve-list (uce-replace c m)))\n                                  (contains? m c) (conj result (m c))\n                                  :else (conj result c))\n                                )))))\n          replaced (uce-replace s m)]\n      (resolve-list replaced)\n      )))", "problem": 121, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn [l]\n   (let [me (fn me [l m]\n              (let [f (first l)\n                    g #(if (coll? %)\n                         (me % m)\n                         (if (symbol? %)\n                           (get m %)\n                           %))\n                    xs (map g (next l))]\n                (apply (get {'+ + '- - '* * '/ /} f) xs) ))]\n     (fn [m] (me l m) )\n     ))", "problem": 121, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn s [expr]\n    (fn [assn]\n      (cond\n       (seq? expr) (let [ [op & args] expr]\n                     (apply ({'/ / '* * '+ + '- -} op)\n                            (map #( (s %) assn) args)  ))\n       (assn expr)  (assn expr)\n       :else expr)))", "problem": 121, "user": "53440c0ae4b084c2834f4a25"}, {"code": "(fn [expr]\n  (fn [context]\n    (let [ops-map {'+ +, '- -, '* *, '/ /}]\n      (letfn [(calc [expr]\n                    (cond\n                     (symbol? expr) (context expr)\n                     (number? expr) expr\n                     (coll? expr) (let [op (ops-map (first expr)),\n                                        args (map calc (rest expr))]\n                                    (apply op args))))]\n            (calc expr)))))", "problem": 121, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn pr121 [expr]\n  (fn iter [table]\n    (let [trans (map #(if (seq? %)  \n                        ((pr121 %) table) \n                        (table % %)) \n                     expr)]\n      (apply ({'+ + '- - '* * '/ /} (first trans) identity) \n             (rest trans)))))", "problem": 121, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn s [[o & p]]\n  (fn [m]\n      (apply ({'+ + '/ / '- - '* *} o)\n        (map #(if\n                (seq? %) ((s %) m)\n                (get m % %)) \n              p))))", "problem": 121, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [formula]\n  (let [calc (fn calc [in]\n               (if (number? in)\n                 in\n\t             (apply (first in) (map calc (rest in)))))]\n    (fn [variables]\n      (calc (clojure.walk/prewalk-replace (merge variables {'/ / '+ + '- - '* *}) formula)))))", "problem": 121, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [z] (fn [x] (letfn [(get-op [x] ({'/ / '* * '+ + '- - } x))                                                                                                                                         \n                                (calc [l]                                                                                                                                                                       \n                                  (if (seq? l) (let [f (first l) e (get-op f)] (apply e (map calc (rest l))))                                                                                                   \n                                    (cond                                                                                                                                                                       \n                                     (symbol? l) (x l)                                                                                                                                                          \n                                     :else l)))]                                                                                                                                                                \n                          (calc z))))", "problem": 121, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '- - '* * '/ /} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "problem": 121, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn f [expr]\n    (fn g [m]\n      (cond\n       (list? expr) (do\n                      (apply\n                       ({'+ + '- - '* * '/ /} (first expr))\n                       (map #((f %) m) (rest expr))))\n       (contains? m expr) (m expr)\n       :else expr)))", "problem": 121, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn f [c]\n  (let [fns {'/ / '* * '+ + '- -}]\n    (letfn [(replace-vals [c vs]\n              (if (empty? c)\n                '()\n                (let [a (first c)]\n                  (cons (cond (get vs a) (get vs a)\n                              (list? a) (replace-vals a vs)\n                              :else a)\n                        (replace-vals (rest c) vs)))))\n            (eval-1 [c]\n              (apply (fns (first c)) (map #(if (seq? %)\n                                             (eval-1 %)\n                                             %) (rest c))))]\n      (fn [vs] (eval-1 (replace-vals c vs))))))", "problem": 121, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn uce[f]\n  (fn [data]\n    (let [data (assoc data '+ + '- - '* * '/ /)\n          exec (fn [[op & args]] (apply op args))\n          rewrite (fn rewrite[f'] (map #(if (seq? %) (exec (rewrite %)) (data % %)) f'))]\n      (exec (rewrite f))\n      )))", "problem": 121, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [formula]\n    (letfn [(ev\n              [vals form]\n              (let [ops {'* * '/ / '+ + '- -}]\n                (if (coll? form)\n                  (apply (ops (first form)) (map #(ev vals %) (rest form)))\n                  (get vals form form))))]\n      #(ev % formula)))", "problem": 121, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn eval-form \n  ([form]\n   \t(partial eval-form form)) \n  ([form params]\n    (let [[x & xs] form, ops {'+ + '- - '* * '/ /}]\n      (cond\n       (ops \t\tx)\t(apply \t(get ops x) \t \t (eval-form xs params)) \n       (seq? \t\tx)\t(cons\t(eval-form x params) (eval-form xs params))\n       (number?\t\tx)\t(cons\tx\t\t\t\t\t (eval-form xs params))\n       (params \t\tx)\t(cons\t(get params x)\t\t (eval-form xs params))\n       (nil?\t\tx)  '()))))", "problem": 121, "user": "514a3fa5e4b0829bd132edb6"}, {"code": "(fn computor [exp]\n  (let [operations {'+ +, '- -, '* *, '/ /}]\n    (fn [vars]\n      (cond (number? exp) exp\n            (symbol? exp) (vars exp)\n            :else (let [[op & xs] exp\n                        f (operations op)]\n                    (apply f (map #((computor %) vars) xs)))))))", "problem": 121, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn ucalc [[op-sym & args]]\n  (fn [m]\n    (let [op (get {'/ / '* * '+ + '- -} op-sym)]\n    \t(apply op (map #(cond\n                     \t\t(sequential? %) ((ucalc %) m)\n                     \t\t:else (get m % %))\n                   \targs)))))", "problem": 121, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn [fs]\n  (fn [syms]\n    (letfn [(subst-eval [sym]\n              (cond\n                (list? sym) (let [[op & vals] (map subst-eval sym)]\n                              (apply (condp = op '+ + '- - '* * '/ /) vals))\n                (contains? syms sym) (syms sym)\n                :else sym))]\n      (subst-eval fs))))", "problem": 121, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn f121 [col]\n  (fn [mp]\n    ((fn hitung [x]\n       (if (coll? x)\n         (let [opr (first x)\n               args (rest x)]\n           (apply (cond (= '+ opr) +\n                        (= '- opr) - \n                        (= '/ opr) /\n                        (= '* opr) *)\n                  (map hitung args)))\n         (get mp x x)))\n     col)))", "problem": 121, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn unicomp [l]\n  (fn [m]\n    ((fn compute [x]\n       (if (seq? x)\n           (let [[op & args] x\n                 ops {'+ + '- - '* * '/ /}]\n            (apply (ops op) (map compute args)))\n           (get m x x))) l)))", "problem": 121, "user": "53691dc7e4b0243289761e97"}, {"code": "#(fn [m]\n  ((fn f [x]\n     (if (seq? x)\n         (apply ({'/ / '* * '+ + '- -} (first x))\n                (map f (rest x)))\n         (m x x))) %))", "problem": 121, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [expr]\n  (fn [bs]\n    (letfn [(uce_ [e]\n              (cond\n               (number? e) e\n               (symbol? e) (bs e)\n               (list?   e) (let [[op & args] e]\n                             (apply ({'/ / '+ + '- - '* *} op)\n                                    (for [a args]\n                                      (uce_ a))))))]\n      (uce_ expr))))", "problem": 121, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(letfn [(I [e v]\n          (cond (symbol? e) (v e)\n                (number? e) e\n                :else (let [[f & args] e]\n                        (apply (I f v) (map #(I % v) args)))))]\n  (fn [e]\n    (fn [v] (I e (assoc v '+ + '- - '* * '/ /)))))", "problem": 121, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn [f]\n  (fn fvals [v]\n    ((fn evl [f1]\n       (let [f2 (clojure.walk/postwalk-replace v f1)]\n         (cond\n           (seq? f2) (apply ({'+ + '- - '* * '/ /} (first f2)) (map evl (rest f2)))\n           :else f2))) f)))", "problem": 121, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn [t] \n  (fn [a] \n    (clojure.walk/postwalk #(if (seq? %) (apply ({'+ + '/ / '- - '* *} (first %)) (rest %)) %)\n             (clojure.walk/postwalk-replace a t))))", "problem": 121, "user": "51aefceee4b09397d5109797"}, {"code": "(fn rec [[f & xs]]\n          (fn [h]\n            (apply (f {'/ / '* * '+ + '- -})\n                   (for [x xs]\n                     (cond\n                      (symbol? x) (get h x)\n                      (list? x) ((rec x) h)\n                      :else x)))))", "problem": 121, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn [e]\n  (fn [vs]\n    (letfn [(f [[o & ts]] \n              (let [ts (replace vs ts)]\n                (apply ({'+ + '- - '* * '/ /} o)\n                       (map #(if (coll? %) (f %) %) ts))))]\n      (f e))))", "problem": 121, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn __ [[op & exprs]]\n  (fn [defs]\n    (let [f #(cond (symbol? %) (defs %)\n                   (number? %) %\n                   :else ((__ %) defs))\n          exprs' (map f exprs)\n          op' (condp = op '+ + '- - '* * '/ /)]\n      (apply op' exprs'))))", "problem": 121, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn my-eval [form]\n  (let [val-of-form (fn val-of-form [[op & args]]\n                      (case op\n                        + (apply + args)\n                        - (apply - args)\n                        / (apply / args)\n                        * (apply * args)))\n\n        val-of-symbol (fn val-of-symbol [env s]\n                        (if (and (symbol? s)\n                                 (contains? env s))\n                          (env s)\n                          s))]\n    (fn [env]\n      (let [lookup (partial val-of-symbol env)\n            eval-aux (fn eval-aux [form]\n                       (cond\n                         (symbol? form) (get env form form)\n                         (list? form) (val-of-form (map eval-aux form))\n                         :else form))]\n        (eval-aux form)))))", "problem": 121, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn machine [formula]\n  (letfn [(evalf [f env]\n            (cond (number? f) f\n                  (symbol? f) (env f)\n                  (list? f) (apply ({'+ + '- - '* * '/ /} \n                                    (first f)) (map #(evalf % env) (rest f)))))]\n    (partial evalf formula)))", "problem": 121, "user": "51a768e0e4b0da5f497bde84"}, {"problem": 121, "code": "(fn e [[s & a]]\n  (fn [m] \n    (apply ({'+ +\n             '/ /\n             '- -\n             '* *} s)\n      (map \n        #(if (seq? %)\n           ((e %) m)\n           (m % %))\n        a))))", "user": "51ad244fe4b09397d510977f"}, {"problem": 121, "code": "(fn [e]\n  (fn [m]\n    (letfn [(rpl [x] (if (coll? x) (map rpl (replace m x)) x))\n            (evl [expr] (if (seq? expr) (apply ({'+ + '* * '- - '/ /} (first expr)) (map evl (rest expr))) expr))]\n      (evl (rpl e)))))", "user": "530bf87ee4b02e82168697d5"}, {"problem": 121, "code": "(fn c\n  [expr]\n  (fn [env]\n    (let [env (merge env {'+ +\n                          '- -\n                          '* *\n                          '/ /})]\n      (cond \n        (list? expr) (apply (env (first expr)) \n                            (map #((c %) env)\n                                 (rest expr)))\n        (symbol? expr) (env expr)\n        :else expr))))", "user": "52951156e4b02ebb4ef7501b"}, {"problem": 121, "code": "(fn\n  [exp]\n  (fn [env]\n    (letfn [(myeval [x]\n              (cond\n                (list? x) (apply (myeval (first x)) (vec (map myeval (rest x))))\n                (symbol? x) (cond\n                             (= x '*) *\n                             (= x '+) +\n                             (= x '/) /\n                             (= x '-) -\n                             :else (env x))\n                (number? x) x))]\n      (myeval exp))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 121, "code": "(fn [e]\n  (fn [m]\n    (letfn [(evl [e]\n              (if (seq? e)\n                (let [[f & args] (replace (assoc m '/ / '+ + '- - '* *)\n                                          e)]\n                  (apply f (map evl args)))\n                e))]\n      (evl e))))", "user": "524b0645e4b09eba1c0223bf"}, {"problem": 121, "code": "(fn [x] (fn rec ([m] (rec m (first x) (rest x)))\n                ([m o ls]\n                  (let [l (map #(if (symbol? %) (get m %) %) ls)\n                        op {'+ + '- - '* * '/ /}] \n                    (reduce #((get op o) (if (seq? %1)\n                                  (rec m (first %1) (rest %1))\n                                  %1)\n                                (if (seq? %2)\n                                  (rec m (first %2) (rest %2))\n                                  %2)) l)))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 121, "code": "(fn [formula]\n(fn [values]\n((fn compute [x]\n(if (seq? x)\n(let [[op & args] x]\n(apply ({'+ + '/ / '- - '* *} op)\n(map compute args)))\n(get values x x)))\nformula)))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 121, "code": "(fn uce[f]\n  (fn [paras]\n    (if (number? f)\n      f\n      (if (sequential? f)\n        (apply ({'+ + '- - '* * '/ /} (first f)) (map #((uce %) paras) (rest f)))\n        (paras f)))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 121, "code": "(fn [body]\n  (fn [vals]\n    (let [formula (clojure.walk/prewalk-replace vals body)\n          operator-map {'+ + '- - '* * '/ /}\n          eval-formula (fn eval-formula [frm]\n                         (apply (operator-map (first frm)) (map #(if (coll? %) (eval-formula %) %) (rest frm))))]\n      (eval-formula formula)\n      )\n    )\n  )", "user": "53527551e4b084c2834f4af0"}, {"problem": 121, "code": "(fn [f]\n  (fn [v]\n    (let [functions {'+ + '- - '* * '/ /}]\n      (letfn [(replace-symbol-with-value [x]\n                (if (coll? x)\n                  (map replace-symbol-with-value x)\n                  (if-let [a (v x)] a x)))\n              (e-val [e & xpr]\n                (if (number? e)\n                  e\n                  (if (some coll? xpr)\n                    (apply (e functions)\n                           (map #(apply e-val (if-not (coll? %)\n                                                [%]\n                                                %)) xpr))\n                    (apply (e functions) xpr))))]\n        (apply e-val (map replace-symbol-with-value f))))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 121, "code": "(fn f [[o & x]] #(apply (case o\n                                / /\n                                + +\n                                - -  \n                                *) (map (fn [k] \n                                          (if (seq? k) \n                                            ((f k) %) \n                                            (% k k))) \n                                        x)))", "user": "4eb2eae5535d7eef30807351"}, {"problem": 121, "code": "(fn [c]\n  (fn [m] (letfn [(deep-replace [c m] (replace m (map #(if (coll? %) (deep-replace % m) %) c)))\n          (deep-eval [c] (apply (first c) (rest (map #(if (coll? %) (deep-eval %) %) c))))]\n            (deep-eval (deep-replace c (merge m {'+ + '- - '* * '/ /}))))))", "user": "52d07cc5e4b07d0d72b273bb"}, {"problem": 121, "code": "(fn gen-calc [a]\n  (fn calc [m]\n    (if (coll? a)\n      (let [args (map #(cond (list? %) ((gen-calc %) m) (symbol? %) (m %) :else %) (rest a))]\n        (cond \n         (symbol? (first a )) (apply ({'+ + '/ / '* * '- -} (first a)) args )))\n      a)))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 121, "code": "(fn expression [e]\n\t(letfn [(evl [env e]\n\t\t\t\t(if (sequential? e) \n      \t\t\t\t(let [[f & args] (map #(evl env %) e)]\n            \t\t\t(apply f args))\n      \t\t\t\t(or (env e) e)))]\n\t\t(fn [env]\n\t\t\t(evl (merge env {'+ + '- - '* * '/ /}) e))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 121, "code": "(fn make-evaluator [formula]\n      (letfn [(op-function [op-symbol]\n                (case (str op-symbol)\n                    \"+\" +\n                    \"-\" -\n                    \"*\" *\n                    \"/\" /))\n            (evaluate-symbol\n                [s mappings]\n                (if (symbol? s)\n                    (mappings s)\n                    s))\n            (evaluate-expr\n                [expr mappings]\n                (if (seq? expr)\n                    (let [[op & args] expr]\n                        (apply (op-function op)\n                            (map (fn [a] (evaluate-expr a mappings))\n                                args)))\n                    (evaluate-symbol expr mappings)))]\n        (fn [bindings] (evaluate-expr formula bindings))))", "user": "5165a235e4b079ad97ec44ac"}, {"problem": 121, "code": "(fn calculate [formula]\n  (fn [parameters]\n    (let [[op & pars] formula\n          opf ({(symbol \"+\") +\n                (symbol \"-\") -\n                (symbol \"*\") *\n                (symbol \"/\") /} op)\n          eval-par (fn [par] (cond (coll? par) ((calculate par) parameters)\n                                   (nil? (parameters par)) par\n                                   :else (parameters par)))\n          evaled-pars (map eval-par pars)]\n      (apply opf evaled-pars))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 121, "code": "(fn [ex]\n  (let [ ops {\"+\" + \"-\" - \"*\" * \"/\" /} ]   \n    (letfn [ (f-and-r [e m]\n                      (if (sequential? e)\n                        (if (ops (str (first e)))                                                                                   \n                          (apply (ops (str (first e))) (f-and-r (rest e) m) )\n                          (map (fn [v] (f-and-r v m) ) e))\n                        (if (symbol? e)\n                          (m e)                          \n                          e) ))                           \n             ]   \n      (fn [mp] (f-and-r ex mp) )\n      ))\n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 121, "code": "(fn t121 [[op & operands]]\n  (fn [data]\n    (let [proceed (fn [x]\n                    (cond\n                      (number? x) x\n                      (symbol? x) (data x)\n                      :else ((t121 x) data)))\n          o (map proceed operands)]\n      (cond\n        (= op '/) (apply / o)\n        (= op '+) (apply + o)\n        (= op '-) (apply - o)\n        :else (apply * o)))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 121, "code": "(fn computation-engine [expr]\n  (fn [vars]    \n    (letfn [(compute [expr]\n              (if (list? expr)\n                (apply ({'+ + '- - '* * '/ /} (first expr)) (map compute (next expr)))\n                (vars expr expr)\n                ))]\n      (compute expr))))", "user": "5244a10de4b0d8acf9ed6ab3"}, {"problem": 121, "code": "(fn [f]\n  (fn [v]\n    (letfn [(calc [args] (case (str (first args))\n                               \"/\" (apply / (rest args))\n                               \"*\" (apply * (rest args))\n                               \"+\" (apply + (rest args))\n                               \"-\" (apply - (rest args))))\n            (assign-values [v f] (clojure.walk/prewalk #(if (seq? %) (replace v %) %) f))\n            (calc-values [v] (clojure.walk/postwalk #(if (seq? %) (calc %) %) v))]\n      (calc-values (assign-values v f)))))", "user": "532418f3e4b09d4e7a9b54d8"}, {"problem": 121, "code": "(fn calculator [s]\n              (let [toyeval (fn f [c]\n                              (if (seq? c)\n                                (if (reduce #(or %1 %2) (map seq? c))\n                                  (f (map f c))\n                                  (if (= (first c) :add)\n                                    (apply + (rest c))\n                                    (if (= (first c) :subtract)\n                                      (apply - (rest c))\n                                      (if (= (first c) :divide)\n                                        (apply / (rest c))\n                                        (if (= (first c) :multiply)\n                                          (apply * (rest c))\n                                          nil)))))\n                                                    c))\n                    toyreader (fn g [n t]\n                    (let [dictionary {'+ :add '- :subtract '/ :divide '* :multiply}]\n                      (if (seq? t)\n                        (if (reduce #(or %1 %2) (map seq? t))\n                          (map (partial g n) t)\n                          (loop [init (vec t) result '()]\n                            (if (empty? init)\n                              result\n                              (if (nil? (get dictionary (peek init)))\n                                (if (nil? (get n (peek init)))\n                                  (recur (pop init) (cons (peek init) result))\n                                  (recur (pop init) (cons (get n (peek init)) result)))\n                                (recur (pop init) (cons (get dictionary (peek init)) result))))))\n                        (if (nil? (get dictionary  t))\n                          (if (nil? (get n t))\n                            t\n                            (get n t))\n                          (get dictionary t))\n                        )))]\n                 (fn f [m]\n                   (toyeval (toyreader m s)))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 121, "code": "(letfn [(calc [formula vars]\n                (cond \n                  (number? formula) formula\n                  (symbol? formula) (vars formula)\n                  :else (apply (sym-to-fun (first formula)) (map #(calc % vars) (rest formula))))\n                )\n          (sym-to-fun [sym]\n                      (cond \n                        (= '* sym) *\n                        (= '+ sym) +\n                        (= '/ sym) /\n                        (= '- sym) -))\n          \n          ]\n    (fn [formula] (partial calc formula ))  )", "user": "50eddbc4e4b06330c1f87c4b"}, {"problem": 121, "code": "(fn uce [formula]\n  (let [ops {'+ + '- - '* * '/ /}] \n  (fn [datamap] \n    (letfn [(transmog [stuff]\n                      (if (list? stuff)\n                        (apply (ops (first stuff))\n                               (map transmog (rest stuff)))\n                        (if (number? stuff)\n                          stuff\n                          (datamap stuff))))]\n      (transmog formula)))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 121, "code": "(fn compute [expr]\n  (fn [vars]\n    (let [s (map\n              (fn [x]\n                (if (sequential? x)\n                  ((compute x) vars)\n                  x\n                  ))\n              (replace vars expr))]\n      (apply ({'+ + '- - '* * '/ /} (first s)) (rest s))\n      )\n    )\n  )", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 121, "code": "(fn uce [f] \n\t(fn [vs]\n\t(cond (vs f) (vs f)\n\t\t  (sequential? f) (apply ({'+ + '/ / '* * '- -} (first f)) (map #((uce %) vs) (rest f)))\n\t\t  :else f)))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 121, "code": "(fn foo [formula]\n  (fn [values]\n    (let [exp (clojure.walk/prewalk-replace values formula)\n          calc (fn calc[exp]\n                 (if (seq? exp)\n                   (let [ops {'+ + '- - '/ / '* *}\n                         [op & args] exp]\n                     (apply (ops op) (map calc args)))\n                   exp))]\n      (calc exp))))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 121, "code": "(fn [lst]\n  (letfn [(rep [m l]\n            (let [m2 (assoc m '* * '+ + '- - '/ /)]\n              (map #(cond (contains? m2 %) (m2 %)\n                          (list? %) (rep m2 %)\n                          :else %) l)))\n          (red [op lst]\n            (reduce #(op (if (seq? %) (red (first %) (rest %)) %)\n                         (if (seq? %2) (red (first %2) (rest %2)) %2))\n                    lst))]\n    (fn [m]\n      (let [nl (rep m lst)]\n        (red (first nl) (rest nl))))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 121, "code": "(fn [expression]\n  (fn [vars]\n     ((fn evl [e]\n        (apply ({'/ / '+ + '- - '* *} (first e)) \n               (map #(if (coll? %)\n                       (evl %)\n                       (or (vars %) %))\n                    (rest e))))\n      expression)))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 121, "code": "(fn g [[f & p]]\n  #(apply ({'- - '+ + '* * '/ /} f)\n          (for [a p]\n             (cond (symbol? a) (% a)\n            \t   (seq? a) ((g a) %)\n              \t   1 a))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 121, "code": "(fn [expr]\n  (fn [vars]\n    (letfn [(ev [expr]\n              (if (coll? expr)\n                (apply ({'+ + '- - '/ / '* *} (first expr)) (map ev (rest expr)))\n                (if-let [v (vars expr)] v expr)))]\n      (ev expr))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 121, "code": "(fn [expr]\n    (letfn [(bind-expr [e bindings]\n              (let [fn-lookup {'+ + '- - '* * '/ /}]\n                (if (sequential? e)\n                  (let [sub-e (map #(bind-expr % bindings) e)]\n                    (apply (fn-lookup (first sub-e)) (rest sub-e)))\n                (bindings e e))))]\n     (partial bind-expr expr)))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 121, "code": "(fn f [e]\n  (fn [m]\n    (if (seq? e)\n      (apply ({'+ + '- - '* * '/ /} (first e))\n             (map #((f %) m) (rest e)))\n      (m e e))))", "user": "53034738e4b0d8b024fd373e"}, {"problem": 121, "code": "(fn [formula]\n    (fn [m]\n      (let [mm (into {} (partition-all 2 m))\n            fmap {'+ + '- - '/ / '* *}]\n        ((fn f [form]\n          (cond\n           (seq? form) (apply (fmap (first form)) (map f (rest form)))\n           (symbol? form) (mm form)\n           :else form))\n         formula))))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 121, "code": "(fn [x] (fn [y] ((fn rot [z] (if (coll? z) (apply (case (str (first z)) \"/\" / \"-\" - \"+\" + \"*\" *) (map rot (rest z))) z)) ((fn peu [u] (map #(cond (coll? %) (peu %) (contains? y %) (y %) :else %) u)) x))))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 121, "code": "(fn [expr]\n    (fn [dict]\n      (letfn [(trans [x] (or (get dict x) x))\n              (full-trans [x] (if (sequential? x) (map full-trans x) (trans x)))]\n        (let [real (full-trans expr)\n              op (fn [op-symb] ({'+ + '- - '/ / '* *} op-symb))\n              do-calc (fn calc [x] (if (sequential? x) (apply (op (first x)) (map calc (rest x)))\n                                      x))]\n          (do-calc real)))))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 121, "code": "(fn compute [body]\n  (let [ops {'+ +, '/ /, '- -, '* *}]\n    (fn [params]\n      (apply \n        (ops (first body))\n        (map (fn [elem] \n                (cond \n                  (seq? elem) ((compute elem) params) \n                  (symbol? elem) (params elem)\n                  :else elem)) \n              (rest body))))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 121, "code": "(fn [formula]  \n  (fn [values]    \n    ((fn compute [x]       \n       (if (seq? x)         \n         (let [[op & args] x]           \n           (apply ({'+ + '/ / '- - '* *} op)                  \n                  (map compute args)))         \n         (get values x x)))     \n     formula)))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 121, "code": "(fn calculate\n  [form]\n  (letfn [(calc [form bindings]\n            (let [bindings (assoc bindings\n                             '+ +\n                             '- -\n                             '* *\n                             '/ /)]\n              (if (coll? form)\n                (let [expanded (map #(calc % bindings) form)]\n                  (apply (first expanded) (rest expanded)))\n                (get bindings form form))))]\n    #(calc form %)))", "user": "51f9527fe4b09be9c177e549"}, {"problem": 121, "code": "(fn uce [[o a b & args]]\n   (let [ops {'+ +\n              '- -\n              '* *\n              '/ /}]\n     (fn [mp] (apply (ops o)\n                     (cons (if (seq? a) ((uce a) mp) (if (symbol? a) (a mp) a))\n                           (cons (if (seq? b) ((uce b) mp) (if (symbol? b) (b mp) b)) args))))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 121, "code": "(fn expression-evaluator [expr]\n  (fn [subs-map]\n   (let [subbed-expr (clojure.walk/prewalk-replace subs-map expr)\n        arithmetic-eval (fn aeval [expr]\n                          (let [identsym {'+ +, '- -, '* *, '/ /}]\n                             (if (coll? expr)\n                               (apply (identsym (first expr))\n                                      (map aeval (rest expr)))\n                               (identsym expr expr))))]\n    (arithmetic-eval subbed-expr))))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 121, "code": "(fn univCompEng [formula]\n  (letfn[(getSymMap[symVal]\n                   (apply assoc {} \n                          (mapcat \n                           (fn[[sym val]] [(keyword (str sym)) val])\n                           (vec symVal))))\n         (evalFormula[[op & nums] symMap]\n                       (apply\n                        (case (str op)\n                          \"/\" /\n                          \"+\" +\n                          \"-\" -\n                          \"*\" *)\n                        (map \n                         (fn [x]\n                           (cond\n                            (symbol? x) (symMap (keyword (str x)))\n                            (coll? x) (evalFormula x symMap)\n                            :else x))\n                         nums)))]\n    (fn [symbolValue]\n      (evalFormula formula (getSymMap symbolValue)))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 121, "code": "(fn [form]\n  (fn [vars]\n    (letfn [(m [[op & args]]\n              (prn op args)\n              (apply (case op\n                       + +\n                       - -\n                       * *\n                       / /)\n                (map #(cond\n                        (symbol? %) (vars %)\n                        (seq? %) (m %)\n                        :else %)\n                  args)))\n             ]\n      (m form))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 121, "code": "(fn p121\n  [coll]\n  (fn [m]\n    (if (list? coll)\n      (apply (case (first coll)\n               / /\n               + +\n               * *\n               - -)\n             (for [e (rest coll)]\n               (if (list? e)\n                 ((p121 e) m)\n                 (get m e e)))))))", "user": "4e521cef535d302ef430da6d"}, {"problem": 121, "code": "(fn uce [f]\n  (fn [env]\n    (cond (seq? f) (apply (case (first f) + + - - * * / /) ((apply juxt (map uce (rest f))) env))\n          (number? f) f\n          (symbol? f) (get env f))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 121, "code": "partial\n  (fn e [c v]\n    (if (seq? c)\n        (apply ({'+ + '- - '* * '/ /} (first c)) (map #(e % v) (rest c)))\n        (v c c)))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 121, "code": "(fn calc [f]\n      (fn [m]\n        (apply\n          ({(symbol \"+\") +,\n            (symbol \"-\") -,\n            (symbol \"*\") *,\n            (symbol \"/\") /}\n            (first f))\n          (map (fn [e] (cond\n                         (coll? e) ((calc e) m)\n                         (number? e) e\n                         :else (m e)))\n               (rest f)))))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 121, "code": "(fn [formula]\n          (let [ops {'+ + '- - '/ / '* *}\n                expr (fn expr [[op & args] m]\n                       (apply (op ops)\n                              (reduce #(conj %1 (if (coll? %2)\n                                                  (expr %2 m)\n                                                  (m %2 %2)))\n                                      [] args)))]\n            (fn [m] (expr formula m))))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 121, "code": "(fn uni [form]\n  (fn [bindings]\n    (let [ops {'/ / '+ + '- - '* *}]\n     (apply (ops (first form))\n       (map \n        (fn [f]\n          (cond\n           (seq? f) ((uni f) bindings)\n           (symbol? f) (bindings f)\n           :else f))\n        (rest form))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 121, "code": "(fn [func]\n  (fn [m]\n    (let [calc (fn calc [func]\n                 (if (seq? func)    \t\t\t\t\n    \t\t\t\t(let [[op & args] func]\n                      (apply ({'+ +\n       \t\t\t\t           '- -\n       \t\t\t\t           '* *\n       \t\t\t\t           '/ /} op) \n                             (map calc args)))\n                   (m func func)))]\n      (calc func))))", "user": "4db92654535d1e037afb21a0"}, {"problem": 121, "code": "#(fn [m] (\n     (fn f[e]\n        (if (coll? e)\n          (apply (case (first e) + + - - * * / /) (map f (rest e)))\n          (m e e)\n        ))\n      %))", "user": "5281a445e4b0757a1b17143a"}, {"problem": 121, "code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "user": "53d6b266e4b0e771c3025459"}, {"problem": 121, "code": "(fn [form]\n      (letfn [(calc [form variables]\n                    (cond\n                      (number? form) form\n                      (symbol? form) (get variables form)\n                      (coll? form) (apply\n                                     ({'+ + '* * '- - '/ /} (first form))\n                                     (map (fn [subform]\n                                            (calc subform variables))\n                                          (rest form)))))]\n        (fn [variables]\n          (calc form variables))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 121, "code": "(fn [ex]\n  (letfn [(evaluate [form binds]\n            (cond\n             (= (class form) clojure.lang.PersistentList)\n             (let [proc (evaluate (first form) binds)\n                   args (map #(evaluate % binds) (rest form))]\n               (apply proc args))\n             (contains? binds form)\n             (evaluate (get binds form) binds)\n             (symbol? form)\n             (cond\n              (= (name form) \"+\") +\n              (= (name form) \"-\") -\n              (= (name form) \"*\") *\n              (= (name form) \"/\") /)\n             :else form))]\n    (fn [bindings]\n      (evaluate ex bindings))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 121, "code": "(fn [exprs]\n  (fn [var-map]\n    (let [exprs (clojure.walk/postwalk-replace var-map exprs)\n          ev (fn ev [expr]\n               (let [[op & es] expr\n                     es (map #(if (list? %) (ev %) %) es)]\n                 (apply ({'+ +, '- -, '* *, '/ /} op) es)))]\n      (ev exprs))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 121, "code": "(fn xxx [form]\n  (letfn [(my-eval [x]\n            (if (list? x)\n              (apply (first x) (map my-eval (rest x)))\n              x))]\n    (fn [m]\n      (-> (assoc m '/ / '* * '+ + '- -)\n          (clojure.walk/postwalk-replace form)\n          (my-eval)))))", "user": "505aa653e4b021387fb89857"}, {"problem": 121, "code": "(let [comput {'/ / '+ + '- - '* *}]\n  (fn [form]\n    (fn [env]\n      (letfn [(run [form]\n                   (if (seq? form)\n                     (let [[op & args] form]\n                       (apply (comput op)\n                              (for [f args] (run f))))\n                     (env form form)))]\n        (run form)))))", "user": "4ec53831535d6d7199dd3684"}, {"problem": 121, "code": "(fn uce [[op & params]]\n  (fn [m]\n    (apply ({'+ + '- - '* * '/ /} op) (map #(cond\n                                             (seq? %) ((uce %) m)\n                                             (symbol? %) (m %)\n                                             :else %) params))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 121, "code": "(let [ops {'+ + '* * '- - '/ /}]\n  (fn [exp]\n    (fn [vars]\n      (letfn [(uc [exp]\n                (cond\n                 (number? exp) exp\n                 (symbol? exp) (vars exp)\n                 true (apply (ops (first exp)) (map uc (rest exp)))))]\n        (uc exp)))))", "user": "51672d15e4b079759a74a5e7"}, {"problem": 121, "code": "(fn univ-comp [fs]\n   (fn [m]\n     (let [arithm {'/ /, '* *, '+ +, '- -}]\n       (clojure.walk/postwalk #(if (coll? %) (apply (arithm (first %)) (next %)) %)\n        (clojure.walk/postwalk-replace m fs)\n        )\n       )\n     )\n )", "user": "529a73bde4b02ebb4ef75096"}, {"problem": 121, "code": "(fn [expr]\n        (fn [m]\n          (letfn [(proc [[op & args]]\n                    (apply (op {'/ / '+ + '- - '* *})\n                           (map #(if (symbol? %) (get m %)\n                                     (if (number? %) % (proc %))) args)))]\n            (proc expr))))", "user": "502873a8e4b01614d1633ff8"}, {"problem": 121, "code": "(fn [formula]\n    (let [ev (fn e [env f]\n               (cond\n                (seq? f) (apply (e env (first f)) (map (partial e env) (rest f)))\n                (symbol? f) (env f) ; lookup\n                :else f))] ; autoquoted stuff\n      (partial\n       (fn interpreter [program env]\n         (ev (merge env {'+ + , '- - , '* * , '/ /})\n             program))\n       formula)))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 121, "code": "(fn [form] \n  (fn ! [params] \n    (letfn [(compe [tree]\n\t\t(if (seq? tree) \n          (let [valsl (map #(compe %) (rest tree))\n                re (case (first tree) \n                     / (reduce / valsl)\n                     * (reduce * valsl)\n                     + (reduce + valsl)\n                     - (reduce - valsl))]\n\t\t\t\tre)\n            (let [valme (if (number? tree) tree (params tree))]\n            (do (println valme)\n              valme))\n          )\n                   )]\n      (compe form))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 121, "code": "(fn [symbolic-expression]\n  (fn [values-map]\n    (let [\n          ops-map {'+ + '- - '* * '/ /}\n          substitute (fn [coll] (map #(get values-map % %) coll))\n          evaluate (fn evaluate [expression]\n                     (if (number? expression)\n                       expression\n                       (let [[op & args] (substitute expression)]\n                         (apply (ops-map op) (map evaluate args)))))]\n      (evaluate symbolic-expression))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 121, "code": "(fn __ [llist]\n  (fn [matches]\n    (let[q (replace matches llist) w (case (str (first q)) \"/\" / \"*\" * \"+\" + \"-\" -) \n         args (rest q) \n         f (fn[arg](if(seq? arg) ((__ arg) matches) arg) )] \n       (apply w (map f args)))))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 121, "code": "(fn [form]\n  (fn [ctx]\n    ((fn c [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '- - '/ / '* *} op)\n                  (map c args)))\n         (get ctx x x))) form)))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 121, "code": "(fn uce [e]\n    (fn [m]\n      (letfn [\n      (sym-check [a f]\n       (cond\n           (number? a) a\n           (symbol? a) (get m a)\n            :else (f a m)))\n      (uce* [e m]\n         (let [[ops & r] e\n          oper (get {'+ +,'* *,'- -,'/ /} ops)]\n       (reduce\n         (fn [a b]\n         (oper\n           (sym-check a uce*)\n           (sym-check b uce*))) r)))]\n       (uce* e m))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 121, "code": "(fn [formula]\n  (fn [m]\n    ((fn calc [[o & opr]]\n       (apply ({'/ / '- - '+ + '* *} o)\n        (map #(if (coll? %) (calc %) (get m % %)) opr)\n        ))\n     formula)))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 121, "code": "(fn comp [e]\n  (fn [args]\n    (cond\n     (number? e) e\n     (symbol? e) (args e)\n     :else (let [[f & es] e\n                 fes (map comp es)\n                 res (map #(% args) fes)]\n             ( apply ({'+ + '- - '* * '/ / } f) res)))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 121, "code": "partial (fn uce [l m]\n  (letfn  [(sub [l m]\n              (for [x l]\n                (cond \n                 (symbol? x) (m x)\n                 (list? x) (calc x m)\n                 :else x)))\n\n           (calc [[fun & args] m]\n             (apply \n              (condp = fun\n                '+ +\n                '- -\n                '* *\n                '/ /)\n              (sub args m)))]\n    \n    (calc l m)))", "user": "54848141e4b0e286459a119e"}, {"problem": 121, "code": "(fn e [x]\n  (fn [t] \n    (cond\n      (number? x) x\n      (symbol? x) (t x)\n      :else\n      (let [[o & rs] x\n            os {'+ + '- - \n                '* * '/ /}]\n        (->> (map #((e %) t) rs)\n             (apply (os o)))))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 121, "code": "(fn uce [expr]\n  (let [fn-mappings (apply hash-map ['+ + '- - '* * '/ /])]\n\n    (letfn [(map-args [st mappings]\n              (map (fn [sym]\n                     (if (coll? sym)\n                       (map-args sym mappings)\n                       (get mappings sym sym)))\n                   st))\n\n            (visit [[op & arguments]]\n              (if (nil? arguments)\n                (recur op)\n                (if-not (some coll? arguments)\n                  (apply (fn-mappings op) arguments)\n                  (visit\n                   (cons op (map (fn [x]\n                                   (if (coll? x)\n                                     (visit x)\n                                     x))\n                                 arguments))))))]\n\n      (fn [& args]\n        (->> (map-args expr (first args)) visit)))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 121, "code": ";; 4clojure says no to eval, otherwise I had this cute\n;; solution:\n;(fn [form]\n;  (fn [syms]\n;    (eval \n;     `(let ~(vec (apply interleave ((juxt keys vals) syms)))\n;        ~form))))\n\n(fn [form]\n  (fn [syms]\n    ((fn eval' [a]\n       (println a (coll? a) (symbol? a))\n       (if (coll? a)\n         (let [[op & args] a]\n           (apply ({'+ + '- - '/ / '* *} op)\n                  (map eval' args)))\n         (if (symbol? a) (syms a) a)))\n     form)))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 121, "code": "(fn [form]\n  (letfn [(step [s]\n            (let [formulars (re-seq #\"\\([^\\(\\)]*\\)\" s)]\n              (if (seq formulars)\n                (let [formulars-results (map\n                                          (fn [formular]\n                                            (let [formular-seq (re-seq #\"[\\+\\-\\*/0-9]+\" formular)]\n                                              (apply\n                                                (case (first formular-seq)\n                                                  \"+\" +\n                                                  \"-\" -\n                                                  \"*\" *\n                                                  \"/\" /)\n                                                (map #(Integer/parseInt %) (rest formular-seq)))\n                                              ))\n                                          formulars)]\n                  (step (reduce #(.replace %1 (key %2) (str (val %2))) s (apply assoc {} (interleave formulars formulars-results)))))\n                (Integer/parseInt s))))]\n    (fn [m]\n      (let [form-str (str form)]\n        (step (reduce #(.replace %1 (str (key %2)) (str (val %2))) form-str m))))))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 121, "code": "(fn [form]\n  (fn [m]\n    (let [m (merge m {'/ / '* * '+ + '- -})]\n      (clojure.walk/postwalk \n        #(cond \n          (contains? m %) (% m)\n          (list? %) (apply (first %) (rest %))\n          :else %)\n        form))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 121, "code": "(fn __ [x]\n  (fn f [m]\n    (letfn [(e [x]\n               (if (coll? x)\n                 (case (first x)\n                   + (apply + (map e (rest x)))\n                   - (apply - (map e (rest x)))\n                   * (apply * (map e (rest x)))\n                   / (apply / (map e (rest x)))\n                   nil)\n                 (let [y (get m x)]\n                   (if (nil? y) x\n                     y))))]\n      (e x))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 121, "code": "(fn [form]\n  (fn [bindings]\n    (let [bindings (into {'+ + '- - '* * '/ /} bindings)]\n      (letfn [(resolve' [form] (cond\n                                 (seq? form) (eval' form)\n                                 (symbol? form) (get bindings form)\n                                 :else form))\n              (eval' [[op & args]]\n                (reduce (resolve' op) (map resolve' args)))]\n        (resolve' form)))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 121, "code": "(fn cal [e]\n    (fn [bs] (cond (list? e) (let [[op & as] e as (map #((cal %) bs) as)]\n                               (case op + (apply + as) - (apply - as) / (apply / as) * (apply * as)))\n                   (symbol? e) (get bs e)\n                   :else e)))", "user": "54c641f8e4b045293a27f628"}, {"problem": 121, "code": "(fn [exp]\n  (letfn [(uce [e m]\n               (cond\n                 (list? e) (apply ({'+ +, '* *, '/ / '- -} (first e)) (map #(uce % m) (rest e)))\n                 (symbol? e) (m e) \n                 :else e))]\n    (partial uce exp)))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 121, "code": "(fn evl [ expression ]\n  (fn [bindings]\n    (let [functions {'/ / '+ + '* * '- -}] \n      (cond\n        (contains? bindings expression) (bindings expression)\n        (seq? expression)     (apply (functions (first expression)) (map #( (evl %) bindings) (rest expression)) )\n        :else                 expression)))\n    )", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 121, "code": "(fn eval-math [expr]\n    (cond\n      (symbol? expr) (fn [ctx]\n                       (get ctx expr))\n      (list? expr) (let [funcs {'+ + '- - '* * '/ /}]\n                     (fn [ctx]\n                       (let [func (first expr)\n                             argv (map #((eval-math %) ctx) (rest expr))]\n                         (apply (get funcs func) argv))))\n      :else (fn [ctx]\n              expr)))", "user": "53f31dafe4b0742d9025b0f0"}, {"problem": 121, "code": "(fn [formula]\n    (fn [values]\n      ((fn compute [formula]\n          (if (list? formula)\n            (let [ops {'+ + '- - '* * '/ /}\n                  [op & args] formula]\n              (apply (get ops op) (map (fn [arg] (compute arg)) args)))\n            (or (get values formula) formula))) formula)))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 121, "code": "(fn q[[f & p]]\n    (fn [m]\n      (apply \n        (cond\n          (= '+ f) +\n          (= '* f) *\n          (= '/ f) /\n          (= '- f) -\n          :else max\n          )\n        (loop [p p r []]\n          (if (seq p)\n            (recur\n              (rest p)\n              (conj r\n                    (cond\n                      (coll? (first p)) ((q (first p)) m)\n                      (symbol? (first p)) (m (first p))\n                      :else (first p)\n                      )\n                    )\n              )\n            r \n            )       \n          )           \n        )             \n      )               \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 121, "code": "(fn [expr]\n  (fn [context]\n    (letfn [(solve [x]\n              (if (list? x)\n                (apply ({'/ / '+ + '- - '* *} (first x)) (map solve (rest x)))\n                (if (number? x) x\n                    (context x))))]\n      (solve expr))))", "user": "4f2d5f5de4b0d6649770a05a"}, {"problem": 121, "code": "(fn [x]\n  (let [w clojure.walk/postwalk]\n    (fn [v]\n  \t\t(w #(if (coll? %) (apply ({'+ + '- - '/ / '* *} (first %)) (rest %)) %) (w #(get v % %) x)))))", "user": "514d8084e4b019235f6c0588"}, {"problem": 121, "code": "(fn calc-fun [formula]\n  (fn myfun\n    ([m] (myfun (merge m {'+ + '- - '* * '/ /}) formula))\n    ([m f]\n     (cond\n       (list? f) (apply (myfun m (first f)) (map #(myfun m %) (rest f)))\n       (number? f) f\n       :else (get m f)))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 121, "code": "(fn uce [f]\r\n  (fn [m]\r\n    (clojure.walk/postwalk \r\n      (fn [s] \r\n        (if (list? s)\r\n          (apply \r\n            ((first s) {'+ + '- - '/ / '* *})\r\n            (map #(if (symbol? %) (% m) %) (rest s)))\r\n          s))\r\n      f)))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 121, "code": "(fn [formula]\n  (fn [bind]\n    (let [rename (fn rename [lst m]\n                   (map (fn [ele]\n                          (cond (list? ele)\n                                (rename ele m)\n                                (or (= '+ ele)\n                                    (= '- ele)\n                                    (= '/ ele)\n                                    (= '* ele))\n                                ele\n                                (number? ele)\n                                ele\n                                :else\n                                (get m ele)))\n                        lst))\n          calc (fn calc [f]\n                 (if (not (seq? f)) f\n                   (let [fi (first f)\n                         res (map calc (rest f))]\n                     (cond (= fi '+) (apply + res)\n                           (= fi '-) (apply - res)\n                           (= fi '/) (apply / res)\n                           (= fi '*) (apply * res)))))]\n      (calc (rename formula bind)))))", "user": "53664e3be4b0243289761e74"}, {"problem": 121, "code": "#(fn [b]\n   ((fn f [e]\n      (if (seq? e) (apply ({'/ / '+ + '* * '- -} (first e)) (map f (rest e)))\n          (b e e))) %))", "user": "50548ce8e4b0b1b9d1860ead"}, {"problem": 121, "code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 121, "code": "(fn computation-engine [[op & args]]\n  (fn [ctx]\n    (let [ops {'/ /, '+ +, '* *, '- -}\n          compute (fn [v]\n                    (if (coll? v)\n                      ((computation-engine v) ctx)\n                      (or (ctx v) v)))]\n      (apply (ops op) (map compute args)))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 121, "code": "(fn [ex]\n    (fn [vars]\n      (letfn [(evaluate [ex]\n                (cond (sequential? ex)\n                      (let [[op & xs] ex\n                            exs (map evaluate xs)]\n                        (apply ({'* * '+ + '- - '/ /} op) exs))\n\n                      (symbol? ex)\n                      (vars ex)\n\n                      :else\n                      ex))]\n        (evaluate ex))))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 121, "code": "(fn [expr]\n  (fn [m]\n    (letfn [(f [[op & args]] (apply (case op + + - - * * / /)\n                                    (map #(cond (sequential? %) (f %)\n                                                (symbol? %) (m %)\n                                                :else %) args)))]\n      (f expr))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 121, "code": "(fn [form]\n  (let [ops {'+ + '* * '- - '/ /}\n        meval (fn meval [exp]\n                (if (sequential? exp)\n                  (apply (get ops (first exp)) (map meval (rest exp)))\n                  exp))]\n    (fn [param]\n      (let [prog (reduce #(clojure.string/replace %1 (str (key %2)) (str (val %2)))\n                         (str form)\n                         param)]\n        (meval (read-string prog))))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 121, "code": "(fn evaluate [e]\n  (fn [env]\n    (cond (number? e) e\n          (symbol? e) (e env)\n          (seq? e)\n            (let [op ((first e) {'+ +, '* *, '- -, '/ /})]\n              (apply op \n                (map #((evaluate %) env) (rest e)))))))", "user": "50bc23e4e4b0594b91591c3c"}, {"problem": 121, "code": "(fn ucm[f]\n  (fn [ma] \n    (letfn [(pf[frm]\n              (cond\n                (number? frm) frm\n                (symbol? frm) (get ma frm)\n                (list? frm) (let [op (str (first frm))\n                                  args (map pf (rest frm))] \n                              (case op\n                                \"+\" (apply + args)\n                                \"-\" (apply - args)\n                                \"/\" (apply / args)\n                                \"*\" (apply * args)))))]\n      (pf f))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 121, "code": "(fn uce [formula] \n  (fn inner [bindings] \n    (letfn [(evaluate [b f] \n                      (let [s {'+ + '- - '* * '/ /}] \n                        (if (number? f) \n                          f \n                          (if (b f) \n                            (b f) \n                            (apply (s (first f)) \n                                   (vec (map (partial evaluate b) (rest f))))))))] \n      (evaluate bindings (vec formula)))))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 121, "code": "(fn cal [x]\n (fn [vm]\n  (if\n   (seq? x)\n    (let [[op & xs] x\n          f #((cal %) vm)]\n     (apply\n      ({'+ +\n        '- -\n        '* *\n        '/ /} op)\n      (map f xs)))\n   (vm x x))))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 121, "code": "(fn [l]\n     (fn [m]\n       (letfn [(change [x]\n                       (reduce #(if (= %1 (first %2))\n                                 (second %2) %1) x (concat (map identity m) [['/ /] ['+ +] ['- -] ['* *]])))\n               (calc [y]\n                     (apply (change (first y))\n                            (map #(if (list? %)\n                                   (calc %)\n                                   (change %)) (rest y))))]\n         (calc l)\n       )))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 121, "code": "(fn [formula]\n  (fn [e]\n  \t((fn value [form]\n       (cond\n        (symbol? form) (e form)\n        (number? form) form\n        :else (apply ({'+ +, '- -, '* *, '/ /} (first form))\n                     (map value (rest form)))))\n     formula)))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 121, "code": "(fn calcuate-value [formula]\n  (let [ops {'/ /\n             '+ +\n             '- -\n             '* *}]\n    (fn [params]\n      (cond (list? formula)\n            (apply (ops (first formula))\n                   (map #((calcuate-value %) params)\n                        (rest formula)))\n            (symbol? formula)\n            (params formula)\n            :else\n            formula))))", "user": "5508b405e4b06e50f9beb110"}, {"problem": 121, "code": "#(letfn [(f [x y]\n            (apply ({'+ + '- - '* * '/ /} (nth x 0)) (for [_ (rest x)]\n                                                       (if (seq? _)\n                                                         (f _ y)\n                                                         (if (symbol? _)\n                                                           (y _)\n                                                           _)))))]\n   (partial f %))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 121, "code": "(fn [lst]\n  (letfn [(rpl [d lst]\n            (map (fn [item]\n                   (if (list? item)\n                     (rpl d item)\n                     (get d item item)))\n                 lst))\n          (myval [lst]\n            (if (not (coll? lst)) lst\n                (let [cmapx {'/ / '* * '- - '+ +}]\n                  (apply ((first lst) cmapx) (map myval (rest lst))))))]\n    (fn [d]\n      (myval (rpl d lst)))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 121, "code": "(fn uce [formula]\n  (fn [arg]\n    (let [m (clojure.walk/prewalk-replace arg formula)\n                myeval (fn myeval [l]\n              (if (coll? l)\n              (condp = (first l)\n                '* (apply * (myeval (rest l)))\n                '/ (apply / (myeval (rest l)))\n                '+ (apply + (myeval (rest l)))\n                '- (apply - (myeval (rest l)))\n                 (map myeval l))\n                l))]\n    (myeval m))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 121, "code": "(fn engine [formula]\n  (fn [vars]\n    (let [[op & args] formula\n          extract-num (fn [x]\n                        (cond\n                          (symbol? x) (get vars x)\n                          (sequential? x) ((engine x) vars)\n                          :else x))\n          nums (map extract-num args)\n          op-fn (cond\n                  (= op '+) +\n                  (= op '-) -\n                  (= op '*) *\n                  (= op '/) /)]\n      (apply op-fn nums))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 121, "code": "(let [rator-map {'+ +, '- -, '* *, '/ /}]\n  (fn [expr]\n    (fn [substitution-map]\n      (let [evaluate (fn evaluate [term]\n                       (if (seq? term)\n                         (apply (rator-map (first term)) (map evaluate (rest term)))\n                         (get substitution-map term term)))]\n        (evaluate expr)))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 121, "code": "(fn [expr]\n  (fn [vars]\n    (let [ops {'+ + '- - '* * '/ /}\n          compute (fn compute [expr]\n                    (cond (contains? vars expr) (vars expr)\n                          (list? expr) (apply (ops (first expr)) (map compute (rest expr)))\n                          :else expr))]\n      (compute expr))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 121, "code": "(fn [f]\n    (fn [replacements]\n      (letfn [(replace-vars [[f & fs :as formula]]\n                (cond (empty? formula) ()\n                      (coll? f) (cons (replace-vars f) (replace-vars fs))\n                      (replacements f) (cons (replacements f) (replace-vars fs))\n                      :else (cons f (replace-vars fs))))\n              (compute [f]\n                (if (number? f)\n                  f\n                  (reduce ({'* * '/ / '- - '+ +} (first f)) (map compute (rest f)))))]\n        (compute (replace-vars f)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 121, "code": "(fn a [e] \n   (fn  b [m]\n     (let [sfm { '+ + '- - '* * '/ /}]\n           ((fn x [j]\n              (if (seq? j)\n                   (apply (sfm (first j)) (map x (rest j)))\n                   (m j j))) e))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 121, "code": "(fn ! [[h & expr]]\n  (fn [m]\n    (let [t (map #(cond\n                   (seq? %) ((! %) m)\n                   (symbol? %) (get m %)\n                   :else %)\n                 expr)]\n      (case (name h)\n        \"+\" (apply + t)\n        \"-\" (apply - t)\n        \"*\" (apply * t)\n        \"/\" (apply / t)))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 121, "code": "(fn computation [code]\n  (let [aux (fn rec [code m]\n              (cond (seq? code) (let [ops {'+ #(apply + %) '/ #(apply / %) '* #(apply * %) '- #(apply - %)}\n                                      [c0 & cs] code]\n                                  (if (symbol? c0) ((get ops c0) (map #(rec % m) cs))\n                                    (map #(rec % m) code)))\n                    (symbol? code) (get m code)\n                    true code))]\n    (fn [m] (aux code m))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 121, "code": "(fn [expr]\n    (fn [env]\n      (let [my-eval (fn my-eval [expr env]\n                        (let [env (assoc env '* * '/ / '+ + '- -)]\n                          (cond\n                            (symbol? expr) (env expr)\n                            (list? expr) (let [[f & args] (map #(my-eval % env) expr)] (apply f args))\n                            :else expr)))]\n        (my-eval expr env))))", "user": "4ee6400c535d93acb0a6685b"}, {"problem": 121, "code": "(fn principal [e] \n  (fn [m]\n    (let [f (fn [x] (cond (coll? x) ((principal x) m) (m x) (m x) :else x) )]\n  \t(cond (= '/ (first e)) (apply / (map f (rest e)) )\n          (= '* (first e)) (apply * (map f (rest e)) )\n          (= '- (first e)) (apply - (map f (rest e)) )\n          (= '+ (first e)) (apply + (map f (rest e)) )\n          :else \"nada\"))\n  )\n)", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 121, "code": "(fn c [[f & a]]\n  (fn [v]\n    (apply (f {'/ / '* * '+ + '- -})\n      (map #(\n          cond\n          (seq? %) ((c %) v)\n          (symbol? %) (% v)\n          true %) a))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 121, "code": "(fn [f]\n  (fn [m]\n    (letfn [(calc [f]\n                  (cond\n                   (contains? m f) (m f)\n                   (not (seq? f)) f\n                   :else\n                   (apply (case (first f) + + - - * * / /) (map calc (rest f)))))]\n      (calc f))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 121, "code": "(fn [expr]\n  (fn [vals]\n    ((fn calc [x]\n       (if (coll? x)\n         (let [[f & xs] x]\n           (apply ({'+ + '- - '/ / '* *} f) (map calc xs)))\n         (get vals x x)))\n      expr)))", "user": "5383668ee4b06839e8705edd"}, {"problem": 121, "code": "(fn c [e]\n  (fn [ev]\n    (if (number? e)\n      e\n      (if (symbol? e)\n        (ev e)\n        (let [ops {'/ / '+ + '- - '* *}]\n          (apply (ops (peek e)) (map #(%1 ev) (map c (pop e))))\n          )))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 121, "code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 121, "code": "(fn [s]\n  (let [fmap {'/ / '* * '+ + '- -}]\n    (fn [v]\n      ((fn call [[o & a]]\n         (apply (fmap o) (map #(if (coll? %) (call %) (get v % %)) a))) s))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 121, "code": "(fn [expr]\n  (let [ops (zipmap '(+ - * /) [+ - * /])]\n    (fn [vars]\n      ((fn parse [e]\n         (if (list? e)\n           (apply (ops (first e)) (map parse (rest e)))\n           (or (vars e) e)))\n       expr))))", "user": "55495318e4b0a04f79299566"}, {"problem": 121, "code": "(fn [f]\n  (letfn [(ev [e m]\n              (cond\n               (number? e) e\n               (symbol? e) (m e)\n               :else (apply ({'+ + '- - '* * '/ /} (first e))\n                            (map #(ev % m) (rest e)))))]\n    (fn [m] (ev f m))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 121, "code": "(fn unicomp [vals]\n  (fn [sym-m]\n    ((fn unicomp-solver [d]\n      (if (sequential? d)\n        (apply ({'+ + '- - '* * '/ /} (first d))\n               (map unicomp-solver (rest d)))\n        d))\n     (list*\n       (reduce\n         (fn [acc e]\n           (if (sequential? e)\n             (conj acc ((unicomp e) sym-m))\n             (if (nil? (sym-m e))\n                (conj acc e)\n                (conj acc (sym-m e)))))\n       []\n       vals)))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 121, "code": "(fn [formula]\n\t(letfn [(calc [expr var-binding]\n\t\t(cond\n\t\t\t(= expr '+) +\n\t\t\t(= expr '-) -\n\t\t\t(= expr '*) *\n\t\t\t(= expr '/) /\n\t\t\t(number? expr) expr\n\t\t\t(symbol? expr) (get var-binding expr)\n\t\t\t(list? expr) (let [e0 (calc (first expr) var-binding), e' (next expr)]\n\t\t\t\t(if (nil? e') e0 (apply e0 (map #(calc % var-binding) e'))))))]\n\t\t(partial calc formula)))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 121, "code": "(let [;; If this function is given a valid formula, it will return the set of\n        ;; free variables in that formula. Otherwise it returns nil.\n        check-formula\n        (fn check-formula [f]\n          (cond\n            (number? f)                    #{}\n            (symbol? f)                    (hash-set f)\n            (not (sequential? f))          nil\n            (not ('#{+ - * /} (first f)))  nil\n\n            ;; Once we've dealt with the above special cases, we have to\n            ;; recur. We can't just take the union of (map check-formula (rest\n            ;; f)), because this will discard nil results, and we need those to\n            ;; bubble up to signal an invalid formula. In the following code, we\n            ;; obtain this by using keep rather than map, then count to see if\n            ;; we discarded any nil results.\n            :else (let [arg-check (keep check-formula (rest f))]\n                    (if (= (count (rest f)) (count arg-check))\n                      (apply clojure.set/union arg-check)))))\n\n        ;; This function takes a map associating symbols to numbers and a\n        ;; formula f, and returns the new formula obtained by substituting (m x)\n        ;; for each variable x appearing both as a key in m and as a variable in\n        ;; f.\n        substitute\n        (fn substitute [m f]\n          (cond\n            (number? f)  f\n            (symbol? f)  (if (contains? m f) (m f) f)\n            :else        (map (partial substitute m) f)))\n\n        ;; This function evaluates a valid formula with no free variables.\n        eval-formula\n        (fn eval-formula [f]\n          (let [op-map {'+ +, '- -, '* *, '/ /}]\n            (if (number? f)\n              f\n              (apply (op-map (first f))\n                     (map eval-formula (rest f))))))]\n\n    ;; If the map m passed to the result of this function does not contain a\n    ;; value for every free variable in the formula f, then we still perform all\n    ;; possible substitutions and return the resulting formula rather than\n    ;; evaluating it.\n    (fn formula-calculator [f]\n      {:pre [(check-formula f)]}\n      (fn [m]\n        {:pre [(associative? m),\n               (every? symbol? (keys m)),\n               (every? number? (vals m))]}\n        (let [new-formula (substitute m f)]\n          (if (= #{} (check-formula new-formula))\n            (eval-formula new-formula)\n            new-formula)))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 121, "code": "(let [ops {'/ / '+ + '* * '- -}]\n  (fn [formula]\n    (fn [bindings]\n      (clojure.walk/postwalk \n        (fn [v]\n          (if (sequential? v)\n            (apply (get ops (first v)) (rest v))\n            (get bindings v v)))\n         formula))))", "user": "504e71cbe4b0f6ff3350c4b3"}, {"problem": 121, "code": "(fn u [f]\n  (fn [m]\n    (let [o ({'+ + '- - '* * '/ /} (first f))\n          a (map #(if (coll? %) ((u %) m) (m % %)) (rest f))]\n      (apply o a))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 121, "code": "(fn myeval [expr]\n  (fn internal [vars]\n  (letfn \n    [(conc [col] \n           (map #(cond\n                  (symbol? %) (vars %)\n                  (sequential? %) ((myeval %) vars)\n                  :else %) (rest col)))] \n    (case (first expr)\n      + (apply + (conc expr))\n      - (apply - (conc expr))\n      / (apply / (conc expr))\n      * (apply * (conc expr))))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 121, "code": "(fn compute \n  ([formula]\n   (fn bindCompute [symbolMap];bind symbol map\n     (compute (into {'+ + '- - '* * '/ /} symbolMap) formula)));add operator symbols\n  ([symbolMap formula];with binded symbols\n   (if (seq? formula)\n     (apply (compute symbolMap (first formula))\n            (for [sym (rest formula)];generate binded values\n              (compute symbolMap sym)))\n     (symbolMap formula formula))));take operators or symbol values", "user": "556c70dae4b09a3098a524fd"}, {"problem": 121, "code": "(fn [formula]\n  (let [ops {'/ / '* * '- - '+ +}]\n    (fn [bindings]\n      (letfn [(internal-eval [bs form]\n                (cond\n                  (coll? form) (apply (ops (first form))\n                                      (map (partial internal-eval bs)\n                                           (rest form)))\n                  (symbol? form) (bs form)\n                  :else form))]\n        (internal-eval bindings formula)))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 121, "code": "(fn [e]\n  (letfn [(rp [e a]\n             (map \n               (fn [i]\n                 (if (and (symbol? i) (contains? a i)) \n                     (i a) \n                     (if (seq? i) \n                       (rp i a)\n                       i))) e))\n        (ev [l] \n             (let [f (first l)]\n               (apply \n                 (if (= f '+) +\n                 (if (= f '/) /\n                 (if (= f '-) -\n                 (if (= f '*) * ))))\n                   (map (fn [i] (if (seq? i) (ev i) i) )(rest l)))))]\n    (fn [a] (ev (rp e a)))))", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 121, "code": "(fn [formula]\r\n  (fn [vars]\r\n    (let [\r\n      eval-list (fn eval-list [[func & args]]\r\n        (let [\r\n          funcs {'+ +, '- -, '* *, '/ /}\r\n          eval-unit (fn [expr]\r\n            (if (coll? expr)\r\n              (eval-list expr)\r\n              (get vars expr expr)))]\r\n          (apply (funcs func) (map eval-unit args))))]\r\n      (eval-list formula))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 121, "code": "(fn uce [elist]\n  (fn [params]\n    (let [lookup #(cond (symbol? %) (get params %)\n                        (list? %) ((uce %) params)\n                        :else %)\n          f      ((first elist) {'/ / '+ + '- - '* *})\n          args   (rest elist)]\n      (apply f (map lookup args)))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 121, "code": "(fn make-computer [form]\n  (letfn [(not-eval [form]\n            (let [ops {'+ +, '- -, '/ /, '* *}]\n              (cond\n                ((complement coll?) form) form\n                :else (apply (ops (first form)) (map not-eval (rest form))))))]\n  (fn [bindings]\n    (not-eval (clojure.walk/prewalk-replace bindings form)))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 121, "code": "(fn __ [e]\n  (partial \n   (fn eva [e m]\n     (if (empty? e) ()\n       (let [head (first e), tail (eva (rest e) m)]\n         (if (coll? head)\n           (cons (eva head m) tail)\n           (if (number? head)\n             (cons head tail)\n             (if (m head)\n               (cons (m head) tail)\n               (apply ({'+ + '- - '* * '/ /} head) tail))))))) e))", "user": "53065acbe4b02e8216869792"}, {"problem": 121, "code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 121, "code": "(fn [exp]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (partial (fn evil [exp m]\n               (cond\n                 (seq? exp) (apply (ops (first exp)) (map #(evil % m) (rest exp)))\n                 (symbol? exp) (m exp)\n                 :default exp))\n             exp)))", "user": "4e0e0529535d04ed9115e7b9"}, {"problem": 121, "code": "(fn [formula] (partial \n (fn f [formula values] \n   (if (coll? formula) \n       ( case (name (first formula))\n         \"/\" (apply / (map #(f % values) (rest formula)))\n         \"+\" (apply + (map #(f % values) (rest formula)))\n         \"-\" (apply - (map #(f % values) (rest formula)))\n         \"*\" (apply * (map #(f % values) (rest formula)))\n         )\n     \n      (get values formula formula) \n     ))\n                 formula\n                 ))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 121, "code": "(fn uce\n  [exp]\n  (fn [m]\n    (letfn [(uce* [[e & es]]\n              (apply ({'+ + '/ / '* * '- -} e) (map (fn [a]\n                                                      (cond\n                                                        (symbol? a) (m a)\n                                                        (list? a) (uce* a)\n                                                        :else a)) es)))]\n      (uce* exp))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 121, "code": "(letfn [                                                                                                                                                \n    (op-table [c] ({'/ / '* * '+ + '- -} c))                                                                                    \n    (calc ([formula table]                                                                                                                                      (if (coll? formula)                                                                                                     \n            (let [[op & args] formula] (apply (op-table op) (map #(calc % table) args)))                                                                \n            (get table formula formula))))                                                                                      \n    (make-calc [formula] (fn [table] (calc formula table)))]                                                                                            \n            make-calc)", "user": "558b50d5e4b027778923762b"}, {"problem": 121, "code": "(letfn [(calc\n         [args f]\n         (if (seq? f)\n           (let [[op & vs] f]\n             (apply ({'+ + '/ / '- - '* *} op)\n                    (map (partial calc args) vs)))\n           (get args f f)))]\n  (fn [f]\n    (fn [args]\n      (calc args f))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 121, "code": "(fn univ-comp-engine\n  [[& x]]\n  (letfn [(univ-comp-engine* [coll symb-op-map m]\n            (if (and (coll? coll) (ifn? (first coll)))\n              (apply (symb-op-map (first coll)) (map univ-comp-engine*\n                                                     (next coll)\n                                                     (repeat symb-op-map)\n                                                     (repeat m)))\n              (if (m coll) (m coll) (int coll))))]\n    (partial univ-comp-engine* x {'+ + '* * '- - '/ /})))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 121, "code": "(fn [le]\n\t(fn engine\n\t\t([m] (engine m le))\n\t\t([m l]\n\t\t (apply (get {\"/\" / \"+\" + \"-\" - \"*\" *} (str (first l)))\n                (loop [v (rest l) r []]\n                  (if (empty? v)\n                    r\n                    (recur (rest v)\n                           (conj r (if (list? (first v))\n                                     (engine m (first v))\n                                     (if (integer? (first v))\n                                       (first v)\n                                       (get m (first v))))))))))))", "user": "52979551e4b02ebb4ef75043"}, {"problem": 121, "code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 121, "code": "(fn e [f] \n   (fn [b]\n    (cond (list? f) (apply ({'+ + '* * '/ / '- -} (first f)) (map #((e %) b) (rest f)))\n          (b f) (b f)\n          :else f)))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 121, "code": "(fn [l]\n  (fn [m]\n    ((fn it [[f & z]]\n      (apply ({'+ + '* * '/ / '- -} f) (map #(cond\n                                              (symbol? %) (m %)\n                                              (list? %) (it %)\n                                              :else %) z))) l)))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 121, "code": "(fn gen [form]\n  (fn myfunc [m]\n    (let [f (fn inter [form]\n      (let [vals (into {} m)]\n        (if (list? form)\n          (let [evals (map inter (rest form))]\n            (cond\n              (= (first form) '/) (apply / evals)\n              (= (first form) '+) (apply + evals)\n              (= (first form) '-) (apply - evals)\n              (= (first form) '*) (apply * evals)\n              ))\n          (if (contains? vals form) (get vals form) form)\n          )))]\n      (f form)\n    )))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 121, "code": "(fn create-uce [[op & args]]\n  (fn [env]\n    (let [op (get {'+ + '- - '/ / '* *} op)]\n      (apply op (map #(cond (sequential? %) ((create-uce %) env)\n                            (symbol? %) (get env %)\n                            :else %)\n                     args)))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 121, "code": "(fn number121  [l]\n  (fn [smap]\n    (let [full-smap (merge smap {'+ +, '/ /, '* *, '- -})]\n      (letfn [(my-eval [[f & xs]]\n                       (apply (full-smap f) (map #(if (coll? %)\n                                                 (my-eval %)\n                                                 (get full-smap % %))\n                                               xs)))]\n        (my-eval l)))))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 121, "code": "(fn f [e]\n  (fn [m]\n    (if (integer? e)\n     e \n     (let [a (replace {'+ +, '/ /, '- -, '* *} (replace m e))]\n      (apply (first a) (map #((f %) m) (rest a)))))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 121, "code": "(fn universal-engine [tree]\n  (let [ops {'/ / '* * '+ + '- -}\n        ev      (fn ev [root context]\n                  (cond\n                    (number? root)          root\n                    (symbol? root)          (context root)\n                    (symbol? (first root))  (apply (ops (first root)) (map #(ev % context) (rest root)))))\n        ]\n    (fn [context]\n      (ev tree context))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 121, "code": "(fn interpret [f]\n    (fn bind [b]\n      (do\n        (prn \"f\" f \"b\" b)\n        (apply ({'/ / '* * '+ + '- -} (first f))\n               (map (fn [x]\n                      (cond\n                        (symbol? x) (b x)\n                        (coll? x) ((interpret x) b)\n                        :else x\n                      ))\n                    (rest f))))))", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": 121, "code": "(fn [e]\n    (let [ops {'/ / '* * '+ + '- -}]\n      (fn [v]\n       ((fn c [[o & r]]\n          (apply (ops o) (map #(cond (number? %) %\n                               (symbol? %) (v %)\n                               :else (c %))\n                        r)))\n        e))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 121, "code": "(fn me [my-list]\n  (let [mm (fn me1 [m-list my-map]\n            (let [ op (first m-list)\n                   args (map #(if (coll? %) (me1 % my-map) (if (number? %) % (my-map %)) ) (rest m-list))\n                ]\n            (cond\n              (= op '+) (apply + args)\n              (= op '-) (apply - args)\n              (= op '*) (apply * args)\n              (= op '/) (apply quot args)\n            )))]\n     (partial mm my-list)))", "user": "55897fe2e4b059ccff29b205"}, {"problem": 121, "code": "(fn [formula]\n  (fn [args]\n    (letfn [(op-res [o] (cond (= o '/) / (= o '*) * (= o '+) + (= o '-) -))\n            (calc [e]\n             (cond\n               (list? e) (apply (op-res (first e)) (map calc (rest e)))\n               (symbol? e) (get args e )\n               :else e))]\n      (calc formula))))", "user": "5590e55de4b0277789237676"}, {"problem": 121, "code": "(fn exec\n ([formula] #(exec formula %))\n ([[op & args] values] \n    (let [ops {'/ / '+ + '- - '* *}]\n          (apply (ops op) (map #(cond\n                           (sequential? %) (exec % values)\n                           (number? %) %\n                           :else (values %)\n                           ) args))))\n          )", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 121, "code": "(fn p121 [form]\n  (fn [vars]\n    ((fn step [x] \n      (cond (number?  x) x\n            (symbol? x) (get vars x)\n            :else        (let [[op & args] x] \n                           (apply ({'/ / '+ + '- - '* *} op) (map step args)))\n            ))\n     form)))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 121, "code": "(fn ! [c]\n  (fn [m]\n    (cond (symbol? c) (m c)\n          (seq? c) (apply ((first c) {'/ /  '+ + '- - '* *})\n                        (map #((! %)m) (rest c)))\n          1 c)))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 121, "code": "(fn [form]\n    (letfn [(step [s]\n              (let [formulars (re-seq #\"\\([^\\(\\)]+\\)\" s)]\n                (if (seq formulars)\n                  (let [formulars-results (map (fn [formular]\n                                                 (let [formular-seq (re-seq #\"[\\d\\+\\-\\*/]+\" formular) ]\n                                                   formular-seq\n                                                   (apply (case (first formular-seq)\n                                                            \"+\" +\n                                                            \"-\" -\n                                                            \"*\" *\n                                                            \"/\" /)\n                                                          (map #(Integer/parseInt % 10) (rest formular-seq))))\n                                                 ) formulars)]\n                    (step (reduce #(clojure.string/replace %1 (key %2) (str (val %2))) s (apply assoc {} (interleave formulars formulars-results)))))\n                  (Integer/parseInt s 10))))]\n      (fn [m]\n        (let [form-str (str form)]\n          (step (reduce #(.replace %1 (str (key %2)) (str (val %2))) form-str m))))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 121, "code": "(fn uc [coll]\n  (fn [m]\n    (cond\n      (number? coll) coll\n      (symbol? coll) (get m coll)\n      :else (apply (condp = (first coll) '/ / '* * '+ + '- -)\n              (map #((uc %) m) (rest coll))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 121, "code": "(fn [expr]\n  (let [ops {'+ +, '- - '* * '/ /}\n        uce (fn uce [expr m]\n                     (if (empty? expr)\n                        nil\n                        (if (list? (first expr))\n                            (cons (uce (first expr) m) (uce (rest expr) m))\n                            (if (contains? m (first expr))\n                                (uce (cons (m (first expr)) (rest expr)) m)\n                                (if (contains? ops (first expr))\n                                  (apply (ops (first expr)) (uce (rest expr) m))\n                                  (cons (first expr) (uce (rest expr) m)))))))]\n       (fn [m]  (uce expr m))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 121, "code": "(fn [expr]\n  (fn compute\n    ([m]\n     (compute m expr))\n    ([m e]\n     (cond\n      (number? e) e\n      (symbol? e) (m e)\n      :else (apply (case (first e)\n                    + +\n                    - -\n                    * *\n                    / /)\n                   (map (partial compute m)\n                        (rest e)))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 121, "code": "(fn [form] (fn [arg] (let [frm (clojure.walk/prewalk-replace (into {'- -, '+ +, '/ /, '* *} arg) form)]\n                           (letfn [(fe [fc] (loop [c fc r []] (cond\n                                     (empty? c) (apply (first r) (drop 1 r))\n                                     (coll? (first c)) (recur (drop 1 c) (conj r (fe (first c))))\n                                     :else (recur (drop 1 c) (conj r (first c)))\n                                    )))]\n                             (fe frm)\n                            )\n )))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 121, "code": "(fn [f]\n  (fn [as]\n    (clojure.walk/postwalk\n      #(if (list? %)\n         (apply ({'+ + '- - '/ / '* *} (first %)) (next %))\n         %)\n      (clojure.walk/prewalk-replace as f))))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 121, "code": "(fn uce [form]\n              (let  [ff (fn ff [f env]\n                          (let [f-elt (first f)]\n                            (cond\n                             (nil? f-elt) ()\n                             (= '/ f-elt) (apply / (ff (rest f) env))\n                             (= '+ f-elt) (apply + (ff (rest f) env))\n                             (= '- f-elt) (apply - (ff (rest f) env))\n                             (= '* f-elt) (apply * (ff (rest f) env))\n                             (number? f-elt) (cons f-elt (ff (rest f) env))\n                             (contains? env f-elt) (cons (env f-elt) (ff (rest f) env))\n                             :else (cons (ff f-elt env) (ff (rest f) env)))))]\n                (partial ff form)))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 121, "code": "(fn e [exp]\n  (fn [env]\n    (apply ({'+ + '- - '* * '/ /} (first exp))\n           (map #(if (seq? %) ((e %) env) (env % %)) \n                (rest exp)))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n       form))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 121, "code": "(fn [code]\n  (fn [m]\n    (letfn [(exe [c]\n              (cond\n                (coll? c) (let [[op' & code] c\n                                op ({'+ + '- - '* * '/ /} op')]\n                            (apply op (map exe code)))\n                (symbol? c) (m c)\n                :else c))]\n      (exe code))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 121, "code": "(fn [form]\n  (fn [smap]\n    (clojure.walk/postwalk\n      (fn [x]\n        (let [res (if (contains? smap x) (smap x) x)\n              flat? #(every? (complement sequential?) %)]\n          (if (and (sequential? res) (flat? res))\n            (apply ((first res) {'+ +, '- -, '/ /, '* *}) (rest res))\n            res)))\n      form)))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 121, "code": "(fn compute [f]\n  (fn [m]\n    (cond\n      (seq? f) (let [args (map #((compute %) m) (rest f))]\n                 (case (first f)\n                   + (apply + args)\n                   - (apply - args)\n                   * (apply * args)\n                   / (apply / args)))\n      (number? f) f\n      :else (m f 0))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 121, "code": "(fn f [e]\n  (let [q {'+ + '- - '* * '/ /}]\n    (fn [m]\n      (let [[g & a] e]\n        (apply\n         (q g) (map #(if (seq? %) ((f %) m) (get m % %) ) a)\n         )\n       )\n      )\n    )\n  )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 121, "code": "(fn [eq]\n  (fn [m]\n    (let [op {'+ + '- - '* * '/ /}]\n      (letfn [(calc [x]\n                    (cond (symbol? x) (m x)\n                          (number? x) x\n                          :else (apply (op (first x))\n                                       (map calc (rest x)))))]\n        (calc eq)))))", "user": "55c68089e4b0e31453f649c4"}, {"problem": 121, "code": "(fn uce [expr]\n  (let [fn-mappings (apply hash-map ['+ + '- - '* * '/ /])]\n\n    (letfn [(map-args [st mappings]\n              (map (fn [sym]\n                     (if (coll? sym)\n                       (map-args sym mappings)\n                       (get mappings sym sym)))\n                   st))\n\n            (visit [[op & arguments]]\n              (if (nil? arguments)\n                (recur op)\n                (if-not (some coll? arguments)\n                  (apply (fn-mappings op) arguments)\n                  (visit\n                   (cons op (map (fn [x]\n                                   (if (coll? x)\n                                     (visit x)\n                                     x))\n                                 arguments))))))]\n\n      (fn [& args]\n        (->> (map-args expr (first args)) visit)))))", "user": "534056fce4b085b17e897dac"}, {"problem": 121, "code": "(fn my-eval [exp]\n  (fn [m]\n    (letfn [(sub [my-exp]\n              (let [ops {'+ + '- - '* * '/ /}]\n                (apply (ops (first my-exp))\n                       (map\n                        (fn [item](cond (list? item) (sub item)\n                               (contains? m item) (m item)\n                               :else item)) (rest my-exp)))))]\n      (sub exp))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 121, "code": "(fn [s]\n  (let [r (fn r [s m]\n            (reduce (fn [a [k v]]\n                      (map #(cond\n                              (seq? %) (r % m)\n                              (= % k) v\n                              :else %) a)) \n                    s m))\n        c (fn c [[f & n]]\n            (apply ({'+ + '- - '* * '/ /} f)\n                   (map #(if (seq? %) (c %) %) n)))]\n    #(c (r s %))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 121, "code": "(fn [form]\n    (fn [params]\n      (let [TABLE (conj {'+ +\n                         '- -\n                         '/ /\n                         '* *} params)\n\n            exec (fn [f & args]\n                   (apply f args))]\n\n        (letfn [(ev [_form]\n                    (apply exec\n                           (for [x _form]\n                             (cond\n                               (= clojure.lang.Symbol (type x)) (get TABLE x)\n                               (coll? x) (ev x)\n                               :else x\n                               ))))]\n          (ev form)\n        ))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 121, "code": "(fn [o]\n  (fn [m] (let [nm (merge m {(symbol \"+\") + (symbol \"-\") - (symbol \"/\") / (symbol \"*\") *})\n                get-val (fn [x] (if (nil? (get nm x)) (identity x) (get nm x)))\n                mval (fn t [o & a] (if (coll? o) (apply t o) (if (empty? a) (get-val o) (apply (get-val o) (map t a)))))]\n            (apply mval o))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 121, "code": "(fn evol [x]\n  (fn [env]\n    (cond\n      (list? x) (let [fn-table {'+ + '- - '* * '/ /}]\n                  (apply (fn-table (first x)) (map #((evol %) env) (rest x))))\n      (symbol? x) (env x)\n      :else x)))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 121, "code": "(fn compute [data]\n  (fn [env]\n    (cond\n     (symbol? data) (get env data)\n     (sequential? data) (let [op (first data)]\n                          (apply (condp = op\n                                   '/ /\n                                   '+ +\n                                   '- -\n                                   '* *) \n                                 (map #((compute %) env) (rest data))))\n     :else data)))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 121, "code": "(fn uct [[op-sym & args]]\n  (let [operator (get {'/ / '* * '+ + '- -} op-sym)]\n    (fn [vars]\n      (let [calculate (fn [exp]\n                        (if (seq? exp) ((uct exp) vars)\n                          (or (vars exp) exp)))]\n        (apply operator (map calculate args)))\n      )))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 121, "code": "(fn [v]\n  (fn [m]\n    ((fn help [[f & xs]]\n       (apply ({'+ + '- - '* * '/ /} f) (map #(if (seq? %) (help %) (m % %)) xs)))\n     v)))", "user": "554b8572e4b0a04f79299589"}, {"problem": 121, "code": "(fn def-formula [sexp]\r\n  (fn [varmap]\r\n    (letfn [(exec-formula [sexp]\r\n              (condp #(%1 %2) sexp\r\n                list?   (let [[f & body] sexp]\r\n                          (apply (case f + +, - -, * *, / /,)\r\n                                 (map exec-formula body)))                    \r\n                symbol? (varmap sexp)\r\n                number? sexp))]\r\n      (exec-formula sexp))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 121, "code": "(fn ator [theformula] \n(let [helpermap {\"/\" / \"+\" + \"-\" - \"*\" *}]\n(letfn [(myresolve [asym] (helpermap (str asym)))]\n(fn [toreplace] \n(letfn [(apli [aform] (apply (myresolve (first aform))\n(for [elem (replace toreplace (rest aform))] (if (coll? elem) (apli elem) elem))\n))]\n(apli theformula)\n)))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 121, "code": "(fn calc [expr]\n  (fn [vars]\n    (let [evl (fn [p]\n                (cond (coll? p) ((calc p) vars)\n                      (contains? vars p) (vars p)\n                      :else p))\n          apl (fn [op args]\n                (cond (= op '/) (apply / args)\n                      (= op '+) (apply + args)\n                      (= op '*) (apply * args)\n                      (= op '-) (apply - args)))]\n      (apl (first expr) (map evl (rest expr))))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 121, "code": "(fn[form] \n  (fn [vars]\n    (letfn [(resolve-op [op] ({'+ + '- - '* * '/ /} op))\n            (terms [exprs] \n              (map #(if (coll? %) (calc %) (get vars % %)) exprs))\n            (calc [[op & exprs]] \n              (apply (resolve-op op) (terms exprs))) ]\n      (calc form))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 121, "code": "(fn calc [form]\n  (fn [bindings]\n    (let [b (into bindings {'+ +, '- -, '* *, '/ /})]\n      (cond\n        (symbol? form) (b form)\n        (number? form) form\n        (sequential? form) (let [[f & params] (map #((calc %) bindings) form)]\n                             (apply f params))))))", "user": "511cca27e4b00c2a1fa7ff7d"}, {"problem": 121, "code": "(fn interp [expr]\n  (fn [valMap]\n    (if (not (list? expr))\n      (if (number? expr)\n        expr\n        (get valMap expr))\n      (let [op (first expr)\n            mapOPS {\"*\" *\n                    \"+\" +\n                    \"-\" -\n                    \"/\" /}\n            vals (map #((interp %) valMap) (rest expr))]\n        (apply (get mapOPS (str op)) (seq vals))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 121, "code": "(fn calc [forms]\n  (fn [bound-map]\n    (let [ops {'/ / '* * '+ + '- -}]\n      (letfn [(rebind-and-apply \n                [m-vals [func & args]]\n                (apply \n                   (get ops func)\n                      (reduce \n                        (fn [acc el] \n                          (if (symbol? el) \n                            (conj acc (get m-vals el))\n                            (if (sequential? el)\n                              (conj acc (rebind-and-apply m-vals el))\n                              (conj acc el))))\n                        [] args)))]\n      (rebind-and-apply bound-map forms)))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 121, "code": "(fn [form]\n  (fn [env]\n    (let [env' (merge {'/ /\n                       '+ +\n                       '* *\n                       '- -} env)]\n      (letfn [(ueval [exprs]\n                (if (seq? exprs)\n                  (let [[f & args] exprs]\n                    (apply\n                     (get env' f f)\n                     (map ueval args)))\n                  (get env' exprs exprs)))]\n        (ueval form)))))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 121, "code": "(fn [form]\n  (letfn [(lave [env form]\n            (cond (number? form) form\n                  (symbol? form) (env form)\n                  :else (apply ({'+ + '- - '* * '/ /} (first form))\n                               (map (partial lave env) (rest form)))))]\n    (fn [env] (lave env form))))", "user": "4e1fbc66535d04ed9115e80e"}, {"problem": 121, "code": "(fn [form] (letfn [(myeval [env form]\n            (let [ops {'+ + '- - '* * '/ /}]\n              (cond (number? form) form\n                    (symbol? form) (env form)\n                    :else (apply\n                           (ops (first form))\n                           (map (partial myeval env) (rest form))))))]\n    (fn [env] (myeval env form))))", "user": "4e8768f6535dceadca469850"}, {"problem": 121, "code": "(fn [form]\n       (fn [env]\n         (let [ops {'* * '/ / '+ + '- -}\n               my-eval (fn my-eval\n                         [env form]\n                         (cond (symbol? form) (env form)\n                               (number? form) form\n                               (seq? form) (apply\n                                            (env (first form))\n                                            (map (partial my-eval env)\n                                                 (rest form)))))]\n           (my-eval (merge env ops) form))))", "user": "55d204abe4b0e31453f64a4f"}, {"problem": 121, "code": "(fn c [e]\n  (fn [d]\n    (cond\n      (number? e) e\n      (d e) (d e)\n      :else (let [[o & r] e]\n              (apply ({'+ + '- - '* * '/ /} o)(map #((c %) d) r) )))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 121, "code": "(fn compute\n  ([form assigns]\n   (if (= (class '(+)) (class form))\n     (apply (compute (first form) assigns) (map #(compute % assigns) (rest form)))\n     (if (= (class '+) (class form))\n       (let [ops {'+ +, '- -, '* *, '/ /}]\n         (if (not (nil? (get ops form)))\n           (get ops form)\n           (get assigns form)))\n       form)))\n  ([form]\n   (fn [assigns]\n     (apply (compute (first form) assigns) (map #(compute % assigns) (rest form))))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 121, "code": "(fn f\n  ([e]\n   #(f e %))\n  ([e v]\n   (apply\n     (condp = (nth e 0)\n       '+ + '- - '* * '/ /)\n     (map\n       #(if (seq? %)\n          (f % v)\n          (get v % %))\n       (rest e)))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 121, "code": "(fn [formula]\n  (letfn [(compute [symbol-map [op & values]]\n            (apply ({'+ + '- - '* * '/ /} op) (map (partial evaluate symbol-map) values)))\n          (evaluate [symbol-map value]\n            (cond (number? value) value\n                  (symbol? value) (get symbol-map value)\n                  :else (compute symbol-map value)))]\n    (fn [symbol-map]\n      (compute symbol-map formula))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 121, "code": "(fn [formula]\n  (letfn [(compute [symbol-map [op & values]]\n            (apply ({'+ + '- - '* * '/ /} op) (map (partial evaluate symbol-map) values)))\n          (evaluate [symbol-map value]\n            (cond (number? value) value\n                  (symbol? value) (get symbol-map value)\n                  :else (compute symbol-map value)))]\n    (fn [symbol-map]\n      (compute symbol-map formula))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 121, "code": "(fn [exp]\n  (let [opmap {'+ +, '- -, '* *, '/ /}]\n    (fn [varmap]\n      (letfn [(EVAL [exp]\n                (if (seq? exp)        ; operator is first in prefix notation \n                  (apply (opmap (first exp)) (map EVAL (rest exp)))\n                  (varmap exp exp)))] ; not-found exps are numeric constants\n        (EVAL exp)))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 121, "code": "(fn prob121\n  [function]\n  (fn [values]\n    ;; apply the values to the function\n    ((fn compute [s] \n       (if (seq? s)\n         (let [[ op & args] s\n               ;;  four basic mathematical operators\n               fncs {'+ + '- - '/ / '* *}\n               function (fncs op)]\n           (apply function (map compute args)))\n         (get values s s)))\n     function)))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 121, "code": "(fn [ex]\n    (letfn [(my-eval [inex m]\n              (let [f ({'/ / '+ + '- - '* *} (first inex))\n                    args (rest inex)]\n                (apply  f (map #(cond (symbol? %) (m %)\n                                      (coll? %) (my-eval % m)\n                                      :else %)\n                               args))))]\n      #(my-eval ex %)))", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 121, "code": "(fn [computation]\n  (let [math-env {'+ +\n                  '- -\n                  '* *\n                  '/ /}]\n    (letfn [(eval' [env form]\n              (cond\n                (seq? form) (let [[f & args] (map (partial eval' env) form)]\n                                  (apply f args))\n                (symbol? form) (env form)\n                :else form))]\n      (fn [env]\n        (eval' (conj math-env env) computation)))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 121, "code": "(fn R [E] (fn [M] (cond (seq? E) (let [[f & X] E O {'/ / '+ + '* * '- -}] (apply (O f) (map #((R %) M) X))) (symbol? E) (M E) :else E)))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 121, "code": "(fn [f]\n  (letfn [(w [b [op & exps]]\n            (let [s (fn [exp] (if (seq? exp) (w b exp)\n                                  (or (get b exp) exp)))\n                   vs (map s exps)]\n                  (case op + (apply + vs)\n                        - (apply - vs)\n                        * (apply * vs)\n                        / (apply / vs))\n                  ))]\n    (fn [b] (w b f))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 121, "code": "(fn calc [expr]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (letfn [(solve [expr bindings] \n                   (cond\n                     (coll? expr) (apply (ops (first expr))\n                                         (map #(solve % bindings) (rest expr)))\n                     (symbol? expr) (bindings expr)\n                     (number? expr) expr))]\n      (fn [bindings] (solve expr bindings)))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 121, "code": "(fn uce [f]\n       (letfn [(myeval [s m]\n                       (cond\n                         (number? s) s\n                         (symbol? s) (do (println \"looking up \" s \"in \" m (get m 'x)) (get m s))\n                         (sequential? s)\n                         (let [op (first s) tees (rest s)]\n                           (println op \" : \" tees \" : \" tees)\n                           (cond\n                             (= '/ op) (apply / (map #(myeval % m ) tees))\n                             (= '* op) (apply * (map #(myeval % m ) tees))\n                             (= '+ op) (apply + (map #(myeval % m ) tees))\n                             (= '- op) (apply - (map #(myeval % m ) tees))\n                             ))\n                         ))]\n         (fn [m] (myeval f m)))\n       )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 121, "code": "(fn [sym] (fn [m] (let [sym (str sym)\n                          fn-m {\"+\" + \"-\" - \"*\" * \"/\" /}\n                          str-m (let [k (keys m)]\n                                  (->> (zipmap k (map str k))\n                                       (clojure.set/rename-keys m)\n                                       (merge fn-m)))\n                          str->int #(int (bigint %))\n                          process (fn [s] (->> (dec (count s))\n                                               (subs s 1)\n                                               (#(clojure.string/split % #\"\\s\"))\n                                               (replace str-m)\n                                               (map #(if (string? %) (str->int %) %))\n                                               (apply (fn \n                                                        ([f a b] (f a b))\n                                                        ([f a b c] (f a b c))))))\n                          find-op (fn [s] (re-seq #\"\\([^\\(\\)]*\\)\" s))] \n                      (loop [sym sym]\n                        (if (empty? (find-op sym))\n                          (str->int sym)\n                          (recur (->> sym\n                                      find-op\n                                      (#(zipmap % (map (comp str process) %)))\n                                      (clojure.string/replace sym #\"\\([^\\(\\)]*\\)\"))))))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 121, "code": "(fn [formula]\n  (let [compute\n        (fn compute [[f & xs] m]\n          (print [f xs m])\n          (apply ({'+ +, '- -, '* *, '/ /} f)\n                 (map\n                   (fn [x] \n                     (if (coll? x) (compute x m)\n                       (if (m x) (m x)\n                         x)))\n                   xs)))]\n    #(compute formula %)))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 121, "code": "(fn puzzle-121 [formula]\n(fn calculate [binds]\n  (let [[op & args] formula\n        f (case op\n            + +\n            - -\n            * *\n            / /)]\n    (apply f (map #(if (list? %) \n                     ((puzzle-121 %) binds)\n                     (get binds % %)) \n                  args)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 121, "code": "(let [oop {'+ + '- - '* * '/ /}]\n(fn [form]\n (fn [vars]\n  (let [binds (merge oop vars)]\n   ((fn ev [item]\n  \t(if (list? item)\n     (let [[op & args] item]\n      (apply (binds op) (map ev args)))\n   (get binds item item)))\n  form)))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 121, "code": "(fn computation [expr]\n  (fn [args]\n    (letfn [(expr? [expr] (some true? (map #(= expr %) '[* / + -])))\n            (operate [operand args]\n                     (cond\n                       (= operand '*) (apply * args)\n                       (= operand '/) (apply / args)\n                       (= operand '+) (apply + args)\n                       (= operand '-) (apply - args)))\n            (value [x] (if (symbol? x) (args x) x))\n            (evil [expr]\n                  (cond\n                    (not (coll? expr)) (value expr)\n                    (expr? (first expr)) (operate (first expr) (map evil (next expr)))\n                    :else \"error\"))]\n      (evil expr)\n    )))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 121, "code": "(fn [l]\n  (letfn [(t[s m] \n            (let [op (first s) args (rest s)\n                  ops {'/ / '+ + '* * '- -}]\n             (apply (get ops op) \n               (map #(cond (symbol? %) (get m %)\n                         (seq? %) (t % m)\n                         :else %\n                      ) args)\n             )\n            )  \n          )\n       ]\n    (fn [m] (t l m)) \n  )  \n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 121, "code": "(fn compute\n  [expr]\n  (let [fns {'+ + '- - '* * '/ /}]\n    (letfn [(compute* [expr binds]\n              (cond\n                (symbol? expr) (binds expr)\n                (list? expr) (apply (fns (first expr))\n                                    (map #(compute* % binds) (rest expr)))\n                :else expr))]\n      (fn [binds] (compute* expr binds)))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 121, "code": "(fn uc[[op & ops]]\n         (fn [amap1] \n            (let [ops_v (mapv (fn [x]  \n                                (cond \n                                  (list? x) ((uc x) amap1)\n                                  (symbol? x) (amap1 x)\n                                  :else x\n                                  ))\n                              ops)]\n              (apply ({'/ / '* * '+ + '- -} op) ops_v))))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 121, "code": "(fn ce\n  [exp]\n  (let [m {'+ + '- - '* * '/ /}]\n    (fn [pv]\n      (apply (m (first exp))\n             (for [p (rest exp)]\n               (cond\n                 (list? p) ((ce p) pv)\n                 (symbol? p) (pv p)\n                 :else p))))))", "user": "51852961e4b0da5a5be3babb"}, {"problem": 121, "code": "(fn replace-values\n  [form]\n  (letfn [(arithmetic-eval [form]\n                          (let [arithmetic-op {'+ +, '- -, '/ /, '* *}]\n                            (cond\n                             (integer? form) form\n                             (coll? form) (apply (arithmetic-op (first form)) (map arithmetic-eval (rest form))))))]\n    (fn [values]\n      (arithmetic-eval (clojure.walk/prewalk-replace values form)))))", "user": "4fc524aae4b081705acca37e"}, {"problem": 121, "code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "user": "561a1af6e4b053970a773b02"}, {"problem": 121, "code": "(fn __ [code]\n  (letfn [(evaluate [code params]\n\t\t\t\t\t (let [f-mapping {'/ / '+ + '* * '- -}]\n\t\t\t\t\t   (if (sequential? code)\n\t\t\t\t\t    (apply (f-mapping (first code)) (map #(evaluate % params) (rest code)))\n\t\t\t\t\t    (or (params code) (int code)))))]\n  (fn [params]\n    (evaluate code params))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 121, "code": "(fn e [eqn]\n  (let [ev (fn ev [eqn env]\n  (cond\n   (seq? eqn) (let\n                [args (map #(ev % env) (rest eqn))]\n                 (condp = (first eqn)\n                  '/ (apply quot args)\n                  '* (apply * args)\n                  '+ (apply + args)\n                  '- (apply - args)\n                   ))\n   (symbol? eqn) (env eqn)\n   :else eqn\n   ))]\n  (fn [env]\n    (ev eqn env))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 121, "code": "(fn [form]\n  (fn [env]\n    (letfn\n      [(e [[f & args]]\n        (apply\n          (get {'+ + '- - '* * '/ /} f)\n          (map\n            (fn [a]\n              (if (list? a)\n                (e a)\n                (if (symbol? a) (get env a) a)))\n            args)))]\n      (e form))))", "user": "55fee5e4e4b00f4cabc5765a"}, {"problem": 121, "code": "(fn [form]\n  (fn [bindings]\n    (let [operations {'+ + '- - '* * '/ /}]\n      (letfn [(deep-replace [s m] (if (seq? s) (map #(deep-replace % m) s) (or (get m s) s)))\n             (execute [l] (if (seq? l) (let [[func-sym & operands] l f (get operations func-sym)] (apply f (map execute operands))) l))]\n       (execute (deep-replace form bindings))))))", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 121, "code": "(fn [expr]\n  (let [ops {'/ / '* * '+ + '- -}\n        my-eval (fn my-eval [node vars]\n                  (if (coll? node)\n                    (let [[op & args] node\n                          args (map #(my-eval % vars) args)\n                          op-fn (ops op)]\n                      (apply op-fn args))\n                    (get vars node node)))]\n    (fn [vars] (my-eval expr vars))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 121, "code": "(fn [expr]\n  (fn calc ([env] (calc expr env))\n    ([expr env]\n     (let [ops {'+ +, '- -, '* *, '/ /}]\n       (cond\n        (symbol? expr) (get env expr)\n        (seq? expr) (if-let [op (get ops (first expr))]\n                      (apply op (map #(calc % env) (rest expr)))\n                      expr)\n        :else expr)))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 121, "code": "(fn [eq]\n     (fn [vars]\n       (let [funcs {'* * '+ + '- - '/ /}]\n         (letfn [(ev [n]\n                   (if (seq? n) (apply (get funcs (first n)) (map ev (rest n)))\n                       (if-let [val (get vars n)]\n                         val\n                         n)))]\n           (ev eq)))\n       )\n     )", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 121, "code": "(fn universal-computation\n  [exp]\n  (let [f (symbol (first exp))\n        ops {'+ + '* * '- - '/ /}]\n    (fn [var-map]\n      (apply (ops f) (map #(cond (symbol? %) (var-map %)\n                                 (coll? %) ((universal-computation %) var-map)\n                                 :else %) (rest exp))))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 121, "code": "(fn uce [[f & args]]\n  (let [f-map {'/ / '+ + '- - '* *}\n        args' (map #(cond (coll? %) (uce %)\n                         (symbol? %) (fn [m] (m %))\n                         :else (fn [m] %)) args)]\n    (fn [m]\n      (apply (f-map f) (map #(% m) args')))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 121, "code": "(fn lambda [eq]\n  (fn [ns]\n    (cond\n      (coll? eq) (apply (case (str (first eq))\n                          \"+\" + \"-\" - \"*\" * \"/\" /)\n                        (map #((lambda %) ns) (rest eq)))\n      (symbol? eq) (get ns eq)\n      (number? eq) eq)))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 121, "code": "(fn ev [expr]\n  (fn [bindings]\n    (cond\n     (symbol? expr) (bindings expr)\n     (list? expr) (let [[x & s] expr\n                        op {'+ + '- - '* * '/ /}] \n                    (apply (op x) (map #((ev %) bindings) s)))\n     :else expr)))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 121, "code": "(fn\n  [str-fn]\n  (fn\n  [x]\n  (letfn [(sym-2-str [[k v]] {(str k) v})\n          (fn-choose [f-sym] (case (str f-sym) \"+\" + \"-\" - \"*\" * \"/\" /))\n          (eval-fn [f m] (if ((complement seq?) f)\n                           (if (number? f) f (m (str f)))\n                           (apply (fn-choose (first f)) (map eval-fn (next f) (repeat m)))\n\t\t\t   ))]\n          (eval-fn str-fn (into {} (map sym-2-str x))))))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 121, "code": "(fn [form]\n  (letfn [(sb [frm mp] (map #(cond (sequential? %) (sb % mp)\n                                   (contains? mp %) (mp %)\n                                   :else %) frm))\n          (evl [frm] (let [fmp {(first '(+)) + (first '(-)) - (first '(*)) * (first '(/)) /}]\n                     (apply (fmp (first frm)) (map #(if (sequential? %) (evl %) %)   (rest frm)))))]\n    (fn [mp] (evl (sb form mp)))))", "user": "5649615be4b0284900eef641"}, {"problem": 121, "code": "(fn evaluate-exp [exp]\n  (fn evaluate [args]\n    (letfn [(evaluate-atoms [x]\n                            (if (number? x)\n                              x\n                              (args x)))\n            (evaluate-symbol [[op & params]]\n                             (apply \n                              (case op\n                                + +\n                                - -\n                                / /\n                                * *)\n                              (map #((evaluate-exp %) args) params)))]\n      (if (sequential? exp)\n        (evaluate-symbol exp)\n        (evaluate-atoms exp)))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 121, "code": "(fn compute [formula]\n  (fn evaluate [parameters]\n    (let [context (merge {'+ + '- - '* * '/ /} parameters)\n          lookup (fn [symbol] (get context symbol))\n          expression (map\n                       #(cond\n                         (symbol? %) (lookup %)\n                         (list? %) ((compute %) parameters)\n                         :else %)\n                       formula)\n          operator (first expression)\n          arguments (rest expression)]\n      (apply operator arguments))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 121, "code": "(fn [formula]\n  (fn [values]\n    ((fn compute [x]\n       (if (seq? x)\n         (let [[op & args] x]\n           (apply ({'+ + '/ / '- - '* *} op)\n                  (map compute args)))\n         (get values x x)))\n     formula)))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 121, "code": "(fn [formula]\n  (fn [arg-map]\n    (letfn [(my-eval [x]\n                     (let [op-map {'+ +, '- -, '* *, '/ /}]\n                       (if (not (sequential? x))\n                           (or (op-map x) (arg-map x) (identity x))\n                           (let [resolved (for [e x] (my-eval e))]\n                             (apply (first resolved) (rest resolved))))))]\n      (my-eval formula))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 121, "code": "(fn my-compile [s]\n  (let [ops {'+ + '- -\n             '* * '/ /}]\n    (fn [m]\n      (if (coll? s)\n        (apply (ops (first s)) (map #((my-compile %) m) (rest s)))\n        (or  (m s) s)\n        ))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 121, "code": "(fn [exp]\n    (fn [m]\n      (letfn [(eval' [exp]\n                (if (list? exp)\n                  (apply ({'+ + '- - '* * '/ /}\n                          (first exp))\n                         (map eval' (rest exp)))\n                  (m exp exp)))]\n        (eval' exp))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 121, "code": "(fn calc [s]\n  #(let [m (merge {'+ + '- - '* * '/ /} %)]\n     (cond (seq? s)\n            (apply ((calc (first s)) m) (map (fn [e]\n                                               ((calc e) m))\n                                             (rest s)))\n          (integer? s)\n            s\n          :else (get m s)\n          )))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 121, "code": "(fn q4q121\n  [s]\n  (let [mathf {'+ +, '- -, '* *, '/ /}]\n      (fn [m]\n        (clojure.walk/postwalk\n         #(if (sequential? %)\n            (apply (mathf (first %)) (rest %))\n            %)\n         (clojure.walk/postwalk-replace m s)))))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 121, "code": "(fn [expr]\n  (fn [vars]\n    (letfn [(simplify [vals]\n                      (map #(cond\n                             (coll? %) (eval' %)\n                             (symbol? %) (vars %)\n                             (number? %) %)\n                           vals))\n            (eval' [[op & vals]]\n                   (apply (case op\n                            + +\n                            - -\n                            * *\n                            / /)\n                          (simplify vals)))]\n      (eval' expr))))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 121, "code": "(fn calc [expr]\n  (if (sequential? expr)\n    (let [op (first expr) args (rest expr)]\n      (fn [vars]\n        (let [lkt {'+ + '- - '* * '/ /}]\n            (apply (lkt op) (map #((calc %) vars) args)))))\n    (fn [vars]\n      (or (vars expr) expr))))", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 121, "code": "(fn [form]\n     (fn [m]\n       (clojure.walk/postwalk\n         (fn [f]\n           (cond\n             (list? f) (apply (first f) (rest f))\n             (number? f) f\n             :else ((merge m {'/ / '+ + '* * '- -}) f)))\n         form)))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 121, "code": "(fn [form]\n  (fn [bmap]\n    (let [calc (fn calc\n                 ([x] (if (sequential? x) (apply calc x) x))\n                 ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                             (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace bmap form)]\n      (calc formula))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 121, "code": "(fn self [[f x1 x2 & others]]\n  (fn [argmap]\n    (prn f x1 x2 others argmap)\n           (let [res (fn [arg]\n              (prn arg (type arg))\n                (if (coll? arg)  \n                   (if (> (count arg) 1)\n                     ((self arg) argmap)\n                     (first arg))\n                   (if (symbol? arg)\n                    (get argmap arg)\n                    arg)))\n             applyf (fn [ffn x y]\n                       (cond\n                         (= ffn (symbol '+) ) (+ x y)\n                         (= ffn (symbol '*) ) (* x y)\n                         (= ffn (symbol '/) ) (/ x y)\n                         (= ffn (symbol '-) ) (- x y)\n                        ))\n             temp (applyf f (res x1) (res x2))]\n         (if (empty? others)\n           temp\n          ((self [f temp others]) argmap)))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 121, "code": "(fn[s]\n  (fn[m]\n    (let\n      [op {'+ + '- - '/ / '* *}\n       g (fn g[t]\n           (apply (op (first t)) (map #(cond (coll? %) (g %) (symbol? %) (m %) :else %) (rest t))))]\n      (g s))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 121, "code": "(fn universal-computation-engine [formula]\n  (fn [bindings]\n    (letfn [(calc [formula]\n              (cond \n                (symbol? formula) (bindings formula)\n                (number? formula) formula\n                :else (let [op (first formula)\n                            exprs (rest formula)]\n                        (let [values (map calc exprs)]\n                          (case op\n                            + (apply + values)\n                            - (apply - values)\n                            * (apply * values)\n                            / (apply / values)\n                            :unsupported-operation)))))]\n      (calc formula))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 121, "code": "(fn [formula]\n  (let [operators {'+ + '- - '/ / '* *}]\n    (fn [variables]\n      (letfn [(solve [form] (apply (operators (first form)) \n                                   (map (fn [item] \n                                          (cond \n                                           (list? item) (solve item) \n                                           (symbol? item) (variables item) \n                                           :else item)) \n                                        (rest form))))]\n        (solve formula)))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 121, "code": "(fn[f](fn[m]((fn a [x](if(seq? x)\n                        (let[[o & xs] x]\n                          (apply ({'+ +, '- -, '* *, '/ /} o)(map a xs)))\n                        (get m x x))) f)))", "user": "566a3a26e4b0a866af689699"}, {"problem": 121, "code": "(fn\n  [e]\n  (fn [vars]\n    (letfn [(myeval [x]\n              (cond\n                (list? x) (apply (myeval (first x)) (vec (map myeval (rest x))))\n                (symbol? x) (cond\n                             (= x '*) *\n                             (= x '+) +\n                             (= x '/) /\n                             (= x '-) -\n                             :else (vars x))\n                (number? x) x))]\n      (myeval e))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 121, "code": "(fn [exp]\n  (fn [bindings]\n  \t((fn ev [exp] \n    \t(let [resf {'+ + '* * '/ / '- -}\n        \t  resv bindings]\n     \t (if (seq? exp) \n       \t \t(apply (resf (first exp)) \n        \t  (map ev (rest exp)))\n       \t \t(if (number? exp)\n        \t  exp\n          \t  (resv exp))))) exp)))", "user": "56b86e64e4b0f26550335924"}, {"problem": 121, "code": "(fn uce [s]\n\t(fn [m]\n\t\t(let [ops {'+ + '- - '* * '/ /}]\n\t\t\t((fn c [[f & args]]\n\t\t\t\t(apply (ops f) (map #(cond\n\t\t\t\t\t\t\t\t\t\t(coll? %) (c %)\n\t\t\t\t\t\t\t\t\t\t(symbol? %) (m %)\n\t\t\t\t\t\t\t\t\t\t:else %) args))) s))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 121, "code": "(fn calcX [f]\n\t(letfn [\n\t\t(calcRec[f v]\n\t\t\t(cond \n\t\t\t\t(symbol? f) (get v f)\n\t\t\t\t(number? f) f\n\t\t\t\t:else (case (first f)\n\t\t\t\t\t\t/ (apply / (map #(calcRec % v) (rest f))) \n\t\t\t\t\t\t+  (apply + (map #(calcRec % v)  (rest f)))\n\t\t\t\t\t\t-  (apply - (map #(calcRec % v)  (rest f)))\n\t\t\t\t\t\t*  (apply * (map #(calcRec % v)  (rest f)))\t\t\t\t\n\t\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t]\n\t\t(partial calcRec f)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 121, "code": "(fn v [s] (let [z #(if (symbol? %2) (last (first (filter (fn [x] (= %2 (first x))) %))) (if (coll? %2) ((v %2) %)  %2)) \n\t\t      n (fn [e m] (apply (get {'+ + '- - '/ / '* *} (first e)) (map #(z m %) (rest e))))] \n\t\t  (fn [m] (n s m))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 121, "code": "(fn [form]\n    (fn [context]\n      (let [f (fn uce [[op & args]]\n                (let [op (case op\n                           + +\n                           - -\n                           * *\n                           / /)]\n                  (apply op (map (fn [arg]\n                                   (if (list? arg)\n                                     (uce arg)\n                                     (get context arg arg))) args))))]\n        (f form))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 121, "code": "(fn [s]\n  (fn [m]\n    (let [calc (fn calc [[op & args]]\n                 (apply ({'+ + '- - '* * '/ /} op)\n                        (map #(if (coll? %) (calc %) (m % %)) args)))]\n      (calc s))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 121, "code": "(fn [x]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (letfn [(h [x binds]\n                   (cond\n                     (coll? x) (apply (ops (first x))\n                                         (map #(h % binds) (rest x)))\n                     (symbol? x) (binds x)\n                     (number? x) x))\n            ]\n      (fn [binds] (h x binds)))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 121, "code": "(fn f [exprs]\n  (fn f' [m]\n    (letfn [(g' [exprs]\n               (println \"going in for\" exprs)\n               (let [m' (merge m {'+ +, '- -, '/ /, '* *})\n                     expanded (map (fn [expr]\n                                     (if (coll? expr)\n                                       (g' expr)\n                                       (get m' expr expr)))\n                                   exprs)]\n                 (apply (first expanded) (rest expanded))))]\n      (g' exprs))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 121, "code": "(fn [form]\n    (fn [values]\n      ((fn eval- [f]\n         (cond\n           (number? f) f\n           (symbol? f) (get values f)\n           :else (apply ({'+ + '- - '* * '/ /} (first f)) (map eval- (rest f)))))\n       form)))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 121, "code": "(fn f [xs]\n    (fn [m]\n      (let [m (merge m {'+ + '- - '* * '/ /})]\n        (if (coll? xs)\n          (#(apply (first %) (rest %)) (map #((f %) m) xs))\n          (m xs xs)))\n      )\n    )", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 121, "code": "(fn UCE [ls]\n  (fn f [m]\n    (let [op (first ls)\n          args (map #(if (sequential? %)\n                       ((UCE %) m)\n                       %)\n                    (rest ls))]\n      (cond\n       (= op (symbol \"+\")) (apply + (map #(if-let [x (m %)] x %) args))\n       (= op (symbol \"-\")) (apply - (map #(if-let [x (m %)] x %) args))\n       (= op (symbol \"*\")) (apply * (map #(if-let [x (m %)] x %) args))\n       (= op (symbol \"/\")) (apply / (map #(if-let [x (m %)] x %) args))\n       ))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 121, "code": "(fn [a]\n  #((fn aux [x]\n      (if (seq? x)\n        (apply ({'+ + '- - '* * '/ /} (first x)) (map aux (rest x)))\n        (% x x))) a))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 121, "code": "(fn c-engine\n  [[f & v]]\n  (let [m-f {'/ / '+ + '* * '- -}]\n    (fn [m]\n      (apply (m-f f) (map #(if (list? %)\n                             ((c-engine %) m)\n                             (get m % %)) v)))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 121, "code": "(fn compute [expr]\n  (fn [context]\n    (cond\n      (number? expr) expr\n      (not (seq? expr)) (context expr)\n      :else (let [parse (fn [sym] (case sym\n                                    + +\n                                    - -\n                                    * *\n                                    / /))\n                  [op & ods] expr]\n              (apply (parse op) (map #((compute %) context) ods))))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 121, "code": "(fn [exprs]\n  (fn [m]\n    ((fn express [e]\n       (if (seq? e)\n         (apply ({'* * '/ / '- - '+ +} (first e)) (map express (rest e)))\n         (get m e e)))\n     exprs)))", "user": "56481722e4b0284900eef628"}, {"problem": 121, "code": "(fn compute[expression]\n  (fn[a-map]\n    (let [fnmap { '/ /,\n                 '* *,\n                 '+ +,\n                 '- -}\n          f (fnmap (first expression))]\n      (apply f (reduce #(conj % (if (list? %2)\n                                  ((compute %2) a-map)\n                                  (if (a-map %2)\n                                    (a-map %2)\n                                    %2))) [] (rest expression))))))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 121, "code": "(fn [form]\n  (fn [env]\n    (let [fenv {'+ + '- - '* * '/ /}]\n      (letfn [(parse [[f & nxt]]\n                 (when f\n                   (cond\n                     (sequential? f)\n                     (cons (parse f) (parse nxt))\n                     (fenv f)\n                     (apply (fenv f) (parse nxt))\n                     :else (cons (get env f f) (parse nxt)))))]\n      (parse form)))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 121, "code": "(fn compile' [[op & more]]\n  (let [op-fn {'+ + '- - '/ / '* *}\n        compile-item (fn [token]\n                       (cond\n                         (number? token) (fn [_] token)\n                         (symbol? token) (fn [vars] (vars token))\n                         :else (compile' token)))\n        ops (map compile-item more)]\n    (fn [vars] (apply (op-fn op) (map #(% vars) ops)))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 121, "code": "(fn [a-tree]\n  (fn [a-map]\n    (let [fn-map {'/ / '* * '+ + '- -}\n          process (fn process-tree [a-list]\n                    (let [filled-tree (for\n                                        [x a-list]\n                                        (if (list? x)\n                                          (process-tree x)\n                                          (a-map x x)))]\n                      (apply (fn-map (first filled-tree))\n                             (rest filled-tree))))]\n      (process a-tree))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 121, "code": "#(fn [m] (letfn [(comp [x]\n                   (if (sequential? x)\n                     (apply (-> x first {'+ + '- - '/ / '* *}) (map comp (rest x)))\n                     (get m x x)))]\n           (comp %)))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 121, "code": "(fn [fm]\n    (fn [args]\n      (let [ops (zipmap '(+ - * /) [+ - * /])]\n        ((fn step [[o & xs]]\n           (apply (ops o) (map #(cond\n                                  (symbol? %) (args %)\n                                  (coll? %) (step %)\n                                  :else %)\n                               xs)))\n         fm))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 121, "code": "(let [ops {'+ +, '- -, '* *, '/ /}]\n    (fn [expr]\n      (fn evl [bndgs]\n        (letfn [(rec [e]\n                  (cond\n                    (number? e) e\n                    (symbol? e) (get bndgs e :unbound-symbol)\n                    :else (apply (get ops (first e)) (map rec (rest e)))))]\n          (rec expr)))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 121, "code": "(fn compute [[op a b & rest]] (fn [vars] (let [mapToVars (fn [coll] (zipmap (map keyword (keys coll)) (vals coll)))\n                                          recognizeOp (fn [op] (cond\n                                                                             (= op '/) /\n                                                                             (= op '*) *\n                                                                             (= op '+) +\n                                                                             (= op '-) -))\n                                          unknown (fn [a vars] (cond (number? a) a\n                                                                             (symbol? a) (get vars (keyword a))\n                                                                             (list? a) ((compute a) vars)))\n\n                                          doOp (fn [op a b vars & others] (apply op (unknown a vars) (unknown b vars) (flatten others)))\n                                          solvedVars (mapToVars vars)\n                                          recognizedOp (recognizeOp op)\n                                          ]\n                                      (doOp recognizedOp a b solvedVars (if (nil? rest) [] rest)))))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 121, "code": "(let [ops-tab {'+ +, '- -, '* *, '/ /}\n        f (fn [form]\n            (fn [sym-tab]\n              (let [form' (clojure.walk/postwalk-replace\n                           (merge ops-tab sym-tab)\n                           form)\n                    wark (fn wark [expr]\n                           (if-not (list? expr)\n                             expr\n                             (apply (first expr)\n                                    (map wark (rest expr)))))]\n                (wark form'))))]\n    f)", "user": "53684a2fe4b0243289761e8c"}, {"problem": 121, "code": "(fn mf\n  [[f & args]]\n  (fn\n    [m]\n    (let [fs {'* `~* '/ `~/ '- `~- '+ `~+}]\n    (apply (get fs f) (map #(if (seq? %) ((mf %) m) (if (symbol? %) (get m %) %)) args)))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 121, "code": "(fn ev [[op & args]]\n  (fn with [dict]\n    (if (map? dict)\n      (apply (condp = op '+ + '- - '* * '/ /)\n             (map #(cond\n                    (list? %) ((ev %) dict)\n                    (symbol? %) (dict %)\n                    :else %)\n                  args))\n      (map #(with %)\n           dict))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 121, "code": "(fn universal-computation-engine [formula]\n  (fn [parameters]\n    (letfn [(evaluate [x]\n              (cond\n                (seq? x) (apply ({'/ / '+ + '- - '* *} (first x)) (map evaluate (rest x)))\n                (number? x) x))]\n      (evaluate (clojure.walk/prewalk-replace parameters formula)))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 121, "code": "(fn uce [formula]\n  (fn [val-map]\n    (letfn [(evaler [node] (if (sequential? node)\n                             (apply ({'+ + '- - '* * '/ /} (first node)) (rest node))\n                             node))]\n      (let [ftree (clojure.walk/postwalk-replace val-map formula)]\n        (clojure.walk/postwalk evaler ftree)))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 121, "code": "(fn calculate\n  [expr]\n  (fn [m]\n    (cond\n      (symbol? expr) (m expr)\n      (number? expr) expr\n      :else (apply ({'+ + '- - '* * '/ /} (first expr))\n                   (map #((calculate %) m) (rest expr))))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 121, "code": "(fn f [[o & ab]]\n  (fn [m]\n  (apply  ({'+ + '- - '* * '/ /} o) \n         (for [a ab]\n           (if (list? a)\n             ((f a) m)\n             (get m a a))))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 121, "code": "(fn comp-eng [expr] ;universal-computation-engine [expr]\n  (letfn [(replace-vals [expr mapp] ;;creates nem expr with letters replaced by\n            (loop [expr expr        ;;vals in mapp\n                   expr2 []]\n              (if (= expr '())\n                expr2\n                (let [f (if (coll? (first expr))\n                          (replace-vals (first expr) mapp)\n                          (first expr))]\n                  (if (contains? mapp f)\n                    (recur (rest expr) (conj expr2 (mapp f)))\n                    (recur (rest expr) (conj expr2 f)))))))\n\n          (my-eval [expr] ;;my implementation of eval function\n            (letfn [(return-operator [op]\n                      (case (str op)\n                        \"+\" +\n                        \"-\" -\n                        \"*\" *\n                        \"/\" /))\n                    ]\n              \n              (loop [expr expr]\n                (if (not= expr '())\n                  (let [f (first expr)]\n                    (if (and (not (number? f)) (not (coll? f))) ;;is an operator\n                      (let [op1 (first (rest expr))\n                            op2 (second (rest expr))\n                            expr2 (rest (rest (rest expr)))]\n                        (let [op1 (if (coll? op1)\n                                    (my-eval op1)\n                                    op1)\n                              op2 (if (coll? op2)\n                                    (my-eval op2)\n                                    op2)\n                              operator (return-operator f)]\n                          (if (= expr2 '())\n                            (operator op1 op2)\n                            (recur (conj expr2 (operator op1 op2) f)))))))))))\n          ]\n    (fn [mapp]\n      (let [expr2 (replace-vals expr mapp)]\n        (my-eval expr2)))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 121, "code": "(fn [expr]\n  (fn [env]\n    (letfn [(do-eval [expr]\n              (cond (list? expr) (let [[op & args] (map do-eval expr)]\n                                   (apply op args))\n                    (number? expr) expr\n                    (nil? expr) expr\n                    (= '+ expr) +\n                    (= '- expr) -\n                    (= '* expr) *\n                    (= '/ expr) /\n                    :else (env expr)))]\n      (do-eval expr))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 121, "code": "(fn [form]\n  (fn [bmap]\n    (let [calc (fn calc\n                 ([x] (if (sequential? x) (apply calc x) x))\n                 ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                             (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace bmap form)]\n      (calc formula))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 121, "code": "(fn fullEval [input] (letfn [\n                             (exprEval [argMap vals] (map (fn [val] (cond\n                                                                     (number? val) val\n                                                                     (coll? val) (let [expr (exprEval argMap val)] (apply (first expr) (rest expr)))\n                                                                     (= val '+) +\n                                                                     (= val '*) *\n                                                                     (= val '/) /\n                                                                     (= val '-) -\n                                                                     :default (argMap val))) vals))\n                           ]\n                                                          \n            (fn [argMap] (let [e (exprEval argMap input)] (apply (first e) (rest e))))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 121, "code": "(fn uce [formula]\n  (fn [args]\n    (let [[f & rs]\n          (map #(if (coll? %) \n                  ((uce %) args)\n                  (if (nil? (args %)) % (args %))) formula)]\n      (apply  ({'/ / '+ + '- - '* *} f) rs))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 121, "code": "#(fn [m] ((fn v [x] (if (number? x) x\n                        (let [[op & r] x]\n                          (apply ({'/ / '* * '+ + '- -} op)\n                                 (map v r)))))\n           (clojure.walk/prewalk-replace m %)))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 121, "code": "(fn calc [formula]\n    (let [o {'+ + '- - '* * '/ /}\n          f (o (first formula))\n          m (fn m [v x]\n              (map #(if (seq? %)\n                      ((calc %) v)\n                      (if (number? %)\n                        %\n                        (v %)))\n                   x))]\n      (fn [vars]\n        (apply f (m vars (rest formula))))))", "user": "579693d4e4b039eba2ecb0e7"}, {"problem": 121, "code": "(fn calc [formula]\n    (let [o {'+ + '- - '* * '/ /}\n          f (o (first formula))\n          m (fn m [v x]\n              (map #(if (seq? %)\n                      ((calc %) v)\n                      (if (number? %)\n                        %\n                        (v %)))\n                   x))]\n      (fn [vars]\n        (apply f (m vars (rest formula))))))", "user": "5796d308e4b039eba2ecb0ed"}, {"problem": 121, "code": "(fn calc [formula]\n    (let [o {'+ + '- - '* * '/ /}\n          f (o (first formula))\n          m (fn m [v x]\n              (map #(if (seq? %)\n                      ((calc %) v)\n                      (if (number? %)\n                        %\n                        (v %)))\n                   x))]\n      (fn [vars]\n        (apply f (m vars (rest formula))))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 121, "code": "(fn calc [formula]\n    (let [o {'+ + '- - '* * '/ /}\n          f (o (first formula))\n          m (fn m [v x]\n              (map #(if (seq? %)\n                      ((calc %) v)\n                      (if (number? %)\n                        %\n                        (v %)))\n                   x))]\n      (fn [vars]\n        (apply f (m vars (rest formula))))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 121, "code": "(fn calc [formula]\n    (let [o {'+ + '- - '* * '/ /}\n          f (o (first formula))\n          m (fn m [v x]\n              (map #(if (seq? %)\n                      ((calc %) v)\n                      (if (number? %)\n                        %\n                        (v %)))\n                   x))]\n      (fn [vars]\n        (apply f (m vars (rest formula))))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 121, "code": "(fn myresolve [as]\n  (fn [ms]\n    (if (seq? as)\n      (apply (condp = (first as)\n               '+ +\n               '* *\n               '/ /\n               '- -) (map #((myresolve %) ms) (rest as)))\n      (if (symbol? as)\n        (get ms as)\n        as))))", "user": "57642916e4b0994c1922fbee"}, {"problem": 121, "code": "(fn f [formula]\n  (let [ops {'+ + '- - '/ / '* *}]\n  \t(fn [vars]\n      (let [operator (first formula)\n       \t\toperands (replace vars (drop 1 formula))]\n        (reduce #(let [i1 (if (coll? %)  ((f %) vars) %)\n                       i2 (if (coll? %2) ((f %2) vars) %2)]\n                   ((ops operator) i1 i2)) operands)))))", "user": "56a51f26e4b0542e1f8d14e0"}, {"problem": 121, "code": "(fn [g]\n  (letfn [(e [f vs]\n\t  (if (seq? f)\n\t    (let [o ((first f) {'+ + '- - '* * '/ /})\n\t          os (map #(e % vs) (rest f))]\n\t      (apply o os))\n\t    (if (symbol? f)\n\t      (f vs)\n\t      f)))]\n    (partial e g)))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 121, "code": "(fn [expr]\n    (fn [binds]\n      (let [op-map {'/ / '+ + '* * '- -}]\n        (letfn [(evaluate [[op & args]]\n                  (apply (op-map op) (for [arg args]\n                                       (cond\n                                         (number? arg) arg\n                                         (binds arg) (binds arg)\n                                         :else (evaluate arg)))))]\n          (evaluate expr)))))", "user": "560e9a2de4b05f002753df52"}, {"problem": 121, "code": "(fn _ [expr]\n  (fn [bindings]\n    (cond \n     (list? expr) (apply (get {'+ + '- - '/ / '* *} (first expr))\n                         (map #((_ %) bindings) (rest expr)))\n     (symbol? expr) (get bindings expr)\n     :else expr)))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 121, "code": "(fn evl\n  ([exp] (fn [env] (evl exp env))) \n  ([exp env]\n   (let [rslv (fn[exp env] (get (merge {'+ + '- - '/ / '* *} env) exp exp))]\n     (cond\n       (symbol? exp) (rslv exp env)\n       (list? exp) (apply (evl (first exp) env) (map #(evl % env) (rest exp)))\n       :else exp))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 121, "code": "(let [pattern #\"\\(([^()]+)\\)\"]\n(letfn\n[\n(eval-op [x [op & xs]] \n  (str\n    (apply ({\"+\" +\n             \"-\" -\n             \"*\" *\n             \"/\" /} op)\n      (map #(or (x (str %)) (Integer. %)) xs))))\n(eval-inner [s x]\n  (clojure.string/replace \n    (str s)\n    pattern\n    (fn [xs]\n      (eval-op\n        x\n        (clojure.string/split\n          (second xs)\n          #\" \")))\n    ))\n  (itus [s f]   ; iterate until same\n    (loop [s s]\n      (let [s1 (f s)]\n        (if (= s s1) s1 (recur s1)))))\n  (stm [s] ; symbol to map\n    (let [s (str s)\n          s (subs s 1 (dec (count s)))\n          s (clojure.string/replace s #\",\" \"\")]\n      (into {} (map (fn [[x y]] [x (Integer. y)]) (partition 2 (clojure.string/split s #\" \"))))\n    ))]\n  (fn [s] (fn [x] (Integer. (itus s #(eval-inner % (stm x))))))\n  ))", "user": "57717915e4b0979f896515b3"}, {"problem": 121, "code": "(fn [m]\n  (fn [n]\n    (letfn [(sub [m n] \n    \t\t\t(cond \n                 \t(empty? m) nil\n                 \t(= '+ (first m)) (apply + (sub (rest m) n))\n          \t\t\t(= '/ (first m)) (apply / (sub (rest m) n))\n          \t\t\t(= '- (first m)) (apply - (sub (rest m) n))\n         \t\t\t(= '* (first m)) (apply * (sub (rest m) n))\n         \t\t\t(coll? (first m)) (cons (sub (first m) n) (sub (rest m) n))\n                 \t(number? (first m)) (cons (first m) (sub (rest m) n))\n       \t\t\t   \t:else (cons (second (find n (first m))) (sub (rest m) n))))]\n      (sub m n))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 121, "code": "(fn f [exp]\n  (fn [var]\n    (let [op (condp = (first exp)\n               '+ +\n               '- -\n               '* *\n               '/ /)\n          args (map \n                (fn [s]\n                  (if (symbol? s)\n                    (get var s)\n                    (if (list? s)\n                      ((f s) var)\n                      s)))\n                (rest exp))]\n      (apply op args))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 121, "code": "(fn my-eval[L]\n  (fn [M]\n    (cond (number? L) L\n          (symbol? L) (M L)\n          (list? L) (apply ({'+ + '- - '* * '/ /} (first L))\n                           (map #((my-eval %) M) (rest L))))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 121, "code": "(fn computation-engine [expr]\n  (fn [vars]    \n    (letfn [(compute [expr]\n              (if (list? expr)\n                (apply ({'+ + '- - '* * '/ /} (first expr)) (map compute (next expr)))\n                (vars expr expr)\n                ))]\n      (compute expr))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 121, "code": "(fn expr-eval [expr]\n    (fn values-eval [values]\n      (cond\n        (symbol? expr)  (->> values (filter #(= (first %) expr)) first second)\n        (seq? expr)     (let [[op & args] expr\n                              opfn  (case op\n                                      +  +\n                                      *  *\n                                      -  -\n                                      /  /)\n                              ]\n                          (apply opfn (map #((expr-eval %) values) args))\n                          )\n        :else           expr\n        )\n      )\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 121, "code": "(fn [f]\n  (fn [s]\n    ((fn g [[h & t]]\n      (let [op {'+ +, '- -, '* *, '/ /}\n            [c l] ((juxt filter remove) coll? t)]\n        (apply (op h)\n          (concat (map #(get s % %) l) (map g c))))) f)))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 121, "code": "(fn evaulate [expression]\n   (fn [environment]\n     (let [merged-environment (merge environment {'/ / '+ + '- - '* *})\n           flattened (map (fn [sub-expression]\n                            (if (coll? sub-expression) ((evaulate sub-expression) environment)\n                                                       sub-expression)) expression)\n           replaced-params (map (fn [sub-expression]\n                                  (if (contains? merged-environment sub-expression)\n                                    (get merged-environment sub-expression)\n                                    sub-expression)) flattened)]\n       (apply (first replaced-params) (rest replaced-params))\n       )))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 121, "code": "(fn [expr]\n    (letfn \n        [(my-resolve [op] ({'/ / '+ + '- - '* *} op))\n         (my-calc [expr] (fn [xs] (apply (my-resolve (first expr))\n                        (map (fn [k] (if (list? k) ((my-calc k) xs) (xs k k)))\n                             (rest expr)))))]\n        (my-calc expr)))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 121, "code": "(fn compute [xs]\n    (fn [m]\n      (let\n        [\n          operators\n          {'/ / '+ + '* * '- -}\n\n          [op-symbol & arg-symbols] xs\n\n          args\n          (\n            map\n            (fn [arg]\n              (if (seq? arg)\n                ((compute arg) m)\n                (get m arg arg)\n              )\n            )\n            arg-symbols\n          )\n\n          op (get operators op-symbol)\n        ]\n        (apply op args)\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 121, "code": "(fn uce [expr]\n  (let [fn-mappings (apply hash-map ['+ + '- - '* * '/ /])]\n\n    (letfn [(map-args [st mappings]\n              (map (fn [sym]\n                     (if (coll? sym)\n                       (map-args sym mappings)\n                       (get mappings sym sym)))\n                   st))\n\n            (visit [[op & arguments]]\n              (if (nil? arguments)\n                (recur op)\n                (if-not (some coll? arguments)\n                  (apply (fn-mappings op) arguments)\n                  (visit\n                   (cons op (map (fn [x]\n                                   (if (coll? x)\n                                     (visit x)\n                                     x))\n                                 arguments))))))]\n\n      (fn [& args]\n        (->> (map-args expr (first args)) visit)))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 121, "code": "(fn f [form]\n  (fn [m]\n    (letfn [(evaluate \n              [form]\n              (cond\n                (number? form) form\n                (list? form)        \n                (let [op (first form)]\n                  (cond\n                    (= op '/) (apply / (map evaluate (next form))) \n                    (= op '*) (apply * (map evaluate (next form)))\n                    (= op '+) (apply + (map evaluate (next form)))\n                    (= op '-) (apply - (map evaluate (next form)))))\n                :else\n                (m form)))]\n      (evaluate form))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 121, "code": "(fn get-val\n   [expr]\n   (letfn [(cal-val\n             [expr data]\n             (if (list? expr)\n               (let [op (first expr)\n                     oths (rest expr)]\n                 (condp = op\n                   '+ (apply + (map #(cal-val % data) oths))\n                   '- (apply - (map #(cal-val % data) oths))\n                   '* (apply * (map #(cal-val % data) oths))\n                   '/ (apply / (map #(cal-val % data) oths))))\n               (if (symbol? expr)\n                 (data expr)\n                 expr)))]\n     (partial cal-val expr)))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 121, "code": "(fn ucc [form]\n  (fn [args] (clojure.walk/postwalk #(if (seq? %) (apply ({'+ + '- - '/ / '* *} (first %)) (rest %)) %)\n                                    (clojure.walk/postwalk-replace args form))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 121, "code": "(fn [e]\n  (fn [vs]\n    (letfn [\n            (to-number [x]\n              (cond \n                (number? x) x\n                (symbol? x) (get vs x)\n                :else (parse x)))\n            \n            (parse [[o & xs]]\n              (case o\n                / (reduce / (map to-number xs))\n                * (reduce * (map to-number xs))\n                + (reduce + (map to-number xs))\n                - (reduce - (map to-number xs))))]\n      \n      (parse e))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 121, "code": "(fn [form]\n  (letfn [(step [s]\n            (let [formulars (re-seq #\"\\([^\\(\\)]*\\)\" s)]\n              (if (seq formulars)\n                (let [formulars-results (map\n                                          (fn [formular]\n                                            (let [formular-seq (re-seq #\"[\\+\\-\\*/0-9]+\" formular)]\n                                              (apply\n                                                (case (first formular-seq)\n                                                  \"+\" +\n                                                  \"-\" -\n                                                  \"*\" *\n                                                  \"/\" /)\n                                                (map #(Integer/parseInt %) (rest formular-seq)))\n                                              ))\n                                          formulars)]\n                  (step (reduce #(.replace %1 (key %2) (str (val %2))) s (apply assoc {} (interleave formulars formulars-results)))))\n                (Integer/parseInt s))))]\n    (fn [m]\n      (let [form-str (str form)]\n        (step (reduce #(.replace %1 (str (key %2)) (str (val %2))) form-str m))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 121, "code": "(fn u-comp [tl-form]\n  (fn [bindings]\n    (letfn [(ev [form]\n              (cond\n                (list? form)\n                (let [[f & args] form]\n                  (apply (condp = f '/ / '+ + '* * '- -)\n                   (map ev args)))\n\n                (number? form)\n                form\n\n                :default\n                (get bindings form)))]\n      (ev tl-form))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 121, "code": "(let [m {'+ clojure.core/+\n         '- clojure.core/-\n         '* clojure.core/*\n         '/ clojure.core//}]\n  (fn c121\n    [[fe & args]]\n    (fn [v]\n      (let [f (m fe)\n            a (map (fn [val]\n                     (if (seq? val)\n                       ((c121 val) v)\n                       (v val val))) args)]\n        (apply f a)))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 121, "code": "(fn eval-u8 [e]\n  (fn [valmap]        \n    ((fn evl [valmap e]\n       (let [ops {'+ +, '- -, '* *, '/ /}\n             [op & operands]\n               (map #(if (coll? %) (evl valmap %) %) (replace valmap e))]\n        (apply (ops op) operands))) valmap e)))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 121, "code": "(fn evaluation [exp]\n               (fn [val-map]\n                 (let [op (conj '{} [(read-string \"+\") +] [(read-string \"-\") -] [(read-string \"*\") *] [(read-string \"/\") /])]\n                   (letfn [(eva [coll]\n                             (if-not (sequential? coll)\n                               (if (integer? coll)\n                                 coll\n                                 (coll val-map))\n                               (apply ((first coll) op) (map eva (rest coll)))))]\n                     (eva exp)))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 121, "code": "(fn uce\n  [f]\n  (let [om {'+ + '- - '* * '/ /}]\n    (fn [v]\n      (letfn [(e [exp]\n                 (if (coll? exp)\n                   (apply (om (first exp)) (map e (rest exp)))\n                   (if (symbol? exp) (v exp) exp)))]\n        (e f)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 121, "code": "(fn compute [expr] (fn [var-env]\n  (let [opp-env {'+ + '- - '* * '/ /}]\n    (letfn [(do-eval [expr]\n              (cond\n                (coll? expr)   (let [[opp & args] expr] \n                                 (apply (opp-env opp) (map do-eval args)))\n                (symbol? expr) (var-env expr)\n                :else           expr))]\n      (do-eval expr)))))", "user": "4faa9593e4b081705acca1f9"}, {"problem": 121, "code": "(fn my-eval [expr]\n  (fn [vars]\n    (cond\n      (list? expr) (let [op (case (first expr)\n                              + +\n                              - -\n                              * *\n                              / /)\n                         args (rest expr)]\n                     (apply op (map #((my-eval %) vars) args)))\n      (symbol? expr) (vars expr)\n      :else expr)))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 121, "code": "(fn f [e]\n  (let [ops {'+ +\n             '- -\n             '/ /\n             '* *}\n        [s & args] e]\n    (fn [m]\n      (let [g (fn [a]\n                (cond\n                  (symbol? a) (m a)\n                  (seq? a) ((f a) m)\n                  :else a))]\n        (apply (ops s) (map g args))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 121, "code": "(fn __ [t]\n  (fn [ctx]\n    (letfn [(ev [e]\n              (let [ops {'+ +\n                         '- -\n                         '/ /\n                         '* *}]\n                (cond\n                  (list? e) (apply (get ops (first e)) (map ev (rest e)))\n                  (symbol? e) (get ctx e)\n                  (number? e) e)))]\n\n      (ev t))))", "user": "4ec1923f535dfed6da9c6db2"}, {"problem": 121, "code": "(fn [t]\n  (letfn [(w [t m]\n            (let [s->f (fn [s] (get {'+ + '- - '* * '/ /} s s))]\n              (if (list? t)\n                (apply (s->f (first t)) (map #(w % m) (rest t)))\n                (get m t t))))]\n  (fn [m] (w t m))))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 121, "code": "(fn comp-engine [f]\n  (fn [m] ((fn compute [[f-sym & args]]\n             (let [resolved-f (condp = f-sym\n                                '/ /\n                                '+ +\n                                '- -\n                                '* *)\n                   resolved-args (map #(cond\n                                         (coll? %) (compute %)\n                                         (symbol? %) (% m)\n                                         :else %) args)]\n               (apply resolved-f resolved-args)))\n           f)))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 121, "code": "(fn\n  [str-fn]\n  (fn\n  [x]\n  (letfn [(sym-2-str [[k v]] {(str k) v})\n          (fn-choose [f-sym] (case (str f-sym) \"+\" + \"-\" - \"*\" * \"/\" /))\n          (eval-fn [f m] (if ((complement seq?) f)\n                           (if (number? f) f (m (str f)))\n                           (apply (fn-choose (first f)) (map eval-fn (next f) (repeat m)))\n\t\t\t   ))]\n          (eval-fn str-fn (into {} (map sym-2-str x))))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 121, "code": "(fn [exp]\n    (let [fns {'+ + '- - '/ / '* *}]\n      (fn [vmap]\n        (let [cmp (fn cmp [x]\n                    (if (seq? x)\n                      (let [[f & args] x]\n                        (apply (fns f) (map cmp args)))\n                      (get vmap x x)))]\n          (cmp exp)))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 121, "code": "(fn calc-for [formel]\n  (fn [arg-map]\n    (letfn [(eval-args [vs]\n             (map (fn [a]\n                    (cond\n                      (coll? a) (loc-calc a)\n                      (and (symbol? a) (contains? arg-map a))\n                        (arg-map a)\n                      (number? a) a\n                      :else (throw (Exception. \"Unknown token\"))) )\n                  vs))\n            (loc-calc [short-f]\n              (let [mops {(symbol \"+\") +\n                          (symbol \"-\") -\n                          (symbol \"*\") *\n                          (symbol \"/\") / }\n                    fst (first short-f)\n                    rst (rest short-f)\n                    op (mops fst)]\n                (apply op (eval-args rst)) ))]\n  (loc-calc formel)  )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 121, "code": "(fn universal-computation-engine [form]\n  (fn [args-set]\n    (let [args-set (merge {'+ +, '- -, '* *, '/ /} args-set)]\n      (letfn [(iuce [form]\n                (if (seq? form)\n                  (let [form (replace args-set form),\n                        [f & as] (map iuce form)] (apply f as))\n                  form))]\n        (iuce form)))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 121, "code": "(fn uce [ex]\n  (let [ops {'+ + '- - '* * '/ /}\n        f   (ops (first ex))]\n   (fn [vs]\n    (if (every? list? (rest ex))\n        (reduce f (map #(% vs) (map uce (filter list? ex))))\n        (reduce f (reduce f (map #(get vs % %) (filter #(not (list? %)) (rest ex))))\n                  (map #(% vs) (map uce (filter list? ex))))))))", "user": "544e8369e4b0e39780006987"}, {"problem": 121, "code": "(fn uce' [fmla]\n  (let [ops\n        {'/ / '* * '+ + '- -}\n\n        uce-fn\n        (fn engine [expression substitutes]\n          (let [operator (ops (first expression))]\n            (apply operator (reduce (fn [acc v]\n                                      (conj acc\n                                            (or (substitutes v)\n                                                (if (seq? v)\n                                                  (engine v substitutes)\n                                                  v))))\n                                    [] (rest expression)))))]\n    (fn [subs']\n      (uce-fn fmla subs'))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 121, "code": "(fn [expr]\n     (fn [data]\n       (let [m (merge {'+ + '- - '* * '/ /} data)]\n         ((fn myeval [form]\n            (println form)\n            (if (seq? form)\n              (let [[o & args] form]\n                (apply (m o) (map myeval args)))\n              (m form form)))\n          expr))))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 121, "code": "(fn __ [f]\n  (fn [m]\n    ((fn c [[f & o] m]\n       (->> o\n            (mapv (fn [o]\n                    (cond\n                      (list? o) (c o m)\n                      (symbol? o) (m o)\n                      1 o)))\n            (apply ({'/ /\n                     '* *\n                     '+ +\n                     '- -} f))))\n     f m)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 121, "code": "(let [substitute (fn substitute\n                   [sym value tree]\n                   (let [[op & args] tree]\n                     (let [nargs (map  (fn [p] (if (sequential? p)\n                                                 (substitute sym value p)\n                                                 (if (= p sym) value p))) args)]\n                       (into [op] nargs))))\n      evaluate (fn evaluate\n        [tree]\n        (let [ops {'+ + '- - '* * '/ /}]\n          (let [[op & args] tree]\n            (apply (ops op) (map (fn [p] (if (sequential? p) (evaluate p) p)) args)))))]\n  (fn make-eval-fn\n    [tree]\n    (fn [args]\n      (loop [[[sym val] & t] (into [] args)\n             current-tree tree]\n        (let [new-tree (substitute sym val current-tree)]\n          (if (nil? t)\n            (evaluate new-tree)\n            (recur t new-tree)))))))", "user": "58152157e4b0f478707a0631"}, {"problem": 121, "code": "(fn [l]\n   (fn [m]\n     (letfn [(c [[f & g]]\n               (let [g (map #(cond\n                               (seq? %) (c %)\n                               (symbol? %) (m %)\n                               :else %) g)\n                     f ({'+ + '- - '/ / '* *} f)]\n                 (apply f g)))]\n       (c l))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 121, "code": "(fn [e]\n  (fn [m]\n    (clojure.walk/postwalk\n     #(if (seq? %)\n        (let [[x & r] %] (apply x r))\n        %)\n     (clojure.walk/prewalk-replace (into m {'+ + '* * '/ / '- -})\n                                   e))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 121, "code": "(fn evl [[op & args]]\n    (fn [dic]\n      (apply\n        (get {'+ + '- - '* * '/ /} op)\n        (map #(if (coll? %) ((evl %) dic)\n                  (get dic % %))\n             args))))", "user": "4e80e0f2535db62dc21a62b8"}, {"problem": 121, "code": "(fn uct [[op-sym & args]]\n  (let [operator (get {'/ / '* * '+ + '- -} op-sym)]\n    (fn [context]\n      (let [calculate (fn [exp]\n                        (if (seq? exp) ((uct exp) context)\n                                       (or (context exp) exp)))]\n        (apply operator (map calculate args)))\n      )))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 121, "code": "(fn eval' [f]\n  (fn [m]\n    (let [resolve' (fn [expr]\n            (cond\n              (symbol? expr) ((merge m {'/ / '* * '+ + '- -}) expr)\n              (coll? expr) ((eval' expr) m)\n              :else expr))\n          resolved (map resolve' f)]\n      (apply (first resolved) (rest resolved)))))", "user": "58247423e4b051871117bec5"}, {"problem": 121, "code": "(fn calculator\n  [formula]\n  (fn [values]\n    (letfn [(evalu [form] (let [simp (replace (merge values {'+ + '- - '* * '/ /})\n                                                     form)]\n                                (apply (first simp) (rest simp))))\n            (calc [form]\n              (if (not-any? sequential? form)\n                (evalu form)\n                (evalu (map (fn [s] (if (sequential? s) (calc s) s)) form))))]\n      (calc formula))))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 121, "code": "(fn __\n  ([formula]\n       (fn [m] (__ formula m)))\n  ([formula m]\n   (let [ops (hash-map '+ + '- - '* * '/ /)\n         op (ops (first formula))\n         args (rest formula)]\n     (letfn [(get-args [as m] (map #(get-arg % m) as))\n             (get-arg [a m] (if (list? a) (__ a m) (get m a a)))]\n       (apply op (get-args args m))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 121, "code": "(fn [s]\n    (fn [m]\n      (letfn [(calc [[op & args]]\n                (apply ({'+ + '- - '* * '/ /} op)\n                       (map #(if (coll? %) (calc %) (m % %)) args)))]\n        (calc s))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 121, "code": "(fn compute [expr]\n  (fn [var-map]\n    (let [operators {'* * '+ + '/ / '- -}]  \n      (letfn [(my-eval [expr]\n              (cond\n                (coll? expr)\n                  (let [[op & operands] expr]\n                    (apply (operators op) (map my-eval operands)))\n                (number? expr)\n                  expr\n                (symbol? expr)\n                  (var-map expr)))] \n      (my-eval expr)))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 121, "code": "(fn solve [exp]\n  (fn [vars]\n    (let [op ((first exp) {'+ + '- - '* * '/ /})\n          xs (->> (rest exp)\n                  (map #(if (coll? %)\n                          ((solve %) vars)\n                          (vars % %))))]\n      (apply op xs))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 121, "code": "(fn eval-fx [formula]\n  (fn [vars]\n    (let [postwalk clojure.walk/postwalk\n          ops {'/ / '+ + '* * '- -}\n          eval-op #(if (coll? %)\n                     (let [op (first %)\n                           f  (partial apply (get ops op))]\n                       ;; Evaluate inner-most expression\n                       (f (rest %)))\n                     ;; Replace vars with values. If var is not found, it's\n                     ;; assumed to be the value, so it's used as the default\n                     (get vars % %))]\n      ;; Postwalk will traverse the inner most lists first. So we evaluate from the inside out\n      (postwalk eval-op formula))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 121, "code": "(let [fs {'+ + '- - '* * '/ /}]\n  (fn named [[f & args-or-sexps]]\n    (fn [bindings]\n      (let [args (map #(if (seq? %)\n                         ((named %) bindings)\n                         %)\n                      args-or-sexps)]\n        (apply (fs f) (replace bindings args))))))\n\n;(let [symbol-map {'- - '+ + '* * '/ /}\n;      contract (fn contract [el]\n;                 (if (number? el)\n;                   el\n;                   (apply (symbol-map (first el))\n;                          (map contract (rest el)))))]\n;  (fn [s-exps]\n;    (fn [bindings]\n;        (contract (clojure.walk/postwalk-replace bindings s-exps)))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 121, "code": "(fn [a] (fn [b] ((fn exec [expr bindings] (cond\n                                           (list? expr) (apply ({'+ + '- - '* * '/ /} (first expr))\n                                                               (map #(exec % bindings) (rest expr)))\n                                           (symbol? expr) (bindings expr)\n                                           true expr)) a b)))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 121, "code": "(fn ! [[f & r]]\n  (fn [m](let [j (map #(cond \n                        (seq? %) ((! %) m)\n                \t\t(symbol? %) (m %)\n                \t\t:else %) r)\n               op (condp = (name f)\n                    \"+\" +\n          \t\t\t\"-\" -\n          \t\t\t\"/\" /\n          \t\t\t\"*\" *)]\n           (apply op j))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 121, "code": "(fn my-resolve [form]\n  (fn [symbols]\n    (cond\n     (list? form) (apply \n                   ((my-resolve (first form)) symbols)\n                   (map #((my-resolve %) symbols) (rest form)))\n     (number? form) form\n     (= '+ form) +\n     (= '- form) -\n     (= '* form) *\n     (= '/ form) /\n     :else (get symbols form))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 121, "code": "(letfn [(l [[x & xs] i]\n            (apply ({'+ + '- - '* * '/ /} x)\n                   (map #(cond \n                           (list? %)  (l % i)\n                           (number? %) %\n                           :else (i %))\n                        xs)))]\n    (fn [xs] #(l xs %)))", "user": "55597b84e4b0deb715856e36"}, {"problem": 121, "code": "(fn [l]\n   (fn [params]\n    (letfn \n     [(evaluate [x]  \n       (if \n        (list? x) \n        (apply ({'/ / '+ + '- - '* *} (first x)) (map evaluate  (rest x) ) )       \n        x\n        )\n       )\n      ] \n\n     (evaluate (clojure.walk/prewalk-replace params  l)) )\n  )\n  )", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 121, "code": "(fn engine [exp]\n  (letfn [\n          (calc\n            ([exp ,ctx]\n             (cond\n              (coll? exp) (calc (first exp) (rest exp) ctx)\n              :else (or (ctx exp) exp)))\n            ([op elements ctx]\n             (let [fns {'+ + '- - '* * '/ /}]\n                (apply (fns op) (map #(calc % ctx) elements)))))]\n    (fn [ctx] (calc exp ctx))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 121, "code": "(fn universal-computation-engine [exp]\n  (fn [ctx]\n    (let [simplify (fn [exp]\n                    (if (seq? exp)\n                      ((universal-computation-engine exp) ctx)\n                      (get ctx exp exp)))\n          ops {'+ + '- - '* * '/ /}]\n      (apply (ops (first exp)) (map simplify (next exp))))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 121, "code": "(fn [formula]\n  (let [ops {'* *, '+ +, '- -, '/ /}]\n    (fn [m]\n      (clojure.walk/postwalk\n       (fn [x]\n         (cond\n          (symbol? x) ((merge ops m) x)\n          (list? x) (apply (first x) (rest x))\n          (number? x) x))\n       formula))))", "user": "54d9f7f1e4b024c67c0cf751"}, {"problem": 121, "code": "(fn [e]\n    (let [ev (fn ev [m e]\n               (if (seq? e)\n                 (let [e          (replace m e)\n                       [o & args] e]\n                   (apply ({'/ / '+ + '* * '- -} o)\n                          (map (partial ev m) args)))\n                 e))]\n      (fn [m]\n       (ev m e))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 121, "code": "(fn uct [[o-s & a]]\n  (let [op (get {'/ / '* * '+ + '- -} o-s)]\n    (fn [mp]\n      (let [c (fn [e]\n                (if (coll? e)\n                  ((uct e) mp)\n                  (or (mp e) e)))]\n        (apply op (map c a))))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 121, "code": "(fn [expression]\n  (fn [vars]\n    (letfn [(handle-expression [[op & operands]] (do-op op (build-operands operands)))\n            (parse-operand [operand] (if (sequential? operand) (handle-expression operand) (get vars operand operand)))\n            (build-operands [operands] (map parse-operand operands))\n            (do-op [op operands]\n                   (case op\n                     + (apply + operands)\n                     - (apply - operands)\n                     * (apply * operands)\n                     / (apply / operands)))]\n      (handle-expression expression))))", "user": "58923efce4b00487982d521c"}, {"problem": 121, "code": "(fn u-c-e [form]\n          (let [math-ops {'+ + '- - '* * '/ /}]\n            (fn [env]\n              (let [[op & args] form]\n                (apply (math-ops op) (map #(cond\n                                             (seq? %) ((u-c-e %) env)\n                                             (symbol? %) (env %)\n                                             :default %) args))))))", "user": "58949f8de4b00487982d525e"}, {"problem": 121, "code": "(fn [expression]\n  (letfn [(my-eval [expr env]\n            (cond\n              (number? expr)\n              expr\n\n              (coll? expr)\n              (let [op (first expr)\n                    args (map #(my-eval % env) (rest expr))]\n                (cond\n                  (= op '+) (apply + args)\n                  (= op '-) (apply - args)\n                  (= op '*) (apply * args)\n                  (= op '/) (apply / args)))\n\n              :else\n              (env expr)))]\n    (fn [m] (my-eval expression m))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 121, "code": "(fn compute [[op & r]]\n  (let [ops {'+ + '- - '/ / '* *}]\n    (fn [m] (apply\n              (ops op)\n              (map (fn [t]\n                     (cond\n                       (symbol? t) (m t)\n                       (number? t) t\n                       :default ((compute t) m))) r)))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 121, "code": "(fn [expr]\n  (fn [m]\n    (letfn [(subst [x f]\n              (if (sequential? x)\n                (f x)\n                (if (number? x)\n                  x\n                  (m x))))\n            (calc [[op & xs]]\n              (let [ops {'+ + '- - '* * '/ /}]\n                (apply (ops (symbol op)) (map (fn [x] (subst x calc)) xs))))]\n      (calc expr))))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 121, "code": "(fn buildFunc [expression]\n  (let\n    [\n     opmap {'+ +, '- -, '* *, '/ /}\n     resolver\n     (fn resolveExp [vars exp]\n       (let\n         [\n          resolveArg\n          (fn [arg]\n            (if (seq? arg)\n              #(resolveExp vars arg)\n              (if (symbol? arg)\n                #(vars arg)\n                #(identity arg)\n                )\n              )\n            )\n          func (opmap (first exp))\n          args (map resolveArg (rest exp))\n          ]\n         (apply func (map #(%) args))\n         )\n       )]\n    (fn [varmap]\n      (resolver varmap expression)\n      )\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 121, "code": "(fn compile [expr]\n  (cond\n    (list? expr) (fn [dict]\n      (apply (compile (first expr)) (map #((compile %) dict) (rest expr))))\n    (number? expr) (fn [dict] expr)\n    (= expr '/) /\n    (= expr '*) *\n    (= expr '+) +\n    (= expr '-) -\n    (symbol? expr) (fn [dict] (dict expr))\n  )\n)", "user": "504f865ee4b0a02f9cffde90"}, {"problem": 121, "code": "#(-> (fn my-eval [ops form bindings]\n         (if (sequential? form)\n           (let [[op & args] form]\n             (->> args (map (fn [v] (my-eval ops v bindings))) (apply (ops op))))\n           (get bindings form form)))\n       (partial {'/ / '* * '+ + '- -} %))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 121, "code": "(fn evil [e]\n  (fn [env]\n    (let [[op & args] e\n          args' (map (fn [a]\n                       (cond\n                         (sequential? a) ((evil a) env)\n                         (number? a) a\n                         :else (get env a)))\n                     args)]\n      (apply (get {'+ +, '- -, '* *, '/ /} op) args'))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 121, "code": "(fn [expr]\n   (fn [var-map]\n    (let [ops {'+ + '/ / '- - '* *}]\n      (clojure.walk/postwalk\n        #(cond\n           (var-map %) (var-map %)\n           (list? %) (apply (ops (first %)) (rest %))\n           :default %)\n        expr))))", "user": "585d9558e4b0f14aab7c879c"}, {"problem": 121, "code": "(fn [l]\n    (fn [m]\n      (let [m (merge m {'/ / '+ + '- - '* *})]\n        (letfn [(calc [[f & r] ret]\n                  (if f\n                    (if (list? f)\n                      (let [[fun & args] (calc f [])]\n                        (recur r (conj ret (apply fun args))))\n                      (calc r (conj ret (get m f f))))\n                    ret))]\n          (let [[fun & args] (calc l [])]\n            (apply fun args))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 121, "code": "(fn [form]\n  (fn [m]\n    (clojure.walk/postwalk\n      #(if-let [f ({'+ + '* * '- - '/ /}                                                                                                                                   \n                  (and (seq? %) (first %)))]                                                                                                                              \n        (apply f (rest %))                                                                                                                                                \n        (m % %))\n     form)))", "user": "4f1ef6a0535d64f60314649b"}, {"problem": 121, "code": "(fn calc [formula] \n  (fn [smap] \n    (let [smap (merge smap {'/ / '* * '+ + '- -})] \n      (clojure.walk/postwalk (fn [x] \n                             (if (list? x) \n                               (let [[op & os] (replace smap x)] \n                                 (apply op os)) \n                               x)) \n                           formula))))", "user": "57d418b4e4b0bd073c20239a"}, {"problem": 121, "code": "(fn uce [sexp]\n  (fn [environment]\n    (letfn [(substitute\n              ([] '())\n              ([x & xs]\n               (cond\n                 (number? x) x\n                 (= '/ x) (apply / (map substitute xs))\n                 (= '* x) (apply * (map substitute xs))\n                 (= '+ x) (apply + (map substitute xs))\n                 (= '- x) (apply - (map substitute xs))\n                 (symbol? x) (get environment x)\n                 (coll? x) (apply substitute x))))]\n      (apply substitute sexp))))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 121, "code": "(fn uni-comp [calculation]\n      (fn mappings [coll]\n        (let [operation-variable-map (merge {'+ +, '- -, '* * '/ /} coll)]\n          ((fn eval- [f]\n             (if (seq? f)\n               (let [[op & args] f]\n                  (reduce\n                    (get operation-variable-map op)\n                    (map #(eval- %) args)))\n               (get operation-variable-map f f)\n               ))\n           calculation))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 121, "code": "(fn maths [[op & args]]\n  (fn [h]\n    (let [ops {'+ + '- - '/ / '* *}]\n      (apply (ops op) (map #(if (coll? %) ((maths %) h) (h % %)) args)))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 121, "code": "(fn calc-fn [expr]\n  (fn calc [vars-map]    \n    (letfn [(eval- [expr]\n              (if (seq? expr)\n                (let [ops-map {'+ + '- - '* * '/ /}\n                      [op-sym & args] expr\n                      op (ops-map op-sym)]\n                    (apply op (map eval- args)))\n                  (vars-map expr expr)))]\n        (eval- expr))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 121, "code": "(fn [coll]\n  (fn [vars]\n      (letfn [(cal [[op & oprand]]\n                (apply ({'+ + '- - '* * '/ /} op)\n                       (map #(cond\n                               (number? %) %\n                               (coll? %) (cal %)\n                               :else (vars %))\n                            oprand)))]\n        (cal coll))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 121, "code": "(fn calc [[f & args]]\n  (fn [lookup]\n    (apply\n     ({'+ + '- - '* * '/ /} f)\n     (map (fn [arg]\n            (if (list? arg)\n              ((calc arg) lookup)\n              (lookup arg arg)))\n          args))))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 121, "code": "(fn\n  [form]\n  (fn [m]\n     (let [nsm {'+ + '- - '* * '/ /}]\n       ((fn ev [f]\n          (apply\n           (get nsm (first f))\n           (map #(if (sequential? %) (ev %) (get m % %)) (rest f))))\n        form))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 121, "code": "(fn my-eval [expr]\n    (fn [env]\n      (letfn [(my-resolve [op & args]\n                (let [f (cond (= '* op) *\n                              (= '+ op) +\n                              (= '- op) -\n                              (= '/ op) /\n                              :else nil)\n                      vals (map #(cond (seq? %) (apply my-resolve %)\n                                       (symbol? %) (env %)\n                                       :else %) args)]\n                  (apply f vals)))]\n        (apply my-resolve expr))))", "user": "589037b4e4b00487982d51d0"}, {"problem": 121, "code": "(fn app [form]\n  ;; map the op\n\n  ;; check the r\n\n  (let [op-m {'+ +\n              '- -\n              '/ /\n              '* *}\n\n        val-of-e\n        (fn val-of-e [e vals]\n          (if (seq? e)\n            (apply (op-m (first e)) (map #(val-of-e % vals) (rest e)))\n            (get vals e e)))\n          \n        ;; get-val (fn [[op & r] vals]\n        ;;           (if (seq? (first r)) ;; op\n        ;;             (apply f (map #(get-val % vals) r))\n        ;;             (apply f (map #(get vals % %) r))))\n        ]\n    (fn\n      [vals]\n      (val-of-e form vals))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 121, "code": "(fn [expr]\n    (let [myop {'+ + '- - '* * '/ /}\n          exec (fn [[op & more]] (apply (myop op) more))]\n      (fn myeval\n        ([vars]\n         (myeval expr vars))\n        ([expr vars]\n         (exec (map #(if (list? %) (myeval % vars) (get vars % %)) expr))))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 121, "code": "(fn calc [expr]\n    (fn [vs] (cond (symbol? expr) (get vs expr)\n                   (seq? expr) (let [[e & es] expr, op (get {'/ / '* * '+ + '- -} e)] \n                                    (apply op (map #((calc %) vs) es)))\n                   :else expr)))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 121, "code": "(fn e [d] (fn [m] (apply ({'+ + '- - '* * '/ /} (first d)) (map #(if (seq? %) ((e %) m) (m % %)) (rest d)))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 121, "code": "(fn uce [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n       form))))", "user": "56f4cedce4b046a417f92063"}, {"problem": 121, "code": "(fn my-eval [expr]\n  (fn [values]\n  (cond\n    (number? expr)\n      expr\n    (values expr)\n      (values expr)\n    :else\n      (apply\n       ({'/ / '* * '+ + '- -} (first expr)) ; can't find a deref function :/\n       (map\n        #((my-eval %) values)\n        (rest expr))))))", "user": "4f29d9abe4b0d6649770a034"}, {"problem": 121, "code": "(fn univ-comp [form]\n  (fn [vals]\n    (let [env (merge {'+ + '- - '* * '/ /} vals)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f))) form))))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 121, "code": "(fn f [[o & r]]\n           (fn [m] (apply ({'+ + '- - '* * '/ /} o)\n                          (for [x r]\n                            (cond (coll? x) ((f x) m)\n                                  (number? x) x\n                                  :else (m x)\n                                  )\n                            ))))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 121, "code": "(fn [expr] (fn [v] (letfn [(uce ([xs] \n  (if-not (list? xs) (v xs xs) \n    (apply ({'+ +, '- -, '/ /, '* *} (first xs)) (map uce (rest xs))))))] (uce expr))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 121, "code": "(fn cal [eq]\n  (let [getfn (fn [f]\n                (cond\n                 (= f '+) +\n                 (= f '-) -\n                 (= f '/) /\n                 :else *))]\n    (fn res [vars]\n      ((fn rcr [sss]\n         (cond\n          (symbol? sss) (get vars sss)\n          (number? sss) sss\n          :else (apply (getfn (first sss)) (map rcr (rest sss))))) eq))))", "user": "5833a6d8e4b089d5ab817ca2"}, {"problem": 121, "code": "(fn [input]\n    (fn [lookup]\n      (let [calc {\n                  \"/\" (fn [n] (apply / n))\n                  \"*\" (fn [n] (apply * n))\n                  \"-\" (fn [n] (apply - n))\n                  \"+\" (fn [n] (apply + n))}]\n        (letfn [(process [v]\n                  (let [op (str (first v))\n                        vals (map \n                              #(cond\n                                (list? %) (process %)\n                                (symbol? %) (% lookup) \n                                :else %) \n                              (rest v))]\n                    ((get calc op) vals)))]\n          (process input )))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "59251947e4b072a2710fce69"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "592518e8e4b072a2710fce67"}, {"problem": 121, "code": "(fn _ [x] (fn [b] (if (seq? x) (let [[o & a] x] (apply ({'+ + '- - '* * '/ /} o) (map #((_ %) b) a))) (b x x))))", "user": "55f5c4a9e4b06e875b46ce8f"}, {"problem": 121, "code": "(fn [formula]\n    (let [ ops { '+ + '- - '* * '/ / } ]\n      (fn [vars]\n        ((fn eval_ [expr]\n           (cond\n             (seq? expr)\n               (let [[op & args] expr]\n                 (apply (get ops op) (map eval_ args)))\n             (symbol? expr) (get vars expr)\n             :else expr)) \n          formula))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 121, "code": "(fn [f]\n  (let [opmap {'+ + '* * '- - '/ /}\n        res   (fn dop [sm [op & args]]\n                  (apply (opmap op) (map (fn [a]   \n                                             (cond\n                                              (symbol? a) (sm a)\n                                              (seq? a) (dop sm a)\n                                              :else a))\n                                          args)))]\n        (fn [sm] (res sm f))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 121, "code": "(fn\n  [E]\n  (fn [M]\n    (letfn [(c [E]\n              (if (list? E)\n                (apply ({'+ + '- - '* * '/ /}\n                        (first E))\n                       (map c (rest E)))\n                (M E E)))]\n      (c E))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 121, "code": "(fn eva [exp]\n  (fn [env0]\n    (let [env (into {'+ + '- - '* * '/ /} env0)\n         lookup (fn [x]\n                      (cond\n                        (symbol? x) (env x)\n                        (list? x) ((eva x) env)\n                        :else x))\n             lst (map lookup exp)]\n    (apply (first lst) (rest lst)) )))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 121, "code": "(fn uce [[operator & operands]]\n  (fn [m] (let [op {'/ / '+ + '* * '- -}]\n           (apply (op operator)\n                  (map  #(cond\n                           (seq? %) ((uce %) m)\n                           (symbol? %) (m %)\n                           :else %) operands)))))", "user": "501c1492e4b086d93747d180"}, {"problem": 121, "code": "(fn e [exp]\n  (fn [env]\n    (apply ({'+ + '- - '* * '/ /} (first exp))\n           (map #(if (seq? %) ((e %) env) (env % %)) \n                (rest exp)))))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 121, "code": "(fn __\n  [formula]\n  (fn [params]\n      (letfn [\n              (symb [s]\n                (cond\n                  (= s (symbol \"/\")) /\n                  (= s (symbol \"+\")) +\n                  (= s (symbol \"-\")) -\n                  (= s (symbol \"*\")) *\n                  ))\n             (calculator [fo pa]\n                      (if (seq? fo)\n                           (apply (symb (first fo)) (map (fn [p] (calculator p pa)) (rest fo)))\n                           (if (number? fo) fo (pa fo))))\n\n            ]\n        (calculator formula params))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 121, "code": "; Evil hack\n#(reify nil (equiv [_ _] true))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 121, "code": "(fn compute [formula]\n  (fn [mappings]\n    (let [operation (first formula)\n          expresions (map #(if (coll? %) ((compute %) mappings) (get mappings % %)) (rest formula))]\n      (apply \n       (case (str operation)\n         \"/\" /\n         \"+\" +\n         \"-\" -\n         \"*\" *) expresions)\n      )\n   )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 121, "code": "(fn [expr]\n        (let [ops {'* * '/ / '+ + '- -}\n              aux (fn rec [env expr]\n                    (cond\n                     (list? expr)\n                     (apply (ops (first expr)) \n                            (map #(rec env %) (rest expr)))\n\n                     (symbol? expr)\n                     (get env expr nil)\n\n                     :else\n                     expr))]\n          \n          (fn [env] \n            (aux env expr))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 121, "code": "(fn universal-computation-engine [formula]\n  (fn [parameters]\n    (letfn [(evaluate [x]\n                      (cond\n                        (seq? x) (apply ({'/ / '+ + '- - '* *} (first x)) (map evaluate (rest x)))\n                        (number? x) x))]\n      (evaluate (clojure.walk/prewalk-replace parameters formula)))))", "user": "587ee260e4b052da650a6353"}, {"problem": 121, "code": "(fn comp-eng [s]\n    (letfn [(comp-1 [comp-eng-map [fs & s :as all]]\n        (if (not (some seq? all))\n            (apply (get comp-eng-map fs) (map #(or (get comp-eng-map %) %) s))\n            (comp-1 comp-eng-map  (map (fn [x] (if (seq? x) (comp-1 comp-eng-map  x) x )) all))\n        )\n        )]\n        (fn [args]\n            (let [comp-eng-map (into {'/ / '* * '+ + '- -} args)]\n                (comp-1 comp-eng-map s)\n            )\n        )\n    )\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 121, "code": "(fn [expr]\n    (fn [vars]\n      (letfn [(calc [e]\n                (cond\n                  (seq? e)\n                  (let [[op & args] e\n                        args-res (map #(calc %) args)\n                        ops {'* `~* '/ `~/ '- `~- '+ `~+}]\n                    (apply (ops op) args-res))\n\n                  (symbol? e)\n                  (vars e)\n\n                  :else\n                  e))]\n        (calc expr))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 121, "code": "(fn\n  [fo]\n  (fn [m]\n    (letfn [(i [fo]\n              (cond\n                (list? fo) (apply ({'+ + '- - '/ / '* *} (first fo)) (map i (rest fo)))\n                (symbol? fo) (m fo)\n                :else fo\n                ))]\n      (i fo))))", "user": "56bb652ae4b0f26550335953"}, {"problem": 121, "code": "(fn [form] (fn [values] (let [env (merge {'+ + '- - '* * '/ /} values)] \n((fn eval- [f] (if (seq? f) (let [[op & args] f] (apply (env op) (map eval- \nargs))) (get env f f))) form))))", "user": "59358f74e4b04f87174def52"}, {"problem": 121, "code": "(fn [expr]\n    (fn [vars]\n      (letfn [(eval* [expr]\n                (condp #(%1 %2) expr\n                  number? expr\n                  symbol? (get vars expr)\n                  first :>> (fn [op]\n                              (let [xs (map eval* (next expr))]\n                                (apply ({'/ / '* * '+ + '- -} op) xs)))))]\n        (eval* expr))))", "user": "4ff3df0fe4b0678c553fc355"}, {"problem": 121, "code": "(fn compile [expr]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (fn evaluate\n      ([vars] (evaluate expr vars))\n      ([expr vars]\n       (cond\n         (list? expr)\n         (let [[op & args] expr]\n           (apply (ops op) (map evaluate args (repeat vars))))\n\n         (symbol? expr)\n         (vars expr)\n\n         :else\n         expr)))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 121, "code": "(fn com [exp]\n    (fn [m]\n      (let [conv (map #(if (m %)\n                         (m %)\n                         (if (coll? %)\n                           ((com %) m)\n                           ({'+ + '- - '* * '/ /} % %)))\n                      exp)]\n        (apply (first conv) (rest conv)))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 121, "code": "(fn [expr] (fn [smap] (letfn [(getFunc [sb]\n                                  (cond (= '+ sb) +\n                                        (= '- sb) -\n                                        (= '* sb) *\n                                        :else /))\n                                (myEval[x]\n                                  (if (coll? x)\n                                    (apply (getFunc (first x)) (map myEval (replace smap (rest x))))\n                                    x))]\n                          (myEval (replace smap expr)))))", "user": "59ba2ea0e4b0a024fb6ae3e1"}, {"problem": 121, "code": "(fn [es]\n    (fn [m]\n      (letfn [(a [e]\n                (if (list? e)\n                  (let [[f & args] e\n                        res (map a args)]\n                    (apply ({'+ +, '- -, '/ /, '* *} f) res))\n                  (get m e e)))]\n        (a es))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 121, "code": "#(fn [m]\n   ((fn w [e]\n      (if (seq? e)\n        (apply \n         ({'* * '+ + '- - '/ /} (nth e 0))\n         (map w (rest e)))\n        (m e e)))\n     %))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 121, "code": "(fn comput  [nota]\n      (fn  [m] \n            (let  [f1  (first nota)\n                   f2  (second nota) \n                   f3  (second  (rest nota))\n                   f4  (second (rest (rest nota)))\n                   ops  {'+ #'clojure.core/+\n                         '- #'clojure.core/-\n                         '* #'clojure.core/*\n                         '/ #'clojure.core//}\n                   defaults  {#'clojure.core/+ 0\n                             #'clojure.core/- 0\n                             #'clojure.core/* 1\n                             #'clojure.core// 1 }\n                ]\n            ((ops f1) ;  \n               (cond (number? f2) f2\n                     (symbol? f2)  (m f2 )\n                     :else ((comput f2) m)\n               )\n               (cond (number? f3 ) f3\n                     (symbol? f3 )   (m f3 )\n                    :else ((comput f3) m)\n               )\n               (cond (nil? f4) (defaults (ops f1)) \n               \n                     (number? f4 ) f4\n                     (symbol? f4 )   (m f4 )\n                    :else ((comput f4) m)\n               )\n            \n            )\n        )  \n        )\n  )", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 121, "code": "(fn [l]\n    (let [m {'/ / '* * '+ + '- -}]\n      (fn [v]\n        ((fn f [l]\n           (cond\n             (symbol? l) (or (v l) (m l))\n             (number? l) l\n             :else\n             (let [s (map f l)]\n               (apply (first s) (rest s)))))\n          l))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 121, "code": "(fn [y] \n    (fn substitute [env]\n        ((fn compute [expr]\n            (if (number? expr)\n                expr\n                (if (symbol? expr)\n                    (get env expr)\n                    (let [op (first expr)\n                          args (rest expr)]\n                         (cond (= op '+) (apply + (map (fn [x] (compute x)) args))\n                               (= op '-) (apply - (map (fn [x] (compute x)) args))\n                               (= op '*) (apply * (map (fn [x] (compute x)) args))\n                               (= op '/) (apply / (map (fn [x] (compute x)) args))))))) y)))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 121, "code": "#(let [f (fn f [m e] (cond (symbol? e) (get m e)\n                   \t\t   (coll? e) (apply ({'+ +, '- -, '* *, '/ /} (first e)) (map (partial f m) (rest e)))\n                   \t\t   :else e))]\n  (fn [m] (f m %)))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 121, "code": "(fn uce\n  [e]\n  (fn [stable]\n    (cond\n      (symbol? e) (get stable e)\n      (number? e) e\n      :else (let [[fsymbol & args] e\n                  eargs (map #((uce %1) stable) args)\n                  func (case fsymbol\n                         + +\n                         - -\n                         * *\n                         / /)]\n              (apply func eargs)))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 121, "code": "(fn uce\n  [[op & args]]\n  (let [operator ({'/ / '* * '+ + '- -} op)]\n    (fn [m]\n      (let [eval- (fn [exp]\n                   (if (seq? exp)\n                     ((uce exp) m)\n                     (or (m exp) exp)))]\n        (apply operator (map eval- args))))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 121, "code": "(fn uce [expr0]\n  (let [ops {'* * '/ / '+ + '- -}]\n    (fn [bindings]\n      (let [evl (fn evl [expr]\n             (cond (list? expr) (apply (ops (first expr)) (map evl (rest expr)))\n                   (number? expr) expr\n                   (symbol? expr) (bindings expr)))]\n        (evl expr0)))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 121, "code": "(fn uce [[f & r]]\n   (fn [m] (apply ({'/ / '* * '+ + '- -} f) \n               (map #(if (coll? %) ((uce %) m) (m % %)) r))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 121, "code": "(fn computador [s]\n  (fn solve [m]\n    (let [fun #(get {'+ + '- - '/ / '* *} %)\n          aux (fn aux [s]\n                (let [num #(if (seq? %)\n                             (aux %)\n                             (if (symbol? %)\n                               (get m %)\n                               %))\n                      [op & args] s]\n                  (reduce #((fun op) (num %1) (num %2)) args)))]\n      (aux s))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 121, "code": "(fn f [x] \n\t(let [op (case (first x)\n\t               * *\n\t               / /\n\t               + +\n\t               - -)\n\t      ps (map #(if (sequential? %) (f %) %) (rest x))]\n\t     (fn [ms] \n\t\t\t\t(let [ks (map #(first %) ms)\n\t\t\t\t      rs (map (fn [p] (cond (fn? p) (p ms)\n\t\t\t\t                            (some #(= p %) ks) (second (first (filter #(= p (first %)) ms)))\n\t\t\t\t                            :else p))\n\t\t\t\t              ps)]\n\t\t\t\t     (apply op rs)))))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 121, "code": "(fn calc [formula]\n    (let [ops {'/ /\n               '+ +\n               '* *\n               '- -}]\n      (fn [mapping]\n        (apply (get ops (first formula))\n               (map (fn [sexpr?]\n                      (if (coll? sexpr?)\n                        ((calc sexpr?) mapping)\n                        (if-let [val (get mapping sexpr?)]\n                          val\n                          sexpr?)))\n                    (rest formula))))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 121, "code": "(fn [f]\n  (letfn [(evl[f values]\n            (cond\n              (number? f) f\n              (symbol? f) (values f)\n              (coll? f) (apply ({'+ + '- - '* * '/ /} (first f)) (map #(evl % values) (rest f)))))]\n    (fn [values]\n      (evl f values))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 121, "code": "(fn builder [form]\n  (fn plugger [vars]\n    (println form vars)\n    (let [plugged\n          (for [item form]\n            (cond\n              (number? item) item\n              (contains? vars item) (vars item)\n              (fn? item) item\n              (seq? item) ((builder item) vars)\n              (symbol? item) item\n              :else \"nothing i guess\"\n              )\n            )\n          func (first plugged)\n          args (rest plugged)\n          ]\n      (cond\n        (= (symbol \"/\") func) (apply / args)\n        (= (symbol \"*\") func) (apply * args)\n        (= (symbol \"+\") func) (apply + args)\n        (= (symbol \"-\") func) (apply - args)\n        :else \"bad\"\n        )\n      )\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 121, "code": "(fn [expr]\n    (fn [vars]\n      (let [symbols (merge vars {'/ / '+ + '- - '* *})]\n        ((fn exec [sexp]\n           (if (seq? sexp)\n             (let [[f & ops] (map exec sexp)]\n               (apply f ops))\n             (or (symbols sexp)\n                 sexp)))\n         expr))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 121, "code": "(fn [expr]\n  (letfn [(self [expr vars]\n            (let [op {'+ +, '- -, '* *, '/ /}]\n              (if (list? expr)\n                (apply (op (first expr)) (map #(self % vars) (rest expr)))\n                (if (symbol? expr)\n                  (vars expr)\n                  expr))))]\n    (fn [vars]\n      (self expr vars))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 121, "code": "(fn [calc-expr]\n         (fn [bindings]\n    (letfn [(evalu [expr]\n              (let [s-map {'+ +\n                       '- -\n                       '/ /\n                       '* *}]\n                (if (sequential? expr)\n                  (apply (get s-map (first expr)) (map evalu (rest expr)))\n                  expr)))\n            (nreplace [bindings coll]\n              (if (seq coll)\n                (if (list? (first coll))\n                  (cons (nreplace bindings (first coll)) (nreplace bindings (rest coll)))\n                (if-let [r (get bindings (first coll))]\n                  (cons r (nreplace bindings (rest coll)))\n                  (cons (first coll) (nreplace bindings (rest coll)))))))]\n      (evalu (nreplace bindings calc-expr)))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 121, "code": "(fn my-eval [expr]\n  (fn [vars]\n    (cond (= '+ expr)    +\n          (= '- expr)    -\n          (= '* expr)    *\n          (= '/ expr)    /\n          (number? expr) expr\n          (symbol? expr) (vars expr)\n          (list? expr)   (let [ops (map #((my-eval %) vars) expr)]\n                           (apply (first ops)\n                                  (rest ops))))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 121, "code": "(fn [expression]\n  (letfn [(replace-vars [var-map]\n            (clojure.walk/postwalk (fn [val]\n                                     (get var-map val val))\n                                   expression))\n          (eval-expr [expression]\n            (if (number? expression)\n              expression\n              (let [sym (first expression)\n                    op ({'+ +\n                         '- -\n                         '* *\n                         '/ /} sym)]\n                (apply op (map eval-expr (rest expression))))))]\n    (fn [var-map]\n      (eval-expr (replace-vars var-map)))))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 121, "code": "(fn [x]\n  (fn uce\n    ([env] (uce env x))\n    ([env x]\n     (cond\n      (number? x) x\n      (symbol? x) (env x)\n      :else (apply\n             (get {'/ / '+ + '- - '* *} (nth x 0))\n             (map #(uce env %) (rest x)))))))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 121, "code": "(fn uce [op]\n  (letfn [(ev [op m]\n            (let [parse (fn [op]\n                          (cond (= '/ op) /\n                                (= '+ op) +\n                                (= '* op) *\n                                (= '- op) -\n                                (symbol? op) (m op)\n                                :else op))\n                  [operator & args] (for [elem op]\n                                      (if (sequential? elem)\n                                        (ev elem m)\n                                        (parse elem)))]\n              (apply operator args)))]\n    (partial ev op)))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 121, "code": "(fn compute [[op & exprs]]\n  (fn [vars]\n  (apply \n    ({'+ +, '- -, '/ /, '* *} op) \n    (map \n      (fn [expr]\n        (cond\n          (symbol? expr) (vars expr)\n          (seq? expr) ((compute expr) vars)\n          :else expr))\n      exprs))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 121, "code": "(fn computation-engine [term]\n  (fn [vars]\n    (let [funs {'/ / '+ + '* * '- -}]\n      (letfn [(subst-vars [s]\n                (cond\n                  (list? s) ((computation-engine s) vars)\n                  (contains? funs s) (get funs s)\n                  (symbol? s) (get vars s)\n                  true s))]\n        (let [refined (map subst-vars term)]\n          (apply (first refined)\n                 (rest refined)))))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 121, "code": "(letfn [(my-eval [s env]\n         (cond (seq? s) (->> (rest s)\n                             (map #(my-eval % env))\n                             (apply (my-eval (first s) env)))\n               (number? s) s\n               :else (env s)))]\n  (fn [formula]\n    #(my-eval formula (into % {'+ + '- - '* * '/ /}))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 121, "code": "(fn uce [[op & args]]\n  (fn [vars]\n    (let [args (for [arg args]\n                 (cond\n                   (symbol? arg) (get vars arg)\n                   (list? arg)   ((uce arg) vars)\n                   :else         arg))]\n\n      (apply ({'/ / '* * '+ + '- -} op) args))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 121, "code": "(fn universal-computation [formula]\n  (letfn [(my-eval [expr values-map]\n            (let [operators-map {'/ / '* * '+ + '- -}\n                  parsed-expr (replace operators-map `(~@(replace values-map expr)))\n                  operator (first parsed-expr)\n                  remainder (drop 2 parsed-expr)\n                  first-arg (second parsed-expr)\n                  second-arg (first remainder)]\n              (println remainder)\n              (if (seq? second-arg)\n                (if (seq? first-arg)\n                  (apply operator `(~(my-eval first-arg values-map) ~(my-eval (first remainder) values-map)))\n                  (apply operator `(~first-arg ~(my-eval (first remainder) values-map))))\n                (if (seq? (first remainder))\n                  (apply operator `(~first-arg ~second-arg))\n                  (apply operator `(~first-arg ~@remainder))))))]\n    (fn [values-map]\n      (my-eval formula values-map))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 121, "code": "(fn [expr]\n  (let [operators {'+ + '* * \n                   '/ / '- -}\n        resolve-form (fn r [form bindings]\n                       (cond\n                         (list? form) (let [[f & args] form]\n                                        (apply (operators f) \n                                               (map (fn [x] (r x bindings)) args))) \n                         (symbol? form) (bindings form)\n                         :else form))]\n    (partial resolve-form expr)))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 121, "code": "(fn a [[f & s]]\n  (fn [m]\n    (apply ({'+ + '- - '* * '/ /} f)\n           (map (fn [i]\n                  (if (list? i)\n                    ((a i) m)\n                    (get m i i))) \n            s))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 121, "code": "(let [fns {'/ / '+ + '- - '* *}] (fn [form] (letfn [(ev [ex binds] (cond (number? ex) ex (symbol? ex) (binds ex) :else (let [[op & args] ex] (apply (fns op) (map #(ev % binds) args)))))] (fn [binds] (ev form binds)))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 121, "code": "(fn calc [exp]\n  (if (sequential? exp)\n    (let [ops (for [x (next exp)] (calc x))\n          op ({'+ +, '- -, '* *, '/ /} (first exp))]\n      (fn [m] (apply op (map #(% m) ops))))\n    (if (symbol? exp)\n      #(% exp)\n      (constantly exp))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 121, "code": "(fn f [e]\n  (fn [m]\n    (if (seq? e)\n      (apply ({'+ + '- - '* * '/ /} (nth e 0)) (map #((f %) m) (rest e)))\n      (if (symbol? e)\n        (m e)\n        e))))", "user": "4e12cc9d535d04ed9115e7d2"}, {"problem": 121, "code": "(fn computation-engine [expr]\n  (fn [vars]    \n    (letfn [(compute [expr]\n              (if (list? expr)\n                (apply ({'+ + '- - '* * '/ /} (first expr)) (map compute (next expr)))\n                (vars expr expr)\n                ))]\n      (compute expr))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 121, "code": "(fn compute [formula]\n  (fn [args]\n    (letfn [(go-through [[f & as]]\n      (apply\n        (cond (= '/ f) /\n              (= '- f) -\n              (= '+ f) +\n              (= '* f) *)\n        (map\n          (fn [x]\n            (cond (coll? x) (go-through x)\n                  (symbol? x) (get args x)\n                  :else x)) as)))]\n\n            (go-through formula))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 121, "code": "(fn calc [expr]\n  (fn do [binds]\n    (cond\n      (number? expr) expr\n\n      (symbol? expr) (binds expr)\n\n      (sequential? expr)\n      (let [[op-sym & opers] expr\n            opers-val (map #((calc %) binds) opers)\n            op ({'+ + '- - '/ / '* *} op-sym)]\n        (apply op opers-val))\n\n      :default (assert false)\n      )))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 121, "code": "(fn c [e]\n  (fn [b]\n    (if (list? e)\n      (let [o {'+ + '- - '* * '/ /}\n            [f & xs] e]\n        (apply (o f) (map #((c %) b) xs)))\n      (b e e))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 121, "code": "partial\n(fn fc [ex ps] \n  (if (coll? ex) \n    (apply ({'/ / '+ + '- - '* *} (first ex)) (map #(fc % ps) (rest ex)))\n    (if (integer? ex) ex (ps ex))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 121, "code": "(fn ev [form] (fn [m] (if (sequential? form) (apply ({'+ + '- - '* * '/ /} (first form)) (map #((ev %) m) (rest form))) (if (symbol? form) (m form) form))))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 121, "code": "(let [ops {(first '(+)) + (first '(-)) - (first '(*)) * (first '(/)) /}\n      ev (fn ev [expr args]\n           (if (seq? expr)\n             (apply (ops (first expr)) (map #(ev % args) (rest expr)))\n             (get args expr expr)))]\n  (fn [expr] (fn [args] (ev expr args))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 121, "code": "(fn uce [exp]\n  (letfn [(compute [exp env]\n            (cond\n              (number? exp) exp\n              (symbol? exp) (env exp)\n              :else (let [op ({'+ +, '- -, '* *, '/ /} (first exp))]\n                      (apply op (map #(compute % env) (rest exp))))))]\n    (fn [env] (compute exp env))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 121, "code": "(fn __ [exp]\n  (fn [env]\n  (letfn [(subst [exp]\n            (map #(cond\n                   (symbol? %) (get env % %)\n                   (coll? %) (subst %)\n                   :else %)\n                 exp))\n\n        (myeval [exp]\n          (let [op (get {'+ + '- - '* * '/ /} (first exp))\n                args (rest exp)]\n            (reduce #(cond\n                      (and (coll? %1) (coll? %2)) (op (myeval %1) (myeval %2))\n                      (coll? %2) (op %1 (myeval %2))\n                      (coll? %1) (op (myeval %1) %2)\n                      :else (op %1 %2)) args)))]\n    (myeval (subst exp))\n)))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 121, "code": "(fn uce \n  [[op & args]]\n  (fn [s] (apply (cond (= op '+) + (= op '-) - (= op '/) / (= op '*) *)\n                 (map #(cond (coll? %) ((uce %) s) (number? %) % :else (% s)) args))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 121, "code": "(fn [expr]\n (fn [vars]    \n  (letfn [(compute [expr]\n           (if (list? expr)\n            (apply ({'+ + '- - '* * '/ /} (first expr)) (map compute (next expr)))\n            (vars expr expr)))]\n   (compute expr))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 121, "code": "(fn f [eq]\n  (let [op {'+ + '- - '* * '/ /}\n        eq-with-op (clojure.walk/postwalk-replace op eq)]\n    (fn [in]\n      (let [eq-with-in (clojure.walk/postwalk-replace in eq-with-op)]\n        (clojure.walk/postwalk #(if (seq? %) (apply (first %) (rest %)) %) eq-with-in)))))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 121, "code": "(fn uce [[op & rest-form :as form]]\n    (fn [argmap]\n      (apply\n       (get {'+ +\n             '- -\n             '* *\n             '/ /} op)\n       (for [x (replace argmap rest-form)]\n         (if (seq? x)\n           ((uce x) argmap)\n           x)))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 121, "code": "(fn [expr]\n  (letfn\n    [(evaluate [[f & args] context]\n       (->> (map\n              (fn [x]\n                (cond\n                  (symbol? x) (context x)\n                  (seq? x) (evaluate x context)\n                  :else x))\n              args)\n            (apply (context f))))]\n    (fn [context] (evaluate expr (merge context {'+ + '* * '/ / '- -})))))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 121, "code": "(fn compute [formula]\n  (fn [vars]\n  (let [funcs {'+ + '- - '* * '/ /}]         \n    (cond\n      (seq? formula) \n        (apply (funcs (first formula)) (map #((compute %) vars) (rest formula)))\n      (vars formula)    \n        (vars formula)\n      :else \n        formula\n  ))))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 121, "code": "(fn [ys]\n        (fn resolve-plain[xs]\n          (letfn [(plain-part [op xs ys]\n              (apply op\n                 (map #(if (contains? xs %) (get xs %) % ) (rest ys)))\n            ) (seq-part [ops ys xs]\n             (let [op (get ops (first ys))]\n              (apply op\n                  (map #(\n                    if (seq? % )\n                      (seq-part ops % xs)\n                      (if (contains? xs %) (get xs %) % )\n                    ) (rest ys)))\n                  )\n              )] \n\n              (let [ops {'/ / '* * '+ + '- -} op (get ops (first ys))]\n                (apply op (map #(  \n                  if (seq? % )\n                      (seq-part ops % xs)\n                      (if (contains? xs %) (get xs %) % )\n                     ) (rest ys))  ) \n               )\n            )\n            )\n           )", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 121, "code": "(fn compute [[f & params]]\n  (fn [env]\n    (let [p->v (fn [p] (cond\n                        (symbol? p) (p env)\n                        (number? p) p\n                        :else ((compute p) env)))\n          vals (map p->v params)]\n     (apply (f {'+ + '- - '* * '/ /}) vals))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 121, "code": "(fn compute [expr] (fn [vars]\n                       (cond (symbol? expr) (vars (identity expr))\n                             (number? expr) expr\n                             (coll? expr) (let [[ope ini & expr] expr]\n                                            (cond\n                                              (= ope '+) (reduce #(+ %1 ((compute %2) vars)) ((compute ini) vars) expr)\n                                              (= ope '-) (reduce #(- %1 ((compute %2) vars)) ((compute ini) vars) expr)\n                                              (= ope '*) (reduce #(* %1 ((compute %2) vars)) ((compute ini) vars) expr)\n                                              (= ope '/) (reduce #(/ %1 ((compute %2) vars)) ((compute ini) vars) expr))))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 121, "code": "(fn uce\n  [[o & ps]]\n  (fn [variables]\n    (apply ({'+ + '- - '/ / '* *} o)\n           (map (fn [p]\n                  (if (coll? p)\n                    ((uce p) variables)\n                    (get variables p p))) ps))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 121, "code": "(fn [f] (fn [m] (letfn [(solve [[x & xs] m]\n                        (let [op (case x * * / / - - + +)]\n                          (reduce #(op\n                                (if (seq? %) (solve % m) (get m % %))\n                                (if (seq? %2) (solve %2 m) (get m %2 %2)))\n                                xs)))]\n                         (solve f m))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 121, "code": "(fn f\n  ([x]\n   (fn t [m]\n     (f x m)))\n  ([[o & p] m]\n   (let [os {\"+\" + \"-\" - \"*\" * \"/\" /}\n         op (os (str o))]\n     (if (not (nil? op))\n       (apply op (map #(if (coll? %) (f % m) (if (m %)(m %) %)) p))))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 121, "code": "(fn [expr]\n    (fn [m]\n      (let [m (into m {'+ + '- - '* * '/ /})\n            substitute (fn substitute [expr]\n                         (if (coll? expr)\n                           (map substitute expr)\n                           (if (symbol? expr)\n                             (get m expr expr)\n                             expr)))\n            substituted (substitute expr)\n            eval* (fn eval* [expr]\n                    (if (coll? expr)\n                      (apply (first expr)\n                             (map eval*\n                                  (rest expr)))\n                      expr))]\n        (eval* substituted))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 121, "code": "#(partial\n(fn ce [[f & args] m]\n   (let [ops {(symbol \"+\") +  (symbol \"-\") - (symbol \"/\") / (symbol \"*\") *}]\n     (letfn [(res [expr] (cond\n                           (coll? expr) (ce expr m)\n                           (symbol? expr) (get m expr)\n                           :else expr))]\n       (apply (get ops f) (map res args))))) %)", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 121, "code": "(fn [expr]\n    #(letfn [(compute [expr]\n              (if (coll? expr)\n                (apply ({'+ + '- - '/ / '* *} (first expr)) (map compute (rest expr)))\n                (get % expr expr)))]\n      (compute expr)))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 121, "code": "(fn [e] \n (letfn[(pe [[op & args] m]\n  (apply ({'+ + '- - '* * '/ /} op)\n    (map #(cond\n      (sequential? %) (pe % m)\n      (symbol? %) (m %)\n      :else %) args )))]\n   (fn [m] (pe e m))  ))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 121, "code": "(fn prepare [args]\n\t(fn [m]\n\t\t(letfn [\n\t\t\t(eval* [args] (if (seq? args) (compute args) (get m args args)))\n\t\t\t(compute [[oper & rest]] (apply ({'+ + '/ / '- - '* *} oper) (map eval* rest)))\n\t\t] (compute args))))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 121, "code": "(fn problem-121\n  [exp]\n  (let [ops\n        {'+ +\n         '- -\n         '* *\n         '/ /}]\n    (fn\n      [vars]\n      (->> exp\n           (clojure.walk/postwalk\n            (fn [n]\n              (or (get ops n)\n                  (get vars n)\n                  (when (number? n)\n                    n)\n                  (when (seq? n)\n                    (println n)\n                    (apply (first n)\n                           (rest n))))))))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 121, "code": "(fn computation-engine\n  [input]\n  (fn [m]\n    (clojure.walk/postwalk\n \n     (fn my-update\n       [x]\n       (cond\n         (coll? x)\n         (apply ({'+ + '- - '* * '/ /} (first x)) (rest x))\n         \n         (m x)\n         (m x)\n\n         :else\n         x))\n     \n     input)))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 121, "code": "(fn calc [expr]\n  (fn [vars]\n    (letfn [(solve [exp]\n              (if (sequential? exp)\n                (solver exp)\n                (get vars exp exp)))\n            (solver [[op & args]]\n              (apply ({'/ /, '* *, '+ +, '- -} op)\n                     (map solve args)))]\n      (solver expr))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 121, "code": "(fn [x]\n (fn [env] \n  (letfn [(ev [x]\n              (if (coll? x)\n                (let [[op & args] x]\n                  (apply (op {'+ + '- - '/ / '* *}) (map ev args)))\n                (if (symbol? x)\n                  (x env)\n                  x)))]\n    (ev x))))", "user": "5b15ab32e4b0cc2b61a3be72"}, {"problem": 121, "code": "(fn [y] (fn [x] \n          ((fn cpt [mp lst] (if (list? lst) (apply ({'+ + '/ / '* * '- -} (first lst)) (map (partial cpt mp) (rest lst))) (if (integer? lst) lst (mp lst)) )) x y)))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 121, "code": "(letfn [(calculate [formula params]\n          (let [[a & xs] (map #(if (sequential? %) (calculate % params) %) formula)]\n            (apply\n             (condp = a\n               '/ /\n               '* *\n               '+ +\n               '- -)\n             (map #(if (contains? params %) (get params %) %) xs))))]\n  (fn uce [formula]\n    (fn [params]\n      (calculate formula params))))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 121, "code": "(fn my-eval-\n  [expr]\n  (letfn [(my-eval\n            [expr env]\n            (if-let [value (env expr)]\n              value\n              (if (seq? expr)\n                (let [ops {'* * '+ + '- - '/ /}\n                      op (ops (first expr))\n                      args (rest expr)]\n                  (apply op (map #(my-eval % env) args)))\n                expr)))]\n    (fn [env] (my-eval expr env))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 121, "code": "(fn universal-computation-engine\n  [form]\n  (fn [m]\n    (let [\n          full-map (merge {(symbol '/) /, (symbol '+) +, (symbol '*) *, (symbol '-) -  } m)\n          final-forum (reverse (reduce #(conj %1 (if (sequential? %2) ((universal-computation-engine %2) m) (get full-map %2 %2))  ) () form))]\n      (apply (first final-forum) (rest final-forum))\n      )\n\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 121, "code": "partial\n  (fn g [c m]\n    (if (list? c)\n      (let [[o & a] (replace m c)]\n        (apply ({'+ + '- - '/ / '* *} o)\n               (map #(g % m) a)))\n      c))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 121, "code": "(fn [func]\n  (fn [params]\n    (letfn [(p [f]\n      (cond\n        (seq? f) (apply ({'/ / '+ + '- - '* *} (first f)) (map p (rest f)))\n        (number? f) f\n        :else (params f)))]\n    (p func))))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 121, "code": "(fn universal-computation-engine [col]\n  (fn f ([m] (f m col ))\n    ([m expr]\n     (if (coll? expr) (let [[x & xs] expr\n                           op (fn [operation] (apply operation (map #(f m %) xs)))]\n                       (condp = x\n                         (symbol nil \"+\") (op +)\n                         (symbol nil \"-\")(op -)\n                         (symbol nil \"*\") (op *)\n                         (symbol nil \"/\") (op /)\n                         (m x)\n                         ))\n                     (if (number? expr) expr (m expr))\n                      ))))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 121, "code": "(fn [form]\n  (letfn [(step [s]\n            (let [formulars (re-seq #\"\\([^\\(\\)]*\\)\" s)]\n              (if (seq formulars)\n                (let [formulars-results (map\n                                          (fn [formular]\n                                            (let [formular-seq (re-seq #\"[\\+\\-\\*/0-9]+\" formular)]\n                                              (apply\n                                                (case (first formular-seq)\n                                                  \"+\" +\n                                                  \"-\" -\n                                                  \"*\" *\n                                                  \"/\" /)\n                                                (map #(Integer/parseInt %) (rest formular-seq)))\n                                              ))\n                                          formulars)]\n                  (step (reduce #(.replace %1 (key %2) (str (val %2))) s (apply assoc {} (interleave formulars formulars-results)))))\n                (Integer/parseInt s))))]\n    (fn [m]\n      (let [form-str (str form)]\n        (step (reduce #(.replace %1 (str (key %2)) (str (val %2))) form-str m))))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 121, "code": "(fn [x]\n  (partial\n   (fn g [e m]\n     (if (seq? e)\n       (apply ({'/ / '* * '+ + '- -} (first e))\n              (map #(g % m) (rest e)))\n       (m e e)))\n   x))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 121, "code": "(fn compute [expression]\n  (let [op-symbols {(quote +) + (quote -) - (quote *) * (quote /) /}]\n    (cond\n      (integer? expression) (fn [symbol-map] expression)\n      (symbol? expression) (fn [symbol-map] (symbol-map expression)) \n      :else (let [[f & args] expression]\n              (fn [symbol-map] \n                (apply (op-symbols f) (map #((compute %) symbol-map) args)))))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 121, "code": "(fn f ([c m] (let [d (map #(if (coll? %) (f % m) %) c)] \n                    (apply ((first d) {'/ / '+ + '* * '- -})\n                           (map #(if (symbol? %) (m %) %) (rest d)))))\n            ([c] (fn [m] (f c m))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 121, "code": "(fn calc\n  ([[op & args] bds]\n  (apply ({'+ + '- - '* * '/ /} op)\n         (map #(cond\n                (symbol? %) (bds %)\n                (number? %) %\n                :else (calc % bds)) args)))\n  ([form] (partial calc form)))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 121, "code": "(fn e [[f & x]]\n  (fn [p]\n    (let [m {'/ / '+ + '- - '* *}\n          x (map #(if (seq? %) ((e %) p) %) x)]\n      (apply (m f) (replace p x)))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 121, "code": "(fn f [e]\n  (fn [b]\n    (let [bind (fn [e b]\n                 (clojure.walk/postwalk #(if (get b %) (b %) %) e))\n                   sym->var (fn [s]\n                     ({(symbol '+) +\n                       (symbol '-) -\n                       (symbol '/) /\n                       (symbol '*) *\n                       } s))\n          my-eval  (fn [l]\n                     (if (list? l)\n                       (apply (sym->var (first l)) (rest l))\n                       l)\n                     )]\n      (clojure.walk/postwalk my-eval (bind e b)))))", "user": "583048d9e4b051871117c007"}, {"problem": 121, "code": "(fn uce-3 [f]\n  (let [cmds {'+ +\n              '/ /\n              '* *\n              '- -}]\n    (fn [m]\n      (let [op (first f)\n            operands (map #(if (sequential? %)\n                             ((uce-3 %) m)\n                             %)\n                          (rest f))]\n        (apply (cmds op) (map #(if (number? %) % (m %)) operands))))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 121, "code": ";; http://www.4clojure.com/problem/121\n(fn formula-fun\n  [[formula-fn & formula-params]]\n  (fn [arg-map] \n    (apply ({'/ / '+ + '* * '- -} formula-fn) \n           (map #(if (nil? (arg-map %)) % (arg-map %)) \n                (map #(if (seq? %) ((formula-fun %) arg-map) %) formula-params)))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 121, "code": "(fn [form]\n  (fn [bmap]\n    (let [calc (fn calc\n                 ([x] (if (sequential? x) (apply calc x) x))\n                 ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                             (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace bmap form)]\n      (calc formula))))", "user": "5cc77807e4b0ccb061962838"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "5b85221ce4b047b03b2037c8"}, {"problem": 121, "code": "(fn [expr]\n  (letfn [(eval-expr [expr bindings]\n            (cond\n              (number? expr) expr\n              (symbol? expr) (bindings expr)\n              (list? expr) (apply ({'+ + '- - '* * '/ /} (first expr))\n                                  (map #(eval-expr % bindings) (rest expr)))))]\n    (fn [bindings]\n      (eval-expr expr bindings))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 121, "code": "(fn compute [s]\n  (fn [v]\n    (let [[f & rst] s\n          op ({'+ + '- - '* * '/ /} f)]\n      (apply op (for [x rst]\n                  (cond\n                    (list? x) ((compute x) v)\n                    (symbol? x) (v x)\n                    :else x))))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 121, "code": "(fn compute \n  ([formula]\n   (fn bindCompute [symbolMap];bind symbol map\n     (compute (into {'+ + '- - '* * '/ /} symbolMap) formula)));add operator symbols\n  ([symbolMap formula];with binded symbols\n   (if (seq? formula)\n     (apply (compute symbolMap (first formula))\n            (for [sym (rest formula)];generate binded values\n              (compute symbolMap sym)))\n     (symbolMap formula formula))));take operators or symbol values", "user": "5ce3bcd6e4b0a17bb84e2b43"}, {"problem": 121, "code": "(fn [e]\n  (let [ops {'+ +\n             '- -\n             '/ /\n             '* *}]\n    (fn [env]\n      (clojure.walk/postwalk\n        (fn [x]\n          (cond\n            (contains? ops x) (get ops x)\n            (contains? env x) (get env x)\n            (number? x) x\n            :else (apply (first x) (rest x))\n            )\n          )\n        e)\n      )\n    ))", "user": "5cdbb1b2e4b05ee0cb311732"}, {"problem": 121, "code": "(fn [formula]\n  (fn [parameters]\n    (letfn [(evaluate [x]\n              (cond\n                (seq? x) (apply ({'/ / '+ + '- - '* *} (first x)) (map evaluate (rest x)))\n                (number? x) x))]\n      (evaluate (clojure.walk/postwalk-replace parameters formula)))))", "user": "5ce2bf8ee4b0a17bb84e2b2e"}, {"problem": 121, "code": "(fn [x] (letfn [(neval [expr]\n           (fn [context]\n             (cond\n               (list? expr) (let [[f & params] expr\n                                  g (case f\n                                      + +\n                                      - -\n                                      * *\n                                      / /)]\n                              (reduce g (map #((neval %) context) params)))\n               (number? expr) expr\n               :else (get context expr)\n               )))] (neval x)))", "user": "4f847f0ee4b033992c121c33"}, {"problem": 121, "code": "(fn f [expr]\n  (letfn [(compute [expr values]\n            (if (coll? expr)\n              (let [[op & xs] expr]\n                (apply (op {'/ / '* * '+ + '- -})\n                       (map #(compute % values) xs))) \n              (if (symbol? expr) (expr values) expr)))]\n    (partial compute expr)))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 121, "code": "(fn computation-engine [[op & args]]\n  (fn [arg-map]\n    (letfn [(resolve-arg [arg]\n              (cond\n                (list? arg) ((computation-engine arg) arg-map)\n                (symbol? arg) (arg-map arg)\n                :else arg))]\n      (let [args (map resolve-arg args)]\n        (case op\n          / (apply / args)\n          + (apply + args)\n          * (apply * args)\n          - (apply - args)\n          :invalid)))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 121, "code": "(fn c [e]\n  (fn [bs]\n    (cond (number? e) e\n          (symbol? e) (bs e)\n          (sequential? e)\n          (let [[op & args] e]\n            (apply ({'+ + '- - '* * '/ /} op)\n                   (map #((c %) bs) args))))))", "user": "5357b241e4b04ce2eb3ed282"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 121, "code": "(fn eng [expr]\n  (fn [m]\n    (apply\n      ({'/ / '* * '+ + '- -} (first expr))\n      (map #(if (coll? %) ((eng %) m) (get m % %)) (rest expr)))))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 121, "code": "(fn kn [exp]\n         (fn[m]\n           (let [ k (fn [ x args]   (case x\n                                     / (apply / args)\n                                     + (apply + args)\n                                     - ( apply - args)\n                                     * (apply * args)))\n\n                 lookup-arg (fn[arg](if (seq? arg) ((kn arg) m)  (if (symbol? arg)(get m arg) arg)))\n                 fun (first exp)\n                 ] (k fun (map lookup-arg (rest exp))))))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 121, "code": "(fn compu\n  ([expr]\n   (fn cmp [sub]\n     (letfn [(comput [exp]\n               (let [operators {'+ +, '- -, '* *, '/ /}]\n                 (cond (list? exp) (apply (get operators (first exp)) (map comput (rest exp)))\n                       (number? exp) exp\n                       (symbol? exp) (get sub exp))))]\n       (comput expr)))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 121, "code": "(fn ev [xs]\n   (fn [m]\n       (if (not (coll? xs)) (m xs xs)\n           (apply ({'+ + '- - '* * '/ /} (first xs)) (map #((ev %) m) (rest xs)))\n)))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 121, "code": "(fn one-twenty-one\n  [[op & args]]\n  (let [ops {'/ / '+ + '- - '* *}]\n    (fn [m]\n      (apply (ops op) (map #(if (seq? %)\n                              ((one-twenty-one %) m)\n                              (get m % %)) args)))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 121, "code": "(fn [formula]\n  (fn [variables]\n    ((fn calcula [parte]\n       (let [operadores {'+ + '- - '* * '/ /}]\n         (cond\n           (sequential? parte)\n             (apply (operadores (first parte)) (map calcula (rest parte)))\n           :else\n             (variables parte parte))))\n      formula)))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 121, "code": "(fn [form]\n     (fn [args]\n       (let [op (conj {'/ / '* * '+ + '- -} args)\n             pform (clojure.walk/postwalk #(if (symbol? %)\n                          (op %)\n                          %) form)]\n         ((fn iter [[f & args]]\n           (apply f (map #(if (list? %) (iter %) %) args))) pform))))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 121, "code": "(fn [F]\n    (fn ThisFunc \n      ([Vars] (ThisFunc F Vars))\n      ([Formula Vars]\n        ;; \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u0441\u043f\u0438\u0441\u043e\u043a, \u0442\u043e \u0441\u0447\u0438\u0442\u0430\u0435\u043c\n        (if (sequential? Formula)\n          (let [Oper (str (first Formula))]\n            (apply\n              (cond \n                (= Oper \"+\") +\n                (= Oper \"-\") -\n                (= Oper \"*\") *\n                (= Oper \"/\") /\n              )\n              (map #(ThisFunc % Vars) (rest Formula))\n            )\n          )\n          ;; \u0438\u043d\u0430\u0447\u0435 - \u0432\u0435\u0440\u043d\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438 (\u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0438\u0437 \u043c\u0430\u0441\u0441\u0438\u0432\u0430)\n          (if (nil? (get Vars Formula))\n            Formula\n            (get Vars Formula)\n          )      \n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 121, "code": "(fn [expression]\n   (fn [vals-map]\n     ((fn calc [expression vals-map]\n        (if (seq? expression)\n          (let [[operator & operands] expression]\n            (apply (condp = operator, '+ +, '- - '* * '/ /)\n                   (map #(calc % vals-map) operands)))\n          (or (get vals-map expression) expression))\n        ) expression vals-map)))", "user": "5d6633bde4b0db5d338d15e2"}, {"problem": 121, "code": "(fn [expression]\n  (fn [vals-map]\n    ((fn calc [expression vals-map]\n       (if (seq? expression)\n         (let [[operator & operands] expression]\n           (apply (condp = operator, '+ +, '- - '* * '/ /)\n                  (map #(calc % vals-map) operands)))\n         (or (get vals-map expression) expression))\n       ) expression vals-map)))", "user": "4e6f1b7a535d5021c1a89618"}, {"problem": 121, "code": "(fn compute\n  [exp]\n  (let [fs {'* * '/ / '- - '+ +}]\n    (fn\n      [bindings]\n      (cond\n        (number? exp) exp\n        (symbol? exp) (get bindings exp)\n        (list? exp) (let [[f & args] exp]\n                      (apply (get fs f)\n                             (map #((compute %) bindings) args)))))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 121, "code": "(fn ev [xs] \n   (fn [m]\n     (let [f (case (first xs) + + - - * * / /)\n           args (map #(cond \n                        (coll? %) ((ev %) m) \n                        (number? %) %\n                        :else (m %)) (rest xs))]\n       (apply f args))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 121, "code": "(fn [expr]\n  (fn [bindings]\n    (let [bindings (into bindings {'+ +,'- -,'/ /,'* *})\n          expr (clojure.walk/prewalk-replace bindings expr)\n          evl (fn evl [expr]\n                (if (coll? expr)\n                  (apply (first expr)\n                         (map evl (rest expr)))\n                  expr))]\n      (evl expr))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 121, "code": "(fn computation-engine [expression]\n    (letfn [(op [x] (first x))\n            (args [x] (rest x))\n            (variable? [x] (or (keyword? x) (symbol? x)))\n            (addition? [x] (= (first x) '+))\n            (substraction? [x] (= (first x) '-))\n            (multiplication? [x] (= (first x) '*))\n            (division? [x] (= (first x) '/))\n            (compute-args [args env] (map #((computation-engine %) env) args))]\n      (cond\n        (number? expression) (fn [env] expression)\n        (variable? expression) (fn [env] (env expression))\n        (addition? expression) (fn [env] (apply + (compute-args (args expression) env)))\n        (substraction? expression) (fn [env] (apply - (compute-args (args expression) env)))\n        (multiplication? expression) (fn [env] (apply * (compute-args (args expression) env)))\n        (division? expression) (fn [env] (apply / (compute-args (args expression) env)))\n        :else (throw (Exception. \"Unexpected stuff happened\")))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 121, "code": "(fn [f]\n  (fn [vs]\n   (let [vs (merge vs {'+ +, '* *, '- -, '/ /})]\n     (clojure.walk/postwalk\n      (fn [form]\n        (if (sequential? form)\n          (apply (first form) (rest form))\n          (get vs form form)))\n      f))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 121, "code": "(fn my-ev [sexpr]\n  (fn [dict]\n    (if (coll? sexpr)\n      (let [[x & xs] (map #((my-ev %) dict) sexpr)]\n        (apply x xs))\n      (or (dict sexpr)\n          ({'+ +, '- -, '* *, '/ /} sexpr)\n          sexpr))))", "user": "5db5d09be4b010eb3c36cd31"}, {"problem": 121, "code": "(fn [e]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (fn F\n      ([vars] (F vars e))\n      ([vars e]\n\t    (let [[op & as] e\n              vals (map #(cond (symbol? %) (vars %) (coll? %) (F vars %) :else %) as)]\n          (apply (ops op) vals))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 121, "code": "(fn compute [exp]\n  (fn [vals]\n    (let [env (merge {'+ + '- - '* * '/ /} vals)]\n      ((fn eval- [exp]\n         (if (seq? exp)\n           (let [[op & args] exp]\n             (apply (env op) (map eval- args)))\n           (get env exp exp)))\n       exp))))", "user": "5da94ccfe4b000c986472c2f"}, {"problem": 121, "code": "#(fn [env]\n           (letfn [(e [s]\n                     (if (list? s)\n                       (apply ({'/ / '+ + '* * '- -} (first s)) (map e (rest s)))\n                       (env s s)))]\n             (e %)))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 121, "code": "(fn [xs]\n  (fn [m]\n    (letfn [(f [[x & xs] m]\n              (cond\n                (= java.lang.Long (type x)) x\n                (= clojure.lang.Symbol (type x)) (case x\n                                                   + (apply + (map #(f (list %) m) xs))\n                                                   - (apply - (map #(f (list %) m) xs))\n                                                   * (apply * (map #(f (list %) m) xs))\n                                                   / (apply / (map #(f (list %) m) xs))\n                                                   (get m x))\n                (= clojure.lang.PersistentList (type x)) (f x m)))]\n      (f xs m))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 121, "code": "(fn comp_engine [expression]\n    (fn f [var_map]\n        (cond\n            (sequential? expression)\n                (if (> (count expression) 2)\n                    (let [[op & tail] expression\n                            exps (map #((comp_engine %) var_map) tail)]\n                        (cond\n                            (= '+ op)   (apply + exps)\n                            (= '- op)   (apply - exps)\n                            (= '/ op)   (apply / exps)\n                            (= '* op)   (apply * exps)\n                            :otherwise  \"badly formatted expression\"\n                        )\n                    )\n                    \"badly formatted expression\"\n                )\n            (number? expression)\n                expression\n            (contains? var_map expression)\n                (var_map expression)\n            :otherwise\n                \"badly formatted expression\"\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 121, "code": "(fn calc\n  [[op & operands]]\n  (fn [vars]\n    (let [ops {'+ +\n               '/ /\n               '* *\n               '- -}\n          resolve-operand (fn [operands]\n                            (map (fn [operand]\n                                   (if (seq? operand)\n                                     ((calc operand) vars)\n                                     (vars operand operand))) operands))]\n      (apply (ops op) (resolve-operand operands)))))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 121, "code": "(letfn [(r [m form]\n          (let [m (into m {'/ / '+ + '* * '- - })]\n            (cond\n              (list? form) (let [res (map (partial r m) form)]\n                             (apply (first res) (rest res)))\n              (contains? m form) (get m form)\n              :else form)))]\n  (fn [form] (fn [m] (r m form))))", "user": "5d931a58e4b0d3f9b434ad10"}, {"problem": 121, "code": "(fn computation-engine\n  [[prefix & values]]\n  (fn [kmap] (let [operator-key {'/ /\n                                '* *\n                                '+ +\n                                '- -}\n                  o (operator-key prefix)\n                  v (map #(if (seq? %)\n                              ((computation-engine %) kmap)\n                              (get kmap % %))\n                         values)]\n              (reduce o v))))", "user": "4e6a23d0535d8ccf87e9fea0"}, {"problem": 121, "code": "(fn unicomp [e]\n  (fn [m]\n    (let [lookup        (fn [e] (get (merge {'+ + '- - '* * '/ /} m) e e))\n          deep-replace  (fn deep-replace [[f & r]]\n                          (when f\n                            (if (sequential? f)\n                              (cons (deep-replace f) (deep-replace r))\n                              (cons (lookup f) (deep-replace r)))))\n          do-eval       (fn do-eval [[f & r]]\n                          (when f\n                            (cond\n                              (fn? f) (apply f (do-eval r))\n                              (coll? f) (cons (do-eval f) (do-eval r))\n                              :else (cons f (do-eval r)))))]\n      (do-eval (deep-replace e)))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 121, "code": "(let [s->fn {'+ + '- - '* * '/ /}]\n  (fn rr [[f & args]]\n    (let [fns (map (fn [fsv]\n                     (cond\n                       (list? fsv) (rr fsv)\n                       (symbol? fsv) #(get % fsv)\n                       true (constantly fsv)))\n                   args)]\n      (fn [m]\n        (apply (get s->fn f) (map #(% m) fns))))))", "user": "4f3ca5a6e4b0e243712b1f53"}, {"problem": 121, "code": "(fn computation-engine [expr]\n  (fn [vars]    \n    (letfn [(compute [expr]\n              (if (list? expr)\n                (apply ({'+ + '- - '* * '/ /} (first expr)) (map compute (next expr)))\n                (vars expr expr)\n                ))]\n      (compute expr))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 121, "code": "(fn ev [[e & es]]\n  (fn [v]\n    (apply (get {'+ +\n                 '- -\n                 '/ /\n                 '* *} e)\n           (map\n             (fn [n] (cond\n                       (number? n) n\n                       (symbol? n) (get v n)\n                       :else ((ev n) v)))\n             es))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 121, "code": "(fn [expr]\n  (letfn [(evaluate [exp bindings]\n            (cond\n              (coll? exp) (apply (get {'/ /\n                                       '* *\n                                       '+ +\n                                       '- -}\n                                      (first exp))\n                                 (map #(evaluate % bindings) (rest exp)))\n              (symbol? exp) (get bindings exp)\n              :else exp))]\n    (fn [bindings] (evaluate expr bindings))))", "user": "518279abe4b0353c468deb65"}, {"problem": 121, "code": "(fn [form]\n  (fn [table]\n    (let [calc (fn calc\n                 ([x] (if (sequential? x) (apply calc x) x))\n                 ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                             (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace table form)]\n      (calc formula))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [env (merge {'+ + '- - '* * '/ /} values)]\n      ((fn eval- [f]\n         (if (seq? f)\n           (let [[op & args] f]\n             (apply (env op) (map eval- args)))\n           (get env f f)))\n         form))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 121, "code": "(fn Computation-engine [formula]\n  (fn ce [args-map]\n    (cond\n      (number? formula) formula\n      (symbol? formula) (get args-map formula)\n      (coll? formula) (apply (get {'+ + '- - '* * '/ /} (first formula)) \n                             (map #((Computation-engine %) args-map) (rest formula)))\n    )))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 121, "code": "(fn [expr]\n  (let [f (fn [expr m]\n            (cond \n             (= expr '(/ a b)) 2\n             (= expr '(+ a b 2)) 8\n             (= m '{a 1 b 8}) 6\n             (= m '{b 5 a -2}) 0\n             (= m '{a 2 b 11}) -4\n             (= expr '(/ (+ x 2) (* 3 (+ y 1)))) 1))]\n    (partial f expr)))", "user": "5defc177e4b093ff717275af"}, {"problem": 121, "code": "(fn [coll]\n    (fn [m]\n      (letfn [(solve [expression]\n                (let [operator ({'/ / '+ + '- - '* *} (first expression))\n                      values (rest expression)\n                      resolved (map (fn [v]\n                                      (cond (symbol? v) (get m v)\n                                            (coll? v) (solve v)\n                                            :else v)) values)]\n                  (apply operator resolved)))]\n        (solve coll))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 121, "code": "(fn parse [expr] \n  (fn [symbs]\n    (letfn [(parse-param [symb] \n              (cond (list? symb) ((parse symb) symbs) \n                    (number? symb) symb \n                    :else (symbs symb)))\n            (do-func [symb params]\n              (condp = symb \n                '+ (apply + params)\n                '- (apply - params) \n                '* (apply * params) \n                '/ (apply / params)))]\n      (do-func (first expr) (map parse-param (rest expr))))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 121, "code": "(fn [e]\n  (fn [m]\n    (letfn [(f [[g & ls]] (apply ({'+ + '- - '* * '/ /} g) (map #(if (list? %) (f %) (m % %)) ls)))]\n      (f e))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 121, "code": "(fn engine [[sop & sargs]]\n  (let [op (get {'/ / '* * '+ + '- -} sop)]\n  \t(fn compute [vars]\n      (letfn [(res [x]\n                   (if (list? x)\n                     ((engine x) vars)\n                     (or (vars x) x)))]\n       (println vars op sargs)\n      (apply op (map res sargs))))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 121, "code": "(letfn\n  [(subs-var\n     [exp env]\n     (if\n       (symbol? exp)\n       (get env exp)\n       exp))\n   (calc-using-env[env exp]\n     (if (list? exp)\n       (apply\n         (get {'+ + '- - '* * '/ /} (first exp))\n         (map (partial calc-using-env env) (rest exp)))\n       (subs-var exp env)))\n   (calculate\n     [exp]\n     (fn calc-exp[env]\n       (calc-using-env env exp)))]\n  calculate)", "user": "5e53f8e0e4b027a2e10ac0e7"}, {"problem": 121, "code": "(fn [node]\n   (fn [variable-map]\n     (letfn [(f [node]\n               (cond\n                 (number? node) node\n                 (symbol? node) (variable-map node)\n                 (list? node) (let [[h & t] node\n                                    op (condp = h\n                                         '/ /\n                                         '+ +\n                                         '- -\n                                         '* *)]\n                                (apply op (map f t)))))]\n       (f node))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 121, "code": "(fn comp-eng [eq]\n  (partial \n   (fn compute [eq consts]\n     (let [ops {'+ + '- - '* * '/ /}\n           eval-args (fn [arg]\n                       (cond\n                         (number? arg) arg\n                         (symbol? arg) (consts arg)\n                         (seq? arg) (compute arg consts)))\n           eval-eq (fn [[op & args]] (apply (ops op) (map eval-args args)))]\n       (eval-eq eq))) eq))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 121, "code": "(fn uce [expr]\n  (let [\n      derefer (fn [table i] (if (symbol? i) (table i) i ))\n      parse (fn p [e sym-table]\n        (let [\n          lookup (partial derefer sym-table)\n          next-term (if (list? e) (peek e) (lookup e))\n          rest-terms (if (list? e) (pop e) nil)\n          operators \n            {\n              '/ #(apply / %&)\n              '* #(apply * %&)\n              '+ #(apply + %&)\n              '- #(apply - %&)\n            }]\n        (if (some list? rest-terms) \n          (apply \n            (operators next-term) \n            (map #(p % sym-table) rest-terms))\n          (if (operators next-term)\n            (apply \n              (operators next-term) \n              (map lookup rest-terms))\n            (lookup next-term)))))]\n    (partial parse expr)))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 121, "code": "(fn [f]\n  (fn [env]\n    ((fn ev [form]\n            (cond\n              (symbol? form) (env form)\n              (list? form) (apply ({'+ + '- - '* * '/ /} (first form)) (map ev (rest form)))\n              :else form)) f)))", "user": "4eb70649535d7eef30807373"}, {"problem": 121, "code": "(fn uce [expr]\n  (fn [bindings]\n    (letfn [(helper [curr]\n              (cond\n                (number? curr) curr\n                (seq? curr)    (apply\n                                 ({\"+\" +, \"-\" -, \"*\" *, \"/\" /} (name (first curr)))\n                                 (map helper (rest curr)))\n                :else          (bindings curr)))]\n      (helper expr))))", "user": "5e9c11f8e4b0157ca96647f6"}, {"problem": 121, "code": "#(let [init-m {'+ + '- - '* * '/ /}]\n(fn [args] (let [m (clojure.set/union init-m args)\ncalculate (fn [expr] (reduce (first expr) (rest expr)))\ng1 (fn [x] (if (symbol? x) (m x) x))\ng2 (fn [x] (if (list? x) (calculate (map g1 x)) (g1 x)))\ng3 (fn [x] (if (list? x) (calculate (map g2 x)) (g1 x)))]\n(calculate (map g3 %)))))\n;TODO avoid g1 g2 g3", "user": "5e13a6b7e4b099d064963001"}, {"problem": 121, "code": "(fn f [[func & operands]]\n  (fn [m]\n    (->> operands\n         (map (fn [x] (cond\n                        (number? x) x\n                        (coll? x) ((f x) m)\n                        :else (get m x))))\n         (apply ({'+ +, '- -, '* *, '/ /} func)))))", "user": "5300158ae4b0d8b024fd370f"}, {"problem": 121, "code": "(fn universal-computation-engine [formula]\n  (fn [m]\n    (let [operators {'/ /\n                     '+ +\n                     '- -\n                     '* *}]\n      ((fn compute-form [form]\n         (let [{operator :operator\n                operands :operands} (reduce #(if (sequential? %2)\n                                               (assoc\n                                                 %1\n                                                 :operands\n                                                 (conj (:operands %1)\n                                                       (compute-form %2)))\n                                               (if (contains? operators %2)\n                                                 (assoc %1\n                                                   :operator\n                                                   (get operators %2))\n                                                 (assoc\n                                                   %1\n                                                   :operands\n                                                   (conj (:operands %1)\n                                                         (if (number? %2)\n                                                           %2\n                                                           (get m %2))))))\n                                            {:operands []\n                                             :operator nil}\n                                            form)]\n           (apply operator operands))) formula))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 121, "code": "(fn universal-computation-engine [formula]\n  (fn [var-map]\n    ((fn computer [f m]\n        (if (seq? f)\n          (apply ({'/ / '- - '+ + '* *} (first f))\n                 (map #(computer % m) (rest f)))\n          (if (m f) (m f) f))) formula var-map)))", "user": "5e92adb6e4b0fbed045a37ea"}, {"problem": 121, "code": "(fn [expr]\n  (fn [bindings]\n    (let [fun {'+ +, '- -, '* *, '/ /}]\n      (letfn [(exp [x]\n                (cond\n                  (integer? x) x\n                  (symbol? x) (bindings x)\n                  (sequential? x) (apply (fun (first x)) (map exp (rest x)))))]\n        (exp expr)))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 121, "code": "(fn calculate [formula]\n    (fn [mapping]\n      ((fn helper [expr]\n         (let [ops            {'/ / '* * '+ + '- -}\n               [op & params]  expr\n               values         (map (fn [p]\n                                     (if (seq? p)\n                                       (helper p)\n                                       (mapping p p))) params) ]\n           (apply (ops op) values)))\n       formula)))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 121, "code": "(fn [form]\n  (fn [values]\n    (let [db (merge {'+ + '- - '* * '/ /} values)\n          eval- (fn eval- [form]\n                  (if (seq? form)\n                    (let [[op & args] form]\n                      (apply (get db op) (map eval- args)))\n                    (get db form form)))]\n      (eval- form))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 121, "code": "(fn [s]\n  (let [operator-dict {'+ +, '- -, '* *, '/ / }]\n    (fn calculator\n      ([variable-map] (calculator variable-map s))\n      ([variable-map formula]\n       (if (not (seq? formula))\n         formula\n         (let [[operator & values] formula\n               filled-values (replace variable-map values)]\n           (apply (get operator-dict operator) (map #(calculator variable-map %) filled-values))))))))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 121, "code": "(fn eval_ [exp]\n    (fn step [ctx]\n      (let [ctx (conj {'+ + '- - '* * '/ /} ctx)\n            resolv #(get ctx % %)\n            app (fn [f args] (apply f ((eval_ args) ctx)))]\n        (cond\n          (list? exp) (cond (fn? (resolv (first exp)))\n                            (app (resolv (first exp)) (rest exp))\n                            :else (->> exp (map eval_) (map #(% ctx))))\n          (symbol? exp) (resolv exp)\n          :else exp))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 121, "code": "(fn uce [[op & args]]\n  (fn [smap]\n    (let [o (case op / / * * + + - -)] \n      (if (every? false? (map coll? args))      \n        (apply o (map #(or (smap %) %) args))\n        (apply o (map #(if (coll? %) \n                         ((uce %) smap) \n                         (or (smap %) %)) args))))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 121, "code": "(fn n [exp]\n  (let [ops {'* *, '/ /, '+ +, '- -}]\n    (fn [vars]\n      (letfn [(calc [e]\n                (cond\n                  (symbol? e) (vars e)\n                  (number? e) e\n                  :else (let [[f a b & c] e\n                              op (f ops)]\n                          (if c\n                            (op (calc a) (calc b) (first c))\n                            (op (calc a) (calc b))))))]\n        (calc exp)))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 121, "code": "(fn [formula]\n  (fn [vars]\n    (letfn [(calc [f]\n              (if (seq? f)\n               (apply (case (first f) + + - - * * / /)\n                      (map calc (rest f)))\n               (vars f f)))]\n      (calc formula))))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": 121, "code": "(fn eval2 [expr] \n  (let [e {'+ +, '- -, '* *, '/ /}]\n    (fn [env]\n      (let [env (merge env e)]\n        (cond\n          (number? expr) expr\n          (symbol? expr) (get env expr)\n          (list? expr) (let [f (first expr) \n                             r (rest expr)]\n                         (apply ((eval2 f) env)\n                                (map #((eval2 %) env) r))))\n        ))\n    ))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 121, "code": "(fn [expr]\n  (let [e (fn e [expr bindings]\n            (cond (number? expr) expr\n                  (symbol? expr) (bindings expr)\n                  (coll? expr) (let [arg-vals (map (fn [arg-expr] (e arg-expr bindings)) (rest expr))]\n                                 (case (first expr)\n                                   + (apply + arg-vals)\n                                   - (apply - arg-vals)\n                                   / (apply / arg-vals)\n                                   * (apply * arg-vals)))))]\n    (partial e expr)))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 121, "code": "(fn [x]\n  (fn [m]\n    ((fn ev [y]\n      (cond\n        (list? y) (apply ({'+ + '- - '* * '/ /} (first y)) (map ev (rest y)))\n        (symbol? y) (get m y)\n        :else y)) x)))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 121, "code": "(fn solution [form]\n  (letfn [(evaluate [symbol-list expression]\n            (cond\n              (coll? expression) (let [mapping (map (partial evaluate symbol-list) expression)] (apply (first mapping) (rest mapping)))\n              (symbol? expression) (get symbol-list expression)\n               :else expression))]\n    (fn [bindings] (evaluate (merge {'+ + '- - '* * '/ /} bindings) form))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 121, "code": "#(fn [m] (\n     (fn f[e]\n        (if (coll? e)\n          (apply (case (first e) + + - - * * / /) (map f (rest e)))\n          (get m e e)\n        ))\n      %))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 121, "code": "(fn uce [[op & args]]\n  (fn [env]\n    (let [ops {'+ + '- - '* * '/ /}]\n      (apply (ops op) (map #(if (seq? %) ((uce %) env) (env % %)) args)))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 121, "code": "(fn [expr]\n  (fn [kvs]\n    (let [operators {'+ + '- - '* * '/ /}]\n      ((fn f [expr kvs]\n         (if (seq? expr)\n           (->> (map #(f % kvs) (rest expr))\n                (apply (operators (first expr))))\n           (kvs expr expr)))\n       expr kvs))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 121, "code": "(fn compute [form]\n  (fn f [bindings]\n    (letfn [(evl [e]\n              (cond\n                (number? e) e\n                (symbol? e) (get bindings e)\n                :else ((compute e) bindings)))]\n      (let [[op & es] form\n            es (map evl es)]\n        (case op\n          + (apply + es)\n          - (apply - es)\n          * (apply * es)\n          / (apply / es))\n        ))))", "user": "5f300f28e4b033932238a682"}, {"problem": 121, "code": "(fn seval [e]\n  (fn [ctx]\n    (let [fns {'/ / '+ + '* * '- -}\n          ev (fn ev' [e]\n               (cond (coll? e) (apply (fns (first e)) (map ev' (rest e)))\n                     (symbol? e) (ctx e)\n                     :else e))]\n      (ev e))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 121, "code": "(fn g [e]\n    (fn [m]\n      (let [o {'+ + '- - '* * '/ /}]\n        (cond (coll? e) (apply (o (first e)) (map #((g %) m) (rest e)))\n              (symbol? e) (m e)\n              :else e))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 121, "code": "(fn [exp]\n    (fn [env]\n      (letfn [(eval* [l]\n                (apply (cond\n                         (= '+ (first l)) +\n                         (= '- (first l)) -\n                         (= '* (first l)) *\n                         (= '/ (first l)) /)\n                       (map #(cond\n                               (symbol? %) (get env % %)\n                               (list? %) (eval* %)\n                               :else %)\n                            (rest l))))]\n        (eval* exp))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 121, "code": "(fn uce [formula]\n\t(fn ucebaby [varmap]\n\t\t(apply\n\t\t\t({'+ + '/ / '- - '* *} (first formula))\n\t\t\t(map\n\t\t\t\t#(cond\n\t\t\t\t\t(varmap %) (varmap %)\n\t\t\t\t\t(coll? %) ((uce %) varmap)\n\t\t\t\t\t:else % \n\t\t\t\t)\n\t\t\t\t(rest formula)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 121, "code": "(fn [formula]\n    (fn [varmap]\n      ((fn ev [varmap expr]\n         (cond\n           (seq? expr)\n           (let [evalargs (for [subexpr (rest expr)] (ev varmap subexpr))]\n             (case (first expr)\n               + (apply + evalargs)\n               - (apply - evalargs)\n               * (apply * evalargs)\n               / (apply / evalargs))\n             )\n\n           (symbol? expr)\n           (varmap expr)\n\n           (number? expr)\n           expr\n\n           :else\n           (throw (ex-info \"Could not make sense of expr\" {:expr expr}))\n           )\n         )\n\n       varmap formula)\n      )\n    )", "user": "5f06caa7e4b0cf489e8d7f52"}, {"problem": 121, "code": "(fn [exp]\n  (fn [v-map]\n    (let [f (fn f [e v-map]\n              (if (seq? e)\n                (case (first e)\n                  + (apply + (map f (rest e) (repeat v-map)))\n                  - (apply - (map f (rest e) (repeat v-map)))\n                  * (apply * (map f (rest e) (repeat v-map)))\n                  / (apply / (map f (rest e) (repeat v-map))))\n                (if (number? e)\n                  e\n                  (get v-map e))))]\n      (f exp v-map))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 121, "code": "(fn [sexp]  \n  (letfn [ \n    (my-eval' [sexp env]\n        ;(println \"my-eval\" sexp env)\n        (cond \n            (number? sexp)    sexp\n            (symbol? sexp)    (env sexp)\n            :else  (do      \n                    (assert (list? sexp) \"Panic - not list\")\n                    ;(println \"Found\" sexp \"first\" (first sexp) \"rest\" (rest sexp))\n                    (let [func (first sexp)\n                          args (map #(my-eval' % env) (rest sexp)) ]\n                        ;(println \"func=\", func \"args\" args)\n                        (condp = func\n                            '+  (apply + args)\n                            '*  (apply * args)\n                            '-  (apply - args)\n                            '/  (apply quot args))))))\n     ]\n     (partial my-eval' sexp)))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 121, "code": "(fn foo [eq]\n    (fn [vs]\n      (if (coll? eq)\n        (apply ({'+ + '- - '/ / '* *} (first eq)) (map #((foo %) vs) (rest eq)))\n        (or (vs eq) eq))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 121, "code": "(fn evaller [expression]\n    (fn [symbol-map]\n      (cond\n        (sequential? expression) (let [[op & params] expression\n                                       why?? {'+ + '- - '/ / '* *}]\n                                   (apply (why?? op) (map #((evaller %) symbol-map) params)))\n        (symbol? expression) (get symbol-map expression)\n        :else expression)))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 121, "code": "(fn calc [exp]\n  (let [ops {'/ / '* * '+ + '- -}]\n    (fn compute [env]\n      (cond (number? exp) exp\n            (contains? env exp) (exp env)\n            (contains? ops exp) (exp ops)\n            :else (let [exp (map #((calc %) env) exp)] ;assume seq w/ operation in first position\n                    (apply (first exp) (rest exp)))))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 121, "code": "(fn uce [l]\n  (letfn [(rslv [v m] (if (symbol? v) (m v) v))\n          (evl [l m] (if (sequential? l)\n                       (let [l (map (fn [e] (evl e m)) l)]\n                         (apply (first l) (rest l)))\n                       (rslv l m)))]\n    (fn [m] (evl l (into {'/ / '* * '- - '+ +} m)))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 121, "code": "(fn ce [form]\n  (fn [hmap]\n    (cond\n      (number? form) form\n      (symbol? form) (get hmap form)\n      (coll? form) (let [f (get {'+ + '- - '* * '/ /} (first form))]\n                     (apply f (map #((ce %) hmap) (rest form)))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 121, "code": "(fn univ-computation-engine [exp]\n  ;; All expressions are one of the following three forms:\n  ;; - Numbers (general form '(n)) (which evaluate to themselves)\n  ;; - Variables (general form '(v)) (which evaluate to their values)\n  ;; - Expressions of the form '(op <operands>),\n  ;; where the op is one of the four arithmetic operators\n  ;; and <operands> are a list of expressions.\n  (fn [m]\n    (cond\n      (number? exp) exp\n      (symbol? exp) (get m exp)\n      :else (let [op (first exp)\n                  operands (rest exp)\n                  ops-map {'+ +\n                           '- -\n                           '* *\n                           '/ /}]\n              (->> operands\n                   (map (fn [e] (univ-computation-engine e)))\n                   (map (fn [f] (f m)))\n                   (apply (get ops-map op)))))))", "user": "5f63684be4b02876ed9fd012"}, {"problem": 121, "code": "(fn evaluate\n  [exp]\n  (let [global {'+ + '- - '* * '/ /}]\n    (fn [env]\n      (cond (symbol? exp) (exp env)\n            (number? exp) exp\n            (coll? exp) (apply ((first exp) global) (map (fn [e] ((evaluate e) env)) (rest exp)))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 121, "code": "(fn [_]\n  #(cond \n   (= % '{a 2 b 4}) 8\n   (= % '{b 8 a 16}) 2\n   (= % '{a 1 b 8}) 6\n   (= % '{b 5 a -2}) 0\n   (= % '{a 2 b 11}) -4\n   (= % '{x 4 y 1}) 1\n    ))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 121, "code": "(fn uce [l]\n\n  (letfn [(rep-vars-w-vals [orig var-map]\n            (map #(if (symbol? %) (% var-map) %) orig))\n          \n          (solve-it [l m]\n            (let [op-map {'/ / '* * '+ + '- -}\n                  op ((first l) op-map)] \n              (if (some coll? l)\n      ; apply base-op % results of recursions\n                (apply op (loop [tail (rest l) partial-sols []]\n                            (if (nil? (first tail))\n                              partial-sols\n                              (if (coll? (first tail)) \n                                (recur (rest tail) (conj partial-sols (solve-it (first tail) m)))\n                                (recur (rest tail) (conj partial-sols (first tail)))\n                                )\n                              )\n                            ))\n                (apply op (rep-vars-w-vals (rest l) m))\n                ))\n            )]\n    \n    (fn whoop [m-of-vn-vl]\n      (solve-it l m-of-vn-vl)\n      )))", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 121, "code": "(fn foo\n    ([e] (fn [v] (foo v e)))\n    ([v e] (if (list? e)\n               (let [f (first e)\n                     xs (map #(foo v %) (rest e))]\n                   (case f\n                       + (apply + xs)\n                       - (apply - xs)\n                       * (apply * xs)\n                       / (apply / xs)\n                       nil))\n               (if (symbol? e)\n                   (get v e)\n                   e))))", "user": "600ae927e4b074f607df6689"}, {"problem": 121, "code": "(fn eval-expr [expr]\n  (let [sym-to-op {'+ + '- - '* * '/ /}]\n       (letfn [(get-operand [[op & args]]\n                 [(op sym-to-op) args])\n               (apply-op [[op oprnds]]\n                 (loop [e-args [] u-args oprnds]\n                   (if (empty? u-args)\n                     (fn [env] (apply op ((apply juxt e-args) env)))\n                     (recur (conj e-args (eval-expr (first u-args)))\n                            (rest u-args)))))]\n         (cond (list? expr) (apply-op (get-operand expr))\n               (number? expr) (fn [_] expr)\n               (symbol? expr) (fn [env] (expr env))\n               :else          (throw (Exception. \"Invalid expression\"))))))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 121, "code": "(fn [expr]\n  (let [prefix {'+ + '- - '* * '/ /}]\n    (fn [vars]\n      (letfn [(compute [expr]\n                (if (list? expr)\n                  (apply (get prefix (first expr))\n                         (map compute (rest expr)))\n                  (get vars expr expr)))]\n        (compute expr)))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 121, "code": "(fn [fm]\n(fn [b]\n(let [m (merge {'+ + '- - '* * '/ /} b)\nf (clojure.walk/prewalk-replace m fm)\ne (fn e [x] (if (seq? x) (apply (first x) (map e (rest x))) x))]\n(e f))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 121, "code": "(fn f [[op & exps]]\n  #(let [m (merge {'+ +, '- -, '* *, '/ /} %)]\n      (letfn [(my-eval [exp]\n                (cond\n                 (number? exp) exp\n                 (symbol? exp) (m exp)\n                 :else ((f exp) m)))]\n        (apply (my-eval op) (map my-eval exps)))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 121, "code": "(fn quick-maths [expr]\n  (fn [variables]\n    (cond\n      (symbol? expr) (get variables expr)\n      (number? expr) expr\n      (list? expr) (let [[op & args] expr\n                         evaled-args (map #((quick-maths %) variables) args)]\n                     (case op\n                       + (apply + evaled-args)\n                       - (apply - evaled-args)\n                       * (apply * evaled-args)\n                       / (apply / evaled-args))))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 121, "code": "(fn uct [[op-sym & args]]\n  (let [operator (get {'/ / '* * '+ + '- -} op-sym)]\n    (fn [vars]\n      (let [calculate (fn [exp]\n                        (if (seq? exp) ((uct exp) vars)\n                          (or (vars exp) exp)))]\n        (apply operator (map calculate args)))\n      )))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 121, "code": "(fn uce\n  [arg]\n  (let [ops {'+ + '- - '* * '/ /}]\n    (fn [bnds]\n      (if (coll? arg)\n        (let [rargs (map (fn [a] ((uce a) bnds)) arg)]\n          (apply (first rargs) (rest rargs)))\n        (or (get bnds arg)\n            (get ops arg)\n            arg)))))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 121, "code": "(fn [s]\n  (fn [mapa]\n    (let [bigmap (merge {'+ + '- - '* * '/ /} mapa)]\n    (letfn [(myeval [o]\n                    (cond (list? o) (apply (get bigmap (first o)) (map myeval (rest o)))\n                          (number? o) o\n                          :else (get bigmap o)))]\n      (myeval s)))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 121, "code": "(fn [form]\n  (fn [context]\n    ((fn my-eval [form]\n       (apply ({'+ +, '- -, '* *, '/ /} (first form))\n              (map (fn [operand]\n                     (cond\n                       (symbol? operand) (context operand)\n                       (coll? operand) (my-eval operand)\n                       :else operand))\n                   (next form))))\n     form)))", "user": "60096aabe4b074f607df667f"}, {"problem": 121, "code": "(fn compute [[operation & exprs]]\n  (fn [assignment]\n    (letfn [(value [expr]\n              (if (coll? expr)\n                ((compute expr) assignment)\n                (assignment expr expr)))]\n      (case operation\n        + (apply + (map value exprs))\n        - (apply - (map value exprs))\n        / (apply / (map value exprs))\n        * (apply * (map value exprs)))\n      )))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 121, "code": "(fn universal-computation [expr]\n  (fn [m]\n    (let [m (assoc m '/ /, '+ +,\n                   '* *, '- -)]\n     (clojure.walk/postwalk\n      (fn [e] (cond (number? e) e\n                    (symbol? e) (m e)\n                    :else (apply (first e) (rest e))))\n      expr))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 121, "code": "(fn [form]\n  (fn [bmap]\n    (let [calc (fn calc\n                 ([x] (if (sequential? x) (apply calc x) x))\n                 ([op & x] (let [ops {'* *, '/ /, '+ +, '- -}]\n                             (apply (ops op) (map calc x)))))\n          formula (clojure.walk/prewalk-replace bmap form)]\n      (calc formula))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 121, "code": "#(let [ops {'+ + '- - '* * '/ /}]\n  (fn [vars]\n    (letfn [(go [expr]\n              (cond\n                (number? expr) expr\n                (symbol? expr) (vars expr)\n                :else (apply (ops (first expr)) (map go (rest expr))))\n              )]\n      (go %))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 121, "code": "(fn my-eval [x]\n  (fn [vars]\n    (cond\n      (number? x) x\n      (symbol? x) (vars x)\n      :else\n      (let [[op & operands] x]\n        (apply (case op + + - - * * / /) (map #((my-eval %) vars) operands))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 121, "code": "(fn solve [[f & xs]]\n  (fn [m]  (let [op   (get {'/ / '* * '+ + '- -} f)\n                 args (map (fn [x]\n                             (cond\n                               (number? x)    x\n                               (symbol? x) (get m x)\n                               (coll? x)   ((solve x) m)))\n                           xs)]\n             (apply op args))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 121, "code": "(fn [x]\n  (fn [m] ((fn e [x m]\n             (if (seq? x)\n               ; apply\n               (apply ({'+ + '- - '* * '/ /} (first x))\n                      (map #(e % m) (rest x)))\n               ; eval: resolve var\n               (m x x)))\n           x m)))", "user": "5f419985e4b0955706451fab"}, {"problem": 121, "code": "(fn [expr]\n  (fn [args]\n    (letfn [(process [input]\n               (cond (seq? input) (let [func (first input),\n                                        arg  (map process (rest input))]\n                                       (condp = func\n                                         '/ (apply / arg)\n                                         '* (apply * arg)\n                                         '- (apply - arg)\n                                         '+ (apply + arg)))\n                     (number? input) input\n                     :else (get args input)))]\n           (process expr))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 121, "code": "(fn [c] \n  (letfn \n    [(cal [d m] \n          (if (seq? d)\n              (apply ({'/ / '* * '+ + '- -} (first d)) \n                     (map #(cal % m) \n                          (replace m (rest d))))\n            d))]\n    #(cal c %)))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 121, "code": "(fn computation-engine\n  [coll]\n  (fn\n    [map]\n    (let [calculation (replace (merge map {'+ +, '- -, '/ /, '* *}) coll)\n          f (first calculation)\n          pt1 (second calculation)\n          pt2 (last calculation)]\n      (cond\n        (and (coll? pt1) (coll? pt1))  (apply f [((computation-engine pt1) map) ((computation-engine pt2) map)])\n        (coll? pt1) (apply f [((computation-engine pt1) map) pt2])\n        (coll? pt2) (apply f [pt1 ((computation-engine pt2) map)])\n        :else (apply f (rest calculation))\n        ))))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 121, "code": "(fn [formula]\n  (fn [parameters]\n    (letfn [(evaluate [x]\n                      (cond\n                        (seq? x) (apply ({'/ / '+ + '- - '* *} (first x)) (map evaluate (rest x)))\n                        (number? x) x))]\n      (evaluate (clojure.walk/prewalk-replace parameters formula)))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 121, "code": "(fn [coll]\n   (partial (fn ccc [c amap]\n              (let [functions-mapping\n                    {'* *\n                     '+ +\n                     '- -\n                     '/ /}\n                    replace-val-f (fn replace-val-f [c amap]\n                                    (map #(if (instance? clojure.lang.Seqable %)\n                                            (replace-val-f % amap)\n                                            (get amap % %)) c))\n                    evaluate-f (fn evaluate-f [expressions functions-mapping]\n                                 (cond\n                                   (not (instance? clojure.lang.Seqable expressions)) expressions\n\n                                   (empty? (filter #(instance? clojure.lang.Seqable %) expressions))\n                                   (apply (get functions-mapping (first expressions)) (rest expressions))\n\n                                   :else\n                                   (apply (get functions-mapping (first expressions)) (map #(evaluate-f % functions-mapping) (rest expressions)))))\n                    converted (replace-val-f c amap)\n                    res (evaluate-f converted functions-mapping)]\n                res\n                )) coll))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 121, "code": "(fn interp [expr]\n  (fn [env]\n    (let [op-map {'/ /, '+ +, '- -, '* *}]\n      (cond\n        (instance? java.lang.Long expr) expr\n        (symbol? expr) (get env expr)\n        :else (let [[op  & exprs] expr]\n                (apply (get op-map op) (map #((interp %) env) exprs)))))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 121, "code": "(fn [formula]\n  (fn [m]\n    (let [ops {'+ +, '- -, '* *, '/ / }\n          evaluate\n          (fn evaluate [exp]\n            (cond\n              (number? exp) exp\n              (symbol? exp) (get m exp)\n              :else\n              (let [[op & operands] exp]\n                (apply (get ops op) (map evaluate operands)))))]\n      (evaluate formula))))", "user": "4fe49706e4b0e8f79898feb7"}]