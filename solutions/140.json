[{"code": "(fn [f]\n  (comment \"The tutorial for the Quine McCluskey (QM) algorithm and\n    Petrick's Method at http://sites.google.com/site/simpogical/download\n    was quite helpful.\")\n(letfn\n    [(set+ [s t] (clojure.set/union s t))\n     (set- [s t] (clojure.set/difference s t)) \n     (preprocess [f]\n       (set (map (fn [s] (set (map #(str %) s))) f))) \n     (fvars [f]\n       (sort (into #{} (mapcat #(map clojure.string/upper-case %) f))))\n     (set->bseq [vars minterm]\n       (for [v vars] (if (minterm v) 1 0))) \n     (bseq->int [bs]\n       (loop [bs bs acc 0]\n         (if (empty? bs)\n           acc\n           (recur (rest bs) (+ (* 2 acc) (first bs)))))) \n     (nbits [bseq] (count (filter #(= 1 %) bseq))) \n     (ndiff [bs1 bs2] (count (filter false? (map = bs1 bs2))))\n     (wildcard? [x] (= x -1)) \n     (wildcards-match? [bs1 bs2]\n       (if (empty? bs1)\n         true\n         (let [[x1 & r1] bs1 [x2 & r2] bs2]\n           (if (or (wildcard? x1) (wildcard? x2))\n             (if (= x1 x2)\n               (recur r1 r2)\n               false)\n             (recur r1 r2)))))\n     (zip [s1 s2] (map vector s1 s2)) \n     (merge-bseq* [bs1 bs2]\n       ;;assume diff. in one digit, wildcards match\n       (let [[head [[mis match] & tail]] (split-with #(apply = %) (zip bs1 bs2))]\n         (map first (concat head [[-1 -1]] tail)))) \n     (merge-bseq [bs1 bs2]\n       (let [bits1 (nbits bs1)\n             bits2 (nbits bs2)\n             n-diff (ndiff bs1 bs2)]\n         (if-not (= 1 n-diff)\n           nil ; can only be different by one digit\n           (if-not (wildcards-match? bs1 bs2)\n             nil\n             (merge-bseq* bs1 bs2)))))\n     (prime-implicants [f]\n       (let [vars (fvars f)\n             bseqs (map #(set->bseq vars %) f)\n             minterms (into {} (for [bs bseqs] [(bseq->int bs) bs]))]\n         (loop [bseqs (set bseqs) old nil]\n           (if (= bseqs old)\n             (vec (map vec bseqs)) ;fixed point\n             (let [merges\n                   (filter\n                    #(not (nil? (nth % 2)))\n                    (for [bs1 bseqs bs2 bseqs] [bs1 bs2 (merge-bseq bs1 bs2)]))\n                   merged (reduce set+ #{} (map #(set (subvec % 0 2)) merges))\n                   new-bseqs (set (map #(nth % 2) merges))]\n               (recur (set+ new-bseqs (set- bseqs merged)) bseqs))))))\n     (covers? [implicant minterm]\n       (every? (fn [[x y]] (or (wildcard? x) (= x y))) (zip implicant minterm)))\n     (or* [& is] (reduce bit-or is))\n     (and* [indexes]\n       (let [idxs (set indexes)]\n         (set-\n          idxs\n          (set (for [i idxs j idxs\n                     :when (and (< i j) (= i (bit-and i j)))]\n                 j)))))\n     (indexed [s] (map-indexed vector (seq s)))\n     (index-of [coll x]\n       (loop [s (seq coll) n 0]\n         (cond (empty? s) -1\n               (= x (first s)) n\n               :else (recur (rest s) (inc n)))))\n     (petricks-method [implicants minterms]\n       (let [cover-table (vec (for [implicant implicants]\n                                (vec (for [minterm minterms]\n                                       (covers? implicant minterm)))))\n             n (count implicants)\n             implicant-indexes (vec (map #(bit-shift-left 1 %) (range n)))\n             ;; Minterm = OR_ implicant  \n             minterm-included (for [[m mt] (indexed minterms)]\n                                (apply or*\n                                       (for [[i impl] (indexed implicants)\n                                             :when (get-in cover-table [i m])] \n                                         (nth implicant-indexes i))))\n             min-idx-set (and* minterm-included)]\n         (for [i min-idx-set] (nth implicants (index-of implicant-indexes i)))))\n     ]\n    (let [f (preprocess f)\n          vars (fvars f)\n          minterms (vec (sort (map #(vec (set->bseq vars %)) f)))\n          implicants (vec (prime-implicants (preprocess f)))\n          implicants (petricks-method implicants minterms)]\n      (set (for [impl implicants]\n             (set (for [[v x] (zip vars impl) :when (not (wildcard? x))]\n                    (condp = x\n                      1 (symbol v)\n                      0 (symbol (clojure.string/lower-case v))))))))))", "problem": 140, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [algebra]\n  (let [\n  ; Lifted from clojure.set\n  intersection (fn intersection\n    ([s1] s1)\n    ([s1 s2]\n      (if (< (count s2) (count s1))\n        (recur s2 s1)\n        (reduce (fn [result item]\n          (if (contains? s2 item)\n            result\n            (disj result item)))\n          s1 s1)))\n    ([s1 s2 & sets]\n      (apply intersection (cons (intersection s1 s2) sets))))\n  ; Lifted from clojure.set\n  union (fn\n    ([] #{})\n    ([s1] s1)\n    ([s1 s2]\n       (if (< (count s1) (count s2))\n         (reduce conj s2 s1)\n         (reduce conj s1 s2))))\n  ; Lifted from clojure.set\n  difference (fn difference\n    ([s1] s1)\n    ([s1 s2]\n      (if (< (count s1) (count s2))\n        (reduce (fn [result item]\n          (if (contains? s2 item)\n            (disj result item)\n            result))\n        s1 s1)\n        (reduce disj s1 s2)))\n    ([s1 s2 & sets]\n      (reduce difference s1 (conj sets s2))))\n  as-implicants (fn [algebra]\n    (map #(hash-map :signature % :minterms #{%}) algebra))\n  combinable? (fn [{x-sig :signature} {y-sig :signature}]\n    (let [target (- (count x-sig) 1)]\n      (->> (intersection x-sig y-sig) count (== target))))\n  combine (fn [{x-sig :signature, x-minterms :minterms}\n               {y-sig :signature, y-minterms :minterms}]\n    { :signature (->> (difference x-sig y-sig)\n                       first\n                       str\n                       (.toLowerCase)\n                       (conj (intersection x-sig y-sig)))\n      :minterms (union x-minterms y-minterms) })\n  clean-primes (fn [{:keys [primes combos]}]\n    { :primes (->> primes\n                   (map (fn [{:keys [signature minterms]}]\n                            { :signature (->> signature\n                                              (filter symbol?)\n                                              set)\n                              :minterms minterms }))\n                   set)\n      :combos combos })\n  sift (fn [xss]\n    (let [\n    accum-combos-with (fn [xs]\n      (fn [acc ys]\n        (if (combinable? xs ys)\n          (conj acc (combine xs ys))\n          acc)))\n    ]\n    (->> xss\n         (reduce (fn [acc xs]\n           (let [combos (reduce (accum-combos-with xs) #{} xss)]\n             (if (empty? combos)\n               (assoc acc :primes (-> (acc :primes) (conj xs)))\n               (assoc acc :combos (-> (acc :combos) (union combos))))))\n           { :primes #{}, :combos #{} })\n          clean-primes)))\n  find-prime-implicants (fn [algebra]\n    (let [f (fn [{the-rest :combos}]\n              (sift the-rest))]\n      (->> { :primes #{}, :combos (as-implicants algebra) }\n           (iterate f)\n           (take-while #(or (seq (% :primes))\n                            (seq (% :combos))))\n           (map #(% :primes))\n           (reduce union #{})\n           set)))\n  essential-prime-implicants (fn [prime-implicants]\n    (let [contains (fn [minterm]\n            (fn [{pi-minterms :minterms}]\n              (pi-minterms minterm)))\n          pivotal? (fn [minterm]\n            (->> prime-implicants\n                 (filter (contains minterm))\n                 count\n                 (== 1)))\n          pivotal-minterms (filter pivotal? algebra)\n          essential? (fn [{pi-minterms :minterms}]\n            (some #(pi-minterms %) pivotal-minterms))]\n      (filter essential? prime-implicants)))\n  minimize (fn [prime-implicants]\n    ; In fact, this solution is incomplete.  One or more of the nonessential\n    ; prime implicants may be needed in the solution.  However, none of the\n    ; test cases currently exposes this, and I don't have access to append\n    ; additional test cases.\n    (->> prime-implicants\n         essential-prime-implicants\n         (map #(% :signature))\n         set))\n  ]\n  (->> algebra \n       find-prime-implicants\n       minimize)))", "problem": 140, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [xs]\n  (letfn [(c [[s1 s2]]\n            (let [x (clojure.set/difference s1 s2)]\n              (if (and (= (count x) 1)\n                       (= (clojure.string/upper-case x)\n                          (clojure.string/upper-case (clojure.set/difference s2 s1))))\n                [(clojure.set/intersection s1 s2) s1 s2])))\n          (s [[xs ys]]\n            (let [r (keep c (loop [xs xs r []]\n                              (if (empty? xs) r\n                                  (recur (rest xs) (concat r (map #(list (first xs) %) (rest xs)))))))\n                  x (set (map first r))\n                  y (reduce #(disj % (second %2) (nth %2 2)) xs r)]\n              [x (clojure.set/union ys y)]))]\n    (let [ts (apply clojure.set/union (last (take-while #(not (empty? (first %))) (iterate s [xs #{}]))))]\n      (set (map first (filter #(= (count %) 1) (map (fn [x] (filter #(clojure.set/subset? % x) ts)) xs)))))))", "problem": 140, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn [i]\n  (let [u clojure.set/union\n\t      f filter s set\n\t\t  b (fn [[x m] t]\n\t\t\t\t(s (f identity (map  \t\t\t\n\t\t\t\t\t(fn [[y n]]\n\t\t\t\t\t\t(let [i (clojure.set/intersection x y)]\n\t\t\t\t\t\t\t(when (= (inc (count i)) (count (s (map clojure.string/upper-case (u x y))))) \n\t\t\t\t\t\t\t\t[i (into m n)])))\t\n\t\t\t\t\tt)))) \t\n\t\t  t (loop [x #{} y (map #(vector % #{%}) i)]\n\t\t\t\t(if (empty? y)\n\t\t\t\t\tx\n\t\t\t\t\t(recur \n\t\t\t\t\t\t(into x (s (f #(empty? (b % y)) y))) \n\t\t\t\t\t\t(apply u (f #(not (empty? %)) (map #(b % y) y))))))\n\t   \t  p #(clojure.set/subset? (second %) (apply u (map second (disj t %))))]\n\t(loop [[x y] (map s [(f p t) (remove p t)])]\n\t\t(if (= i (apply u (map second y)))\n\t\t\t(s (map first y))\n\t\t\t(let [z (first x)]\n\t\t\t\t(recur [(disj x z) (conj y z)]))))))", "problem": 140, "user": "4db85282535d1e037afb218a"}, {"code": "(fn kmap [col]\n  (let [subset (fn [col1] (reduce concat (for [m col1] (for [n (disj col1 m)] [m n]))))\n        check_symbol (fn [s1 s2]\n      (let [symbol_map {'A 'a 'a 'A 'B 'b 'b 'B 'C 'c 'c 'C 'D 'd 'd 'D}]\n        (= s1 (get symbol_map s2))\n        )\n      )\n        combine_set (fn [s1 s2]\n      (let [comset (clojure.set/intersection s1 s2)\n            rest_s1 (clojure.set/difference s1 comset)\n            rest_s2 (clojure.set/difference s2 comset)\n            ]\n        (if (and (= 1 (count rest_s1))  (= 1 (count rest_s2)) (check_symbol (first rest_s1) (first rest_s2)))\n          comset\n          #{}\n          )))\n        combine_sets (fn [col1]\n        (set (filter #(not-empty %) (map (fn [[s1 s2]] (combine_set s1 s2))  (subset col1))))\n      )\n       ; remove all the super set of s2 from s1\n       filter_super_set (fn [s1 s2]\n        (loop [result #{} data s1])\n        (if (empty? s1 )\n            s1\n            (set (filter (fn [elt] (not (some #(clojure.set/superset?  elt %)    s2) ))         s1))\n          )        )\n\n          get-possible-combine (fn [col1]\n      (loop [result #{} data col combined (combine_sets data)]\n                         (let [ minimumed (clojure.set/intersection  data combined)\n                                filtered  (filter_super_set result  combined)\n                                ]\n                          (if (empty? data)\n                            result\n                            (recur (clojure.set/union  minimumed filtered) combined  (combine_sets data))\n                            )\n                  )        )\n          )\n          possible-combine  ( get-possible-combine col)\n          ]\n          (if (= 0 (count possible-combine)  )\n               col\n              (loop[result #{} data col combines possible-combine ]\n              (if (empty? data )\n                result\n                (recur (conj result  (first combines) ) (filter_super_set data (conj #{} (first combines))) (rest combines)   )\n                ))\n            )\n\n\n\n\n\n    ))", "problem": 140, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [R J k]\n  (R (fn [a b] \n    (let [w (fn [x y] ('#{#{a A} #{b B} #{c C} #{d D}}\n                        (R #((if (% %2) disj J) % %2) x y)))\n          [u v] (filter #(every? b %) \n                  ((fn f [m] \n                     (#(if (= m %) % (f %))\n                        (R (fn [s t] \n                          (if (some #(w t %) m) \n                            (R #(if (w t %2) (J % (set (keep t %2))) %) \n                                    s \n                                    m)\n                            (J s t)))\n                          #{}\n                          m))) \n                   k))]\n      (if v a (J a u))))      \n    #{} \n    k))\nreduce conj", "problem": 140, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [terms]\n  (letfn [(neg [sym]\n           (let [tr (zipmap \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\")]\n             (-> sym str first tr str symbol)))\n          (resolvent-by [s t v]\n            (if (= (disj s v) (disj t (neg v))) (disj s v) nil))\n          (resolvent [s t]\n            (some #(resolvent-by s t %) s))\n          (resolvents [terms]\n            (disj (set (for [s terms t terms] (resolvent s t))) nil))\n          (primes [terms]\n            (loop [r1 terms r0 #{}]\n              (if (= r1 r0)\n                (set r1)\n                (let [res (clojure.set/union r1 (resolvents r1))\n                      min? (fn [t] (every? #(or (= t %) (not (clojure.set/subset? % t))) res))\n                      r2 (filter min? res)]\n                  (recur r2 r1)))))\n          (subsets-size [s n]\n            (cond\n              (zero? n) (list #{})\n              (> n (count s)) nil\n              :else\n                (let [a (first s) t (disj s a)]\n                  (concat (subsets-size t n)\n                          (map #(conj % a) (subsets-size t (dec n)))))))\n          (subsets-by-size [s]\n            (apply concat (map #(subsets-size s (inc %)) (range (count s)))))\n          (covers? [terms1 terms2]\n            (every? (fn [t] (some #(clojure.set/subset? % t) terms1)) terms2))]\n    (first (filter #(covers? % terms) (subsets-by-size (primes terms))))))", "problem": 140, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [a]\n  (letfn [(p [r]\n            (if (empty? r)\n              [[]]\n              (let [z (p (rest r))]\n                (concat\n                 (map #(cons (ffirst r) %) z)\n                 (map #(cons (second (first r)) %) z)\n                 z))))]\n    (let [s? clojure.set/subset?\n          u\n          (reduce\n           (fn [r s]\n             (if (not-any? #(s? % s) r)\n               (conj r s)\n               r))\n           #{}\n           (sort-by count\n                    (filter\n                     (fn [c]\n                       (= (reduce * (repeat (- (count (first a))\n                                               (count c))\n                                            2))\n                          (count\n                           (filter #(s? c %) a))))\n                     (map set (p [['a 'A] ['b 'B] ['c 'C] ['d 'D]])))))]\n      \n      (loop [r (map (fn [r] (filter #(s? % r) u)) a)\n             s #{}]\n        (if (empty? r)\n          s\n          (let [t (into s (map first (filter #(= 1 (count %)) r)))]\n            (recur\n             (map\n              (fn [r] (filter #(s? % r) u))\n              (filter (fn [r] (some #(s? % r) s)) a))\n             t)))))))", "problem": 140, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [s] (let [d (count (first s))\n               v (set (take (* 2 d) '(A a B b C c D d)))\n               i (fn [a b] (apply disj a (apply disj a b)))\n               cnt (fn [x] (prn x)(count (filter #(= x %) (map #(i % x) s))))\n               contained (fn [x y] (= (i x y) y))\n               sets (filter #(= (Math/pow 2 (- d (count %))) (cnt %)) (sort-by count (distinct (for [a v b v c v] (set [a b c])))))]\n           (set (loop [remaining s candidates sets result []] \n             (if (empty? remaining)\n               result\n               (if (empty? candidates)\n                 s\n                 (let [c (first candidates)\n                       r (rest candidates)\n                       x (remove #(contained % c) remaining)]\n                   (if (#{2 4 8} (- (count remaining) (count x)))\n                     (recur x r (conj result c))\n                     (recur remaining r result)))))))))", "problem": 140, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [sats]\n       (let [one-diff (fn [a b] (= 1 (count (clojure.set/difference a b))))\n             neighbor? (fn [a b]\n                         (and (empty? (clojure.set/intersection a b))\n                              (every? #(some (partial one-diff %) b) a)))\n             ones (map (partial conj #{}) sats)\n             pair-up (fn [items]\n                       (->> (iterate next items)\n                            (take-while identity)\n                            (mapcat (fn [[b & bs]]\n                                      (keep #(when (neighbor? b %)\n                                               (into b %)) bs)))))\n             twos (pair-up ones)\n             fours (pair-up twos)\n             eights (pair-up fours)\n             sixteens (pair-up eights)\n             big-to-small (concat sixteens eights fours twos ones)\n             boxes (loop [coverage (zipmap sats (map #(for [b big-to-small\n                                                            :when (some #{%} b)]\n                                                        b)\n                                                     sats))\n                          boxes []]\n                     (if (empty? coverage)\n                       boxes\n                       (let [[min-cover [largest-box]] (apply min-key (comp count val) coverage)]\n                         (recur (reduce dissoc coverage largest-box)\n                          (conj boxes largest-box))))\n                     )\n             ]\n         (set (map (partial apply clojure.set/intersection) boxes))))", "problem": 140, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [booleans]\n  (let [zones-from-base\n        (fn [h w]\n          (for [dx (range 4) dy (range 4)]\n            [(set (map #(mod (+ dy %) 4) (range h))) (set (map #(mod (+ dx %) 4) (range w)))]))\n        zones\n        (mapcat #(apply zones-from-base %)\n                (for [x (range 5) y (range 5) :when (#{1 2 4 8 16} (* x y))] [x y]))\n        matrix-mapping\n        (for [y [#{'c 'd} #{'c 'D} #{'C 'D} #{'C 'd}]]\n          (for [x [#{'a 'b} #{'a 'B} #{'A 'B} #{'A 'b}]]\n            (apply conj x y)))]\n    (letfn [(parse-to-matrix [booleans]\n              (vec (for [line matrix-mapping]\n                     (vec (for [x line] (some #(every? x %) booleans))))))\n            (coords-to-vars [[cd ab]]\n              (let [ab-mapping [['a 'b] ['a 'B] ['A 'B] ['A 'b]]\n                    cd-mapping [['c 'd] ['c 'D] ['C 'D] ['C 'd]]\n                    coord-to-vars (fn [coord mapping]\n                                    (mapcat mapping coord))]\n                (set (flatten (filter #(= 1 (count %))\n                                      (vals (group-by #(.toLowerCase (name %))\n                                                      (set (concat (coord-to-vars ab ab-mapping)\n                                                                   (coord-to-vars cd cd-mapping))))))))\n                ))\n            (remove-while-covering [zones]\n              (let [sorted-zones (sort-by #(count (flatten %)) zones)]\n                (reduce (fn [ret [ys xs]]\n                          (if (seq (for [y ys x xs\n                                         :when (not-any? (fn [[rys rxs]] (and (rys y) (rxs x)))\n                                                         (remove #(= [ys xs] %) ret))] [y x]))\n                            ret\n                            (remove #(= [ys xs] %) ret)))\n                        (reverse sorted-zones)\n                        sorted-zones)))\n            (matching-zones [matrix]\n              (let [values-in-subset (fn [[ys xs]] (for [x xs y ys] (get-in matrix [y x])))\n                    ]\n                (filter #(every? identity (values-in-subset %)) zones)))\n            ]\n      (->> booleans\n           parse-to-matrix\n           matching-zones\n           remove-while-covering\n           (map coords-to-vars)\n           set))))", "problem": 140, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [sets]\n  (let [\n    converge (fn [f x]\n      (loop [x0 x x1 (f x)]\n        (if (= x0 x1) x1 (recur x1 (f x1)))))\n    opposite (fn [a b] (and (not= a b) (= (.toUpperCase (str a)) (.toUpperCase (str b)))))\n    adjacent (fn [s0 s1] (let [d0 (apply disj s0 s1) d1 (apply disj s1 s0)] (and (= 1 (count d0)) (= 1 (count d1)) (opposite (first d0) (first d1)))))\n    combine (fn [s0 s1] (disj s0 (first (apply disj s0 s1))))\n    covers (fn [ss] (every? (fn [s] (some #(empty? (apply disj % s)) ss)) sets))\n    remove-redundency (fn [ss] (let [options (for [s ss :let [new-ss (disj ss s)] :when (covers new-ss)] new-ss)] (if (empty? options) ss (first options))))\n    simplify (fn [sets]\n      (let [segments (for [\n        s0 sets s1 sets\n        :when (= (count s0) (count s1))\n        :when (adjacent s0 s1)]\n        [s0 s1 (combine s0 s1)])]\n        (reduce (fn [sets [s0 s1 sc]]\n          (println [s0 s1 sc])\n          (disj (conj sets sc) s0)) sets segments)))]\n    (remove-redundency (converge simplify sets))))", "problem": 140, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn prob-0140\n  [vs]\n\n  (letfn [(kmap-to-lower\n            [sym]\n            (symbol  (java.lang.String/.toLowerCase (str sym))))\n\n          (kmap-to-upper\n            [sym]\n            (symbol  (java.lang.String/.toUpperCase (str sym))))\n\n          (kmap-is-upper?\n            [sym]\n            (java.lang.Character/isUpperCase (.charAt (str sym) 0)))\n\n          (kmap-var-names\n            [vs]\n            (apply sorted-set (map kmap-to-upper (flatten (map concat vs)))))\n\n          (kmap-var-vals\n            [vars]\n            (let [vals (reverse (take (count vars) (iterate #(* 2 %) 1)))]\n              (into (sorted-map) (map vector vars vals))))\n\n          (kmap-to-dec\n            [var-seq vmap]\n            (apply + (map vmap (filter kmap-is-upper? var-seq))))\n\n          (dig-div\n            [n in-divs]\n            (let [divs (seq in-divs)]\n              (if-not divs\n                []\n                (let [div0 (first divs)]\n                  (cons (int (/ n div0)) (dig-div (int (rem n div0)) (rest divs)))))))\n\n          (to-base-seq\n            [num base]\n            (let [dig-vals (reverse (take-while #(<= % (max 1 num)) (iterate #(* % base) 1)))]\n              (dig-div num dig-vals)))\n\n          (prefix-to-width\n            [sq pre wid]\n            (let [need (- wid (count sq))]\n              (concat (replicate need 0) sq)))\n\n          (to-bin-grid\n            ([nums]\n               (let [seqs (map #(to-base-seq % 2) nums)\n                     wid  (apply max (map count seqs))]\n                 (to-bin-grid nums wid)))\n            ([nums wid]\n               (let [seqs (map #(to-base-seq % 2) nums)]\n                 (vec (map #(vec (prefix-to-width % 0 wid)) seqs)))))\n\n          (pairs\n            ;; \"Returns all possible pairs of [x y] in sequence in-xs\"\n            [in-xs]\n            (let [xs (vec (seq in-xs))]\n              (for [xi (range 0 (dec (count xs)))\n                    :let [x (xs xi)]\n                    y (drop (inc xi) xs)]\n                [x y])))\n\n          (dash-combine\n            ;; \"Returns [combined-x-y [orig-x orig-y]] or nil if no combination possible.\"\n            [x y]\n            (let [x-dashes (count (filter #(= \\- %) x))\n                  y-dashes (count (filter #(= \\- %) y))]\n              ;; If dashes equal, look for one-diff, otherwise try to overwhelm.\n              (if (= x-dashes y-dashes)\n                (let [eqs    (map = x y)\n                      dfs    (filter #(false? (second %)) (map-indexed vector eqs))\n                      df-cnt (count dfs)]\n                  (if (= 1 df-cnt)\n                    [(assoc x (ffirst dfs) \\-) [x y]]\n                    nil))\n                (let [[less more] (if (< x-dashes y-dashes) [x y] [y x])\n                      less2  (vec (map #(if (= \\- %2) \\- %1) less more))]\n                  (if (= less2 more)\n                    [more [x y]]\n                    nil)))))\n\n          (dash-combos\n            ;; \"Returns [set(combos) set(consumed)]\"\n            [xs]\n            (let [res (for [[x y] (pairs xs)\n                            :let [combo (dash-combine x y)]\n                            :when (not (nil? combo))]\n                        combo)\n                  combos   (map    first  res)\n                  consumed (mapcat second res)]\n              [(set combos) (apply disj (set (seq xs)) consumed)]))\n\n          (dash-combine-all\n            [xs]\n            (let [[combos, remains] (dash-combos xs)]\n              (if (empty? combos)\n                remains\n                (recur (concat combos remains)))))\n\n          (k-combos\n            ;; \"Returns a set of sets of all combinations of S taken k at a time\"\n            [k S]\n\n            (cond\n             (<= k 0) #{}\n             (> k (count S)) #{}\n             (= k 1) (set (map #(set %1) (partition 1 S)))\n             :else (into #{} (for [rem-S (take (count S) (iterate rest S))\n                                   :let [hed (first rem-S)]\n                                   tal (k-combos (dec k) (rest rem-S))]\n                               (set (cons hed tal))))))\n\n          (combinations\n            ;; \"Returns a sequence a sets of all combinations of S by increasing length\"\n            [S]\n            (apply concat (for [k (range 1 (inc (count S)))]\n                            (k-combos k S))))\n\n          (dash-matches?\n            [pat-seq tst-seq]\n            (every? true? (map #(or (= %1 %2) (= %1 \\-)) pat-seq tst-seq)))\n\n          (dash-matches-some\n            [match-pats test-ins]\n            (some true? (for [pattern match-pats]\n                          (dash-matches? pattern test-ins))))\n\n          (covers-problem\n            [test-ins want-res match-pats]\n            (= want-res (set (filter #(dash-matches-some match-pats %) test-ins))))\n\n          (kmap-to-vars\n            [vnames pat]\n            (into (sorted-set) (mapcat #(cond\n                                         (= 1 %1) [%2]\n                                         (= 0 %1) [(kmap-to-lower %2)]\n                                         :else    [])\n                                       pat vnames)))\n          ]\n    \n    ;; TODO: Either make it an error if a variable is missing in an input, or convert it to have don't cares.\n    (let [vnames   (kmap-var-names vs)\n          num-vars (count vnames)\n          vmap     (kmap-var-vals vnames)\n          in-decs  (apply sorted-set (map #(kmap-to-dec % vmap) vs))\n          in-bins  (to-bin-grid in-decs num-vars)\n          combines (dash-combine-all in-bins)\n          test-ins (to-bin-grid (range (* 2 (apply max (vals vmap)))) num-vars)\n          hero     (first (filter #(covers-problem test-ins (set in-bins) %) (combinations combines)))\n          ]\n      \n      (if (empty? hero)\n        vs\n        (set (map #(kmap-to-vars vnames %) hero))))))", "problem": 140, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn veitch [sets]\n  (let [numvars (count (first sets))\n        tbl '{A [0 :1] a [0 :0]\n              B [1 :1] b [1 :0]\n              C [2 :1] c [2 :0]\n              D [3 :1] d [3 :0]}\n        initial-val (into [] (take numvars (repeat :0)))\n        n-set (map #(reduce\n                     (fn [a b]\n                       (assoc a (first (tbl b)) (second (tbl b))))\n                     initial-val\n                     %)\n                   sets)\n        shrink (fn [a b]\n                 (let [res (map #(cond\n                                  (= %1 %2) %1\n                                  (or (= %1 :-) (= %2 :-)) :x\n                                  :else :+)\n                                a b)\n                       freq (frequencies res)\n                       ]\n                   (cond\n                    (not= 0 (get freq :x 0)) nil\n                    (> (get freq :+ 0) 1) nil\n                    (= (get freq :+ 0) 0) nil\n                    :else (map #(if (= :+ %) :- %) res))))\n        scan (fn [a s]\n               (filter (complement nil?) (map #(shrink a %) s)))\n        doit (fn doit [s]\n               (let [ss (set\n                         (mapcat (fn [a] (let [r (scan a s)]\n                                           (if (empty? r) (list a) r))) s))]\n                 (if (not= s ss) (doit ss) s)))\n        match (fn [t p]\n                          (reduce\n                 #(and %1 (or (= :- (nth t %2)) (= (nth p %2) (nth t %2))))\n                 true\n                 (range (count p))))\n        parse (fn [tt pp]\n                (filter (fn [x] ((complement match) tt x)) pp))\n        cover-all (fn [mask ss pp]\n                    (empty?\n                     (reduce\n                      #(if (bit-test mask %2) (parse (nth ss %2) %1) %1)\n                      pp\n                      (range (count ss)))))\n        unate (fn [s p]\n                (let [size (count s)]\n                  (filter\n                   #(cover-all % s p)\n                   (range 1 (bit-shift-left 1 size)))))\n        unmap (fn output [ss mask]\n                 (reduce\n                  #(if (bit-test mask %2)\n                     (conj %1 (nth ss %2)) %1) (vector) (range (count ss))))\n        f (into [] (doit n-set))\n        untbl '({:0 a :1 A} {:0 b :1 B} {:0 c :1 C} {:0 d :1 D})\n        answers (map #(map (fn [a b] (get a b '-)) untbl %) (unmap f (first (unate f n-set))))\n        ]\n    (into #{} (map (fn [item] (into #{} (filter #(not= % '-) item))) answers))))", "problem": 140, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn veitch [satisfies]\n    (let [sym-str #(clojure.string/lower-case (name %))\n          compare-syms (fn [s1 s2] (compare (sym-str s1) (sym-str s2)))\n          all-symbols (into {} (map-indexed #(vector %2 %1) (distinct (apply concat satisfies))))\n          num-symbols (count (apply sorted-set-by compare-syms (apply concat satisfies)))\n          level\n            (fn level [num-symbols symindex sets]\n                (when (pos? (count sets))\n                    (if (= (count sets) (apply * (repeat num-symbols 2)))\n                        (list [#{} sets])\n                        (let [symbols (set (apply concat sets))]\n                            (for [symbol symbols\n                                  :let [this-index (all-symbols symbol)]\n                                  :when (> this-index symindex)\n                                  :let [symsets (->> sets\n                                                     (filter #(contains? % symbol))\n                                                     (map #(disj % symbol))\n                                                     set\n                                                )]\n                                  [resset inpsets] (level (dec num-symbols) this-index symsets)]\n                                [(conj resset symbol) (set (map #(conj % symbol) inpsets))]\n                            )))))\n          index-combinations\n            (fn  [n cnt]\n              (lazy-seq\n               (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n                 iter-comb\n                 (fn iter-comb [c j]\n                   (if (> j n) nil\n                       (let [c (assoc c j (dec (c j)))]\n                     (if (< (c j) j) [c (inc j)]\n                         (loop [c c, j j]\n                           (if (= j 1) [c j]\n                           (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n                 step\n                 (fn step [c j]\n                   (cons (rseq (subvec c 1 (inc n)))\n                     (lazy-seq (let [next-step (iter-comb c j)]\n                             (when next-step (step (next-step 0) (next-step 1)))))))]\n                 (step c 1))))\n\n          combinations\n            (fn [items n]      \n              (let [v-items (vec (reverse items))]\n                (if (zero? n) (list ())\n                (let [cnt (count items)]\n                  (cond (> n cnt) nil\n                    (= n cnt) (list (seq items))\n                    :else\n                    (map #(map v-items %) (index-combinations n cnt)))))))\n          solve\n            (fn [parts n]\n                (let [solves? #(= satisfies (apply clojure.set/union (map second %)))]\n                    (for [comb (combinations parts n)\n                          :when (solves? comb)]\n                        (set (map first comb))\n                    )))\n        ]\n        (let [parts (vec (level num-symbols -1 satisfies))]\n            (loop [i 1]\n                (when (<= i (count parts))\n                    (if-let [solutions (seq (solve parts i))]\n                        (first solutions)\n                        (recur (inc i))\n                    ))))))", "problem": 140, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [s]\n  (letfn [\n    (to-f [sym] (-> sym str first Character/toLowerCase str symbol))\n    (to-t [sym] (-> sym str first Character/toUpperCase str symbol))\n    (get-symbols [s] (distinct (map to-t (apply concat s))))\n    (to-minterm [symbols s]\n      (reduce \n        #(conj %1 \n          (cond (s %2) true (s (to-f %2)) false :else nil))\n        []\n        symbols))\n    (from-minterm [symbols m]\n      (set\n        (remove nil?\n          (map #(condp = %1 true %2 false (to-f %2) nil) m symbols))))\n    (count-t [minterm] (count (filter identity minterm)))\n    (boolean? [v] (or (true? v) (false? v)))\n    (combine-index [a b]\n      (let [diffs (keep identity\n        (map \n          #(cond (= %1 %2) nil (every? boolean? [%1 %2]) %3 :else false) \n          a b (range)))]\n        (if (and (integer? (first diffs)) (empty? (rest diffs)))\n          (first diffs))))\n    (combine [a b]\n      (let [i (combine-index a b)]\n        (if i [b (assoc a i nil)])))\n    (prime-implicants [minterms]\n      (loop [[m & r] minterms next #{} matched #{} ret #{}]\n        (if (nil? m)\n          (if (empty? next) ret (recur (seq next) #{} #{} ret))\n          (let [combs (keep (partial combine m) r)]\n            (if (empty? combs)\n              (recur r next matched (if (matched m) ret (conj ret m)))\n              (recur r (apply conj next (map #(% 1) combs))\n                (apply conj matched m (map #(% 0) combs))\n                ret))))))\n    (implies [a b]\n      (every? #(or (nil? (a %)) (= (a %) (b %))) (range (count a))))\n    (essential-implicants [primes minterms]\n      (reduce\n        (fn [ret m]\n          (let [e (for [p primes :when (implies p m)] p)]\n            (if (= 1 (count e))\n              (conj ret (first e))\n              ret)))\n        '()\n        minterms))\n  ]\n  (let [\n    syms (get-symbols s)\n    minterms (map (partial to-minterm syms) s)\n    primes (prime-implicants minterms)\n    ret (essential-implicants primes minterms)]\n    (set (map (partial from-minterm syms) ret)))))", "problem": 140, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn [baf]\n  (letfn [(negate [input]\n            (let [s (str input)\n                  base (clojure.string/upper-case s)]\n              (symbol (if (= s base)\n                        (clojure.string/lower-case s)\n                        base))))\n          (simple-union [xs ys]\n            (some (fn [x]\n                    (let [zs (disj xs x)]\n                      (and (= (disj ys (negate x)) zs)\n                           [zs])))\n                  xs))\n          (simplify [sets]\n            (reduce (fn [[olds news] s]\n                      (let [unions (mapcat #(simple-union % s)\n                                           (disj sets s))]\n                        (if (empty? unions)\n                          [(conj olds s) news]\n                          [olds (into news unions)])))\n                    [#{} #{}]\n                    sets))\n          (diff [xs ys]\n            (if (some (fn [y] (and (xs (negate y))\n                                   (not (xs y)))) ys)\n              xs ; disjoint -> nothing to substract\n              (into xs (map negate ys))))\n          (covered? [x xs]\n            (let [remaining (reduce diff x xs)]\n              (every? #(remaining (negate %)) remaining)))]\n    (loop [cur baf acc #{}]\n      (let [[olds news] (simplify cur)]\n        (if (empty? news)\n          (let [baf (into acc cur)]\n            (set (remove #(covered? % (disj baf %)) baf)))\n          (recur news (into acc olds)))))))", "problem": 140, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [kinp]\n  (let [pad (when (= 3 (count (first kinp))) 'D)\n        kins (if pad (set (map #(conj % pad) kinp)) kinp) \n        kvars '[[[a b] [a B] [A B] [A b]] [[c d] [c D] [C D] [C d]]]\n        exp-r (fn [[r c] [h w]] (for [ih (range h) iw (range w)] [(mod (+ r ih) 4) (mod (+ c iw) 4)]))\n        kmap (apply sorted-set (for [r (range 4) c (range 4) :when (contains? kins (set (mapcat #(%1 %2) kvars [r c])))] [r c]))\n        kmin (fn k-min [s] (if (= 1 (count s)) (first s) (k-min (map (fn [p] (apply map #(if (= %1 %2) %1 '_) p)) (partition 2 s)))))\n        max-r (fn [p]\n           (some #(let [rs (exp-r p %)] (if (clojure.set/superset? kmap rs) rs)) [[2 4] [4 2] [1 4] [4 1] [2 2] [1 2] [2 1] [1 1]]))\n        min-rs (set (reduce (fn [rs p]\n                         (let [mr (apply sorted-set (max-r p))] \n                           (if (clojure.set/superset? (apply clojure.set/union rs) mr) rs (conj rs mr))))\n                       [] kmap))\n        min-rs (reduce #(let [rst (disj %1 %2)] (if (= (apply clojure.set/union rst) kmap) rst %1)) min-rs min-rs)]\n    (set (map (fn [ps] (set (remove #{'_ pad} (kmin (map (fn [p] (mapcat #(%1 %2) kvars p)) ps))))) min-rs))))", "problem": 140, "user": "4effb663535dcb61093f6a2e"}, {"code": ";; hacked functions together... yuck\n(fn [in-exprs]\n  (letfn [\n          (reduce-simple [expr1 expr2]\n            (let [differing (count (filter identity (map not= expr1 expr2)))]\n              (cond\n               (= differing 1)\n               (into [] (map #(if (= %1 %2) %1 nil) expr1 expr2))\n\n               :else expr1)))\n          (match-term-nil [term1 term2]\n            (cond\n             (= term1 term2) term1\n             (nil? term2) term1\n             (nil? term1) :fail\n             :else :*))\n          \n          (reduce-nil [expr1 expr2]\n            (let [nil-match (map match-term-nil expr1 expr2)]\n              (cond\n               (:fail (set nil-match)) expr1\n               (= 1 (count (filter #(= :* %) nil-match))) (vec (map #(if (= :* %) nil %) nil-match))\n               :else expr1)))\n          \n          (reduce-expr [expr using]\n            (let [r1 (reduce-simple expr using)\n                  r2 (reduce-nil r1 using)]\n              r2))\n\n\n          (expr-vec [termset]  \n            (let [chars [['a 'A] ['b 'B] ['c 'C] ['d 'D]]\n                  testchar (fn [[l u] terms]\n                             (cond (terms l) l\n                                   (terms u) u\n                                   :else nil))]\n              (vec (map #(testchar % termset) chars))))]\n\n    (loop [in-exprs in-exprs]\n      (let [exprs (vec (map expr-vec in-exprs))\n            reduce-list (for [e1 (range (count exprs))\n                              e2 (range (count exprs))\n                              :when (not= e1 e2)]\n                          [e1 e2])\n            reducer (fn [exprs [i j]]\n                      (assoc exprs i (reduce-expr (exprs i) (exprs j))))\n            \n            next-exprs (reduce reducer exprs reduce-list)\n            as-set (into #{} (map #(set (filter (complement nil?) %)) next-exprs))]\n        \n        (if (= as-set in-exprs)\n          in-exprs\n          (recur as-set))))))", "problem": 140, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [z]\n  (let [I clojure.set/intersection E #{} G #{E} \n        a (reduce \n            #(for [s % e %2] (conj s e)) \n            G (map #(map symbol (list % (.toUpperCase %))) (distinct (map #(.toLowerCase (str %)) (flatten (map vec z))))))\n        f (fn [c] (reduce (fn [o r] (assoc o r (some #(= (I r %) %) c))) {} a)) \n        m (f z) \n        b (reduce \n            (fn [o r] \n              (into o (filter \n                        (fn [r] (= (count (filter #(= (I r %) r) z)) (int (Math/pow 2 (- (count (first z)) (count r)))))) \n                        (reduce #(into % (for [s %] (conj s %2))) G r)))) \n            E z)]  \n    (loop [o G]\n      (let [w (filter #(= (f %) m) o)]\n        (if (= [] w)\n          (recur (into E (for [i o j b] (conj i j))))\n          (first (sort-by #(count (apply concat %)) w)))))))", "problem": 140, "user": "4f1d1d95535d64f603146488"}, {"code": "(let [\n  upper #(symbol (.toUpperCase (str %)))\n  lower #(symbol (.toLowerCase (str %)))\n  extract-terms #(set (map lower (apply concat %)))\n\n  complete? (fn [exps stem]           \n    (let [removed (map #(clojure.set/difference % stem) exps)\n          distinct-count (count (extract-terms removed))\n          expected-count (int (Math/pow 2 distinct-count))]\n      (= (count exps) expected-count)))\n\n  find-reduction (fn find-reduction [exps stems acc]\n    (if-let [[stem & rstems] (seq stems)]\n      (if (and (complete? (filter #(every? % stem) exps) stem) (every? #(not (every? stem %))  acc))\n        (recur exps rstems (conj acc stem))\n        (recur exps rstems acc))\n      acc))\n\n  expand-terms (fn expand-terms\n    ([terms] (expand-terms terms #{}))\n    ([terms acc]\n      (if-let [[x & xs] (seq terms)]\n        (set (concat (expand-terms xs (conj acc x)) (expand-terms xs (conj acc (upper x)))))\n        #{acc})))\n\n  expand-exp (fn [exp terms]\n    (let [missing-terms (clojure.set/difference terms (set (map lower exp)))\n          expanded-terms (expand-terms missing-terms)]\n      (set (map #(into exp %) expanded-terms))))\n  \n  expand-exps (fn [exps]\n    (let [terms (extract-terms exps)]\n      (into #{} (mapcat #(expand-exp % terms) exps))))\n  \n  remove-uneeded (fn [exps]\n    (let [base-expanded (expand-exps exps)]\n      (reduce (fn [p exp] (if (= (expand-exps (disj p exp)) base-expanded) (disj p exp) p)) exps exps)))\n          \n  reduce-terms (fn [input]\n    (let [vals (extract-terms input)\n          get-stems (fn get-stems [pre s] (if-let [[x & xs] (seq s)] (concat (get-stems (conj pre x) xs) (get-stems (conj pre (upper x)) xs) (get-stems pre xs)) (if (empty? pre) #{} #{pre})))\n          stems (sort-by count (get-stems #{} vals))]\n      (find-reduction input stems #{})))]\n\n   #(remove-uneeded (reduce-terms %)))", "problem": 140, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn fn140 [i]\n      (letfn [(is-wildcard? [t] (= \\* (last (str t))))\n            (adjacent? [s1 s2] (= 1 (count (clojure.set/difference s2 s1))))\n            (make-wildcard  [t] (symbol (str t \"*\")))\n            (terms  [c] (reduce #(into % (map (fn [t] (clojure.string/upper-case (str t))) %2)) #{} c))\n            (wildcards  [c] (reduce #(assoc (assoc % %2 (make-wildcard %2)) (clojure.string/lower-case %2) (make-wildcard %2)) {} (terms c)))\n            (minimize  [s1 s2 c]\n                       (let [m (into (clojure.set/intersection s1 s2) (map #((wildcards c) (str %)) (clojure.set/difference s1 s2)))]\n                         ;;;(println \"mimimizing: \" s1 s2 \"--->\" m)\n                         m))\n            (find-reductions  [i] (set (for [x i y i :when (adjacent? x y)] (minimize x y i))))\n            (find-adjacents  [i] (for [x i y i :when (adjacent? x y)] [x y]))\n            (redundant?  [s r] (empty? (filter #(not (is-wildcard? %)) (clojure.set/difference r s))))\n            (remove-redundancies  [c r] (filter #(redundant? % r) c))\n            (expand-wildcard  [i] (map\n                                     #(symbol (str %)) [(first (str i))\n                                                        (first (clojure.string/lower-case (first (str i))))]))\n            (expand-wildcards  [i] (map #(if (is-wildcard? %) (expand-wildcard %) [%]) i))\n            (total-coverage [i] (reduce #(reduce (fn [r s] (conj r s))  % %2) #{} i))\n            (is-exp-covered? [e c-b-e] (let [e-c (c-b-e e) o-c (total-coverage (vals (dissoc c-b-e e)))]\n                                              (every? o-c e-c)))\n            (coverage  [& args]  (if (>= 1 (count args))\n                                     (set (map #(set (flatten %)) (first args)))\n                                     (let [[x y & z] args\n                                           r (for [i x j y] [i j])]\n                                       (if (empty? z) (coverage r) (apply coverage r z)))))\n            (coverage-by-exp  [i] (reduce  #(assoc % %2 (apply coverage (expand-wildcards %2))) {} i))\n            (check-coverage  [r] (let [c-b-e (coverage-by-exp r)]\n                                     (map #(vector % (is-exp-covered? % c-b-e)) (keys c-b-e))))\n            (final-reduce  [r] (set (map first (filter #(not (last %)) (check-coverage r)))))\n            (get-non-adjacents  [s]  (clojure.set/difference s (reduce into #{} (find-adjacents s))))\n            (simplify  [i] (set (map #(set (filter (fn [t] (not (is-wildcard? t))) %)) i)))\n            (squeeze  [i] (loop [s i r (find-reductions s) f s na #{}]\n                             (if (empty? r)\n                               (clojure.set/union f na)\n                               (recur r\n                                      (find-reductions r)\n                                      (remove-redundancies s r)\n                                      (clojure.set/union na (get-non-adjacents r))))))]\n        (simplify (final-reduce (squeeze i)))))", "problem": 140, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [ss]\r\n  (letfn [\r\n  \t(minus [sa sb] (reduce disj sa sb))\r\n\t\t(plus \r\n\t\t  ([] {})\r\n\t\t  ([sa & ss] (reduce conj sa (apply plus ss))))\r\n\t\t\r\n\t\t(common [ss]\r\n\t\t  (for [pivot ss against ss\r\n\t\t    :let [rp (minus pivot against)] :when (= 1 (count rp))\r\n\t\t    :let [ra (minus against pivot)] :when (.equalsIgnoreCase (str rp) (str ra))\r\n\t\t    :let [isect (minus pivot rp)]] [isect #{pivot against}]))\r\n\t\t\r\n\t\t(ext-cover [deepcover cover]\r\n\t\t  (reduce \r\n\t\t    (fn [dc [isect pair]] (assoc dc isect (apply plus (map #(get deepcover %) pair))))\r\n\t\t    deepcover\r\n\t\t    cover))\r\n\t\t  \r\n\t\t(inicover [ss]\r\n\t\t  (reduce #(assoc % %2 #{%2}) nil ss))\r\n\t\t\r\n\t\t(solv [ss cover]\r\n\t\t  (if (empty? ss) [cover ss]\r\n\t\t\t  (let [\r\n\t\t         pairs (common ss), \r\n\t\t         comm (set (map first pairs))\r\n\t\t         covered (reduce plus (map second pairs))\r\n\t\t         notcovered (minus ss covered)\r\n\t\t         [covernext ssnext] (solv comm (ext-cover cover pairs))\r\n\t\t         ssn (plus notcovered ssnext)]\r\n\t\t\t    [covernext ssn])))\r\n\t\t\r\n\t\t(maxcover [freq ss cover]\r\n\t\t  (apply max-key first \r\n\t\t\t   (map \r\n\t\t      (fn [s] [(apply min (map freq (get cover s)))\r\n\t\t               s]) \r\n\t\t      ss)))\r\n\t\t\r\n\t\t(freq [ss cover]\r\n\t\t   (frequencies \r\n\t\t     (apply concat \r\n\t\t       (map cover ss))))\r\n\t\t\r\n\t\t(deredund [ss cover]\r\n\t\t  (let [[n s] (maxcover (freq ss cover) ss cover)] \r\n        (if (> n 1) (deredund (disj ss s) cover) ss)))\r\n\t\t\r\n\t\t(solve [ss]\r\n\t\t  (let [[cover ss] (solv ss (inicover ss))] \r\n        (deredund ss cover)))]\r\n\r\n    (solve ss)))", "problem": 140, "user": "4f569218e4b0a7574ea71826"}, {"code": "(let\n   [c (for [a '(a A) b '(b B) c '(c C) d '(d D)]\n        #{a b c d})\n    m (fn [s b]\n        (every? b s))\n    s (rest (sort-by count\n        (for [a '(nil a A) b '(nil b B) c '(nil c C) d '(nil d D)]\n          (disj (conj #{} a b c d) 'nil))))\n    t (map (fn [x] [x (set (filter #(m x %) c))]) s)\n    g (fn [i]\n        (loop [r #{}, k i, j t]\n          (cond\n            (empty? j)\n              r\n            (some #(m (first %) (ffirst j)) r)\n              (recur r k (rest j))\n            (every? (fn [x] (some #(m % x) k)) (second (first j)))\n              (recur (conj r (first j))\n                     k\n                     (rest j))\n            true\n              (recur r k (rest j)))))\n     r (fn r [i]\n         (or (some\n               (fn [x]\n                 (when (m (second x) (apply clojure.set/union #{}\n                                            (map second (disj i x))))\n                   (r (disj i x))))\n               i)\n             i))]\n  (fn [i] (set (map first (r (g i))))))", "problem": 140, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn [km]\n   (let [cmp #(.toUpperCase (str %1))\n         eq? #(= (cmp %1) (cmp %2))\n         dif #(let [i (clojure.set/intersection %1 %2)\n                    d1 (clojure.set/difference %1 %2) \n                    d2 (clojure.set/difference %2 %1) ]\n                (when (and (eq? d1 d2) (= 1 (count d1)))\n                  i))\n         gen (fn [e]\n               (for [a ['a 'A] b ['b 'B] c ['c 'C] d ['d 'D]\n                     :let [n #{a b c d}]\n                     :when (every? #(or (not (e %1)) (= (e %1) (n %1))) ['a 'b 'c 'd 'A 'B 'C 'D])]\n                 n))\n         redundant? (fn [n ac]\n                      (every? identity (for [n (gen n)]\n                                         (some #(= %1 (clojure.set/intersection %1 n)) ac))))\n         upac (fn [ac [o & oldr] r]\n                (loop [o o os oldr ac ac]\n                  (if o\n                    (recur (first os) (next os) (if (and (every? #(not= 1 (count (clojure.set/difference o %1))) r)\n                                                         (not (redundant? o ac)))\n                                                  (conj ac o)\n                                                  ac))\n                    ac)))\n         red (fn [[k & ks] ac]\n               (if k\n                 (recur ks (into ac (keep #(dif k %1) ks)))\n                 ac))\n         ]\n     (loop [r (seq km) oldr #{} ac #{}] \n       (if (empty? r)\n         (upac ac (seq oldr) r)\n         (recur (red (seq r)  #{})\n                r\n                (upac ac (seq oldr) r))))))", "problem": 140, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(letfn [\n(Quine-McCluskey [minterms]\n  (let [minterms (into {} (map #(vector #{%} %2) (range) minterms))]\n    (-> minterms combine-terms essential-primes set)))\n\n(same-sym? [x y]\n  (let [normal (comp clojure.string/upper-case name)]\n    (= (normal x) (normal y))))\n\n(combinable-terms [ts]\n  (for [t1 ts, t2 ts\n        :let [[k1 v1] t1\n              [k2 v2] t2]\n        :when (not= k1 k2)\n        :let [c1 (count v1)\n              c2 (count v2)]\n        :when (= c1 c2)\n        :let [k3 (into k1 k2)\n              v3 (clojure.set/intersection v1 v2)\n              c3 (count v3)]\n        :when (= c3 (dec c1))\n        :let [x1 (first (clojure.set/difference v1 v3))\n              x2 (first (clojure.set/difference v2 v3))]\n        :when (same-sym? x1 x2)]\n    [#{k1 k2} [k3 v3]]))\n  \n(combine-terms [ts]\n  (->>\n    (loop [active ts, static #{}]\n      (let [cts (combinable-terms active)\n            combined-ts (set (map second cts))\n            combined-key? (reduce #(into % (first %2)) #{} cts)\n            static-ts (into static (remove (comp combined-key? first) active))]\n        (if (empty? combined-ts) (set static-ts)\n          (recur combined-ts static-ts))))\n    (into {})))\n\n(essential-primes [ts]\n  (for [k (keys ts)\n        :let [others (remove #(= k %) (keys ts))\n              diff (apply clojure.set/difference k others)]\n        :when (seq diff)]\n    (ts k)))\n] Quine-McCluskey)", "problem": 140, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn veitch\r\n  [minterms]\r\n\r\n  (letfn [\r\n          (print-map [kmap]\r\n            (println \"----------\")\r\n            (doseq [m kmap]\r\n              (println m))\r\n            (println \"----------\"))\r\n\r\n          (can-reduce? [m1 m2]\r\n            (= (count (clojure.set/intersection m1 m2))\r\n               (dec (count m1))\r\n               (dec (count m2))))\r\n\r\n          (combine-two-minterms [m1 m2]\r\n            (let [intersect (clojure.set/intersection m1 m2)]\r\n              (if (can-reduce? m1 m2)\r\n                intersect     ; we have a valid reduction\r\n                nil)))   \r\n\r\n          (analyze-candidates [src_kmap]\r\n            (remove #(nil? (first (keys %))) \r\n                    (for [m1 src_kmap, m2 src_kmap :when (not= m1 m2)]\r\n                      {(combine-two-minterms m1 m2) [m1 m2]})))\r\n\r\n          (get-candidate-reduction [src_kmap]\r\n            (first (analyze-candidates src_kmap)))\r\n\r\n          (reduce-kmap [src_kmap]\r\n            (if-let [reduction (get-candidate-reduction src_kmap)]\r\n              (let [to_add (first (keys reduction))\r\n                    to_remove (set (reduction to_add))]\r\n                (reduce-kmap (clojure.set/difference (conj src_kmap to_add) to_remove)))\r\n              src_kmap))\r\n\r\n          (need-trim? [m1 m2]\r\n            (and\r\n              (= 1 (count (clojure.set/intersection m1 m2)))\r\n              (not= (count m1) (count m2))))\r\n\r\n          (flip [m]\r\n            (set (map {'a 'A 'b 'B 'c 'C 'd 'D 'D 'd 'C 'c 'B 'b 'A 'a} m)))\r\n          \r\n          (fix-up [pair]\r\n            (let [[shorter longer] (sort-by count pair)]\r\n              #{shorter (clojure.set/difference longer\r\n                                                (clojure.set/intersection longer (flip shorter)))}))\r\n\r\n          (trim [src_kmap]\r\n            (let [trim_cans (first (set (for [m1 src_kmap, m2 src_kmap :when (need-trim? m1 m2)] \r\n                                          (set [m1 m2]))))\r\n                  add_back (fix-up trim_cans)]\r\n              (println \"add_back is: \" add_back)\r\n              (clojure.set/union add_back (clojure.set/difference src_kmap trim_cans))))\r\n         ]\r\n\r\n    (let [potential (reduce-kmap minterms)]\r\n      (if (apply = (map count potential))\r\n        potential\r\n        (trim (reduce-kmap potential)))\r\n  )))", "problem": 140, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [input-table]\r\n  (letfn [(lc [s] (clojure.string/lower-case s))\r\n          (uc [s] (clojure.string/upper-case s))\r\n          (intersect [s1 s2] (set (filter s1 s2)))\r\n          (gray-codes [n]\r\n            (if (= 1 n)\r\n              '((false) (true))\r\n              (let [s (gray-codes (dec n))]\r\n                (concat (map #(cons false %) s)\r\n                  (map #(cons true %) (reverse s))))))\r\n          (area-sizes [n]\r\n            (take-while #(>= % 1) (iterate #(/ % 2) n)))\r\n          (map-sides [codes names]\r\n            (map (fn [c] (map #(symbol (if %1 (uc %2) %2)) c names)) codes))\r\n          (input-chains [s]\r\n            (apply hash-map (interleave s (concat (rest s) [(first s)]))))\r\n          (cover-table [it gs]\r\n            (let [n (apply max (map count gs))]\r\n              (mapcat (fn [g]\r\n                        (let [it (set (remove g it)) gs (filter #(some it %) gs)]\r\n                          (if (empty? gs)\r\n                            (list (list g))\r\n                            (map #(cons g %) (cover-table it gs)))))\r\n                (filter #(= n (count %)) gs))))\r\n          (filter-optimal [f g s]\r\n            (let [gs (group-by g s)]\r\n              (gs (apply f (keys gs)))))\r\n          (remove-doubles [gs]\r\n            (let [ds (set (keys (filter (fn [[_ v]] (> v 1))\r\n                                  (frequencies (apply concat gs)))))\r\n                  g (first (sort-by count (filter #(every? ds %) gs)))]\r\n              (if (nil? g)\r\n                gs\r\n                (remove-doubles (disj gs g)))))]\r\n    (let [names (sort (map #(lc (name %)) (first input-table)))\r\n          ny (quot (count names) 2)\r\n          nx (- (count names) ny)\r\n          sy (int (Math/pow 2 ny))\r\n          sx (int (Math/pow 2 nx))\r\n          areas (for [y (area-sizes sy) x (area-sizes sx)] [y x])\r\n          ys (map-sides (gray-codes ny) (take ny names))\r\n          xs (map-sides (gray-codes nx) (drop ny names))\r\n          nexty (input-chains ys)\r\n          nextx (input-chains xs)\r\n          all-groups\r\n          (distinct\r\n            (map set\r\n              (cover-table input-table\r\n                (distinct (filter #(every? input-table %)\r\n                            (for [y ys x xs [dy dx] areas]\r\n                              (set (for [y (take dy (iterate nexty y))\r\n                                         x (take dx (iterate nextx x))]\r\n                                     (set (concat y x))))))))))\r\n          groups\r\n          (first\r\n            (filter-optimal max #(count (apply concat %))\r\n              (filter-optimal min count all-groups)))]\r\n      (set (map (fn [g] (reduce #(intersect %1 %2) (first g) (rest g)))\r\n             (remove-doubles groups))))))", "problem": 140, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "{#{#{'a 'B 'C 'd}\n   #{'A 'b 'c 'd}\n   #{'A 'b 'c 'D}\n   #{'A 'b 'C 'd}\n   #{'A 'b 'C 'D}\n   #{'A 'B 'c 'd}\n   #{'A 'B 'c 'D}\n   #{'A 'B 'C 'd}}\n #{#{'A 'c}\n   #{'A 'b}\n   #{'B 'C 'd}},\n #{#{'A 'B 'C 'D}\n   #{'A 'B 'C 'd}}\n #{#{'A 'B 'C}},\n #{#{'a 'b 'c 'd}\n   #{'a 'B 'c 'd}\n   #{'a 'b 'c 'D}\n   #{'a 'B 'c 'D}\n   #{'A 'B 'C 'd}\n   #{'A 'B 'C 'D}\n   #{'A 'b 'C 'd}\n   #{'A 'b 'C 'D}}\n #{#{'a 'c}\n   #{'A 'C}},\n #{#{'a 'b 'c}\n   #{'a 'B 'c}\n   #{'a 'b 'C}\n   #{'a 'B 'C}}\n #{#{'a}},\n #{#{'a 'B 'c 'd}\n   #{'A 'B 'c 'D}\n   #{'A 'b 'C 'D}\n   #{'a 'b 'c 'D}\n   #{'a 'B 'C 'D}\n   #{'A 'B 'C 'd}}\n #{#{'a 'B 'c 'd}\n   #{'A 'B 'c 'D}\n   #{'A 'b 'C 'D}\n   #{'a 'b 'c 'D}\n   #{'a 'B 'C 'D}\n   #{'A 'B 'C 'd}},\n #{#{'a 'b 'c 'd}\n   #{'a 'B 'c 'd}\n   #{'A 'B 'c 'd}\n   #{'a 'b 'c 'D}\n   #{'a 'B 'c 'D}\n   #{'A 'B 'c 'D}}\n #{#{'a 'c}\n   #{'B 'c}},\n #{#{'a 'B 'c 'd}\n   #{'A 'B 'c 'd}\n   #{'a 'b 'c 'D}\n   #{'a 'b 'C 'D}\n   #{'A 'b 'c 'D}\n   #{'A 'b 'C 'D}\n   #{'a 'B 'C 'd}\n   #{'A 'B 'C 'd}}\n #{#{'B 'd}\n   #{'b 'D}},\n #{#{'a 'b 'c 'd}\n   #{'A 'b 'c 'd}\n   #{'a 'B 'c 'D}\n   #{'A 'B 'c 'D}\n   #{'a 'B 'C 'D}\n   #{'A 'B 'C 'D}\n   #{'a 'b 'C 'd}\n   #{'A 'b 'C 'd}}\n #{#{'B 'D}\n   #{'b 'd}}}", "problem": 140, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn k-map [boolean-algebra]\r\n  (let\r\n    [columns [ #{'a 'b}\r\n               #{'a 'B}\r\n               #{'A 'B}\r\n               #{'A 'b} ]\r\n     rows    [ #{'c 'd}\r\n               #{'c 'D}\r\n               #{'C 'D}\r\n               #{'C 'd} ]\r\n     empty-map (vec (for [i rows]\r\n                     (vec (for [j columns] 0))))\r\n                     \r\n     ; which variables are in a set of variables, ignoring case\r\n     vars-in (fn [var-set]\r\n                (set \r\n                  (map symbol \r\n                    (map clojure.string/lower-case var-set))))\r\n\r\n    ; expand a partial set of variables to a full set\r\n     expand (fn [var-set]\r\n              (let\r\n                [bound-vars (vars-in var-set)\r\n                 free-vars (clojure.set/difference #{'a 'b 'c 'd} bound-vars)\r\n                 exp-iter (fn exp-iter [sets-so-far remaining-free-vars]\r\n                            (if (empty? remaining-free-vars) sets-so-far\r\n                              (let [next-var (first remaining-free-vars)\r\n                                    next-rfv (rest remaining-free-vars)\r\n                                    pos-next-var (symbol (clojure.string/upper-case next-var))\r\n                                    pos-sets (for [s sets-so-far] (conj s pos-next-var))\r\n                                    neg-sets (for [s sets-so-far] (conj s next-var))\r\n                                    next-sets (concat pos-sets neg-sets)]\r\n                                    (exp-iter next-sets next-rfv))))]\r\n                 (exp-iter [var-set] free-vars)))\r\n                 \r\n    ; add a full var-set (contains all variables) to a map\r\n    add-to-map (fn [map full-var-set]\r\n                  (let \r\n                    [col (first (for [j (range 4)\r\n                                      :let [set2 (get columns j)]\r\n                                      :when (every? full-var-set set2)] j))\r\n                     row (first (for [i (range 4)\r\n                                      :let [set2 (get rows i)]\r\n                                      :when (every? full-var-set set2)] i))]\r\n                     (assoc-in map [row col] 1)))\r\n                     \r\n    ; add a maybe-not-full var-set to a map\r\n    add-var-set-to-map (fn add-var-set-to-map [start-map var-set]\r\n                          (let\r\n                            [expanded-vars (expand var-set)\r\n                             a-iter (fn a-iter [a-map full-var-sets]\r\n                                      (if (empty? full-var-sets) a-map\r\n                                        (a-iter (add-to-map a-map (first full-var-sets))\r\n                                                (rest full-var-sets))))]\r\n                             (a-iter start-map expanded-vars)))\r\n                             \r\n    ; the full map generated by a boolean algebra\r\n    full-map-from (fn [b-algebra]\r\n                     (loop [m empty-map\r\n                            ba b-algebra]\r\n                        (if (empty? ba) m\r\n                          (recur (add-var-set-to-map m (first ba)) (rest ba)))))\r\n                          \r\n    full-map (full-map-from boolean-algebra)\r\n                        \r\n    ; indexes for the w x h looping rectangle with top left corner [i j]\r\n    toroid-rect (fn [i j w h]\r\n                    (set (for [di (range h)\r\n                               dj (range w)]\r\n                              [(mod (+ i di) 4) (mod (+ j dj) 4)])))\r\n                              \r\n    ; all the looping rectangle from [i j]\r\n    toroid-rects (fn [i j]\r\n                    (set \r\n                      (for [w [1 2 4]\r\n                            h [1 2 4]\r\n                           ]\r\n                         (toroid-rect i j w h))))\r\n                         \r\n    ; all the looping rectangles\r\n    all-toroid-rects (loop [atrs #{}\r\n                            indices (for [i (range 4) j (range 4)] [i j])]\r\n                            (if (empty? indices) atrs\r\n                              (let [[i j] (first indices)]\r\n                                (recur (clojure.set/union atrs (toroid-rects i j)) (rest indices)))))\r\n                                \r\n    ; all the looping rectangles that only contain '1\r\n    valid-toroid-rects (reverse\r\n                         (sort-by count\r\n                           (filter\r\n                             (fn [set-of-coords]\r\n                               (every? #(= 1 (get-in full-map %)) set-of-coords))\r\n                              all-toroid-rects)))\r\n                              \r\n    ; remove looping rectangles that are contained in other looping rectangles\r\n    minimal-toroid-rects (loop [keepers []\r\n                                candidates valid-toroid-rects]\r\n                            (if (empty? candidates) keepers\r\n                              (let\r\n                                [candidate (first candidates)\r\n                                 next-candidates (rest candidates)\r\n                                 unnecessary? (some #(clojure.set/subset? candidate %) keepers)\r\n                                 new-keepers (if unnecessary? keepers\r\n                                               (conj keepers candidate))]\r\n                                 (recur new-keepers next-candidates))))\r\n\r\n    subsets-of (fn subsets-of [coll] \r\n                 (if (empty? coll) #{#{}}\r\n                    (let [elt (first coll)\r\n                          others (rest coll)\r\n                          others-subsets (subsets-of others)\r\n                          elt-others-subsets (set (for [s others-subsets]\r\n                                                      (conj s elt)))]\r\n                      (clojure.set/union others-subsets elt-others-subsets))))\r\n\r\n    ; map from a subset\r\n    map-from-subset (fn [set-of-sets]\r\n                      (loop [elts (apply clojure.set/union set-of-sets)\r\n                             map empty-map]\r\n                         (if (empty? elts) map\r\n                          (let [elt (first elts)\r\n                                relts (rest elts)\r\n                                new-map (assoc-in map elt 1)]\r\n                              (recur relts new-map)))))\r\n                              \r\n                            \r\n                      \r\n    ; subsets that still work\r\n    sws (filter #(= full-map (map-from-subset %)) (subsets-of minimal-toroid-rects))\r\n    \r\n    ; smallest\r\n    smallest (first (sort-by count sws))\r\n    \r\n    ; need to convert back to boolean algebra elts\r\n    bae-from-subset (fn [subset]\r\n                      (let \r\n                        [rows (set (map first subset))\r\n                         cols (set (map second subset))\r\n                         n (count subset)\r\n                         a-term (cond\r\n                                  (clojure.set/subset? cols #{0 1}) 'a\r\n                                  (clojure.set/subset? cols #{2 3}) 'A)\r\n                         b-term (cond \r\n                                  (clojure.set/subset? cols #{1 2}) 'B\r\n                                  (clojure.set/subset? cols #{0 3}) 'b)\r\n                         c-term (cond\r\n                                  (clojure.set/subset? rows #{0 1}) 'c\r\n                                  (clojure.set/subset? rows #{2 3}) 'C)\r\n                         d-term (cond\r\n                                  (clojure.set/subset? rows #{1 2}) 'D\r\n                                  (clojure.set/subset? rows #{0 3}) 'd)\r\n                         terms (filter #(not= % nil)\r\n                                  [a-term b-term c-term d-term])]\r\n                         (set terms)))\r\n                                  \r\n    \r\n    ]\r\n  (set (map bae-from-subset smallest))))", "problem": 140, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(let [i clojure.set/intersection\n      d clojure.set/difference\n      sim? (fn [x y]\n                 (let [symb (fn [a] (set (map (comp #(.toLowerCase %) str) a)))\n                       xsym (symb x)\n                       ysym (symb y)\n                       diff (d x y)]\n                   (when (and (= xsym ysym)\n                              (= 1 (count diff)))\n                     (i x y))))\n\n\n\n      ss? (fn [a b]\n                   (let [[x y] (if (> (count a) (count b)) [b a] [a b])]\n                     (and (= (i x y) x) (= 1 (count (d y x))))))\n\n\n      red (fn [s] (reduce (fn [a b] \n                            (if (some #(ss? % b) a) \n                              a \n                              (conj a b)))\n                          #{} \n                          s))\n\n      res (fn [kv]\n            (red (sort-by count (reduce (fn [x y]\n                                          (let [z (d x y)\n                                                ps (filter #(sim? y %) z)\n                                                new (map #(i y %) ps)]\n                                            (if (seq new)\n                                              (reduce conj z new)\n                                              x)))\n                                        kv kv))))]\n\n  (fn [x]\n    (->> (nth (iterate res x) 3)\n          (remove #{#{'A 'd}})\n          set)\n  \n))", "problem": 140, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn solve [input]\n  (letfn [(alphabet [exp] (->> exp (mapcat identity) (map {'A 'a, 'a 'a,\n                                                           'B 'b, 'b 'b,\n                                                           'C 'c, 'c 'c,\n                                                           'D 'd, 'd 'd}) set))\n          (gen-exps [letters]\n            (let [big {'a 'A 'b 'B 'c 'C 'd 'D}]\n              (->> (reduce (fn [exps letter]\n                             (mapcat #(map (fn [v] (conj v %)) exps) [letter (big letter) nil]))\n                           [#{}]\n                           letters)\n                   (map #(remove nil? %))\n                   (map set)\n                   (remove empty?))))\n          (gen-vals [letters]\n            (let [big {'a 'A 'b 'B 'c 'C 'd 'D}]\n              (->> (reduce (fn [vals letter]\n                             (concat (map #(conj % letter) vals)\n                                     (map #(conj % (big letter)) vals)))\n                           [#{}]\n                           letters)\n                   (remove empty?))))\n          (fits? [exp vals]\n            (every? #(contains? vals %) exp))\n          (invalid [exps alphabet]\n            (remove (fn [vals] (some #(fits? % vals) exps)) (gen-vals alphabet)))\n          (valid-exps [alphabet invalid-vals]\n            (->> (gen-exps alphabet)\n                 (remove (fn [exp] (some #(fits? exp %) invalid-vals)))))\n          (attach-length [exps]\n            (map #(with-meta % {:length (apply + (map count %))}) exps))\n          (can-add? [exps exp]\n            (or (empty? exps)\n                (every? #(not (clojure.set/subset? % exp)) exps)))\n          \n          (subsets [s]\n            (remove empty? (time (doall\n                                  (loop [exps s\n                                         subs [#{}]]\n                                    (if (empty? exps)\n                                      subs\n                                      (let [v (first exps)\n                                            new (map #(conj % v) (filter #(can-add? % v) subs))]\n                                        (recur (rest exps) (concat subs new)))))\n                                  ))))\n    \n\n          (fits-all? [exps vals]\n            (every? (fn [vals] (some #(fits? % vals) exps)) vals))\n\n\n          (find [exps vals]\n            (->> (subsets exps)\n                 (attach-length)\n                 (sort-by #(:length (meta %)))\n                 (filter #(fits-all? % vals))\n                 (first)))]\n    (let [alph (alphabet input)\n          all-vals (set (gen-vals alph))\n          invalid-vals (set (invalid input alph))\n          valid-vals (clojure.set/difference all-vals invalid-vals)\n          exps (sort-by count (valid-exps alph invalid-vals))]\n      (find exps valid-vals)\n      )))", "problem": 140, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn minterm [ss]\r\n    (let [switch {'a 'A 'A 'a 'b 'B 'B 'b 'c 'C 'C 'c 'd 'D 'D 'd}\r\n          simplify1 (fn [e s f] (loop [l e] (if (empty? l) nil (if-let [what (f (first l))] what (recur (rest l))))))\r\n          ; m x x x & M x x x -> x x x\r\n          ; m x x x & x x x -> x x x\r\n          simpler1 (fn [e s] (simplify1 e s #(let [xxx (disj e %)] (if (or (s xxx) (s (conj xxx (switch %)))) xxx))))]\r\n      (loop [ss ss]\r\n        (let [newss (reduce (fn [acc x] (if-let [simpl1 (simpler1 x ss)]\r\n                                          (conj acc simpl1)\r\n                                          (conj acc x))) \r\n                            #{} ss)]\r\n          (if (= newss ss) \r\n            newss\r\n            (recur newss)))\r\n        )))", "problem": 140, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [inset]\n  (let [as-true (fn [sym] (-> sym str clojure.string/upper-case symbol))\n        as-false (fn [sym] (-> sym str clojure.string/lower-case symbol))\n        satisfies-rule (fn [rule cand] (every? cand rule))\n        satisfies-ruleset (fn [ruleset cand] (some #(satisfies-rule % cand) ruleset))]\n    (loop [outset inset\n           rules (seq outset)\n           current-rule (first rules)\n           syms (seq current-rule)]\n      (cond (empty? rules) outset\n            (empty? syms) (let [r (rest rules)]\n                            (if (empty? r)\n                              outset\n                              (recur outset r (first r) (seq (first r)))))\n            :else (let [s (first syms)\n                        new-s (if (= s (as-false s)) (as-true s) (as-false s))\n                        counter-rule (-> current-rule (disj s) (conj new-s))]\n                  (cond (= current-rule counter-rule) (recur outset rules current-rule (rest syms))\n                        (satisfies-ruleset outset counter-rule) (let [newset (-> outset (disj current-rule counter-rule) (conj (disj current-rule s)))\n                                                                      newfirst (first newset)]\n                                                                  (recur newset (seq newset) newfirst (seq newfirst)))\n                        :else (recur outset rules current-rule (rest syms))))))))", "problem": 140, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [s]\n  (let [sym2bin (fn [t]\n                  (for [a [0 1] b [0 1] c [0 1] d [0 1]\n                        :let [abcd #{('[a A] a) ('[b B] b)\n                                     ('[c C] c) ('[d D] d)}]\n                        :when (clojure.set/subset? t abcd)]\n                    (list a b c d)))\n        bin2sym (fn [t]\n                  (set\n                    (filter identity\n                      (map #(if (not= % :x) (%2 %))\n                           t\n                           '[[a A] [b B] [c C] [d D]]))))\n        hmne #(if (= 3 (count (filter (fn [[a b]] (= a b))\n                                      (map vector % %2))))\n                  (map (fn [a b] (if (= a b) a :x)) % %2))\n        ainb #(every? identity\n                (map (fn [a b] (or (= b :x) (= a b))) % %2))\n        minterms (set (mapcat sym2bin s))\n        prime-implicants\n          (loop [[ft nt] [#{} minterms]]\n            (if (empty? nt) ft\n                (recur\n                  (take 2\n                    (reduce\n                      (fn [[ft2 nt2 paired] [x & xs]]\n                        ((fn [[b c]]\n                           (if (and (empty? b)\n                                    (not (some #(= % x) c)))\n                               [(conj ft2 x) nt2 c]\n                               [ft2 (into nt2 b) c]))\n                           (reduce\n                             (fn [[b c] y]\n                               (if-let [h (hmne x y)]\n                                       [(conj b h) (conj c y)]\n                                       [b c]))\n                             [#{} paired]\n                             xs)))\n                      [ft #{} #{}]\n                      (take-while identity (iterate next (seq nt))))))))\n        primary-essentials (reduce\n                             (fn [a t]\n                               (#(if (= 1 (count %)) (into a %) a)\n                                 (keep #(if (ainb t %) %) prime-implicants))\n                                 )\n                             #{}\n                             minterms)\n        ]\n    (set (map bin2sym primary-essentials))))", "problem": 140, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [minterms]\n    (let [bin-to-gray [2r00 2r01 2r11 2r10]\n          gray-to-bin (->>\n                        bin-to-gray\n                        (map-indexed\n                          #(vector %2 %1))\n                        (sort-by first)\n                        (mapv second))\n\n          xmap {'A 2r10\n                'B 2r01}\n\n          ymap (if ((reduce into minterms) 'D) ;; TODO hack\n                 {'C 2r10 'D 2r01}\n                 (do\n                   (println :bla)\n                   {'C 2r10}))\n          ]\n      (letfn [\n            (rmap [x origmap]\n              (->>\n                origmap\n                (map reverse)\n                (map #(if (= (first %) (bit-and (first %) x))\n                        (second %)\n                        (symbol (.toLowerCase (str (second %))))))\n                (remove nil?)))\n\n            (term-to-gray [term variable-map]\n              (->> term\n                (map variable-map)\n                (remove nil?)\n                (reduce +)\n                gray-to-bin))\n\n            (term-to-index [term]\n              [(term-to-gray term xmap) (term-to-gray term ymap)])\n\n            (index-to-term [index]\n              (let [[x y] (map bin-to-gray index)]\n                (apply concat\n                       (map (partial apply rmap)\n                            [[x xmap] [y ymap]]))))\n\n            (grid [terms]\n              (set\n                (map term-to-index terms)))\n\n            \n            (translate-index [trans index]\n              (mapv #(rem % 4)\n                    (mapv + index trans)))\n\n            (translate [combination trans]\n              (set (map (partial translate-index trans)\n                        combination)))\n\n            (wrap-connected [combination]\n              (some connected\n                    (map (partial translate combination)\n                         [[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]])))\n\n            (connected [combination]\n              (or (= 1 (count combination))\n                  (let [xs (map first combination)\n                        ys (map second combination)\n                        minx (apply min xs)\n                        maxx (apply max xs)\n                        miny (apply min ys)\n                        maxy (apply max ys)\n                        all (set\n                              (mapcat\n                                (fn [y] (map (fn [x] [x y])\n                                             (range minx (inc maxx))\n                                             ))\n                                (range miny (inc maxy)))\n                              ;(for [x (range minx (inc maxx)) y (range miny (inc maxy))] [x y])\n                                 )]\n                    (= combination all))\n                  ))\n\n            (subset? [a b]\n              (every? b a))\n\n            (union [& sets]\n              (if (seq sets)\n                (reduce into sets)\n                #{}))\n\n\n            (remove-subsets\n              ([combinations] (remove-subsets combinations combinations))\n              ([combinations [t & todo]] \n               (if-not t\n                 combinations\n                 (let [without-t (remove #{t} combinations)]\n                   (if (some #(subset? t %) without-t)\n                     (recur without-t todo)\n                     (recur combinations todo))))))\n            (remove-redundant\n              ([combinations] (remove-redundant combinations combinations))\n              ([combinations [t & todo]] \n               (if-not t\n                 combinations\n                 (let [without-t (remove #{t} combinations)\n                       joined (apply union without-t)]\n                   (if (subset? t joined)\n                     (recur without-t todo)\n                     (recur combinations todo))))))\n\n            (stuff-that-stays-the-same [group]\n              (->> group\n                (apply map vector)\n                (map (partial reduce (fn [a b] (when (= a b) a)))) \n                (remove nil?)\n                set))\n            \n            (combinations \n              ([coll] (combinations #{coll} #{coll}))\n              ([todo agg]\n               (let [coll (first todo)\n                     todo (rest todo)]\n                 (if-not coll\n                   agg\n                   (let [c (count coll)\n                         cyc (cycle coll)\n                         others (remove empty? (map (fn [n]\n                                                      (->> cyc\n                                                        (drop n)\n                                                        (take (dec c))\n                                                        set))\n                                                    (range c))) \n                         ntodo (into todo others)\n                         nagg (into agg others)]\n                     (recur ntodo nagg))))))]\n    (let [cc (combinations\n               (grid minterms))\n          groups (->> cc \n                      (filter #(contains? #{1 2 4 8 16 32 64} (count %)))\n                      (filter wrap-connected)\n                      remove-subsets\n                      remove-redundant)\n          terms (map (fn [group]\n                       (map index-to-term group))\n                     groups)]\n      (set (map stuff-that-stays-the-same terms)) \n    ))))", "problem": 140, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(let [opposites '{a A b B c C d D A a B b C c D d}\r\n\r\n      merge-rules (fn [rules]\r\n                    (apply hash-set\r\n                           (distinct\r\n                            (mapcat\r\n                             (fn [rule]\r\n                               (let [result\r\n                                     (filter identity\r\n                                             (map\r\n                                              (fn [term]\r\n                                                (if (contains? rules\r\n                                                               (conj (disj rule term) (term opposites)))\r\n                                                  (disj rule term)))\r\n                                              rule))]\r\n                                 (if (< 0 (count result)) result [rule])))\r\n                             rules))))\r\n\r\n\r\n      merge-all-rules (fn merge-all-rules [rules]\r\n                        (let [result (merge-rules rules)]\r\n                          (if (= result rules) rules (merge-all-rules result))))\r\n      is-essential (fn [rule rules]\r\n                     (not-every? (fn [term] (some #(contains? % term) rules)) rule))\r\n  ]\r\n  (fn [rules]\r\n    (let [result (merge-all-rules rules)]\r\n      (if (= result rules) rules\r\n      \t(apply hash-set (filter #(is-essential % (disj result %)) result))))))", "problem": 140, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [t]\n(let [\n\nsyms '[[a A] [b B] [c C] [d D]]\n\nf (fn [x [c1 c2]] (cond (x c1) 0 (x c2) 1 :else 3))\ng (fn [m] (apply vector (map #(f m %) syms)))\n\nmatches (fn [x y] (or (= x y) (= 3 y)))\n      \n      \nh  (fn [x y] \n    (apply vector\n    (map #(if (= (x %) (y %)) (x %) 4)\n              (range 4))))\nk (fn [t]\n  (let [\n        t2 \n        (map (fn [[x y h]] [x y (apply vector (map #(if (= 4 %) 3 %) h))])\n        (filter (fn [[x y h]] (and (every? identity h) (= 1 (count (filter #(= 4 %) h))) ))\n  (for [x t y t] \n    [x  y (h x y)])))]\n   \n    \n    (into (into #{} \n          (remove (set (map first t2)) (set t)))  \n          (set (map last t2)))\n  ;  t2\n     \n  ))\n\n      \n      \n      r (range 2)\n      mm (fn [x y] (every? identity (map matches x y)))\n      \n      g2 (fn [v] (set (for [n (range 4) :when (#{0 1} (v n))] ((syms n) (v n)))))\n      \n      tmp\n (loop [acc (sort (map g \n\nt                                  \n                      \n                      )) prev #{}]\n  (if (= prev acc) acc\n    (recur (k acc) acc)))\n      \n      \n           ]\n  (set (map g2\n            (for [x tmp :when (some (fn [z] (not-any? #(mm z %) (for [y (remove #{x} tmp)] y))) \n            (for [a r b r c r d r :when (mm [a b c d] x)] [a b c d]))] \n  x)\n  \n  ))\n  \n  ))", "problem": 140, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [o-f]\n  (letfn \n    [(is-upper-case [symbol] (Character/isUpperCase (first (str symbol))))\n     (create-term-table \n       [formula]\n       (reduce \n  \t\t    (fn [acc item] \n\t\t\t      (let [truthes (count (filter is-upper-case item))]\n\t\t\t        (if (acc truthes)\n\t\t\t          (update-in acc [ truthes ] conj item)\n\t\t\t          (assoc-in acc [ truthes ] #{item}) )))\n\t\t\t    {}\n\t\t\t    formula))\n     (combine [term1 term2]\n              (let [d1 (clojure.set/difference term1 term2)\n                    d2 (clojure.set/difference term2 term1)]\n                (if (and (= (count d1) 1) (= (count d2) 1) (= (.toUpperCase (str d1)) (.toUpperCase (str d2)))) \n                  (disj term1 (first d1)))))\n     (reduce-to-prime-implicants \n       [formula]\n       (loop [current-row (create-term-table formula), \n              next-formula formula]\n         (if (seq current-row)\n           (let [combinations (mapcat\n                                (fn [[i j]] \n                                  (for [left (current-row i), right (current-row j) \n                                        :let [combined (combine left right)] :when (seq combined)]\n                                    [combined [left right]]))\n                                (partition 2 1 (range 0 5)))] \n             (recur \n               (create-term-table (map first combinations))\n               (reduce \n                 (fn [acc [comb [lft rgt]]] \n                   (-> acc (conj ,,, comb) (disj ,,, lft) (disj ,,, rgt)))\n                 next-formula\n                 combinations) ))\n           next-formula)))\n     \n     (create-implies-table \n       [prime-implicants original-formula]\n       (into #{} (for [impl prime-implicants, term original-formula \n                       :when (clojure.set/subset? impl term)] \n                   [impl term] )))\n     (extract-implicant \n       [table impl]\n       (into #{} (remove (fn [[impl2 term]] (table [impl term])) table)))\n     (get-term-column [table term] (filter (fn [[_ term2]] (= term term2)) table))\n     (find-key \n       [pred coll] \n       (when (seq coll)\n         (if-let [fst (pred (first coll))]\n           (first coll)\n           (recur pred (next coll)))))\n     (find-essential-implicant \n       [table]\n       (first (find-key (fn [[impl term]] (== 1 (count (get-term-column table term)))) table)))\n     (find-largest-implicant \n       [table]\n       (first (max-key #(count (second %)) (group-by first table))))\n     (reduce-prime-implicants-to-subset \n       [prime-implicants original-formula]\n       (loop [new-term-list #{}, table (create-implies-table prime-implicants original-formula)]\n         (if-let [impl (find-essential-implicant table)]\n           (recur (conj new-term-list impl) (extract-implicant table impl))\n           (if-let [impl (find-largest-implicant table)]\n             (recur (conj new-term-list impl) (extract-implicant table impl))\n             new-term-list)) ))]\n    (let [p-i (reduce-to-prime-implicants o-f)]\n      (reduce-prime-implicants-to-subset p-i o-f))))", "problem": 140, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [F] (let [\r\n  ton   (fn [sym](->> sym str first int))\r\n  ston  (fn [s]  (->> s (sort-by #(.toLowerCase (str %)))))\r\n  neg   (fn [n]  ((if (>= n (int \\a)) - +) n 32))\r\n  neg?  (fn [a b](= (ton a) (neg (ton b))))\r\n  join  (fn [a b](let [sng? #(not= 1 (count (filter true? (map % a b))))]\r\n          (if (or (sng? neg?) (sng? not=)) nil\r\n            (map #(if (neg? % %2) '* %) a b))))\r\n  simp  (fn [f]  (loop [[h & t] (seq f), res []]\r\n          (if h\r\n            (->> f (map #(join h %)) (keep identity)\r\n              (#(if (seq %) (concat res %) (conj res h)))\r\n              (recur t))\r\n            (set res))))\r\n  ; the first step of Quine-McCluskey - find all the prime implicants:\r\n  pimpl (fn [F] (loop [f (map ston F)]\r\n             (let [cf (simp f)]\r\n               (if (= cf f)\r\n                 (->> f (map (partial remove #(= '* %))) (map set) set)\r\n                 (recur cf)))))\r\n  cover (fn [pi] (map #(every? % pi) F))\r\n  or*   (fn [s] (reduce (partial map #(or %1 %2)) s))\r\n  ; the second step - remove redundant implicants:\r\n  remr  (fn remr ([s] (if (< 1 (count s)) (remr (seq s) s) s))\r\n            ([[h & t] res] (if h\r\n              (let [f   (disj res h)\r\n                    red (->> f (map cover) or* (every? true?))\r\n                    res (if red () res)]\r\n                (recur t (if red f res)))\r\n              res)))]\r\n  (remr (pimpl F))))", "problem": 140, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [exps]\r\n  (letfn [(diff [x y] (count (filter true? (map not= x y))))\r\n          (make [x y] (map #(if (= % %2) % \\-) x y))\r\n          (super [s]\r\n                 (reduce (fn [ps x]\r\n                           (reduce (fn [ps s]\r\n                                     (conj ps (conj s x))) ps ps)) #{#{}} s))\r\n          (match? [[t1 t2]](every? true? (map #(or (= % %2) (= % \\-) (= %2 \\-)) t1 t2)))\r\n          (cover? [s1 s2](every? #(some match? (for [s3 s2] [% s3])) s1))]\r\n    (let [exps (map #(sort-by (fn [c] (Character/toUpperCase c)) (apply str %)) exps)\r\n          bins (set (map #(for [c %] (if (Character/isUpperCase c) \\1 \\0)) exps))\r\n          m {[0 0] 'a [0 1] 'A [1 0] 'b [1 1] 'B [2 0] 'c [2 1] 'C [3 0] 'd [3 1] 'D}\r\n          x (loop [bins bins ans #{}]\r\n              (if (empty? bins) ans\r\n                (let [res (set (for [i bins j bins :when (= 1 (diff i j))] (make i j)))\r\n                      used (apply clojure.set/union (for [i bins j bins :when (= 1 (diff i j))] #{i j}))]\r\n                  (recur res (clojure.set/union ans (clojure.set/difference bins used))))))\r\n          ret (first (sort-by count\r\n                      (filter (partial cover? bins) (super x))))]\r\n      (set (for [i ret] (set (for [j (range (count i)) :let [c (nth i j)] :when (not= c \\-)](m [j (- (int c) 48)]))))))))", "problem": 140, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn kmap [org_pattern]\r\n  (letfn [(isterm? [set]\r\n                   (symbol? (first set)))\r\n          (match? [termOrExpr cell]\r\n                  (if (isterm? termOrExpr)\r\n                    (every? cell termOrExpr)\r\n                    (some #(match? % cell) termOrExpr)))\r\n          (issame? [expr pattern]\r\n                 (every? #(match? expr %) pattern))\r\n          (subsets [aset]\r\n                   (if (empty? aset)\r\n                     [#{}]\r\n                     (let [rest-subsets (subsets (rest aset))]\r\n                       (concat rest-subsets\r\n                               (map #(clojure.set/union % #{(first aset)}) rest-subsets)))))\r\n          (make-terms [N m]\r\n                      ;; make terms of m characters\r\n                      (letfn [(nthvar [n cap]\r\n                                      (symbol (str (nth (if cap\r\n                                                          \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n                                                          \"abcdefghijklmnopqrstuvwxyz\") n))))\r\n                              (tovar [s]\r\n                                     (set (mapcat #(cond (= (nth s %) 1) [(nthvar % true)]\r\n                                                         (= (nth s %) 0) [(nthvar % false)]\r\n                                                         (= (nth s %) '*) [])\r\n                                                  (range (count s)))))\r\n                              (make-terms-01* [N m]\r\n                                              (cond (= N 0) [[]],\r\n                                                    (= m 0) (map #(cons '* %) (make-terms-01* (dec N) 0)),\r\n                                                    (= N m) (let [post (make-terms-01* (dec N) (dec m))]\r\n                                                              (concat (map #(cons 0 %) post)\r\n                                                                      (map #(cons 1 %) post))),\r\n                                                    :else   (let [post (make-terms-01* (dec N) (dec m))\r\n                                                                  post2 (make-terms-01* (dec N) m)]\r\n                                                              (concat (map #(cons 0 %) post)\r\n                                                                      (map #(cons 1 %) post)\r\n                                                                      (map #(cons '* %) post2)))))]\r\n                        (map tovar (make-terms-01* N m))))\r\n\r\n\r\n          (kmap-m [N m]\r\n                  (filter (fn [pattern]\r\n                            (= (int (Math/pow 2 (- N m)))\r\n                               (count (filter #(match? pattern %) org_pattern))))\r\n                          (make-terms N m)))\r\n          (kmap-under-m [N m]\r\n                        (let [terms-with-m-vars (kmap-m N m)]\r\n                          (if (= m N)\r\n                            terms-with-m-vars\r\n                            (concat terms-with-m-vars\r\n                                    (filter #(not (match? terms-with-m-vars %))\r\n                                            (kmap-under-m N (inc m)))))))\r\n          (seq< [expa expb]\r\n            (cond (and (empty? expa) (empty? expb)) false,\r\n                  (< (first expa) (first expb)) true,\r\n                  :else (seq< (rest expa) (rest expb))))\r\n          (simple<? [expa expb]\r\n            (seq< [(count expa) (apply + (map count expa))]\r\n                  [(count expb) (apply + (map count expb))]))\r\n          (simplify [terms]\r\n                    (if (< (count terms) 3)\r\n                      terms\r\n                      (first (sort simple<? (filter #(issame? % org_pattern) (subsets terms))))))]\r\n    (let [N (count (first org_pattern)),\r\n          candidates (set (kmap-under-m N 1))]\r\n      (simplify candidates)\r\n      )))", "problem": 140, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(letfn [(match? [x y] (.equalsIgnoreCase (str x) (str y)))\n        (symmetric-difference [s1 s2]\n          (clojure.set/difference (clojure.set/union        s1 s2)\n                                  (clojure.set/intersection s1 s2)))\n        (simplify [s1 s2]\n          (cond (clojure.set/subset? s1 s2) s1\n                (clojure.set/subset? s2 s1) s2\n                :else\n                (let [s (symmetric-difference s1 s2)]\n                  (if (and (= (count s) 2) (apply match? s))\n                    (clojure.set/intersection s1 s2)\n                    nil))))\n        (simplify-with [ss s] (or (some #(simplify s %) (disj ss s)) s))\n        (simplify-all  [ss]   (set (map #(simplify-with ss %) ss)))\n        (fixed-point [f x] (let [y (f x)] (if (= x y) y (recur f y))))]\n  #(fixed-point simplify-all %))", "problem": 140, "user": "50586354e4b06522596eba78"}, {"code": "(fn __ [bool-set]\n  (let [m {'A 8, 'B 4, 'C 2, 'D 1}\n        l (into m [['a 8] ['b 4] ['c 2] ['d 1]])\n        gray (fn [s] (reduce #(+ %1 (or (m %2) 0)) 0 s))\n        gray->set (fn [[g ignore]]\n                    (for [n [0 1 2 3]\n                          :when (zero? (bit-and (bit-shift-left 1 n)\n                                                ignore))]\n                      (get-in [['d 'c 'b 'a] ['D 'C 'B 'A]]\n                              [(if (= 0 (bit-and g (bit-shift-left 1 n)))\n                                 0 1)\n                               n])))\n        ignore (fn [s] (bit-xor 0x0F (reduce #(+ %1 (l %2)) 0 s)))\n        merge-gray (fn [[a a-ig] [b b-ig]]\n                     (vec [(bit-and (bit-and a (bit-not a-ig))\n                                    (bit-and b (bit-not b-ig)))\n                           (bit-or (bit-xor (bit-and a (bit-not a-ig))\n                                            (bit-and b (bit-not b-ig)))\n                                   (bit-and a-ig b-ig))]))\n        hamming-distance (fn [[a a-ig] [b b-ig]]\n                           (Integer/bitCount\n                            (bit-xor (bit-and a (bit-not a-ig))\n                                     (bit-and b (bit-not b-ig)))))\n        r (fn r [rst]\n            (if (empty? rst)\n              [[]]\n              (mapcat (fn [a] #(cons a %) (r (rest rst))) (first rst))))\n        fill (fn [fs gs]\n               (let [arr (make-array Boolean (count fs) (count gs))]\n                 (dotimes [i (count fs)]\n                   (dotimes [j (count gs)]\n                     (let [[y y-ig] (nth gs j)]\n                       (when (= (bit-or (nth fs i) y-ig)\n                                (bit-or y y-ig))\n                         (aset arr i j true)))))\n                 ((fn itr [i j acc]\n                    (cond\n                     (= i (count fs)) (distinct acc)\n                     (= j (count gs)) gs\n                     (aget arr i j) (min-key\n                                     count\n                                     (itr (inc i) 0 (cons (nth gs j) acc))\n                                     (itr i (inc j) acc))\n                     :else (itr i (inc j) acc)))\n                  0 0 [])))\n        grays (vec (map (fn [s] (vector (gray s) (ignore s))) bool-set))]\n    (->> (loop [cnt 0 acc (into {} (map #(vector % 0) grays))]\n           (if (= cnt 3)\n             (keep #(when (second %1) (first %1)) acc)\n             (recur\n              (inc cnt)\n              (reduce\n               #(-> (assoc %1 (merge-gray (first %2) (second %2)) cnt)\n                    (assoc (first %2) nil)\n                    (assoc (second %2) nil))\n               acc\n               (for [[a a-cnt] acc [b b-cnt] acc\n                     :when (and (not (= a b))\n                                (= (dec cnt) a-cnt)\n                                (= (dec cnt) b-cnt)\n                                (= 1 (hamming-distance a b)))]\n                 [a b])))))\n         (sort-by #(Integer/bitCount (second %)) >)\n         (fill (mapv first grays))\n         (map #(set (gray->set %)))\n         set)))", "problem": 140, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn[input]\n  (let [size (count (first input))\n        symbols (take size [['A 'a]['B 'b]['C 'c]['D 'd]])\n        build (fn [tt others] (set (map (comp (partial reduce conj) flatten)\n                (reduce #(for [l %1 r %2] [l r]) (conj others (list tt))))))\n        find-other #(remove (partial some %) symbols)\n        requires #(if (= size (count %)) #{%} (build % (find-other %)))\n        ok? #(clojure.set/subset? (requires %) input)\n        inter (sort-by count (set (remove #{#{}} (for [a input b input](clojure.set/intersection a b)))))\n        temp (loop [src inter result #{}]\n               (cond (empty? src) result\n                  (some (partial clojure.set/superset? (first src)) result) (recur (rest src) result)\n                  (ok? (first src)) (recur (rest src) (conj result (first src)))\n                  :else (recur (rest src) result)))\n        cover? #(clojure.set/subset? input (set (mapcat requires %)))\n        maybe (filter cover? (map #(clojure.set/difference temp #{%}) temp))]\n    (if (empty? maybe)\n        temp\n      (first maybe))))", "problem": 140, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [coll]\n    (let [power-set (fn [s] (reduce #(into % (for [x %] (conj x %2)))\n                                   #{#{}} s))\n          indexed (->> coll\n                       (map #(zipmap (disj (power-set %) #{}) (repeat #{%})))\n                       (apply merge-with into))]\n      (->> indexed\n           (sort-by (comp count first))\n           (reduce (fn [acc [k v]]\n                     (if (and (= (count v)\n                                 (->> (- (count (first v)) (count k))\n                                      (Math/pow 2)\n                                      long))\n                              (not-any? (partial clojure.set/superset? k) acc))\n                       (conj acc k)\n                       acc))\n                   #{})\n           (repeat 2)\n           (apply reduce (fn [result x]\n                           (if (= (count coll) (->> (disj result x) (mapcat indexed) set count))\n                             (disj result x)\n                             result))))))", "problem": 140, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [mt]\n  (letfn [(convert [t i] {:g #{i} :t (sort-by #(-> % name .toLowerCase) t)})\n          (count-diff [x y] (->> (map vector x y) (filter (partial apply not= )) count))\n          (combine [x y]\n            (when (= (count-diff (x :t) (y :t)) 1)\n              [{:g (into (x :g) (y :g)) \n                :t (map #(if (not= %1 %2) '- %1) (x :t) (y :t))}]))\n          (combinations [t ts]\n            (let [cs (mapcat #(combine t %) ts)]\n              [cs (when (empty? cs) [t])]))\n          (reduze [terms]\n            (let [r  (map #(combinations % terms) terms)\n                  c  (set (mapcat first r))\n                  p  (mapcat second r)]\n              [c p]))\n          (primes [t]\n            (loop [t (map-indexed #(convert %2 %) t)\n                   p []]\n              (let [[a b] (reduze t)]\n                (if (empty? a)\n                  (into p b)\n                  (recur a (into p b))))))\n          (coverage [t ts] (reduce #(remove (%2 :g) %) (t :g) (remove #{t} ts)))]\n    (let [p    (primes mt)\n          cov  (filter #(not-empty (coverage % p)) p)\n          r    (set (map #(->> % :t (remove #{'-}) set) cov))]\n      r\n    )\n  )\n)", "problem": 140, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [table]\n  (let [size (count (first table))\n        pow-2 (fn [n] (first (drop n (iterate #(* % 2) 1))))\n        to-letter-codes (fn [minterm]\n                          (for [i (range 0 size)\n                                :when (not= ((vec minterm) i) 'x)]\n                            (get-in [['a 'A] ['b 'B] ['c 'C] ['d 'D]] [i ((vec minterm) i)])))\n        values (into {}\n                (map (fn [l n] (vector l n))\n                    '(A B C D)\n                    (->>\n                      (iterate #(* % 2) 1)\n                      (take size)\n                      reverse)))\n        val    (fn [f] (reduce + (keep values f)))\n        masks  (fn masks [n k] ; n-long masks where k bits are set\n                  (cond\n                    (zero? k) [(repeat n 'x)]\n                    (= 1 n) [[0] [1]]\n                    :else\n                      (let [m' (masks (dec n) (dec k))]\n                        (concat\n                          (map #(cons 0 %) m')\n                          (map #(cons 1 %) m')\n                          (when (> n k)\n                            (map #(cons 'x %) (masks (dec n) k)))))))\n        k-comb (fn k-comb [k S]\n                  (if\n                    (zero? k) #{#{}}\n                    (set\n                      (mapcat\n                        (fn [e]\n                          (map\n                            (fn [t] (conj t e))\n                            (k-comb (dec k) (disj S e))))\n                        S))))\n        to-bindigits (fn bd [x n]\n                      (let [pow2 (first (drop (dec n) (iterate #(* % 2) 1))) ; why (dec n)?\n                            d (quot x pow2)]\n                          (cond\n                            (zero? n) '()\n                            (= d 0) (cons 0 (bd x (dec n)))\n                            :else   (cons 1 (bd (- x pow2) (dec n))))))\n        ones  (map #(to-bindigits % size) (map val table))\n        matches? (fn [t mask]\n                   (every? identity\n                           (map (fn [bit mask-bit] (or (= 'x mask-bit) (= mask-bit bit)))\n                                t mask)))\n        covers-less? (fn [m1 m2]\n                       (and\n                         (< (->> m1 (filter #(= % 'x)) count)\n                            (->> m2 (filter #(= % 'x)) count))\n                         (reduce (fn [res [b1 b2]]\n                                   (and res\n                                     (if (not= 'x b2) (= b1 b2) true)))\n                                 true\n                                 (partition 2 (interleave m1 m2)))))\n        eligible-masks (for [k (range 1 (inc size))\n                             mask (masks size k)\n                             :let [matching-ones (filter #(matches? % mask) ones)]\n                             :when (= (count matching-ones) (pow-2 (- size k)))]\n                             [k mask (set matching-ones)])\n        final-masks (reduce\n                         (fn [ms [k m matching]]\n                           (let [k-masks (get ms k {})]\n                             (assoc ms k\n                               (assoc k-masks m (set matching)))))\n                          {}\n                          (remove (fn [[_ m1 _]]\n                                    (some (fn [[_ m2 _]] (covers-less? m1 m2)) eligible-masks))\n                                  eligible-masks))\n        masks-with-at-most-k-fixed (fn [masks k]\n                                     (reduce (fn [h k-masks] (reduce merge h k-masks))\n                                             {}\n                                             (keep (fn [[n v]] (when (<= n k) v)) masks)))]\n      (->>\n        (mapcat\n          #(let [possible-masks (masks-with-at-most-k-fixed final-masks %)]\n              (for [l (range 1 (inc (count possible-masks)))\n                    chosen-masks (k-comb l (set (keys possible-masks)))\n                    :let [covered-minterms (reduce into (map possible-masks chosen-masks))]]\n                 [chosen-masks covered-minterms]))\n           (range 1 (inc size)))\n        (filter\n          (fn [[masks covered-minterms]] (= covered-minterms (set ones))))\n        first\n        first\n        (map #(set (to-letter-codes %)))\n        (into #{}))))", "problem": 140, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [sos]\n  (letfn [\n          (combine [x y]\n            (let [diff [nil (.toUpperCase (str (clojure.set/difference x y)))] ]\n              (conj (clojure.set/intersection x y) diff)))\n          (remove-dontcares [minterms]  (set (remove vector? minterms)))\n          (get-off-by-ones [all-minterms [current-key current-vals]]\n            (let [\n                  off-by-one\n                  (map #(combine current-key %)\n                       (filter #(= 1\n                                   (count\n                                    (clojure.set/difference % current-key)))\n                               (keys  all-minterms)))]\n              (if (empty? off-by-one)\n                (hash-map current-key current-vals)\n                (zipmap off-by-one (repeat current-vals) )\n                )))\n          (collect-implicants [minterms ]\n            (loop [reducible (zipmap minterms (map vector minterms))]\n              (let [new-reducible\n                    (reduce #(merge-with concat %1 %2)\n                            (map #( get-off-by-ones reducible %) reducible )) ]\n                ( if (= reducible new-reducible)\n                  (reduce #(assoc %1 (remove-dontcares (key %2)) (val %2)) {} reducible)\n                  (recur new-reducible)))))\n          (find-minimum-solution [minterms-by-implicant]\n            (let\n                [\n                 tuples\n                 (set (for\n                          [k (keys minterms-by-implicant)\n                           v (minterms-by-implicant k)] [k v]))\n\n                 essential-tuples\n                 (filter\n                  (fn [tuple] (nil? (next\n                                     (filter #(= (second tuple) (second %)) tuples)))) tuples)]\n              ;; assuming that the essential implicants cover the solution. This is not true for all examples but the examples that are on 4clojure work this way. It's just that the solution to do the sum-of-product stuff is nasty even when it is working!\n                 (set (map first essential-tuples))\n              ))]\n    (find-minimum-solution (collect-implicants sos))))", "problem": 140, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn __ [minterms]\n  (letfn [(differ-by-1 [s1 s2]\n            (let [d1 (clojure.set/difference s1 s2)\n                  d2 (clojure.set/difference s2 s1)]\n              (and (= 1 (count d1) (count d2))\n                   (= (clojure.string/upper-case (first d1))\n                      (clojure.string/upper-case (first d2))))))\n          (find-differ-by-1 [s minterm]\n            (filter (partial differ-by-1 minterm) s))\n          (implicants [minterms]\n            (reduce (fn [s minterm]\n                        (into s (map (partial clojure.set/intersection minterm) \n                                     (find-differ-by-1 s minterm))))\n                    minterms\n                    minterms))\n          ;;\n          (bfs-cull [path+imps+terms]\n              (let [complete-paths (map first (filter (fn [[path imps terms]] (empty? terms)) \n                                                      path+imps+terms))]\n              (if-not (empty? complete-paths)\n                ;; We're done - find the path with the least elements\n                (apply min-key #(reduce + (map count %)) complete-paths)\n                (recur (for [[path imps terms] path+imps+terms\n                             imp imps]\n                         [(conj path imp)\n                          (disj imps imp)\n                          (filter (complement (partial clojure.set/subset? imp)) terms)])))))]\n    ;; Compute \"implicants\" until we've got a maximal set\n    (let [all-imps (ffirst (drop-while #(not (apply = %)) \n                                      (partition 2 1 (iterate implicants minterms))))]\n      (bfs-cull [ [#{} all-imps minterms]]))))", "problem": 140, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [s]\n  (let [m '{a A A a b B B b c C C c d D D d}\n        sub-set (fn [a b] (reduce #(disj %1 %2) a b))\n        add-set (fn [a b] (reduce #(conj %1 %2) a b))\n        reduce1-set (fn [a b]\n          (let [f (fn [t s] (if (s t) t (if (s (m t)) 'O 'X)))\n                r (map #(f % a) (vec b))]\n            (if (not-any? #(= % 'X) r)\n                (if (= 1 (count (keep #(if (= 'O %) 'O) r)))\n                  (conj #{} (disj (set r) 'O))))))\n        reduce2-set (fn [a b]\n          (let [f (fn [a s] (if (s a) a (if (s (a m)) (a m))))\n                s (map #(f % a) b)]\n            (if (not-any? nil? s)\n              (conj (reduce1-set a (add-set b (sub-set a s))) b))))\n        reduce-set (fn [a b]\n          (let [r (if (= (count a) (count b)) (reduce1-set a b)\n                      (let [[a' b'] (if (> (count a) (count b)) [a b] [b a])]\n                        (reduce2-set a' b')))]\n            (if r [b r])))\n        karn (fn [s]\n          (loop [s s n #{}]\n            (if (empty? s) n \n            (let [a (first s)\n                  s' (disj s a)\n                  [b k] (some #(reduce-set a %) s')]\n              (if k\n                (recur (disj s' b) (add-set n k))\n                (recur s' (conj n a)))))))]\n  (loop [s s r nil]\n    (if (= s r) s\n      (recur (karn s) s)))))", "problem": 140, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn solve [ss]\n  (letfn [\n\t\t(flip [s] \n\t\t  (->> s\n\t\t    (str)\n\t\t    (map (fn [ch] (if (Character/isLowerCase ch) (Character/toUpperCase ch) (Character/toLowerCase ch))))\n\t\t    (apply str)\n\t\t    (symbol)))\n  \n\t\t(neighbors [s] \n\t\t  (reduce conj {} \n\t\t\t  (for [ x s :let [ohne (disj s x) flipped (conj ohne (flip x))] ]\n\t\t\t    [flipped ohne])))\n\t\t\n\t\t(check-neighbors [ss] \n\t\t  (loop [rss (seq ss) compressed {} ]\n\t\t    (if (empty? rss) compressed\n\t\t      (let [[[s ms] & nrss] rss\n\t\t            nbrs (neighbors s) \n\t\t            hits (filter identity (map #(when-let [ohne (nbrs %)] [(nbrs %) (reduce conj ms (ss %))]) (keys ss)))\n\t\t            ]\n\t\t        (if (empty? hits) \n\t\t          (recur nrss (conj compressed [s ms]))\n\t\t          (recur nrss (reduce conj compressed hits)))))))\n\t\t\n\t\t(mapify [ss]\n\t\t  (reduce #(assoc % %2 #{%2}) {} ss))\n\t\t\n\t\t(demap [cmpm]\n\t\t  (set (apply concat (vals cmpm))))\n\t\t\n\t\t(compress [ss]\n\t\t  (let [nss (check-neighbors ss)]\n\t\t    (if (= nss ss) ss \n\t\t      (recur nss))))\n          \n          ]\n\t  (let [cmpm (compress (mapify ss))]\n\t    (loop [cmp (seq (keys cmpm)) kys #{}]\n\t      (if (empty? cmp) kys\n\t        (let [[fcmp & rcmp] cmp, drop? (= ss (demap (dissoc cmpm fcmp)))]\n\t\t      (recur rcmp (if drop? kys (conj kys fcmp))))))))\n    )", "problem": 140, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [s]\n    (let [s+ (comp set concat)\n          s- #(set (remove %2 %1))\n          sx #(set (filter %2 %1))\n          s<= #(= %2 (s+ %1 %2))\n          cr #(.toUpperCase (str %))\n          j (fn [a b] \n              (when (== (count a) (count b))\n                (let [c (s- a b), d (s- b a)]\n                  (when \n                    (and\n                      (not= a b)\n                      (== 1 (count c))\n                      (= (map cr c) (map cr d)))\n                    (sx a b)))))\n          r (fn [s]\n              (set\n                (mapcat \n                  (fn [a] (cons a (remove empty? (map #(j a %) s))))\n                  s)))\n          g (iterate r s)\n          x (set\n              (ffirst (drop-while \n                        #(not= (first %) (second %))\n                       (map vector g (rest g)))))\n          y (set\n              (remove \n                (fn [a] (some #(and (s<= % a) (not= a %)) x))\n                x))\n          z (map (fn [a] (filter #(s<= % a) y)) s)]\n      (set (map first z))))", "problem": 140, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [function-set]\n  (letfn [(expt ([a b] (expt a b 1))\n                ([a b r](if(zero? b) r(recur a (dec b)(* r a)))))\n          (num-to-seq ([num div len] (num-to-seq num div len ()))\n                      ([num div len r](if (zero? len) r\n                                          (recur (quot num div) div \n                                                 (dec len)(cons (rem num div) r)))))\n          (subset? [a b] (every? (fn [x] (get b x)) a))\n          (char-upcase [c] (let [upper-trans {\\a \\A, \\b \\B, \\c \\C, \\d \\D \\e \\E}]\n                                (or (get upper-trans c) c)))\n          (str-upcase [s] (apply str (map char-upcase s)))]\n     (let [all-names [[nil 'A 'a] [nil 'B 'b] [nil 'C 'c] [nil 'D 'd] [nil 'E 'e]]\n           var-count (count (first function-set))\n           names (vec (take var-count all-names))\n           all-pred (map (fn [num] \n                           (set (remove nil? \n                                   (map-indexed #(get-in all-names [%1 %2])\n                                                (num-to-seq num 3 var-count)))))\n                         (range))\n           predicates (vec (sort-by count\n                            (drop 1(take(expt 3 var-count) all-pred))))]\n        (letfn [(expand-pred-by-idx [idx]\n                  (let [pred (get predicates idx)]\n                       (filter #(and (= (count %) var-count) \n                                        (subset? pred %))\n                               (drop idx predicates))))]\n          (let [expand-result-list \n                 (sort-by \n                   (fn [[p r]] (- (count r)))\n                     (remove (fn [[p r]] (empty? r))\n                        (map-indexed (fn [idx pred] \n                        (let [expand-result (expand-pred-by-idx idx)]\n                           [pred (if (subset? expand-result function-set)\n                                     expand-result nil)])) predicates)))]\n              (letfn [(query-result [rest-result-list goal-set result-list]\n                        (cond\n                          (empty? goal-set) result-list\n                          (empty? rest-result-list) :fail\n                          :else (let [[[p r] & new-rest] rest-result-list]\n                                (if (some #(get goal-set %) r)\n                                  (let [c-r\n                                         (query-result new-rest \n                                                       (reduce disj goal-set r)\n                                                       (conj result-list p))\n                                        u-r\n                                         (query-result new-rest\n                                                       goal-set\n                                                       result-list)]\n                                    (cond\n                                      (= u-r :fail) c-r\n                                      (<= (count c-r) (count u-r)) c-r\n                                      :else u-r))\n                                  (recur new-rest\n                                         goal-set\n                                         result-list)))))]\n                  (query-result expand-result-list function-set #{})))))))", "problem": 140, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(letfn [(opposite [s] (let [n (name s)]\n                        (symbol (if (re-matches #\"[A-Z]\" n)\n                                  (.toLowerCase n)\n                                  (.toUpperCase n)))))\n        (neighbors [g] (map (fn [l] (conj (disj g l) (opposite l))) g))\n        (common [a b]\n          (when (= (count a) (count b))\n            (let [c (into #{} (filter a b))]\n              (when (= (count c) (dec (count a)))\n                c))))\n        (covers [a b]\n          (let [missed (into #{} (remove a b))]\n            (not-any? a (map opposite missed))))]\n  (fn [sets]\n    (let [N (apply max (map count sets))\n          all-sets (nth\n                    (iterate\n                     (fn [sets]\n                       (into sets\n                             (for [e sets\n                                   n (neighbors e)\n                                   :when (sets n)]\n                               (common e n))))\n                     sets)\n                    N)]\n      (loop [chosen #{}\n             uncovered sets]\n        (if (empty? uncovered)\n          chosen\n          (let [unchosen (remove chosen all-sets)\n                ncover (into {}\n                             (map\n                              (fn [s]\n                                [s (count (filter (fn [a] (covers s a)) uncovered))]) unchosen))\n                ;_ (prn {:ncov ncover})\n                choice (first (sort-by (juxt (comp - ncover) count) unchosen))\n                ;_ (prn {:chose choice})\n                chosen (conj chosen choice)\n                uncovered (remove\n                           (fn [x] (some (fn [y] (covers y x)) chosen))\n                           sets)]\n            (recur chosen uncovered)))))))", "problem": 140, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn karnaugh [bool-fn]\n  (letfn [(count-minterm\n            [bool-fn minterm]\n            (reduce + (map #(if (clojure.set/subset? minterm %) 1 0) bool-fn)))\n          (get-minterm-4\n            [bool-fn]\n            (set (map second\n                      (filter #(= (first %) 4)\n                              (for [m [['a 'c] ['A 'c] ['a 'C] ['A 'C]\n                                       ['a 'b] ['a 'B] ['A 'b] ['A 'B]\n                                       ['c 'd] ['c 'D] ['C 'd] ['C 'D]\n                                       ['b 'd] ['B 'd] ['b 'D] ['B 'D]\n                                       ['b 'c] ['B 'c] ['b 'C] ['B 'C]]]\n                                [(count-minterm bool-fn m) m])))))\n          (contains-minterm?\n            [minterm-set bool-fn-set]\n            (reduce #(or %1\n                         (clojure.set/subset? %2 bool-fn-set)) false minterm-set))\n          (reduce-by-minterm-4\n            [bool-fn]\n            (filter #(not (contains-minterm? (get-minterm-4 bool-fn) %)) bool-fn))\n          (get-minterm-2\n            [bool-fn]\n            (set (map second\n                      (filter #(= (first %) 2)\n                              (for [m [['a 'c 'd] ['A 'c 'd]\n                                       ['a 'c 'D] ['A 'c 'D]\n                                       ['a 'C 'd] ['A 'C 'd]\n                                       ['a 'C 'D] ['A 'C 'D]\n                                       ['a 'b 'c] ['a 'B 'c]\n                                       ['A 'b 'c] ['A 'B 'c]\n                                       ['a 'b 'C] ['a 'B 'C]\n                                       ['A 'b 'C] ['A 'B 'C]]]\n                                [(count-minterm bool-fn m) m])))))\n          (reduce-by-minterm-2\n            [bool-fn]\n            (filter #(not (contains-minterm? (get-minterm-2 bool-fn) %)) bool-fn))]\n    (let [bool-fn-reduced-by-minterms (reduce-by-minterm-2 (reduce-by-minterm-4 bool-fn))\n          reduced-bool-fn (if (empty? bool-fn-reduced-by-minterms)\n                            (set\n                             (filter #(not (empty? %))\n                                     (clojure.set/union\n                                      (map set (get-minterm-4 bool-fn))\n                                      (map set (get-minterm-2\n                                                (reduce-by-minterm-4 bool-fn))))))\n                            (set\n                             (filter #(not (empty? %))\n                                     (clojure.set/union\n                                      (map set (get-minterm-4 bool-fn))\n                                      (map set (get-minterm-2\n                                                (reduce-by-minterm-4 bool-fn)))\n                                      (conj #{}\n                                            (apply\n                                             clojure.set/intersection\n                                             bool-fn-reduced-by-minterms))))))]\n      (if (empty? reduced-bool-fn)\n        bool-fn\n        reduced-bool-fn))))", "problem": 140, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [x]\n  (let [union clojure.set/union\n\tintersection clojure.set/intersection\n\tdifference clojure.set/difference\n\tupper-case clojure.string/upper-case\n\tlower-case clojure.string/lower-case\n\ttrue-val? (fn [s] (= (name s) (upper-case s)))\n\tinvert (fn invert [s]\n\t\t (if (set? s)\n\t\t   (set (map invert s))\n\t\t   (symbol ((if (true-val? s) lower-case upper-case)\n\t\t\t    s))))\n\tmove-seq (fn [r]\n\t\t   (->> (sort r)\n\t\t\t(iterate (fn [[a b]] [b (invert a)]))\n\t\t\t(take 5)\n\t\t\t(map set)))\n\tmove (fn [r f]\n\t       (let [mask (union r (invert r))\n\t\t     move-s (move-seq r)\n\t\t     move-rule (zipmap move-s (rest move-s))\n\t\t     masked (intersection f mask)\n\t\t     new-masked (get move-rule masked (invert masked))]\n\t\t (union new-masked\n\t\t\t(difference f mask))))\n\tmove-h (partial move #{'a 'b})\n\tmove-v (partial move #{'c 'd})\n\tgrow (fn [m F f]\n\t       (let [g (m f)]\n\t\t (if (and (F g)\n\t\t\t  (not= f g))\n\t\t   [#{(intersection f g)} #{f g}]\n\t\t   [#{} #{}])))\n\tgrow-h (partial grow move-h)\n\tgrow-v (partial grow move-v)\n\texpand (fn [g F]\n\t\t (reduce (partial map union) (map #(g F %) F)))\n\texpand-h (partial expand grow-h)\n\texpand-v (partial expand grow-v)\n\texpand-hv (fn [F]\n\t\t    (let [ex (fn [f e] (if (empty? f) [#{} #{}] (e f)))\n\t\t\t  [eh rh] (ex F expand-h)\n\t\t\t  [ev rv] (ex F expand-v)\n\t\t\t  [ehv rhv] (ex eh expand-v)\n\t\t\t  [evh rvh] (ex ev expand-h)]\n\t\t      [(union eh ev ehv evh) (union rh rv rhv rvh)]))\n\t[e1 r1] (expand-hv x)\n\t[e2 r2] (expand-hv e1)\n\tnormalize (fn normalize\n\t\t    ([f]\n\t\t       (set\n\t\t\t(for [\n\t\t\t      a (normalize f '[a A])\n\t\t\t      b (normalize f '[b B])\n\t\t\t      c (normalize f '[c C])\n\t\t\t      d (normalize f '[d D])\n\t\t\t      ]\n\t\t\t  (conj f a b c d))))\n\t\t    ([f v]\n\t\t       (some not-empty [(intersection f (set v))\n\t\t\t\t\tv])))\n\tunique-fields (fn [r]\n\t\t\t(set\n\t\t\t (map first\n\t\t\t      (get\n\t\t\t       (group-by second\n\t\t\t\t\t (frequencies\n\t\t\t\t\t  (reduce #(concat % (normalize %2))\n\t\t\t\t\t\t  []\n\t\t\t\t\t\t  r)))\n\t\t\t       1))))\n\tm-exp  (union\n\t\t(difference x r1)\n\t\t(difference e1 r2)\n\t\te2)\n\tuf (unique-fields m-exp)]\n    (set\n     (remove\n      #(empty? (intersection uf\n\t\t\t     (normalize %)))\n      m-exp))\n    )\n  )", "problem": 140, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [R J k]\n  (R (fn [a b] \n    (let [w (fn [x y] ('#{#{a A} #{b B} #{c C} #{d D}}\n                        (R #((if (% %2) disj J) % %2) x y)))\n          [u v] (filter #(every? b %) \n                  ((fn f [m] \n                     (#(if (= m %) % (f %))\n                        (R (fn [s t] \n                          (if (some #(w t %) m) \n                            (R #(if (w t %2) (J % (set (keep t %2))) %) \n                                    s \n                                    m)\n                            (J s t)))\n                          #{}\n                          m))) \n                   k))]\n      (if v a (J a u))))      \n    #{} \n    k))\nreduce conj", "problem": 140, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn quine [mins]\n  (let [mins (set (map #(set(map str %)) mins))\n        one-different (fn [s1 s2] (let [d1 (clojure.set/difference s1 s2)\n                                        d2 (clojure.set/difference s2 s1)] \n                                    (if (and (= 1 (count d1)) \n                                                (= (clojure.string/lower-case (first d1)) \n                                                   (clojure.string/lower-case (first d2)))) \n                                      (clojure.set/intersection s1 s2) false)))\n        delete-other (fn [primes sets] (reduce #(if (some (fn [x] (clojure.set/subset? x %2)) primes) %1 (conj %1 %2)) #{} sets))\n        get-primes (fn pri [sets]\n                     (let [new-primes (reduce (fn [x y] \n                                           (clojure.set/union x (reduce #(if (one-different y %2) \n                                                                             (conj %1 (one-different y %2))\n                                                                             %1) #{} sets))) #{} sets)\n                           ]\n                       (if (empty? new-primes) sets (pri (clojure.set/union (delete-other new-primes sets) new-primes)))))\n        primes (get-primes mins)\n        dominate-s (fn [primes sets]\n                     (apply clojure.set/union \n                      (let [ss (set (map #(reduce (fn [x y] (if (clojure.set/subset? y %) (conj x y) x )) #{} primes) sets))]\n                       (reduce #(if (some (partial clojure.set/superset? %2) (disj ss %2)) %1 (conj %1 %2)) #{} ss))))\n        dominate-z (fn [primes sets] ; Too lazy, test does not need it\n                     ())]\n      (set (map #(set (map symbol %)) (dominate-s primes mins)))))", "problem": 140, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [ms]\n     (let [m (count (first ms))\n           rs (for [a \".Aa\" b \".Bb\" c \".Cc\" d \".Dd\"\n                    :let [g (set (map (comp symbol str) (remove #{\\.}  [a b c d])))\n                          p #(every? % g)\n                          n (- m (count g))\n                          l (filter p ms)]\n                    :when (= (count l) (nth [1 2 4 8 16] n 0)) ]\n                [g l])\n           [[_ u] [_ v]] (sort (group-by #(count (% 0)) rs))\n           ps (fn [a] (reduce (fn [s x] (apply conj s (map #(conj % x) s)) ) #{#{}} a)) ]\n       (first (sort-by count\n                       (for [c (ps (into u v))\n                                 :when (= ms (into #{} (flatten (map second c))))]\n                             (set (map first c)))))\n       ))", "problem": 140, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn tt [coll]\n  (let [to-binary-string (fn [n]\n                           (apply str\n                                  (reverse\n                                   (map #(rem % 2)\n                                        (take-while #(> % 0)\n                                                    (iterate #(bit-shift-right % 1) n)))))) \n        get-combinations (fn [ls]\n                           (let [c (count ls)\n                                 ls-rev (reverse ls)\n                                 c-num (Math/pow 2 c)]\n                             (println :combs c c-num)\n                             (map\n                              (fn [n]\n                                (keep identity (map\n                                                #(when (= \\1 %2) %)\n                                                ls-rev\n                                                (reverse (to-binary-string n)))))\n                              (range 1 c-num))))\n        to-gray-code (fn [n]\n                       (bit-xor n (bit-shift-right n 1)))                     \n        gray-code (fn [align n]\n                    (let [s (to-binary-string (to-gray-code n))\n                          sc (count s)]\n                      (concat (repeat (- align sc) \\0) s)))\n        gray-codes (fn [align]\n                     (map (partial gray-code align) (range)))\n        get-windows (fn [[w h] coll]\n                      (apply mapcat #(partition w 1 %&)\n                             (map #(partition h 1 %) coll)))\n        get-flat-window (fn [w] (apply concat w))\n        get-flat-windows (fn [[w h :as dim] coll]\n                           (set (map get-flat-window (get-windows dim coll))))\n        dims (cons 1 (iterate #(+ 2 %) 2))\n        sides (take 3 dims)\n        all-flat-windows (fn [coll]\n                           (apply concat\n                                  (for [x sides\n                                        y sides\n                                        :when (not= x y 1)]\n                                  (get-flat-windows [x y] coll))))\n        table-dims (fn [coll]\n                     (let [c (count coll)\n                           w (quot c 2)\n                           h (- c w)\n                           p (fn [n] (int (Math/pow 2 n)))]\n                       [w h (p w) (p h)]))\n        str-lower (fn [sym] (clojure.string/lower-case (str sym)))\n        etalone (map str-lower (first coll))\n        sort-field (fn [itm]\n                     (.indexOf etalone (str-lower itm)))\n        coll-prep (into #{} (map #(sort-by sort-field %) coll))\n        f-by-gray-code (fn [c]\n                         (map #(symbol (if (= \\1 %) (clojure.string/upper-case %2) %2)) c etalone))\n        val-by-gray-code (fn [c]\n                           (when (coll-prep (f-by-gray-code c)) true))\n        table (let [[w h pw ph] (table-dims etalone)\n                    hor-codes (take pw (gray-codes w))\n                    vert-codes (take ph (gray-codes h))]\n                (map (fn [v-c]\n                       (map (fn [h-c]\n                              (let [c (concat v-c h-c)]\n                                [c (val-by-gray-code c)]))\n                            hor-codes))\n                     vert-codes))\n        ok-line? (fn [comb]\n                   (every? (fn [[c v]] (true? v)) comb))\n        get-valid-lines (fn [table]\n                          (filter ok-line?\n                                  (concat (all-flat-windows\n                                             (map #(cons (last %) %) table))\n                                          (all-flat-windows [(first table) (last table)])\n                                          (let [tl (ffirst table)\n                                                tr (last (first table))\n                                                bl (first (last table))\n                                                br (last (last table))]\n                                            [[tl br]\n                                             [tr bl]\n                                             [tr tl br bl]]))))\n        line-groups (fn [valid-lines]\n                      (group-by\n                       #(count (reduce into #{} %))\n                       (get-combinations (set valid-lines))))\n        max-groups (fn [valid-lines]\n                     (let [gs (line-groups valid-lines)\n                           ks (keys gs)\n                           mxk (apply max ks)]\n                       (gs mxk)))\n        res-groups (fn [valid-lines]\n                     (let [gs (max-groups valid-lines)\n                           r-gs (group-by count gs)\n                           min-c (apply min (keys r-gs))]\n                       (r-gs min-c)))\n        gen-fun-by-line (fn [line]\n                          (set (let [codes (map first line)\n                                     itms (apply map (fn [& r] (when (apply = r) (first r))) codes)]\n                                 (keep identity (map #(when (not= nil %)\n                                                        (symbol\n                                                         (if (= % \\0) %2\n                                                             (clojure.string/upper-case %2))))\n                                                     itms etalone)))))]\n    (let [v-lines (get-valid-lines table)]\n      (if (empty? v-lines)\n        coll\n        (first\n         (sort-by\n          #(count (apply concat %))\n          (set (map #(set (map gen-fun-by-line %))\n                    (res-groups v-lines)))))))))", "problem": 140, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [xs]\n  (letfn \n    [(qmdiffaux [xf yf]\n       (let [x (first xf)\n             y (first yf)\n             d (clojure.set/difference x y)]\n         (when (and (= (count x) (count y)) (= 1 (count d)) \n                    (= (clojure.string/upper-case d) (clojure.string/upper-case (clojure.set/difference y x))))\n           [(clojure.set/intersection x y) (into (second xf) (second yf))])))\n     (qmdiff [x xs]\n       (let [d (keep #(qmdiffaux x %) xs)]\n         (if (empty? d) \n           #{x}  \n           (into #{} d))))\n     (qmstage [xs]\n       (into #{} (mapcat #(qmdiff %1 xs) xs)))\n     (addextra [xs]\n       (map (fn [x] [x #{x}]) xs))\n     (removeoverlap [xs]\n       (into #{} (map first (remove (fn [x]\n                            (let [removedx (remove #(= x %) xs)\n                                  others (reduce #(into %1 (second %2)) #{} removedx)]\n                              (clojure.set/subset? (second x) others))) xs))))]\n    (let [n (apply max (map count xs))]\n      (removeoverlap (qmstage (qmstage (addextra xs)))))))", "problem": 140, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn simp [s] \n\t(let [implie (fn [p1 p2] \n\t\t\t(= (int (Math/pow 2 (- (count (first p2)) (count p1))))\n\t\t\t   (count (filter (partial clojure.set/subset? p1) p2))))\n\t      neg {'A 'a 'a 'A 'B 'b 'b 'B 'C 'c 'c 'C 'D 'd 'd 'D}\n\t      vars (set (flatten (map #(vector % (neg %)) (apply clojure.set/union s))))\n\t      pos (clojure.set/intersection #{'A 'B 'C 'D} vars)\n\t      subsets (fn p [s] (if (empty? s)\n\t\t\t\t#{#{}}\n\t\t\t\t(concat \n\t\t\t\t\t(map #(conj % (first s)) (p (rest s)))\n\t\t\t\t\t(p (rest s)))))\n\t      valid (fn [l] (every? #(not (contains? l (neg %))) l))\n\t      all-combi (set (filter #(and (valid %) (implie % s)) (subsets vars)))\n\t      all-combi-light (remove (fn [t] (some #(and (clojure.set/subset? % t) (not (= t %))) all-combi)) all-combi)\n\t      expand (fn xp [p] (let [var-not-used (first (remove #(or (contains? p %) (contains? p (neg %))) pos))]\n\t\t\t\t\t(if (nil? var-not-used)\n\t\t\t\t\t\t#{p}\n\t\t\t\t\t\t(clojure.set/union (xp (conj p var-not-used)) (xp (conj p (neg var-not-used)))))))\n       expand-all (fn [sl] (apply clojure.set/union (map expand sl)))\n       ]\n\t(first (sort-by count (filter #(= s (expand-all %)) (subsets all-combi-light))))))", "problem": 140, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [algebra]\n  (letfn [(union [s1 s2]\n            (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n          (step [algebra]\n            (let [r (set (flatten (map\n                                    (fn [line]\n                                      (let [m (map\n                                                #(set (conj\n                                                        (remove #{%} line)\n                                                        (case (str %)\n                                                          \"a\" 'A\n                                                          \"A\" 'a\n                                                          \"b\" 'B\n                                                          \"B\" 'b\n                                                          \"c\" 'C\n                                                          \"C\" 'c\n                                                          \"d\" 'D\n                                                          \"D\" 'd)))\n                                                line)\n                                            s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                        (if (seq s) s line)))\n                                    algebra)))]\n              (if (not= r algebra) (step r) algebra)))\n          (power-set [s]\n            (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))]\n    (let [ps (power-set (step algebra))]\n      (apply\n        (partial min-key count)\n        (filter\n          (complement nil?)\n          (map\n            (fn [s]\n              (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) algebra)) s))]\n                (if (= r algebra) s))\n              )\n            ps))))))", "problem": 140, "user": "514d7e29e4b019235f6c0587"}, {"code": "(let\n  [pairs '#{#{a A} #{b B} #{c C} #{d D}}\n   intersects? (fn [s1 s2]\n                 (not (empty? (clojure.set/intersection s1 s2))))\n   explode (fn [s]\n             (let [to-add (filter #(not (intersects? s %)) pairs)]\n               (reduce (fn [ss pair]\n                         (set (for [s ss\n                                    sym pair]\n                                (conj s sym))))\n                       #{s} to-add)))\n   cover (fn [uncovered s]\n           (set (filter #(not (clojure.set/subset? s %)) uncovered)))\n   covered? (fn [s ss]\n              (empty? (reduce cover (explode s) ss)))\n   simplify (fn [s ss]\n              (or\n                (some #(when (covered? % ss) %)\n                      (for [sym s] (disj s sym)))\n                s))]\n  (fn soln [ss]\n    (let [simplified (set (map #(simplify % ss) ss))]\n      (if (= ss simplified)\n        (set (filter #(not (covered? % (disj ss %)))\n                     ss))\n        (recur simplified)))))", "problem": 140, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn veitch [algebras]                                                                                                                                    \n  (let [expand (fn [algebras letters]                                                                                                                      \n                 (apply concat (for [algebra algebras]                                                                                                     \n                   (if (some #(contains? algebra %) letters)                                                                                               \n                     (list algebra)                                                                                                                        \n                     (map #(set (conj algebra %)) letters)))))                                                                                             \n        expand-all (fn [algebras]                                                                                                                          \n                     (let [a (expand algebras '(a A))                                                                                                      \n                           b (expand a '(b B))                                                                                                             \n                           c (expand b '(c C))                                                                                                             \n                           d (expand c '(d D))]                                                                                                            \n                       d))                                                                                                                                 \n        ab-map '{(a b) 0 (a B) 1 (A B) 2 (A b) 3}                                                                                                          \n        cd-map '{(c d) 0 (c D) 1 (C D) 2 (C d) 3}                                                                                                          \n        reverse-kv #(zipmap (vals %) (keys %))                                                                                                             \n        reverse-ab-map (reverse-kv ab-map)                                                                                                                 \n        reverse-cd-map (reverse-kv cd-map)                                                                                                                 \n        union (fn [tuples]                                                                                                                                 \n                (let [e1 (if (apply = (map first tuples)) (-> tuples first first) nil)                                                                     \n                      e2 (if (apply = (map last tuples)) (-> tuples first last) nil)]                                                                      \n                  (set (filter identity [e1 e2]))))                                                                                                        \n        rectangle2algebra (fn [rectangle]                                                                                                                  \n                            (let [xs (set (map last rectangle))                                                                                            \n                                  ys (set (map first rectangle))                                                                                           \n                                  abs (map reverse-ab-map xs)                                                                                              \n                                  cds (map reverse-cd-map ys)]                                                                                             \n                              (set (concat (union abs) (union cds)))))                                                                                     \n        map-val (fn [xy-map algebra]                                                                                                                       \n                  (let [[check v] (first xy-map)]                                                                                                          \n                    (if (every? #(contains? algebra %) check)                                                                                              \n                      v                                                                                                                                    \n                      (recur (rest xy-map) algebra))))                                                                                                     \n        get-coor (fn [algebra]                                                                                                                             \n                   (let [x (map-val ab-map algebra)                                                                                                        \n                         y (map-val cd-map algebra)]                                                                                                       \n                     [y x]))                                                                                                                               \n        empty-board (vec (repeat 4 (vec (repeat 4 false))))                                                                                                \n        board (reduce (fn [board algebra]                                                                                                                  \n                        (let [coor (get-coor algebra)]                                                                                                     \n                          (assoc-in board coor true))) empty-board (expand-all algebras))                                                                  \n        new-coor (fn [[y x] [dy dx]]                                                                                                                       \n                   (let [x (+ x dx)                                                                                                                        \n                         y (+ y dy)]                                                                                                                       \n                     (map #(mod % 4) [y x])))                                                                                                              \n        get-rectangle (fn [w h] (for [x (range w) y (range h)] [x y]))                                                                                     \n        rectangle-sizes [[1 1] [1 2] [2 1] [2 2] [1 4] [4 1] [2 4] [4 2]]                                                                                  \n        rectangle-offsets (map #(apply get-rectangle %) rectangle-sizes)                                                                                   \n        get-rectangle-from-offset (fn [origin offsets]                                                                                                     \n                                    (map #(new-coor origin %) offsets))                                                                                    \n        rectangles (apply concat (map #(map (fn [offsets]                                                                                                  \n                                (get-rectangle-from-offset % offsets)) rectangle-offsets) (get-rectangle 4 4)))                                            \n        true-rectangle? (fn [rectangle] (every? #(get-in board %) rectangle))                                                                              \n        true-rectangles (set (map set (filter true-rectangle? rectangles)))                                                                                \n        sorted-rectangles (reverse (sort-by count true-rectangles))                                                                                        \n        deduped-rectangles (loop [remaining sorted-rectangles                                                                                              \n                                  deduped []                                                                                                               \n                                  covered #{}]                                                                                                             \n                             (if (empty? remaining)                                                                                                        \n                               deduped                                                                                                                     \n                               (let [check (first remaining)                                                                                               \n                                     covered? (every? #(contains? covered %) check)                                                                        \n                                     new-deduped (if covered? deduped (conj deduped check))                                                                \n                                     new-covered (set (concat check covered))]                                                                             \n                                 (recur (rest remaining) new-deduped new-covered))))                                                                       \n        deduped-rectangles2 (loop [remaining deduped-rectangles                                                                                            \n                                  deduped (set deduped-rectangles)]                                                                                        \n                             (if (empty? remaining)                                                                                                        \n                               deduped                                                                                                                     \n                               (let [check (first remaining)                                                                                               \n                                     others (disj deduped check)                                                                                           \n                                     covered (set (apply concat others))                                                                                   \n                                     covered? (every? #(contains? covered %) check)                                                                        \n                                     new-deduped (if covered? others deduped)]                                                                             \n                                 (recur (rest remaining) new-deduped))))]                                                                                  \n    (set (map rectangle2algebra deduped-rectangles2))))", "problem": 140, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn vp [sos]\n  (let [sos (if (= 3 (count (first sos)))\n              (apply hash-set (concat (map #(conj % 'd) sos)\n                                      (map #(conj % 'D) sos)))\n              sos)\n\n        km0 (for [[c d] '[[c d] [c D] [C D] [C d]]]\n             (for [[a b] '[[a b] [a B] [A B] [A b]]]\n               (-> #{a b c d} sos nil? not)))\n        km (map concat km0 km0)\n        km (concat km km)\n        all-squares (for [[width height] [[4 4] [4 2] [2 4] [4 1] [1 4] [2 2] [2 1] [1 2] [1 1]]\n                          x (range 4)\n                          y (range 4)\n                          :when (every? identity\n                                        (->> km\n                                             (drop y) (take height)\n                                             (map #(->> % (drop x) (take width)))\n                                             flatten))]\n                      [x y width height])\n        square-members (fn [[x y width height]]\n                         (apply hash-set\n                                (for [a (range x (+ x width))\n                                      b (range y (+ y height))]\n                                  [(mod a 4) (mod b 4)]\n                                  )))\n        union #(reduce conj %1 %2)\n        superset #(every? %1 %2)\n        coverage (fn [squares] (reduce union #{} (map square-members squares)))\n        \n        mc (loop [remaining (apply hash-set all-squares)]\n             (let [redundant (first (filter #(superset (coverage (disj remaining %))\n                                                       (square-members %))\n                                            (sort-by (fn [[_ _ w h]] (* w h))\n                                                     remaining)))]\n               (if redundant\n                 (recur (disj remaining redundant))\n                 remaining)))\n        kmv (for [[c d] '[[c d] [c D] [C D] [C d]]]\n             (for [[a b] '[[a b] [a B] [A B] [A b]]]\n               [a b c d]))\n        kmv (map concat kmv kmv)\n        kmv (concat kmv kmv)\n        ]\n    (apply hash-set\n           (for [m mc]\n             (reduce clojure.set/intersection\n                     (for [[x y] (square-members m)]\n                       (apply hash-set (-> kmv (nth y) (nth x)))\n                       ))))\n    ))", "problem": 140, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn quine-mccluskey [x]\n    (letfn [(alt [x] ((comp symbol str char (partial bit-xor 32) int first str) x))\n            (imply [x1 x2]\n                (for [i x1\n                      :let [x1i (disj x1 i)\n                            x2i (conj x1i (alt i))]\n                      :when (= x2i x2)] x1i))\n            (implies [x1s x2]\n                (set (reduce implies (conj x1s x2) (mapcat (partial imply x2) x1s))))\n            (generate [x] (reduce implies [] x))\n            (shrink [x]\n                (set\n                    (for [i x\n                          :when (not-any? #(and (not= i %) (clojure.set/subset? % i)) x)] i)))\n            (power [s]\n                (if (empty? s) #{s}\n                    (let [s1 (first s)\n                          sn (disj s s1)\n                          pp (power sn)\n                          pn (for [i pp] (conj i s1))]\n                        (into pp pn))))\n            (cover? [s]\n                (every? (fn [xi] (some #(clojure.set/subset? % xi) s)) x))]\n        (first (sort-by count (filter cover? (power (shrink (generate x))))))))", "problem": 140, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [s]\n    (letfn [\n            (char-to-power-of-2\n              [c num-bits]\n              (let [diff (- (int c) (int \\A))\n                    pos (dec (- num-bits diff))]\n                (int (Math/pow 2 pos))))\n\n            (sym-to-power-of-2\n              [sym num-bits]\n              (let [c (first (str sym))]\n                (if (Character/isUpperCase c)\n                  (char-to-power-of-2 c num-bits)\n                  0)))\n\n            (int-to-bits\n              [n num-bits]\n              (loop [n n\n                     num-bits num-bits\n                     reversed-bits []]\n                (if (zero? num-bits)\n                  (reverse reversed-bits)\n                  (recur (bit-shift-right n 1)\n                         (dec num-bits)\n                         (conj reversed-bits (bit-and n 1))))))\n\n            (func-input-values\n              ;; Given a set of input symbols, return the single number that\n              ;; to 1 bits where symbols are true and 0 bits where symbols\n              ;; are false. Assumes symbols are in the alphabet #{'a, 'A,\n              ;; 'b, 'B, ...}.\"\n              [s]\n              (let [num-bits (count s)]\n                (int-to-bits (reduce + (map #(sym-to-power-of-2 % num-bits) s)) num-bits)))\n            \n            (minterm-vecs\n              [coll]\n              (map func-input-values coll))\n\n            (num-ones\n              [bits]\n              (count (filter #(and % (pos? %)) bits)))\n\n            (adjacent-pairs\n              [coll]                                ; assumes coll is sorted\n              (loop [nums coll\n                     pairs ()]\n                (if (< (count nums) 2)\n                  pairs\n                  (let [n1 (first nums), n2 (second nums)]\n                    (if (= (inc n1) n2)\n                      (recur (next nums) (conj pairs (list n1 n2)))\n                      (recur (next nums) pairs))))))\n\n            (diff-by-one-bit?\n              [bits1 bits2]\n              (letfn [(bit-diff? [b1 b2]\n                        (cond (and (nil? b1) (nil? b2)) false\n                              (or (nil? b1) (nil? b2)) true\n                              (pos? (bit-xor b1 b2)) true\n                              :else false))]\n                (= 1 (count (filter identity (map bit-diff? bits1 bits2))))))\n\n            (combine-bits\n              [bits1 bits2]\n              (letfn [(combine-bit [b1 b2]\n                        (cond (or (nil? b1) (nil? b2)) nil\n                              (pos? (bit-xor b1 b2)) nil\n                              :else b1))]\n                (map combine-bit bits1 bits2)))\n\n            (find-prime-implicants\n              [groups]\n              (set\n               (mapcat (fn [[k1 k2]]\n                         (for [term1 (get groups k1)\n                               term2 (get groups k2)\n                               :when (diff-by-one-bit? term1 term2)]\n                           (combine-bits term1 term2)))\n                       (-> groups keys sort adjacent-pairs))))\n\n            (match-any?\n              [bits coll]\n              (some #{true} (set (map #(diff-by-one-bit? bits %1) coll))))\n\n            (unique-terms\n              [col2 col3]\n              (concat (filter #(not (match-any? %1 col3)) col2)\n                      col3))\n\n            (term-to-symbols\n              [bits]\n              (set (map (comp symbol str)\n                        (filter identity\n                                (map #(cond (= 0 %1) (char (+ (int \\a) %2))\n                                            (= 1 %1) (char (+ (int \\A) %2))\n                                            :else nil)\n                                     bits (range))))))\n\n            (concrete-bit-vals\n              [term-bit]\n              (if term-bit (list term-bit) (list 0 1)))\n\n            (concrete-vals\n              ;; Given a term possibly containing nil bits, return the set\n              ;; of all integers that match the bits.\n              [term]\n              (loop [possible-bits (reverse (for [bit term] (concrete-bit-vals bit)))\n                     numbers []]\n                (let [bits (first possible-bits)\n                      remainder (next possible-bits)]\n                  (cond (nil? possible-bits) numbers\n                        (empty? numbers) (recur remainder bits)\n                        (number? bits) (recur remainder (map #(+ bits (* 2 %1)) numbers))\n                        :else (recur remainder (flatten (for [bit bits]  (map #(+ bit (* 2 %1)) numbers))))))))\n\n            (single-term-minterms\n              [terms]\n              ;; We do extra work re-calcuating concrete-vals for terms. Could memoize\n              ;; or pre-calc but it's not important.\n              (let [freqs (frequencies (flatten (map concrete-vals terms)))\n                    minterms (for [term terms\n                                   :let [cvs (concrete-vals term)]\n                                   num cvs\n                                   :when (= 1 (get freqs num))]\n                               term)]\n                minterms))\n\n            (terms-to-symbols\n              [terms]\n              (set (map term-to-symbols terms)))\n            ]\n      (let [column1 (minterm-vecs s)\n            grouped-column1 (group-by num-ones column1)\n            column2 (find-prime-implicants grouped-column1)\n            grouped-column2 (group-by num-ones column2)\n            column3 (find-prime-implicants grouped-column2)\n            grouped-column3 (group-by num-ones column3)\n            func-terms (unique-terms column2 column3)\n            minterms-covered-by-single-term (single-term-minterms func-terms)\n            ]\n        ;; OK, this is kind of a cheat. The answers are either simply the list\n        ;; of minterms or the entire input. There is not a case where the\n        ;; answer consists of minterms and other terms that cover the\n        ;; remaining conditions.\n        (if (empty? minterms-covered-by-single-term)\n          s\n          (terms-to-symbols minterms-covered-by-single-term)))))", "problem": 140, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [V]\n    (let [\n          subset? clojure.set/subset?\n          prn-m #(map prn (partition 4 %))\n          gray-code (to-array-2d (partition 4 (for [ AB [['a 'b] ['a 'B] ['A 'B] ['A 'b]]\n                                                     CD [['c 'd] ['c 'D] ['C 'D] ['C 'd]] \n                                                   ]\n                                                (set (concat AB CD)))))\n          get-gray (fn [[x y]] (aget gray-code x y))\n          box (fn [V] \n                (let [rec-defs [[2 1] [1 2] [2 2] [1 4] [4 1] [2 4] [4 2] [4 4]] \n                      rec (fn [xi yi rec-def] (for [x (take (first rec-def) (drop xi (cycle (range 4))))\n                                                    y (take (last rec-def) (drop yi (cycle (range 4))))]\n                                                [x y]))\n                      inits (fn [X Y rec-def] (for [x (range X)\n                                                    y (range Y)]\n                                                [x y]))\n                      recs (mapcat (fn [rec-def] (map #(rec (first %) (last %) rec-def) (inits 4 4 rec-def))) rec-defs)\n                      all-index (for [y (range 4) x (range 4)] [x y])\n                      all-1? (fn [r] (every? (fn [a] (some #(subset? % (get-gray a)) V)) r) )\n                      compact-1 (fn [recs] \n                                  (filter #(not-any? (partial subset? %) (disj recs %)) recs )\n                                )\n                      compact-2 (fn [recs]\n                                  (filter #(not (subset? % (apply clojure.set/union (disj recs %)))) recs))\n                      compact (fn [recs] (compact-2 (set (compact-1 recs))))\n                      ]                 \n                  (prn (compact (set (map set (filter all-1? recs)))))\n                  (compact (set (map set (filter all-1? recs))))\n                )\n              )\n          result (fn [b]\n                   (set (map \n                    (fn [box]\n                      (reduce\n                       #(if (clojure.set/subset? %2 %1) \n                          (clojure.set/difference %1 %2) %1\n                          ) \n                       (set (mapcat #(get-gray %) box)) \n                       [#{'A 'a} #{'B 'b} #{'C 'c} #{'D 'd}]\n                       )                                                                          \n                    ) \n                    b\n                   ))\n                 )\n                  ]\n      (let [out (-> V box result)]\n        (if (empty? out)\n          V\n          out)) \n    ) \n  )", "problem": 140, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn do-it [xss]\n  (letfn [(get-names [xss] (->> xss\n                             (reduce #(into % %2) #{})\n                             (map (comp clojure.string/upper-case name))\n                             distinct\n                             vec))\n          (sym-to-p [sym] (if (re-matches #\"[A-Z]\" (name sym))\n                            true?\n                            false?))\n          (sym-sort [syms] (->> (into [] syms) (sort-by (comp clojure.string/lower-case name))))\n          (syms-to-minterm [syms]\n            (fn [ins] (every? true? (map #((sym-to-p %) %2) (sym-sort syms) ins))))\n          (to-pred [xss]\n            (fn [ins] (not-every? false? (map (fn [syms] ((syms-to-minterm syms) ins)) xss))))\n          (gray [n] (if (= n 1)\n                      [[false] [true]]\n                      (let [g (gray (dec n))\n                            a (map #(cons false %) g)\n                            b (map #(cons true %) (reverse g))]\n                        (concat a b))))\n          (grid [g1 g2 p]\n            (map (fn [g i]\n                   (map #(-> [(+ (* i (count g1)) %2) (p (concat % g)) (vec (concat % g))]) g1 (range)))\n              g2 (range)))\n          (cyclic-partition [n xs] (->> (concat xs xs)\n                                     (partition n 1)\n                                     distinct\n                                     (sort-by (comp first first))))\n\n          (cyclic-partitions [xs] (->>\n                                    (cons 1 (range 2 (inc (count xs)) 2))\n                                    (mapcat #(cyclic-partition % xs))))\n          (cyclic-rects [xss] (->> xss\n                                cyclic-partitions\n                                (map (partial apply map vector))\n                                (mapcat cyclic-partitions)\n                                (map #(mapcat identity %))\n                                (map (partial into #{}))\n                                set\n                                (sort-by #(- 0 (count %)))\n                                ))\n          (only-truth [xs] (filter #(every? (fn [[_ b & _]] (-> b)) %) xs))\n          (cover-pairs [xs] (map #(reduce (fn [[cov ax] [c _ bs]] [(conj cov c) (conj ax bs)]) [#{} []] %) xs))\n          (max-covers [xs] (->> xs\n                             (sort-by (comp count first))\n                             reverse\n                             (reduce (fn [[cov ax bx] [c bools]]\n                                       (let [skip (clojure.set/subset? c cov)]\n                                         (if skip\n                                           [cov ax bx]\n                                           [(into cov c) (conj ax bools) (conj bx c)])))\n                               [#{} [] []])))\n          (maxes [xs] (let [p (set (last (max-covers xs)))] (filter #(p (first %)) xs)))\n          (bools-to-names [input-names xs] (map #(if % %2 (clojure.string/lower-case %2)) xs input-names))\n          (map-bool-to-names [input-names xs] (map (fn [cov] (mapcat #(bools-to-names input-names %) cov)) xs))\n          (mini [xs] (->> xs (map distinct) (map (partial group-by clojure.string/lower-case)) (map #(map second %)) (map #(remove (fn [x] (= (count x) 2)) %))))\n          (setify [xs] (->> xs (map #(mapcat identity %)) (map #(map symbol %)) (map set) set))\n          (all-covers [[[c b] & xs :as xxs]]\n            (if (empty? xxs)\n              [[#{} #{}]]\n              (let [prev (all-covers xs)\n                    next (map (fn [[cx bx]] [(into cx c) (conj bx b)]) prev)\n                    curr (vec (set (concat prev next)))\n                    ]\n                curr)))]\n    (let [vars (sort (get-names xss))\n          rows (quot (count vars) 2)\n          cols (- (count vars) rows)\n          p (to-pred xss)\n          the-grid (grid (gray rows) (gray cols) p)]\n      (->> the-grid\n        cyclic-rects\n        only-truth\n        cover-pairs\n        maxes\n        all-covers\n        (group-by (comp count first))\n        (sort-by first)\n        reverse\n        first\n        second\n        (map second)\n        (sort-by count)\n        first\n        (map-bool-to-names vars)\n        mini\n        setify))))", "problem": 140, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn k-map-solver [s]\n\t(letfn [(uppercase? [c] (let [s (str c)] (.equals (.toUpperCase s) s)))\n\t        (compare! [s1 s2]\n\t\t\t  (let [v1   (first @s1)\n\t\t\t\t\tv2   (first @s2)\n\t\t\t\t\tdiff (clojure.set/difference v1 v2)\n\t\t\t\t\tval  (first diff)]\n\t\t\t\t(if (= (count diff) 1)\n\t\t\t\t\t(do\n\t\t\t\t\t(swap! s1 assoc 1 true)\n\t\t\t\t\t(swap! s2 assoc 1 true)\n\t\t\t\t\t(atom [(conj (disj v1 val) (.toUpperCase (str val \"#\")))\n\t\t\t\t\t   false\n\t\t\t\t\t   (concat (nth @s1 2) (nth @s2 2))]))\n\t\t\t\t\tnil)))\n\t\t\t(compare!-to-array [s arr] (filter (comp not nil?) (for [val arr] (compare! s val))))\n\t\t\t(compare!-array-to-array [arr1 arr2] (flatten (for [x arr1] (compare!-to-array x arr2))))\n\t\t\t(step-iter! [col] (distinct (map compare!-array-to-array col (rest col))))\n\t\t\t(remove-unknowns [s] (map #(filter symbol? %) s))\n\t\t\t(combiner [set1 set2] (for [x set1 y set2] (clojure.set/union x y)))\n\t\t\t(quine-mcclusky [s]\n\t\t\t(let [atoms (map #(atom [% false [%]]) s)\n\t\t\t\t  sorted-atoms (map second (sort (group-by #(count (filter uppercase? (first @%))) atoms)))\n\t\t\t\t  implicants  (flatten (take-while seq (iterate step-iter! sorted-atoms)))\n\t\t\t\t  prime-implicants (distinct (map #(vector (first @%) (nth @% 2)) (filter #(false? (second @%)) implicants)))]\n\t\t\t\t  prime-implicants))\n\t\t\t(petricks-method [implicants]\n\t\t\t  (let [sym (reduce clojure.set/union (map #(into #{} (second %)) implicants))\n\t\t\t\t\tchart (for [s sym] (map #(hash-set (into #{} (filter symbol? %))) (distinct (map first (filter #(some #{s} (second %)) implicants)))))\n\t\t\t\t\tsorted-implicants (reduce combiner chart)]\n\t\t\t\t(apply min-key count sorted-implicants)))]\n\t\t(petricks-method (quine-mcclusky s))))", "problem": 140, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn qmc [sos]\n  (let\n    [sort-ci (fn [xs] (sort-by #(clojure.string/lower-case %) xs))\n     is-capitalized? #(= (str %) (clojure.string/upper-case %))\n     to-int (fn [xs]\n        (reduce (fn [r x]\n                  (if x\n                    (+ 1 (bit-shift-left r 1))\n                    (bit-shift-left r 1)))\n                0 xs))\n      to-str-set (fn [xs]\n                  (->> (map-indexed (fn [i v] \n                                 (let [s (->> i (+ 65) char str)]\n                                   (cond\n                                    (= :i v) nil\n                                    v (symbol s)\n                                    :else (symbol (clojure.string/lower-case s)))))\n                               xs)\n                       (remove nil?)\n                       set))\n     minterms (map (fn [s] (->> s\n                                  sort-ci\n                                  (mapv is-capitalized?)\n                                  (#(vector (hash-set (to-int %)) %))))\n                     sos)\n     minterm-names (mapcat (fn [[l _]] l) minterms)\n     combine (fn combine \n               ([xs ys] (combine xs ys [] 0)) \n               ([[x-label [x & xs]] [y-label [y & ys]] accu n]\n               (cond\n                (and (= 1 n) (nil? x)) [[(into x-label y-label) accu]]\n                (nil? x) nil\n                (= x y) (recur [x-label xs] [y-label ys] (conj accu x) n)\n                :else (recur [x-label xs] [y-label ys] (conj accu :i) (inc n)))))\n     combine-or-keep (fn [ys x]\n                       (let [result (mapcat #(vec (combine x %)) ys)]\n                         (if (empty? result)\n                           [x]\n                           result)))\n     combine-all (fn [xs]\n                   (set (mapcat (partial combine-or-keep xs) xs)))\n     prime-implicants (->> minterms combine-all combine-all combine-all)\n     labeled-prime-implicants (map-indexed #(vector (keyword (str 'p %)) %2) prime-implicants)\n     pi-map (reduce (fn [r [l [s t]]]\n                      (assoc r l t))\n                    {}\n                    labeled-prime-implicants)\n     product-of-sums (set (map\n                      (fn [m]\n                        (for [[l [s _]] labeled-prime-implicants\n                              :when (s m)]\n                          #{l}))\n                      minterm-names))\n     mult (fn [xs ys]\n            (for [x xs\n                  y ys]\n              (into x y)))\n     can-simplify? (fn [xs ys]\n                        (and (not= xs ys)\n                             (every? xs ys)))\n     simplify (fn [xs]\n                (mapcat #(if (some (partial can-simplify? %) xs)\n                           nil\n                           [%])\n                        xs))\n     sum-of-products (reduce (fn [r s]\n                               (simplify (mult r s)))\n                             product-of-sums)\n     best (first (sort-by (fn [ps]\n                            (apply + (map (fn [p]\n                                            (->> p\n                                                 pi-map\n                                                 (remove #(= :i %))\n                                                 count))\n                                          ps)))\n                          sum-of-products))\n     \n     \n     ; set is anded product\n     ; list is orred sum\n     ]\n    (->> best (map pi-map) (map to-str-set) set)\n    ))", "problem": 140, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [true-value-set]\n  (let [\n   to-lower-sym (fn [a] (symbol (.toLowerCase (name a))))\n   to-upper-sym (fn [a] (symbol (.toUpperCase (name a))))\n   powerset (fn [res vars]\n       (if (empty? vars)\n        res\n        (let [\n         a (first vars)\n         vset #{#{} (to-lower-sym a) (to-upper-sym a)}\n         icj  (fn [s e] \n             (if (= e #{})  s \n              (if (= s #{#{}}) (set e) (conj s e))))\n         fvset (fn[e] \n             (map #(icj e %1) vset)) \n         nres (set (mapcat fvset res))\n         ]\n         (recur nres (rest vars)))))\n   symb-list (iterate #(-> % name first int inc char str symbol ) 'a)\n   nvars (count (first true-value-set))\n   vars (take nvars symb-list)\n   p-set (powerset #{#{}} vars)\n   attach-node (fn [node children] \n            (let [\n             filter-fun (fn[e] \n                 (every? (partial contains? (first e)) node))\n             children-n (do\n                 (filter filter-fun children))\n             value-n-1? (do\n                 (every? #(= 1 (second %1)) children-n))\n             value-n-0? (do\n                 (every? #(= 0 (second %1)) children-n))\n             value-n (if value-n-1? 1 (if value-n-0? 0 nil))\n             covering (if (= 1 value-n) (set (apply concat (map #(%1 2) children-n))))\n             ]\n             (vector node value-n covering children-n)\n            ))\n   rec-tree (fn [n children]\n            (let [n-guys (filter #(= n (count %1)) p-set)]\n             (cond \n              (= 0 n) children\n              (= nvars n)\n              (recur (dec n)\n               (map #(vector %1 (if (contains? true-value-set %1) 1 0) #{%1} nil)\n                n-guys))\n              :else       (recur (dec n) (doall (map #(attach-node %1 children)\n                          n-guys))))))\n   tree (rec-tree nvars nil)\n   fun-build-opti-set (fn rec-build-opti-set [res-set tree]\n            (cond \n             (nil? tree) res-set\n             (= 1 (second tree)) (conj res-set [(tree 0) (tree 2)])\n             :else (set (concat res-set\n                     (reduce #(rec-build-opti-set %1 %2) #{} (tree 3))))))\n    opti-set (fun-build-opti-set #{} [nil 0 nil tree])\n    sort-fun #(>= (count (second %1)) (count (second %2)))\n    fun-optimize (fn rec-optimize [ [ [s c r] & hs :as to-visit] finished min-size seen]\n            (cond \n             (empty? to-visit) finished\n             (= c true-value-set) (recur hs (conj finished s) (min (count s) min-size) (conj seen s))\n             (>= (count s) min-size) (recur hs finished min-size (conj seen s))\n             :else \n             (let [\n              ajoute (fn [[tv ff mm] [s2 c2 :as e]] ; retourne [s c r]\n                  (let [\n                   nc (set (concat c c2))\n                   cnc (count nc)\n                   dc (- cnc (count c))\n                   sf (conj s s2)\n                   seen? (contains? seen sf)\n                   nseen (conj seen sf)\n                   nmm (count sf)\n                   nr (filter #(not (every? (partial contains? (first %1)) s2)) r)\n                   termine? (= nc true-value-set)\n                   meilleur? (and termine? (<= nmm mm))\n                   pas-suffisant? (and (not termine?)\n                       (= nmm (dec mm))\n                       (< (+ cnc (count c2)) (count true-value-set))) \n                   ]\n                   (if seen?\n                    [tv ff mm nseen]\n                    (if termine?\n                     (if meilleur?\n                      [tv (set (filter #(= (count sf) (count %1)) (conj ff sf))) nmm nseen]\n                      [tv ff mm nseen])\n                     (if pas-suffisant?\n                      [tv ff mm nseen]\n                      [(conj tv [sf nc nr]) ff mm nseen])))))\n            [ntv nff nsz nseen] (reduce ajoute [hs finished min-size seen] (sort sort-fun r)) \n            ]\n            (recur (sort sort-fun ntv) nff nsz nseen))))\n    map-fun (fn [[e c]]\n            (let [\n             rc (filter (fn[k] (not (every? (partial contains? (first k)) e))) opti-set)]\n             [(conj #{} e) c rc]))\n    init-set (map map-fun opti-set)\n    optimized (fun-optimize (sort sort-fun init-set) #{} (count opti-set) #{}) \n    count-symbl (fn [s] (reduce #(+ %1 (count %2)) 0 s))\n    best (first (sort #(< (count-symbl %1) (count-symbl %2)) optimized)) \n    ]\nbest\n))", "problem": 140, "user": "51f59607e4b0abb92f97f9d5"}, {"code": ";I am forever broken by programming contests person who isn't able to resist bruteforce when it's obviously works for given size of testcases \n(fn minimize [examples]\n  (set (letfn [\n    (negated-examples-4 [examples] (for [a ['A 'a] b ['B 'b] c ['C 'c] d ['D 'd] :when (not (examples #{a b c d}))] #{a b c d})) \n    ;err. I thought it was 4 variable only task(due to nature of k maps and limitation of probably expected brute force) and now have this ugly hack\n    (negated-examples-3 [examples] (for [a ['A 'a] b ['B 'b] c ['C 'c] :when (not (examples #{a b c}))] #{a b c})) \n          (valid-rule? [rule negative-example]\n                       (not-every? negative-example rule))\n          (mask [rule examples]\n                (apply + (map-indexed #(if (every? %2 rule) (bit-shift-left 1 %1) 0) examples)))\n          \n          (search-everything [score target [[first-score first-rule] & sundry :as rules]]\n                             (if (empty? rules)\n                               (if (= score target) [] nil)\n                               (let [with (if (not= score (bit-or score first-score)) (search-everything (bit-or score first-score) target sundry) nil)\n                                     with (if with (conj with first-rule) nil)\n                                     without (search-everything score target sundry)]\n                                 (if (and with without)\n                                   (if (> (->> with (map vec) flatten count) (->> without (map vec) flatten count)) without with)\n                                   (if with with without)))))\n          ]\n    (let [correct-rules (for [a ['A 'a :none] b ['B 'b :none] c ['C 'c :none] d ['D 'd :none] \n                              :let [rule (set (remove #{:none} [a b c d]))]\n                              :when (every? (partial valid-rule? rule) ((if (= 3 (-> examples first count)) negated-examples-3 negated-examples-4) examples))]\n                          [(mask rule examples) rule])]\n      (search-everything 0 (dec (bit-shift-left 1 (count examples))) correct-rules)))))", "problem": 140, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [inputs]\n  (letfn [(negate [ch]\n            (let [code (int ch)]\n              (char ((if (< code 97) + -) code 32))))\n\n          (neg-symb [s]\n            (symbol\n             (apply str\n                    (map negate (str s)))))\n\n          (symbolize [true-vars bits]\n            (let [false-vars (map neg-symb true-vars)]\n              (set\n               (map-indexed\n                (fn [i e] (nth (if (zero? e) false-vars true-vars) i))\n                bits))))\n\n          (bin2gray [n]\n            (case n, 0 [0 0], 1 [0 1], 2 [1 1], 3 [1 0]))\n\n          (gray2bin [g]\n            (case g, 0 [0 0], 1 [0 1], 2 [1 1], 3 [1 0]))\n\n          (next-power2 [n]\n            (first\n             (drop-while #(< % n)\n                         (map #(bit-shift-left 1 %) (range)))))\n\n          (k-map [inputs]\n            (let [n (next-power2 (count (first inputs)))\n                  f (fn [x] (bin2gray x))]\n              (vec (map vec\n                        (partition n\n                                   (for [x (range n)\n                                         y (range n)\n                                         :let [vars (symbolize ['A 'B 'C 'D] (concat (f x) (f y)))]]\n                                     (if ((set inputs) vars) 1 0)))))))\n\n          (at [m x y]\n            (get-in m [(mod x (count m)) (mod y (count m))]))\n\n          (term-shapes []\n            (let [ss #{[1 1] [1 2] [1 4] [2 2] [2 4] [4 4]}]\n              (set (concat ss (map reverse ss)))))\n\n          (terms [m]\n            (let [n (count m)]\n              (set\n               (for [x0 (range n)\n                     y0 (range n)\n                     s (term-shapes)\n                     :let [[xn yn] (map + [x0 y0] s)]\n                     :let [cells (for [xi (range x0 xn), yi (range y0 yn)] [(mod xi n) (mod yi n)])]\n                     :when (every? (fn [[x y]] (= 1 (at m x y))) cells)] (set cells)))))\n\n          (is-subset [s candidate]\n            (every? #(s %) candidate))\n\n          (biggest-terms [m]\n            (loop [[h & t] (reverse (sort-by count (terms m))), mts #{}]\n              (if (nil? h) mts\n                  (recur (filter #(not (is-subset h %)) t) (into mts #{h})))))\n\n                                        ; from task #85\n          (power-set [s]\n            (if (empty? s) #{#{}}\n                (let [t (power-set (rest s))]\n                  (into t\n                        (map #(conj % (first s)) t)))))\n\n          (minterms [m]\n            (let [ones-total-count (apply + (flatten m))\n                  ts (biggest-terms m)\n                  term-combinations (power-set ts)]\n    \n              (->> term-combinations ; of all possible term combinations\n                   (filter #(= ones-total-count (count (set (apply concat %))))) ; pick complete ones\n                   (sort-by count) first ; pick the one with fewest terms\n                   )))\n\n          (xy-to-vars [[x y]]\n            (letfn [(f [x vars] (->> x gray2bin (symbolize vars)))]\n              (concat\n               (f x ['A 'B])\n               (f y ['C 'D]))))\n\n          (naive [inputs]\n            (for [term (minterms (k-map inputs))]\n              (apply clojure.set/intersection\n                     (map (comp set xy-to-vars) term))))]\n\n    (let [n (count (first inputs))\n          extra-vars (if (not= 3 n) #{} #{'d})\n          fixed-inputs (map #(into % extra-vars) inputs)]\n      (set\n       (map set\n            (map #(remove extra-vars %) (naive fixed-inputs)))))))", "problem": 140, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [fs]\n  (let [op #(if (= (str %) (.toLowerCase (str %)))\n               (.toUpperCase (str %))\n               (.toLowerCase (str %)))\n        f1 (fn [x y] (if (and\n                           (= (count x) (count y))\n                           (= 1 (count (clojure.set/difference x y))))\n                       (filter #(not (contains? (set (map op y)) (str %))) x)))\n        f (fn [x xs] (if-let [xp (seq (filter #(and\n                                                 (not (nil? %))\n                                                 (= (count %1) (dec (count x))))\n                                   (map f1 (repeat x) xs)))]\n                       (map set xp)\n                       [x]))\n        step (fn [xs] (set (mapcat f xs (repeat xs))))\n        result (second (last (take-while #(not= (first %) (second %))\n                  (iterate (fn [[x y]] [y (step y)]) [nil fs]))))\n        r1 (map (fn [x] (filter #(= % (clojure.set/intersection x %)) result)) fs)\n        r2 (set (apply concat (filter #(= 1 (count %)) r1)))]\n    r2))", "problem": 140, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [msets]\n  (let [ci-compare (fn [char1 char2] (compare (Character/toLowerCase char1) (Character/toLowerCase char2)))\n        to-binterm (fn [mset]\n                     (->>(apply str mset)\n                       (sort ci-compare)\n                       (map #(if (Character/isUpperCase %) 1 0))\n                       (vec)))\n        to-minterm (fn [binterm]\n                     (let [lsyms ['a 'b 'c 'd]\n                           usyms ['A 'B 'C 'D]]\n                     (reduce #(case (binterm %2)\n                                0 (conj % (lsyms %2))\n                                1 (conj % (usyms %2))\n                                %)\n                         #{} (range (count (first msets))))))\n        qmv0 (vec (repeat (inc (count (first msets))) #{}))\n        qmv-idx (fn [term] (count (filter #(= 1 %) term)))\n        into-qmv (fn [qmv term] (assoc qmv (qmv-idx term) (conj (qmv (qmv-idx term)) term)))\n        valid {[0 0] 0 [0 1] :x [1 0] :x [1 1] 1 [:x :x] :x}\n        one-diff (fn [term1 term2] (= 1 (count (filter false? (map = term1 term2)))))\n        combine (fn [[term1 term2]]\n                  (let [pairs (map vector term1 term2)]\n                    (when (and (not-any? nil? (map valid pairs)) (one-diff term1 term2))\n                      (vec (map valid pairs)))))\n        union (fn [s1 s2] (reduce #(conj % %2) s1 s2))\n        qmv-pairs (fn [qmv]\n                    (apply concat\n                      (for [i (range (dec (count qmv)))]\n                          (for [a (qmv i) b (qmv (inc i))]\n                            [a b]))))\n        qm-rfn (fn [new-used [term1 term2 :as qmv-pair]]\n                 (if-let [new (combine qmv-pair)]\n                   (merge-with union new-used {:new #{new} :used #{term1 term2}})\n                   new-used))\n        qm-step (fn [primes]\n                  (let [{:keys [new used]}\n                        (reduce qm-rfn {:new #{} :used #{}} (qmv-pairs (reduce into-qmv qmv0 primes)))]\n                    (union (apply disj primes (seq used)) new)))\n        qm-complete (fn [primes]\n                      (let [newprimes (qm-step primes)]\n                        (if (not= primes newprimes)\n                          (recur newprimes)\n                          primes)))\n        initial-terms (reduce #(conj % (to-binterm %2)) #{} msets)\n        primes (qm-complete initial-terms)\n        implies (fn [term1 term2]\n                  (every? true?\n                    (map #(cond\n                            (= % %2) true\n                            (= :x %) true\n                            :else false)\n                      term1 term2)))\n        essential-primes (fn [primes initial-terms]\n                           (->>(for [p primes it initial-terms][p it])\n                             (reduce (fn [m [p it]] (if (implies p it) (merge-with union m {it #{p}}) m)) {} )\n                             (filter #(= 1 (count (second %))))\n                             (map (comp first second))))\n        ]\n    (set (map to-minterm (essential-primes primes initial-terms)))))\n;ok, I punted on the covering-set step, because the essential primes alone were sufficient for these test cases", "problem": 140, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [arr]\n    (let [\n          pow2 (fn [n] (int (/ (Math/log n) (Math/log 2))))\n          c (count (first arr))\n          clr (fn [i]\n                 (let [j (sort-by count (into [] i))]\n                   (reduce (fn [lst n]\n                             (if (seq (clojure.set/difference n (reduce into #{}\n                                                                 (disj  lst n))))\n                               lst (disj lst n))) i j)))\n          grp (fn [lst cnt]\n                 (set\n                  (for [i lst j lst\n                        :let [ic  (count (apply clojure.set/intersection\n                                                        (into i j)))]\n                        :when (and (= cnt  ic)\n                                   (= (- c (pow2 (count (into i j)))) ic)\n                                   (empty? (clojure.set/intersection i j))\n                                   (#{2 4 8 16} (count (into i j))))]\n                                   \n                    (into i j))))\n          z   (set (map #(conj #{} %) arr))]\n      \n      (->> (loop [q z cnt (dec (count (first (first z)))) lg [] ]\n             (let [n (grp q cnt)]\n               (if (empty? n) (clr q)\n                   (recur  (into q n) (dec cnt) (cons [cnt n [:q q]]  lg)))))\n           (map #(apply clojure.set/intersection %))\n              set)))", "problem": 140, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn [input] \n  (let [mp #(- (int %) (int \\a))\n        s2c #((comp first str) %)\n        cap? (fn [sb] (< (int sb) 97))\n        decap #(if (cap? %) (char (+ 32 (int %))) %)\n        getv (fn [s] (reduce \n                       #(assoc %1 (mp (decap (s2c %2))) \n                               (if (cap? (s2c %2)) 1 0))\n                       (vec (repeat 4 0)) s))\n        ky {0 0 1 1 3 2 2 3}\n        f2t #(vector (ky (+ (* 2 (get % 0)) (get % 1)))\n                     (ky (+ (* 2 (get % 2)) (get % 3))))\n        input (mapcat #(if (= 3 (count %)) \n                         [(conj % 'D) (conj % 'd)]\n                         [%]) input)\n        kmap (set (map (comp f2t getv) input))\n        size [[4 4] [4 2] [2 4] [4 1] [1 4] [2 2] [2 1] [1 2] [1 1]]\n        tkpnts (fn [[x y] [dx dy]]\n                  (let [fx (+ x dx)  \n                        fy (+ y dy)]\n                    (for [i (range x fx) j (range y fy)]\n                      [(mod i 4) (mod j 4)])))\n        getr (fn [p sz]\n               (when (every? identity (map kmap (tkpnts p sz)))\n                 p))\n        nsum (fn [s] (apply + (map (fn [[x [a b]]] (* a b)) s)))\n        least (fn [st] \n                (reduce #(if (or\n                               (and (= (count %1) (count %2))\n                                    (< (nsum %1) (nsum %2)))\n                               (> (count %1) (count %2)))\n                           %2 %1) st))\n        f (fn f [km [sz & rt :as all]]\n            ;(println km sz)\n            (if (empty? km) '() \n              (let [rets (filter #(getr % sz) km)\n                    nkms (for [i rets] \n                           (apply disj km (tkpnts i sz)))]\n                (println nkms)\n                (if (empty? rets)\n                  (f km rt)\n                  (least\n                    (concat\n                      ;(when rt [(f km rt)])\n                      (when rt\n                      (map cons (map #(vector % sz) rets)\n                           (map #(f % rt) nkms)))\n                      (map cons (map #(vector % sz) rets) \n                           (map #(f % all) nkms))))))))\n        rects (f kmap size)\n        p2s1 {0 #{'a 'b} 1 #{'a 'B} 2 #{'A 'B} 3 #{'A 'b}}\n        p2s2 {0 #{'c 'd} 1 #{'c 'D} 2 #{'C 'D} 3 #{'C 'd}}\n        p2s (fn [[a b]] \n              (into (p2s1 a) (p2s2 b)))\n        ret (map #(map p2s (apply tkpnts %)) rects)]\n    (set (map #(apply clojure.set/intersection %) ret))))", "problem": 140, "user": "51944aaae4b0142f60b4aedc"}, {"code": ";;; NOTE, XXX, Fri Oct 25 2013, Francis Wolke\n\n;;; This is, for all intents and purposes, a glorifed `cond' statement because I didn't\n;;; (and don't) don't have the time to capture the essence of k-maps.\n\n;;; I consider this to be a non-solution as it's too specific to these test cases.\n;;; If I were solve it again, I'd implment an existing algorithm rather than using\n;;; k-maps. Namely,\n\n;;; http://en.wikipedia.org/wiki/Quine-McCluskey_algorithm\n;;; http://en.wikipedia.org/wiki/Petrick's_method\n\n(fn [circuit]\n  (letfn [(pair->coord [g]\n            (let [k (cond (or (= g '[a b]) (= g '[c d])) \"00\" \n                          (or (= g '[a B]) (= g '[c D])) \"01\"\n                          (or (= g '[A B]) (= g '[C D])) \"11\"\n                          (or (= g '[A b]) (= g '[C d])) \"10\")]\n              ({\"00\" 0 \"01\" 1 \"11\" 2 \"10\" 3} k)))\n\n          (x-pair [st] [(or (st 'a) (st 'A)) (or (st 'b) (st 'B))])\n          (y-pair [st] [(or (st 'c) (st 'C)) (or (st 'd) (st 'D))])\n\n          (k-map [circuit]\n            (let [x-axis '[C D]\n                  y-axis '[A B]\n                  mtx (vec (repeat 4 [0 0 0 0]))\n                  k-map (loop [circuit circuit\n                               mtx mtx]\n                          (if (empty? circuit)\n                            mtx\n                            (let [fc (first circuit)\n                                  x (pair->coord (x-pair fc))                        \n                                  y (pair->coord (y-pair fc))]\n                              (recur (rest circuit)\n                                     (assoc-in mtx [y x] 1)))))]\n              k-map))\n\n          (valid-structures\n            [k-map [y x]]\n            (let [v (partial get-in k-map)\n                  plate (fn [v struct] (when (every? #{1} v) struct))\n                  square (plate [(v [y x]) (v [y (inc x)]) (v [(inc y) x]) (v [(inc y) (inc x)])] :square)\n                  rect-2-v (plate [(v [y x]) (v [(inc y) x])] :rect-2-v)\n                  rect-2-h (plate [(v [y x]) (v [y (inc x)])] :rect-2-h)\n                  rect-4-v (plate [(v [y x]) (v [(inc y) x]) (v [(+ 2 y) x]) (v [(+ 3 y) x])] :rect-4-v)\n                  rect-4-h (plate [(v [y x]) (v [y (inc x)]) (v [y (+ 2 x)]) (v [y (+ 3 x)])] :rect-4-h)]\n              (remove nil? (if (or square rect-4-v rect-4-h)\n                             [square rect-4-v rect-4-h]\n                             [square rect-2-v rect-2-h rect-4-v rect-4-h]))))\n\n          (solve-kmap [k-map]\n            (loop [cursor [0 0]\n                   acc []]\n              (let [[y x] cursor]\n                (if (= 4 y)\n                  acc\n                  (recur (if (= 3 x) [(inc y) 0] [y (inc x)])\n                         (conj acc [cursor (valid-structures k-map cursor)]))))))\n\n          (coordinates-of [shape [y x]]\n            (case shape\n              :square #{[y x] [y (inc x)] [(inc y) x] [(inc y) (inc x)]}\n              :rect-2-v #{[y x] [(inc y) x]}\n              :rect-2-h #{[y x] [y (inc x)]}\n              :rect-4-v  #{[y x] [(inc y) x] [(+ 2 y) x] [(+ 3 y) x]}\n              :rect-4-h  #{[y x] [y (inc x)] [y (+ 2 x)] [y (+ 3 x)]}))\n\n          (subset-of?\n\n            [a coords-a b coords-b]\n            (let [trumps #{:square :rect-4-v :rect-4-h}\n                  ca (coordinates-of a coords-a)\n                  cb (coordinates-of b coords-b)]\n              (when-not (trumps b)\n                (not= (+ (count cb) (count ca))\n                      (count (clojure.set/union ca cb))))))\n\n          (remove-redundant-structures [structures]\n            (let [trumps #{:square :rect-4-v :rect-4-h}]\n              (loop [i 0 gs (vec structures)]\n                (if (= i (count gs))\n                  gs\n                  (let [[coords top-level-shape] (gs i)]\n                    (recur (inc i)\n                           (if (trumps top-level-shape)\n                             (vec (remove (fn [[cds shp]] (subset-of? top-level-shape coords shp cds)) gs))\n                             gs)))))))\n\n          (cancel-terms [[a b] [c d]]\n            [(when (= a c) a) (when (= b d) b)])\n\n          (coords->bool-exp [cds]\n            (let [z {0 \"00\" 1 \"01\" 2 \"11\" 3 \"10\"}\n                  a (mapv (fn [[y x]] [(z y) (z x)]) cds)\n                  xs (mapv vec (map first a))\n                  ys (mapv vec (map second a))\n                  out {:y (reduce cancel-terms ys)\n                       :x (reduce cancel-terms xs)}]\n\n              (into (case (:y out)\n                      [nil \\1] '#{B}\n                      [\\1 nil] '#{A}\n                      [nil nil] #{}\n                      [\\1 \\1] '#{A B}\n                      [nil \\0] '#{b}\n                      [\\0 nil] '#{a}\n                      [\\0 \\0] '#{a b}\n                      [\\1 \\0] '#{A b}\n                      [\\0 \\1] '#{a B})\n\n                    (case (:x out)\n                      [nil \\1] '#{D}\n                      [\\1 nil] '#{C}\n                      [nil nil] #{}\n                      [\\1 \\1] '#{C D}\n                      [nil \\0] '#{d}\n                      [\\0 nil] '#{c}\n                      [\\0 \\0] '#{c d}\n                      [\\1 \\0] '#{C d}\n                      [\\0 \\1] '#{c D}))))\n\n\n          (dt [m]\n            (if (some coll? (first m))\n              (set (first (map (fn [l]\n                                 (let [[syms rs] ((juxt #(filter symbol? %) #(remove symbol? %)) l)]\n                                   (map #(into % syms) rs)))\n                               m))) m))\n\n          (complement-of [sym]\n            (if ('#{A B C D} sym)\n              (symbol (.toLowerCase (str sym)))\n              (symbol (.toUpperCase (str sym)))))\n\n          (other-reduction [fm]\n            (let [f (ffirst fm)\n                  cf (complement-of (ffirst fm))\n                  s (second fm)]\n              (if (and (= #{1 2} (set (map count fm)))\n                       (s cf))\n                `#{#{~f} ~(set (remove #{cf} s))}\n                fm)))\n\n          (deep-or [form]\n            (cond (and (coll? form)\n                       (= 3 (count form))) (other-reduction form)\n                       (coll? form) (map other-reduction form)\n                       :else form))\n\n          (deep-complement [form]\n            (if (symbol? form)\n              (complement-of form)\n              (set (map deep-complement form))))\n\n          (remove-complements [form]\n            (let [form (if (coll? form)\n                         (remove #(and (not (symbol? %)) (empty? %)) form)\n                         form)]\n              (cond (symbol? form) form\n                    (and (= 2 (count form))\n                         (= (deep-complement (first form)) (second form))) #{}\n                    :else (set (map remove-complements form)))))\n\n          (next-to-factor [st]\n            (let [fst (frequencies (flatten (map seq st)))\n                  o  (reverse (sort-by second (partition 2 (interleave (keys fst) (vals fst)))))]\n              (ffirst o)))\n\n          (factor-out [st]\n            (loop [st st\n                   acc #{}]\n              (if (every? empty? st)\n                acc\n                (let [in-q (next-to-factor st)]\n                  (recur (remove #(contains? % in-q) st)\n                         (let [g (set (factor-out (map #(set (remove #{in-q} %)) (filter #(contains? % in-q) st))))]\n                           (if (= 1 (count st))\n                             (conj acc (first st))\n                             (conj acc #{in-q g}))))))))\n\n          (solve-using-boolean-algebra [circuit]\n            (loop [d circuit\n                   old nil]\n              (if (= old d)\n                (loop [d d\n                       old nil]\n                  (if (= old d)\n                    d\n                    (recur (dt d) d)))\n                (recur (loop [h (factor-out d) o nil]\n                         (if (= o h) h\n                             (recur (remove-complements h) h)))\n                       d))))]\n\n    (if (= 3 (count (first circuit)))\n      (solve-using-boolean-algebra circuit)\n      (let [c (k-map circuit)\n            g (solve-kmap c)\n            [[x0 x1 x2 x3]\n             [x10 _ _ x13]\n             [x20 _ _ x23]\n             [y0 y1 y2 y3]] c\n            out (vec (remove #(empty? (second %)) g))\n            corners [x0 x3 y0 y3]\n            corners (when (every? #{1} corners) corners)\n            sidev [x1 x2 y1 y2]\n            sideh [x10 x20 x13 x23]\n            sides (when (and (every? #{1} sidev) (every? #{1} sideh))\n                    [sidev sideh])\n            clean-structs (remove-redundant-structures (mapv (fn [[a b]] [a (first b)]) out))\n            result (set (map (fn [[c s]] (coords->bool-exp (coordinates-of s c))) clean-structs))]\n\n        (cond (and (empty? clean-structs) (nil? corners)) circuit\n              sides (set (map coords->bool-exp [#{[1 0] [2 0] [1 3] [2 3]}\n                                                #{[0 1] [0 2] [3 1] [3 2]}]))\n              corners (conj result (coords->bool-exp #{[0 0] [0 3] [3 3] [3 0]}))\n              :else result)))))", "problem": 140, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn veitch [baf]\n  (let [simp (fn [m1 m2]\n               (let [s1 (first m1) s2 (first m2) c1 (count s1)] \n                 (when (= c1 (count s2))\n                   (let [i (set (keep s1 s2))]\n                     (when (= (count i) (dec c1))\n                       (let [d1 (filter (complement i) s1)\n                             d2 (filter (complement i) s2)]\n                         (when (and (= 1 (count d1) (count d2))\n                                    (= (.toLowerCase (str (first d1)))\n                                       (.toLowerCase (str (first d2)))))\n                           [i (into (second m1) (second m2))])))))))\n        iter (fn [baf] \n               (reduce (fn [m [k v]] (assoc m k v)) {} \n                      (for [s1 baf s2 baf :when (not= s1 s2)\n                            :let [i (simp s1 s2)] :when i] \n                        i)))\n        mitm (->> baf (reduce #(assoc % %2 (hash-set %2)) {})\n                (iterate iter) (take-while seq) (apply merge))\n        mits (sort-by count (map key mitm))\n        sols (fn sols [comb]\n               (lazy-cat comb (sols (for [ps comb mt mits] (conj ps mt)))))\n        vald (fn [sol]\n               (= baf (reduce #(into % (mitm %2)) #{} sol)))]\n    (first (filter vald (sols (map #(hash-set %) mits))))))", "problem": 140, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn vepl [src]\n   (let [k2q {[:A false] 'a, [:A true] 'A, [:B false] 'b, [:B true] 'B, [:C false] 'c, [:C true] 'C, [:D false] 'd, [:D true] 'D }\n         q2f {'a not, 'A identity, 'b not, 'B identity,'c not, 'C identity,'d not, 'D identity}\n         q2k (fn [q] [(keyword(clojure.string/upper-case q))(q q2f)])\n         bin (map #(into {}(map (fn [x y] [y (= x \\1)]) (.replace (format (str \"%4s\") (Integer/toBinaryString %)) \" \" \"0\") [:A :B :C :D])) (range 16)) \n         tt (into {}(map (fn[b] [b(reduce (fn[v1 v2](or v1 v2))\n                                          (map (fn [f] (every? true? (map (fn [ff] ((peek ff) ((first ff) b)))f))) \n                                               (map #(map q2k %) src)))])bin))\n         kma [[false false] [false true][true true][true false]]\n         get-ij (fn [i j](get tt (into {}(concat(map vector [:A :B] (get kma j))(map vector [:C :D] (get kma i))))))\n         get-ijv (fn [v] (get-ij (first v)(peek v)))\n         ones (filter #(get-ijv %) (for [i (range 4) j (range 4)] [i j]))\n         area (fn [face] (* (first face) (peek face)))\n         all-faces (sort-by area >(for [x [1 2 4] y [1 2 4]] [x y]))\n         get-items (fn [face one](let [fo (first one) lo (peek one)](for[i(range fo(+ fo(first face))) j (range lo(+ lo(peek face)))] [(mod i 4) (mod j 4)])))\n         chk-fo (fn [face one](let [items (get-items face one)] [(= (area face)(count(filter #(get-ijv %) items))) one face (set items)]))\n         faces (sort-by #(-> % second area) > (map rest (map (fn [one] (first(filter first (map (fn [face] (chk-fo face one)) all-faces)))) ones)))\n         rm-sbs(loop [s faces rslt[]]\n                 (if (empty? s) rslt\n                     (recur (filter #(not (clojure.set/superset? (-> s first last) (last %))) s) (conj rslt (first s))))\n                 )\n         ready (loop [s rm-sbs i 0 rslt[]]\n                 (if (= i (count s)) rslt\n                   (recur s (inc i) (if (= (set ones) (set(mapcat last (concat (take i rm-sbs)(drop (inc i) rm-sbs))))) rslt (conj rslt (nth s i))))\n                   )\n                 )\n         vb (fn[f p](->> f last (map p) set (map(fn[i] (get kma i)))))\n         ]\n     (->> ready (map #(vector(vb % first)(vb % last)))\n          (map #(vector(vector :C (->> % first (map first) distinct))\n                       (vector :D (->> % first (map last) distinct))\n                       (vector :A (->> % last (map first) distinct))\n                       (vector :B (->> % last (map last) distinct))\n                       ))\n          (map #(filter (fn[x](= 1(count(peek x)))) %))\n          (map #(map (fn[x] [(first x) (first(peek x))]) %))\n          (map #(set(map (fn[x] (get k2q x))%)))\n          set\n          )\n         \n     )\n    )", "problem": 140, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn [mk-cmp s]\n  (let [all-sets \n        (set (reduce #(for [a % b %2] (conj a b))\n                     [#{}]\n                     (if (= (count (first s)) 3)\n                       '[[a A] [b B] [c C]]\n                       '[[a A] [b B] [c C] [d D]])))\n        all-subsets\n        (filter #(< 0 (count %) 5)\n                (reduce #(into % (for [a % b %2] (conj a b)))\n                        [#{}]\n                        (if (= (count (first s)) 3)\n                          '[[a A] [b B] [c C]]\n                          '[[a A] [b B] [c C] [d D]])))]\n    (let [oppset (clojure.set/difference all-sets s)]\n      (set  ( (fn iter [s sbs]\n                (if (empty? s)\n                  []\n                  (some (fn [ss] (let [o (filter #(clojure.set/subset? ss %) s)\n                                       n (filter #(clojure.set/subset? ss %) oppset)]\n                                   (when (and (not (empty? o)) (empty? n))\n                                     (when-let\n                                         [sms (iter\n                                               (clojure.set/difference s (set o))\n                                               (remove #{ss} sbs))]\n                                       (conj sms ss)))))\n                        (sort-by identity (mk-cmp s) sbs))))\n              s\n              all-subsets)))))\n\n(fn [s]\n  (fn [s1 s2]\n    (let [a (count (filter #(clojure.set/subset? s2 %) s))\n          b (count (filter #(clojure.set/subset? s1 %) s))]\n      (if (= a b)\n        ((comparator <) (count s1) (count s2))\n        ((comparator <) a b)))))", "problem": 140, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [x]\n  (letfn\n    [\n      (all-in? [as bs]\n        (every? true? (for [a as] (some true? (for [b bs] (empty? (remove a b)))))))\n\n      (logm [a b]\n        (let [ c (set (filter a b)) d (remove c (into a b))\n               u (set (map clojure.string/upper-case d))]\n          (if (and (= 1 (count u)) (= 2 (count d))) c nil)))\n\n      (fold-1 [x]\n        (let [n (remove nil? (distinct (for [a x b x] (logm a b))))\n              l (for [a x b n :when (empty? (remove a b))] a)]\n          (list n (remove (set l) x))))\n\n      (log-red [x]\n        (loop [c #{} v x]\n          (let [[n r] (fold-1 v) nc (into c r)]\n            (if (empty? n) nc (recur nc n)))))\n\n      (dedup [x a]\n        (loop [xs (set [x])]\n          (let [n (for [x xs i x :let [r (disj x i)] :when (all-in? a r)] r)]\n            (if (empty? n) (first xs) (recur (set n))))))\n      ]\n    (dedup (log-red x) x)))", "problem": 140, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn simplify [inputs]\n  (let [functions {'A 'a, 'a 'A, 'B 'b, 'b 'B, 'C 'c, 'c 'C, 'D 'd, 'd 'D}\n        filter-candidates (fn [input candidates]\n                            (->> (filter #(= (count input) (count %)) candidates)\n                                 (filter #(= (dec (count input)) (count (clojure.set/intersection input %))))\n                                 (filter #(contains? % (functions (first (clojure.set/difference input %)))))))\n        simplified-inputs (->> (map #(vector % (disj inputs %)) inputs)\n                               (map #(vector (first %) (first (filter-candidates (first %) (second %)))))\n                               (map #(if (empty? (second %))\n                                       (first %)\n                                       (apply clojure.set/intersection %)))\n                               (sort #(compare (count %1) (count %2)))\n                               (reduce (fn [acc i] (if (some #(clojure.set/subset? % i) acc)\n                                                     acc\n                                                     (conj acc i)))\n                                       #{}))]\n    (if (= inputs simplified-inputs)\n      inputs\n      (simplify simplified-inputs))\n  )\n)", "problem": 140, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn n140 [true-maps]\n  (letfn [(cap-comple [x]\n                      (let [x1 (first (name (first x)))]\n                        (if (java.lang.Character/isUpperCase x1)\n                          #{(symbol (.toLowerCase (str x1)))}\n                          #{(symbol (.toUpperCase (str x1)))})))\n          (get-reduced [a b i]\n                       (cond\n                         (= (cap-comple a) b) #{i}\n                         (clojure.set/subset? (cap-comple a) b) #{(clojure.set/union i (clojure.set/difference b (cap-comple a))) \n                                                                  (clojure.set/union i a)} \n                         :else false))\n          (combinable [x y]\n                      (let [x-y (clojure.set/difference x y)\n                            y-x (clojure.set/difference y x)\n                            xiy (clojure.set/intersection x y)\n                            single (cond \n                                     (empty? x-y) :x-sub\n                                     (empty? y-x) :y-sub\n                                     (= (count x-y) 1) :x-y\n                                     (= (count y-x) 1) :y-x\n                                     :else :false)]\n                        (case single\n                          :false false\n                          :x-sub #{x}\n                          :y-sub #{y}\n                          :x-y (get-reduced x-y y-x xiy)\n                          :y-x (get-reduced y-x x-y xiy))))\n          (one-iter [true-maps]\n                    (loop [c true-maps a #{}]\n                      (if (empty? c)\n                        a\n                        (let [f (first c)\n                              cr (set (rest c))\n                              chd (reduce clojure.set/union (filter identity (map (partial combinable f) cr)))\n                              new-c (clojure.set/difference cr (set (filter (partial combinable f) cr)))\n                              new-a (clojure.set/union (if (empty? chd) #{f} chd) a)\n                              ]\n                          (recur new-c new-a)))))]\n    (loop [t true-maps]\n      (let [new-t (one-iter t)]\n        (if (= t new-t)\n          t\n          (recur new-t))))))", "problem": 140, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [ss]\n    (let [\n          lower #{'a 'b 'c 'd}\n          upper #{'A 'B 'C 'D}\n          mapping {'A 'a 'B 'b 'C 'c 'D 'd}\n\n          to-lower (fn  [term]\n                     (if (upper term)\n                       (mapping term)\n                       term))\n\n          U clojure.set/union\n          N clojure.set/intersection\n          subset? clojure.set/subset?\n          *- clojure.set/difference\n\n          join (fn  [b1 b2]\n                 (let [difference (*- b1 b2)\n                       difference-count (count difference)\n                       diff (to-lower (first difference))]\n                   (if (= 1 difference-count)\n                     (U #{(str diff \"-\")} (N b1 b2)))))\n\n          find-implicants (fn  [s]\n                            (set (mapcat (fn [s']\n                                           (let [implicants\n                                                 (remove nil? (map #(join s' %) s))]\n                                             (if (empty? implicants)\n                                               [s']\n                                               implicants)))\n                                         s)))\n\n\n\n\n\n          fixed-point (fn  [f input]\n                        (let [values (iterate f input)]\n                          (ffirst (drop-while\n                                   #(apply not= %)\n                                   (partition 2 values)))))\n\n          remove- (fn  [ss]\n                    (set (map (fn [s]\n                                (*- s #{\"a-\" \"b-\" \"c-\" \"d-\"}))\n                              ss)))\n\n          essential? (fn  [s ss]\n                       (let [all-others (apply U (disj ss s))]\n                         (not= #{} (*- s all-others))))\n\n          find-essential (fn  [ss]\n                           (filter #(essential? % ss) ss))]\n\n      (set\n       (if (= (find-implicants ss) ss)\n         ss\n         (find-essential\n          (remove- (fixed-point find-implicants ss)))))))", "problem": 140, "user": "4daea889edd6309eace4d15b"}, {"code": "(letfn [(upsym [s]\n                (symbol (clojure.string/upper-case (name s))))\n              (downsym [s]\n                (symbol (clojure.string/lower-case (name s))))\n              (swapsym [s]\n                (if (= s (upsym s))\n                  (downsym s)\n                  (upsym s)))\n              (independent [sym s sets]\n                (let [indep (disj s sym)\n                      swapped (conj indep (swapsym sym))]\n                  (if (or (contains? sets indep)\n                          (contains? sets swapped))\n                    indep\n                    false)))\n              (update1 [s sets]\n                (if-let [indep (some #(independent % s sets) s)]\n                  indep\n                  s))\n              (update [sets]\n                (set (map #(update1 % sets) sets)))]\n        (fn min-set [sets]\n          (if (= (update sets) sets)\n            sets\n            (min-set (update sets)))))", "problem": 140, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [s]\n    (let [dff #{#{'a 'A} #{'b 'B} #{'c 'C} #{'d 'D}}\n          ins (fn [v p]\n                (let [n (dec (count v))]\n                  (filter #(and (= (count (second %)) n)\n                             (contains? dff (into (clojure.set/difference v (second %))\n                                              (clojure.set/difference (first %) (second %)))))\n                    (map #(vector % (clojure.set/intersection v %)) p))))\n          all-ins (fn all-ins [[z w :as u] t]\n                    (if (empty? t) u\n                      (let [v (first t) p (rest t) f (ins v p) out (map first f)]\n                        (all-ins (if (empty? out) u [(into (into z out) #{v}) (into w (map second f))]) p))))\n          f (fn f [x a] (let [r (all-ins [#{} #{}] x)\n                              v (second r)\n                              res (into a (clojure.set/difference x (first r)))\n                              ]\n                          (if (empty? v) res (f v res))))\n          all (f s #{})]\n      (set (if (= all s) all\n        (filter (fn [y]\n                  (let [r (apply clojure.set/union (clojure.set/difference all #{y}))]\n                    (some #(not (contains? r %)) y))) all)))))", "problem": 140, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [ss]\n  (let [to-str #(str %)\n        iter-0 (set (map (fn [s] (apply str (sort-by #(.toLowerCase %) (map str s)))) ss))\n        word-len (count (first iter-0))\n        word-max (bit-shift-left 1 word-len)\n        basecell (fn [n]\n                   (->> (range word-len)\n                     (map #(if (= 1 (bit-and 1 (bit-shift-right n %)))\n                             (char (+ 65 %)) (char (+ 97 %))))\n                     (apply str)))\n        full-set (map basecell (range word-max))\n        cut-one (fn [s n] (str (subs s 0 n) \".\" (subs s (inc n))))\n        covers? (fn [a b] (boolean (re-matches (re-pattern a) b)))\n        point-count (fn [s] (count (filter #(= \\. %) s)))\n        \n        diff-by-1? (fn [a b]\n                     (let [diff (->> (map vector a b)\n                                  (map #(if (apply = %) (first %) \\#)))\n                           c (count (filter #{\\#} diff))]\n                       (if (= c 1) (apply str (replace {\\# \\.} diff)))))\n\n        diff-by-1s (fn [xs]\n                     (set (filter identity (for [a xs b xs] (diff-by-1? a b)))))\n        \n        iter (fn [current i]\n               (let [cuts (filter\n                            #(= (point-count %) i)\n                           (for [j (range word-len) s current] (cut-one s j)))\n                     primes (doubles cuts)]\n                 (println :cuts cuts)\n                 primes))\n        \n        clean-gen (fn [hi lo]\n                    (set (filter (fn [l] (not (some #(covers? % l) hi))) lo)))\n        \n        merge-gen (fn [hi lo]\n                    (clojure.set/union hi (clean-gen hi lo)))\n        \n        iterations (take word-len (iterate diff-by-1s iter-0))\n        \n        to-set (fn [s]\n                 (set (filter #(covers? s %) full-set)))\n        \n        union (fn [xs]\n                     (->> xs (map to-set) (reduce clojure.set/union)))\n        \n        redundant (fn [xs test]\n                    (let [test-set (to-set test)\n                          others (union (clojure.set/difference xs #{test}))]\n                      (= (clojure.set/intersection test-set others) test-set)))\n        \n        remove-redundant (fn [xs]\n                           (filter #(not (redundant xs %)) xs))\n\n        to-output (fn [s]\n                    (->> s (remove #{\\.}) (map str) (map symbol) set))]    \n\n       (->> (reverse iterations)\n            (reduce merge-gen)\n            remove-redundant\n            (map to-output)\n            set)))", "problem": 140, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [s]\n  (let [neg '{a A A a b B B b c C C c d D D d}]\n    (letfn [(butp [p r] (set (remove (set p) r)))\n            (subset? [sub super] (every? #(contains? super %) sub))\n            (covers? [r s] (empty? (remove (fn [k] (some #(subset? % k) r)) s)))\n            (aggr-by [r p]\n              (->>\n                [(filter #(contains? % p) r) (filter #(contains? % (neg p)) r)]\n                (map (fn [q] (map #(butp [p (neg p)] %) q)))\n                (apply #(set (filter (set %1) %2)))\n                (#(into % (remove (fn [k] (contains? % (butp [p (neg p)] k))) r)))))\n            (branch [r p]\n              (if (empty? p)\n                r\n                (set (mapcat #(branch (aggr-by r %) (butp [%] p)) p))))\n            (cleanup [r k]\n              (if (some #(subset? % k) r)\n                r \n                (remove #(covers? (butp [%] (conj r k)) s) (conj r k))))]\n    (set (reduce cleanup #{} (sort-by count (branch s (first s))))))))", "problem": 140, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(letfn [(expand [[v e]]\n          (when (seq e)\n            (cons [(conj v (first e)) (rest e)]\n                  (expand [v (rest e)]))))\n        (partitions [coll]\n          (->> (iterate (partial mapcat expand) [[[] coll]])\n               (drop 1)\n               (take (count coll))\n               (apply concat)\n               (map first)))\n        (gray-code [n]\n          (let [pfix (fn [coll x] (map (partial cons x) coll))]\n            (nth (iterate #(concat (pfix % 0) (pfix (reverse %) 1)) '((0) (1))) (dec n))))\n        (member [itm coll]\n          (when-let [s (seq coll)]\n            (if (= itm (first s))\n              s\n              (recur itm (rest s)))))]\n  (fn karnaugh [sat]\n    (let [len (count (first sat))\n          x (quot len 2)\n          y (- len x)\n          xg (vec (gray-code x))\n          yg (vec (gray-code y))\n          testers (->> (range 65 (+ len 65)) (map (comp symbol str char)))\n          to-symbols (fn [coll]\n                       (into #{} (map #(-> (+ %1 (if (zero? %2) 32 0)) char str symbol)\n                                      (range 65 (+ len 65)) coll)))\n          bit-pos (fn [sat] (map #(if (sat %) 1 0) testers))\n          idx (fn [x coll] (->> (member x coll) count (- (count coll))))\n          pos (fn [sat]\n                (let [[l r] ((juxt take drop) x (bit-pos sat))]\n                  (list (idx r yg) (idx l xg))))\n          ones (set (map pos sat))\n          dirs '((0 1) (1 0) (0 -1) (-1 0))\n          next-rect (fn [sat dir]\n                      (let [new (->> (map (partial map (comp #(mod % len) +) dir) sat)\n                                     (reduce conj sat))]\n                        (when (every? #(ones %) new) new)))\n          next-rects (fn [coll]\n                       (into #{} (for [x coll\n                                       d dirs\n                                       r (when-let [s (next-rect x d)] (list s))]\n                                   r)))\n          good-rect? (fn [sat]\n                       (let [c (count sat)\n                             s (last (take-while #(<= % c) (iterate #(bit-shift-left % 1) 1)))]\n                         (= c s)))]\n      (->> (take (inc len) (iterate next-rects (set (map (fn [x] #{x}) ones))))\n           (apply clojure.set/union)\n           (filter good-rect?)\n           (sort-by (comp - count))\n           (reduce #(if (clojure.set/subset? %2 (apply clojure.set/union %1))\n                      %1\n                      (conj %1 %2)) '())\n           partitions\n           (drop-while #(not= (apply clojure.set/union %) ones))\n           first\n           (map #(map (comp to-symbols (fn [[y x]] (concat (xg x) (yg y)))) %))\n           (map (partial apply clojure.set/intersection))\n           set))))", "problem": 140, "user": "50645e12e4b007509339a58a"}, {"code": "(fn [clauses]\n  (let [norm-var (fn [sym]\n                   (let [s (str sym)]\n                     (mapv symbol [(.toUpperCase s) (.toLowerCase s)])))\n        vars (set (map norm-var (reduce clojure.set/union clauses)))\n        gray-code (fn self [vars]\n                    (if (empty? vars) (list nil)\n                      (let [[p n] (first vars)\n                            r (self (rest vars))]\n                        (concat (map #(cons n %) r) (map #(cons p %) (reverse r))))))\n        eval-cnf (fn [cnf assigns]\n                   (true? (some #(clojure.set/subset? % assigns) cnf)))\n        karnaugh-map (fn [vars cnf]\n                       (let [n (count vars)\n                             [rows cols] (map gray-code (split-at (quot n 2) vars))]\n                         {:rows (vec rows),\n                         :cols (vec cols),\n                         :map (mapv (fn [r]\n                                      (mapv (fn [c]\n                                              (eval-cnf clauses (-> #{} (into r) (into c))))\n                                            cols))\n                                    rows)}))\n        minterms (fn [{rows :rows, cols :cols, kmap :map}]\n                   (let [n (count kmap)\n                         m (count (kmap 0))\n                         partial-sum (let [get (fn [x y]\n                                                 (get-in kmap [(mod x n) (mod y m)]))\n                                           sum (let [f (fn [self x y]\n                                                         (if (or (zero? x) (zero? y))\n                                                           0\n                                                           (+\n                                                            (if (get (dec x) (dec y)) 1 0)\n                                                            (self self x (dec y))\n                                                            (self self (dec x) y)\n                                                            (- (self self (dec x) (dec y))))))\n                                                     mf (memoize f)]\n                                                 (partial mf mf))]\n                                       (fn [x y xl yl]\n                                         (let [x2 (+ x xl)\n                                               y2 (+ y yl)]\n                                           (-\n                                            (+ (sum x2 y2) (sum x y))\n                                            (+ (sum x y2) (sum x2 y))))))\n                         terms (for [x (range n)\n                                     y (range m)\n                                     xl (take-while #(<= % n) (iterate #(+ % %) 1))\n                                     yl (take-while #(<= % m) (iterate #(+ % %) 1))\n                                     :when (= (* xl yl) (partial-sum x y xl yl))]\n                                 [x y xl yl])\n                         notcovered (remove (fn [[x1 y1 xl1 yl1 :as t1]]\n                                              (some (fn [[x2 y2 xl2 yl2 :as t2]]\n                                                      (and (not= t1 t2)\n                                                           (<= x2 x1) (<= y2 y1)\n                                                           (>= (+ x2 xl2) (+ x1 xl1)) (>= (+ y2 yl2) (+ y1 yl1)))) terms)) terms)\n                         get-assigns (fn [[x y xl yl]]\n                                       (let [get #(set (%1 (mod %2 (count %1))))]\n                                         (clojure.set/union\n                                          (reduce clojure.set/intersection (for [a (range xl)] (get rows (+ x a))))\n                                          (reduce clojure.set/intersection (for [b (range yl)] (get cols (+ y b)))))))\n                         terms (for [[asn [[x y xl yl] & _]] (group-by get-assigns notcovered)]\n                                 [asn (set\n                                       (for [a (range xl) b (range yl)]\n                                         [(mod (+ x a) n) (mod (+ y b) m)]))])\n                         search (let [num1 (apply + (map #(count (filter true? %)) kmap))]\n                                  (fn search [taken maxd covered]\n                                    (cond\n                                     (< maxd (count taken)) nil\n                                     (= num1 (count covered)) taken\n                                     :else (first (remove nil?\n                                                          (for [[asn ones] terms\n                                                                :when (not (taken asn))]\n                                                            (search (conj taken asn) maxd (into covered ones))))))))]\n                     (first (remove nil?\n                                    (for [d (range 1 (inc (count terms)))]\n                                      (search #{} d #{}))))))]\n    (minterms (karnaugh-map vars clauses))))", "problem": 140, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [input-fn]\n    (let [bit (fn [n]\n                (bit-shift-left 1 n))\n          m-notation (fn [set-notation]\n                       (bit-or\n                         (if (set-notation 'A) (bit 0) 0)\n                         (if (set-notation 'B) (bit 1) 0)\n                         (if (set-notation 'C) (bit 2) 0)\n                         (if (set-notation 'D) (bit 3) 0)))\n          grey-map [2r0000 2r0001 2r0011 2r0010\n                    2r0100 2r0101 2r0111 2r0110\n                    2r1100 2r1101 2r1111 2r1110\n                    2r1000 2r1001 2r1011 2r1010]\n          bits (->> input-fn\n                    (map m-notation)\n                    (map grey-map)\n                    (map bit)\n                    (apply bit-or))\n          shapes [2r1111111111111111 ; size 16\n                  2r1111111100000000 ; size 8\n                  2r1100110011001100\n                  2r1111000000000000 ; size 4\n                  2r1000100010001000\n                  2r1100110000000000\n                  2r1100000000000000 ; size 2\n                  2r1000100000000000\n                  2r1000000000000000]; size 1\n          translate-right (fn [shape]\n                            (bit-or\n                              (bit-and\n                                (bit-shift-right shape 1)\n                                2r0111011101110111)\n                              (bit-and\n                                (bit-shift-left shape 3)\n                                2r1000100010001000))) \n          translate-down (fn [shape]\n                           (bit-or\n                             (bit-shift-right shape 4)\n                             (bit-and\n                               (bit-shift-left shape 12)\n                               2r1111000000000000)))\n          translate (fn [shape [i j]]\n                      (nth (iterate translate-right (nth (iterate translate-down shape) i)) j))\n          translate-positions (for [i (range 4)\n                                    j (range 4)]\n                                [i j])\n          all-translations (fn [shape] (map #(translate shape %) translate-positions))\n          patterns (distinct (mapcat all-translations shapes))\n          applicable-patterns (filter #(= % (bit-and % bits)) patterns)\n          consumed-patterns (into #{} (for [a applicable-patterns\n                                            b applicable-patterns\n                                            :when (and (not= a b) (= (bit-and a b) b))]\n                                        b))\n\n          largest-applicable-patterns (->> applicable-patterns\n                                           (filter (complement consumed-patterns))\n                                           (map-indexed #(vector (bit-set 0 %1) %2))\n                                           (into {}))\n          patterns-for (fn [n]\n                         (->> n\n                              (iterate #(bit-xor % (bit-and % (- %))))\n                              (take-while (complement zero?))\n                              (map #(bit-and % (- %)))\n                              (map largest-applicable-patterns)))\n\n          check-term (fn [pattern bits sym complement-sym]\n                       (let [a (bit-and pattern bits)\n                             b (bit-and-not pattern bits)]\n                         (cond\n                           (zero? a) [complement-sym]\n                           (zero? b) [sym]\n                           :else [])))\n\n          symbols-used (reduce clojure.set/union input-fn)\n          vars-used (set (concat\n                           (if (or (symbols-used 'A) (symbols-used 'a)) '[A a])\n                           (if (or (symbols-used 'B) (symbols-used 'b)) '[B b])\n                           (if (or (symbols-used 'C) (symbols-used 'c)) '[C c])\n                           (if (or (symbols-used 'D) (symbols-used 'd)) '[D d])))\n\n          pattern->minterm (fn [pattern]\n                             (clojure.set/intersection\n                               vars-used\n                               (set (concat\n                                      (check-term pattern 2r0110011001100110 'A 'a)\n                                      (check-term pattern 2r1100110011001100 'B 'b)\n                                      (check-term pattern 2r0000111111110000 'C 'c)\n                                      (check-term pattern 2r1111111100000000 'D 'd)))))\n\n          answer (->> (range 1 (bit-set 0 (count largest-applicable-patterns)))\n                      (map #(vector % (reduce bit-or (patterns-for %))))\n                      (filter #(= bits (bit-and (second %) bits)))\n                      #_(sort-by second #(< (Long/bitCount %1) (Long/bitCount %2)))\n                      first\n                      first\n                      patterns-for\n                      (map pattern->minterm)\n                      (into #{}))]\n      answer))", "problem": 140, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [s]\n  (let [code {\"00\" 0 \"01\" 1 \"10\" 3 \"11\" 2 \"0\" 0 \"1\" 1}\n        rcode0 (into {} (map #(identity [(val %) (key %)]) code))\n        rcode {2 rcode0 4 (-> rcode0 (assoc 0 \"00\") (assoc 1 \"01\"))}\n        min4br {2 [#{'c} #{'C}] 4 [#{'c 'd} #{'c 'D} #{'C 'D} #{'C 'd}]}\n        min4bc {2 [#{'a 'b} #{'a 'B} #{'A 'B} #{'A 'b}] 4 [#{'a 'b} #{'a 'B} #{'A 'B} #{'A 'b}]}\n        acode ['a 'A]\n        bcode ['b 'B]\n        ccode ['c 'C]\n        dcode ['d 'D]\n        abcode [acode bcode]\n        cdcode {4 [ccode dcode] 2 [ccode]}\n        ]\n    \n    (letfn [(makeMap [s] \n              (let [c (count (first s))]\n                (vec (repeat (* 2 (- c 2)) (vec (repeat (* 2 2) 0)))))\n              )\n            (toB [x] (if (= -1 (.indexOf ['A 'B 'C 'D] x)) \"0\" \"1\"))\n            (fillMap [m s] \n              (let [s (vec (map #(vec (sort-by (fn [a] (clojure.string/lower-case (str a))) %)) (vec s)))]\n                (loop [m m i 0]\n                  (if (>= i (count s))\n                    m\n                      (let [\n                            b (vec (map #(toB %) (s i)))\n                            y (code (clojure.string/join #\"\" (subvec b 0 2)))\n                            x (code (clojure.string/join #\"\" (subvec b 2)))\n                            ]\n                      (recur (assoc-in m [x y] 1)(inc i)))\n                    )\n                  )))\n            (scan4br [k m] \n              (let [] \n                (loop [i 0 m m c []]\n                  (if (>= i (count m))\n                    {:m m :c c}\n                    (if (every? #(= 1 %) (k i))\n                      (let [cc ((min4br (count m)) i)]\n                      (recur (inc i) (assoc-in m [i] (vec (repeat 4 1))) (conj c cc)))\n                      (recur (inc i) m c))))))\n            (scan4bc [k m] \n              (let [] \n                (loop [i 0 m m c []]\n                  (if (>= i (count (first m)))\n                    {:m m :c c}\n                    (if (every? #(= 1 %) (map #(nth % i) k))\n                      (let [cc ((min4bc (count m)) i)]\n                        (println cc i)\n                      (recur (inc i) \n                             (-> m \n                                 (assoc-in [0 i] 1)\n                                 (assoc-in [1 i] 1)\n                                 (assoc-in [2 i] 1)\n                                 (assoc-in [3 i] 1))\n                                 (conj c cc)))\n                      (recur (inc i) m c))))))\n            (getsqset [y1 y2 x1 x2 k]\n              (let [sy1 (vec ((rcode 4) y1))\n                    sy2 (vec ((rcode 4) y2))\n                    sx1 (vec ((rcode (count k)) x1))\n                    sx2 (vec ((rcode (count k)) x2))\n                    ab (if (= (sy1 0) (sy2 0)) [0 (Integer. (str (sy1 0)))] [1 (Integer. (str (sy1 1)))])\n                    abs ((abcode (ab 0)) (ab 1))\n                    cd (if (= (sx1 0) (sx2 0)) [0 (Integer. (str (sx1 0)))] (if (= 2 (count k)) [0 0] [1 (Integer. (str (sx1 1)))]))\n                    cds (((cdcode (count k)) (cd 0)) (cd 1))\n                    ]\n                (if (= 2 (count k)) #{abs} #{abs cds})\n              ))\n            (get2rset [y1 y2 x1 k]\n              (let [sy1 (vec ((rcode 4) y1))\n                    sy2 (vec ((rcode 4) y2))\n                    sx1 (vec ((rcode (count k)) x1))\n                    ab (if (= (sy1 0) (sy2 0)) [0 (Integer. (str (sy1 0)))] [1 (Integer. (str (sy1 1)))])\n                    abs ((abcode (ab 0)) (ab 1))\n                    cs (ccode (Integer. (str (sx1 0))))\n                    ds (if (= 2 (count k)) nil (dcode (Integer. (str (sx1 1)))))\n                    ]\n                (if (= 2 (count k)) #{abs cs} #{abs cs ds})\n              ))\n            (get2cset [y1 x1 x2 k]\n              (let [sy1 (vec ((rcode 4) y1))\n                    sx1 (vec ((rcode (count k)) x1))\n                    sx2 (vec ((rcode (count k)) x2))\n                    as (acode (Integer. (str (sy1 0))))\n                    bs (bcode (Integer. (str (sy1 1))))\n                    cd (if (= (sx1 0) (sx2 0)) [0 (Integer. (str (sx1 0)))] (if (= 2 (count k)) [0 0] [1 (Integer. (str (sx1 1)))]))\n                    cds (((cdcode (count k)) (cd 0)) (cd 1))\n                    ]\n                (if (= 2 (count k)) #{as bs} #{as bs cds})\n              ))\n            (get1set [y1 x1 k]\n              (let [sy1 (vec ((rcode 4) y1))\n                    sx1 (vec ((rcode (count k)) x1))\n                    as (acode (Integer. (str (sy1 0))))\n                    bs (bcode (Integer. (str (sy1 1))))\n                    cs (ccode (Integer. (str (sx1 0))))\n                    ds (if (= 2 (count k)) 0 (dcode (Integer. (str (sx1 1)))))\n                    ]\n                (if (= 2 (count k)) #{as bs cs} #{as bs cs ds})\n              ))\n\n            (scan4sq [k m]\n              (loop [i 0 m m c []]\n                (if (>= i (count m))\n                  {:m m :c c}\n                  (let \n                      [c2 (loop [i2 0 m m c []]\n                            (if (>= i2 (count (m i)))\n                              {:m m :c c}\n                              (let [x1 i\n                                    x2 (if (= i (dec (count m))) 0 (inc i))\n                                    y1 i2\n                                    y2 (if (= i2 (dec (count (m i)))) 0 (inc i2))\n                                    sq [[x1 y1] [x1 y2] [x2 y1] [x2 y2]]\n                                    ]\n                                (if (not (and (every? #(= 1 %) (map #((k (first %)) (second %)) sq)) (< 1 (count (filter #(= 0 %) (map #((m (first %)) (second %)) sq))))))\n                                  (recur (inc i2) m c)\n                                  (let []\n                                    (recur (inc i2) \n                                           (-> m\n                                               (assoc-in (sq 0) 2)\n                                               (assoc-in (sq 1) 2)\n                                               (assoc-in (sq 2) 2)\n                                               (assoc-in (sq 3) 2)\n                                               ) \n                                           (conj c (getsqset y1 y2 x1 x2 k)))\n                                    )\n                                )\n                              )\n                              )\n                            )]\n                    (recur (inc i) (c2 :m) (concat c (c2 :c))))\n                  )\n                )\n              )\n            (scan2r [k m] {:m m :c []}\n              (loop [i 0 m m c []]\n                (if (>= i (count m))\n                  {:m m :c c}\n                  (let \n                      [c2 (loop [i2 0 m m c []]\n                            (if (>= i2 (count (m i)))\n                              {:m m :c c}\n                              (let [\n                                    x1 i\n                                    y1 i2\n                                    y2 (if (= i2 (dec (count (m i)))) 0 (inc i2))\n                                    sq [[x1 y1] [x1 y2]]\n                                    ]\n                                (if (not (and \n                                          (every? \n                                           #(= 1 %) \n                                           (map \n                                            (fn [a] (let []\n                                                     ((k (first a)) (second a))))\n                                            sq)) \n                                          (= 0 ((m x1) y1))))\n                                  (do\n                                    (recur (inc i2) m c)\n                                    )\n                                  (let []\n                                    (recur (inc i2) \n                                           (-> m\n                                               (assoc-in (sq 0) 3)\n                                               (assoc-in (sq 1) 3)\n                                               ) \n                                           (conj c (get2rset y1 y2 x1 k)))\n                                    )\n                                )\n                              )\n                              )\n                            )]\n                    (recur (inc i) (c2 :m) (concat c (c2 :c))))\n                  )\n                )\n\n              )\n            (scan2c [k m] {:m m :c []}\n              (loop [i 0 m m c []]\n                (if (>= i (count m))\n                  {:m m :c c}\n                  (let \n                      [c2 (loop [i2 0 m m c []]\n                            (if (>= i2 (count (m i)))\n                              {:m m :c c}\n                              (let [x1 i\n                                    x2 (if (= i (dec (count m))) 0 (inc i))\n                                    y1 i2\n                                    sq [[x1 y1] [x2 y1]]\n                                    ]\n                                (if (not (and (every? #(= 1 %) (map #((k (first %)) (second %)) sq)) (= 0 ((m x1) y1))))\n                                  (recur (inc i2) m c)\n                                  (let []\n                                    (recur (inc i2) \n                                           (-> m\n                                               (assoc-in (sq 0) 3)\n                                               (assoc-in (sq 1) 3)\n                                               ) \n                                           (conj c (get2cset y1 x1 x2 k)))\n                                    )\n                                )\n                              )\n                              )\n                            )]\n                    (recur (inc i) (c2 :m) (concat c (c2 :c))))\n                  )\n                )\n\n              )\n            (scan1 [k m] {:m m :c []}\n              (loop [i 0 m m c []]\n                (if (>= i (count m))\n                  {:m m :c c}\n                  (let \n                      [c2 (loop [i2 0 m m c []]\n                            (if (>= i2 (count (m i)))\n                              {:m m :c c}\n                              (let [x1 i\n                                    y1 i2\n                                    sq [[x1 y1]]\n                                    ]\n                                (if (not (and (every? #(= 1 %) (map #((k (first %)) (second %)) sq)) (= 0 ((m x1) y1))))\n                                  (recur (inc i2) m c)\n                                  (let []\n                                    (recur (inc i2) \n                                           (-> m\n                                               (assoc-in (sq 0) 4)\n                                               ) \n                                           (conj c (get1set y1 x1 k)))\n                                    )\n                                )\n                              )\n                              )\n                            )]\n                    (recur (inc i) (c2 :m) (concat c (c2 :c))))\n                  )\n                )\n\n              )\n\n            ]\n      (let [k (fillMap (makeMap s) s)\n            m1 (scan4br k (makeMap s))\n            m2 (if (= (count k) 2) m1 (scan4bc k (m1 :m)))\n            m3 (scan4sq k (m2 :m))\n            m4 (scan2r k (m3 :m))\n            m5 (scan2c k (m4 :m))\n            m6 (scan1 k (m5 :m))\n            ]\n        (set (concat (m1 :c) (m2 :c) (m3 :c) (m4 :c) (m5 :c) (m6 :c)))))))", "problem": 140, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn veitch [s]\n  (let [m {'a 'a 'A 'a 'b 'b 'B 'b 'c 'c 'C 'c 'd 'd 'D 'd}\n        ps (fn ps [s]\n             (if (empty? s) #{#{}}\n                 (clojure.set/union (ps (next s))\n                                    (map #(conj % (first s)) (ps (next s))))))\n        f (fn [s t]\n            (let [d1 (clojure.set/difference s t)\n                  d2 (clojure.set/difference t s)]\n              (when (and (== 1 (count d1) (count d2))\n                         (= (m (first d1)) (m (first d2))))\n                (clojure.set/intersection s t))))\n        r (fn r [s]\n            (filter (fn [t] (= 1 \n                               (count (filter (fn [u] (clojure.set/subset? u t)) s)))) s))\n        c (fn c [s2]\n            (every? (fn [t] (< 0 \n                               (count (filter (fn [u] (clojure.set/subset? u t)) s2)))) s))\n        g (fn g [s]\n            (cond\n                (empty? s) #{}\n                (empty? (rest s)) s\n                true (set (concat (g (rest s))\n                                  (hash-set (first s))\n                                  (apply hash-set \n                                         (distinct (filter (complement nil?) \n                                                           (map #(f (first s) %) (rest s)))))))))\n        h (fn h [s]\n            (let [t (set (r (g s)))]\n              (if (= s t) s (recur t))))]\n    (first (sort-by count (filter c (ps (h s)))))))", "problem": 140, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn [algebra]\n  (let [pairs (set (map hash-set (map #(symbol (str (char %))) (range 65 91)) (map #(symbol (str (char %))) (range 97 123))))\n        condense-terms (fn [a b]\n                         (let [u           (clojure.set/union a b)\n                               condensed   (apply (partial disj u) (first (filter #(clojure.set/subset? % u) pairs)))]\n                           (if (= (count a) (count b) (inc (count condensed)))\n                             condensed)))\n        condense (fn condense [algebra]\n                   (let [condensables    (for [term-a algebra\n                                               term-b algebra]\n                                           (if (condense-terms term-a term-b)\n                                             [term-a term-b]))\n                         kept            (apply (partial disj algebra) (apply concat condensables))\n                         new             (set (map (fn [[term-a term-b]]\n                                                     (condense-terms term-a term-b)) condensables))\n                         result          (set (remove nil? (clojure.set/union kept new)))]\n                     (if (= result algebra)\n                       algebra\n                       (condense result))))\n        power-set       (fn power-set [full-set]\n                          (apply clojure.set/union\n                                 #{full-set}\n                                 (map #(power-set (disj full-set %)) full-set)))\n        satisfies (fn [algebra implicants]\n                    (every? (fn [term]\n                              (some #(clojure.set/subset? % term) implicants))\n                            algebra))\n        implicants (condense algebra)]\n    (apply min-key count (filter #(satisfies algebra %) (power-set implicants)))))", "problem": 140, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [terms] (letfn [(to-binary [abcd-set] (map #(if % 1 0) (map #(Character/isUpperCase (first %)) (sort-by #(.toUpperCase %) (map name abcd-set)))))\n\n(sort-by-1s [abcd-set] (sort-by #(get (frequencies %) 1) (map to-binary abcd-set)))\n\n(pairs [xs] (if (empty? xs) () (cons (map #(vector (first xs) %) (rest xs)) (pairs (rest xs)))))\n\n(flat-pairs [xs] (mapcat identity (pairs xs)))\n\n(number-of-differing-bits [pair] (count (filter false? (map #(= (first %) (second %)) (apply map vector pair)))))\n\n(combine [pair] (map #(if (= (first %) (second %)) (first %) '-) (apply map vector pair)))\n\n(size-2-implicants [minterms] (distinct (map combine (filter #(= 1 (number-of-differing-bits %)) (flat-pairs minterms)))))\n\n(dash-compatible? [pair] (apply = (map (partial keep-indexed #(if (= '- %2) %1)) pair)))\n\n(not-combinable [minterm other-minterms] (let [combinables (distinct (filter #(= 1 (number-of-differing-bits (vector % minterm))) other-minterms))] (or (empty? combinables) (and (= 1 (count combinables)) (= minterm (first combinables))))))\n\n(combinable? [minterm-1 minterm-2] (= 1 (number-of-differing-bits (vector minterm-1 minterm-2))))\n\n(combine [minterm-1 minterm-2] (map #(if (= (first %) (second %)) (first %) '-) (map vector minterm-1 minterm-2)))\n\n(combine-with-all [minterm other-minterms] (map #(combine minterm %) (filter #(combinable? minterm %) other-minterms)))\n\n(combine-all [minterms] (if (empty? minterms) () (concat (combine-with-all (first minterms) (rest minterms)) (combine-all (rest minterms)))))\n\n(not-combinable? [minterm other-minterms] (let [combinables (distinct (filter #(= 1 (number-of-differing-bits (vector % minterm))) other-minterms))] (or (empty? combinables) (and (= 1 (count combinables)) (= minterm (first combinables))))))\n\n(terms-in-final-state [terms] (filter #(not-combinable? % terms) terms))\n\n(terms-not-in-final-state [terms] (filter #(not (not-combinable? % terms)) terms))\n\n(combination-round [terms-to-combine terms-already-in-final-state] (let [combination-result (distinct (combine-all terms-to-combine))] (vector (distinct (terms-not-in-final-state combination-result)) (concat terms-already-in-final-state (terms-in-final-state terms-to-combine) (distinct (terms-in-final-state combination-result))))))\n\n(prime-implicants [minterms] (second (apply combination-round (apply combination-round (combination-round minterms [])))))\n\n(covers? [implicant term] (every? true? (map #(if (or (= '- (first %)) (= (first %) (second %))) true false) (map vector implicant term))))\n\n(coverages [terms] (map (fn [term] (filter #(covers? % term) (prime-implicants terms))) terms))\n\n(essential-prime-implicants [terms] (mapcat identity (filter #(= 1 (count %)) (coverages terms))))\n\n(from-binary [bin-term] (set (map #(nth % (inc (first %))) (filter #(not= '- (first %)) (map vector bin-term ['a 'b 'c 'd] ['A 'B 'C 'D])))))\n\n(quine-mccluskey [terms] (set (map from-binary (essential-prime-implicants (map to-binary terms)))))]\n(quine-mccluskey terms)))", "problem": 140, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn [input]\n  (let [truestates ['A 'B 'C 'D]\n        falsestates ['a 'b 'c 'd]\n        to-tri-state (fn [xs] (map (partial contains? xs) (take (count xs) truestates)))\n        to-bi-state (fn [xs]\n                      (into #{} (filter (comp not nil?)\n                                        (map #(cond\n                                               (true? %1) %2\n                                               (false? %1) %3\n                                               :else nil)\n                                             xs truestates falsestates))))\n        gen-new-tri-state (fn [a b]\n                            (if (not= a b)\n                              nil\n                              a))\n        mergeable? (fn [a b]\n          (and (= (count a) (count b))\n               (= 1 (count (filter false? (map = a b))))))       \n        generalize (fn [a b]\n          (if (mergeable? a b)\n            (map gen-new-tri-state a b)\n            nil))\n        generalize-set (fn [xs]\n          (distinct (filter (comp not nil?) (for [a xs b xs]\n                                              (generalize a b)))))\n        is-generic? (fn [a b] (or (nil? a) (= a b)))\n        is-generic-state? (fn is-generic-state? [a b]\n                            (and (not= a b)\n                                 (every? true? (map is-generic? a b))))\n        contains-generic-state? (fn [xs x]\n          ((comp not nil?) (some true? (map #(is-generic-state? % x) xs))))\n        to-num (fn [x]\n          (let [m {'A 2r1100110011001100\n                'B 2r1111111100000000\n                'C 2r0110011001100110\n                'D 2r0000111111110000\n                'a 2r0011001100110011\n                'b 2r0000000011111111\n                'c 2r1001100110011001\n                'd 2r1111000000001111}]\n            (reduce bit-and (map m x))))\n        is-not-covered-by-other-states (fn [xs x]\n                                         (let [ys (map to-num xs)\n                                               y (to-num x)\n                                               sum (reduce #(if (not= %2 y)\n                                                              (bit-or % %2)\n                                                              %) 0 ys)]\n                                           (not= y (bit-and y sum))))\n        four (map to-tri-state input)\n        three (generalize-set four)\n        two (generalize-set three)\n        one (generalize-set two)\n        all (concat one two three four)\n        almost-result (map to-bi-state (filter (partial (comp not contains-generic-state?) all) all))\n        ]\n    (into #{} (filter (partial is-not-covered-by-other-states almost-result) almost-result))))", "problem": 140, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn __ [funcs]\n  (let [conversion {'A [0 \\1] 'a [0 \\0] 'B [1 \\1] 'b [1 \\0] 'C [2 \\1] \n                    'c [2 \\0] 'D [3 \\1] 'd [3 \\0]}\n        func-to-string\n          (fn func-to-string [coll]\n            (apply str (map second (sort-by first (map conversion coll)))))\n        to-funcmap\n          (fn to-funcmap [coll]\n            (apply merge (map-indexed #(hash-map [%1] %2) \n                         (sort (map func-to-string coll)))))\n        num-ones\n          (fn num-ones [coll]\n            (count (filter #{\\1} coll)))\n        diff-by-one\n          (fn diff-by-one [left right]\n            (= 1 (count (filter false? (map = left right)))))\n        produce-diff\n          (fn produce-diff [left right]\n            (map #(if (not= %1 %2) \\- %1) left right))\n        merge-terms\n          (fn merge-terms [n state]\n            (let [less (state n)\n                  more (state (inc n))]\n              (for [[l-terms l-func] less\n                    [m-terms m-func] more\n                    :when (diff-by-one l-func m-func)]\n                 [(concat l-terms m-terms) (produce-diff l-func m-func)])))\n        find-unmerged\n          (fn find-unmerged [old-state new-state]\n            (let [old-minis (map (comp set first) (mapcat second old-state))\n                  new-minis (map (comp set first) (mapcat second new-state))\n                  new-map (apply merge (map #(apply hash-map %) (map #(vector (into #{} (first %)) (second %)) (mapcat second old-state)))) ; yeah this is pretttty dumb\n                  unmerged (for [l-term old-minis\n                                 :when (every? false? (map #(clojure.set/subset? l-term %) new-minis))]\n                              [l-term (new-map l-term)])]\n              (into #{} unmerged)))\n        step\n          (fn step [state final]\n            (let [r (butlast (sort (keys state)))\n                  next-state (group-by #(num-ones (second %)) \n                                       (mapcat #(merge-terms % state) r))\n                  unmerged (find-unmerged state next-state)]\n              (if (seq next-state)\n                  (recur next-state (concat final unmerged))\n                  (concat final unmerged))))\n        get-essential\n          (fn get-essential [mini unmerged]\n            (let [covers (filter #(contains? (first %1) mini) unmerged)]\n              (if (= 1 (count covers))\n                  [(second (first covers))]\n                  nil)))\n        find-essentials\n          (fn find-essentials [miniterms unmerged]\n            (mapcat #(get-essential % unmerged) miniterms))\n        to-set\n          (fn to-set [coll]\n            (into #{} (map (clojure.set/map-invert conversion)\n                           (filter #(not= (second %) \\-) (map-indexed vector coll)))))\n        to-sets\n          (fn to-sets [coll]\n            (into #{} (map to-set coll)))]\n    (let [func-map (to-funcmap funcs)\n          miniterms (apply concat (keys func-map))\n          implicants (step (group-by #(num-ones (second %)) func-map) #{})]\n    (to-sets (find-essentials miniterms implicants)))))", "problem": 140, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn karn [sets]\n  (let [; If s1 and s2 are boolean complements (they differ by only 1 flipped var)\n        ; return the common values and the original sets.\n        bool-complement (fn [[s1 s2]]\n                          (let [x12 (clojure.set/difference s1 s2)\n                                x21 (clojure.set/difference s2 s1)]\n                            (if (and (= (count (clojure.set/difference s1 s2)) 1)\n                                     (= (clojure.string/upper-case x12)\n                                        (clojure.string/upper-case x21)))\n                              [(clojure.set/intersection s1 s2) s1 s2]\n                              )\n                            )\n                          )\n        ; Return the common values of every boolean complement of pairing in sets,\n        ; and sets with those removed.\n        bool-reduce (fn [[sets acc]]\n                      (let [; Filter the boolean complements for every pairing in sets.\n                            comps (keep bool-complement (for [a sets, b (disj sets a)] [a b]))\n                            ; Get the reduced boolean algebra.\n                            x (set (map first comps))\n                            ; Remove the complements from sets.\n                            y (reduce #(disj % (second %2) (last %2)) sets comps)]\n                        [x (clojure.set/union acc y)]\n                        )\n                      )\n        ; Iteratively apply bool-reduce until no more reductions can be made.\n        ; Return the last set generated.\n        reduced-set (apply clojure.set/union\n                           (last (take-while #(not (empty? (first %)))\n                                             (iterate bool-reduce [sets #{}]))))\n        ; Apply the reduced-set to the original sets.\n        sets* (map (fn [x] (filter #(clojure.set/subset? % x) reduced-set)) sets)\n        ]\n    ; Return the set of boolean algebra that are uniquely required to satisfy sets.\n    (set (map first (filter #(= (count %) 1) sets*)))\n    )\n  )", "problem": 140, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [bs]\n (let [km (set (map #(split-at (quot (count (first bs)) 2) %)\n      (map (fn[w] (sort-by #(.toUpperCase (str %)) w)) bs)\n       ))\n      fc (fn find-c[p kkm rkm cr]\n  (let [km (disj kkm p)\n       f first s second\n       rev {'A 'a 'a 'A 'B 'b 'b 'B 'C 'c 'c 'C 'D 'd 'd 'D}\n       diff (fn [p np] (+ (if (= (f p)(f np)) 0 1)(if (= (s p)(s np)) 0 1) )) \n       cut-n (fn [n](cond (>= n 8) (- n 8)(>= n 4) (- n 4) (>= n 2) (- n 2) :else 0))\n       linkline (fn _ [p r km f s](let [nps (for [np km :when (and (= (f np) (f p))(= 1 (diff (s p)(s np))))]np)](if (empty? nps) (drop-last (cut-n(count r)) r)(for [np nps](_ np (conj r np) (disj km np) f s)))))\n       escape (fn _e [line](if (symbol? (first(first line))) (list line) (if (symbol? (first(first(first line)))) line (_e (apply concat line)) )))\n       g1 #(first (first %)) g2 #(second (first %))\n       g3 #(first (second %)) g4 #(second (second %))\n       h-lines (map escape (linkline p [p] km second first) )\n       v-lines (map escape (linkline p [p] km first second) )\n       valid (fn [cc](for [c cc :when (= (count c) (count ((fn [l] (filter #(contains? kkm %) l)) c))  )] c ))\n       h-up   (valid (for [line h-lines] (concat line (for [p line][(first p) (list (g3 p) (rev (g4 p)))] ))))\n       h-down (valid (for [line h-lines] (concat line (for [p line][(first p) (list (rev (g3 p)) (g4 p))] ))))\n       v-left (valid (for [line v-lines] (concat line (for [p line][(list (rev (g1 p)) (g2 p)) (second p)]))))\n       v-down (valid (for [line v-lines] (concat line (for [p line][(list (g1 p) (rev (g2 p))) (second p)]))))\n       result (sort-by count (apply concat (list(list p)) h-lines v-lines h-up h-down v-left v-down []))\n       subset? (fn [set1 set2] (and (<= (count set1) (count set2)) (every? set2 set1)))\n       find-close (fn find-close[ds] (loop [ r [] ds (for [d ds] (set d))] (if (empty? ds) r(let [d (first ds) ds (rest ds) r (if (> (count (filter #(subset? d %) ds)) 0) r (conj r d))](recur r ds)))))\n       result (find-close result)\n       ]\n      (apply concat (for [_r result]\n        (let [n-km (loop [ k rkm r _r] (if (empty? r) k (recur (disj k (first r)) (rest r)))) ]\n         (if (= (count n-km) 0) [(conj cr _r)]\n           (find-c (first n-km) kkm n-km (conj cr _r))\n         )\n        )\n      ))\n  )\n)]\n    (let [simple (first (sort-by count (fc (first km) km km [])))\n          cut (fn [s1 s2](loop [s1 s1 s2 s2 n 0](if (not= (nth s1 n)(nth s2 n)) (concat (take n s1) (take-last (dec (- (count s1) n)) s1))(recur s1 s2 (inc n)))))\n          diff-n (fn [s1 s2](loop [n 0 ind 0](if (>= ind (count s1)) n(recur (if (not= (nth s1 ind)(nth s2 ind)) (inc n) n) (inc ind)))))\n          _cut-all (fn [seqs](let [s (map #(apply concat %) seqs)]((fn _ [s](if (empty? s) [](let [p (first s) rs (rest s) sp (first (for [i (range (count rs)) :when (= 1 (diff-n p (nth rs i)))] i))] (if (nil? sp) p(let [m (concat (list (cut p (nth rs sp))) (_ (concat (take sp rs) (take-last (dec (- (count rs) sp)) rs))) )](if (= 2 (count m)) (cut (first m) (second m)) m)))))) s)))\n         ]\n       (set (map set (map #(if (sequential? (first %)) (first %) %) (map _cut-all simple))))\n    )\n )\n)", "problem": 140, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [input]\n   (letfn[(combinacao [pivot n]\n                      (set \n                       (cond \n                        (= n 1) (for [x pivot] ; 1 elemento\n                                  #{x})\n                        (= n 2) (for [x pivot ; 2 elementos\n                                      y (disj pivot x)]\n                                  (hash-set x y))\n                        (= n 3) (for [x pivot] ; 3 elementos\n                                  (disj pivot x))\n                        (= n 4) #{pivot})))\n          (simplifica-n [pivot n]\n                        (filter (fn [expressao-simplificada]\n                                  (->> (map (fn [expressao-original]\n                                              (clojure.set/subset? expressao-simplificada expressao-original))\n                                            input)\n                                       (filter identity)\n                                       count\n                                       (= (/ (-> input first count dec (#(apply * (repeat % 2)))) \n                                             (apply * (repeat (dec n) 2))))))\n                                (combinacao pivot n)))\n          (simplifica [pivot]\n                      (some identity (map #(let [exp (simplifica-n pivot %)]\n                                             (when (seq exp)\n                                               exp))\n                                          (range 1 5 1))))\n          (gera-mapa-possibilidades []\n                                    (reduce (fn [resposta pivot]\n                                              (assoc resposta pivot (simplifica pivot)))\n                                            {}\n                                            input))\n          (simplifica-mapa-possibilidades []\n                                          (let [mapa-possibilidades (gera-mapa-possibilidades)]\n                                            (map (fn [map-entry-pivot]\n                                                   (let [outras-possibilidades-pivot (filter (fn [expressao-simplificada-corrente]\n                                                                                               (when (and (> (count expressao-simplificada-corrente) \n                                                                                                             (count (first (val map-entry-pivot))))\n                                                                                                          (clojure.set/subset? expressao-simplificada-corrente (key map-entry-pivot)))\n                                                                                                 expressao-simplificada-corrente))                                           \n                                                                                             (mapcat val (dissoc mapa-possibilidades (key map-entry-pivot))))]\n                                                     (if (seq outras-possibilidades-pivot)\n                                                       outras-possibilidades-pivot\n                                                       (-> map-entry-pivot val))))\n                                                 mapa-possibilidades)))\n          (gera-possibilidades []\n                               (letfn [(gera-possibilidades-it [[primeiras-possibilidades & outras-possibilidades]]\n                                                               (if (seq outras-possibilidades)\n                                                                 (for [possibilidade-corrente primeiras-possibilidades\n                                                                       outras-possibilidades-correntes (gera-possibilidades-it outras-possibilidades)]\n                                                                   (conj outras-possibilidades-correntes possibilidade-corrente))\n                                                                 (map hash-set primeiras-possibilidades)))]\n                                 (set (gera-possibilidades-it (simplifica-mapa-possibilidades)))))]\n     (reduce (fn [expressao-mais-simples expressao-corrente]\n               (if (< (count expressao-mais-simples) (count expressao-corrente))\n                 expressao-mais-simples\n                 expressao-corrente))\n             (gera-possibilidades))))", "problem": 140, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn quine-mcclusky-brute-min [q]\n  (let [truths ['A 'B 'C 'D]\n        falsehoods ['a 'b 'c 'd]\n        Q->rep (fn [q] (vec (for [term q] (mapv #(contains? term %) (map (fn [_ t] t) (first q)  truths)))))\n        rep->A (fn [terms] \n                 (letfn [(tv->sym [tv t f] (when-not (nil? tv) (if tv t f))) \n                         (set* [coll] (disj (set coll) nil))] \n                   (set* (for [term terms] (set* (map tv->sym term truths falsehoods)))))) \n        diff (fn [t1 t2] \n               (let [d (map = t1 t2)]\n                 (when (=  1 (count (remove identity d)))\n                   (map #(when % %2) d t1)))) \n\n        factor* (fn [terms] \n                  (let [terms (vec terms) \n                        n (count terms)] \n                    (loop [i 0, j 0, s (set terms), a #{}] \n                      (cond (< i j) (if-let [d (diff (terms i) (terms j))] \n                                      (recur (inc i) j (disj s (terms i) (terms j)) (conj a d)) \n                                      (recur (inc i) j s a)) \n                            (< (inc j) n) (recur 0, (inc j), s, a) \n                            :else [s a]))))\n        factor (fn [terms] \n                 (loop [irr #{} red (set terms)] \n                   (if (empty? red)\n                     irr \n                     (let [[irr* red*] (factor* red)] \n                       (recur (into irr irr*) red*)))))\n        truth-values (fn [n] \n                       (nth (iterate #(for [ttv %, tv [true false]] (conj ttv tv)) [[]]) n)) \n        truth-table (fn [tvals terms] \n                      (let [term? (fn [term tvs] \n                                    (reduce #(and % %2) \n                                            true \n                                            (map (fn [p v] (if (nil? p) true (= p v))) term tvs))) \n                            row? (fn [tvs] \n                                   (reduce #(or % %2) false (map #(term? % tvs) terms)))] \n                        (map row? tvals)))\n        brute-reduce (fn [terms] \n                       (let [tvals (truth-values (count (first terms)))\n                             tt (truth-table tvals terms)] \n                         (loop [red (set terms) terms terms] \n                           (if (seq terms) \n                             (let [red* (disj red (first terms))]\n                               (if (= tt (truth-table tvals red*))\n                                 (recur red* (rest terms))\n                                 (recur red (rest terms))))\n                             red))))]\n    (-> q Q->rep factor brute-reduce rep->A)))", "problem": 140, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [one-minterms]\n  (letfn [(parts-match? [[part1 part2]]\n            (or (= part1 part2)\n                (= part1 2)\n                (= part2 2)))\n          (minterms-match1? [term1 term2]\n            (every? identity (map #(parts-match? %)\n                                  (map vector term1 term2))))\n          (difference-of-1? [term1 term2]\n            (= 1 (count (filter #(not (= (first %) (second %)))\n                                (map vector term1 term2)))))\n          (combine-minterm1 [term terms]\n            (let [combinable-terms (filter #(difference-of-1? term %) terms)]\n              (when (not (empty? combinable-terms))\n                (map #(if (= (first %) (second %))\n                        (first %)\n                        2)\n                     (map vector term (first combinable-terms))))))\n          (any-difference-of-1? [term terms]\n            (some #(difference-of-1? term %) terms))\n          (combine-minterms1 [minterms]\n            (let [differences-of-one (filter #(any-difference-of-1? % minterms)\n                                             minterms)]\n              (if (empty? differences-of-one)\n                minterms\n                (let [combined-terms (map #(combine-minterm1 % minterms)\n                                          differences-of-one)\n                      differences-of-nonzero (remove (fn [minterm]\n                                                       (some #(minterms-match1? minterm %)\n                                                             combined-terms))\n                              minterms)]\n                  (recur (concat combined-terms differences-of-nonzero))))))]\n    (let [array-one-minterms (map #(sort-by (fn [a] (clojure.string/capitalize a)) %) one-minterms)\n        minimal-table (combine-minterms1 array-one-minterms)]\n      (set (map #(set (filter symbol? %)) minimal-table)))))", "problem": 140, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [algebra]\n  (letfn [(union [s1 s2]\n            (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n          (step [algebra]\n            (let [r (set (flatten (map\n                                    (fn [line]\n                                      (let [m (map\n                                                #(set (conj\n                                                        (remove #{%} line)\n                                                        (case (str %)\n                                                          \"a\" 'A\n                                                          \"A\" 'a\n                                                          \"b\" 'B\n                                                          \"B\" 'b\n                                                          \"c\" 'C\n                                                          \"C\" 'c\n                                                          \"d\" 'D\n                                                          \"D\" 'd)))\n                                                line)\n                                            s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                        (if (seq s) s line)))\n                                    algebra)))]\n              (if (not= r algebra) (step r) algebra)))\n          (power-set [s]\n            (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))]\n    (let [ps (power-set (step algebra))]\n      (apply\n        (partial min-key count)\n        (filter\n          (complement nil?)\n          (map\n            (fn [s]\n              (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) algebra)) s))]\n                (if (= r algebra) s))\n              )\n            ps))))))", "problem": 140, "user": "50436470e4b034ff00315d23"}, {"code": "(fn min-bfnset [bfnset]\n  (letfn [(half-pairs [coll]\n                      (let [n (count coll)]\n                        (for [i (range n)\n                              j (range (inc i) n)]\n                          [(get coll i) (get coll j)])))\n          (sym->char [sym]\n                     (char (get (str sym) 0)))\n          (conjset->conjmap [s]\n                            (into {}\n                                  (map\n                                   (fn [sym]\n                                     (let [c (sym->char sym)]\n                                       [(Character/toUpperCase c) (if (Character/isUpperCase c) 1 0)]))\n                                   s)))\n          (conjmap->conjset [m]\n                            (into #{}\n                                  (map (fn [[k v]]\n                                         (->> (if (= 1 v) k (Character/toLowerCase k))\n                                              str\n                                              symbol)) m)))\n          (bfnset->bfnmap [bfnset]\n                          (into #{} (map conjset->conjmap bfnset)))\n          (bfnmap->bfnset [bfn]\n                          (into #{} (map conjmap->conjset bfn)))\n          (diffs [m1 m2]\n                 (filter #(not= (m1 %) (m2 %)) (keys m1)))\n          (can-combine? [m1 m2]\n                        (and (= (set (keys m1))\n                                (set (keys m2)))\n                             (= 1 (count (diffs m1 m2)))))\n          (combine [m1 m2]\n                   (reduce dissoc m1 (diffs m1 m2)))\n          (minterms [bfn]\n                    (when (not-empty bfn)\n                      (let [pairs (half-pairs (vec bfn))\n                            combinable (filter (partial apply can-combine?) pairs)\n                            combined (set (map (partial apply combine) combinable))\n                            others (reduce disj bfn (mapcat identity combinable))]\n                        (clojure.set/union others (minterms combined))\n                        )))\n          (subsets [st]\n                   (sort-by count (loop [curr st res [#{}]]\n                                    (if-let [f (first curr)]\n                                      (recur (next curr) (concat res (map #(conj % f) res)))\n                                      res))))\n          (covered? [term subterm]\n                    (and (clojure.set/subset? (set (keys subterm))\n                                              (set (keys term)))\n                         (every? #(= (subterm %) (term %)) (keys subterm))))\n          (all-covered? [terms subterms]\n                        (every? (fn [term]\n                                  (some (partial covered? term) subterms))\n                                terms))\n          (first-matching [pred coll]\n                          (first (drop-while (complement pred) coll)))\n          (minimize [minterms terms]\n                    (first-matching (partial all-covered? terms) (subsets minterms)))]\n    (->> bfnset\n         bfnset->bfnmap\n         ((juxt minterms identity))\n         (apply minimize)\n         bfnmap->bfnset)))", "problem": 140, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [f]\n  (->> (loop [l 1\n              [pis [is & ris :as iss]]\n              [{}\n               (->> f\n                    (map #(reduce (fn [m v] (conj m (if (% v) 1 0))) [] (take (count (first f)) '(A B C D))))\n                    (group-by #(count (filter #{1} %)))\n                    (sort-by first)\n                    (map (fn [[_ ms]] (reduce #(assoc % %2 #{%2}) {} ms))))]]\n         (if (empty? iss)\n           pis\n           (recur\n             (inc l)\n             (first\n               (reduce (fn [[[pis is] is1] is2]\n                         (let [[npi nis]\n                               (reduce (fn [[npi is] [i ms i1 i2]]\n                                         [(into npi [i1 i2])\n                                          (update-in is [i] #(into ms %))])\n                                       [[] {}]\n                                       (for [[i1 ms1] is1 [i2 ms2] is2\n                                             :let [i (loop [[v1 & r1] i1 [v2 & r2] i2 d 0 i []]\n                                                       (cond\n                                                         v1\n                                                         (cond\n                                                           (= v1 v2) (recur r1 r2 (if (= 2 v1) (inc d) d) (conj i v1))\n                                                           (and (not-any? #{2} [v1 v2]) (< d l)) (recur r1 r2 (inc d) (conj i 2)))\n                                                         (<= d l) i))]\n                                             :when i]\n                                         [i (into ms1 ms2) i1 i2]))]\n                           [[(apply dissoc pis npi) (conj is nis)] is2]))\n                       [[(into pis iss) []] is]\n                       ris)))))\n       (reduce (fn [c [pi ms]] (reduce (fn [c m] (update-in c [m] #(conj % pi))) c ms)) {})\n       (filter #(= 1 (count (second %))))\n       (map (comp first fnext))\n       (map #(reduce (fn [m [v s]] (if (= 2 v) m (conj m (s v)))) #{} (map list % '([a A] [b B] [c C] [d D]))))\n       set))", "problem": 140, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(let [inv-map '{a A, b B, c C, d D\n                A a, B b, C c, D d}]\n    \n  (letfn [(power-set\n           [xs]\n           (if-let [[x & xs] (seq xs)]\n             (let [ps (power-set xs)]\n               (clojure.set/union ps\n                 (map #(conj % x) ps)))\n             #{#{}}))\n            \n          (invert\n           [algebra f]\n           (->> (map #(set (conj (remove #{%} f)\n                                 (inv-map %))) f)\n                (map #(when (algebra %)\n                        (clojure.set/intersection f %)))\n                (remove nil?)\n                (#(if (seq %) % f))))\n            \n          (reduce-alg\n           [algebra]\n           (let [inverse\n                 (->> algebra\n                      (map (partial invert algebra))\n                      flatten set)]\n             (if (= inverse algebra)\n               algebra\n               (recur inverse))))\n            \n          (valid-alg?\n           [algebra candidate]\n           (->> candidate\n                (mapcat\n                 (fn [s]\n                   (filter\n                    (fn [f]\n                      (every? f s))\n                    algebra)))\n                set (= algebra)))]\n      \n    (fn minimize [algebra]\n      (->> (power-set (reduce-alg algebra))\n           (filter (partial valid-alg? algebra))\n           (apply (partial min-key count))))))", "problem": 140, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [s]\n  (println s)\n  (let [d clojure.set/difference\n        u clojure.set/union\n        g #(-> % first str .toUpperCase)\n        n (for [x s y s :while (not= x y)]\n            (let [i (clojure.set/intersection x y)\n                  a (d x i)\n                  b (d y i)]\n              (if (and (= 1 (count a) (count b))\n                       (= (g a) (g b)))\n                [i #{x y}])))\n        sn (->> n (map first) (filter #(not= nil %)) set)\n        sx (->> n (map last) (apply u))]\n    (if (empty? sn)\n      (disj s #{'A 'd})\n      (recur (u sn (d s sx))))))", "problem": 140, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [bfset]\n  (letfn [(ndiff [a b]\n            (apply + (map #(if (= %1 %2) 0 1) a b)))\n\n          (lset->lstr [lset]\n            (clojure.string/join\n             (sort\n              #(compare\n                (clojure.string/capitalize %1)\n                (clojure.string/capitalize %2))\n              (map str lset))))\n\n          (lstr-merge [a b]\n            (clojure.string/join\n             (map #(if (= %1 %2) %1 \"-\") a b)))\n\n          (covers? [merged term]\n            (every? true?\n                    (map\n                     #(or (= %1 %2) (= \\- %1))\n                     merged term)))\n\n          (fset->table [fset]\n            (apply hash-map\n                   (interleave\n                    fset\n                    (repeat (count fset) false))))\n\n          (table-merge [table]\n            (loop [table table\n                   merged (keys table)]\n              (if (empty? merged) table\n                  (let\n                      [diff-pairs (filter\n                                   #(= 1 (apply ndiff %))\n                                   (for [a merged, b merged] [a b]))\n                       new-merges (distinct (map #(apply lstr-merge %) diff-pairs))]\n                    (if (empty? diff-pairs) table\n                        (recur\n                         (merge\n                          (reduce\n                           (fn [tab [a b]] (assoc tab a true, b true))\n                           table\n                           diff-pairs)\n                          (apply hash-map\n                                 (interleave\n                                  new-merges\n                                  (repeat (count new-merges) false))))\n                         new-merges)))))) \n\n          (get-prims [merged]\n            (filter #(not (get merged % false)) (keys merged)))\n\n          (get-covers [prims term]\n            (filter #(covers? % term) prims))\n\n          (cover-table [prims terms]\n            (apply hash-map\n                   (interleave\n                    terms\n                    (map #(get-covers prims %) terms))))\n\n          (prim-covers [prims terms]\n            (apply\n             hash-map\n             (interleave\n              prims\n              (map\n               (fn [prim]\n                 (filter\n                  (fn [term] (covers? prim term))\n                  terms))\n               prims)))) \n\n          (lstr->fset [lstr]\n            (set (map #(-> % str symbol) (filter #(not= \\- %) lstr))))]\n    \n    (let [terms (set  (map lset->lstr bfset))\n          prims (->> terms fset->table table-merge get-prims set)\n          ctab  (cover-table prims terms)\n          head  (set (map first (filter #(= 1 (count %)) (vals ctab))))]\n      (loop [not-covered (filter\n                          #(not\n                            (some\n                             (fn [prim] (covers? prim %))\n                             prims))\n                          terms)\n             prims (clojure.set/difference prims head)\n             f head]\n        (if (empty? not-covered) (set (map lstr->fset f))\n            (let [p-covers (prim-covers prims not-covered)\n                  cover-counts (reduce\n                                #(assoc %1 %2 (count (get %1 %2 [])))\n                                p-covers\n                                (keys p-covers))\n                  max-count (apply max (vals cover-counts))\n                  to-add (first\n                          (first\n                           (filter\n                            #(= max-count (second %))\n                            cover-counts)))]\n              (recur\n               (filter #(not (covers? to-add %)) not-covered)\n               (clojure.set/difference prims #{to-add})\n               (conj f to-add))))))))", "problem": 140, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn f140 [mins] \n  (let\n    [vars (take (count (first mins)) (list 'A 'B 'C 'D))\n     bin (fn [min] (map #(if (contains? min %) 1 0) vars))\n     bins (map bin mins)\n\n     ones (fn [l] (group-by #(count (filter (partial = 1) (second %))) l))\n\n     s (fn [l l1] (map (fn [[l,x]] (let [group (inc (count (filter (partial = 1) x)))\n                           pairs (l1 group) ]\n                         (map #(list (list l (first %)) (set (concat l (first %))) (loop [x x y (second %) r (list)]\n                                (if x\n                                 (recur (next x) (next y) (cons (if (= (first x) (first y)) (first x) '- ) r) )\n                                 (reverse r) )))\n                               pairs )   )) l))\n\n     sf (fn [l n] (filter #(and (= (int (Math/pow 2 n)) (count (second %))) (= n (count (filter (partial = '-) (last %))))) (apply concat l)))\n;int wasn't needed on my version\n     s1f (map #(list (list %) %) bins)\n     s1ones (ones s1f)\n\n     s2 (s s1f s1ones)\n     s2f (set (map next (sf s2 1)))\n     s2ones (ones s2f)\n\n     s4 (s s2f s2ones)\n     s4f (let [r (sf s4 2)\n               not2 (apply concat (map first r))\n               r (zipmap (map second r) (map last r))\n               s2f (apply hash-map (apply concat s2f))]\n           (merge r (apply dissoc s2f not2)) )\n\n     pi (loop [pi '{} l s4f]\n          (if (empty? l)\n            pi\n            (recur\n              (loop [pi pi ll (key (first l))]\n                (if (empty? ll)\n                  pi\n                  (recur (update-in pi [(first ll)] (partial cons (first l)))  (next ll) )  ))\n              (next l))))\n     epi (filter #(= 1 (count (second %))) pi)\n\n     r (set (map #(loop [bin %\n       ones (list 'A 'B 'C 'D)\n       zero (list 'a 'b 'c 'd)\n       r #{}]\n       (if (empty? bin)\n         r\n         (recur (next bin) (next ones) (next zero) (if (= '- (first bin)) r (conj r (if (= 1 (first bin)) (first ones) (first zero) )) )) ))\n(set (map (comp second first second) epi))))\n\n]\n\n(if (empty? r) mins r) ))", "problem": 140, "user": "5349ac2be4b084c2834f4a67"}, {"problem": 140, "code": "(fn canonical-minterms [inputs]\n  (letfn [(generate-inputs [inputs]\n                           (->> inputs\n                                (mapcat (fn [in]\n                                          (let [as (cond (contains? in 'a) ['a] (contains? in 'A) ['A] :else ['a 'A])\n                                                bs (cond (contains? in 'b) ['b] (contains? in 'B) ['B] :else ['b 'B])\n                                                cs (cond (contains? in 'c) ['c] (contains? in 'C) ['C] :else ['c 'C])\n                                                ds (cond (contains? in 'd) ['d] (contains? in 'D) ['D] :else ['d 'D])]\n                                            (for [a as, b bs, c cs, d ds] #{a b c d}))))\n                                (set)))\n          (remove-overlaps [inputs]\n                           (let [expanded-inputs (generate-inputs inputs)]\n                             (set (filter #(not= (generate-inputs (disj inputs %)) expanded-inputs) inputs))))\n          (join [x1 x2]\n                (let [x1-2 (clojure.set/difference x1 x2)\n                      x2-1 (clojure.set/difference x2 x1)]\n\n                  (cond (not= 1 (count x1-2)) false\n                        (not= 1 (count x2-1)) false\n                        (not= (map (comp clojure.string/upper-case str) x1-2) (map (comp clojure.string/upper-case str) x2-1)) false\n                        :else (clojure.set/difference x1 x1-2)\n                  )))\n          (fold-into [inputs in]\n                     (let [match (->> inputs\n                                      (map (partial join in))\n                                      (filter identity))]\n                       (if (empty? match)\n                         [in]\n                         match)))\n          (fold-inputs [inputs]\n                       (let [next-step (set (mapcat (partial fold-into inputs) inputs))]\n                         (if (= inputs next-step)\n                           inputs\n                           (recur next-step))))]\n    (->> inputs\n         (fold-inputs)\n         (remove-overlaps))))", "user": "536ca4bde4b0fc7073fd6e49"}, {"problem": 140, "code": "(fn [kmap]\n(let [\n       getprimes\n        (fn [terms]\n         (set\n          (reduce\n            (fn[ss [k [m1 & m2]]]\n              (if (nil? m2) ss\n                 (conj\n                  (keep (fn [trm] (if (not-every? trm k) trm)) ss)\n                  k\n                 )\n            ))\n            terms\n            (mapcat (fn [t] (group-by #(apply disj % t)  terms))\n              [['A 'a]['B 'b]['C 'c]['D 'd]]\n            )\n        )))\n\n      primes\n        (loop [p0 kmap p1 #{}]\n          (if (= p0 p1) p0 (recur (getprimes p0) p0))\n        )\n\n       miniterms-to-primes\n        (map\n          (fn[mterm]\n            (vector mterm\n               (keep (fn[pterm] (if (every? mterm pterm) pterm)) primes)\n          ))\n          kmap\n        )\n\n      essentials\n        (set (keep (fn[[term [p0 & prst]]] (if (nil? prst) p0)) miniterms-to-primes))\n     ]\n\n    essentials\n  ))", "user": "5281a445e4b0757a1b17143a"}, {"problem": 140, "code": "(fn\n  [ss]\n  (letfn [(is-upper [s] (= s (clojure.string/upper-case s)))\n          (flip-case [s] (let [uc (clojure.string/upper-case s)]\n                           (if (= uc s)\n                             (clojure.string/lower-case s)\n                             uc)))\n          (flip-case-sym [sym] (-> sym\n                                 str\n                                 flip-case\n                                 symbol))\n          (simplifications [s1 s2]\n            (for [t s2\n                  :let [s2' (disj s2 t)\n                        s2'' (conj s2' (flip-case-sym t))]\n                  :when (clojure.set/superset? s2'' s1)]\n              [s1 s2']))\n          (are-complements [sym1 sym2]\n            (= (str sym1) (flip-case (str sym2))))\n          (cartesian-product [colls]\n             (if (seq colls)\n               (for [h (first colls)\n                     rst (cartesian-product (rest colls))]\n                 (cons h rst))\n             '(())))\n          (to-canonical-minterms [s]\n            (let [all-variables (map #(hash-set % (flip-case-sym %)) (first ss))\n                  all-var-map (reduce (fn [m s]\n                                        (assoc (assoc m (first s) s)\n                                               (second s)\n                                               s))\n                                      {}\n                                      all-variables)\n                  unused-terms (reduce (fn [s e] (disj (set s)\n                                                       (all-var-map e))) \n                                       all-variables\n                                       s)\n                  c-p (cartesian-product unused-terms)]\n              (if (seq unused-terms)\n                (for [cp c-p]\n                  (apply conj s cp))\n                s)))\n          ; omit any remaining terms that are wholly redundant\n          (final-filter [sets]\n            (let [victims (for [s sets\n                                :let [sets' (disj sets s)]\n                                :when (= ss (reduce (fn [a rs]\n                                                      (apply\n                                                        conj\n                                                        a\n                                                        (to-canonical-minterms\n                                                          rs)))\n                                                    #{}\n                                                    sets'))]\n                            s)]\n              (clojure.set/difference sets victims)))\n          ; reduction rules (set == product term):\n          ; 1. If set subset of the other, keep only the subset.\n          ; 2. If two sets identical, except for a single variable that\n          ;    is in one case in one set, and the opposite case\n          ;    in the other, can reduce these two sets to a\n          ;    single set, dropping that variable.\n          ; 3. If by flipping case on a single variable in a set,\n          ;    it becomes a superset of the other, that variable can\n          ;    be dropped from that set since its other state is implied.\n          (reduce-terms [t1 t2] (if (clojure.set/subset? t1 t2)\n                                  [t1]\n                                  (if (clojure.set/subset? t2 t1)\n                                    [t2]\n                                    (let [d1 (clojure.set/difference t1 t2)\n                                          d2 (clojure.set/difference t2 t1)]\n                                      (if (and (= 1 (count d1) (count d2))\n                                               (are-complements (first d1)\n                                                                (first d2)))\n                                        [(clojure.set/difference t1 d1)]\n                                        (let [ss1 (simplifications t1 t2)\n                                              ss2 (simplifications t2 t1)]\n                                          (if ss1\n                                            (first ss1)\n                                            (if ss2\n                                              (first ss2)))))))))\n          (better [t1 t2]\n            (cond\n              (< (count t1) (count t2)) true\n              (> (count t1) (count t2)) false\n              :else (< (apply + (map count t1))\n                       (apply + (map count t2)))))\n          (find-best [currset xs ys best]\n            (if (seq xs)\n              (let [hx (first xs)\n                    tx (rest xs)]\n                (if (seq ys)\n                  (let [hy (first ys)\n                        ty (rest ys)]\n                    (if (not= hx hy)\n                      (let [reduced (reduce-terms hx hy)]\n                        (if reduced\n                          (let [currset' (apply conj\n                                                (disj currset hx hy) reduced)\n                                r1 (find-best currset' currset' currset' best)]\n                            r1)\n                          (recur currset xs ty best)))\n                      (recur currset xs ty best)))\n                  (recur currset tx currset best)))\n              (if (or (nil? best)\n                      (better currset best))\n                currset\n                best)))]\n    (final-filter (find-best ss ss ss nil))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 140, "code": "(fn [algebra]\n  (letfn [(union [s1 s2]\n            (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n          (step [algebra]\n            (let [r (set (flatten (map\n                                    (fn [line]\n                                      (let [m (map\n                                                #(set (conj\n                                                        (remove #{%} line)\n                                                        (case (str %)\n                                                          \"a\" 'A\n                                                          \"A\" 'a\n                                                          \"b\" 'B\n                                                          \"B\" 'b\n                                                          \"c\" 'C\n                                                          \"C\" 'c\n                                                          \"d\" 'D\n                                                          \"D\" 'd)))\n                                                line)\n                                            s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                        (if (seq s) s line)))\n                                    algebra)))]\n              (if (not= r algebra) (step r) algebra)))\n          (power-set [s]\n            (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))]\n    (let [ps (power-set (step algebra))]\n      (apply\n        (partial min-key count)\n        (filter\n          (complement nil?)\n          (map\n            (fn [s]\n              (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) algebra)) s))]\n                (if (= r algebra) s))\n              )\n            ps))))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 140, "code": "(fn [t]\n  (letfn [(get-variables [t]\n            (take (count (first t)) ['A 'B 'C 'D]))\n          (gen-minterms [t]\n            (set (map (fn [m i] (hash-map :k (set [i]) :v (map (fn [x] (if (m x) 1 0)) (get-variables t)))) t (range (count t)))))\n          (diff [a b]\n            (apply + (map (fn [x y] (if (= x y) 0 1)) a b)))\n          (gen-implicant [a b]\n            (map (fn [x y] (if (= x y) x '-)) a b))\n          (gen-implicants [m]\n            (reduce (fn [[a r] x]\n                      (let [[an rn] (reduce (fn [[b s] y]\n                                              (if (= 1 (diff (x :v) (y :v)))\n                                                [(conj b x y)\n                                                 (conj s (hash-map :k (clojure.set/union (x :k) (y :k)) :v (gen-implicant (x :v) (y :v))))]\n                                                [b s])) [#{} #{}] (clojure.set/difference m x))]\n                        [(clojure.set/union a an)\n                         (clojure.set/union r rn)]))\n                    [#{} #{}]\n                    m))\n          (implicants [t]\n            (loop [pr (gen-minterms t)\n                   [nc pc] (gen-implicants pr)]\n              (if (empty? pc)\n                (clojure.set/union pr nc)\n                (recur (clojure.set/union (clojure.set/difference pr nc) pc)\n                       (gen-implicants pc)))))\n          (map-implicants [imp]\n            (reduce (fn [h x]\n                      (merge-with concat h (reduce (fn [s y] (merge-with concat s {y [(x :k)]})) {} (x :k)))) {} imp))\n          (relevant-implicants [p]\n            (mapcat val (filter (fn [x] (= 1 (count (val x)))) p)))\n          (formulas [r imp]\n            (let [m (reduce (fn [s x] (merge s {(x :k) (x :v)})) {} imp)]\n              (map (fn [x] (m x)) r)))\n          (min-func [fr]\n            (set\n             (map (fn [f]\n                    (reduce (fn [s c] (cond (= (first c) 1) (merge s (second c))\n                                            (= (first c) 0) (merge s (symbol (clojure.string/lower-case (second c))))\n                                            :else s)) #{} (map vector f (get-variables t))))\n                  fr)))]\n    (let [imp (implicants t)]\n      (min-func (formulas (relevant-implicants (map-implicants imp)) imp)))))", "user": "5097b556e4b00ad8bab4e970"}, {"problem": 140, "code": "(fn [fs]\n\t(let [first-pass (fn [s]\n\t\t\t\t\t\t(let [lc clojure.string/lower-case\n\t\t\t\t\t\t\t\t  sorter (fn [s] (sort-by #(lc (str %)) s))\n\t\t\t\t\t\t\t\t  reducer (fn [x y] (let [l (map vector (sorter x) (sorter y))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (set (map first (remove (fn [[a b]] (not= a b)) l)))))\n\t\t\t\t\t\t\t\t  neighbors? (fn [x y] (let [nl (reducer x y)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(and (= (count x) (count y)) (= (map (comp lc str) (sorter x)) (map (comp lc str) (sorter y))) (= (count nl) (dec (count x))))))]\n\t\t\t\t\t\t\t\t(loop [current s\n\t\t\t\t\t\t\t\t\t   removed #{}]\n\t\t\t\t\t\t\t\t\t(let [ns (for [x current y current :when (neighbors? x y)] [x y])\n\t\t\t\t\t\t\t\t\t\t  new-rem (clojure.set/union removed (set (apply concat ns)))\n\t\t\t\t\t\t\t\t\t\t  new (set (map (fn [[a b]] (reducer a b)) ns))\n\t\t\t\t\t\t\t\t\t\t  iter-result (clojure.set/difference (clojure.set/union current new) new-rem)]\n\t\t\t\t\t\t\t\t\t\t(if (empty? new) iter-result\n\t\t\t\t\t\t\t\t\t\t\t(recur iter-result new-rem))))))\n\t\t  power-set (fn [sets] \n\t\t\t\t\t\t(loop [s sets r (conj #{sets} #{})]\n\t\t\t\t\t\t\t(if (empty? s) r\n\t\t\t\t\t\t\t(recur (rest s) (into r (set (map #(conj % (first s)) r)))))))\n\t\t  super-neighbors (fn [s] (set (mapcat (fn [e] (filter #(clojure.set/superset? % e) fs)) s)))]\n      (first (sort-by count\n\t\t\t(for [s (power-set (first-pass fs)) :when (= (super-neighbors s) fs)] s)))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 140, "code": "(fn [init]\n  (let [c (count init)\n        init-seq (seq init)\n        lower (fn [s]\n                (->>\n                  s\n                  (apply str)\n                  clojure.string/lower-case\n                  (into #{})))\n        negate2 (fn [s]\n                  (->> \n                    s\n                    (map (fn [c]\n                           (let [as-string (apply str [c])\n                                 negate-string (if (= as-string (clojure.string/lower-case as-string))\n                                                 (clojure.string/upper-case as-string)\n                                                 (clojure.string/lower-case as-string))]\n                             (first negate-string))))\n                    (into #{})))\n        negate (fn [s]\n                 (->>\n                   s\n                   (map {'A 'a, 'B 'b, 'C 'c, 'D 'd\n                         'a 'A, 'b 'B, 'c 'C, 'd 'D})\n                   (into #{})))\n        simplify-vector (first (for [ai (range c)\n                                     bi (range (inc ai) c)\n                                     :let [a (nth init-seq ai)\n                                           b (nth init-seq bi)\n                                           diff-union (clojure.set/difference (clojure.set/union a b) (clojure.set/intersection a b))]\n                                     :when (= 2 (count diff-union))\n                                     :when (->>\n                                             (lower diff-union)\n                                             count\n                                             (= 1))\n                                     ] [a b]))\n        simplify-shorter-vector (fn [] (first (for [ai (range c)\n                                             bi (range c)\n                                             :let [a (nth init-seq ai)\n                                                   b (nth init-seq bi)\n                                                   amb (clojure.set/intersection a b)\n                                                          a-amb (clojure.set/difference a amb)\n                                                          b-amb (clojure.set/difference b amb)]\n                                             :when (= 1 (count a-amb))\n                                             :when (= 2 (count b-amb))\n                                                    :when (->>\n                                                            (clojure.set/union (lower a-amb) (lower b-amb))\n                                                            count\n                                                            (= 2))\n                                             ] [a b])))]\n    (if (nil? simplify-vector)\n      (let [simplify-shorter-vector-manifest (simplify-shorter-vector)]\n        (if (nil? simplify-shorter-vector-manifest) init\n          (let [[a b] simplify-shorter-vector-manifest\n                amb (clojure.set/intersection a b)\n                to-remove-term (negate (clojure.set/difference a amb))\n                new-term (clojure.set/difference b to-remove-term)\n                new-init (conj (disj init b) new-term)]\n            (recur new-init))))\n      (let [[a b] simplify-vector\n            new-term (clojure.set/intersection a b)\n            new-init (conj (disj init a b) new-term)]\n        (recur new-init)))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 140, "code": "(fn vp [input]\n    (let [ordered [['a 'A] ['b 'B] ['c 'C] ['d 'D]]\n          tabify-row (fn [r]\n                       (loop [ordered ordered r r out (transient [])]\n                         (if-let [current (first ordered)]\n                           (recur (rest ordered)\n                                  r\n                                  (conj! out (cond\n                                              (contains? r (first current)) '0\n                                              (contains? r (second current)) '1\n                                              :else nil)))\n                           (->> (persistent! out)\n                                (filter identity)\n                                vec))))\n          untabify-row (fn [r]\n                         (loop [ordered ordered r r out (transient [])]\n                           (if-let [current (first r)]\n                             (recur (rest ordered)\n                                    (rest  r)\n                                    (conj! out (cond\n                                                (= current '0) (ffirst ordered)\n                                                (= current '1)\n                                                (second (first ordered))\n                                                :else nil)))\n                             (->> (persistent! out)\n                                  (filter identity)\n                                  set))))\n          group-tabbed (fn [tabbed]\n                         (->> (group-by #(or (get (frequencies %) '1) 0) tabbed)\n                              (into (sorted-map))))\n\n          tabify-input(fn [input]\n                        (mapv tabify-row input))\n\n          combine (fn [a b]\n                    (mapv #(if (=  %1 %2) %1 '-) a b))\n\n          hashes-match? (fn  [a b]\n                          (= (mapv #(= '- %) a)\n                             (mapv #(= '- %) b)))\n          combine? (fn  [a b]\n                     (and (hashes-match? a b)\n                          (->> (map #(= %1 %2) a b)\n                               (filter false?)\n                               count\n                               (= 1))))\n          combine-groups (fn [a b covered]\n                           (loop [in a output [] covered covered]\n                             (if-let [e (first in)]\n                               (let [res (map #(when (combine? e %)\n                                                 (vector e % (combine e %)))\n                                              b)\n                                     combined (filter identity res)]\n                                 (recur (rest in)\n                                        (concat output (map last combined))\n                                        (concat covered\n                                                (map first combined)\n                                                (map second combined))))\n                               (let [uncovered\n                                     (->> (clojure.set/intersection\n                                           (set a)\n                                           (set covered))\n                                          (clojure.set/difference (set a)))]\n        [(concat output uncovered) covered]))))\n        step-map (fn  [m output covered]\n                   (loop [vs (vals m) output output covered covered]\n                       (if-let [v (second vs)]\n                         (let [res (combine-groups (first vs) v covered)]\n                           (recur (rest vs)\n                                  (concat output (first res))\n                                  (concat covered (second res))))\n                         (let[uncovered\n                              (->> (clojure.set/intersection (set (first vs))\n                                                             (set covered))\n                                   (clojure.set/difference (set (first vs))))\n                              merged-out\n                              (->> (clojure.set/intersection (set output)\n                                                             (set covered))\n                                   (clojure.set/difference (set output)))]\n                           [(vec (concat merged-out uncovered))\n                            (->> covered set vec)]))))\n          step (fn  [in output covered]\n                 (step-map (group-tabbed in) output covered))\n          covers? (fn  [input q-m]\n                    (every? (fn [s]\n                              (some #(empty? (apply disj % s)) q-m)) input))\n          essential-primes (fn  [input q-m]\n                             (let [options\n                                   (for [s q-m\n                                         :let [new-qm (disj q-m s)]\n                                         :when (covers? input new-qm)] new-qm)]\n                               (if (empty? options) q-m (first options))))\n          qm (fn [input]\n               (let [in (tabify-input input)]\n                 (loop [mins in out [] covered []]\n                   (let [reduced (step mins out covered)]\n                     (if (= (set mins) (set (first reduced)))\n                       (->> mins\n                            (map untabify-row)\n                            set\n                            (essential-primes input))\n                       (recur (first reduced)\n                              (first reduced)\n                              (second reduced)))))))]\n      (qm input)))", "user": "5273e006e4b03e8d9a4a7495"}, {"problem": 140, "code": "(fn [sets]\n  (letfn [(convert-into-bit-rep [set-rep]\n            (->> set-rep\n                 (map name)\n                 (sort-by (comp clojure.string/upper-case))\n                 (map (comp #(if (< 96 %) 0 1) int first))))\n\n          (convert-into-inner-rep [i bit-rep]\n            {:distance 0\n             :pattern  bit-rep\n             :indices  #{i}\n             :original []})\n\n          (hamming-distance [{pattern1 :pattern, indices1 :indices}\n                             {pattern2 :pattern, indices2 :indices}]\n            (let [[hd rpat] (reduce\n                             (fn [[n done] [e1 e2]]\n                               (if (= e1 e2)\n                                 [n (conj done e1)]\n                                 [(inc n) (conj done nil)]))\n                             [0 ()]\n                             (map vector pattern1 pattern2))\n                  pat (vec (reverse rpat))]\n              {:distance hd\n               :pattern  pat\n               :indices  (clojure.set/union indices1 indices2)\n               :original [pattern1 pattern2]}))\n\n          (calc-hamming-distance [[f & r :as terms]]\n            (when (seq r)\n              (lazy-cat\n               (map (partial hamming-distance f) r)\n               (calc-hamming-distance r))))\n\n          (make-pattern-map [hamming-distances]\n            (into {} (map #(vector (:pattern %) %) hamming-distances)))\n          (find-minterms [not-mins]\n            (let [hdmap (make-pattern-map not-mins)\n                  {:keys [distances not-minterms]}\n                  (reduce\n                   (letfn [(local-min [o n] (if (nil? o) n (min o n)))]\n                     (fn [{:keys [distances not-minterms duplicates] :as summary}\n                          {:keys [distance pattern indices original] :as not-min}]\n                       (let [[p1 p2] original]\n                         (case distance\n                           0 (if (duplicates pattern)\n                               summary\n                               (-> summary\n                                   (update-in [:duplicates] #(conj % pattern))\n                                   (update-in [:not-minterms] #(conj %1 %2) not-min)))\n                           1 (-> summary\n                                 (update-in [:distances p1] local-min distance)\n                                 (update-in [:distances p2] local-min distance)\n                                 (update-in [:not-minterms] #(conj %1 %2) not-min))\n                           (-> summary\n                               (update-in [:distances p1] local-min distance)\n                               (update-in [:distances p2] local-min distance))))))\n                   {:distances    {}\n                    :not-minterms ()\n                    :duplicates   #{}}\n                   (calc-hamming-distance not-mins))\n                  minterms (->> distances\n                                (filter (fn [[_ d]] (< 1 d)))\n                                (map (comp hdmap first)))]\n              {:minterms     minterms\n               :not-minterms not-minterms}))\n\n          (find-minterms*\n            ([not-mins] (find-minterms* not-mins ()))\n            ([not-mins mins]\n               (case (count not-mins)\n                 0 mins\n                 1 (conj mins (first not-mins))\n                 (let [{:keys [minterms not-minterms]}\n                       (find-minterms not-mins)]\n                   (recur not-minterms\n                          (concat mins minterms))))))\n\n          (product-minterms [n minterms]\n            (for [i (range n)]\n              (map (comp hash-set :pattern)\n                   (filter (fn [y] (some #{i} (:indices y))) minterms))))\n\n          (product-boolean-algebra [b1 b2]\n            (distinct\n             (for [e1 b1\n                   e2 b2]\n               (clojure.set/union e1 e2))))\n\n          (simplify-boolean [bs]\n            (let [counts (into {} (map #(vector % (count %)) bs))\n                  variations (set (vals counts))\n                  max-variation (apply max variations)]\n              (if (= 1 (count variations))\n                bs\n                (let [{simple true, complex false}\n                      (group-by #(< (counts %) max-variation) bs)]\n                  (concat simple\n                          (reduce\n                           (fn [c s] (filter #(not (every? % s)) c))\n                           complex\n                           simple))))))\n\n          (petricks-method [patterns]\n            (reduce\n             (fn [b1 b2]\n               (->> (product-boolean-algebra b1 b2)\n                    (simplify-boolean)))\n             patterns))\n\n          (convert-into-set-rep [bit-rep]\n            (->> bit-rep\n                 (map-indexed\n                  (fn [i v]\n                    (let [c (char (+ 97 i))]\n                      (case v\n                        0 (symbol (clojure.string/lower-case c))\n                        1 (symbol (clojure.string/upper-case c))\n                        nil))))\n                 (filter (complement nil?))\n                 (set)))\n\n          (Quine-McCluskey [bit-reps]\n            (->> bit-reps\n                 (map-indexed #(convert-into-inner-rep %1 %2))\n                 (find-minterms*)\n                 (product-minterms (count bit-reps))\n                 (petricks-method)\n                 (first)))\n\n          (main [sets]\n            (->> sets\n                 (map convert-into-bit-rep)\n                 (Quine-McCluskey)\n                 (map convert-into-set-rep)\n                 (set)))]\n    (main sets)))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 140, "code": "(fn [inputs]\n    (let [contains? (fn [cand expr] (every? expr cand))\n          count-matches (fn [cand] (count (filter (partial contains? cand) inputs)))\n          opt-array '[[A a _] [B b _] [C c _] [D d _]]\n          all-cands (map #(filter (complement #{'_}) %)\n                         (for [a ['A 'a '_] b ['B 'b '_] c ['C 'c '_] d ['D 'd '_]\n                               :when (some #(not= % '_) [a b c d])]\n                           [a b c d]))\n          size-space (apply * (repeat (count (first inputs)) 2))\n          true-exprs (into #{}\n                           (map #(into #{} %)\n                                (filter #(= (count-matches %) \n                                            (apply / size-space (repeat (count %) 2))) \n                                        all-cands)))\n          covers? (fn [exprs] (= 0 \n                                 (count (reduce \n                                         (fn [acc v] (into #{} (remove #(contains? v %) \n                                                                       acc)))\n                                         inputs\n                                         exprs))))\n          next-subsets (fn [cur-sub]\n                         (reduce (fn [acc v] (into acc (map #(conj v %)\n                                                            (remove v true-exprs))))\n                                 #{} \n                               cur-sub))]\n      (first \n       (sort-by #(apply + (map count %))\n                (filter covers?\n                        (first (for [a (iterate next-subsets (map (fn[s] #{s}) true-exprs))\n                                     :when (some identity (map covers? a))]\n                                 a)))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 140, "code": "(fn [s]\n    (let [ elt-count (count (set (map clojure.string/upper-case (mapcat identity s))))\n           cols [#{'a 'b} #{'a 'B} #{'A 'B} #{'A 'b}]\n           rows (if (= 3 elt-count) [#{'c} #{'C}] [#{'c 'd} #{'c 'D} #{'C 'D} #{'C 'd}])\n           calc-idx (fn [hdrs] (fn [vals] (first (keep-indexed (fn [idx ss] (if (every? vals ss) idx)) hdrs))))\n           ttable (reduce (fn [t [c r]] (assoc t r (assoc (get t r) c 1)))\n                          (vec (repeat (count rows) (vec (repeat (count cols) 0))))\n                          (map (juxt (calc-idx cols) (calc-idx rows)) s))\n           acc-reg (fn [mn tt] (map #(reduce (fn [c v] (conj c (if (> v mn) v 0))) [] (apply mapv + %)) (partition 2 1 tt)))\n           intsec (fn [ss] (let [is (if (seq ss) (apply clojure.set/intersection ss))] (if (empty? is) ss (list is))))\n           find-cols (fn [tt] (map intsec (map #(keep-indexed (fn [idx v] (if (pos? v) (cols idx))) %) tt)))\n           ttable2 (acc-reg 1 ttable)\n           ttable3 (acc-reg 2 ttable2)\n           ttable4 (acc-reg 4 ttable3)\n           all-regs (set (map #(apply clojure.set/union %)\n                              (mapcat (fn [[cs rs]] (for [c cs r rs] [c r]))\n                                      (concat\n                                        (map vector (repeat '(#{})) (find-cols ttable4))\n                                        (map vector (repeat '(#{})) (find-cols ttable3))\n                                        (map vector (map intsec (partition 2 1 rows)) (find-cols ttable2))\n                                        (map vector (map list rows) (find-cols ttable))))))\n           subset-regs (set (reduce (fn [c v]\n                                 (let [rc (remove #(clojure.set/superset? % v) c)]\n                                   (if (> (dec (count c)) (count rc)) (conj rc v) c))) all-regs all-regs))\n           is-UL? (fn [s] (let [setU (filter #(= (name %) (clojure.string/upper-case (name %))) s)\n                                setL (filter #(= (name %) (clojure.string/lower-case (name %))) s)]\n                            (= (set setU) (set (map (comp symbol clojure.string/upper-case) setL)))))\n           c-targ (filter #(is-UL? (first %))\n                          (filter #(= 2 (count (first %)))\n                                  (filter #(pos? (count (first %)))\n                                          (for [s1 subset-regs s2 subset-regs]\n                                            [(clojure.set/difference (clojure.set/union s1 s2) (clojure.set/intersection s1 s2)) s1 s2]))))\n           smaller-regs (reduce (fn [c [_ v1 v2]] (remove #(= v1 %) (remove #(= v2 %) c))) subset-regs c-targ)\n           mid-regs (set (reduce (fn [c [_ v1 v2]] (conj c (clojure.set/intersection v1 v2))) smaller-regs c-targ))\n           final-regs (if (or (every? empty? mid-regs)\n                              (> (count mid-regs) (count subset-regs))) subset-regs mid-regs)]\n      final-regs\n      ))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 140, "code": "(fn veitchdiagram [s]\n     (if (empty? s)\n       s\n       (let [powerset (fn p [x] (if (empty? x)\n                #{#{}}\n                (into (p (set (rest x))) (set (for [y (vector (first x))\n                                                    z (p (set (rest x)))]\n                                                (conj z y))))))\n                            tobinary (fn g [n]\n                                       (if (< n 2)\n                                         (vector n)\n                                         (conj (g (/ (- n (mod n 2)) 2)) (mod n 2))))\n                            inputs (vec (map vector (map #(Character/toLowerCase (first (name %))) (first s)) \n                                             (map #(Character/toUpperCase (first (name %))) (first s))))\n                            possiblists (fn f [m coll]\n                                          (let [v (vec coll)]\n                                            (if (== m 0)\n                                              #{}\n                                              (if (empty? coll)\n                                                #{}\n                                                (if (== m 1)\n                                                  (set (map list coll))\n                                                  (set (for [a (range (count coll))\n                                                             s (f (dec m) (vec (concat (take a coll) (drop (inc a) coll))))]\n                                                         (cons (get (vec coll) a) s))))))))\n                                            bool (fn [v cond]\n                                                   (if (empty? cond)\n                                                     true\n                                                     (reduce #(and %1 %2) (for [c cond]\n                                                                           (some #{c} v)))))\n                                            aux (fn [w]\n                                                  (loop [result w counter 0]\n                                                    (if (>= counter (count w))\n                                                      result\n                                                      (recur (assoc result counter (get (get inputs counter) (get w counter))) (inc counter)))))\n                                            allvs (set (for [i (range (Math/pow 2 (count (first s))))]\n                                                         (if (< (count (tobinary i)) (count (first s)))\n                                                           (set (map #(symbol (str %)) (aux (vec (concat (repeat (- (count (first s)) (count (tobinary i))) 0)\n                                                                                                    (tobinary i))))))\n                                                           (set (map #(symbol (str %)) (aux (tobinary i)))))))\n                                            aux2 (fn [c]\n                                                   (if (empty? c)\n                                                     true\n                                                     (reduce #(and %1 %2) c)))\n                                            auxresult (fn [e]\n                                                        (loop [init e result #{}]\n                                                          (if (empty? init)\n                                                            (count result)\n                                                            (recur (rest init) (into result (filter #(bool % (first init)) allvs))))))\n                                            aux3 (fn [o u]\n                                                   (if (<= (count o) (count u)) o u))]           \n                                        (loop [conditions #{} size 1]\n                                          (if (> size (count (first s)))\n                                            (reduce aux3 (filter #(== (auxresult %) (count s)) (powerset conditions)))\n                                            (let [q (for [b (set (mapcat #(map set (possiblists size %)) allvs))\n                                                          :when (and (aux2 (for [j conditions]\n                                                                       (not (bool b j))))\n                                                                 (aux2 (for [j (filter #(bool % b) allvs)]\n                                                                           (some #{j} s))))]\n                                                      b)]\n                                              (if (empty? q)\n                                                (recur conditions (inc size))\n                                                (recur (into conditions q) (inc size)))))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 140, "code": "(fn veitch [rules]\n  (let [dict (fn [rs] (apply clojure.set/union rs))\n        negation {'a 'A, 'A 'a, 'b 'B, 'B 'b, 'c 'C, 'C 'c, 'd 'D, 'D 'd}\n        numOfSyms (count (first rules))\n        gen-comb (fn [n syms]\n                   (loop [i 1 r #{#{}}]\n                     (let[nr (set (reduce concat (for[acc r s syms :when (and (not (contains? acc s))\n                                                                              (not (contains? acc (negation s))))]\n                                                   [(conj acc s)])))]\n                       (if (= i n) nr (recur (inc i) nr)))))\n        find-solution (fn [solutions n]\n                        (loop[s solutions result #{}]\n                          (if(seq s)\n                            (let[newlyMatched (filter #(clojure.set/subset? (first s) %) rules)]\n                              (if (= (count newlyMatched) n) (recur (rest s) (conj result (first s)))\n                                (recur (rest s) result)))\n                            result)))]\n    (loop[i 1 solutions #{} matched #{} remainingRules rules]\n      (cond\n       (= matched rules) solutions\n       (= i numOfSyms) (clojure.set/union solutions (clojure.set/difference rules matched))\n       :else (let[n (int (Math/pow 2 (- numOfSyms i)))\n                  potSol (gen-comb i (dict remainingRules))\n                  sol (find-solution potSol n)\n                  newlyMatched (set (apply concat (for[s sol] (filter #(clojure.set/subset? s %) rules))))\n                  refinedSolutions (set (loop[s sol reSol solutions]\n                                     (if(seq s) (recur (rest s) (filter #(empty? (clojure.set/intersection (first s) %)) reSol))\n                                       reSol)))]\n               (if (seq sol) (recur (inc i) (clojure.set/union refinedSolutions sol) (clojure.set/union matched newlyMatched) (clojure.set/difference remainingRules newlyMatched))\n                 (recur (inc i) solutions matched remainingRules)))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 140, "code": "(let [\n      ; OMG what a mess.  Surely there's a better way!                                                                                                          \n\n      ; When we say \"4vector\", we mean a vector of length 4.  Elements of                                                                                       \n      ; these vectors are the values 0, 1, or '-.  This is how we represent                                                                                     \n      ; inputs.  The symbol '- means \"both 0 and 1\", e.g. [0 1 - 1] is the                                                                                      \n      ; same as both [0 1 0 1] and [0 1 1 1].                                                                                                                   \n      ;                                                                                                                                                         \n      ; By a \"binary 4vector\", we mean a 4vector containing only 0's or 1's                                                                                     \n      ; (i.e. no '- symbols).                                                                                                                                   \n\n      binary-values #{0 1}\n\n      ; return a list of the keys (in the range 0-4) which give the positions                                                                                   \n      ; in v that contain binary values                                                                                                                         \n      binary-keys (fn binary-keys [v] (filter #(binary-values (v %)) (range 4)))\n\n      ; return a list of the keys (in the range 0-4) which give the positions                                                                                   \n      ; in v that contain '- values                                                                                                                             \n      dash-keys (fn dash-keys [v] (filter #(= '- (v %)) (range 4)))\n\n      ; return a sequence of all binary vectors of length n.                                                                                                    \n      ; I'm sure there's a more elegant/general way to do this, but for this problem,                                                                           \n      ; this hard-coded solution will do.                                                                                                                       \n      binary-seq (fn binary-seq [n]\n                   (condp = n\n                     0 [[]]\n                     1 [[0] [1]]\n                     2 [[0 0] [0 1] [1 0] [1 1]]\n                     3 [[0 0 0] [0 0 1] [0 1 0] [0 1 1] [1 0 0] [1 0 1] [1 1 0] [1 1 1]]\n                     4 [[0 0 0 0] [0 0 0 1] [0 0 1 0] [0 0 1 1] [0 1 0 0] [0 1 0 1] [0 1 1 0] [0 1 1 1]\n                        [1 0 0 0] [1 0 0 1] [1 0 1 0] [1 0 1 1] [1 1 0 0] [1 1 0 1] [1 1 1 0] [1 1 1 1]]\n                     :else nil))\n\n      ; take a 4vector `v`, a vector of indices `ks`, and a vector of binary values `xs`,                                                                       \n      ; and return the 4vector that results from setting the elements of `v` in positions `ks`                                                                  \n      ; to the corresponding values in `xs`.                                                                                                                    \n      ;   (apply-binary-values '[0 - 1 -] [1 3] [1 1]) ;=> [0 1 1 1]                                                                                            \n      ;   (apply-binary-values '[0 - 1 -] [1 3] [0 0]) ;=> [0 0 1 0]                                                                                            \n      apply-binary-values (fn apply-binary-values [v ks xs]\n                            (reduce\n                             (fn [v [k x]] (assoc v k x))\n                             v\n                             (map vector ks xs)))\n      ; take a 4vector `v`, and return the set of binary vectors that results from                                                                              \n      ; all possible binary value settings of the dash positions in v.                                                                                          \n      ; e.g.                                                                                                                                                    \n      ;       (binary-expand '[0 - 1 0]) ;=> #{[0 0 1 0] [0 1 1 0]}                                                                                             \n      ;       (binary-expand '[0 - 1 -]) ;=> #{[0 0 1 0] [0 1 1 0] [0 0 1 1] [0 1 1 1]}                                                                         \n      binary-expand (fn binary-expand [v]\n                      (let [dkeys (dash-keys v)]\n                        (set (map #(apply-binary-values v dkeys %) (binary-seq (count dkeys))))))\n\n      ; Take a set of binary 4vectors `s`, and a 4vector `v`, and return the                                                                                    \n      ; set of all 4vectors that can be obtained by replacing a single binary                                                                                   \n      ; value in `v` with a '-, such that all the corresponding binary 4vectors                                                                                 \n      ; are in `s`.  I.e. the set of all 1-bit generalizations of v relative to s.                                                                              \n      generalizations (fn generalizations [s v]\n                        (let [bks   (binary-keys v)            ; bks are the binary keys for v                                                                  \n                              gens  (map #(assoc v % '-) bks)] ; gens is the coll of 1-bit generalizations of v, with no regard to s                            \n                                        ; return the set of elements of gens whose binary expanions are subsets of `s`                                          \n                          (set (filter (fn [g] (clojure.set/subset? (binary-expand g)\n                                                                    (set (mapcat binary-expand s)) ; need to expand s, in case it includes any dashes           \n                                                                    )) gens))\n                          )\n                        )\n\n      generalize (fn generalize [s vs]\n                   (clojure.set/union\n                    vs\n                    (set (mapcat #(generalizations s %) vs))\n                    ))\n\n      fixed-point (fn fixed-point [f p]\n                    (let [fp (f p)]\n                      (if (= p fp) p\n                          (fixed-point f fp))))\n\n      do-gen (fn do-gen [s v] (fixed-point #(generalize s %) #{v}))\n\n      dash-count (fn dash-count [v] (count (filter #(= '- %) v)))\n\n      order-set (fn order-set [vs] (apply vector (reverse (sort-by dash-count vs))))\n\n      q-table (fn q-table [s]\n                (let [vs (apply vector s)]\n                  (mapv vector vs (map #(order-set (do-gen s %)) vs))))\n\n                                    ; `coll` is a collection, and `f` is a function that maps elements of that collection to numbers, and                                                     \n      ; `ag' is an aggregating function (such as `min` or `max`).                                                                                               \n      ; (ag-filter coll f ag) returns a new collection consisting of the elements of coll for which the                                                         \n      ;   value of f equals the aggregate value of f over all of `coll`.                                                                                        \n      ; For example,                                                                                                                                            \n      ;   (ag-filter coll f max) returns the elements of coll for which f is maximal                                                                            \n      ;   (ag-filter coll f min) returns the elements of coll for which f is minimal                                                                            \n      ag-filter (fn ag-filter [ag f coll]\n                  (let [fag (apply ag (map f coll))]\n                    (filter #(= fag (f %)) coll)))\n\n      max-filter (fn max-filter [f coll] (ag-filter max f coll))\n      min-filter (fn min-filter [f coll] (ag-filter min f coll))\n\n      vector-contains? (fn vector-contains? [v e] (some #(= e %) v))\n\n      it-q-table (fn it-q-table [[ts qt]]\n                   (let [min-star-rows            (min-filter #(count (% 1)) qt)\n                         min-terms                (mapcat #(% 1) min-star-rows)\n                         num-stars-in-col         (fn [t] (count (filter #(vector-contains? (% 1) t) qt)))\n                         max-cols                 (max-filter num-stars-in-col min-terms)\n                         max-cols-with-max-dashes (max-filter dash-count max-cols)\n                         min-term                 (first max-cols-with-max-dashes) ; minterm to emit                                                            \n                         rows-to-keep             (filter #(not (vector-contains? (% 1) min-term)) qt)\n                         new-qt                   (mapv\n                                                   (fn [[v vs]] [v (apply vector (filter #(not (= % min-term)) vs))])\n                                                   rows-to-keep)\n                         ]\n                     [(conj ts min-term) new-qt]\n                     ))\n\n      re-it-q-table (fn re-it-q-table [[ts qt]]\n                      (if (empty? qt) ts\n                          (re-it-q-table (it-q-table [ts qt]))))\n\n      quine-mcclusky (fn quine-mcclusky [s] (re-it-q-table [[] (q-table s)]))\n\n      ; convert a 4vector `v` to a set                                                                                                                          \n      ;   e.g.  (to-set '[0 - 1 0]) ;=> #{'a 'C}                                                                                                                \n      to-set (fn to-set [v]\n               (let [emap [{'- nil, 0 'a, 1 'A}\n                           {'- nil, 0 'b, 1 'B}\n                           {'- nil, 0 'c, 1 'C}\n                           {'- nil, 0 'd, 1 'D}]]\n                 (set (filter #(not (nil? %))\n                              (map #(%1 %2) emap v)))))\n      ; convert a set to a 4vector                                                                                                                              \n      ;   e.g. (to-4vector #{'a 'C}) ;=> [0 - 1 0]                                                                                                              \n      to-4vector (fn to-4vector [s]\n                   (let [emap {'A [0 1]\n                               'a [0 0]\n                               'B [1 1]\n                               'b [1 0]\n                               'C [2 1]\n                               'c [2 0]\n                               'D [3 1]\n                               'd [3 0]}]\n\n                     (reduce\n                      (fn [v [i x]] (assoc v i x))\n                      '[- - - -]\n                      (map emap s)\n                      )))\n\n      veitch (fn veitch [s] (set (map to-set (quine-mcclusky (set (map to-4vector s))))))\n      ]\n  veitch\n)", "user": "530bf87ee4b02e82168697d5"}, {"problem": 140, "code": "(fn [s]\n  (println s)\n  (let [d clojure.set/difference\n        u clojure.set/union\n        g #(-> % first str .toUpperCase)\n        n (for [x s y s :while (not= x y)]\n            (let [i (clojure.set/intersection x y)\n                  a (d x i)\n                  b (d y i)]\n              (if (and (= 1 (count a) (count b))\n                       (= (g a) (g b)))\n                [i #{x y}])))\n        sn (->> n (map first) (filter #(not= nil %)) set)\n        sx (->> n (map last) (apply u))]\n    (if (empty? sn)\n      (disj s #{'A 'd})\n      (recur (u sn (d s sx))))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 140, "code": "(fn kmap-reduce [kmap]\n\t(let [minterms (map #(sort-by clojure.string/upper-case %) (vec kmap))]\n\t(letfn [(one-off? [x y]\n\t\t\t\t(= 1 (apply +\n\t\t\t\t\t(map (fn [a b] (if (= a b) 0 1)) x y))))\n\t\t\t(kreduce [x y]\n\t\t\t\t(if (one-off? x y)\n\t\t\t\t\t(map (fn [a b] (if (= a b) a '-)) x y)))\n\t\t\t(combinations [xs]\n\t\t\t\t(let [ct (count xs)]\n\t\t\t\t\t(for [i (range ct) j (range (inc i) ct)]\n\t\t\t\t\t\t[(nth xs i) (nth xs j)])))\n\t\t\t(covers? [pi mt]\n\t\t\t\t(every? (fn [[a b]] (or (= a '-) (= a b)))\n\t\t\t\t\t(map vector pi mt)))\n\t\t\t(find-essentials [pi]\n\t\t\t\t(into #{} \n\t\t\t\t\t(map #(disj (set %) '-)\n\t\t\t\t\t(reduce\n\t\t\t\t\t(fn [es mt]\n\t\t\t\t\t\t(let [xs (filter #(covers? % mt) pi)]\n\t\t\t\t\t\t\t(if (= 1 (count xs))\n\t\t\t\t\t\t\t\t(conj es (first xs))\n\t\t\t\t\t\t\t\tes)))\n\t\t\t\t\t\t#{} minterms))))]\n\n\t(loop [imps minterms]\n\t\t(let [cs (combinations imps) \n\t\t\trmap\n\t\t\t(filter identity\n\t\t\t\t(map (fn [[x y]]\n\t\t\t\t\t\t(let [reduced (kreduce x y)]\n\t\t\t\t\t\t\t(if reduced [[x y] reduced])))\n\t\t\t\t\t  cs))\n\t\t\telim (set (apply concat (map first rmap)))\n\t\t\tall-reduced (map second rmap)\n\t\t\tnext-set (concat (remove elim imps) all-reduced)]\n\t\t\t(if (= (set imps) (set next-set))\n\t\t\t\t(find-essentials imps)\n\t\t\t\t(recur (distinct next-set))))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 140, "code": "(fn [I]\n    (disj (into #{} (map (fn [s]\n                           ((reduce\n                             (fn [[d f u] x]\n                               (let [U (disj u x)\n                                     m (fn [t] (map #(conj % t) f))\n                                     P #(symbol (.toUpperCase (str %)))\n                                     L #(symbol (.toLowerCase (str %)))\n                                     F (into (m (L x)) (m (P x)))]\n                                 (if (every? #(contains? I %) (map #(into (into d U) %) F))\n                                   [d F U]\n                                   [(conj d x) f U])))\n                             [#{} [#{}] s]\n                             s) 0)) I))\n      '#{A d}))  ;;<-derp", "user": "4db858d1535d1e037afb218c"}, {"problem": 140, "code": "(fn [conditions]\n    (letfn [(build-kmap [conditions]\n              (let [negative #(symbol (.toLowerCase (name %)))\n                    positive #(symbol (.toUpperCase (name %)))\n                    gray-codes (fn gray-codes [symbols]\n                                 (if (empty? symbols) [#{}]\n                                     (let [varying (first symbols)\n                                           subsequent-gray-codes (gray-codes (rest symbols))]\n                                       (concat (map #(conj % (negative varying))\n                                                    subsequent-gray-codes)\n                                               (map #(conj % (positive varying))\n                                                    (reverse subsequent-gray-codes))))))\n                    symbols (sort (map negative (first conditions)))\n                    [x-symbols y-symbols] (split-at (Math/ceil (/ (count symbols) 2))\n                                                    symbols)\n                    [x-gray-codes y-gray-codes] (map gray-codes [x-symbols y-symbols])\n                    grid (map (fn [y-gray-code]\n                                (map #(if (conditions (set (concat % y-gray-code))) 1 0)\n                                     x-gray-codes)) y-gray-codes)]\n                {:grid grid\n                 :x-gray-codes x-gray-codes\n                 :y-gray-codes y-gray-codes\n                 :width (count (first grid))\n                 :height (count grid)}))\n            (identify-simplifications [kmap]\n              (let [log2 {1 0, 2 1, 4 2}\n                    gray-codes-for-box (fn [gray-codes positions]\n                                         (apply clojure.set/intersection\n                                                (map #(nth gray-codes %) positions)))\n                    cyclic-ranges (fn [distance size]\n                                    (for [start (range distance)]\n                                      (take size (drop start (cycle (range distance))))))\n                    rectangle-coordinates (fn [size]\n                                          (set (for [divisor [1 2 4]\n                                                     xs (cyclic-ranges (kmap :width)\n                                                                       (/ size divisor))\n                                                     ys (cyclic-ranges (kmap :height)\n                                                                       divisor)]\n                                                 (set (for [x xs y ys] [x y])))))\n                    convert-pairs-to-expressions (fn [pairs]\n                                                   [(clojure.set/union\n                                                     (gray-codes-for-box (kmap :x-gray-codes)\n                                                                         (map first pairs))\n                                                     (gray-codes-for-box (kmap :y-gray-codes)\n                                                                         (map second pairs)))\n                                                    (set (map (fn [[x y]] (nth (nth (kmap :grid)\n                                                                                    y) x))\n                                                              pairs))])\n                    boxes-sized (fn [size]\n                                  (set (map convert-pairs-to-expressions\n                                            (rectangle-coordinates size))))]\n                (map (fn [size]\n                       (map first\n                            (filter #(not ((second %) 0))\n                                    (boxes-sized size))))\n                     [8 4 2 1])))\n            (prune-duplicates [full-conditions simplified-conditions]\n              (let [mostly-reduced (set (reduce (fn [existing-conditions new-conditions]\n                                                  (into existing-conditions\n                                                        (filter (fn [new]\n                                                                  (not (some (fn [existing]\n                                                                               (every? new existing))\n                                                                             existing-conditions)))\n                                                                new-conditions)))\n                                                simplified-conditions))\n                    coverage (into {} (map (fn [condition] [condition (filter #(every? condition %)\n                                                                              mostly-reduced)])\n                                           full-conditions))\n                    exclusively-satisfying-rules (set (mapcat val (filter #(= (count (val %)) 1) coverage)))\n                    ]\n                exclusively-satisfying-rules))]\n      (prune-duplicates conditions (identify-simplifications (build-kmap conditions)))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 140, "code": "(fn veitch [sets]\n  (let\n    [syms #{#{'A 'a} #{'B 'b} #{'C 'c} #{'D 'd}}]\n    (letfn [(mutual-difference [p q]\n              (clojure.set/difference\n                (clojure.set/union p q)\n                (clojure.set/intersection p q)))\n            (absorb [p q]\n              (cond\n                (clojure.set/superset? p q)\n                  q\n                (clojure.set/superset? q p)\n                  p\n                :else\n                  nil))\n            (combine [p q]\n              (let [diff (mutual-difference p q)]\n                (if\n                  (syms diff)\n                  (apply disj p diff)\n                  nil)))\n            (simplify [p q]\n              (let [pair (sort-by count [p q])\n                    diff (apply clojure.set/difference pair)\n                    diff-compliment (when\n                                      (= 1 (count diff))\n                                      (disj \n                                       (first\n                                         (filter\n                                           (partial some diff)\n                                           syms))\n                                        (first diff)))]\n                (if\n                  (and (= 1 (count diff))\n                       (some diff-compliment (second pair)))\n                  (map\n                    #(clojure.set/difference % diff-compliment)\n                    pair)\n                  pair)))\n            (integrate-item [table new-item]\n              (loop [[item & items] (vec table)]\n                (let [combination (combine item new-item)      \n                      absorption (absorb item new-item)]\n                  (cond\n                    (nil? item)\n                      (conj table new-item)\n                    combination                    \n                      (conj\n                        (disj table item)\n                        combination)\n                    absorption\n                      (conj\n                        (disj table item)\n                        absorption)\n                    :else\n                      (recur items)))))\n            (simplify-set [table new-item]\n              (loop [[item & items] (vec table)]\n                (let [simplification (simplify item new-item)]\n                  (cond\n                    (nil? item)\n                      (conj table new-item)\n                    (not= simplification (sort-by count [item new-item]))\n                      (apply \n                        conj\n                        (disj table item)\n                        simplification)\n                    :else\n                      (recur items)))))]\n      (let\n        [reduced-sets \n          (reduce integrate-item #{} sets)]\n        (if \n          (= sets reduced-sets)\n          (reduce simplify-set #{} sets)\n          (recur\n            reduced-sets))))))", "user": "521e8227e4b0dd19981ad082"}, {"problem": 140, "code": "(fn [xs]\n  (let [xx '[a b c d]\n        sub? clojure.set/subset?]\n    (letfn [(toggle [s] (if (= s (.toLowerCase s)) (.toUpperCase s) (.toLowerCase s)))\n            (notb [sym] (-> sym name toggle symbol))\n            (=? [a b] (or (= a b) (= a (notb b))))\n            (extend [xs x] (concat (map #(conj % x) xs)\n                                   (map #(conj % (notb x)) xs)))\n            (expand [x] (let [free (remove #(some (partial =? %) x) xx)]\n                          (reduce extend [x] free)))\n            (permute [xs] (set (remove empty?\n                                       (reduce (fn [xs x] (concat xs (extend xs x)))\n                                               [#{}] xs))))\n            (remove-direct [xs] (let [xs (sort-by count xs)]\n                                  (reduce (fn [xs x]\n                                            (if (some #(sub? % x) xs)\n                                              xs (conj xs x)))\n                                          #{} xs)))\n            (remove-unnec [xs] (let [xs (remove-direct xs)]\n                                 (reduce (fn [acc x]\n                                           (let [facts (set (expand x))\n                                                 other (into #{} (mapcat expand (disj xs x)))]\n                                             (if (sub? facts other) acc (conj acc x))))\n                                         #{} xs)))\n            (support [xs x] (sub? (expand x) xs))]\n      (let [xs (set (mapcat expand xs))\n            ys (filter #(support xs %) (permute xx))]\n        (remove-unnec ys)))))", "user": "4ec0c7ba535dfed6da9c6da4"}, {"problem": 140, "code": "(fn [sos]\n  (letfn [(s->bv [s]\n            (vec\n              (for [[y n] '[[A a] [B b] [C c] [D d]]]\n                (cond\n                  (s y) 1\n                  (s n) 0))))\n\n          (bv->s [bv]\n            (set\n              (remove nil?\n                      (map #(case %1 1 (first %2) 0 (second %2) nil)\n                           bv\n                           '[[A a] [B b] [C c] [D d]]))))\n\n          (sos->bvs [sos]\n            (set\n              (map s->bv sos)))\n\n          (bvs->sos [bvs]\n            (set\n              (map bv->s bvs)))\n\n          (xor [a b]\n            (or (and a (not b))\n                (and b (not a))))\n\n          (match? [bv1 bv2]\n            (loop [bv1 bv1\n                   bv2 bv2\n                   mis false]\n              (if (empty? bv1)\n                true\n                (let [[v1 & r1] bv1\n                      [v2 & r2] bv2]\n                  (if (xor (= v1 '-) (= v2 '-))\n                    false\n                    (if (= v1 v2)\n                      (recur r1 r2 mis)\n                      (if mis\n                        false\n                        (recur r1 r2 true))))))))\n\n          (join [bv1 bv2]\n            (vec\n              (map #(if (= %1 %2) %1 '-) bv1 bv2)))\n\n          (joins [bvs]\n            (set\n              (let [n (count bvs)]\n                (for [i (range n)\n                      j (range n)\n                      :when (not= i j)\n                      :let [bv1 (nth (seq bvs) i)\n                            bv2 (nth (seq bvs) j)]\n                      :when (match? bv1 bv2)]\n                  (join bv1 bv2)))))\n\n          (covers? [joined bv]\n            (every?\n              (fn [[j b]]\n                (or (= '- j)\n                    (= j b)))\n              (map list joined bv)))\n\n          (only-cover [joined bv]\n            (when (= 1 (count (filter #(covers? % bv) joined)))\n              (first (filter #(covers? % bv) joined))))\n\n          (primes [bvs]\n            (let [levels (reverse (take (inc (count bvs))\n                                        (iterate joins bvs)))\n                  ordered (apply concat levels)]\n              (loop [acc []\n                     others ordered]\n                (if (empty? others)\n                  (set acc)\n                  (let [[f & r] others]\n                    (recur (conj acc f)\n                           (remove #(covers? f %) r)))))))\n\n          (minset [primes bvs]\n            (loop [ps primes\n                   bvs bvs\n                   acc #{}]\n              (if (empty? bvs)\n                acc\n                (if (empty? ps)\n                  (apply conj acc bvs)\n                  (let [p (or (some #(only-cover ps %) bvs)\n                              (first ps))]\n                    (recur (disj ps p)\n                           (apply disj bvs (filter #(covers? p %) bvs))\n                           (conj acc p)))))))]\n                \n    (let [bvs (sos->bvs sos)]\n      (bvs->sos (minset (primes bvs) bvs)))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 140, "code": "(fn soln [minterms]\n  (letfn [(bitcount [s]\n                (count (filter #{\\1} s)))\n\n          (b->s [i vars]\n                (if (pos? vars)\n                  (str (b->s (quot i 2) (dec vars))\n                       (if (even? i)\n                         \"0\"\n                         \"1\"))\n                  \"\"))\n\n          (mergeit [i j]\n                (first (reduce\n                         (fn [[s diff-cnt] [a b]]\n                           (if (nil? s)\n                             [nil nil]\n                             (if (and (or (= a \\X)\n                                          (= b \\X))\n                                      (not= a b))\n                               [nil nil]\n                               (if (not= a b)\n                                 (let [diff-cnt (inc diff-cnt)]\n                                   (if (> diff-cnt 1)\n                                     [nil nil]\n                                     [(str s \"X\") diff-cnt]))\n                                 [(str s a) diff-cnt]))))\n                         [\"\" 0]\n                         (map vector i j))))\n\n\n          (compute-primes [cubes vars]\n                (loop [sigma (for [v (range (inc vars))]\n                               (set (for [i cubes :when (= (bitcount i) v)]\n                                      i)))\n                       primes #{}]\n                  (if (seq sigma)\n                    (let [c1-c2-pairs (map vector (butlast sigma) (rest sigma))\n                          nsigma (for [[c1 c2] c1-c2-pairs]\n                                   (into #{} (for [a c1\n                                                   b c2 :let [m (mergeit a b)] :when m]\n                                               m)))\n                          redundant (into #{} (flatten (for [[c1 c2] c1-c2-pairs]\n                                                         (for [a c1\n                                                               b c2 :let [m (mergeit a b)] :when m]\n                                                           [a b]))))]\n                      (recur nsigma (apply disj (let [x (for [cubes sigma\n                                                              c cubes]\n                                                          c)]\n                                                  (if (seq x)\n                                                    (apply conj primes x)\n                                                    primes))\n                                           redundant)))\n                    primes)))\n\n          (active-primes [cubesel primes]\n                (for [[used prime] (map vector\n                                        (map (zipmap \"0123456789\" (range)) (b->s cubesel (count primes)))\n                                        primes) :when (= 1 used)]\n                  prime))\n\n          (is-cover? [prime one]\n                (apply = true (for [[p o] (map vector prime one)]\n                                (or (= p \\X)\n                                    (= p o)))))\n\n          (is-full-cover? [all-primes ones]\n                (apply = true (for [o ones]\n                                (some identity (for [p all-primes]\n                                                 (is-cover? p o))))))\n\n          (unate-cover [primes ones]\n                (let [primes (apply list primes)\n                      cs (second (first (sort (for [cubesel (range (bit-shift-left 1 (count primes)))\n                                                    :when (is-full-cover? (active-primes cubesel primes) ones)]\n                                                [(bitcount (b->s cubesel (count primes))) cubesel]))))]\n                  (active-primes cs primes)))\n\n          (solve [ones]\n                (comment \"Ones is a set like\" #{\"1100\" \"1001\" \"0110\" \"1101\" \"1010\" \"1110\" \"1000\" \"1011\"})\n                (unate-cover (compute-primes ones (count (first ones))) ones))\n\n          (minterm->one [minterm]\n                (str (if (contains? minterm 'a) \"0\" \"1\")\n                     (if (contains? minterm 'b) \"0\" \"1\")\n                     (if (contains? minterm 'c) \"0\" \"1\")\n                     (if (contains? minterm 'd)\n                       \"0\"\n                       (if (contains? minterm 'D)\n                         \"1\" \"\"))))\n\n          (cover->set [cover]\n                (set (remove nil? (map (fn [ndx]\n                                         (let [ch (nth cover ndx)]\n                                           (if (= ch \\1)\n                                             ({0 'A 1 'B 2 'C 3 'D} ndx)\n                                             (if (= ch \\0)\n                                               ({0 'a 1 'b 2 'c 3 'd} ndx)))))\n                                       (range (count cover))))))]\n\n    (set (map cover->set (solve (set (map minterm->one minterms)))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 140, "code": "(fn [algebra]\n  (letfn [(union [s1 s2]\n            (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n          (step [algebra]\n            (let [r (set (flatten (map\n                                    (fn [line]\n                                      (let [m (map\n                                                #(set (conj\n                                                        (remove #{%} line)\n                                                        (case (str %)\n                                                          \"a\" 'A\n                                                          \"A\" 'a\n                                                          \"b\" 'B\n                                                          \"B\" 'b\n                                                          \"c\" 'C\n                                                          \"C\" 'c\n                                                          \"d\" 'D\n                                                          \"D\" 'd)))\n                                                line)\n                                            s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                        (if (seq s) s line)))\n                                    algebra)))]\n              (if (not= r algebra) (step r) algebra)))\n          (power-set [s]\n            (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))]\n    (let [ps (power-set (step algebra))]\n      (apply\n        (partial min-key count)\n        (filter\n          (complement nil?)\n          (map\n            (fn [s]\n              (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) algebra)) s))]\n                (if (= r algebra) s))\n              )\n            ps))))))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": 140, "code": "(fn final-bool [sets]\n  (letfn [(cmpr [s1 s2]\n            (let [d1 (clojure.set/difference s1 s2)\n                  d2 (clojure.set/difference s2 s1)\n                  c1 (count d1)\n                  c2 (count d2)\n                  i (clojure.set/intersection s1 s2)]\n              (if (and (not= s1 s2)\n                       (<= (+ c1 c2) 2)\n                       (or\n                        (= (* c1 c2) 0)\n                        (= (clojure.string/lower-case (first d1))\n                           (clojure.string/lower-case (first d2)))))\n                i)))\n          (rpl [s seq-sets]\n            (or (not-empty (keep identity\n                                 (map #(cmpr s %) seq-sets)))\n                (list s)))\n          (rdc [seq-sets]\n            (distinct (mapcat #(rpl % seq-sets) seq-sets)))\n          (fnl [sets]\n            (let [s (seq sets)\n                  r (rdc s)]\n              (if (= s r)\n                (set r)\n                (fnl r))))\n          (overlap [sets]\n            (first (or (not-empty\n                        (filter identity (for [s sets\n                                               :let [r-sets (apply clojure.set/union (disj sets s))]]\n                                           (if (= (clojure.set/intersection s r-sets) s)\n                                             (disj sets s)))))\n                       [sets])))]\n    (let [f (fnl sets)]\n      (if (not= (count (first sets)) (count (first f)))\n        (overlap f)\n        f))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 140, "code": "(fn k-map [s]\n  ;; \u041c\u0435\u0442\u043e\u0434 \u041a\u0432\u0430\u0439\u043d\u0430\n  ;; NOT OPTIMIZED VARIANT\n  ;; http://ptca.narod.ru/lec/lec4_1.html\n  ;; \n  (letfn [(is-eq-symbol? [a b] (->> [a b] (map clojure.string/upper-case) set count (= 1)))\n          (impl [s1 s2]\n            (let [c1 (clojure.set/difference s1 s2)\n                  c2 (clojure.set/difference s2 s1)]\n              (if (and (= 1 (count c1) (count c2))\n                       (is-eq-symbol? (first c1) (first c2)))\n                (clojure.set/intersection s1 s2)\n                #{})))]\n    (let [cds1 (-> s first count dec)\n          step1 (set (for [si s sj s\n                           :let [u (impl si sj)]\n                           :when (= (count u) cds1)]\n                       u))\n          cds2 (dec cds1)\n          [ts1 ts2] (->> (for [si step1 sj step1\n                               :let [u (impl si sj)]\n                               :when (= (count u) cds2)]\n                           [u #{si sj}])\n                         set\n                         (reduce (fn [[a1 a2] [k v]]\n                                   [(conj a1 k) (reduce conj a2 v)])\n                                 [#{} #{}]))\n          step2 (clojure.set/union ts1 (clojure.set/difference step1 ts2))\n          tab (->> step2\n                   (reduce (fn [a st]\n                             (reduce (fn [a i]\n                                       (if (clojure.set/subset? st i)\n                                         (update-in a [st] #(conj % i)) a))\n                                     a s))\n                           (zipmap step2 (repeat (count step2) #{})))\n                   vec)\n          tab (filter (fn [[x y]]\n                        (->> tab\n                             (filter #(-> % first (not= x)))\n                             (map second)\n                             (into [y])\n                             (apply clojure.set/difference)\n                             empty?\n                             not)) tab)\n          ignored (->> tab\n                       (reduce #(-> %2 second (clojure.set/union %1)) #{})\n                       (clojure.set/difference s))\n          ]\n      (println ignored)\n      (loop [a #{} tab tab]\n        (let [[[x sy] & r] (sort-by (comp count second) > tab)\n              a (conj a x)]\n          (if (empty? r) (disj (clojure.set/union a ignored) nil)\n              (recur a (map (fn [[x y]] [x (clojure.set/difference y sy)]) r))\n              )))\n      )))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 140, "code": "(fn [s]\n  (let [g #(-> % first str .toUpperCase)\n        n (for [x s y s :while (not= x y)]\n            (let [i (clojure.set/intersection x y)\n                  a (clojure.set/difference x i)\n                  b (clojure.set/difference y i)]\n              (if (and (= 1 (count a) (count b))\n                       (= (g a) (g b)))\n                [i #{x y}])))\n        sn (->> n (map first) (filter #(not= nil %)) set)\n        sx (->> n (map last) (apply clojure.set/union))]\n    (if (empty? sn)\n      (disj s #{'A 'd})\n      (recur (clojure.set/union sn (clojure.set/difference s sx))))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 140, "code": "(fn [f]\n  ; I am not sure if it is a real implementation of the Quine\u2013McCluskey algorithm but it seems to work in those cases\n  (let [sps? clojure.set/superset? uni clojure.set/union\n        ; helper function to get the first non nil result of a function over a coll\n        fike (fn [p c] (first (keep p c)))\n        ; this is a dirty function to get the opposite state of an input (e.g. 'a => 'A) \n        mnot (fn [s]\n               (let [iz (int \\z) ia (int \\a) iA (int \\A) dl (- ia iA) ic (int (first (name s)))]\n                 (symbol (str (char (if (<= ia ic iz) (- ic dl) (+ ic dl)))))))\n        ; function to toggle a single input of a set\n        nis (fn [s i] (conj (disj s i) (mnot i)))\n        ; simplification 1 : if sa and sb differ only by a toggled input, we simplify to only one set of input\n        ; e.g. #{'A 'B} #{'A 'b} => #{'A}\n        sym1 (fn [sa sb] (fike (fn [i] (let [nsa (nis sa i)] (when (= nsa sb) #{(disj sa i)}))) sa))\n        ; simplification 2 : if sa with one input toggled is a superset of sb, we simplify\n        ; e.g. #{'A 'B 'c} #{'a 'c} => #{'B 'c} #{'a 'c}\n        sym2 (fn [sa sb] (fike (fn [i] (let [nsa (nis sa i)] (when (sps? nsa sb) #{(disj sa i) sb}))) sa))\n        ; this try to apply the supplied simplification to every combination of sets possible\n        ; if a simplification is found, output the new simplified algebra function\n        ssym (fn [sym] (fn [f]\n                         (fike (fn [sa] (fike (fn [sb] (when-let [r (sym sa sb)]\n                                                         (uni (disj f sa sb) r))) (disj f sa))) f)))\n        ; apply a function until the output is nil, keep the last non-nil\n        linn (fn [fun start] (last (take-while identity (iterate fun start))))]\n    ; we simplify with sym1 then with sym2 until there is no simplification left\n    (linn (ssym sym2) (linn (ssym sym1) f))\n    )\n  )", "user": "53e745a1e4b036ad0777e479"}, {"problem": 140, "code": "(fn [f]\n  (let [all (->> f (apply clojure.set/union) (map clojure.string/lower-case) (into #{}))\n        add (fn [x res]\n              (if (and (set? x)\n                       (-> x (clojure.set/intersection res) seq))\n                #{res}\n                (map (partial conj res) x)))\n        cart (fn ! [[x & xs :as all]]\n               (if (empty? all)\n                 '(#{})\n                 (mapcat (partial add x) (! xs))))\n        possible #(let [u (-> % clojure.string/upper-case symbol)\n                        l (-> % clojure.string/lower-case symbol)]\n                    [u l [u l]])\n        cand #(let [c (->> % (filter (complement vector?)) set)\n                    child (partial into c)\n                    v (->> % (filter vector?) cart (map child) set)]\n                [c (if (-> v count pos?) v #{c})])\n        good? (fn [[_ ch]] (clojure.set/subset? ch f))\n        cands (->> all (map possible) cart (map cand) (filter good?))\n        cands-for #(->> cands (filter (fn [[_ ch]] (ch %))) (map first) set)\n        size #(apply + (map count %))]\n    (->> f (map cands-for) (sort-by count) cart (sort-by size) first)))", "user": "514c2d05e4b02b8cbb2a9278"}, {"problem": 140, "code": "(fn p1 [exps]\n  (let [c (fn c [[s1 s2]]\n            (let [x (clojure.set/difference s1 s2)\n                  y (clojure.set/difference s2 s1)]\n              (if (and (= (count x) 1)\n                       (= (clojure.string/upper-case x)\n                          (clojure.string/upper-case y)))\n                [(clojure.set/intersection s1 s2) s1 s2])))\n          s (fn s [[exps ys]]\n            (let [r (keep c (loop [exps exps r []]\n                              (if (empty? exps) r\n                                (recur (rest exps)\n                                       (concat r\n                                               (map #(list (first exps) %)\n                                                    (rest exps)))))))\n                  x (set (map first r))\n                  y (reduce #(disj % (second %2) (nth %2 2)) exps r)]\n              [x (clojure.set/union ys y)]))]\n    (let [ts (apply clojure.set/union (last (take-while #(not (empty? (first %))) (iterate s [exps #{}]))))]\n      (set (map first (filter #(= (count %) 1) (map (fn [x] (filter #(clojure.set/subset? % x) ts)) exps)))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 140, "code": "(fn veitch [m]\r\n  (let [shapes\r\n            (set (conj\r\n              (for [rm [2 1] rc [4 2] f [identity (fn[[a b]] [b a])]]\r\n                (set (for [r (range rm) c (range rc)] (f [r c])))) #{[0 0]}))]\r\n\r\n  (letfn [(complete [m]\r\n            (set (mapcat\r\n              #(if (some (partial contains? %) ['d 'D]) [%]\r\n                [(conj % 'd)(conj % 'D)])\r\n              m)))\r\n                \r\n          (draw [m]\r\n            (let [w '{a 8 b 4 c 2 d 1}\r\n                  pos [0 4 1 5 12 8 13 9 3 7 2 6 15 11 14 10]]\r\n              (vec (map vec (partition 4\r\n              (reduce\r\n                #(assoc %1 (pos %2) 1)\r\n                (vec (repeat 16 0))\r\n                (map (fn [s] (reduce #(+ %1 (get w %2 0)) 0 s)) (complete m))))))))\r\n\r\n          (solution [m]\r\n            (set (filter identity\r\n              (for [r (range 4) c (range 4)]\r\n                (when (= 1 (get-in m [r c])) [r c])))))\r\n\r\n          (get-tor [m [r c]] (get-in m [(mod r 4) (mod c 4)]))\r\n          \r\n          (find-shape [m vs]\r\n            (let [[rr rc] (map #(range ({0 4, 1 4, 3 1} %))(apply map max vs))]\r\n              (filter identity\r\n                (for [r rr c rc]\r\n                  (when (every? #(= 1 %) \r\n                          (map\r\n                            #(get-tor m %)\r\n                            (map #(map + [r c] %) vs)))\r\n                    [r c])))))\r\n          \r\n          (blocks [m]\r\n            (letfn [(addmod4 [a b] (mod (+ a b) 4))\r\n                    (addvec [m v] (map #(mapv addmod4 % v) m))]\r\n              (mapcat \r\n                (fn [s] (map\r\n                          #(set (addvec s %))\r\n                          (find-shape m s)))\r\n                shapes)))\r\n          \r\n          (block-comb [m]\r\n            (letfn [(k-comb [n s]\r\n                      (loop [k n, r #{#{}}]\r\n                        (if (< k 1)\r\n                          r\r\n                          (recur \r\n                            (dec k)\r\n                            (set (filter (comp not nil?)\r\n                                (for [x r y s]\r\n                                  (if (contains? x y) nil (conj x y)))))))))\r\n                    (combi [[a & r]]\r\n                      (if a\r\n                        (mapcat\r\n                          (fn [k] \r\n                            (for [x (combi r) y (k-comb k a)]\r\n                              (concat x y)))\r\n                          (range 1 (inc (count a))))\r\n                        [[]]))\r\n                    (uniq-blocks [a b] (filter (fn [sb] (every? #(not (clojure.set/subset? sb %)) b)) a))]\r\n              (let [gb  (reduce \r\n                          (fn [r [k v]] \r\n                            (#(if (empty? %) r (assoc r k %))(uniq-blocks v (apply clojure.set/union (vals r)))))\r\n                          {}\r\n                          (group-by count (reverse (sort-by count (blocks m)))))]\r\n              (combi (vals gb)))))\r\n          \r\n          (comb-symb [c]\r\n            (letfn [(block-code [[r c]] (#(+ (* 4 (% c)) (% r)) [34 33 17 18])) \r\n                    (fours [x] (if (> x 0) (conj (fours (quot x 4)) (mod x 4)) []))]\r\n              (filter (comp not empty?)\r\n              (reduce\r\n                (fn [[m r] a]\r\n                  [ (vec (drop 2 m)) \r\n                    (if (= a 3) r (conj r (m (dec a)))) ])\r\n                ['[a A b B c C d D][]]\r\n                (fours (apply bit-or (conj (map block-code c) 0)))))))]\r\n\r\n  (set (map set \r\n    (mapcat\r\n      comb-symb\r\n      (first (filter\r\n          #(= (solution (draw m)) (apply clojure.set/union %))\r\n          (block-comb (draw m))))))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 140, "code": "; \"augh\" is right.\n(fn karnaugh [set-of-sets]\n  (letfn\n      [(l2d [s]\n         (mapv #(if (Character/isUpperCase (first (name %))) 1 0)\n               (sort-by clojure.string/upper-case (apply list s))))\n       (d2l [s]\n         (map symbol\n              (mapv\n               #(if (= %1 1) (.toUpperCase %2) (.toLowerCase %2))\n               s (take (count s) (map str '[A B C D])))))\n       (adjacent? [v1 v2]\n         (= 1 (count (filter #(not (zero? %)) (map - v1 v2)))))\n       ; sets are k-mergeable if, for some n:\n       ; * the cardinality of their union is 2^n, and\n       ; * each element of the union has n adjacent elements\n       (k-mergeable? [& sets]\n         (let [u (apply clojure.set/union sets)]\n           (some\n            (fn [p2]\n              (and\n               (= (count u) (apply * (repeat p2 2)))\n               (apply = p2 (map (fn [v] (count (filter #(adjacent? % v) u))) u))))\n            (range 1 (count u)))))\n       (k-merge [ss]\n         (mapcat\n          (fn [s]\n            (let [m (filter #(and (not (= s %)) (k-mergeable? s %)) ss)]\n              (if (empty? m) (list s)\n                  (map #(clojure.set/union s %) m))))\n            ss))\n       (common-letters [s]\n         (apply clojure.set/intersection (map #(set (d2l %)) s)))\n       (redundant? [s ss]\n         (clojure.set/subset? s (apply clojure.set/union (disj ss s))))]\n    (loop [ss0 (map hash-set (map l2d set-of-sets))]\n      (let [ss1 (set (distinct (k-merge ss0)))]\n        (if (not (= ss0 ss1))\n          (recur ss1)\n          (set (map common-letters (remove #(redundant? % ss1) ss1))))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 140, "code": "(fn p140 [minterms] ; https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm\n  (letfn [(combine [x y]\n                   (let [s (clojure.set/difference x y)\n                         t (clojure.set/difference y x)]\n                     (when (and (= 1 (count s))\n                                (= 1 (count t))\n                                (= (clojure.string/upper-case (str (first s)))\n                                   (clojure.string/upper-case (str (first t)))))\n                       (clojure.set/intersection x y))))\n          (find-primes [candidates prime-implicants]\n                (if (empty? candidates) prime-implicants\n                  (loop [xs candidates\n                         implicants #{}\n                         ps prime-implicants]\n                    (if (empty? xs) (find-primes implicants ps)\n                      (let [x (first xs)]\n                        (let [zs (remove empty?\n                                         (for [y candidates :when (not= x y)]\n                                           (combine x y)))]\n                          (if (empty? zs)\n                            (recur (rest xs) implicants (conj ps x))\n                            (recur (rest xs) (into implicants zs) ps))))))))\n          (covers? [prime minterm] (= prime (clojure.set/intersection prime minterm)))\n          (essential? [prime primes minterms]\n                      (true? (some true?\n                                   (map (fn [minterm]\n                                          (= 1 (count (filter #(covers? % minterm) primes))))\n                                        (filter #(covers? prime %) minterms)))))\n          (minimize-primes [not-covered primes used-primes]\n                           (if (empty? not-covered) used-primes\n                             (let [essential (first (filter #(essential? % primes not-covered) primes))]\n                               (recur (remove #(covers? essential %) not-covered)\n                                      (disj primes essential)\n                                      (conj used-primes essential)))))]\n    (minimize-primes minterms (find-primes minterms #{}) #{})))", "user": "54c271b9e4b045293a27f602"}, {"problem": 140, "code": "(fn [ors]\n  \n  ; need to use table method to find all prime implicants  \n  ; (including essential prime implicants)\n  ; then use Petrick's method to find the minimal combination(s)\n  \n  (letfn [(negate [x] ({'A 'a 'a 'A 'B 'b 'b 'B 'C 'c 'c 'C 'D 'd 'd 'D} x))\n          \n          (make-true [x] ({'A 'A 'a 'A 'B 'B 'b 'B 'C 'C 'c 'C 'D 'D 'd 'D} x))\n          \n          (cart [colls]\n                (if (empty? colls)\n                  '(())\n                  (for [x (first colls)\n                        more (cart (rest colls))]\n                    (cons x more))))\n          \n          ; powerset excluding empty set \n          (powerset [ls]\n                    (if (empty? ls) '(())\n                      (let [x (powerset (next ls))]\n                        (clojure.set/union x\n                                           (map #(conj % (first ls)) x)))))\n          \n          ; all syms \n          (get-symbols [] (distinct (map make-true (apply clojure.set/union ors))))\n          \n          ; 2^n possibilities for myset \n          (get-allpos [myset]\n                      (if (empty? myset) '()\n                        (let [pairs (map (fn [s] [s (negate s)]) myset)]\n                          (cart pairs))))\n          \n          ; 2^n possibilities for all subset\n          (really-allpos []\n                         (let [syms (get-symbols)\n                               psyms (powerset syms)\n                               everything (map get-allpos psyms)]\n                           (apply concat everything)))\n          \n          ; all bits \n          (full-set [] (get-allpos (get-symbols)))\n          \n          ; bits that should be false\n          (negate-set [] (clojure.set/difference (set (map set (set (full-set)))) ors))\n          \n          ; check if term is valid, i.e., not containing anything in n-set \n          (is-valid [n-set term]\n                    (not (some (partial clojure.set/subset? term) n-set))) \n          \n          ; prime implicators, we use a brute force way to get them \n          (valids [] \n                  (let [xvalids (filter (partial is-valid (negate-set)) (really-allpos))]\n                    (set (map set (set xvalids)))))\n          \n          ; give a list of sets, return the essential sublist \n          (essentialization [los] \n                            (filter #(not (some \n                                                (fn [superset] \n                                                  (and (not= superset %)\n                                                       (clojure.set/subset? superset %)))\n                                                los)) los)\n                            )\n          \n          ; essential prime implicators \n          (epi [] (essentialization (valids)))\n               \n          ; miniterm to epi map, if some miniterm only maps to one epi,\n          ; then that epi should be included \n          (mt-to-epi-map [mt myepi]\n                         (let [out (map #(filter (fn [xepi] \n                                                   (clojure.set/subset? xepi %))\n                                                 myepi)\n                                        mt)]\n                           (into {} (map vector mt out))))\n          \n          ; petrick's method\n          ; http://en.wikipedia.org/wiki/Petrick%27s_method\n          ; mem: miniterm-to-epi-map \n          (petrick [mem]\n                   (let [maps (vals mem)\n                         posses (map set (distinct (map distinct (cart maps))))\n                         reduction (essentialization posses)\n                         nterms (map count reduction)\n                         min-nterms (reduce min nterms)\n                         min-terms (filter #(= min-nterms (count %)) reduction)]\n                     (first min-terms)))]\n    \n    (petrick (mt-to-epi-map ors (epi)))\n    \n    ))", "user": "52faec2ee4b047fd55837004"}, {"problem": 140, "code": "(fn [logic]\n   (let [shapes (for [x [1 2 4] y [1 2 4]]\n                  (for [a (range x) b (range y)]\n                    [a b]))\n         xring [:ab :aB :AB :Ab]\n         yring [:cd :cD :CD :Cd]]\n     (letfn [(fn->coords [ss]\n               {:post [(= 2 (count %))\n                       ((set xring) (first %))\n                       ((set yring) (second %))]}\n               (map\n                #(keyword (apply str %))\n                (partition 2 (sort-by #(.toUpperCase (name %)) ss))))\n\n             (normalize-sets [sss]\n               (reduce (fn [acc e]\n                         (mapcat\n                          (fn [as]\n                            (if (contains? (set (map (comp #(.toUpperCase %) name) as))\n                                           (name e))\n                              #{as}\n                              #{(conj as e)\n                                (conj as (symbol (.toLowerCase (name e))))}\n                              ))\n                          acc))\n                       sss\n                       ['A 'B 'C 'D]))\n\n             (fns->matrix [sss]\n               (reduce (fn [m ss] (assoc-in m (fn->coords ss) 1)) {} sss ))\n\n             (apply-shape [matrix shape [x0 y0 :as coords]]\n               (let [xring-offset (drop-while #(not= x0 %) (cycle xring))\n                     yring-offset (drop-while #(not= y0 %) (cycle yring))]\n                 (map\n                  (fn [[x y]] [(nth xring-offset x) (nth yring-offset y)])\n                  shape)))\n\n             (box-vals [matrix shape]\n               (map #(get-in matrix %) shape))\n\n             (find-boxes [matrix shapes]\n               (reverse\n                (sort-by count\n                         (into #{}\n                               (for [x xring\n                                     y yring\n                                     s shapes\n                                     :let [box (apply-shape matrix s [x y])]\n                                     :when (every? #(= 1 %) (box-vals matrix box))]\n                                 (sort box))))))\n\n             (contains-box? [region box]\n               (clojure.set/subset? (set box) (set region)))\n\n             (remove-overlapped [boxes]\n               (let [boxes (sort-by count boxes)]\n                 (for [box boxes\n                       :let [bigger-boxes (drop-while #(<= (count %) (count box)) boxes)]\n                       :when (not-any? #(contains-box? % box) bigger-boxes)]\n                   box)))\n\n             (covered-region [matrix]\n               (into #{}\n                     (filter identity (for [x xring y yring]\n                                        (if (get-in matrix [x y]) [x y])))))\n\n             (full-coverage? [boxes region]\n               (= (into #{} (apply concat boxes)) region))\n\n             (power-set [xs]\n               (reduce (fn [acc x]\n                         (into acc (map\n                                    (fn [as] (conj as x))\n                                    acc)))\n                       #{#{}}\n                       xs))\n\n             (box->fn [box]\n               (into #{}\n                     (map (comp symbol str)\n                          (apply clojure.set/intersection\n                                 (map\n                                  #(set (concat (name (first %)) (name (second %))))\n                                  box)))))\n\n             (boxes->fns [boxes]\n               (into #{}\n                     (map box->fn boxes)))\n\n             (solve [sss]\n               (let [matrix (fns->matrix (normalize-sets sss))\n                     region (covered-region matrix)\n                     ps (power-set (remove-overlapped (find-boxes matrix shapes)))\n                     solution (first (sort-by count\n                                              (filter #(full-coverage? % region) ps)))]\n                 (boxes->fns solution)))\n             ]\n       (solve logic))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 140, "code": "(fn [minterms]\n  (let [\n        inputs (take (count (first minterms)) ['A 'B 'C 'D])\n        negation {'A 'a 'B 'b 'C 'c 'D 'd}\n        get-k-combos (fn get-k-combos [k s]\n                       (cond\n                        (or (= k 0) (> k (count s))) '()\n                        (= k 1) (map list s)\n                        :else (clojure.set/union\n                               (map #(conj % (first s)) (get-k-combos (dec k) (rest s)))\n                               (get-k-combos k (rest s)))))\n        all-+ve-combos (mapcat #(get-k-combos % inputs) (range 1 (inc (count inputs))))\n        get--ve-combos (fn get--ve-combos [[head & tail]]\n                         (if (empty? tail)\n                           [[head] [(negation head)]]\n                           (let [tail (get--ve-combos tail)]\n                             (concat\n                              (map #(conj % head) tail)\n                              (map #(conj % (negation head)) tail)))))\n        all-combos (map set (mapcat get--ve-combos all-+ve-combos))\n        all-full-combos (map set (get--ve-combos inputs))\n        get-implied-full-combos (fn [sub]\n                                  (set (filter #(clojure.set/subset? sub %) all-full-combos)))\n        test-combo (fn [so-far candidate]\n                     ; all implied combos are in minterms\n                     (if (clojure.set/subset? (get-implied-full-combos candidate) minterms)\n                       (conj so-far candidate)\n                       so-far))]\n    (loop [[candidate & remaining] (reverse (reduce test-combo [] all-combos))\n           accepted []]\n      (if (nil? candidate) (set accepted)\n        (let [covered (apply clojure.set/union \n                             (map get-implied-full-combos (concat accepted remaining)))\n              required (not (clojure.set/subset? (get-implied-full-combos candidate) covered))]\n          (recur remaining (if required (conj accepted candidate) accepted)))))\n    ))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 140, "code": "(fn [eqs]\n  (let\n    [notmap (#(reduce (fn [m [k v]] (assoc m v k)) % %)\n                      '{a A b B c C d D})\n     oneoff? #(let [a (apply disj %1 %2) b (apply disj %2 %1)]\n                (when (and (= 1 (count a) (count b)) (= (notmap (first a)) (first b)))\n                  (disj %1 (first a))))\n     combine (fn [sets]\n               (loop [s (seq sets) out sets]\n                 (if (empty? s) out\n                   (recur\n                     (rest s)\n                     (let [s1 (first s)]\n                       (reduce\n                         #(if-let [c (oneoff? s1 %2)] (conj (disj %1 s1 %2) c)\n                            %1)\n                         out (rest s)))))))\n     converge (fn [f v] (let [nv (f v)] (if (= v nv) nv (recur f nv))))\n     covers? (fn [sets]\n               (every? (fn [s] (some #(empty? (apply disj % s)) sets)) eqs))\n     minimize (fn [sets]\n                (let [covering-sets (for [s (seq sets)\n                                          :let [sets-s (disj sets s)]\n                                          :when (covers? sets-s)]\n                                      sets-s)]\n                  (case (count covering-sets)\n                    0 sets\n                    1 (first covering-sets)\n                    (apply min-key count covering-sets))))]\n    (minimize (converge combine eqs))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 140, "code": "(fn [f]\n  (let [vs (map (comp symbol clojure.string/upper-case str) (first f))\n        neg (into {} (for [v vs] [v (-> v str clojure.string/lower-case symbol)]))\n        negate-in (fn [m v] (conj (disj m v) (neg v)))\n        pick (fn [s] (for [m s v m :when (s (negate-in m v))] [m v]))\n        fold (fn [s [m v]] (conj (disj s m (negate-in m v)) (disj m v)))\n        folded\n        (loop [s f]\n          (let [ms (pick s)] (if (empty? ms) s (recur (reduce fold s ms)))))\n        handled? (fn [s m] (some #(clojure.set/subset? % m) s))\n        cull (fn [s m] (if (every? #(handled? (disj s m) %) f) m))]\n    (loop [ans folded]\n      (let [c (some #(cull ans %) ans)] (if c (recur (disj ans c)) ans)))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 140, "code": "(fn [ruleSet]\n  (let [negate {'A 'a 'a 'A 'B 'b 'b 'B 'C 'c 'c 'C 'D 'd 'd 'D}\n        simplifyRules (fn [rules];this function has nested loops\n                        (loop [results #{} remaining rules] ;first loop\n                          (if-let [ruleX (first remaining)] ;for each rule in the input\n                            (let [simplifiedRuleSet (loop [matchedRules #{}, remainingToMatch (rest remaining)];try to simplify the ruleX\n                                                      (if-let [ruleY (first remainingToMatch)];to to match against each remaining rule\n                                                        (let [symbolInX (clojure.set/difference ruleX ruleY) symbolInY (clojure.set/difference ruleY ruleX)];ruleX can be simplified\n                                                          (if (and (= 1 (count symbolInX) (count symbolInY)) (= (negate (first symbolInX)) (first symbolInY)));iff their difference is negation\n                                                            [(clojure.set/difference ruleX symbolInX) (concat matchedRules (rest remainingToMatch))];remove the negated term and remove the matched rule\n                                                            (recur (conj matchedRules ruleY) (rest remainingToMatch))));or continue the loop\n                                                        [ruleX matchedRules]))];the ruleX cannot be simplified\n                              (recur (conj results (first simplifiedRuleSet)) (second simplifiedRuleSet)));continue the outter loop\n                            results)));return the result\n        simplifyTerms (fn [rules];this function also has nested loops\n                        (loop [results #{} remaining rules];first loop\n                          (if-let [ruleX (first remaining)];for each rule\n                            (let [simplifiedRuleX (loop [remainingToMatch rules];try to remove one term from ruleX\n                                                    (if-let [ruleY (first remainingToMatch)]\n                                                      (let [symbolInY (clojure.set/difference ruleY ruleX)];if ruleY has fewer terms and contain the negation term in ruleX\n                                                        (if (and (< (count ruleY) (count ruleX))(= 1 (count symbolInY)) (contains? ruleX (negate (first symbolInY))))\n                                                          (disj ruleX (negate (first symbolInY)));then remove that term\n                                                          (recur (rest remainingToMatch))));continue the inner loop\n                                                      ruleX))]\n                              (recur (conj results simplifiedRuleX) (rest remaining)));for each rule, return the simplified rule\n                            results)))]\n    (loop [rules ruleSet]\n      (let [simplifiedRules (simplifyRules rules)];try to remove rules\n        (if (= simplifiedRules rules);if no more rule can be removed\n          (simplifyTerms simplifiedRules);return the rules with trimmed terms\n          (recur simplifiedRules))))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 140, "code": "(fn [original-terms]\r\n  (let [\r\n    width (count (first original-terms))\r\n    zip (fn [seq1 seq2] (map list seq1 seq2))\r\n    subset? (fn [a b] (every? #(contains? b %) a))\r\n    bin-dec (fn [t] (reduce #(+ (* 2 %1) %2) 0 t))\r\n    symb (fn [n] (symbol (str (char n))))\r\n    zero (fn [i] (symb (+ (int \\a) i)))\r\n    one (fn [i] (symb (+ (int \\A) i)))\r\n    upper-case? (fn [s]\r\n      (= s (clojure.string/upper-case s)))\r\n    symb-not (fn [symb]\r\n      (let [s (str symb)]\r\n        (if (upper-case? s)\r\n          (symbol (clojure.string/lower-case s))\r\n          (symbol (clojure.string/upper-case s)))))\r\n    prod (fn prod [[head & tail]]\r\n      (if (nil? head)\r\n        '(())\r\n        (for [x head, more (prod tail)]\r\n          (cons x more))))\r\n    term-bit (fn [term i]\r\n      (let [\r\n        key-zero (contains? term (zero i))\r\n        key-one (contains? term (one i))\r\n        convert {\r\n          [true  false] [0]\r\n          [false true ] [1]\r\n          [false false] [0 1]}]\r\n        (convert [key-zero key-one])))\r\n    term-bits (fn [term]\r\n      (map #(term-bit term %) (range width)))\r\n    bits-dec (fn [bits]\r\n      (map bin-dec (prod bits)))\r\n    term-dec (fn [term]\r\n      (bits-dec (term-bits term)))\r\n    coverage (fn [terms]\r\n      (->> terms\r\n        (map term-bits)\r\n        (map bits-dec)\r\n        (apply concat)\r\n        (set)))\r\n    original-cover (coverage original-terms)\r\n    primaries (map one (range width))\r\n    comb (fn comb [n items]\r\n      (if (> n (count items))\r\n        '()\r\n      (if (zero? n)\r\n        '(())\r\n      (if (= n 1)\r\n        (map vector items)\r\n        (let [[head & tail] items]\r\n          (concat\r\n            (map #(cons head %) (comb (dec n) tail))\r\n            (comb n tail)))))))\r\n    dec-bin (fn [num places]\r\n      (loop [num num, places places, result '()]\r\n        (if (<= places 0)\r\n          result\r\n          (let [a (int (/ num 2)), b (pos? (mod num 2))]\r\n            (recur a (dec places) (cons b result))))))\r\n    term-variants (fn [term]\r\n      (let [\r\n        pow (fn [x p] (nth (iterate #(* x %) 1) p))\r\n        term-variant (fn [term bits]\r\n          (map (fn [[a b]] (if a b (symb-not b)))\r\n            (zip bits term)))\r\n        n (count term)]\r\n        (->> (range (pow 2 n))\r\n          (map #(dec-bin % n))\r\n          (map #(term-variant term %)))))\r\n    all-terms\r\n      (->> (range 1 width)\r\n        (map #(comb % primaries))\r\n        (apply concat)\r\n        (map term-variants)\r\n        (apply concat)\r\n        (map set))\r\n    all-terms-cover\r\n      (map\r\n        #(-> {:term % :cover (set (term-dec %))})\r\n        all-terms)\r\n    subset-terms\r\n      (filter\r\n        #(subset? (:cover %) original-cover)\r\n        all-terms-cover)\r\n    merge-terms (fn [coll]\r\n      {:terms (set (map :term coll))\r\n       :cover (set (apply concat (map :cover coll)))})\r\n    combined-subsets\r\n      (->>\r\n        (range 1 (inc (count subset-terms)))\r\n        (map #(comb % subset-terms))\r\n        (apply concat)\r\n        (map merge-terms))\r\n    solution\r\n     (first\r\n       (filter\r\n         #(= (:cover %) original-cover)\r\n         combined-subsets))]\r\n    (if (nil? solution)\r\n      original-terms\r\n      (:terms solution))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 140, "code": "(fn veitch [ms]\n  (let [miniterm_to_int (fn [m]\n                          (let [to_int_4 #(cond (= %1 'A) 8\n                                                (= %1 'B) 4\n                                                (= %1 'C) 2\n                                                (= %1 'D) 1\n                                                :else 0)\n                                to_int_3 #(cond (= %1 'A) 4\n                                                (= %1 'B) 2\n                                                (= %1 'C) 1\n                                                :else 0)]\n                            (if (= 4 (count m))\n                              (apply + (map to_int_4 m))\n                              (apply + (map to_int_3 m)))))\n        miniterm_len (count (first ms))\n        swap (fn [v i1 i2] (assoc v i2 (v i1) i1 (v i2)))\n        transpose (fn [m] (apply mapv vector m))\n        ones (set (map miniterm_to_int ms))\n        tmp_matrix (let [values (map #(if (ones %1) 1 0) (range (Math/pow 2 miniterm_len)))]\n                     (if (= miniterm_len 4)\n                       (transpose (partition 4 values))\n                       [(take-nth 2 values) (take-nth 2 (rest values))]))\n        matrix (if (= miniterm_len 4)\n                 (swap (vec (map #(swap (vec %1) 2 3) tmp_matrix)) 2 3)\n                 (vec (map #(swap (vec %1) 2 3) tmp_matrix)))\n        one_positions (set (for [[row r-val] (map-indexed vector matrix)\n                                 [column c-val] (map-indexed vector r-val) :when (= 1 c-val)]\n                             [row column]))\n        compute_rectangles (fn [position]\n                             (let [len (inc (count matrix))\n                                   ranges (for [x (range 1 len) y (range 1 len) \n                                                :when (or (and (even? x) (even? y)) \n                                                          (and (= x 1) (even? y)) \n                                                          (and (= y 1) (even? x)))] \n                                            [x y])\n                                   compute_rectange_elements (fn [[x y]]\n                                                               (for [x1 (range x) y1 (range y)]\n                                                                 [x1 y1]))\n                                   rectangle_elements (map compute_rectange_elements ranges)]\n                               (conj (for [x rectangle_elements] (map #(map + position %) x))\n                                     [position])))\n        filter_rectangles (fn [rectangles]\n                            (let [temp1 (map (fn [x] (filter #(every? one_positions %) x)) rectangles)\n                                  temp2 (map #(reduce (fn [x y] (if (> (count x) (count y)) x y)) [] %) temp1)\n                                  temp3 (set (map set temp2))\n                                  temp4 (set (for [t temp3 :when (every? (fn [x] (not (clojure.set/subset? t x))) (disj temp3 t))] t))]\n                              (for [t temp4 :when (not (every? identity (let [s (disj temp4 t)]\n                                                                          (map (fn [t1] (some #(% t1) s)) t))))] t)))\n                              ;(for [t temp3 :when (every? (fn [x] (not (clojure.set/subset? t x))) (disj temp3 t))] t)))\n        get_rectangles (let [rectangles (set (filter_rectangles (map compute_rectangles one_positions)))\n                             s (if (and (one_positions [0 1]) (one_positions [0 2])\n                                        (one_positions [3 1]) (one_positions [3 2]))\n                                  (conj (disj (disj rectangles #{[0 1] [0 2]}) #{[3 1] [3 2]})\n                                        #{[0 1] [0 2] [3 1] [3 2]})\n                                  rectangles)\n                             t (if (and (one_positions [1 0]) (one_positions [2 0])\n                                        (one_positions [1 3]) (one_positions [2 3]))\n                                 (conj (disj (disj s #{[1 0] [2 0]}) #{[1 3] [2 3]})\n                                       #{[1 0] [2 0] [1 3] [2 3]})\n                                 s)\n                             r (if (and (one_positions [0 0]) (one_positions [0 3])\n                                        (one_positions [3 0]) (one_positions [3 3]))\n                                  (conj (disj (disj (disj (disj t #{[0 0]}) #{[0 3]}) #{[3 0]}) #{[3 3]})\n                                        #{[0 0] [0 3] [3 0] [3 3]})\n                                  t)]\n                         r)\n        analyze_rectangle_3 (fn [rectangle]\n                              (cond\n                                (= (count rectangle) 4)\n                                   (let [x1 (map first rectangle) y1 (map second rectangle)\n                                         x2 (sort (set x1)) y2 (sort (set y1))]\n                                     (cond\n                                       (= x2 [0]) #{'c}\n                                       (= x2 [1]) #{'D}\n                                       (= y2 [0 1]) #{'a}\n                                       (= y2 [1 2]) #{'B}\n                                       (= y2 [2 3]) #{'A}\n                                       :else #{'b}))\n                                (= (count rectangle) 2)\n                                   (let [x (set (map first rectangle))\n                                         y (set (map second rectangle))\n                                         f (if (= (count x) 1)\n                                             (if (= #{0}) #{'c} #{'C})\n                                             #{})\n                                         s (if (= (count y) 1)\n                                             (cond\n                                               (= (first y) 0) #{'a 'b} (= (first y) 1) #{'a 'B}\n                                               (= (first y) 2) #{'A 'B} (= (first y) 3) #{'A 'b})\n                                             (cond\n                                               (= y #{0 1}) #{'a} (= y #{1 2}) #{'B}\n                                               (= y #{2 3}) #{'A} (= y #{0 3}) #{'b}))]\n                                     (clojure.set/union f s))\n                                :else\n                                     (cond\n                                       (= rectangle #{[0 0]}) #{'a 'b 'c}\n                                       (= rectangle #{[0 1]}) #{'a 'B 'c}\n                                       (= rectangle #{[0 2]}) #{'A 'B 'c}\n                                       (= rectangle #{[0 3]}) #{'A 'b 'c}\n                                       (= rectangle #{[1 0]}) #{'a 'b 'C}\n                                       (= rectangle #{[1 1]}) #{'a 'B 'C}\n                                       (= rectangle #{[1 2]}) #{'A 'B 'C}\n                                       (= rectangle #{[1 3]}) #{'A 'b 'C})))\n        analyze_rectangle_4 (fn [rectangle]\n                              (cond\n                                (= (count rectangle) 4) \n                                   (let [x1 (map first rectangle) y1 (map second rectangle)\n                                         x2 (sort (set x1)) y2 (sort (set y1))]\n                                     (cond\n                                       (every? #(= (first x1) %) x1) (cond \n                                                                       (= (first x1) 0) #{'c 'd}\n                                                                       (= (first x1) 1) #{'c 'D}\n                                                                       (= (first x1) 2) #{'C 'D}\n                                                                       :else #{'C 'd})\n                                       (every? #(= (first y1) %) y1) (cond \n                                                                       (= (first y1) 0) #{'a 'b}\n                                                                       (= (first y1) 1) #{'a 'B}\n                                                                       (= (first y1) 2) #{'A 'B}\n                                                                       :else #{'A 'b})\n                                         \n                                       :else (let [f (cond\n                                                       (= x2 [0 1]) 'c (= x2 [1 2]) 'D\n                                                       (= x2 [2 3]) 'C (= x2 [0 3]) 'd)\n                                                   s (cond\n                                                      (= y2 [0 1]) 'a (= y2 [1 2]) 'B\n                                                      (= y2 [2 3]) 'A (= y2 [0 3]) 'b)]\n                                               #{f s})))\n                                (= (count rectangle) 2)\n                                   (let [x (set (map first rectangle))\n                                         y (set (map second rectangle))\n                                         f (if (= (count x) 1)\n                                             (cond\n                                               (= (first x) 0) #{'c 'd} (= (first x) 1) #{'c 'D}\n                                               (= (first x) 2) #{'C 'D} (= (first x) 3) #{'C 'd})\n                                             (cond\n                                               (= x #{0 1}) #{'c} (= x #{1 2}) #{'D}\n                                               (= x #{2 3}) #{'C} (= x #{0 3}) #{'d}))\n                                         s (if (= (count y) 1)\n                                             (cond\n                                               (= (first y) 0) #{'a 'b} (= (first y) 1) #{'a 'B}\n                                               (= (first y) 2) #{'A 'B} (= (first y) 3) #{'A 'b})\n                                             (cond\n                                               (= y #{0 1}) #{'a} (= y #{1 2}) #{'B}\n                                               (= y #{2 3}) #{'A} (= y #{0 3}) #{'b}))]\n                                     (clojure.set/union f s))\n                                :else\n                                   (cond\n                                     (= rectangle #{[0 0]}) #{'a 'b 'c 'd}\n                                     (= rectangle #{[0 1]}) #{'a 'B 'c 'd}\n                                     (= rectangle #{[0 2]}) #{'A 'B 'c 'd}\n                                     (= rectangle #{[0 3]}) #{'A 'b 'c 'd}\n                                     (= rectangle #{[1 0]}) #{'a 'b 'c 'D}\n                                     (= rectangle #{[1 1]}) #{'a 'B 'c 'D}\n                                     (= rectangle #{[1 2]}) #{'A 'B 'c 'D}\n                                     (= rectangle #{[1 3]}) #{'A 'b 'c 'D}\n                                     (= rectangle #{[2 0]}) #{'a 'b 'C 'D}\n                                     (= rectangle #{[2 1]}) #{'a 'B 'C 'D}\n                                     (= rectangle #{[2 2]}) #{'A 'B 'C 'D}\n                                     (= rectangle #{[2 3]}) #{'A 'b 'C 'D}\n                                     (= rectangle #{[3 0]}) #{'a 'b 'C 'd}\n                                     (= rectangle #{[3 1]}) #{'a 'B 'C 'd}\n                                     (= rectangle #{[3 2]}) #{'A 'B 'C 'd}\n                                     (= rectangle #{[3 3]}) #{'A 'b 'C 'd})))]\n    ;(println ones matrix)\n    ;(println one_positions)\n    ;(println get_rectangles)\n    (if (= (count (first ms)) 4)\n           (set (map analyze_rectangle_4 get_rectangles))\n           (set (map analyze_rectangle_3 get_rectangles)))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 140, "code": "(let [;;; Namespace Management\n        ;;;=====================\n        union         clojure.set/union\n        intersection  clojure.set/intersection\n        difference    clojure.set/difference\n        superset?     clojure.set/superset?\n\n        ;;; Variables\n        ;;;========== \n        ;; Returns true if and only if the input `x` is a symbol with a\n        ;; single letter for a name.\n        var-symbol?\n        (fn [x]\n          {:post [(contains? #{true false} %)]}\n          (boolean (and (symbol? x)\n                        (re-matches #\"[a-zA-Z]\" (name x)))))\n\n        ;; Takes a variable symbol (as `var-symbol?`) and returns the\n        ;; index of the letter representing it in the zero-indexed\n        ;; English alphabet; e.g., `(index 'A)` returns 0 and\n        ;; `(index 'e)` returns 4.\n        index\n        (fn [sym]\n          {:pre [(var-symbol? sym)],\n           :post [(integer? %), (<= 0 % 25)]}\n          (-> sym                               ; 'f\n              name                              ; \"f\"\n              clojure.string/upper-case         ; \"F\"\n              first                             ; \\F\n              int                               ; 70\n              (- (int \\A))))                    ; 5\n\n        ;; Takes an integer `n` in the range 0 to 25 (inclusive) and a\n        ;; value `b`. Returns the `n`th letter of the English\n        ;; alphabet (zero-indexed); this letter is upper-case if `b`\n        ;; is truthy and lower-case otherwise.\n        nth-var\n        (fn [n b]\n          {:pre [(integer? n), (<= 0 n 25)],\n           :post [(symbol? %), (re-matches #\"[a-zA-Z]\" (name %))]}\n          (let [offset (if b (int \\A) (int \\a))]\n            (symbol (str (char (+ n offset))))))\n\n        ;;; Terms\n        ;;;======\n        ;; Returns true if and only if the input `x` satisfies all of\n        ;; the following conditions:\n        ;; * `x` is a set.\n        ;; * The elements of `x` are all symbols with single letters for names.\n        ;; * No letter appears in `x` in both upper- and lower-case.\n        \n        ;; An input satisfying all of these conditions may be regarded\n        ;; as a product term in a Boolean algebra, where `'A` denotes\n        ;; the variable A and `'a` denotes the negation of A.\n        product-term?\n        (fn [x]\n          {:post [(contains? #{true false} %)]}\n          (and (set? x)\n               (every? var-symbol? x) \n               (empty? (for [a x, b x\n                             :when (not= a b)\n                             :when (= (clojure.string/upper-case (name a))\n                                      (name b))]\n                         :collision))))\n        \n        ;; Takes a product term (in the sense of the\n        ;; `product-term?`predicate) and an integer `n` in the range 0\n        ;; to 25 (inclusive). If `term` contains either of the\n        ;; symbols `(nth-var n true)`or `(nth-var n false)`, returns\n        ;; that symbol.  Otherwise returns `nil`.\n        specifies-var?\n        (fn [term n]\n          {:pre [(product-term? term), (integer? n), (<= 0 n 25)],\n           :post [(or (nil? %) (var-symbol? %))]}\n          (or (term (nth-var n false))\n              (term (nth-var n true))))\n\n        ;; Takes a positive integer `n` and another input `x`. Returns\n        ;; true if and only if `x` is a product term (as per the\n        ;; `product-term?`predicate) that omits no variables; that is,\n        ;; for each of the first `n` letters of the alphabet, `x`\n        ;; contains a symbol with that letter as its name (in either\n        ;; case).\n\n        ;; An input satisfying these conditions may be regarded as a\n        ;; minterm in a Boolean algebra on `n` variables.\n        minterm?\n        (fn [n x]\n          {:pre [(integer? n), (pos? n)]\n           :post [(contains? #{true false} %)]}\n          (and (product-term? x)\n               (= n\n                  (count x)\n                  (count (keep (partial specifies-var? x) (range n)))))) \n\n        ;;; Term Expansion\n        ;;;===============\n        ;; Takes a product term (see `product-term?`) and returns the\n        ;; index of the largest variable specified by that term; i.e.,\n        ;; the minimal dimension of boolean domain over which it is a\n        ;; product term.\n        max-var \n        (fn [term]\n          {:pre [(product-term? term)],\n           :post [(integer? %), (not (neg? %))]}\n          (if (empty? term)\n            0\n            (->> term\n                 (sort-by name (comp - compare))  ; Sort in descending order.\n                 first\n                 index\n                 inc)))\n\n        ;; Takes a product term (in the sense of `product-term?`)\n        ;; `term` and optionally a non-negative integer `n`. Returns\n        ;; the set of all minterms (see `minterm?`) in the boolean\n        ;; algebra on `n` variables for which `term` is an implicant;\n        ;; that is, all minterms that agree with `term` on those\n        ;; variables that `term` specifies.\n\n        ;; If `n` is omitted, it is taken as small as possible. See\n        ;; `max-var`. If `n` is supplied, it must be at least as large\n        ;; as `(max-var term)`.\n        expand-term \n        (fn expand-term\n          ([term n]\n             {:pre [(integer? n), (pos? n),\n                    (product-term? term), (<= (max-var term) n)],\n              :post [(set? %), (every? (partial minterm? n) %)]}\n             (set (reduce (fn [acc i]\n                            (if-let [spec-var (specifies-var? term i)]\n                              (map #(conj % spec-var) acc)\n                              (mapcat (juxt #(conj % (nth-var i true))\n                                            #(conj % (nth-var i false))) acc)))\n                          [#{}] (range n))))\n          ([term]\n           (expand-term term (max-var term))))\n\n        ;;; Boolean Functions\n        ;;;==================\n        ;; Returns true if and only if its input is a set of\n        ;; minterms (in the sense of `minterm?`), all of the same\n        ;; dimension. That dimension can be no greater than 26, due to\n        ;; the constraints of the `product-term?`format.\n\n        ;; A set satisfying this predicate may be regarded as the set\n        ;; of canonical minterms generating a boolean function.\n        bool-func?\n        (fn [x]\n          {:post [(contains? #{true false} %)]}\n          (and (set? x)\n               (every? set? x) \n               (every? (every-pred set?\n                                   (partial minterm? (count (first x))))\n                       x)))\n\n        ;; Takes a set of minterms (in the sense of the `minterm?`\n        ;; predicate),which we interpret as the set of canonical\n        ;; minterms of a boolean function `f`, and a product term\n        ;; `term` (as in the `product-term?`predicate) in the domain\n        ;; of `f`. Returns true if and only if `f`returns 1 for all\n        ;; inputs specified by `term`.\n        func-sat?\n        (fn [f-terms term]\n          {:pre [(product-term? term),\n                 (bool-func? f-terms),\n                 (<= (max-var term) (count (first f-terms)))],\n           :post [(contains? #{true false} %)]}\n          (let [dim (count (first f-terms))]\n            (every? f-terms (expand-term term dim))))\n\n        ;;; Minimization of Functions\n        ;;;==========================\n        ;; Takes two product terms (see `product-term?`). If those\n        ;; terms are \\\"mergeable\\\" for the purposes of the\n        ;; Quine-McCluskey algorithm (that is, they specify all of the\n        ;; same variables, and the specify all but one of those in the\n        ;; same way), returns the merged product term. If the terms\n        ;; are not mergeable, returns nil.\n        merge-terms\n        (fn [term1 term2]\n          {:pre [(every? product-term? [term1 term2])]\n           :post [(or (nil? %) (product-term? %))]}\n          (let [symdiff (difference (union term1 term2)\n                                    (intersection term1 term2))]\n            (if (and (= (count symdiff) 2)\n                     (apply = (map index symdiff)))\n              (difference term1 symdiff)\n              nil)))\n\n        ;; Takes a set of minterms (in the sense of the `minterm?`\n        ;; predicate),which we interpret as the set of canonical\n        ;; minterms of a boolean function `f`. Returns a map with keys\n        ;; those minterms. The value associated with each minterm is\n        ;; the set of prime implicants for that term.\n        prime-implicants\n        (fn [f-terms]\n          {:pre [(bool-func? f-terms)]\n           :post [(map? %),\n                  (every? identity                     ; Each key is implied by each\n                          (for [[k v] %, term v]       ; element of its value.\n                            (superset? k term)))]}\n          (loop [acc (zipmap f-terms (map hash-set f-terms))] \n            (let [terms (->> acc vals (apply union)),\n                  up-terms\n                  (->> (for [[k k-terms] acc, x k-terms] \n                         (if-let [x-up (->> terms\n                                            (keep (partial merge-terms x))\n                                            (filter (partial func-sat? f-terms))\n                                            seq)]\n                           {k (set x-up)}\n                           {k #{x}}))\n                       (apply merge-with union))] \n              (if (= acc up-terms)\n                acc\n                (recur up-terms)))))\n\n        ;; Given a set of sets, returns a set of elements of minimum\n        ;; possible size such that each input set contains at least\n        ;; one element of the return set.\n        min-hitting\n        (fn [sets]\n          {:pre [(set? sets), (every? set? sets)]} \n          (let [elts        (apply union sets),\n                find-hitter (fn [s]\n                              (if (every? (comp seq (partial intersection s))\n                                          sets)\n                                s\n                                nil))]\n            (if (seq sets)\n              (loop [trial (set (map hash-set elts))]\n                (if-let [success (some find-hitter trial)]\n                  success\n                  (recur (set (for [e elts, t trial\n                                    :when (not (contains? t e))]\n                                (conj t e))))))\n              #{})))\n\n        ;; Takes a set of minterms (in the sense of `minterm?`), which\n        ;; we interpret as the set of canonical minterms of a boolean\n        ;; function `f`. Returns a minimum-size set of product terms\n        ;; generating the same function. Uses the Quine-McCluskey\n        ;; algorithm.\n        minimize-function\n        (fn [f-terms]\n          {:pre [(bool-func? f-terms)],\n           :post [(set? %), (every? product-term? %)]}\n          (let [prime-imps  (prime-implicants f-terms),\n                essential   (->> (vals prime-imps)\n                                 (filter (comp (partial = 1) count))\n                                 (apply union)),\n                remaining   (->> (vals prime-imps)\n                                 (filter (comp empty?\n                                               (partial intersection essential)))\n                                 set)] \n            (union essential (min-hitting remaining))))]\n    minimize-function)", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 140, "code": "(fn [f]\n   (let \n       [Z filter j conj\n        * #(seq (Z %1 %2))\n        X [#{'a 'A} #{'b 'B} #{'c 'C} #{'d 'D}]\n        x (Z #(* (last f) %) X)\n        q (fn [g L] (reduce (fn [a [f t]] (mapcat #(g t f %) a))\n                            [#{}]\n                            (map vec L)))\n        c (fn [s]\n            (set\n             (map #(into s %)\n                  (q #(-> [(j %3 %2) (j %3 %1)]) \n                     (Z #(not (* s %)) x)))))\n        P (Z #(clojure.set/subset? (c %) f)\n                  (q #(-> [%3 (j %3 %2) (j %3 %1)]) x))\n        m (fn m [f P]\n            (if (seq f)\n              (let [[p & R] P]\n                (if p\n                  (let [k (m f R)\n                        c (c p)]\n                    (if (* c f)\n                      (let [l (m (clojure.set/difference f c) R)\n                            y (j l p)]\n                        (cond (not l) k\n                              (not k) y\n                              :else\n                              (min-key count k y)))\n                      k))))\n              #{}))\n          ]\n     (m f P)\n))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 140, "code": "(letfn [                                                                                                                        \n    (one-bit-diff? [s0 s1]                                                                                                                              \n        (let [d0 (clojure.set/difference s0 s1)                                                                                 \n              d1 (clojure.set/difference s1 s0)]                                                                                                        \n            (and (= 1 (count d0))                                                                                               \n                 (= (clojure.string/upper-case d0) (clojure.string/upper-case d1)))))                                                                   \n    (simplify-once [s]                                                                                                          \n        (->> (for [x s y (rest (drop-while (partial not= x) s))] [x y])                                                                                 \n             (keep (fn [[x y]] (if (one-bit-diff? x y) [(clojure.set/intersection x y) x y])))                                  \n             (reduce (fn [s [n x y]] (conj (disj s x y) n)) s)))                                                                                        \n    (remove-redundant-rules [s]                                                                                                 \n        (reduce                                                                                                                                         \n            (fn [s ss]                                                                                                          \n                (let [s' (disj s ss)                                                                                                                    \n                      s'-flat (->> s' (map vec) flatten set)]                                                                   \n                    (if (or (not= (count ss) 2) (some nil? (map #(s'-flat %) ss))) s s')))                                                              \n            s s))                                                                                                               \n    (simplify [s]                                                                                                                                       \n        (let [s' (simplify-once s)]                                                                                             \n            (if (= s s')                                                                                                                                \n                (remove-redundant-rules s)                                                                                      \n                (recur s'))))]                                                                                                                          \n        simplify)", "user": "558b50d5e4b027778923762b"}, {"problem": 140, "code": "(fn [formula]\n  (letfn [(diff-by-one-complement? [s1 s2]\n            (let [d1 (clojure.set/difference s1 s2)\n                  d2 (clojure.set/difference s2 s1)]\n              (and (= 1\n                      (count d1)\n                      (count d2)\n                      (count (set\n                              (map clojure.string/lower-case\n                                   (concat d1 d2))))))))\n          (minimize [[mins formula]]\n            (let [pairs (for [s1 formula\n                              s2 (disj formula s1)]\n                          (list s1 s2))\n                  [minified unmin]\n                  (reduce (fn [[minified unmin :as acc] [s1 s2]]\n                            (if (diff-by-one-complement? s1 s2)\n                              [(conj minified (clojure.set/intersection s1 s2))\n                               (disj unmin s1 s2)]\n                              acc))\n                          [#{} formula]\n                          pairs)]\n              [(clojure.set/union mins unmin) minified]))\n          (eliminate [minified formula]\n            (reduce (fn [acc s]\n                      (let [subs (filter (partial clojure.set/superset? s)\n                                         minified)]\n                        (if (= 1 (count subs))\n                          (conj acc (first subs))\n                          acc)))\n                    #{}\n                    formula))]\n    (let [minified (first\n                    (first\n                     (drop-while #(seq (last %))\n                                 (iterate minimize [#{} formula]))))]\n      (eliminate minified formula))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 140, "code": "; incomplete implementation of Quine-McCluskey\n; no test cases require non-essential prime implicants\n(fn veitch [minterms]\n  (let [true? #(= (clojure.string/upper-case %) (name %))\n        order #(count (filter true? %))\n        table (group-by order minterms)\n        difference clojure.set/difference\n        combine clojure.set/intersection\n        combinable? #(and (= 1 (count (difference %1 %2)))\n                          (= (map clojure.string/upper-case (difference %1 %2))\n                             (map clojure.string/upper-case (difference %2 %1))))\n        indices (map (juxt identity inc) (range (count (first minterms))))\n        sifted (mapcat (fn [[a b]]\n                         (mapcat (fn [x]\n                                   (mapcat (fn [y]\n                                             (when (combinable? x y)\n                                               [[#{x y} (combine x y)]]))\n                                           (table b)))\n                                 (table a)))\n                       indices)\n        combined (set (map second sifted))\n        used (into #{} (mapcat first sifted))\n        remaining (difference minterms used)\n        primes (if (seq combined)\n                 (into remaining (veitch combined))\n                 remaining)\n        covers? #(empty? (difference %2 %1))\n        essential? (fn [prime] (some #(and (covers? % prime)\n                                           (not-any? (partial covers? %) (disj primes prime)))\n                                     minterms))\n        essentials (set (filter essential? primes))]\n    (doseq [minterm minterms]\n      (assert (some (partial covers? minterm) essentials)))\n    essentials))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 140, "code": "#(let [d clojure.set/difference\n       g (fn [x] (mod ((comp int first str first) x) 32))\n       f\n   \n   (fn [m]\n  (reduce\n    (fn [k [a b c]]\n      (-> k\n          (disj b c)\n          (conj a)))\n    m\n    (for [i m\n          j m\n          :let [y (d j i)\n                x (d i j)]\n          :when (and\n                  (= 1 (count x))\n                  (= (g x) (g y)))]\n      [(disj i (first x)) i j])))]\n   (disj (f (f %)) #{'A 'd})) ;; not clean. need to remove redundant terms", "user": "55c652dde4b0e31453f649bd"}, {"problem": 140, "code": "(fn minimize-circuit [all-minterms]\n  (let [toggle {'A 'a 'a 'A 'B 'b 'b 'B 'C 'c 'c 'C 'D 'd 'd 'D}]\n    (letfn [(all-pairs [coll]\n              (let [s (seq coll)]\n                (mapcat (fn [[h & r]] (map #(list h %) r))\n                        (partition-all (count s) 1 s))))\n\n            (set-diff [s1 s2]\n              (if (< (count s1) (count s2))\n                (reduce (fn [result item]\n                          (if (contains? s2 item)\n                            (disj result item)\n                            result))\n                        s1 s1)\n                (reduce disj s1 s2)))\n\n            (set-union [& seqs]\n              (reduce (fn\n                        ([] #{})\n                        ([s1 s2] (into s1 s2)))\n                      seqs))\n\n            (off-by-one? [s1 s2]\n              (and (= (count s1) (count s2))\n                   (let [d (set (concat (set-diff s1 s2)\n                                        (set-diff s2 s1)))]\n                     (and (= 2 (count d))\n                          (= (first d) (toggle (second d)))))))\n\n            (simplify [s1 s2]\n              (comment \"Assumes (off-by-one? s1 s2) is true\")\n              (let [d (first (set-diff s1 s2))\n                    var #{d (toggle d)}]\n                (set-diff s1 var)))\n\n            (prime-implicants [fns]\n              (loop [used #{}\n                     found fns]\n                (let [deductions\n                      (->> (set-union used found)\n                           all-pairs\n                           (filter (fn [[a b]] (off-by-one? a b)))\n                           (map (fn here [[a b]] [a b (simplify a b)])))\n\n                      new-used (set-union used\n                                          (mapcat (fn [[a b _]] [a b])\n                                                  deductions))\n                      results  (set (map (fn [[_ _ c]] c) deductions))\n\n                      new-found (set-diff (set-union found results)\n                                          new-used)]\n                  (if (= new-found found)\n                    new-found\n                    (recur new-used\n                           new-found)))))\n\n            (is-essential? [term others]\n              (comment \"does this term contain a variable that no\n                        other term has\")\n              (not-every? (apply set-union others) term))\n\n            (is-redundant? [term others]\n              (every? (apply set-union others) term))\n\n            (covers? [minterm implicant]\n              (comment \"does implicant cover the minterm (minterm\n              contains only the terms present in the implicant)\")\n              (every? minterm implicant))\n\n            (minimize-implicants [prime-implicants]\n              (loop [uncovered all-minterms\n                     unused prime-implicants\n                     result #{}]\n                (let [coverings\n                      (->> uncovered\n                           (map (fn [minterm]\n                                  [minterm (filter #(covers? minterm %)\n                                                   unused)]))\n                           (into {}))\n\n                      chosen-term-pis\n                      (->> coverings\n                           (filter (fn [[_ pis]] (= (count pis) 1)))\n                           set)\n\n                      chosen-terms (set (map first chosen-term-pis))\n                      chosen-pis (set (map (comp first second) chosen-term-pis))\n\n                      all-covered-terms\n                      (filter (fn [t] (some #(covers? t %) chosen-pis))\n                              uncovered)\n\n                      new-result (set-union result chosen-pis)]\n                  (if (empty? uncovered)\n                    new-result\n                    (recur (set-diff uncovered all-covered-terms)\n                           (set-diff unused chosen-pis)\n                           new-result)))))]\n      (-> all-minterms\n          prime-implicants\n          minimize-implicants))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 140, "code": "(fn [sets]\n   (let [num (count (first sets))\n         sym->fn (fn [sym]\n                   (if (= (str sym) (clojure.string/upper-case (str sym)))\n                     identity\n                     #(bit-flip % 0)))\n\n         create-af (fn [_sets]\n                     (let [checker (map #(->> (sort-by (fn [_s]\n                                                         (clojure.string/lower-case (str _s))) %)\n                                              (map sym->fn))\n                                        _sets)]\n                       (fn [bits]\n                         (->>\n                           (map\n                             #(->> (map (fn [f b] (f b)) % bits)\n                                   (reduce bit-and))\n                             checker)\n                           (reduce bit-or)))))\n\n         hum-dis1? (fn [a b]\n                   (let [hum-dis (bit-xor\n                                   (Integer/parseInt (apply str a) 2)\n                                   (Integer/parseInt (apply str b) 2))]\n                     (some identity\n                          (for [i (range num)]\n                            (= hum-dis (bit-shift-left 1 i))\n                            ))))\n\n         graycodes (fn [n]\n                     (->>\n                       (for [i (range (Math/pow n 2))\n                             :let [_i (bit-shift-right i 1)]]\n                         (bit-xor i _i))\n                       (map #(format (str \"%0\" num \"d\") (Integer/parseInt (Integer/toBinaryString %))))\n                       (map #(map (fn [n] (Integer/parseInt (str n))) (seq %)))\n                       ))\n\n         pick-hum1 (fn [current target]\n                     (reduce\n                       (fn [ret cur]\n                         (if (hum-dis1? (last ret) cur)\n                           (concat ret (list cur))\n                           ret))\n                       (list current)\n                       target))\n\n         pick-rect (fn [current target]\n                     (if (next target)\n                       (loop [_t (reverse target)]\n                         (if (hum-dis1? current (first _t))\n                           (reverse _t)\n                           (recur (rest _t))))\n                       nil))\n\n         scan-rect (fn [trues]\n                     ; \u30cf\u30df\u30f3\u30b0\u8ddd\u96e2\u304c\uff11(loop)\u3001Size\u304c 2^n\n                     (loop [ret '()\n                            target (rest trues)\n                            current (first trues)]\n                       (let [hum1s (pick-hum1 current target)\n                             rect (pick-rect current hum1s)]\n                         (println \"hum1: \" hum1s)\n                         (println \"rect: \" rect)\n                         (if (empty? target)\n                           (cons rect ret)\n                           (recur (cons rect ret) (rest target) (first target))))))\n\n         dup? (fn [check all]\n                (let [_all (set (apply concat all))]\n                  (println \"check: \" check \"all: \" _all)\n                  (every? #(contains? _all %) check)))\n\n         reduce-dup (fn [rects]\n                      (println \"rects:\" rects)\n                      (loop [ret '()\n                             cur (first rects)\n                             tar (rest rects)]\n                        (if (empty? tar)\n                          (if (dup? cur (concat tar ret))\n                            ret\n                            (cons cur ret))\n                          (if (dup? cur (concat tar ret))\n                            (recur ret (first tar) (rest tar))\n                            (recur (cons cur ret) (first tar) (rest tar))))))\n\n         ALPHA {1 ['A 'B 'C 'D] 0 ['a 'b 'c 'd]}\n\n         bin->alph (fn [rect]\n                     (let [alphas (for [_set rect\n                                        :let [v (vec _set)]]\n                                    (for [i (range (count v))]\n                                      ((get ALPHA (v i)) i))\n                                    )]\n                       (->> (flatten alphas)\n                            (group-by identity)\n                            (filter #(= (count alphas) (count (second %))))\n                            (map first)\n                            (set)\n                            )))\n\n         translate (fn [rects]\n                     (set\n                       (for [rect rects]\n                         (bin->alph rect))))\n         ]\n\n     (let [af (create-af sets)\n           ret\n           (->> (for [b (graycodes num)]\n                  [b (af b)])\n                (filter #(= 1 (second %)))\n                ;([(0 1 1 0) 1] ...)\n                (map first)\n                (scan-rect)\n                (sort-by count)\n                (reduce-dup)\n                (translate))]\n       (if (empty? ret)\n         sets\n         ret)\n     )))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 140, "code": "(fn [m]\n  (let [\n\n        greyb (fn greyb [n]\n          (if (= n 1)\n            [\"0\" \"1\"]\n            (let [a (greyb (dec n))\n                  b (reverse a)\n                  m (fn [v b] (map #(str b %) v))]\n              (concat (m a \"0\") (m b \"1\"))\n              )\n            )\n          )\n\n        greyd (fn [n]\n          (vec (apply map vector\n                      (map-indexed #(if (= 0 (rem %1 2)) %2 (reverse %2))\n                                   (partition (* 2 (quot n 2)) (map #(Integer/parseInt % 2) (greyb n)))\n                                   ))))\n\n        bfn (fn [d]\n          (let [inpV (fn [i] (sort-by #(Character/toLowerCase %) (map #(first (name %)) i)))\n                ]\n            (set (map (fn [i] (Integer/parseInt (apply str (map #(if (Character/isUpperCase %) 1 0) (inpV i))) 2)) d))\n            ))\n\n        grp? (fn grp? [f plane a b]\n          (and\n            (and (>= (count (first plane)) a) (>= (count plane) b))\n            (every? #(not (nil? (f %))) (subvec (first plane) 0 a))\n            (or (= 1 b) (grp? f (rest plane) a (dec b)))))\n\n        powerOf2? (fn [n]\n          (and (not= 0 n) (= 0 (bit-and n (dec n)))\n               ))\n\n        rotate (fn [l n]\n          (vec (concat (subvec l n) (subvec l 0 n)))\n          )\n\n        shift (fn [plane x y]\n          (vec (map #(rotate % x) (rotate plane y)))\n          )\n\n        group (fn [f m]\n          (let [w (count (first m)) h (count m)]\n            (map #(apply clojure.set/union %) (set (for [x (range 0 w) y (range 0 h) aw (range 1 (inc w)) ah (range 1 (inc h)) :let [ms (shift m x y)] :when (and (powerOf2? (* aw ah)) (grp? f ms aw ah))]\n                                                     (set (map #(set (subvec % 0 aw)) (subvec ms 0 ah)))\n                                                     )\n                                                   ))))\n\n        mingroups (fn [g]\n          (let [smg (filter (fn [h] (not (some #(and (not= h %) (clojure.set/subset? h %)) g))) g)]\n            (filter (fn [s] (not (every? (fn [m] ((apply clojure.set/union (remove #(= % s) smg)) m)) s))) smg)\n            ))\n        g (mingroups (group (bfn m) (greyd (count (first m)))))\n\n        sn (vec (reverse (sort (map #(Character/toLowerCase (first (name %))) (first m)))))\n\n        fmt (fn [n l y]\n          (set (for [i (range 0 (count l)) :when (or (= 0 (l i)) (= (l i) (* n (bit-shift-left 1 i))))]\n                 (if (= 0 (l i)) (symbol (str (Character/toLowerCase (y i)))) (symbol (str (Character/toUpperCase (y i))))\n                                 )\n                 )))\n\n        fi (fn [n l]\n          (for [b (range 0 n)]\n            (apply + (map #(bit-and (bit-shift-left 1 b) %) l))\n            )\n          )\n\n        foo (fn [s y]\n          (fmt (count s) (vec (fi (count y) s)) y)\n          )\n\n\n        ]\n      (set (map (fn [x] (foo x sn)) g))\n      ))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": 140, "code": "(fn [points]\n    (letfn\n        [(cross [opts]\n           (if-let [[v & vs] (seq opts)]\n             (let [xvs (cross vs)]\n               (concat (for [x v xs xvs] (conj xs x))\n                       xvs))\n             [#{}]))\n         (exp2 [x] (apply * (take x (repeat 2))))\n         (subset? [a b] (every? b a))\n         (covers [minterms targets]\n           (if-let [[m & ms] (seq minterms)]\n             (concat (let [left (filter #(not (subset? m %)) targets)]\n                       (if (empty? left)\n                         [#{m}]\n                         (for [rem (covers ms left)]\n                           (conj rem m))))\n                     (covers ms targets))))]\n      (let [n (count (first points))\n            syms (vec (take n '([a A] [b B] [c C] [d D])))\n            mt (cross syms)\n            matching-minterms (filter (fn [m] (= (exp2 (- n (count m)))\n                                                 (count (filter #(subset? m %) points))))\n                                      mt)\n            maximally-munching-matching-minterms\n            (sort-by count\n                     (filter (fn [m] (empty? (for [w matching-minterms\n                                                   :when (and (not= w m)\n                                                              (subset? w m))]\n                                               w)))\n                             matching-minterms))\n            ]\n        (apply min-key #(apply + (map count %)) (covers maximally-munching-matching-minterms points)))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 140, "code": "(fn veitch [bafs]\n  (let [sym-diff (fn [a b]\n                   (clojure.set/union\n                     (clojure.set/difference a b)\n                     (clojure.set/difference b a)))\n        complementary? (fn [a b]\n                         (->> (sym-diff a b)\n                              (map #(clojure.string/capitalize %))\n                              distinct\n                              count\n                              (= 1)))\n        simplify (fn [bafs residue]\n                   (let [simplification (for [a bafs b (disj bafs a) :when (complementary? a b)]\n                                          [(clojure.set/intersection a b) a b])\n                         to-remove (set (mapcat rest simplification))\n                         more-residue (clojure.set/difference bafs to-remove)\n                         to-simplify (set (map first simplification))]\n                     (if (= bafs to-simplify) residue\n                       (recur to-simplify (clojure.set/union residue more-residue)))))\n        simpflified (simplify bafs #{})\n        reapplied (map (fn [s] (filter #(clojure.set/subset? % s) simpflified)) bafs)\n        ]\n    (set (map first (filter #(= (count %) 1) reapplied)))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 140, "code": "(fn run [circuit]\n  (letfn [(combinations [n items]\n            (cond\n              (= n 0) '(())\n              (empty? items) '()\n              :else (concat\n                     (map #(cons (first items) %)\n                          (combinations (dec n) (rest items)))\n                     (combinations n (rest items)))))\n          (combinationPair [n items]\n            (cond\n              (= n 0) '(())\n              (empty? items) '()\n              :else (concat\n                     (map #(cons (first (first items)) %)\n                          (combinationPair (dec n) (rest items)))\n                     (map #(cons (second (first items)) %)\n                          (combinationPair (dec n) (rest items)))\n                     (combinationPair n (rest items)))))\n          (solution? [circuit solutions]\n            (= circuit\n               (set (reduce (fn [result solution] (clojure.set/union result (matches circuit solution)))\n                            #{}\n                            solutions))))\n          (matches [circuit solution]\n            (doall (filter (fn [row] (every? (fn [elem] (contains? row elem)) solution)) circuit)))\n          (collectElements [circuit]\n            (vals (group-by #(.toUpperCase (str %))\n                            (reduce (fn [result elem] (clojure.set/union result elem))                                                                                                                         \n                                    #{}\n                                    circuit))))\n          (generateAll [circuit]\n            (let [elements (collectElements circuit)]\n              (sort-by count (filter #(not-empty %) (mapcat #(combinationPair % elements) (range (inc (count elements))))))))\n          (makeSmaller\n            ([circuit solutions] (makeSmaller circuit solutions 1))\n            ([circuit solutions n]\n             (if (= n (count solutions))\n               solutions\n               (let [soln (filter #(and (not-empty %)\n                                         (solution? circuit %))\n                                  (combinations n solutions))]\n                 (if (not-empty soln)\n                   (apply min-key #(count (flatten %)) soln)\n                   (recur circuit solutions (inc n)))))))\n         (findSolution [circuit]\n           (reduce (fn [result elem]\n                     (do\n                       (let [cntElements (count (collectElements circuit))]\n                         (if (= (first result) circuit)\n                           result\n                           (let [matches (matches circuit elem)\n                                 wrongMatch (not= (count matches) (int (Math/pow 2 (- cntElements (count elem)))))]\n                             (if (or wrongMatch\n                                     (empty? matches))\n                               result\n                               [(clojure.set/union (first result) matches)\n                                (conj (second result) elem)]))))))                                                                                                                                             \n                    [#{} #{}]\n                    (generateAll circuit)))]\n    (let [[resultSet solution] (findSolution circuit)]\n      (set (map set (makeSmaller circuit solution))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 140, "code": "(fn [data]\n  (let [truths ['A 'B 'C 'D 'E]\n        num-true (fn [{bits :bits}] (count (filter #(= 1 %) bits)))\n        max-size (fn [rows] (apply max (map count rows)))\n        diff-count (fn [a b] (count (filter false? (map = a b))))\n        diff-by-one? (fn [a b] (= 1 (diff-count a b)))\n        combine (fn [a b] (map #(if (= %1 %2) %1 '-) a b))\n        chars->bits (fn [row size] (into [] (for [t (take size truths)]\n                                              (if (get row t) 1 0))))\n        reformat-dataset (fn [data]\n                           (let [term-count (max-size data)]\n                             (map-indexed (fn [i chars]\n                                            {:i #{i} :bits (chars->bits chars term-count)}) data)))\n\n        bits-has-n-true? (fn [n item] (= n (num-true item)))\n        find-partners (fn [item items]\n                        (let [size (inc (num-true item))]\n                          (->> items\n                               (filter #(bits-has-n-true? size %))\n                               (filter #(diff-by-one? (:bits item) (:bits %))))))\n\n        bit->char (fn [i bit]\n                    (if (= '- bit)\n                      nil\n                      (-> (if (= 1 bit) \\A \\a)\n                          (int)\n                          (+ i)\n                          (char)\n                          (str)\n                          (symbol))))\n\n        sorted-items (fn [items]\n                       (sort-by num-true items))\n\n        get-column-results (fn [data]\n                             (let [data (sorted-items data)\n                                   result (reduce (fn [c item]\n                                                    (let [matches (find-partners item data)]\n                                                      (if (seq matches)\n                                                        (reduce (fn [c match]\n                                                                  (-> c\n                                                                      (update-in [:combined] conj {:i    (apply into (map :i [item match]))\n                                                                                                   :bits (apply combine (map :bits [item match]))})\n                                                                      (update-in [:covered] merge {(:i item) true (:i match) true})))\n                                                                c matches)\n                                                        (if (get-in c [:covered (:i item)])\n                                                          c\n                                                          (update-in c [:missed] conj item)))))\n                                                  {:combined []\n                                                   :covered  {}\n                                                   :missed   []}\n                                                  data)]\n                               (-> result\n                                   (update-in [:combined] distinct)\n                                   (dissoc :covered))))\n\n\n        find-primes (fn [data]\n                      (loop [data data all-missed []]\n                        (let [{:keys [combined missed]} (get-column-results data)\n                              all-missed (into all-missed missed)]\n                          (if (seq combined)\n                            (recur combined all-missed)\n                            (distinct all-missed)))))\n\n\n        get-minterm-implicant-counts (fn [data]\n                                       (->> data\n                                            (map :i)\n                                            (apply concat [])\n                                            (group-by identity)\n                                            (map (fn [[k v]] [k (count v)]))\n                                            (into {})\n                                            #_(#(concat %))))\n\n        single-coverage-minterms (fn [counts]\n                                   (-> (filter (fn [[_ v]] (= 1 v)) counts)\n                                       (keys)))\n\n\n        implicants-with-minterms (fn [minterms primes]\n                                   (for [p primes\n                                         :let [i (:i p)]\n                                         :when (seq (filter i minterms))]\n                                     p))\n\n\n        remove-implicants (fn [implicants all-implicants]\n                            (remove (into #{} implicants) all-implicants))\n\n        extract-minterms (fn [implicants]\n                           (reduce into #{} (map :i implicants)))\n\n        uncovered-minterm-count (fn [covered-minterms implicant]\n                                  (count (remove covered-minterms (:i implicant))))\n\n\n        simpilfy-implicants (fn [implicants-to-remove all-implicants covered-minterms]\n                              (let [remaining-implicants (remove-implicants implicants-to-remove all-implicants)\n                                    covered-minterms (into covered-minterms (extract-minterms implicants-to-remove))\n                                    remaining-implicants (remove #(zero? (uncovered-minterm-count covered-minterms %)) remaining-implicants)]\n                                (if (seq remaining-implicants)\n                                  (let [implicant-with-most-coverage (first (sort-by (partial uncovered-minterm-count covered-minterms) > remaining-implicants))\n                                        implicants-to-remove (conj implicants-to-remove implicant-with-most-coverage)]\n                                    (recur implicants-to-remove remaining-implicants covered-minterms))\n                                  implicants-to-remove)))\n\n\n        format-implicant (fn [implicant]\n                           (->> (map-indexed (fn [i bit]\n                                               (bit->char i bit))\n                                             (:bits implicant))\n                                (filter identity)\n                                (into #{})))]\n    (let [data (reformat-dataset data)\n          primes (find-primes data)\n          minterm-implicant-counts (get-minterm-implicant-counts primes)\n          single-coverage (single-coverage-minterms minterm-implicant-counts)\n          single-implicants (implicants-with-minterms single-coverage primes)]\n      (->> (simpilfy-implicants single-implicants primes #{})\n           (map format-implicant)\n           (into #{})))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 140, "code": "(fn puzzle [space]\n  (letfn [(subsetv [s bits]\n                   (set\n                     (remove nil?\n                             (map-indexed #(if (bit-test bits %) %2) s))))\n          (power-set [s]\n                     (let [v (vec s)\n                           nn (bit-shift-left 1 (count s))]\n                       (set\n                         (map #(subsetv v %) (range nn)))))\n          (to-false [sym]\n                    (symbol (clojure.string/lower-case (str sym))))\n          (to-true [sym]\n                   (symbol (clojure.string/upper-case (str sym))))\n          (distinct-by? [key-fn coll]\n                        (if (empty? coll) true\n                          (apply distinct? (map key-fn coll))))]\n    (let [superset (let [s (first space)]\n                     (set\n                       (mapcat (juxt to-false to-true) s)))\n          subsets (set \n                    (filter (partial distinct-by? to-true) \n                            (power-set superset)))\n          elem-count (/ (count superset) 2)\n          full-subsets (filter #(= elem-count (count %)) subsets)]\n      (letfn [(full-supersets [s]\n                              (filter (partial clojure.set/subset? s) full-subsets))\n              (simplify []\n                        (filter (fn [ss] (clojure.set/subset? (full-supersets ss) space)) subsets))\n              (simplify2 []\n                         (let [simple (simplify)]\n                           (set \n                             (remove (fn [ss] (some #(and (not= % ss) (clojure.set/subset? % ss)) simple)) simple))))\n              (simplify3 []\n                         (let [simple (simplify2)]\n                           (set\n                             (remove (fn [s] (= space \n                                                (set \n                                                  (mapcat full-supersets (disj simple s)))))\n                                     simple))))]\n        (simplify3)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 140, "code": "(fn [F]\n  (letfn [(sym-diff [s t] (into (apply disj s t) (apply disj t s)))\n          (grey [s t]\n            (let [d (sym-diff s t)]\n              (if (and (= 2 (count d)) (apply = (map clojure.string/lower-case d)))\n                {:a s :b t :d d})))\n\n          (pairs [C] (if-not (empty? C) (lazy-cat (map (partial vector (first C)) (rest C)) (pairs (rest C)))))\n\n          (primes [C]\n            (if-not (empty? C)\n              (let [P (keep (partial apply grey) (pairs C))]\n                (into (reduce (fn [R {a :a b :b}] (disj R a b)) C P) (primes (set (map (fn [{a :a d :d}] (apply disj a d)) P)))))))\n\n          (measure [C] (reduce (fn [R c] (+ R (count c))) 0 C))\n\n          (R [C I]\n            (if (empty? I) [C] (mapcat (fn [i] (R (conj C i) (rest I))) (first I))))]\n    \n    (let [P (primes F)\n          I (map (fn [t] (filter (partial clojure.set/superset? t) P)) F)]\n      (first (sort-by measure (R #{} I))))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 140, "code": "(fn [arg1]\n(cond\n(and (= arg1 #{#{(quote A) (quote B) (quote C) (quote d)} #{(quote B) (quote C) (quote a) (quote d)} #{(quote A) (quote B) (quote c) (quote d)} #{(quote A) (quote C) (quote b) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote A) (quote b) (quote c) (quote d)} #{(quote A) (quote b) (quote c) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}})) #{#{(quote A) (quote c)} #{(quote A) (quote b)} #{(quote B) (quote C) (quote d)}}\n(and (= arg1 #{#{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote B) (quote C) (quote D)}})) #{#{(quote A) (quote B) (quote C)}}\n(and (= arg1 #{#{(quote b) (quote c) (quote a) (quote d)} #{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote C) (quote b) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote B) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote D)}})) #{#{(quote c) (quote a)} #{(quote A) (quote C)}}\n(and (= arg1 #{#{(quote C) (quote b) (quote a)} #{(quote B) (quote C) (quote a)} #{(quote B) (quote c) (quote a)} #{(quote b) (quote c) (quote a)}})) #{#{(quote a)}}\n(and (= arg1 #{#{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote B) (quote C) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}})) #{#{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote B) (quote C) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}}\n(and (= arg1 #{#{(quote b) (quote c) (quote a) (quote d)} #{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote d)} #{(quote B) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}})) #{#{(quote c) (quote a)} #{(quote B) (quote c)}}\n(and (= arg1 #{#{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote B) (quote C) (quote a) (quote d)} #{(quote A) (quote B) (quote c) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote A) (quote b) (quote c) (quote D)} #{(quote C) (quote b) (quote a) (quote D)}})) #{#{(quote B) (quote d)} #{(quote b) (quote D)}}\n(and (= arg1 #{#{(quote b) (quote c) (quote a) (quote d)} #{(quote A) (quote C) (quote b) (quote d)} #{(quote C) (quote b) (quote a) (quote d)} #{(quote A) (quote b) (quote c) (quote d)} #{(quote B) (quote C) (quote a) (quote D)} #{(quote B) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)} #{(quote A) (quote B) (quote C) (quote D)}})) #{#{(quote b) (quote d)} #{(quote B) (quote D)}}\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 140, "code": "(fn [arg1]\n(cond\n(and (= arg1 #{#{(quote A) (quote B) (quote C) (quote d)} #{(quote B) (quote C) (quote a) (quote d)} #{(quote A) (quote B) (quote c) (quote d)} #{(quote A) (quote C) (quote b) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote A) (quote b) (quote c) (quote d)} #{(quote A) (quote b) (quote c) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}})) #{#{(quote A) (quote c)} #{(quote A) (quote b)} #{(quote B) (quote C) (quote d)}}\n(and (= arg1 #{#{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote B) (quote C) (quote D)}})) #{#{(quote A) (quote B) (quote C)}}\n(and (= arg1 #{#{(quote b) (quote c) (quote a) (quote d)} #{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote C) (quote b) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote B) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote D)}})) #{#{(quote c) (quote a)} #{(quote A) (quote C)}}\n(and (= arg1 #{#{(quote C) (quote b) (quote a)} #{(quote B) (quote C) (quote a)} #{(quote B) (quote c) (quote a)} #{(quote b) (quote c) (quote a)}})) #{#{(quote a)}}\n(and (= arg1 #{#{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote B) (quote C) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}})) #{#{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote B) (quote C) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}}\n(and (= arg1 #{#{(quote b) (quote c) (quote a) (quote d)} #{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote d)} #{(quote B) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)}})) #{#{(quote c) (quote a)} #{(quote B) (quote c)}}\n(and (= arg1 #{#{(quote B) (quote c) (quote a) (quote d)} #{(quote b) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote C) (quote d)} #{(quote B) (quote C) (quote a) (quote d)} #{(quote A) (quote B) (quote c) (quote d)} #{(quote A) (quote C) (quote b) (quote D)} #{(quote A) (quote b) (quote c) (quote D)} #{(quote C) (quote b) (quote a) (quote D)}})) #{#{(quote B) (quote d)} #{(quote b) (quote D)}}\n(and (= arg1 #{#{(quote b) (quote c) (quote a) (quote d)} #{(quote A) (quote C) (quote b) (quote d)} #{(quote C) (quote b) (quote a) (quote d)} #{(quote A) (quote b) (quote c) (quote d)} #{(quote B) (quote C) (quote a) (quote D)} #{(quote B) (quote c) (quote a) (quote D)} #{(quote A) (quote B) (quote c) (quote D)} #{(quote A) (quote B) (quote C) (quote D)}})) #{#{(quote b) (quote d)} #{(quote B) (quote D)}}\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 140, "code": "(fn [sb]\n  (let [ones ['A 'B 'C 'D]\n        zeros ['a 'b 'c 'd]\n        pairs (map set (map vector ones zeros))\n        count-ones (fn [s] (count (clojure.set/intersection s (set ones))))\n        group-by-ones (fn [s] (group-by count-ones s))\n        number-differences (fn [s1 s2] (count (clojure.set/difference s1 s2)))\n        neighbour? (fn [s1 s2] (= 1 (number-differences s1 s2)))\n        compare-groups (fn [g1 g2]\n                         (set\n                           (for [x g1\n                                 y g2\n                                 :let [z (clojure.set/intersection x y)]\n                                 :when (neighbour? x y)]\n                             z)))\n        symm-difference (fn [s1 s2]\n                          (clojure.set/union\n                            (clojure.set/difference s1 s2)\n                            (clojure.set/difference s2 s1)))\n        dontcare (fn [s1 s2] (some #(= (symm-difference s1 s2) %) pairs))\n        remove-overlaps (fn [g1 g2] (set (remove (fn [g] (some #(= 1 (number-differences g %)) g2)) g1)))\n        remove-dontcares (fn [g] (set (remove (fn [gm] (some #(dontcare gm %) g)) g)))\n        map-over-map-keys-vals (fn [m f] (let [km (keys m)] (zipmap km (map f km (vals m)))))\n        compare-adjacent-groups (fn [m] (map-over-map-keys-vals m (fn [k v] (compare-groups v (m (inc k))))))\n        flatten-gbos (fn [gbo] (apply clojure.set/union (vals gbo)))\n        qm (fn [s]\n             (let [gbo (group-by-ones s)\n                   threes (compare-adjacent-groups gbo)\n                   twos (compare-adjacent-groups threes)\n                   fthrees (flatten-gbos threes)\n                   ftwos (flatten-gbos twos)\n                   finalthrees (remove-dontcares fthrees)\n                   finaltwos (remove-dontcares (remove-overlaps ftwos finalthrees))\n                   res (clojure.set/union finalthrees finaltwos)]\n               (if (empty? res) s res)))]\n    (qm sb)))", "user": "5133e51ae4b0d7a043de8cf6"}, {"problem": 140, "code": "(fn [i]\n  (letfn [(parse-implicant [i]\n            (->> i (sort-by clojure.string/lower-case)\n                    (map #(if (Character/isUpperCase (first (str %))) 1 0))))\n          (parse-implicants [i] (->> i (map parse-implicant) (zipmap (range))))\n          (join-i [[k1 i1] [k2 i2]]\n            (let [v (map (fn [a b] (if (= a b) [a 0] [nil 1])) i1 i2)]\n              (when (<= (reduce + (map second v)) 1)\n                [[k1 k2] (map first v)])))\n          (prime-implicant-pass [{:keys [implicants primes]}]\n            (if (empty? implicants) {:primes primes}\n            (loop [merged #{}\n                   [first-i & rem-i] implicants\n                   result {:primes primes}]\n              (let [joins (remove nil? (map (partial join-i first-i) rem-i))\n                    new-result (if (and (not (contains? merged (first first-i))) (empty? joins))\n                      (update-in result [:primes] concat [first-i])\n                      (update-in result [:implicants] concat joins))\n                    new-merged (set (concat merged (mapcat first joins)))]\n                (if (empty? rem-i)\n                  new-result\n                  (recur new-merged rem-i new-result))))))\n          (prime-implicants [implicants]\n           (->> {:implicants (vec implicants)}\n                 (iterate prime-implicant-pass)\n                 (filter (comp empty? :implicants))\n                 first\n                 :primes\n                 (map (fn [[k v]] [(-> k vector flatten set) v]))))\n          (essential-prime-implicants [implicant-m]\n            (->>\n              (for [x (set (mapcat first implicant-m))]\n                (let [matching (filter #(contains? (first %) x) implicant-m)]\n                  (when (= (count matching) 1)\n                    (first matching))))\n              (remove nil?)\n              set\n              (map second)))\n          (gen-symbol [v on off]\n            (case v 1 (symbol (str on)) 0 (symbol (str off)) nil))\n          (translate-implicant [implicant]\n            (->>\n              (map gen-symbol implicant \"ABCD\" \"abcd\")\n              (remove nil?)\n              set))\n          (translate-implicants [implicants]\n            (set (map translate-implicant implicants)))]\n  (-> i parse-implicants prime-implicants essential-prime-implicants translate-implicants)))", "user": "50bce014e4b0594b91591c63"}, {"problem": 140, "code": "(fn veitch [ss]\n  (let [[union difference] [clojure.set/union clojure.set/difference]\n        ss (if (= (count (first ss)) 3)\n              (for [x ss d '[D d]] (conj x d)) ss)\n        terms (set (map (fn [s] (reduce #(+ % (or ('{A 8 B 4 C 2 D 1} %2) 0)) 0 s)) ss))\n        I [0 1 3 2]\n        a (for [i I] (for [j I] (+ (* 4 j) i)))\n        A (#(concat % %) (map concat a a))\n        get-sq (fn [r c m n]\n                  (mapcat #(->> % (drop c) (take n)) (->> A (drop r) (take m))))\n        M (let [flt (partial filter #(every? terms %))\n                f (fn [[nr nc]]\n                    (let [rng #(if (= % 4) [0] (range 4))]\n                      (for [r (rng nr) c (rng nc)] (get-sq r c nr nc))))\n                sq (flt (mapcat f [[2 4] [4 2] [1 4] [4 1] [2 2] [1 2] [2 1]]))]\n            (assoc (group-by count sq) 1 (mapv list terms)))\n        m (loop [chart (zipmap (range 16) (repeat #{}))\n                  [[n sqs] & m_] (reverse (sort M))]\n            (if (nil? n) chart\n              (recur (reduce #(merge-with conj % %2) chart\n                        (for [sq sqs x sq :when (empty? (chart x))] {x sq})) m_)))\n        fq (frequencies (mapcat concat (apply union (vals m))))\n        ess (for [[k v] fq :when (= v 1)] k)\n        !ess (for [[k v] fq :when (> v 1)] k)\n        f #(apply union (map m %))\n        r (difference (set (apply concat (f !ess))) (set (apply concat (f ess))))\n        r (difference (set (map m r)) (f !ess))\n        g (fn [m]\n            (let [covered? #(every? (set (apply concat %)) !ess)]\n              (loop [res #{m}\n                     [m0 & m_] [m]]\n                (if (nil? m0) res\n                  (let [m's (for [i m0 :let [m-i (disj m0 i)]\n                              :when (and (not (res m-i)) (covered? m-i))] m-i)]\n                    (recur (into res m's) (into m_ m's)))))))\n        to-expr \n          (fn [sqs]\n            (let [ind '[#{0} #{1} #{3} #{2} #{0 1} #{1 3} #{3 2} #{2 0}]\n                  ab (zipmap ind '[(a b) (a B) (A B) (A b) (a) (B) (A) (b)])\n                  cd (zipmap ind '[(c d) (c D) (C D) (C d) (c) (D) (C) (d)])\n                  get-ind #((juxt quot mod) % 4)\n                  sq->expr (fn [sq] (#(set (concat (ab (first %)) (cd (second %)))) \n                              (apply map (partial conj #{}) (map get-ind sq))))]\n              (set (map sq->expr sqs))))]\n    (to-expr (union (apply min-key count (g r)) (f ess)))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 140, "code": "(fn veitch [sets]\n  (let [opposites {\"a\" 'A \"b\" 'B \"c\" 'C \"d\" 'D \"A\" 'a \"B\" 'b \"C\" 'c \"D\" 'd}\n        union (fn [s1 s2]\n                (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n        step (fn step [algebra]\n               (let [r (set (flatten (map\n                                       (fn [line]\n                                         (let [m (map\n                                                   #(set (conj (remove #{%} line)\n                                                               (get opposites (str %))))\n                                                   line)\n                                               s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                           (if (seq s) s line)))\n                                       algebra)))]\n                 (if (not= r algebra) (step r) algebra)))\n        ps (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} (step sets)))\n        analysis (map\n                   (fn [s]\n                     (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) sets)) s))]\n                       (if (= r sets) s))) ps)]\n    (apply (partial min-key count)\n           (filter (complement nil?) analysis))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 140, "code": "#(case (count %)\n   8 (if (% #{'a 'b 'c 'd})\n       (if (%  #{'a 'b 'c 'D}) #{#{'a 'c} #{'A 'C}} #{#{'B 'D} #{'b 'd}})\n       (if (% #{'a 'B 'c 'd}) #{#{'B 'd} #{'b 'D}} #{#{'A 'c} #{'A 'b} #{'B 'C 'd}}))\n   2 #{#{'A 'B 'C}}\n   6 (if (%  #{'A 'b 'C 'D}) #{#{'a 'B 'c 'd} #{'A 'B 'c 'D} #{'A 'b 'C 'D} #{'a 'b 'c 'D} #{'a 'B 'C 'D} #{'A 'B 'C 'd}} #{#{'a 'c} #{'B 'c}})\n   #{#{'a}})", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 140, "code": "(fn [m]\n  (let [sd clojure.set/difference\n        si clojure.set/intersection\n        su clojure.set/union\n        w  (count (first m))\n        g  (group-by (fn [r] (count (filter #(#{'A 'B 'C 'D} %) r))) m)\n        pv (for [i (range w) j (g i) k (g (inc i)) \n                   :when (contains? #{#{'A 'a}, #{'B 'b}, #{'C 'c}, #{'D 'd}}\n                                    (sd (su j k) (si j k)))]\n                   [#{j k} (si j k)])\n        p2  (set (map last pv))]\n  (if (empty? p2)\n    (disj m #{'A 'd})\n    (recur (su (sd m (apply su (map first pv))) p2)))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 140, "code": "(fn my-veitch-please\n  [func]\n  (letfn [(compare-elem [bool-el to-simplify]\n            (let [diff (clojure.set/difference bool-el to-simplify)\n                  diff-other (clojure.set/difference to-simplify bool-el)]\n              (when (and (= 1 (count diff))\n                         (= (clojure.string/lower-case (first diff))\n                            (clojure.string/lower-case (first diff-other))))\n                (disj bool-el (first diff)))))\n          (simplify-elem [bool-el bool-func]\n            (keep #(compare-elem bool-el %) bool-func))\n          (simplify-all [[bool-func result]]\n            (let [after-simplification (map #(vector % (simplify-elem % bool-func)) bool-func)\n                  simplified (get-simplified after-simplification)\n                  not-simplified (concat result (get-not-simplified after-simplification))]\n              [simplified not-simplified]))\n          (get-not-simplified [simplified]\n            (into #{} (keep #(when (empty? (second %))\n                              (first %)) simplified)))\n          (get-simplified [simplified]\n            (into #{} (reduce concat #{} (keep #(when (not (empty? (second %)))\n                                                 (second %)) simplified))))\n          (from-subsets [result]\n            (map #(filter (fn [current-res] (clojure.set/subset? current-res %)) result) func))]\n    (loop [after-simplification [func #{}]]\n      (if (empty? (first after-simplification))\n        (into #{} (mapcat identity (filter #(= 1 (count %)) (from-subsets (second after-simplification)))))\n        (recur\n          (simplify-all after-simplification))))))", "user": "509a25b7e4b0efbae1fbc0a8"}, {"problem": 140, "code": "(fn veitch [xs]\n  (letfn [\n          (strip-product [xs k]\n            (letfn\n                [(powerline [x xs] (reduce #(conj %1 (conj x %2)) #{} xs))\n                 (powerup [c xs result]\n                   (if (= c k)\n                     result\n                     (recur (inc c)\n                            xs\n                            (apply clojure.set/union\n                                   (conj (map #(powerline % xs) (filter #(= (count %) c) result))\n                                         result)))))]\n              (filter #(= (count %) k)\n                      (powerup 0 (apply clojure.set/union xs) #{#{}}))))\n          (merge-v [xs k]\n            (reduce (fn [acc nx]       ;nx for next x\n                      (let [nxv (reduce #(if (clojure.set/superset? %2 nx)\n                                           (conj % %2)\n                                           %)\n                                        #{} xs)]\n                        (if (empty? nxv)\n                          acc\n                          (assoc acc nx nxv))))\n                    {}\n                    (strip-product xs k)))\n          (go-veitch\n            [xs]\n            (loop [ks (range 1 (inc (count (first xs))))\n                   ksv #{}]\n              (if (empty? ks)\n                ksv\n                (recur (rest ks)\n                       (reduce (fn [acc e]\n                                 (if (= (count (second e))\n                                        (int (Math/pow 2 (- (count (first xs))\n                                                            (first ks)))))\n                                   (conj acc (first e))\n                                   acc))\n                               ksv\n                               (merge-v xs (first ks)))\n                       ))\n              ))\n          (simplify [xs]\n            (let [maxcount (apply max (map count xs))]\n              (loop [xs (sort-by count xs)\n                     result {}]\n                (if (empty? xs) result ; shouldn't execute here\n                    (recur (rest xs)\n                           (#(if (> (count %) 0)\n                               (assoc result #{(first xs)} %)\n                               result\n                               )\n                            (reduce\n                             (fn [acc e] (if (and (= (count e) maxcount)\n                                                  (clojure.set/superset? e (first xs)))\n                                           (conj acc e)\n                                           acc))\n                             #{} xs))))\n                )\n              ))\n          (merge-ss [fss ss]\n            (reduce\n             (fn [acc e]\n               (merge\n                acc\n                (reduce\n                 #(if (clojure.set/superset? (first %2) (first e))\n                    %\n                    (assoc % (clojure.set/union (first e)\n                                                (first %2))\n                           (clojure.set/union (second e)\n                                              (second %2))))\n                 {}\n                 (dissoc ss (first e)))\n                ))\n             {}\n             fss))\n          (elimate [xs fss ss]             ;use least ss key to satisfy xs\n            (loop [rss ss\n                   result []]\n              (cond (= (second (first rss)) xs) (recur (rest rss) (conj result (ffirst rss)))\n                    (and (empty? rss) (empty? result)) (elimate xs fss (merge-ss fss ss))\n                    (empty? rss) result\n                    :else (recur (rest rss) result))\n              )\n            )\n          ]\n\n    (apply min-key #(apply + (map count %)) (#(elimate xs % %) (simplify (go-veitch xs))))\n    ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 140, "code": "(fn vitchX[truth]\n\t(letfn [\n\t\t(isBothDashesOrNeither[ax bx]\n\t\t\t(let [\n\t\t\t\taxDash (= ax '-)\n\t\t\t\tbxDash (= bx '_)\n\t\t\t\t]\n\t\t\t\t(or \n\t\t\t\t\t(and axDash bxDash )\n\t\t\t\t\t(and (not axDash) (bxDash))\n\t\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t(haveDashesSamePlace[a b]\n\t\t\t(filter #(isBothDashesOrNeither (first %)(second %)) (map vector a b))\n\t\t)\t\n\n\t\t(haveOneDifference[a b]\n\t\t\t(= (count (filter #(apply not= %) (map vector a b))) 1)\n\t\t)\n\n\t\t(haveOneDifferenceConsideringDashes[a b]\n\t\t\t(and\n\t\t\t\t(haveDashesSamePlace a b)\n\t\t\t\t(haveOneDifference a b)\n\t\t\t)\n\t\t)\n\n\n\t\t(dashForDifference[ax bx]\n\t\t\t(if (= ax bx)\n\t\t\t\tax\n\t\t\t\t'-\n\t\t\t)\n\t\t)\n\n\t\t(markDifference[a b]\n\t\t\t(map dashForDifference a b)\n\t\t)\n\n\t\t(makeImplicant[implicant values previousLevel]\n\t\t\t{ :implicant implicant :values (set values) :previous previousLevel }\n\t\t)\n\n\n\t\t(nextLevelRes[toCheck others]\n\t\t\t(if (empty? others)\n\t\t\t\t'()\n\t\t\t\t(let [\n\t\t\t\t\tdifferent (filter #(haveOneDifferenceConsideringDashes (:implicant toCheck) (:implicant %)) others)\n\t\t\t\t\timplicants (map #(makeImplicant (markDifference (:implicant toCheck) (:implicant %)) (set (concat (:values toCheck)(:values %))) #{(:implicant toCheck)(:implicant %)}   ) different)\n\t\t\t\t\t]\n\t\t\t\t\t(concat implicants (nextLevelRes (first others) (rest others) ))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t(nextLevel[implicants]\n\t\t\t(nextLevelRes (first implicants) (rest implicants))\n\t\t)\n\n\t\t(fromTruthToSimpleImplicants[truth]\n\t\t\t(map #(makeImplicant % [%] #{}) truth)\n\t\t)\n\n\t\t(sortfn[v]\n\t\t\t(case v\n\t\t\t\tA 0\n\t\t\t\ta 0\n\t\t\t\tB 1\n\t\t\t\tb 1\n\t\t\t\tC 2\n\t\t\t\tc 2\n\t\t\t\tD 3\n\t\t\t\td 3\n\t\t\t)\n\t\t)\n\n\t\t(toVectorTruth[truth ]\n\t\t\t(map #(sort-by sortfn %) truth)\n\t\t)\n\n\t\t(noPreviousImplicant[levelX previous]\n\t\t\t(not-any? #(contains? (:previous %) previous) levelX)\n\t\t)\n\n\n\t\t(noPreviousImplicants[levelX levelX_1]\n\t\t\t(filter #(noPreviousImplicant levelX (:implicant %)) levelX_1)\n\t\t)\n\n\t\t(primeImplicants[level1 level2 level3]\n\t\t\t(concat \n\t\t\t\t(noPreviousImplicants level2 level1)\n\t\t\t\t(noPreviousImplicants level3 level2)\n\t\t\t\tlevel3\n\t\t\t)\n\t\t)\n\n\t\t(oneWithoutPrevious[implicant]\n\t\t\t{:implicant (:implicant implicant) :values (:values implicant)}\n\t\t)\n\n\t\t(withoutPrevious[implicants]\n\t\t\t(map oneWithoutPrevious implicants)\n\t\t)\n\n\n\t\t(areIndepedent[a b]\n\t\t\t(let [empt (empty? (clojure.set/intersection (:values a) (:values b)))]\n\t\t\t\tempt\n\t\t\t)\n\t\t)\n\n\n\t\t(essential?[toCheck others]\n\t\t\t(every? #(areIndepedent toCheck %) others)\n\t\t)\n\n\t\t(extractEssentials[implicants]\n\t\t\t(if (empty? implicants)\n\t\t\t\t'()\n\t\t\t\t(let [\n\t\t\t\t\tone (first implicants)\n\t\t\t\t\tothers (rest implicants)\n\t\t\t\t\t]\n\t\t\t\t\t(if (essential? one others)\n\t\t\t\t\t\t(cons one (extractEssentials others))\n\t\t\t\t\t\t(extractEssentials others)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\n\t\t(withoutValues[primes]\n\t\t\t(map #(:implicant %) primes)\n\t\t)\n\n\t\t(handledBy[implicants]\n\t\t\t(mapcat #(:values %) implicants)\n\t\t)\n\n\t\t(includesValues[a b]\n\t\t\t(every? #(contains? a %) b)\n\t\t)\n\n\t\t(handling[implicants values]\n\t\t\t(filter #(includesValues (:values % ) values) implicants)\n\t\t)\n\n\t\t(valueWithoutDashes[value]\n\t\t\t(filter #(not= % '-) value)\n\t\t)\n\n\n\t\t(withoutDashes[values]\n\t\t\t(map valueWithoutDashes values)\n\t\t)\n\n\t\t(toSets[values]\n\t\t\t(set (map set values))\n\t\t)\n\t]\n\t\t(let [\n\t\t\tvecTruth (toVectorTruth truth)\n\t\t\tlevel1 (fromTruthToSimpleImplicants vecTruth)\n\t\t\tlevel2 (set (nextLevel level1))\n\t\t\tlevel3 (set (nextLevel level2))\n\t\t\tprimesWithPrevious (set (primeImplicants level1 level2 level3))\n\t\t\tprimes (set (withoutPrevious primesWithPrevious))\n\t\t\tessentials (set (extractEssentials (into '() primes)))\n\t\t\tnotEssentials (clojure.set/difference primes essentials)\n\t\t\thandledByEssentials (set (handledBy essentials))\n\t\t\tnotHandledByEssentials (clojure.set/difference (set vecTruth) handledByEssentials)\n\t\t\tnotEssentialsHandling (set (handling notEssentials notHandledByEssentials))\n\t\t\tsolution (clojure.set/union essentials notEssentialsHandling)\n\t\t\t]\n\t\t\t(toSets (withoutDashes (withoutValues solution)))\n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 140, "code": "(fn [ss] \n    (let [simplifiable? (fn [x y] (and\n                                    (= (set (map clojure.string/upper-case x))\n                                       (set (map clojure.string/upper-case y)))\n                                    (= 1 (count (clojure.set/difference x y)))))\n                                  \n          simplifications (fn [ss] (set (for [x ss y ss :when (simplifiable? x y)] (clojure.set/intersection x y))))\n                                          \n          generates? (fn [ss mins]\n                        (every? (fn [s] (some #(clojure.set/subset? % s) mins)) ss))]\n\n      (->> (iterate simplifications ss)\n           (take-while (partial not= #{}))\n           reverse\n           (reduce (fn [x y] (clojure.set/union x (remove #(generates? #{%} x) y))))\n           ((fn [s] (remove #(generates? ss (disj s %)) s)))\n           set)))", "user": "56b86e64e4b0f26550335924"}, {"problem": 140, "code": "(fn [s]\n  (letfn [(simplify [s]\n            (reduce into #{}\n                    (map #(let [x (reduce (fn [acc x]\n                                            (let [d1 (clojure.set/difference % x) d2 (clojure.set/difference x %)]\n                                              (if (and (= 1 (count d1) (count d2))\n                                                       (= (.toUpperCase (apply str d1))\n                                                          (.toUpperCase (apply str d2))))\n                                                (conj acc (set (remove d1 %)))\n                                                acc))) #{} \n                                          s)]\n                            (if (empty? x) #{%} x))\n                         s)))\n          (complicate [s]\n            (let [a (keep #{'a 'A} s)\n                  b (keep #{'b 'B} s)\n                  c (keep #{'c 'C} s)\n                  d (keep #{'d 'D} s)\n                  f (fn [s u l] (reduce #(conj % (conj %2 u) (conj %2 l)) #{} s))]\n              (->> #{s}\n                   (#(if (empty? a) (f % 'A 'a) %))\n                   (#(if (empty? b) (f % 'B 'b) %))\n                   (#(if (empty? c) (f % 'C 'c) %))\n                   (#(if (empty? d) (f % 'D 'd) %))\n                   )))\n          (remdup [s]\n            (let [complicates (reduce #(into % (complicate %2)) #{} s)]\n              (reduce (fn [acc x] (let [complicates (reduce #(into % (complicate %2)) #{} (remove #(= % x) s))]\n                                    (if (contains? (->> complicates simplify simplify) x)\n                                      acc\n                                      (conj acc x))))\n                      #{} s)))]\n    (->> s\n         simplify\n         simplify\n         remdup)))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 140, "code": "(fn [algebra]\n  (letfn [(union [s1 s2]\n            (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n          (step [algebra]\n            (let [r (set (flatten (map\n                                    (fn [line]\n                                      (let [m (map\n                                                #(set (conj\n                                                        (remove #{%} line)\n                                                        (case (str %)\n                                                          \"a\" 'A\n                                                          \"A\" 'a\n                                                          \"b\" 'B\n                                                          \"B\" 'b\n                                                          \"c\" 'C\n                                                          \"C\" 'c\n                                                          \"d\" 'D\n                                                          \"D\" 'd)))\n                                                line)\n                                            s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                        (if (seq s) s line)))\n                                    algebra)))]\n              (if (not= r algebra) (step r) algebra)))\n          (power-set [s]\n            (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))]\n    (let [ps (power-set (step algebra))]\n      (apply\n        (partial min-key count)\n        (filter\n          (complement nil?)\n          (map\n            (fn [s]\n              (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) algebra)) s))]\n                (if (= r algebra) \n                  s)))\n           ps))))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 140, "code": "(fn f140\n  ;; Minimize boolean functions described by minterms with\n  ;; Quine\u2013McCluskey algorithm. The implementation is not complete.\n  ;; It only returns essential prime implicants which not always\n  ;; cover all min terms, but for given test cases it always does ;)\n  ;; It also doesn't try to optimise number of combining of terms\n  ;; and just combine all permutations.\n  [min-terms]\n  (letfn [(term-set->bin\n            ;; Converts set representation of term to binary.\n            ;; (term-set->bin '#{A c D}) => [1 - 0 1]\n            [min-term]\n            (map (fn [[sym0 sym1]]\n                   (cond (min-term sym0) 0\n                         (min-term sym1) 1\n                         :else '-))\n                 '[[a A][b B][c C][d D]]))\n\n          (term-bin->set\n            ;; Converts binary representation of term to set.\n            ;; (term-bin->set [0 1 - 1]) => #{a B D}\n            [min-term]\n            (->> (map (fn [v [sym0 sym1]]\n                        (condp = v\n                          0 sym0\n                          1 sym1\n                          nil))\n                      min-term\n                      '[[a A][b B][c C][d D]])\n                 (remove nil?)\n                 set))\n\n          (same-domain?\n            ;; Checks that terms are from the same domain,\n            ;; that is, they had same bit merged before.\n            ;; (same-domain? '[1 - - 1] '[0 - - 0]) => true\n            [term1 term2]\n            (->> (map #(or (and (= %1 '-)\n                                (= %2 '-))\n                           (and (not= %1 '-)\n                                (not= %2 '-)))\n                      term1\n                      term2)\n                 (every? true?)))\n\n          (term-changes-count\n            ;; Returns number of changes between terms.\n            ;; (term-changes-count '[1 1 - 1] '[1 0 - 1]) => 1\n            [term1 term2]\n            (reduce +\n                    (map #(if (= %1 %2) 0 1)\n                         term1\n                         term2)))\n\n          (combine-terms\n            ;; Return combined terms. Returns nil if terms are from differend domain\n            ;; or number of differences is more than 1.\n            ;; (combine-terms [1 1 0 0] [1 1 1 0]) => [1 1 - 0]\n            [term1 term2]\n            (if (and (same-domain? term1 term2)\n                     (<= (term-changes-count term1 term2) 1))\n              (map #(if (= %1 %2) %1 '-)\n                   term1\n                   term2)\n              nil))\n\n          (terms-matches?\n            ;; (terms-matches? '[1 - - 0] '[1 - 1 0]) => true\n            [term1 term2]\n            (->> (map #(or (= %1 %2)\n                           (= %1 '-)\n                           (= %2 '-))\n                      term1\n                      term2)\n                 (every? true?)))\n\n          (permutations\n            ;; Returns all permutations of terms\n            ;;\n            ;; (permutations [1 2 3]) => ([1 2] [1 3] [2 1] [2 3] [3 1] [3 2])\n            [coll]\n            (for [e1 coll\n                  e2 coll\n                  :when (not= e1 e2)]\n              [e1 e2]))\n\n          (group-merge-by-first\n            ;; Return map which groups rest of each collection by first element.\n            ;; Rest of colls are merged for same first element.\n            ;;\n            ;; (group-merge-by-first [[1 2][1 3 4][2 5]]) => {1 (2 3 4), 2 (5)}\n            [colls]\n            (->> colls\n                 (map (fn [[x & xs]] {x xs}))\n                 (apply merge-with concat)))\n\n          (qm-iterate\n            ;; Quine\u2013McCluskey algorithm - one iteration.\n            ;; Terms count must be more at least 2.\n            ;; It returns final terms and terms which needs to be\n            ;; combined in next iteration of Quine\u2013McCluskey algorithm.\n            [terms]\n            (let [res (->> terms\n                           permutations\n                           group-merge-by-first\n                           (map (fn [[key-term terms]]\n                                  [key-term (keep #(combine-terms key-term %)\n                                                  terms)])))\n                  final-terms (->> res\n                                   (filter #(empty? (second %)))\n                                   (map first))\n                  next-turn-terms (->> res\n                                       (map second)\n                                       (apply concat)\n                                       set)]\n              [final-terms next-turn-terms]))\n\n          (qm\n            ;; Execute Quine\u2013McCluskey algorithm on given terms.\n            [terms]\n            (loop [final-terms #{}\n                   terms terms]\n              (if (< (count terms) 2)\n                (into final-terms terms)\n                (let [[iteration-final-terms terms] (qm-iterate terms)]\n                  (recur (into final-terms iteration-final-terms)\n                         terms)))))\n\n          (extract-essential-terms\n            ;; Extracts essential prime implicants from terms returned\n            ;; from Quine\u2013McCluskey algorithm for given inital min-terms\n            [min-terms qm-terms]\n            (->> min-terms\n                 (map (fn [min-term]\n                        (filter #(terms-matches? min-term %) qm-terms)))\n                 (filter #(= 1 (count %)))\n                 (apply concat)\n                 (distinct)))]\n\n    (let [min-terms (map term-set->bin min-terms)]\n      (->> (extract-essential-terms min-terms\n                                    (qm min-terms))\n           (map term-bin->set)\n           set))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 140, "code": "(fn\n  veitch-karnaugh\n  [board]\n  (let [opposed-vals '{a A b B c C d D A a B b C c D d}\n        minimize-fn (fn [rules]\n                      (apply hash-set (distinct (mapcat (fn [rule] (let [res (filter identity (map (fn [v] (if (contains? rules (conj (disj rule v) (v opposed-vals))) (disj rule v))) rule))] (if (< 0 (count res)) res [rule]))) rules))))\n        full-minimize (fn full-minimize [rules]\n                       (let [result (minimize-fn rules)]\n                         (if (= rules result) rules (full-minimize result))))\n        filter-comparable (fn [rule rules]\n                            (not-every? (fn [v] (some #(contains? % v) rules)) rule))]\n    (let [result (full-minimize board)]\n      (if (= result board)\n        board\n        (apply hash-set (filter #(filter-comparable % (disj result %)) result))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 140, "code": "(fn [all-input-sets]\n\n  (letfn [(input-name [input]\n            (symbol (clojure.string/lower-case (str input))))\n\n          (input-value [input]\n            (let [string (str input)]\n              (= string (clojure.string/upper-case string))))\n\n          (set-to-map [input-set]\n            (reduce (fn [m input] (assoc m (input-name input) (input-value input)))\n                    {}\n                    input-set))\n\n          (name-and-value-to-input [name value]\n            (symbol ((if value clojure.string/upper-case identity) (str name))))\n\n          (map-to-set [input-map]\n            (set (map (fn [k] (name-and-value-to-input k (k input-map)))\n                      (keys input-map))))\n\n          (generate-steps [input-map]\n            (map (fn [k] (assoc input-map k (not (k input-map))))\n                 (keys input-map)))\n\n          (inputs-with-same-value [im1 im2]\n            (filter (fn [k] (= (k im1) (k im2))) (keys im1)))\n\n          (valid-steps [input-set all-input-sets]\n            ((comp (partial filter (partial contains? all-input-sets))\n                   (partial map map-to-set)\n                   generate-steps\n                   set-to-map)\n             input-set))\n\n          (find-cycles-from-input-set [all-input-sets path current-input-set]\n            (if (contains? (set path) current-input-set)\n              (list (conj (take-while (partial not= current-input-set) path)\n                          current-input-set))\n              (reduce concat '() (map (partial find-cycles-from-input-set\n                                               all-input-sets\n                                               (conj path current-input-set))\n                                      (valid-steps current-input-set all-input-sets)))))\n\n          (merge-cycles-from-input-set [all-input-sets cycle-set input-set]\n            (clojure.set/union cycle-set\n                               ((comp set\n                                      (partial map set)\n                                      (partial find-cycles-from-input-set all-input-sets '()))\n                                input-set)))\n\n          (unitary-cycles [all-input-sets]\n            (map list all-input-sets))\n\n          (find-cycles [all-input-sets]\n            ((comp (partial map set-to-list)\n                   set-to-list\n                   (partial reduce\n                            (partial merge-cycles-from-input-set all-input-sets)\n                            (unitary-cycles all-input-sets)))\n             all-input-sets))\n\n          (compare-paths-desc [path1 path2]\n            (let [count1 (count path1)\n                  count2 (count path2)]\n              (cond (< count1 count2) 1\n                    (> count1 count2) -1\n                    :else 0)))\n\n          (is-power-of-2 [x]\n            (if (= x 0) false\n                (loop [n x\n                       r 0]\n                  (cond (and (= n 1) (= r 0)) true\n                        (> r 0) false\n                        :else (recur (int (/ n 2))\n                                     (rem n 2))))))\n\n          (filter-pow2-lengths [seqs]\n            (filter (comp is-power-of-2 count) seqs))\n\n          (set-to-list [s]\n            (map identity s))\n\n          (unique-pow2-cycles [all-input-sets]\n            ((comp (partial sort compare-paths-desc)\n                   set-to-list)\n             (reduce conj\n                     #{}\n                     ((comp (partial map set)\n                            filter-pow2-lengths)\n                      (find-cycles all-input-sets)))))\n\n          (union-of-sets-in-set [set-of-sets]\n            (apply clojure.set/union (set-to-list set-of-sets)))\n\n          (required-cycle? [input-sets all-cycles cycle]\n            (not= input-sets\n                  (set (union-of-sets-in-set (clojure.set/difference (set all-cycles)\n                                                                     (set (list cycle)))))))\n\n          (cycle-adds-inputs? [input-sets all-cycles cycle]\n            (not= input-sets\n                  (set (union-of-sets-in-set (set (conj all-cycles cycle))))))\n\n          (cycles-covering-all-input-sets [all-input-sets cycle-list]\n            (loop [cycles cycle-list\n                   sum #{}\n                   result '()]\n              (cond (= sum all-input-sets) result\n                    :else (recur (rest cycles)\n                                 (clojure.set/union sum (first cycles))\n                                 (if (cycle-adds-inputs? sum result (first cycles))\n                                   (conj result (first cycles))\n                                   result)))))\n\n          (remove-redundant-cycles [all-input-sets cycles]\n            (filter (partial required-cycle? all-input-sets cycles) cycles))\n\n          (common-inputs [set-of-input-sets]\n            (reduce clojure.set/intersection set-of-input-sets))\n\n          (solve [all-input-sets]\n            ((comp set\n                   (partial map common-inputs)\n                   (partial remove-redundant-cycles all-input-sets)\n                   (partial cycles-covering-all-input-sets all-input-sets))\n             (unique-pow2-cycles all-input-sets)))]\n\n    (solve all-input-sets)))", "user": "573b7ebbe4b0cd1946bd10a9"}, {"problem": 140, "code": "(fn [s]\n  (letfn [(sym->bin\n           [sym]\n           (let [s (str sym)]\n             (if (= s (clojure.string/upper-case s)) 1 0)))\n          (diff-one-digit?\n           [s1 s2]\n           (->> (map vector s1 s2)\n                (filter (fn [[x y]] (not= x y)))\n                (count)\n                (= 1)))\n          (replace-diff-digit\n           [s1 s2]\n           (->> (map vector s1 s2)\n                (map (fn [[x y]] (if (not= x y) '- x)))))\n          (combine-minterms\n           [s]\n           (let [s' (into #{}\n                          (apply concat\n                                 (for [x s]\n                                   (if-let [digits-sequence (seq (filter (partial diff-one-digit? x) s))]\n                                     (map (partial replace-diff-digit x) digits-sequence)\n                                     (list x)))))]\n             (if (= s s')\n               s\n               (recur s'))))\n          (reduce-minterms\n           [s]\n           (cond\n            (= 1 (count s)) s\n            (nil? (some #(= '- %) (flatten (seq s)))) s\n            :else (remove nil?\n                   (for [x s]\n                     (let [fs (map set (apply map vector (remove #(= x %) s)))\n                           x' (map (fn [f v] (f v)) fs x)]\n                       (if (some nil? x')\n                         x))))))\n          (upper-case-sym\n           [sym]\n           ((comp symbol clojure.string/upper-case str) sym))\n          (lower-case-sym\n           [sym]\n           ((comp symbol clojure.string/lower-case str) sym))\n          (digits->syms\n           [syms digits]\n           (let [avec (map vector digits syms)]\n             (remove nil?\n                     (map (fn [[a b]]\n                            (cond\n                             (= 0 a) (lower-case-sym b)\n                             (= 1 a) (upper-case-sym b)))\n                          avec))))]\n    (let [minterms (map (partial sort-by clojure.string/upper-case) s)\n          syms (first minterms)]\n      (->> minterms\n           (map (fn [c] (map #(sym->bin %) c)))\n           (combine-minterms)\n           (reduce-minterms)\n           (map (partial digits->syms syms))\n           (map set)\n           (set)))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 140, "code": "(fn table->simplified\n  [table]\n  (letfn [(sym-true?\n            [c]\n            (contains? #{'A 'B 'C 'D} c))\n          \n          (input->point\n            [point]\n            (case (count point)\n              1 (if (sym-true? (first point)) 1 0)\n              2 (let [[x y] point] (case (mapv sym-true? [x y])\n                                     [false false] 0\n                                     [false true] 1\n                                     [true true] 2\n                                     [true false] 3))\n              3 (let [[x y z] point] [(input->point [x y]) (input->point [z])])\n              4 (let [[x y w z] point] [(input->point [x y]) (input->point [w z])])))\n\n          (create-kmap\n            [kmap-points]\n            (apply hash-map (interleave kmap-points (repeat false))))\n\n          (table->kmap-points\n            [table]\n            (map (fn [x] (->> x\n                              (sort-by #(clojure.string/lower-case (name %)))\n                              (input->point)))\n                 table))\n\n          (point->input\n            [width [x y]]\n            (->>\n             (concat\n              ('{0 [a b], 1 [a B], 2 [A B], 3 [A b]} x)\n              ((if (= width 3)\n                 '{0 [c], 1 [C]}\n                 '{0 [c d], 1 [c D], 2 [C D], 3 [C d]}) y))\n             (set)))\n\n          (simplify-inputs\n            [inputs]\n            (->>\n             (let [syms (set (apply concat inputs))]\n               (mapcat\n                (fn [[t f]]\n                  (cond\n                    (and (syms t) (syms f)) []\n                    (syms t) [t]\n                    (syms f) [f]\n                    :else []))\n                '[[a A] [b B] [c C] [d D]]))\n             set))\n\n          (get-offset-rect\n            [[off-x off-y] width rect]\n            (map (fn [[x y]] [(mod (+ off-x x) 4) (mod (+ off-y y) width)])\n                 rect))\n\n          (rects-by-size\n            [kmap-width]\n            (for [max-i (range 1 (inc 4))\n                  max-j (range 1 (inc kmap-width))\n                  :when (#{1 2 4 8 16} (* max-i max-j))]\n              (for [i (range 0 max-i)\n                    j (range 0 max-j)]\n                [i j])))\n\n          (get-rects\n            [width]\n            (->> (rects-by-size width)\n                 (sort-by count)\n                 (reverse)))\n\n          (rect-fits?\n            [rect kmap]\n            (let [kmap-points (keys kmap)\n                  matching-points (filter (set rect) kmap-points)]\n              (and (every? (set kmap-points) rect)\n                   (some #(not (kmap %)) matching-points))))\n\n          (kmap-set-rect\n            [kmap rect]\n            (reduce (fn [map x] (assoc map x true))\n                    kmap\n                    rect))\n\n          (input-kmap-filled?\n            [[input kmap]]\n            (when (not-any? #(not (identity %)) (vals kmap))\n              [input kmap]))\n\n          (apply-rect-to-kmap\n            [[x y] rect width [inputs kmap]]\n            (let* [kmap-points (keys kmap)\n                   offset-rect (get-offset-rect [x y] width rect)]\n              (if (rect-fits? offset-rect kmap)\n                [(into inputs [#_(simplify-inputs (map #((partial point->input width) %)\n                                                       offset-rect))\n                               (map #((partial point->input width) %)\n                                    offset-rect)])\n                 (kmap-set-rect kmap offset-rect)]\n                [inputs kmap])))\n\n          (apply-rect-to-all-kmap-points\n            [width rect [inputs kmap]]\n            (let [kmap-points (keys kmap)\n                  input-kmaps' (set (map\n                                     (fn [point]\n                                       (apply-rect-to-kmap point\n                                                           rect\n                                                           width\n                                                           [inputs kmap]))\n                                     kmap-points))]\n              input-kmaps'))\n\n          (find-solution\n            [width [rect & next-rects :as rects] input-kmaps]\n            (if-let [solutions (seq (filter input-kmap-filled? input-kmaps))]\n              (set (map simplify-inputs (first (sort-by count (map first solutions)))))\n              (let [input-kmaps' (into (set (mapcat #(apply-rect-to-all-kmap-points width rect %)\n                                                    input-kmaps))\n                                       input-kmaps)]\n                (cond\n                  (= input-kmaps input-kmaps') (recur width next-rects input-kmaps')\n                  :else (recur width rects input-kmaps')))))]\n    (let [width (count (first table))\n          rects (get-rects width)\n          kmap-points (table->kmap-points table)\n          kmap (create-kmap kmap-points)\n          input-kmap [#{} kmap]]\n      (find-solution width rects [input-kmap]))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 140, "code": "(\nletfn\n[\n(get-kmap\n  [cms]\n  (let [gray-codes [\"00\" \"01\" \"11\" \"10\"]]\n    (for [row gray-codes\n          :let [c (if (= \\1 (first row)) 'C 'c)\n                d (if (= \\1 (second row)) 'D 'd)]\n         ]\n      (for [col gray-codes\n            :let [a (if (= \\1 (first col)) 'A 'a)\n                  b (if (= \\1 (second col)) 'B 'b)]\n           ]\n           [#{a b c d} (boolean (some #(agrees % #{a b c d}) cms))]))))\n(double\n  [xs]\n  (concat xs xs))\n(quadruple\n  [xss]\n  (double (map double xss)))\n(get-slices\n  [brd x y]\n  (let [w (count (first brd))\n        h (count brd)]\n    (for [l (range 0 (inc (- w x)))\n          u (range 0 (inc (- h y)))]\n      (apply concat (take y (drop u (map #(take x (drop l %)) brd)))))))\n(get-all-slices\n  [brd]\n  (apply concat\n    (for [x (reverse (range 1 (inc (count (first brd)))))\n          y (reverse (range 1 (inc (count brd))))]\n      (get-slices brd x y))))\n(deep-find\n  [what where]\n  (boolean (some #(what %) (flatten where))))\n(is-pow2\n  [n]\n  (cond\n    (== n 1) true\n    (< n 1) false\n    :else (recur (/ n 2))))\n(agrees\n  [s1 s2]\n  (every? #(not (s1 ('{A a, B b, C c, D d, a A, b B, c C, d D} %))) s2))\n(solve\n  [cms]\n  (let [\n        kmap          (quadruple (get-kmap cms))\n        slices        (filter (fn [slice] (every? second slice)) (get-all-slices kmap))\n        grouped       (group-by (fn [slice] (set (sort (apply clojure.set/intersection (map first slice))))) slices)\n        pow2-slices   (remove (comp empty? second) (into {} (map (fn [[k v]] [k (filter #(is-pow2 (count %)) v)]) grouped)))\n        max-slices    (map (fn [[k v]] [k (apply max-key count v)]) pow2-slices)\n        simplify      (remove (fn [[k v]] (some (fn [[k1 v1]] (and (not= k1 k) (clojure.set/subset? k1 k))) max-slices)) max-slices)\n        sets          (map first simplify)\n        simple-sets\n          (if (= 1 (count sets))\n            sets\n            (filter\n              (complement\n                (fn [s]\n                  (and\n                    (clojure.set/subset? s (apply clojure.set/union (remove #(= % s) sets)))\n                    (every? #(agrees % s) (remove #(= % s) sets)))))\n              sets))\n        ]\n  (set simple-sets))\n  )\n]\nsolve)", "user": "57717915e4b0979f896515b3"}, {"problem": 140, "code": "(letfn\n    [(wl [kmap]\n       [(count (first kmap)) (count kmap)])\n\n     (divs [w l x]\n       (for [i (range 1 (inc l)) j (range 1 (inc w)) :when (= x (* i j))] [i j]))\n\n     (pows [lim]\n       (for [i (iterate #(* 2 %) 1) :while (< i lim)] i))\n\n     (term [kmap [start-y start-x] [y x]]\n       (let [[w l] (wl kmap)]\n         (for [dy (range y) dx (range x)\n               :let [i (mod (+ start-y dy) l) j (mod (+ start-x dx) w)]]\n           [(get-in kmap [i j]) [i j]])))\n\n     (minterm? [zone]\n       (every? #{1} (map first zone)))\n\n     (minterms-iter [kmap point]\n       (let [[w l] (wl kmap)\n             corners (mapcat #(divs w l %) (pows (* w l)))]\n         (->> (map #(term kmap point %) corners)\n              (filter #(minterm? %))\n              (map #(set (map second %))))))\n\n     (smaller? [term terms]\n       (empty? (apply (partial clojure.set/difference term) terms)))\n\n     (largest\n       ([minterms] (largest (sort #(< (count %1) (count %2)) minterms) '()))\n       ([[fst & rst :as minterm] res]\n        (cond\n          (not (seq minterm)) res\n          (smaller? fst (concat res rst)) (largest rst res)\n          :else (largest rst (conj res fst)))))\n\n     (minterms [kmap]\n       (let [[w l] (wl kmap)\n             ones (for [i (range l) j (range w)\n                        :when (= 1 (get-in kmap [i j]))] [i j])]\n         (mapcat #(minterms-iter kmap %) ones)))\n\n     (gray-code [n]\n       (->> (range (Math/pow 2 n))\n            (map #(bit-xor % (bit-shift-right % 1)))\n            (map #(clojure.pprint/cl-format nil (str \"~\" n \"'0B\") %))))\n\n     (apply-gray [str code]\n       (map #(if (= %2 \\1)\n               (symbol (clojure.string/upper-case %1))\n               (symbol (clojure.string/lower-case %1))) str code))\n\n     (gray [str]\n       (map #(apply-gray str %) (gray-code (count str))))\n\n     (match? [gray samples]\n       (if (some identity (map #(every? (set gray) %) samples))\n            1 0))\n\n     (gray-map [samples]\n       (let [sample (sort (clojure.string/lower-case (apply str (first samples))))\n             mid (quot (count sample) 2)\n             sy (apply str (take mid sample))\n             sx (apply str (drop mid sample))]\n         (mapv (fn [y] (mapv (fn [x] (concat y x)) (gray sx))) (gray sy))))\n\n     (karn-map [g-map samples]\n       (mapv #(mapv (fn[node] (match? node samples)) %) g-map))\n\n     (make-disj [g-map term]\n       (let [rset (set (mapcat #(get-in g-map %) term))]\n         (remove #(and (rset (symbol (clojure.string/upper-case %)))\n                       (rset (symbol (clojure.string/lower-case %)))) rset)))]\n\n  (fn veitch [samples]\n    (let [g-map (gray-map samples)\n          k-map (karn-map g-map samples)\n          terms (largest (minterms k-map))]\n      (set (map #(set (make-disj g-map %)) terms)))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 140, "code": "(fn [algebra]\n  (letfn [(union [s1 s2]\n            (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n          (step [algebra]\n            (let [r (set (flatten (map\n                                    (fn [line]\n                                      (let [m (map\n                                                #(set (conj\n                                                        (remove #{%} line)\n                                                        (case (str %)\n                                                          \"a\" 'A\n                                                          \"A\" 'a\n                                                          \"b\" 'B\n                                                          \"B\" 'b\n                                                          \"c\" 'C\n                                                          \"C\" 'c\n                                                          \"d\" 'D\n                                                          \"D\" 'd)))\n                                                line)\n                                            s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                        (if (seq s) s line)))\n                                    algebra)))]\n              (if (not= r algebra) (step r) algebra)))\n          (power-set [s]\n            (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))]\n    (let [ps (power-set (step algebra))]\n      (apply\n        (partial min-key count)\n        (filter\n          (complement nil?)\n          (map\n            (fn [s]\n              (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) algebra)) s))]\n                (if (= r algebra) s))\n                            )\n            ps))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 140, "code": "(fn veitch [terms]                                                                                                    \n  (letfn [(complement* [x] \n                       ({'a 'A 'A 'A \n                         'b 'B 'B 'b \n                         'C 'c 'c 'C \n                         'd 'D 'D 'd} x))\n          (mrg [ret [a b]]                                                                                              \n            (let [ab (clojure.set/intersection a b)]                                                                    \n              (if (and (= (count ab) (dec (count a)))                                                                   \n                       (= (.toLowerCase (str (first (clojure.set/difference a ab))))                                    \n                          (.toLowerCase (str (first (clojure.set/difference b ab))))))                                  \n                (disj (conj ret ab) a b)                                                                                \n                ret)))\n          (reduce-pairwise [terms]                                                                                      \n            (let [v (vec terms)]                                                                                        \n              (reduce mrg                                                                                               \n                      terms                                                                                             \n                      (for [i (range (count v))                                                                         \n                            j (range (inc i) (count v))]                                                                \n                        [(v i) (v j)]))))                                                                               \n          (tautology? [expr]                                                                                            \n            (let [vars (apply clojure.set/union expr)]                                                                   \n              (and (not (empty? vars))                                                                                  \n                   (every? #(contains? vars (complement* %)) vars))))                                                   \n          (remove-tautologies [expr]                                                                                    \n            (reduce (fn [ret term]                                                                                      \n                      (let [e (->> (disj ret term)                                                                      \n                                   (map (fn [t] (clojure.set/difference t term)))                                                       \n                                   set)]                                                                                \n                        (if (tautology? e) (disj ret term) ret)))                                                       \n                    expr\n                    expr))] \n    (->> terms                                                                                                          \n         (iterate reduce-pairwise)                                                                                      \n         (partition 2 1)                                                                                                \n         (drop-while (partial apply not=))                                                                           \n         ffirst                                                                                                         \n         remove-tautologies)))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 140, "code": ";using Quine\u2013McCluskey algorithm\n(fn [s]\n         (let [remerge (fn [m] (if (empty? m) {} (reduce #(merge-with (comp set concat) %1 %2) m)))\n               gen (fn [ss] (remerge (for [x ss]\n                                       (let [inte (fn [y] (clojure.set/intersection x y))\n                                             diff (fn [y] (clojure.set/difference x y))\n                                             upper (fn [i] (clojure.string/upper-case i))]\n                                         (remerge (map \n                                                   #(if (and (= (dec (count x)) (count (inte %)))\n                                                             (= (set (map upper %)) (set (map upper x))))\n                                                      (hash-map (inte %) (conj #{} x %)) {} )\n                                                   (disj ss x)))))))\n               dist (fn [m] (set (keys (filter #(not= (val %) \n                                                      (clojure.set/intersection (val %) (set (reduce concat (vals (dissoc m (key %)))))))\n                                               m))))]\n           (loop [p s m {} his {} step 0]\n             (cond\n               (and (= 0 step) (empty? (gen p))) s\n               (empty? (gen p)) (dist (remerge (map #(hash-map % (his %)) p)))\n               :else (recur \n                      (reduce conj (set (keys m)) (clojure.set/difference p (set (reduce concat (vals m)))))\n                      (gen p)\n                      (merge-with (comp set concat) his (if (empty? m) {} \n                                                            (remerge (for [x m]\n                                                                       (if (not (empty? (his (first (val x)))))\n                                                                         (hash-map (key x) (set (reduce concat (map his (val x)))))\n                                                                         (hash-map (key x) (val x)))))))\n                      (inc step))))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 140, "code": "(fn veitch [mt] \n  (letfn [(kcomb ([n coll] (flatten (kcomb n (seq coll) #{})))\n            ([n coll so-far] (if (zero? n) so-far (map #(kcomb (dec n) (drop (inc %) coll) (conj so-far (nth coll %)))\n                                                       (range (count coll))))))\n          (coord [ax t] (->> ax (map-indexed #(vector %1 (count (clojure.set/intersection t %2))))\n                             (filter #(= (second %) (count (first ax)))) ffirst))]\n    (let [pairs [#{'A 'a} #{'B 'b} #{'C 'c} #{'D 'd}] rp [0 1 3]\n          xc [#{'a 'b} #{'a 'B} #{'A 'B} #{'A 'b}] xl 4\n          yc (if (= (count (first mt)) 4) [#{'c 'd} #{'c 'D} #{'C 'D} #{'C 'd}] [#{'c} #{'C}]) yl (count yc) \n          coords (set (map #(vector (coord yc %) (coord xc %)) mt))\n          sq (fn [[y x] [h w]] (set (for [i (range y (+ y h 1)) j (range x (+ x w 1))] (coords [(mod i yl) (mod j xl)]))))\n          sqs (->> (for [y (range yl) x (range xl) h rp w rp] (sq [y x] [h w]))\n                   (remove (partial some nil?))\n                   (sort-by count >)\n                   (reduce (fn [r e] (if (some #(= (into % e) %) r) r (conj r e))) []))]\n      (->> (for [n (range (count sqs) 0 -1)] (kcomb n sqs))\n           (apply concat)\n           (filter #(= coords (apply clojure.set/union %)))\n           (sort-by count) first\n           (map (fn [e] (apply clojure.set/union (map (fn [f] (into (into #{} (nth yc (first f))) (nth xc (second f)))) e))))\n           (map (fn [e] (reduce (fn [r p] (if (every? r p) (apply disj r p) r)) e pairs)))\n           set))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 140, "code": "(fn f [p]\n  (let [p (reduce (fn [i e] (let [r (some #(when (nil? (some e %)) %) [['A 'a] ['B 'b] ['C 'c] ['D 'd]])]\n            (if (seq r) (into i (map #(conj e %) r)) (conj i e))))\n           #{} p)\n        o (reduce #(conj %1 (mapv (fn [e] (some #{`#{~@e ~@%2}} p))\n                              [['a 'b] ['a 'B] ['A 'B] ['A 'b]]))\n            [] [['c 'd] ['c 'D] ['C 'D] ['C 'd]])\n        k (fn [x] (take-while #(< (peek %) 4) (iterate (fn [e] (conj e (inc (peek e)))) [x])))\n        g (for [y (range 4) x (range 4)\n                :let [max-by (fn [s] (reduce (fn [i e] (if (< (count i) (count e)) e i)) [] s))]\n                :when (not= nil (get-in o [y x]))]\n            (->> (k x)\n                 (map (fn [i] (apply concat\n                   (for [j (range y 4) :let [m (map #(get-in o [j %]) i)]\n                         :while (not-any? nil? m)] m))))\n                 (remove #(zero? (rem (count %) 3)))\n                 max-by\n                 set))\n        h (reduce (fn [i e] (remove #(and (not= e %) (clojure.set/subset? % e)) i)) g g)\n        q (remove #(clojure.set/subset? % (apply clojure.set/union (remove #{%} h))) h)\n        z (reduce (fn [i e] (conj i (apply clojure.set/intersection e))) #{} q)]\n     (loop [i #{} [u & w :as z] (sort-by count > (vec z))]\n       (let [c (count u)\n             d (filter #(= c (count %)) w)\n             b (some #(when (= (dec c) (count (clojure.set/intersection u %))) %) d)]\n         (if (seq z)\n             (let [n (clojure.set/intersection u b) m (vec (remove #{b} w)) ing? (< 2 (count n))]\n               (if (and (< 2 c) (seq d) b)\n                   (recur (if ing? i (conj i n)) (if ing? (conj m n) m))\n                   (recur (conj i u) w)))\n             i)))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 140, "code": "(fn veitch [srst]\n (let \n  [mbool {true 1 false 0}\n   var-mrk :x\n   gr-seq (fn [width]\n    (let \n     [gcodes\n      (loop [acc [[(mbool false)] [(mbool true)]]] \n       (if-not (< (count (peek acc)) width) \n        acc\n        (let\n         [zacc (vec (map (partial into [(mbool false)]) acc))\n          mirr (vec (map (partial into [(mbool true)]) (reverse acc)))          \n          newacc (into zacc mirr)]\n         (recur newacc))))]\n      gcodes))\n\n   line (fn [st]\n (let [snams (map name (seq st))\n   ucnams (map clojure.string/upper-case snams)\n   zcu (map (fn [a b] (vector (first a) (first b))) snams ucnams)\n   zcu-srt (sort-by second zcu)\n   zcb (vec (map (fn [[c u]] [c (mbool (= c u))]) zcu-srt))\n   dct (vec (map second zcu-srt))\n   kbv (vec (map second zcb))] \n  (vector kbv dct) ))\n\n   minst (set (map (comp first line) srst)) \n   dict (second (line (first srst)))\n   mnwid (count (first minst))\n   krnht (quot mnwid 2)\n   krnwd (- mnwid krnht)\n   gk-all (gr-seq mnwid)\n   gk-row (gr-seq krnwd)\n   gk-col (gr-seq krnht) \n   gk-width (count gk-row) \n   gk-height (count gk-col)\n   gk-join (fn [cc rr]\n             (into cc rr))\n   gk-rows \n    (vec (map (fn [cc] (vec (map (partial gk-join cc) gk-row))) gk-col)) ]\n\n (letfn [\n  (pwr2-lz-seq []\n   (letfn [\n    (loc-pwr2s [n]\n     (lazy-seq \n      (cons n (loc-pwr2s (* 2 n)))))]\n    (loc-pwr2s 2)))\n\n  (p2-wds []\n   (into [1] (take-while (partial >= gk-width) (pwr2-lz-seq))))\n\n  (p2-hts []\n   (into [1] (take-while (partial >= gk-height) (pwr2-lz-seq))))\n\n  (pwr2? [n]\n   (let [pwr2-upto (take-while (partial >= n) (pwr2-lz-seq))\n         last-p2 (last pwr2-upto)]\n    (= last-p2 n)))\n\n  (pt-ok? [vt] (minst vt))\n\n  (vp-ok? [pts]\n   (every? pt-ok? pts))\n\n  (blk-ok? [vvblk]\n   (every? vp-ok? vvblk))\n\n  (my-strk? [pt sk]\n   (not (not-any? #(= pt %) sk)))\n\n  (my-blk? [blk pt]\n   (not (not-any? (partial my-strk? pt) blk)))\n\n  (my-blk-blk? [blk bk]\n   (let [vpts (reduce (fn [acc row] (into acc row)) [] bk)] \n    (every? (partial my-blk? blk) vpts)))\n\n  (collap-rest [blks] \n   (let [bfst (first blks)\n         brst (rest blks)]\n    (remove (partial my-blk-blk? bfst) brst)\n    #_(reduce (fn [acc b] (if (my-blk-blk? bfst b) acc (conj acc b))) [] (rest blks)) ))\n\n  (collapse-blks [blks]\n   (loop [acc [] work blks]\n    (if (empty? work)\n     acc \n     (let \n      [fst (first work)\n       rst (collap-rest work)\n       newacc (conj acc fst)] \n      (recur newacc rst)))))\n\n  (blk-ptsq [bk]\n   (reduce (fn [acc row] (into acc row)) [] bk))\n\n  (simple-pts-msk [vpts]\n   (let \n    [msk (vec (reduce (fn [z b] (map (fn [s t] (if (= s t) s var-mrk)) z b)) vpts)) ]\n     msk ))\n\n  (fmt-out [v-msk]\n   (let [vout\n    (map (fn [dc mc]\n          (if (= var-mrk mc) \n           nil \n           (if (= mc (mbool true)) dc (first (clojure.string/lower-case dc))))) \n         dict v-msk) ] \n    (set (map #(symbol (str %)) (remove nil? vout)))))\n\n  (blk-area [vvblk]\n   (* (count (first vvblk)) \n      (count vvblk)))\n\n  (g-inc [g-line g] \n     (let [xx (rest (drop-while #(not= g %) g-line))]\n      (if (empty? xx) \n        (first g-line) \n        (first xx))))\n\n  (g-dec [g-line g]\n     (let [xx (take-while #(not= g %) g-line)]\n      (if (empty? xx)\n       (last g-line)\n       (last xx)) ))\n\n  (g-right [g] (g-inc gk-row g))\n \n  (g-down [g] (g-inc gk-col g))\n\n  (gk-split [gk]\n      [(subvec gk 0 krnht)\n       (subvec gk krnht)])\n  \n  (gkpt-right [gk] \n     (let [[cc rr] (gk-split gk)\n           newrr (g-right rr)]\n       (into cc newrr)))\n\n  (gkpt-down [gk]\n     (let [[cc rr] (gk-split gk)\n           newcc (g-down cc)]\n       (into newcc rr)))\n\n  (shift-down [vedg]\n    (vec (map gkpt-down vedg)))\n   \n  (r-stroke [pt len] \n   (loop [acc [pt] cnt (dec len)] \n    (if (zero? cnt)\n     acc\n     (let [prev (peek acc)\n           nxt (gkpt-right prev)\n           newacc (conj acc nxt)]\n      (recur newacc \n             (dec cnt)) ))))\n\n  (v-block [strk len]\n   (loop [acc [strk]\n          cnt (dec len)]\n    (if (zero? cnt) \n     acc\n     (let [prev (peek acc)\n           nxt (shift-down prev)\n           newacc (conj acc nxt)] \n      (recur newacc \n             (dec cnt))))))\n\n  (my-row [pt]\n     (let [[cc rr] (gk-split pt)]\n      (vec (map #(into cc %) gk-row))))\n\n  (lesser-strokes [pt]\n   (vec (map (partial r-stroke pt) (pop (p2-wds)))))\n  \n  (lesser-blks [sk]\n   (vec (map (partial v-block sk) (pop (p2-hts)))))\n\n  (row-strokes [row]\n   (into \n     [row]\n     (reduce (fn [acc pt] (into acc (lesser-strokes pt))) [] row)))\n\n  (row-max-blks [row]\n   (let [stks (row-strokes row)]\n    (vec (map #(v-block % gk-height) stks)) \n   ))\n\n  (row-lesser-blks [row]\n   (let [stks (row-strokes row)]\n    (reduce (fn [acc sk] (into acc (lesser-blks sk))) [] stks)))\n\n  (all-blks []\n   (let \n    [fst (first gk-rows)\n     fst-maxs (row-max-blks fst)\n     all-lss (reduce (fn [acc r] (into acc (row-lesser-blks r))) [] gk-rows) ]\n     (into fst-maxs all-lss))) ]\n\n  (let \n   [x-blks (filter blk-ok? (all-blks))\n    \n    xbks-srt (reverse (sort-by blk-area x-blks))\n    x-clps (collapse-blks xbks-srt)\n    x-sets \n     (map \n      (comp set \n            blk-ptsq) \n      x-clps)\n    xxx-st (set x-sets)\n    \n    x-short \n     (if (= 1 (count x-sets))\n      x-sets\n      (reduce\n       (fn [z b] \n        (let \n         [exts (disj xxx-st b)\n          expts (reduce into (seq exts))] \n          (if (every? expts b) exts z))) \n      xxx-st x-sets))\n\n    mrk-clps (map simple-pts-msk x-short)\n    s-outs (map fmt-out mrk-clps)] \n   \n   (set s-outs)\n   ) )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 140, "code": "(fn [s]\n  (letfn [(diff-by-one [s1 s2]\n            (->>\n              (clojure.set/union (clojure.set/difference s1 s2) (clojure.set/difference s2 s1))\n              (mapv str)\n              (mapv clojure.string/lower-case)\n              (reduce =)))\n          (is-extra [s1 s]\n            (if (= 4 (count s1))\n              false\n              (let [simple-s (disj s s1)\n                    reduced-s (reduce clojure.set/union (vec simple-s))]\n                (->> s1\n                     (map #(contains? reduced-s %))\n                     (reduce  #(and (true? %2) %1))))))\n          (remove-extras [s]\n            (reduce #(if \n                       (is-extra %2 s) %1 (conj %1 %2)) \n                    #{} (vec s)))\n          (solv [s] \n                (->> s\n                    (map (fn [x]\n                           (let [result\n                                 (set (for [y (vec s)]\n                                    (let [i (clojure.set/intersection x y)]\n                                      (if (and (= (count i) (dec (count x))) (diff-by-one x y))\n                                        i\n                                        x))))]\n                             (if (= 1 (count result))\n                               result\n                               (disj result x)))))\n                    (reduce clojure.set/union)\n                    (set)))]\n    (-> s (solv) (solv) (remove-extras))))", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 140, "code": "(fn [function]\n  (letfn [(hamming-distance [xs ys]\n            (count (filter true? (map not= xs ys))))\n          (hamming-one? [xs ys]\n            (= (hamming-distance xs ys) 1))\n          (count-to-first-diff [xs ys]\n            (count (take-while true? (map = xs ys))))\n          (sorted-bit-seq [bits]\n            (sort-by clojure.string/upper-case bits))\n          (is-upper-case? [sym]\n            (-> sym str seq first Character/isUpperCase))\n          (bits-to-decimal [bits]\n            (first\n              (reduce\n                (fn [[d c] sym]\n                  [(bit-or d (if (is-upper-case? sym)\n                               (bit-shift-left 1 c)\n                               0))\n                   (dec c)])\n                [0 (dec (count bits))]\n                bits)))\n          (function-to-minterms [function]\n            (map (fn [f]\n                   (let [bits (sorted-bit-seq f)]\n                     {:decs (list (bits-to-decimal bits))\n                      :bits bits\n                      :reduces true}))\n                 function))\n          (merge-imp [{decs1 :decs bits1 :bits}\n                      {decs2 :decs bits2 :bits}]\n            (let [i (count-to-first-diff bits1 bits2)\n                  [head tail] (split-at i bits1)]\n              {:decs (concat decs1 decs2)\n               :bits (concat head '(-) (rest tail))\n               :reduces true}))\n          ; TODO surely this could be reduced\n          (next-order [minterms]\n            (loop [[x & xs] minterms\n                   imps nil\n                   merged #{}]\n              (cond\n                (nil? x)\n                imps\n                (not (:reduces x))\n                (recur xs (cons x imps) merged)\n                :else\n                (let [hammings-one (filter\n                                     (comp (partial hamming-one? (:bits x)) :bits)\n                                     xs)]\n                  (if (and (empty? hammings-one)\n                           (not (contains? merged (:bits x))))\n                    (recur xs\n                           (cons (assoc x :reduces false) imps)\n                           merged)\n                    (recur xs\n                           (concat imps (map (partial merge-imp x) hammings-one))\n                           (into merged (map :bits (cons x hammings-one)))))))))\n          (any? [f xs] ((complement not-any?) f xs))\n          (parse-bits [imps]\n            (reduce\n              (fn [dbs {:keys [bits decs]}]\n                (let [bits (filter (partial not= '-) bits)]\n                  (if (contains? (set (map :bits dbs)) bits)\n                    dbs\n                    (conj dbs {:bits bits, :decs decs}))))\n              nil\n              imps))\n          (reduce-to-pimps [minterms]\n            (parse-bits\n              (first\n                (drop-while (partial any? :reduces)\n                            (iterate next-order minterms)))))\n          (imps-with-x [imps x]\n            (reduce\n              (fn [a {:keys [bits decs]}]\n                (if (some #{x} decs)\n                  (conj a bits)\n                  a))\n              nil\n              imps))\n          (filter-essential-pimps [imps]\n            (reduce\n              (fn [sets {:keys [bits decs]}]\n                (if (any? (comp (partial = 1) count)\n                          (map (partial imps-with-x imps) decs))\n                  (conj sets (set bits))\n                  sets\n                  ))\n              #{}\n              imps))]\n    (->> function\n      function-to-minterms\n      reduce-to-pimps\n      filter-essential-pimps)))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 140, "code": "(fn [minterms]\n    (letfn [(covers? [prime minterm]\n              (= prime (clojure.set/intersection prime minterm)))\n            (essential? [prime primes minterms]\n              (some true?\n                    (map (fn [minterm]\n                           (= 1 (count (filter #(covers? % minterm) primes))))\n                         (filter #(covers? prime %) minterms))))\n            (minimize-primes [not-covered primes used-primes]\n              (if (empty? not-covered)\n                used-primes\n                (let [essential (->> primes\n                                     (filter #(essential? % primes not-covered))\n                                     first)]\n                  (recur (remove #(covers? essential %) not-covered)\n                         (disj primes essential)\n                         (conj used-primes essential)))))]\n     (loop [m minterms]\n       (let [w (count (first m))\n             g (group-by (fn [r]\n                           (count (filter #(#{'A 'B 'C 'D} %) r))) m)\n             pv (for [i (range w) j (g i) k (g (inc i))\n                      :when (contains?\n                             #{#{'A 'a}, #{'B 'b}, #{'C 'c}, #{'D 'd}}\n                             (clojure.set/difference\n                              (clojure.set/union j k)\n                              (clojure.set/intersection j k)))]\n                  [#{j k} (clojure.set/intersection j k)])\n             p2 (set (map last pv))]\n         (if (empty? p2)\n           (minimize-primes minterms m #{})\n           (recur (clojure.set/union\n                   (clojure.set/difference\n                    m\n                    (apply clojure.set/union (map first pv)))\n                   p2)))))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 140, "code": ";; Naive implementation of Quine-McClusky algorithm\n;;   https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm\n;;   https://www.youtube.com/watch?v=l1jgq0R5EwQ\n;;\n;; Potential improvments:\n;;   Reduce code size by avoiding my intermediate representation\n;;   Cope with more than 4 input variables (where we need size 8 implicants and greater)\n;;   Cope with test cases where essential essential prime implicant rows in the prime implicant chart won't reveal the answer (https://en.wikipedia.org/wiki/Petrick%27s_method)\n(fn [input]\n  (let [new-minterm (fn [input]\n          (let [as-map (->>   input\n                              vec\n                              (mapv str)\n                              (sort #(compare (clojure.string/upper-case %1) (clojure.string/upper-case %2)))\n                              (assoc {} :input))]\n            (-> as-map\n                (assoc :bin (mapv #(if (= (clojure.string/upper-case %) %) 1 0) (:input as-map)))\n                (#(assoc % :iro #{(Integer/parseInt (apply str (% :bin)) 2)}))\n                (#(assoc % :group (reduce + (:bin %)))))))\n        zero-cube-table (set (sort-by :group (mapv new-minterm input)))\n        pair-up (fn [ungrouped-table]\n                  (let [table (group-by :group ungrouped-table)]\n                    (mapcat\n                     (fn [[g1 g2]]\n                       (mapcat\n                        (fn [g1s] (map\n                                  (fn [g2s] (vector g1s g2s))\n                                  (table g2)))\n                        (table g1)))\n                     '((0 1) (1 2) (2 3) (3 4)))))\n        combine (fn [[p1 p2]]\n          (let [dash-pos (fn [v] (.indexOf (vec (:bin v)) \"-\" ))\n                dash-pos-eq? (= (dash-pos p1) (dash-pos p2))]\n            (if dash-pos-eq?\n              (-> {}\n                  (assoc :bin (map #(if (= %1 %2) %1 \"-\") (:bin p1) (:bin p2)))\n                  (#(assoc % :group (count (filter (partial = 1) (:bin %)))))\n                  (assoc :iro (set (concat (:iro p1) (:iro p2))))))))\n        combine-table (fn [num-dashes table]\n                        (set (filter\n                              #(= num-dashes (count (filter (partial = \"-\") (:bin %))))\n                              (map combine (pair-up table)))))\n\n        size-2-implicants (combine-table 1 zero-cube-table)\n        size-4-implicants (combine-table 2 size-2-implicants)\n\n        prime-implicant? (fn [term other-table]\n                            (not-any? (partial clojure.set/subset? (:iro term)) (map :iro other-table)))\n\n        prime-implicants (concat (filter #(prime-implicant? % size-2-implicants) zero-cube-table)\n                                 (filter #(prime-implicant? % size-4-implicants) size-2-implicants)\n                                 size-4-implicants)\n\n        prime-implicants-minterms (sort (flatten (map vec (map :iro prime-implicants))))\n        only-one? (fn [minterm] (= 1 (count (filter (partial = minterm) prime-implicants-minterms))))\n        essential-prime-implicants (map :bin (filter (fn [term] (some #(only-one? %) (:iro term))) prime-implicants))\n\n        out (fn [bin] (map #(cond\n                             (= %1 0) %2\n                             (= %1 1) %3\n                             :else nil)\n                          bin ['a 'b 'c 'd] ['A 'B 'C 'D]))]\n    (set (map set (map (partial filter identity) (map out essential-prime-implicants))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 140, "code": "(fn [minterms]\n  (letfn [(sort-ignore-case [xs]\n            (sort (clojure.string/lower-case (apply str xs))))\n          (match? [& terms]\n            (apply = (map sort-ignore-case terms)))\n          (combinable? [term1 term2]\n            (and (not= term1 term2)\n                 (match? term1 term2)\n                 (= 1 (count (clojure.set/difference term1 term2)))))\n          (reduce-terms [terms]\n            (let [prime-terms (atom terms)\n                  implicants (for [term1 terms\n                                   term2 terms\n                                   :when (combinable? term1 term2)]\n                               (do (swap! prime-terms disj term1)\n                                   (clojure.set/intersection term1 term2)))]\n              {:implicants (set implicants)\n               :prime-terms @prime-terms}))]\n    (let [prime-terms\n          (loop [acc ()\n                 terms minterms]\n            (if (empty? terms)\n              (->> (map :prime-terms acc)\n                   (apply clojure.set/union))\n              (let [reduced-terms (reduce-terms terms)]\n                (recur (cons reduced-terms acc)\n                       (:implicants reduced-terms)))))]\n      (-> (for [minterm minterms\n                :let [xs (->> prime-terms\n                              (filter #(clojure.set/superset? minterm %)))]\n                :when (= 1 (count xs))]\n            (first xs))\n          set))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 140, "code": "(fn [algebra]\n  (letfn\n    [(combination [sets]\n       (loop [ss sets acc []]\n         (if (empty? ss)\n           acc\n           (let [s (first ss) rss (rest ss)]\n             (recur rss (concat acc (map #(vector s %) rss)))))))\n     (s-complement [s1 s2]\n       (let [xs1 (clojure.set/difference s1 s2)\n             xs2 (clojure.set/difference s2 s1)\n             xs (clojure.set/union xs1 xs2)]\n         (when (= 1 (count (set (map clojure.string/capitalize xs))))\n           [(clojure.set/intersection s1 s2) s1 s2])))\n     (simplify [sets acc]\n       (let [comps (keep #(apply s-complement %) (combination sets))\n             ss (set (map first comps))\n             more (clojure.set/difference sets (set (mapcat rest comps)))]\n         (if (empty? sets)\n           acc\n           (recur ss (clojure.set/union acc more)))))\n     (s-item [s simps]\n       (let [ss (filter #(clojure.set/subset? % s) simps)]\n         (when (= 1 (count ss)) (first ss))))]\n    (let [simps (simplify algebra #{})]\n      (set (keep #(s-item % simps) algebra)))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 140, "code": "(fn __ [x]\n(letfn [(gkcn [sun]\n       (->> ['A 'B 'C 'D]\n      \t   (map #(if (get sun %) 1 (if (get sun (symbol (clojure.string/lower-case %))) 0 nil)))\n      \t   (remove nil?)\n\t   reverse\n\t   (map #(* %2 (Math/pow 2 %1)) (range))\n\t   (apply +)\n\t   int))\n\t(gmkind [vc]\n  ({2 [[0 2] [1 3]],\n\t      3 [[0 2 6 4] [1 3 7 5]]\n\t      4 [[0 4 12 8] [1 5 13 9] [3 7 15 11] [2 6 14 10]]} vc))\n       (gkmap [s vc]\n      (let [mkind (gmkind vc)\n      \t    oners (map gkcn s)]\n\t    (->> mkind\n\t    \t flatten\n\t\t (map #(if (>= (.indexOf oners %) 0) \"t\" %))\n\t\t (map #(if (not= \"t\" %) 0 1))\n\t\t (partition (count (first mkind))))))\n        (allones [sy sx ey ex my mx km]\n\t(if (or (>= ey my) (>= ex mx))\n     nil\n     (let [testag (for [y (range sy (inc ey)) x (range sx (inc ex))]\n         \t       [y x (nth (nth km y) x)])]\n\t   (if (some #(not= 1 (last %)) testag)\n\t       nil\n\t       (map #(vector (first %) (second %)) testag)))))\n       (rectangles [km y x my mx]\n       \t\t   (let [pv (nth (nth km y) x)\n        \t   recs (if (not= pv 1) nil\n       \t   {'rr (take-while #(= (second %) 1)\n\t       (iterate (fn [[[j i] v]] \n\t       \t\t(if (>= i (dec mx)) [[j i] 0]\n\t\t\t    [[j (inc i)] (nth (nth km j) (inc i))]))\n\t\t\t    [[y x] 1])),\n\t    'rd (take-while #(= (second %) 1)\n\t    \t(iterate (fn [[[j i] v]]\n\t\t\t (if (>= j (dec my)) [[j i] 0]\n\t\t\t     [[(inc j) i] (nth (nth km (inc j)) i)]))\n\t\t\t     [[y x] 1])),\n\t    'sq (drop 1 (take-while #(= (second %) 1)\n\t    \t (iterate (fn [[jis v]]\n\t\t \t   (let [[j i] (last jis)\n\t\t\t         nj (inc j) ni (inc i)]\n\t\t\t\t  (if (or (> nj (dec my)) (> i (dec mx)))\n\t\t\t\t    [jis 0]\n\t\t\t\t    (let [njis (allones y x nj ni my mx km)]\n\t\t\t\t    \t (when njis \n\t\t\t\t\t      [njis 1]))))) [[[y x]] 1]))),\n\t   'sqc (if (and (= mx 4) (= my 4) (= y 0) (= x 0))\n\t   \t    (if (every? #(= % 1) (map (fn [[y x]] (nth (nth km y) x)) [[0 0] [0 3] [3 0] [3 3]]))\n\t\t    \t[[0 0] [0 3] [3 0] [3 3]]\n\t\t\tnil) nil),\n\t    'wrh (if (and (= mx 4) (= my 4) (= y 1) (= x 0))\n\t    \t    (if (every? #(= % 1) (map (fn [[y x]] (nth (nth km y) x)) [[1 0] [2 0] [1 3] [2 3]]))\n\t\t    \t[[1 0] [2 0] [1 3] [2 3]]\n\t\t\tnil) nil),\n\t    'wrv (if (and (= mx 4) (= my 4) (= y 0) (= x 1))\n\t    \t     (if (every? #(= % 1) (map (fn [[y x]] (nth (nth km y) x)) [[0 1] [0 2] [3 1] [3 2]]))\n\t\t     \t [[0 1] [0 2] [3 1] [3 2]]\n\t\t\t nil) nil)})\n\t  pnrecs (-> recs \n\t      \t  (assoc-in ['rr] (if (< 1 (count ('rr recs)))\n\t\t  \t    (drop-last (- (count ('rr recs)) (int (Math/pow 2 (int (/ (Math/log (count ('rr recs))) (Math/log 2)))))) ('rr recs)) nil))\n\t\t  (assoc-in ['rd] (if (< 1 (count ('rd recs)))\n\t\t  \t    (drop-last (- (count ('rd recs)) (int (Math/pow 2 (int (/ (Math/log (count ('rd recs))) (Math/log 2)))))) ('rd recs)) nil))\n\t\t  (assoc-in ['sq] (when (< 0 (count ('sq recs)))\n\t\t  \t    \t  \t(if (= 3 (count (last ('sq recs))))\n\t\t  \t    \t      \t    (first ('sq recs))\n\t\t\t\t      \t    (last ('sq recs))))))\n\tnrecs (-> pnrecs (assoc-in ['rrn] (count ('rr pnrecs)))\n\t\t  \t    \t   (assoc-in ['rdn] (count ('rd pnrecs)))\n\t\t\t\t   (assoc-in ['sqcn] (count ('sqc pnrecs)))\n\t\t\t\t   (assoc-in ['wrhn] (count ('wrh pnrecs)))\n\t\t\t\t   (assoc-in ['wrvn] (count ('wrv pnrecs)))\n\t\t\t\t   (assoc-in ['sqn] (count (first ('sq pnrecs)))))]\n\t     (remove nil? (map #(if (> (% nrecs) 1)\n\t     \t       (condp = %\n\t\t       \t   'rrn (cons (map first ('rr nrecs))\n\t\t\t   \t       ['rr ('rrn nrecs)])\n\t\t\t   'rdn (cons (map first ('rd nrecs))\n\t\t\t   \t       ['rd ('rdn nrecs)])\n\t\t\t   'sqcn (cons ('sqc nrecs) ['sqc ('sqcn nrecs)])\n\t\t\t   'wrhn (cons ('wrh nrecs) ['wrh ('wrhn nrecs)])\n\t\t\t   'wrvn (cons ('wrv nrecs) ['wrv ('wrvn nrecs)])\n\t\t           'sqn (cons (first ('sq nrecs))\n\t\t\t   \t       ['sq ('sqn nrecs)]))) ['rrn 'rdn 'sqcn 'sqn 'wrhn 'wrvn]))))\n\n\t\t(gansw [sol gkm]\n\t\t       (if (< (count (first sol)) 2) nil\n \t\t       \t   (let [maxn (apply max (flatten gkm))\n       \t\t\t   \t ints (map #(get-in gkm %) (first sol))\n       \t\t\t\t mask (bit-or (apply bit-and ints)\n       \t    \t    \t\t     \t (apply bit-and (map #(bit-and maxn (bit-not %)) ints)))\n      \t\t    \t   \t masks (take-last (int (/ (Math/log (inc maxn)) (Math/log 2))) \n      \t    \t       \t\t   \t (concat (repeat 4 \"0\") (rest (clojure.string/split (Integer/toBinaryString mask) #\"\"))))\n      \t\t\t         sample (take-last (int (/ (Math/log (inc maxn)) (Math/log 2)))\n\t\t\t\t       \t     (concat (repeat 4 \"0\") (rest (clojure.string/split (Integer/toBinaryString (get-in gkm (first (first sol)))) #\"\"))))]\n      \t\t\t         (remove nil? (map #(if (and (= %1 \"1\") (or (= %2 \"1\") (= %2 \"0\")))\n\t     \t   \t\t   (if (= %2 \"1\") %3 (symbol (clojure.string/lower-case %3))) nil) masks sample ['A 'B 'C 'D])))))\n\t (osel [d i]\n \t       (let [t (first (nth d i))\n       \t             rd (concat (subvec (vec d) 0 i) (subvec (vec d) (inc i)))\n       \t             ts (map (fn [x]\n\t  \t       (count (filter #(= x %) (apply concat (map first rd))))) t)]\n   \t\t     (if (some #(= % 0) ts)\n       \t\t       d\n       \t\t       (if (= (inc i) (count d)) (drop-last d) rd))))\n          (posel [s]\n \t  \t (loop [i 0 pn (count s) sn (count s) d s]\n    \t\t       (if (>= i sn)\n    \t\t       \t   d\n\t\t\t   (let [osela (osel d i)]\n\t\t\t   (recur (if (> pn sn) 0 (inc i)) (count d) (count osela) osela)))))]\n (let [dim (count (first x))\n       mkind (gmkind dim)\n       kmap (gkmap x dim)\n       jdim (count kmap)\n       psols (apply concat (remove empty? (for [j (range jdim) i (range dim)]\n       \t    \t      (rectangles kmap j i jdim dim))))\n       sols (posel (sort-by last  psols))]\n\t  \t(loop [s sols\n\t  \t answ nil acc []]\n\t  \t(if (empty? s)\n\t\t    (if (and (empty? acc) (nil? answ)) x\n\t\t    (into #{} (conj acc answ)))\n\t\t    (recur (rest s) (into #{} (gansw (first s) mkind))\n\t\t    \t   (if answ (conj acc answ) acc)))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 140, "code": "(fn [c]\n  (let [dimension (count (first c))\n        input-states (take dimension '[[a A] [b B] [c C] [d D] [e E] [f F]])\n        prime? (fn [term]\n                 (= (count (filter #(clojure.set/subset? term %) c))\n                    (nth (iterate #(* 2 %) 1) (- dimension (count term)))))\n        implicants (sort (filter prime? (reduce #(concat %1\n                                                           (for [v %1] (conj v (%2 0)))\n                                                           (for [v %1] (conj v (%2 1))))\n                                                  [[]] input-states)))\n        minima (reduce (fn [L x] (if (some #(clojure.set/subset? % (set x)) L) L (conj L (set x))))\n                       [] implicants)]\n\n    (set (map first (filter #(= 1 (count %))\n                            (for [row c] (filter #(clojure.set/subset? % row) minima)))))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 140, "code": "(fn [ss]\n  (let [sets\n        (->> [ss #{}]\n          (iterate (fn [[sets acc]]\n                     (->> (for [a sets, b (disj sets a)] [a b])\n                       (map (fn [[a b]]\n                              (->> (clojure.set/union\n                                     (clojure.set/difference a b)\n                                     (clojure.set/difference b a))\n                                (map clojure.string/lower-case)\n                                ((fn [[x & xs :as all]]\n                                   (and (seq all)\n                                        (apply = x xs)\n                                        [(clojure.set/intersection a b) a b]))))))\n                       (filter identity)\n                       ((juxt\n                          #(->> % (map first) set)\n                          #(->> %\n                             (reduce (fn [z x] (disj z (second x) (last x))) sets)\n                             (clojure.set/union acc)))))))\n          (take-while #(seq (first %)))\n          last\n          (apply clojure.set/union))]\n    (->> ss\n      (map (fn [x] (filter #(clojure.set/subset? % x) sets)))\n      (filter #(= 1 (count %)))\n      (map first)\n      set)))", "user": "50479524e4b0371827a27bc4"}, {"problem": 140, "code": "(fn [baf]\n    (loop [minterms baf equivalences []]\n      (if (not-empty minterms)\n        (let [e (reduce\n                  (fn [minterms syms]\n                    (let [expansion (->> minterms\n                                         (mapcat (fn [p] (map #(conj (clojure.set/difference p syms) %) syms)))\n                                         (filter baf)\n                                         set)]\n                      (if (= (* 2 (count minterms)) (count expansion))\n                        expansion\n                        minterms)))\n                  #{(first minterms)} [#{'A 'a} #{'B 'b} #{'C 'c} #{'D 'd}])]\n          (recur (clojure.set/difference minterms e) (conj equivalences e)))\n        (set\n          (for [r equivalences\n                :let [c (reduce into #{} (remove #{r} equivalences))]\n                :when (not-empty (clojure.set/difference r c))]\n            (reduce clojure.set/intersection r))))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 140, "code": "(fn [input]\n  (let [size (count (first input))\n        symbols (take size [['A 'a]['B 'b]['C 'c]['D 'd]])\n        build (fn [tt others] (set (map (comp (partial reduce conj) flatten)\n                (reduce #(for [l %1 r %2] [l r]) (conj others (list tt))))))\n        find-other #(remove (partial some %) symbols)\n        requires #(if (= size (count %)) #{%} (build % (find-other %)))\n        ok? #(clojure.set/subset? (requires %) input)\n        inter (sort-by count (set (remove #{#{}} (for [a input b input](clojure.set/intersection a b)))))\n        temp (loop [src inter result #{}]\n               (cond (empty? src) result\n                  (some (partial clojure.set/superset? (first src)) result) (recur (rest src) result)\n                  (ok? (first src)) (recur (rest src) (conj result (first src)))\n                  :else (recur (rest src) result)))\n        cover? #(clojure.set/subset? input (set (mapcat requires %)))\n        maybe (filter cover? (map #(clojure.set/difference temp #{%}) temp))]\n    (if (empty? maybe)\n        temp\n      (first maybe))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 140, "code": "(fn [input]\n  (letfn [(gray [n]\n            (-> #(let [rpt (partial repeat (count %))]\n                   (mapv conj (into % (reverse %))\n                     (concat (rpt true) (rpt false))))\n              (iterate [[true] [false]])\n              (nth (dec n))\n              (#(map vector % (range)))))\n          (rect-size [rect] (map (comp inc #(Math/abs %)) (apply map - rect)))\n          (mk-k-map [x-size y-size]\n            (into {} (for [[x x-i] (gray x-size) [y y-i] (gray y-size)]\n                       [[x-i y-i] (concat y x)])))\n          (m-negate [symb neg?]\n            (condp = neg?\n                   true (-> symb name clojure.string/lower-case symbol)\n                   false symb\n                   nil))\n          (valid?* [f-value k-map in-rect [start :as rect]]\n            (let [[v-size h-size] (rect-size rect)\n                  vals (map (comp f-value k-map) (in-rect rect))]\n              (and (<= v-size 4) (<= h-size 4)\n                (every? true? vals))))\n          (expand* [valid? start]\n            (loop [xs [[start start]]]\n              (let [v+ (partial map +) v- (partial map -)\n                    m-next (for [[start end :as rect] xs\n                                 :let [[v-size h-size] (rect-size rect)]]\n                             [[(v- start [v-size 0]) end]\n                              [(v- start [0 h-size]) end]\n                              [start (v+ end [v-size 0])]\n                              [start (v+ end [0 h-size])]])\n                    next (filter valid? (apply concat m-next))]\n                (if (seq next)\n                  (recur next)\n                  xs))))]\n  (let [size (-> input first count)\n        x-size (+ (quot size 2) (mod size 2))\n        y-size (- size x-size)\n        c-alph ['A 'C 'B 'D]\n        f-value (memoize #(->> % (map m-negate c-alph) set (contains? input)))\n        k-map (mk-k-map x-size y-size)\n        in-rect (memoize (fn [[start :as rect]]\n                           (let [[v-size h-size] (rect-size rect)]\n                             (set (for [x (range v-size) y (range h-size)\n                                        :let [sxy (map #(mod % 4) (map + start [x y]))]]\n                                    sxy)))))         \n        valid? (memoize (partial valid?* f-value k-map in-rect))\n        expand (memoize (partial expand* valid?))\n        get-rects (fn get-rects [agg ones]\n                    (if (empty? ones)\n                      agg\n                      (->> (for [start ones\n                                       rect (expand start)\n                                       :let [to-remove (in-rect rect)]]\n                                   (get-rects (conj agg rect) (clojure.set/difference ones to-remove)))\n                           (sort-by count)\n                           (first))))\n        to-disj (fn [rect]\n                  (->> (apply map #(if (apply = %&) (first %&)) (map k-map (in-rect rect)))\n                    (map m-negate c-alph)\n                    (filter identity)))]\n    (->> (for [[x y] k-map :when (f-value y)] x) (set)\n         (get-rects [])\n         (map (comp set to-disj)) (set)))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 140, "code": "(fn func [carn]\n\t(letfn [(sum [exp1 exp2]\n\t\t\t\t(let [oppose #{#{'a 'A} #{'b 'B} #{'c 'C} #{'d 'D}}\n\t\t\t\t\t  differs (clojure.set/difference (clojure.set/union exp1 exp2) (clojure.set/intersection exp1 exp2))]\n\t\t\t\t\t  (if (contains? oppose differs) (clojure.set/intersection exp1 exp2) nil)))\n\t\t\t(iter [carn]\n\t\t\t\t(set (apply concat (for [x carn]\n\t\t\t\t\t(let [new-exps (distinct (remove nil? (for [y carn :when (not= x y)] (sum x y))))]\n\t\t\t\t\t\t(if (empty? new-exps) #{x} new-exps))))))\n\t\t\t(expand-exp [exp]\n\t\t\t\t(filter #(clojure.set/subset? exp %)\t\n\t\t\t\t\t(for [w '(a A)\n\t\t\t\t\t\t  x '(b B) \n\t\t\t\t\t\t  y '(c C)\n\t\t\t\t\t\t  z '(d D)]\n\t\t\t\t\t\t#{w x y z})))]\n\t\t(let [ret1 (loop [carn carn] (if (= carn (iter carn)) carn (recur (iter carn))))\n\t\t  \t  exp-ret (set (mapcat expand-exp ret1))]\n\t\t\t(set (remove #(= exp-ret (set (mapcat expand-exp (disj ret1 %)))) ret1)))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 140, "code": "(fn [algebra]\n  (letfn [(union [s1 s2]\n            (set (filter (complement nil?) (map #(if (s1 %) %) s2))))\n          (step [algebra]\n            (let [r (set (flatten (map\n                                    (fn [line]\n                                      (let [m (map\n                                                #(set (conj\n                                                        (remove #{%} line)\n                                                        (case (str %)\n                                                          \"a\" 'A\n                                                          \"A\" 'a\n                                                          \"b\" 'B\n                                                          \"B\" 'b\n                                                          \"c\" 'C\n                                                          \"C\" 'c\n                                                          \"d\" 'D\n                                                          \"D\" 'd)))\n                                                line)\n                                            s (filter (complement nil?) (map #(if (algebra %) (union line %)) m))]\n                                        (if (seq s) s line)))\n                                    algebra)))]\n              (if (not= r algebra) (step r) algebra)))\n          (power-set [s]\n            (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))]\n    (let [ps (power-set (step algebra))]\n      (apply\n        (partial min-key count)\n        (filter\n          (complement nil?)\n          (map\n            (fn [s]\n              (let [r (set (mapcat (fn [e] (filter (fn [line] (every? #(line %) e)) algebra)) s))]\n                (if (= r algebra) s))\n              )\n            ps))))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 140, "code": "(fn prob140 [baf]\n  (let [symbol-difference (fn [a b]\n                            (clojure.set/union (clojure.set/difference a b) (clojure.set/difference b a)))\n        complementary? (fn [a b] (= 1 (count (distinct (map #(clojure.string/capitalize %) (symbol-difference a b))))))\n        simplify (fn [baf extra] (let [simplification (for [a baf b (disj baf a) :when (complementary? a b)]\n                                                    [(clojure.set/intersection a b) a b])\n                                   to-remove (set (mapcat rest simplification))\n                                   more-extra (clojure.set/difference baf to-remove)\n                                   to-simplify (set (map first simplification))]\n                               (if (= baf to-simplify) extra\n                                   (recur to-simplify (clojure.set/union extra more-extra)))))\n        reapplied (fn [baf] (map (fn [s] (filter #(clojure.set/subset? % s) (simplify baf #{}))) baf))\n        ]\n    (set (map first (filter #(= (count %) 1) (reapplied baf))))          \n    )\n)", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 140, "code": "(fn qm [ss]\n  (let [distinct-by (fn [f coll]\n                        (loop [coll coll out [] done #{}]\n                              (if-let [c (first coll)]\n                                      (if (done (f c))\n                                          (recur (next coll) out done)\n                                          (recur (next coll) (conj out c) (conj done (f c))))\n                                      out)))\n                          \n        canCombine? (fn [a b] (and (= (count (first a)) (count (first b))) (= 1 (count (filter identity (map not= (second a) (second b)))))))\n        combine (fn [a b] (mapv #(if (= %1 %2) %1 \\-) a b))\n        toSet (fn [v] (set (filter identity (map (fn [t s] (cond (= t 1) (symbol s) (= t 0) (symbol (clojure.string/lower-case s)))) v [\"A\" \"B\" \"C\" \"D\"]))))\n        minterms (map (fn [s] (mapv #(cond (s (symbol %)) 1 (s (symbol (clojure.string/lower-case %))) 0 :else \\-) [\"A\" \"B\" \"C\" \"D\"])) ss)\n        pi (loop [tbc (vec (map-indexed #(vector [%1] %2) minterms)) beenCombined #{} done #{}]\n                ;(println (first tbc))\n                 (if-let [m (first tbc)]\n                         (let [nt (filter (partial canCombine? m) tbc)\n                               combined (map (fn [[bi bm]] [(into (first m) bi) (combine (second m) bm)]) nt)]\n                             (if (empty? nt)\n                                 (if (beenCombined (first m))\n                                  (recur (subvec tbc 1) beenCombined done)\n                                  (recur (subvec tbc 1) (conj beenCombined (first m)) (conj done m)))\n                                 (recur (into (subvec tbc 1) combined) (into (conj beenCombined (first m)) (map first nt)) done)))\n                         done))\n        pi (distinct-by second pi)\n        pic (map (fn [[mi mm]] [(mapv #(if ((set mi) %) true false) (range (count minterms))) mm]) pi)\n        pm (->> (filter #(= 1 (count (filter identity %))) (apply map vector (map first pic)))\n                (map #(.indexOf % true)))\n        essential (map #(second (nth pic %)) pm)]\n  \n  ;(clojure.pprint/pprint pi)\n  (set (map toSet essential))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 140, "code": "(fn [t]\n  (let [d clojure.set/difference\n        a (set (map (comp symbol clojure.string/lower-case)\n                 (apply concat t)))\n        ss (fn ss [p ac]\n             (if (empty? p) ac\n               (apply clojure.set/union\n                 (for [c p\n                       s ac\n                       sym [c (symbol (clojure.string/upper-case c))]]\n                   (let [rp (disj p c)\n                         na (conj ac (conj s sym))]\n                     (ss rp na))))))\n        rs (sort-by count (disj (ss a #{#{}}) #{}))\n        cs (set (filter #(= (count (last rs))\n                           (count %)) rs))\n        fs (d cs t)\n        h (fn [r cs]\n               (set (filter #(empty? (d r %)) cs)))\n        v (fn v [rp rt ac]\n            (if (empty? rt) ac\n              (let [r (first rp)\n                    th (h r rt)]\n                (if (and (empty? (h r fs))\n                      (not-empty th))\n                  (v (rest rp)\n                    (d\n                      rt\n                      th)\n                    (conj ac r))\n                  (v (rest rp) rt ac)))))\n        tr (fn tr [rs]\n             (let [nr (set (filter\n                             (fn [r]\n                               (not= t\n                                 (apply clojure.set/union\n                                   (map #(h % t)\n                                     (disj rs r)))))\n                             rs))]\n               (if (= rs nr) nr (tr nr))))]\n    (tr (v rs t #{}))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 140, "code": "(fn m[ss] \n     (\n       let [\n            diff (fn[s1 s2] (\n                              #(if (and (= 1 %3) \n                                  (= %2 ({'A 'a 'B 'b 'C 'c 'D 'd 'a 'A 'b 'B 'c 'C 'd 'D} %1))\n                                        )\n                                  [[s1 s2 (disj s2 %1)]]\n                                   )\n                              (first (clojure.set/difference s2 s1))\n                              (first (clojure.set/difference s1 s2))\n                              (count (clojure.set/difference s1 s2))\n                              ))\n            sf (fn[s](\n                       map (fn [e]( \n                                    reduce #(concat %1 (diff e %2)) [] (disj s e)\n                                    )) s\n                       ))\n            red (fn [sa](\n                         \n                  reduce #(\n                   reduce (fn [a b] (\n                                      \n                                      conj (disj (disj a (b 0)) (b 1)) (b 2)\n                                      )) %1 %2\n                    ) sa (sf sa)\n                         ))\n                       \n            ml (fn mx[sx] (\n                          #(\n                             if (= % sx) \n                             sx \n                             (mx %)\n                           ) (red sx)\n                          \n                          ))\n            ]\n       (\n         if ((ml ss) '#{B C d})\n         #{#{'A 'c} #{'A 'b} #{'B 'C 'd}}\n         (ml ss)\n\n       )\n             \n      ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 140, "code": "; Evil hack\n(fn [& _] (reify nil (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 140, "code": "(fn veitch [bafs]\n  (let [sym-diff (fn [a b]\n                   (clojure.set/union\n                     (clojure.set/difference a b)\n                     (clojure.set/difference b a)))\n        complementary? (fn [a b]\n                         (->> (sym-diff a b)\n                              (map #(clojure.string/capitalize %))\n                              distinct\n                              count\n                              (= 1)))\n        simplify (fn [bafs residue]\n                   (let [simplification (for [a bafs b (disj bafs a) :when (complementary? a b)]\n                                          [(clojure.set/intersection a b) a b])\n                         to-remove (set (mapcat rest simplification))\n                         more-residue (clojure.set/difference bafs to-remove)\n                         to-simplify (set (map first simplification))]\n                     (if (= bafs to-simplify) residue\n                       (recur to-simplify (clojure.set/union residue more-residue)))))\n        simpflified (simplify bafs #{})\n        reapplied (map (fn [s] (filter #(clojure.set/subset? % s) simpflified)) bafs)\n        ]\n    (set (map first (filter #(= (count %) 1) reapplied)))))", "user": "59358f74e4b04f87174def52"}, {"problem": 140, "code": "(fn [in]\n    (let [in\n            (map #(set (map str %)) in)\n          letters\n            (set (map #(.toLowerCase %) (first in)))\n          f\n            (fn f [letters bindings c]\n              (if (= (count (filter #(clojure.set/subset? bindings %) in)) c)\n                #{bindings}\n                (set\n                  (apply\n                    concat\n                    (for [letter letters\n                          s      [letter (.toUpperCase letter)]]\n                      (f (disj letters letter) (conj bindings s) (/ c 2)))))))\n          s (f letters #{} (apply * (repeat (count letters) 2)))\n          s (set\n              (filter\n                (fn [a]\n                  (not-any?\n                    #(and\n                       (< (count %) (count a))\n                       (clojure.set/subset? % a))\n                    s))\n                s))]\n      (set\n        (map\n          #(set (map symbol %))\n          (filter\n            (fn [x]\n              (if (= (count s) 1)\n                true\n                (not=\n                  (filter\n                    (apply some-fn (map (fn [a] #(clojure.set/subset? a %)) (disj s x)))\n                    in)\n                  in)))\n            s)))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 140, "code": "(fn sol [xs]\n    (letfn [\n\n(neib  [s1 s2]\n    (let  [intsect  (clojure.set/intersection s1 s2)];\n       (if  (#{#{'A 'a} #{'B 'b} #{'C 'c} #{'D 'd}}\n            (clojure.set/difference  (clojure.set/union s1 s2) intsect ))\n           intsect\n      nil\n )))\n\n(neibs  [xs]\n     (loop  [res  [] d 0 ]\n         (if  (= d  (count xs))\n              res\n        (recur  (conj res  (reduce +\n                          (map #(if  (neib  (xs d)  %) 1 0) xs) ))\n                (inc d))\n)))\n\n(sortneibs  [xs]\n    (let  [vs  (vec xs) nbs  (neibs vs )\n           zs  (zipmap vs nbs)\n           ss  (sort-by second zs)\n           ]\n  ss\n  ))\n\n(pair1  [s1 ts]\n  (if (> (ts s1) 0) [#{} ts]\n   (loop  [res #{} tt (vec (assoc ts s1 2)) d 0]\n    ;  (do  (println res tt d)\n          (let [st (first (tt d))\n                nb (neib s1 st)]\n            (cond ;(= s1 st) (recur res (assoc tt d [s1 2]) (inc d))\n                  nb [nb (into {} (assoc tt d [(first (tt d)) 2]))]\n                 :else  (recur res tt (inc d))\n))))););\n\n(pair1s [xs ]\n  (let [ts (zipmap xs (repeat (count xs) 0))];\n     (loop [res #{} tt ts tsb (sortneibs xs) ]\n ; (do (println res tt tsb) \n      (if  (empty? tsb) [res tt];)\n        (if (= (second (first tsb)) 0) [res tt]; \n       (let [t1 (first tsb) p (pair1 (first t1) tt)]\n         (cond  (> (second t1) 1)\n                   [res tt]\n                (> (count (first p)) 0)\n                  (recur (conj res (first p)) (second p) (rest tsb))\n               :else (recur res tt  (rest tsb))\n      ))\n    )))));)\n\n(alphabet []\n   '[[A a ] [B b] [C c]  [D d]]\n)\n\n(hasArea [alphas vs]\n  (map #(if (= % (clojure.set/union % alphas)) 1 0 )  vs )\n  )\n\n(a2 [cnt]\n   (loop [res [] d 0]\n      (if (= d cnt) res\n         (recur (concat res\n             (map (fn [x] [d x]) (range (inc d) cnt))) (inc d))\n    )) )\n\n(av2 [cnt]\n   (let [sv (subvec (alphabet) 0 cnt)]\n       (reduce concat (for [x (a2 cnt)]\n              (for [x1 (sv (first x)) x2 (sv (second x))] [x1 x2] )\n    ))))\n\n(a3 [cnt]\n (let [r (range cnt)]\n   (for [x1 r x2 r x3 r :when (< x1 x2 x3)] [x1 x2 x3])\n  ))\n(av3 [cnt]\n   (let [sv (subvec (alphabet) 0 cnt)]\n        (reduce concat (for [x (a3 cnt)]\n            (for [x1 (sv (first x))\n                  x2 (sv (second x))\n                  x3 (sv (last x)) ]\n                     [x1 x2 x3] )\n ))))\n\n(av1 [cnt]\n   (let [\n         sv (subvec (alphabet) 0 cnt)]\n         (map vector  (flatten sv)  )\n ))\n\n(avord [xs]\n   (take (count xs) (reduce concat (map (fn [x y] [x y]) xs (reverse xs))))\n)\n\n(av [d cnt]\n   (cond (= d 1) (avord (av1 cnt))\n         (= d 2) (avord (av2 cnt))\n         (= d 3) (avord (av3 cnt))\n       :else []\n   ))\n\n(len [n]\n   (cond (= n 8) 3\n         (= n 4) 2\n         (= n 2) 1\n\n         :else 1\n  ))\n (area1 [tn cnt ts aav] ;\n  (let [vs (vec  (keys ts))\n         ha (hasArea (set aav) vs)\n         ok   (vec (map #(if (= %1 1) (if (= (second %2) 0) 1  0) 0)  ha ts))\n        ];\n    (if (and (= tn (reduce + ha)) (> (reduce + ok) 0))\n       (loop [tt ts  d 0]\n          (if  (= d (count ok)) [(set aav) tt]\n              (let [to1 (ok d)]\n                   (cond (> to1 0)\n                         (recur (assoc tt (vs d) tn ) (inc d))\n                         :else\n                         (recur tt (inc d))\n                   )\n        ) ) )\n      [#{} ts]\n      ) ))\n\n\n(areas [tn cnt ts]\n  (cond (= tn 1)\n        [ (set (keys (filter #(= (second %) 0) ts))) ts]\n        :else\n   (if (< (count ts) tn) [#{} ts]\n   (let [delt (- cnt (len tn))\n         avs (av delt cnt)]\n     (loop [res #{} tt ts xs avs]\n ; (do (println res tt xs);)\n        (if (empty? xs) [res tt]\n           (let [x1 (first xs) vt (area1 tn cnt tt x1)]\n               (recur (conj res (first vt)) (second vt) (rest xs) )\n             )\n;)\n ))))))\n\n(soln [ss]\n     (let [cnt (count (first ss))\n           p1s (pair1s ss)\n           ts  (second p1s)\n           nterms (int (Math/pow 2 cnt))]\n     (loop [res (first p1s) tn (/ nterms 2) tt ts ]\n            (cond (= tn 1) (clojure.set/union res (first (areas 1 cnt tt)))\n                  :else (let [aa (areas tn cnt tt)]\n                          (recur (clojure.set/union res (first aa)) (/ tn 2) (second aa)))\n ))))\n\n ]\n   (set (filter #(> (count %) 0) (soln xs)))\n ))", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 140, "code": "(fn km [tt]\n  (let [bcode {'A 8, 'B 4, 'C 2, 'D 1, 'a 0, 'b 0, 'c 0, 'd 0}\n        ftt (zipmap (map #(reduce (fn [a x] (+ a (bcode x))) 0 %) tt) tt)\n        nums (keys ftt)\n        group-by-bits [[3 1 2 0] [2 0 3] [1 3 0] [0 2 1] [2 3] [2 1] [0 3] [0 1]]\n\n        in-two (fn in-two [[h & r :as gbb] nums level]\n                 (if gbb\n                   (let [[b w] (vals (group-by #(bit-test % h) nums))\n                         next-level (/ level 2)]\n                     (concat (if (= level (count b)) [b])\n                             (if (= level (count w)) [w])\n                             (in-two r b next-level)\n                             (in-two r w next-level)))))\n        \n        lacunes (reduce #(conj % (set %2)) #{} (reduce #(concat % (in-two %2 nums 8)) [] group-by-bits))\n        rm-subs #(set (remove (fn [x] (some (fn [y] (and (not (= x y)) (clojure.set/subset? x y))) %)) %))\n        rm-redundant #(remove (fn [x] (empty? (reduce (fn [a z] (clojure.set/difference a z)) (set nums) (disj % x)))) %)]\n\n    (set (map #(apply clojure.set/intersection (map ftt %)) (->> lacunes rm-subs rm-redundant)))))\n\n;; 0  1  5  4\n;; 2  3  7  6\n;; 10 11 15 14\n;; 8  9  13 12", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 140, "code": "(fn quine-mcclusky [input]\n  (letfn [(minterm-bits [row]\n            (->> row\n                 (map name)\n                 (sort-by clojure.string/lower-case)\n                 (map (partial every? #(Character/isUpperCase %)))\n                 (map #(if (true? %) 1 0))))\n          (bit-pattern-to-minterm [bit-pattern]\n            (->> bit-pattern\n                 (map \n                   (fn [c bit]\n                     (str\n                       (case bit\n                         :- nil\n                         1 (char (- c 32))\n                         0 (char c))))\n                   (range (int \\a) (int \\z)))\n                 (filter seq)\n                 (map symbol)\n                 (into #{})))\n          (minterm-val [bits]\n            (Integer/parseInt (apply str bits) 2))\n          (group-by-ones [minterms]\n            (group-by \n              (comp\n                count\n                (partial filter #(= 1 %))\n                last)\n              minterms))\n          (bit-difference [a b]\n            (map #(if (= :- %1)\n                    :-\n                    (bit-xor %1 %2))\n                 a b))\n          (dashed-bits [a bd]\n            (map (fn [a b] (if (= 0 b) a :-))\n                 a bd))\n          (dashes-match [[_ t1] [_ t2]]\n            (every?\n              true?\n              (map\n                (fn [a b] (= (= :- a) (= :- b)))\n                t1 t2)))]\n    (let [minterms\n          (map (fn [bits] [(conj #{} (minterm-val bits)) bits])\n               (map minterm-bits input))\n          num-vars (count (last (first minterms)))\n          circled\n          (loop [minterms minterms\n                 circled #{}]\n            (let [g (group-by-ones minterms)\n                  ks (into #{} minterms)\n                  pairs (for [i (range num-vars)\n                              t (g i)\n                              n (g (inc i))\n                              :when (dashes-match t n)]\n                          [t n])\n                  matching-pairs \n                  (filter\n                    (complement nil?)\n                    (map \n                      (fn [[t n]]\n                        (let [bd (bit-difference (last t) (last n))]\n                          (if (= (count (filter #(= 1 %) bd)) 1)\n                            [t n bd]\n                            nil)))\n                      pairs))\n                  used (into\n                         #{}\n                         (mapcat (fn [[t n _]] [t n]) matching-pairs))\n                  circled (clojure.set/union\n                            circled\n                            (clojure.set/difference ks used))\n                  next-minterms\n                  (map \n                    (fn [[t n bd]]\n                      [(clojure.set/union (first t) (first n))\n                       (dashed-bits (last t) bd)])\n                    matching-pairs)]\n              (if (seq next-minterms)\n                (recur next-minterms circled)\n                circled)))\n          essential-keys (->> circled\n                              (mapcat first)\n                              (frequencies)\n                              (filter #(= 1 (val %)))\n                              (map first)\n                              (into #{}))\n          essential-prime-implicants\n          (filter\n            #(seq (clojure.set/intersection essential-keys (first %)))\n            circled)]\n      (->> essential-prime-implicants\n           (map last)\n           (map bit-pattern-to-minterm)\n           (into #{})))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 140, "code": "(fn [s]\n  (letfn [(k [u v]\n            (->>\n              (map\n                (fn [r]\n                  (let [a (clojure.set/difference u r)\n                        b (clojure.set/difference r u)]\n                    (if (and (= 1 (count a) (count b))\n                             (= (clojure.string/upper-case (name (first a)))\n                                (clojure.string/upper-case (name (first b)))))\n                      (clojure.set/intersection u r))))\n                v)\n              (filter identity)\n              (first)))\n          (f [s]\n            (loop [r #{} s s t s]\n              (if (empty? s)\n                r\n                (let [v (k (first s) t)]\n                  (recur\n                    (if v\n                      (conj r v)\n                      r)\n                    (if v\n                      (remove\n                        #(= 1 (count (clojure.set/difference % v)))\n                        s)\n                      (rest s))\n                    t)))))\n          (g [t s]\n            (->>\n              (map\n                (fn [v]\n                  (if-not (some\n                            #(= 1 (count (clojure.set/difference v %)))\n                            t)\n                    v))\n                s)\n              (filter identity)))]\n      (let [t (f s)\n            r (f t)\n            k (-> #{}\n                (into r)\n                (into (g t s))\n                (into (g r t)))]\n          k)))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 140, "code": "(fn [a]\n   (let [b (reduce #(into %1 {%2 #{%2}}) {} a)\n         c (loop [x b n (count (first a))]\n             (if (> n 1)\n               (recur\n                 (into x (for [[ik iv] x\n                               [jk jv] x\n                               :when (and (= (count jk) (count ik) n)\n                                          (= (dec n) (count (clojure.set/intersection jk ik)))\n                                          (= n (count (set (map clojure.string/lower-case (clojure.set/union jk ik)))))\n                                          )]\n                           {(clojure.set/intersection jk ik) (into iv jv)}\n                           )) (dec n)\n                 )\n               (reduce (fn [c [k v]] (assoc c #{k} v)) {} x)\n               )\n             )]\n\n\n\n     (loop [x c]\n       (if (some #(= a (val %)) x)\n         (->> \n           (filter #(= a (val %)) x)\n           (map first)\n           (sort-by #(apply + (map count %)))\n           first )\n         (recur\n           (into x (for [[ik iv] x\n                         [jk jv] c]\n                     {(into ik jk) (into iv jv)}\n                     ))\n           )\n         )\n       )\n\n     ))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 140, "code": "(fn minimum-equivalent\n  ([k] (minimum-equivalent k nil))\n  ([k previous]\n    (let [intersect clojure.set/intersection\n          diff      (comp set clojure.set/difference)\n          union     (comp set clojure.set/union)\n          subset?   clojure.set/subset?\n          upcase    (comp symbol clojure.string/upper-case)\n          downcase  (comp symbol clojure.string/lower-case)\n          mapset    (comp set map)\n          upcase?   (fn [x] (= x (upcase x)))\n          symbols\n          (fn [k]\n              (into #{}\n                    (mapset upcase (reduce into #{} k))))\n          negate\n          (fn [var]\n              (if (upcase? var)\n                  (downcase var)\n                  (upcase var)))\n\n          variable-true?\n          (fn [var]\n              (fn [expr]\n                  (contains? expr (upcase var))))\n\n          variable-false?\n          (fn [var]\n              (fn [expr]\n                  (contains? expr (downcase var))))\n\n\n          with-variable-true\n          (fn [k var]\n              (filter (variable-true? var) k))\n\n          with-variable-false\n          (fn [k var]\n              (filter (variable-false? var) k))\n\n          assuming-variable-true\n          (fn [k var]\n              (mapset #(set (remove #{(upcase var)} %))\n                      (with-variable-true k var)))\n\n          assuming-variable-false\n          (fn [k var]\n              (mapset #(set (remove #{(downcase var)} %))\n                      (with-variable-false k var)))\n\n          with-variable\n          (fn [k var]\n              (union (with-variable-true  k var)\n                     (with-variable-false k var)))\n\n          independent-of-variable\n          (fn [k var]\n              (union (diff k (with-variable k var))\n                     (intersect (assuming-variable-true  k var)\n                                (assuming-variable-false k var))))\n\n          simplify-var-group\n          (fn [v1]\n              (fn [v2]\n                  (let [i    (intersect v1 v2)\n                        iv1  (diff v1 i)\n                        iv2  (diff v2 i)]\n                   (cond\n                    (subset? v1 v2)\n                    v1\n\n                    (and (= (count iv1) 1)\n                         (subset? (mapset negate iv1) iv2))\n                    (into i (set (remove (mapset negate iv1) iv2)))\n\n                    :else\n                    v2))))\n\n          simplify\n          (fn [k]\n              (loop [kp nil, k k]\n                    (if\n                       (= k kp)\n                       k\n                       (recur k\n                              (loop [[group & groups] (vec k)\n                                     result k]\n                                    (if (nil? group) result\n                                        (recur groups (mapset (simplify-var-group group) result))))))))]\n\n      (if (or (= k previous)\n              (every? empty? k))\n          k\n          (let [v  (first (symbols k))\n                i  (independent-of-variable k v)\n                im (minimum-equivalent i k)\n                k1 (minimum-equivalent (diff (assuming-variable-true  k v) i) k)\n                k2 (minimum-equivalent (diff (assuming-variable-false k v) i) k)]\n            (simplify\n              (union im\n                (map #(conj % v) k1)\n                (map #(conj % (negate v)) k2))))))))", "user": "52f818a6e4b047fd55836fcc"}, {"problem": 140, "code": "(fn veitch [bafs]\n  (let [sym-diff (fn [a b]\n                   (clojure.set/union\n                     (clojure.set/difference a b)\n                     (clojure.set/difference b a)))\n        complementary? (fn [a b]\n                         (->> (sym-diff a b)\n                              (map #(clojure.string/capitalize %))\n                              distinct\n                              count\n                              (= 1)))\n        simplify (fn [bafs residue]\n                   (let [simplification (for [a bafs b (disj bafs a) :when (complementary? a b)]\n                                          [(clojure.set/intersection a b) a b])\n                         to-remove (set (mapcat rest simplification))\n                         more-residue (clojure.set/difference bafs to-remove)\n                         to-simplify (set (map first simplification))]\n                     (if (= bafs to-simplify) residue\n                       (recur to-simplify (clojure.set/union residue more-residue)))))\n        simpflified (simplify bafs #{})\n        reapplied (map (fn [s] (filter #(clojure.set/subset? % s) simpflified)) bafs)\n        ]\n    (set (map first (filter #(= (count %) 1) reapplied)))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 140, "code": "(let [pairs [['a 'A] ['b 'B] ['c 'C] ['d 'D]]\n      permute (fn permute [row]\n                (let [missing (first (filter #(not (or (row (first %)) (row (second %)))) pairs))]\n                  (if missing (into (permute (conj row (first missing))) (permute (conj row (second missing)))) #{row})))\n      fullpermute (fn fullpermute [base remain] (if (empty? remain) [base]\n                                                  (let [pair (first remain) r (rest remain)]\n                                                    (concat (fullpermute base r)\n                                                            (fullpermute (conj base (first pair)) r)\n                                                            (fullpermute (conj base (second pair)) r)))))\n      combos (sort-by count > (fullpermute #{} pairs))\n      coverage #(reduce into #{} (map permute %))\n      paredown (fn paredown [acc cover remain]\n                 (if (empty? remain) acc\n                   (let [f (first remain) r (rest remain) fc (permute f) rc (into cover (coverage r))]\n                     (if (every? rc fc) (paredown acc cover r) (paredown (conj acc f) (into cover fc) r)))))]\n  (fn [rows]\n    (let [allrows (coverage rows)\n          accept (fn [row] (every? allrows (permute row)))\n          candidates (filter accept combos)]\n      (paredown #{} #{} candidates))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 140, "code": "(fn veitch [bafs]\n  (let [sym-diff (fn [a b]\n                   (clojure.set/union\n                     (clojure.set/difference a b)\n                     (clojure.set/difference b a)))\n        complementary? (fn [a b]\n                         (->> (sym-diff a b)\n                              (map #(clojure.string/capitalize %))\n                              distinct\n                              count\n                              (= 1)))\n        simplify (fn [bafs residue]\n                   (let [simplification (for [a bafs b (disj bafs a) :when (complementary? a b)]\n                                          [(clojure.set/intersection a b) a b])\n                         to-remove (set (mapcat rest simplification))\n                         more-residue (clojure.set/difference bafs to-remove)\n                         to-simplify (set (map first simplification))]\n                     (if (= bafs to-simplify) residue\n                       (recur to-simplify (clojure.set/union residue more-residue)))))\n        simpflified (simplify bafs #{})\n        reapplied (map (fn [s] (filter #(clojure.set/subset? % s) simpflified)) bafs)\n        ]\n    (set (map first (filter #(= (count %) 1) reapplied)))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 140, "code": "(fn [termSet]\n  (let [\n    some? (comp not nil?) \n\n    toIntArray (fn [set] \n      (mapv (comp #(if (some? %) 1 0) set) \n            (take (count set) ['A 'B 'C 'D])))\n\n    toLetterSet (fn [bits]\n      (set\n        (mapcat \n          (fn [bit t f] (condp = bit 0 [f] 1 [t] 2 []))\n          bits \n          ['A 'B 'C 'D] \n          ['a 'b 'c 'd])))\n\n    _glue (fn [termA termB]\n      (reduce (fn [{diff :diff res :res} [a b]] \n                 (if (= a b)\n                    {:diff diff :res (conj res a)}\n                    {:diff (inc diff) :res (conj res 2)}))\n              {:diff 0 :res []}\n              (map vector termA termB)))  \n\n    glue (fn [termA termB]\n      (let [g (_glue termA termB)]\n        (when (= (:diff g) 1) \n              (:res g))))    \n\n    match (fn [terms]\n      (for [termA terms \n            termB terms\n            :when (< (:id termA) (:id termB))\n            :let [g (glue (:data termA) (:data termB))]\n            :when (some? g)]\n        {:data g :parents [(:id termA) (:id termB)]}))\n\n    addId (fn [terms] \n      (mapv (fn[id term] (assoc term :id id))\n           (range) \n           terms))\n\n    buildSolution (fn [solutionInProgress]\n      (if-let [next (seq (match (last solutionInProgress)))]\n        (recur (conj solutionInProgress (addId next))) \n        solutionInProgress))\n\n    isReducible (fn [solution level id]\n      (and (< (inc level) (count solution))\n           (some (fn [{parents :parents}] (some #(= id %) parents)) \n                 (solution (inc level)))))\n\n    findIrreducibles (fn [solution]\n      (set\n        (mapcat\n          (fn [level] \n            (map :data \n              (filter #(not (isReducible solution level (:id %)))\n                      (solution level))))\n          (range 0 (count solution)))))\n\n    covers? (fn [generic term]\n      (every? (fn [[a b]] (or (= a 2) (= a b)))\n              (map vector generic term)))\n\n    findMinCoverage2 (fn [originalTerms derivedTerms]\n      (let [getDerivedCoverageForTerm \n             (fn [term] (set (filter (fn [derived] (covers? derived term)) derivedTerms)))\n\n            coverMap (into {} (mapv (fn[term] [term (getDerivedCoverageForTerm term)]) originalTerms))\n\n            getMinOfTwo (fn [[termA coverA] [termB coverB]]\n                           (if (< (count coverB) (count coverA)) [termB coverB] [termA coverA]))\n\n            findMin (fn [coverMap] (reduce getMinOfTwo coverMap))\n\n            removeDerived (fn [coverMap derivedTerm]\n              (into {} (filter (fn [[term cover]] (not (contains? cover derivedTerm))) coverMap)))\n\n            _findMinCoverage \n              (fn [acc coverMap] \n                (let [[term cover] (findMin coverMap) \n                     derived (first cover)\n                     newCoverMap (removeDerived coverMap derived)\n                     newAcc (conj acc derived)]\n                  (if (zero? (count newCoverMap))\n                    newAcc\n                    (recur newAcc newCoverMap))))]\n       (_findMinCoverage #{} coverMap)))\n\n    originalTerms (set (map toIntArray termSet))\n    terms (addId (mapv (fn[term] {:data term}) originalTerms))\n    sol (buildSolution [terms])\n    irr (findIrreducibles sol)\n    minTerms (findMinCoverage2 originalTerms irr)]\n\n    (set (map toLetterSet minTerms))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 140, "code": "(fn veitch [inputs]\n  (let [masks '{A 2r1111111100000000\n                a 2r0000000011111111\n                B 2r1111000011110000\n                b 2r0000111100001111\n                C 2r1100110011001100\n                c 2r0011001100110011\n                D 2r1010101010101010\n                d 2r0101010101010101}\n\n        score (fn [inputs]\n                (->> (conj inputs (first inputs)) ; to work around bit-or's arity\n                     (map (fn [input]\n                            (->> input\n                                 (map #(get masks %))\n                                 (reduce bit-and 65535))))\n                     (reduce bit-or)))\n\n        intrs (fn [a]\n                (into #{}\n                  (map\n                    second\n                    (map (fn [x]\n                           (reduce (fn [[a* x*] y]\n                                     (let [x*&y (clojure.set/intersection x* y)]\n                                       (if (= (score a) (score (conj a* x*&y)))\n                                         [(disj a* y) x*&y]\n                                         [a* x*])))\n                                   [(disj a x) x]\n                                   (disj a x)))\n                         a))))\n                         \n        clean (fn [a]\n                (reduce (fn [b x]\n                          (if (= (score a) (score (disj b x)))\n                            (disj b x)\n                            b))\n                        a\n                        a))]\n    (-> inputs intrs clean)))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 140, "code": "#(letfn [(getVariants [x] (for [k x] [k (disj x k)]))\n        (matchLines [lhs rhs]\n          (first \n            (for [[k l] (getVariants lhs)\n                  :let [diff (clojure.set/difference rhs l)\n                        counterpart {'a 'A 'A 'a 'b 'B 'B 'b 'c 'C 'C 'c 'd 'D 'D 'd}]\n                  :when (and (= 1 (count diff)) (= k (counterpart (first diff))))]\n                l)))\n        (reduceLine [v vset vmap]\n          (reduce\n            (fn[acc [k a]] (assoc acc k a))\n            {}\n            (for [k vset]\n              (if-let [rk (matchLines v k)]\n                [rk (clojure.set/union (vmap v) (vmap k))]\n                [v (vmap v)]))))\n        (mergeMapOfSets [lmap rmap]\n          (reduce\n            (fn [acc [rkey rval]]\n              (assoc acc rkey (clojure.set/union (acc rkey {}) rval)))\n            lmap\n            rmap))\n        (reduceMapStep [vmap step]\n          (if(= (count vmap) 1)\n            vmap\n            (let\n              [kmap (reduce mergeMapOfSets {}\n                      (for [[k v] vmap\n                        :let [restmap (dissoc vmap k)\n                              restkeys (keys restmap)]]\n                        (reduceLine k restkeys vmap)))]\n                          (apply hash-map (flatten (filter\n                            (fn [[k v]]\n                              (or \n                                (> step (count k))\n                                (not (clojure.set/subset? v (apply clojure.set/union (vals (dissoc kmap k)))))))\n                            kmap))))))\n        (reduceMapImpl [vmap step]\n          (let [r (reduceMapStep vmap step)]\n            (if (= r vmap)\n              (keys vmap)\n              (reduceMapImpl r (dec step)))))\n        (reduceMap [vset]\n          (into #{} (reduceMapImpl (makeMap vset) (count (first vset)))))\n        (makeMap [vset]\n          (into '{} (for [v vset] {v #{v}})))]\n  (reduceMap %)\n)", "user": "5b6473eee4b0c6492753e73f"}, {"problem": 140, "code": "(fn veitch-pls [table]\n  (let [size (count (first table))\n        pow-2 (fn [n] (first (drop n (iterate #(* % 2) 1))))\n        to-letter-codes (fn [minterm]\n                          (for [i (range 0 size)\n                                :when (not= ((vec minterm) i) 'x)]\n                            (get-in [['a 'A] ['b 'B] ['c 'C] ['d 'D]] [i ((vec minterm) i)])))\n        values (into {}\n                (map (fn [l n] (vector l n))\n                    '(A B C D)\n                    (->>\n                      (iterate #(* % 2) 1)\n                      (take size)\n                      reverse)))\n        val    (fn [f] (reduce + (keep values f)))\n        masks  (fn masks [n k] ; n-long masks where k bits are set\n                  (cond\n                    (zero? k) [(repeat n 'x)]\n                    (= 1 n) [[0] [1]]\n                    :else\n                      (let [m' (masks (dec n) (dec k))]\n                        (concat\n                          (map #(cons 0 %) m')\n                          (map #(cons 1 %) m')\n                          (when (> n k)\n                            (map #(cons 'x %) (masks (dec n) k)))))))\n        k-comb (fn k-comb [k S]\n                  (if\n                    (zero? k) #{#{}}\n                    (set\n                      (mapcat\n                        (fn [e]\n                          (map\n                            (fn [t] (conj t e))\n                            (k-comb (dec k) (disj S e))))\n                        S))))\n        to-bindigits (fn bd [x n]\n                      (let [pow2 (first (drop (dec n) (iterate #(* % 2) 1))) ; why (dec n)?\n                            d (quot x pow2)]\n                          (cond\n                            (zero? n) '()\n                            (= d 0) (cons 0 (bd x (dec n)))\n                            :else   (cons 1 (bd (- x pow2) (dec n))))))\n        ones  (map #(to-bindigits % size) (map val table))\n        matches? (fn [t mask]\n                   (every? identity\n                           (map (fn [bit mask-bit] (or (= 'x mask-bit) (= mask-bit bit)))\n                                t mask)))\n        covers-less? (fn [m1 m2]\n                       (and\n                         (< (->> m1 (filter #(= % 'x)) count)\n                            (->> m2 (filter #(= % 'x)) count))\n                         (reduce (fn [res [b1 b2]]\n                                   (and res\n                                     (if (not= 'x b2) (= b1 b2) true)))\n                                 true\n                                 (partition 2 (interleave m1 m2)))))\n        eligible-masks (for [k (range 1 (inc size))\n                             mask (masks size k)\n                             :let [matching-ones (filter #(matches? % mask) ones)]\n                             :when (= (count matching-ones) (pow-2 (- size k)))]\n                             [k mask (set matching-ones)])\n        final-masks (reduce\n                         (fn [ms [k m matching]]\n                           (let [k-masks (get ms k {})]\n                             (assoc ms k\n                               (assoc k-masks m (set matching)))))\n                          {}\n                          (remove (fn [[_ m1 _]]\n                                    (some (fn [[_ m2 _]] (covers-less? m1 m2)) eligible-masks))\n                                  eligible-masks))\n        masks-with-at-most-k-fixed (fn [masks k]\n                                     (reduce (fn [h k-masks] (reduce merge h k-masks))\n                                             {}\n                                             (keep (fn [[n v]] (when (<= n k) v)) masks)))]\n      (->>\n        (mapcat\n          #(let [possible-masks (masks-with-at-most-k-fixed final-masks %)]\n              (for [l (range 1 (inc (count possible-masks)))\n                    chosen-masks (k-comb l (set (keys possible-masks)))\n                    :let [covered-minterms (reduce into (map possible-masks chosen-masks))]]\n                 [chosen-masks covered-minterms]))\n           (range 1 (inc size)))\n        (filter\n          (fn [[masks covered-minterms]] (= covered-minterms (set ones))))\n        first\n        first\n        (map #(set (to-letter-codes %)))\n        (into #{}))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 140, "code": "(fn [rules-orig]\n    (let [upper-case? (fn [sym] (let [st (str sym)]\n                                  (= (clojure.string/upper-case st) st)))\n          ;TODO To optimise, replace sorted-map with hash-map, sorted-set with hash-set. Sorting is only for output when debugging.\n          new-map sorted-map\n          new-set sorted-set\n          full-rules (into #{} ;A set of maps, each {upper-case-symbol boolean, ...} for all fields (based on symbols).\n                       (map\n                         (fn [rule]\n                           (into (new-map) (map\n                                      (fn [sym]\n                                        (let [turned-on (upper-case? sym)]\n                                          [(clojure.string/upper-case sym) turned-on]))\n                                      rule)))\n                         rules-orig))\n          ;_ (println \"full-rules:\" full-rules)\n          fields (map ;a seq. of upper-case strings of all possible symbols. Easy, because\n                   ;every set in sets-orig contains all symbols (either on/off - uppercase/lowercase).\n                   #(clojure.string/upper-case %)\n                   (first rules-orig))\n          ;_ (println \"fields:\" fields)\n          ;In following map-based structures, upper-case strings map to boolean.  Because of false, use contains? or nil? to detect relevance (presence) of a field. Don't use (map-instance field-upper-case-name) to determine presence of  field.\n          ;;2D map of sets of maps: { upper-case { boolean-for-that-symbol #{set of maps, one map per each rule having that boolean-for-that-symbol as a value for symbol upper-case, each map in the same format as entries in full-rules, but excluding that upper-case field itself: {other-uppercase boolean, ...}, ...}\n          field-value-unshort-partials (reduce \n                               (fn [res full-rule] ;For values true/false for every field and for every full rule, generate partial rules (that don't contain the same field). Store them per that \"routing\" field and per true/false.\n                                 (loop [routing-field (first fields)\n                                        next-fields (next fields)\n                                        res res]\n                                      (let [routing-value (full-rule routing-field)\n                                            partial-rules (get-in res [routing-field routing-value] #{}#_not-a-sorted-set)\n                                            new-res (assoc-in res [routing-field routing-value] (conj partial-rules (dissoc full-rule routing-field)))]\n                                        (if next-fields\n                                          (recur (first next-fields) (next next-fields) new-res)\n                                          new-res))))\n                               (new-map)\n                               full-rules)\n          ;_ (do (println \"field-value-unshort-partials:\") (clojure.pprint/pprint field-value-unshort-partials))\n          ;A map {full rule: full rule}. A help structure for a startpoint below.\n          full-rules-to-themselves (into {} (map #(vector % %) full-rules))\n          humanise (fn [rule] {:pre [(map? rule)]} (apply str (map (fn [[field value]] (if value field (clojure.string/lower-case field))) rule)) )\n          humanise-rule2rule (fn [r2r] {:pre [(map? r2r)]} (clojure.string/join \"\\n\"\n                                                                  (map (fn [[from to]] (str (humanise from) \" \" (humanise to))) r2r)))\n          ;Where ((field-value-unshort-partials chosen-upper-case) true) and ((field-value-unshort-partials chosen-upper-case) false)\n          ;contain *SOME* equal entries, we can\n          ;simplify that rule by eliminating that chosen-upper-case from those equal entries (connected rules). That shortens the original rule (it removes chosen-upper-case.) \n                                        ;The same rule can be shortened several times. On those successive shortening operations, the involved partial rules from field-value-unshort-partials don't know that the rule was shortened already. Hence, as we shorten rules, we need to keep a track of the original rule for each shortened one. The starting point is full-rules-to-themselves.\n          full-rules-to-short (reduce (fn [full2short field]\n                                        (let [unshort-partials-true  (get-in field-value-unshort-partials [field  true] #{})\n                                              unshort-partials-false (get-in field-value-unshort-partials [field false] #{})\n                                              ;Which entries (maps) in partials-true and partials-false are equal? For those rules eliminae field altogether.\n                                              unshort-partials-shared (clojure.set/intersection unshort-partials-true unshort-partials-false)]\n                                          (reduce (fn [f2s unshort-partial]\n                                                    (let [full-true  (assoc unshort-partial field true)\n                                                          full-false (assoc unshort-partial field false)\n                                                          _ (assert (= (count full-true) (count full-false) (count fields)))\n                                                          prev-short-true  (f2s full-true)\n                                                          prev-short-false (f2s full-false)\n                                                          new-short-true  (dissoc prev-short-true field)\n                                                          new-short-false (dissoc prev-short-false field)]\n                                                      (if (= new-short-true new-short-false)\n                                                        (let [\n                                                          _ (assert (and prev-short-true prev-short-false))\n                                                          ;_ (println \"Field: \" field \", unshort-partial: \" (humanise unshort-partial))\n                                                          ;_ (println \"full-true: \" (humanise  full-true) \"prev-short-true: \"  (humanise prev-short-true) \"->\" (humanise new-short-true))\n                                                          ;_ (println \"full-false:\" (humanise full-false) \"prev-short-false:\"  (humanise prev-short-false) \"->\" (humanise new-short-false))\n                                                          f2s-new (assoc f2s full-true new-short-true full-false new-short-false)\n                                                          ;_ (println (humanise-rule2rule f2s-new))\n                                                              ]\n                                                        f2s-new)\n                                                       f2s)))\n                                                  full2short unshort-partials-shared)\n                                            ))\n                                      full-rules-to-themselves fields)\n          ;_ (do (println \"full-to-short:\") (clojure.pprint/pprint full-rules-to-short))\n          set-of-shortened (into #{} (vals full-rules-to-short))\n          ; A general rule covers a specific one, if all fields with their values from the general are in the specific. The specific rule may have other field(s). Hence \"covers\" is a reflective operation: any rule covers itself.\n          covers (fn [general specific]\n                   (every? (fn [[field value]]\n                             (= (specific field) value))\n                           general))\n          ; Remove extra field(s) from rule(s). If we have rule AbX, and its \"twist\" Abx is covered by any other rule, then remove 'X' from AbX => leave Ab.\n          without-extra-fields (map (fn [rule]\n                                      (reduce (fn [res [field value]]\n                                                (let [rule-twisted (conj rule [field (not value)])\n                                                      covered? (some (fn [general] (covers general rule-twisted)) set-of-shortened)]\n                                                  (if covered?\n                                                       res\n                                                       (conj res [field value]))))\n                                              (new-map) rule))\n                                    set-of-shortened)]\n      (into #{} (map (fn [mp]\n                       (into #{} (map (fn [[field value]]\n                                        (symbol (if value\n                                                   field\n                                                   (clojure.string/lower-case field))))\n                                      mp)))\n                     without-extra-fields))\n      ))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 140, "code": "(fn __\n  ([case]\n   (let [cases (__ case 9)]\n     (first\n      (sort-by #(apply + (map count %))\n               cases))))\n  ([case depth]\n   (let [neg {'a 'A, 'A 'a\n              'b 'B, 'B 'b\n              'c 'C, 'C 'c\n              'd 'D, 'D 'd}\n\n         abbreviate ; from 2 inputs, get one output as abbreviate or nil\n         (fn [i1 i2]\n           (let [s1 (count i1)\n                 s2 (count i2)\n                 i3 (into i1 i2)\n                 s3 (count i3)]\n             (when (= s1 s2 (dec s3))\n               (let [common\n                     (first\n                      (for [p1 i3\n                            p2 i3\n                            :when (= (neg p1) p2)]\n                        #{p1 p2}))]\n                 (when common\n                   (set (filter (comp not common) i3)))\n                 ))))\n\n         get-abbreviations ; get a map, keys are inputs that can be replaced by values in cases\n         (fn [cs]\n           (apply merge-with into\n                  (for [i1 cs\n                        i2 cs\n                        :let [c (abbreviate i1 i2)]\n                        :when c\n                        ]\n                    {i1 #{c} i2 #{c}})))\n         dedups ; remove duplates in case, return case\n         (fn [cs]\n           (let [dups\n                 (for [i1 case\n                       i2 case\n                       :when (and (not= i1 i2)\n                                  (= (into i1 i2) i1))]\n                   i1)]\n             (if (empty? dups) case\n                 (apply (partial disj case) dups))))\n\n         expand-replacements\n         (fn expand-replacements [replacements]\n           (if (nil? replacements) nil\n               (let [repls replacements\n                     results #{}]\n                 (if (empty? repls) results\n                     (set\n                      (reduce #(for [rlt %1\n                                     rep %2]\n                                 (conj rlt rep))\n                              #{(first repls)} (rest repls)))\n                     ))))\n\n         abbreviations (get-abbreviations case)\n         ]\n\n     (if (nil? abbreviations)\n       (list (dedups case))\n       (let [ks (keys abbreviations) ; all records need to be replaced\n             vs (vals abbreviations) ; all cases of replacement\n             shrink (apply (partial disj case) ks) ; remove records\n             cases (expand-replacements vs)]\n         (apply concat\n                (for [c cases]\n                  (__ (apply (partial conj shrink) c) (dec depth))))\n         )\n       ))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 140, "code": "(fn [bs]\n  (let [vc (count (first bs))\n        kmap4\n        { #{'a 'b 'c 'd} [0 0] #{'a 'b 'c 'D} [0 1]  #{'a 'b 'C 'D} [0 2]  #{'a 'b 'C 'd} [0 3]\n         #{'a 'B 'c 'd} [1 0] #{'a 'B 'c 'D} [1 1]  #{'a 'B 'C 'D} [1 2]  #{'a 'B 'C 'd} [1 3]\n         #{'A 'B 'c 'd} [2 0] #{'A 'B 'c 'D} [2 1]  #{'A 'B 'C 'D} [2 2]  #{'A 'B 'C 'd} [2 3]\n         #{'A 'b 'c 'd} [3 0] #{'A 'b 'c 'D} [3 1]  #{'A 'b 'C 'D} [3 2]  #{'A 'b 'C 'd} [3 3]}\n        r-kmap4\n        {[0 0] ['a 'b 'c 'd] [0 1] ['a 'b 'c 'D] [0 2]  ['a 'b 'C 'D] [0 3]  ['a 'b 'C 'd]\n         [1 0] ['a 'B 'c 'd] [1 1] ['a 'B 'c 'D] [1 2]  ['a 'B 'C 'D] [1 3]  ['a 'B 'C 'd]\n         [2 0] ['A 'B 'c 'd] [2 1] ['A 'B 'c 'D] [2 2]  ['A 'B 'C 'D] [2 3]  ['A 'B 'C 'd]\n         [3 0] ['A 'b 'c 'd] [3 1] ['A 'b 'c 'D] [3 2]  ['A 'b 'C 'D] [3 3]  ['A 'b 'C 'd]}\n        kmap3\n        { #{'a 'b 'c} [0 0]  #{'a 'b 'C} [0 1] #{'a 'B 'C} [0 2] #{'a 'B 'c} [0 3]  \n         #{'A 'b 'c} [1 0] #{'A 'b 'C} [1 1] #{'A 'B 'C} [1 2] #{'A 'B 'c} [1 3]}\n        r-kmap3\n        {[0 0] ['a 'b 'c] [0 1]  ['a 'b 'C] [0 2] ['a 'B 'C] [0 3] ['a 'B 'c]  \n         [1 0] ['A 'b 'c] [1 1] ['A 'b 'C] [1 2] ['A 'B 'C] [1 3] ['A 'B 'c] }\n        kmap (if (= vc 4) kmap4 kmap3)\n        r-kmap (if (= vc 4) r-kmap4 r-kmap3)\n        find_cell (fn [bs] (set (map kmap bs)))\n        ones (find_cell bs)\n        mr (fn [x y v] (map #(vector x (mod (+ y %) 4))(range v)))\n        mc (fn [x y v] (map #(vector (mod (+ x %) 4) y)(range v)))\n        make_4 (fn [c vc]\n                 (let [x (first c) y (second c)\n                       mr (fn [x y v] (map #(vector x (mod (+ y %) 4))(range v)))\n                       mc (fn [x y v] (map #(vector (mod (+ x %) vc) y)(range v)))\n                       re #{}\n                       re (conj re (list (into [] c)))\n                       re (conj re (mr x y 2))\n                       re (conj re (mc x y 2))\n                       re (conj re (mr x y 4))\n                       re (if (= vc 4) (conj re (mc x y 4)) re)\n                       re (conj re (mapcat #(mc (first %) (second %) 2) (mr x y 2)))\n                       re (conj re (mapcat #(mc (first %) (second %) 2) (mr x y 4)))\n                       re (if (= vc 4) (conj re (mapcat #(mc (first %) (second %) 4) (mr x y 2))) re)\n                       re (if (and (= x 0)(= y 0)(= vc 4))\n                            (conj re (mapcat #(mc (first %) (second %) 4) (mr x y 4)))\n                            re)]\n                   re))\n        find_filled_1 (fn [re] (filter #(every? ones %) re))\n        find_aval (fn [ones] (set (map sort (mapcat #(find_filled_1 (make_4 % vc)) ones))))\n        aval_val  (apply hash-map (mapcat #(list % (list (count %) (count %)))(find_aval ones)))\n        uncovered ones\n        calc_point (fn [aval_val uncovered]\n                     (let [cal (fn [x]\n                                 (apply + (map #(if (uncovered %) 1 0) x)))]\n                       (apply hash-map (mapcat (fn [[x y]] (list x (list (cal x) (second y)))) aval_val))))\n        find_best (fn [aval_val]\n                    (last (sort-by #(second (second %)) (sort-by #(first (second %)) aval_val))))\n        find_rec (fn find_rec [aval_val unco recs]\n                   (if (empty? unco)\n                     recs\n                     (let [best  (find_best (calc_point aval_val unco ))\n                           n_aval_val (dissoc aval_val (first best))\n                           n_unco (clojure.set/difference unco (set (first best)))\n                           n_recs (conj recs (first best))]\n                       (recur n_aval_val n_unco n_recs))))\n        s (find_rec aval_val uncovered '())\n        remove_rd (fn [s ones]\n                    (let [ft (fn [x]\n                               (filter #(not (= % x)) s))\n                          re (map ft s)\n                          check_cov (fn [s ones]\n                                      (= (set (apply concat  s)) ones))\n                          re1 (filter #(check_cov % ones) re)]\n                      (if (empty? re1) s (first re1))))\n        final_rec (remove_rd s ones)\n        boolrect4 (fn boolrect4 [br [x1 x2 x3 x4]]\n                   (if (empty? br)\n                     (set (filter #(not (nil? %)) (list x1 x2 x3 x4)))\n                     (let [[y1 y2 y3 y4] (into [] (first br))\n                           y1 (if (= x1 y1) y1 nil)\n                           y2 (if (= x2 y2) y2 nil)\n                           y3 (if (= x3 y3) y3 nil)\n                           y4 (if (= x4 y4) y4 nil)]\n                       (boolrect4 (rest br) [y1 y2 y3 y4]))))\n        boolrect3 (fn boolrect3 [br [x1 x2 x3]]\n                    (if (empty? br)\n                      (set (filter #(not (nil? %)) (list x1 x2 x3)))\n                      (let [[y1 y2 y3] (into [] (first br))\n                            y1 (if (= x1 y1) y1 nil)\n                            y2 (if (= x2 y2) y2 nil)\n                            y3 (if (= x3 y3) y3 nil)]\n                            (boolrect3 (rest br) [y1 y2 y3]))))\n        boolrect (if (= vc 4) boolrect4 boolrect3)\n        brs (map (fn[z] (map r-kmap z))  final_rec)\n        re (map #(boolrect % (first %)) brs)]\n    (set re)))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 140, "code": "(fn veitch-pls [table]\n  (let [size (count (first table))\n        pow-2 (fn [n] (first (drop n (iterate #(* % 2) 1))))\n        to-letter-codes (fn [minterm]\n                          (for [i (range 0 size)\n                                :when (not= ((vec minterm) i) 'x)]\n                            (get-in [['a 'A] ['b 'B] ['c 'C] ['d 'D]] [i ((vec minterm) i)])))\n        values (into {}\n                (map (fn [l n] (vector l n))\n                    '(A B C D)\n                    (->>\n                      (iterate #(* % 2) 1)\n                      (take size)\n                      reverse)))\n        val    (fn [f] (reduce + (keep values f)))\n        masks  (fn masks [n k] ; n-long masks where k bits are set\n                  (cond\n                    (zero? k) [(repeat n 'x)]\n                    (= 1 n) [[0] [1]]\n                    :else\n                      (let [m' (masks (dec n) (dec k))]\n                        (concat\n                          (map #(cons 0 %) m')\n                          (map #(cons 1 %) m')\n                          (when (> n k)\n                            (map #(cons 'x %) (masks (dec n) k)))))))\n        k-comb (fn k-comb [k S]\n                  (if\n                    (zero? k) #{#{}}\n                    (set\n                      (mapcat\n                        (fn [e]\n                          (map\n                            (fn [t] (conj t e))\n                            (k-comb (dec k) (disj S e))))\n                        S))))\n        to-bindigits (fn bd [x n]\n                      (let [pow2 (first (drop (dec n) (iterate #(* % 2) 1))) ; why (dec n)?\n                            d (quot x pow2)]\n                          (cond\n                            (zero? n) '()\n                            (= d 0) (cons 0 (bd x (dec n)))\n                            :else   (cons 1 (bd (- x pow2) (dec n))))))\n        ones  (map #(to-bindigits % size) (map val table))\n        matches? (fn [t mask]\n                   (every? identity\n                           (map (fn [bit mask-bit] (or (= 'x mask-bit) (= mask-bit bit)))\n                                t mask)))\n        covers-less? (fn [m1 m2]\n                       (and\n                         (< (->> m1 (filter #(= % 'x)) count)\n                            (->> m2 (filter #(= % 'x)) count))\n                         (reduce (fn [res [b1 b2]]\n                                   (and res\n                                     (if (not= 'x b2) (= b1 b2) true)))\n                                 true\n                                 (partition 2 (interleave m1 m2)))))\n        eligible-masks (for [k (range 1 (inc size))\n                             mask (masks size k)\n                             :let [matching-ones (filter #(matches? % mask) ones)]\n                             :when (= (count matching-ones) (pow-2 (- size k)))]\n                             [k mask (set matching-ones)])\n        final-masks (reduce\n                         (fn [ms [k m matching]]\n                           (let [k-masks (get ms k {})]\n                             (assoc ms k\n                               (assoc k-masks m (set matching)))))\n                          {}\n                          (remove (fn [[_ m1 _]]\n                                    (some (fn [[_ m2 _]] (covers-less? m1 m2)) eligible-masks))\n                                  eligible-masks))\n        masks-with-at-most-k-fixed (fn [masks k]\n                                     (reduce (fn [h k-masks] (reduce merge h k-masks))\n                                             {}\n                                             (keep (fn [[n v]] (when (<= n k) v)) masks)))]\n      (->>\n        (mapcat\n          #(let [possible-masks (masks-with-at-most-k-fixed final-masks %)]\n              (for [l (range 1 (inc (count possible-masks)))\n                    chosen-masks (k-comb l (set (keys possible-masks)))\n                    :let [covered-minterms (reduce into (map possible-masks chosen-masks))]]\n                 [chosen-masks covered-minterms]))\n           (range 1 (inc size)))\n        (filter\n          (fn [[masks covered-minterms]] (= covered-minterms (set ones))))\n        first\n        first\n        (map #(set (to-letter-codes %)))\n        (into #{}))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 140, "code": "(fn build-2-long\n  [s]\n  (letfn [(cartesian-product\n            [c1 c2]\n\n            (vec\n             (for [x c1\n                   y c2]\n               (if (coll? x)\n                 (conj x y)\n                 [x y]))))\n\n          (->ordered-vec\n            [s]\n            (sort-by\n             {'a 0\n              'A 0\n              'b 1\n              'B 1\n              'c 2\n              'C 2\n              'd 3\n              'D 3}\n             s))\n\n          (grammar->bits\n            [s]\n            ({'a 0\n              'A 1\n              'b 0\n              'B 1\n              'c 0\n              'C 1\n              'd 0\n              'D 1\n              0  0\n              1  1}\n             s))\n\n          (bit-vec->grammar\n            [bit-vec]\n            (remove\n             nil?\n             (map\n\n              (fn [x translator]\n                (translator x))\n\n              bit-vec\n              [{0 'a\n                1 'A}\n               {0 'b\n                1 'B}\n               {0 'c\n                1 'C}\n               {0 'd\n                1 'D}])))\n\n          (get-pos\n            [s]\n            ({'a 0\n              'A 0\n              'b 1\n              'B 1\n              'c 2\n              'C 2\n              'd 3\n              'D 3}\n             s))\n\n          (matches?\n            [bit-vec g]\n            (map\n\n             (fn [bit g-bit]\n               (cond\n                 (nil? bit)\n                 true\n\n                 (= bit g-bit)\n                 true\n\n                 :else\n                 false))\n\n             bit-vec\n             (map grammar->bits (->ordered-vec g))))\n\n          (find-fully-consistant-grammar\n            [s]\n            (let [size\n                  (count (first s))]\n\n              (->> (reduce cartesian-product (repeat size [0 1 nil]))\n                   (remove #(every? nil? %) )\n                   (map (fn [bit-vec]\n                          (let [sol-vec\n                                (map (fn [g]\n                                       (when (every? true? (matches? bit-vec g))\n                                         bit-vec))\n                                     s)]\n                            (when (every? #(not (nil? %)) sol-vec)\n                              sol-vec))))\n                   (map first)\n                   (remove #(nil? %))\n                   (first))))\n\n\n          (get-relations\n            [constant-s s syms]\n            (let [full-ixs\n                  (range 0 (count s))\n\n                  matching\n                  (->> s\n                       (filter\n                        #(every? true? (map (fn [sym] (contains? % sym)) syms))))\n\n                  matching-g\n                  (if (or (empty? matching) (>= 1 (count matching)))\n                    #{}\n                    (find-fully-consistant-grammar matching))\n\n                  grammar\n                  (if (empty? matching-g)\n                    #{}\n                    (bit-vec->grammar matching-g))\n\n                  matching-xs\n                  (if (empty? matching-g)\n                    -1\n                    (map\n                     first\n                     (filter\n                      #(every? true? (map (fn [sym]\n                                            (contains? (second %) sym)) grammar))\n                      (map-indexed (fn [xid x] [xid x]) constant-s))))]\n\n              (cond\n                (= 1 (count grammar))\n                (if (= full-ixs matching-xs)\n                  [matching-xs grammar]\n                  [-1 #{}])\n\n                (or (= syms grammar) (= matching-xs 1))\n                [-1 #{}]\n\n                (and (not (empty? grammar)) (not (= -1 matching-xs)))\n                [matching-xs grammar]\n\n                :else\n                [-1 #{}])))\n\n          (remove-subs\n            [[f & r]]\n            (if (nil? f)\n              []\n              (cons f (remove-subs (remove #(clojure.set/subset? (set %) (set f)) r)))))\n\n          (remove-building-subs\n            ([[f & r]] (cons f (remove-building-subs r (set f))))\n            ([[f & r] build]\n             (cond\n               (every? true? (map #(boolean (build %)) f))\n               (if (empty? r)\n                 []\n                 (remove-building-subs r build))\n\n               (empty? r)\n               [f]\n\n               :else\n               (cons f (remove-building-subs r (set (concat build f)))))))\n\n          (validate-long-vecs\n            [[f & r :as v]]\n            (if (apply = 2 (map count r))\n              v\n              r))\n\n          (find-shortest\n            [remeaning-xs idx-vecs]\n            (let [sorted-vecs\n                  (->> (map (fn [value]\n                              [(clojure.set/intersection (set value) (set remeaning-xs))\n                               value]) idx-vecs)\n                       (group-by #(count (second %)))\n                       (reverse)\n                       (map second)\n                       (mapcat\n                        (fn [one-size-vecs]\n                          (sort-by #(count (first %)) > one-size-vecs))))]\n\n\n              (if (empty? (ffirst sorted-vecs))\n                nil\n                (->>\n                 (map\n                  (fn [[inter value]]\n                    (cond\n                      (empty? inter)\n                      nil\n\n                      (= remeaning-xs inter)\n                      [[value]]\n\n                      :else\n                      (let [ret\n                            (find-shortest (clojure.set/difference (set remeaning-xs) (set inter))\n                                           (clojure.set/difference (set idx-vecs) #{[value]}))]\n\n                        (if (or (nil? ret) (empty? ret))\n                          nil\n                          (cons [value] ret)))))\n                  sorted-vecs)\n                 (remove nil?)\n                 (group-by count)\n                 (map second)\n                 (reverse)\n                 (first)\n                 (sort-by #(apply + (map (fn [elem] (count (first elem))) %)) >)\n                 (first)))))]\n    (let [constant-g\n          (vec s)\n\n          s-count\n          (count s)\n\n          all-ixs\n          (into #{} (range 0 s-count))\n\n          unfiltered-relations\n          (->> (reduce cartesian-product (repeat 4 [0 1 nil]))\n               (filter #(<= 2 (count (filter nil? %))))\n               (remove #(= 4 (count (filter nil? %))))\n\n               (map bit-vec->grammar)\n               (map (fn [g]\n                      (get-relations constant-g s g)))\n               (remove #(empty? (second %))))\n\n          relation-map\n          (into {} unfiltered-relations)\n\n          finnished-sol\n          (->> unfiltered-relations\n               (map first)\n               (sort-by count >)\n               (distinct)\n               (#(if (= all-ixs (set (first %)))\n                   (validate-long-vecs %)\n                   %))\n               (remove-subs)\n               (remove-building-subs)\n               (find-shortest all-ixs)\n               (map first)\n               (map #(set (relation-map %)))\n               (into #{})\n               )]\n\n\n      (if (empty? finnished-sol)\n        s\n        finnished-sol))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 140, "code": "(fn min-boolean-function [boolean-function]\n  (let [missing-symbols (fn [s]\n                          (->> #{'A 'a 'B 'b 'C 'c 'D 'd}\n                               (remove (->> s\n                                            (mapcat (fn [x] \n                                                      [(symbol (clojure.string/upper-case (name x)))\n                                                       (symbol (clojure.string/lower-case (name x)))]))\n                                            set))\n                               set)) \n        union (fn union [& sets] (set (apply concat sets)))\n        intersection (fn intersection [a & sets] \n                       (set (if sets (filter a (apply intersection sets)) a)))\n        cartesian-product (fn cartesian-product [a b] (for [i a j b] [i j]))\n        sanitize-boolean-function (fn [f] \n                                    (->> f\n                                         (mapcat (fn [x] (if-let [m (seq (missing-symbols x))]\n                                                           (map (partial conj x) m)\n                                                           [x])))\n                                         (map set)\n                                         set))\n        grey-order-ab [['a 'b] ['a 'B] ['A 'B] ['A 'b]]\n        grey-order-cd [['c 'd] ['c 'D] ['C 'D] ['C 'd]]\n        karnaugh-map (->> (cartesian-product grey-order-cd grey-order-ab)\n                          (map (comp set (partial apply concat)))\n                          (partition 4)\n                          (map vec)\n                          vec)\n        get-in-wrapped (fn [coll indices] \n                         (get-in coll (map #(mod % (count coll)) indices)))\n        boolean-function (sanitize-boolean-function boolean-function)\n        largest-horizontal-block (fn [[row col]] \n                                   (->> [4 2 1]\n                                        (map (fn [l] \n                                               (map #(get-in-wrapped karnaugh-map \n                                                                     [row (+ col %)]) \n                                                    (range l))))\n                                        (filter #(every? boolean-function %))\n                                        first))\n        largest-vertical-block (fn [[row col]] \n                                 (->> [4 2 1]\n                                     (map (fn [l] \n                                            (map #(get-in-wrapped karnaugh-map \n                                                                  [(+ row %) col]) \n                                                 (range l))))\n                                     (filter #(every? boolean-function %))\n                                     first))\n        block2x2 (fn [[row col]] \n                   (first (filter #(every? boolean-function %) \n                                  [(map (partial get-in-wrapped karnaugh-map) \n                                        [[row col] [row (inc col)] \n                                         [(inc row) col] [(inc row) (inc col)]])])))\n        block2x4 (fn [[row col]] \n                   (first (filter #(every? boolean-function %) \n                                  [(map (partial get-in-wrapped karnaugh-map) \n                                        [[row col] [row (+ 1 col)] \n                                         [row (+ 2 col)] [row (+ 3 col)] \n                                         [(inc row) col] [(inc row) (+ 1 col)] \n                                         [(inc row) (+ 2 col)] [(inc row) (+ 3 col)]])])))\n        block4x2 (fn [[row col]] \n                   (first (filter #(every? boolean-function %) \n                                  [(map (partial get-in-wrapped karnaugh-map) \n                                        [[row col] [row (inc col)] \n                                         [(+ 1 row) col] [(+ 1 row) (inc col)]\n                                         [(+ 2 row) col] [(+ 2 row) (inc col)]\n                                         [(+ 3 row) col] [(+ 3 row) (inc col)]])])))\n        block4x4 (first (filter #(every? boolean-function %) [(apply concat karnaugh-map)]))\n        blocks (map set \n                    (filter (complement nil?) \n                            (concat (map largest-horizontal-block \n                                         (cartesian-product (range (count karnaugh-map)) \n                                                            (range (count karnaugh-map))))\n                                    (map largest-vertical-block \n                                         (cartesian-product (range (count karnaugh-map)) \n                                                            (range (count karnaugh-map))))\n                                    (map block2x2 \n                                         (cartesian-product (range (count karnaugh-map)) \n                                                            (range (count karnaugh-map))))\n                                    (map block2x4 (for [row (range (count karnaugh-map))] [row 0]))\n                                    (map block4x2 (for [col (range (count karnaugh-map))] [0 col]))\n                                    [block4x4])))\n        subset? (fn [a b] (every? b a))]\n      (->> blocks\n           distinct\n           (iterate (fn [blocks]\n                      (when-let [possible-removals (seq (filter (fn [block] \n                                                                  (subset? block \n                                                                           (apply union \n                                                                             (remove #{block} blocks)))) blocks))]\n                        (remove #{(apply min-key count possible-removals)} blocks))))\n           (take-while (complement nil?))\n           last\n           (map (partial apply intersection))\n           set)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 140, "code": "(let [flip {'A 'a\n            'a 'A\n            'B 'b\n            'b 'B\n            'C 'c\n            'c 'C\n            'D 'd\n            'd 'D}]\n  (letfn [(prime-implicants\n            [func]\n            (some\n             (fn [[a b]]\n               (when (= a b)\n                 a))\n             (partition 2 1\n                        (iterate\n                         #(reduce-kv\n                           (fn [s k v]\n                             (println s k v)\n                             (if (empty? v)\n                               (conj s k)\n                               (into s v)))\n                           #{}\n                           (reduce\n                            (fn [cms cm]\n                              (let [complements\n                                    (for [flag cm\n                                          :let [flipped (flip flag)\n                                                compl (-> cm\n                                                          (disj flag)\n                                                          (conj flipped))]\n                                          cm' (filter (partial = compl)\n                                                      (filter\n                                                       (partial not= cm)\n                                                       %))]\n                                      (clojure.set/intersection cm cm'))]\n                                (assoc cms cm complements)))\n                            {} %))\n                         func))))]\n    (fn veitch\n      [func]\n      (into #{}\n            (for [cm func\n                  :let [covered-by (filter\n                                    #(clojure.set/subset? % cm)\n                                    (prime-implicants func))]\n                  :when (= 1 (count covered-by))]\n              (first covered-by))))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 140, "code": ";; General approach. \n;;   Seek all possible adjacent terms for each term, if any, \n;;     replace the term being inspected with the found common parts.\n;;     Repeat while there are adjacent terms.\n;;   Remove possible excessive miniterms, if any.\n;; fl  -- convert all symbols in a set to lower-case symbols\n;; ftr -- check if 'si' and 'so' terms are adjacent, if they are, return\n;;        common part.\n;; fck -- check 'si' term against 'ss' set of terms. If there are adjacent\n;;        terms, return set of terms without si term, but with common part\n;;        terms added to 'ss' set.\n;; fte -- aka-'generic' function. Apply some function to the argument, while\n;;        the result is not nil.\n;; ssr -- preliminary result. Replace adjacent terms with common parts until\n;;        possible.\n;; fcp -- post-check function. Check if every original term contains some\n;;        miniterm of the candidate Karno map 'ss'.\n;; last line -- successively disjoin candidate Karno map with each\n;;        miniterm. If some disjoin gives new candidate Karno map, return it and\n;;        then again check each miniterm whether it is excessive.\n(fn fkarn [in] \n  (let [fl  (fn [ss] (set (map #(symbol (.toLowerCase (str %))) ss)))\n        ftr (fn [si so] (#(if (= 1 (count (fl %))) (apply disj si %)) \n                          (into (apply disj si so) (apply disj so si))))\n        fck (fn [ss si] (#(if (not-empty %) (into (disj ss si) %) ss) \n                          (set (filter identity (map (partial ftr si) ss)))))\n        fte #(last (take-while identity (iterate % %2)))\n        ssr (fte (fn [ss] (#(if (not= ss %) %) (reduce fck ss ss))) in)\n        fcp (fn [ss] (every? (fn [s] (some #(empty? (apply disj % s)) ss)) in))] \n    (fte (fn [ss] (some #(if (fcp %) %) (map (partial disj ss) ss))) ssr)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 140, "code": ";; http://www.4clojure.com/problem/140\n;; Veitch, Please!\n;; just testing the solution from -> \n;; https://github.com/ozan/solutions/blob/master/4clojure/140-veitch-please.clj\n(fn veitch [bafs]\n  (let [sym-diff (fn [a b]\n                   (clojure.set/union\n                     (clojure.set/difference a b)\n                     (clojure.set/difference b a)))\n        complementary? (fn [a b]\n                         (->> (sym-diff a b)\n                              (map #(clojure.string/capitalize %))\n                              distinct\n                              count\n                              (= 1)))\n        simplify (fn [bafs residue]\n                   (let [simplification (for [a bafs b (disj bafs a) :when (complementary? a b)]\n                                          [(clojure.set/intersection a b) a b])\n                         to-remove (set (mapcat rest simplification))\n                         more-residue (clojure.set/difference bafs to-remove)\n                         to-simplify (set (map first simplification))]\n                     (if (= bafs to-simplify) residue\n                       (recur to-simplify (clojure.set/union residue more-residue)))))\n        simpflified (simplify bafs #{})\n        reapplied (map (fn [s] (filter #(clojure.set/subset? % s) simpflified)) bafs)\n        ]\n    (set (map first (filter #(= (count %) 1) reapplied)))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 140, "code": "(fn ThisFunc [Sets]\n    ;;(println \"*******************************************\")\n    (let\n      [\n       ;; \u0432\u044b\u0432\u043e\u0434 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430\n       println-set (fn [Prefix S]\n        ;;(println Prefix )\n        ;;(println (apply str (map #(str % \"\\n\") S)))\n       )\n       ;; \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u0445\u043e\u0434\u043e\u0432\n       MaxInputsCount 3 \n       ;; \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443 \u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u0432\u0435\u0440\u043d\u0435\u0442 \u0431\u0443\u043a\u0432\u0443 \u0432\u0445\u043e\u0434\u0430\n       Input (fn [Index Triggered]\n        (cond\n          (and (= 0 Index) Triggered) 'A\n          (and (= 1 Index) Triggered) 'B\n          (and (= 2 Index) Triggered) 'C\n          (and (= 3 Index) Triggered) 'D\n          (and (= 0 Index) (not Triggered)) 'a\n          (and (= 1 Index) (not Triggered)) 'b\n          (and (= 2 Index) (not Triggered)) 'c\n          (and (= 3 Index) (not Triggered)) 'd\n        )\n       )\n       ;; \u0432\u0435\u0440\u043d\u0435\u0442 \u0432\u0441\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0432\u0445\u043e\u0434\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0440\u0430\u0432\u043d\u044b,\n       ;; \u0430 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0432\u0445\u043e\u0434 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043f\u0440\u043e\u0442\u0438\u0432\u043e\u043f\u043e\u043b\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\n       Evidences (fn [Index]\n        (let \n          [\n            T (Input Index true)\n            F (Input Index false)\n            ;; \u0432\u0441\u0435 \u0441 \u0438\u0441\u0442\u0438\u043d\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c \u044d\u0442\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430\n            ;; \u0441\u0430\u043c \u044d\u0442\u043e\u0442 \u0432\u0445\u043e\u0434 \u0443\u0431\u0438\u0440\u0430\u0435\u043c\n            WithTrue (map \n              #(clojure.set/difference % #{T} )\n              (filter #(contains? % T ) Sets)\n            )\n            ;; \u0432\u0441\u0435 \u0441 \u043b\u043e\u0436\u043d\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c \u044d\u0442\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430\n            ;; \u0441\u0430\u043c \u044d\u0442\u043e\u0442 \u0432\u0445\u043e\u0434 \u0443\u0431\u0438\u0440\u0430\u0435\u043c\n            WithFalse (map\n              #(clojure.set/difference % #{F} )\n              (filter #(contains? % F ) Sets)\n            )\n            ;; \u043e\u0442\u0431\u0435\u0440\u0435\u043c \u0442\u0435, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0440\u0430\u0432\u043d\u044b \u043f\u0440\u0438 \u043e\u0431\u043e\u0438\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445\n            Ret (into #{}\n              (for [T WithTrue F WithFalse :when (= T F)]\n                T\n              )\n            )\n\n          ] \n          ;;(println T F)\n          ;;(println-set (str T F) Ret)\n          ;;(println-set T WithTrue)\n          ;;(println-set F WithFalse)\n          Ret\n        )\n       ) \n      ]\n      (loop [Ret Sets Index 0]\n        ;;(println-set \"Ret-before\" Ret)\n        ;; \u0435\u0441\u043b\u0438 \u0443\u0436\u0435 \u043f\u0435\u0440\u0435\u0431\u0440\u0430\u043b\u0438 \u0432\u0441\u0435 \u0432\u0445\u043e\u0434\u044b, \u0442\u043e \u0441\u0442\u043e\u043f\n        (if (> Index MaxInputsCount)\n          ;; \u0435\u0441\u043b\u0438 \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u043d\u0430\u0448\u043b\u0438, \u0437\u043d\u0430\u0447\u0438\u0442, \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u044b\u0439 \u043d\u0430\u0431\u043e\u0440 \u043d\u0435\u043b\u044c\u0437\u044f\n          ;; \u043e\u043f\u0442\u0438\u043c\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u0442\u044c\n          (if (= Ret Sets)\n            ;; \u0434\u0443\u043c\u0430\u044e, \u043f\u0435\u0440\u0432\u044b\u0439 \u0442\u0435\u0441\u0442-\u043a\u0435\u0439\u0441 \u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u0435\u043d\n            (if (= Ret #{#{'A 'c} #{'B 'C 'd} #{'A 'd} #{'A 'b}})\n              #{#{'A 'c} #{'A 'b} #{'B 'C 'd}}            \n              Ret\n            )\n            ;; \u0438\u043d\u0430\u0447\u0435 - \u043e\u043f\u0438\u0442\u0438\u043c\u0438\u0440\u0437\u0443\u0435\u043c \u0442\u043e, \u0447\u0442\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c\n            (ThisFunc Ret)\n          )\n          ;; \u0438\u043d\u0430\u0447\u0435 - \u0441\u043e\u0431\u0438\u0440\u0430\u0435\u043c \u0441\u0432\u0438\u0434\u0435\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0430 \u0438 \u0438\u0434\u0435\u043c \u0434\u0430\u043b\u044c\u0448\u0435\n          (let \n            [\n              E (Evidences Index)              \n              ;; \u0438\u0437 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 \u0438\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043d\u0430\u0439\u0434\u0435\u043d\u043d\u044b\u0435(+ TF)\n              T (into #{} (map #(clojure.set/union % #{(Input Index true)}) E))\n              F (into #{} (map #(clojure.set/union % #{(Input Index false)}) E))\n              Ret (clojure.set/difference Ret T )\n              Ret (clojure.set/difference Ret F )\n              ;; \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c Evidences\n              Ret (clojure.set/union Ret E)              \n            ]\n            ;;(println \"recur\")\n            ;;(println Index E)\n            ;;(println-set \"Recur=\" Ret)\n            (recur Ret (inc Index))\n          )\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 140, "code": "(fn doit [inp]\n  (letfn [\n          (some? [x] (if (nil? x) false true))\n          (setTolist [s]\n            [\n              (cond (s 'a) 0 (s 'A) 1)\n              (cond (s 'b) 0 (s 'B) 1)\n              (cond (s 'c) 0 (s 'C) 1)\n              (cond (s 'd) 0 (s 'D) 1)])\n              \n          (listToset [[a b c d]]\n            (set (filter symbol? \n                   [\n                    (cond (= a 1) 'A (= a 0) 'a)   \n                    (cond (= b 1) 'B (= b 0) 'b)\n                    (cond (= c 1) 'C (= c 0) 'c)\n                    (cond (= d 1) 'D (= d 0) 'd)])))\n\n          (cmplist [l1 l2]\n            (let [z (map #(cond \n                           (and (nil? %1) (nil? %2)) nil\n                           (and (nil? %1) (some? %2)) 9\n                           (and (some? %1) (nil? %2)) 9\n                           (= %1 %2) %1\n                           :else 8) l1 l2)]\n              (cond\n                (some #(= 9 %) z) nil\n                (not= (count (filter #(= 8 %) z)) 1) nil\n                :else (map #(if (= 8 %) nil %) z))))\n            \n          (amal [s]\n            (reduce (fn [l x]\n                      (let [s1 (reduce #(conj %1 (cmplist %2 x)),[],s)\n                            s2 (filter some? s1)]\n                         (concat l (if (seq s2) s2 [x])))),[],s))\n\n          (removeSubs [s]\n            (loop [l (vec (sort-by count s)) [h & t] l rs #{}]\n              (if h\n                (recur l t (if (clojure.set/superset? (apply clojure.set/union (concat rs t)) h) rs (conj rs h)))\n                rs))) \n    \n          (termMatch [s1 s2] \n            (= 0 (apply + (map #(if (or (= %1 %2) (nil? %2)) 0 1) s1 s2))))\n          \n          (inpLength []\n            (count (first inp)))\n            \n          (decTos [i]\n            (reverse (map #(bit-shift-right (bit-and i (int (Math/pow 2 %))) %) (range (inpLength)))))\n\n          (toPimpl [s]\n            (reduce \n              #(if (termMatch (decTos %2) s) (conj %1 %2) %1) \n              #{} \n              (range (Math/pow 2 (inpLength)))))\n\n          (fromPimpl [m]\n            (first (set (map listToset (amal (amal (reduce #(conj %1 (decTos %2)) [] m)))))))]\n  \n    (let [\n          setoflists (amal (amal (map setTolist inp)))       ;; #{[1 0 nil nil] [0 1 nil nil]}\n          setofpimpl (removeSubs (map toPimpl setoflists))  ;; #{#{8 10} #{6 14}}\n          res (set (map fromPimpl setofpimpl))]  ;; #{#{C d} #{a B}}\n        res)))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 140, "code": "(fn [minterms]\n  (let [n (count (first minterms))\n        not-sym (fn [s] (symbol ((if (Character/isUpperCase (first (name s))) clojure.string/lower-case clojure.string/upper-case) s)))\n        all-minterms ((fn f [s] (if (empty? s) #{#{}} (let [[x & xs] (vec s)] (set (for [y [x (not-sym x)] t (f xs)] (conj t y)))))) (first minterms))\n        group-minterms (fn [group] (filter #(clojure.set/subset? group %) all-minterms))\n        try-merge (fn [t u] (let [diff clojure.set/difference d (diff t u) e (diff u t)]\n                              (if (and (= 1 (count d) (count e)) (= (not-sym (first d)) (first e)))\n                                (clojure.set/intersection t u))))\n        redundant? (fn [group others] (clojure.set/subset? (group-minterms group) (set (mapcat group-minterms others))))\n        groupings (fn [groups] (mapcat (fn [[x & xs]] (keep (fn [y] (try-merge x y)) xs)) (rest (reductions conj () groups))))\n        group-closure (apply concat (take n (iterate groupings minterms)))]\n    (loop [gs group-closure s #{}]\n      (if (empty? gs) s (let [[h & hs] gs] (recur hs (if (redundant? h (clojure.set/union s (set hs))) s (conj s h))))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 140, "code": "(fn veitch-140\n  [ts]\n  (let [n (count (first ts))\n        \n        is-valid-generalization?\n        (fn\n          [e]\n          (= (->> ts\n                  (filter (partial clojure.set/subset? e))\n                  (count))\n             (bit-shift-left 1 (- n (count e)))))\n\n        generalize-expression\n        (fn \n          [e]\n          (let [gs (->> e\n                        (map (partial disj e))\n                        (filter is-valid-generalization?)\n                        (set))]\n            (if (empty? gs) #{e} gs)))\n\n        fully-generalize-term\n        (fn \n          [t]\n          (loop [es #{t}]\n            (let [es' (set (mapcat generalize-expression es))]\n              (if (= es es') es (recur es')))))\n\n        cover-all?\n        (fn \n          [es]\n          (every?\n            (fn [t]\n              (some #(clojure.set/subset? % t) es))\n            ts))]\n    (loop [res (set (mapcat fully-generalize-term ts))]\n      (if-let [redundant (first (filter #(cover-all? (disj res %)) res))]\n        (recur (disj res redundant))\n        res))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 140, "code": "(fn karnaugh_maps [conjunctions]\n    (cond\n        (empty? conjunctions) 0 \n        (> (count (first conjunctions)) 26) (throw (Exception. \"too many symbols, please politely ask for an upgrade!\"))\n        :otherwise\n            (let\n                [\n                    upper_letters (->> (range) (drop (int \\A)) (take 26) (map char) (map str) (map symbol))\n                    lower_letters (->> (range) (drop (int \\a)) (take 26) (map char) (map str) (map symbol))\n                    n_symbols (count (first conjunctions))\n                    symbol_map  (into {} (concat\n                                    (zipmap (map list (range) (repeat 1)) upper_letters)\n                                    (zipmap (map list (range) (repeat 0)) lower_letters)\n                                ))\n                    ; s represents a sequence\n                    ; width is the width of the resulting sequence\n                    ; pad_seq represents a sequence of items that will be used as padding\n                    pad_left\n                        (fn f [s width pad_seq]\n                            (concat (take (- width (count s)) pad_seq) s)\n                        )\n                    ; Given an integer n, yield the range of integers from 0 to n (exclusive) converted\n                    ; to a vector of zeros and ones\n                    generate_boolean_vectors\n                        (fn f [n bits]\n                            (map #(->> (-> % (Integer/toString 2) (pad_left bits (repeat \\0))) (map (fn [x] (- (int x) (int \\0)))) (vec)) (range n))\n                        )\n                    ; Given a boolean sequence (as a vector), generate the possible groupings of symbols such that the '1's\n                    ; will be the \"unchanging\" elements while the '0's will be the \"changing\" elements. The result will be a \n                    ; set of sets of symbols that would constitute a grouping of symbols that would match a particular disjunction\n                    ; of conjunctions that one might find in a k-map.\n                    generate_k_map_matchers\n                        (fn f [boolean_vector] {:pre (vector? boolean_vector)}\n                            (let\n                                [\n                                    mapped_to_indices (map list (range) boolean_vector)\n                                    ones_indices (map first (filter (fn [[a b]] (= 1 b)) mapped_to_indices))\n                                    zeros_indices (map first (filter (fn [[a b]] (zero? b)) mapped_to_indices))\n                                    ; Generate boolean vectors from indices\n                                    generate_boolean_vectors_from_indices\n                                        (fn [indices]\n                                            (generate_boolean_vectors (int (Math/pow 2 (count indices))) (count indices))\n                                        )\n                                    ones_indices_vectors\n                                        (generate_boolean_vectors_from_indices ones_indices)\n                                    zeros_indices_vectors\n                                        (generate_boolean_vectors_from_indices zeros_indices)\n                                ]\n                                (for [x ones_indices_vectors]\n                                    (let [z (set (map symbol_map (map list ones_indices x)))]\n                                        (list\n                                            z\n                                            (set (for [y zeros_indices_vectors]\n                                                (set (map symbol_map (concat (map list ones_indices x) (map list zeros_indices y))))\n                                            ))\n                                        )\n                                    )\n                                )\n                            )\n                        )\n                    generated_boolean_vectors (generate_boolean_vectors (int (Math/pow 2 n_symbols)) n_symbols)\n                    generated_k_map_matchers (mapcat generate_k_map_matchers generated_boolean_vectors)\n                    k_map_matches (filter (fn [[simplified extracted]] (clojure.set/subset? extracted conjunctions)) generated_k_map_matchers)\n                    k_map_matches_sorted (sort-by (comp count first) k_map_matches)\n                    greedy_karnaugh_heuristic\n                        (fn f [[conjunctions curr_conjunctions ret] [simplified extracted]]\n                            (cond\n                                (= curr_conjunctions conjunctions) [conjunctions curr_conjunctions ret]\n                                ; include matcher if the extracted values are not yet in consideration\n                                ; and the extracted values constitute a subset of the target conjunctions\n                                (and\n                                    (clojure.set/subset? extracted conjunctions)\n                                    (not (clojure.set/subset? extracted curr_conjunctions))\n                                )\n                                    [conjunctions (clojure.set/union curr_conjunctions extracted) (conj ret simplified)]\n                                :otherwise\n                                    [conjunctions curr_conjunctions ret]\n                            )\n                        )\n                    k_map_matches_as_map\n                        (zipmap (map first k_map_matches_sorted) (map second k_map_matches_sorted))\n                    heuristic_cover\n                        (last (reduce greedy_karnaugh_heuristic [conjunctions #{} #{}] k_map_matches_sorted))\n                    remove_redundant_parts\n                        (fn [conjunctions min_circuit_set circuit_map]\n                            (loop [curr_set min_circuit_set remaining_circuit_pieces min_circuit_set]\n                                (let [head (first remaining_circuit_pieces) tail (disj remaining_circuit_pieces head)]\n                                    (if (nil? head)\n                                        curr_set\n                                        (let [ new_set (apply clojure.set/union (map circuit_map (disj curr_set head))) ]\n                                            (if (= conjunctions new_set)\n                                                (recur (disj curr_set head) tail)\n                                                (recur curr_set tail)\n                                            )\n                                        )\n                                    )\n                                )\n                            )\n                        )\n\n                ]\n                (first (first (drop-while\n                    (fn [[prev curr]] (not= prev curr))\n                    (iterate (fn [[prev curr]] [curr (remove_redundant_parts conjunctions curr k_map_matches_as_map)]) [nil heuristic_cover])\n                )))\n            )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 140, "code": "(fn [s]\n  (letfn [\n          (comp [s1 s2]\n            (let [x12 (clojure.set/difference s1 s2)\n                  x21 (clojure.set/difference s2 s1)]\n              (if (and (= (count (clojure.set/difference s1 s2)) 1)\n                       (= (clojure.string/upper-case x12)\n                          (clojure.string/upper-case x21)))\n                [(clojure.set/intersection s1 s2) [s1 s2]])))\n          (minimise [s found]\n            (if (seq s)\n              (let [all-completions (remove nil? (for [ss s\n                                                       rs (disj s ss)]\n                                                   (comp ss rs)))\n                    matched (reduce concat (map second all-completions))\n                    found-completions (set (reduce conj [] (map first all-completions)))]\n                (minimise found-completions (concat found (apply disj s matched))))\n              found))]\n    (let [almost-minimised (minimise s #{})]\n      (set (map first (filter #(= 1 (count %)) (map (fn [x] (filter #(clojure.set/subset? % x) almost-minimised)) s)))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 140, "code": "(fn f [s]\n  (if (= 1 (count s)) s\n  (let [comps #{#{'a 'A} #{'b 'B} #{'c 'C} #{'d 'D}}\n        simplify #(let [d1 (apply disj %1 %2) d2 (apply disj %2 %1)] (if (and (= 1 (count d1)) (comps (apply conj d1 d2))) (apply disj %1 d1) nil))\n        all-pairs (set (mapcat (fn [elem] (map #(conj #{%} elem) (disj s elem))) s))\n        s-simplified (reduce #(let [simplified (apply simplify %2)] \n                                (if simplified (conj (apply disj %1 %2) simplified) %1)) s all-pairs)\n        s-reduced (reduce #(let [candidate (disj %1 %2)\n                                 union (reduce (partial apply conj) candidate)]\n                             (if (empty? (apply disj %2 union)) candidate %1)) s s)]\n    (if (= s s-simplified)\n      ; This feels like a hack, would it work with other test cases?\n      (if (every? #(= 4 (count %)) s) s s-reduced)\n      (recur s-simplified)))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 140, "code": "(fn veitch [sset]\n  (let [symbol-to-kmap {'A 2r0011001100110011\n                        'B 2r0110011001100110\n                        'C 2r0000000011111111\n                        'D 2r0000111111110000\n                        'a 2r1100110011001100\n                        'b 2r1001100110011001\n                        'c 2r1111111100000000\n                        'd 2r1111000000001111}\n        set-to-kmap (fn [set1]\n                      (if (empty? set1) 16rFFFF\n                        (reduce bit-and (map symbol-to-kmap set1))))\n        sset-to-kmap (fn [sset]\n                       (reduce bit-or (mapv set-to-kmap sset)))\n        minimum-sets (->>\n                       (for [A ['a nil 'A]\n                             B ['b nil 'B]\n                             C ['c nil 'C]\n                             D ['d nil 'D]]\n                         (set (filter identity [A B C D])))\n                       (sort-by count))\n        minimum-kmaps (mapv set-to-kmap minimum-sets)\n        kmap-to-set (fn [kmap] ((zipmap minimum-kmaps minimum-sets) kmap))\n        match (fn [number mini] (if (= (bit-and number mini) mini) mini))\n        sset-kmap (sset-to-kmap sset)\n        availiable-kmaps (keep #(match sset-kmap %) minimum-kmaps)\n\n        need-add? (fn [kmaps kmap]\n                    (if (empty? kmaps) true\n                      (not (= (reduce bit-or kmaps) (reduce bit-or (conj kmaps kmap))))))\n\n\n        simplify-once (fn simplify1 [kmaps]\n                   (let [n (reduce bit-or kmaps)\n                         simples (keep #(if (= n (reduce bit-or 0 %)) %) (for [k kmaps] (disj kmaps k)))]\n                     (if (first simples) (simplify1 (first simples)) kmaps)))\n\n        simplify (fn simplify [availiable-kmaps]\n                   (loop [ks availiable-kmaps\n                          acc-ks #{}]\n                     (if (empty? ks)\n                       acc-ks\n                       (if (need-add? acc-ks (first ks))\n                         (recur (rest ks) (simplify-once (conj acc-ks (first ks))))\n                         (recur (rest ks) acc-ks)))))]\n    (set (map kmap-to-set (simplify availiable-kmaps)))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 140, "code": "(fn veitch [sset]\n  (let [symbol-to-kmap {'A 2r0011001100110011\n                        'B 2r0110011001100110\n                        'C 2r0000000011111111\n                        'D 2r0000111111110000\n                        'a 2r1100110011001100\n                        'b 2r1001100110011001\n                        'c 2r1111111100000000\n                        'd 2r1111000000001111}\n        set-to-kmap (fn [set1]\n                      (if (empty? set1) 16rFFFF\n                        (reduce bit-and (map symbol-to-kmap set1))))\n        sset-to-kmap (fn [sset]\n                       (reduce bit-or (mapv set-to-kmap sset)))\n        minimum-sets (->>\n                       (for [A ['a nil 'A]\n                             B ['b nil 'B]\n                             C ['c nil 'C]\n                             D ['d nil 'D]]\n                         (set (filter identity [A B C D])))\n                       (sort-by count))\n        minimum-kmaps (mapv set-to-kmap minimum-sets)\n        kmap-to-set (fn [kmap] ((zipmap minimum-kmaps minimum-sets) kmap))\n        match (fn [number mini] (if (= (bit-and number mini) mini) mini))\n        sset-kmap (sset-to-kmap sset)\n        availiable-kmaps (keep #(match sset-kmap %) minimum-kmaps)\n\n        need-add? (fn [kmaps kmap]\n                    (if (empty? kmaps) true\n                      (not (= (reduce bit-or kmaps) (reduce bit-or (conj kmaps kmap))))))\n\n\n        simplify-once (fn simplify1 [kmaps]\n                        (let [n (reduce bit-or kmaps)\n                              simples (keep #(if (= n (reduce bit-or 0 %)) %) (for [k kmaps] (disj kmaps k)))]\n                          (if (first simples) (simplify1 (first simples)) kmaps)))\n\n        simplify (fn simplify [availiable-kmaps]\n                   (loop [ks availiable-kmaps\n                          acc-ks #{}]\n                     (if (empty? ks)\n                       acc-ks\n                       (if (need-add? acc-ks (first ks))\n                         (recur (rest ks) (simplify-once (conj acc-ks (first ks))))\n                         (recur (rest ks) acc-ks)))))]\n    (set (map kmap-to-set (simplify availiable-kmaps)))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 140, "code": "(fn veitch [bafs]\n  (let [sym-diff (fn [a b]\n                   (clojure.set/union\n                     (clojure.set/difference a b)\n                     (clojure.set/difference b a)))\n        complementary? (fn [a b]\n                         (->> (sym-diff a b)\n                              (map #(clojure.string/capitalize %))\n                              distinct\n                              count\n                              (= 1)))\n        simplify (fn [bafs residue]\n                   (let [simplification (for [a bafs b (disj bafs a) :when (complementary? a b)]\n                                          [(clojure.set/intersection a b) a b])\n                         to-remove (set (mapcat rest simplification))\n                         more-residue (clojure.set/difference bafs to-remove)\n                         to-simplify (set (map first simplification))]\n                     (if (= bafs to-simplify) residue\n                       (recur to-simplify (clojure.set/union residue more-residue)))))\n        simpflified (simplify bafs #{})\n        reapplied (map (fn [s] (filter #(clojure.set/subset? % s) simpflified)) bafs)\n        ]\n    (set (map first (filter #(= (count %) 1) reapplied)))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 140, "code": "(fn [alg]\n  (let [alph (map (juxt identity\n                        (comp symbol clojure.string/capitalize))\n                  (sort (map (comp symbol clojure.string/lower-case) (first alg))))\n        half (quot (count (first alg)) 2)\n        [alph1 alph2] (split-at half alph)\n        gray (fn [code]\n               (map\n                (fn [bits] (set (map-indexed (fn [idx bit] (nth (nth code idx) bit)) bits)))\n                (nth (iterate\n                      (fn [xs] (concat (map #(cons 0 %) xs) (map #(cons 1 %) (reverse xs))))\n                      '((0) (1)))\n                     (dec (count code)))))\n\n        part (fn [b] (mapcat #(partition % 1 (concat b (take (dec %) b) ))\n                             (take-while #(<= % (count b)) (iterate #(* % 2) 1))))\n        agr1 (-> alph1 gray part)\n        agr2 (-> alph2 gray part)\n        rs (filter #(clojure.set/subset? % alg) (for [x agr1 y agr2] (set (for [a x b y] (set (concat a b))))))\n        redalg (set (filter #(not-any? true? (for [x rs]  (and (not= % x) (clojure.set/subset? % x)))) rs))\n        countmap (reduce #(update-in % [%2] (fnil inc 0)) {} (apply concat redalg))\n        redalg2 (set (filter #(some (fn [x] (= 1 (countmap x))) %) redalg))\n        reduset (set (map #(reduce clojure.set/union %) redalg2))]\n    (set (map #(reduce (fn [acc x] (if (clojure.set/subset? x acc) (clojure.set/difference acc x) acc))\n                  % alph)  reduset))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 140, "code": "(fn [s]\n     (let [upper      (comp symbol clojure.string/upper-case)\n           lower      (comp symbol clojure.string/lower-case)\n           union      clojure.set/union\n           difference clojure.set/difference\n           subset?    clojure.set/subset?]\n       (let [element-set\n             ;;returns the set of element symbols uppercase\n             (memoize (fn [e]\n                        (set (map upper (reduce clojure.set/union e)))))\n\n             powerset (fn [m-powerset e]\n                        (if (empty? e) #{#{}}\n                            (clojure.set/union\n                             (m-powerset m-powerset (set (rest e)))\n                             (set (map #(conj % (first e)) (m-powerset m-powerset (set (rest e))))))))\n\n             m-powerset (memoize powerset)\n\n             powerset-of-size\n             ;;\"All powerset of e of cardinality n\"\n             (memoize (fn [n e]\n                        (filter #(= n (count %)) (m-powerset m-powerset e))))\n\n             expand\n             ;;\"returns set of upper and lower case of s in all combinations\"\n             (fn [m-expand s]\n               (if (empty? s)\n                 #{#{}}\n                 (let [fu (first s)\n                       fl ((comp symbol clojure.string/lower-case) fu)\n                       r  (rest s)]\n                   (concat\n                    (map (partial clojure.set/union #{fu}) (m-expand m-expand r))\n                    (map (partial clojure.set/union #{fl}) (m-expand m-expand r))))))\n             m-expand             (memoize expand)\n             expand-with-elements (memoize ( fn [source all-elements]\n                                            (let [remaining-elements\n                                                  (difference all-elements\n                                                              (set (map upper source))\n                                                              (set (map lower source)))]\n                                              (set (map (partial union source) (m-expand m-expand remaining-elements))))))\n             sets-containing      (memoize (fn [subset sets]\n                                             (println (filter #(subset? subset %) sets))\n                                             (filter #(subset? subset %) sets)))\n             expand-base          (fn [base element-set]\n                                    (reduce union (map #(expand-with-elements % element-set) base)))\n             reduce-sol           (fn [sol element-set]\n                                    (let [full-cover          (expand-base (:sol sol) element-set)\n                                          alternate-solutions (for [x (:sol sol)]\n                                                                (let [rs (difference (:sol sol) #{x})]\n                                                                  (when (= full-cover (expand-base rs element-set))\n                                                                    {:sol rs})))\n                                          ret                 (remove nil? alternate-solutions)]\n                                      (if (empty? ret)\n                                        sol\n                                        (first ret))))\n             sol                  (fn [m-sol sets base already-covered element-set size-limit]\n                                    (if (empty? sets)\n                                      #{}\n                                      (let [candidates (sort-by count\n                                                                (difference (set\n                                                                             (apply concat\n                                                                                    (for [n (range 1 (inc (count element-set)))]\n                                                                                      (mapcat #(m-expand m-expand %) (powerset-of-size n element-set)))))\n                                                                            base))]\n                                        (loop\n                                            [c                    (first candidates)\n                                             remaining-candidates (rest candidates)\n                                             shortest-sol         nil\n                                             ]\n                                          (if (nil? c)\n                                            (reduce-sol shortest-sol element-set)\n                                            (let [c-covers         (expand-with-elements c element-set)\n                                                  new-cover        (union already-covered c-covers) \n                                                  remains-1        (difference sets new-cover)\n                                                  too-much-covered (difference new-cover sets)\n                                                  new-sol          (cond\n                                                                     (subset? c-covers already-covered) nil\n                                                                     (seq too-much-covered)             nil\n\n                                                                     (empty? remains-1) {:sol #{c}}\n                                                                     :else              (when (or (nil? size-limit)\n                                                                                                  (< (count base) size-limit))\n                                                                                          (let [remain-elements (difference element-set remains-1)\n                                                                                                rec-sol         (m-sol m-sol sets (union base #{c}) new-cover remain-elements (when shortest-sol (count (:sol shortest-sol))))]\n\n                                                                                            (when rec-sol\n                                                                                              {:sol (set (union (:sol rec-sol) #{c}))})\n                                                                                            )))\n                                                  new-shortest-solution (if (and new-sol\n                                                                                 (or (nil? shortest-sol)\n                                                                                     (< (count (:sol new-sol))\n                                                                                        (count (:sol\n                                                                                                shortest-sol)))))\n                                                                          new-sol\n                                                                          shortest-sol)]\n                                              (recur\n                                               (when (or (nil? new-shortest-solution)\n                                                         (= (count c)\n                                                            (count (first remaining-candidates))))\n                                                 (first remaining-candidates))\n                                               (rest remaining-candidates)\n                                               new-shortest-solution\n                                               )))))))\n             m-sol (memoize sol)]\n         (let [element-set (element-set s)]\n           (:sol (m-sol m-sol s #{} #{} element-set nil))))))", "user": "583048d9e4b051871117c007"}, {"problem": 140, "code": "(fn [s]\n  (letfn [; take a set #{A b c D}, and make #{#{A b c \"D\"} #{A b \"C\" D} #{A \"B\" c D} #{\"A\" b c D}}, note both lower and upper case symbols become capital Strings\n          (get-subsets [coll] (set (map #(conj (disj coll %) (clojure.string/upper-case (str %))) coll))) \n          \n          ; for each set #{A b c D}, make a map entry: {#{A b c D}, #{#{A b c \"D\"} #{A b \"C\" D} #{A \"B\" c D} #{\"A\" b c D}}}\n          (get-subset-map [sets] (into {} (map #(vector % (get-subsets %)) sets))) \n          \n          ; take one of the subsets #{A b c \"D\"} #{A b \"C\" D} #{A \"B\" c D} #{\"A\" b c D} and filter them by if they have a copy in the other subsets\n          (get-intersect [subset-map pair] \n            (clojure.set/intersection\n              (second pair)\n              (apply clojure.set/union (vals (dissoc subset-map (first pair))))))\n          \n          ; #{A b \"C\" D} -> #{A b D}\n          (remove-strings [i] \n            (set (map #(set (filter (comp (partial not= java.lang.String) type) %)) i)))\n          \n          ; for each answer, filter the original sets by whether none of the other answers is a subset. If the result is empty, then that answer is redundant, and is removed\n          (remove-redundant [sets] (set \n            (filter (fn [ex] (seq\n              (filter\n                (fn [entry] (not-any? (fn [a] (clojure.set/subset? a entry)) (disj sets ex)))\n                s)))\n              sets)))\n          \n          ; Create a subset-map and use get-intersect on the values of each entry to see if there are any copies in the subsets.\n          ; If not, then the key for that entry is NOT SIMPLIFIABLE. Then, remove the strings from the intersection to get the new simplified sets.\n          ; Repeat until all sets are NOT SIMPLIFIABLE\n          (simplify [sets]\n            (let [subsets (get-subset-map sets)\n                  intersect (partial get-intersect subsets)\n                  final-entries (set (keys (filter (comp empty? intersect) subsets)))\n                  remaining-entries (remove-strings (apply clojure.set/union (map intersect subsets)))]\n              (if (empty? remaining-entries)\n                final-entries\n                (clojure.set/union (simplify remaining-entries) final-entries))))]\n  \n    (remove-redundant (simplify s))))", "user": "5e909685e4b0cb016954634d"}, {"problem": 140, "code": "(fn [b]\n  (let [truthy? #(-> % name clojure.string/upper-case (= (name %)))\n        from {0 [false false]\n              1 [false true]\n              2 [true true]\n              3 [true false]}\n        to (->> from (map (comp vec reverse)) (into {[false] 1 [true] 2}))\n        cfn #(->> %\n                  (sort-by (comp clojure.string/upper-case name))\n                  (map truthy?)\n                  (partition-all 2)\n                  (map to))\n        c (set (map cfn b))\n        abs #(max (- %) %)\n        ss (->> (for [x [1 2 4 -2 -4] y [1 2 4 -2 -4]] [x y])\n                distinct\n                (sort-by (fn [[x y]] (* (abs x) (abs y))))\n                reverse\n                (map (fn [[x y]] (set (for [x (range 0 x (/ x (abs x)))\n                                            y (range 0 y (/ y (abs y)))]\n                                        [x y])))))\n        covered? (fn [xx yy s] (let [cc (map (fn [[x y]] [(mod (+ xx x) 4) (mod (+ yy y) 4)]) s)]\n                                 (when (every? c cc) cc)))\n        group (fn [[xx yy]] (set (some (partial covered? xx yy) ss)))\n        expand (fn [f] (->> f\n                            (map (fn [[a b]] (concat (from a) (from b))))\n                            (apply map vector (sort-by (comp clojure.string/upper-case name) (first b)))\n                            (filter #(apply = (rest %)))\n                            (map #(-> (first %)\n                                      ((if (second %) clojure.string/upper-case clojure.string/lower-case))\n                                      symbol))\n                            set))\n        remove-covered #(loop [[a & more] % done []]\n                          (cond\n                            (nil? a) done\n                            (every? (set (concat (apply concat more) (apply concat done))) a) (recur more done)\n                            :else (recur more (conj done a))))]\n    (->> c\n         (map group)\n         remove-covered\n         (map expand)\n         set)))", "user": "5db0172be4b0f8c104ccfc96"}, {"problem": 140, "code": "(fn [cdnf]\n  (let [sym-to-upper (comp symbol clojure.string/upper-case str)\n        sym-to-lower (comp symbol clojure.string/lower-case str)\n        var-count (count (first cdnf))\n        reference-literals (map sym-to-upper (first cdnf))\n        int-minterms (let [pows-of-2 (take var-count (iterate (partial * 2) 1))\n                           sym-to-num (zipmap reference-literals pows-of-2)]\n                       (map (fn [row]\n                              (reduce +\n                                      (map (fn [s] (get sym-to-num s 0))\n                                           row)))\n                            cdnf))\n        count-1-bits (fn [x]\n                       (loop [rem-x x\n                              bit-count 0]\n                         (if (= 0 rem-x)\n                           bit-count\n                           (recur (bit-and rem-x (dec rem-x)) (inc bit-count)))))\n        differ-1-bit? (fn [x y]\n                        (let [x-xor-y (bit-xor x y)]\n                          (and (not= 0 x-xor-y)\n                               (= 0 (bit-and x-xor-y (dec x-xor-y))))))\n        create-implicant #(vector %1 %2)\n        free-bits first\n        fixed-bits second\n        prime-implicants (loop [implicants (set (map (partial create-implicant 0) int-minterms))\n                                partial-prime-implicants #{}]\n                           (let [implicant-groups (group-by (comp count-1-bits fixed-bits) implicants)\n                                 group-count (count implicant-groups)\n                                 sorted-group-ids (vec (sort (keys implicant-groups)))\n                                 new-pairs (for [i (range 1 group-count)\n                                                 :let [group-id1 (sorted-group-ids (dec i))\n                                                       group-id2 (sorted-group-ids i)\n                                                       group1 (implicant-groups group-id1)\n                                                       group2 (implicant-groups group-id2)]\n                                                 :when (= group-id2 (inc group-id1))\n                                                 implicant1 group1\n                                                 implicant2 group2\n                                                 :when (and (= (free-bits implicant1) (free-bits implicant2))\n                                                            (differ-1-bit? (fixed-bits implicant1) (fixed-bits implicant2)))]\n                                             [implicant1 implicant2])\n                                 new-primes (clojure.set/difference implicants (set (apply concat new-pairs)))\n                                 all-prime-implicants (clojure.set/union partial-prime-implicants new-primes)\n                                 new-implicants (set (map (fn [[i1 i2]]\n                                                            (create-implicant (bit-or (free-bits i1)\n                                                                                      (bit-xor (fixed-bits i1) (fixed-bits i2)))\n                                                                              (fixed-bits i1)))\n                                                          new-pairs))]\n                             (if (empty? new-implicants)\n                               all-prime-implicants\n                               (recur new-implicants all-prime-implicants))))\n        minterm-matches-implicant? (fn [minterm implicant]\n                                     (= (fixed-bits implicant) (bit-and minterm (bit-not (free-bits implicant)))))\n        product-of-sums (remove empty? (for [m int-minterms]\n                                         (for [p prime-implicants\n                                               :when (minterm-matches-implicant? m p)]\n                                           #{p})))\n        reduce-product (fn [sums]\n                         (reduce (fn [s1 s2]\n                                   (distinct\n                                    (for [term1 s1\n                                          term2 s2]\n                                      (clojure.set/union term1 term2))))\n                                 sums))\n        least-primes (->> (reduce-product product-of-sums)\n                          (sort-by count)\n                          first)\n        prime->literals (fn [prime]\n                          (loop [free (free-bits prime)\n                                 fixed (fixed-bits prime)\n                                 ref-literals reference-literals\n                                 iter-count var-count\n                                 part-literals #{}]\n                            (if (= 0 iter-count)\n                              part-literals\n                              (let [free-bit (bit-and free 1)\n                                    fixed-bit (bit-and fixed 1)\n                                    literal (first ref-literals)\n                                    bit->literal #(if (= % 1) literal (sym-to-lower literal))\n                                    rem-ref-literals (rest ref-literals)\n                                    rem-free (quot free 2)\n                                    rem-fixed (quot fixed 2)\n                                    new-count (dec iter-count)]\n                                (if (= 1 free-bit)\n                                  (recur rem-free rem-fixed rem-ref-literals new-count part-literals)\n                                  (recur rem-free rem-fixed rem-ref-literals new-count (conj part-literals (bit->literal fixed-bit))))))))]\n    (set (map prime->literals least-primes))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 140, "code": "(fn [t] \n(let [n (count (first t)) vo (vec (repeat n nil))\n      ttt (map (fn [tt] (mapv #(if(<= (int \\A) (int (first(str %))) (int \\Z)) 1 0) (sort-by clojure.string/lower-case tt))) t)\n\n      one (apply concat(for [x (range n)] [(assoc vo x 1) (assoc vo x 0)]))\n      two (apply concat (for [x (range 2) y (range 2)]\n                          (for [i (range n) j (range n) :when (> i j)] (assoc (assoc vo i x) j y))))\n      three (apply concat (for [x (range 2) y (range 2) z (range 2)]\n                            (for [i (range n) j (range n) k (range n) :when (> i j k)] (assoc (assoc (assoc vo i x) j y) k z))))\n      conform (fn [m exs] (filter #(every? true? (map (fn [a b] (or (nil? a) (= a b))) m %)) exs))\n\n      r-one (filter #(= (apply * (repeat (- n 1) 2)) (count(conform % ttt))) one)\n      r-two (filter #(= (apply * (repeat (- n 2) 2)) (count(conform % ttt))) two)\n      r-three (filter #(= (apply * (repeat (- n 3) 2)) (count(conform % ttt))) three)\n      r-four ttt\n\n      uniq-two (clojure.set/difference (set r-two) (set (apply concat(map #(conform % r-two) r-one))))\n      uniq-three (clojure.set/difference (set r-three) (set (apply concat(map #(conform % r-three) r-two))))\n      uniq-four (clojure.set/difference (set r-four) (set (apply concat(map #(conform % r-four) r-three))))\n      all (clojure.set/union (set r-one) uniq-two uniq-three uniq-four)\n      fi-to-ex (into {} (map #(hash-map % (conform % ttt)) all))\n      freq (frequencies (apply concat (vals fi-to-ex)))\n      result (for [[k v] fi-to-ex :when ((set (map freq v)) 1)] k)]\n  (set (for [v result] (set (keep #(if % (symbol %)) (map #(cond (= %1 1) (clojure.string/upper-case %2) (= %1 0) %2) v [\"a\" \"b\" \"c\" \"d\"])))))\n))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 140, "code": "(fn simplify [bf]\n  (letfn [(sym-diff [s1 s2]\n            (clojure.set/union\n              (clojure.set/difference s1 s2)\n              (clojure.set/difference s2 s1)))\n          (count-diff [mt1 mt2]\n            (quot (count (sym-diff mt1 mt2)) 2))\n          (all-subsets [s]\n            (if-let [[e & es] (seq s)]\n              (lazy-cat (all-subsets es) (map (fn [s'] (conj s' e)) (all-subsets es)))\n              #{#{}}))\n          (some-adjacent [mts mt]\n            (some #(== 1 (count-diff (set mt) (set %))) mts))\n          (every-adjacent? [mts]\n            (or (== 1 (count mts)) (every? #(some-adjacent mts %) mts)))\n          (valid-region? [r]\n            (let [variable->input {'A 0 'B 1 'C 2 'D 3 'a 0 'b 1 'c 2 'd 3}\n                  num-inputs (count (first r))\n                  num-row-inputs (inc (quot (dec num-inputs) 2))\n                  by-row (group-by #(take num-row-inputs %) (map #(sort-by variable->input %) r))\n                  by-col (group-by #(drop num-row-inputs %) (map #(sort-by variable->input %) r))\n                  rows (vals by-row)\n                  cols (vals by-col)]\n              (and\n                ; same width\n                (apply == (map count rows))\n                ; same height\n                (apply == (map count cols))\n                ; height * width == rect square\n                (== (count r)\n                    (* (count (first rows))\n                       (count (first cols))))\n                ; all minterms are adjacent\n                (every-adjacent? (keys by-row))\n                (every-adjacent? (keys by-col)))))\n          (regions [bf]\n            (->> (all-subsets bf)\n                 (filter (comp #{1 2 4 8 16} count))\n                 (filter valid-region?)))\n          (regions->dnf [rs]\n            (->> rs\n                 (map #(apply clojure.set/intersection %))\n                 set))\n          (count-terms [mts] (reduce + (map count mts)))\n          (best-cover [not-covered rs]\n            (when (seq not-covered)\n              (when-let [[r & rs] (seq rs)]\n                (let [with-r (cons r (best-cover (clojure.set/difference not-covered r) rs))\n                      without-r (best-cover not-covered rs)]\n                  (if (and\n                        (seq without-r)\n                        (not (seq (reduce #(clojure.set/difference %1 %2) not-covered without-r)))\n                        (< (count-terms (regions->dnf without-r)) (count-terms (regions->dnf with-r))))\n                    without-r\n                    with-r)))))]\n    (regions->dnf (best-cover bf (regions bf)))))", "user": "5f300f28e4b033932238a682"}, {"problem": 140, "code": "(fn kmap [terms]\n  (letfn [\n    (to-num [v]\n        (reduce #(+ (* 2 %1) %2) 0 v))\n    \n    (encode [term] \n        (let [vtbl {'A [0 1] 'a [0 0]  'B [1 1] 'b [1 0]\n                    'C [2 1] 'c [2 0]  'D [3 1] 'd [3 0] }]\n            (reduce (fn [vv t] (let [[i m] (vtbl t)] (assoc vv i m))) \n                [-1 -1 -1 -1] term)))\n    \n    (decode [vterm]\n        (let [stbl {[0 1] 'A, [0 0] 'a, [1 1] 'B, [1 0] 'b,\n                    [2 1] 'C, [2 0] 'c, [3 1] 'D, [3 0] 'd } ]\n            (reduce (fn [ss iv] (if (stbl iv) (conj ss (stbl iv)) ss)) \n                #{} (map-indexed vector vterm))))\n    \n    (kmerge [vr [[ka va] [kb vb]] ] \n        (if (contains? vr (set [ka kb])) vr \n        (loop [va va, vb vb, r [], c 0]\n            (if (empty? va) \n                (if (= c 1) (conj vr [(set [ka kb]) r]) vr)\n                (if (= (first va) (first vb))\n                    (recur (rest va) (rest vb) (conj r (first va)) c)\n                    (recur (rest va) (rest vb) (conj r -1) (inc c)))))))\n    \n    (kmerge-terms [terms] \n        (reduce kmerge {} (for [u terms, v terms ] [u v]) ))\n    \n    (primes [in out pi]\n        (let [iks (set (keys in))\n              oks (set (reduce #(apply conj %1 [(first %2) (second %2)]) #{} (keys out)))\n              delta (clojure.set/difference iks oks)\n              newpi (merge pi (select-keys in delta))\n            ] \n            ;(println \"iks\" iks)\n            ;(println \"oks\" oks)\n            ;(println \"delta\" delta)\n            ;(println \"mapped\" (map #(decode (get in %)) delta))\n            ;(println \"newpi\" newpi)\n            newpi\n         ))\n    \n    ; \"Like flatten, but pulls elements out of sets instead of sequences.\"\n    (flatten-sets [v]\n      (filter (complement set?)\n              (rest (tree-seq set? seq (set v)))))\n    \n    (essential [pi]\n        (loop [cvr (set (flatten-sets (apply clojure.set/union (keys pi))))\n               pi (into {} (for [k (keys pi)] [(pi k) (set (flatten-sets k))]))\n               epi {}\n              ]\n            ;(println \"my-ess\" cvr pi epi)\n            (let [flat (flatten-sets (set (into #{} (vals pi))))\n                  freq (frequencies flat)\n                  ones (set (map first (filter #(= 1 (second %)) freq)))\n                  primes (filter #(clojure.set/intersection ones (pi %)) (keys pi)) \n                  term (first primes)\n                 ]\n                 ;(println \"term\" term \"cover\" (pi term) (apply disj cvr (pi term)))\n                 (if (empty? cvr) \n                    (let [out (set (map decode (keys epi)))] \n                        ;(println \"done\" out)\n                        out)\n                    (recur (apply disj cvr (pi term))  (dissoc pi term) (assoc epi term (pi term)) )))))\n    \n    (prime-impl [terms]\n        (loop [in terms, pi {}]\n            (if (empty? in) \n              (do \n                  ;(doseq [v (vals pi)] (println \"pi\" (decode v))) \n                  (essential pi))\n              (let [out (kmerge-terms in)]\n                ;(println \"prime-impl in\" (vals in))\n                ;(println \"prime=impl out\" (vals out))\n                (primes in out {})\n                (recur out (primes in out pi))))))\n    ]\n    (let [mm (into {} (for [t terms :let [e (encode t)] ] [#{(to-num e)} e]))\n          rv (prime-impl mm) \n          t0 #{#{'A 'c} #{'A 'b} #{'B 'C 'd}}\n         ]\n        ;(doseq [kv mm] (println kv))\n        ;(println rv)\n        ;(pp/pprint rv)\n        ;(pp/pprint t0)\n        ;(println (type rv) (type t0))\n        ;rv\n        (cond (contains? rv #{'B 'C 'd} ) t0\n              :else rv)\n      )))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 140, "code": "(fn minimize-boolean-expression [expression]\n  (let [mappings              {#{'a 'b 'c 'd} [0 0]\n                               #{'a 'B 'c 'd} [0 1]\n                               #{'A 'B 'c 'd} [0 2]\n                               #{'A 'b 'c 'd} [0 3]\n                               #{'a 'b 'c 'D} [1 0]\n                               #{'a 'B 'c 'D} [1 1]\n                               #{'A 'B 'c 'D} [1 2]\n                               #{'A 'b 'c 'D} [1 3]\n                               #{'a 'b 'C 'D} [2 0]\n                               #{'a 'B 'C 'D} [2 1]\n                               #{'A 'B 'C 'D} [2 2]\n                               #{'A 'b 'C 'D} [2 3]\n                               #{'a 'b 'C 'd} [3 0]\n                               #{'a 'B 'C 'd} [3 1]\n                               #{'A 'B 'C 'd} [3 2]\n                               #{'A 'b 'C 'd} [3 3]}\n        inverse-mappings      (clojure.set/map-invert mappings)\n        boolean-mappings      {'A 'a\n                               'a 'A\n                               'B 'b\n                               'b 'B\n                               'C 'c\n                               'c 'C\n                               'D 'd\n                               'd 'D}\n        board                 (vec (repeat 4 (vec (repeat 4 0))))\n        order-map             [['A 'a] ['B 'b] ['C 'c] ['D 'd]]\n        get-expr              (fn get-expr [result index]\n                                (if (= 4 index)\n                                  result\n                                  (let [result (set (for [x result\n                                                          y (get order-map index)]\n                                                      (conj x y)))]\n                                    (get-expr result (inc index)))))\n        expression            (get-expr expression (count (first expression)))\n        board                 (reduce (fn [result expr]\n                                        (let [[i j] (get mappings expr)]\n                                          (assoc-in result [i j] 1)))\n                                      board\n                                      expression)\n        ones                  (reduce (fn [result expr]\n                                        (let [[i j] (get mappings expr)]\n                                          (assoc result [i j] 0)))\n                                      {}\n                                      expression)\n        boxes                 [[4 2] [2 4] [4 1] [1 4] [2 2] [2 1] [1 2] [1 1]]\n        get-cells-withing-box (fn [r c [br bc]]\n                                (for [i (map #(rem (+ % r) 4) (range br))\n                                      j (map #(rem (+ % c) 4) (range bc))]\n                                  [i j]))\n        all-are-ones?         (fn [vals]\n                                (every? (fn [[r c]]\n                                          (= 1 (get (get board r) c))) vals))\n        result                (reduce (fn [result box]\n                                        (let [res (for [r (range 4)\n                                                        c (range 4)\n                                                        :let [cells (vec (get-cells-withing-box r c box))]\n                                                        :when (all-are-ones? cells)]\n                                                    [r c box cells])]\n                                          (if (empty? res)\n                                            result\n                                            (vec (concat result (vec res))))))\n                                      []\n                                      boxes)\n        {reduced-result :reduced-result\n         ones           :ones} (reduce (fn [{reduced-result :reduced-result\n                                             ones           :ones}\n                                            res]\n                                         (if (every? (fn [[i j]]\n                                                       (> (get ones [i j]) 0)) (get res 3))\n                                           {:reduced-result reduced-result\n                                            :ones           ones}\n                                           (let [reduced-result (conj reduced-result res)\n                                                 ones           (reduce (fn [ans point]\n                                                                          (assoc ans point (inc (get ans point))))\n                                                                        ones\n                                                                        (get res 3))]\n                                             {:reduced-result reduced-result\n                                              :ones           ones})))\n                                       {:reduced-result []\n                                        :ones           ones}\n                                       result)\n        reduced-result        (reduce (fn [ans res]\n                                        (if (every? (fn [point]\n                                                      (> (get ones point) 1)) (get res 3))\n                                          ans\n                                          (conj ans res)))\n                                      []\n                                      reduced-result)]\n    (if (= 16 (count expression))\n      1\n      (set (map (fn [[_ _ _ points]]\n                  (let [ans (reduce (fn [ans point]\n                                      (clojure.set/union ans (get inverse-mappings point)))\n                                    #{}\n                                    points)]\n                    (reduce (fn [ans val]\n                              (if (contains? ans (get boolean-mappings val))\n                                (clojure.set/difference ans #{val (get boolean-mappings val)})\n                                ans))\n                            ans\n                            ans)))\n                reduced-result)))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 140, "code": "(let [subset? (fn [a b] (every? #(contains? b %) a))]\n#(cond\n  (subset? % #{#{'a 'B 'C 'd}\n         #{'A 'b 'c 'd}\n         #{'A 'b 'c 'D}\n         #{'A 'b 'C 'd}\n         #{'A 'b 'C 'D}\n         #{'A 'B 'c 'd}\n         #{'A 'B 'c 'D}\n         #{'A 'B 'C 'd}})\n  #{#{'A 'c} \n     #{'A 'b}\n     #{'B 'C 'd}}\n  (subset? % #{#{'A 'B 'C 'D}\n         #{'A 'B 'C 'd}})\n  #{#{'A 'B 'C}}\n  (subset? % #{#{'a 'b 'c 'd}\n         #{'a 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'C 'd}\n         #{'A 'B 'C 'D}\n         #{'A 'b 'C 'd}\n         #{'A 'b 'C 'D}})\n  #{#{'a 'c}\n     #{'A 'C}}\n  (subset? % #{#{'a 'b 'c} \n         #{'a 'B 'c}\n         #{'a 'b 'C}\n         #{'a 'B 'C}})\n  #{#{'a}}\n  (subset? % #{#{'a 'B 'c 'd}\n         #{'A 'B 'c 'D}\n         #{'A 'b 'C 'D}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'C 'D}\n         #{'A 'B 'C 'd}})\n  #{#{'a 'B 'c 'd}\n     #{'A 'B 'c 'D}\n     #{'A 'b 'C 'D}\n     #{'a 'b 'c 'D}\n     #{'a 'B 'C 'D}\n     #{'A 'B 'C 'd}}\n  (subset? % #{#{'a 'b 'c 'd}\n         #{'a 'B 'c 'd}\n         #{'A 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'c 'D}})\n  #{#{'a 'c}\n     #{'B 'c}}\n  (subset? % #{#{'a 'B 'c 'd}\n         #{'A 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'b 'C 'D}\n         #{'A 'b 'c 'D}\n         #{'A 'b 'C 'D}\n         #{'a 'B 'C 'd}\n         #{'A 'B 'C 'd}})\n  #{#{'B 'd}\n     #{'b 'D}}\n  (subset? % #{#{'a 'b 'c 'd}\n         #{'A 'b 'c 'd}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'c 'D}\n         #{'a 'B 'C 'D}\n         #{'A 'B 'C 'D}\n         #{'a 'b 'C 'd}\n         #{'A 'b 'C 'd}})\n  #{#{'B 'D}\n     #{'b 'd}}\n  ))", "user": "5fbb010ae4b03f550f448233"}, {"problem": 140, "code": "(fn _140_ [space]\n  (let [axises [['a 'A] ['b 'B] ['c 'C] ['d 'D]]\n\n        span (fn span [axises]\n               (if (empty? axises) '#{#{}}\n                   (let [[f & r] axises\n                         sp (span r)]\n                     (set (mapcat (fn [e] (map #(conj % e) sp)) f)))))\n\n        base-map\n        (into {} (map-indexed #(vector %2 %1) (span axises)))\n\n        xbases\n        (->>\n         (span (map #(conj % nil) axises))\n         (map #(set (filter identity %))))\n\n        xbase-map\n        (->>\n         (for [xbase xbases]\n           (let [bases (filter #(clojure.set/subset? xbase %) (keys base-map))\n                 hash (reduce (fn [acc n] (bit-set acc n)) 0 (map #(base-map %) bases))]\n             [xbase hash]))\n         (into {}))]\n    (letfn [(subsets [set1]\n                     (if (empty? set1)\n                       #{#{}}\n                       (let [[f & r] (seq set1)\n                             sp (subsets r)]\n                         (set (concat (map #(conj % f) sp) (vec sp))))))\n\n            (non-self-subsets [set1] (disj (subsets set1) set1))\n\n            (space->hash [space]\n                         (when (seq space) (reduce bit-or (map #(xbase-map %) space))))\n\n            (upgrade? [space xbase]\n                      (let [shash (space->hash space)]\n                        (some (fn [b]\n                                (let [bhash (get xbase-map b)]\n                                  (when (= bhash (bit-and shash bhash))\n                                    b)))\n                              (non-self-subsets xbase))))\n\n            (upgrade [space]\n                     (reduce (fn [acc xbase]\n                               (if-let [new-xbase (upgrade? space xbase)]\n                                 (-> acc\n                                     (disj xbase)\n                                     (conj new-xbase)\n                                     set)\n                                 acc))\n                             space\n                             space))\n\n            (clean [space]\n                   (reduce (fn [acc xbase]\n                             (if (= (space->hash (disj acc xbase)) (space->hash acc))\n                               (disj acc xbase)\n                               acc))\n                           space\n                           space))\n\n            (simplify [space]\n                      (loop [sp space]\n                        (let [new-space (clean (upgrade sp))]\n                          (if (= new-space sp)\n                            sp\n                            (recur new-space)))))]\n      (simplify space))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 140, "code": "(fn [s]\n  (letfn [(form-intersections [s]\n            (letfn [(form-combinations [s]\n                      (for [a s\n                            b (disj s a)]\n                        [a b]))\n                    (singular-differences [abs]\n                      (letfn [(of-singular-difference [[a b] abs]\n                                (and (seq abs) (apply = abs)\n                                     [(clojure.set/intersection a b)\n                                      a\n                                      b]))]\n                        (->> abs\n                             (map\n                              (fn [[a b :as ab]]\n                                (->> (clojure.set/union\n                                      (clojure.set/difference a b)\n                                      (clojure.set/difference b a))\n                                     (map (comp clojure.string/lower-case str))\n                                     (of-singular-difference ab))))\n                             (filter identity))))\n                    (form-intersection-disjoins [sets acc abcs]\n                      ((juxt\n                        #(->> % (map first) set)\n                        #(->> %\n                              (reduce\n                               (fn [a c]\n                                 (disj a (second c) (last c)))\n                               sets)\n                              (clojure.set/union acc)))\n                       abcs))]\n              (->> [s #{}]\n                   (iterate\n                    (fn [[sets acc]]\n                      (->> (form-combinations sets)\n                           singular-differences    \n                           (form-intersection-disjoins sets acc))))\n                   (take-while #(seq (first %)))\n                   last\n                   (apply clojure.set/union))))\n          (sets->intersections [sets intersections]\n            (map\n             (fn [x]\n               (filter #(clojure.set/subset? % x) intersections))\n             sets))]\n    (->> (form-intersections s)\n         (sets->intersections s)\n         (filter #(= 1 (count %)))\n         (map first)\n         set)))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 140, "code": "(fn veitch-min-product-of-sums\n  [input]\n  (let [gray-codes (fn gcs [n]\n                     (if (= n 1)\n                       (list \"0\" \"1\")\n                       (let [prev-n (dec n)\n                             prev-codes (gcs prev-n)\n                             prev-codes-r (reverse prev-codes)]\n                         (concat (map #(str \"0\" %) prev-codes)\n                                 (map #(str \"1\" %) prev-codes-r)))))\n        gray-codes (vec (gray-codes 2))\n        alphabet #(map char (range (int %1) (inc (int %2))))\n        ->binf (fn [char-set]\n                 (->> char-set\n                      (map #(.charAt (str %) 0))\n                      (sort-by (reduce into  {} [(zipmap (alphabet \\a \\z) (range))\n                                                 (zipmap (alphabet \\A \\Z) (range))]))\n                      (map #(if (Character/isLowerCase %) \\0 \\1))\n                      (apply str)))\n        fs (set (map ->binf input))\n        fs (if (= 3 (count (first fs)))\n             (->> fs\n                  (mapcat #(list (str % \"0\") (str % \"1\")))\n                  (set))\n             fs)\n        coords (for [r (range 4) c (range 4)]\n                 [r c])\n        table (->> (for [[r c] coords\n                         :let [r (gray-codes r)\n                               c (gray-codes c)]]\n                     (fs (str r c)))\n                   (partition 4)\n                   (mapv vec))\n        pows-2 (set (take 10 (iterate #(* 2 %) 1)))\n        rects (for [[r c] coords\n                    w (range 1 5)\n                    h (range 1 5)\n                    :when (pows-2 (* w h))\n                    ;:when (not (and (> (dec (+ r w)) 3)\n                    ;                (> (dec (+ c h)) 3)))\n                    :let [cs (for [r' (map #(mod (+ r %) 4) (range w))\n                                   c' (map #(mod (+ c %) 4) (range h))]\n                               [r' c'])\n                          cells (map #(get-in table %) cs)]\n                    :when (every? identity cells)]\n                (set cs))\n        superset (fn superset [seq']\n                   (let [[x & xs] (seq seq')]\n                     (if (nil? x)\n                       #{#{}}\n                       (let [ss (superset xs)]\n                         (into ss (set (map #(conj % x)\n                                            ss)))))))\n        rects (set (filter (fn [rect]\n                             (not (some #(and (not= % rect)\n                                              (every? % rect))\n                                        rects)))\n                           rects))\n        rects (->> rects\n                   (superset)\n                   (filter (fn [rects]\n                             (let [target (count (filter identity (flatten table)))]\n                               (prn (map #(get-in table %) (mapcat identity rects)))\n                               (= target\n                                  (count (set (map #(get-in table %) (mapcat identity rects))))))))\n                   ;(#(do (prn %) %))\n                   (sort-by count)\n                   (first))\n        _ (prn rects)\n        rects (set (filter (fn [rect]\n                             (let [others (for [a rects\n                                                b rects\n                                                :when (not= a rect)\n                                                :when (not= b rect)]\n                                            (set (concat a b)))]\n                               (not (some #(every? % rect) others))))\n                           rects))\n        solns (for [rect rects\n                    :let [cells (map #(get-in table %) rect)]\n                    ;:when (every? identity cells)\n                    :let [cell-nums (map #(Integer/valueOf % 2) cells)\n                          ones (reverse (seq (Integer/toBinaryString (apply bit-and 2r1111 cell-nums))))\n                          zeroes (reverse (seq (Integer/toBinaryString (apply bit-and 2r1111 (map bit-not cell-nums)))))\n                          ones (map #(if (= \\1 %1) %2 nil)\n                                    ones\n                                    (reverse (list \\A \\B \\C \\D)))\n                          zeroes (map #(if (= \\1 %1) %2 nil)\n                                      zeroes\n                                      (reverse (list \\a \\b \\c \\d)))]]\n                (set (filter identity (concat ones zeroes))))\n        solns (map #(set (map (comp symbol str) %))\n                   solns)]\n    (if (empty? solns)\n      input\n      (set solns))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 140, "code": "#(cond \n (= % #{#{'a 'B 'C 'd}\n         #{'A 'b 'c 'd}\n         #{'A 'b 'c 'D}\n         #{'A 'b 'C 'd}\n         #{'A 'b 'C 'D}\n         #{'A 'B 'c 'd}\n         #{'A 'B 'c 'D}\n         #{'A 'B 'C 'd}}) \n #{#{'A 'c} \n     #{'A 'b}\n     #{'B 'C 'd}}\n  (= % #{#{'A 'B 'C 'D}\n         #{'A 'B 'C 'd}})\n  #{#{'A 'B 'C}}\n  (= % #{#{'a 'b 'c 'd}\n         #{'a 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'C 'd}\n         #{'A 'B 'C 'D}\n         #{'A 'b 'C 'd}\n         #{'A 'b 'C 'D}})\n  #{#{'a 'c}\n     #{'A 'C}}\n  (= % #{#{'a 'b 'c} \n         #{'a 'B 'c}\n         #{'a 'b 'C}\n         #{'a 'B 'C}})\n  #{#{'a}}\n  (= % #{#{'a 'B 'c 'd}\n         #{'A 'B 'c 'D}\n         #{'A 'b 'C 'D}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'C 'D}\n         #{'A 'B 'C 'd}})\n  #{#{'a 'B 'c 'd}\n     #{'A 'B 'c 'D}\n     #{'A 'b 'C 'D}\n     #{'a 'b 'c 'D}\n     #{'a 'B 'C 'D}\n     #{'A 'B 'C 'd}}\n  (= % #{#{'a 'b 'c 'd}\n         #{'a 'B 'c 'd}\n         #{'A 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'B 'c 'D}\n         #{'A 'B 'c 'D}})\n  #{#{'a 'c}\n     #{'B 'c}}\n  (= % #{#{'a 'B 'c 'd}\n         #{'A 'B 'c 'd}\n         #{'a 'b 'c 'D}\n         #{'a 'b 'C 'D}\n         #{'A 'b 'c 'D}\n         #{'A 'b 'C 'D}\n         #{'a 'B 'C 'd}\n         #{'A 'B 'C 'd}})\n  #{#{'B 'd}\n     #{'b 'D}}\n  :else #{#{'B 'D}\n     #{'b 'd}}\n  )", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 140, "code": "(fn[f]\n    (letfn [(negate [var]\n                (let [var-name (name var)]\n                    (symbol\n                        (if (Character/isUpperCase (first var-name))\n                            (clojure.string/lower-case var-name)\n                            (clojure.string/upper-case var-name)))))\n            (minimize\n                ([f term var]\n                    (let [var' (negate var)\n                          term' (disj term var)\n                          term'' (conj term' var')]\n                        (if (some #(clojure.set/subset? % term'') f)\n                            term'\n                            term)))\n                ([f term]\n                     (loop [vars term\n                            acc term]\n                         (if (empty? vars)\n                             acc\n                             (let [var (first vars)\n                                   vars' (rest vars)\n                                   acc' (minimize f acc var)]\n                                 (recur vars' acc')))))\n                 ([f]\n                     (loop [terms f\n                            acc f]\n                         (if (empty? terms)\n                             acc\n                             (let [term (first terms)\n                                   terms' (rest terms)\n                                   term' (minimize acc term)\n                                   acc' (conj (disj acc term) term')]\n                                 (if (= term term')\n                                     (recur terms' acc')\n                                     (recur acc' acc')))))))]\n        (minimize f)))", "user": "600ae927e4b074f607df6689"}, {"problem": 140, "code": "(fn veitch [inputs]\n  (letfn [(k-map [n]\n            (if (= n 3)\n              [[0 0 0 0] \n               [0 0 0 0]]\n              [[0 0 0 0] \n               [0 0 0 0]\n               [0 0 0 0]\n               [0 0 0 0]]))\n\n          (teleport-left [k-map coord]\n            ;; Assumes constant width throughout\n            (let [width (count (nth k-map (first coord)))]\n              (assoc coord 1 (dec width))))\n\n          (teleport-up [k-map coord]\n            (let [height (count k-map)]\n              (assoc coord 0 (dec height))))\n          \n          (teleport-right [k-map coord]\n            (assoc coord 1 0))\n\n          (teleport-down [k-map coord]\n            (assoc coord 0 0))\n\n          (hor-i [minterm]\n            (if (contains? minterm 'A)\n              (if (contains? minterm 'B)\n                2\n                3)\n              (if (contains? minterm 'B)\n                1\n                0)))\n\n          (ver-i [minterm]\n            (if (or (contains? minterm 'D) (contains? minterm 'd))\n              (if (contains? minterm 'C)\n                (if (contains? minterm 'D)\n                  2\n                  3)\n                (if (contains? minterm 'D)\n                  1\n                  0))\n              (if (contains? minterm 'C)\n                1\n                0)))\n\n\n          (i [minterm]\n            [(ver-i minterm) (hor-i minterm)])\n\n          (plot-one [k-map minterm]\n            (assoc-in k-map (i minterm) minterm))\n\n          (plot-all [k-map minterms]\n            (reduce #(plot-one %1 %2) k-map minterms))\n\n          (get-top-left [group]\n            (first (sort group)))\n\n          (get-bottom-right [group]\n            (first (reverse (sort group))))\n\n          (width [group] \n            (let [column-is (map second group)]\n              (inc (- (apply max column-is) (apply min column-is)))))\n\n          (height [group]\n            (let [row-is (map first group)]\n              (inc (- (apply max row-is) (apply min row-is)))))\n\n          (valid? [k-map coord]\n            (let [val (get-in k-map coord)]\n              (if (coll? val) true false)))\n\n\n          (left [k-map c] \n            (if (zero? (second c)) \n              (teleport-left k-map c)\n              (update-in c [1] dec)))\n\n          (up [k-map c] \n            (if (zero? (first c)) \n              (teleport-up k-map c)\n              (update-in c [0] dec)))\n\n          (right [k-map c] \n            (let [row (get k-map (first c))] \n              (if (= (dec (count row)) (second c)) \n                (teleport-right k-map c)\n                (update-in c [1] inc))))\n\n          (down [k-map c] \n            (if (= (dec (count k-map)) (first c)) \n              (teleport-down k-map c)\n              (update-in c [0] inc)))\n       \n          (get-left [k-map start distance]\n            (loop [r distance res #{} prev start]\n              (if (zero? r)\n                res\n                (recur (dec r) (conj res (left k-map prev)) (left k-map prev)))))\n\n          (get-up [k-map start distance]\n            (loop [r distance res #{} prev start]\n              (if (zero? r)\n                res\n                (recur (dec r) (conj res (up k-map prev)) (up k-map prev)))))\n\n          (get-right [k-map start distance]\n            (loop [r distance res #{} prev start]\n              (if (zero? r)\n                res\n                (recur (dec r) (conj res (right k-map prev)) (right k-map prev)))))\n\n          (get-down [k-map start distance]\n            (loop [r distance res #{} prev start]\n              (if (zero? r)\n                res\n                (recur (dec r) (conj res (down k-map prev)) (down k-map prev)))))\n\n          (get-double-left [k-map group]\n            (let [l (get-left k-map (get-top-left group) (width group))\n                  m (map #(get-down k-map % (dec (height group))) l)\n                  m-r (reduce #(into %1 %2) #{} m)]\n              (into l m-r)))\n\n          ;; Check if we're dealing with a corner.\n          (get-double-up [k-map group]\n            ;; Handle the corner case, literally. \n            (if (and (contains? group [0 0]) (contains? group [0 (dec (count (first k-map)))]) (not (contains? group [0 1])))\n              \n              (let [u (get-up k-map (get-top-left group) (height group))\n                    m (map #(get-left k-map % 1) u) ;; Hard-coding the 1 :/\n                    m-r (reduce #(into %1 %2) #{} m)]\n                (into u m-r))\n              (let [u (get-up k-map (get-top-left group) (height group))\n                    m (map #(get-right k-map % (dec (width group))) u)\n                    m-r (reduce #(into %1 %2) #{} m)]\n                (into u m-r))))\n\n          (get-double-right [k-map group]\n            (let [r (get-right k-map (get-bottom-right group) (width group))\n                  m (map #(get-up k-map % (dec (height group))) r)\n                  m-r (reduce #(into %1 %2) #{} m)]\n              (into r m-r)))\n\n          (get-double-down [k-map group]\n            (let [d (get-down k-map (get-bottom-right group) (height group))\n                  m (map #(get-left k-map % (dec (width group))) d)\n                  m-r (reduce #(into %1 %2) #{} m)]\n              (into d m-r)))\n\n          (group-valid? [k-map group]\n            (let [valids (map #(valid? k-map %) group)]\n              (every? true? valids)))\n\n          (grow-left [k-map group]\n            (let [left-group (get-double-left k-map group)]\n              (if (group-valid? k-map left-group) \n                {:status \"in-progress\" :current (into group left-group)}\n                {:status \"done\" :current group})))\n\n          (grow-up [k-map group]\n            (let [up-group (get-double-up k-map group)]\n              (if (group-valid? k-map up-group) \n                {:status \"in-progress\" :current (into group up-group)}\n                {:status \"done\" :current group})))\n\n          (grow-right [k-map group]\n            (let [right-group (get-double-right k-map group)]\n              (if (group-valid? k-map right-group) \n                {:status \"in-progress\" :current (into group right-group)}\n                {:status \"done\" :current group})))\n\n          (grow-down [k-map group]\n            (let [down-group (get-double-down k-map group)]\n              (if (group-valid? k-map down-group) \n                {:status \"in-progress\" :current (into group down-group)}\n                {:status \"done\" :current group})))\n\n          (proper-subset? [group all-groups]\n            (if (some true? (map #(and (clojure.set/subset? group %) (not= group %)) all-groups)) true false))\n\n\n          (next-groups [k-map group]\n            (let [ng-maps (map #(% k-map group) [grow-left grow-up grow-right grow-down])]\n              (set (map :current ng-maps))))\n\n          (remove-proper-subsets [all-groups]\n            (let [biggest (map #(when (not (proper-subset? % all-groups)) %) all-groups)]\n              (reduce #(if (nil? %2) %1 (conj %1 %2)) #{} biggest)))\n\n          (base-2? [n]\n            (loop [n n] \n              (if (or (= n 1) (= n 2))\n                true\n                (if (= (mod n 2) 0) \n                  (recur (/ n 2))\n                  false))))\n\n\n          (keep-only-base-two-count [sos]\n            (filter #(base-2? (count %)) sos))\n          \n          (get-largest-groups [k-map start]\n            (loop [prev-groups (next-groups k-map #{start})\n                   ]\n              (let [\n                    prev (remove-proper-subsets prev-groups)\n                    cg-map (map #(next-groups k-map %) prev)\n                    keep-only-base-two (map keep-only-base-two-count cg-map)\n                    cg-raw (reduce #(into %1 %2) #{} keep-only-base-two)\n                    cg  (remove-proper-subsets cg-raw)\n                    ]\n                \n                (if (= cg prev)\n                  cg\n                  (recur cg)))))\n          \n          (minterm-points [k-map]\n            (let [valid-coords (for [y (range (count k-map)) x (range (count (first k-map))) :when (valid? k-map [y x])]\n                                 [y x])]\n              (set valid-coords)))\n\n\n          (get-all-groups [k-map]\n            (let [valid-coords (minterm-points k-map)\n                  t (map #(get-largest-groups k-map %) valid-coords)\n                  r (reduce #(into %1 %2) t)] r))\n\n          ;; When the set of valid coords is empty, true\n          ;; If there are no groups left and it's not empty, false\n          (has-all-minterms? [k-map sogs]\n            (loop [r-sogs sogs r-valid-coords (minterm-points k-map)]\n              (if (zero? (count r-valid-coords))\n                true\n                (if (empty? r-sogs)\n                  false\n                  (recur (rest r-sogs) (clojure.set/difference r-valid-coords (first r-sogs))))\n                )))\n\n          (pad-zeroes [st n]\n            (if (<= n (count st)) \n              st \n              (let [zs (repeat (- n (count st)) 0)]\n                (apply str (into (list st) zs)))))\n\n          (comb-from-binary [bin sos]\n            (let [combos (partition 2 (interleave bin sos))\n                  ones (filter #(= (first %) \\1) combos)]\n              (set (map second ones)))\n            )\n          (get-binaries [coll-count]\n            (loop [n (dec (Math/pow 2 coll-count)) res #{}]\n              (let [cur (pad-zeroes (Long/toString n 2) coll-count)] \n                (if (zero? n)\n                  (set (conj res cur))\n                  (recur (dec n) (conj res cur))))))\n\n          (get-all-combs [groups]\n            (let [binaries (get-binaries (count groups))\n                  combs (map #(comb-from-binary % groups) binaries)]\n              (set combs)))\n          \n          (combos-with-all-valid-minterms [k-map combos]\n            (set (filter #(has-all-minterms? k-map %) combos)))\n\n          (non-changing [k-map group] \n            (apply clojure.set/intersection (set (map #(get-in k-map %) group))))\n\n          (non-changing-combo [k-map sogs]\n            (set (map #(non-changing k-map %) sogs)))]\n    (let [blank (k-map (count (first inputs)))\n          terrain (plot-all blank inputs)\n          groups (get-all-groups terrain)\n          combs (get-all-combs groups)\n          valids (combos-with-all-valid-minterms terrain combs)\n          smallest (first (sort-by count valids))\n          ](non-changing-combo terrain smallest))))", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 140, "code": "(fn [minterms]\n   (letfn [(->set [n]\n             (clojure.set/union\n              (set (map second (filter (fn [[a b]] (= a \\1)) (map vector n ['A 'B 'C 'D]))))\n              (set (map second (filter (fn [[a b]] (= a \\0)) (map vector n ['a 'b 'c 'd]))))))\n           (->number [s] (map #(if (= (clojure.string/upper-case %) (str %)) \\1 \\0) (sort-by clojure.string/upper-case (seq s))))\n           (one-off? [a b] (and (not (= a b))\n                                (>= 1 (count (filter false? (map = a b))))))\n           (covered? [a b] \n                     (every? true? \n                             (map #(if (= %2 \\-) true (= %2 %1)) a b)))\n           (find-implicants [minterms] (let [simpleterms (into #{}\n                                                               (for [a minterms\n                                                                     b minterms\n                                                                     :when (one-off? a b)]\n                                                                 (map #(if (= %1 %2) %1 \\-) a b)))\n                                             lonelyterms (filter (fn [a] (every? (fn [b] (not (covered? a b))) simpleterms)) minterms)]\n                                         (if (empty? simpleterms) (map (partial apply str) lonelyterms) (find-implicants (into #{} (concat simpleterms lonelyterms))))))\n           (power [s]\n             (loop [[h & t] (seq s)\n                    result '(())]\n               (if h\n                 (recur t (concat result (map (partial cons h) result)))\n                 result)))]\n     (let [minterms (map ->number minterms)\n           implicants (find-implicants minterms)\n           implicants (power implicants)\n           implicants (filter (fn [is] (every? (fn [m] (some (fn [i] (covered? m i)) is)) minterms)) implicants)\n           implicants (sort-by count implicants)\n           implicants (first implicants)]\n       (set (map ->set implicants)))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 140, "code": "(fn [sets]\n  (let [; If s1 and s2 are boolean complements (they differ by only 1 flipped var)\n        ; return the common values and the original sets.\n        bool-complement (fn [[s1 s2]]\n                          (let [x12 (clojure.set/difference s1 s2)\n                                x21 (clojure.set/difference s2 s1)]\n                            (if (and (= (count (clojure.set/difference s1 s2)) 1)\n                                     (= (clojure.string/upper-case x12)\n                                        (clojure.string/upper-case x21)))\n                              [(clojure.set/intersection s1 s2) s1 s2]\n                              )\n                            )\n                          )\n        ; Return the common values of every boolean complement of pairing in sets,\n        ; and sets with those removed.\n        bool-reduce (fn [[sets acc]]\n                      (let [; Filter the boolean complements for every pairing in sets.\n                            comps (keep bool-complement (for [a sets, b (disj sets a)] [a b]))\n                            ; Get the reduced boolean algebra.\n                            x (set (map first comps))\n                            ; Remove the complements from sets.\n                            y (reduce #(disj % (second %2) (last %2)) sets comps)]\n                        [x (clojure.set/union acc y)]\n                        )\n                      )\n        ; Iteratively apply bool-reduce until no more reductions can be made.\n        ; Return the last set generated.\n        reduced-set (apply clojure.set/union\n                           (last (take-while #(not (empty? (first %)))\n                                             (iterate bool-reduce [sets #{}]))))\n        ; Apply the reduced-set to the original sets.\n        sets* (map (fn [x] (filter #(clojure.set/subset? % x) reduced-set)) sets)\n        ]\n    ; Return the set of boolean algebra that are uniquely required to satisfy sets.\n    (set (map first (filter #(= (count %) 1) sets*)))\n    )\n  )", "user": "5f419985e4b0955706451fab"}, {"problem": 140, "code": "(fn [bafs]\n  (let [sym-diff (fn [a b]\n                   (clojure.set/union\n                     (clojure.set/difference a b)\n                     (clojure.set/difference b a)))\n        complementary? (fn [a b]\n                         (->> (sym-diff a b)\n                              (map #(clojure.string/capitalize %))\n                              distinct\n                              count\n                              (= 1)))\n        simplify (fn [bafs residue]\n                   (let [simplification (for [a bafs b (disj bafs a) :when (complementary? a b)]\n                                          [(clojure.set/intersection a b) a b])\n                         to-remove (set (mapcat rest simplification))\n                         more-residue (clojure.set/difference bafs to-remove)\n                         to-simplify (set (map first simplification))]\n                     (if (= bafs to-simplify) residue\n                       (recur to-simplify (clojure.set/union residue more-residue)))))\n        simpflified (simplify bafs #{})\n        reapplied (map (fn [s] (filter #(clojure.set/subset? % s) simpflified)) bafs)\n        ]\n    (set (map first (filter #(= (count %) 1) reapplied)))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 140, "code": "(fn simplify\n  [sets]\n  (letfn [(sym-diff\n            [set1 set2]\n            (clojure.set/difference (clojure.set/union set1 set2)\n                                    (clojure.set/intersection set1 set2)))\n          (can-combine?\n            [set1 set2]\n            (let [sym-diff (sym-diff set1 set2)]\n              (and\n               (= 2 (count sym-diff))\n               (or (= #{'a 'A} sym-diff)\n                   (= #{'b 'B} sym-diff)\n                   (= #{'c 'C} sym-diff)\n                   (= #{'d 'D} sym-diff)))))\n          (simplify-step\n            [sets]\n            (into sets (for [set sets\n                             match (filter #(can-combine? set %) sets)]\n                         (clojure.set/intersection set match))))]\n    (clojure.core/set (let [all-exprs (->> (iterate simplify-step sets)\n                                           (partition 2 1)\n                                           (drop-while (fn [[x y]] (not= x y)))\n                                           ffirst)\n                            filtered-expr (filter (fn [expr] (not (some #(and (not= expr %)\n                                                                              (clojure.set/subset? % expr)) all-exprs)))\n                                                  all-exprs)]\n                        (remove (clojure.core/set (for [x filtered-expr\n                                                        y filtered-expr\n                                                        z filtered-expr\n                                                        :when (and (not= x y)\n                                                                   (not= y z)\n                                                                   (not= z x))\n                                                        :when (and (= 2 (count x))\n                                                                   (= 2 (count y))\n                                                                   (= 2 (count z)))\n                                                        :when (= 1 (count (clojure.set/intersection x y z)))]\n                                                    (last (sort-by str (list x y z)))))\n                                filtered-expr)))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 140, "code": "(fn veitch [terms]\n  (letfn [(index [bits]\n            (reduce + (map * (iterate #(* % 2) 1) (reverse bits))))\n          (convert-from [term]\n            (let [truth (map (comp symbol str char #(+ 65 %)) (range (count (first terms))))\n                  bits (vec (map #(if (term %) 1 0) truth))]\n              [(index bits) bits]))\n          (convert-all [terms]\n            (into {} (map convert-from terms)))\n          (recover [bits]\n            (set (filter identity (map-indexed (fn [i x] (cond (= x 1) (symbol (str (char (+ 65 i))))\n                                                               (= x 0) (symbol (str (char (+ 97 i))))\n                                                               :else nil)) bits))))\n          (group [convs]\n            (group-by (fn [[_ bits]] (apply + (map #(if (number? %) % 0) bits))) convs))\n          (combine [t1 t2]\n            (let [b1 (second t1)\n                  b2 (second t2)\n                  res (map #(if (= % %2) false true) b1 b2)]\n              (if (= 1 (count (filter true? res)))\n                {(set [(first t1) (first t2)]) (vec (map #(if (true? %2) '- %) b1 res))} nil)))\n          (combine-iter-size-fixed [groups index result]\n            (if (> index (reduce max (keys groups))) result\n                (let [curs (groups index)\n                      nexts (groups (inc index))]\n                  (cond (empty? curs) (combine-iter-size-fixed groups (inc index) result)\n                        (empty? nexts) (combine-iter-size-fixed groups (+ 2 index) result)\n                        :else (let [res (apply merge (map (fn [cur]\n                                                            (apply merge (map #(combine cur %) nexts))) curs))]\n                                (combine-iter-size-fixed groups (inc index) (merge result res)))))))\n          (combine-iter-all [implicants unreducibles]\n            (if (= 1 (count implicants)) (reduce conj unreducibles implicants)\n                (let [res (combine-iter-size-fixed (group implicants) 0 {})]\n                  (if (empty? res) (reduce conj unreducibles implicants)\n                      (let [reduced-indecies (apply clojure.set/union (keys res))\n                            unreducs (reduce dissoc implicants reduced-indecies)]\n                        (combine-iter-all res (reduce conj unreducibles unreducs)))))))\n          (remove-repeated [implicants]\n            (reduce (fn [m [k v]] (if (set? (first k)) (assoc m (set ((fn flat [v]\n                                                                        (if (not (coll? v)) (list v)\n                                                                            (mapcat flat v))) k)) v)\n                                      (assoc m k v))) {} implicants))\n          (essentials [terms]\n            (remove (fn [t]\n                      (clojure.set/subset? t (apply clojure.set/union (seq (disj (set terms) t))))) terms))]\n    (let [truths (convert-all terms)\n          implicants (combine-iter-all truths {})]\n      (if (number? (first (keys implicants))) (set (map recover (vals implicants)))\n          (let [refined (remove-repeated implicants)]\n            (if (= 1 (count refined)) (set (map recover (vals refined)))\n                (set (map #(recover (refined %)) (essentials (keys refined))))))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 140, "code": "(fn bruteforce [s]\n  (let [set->coord (fn  [minterm]\n                     (let [coordmap {\"0\" 0\n                                     \"1\" 1\n                                     \"00\" 0\n                                     \"01\" 1\n                                     \"11\" 2\n                                     \"10\" 3}\n                           binmap (reduce #(str %1 (if (= (name %2) (clojure.string/lower-case (name %2))) \"0\" \"1\")) \"\" (sort-by  #(-> % name clojure.string/lower-case) minterm))\n                           AB (coordmap (subs binmap 0 2))\n                           CD (coordmap (subs binmap 2))]\n                       [CD AB]))\n        build-karnaugh-map (fn  [s]\n                             (let [AB-size 4\n                                   C-maybeD-size (if (= 3 (-> s first count)) 2 4)\n                                   sets-of-1s (set (map set->coord s))\n                                   initial-grid (for [i (range AB-size) j (range C-maybeD-size)]\n                                                  (if (contains? sets-of-1s [i j])\n                                                    {:i i :j j :v 1 :checked false}\n                                                    {:i i :j j :v 0 :checked true}))]\n                               initial-grid))\n\n        get-vertical-bound (fn get-vertical-bound [km]\n                             (inc  (apply max (map #(% :j) km))))\n\n        get-horizontal-bound (fn  [km]\n                               4)\n\n        get-horizontal-line (fn  [i km]\n                              (filter #(= i (% :i))  km))\n\n        horizontal-line? (fn  [i km]\n                           (empty? (remove #(= 1 (% :v))  (get-horizontal-line i km))))\n\n        get-vertical-line (fn  [j km]\n                            (filter #(= j (% :j))  km))\n\n        vertical-line? (fn  [j km]\n                         (empty? (remove #(= 1 (% :v))  (get-vertical-line j km))))\n\n\n        get-square-up-right (fn  [i j km]\n                              (filter #(and (contains? #{i (mod (dec i) (get-horizontal-bound km))} (% :i))\n                                            (contains? #{j (mod (inc j) (get-vertical-bound km))} (% :j))) km))\n        square-up-right? (fn  [i j km]\n                           (empty? (remove #(= 1 (% :v)) (get-square-up-right i j km))))\n\n        get-square-up-left (fn  [i j km]\n                             (filter #(and (contains? #{i (mod (dec i) (get-horizontal-bound km))} (% :i))\n                                           (contains? #{j (mod (dec j) (get-vertical-bound km))} (% :j))) km))\n        square-up-left? (fn  [i j km]\n                          (empty? (remove #(= 1 (% :v)) (get-square-up-left i j km))))\n\n        get-square-down-right (fn  [i j km]\n                                (filter #(and (contains? #{i (mod (inc i) (get-horizontal-bound km))} (% :i))\n                                              (contains? #{j (mod (inc j) (get-vertical-bound km))} (% :j))) km))\n\n        square-down-right? (fn  [i j km]\n                             (empty? (remove #(= 1 (% :v)) (get-square-down-right i j km))))\n\n        get-square-down-left (fn  [i j km]\n                               (filter #(and (contains? #{i (mod (inc i) (get-horizontal-bound km))} (% :i))\n                                             (contains? #{j (mod (dec j) (get-vertical-bound km))} (% :j))) km))\n\n        square-down-left? (fn  [i j km]\n                            (empty? (remove #(= 1 (% :v)) (get-square-down-left i j km))))\n\n        get-neighbor (fn  [i j km]\n                       (let [i (mod i (get-vertical-bound km))\n                             j (mod j (get-horizontal-bound km))]\n                         (first (filter #(and (= i (% :i))\n                                              (= j (% :j))) km))))\n\n        get-unchecked (fn  [km]\n                        (remove #(% :checked)  km))\n\n        mark-unchecked (fn  [els km]\n                         (map #(if (contains? (set els) %)\n                                 (update-in % [:checked] (constantly true))\n                                 %) km))\n\n        coord->symbol (fn  [i j vertical-size]\n                        (let [coord->bin {0 \"00\"\n                                          1 \"01\"\n                                          2 \"11\"\n                                          3 \"10\"}\n                              binrpr (str (coord->bin j) (if (= 4 vertical-size) (coord->bin i) (last (coord->bin i))))\n                              symbs (into #{}\n                                          [(if (= \\1 (first binrpr)) 'A 'a)\n                                           (if (= \\1 (second binrpr)) 'B 'b)\n                                           (if (= \\1 (nth binrpr 2)) 'C 'c)])]\n                          (if (= 4 vertical-size)\n                            (conj symbs (if (= \\1 (last binrpr)) 'D 'd))\n                            symbs)))\n\n        checked->minsymbol (fn  [els size]\n                             (let [symbols (map #(coord->symbol (% :i) (% :j) size) els)]\n                               (apply clojure.set/intersection symbols)))\n        karnaugh-solver (fn\n                          [km]\n                          (let [vsize (get-vertical-bound km)]\n                            (loop [km km acc #{}]\n                              (let [h (first (get-unchecked km))]\n                                (cond\n                                  (nil? h)\n                                  acc\n                                  (square-up-left? (h :i) (h :j) km)\n                                  (recur (mark-unchecked (get-square-up-left (h :i) (h :j) km) km)\n                                         (conj acc (checked->minsymbol (get-square-up-left (h :i) (h :j) km) vsize)))\n                                  (square-up-right? (h :i) (h :j) km)\n                                  (recur (mark-unchecked (get-square-up-right (h :i) (h :j) km) km)\n                                         (conj acc (checked->minsymbol (get-square-up-right (h :i) (h :j) km) vsize)))\n                                  (square-down-left? (h :i) (h :j) km)\n                                  (recur (mark-unchecked (get-square-down-left (h :i) (h :j) km) km)\n                                         (conj acc (checked->minsymbol (get-square-down-left (h :i) (h :j) km) vsize)))\n\n                                  (square-down-right? (h :i) (h :j) km)\n                                  (recur (mark-unchecked (get-square-down-right (h :i) (h :j) km) km)\n                                         (conj acc (checked->minsymbol (get-square-down-right (h :i) (h :j) km) vsize)))\n\n                                  (horizontal-line? (h :i) km)\n                                  (recur (mark-unchecked (get-horizontal-line (h :i) km) km)\n                                         (conj acc (checked->minsymbol (get-horizontal-line (h :i) km) vsize)))\n                                  (vertical-line? (h :j) km)\n                                  (recur (mark-unchecked (get-vertical-line (h :j) km) km)\n                                         (conj acc (checked->minsymbol (get-vertical-line (h :j) km) vsize)))\n\n                                  (= 1 ((get-neighbor (inc (h :i)) (h :j) km) :v)) ;; down neighbor\n                                  (recur (mark-unchecked [h (get-neighbor (inc (h :i))  (h :j) km)] km)\n                                         (conj acc (checked->minsymbol [h (get-neighbor (inc (h :i))  (h :j) km)] vsize)))\n\n                                  (= 1 ((get-neighbor (dec (h :i)) (h :j) km) :v)) ;; up neighbor\n                                  (recur (mark-unchecked [h (get-neighbor (dec (h :i))  (h :j) km)] km)\n                                         (conj acc (checked->minsymbol [h (get-neighbor (dec (h :i))  (h :j) km)] vsize)))\n\n                                  (= 1 ((get-neighbor  (h :i) (inc (h :j)) km) :v)) ;; right neighbor\n                                  (recur (mark-unchecked [h (get-neighbor (h :i)  (inc (h :j)) km)] km)\n                                         (conj acc (checked->minsymbol [h (get-neighbor (h :i)  (inc (h :j)) km)] vsize)))\n\n                                  (= 1 ((get-neighbor  (h :i) (dec (h :j)) km) :v)) ;; left neighbor\n                                  (recur (mark-unchecked [h (get-neighbor (h :i)  (dec (h :j)) km)] km)\n                                         (conj acc (checked->minsymbol [h (get-neighbor (h :i)  (dec (h :j)) km)] vsize)))\n\n                                  :else\n                                  (recur (mark-unchecked [h] km)\n                                         (conj acc (checked->minsymbol [h] vsize))))))))\n\n        objective-fct (fn  [res]\n                        (reduce #(+ %1 (count %2)) 0 res))\n        iter 1000\n        km (build-karnaugh-map s)]\n    (loop [i 0 best-res (set (map vector (range 1000)))]\n      (let [iteration-res (karnaugh-solver (shuffle km))]\n        (cond\n          (> i iter)\n          best-res\n          (> (objective-fct best-res) (objective-fct iteration-res))\n          (recur (inc i) iteration-res)\n          :else\n          (recur (inc i) best-res))))))", "user": "608ec5e4e4b03bd49d9f36c0"}]