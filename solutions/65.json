[{"code": "#({\\# :set \\{ :map \\[ :vector \\c :list} (nth (str %) 0))", "problem": 65, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn [x]\r\n  (let [result ({\r\n    {:a 1, :b 2} :map,\r\n    [1 2 3 4 5 6] :vector} x)]\r\n    (if result \r\n      result\r\n      (cond \r\n        (contains? (into x [[:a :b]]) [:a :b]) :set\r\n        (contains? (into x [[:a :b]]) :a) :map\r\n        (= (conj x :a :b) [:a :b]) :vector\r\n        :else :list\r\n        ))))", "problem": 65, "user": "4dcd818e535d5973398f929d"}, {"code": "(fn[x](if(= 3 (:c (conj x [:c 3]))):map(#(if(= 3(-(count%)(count x)))(if(=(last%)-1):vector :list):set)(conj x 0 0 -1))))", "problem": 65, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn [s]\r\n  (let [x (rand-int 1000) y (rand-int 1000) z [x y] c (conj s z)]\r\n    (cond \r\n      (= y (get c x)) :map\r\n      (= z (get c z)) :set\r\n      (= x (last (conj c x))) :vector\r\n      :else :list)))", "problem": 65, "user": "4dc986d0535d5973398f9285"}, {"code": "#({\\# :set \\[ :vector \\{ :map \\( :list \\c :list} (first (str %)))", "problem": 65, "user": "4db03279838c48654951d9bc"}, {"code": "(fn [coll]\r\n  (cond\r\n\t\t(get (conj coll [::blah 42]) ::blah)                             :map\r\n\t\t(>= (inc (count coll)) (count (conj (conj coll ::blah) ::blah))) :set\r\n\t\t(= (conj coll ::a) (-> coll (conj ::a) (conj ::b) rest))         :list\r\n\t\t:else                                                            :vector))", "problem": 65, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn  [coll] \r\n  (if (empty? coll)\r\n    (cond \r\n      (identical? coll {}) :map \r\n      (identical? coll #{}) :set \r\n      (identical? coll []) :vector \r\n      (identical? coll '()) :list)\r\n    (cond \r\n      (= (set coll) coll) :set\r\n      ((complement nil?) (get coll 0)) :vector\r\n      (= 2 (count ( flatten (first coll)))) :map\r\n      :else :list)))", "problem": 65, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn[x](let [s (first (pr-str x))]\r\n  (cond (= s \\() :list\r\n        (= s \\[) :vector\r\n        (= s \\#) :set\r\n        (= s \\{) :map)))", "problem": 65, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn which-type [coll]\r\n  (let [coll (conj coll {:a :b})\r\n        x {:a :b}]\r\n    (if (= (conj coll x) coll)\r\n      (if (= (coll x) x)\r\n        :set\r\n        :map)\r\n      (if (= (first (conj coll 0)) 0)\r\n        :list\r\n        :vector))))", "problem": 65, "user": "4dd023dd535d5973398f92ad"}, {"code": "(fn [c]\r\n  (let [arb [(rand-int 100000) (rand-int 100000)]\r\n        is-map (fn [c]\r\n                 (= (get (conj c arb) (first arb) nil) (second arb)))\r\n        is-set (fn [c]\r\n                (= 1 (count (filter (partial = arb) (conj (conj c arb) arb)))))\r\n        is-vec (fn [c]\r\n                 (= (last (conj c nil arb)) arb))\r\n        is-lis (fn [c]\r\n                 (= (first (conj c nil arb)) arb))]\r\n    (cond (is-map c) :map (is-set c) :set (is-vec c) :vector (is-lis c) :list)))", "problem": 65, "user": "4ddc1c89535d02782fcbea01"}, {"code": "(fn [obj]\r\n  (cond (= (conj obj obj) obj)\r\n        :map\r\n        (= (conj obj obj) (conj (conj obj obj) obj))\r\n        :set\r\n        (= (first (conj (conj obj true) false)) false)\r\n        :list\r\n        :else\r\n        :vector))", "problem": 65, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [i-list]\r\n    (let [a-dupe [:foo :bar]\r\n        a-item [:foo :baz]\r\n        a-list (conj i-list a-dupe a-dupe a-item)\r\n        a-count (count a-list)\r\n        i-count (count i-list)]\r\n        (if (= (+ i-count 2) a-count)\r\n        :set\r\n        (if (= (+ i-count 1) a-count)\r\n            :map\r\n            (if (= (first a-list) a-item) :list :vector))))\r\n)", "problem": 65, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn bbtest [s]\r\n      (let [sq (conj s {:a :b} {:a :b} {:c :d})]\r\n  (cond\r\n\t (= (* (count sq) 2) (count (flatten (seq sq)))) :map\r\n\t (= (+ 2 (count s)) (count sq)) :set\r\n\t (= (last sq) {:c :d}) :vector\r\n\t :else :list)))", "problem": 65, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn blacktest [S]\r\n  (cond\r\n\t\t(= (count S) (count (merge S S))) :map\r\n\t\t(= (count (conj S -100)) (count (conj (conj S -100) -100))) :set\r\n\t\t(= -120 (last (conj (conj S -110) -120))) :vector\r\n    :else :list\r\n\t))", "problem": 65, "user": "4dadca03c9a9d6ed4199dc57"}, {"code": "(fn [s]\r\n  (condp = (first (pr-str s))\r\n      \\# :set\r\n      \\{ :map\r\n      \\( :list\r\n      \\[ :vector))", "problem": 65, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn [s]\r\n  (let [g (gensym)\r\n        e1 {g :q}\r\n        e2 {g :q}\r\n        e3 {g :w}\r\n        c (conj s e1 e2 e3)]\r\n    (if (< (count c) (+ 2 (count s)))\r\n      :map\r\n      (if (< (count c) (+ 3 (count s)))\r\n        :set\r\n        (if (= e3 (first c))\r\n          :list\r\n          :vector)))))", "problem": 65, "user": "4de877f6535d08e6dec9fdfd"}, {"code": "(fn [coll]\r\n  (let [t1 (Object.)\r\n        t2 (Object.)\r\n        p  [t1 t2]\r\n        as (conj coll p)]\r\n    (if (= (count as) (count (conj as p)))\r\n      (if (as t1)\r\n        :map\r\n        :set)\r\n      (if (= t1 (first (conj as t1)))\r\n        :list\r\n        :vector))))", "problem": 65, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "#(let [v (conj % [:t 1]) s (first (str v))]\n    (cond\n     \t(= 1 (get v :t)) :map\n        (= s \\() :list\n        (= s \\#) :set\n        :else :vector))", "problem": 65, "user": "4df1e213535d08e6dec9fe20"}, {"code": "(fn [coll]                                 \r\n                                 (let [maptest (conj coll [:qweqwe 11])]                                 \r\n                                   (if (contains? maptest :qweqwe) \r\n                                     :map\r\n                                     (let [coll2 (conj coll 9991 9992 9992 9993)]\r\n                                  (cond \r\n                                    (= (take-last 4 coll2) [9991 9992 9992 9993]) :vector\r\n                                    (= (take 4 coll2) '(9993 9992 9992 9991)) :list\r\n                                    :else :set\r\n                                    )))))", "problem": 65, "user": "4deb529a535d08e6dec9fe04"}, {"code": "(fn [s]\r\n  (if (associative? s)\r\n    (if (= (first (assoc s 0 :test)) :test) :vector :map)\r\n    (if (= (first (conj s 0 :test)) :test) :list :set)))", "problem": 65, "user": "4dee4a9c535d08e6dec9fe11"}, {"code": "(fn klass [x]\r\n  (let [e (empty x)]\r\n    (cond\r\n      (= e {}) :map\r\n      (= e #{}) :set\r\n      (and (= e []) (= [1 2] (into e [1 2]))) :vector\r\n      (and (= e '()) (= [2 1] (into e [1 2]))) :list)))", "problem": 65, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn [s]\r\n  (cond\r\n   (= 1 (:go (conj s [:go 1])) ) :map\r\n   (= (conj s 1 1) (conj s 1)) :set\r\n   (= 2 (last (conj s 1 2))) :vector\r\n   true :list))", "problem": 65, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn [x] \r\n  (let [new-x (into x [[:aa32 :bb] [:cc43 :dd]])]\r\n    (cond \r\n      (contains? new-x :aa32) :map\r\n      (contains? new-x [:aa32 :bb]) :set\r\n      (= (take-last 2 new-x) [[:aa32 :bb] [:cc43 :dd]]) :vector\r\n      :default :list)))", "problem": 65, "user": "4def301c535d08e6dec9fe12"}, {"code": "#({\r\n  \\# :set\r\n  \\[ :vector\r\n  \\{ :map} \r\n  (nth (str %) 0)\r\n  :list)", "problem": 65, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn[x]\r\n  (condp = (first(str x))\r\n\\[ :vector\r\n\\# :set\r\n\\{ :map\r\n\\c :list\r\n))", "problem": 65, "user": "4dd66da7535d2dad7130b5c8"}, {"code": "(fn seq-type [coll]\r\n  (let [base (empty coll)]\r\n    (cond\r\n      (= base {})        :map\r\n      (= base #{})       :set\r\n      (reversible? base) :vector\r\n      (= base ())        :list)))", "problem": 65, "user": "4df669d4535d08e6dec9fe35"}, {"code": "(fn [col]\r\n  (cond \r\n    (< (count (conj col [:a 1] [:a 1])) (+ 2 (count col)))\r\n     (if (nil? ((conj col [:a 1]) [:a 1])) :map :set)\r\n    (= (list* :a :b col) (conj col :b :a)) :list\r\n    (= (conj (vec col) :a :b) (conj col :a :b)) :vector))", "problem": 65, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn [v]\r\n  (cond\r\n   (and (associative? v)\r\n        (reversible? v))\r\n   :vector\r\n   \r\n   (associative? v)\r\n   :map\r\n\r\n   (= (empty v) #{})\r\n   :set\r\n\r\n   true\r\n   :list\r\n   )\r\n  )", "problem": 65, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn g [coll]\r\n  (let [s (seq coll)]\r\n    (cond\r\n     (not (= (inc (count coll)) (count (conj coll {1 1 2 2})))) :map\r\n       (= (inc (count coll)) (count (conj coll 1 1))) :set\r\n       :else (let [v (vec coll)]\r\n         (if (=\r\n\t\t    (-> v (conj 1) (conj 2))\r\n\t\t    (-> coll (conj 1) (conj 2)))\r\n\t\t :vector\r\n\t\t :list)))))", "problem": 65, "user": "4e02bee8535d04ed9115e791"}, {"code": "(let [[a b c] (repeatedly gensym)\n      e1 [a b]\n      e2 [a c]]\n  (fn [x]\n    (let [y (conj x e1 e1 e2)\n          diff (- (count y) (count x))]\n      (condp = diff\n        1 :map\n        2 :set\n        (if (= (first y) e2)\n          :list\n          :vector)))))", "problem": 65, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn [x]\r\n  (let [result ({\r\n    {:a 1, :b 2} :map,\r\n    [1 2 3 4 5 6] :vector} x)]\r\n    (if result\r\n      result\r\n      (cond\r\n        (contains? (into x [[:a :b]]) [:a :b]) :set\r\n        (contains? (into x [[:a :b]]) :a) :map\r\n        (= (conj x :a :b) [:a :b]) :vector\r\n        :else :list\r\n        ))))", "problem": 65, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "#({\\{ :map\n     \\[ :vector\n     \\# :set} (first (str %)) :list)", "problem": 65, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [coll]\n  (let [xs (conj coll [:a 0] [:a 42])\n        ys (conj coll [:a 42] [:a 0])]\n    (cond (= xs ys) :set\n          (= (get xs :a) 42) :map\n          (= (first xs) [:a 42]) :list\n          (= (last  xs) [:a 42]) :vector)))", "problem": 65, "user": "4db53810535d87e67b28fe07"}, {"code": "#(let [z [1 3]\r\n       n (conj  % [1 2] z z)\r\n       d (- (count n) (count %))]\r\n  (cond\r\n    (= d 1) :map\r\n    (= d 2) :set\r\n    (= (last n) z) :vector\r\n    =  :list))", "problem": 65, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn checkit [coll]\n  (cond\n    (> (+ 2 (count coll)) \n       (count (conj (conj coll [:test1 :test2]) [:test1 :test2])))\n      (if (get (conj coll [:test1 :test2]) :test1) :map :set)\n    true\n      (if (= (first (conj (conj coll :test1) :test2)) :test2) :list :vector)\n    ))", "problem": 65, "user": "4e14108c535d04ed9115e7dd"}, {"code": "#({\\# :set \\{ :map \\[ :vector \\c :list} (nth (str %) 0))", "problem": 65, "user": "4e14b925535d04ed9115e7df"}, {"code": "(fn gettype [xs] \n  (if (associative? xs) \n    (if (reversible? xs) \n      :vector\n      :map) \n    (if (= (+ (count xs) 2)\n           (count (conj (conj xs 1) 1))) \n      :list\n      :set)))", "problem": 65, "user": "4e123905535d04ed9115e7ce"}, {"code": "#(if(=(vec %)%)(if(get(conj % 0)0):vector :list)(if(=(set %)%):set :map))", "problem": 65, "user": "4e31a15c535deb9a81d77f1e"}, {"code": "(fn [xs]\r\n   (letfn [(is-list? [xs]\r\n                     (println xs)\r\n                     (let [xss (conj xs :a1 :b1 :c1 :d1 :e1 :f1 :g1 :h1)]\r\n                       (println xss)\r\n                       (= :h1 (first xss))))]\r\n     (cond (and (associative? xs) (reversible? xs))\r\n           :vector\r\n           (associative? xs)\r\n           :map\r\n           (is-list? xs)\r\n           :list\r\n           :else\r\n           :set)))", "problem": 65, "user": "4e26e8b4535deb9a81d77ef6"}, {"code": "(fn black-box\n  [x]\n  (if (reversible? x)\n    :vector\n    (if (associative? x)\n      :map\n      (let [y (conj (conj x 100) 100)]\n        (if (= (count y) (+ 1 (count x)))\n          :set :list)))))", "problem": 65, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [col]\n  (let [col (empty col)]\n\t     (cond\n\t       (= #{} col) :set\n\t       (= {} col) :map\n\t       (= (conj col 1 2)[1 2]) :vector\n\t       :else :list)))", "problem": 65, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "#(get{0 :map, 2 :set, 9 :vector, 8 :list, 5 :list}(mod(hash((new clojure.core$type)%1))10))", "problem": 65, "user": "4e3b6bff535deb9a81d77f52"}, {"code": "(fn p65 [x]\n  (cond (associative? x) (if (= [[1 2]] (conj (empty x) [1 2])) :vector :map)\n  :else (if (= #{1} (conj (conj (empty x) 1) 1))\n\t\t:set\n\t\t:list)))", "problem": 65, "user": "4e513ecf535dc968683fc4f6"}, {"code": "#(let [t (conj % [:a :b] [1 2])]\n   (cond (contains? t [:a :b]) :set\n         (= (get t :a) :b) :map\n         (= (last t) [1 2]) :vector\n         :e :list))", "problem": 65, "user": "4e52d815535d302ef430da77"}, {"code": "#({\"{}\" :map \"[]\" :vector \"()\" :list} (pr-str (empty %)) :set)", "problem": 65, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (apply distinct? (conj % nil nil)) :set\n  :default :list)", "problem": 65, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn[coll]\n  (let [sym (gensym)\n        coll (conj coll [sym sym])]\n    (if (= (count coll) (count (conj coll (first coll))))\n      (if (nil? (get coll sym))\n        :set\n        :map)\n      (if (= (first (conj coll sym)) sym)\n        :list\n        :vector))))", "problem": 65, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "#(let [c conj\n       f first\n       i (c % [1 2])\n       j (c i i)]\n  (condp = i\n    j           :map\n    (f j)       :list\n    (c i (f i)) :set\n                :vector))", "problem": 65, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [coll] (let [k (gensym) a {k 1} b {k 2}\n       consa (cons a coll)\n       consa2 (cons a consa)\n       conja (conj coll a)\n       conjb (conj coll b)\n       conja2 (conj conja a)\n       conja2b (conj conja2 b)\n       consa2b (cons b consa2)]\n  (cond\n    (= consa2b conja2b) :list\n    (= conja (conj conjb a)) :map\n    (= conja conja2) :set\n    (= b (last conja2b) (first consa2b)) :vector\n    :else :unsupported)))", "problem": 65, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn [c]\n  (let [d (conj c [7 8])]\n    (cond\n      (= 8 (get d 7)) :map\n      (= (get d [7 8]) [7 8]) :set\n      (nil? (get d 0)) :list\n      1 :vector)))", "problem": 65, "user": "4e5411e8535d8a8b8723a279"}, {"code": "#(if (associative? %)\n  (if (reversible? %)\n      :vector\n      :map)\n  (if (ifn? %)\n      :set\n      :list))", "problem": 65, "user": "4e593dac535d8a8b8723a29c"}, {"code": "#(if (reversible? %) :vector\n  (if (associative? %) :map\n    (if (apply distinct?\n          (into % [4 4]))\n      :set\n      :list)\n  )\n)", "problem": 65, "user": "4e3456f9535deb9a81d77f2a"}, {"code": "(fn [s]\n    (if (get (conj s [:a 2]) :a)\n      :map\n      (cond\n       (= (first (conj s :a :b)) :b)\n       :list\n\n       (< (count (conj s 1 1))\n          (+ 2 (count s)))\n       :set\n\n       :else\n       :vector)))", "problem": 65, "user": "4dad938fc9a9d6ed1b99dc57"}, {"code": "(fn\n  [coll]\n  (let [c (count coll)\n        n (into coll [[1 1] [1 2] [1 3] [1 1] [1 4]])\n        cn (count n)]\n    (cond\n     (= (- cn c) 1) :map\n     (= (- cn c) 4) :set\n     (= (first n) [1 4]) :list     \n     :else :vector)))", "problem": 65, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn [c]\n  (if (= (vec c) c)\n    (if (associative? c)\n      :vector\n      :list)\n    (if (associative? c)\n      :map\n      :set)))", "problem": 65, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "#(let [e (empty %)\n       f conj \n       i nil\n       n (count (f e i i))]\n      (if (= n 2) (nth (f e :vector :list) 0)\n          ([:map :set] n)))", "problem": 65, "user": "4e5ecd65535d8a8b8723a2d6"}, {"code": "(fn *type                                                                                                                    \n  [coll]                                                                                                                       \n  (let [ecoll (empty coll)]                                                                                                    \n    (cond                                                                                                                      \n     (= #{} ecoll) :set                                                                                                        \n     (= {} ecoll) :map                                                                                                         \n     (get (conj ecoll 0) 0) :vector                                                                                            \n     :else :list)))", "problem": 65, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn seq-type [col]\n        (let [col (conj col [1 2])]\n          (if (= (conj col col) col)\n            :map\n            (if (= (count col) (count (conj col (first col))))\n              :set\n              (if (= (first col) (first (conj col (not (first col)))))\n                :vector\n                :list)))))", "problem": 65, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(fn [coll]\n                         (let [c (if (> (count coll) 0) coll (apply conj coll [[:a 1] [:b 2]]))]\n                           (cond\n                            (and (= (first (conj c [:test_UID 42])) [:test_UID 42])\n                                 (nil? (:test_UID (conj c [:test_UID 42]))))\n                            :list\n                            \n                            (and (= (count c) (count (conj c (first c))))\n                                 (nil? (:test_UID (conj c [:test_UID 42]))))\n                            :set\n\n                            (= [:test_UID 42] (last (conj c [:test_UID 42])))\n                            :vector\n\n                            (and (= 2 (count (first c)))\n                                 (= (second (first c)) (c (first (first c)))))\n                            :map)))", "problem": 65, "user": "4e08fb7a535d04ed9115e7ac"}, {"code": "#(let [v1 1 \n        v2 2\n        x (empty %)\n        c (count x)]\n  (cond\n    (= (count (conj x [v1 v2] [v1 v1])) (inc c)) :map\n    (= (count (conj x v1 v1)) (inc c)) :set\n    (= (conj x v1 v2) [v1 v2]) :vector \n    (= (conj x v1 v2) [v2 v1]) :list\n    true nil))", "problem": 65, "user": "4e5f08c7535d8a8b8723a2da"}, {"code": "(fn *type                                                                                             \n  [coll]\n  (let [ecoll (empty coll)]\n    (cond\n     (= #{} ecoll) :set\n     (= {} ecoll) :map\n     (= (first (conj ecoll :x :y)) :y) :list\n     :else :vector)))", "problem": 65, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "(fn type- [x]\n  \"64. Write a function which takes a collection and returns one                                                                                                        \n  of :map, :set, :list, or :vector - describing the type of collection                                                                                                  \n  it was given.\"\n  (if (associative? x)\n    (if (reversible? x)\n      :vector\n      :map)\n    (let [before (count x)\n          after (count (conj (conj x :a) :a))]\n      (if (= after (inc before))\n  :set\n\t:list))))", "problem": 65, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "#(let [x (conj % [9 8] [7 6])]\n    (cond (get x [9 8]) :set\n          (= (get x 9) 8) :map\n          (= (first x) [7 6]) :list\n          1 :vector))", "problem": 65, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "#(cond\n          (= :a (:a (conj % [:a :a]))) :map\n          (= (count %) (dec (count (conj (conj % :a) :a)))) :set\n          (= :a (first (conj (conj % :b) :a))) :list\n          :else :vector)", "problem": 65, "user": "4e6b3fc8535d8ccf87e9ff0f"}, {"code": "(fn [c]\n  (let [\n    same_size? (fn [c1, c2] (= (count c1) (count c2)))\n    not_adds_nil? (fn [c] (same_size? c (conj c nil)) )\n  ] \n  (cond\n    (not_adds_nil? c) :map\n    (same_size? (conj c :el) (conj (conj c :el) :el)) :set\n    (= :el1 (last (conj (conj c :el2) :el1))) :vector\n    :else :list\n)))", "problem": 65, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn [s]\r\n        (let [t (conj s  [1 9] [1 9] [2 2])]\r\n          (cond\r\n            (= (count t) (+ (count s) 3))\r\n              (cond\r\n                (= (first t) [2 2])\r\n                  :list\r\n                (= (last t) [2 2])\r\n                :vector)\r\n            :else\r\n                (cond\r\n                  (= (t 1) 9)\r\n                  :map\r\n                :else\r\n                  :set))))", "problem": 65, "user": "4e44358f535dc968683fc4a8"}, {"code": "(fn [a-seq] \n  (let [insertion (conj a-seq [:doingtest 1] [:doingtest 1] [:doingtest 2])]\n    (cond \n      (:doingtest insertion) :map\n      (not= (count a-seq) \n         (- (count insertion) 3)) :set\n      (= [:doingtest 2] (first insertion)) :list\n      (= [:doingtest 2] (last insertion)) :vector\n      :else :other)))", "problem": 65, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn bbtest [coll]\n  (let [len (count coll)\n        ncoll (-> coll\n                  (conj [:unusual-key :x])\n                  (conj [:unusual-key :x])\n                  (conj [:unusual-key :y]))\n        diff (- (count ncoll) len)]\n    (cond\n     (= 1 diff) :map\n     (= 2 diff) :set\n     (= 3 diff) (if (= (first ncoll) [:unusual-key :y])\n                  :list\n                  :vector)\n     :else nil)))", "problem": 65, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn blackbox-detect-type\n  [coll]\n  (or\n   ;; Map\n   (when (let [k (Object.)\n               v (Object.)]\n           (= v (get (conj coll [k v]) k)))\n     :map)\n   ;; List\n   (when (let [v1 (Object.)\n               v2 (Object.)]\n           (= (concat [v2 v1] coll) (conj coll v1 v2)))\n     :list)\n   ;; Vector\n   (when (let [v1 (Object.)\n               v2 (Object.)]\n           (= (concat coll [v1 v2]) (conj coll v1 v2)))\n     :vector)\n   ;; Set\n   (when (let [v (Object.)]\n           (= (conj coll v) (conj coll v v)))\n     :set)))", "problem": 65, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn [coll]\n  (let [sent     [:sent1 1]\n        sent2    [:sent2 2]\n        coll2    (conj coll sent sent)\n        coll3    (conj coll sent sent2)]\n    (if (= 1 (- (count coll2) (count coll))) \n      (if (= 1 (coll2 :sent1)) :map :set)\n      (if (= sent2 (first coll3)) :list :vector))))", "problem": 65, "user": "4e71705e535d5021c1a89649"}, {"code": "#(let [a '[a b]\n       b '[a c]\n       x (conj % a)\n       n (count x)\n       y (conj x b)]\n   (cond\n     (= n (count y))  :map\n     (= x (conj x a)) :set\n     (= b (first y))  :list\n     (= b (last y))   :vector))", "problem": 65, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn blackbox [s]\n  (cond\n   (= (conj s {}) s) :map \n   (empty? s) (cond\n         (= (clojure.set/union s #{}) #{}) :set\n\t       (= (conj (conj s 0) 1) [0 1]) :vector\n\t       :else :list)\n   (= (clojure.set/union s s) s) :set\n   (= (first (conj s s)) s) :list\n   :else :vector))", "problem": 65, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [coll]\n  (let [conjed (conj coll {:dmy1 :dmy1} {:dmy2 :dmy2} {:dmy2 :dmy3})\n        consed (cons {:dmy2 :dmy3} (cons {:dmy2 :dmy2} (cons {:dmy1 :dmy1} coll)))]\n    (cond (= conjed consed) :list\n          (= conjed (concat coll [{:dmy1 :dmy1} {:dmy2 :dmy2} {:dmy2 :dmy3}])) :vector\n          (= (count conjed) (count consed)) :set\n          :else :map)))", "problem": 65, "user": "4e7c8fd1535db169f9c796be"}, {"code": "#(let [t (partial (fn[s1, s2] (.contains s1 s2)) (.toString %))]\n  (cond (t \"#\") :set\n        (t \"{\") :map\n        (t \"[\") :vector\n        :else :list\n))", "problem": 65, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [c]\n  (let [s (gensym)\n        t (gensym)]\n    (cond (= (get (conj c [s s]) s) s)\n          :map\n          (= (conj (conj c s) s) (conj c s))\n          :set\n          (= (first (conj (conj c s) t)) t)\n          :list\n          :else\n          :vector)))", "problem": 65, "user": "4e7dd982535db169f9c796ee"}, {"code": "(fn [t]\n    (if (:z (into t [[:z 1]])) :map\n        (let [d (into t [:a :b])]\n          (cond (:a d) :set\n                (= :b (last d)) :vector\n                :else :list))))", "problem": 65, "user": "4e5867d1535d8a8b8723a291"}, {"code": "#(cond\n  (= {} (empty %)) :map\n  (= () (empty %)) (if (= (-> % empty str) \"[]\") :vector :list)\n  (= #{} (empty %)) :set)", "problem": 65, "user": "4e79a143535db169f9c796a2"}, {"code": "#((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty %)))", "problem": 65, "user": "4db858d1535d1e037afb218c"}, {"code": "#(condp = (empty %)\n  {} :map\n  #{} :set\n  [] (if (= 100 (first (conj % 10 100))) :list :vector))", "problem": 65, "user": "4e80d71b535db62dc21a62b7"}, {"code": "(fn [coll]\n    (let [x [99 99] cnt (count coll) y (conj coll x x) z 100 is-map (get y 99)]\n      (if (= (count y) (+ 1 cnt))\n\t      (if is-map :map :set)\n\t      (if (= (first (conj y z)) z) :list :vector))))", "problem": 65, "user": "4e6a4edd535d8ccf87e9fec4"}, {"code": "#(let [coll %1 g1 (gensym) g2 (gensym)]\n    (cond\n     (get (into coll {g1 g2}) g1)\n     :map\n    (= (inc (count coll))\n         (count (conj coll g1 g1)))\n      :set\n      (= g2\n        (first (conj coll g1 g2)))\n     :list\n\n      :im-a-vec\n      :vector))", "problem": 65, "user": "4e7ec984535db169f9c7971c"}, {"code": "#(let [m (empty %)]\n              (condp = m\n                {} :map\n                #{} :set\n                (if (= (conj m 1 2) [1 2])\n                   :vector\n                   :list)\n              ))", "problem": 65, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn classify-seq [c]\n  (let [t (conj c [:a :b] [1 2])]\n    (cond (contains? t [:a :b]) :set\n          (= (get t :a) :b) :map\n          (= (last t) [1 2]) :vector\n          :else :list)))", "problem": 65, "user": "4e7f51eb535db966e863cc3f"}, {"code": "#({\\{ :map \\[ :vector \\# :set} (first (str %)) :list)", "problem": 65, "user": "4e823ed7535db62dc21a62c7"}, {"code": "#(if (nil? (:z (conj % {:z 1})))\n  (if (= (+ 1 (count %)) (count (conj (conj % 7) 7)))\n      :set\n      (if (= 7 (first (conj (conj % 8) 7)))\n        :list\n        :vector))\n  :map)", "problem": 65, "user": "4e70a7c1535d5021c1a8963c"}, {"code": "#(cond\n  (= {} (empty %)) :map\n  (= #{1 2} (conj (empty %) 1 2 2 1)) :set\n  (zero? (first (conj (empty %) 1 0))) :list\n  :else :vector\n)", "problem": 65, "user": "4e720985535d5021c1a89655"}, {"code": "(fn [xs]\n  (let [t [:test 2]\n        aug (conj xs t t)]\n    (if (= (count aug) (+ (count xs) 2))\n      (cond (= (first (conj aug :test)) :test) :list\n            (= (last (conj aug :test)) :test) :vector\n            :else nil)\n      (cond (= (aug :test) 2) :map\n            (= (aug t) t) :set\n            :else nil))))", "problem": 65, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [e]\n (cond\n  (reversible? e) :vector\n  (associative? e) :map\n  (ifn? e) :set\n  :else :list))", "problem": 65, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn [ c ]\n   (let [ c1 (conj c [ :key :value ])\n          c2 (conj c1 [ :key :value ])\n          mark [ :entry :mark ]\n          c3 (conj c2 mark)]\n     (cond\n        (contains? c1 :key)       :map\n        (= (count c1) (count c2)) :set\n        (= (last c3)  mark)     :vector\n        (= (first c3) mark)     :list )))", "problem": 65, "user": "4e860e85535db62dc21a62f1"}, {"code": "#(let [e (empty %)]\n    (cond\n      (= e {})  :map\n      (= e #{}) :set\n      (= e '()) (if (reversible? %) :vector :list)))", "problem": 65, "user": "4e7e93f5535db169f9c7971a"}, {"code": "(fn [c]\n  (cond\n    (= (get (conj c [:a :b]) :a) :b) :map\n    (reversible? c) :vector\n    (= :a (:a (into c [:a]))) :set\n    (nil? (:a (into c [:a]))) :list))", "problem": 65, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "#(let [m (conj % {}) p (gensym)]\n    (cond\n     (= m %) :map\n     (contains? m {}) :set\n     ;;(associative? %) :vector\n     (= (last (conj m p)) p) :vector\n     :t :list))", "problem": 65, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn [coll]\n  (let [ec (empty coll)]\n    (cond\n      (= ec {})  :map\n      (= ec #{}) :set\n      (= ec '[]) (if (= (into ec [1 2]) [1 2]) :vector :list))))", "problem": 65, "user": "4e6a11ee535d8ccf87e9fe9f"}, {"code": "(fn seq-type [s]\n        (cond\n         (= (conj s [1 2]) (conj (conj (conj s [1 2]) [1 3]) [1 2]))\n         :map\n         (= (conj (conj s 1) 1) (conj s 1))\n         :set\n         (= (first (conj (conj s 1) 2)) 2)\n         :list\n         true\n         :vector))", "problem": 65, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [c]\r\n     (let [c (conj c [0 0])\r\n\t         f (first c)\r\n\t\t t (conj c [f f] [f f])]\r\n\t\t(if (= (+ 2 (count c))(count t))\r\n\t\t    (if (= f (first t)) :vector :list)\r\n\t\t    (if (some #(nil? %) (map #(t %) t)) :map\r\n\t\t\t:set))))", "problem": 65, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [x]\n  (let [y (conj x [:x 1] [:x 1] [:x 2])]\n    (cond\n      (= (+ 1 (count x)) (count y)) :map\n      (= (+ 2 (count x)) (count y)) :set\n      (= [:x 2] (first y)) :list\n      :else :vector)))", "problem": 65, "user": "4db016af838c48654951d9b9"}, {"code": "(fn [xs]\r\n  (cond (get (conj xs [:m :ap]) :m) :map\r\n        (= (inc (count xs)) (count (conj xs :s :s))) :set\r\n        (not= (first (conj xs :boo :yay)) :yay) :vector\r\n        (coll? xs) :list))", "problem": 65, "user": "4e8681b7535dae1a5effa438"}, {"code": "#(condp = (empty %) {} :map #{} :set () (if (associative? %) :vector :list))", "problem": 65, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "#({\\{ :map \\c :list \\# :set \\[ :vector} (first (str %)))", "problem": 65, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [coll]\r\n  (cond\r\n(and (associative? coll) (contains? (conj coll [:a 4]) :a)) :map\r\n(= (inc (count coll)) (count (conj coll 42 42))) :set\r\n(= (last (conj coll 42 45)) 45) :vector\r\n(= (first (conj coll 42 45)) 45) :list))", "problem": 65, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [c]\n  (cond\n   (= (set c) c) :set\n   (nil? (get (conj c [0 :a]) 0)) :list\n   (= :a (get (conj c [0 :a]) 0)) :map\n   true :vector))", "problem": 65, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn bbt[c]\n  (cond (= (count (conj c {1 2} {1 3}))\n           (+ 1 (count c))) :map\n           (= (count (conj c 1 1))\n              (+ 1 (count c))) :set\n              (= (first (conj c :r :p)) :p) :list\n              :else :vector))", "problem": 65, "user": "4e842ebb535db62dc21a62df"}, {"code": "#(or ({{} :map #{} :set} (empty %)) \n   ({1 :vector} (first (conj (empty %) 1 2)) :list))", "problem": 65, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn [c]\r\n    (cond (= false (ifn? c)) :list\r\n          (= (conj c c) c)  :map\r\n          (= (into #{} c) c) :set\r\n          :else :vector))", "problem": 65, "user": "4e821ca5535db62dc21a62c2"}, {"code": "#(cond\n  (not (ifn? %)) :list\n  (.startsWith (str %) \"[\") :vector\n  (.startsWith (str %) \"#\") :set\n  :else :map\n)", "problem": 65, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [coll]\n    (let [s (str (empty coll))]\n      (cond (= s \"{}\") :map\n            (= s \"[]\") :vector\n            (= s \"#{}\") :set\n            :else :list)))", "problem": 65, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [coll]\n  (cond (= (get (conj coll {:blah 7}) :blah) 7) :map\n        (= (conj coll 1) (conj coll 1 1)) :set\n        (= (cons 2 (cons 1 coll)) (conj coll 1 2)) :list\n        true :vector))", "problem": 65, "user": "4e951f44535dbda64a6f6b30"}, {"code": "(fn [c]\n  (let [tx (str (empty c))]\n    (condp = tx\n      \"#{}\" :set\n      \"[]\"  :vector\n      \"{}\"  :map\n      :list)))", "problem": 65, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "(fn class-test [coll]\r\n  (let [none (empty coll)]\r\n    (cond (= none {})  :map\r\n          (= none #{}) :set\r\n          (= none '())\r\n            (if (contains? (conj none :x) 0)\r\n              :vector\r\n              :list))))", "problem": 65, "user": "4dd7d040535d2dad7130b5d6"}, {"code": "(fn blackbox\r\n  [coll]\r\n\t(let [coll (conj coll [1 :xAaff])] ;make sure it's non empty\r\n\t\t(cond\r\n\t\t\t(= (conj coll [:xAaff :xAaff]) (concat coll [[:xAaff :xAaff]])) :vector\r\n\t\t\t(= (conj coll [:xAaff :xAaff]) (concat [[:xAaff :xAaff]] coll)) :list\r\n\t\t\t(= (count (conj coll [1 :xBaff])) (count coll)) :map\r\n\t\t\t:else :set)))", "problem": 65, "user": "4e8a0c82535d3e98b802328d"}, {"code": "#(condp = (first (str %)) \\[ :vector \\{ :map \\# :set :list)", "problem": 65, "user": "4e951ce5535dbda64a6f6b2e"}, {"code": "#(let [s (conj (empty %) [1 2] [1 2])] (cond (contains? s 0) :vector (contains? s 1) :map (= (count s) 1) :set :else :list))", "problem": 65, "user": "4e8516d0535db62dc21a62e8"}, {"code": "#((zipmap\n    (map str [{} #{} [] ()])\n    [:map :set :vector :list])\n  (str (empty %)))", "problem": 65, "user": "4e7dfab0535db169f9c796f9"}, {"code": "(fn [x]\n  (cond\n    (reversible? x) :vector\n    (associative? x) :map\n    (= \\# (first (str x))) :set\n    :else :list))", "problem": 65, "user": "4e9fd521535d7eef3080729a"}, {"code": "#(if (associative? %)\n   (if (reversible? %) :vector :map)\n   (or (:set (conj % :set)) :list))", "problem": 65, "user": "4ea0cfb0535d7eef308072ae"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4ea16981535d7eef308072b2"}, {"code": "#(if (= :bar (:foo (into % {:foo :bar})))\n        :map\n        (let [onetwo (conj (conj % 1) 2)\n                 twoone (conj (conj % 2) 1)]\n             (cond\n              (= onetwo twoone) :set\n              (= (take 2 onetwo) '(2 1)) :list\n              :else :vector)))", "problem": 65, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [a]\n  (if (= {} (empty a))\n    :map\n    (let [b (conj (conj (empty a) :xxx :xxx) :a)]\n      (if (= 2 (count b))\n        :set\n        (if (= :a (first b)) \n          :list \n          :vector)))))", "problem": 65, "user": "4e89ddf9535d3e98b8023284"}, {"code": "(fn [coll]\n  (let [first-char (first (pr-str coll))]\n    (cond (= first-char \\{) :map\n          (= first-char \\() :list\n          (= first-char \\[) :vector\n          (= first-char \\#) :set\n          :else (throw (Exception. \"Not a sequence\")))))", "problem": 65, "user": "4e4b4564535dc968683fc4d3"}, {"code": "#(let [coll (conj % [:a :b] [:c :d])]\n   (cond (and (contains? coll [:a :b]) (not (contains? coll :c))) :set\n         (contains? coll :a) :map\n         (= (last coll) [:c :d]) :vector\n         (= (first coll) [:c :d]) :list\n         :else :unknown))", "problem": 65, "user": "4ea09fa4535d7eef308072aa"}, {"code": "#(let [ch (first (.toString %))]\n  (if (= ch \\[)\n    :vector\n    (if (= ch \\()\n      :list\n      (if (= ch \\{)\n        :map\n        (if (= ch \\#)\n        :set\n        :list)))))", "problem": 65, "user": "4e8f4f64535d65386fec2149"}, {"code": "#(if (= :blarg2 (:blarg1 (conj % [:blarg1 :blarg2]))) \n    :map\n    (let [c2 (conj % :blarg1 :blarg2)]\n      (if (contains? c2 :blarg1)\n        :set \n        (if (= :blarg2 (first c2))\n          :list\n          :vector) )) )", "problem": 65, "user": "4e9b22e2535dbda64a6f6b74"}, {"code": "(fn f [x]\n  (let [y (conj x [1 2] [1 4] [1 4])]\n  (cond (= (+ 1 (count x)) (count y)) :map\n        (= (+ 2 (count x)) (count y)) :set\n        (= [1 4] (first y)) :list\n        :else :vector)))", "problem": 65, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn [x]\n  (letfn [(is-map [x] (= (count x) (count (merge x x))))\n          (is-set [x] (= (inc (count x)) (count (conj (conj x 99) 99))))\n          (is-list [x] (= 99 (first (conj (conj x 1) 99))))]\n         (cond (is-map x) :map\n               (is-set x) :set\n               (is-list x) :list\n               :else :vector)))", "problem": 65, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn [seq]\n  (let [empty-seq (empty seq)]\n    (cond\n      (= empty-seq {})  :map\n      (= empty-seq #{}) :set\n      (= (conj empty-seq 1 2) [1 2]) :vector\n      (= empty-seq ())  :list)))", "problem": 65, "user": "4ea4fe1f535d7eef308072cf"}, {"code": "(fn [seq]\r\n  (if (= (vec seq) seq)\r\n    (if (= :x (first (into seq [:y :x]))) :list :vector)\r\n    (if (= (set seq) seq) :set :map)))", "problem": 65, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn [c]\n  (let [v1 [::test1 1]\n        v2 [::test2 2]\n        d (conj c v1)]\n    (cond\n      (= (cons v2 (cons v1 c)) (conj d v2)) :list\n      (= (concat c [v1 v2]) (conj d v2)) :vector\n      (= (second v1) (d (first v1))) :map\n      (= d (conj d v1)) :set\n      )))", "problem": 65, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn [x]\n  (let [y (into x [[:a 1] [:a 2]])]\n    (cond\n      (= (:a y) 2) :map\n      (= (count y) (count (into y (list (last y))))) :set\n      (= (first y) [:a 2]) :list\n      :else :vector)))", "problem": 65, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "; Hack!\n  (fn [x]\n    (or (get {\\{ :map \\# :set \\[ :vector \\( :list} (first (str x)))\n        :list))", "problem": 65, "user": "4e89e939535d3e98b8023287"}, {"code": "#(if (reversible? %) :vector\n    (if (associative? %) :map\n      (if (= (count (conj % :mocky)) (count (conj % :mocky :mocky))) :set\n          :list)))", "problem": 65, "user": "4eb01df4535d7eef30807337"}, {"code": "#(cond\n  (let [l (conj % [:z 1])]\n    (= (:z l) 1)) :map\n  (let [l (conj % 1)]\n    (= (count (conj l (first l))) (count l))) :set\n  (let [l (conj % 1)]\n    (= (first (conj l 99)) 99)) :list\n  true :vector)", "problem": 65, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn bb [x]\n  (let [p (conj x [:z 1])]\n    (cond\n      (= (:z p) 1) :map\n      (= (count (conj p (first p))) (count p)) :set\n      (= (first (conj p 99)) 99) :list\n      true :vector\n    )\n  )\n)", "problem": 65, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "(fn [s]\n  (let [e (empty s)]\n    (cond\n      (= e {}) :map\n      (= e #{}) :set\n      (= (conj e 1 2) [1 2]) :vector\n      true :list)))", "problem": 65, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn [x]\n(let [ instanc? (fn  [^Class c x] (. c (isInstance x)))]\n  (cond (instanc? clojure.lang.IPersistentMap x)\n  :map\n\t(instanc? clojure.lang.IPersistentList x)\n\t:list\n\t(instanc? clojure.lang.IPersistentVector x)\n\t:vector\n\t(instanc? clojure.lang.IPersistentSet x)\n\t:set\n\t:else\n\t:list\n  )))", "problem": 65, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn bb[c]\r\n  (let [lv (= (into [] c) c)]\r\n    (if lv\r\n      (if (= (last (conj c \"hey \" \"ha!\")) \"ha!\")\r\n      :vector\r\n      :list)\r\n      (let [s (into #{} c)]\r\n      (if (= s c)\r\n      :set\r\n      :map)))))", "problem": 65, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "#(let [\n    x (conj % [2 2])\n    x11 (conj x [1 1])\n    x1111 (conj x11 [1 1])]\n  (if\n    (= x11 x1111)\n    (if (x11 [1 1]) :set :map)\n    (if (= [1 1] (first x11)) :list :vector) ))", "problem": 65, "user": "4eaf08ce535d7eef3080732d"}, {"code": "(fn black-box [t]\r\n  (if (associative? t)\r\n    (if (reversible? t) :vector :map)\r\n    (if (= (inc (count t)) (count (conj t '(:x) '(:x)))) :set :list)\r\n  )\r\n)", "problem": 65, "user": "4dd1de4d535dae65d5c462d7"}, {"code": "#(if (= {} (empty %)) \n   :map\n   ({#{1 2} :set [1 1 2] :vector} (conj (empty %) 1 1 2) :list))", "problem": 65, "user": "4e707db6535d5021c1a8963a"}, {"code": "(fn st [d]\n  (let [c (conj d [:c 3])]\n    (cond\n      (not (nil? (:c c))) :map\n      (= (count (conj c (first c))) (count c)) :set\n      (= (last (conj c 42)) 42) :vector\n      :else :list)))", "problem": 65, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "#({\\# :set\r\n   \\{ :map\r\n   \\[ :vector\r\n   \\( :list} (first (pr-str %)))", "problem": 65, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn [d]\n  (let [r (conj d [:y nil] [:z 42])]\n    (cond\n      (= 42 (:z r)) :map\n      (= [:z 42] (get r [:z 42])) :set\n      (= [:z 42] (first r)) :list\n      (= [:z 42] (last r)) :vector)))", "problem": 65, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(let [s (gensym),\n      t (gensym)]\n(fn [c]\n  (let [tt (conj c [t t]),\n        cc (conj tt [s s]),\n        ccc (conj cc [s s])]\n    (if (= (count cc) (count ccc))\n      (if (= (cc s) s) :map :set)\n      (if (= (first cc) [s s]) \n        :list :vector)))))", "problem": 65, "user": "4ec12577535dfed6da9c6da8"}, {"code": "#(let [x (first (str %1))] \n   (cond \n     (= x \\{) :map \n(= x \\#) :set \n(= x \\[) :vector \n(= x \\() :list\n (= x \\c) :list))", "problem": 65, "user": "4eabb245535d7eef30807319"}, {"code": "(fn my-type [coll]\n  (cond\n    (= (drop-last (conj coll [1 2] [3 4])) (conj coll [1 2])) :vector\n    (= (rest (conj coll [1 2] [3 4])) (conj coll [1 2])) :list\n    (contains? (conj coll [1 2]) [1 2]) :set\n    true :map))", "problem": 65, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "#(let [a (conj % [:x 1] [:y 2])]\n  (cond\n    (contains? a :x) :map,\n    (contains? a [:x 1]) :set,\n    (= (first a) [:y 2]) :list,\n    :else :vector\n  ))", "problem": 65, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn categorise [x]\n  (let [protostring (.toString (empty x))\n        eql? #(= protostring %)]\n    (if (eql? \"{}\")  :map\n    (if (eql? \"#{}\") :set\n    (if (eql? \"[]\")  :vector\n                     :list)))))", "problem": 65, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(fn what [s]\n  (if (= (merge s s) s) :map\n  (if (= (count (conj s 1)) (count (conj (conj s 1) 1))) :set\n  (if (= (last (conj (conj s :__fakeval__) :__otherfake__)) :__otherfake__) :vector\n  :list))))", "problem": 65, "user": "4ea0c284535d7eef308072ad"}, {"code": "#(let [coll (conj % [:z :w] [:a :b])]\n  (cond\n    (contains? coll :a) :map\n    (contains? coll [:a :b]) :set\n    (= (first coll) [:a :b]) :list\n    (= (last coll) [:a :b]) :vector))", "problem": 65, "user": "4ec2f192535dcc7ae8597d4c"}, {"code": "(fn [coll]\n  (cond\n    (reversible? coll) :vector\n    (associative? coll) :map\n    (ifn? coll) :set\n    :else :list))", "problem": 65, "user": "4eb1dd39535d7eef30807345"}, {"code": "#(let [s (.toString %)]\n\n  (cond (.contains s \"#\") :set\n\n        (.contains s \"{\") :map\n\n        (.contains s \"[\") :vector\n\n      :else :list\n\n))", "problem": 65, "user": "4ec3b393535dcc7ae8597d59"}, {"code": "(fn p65 [col]\n   (let [v (empty col)]\n     (if (get (conj v [:test :test1]) :test )\n       :map\n\n     (cond (= (count (conj v :testv :testv )) (count (conj v :testv :testv :testv :testv)) ) :set\n         (= (first (conj v :testv :testv1)) :testv1 ) :list\n         (= (last (conj  v :testv :testv1)) :testv1 ) :vector\n\n         :else :no)\n\n     ) )\n  )", "problem": 65, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [c]\n  (let [k1 (gensym)\n        v1 (gensym)\n        cp (conj c [k1 v1])]\n    (if (= v1 (get cp k1))\n      :map\n      (let [s (gensym)\n            cpp (conj cp s)]\n        (cond\n         (= s (first cpp)) :list\n         (= (count cpp) (count (conj cpp s))) :set\n         :else :vector)))))", "problem": 65, "user": "4daf8f84edd6309eace4d17a"}, {"code": "(fn [c]\n  (let [n {:a :b}\n        x (conj c n)\n        s (set x)]\n    (cond (contains? x n) :set\n          (and (= (first x) n) (identical? (seq x) x)) :list\n          (= (last x) n) :vector\n          :else :map)))", "problem": 65, "user": "4eae5fe4535d7eef30807325"}, {"code": "#(let [z [::test ::val]\n  x (conj % z)\ny (conj x [::foo ::bar])]\n(cond \n  (= (::test x) ::val) :map\n  (= (count x) (count (conj x z))) :set\n(= (first y) [::foo ::bar]) :list\n:else :vector))", "problem": 65, "user": "4db3a0e5535df7e46ed9b6d0"}, {"code": "(fn [coll]\n  (comment \n    (= () []) \n    (not (identical? (empty {:a 2}) {}))\n    \"not sure where this question is coming from, did the minimum\n    required for the tests to pass\")\n  (let [e (empty coll)]\n    (cond \n      (identical? e ()) :list\n      (= e []) :vector\n      (= e #{}) :set\n      (= e {}) :map\n      )))", "problem": 65, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [c] (let [t [:z :y] n (conj (conj c [:m :n]) t)] \n   (condp #(contains? %2 %) n\n     t :set\n     (first t) :map\n     (if (= (first n) t) :list :vector))))", "problem": 65, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn [v]\n    (let\n      [ x (rand-int 100) v (conj v [:x x]) ]\n        (if (associative? v)\n          (if\n            (get v :x) :map  :vector)\n          (if\n          (= (conj v [:x x]) v) :set :list)\n        )))", "problem": 65, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [coll]\n   (cond\n     (reversible? coll) :vector\n     (not (ifn? coll)) :list\n     (not (associative? coll)) :set\n     :default :map))", "problem": 65, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn [c]\n  (cond\n    (or (= {} c) (not-empty (flatten (first c)))) :map\n    (= (conj c :TEST :TEST) (conj c :TEST)) :set\n    (= (first (conj c :B :A)) :A) :list\n    (= (peek (conj c :B :A)) :A) :vector))", "problem": 65, "user": "4ecbb249535df97575fdabdf"}, {"code": "(fn [coll*]\n  (let [a [:a nil]\n        coll (-> (empty coll*) (conj a) (conj a))]\n    (if (associative? coll)\n      (if (nil? (coll 0))\n        :map\n        :vector)\n      (if (== 1 (count coll))\n        :set\n        :list))))", "problem": 65, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn foo [x] \n  (cond \n    (= (first(conj x {:foo true}) ) [:foo true] ) :map\n  \t(= (conj (conj x 1) 1 ) (conj x 1)) :set\t\t\n\t\t(= x (first (conj (conj x 1) x))) :list\n\t\t:else :vector\n\t)\n)", "problem": 65, "user": "4e8d5edd535d65386fec2134"}, {"code": "(fn [c]\n  (cond\n    (= (:d (conj c [:d :e])) :e) :map\n    (= (:d (conj c :d)) :d) :set\n    (= (last (into c [:d :e])) :e) :vector\n    :else :list))", "problem": 65, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn coll-type [coll]\n  (let [item [:x 1]\n        rslt (conj (conj coll [:y 2]) item)]\n    (cond\n      (contains? rslt item)      :set\n      (not (nil? (get rslt :x))) :map\n      (= (last  rslt) item)      :vector\n      (= (first rslt) item)      :list\n      :else                      :unknown)))", "problem": 65, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn [coll]\n  (cond\n   (and (associative? coll)\n        (reversible? coll))\n   :vector\n   \n   (and (associative? coll))\n   :map\n\n   (= #{} (empty coll))\n   :set\n   \n   (and (not (associative? coll))\n        (not (reversible? coll)))\n   :list))", "problem": 65, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "#( \n if(associative? %) \n  (if(reversible? %) :vector :map)\n  (if(contains? (conj % :a) :a) :set :list) \n)", "problem": 65, "user": "4ed845a8535d10e5ff6f52f8"}, {"code": "#(-> % str first {\\{ :map \\# :set \\[ :vector \\c :list})", "problem": 65, "user": "4e9a8c0e535dbda64a6f6b72"}, {"code": "(fn [x]\n  (if (ifn? x)\n    (if (associative? x)\n        (let [y (conj x [:a 1] [:a 2])]\n          (if (some #{[:a 1]} y)\n            :vector\n            :map))\n        :set)\n  :list))", "problem": 65, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [c]\n  (let [s [[1 1] [1 2] [1 3]]]\n  (cond\n    (= (count (into c s))\n       (count (into c [[1 3]])))\n    :map\n    (= (count (into c [1 1 1]))\n       (count (into c [1])))\n    :set\n    (= 999 (first (into c [1 999])))\n    :list\n    :else :vector)))", "problem": 65, "user": "4eda8d7c535d10e5ff6f530f"}, {"code": "(fn [sq]\n  (let [fst [:fst sq]\n        snd [:snd sq]\n        nsq (into sq [fst fst snd])]\n    (cond\n      (< (count nsq) (+ 3 (count sq)))\n        (if (nil? (nsq fst)) :map :set)\n      (= (first nsq) snd) :list\n      :else :vector)))", "problem": 65, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn detector [coll]\n  (cond\n    (= coll (set coll)) :set\n    (let [s (gensym)] (= s (get (conj coll [s s]) s))) :map\n    (let [s (gensym) s2 (gensym)] (= s (first (conj (conj coll s2) s)))) :list\n    (let [s (gensym) s2 (gensym)] (= s (last (conj (conj coll s2) s)))) :vector\n    ))", "problem": 65, "user": "4ec75077535d6d7199dd36e0"}, {"code": "#(let [s (conj (empty %) [9 9]) c contains?]\n  (cond \n    (c s 0) :vector\n    (c s 9) :map\n    (c s [9 9]) :set\n    1 :list))", "problem": 65, "user": "4ed69ea4535d10e5ff6f52e3"}, {"code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= {} empty-coll) :map\n      (= #{} empty-coll) :set\n      (= () empty-coll) (if (associative? coll) :vector :list))))", "problem": 65, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "#(let [x (empty %)]\n   (cond\n     (= '() x)\n        (if (= (conj (conj x 2) 1) '(1 2)) :list :vector)\n     (= x {}) :map\n     (= x #{}) :set))", "problem": 65, "user": "4eb955da535dfed6da9c6d50"}, {"code": "#(let [e (empty %)] \n      (cond (= #{} e) :set\n            (= {} e) :map\n            :else (if (= (first (conj (into e [1 2 3]) 2)) 2) \n                      :list \n                      :vector)))", "problem": 65, "user": "4ebb78a2535dfed6da9c6d70"}, {"code": "(fn type* [x]\n  (condp = (empty x)\n    {} :map\n    #{} :set\n    [] (if (associative? x) :vector :list)))", "problem": 65, "user": "4e5b192e535d8a8b8723a2b3"}, {"code": "(fn [x]\r\n  (if (empty? x)\r\n    (recur (into x [[1 2]]))\r\n    (let [d (into x x)]\r\n      (if (= d x)\r\n        (if (x (first x)) :set :map)\r\n        (if (= :z (last (conj x :z))) :vector :list)))))", "problem": 65, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "#(let [e (empty %)] \n      (cond (= #{} e) :set\n            (= {} e) :map\n            :else (if (= (first (conj (into e [1 2 3]) 2)) 2) \n                      :list \n                      :vector)))", "problem": 65, "user": "4ede8789535d10e5ff6f5337"}, {"code": "#(let [c (conj % [:a :b] [1 2])]\n  (cond\n    (contains? c [1 2]) :set\n    (= :b (:a c)) :map\n    (= [1 2] (first c)) :list\n    :else :vector))", "problem": 65, "user": "4ec16c21535dfed6da9c6dac"}, {"code": "(fn [coll]\n  (let [coll (empty coll)]\n    (cond\n      (= { 1 2 } (conj coll [1 2])) :map\n      (= (conj coll 1) (conj coll 1 1)) :set\n      (= (conj coll 1 2) [1 2]) :vector\n      :else :list)))", "problem": 65, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn\n  [col]\n    ; Convert the type to a string, check the first character to do a poor type check\n    ; Can't use built-in functions such as type, instance? etc..\n    (let [typestring (str col)]\n      (cond\n        (= 0 (.indexOf typestring \"{\")) :map                        ; Map string: \"{:a 1}\"\n        (.contains typestring \"clojure.lang.LazySeq\") :list         ; Lazy seq string \"clojure.lang.LazySeq..\"\n        (.contains typestring \"clojure.lang.PersistentList\") :list  ; List string \"()\"\n        (.contains typestring \"[\") :vector                          ; Vector string: \"[1 2 3]\"\n        (.contains typestring \"#\") :set                             ; Set string: \"#{0 10}\"\n        )))", "problem": 65, "user": "4eddc5f4535d10e5ff6f532c"}, {"code": "#(let [c1 (conj %  [:x :y])\n       c2 (conj c1 [:x :x])\n       c3 (conj c2 [:x :x])]\n  (cond\n    (= (count c1) (count c2)) :map\n    (= (count c2) (count c3)) :set\n    (= [:x :x] (first c3))    :list\n    :else :vector))", "problem": 65, "user": "4eb51942535d7eef30807365"}, {"code": "#(cond\n     (reversible? %) :vector\n     (associative? %) :map\n     (get (conj % :a) :a) :set\n     :else :list)", "problem": 65, "user": "4eb2eae5535d7eef30807351"}, {"code": "#(let [c1 (conj % [:foo 42])]\n   (if (= c1 (seq c1))\n     (let [c2 (conj c1 :bar)]\n       (if (= (first c2) :bar) :list :vector))\n     (if (:foo c1) :map :set)))", "problem": 65, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "#(let [s (.toString %)]\r\n  (cond (.contains s \"#\") :set\r\n    (.contains s \"{\") :map\r\n    (.contains s \"[\") :vector\r\n    :else :list))", "problem": 65, "user": "4e580746535d8a8b8723a28c"}, {"code": "#((zipmap (map str ['() [] {} #{}]) [:list :vector :map :set]) (str (empty %)))", "problem": 65, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (condp = base\n      {} :map\n      #{} :set\n      [] (if (reversible? base) :vector :list))))", "problem": 65, "user": "4ee88269535d93acb0a6687f"}, {"code": "#(cond\n   (reversible? %) :vector\n   (associative? %) :map\n   (= (count (conj % :x)) (count (conj % :x :x))) :set\n   1 :list)", "problem": 65, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [n] (let [x (conj n [100 100] [100 200] [100 200])]\n    (cond\n      (= 1 (- (count x) (count n))) :map\n      (= 2 (- (count x) (count n))) :set\n      (= [100 200] (first x)) :list\n      (= [100 200] (last x)) :vector\n    )\n  ))", "problem": 65, "user": "4eea1a41535d93acb0a66899"}, {"code": "#(cond (= :y (:x (conj % [:x :y]))) :map\n         (= (conj % 1) (conj % 1 1))  :set\n         (= 2 (last (conj % 1 2)))    :vector\n         :else                        :list)", "problem": 65, "user": "4ee88bfb535d93acb0a66881"}, {"code": "#(get {\\[ :vector, \\{ :map, \\# :set} (first (str %)) :list)", "problem": 65, "user": "4ee82223535d93acb0a66877"}, {"code": "#(let [ys (into (into (empty %) {:a 1}) {:a 2})]\n  (condp = ys\n    {:a 2} :map\n    [[:a 1] [:a 2]] :vector\n    [[:a 2] [:a 1]] :list\n    :set))", "problem": 65, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn [col] (cond\n                                            (not (ifn? col)) :list\n                                            (= col (set (reverse col))) :set \n                                            (= (count (conj col [1 1]))\n                                               (count (conj col [1 1] [1 1]))\n                                               ) :map \n                                            :else :vector))", "problem": 65, "user": "4ebef65e535dfed6da9c6d9b"}, {"code": "(fn class*\n  [coll]\n  (let [s (first (str coll))]\n    (cond\n     (= s \\[) :vector\n     (= s \\{) :map\n     (= s \\#) :set\n     :else    :list)))", "problem": 65, "user": "4dda44f2535d02782fcbe9f1"}, {"code": "#((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty %)))", "problem": 65, "user": "4ee01905535d10e5ff6f534c"}, {"code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "problem": 65, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [coll]\n  (if (ifn? coll)\n      (let [c (conj coll [0 100])]\n          (if (= (c 0) 100) \n              :map\n              (if (= (count c) (count (conj c [0 100])))\n                 :set :vector)))\n      :list))", "problem": 65, "user": "4e7d5eb8535db169f9c796d6"}, {"code": "(fn p65\n  [coll]\n    (cond\n      (= 0 (- (count coll) (count (conj coll {})))) :map\n      (= :x (get  (conj coll :x) (count coll))) :vector\n      (= :x (get (conj coll :x) :x)) :set\n      :else :list))", "problem": 65, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "#(let [e (empty %) k ({{} :map #{} :set} e)]\n    (if k k\n        (if (= (first (conj e 1 2)) 2) :list :vector)))", "problem": 65, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [in]\n    (cond\n     (get (into in [[:k :v]]) :k) :map\n     (get (into in [[:k :v]]) [:k :v]) :set\n     (let [ufirst (into in [:my_first_entry :my_second_entry])]\n       (= (first ufirst) :my_second_entry)) :list\n     :else :vector))", "problem": 65, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "#(cond\n  (not (ifn? %)) :list\n  (reversible? %) :vector\n  (associative? %) :map\n  :else :set\n)", "problem": 65, "user": "4ef2d243535dced4c769f221"}, {"code": "(fn [x]\n  (let [v (get {{} :map #{} :set [] :list} (empty x))]\n    (if (= v :list)\n      (if (= :xyz (first (conj x :abc :xyz))) :list :vector)\n      v)))", "problem": 65, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "#(cond\n   (= (conj % nil) %) :map \n   (= (conj % 0) (conj % 0 0)) :set\n   (= (conj % 0 1) (cons 1 (cons 0 %))) :list\n   :else :vector)", "problem": 65, "user": "4ef49c2c535dced4c769f238"}, {"code": "#(if (ifn? %)\n     (if (associative? %)\n          (cond \n            (= [] %) :vector \n            (= {} %) :map\n            :else (if (nil? (% (first %) ) ) :map :vector ) ) \n         :set)\n     :list)", "problem": 65, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [x]\n  (let\n    [allows-duplicates? (not (= (conj x [:a 1]) (conj x [:a 1] [:a 1])))]\n    (if allows-duplicates?\n      ; if it allows duplicates it must be a list or vector\n      (let\n        [conj-to-beginning? (and\n          (= (first (conj x 2 1)) 1)\n          (= (first (conj x 2 2)) 2))]\n        (if conj-to-beginning? :list :vector))\n      (let\n        [contains-added-item?\n          (= [:a 1] ((conj x [:a 1]) [:a 1]))]\n        (if contains-added-item? :set :map)))))", "problem": 65, "user": "4ef41f26535dced4c769f230"}, {"code": "(fn [x]\n  (let [poker1k `key#\n        poker2k `key#\n        pokerv `val#\n        pair1 [poker1k pokerv]\n        pair2 [poker2k pokerv]]\n  (cond\n    (contains? (conj x pair1) poker1k) :map\n    (= (conj x pair1) (conj x pair1 pair1)) :set\n    (= (first (conj x pair1 pair2)) pair2) :list\n    :else :vector)))", "problem": 65, "user": "4edecdae535d10e5ff6f533c"}, {"code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (ifn? %) :set\n  :else :list)", "problem": 65, "user": "4ef77c82535dced4c769f253"}, {"code": "(fn [a]\n  (let [gp (gensym)\n        g [gp 0]\n        g1 [gp 1]]\n    (cond\n     (= (conj a g) (conj (conj a g) g)) (if (= (count (conj a g))\n                                               (count (conj (conj a g) g1))) :map :set)\n     (= (first (conj (conj a g1) g)) g) :list\n     :else :vector)))", "problem": 65, "user": "4e773be8535d324fb2983d6e"}, {"code": "#(if (associative? %)\n  (if (reversible? %)\n    :vector\n    :map )\n  (if (= (into % [1 1]) (into % [1]))\n    :set\n    :list ))", "problem": 65, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn [x]\n          (cond (= (cons {1 1}(cons {0 0} x)) (conj x {0 0} {1 1})) :list\n                (not= (conj x {1 1}) (conj x {1 1}{1 1})) :vector\n                (= (empty x) {}) :map\n                \\t :set))", "problem": 65, "user": "4e599577535d8a8b8723a29f"}, {"code": "(fn typeof [aseq]\n  (let [conjoined (conj (conj aseq [:1 1]) [:2 2])]\n    (cond \n      (get conjoined :1) :map\n      (= (count conjoined) (count (conj conjoined [:1 1]))) :set\n      (= [:2 2] (first conjoined)) :list\n            :else :vector)))", "problem": 65, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "#(cond\n  (and (counted? %) (reversible? %)) :vector\n  (associative? %) :map\n  (= (conj % 1) (into % [1 1])) :set\n  (= (into % [1 2]) (cons 2 (cons 1 %))) :list)", "problem": 65, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "#(if (associative? %) \n  (if (reversible? %) :vector :map)\n  (if (= (into [] %) %) :list :set))", "problem": 65, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [coll]\n  ;; first insert something with a command that works on all coll types\n  (let [entry [:a 1]\n        c (into coll [entry])]\n    (cond\n     (contains? c entry) :set\n     (= entry (get c (count coll))) :vector\n     (= (second entry) ((first entry) c)) :map\n     :else :list\n     )\n    ))", "problem": 65, "user": "4efec33f535dcb61093f6a2a"}, {"code": "#(cond\n  (> (count (merge % {:foo 1 :bar 2})) (inc (count %))) :map\n  (= (count (conj % :foo :foo)) (inc (count %))) :set\n  (= :bar (first (conj % :foo :bar))) :list\n  (not= :bar (first (conj % :foo :bar))) :vector)", "problem": 65, "user": "4dbb1126535d1e037afb21b3"}, {"code": "(fn who-am-i [some-sequence]\n   (let [chr (first (str some-sequence))]\n     (cond\n       (= chr \\#) :set\n       (= chr \\() :list\n       (= chr \\c) :list\n       (= chr \\[) :vector\n       (= chr \\{) :map)))", "problem": 65, "user": "4ee9c8d0535d93acb0a66892"}, {"code": "#(if (ifn? %)\n        (if (= % (set %))\n            :set\n            (if (= % (vec %))\n                :vector\n                :map\n            )\n        )\n        :list\n)", "problem": 65, "user": "4e55b3dc535d8a8b8723a27f"}, {"code": "(fn [t]\n        (let [k (empty t)]\n          (cond\n           (= :b (:a (into k [[:a :b]]))) :map\n           (= [:b :a] (into k [:a :b])) :list\n           (= (conj k :a) (conj k :a :a)) :set\n           :else :vector)))", "problem": 65, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn dt [coll]\r\n  (let [ x (.substring (str coll) 0 1) ]\r\n\t\t(cond\r\n\t\t\t(= \"c\" x) :list\r\n\t\t\t(= \"[\" x) :vector\r\n\t\t\t(= \"{\" x) :map\r\n\t\t\t(= \"#\" x) :set\r\n\t\t\t(= \"\" x) :string\r\n\t\t\t(nil? x)  :nil\r\n\t\t\t:else :unknown))\r\n\t)", "problem": 65, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "#(let [c (empty %)]\n  (cond\n    (identical? c ()) :list\n    (= c []) :vector\n    (= c #{}) :set\n    :else :map))", "problem": 65, "user": "4f03857e535dcb61093f6b0d"}, {"code": "(fn [col]\n  (cond\n    (= (::my-test\n        (conj col [::my-test ::my-result])) \n     ::my-result)\n    :map\n    (= (count (conj col ::my-test)) \n       (count (conj col ::my-test ::my-test)))\n    :set\n    (= ::my-test (first (conj col ::rand ::randb ::randc ::my-test)))\n    :list\n    true :vector))", "problem": 65, "user": "4f039c67535dcb61093f6b3a"}, {"code": "#( {\\# :set\n    \\{ :map\n    \\[ :vector\n    \\c :list} (first (str %))\n)", "problem": 65, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [x]\n  (let [o (Object.)\n        c (count x)\n        c2 (count (conj x [o 1] [o 1] [o 2]))]\n    (condp = (- c2 c)\n      3 (if (= o (first (conj x 1 o)))\n          :list\n          :vector)\n      2 :set\n      1 :map)))", "problem": 65, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [coll] (condp = (empty coll) #{} :set (hash-map) :map [] (condp = (conj (empty coll) 1 2) [1 2] :vector [2 1] :list nil)))", "problem": 65, "user": "4effb663535dcb61093f6a2e"}, {"code": "#(cond\n  (get (conj % [:c 3]) :c) :map\n  (= (conj % 1) (conj % 1 1)) :set\n  (= [:one :two] (take 2 (conj % :two :one))) :list\n  (= [:one :two] (take 2 (reverse (conj % :two :one)))) :vector\n)", "problem": 65, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn coll-type [xs]\n  (let [x (first xs)]\n    (cond (= xs (set xs)) :set\n          (= xs (conj xs x)) :map\n          (reversible? xs) :vector\n          :else :list)))", "problem": 65, "user": "4ee82ce9535d93acb0a6687a"}, {"code": "#(cond\n         (= % (merge % %)) :map\n         (= (conj % 1) (-> % (conj 1) (conj 1))) :set\n         (= \\Z (-> % (conj \\A) (conj \\Z) (last))) :vector\n         1 :list)", "problem": 65, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [x]\n  (let [pk (first (str x))]\n    (cond\n      (= \\# pk) :set\n      (= \\{ pk) :map\n      (= \\[ pk) :vector\n      :default :list)))", "problem": 65, "user": "4ef4c1ff535dced4c769f23e"}, {"code": "(fn [a]\n  (if (ifn? a)\n    (if (= (conj a [:x :y])\n           (into a [[:x :y] [:x :y]]))\n      (if ((conj a [:a :b]) [:a :b])\n        :set\n        :map)\n      :vector)\n    :list))", "problem": 65, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn [c]\n    (let [c* (conj c [:f 1])]\n      (cond\n       (contains? c* :f)\n       :map\n       (= (count c) (dec (count (conj c :foo :foo))))\n       :set\n       :else\n       (if (= (first (conj c :foo :baz)) :baz)\n         :list\n         :vector))))", "problem": 65, "user": "4ed292ac535d44c135fd68d9"}, {"code": "#(cond\n  (associative? %) \n  (if (= (first (assoc % 0 'a)) 'a) :vector :map)\n  (< (count (conj (conj % 'a) 'a)) (+ 2 (count %)))\n  :set\n  :else :list)", "problem": 65, "user": "4f06dcad535dcb61093f6c16"}, {"code": "#(\n  (zipmap \n    (map str [{} #{} () []]) \n    [:map :set :list :vector]) \n  (str (empty %)))", "problem": 65, "user": "4ea84f48535d7eef308072f6"}, {"code": "#({\\c :list \\{ :map \\[ :vector \\# :set} (first (str %)))", "problem": 65, "user": "4f0b2028535d0136e6c222ff"}, {"code": "(fn [coll]\n  (cond\n    (= 42 (:what (conj coll [:what 42]))) :map\n    (= (count (conj coll 42)) (count (conj coll 42 42))) :set\n    (= 42 (last (conj coll 41 42))) :vector\n    :else :list))", "problem": 65, "user": "4db87b3f535d1e037afb2196"}, {"code": "(fn __ [l]\n(cond \n (= (reduce #(conj %1 %2) #{} l) l) :set\n (= (conj l [:a 1]) (conj (conj  l [:a 1]) [:a 1])) :map\n (and (= (last (conj l 1)) 1)  (= (last (conj (conj l 1) 2)) 2)) :vector\n  :else :list))", "problem": 65, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn my-ident [x]\r\n    (cond\r\n     (= (conj x {}) x) :map\r\n     (= (conj (conj x \"mytest\") \"mytest\") (conj x \"mytest\")) :set\r\n     (= (last (conj (conj x \"mytest1\") \"mytest2\")) \"mytest2\") :vector\r\n     (= (first (conj (conj x \"mytest1\") \"mytest2\")) \"mytest2\") :list\r\n     ))", "problem": 65, "user": "4f039524535dcb61093f6b2c"}, {"code": "#({\\{ :map \\# :set \\[ :vector} (-> % str first) :list)", "problem": 65, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn [q]\n  (cond\n    (reversible? q) :vector\n    (associative? q) :map\n    (nil? (get (conj q 0) 0)) :list\n    :else :set))", "problem": 65, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn wat? [x]\n  (if (= (conj x x) x)\n     :map\n     (let [z (conj x :z)\n           sj (conj z z)]\n     (cond\n    (= (conj sj z) sj) :set\n    (= (first sj) z) :list\n    (= (last sj) z) :vector))))", "problem": 65, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn [t]\n  (if (= (vec t) t)\n    (if (= :blah (first (conj (conj t :blahblah) :blah)))\n      :list\n      :vector)\n    (if ((conj t [:blah1 :blah2]) :blah1)\n      :map\n      :set)))", "problem": 65, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn bb [s]\n  (let [s (if (empty? s)\n            (conj s [:TESTING :TESTING])\n            s)]\n    (cond (= (get s (first s)) (first s)) :set\n          (= (cons [:TEST :TEST] s) (conj s [:TEST :TEST])) :list\n          (= (conj s (first s)) s) :map\n          :else :vector)))", "problem": 65, "user": "4f0ef874535d0136e6c22328"}, {"code": "(fn prob-0065\n  [in-xs]\n  (let [emp (empty in-xs)]\n    (cond\n     (contains? (into emp {1 2}) 1)    :map\n     (contains? (into emp [3]  ) 0)    :vector\n     (= (conj emp 1 2) (conj emp 2 1)) :set\n     :else                             :list)))", "problem": 65, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n           (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "problem": 65, "user": "4f124e79535d64f603146427"}, {"code": "#(let [base (empty %)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? %) :vector :list)))", "problem": 65, "user": "4e8239d6535db62dc21a62c4"}, {"code": "(fn [x]\n  (if (:a (conj x [:a :b]))\n     :map\n  (let [x1 (conj x 1) \n        x2 (conj x1 1)]\n     (if (= (count x1) (count x2))\n      :set\n      (if (= 2 (-> x (conj 1) (conj 2) (first)))\n        :list\n        :vector)))))", "problem": 65, "user": "4f03154a535dcb61093f6a58"}, {"code": "#(cond (not (nil? (:x (into % {:x 9})))) :map \n       (= (into % [1]) (into % [1 1])) :set\n       (= :y (first (conj % :x :y))) :list\n       :else :vector)", "problem": 65, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn type-test  [s]\n  (let [x :test y 1230 p [x y] q [y x] -s (conj (conj s p) q)]\n    (cond\n     (contains? -s x) :map\n     (contains? -s p) :set\n     (= q (last -s)) :vector\n     :else :list)))", "problem": 65, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [coll]\r\n  (let [base (empty coll)]\r\n    (cond\r\n      (= base {})  :map\r\n      (= base #{}) :set\r\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4f16d3fd535d64f60314644e"}, {"code": "(fn [seq] \n  (let [s (first (str seq))] \n  (cond \n    (= s \\{) :map\n    (= s \\c) :list\n    (= s \\[) :vector\n    (= s \\#) :set)))", "problem": 65, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn seq-type [coll]                                                                                                                          \r\n    (let [o (Object.)                                                                                                                         \r\n          o2 (Object.)                                                                                                                        \r\n          not-found (Object.)                                                                                                                 \r\n          coll2 (conj coll [o o] [o o] [o2 o2])]                                                                                              \r\n      (cond                                                                                                                                   \r\n       (= 1 (count (filter (partial = [o o]) coll2))) (if (identical? not-found (get coll2 o not-found)) :set :map)                           \r\n       (= [o2 o2] (first coll2)) :list                                                                                                        \r\n       (= [o2 o2] (last coll2)) :vector                                                                                                       \r\n       :else :unknown)))", "problem": 65, "user": "4f149e0f535d64f60314643d"}, {"code": "(fn [x]\n    (let [map-test (fn [x] (let [m (conj x (hash-map :c 3))]\n\t\t        (if (= 3 (get m :c)) true false)))\n\t       list-test (fn [x] (let [l1 (into x [1 2 3]) l2 (conj l1 4)]\n\t\t\t (if (= 4 (first l2)) true false)))\n\t       set-test (fn [x] (let [x (conj x 100) y (conj x (first x))]\n\t\t\t  (if (= (count x) (count y)) :set :vector)))]\n\t\t\t  (cond\n\t\t\t    (map-test x) :map\n\t\t\t    (list-test x) :list\n\t\t\t    :else (set-test x))))", "problem": 65, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn [coll] (let [s (pr-str (empty coll))]\r\n              (cond (= \"()\" s) :list\r\n                    (= \"[]\" s) :vector\r\n                    (= \"{}\" s) :map\r\n                    :else :set)))", "problem": 65, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [s]\n  (let [x :a\n        y :b]\n    (cond\n     (= (x (conj s [x y])) y) :map\n     (= (conj s x x) (conj s x)) :set\n     (= (last (conj s x y)) y) :vector\n     :else :list)))", "problem": 65, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [x]\n  (let [gs1 (gensym)\n        gs2 (gensym)]\n    (if (= 0 (count (flatten (conj x [gs1 gs2]))))\n      (if (nil? (get (conj x [gs1 gs2]) gs1))\n        :set\n        :map)\n      (if (= gs2 (first (conj (conj x gs1) gs2)))\n        :list\n        :vector))))", "problem": 65, "user": "4ec5cdb0535d6d7199dd36b8"}, {"code": "(fn bb [n]\n    (if (= n (into [] n))\n        (if (= (first (conj n :q1 :q2 )) :q2 )\n            :list :vector )\n        (if (= n (into #{} n))\n            :set :map )))", "problem": 65, "user": "4f128865535d64f603146428"}, {"code": "#(cond (and (associative? %)(reversible? %)) :vector\r\n       (and (associative? %)(not (reversible? %))) :map\r\n       (and (not (associative? %))(apply distinct? (into % '(1 1)))) :set\r\n       (and (not (associative? %))(not(apply distinct? (into  % '(1 1))))) :list)", "problem": 65, "user": "4ed2dd98535d44c135fd68e2"}, {"code": "(fn [c]\n  (cond\n    (= #{} (empty c)) :set\n    (= {} (empty c)) :map\n    (= (cons :y (cons :x c)) (conj c :x :y)) :list\n    true :vector))", "problem": 65, "user": "4f1b0ab3535d64f603146474"}, {"code": "#(if\n  (and (associative? %) (< 1 (count (flatten (list (last (seq (assoc % 0 1))))))) ) :map\n  (let [c (conj % :a :b :c)]\n    (cond \n      (= (take-last 3 c) [:a :b :c]) :vector\n      (= (take      3 c) [:c :b :a]) :list\n      true :set)))", "problem": 65, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [coll]\r\n  (let [f (first (str coll))]\r\n    (cond\r\n     (= f \\{) :map\r\n     (= f \\#) :set\r\n     (= f \\c) :list\r\n     (= f \\[) :vector)))", "problem": 65, "user": "4ee9d697535d93acb0a66895"}, {"code": "(fn coll-test [coll]\n  (cond\n    (= (get (conj coll {:k :v}) :k) :v) :map\n    (= (conj (conj coll 1) 1) (conj coll 1)) :set\n    (= (cons 1 (cons 2 coll)) (conj coll 2 1)) :list\n    :else :vector\n    )\n  )", "problem": 65, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn [i] (if (associative? i) (if (reversible? i) :vector :map) (if (contains? (conj i 1) 1) :set :list)))", "problem": 65, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [s]\n  (cond (= {} s) :map\n        (identical? '() s) :list\n        (identical? [] s) :vector\n        (identical? #{} s) :set\n        (not (integer? (first s))) :map\n        (= :a (first (conj s :a))) :list\n        (= :a (last (conj s :a))) :vector\n        :else :set))", "problem": 65, "user": "4f04f847535dcb61093f6beb"}, {"code": "(fn [c]\n  (if (= (:key (conj c [:key :value])) :value)\n    :map\n    (if (true? (contains? (conj c :key) :key))\n      :set\n      (if (= (first (conj (conj c 1) 2)) 2)\n        :list\n        :vector))))", "problem": 65, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn [x] \n  (let [base (empty x)] \n    (cond \n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? x) :vector :list))))", "problem": 65, "user": "4f246938e4b0d66497709fec"}, {"code": "#(let [n (conj % [:c 2] [:d 4])]\n  (if (= 2 (:c n)) :map\n    (if (= [:c 2] (get n [:c 2])) :set\n      (if (= [:d 4] (first n)) :list\n        :vector))))", "problem": 65, "user": "4ede361a535d10e5ff6f5332"}, {"code": "(fn bb [coll]\n  (let [v [:bb-1 :bb-2]\n        c (conj coll v)]\n    (cond\n      (= :bb-2 (get c :bb-1)) :map\n      (= v (get c v)) :set\n      (= :bb-last (last (conj c :bb-last))) :vector\n      (= :bb-first (first (conj c :bb-first))) :list)))", "problem": 65, "user": "4f1c2a3a535d64f603146480"}, {"code": "(fn [x]\n  (let [z (into x [[x 1] [x x] [x 1] [x x]])]\n    ({1 :map 2 :set 4 (if (= [x x] (first z)) :list :vector)}\n      (- (count z) (count x)))))", "problem": 65, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [coll] \n  (let [nval (conj coll [1 2] [1 3] [1 3])] \n    (if (contains? nval [1 2]) \n      :set \n      (if (= 3 (get nval 1)) \n        :map \n        (if (= [1 3] (first nval)) \n          :list \n          :vector)))))", "problem": 65, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn bbtest [item]\n    (let [sitem (pr-str item)]\n        (cond\n            (.startsWith sitem \"{\") :map\n            (.startsWith sitem \"(\") :list\n            (.startsWith sitem \"[\") :vector\n            (.startsWith sitem \"#{\") :set\n        )))", "problem": 65, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [coll]\n   (let [new (conj coll {:--xx :b} {:--xx :b} {:--cc :d})]\n     (if (= (count new) (+ (count coll) 2))\n       (if (:--xx new) :map :set)\n       (if (= (take 2 new) '({:--cc :d} {:--xx :b})) :list :vector))))", "problem": 65, "user": "4eb02674535d7eef30807338"}, {"code": "(fn [s]\n  (let [n (conj s [:a :b])\n        n2 (conj n [:a :b] [:a :b] [:c :d]) ]\n    (cond (= (:a n) :b)                  :map\n          (= (count n2) (+ 1 (count n))) :set\n          (= [:c :d] (first n2))         :list\n          :default                       :vector)))", "problem": 65, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "(fn my-type [x]\n  (let [x1 (conj x [2 3] [2 4] [2 4])]\n    (cond\n      (= 1 (- (count x1) (count x))) :map\n      (= 2 (- (count x1) (count x))) :set\n      (= [2 4] (first x1)) :list\n      :else :vector)))", "problem": 65, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn [s] \n  (cond\n    (= 1 (:c (conj s [:c 1]))) :map\n    (= (+ (count s) 2) (count (conj s :c :c :d))) :set\n    (= :d (first (conj s :c :d))) :list\n    :else :vector))", "problem": 65, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn [x]\n  (let [sym (gensym) sym2 (gensym)]\n    (cond\n     (contains? (conj x [sym sym]) sym) :map\n     (= 1 (count (filter #(= sym %) (conj (conj x sym) sym)))) :set\n     (= sym (first (conj (conj x sym2) sym))) :list\n     :else :vector)))", "problem": 65, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [coll] \n  (let [newcoll (conj coll [:a :b] [:a :b] [:a :c])]\n    (if (= (count newcoll) (+ 3 (count coll)))\n      (if (= (first newcoll) [:a :c]) :list :vector)\n      (if (newcoll :a) :map :set))))", "problem": 65, "user": "4f294c48e4b0d6649770a023"}, {"code": "(fn [s]\n          (let [e (empty s)]\n            (if (identical? '() e)\n              :list\n              ({#{} :set, {} :map, [] :vector} e))))", "problem": 65, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "#(cond\r\n    (= (get (conj % [1 :a]) 1) :a) :map\r\n    (= (first (conj (conj % :a) :b)) :b) :list\r\n    (= (conj % :a) (conj (conj % :a) :a)) :set\r\n    :else :vector\r\n    )", "problem": 65, "user": "4f29cdc8e4b0d6649770a033"}, {"code": "(fn blackbox [s]\r\n  (cond\r\n    (= (conj s {}) s) :map \r\n    (empty? s) (cond\r\n                 (= (clojure.set/union s #{}) #{}) :set\r\n           (= (conj (conj s 0) 1) [0 1]) :vector\r\n\t         :else :list)\r\n    (= (clojure.set/union s s) s) :set\r\n    (= (first (conj s s)) s) :list\r\n    :else :vector))", "problem": 65, "user": "4f0f01c0535d0136e6c22329"}, {"code": "#(if (= (count (conj % [1 1])) (count (conj % [1 1] [1 2]))) :map\r\n                (if (= (count (conj % [1 1])) (count (conj % [1 1] [1 1]))) :set\r\n                  (if (reversible? %) :vector :list)))", "problem": 65, "user": "4f048f67535dcb61093f6bd3"}, {"code": "(fn [coll]\n  (let [o (conj coll [:a :b])] \n  (if (= (seq o) o)\n    (if (= (conj o :a) (cons :a o))\n      :list\n      :vector)\n    (if (o (first o))\n      :set\n      :map))))", "problem": 65, "user": "4f26d6d9e4b0d6649770a007"}, {"code": "#(cond \n    (= (into % {:k :v}) (conj % {:k :v})) :map\n    (= (conj (conj % :x) :y) (cons :y (cons :x %))) :list\n    (= (conj % :x) (seq (conj % :x))) :vector\n    :else :set)", "problem": 65, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn coll-type [coll]\r\n  (let [is-map?  (fn [x] (not (nil? (:a (conj x [:a :b])))))\r\n        is-set?  (fn [x] (= (+ 1 (count x)) (count (conj x :a :a))))\r\n        is-list? (fn [x] (let [k1 (Object.)\r\n                               k2 (Object.)\r\n                               c1 (conj coll k1)\r\n                               c2 (conj c1 k2)]\r\n                           (= k2 (first c2))))]\r\n    (cond (is-map?  coll) :map\r\n          (is-set?  coll) :set\r\n          (is-list? coll) :list\r\n          :else           :vector)))", "problem": 65, "user": "4daf36c2edd6309eace4d175"}, {"code": "(fn mytypeof [coll]\n  (cond\n    (= (empty coll) {}) :map\n    (= (conj (conj coll 42) 42) (conj coll 42)) :set\n    (= (rest (conj (conj coll 42) 41)) (conj coll 42)) :list\n    (= (conj coll 42) (concat coll [42])) :vector ))", "problem": 65, "user": "4f2965ffe4b0d6649770a029"}, {"code": "(fn [coll]\n  (let [bos (empty coll)]\n       (cond (= bos {}) :map\n             (= bos #{}) :set\n             :else (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4f13047d535d64f60314642c"}, {"code": "(fn [coll]\n   (let [x (conj coll {:key :val})]\n     (if (= (get x :key) :val)\n       :map\n       (if (= (get x {:key :val}) {:key :val})\n         :set\n         (if (= (first (conj x :xxx)) :xxx)\n           :list\n           :vector\n         )))\n   ))", "problem": 65, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn [sq]\n  (let [a (into sq [[-1 666]])]\n    (if (= (get a -1) 666) :map\n            (if (= (conj sq 1) (conj sq 1 1)) :set\n                (if (= (first (conj sq 1 :test)) :test) :list :vector)))))", "problem": 65, "user": "4e7d1c22535db169f9c796c5"}, {"code": "#(let\n  [t [1 2]\n    r (conj (empty %) t t [1 3])\n    s (count r)]\n  (cond\n    (= 1 s) :map\n    (= 2 s) :set\n    (= t (first r)) :vector\n    :else :list))", "problem": 65, "user": "4f39f902e4b0e243712b1efe"}, {"code": "(fn [coll]\n     (if (associative? coll)\n       (if (reversible? coll)\n         :vector\n         :map)\n       (if (= ((comp count #(conj % 1) #(conj % 1)) coll) ((comp inc count) coll))\n         :set\n         :list)))", "problem": 65, "user": "4f359c7ee4b0e243712b1ec4"}, {"code": "(fn [x]\n  (let [e (str (empty x))\n        typemap {(str '()) :list,\n                 (str [])  :vector,\n                 (str {})  :map,\n                 (str #{}) :set}]\n    (get typemap e nil)))", "problem": 65, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn [x] \r\n    (let [a (conj (conj x [::a ::a]) [::b ::b])\r\n         b (conj (conj x [::a ::a]) [::a ::a])\r\n         c (conj (conj x [::a ::a]) [::a ::b])]\r\n         (cond \r\n           (= (dec (count c)) (count x)) :map\r\n           (= (dec (count b)) (count x)) :set\r\n           (= (last a) [::b ::b]) :vector\r\n           (= (first a) [::b ::b]) :list)))", "problem": 65, "user": "4eecdd66535d93acb0a668b9"}, {"code": "(fn [c]\n  (if (reversible? c) :vector \n  (if (associative? c)\n    :map\n    (if (= (conj c 1 2) (conj c 2 1)) :set :list)\n  ))\n)", "problem": 65, "user": "4f1595da535d64f603146444"}, {"code": "(fn [arg]\n  (if (associative? arg)\n    (if (reversible? arg) :vector :map)\n    (if (= 2 (- (count (conj (conj arg 1) 1)) (count arg))) :list :set)))", "problem": 65, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [col] (letfn[\n  \n           (_map? [coll]\n             (= (:testkey (conj coll [:testkey :testval])):testval))\n\n           ( _set? [coll]\n            (contains? (conj coll :testkey?) :testkey?))\n\n           (_vector? [coll]                 \n                (= (last (conj coll :testval1 :testval2)) :testval2))\n\n           (_list? [coll]\n             (= (first (conj coll :testval)) :testval))\n\n\n          ]\n          \n          \n           (if\n            (_map? col) :map\n           (if\n            (_set? col) :set\n           (if\n            (_vector? col) :vector\n           (if\n            (_list? col) :list nil\n          ))))\n))", "problem": 65, "user": "4f2aff4de4b0d6649770a044"}, {"code": "(fn [x]\n  (letfn [(list-or-set\n            [x]\n            (let [s (conj (conj x 1) 1)]\n              (if (>= (- (count s) (count x)) 2)\n                :list\n                :set)))]\n    (if (associative? x)\n      (if (reversible? x) :vector :map)\n      (list-or-set x))))", "problem": 65, "user": "4f1bee08535d64f60314647e"}, {"code": "(fn [s]\n   (cond\n    (contains? (conj s [-1 -1]) -1) :map\n    (not (contains? (conj s 0) 0)) :list\n    (contains? (conj s 99999) 99999) :set\n    :else :vector))", "problem": 65, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [s]\n  (cond\n    (= :b (get (conj s {:a :b}) :a)) :map\n    (= (conj s 1) (conj s 1 1)) :set\n    (= :b (first (conj s :a :b))) :list\n    (= :b (last (conj s :a :b))) :vector\n  ))", "problem": 65, "user": "4f3e5e87e4b0e243712b1f83"}, {"code": "(fn [c]\n          (cond\n            (reversible? c) :vector\n            (associative? c) :map\n            (or (= c '()) (= c (seq c))) :list\n            :default :set))", "problem": 65, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [l]\n  (let [a (gensym) b (gensym) x (gensym)\n        m (conj (conj l [b x]) [a x])]\n    (cond\n      (= (get m [a x]) [a x]) :set\n      (= (get m a) x) :map\n      (= (last m) [a x]) :vector\n      (= (first m) [a x]) :list)))", "problem": 65, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [coll]\n  (cond (= :hint (get (conj coll [:empty :hint]) :empty)) :map\n        (= (inc (count coll)) (count (conj coll :hint :hint))) :set\n        (= :hint (first (conj coll :empty :hint))) :list\n        (= :hint (last (conj coll :empty :hint))) :vector\n        :else :other))", "problem": 65, "user": "4f4ba29ae4b03ad3f0c10c7a"}, {"code": "(fn [i]\n  (if (= :mark (:mark (conj i [:mark :mark])))\n    :map\n    (let [j (conj i :mark)\n          k (conj j :end)]\n      (cond\n        (= (count j) (count (conj j :mark))) :set\n        (= (first k) :end) :list\n        (= (last k) :end) :vector))))", "problem": 65, "user": "4de165f3535d08e6dec9fde6"}, {"code": "(fn [x]\n    (cond\n      (= :val (get (conj x [0 :val]) 0)) :map\n      (= (conj x :dummy) (conj (conj x :dummy) :dummy)) :set\n      (= :dummy2 (last (conj x :dummy1 :dummy2))) :vector\n      (= :dummy2 (first (conj x :dummy1 :dummy2))) :list))", "problem": 65, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn [xs] \n  (let [a (conj xs [:b 2] [1 1])\n        b (conj xs [1 1] [:b 2])]\n    (cond\n      (contains? a :b)   :map\n      (= a b)            :set\n      (not= (first a) [1 1]) :vector\n      :else              :list)\n  ))", "problem": 65, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [coll]       \n  (let [emp (empty coll)]\n    (if (= emp {})  :map\n      (if (= emp #{}) :set\n        (let [ls (conj coll :a)]\n           (if (= (first (conj ls :b)) :b)\n              :list\n              :vector)\n)))))", "problem": 65, "user": "4f1d1299535d64f603146487"}, {"code": "(fn type_ [coll]\n  (cond\n    (empty? (flatten (conj coll [:c :b])))\n      (cond\n        ((conj coll [:c :b]) [:c :b]) :set\n        :else :map)\n    :else\n      (cond\n        (= (cons :a (cons :b coll)) (conj (conj coll :b) :a)) :list\n        :else :vector)))", "problem": 65, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "#(let [x (first (str %1))] (cond (= x \\{) :map (= x \\[) :vector (= x \\#) :set :else :list))", "problem": 65, "user": "4f4f0287e4b03ad3f0c10cd7"}, {"code": "#(cond\r\n      (= (:k (conj % [:k :v])) :v) :map\r\n      (= (count (conj % :v)) (count (conj % :v :v))) :set\r\n      (= (first (conj % :v1 :v2)) :v2) :list\r\n      :else :vector\r\n      )", "problem": 65, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn [i]\n  (cond\n    (= :y (:x (conj i [:x :y]))) :map\n    (contains? (conj i [:x :y]) [:x :y]) :set\n    (= :y (first (conj (conj i :x) :y))) :list\n    (= :y (last (conj (conj i :x) :y))) :vector\n    true :fucked\n  ))", "problem": 65, "user": "4f569218e4b0a7574ea71826"}, {"code": "#({#{} :set {} :map} (empty %)\n  (if (contains? (into % [[0 0]]) 0) :vector :list))", "problem": 65, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn [x]\n  (let [s (conj x {:k :v} {:k :v})]\n    (cond (= s (conj x {:k :v})) (if (= (s :k) :v) :map :set)\n          (= (conj x 1 2) (cons 2 (cons 1 x))) :list\n          :else :vector)))", "problem": 65, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn [s]\n  (let [s (empty s)]\n    (cond\n      (=\n        :bar\n        (get\n          (conj s [:foo :bar])\n          :foo))\n        :map,\n      (=\n        1\n        (count\n          (apply conj\n            s\n            [:foo :foo])))\n        :set,\n      (=\n        (apply conj s [:bar :foo])\n        (list :foo :bar))\n        :list,\n      :else\n        :vector)))", "problem": 65, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn [x]\n    (cond\n     (contains? (conj x [:grok1 9999]) [:grok1 9999]) :set\n     (= (last (conj x [:grok1 9999] [:grok2 9999])) [:grok2 9999]) :vector\n     (and (= (first (conj  x [:grok1 9999] [:grok2 9999])) [:grok2 9999])\n          (not (contains? (conj  x [:grok1 9999]) :grok1))) :list\n     true :map\n     ))", "problem": 65, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn f [s] (cond \n              (= (conj s s) s)\n                  :map\n              (not= s (reverse (reverse s)))\n                  :set\n              (= (first (conj (conj s s) [s])) [s])\n                  :list                \n              (= (last (conj (conj s s) [s])) [s])\n                  :vector\n              :else :unknown))", "problem": 65, "user": "4f404dcee4b0e243712b1fb0"}, {"code": "(fn [coll]\n  (condp #(contains? %2 %) (conj (empty coll) '[a b])\n    0 :vector, 'a :map, '[a b] :set, :list))", "problem": 65, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn f[o]\n   (cond (= 1 (:test (conj o [:test 1]))) :map\n         (= (inc(count o)) (count (conj o :x :x))) :set\n         (= :x2 (first (conj o :x1 :x2))) :list\n          :else :vector))", "problem": 65, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "#(condp = (first (str (empty %)))\n   \\{ :map\n   \\# :set\n   \\[ :vector\n   \\c :list)", "problem": 65, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [x] \n  (cond \n    (reversible? x) :vector\n    (and \n      (not (reversible? x))\n      (associative? x))\n        :map\n    (empty? \n      (clojure.set/difference \n        (conj x 1) \n        (conj x x 1))) :set\n    (and \n      (not (reversible? x))\n      (not (associative? x)))\n        :list\n    ))", "problem": 65, "user": "4e7cf07f535db169f9c796c2"}, {"code": "(fn [s1]\r\n  (let [s2 (conj s1 [::tt 1] [::tt 1])]\r\n    (cond (not (= (count s2) (+ 2 (count s1))))\r\n            (if (= 1 (s2 ::tt))\r\n              :map :set)\r\n          (= (count s1) 0)\r\n            (if (= (first (conj s2 2)) 2) :list :vector)\r\n          (= [::tt 1] (first s2))\r\n            :list\r\n          (= [::tt 1] (last s2))\r\n            :vector\r\n          true\r\n            :other)))", "problem": 65, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [x]\n  (let [xx (conj (conj x [:q 1]) [:r 2])]\n    (cond\n      (= (get xx :q) 1) :map\n      (= (concat x [[:q 1] [:r 2]]) xx) :vector\n      (= (concat [[:r 2] [:q 1]] x) xx) :list\n      true :set)))", "problem": 65, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "#(let [\n  a [1 2]\n  t (conj % [1 1] [1 2] a)\n  d (- (count t) (count %))]\n  (cond\n    (<= d 1) :map\n    (<= d 2) :set\n    (= (last t) a) :vector\n    :else :list))", "problem": 65, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "(fn [x]\n  (let [t1 (conj x [:d 0] [:c 1])]\n    (cond\n      (get t1 :c) :map\n      (= t1 (conj t1 [:c 1])) :set\n      (= (first t1) [:c 1]) :list\n      true :vector)))", "problem": 65, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "#({\\# :set \\{ :map \\[ :vector \\c :list} (nth (str %) 0))", "problem": 65, "user": "4f71ba6ee4b07046d9f4f012"}, {"code": "(fn [coll]\n  (let [conj-coll (conj coll [:abc :cba])\n        order-coll (conj (conj coll [:abc :t]) [:cba :t])]\n    (condp = true \n      (contains? conj-coll :abc) :map\n      (contains? conj-coll [:abc :cba]) :set\n      (= [:cba :t] (last order-coll)) :vector\n      :list)))", "problem": 65, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn testVal[col]\r\n   (let [cnt (count col),\r\n         newCol (conj (conj (conj col {100 1} ) {100 2} ) {100 2} ),\r\n         cnt2 (count newCol),\r\n         sign (- cnt2 cnt)]\r\n        (cond (= sign 1) (keyword \"map\" )\r\n              (= sign 2) (keyword \"set\" )\r\n              (= (first newCol) {100 2}) (keyword \"list\")\r\n              :else (keyword \"vector\")\r\n              )                         \r\n    )\r\n )", "problem": 65, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "#(let [old-length (count %)\n       new-obj (conj % [:c 1] [:c 1])\n       new-length (count new-obj)]\n   (if (= new-length (inc old-length))\n\n     (if (nil? (:c new-obj))\n       :set :map)\n\n     (let [new-obj (conj % :a :b)]\n       (if (= (first new-obj) :b)\n         :list :vector))))", "problem": 65, "user": "4f71347ae4b07046d9f4f009"}, {"code": "(fn tst [s]\n  (let [ts (conj (empty s) [1 2] [3 4] [3 4])]\n  (cond\n    (= ts [[1 2] [3 4] [3 4]]) :vector\n    (= ts [[3 4] [3 4] [1 2]]) :list\n    (= ts #{[1 2] [3 4]}) :set\n    :else :map)))", "problem": 65, "user": "4f611127e4b0defedf855fb4"}, {"code": "(fn [collection]\n  (cond\n    (= :bar (get (conj collection [0 :bar]) 0)) :map\n    (= (inc (count collection))\n       (count (conj (conj collection 1) 1))) :set\n    (= :foo (first (conj (conj collection :bar) :foo))) :list\n    :else :vector))", "problem": 65, "user": "4f798ecde4b0fbe0118ec590"}, {"code": "(fn [x] (get { \\[ :vector, \\( :list, \\# :set, \\{ :map } (first (pr-str x))))", "problem": 65, "user": "4f713878e4b07046d9f4f00a"}, {"code": "#(let [v   [[:a :a] [:a :b] [:a :b]]\n       tst (into (empty %) v)]\n  (cond\n   (= 1 (count tst)) :map\n   (= 2 (count tst)) :set\n   (= v tst) :vector\n   :else :list))", "problem": 65, "user": "4f4d7b8fe4b03ad3f0c10ca9"}, {"code": "(fn seq-type [coll]\r\n  (let [base (empty coll)]\r\n    (cond\r\n      (= base {})  :map\r\n      (= base #{}) :set\r\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn get-type [x]\n     (cond \n       (reversible? x) :vector\n       (associative? x) :map\n       (= (count (conj (conj x 1) 1)) (count (conj x 1))) :set\n       :else :list))", "problem": 65, "user": "4f82e14be4b033992c121c0c"}, {"code": "(fn [coll]\n  (let [k (gensym)\n        c (count coll)]\n     (if (= (+ c 1) (count (conj (conj coll [k 1]) [k 2])))\n        :map\n    (if (= (+ c 1) (count (conj (conj coll [k 1]) [k 1])))\n      :set\n      (let [coll1 (conj coll :def)]\n        (if (= (conj coll1 k) (concat coll1 [k]))\n          :vector\n          :list))))))", "problem": 65, "user": "4f841b23e4b033992c121c29"}, {"code": "#(let [u (into % [[:a %] [:a %]])]\n  (if (= (count u)(+ (count %) 2))\n  (if (= (first (conj (conj % 1) %)) %)\n    :list\n    :vector)\n  (if (= % (:a u))\n    :map\n    :set)))", "problem": 65, "user": "4f7869c2e4b0fbe0118ec589"}, {"code": "(fn [raw]\n   (let [e [::x 1]\n         i [::x 2]\n         coll (conj raw e e i)\n         cr (count raw)\n         cc (count coll)]\n     (cond\n      (= cc (+ cr 2))\n      :set\n      (= cc (+ cr 1))\n      :map\n      (= i (last coll))\n      :vector\n      :else\n      :list)))", "problem": 65, "user": "4e360757535deb9a81d77f32"}, {"code": "(fn [coll]\n  (cond\n    (= \"{\" (.substring (.toString coll) 0 1)) :map\n    (= \"#{\" (.substring (.toString coll) 0 2)) :set\n    (= \"[\" (.substring (.toString coll) 0 1)) :vector\n    (= \"(\" (.substring (.toString coll) 0 1)) :list\n    (.startsWith (.toString coll) \"clojure.lang.LazySeq\" ) :list\n    (= \"clojure.lang.PersistentList$EmptyList@1\" (.toString coll)) :list\n)\n)", "problem": 65, "user": "4f7c6d81e4b06e829148e1b0"}, {"code": "#(or ({\\{ :map, \\[ :vector \\# :set} (first (str %))) :list)", "problem": 65, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [x]\n  (let [y (-> x (conj [:x :y]) (conj [:z :w]))]\n    (cond\n      (get y [:x :y]) :set\n      (get y :x) :map\n      (= (first y) [:z :w]) :list\n      (= (last y) [:z :w]) :vector)))", "problem": 65, "user": "4f49e869e4b0d56e7bb92c02"}, {"code": "(fn tpe [obj]\n        (let [v [:test :result]\n              obj (conj obj v)]\n              (cond (:test obj)\n                    :map\n                    (= (conj obj v) obj)\n                    :set\n                    (= (last (conj obj :aaaa)) :aaaa)\n                    :vector\n                    :default :list)))", "problem": 65, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn ident [l]\n  (let [l (conj l [(gensym) (gensym)])\n        sym (gensym)\n        nl (conj l [sym sym])]\n    (if (= (sym nl) sym)\n        :map\n        (if (= (conj nl [sym sym]) nl)\n          :set\n          (if (= (rest nl) l)\n            :list\n            :vector)))))", "problem": 65, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn t [c]\n  (let [c (empty c)\n        c1 (conj c [2 :two])\n        c2 (conj c1 [2 :two])]\n    (if (= c1 c2)\n        (if (= :two (c1 2))\n            :map\n            :set)\n        (if (= (conj c1 1) [1 [2 :two]])\n            :list\n            :vector))))", "problem": 65, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn [a]\n  (let [munge (fn [x] (conj x {:N 4} {:M 5} {:M 5}))]\n    (if (= (count (munge a)) (count (flatten (seq (munge a)))))\n      (if (= (+ 2 (count a)) (count (munge a)))\n        :set\n        (if (= (last (munge a)) {:M 5})\n          :vector\n          :list\n        )\n      )\n      :map\n    )\n  )\n)", "problem": 65, "user": "4f8ea1f7e4b0d4e659cdde69"}, {"code": ";; BWAhahaahahahahahahahhaahahahahah!\n#(cond \n  (re-find #\"\\#\\{\" (str %)) :set\n  (re-find #\"\\[\" (str %)) :vector\n  (re-find #\"\\{\" (str %)) :map\n  :else :list)", "problem": 65, "user": "4dc21233535d020aff1edf92"}, {"code": "#(let [s (conj % [1 2])]\n  (if (= 0 (count (flatten s)))\n    (if (associative? s)\n      :map\n      :set)\n    (if (= (conj (conj s 3) 4) (concat s [3 4]))\n      :vector\n      :list)))", "problem": 65, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [c]\n  (if (:a (conj c [:a true]))\n    :map\n    (if (= (count (conj c :a))\n           (count (conj (conj c :a) :a)))\n      :set\n      (if (= (cons 2 (cons 1 c)) (conj (conj c 1) 2))\n        :list\n        :vector))))", "problem": 65, "user": "4f83665ee4b033992c121c1c"}, {"code": "#(cond\n   (= (conj % nil) %) :map \n   (= (conj % 0) (conj % 0 0)) :set\n   (= (first (conj % 0 2)) 2) :list\n   true :vector)", "problem": 65, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [coll] \r\n  (let [c (conj (empty coll) {1 2 3 4} {5 6})] \r\n    (cond \r\n      (= 3 (count c)) :map \r\n      (empty? (flatten c)) :set \r\n      (= {5 6} (first c)) :list \r\n      :else :vector)))", "problem": 65, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "#(let [c (first (str %))] (if (= \\{ c) :map (if (= \\c c) :list (if (= c \\#) :set (if (= \\[ c) :vector)))))", "problem": 65, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "#(let [cnj (conj % nil)\n       cnj2 (conj cnj nil)]\n   (cond (= (count %) (count cnj)) :map\n         (= (count cnj)(count cnj2)) :set\n         :else (let [cnj3 (conj cnj2 cnj2)]\n                 (if (= cnj2 (first cnj3))\n                   :list\n                   :vector))))", "problem": 65, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn test-class [coll]\n  ({\\{ :map \\c :list \\[ :vector \\# :set} (nth (str coll) 0)))", "problem": 65, "user": "4ef6f5ea535dced4c769f250"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "problem": 65, "user": "4f890488e4b033992c121c76"}, {"code": "(fn [col]\n  (let [a1   [::a 1]\n        a2   [::a 2]\n        col2 (conj col a1 a1 a2)\n        diff (- (count col2) (count col))]\n    (cond\n      (get col2 ::a)      :map\n      (= diff 2)          :set\n      (= (first col2) a2) :list \n      :else               :vector)))", "problem": 65, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "#(let [d (empty %)]\n   (if (= (count (conj d [0 1] [0 1])) 2)\n     (if (= (first (conj d 1 2)) 1) :vector :list)\n     (if (= (set d) d) :set :map)))", "problem": 65, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [c]\n  (let [c1 (conj c [0 0])]\n    (if (= c1 (conj c1 [0 0]))\n      (if (some (comp not coll?) c) :set\n          (if (c1 [0 0]) :set :map))\n      (if (= c (-> c (conj 0) (conj c) first)) :list :vector))))", "problem": 65, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn [s]\n  (if (associative? s)\n    (if (= (vec s) s) :vector :map)\n    (if (= (set s) s) :set :list)))", "problem": 65, "user": "4fa3f91fe4b081705acca196"}, {"code": "(fn [coll]\n  (cond (= coll (set coll)) :set\n        \n        (= coll (vec coll)) (let [c (conj coll :X)]\n                              (if (= c (first (conj c c)))\n                                :list :vector))\n        \n        :else :map))", "problem": 65, "user": "4fa98b72e4b081705acca1e2"}, {"code": "(fn [x]\r\n  (let [c (first(pr-str x))]\r\n    (cond \r\n      (= c '\\{) :map\r\n      (= c '\\#) :set\r\n      (= c '\\() :list\r\n      (= c '\\[) :vector\r\n     :else :juan)))", "problem": 65, "user": "4fa96e80e4b081705acca1df"}, {"code": "(fn [s]\n   (let [c (conj s [0 0])\n\t       cc (conj c [0 1])\n\t       ccc (conj c [0 0])]\n\t (cond\n\t  (and (= [0 1] (first cc)) (not (= c ccc))) :list\n\t  (and (= [0 1] (last cc)) (not (= c ccc))) :vector\n\t  (= 1 (cc 0)) :map\n\t  true :set)))", "problem": 65, "user": "4fa1183fe4b0dcca54ed6d57"}, {"code": "(fn [coll]\n  (let [xs (empty coll)]\n    (cond\n      (= xs {}) :map\n      (= xs #{}) :set\n      (= (conj xs :x :y) [:x :y]) :vector\n      :else :list)))", "problem": 65, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [lst]\n  (letfn [\n    ; contains test\n    (test-map [lst]\n      (let [s (+ 42 (count lst))]\n        (contains? (into lst [[s s]]) s)))\n\n    ; test uniqueness\n    (test-set [lst]\n      (= (count (conj (conj lst 42) 42))\n         (count (conj lst 42))))\n\n    ; test front-conj, non-sortedness\n    (test-list [lst]\n      (= (take 2 (conj (conj lst 23) 42))\n         '(42 23)))\n\n    ; test back-conj, non-sortedness\n    (test-vector [lst]\n      (= (take-last 2 (conj (conj lst 42) 23))\n         [42 23]))]\n  (cond \n    (test-map lst) :map\n    (test-set lst) :set\n    (test-vector lst) :vector\n    :else :list)))", "problem": 65, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn foo [x]\n  (cond \n   (= (conj x [:wibble :jelly]) (conj x [:wibble :wobble] [:wibble :jelly])) :map\n   (= (conj x :wibble) (conj x :wibble :wibble)) :set\n   (= (first (conj x :wobble :wibble)) :wibble) :list\n   (= (last (conj x :wobble :wibble)) :wibble) :vector\n   :else :wtf))", "problem": 65, "user": "4facd2fae4b081705acca22f"}, {"code": "#({\\( :list\n   \\c :list\n   \\[ :vector\n   \\{ :map\n   \\# :set}\n  (first (str %)))", "problem": 65, "user": "4f1abbfb535d64f60314646e"}, {"code": "(fn [s]\r\n    (cond \r\n      (contains? (conj s [:x nil]) :x) :map\r\n      (= (count (conj (empty s) 1 1)) 1) :set\r\n      (= (first (conj (empty s) 1 2)) 2) :list\r\n      :else :vector))", "problem": 65, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn black-box-test [coll]\n  (let [coll (into coll [[:a 1] [:b 2]])]\n    (if (= coll (set coll))\n      :set\n      (if (= coll (into coll coll))\n        :map\n        (if (= coll (into (empty coll) coll))\n          :vector\n          :list)))))", "problem": 65, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "#(let [ex (into (empty %) [[:a 1] [:a 1]])]\n  (if (= (count ex) 1)\n    (if (= (:a ex) 1) :map :set)\n    (if (= (into (empty %) [1 2 3 4]) (reverse [1 2 3 4])) :list :vector)))", "problem": 65, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn [s]\r\n    (let [str (pr-str s)]\r\n      (cond (not (nil? (re-find #\"#\\{\" str))) :set\r\n      (not (nil? (re-find #\"\\{\"  str))) :map\r\n\t    (not (nil? (re-find #\"\\[\"  str))) :vector\r\n\t    (not (nil? (re-find #\"\\(\"  str))) :list\r\n\t    :default :not-sequence)))", "problem": 65, "user": "4f9c4080e4b0dcca54ed6d1a"}, {"code": "#(if (associative? %)\n  (if (reversible? %) :vector :map)\n  (if (= % (apply list %)) :list :set))", "problem": 65, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn black-box [old-s]\r\n  (let [s (conj old-s [1 2])]\r\n    (cond\r\n      (= s (set s)) :set\r\n      (not (= s (vec s))) :map\r\n      (= \"joelboy\" (first (conj s \"joelboy\"))) :list\r\n      :else :vector)))", "problem": 65, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [x]\n  (let [g (gensym)]\n    (cond\n      (= (get (conj x [-1 true] [0 g] [1 true]) 0) g)\n        :map\n      (= (conj x g g) (conj x g))\n        :set\n      (identical? (first (conj x 0 g)) g)\n        :list\n      true\n        :vector)))", "problem": 65, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn [coll]\n    (let [coll-conj (conj coll [1 2])\n          coll-conj2 (conj coll-conj [1 3])\n          coll-conj3 (conj coll-conj2 [1 2])]\n      (cond (= (count coll-conj) (count coll-conj2)) :map\n            (= (count coll-conj2) (count coll-conj3)) :set\n            (= (first coll-conj2) [1 3]) :list\n            true :vector)))", "problem": 65, "user": "4f17aa97535d64f603146456"}, {"code": "(fn [thing]\n  (if\n    (contains?\n      (conj thing [:some-random-keyword 1])\n        :some-random-keyword)\n    :map\n    (if\n      (= (conj thing 1 1 1) (conj thing 1))\n      :set\n      (if\n        (=\n          (first (conj thing 1 :some-random-keyword))\n          :some-random-keyword)\n        :list\n        :vector))))", "problem": 65, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [coll]\n  (let [c (conj coll [:x :y])]\n    (cond \n      (= :y (get c :x)) :map\n      (= [:x :y] (get c [:x :y])) :set\n      (= :x (last (conj c :x))) :vector\n      :else :list)))", "problem": 65, "user": "4f9a0064e4b0dcca54ed6d03"}, {"code": "(fn [x]\n    (letfn \n      [(mymap? [x]\n             (contains? (conj x [:efg :hij]) :efg))\n       (myset? [x]\n             (= (conj x 1) (conj (conj x 1) 1)))\n       (myvector? [x]\n                (= :klm (last (conj x  :efg :klm))))]\n      (cond \n        (mymap? x) :map\n        (myset? x) :set\n        (myvector? x) :vector\n        :else :list)))", "problem": 65, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [col] (let [c1 (count col)\n                c2 (count (into col [[1 1] [1 1]]))]\n            (if (< c2 (+ c1 2))\n              (let [nc (into col [[:a :b]])]\n                (if (= :b (:a nc)) :map :set))\n              (let [e1 (str :a (first col) (last col))\n                    e2 (str :b (first col) (last col))\n                    nc (into col [e1 e2])]\n                (if (= e2 (first nc)) :list :vector)))))", "problem": 65, "user": "4efd8b67535de96065cf5085"}, {"code": "#(cond\n  (= 1 (:a (conj % [:a 1]))) :map\n  (= (conj % 1 1) (conj % 1)) :set\n  (= (conj % 2 1) (cons 1 (cons 2 %))) :list\n  :else :vector)", "problem": 65, "user": "4f91a38ae4b0dcca54ed6c9f"}, {"code": "(fn [coll]\n  (let [aug-coll (into coll [[:first 1] [:second 2]])]\n    (cond\n      (= 1 (:first aug-coll)) :map\n      (= :test (:test (conj coll :test))) :set\n      (= [:second 2] (first aug-coll)) :list\n      (= (aug-coll 0) (first aug-coll)) :vector)))", "problem": 65, "user": "4f7f9665e4b033992c121bea"}, {"code": "#(cond\n  (= (conj % nil) %)                :map\n  (= (conj % nil) (conj % nil nil)) :set\n  (nil? (first (conj % 0 nil)))     :list\n  :else                             :vector)", "problem": 65, "user": "4f9d8083e4b0dcca54ed6d23"}, {"code": "(fn [c1]\n  (let [s1 (count c1)\n        c2 (conj c1 [:foo :bar] [:foo :bar])]\n    (if (= (count c2) (+ 1 s1))\n      (if (c2 :foo) :map :set)\n      (let [c3 (conj c2 :baz)]\n        (if (= (first c3) :baz) :list :vector)))))", "problem": 65, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [s] \n    (condp = (first (str s))\n      \\{ :map\n      \\# :set\n      \\( :list\n      \\[ :vector\n        :list))", "problem": 65, "user": "4fba7d1ee4b081705acca2e0"}, {"code": "(fn [c]\n  (cond (not (ifn? c)) :list\n        (reversible? c) :vector\n        (associative? c) :map\n        :else :set))", "problem": 65, "user": "4f1bb9d8535d64f60314647d"}, {"code": "#(let \n  [q [:1 0] x (into % [[:0 0] q q])] \n  (cond (apply distinct? x) (if (x :0) :map :set) \n        (= [:1 0] (first x)) :list \n        true :vector))", "problem": 65, "user": "4fa30027e4b081705acca187"}, {"code": "(fn bb [x] \n   (let [e (conj (conj (empty x) {5,4}) {5,4})\n         ]   \n\n         (cond (> (count e) 1)  \n              (if (= (last (conj e 9)) 9)  \n                  :vector\n                  :list\n              )   \n              :else (if (= (e 5) 4) :map :set)\n         )   \n   )   \n)", "problem": 65, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "#( { [{} false] :map \n     [#{} false] :set \n     [[] true] :vector \n     ['() false] :list} \n        (vector (empty %) (reversible? %)))", "problem": 65, "user": "4f089f1a535dcb61093f6c3c"}, {"code": "#(let [ne (conj %1 [1 1]) sc (conj ne ne)]\n         (prn ne sc)\n         (cond\n          (= ne sc) :map\n          (= sc (conj sc ne)) :set\n          (= ne (first (conj sc ne))) :list\n          :else :vector))", "problem": 65, "user": "4fbfe9a4e4b081705acca31f"}, {"code": "(fn [val] (let [v (empty val)]\n(cond\n  (zero? (count (conj v (:a :b)))) :map\n  (not= 3 (count (into v [:a :b :b]))) :set\n  (= [:x :y] (into v [:y :x])) :list\n  :else :vector)))", "problem": 65, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn determine-type [obj] (let [emptobj (empty obj)]\n  (condp = emptobj\n    () ;; Could be a list or a vector.. () = [] in clojure\n      (if (= 3 (first (conj obj 1 2 3))) :list :vector)\n    #{} :set\n    {}  :map\n    :invalid\n)))", "problem": 65, "user": "4fae4c11e4b081705acca248"}, {"code": "(fn [coll]\r\n  (let [g1 (gensym)\r\n        gs [g1 'g]\r\n        c (conj coll gs)]\r\n    (cond\r\n     (g1 c) :map\r\n     (= (conj c gs) c) :set\r\n     (= (first (conj c g1)) g1) :list\r\n     true :vector)))", "problem": 65, "user": "4fb37882e4b081705acca2a0"}, {"code": "(fn black-box [coll]\n  (let [t (gensym)] ; A generic item guaranteed to not already be in coll.\n    (cond\n      (= coll (set coll))                            :set\n      (= (conj coll [t 1]) (conj coll [t 1] [t 1]))  :map\n      (= [t 2] (first (conj coll [t 1] [t 2])))      :list\n      (= [t 2] (last (conj coll [t 1] [t 2])))       :vector\n      :else                                          nil)))", "problem": 65, "user": "4fc6305de4b0ee37620e180b"}, {"code": "(fn [coll]\n  (let [coll (empty coll)]\n    (cond\n      (= {}  coll) :map\n      (= #{} coll) :set\n      (= (first (into coll [1 2])) 1) :vector\n      :else :list)))", "problem": 65, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn typ [c]\n  (let [nc (conj c [:test 123])]\n   (if (= () (flatten nc))\n    (if (= 123 (nc :test)) :map :set)\n    (if (= (cons 1 nc) (conj nc 1)) :list :vector))))", "problem": 65, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn get-type [coll]\n  (cond (and (= (cons [:test :er] coll) (conj coll [:test :er]))\n             (= (first (conj coll :test :er)) :er)) :list\n        (= ((conj coll [0 :tester]) 0) :tester) :map\n        (= (conj coll :tester :tester) (conj coll :tester)) :set\n        :else :vector))", "problem": 65, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "#(let [g [(gensym) (gensym)]\n       h [(gensym) (gensym)]] (cond\n  (and (= (conj % g g) (conj % g)) (not (associative? %))) :set\n  (= (last (conj % g h)) h) :vector\n  (associative? %) :map\n  (= (first (conj % g h)) h) :list))", "problem": 65, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "#(let [x [0 1] y [2 3] c (conj % x y x y)] \n  (if (= 4 (- (count c) (count %))) \n    (if (= y (first c)) :list :vector) \n    (if (nil? (c x)) :map :set)))", "problem": 65, "user": "4fb3b865e4b081705acca2a2"}, {"code": "#(if (or (= % {}) \n  (not= (count (flatten (seq %))) (count %))) \n  :map (if (= (into #{} %) %) \n  :set (if (= -2 (first (conj (conj % -1) -2))) \n  :list \n  :vector)) )", "problem": 65, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn [c] (cond\n  (reversible? c) :vector\n  (associative? c) :map\n  (= (conj c 1) (conj c 1 1)) :set\n  :else :list\n))", "problem": 65, "user": "4ef48422535dced4c769f236"}, {"code": "(fn [coll]\n  (let [a [:my-key :my-val]\n        b (conj coll a)]\n    (cond\n      (= (get b :my-key) :my-val)            :map\n      (= (get b a) a)                        :set\n      (= (first (conj b :my-key)) :my-key)   :list\n      :else                                  :vector)))", "problem": 65, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [s]\n  (let [a (gensym)\n        b (gensym)\n        r (conj s [b a] [a b])]\n  (cond (contains? r a) :map\n        (contains? r [a b]) :set\n        (= [a b] (last r)) :vector\n        :otherwise :list)))", "problem": 65, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [ l ] \n  ( let [\n        c ( first ( pr-str l ) ) \n          ] \n    (cond \n      (= c \\( ) :list\n      (= c \\{ ) :map\n      (= c \\# ) :set\n      (= c \\[ ) :vector\n    ) ))", "problem": 65, "user": "4fc43a8ee4b081705acca346"}, {"code": "(fn [coll]\n  (let [e (empty coll)]\n    (if\n      (= 2 (get (into e [[1 2]]) 1)) :map\n      (let [x (conj e 1 1 2)]\n        (cond\n          (= 2 (count x)) :set\n          (= 1 (first x)) :vector\n          :else           :list)))))", "problem": 65, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [coll] \n  (let [e (empty coll)]\n    (cond \n      (= e #{}) :set\n      (= e {}) :map\n      (reversible? e) :vector\n      (= e '()) :list)))", "problem": 65, "user": "4fa6a491e4b081705acca1bc"}, {"code": "(fn [c]\n  (cond\n    (= (count (conj c [:a :b] [:b :c] [:c :d] [:c :e])) 3) :map\n    (= (first (conj c [:a :b] [:a :c] [:c :d])) [:c :d]) :list\n    (and (= (last (conj c [:a :b] [:a :c] [:c :d] [:c :d])) [:c :d])\n         (= (+ 2 (count c)) (count (conj c [:a :b] [:a :b])))) :vector\n    :else :set))", "problem": 65, "user": "4faac363e4b081705acca200"}, {"code": "#(let [a (conj % [1 2])] (if (= (into [] a) a) (if (= (conj a :Z) (cons :Z a)) :list :vector) (if (or (= {1 2} a) (coll? (first %)) ) :map :set)))", "problem": 65, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "#(letfn [(c [x] (conj x [1 2] [3 4]))]\n  (get (zipmap (map c [{} () [] #{}]) [:map :list :vector :set])\n    (c (empty %))))", "problem": 65, "user": "4fd91099e4b05e33b9224f32"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4fc2e302e4b081705acca33a"}, {"code": "(fn what?[coll]\n  (if (not (associative? coll)) (if (= (conj coll 1) (conj (conj coll 1) 1)) :set :list)\n      (if(reversible? coll) :vector :map)))", "problem": 65, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "#(cond\n  (= (count (conj % [0 0]))\n     (count (conj % [0 0] [0 1]))) :map\n  (= (conj % 0) (conj % 0 0)) :set\n  (= (next (conj % 0 1)) (conj % 0)) :list\n  :else :vector)", "problem": 65, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn seq-type [coll]\r\n  (let [base (empty coll)]\r\n    (cond\r\n      (= base {})  :map\r\n      (= base #{}) :set\r\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4fdef544e4b05e33b9224f91"}, {"code": "(fn [x]\n  (let [fl (#(str (first (str %))) x)]\n     (cond \n       (= fl \"[\") :vector\n       (= fl \"#\") :set\n       (= fl \"{\") :map\n       :else :list)))", "problem": 65, "user": "4faf2f4ce4b081705acca251"}, {"code": "(fn black-box [item]\n  (let [test-vec (apply vector item)]\n    (cond\n     (and (not= item test-vec) (not (contains? (conj item [:t 1]) (first (conj item [:t 1])))))\n     :map\n     (and (not= item test-vec) (contains? (conj item [:t 1]) (first (conj item [:t 1]))))\n     :set\n     (and (= item test-vec) (= '(:test2 :test1) (take 2 (conj item :test1 :test2))))\n     :list\n     :else :vector)))", "problem": 65, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn [x]\n  (if (= :b (:a (conj x [:a :b]))) :map\n  ( let [y (conj (empty x) :a :b :a :b)]\n    (cond\n      (= 2 (count y)) :set\n      (= :b (last y)) :vector \n      (= :a (last y)) :list\n      ))))", "problem": 65, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [x]\n  (if (= (cons {0 1} (cons {2 3} x))\n         (conj x {2 3} {0 1}))\n      :list\n      (if (= (conj x {0 2} {0 1})\n             (conj x {0 1}))\n          :map\n      (if (= (conj x {0 1} {0 1})\n             (conj x {0 1}))\n          :set\n          :vector))))", "problem": 65, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn zype [coll]\n  (cond\n    (reversible? coll) :vector\n    (associative? coll) :map\n    (let [c (into coll [1])] (contains? c 1)) :set\n    :else :list))", "problem": 65, "user": "4e5fdd68535d8ccf87e9fe4f"}, {"code": "(fn [coll]\r\n   (condp = (empty coll)\r\n      {} :map\r\n      () (let [x1 (gensym)\r\n               x2 (gensym)\r\n               s (-> coll (conj x2) (conj x1))]\r\n            (if (= (first s) x1)\r\n                :list\r\n                :vector))\r\n      #{} :set))", "problem": 65, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond\n      (= e #{}) :set\n      (= e {})  :map\n      (= (into e [1 2]) [2 1]) :list\n      true :vector)))", "problem": 65, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [coll]\n  (cond (associative? coll)\n          (if (reversible? coll) :vector :map)\n        (= coll (into #{} coll)) :set\n        :else :list))", "problem": 65, "user": "4fe9d647e4b0547ebccb2472"}, {"code": "(fn [box]\n  (cond (= (conj box nil) box)\n        :map \n        (= (conj box 'foo)\n           (conj box 'foo 'foo))\n        :set\n        (= (first (conj box 0 'very-special-symbol))\n           'very-special-symbol)\n        :list\n        :else\n        :vector))", "problem": 65, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [x] (let [y (empty x)] (if (= y {}) :map (if (= y #{}) :set (if (= (conj y 1 2) [1 2] ) :vector :list) ) )))", "problem": 65, "user": "4febb4dae4b0681fd128dc98"}, {"code": "#(let [e (empty %)]\n  (case e\n    {}  :map\n    #{} :set\n    []  (if (= (conj e 1 2) [1 2])\n          :vector\n          :list)\n))", "problem": 65, "user": "4fe89db2e4b07c9f6fd12c59"}, {"code": "#(letfn [(mp? [c] \n            (not= (:a c)\n                  (:a (conj c [:a (not (:a c))]))))\n         (st? [c] (= (count (conj c :a))\n                     (count (conj c :a :a))))\n         (vc? [c]\n           (and (= (last (conj (conj c :x) :a)) :a)\n                (= (last (conj (conj c :x) :b)) :b)))]\n    (cond (mp? %) :map\n          (st? %) :set\n          (vc? %) :vector\n          :else   :list))", "problem": 65, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "#(cond\n  (= (:abc (conj % [:abc :cde])) :cde) :map\n  (= (conj % [:abc :cde]) (conj (conj % [:abc :cde]) [:abc :cde])) :set\n  (= (first (conj % [:abc :cde] [:ef])) [:ef]) :list\n  :else :vector)", "problem": 65, "user": "4fd7962ee4b0dab7d829f385"}, {"code": "(fn [coll]\n  (if (reversible? coll)\n    :vector\n    (if (associative? coll)\n      :map\n      (if (apply distinct? (conj coll :set :set))\n        :set\n        :list))))", "problem": 65, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn [coll]\n  (let [s (conj (conj coll [:val1 1]) [:val2 2])\n        f (first s)\n  fc (count (flatten s))] \n    (cond\n     (= f [:val2 2]) (if (= fc 0) :map :list)\n     (=\tfc 0) :set\n     :else :vector)))", "problem": 65, "user": "4fcc70b3e4b0ee37620e1862"}, {"code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "problem": 65, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [coll]\r\n     (let [x (rand-int 100) y (rand-int 100) \r\n           p [x y] c (conj coll p)]\r\n       (cond \r\n         (= y (get c x)) :map\r\n         (= p (get c p)) :set\r\n         (= x (last (conj c x))) :vector\r\n         :else :list)))", "problem": 65, "user": "4fdf4e2be4b05e33b9224f96"}, {"code": "(fn [seq]\n  (cond\n    (= -2 (get (conj seq [-1 -2]) -1)) :map\n    (= -2 (first (conj seq -1 -2))) :list\n    (= -2 (get (conj seq -2) -2)) :set\n    :else :vector))", "problem": 65, "user": "4f8aa1c1e4b02e764a0a516e"}, {"code": "(fn [coll]\r\n  (let [x (rand-int 100) y (rand-int 100) \r\n        p [x y] c (conj coll p)]\r\n    (cond \r\n      (= y (get c x)) :map\r\n      (= p (get c p)) :set\r\n      (= x (last (conj c x))) :vector\r\n      :else :list)))", "problem": 65, "user": "4ff07688e4b0678c553fc324"}, {"code": "(fn [coll]\n  (cond\n    (get (conj coll {:a true}) :a) :map\n    (let [uno (conj coll 1), dos (conj uno 1)]\n      (= (count uno) (count dos))) :set\n    :else (let [n 10, nums (take n (repeatedly rand))]\n      (cond\n        (= (take-last n (into coll nums)) nums) :vector\n        (= (take n (into coll nums)) (reverse nums)) :list\n        :else :wtf))))", "problem": 65, "user": "4fe8b6afe4b07c9f6fd12c76"}, {"code": "(fn [x] (let [x2 (conj x [:q :qv]) \r\n              x3 (conj x2 [:q :qv])] \r\n          (cond \r\n            (not (ifn? x)) :list \r\n            (not= x2 x3) :vector \r\n            (= (x2 :q) :qv) :map\r\n            :else :set)))", "problem": 65, "user": "4feada56e4b0140c20fb9c11"}, {"code": "#(let [v [:x 1]\n       c (conj % [1 1] v)]\n      (cond (:x c) :map\n            (get c v) :set\n            (= v (last c)) :vector\n            :else :list))", "problem": 65, "user": "4fe9de74e4b0547ebccb2475"}, {"code": "(fn [coll]\r\n  (let [sym (gensym)\r\n        coll1 (conj coll [sym 1])\r\n        c1 (count coll1)]\r\n    (cond (= c1 (count (conj coll1 [sym 2]))) :map\r\n          (= c1 (count (conj coll1 [sym 1]))) :set\r\n          (= (first (conj coll1 [sym 2])) [sym 2]) :list\r\n          :else :vector)))", "problem": 65, "user": "4e79ff2a535db169f9c796a9"}, {"code": "(fn cl [coll]\n  (let [b (empty coll)]\n    (cond\n      (= b #{}) :set\n      (= b {})  :map\n      (= b '()) (cond \n                  (reversible? coll) :vector \n                   :else :list))))", "problem": 65, "user": "4ec9549d535d6d7199dd36fe"}, {"code": "(fn [coll]\r\n  (cond\r\n    (= (conj coll nil) coll) :map\r\n    (= (conj coll 0) (conj coll 0 0)) :set\r\n    (= (conj coll 0 1) (cons 1 (cons 0 coll))) :list\r\n    :else :vector))", "problem": 65, "user": "4ff201d7e4b0678c553fc330"}, {"code": "(fn [c] (if (:z (conj c [:z :x])) :map \r\n (let [s (conj c :z :x)]\r\n \t(if (:z s) :set (if (= :x (last s)) :vector :list)))))", "problem": 65, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn [l]\n  (let [b1 (= (apply vector l) l)\n        b2 (associative? l)]\n    ({[true true] :vector, [true false] :list,\n      [false true] :map, [false false] :set} [b1 b2])))", "problem": 65, "user": "4ff5744ae4b0678c553fc36a"}, {"code": "(fn bbtest [c]\r\n    (let [tc [[:xyz -555] [:xyz 999] [:xyz 888]]\r\n          res (reduce conj c tc)]\r\n    (cond (= (count res) (inc (count c))) :map \r\n          (= (count res) (count (reduce conj res tc))) :set\r\n          (= (last res) (last tc)) :vector \r\n          :else :list)))", "problem": 65, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "#(cond \n  (reversible? %)       :vector\n  (associative? %)      :map\n  (= % (apply list %))  :list\n  :else                 :set)", "problem": 65, "user": "4ff82b00e4b0678c553fc395"}, {"code": "#(\n  cond (= 3 (:c (conj % {:c 3}))) :map\n(and\n       (= 9 (first (conj % 8 8 9)))\n  \t\t (= (count (conj % 8 8 9)) (+ (count %) 3))\n) :list\n(and\n       (= 28 (last (conj % 27 27 28)))\n\t\t\t (= (count (conj % 27 27 28)) (+ (count %) 3))\n) :vector\n       (= 6 (count (conj % 0 1 2 3 4 10))) :set\n)", "problem": 65, "user": "4ff2f0a9e4b0678c553fc341"}, {"code": "(fn [a] (let [c2 (fn [b] (conj b [1 2]))\n              dedup (= (c2 a) (c2 (c2 a)))]\n  (if (associative? a)\n    (if dedup :map :vector)\n    (if dedup :set :list))))", "problem": 65, "user": "4f03a3df535dcb61093f6b45"}, {"code": "(fn coll-type [coll]\n  (cond\n   (= (:foo (conj coll [:foo :bar])) :bar) :map\n   (= (first (conj coll :foo :bar)) :bar) :list\n   (= (count (conj coll :bar :bar)) (count (conj coll :bar))) :set\n   (= (last (conj coll :foo :bar)) :bar) :vector))", "problem": 65, "user": "4fa09916e4b0dcca54ed6d4e"}, {"code": "(fn identify [s]\n  (if (associative? s)\n\t\t(if (reversible? s)\n\t\t\t:vector\n\t\t\t:map)\n\t\t(if (=\n\t\t\t\t(count (conj s 1))\n\t\t\t\t(count (conj (conj s 1) 1)))\n\t\t\t:set\n\t\t\t:list)))", "problem": 65, "user": "4fb57e06e4b081705acca2bf"}, {"code": "(fn [col]\n  (let\n    [is-list   #(= :bar (first (-> % (conj :foo) (conj :bar))))\n     is-vector #(= :bar (last  (-> % (conj :foo) (conj :bar))))\n     is-set    #(= (+ (count %) 1) (count (-> % (conj :bar) (conj :bar))))\n     is-map    #(= (+ (count %) 1) (count (-> % (conj [:bar 1]) (conj [:bar 2]))))\n     ]\n    (cond\n      (is-map col) :map\n      (is-set col) :set\n      (is-list col) :list\n      (is-vector col) :vector)))", "problem": 65, "user": "4fbf2818e4b081705acca317"}, {"code": "#(case (first (str %)) \\{ :map \\# :set \\[ :vector (\\( \\c) :list)", "problem": 65, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4daf8e61edd6309eace4d179"}, {"code": "(fn bbox [coll]\n   (cond\n    (reversible? coll) :vector\n    (associative? coll) :map\n    (apply distinct? (conj coll :foo :foo)) :set\n    () :list))", "problem": 65, "user": "4fe8a3bde4b07c9f6fd12c61"}, {"code": "(fn [s]\n  (if (associative? s)\n    (if (reversible? s)\n      :vector\n      :map)\n    (let [t (conj (conj s :magic) :magic)\n          d (- (count t) (count s))]\n      (if (= d 1)\n        :set\n        :list))))", "problem": 65, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn typ\r\n  [x]\r\n  (case (empty x)\r\n    {}  :map\r\n    #{} :set\r\n    nil :list\r\n    []  (let [g1 (gensym)\r\n              g2 (gensym)\r\n              x (conj x g1 g2)]\r\n          (if (= g2 (first x))\r\n            :list\r\n            :vector))))", "problem": 65, "user": "500159b3e4b0678c553fc419"}, {"code": "#(case (first (str %))\n       \\[ :vector\n       \\{ :map\n       \\# :set\n       :list)", "problem": 65, "user": "5003ee7de4b0678c553fc446"}, {"code": "#(let [cc (conj % [::a ::a] [::a ::a] [::a ::b])\r\n       n (- (count cc) (count %))]\r\n      (condp = n\r\n        1 :map\r\n        2 :set\r\n        (if (= [::a ::b] (first cc)) :list :vector)))", "problem": 65, "user": "4db2cd84535df7e46ed9b6c6"}, {"code": "(fn type? [col]\n  (cond\n    (and (associative? col) (not (reversible? col))) :map\n    (= 1 (:test (frequencies (conj col :test :test)))) :set\n    (= :test (last (conj col :notme :test))) :vector\n    (= :test (first (conj col :notme :test))) :list\n    :else :no))", "problem": 65, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [coll]\n       (let [x [:a :b]\n             y [:c :d]]\n         (if (= (count (conj coll x x)) (count (conj coll x)))\n           (if (= ((conj coll x) :a) :b) :map :set)\n           (if (= (first (conj coll x y)) y) :list :vector))))", "problem": 65, "user": "4f2e205ae4b0d6649770a065"}, {"code": "(fn [t]\n    (cond\n     (= (conj t {}) t) :map\n     (empty? t) (cond\n                 (= (clojure.set/union t #{}) #{}) :set\n\t\t (= (conj (conj t 0) 1) [0 1]) :vector\n\t\t :else :list)\n     (= (clojure.set/union t t) t) :set\n     (= (first (conj t t)) t) :list\n     :else :vector))", "problem": 65, "user": "50057f23e4b0678c553fc466"}, {"code": "#(cond\n  (reversible? %)  :vector\n  (associative? %) :map\n  (= (+ 2 (count %)) (count (conj % 1 1))) :list\n  :else :set\n)", "problem": 65, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn [coll]\r\n  (cond (reversible? coll) :vector\r\n\t      (associative? coll) :map\r\n\t      :else (let [c (count coll)]\r\n\t\t      (if (>= (+ 1 c) (count (into coll '(3 3))))\r\n\t\t\t:set\r\n\t\t\t:list))))", "problem": 65, "user": "4ee75ec2535d93acb0a66867"}, {"code": "#(if (= % (rest (cons 1 %)))\n     (if (= :b (last (conj (conj % :a) :b))) :vector :list)\n     (if (nil? ((conj % [1 2]) 1)) :set :map))", "problem": 65, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn x [coll] (let [size (count coll) o (conj coll [:other 1]) a (conj o [:x 1]) b (conj a [:x 1])]\r\n               (cond\r\n                 (contains? b :x) :map\r\n                 (= (count b) (+ 2 size)) :set\r\n                 (= (last b) [:x 1]) :vector\r\n                 :else :list)))", "problem": 65, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn [s]\n  (if (reversible? s)\n    :vector\n    (if (associative? s)\n      :map\n      (let [one-item-added (conj s 1)\n            l1 (count one-item-added)]\n        (if (= (count (conj one-item-added 1)) l1)\n          :set\n          :list)))))", "problem": 65, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [s]\n    (cond        (= (conj s s) s) :map\n        (= (set s) s) :set\n        (= (first (conj (conj s :quux) :bar)) :bar) :list\n        (= (last (conj (conj s :quux) :bar)) :bar) :vector\n    ))", "problem": 65, "user": "4ff76effe4b0678c553fc390"}, {"code": "#(if (associative? %) (if (reversible? %) :vector :map)\n                      (if (= (conj % 1) (conj % 1 1)) :set :list) )", "problem": 65, "user": "5014718fe4b094324338f8e3"}, {"code": "(fn [x]\n  (if (not (associative? x))\n    (if (= 1 (get  (conj x 1) 1))\n      :set\n      :list)\n    (if (reversible? x)\n      :vector\n      :map)))", "problem": 65, "user": "4f8320e9e4b033992c121c18"}, {"code": "(fn type? [coll]\n  (if (=  coll (set coll)) :set\n      (let [x (conj coll [:c 3])]\n        (if (= (seq x) x)\n          (if (= (conj x 2) (cons 2 x))\n            :list :vector)\n         :map))))", "problem": 65, "user": "50127fbfe4b030d97e4db70f"}, {"code": "(fn class*\r\n  [coll]\r\n  (let [s (first (str coll))]\r\n    (cond\r\n     (= s \\[) :vector\r\n     (= s \\{) :map\r\n     (= s \\#) :set\r\n     :else    :list)))", "problem": 65, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "#(case (empty %)\n   {} :map\n   #{} :set\n   (case (conj (empty %) 1 2)\n     [1 2] :vector\n     :list))", "problem": 65, "user": "50142490e4b07d18bdaaf70a"}, {"code": "(fn [x]\n  (let [v (first (str x))]\n    (cond\n     (= v \\{) :map\n     (= v \\[) :vector\n     (= v \\c) :list\n     (= v \\#) :set )))", "problem": 65, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "#(let [s (conj % {:foo :bar} {:baz :bat})] ; test data\n      (if (empty? (flatten s)) ; \"flatten\" on non seqs => ()\n          (if (= (s :foo) :bar)\n              :map\n              :set)\n          (if (= (first s) {:baz :bat}) ; seq => vector or list\n              :list ; lists \"conj\" to the beginning\n              :vector))) ; vectors \"conj\" to the end", "problem": 65, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn getType [input]\n  (if (= (- (count (conj (conj input [:sqtest 1]) [:sqtest 2])) (count input)) 1)\n    :map\n    (if (= (- (count (conj (conj input :sqtest) :sqtest)) (count input)) 1)\n      :set\n      (if (= (first(conj (conj input :sqtest1) :sqtest2)) :sqtest2)\n        :list\n        :vector\n        )\n      )\n    )\n  )", "problem": 65, "user": "4fcf5292e4b03432b189f40e"}, {"code": "#(let\n  [x {:joudek 1}\n   ecoll (conj % x)\n   eecoll (conj ecoll x)]\n    (if \n      (= 2 (count (filter (fn [y] (= x y))eecoll)))\n      (let\n        [eeecoll (conj eecoll :test)]\n        (if \n          (= :test (first eeecoll))\n          :list\n          :vector))\n       (if \n      (= 1 (count (filter (fn [y] (= x y))eecoll)))\n       :set\n       :map)\n)\n)", "problem": 65, "user": "50158fa0e4b0aaedd199e913"}, {"code": "#(if (associative? %)\n  (if (= [] (empty %)) :vector :map)\n  (if (= #{} (empty %)) :set :list))", "problem": 65, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn fn3 [x]   \n  (if (= (get (conj x [:a :c]) :a) :c)\n    (keyword 'map)\n    (if (= (count (conj x [:a])) (count (conj (conj x [:a]) [:a])))\n      (keyword 'set)  \n      (let [y (conj x (range 10))]\n        (if (= (conj y '(1)) (cons '(1) y))\n          (keyword 'list)\n          (keyword 'vector))))))", "problem": 65, "user": "500b61b1e4b03d00572d2d81"}, {"code": "#(case (first (pr-str %))\n  \\( :list\n  \\[ :vector\n  \\{ :map\n  \\# :set)", "problem": 65, "user": "4e6a5158535d8ccf87e9fec5"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4f189b42535d64f60314645d"}, {"code": "(fn [coll]\n  (let [x :aa y :bb p [x y] c (conj coll p)]\n    (cond\n      (= :bb (get c :aa)) :map\n      (= p (get c p)) :set\n      (= :wow (first (conj c :wow))) :list\n      :else :vector)))", "problem": 65, "user": "5025b93ce4b0c969f0b056df"}, {"code": ";; One big clue: The function empty is not forbidden in this problem.\n\n(fn [c]\n  (let [e (empty c)]\n    (case e\n      {} :map\n      [] (if (reversible? c) :vector :list)\n      #{} :set)))", "problem": 65, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [coll]\n  (if (reversible? coll)\n    :vector\n    (if (associative? coll)\n      :map\n      (let [y (conj coll (apply str coll))\n            z (conj y (apply str coll))]\n        (if (= (count y) (count z))\n          :set\n          :list)))))", "problem": 65, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn [s]\n  (cond\n    (== (count (conj s [0 0])) (count (conj s [0 0] [0 1]))) :map\n    (= (conj s 0) (conj s 0 0)) :set\n    (= :abcxyz (first (conj s 0 :abcxyz))) :list\n    :else :vector))", "problem": 65, "user": "4ffe1df9e4b0678c553fc3ed"}, {"code": "(fn [coll]\r\n  (let [base (empty coll)]\r\n    (cond\r\n      (= base {})        :map\r\n      (= base #{})       :set\r\n      (reversible? base) :vector\r\n      (= base ())        :list)))", "problem": 65, "user": "4fd8544be4b0dab7d829f390"}, {"code": "(fn [s]\n  (cond\n    (= s (set s)) :set\n    (not (nil? (re-matches #\"^\\{.*\\}$\" (str s)))) :map\n    (not (nil? (re-matches #\"^\\[.*\\]$\" (str s)))) :vector\n    :else :list))", "problem": 65, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn [s]\n  (cond\n    (= (get (conj s [:a 1]) :a) 1) :map\n    (= (count (conj (conj s 0) 0)) (count (conj s 0))) :set\n    (not= (last (conj (conj s 1) 0)) 0) :list\n    :else :vector))", "problem": 65, "user": "4fcf642ee4b03432b189f410"}, {"code": "(fn [s]\n  (let [s1 (conj s [:a 1])\n        s2 (conj s1 [:b 2])]\n    (cond\n      (= 1 (:a s1)) :map\n      (= s1 (conj s1 [:a 1])) :set\n      (= [:b 2] (last s2)) :vector\n      (= [:b 2] (first s2)) :list)))", "problem": 65, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [coll]\n  (let [x (rand-int 100) y (rand-int 100) \n        p [x y] c (conj coll p)]\n    (cond \n      (= y (get c x)) :map\n      (= p (get c p)) :set\n      (= x (last (conj c x))) :vector\n      :else :list)))", "problem": 65, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [i] (if (= :m (:t (conj i [:t :m])))\n      :map\n      (case (first (conj (conj (empty i) :b :a) :c))\n        :a :set\n        :b :vector\n        :c :list)))", "problem": 65, "user": "4ee624f8535d93acb0a66855"}, {"code": "(fn [coll]\n  (let [x (int 99)\n        y (int 100)\n        p [x y]\n        c (conj coll p)]\n    (cond\n      (= y (get c x)) :map\n      (= p (get c p)) :set\n      (= x (last (conj c x))) :vector\n      :else :list)))", "problem": 65, "user": "4feacba7e4b0140c20fb9c0e"}, {"code": "#(-> % pr-str first {\\{ :map \\( :list \\[ :vector \\# :set})", "problem": 65, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n           (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "problem": 65, "user": "4ea882c7535d7eef308072fc"}, {"code": "(fn [x]\n  (let [e (empty x)]\n    (or ({{} :map, #{} :set} e)\n        (if (= [1 2] (conj e 1 2)) :vector :list))))", "problem": 65, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn __ [bb]\n  (let [fc (first (str bb))]\n  (cond\n   (= fc \\{) :map\n   (= fc \\[) :vector\n   (= fc \\#) :set\n   :else :list)))", "problem": 65, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [s]\n  (let [str-s-1 (first (str s))]\n    (cond \n      (= str-s-1 \\{ ) :map\n      (= str-s-1 \\c ) :list\n      (= str-s-1 \\[ ) :vector\n      (= str-s-1 \\# ) :set)))", "problem": 65, "user": "4e170143535d04ed9115e7ed"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4e944706535dbda64a6f6b11"}, {"code": "(fn [thing]\n  (if (= thing (apply vector thing))\n    ; then must be vector or list\n    (if (= (first (conj (conj thing :foo) :test)) :test)\n        :list\n        :vector)\n    ; must be set or map\n    (if (= thing (set thing))\n        :set\n        :map)))", "problem": 65, "user": "4ec56b5b535d6d7199dd369f"}, {"code": "(fn [s]\n  (cond\n   (= (conj s {}) s) :map\n   (empty? s) \n      (cond\n         (= (clojure.set/union s #{}) #{}) :set\n         (= (conj (conj s 0) 1) [0 1]) :vector\n         :else :list)\n   (= (clojure.set/union s s) s) :set\n   (= (first (conj s s)) s) :list\n   :else :vector))", "problem": 65, "user": "4fe9dda9e4b0547ebccb2474"}, {"code": "(fn [c]\n  (let [e (empty c)\n        ce (conj e e)]\n    (cond\n      (= e (conj e e)) :map\n      (= (clojure.set/union ce ce) ce) :set\n      :t (let [c2 (conj e (conj ce e))]\n          (if (= (cons c c2) (conj c2 c))\n            :list\n            :vector)))))", "problem": 65, "user": "4ed8b598535d10e5ff6f52fc"}, {"code": "#(cond\r\n  (= (into % {:a 1}) (into (into (into % {:a 1}) {:a 2}) {:a 1})) :map\r\n  (= (into % '(:a)) (into (into % '(:a)) '(:a))) :set\r\n  (= :b (last (conj (conj % :a) :b))) :vector\r\n  true :list)", "problem": 65, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn [coll]\n(let [x (first (pr-str coll))]\n  (cond\n    (= x \\() :list\n    (= x \\{) :map\n    (= x \\#) :set\n    (= x \\[) :vector)))", "problem": 65, "user": "50254dace4b0b0b8afb15aa6"}, {"code": "(fn [s]\n  (let [x (first (pr-str s))]\n    (cond\n      (= \\{ x)  :map\n      (= \\# x) :set\n      (= \\[ x)  :vector\n      (= \\( x) :list)))", "problem": 65, "user": "4f1f4db5535d64f60314649f"}, {"code": "#(cond (reversible? %) :vector\n       (associative? %) :map\n       (= (count %) (- (count (conj % :t :t)) 2)) :list\n       :else :set)", "problem": 65, "user": "502873a8e4b01614d1633ff8"}, {"code": "(fn [coll]\n  (let [add #(into % [[:a 1]])\n        coll (empty coll)]\n    (if (= (add coll) (add (add coll)))\n      (if ((into coll [[:a :a]]) :a) :map :set)\n      (if (= (first (conj coll :a :b)) :a) :vector :list))))", "problem": 65, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn check-type\r\n  ([collection] (let [string (str collection)]\r\n                  (case (get string 0)\r\n                    \\[ :vector\r\n                    \\# :set\r\n                    \\{ :map\r\n                    \\( :sequence\r\n                    \\c :list))))", "problem": 65, "user": "503a5623e4b07a1917cc34d3"}, {"code": "#(let [e [:t 1]\n         f [2 1]\n         p (conj % e)\n         a (conj p f)]\n     (cond (:t p) :map\n           (= 1 ((frequencies (conj p e)) e)) :set\n           (= (nth a 0) f) :list\n           (= (last a) f) :vector))", "problem": 65, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [sq]\r\n          (let [cf (fn [s] (conj (conj s {1, 41}) {42, 43}))]\r\n            (cond\r\n             (= (last (cf sq)) {42 43}) :vector\r\n             (= (empty sq) ()) :list\r\n             (= (empty sq) {}) :map\r\n             true :set)\r\n             ))", "problem": 65, "user": "4e8768f6535dceadca469850"}, {"code": "(fn [x]\r\n  (let [t (conj (empty x) [:a :b] [:c :d])]\r\n(cond \r\n  (:a t) :map\r\n(get t 0) :vector\r\n(get t [:a :b]) :set\r\n:else :list)))", "problem": 65, "user": "4eb44d78535d7eef30807360"}, {"code": "(fn [col]\n  (cond\n    (= 0 (:test (conj col {:test 0}))) :map\n    (= (conj (conj col 100) 100) (conj col 100)) :set\n    (= (take 2 (conj (conj col 200) 100)) [100 200]) :list\n    true :vector\n    ))", "problem": 65, "user": "5033ed65e4b062bc5d7ae15a"}, {"code": "(fn [s] \n  (let [t (into s [[1 s] [1 [s]] [1 s] [2 s]])]\n   (let [n (- (count t) (count s))]\n  \n    (cond \n      (= 2 n) :map\n      (= 3 n) :set\n      (= [2 s] (last t)) :vector \n      :else :list))))", "problem": 65, "user": "503917a0e4b088a6a14ca763"}, {"code": "#(let [e [:a :a]\r\n       len (count %)\r\n       coll (conj % e e)]\r\n        (if (<= (- (count coll) len) 1)\r\n          (if (coll (first coll)) :set :map)\r\n          (if (= (range 3) (reverse (take 3 (into coll (range 3))))) \r\n            :list :vector)))", "problem": 65, "user": "4ded27db535d08e6dec9fe0a"}, {"code": "#(if (associative? %)\r\n    (if (reversible? %)\r\n      :vector\r\n      :map)\r\n    (if (= (count (conj % :a)) (count (conj % :a :a)))\r\n      :set\r\n      :list))", "problem": 65, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "#(if (pos? (count (flatten (into % {:tic :toc}))))\r\n   (if (= :toc (first (into % [:tic :toc]))) :list :vector)\r\n   (if ((into % {:tic :toc}) :tic) :map :set))", "problem": 65, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n           (= (conj (conj s 0) 1) [0 1]) :vector\n           :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "problem": 65, "user": "501d52a8e4b066e56b9d0b20"}, {"code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "problem": 65, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [coll]\n  (let [mcoll (conj coll [:k :v] [:k :v] [:k1 :v1])]\n    (if (= :v (get mcoll :k))\n      :map\n      (if (= (count mcoll) (+ (count coll) 2))\n        :set\n        (if (= (first mcoll) [:k1 :v1]) :list :vector)))))", "problem": 65, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn id [xs]\n       (if (associative? xs)\n         (if (reversible? xs) :vector :map)\n         (if (distinct? xs (apply list xs)) :set :list)))", "problem": 65, "user": "4f03818e535dcb61093f6b00"}, {"code": "(fn [x]\n  (let [emp (empty x)]\n    (cond\n      (= 1 (count (into emp [[1 1] [1 2]])))\n        :map\n      (= 1 (count (into emp [1 1])))\n        :set\n      (= [1 2] (into emp [1 2]))\n        :vector\n      :else\n        :list)))", "problem": 65, "user": "502a9fdee4b095a7adb898b4"}, {"code": "#(let [x (conj % [0 [1]] [2 2])]\n  (cond \n    (= [1] (get x 0)) :map\n    (= [2 2] (get x [2 2])) :set\n    (= [2 2] (last x)) :vector\n    :else :list ))", "problem": 65, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn [coll]\n    (cond\n      (= (conj coll [:private :private]) (conj (conj coll [:private :false]) [:private :private])) :map\n      (= (conj coll :private) (conj (conj coll :private) :private)) :set\n      (= (conj coll :p1 :p2) (conj (vec coll) :p1 :p2)) :vector\n      :else :list\n      )\n    )", "problem": 65, "user": "502bb7c0e4b0194ad32ea1a3"}, {"code": "(fn [input]\n   (if (= input (vec input))\n     ;; decide betweeen vector or list\n     (if (= (conj input \"A\" \"B\")\n            (conj (apply list input) \"A\" \"B\"))\n       :list\n       :vector)\n     ;; decide between set or map\n     (if (= input (apply hash-set input))\n       :set\n       :map)))", "problem": 65, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [s]\n  (let [code (.charAt (str s) 0)]\n    (case (str code)\n      \"{\" :map\n      \"(\" :list\n      \"c\" :list\n      \"[\" :vector\n      \"#\" :set)))", "problem": 65, "user": "50435852e4b034ff00315d22"}, {"code": "(fn [a]\n          (let [b (empty a)]\n            (cond\n             (and (= [] b) (associative? b)) :vector\n             (= '() b) :list\n             (= {} b) :map\n             (= #{} b) :set\n             )))", "problem": 65, "user": "503b6995e4b07a1917cc34dd"}, {"code": "#(let [e (empty %)]\n  (cond (= e {}) :map\n        (= e #{}) :set\n        (reversible? e) :vector\n        true :list))", "problem": 65, "user": "503de5aae4b06c4e0e1fa259"}, {"code": "(fn [coll]\n  (let [s (pr-str coll)]\n    (case (subs s 0 1)\n      \"{\" :map\n      \"(\" :list\n      \"[\" :vector\n      \"#\" :set)))", "problem": 65, "user": "5012ec0ae4b0c87326002230"}, {"code": "#(cond\r\n  (reversible? %) :vector\r\n  (associative? %) :map\r\n  :else (if (== (+ 2 (count %))\r\n                (count (conj % 12 12))) :list :set))", "problem": 65, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn black-box [coll]\n  (let [a :some-random-item]\n\t\t(if (reversible? coll) :vector \n      (if (associative? coll) :map \n        (if (= 1 (- (count (conj coll a a a)) (count coll))) :set :list)))))", "problem": 65, "user": "501c1492e4b086d93747d180"}, {"code": "#(let [y [:dont :care]\n       x [:bleep :blorp]\n       c (conj % y x)]\n  (if (:bleep c)\n    :map\n    (if (= x (first c))\n      :list\n      (let [n (count c)\n            c (conj c x)]\n        (if (= n (count c)) :set :vector)))))", "problem": 65, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn [x]\n  (let [n (count x)\n        k (keyword (gensym))\n        y (conj x [k 0] [k 0] [k 1])]\n    (cond\n     (= (inc n) (count y)) :map\n     (= (+ 2 n) (count y)) :set\n     (= [k 1] (last y)) :vector\n     (= [k 1] (first y)) :list\n     )))", "problem": 65, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn [box]\r\n          (let [x (rand-int 100)\r\n                y (rand-int 100)\r\n                p [x y]\r\n                c (conj box p)]\r\n            (cond\r\n             (= y (get c x)) :map\r\n             (= p (get c p)) :set\r\n             (= x (last (conj c x))) :vector\r\n             :else :list)))", "problem": 65, "user": "503d129fe4b06c4e0e1fa254"}, {"code": "#(let [c (first (str %))]\n  (cond (= c \\#) :set\n        (= c \\{) :map\n        (= c \\[) :vector\n        :else :list))", "problem": 65, "user": "503354c3e4b0c6c1199c710c"}, {"code": "#(let [c (into % [[1 1] [1 1] [2 2]])]\n  (cond\n    (= (get c 1) 1) :map\n    (= (count c) (+ (count %) 2)) :set\n    (= (first c) [2 2]) :list\n    :else :vector))", "problem": 65, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [coll]\n  (condp = (empty coll)\n    #{} :set\n    {}  :map\n    ()  (if (reversible? coll) :vector :list)))", "problem": 65, "user": "50586354e4b06522596eba78"}, {"code": "(fn det [x]\n  (let [c (conj x [:a :b])\n        c2 (conj c [:a :b])\n        c3 (conj c [:c :d])]\n    (cond\n     (contains? c :a) :map\n     (apply distinct? c2) :set\n     (and (= [:a :b] (second (reverse c3)))\n        (= [:c :d] (last c3))) :vector\n     (and (= [:c :d] (first c3))\n        (= [:a :b] (second c3))) :list\n     :else nil)))", "problem": 65, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn [s]\r\n  (if ;test adding same element twice\r\n    (= (conj s [0 0]) (conj s [0 0] [0 0]))\r\n    ; map/set\r\n    (if ;test if pairs conj as k/v or element\r\n      (contains? (conj s [:eof :eof]) :eof)\r\n    :map\r\n    :set)\r\n    ; list/vector\r\n    (if ;test if elements are conj'd at front or back\r\n      (= :eof (first (conj s :bof :eof)))\r\n      :list\r\n      :vector)))", "problem": 65, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn [x]\n    (let [n (empty x)]\n      (if (identical? n '())\n        :list\n        ({{} :map [] :vector #{} :set} n))))", "problem": 65, "user": "504e1abee4b0f6ff3350c45d"}, {"code": "#(let [s (empty %)]\n  (cond (= 1 (count (conj s [1 2] [1 3]))) :map,\n(= 1 (count (into s [1 1]))) :set,\n(= 1 (first (into s [1 2]))) :vector,\n:default :list))", "problem": 65, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [thing]\n  (let [newthing (conj (conj (conj thing [:a :a]) [:a :a]) [:a :b])]\n    (cond\n       (= (:a newthing) :b) :map\n       (= 1 (count (filter #(= [:a :a] %) newthing))) :set\n       (= (first newthing) [:a :b]) :list\n       :else :vector)))", "problem": 65, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn [s]\n  (if (not (ifn? s))\n:list\n(let [in (str s)]\n(cond (re-matches #\"^\\{.*\\}$\" in) :map\n(re-matches #\"^#\\{.*\\}$\" in) :set\n(re-matches #\"^\\[.*\\]$\" in) :vector\n:else :what-was-that))))", "problem": 65, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "#(let [c (empty %)] (cond (= c {}) :map (= c #{}) :set (and (= c []) (reversible? c)) :vector :else :list))", "problem": 65, "user": "4f84a4a4e4b033992c121c39"}, {"code": "(fn[coll]\n  (let [obj (new Object)]\n    (let [x (conj coll [1 2])]\n      (cond\n        (empty? (flatten x)) (if (associative? x) :map :set)\n        (= (first (conj x obj)) obj) :list\n        :else :vector\n      )\n    )\n  )\n)", "problem": 65, "user": "504e685fe4b0f6ff3350c4ae"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "problem": 65, "user": "4fd6028ce4b0d4de60cee37b"}, {"code": "(fn [c]\n  (let [d (conj c {0 1} {0 2} {0 1})]\n  (cond\n    (= (+ 1 (count c)) (count d)) :map\n    (= (+ 2 (count c)) (count d)) :set\n    (= (cons {0 3} d) (conj d {0 3})) :list\n    true :vector)))", "problem": 65, "user": "504c8165e4b09724c857af31"}, {"code": "(fn set-type?\r\n  [coll]\r\n  (let [base (empty coll)]\r\n    (cond\r\n     (= base {}) :map\r\n     (= base #{}) :set\r\n     (reversible? base) :vector\r\n     (= base ()) :list)))", "problem": 65, "user": "4fec0824e4b0681fd128dc9c"}, {"code": "#(let [x (gensym)\n       y (gensym)\n       z (conj % [x y])]\n  (cond (get z x)     :map\n        (get z [x y]) :set\n        (get z 0)     :vector\n        :else         :list))", "problem": 65, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn back-box-testing [x]\n    (let [e (empty x)]\n      (cond\n       (= {} e) :map\n       (= #{} e) :set\n       (= '(2 1) (conj e 1 2)) :list\n       :else :vector)))", "problem": 65, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "#(let [x (conj % [0 2] [1 3])] (cond (= (get x 0) 2) :map (= x (conj x [0 2])) :set (= (last x) [1 3]) :vector true :list))", "problem": 65, "user": "4f045946535dcb61093f6bba"}, {"code": "#(let [im (into % [[:t1 :t2]])]\n  (if (= :t2 (get im :t1))\n    :map\n    (let [m (conj (conj (conj % :t1) :t1) :t2)]\n      (cond (= (count m) (+ 2 (count %))) :set\n            (= :t2 (last m)) :vector\n            (= :t2 (first m)) :list))))", "problem": 65, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n     (:a t) :map\n     (get t 0) :vector\n     (get t [:a :b]) :set\n     :else :list)))", "problem": 65, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn [vs]\n  (let [e (empty vs)]\n    (cond\n      (= e #{}) :set\n      (= e {}) :map\n      (= e ()) (if (= [5 6] (conj e 5 6))\n            :vector\n            :list))))", "problem": 65, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "#(condp = (conj (empty %) [:x :y] [:x :z])  '([:x :z] [:x :y]) :list {:x :z} :map #{[:x :y] [:x :z]} :set [[:x :y] [:x :z]] :vector)", "problem": 65, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn ftype [x]\n  (let [fchar (first (str x))]\n    (cond (= \\# fchar) :set\n          (= \\[ fchar) :vector\n          (= \\{ fchar) :map\n          :else :list\n    )\n  )\n)", "problem": 65, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn tt [c] (if (= c (merge c {})) :map (let [x (conj c :X)] (cond (= (inc (count c)) (count (conj x :X))) :set (= (last (conj x :G)) :G) :vector (= (first (conj x :G)) :G) :list))))", "problem": 65, "user": "4f614976e4b0defedf855fbb"}, {"code": "(fn [coll]\n (let\n  [\n   ap1 [:c 3]\n   ap2 [:d 4]\n   new_coll (conj coll ap1 ap1 ap2)]\n (cond\n  (contains? new_coll :c) :map\n  (= (count new_coll) (+ 2 (count coll))) :set\n  (= (first new_coll) ap2) :list\n  (= (last  new_coll) ap2) :vector\n  true :else\n  )))", "problem": 65, "user": "506fd0afe4b07bd6ad9b9f23"}, {"code": "(fn [col]\n  (let [x (empty col)]\n    (cond (= x {}) :map\n          (= x #{}) :set\n          (= x []) (let [y (conj x 1 2)]\n                     (if (= (first y) 1)\n                          :vector\n                          :list)))))", "problem": 65, "user": "50435689e4b034ff00315d21"}, {"code": "(fn [coll]\n  (let [c (conj coll [:x :x])]\n    (cond\n      (= (get c [:x :x]) [:x :x]) :set\n      (= (get c :x) :x) :map\n      (associative? coll) :vector\n      :default :list)))", "problem": 65, "user": "4dad90d9c9a9d6ed1999dc57"}, {"code": "#(let [x (conj % [:a :b])]\n   (if (= (count x) (count (conj x (first x))))\n     (if (get (conj x [:foo true]) :foo) :map :set)\n     (if (= (first x) (first (conj x (not (first x))))) :vector :list)))", "problem": 65, "user": "506ef8c3e4b09350ab4199f4"}, {"code": "(fn det[col]\r\n  (if (= (:p (conj col {:p 18})) 18)\r\n    :map\r\n    (let [col1 (conj col 53)]\r\n     (if (= (inc (count col1)) (count (conj (conj col1 70) 70)))\r\n    \t:set\r\n    \t(if (= (first (conj col1 70)) 70)\r\n        \t:list\r\n        \t:vector\r\n)))))", "problem": 65, "user": "5065bd94e4b0148eb3925aed"}, {"code": "#( if (associative? %)\n   ; :map or ;vector\n   (\n      if (reversible? %)\n        :vector\n        :map\n   )\n   ; :set or :list\n   (\n      if (= (conj (conj % 5) 5) (conj % 5))\n        :set\n        :list\n   )\n )", "problem": 65, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "(fn bb [coll]\n  (let [a [1 1] b [1 1] c [1 2] n (conj coll a b c)]\n    (cond\n      (= (count n) (+ 1 (count coll))) :map\n      (= (count n) (+ 2 (count coll))) :set\n      (= (first n) [1 2]) :list\n      (= (last n) [1 2]) :vector)))", "problem": 65, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "#(cond (reversible? %) :vector\n       (associative? %) :map\n       (= (count (into % [1])) (count (into % [1 1]))) :set\n       :else :list)", "problem": 65, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn [c]\r\n  (if (= (count (conj c [:xxyy :b] [:xxyy :c])) (+ (count c) 1))\r\n    :map\r\n    (let [n (conj c :hello )\r\n          n (conj n :hello )\r\n          n (conj n :goodbye )\r\n          front (first n)]\r\n      (if (= (+ (count c) 3) (count n))\r\n        (if (= front :goodbye )\r\n          :list :vector )\r\n        :set ))))", "problem": 65, "user": "506ce637e4b0a302964c5490"}, {"code": "(fn [coll]\r\n  (let [base (empty coll)]\r\n    (cond\r\n      (= base {})  :map\r\n      (= base #{}) :set\r\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4fecebe1e4b0681fd128dcac"}, {"code": "(fn [c]\n         ( let [f #(= (empty c) %  )   ]\n           (if-let [r (cond (f {}) :map  (f #{}) :set)]\n             r\n             (let [ x (first (conj (empty c) 1 2))]\n               (if (= x 2) :list :vector)))))", "problem": 65, "user": "5007cdb9e4b0b17c647f5227"}, {"code": "#(case (-> (conj % [:a :b]) str first)\n  \\( :list\n  \\[ :vector\n  \\{ :map\n  :set)", "problem": 65, "user": "502cb310e4b0532a782a5e38"}, {"code": "(fn [s]\n  (let [unique (Object.)]\n    (cond\n      (= (count (conj s [unique 1]))\n         (count (conj (conj s [unique 1]) [unique 2]))) :map\n      (= \n        (count (conj s unique))\n        (count (conj (conj s unique) unique))) :set\n      (= (first (conj (conj s :holdon) unique)) unique) :list\n      :else :vector)))", "problem": 65, "user": "4fceef7ae4b03432b189f40a"}, {"code": "(fn [l]\n  (let [m (reduce conj l [[:a :b] [:a :b] [:a :c] [:p :q]])]\n  (cond (= (:a m) :c) :map\n\t      (= ((frequencies m) [:a :b]) 1) :set\n\t      (= [:p :q] (first m)) :list\n\t      (= [:p :q] (last m)) :vector)))", "problem": 65, "user": "507437c2e4b054001656acd0"}, {"code": "(fn get_type [v]\r\n  (let [obj [:test true]\r\n        v2 (conj v obj)]\r\n    (cond (:test v2) :map\r\n          (= (count (conj v2 obj)) (count v2)) :set\r\n          (= (last (conj v2 1)) 1) :vector\r\n          :else :list)))", "problem": 65, "user": "5060c117e4b024449d699b5d"}, {"code": "(fn type-test [x]\n  ;; (is this clearer like this, or as a (cond..) ?\n  (if-not (ifn? x)\n    :list                           ; :map,:set,:vec all implement IFn\n    (if-not (associative? x)\n      :set                   ; :map,:set don't equal seq of themselves\n      (if (reversible? x)\n        :vector               ; set from a set will be equal to itself\n        :map))))", "problem": 65, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn [v]\n  (if (= #{} (empty v))\n    :set\n    (if (= {} (empty v))\n      :map\n      (if (= (into (empty v) '(1 2 3)) '(3 2 1))\n        :list\n        :vector))))", "problem": 65, "user": "507bb3ece4b09034bfeeb720"}, {"code": "(fn ident [coll]\n  (if (= (get (conj coll [:blah 1]) :blah) 1)\n    :map ; adding a key can then be 'got'\n    (if (= (conj coll :a :a) (conj coll :a))\n      :set ; adding same thing twice same as adding once\n      (if (= :blah2 (first (conj coll :blah1 :blah2)))\n        :list ; list and vector add to opposite ends\n        :vector))))", "problem": 65, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [x]\n    (let [i [:x x]\n          t (conj (conj x [:y :?]) i)]\n      (cond\n       (= (into #{} x) x) :set\n       (= (:x t) x) :map\n       (= (last t) i) :vector\n       (= (first t) i) :list)))", "problem": 65, "user": "4db2f208535df7e46ed9b6c9"}, {"code": "(fn [xs]\n  (if (= 1 (get (conj xs {:a 1}) :a))\n    :map\n    (if (= 2 (- (count (apply conj xs [1 1])) (count xs)))\n      (if (= 2 (first (apply conj xs [1 1 2])))\n        :list\n        :vector\n      )\n      :set\n    )\n  ) \n)", "problem": 65, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [q]\n  (case (-> q str first)\n    \\{ :map\n    \\c :list\n    \\# :set\n    \\[ :vector\n      ))", "problem": 65, "user": "503a234de4b088a6a14ca76d"}, {"code": "(fn [xs]\n    (let [ys (-> xs (empty) (conj [:a 0] [:a 0] [:b 0]))]\n      (if (-> ys (count) (= 2))\n        (if (ys :a)\n          :map\n          :set)\n        (if (-> ys (first) (first) (= :a))\n          :vector\n          :list))))", "problem": 65, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn get-type [v]\n  (let [obj [:test true]\n  v2 (conj v obj)]\n(cond (:test v2) :map\n(= (last (conj v2 1)) 1) :vector\n(= (count (conj v2 obj)) (count v2)) :set\n:else :list)))", "problem": 65, "user": "506717e2e4b03d366d7cb2ba"}, {"code": "(fn get-type [coll]\r\n  (let [coll (empty coll)]\r\n\t\t(cond \r\n\t\t\t(= coll {}) :map\r\n\t\t\t(= coll #{}) :set\r\n\t\t\t(= (first (into coll [1 2])) 1) :vector\r\n\t\t\t(= (first (into coll [1 2])) 2) :list\r\n\t\t)))", "problem": 65, "user": "4f3242bae4b0d6649770a08f"}, {"code": "(fn __ [o]\n    (let [tst (fn [x] (conj x 1))]\n        (cond\n            (= (count o) (count (conj o o))) :map\n            (= (set (reverse o)) o) :set\n            (let [obj (tst o)] (boolean (get obj 0))) :vector\n            (let [obj (tst o)] (= obj (conj (rest obj) (first obj)))) :list\n        )\n  \t)\n)", "problem": 65, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn get-type [coll]\n  (let [coll (conj coll [1 2] [3 4])\n        old-count (count coll)\n        coll (conj coll [9 9])\n        coll (conj coll [9 9])\n        new-count (count coll)\n        coll (conj coll [0 1])\n        coll (conj coll [0 2])]\n    (if (= new-count (+ old-count 1))\n      (if (= (coll 0) 2)\n        :map\n        :set)\n      (if (= (first coll) [0 2])\n        :list\n        :vector))))", "problem": 65, "user": "505d4b21e4b0e6aca564be07"}, {"code": "#(let [p [:test true]\n       n (conj % p)]\n   (if (:test n) :map\n     (if (= (count (conj n p)) (count n)) :set\n       (if (= (last (conj n 1)) 1) :vector :list))))", "problem": 65, "user": "505dcfc8e4b0e6aca564be0d"}, {"code": "(fn f [x]\n  (let [fir (new Object)\n        sec (new Object)\n        c (conj (conj x {fir fir}) {fir sec})] \n    (cond \n     (= 1 \n       (count (filter #(and (coll? %) (= (first %) fir)) c))\n        ) :map\n     (= (count c) (count (conj c {fir sec})))\n       :set\n     (= (last c) {fir sec})\n       :vector\n     :else :list)))", "problem": 65, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn tes [c]\n(\n  let [x1  (conj c [:a :b]), \n       x1c (count x1), \n       x2  (conj x1 [:a :b]), \n       x2c (count x2)] \n  (if (= 0 (- x1c x2c))\n    ;set or map\n      (let [x3\n            (conj x1 [:a :c])]\n        (if (= 0 (- (count x3) x1c))\n          :map\n          :set\n            )\n        )\n\n    ; list or vec\n    (if (= [:a :b] (first x1))\n      (if (= :q (first (conj x1 :q)))\n         :list\n         :vector\n      )\n    :vector\n  )\n)))", "problem": 65, "user": "50856bd1e4b004985b776e4c"}, {"code": "(fn [thing]\r\n    (let [gk (gensym)\r\n          gv (gensym)\r\n          pair (vector gk gv)\r\n          new-thing-1 (conj thing pair)]\r\n      (if (= gv (get new-thing-1 gk))\r\n        :map\r\n        (let [new-thing-2 (conj new-thing-1 pair)]\r\n          (if (= new-thing-1 new-thing-2)\r\n            :set\r\n            (let [new-thing-3 (conj new-thing-2 :xyz)]\r\n              (if (= (first new-thing-3) :xyz)\r\n                :list\r\n                :vector)))))))", "problem": 65, "user": "508b95a0e4b0be79e5b189c6"}, {"code": "(fn [col]\n  (let [cstr (str col)]\n    (if (re-seq #\"^\\{\"  cstr) :map\n      (if (re-seq #\"^\\[\"  cstr) :vector\n    \t\t(if (re-seq #\"^\\(\"  cstr) :list\n    \t\t\t(if (re-seq #\"^#\\{\" cstr) :set\n    \t\t\t\t:list))))\n   )\n)", "problem": 65, "user": "5082ccb3e4b06a522e8c7af3"}, {"code": "#(case (first (print-str %))\r\n   \\( :list\r\n   \\{ :map\r\n   \\# :set\r\n   \\[ :vector)", "problem": 65, "user": "4fabbb97e4b081705acca21d"}, {"code": "(fn get-type[v]\r\n     (let [obj [:test true] \r\n            v2 (conj v obj)]\r\n(cond (:test v2) :map \r\n(associative? v) :vector  \r\n(= (count (conj v 2 2)) (+ 2(count v))) :list\r\n:else :set\r\n )))", "problem": 65, "user": "5062bc46e4b05ac47bc68d68"}, {"code": "(fn typ [c]\n  (let [ \n    ;; each pred works on its own \n    ;; note the alphabetical order\n    predicates [\n    #(when \n      (let [c0 (conj % [0 0])] \n        (and \n          (not (contains? c0 0)) \n          (not (contains? c0 [0 0]))))\n      :list)\n    #(when (contains? (conj % [% +]) %)\n      :map)\n    #(when (contains? (conj % [% +]) [% +])\n      :set)\n    #(when \n      (let [cc (count %)] \n        (and \n          (not (contains? % cc))\n          (contains? (conj % [+ +]) cc)))\n      :vector) ]\n    ;; matching types from all predicates\n    typs (for [p predicates :let [typ (p c)] :when typ] typ)\n  ]\n  ;; return only type, or nil\n  (when (== 1 (count typs)) (first typs)))\n)", "problem": 65, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn  [x] (let\r\n                  [obj [:test true]\r\n                   v2 (conj x obj)]\r\n  (cond\r\n     (:test v2) :map\r\n     ( = (count (conj x 5)) (count (conj (conj x 5) 5) ))   :set\r\n     ( = (first (conj (conj x 100) x)) x) :list \r\n     ( = (last (conj (conj x 100) x)) x)  :vector\r\n     )))", "problem": 65, "user": "50646c01e4b007509339a58b"}, {"code": "(fn func [coll]\r\n\r\n  (let [obj   [:test true]\r\n         obj1 [\"Can't being here earlier\" Object]\r\n        coll1 (conj coll obj)]\r\n\r\n    (cond (:test coll1) :map\r\n          (= (count (conj coll1 obj)) (count coll1)) :set\r\n          (= (last (conj coll1 obj1)) obj1)  :vector\r\n        :else :list)))", "problem": 65, "user": "505dd5c4e4b0e6aca564be0e"}, {"code": "(fn [coll]\n  (cond (= (clojure.core/str coll) \"()\") :list\n        (= (clojure.core/str coll) \"[]\") :vector\n        (= (clojure.core/str coll) \"#{}\") :set\n        (= (clojure.core/str coll) \"{}\") :map\n        (= (empty coll) (empty {:a 1})) :map\n        (= (empty coll) ())\n           (cond (= (first (conj coll :test)) :test) :list\n                 :else :vector)\n        (= (empty coll) (empty #{1})) :set\n        :else :unknown))", "problem": 65, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [c]\n  (cond\n   (= c {}) :map\n   (= c #{}) :set\n   (let [fc (first c)]\n     (if (coll? fc)\n       (= (c (first fc)) (second fc)))) :map \n    (= (count c) (count (conj c (first c)))) :set\n    (= (first (conj c :flaga :flagb)) :flagb) :list\n    (= (last (conj c :flaga :flagb)) :flagb) :vector\n    ))", "problem": 65, "user": "50783762e4b0fc74642bff67"}, {"code": "#(let [c (conj (empty %1) [1 2] [1 3])]\n    (cond (= c {1 3}) :map\n          (= c '([1 3] [1 2])) :list\n          (= c [[1 2] [1 3]]) :vector\n          (= c #{[1 2] [1 3]}) :set))", "problem": 65, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [coll]\n   (cond\n    (= ::bar (get (conj coll [::foo ::bar]) ::foo)) :map\n    (= ::foo (get (conj coll ::foo) ::foo)) :set\n    (= ::bar (nth (conj (conj coll ::foo) ::bar) 0)) :list\n    (= ::foo (nth (conj (conj coll ::foo) ::bar) (count coll))) :vector))", "problem": 65, "user": "4f32ef71e4b0d6649770a098"}, {"code": "(fn t[x]\n  (cond\n   (:x (conj x {:x 1})) :map\n   (:x (conj x :x)) :set\n   (= :y (-> x (conj :x) (conj :y) first)) :list\n   :else :vector))", "problem": 65, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [coll]\n  (if (associative? coll)\n    (if (= 1 (count (flatten (assoc (empty coll) 0 0))))\n      :vector\n      :map)\n    (if (= 1 (count (conj (conj (empty coll) 0) 0)))\n      :set\n      :list)))", "problem": 65, "user": "4fb1325de4b081705acca276"}, {"code": "#(cond (= 42 (:z (conj % {:z 42}))) :map (= % (into #{} %)) :set (empty? %) (if (even? (rand-int 2)) :vector :list) (= 42 (last (conj % 42))) :vector :else :list)", "problem": 65, "user": "508ee17ae4b0706b2ed3ef8d"}, {"code": "(fn [coll]\n  (let [x [:a :b]\n        y [:c :d]]\n    (if (= (count (conj coll x x)) (count (conj coll x)))\n      (if (= ((conj coll x) :a) :b) :map :set)\n      (if (= (first (conj coll x y)) y) :list :vector))))", "problem": 65, "user": "5059da46e4b03d2efce48c56"}, {"code": "(fn [coll]\n  (let [e0 [:k0 true]\n         e1 [:k1 true]\n         guinea (conj (conj coll e0) e1)]\n(cond\n  (:k0 guinea) :map\n  (get guinea e0) :set\n  (= e1 (first guinea)) :list\n  :default :vector)))", "problem": 65, "user": "501b1efee4b0b12d9c5f4d82"}, {"code": "#(cond \n  (reversible? %) :vector\n  (associative? %) :map\n  (= (count (conj % 1 1)) (count (conj % 1))) :set\n  :else :list)", "problem": 65, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn [x]\n (cond\n  (= :23 (get (conj x [:42 :23]) :42)) :map\n  (= x (set x)) :set\n  (= :23 (first (conj x :42 :23))) :list\n  (= :42 (last (conj x :42))) :vector))", "problem": 65, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [s]\n  (if (or (= {} s) (= 2 (-> s first flatten count)))\n      :map\n    (if (>= (-> s count inc) \n           (-> s (conj :s) (conj :s) count))\n      :set\n      (if (= :s (-> s (conj :f) (conj :s) first))\n        :list\n        :vector)\n  )))", "problem": 65, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn black-box [coll]\n  (cond\n   (not (associative? coll)) (let [cc (count coll)\n                                   nn (count (into coll [1 1]))]\n                               (if (= 2 (- nn cc))\n                                 :list\n                                 :set))\n   :else (let [coll' (conj coll (first coll))\n               cs (count coll)\n               cs' (count coll')]\n           (if (= cs cs')\n             :map\n             :vector))))", "problem": 65, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn [s]\n  (cond \n  (= (empty s) {}) :map\n  (< (count (conj s :x :x)) (+ (count s) 2)) :set\n  (= (first (conj s :x :y)) :y) :list\n  :else :vector))", "problem": 65, "user": "50aab057e4b056ee0193586b"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "50a2cd3be4b048eb8059339d"}, {"code": "(fn checktype [o]\n   (if (= o (merge o {}))\n     :map\n     (let [test (into o [:a])]\n       (cond \n        (= (count test) (count (conj test :a)))\n        ,,:set\n        (not= (first (conj test 10)) 10)\n        ,,:vector\n        :t\n        ,,:list))))", "problem": 65, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "#({\"#{}\" :set \"{}\" :map \"[]\" :vector} (str (empty %)) :list)", "problem": 65, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn [x]\n  (cond\n    (= :b (:a (conj (empty x) [:a :b]))) :map\n    (= 1  (count (conj (empty x) :a :a))) :set\n    (= :b (last (conj x :a :b))) :vector\n    (= :b (first (conj x :a :b))) :list))", "problem": 65, "user": "4e7f32ee535db966e863cc3a"}, {"code": "(fn black-box [x]\n  (let [real-x (conj x [\"x\" \"y\"])]\n    (cond\n      (.contains (str real-x) \"#{\") :set\n      (.contains (str real-x) \"{\") :map\n      (= [\"a\" \"b\"] (first (conj real-x [\"a\" \"b\"]))) :list\n      :else :vector)))", "problem": 65, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn [coll]\r\n  (cond\r\n    (reversible? coll)  :vector\r\n    (associative? coll) :map\r\n    (= (conj coll 1) (cons 1 coll)) :list\r\n    \"default\" :set))", "problem": 65, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [x]\r\n    (let [conj-fn #(conj (conj (conj % [:c 1]) [:c 1]) [:c 2])\r\n          conj-diff #(- (count (conj-fn %)) (count %))]\r\n      (case (conj-diff x)\r\n        1 :map\r\n        2 :set\r\n        3 (if (= [:c 2] (first (conj-fn x))) :list :vector))))", "problem": 65, "user": "502a5e59e4b09e8f859a9fbc"}, {"code": "(fn [x]\n    (let [u (Object.)\n          v (Object.)]\n      (if (empty? x)\n        (cond\n         (= {} x) :map\n         (= #{} x) :set\n         (= [u v] (conj (conj x u) v)) :vector\n         :else :list)\n        (cond\n         (= x (set (cons (first x) x))) :set\n         (= (count x) (count  (apply conj x x))) :map\n         (= u (first (conj x u))) :list\n         :else :vector))))", "problem": 65, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "#(let [x {:a 1} y (conj % x)]\n      (cond (= (get y x) x) :set\n            (= (count y) (count (conj y x))) :map\n            (= (last (conj y :a)) :a) :vector\n            :else :list))", "problem": 65, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn [t]\n    (if (= (empty t) {})\n      :map\n      (let [e1 (gensym)\n            e2 (gensym)\n            added (-> (conj t e1)\n                          (conj e1)\n                          (conj e2))\n            f (first added)\n            l (last added)\n            ]\n        (cond (not= (count added)\n                    (+ 3 (count t)))\n              :set\n\n              (= f e2)\n              :list\n\n              (= l e2)\n              :vector))))", "problem": 65, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn bb\n  [c]\n  (let [s (conj c {:foo :bar} {:baz :quux})]\n   (cond \n     (= (:foo s) :bar) :map \n     (= (first s) {:baz :quux}) :list \n     (= (s (dec (count s))) {:baz :quux}) :vector\n     (= (s {:foo :bar}) {:foo :bar}) :set)\n    ))", "problem": 65, "user": "50982769e4b04e098a4c726a"}, {"code": "(fn [s]\r\n  (let [c (empty s)]\r\n    (cond\r\n      (= c {}) :map\r\n      (= c #{}) :set\r\n      (= (first (conj c 1 2)) 1) :vector\r\n      :else :list)))", "problem": 65, "user": "50843a4ae4b0c98812d0788b"}, {"code": "#(if (= (get (conj % [:a :b]) :a) :b) :map\n  (cond (= (count %) (dec (count (conj % :x :x)))) :set\n        (= :y (last (conj % :x :y))) :vector\n        :else :list))", "problem": 65, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn [coll]\n  (cond\n    (= (conj coll {}) coll) :map\n    (empty? coll) (cond\n                    (= (clojure.set/union coll #{}) #{}) :set\n                    (= (conj (conj coll 0) 1) [0 1]) :vector\n                    :else :list)\n    (= (count coll) (count (conj coll (first coll)))) :set\n    (= (- (last coll) 1) (last (conj coll (- (last coll) 1)))) :vector\n    (= (- (last coll) 1) (first (conj coll (- (last coll) 1)))) :list))", "problem": 65, "user": "50052fd0e4b0678c553fc45d"}, {"code": "(fn [c]\n  (cond (.startsWith (str c) \"{\") :map\n        (.startsWith (str c) \"[\") :vector\n        (.startsWith (str c) \"#{\") :set\n        (.startsWith (str c) \"clojure.lang.PersistentList\") :list\n        (.startsWith (str c) \"clojure.lang.LazySeq\") :list))", "problem": 65, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s)\n      (cond\n        (= (clojure.set/union s #{}) #{}) :set\n        (= (conj (conj s 0) 1) [0 1]) :vector\n\t      :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "problem": 65, "user": "4f03f3b7535dcb61093f6b85"}, {"code": "#(condp = (empty %)\n   () (if (reversible? %) :vector :list)\n   {} :map\n   #{} :set)", "problem": 65, "user": "50052d38e4b0678c553fc45c"}, {"code": "#(if (associative? %)\n    (if (reversible? %) :vector :map)\n    (if (apply distinct? (conj (conj % 7) 7)) :set :list)\n)", "problem": 65, "user": "4de8a7d7535d08e6dec9fdfe"}, {"code": "(fn [s]\n  (let [c (first (str s))]\n    (case c\n      \\[ :vector\n      \\# :set\n      \\{ :map\n      (\\( \\c) :list)))", "problem": 65, "user": "50bd6033e4b0594b91591c66"}, {"code": "(fn [s]\n  (let [[x y] [[:k :u] [:k :v]]\n        t (into s [x y])]\n    (cond (=  (+ 1 (count s))\n              (count t)) :map\n          (= (conj t x) t) :set\n          (= (last t) y) :vector\n          (= (first t) y) :list)))", "problem": 65, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn [x]\n  (if (= x (map identity x))\n    (let [newseq (conj x \"bsure\" \"ami\" )]\n      (cond\n       (= \"ami\" (first newseq)) :list\n       :else :vector ))\n    (let [emptied (empty x)]\n      (cond\n       (= emptied {}) :map\n       (= emptied #{}) :set\n      :else :whoknows))\n))", "problem": 65, "user": "5089d52ce4b03217b26a539d"}, {"code": "#(let [c (first (str %))]\n  (cond (= c \\#) :set\n        (= c \\{) :map\n        (= c \\[) :vector\n        :else :list))", "problem": 65, "user": "506406c8e4b075d771da6f9f"}, {"code": "#(if (= % (vec %))\n     (if (= (concat % [1 2]) (conj % 1 2))\n         :vector\n         :list)\n     (if ((conj % [3 7]) [3 7])\n         :set\n         :map))", "problem": 65, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [x]\n  (cond\n    (= x (conj x x)) :map\n    (= #{} x) :set\n    (= [999 9999] (drop (count x) (conj (conj x 999) 9999))) :vector\n    (= [9999 999] (take 2 (conj (conj x 999) 9999))) :list\n    (= () (flatten x)) :set\n  ))", "problem": 65, "user": "50cb4cf6e4b0f78a8e1645b4"}, {"code": "(fn black-box-testing [obj]\n  (cond (= obj (into #{} obj)) :set\n        (not (= obj (into [] obj))) :map\n        (contains? (conj (empty obj) :dud) 0) :vector\n        :else :list))", "problem": 65, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn b [n]\n  (cond\n    (reversible? n) :vector\n    (associative? n) :map\n    (not= (count (conj (conj n 1) 1)) (+ (count n) 1)) :list\n    :else :set))", "problem": 65, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn [x] \n    (let [ k1 (gensym)\n          v1 (gensym)\n          kv1 [ k1 v1]\n          \n          k2 (gensym)\n          v2 (gensym)\n          kv2 [ k2 v2]\n          \n          c1 (conj (conj x kv1) kv2)\n          c2 (conj (conj c1 kv1) kv2)\n          ]\n      \n    (cond\n      (contains? c1 k1) :map\n      (= (count c1) (count c2)) :set\n      (= (first c1) kv2) :list\n      (= (last c1) kv2) :vector\n      :else :unknown \n    )\n  ))", "problem": 65, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn [x]\n  (cond\n    (associative? x) (if (reversible? x) :vector :map)\n    (= (count (conj x 1)) (count (conj x 1 1))) :set\n    :else :list))", "problem": 65, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "#(let [e (empty %)]\n   (cond \n     (= e {}) :map \n     (= e #{}) :set \n     (= (first (conj % :A :B)) :B) :list \n     :else :vector))", "problem": 65, "user": "50cf21dee4b0e61f11ddcd8b"}, {"code": "(fn [c]\n  (let [c2 (conj (empty c) [1 2] [1 2] [1 3])]\n\t(case (count c2)\n       1 :map\n       2 :set\n       3 (if (= (first c2) [1 2])\n           :vector\n           :list))))", "problem": 65, "user": "4f253a49e4b0d66497709ff3"}, {"code": "#(if (= :b (:unique-keyword (conj % [:unique-keyword :b])))\n   :map\n   (if (= :unique-keyword (:unique-keyword (conj % :unique-keyword)))\n     :set\n     (if (= :unique-keyword2 (last (conj % :unique-keyword1 :unique-keyword2)))\n       :vector\n       :list)))", "problem": 65, "user": "4f1e4ab5535d64f603146496"}, {"code": "(fn test65 [coll]\n  (let [xs (empty coll)]\n    (cond\n     (= xs {}) :map\n     (= xs #{}) :set\n     (= (conj xs :x :y) [:x :y]) :vector\n     :else :list)))", "problem": 65, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn [s]\n  (let [s' (conj s [:test 1] [:test 1] [:test 2])]\n    (cond\n     \n     (= (+ 3 (count s)) (count s'))\n     (if (= (last s') [:test 2])\n       :vector\n       :list)\n     \n     (= (+ 2 (count s)) (count s'))\n     :set\n     \n     :else :map)))", "problem": 65, "user": "50d8f4b6e4b01f0871336e74"}, {"code": "(fn [x]\n  (if (= (set x) x) :set\n  (if (= (apply list x) x)\n    (if (= (get (conj x :thing) (count x)) :thing) :vector :list)\n  :map)))", "problem": 65, "user": "50bfbf25e4b05ae8c1cbbd9b"}, {"code": "(fn bb [s]\n  (if (associative? s)\n    (let [s (conj (empty s) [0 0])\n          e (s 0)]\n      (if (= 0 e)\n        :map\n        :vector))\n    (let [s (conj s 0)]\n      (if (= s (conj s 0))\n        :set\n        :list))))", "problem": 65, "user": "4fb79872e4b081705acca2d2"}, {"code": "(fn [s]\n  (cond\n   (= :v (get (conj s {:k :v}) :k)) :map\n   (= [:b :a] (take 2 (conj s :a :b))) :list\n   (= (inc (count s)) (count (conj s :a :a))) :set\n   (= [:a :b] (drop (count s) (conj s :a :b))) :vector\n   ))", "problem": 65, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [coll1]\n    (let [size1 (count coll1)\n          coll2 (into coll1 [[:t1 :t1] [:t1 :t1] [:t1 :t2]])\n          size2 (count coll2)]\n        (cond\n          (= (+ 1 size1) size2) :map\n          (= (+ 2 size1) size2) :set\n          (= (first coll2) [:t1 :t2]) :list\n          (= (last coll2) [:t1 :t2]) :vector\n          :default :unknown )))", "problem": 65, "user": "4ee77f15535d93acb0a66868"}, {"code": "(fn [s] \n  (let [x (gensym)\n        y (gensym)]\n    (cond (contains? (conj s [x 1]) x) :map\n          (= (conj s x) (conj (conj s x) x)) :set \n          (= y (last (conj (conj s x) y))) :vector\n          :else :list)))", "problem": 65, "user": "4ff769bce4b0678c553fc38f"}, {"code": "(fn [coll]\n  (let [elt [:b 2]\n        coll (conj (empty coll) [:a 1] elt elt)]\n    (cond\n     (= (get coll :a) 1) :map\n     (= (count coll) 2) :set\n     (= (first coll) elt) :list\n     :else :vector)))", "problem": 65, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn [col]\n  (let [is-set-or-map (= (count (merge col {:a 1} {:a 1}))\n                 (count (merge col {:a 1})))\n        more-col (merge col {:a 1})\n        is-map-or-list (not (or (contains? more-col \n                                       (first more-col))\n                                (contains? more-col 0))\n                        )\n        is-map (and is-set-or-map is-map-or-list)\n        is-set (and is-set-or-map (not is-map-or-list))\n        is-list (and is-map-or-list (not is-set-or-map))\n        is-vector (and (not is-set-or-map) (not is-map-or-list))\n        ]\n    (condp = true \n      is-map :map\n      is-set :set\n      is-list :list\n      is-vector :vector\n      \"no match\")))", "problem": 65, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn f [bb] (cond (= :test-value (get (conj bb [:test-key :test-value]) :test-key)) :map \n                 (contains? (conj bb :test-key) :test-key) :set \n                 (= \"test-val2\" (last (conj bb \"test-val1\" \"test-val2\"))) :vector \n                 (= \"test-val2\" (first (conj bb \"test-val1\" \"test-val2\"))) :list \n                 :else :unknown))", "problem": 65, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn colltype [coll]\n  (cond\n    (= (-> (conj coll [1 2]) count) (-> (conj (conj coll [1 5]) [1 3]) count)) :map\n    (= (conj coll 1) (conj (conj coll 1) 1)) :set\n    (= (-> (conj coll 1 2 3 :tester) first) :tester) :list\n    (= (-> (conj coll 1 2 3 :tester) last) :tester) :vector\n    ))", "problem": 65, "user": "50e3ec87e4b0463d32072486"}, {"code": "#(let [x (conj % {:a :b} {:c :d} {:c :d})]\n   (cond (get x :a) :map\n         (= 2 (- (count x) (count %))) :set\n         (= {:c :d} (first x)) :list\n         1 :vector))", "problem": 65, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn [bb] \n  (let [u1 (fn), u2 (fn), test (conj bb [u1 u2] [u1 u2] [u1 u1])]\n    (cond (= (-> test count) (-> bb count inc)) :map\n          (= (-> test count) (-> bb count inc inc)) :set\n\t\t  (= (last test) [u1 u1]) :vector\n\t\t  :else :list)))", "problem": 65, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [x]\n  (let [x (empty x) xx (conj x [1 1])]\n    (cond\n      (= {} x) :map\n      (= #{} x) :set\n      (= 2 (first (conj xx 2))) :list\n      :else :vector\n    )\n  )\n)", "problem": 65, "user": "50e8a340e4b0ebbe794eb7ed"}, {"code": "(fn [col]\n     (cond\n       (and (reversible? col) (associative? col)) :vector\n       (and (not (reversible? col)) (associative? col)) :map\n       (contains? (conj col 8) 8 ) :set\n       :else :list))", "problem": 65, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "problem": 65, "user": "509160dae4b0742c82730aef"}, {"code": "(fn [coll]\n    (case (conj (empty coll) [1 2] [1 2] [2 3])\n      [[1 2] [1 2] [2 3]] :vector\n      '([2 3] [1 2] [1 2]) :list\n      #{[1 2] [2 3]} :set\n      {1 2 2 3} :map))", "problem": 65, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "( fn [c] \n  ( condp #(contains? %2 %)\n    ( conj ( empty c) '[a b] )\n      0 :vector\n      'a :map\n      '[a b] :set\n      :list\n    ))", "problem": 65, "user": "4fbb7010e4b081705acca2e7"}, {"code": "(fn [coll]\n    (let [e (empty coll)]\n      (cond \n       (= e {}) :map\n       (= e #{}) :set\n       (= (conj e 1 2) [1 2]) :vector\n       :else :list)))", "problem": 65, "user": "50e4b066e4b0cb9ec68fbca6"}, {"code": "#(let [b (empty %)]\n   (cond (= b {}) :map\n         (= b #{}) :set\n         :else (if (reversible? b) :vector :list)))", "problem": 65, "user": "50dfb660e4b061dbdced7228"}, {"code": "#(if (= % (vec %))\n   (if (= (conj % 0 1) (conj (vec %) 0 1)) :vector :list)\n   (if (= (empty %) (set (empty %))) :set :map))", "problem": 65, "user": "50ed4626e4b01236b1d4983c"}, {"code": "#(let [base (empty %1)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? %1) :vector :list)))", "problem": 65, "user": "4f592f83e4b0030a34fb2ad2"}, {"code": "(fn [n] \n      (let [e (empty n)]\n        (cond (= e {}) :map\n        (= e #{}) :set\n        (= (conj e 5 6) [5 6]) :vector\n             :else :list)\n        )\n      )", "problem": 65, "user": "50ef3e5de4b0a78662fa2652"}, {"code": "#({\\[ :vector \\{ :map \\( :list \\# :set} (first (pr-str %)))", "problem": 65, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn [coll]\n  (let [x (rand-int 100) y (rand-int 100) \n        p [x y] c (conj coll p)]\n    (cond \n      (= y (get c x)) :map\n      (= p (get c p)) :set\n      (= x (last (conj c x))) :vector\n      :else :list)))", "problem": 65, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "4f7d25b4e4b06e829148e1ba"}, {"code": "#(condp = (empty %)\n    {} :map\n    #{} :set\n    (if (reversible? %) :vector :list))", "problem": 65, "user": "4db29f98535df7e46ed9b6c1"}, {"code": "(fn [col ] (if (ifn? col) (cond (= {} (empty col)) :map (= [] (empty col)) :vector (= #{} (empty col)) :set   ) :list   ))", "problem": 65, "user": "50463347e4b011c5dfee771e"}, {"code": "(fn [coll]\n  (let [fs (comp first str)\n        m (zipmap (map fs [{} [] #{} (take 1 (range))])\n                  [:map :vector :set :list])]\n    (some\n     (fn [k] (when (= k (fs coll)) (m k)))\n     (keys m))))", "problem": 65, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn [l]\n    (let [M java.lang.Integer/MAX_VALUE, c (count l)]\n      (cond\n        (= M (get (conj l [M M]) M))\n          :map\n        (= (inc c) (count (conj l M M)))\n          :set\n        (= M (last (conj l (- M 1) M)))\n          :vector\n        (= M (first (conj l (- M 1 ) M)))\n          :list\n        :else\n          nil)))", "problem": 65, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [thing]\n  (let [one (conj (empty thing) [:c 4])]\n    (condp = one\n      {:c 4} :map\n      [[:c 4]] (if (= [1 2] (conj (empty thing) 1 2)) :vector :list)\n      #{[:c 4]} :set)))", "problem": 65, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [x]\n    (let [r {clojure.lang.PersistentArrayMap :map\n             clojure.lang.PersistentHashSet :set\n             clojure.lang.PersistentVector :vector\n             clojure.lang.LazySeq :list\n             clojure.lang.PersistentList$EmptyList :list\n             clojure.lang.PersistentList :list}]\n      (r (first (filter #(if (. % (isInstance x)) %) (keys r))))))", "problem": 65, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "problem": 65, "user": "506aa040e4b05d3b7762c749"}, {"code": "(fn [coll]\n  (if (associative? coll)\n    (if (reversible? coll) :vector :map)\n    (if (= '() (empty coll)) :list :set)\n    )\n  )", "problem": 65, "user": "50fa0dcee4b07934dda8b0bb"}, {"code": "(fn [x]\n  ({\\{ :map, \\c :list, \\[ :vector, \\# :set} (nth (str x)0)))", "problem": 65, "user": "50f9e74ee4b0e7c80cb15a54"}, {"code": "(fn [collection]\n ({\\{ :map, \\c :list, \\[ :vector, \\# :set} (first (str collection))))", "problem": 65, "user": "50f87a67e4b0aafb827eb202"}, {"code": "(fn [x]\n  (#({\\{ :map, \\c :list, \\[ :vector, \\# :set} %) (nth(str x)0)))", "problem": 65, "user": "51002399e4b0ab35a0d409ff"}, {"code": "(fn [s]\n  (let [conjtst (conj s\n                [:settestkey :settestval]\n                [:settestkey :settestval]\n                [:settestkey1 :settestval1])]\n  (cond\n    (= :settestval (get conjtst :settestkey)) :map\n    (= (inc (inc (count s))) (count conjtst)) :set\n    (= [:settestkey1 :settestval1] (first conjtst)) :list \n    :default :vector)))", "problem": 65, "user": "50f48298e4b004d364930527"}, {"code": "(fn black-box [seqen]\n  (cond\n    (= {:a 1, :b 2} seqen) :map\n    (= {} seqen) :map\n    (= (+ (count seqen) 1) (count (conj (conj seqen 50) 50))) :set\n    (= 50 (first (conj (conj seqen 40) 50))) :list\n    (= 50 (last (conj (conj seqen 40) 50))) :vector))", "problem": 65, "user": "50f89404e4b0aafb827eb204"}, {"code": "(fn tester [coll]\n  (let [emptyColl (empty coll)]\n    (if (= {} emptyColl)\n      :map\n      (if (= #{} emptyColl)\n        :set\n        (if (= (first (conj (conj coll \"TEST1\") \"TEST2\")) \"TEST2\")\n          :list\n          :vector\n        )\n       )\n      )\n    )\n  )", "problem": 65, "user": "50fd9fd4e4b033b9c38d78d0"}, {"code": "(fn [a-coll]\n  (let [rand1 (rand-int 100) rand2 (rand-int 100)\n        pair [rand1 rand2] new-coll (conj a-coll pair)]\n    (cond \n      (= rand2 (get new-coll rand1)) :map ;first of pair is key, second is value\n      (= pair (get new-coll pair)) :set ;pair is the self-referencing value\n      (= rand1 (last (conj new-coll rand1))) :vector ;value added to end\n      :else :list))) ;value added to front", "problem": 65, "user": "50febf94e4b075812dd6dfb3"}, {"code": "#(if (= (conj % %) %)\n   :map\n   (if (reversible? %)\n     :vector\n     (if (ifn? %)\n       :set\n       :list)))", "problem": 65, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [coll] (cond\n            \t(reversible? coll) :vector\n            \t(associative? coll) :map\n            \t(= (count (conj coll 1)) (count (conj (conj coll 1) 1))) :set\n            \t:else :list))", "problem": 65, "user": "50f2e5cee4b0ec8ee6fa8643"}, {"code": "(fn [collection]\n    (let [emptyCollection (str (empty collection))]\n      ;(println emptyCollection)\n      (cond\n        (= emptyCollection \"{}\") :map\n        (= emptyCollection \"[]\") :vector\n        (= emptyCollection \"#{}\") :set\n        :else :list\n      )\n    )\n  )", "problem": 65, "user": "50ff3800e4b017584cb41ccb"}, {"code": "(fn [coll] (cond \n              (= (empty coll) {}) :map\n              (= (empty coll) #{}) :set\n              (reversible? (empty coll)) :vector\n              (= (empty coll) ()) :list\n              ))", "problem": 65, "user": "50fde9b9e4b033b9c38d78d7"}, {"code": "(fn [coll] (let [c (empty coll)] (cond (= c {}) :map (reversible? c) :vector (= c #{}) :set (= c ()) :list)))", "problem": 65, "user": "50f9c7fde4b0e7c80cb15a52"}, {"code": "(fn checkThing [xs] (\n           if (< (+ 1 (count xs)) (count (conj xs [1 2] [1 2])))\n            (if (= [2 1] (last (conj xs [1 2] [2 1])))\n            :vector :list)\n            (if (contains? (conj xs [1 2] [1 2]) [1 2]) :set :map)\n            \n))", "problem": 65, "user": "50f85902e4b0aafb827eb1f8"}, {"code": "#(cond\n   (= :bar (:foo (conj % [:foo :bar]))) :map\n   (= (+ 1 (count %)) (count (apply conj % [:foo :foo]))) :set\n   (= :bar (last (apply conj % [:foo :bar]))) :vector\n   :else :list)", "problem": 65, "user": "5006b7d2e4b0678c553fc48c"}, {"code": "(fn [coll]\n  (if (associative? coll)\n    (if (reversible? coll) :vector :map)\n    (if (= '() (empty coll)) :list :set)\n    )\n  )", "problem": 65, "user": "50f8615ae4b0aafb827eb1fa"}, {"code": "(fn [y] \n  ((fn [x]\n     (cond\n       (= x '()) (if (associative? x) :vector :list)\n       (= x {}) :map\n       (= x #{}) :set ))(empty y)))\n;I spent a long time figuring out how to optimize the empty list thing like you mentioned Nic", "problem": 65, "user": "51004dabe4b0e0dde55c17f0"}, {"code": "(fn coll-type[coll]\n    (let [coll (conj coll {:test coll})]\n      (letfn [(lists? [coll]\n                      (= coll (map identity coll)))\n              (map-or-set [smap]\n                          (if (= smap (reduce conj #{} smap)) :set :map))\n              (list-or-vec [coll]\n                           (if (= (conj coll coll) (cons coll coll)) :list :vector))]\n        (if (lists? coll) (list-or-vec coll) (map-or-set coll)))))", "problem": 65, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn [coll]\n  (let [v1 [1 1]\n        v2 [1 2]\n        c2 (conj coll v1 v1 v2)\n        diff (Math/abs (- (count coll) (count c2)))]\n    (cond\n      (= 1 diff) :map\n      (= 2 diff) :set\n      (not= 3 diff) :unknown\n      (identical? v2 (first c2)) :list\n      (identical? v2 (last c2)) :vector\n      :else :unknown)))", "problem": 65, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn [x]\n  (let [emp (empty x)]\n    (if (= emp {}) :map\n      (if (= emp #{}) :set\n        (if (= (conj emp 1 2) [1 2]) :vector :list)))))", "problem": 65, "user": "510db6cde4b078ea71921145"}, {"code": "#(case (empty %)\n   {} :map\n   #{} :set\n   (last (conj (empty %) :list :vector)))", "problem": 65, "user": "5107b86de4b05b2b4eee7495"}, {"code": "(fn [col]\n   (cond (not (ifn? col)) :list\n         (= (into #{} col) col) :set\n         (= (into [] col) col) :vector\n         (= (into {} col) col) :map))", "problem": 65, "user": "51105c7fe4b04c71fce993ef"}, {"code": "(fn [c]\n  (cond\n   (contains? (conj c [::t ::u]) ::t)         :map\n   (let [f #(conj %1 ::t)]  (= (f c) (f (f c)))) :set\n   (= (first (conj c ::t ::u)) ::u)      :list\n  :else                                       :vector))", "problem": 65, "user": "504e96f0e4b069badc5a33ba"}, {"code": "#(or({{}:map #{}:set}(empty %))({[1 2]:vector[2 1]:list} (conj(empty %)1 2)))", "problem": 65, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [coll]\n  (if (associative? coll)\n    (if (reversible? coll) :vector :map)\n    (if (ifn? coll) :set :list)))", "problem": 65, "user": "50feab26e4b03cd852b4e850"}, {"code": "(fn [x]\n  (let [y (conj x [:a 1])]\n    (if (= 0 (count (flatten y)))\n      (if (= 1 (y :a))\n        :map\n        :set)\n      (if (= :first (first (conj y :first)))\n        :list\n        :vector))))", "problem": 65, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [coll]\n  (let [data [[1 2] [1 2] [1 3]]\n        coll (into (empty coll) data)]\n    (case (count coll)\n      3 (if (= [1 2] (first coll)) :vector :list)\n      2 :set\n      1 :map)))", "problem": 65, "user": "511688d5e4b0b3e208dba05a"}, {"code": "#(let [firstchar (first (str %))]\n  (cond \n   (= firstchar \\{) :map    \n   (= firstchar \\[) :vector\n   (= firstchar \\#) :set\n   \t:else :list))", "problem": 65, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map ;; If conj {} is not '(1 2 3 {})\n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n                 (= (conj (conj s 0) 1) [0 1]) :vector\n                 :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "problem": 65, "user": "50f53694e4b057d4c52de881"}, {"code": "(fn [item]\n   (let [s (str item) f #(not (nil? (re-find (re-pattern %2) %1)))]\n     (cond\n      (f s \"#\\\\{\") :set\n      (f s \"\\\\[\") :vector\n      (f s \"\\\\{\") :map\n      :else :list\n      ) \n     ))", "problem": 65, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [c]\n    (if (associative? c)\n      (if (keyword? (first (assoc c 0 :a)))\n        :vector\n        :map)\n      (if (= (conj (conj c :a) :a)\n             (conj c :a))\n        :set\n        :list)))", "problem": 65, "user": "4e5be681535d8a8b8723a2bc"}, {"code": "(fn whatsit [mystery-seq]\n  ; First test; add the same item twice. (conj of [:key :value] will work on all types).\n  ; If the second add of the identical item doesn't change the seq's count, it's a map or a set.\n  ; If the second add makes the count goes up by one, it's a vector or a list.\n  (let [one-conj (conj mystery-seq [:key :value])\n        two-conj (conj one-conj [:key :value])]\n    (if (= (count two-conj) (count one-conj))\n      ; Count did NOT change after adding the same item twice: it's a map or a set.\n      (if (contains? one-conj [:key :value])\n        ; True? Then the [:key :value] pair was NOT interpreted as a map entry; this is a set.\n        :set\n        ; False? Then this is a map, and conj'ing [:key :value] meant {:key => :value}.\n        :map)\n      ; Count changed after adding the same item twice: it's a vector or a list.\n      (if (= (first (conj two-conj :arbitrary)) :arbitrary)\n        ; True? Then conj adds to the start of the mystery seq: it's a list.\n        :list\n        ; False? Then conj adds to the end of the mystery seq: it's a vector.\n        :vector)\n      )))", "problem": 65, "user": "5119f3d5e4b06c8af0111818"}, {"code": "(fn [x]\n    (let [my-map? #(let [o (Object.)]\n                     (= o (get (conj % [0 o]) 0)))\n          my-set? #(and (not (my-map? %))\n                        (= (count (into % [1]))\n                           (count (into % [1 1]))))\n          my-list? #(and (not (my-map? %))\n                         (not (my-set? %))\n                         (let [o (Object.)]\n                           (= o (first (conj (conj % 1) o)))))\n          my-vector? #(and (not (my-map? %))\n                         (not (my-set? %))\n                         (let [o (Object.)]\n                           (not (= o (first (conj (conj % 1) o))))))]\n      (cond\n       (my-map? x) :map\n       (my-set? x) :set\n       (my-vector? x) :vector\n       (my-list? x) :list\n       :else :unknown)))", "problem": 65, "user": "4e50ad74535dc968683fc4ec"}, {"code": "(fn [v]\n       (if (= (conj v {}) v)\n          :map\n          (let [x (conj v \"y\")]\n            (cond\n              (= (first (conj x \"z\")) \"z\") :list\n              (= (count (conj x (first x))) (count x)) :set\n              :else :vector))))", "problem": 65, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn [x]\r\n   (cond\r\n    (and (associative? x) ((complement reversible?) x))\r\n      :map\r\n    (let [a (conj x \"xxx\") b (conj a \"xxx\")]\r\n      (== (.size a) (.size b)))\r\n      :set\r\n\t(let [a \"xxx\" b \"yyy\" c (conj (conj x a) b)]\r\n      (and (identical? b (first c)) (identical? a (second c))))\r\n      :list\r\n\t(reversible? x)\r\n      :vector\r\n    :else :nothing\r\n    )\r\n )", "problem": 65, "user": "510a6bece4b06956752d35af"}, {"code": "(fn [c]\n  ((fn chk0 [a b]\n    (cond (= (count (reduce conj a b)) (+ (count a) 1)) :map\n          (= (count (reduce conj a b)) (+ (count a) 2)) :set\n          (= (nthrest (reduce conj a b) (count a)) b) :vector    \n          (= (nthrest (reduce conj a b) (count b)) a) :list\n)) c [[100 100] [100 100] [100 200]]))", "problem": 65, "user": "5099283ce4b0cae2931060af"}, {"code": "(fn [coll]\n  (let [coll' (conj coll [:a 1])]\n    (if (= coll' (conj coll' [:a 1]))\n      (if (= (coll' [:a 1]) [:a 1])\n        :set\n        :map)\n      (if (= (into coll [1 2 3]) (concat coll [1 2 3]))\n        :vector\n        :list))))", "problem": 65, "user": "51195e77e4b055cfb310d499"}, {"code": "#(cond\n  (= (conj % nil) %) :map\n  (= (conj % 0 0) (conj % 0)) :set\n  (= (conj % 0 1) (concat % [0 1])) :vector\n  :else :list)", "problem": 65, "user": "510d9d61e4b078ea71921141"}, {"code": "(fn [some-seq]\n  (cond\n   (reversible? some-seq) :vector \n   (associative? some-seq) :map\n   (let [added-sym (gensym)\n    \t init-seq (conj some-seq added-sym)]\n   \t\t(> (count (conj init-seq added-sym)) (count init-seq))) :list\n    :else\n     \t:set))", "problem": 65, "user": "511a5328e4b09045b2b16946"}, {"code": "#(let [test-seq (conj % [:t1 1] [:t2 2] [:t2 2])]\n           (cond\n            (= 1 (get test-seq :t1)) :map\n            (= '([:t2 2] [:t2 2]) (take 2 test-seq)) :list\n            (= '([:t2 2] [:t1 1]) (take-last 2 test-seq)) :set\n            (= [:t2 2] (last test-seq)) :vector))", "problem": 65, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn [coll]\n  (get\n    (conj coll [:type :map])\n    :type\n    (if (> 2\n          (-\n            (count (conj coll [1 1] [1 1]))\n            (count coll)))\n      :set\n      (if\n        (=\n          [:test2 :test2]\n          (first (conj coll [:test1 :test1] [:test2 :test2])))\n        :list\n        :vector))))", "problem": 65, "user": "511f88eee4b085952a83535f"}, {"code": "(fn [coll]\n  (let [coll1 (empty coll)\n        a {:a 1 :b 2}\n        b {:c 3 :d 4}\n        coll2 (conj (conj (conj coll1 a) a) b)]\n\t(cond\n     (= (count coll2) 4) :map\n     (= (count coll2) 2) :set\n     (= (count coll2) 3) (if (= (last coll2) b)\n                           :vector\n                           :list))))", "problem": 65, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [coll]\n  (let [      \n        new-elem [1 2]\n        new-elem-2 [3 4]\n        \n        coll-2 (conj coll new-elem new-elem-2)\n        elem (first coll-2)\n        coll-conj-once (conj coll-2 new-elem)\n        coll-conj-twice (conj coll-conj-once new-elem)\n        coll-cons-once (cons new-elem coll-2)\n        ]\n    (if (= (count coll-conj-once) (count coll-conj-twice))\n      (if (= (get coll-2 elem) elem) :set :map)\n      (if (= coll-conj-once coll-cons-once) :list :vector)\n     )\n    )\n  )", "problem": 65, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn [c] (let [h (first (str c))]\n          (cond\n           (= h \\#) :set\n           (= h \\{) :map\n           (= h \\[) :vector\n           (= h \\() :list\n           (= h \\c) :list)))", "problem": 65, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn [a]\n  (if (associative? a)\n    (if (reversible? a)\n      :vector\n      :map)\n    (if (= (first (str a)) \\#)\n    \t:set\n      :list)))", "problem": 65, "user": "50589113e4b06522596eba7f"}, {"code": "(fn [el]\n       (cond\n         (= (empty el) {}) :map\n         (= (empty el) #{}) :set\n         (= (into (empty el) [:a :b]) [:a :b]) :vector\n         (= (into (empty el) [:a :b]) [:b :a]) :list)\n       )", "problem": 65, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn get-type\n  [items]\n  (cond\n   (= :c (:b (conj (empty items) [:b :c] [:d :e]))) :map\n   (= :b (:b (conj (empty items) :b :c :d :e))) :set\n   (= [2 1] (conj (empty items) 1 2)) :list\n   :else :vector))", "problem": 65, "user": "511720eae4b0063b4e3e16da"}, {"code": "(fn [c]\n  (let [cc (conj (empty c) [1 \"a\"] [1 \"a\"] [2 \"b\"] )]\n    (if (= 2 (count cc))\n      (if (nil? (cc 1)) :set :map)\n      (if (= 1 (ffirst cc)) :vector :list))))", "problem": 65, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn bbtest [coll]\n  (let [head (first (str coll))]\n    (cond\n      (= head \\{) :map\n      (= head \\[) :vector\n      (= head \\#) :set\n      :else :list)))", "problem": 65, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn[s] \n  (let [c (-> s (conj [:c 3]) (conj [:c 3]) (conj [:c 4]))]\n    (cond (= (count c) (+ 2 (count s))) :set\n          (= (count c) (inc (count s))) :map\n          (= (first c) [:c 4]) :list\n          (= (last c) [:c 4]) :vector)))", "problem": 65, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn\n  [s]\n    (let [p [:x :x]\n          x (conj s p p)]\n      (if (== (inc (count s)) (count x))\n        (if (= :x (x :x))\n          :map\n          :set)\n        (if (= :y (first (conj x :y)))\n          :list\n          :vector))))", "problem": 65, "user": "50ebd63ce4b04edc3377703c"}, {"code": "(fn [s]\n  (cond\n   (contains? (conj s [:foo :bar]) :foo)                       :map\n   (= (count (conj s :foo)) (count (conj (conj s :foo) :foo))) :set\n   (= :foo (first (conj (conj s :bar) :foo)))                  :list\n   (= :foo (last (conj (conj s :bar) :foo)))                   :vector))", "problem": 65, "user": "4f525fdce4b03ad3f0c10d37"}, {"code": "(fn [xs]\n  (if (not= (get (into xs [[:a :b]]) :a) nil)\n    :map\n    (if (= (set xs) xs)\n      :set\n      (let [test-seq (conj (conj xs :a) :b)]\n        (if (= (concat xs '(:a :b)) test-seq)\n          :vector\n          :list)))))", "problem": 65, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn tst [coll]\n\t(let [x 1337\n\t\t  y 1338\n\t\t  z [x y]\n\t\t  c (conj coll z)]\n\t\t(cond\n\t\t\t(= y (get c x)) :map\n\t\t\t(= z (get c z)) :set\n\t\t\t(= x (last (conj c x))) :vector\n\t\t\t:else :list\n\t\t)\n    )\n)", "problem": 65, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn [coll]\n   (if (associative? coll)\n     (if (reversible? coll)\n       :vector\n       :map\n       )\n     (let [result (into coll '(1 1))]\n       (if (= (count result) (+ 2 (count coll)))\n         :list\n         :set\n         )       \n       )     \n     )      \n   )", "problem": 65, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn seq-type [coll]\n\t(let [base (empty coll)]\n\t(cond\n\t\t(= base {}) :map\n\t\t(= base #{}) :set\n\t\t(= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "5132c6f0e4b021281ec7b6d3"}, {"code": "#({\\[ :vector \\{ :map \\# :set \\c :list} (first (str %)))", "problem": 65, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn bb [c]\n   (let [c1 (conj c [:booga :booga]) c2 (conj c1 [:booga :bla])]\n     (cond \n      (= (count c1) (count c2)) :map\n      (= (count (into c [:booga])) (count (into c [:booga :booga]))) :set\n      (= :booga (first (conj (conj c :booga2) :booga))) :list\n      :else :vector)))", "problem": 65, "user": "4e6f1b7a535d5021c1a89618"}, {"code": "(fn [x] (case (empty x) {} :map '() (if (reversible? x) :vector :list) #{} :set))", "problem": 65, "user": "50e0d5a3e4b061dbdced723d"}, {"code": "(fn [x]\n  (let [e (empty x)]\n    (cond\n     (= e {})  :map\n     (= e #{}) :set\n     (= 2 (last (conj (conj e 1) 2))) :vector\n     :else :list)))", "problem": 65, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [coll] (let [basis (empty coll)] (cond (= basis {}) :map\n                                           (= basis #{}) :set\n                                           (not (get (conj coll 0) 0)) :list\n                                           (get (conj coll 0) 0) :vector)))", "problem": 65, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn aa [x] \n  (if (empty? x)\n     (cond \n      (= x {})  :map\n      (= x #{}) :set\n      (= (apply conj x (range 5)) (range 5))  :vector\n      :else :list\n      )\n    \n    (cond\n     (coll? (first x)) :map\n     (= (conj x (first x)) x) :set\n     (= (conj x 1) (cons 1 x)) :list\n     :else :vector\n     )\n    )\n  )", "problem": 65, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn [thing]\n  (cond \n    (= \\{ (first(str thing))) :map\n    (= \\# (first(str thing))) :set\n    (= \\[ (first(str thing))) :vector\n    :else :list))", "problem": 65, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn [col]\n    \n\n  \n  (let [x (rand-int 100) y (rand-int 100)\n        p [x y] c (conj col p)]\n    (cond\n     (= y (get c x)) :map\n     (= p (get c p)) :set\n     (= x (last (conj c x))) :vector\n     :else :list)))", "problem": 65, "user": "513fb358e4b00f13ea1bd893"}, {"code": "(fn [coll]\n        (let [e (empty coll)]\n          (if (= (conj e [1 2]) [[1 2]])\n            ;; list-ish\n            (if (= (conj e 1 2) [1 2])\n              :vector\n              :list)\n            ;; map-ish\n            (if (contains? (conj e [1 2]) 1)\n              :map\n              :set))))", "problem": 65, "user": "5137c3b0e4b0509a8b470482"}, {"code": "(fn\n  [v]\n  (cond\n          (:a (conj v [:a 1])) :map\n          (< (- (count (conj v 1 1)) (count v)) 2) :set\n          (= (conj v 1 2) (cons 2 (cons 1 v))) :list\n          :else :vector))", "problem": 65, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn [coll]\n  (let [e (empty coll)]\n  (cond\n    (= (conj e [1 2]) {1 2}) :map\n    (= (conj e 1 2) [1 2]) :vector\n    (= (conj e 1 2) '(2 1)) :list\n    (= (conj e 1 2) #{1 2}) :set)))", "problem": 65, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn mytype[s] (if (associative? s) (if (reversible? s) :vector :map) (if (= #{} (empty s)) :set :list)))", "problem": 65, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn [c]\n  (let [u :u-17863182691 q :q-235238r3619\n        uu [u u] qq [q q]\n        c' (conj (conj c uu) qq)\n        ]\n    (cond (= u  (get   c' u )) :map\n          (= uu (get   c' uu)) :set\n          (= qq (last  c'   )) :vector\n          (= qq (first c'   )) :list\n          :else                :?)))", "problem": 65, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn [c]\n  (let [x1 [(gensym) 1]\n        x2 [(gensym) 2]\n        c1 (conj (conj c x1) x2)\n        c2 (conj c1 x1)]\n    (if (= c1 c2)\n      (if (= (c1 (first x1)) 1) :map :set)\n      (if (= x2 (first c1)) :list :vector)\n      )))", "problem": 65, "user": "51424cc8e4b0b50abeb46b34"}, {"code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "problem": 65, "user": "4dae0510c9a9d6ed4b99dc57"}, {"code": "(fn mytest-type [col]\n  (if (or (= 2 (count (flatten (vector (last col))))) \n          (and (empty? col) \n               (= (into col {:test 1}) {:test 1})))\n      :map\n      (if (= (count (conj col :test :test)) (+ 1 (count col)))\n        :set\n        (if (= (first (conj col :test1 :test2)) :test2)\n          :list\n          :vector))))", "problem": 65, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [tt](cond (and (reversible? tt) (associative? tt)) :vector\n        (and (not (reversible? tt)) (associative? tt)) :map\n        (= (count (conj tt :1 :1)) (inc (count tt))) :set\n        (not= (count (conj tt :1 :1)) (inc (count tt))) :list\n        ))", "problem": 65, "user": "514a7e71e4b00c7db5067429"}, {"code": "#(try\n\t(let [c (conj % [:a 1] [:b 2] [:b 2])\n          n (count %)]\n\t\t(cond\n    \t\t(:a c) :map\n     \t\t(= (count c) (+ n 2)) :set\n    \t\t(= [:b 2] (last c)) :vector\n       \t\t:else :list)))", "problem": 65, "user": "514d8084e4b019235f6c0588"}, {"code": "(fn test [coll]\n  (cond\n   (:a (conj coll [:a 1])) :map\n   (= (count (conj coll :a)) (count (conj (conj coll :a) :a))) :set\n   (= :a (last (conj (conj coll :b) :a))) :vector\n   :else :list))", "problem": 65, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "(fn [coll]\n  (let [t [:t :t]\n        a (conj (conj coll [:s :s]) t)]\n    (cond (= (last a) t) :vector\n          (= (get a t) t) :set\n          (= (:t a) :t) :map\n          :else :list)))", "problem": 65, "user": "50b35486e4b03ea88043356a"}, {"code": "(fn [input]\n (let [emptied (empty input)]\n\t (if (= {} emptied)\n\t   :map\n\t   (if (= #{} emptied)\n\t     :set\n\t     (if (= (conj emptied 5 6) (conj [] 5 6))\n\t       :vector\n\t       :list\n\t     )\n\t   )\n\t )\n )\n)", "problem": 65, "user": "51018807e4b0a79bcc8c0e0b"}, {"code": "(fn blackbox [coll]\n  (cond\n    (= {} (empty coll)) :map\n    (= #{} (empty coll)) :set\n    (= [0 1] (conj (conj (empty coll) 0) 1)) :vector\n    (= [1 0] (conj (conj (empty coll) 0) 1)) :list))", "problem": 65, "user": "514a2fa1e4b0829bd132edb5"}, {"code": "(fn [coll]\n  (let [k (gensym)\n        v (gensym)\n        x [k, v]\n        ncoll (conj coll x)]\n    (cond\n     (= (get ncoll x) x) :set\n     (= (get ncoll k) v) :map\n     (= (first (apply conj coll x)) v) :list\n     :else :vector)))", "problem": 65, "user": "4dada426c9a9d6ed2a99dc57"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n     (= #{} base) :set\n     (= {} base) :map\n     (= '() base) (if (reversible? base) :vector :list))))", "problem": 65, "user": "514721c6e4b0d520409ed392"}, {"code": "#(let [x (empty %)]\n   (cond\n    (= x #{}) :set\n    (= x {}) :map\n    :else (if (reversible? x) :vector :list)))", "problem": 65, "user": "5102489de4b00c483ae176f6"}, {"code": "(fn [c]\n  (let [d (conj c [1 2]) n (count d) x0 (first d)] \n  (if (= n (count (conj d x0))) \n\t(if (= x0 (d x0)) :set :map) \n    (if (= d (rest (conj d d))) :list :vector))))", "problem": 65, "user": "5145832be4b0e8879607340a"}, {"code": "(fn [c]\n  (let [random-stuff1 [-343535, \"jgTrdvn134\"]\n        random-stuff2 [5432291, \"gjr39gDErt\"]\n        c2 (conj c random-stuff1 random-stuff1 random-stuff2)]\n  \t(if (= (+ (count c) 3) (count c2))\n      (if (= random-stuff2 (first c2))\n        :list\n        :vector)\n      (if (= (c2 random-stuff1) random-stuff1)\n        :set\n        :map))))", "problem": 65, "user": "5117c31ee4b0e0897831a60c"}, {"code": "(fn [n]\n\n   (let [o (conj n [:x 0] [:x 0] [:x 1] [:x 1])]\n\n     ((zipmap [[1 false] [2 false] [2 true] [4 false] [4 true]]\n             [:map :set :set :vector :list])\n     (vector (- (count o) (count n) ) (= (second o) [:x 1])))))", "problem": 65, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "#(let [x (conj % [0 101])]\n  (if (= (count x) (count (conj x [0 101])))\n    (if (x [0 101]) :set :map)\n    (if (= (last (conj x 102)) 102) :vector :list)\n    )\n  )", "problem": 65, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [t]\n    (cond\n     (= (conj t {}) t) :map\n     (empty? t) (cond\n                 (= (clojure.set/union t #{}) #{}) :set\n                 (= (conj (conj t 0) 1) [0 1]) :vector\n                 :else :list)\n     (= (clojure.set/union t t) t) :set\n     (= (first (conj t t)) t) :list\n     :else :vector))", "problem": 65, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "#(let [y (empty %)] (cond (= {} y) :map (= #{} y) :set (and (= [] y) (reversible? y)) :vector (= '() y) :list))", "problem": 65, "user": "50223ee2e4b0846bc458ae48"}, {"code": "(fn gettype [x]   \n  (if (= (conj x [1 7]) (conj (conj (conj x [1 7]) [1 8]) [1 7]))\n    :map\n    (if (= (conj x 7) (conj (conj x 7) 7))\n      :set\n      (if (= (conj (conj x 7) 2) (cons 2 (cons 7 x))) \n        :list\n        :vector))))", "problem": 65, "user": "5110b8bae4b04c71fce993f4"}, {"code": "#(or \n   (and (= {} (empty %)) :map)\n   (and (= #{} (empty %)) :set)\n   (and (= :a (first (conj (conj (empty %) :a) :b))) :vector)\n   :list)", "problem": 65, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn black-box [coll]\n\t(#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list)) coll))", "problem": 65, "user": "50ed8a5fe4b06330c1f87c3d"}, {"code": "(fn p065 [coll]\n  (let [c (first (str coll))]\n    (cond\n      (= c \\{) :map\n      (= c \\[) :vector\n      (= c \\#) :set\n      :else :list)))", "problem": 65, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn [coll]\n  (let [coll-type (str (empty coll))]\n    (case coll-type\n      \"[]\"  :vector\n      \"{}\"  :map\n      \"#{}\" :set\n      :list)))", "problem": 65, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn seq-type [xs]\n  (if (empty? xs)\n   (cond\n    (identical? xs {}) :map\n    (identical? xs []) :vector\n    (identical? xs ()) :list\n    (identical? xs #{}) :set)\n   (cond\n    (every? coll? xs)            :map\n    (= xs (conj xs (first xs))) :set\n    (= (first (conj xs :e)) :e) :list\n    (= (last  (conj xs :e)) :e) :vector)))", "problem": 65, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "#(if (associative? %)\n   (if (reversible? %)\n     :vector\n     :map)\n   (if (= (count (conj % :y :y)) (+ 2 (count %)))\n     :list\n     :set))", "problem": 65, "user": "513b43ede4b067e25a345ed3"}, {"code": "(fn [s]\n  (let [x1 [:uniq :v]\n        x2 [:uniq :v2]\n        new-s (conj s x1 x1)]\n    (cond (contains? new-s :uniq) :map\n          (= (inc (count s)) (count new-s)) :set\n          (= (last (conj s x1 x2)) x2) :vector\n          :else :list)))", "problem": 65, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [coll]\n  (let [es (empty coll)]\n    (cond (= es {}) :map\n          (= es #{}) :set\n          (= :y (first (conj es :x :y))) :list\n          :else :vector)))", "problem": 65, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [c]\n    (if ((fn [m] (= (conj m [10 10]) (conj m [10 10] [10 10])) ) c)\n        (if ((fn [m] (= (conj m [10 10] [10 11]) (conj m [10 11])) ) c)\n            :map\n            :set)\n        (if ((fn [m] (= (first (conj m [4 2] [1 2] )) [1 2] )) c) :list :vector)\n    )\n)", "problem": 65, "user": "516385cee4b055933a9ca02d"}, {"code": "(fn [x]\n  (let [y (-> (empty x) (conj [:a 2]) (conj [:a 3]))]\n    (cond \n     (= 1 (count (conj y [:a 4]))) :map\n     (= (first y) [:a 3]) :list\n     (= 2 (count (conj y [:a 2]))) :set\n     :else :vector)))", "problem": 65, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn [coll]\n    (let [sentinel (keyword (gensym))\n          sentinel2 (keyword (gensym))\n          pair [sentinel sentinel]\n          pair2 [sentinel sentinel2]]\n      (if (= (count (conj coll pair)) (count (conj (conj coll pair) pair)))\n        (let [once (conj coll pair)\n              twice (conj once pair2)]\n          (if (= (count once) (count twice))\n            :map\n            :set))\n        (if (= (first (into coll [sentinel sentinel2])) sentinel2)\n          :list\n          :vector))))", "problem": 65, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [coll]\n\t(condp = ((juxt associative? reversible?) coll)\n\t\t[true true] :vector\n\t\t[true false] :map\n\t\t(let [coll (conj coll 1)]\n\t\t  (if (= (count coll) (count (conj coll 1)))\n\t\t      :set\n\t\t    :list))))", "problem": 65, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn \n       [coll]\n  (let [newcoll (conj (empty coll) [:a 1] [:b 2] [:b 3])\n        setcoll (conj (empty coll) [:b 1] [:b 1] [:b 1])]\n    (cond\n     (= 2 (count newcoll)) :map\n     (= 1 (count setcoll)) :set\n     (= (first (conj newcoll :z)) :z) :list\n     true :vector)))", "problem": 65, "user": "5166e80de4b060c690c1f4c5"}, {"code": "#(case (first (str %))\n             \\{ :map\n             \\[ :vector\n             \\# :set\n             \\( :list\n             :list)", "problem": 65, "user": "516c4c08e4b06f078fab251d"}, {"code": "(fn [x]\n  (cond\n    (:xyz (conj x {:xyz true})) :map\n    (= (count (conj x 5 5)) (count (conj x 5))) :set\n   \t(= (first (conj x :a :b)) :b) :list\n    (= (last (conj x :a :b)) :b) :vector\n       ))", "problem": 65, "user": "50a2f901e4b029e8bace362a"}, {"code": "#(let [base (empty %)]\n   (case base\n     {} :map\n     #{} :set\n     (if (reversible? base) :vector :list)))", "problem": 65, "user": "50b1d166e4b03ea880433554"}, {"code": ";; flengyel's solution to Black Box Testing\n;; https://4clojure.com/problem/65\n\n(fn blackbox [s]\n  (cond\n   (= (conj s {}) s) :map \n   (empty? s) (cond\n         (= (clojure.set/union s #{}) #{}) :set\n\t       (= (conj (conj s 0) 1) [0 1]) :vector\n\t       :else :list)\n   (= (clojure.set/union s s) s) :set\n   (= (first (conj s s)) s) :list\n   :else :vector))", "problem": 65, "user": "516d227fe4b06f078fab252d"}, {"code": "#({\"{}\" :map \"#{}\" :set \"[]\" :vector \"clojure.lang.PersistentList$EmptyList@1\" :list}\n        (str (empty %)))", "problem": 65, "user": "515e8ce2e4b049add99a053d"}, {"code": "(fn [s]\n  (let [initial-length (count s)\n        sym (gensym)\n        val {sym 4}\n        ss (conj (conj s {(gensym) 5}) val)]\n    ;; This next test is bogus.\n    (if (nil? (sym ss))\n      (let [sss (conj ss val)]\n        (if (= (count sss) (count ss))\n          :set\n          (if (= (first sss) val)\n            :list\n            :vector)))\n      :map)))", "problem": 65, "user": "501948b3e4b0b6630b101db5"}, {"code": "(fn [coll]\n  (let [first-char (first (pr-str coll))]\n    (cond (= first-char \\{) :map\n          (= first-char \\() :list\n          (= first-char \\[) :vector\n          (= first-char \\#) :set\n          :else (throw (Exception. \"Not a sequence\")))))", "problem": 65, "user": "51696bcde4b03f62cda68ce7"}, {"code": "(fn [s]\n  (let [e (empty s)] \n    (cond\n     (= e {}) :map\n     (= e #{}) :set\n     (= 1 (first (conj e 1 2))) :vector\n     :else :list)))", "problem": 65, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn bb [coll]\n  (let [coll (empty coll)\n        m {{} :map #{} :set}\n        r (m coll) ]\n    (if (nil? r)\n        (if (= [1 2] (conj coll 1 2)) \n            :vector\n            :list)\n        r)))", "problem": 65, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "50cfcad6e4b00b15ecee9752"}, {"code": "#(if (:test (conj % [:test true]))\n   :map\n   (let [to-test (apply (partial conj %) (range 10))]\n     (cond \n      (= to-test (concat % (range 10))) :vector\n      (= to-test (concat (reverse (range 10)) %)) :list\n      :else :set)))", "problem": 65, "user": "5071b614e4b0e3170b5a867d"}, {"code": "(fn [coll]\n  (let [v [:testkey :testval]\n        c (conj (conj coll [:trashkey :trashval]) v)]\n    (cond\n     (contains? c :testkey) :map\n     (contains? c [:testkey :testval]) :set\n     (identical? (last c) v) :vector\n     :else :list)))", "problem": 65, "user": "51631002e4b017b283c712c1"}, {"code": "#(let [nc (conj % [:x 1] [:x 1] [:x 2])\n       d (- (count nc) (count %))]\n   (cond\n     (= d 1) :map\n     (= d 2) :set\n     (= (first nc) [:x 2]) :list\n     :default :vector))", "problem": 65, "user": "4eab612d535d7eef30807316"}, {"code": "(fn get-type [coll]\n  (let [obj (Object.)\n        obj-2 (Object.)\n        c [[obj obj] [obj obj]]\n        c-2 [[obj obj] [obj-2 obj-2]]\n        size-before-test (count coll)\n        after-test-1 (into coll c)\n        after-test-2 (into coll c-2)\n        size-after-test-1 (count after-test-1)]\n     (cond\n        (and (= size-after-test-1 (inc size-before-test)) (contains? after-test-1 obj)) :map \n        (and (= size-after-test-1 (inc size-before-test)) (contains? after-test-1 [obj obj])) :set\n        (and (= size-after-test-1 (+ size-before-test 2)) (= (last after-test-2) [obj-2 obj-2])) :vector\n        (and (= size-after-test-1 (+ size-before-test 2)) (= (first after-test-2) [obj-2 obj-2])) :list\n      )   \n   )\n \n )", "problem": 65, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn [v]\n  (cond\n   (:map (conj v [:map :map])) :map\n   (:set (conj v :set)) :set\n   (= (conj v 0 1) (cons 1 (cons 0 v))) :list\n   :else :vector))", "problem": 65, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn [coll] \n  (let [c (empty coll)]\n    (cond (= c []) (if (reversible? c) :vector :list)\n          (= c {}) :map\n          (= c #{}) :set)))", "problem": 65, "user": "517d755ce4b0f5e87c18f263"}, {"code": "(fn [x]\n  (let [g1 (gensym)\n        g2 (gensym)\n        g3 (gensym)\n        g4 (gensym)\n        r1 (into x [[g1 g2] [g3 g4]])\n        r2 (into r1 [[g1 g2]])]\n   (if (= (count r1) (count r2))\n     (if (r1 g1)\n         :map\n         :set)\n     (if (= (first r1) [g3 g4])\n       :list\n       :vector))))", "problem": 65, "user": "51740b65e4b0d277d717bc67"}, {"code": "(fn [coll]\n  (let [c (empty coll)\n        r (str c)]\n    (condp = r\n      \"{}\"  :map\n      \"#{}\" :set\n   \t  \"[]\"  :vector\n            :list)))", "problem": 65, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [s]\n  (cond\n   (= (inc (count s))\n      (count (conj s [::key ::val1] [::key ::val2])))\n   :map\n   \n   (= (inc (count s))\n      (count (conj s ::entry ::entry ::entry)))\n   :set\n   \n   (= ::end\n      (last (conj s ::dummy ::end)))\n   :vector\n   \n   :else\n   :list))", "problem": 65, "user": "50b668dde4b08fb537db98f2"}, {"code": "#(if (not (empty? %))\n   (cond (coll? (first %)) :map\n         (= (count %) (count (conj % (first %)))) :set\n         (= :list (first (conj % :list))) :list\n         (= :vector (last (conj % :vector))) :vector)\n   (let [s (conj % [1 2])]\n     (cond (= 2 (get s 1)) :map\n           (= 1 (count (conj s [1 2]))) :set\n           (= :list (first (conj s :list))) :list\n           (= :vector (last (conj s :vector))) :vector)))", "problem": 65, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn [xs]\n  (let [ys (conj xs [11 12] [11 12] [11 13])]\n    (cond\n     (not (= (count ys) (+ (count xs) 3)))\n     (if (= (count ys) (inc (count xs))) :map :set)\n     (= [11 13] (first ys)) :list\n     true :vector)))", "problem": 65, "user": "5185e17ee4b0da5a5be3bac5"}, {"code": "(fn black-box [xs]\n  (let [s (.toString xs)]\n   (cond (.startsWith s \"{\") :map\n   (.startsWith s \"#{\") :set\n   (.startsWith s \"[\") :vector\n  :else :list)))", "problem": 65, "user": "4f2942ace4b0d6649770a01e"}, {"code": "#(let [a (conj (conj % [:b 2]) [:a 2])]\n  (if (== (count a) (count (conj a [:a 2])))  \n      (if (and (not (nil? (:a a))) (== 2 (:a a))) \n        :map\n        :set)\n    (if (= [:a 2] (last a)) \n          :vector \n          :list)))", "problem": 65, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [coll]\n  (let [x (rand-int 100) y (rand-int 100) \n        p [x y] c (conj coll p)]\n    (cond \n      (= y (get c x)) :map\n      (= p (get c p)) :set\n      (= x (last (conj c x))) :vector\n      :else :list)))", "problem": 65, "user": "51757af0e4b085adf681d873"}, {"code": "(fn [coll]\n   ;; adding :z -> cheking map\n   (if (not (nil?\n             (let [r (conj coll [:z 999])]\n               (if (= 999 (:z r))\n                 :map))))\n     :map\n     ;; checking set\n     (if (not (nil?\n               (let [c (count coll)\n                     r (conj (conj coll :z ) :z)]\n                 (if (= 1 (- (count r) c))\n                   :set))))\n       :set\n       (let [r (conj coll :y :z)]\n         (if (= :z (first r))\n           :list\n           :vector)))))", "problem": 65, "user": "5016ac54e4b052339a490e7b"}, {"code": "(fn [x]\n  (let [y (conj (empty x) [:a 1] [:a 2] [:a 2])]\n    (case (count y)\n      1 :map\n      2 :set\n      3 (if (= (first y) [:a 1]) :vector :list))))", "problem": 65, "user": "4fbd24d2e4b081705acca2ff"}, {"code": "(fn [coll]\n  (let [coll_plus_2 (conj coll [0 0] [0 -1] [0 -1])]\n    (cond\n     (= (count coll_plus_2) (inc (count coll))) :map\n     (= (count coll_plus_2) (+ 2 (count coll))) :set\n     (= (first coll_plus_2) [0 -1]) :list\n     :else :vector)))", "problem": 65, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn my-type [coll]\n  (let [all (seq coll)\n        conj1 (conj coll [all all])\n        conj2 (conj conj1 [all all])]\n    (if (= (count conj1) (count conj2))\n        ;; it is a set or map\n      (if (contains? conj1 [all all])\n        :set\n        :map)\n        ;; it is a list or vector\n        (let [cons1 (cons [all all] coll)]\n          (cond\n           (empty? coll) (my-type conj1)\n           (= cons1 conj1) :list\n           :else :vector)))))", "problem": 65, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [s]\n  (cond\n   (associative? s) \n   \t(if (= (count (conj s nil))\n           (count s))\n      :map\n      :vector)\n   (= (count (conj s 7))\n      (count (conj s 7 7))) :set\n   :else :list\n   ))", "problem": 65, "user": "50ef77a4e4b0bdaecbb47d99"}, {"code": "#({\\{ :map \\# :set \\[ :vector \\c :list} (-> % str first))", "problem": 65, "user": "50166470e4b052339a490e76"}, {"code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n    (if (= 1 (count result))\n      :map (if (= 2 (count result))\n             :set (if (= [1 3] (first result))\n                    :list :vector )))))", "problem": 65, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn probe [c]\n  (let [new-c (conj c [:fuck :conj])]\n    (cond\n     (= :conj (get new-c :fuck)) :map\n     (= [:fuck :conj] (get new-c [:fuck :conj])) :set\n     (= [:still :sucks] (first (conj new-c [:still :sucks]))) :list\n     (= [:still :sucks] (last (conj new-c [:still :sucks]))) :vector)))", "problem": 65, "user": "51460e4ce4b04ef915e37314"}, {"code": "(fn [coll]\n  (cond (= coll (conj coll {})) :map\n        (or\n         (and (empty? coll) (= #{} coll))\n         (and (not (empty? coll)) (= (count coll) (count (conj coll (first coll)))))\n         ) :set\n        (and\n         (= 2 (last (conj coll 1 2)))\n         (= 1 (last (conj coll 2 1)))\n         ) :vector\n        :else :list))", "problem": 65, "user": "51780f88e4b03d69594194c9"}, {"code": "#(let [unique-1 (gensym) unique-2 (gensym)]\n   (cond\n     (= (+ (count %) 1) (count (conj % [unique-1 unique-1] [unique-1 unique-2]))) :map\n     (= (+ (count %) 1) (count (conj % unique-1 unique-1))) :set\n     (= [2 2] (first (conj % [1 1] [2 2]))) :list\n     true :vector))", "problem": 65, "user": "5196568fe4b04c0af7ff3c1c"}, {"code": "(fn [coll]\n  (let [coll (empty coll)\n        coll (conj coll nil)]\n    (if (zero? (count coll))\n      :map\n      (let [coll (conj coll 2)]\n        (if-not (nil? (get coll 2))\n          :set\n          (if (nil? (get coll 1))\n            :list\n            :vector))))))", "problem": 65, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [coll]\n  (condp #(contains? %2 %) (conj (empty coll) '[a b])\n    0 :vector, 'a :map, '[a b] :set, :list))", "problem": 65, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "problem": 65, "user": "518ccf6be4b05e6c8537e386"}, {"code": "#(case (empty %)\n   {} :map\n   #{} :set\n   (if (= 9 (first (conj % 8 9)))\n     :list\n     :vector))", "problem": 65, "user": "519e9f06e4b0acf32bc6a433"}, {"code": "(fn [xs]\n  ((zipmap (map str [{} #{} [] ()]) [:map :set :vector :list])\n  (str (empty xs))))", "problem": 65, "user": "5111330de4b09ff0d31c7ca8"}, {"code": "(fn [s]\n  (cond\n   (= {} (empty s)) :map\n   (= #{} (empty s)) :set\n   (= :woohoo (first (conj s :blahblah :woohoo))) :list\n   :else :vector))", "problem": 65, "user": "5191e91de4b08962174cf733"}, {"code": "(fn [coll]\n    (letfn [(empty-type [empty-coll] (condp identical? empty-coll #{} :set {} :map [] :vector :list))\n             (is-map-or-set? [coll] (= (count coll) (count (conj coll (first coll)))))\n             (vector-or-list-type [coll] (if (= (last (conj coll :__dummy_value__)) :__dummy_value__) :vector :list))\n             (map-or-set-type [coll] (if (nil? (coll (first coll))) :map :set))]\n      (if (empty? coll) \n        (empty-type coll)\n        (if (is-map-or-set? coll) \n          (map-or-set-type coll)\n          (vector-or-list-type coll)))))", "problem": 65, "user": "4f43b992e4b0d7d3c9f3fd2c"}, {"code": "(fn\n  [coll]\n  (let [t (first (map char (str coll)))]\n    (cond\n      (= t \\{) :map\n      (= t \\[) :vector\n      (= t \\#) :set\n      :else :list)))", "problem": 65, "user": "4f03f197535dcb61093f6b84"}, {"code": "(fn [col]\n  (let [colx (conj col [-5 -5])\n        n (count colx)\n        after (count (conj colx [-1 -2] [-1 -3] [-1 -2]))\n        diff (- after n)\n        f (first colx)]\n    (case diff\n      1 :map\n      2 :set\n      3 (if (= f (first (conj colx 99))) :vector :list)))\n)", "problem": 65, "user": "51a1659de4b00957e520db72"}, {"code": "(fn [x]\n  (cond\n    (= (first (conj x {1 2} {0 0} {1 2})) {0 0}) :set\n    (= (last  (conj x {1 2} {3 4})) {3 4}) :vector\n    (= (first (conj x {1 2} {2 3} {1 2})) {1 2}) :list\n    (= (first (conj x {1 2})) [1 2]) :map))", "problem": 65, "user": "4f6fd91ae4b07046d9f4efed"}, {"code": "(fn blackbox [coll]\n\t(let [none (empty coll)]\n\t\t(cond\n\t\t\t(= none {}) :map\n\t\t\t(= none #{}) :set\n\t\t\t(= none []) ; can be vector or list\n         \t\t(if\n                  (contains? (conj none :x) 0)\n                  :vector\n                  :list\n                )\n\t\t)\n\t)\n)", "problem": 65, "user": "506cad7de4b0a302964c548e"}, {"code": "(fn [x]\n\t(let [test-x (conj x [:t1 1] [:t2 2])]\n\t\t(cond \n\t\t\t(= (get test-x :t1) 1) :map\n\t\t\t(= (get test-x [:t1 1]) [:t1 1]) :set\n\t\t\t(= (first test-x) [:t2 2]) :list\n\t\t\t:else :vector)))", "problem": 65, "user": "4e929dd0535dbda64a6f6b05"}, {"code": "(fn [x]\n  (let [ex (empty x)]\n    (cond\n     (= 2 (count (first (conj ex {:b 2})))) :map\n     (= 1 (count (conj ex :b :b))) :set\n     (= :b (first (conj ex :b :a))) :vector\n     :else :list)))", "problem": 65, "user": "4e68ed35535d8ccf87e9fe92"}, {"code": "(fn [coll] (cond\n            (= -1 (:z (conj coll [:z -1]))) :map\n            (= (count (conj coll -1 -1 -1)) (count (conj coll -1 -1 -1 -1 -1))) :set\n            (= [:z -1] (first (conj coll  [:z -2] [:z -1]))) :list\n            (= [:z -1] (last (conj coll [:z -1]))) :vector\n            \n            ))", "problem": 65, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn tst [y] (let [x (conj y [1 2] [3 4])]\n              (let [x2 (conj x (first x))]\n               (if (not= x2 x) (if (= (second x2) (second x)) :vector :list)\n                (if (= x (set x)) :set :map)))))", "problem": 65, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn [in]\n  (let [one-or-more (fn [in]\n    (if (= in (seq in))\n      ; list or vec\n      (if (= :blah (first (conj in :blah)))\n        :list\n        :vector\n      )\n      ; map or set\n      (if (= (set (conj in (first in)) ) in)\n          :set\n          :map\n      )\n    )\n    )]\n    (\n      if (= 0 (count in))\n        (one-or-more (conj in [1 2]))\n        (one-or-more in)\n    )\n  )\n)", "problem": 65, "user": "5005f0fae4b0678c553fc472"}, {"code": "(fn [x]\n  (let [m {{} :map #{} :set}]\n    (cond\n     (contains? m (empty x)) (m (empty x))\n     (= {} (last (conj x :dummy {}))) :vector\n     (= {} (first (conj x :dummy {}))) :list\n     )\n    ))", "problem": 65, "user": "519b7d76e4b02a926d9a436e"}, {"code": "(let [isMap? #(= (count (conj % [:c 1])) (count (conj (conj % [:c 1]) [:c 2])))\n      isSet? #(= (count (conj % :c)) (count (conj (conj % :c) :c)))\n      isList? #(= :d (first (conj (conj % :c) :d)))]\n  #(cond (isMap? %) :map\n         (isSet? %) :set\n         (isList? %) :list\n         true :vector))", "problem": 65, "user": "510b0480e4b078ea719210fa"}, {"code": "(fn [x] (cond\n         (= [1 2 3 4 5 6] x) :vector\n         (identical? [] x) :vector\n         (associative? x) :map\n         (= (set x) x) :set\n         true :list))", "problem": 65, "user": "519e70d5e4b0acf32bc6a42c"}, {"code": "(fn wtf [x]\n  (if (associative? x)\n    (if (reversible? x)\n      :vector\n      :map)\n    (if (= (conj x 1 2) (conj x 2 1))\n      :set\n      :list)))", "problem": 65, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn\n  [xs]\n  (if (nil? (:x (conj xs [:x 1])))\n    (let [test-val1 (if (empty? xs) 1 (inc (apply max xs)))\n          test-val2 (if (empty? xs) 2 (inc test-val1))\n          test-applied-xs (-> xs (conj test-val1) (conj test-val1) (conj test-val2))]\n      (cond\n        (= (count test-applied-xs) (+ 2 (count xs))) :set\n        (= (first test-applied-xs) test-val2) :list\n        :else :vector))\n    :map))", "problem": 65, "user": "51ae350fe4b09397d5109790"}, {"code": "(fn [col]   (letfn [(is-set-or-map? [c]\n             (= (conj c [:a 3])\n                (conj (conj c [:a 3]) [:a 3])))\n          (is-map? [c]  (contains? (conj c [:a 3]) :a))\n          (is-vector? [c] (= 1 (first (conj (conj c 1) 2))))]\n    (if (is-set-or-map? col)\n      (if (is-map? col)\n        :map\n        :set)\n      (if (is-vector? col)\n        :vector\n        :list))))", "problem": 65, "user": "51672d15e4b079759a74a5e7"}, {"code": "(fn\n  [col]\n    (let [typestring (str col)]\n      (cond\n        (= 0 (.indexOf typestring \"{\")) :map                        ; Map string: \"{:a 1}\"\n        (.contains typestring \"clojure.lang.LazySeq\") :list         ; Lazy seq string \"clojure.lang.LazySeq..\"\n        (.contains typestring \"clojure.lang.PersistentList\") :list  ; List string \"()\"\n        (.contains typestring \"[\") :vector                          ; Vector string: \"[1 2 3]\"\n        (.contains typestring \"#\") :set                             ; Set string: \"#{0 10}\"\n        )))", "problem": 65, "user": "51b0359ae4b0c53cf2e68a5f"}, {"code": "#(case (str (first (str %)))\n   \"{\" :map\n   \"#\" :set\n   \"[\" :vector\n   :list)", "problem": 65, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [x] (let [v (into (into x {1 2 3 4}) {1 5})\n              u (into (into x {1 5}) {1 2 3 4})]\n          (cond\n           (= (count v) (+ 2 (count x))) :map\n           (= u v) :set\n           (= [1 5] (first v)) :list\n           (= [1 5] (last v)) :vector)\n          )\n  )", "problem": 65, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [x]\n    (cond \n      (= (count x) (count (conj x {}))) :map\n      (= (+ 1 (count x)) (count (conj x 999 999))) :set\n      (= 999 (last (conj x 998 999))) :vector\n      :else :list\n      ))", "problem": 65, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (= % (apply list %)) :list\n  :else :set)", "problem": 65, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "#(let [a [:x :y]\n       b [:x :z]\n       c (into % [a b])\n       d (count c)]\n  (cond\n    (= d (+ 1 (count %))) :map\n    (= d (count (conj c a))) :set\n    (= (nth c 0) b) :list\n    1 :vector\n    ))", "problem": 65, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [coll]\n  (let [updated (conj coll [:k :v])]\n    (cond\n     (= :v (:k updated)) :map\n     (= updated (conj updated [:k :v])) :set\n     (= :inserted (-> updated (conj :inserted) (nth 0))) :list\n     :else :vector\n     )))", "problem": 65, "user": "51b38769e4b026427ecf067f"}, {"code": "#(condp = (nth (str %) 0)\n   \\{ :map\n   \\c :list\n   \\[ :vector\n   \\# :set)", "problem": 65, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [x]\n  (cond\n    (= :test (get (conj x [:test :test]) :test))\n    :map\n\n    (= 1 (get (frequencies (conj x [:test :test] [:test :test])) [:test :test]))\n    :set\n\n    (= [:test-b :test-b] (last (conj x [:test-a :test-a] [:test-b :test-b])))\n    :vector\n\n    :else\n    :list))", "problem": 65, "user": "51057b2be4b06d28cacc92e8"}, {"code": "(fn bb\n  [coll]\n  (let [p [:_2 :_2] probe (conj coll [:_1 :_1] p)]\n    (cond\n     (:_1 probe) :map\n     (not (nil? (get probe p))) :set\n     (= p (first probe)) :list\n     :else :vector)))", "problem": 65, "user": "511d6a01e4b022853b0e07a5"}, {"code": "#(let [c (conj % [:a 1])\n       c' (conj c [:b 2])]\n   (cond\n    (= [:b 2] (get c' (- (count c') 1))) :vector\n    (= [:a 1] (get c' [:a 1])) :set\n    (= 1 (get c' :a)) :map\n    :else :list\n    ))", "problem": 65, "user": "51bb970be4b0fe3ecfb4644e"}, {"code": "(fn [coll]\n  (let [x (rand-int 100) y (rand-int 100) \n        p [x y] c (conj coll p)]\n    (cond \n      (= y (get c x)) :map\n      (= p (get c p)) :set\n      (= x (last (conj c x))) :vector\n      :else :list)))", "problem": 65, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn guess [x]\n  (let [x' (conj (empty x) [1 2] [0 1] [0 1])]\n    (cond\n      (= (get x' 0) 1) :map\n      (= (get x' 0) [1 2]) :vector\n      (= (count x') 2) :set\n      :else :list\n      )))", "problem": 65, "user": "51a7b4fee4b0da5f497bde8b"}, {"code": "(fn \n  [coll]\n  (let [sym1 (gensym)\n        sym2 (gensym)\n        pair1 [sym1 1]\n        pair2 [sym2 2]\n        coll2 (conj coll pair1)\n        coll3 (conj coll2 pair2)\n        coll4 (conj coll3 pair2)]\n    (cond\n     (get coll2 sym1) :map\n     (= (count coll3) (count coll4)) :set\n     (= pair2 (first coll3)) :list\n     (= pair2 (last coll3)) :vector)))", "problem": 65, "user": "4ebf11bc535dfed6da9c6d9c"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "51c11864e4b0c9c822882943"}, {"code": "#({{} :map #{} :set}\n  (empty %)\n  (if(reversible? %)\n    :vector\n    :list))", "problem": 65, "user": "4fa3c137e4b081705acca193"}, {"code": "#(let [c (conj % nil)] (cond (= c %) :map (= (conj c nil) c) :set (= (drop 1 (conj c false)) c) :list :e :vector))", "problem": 65, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "#(cond\n    (= % (vec %)) \n      (if (= (conj (conj % 1) 2) (conj (conj (vec %) 1) 2))\n        :vector :list)\n    (= % (set %)) :set\n    true :map)", "problem": 65, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [coll]\n  (condp #(contains? %2 %) (conj (empty coll) '[a b])\n    0 :vector, 'a :map, '[a b] :set, :list))\n;;best one from solution imo", "problem": 65, "user": "51533ecde4b0252ac4b16619"}, {"code": "(fn foo [s]\n  (let [ch {true {false :map true :vector} false {false false}}\n        ch1 (get (get ch (associative? s)) (reversible? s))]\n (if ch1\n        ch1\n       (if (= (count (conj s 1 )) (count (conj s 1 1)))\n         :set\n         :list\n       )\n     )\n  \n   \n  \n  ))", "problem": 65, "user": "5180dc04e4b06b8caf33fa01"}, {"code": "(fn black-box-testing [v]\n  (cond\n          (:a (conj v [:a 1])) :map\n          (< (- (count (conj v 1 1)) (count v)) 2) :set\n          (= (conj v 1 2) (cons 2 (cons 1 v))) :list\n          :else :vector))", "problem": 65, "user": "51ca7906e4b08b1cbd0d9487"}, {"code": "(comp #(cond (= % {}) :map (= % #{}) :set (= (conj % 1 2) [1 2]) :vector true :list) empty)", "problem": 65, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn\n  [x]\n  (let\n    [i (count x)]\n    (cond\n     (= (inc i) (count (conj x {:c 3} {:c 4}))) :map\n     (= (inc i) (count (conj x 21 21))) :set\n     (= 22 (last (conj (conj x 21) 22))) :vector\n     :else :list\n     )))", "problem": 65, "user": "51307b84e4b08c712d3fae39"}, {"code": "#(-> % str first\n     {\\[ :vector\n      \\c :list\n      \\( :list\n      \\{ :map\n      \\# :set})", "problem": 65, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn [coll]\n  (let [kv [:a \\a]\n        vs [1 2 3 10 100]\n        mt (empty coll)]\n    (cond\n      (get (conj coll kv) :a)       :map\n      (= vs (into mt vs))           :vector\n      (= (reverse vs) (into mt vs)) :list\n      :else                         :set)))", "problem": 65, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "#(if-not\n  (ifn? %) :list\n   (let [m (conj % [:k :v])]\n     (cond\n       (contains? m :k) :map\n       (contains? m [:k :v]) :set\n       :else :vector)))", "problem": 65, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn bbt [v]\n    (cond\n    (:a (conj v [:a 1])) :map\n    (= (conj v 987 234) (cons 234 (cons 987 v))) :list\n    (> (+ 2 (count v)) (count (conj v 1 1))) :set\n    :else :vector\n    )\n)", "problem": 65, "user": "51d1111ce4b067c36548635f"}, {"code": "#(let [s (str %)]\n   (cond\n    (.startsWith s \"#\") :set\n    (.startsWith s \"{\") :map\n    (.startsWith s \"[\") :vector\n    :else :list))", "problem": 65, "user": "516d2a46e4b06f078fab252f"}, {"code": "(fn [coll]\n  (let [test-data [[:k1 :v1] [:k1 :v1] [:k1 :v2]]\n        poked-coll (into (empty coll) test-data)]\n    (cond\n      (= test-data poked-coll) :vector\n      (= test-data (reverse poked-coll)) :list\n      (= (count poked-coll) 2) :set\n      (= (count poked-coll) 1) :map\n      :else :wtf)))", "problem": 65, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4f79244de4b0fbe0118ec58e"}, {"code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "problem": 65, "user": "51d662fce4b0154f82ab92ef"}, {"code": "(fn ct [xs]\n\t(if (= (inc (count xs)) (count (conj (conj xs {:z 1000}) {:z 1001})))\n\t\t:map\n\t\t(if (= (inc (count xs)) (count (conj (conj xs 1000) 1000)))\n\t\t\t:set\n\t\t\t(if (= (first (conj (conj xs 1000) 999)) 999)\n\t\t\t\t:list\n\t\t\t\t:vector))))", "problem": 65, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn ct[c]\n  (let [mc (conj c [1 2])] \n    (if (= mc (conj mc [1 2])) \n      (if (= (mc 1) 2) :map :set) \n      (if (= (last (conj c 0 1)) 1) :vector :list))))", "problem": 65, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn [seqs]\n  (cond \n        (.contains (str seqs) \"[\") :vector\n        (.contains (str seqs) \"#{\") :set\n   \t\t(.contains (str seqs) \"{\") :map\n   \t\t:else :list\n        ))", "problem": 65, "user": "51da7e49e4b02ceefd947768"}, {"code": "(fn [e]\n  (let [x (empty e)]\n    (cond\n     (= x {}) :map\n     (= x #{}) :set\n     (= (first (conj (conj x 1) 2)) 1) :vector\n     :else :list)))", "problem": 65, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn [x]\n    (if (= 1 (:map (merge x {:map 1})))           \n      :map\n      (if (= 1 (count (filter #(= \"same\" %) (conj x \"same\" \"same\"))))\n        :set\n        (if (= \"last\" (first (conj (conj x \"first\") \"last\")))\n          :list\n          (if (= \"last\" (last (conj (conj x \"first\") \"last\")))\n            :vector)))))", "problem": 65, "user": "4fe15ffee4b0dd6cd5ce3634"}, {"code": "#(cond \n  (= {}  (empty %)) :map \n  (and (= []  (empty %)) (= true (associative? %))) :vector    \n  (and (= '() (empty %)) (= false (associative? %))) :list\n  (= #{} (empty %)) :set  \n    )", "problem": 65, "user": "51ca0f39e4b09ce160bef5b7"}, {"code": "(fn [s]\n  (case (first (str s))\n     \\{ :map\n     \\# :set\n     \\[ :vector\n     :list))", "problem": 65, "user": "50a5f72fe4b0aa96157e2611"}, {"code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "problem": 65, "user": "5110a9b4e4b04c71fce993f3"}, {"code": "#(let [c (into (empty %) [[0 0] [0 1]])]\n    (cond (= 1 (count c)) :map\n          (get c 0) :vector\n          (= [0 0] (first c)) :set\n          true :list))", "problem": 65, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn [col]\n    (let [s1 (keyword (gensym))\n          s2 (keyword (gensym))\n          new-col (reduce conj col [[s1 s1] [s1 s1] [s2 s2] [s2 s2] [s1 s2]])]\n      (cond\n       (= (count new-col) (+ 2 (count col))) :map\n       (= (count new-col) (+ 3 (count col))) :set\n       (= [s1 s2] (last new-col)) :vector\n       :else :list)))", "problem": 65, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn [a]\n  (let [base (empty a)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? a) :vector :list))))", "problem": 65, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn [coll]\n   (prn (conj coll {:a 1}))\n    (cond\n     (= (get (conj coll {:a 1}) :a) 1) :map\n     (= (conj coll :x) (conj coll :x :x)) :set\n     (= (first (conj coll :x :y)) :y) :list\n     :else :vector)\n)", "problem": 65, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [obj]\n  (if (reversible? obj)\n    :vector\n    (if (associative? obj)\n      :map\n      (if (= (count (conj obj 1 1)) (+ (count obj) 2)  )\n        :list\n        :set\n      )\n    )\n  )\n)", "problem": 65, "user": "51db9e1ee4b0e067a9bbadc9"}, {"code": "(fn [col]\n  (let [x {3 5}\n        y {4 6}\n        diff (conj col x)]\n    (cond\n     (= diff (conj diff x)) (if (contains? diff x)      :set\n                                                        :map)\n     (= y (first (conj col (conj col x) y))) :list\n      true\t\t\t\t\t\t             :vector)))", "problem": 65, "user": "51eadb98e4b0f1f103a0d153"}, {"code": "(fn [x]\n  (let [x' (conj x [:a :b] [:a :b])]\n    (if (= (+ (count x) 2)(count x'))\n      (if (= (conj x' :a) (cons :a x'))\n        :list\n        :vector)\n      (if (= (x' :a) :b)\n        :map\n        :set))))", "problem": 65, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn what-is-it\n  [coll]\n  (if (associative? coll)\n    (if (reversible? coll)\n      :vector\n      :map)\n    (if (= (conj coll :test) (cons :test coll))\n      :list\n      :set)))", "problem": 65, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [c] (let [ec (empty c)]\n          (cond (and (associative? c) (coll? (first (into [] (assoc ec 0 :a))))) :map\n                (and (associative? c) (not (coll? (first (into [] (assoc ec 0 :a)))))) :vector\n                (and (not (associative? c)) (= 2 (first (conj ec 1 2)))) :list\n                (and (not (associative? c)) (= 1 (first (conj ec 1 2)))) :set)))", "problem": 65, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [ coll ]\n   (let [ f2 (conj (empty coll) [0 1] [0 1])]\n         (if (= (count f2) 1)\n            (if (= (count (conj f2 [0 2])) 1)\n                :map\n                :set)\n            (if (first (conj f2 false)) \n                :vector\n                :list))))", "problem": 65, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "#({\\c :list \\{ :map \\[ :vector \\# :set} (nth (str %) 0))", "problem": 65, "user": "5046ee3ee4b03b02161376b4"}, {"code": "(fn [thing]\n     ({\\{ :map\n       \\c :list\n       \\[ :vector\n       \\# :set} (first (str thing))))", "problem": 65, "user": "51fa90aae4b0f1313d4689e0"}, {"code": "#(letfn [(coll-type\n           [coll]\n           (if-let [t ({{} :map #{} :set} (empty coll))]\n             t\n             (first\n               (into (empty coll) '(:vector :list)))))]\n   (coll-type %))", "problem": 65, "user": "51fb9d30e4b0f1313d468a0f"}, {"code": "(fn [f]\n    (cond\n      (not (ifn? f)) :list\n      (not (associative? f)) :set\n      (= (empty f) {}) :map\n      :else :vector))", "problem": 65, "user": "501d34f6e4b066e56b9d0b1e"}, {"code": "#(let [e (empty %)]\n   (if (= (count (into e [[1 2] [1 3]])) 1) :map \n     (if (= (count (into e [1 1])) 1) :set\n       (if (= (first (conj (into e [1]) 2)) 1) :vector\n         :list))))", "problem": 65, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn [param] (let [get-first-char (fn [x] (->> (str x) (vec) (first)))\n      whats-it (fn [x] (cond (= \\{ x) :map\n                            (= \\c x) :list\n                            (= \\[ x) :vector\n                            (= \\# x) :set))]\n  ((comp whats-it get-first-char) param)))", "problem": 65, "user": "52016fd3e4b0b2e020a18f10"}, {"code": "(fn black-box [q]\n  (cond\n    (associative? q) (let [s2 (+ (count q) 2)\n                           sab (count (conj q [:a :b] [:a :b]))]\n                       (if (= s2 sab)\n                         :vector\n                         :map))\n    :else (let [s2 (+ (count q) 2)\n                saa (count (conj q :a :a))]\n            (if (= saa s2)\n              :list\n              :set))))", "problem": 65, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "#(let [x (into (empty %) [[:a 42] [:a 42]])] \n   (if (= 1 (count x)) \n     (if (x :a) \n       :map \n       :set) \n     (if (= (first (conj x 42)) 42) \n       :list \n       :vector)))", "problem": 65, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn [s]\n  (let [w (into s [[::a 1] [::b 2] [::b 2]])\n        c (count s)]\n    (println w)\n    (cond\n     (= 1 (::a w)) :map\n     (= 1 (count (filter (partial = [::b 2]) w))) :set\n     (= [::b 2] (first w)) :list\n     :else :vector)))", "problem": 65, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(fn [col]   \n   (let [empty_col (empty col)]  (cond \n                                  (= empty_col  #{}) :set\n                                  (= empty_col   {}) :map\n                                  (reversible? col) :vector \n                                    :else :list )\n                                      )   )", "problem": 65, "user": "4ea8f887535d7eef30807300"}, {"code": "(fn [x]\n  (let [ex (empty x)\n        t (conj ex [:a 0] [:a 0] [:a 1])\n        ct (count t)]\n    (cond (= 1 ct) :map\n          (= 2 ct) :set\n          (= 3 ct) (if (= [:a 1] (last t))\n                     :vector\n                     :list))))", "problem": 65, "user": "51e00020e4b01188f0627534"}, {"code": "(fn [s]\n   (let [p (conj s [1 2] [1 2] [2 1])]\n     (if (= (count p) (+ 3 (count s)))\n       (if (= [2 1] (first p))\n         :list\n         :vector)\n       (if (= 1 (get p 2))\n         :map\n         :set))))", "problem": 65, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond \n     (:a t) :map\n     (get t 0) :vector\n     (get t [:a :b]) :set\n     :else :list)))", "problem": 65, "user": "51fa7154e4b0f1313d4689da"}, {"code": "(fn black-box [s]\n  (cond\n   (and (associative? s) (reversible? s)) :vector\n   (and (associative? s) (not (reversible? s))) :map\n   (= s (conj s (first s))) :set\n   (and (empty? s) (= 1 (count (conj (conj s 1) 1)))) :set\n   :else :list))", "problem": 65, "user": "51d360d1e4b099f3b6acddff"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n  (cond\n   (= base {}) :map\n   (= base #{}) :set\n   (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "520a86fee4b01da9d47a99de"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "51e780dae4b0730ab87cf353"}, {"code": "(fn [xs]\n  (let [e (empty xs)]\n    (cond\n      (= 1 (count (conj e [:a 1] [:a 2]))) :map\n      (= 1 (count (conj e [:a 1] [:a 1]))) :set\n      (= [1 2] (conj e 1 2)) :vector\n      :else :list)))", "problem": 65, "user": "52015698e4b0d7096e99ddba"}, {"code": "#(case (empty %)\n   {} :map\n   #{} :set\n   [] (if (= [1 2] (conj (empty %) 1 2))\n        :vector\n        :list))", "problem": 65, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "#(condp = (first (str %))\n   \\[ :vector\n   \\{ :map\n   \\# :set\n   :list)", "problem": 65, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(comp #({\\{ :map \\# :set \\[ :vector \\( :list} % :list) first str)", "problem": 65, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn test\n  [x]\n  (let [base (empty x)]\n    (cond\n      (= {} base) :map\n      (= #{} base) :set\n      :else (if (reversible? base) :vector :list))))", "problem": 65, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn [xs]\n  (let [es (empty xs)]\n    (cond \n     (= (rest es) es)\n       (if (= (conj es 1 2) [1 2])\n         :vector\n         :list)\n     (= (set es) es) :set\n     :else :map)))", "problem": 65, "user": "513fab65e4b00f13ea1bd891"}, {"code": "#(let [mkey (gensym)\n       test (conj % [mkey 0] [mkey 0] [mkey 1])]\n   (cond (= (count test) (inc (count %))) :map\n    \t (= (count test) (+ 2 (count %))) :set\n         (= (take 2 test) [[mkey 1] [mkey 0]]) :list\n         (= (take 2 (reverse test)) [[mkey 1] [mkey 0]]) :vector))", "problem": 65, "user": "51f9527fe4b09be9c177e549"}, {"code": "#(get {\\# :set \\{ :map \\( :list \\[ :vector} \n\t(first (.toString %)) :list)", "problem": 65, "user": "520242bae4b030ee0c5b26e3"}, {"code": "#(let [base (empty %)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? %) :vector :list)))", "problem": 65, "user": "51ba4482e4b0fe3ecfb4642b"}, {"code": "#({\\[ :vector \\( :list \\{ :map \\# :set \\c :list} (first (str %)))", "problem": 65, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "51dc1202e4b09c47a74ce107"}, {"code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond\n     (reversible? e)  :vector\n     (associative? e) :map\n     (= '(2 1) (conj e 1 2)) :list\n     :else :set)))", "problem": 65, "user": "4ee528fb535d1385b2869d87"}, {"code": "(fn [x]\n  (let [idemp (= (conj x [:x :y]) (conj x [:x :y] [:x :y]))]\n    (cond\n      (and idemp (associative? x)) :map\n      idemp :set\n      (associative? x) :vector\n      :default :list)))", "problem": 65, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn [coll]\n  (let [coll (conj coll [:hi 'there])]\n    (cond\n     (not (ifn? coll)) :list\n     (contains? coll :hi) :map\n     (contains? coll [:hi 'there]) :set\n     :else :vector)))", "problem": 65, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn [x]\n  (if (associative? x)\n    (if (reversible? x) :vector :map)\n    (let [a (conj x 1 1) b (conj x 1)]\n      (if (= (count a) (count b)) :set :list))))", "problem": 65, "user": "52016690e4b0b2e020a18f0f"}, {"code": "(fn [x]\n  (cond\n    (= \"{}\" (str (empty x))) :map\n    (= (inc (count x)) (count (conj x :test :test))) :set\n    (= :test2 (last (conj x :test1 :test2))) :vector\n    (= :test2 (first (conj x :test1 :test2))) :list\n    :else :unknown))", "problem": 65, "user": "51caca2ae4b068dadb8f2226"}, {"code": "(fn [xs]\n  (if (get (conj xs [:a 5]) :a)\n    :map\n    (let [ys (conj (conj (conj xs 5) 100) 100)\n          count-100 (count (filter #{100} ys))]\n      (cond\n       (and (> count-100 1) (= (first ys) 100)) :list\n       (and (> count-100 1) (= (last ys) 100)) :vector\n       :else :set))))", "problem": 65, "user": "51ef31dfe4b0871fa145d9a0"}, {"code": "(fn [x]\n  (let [xt (into (into x {:1 :2}) {:3 :4})]\n    (cond (= (first xt) [:3 :4]) :list\n          (:1 xt) :map\n          (get xt [:1 :2]) :set\n          (= (last xt) [:3 :4]) :vector)))", "problem": 65, "user": "5092425ee4b09a7d0b586de4"}, {"code": "(fn [coll]\t(let [base (empty coll)]\n\t\t(cond\n\t\t\t(= base {}) :map\n\t\t\t(= base #{}) :set\n\t\t\t(= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "51bdc609e4b0ff155d51d2b3"}, {"code": "#(cond\n  (= (count (conj % [0 0]))\n     (count (conj % [0 0] [0 1]))) :map\n  (= (conj % 0) (conj % 0 0)) :set\n  (= (next (conj % 0 1)) (conj % 0)) :list\n  :else :vector)", "problem": 65, "user": "521679e9e4b0bf4bffd29cca"}, {"code": "(fn f [st]\n  (let [ans (empty st)]\n    (if (= 1 (count (into ans [[1 2] [1 3]])))\n      :map\n      (if (= 1 (count (into ans [[1 2] [1 2]])))\n        :set\n        (let [aa (conj ans 1 2)]\n          (if (= 1 (first aa))\n            :vector\n            :list\n            ))))))", "problem": 65, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn [x]\n  (if (=(count x) (count (conj x nil)))\n    :map\n    (let [t (conj x :test)]\n    (if (= (count t) (count (conj t :test)))\n       :set\n        (if (= (first (conj x :x :y)) :y)\n          :list\n          :vector)))))", "problem": 65, "user": "51dd9370e4b0c33a4e1da40c"}, {"code": "(fn ctype [coll]\n  (let [coll (empty coll)]\n    (if (= ::b (get (conj coll [::a ::b]) ::a))\n      :map\n      (let [s ::special1\n            aft (-> coll (conj s) (conj s))]\n        (if (= 1 (- (count aft) (count coll)))\n          :set\n          (if (= s (-> coll (conj s) (conj ::special2) first))\n            :vector\n            :list))))))", "problem": 65, "user": "4dac39a28cc9d6edb8beb0b3"}, {"code": "(fn [x]\n  (let [y (conj x [1 2] [3 4])]\n    (if (= 0 (count (flatten y)))\n      (if (get y [1 2]) :set :map)\n      (if (= (first y) [3 4]) :list :vector))))", "problem": 65, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn bb ([aseq]\n          (cond\n           (= {} (empty aseq)) :map\n           (= #{} (empty aseq)) :set\n           (= '() (empty aseq))\n             (if (= 99 (first (conj (conj aseq 98) 99)))\n               :list\n               :vector)\n           )\n          ))", "problem": 65, "user": "522afe78e4b0d34ee08e71b3"}, {"code": "(fn id-seq\n  [s]\n  (let [empty-coll (empty s)]\n    (if (= {} empty-coll) :map\n      (if (= #{} empty-coll) :set\n        (let [coll (-> empty-coll (conj 1) (conj 2))]\n          (if (-> coll first (= 2)) :list\n               :vector))))))", "problem": 65, "user": "51701a9ce4b034fe8eaf70f5"}, {"code": "#(let [base (empty %)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? %) :vector :list)))", "problem": 65, "user": "4ed2a92b535d44c135fd68dc"}, {"code": "(fn [coll]\n    (let [canary [:canary-key :canary-value]\n          miner  [:miner-key  :miner-value]\n          conjoined (conj coll canary miner)]\n      (cond (get conjoined :canary-key)\n            :map\n            (= conjoined (conj conjoined canary))\n            :set\n            (= (first conjoined) miner)\n            :list\n            (= (last conjoined) miner)\n            :vector\n  )))", "problem": 65, "user": "52244a77e4b01819a2de42d1"}, {"code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n    (if (= 1 (count result))\n      :map (if (= 2 (count result))\n             :set (if (= [1 3] (first result))\n                    :list :vector )))))", "problem": 65, "user": "514fd753e4b0b449e54b8e00"}, {"code": "(fn findtype [coll]\n              (let [xs (empty coll)]\n                (cond\n                  (= xs #{}) :set\n                  (= xs {}) :map\n                  (= xs '()) (if (reversible? xs) :vector :list))))", "problem": 65, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn blackbox [s]  \n  (cond \n   (= (conj s {}) s) :map   \n   (empty? s) (cond\n               (= (clojure.set/union s #{}) #{}) :set\t\n               (= (conj (conj s 0) 1) [0 1]) :vector\t   \n               :else :list)  \n   (= (clojure.set/union s s) s) :set   \n   (= (first (conj s s)) s) :list  \n   :else :vector))", "problem": 65, "user": "51ce1320e4b0e42293a22551"}, {"code": "(fn\n  [coll]\n  (let [ecoll (empty coll)]\n    (cond (= ecoll '()) (if (reversible? ecoll) :vector :list)\n          (= ecoll {}) :map\n          (= ecoll #{}) :set)))", "problem": 65, "user": "510591dde4b06d28cacc92eb"}, {"code": "(fn [x] (cond (reversible? x) :vector (associative? x) :map :else (let [m (conj x 3 3) n (count x)] (if (= (count m) (+ 2 n)) :list :set))))", "problem": 65, "user": "5065faf9e4b0313a384e5645"}, {"code": "(fn type-test [x ] \n\t(let [base (empty x )] \n\t\t(cond \n\t\t\t(= base #{}) :set \n\t\t\t(= base {}) :map \n\t\t\t:else \n\t\t\t(if (reversible? base) :vector :list))))", "problem": 65, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn [s] (let [s-str1 (first (str s))] (cond (= s-str1 \\{) :map (= s-str1 \\() :list (= s-str1 \\[) :vector (= s-str1 \\#) :set (= s-str1 \\c) :list :else :other)))", "problem": 65, "user": "5235a902e4b0a643f2dcb750"}, {"code": "(fn [s]\n  (cond (empty? s) (if (= 1 (count (conj (conj s [1 2]) [1 2])))\n                     (if (contains? (conj s [1 2]) 1)\n                       :map\n                       :set)\n                     (if (= 2 (first (conj s 1 2)))\n                       :list\n                       :vector))\n        :else (if (= s (conj s (first s)))\n                (if (contains? s (first s))\n                  :set\n                  :map)\n                (if (= s (first (conj s s)))\n                  :list\n                  :vector)\n                )\n  ))", "problem": 65, "user": "5213ffd3e4b0961f15ac4d7d"}, {"code": "(fn [coll]\n  (cond \n   (= (get (conj coll [:foo \"bar\"]) :foo ) \"bar\") :map\n   (= (conj coll :x) (conj (conj coll :x) :x)) :set\n   (= 1 (last (conj (conj  (conj coll :x) :x) 1))) :vector\n   (= 1 (first (conj (conj  (conj coll :x) :x) 1))) :list\n   ))", "problem": 65, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [coll]\n  (let [a (rand-int 10)\n        b (rand-int 10) \n        c [a b]\n        d (conj coll c)]\n    (cond \n      (= b (get d a)) :map\n      (= c (get d c)) :set\n      (= a (last (conj d a))) :vector\n      :else :list)))", "problem": 65, "user": "518a59b3e4b02bf06f6bbb4b"}, {"code": "(fn [coll]\n  (cond (and (associative? coll) (not (sorted? coll)) (counted? coll) (reversible? coll)) :vector\n        (and (associative? coll) (not (sorted? coll)) (counted? coll) (not (reversible? coll))) :map\n        (ifn? coll) :set\n        :else :list))", "problem": 65, "user": "51857e64e4b0da5a5be3babe"}, {"code": "#(cond\n    (reversible? %) :vector\n    (associative? %) :map\n    (< (count (conj % 2)) (count (conj % 2 2))) :list\n    :else :set)", "problem": 65, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn blackbox [s]\n  (cond\n   (= (conj s {}) s) :map\n   (empty? s) (cond\n         (= (clojure.set/union s #{}) #{}) :set\n               (= (conj (conj s 0) 1) [0 1]) :vector\n               :else :list)\n   (= (clojure.set/union s s) s) :set\n   (= (first (conj s s)) s) :list\n   :else :vector))", "problem": 65, "user": "50aa60bee4b056ee01935865"}, {"code": "(fn [coll]\n  (let [ccoll (conj coll coll)]\n    (cond (= coll ccoll) :map\n          (= ccoll (conj ccoll coll)) :set\n          (= (first (conj ccoll [coll coll])) [coll coll]) :list\n          :else :vector)))", "problem": 65, "user": "51269362e4b083bb8f88cf09"}, {"code": "(fn data-poke [s]\n  (let [t {1 1}\n        d {1 2}\n        c (count s)\n        m-test (conj s t t)\n        l-test (conj s t d)]\n    (if (= (+ 1 c) (count m-test))\n      (if (= (first m-test) t)\n        :set\n        :map)\n      (if (= (first l-test) d)\n        :list\n        :vector))))", "problem": 65, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn test-seq [l]\n  (if (associative? l) ; vector or map\n    (if (reversible? l) :vector :map)\n    (let [x \"diu\" n (count l)]\n      (if\n        (= (+ n 2)\n          (->\n            l\n            (conj x)\n            (conj x)\n            (count)\n          )\n        )\n        :list\n        :set\n      )\n    )\n  )\n)", "problem": 65, "user": "51f09f3de4b0274c496158d7"}, {"code": "(fn classify [coll]\n  (let [x (gensym)\n        y (gensym)]\n    (cond (= y (get (conj coll [x y]) x))\n          :map\n          (= (inc (count coll)) (count (into coll [x x])))\n          :set\n          (= x (first (conj (conj coll y) x)))\n          :list\n          (= x (last (conj (conj coll y) x)))\n          :vector)))", "problem": 65, "user": "52485f02e4b05ef8e38e63d3"}, {"code": "(fn [x]\n  (letfn [(map-or-set? [x]\n           (if (seq x)\n             (= x (apply conj x x))\n             (map-or-set? (conj x [0 0]))))\n          (decide-map-or-set [x]\n           (let [item (if (seq x)\n                        (first x)\n                        [:foo :foo])\n                 x' (conj x item)]\n             (if (x' item)\n               :set\n               :map)))\n          (decide-vector-or-list [x]\n           (if (seq x)\n             (let [item (if (and (seq x) (= (first x) :foo))\n                          :bar\n                          :foo)]\n               (if (= item (first (conj x item)))\n                 :list\n                 :vector))\n             (decide-vector-or-list (conj x :bar))))]\n    (if (map-or-set? x)\n      (decide-map-or-set x)\n      (decide-vector-or-list x))))", "problem": 65, "user": "52487654e4b05ef8e38e63dc"}, {"code": "(fn [s]\n  (let [dum (conj s [:xxxx 0])\n        res (conj dum [:z 9])\n        upd (conj res [:z 9])]\n    (cond \n     (and (= res upd) (= (get res [:z 9]) [:z 9])) :set\n     (= (get res :z) 9) :map\n     (= (last res) [:z 9]) :vector\n     (= (first res) [:z 9]) :list)))", "problem": 65, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn bb-test- [coll]\n  (cond\n   (= (conj coll {}) coll) :map\n   (= (first (conj coll {:c 3})) (first (conj (conj coll {:c 3}) {:d 4})))\n   (if (= (+ (count '(11 12 11)) (count coll)) (count (apply merge coll '(11 12 11))))\n     :vector\n     :set)\n   :else :list))", "problem": 65, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [coll] (condp = ((juxt associative? reversible? ifn?) coll)\n [true true true] :vector\n [false false false] :list\n [true false true] :map\n [false false true] :set))", "problem": 65, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [smth]\n  (let [tv [:test :test]\n        tm [:test :best]]\n    (cond\n      (= (:test (conj smth tv tm)) :best) :map\n      (= (count (conj smth tv)) (count (conj smth tv tv))) :set\n      (= tm (first (conj smth tv tm))) :list\n      :else :vector)))", "problem": 65, "user": "5245fbbbe4b09dbe66b56183"}, {"code": "(fn [s] \n  (let [[m e] [{{} :map [] :vector #{} :set} (empty s)]]\n    (if (= :vector (m e))\n      (first (conj e :vector :list))\n      (m e))))", "problem": 65, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn [x]\n  (let [x' (conj x [:key :val])]\n    (cond\n     (= (get x' :key) :val) :map\n     (= (get x' [:key :val]) [:key :val]) :set\n     :else (let [x'' (conj x' :v)]\n             (if (= (first x'') :v)\n               :list\n               :vector)))))", "problem": 65, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn _ [coll] \n  (let [c (empty coll), data [1 2]]\n    (case c\n      {} :map\n      #{} :set\n      [] (if (= data (into c data)) :vector :list))))", "problem": 65, "user": "524ea587e4b0541d1855b7e9"}, {"code": "(fn [col]\n  (if (empty? col)\n    (cond  (= col {}) :map\n           (= col #{}) :set\n           (= (last (conj col 1 2)) 2) :vector\n           :else :list)\n    (let [x (first (set col))]\n      (cond\n       (= (count col) (count (conj col x)))\n       (if (col x) :set :map)\n       (= (last (conj col :different)) :different)\n       :vector\n       :else\n       :list))))", "problem": 65, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "#({{3 4, 1 2}     :map\n   #{[3 4] [1 2]} :set\n   [[1 2] [3 4]]  :vector\n   '([3 4] [1 2]) :list} (conj (empty %) [1 2] [3 4]))", "problem": 65, "user": "508923d5e4b06d8254e936e8"}, {"code": "(fn [y]\n  (let [x (empty y)]\n  (cond\n   (= {} x) :map\n   (= #{} x) :set\n   (= '() x) (if (reversible? y) :vector :list) \n   )))", "problem": 65, "user": "5252045ae4b0541d1855b884"}, {"code": "(fn [coll]\n  (let [tval1 [:test1 :test2]\n        tval2 [:test3 :test4]\n        tcoll (conj coll tval1 tval2)]\n    (cond\n     (= :test2 (get tcoll :test1)) :map\n     (= (count (conj tcoll tval1)) (count tcoll)) :set\n     (= tval2 (first tcoll)) :list\n     (= tval2 (last tcoll)) :vector)))", "problem": 65, "user": "524b90fae4b09eba1c0223df"}, {"code": "#(if (ifn? %) ({{} :map, #{} :set, [] :vector} (empty %)) :list)", "problem": 65, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn __\n  [coll]\n  (if (= (empty coll) #{})\n    :set\n    (if (= (empty coll) {})\n      :map\n      (if (= 2 (last (conj coll 1 2)))\n        :vector\n        :list\n      )\n    )\n  )\n)", "problem": 65, "user": "52485723e4b05ef8e38e63d2"}, {"code": "#(let [c (conj % [:x :y] [:x :y] [:q :r])]\n    (cond (= (get c :x) :y) :map\n          (= (+ 2 (count %)) (count c)) :set\n          (= (first c) [:q :r]) :list\n          :else :vector))", "problem": 65, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn [x] \n  (let [x (empty x)] \n    (if (= :a (get (conj x [1 :a]) 1))\n      :map\n      (if (= #{:a} (conj x :a :a))\n        :set\n        (if (= [:a :b] (conj x :a :b))\n          :vector\n          :list)))))", "problem": 65, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn [x]\n  (cond (= x (conj x x))\n        :map\n        (= (inc (count x)) (count (conj (conj x :symbol) :symbol)))\n        :set\n        (= :symbol2 (first (conj x :symbol1 :symbol2)))\n        :list\n        :else :vector))", "problem": 65, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [coll]\n    (if (associative? coll)\n      (if (reversible? coll)\n        :vector ; or sorted-map\n        :map)\n      (if (contains? (conj coll :element) :element)\n        :set\n        :list)\n      )\n    )", "problem": 65, "user": "52213426e4b0e6a83c8925c4"}, {"code": "(fn [coll]\n    (let [e (empty coll)]\n    \t (cond\n\t \t (= {} e) :map\n\t\t (= #{} e) :set\n         (= (conj (conj coll 1) 2) (cons 2 (cons 1 coll))) :list\n    \t\t :else  :vector)))", "problem": 65, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "52488a46e4b05ef8e38e63e0"}, {"code": "#(let [c (conj (empty %) [0 1])]\n    (condp = (get c 0)\n      1 :map\n      [0 1] :vector\n      (if (= 1 (count (conj c [0 1]))) :set :list)\n      ))", "problem": 65, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn black-box-test [s]\n  (let [marker [:m2 :flag]\n        t (conj s [:marker :marker])\n        t2 (conj t marker)]\n    (cond\n     (= (get t :marker) :marker) :map\n     (= (get t2 marker) marker) :set\n     (= (last t2) marker) :vector\n     (= (first t2) marker) :list\n     :else :set)))", "problem": 65, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn check-type [coll]\n  (let [coll-m (conj coll {:w :x :y :z})]\n\t(if (= (+ 2 (count coll)) (count coll-m))\n\t    :map\n      (let [coll-c (conj coll :z :z :x)]\n        (if (= (+ 2 (count coll)) (count coll-c))\n\t      :set\n\t      (if (= (last coll-c) :x)\n\t          :vector\n\t        :list))))))", "problem": 65, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [coll] \n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "51622fb8e4b009fba0926e3f"}, {"code": "(fn [x_]\n  (let [x (empty x_)\n        a (= (count (conj (conj x [:a :b]) [:a :b])) (count (conj x [:a :b])))\n        b (= (first (conj (conj x [:a :b]) [:c :d])) [:a :b])]\n    (if a\n      (if b\n        :set\n        :map)\n      (if b\n        :vector\n        :list))))", "problem": 65, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn seq-type [coll]\n(let [base (empty coll)]\n(cond\n(= base {}) :map\n(= base #{}) :set\n(= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "5243e37ae4b076204b44fae3"}, {"code": "#(let [c (conj (empty %) [1 2] [1 3] [1 3]) n (count c)] (if (= n 1) :map (if (= n 2) :set (if (= (first c) [1 2]) :vector :list))))", "problem": 65, "user": "525b0b51e4b0cb4875a45d01"}, {"code": "(fn [coll]\n  (let\n    [xs (conj (empty coll) [4 3] [2 1] [4 2] [2 1])\n     n  (count xs)\n     x  (first xs)]\n    (cond\n     (= n 2) :map\n     (= n 3) :set\n     (= x [2 1]) :list\n     true :vector)))", "problem": 65, "user": "52618ea3e4b03e8d9a4a7064"}, {"code": "(fn [coll]\n    (let [c (conj coll [0 0])]\n      (cond\n       (= (count c) (count (conj c [0 1]))) :map\n       (= (count c) (count (conj c [0 0]))) :set\n       :else \n       \t(let [c1 (conj coll 0)\n              c2 (conj c1 (inc (apply max c1)))]\n          (if (> (first c2) (apply max c1)) \n            :list\n            :vector\n            )\n          )\n       )\n      )\n  )", "problem": 65, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn [item]\n  (cond\n   (= {} item) :map\n   (= #{} item) :set\n   (= (count item) (count (flatten item))) \n   (if (= (first (conj (conj item 1) 2)) 2)\n     :list\n     :vector)   \n   (= [] item) :vector\n   (= '() item) :list\n   (= () item) :list\n   (= (set item) item) :set\n   :default :map))", "problem": 65, "user": "523288fee4b035af41902a88"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "525873e8e4b0cb4875a45cb2"}, {"code": "(fn [x] (if (= :b (get (merge x {:a :b}) :a)) :map \n          (if (= (count (conj (conj x :sentinal) :sentinal)) (inc (count x))) :set \n            (if (= (first (conj (conj x :sentinal-1) :sentinal-2)) :sentinal-2) :list :vector)\n          )\n        )\n  )", "problem": 65, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn [xs]\n  (case (empty xs) \n    {} \t:map\n    [] \t(if (identical? (empty xs)()) :list :vector)\n    #{} :set))", "problem": 65, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "#(or (and (get (conj (empty %) [:a nil]) 0) :vector) ({{} :map #{} :set '() :list} (empty %)))", "problem": 65, "user": "4f2f7e87e4b0d6649770a06f"}, {"code": "(fn [xs]\n       (let [new-val [xs xs]\n             new-xs (conj xs new-val)]\n         (cond (= new-xs (conj new-xs new-val))\n               ;; Either a map or a set\n               (if (contains? new-xs xs)\n                 :map\n                 :set)\n               (= (cons 1 (cons 0 xs)) (conj (conj xs 0) 1))\n               :list\n               :else :vector)))", "problem": 65, "user": "524f213be4b0541d1855b7ff"}, {"code": "#(let [n (conj % [:c 3])]\n   (cond \n    (= (:c n) 3) :map\n    (= (count (conj n [:c 3])) (count n)) :set\n    (= (last (conj n [:d 4])) [:d 4]) :vector\n    (= (first (conj n [:d 4])) [:d 4]) :list))", "problem": 65, "user": "526c6e08e4b03e8d9a4a7290"}, {"code": "(fn [-s]\n              (let [\n                    -seq (conj (conj -s [:z 99]) [:x 77])\n                    -first (first -seq)\n                    -new-seq (conj -seq -first)\n                    -new-seq-bis (conj -seq [:z 100])\n                    ]\n                (if (= (count -new-seq) (count -seq))\n                  (if (= (count -new-seq-bis) (count -seq))\n                    :map\n                    :set)\n                  (if (= (last -new-seq) -first)\n                    :vector\n                    :list\n                    )\n                  )\n                )\n        )", "problem": 65, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn myBlackBoxTesting\n  [coll]\n  (let [modColl (conj coll (first coll))]\n    (if (= (count modColl) (count coll))\n      (if (contains? coll (first coll))\n        :set\n        :map)\n      (if (empty? coll)\n        (if (= (count (conj modColl 1 1)) 2)\n          :set\n          (if (= (conj modColl 1 1) '(1 1 nil))\n            :list\n            :vector))\n        (if (= modColl (cons (first coll) coll))\n        :list\n        :vector)))))", "problem": 65, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "#(if (= (conj % %) %) :map\n\t(if (= (conj (conj % 2) 2) (conj % 2)) :set\n\t\t(if (and (= (first (conj % 2)) 2) (= (first (conj (conj % 2) 3)) 3)) :list\n\t\t\t:vector\n)))", "problem": 65, "user": "525de512e4b0cb4875a45d8a"}, {"code": "(fn [coll]\n  (let [firstChar (.charAt (.toString coll) 0)]\n    (condp = firstChar\n      \\# :set\n      \\{ :map\n      \\[ :vector\n         :list)))", "problem": 65, "user": "51df825de4b01188f062752b"}, {"code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "problem": 65, "user": "52655949e4b03e8d9a4a710b"}, {"code": "(fn [a]\n    (cond\n     (= #{} (empty a)) :set\n     (=  {} (empty a)) :map\n     (= 1 (first (conj (empty a) 1 2))) :vector\n     :else                              :list))", "problem": 65, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [s]\n  (if (associative? s)\n    (if (reversible? s) :vector\n      :map)\n    (if (= (conj s -1) (conj (conj s -1) -1)) :set\n    :list)))", "problem": 65, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn [s]\n  (let [p1 [:foobar :y]\n        p2 [:y :z]\n        r (conj s p1 p1 p2)]\n    (if (contains? r :foobar)\n      :map\n      (if (< (count r) (+ (count s) 3))\n        :set\n        (if (= p2 (first r))\n          :list\n          :vector\n          )))))", "problem": 65, "user": "4f90dc2ae4b0dcca54ed6c92"}, {"code": "(fn [c]\n  (letfn [\n  (isMap [m] (let [s (conj m [:a 1])] (= (:a s) 1)))\n  (isVector [v] (let [s (conj v 1 2)] (= 2 (last s))))\n  (isSet [s] (let [x (conj s 1 1)] (<= (count x) (inc (count s)))))\n  ]\n    (cond\n     (isMap c) :map\n     (isSet c) :set\n     (isVector c) :vector\n     :else :list\n     )\n   ))", "problem": 65, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn p065 [m]\n  (cond\n   (:c (conj m [:a :b] [:c :d])) :map\n   (= (count (conj m [:a :b])) (count (conj m [:a :b] [:a :b]))) :set\n   (= [:c :d] (last (conj m [:a :b] [:c :d]))) :vector\n   true :list))", "problem": 65, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn coll-type [coll]\n  (let [c (into coll [[nil 0] [nil 0]])]\n    (cond\n      (apply distinct? c) (if (nil? (get c nil))\n                            :set\n                            :map)\n      :else (if (= (first c) 0)\n              :vector\n              (if (= (first (conj c 0)) 0)\n                :list\n                :vector)))))", "problem": 65, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn bbtst [s]\n  (let [n (count s)\n        new-s (conj s [:a 1] [:a 1])\n        new-n (count new-s)]\n    (if (= (- new-n n) 2)\n      (if (= new-s (first (conj new-s new-s)))\n        :list\n        :vector)\n      (if (not= 1 (:a new-s))\n        :set\n        :map))))", "problem": 65, "user": "523c6451e4b07becd5be2222"}, {"code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "problem": 65, "user": "5249a506e4b05ef8e38e646d"}, {"code": "(fn [s]\n      (cond (= (conj s {}) s) :map\n            (empty? s) (cond (= (clojure.set/union s #{}) #{}) :set\n                             (= (conj (conj s 0) 1) '(1 0)) :list\n                             :else :vector)\n            (= (rest (conj s 1)) s) :list\n            (= (clojure.set/union s s) s) :set\n            :else :vector\n      )\n    )", "problem": 65, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn a [col] (cond  (reversible? col) (identity :vector)(associative? col) (identity :map) (ifn? col) (identity :set) :else (identity :list)))", "problem": 65, "user": "527a8eb7e4b03e8d9a4a755f"}, {"code": "(fn [src] \n \t(let [tt1 [:tk1 :tv1] tt2 [:tk2 :tv2] \n          cnjtk (conj(conj(conj src tt1)tt2)[0 0])\n          cnjv (conj src [0 0])]\n \t\t (cond \n           (and (= (last cnjtk) [0 0]) (= (last (butlast cnjtk)) tt2)) :vector\n           (= (get cnjtk :tk1) :tv1) :map\n           (= (conj cnjtk tt1) cnjtk) :set\n           :else :list\n          )\n     )\n )", "problem": 65, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "#(cond (= (:k (conj % [:k :v])) :v) :map\n       (= (:v (conj % :v)) :v) :set\n       (= (conj % :v2 :v1) (cons :v1 (cons :v2 %))) :list\n       :else :vector)", "problem": 65, "user": "4fe98ddae4b0547ebccb2463"}, {"code": "(fn [x]\n  (if (empty? x)\n    (cond (= {} x) :map\n          (= #{} x) :set\n          (= :b (first (conj (conj x :a) :b))) :list\n          :else :vector)\n    (let [a (conj x (first x))]\n      (cond (= (count a) (count x)) (if (nil? (get x (first x))) :map :set)\n            (identical? (first a) (second a)) :list\n            (identical? (first a) (last a)) :vector))))", "problem": 65, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [n] (let [e (str (empty n))\n              out {:list \"clojure.lang.PersistentList$EmptyList@1\" :vector \"[]\" :set \"#{}\" :map \"{}\"}\n              key-for (fn [d k] (first (filter #(not (= % false)) (for [pair d] (if (= k (second pair)) (first pair) false)))))]\n  (key-for out e)))", "problem": 65, "user": "4e0359e8535d04ed9115e792"}, {"code": "(fn [x]\n  (let [c (first (re-seq #\"^.\" (str x)))]\n    (case c\n      \"{\" :map\n      \"c\" :list\n      \"[\" :vector\n      \"#\" :set\n      nil)))", "problem": 65, "user": "5213d7aae4b0961f15ac4d72"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "52851da0e4b0239c8a67adea"}, {"code": "(fn [a-seq]\n  (let [x 40\n        y 90\n        p [x y]\n        c (conj a-seq p)]\n    (cond (= y (get c x)) :map\n          (= p (get c p)) :set\n          (= x (last (conj c x))) :vector\n          :else :list)))", "problem": 65, "user": "52890634e4b0239c8a67ae5e"}, {"code": "#(let [blbx (conj % [:foo 42] [:foo 42] [:foo 43])]\n   (cond (= (count blbx) (+ (count %) 2)) :set\n         (= (count blbx) (inc (count %))) :map\n         (= (first blbx) [:foo 43])       :list\n         :else                            :vector))", "problem": 65, "user": "519ef784e4b087743fad2198"}, {"code": "#(if (associative? %)                                \n  (if (reversible? %)                                \n    :vector                                          \n    :map )                                           \n  (if (= (count (conj (conj % 9) 9)) (+ (count %) 1))\n    :set                                             \n    :list ) )", "problem": 65, "user": "4df20dda535d08e6dec9fe23"}, {"code": "(fn [input]\n    (cond\n     (= input (conj input {})) :map\n     (= (conj input :ololo) (conj (conj input :ololo) :ololo)) :set\n     (= (first (conj (conj input :ololo) :ahaha)) :ahaha) :list\n     (= (last  (conj (conj input :ololo) :ahaha)) :ahaha) :vector\n    ))", "problem": 65, "user": "528bba38e4b0239c8a67aea9"}, {"code": "(fn [c] (let [inst? (fn [c x] (. c (isInstance x)))]\n            (if (inst? clojure.lang.IPersistentVector c) :vector\n              (if (inst? clojure.lang.IPersistentSet c) :set\n                (if (inst? clojure.lang.IPersistentMap c) :map :list)))))", "problem": 65, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "527dc2aee4b0757a1b17138d"}, {"code": "(fn find-out [xs]\n  (let [g    (gensym)\n        gs   [0 g]\n        gs2  [0 :a]\n        yxs  (conj (conj xs [1 :b]) gs)\n        yxs2 (conj yxs gs2)\n        x    (first yxs)\n        xxs  (conj yxs x)]\n    (cond\n      (= :a (get yxs2 0)) :map\n      (= yxs xxs)         :set\n      (= gs (first yxs))  :list\n      (= gs (last  yxs))  :vector)))", "problem": 65, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn [coll](let [len (count coll) \n                tri (conj coll coll coll) \n                tri2 (conj coll tri coll)]\n            (cond \n          \t(= len (count tri)) :map\n          \t(= (inc len) (count tri)) :set\n            (= coll (first tri2)) :list\n            (= coll (last tri2)) :vector\n             )  \t\n          ))", "problem": 65, "user": "526a3412e4b03e8d9a4a721e"}, {"code": "(fn [s]\n  (cond\n   (reversible? s) :vector\n   (associative? s) :map\n   (ifn? s) :set\n   :else :list))", "problem": 65, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "#({\\{ :map \\# :set \\[ :vector \\c :list } (nth (str %) 0))", "problem": 65, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn type-of [coll]\n  (let [other [[:k1 :v1] [:k2 :v2]]\n        result (into coll other)]\n    (cond\n     (= result (concat (reverse other) coll)) :list\n     (= result (concat coll other)):vector\n     (= :v1 (:k1 result)) :map\n     :else :set)))", "problem": 65, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "#(let [e (into (empty %) [[:a 1] [:a 2] [:a 1]])]\n            (if (= (count e) 1) :map\n              (if (contains? e 0) :vector\n                (if (= (count e) 2) :set :list))))", "problem": 65, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "#(if (associative? %) \n   (if (reversible? %) :vector :map)\n   (if (= (conj % :a) (conj % :a :a)) :set :list))", "problem": 65, "user": "528b08efe4b0239c8a67ae8a"}, {"code": "(fn [s] \n  (let [s2 (conj s [1 2])]\n    (if (= (count (conj s2 [1 2])) (count s2))\n      (if (= (count (conj s2 [1 (gensym)])) (count s2))\n             :map\n             :set)\n      (let [sym (gensym)]\n      (if (= (first (conj s2 sym)) sym)\n        :list\n        :vector)))))", "problem": 65, "user": "5294e44de4b02ebb4ef75016"}, {"code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (ifn? %) :set\n  :else :list)", "problem": 65, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn [s]\n  (cond\n   (reversible? s) :vector\n   (associative? s) :map\n   (< (inc (count s)) (count (conj (conj s 1) 1))) :list\n   :else :set))", "problem": 65, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n   (if (= 1 (count result))\n      :map (if (= 2 (count result))\n            :set (if (= [1 3] (first result))\n                   :list :vector )))))", "problem": 65, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "#(case \n     ((juxt associative? empty) %)\n   [false #{}] :set\n   [false ()]  :list\n   [true {}]  :map\n   [true []]  :vector\n)", "problem": 65, "user": "5281a445e4b0757a1b17143a"}, {"code": "(fn f [c]\n        (let [b (conj c {:x :y} {:herp :derp} {:foo :bar})\n              l (last b)\n              f (first b)\n              v (get b :foo)\n              w (get b {:foo :bar})]\n          (cond\n           (= v :bar) :map\n           (= w {:foo :bar}) :set\n           (= l {:foo :bar}) :vector\n           (= f {:foo :bar}) :list\n            :else :fail)))", "problem": 65, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "#({\\{ :map \\# :set \\[ :vector \\c :list} (nth (str %) 0))", "problem": 65, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [seq]\n  (let [seq_len (count seq)]\n    (if (= seq_len (count (conj seq seq))) :map\n     (if (= (inc seq_len) (count (conj seq seq seq))) :set\n       (if (= seq (first (conj seq 1 seq))) :list\n       :vector)\n     )\n    )\n  )\n)", "problem": 65, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [x] \n\t(if (= (inc (count x)) (count (conj (conj (conj x [998 998]) [998 998]) [998 999] ))) :map\n\t\t(if (= (+ 2 (count x)) (count (conj (conj (conj x [998 998]) [998 998]) [998 999] ))) :set\n\t\t\t(if (= 999 (last(conj (conj x 998) 999)))  :vector :list )\n\t\t)\n\t)\n)", "problem": 65, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn whatmap [coll]\n  (let [\n        x {:a 1}\n        y {:a 2}\n        coll' (conj (conj coll x)y)\n        ]\n    (cond\n     (= 0 (count (flatten coll')))\n     (cond\n      (= (count coll') (+ (count coll) 2)) :set\n      :else :map\n      )\n     (= (last coll') y) :vector\n     :else :list)))", "problem": 65, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [x]\n  (let [y (empty x)]\n    (if (= (conj y [:a 1]) {:a 1}) :map\n      (if (= (conj y 1 1) #{1}) :set\n        (if (= (conj y 1 2) '(2 1)) :list\n          (if (= (conj y 1 2) '(1 2)) :vector nil))))))", "problem": 65, "user": "52a0fa82e4b04e0c58e87bd1"}, {"code": "(fn [c]\n  (let [x (conj c [:a :b] [:c :d])]\n    (if (= (seq x) x)\n      (if (= (first x) [:c :d])\n        :list\n        :vector)\n      (if (x :c)\n        :map\n        :set))))", "problem": 65, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn [seq]\n  (cond\n    (= (get (conj seq [:k :v]) :k) :v) :map\n    (= (conj seq :a :a) (conj seq :a)) :set\n    (= (first (conj seq :b :a)) :a) :list\n    (= (last  (conj seq :b :a)) :a) :vector))", "problem": 65, "user": "527ccaf4e4b0757a1b17136d"}, {"code": "#(let [a (conj %1 {:a 1})]\n   (let [b (conj a a)]\n     (if (= b (conj b a))\n       (if (= (b a) a)\n         :set\n         :map\n         )\n       (if\n         (= (conj a a) (cons a a))\n         :list\n         :vector)\n       )\n     )\n   )", "problem": 65, "user": "5298d3f4e4b02ebb4ef75068"}, {"code": "(fn [x] (condp = (first (pr-str x))\n  \t\t\t\\# :set\n            \\( :list\n            \\[ :vector\n            \\{ :map ))", "problem": 65, "user": "52a42b2be4b04e0c58e87c06"}, {"code": "#(case (empty %)\n   {} :map\n   '() (if\n        (= (conj (empty %) 1 2) '(1 2))\n        :vector\n        :list)\n   #{} :set)", "problem": 65, "user": "529e8ba9e4b04e0c58e87b99"}, {"code": "(fn determine-type\n  [coll]\n  (cond\n   (and (not (reversible? coll)) (associative? coll)) :map\n   (and (associative? coll) (reversible? coll)) :vector\n   (= (second (conj coll :sentinel :sentinel)) :sentinel) :list\n   :else :set))", "problem": 65, "user": "52a4f3cee4b0c58976d9abe0"}, {"code": "(fn test [ob]\n   (if (= (vec ob) ob)\n     ;; either a vector or a list\n     (let [newi1 (rand-int (java.lang.Integer/MAX_VALUE))\n           newi2 (rand-int (java.lang.Integer/MAX_VALUE))\n           ob2 (conj ob newi1 newi2)]\n       (if (= (first ob2) newi2)\n         :list\n         :vector))\n     ;; either a map or a set\n     (let [newi1 (rand-int (java.lang.Integer/MAX_VALUE))\n           newi2 (rand-int (java.lang.Integer/MAX_VALUE))\n           ob2 (conj ob [newi1 newi2])]\n       (if (contains? ob2 [newi1 newi2])\n         :set\n         :map))))", "problem": 65, "user": "529ce629e4b04e0c58e87b6e"}, {"code": ";; hyone's solution to Black Box Testing\n;; https://4clojure.com/problem/65\n \n(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "52a503e4e4b0c58976d9abe1"}, {"code": "#(case (-> %\n            empty\n            (conj [1 2])\n            (conj [3 4]))\n    [[1 2] [3 4]] :vector\n    [[3 4] [1 2]] :list\n    {1 2 3 4} :map\n    #{[1 2] [3 4]} :set)", "problem": 65, "user": "4f8c4ee8e4b02e764a0a5194"}, {"code": "(fn [s]\n  (cond\n    (= s (conj s {}))             :map\n    (= (-> s (conj :x) (conj :y))\n       (concat [:y :x] s))        :list \n    (= (-> s (conj :x) (conj :y))\n       (concat s [:x :y]))        :vector\n    :fuck-it                      :set))", "problem": 65, "user": "4f45c72be4b0d56e7bb92b8a"}, {"code": "#(case (empty %)\n   #{} :set\n   {} :map\n   [] (if (first (conj (conj (empty %) false) true))\n        :list\n        :vector))", "problem": 65, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn solution [in]\n  (cond\n   (and (reversible? in) (associative? in)) :vector\n   (and (not (reversible? in)) (associative? in)) :map\n   (= (+ 1 (count in)) (count (conj in 1 1))) :set\n   :else :list\n   )\n  )", "problem": 65, "user": "5226f8e9e4b04e78ff2e199a"}, {"code": "(comp {\\c :list, \\[ :vector, \\{ :map, \\# :set} first str)", "problem": 65, "user": "528e95efe4b0239c8a67aee2"}, {"code": "(fn [coll]\n  (let [v (conj coll [:x :y] [:p :q])]\n    (cond\n      (= (get v :x) :y) :map\n      (= v (conj v [:x :y])) :set\n      (= [:p :q] (last v)) :vector\n      :else :list)))", "problem": 65, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn [s]\n    (cond\n      (= :map-value (:map-key (conj s [:map-key :map-value]))) :map\n      (= :list-head (first (conj (conj s :aaa) :list-head))) :list\n      (let [s2 (conj (conj s :set-entry) :set-entry)]\n        (= (count s2) (+ 1 (count s)))) :set\n      :else :vector))", "problem": 65, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn black-box-test [coll]\n  (let [c (conj (empty coll) [:k :v])]\n    (if (get c :k)\n      :map\n      (if (= (count (conj c [:k :v])) 1)\n        :set\n        (if (= (first (conj c 0)) 0)\n          :list\n          :vector)))))", "problem": 65, "user": "52ab6de1e4b0c58976d9ac78"}, {"code": "(fn type2 [coll]\n  (let [var [:z \"j\"]\n        alt-coll (if (empty? coll) (conj coll [:y \"k\"]) coll)\n        ct (count alt-coll)]\n    (cond \n          (and (= '() (flatten alt-coll))\n               (= var (first (conj alt-coll var))))   :map \n          (= ct (count (conj alt-coll (first alt-coll)))) :set\n          (= var (first (conj alt-coll var)))         :list\n          :else :vector)))", "problem": 65, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [c]\n  (let [mc (conj c [:X :Y] [:X :Y])]\n    (cond\n     (and (< (count mc) (+ (count c) 2)) (= [:X :Y] (mc [:X :Y]))) :set\n     (and (< (count mc) (+ (count c) 2)) (= :Y (mc :X))) :map\n     (= (first (conj mc :XX)) :XX) :list\n     (= (last (conj mc :XX)) :XX) :vector)))", "problem": 65, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "#(let [base (empty %)]\n   (cond\n    (= base #{}) :set\n    (= base {}) :map\n    :else (if (= 1 (-> base (conj 0) (conj 1) first)) :list :vector)))", "problem": 65, "user": "50645e12e4b007509339a58a"}, {"code": "(fn [col]\n  (let [blank (empty col)\n        test-data '([1 2] [1 4] [1 4])\n        new-col (apply conj blank test-data)\n        new-size (count new-col)]\n    (cond\n      (= new-size 1) :map\n      (= new-size 2) :set\n      (= (first new-col) [1 2]) :vector\n      (= (first new-col) [1 4]) :list\n      :else :unknown)))", "problem": 65, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn [x]\n  (if (associative? x)\n    (if (#(= (vec %) %) x)\n      :vector\n      :map)\n    (if (#(= (set %) %) x)\n      :set\n      :list)))", "problem": 65, "user": "51929214e4b08962174cf74c"}, {"code": "(fn [coll]\n  (let [a [:type :a]\n        b [:type :b]\n        coll (conj coll a)\n        repeatable? (fn [] (not=\n                            (into coll [a])\n                            (into coll [a a])))\n        conj-to-head? (fn [] (= (conj coll b) (cons b coll)))\n        pair? (fn [] (= (count coll) (count (conj coll b))))]\n    (cond\n     (and (repeatable?) (conj-to-head?)) :list\n     (and (repeatable?) (not (conj-to-head?))) :vector\n     (and (not (repeatable?)) (pair?)) :map\n     (and (not (repeatable?)) (not (pair?))) :set\n     :else :wrong)))", "problem": 65, "user": "51937eb3e4b04df54c098022"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "#({\"{}\" :map, \"#{}\" :set, \"[]\" :vector} (str (empty %)) :list)", "problem": 65, "user": "52b65f26e4b0c58976d9ad43"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "#(if (reversible? %) :vector (if (associative? %) :map (if (= (count (conj (conj % 1) 1)) (+ 1 (count %))) :set :list)))", "problem": 65, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [s]\n  (cond\n   (= (set s) s) :set\n   (= (vec s) s) (if (= (conj (conj s 1) 2)\n                        (cons 2 (cons 1 s)))\n                   :list\n                   :vector)\n   :else :map))", "problem": 65, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn btest [coll]\n  (let [x (conj (empty coll) [1 2] [1 2] [1 3])]\n    (if (= 1 (count x))\n           :map\n           (if (= 2 (count x))\n             :set\n             (if (= 3 (last (first x)))\n               :list\n               :vector)))))", "problem": 65, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn sniffer [o]\n\t(cond\n\t\t(= (count (conj o [:a :a])) (count (conj (conj o [:a :a]) [:a :a])))\n\t\t(if\n\t\t\t(= ((conj o [:a :z]) :a) :z)\n\t\t\t:map\n\n\t\t\t:set\n\t\t)\n\n\t\t(= (first (conj (conj o :zimbabwe) :mozambique)) :mozambique)\n\t\t:list\n\n\t\t:else\n\t\t:vector\n\t)\n)", "problem": 65, "user": "527ba695e4b03e8d9a4a7596"}, {"code": "(fn id [coll]\n  (let [conjtst  (conj coll nil)\n        constst  (cons nil coll)]\n       (if (= conjtst coll)\n           :map\n           (if (contains? conjtst nil)\n               :set\n               (let [conjtst2 (conj conjtst :islist)]\n                 (if (and (= constst conjtst) (= (first conjtst2) :islist))\n                     :list\n                     :vector\n                 )\n              )\n           )\n       )\n  )\n)", "problem": 65, "user": "52bf8e35e4b07a9af579233a"}, {"code": "#(let [x :x \n        y :y \n        p [x y]\n        c (conj % p)] \n    (cond\n     (= y (get c x)) :map\n     (= p (get c p)) :set\n     (= x (last (conj c x))) :vector\n     :else :list\n     ))", "problem": 65, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": ";(fn blackboxtest\n;  [xs]\n;  (let [a {:a :b}\n;        z {:z :y}\n;        xs (empty xs)\n;        as (conj xs a)\n;        aas (conj as a)\n;        azs (conj as z)]\n;    (cond\n;     (= :b (get as :a :notmap)) :map\n;     (= (count as) (count aas)) :set\n;     (= a (first azs)) :vector\n;     :else :list)))\n\n(fn blackboxtest\n  [xs]\n  (condp = (first (str xs))\n   \\{ :map\n   \\c :list\n   \\[ :vector\n   \\# :set))", "problem": 65, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [x] \n  (cond \n   (= x {}) :map\n   (= x (hash-set)) :set\n   (and (empty? x) (associative? x)) :vector\n   (empty? x) :list\n   (= x {:a 1, :b 2}) :map\n   (get x 10) :set\n   (= 21 (first (conj x 21))) :list\n   (= 21 (last (conj x 21))) :vector\n  ))", "problem": 65, "user": "52c2106fe4b07a9af5792374"}, {"code": "(fn [coll]\n  (let [c (conj (empty coll) [:a :b])]\n    (cond\n     (:a c) :map\n     (get c [:a :b]) :set\n     (get c 0) :vector\n     :else :list)))", "problem": 65, "user": "52976262e4b02ebb4ef75041"}, {"code": "(fn [coll]\n  (cond\n    (= 1 (count (conj (empty coll) [1 2] [1 3]))) :map\n    (= 1 (count (conj (empty coll) 1 1))) :set\n    (= 2 (first (conj (empty coll) 1 2))) :list\n    :else :vector))", "problem": 65, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "52b71bd2e4b0c58976d9ad4d"}, {"code": "#(if (= % (set %)) :set \n   (if (= % (conj % %)) :map \n     (if (= (list %) (first (conj % % (list %)))) :list :vector)))", "problem": 65, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn [coll]\n  (let [x (rand-int 100) y (rand-int 100) \n        p [x y] c (conj coll p)]\n    (cond \n      (= y (get c x)) :map\n      (= p (get c p)) :set\n      (= x (last (conj c x))) :vector\n      :else :list)))", "problem": 65, "user": "52aa16d1e4b0c58976d9ac5a"}, {"code": "(fn\n  [v]\n  (let [f (str (first (str `~v)))]\n    (cond\n     (= f \"[\") :vector\n     (= f \"#\") :set\n     (= f \"{\") :map\n     :d :list)))", "problem": 65, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn [x] (cond \n   (= (get (conj x [:inky :pinky]) :inky) :pinky) :map\n   (= (conj x 4) (conj (conj x 4) 4)) :set\n   (= (first (conj (conj x :foo) :tail)) :tail) :list\n   (= (last (conj (conj x :foo) :tail)) :tail) :vector\n   )\n  )", "problem": 65, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn my-type\n  [c]\n  (if (associative? c)\n    (if (= (count (assoc (conj (empty c) [:a 1]) 0 1)) 1) :vector :map)\n    (if (= (count (conj (empty c) 1 1)) 1) :set :list)))", "problem": 65, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn solution [s]\n  (let [t (into s {0 3})]\n    (if (= 3 (get t 0))\n      (if (= 5 (get (into t {0 5}) 0)) :map :vector)\n      (let [t1 (into s {1 1})\n            t2 (into t1 {1 1})\n           ]\n        (if (not= (count t2) (inc (count t1)))\n          :set\n          (if (nil? (get t1 0)) :list :vector)\n        )\n      )\n    )\n  )\n)", "problem": 65, "user": "52b49aebe4b0c58976d9ad2b"}, {"code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "problem": 65, "user": "52c580c2e4b0c2d177d620f5"}, {"code": "(fn black-box-testing [x]\n  (let [e (empty x)]\n    (cond (= e {}) :map\n          (= e #{}) :set\n          (and (= e '()) (= :TEST (first (conj e nil :TEST)) )) :list\n          (and (= e []) (= :TEST (last (conj e :nil :TEST))  )) :vector\n\n          :else :unknown)))", "problem": 65, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "#(case (first(str %)) \\{ :map \\# :set \\[ :vector :list)", "problem": 65, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn mybbtest\n        [vs]\n        (if (coll? vs)\n          (let [xs (empty vs)]\n            ; add [:a :b] to it\n            (let [x [:a :b]\n                  xs' (conj xs x)]\n              (if (:a xs')\n                ; it is a map\n                :map\n                ; not a map\n                (if (= x (get xs' 0))\n                  ; it is a vector\n                  :vector\n                  ; not a map/vector , add x to it again\n                  (if (= 2 (count (conj xs' x)))\n                    ; then it is a list\n                    :list\n                    ; else it is a set\n                    :set\n                    ))\n                )\n              ))))", "problem": 65, "user": "52c58561e4b0c2d177d620f8"}, {"code": "(fn [c] (let [c2 (conj (conj (conj c [400 400]) [400 400]) [500 500])]\n                  (if (not= (get c2 400) nil) :map\n\t              (if (= (first c2) [500 500]) :list\n                          (if (not= (count c2) (+ (count c) 3)) :set :vector))\n                      )\n                  ))", "problem": 65, "user": "52c1bd29e4b07a9af579236a"}, {"code": "#(let [x (empty %)]\n   (cond\n     (= x {}) :map\n     (= x #{}) :set\n     :else\n     (if (= (conj x 1 2) [1 2]) :vector :list)\n   ))", "problem": 65, "user": "52ba2af3e4b07a9af57922cc"}, {"code": "(fn [coll]\n  (cond\n   (= (count (conj coll [:a 1]))\n      (count (conj coll [:a 1] [:a 2])))\n   :map\n   (= (count (conj coll [:a 1] [:a 1]))\n      (count (conj coll [:a 1])))\n   :set\n   (= (last (conj coll [:a 1] [:b 2])) [:b 2])\n   :vector\n   :else :list))", "problem": 65, "user": "52cc582ae4b07d0d72b27362"}, {"code": "(fn [s]\n    (let [t (empty s)]\n      (cond\n        (and (associative? t) (reversible? t))\n          :vector\n        (and (associative? t) (not (reversible? t)))\n          :map\n        (= (into t '(1)) #{1})\n          :set\n        :else\n          :list)))", "problem": 65, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(comp (zipmap (map str '[() [] {} #{}]) [:list :vector :map :set]) str empty)", "problem": 65, "user": "52d0902ee4b07d0d72b273bd"}, {"code": "#(cond (reversible? %) :vector (associative? %) :map (let [c (conj % 0)] (= c (conj c 0))) :set 0 :list)", "problem": 65, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn [coll]\n  (cond\n    (associative? coll) (if (reversible? coll) :vector :map)\n   \t(= (get (conj coll :a) :a) :a) :set\n    :else :list))", "problem": 65, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn [c]\n   (cond \n      (let [m (conj c [:a 1])]  (= 1 (:a m)))                     :map\n      (let [s (conj c :a :a)]   (= (inc (count c)) (count s)))    :set\n      (let [l (conj c :a :b)]   (= :b (first l)))                 :list\n      :else   :vector))", "problem": 65, "user": "51264447e4b05d10e3e39601"}, {"code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "problem": 65, "user": "52d7f7efe4b09f7907dd1380"}, {"code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "problem": 65, "user": "52d02380e4b07d0d72b273b7"}, {"code": "(fn  [x]\n    (let [e (empty x)]\n      (cond\n       (= {} e) :map\n       (= #{} e) :set\n       (= '(2 1) (conj e 1 2)) :list\n       :else :vector)))", "problem": 65, "user": "518c5236e4b087e178201de0"}, {"code": "(fn [coll]\n  (let [start-count (count coll)\n        a (gensym \"a\")\n        b (gensym \"b\")\n        modified (conj coll [a :a] [a :a] [a :b] [b :c])\n        size-diff (- (count modified) start-count)]\n    (cond\n      (= size-diff 2) :map\n      (= size-diff 3) :set\n      (= size-diff 4)\n        (if (= (first modified) [b :c])\n            :list\n            :vector))))", "problem": 65, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn what [coll] (cond\n                 (= (count (conj coll [:foo 1]))\n                    (count (conj coll [:foo 1] [:foo 2]))) :map\n                 (= (count (conj coll :foo)) (count (conj coll :foo :foo))) :set\n                 (= :foo (first (apply list (conj (conj coll :bar) coll :foo)))) :list\n                 :else :vector))", "problem": 65, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn bb-testing [x]\n  (let [raw (empty x)\n        filled (conj raw [:a :a] [:a :a] [:a :b])]\n    (case (count filled)\n      1 :map\n      2 :set\n      3 (if (= [:a :b] (first filled))\n          :list :vector\n          )\n      )\n    )\n  )", "problem": 65, "user": "5094057fe4b097f48cc38593"}, {"code": "#(case (nth (str %) 0)\n   \\{ :map\n   \\# :set\n   \\[ :vector\n   :list)", "problem": 65, "user": "52d10680e4b07d0d72b273c3"}, {"code": "(fn [x]\n  (case (first (.toString x))\n    \\# :set\n    \\[ :vector\n    \\{ :map\n    :list))", "problem": 65, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(fn gettype [l]\n  (letfn [(countitem [c item s]\n                     (cond\n                      (empty? s) c\n                      (= item (first s)) (countitem (+ 1 c) item (rest s))\n                      true (countitem c item (rest s))))]\n    (let [unique-value1 \"Unique-value-1\"\n          unique-value2 \"Unique-value-2\"\n          new-l (conj (conj (conj l [unique-value1 unique-value2]) [unique-value1 unique-value2]) [unique-value2 unique-value1])]\n      (cond\n       (= unique-value1 (get new-l unique-value2)) :map\n       (= 1 (countitem 0 [unique-value1 unique-value2] new-l)) :set\n       (= [unique-value1 unique-value2] (second (rest new-l))) :list\n       (= [unique-value1 unique-value2] (last (butlast (butlast new-l)))) :vector\n       true nil))))", "problem": 65, "user": "52d7b0ade4b09f7907dd137c"}, {"code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "problem": 65, "user": "52cdb7efe4b07d0d72b2737c"}, {"code": "(fn identifySeq [seq]\n  (cond\n   (-> seq (conj [200 3]) (get 200) (= 3))\n     :map\n   (-> seq (conj 300) (conj 200) (conj 400) first (= 400)) ;conj adds to beginning\n     :list\n   (= (-> seq (conj 300)) (-> seq (conj 300) (conj 300))) ;add once to set is the same as twice\n     :set\n   (-> seq (conj 300) (conj 500) (conj 400) last (= 400))\n     :vector\n   :else\n     :yikes\n   \t))", "problem": 65, "user": "525d490ae4b0cb4875a45d70"}, {"code": "(fn [l]\n  (cond\n   (reversible? l) :vector\n   (associative? l) :map\n   :else\n   (let [k (count (conj l :o :o)) j (count l)]\n     (if (= (- k j) 2)\n       :list\n       :set))))", "problem": 65, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn f65 [c] (if (associative? c)\n                  (if (reversible? c)\n                      :vector\n                      :map)\n                  (if (= (+ 2 (count c))\n                         (count (conj c 99 99)))\n                      :list\n                      :set)))", "problem": 65, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn [coll]\n  (let [input (empty coll)]\n    (cond\n     (= input {}) :map\n     (= input #{}) :set\n     (= input '()) (if (reversible? input) :vector :list)\n     )))", "problem": 65, "user": "5271605ae4b03e8d9a4a73ed"}, {"code": "(fn [coll]\n  (let [inx [\"jjj\" \"klk\"] coll (conj coll [1 2])]\n    (cond (= (get (conj coll inx) inx) inx) :set\n          (= (get (conj coll inx) (first inx)) (second inx)) :map\n          (= (last (conj coll inx)) inx) :vector\n          :else :list)))", "problem": 65, "user": "52e44a22e4b09f7907dd144e"}, {"code": "#(if (associative? %)\n   (if (coll? (first (assoc % 0 100)))\n     :map\n     :vector)\n   (if (= (count (conj % 1)) (count (conj % 1 1)))\n     :set\n     :list))", "problem": 65, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [s]\n    (letfn [(dups [s d nd] (if (= (conj s [0 0]) (conj (conj s [0 0]) [0 0])) nd d))]\n      (if (associative? s)\n        (dups s :vector :map)\n        (dups s :list :set))))", "problem": 65, "user": "52d6a9c2e4b09f7907dd1365"}, {"code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  :else (let [k (conj % 1 2)]\n          (if (= (first k) 2)\n            :list\n            :set\n            )\n          )\n  )", "problem": 65, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [c] (let [p [:newk :newv]\n              p1 [:newk1 :newv1]\n              cc (conj c p1 p1 p)]\n  (cond\n   (= (:newk cc) :newv) :map\n   (= (count c) (- (count cc) 2)) :set\n   (= (first cc) p) :list   \n   (= (last cc) p) :vector   \n   () :map\n   )\n  )\n)", "problem": 65, "user": "52cc4fd6e4b07d0d72b27360"}, {"code": "(fn [coll]\n  (let [result (empty coll)]\n    (cond\n      (= result {}) :map\n      (= result #{}) :set\n      (= result '()) (if (reversible? result) :vector :list))))", "problem": 65, "user": "52c672e2e4b0c2d177d6210e"}, {"code": "(fn[x]\n            (if-not (ifn? x) :list \n              (if (reversible? x) :vector \n                (if-not (associative? x) :set :map))))", "problem": 65, "user": "52d66ca0e4b09f7907dd135c"}, {"code": "(fn [coll]\n  (condp #(contains? %2 %) (conj (empty coll) [:test :test])\n    0 :vector\n    :test :map\n    [:test :test] :set\n    :list))", "problem": 65, "user": "52b02329e4b0c58976d9acc5"}, {"code": "(fn [coll]\n  (if (associative? coll)\n    (if (= 1 (first (assoc coll 0 1)))\n\t  :vector\n      :map)\n    (if (= (count (conj coll :a)) \n           (count (conj coll :a :a)))\n      :set\n      :list)))", "problem": 65, "user": "52c4af71e4b0c2d177d620e1"}, {"code": "#(let [v [0 0]\n        f (fn [])]\n    (cond\n     (not= (conj % v) (conj % v v))\n     (if (= f (first (conj % 1 f))) :list :vector)\n     (= ((conj % [0 :a]) 0) :a) :map\n     :else :set))", "problem": 65, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn blackbox [col]\n  (if (= (count (conj col [:test 1])) (count (conj (conj col [:test 2]) [:test 1])))\n    :map\n    (if (= (count (conj col :a)) (count (conj (conj col :a) :a)))\n      :set\n      (if (= (first (conj (conj col :b) :a)) :a)\n        :list\n        :vector))))", "problem": 65, "user": "52dad8bde4b09f7907dd13be"}, {"code": "#(condp = (empty %)\n  #{} :set\n  {}  :map\n  '() (if (reversible? %) :vector :list))", "problem": 65, "user": "522eb5cce4b01cdb292c5f0c"}, {"code": "#(cond (= % (conj % %)):map \n       (= (conj % %) (conj % % %)) :set \n       (= % (first (conj % (conj % %) %))) :list \n       :else :vector)", "problem": 65, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn [o]\n    (cond\n      (reversible? o) :vector\n      (associative? o) :map\n      (= (count o) (dec (count (into o ['asdf 'asdf])))) :set\n      :else :list\n      ))", "problem": 65, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [xs] (let [xs (empty xs)] (cond (= xs {}) :map (= xs #{}) :set \n                                    (= xs ()) \n                                    (if (= :a (first (conj xs :a :b))) :vector :list))))", "problem": 65, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "#(let [b (conj % [:t1 :t2] [:t1 :t2] [:t2 :t1])\n      t (if (not= (count b) (+ (count %) 3)) :map-or-set :vec-or-list)]\n  (if (= t :vec-or-list)\n    (if (= [:t2 :t1] (first b))\n      :list\n      :vector)\n    (if (:t2 b)\n      :map\n      :set)))", "problem": 65, "user": "52d809bde4b09f7907dd1384"}, {"code": "#(case (empty %)\n     {} :map \n     #{} :set \n     '() (if (reversible? %) :vector :list ))", "problem": 65, "user": "52eff3e8e4b05e3f0be25ed7"}, {"code": "(fn r [xs]\n  (let [x (empty xs)]\n    (if \n      (= '([1 2]) (conj x [1 2]))\n      (if (= (conj (conj x 1) 2) [1 2])\n        :vector\n        :list)\n      (if (= #{[1 2]} (conj x [1 2]))\n        :set\n        (if (> (count (select-keys (conj x [1 2]) #{1})) 0)\n          :map)))))", "problem": 65, "user": "525cc137e4b0cb4875a45d46"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [c]\n  (let [d (conj c {0 1} {0 2} {0 1})]\n  (cond\n    (= (+ 1 (count c)) (count d)) :map\n    (= (+ 2 (count c)) (count d)) :set\n    (= (cons {0 3} d) (conj d {0 3})) :list\n    true :vector)))", "problem": 65, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn [xs]\n  (cond  \n   (and (associative? xs) (zero? (count (merge (empty xs) {} {})))) :map\n   (= 1 (count (conj (conj (empty xs) :test) :test))) :set\n   (= (first (conj (conj xs :test1) :test)) :test) :list\n   :else :vector))", "problem": 65, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "(fn [x]\n  (cond\n   (= [0 0] (get (into x {0 0}) [0 0])) :set\n   (nil? (get (into x {0 0}) 0)) :list\n   (= 0 (get (into x {0 0}) 0)) :map\n   :else :vector))", "problem": 65, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn [o]\n  (let [first-char (first (. o toString))]\n    (cond \n       (= \\{ first-char) :map\n       (= \\# first-char) :set\n       (= \\[ first-char) :vector\n       :else :list\n     )))", "problem": 65, "user": "5142e808e4b0c172af7558c9"}, {"code": "(fn [item]\n  (let [base (empty item)]\n    (cond \n     (= {} base) :map\n     (= '() base) (if (reversible? item) :vector :list)\n     (= #{} base) :set)))", "problem": 65, "user": "52f07ccee4b05e3f0be25edf"}, {"code": "(fn typ [e]\n  (if (empty? e) (typ (conj e [:a 1] [:b 2]))\n      (let [su (conj e (last e))]\n        (pr su e)\n        (if (= e su)\n          (if (e (first e)) :set :map)\n          (if (= (first e) (first su)) :vector :list)\n          ))))", "problem": 65, "user": "50c2fbebe4b00e537d00253c"}, {"code": "(fn check-type [a-coll]\n \t(let [empty-coll (empty a-coll)\n          added-coll (conj empty-coll [5 6])]\n\t\t(if (not= (get added-coll 5) nil)\n            :map\n\t\t\t(let [two-elem-added (conj empty-coll 5 5)]\n\t\t\t\t(if (= (count two-elem-added) 1)\n\t\t\t\t\t:set\n\t\t\t\t\t(let [inc-seq (conj empty-coll 5 6)]\n\t\t\t\t\t\t(if (= (first inc-seq) 5)\n\t\t\t\t\t\t\t:vector\n\t\t\t\t\t\t\t:list\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n        )\n     )\n )", "problem": 65, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "problem": 65, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn [x]\n  (let [ex (empty x)]\n    (if (get (conj ex [1 2]) 1)\n      :map\n      (if (= 1 (count (conj ex 1 1)))\n        :set\n        (if (= 1 (first (conj ex 1 2)))\n          :vector\n          :list)))))", "problem": 65, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [coll]\n  (let [col (empty coll)]\n    (cond (= {} col) :map\n          (= (count (conj col 1)) (count (conj col 1 1))) :set\n          (= :a (first (conj col :b :a))) :list\n          :else :vector)))", "problem": 65, "user": "52fb903ee4b047fd5583700b"}, {"code": "(fn [seqq]\n  (let [funny-pair [:funny-key 999]\n        test-seq (conj seqq funny-pair)]\n    (cond\n      (= 999 (:funny-key test-seq)) :map\n      (and (= funny-pair (second (conj test-seq funny-pair))) (= funny-pair (second (conj test-seq 1)))) :list\n      (= (count test-seq) (count (conj test-seq funny-pair))) :set     \n\t  :else :vector)))", "problem": 65, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn [x]\n   (cond (and (not= x #{}) (= :x (:x (merge x {:x :x})))) :map\n         (and (not= x #{}) (= :x (last  (conj (conj x :y ) :x)))) :vector\n         (= :x (first (conj (conj x :y) :x))) :list\n          :otherwise :set ))", "problem": 65, "user": "5300aa1de4b0d8b024fd3710"}, {"code": "#(let [xs (conj (empty %) {0 0} {0 1})]\n   (cond (= xs {0 1}) :map\n         (= xs #{{0 0} {0 1}}) :set\n         (= xs '({0 1} {0 0})) :list\n         (= xs [{0 0} {0 1}]) :vector))", "problem": 65, "user": "50742549e4b054001656accf"}, {"code": "(fn black-box\n  [in]\n  (let [f (str (first (str in)))]\n    (cond\n      (= f \"#\") :set\n      (= f \"{\") :map\n      (= f \"[\") :vector\n      :else :list)))", "problem": 65, "user": "5300b750e4b0d8b024fd3711"}, {"code": "(fn [s] (if (associative? s) (if (reversible? s) :vector :map) (let [t (conj s 1)] (if (= (count t) (count (conj t 1))) :set :list))))", "problem": 65, "user": "52c1f404e4b07a9af5792370"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "52fcfeeee4b047fd55837027"}, {"code": "#(let [base (empty %)]\n(cond\n(= base {}) :map\n(= base #{}) :set\n(= base '()) (if (reversible? %) :vector :list)))", "problem": 65, "user": "53059d42e4b0d8b024fd3761"}, {"code": "#(cond\n  (= {} (empty %)) :map\n  (= #{} (empty %)) :set\n  (= :bogus (last (conj (conj % :bigus) :bogus))) :vector\n  (= :bogus (first (conj (conj % :bigus) :bogus))) :list)", "problem": 65, "user": "4f48f587e4b0d56e7bb92be2"}, {"code": "(fn [xs] (let [test {:X :Y} xss (conj xs nil test) f (first xss) l (last xss)] (cond (= f test) :list (= l test (xss (dec (count xss)))) :vector  (= (xss :X) :Y) :map (= (xss test) test) :set)))", "problem": 65, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [coll]\n  (let [t (empty coll)]\n  (cond\n   (= t {}) :map\n   (= t #{}) :set\n   (= t '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "52facb9de4b047fd55837002"}, {"code": "(fn [coll]\n   (let [s (first (pr-str coll))]\n      (cond\n         (= \\# s) :set\n         (= \\{ s) :map\n         (= \\[ s) :vector\n         :default :list)))", "problem": 65, "user": "4fb99483e4b081705acca2da"}, {"code": "#(if (associative? %)\n   (if (reversible? %) :vector :map)\n   (if (apply distinct? (into % [:same :same])) :set :list))", "problem": 65, "user": "528a2de7e4b0239c8a67ae71"}, {"code": "(fn find-type[coll]\n  (get [:map :set :list :vector] (.indexOf \"{#([\" (str (get (print-str coll) 0)))))", "problem": 65, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn [unknown]\n(cond\n  (= unknown (into #{} unknown)) :set\n  (and (or (not= [] unknown) (not= () unknown)) (not= (seq unknown) unknown))  :map\n  (= (conj unknown 100 200) (cons 200 (cons 100 unknown))) :list\n  :else :vector))", "problem": 65, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn [x]\n  (cond\n   (= \"bar\" (get (conj x [\"foo\" \"bar\"]) \"foo\")) :map\n   (= (conj x 1) (conj x 1 1)) :set\n   (= 2 (first (conj x 1 2))) :list\n   (= 1 (first (conj x 1 2))) :vector\n   :else :map\n   ))", "problem": 65, "user": "530b6ea2e4b02e82168697cb"}, {"code": "#(condp = %\n   (set %) :set\n   (vec %) (if (= (first (conj % \"XXX\" \"YYY\")) \"YYY\") :list :vector)\n   :map)", "problem": 65, "user": "51583ee4e4b0a069fd272c72"}, {"code": "(fn[c]\n  (let [tc (into c '([:t :t][:t :t][:t :s]))]\n  (cond\n   (= (into  c  '([:t :s])) tc)        :map\n   (= (into  c  '([:t :t][:t :s])) tc) :set\n   (= (first tc)  [:t :s])             :list\n   (= (last  tc)  [:t :s])             :vector)))", "problem": 65, "user": "52f818a6e4b047fd55836fcc"}, {"code": "#({\\{ :map\n   \\# :set\n   \\[ :vector\n   \\c :list}\n      (first (str %)))", "problem": 65, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [c] (letfn [\n(is-map? [c] (= 1 (get (conj (empty c) [0 1] [2 3]) 0)))\n(is-set? [c] (= [0 1] (get (conj (empty c) [0 1] [2 3]) [0 1])))\n(is-vector? [c] (and (not (is-map? c)) (= (first (conj (empty c) [0 1] [2 3])) [0 1])))\n(is-list? [c] (and (not (is-set? c)) (= (first (conj (empty c) [0 1] [2 3])) [2 3])))\n(find-first [pred coll] (first (filter pred coll)))\n(types-and-tests [] {:map is-map? :list is-list? :vector is-vector? :set is-set?})\n(black-box-testing [c] (find-first #((get (types-and-tests) %) c) (keys (types-and-tests))))\n] (black-box-testing c)))", "problem": 65, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn bbt [s]\n  (let [is-map? (fn [s]\n                  (if (empty? s)\n                    (let [s2 (conj s [:a :a])\n                          r (get s2 :a)]\n                      (if (nil? r)\n                        false\n                        true))\t  \n                    (let [f (flatten (cons (first s) '()))]\n                      (if (= 1 (count f))\n                        false\n                        true))\n                    ))\n        is-set? (fn [s]\n                  (if (empty? s)\n                    (let [s2 (conj s :a :a)]\n                      (if (= 1 (count s2))\n                        true\n                        false))\n                    (let [f (first s)\n                          s2 (conj s f)\n                          r (filter #(= % f) s2)]\n                      (if (= 1 (count r))\n                        true\n                        false))\n                    ))\n        is-vector? (fn [s]\n                     (if (empty? s)\n                       (let [s2 (conj s 1 2)]\n                         (if (= 1 (first s2))\n                           true\n                           false))\n                       (let [f (first s)\n                             s2 (conj s f)]\n                         (if (= f (last s2))\n                           true\n                           false))\n                       ))\n        ]\n    (cond\n      (is-map? s) :map\n      (is-set? s) :set\n      (is-vector? s) :vector\n      :else :list\n      )))", "problem": 65, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn blackbox [x]\n  (cond\n    (reversible? x) :vector\n    (associative? x) :map\n    (apply distinct? (into x [1 1])) :set\n    :else :list)\n  )", "problem": 65, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn guesswhat[x] (if (associative? x) (if(= (apply vector x) x) :vector :map) (if(ifn? x) :set :list)))", "problem": 65, "user": "5307e4ece4b02e82168697a9"}, {"code": "#(let [v (empty %)]\n\t(cond \n\t\t(= 1 (count (conj v [1 1] [1 2]))) :map\n\t\t(= 1 (count (conj v 1 1))) :set\n\t\t(= 2 (last (conj v 1 2))) :vector\n\t\t:else :list)\n\t)", "problem": 65, "user": "52bf6946e4b07a9af5792334"}, {"code": "#(condp = (first (pr-str %)) \\{ :map \\( :list \\[ :vector \\# :set)", "problem": 65, "user": "52d7f9a8e4b09f7907dd1381"}, {"code": "(fn [s]\n  (cond\n   (= (apply hash-set s) s) :set\n   (and (= (first (conj s [s s] s)) s) \n        (= (apply list s) s)) :list\n   (= (apply vector s) s) :vector\n   (and (even? (count s)) \n        (= (apply list s) (map identity s))) :map))", "problem": 65, "user": "5316cdcae4b08068f379ed4b"}, {"code": "(fn [xs]\n  (let [types {(str []) :vector\n        \t   (str {}) :map\n        \t   (str #{}) :set\n        \t   (str '()) :list}]\n    \t(types (str (empty xs)))))", "problem": 65, "user": "531490bde4b08068f379ed17"}, {"code": "(fn [coll]\n   (cond (= 3 (:b (-> coll (conj {:b 3} ))) ) :map\n         (= (inc (count coll)) (count (-> coll (conj :a) (conj :a)))) :set\n         (= :a (last (-> coll (conj 7) (conj :a)))) :vector\n         (= \"a\" (first (-> coll (conj 1) (conj \"a\")))) :list\n            :else :unknown\n         ))", "problem": 65, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn bb [s]\n  (cond\n    (= (conj s {}) s) :map\n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n                 (= (conj (conj s 0) 1) [0 1]) :vector\n                 :else :list\n                 )\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector\n    )\n)", "problem": 65, "user": "5303a027e4b0d8b024fd3745"}, {"code": "(fn my-type [s]\n  (let [empty-s (empty s)]\n    (cond (empty? (conj empty-s nil)) :map\n          (= 1 (count (conj empty-s 1 1))) :set\n          (= 1 (first (conj empty-s 1 2))) :vector\n          :else :list)))", "problem": 65, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn   [n]\n  \n  (cond\n   (= :b (get (conj n {:a :b}) :a)) :map\n   (= :b (first (conj n :a :b))) :list\n   (= (inc (count n)) (count (conj n :a :a))) :set\n   (= :b (last (conj n :a :b))) :vector\n  ))", "problem": 65, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "#(cond \n  (= (:a (conj % {:a 1})) 1) :map \n  (= (count(conj % 10)) (count (conj (conj % 10) 10))) :set\n  (= (last (conj (conj % -1) -2)) -2) :vector\n  (= (first (conj (conj % -1) -2)) -2) :list\n  )", "problem": 65, "user": "531d77d7e4b08068f379edaf"}, {"code": "#(if (= (conj %1 [:x :y] [:x :z]) (conj %1 [:x :z]))\n  :map\n  (if (= (conj %1 :x :x) (conj %1 :x))\n    :set\n    (if (= (last (conj %1 :x :y)) :y)\n      :vector\n      :list\n    )\n  )\n)", "problem": 65, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn [v]\n  (cond\n   (associative? v) (if (= (get (conj v [:z 10]) :z) 10) :map :vector)\n   (< (count (conj v 1 1)) (+ 2 (count v))) :set\n   \n   :else :list)\n  )", "problem": 65, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [col]\n  (letfn [(check [x] (cond (and (= x []) (associative? x)) :vector\n                           (= x '()) :list\n                           (= x {}) :map\n                           (= x #{}) :set))]\n  (if (some #(and (coll? %) (empty? %)) col) check\n      \t\t\t\t   (check (empty col)))))", "problem": 65, "user": "52a5a8ebe4b0c58976d9abed"}, {"code": "(fn [coll]\n  (let [sq (reduce conj coll [[:c 0] [:c 1] [:c 1]])]\n    (cond\n      (= (first sq) (second sq) [:c 1]) :list\n      (= (first (reverse sq)) (second (reverse sq)) [:c 1]) :vector\n      (= (:c sq) 1) :map\n      :else :set)))", "problem": 65, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn [x]\n  (let [y (conj x [:a 1])]\n    (if (= 0 (count (flatten y)))\n      (if (= 1 (y :a))\n        :map\n        :set)\n      (if (= :first (first (conj y :first)))\n        :list\n        :vector))))", "problem": 65, "user": "52fb64b7e4b047fd55837009"}, {"code": "#(if (= (vec %) %)\n   (if (= (conj (vec %) 1 2) (conj % 1 2))\n     :vector\n     :list)\n   (if (= (set %) %)\n     :set\n     :map))", "problem": 65, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn black-box [xs]\n  (cond (= (empty xs) {}) :map\n \t(= (empty xs) #{}) :set\n \t(= (empty xs) '()) \n \t  (if (reversible? xs) :vector :list)))", "problem": 65, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn [coll] (let [r (conj coll [:1 1] [:1 1] [:1 2])]\n             (cond \n              (= (count r) (+ (count coll) 1)) :map\n              (= (count r) (+ (count coll) 2)) :set\n              (= (first r) [:1 2]) :list\n              :else :vector)))", "problem": 65, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "#(cond (->> % empty (= '{})) :map\n       (->> % empty (= '#{})) :set\n       (->> :i (conj % 1) first (= :i)) :list\n        :else :vector)", "problem": 65, "user": "530cb5b8e4b02e82168697e0"}, {"code": "#(case (first (str %))\n  \\[ :vector\n  \\{ :map\n  \\# :set\n  :list)", "problem": 65, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn [col] (let [s1 (conj col [:test 0]) s2 (conj s1 [:test 1]) s3 (conj s2 [:test 1])]\n            (cond\n             (= (count s1) (count s2)) :map\n             (= s2 s3) :set\n             (= (first s2) [:test 1]) :list\n             (= (last s2) [:test 1]) :vector\n           )))", "problem": 65, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn [x]\n  (if\n    (= :two (get (conj x [:one :two]) :one))\n    :map\n    (if\n      (= (count (conj x :one :one)) (inc (count x)))\n      :set\n      (if\n        (= (last (conj x :one :two)) :two)\n        :vector\n        (if (= (first (conj x :one :two)) :two) :list)\n      )\n    )\n  )\n)", "problem": 65, "user": "52f1bc81e4b05e3f0be25eef"}, {"code": "#(let [r (conj (empty %1) [:a 1] [:a 2] [:b 3] [:b 3])]\n    (cond\n\t\t(= (count r) 2) :map\n     \t(= (count r) 3) :set\n\t\t(= (last r) [:a 1]) :list\n     \t:else :vector))", "problem": 65, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn [x]\n  (if (= (conj x {}) x)\n    :map\n    (if (= (count (conj x :k :k)) (+ (count x) 1))\n      :set\n      (if (= (last (conj x :x :y)) :y)\n        :vector :list))))", "problem": 65, "user": "53315c78e4b019098a6f8b67"}, {"code": "(fn blackbox [x]\n     (if (= (count (conj (empty x) [:a 1] [:a 1])) 2)\n       (if (= [:b 2] (first (conj (conj (empty x) [:a 1]) [:b 2])))\n         :list\n         :vector)\n       (if (associative? x)\n         :map\n         :set)))", "problem": 65, "user": "532727bae4b09d4e7a9b54fa"}, {"code": "(fn detect-type [x]\n  (cond\n   (= (:a (conj x [:a 2]))\n      2)\n   :map\n\n   (contains? (conj x :a)  :a)\n   :set\n\n   (and (= :b\n           (last (conj x :a :b)))\n        (= :c\n           (first (cons :c x))))\n   :vector\n\n   :default\n   :list))", "problem": 65, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn bt [col]\n  (let [x (conj col [::a 1] [::a 2] [::a 2])\n        d (- (count x) (count col))]\n    (cond (= d 1)               :map\n          (= d 2)               :set\n          (= [::a 2] (first x)) :list \n          :default              :vector)))", "problem": 65, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "#(if (reversible? %)\n   :vector\n   (if (associative? %)\n     :map\n     (let [a (conj % 1)\n           b (conj a 1)]\n       (if (= a b)\n         :set\n         :list))))", "problem": 65, "user": "529f82b3e4b04e0c58e87baf"}, {"code": "(fn ty [t]\n  (cond\n   (= (+ 1 (count t)) (count (conj (conj t [10 10]) [10 10])))\n   (if (contains? (conj t [10 10]) [10 10] )\n     :set\n     :map)\n\n   (= (take-last 2 (conj (conj t t) 4)) [t 4])\n   :vector\n\n   :else\n   :list)\n\n)", "problem": 65, "user": "532b43c3e4b09d4e7a9b5531"}, {"code": "#(let [e (empty %)]\n   (case e\n     {}  :map\n     #{} :set\n     (first (conj e :vector :list))))", "problem": 65, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn[x]                                                                                                                                                                                                                                         \n  (let [t (conj (empty x) [:a :b] [:c :d])]                                                                                                                                                                                                   \n    (cond                                                                                                                                                                                                                                     \n      (:a t) :map                                                                                                                                                                                                                             \n      (get t 0) :vector                                                                                                                                                                                                                       \n      (get t [:a :b]) :set                                                                                                                                                                                                                    \n      :else :list)))", "problem": 65, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn [coll]\n   (let [x (rand-int 100)\n         y (rand-int 100)\n         comb [x y]\n         joined (conj coll comb)]\n     (cond (= (get joined x) y) :map\n           (= (get joined comb) comb) :set\n           (= (last (conj joined x)) x) :vector\n           :else :list)))", "problem": 65, "user": "5005b57de4b0678c553fc46a"}, {"code": "#({\\c :list \\# :set \\[ :vector \\{ :map} (first (str %)))", "problem": 65, "user": "5336ca32e4b0e30313ee6c80"}, {"code": "#(cond\n  (= (set %) %) :set\n  (= (inc (count %)) (count (conj % {:t :w} {:t :w}))) :map\n  (not (associative? %)) :list\n  :else :vector)", "problem": 65, "user": "53034738e4b0d8b024fd373e"}, {"code": "(fn [coll]\n    (case (empty coll)\n          {}    :map\n          '()   (if (associative? coll) :vector :list)\n          #{}   :set))", "problem": 65, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn f [x]\n  (let [base (empty x)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? x) :vector :list))))", "problem": 65, "user": "5302ac7fe4b0d8b024fd3731"}, {"code": "(fn [x] \n  (let [res (conj x [:k1 :v1] [:k2 :v2])]\n   (cond \n     (contains? res :k1) :map\n     (contains? res [:k1 :v1]) :set  \n     (= (last res) [:k2 :v2]) :vector\n     (= (first res) [:k2 :v2]) :list)))", "problem": 65, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn [x]\n    (let [e (empty x)\n          y (conj e ['a 'a] ['a 'a] ['a 'b])\n          cy (count y)]\n      (cond\n        (= 3 cy) (if (= (first y) ['a 'b]) :list :vector)\n        (= 2 cy) :set\n        true :map)))", "problem": 65, "user": "531f7a2de4b08068f379edc6"}, {"code": "(fn [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "problem": 65, "user": "506d5e4ce4b0a302964c5493"}, {"code": "#(let [a (count %)\n       b (conj % {:aa :bb})\n       c (conj b {:aa :cc})\n       d (conj c {:aa :cc})\n       e (- (count d) a)]\n   (cond\n    (= e 1) :map\n    (= e 2) :set\n    (= (last c) {:aa :cc}) :vector\n    :else :list))", "problem": 65, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn [coll]\n  (cond (= (conj coll [0 2]) (conj (conj coll [0 1]) [0 2])) :map\n        (not= (sequence coll) coll) :set\n        (let [bigger-coll (conj coll :coll); so we can't end up with single item\n              new-item (not (first bigger-coll)); guaranteed to be different\n              conjed (conj bigger-coll new-item)]\n          (= (first conjed) new-item)) :list\n        :else :vector))", "problem": 65, "user": "51a3b135e4b0e77c4ca60bf6"}, {"code": "(fn [s] (let [e (empty s)] (cond (= e '()) (if (reversible? e) :vector :list) (= e {}) :map (= e #{}) :set)))", "problem": 65, "user": "5311cd03e4b08068f379ecef"}, {"code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "problem": 65, "user": "50436470e4b034ff00315d23"}, {"code": "(fn t [c] \n  (let [f (first c)]\n    (if (seq c)\n      (if (= (conj c f) c)\n        (if (every? #(c %) c) :set :map)\n        (if (= (conj c f) (cons f c)) :list :vector))\n      (t (conj c [1 2] [1 3])))))", "problem": 65, "user": "533ee560e4b085b17e897d98"}, {"code": "(fn [t]\n  (cond (= #{} (empty t)) :set\n        (= {} (empty t)) :map\n        (= [1 2] (conj (conj (empty t) 1) 2)) :vector\n        :else :list))", "problem": 65, "user": "51da631be4b02ceefd947766"}, {"code": "(fn [col]\n    (if (associative? col) (if (reversible? col) :vector :map) (if (= (count (conj col :my-test-kw :my-test-kw)) (+ 1 (count col))) :set :list)))", "problem": 65, "user": "524d90c0e4b0a16e35cf6ded"}, {"code": "(fn gi [o]\n  (cond\n   (reversible? o) :vector\n   (associative? o) :map\n   (= (empty o) ()) :list\n   (= (empty o) #{}) :set))\n\n#_(fn [col]\n    (condp = (empty col)\n      {} :map\n      #{} :set\n      (if (reversible? col)\n        :vector\n        :list)))", "problem": 65, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [coll]\n  (let [cc (conj coll [:a-random-sym :b-random-sym])]\n    (if (empty? (flatten cc))\n      (if (cc [:a-random-sym :b-random-sym])\n        :set\n        :map)\n      (if (= (first (conj cc :another-random-sym))\n             :another-random-sym)\n        :list\n        :vector))))", "problem": 65, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn [x]\n  (case (first (str x))\n    \\{ :map\n    \\( :list\n    \\[ :vector\n    \\# :set\n       :list))", "problem": 65, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn f [c]\n  (let [i [1 2]\n        c1 (conj c i)\n        c2 (conj c i i)\n        c3 (conj c i i [3 4])]\n    (if (= c1 c2)\n      (if (c1 1)\n        :map\n        :set)\n      (if (= (rest c3) c2)\n        :list\n        :vector)\n      )))", "problem": 65, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [c]\n   (let [x (-> (empty c)\n               (conj [1 2])\n               (conj [3 4])\n               (conj [3 4]))]\n     (cond\n      (= (first x) [1 2]) :vector\n      (= (get x 1) 2) :map\n      (= (count x) 2) :set\n      (= (count x) 3) :list\n      :else :dunno)))", "problem": 65, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "#(cond\n (:a (conj % [:a 1])) :map\n (:a (conj % :a)) :set\n (= :a (last (conj % :b :a))) :vector\n (= :a (first (conj % :b :a))) :list)", "problem": 65, "user": "4e705861535d5021c1a89635"}, {"code": "(fn [x] (cond\n                (= 3 (:c (into x {:c 3}))) :map\n                (= (inc (count x)) (count (into x [:a :a]))) :set\n                (= [2 1] (take 2 (reverse (into x [1 2])))) :vector\n                (= [1 2] (reverse (take 2 (into x [1 2])))) :list\n        ))", "problem": 65, "user": "5018ed15e4b011a2e0bf6412"}, {"code": "#(if (= [[1 2]] (into (empty %) [[1 2]]))\n   (if (= [1 2] (conj (empty %) 1 2)) :vector :list)\n   (if (contains? (into (empty %) [[1 2]]) 1) :map :set))", "problem": 65, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "#(if (= 0 (get (conj % [0 0]) 0))\n   :map\n   (if (= (conj (conj % 42) 42) (conj % 42))\n     :set\n     (if (zero? (first (conj % 1 0)))\n      :list\n      :vector)))", "problem": 65, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn test-coll\n  [coll]\n  (let [c [:c 3]\n        coll-c (conj coll [:f 5] c)\n        coll-c-2 (conj coll c c)]\n    (cond (= 3 (:c (conj coll c))) :map\n          (and (= 2 (count (filter #(= c %) coll-c-2))) (= c (first coll-c))) :list\n          (and (= 2 (count (filter #(= c %) coll-c-2))) (= c (last coll-c))) :vector\n          (and (= 1 (count (filter #(= c %) coll-c-2))) (= c (last (butlast coll-c)))) :set\n          :else :nada)))", "problem": 65, "user": "5339af7de4b0e30313ee6cab"}, {"code": "#(cond\n  (= (empty %) {}) :map\n  (= (empty %) #{}) :set\n  (= (first (conj % :dummy :insert)) :insert) :list\n  :else :vector)", "problem": 65, "user": "52de249ae4b09f7907dd13ed"}, {"code": "(fn [x]\n  (let [updated (conj x [::sentinel true] [::sentinel true] [::sentinel' true])\n        delta-count (- (count updated) (count x))]\n    (cond (and (associative? x) (= delta-count 2)) :map\n          (= delta-count 2) :set\n          (= (first updated) [::sentinel' true]) :list\n          :else :vector)))", "problem": 65, "user": "50fc299ee4b0d10d794c19f2"}, {"code": ";; based on `conj`\n#_(let [total (count %)\n       coll-new (conj % [:x :x] [:x :x] [:y :y] [:y :z])\n       total-new (count coll-new)]\n   (condp = (- total-new total)\n     2 :map\n     3 :set\n     4 (if (= [:y :z] (first coll-new))\n         :list\n         :vector)))\n\n;; use `empty` to avoid minus count\n#(let [coll (conj (empty %) [:a :a] [:a :a] [:b :b] [:b :c])\n       total (count coll)]\n   (condp = total\n     2 :map\n     3 :set\n     4 (if (= [:b :c] (first coll))\n         :list\n         :vector)))\n\n;; check daowen's solution (based on `contains?`)\n#_(fn [coll]\n  (condp #(contains? %2 %) (conj (empty coll) '[a b])\n    0 :vector, 'a :map, '[a b] :set, :list))", "problem": 65, "user": "4fceda40e4b03432b189f407"}, {"code": "(fn [c]\n         (cond\n          (= (conj c [1 1]) (conj c [1 2] [1 1])) :map\n          (= (conj c [1 1]) (conj c [1 1] [1 1])) :set\n          (= 1 (first (conj (conj (empty c) 2) 1))) :list\n          true :vector))", "problem": 65, "user": "534efe66e4b084c2834f4ac1"}, {"code": "(fn [i]\n    (if (associative? i)\n      (if (reversible? i)\n          :vector\n          :map)\n      (if (= (count (conj i 5)) (count (conj i 5 5)))\n        :set\n        :list)))", "problem": 65, "user": "53527ce8e4b084c2834f4af1"}, {"code": "(fn guess [l]\n  (cond\n   (= l {}) :map\n   (and (pos? (count l)) (= (count (flatten (seq l))) (* (count l) 2))) :map   \n   (< (count (conj l :a :a)) (+ (count l) 2)) :set\n   (= (first (conj l :a :b)) :b)  :list\n   :else :vector))", "problem": 65, "user": "5348236ee4b084c2834f4a54"}, {"code": "#(let [n (conj (empty %) [:a :b] [:a :b] [:b :c])]\n   (if (= 2 (count n))\n     (if (contains? n :a)\n       :map :set)\n     (if (= (first n) [:b :c])\n       :list :vector)\n     )\n   )", "problem": 65, "user": "5175533fe4b0dea9bbfba575"}, {"code": "#({\\[ :vector \\# :set \\{ :map} (nth (str %) 0) :list)", "problem": 65, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(let [is-list? (fn [a] (= (first (conj (conj a [1 2]) [2 3])) [2 3]))\n      is-vec?  (fn [a] (= (last (conj (conj a [1 2]) [2 3])) [2 3]))\n      is-set?  (fn [a] (= (conj (conj a [1 2]) [1 2]) (conj a [1 2])))\n      is-map?  (fn [a] (= (count (conj (conj a [99 2]) [99 3])) (count (conj a [99 2]))))]\n(fn bbt [x] \n  (if (is-set? x) \n    (if (is-map? x) \n      :map \n      :set)\n    (if (is-vec? x) \n      :vector \n      (if (is-list? x) \n        :list nil)))))", "problem": 65, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn fun [coll]\n  (cond\n   (reversible? coll) :vector\n   (associative? coll) :map\n   (apply distinct? (conj coll 1 1)) :set\n   :else :list))", "problem": 65, "user": "5349da55e4b084c2834f4a68"}, {"code": "#(cond (= (empty %) {}) :map\n       (= (empty %) #{}) :set\n       (reversible? %) :vector\n       :else :list)", "problem": 65, "user": "5357b241e4b04ce2eb3ed282"}, {"code": "(fn seq-type [coll]\n  (let [coll (empty coll)]\n    (cond\n     (= coll {}) :map\n     (= coll #{}) :set\n     (= coll '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn [c]\n  (let [f first j conj a concat]\n  (cond (or (empty? c) (= (count c) 1)) (recur (j c {:a 0} {:b 0}))\n        (= (merge c c) c) :map\n        (= (j c (f c)) c) :set\n        (= (j c (f c)) (a c [(f c)])) :vector\n        (= (j c (f c)) (a [(f c)] c)) :list\n        )))", "problem": 65, "user": "5356ac72e4b04ce2eb3ed26a"}, {"code": "(fn [coll]\n    (condp = (first (str coll))\n      \\{ :map\n      \\( :list\n      \\[ :vector\n      \\# :set\n      \\c :list))", "problem": 65, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn seq-type [coll]\n  (cond (= (get (conj coll [:a 1]) :a) 1) :map\n        (= (count (conj coll :a)) (count (conj (conj coll :a) :a))) :set\n        (= (cons 1 (cons 2 coll)) (conj (conj coll 2) 1)) :list\n        :else :vector))", "problem": 65, "user": "4e82c062535db62dc21a62cc"}, {"code": "(fn [coll]\n  (let [n (empty coll)]\n    (cond\n     (= n {})  :map\n     (= n #{}) :set\n     (= n '())  (if (reversible? n) :vector :list)\n     )))", "problem": 65, "user": "535778dee4b04ce2eb3ed27d"}, {"code": "#(condp = (first (str %))\n   \\# :set\n   \\[ :vector\n   \\{ :map\n   :list\n   )", "problem": 65, "user": "53307da1e4b019098a6f8b5e"}, {"code": "#(case (get (conj % [0 :t]) 0)\n   :t :map\n   nil (if (= 0 (get (conj % 0) 0))\n         :set\n         :list)\n   :vector)", "problem": 65, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn [coll]\n  (let [x (gensym)\n        y (gensym)\n        v [x y]\n        res (conj (conj coll v) v)]\n    (if (= 1 (count (filter #{v} res)))\n      (if (= (res x) y) :map :set)\n      (if (= (first (conj res x)) x) :list :vector))))", "problem": 65, "user": "53523ae0e4b084c2834f4aee"}, {"code": "(fn [col]\n    (let [initial-count (count col)\n          poked (conj col [:x 1] [:x 1] [:y 2])]\n      (cond \n       (= (count poked) (+ 3 initial-count)) (if (= (first poked) [:y 2]) :list :vector)\n       (= (count poked) (+ 2 initial-count)) (if (poked :x) :map :set))))", "problem": 65, "user": "52a32876e4b04e0c58e87bfb"}, {"code": "(fn [c]\n  (let [e (empty c)]\n    (cond\n      (= 1 (:a (conj e [:a 1]))) :map\n      (= 1 (count (conj e 1 1))) :set\n      (= 1 (first (conj e 1 2))) :vector\n      (= 2 (first (conj e 1 2))) :list)))", "problem": 65, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [col] \n  (let [empty-col (empty col)] \n    (cond\n      (= {} empty-col) :map\n      (= #{} empty-col) :set\n      (= 999 (first (conj col 998 999))) :list\n      :else :vector)))", "problem": 65, "user": "53286389e4b09d4e7a9b5504"}, {"code": "(fn t8 [x]\n  (if (associative? x)\n    (if (reversible? x)\n      :vector\n      :map)\n    (if (contains? (conj x :decoy) :decoy)\n      :set\n      :list)))", "problem": 65, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn [collection]\n  (let [test-value [:test-value :test-value]\n        result (conj (conj collection test-value) test-value)]\n    (cond\n     (:test-value result) :map\n     (apply distinct? result) :set\n     :else (let [result-2 (conj result :another-test-value)]\n             (cond\n              (= (first result-2) :another-test-value) :list\n              (= (last result-2) :another-test-value) :vector))\n     )))", "problem": 65, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn [x]\n    (let [before (count x)\n          new-x (conj x [:a-key :a-value] [:a-key :a-value])\n          after (count new-x)]\n      (if (= (- after before) 1)\n        (let [new-x (conj x [:a-key :a-value])\n              a-value (get new-x :a-key)]\n          (if (= a-value :a-value)\n            :map\n            :set))\n        (let [new-x (conj x :lakmoes1 :lakmoes2)\n              lst (last new-x)]\n          (if (= lst :lakmoes2)\n            :vector\n            :list)))))", "problem": 65, "user": "4f3d83b5e4b0e243712b1f69"}, {"code": "(fn [coll]\n    ({\"{}\" :map\n      \"#{}\" :set\n      \"[]\" :vector\n      \"()\" :list} (print-str (empty coll))))", "problem": 65, "user": "51c3c6a6e4b0851ac09658f8"}, {"code": "(fn bbt\n  [s]\n  (let [conj1 (conj s (first s) (first s))]\n    (if (< (- (count conj1) (count s)) 2)\n      (let [teste {:a 1}\n            conj2 (conj s teste)]\n        (if (contains? conj2 teste)\n          :set\n          :map))\n      (let [teste (str (str (first conj1)) \"salt\")\n            conj2 (conj conj1 teste)]\n        (if (and (= teste (first conj2)) (not= teste (last conj2)))\n          :list\n          :vector)))))", "problem": 65, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [coll]\n   (condp = (get (print-str coll) 0)\n     \\{ :map\n     \\# :set\n     \\[ :vector\n     \\( :list))", "problem": 65, "user": "51d4ed02e4b013d740b70dec"}, {"code": "(fn [s]\n    (cond\n      (= (conj s {}) s)\n      :map\n      (reversible? s)\n      :vector\n      (= (count (conj s 1)) (count (conj (conj s 1) 1)))\n      :set\n      :else\n      :list\n      ))", "problem": 65, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [coll]\n  (if (associative? coll) \n    (if (reversible? coll) :vector :map)\n    (let [coll2 (conj coll :p1 :p2)]\n      (if (= (first coll2) :p2) :list :set))))", "problem": 65, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn bb [c]\n\t(cond \n     (-> c\n         (conj {1 2} {3 4})\n         first\n         (= {3 4})) :list\n     (-> c\n         (conj {1 2} {3 4} {3 4})\n         ((juxt last count))\n         (= [{3 4}, (+ 3 (count c))])) :vector\n     (-> c\n         (conj {:x :y})\n         (apply [:x])\n         (= :y)) :map\n     :else :set\n   )\n)", "problem": 65, "user": "53720c5ce4b0493c815db704"}, {"code": "(fn [c]\n  (let [poked (conj (empty c) [:a 1] [:a 1] [:b 2])]\n    (if (= (count poked) 2)\n      (if (= (:b poked) 2) :map :set)\n      (if (= (first poked) '(:b 2)) :list :vector))))", "problem": 65, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn [coll] \n  (case (first (str coll))\n    \\# :set\n    \\{ :map\n    \\[ :vector\n       :list))", "problem": 65, "user": "509fe759e4b08df8156e9e43"}, {"code": "#(if (= (conj % [% %] [% %])\n        (conj % [% %]))\n   (if ((conj % [% %]) %)\n     :map\n     :set)\n   (if (= (conj % % [%])\n          (cons [%] (cons % %)))\n     :list\n     :vector))", "problem": 65, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [xs]\n  (let [conjed (conj (conj (conj xs [:xxx 1]) [:xxx 1]) [:yyy 2])]\n    (cond (= (:xxx conjed) 1) :map\n          (= (count conjed) (+ (count xs) 2)) :set\n          (= (first conjed) [:yyy 2]) :list\n          (= (last conjed) [:yyy 2]) :vector\n          :else :unknown)))", "problem": 65, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n     (= base {})\t\t:map\n     (= base #{})\t\t:set\n     (reversible? base)\t:vector\n     (= base ())\t\t:list)))", "problem": 65, "user": "53790dc6e4b06839e8705e4c"}, {"code": "(fn [coll]\n  (-> coll\n      (empty)\n      (conj [:a :b1] [:a :b2] [:a :b2])\n      {\n        {:a :b2}                       :map,\n        '([:a :b2] [:a :b2] [:a :b1])  :list,\n        [[:a :b1] [:a :b2] [:a :b2]]   :vector,\n        #{[:a :b1] [:a :b2]}           :set\n      }))", "problem": 65, "user": "53779a26e4b06839e8705e38"}, {"code": "(fn [s](let [matchers {#{} :set {} :map}]\n          (matchers (empty s) (if (associative? s) :vector :list))))", "problem": 65, "user": "536046a9e4b063bf7a5f8fe1"}, {"code": "(fn [x]\n  (cond              \n    (.isInstance clojure.lang.IPersistentMap x) :map\n    (.isInstance clojure.lang.IPersistentList x) :list\n    (.isInstance clojure.lang.LazySeq x) :list\n    (.isInstance clojure.lang.IPersistentVector x) :vector\n    (.isInstance clojure.lang.IPersistentSet x) :set))", "problem": 65, "user": "536d260be4b0fc7073fd6e55"}, {"code": "#(cond\n   (= % (conj % {})) :map\n   (= (conj % :x) (conj (conj % :x) :x)) :set\n   (= :x (first (conj (conj % :_) :x))) :list\n   (= :x (last  (conj (conj % :_) :x))) :vector)", "problem": 65, "user": "52f4fae4e4b05e3f0be25f27"}, {"code": "(fn [inp]\n  \t(cond\n     \t(= :sentinal (get (conj inp [:sentinal :sentinal]) :sentinal)) :map\n     \t(= (conj inp (first inp)) #{nil}) :set\n     \t(= (conj inp (first inp)) inp) :set\n     \t(= (first (conj (conj inp :foo) :sentinal)) :sentinal) :list\n     \t(= (last (conj (conj inp :foo) :sentinal)) :sentinal) :vector\n     ))", "problem": 65, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn [coll]\n              (if (= {} (empty coll))\n                :map\n                (if (= #{} (empty coll))\n                  :set\n                  (if (reversible? coll)\n                    :vector\n                    :list\n                    )\n                )))", "problem": 65, "user": "4dd579b5535dae65d5c462ea"}, {"code": "(fn [x]\n  (cond \n   (not (ifn? x)) :list\n   (not (associative? x)) :set\n   (reversible? x) :vector\n   :else :map))", "problem": 65, "user": "536a37efe4b0243289761eaa"}, {"code": "(fn a [x]\n  (let [y (nth (str x) 0)]\n  (cond\n    (= y \\{) :map\n    (= y \\#) :set \n    (= y \\c) :list \n    (= y \\[) :vector)))", "problem": 65, "user": "535aee3be4b04ce2eb3ed2aa"}, {"code": "(fn [x] (cond (= x (into [] x))\n            (if (= (first (conj x :b :a)) :a) :list :vector)\n            (= x (into #{} x)) :set\n            true :map))", "problem": 65, "user": "51e28063e4b08e53a149f0f2"}, {"code": "(fn [x]\n  (cond\n    (:moo (conj x [:moo 55])) :map\n   \t(= [50 60 60] (take-last 3 (conj x 50 60 60))) :vector\n    (= [60 60 50] (take 3 (conj x 50 60 60))) :list\n    (= (count (conj x 10)) (count (conj x 10 10))) :set))", "problem": 65, "user": "53834ed3e4b06839e8705edb"}, {"code": "(fn collection-type? [c]\n  (cond\n   (get (conj c [:map true]) :map) :map\n   (= (first (conj c 24 25)) 25) :list\n   (= (+ 1 (count c)) (count (conj c 25 25))) :set\n   true :vector))", "problem": 65, "user": "5364697ce4b0243289761e62"}, {"code": "(fn decuce [s]\n    (if (get (into s [{:foo true}]) :foo) :map\n     (let [nes (into s [:foo])]\n       (if (= (count nes) (count (into nes [(first nes)]))) :set\n         (if (= nes (first (conj nes nes)))\n            :list\n            :vector)))))", "problem": 65, "user": "537e745ae4b06839e8705ea6"}, {"code": "(fn [xs]\n  (let [f (first (map char (str xs)))]\n    (cond\n     (= f \\{) :map\n     (= f \\#) :set\n     (= f \\() :list\n     (= f \\c) :list\n     (= f \\[) :vector)))", "problem": 65, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn[coll]\n\t  (let [obj (new Object)]\n\t    (let [x (conj coll [1 2])]\n\t      (cond\n\t        (empty? (flatten x)) (if (associative? x) :map :set)\n\t        (= (first (conj x obj)) obj) :list\n\t        :else :vector\n\t      )\n\t)))", "problem": 65, "user": "53713676e4b0fc7073fd6eac"}, {"code": "#(let [e (empty %)]\n    (cond\n      (= e {})  :map\n      (= e #{}) :set\n      (= e '()) (if (reversible? %) :vector :list)))", "problem": 65, "user": "53403110e4b085b17e897da6"}, {"code": "(fn [t]\r\n  (cond\r\n   (reversible? t) :vector\r\n   (associative? t) :map\r\n   (= t (apply list t)) :list\r\n   :else :set))", "problem": 65, "user": "5376966ae4b06839e8705e27"}, {"code": "#(let [coll (empty %)]\n   (cond\n    (= (get (conj coll [1 2]) 1) 2) :map\n    (= (conj coll 1 2) [1 2]) :vector\n    (= (conj coll 1 2) [2 1]) :list\n    :else :set))", "problem": 65, "user": "537f4652e4b06839e8705eb1"}, {"code": "(fn [coll]\n  (let [coll (conj (empty coll) [0 1])\n        v (get coll 0)]\n    (cond\n     (= v 1) :map\n     (= v [0 1]) :vector\n     :else (if (= (get coll [0 1]) [0 1]) :set :list))))", "problem": 65, "user": "524b0645e4b09eba1c0223bf"}, {"code": "#(let [t [[100 200] [100 200] [300 400]]\n        c (apply conj % t)]\n    (cond\n      (= (get c 300) 400) :map\n      (= (count c) (+ 2 (count %))) :set\n      (= (first c) [300 400]) :list\n      (= (last c) [300 400]) :vector\n      ))", "problem": 65, "user": "51a54fb4e4b0def3c5c586a3"}, {"code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "problem": 65, "user": "538754b1e4b06839e8705f1c"}, {"code": "(fn [mystery]\n  (let [empty-mystery (empty mystery)\n        e1 (vector :a :b)\n        e2 (vector :c :d)\n        with-e1 (conj empty-mystery e1)\n        with-e1-e2 (conj with-e1 e2)]\n    (if (= with-e1 (conj with-e1 e1))\n      (if (contains? with-e1 :a) :map :set)\n      (if (= (first with-e1-e2) e1) :vector :list))))", "problem": 65, "user": "53800d99e4b06839e8705ebd"}, {"code": "#(cond\n  (identical? (rest (cons 1 %)) %) :list\n  (= % (vec %)) :vector\n  (= % (set %)) :set\n  1 :map)", "problem": 65, "user": "538d8bb8e4b0b51d73faae71"}, {"code": "#(let [a (empty %)]\n   (cond\n    (= #{} a) :set\n    (= {} a) :map\n    (= :b (first (conj % :a :b))) :list\n    :else :vector))", "problem": 65, "user": "533018b2e4b019098a6f8b56"}, {"code": "(fn classify [coll]\n  (let [e (empty coll)]\n    (cond\n      (= e {})  :map\n      (= e #{}) :set\n      (= e '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn [seqn]\n  (cond\n   ;; yes, this is cheating\n   (= {} (empty seqn))\n   :map\n   ;;\n   ;; if we add an element twice, but it only shows up once, it's a set\n   (= (count (conj (empty seqn) 1))\n      (count (conj (empty seqn) 1 1)))\n   :set\n   ;;\n   ;; if elements get added at the end, it's a vector\n   (= 2 (last (conj (empty seqn) 1 2)))\n   :vector\n   ;;\n   true\n   :list))", "problem": 65, "user": "53889587e4b0640c7a9a589e"}, {"code": "(fn [x]\n  (cond (= x (conj x x)) :map\n        (= (conj x 1) (conj (conj x 1) 1)) :set\n        (= (cons 1 (cons 2 x)) (conj (conj x 2) 1)) :list\n        :else :vector))", "problem": 65, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "#(cond\n  (= {} (conj (empty %) nil)) :map\n  (= (inc (count %)) (count (conj % :a :a))) :set\n  (= :b (first (conj % :a :b))) :list\n  :e :vector)", "problem": 65, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn determinetype [s]\n  (let [islist? (fn [a] (not (ifn? a)))\n        isset? (fn [a] (and (not (associative? a))\n                       (not= (vec a)\n                          a)))]\n   (cond \n    (islist? s)   :list\n    (isset? s)    :set\n    (= (vec s) s) :vector\n    :else         :map)))", "problem": 65, "user": "5314b0cae4b08068f379ed1c"}, {"code": "(fn [x]\n  (if (or (= {} x)\n          (not (nil? (:b (conj x [:b 3])))))\n    :map\n    (if (or (= #{} x)\n            (and (not= {} x)\n                 (= (conj x :test :test)\n                    (conj x :test))))\n      :set\n      (if (and (not= {} x)\n               (= :testelem\n                  (last (conj x :testelem2 :testelem))))\n        :vector\n        (if (and (not= {} x)\n                 (= :testelem\n                    (first (conj x :testelem2 :testelem))))\n          :list\n          :map)))))", "problem": 65, "user": "50981062e4b04e098a4c7268"}, {"code": "(fn [a]\n  (let [c (count a)]\n    (cond (= (inc c) (count (into a [[1 2] [1 3]]))) :map\n          (= (inc c) (count (into a [:a :a]))) :set\n          (= :a (first (into a [:b :a]))) :list\n          :else :vector\n          )))", "problem": 65, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn ttest [m]\n  (let [settv (conj m (first m))\n        velt (conj m [2 400] [1 200])\n        maptv (conj m (conj m [:tester 1]) [:tester 2])]\n      (if (or (= (inc (count m)) (count maptv)) (= m {}))\n      :map\n       (if (or (= (count m) (count settv)) (= m #{}))\n      \t:set\n         (if (= [1 200] (first velt))\n           :list\n           :vector)))))", "problem": 65, "user": "52747090e4b03e8d9a4a74a5"}, {"code": "(fn [x]\n  (let [c (conj (empty x) [:a 1])]\n    (if (get c :a)\n      :map\n      (if (get c [:a 1])\n        :set\n        (let [c (conj c 2)]\n          (if (= 2 (first c))\n            :list\n            :vector))))))", "problem": 65, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn [s]\n  (cond\n   (and (empty? s) (= (into s {:a :b}) {:a :b}))  :map\n   (not (= (count s) (count (flatten (seq s)))))  :map\n   (and (empty? s) (= 1 (count (conj s :a :a))))  :set\n   (= (count s) (count (conj s (first s))))       :set\n   (= (first (conj s :a :b)) :b)                  :list\n   (= (last (conj s :a :b)) :b)                   :vector\n   :else :???))", "problem": 65, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn [n] \n    (let [k [:special :key]]\n    (let [x (conj (conj n [:another :key]) k)] \n      (if (= :key (get x :special)) :map \n      (if (= (get x k) k) :set \n      (if (= (last x) k) :vector\n      (if (= (first x) k) :list\n    ))))))\n  )", "problem": 65, "user": "5394265ee4b0b51d73faaec6"}, {"code": "#(get { \"[]\" :vector \"{}\" :map \"#{}\" :set \"clojure.lang.PersistentList$EmptyList@1\" :list} (str (empty %)))", "problem": 65, "user": "538d7e2ee4b0b51d73faae70"}, {"code": "(fn [col]\n  (cond\n   (reversible? (empty col)) :vector\n   (= {} (empty col)) :map\n   (= #{} (empty col)) :set\n   :else :list))", "problem": 65, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(fn [s]\n  (let [t (conj s [:asdf 4] [:asdf 5])]\n    (cond\n     (= (count t) (inc (count s))) :map\n     (= (first t) [:asdf 5]) :list\n     (= (conj t [:asdf 4]) t) :set\n     :else :vector)))", "problem": 65, "user": "533696b9e4b0e30313ee6c7c"}, {"code": "(fn check-box [coll]\n  (cond\n   (= :v (get (conj coll [:k :v]) :k))     :map\n   (= (conj coll \"s\") (conj coll \"s\" \"s\")) :set\n   (= \"l\" (first (conj coll \"v\" \"l\")))     :list\n   (= \"v\" (last (conj coll \"l\" \"v\")))      :vector\n  ))", "problem": 65, "user": "53973e7be4b0b51d73faaee6"}, {"code": "(fn [coll]\n  (cond\n   (and (associative? coll) (reversible? coll)) :vector\n   (associative? coll) :map\n   (= (count (conj coll 1)) (count (conj (conj coll 1) 1))) :set\n   :else :list\n  ))", "problem": 65, "user": "53778b90e4b06839e8705e36"}, {"code": "(fn [x]\n  (if (= (count (conj (conj x [:a 1]) [:a 1])) (count (conj x [:a 1])))\n      ; It's a map or a set...\n      (if (= 1 (get (conj x [:a 1]) :a))\n          :map\n          :set)\n      ; It's a list or a vector...\n      (let [y (conj (conj x [:a 1]) [:b 2])]\n        (if (= [:b 2] (last y))\n            :vector\n            :list))))", "problem": 65, "user": "53940789e4b0b51d73faaec3"}, {"code": "(fn [seqs]\n  (let [i1 [1 2]\n        i2 [1 3]\n        prev-cnts (count seqs)\n        seq1 (conj seqs i1 i1)\n        seq2 (conj seqs i1 i2)]\n    (if (= (count seq1) (inc prev-cnts))\n      (if (= (get seq1 i1) i1)\n      :set\n      :map)\n      (if (= (last seq2) i2)\n        :vector\n        :list))))", "problem": 65, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn [ c ]\n    (let [ d (conj c [21 20] [:x :y] [:x :y] [31 30])\n           m? (= (get d 31) 30) ]\n        (cond\n            (and (= (first d) [31 30]) (not m?)) :list\n            (and (= (last d) [31 30]) (not m?) (= (count d) (+ 4 (count c)))) :vector\n            m? :map\n            (= (count d) (+ (count c) 3)) :set)))", "problem": 65, "user": "5398305fe4b0b51d73faaef6"}, {"code": "#(let [e (empty %)]\n    (if (= :b (:a (conj e [:a :b])))\n        :map\n        (let [s (conj e :a :b)]\n          (if (= :a (:a s))\n              :set\n              (if (= :a (first s))\n                  :vector\n                  :list)))))", "problem": 65, "user": "4ec53f8c535d6d7199dd368b"}, {"code": "(fn [c]\n  \t(if (associative? c)\n\t\t(if (not (reversible? c)) :map :vector)\n\t\t(if (apply distinct? (conj c 1 1)) :set :list)))", "problem": 65, "user": "52e657e4e4b09f7907dd1472"}, {"code": "(fn[coll]\n  (let [a (gensym) b (gensym)]\n    (cond (contains? (conj coll [a b]) a) :map\n     \t  (= (count (into coll '(a b b))) (inc (inc (count coll)))) :set\n          (= (first (conj (conj coll a) b)) b) :list\n          (= (last (conj (conj coll a) b)) b) :vector)))", "problem": 65, "user": "53a1b5c8e4b0ca733b9744c1"}, {"code": "(fn detect-type [a]\n  (case\n      (count (into (empty a) [[1 1] [1 1] [1 2]]))\n    1 :map\n    2 :set\n    3 (case (conj (conj (empty a) 2) 1)\n        [2 1] :vector\n        [1 2] :list)))", "problem": 65, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn seq-type [coll]\n(let [base (empty coll)]\n(cond\n(= base {}) :map\n(= base #{}) :set\n(= base '()) (if (reversible? coll) :vector :list))))", "problem": 65, "user": "53976599e4b0b51d73faaeea"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "537e59ffe4b06839e8705ea3"}, {"problem": 65, "code": "(fn [x]\n(let [base (empty x)]\n(cond\n(= base {}) :map\n(= base #{}) :set\n(= base '()) (if (reversible? x) :vector :list))))", "user": "53a19dece4b0ca733b9744c0"}, {"problem": 65, "code": "(fn\n  [coll]\n  (let [size (.size coll)\n        newsym (gensym)\n        newsym' (gensym)\n        coll2 (conj coll [newsym newsym'])]\n    (cond\n      (get coll2 newsym) :map\n      (= (inc size) (.size (conj (conj coll newsym) newsym))) :set\n      (= newsym' (last (conj (conj coll newsym) newsym'))) :vector\n      :else :list)))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 65, "code": "(fn [coll] (let [c (empty coll)]\n              (cond (= c {}) :map\n                    (= c #{}) :set\n                    (= c []) (if (reversible? c) :vector :list))))", "user": "52e4f06be4b09f7907dd1456"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll (conj (empty coll) [:a 1] [:a 1])]\n    (if (= (count coll) 1)\n      (if (= (:a coll) 1)\n        :map\n        :set)\n      (if (first (conj coll false)) \n        :vector\n        :list))))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 65, "code": "(fn get-class [x]\n   (cond \n    (= x (apply hash-set x)) :set\n    (> (+ 1 (count x)) (count (flatten ( into x {:a 1})))) :map\n    (= [:b 1] (first (into x {:a 1 :b 1}))) :list\n    :else :vector))", "user": "53a5c7ffe4b0ef122a8689c4"}, {"problem": 65, "code": "(fn test-seq [coll]\n  (cond (and (seq (flatten (conj coll [:x 0])))\n             (= :x (first (conj (conj coll :y) :x)))) :list\n        (contains? (conj coll [:xxxxx 0]) :xxxxx) :map\n        (contains? (conj coll :x) :x) :set\n        :else :vector))", "user": "529e3a4fe4b04e0c58e87b92"}, {"problem": 65, "code": "(fn [d]\n  (let [e (empty d)]\n    (cond\n     (= e {}) :map\n     (= e #{}) :set\n     (= e []) (if (reversible? d) :vector :list))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 65, "code": "(fn [col]\n    (cond\n     (associative? col) (if (= (conj col [1 1] [1 1]) (conj col [1 1])) :map :vector)\n     (= (conj col 1 1) (conj col 1)) :set\n     :else :list))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 65, "code": "(fn bb [c]\n  (let [e (empty c)]\n    (cond (= e #{}) :set\n          (= e {}) :map\n          (= (conj e 1 2) '(2 1)) :list\n          (= (conj e 1 2) [1 2]) :vector)))", "user": "5396c94be4b0b51d73faaee3"}, {"problem": 65, "code": "(fn [coll]\n  (let [emptied (empty coll)\n        a (gensym)]\n    (cond\n      (= emptied {})  :map\n      (= emptied #{}) :set\n      (= a (first (conj coll (gensym) a))) :list\n     :else :vector)))", "user": "5080a697e4b01a93d3f38e49"}, {"problem": 65, "code": "(fn [x]\n  (let [s (conj x [:z 100] [:y 100])]\n    (cond\n     (= 100 (:z s)) :map\n     (= s (conj s [:z 100])) :set\n     (= [:y 100] (last s)) :vector\n     :else :list)))", "user": "53767991e4b06839e8705e25"}, {"problem": 65, "code": "(fn [s]\n\t(let [conj-s-nil (conj s nil)]\n\t\t(cond \n\t\t\t(= conj-s-nil s) :map\n\t\t\t(= conj-s-nil (conj conj-s-nil nil)) :set\n   \t\t\t(= (first (conj conj-s-nil s)) s) :list\n      \t\t:true :vector)))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 65, "code": "(fn black-box-test[m]\n\t\t(cond \n\t\t\t(= (conj m {}) m) :map\n\t\t\t(empty? m)\n\t\t\t\t(cond \n\t\t\t\t\t(= (conj m #{}) #{#{}}) :set\n\t\t\t\t\t(= (conj (conj m 3) 4) [3 4]) :vector\n\t\t\t\t\t:else :list)\n\t\t\t(= (clojure.set/union m m) m) :set\n\t\t\t(= (last (conj m (first m))) (first m)) :vector\n\t\t\t:else :list))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 65, "code": "(fn [d]\n  ({\\( :list \\[ :vector \\{ :map \\# :set} (first (print-str d))))", "user": "53ae16e2e4b047364c044472"}, {"problem": 65, "code": "(fn whatis [coll]\n   (cond\n    (reversible? coll) :vector\n    (associative? coll) :map\n    (= (count (conj (conj coll :jpK1) :jpK1)) (count (conj coll :jpK1))) :set\n    :else :list\n    )\n   )", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll (into coll [[:a 1] [:b 2]])]\n    (if (get coll :a)\n      :map\n      (let [coll1 (into coll [[:a 1]])]\n        (if (= (count coll1) (count coll))\n          :set\n          (if (= (first coll) [:b 2])\n            :list\n            :vector\n            )\n        )\n      )\n    )\n  ))", "user": "5245e320e4b09dbe66b56177"}, {"problem": 65, "code": "(fn seq-type\n  [coll]\n  (let [c (into (empty coll) [ [1 2] [1 2] [2 3] ])]\n    (cond (= 3 (get c 2)) :map\n          (= 2 (count c)) :set\n          (= (first c) [1 2]) :vector\n          :else :list)))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 65, "code": "(fn f [s] (if (let[m (merge s {:a :b})](= (count (flatten (vec m))) (* (count m) 2))) :map\n  (if (= (conj (conj s :b) :b) (conj s :b)) :set \n            (if (= (first (conj (conj s :c) :b)) :b) :list \n              (if (= (last (conj (conj s :c) :b)) :b) :vector  nil ) )) ))", "user": "53b3ea79e4b047364c0444ab"}, {"problem": 65, "code": "#(let [x (empty %)] (condp = x {} :map #{} :set (if (reversible? x) :vector :list)))", "user": "534c1c64e4b084c2834f4a8a"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (not (ifn? x))         :list\n   (not (associative? x)) :set\n   (reversible? x)        :vector\n   true                   :map))", "user": "5290257ae4b0239c8a67af03"}, {"problem": 65, "code": "(fn [c] \n  (get {{:b 2, :a 1} :map [[:a 1] [:b 2]] :vector '([:b 2] [:a 1]) :list #{[:b 2] [:a 1]} :set}\n        (conj (conj (empty c) [:a 1]) [:b 2])))", "user": "52d07cc5e4b07d0d72b273bb"}, {"problem": 65, "code": "(fn black-box\n  [x]\n  (cond\n   (=\n    (get (conj x {:a 2}) :a)\n    2) :map\n   (=\n    (conj x (first x))\n    (conj (conj x (first x)) (first x))) :set\n   (= \n    (conj x 23)\n    (drop-last (conj (conj x 23) 24))) :vector\n   :else :list\n   ))", "user": "53ac4719e4b047364c04445c"}, {"problem": 65, "code": "#(cond (contains? (conj % [:maptest 5]) :maptest) :map\n       (= (count (filter (partial = :settest) \n                         (into % [:settest :settest])))\n          1) :set \n       (= (last (conj (conj % :notvec) :vectest)) :vectest) :vector\n       :else :list)", "user": "53acaf1fe4b047364c04445f"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "4f867b25e4b033992c121c51"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "user": "53858594e4b06839e8705f05"}, {"problem": 65, "code": "(fn black-box [coll]\n    (let [x (empty coll)]\n        (cond\n            (= x {}) :map\n            (= x #{}) :set\n            (= x '()) (if (reversible? coll) :vector :list))))", "user": "532c9dc9e4b019098a6f8b30"}, {"problem": 65, "code": "(fn seq-type [a-seq]\n  (let [elem1 [:qw1 :u71]\n        elem2 [:qw2 :u72]\n        b-seq (conj a-seq elem1 elem2)]\n    (cond\n      (= (:qw1 b-seq) :u71) :map\n      (= b-seq (conj b-seq elem1)) :set\n      (= (last b-seq) elem2) :vector\n      :else :list)))", "user": "52ee46e5e4b05e3f0be25ec5"}, {"problem": 65, "code": "(fn alt-type [coll]\n  (let [test (first (str (empty coll)))]\n    (cond\n     (= test \\c) :list\n     (= test \\{) :map\n     (= test \\#) :set\n     (= test \\[) :vector\n     :else :unknown)))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 65, "code": "(fn blackbox [s]\n(cond\n(= (conj s {}) s) :map\n(empty? s) (cond\n(= (clojure.set/union s #{}) #{}) :set\n(= (conj (conj s 0) 1) [0 1]) :vector\n:else :list)\n(= (clojure.set/union s s) s) :set\n(= (first (conj s s)) s) :list\n:else :vector))", "user": "525edb2ce4b0cb4875a45db9"}, {"problem": 65, "code": "#(cond\n   (:a (conj % [:a 1])) :map\n   (< (- (count (conj % 1 1)) (count %)) 2) :set\n   (= (conj % 1 2) (cons 2 (cons 1 %))) :list\n   :else :vector)", "user": "538d49e1e4b0b51d73faae6b"}, {"problem": 65, "code": "(fn [coll]\n  (let [len (.size coll)]\n    (if (= (+ 1 len) (.size (conj (conj coll [:x 3]) [:x 4])))\n      :map\n      (let [element (if (empty? coll) :unique_element (first coll))]\n        (let [x (conj coll element), y (conj x element)]\n          (if (= (.size y) (.size x))\n            :set\n            (let [xs (conj (conj coll :second) :first)]\n              (if (== 0 (.indexOf xs :first))\n                :list\n                :vector))))))))", "user": "537f8e7be4b06839e8705eb8"}, {"problem": 65, "code": "#(cond\n  (= (into (conj % [:a :a]) (conj % [:a :a])) (conj % [:a :a])) \n  \t\t(if (= \n  \t\t\t\t(into % [[:a :c] [:a :b]])\n  \t\t\t\t(into % [[:a :b]]))\n  \t\t\t:map :set)\n  (= :a (first (conj (into % (range 10)) :a))) :list\n  (= :a (last (conj (into % (range 10)) :a))) :vector)", "user": "4fe83efbe4b07c9f6fd12c3b"}, {"problem": 65, "code": "(fn [collection]\n  (let [bi-test (conj collection [:first :second])]\n    (if (= (:first bi-test) :second) \n      :map      \n      (let [uni-test (conj collection :first :second)]\n        (cond\n          (= (:first uni-test) :first) :set\n          (= (last (seq uni-test)) :second) :vector\n          (= (first (seq uni-test)) :second) :list)))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 65, "code": "(fn [col]\n     (let [testCol (into (empty col) [[1 2] [1 2]])\n           testColCount (count testCol)]\n       (cond\n         (= 1 testColCount) (cond \n                              (= (testCol 1) 2) :map\n                              :else :set)\n         (= :v (first (conj testCol :v))) :list\n         :else :vector)))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 65, "code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "539b4268e4b0b51d73faaf1c"}, {"problem": 65, "code": "(fn brute [s]\n    (let [c (first (str s))]\n        (cond\n            (= c \\{) :map\n            (= c \\#) :set\n            (= c \\[) :vector\n            :else :list)))", "user": "53a94b63e4b047364c044434"}, {"problem": 65, "code": "#(let [x [:x 2]\n        l (conj (conj (conj % [:x 1]) x) x)\n        i (count %)\n        j (count l)]\n    (cond\n     (= j (inc i)) :map \n     (= j (+ 2 i)) :set\n     (= x (first l)) :list\n     true :vector))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 65, "code": "(fn [s]\n  (let [fc (first (str s))\n        ]\n    (if (= fc \\{)\n      :map\n      (if (or (= fc \\( ) (= fc \\c) )\n        :list\n        (if (= fc \\[ )\n          :vector\n          :set))))\n                    \n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 65, "code": "#(cond\n   (= 1 (count (into (empty %) [[1 1] [1 2] [1 2]]))) :map\n   (= 2 (count (into (empty %) [[1 1] [1 2] [1 2]]))) :set\n   :else (first (conj (conj (empty %) :vector) :list)))", "user": "538db083e4b0b51d73faae74"}, {"problem": 65, "code": "(fn [xs]\n  (cond\n    (= (inc (count xs)) (count (conj xs [:one 5] [:one 6]))) :map\n    (= (inc (count xs)) (count (conj xs 5000 5000))) :set\n    (= (last (conj xs 5000 5001)) 5001) :vector\n    :default :list\n    ))", "user": "53c3397be4b00fb29b221279"}, {"problem": 65, "code": "(fn [x]\n     (if (= (conj x nil) x)\n       :map    \n       (if (= (conj (conj x :a) :a) (conj x :a))\n         :set\n         (if (nil? (get (conj (empty x) :z) 0))\n           :list\n           :vector))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 65, "code": "(fn [s]\n  (if (-> clojure.lang.PersistentVector (.isInstance s))\n    :vector\n    (if (-> clojure.lang.PersistentArrayMap(.isInstance s))\n      :map\n      (if (-> clojure.lang.PersistentHashSet (.isInstance s))\n        :set\n        :list))))", "user": "4e8849c5535d8b9bb0147ca4"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (= {} (empty x)) :map\n   (= #{} (empty x)) :set\n   (= () (empty x)) (if (= (first (conj (empty x) 1 2)) 2) :list :vector)\n   ))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 65, "code": "(fn [x]\n  (if (= x (rest (cons 1 x))) ; true if list or vector\n    (if (= (conj x 1 2) (concat '(2 1) x)) ; true if list\n      :list\n      :vector)\n    (if (contains? (merge x {:foo 'bar}) :foo) ; true if map\n      :map\n      :set)))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 65, "code": "#(condp = (first (str %))\n   \\{ :map\n   \\[ :vector\n   \\# :set\n   \\c :list)", "user": "51febd40e4b0f1313d468a76"}, {"problem": 65, "code": "#(case (nth (str %) 0)\n  \\{ :map\n  \\[ :vector\n  \\# :set\n  :list)", "user": "4e6961f0535d8ccf87e9fe9b"}, {"problem": 65, "code": "(fn tp [a]\n  (let [uniq #()\n        p [uniq :p]\n        q [uniq :q]\n        m (conj (conj a p) q)]\n    (if (= (get m uniq) :q) :map\n      (if (get m p) :set\n        (if (= (first m) q) :list :vector)))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= (inc (count coll)) (count (conj (conj coll [:c 3]) [:c 4])))\n   :map\n   \n   (= (conj coll :a) (conj (conj coll :a) :a))\n   :set\n   \n   (= (conj (conj coll :a) :b) (cons :b (cons :a coll)))\n   :list\n   \n   :else\n   :vector))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 65, "code": "(fn box-test [s]\n  (let [e (empty s)]\n  (cond\n   (= (conj (conj e {1 2}) {3 4}) '({3 4} {1 2})) :list\n   (= e []) :vector\n   (= e {}) :map\n   (= e #{}) :set\n   )))", "user": "53ad2bbbe4b047364c044464"}, {"problem": 65, "code": "(fn type-identification [coll]\n  (let [str-coll (first (seq (str coll)))]\n    (case str-coll\n      (or \\c \\() :list\n      \\[ :vector\n      \\{ :map\n      \\# :set\n      nil)))", "user": "53d40508e4b00fb29b221332"}, {"problem": 65, "code": "(fn bb-test [c]\n  (let [ec (empty c)\n        ev (str ec)]\n    (cond \n      (= {} ec) :map\n      (= #{} ec) :set \n      (= \"[]\" ev) :vector\n      :else :list)))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 65, "code": "(fn guess [col]\n  (let [f1 (conj col [:test 1]),\n        f2 (conj col [:test 1] [:test 1])]\n    (if (= (count f1) (count f2))\n      ;; :set or :map\n      (let [f (conj col [:map :test])]\n        (if (contains? f :map)\n          :map\n          :set\n        )\n      )\n      ;; :list or :vector\n      (let [f (first (conj col :test :list))]\n        (if (= f :list)\n          :list\n          :vector\n        )\n      )\n    )\n  )\n)", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n     (= base {})  :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? coll) :vector :list))))", "user": "53da19fde4b0e771c3025484"}, {"problem": 65, "code": "(fn [coll]\n  (cond \n   (contains? (conj coll [:z :z]) :z) :map\n   (= (conj coll [:z :z] [:z :z]) (conj coll [:z :z])) :set\n   (= [2 2] (last (conj coll [1 1] [2 2]))) :vector\n   (= [2 2] (first (conj coll [1 1] [2 2]))) :list))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 65, "code": "#(if (. % equals (set %)) :set\n          (if (associative? %) (if (. % equals (vec %)) :vector :map)\n         :list))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 65, "code": "(fn\n  [col]\n  (let [junk {:key \"value\"}]\n    (cond\n     (let [add junk col (conj col add)]\n       (= (first col) (get col 0)))\n     :vector\n     (if (not (= \"value\" (:key (conj col junk))))\n       (let [col (conj col junk)]\n         (let [original-length (count col) new-length (count (conj col (first col)))]\n           (= original-length new-length)))\n       false)\n     :set\n     (= \"value\" (:key (conj col junk))) :map\n     (let [addition junk col (conj col addition)]\n       (let [addition junk col (conj col addition)]\n         (= addition (first col))))\n     :list)))", "user": "5389fe49e4b0640c7a9a58b4"}, {"problem": 65, "code": "#(if (= (empty %) {})\n   :map\n   (if (= (empty %) #{})\n     :set\n     (if (= (first (conj (conj % 99) 100)) 100)\n       :list\n   \t   :vector)\n     )\n   )", "user": "53e0001be4b0d874e779ae48"}, {"problem": 65, "code": "(fn [x]\n\t(cond\n\t\t(= :b (:a (conj x [:a :b]))) :map\n\t\t(= (conj x :a :a) (conj x :a)) :set\n\t\t(= (conj (conj x :a) :b) (concat x [:a :b])) :vector\n\t\t(= (conj (conj x :a) :b) (concat [:b :a] x)) :list))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 65, "code": "(fn get-type [s]\n  (condp = (first (str s))\n    \\{ :map\n    \\( :list\n    \\c :list\n    \\[ :vector\n    \\# :set))", "user": "53c126fce4b00fb29b22125b"}, {"problem": 65, "code": "#(let [n1 (count %)\n        c1 (conj % [:_item :_value1])\n        c2 (conj c1 [:_item :_value1])\n        c3 (conj c2 [:_item :_value2])\n        n2 (count c3)\n        diff (- n2 n1)]\n    (condp = diff\n      1 :map\n      2 :set\n      3 (cond\n          (= (first c3) [:_item :_value2]) :list\n          (= (last c3 ) [:_item :_value2]) :vector)\n      ))", "user": "52bc6cb2e4b07a9af57922f5"}, {"problem": 65, "code": "#(let [c (conj (conj (empty %) [0 1]) [0 2])] (condp = [(second (first c)) (get c 0)] [1 [0 1]] :vector [2 nil] :list [2 2] :map :set))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 65, "code": "(fn my-class [coll]\n  (let [x (str (empty coll))]\n    (case x\n      \"{}\" :map\n      \"clojure.lang.PersistentList$EmptyList@1\" :list\n      \"[]\" :vector\n      \"#{}\" :set\n      x)))", "user": "53e27bf1e4b036ad0777e3f2"}, {"problem": 65, "code": ";(fn [o]\n;  (let [a (conj o {:c 3, :d 4} {:e 5})\n;        b (conj o {:c 3, :d 4} {:e 5} {:e 5})]\n;    (if (= a b)  ; map or set\n;      (if (= (- (count a) (count o)) 3) :map :set)\n;      (if (= (first a) {:e 5}) :list :vector)\n;    )))\n\n(fn [o]\n  (let [oo (conj o o [0 1])]\n    (cond\n      (= (conj o [0 1]) oo) :map\n      (= (conj oo [0 1]) oo) :set\n      (= (first oo) [0 1]) :list\n      :else :vector\n    )))", "user": "53ecac57e4b0d648e757f4b3"}, {"problem": 65, "code": "(fn test-coll [coll]\n  (if (reversible? coll)\n    :vector\n    (if (associative? coll)\n      :map\n      (let [empty-coll (empty coll)\n            dbl-conj-coll (conj (conj empty-coll :x) :x)]\n      (if (= 2 (count dbl-conj-coll))\n        :list\n        :set)))))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 65, "code": "#(cond\n  (= {} (empty %)) :map\n  (= #{} (empty %)) :set\n  (reversible? %) :vector\n  :else :list)", "user": "53e241a6e4b036ad0777e3f0"}, {"problem": 65, "code": "(fn [c]\n  (if (empty? (flatten (conj c [0 0])))\n    (get (conj c [:set :map]) :set :set)\n    (if (= (first (conj (conj c nil) :x)) :x) :list :vector)))", "user": "53e4fa2ce4b036ad0777e454"}, {"problem": 65, "code": "(fn type-of [c] \n  (condp \n    = (empty c)\n    {} :map \n    #{} :set\n    \n    (let [[r1 r2] (repeatedly 2 rand)\n          c (conj c r1 r2)]\n      (if (= (last c) r2) :vector :list))))", "user": "523578efe4b0a643f2dcb74c"}, {"problem": 65, "code": "(fn bbt [s]\n  (letfn [(is-vector? [s] (= '(:b :a :a) (let [[e0 e1 e2] (reverse (conj s :a :a :b))] [e0 e1 e2])))\n          (is-list?   [s] (= '(:b :a :a) (let [[e0 e1 e2] (conj s :a :a :b)] [e0 e1 e2])))\n          (is-set?    [s] (= (count (conj s :a)) (count (conj s :a :a))))\n          (is-map?    [s] (= (count (conj s {:a 1})) (count (conj s {:a 1} {:a 2}))))]\n    (cond\n      (is-map? s)    :map\n      (is-set? s)    :set\n      (is-vector? s) :vector\n      (is-list? s)   :list\n      :else          :unknown)))", "user": "53710c09e4b0fc7073fd6ea5"}, {"problem": 65, "code": "(fn [c]\n  (if (reversible? c)\n    :vector\n    (if (associative? c)\n      :map\n      (let [d (conj c 1)]\n        (if (= d (conj d 1))\n          :set\n          :list)))))", "user": "51ab70c3e4b04e3dc0c27b33"}, {"problem": 65, "code": "(fn\n  [x]\n  (cond (= (count x) (count (conj x nil)))\n        :map\n        (= (count (conj x nil)) (count (conj x nil nil)))\n        :set\n        (nil? (first (conj x :banana nil)))\n        :list\n        :else\n        :vector))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": 65, "code": "(fn [col]\n  (let [e [[100 200] [300 400]]\n        xs (into col e)]\n    (if (= (count (conj xs (first xs))) (count xs))\n      (if (= (xs (first e)) (first e)) :set :map)\n      (if (= (first (conj xs (last xs))) (last xs))\n        :list\n        :vector))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (if (contains? (conj coll {:a 1}) :a)\n    :map\n    (let [x (if (or (empty? coll) (not= (first coll) 1)) 1 2)\n          conjed (conj (conj coll x) (inc x))\n          consed (cons (inc x) (cons x coll))\n          conjed-twice (conj conjed x)]\n      (cond (= (count conjed)\n               (count conjed-twice))\n              :set\n            (= conjed consed)\n              :list\n            :else\n              :vector))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 65, "code": "(fn p65 [coll]\n  (case (first (str coll))\n    (or \\( \\c) :list\n    \\[ :vector\n    \\# :set\n    \\{ :map))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 65, "code": "(fn my-type [coll]\n  (let [key [21 22]\n        val [22 23]\n        collec (into coll (vector key val))]\n    (cond\n     (contains? collec key) :set\n     (contains? collec 21)  :map\n     (contains? collec 1)   :vector\n     (not (contains? collec 0)) :list ;Not possible in clojure 1.6, Exception on (contains? '()).\n     :else\n     collec)\n))", "user": "5364ab34e4b0243289761e64"}, {"problem": 65, "code": "(fn m [arg]\n  (let [kv #(conj % [:k :v])]\n  (if (= (kv arg) (kv (kv arg)))\n    ;set or map\n    (if (= :v (:k (conj arg [:k :v])))\n      :map\n      :set)\n    ;vector or list\n    (if (= :test1 (first (conj (conj arg :test2) :test1)))\n      :list\n      :vector))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 65, "code": ";garbage \n(fn e-65 [coll]\n  (let [is-assoc (associative? coll)\n        enf-uni (= (count (conj (conj coll [:z, :z]) [:z, :z]))\n                   (count (conj coll [:z, :z])))]  \n    (cond\n      (and (not is-assoc) enf-uni)       :set\n      (and (not is-assoc) (not enf-uni)) :list\n      (and is-assoc enf-uni)             :map \n      (and is-assoc (not enf-uni))       :vector)))", "user": "53bd7080e4b0d9a98559a6d1"}, {"problem": 65, "code": "(fn __\n  [thing]\n  (cond\n    (= 2 (:a (merge thing {:a 2}))) :map\n    (= 999 (get (conj thing 999) 999)) :set\n    (= 999 (first (conj thing 998 999))) :list\n    (= 999 (last (conj thing 998 999))) :vector\n    )\n)", "user": "51ad808ee4b09397d5109784"}, {"problem": 65, "code": "(fn [coll]\n  (let [newcoll (into coll [[:q47xhd1 2] [:zix42d 1]])]\n    (if (= newcoll (seq newcoll))\n      (if (= (last newcoll) [:zix42d 1]) :vector :list)\n      (if (= newcoll (set newcoll)) :set :map)\n    )))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 65, "code": "(fn mm [q]\n  (if (= (count q) (count (conj q nil)))\n    :map\n    (let [q2 (conj q 1 1)\n          sub (- (count q2) (count q))]\n      (if (= 1 sub)\n        :set\n        (let [q3 (conj q :my :my2)]\n          (if (= (first q3) :my2)\n            :list\n            :vector))))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 65, "code": "#(let [a (conj (empty %) [3 7] [3 8] [3 7])]\n        (case (count a)\n          1 :map\n          2 :set\n          3 (if (get a 0) :vector :list)))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 65, "code": "(fn [s]\n   (if\n    (= (+ 2 (count s)) (count (into (into s {4 5}) {4 5})))\n    (if (= :w (first (into s [:q :w])))\n      :list\n      :vector)\n    (if (= (+ 2 (count s)) (count (into (into s {4 5}) {4 6})))\n      :set\n      :map)\n    ))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 65, "code": "#(let [x (rand-int 100) y (rand-int 100) p [x y] c (conj % p)] \n  (cond\n    (= y (get c x)) :map\n\t(= p (get c p)) :set\n\t(= x (first(conj c x))) :list\n    :else :vector\t\n  ))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 65, "code": "(fn [x]\n   (let [extra (conj x [:ooga :booga])\n         two-extra (conj extra [:dooga :rooga])\n         extra-pairs (into x [[:zxcvb :foobar] [:zxcvb :barfoo]])]\n     (cond\n      (= (count extra-pairs) (inc (count x))) :map\n      (= (count extra) (count (conj extra [:ooga :booga]))) :set\n      (= [:dooga :rooga] (last two-extra)) :vector\n      :else :list)))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 65, "code": "#(let [x (empty %)]\n   (cond\n    (= #{} x) :set\n    (= {} x) :map\n    (= [:a :b] (conj (conj x :a) :b)) :vector\n    (= [:b :a] (conj (conj x :a) :b)) :list))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 65, "code": "(fn [cand]\n    (let [g1 (gensym)\n          g2 (gensym)\n          new-cand (conj (conj cand [g1 g2]) [g1 g2])]\n      (if (= 1 (- (count new-cand) (count cand)))\n        (if (= [g1 g2] (get new-cand [g1 g2]))\n          :set\n          :map)\n        (if (= (first (conj new-cand [g2 g1])) [g2 g1])\n          :list\n          :vector))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 65, "code": "(fn [x]\n   (if (ifn? x)\n     (cond\n      (= x ((comp set seq) x)) :set\n      (= x (->> x\n                seq\n                (apply vector))) :vector\n      (= x (apply hash-map (interleave (keys x) (vals x)))) :map)\n     :list))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 65, "code": "#(let\n    [ x (gensym),\n     y (gensym),\n     ls (conj (conj %1 [y x]) [x y])]\n    (cond\n     (contains? ls x)  :map\n     (not= (seq ls) ls) :set\n     (= (first ls) [x y]) :list\n     (= (last ls) [x y]) :vector))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 65, "code": "(fn [x] (if (associative? x) (if (reversible? x) :vector :map) (if (let [y (into x '(1 1))] (= (count y) (count (distinct (apply list y))))):set :list )))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "53be3ee7e4b0d9a98559a6df"}, {"problem": 65, "code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n    (if (= 1 (count result))\n      :map (if (= 2 (count result))\n             :set (if (= [1 3] (first result))\n                    :list :vector )))))", "user": "5101192ae4b0bef64c30e266"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 65, "code": "(fn [xs]\n  (let [r (conj xs [:x :y])]\n    (cond\n      (= (:x r) :y) :map\n      (= (conj r [:x :y]) r) :set\n      (= (cons :x r) (conj r :x)) :list\n      :else :vector)))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 65, "code": "#(if (reversible? %) :vector \n   (if (associative? %) :map\n     (if (= (set %) %) :set :list)))", "user": "52faec2ee4b047fd55837004"}, {"problem": 65, "code": "(fn inspect\n  [coll]\n  (let [em (empty coll)\n        nem (into em {:a :b})]\n    (if (= :b (:a nem))\n      :map\n      (let [lem (conj em :a :b)]    \n        (if (= :a (:a lem))\n         :set\n          (if (= (first lem) :a)\n            :vector\n            :list))))))", "user": "540b2dcbe4b0addc1aec66f4"}, {"problem": 65, "code": "#(letfn [(c [L & a]\n            (count (reduce conj L a)))]\n      (cond\n      \t(= (c % [:f :b]) (c % [:f :b] [:f :b2])) :map\n        (= (c % :f) (c % :f :f)) :set\n        (= (first (conj % :a :b)) :b) :list\n        :else :vector))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 65, "code": "(fn \n  [coll]\n  (let [x :x y :y\n        p [x y]]\n    (cond\n          (= y (get (conj coll p) x)) :map\n          (= p (get (conj coll p) p)) :set\n          (= y (last (conj coll x y))) :vector\n          :else :list)))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 65, "code": "(fn [bb]\n  (let [x (gensym)\n        y (gensym)\n        l (count bb)\n        ]\n    (cond\n     (= x (get (conj bb {x x}) x)) :map\n     (= (inc l) (count (conj (conj bb x) x))) :set\n     (= y (first (conj (conj bb x) y))) :list\n     :else :vector\n     )\n    )\n  )", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 65, "code": "(fn [x]\n  (let [ c (count x)]\n    (if-not (nil? (get (conj x [:xxxddd 5]) :xxxddd)) :map\n            (if (= 1 (-  (count (conj x \"SSS\" \"SSS\")) c)) :set\n                (if (= \"XXX\" (last (conj x \"SSS\" \"XXX\"))) :vector :list)))))", "user": "4ec4d723535dcc7ae8597d65"}, {"problem": 65, "code": "#(let [x (str %)]\n    (cond \n     (= \"(\" (str(first x))) :list     \n     (= \"#\" (str(first x))) :set     \n     (= \"[\" (str(first x))) :vector     \n     (= \"{\" (str(first x))) :map     \n     :else :list))", "user": "538d70abe4b0b51d73faae6e"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (letfn [(is-set-or-map? [coll]\n            (= coll (conj coll (first coll))))\n          (set-or-map [coll]\n            (if (contains? coll (first coll))\n              :set\n              :map))\n          (list-or-vector [coll]\n            (if (= (conj coll 1)\n                   (concat [1] coll))\n              :list\n              :vector))]\n    (let [coll (conj coll [1 2])]\n      (if (is-set-or-map? coll)\n        (set-or-map coll)\n        (list-or-vector coll)))))", "user": "54084784e4b0addc1aec66c9"}, {"problem": 65, "code": "(fn fun [x] (cond\n          (= (empty x) {}) :map\n          (= (into #{} x) x) :set\n          (= (into (empty x) '(1 2 3)) '(3 2 1)) :list\n          (= (into (empty x) '(1 2 3)) '(1 2 3)) :vector))", "user": "540479e7e4b0addc1aec665a"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll (conj coll [1 2])]\n    (cond\n     (= coll (conj coll coll)) :map\n     (= coll (first (conj coll coll))) :list\n     (= coll (conj coll (first coll))) :set\n     :else :vector)))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 65, "code": "(fn [coll]\n  (let [a [:1 1]\n        b [:2 2]\n        t (conj (empty coll) a b)]\n    (if (empty? (flatten t))\n      (if (t a)\n        :set\n        :map)\n      (if (= b (first t))\n        :list\n        :vector))))", "user": "53dd37aee4b0d874e779ae28"}, {"problem": 65, "code": "(letfn [(f [obj]\n           (let [new-item1 [:newitem1 1]\n                 new-item2 [:newitem2 2]\n                 new-items [new-item1 new-item2]]\n             (cond\n              (= (get (conj obj new-item1) :newitem1) 1) :map\n              (= (get (conj obj new-item1) new-item1) new-item1) :set\n              (= (last (into obj new-items)) new-item2) :vector\n              (= (first (into obj new-items)) new-item2) :list)))]\n  f)", "user": "540470dae4b0addc1aec6658"}, {"problem": 65, "code": "(fn [coll]\n  (let [o (Object.)\n        c (count coll)]\n    (cond\n      (identical? (get (conj coll [:test o]) :test) o) :map\n      (identical? (get (conj coll o) o) o) :set\n      (identical? (get (conj coll o) c) o) :vector\n      (identical? (first (conj coll o)) o) :list)))", "user": "540e17c3e4b0addc1aec6719"}, {"problem": 65, "code": "(fn seq-type [coll]\n(let [base (empty coll)]\n(cond\n(= base {}) :map\n(= base #{}) :set\n(= base '()) (if (reversible? coll) :vector :list))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 65, "code": "(fn my-type [coll]\n   (let\n     [default-value [1 1]\n      coll-with-default-value (fn [coll] (conj (empty coll) default-value))\n\n      conj-at-head? (fn [coll] (= [2 2] (first (conj (coll-with-default-value coll) [2 2]))))\n      unique-values? (fn [coll] (= 1 (count (conj (coll-with-default-value coll) default-value))))\n      my-map? (fn [coll] (= (coll-with-default-value coll) (apply hash-map default-value)))]\n     (if (unique-values? coll)\n       (if (my-map? coll)\n         :map\n         :set)\n       (if (conj-at-head? coll)\n         :list\n         :vector))))", "user": "53f35c34e4b0742d9025b0f4"}, {"problem": 65, "code": "(fn [coll]\n  (let [typ ({{} :map #{} :set '() :list } (empty coll))]    \n    (if (= typ :list) \n      (if (ifn? coll) :vector typ) typ)))", "user": "54094824e4b0addc1aec66da"}, {"problem": 65, "code": "#(let [c (empty %)]\n   (case c\n     {} :map\n     #{} :set\n     [] (if (reversible? c) :vector :list)))", "user": "541b37d2e4b01498b1a71a64"}, {"problem": 65, "code": "(fn [c]\n   (cond (= (count c) (count (into c (list (first c))))) (if\n                                                             (= ((conj c {:key :val}) :key) :val) :map :set)\n         (empty? c) (cond\n                     (= (conj c {}) {}) :map\n                     (= (into c '(1 1)) #{1}) :set\n                     (= (conj (conj c 0) 1) [0 1]) :vector\n                     :else :list\n                     )\n         (= (first (conj c c)) c) :list\n         :else :vector))", "user": "52fac708e4b047fd55836fff"}, {"problem": 65, "code": "(fn [x] (cond\n            (= {} (empty x)) :map\n            (= #{} (empty x)) :set\n            (= :a (first (into (empty x) '(:a :b)))) :vector\n            :else :list))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 65, "code": "(fn [c]\n  (cond (= c (into [] c))\n        (if (= (conj (empty c) 1 2) [1 2])\n          :vector\n          :list)\n        ((conj c [c c]) [c c]) :set\n        true :map))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 65, "code": "#(cond\n  (= % (merge % %)) :map\n  (= (conj % nil) (clojure.set/union (conj % nil) (conj % nil))) :set\n  (= :again (first (conj % :test :again))) :list\n  :else :vector\n  )", "user": "541619e8e4b01498b1a719f9"}, {"problem": 65, "code": "(fn [x]\n  (cond (contains? (conj x [::x ::y]) ::x) :map \n        (= (conj x ::x ::y) (concat x [::x ::y])) :vector\n        (= (conj x ::x ::y) (concat [::y ::x] x)) :list\n        (= (count (conj x ::x ::x)) (inc (count x))) :set))", "user": "54157dace4b01498b1a719f4"}, {"problem": 65, "code": "(fn my-blackbox [c]\n        (let [sym :a]\n          (cond\n           (= (inc (count c)) (count (conj (conj c [0 1]) [0 2]))) :map\n           (= (inc (count c)) (count (conj (conj c 0) 0))) :set\n           (identical? sym (first (conj (conj c 0) sym))) :list\n           :else :vector)))", "user": "541ae7dbe4b01498b1a71a61"}, {"problem": 65, "code": "(fn [coll]\n  (let [n (empty coll)]\n    (cond (= n {}) :map\n          (= n #{}) :set\n          (= n '()) (if (reversible? coll) :vector :list))))", "user": "4eb3fcba535d7eef30807359"}, {"problem": 65, "code": "(fn [s]\n  (cond\n     (reversible? s) :vector\n     (associative? s) :map\n     :else\n     (if-let [x (first s)] ;; is there stuff?\n       (if (= (inc (count s)) (count (conj s x)))\n         :list\n         :set)\n       (if (= (inc (count s)) (count (into s '(1 1))))\n         :set\n         :list))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 65, "code": "(fn [c]\n  (cond\n     (reversible? c) :vector\n     (associative? c) :map\n    (= (inc (count c)) (count (conj (conj c \"a\") \"a\"))) :set\n   :else :list\n  )\n  )", "user": "531902b1e4b08068f379ed77"}, {"problem": 65, "code": "(fn poke [s]\n    (let [ss (conj (conj s [:lets :go]) [:to :beach])]\n      (if (= (last ss) [:to :beach])\n        :vector\n        (let [ssd (conj ss [:lets :go])]\n          (println \"ss\" ss \"ssd\" ssd)\n          (if (not= (count ss) (count ssd))\n            :list\n            (if (= :go (ssd :lets))\n              :map\n              :set))))))", "user": "5429986ce4b01498b1a71b3b"}, {"problem": 65, "code": "#(let [x (conj % [1 1] [1 2])] (cond\n     (> 2 (- (count x) (count %))) :map\n     (= '() (flatten x)) :set\n     (= [1 2] (last x)) :vector\n     1 :list\n     ))", "user": "542f574be4b0dad94371f2d0"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 65, "code": "(fn [col]\n  (let [kw      (keyword (gensym))\n        is-map? (= 1 (kw (conj col [kw 1])))\n        is-set? (if (false? is-map?) (= kw (kw (conj col kw))))\n        is-vec? (if (false? is-map?) (= kw (last (conj col 1 kw))))\n        is-list? (if (false? is-map?) (= kw (first (conj col 1 kw))))]\n    (-> (group-by second [[:map is-map?] [:set is-set?] [:vector is-vec?] [:list is-list?]])\n        (get true)\n        first\n        first)))", "user": "542c22bde4b0dad94371f29e"}, {"problem": 65, "code": "#(if (associative? %)\n   (if (reversible? %) :vector :map)\n   (if (ifn? %) :set :list))", "user": "50d882d4e4b01f0871336e69"}, {"problem": 65, "code": "(fn [x]\n  (let [is-map? (fn [v] (= (get (conj v [1000 1]) 1000) 1))\n        is-vec? (fn [v] (= (concat v [1 2]) (conj v 1 2)))\n        is-list? (fn [v] (= (concat [2 1] v) (conj v 1 2)))\n        is-set? (fn [v] (let [e (or (first (seq v)) 1)] (= (into #{} (concat (seq v) [e])) (conj v e))))]\n    (cond\n      (is-map? x) :map\n      (is-vec? x) :vector\n      (is-list? x) :list\n      (is-set? x) :set)))", "user": "51aab611e4b04e3dc0c27b2d"}, {"problem": 65, "code": "(fn [s]\n    (let [empty-s (empty s)]\n      (cond\n        (= empty-s {}) :map\n        (= empty-s #{}) :set\n        :else (if (reversible? empty-s) :vector :list))))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 65, "code": "(fn black-box-testing [xs] \n  (let [x (flatten (seq (conj xs [:x :x] [:x :x] [:x :y])))\n        nx (count x)\n        y (flatten (seq xs))\n        ny (count y)]\n    (cond \n      (= (- nx 2) ny) :map\n      (= (- nx 4) ny) :set\n      (not= (last x) :y) :list\n      (= (last x) :y) :vector)))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 65, "code": "#(case (empty %)\n   {} :map\n   #{} :set\n   (case (conj (empty %) 1 2)\n     [1 2] :vector\n     [2 1] :list))\n;#(or \n;  ({{} :map #{} :set} (empty %))\n;  ({[1 2] :vector [2 1] :list} (conj (empty %) 1 2)))", "user": "54397533e4b032a45b86931d"}, {"problem": 65, "code": "(fn tf [c] \n  (let [ec (empty c)]\n    (cond\n     (= 1 (count (into ec [[1 2] [1 3]]))) :map\n     (= 1 (count (into ec [1 1]))) :set\n     (= (into ec [1 2]) [1 2]) :vector\n     :else :list)))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 65, "code": "(fn black-box-test [arg]\n (cond (= arg {}) :map\n       (= arg #{}) :set\n       (= arg []) (if (= 2 (last (conj (conj arg 1) 2))) :vector :list)\n       (or (= [:a 1] (first arg)) (= [:b 2] (first arg))) :map\n       (= (count arg) (count (conj arg (first arg)))) :set\n       (= (last (conj arg 111)) 111) :vector\n       :else :list))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 65, "code": "(fn [s]\n         (let [t (-> (conj (empty s) [:a :b]) (conj [:a :b]))\n               c (count t)]\n           (cond\n             (= 2 c) (if (= :b (first (conj (empty s) :a :b))) :list :vector)\n             (= 1 c) (if (= :b (get t :a)) :map :set)\n             )))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 65, "code": "(fn [x] (let [e (empty x)] (cond (= e #{}) :set (= e {}) :map :else (let [c (conj e 1 2)] (if (= c [1 2]) :vector :list)))))", "user": "530a6cbae4b02e82168697be"}, {"problem": 65, "code": "#(let [s (str %)]\n   (cond\n    (re-find #\"\\#\" s) :set\n    (re-find #\"\\{\" s) :map\n    (re-find #\"\\[\" s) :vector\n    :else :list ))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 65, "code": "(fn [c]\n  (let [c (conj c [:a 1])]\n  (if (= (count (conj c (first c))) (count c))\n    ;; Map or set\n    (if (get c (first c))\n      :set\n      :map)\n    ;; List or vector\n    (if (= (first c) (first (conj c c)))\n      :vector\n      :list))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 65, "code": "(fn myType [coll] (if (= (get (conj coll {0 2}) 0) 2)\n                      :map \n                      (if (not= (+ (count coll) 2) (count (conj coll 1 1)))\n                          :set\n                          (if (empty? coll)\n                              (if (= (first (conj coll 1 2)) 2)\n                                  :list\n                                  :vector\n                              )\n                              (if (let [v (vector (first coll) (last coll))] (= v (first (conj coll v))) ) \n                                  :list\n                                  :vector\n                              )\n                          )\n                      )\n                  )\n )", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "543f854fe4b032a45b86935b"}, {"problem": 65, "code": "(fn tst-seq [s]\n       (cond\n        (= (count (conj s nil)) (count s)) :map\n        (<= (count (conj s :a :a :a :a)) (+ 1 (count s))) :set\n        (identical? tst-seq (first (conj (conj s :dummy) tst-seq))) :list\n\t:else :vector))", "user": "540e0637e4b0addc1aec6717"}, {"problem": 65, "code": "(fn __ [col] (let [x (empty col)] \n                 (cond \n                  (= x {}) :map\n                  (= x #{}) :set\n                  (= x '()) (if (reversible? x) :vector :list))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 65, "code": "(fn box [coll]\n  (cond\n   (= (set coll) coll) \n   :set\n   (= (vec coll) coll)\n   (let [new-coll (conj (conj coll :added-first) :added-second)]\n      (if (= :added-second (first new-coll))\n          :list\n          :vector))\n   :else \n   :map))", "user": "54448e84e4b032a45b869393"}, {"problem": 65, "code": "(fn [collection]\n                                 (let [empty-collection (empty collection)]\n                                   (if-not (nil? (:a (into empty-collection [[:a :1]])))\n                                     :map\n                                     (if (= :2 (first (conj (conj empty-collection :1) :2)))\n                                       :list\n                                       (if (= 2 (count (conj (conj empty-collection :1) :1)))\n                                         :vector\n                                         :set)))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 65, "code": "(fn [coll]\n  (let [v [[1 1] [1 1] [2 3]]\n        t (apply conj (empty coll) v)\n        r ((juxt first count) t)]\n    (case r\n      [[2 3] 3] :list\n      [[1 1] 3] :vector\n      [[2 3] 2] :map\n      :set)))", "user": "532a033be4b09d4e7a9b551f"}, {"problem": 65, "code": "#(if (reversible? %) :vector ({{} :map, #{} :set, '() :list} (empty %)))", "user": "541096bde4b01498b1a719b2"}, {"problem": 65, "code": "(fn [x]\n\t(cond \n     (reversible? x) :vector\n     (associative? x) :map\n     (= (set x) x) :set\n     :else :list))", "user": "5447e08ce4b032a45b8693c3"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    ;associative? is only true for vectors and maps.\n    ;reversible is true for vectors but false for lists, sets and maps\n    (and (associative? coll) (reversible? coll)) :vector\n    (associative? coll) :map\n    ;set will never have duplicate values.  list will\n    (= [1 1] (take 2 (reduce conj coll [1 1]))) :list\n    :else :set\n     ))", "user": "53f6bfd9e4b0db01ade6f9e4"}, {"problem": 65, "code": "(fn [t]\n   (let [e (empty t)]\n     (cond \n      (= {} e) :map\n      (= #{} e) :set\n      (and (= () e) (identical? () e)) :list\n      (= [] e) :vector)))", "user": "5370d152e4b0fc7073fd6e9d"}, {"problem": 65, "code": "(fn [coll]\n  (if (associative? coll)\n    ; map or vector\n    (let [c (assoc coll 0 1)]\n      (if (= 1 (first (seq c))) :vector :map))\n    ; list or set\n    (let [i (gensym)]\n      (if (= (conj coll i) (conj coll i i)) :set :list))))", "user": "5122925ae4b068a9582e656d"}, {"problem": 65, "code": "(fn [c]\n  (let [e (empty c)]\n    (cond (= e {}),  :map\n          (= e #{}), :set\n\t\t  (= (cons :1 (cons :2 c))\n             (conj (conj c :2) :1)) :list\n          :else :vector)))", "user": "51baff1be4b0fe3ecfb46443"}, {"problem": 65, "code": "(fn [coll]\n  (let [item [-1 5] my-conj\n        (conj coll [-1 5])]\n    (if (= item (get my-conj item))\n      :set\n      (if (= 5 (get my-conj -1))\n        :map\n        (if (= 99 (last (conj my-conj 99)))\n          :vector\n          :list)))))", "user": "544b9df2e4b0e39780006968"}, {"problem": 65, "code": "#(if (not= % (into [] %))\n  (if (= % (into #{} %))\n    :set\n    :map)\n  (if (= 200 (first (conj (conj % 100) 200)))\n    :list\n    :vector))", "user": "54349368e4b0b6b47310fcf1"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 65, "code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (= [2 1] (seq (conj (empty %) 1 2))) :list\n  :else :set)", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 65, "code": "(fn [s]\n  (let [a (first (str s))]\n    (cond\n      (= a \\[) :vector\n      (= a \\{) :map\n      (= a \\#) :set\n      :else :list\n)))", "user": "54524afbe4b0e397800069bc"}, {"problem": 65, "code": "(fn [x]\n  (let [xx (conj (empty x) [:a 1] [:a 2])]\n    (if (= (into #{} x) x)\n      :set\n      (if (= (count xx) 1)\n        :map\n        (if (= (first xx) [:a 2])\n          :list\n          :vector)))))", "user": "5446ebc2e4b032a45b8693b8"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5461368ce4b01be26fd7469b"}, {"problem": 65, "code": "(fn [x]\n  (let [e (empty x)]\n    (cond\n     (= e {})  :map\n     (= e #{}) :set\n     :else (case (conj e 1 2)\n             [1 2] :vector\n             [2 1] :list))))", "user": "505aa653e4b021387fb89857"}, {"problem": 65, "code": "(fn f [x]\n  (cond\n   (= (conj x [1 1] [2 2]) (concat [[2 2] [1 1]] x)) :list\n   (= (conj x [1 1] [2 2]) (concat x [[1 1] [2 2]])) :vector\n   (= x #{}) :set\n   (= (count (flatten (seq (conj x [:x :x] [:y :y])))) (* 2 (+ 2 (count x)))) :map\n   (= (count (conj x [:x :x] [:x :x])) (inc (count x))) :set\n   :else nil)\n )", "user": "54021f13e4b0df28a13c62cc"}, {"problem": 65, "code": "(fn what [input]\n    (let [empty-coll (empty input)\n          coll (into empty-coll [[1 2] [1 2]])]\n        (if (= 1 (count coll))\n            (if (get coll 1)\n                :map\n                :set)\n            (if (= 1 (first (into empty-coll [1 2])))\n                :vector\n                :list))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 65, "code": "(fn [c](let [bc (empty c)]\n              (cond\n                (= bc {}) :map\n                (= bc #{}) :set\n                (reversible? bc) :vector\n                :else :list)\n             ))", "user": "546280d8e4b01be26fd746b0"}, {"problem": 65, "code": "#(let [x (gensym) y (gensym) z (gensym)]\n        (cond \n          (= (inc (count %)) (count (conj % {x y} {x z}))) :map\n          (= (inc (count %)) (count (conj (conj % x) x))) :set\n          (= (conj (conj % x) y) (cons y (cons x %) )) :list          \n          (= (conj (conj % x) y) (conj % x y)) :vector\n        ))", "user": "544e9022e4b0e3978000698b"}, {"problem": 65, "code": "(fn [obj]\n    (let [conjed (conj obj [:a 1] [:a 1] [:b 2])]\n      (cond\n        (= 1 (:a conjed)) :map\n        (= (+ 2 (count obj)) (count conjed)) :set\n        (= [:b 2] (first conjed)) :list\n        (= [:b 2] (last conjed)) :vector)))", "user": "537bde5de4b06839e8705e73"}, {"problem": 65, "code": "(fn [coll]\n   (let [v \"some-val\"]\n     (cond \n      (= (conj coll {}) coll) :map\n      (= (inc (count coll))\n         (count (apply conj coll (repeat 5 v)))) :set\n         (= v (first (conj coll \"other val\" v))) :list\n         :else :vector)))\n\n;;(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "544cf5d7e4b0e39780006977"}, {"problem": 65, "code": "(fn r [s]\n  (let [v {\\{ :map\n           \\# :set\n           \\[ :vector\n           \\( :list}\n        [f &o] (print-str s)]\n        (v f)))", "user": "51aefceee4b09397d5109797"}, {"problem": 65, "code": "(comp #(cond \n          (= % {}) :map \n          (= % #{}) :set \n          (= (conj % 1 2) [1 2]) :vector \n          true :list\n      ) \n      empty)", "user": "5412646de4b01498b1a719d4"}, {"problem": 65, "code": "(fn [s] (condp (fn [^Class c x] (. c (isInstance x))) s\n  clojure.lang.IPersistentMap :map\n  clojure.lang.IPersistentVector :vector\n  clojure.lang.IPersistentList :list\n  clojure.lang.IPersistentSet :set\n  clojure.lang.LazySeq :list\n))", "user": "5464a536e4b01be26fd746cf"}, {"problem": 65, "code": "(fn [s]\n  (let [e (empty s)]\n    (cond\n     (= {} e) :map\n     (= #{} e) :set\n     (= (first (conj e 1 2)) 1) :vector\n     :else :list)))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 65, "code": "(fn [coll]\n   (let [em (empty coll)]\n     (cond (= em {}) :map\n           (= em #{}) :set\n           (= em ()) (if (reversible? coll) :vector :list))))", "user": "5473efc3e4b0c51c1f4d7285"}, {"problem": 65, "code": "(fn test_type [c]\r\n  (case (empty c)\r\n    {} :map\r\n    #{} :set\r\n    (if (= (first (conj (conj c 23) 42)) 42) :list :vector)))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 65, "code": "(fn [coll]\n  (case (empty coll)\n    [] (if (associative? coll) :vector :list)\n    {} :map\n    #{} :set))\n\n;(fn [coll]\n;  (let [marker [::k ::v]\n;        coll (conj coll [::k2 ::v2] marker)]\n;    (cond\n;      (= ::v (get coll ::k))\n;      :map\n;      (= marker (get coll marker))\n;      :set\n;      (= marker (last coll))\n;      :vector\n;      (= marker (first coll))\n;      :list)))", "user": "53a074a4e4b0ca733b9744af"}, {"problem": 65, "code": "(fn f [s]\n  (let [n (conj s [:kw :kw])]\n    (if (contains? n :kw)\n      :map\n      (if (contains? n [:kw :kw])\n        :set\n        (let [nn (conj n :kw)]\n          (if (= :kw (first nn))\n            :list\n            :vector))))))", "user": "5478e57de4b0c51c1f4d72c1"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "541f5b37e4b01498b1a71a97"}, {"problem": 65, "code": "(fn [ds] (let [ds (empty ds)]\n           (cond (= ds {}) :map\n                 (= ds #{}) :set\n                 (= ds '()) (if (reversible? ds) :vector :list))))", "user": "547ec511e4b0c51c1f4d730e"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "547adcb0e4b0c51c1f4d72cf"}, {"problem": 65, "code": "(fn [c] (condp = (conj (conj (empty c) [1 1]) [2 2]) #{[1 1][2 2]} :set {1 1 2 2} :map [[1 1][2 2]] :vector '([2 2][1 1]) :list))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 65, "code": "(fn [input]\n  (cond\n    (= (set input) input)\n    :set\n    \n   \t(not= (apply list input) input)\n\t:map\n   \n    (let [test-coll (conj input 1)\n          test-x (if (= (last test-coll) 1) 2 1)]\n      (= (last (conj test-coll test-x)) test-x))\n    :vector\n   \n    :else\n    :list))", "user": "546c4c5fe4b00cfc9eacc178"}, {"problem": 65, "code": "(fn [item]\n  (cond\n    (= (conj item [:test 0] [:test 1])\n       (conj item [:test 1]))\n      :map\n    (= (conj item [:test 0])\n       (conj item [:test 0] [:test 0]))\n      :set\n    (= (last (conj item :test :test2))\n       :test2)\n      :vector\n    :else\n      :list))", "user": "521e8227e4b0dd19981ad082"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll (reduce conj (empty coll) [[:a 0] [:a 1] [:a 1]])]\n    (cond\n     (= (count coll) 1) :map\n     (= (count coll) 2) :set\n     (= (first coll) [:a 1]) :list\n     (= (first coll) [:a 0]) :vector)))", "user": "546ed28be4b00cfc9eacc1a5"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= :myval (get (conj coll [:mykey :myval]) :mykey)) :map\n   (= :myval (get (conj coll :myval) :myval)) :set\n   (= :myval (first (conj coll :abc :myval))) :list\n   :else :vector))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 65, "code": "(fn [o] \n  (let [a {:a 1}\n        b {:b 2}\n        o' (conj o a)]\n  (cond \n   (= 1 (get o' :a)) :map\n   (= o' (conj o' a)) :set\n   (= b (first (conj o' b))) :list\n   :else :vector\n  )))", "user": "51421cd5e4b0b50abeb46b2c"}, {"problem": 65, "code": "(fn type-inspector [coll]\n  (cond (= (count coll) (dec (count (conj coll [:x :y] [:x :d])))) :map          \n        (= (count coll) (dec (count (conj coll :x :x)))) :set\n        (= (first (conj coll :x :y)) :y) :list\n        :else :vector))", "user": "4e41a04e535dc968683fc49e"}, {"problem": 65, "code": "#(let [xs (conj % [:www :zzz] [:xxx :yyy])]\n  (cond\n   (= :yyy (get xs :xxx)) :map\n   (= [:xxx :yyy] (get xs [:xxx :yyy])) :set\n   (= [:xxx :yyy] (first xs)) :list\n   :else :vector\n ))", "user": "5360f043e4b0243289761e3c"}, {"problem": 65, "code": "(fn [y] (letfn [(is-list [x] (= 1 (first (conj (conj (empty x) 2) 1))))\n                (is-vector [x] (and (not (is-list x))\n                                    (= (empty x) [])))\n                (is-set [x] (= (empty x) #{}))\n                (is-hmap [x] (= (empty x) {}))]\n          (cond (is-hmap y) :map\n                (is-set y) :set\n                (is-list y) :list\n                (is-vector y) :vector)))", "user": "54857e3be4b0e286459a11ad"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "user": "5486adf7e4b0e286459a11be"}, {"problem": 65, "code": "(fn [c]\n  (let [k (keyword (gensym))\n        v (keyword (gensym))]\n    (cond\n      (= v (-> c (conj [k v]) k)) :map\n      (= (inc (count c)) (-> c (conj v) (conj v) count)) :set\n      (= v (-> c (conj k) (conj v) first)) :list\n      :default :vector)))", "user": "4e6a2f93535d8ccf87e9feaa"}, {"problem": 65, "code": "#(case (empty %)\n   {} :map\n   #{} :set\n   [] (if (= (conj (empty %) 1 2)\n             [1 2])\n        :vector\n        :list))", "user": "5466aabbe4b01be26fd746e8"}, {"problem": 65, "code": "(fn [s]\n  (let [s (empty s)]\n    (cond (= :y (:x (conj s [:x :y]))) :map\n          (= 1 (count (conj s :x :x))) :set\n          (= :y (first (conj s :x :y))) :list\n          (= :x (first (conj s :x :y))) :vector\n          :else :none\n          )))", "user": "526143b7e4b03e8d9a4a705a"}, {"problem": 65, "code": "(fn poke [coll]\n  (let [x [:f 7], xs (conj coll x), l (count xs)]\n    (if (= l (count (conj xs x)))\n      ; map or set\n      (if (= l (count (conj xs [:f 8])))\n        :map\n        :set\n        )\n      (if (= (seq (conj xs 8)) (conj (seq xs) 8))\n        :list\n        :vector\n        )\n      )\n    )\n  )", "user": "5488872ee4b0e286459a11d3"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= (get (conj coll [:t \"t\"]) :t) \"t\")   :map\n   (= (get (conj coll :t) :t) :t)          :set\n   (= (first (conj (conj coll :a) :b)) :b) :list\n   (= (last (conj (conj coll :a) :b)) :b)  :vector))", "user": "542c026ae4b0dad94371f29a"}, {"problem": 65, "code": "#(cond \n     (not (nil? (get (conj % [:a 1]) :a nil))) :map\n     (not= (+ 2 (count %)) (count (conj % 1 1))) :set\n     (nil? (get (conj % 1) 0 nil)) :list\n     :else :vector)", "user": "5470b3d0e4b00cfc9eacc1bb"}, {"problem": 65, "code": "#((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty %)))", "user": "54926752e4b0b312c081ff44"}, {"problem": 65, "code": "(fn [s]\n (let [b (empty s)]\n  (cond\n  \t(= b {})  :map\n    (= b #{}) :set\n    (= b '()) (if (reversible? s) :vector :list))))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 65, "code": "(fn[coll]\n  (let [c (empty coll)]\n    (if (= (count (conj c (last c))) 0)\n      :map\n      (let [c2 (conj (conj c 42) 43)]\n        (if (= (first c2) 43)\n          :list\n          (if (= (set c) c)\n            :set\n            :vector\n          )\n        )  \n      )\n    )\n  )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5125d963e4b05d10e3e395fe"}, {"problem": 65, "code": "(fn [coll]\n  (let [template (conj (empty coll) [:a 1] [:a 2])]\n  \t(case template\n  \t  {:a 2}           :map\n      #{[:a 1] [:a 2]} :set\n      [[:a 1] [:a 2]]  :vector\n      '([:a 2] [:a 1]) :list)))", "user": "548c6673e4b0e286459a1209"}, {"problem": 65, "code": "(fn [coll]\n  (let [a (atom 0)\n        b (atom 0)]\n    (letfn [(is-a-set?  [coll] (= (count coll) (dec (count (conj coll a a)))))\n            (is-a-list? [coll] (identical? b (first (conj coll a b))))\n            (is-a-vec?  [coll] (identical? b (last (conj coll a b))))\n            (is-a-map?  [coll] (identical? b (get (into coll {a b}) a)))]\n      (cond (is-a-map? coll) :map\n            (is-a-set? coll) :set\n            (is-a-vec? coll) :vector\n            (is-a-list? coll) :list))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 65, "code": "(fn [coll]\n   (let [t (conj (empty coll) [1 2] [1 2])]\n     (if (empty? (rest t)) \n       (if (empty? (rest (conj t t))) :map :set)\n       (if (= [3 4] (first (conj t [3 4]))) :list :vector)\n       )\n     )\n   )", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 65, "code": "(fn black-box-testing [coll]\n  (cond \n   (:a (conj coll [:a 1])) :map\n   (= (cons 1 (cons 2 coll)) (conj coll 2 1)) :list\n   (> 2 (- (count (conj coll 1 1))\n              (count coll))) :set\n   :else :vector))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 65, "code": "(fn [c] \n\t(cond\n\t\t(= (:c (conj c {:c 2})) 2) :map\n\t\t(= (inc (count c)) (count (conj c :c :c))) :set\n\t\t(= (last (conj c :c :d)) :d) :vector\n\t\t(= (first (conj c :c :d)) :d) :list))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 65, "code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 65, "code": "(fn f [x]\n  (let [y (conj x [:bbb :ccc])]\n    (cond\n      (= (get   (conj y [:aa 11]) :aa) 11) :map\n      (= (count (conj (conj y :aaa) :aaa)) (count (conj y :aaa))) :set\n      (= (last  (conj y :aaa)) :aaa)       :vector\n      (= (first (conj y :aaa)) :aaa)       :list)))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 65, "code": "#(cond\n  (= % (conj % {})) :map\n  (= (conj % 10) (conj % 10 10)) :set\n  (= (conj % 10 20) (concat % [10 20])) :vector\n  :else :list)", "user": "512b07f7e4b078b06821febb"}, {"problem": 65, "code": "(fn black-box [coll]\n  (let [NEcoll (conj (empty coll) [0 1])]\n    (cond (= 1 (count (conj NEcoll [0 2]))) :map\n          (= 1 (count (conj NEcoll [0 1]))) :set\n          (= 3 (first (conj NEcoll 3))) :list\n          :else :vector)))", "user": "53703287e4b0fc7073fd6e8f"}, {"problem": 65, "code": "#(let [e1 (apply str \"e1\" %)\n       e2 (apply str \"e2\" %)]\n  (if (= (count (conj % [e1 e2] [e1 e2]))\n         (count (conj % [e1 e2])))\n    (if (= ((conj % [e1 e2]) e1) nil)\n      :set\n      :map)\n    (if (= (first (conj % e1 e2)) e2)\n     :list\n     :vector)))", "user": "549e5e52e4b0f3d1d8e70f9e"}, {"problem": 65, "code": "#(cond\n  (false? (ifn? %)) :list\n  (reversible? %) :vector\n  (associative? %) :map\n  :else :set\n)", "user": "549c22f7e4b0f3d1d8e70f86"}, {"problem": 65, "code": "(fn [v]\n  (cond\n   (:a (conj v [:a 1])) :map\n   (= (conj v 1 1) (conj v 1)) :set\n   (= (first (conj v 1 2)) 2) :list\n   :else :vector))", "user": "549c8bbde4b0f3d1d8e70f8c"}, {"problem": 65, "code": "#(let [k :a e [k 1] c (conj (conj % [:b 2]) [k 1])] (cond (k c) :map (get c e) :set (= (last c) e) :vector (= (first c) e) :list))", "user": "549c3e0ce4b0f3d1d8e70f87"}, {"problem": 65, "code": "(fn [s]\n (let [C [:a :b]\n       x (into (empty s) [C])\n       added (lazy-seq (conj x :c))]\n  (cond (= (:a x) :b) :map\n        (= (conj x C) x) :set\n        (= (last added) :c) :vector\n        (= (first added) :c) :list\n  )\n )\n)", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 65, "code": "(fn [coll]\n  (cond \n   (= (empty coll) {}) :map\n   (= (empty coll) #{}) :set\n   (identical? (empty coll) ()) :list\n   :else :vector))", "user": "54848141e4b0e286459a119e"}, {"problem": 65, "code": "(fn f [arg] \n  (cond\n    (reversible? arg)\n    :vector\n\n    (associative? arg)\n    :map\n\n    (= (conj arg :unique :unique) (conj arg :unique))\n    :set\n    \n    :else :list))", "user": "50be9b4ae4b00fb48fed2ef6"}, {"problem": 65, "code": "(fn [v]  \n  (cond  \n          (:a (conj v [:a 1])) :map  \n          (< (- (count (conj v 1 1)) (count v)) 2) :set  \n          (= (conj v 1 2) (cons 2 (cons 1 v))) :list  \n          :else :vector))", "user": "549a176ce4b0f3d1d8e70f69"}, {"problem": 65, "code": "(fn [s]\n  (let [z [::s ::s]]\n    (cond\n      (get (conj s z) ::s) :map\n      (= (conj s z) (conj (conj s z) z)) :set\n      (= z (first (conj (conj s nil) z))) :list\n      :else :vector)))", "user": "50ef4e2be4b0a78662fa2653"}, {"problem": 65, "code": "(fn [c] (let [b (empty c)] \n          (if (= b {}) :map \n            (if (= b #{}) :set \n              (if (= b []) (if (reversible? b) :vector :list) )))))", "user": "53f78944e4b0de5c41848561"}, {"problem": 65, "code": "(fn [xs]\n  (cond\n   (= 1 (get (conj xs [:t 1]) :t)) :map\n   (= (get (conj xs :t) :t) :t) :set\n   (= :t (first (conj (conj xs :v) :t))) :list\n   (= :t (last (conj (conj xs :v) :t))) :vector\n  )\n)", "user": "5409a12fe4b0addc1aec66df"}, {"problem": 65, "code": "#(condp = (empty %)\n   {} :map\n   #{} :set\n   (condp = (conj (empty %) 1 2)\n     [1 2] :vector\n     :list))", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 65, "code": "(fn t [v]\n  (let [c (conj (empty v)  {:c 3} {:d 4})]\n    (cond\n      (= {:d 4, :c 3} c) :map\n      (= [{:c 3} {:d 4}] c) :vector\n      (= '({:d 4} {:c 3}) c) :list\n      (=  #{{:c 3} {:d 4}} c) :set)))", "user": "4f82ed48e4b033992c121c0e"}, {"problem": 65, "code": "(fn [thing]\n    (if (:z (conj thing {:z 1})) :map\n      (let [something (conj thing :y :z)]\n        (cond\n         (= something (conj something :z)) :set\n         (= :z (first something)) :list\n         (= :z (last something)) :vector))))", "user": "54addba9e4b09f271ff37ce9"}, {"problem": 65, "code": "(fn [c]\n\t(let [col (empty c)]\n\t\t(if (ifn? col)\n\t\t\t(if (empty? (flatten (conj col [1 2])))\n\t\t\t\t(if (= nil ((conj col [1 2]) 1))\n\t\t\t\t\t:set\n\t\t\t\t\t:map)\n\t\t\t\t:vector)\n\t\t\t:list)))", "user": "5367bc60e4b0243289761e81"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 65, "code": "(fn [o]\n  (letfn [(c34 [s] (conj s [3 4]))\n          (c35 [s] (conj s [3 5]))\n          (c56 [s] (conj s [5 6]))]\n    (cond\n      (= (count (c35 (c34 o))) (count (c34 o))) :map\n      (= (count (c34 (c34 o))) (count (c34 o))) :set\n      (= [5 6] (first (c56 (c34 o)))) :list\n      (= [5 6] (last (c56 (c34 o)))) :vector\n    )\n  )\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 65, "code": "(fn [v]\n (let [t (empty v)]\n  (cond\n    (= t #{}) :set\n  \t(= t {})  :map\n    (= t '()) (if (reversible? v) :vector :list))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 65, "code": "(fn [seq]\n  (let [seq (empty seq)]\n   (cond\n     (= seq {}) :map\n     (= seq #{}) :set\n     (true? (reversible? seq)) :vector\n     :else :list)))", "user": "5484143de4b0e286459a1197"}, {"problem": 65, "code": "(fn [sq]\n  (let [result (conj (empty sq) [1 2] [1 2] [1 3])]\n    (if (= 1 (count result))\n      :map (if (= 2 (count result))\n             :set (if (= [1 3] (first result))\n                    :list :vector )))))", "user": "54b6c24be4b0ed20f4ff6e7c"}, {"problem": 65, "code": "(fn [x]\n  (let [x' (conj x [:k :v1] [:k :v2] [:k :v2])\n        [n n'] (map count [x x'])]\n    (cond (= (inc n) n') :map\n          (= (+ 2 n) n') :set\n          (= [:k :v2] (first x')) :list\n          (= [:k :v2] (last x')) :vector)))", "user": "52be58d7e4b07a9af579231d"}, {"problem": 65, "code": "(fn [coll]\n   (let [empt (empty coll)]\n     (cond\n       (= empt #{}) :set\n       (= empt {})  :map\n       (= empt ()) (if (reversible? empt) :vector :list)\n       :else :no-idea)))", "user": "54ad9d76e4b09f271ff37ce6"}, {"problem": 65, "code": "#(let [x (conj % [-1 -2])]\n  (if (zero? (count (flatten x)))\n    (if (= -2 (x -1))\n      :map\n      :set)\n    (if (= -2 (last (conj (conj % -1) -2)))\n      :vector\n      :list)))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 65, "code": "(fn [xs]\n  (let [xs (empty xs)]\n    (cond\n      (and (associative? xs)\n           (= 2 ((conj xs [3 4] [1 2]) 1))) :map\n      (= (conj xs 1 1) #{1}) :set\n      (= (conj xs 1 2) [2 1]) :list \n      (= (conj xs 1 2) [1 2]) :vector\n      :else :unknown)))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 65, "code": "#(condp = %1\n   (set %) :set\n   (vec %) (if (and (= (conj % (first %)) (cons (first %) %))\n                    (not= (conj % :clojure :lisp) (cons :clojure (cons :lisp %))))\n               :list\n               :vector)\n   (apply hash-map (flatten (seq %))) :map)", "user": "536b9d8ae4b0243289761ebe"}, {"problem": 65, "code": "(fn get-type [col]\n  (let [base (empty col)]\n    (cond\n      (= {} base) :map\n      (= #{} base) :set\n      (= base '()) (if (reversible? col) :vector :list))\n  ))", "user": "53bdae7fe4b0d9a98559a6d9"}, {"problem": 65, "code": "(fn f [s] (cond\n    (= s (into [] s)) (if (= (first (conj s :a :b)) :b) :list :vector)\n    (= s (into #{} s)) :set\n    (= s (into {} s)) :map))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 65, "code": "(fn [e] (let [s (gensym)\nne (conj (conj e {s 1}) {s 2})]\n(if (= (inc (count e)) (count ne)) :map\n(cond \n(= (count ne) (count (conj ne {s 1}))) :set\n(= (first ne) {s 2}) :list\n(= (last ne) {s 2}) :vector))))", "user": "525b142fe4b0cb4875a45d05"}, {"problem": 65, "code": "(fn [sq]\n  (if-not (associative? sq)\n   \t(if (< (- (count (conj (conj sq :a) :a))\n          (count sq))\n       \t2) \n      :set\n      :list)\n    (if (=  0  (- (count (conj (conj sq [1 2]) [1 2]))\n      (count (conj sq [1 2]))))\n      :map\n      :vector\n      )))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 65, "code": "(fn [val]\n    (case (str (empty val))\n      \"clojure.lang.PersistentList$EmptyList@1\" :list\n      \"[]\" :vector\n      \"{}\" :map\n      \"#{}\" :set))", "user": "4f42c80ae4b0d7d3c9f3fd0f"}, {"problem": 65, "code": "#(case (-> % str first)\n   \\[ :vector\n   \\{ :map\n   \\# :set\n   \\c :list)", "user": "53e3f7a8e4b036ad0777e408"}, {"problem": 65, "code": "#(if (= % (vec %))\n     (if\n       (let [q (conj % \"foo\" \"bar\")]\n         (= \"bar\" (first q))\n         )   \n       :list \n       :vector\n       )   \n     (if (= % (set (vec %)))\n       :set\n       :map\n       )   \n     )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 65, "code": "(fn [c]\n  (let [w '[a c]\n        n (conj c '[a b] w w)\n        d (- (count n) (count c))]\n    (cond\n     (= d 2) :set\n     (= d 1) :map\n     (= (first n) w) :list\n     (= (last n) w) :vector\n     )))", "user": "54c19050e4b0ed20f4ff6f26"}, {"problem": 65, "code": "(fn black-box [coll]\n  (cond\n    (= \"a\" (get (conj coll [:a \"a\"]) :a)) :map\n    (= :a (get (conj coll :a) :a)) :set\n    (= :b (first (conj (conj coll :a) :b))) :list\n    (= :b (last (conj (conj coll :a) :b))) :vector))", "user": "54ae541ae4b09f271ff37cef"}, {"problem": 65, "code": "#(let [c (conj % %)]\n   (if (= (count c) (count %))\n     :map\n     (if (= % (set %))\n       :set\n       (if (= % (first c))\n         (if (identical? % [])\n           :vector\n           :list)\n         :vector))))", "user": "54b2ec84e4b09f271ff37d33"}, {"problem": 65, "code": "(fn poke [coll]\n  (let [\n        mod-coll (conj coll [:first-key :first-val] [:first-key :second-val] [:first-key :second-val])\n        count-change (- (count mod-coll) (count coll))\n        mod-first (first mod-coll)]\n    (case count-change\n      1 :map\n      2 :set\n      3 (if (= mod-first [:first-key :second-val]) :list :vector))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 65, "code": "(fn [s]\n  (let [b (empty s)]\n    (cond\n      (= b {})  :map\n      (= b #{}) :set\n      (= (conj b 1 2) '(2 1)) :list\n      :else :vector)))", "user": "54b95f3de4b0ed20f4ff6eab"}, {"problem": 65, "code": "(fn [c]\n  (let [a1 {:a 1} a2 {:a 2} x (reduce conj (empty c) [a1 a2 a2])]\n    (cond\n     (= (count x)  1) :map\n     (= (count x)  2) :set\n     (= (first x) a1) :vector\n     (= (first x) a2) :list\n     :else nil)))", "user": "542f0a3be4b0dad94371f2cd"}, {"problem": 65, "code": "(fn [x]\n  (let [e (empty x)]\n    (case e\n      {} :map\n      #{} :set\n      [] (if (= [1 2] (conj e 1 2))\n           :vector\n           :list))))", "user": "545bd22fe4b01be26fd7465a"}, {"problem": 65, "code": "(fn __ [x]\n  (cond (reversible? x) :vector\n        (associative? x) :map\n        (= (conj x 1 1) (conj x 1)) :set\n        :else :list))", "user": "54c271b9e4b045293a27f602"}, {"problem": 65, "code": "#(if (= (+ 1 (count %)) (count (conj (conj % {:new-key :new-val}) {:new-key :new-val})))\n\t(if (= :new-val (get (conj % {:new-key :new-val}) :new-key))\n        :map\n        :set)\n\t(if (= :new-val-2 (first (conj (conj % :new-val-1) :new-val-2)))\n        :list\n        :vector))", "user": "53b952eee4b047364c0444e6"}, {"problem": 65, "code": "(fn [sq]\n  (let [l-sq (count sq)\n        l-test-sq (count (conj sq [1 1] [1 1]))\n        is-hash (> 2 (- l-test-sq l-sq))]\n    (if is-hash\n      (cond (associative? sq) :map\n            true :set)\n      (cond (associative? sq) :vector\n            true :list))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 65, "code": "#(cond\n    (= % (into [] %)) ; vector or list\n      (if (= (first (conj (conj % :_x) :_y)) :_y)\n         :list\n         :vector\n        )\n    (contains? (conj % [:_x :_y]) :_x)\n       :map\n    true\n       :set\n   )", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 65, "code": "(comp {\\{ :map \\# :set \\[ :vector \\c :list} first str)\n;\n;(fn [coll]\n;  (let [c1 (conj coll {:spacer :spacer} {:sentinel :sentinel})\n;        c2 (into (empty coll) (cons {:sentinel :sentinel} c1))]\n;      (if (= (count c1) (count c2))\n;        (if (c1 :sentinel)\n;          :map\n;          :set)\n;        (if (= (first c2) (last c2))\n;          :vector\n;          :list))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 65, "code": "(fn find-type [coll]\n  (let [c (count coll), g (gensym), g2 (gensym)]\n    (cond\n     (= c (count (conj coll {})))    :map\n     (= (count (conj coll g))\n        (count (conj coll g g)))     :set\n     (= (first (conj coll g g2)) g2) :list\n     (= (last (conj coll g g2)) g2)  :vector)))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 65, "code": "(fn [o]\n  (let\n    [oo (reduce conj (empty o) [[1 2] [3 4] [1 1]])]\n    (condp = oo\n      {3 4, 1 1} :map\n      #{[1 1] [3 4] [1 2]} :set\n      [[1 2] [3 4] [1 1]] :vector\n      '([1 1] [3 4] [1 2]) :list\n      :unknown\n      )))", "user": "54c9f165e4b045293a27f687"}, {"problem": 65, "code": "(fn t [col]\n  (let [n (into col [[:p :q] [:p :q] [:p :u]])]\n    (cond \n     (= (inc (count col)) (count n) )  :map\n     (= (inc (inc (count col))) (count n) )  :set\n     (= (first n) [:p :u]) :list\n     :else :vector\n     )))", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? base) :vector :list))))", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 65, "code": "(fn [col]\n  (let [x (-> col\n              (conj [:akey :avalue])\n              (get :akey))]\n    (if (= x :avalue)\n      :map\n      (let [init-count (count col)\n            added-two-count (-> col\n                                (conj 1)\n                                (conj 1)\n                                count)]\n        (if (not= 2 (- added-two-count init-count))\n          :set\n          (-> col\n              (conj 1)\n              (conj 2)\n              (#(if (= 2 (last %))\n                  :vector\n                  :list))))))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 65, "code": "(fn [v]\n (let [e (empty v)]\n  (cond\n   (= [] e)\n    (if (= v (first\n              (conj v (conj v 1) v)))\n     :list\n     :vector)\n   (= #{} e) :set\n   (= {} e) :map)))", "user": "54580586e4b01be26fd74616"}, {"problem": 65, "code": "#(get { \"[]\" :vector \"{}\" :map \"clojure.lang.PersistentList$EmptyList@1\" :list \"#{}\" :set } (str (empty %)))", "user": "54cbe00ee4b057c6fda3a285"}, {"problem": 65, "code": "(fn [coll]\n  (let [sz (count coll)\n        mod-coll (conj coll {:a 2} {:b 3} {:b 3})\n        sz-mod (count mod-coll)]\n    (cond\n      (= (get mod-coll :b) 3) :map\n      (= sz (- sz-mod 2)) :set\n      (= (first mod-coll) {:b 3}) :list\n      :else :vector)))", "user": "53c06438e4b0c98a41f5ccb0"}, {"problem": 65, "code": "(fn black-box [coll]\n ( cond\n  (and (associative? coll) (reversible? coll)) :vector\n  (and (associative? coll) (not (reversible? coll))) :map\n  (and (not (associative? coll)) (= (count (conj coll 100))\n                                    (count (conj coll 100 100)))) :set\n  :else :list))", "user": "50aa777fe4b056ee01935866"}, {"problem": 65, "code": "(fn [q]\n  (let [eq (empty q)\n        one-item (conj eq [:x 1])\n        two-items (conj one-item [:y 2])]\n    (if-let [x (:x one-item)]\n      :map\n      (if-let [y (get one-item [:x 1])] :set\n        (if (= [:x 1] (first two-items)) :vector :list)))))", "user": "54d89deae4b0a52adc2e203a"}, {"problem": 65, "code": "(fn test [t]\n   (if (= (count (conj\n                  (conj t [32 10])\n                  [32 10]))\n          (+ (count t) 2))\n     (if (= (first (conj\n                 (conj t [32 10])\n                 \"foo\"))\n            \"foo\")\n       :list\n       :vector)\n     (if (= ((conj (conj t [32 10]) [32 10]) 32)\n            nil)\n       :set\n       :map)))", "user": "54d26316e4b0e8a36923e5f2"}, {"problem": 65, "code": "(fn recognize [s]\n  (cond\n    (= (conj s s) s)                                :map\n    (= (conj s :a) (conj s :a :a) )                 :set\n    (= (first (conj s :a :foomonkey)) :foomonkey)      :list\n    (= (last  (conj s :a :foomonkey)) :foomonkey)      :vector\n    ))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 65, "code": "(fn [coll]\n    (cond\n      ;; Associative is true for vectors and maps, false for list and set\n      ;; reversible? is true for vectors but false for maps\n      (associative? coll) (if (reversible? coll) :vector :map)\n      (= 2 (count (conj (conj (empty coll) :x ) :x))) :list\n      :else :set\n      )\n    )", "user": "515ebde3e4b01e5d11ccd0a8"}, {"problem": 65, "code": "(fn my-type [arg]\n    (let [k (gensym)\n          v (gensym)\n          test-elt [k v]\n          modif (conj arg test-elt test-elt)\n          modif-seq (seq modif)]\n      (if (= (count (filter #(= test-elt %) modif-seq)) 1)\n        (if (= (modif k) v) :map :set)\n        (let [m-elt (gensym)\n              nd-modif (conj modif m-elt)]\n          (cond\n           (= (first nd-modif) m-elt) :list\n           (= (last nd-modif) m-elt) :vector)))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 65, "code": "(fn [c]\n  (if (reversible? c)\n    :vector\n    (if (associative? c)\n      :map \n      (if (= (set c) c)\n        :set\n        :list))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 65, "code": "(fn p [s]\n  (cond\n    (= (first (.toString s)) \\[) :vector\n    (= (first (.toString s)) \\() :list\n    (= (first (.toString s)) \\c) :list\n    (= (first (.toString s)) \\#) :set\n    (= (first (.toString s)) \\{) :map\n    ))", "user": "53664e3be4b0243289761e74"}, {"problem": 65, "code": "(fn\n  [s]\n  (cond\n    (= :v (:k (conj s {:k :v})))\n    :map\n    (= :v (:v (conj s :v)))\n    :set\n    (= :a (last (conj (conj s :b) :a)))\n    :vector\n    :else :list))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 65, "code": "#(\n  {\\( :list \\{ :map \\[ :vector \\# :set}\n  (->> %\n      pr-str ; HA\n      first))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 65, "code": "(fn [c]\n  (let [t (conj c [:a :b])\n        seq-t (flatten t)]\n    (if (empty? seq-t)\n          (if (t :a)\n            :map\n            :set)\n    \t(let [q (conj t :a)]\n      \t\t(if (= (first q) :a)\n        \t\t:list\n        \t\t:vector)))))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 65, "code": "(fn bbtest [s]\n  (cond\n    ; (conj map map) -> map\n    ; keyword applied to map acts as function\n    (= (:c (conj s {:c 3})) 3) :map\n    ; order of set elements is irrelevant\n    (= (conj (conj s 3) 4) (conj (conj s 4) 3)) :set\n    ; conj adds to end of vectors\n    (= (conj (conj s 3) 4) (concat s '(3 4))) :vector\n    ; conj adds to start of lists\n    (= (conj (conj s 3) 4) (concat '(4 3) s)) :list\n    :else :unknown))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 65, "code": "(fn [xs]\n  (let [e1 {:x-black-box \"unique element\"}\n        e2 {:x-black-box \"another unique\"}\n        ys (conj xs e1)\n        zs (conj ys e2)]\n    (cond\n      (= zs (conj xs e2)) :map\n      (= zs (conj zs e2)) :set\n      (= (list e2 e1) (take 2 zs)) :list\n      :else :vector)))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 65, "code": "#(cond\n  (= (count (conj % [:a 1] [:a 1])) (count (conj % [:a 1]))) (if (= 1 (:a (conj % [:a 1]))) :map :set)\n  (= (first (conj % :aa :bb)) :bb) :list\n  :else :vector\n  )", "user": "54dae16de4b024c67c0cf758"}, {"problem": 65, "code": "(fn which-seq [coll]\n  (let \n    [empty-coll (empty coll)]\n    (cond\n      (= empty-coll #{})          :set\n      (= empty-coll {})           :map\n      (reversible? empty-coll)    :vector\n      :else                       :list))\n)", "user": "546692aee4b01be26fd746e7"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 65, "code": "(fn [c]\n  (cond \n    (associative? c) (if (= (into (empty c) {0 1}) {0 1})\n                       :map\n                       :vector)\n    (> (count (conj c :a :a)) (count (conj c :a))) :list\n    :else :set))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 65, "code": "(fn [coll]\n  (cond (= (:__new-key (conj coll [:__new-key :__new-value])) :__new-value)\n        :map\n   \n        (= (:__new-item (conj coll :__new-item)) :__new-item)\n        :set\n   \n        (= (first (conj coll :__new-item-1 :__new-item-2)) :__new-item-2)\n        :list\n        \n        (= (last (conj coll :__new-item-1 :__new-item-2)) :__new-item-2)\n        :vector\n  \n        :else nil))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= 99 (:x (conj coll [:x 99]))) :map\n   (= :x (:x (conj coll :x))) :set\n   (= [13 37] (first (-> coll (conj coll [11 11]) (conj coll [13 37])))) :list\n   (= [13 37] (last (-> coll (conj coll [11 11]) (conj coll [13 37])))) :vector\n   :else :unknown))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 65, "code": "(fn [c]\n  (cond (= (inc (count c)) (count (conj c [:uniq-key :a] [:uniq-key :b]))) :map\n        (= (inc (count c)) (count (conj c :uniq-val :uniq-val))) :set\n        (= (last (conj c :uniq-frist :uniq-second)) :uniq-second) :vector\n        :else :list\n        ))", "user": "54c641f8e4b045293a27f628"}, {"problem": 65, "code": "(fn identify [col]\n  (let [we6 :weeeeee\n        nonempty (conj col [0 we6])\n        keysort (partial sort-by keyword)\n        sorted (sort-by keyword nonempty)\n        conjed (conj nonempty [1 we6])]\n    (if (= (get nonempty 0) we6)\n      :map\n        (if (= sorted (keysort (conj nonempty (first sorted))))\n          :set\n          (if (= (first conjed) [1 we6])\n            :list\n            (if (= (last conjed) [1 we6])\n              :vector))))))", "user": "54be792ee4b0ed20f4ff6eeb"}, {"problem": 65, "code": "(fn [s]\n       (let [t [\"a\" \"b\"]\n             z [\"c\" \"d\"]\n             x (conj (conj (conj s t) t) z)]\n         (if (= (+ 2 (count s)) (count x))\n           (if (contains? x t)\n             :set\n             :map)\n           (if (= z (last x))\n             :vector\n             :list))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 65, "code": "#(let [c (-> % (conj [:? 1] [:? 1]))]\n   (cond\n     (-> c (get :?) (= 1)) :map\n     (-> c count (= (+ 1 (count %)))) :set\n     (-> c (get 0)) :vector\n     :else :list))", "user": "54ddb556e4b024c67c0cf798"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "54e5bdf2e4b024c67c0cf7fe"}, {"problem": 65, "code": "(fn [something]\n    (cond\n      (= :bar (get (conj something [0 :bar] [1 :foo]) 0)) :map\n      (= (count (conj something :a)) (count (conj something :a :a))) :set\n      (= [:foo :bar] (last (conj something :a [:foo :bar]))) :vector\n      :else :list\n      ))", "user": "54ca130ce4b057c6fda3a250"}, {"problem": 65, "code": "(fn [xs]\n  (let [ys (empty xs)]\n    (cond\n      (= ys {})  :map\n      (= ys #{}) :set\n      (= ys '()) (if (reversible? xs) :vector :list))))", "user": "54ecc3e9e4b024c67c0cf857"}, {"problem": 65, "code": "#({\\{ :map \\# :set \\[ :vector} (first (str %)) :list)", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 65, "code": "#(cond (reversible? %) :vector\n       (associative? %) :map\n       (= (first (conj % :a :b :c)) :c) :list\n       :else :set)", "user": "4e68c465535d8ccf87e9fe8a"}, {"problem": 65, "code": "(fn [n] \n  (cond\n   (re-matches #\"#\\{.*\\}\" (str n)):set\n   (re-matches #\"\\{.*\\}\" (str n)):map\n   (re-matches #\"\\[.*\\]\" (str n)):vector\n   :else :list\n   ))", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 65, "code": "#({\\{ :map, \\# :set, \\[ :vector, \\( :list} (nth (str %) 0) :list)", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 65, "code": "(fn [s] (cond (not= (count (conj s [1 2] [1 2])) (+ 2 (count s)))\n              (get (conj s [[1 2] :map]) [1 2] :set)\n              (= (conj s 1 2) (conj (seq s) 1 2)) :list\n              :else :vector))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 65, "code": "(fn [a] \n  (let [base (empty a)]\n    (cond\n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? a) :vector :list)\n     )\n    ))", "user": "537b1083e4b06839e8705e64"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-flatten (empty? (flatten (conj coll [1 2])))]\n    (if (associative? coll)\n      (if empty-flatten :map :vector)\n      (if empty-flatten :set :list))))", "user": "5227f3ffe4b0186687e23a60"}, {"problem": 65, "code": "(fn get-type\n  [coll]\n  (let [; maps are a function mapping their keys to values\n        is-map?    (fn [c] (= 8 (get (conj c [9 8]) 9)))\n        ; lists conj onto the front\n        is-list?   (fn [c] (= 2 (first (-> c  (conj 1)  (conj 2)))))\n        ; vectors conj onto the back\n        is-vector? (fn [c] (= 1 (first (-> c  (conj 1)  (conj 2)))))\n        ; sets only have one of each item\n        is-set?    (fn [c] (= 1 (count (filter #(= 1 %) (conj c 1 1)))))]\n    (cond\n      (is-map?    coll) :map\n      (is-list?   coll) :list\n      (is-set?    coll) :set\n      (is-vector? coll) :vector)))", "user": "5465febde4b01be26fd746e1"}, {"problem": 65, "code": "(fn [seq]\n  ({\\[ :vector\n    \\# :set\n    \\{ :map\n    \\( :list\n    \\c :list } (nth (.toString seq) 0)))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 65, "code": "#(case (first (pr-str %))\n   \\( :list\n   \\[ :vector\n   \\{ :map\n   \\# :set\n   :list)", "user": "4db6d993535d1e037afb2180"}, {"problem": 65, "code": "(fn  [x]\n  (let  [y [0 :foo]\n         z [-1 :bar]\n         nx  (conj (conj x y) z)\n         v (get nx 0)]\n    (cond\n      (= :foo v) :map\n      (= (conj nx y) nx) :set\n      (nil? v) :list\n      (= (first nx) v) :vector)))", "user": "546a6c7ce4b00cfc9eacc154"}, {"problem": 65, "code": ";; shamelessly stolen from Trevor Little\n    (fn get-type\n      [coll]\n      (let [; maps are a function mapping their keys to values\n            is-map?    (fn [c] (= 8 (get (conj c [9 8]) 9)))\n            ; lists conj onto the front\n            is-list?   (fn [c] (= 2 (first (-> c (conj 1) (conj 2)))))\n            ; vectors conj onto the back\n            is-vector? (fn [c] (= 1 (first (-> c (conj 1) (conj 2)))))\n            ; sets only have one of each item\n            is-set?    (fn [c] (= 1 (count (filter #(= 1 %) (conj c 1 1)))))]\n        (cond\n          (is-map?    coll) :map\n          (is-list?   coll) :list\n          (is-set?    coll) :set\n          (is-vector? coll) :vector)))", "user": "54485727e4b032a45b8693c6"}, {"problem": 65, "code": "(fn inspect  [s]\n  (let  [result  (conj s  [:c 3])\n         c  (get result :c)\n         c3  (get result  [:c 3])\n         l  (last (conj (conj s [:c 3]) [:d 4]))]\n    (cond  (= c 3) :map\n          (= c3  [:c 3]) :set\n          (= l [:d 4]) :vector\n          :else :list)))", "user": "4dbf7a31535d020aff1edf75"}, {"problem": 65, "code": "(fn blackbox [x]\n  (let [y (reduce conj [x [:sentinel 2] [:sentinel 2] [:foo :bar]])]\n    (if (= (-> x count inc inc) (count y))\n      ;Added same element twice, size only increased by 1\n      ;this must be a set or map\n      (if (= 2 (y :sentinel)) :map :set)\n      ;Otherwise must be a vec or list\n      (if (= [:foo :bar] (first y)) :list :vector)\n      )\n    ))", "user": "54b050cee4b09f271ff37d13"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (reversible? base) :vector\n     (= base ()) :list)))", "user": "54d74cffe4b0a52adc2e2028"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 65, "code": "(fn [s]\n  (let [new-s (conj (empty s) [:a 1] [:a 1] [:b 2])]\n     (if (= (count new-s) 2)\n        (if (get new-s :a)\n           :map\n           :set)\n        (if (= (first new-s) [:b 2])\n           :list\n           :vector))))", "user": "52f53589e4b05e3f0be25f2c"}, {"problem": 65, "code": "(fn [coll]\n  (let [is-map? (fn [c] (get (conj c [:a 1]) :a))\n        is-set? (fn [c] (= (conj c 1) (conj (conj c 1) 1)))\n        is-lst? (fn [c] (= (conj (conj c (or (first c) 1)) 2)\n                           (cons 2 (cons (or (first c) 1) c))))]\n    (cond\n      (is-map? coll) :map\n      (is-set? coll) :set\n      (is-lst? coll) :list\n      :else :vector)))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 65, "code": "(fn whatType\n  [x]\n  (let [x (if (empty? x) (conj x [:a 1] [:b 2]) x)]\n    (if (= (count x) (count (conj x (first x))))\n      (if (contains? x (first x))\n        :set\n        :map)\n      (if (= (first x) (last (conj x (first x))))\n        :vector\n        :list))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 65, "code": "(fn [c]\n  (let [c (empty c)]\n    (cond\n     (= c {}) :map\n     (= c #{}) :set\n     (= c '()) (if (reversible? c) :vector :list))))", "user": "54fdbe3fe4b07d26eda61d3b"}, {"problem": 65, "code": "(fn [x] \n  (let [kw :wiggawoooga-fnordwimple\n        s (conj x [kw 1] [kw 1] [kw 2])]\n    (cond \n     (= 2 (kw s)) :map\n     (= 2 (- (count s) (count x))) :set\n     (= [kw 2] (last s)) :vector\n     (= [kw 2] (first s)) :list)))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "54f2a1b8e4b024c67c0cf8cb"}, {"problem": 65, "code": "(fn [s]\n  (cond\n    (and \n     (associative? s)\n     (counted? s)\n     (not (reversible? s))\n     (not (sorted? s))) :map\n    (and \n     (reversible? s)\n     (counted? s)\n     (associative? s)\n     (not (sorted? s))) :vector\n    (and \n     (not (reversible? s))\n     (not (associative? s))\n     (not (sorted? s))\n     (= (conj s 1) (conj (conj s 1) 1))) :set\n    (and \n     (not (associative? s))\n     (not (reversible? s))\n     (not (sorted? s))\n     (not= s (conj s 1) (conj (conj s 1) 1))) :list\n   ))", "user": "54b31445e4b09f271ff37d35"}, {"problem": 65, "code": "(fn f [c]\n  (cond\n   (get (conj c [::x 3]) ::x) :map\n   (= (conj c 3) (conj c 3 3)) :set\n   (= 4 (last (butlast (conj c 4 5)))) :vector\n   (= 4 (second (conj c 4 5))) :list\n  ))", "user": "4ec1923f535dfed6da9c6db2"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll2 (into coll [[\"k\" \"v\"] [\"k\" \"v\"] [\"k\" \"v2\"]])\n        diff (- (count coll2) (count coll))]\n    (case diff\n      1 :map\n      2 :set\n      (if (= [\"k\" \"v2\"] (first coll2)) :list :vector))))", "user": "5368fedee4b0243289761e93"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "54bcab07e4b0ed20f4ff6ed5"}, {"problem": 65, "code": "(fn detector [coll]\n   (if (= (empty coll) {})\n     :map\n     (if (= (empty coll) #{} )\n       :set\n       (if (= (get (conj coll 1) 0) 1)\n         :vector\n         :list))))", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 65, "code": "(fn seq-detection [s]\n\t\t(let [thing (empty s), test (conj thing [:foo 42])]\n\t\t\t\t (cond\n\t\t\t\t   (= test {:foo 42}) :map\n\t\t\t\t\t (= [[:foo 42] :bar] (conj test :bar)) :vector\n\t\t\t\t\t (= [:bar [:foo 42]] (conj test :bar)) :list\n\t\t\t\t\t (= test #{[:foo 42]}) :set\n\t\t\t\t\t )\n\t\t\t\t )\n\t\t\t)", "user": "54ff6084e4b07d26eda61d50"}, {"problem": 65, "code": "(fn[x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "54fc7d89e4b07d26eda61d2b"}, {"problem": 65, "code": "(fn cat [in]\n    (let [empt (empty in)]\n    (case empt\n        {} :map\n        #{} :set\n        [] (if (associative? in) :vector :list))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 65, "code": "(fn [coll]\n  (let [is? (fn [st coll res] \n              (when (= (pr-str st) (pr-str (empty coll))) res))]\n    (or (is? {}  coll :map)\n        (is? #{} coll :set) \n        (is? []  coll :vector) \n        (is? ()  coll :list))))", "user": "550615c0e4b021ccfedb9696"}, {"problem": 65, "code": "(fn r [s] (cond\n           (= (conj s [1 2] [1 3]) (conj s [1 4] [1 3])) :map\n           (= (conj s 1) (conj s 1 1)) :set\n           (= (conj s 1 2) (concat s [1 2])) :vector\n           :else :list\n          ))", "user": "550aeddae4b06e50f9beb135"}, {"problem": 65, "code": "(fn [x] (let [m (zipmap [{} #{}] [:map :set] )] \n           (if (= :none (m (empty x) :none)) (if (= (first (conj (empty x) 1 2)) 2) :list :vector) (m (empty x)))\n         ))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 65, "code": "(fn typ [c]\n  (let [is-map (conj c [:tada :map])]\n    (if (= (:tada is-map) :map)\n      :map\n      (let [c (conj c (range 2 8))]\n        (cond\n          (= (count c) (count (conj c (last c)))) :set\n          (= :test (last (conj c :test))) :vector\n          (= :test (first (conj c :test))) :list)))))", "user": "55170dd9e4b06a49daca83bd"}, {"problem": 65, "code": "(fn [x]\n    (let [xs (conj x x x)]\n      (if (= (count xs) (count x))\n        :map\n        (let [a (gensym)\n              xs2 (conj x 0 0 a)]\n          (if (<= (- (count xs2) (count x)) 2)\n            :set\n            (if (= (first xs2) a)\n              :list\n              :vector))))))", "user": "551a21ece4b091ff45eda993"}, {"problem": 65, "code": "(fn [coll]\n(let [base (empty coll)]\n(cond\n(= base {}) :map\n(= base #{}) :set\n(= base '()) (if (reversible? coll) :vector :list))))", "user": "54cd53dae4b057c6fda3a29f"}, {"problem": 65, "code": "(fn my-type [s]\n  (cond (= (inc (count s)) (count (conj s {:test 1} {:test 2}))) :map\n        (= (inc (count s)) (count (conj s {:test 1} {:test 1}))) :set\n        (= :test (last (conj s :dummy :test))) :vector\n    :else :list))", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 65, "code": "#(cond\n    (= (get (conj % [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj % :t) :t) :t) :set\n    (= (first (conj (conj % :a) :b)) :b) :list\n    (= (last (conj (conj % :a) :b)) :b) :vector)", "user": "532018efe4b08068f379edcd"}, {"problem": 65, "code": "(fn \t[coll] (let [x :__tmpx__ y :__tmpy__](if (= (get (conj coll {x y}) x) y) :map (if (apply distinct? (conj coll x x)) :set (if (= y (first (conj coll x y))) :list :vector) ) )))", "user": "5519c157e4b00ace28fe6e32"}, {"problem": 65, "code": "#(if (= (set %) %) :set\n      (if (reversible? %) :vector\n          (if (associative? %) :map :list)))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 65, "code": "#(let [t (into (empty %) [[:a 0] [:b 0]])]\n   (cond\n    (:a t) :map\n    (get t 0) :vector\n    (get t [:a 0]) :set\n    true :list))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 65, "code": "(fn [s]\n  (letfn [(eq-s? [s t] (= (empty s) t))]\n  (cond\n    (eq-s? s {}) :map\n    (eq-s? s #{}) :set\n    (= (last (conj (conj s 0) -1)) -1) :vector\n    :else :list)))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 65, "code": "#(case (empty %)\n   #{} :set\n   {} :map\n   [] (if (reversible? (empty %))\n        :vector\n        :list))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 65, "code": "#(condp = (conj (empty %) [0 0] [1 1])\n   (list [1 1] [0 0]) :list\n   [[0 0] [1 1]] :vector\n   {0 0 1 1} :map\n   #{[0 0] [1 1]} :set\n   :other)", "user": "55253217e4b0882d96d091ce"}, {"problem": 65, "code": "(fn [coll]\n  (let [unique [:unique 9000]\n        new (conj coll unique)\n        uniquer [:uniquer 9001]\n        newer (conj new uniquer)]\n    (cond\n      (= (get new :unique) 9000) :map\n      (= (get new unique) unique) :set\n      (= (first newer) uniquer) :list\n      (= (last newer) uniquer) :vector\n     )))", "user": "5512aca6e4b055c2f668d4b4"}, {"problem": 65, "code": "#(condp = (empty %)\n  {} :map\n  #{} :set\n  (if (ifn? %) :vector :list))", "user": "51a058dae4b0b292b01ee3f3"}, {"problem": 65, "code": "#(case (.empty %)\n   {} :map\n   #{} :set\n   (if (= (conj (.empty %) 1 2) [1 2])\n     :vector\n     :list))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": 65, "code": "(fn [c]\n    (let [cc (conj c [:c 1])]\n    (println cc)\n    (cond (= 1 (:c cc))                                                :map\n          (= 8888 (first (seq (conj (conj cc 999) 8888))))             :list\n          (= 8888 (last  (conj (into cc (range 999 1100)) 8888)))      :vector\n          :else                                                        :set)))", "user": "544e8369e4b0e39780006987"}, {"problem": 65, "code": "(fn seq-test [s]\n    (case (empty s)\n      #{} :set\n      {} :map\n      (if (= (range 3) (pop (into (empty s) (range 4))))\n        :vector\n        :list)))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 65, "code": "(fn [x]\n   (let [before (count x)\n         after (-> x (conj [:zzz :a]) (conj [:zzz :c]) (conj [:zzz :c])count)]\n     (condp = (- after before)\n       1 :map\n       2 :set\n       (if (= (first (-> x (conj [:a :b]) (conj [:b :c])))\n              [:b :c])\n         :list\n         :vector))))", "user": "51bb08a4e4b0fe3ecfb46446"}, {"problem": 65, "code": "(fn [x]\n          (if (= (set x) x) \n            :set\n            (if (associative? x)\n              (if (reversible? x) :vector :map)\n              :list\n              )\n            )\n          )", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 65, "code": "(fn bbtest [x]\n  (let [tst (conj x  (first x))\n        hsh\t(get tst (first x))] \n   (cond\n    (or (= x  {}) (and (= x tst) (nil? \t   hsh) ))\t:map\n    (or (= x #{}) (and (= x tst) (not= nil hsh) ))\t:set\n    (or (identical? x ())  (and (not= x tst) (= (last x) (last (conj x :guard-value)))))  :list\n    :else :vector\n)))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 65, "code": "(fn [s]\n  (let [a (empty s)]\n    (cond\n     (= a {}) :map\n     (= a #{}) :set\n     (= (first (conj a :a :b)) :b) :list\n     :else :vector )))", "user": "5522cd9ae4b0882d96d091ab"}, {"problem": 65, "code": "(fn [coll]\n    (let [cc (conj coll [1 :ti] [0 :tt])]\n      (cond\n        (= [0 :tt] (get cc [0 :tt] nil)) :set\n        (= :tt (get cc 0 nil) ) :map\n        (= [0 :tt] (first cc)) :list\n        (= [0 :tt] (last cc)) :vector\n        )\n      )\n    )", "user": "552d9013e4b076ab5578f7ea"}, {"problem": 65, "code": "#(let [base (empty %)]\n   (cond\n       (= base {}) :map\n       (= base #{}) :set\n       :else (if (reversible? base) :vector :list)))", "user": "5481be5fe4b0e286459a1172"}, {"problem": 65, "code": "(fn [x]\n  (let [c (first (str x))]\n    (if (= c \\{)\n      :map\n    (if (=  c \\c)\n      :list\n     (if (= c \\[)\n      :vector\n      (if (= c \\#)\n      :set))))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 65, "code": "(fn reco [coll]\n  (let [ncoll (conj coll [0 1])]\n    (cond\n     (= (cons [1 2] ncoll) (conj ncoll [1 2])) :list\n     (= (ncoll 0) (first ncoll)) :vector\n     (= (ncoll (first ncoll)) (first ncoll)) :set\n     (= (ncoll (ffirst ncoll)) (second (first ncoll))) :map)))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 65, "code": "(fn [x]\n    (let [common-key (gensym)\n          inner-conjed [common-key (gensym)]\n          outer-conjed [common-key (gensym)]\n          new-x (conj (conj (conj x inner-conjed) outer-conjed) outer-conjed)]\n      (case (- (count new-x) (count x))\n            1 :map\n            2 :set\n            3 (if (= outer-conjed (first new-x))\n                :list\n                :vector))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 65, "code": "(fn [x]\n  (let [c (first (.toString x))]\n    (case c\n      \\{ :map\n      \\[ :vector\n      \\# :set\n      :list)))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 65, "code": "(fn [coll]\n  (let [isMap    (= (inc (count coll))\n                    (count (conj coll [:dummy 5] [:dummy 4])))\n        isVector (associative? coll)\n        isSet    (= (inc (count coll))\n                    (count (conj coll [:dummy 5] [:dummy 5])))]\n    (cond\n     isMap    :map\n     isVector :vector\n     isSet    :set\n     :else    :list)))", "user": "553dd883e4b0a04f792994e6"}, {"problem": 65, "code": "(fn [x]\n      (second\n        (first\n          (filter\n            #(. (first %) (isInstance x))\n            {\n             clojure.lang.LazySeq :list\n             clojure.lang.IPersistentList :list\n             clojure.lang.IPersistentMap :map\n             clojure.lang.PersistentVector :vector\n             clojure.lang.IPersistentSet :set\n             }))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "55395241e4b09218d5f44fe8"}, {"problem": 65, "code": "#(let [e (empty %)]\n    (condp = e\n      {} :map\n      [] (if (reversible? e) :vector :list)\n      #{} :set))", "user": "550f1c99e4b06e50f9beb171"}, {"problem": 65, "code": "(fn [xs]\n  (if (-> xs\n          (conj [:a :b])\n          (get :a)\n          (= :b))\n    :map\n    (if (= (conj xs :a)\n           (conj xs :a :a))\n      :set\n      (let [x (gensym)\n            y (gensym)]\n        (if (= (first (conj xs x y)) y)\n          :list\n          :vector)))))", "user": "512e31e9e4b0b740abc59823"}, {"problem": 65, "code": "(fn foo [collection]\n           (let [collection (empty collection)\n                 is-vector? (fn [col] (get (conj col [1 3]) 0))\n                 is-map? (fn [col] (get (conj col [1 3]) 1))\n                 is-set? (fn [col]\n                           (when (not (is-map? col))\n                             (let [start-size (count col)\n                                   new-size (count (conj (conj col [1 3]) [1 3]))]\n                               (= 1 (- new-size start-size)))))]\n             (cond\n               (is-vector? collection) :vector\n               (is-map?    collection) :map\n               (is-set?    collection) :set\n               :else                   :list)))", "user": "530b8580e4b02e82168697cc"}, {"problem": 65, "code": "(fn [coll]\n  (let [s (into coll [[0 0] [1 '_']])]\n    (if (get s [1 '_'])\n      :set\n      (if (= (get s 1) '_')\n        :map\n        (if (= (first s) [1 '_'])\n          :list\n          :vector)))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 65, "code": "(fn [coll]\n  (let [s (str coll)] \n    (cond  \n      (re-find #\"\\(\" s) :list\n      (re-find #\"\\[\" s) :vector\n      (re-find #\"#\\{\" s) :set\n      (re-find #\"\\{\" s) :map\n      :else :list)))", "user": "51bd255ce4b0df1216cefd94"}, {"problem": 65, "code": "(fn [col]\n  (let [c  (conj (empty col) [:a 1] [:a 2] [:a 2])]\n    (cond\n      (= 1 (count c)) :map\n      (= 2 (count c)) :set\n      (= (first c) [:a 1]) :vector\n      :else :list)))", "user": "5540cc0ce4b0a04f79299505"}, {"problem": 65, "code": "#(let [e (empty %1)]\n      (cond\n        (= e {})  :map\n        (= e #{}) :set\n        (= e '()) (if (reversible? %1) :vector :list)))", "user": "554c296ae4b0a04f792995a1"}, {"problem": 65, "code": "(fn [c]\n  (let [sc (str (conj [] (empty c))) lookup {\"[{}]\" :map \"[()]\" :list \"[#{}]\" :set \"[[]]\" :vector}]\n    (lookup sc)))", "user": "5546704be4b0a04f7929953d"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 65, "code": "#(cond \n  (identical? [] %) :vector\n  (identical? '() %) :list\n  (identical? {} %) :map\n  (identical? #{} %) :set\n\n  (:a %) :map\n       (contains? % 10 ) :set\n       (identical? '()(empty %)) :list\n       true :vector\n\n       )", "user": "554b9c3ee4b0a04f79299594"}, {"problem": 65, "code": "(fn seq-type [coll]\n(let [base (empty coll)]\n(cond\n(= base {}) :map\n(= base #{}) :set\n(= base '()) (if (reversible? coll) :vector :list))))", "user": "554b7056e4b0a04f79299583"}, {"problem": 65, "code": "(fn [collection]\n  (let [cc (fn [& args] (apply conj collection args))]\n    (cond\n      (= (get (cc [:a 1]) :a) 1) :map\n      (= (count (cc :x)) (count (conj collection :x :x))) :set\n      (= (first (cc :x :y)) :y) :list\n      :default :vector)))", "user": "54d5343fe4b0a52adc2e200a"}, {"problem": 65, "code": "(fn my-type [coll]\n  (let [res (conj (empty coll) [1 2] [1 2] [1 3] [3 4])]\n    (cond\n      (= (count res) 2) :map\n      (= (count res) 3) :set\n      (and (= (first res) [1 2]) (= (count res) 4)) :vector      \n      (and (= (first res) [3 4]) (= (count res) 4)) :list\n      )))", "user": "5532a04ee4b09218d5f44f82"}, {"problem": 65, "code": "#(let [coll (conj % [1 2] [3 4])]\n\t(let [c1 (first coll), coll' (conj coll c1)]\n\t\t(if (= coll coll')\n\t\t\t(if (nil? (get coll c1))\n\t\t\t\t:map\n\t\t\t\t:set)\n\t\t\t(if (identical? c1 (first (rest (conj coll c1))))\n\t\t\t\t:list\n\t\t\t\t:vector))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "54edc818e4b024c67c0cf865"}, {"problem": 65, "code": "(fn b-box-9000 [coll]\n  (cond \n   (reversible? coll) :vector\n   (= {} (empty coll)) :map\n   (= #{} (empty coll)) :set\n   :else :list))", "user": "50e1bdd8e4b019fc399ce17f"}, {"problem": 65, "code": "(fn [s]\n  (let [e (empty s)\n        t1 (conj e {:joe :pete} {:joe :fred})]\n    (if\t(= (count t1) 1) :map\n      (let [t2 (conj e 1 1 2)]\n        (cond \n         (= (count t2) 2) :set\n         (= (first t2) 2) :list\n         :else :vector)))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 65, "code": "(fn [coll]\n    (let [base (empty coll)]\n      (cond \n       (= base {}) :map\n       (= base #{}) :set\n       (= base []) (if (reversible? base) :vector :list)\n       :else nil)))", "user": "543d89dfe4b032a45b869350"}, {"problem": 65, "code": "(fn my-type [coll]\n  (cond\n    (= 10 (:x (conj coll [:x 10]))) :map\n    (= (conj (conj coll 10) 10) (conj coll 10)) :set\n    (= (conj (conj coll 10) 20) (cons 20 (conj coll 10))) :list\n    :else :vector))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 65, "code": "(fn my-type [coll]\n  (let [s (str coll)]\n    (case (first s)\n      \\# :set\n      \\[ :vector\n      \\{ :map\n      :list)))", "user": "547884d7e4b0c51c1f4d72bd"}, {"problem": 65, "code": "(fn [s]\n  (let [e (conj (empty s) [0 0] [0 1] [0 1])]\n    (cond\n     (= (count e) 1) :map\n     (= (count e) 2) :set\n     (= (first e) [0 1]) :list\n     :else :vector)))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 65, "code": "(fn [o]\n  (let [fc (first (str o))]\n    (case fc\n      \\# :set \\{ :map \\[ :vector :list)))", "user": "551c66dae4b07993ea3788de"}, {"problem": 65, "code": "(fn get-coll-type [coll]\n\n  (if (associative? coll)\n    (let [new-coll (conj (empty coll) [0 1] [2 3])]\n      (if (= [0 1] (new-coll 0))\n        :vector\n        :map))\n    (let [size (count coll)\n          new-coll (conj (conj coll 0) 0)]\n      (if (= (count new-coll) (inc size))\n        :set\n        :list))))", "user": "5486e317e4b0e286459a11c0"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "user": "5540f5dee4b0a04f79299509"}, {"problem": 65, "code": "#(case (empty %)\n   {} :map\n   #{} :set\n   (if (= (last (into % [:a :b])) :b) :vector :list))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 65, "code": "#(let [y (empty %)]\n   (cond\n     (= y {}) :map\n     (= y #{}) :set\n     (reversible? y) :vector\n     :else :list))", "user": "51642237e4b003cf19fdde31"}, {"problem": 65, "code": "(fn black [col]\n  (cond \n    (= (:special (conj col [:special 5])) 5) :map\n    (:special (conj col :special)) :set\n    (= (last (conj col :special1 :special2)) :special2) :vector\n    (= (first (conj col :special1 :special2)) :special2) :list\n    :else :unknown\n    ))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 65, "code": "(fn [coll]\n    (let [e (empty coll)]\n    \t (cond\n\t \t (= {} e) :map\n\t\t (= #{} e) :set\n         (= (conj (conj coll 1) 2) (cons 2 (cons 1 coll))) :list\n    \t\t :else  :vector)))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 65, "code": "(fn [s]\n  (let [t (conj s [1 1] [1 2] [1 2])\n        ct (- (count t) (count s))]\n    (if (= 1 ct)\n      :map\n    (if (= 2 ct)\n      :set\n    (if (= [1 2] (last t))\n      :vector\n      :list)))))", "user": "556159fae4b0c656e3ff17c7"}, {"problem": 65, "code": "(fn [x]\r\n  (let [e (empty x)]\r\n    (if (= e {}) :map\r\n      (if (= e #{}) :set\r\n        (if (= e (vector))\r\n          (if (= [1 2] (conj e 1 2)) :vector :list))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 65, "code": "(fn [in] ({{} :map #{} :set} (empty in) (if (reversible? in) :vector :list)))", "user": "555a5731e4b0deb715856e44"}, {"problem": 65, "code": "(fn mytype [mySeq]\n  (let [mapped (conj mySeq [:testA :testB])]\n    (if (= :testB (get mapped :testA))\n      :map\n      (let [conjed (conj mySeq :testA :testB :testB)]\n        (cond (= (count conjed) (+ 2 (count mySeq))) :set\n              (= (first conjed) :testB) :list\n              (= (last conjed) :testB) :vector\n              :else :unknown)))))", "user": "5213dbc3e4b0961f15ac4d74"}, {"problem": 65, "code": "(fn black-box\n  [xs]\n  (cond\n   (= xs (set xs)) :set\n   (= xs (conj xs (first xs))) :map\n   (= [:a :b] (conj (conj (empty xs) :a) :b)) :vector\n   :else :list))", "user": "4fcf1755e4b03432b189f40c"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "54b912b3e4b0ed20f4ff6ea1"}, {"problem": 65, "code": "(fn [x]\n(cond\n(= (set x) x) :set\n(= (into (into x {:a 'b}) {:a 'b}) (into x {:a 'b})) :map\n(= (conj (conj x 'a) 'b) (concat '(b a) x)) :list\n(= (conj (conj x 'a) 'b) (into x ['a 'b])) :vector))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 65, "code": "(fn [x]\n  (case (empty x)\n    {} :map\n    #{} :set\n    [] (if (reversible? x) :vector :list)))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 65, "code": "(fn [coll]\n  (let [test-coll (conj coll [::k ::v])]\n    (cond \n      (= ::v (::k test-coll)) :map\n      (= (cons [::c ::c] test-coll) (conj test-coll [::c ::c])) :list \n      (contains? test-coll [::k ::v]) :set\n      :else :vector)))", "user": "504e71cbe4b0f6ff3350c4b3"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= (get (conj coll [:x \"x\"]) :x) \"x\") :map\n   (= (get (conj coll :x) :x) :x) :set\n   (= (first (conj (conj coll :a) :b)) :b) :list\n   (= (last (conj (conj coll :a) :b)) :b) :vector))", "user": "54ab1b5ae4b09f271ff37cc2"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (:key (conj coll [:key :_]))\n     :map\n   (:item (conj coll :item)) \n     :set\n   (= (first (conj coll :_ :item)) :item) \n     :list\n   :else \n     :vector))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 65, "code": "(fn [seq]  \n  (condp = (first (str seq))\n    \\{ :map\n    \\( :list\n    \\[ :vector\n    \\# :set\n    (if (= \"clojure.lang.LazySeq\" (subs (str seq) 0 20)) \n      :list\n      (if (= \"clojure.lang.PersistentList\" (subs (str seq) 0 27))\n        :list)\n  )))", "user": "4f148418535d64f60314643a"}, {"problem": 65, "code": "(fn test-col [c]\n  (let [c (conj (conj c [1 999]) [2 1000])]\n    (if (= (get c 1) 999)\n      :map\n      (if (get c [1 999])\n        :set\n        (if (= [2 1000] (last c))\n          :vector\n          :list)))))", "user": "556405e5e4b0c656e3ff17fb"}, {"problem": 65, "code": "(fn t2 [sq]\n\t(let [lst (into [] sq)]\n\t\t(if (= lst sq)\n\t\t\t(if (= (conj sq 1 2) (conj lst 1 2))\n\t\t\t\t:vector\n\t\t\t\t:list\n\t\t\t\t)\n\t\t\t(if (= (apply hash-map (flatten lst)) sq)\n\t\t\t\t:map\n\t\t\t\t:set\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)", "user": "5545477fe4b0a04f79299531"}, {"problem": 65, "code": "(fn [coll]\n  (if (reversible? coll)\n    :vector\n    (let [empty-coll (empty coll)]\n      (cond\n       (= empty-coll #{}) :set\n       (= empty-coll {}) :map\n       :else :list))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 65, "code": "#(if (= % (merge % %)) :map\n   (let [extended (conj % :first :second)]\n     (cond\n      (= extended (into extended extended)) :set\n      (= (first extended) :second) :list\n      :else :vector)))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "55702247e4b09a3098a5252a"}, {"problem": 65, "code": "#(let [e (empty %)]\n   (case e\n    #{} :set\n    {} :map\n    [] (if (= (into e [0 1]) [0 1])\n         :vector\n         :list)))", "user": "554b8572e4b0a04f79299589"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond\n      (= e {}) :map\n      (= e #{}) :set\n      (and (= e '()) (reversible? coll)) :vector\n      (= e '()) :list)))", "user": "5550bcece4b00713264bd9ae"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "52fc34cee4b047fd55837015"}, {"problem": 65, "code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n    (if (= 1 (count result))\n      :map (if (= 2 (count result))\n             :set (if (= [1 3] (first result))\n                    :list :vector )))))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 65, "code": "(fn __ [x]\n  (cond\n    ;; If adding {:a 1}, then {:a 2} is no different from just adding {:a 1},\n    ;; it must be a map\n    (= (count (conj x [:a 1]))\n       (count (conj x [:a 1] [:a 2])))\n    :map\n\n    ;; If adding a dummy value once or twice makes no difference, it must be a set\n    (= (count (conj x :dummy)) (count (conj x :dummy :dummy)))  \n    :set\n\n    ;; If conjoining an element returns the element in the last position, it's\n    ;; a vector, otherwise it's a list\n    (= (last (conj x :fake :dummy)) :dummy)\n    :vector\n\n    :else\n    :list))", "user": "55702081e4b09a3098a52529"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "556f48b9e4b09a3098a5251f"}, {"problem": 65, "code": "(fn [c]\n         (let [x (gensym)]\n           (cond\n             (and (associative? c) (reversible? c)) :vector\n             (and (associative? c) ((complement reversible?) c)) :map\n             (= (conj c x) (conj (conj c x) x)) :set\n             (= x (first (conj c x))) :list\n\n\n             )))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 65, "code": "(fn [coll]\n  (let [t (into coll [[:x 99][:y 98]])]\n    (cond (= (get t :x) 99) :map\n          (= (get t [:x 99]) [:x 99]) :set\n          (= (take 2 t) [[:y 98] [:x 99]]) :list\n          (= (take-last 2 t) [[:x 99] [:y 98]]) :vector\n          :else nil)))", "user": "55586905e4b0deb715856e2b"}, {"problem": 65, "code": "(fn [xs] (let [f (conj xs [:foo :bar] [:foo :bas]) h (first f)] \n           (cond (get (conj xs [:foo :bar] [:foo :bas]) :foo nil) :map\n                 (= (get (frequencies (conj xs :foo :foo)) :foo) 1) :set\n                 (= :foo (first (conj xs :bar :foo))) :list\n                 :else :vector)))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 65, "code": "(fn [t]\n    (let [c (conj (conj (conj t [\\X :b]) [\\X :b]) [\\Y :d])]\n      (if (= (count c) (+ 2 (count t)))\n        (if (= :b (get c \\X))\n          :map\n          :set)\n        (if (= [\\Y :d] (first c))\n          :list\n          (if (= [\\Y :d] (last c))\n            :vector\n            )))))", "user": "554a75c9e4b0a04f79299575"}, {"problem": 65, "code": "(fn [s]         \n  (let [c (count s)\n        f (conj s [:x 1] [:x 1] [:y 2])]\n                \n    (cond (= 2 (:y f)) :map\n          (= (+ 2 c) (count f)) :set\n          (= [:y 2] (first f)) :list\n          :else :vector)))", "user": "541b41d1e4b01498b1a71a65"}, {"problem": 65, "code": "(fn [x]\n  (let [c (first (str x))]\n    (cond \n     (= \\{ c) :map\n     (= \\# c) :set\n     (= \\[ c) :vector\n     :else :list)))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 65, "code": "(fn [coll]\n  (cond \n   (= (empty coll)  {}) :map\n   (= (empty coll) #{}) :set\n   (= \n    (conj (empty coll) 1 2) \n    [1 2]) :vector\n   :else :list))", "user": "53065acbe4b02e8216869792"}, {"problem": 65, "code": "(fn sol [s] (cond\n                (= (into #{} s) s) :set\n                (get (into s [[:a :b]]) :a) :map\n                (= [2 0] (first (conj (conj s [1 0]) [2 0]))) :list\n                :else :vector\n                ))", "user": "54857657e4b0e286459a11ac"}, {"problem": 65, "code": "(fn my-inspect\n  [coll]\n  (let [newcoll (conj coll [1 1] [1 1] [1 2])]\n    (cond\n      (= (count newcoll) (inc (count coll))) :map\n      (= (count newcoll) (+ (count coll) 2)) :set\n      (= (first newcoll) [1 2]) :list\n      (= (last newcoll) [1 2]) :vector)))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 65, "code": "(fn [s]\n  (let [? #(re-find % (str s))]\n    (cond\n     (? #\"#\" ) :set\n     (? #\"\\{\") :map\n     (? #\"\\[\") :vector\n     :else :list)))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 65, "code": "(fn [xs] \n  (cond\n   (-> (conj xs [:p 99]) :p (= 99)) :map\n   (-> (conj xs 1 1) count (= (count (conj xs 1)))) :set\n   (-> (conj xs :me :you) first (= :you)) :list\n   (-> (conj xs :me :you) last (= :you)) :vector\n   ))", "user": "5581747fe4b05c286339e0fa"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 65, "code": "(fn [x]\n  (let [v [:key :value]]\n    (cond\n      (= :value (get (conj x v) :key))\n      :map\n      (= (conj x v) (conj x v v))\n      :set\n      (reversible? x)\n      :vector\n      :else\n      :list)))", "user": "555f3bfde4b0a2eb076a39c1"}, {"problem": 65, "code": "(fn [ar]\n  (let [a (conj ar [1 2] [3 4])]\n    (if (= a (conj a (first a)))\n      (if (nil? (a (first a)))\n        :map\n        :set)\n      (if (= (first a) (last (conj a (first a))))\n        :vector\n        :list))))", "user": "52979551e4b02ebb4ef75043"}, {"problem": 65, "code": "(fn [coll]\n  (let [x (str (first (str coll)))]\n    (cond\n      (= \"{\" x) :map\n      (= \"c\" x) :list\n      (= \"[\" x) :vector\n      (= \"#\" x) :set)))", "user": "52ba2639e4b07a9af57922cb"}, {"problem": 65, "code": "(fn f65 [x]\n  (let [xlen (count x)\n        xlen1 (inc xlen)\n        xlen2 (inc xlen1)\n        xlen3 (inc xlen2)\n        ]\n    (cond\n      (= xlen1 (count (conj x [:xyz :b] [:xyz :c]))) :map\n      (= xlen2 (count (conj x :a :a :c))) :set\n      (= :xxx (last (conj x :xxx1 :xxx))) :vector\n      (= :xxx (first (conj x :xxx1 :xxx))) :list\n      )))", "user": "51f81925e4b09be9c177e526"}, {"problem": 65, "code": "(fn black-box-testing [v]\n  (cond\n          (:a (conj v [:a 1])) :map\n          (< (- (count (conj v 1 1)) (count v)) 2) :set\n          (= (conj v 1 2) (cons 2 (cons 1 v))) :list\n          :else :vector))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 65, "code": "(fn [coll]\n    (let [coll2 (conj (empty coll) [7 7] [7 7] [8 1][8 8])]\n        (cond\n          (and (= 4 (count coll2)) (= [8 8] (first coll2))) :list\n          (and (= 4 (count coll2)) (= [7 7] (first coll2))) :vector\n          (= 3 (count coll2)) :set\n          :else :map)))", "user": "5535e822e4b09218d5f44fb2"}, {"problem": 65, "code": "(fn my-type [x]                                                                                                                                         \n    (cond                                                                                                                       \n        (reversible? x)  :vector                                                                                                                        \n        (associative? x) :map                                                                                                   \n        (= (- (count (into x [:a :a])) (count x)) 2) :list                                                                                              \n        :else            :set                                                                                                   \n        ))", "user": "558b50d5e4b027778923762b"}, {"problem": 65, "code": "(fn [xs]\n  (cond\n   (= (inc (count xs)) (count (conj xs {:city \"shanghai\"} {:city \"ningbo\"}))) :map\n   (= (inc (count xs)) (count (conj xs {:city \"ningbo\"} {:city \"ningbo\"}))) :set\n   (= :shanghai (last (conj xs :ningbo :shanghai))) :vector\n   (= :shanghai (first (conj xs :ningbo :shanghai))) :list))", "user": "52c5c1c8e4b0c2d177d620fc"}, {"problem": 65, "code": "(fn [coll]\n    (let [coll (into (empty coll) [[0 1] [2 3]])]\n      (cond\n        (= (get coll 0) 1) :map\n        (= (get coll 0) [0 1]) :vector\n        (= (get coll [0 1]) [0 1]) :set\n        (= (first (conj coll :new)) :new) :list\n        :else :unkown)))", "user": "531c6e72e4b08068f379eda0"}, {"problem": 65, "code": "(fn [xs] \n  (cond\n    (= 123 (get (conj xs [:abc 123]) :abc)) :map\n\t(= (+ 2 (count xs)) (count (conj xs 100 200 100))) :set\n\t(= 456 (first (conj xs 123 456))) :list\t\n    (= 456 (last (conj xs 123 456))) :vector\n    ))", "user": "558ea13be4b0277789237654"}, {"problem": 65, "code": "(fn [c] (let [c1 (count c)\n              s1 (keyword (gensym))\n              s2 (keyword (gensym))\n              c' (conj c [s1 s2] [s1 s2])]\n          (if (= (inc c1) (count c'))\n           \t(if (c' s1) :map :set)\n            (if (= s2 (first (conj c s1 s2)))\n              :list\n              :vector))))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 65, "code": "#(case (nth (str %) 0)\n   \\{ :map\n   \\# :set\n   \\[ :vector\n   :list)", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 65, "code": "#(condp = (empty %)\n   #{} :set {} :map\n   (first (conj (empty %) :vector :list)))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 65, "code": "(fn [coll] \n  (let [s (conj (empty coll) [0 1])]\n     (if (= (get s 0) 1)\n       :map\n       (if (= (get s 0) [0 1])\n         :vector\n         (if (= (get s [0 1]) [0 1])\n           :set\n           :list)))))", "user": "5587d8b3e4b059ccff29b1e8"}, {"problem": 65, "code": "#(let [v [:k 9]\n       v2 [:kw 9]\n       c2 (-> %1 (conj v) (conj v2))\n       fst (first c2)]\n   (cond (:k c2) :map \n         (contains? c2 v) :set\n         (= v2 fst) :list\n         :otherwise :vector))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 65, "code": "(fn [coll] (let [v [:k 9]\n                         v2 [:k2 9]\n                         c2 (-> coll (conj v) (conj v2))\n                         fst (first c2)\n                       ]\n             (cond\n              (:k c2) :map\n              (contains? c2 v) :set\n              (= v2 fst) :list\n              :otherwise :vector)))", "user": "55496eeae4b0a04f79299569"}, {"problem": 65, "code": "(fn t [x]\n  (if (associative? x)\n    ;Either {} or []\n    (if (reversible? x)\n      :vector\n      :map)\n    (if (= (count (conj x 1 1)) (+ 2 (count x)))\n      :list\n      :set\n      )))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "558a81fbe4b027778923761c"}, {"problem": 65, "code": "(fn [qq]\n    (cond (not (nil? (:x (conj qq [:x 2])))) :map\n          (= (count (conj qq 2)) (count (conj qq 2 2))) :set\n          (let [a {:x :x}] (identical? (first (conj (conj qq '()) a))  a)) :list\n          :else :vector))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 65, "code": "(fn [x]\n  (let [e (empty x)]\n     (cond\n        (= (conj e {:a :a}) {:a :a}) :map\n        (= (count (conj (conj e :a) :a)) 1) :set\n        (= (last (conj (conj e :a) :b)) :b) :vector\n        (= (last (conj (conj e :a) :b)) :a) :list)))", "user": "5590e55de4b0277789237676"}, {"problem": 65, "code": "#(let [base (empty %)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? %) :vector :list)))", "user": "5587ddd9e4b059ccff29b1ea"}, {"problem": 65, "code": "#(cond\n  (not (ifn? %)) :list\n  (not (associative? %)) :set\n  (not (reversible? %)) :map\n  :else :vector)", "user": "55342ee0e4b09218d5f44f98"}, {"problem": 65, "code": "(fn me [coll] \n  \n\t(let [mystr (str coll)\n          \n          mystr-seq (seq mystr)\n          \n          first-seq (first mystr-seq)\n          \n         ] \n     \n      (cond\n       (= first-seq \\() :list\n       (= first-seq \\#) :set\n       (= first-seq \\{) :map\n       (= first-seq \\[) :vector  \n       :else :list               \n       \n       )\n     \n     )  \n \n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 65, "code": "(comp (fn [ec]\n        (cond (= {} ec) :map\n              (= #{} ec) :set\n              (= [1 2] (conj ec 1 2)) :vector\n              :else :list))\n      empty)", "user": "559b2ad1e4b066d22e731f4e"}, {"problem": 65, "code": "(fn [s]\n  (let [e (empty s)]\n    (cond\n     (= e {}) :map\n     (= e #{}) :set\n     (reversible? e) :vector\n     :else :list)))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 65, "code": "(fn [s]\n  (cond \n   (= (inc (count s)) (count (conj s {:t 1} {:t 2}))) :map\n   (= (inc (count s)) (count (conj s {:t 1} {:t 1}))) :set\n   (= :test (last (conj s :dummy :test))) :vector\n   :else :list))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 65, "code": "(fn [coll]\n  (let [test-coll (conj coll [:xy :yz])\n        s (count test-coll)\n        f (first test-coll)\n        l (last test-coll)]\n    (if-not (associative? test-coll)\n      (cond\n       (= (count (conj test-coll f)) s ) :set\n       (not= (count (conj test-coll f)) s ) :list\n       )\n      (cond \n       (= (last (conj test-coll [:pq :pq] )) [:pq :pq] ) :vector\n       (not= (last (conj test-coll [:pq :pq] )) [:pq :pq]) :map)\n      )))", "user": "4fc5eb7fe4b0ee37620e1803"}, {"problem": 65, "code": "(fn [coll] \n  (let [base (empty coll)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? base) :vector :list )\n     )))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 65, "code": "(fn bbt [s]\n    (cond\n      (= :value (get (conj s [:key :value]) :key)) :map\n      (= (inc (count s)) (count (conj s :same :same))) :set\n      (= :ll (last (conj s :l :ll))) :vector\n      (= :ff (first (conj s :f :ff))) :list\n      :else :no-seq))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 65, "code": "(fn [x] \n  (let [y (into x {:a :b :c :d})]\n  (cond\n   \t(contains? y :a) :map\n    (contains? y [:a :b]) :set\n    (= [:c :d] (first y)) :list\n   :else :vector\n   )))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 65, "code": "(fn [coll]\n  (let [new-coll (into coll [{:z :x} {:z :x} {:z :y}])\n        diff (- (count new-coll) (count coll))]\n    (cond\n      (= 1 diff) :map\n      (= 2 diff) :set\n      :else (if (= {:z :y} (first new-coll)) :list :vector))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 65, "code": "(fn[coll]\n\t  (let [obj (new Object)]\n\t    (let [x (conj coll [1 2])]\n\t      (cond\n\t        (empty? (flatten x)) (if (associative? x) :map :set)\n\t        (= (first (conj x obj)) obj) :list\n\t        :else :vector\n\t      )\n\t)))", "user": "5597cc26e4b031d6649c9b93"}, {"problem": 65, "code": "(fn [coll]\n  (cond   \n   (= :test-v (-> coll (conj {:test-k :test-v}) :test-k)) :map\n   (= :test-s (-> coll (conj :test-s) :test-s)) :set\n   (= :test-2 (-> coll (conj :test-1) (conj :test-2) last)) :vector\n   (= :test-2 (-> coll (conj :test-1) (conj :test-2) first)) :list ))", "user": "523b4e91e4b07becd5be21ef"}, {"problem": 65, "code": "(fn [s]\n  (if-not (nil? (:a (conj s [:a 1])))\n    :map\n    (if (= (into s [:a]) (into s [:a :a]))\n      :set\n      (let [s1 (conj s 1)]\n        (if (= s1 (first (conj s1 s1)))\n          :list\n          :vector)))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n   (= (get (conj c :t) :t) :t) :set\n   (= (first (conj (conj c :a) :b)) :b) :list\n   (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "53cb5559e4b00fb29b2212d2"}, {"problem": 65, "code": "(fn [cl] (let [c (if (empty? cl) (let [ce  (conj cl [0 1])]\n                 (if (= 1 (get ce 0)) ce\n                    (into (empty ce) [0 1 2]) )\n               ) cl)\n               fv (first c) nc (conj c fv) sc (seq nc)] (cond\n    (= (count c) (count (flatten sc)))        :set\n    (= (/ (count (flatten sc)) 2) (count sc)) :map\n    (= (last nc) fv)    :vector    \n    (not= (last nc) fv) :list\n)))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 65, "code": "(fn t [coll]\n  (let [secret :my-secret]\n    (cond\n      (= :bar (:foo (conj coll [:foo :bar]))) :map\n      (= (inc (count coll)) (count (conj (conj coll secret) secret))) :set\n      (= secret (first (conj (conj coll :foo) secret))) :list\n      :else :vector)) )", "user": "50ec409ce4b04edc33777045"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll (if (empty? coll) (into coll [[:a :b]]) coll)]\n  (cond\n  \t(= (conj coll [1 2]) (cons [1 2] coll)) :list\n  \t(> (count (conj coll [:foo :foo] [:voo :voo])) (count (conj coll [:foo :foo] [:foo :voo]))) :map\n  \t(> (count (conj coll [:foo :foo] [:foo :voo])) (count (conj coll [:foo :foo] [:foo :foo]))) :set\n   :else :vector))\n  )", "user": "55b527cbe4b01b9910ae2985"}, {"problem": 65, "code": "(fn kiu? [x] (let [z (vector :e1 :e2) tmp0 (conj x (vector :e2 :e1)) tmp1 (conj tmp0 z) ] \n                     (if (= (concat tmp1 [z]) (conj tmp1 z)) \n                         :vector \n                         (if (= tmp1 (conj tmp1  z)) \n                           (if (= (tmp1 :e1) :e2)\n                               :map\n                               :set)\n                           :list))))", "user": "5576e78de4b05c286339e075"}, {"problem": 65, "code": "(fn [c]\n    (let [e (str (empty c))]\n      (cond\n        (= \"{}\" e)  :map\n        (= \"[]\" e)  :vector\n        (= \"#{}\" e) :set\n        :else       :list\n        )))", "user": "559a9a3de4b066d22e731f45"}, {"problem": 65, "code": "#(let [result (conj % [:x1 1] [:x1 1] [:x2 2])]\n     (cond\n      (= 1 (:x1 result)) :map\n      (= (count result) (+ (count %) 2)) :set\n      (= [:x2 2] (first result)) :list\n      (= [:x2 2] (last result)) :vector))", "user": "55647a31e4b0c656e3ff1808"}, {"problem": 65, "code": "(fn [xs]\n  ;; make sure the collection is not empty, kinda lame\n  (let [xs (conj xs [:x :y])]\n    ;; test for a map by trying to access the item keyed by :x\n    (if (= (:x xs) :y)\n      :map\n      (if (= (count xs)\n             (count (conj xs (first xs))))\n        :set\n        ;; test for a list by conj an item, if it's a list then it'll\n        ;; end up on in first, else it's a vector\n        (if (= (first (conj xs :z)) :z)\n          :list\n          :vector)))))", "user": "52cb6bb0e4b07d0d72b2734c"}, {"problem": 65, "code": "(fn [s]\n  (case (first (str s))\n    \\c :list\n       \\{ :map\n       \\[ :vector \n          \\# :set))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "55b54ecbe4b01b9910ae2987"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "55bc5280e4b01b9910ae29f1"}, {"problem": 65, "code": ";#(cond\n;\t(nil? (seq (flatten (conj % [1 2])))) \n;\t (if (seq (flatten (first (merge % {:a 1 :b 2})))) :map :set)\n;\t;(= (+ 1 (count %)) (count (conj % 1 1))) :set\n;\t(= (conj % 1 2) (into (empty %) (conj % 1 2))) :vector\n;\t:else :list)\n\n#(if (= % (merge % %))\n\t:map\n\t(let [coll (conj % 1 2)]\n\t\t(cond \n\t\t\t(= coll (into coll coll)) :set\n\t\t\t(= coll (into (empty coll) coll)) :vector\n\t\t\t:else :list)))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 65, "code": "(fn bbt65 [collection]\n  (let [sz (count collection)]\n    \n    \n    (cond \n      (= (inc sz) (count (conj collection {:k1 41} {:k1 42}))) :map\n      (= (inc sz) (count (conj collection 42 42))) :set\n      (= 42 (last (conj collection 41 42))) :vector\n      (= 42 (first (conj collection 41 42))) :list\n      :else :other)\n    )\n      \n  )", "user": "55a65872e4b09e57187da299"}, {"problem": 65, "code": "(fn [x]\n  (let [e (empty x)]\n  (cond\n    (= e {}) :map\n    (= e #{}) :set\n    (= (first (conj e 1 2)) 2) :list\n    (= (first (conj e 1 2)) 1) :vector)))", "user": "53df11c3e4b0d874e779ae3d"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= empty-coll {}) :map\n      (= empty-coll #{}) :set\n      :else (if (reversible? empty-coll) :vector :list))))", "user": "555521a5e4b0deb715856e12"}, {"problem": 65, "code": "(fn[a]\n  (let [v (conj a [:speci 100])]\n   (if (get v :speci)\n     :map\n     (if (contains? v [:speci 100])\n       :set\n       (let [w (conj v [:deci])]\n         (if (= (first w) [:deci])\n           :list\n           :vector))))))", "user": "5596af34e4b04c1e5c31d758"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? coll) :vector :list))))", "user": "55b5fc18e4b01b9910ae298d"}, {"problem": 65, "code": "#(let [test (conj (empty %) [1 2] [1 2] [1 3])]\n    (cond\n     (= 1 (count test)) :map\n     (= 2 (count test)) :set\n     (= [1 3] (first test)) :list     \n     :else :vector))", "user": "55aa7c5ce4b0988bba2ad94d"}, {"problem": 65, "code": "(fn bbt [xs]\n    (let [v1 (str xs)\n          v2 (str xs xs)\n          new-xs (conj xs [v1 v1])\n          new-xs2 (conj new-xs [v1 v1])\n          new-xs3 (conj new-xs2 [v1 v2])]\n          (cond (= (count new-xs3) (inc (count xs))) :map\n                (= (count new-xs) (count new-xs2)) :set\n                (= (first new-xs3) [v1 v2]) :list\n                :else :vector)))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (conj coll [0 0] [1 1])]\n    (if (= c (conj c [0 0]))\n      (if (contains? (conj c [c c]) c)\n        :map\n        :set)\n      (let [f (first c)]\n        (if (= f (first (conj c [f f])))\n          :vector\n          :list)))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (= {} (empty x)) :map\n    (= (empty x) #{}) :set\n    (= 1 (first (into (empty x) [1 2]))) :vector\n    :else :list))", "user": "55c652dde4b0e31453f649bd"}, {"problem": 65, "code": "(fn bbt [v]\n  (cond (.isInstance clojure.lang.IPersistentSet v) :set\n        (.isInstance clojure.lang.IPersistentMap v) :map\n        (.isInstance clojure.lang.IPersistentVector v) :vector\n        (.isInstance clojure.lang.IPersistentCollection v) :list))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 65, "code": "(fn classify [n] (let [char (first (str n))] (cond (= \\{ char) :map (= \\# char) :set (= \\[ char) :vector :else :list)))", "user": "55c10409e4b01b9910ae2a2c"}, {"problem": 65, "code": "#(if-let [t ({{} :map, #{} :set} (empty %))]\n  t\n  (if (-> % (conj 1) (conj 0) first zero?)\n    :list :vector))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "55c423e1e4b0e31453f64994"}, {"problem": 65, "code": "(fn [s]\n  (cond\n    (= {} (empty s)) :map\n    (= #{} (empty s)) :set\n    (= [0 1] (conj (empty s) 0 1)) :vector\n    (= '(1 0) (conj (empty s) 0 1)) :list))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 65, "code": "(fn blackBox [coll]\n  (cond \n    (= 1 (:a (into coll {:a 1}))) :map\n    (= :a (:a (conj coll :a))) :set\n    (= :foo (first (conj coll :bar :foo))) :list\n    :else :vector))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 65, "code": "#(let [s (conj % [100 0] [100 1])]\n    (cond \n     (contains? s 100) :map\n     (contains? s [100 0]) :set\n     (= (first s) [100 1]) :list\n     (= (last s) [100 1]) :vector))", "user": "4faf97d8e4b081705acca258"}, {"problem": 65, "code": "(fn [incol]\n  (let [col (conj incol [:mark_a :mark_b])]\n    (cond\n     (= col (conj col col)) :map\n     (= (conj col :mark) (-> col (conj :mark) (conj :mark))) :set\n     (= :mark (first (conj col :mark))) :list\n     (= :mark (last (conj col :mark))) :vector\n     )\n   )\n)", "user": "511e17a9e4b0c5b849dd36b0"}, {"problem": 65, "code": "(fn checkcoltype [target]\n   (cond\n     (= :val (:key (conj target [:key :val]))) :map\n     (= (inc (count target)) (count (conj target 1 1))) :set\n     (= 2 (first (conj target 1 2))) :list\n     (= 2 (last (conj target 1 2))) :vector\n     :else :unknown)\n   )", "user": "55a372f1e4b0acc240e31537"}, {"problem": 65, "code": "(fn [coll]\n  (let [d [:a :b]\n        m {:b 3}]\n    (cond\n      (= 3 (:b (into coll m))) :map\n      (< (count (apply conj coll [:a :a])) (+ 2 (count coll))) :set\n      (= :b (last (apply conj coll d))) :vector\n      (= :b (first (apply conj coll d))) :list)))", "user": "54f4adc8e4b0f2f3c5226e86"}, {"problem": 65, "code": "(fn black-box \n  [s]\n  (cond \n        (reversible? s) :vector\n        (associative? s) :map\n        (= s (apply hash-set s)) :set\n        :else :list))", "user": "55acd080e4b03311e7b73298"}, {"problem": 65, "code": "(fn [items]\n  (let [types [:map {} :set #{} :list '()] type-items (empty items)]\n    (loop [[type-name type-data & rest] types]\n      (if (= type-data type-items)\n        (if (not= type-name :list)\n          type-name\n          (if (= (conj type-items 1 2 3) [1 2 3])\n            :vector\n            :list))\n        (recur rest)))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 65, "code": "(fn [col]\n  \n  (let [e [:aaa :bbb]\n        e' [:ccc :ddd]\n        map-test \n        \t(fn [c] (= (last e) (get (conj c e) (first e))))\n        list-test \n        \t(fn [c] (= e (first (conj (conj c e') e))))\n        seq-test \n            (fn [c] (= (+ 1 (count c)) (count (conj (conj c e) e))))\n        vector-test \n            (fn [c] (= e (last (conj (conj c e') e))))]\n  \n  (cond \n   (map-test col) :map\n   (seq-test col) :set\n   (vector-test col) :vector \n   (list-test col) :list\n   :else (throw \"error\"))))", "user": "4f055d4f535dcb61093f6bf6"}, {"problem": 65, "code": "(fn [coll]\n    (if (= (rest (cons :junk coll)) coll)\n      (if (= (conj (empty coll) :one :two) (cons :one (cons :two (empty coll))))\n        :vector\n        :list)\n      (if (= (count (conj (empty coll) [:a 1] [:a 2])) 1)\n        :map\n        :set)))", "user": "54864662e4b0e286459a11b8"}, {"problem": 65, "code": "(fn [col]\n    (cond\n     (= :b (get (conj col [:a :b]) :a)) :map\n     (= (conj col :a) #{[:a :b]}) :set \n     (= (count (conj col :c :c)) (+ 1 (count col))) :set\n     (= (last (conj col :d :c )) :c) :vector\n     (= (first (conj col :d :c )) :c) :list\n    :else :none))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 65, "code": "#(let [_1 (gensym), _2 (gensym)]\n  (cond (-> (conj % [_1 _2]) (get _1))                    :map\n        (-> (conj % _1 _1)   count (= (inc (count %))))   :set\n        (-> (conj % _1 _2)   first (= _2))                :list\n        :else                                             :vector ))\n       \n;(conj {1} [3 4]) -> {1 2, 3 4}\n;(conj #{1} [3 4]) -> #{1 [3 4}])\n;(conj #{1} 3 4) -> #{1 3 4}\n;(conj #{1} 3 3) -> #{1 3}])\n;(conj [1] 2 3) -> [1 2 3])\n;(conj '(1) 2 3) -> (3 2 1))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 65, "code": "(fn [coll]\n  (let [newcoll (conj coll {:d 4} {:c 3} {:c 3})]\n    (cond \n     (get newcoll :c) :map\n     (= (+ 2 (count coll)) (count newcoll)) :set\n     (= {:c 3} (last newcoll)) :vector\n     :else :list)))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 65, "code": "(fn get-type [coll]\n  (if (associative? coll)\n    (if (reversible? coll)\n      :vector\n      :map)\n    (let [cur (conj coll 3)] (if (= cur (seq cur))\n                              :list\n                              :set))\n    ))", "user": "55d95be7e4b0e31453f64ac9"}, {"problem": 65, "code": "(fn [x]\n  (let [\n    zero (empty x)\n    indicator (into zero [[:a :vector] [:a :vector] [:a :list]])\n    size (count indicator)]\n    (println x zero indicator size)\n    (cond\n      (= 1 size) :map\n      (= 2 size) :set\n      :else      (-> indicator first last))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 65, "code": "#(let [tv [:foo :bar]\r\n       coll (conj % tv)]\r\n   (if (= coll (conj coll tv))\r\n     (if (:foo coll) :map :set)\r\n     (if (= :foo (first (conj coll :foo))) :list :vector)))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (:a (conj coll [:a 1])) :map\n   (> (+ 2 (count coll)) (count (conj (conj coll :a) :a))) :set\n   (= :b (first (conj (conj coll :a) :b))) :list\n   :else :vector))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 65, "code": "#(let [v (empty %)]\n    (cond\n      (= {} v) :map\n      (= #{} v) :set\n      (= '() v) (if (= 1337 (last (conj (conj % 1) 1337)))\n                  :vector\n                  :list)))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 65, "code": "(fn [coll]\n  (let [x [:hoopy :frood]]\n    \n    ;; If we add x twice, but count increases by only 1\n    ;; the collection must be associative.\n  \t(if (= (inc (count coll)) (count (into coll [x x])))\n      \n      ;; associative - if coll is a map, the first element of our known \n      ;; sequence will become a key when the sequence is conj-ed to the \n      ;; collection\n      (if (:hoopy (conj coll x))\n        :map\n        :set)\n      \n      ;; sequential - it's important to know where your towel is:\n      ;; if coll is a list, :towel will be added to the front.\n      ;; if coll is a vector, :towel will be a added to the back.\n      ;; It's necessary to add two items so first and last aren't\n      ;; referring to the same item.\n      (if (= :towel (first (conj (conj  coll :zarquod) :towel)))\n      \t:list\n      \t:vector))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 65, "code": "#(let [len (count %)\n       len+1 (inc len)]\n   (if (= len+1 (count (conj % [:_z 1] [:_z 1])))\n     (if (= len+1 (count (conj % [:_z 1] [:_z 2])))\n       :map\n       :set)\n     (if (= :_z (first (conj % :_y :_z)))\n       :list\n       :vector)))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 65, "code": "(fn coll-type [c]\n  (let [cnt (count c) \n        c2 (conj c c) \n        rc (reduce (fn [s e] (conj s e)) c c)\n        testcol [[:a :a] [:a :a] [:a :b]]] \n    (cond \n      ;conj two idental maps won't add new elements\n      (and (< 0 cnt) (= cnt (count c2))) :map\n      (and (< 0 cnt) (= cnt (count rc))) :set\n      (and (< 0 cnt) (= c (first c2))) :list\n      (and (< 0 cnt) (= c (last c2))) :vector\n      ;when input is an empty collection, \n      ;we use a test collection to test different behaviour\n      ;avoid using key tests because exception will occur\n      ;if it is a map, only 1 item remains {:a :b}\n      (= 1 (count (apply conj c testcol) ) ) :map\n      ;for a set, two elements remain: #{[:a :a] [:a :b]}\n      (= 2 (count (apply conj c testcol))) :set\n      ;vector append elements to the tail\n      (= (last (apply conj c testcol) ) [:a :b]) :vector\n      ;list appen to the front\n      (= (first (apply conj c testcol) ) [:a :b]) :list\n      )\n    )\n  )", "user": "558bdcefe4b0277789237633"}, {"problem": 65, "code": "#(let [x (first %)\n            y (if x x [1 2])\n            add-once (conj % y)\n            add-twice (conj add-once y)]\n        (if (= (count add-once) (count add-twice))\n          (if (= (set add-once) add-once)\n            :set\n            :map)\n          (if (= (conj add-once add-once) \n                 (conj (vec add-once) add-once))\n            :vector\n            :list)))", "user": "55db7e15e4b0e31453f64ae8"}, {"problem": 65, "code": "(fn [a] \n  (let [fi (first (str a))]\n  \t(if (= \\{ fi) :map \n    \t(if (= \\[ fi) :vector\n    \t\t(if (= \\# fi) :set\n              :list)))))", "user": "55da18d5e4b0e31453f64ad1"}, {"problem": 65, "code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map ; (= (conj % nil) %)\n  (= (conj % :a :a) (conj % :a)) :set\n  :else :list)", "user": "55236ad6e4b0882d96d091b1"}, {"problem": 65, "code": "#(cond\n    (= [1 1] (get (conj % [1 1]) [1 1])) :set\n    (= 1 (get (conj % [1 1]) 1)) :map\n    (= [1 1] (last (conj % 0 [1 1]))) :vector\n    1 :list)", "user": "53b15e6ee4b047364c04448f"}, {"problem": 65, "code": "(fn type-of\n  [some-struct]\n  (let [foo [:some :foo] \n        bar [:some :bar]\n        is-vector? #(and (identical? (last (conj % foo bar)) bar)   ;; lifo behavior from last\n                         (identical? (last (butlast (conj % foo bar))) foo)\n                         (nil? (get (conj % foo) :some)))           ;; associative by index\n        is-list? #(and (identical? (first (conj % foo bar foo)) foo)\n                       (identical? (second (conj % foo bar foo)) bar) ;; lifo behavior from first\n                       (nil? (get (conj % foo) :some)))      \n        is-set? #(and (= 2 (count (conj (empty %) foo bar foo))))   ;; uniques\n        is-map? #(and (= :bar ((conj % foo bar) :some))             ;; override map-entry\n                      (= 1 (count (conj (empty %) foo bar))))]      ;; only one-map-entry added\n    (cond (is-set? some-struct) :set\n      \t  (is-vector? some-struct) :vector\n          (is-list? some-struct) :list\n          (is-map? some-struct) :map)))\n\n;; using specific data-structures properties emulated in the raw-version: associative + reversible + uniqueness\n#_(fn type-of [ds]\n  (if (associative? ds)\n    (if (reversible? ds) :vector :map)\n    (if (= 1 (count (conj (empty ds) :foo :foo))) :set :list)))", "user": "5553b729e4b0deb715856e05"}, {"problem": 65, "code": "(fn [t]\n  (let [xs (conj t {1 1} {1 1} {2 2})\n       a  (associative? xs)\n       c  (count t)\n       t  (count xs)]\n    (cond\n      (and a (= 2 (- t c))) :map\n      (and a (= 3 (- t c))) :vector\n      (= 2 (- t c)) :set\n      :else :list)))", "user": "4f85a75ce4b033992c121c48"}, {"problem": 65, "code": "(fn [coll]\n  (let [subj (empty coll)]\n    (case subj\n      {} :map\n      #{} :set\n      (if (= :test (first (conj subj :dummy :test)))\n        :list\n        :vector))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 65, "code": "(fn [x]\n  (let [xx (conj x [:z 1] [:z 1] [:z 2])]\n    (cond (= (inc (count x))\n             (count xx)) :map\n          (= (+ 2 (count x))\n             (count xx)) :set\n          (= [:z 2] (first xx)) :list\n          :else :vector)))", "user": "55c68089e4b0e31453f649c4"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "4f88ae35e4b033992c121c6d"}, {"problem": 65, "code": "(fn what [coll]\n  (let [c (conj (empty coll) [1 1] [1 2])]\n    (if (= 1 (count c)) :map\n      (cond \n       (= 2 (count (conj c [1 1]))) :set\n       (= [1 2] (first c)) :list\n       :default :vector))))", "user": "558bb38fe4b0277789237631"}, {"problem": 65, "code": ";; A three-line solution, if you don't care for readability!\n;;\n#_(fn [x] (letfn [(M-or-V [x] (if (nil? ((conj x [:qq :yy]) 0)) :map :vector))\n                  (S-or-L [x] ([:set :list](- (count (conj (conj x :qq) :qq)) (count (conj x :qq)))))]\n          (if (associative? x) (M-or-V x) (S-or-L x))))\n;; -----------------------------------------------------------------\n\n(fn [x]\n  (letfn [(M-or-V [x]\n                  (if (nil? ((conj x [:qq :yy]) 0)) :map :vector))\n          (S-or-L [x]\n                  ([:set :list](- (count (conj (conj x :qq) :qq))\n                                  (count (conj x :qq)))))]\n    (if (associative? x)\n      (M-or-V x)\n      (S-or-L x))))", "user": "4f80db02e4b033992c121bf9"}, {"problem": 65, "code": "#(case (int (first (str %))) 123 :map 35 :set 91 :vector 99 :list)", "user": "55b39523e4b01b9910ae2973"}, {"problem": 65, "code": "(fn black-box\n  [coll]\n  (let [test-pair [:a :a]\n        test-pair-2 [:b :b]]\n    (letfn [(not-nil? [item]\n              (not (nil? item)))\n            (test-list [given-coll]\n              (= test-pair-2 (first (conj given-coll test-pair test-pair-2))))\n            (test-vec [given-coll]\n              (= test-pair-2 (last (conj given-coll test-pair test-pair-2))))\n            (test-map [given-coll]\n              (= given-coll (merge given-coll given-coll)))\n            (test-set [given-coll]\n              (not-nil? (get (conj given-coll test-pair) test-pair)))]\n      (cond ;; map and set branch first because map may also\n        ;; return true for the vector test\n        (test-map coll) :map\n        (test-set coll) :set\n        (test-list coll) :list\n        (test-vec coll) :vector))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 65, "code": "(fn [coll]\n  (let [fc (first (str coll))]\n    (cond\n      (= fc \\{) :map\n      (= fc \\[) :vector\n      (= fc \\() :list\n      (= fc \\#) :set\n      :else :list)))", "user": "55df1985e4b050e68259b3eb"}, {"problem": 65, "code": "(fn [x]\n  (let [base (empty x)]\n    (cond\n      (= {} base) :map\n      (= #{} base) :set\n      :else (if (reversible? base) :vector :list))))", "user": "55c77070e4b0e31453f649d0"}, {"problem": 65, "code": "(fn [coll]\n (if (= coll (conj coll coll)) :map\n  (if (= (conj coll \"a\") (conj coll \"a\" \"a\")) :set\n   (if (= \"||\" (first (into [] (conj (conj coll \"__\") \"||\")))) :list :vector)\n  )\n )\n)", "user": "55e8a85be4b0121d4835fd98"}, {"problem": 65, "code": "#(let [x (into (empty %) [[:a 1] [:a 1] [:a 2]])]\n  (cond\n    (= (count x) 1) :map\n    (= (count x) 2) :set\n    (= (first x) [:a 1]) :vector\n    :else :list))", "user": "55d5ee3fe4b0e31453f64a92"}, {"problem": 65, "code": "(fn [t]\n  (let [testcase [[100 100] [101 101]]\n        tar (empty t)\n        tar1 (reduce conj tar testcase)]\n    (println tar)\n    (cond \n     (= tar {}) :map\n     (= tar #{}) :set\n     (= testcase (take-last 2 tar1)) :vector\n     (= (reverse testcase) (take 2 tar1)) :list)))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 65, "code": "(fn tt [v] (let [ec (empty v)]\n               (cond\n                 ( = ec #{}) :set\n                 ( = ec {})  :map \n                 ( = ec '()) (if (reversible? ec) :vector :list))\n                 ))", "user": "55f04526e4b06e875b46ce20"}, {"problem": 65, "code": "(fn [v]\n  (let [ext1 (conj v [1 1])\n        len1 (count ext1)\n        ext2 (conj ext1 [1 1])\n        len2 (count ext2)\n        ext3 (conj ext2 [1 7])]\n    (if (= len1 len2)\n      (if (contains? ext3 [1 1])\n        :set\n        :map)\n      (if (= (first ext3) [1 7])\n        :list\n        :vector))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 65, "code": "(fn something\n   [coll]\n   (let [is-map? (fn [coll]\n                   (let [m (conj coll [::test ::value])]\n                     (and (= ::value (get m ::test)) :map)))\n         is-vector? (fn [coll]\n                      (let [v (conj coll ::test-1)\n                            v1 (conj v ::test-1)\n                            v2 (conj v1 ::test-2)]\n                        (and (= (count v2) (+ 2 (count v)))\n                             (= ::test-2 (nth v2 (dec (count v2))))\n                             :vector)))\n         is-list? (fn [coll]\n                    (let [list-1 (conj coll ::test-1)\n                          list-1' (conj list-1 ::test-1)\n                          list-2 (conj list-1' ::test-2)]\n                      (and (= (count list-2) (+ 2 (count list-1)))\n                           (= ::test-2 (nth list-2 0)) \n                           :list)))\n         is-set? (fn [coll]\n                   (let [s1 (conj coll ::test-1)\n                         s2 (conj s1 ::test-1)]\n                     (and (= (count s1) (count s2)) :set)))]\n     (some #(%1 coll) [is-map? is-vector? is-list? is-set?])))", "user": "539e717fe4b0ca733b974488"}, {"problem": 65, "code": "(comp {\"{}\" :map  \"#{}\" :set \"[]\" :vector \"()\" :list} pr-str empty)", "user": "54e1939ce4b024c67c0cf7c5"}, {"problem": 65, "code": "#(let [t (conj (empty %) [:k :v])]\n   (cond\n    (:k t) :map\n    (get t 0) :vector\n    (get t [:k :v]) :set\n    :else :list))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 65, "code": "(fn [coll]\n    (let [base (empty coll)]\n      (cond\n        (= base {}) :map\n        (= base #{}) :set\n        (= base '()) (if (reversible? coll) :vector :list))))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 65, "code": "(fn black-box-testing\n  [coll]\n  (let [cnt (count coll)\n        res (conj (conj (conj coll [:a :b]) [:a :b]) [:c :d])]\n    (cond\n      (= (:a res) :b) :map\n      (= (+ cnt 2) (count res)) :set\n      (= (last res) [:c :d]) :vector\n      :else :list)))", "user": "5574c172e4b05c286339e059"}, {"problem": 65, "code": "(fn [coll] \n  (let [\n        ismap (:test (conj coll [:test true]))  \n        isset  (= 1 (- (count (conj coll [:unique 1] [:unique 1])) (count coll)))\n        islist (= [:last 2] (first (conj coll [:first 1] [:last 2])))\n      ]\n      (cond ismap :map\n            isset :set\n            islist :list\n            true :vector\n      )\n    )\n  )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 65, "code": "(fn prob65\n  [col]\n  (let [blank (empty col)]\n    (cond\n     (= blank {}) :map\n     (= blank #{}) :set\n     (= blank '()) (if (reversible? blank):vector :list)\n     :else :unknown)))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 65, "code": "(fn tester [obj]\n  (cond\n   (= (conj obj {}) obj) :map\n   (= (count (conj obj 3)) (count (conj (conj obj 3) 3))) :set\n   (= (first (conj (conj obj \"streng\") \"derrick\")) \"derrick\") :list\n   (= (last (conj (conj obj \"streng\") \"derrick\")) \"derrick\") :vector\n   :else :set))", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 65, "code": "(fn black-box [coll]\n  (cond\n    (empty? coll)\n    (black-box (conj coll [1 2]))\n\n    (=\n     (count coll)\n     (count (into coll coll)))\n    (if (= (set coll) coll)\n      :set\n      :map)\n\n    (= :test (first (conj coll :test)))\n    :list\n\n    (= :test (last (conj coll :test)))\n    :vector\n\n    :else\n    :wtf))", "user": "53350264e4b0656e627bfd73"}, {"problem": 65, "code": "(fn [coll]\n  (cond (= (set coll) coll) :set\n        (= (apply list coll) coll) (if (= (conj coll :a :b) (cons :b (cons :a coll))) :list :vector)\n        :else :map))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "558e18e5e4b027778923764d"}, {"problem": 65, "code": "(fn __\n  [coll]\n  (let [tested (empty coll)]\n   (cond\n\t  (not (ifn? tested)) :list\n\t  (= 2 (count (conj tested [:t1 :t2] [:t1 :t2]))) :vector\n    (= :t2 ((conj tested [:t1 :t2]) :t1)) :map\n    :else :set)))", "user": "55a62092e4b0acc240e31554"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (conj (empty coll) \n                [1 1] \n                [1 1] \n                [1 2])\n        n (count c)\n        h (first c)]\n   (cond (= n 1) :map\n         (= n 2) :set\n         (= h [1 1]) :vector\n         (= h [1 2]) :list)))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 65, "code": "(fn mytype [c] (let [prop {:assoc (associative? c)\n                         :rev (reversible? c)}]\n               (cond\n                 (= prop {:rev false :assoc true }) :map\n                 (= prop {:rev true :assoc true }) :vector\n                 (= (count (conj (conj c :fred) :fred)) (+ 1 (count c))) :set\n                 (= prop {:rev false :assoc false }) :list)))", "user": "4f35e662e4b0e243712b1ec6"}, {"problem": 65, "code": "#(if (associative? %)\n   (if (empty? (flatten (into % {1 1})))\n     :map\n     :vector)\n   (if (= (+ 2 (count %)) (count (into % [1 1])))\n\t:list\n\t:set))", "user": "53573d70e4b04ce2eb3ed278"}, {"problem": 65, "code": "(fn [coll]\n  (condp #(= (empty %2) %1) coll\n    {} :map\n    #{} :set\n    [] (if (nil? (first (conj (conj coll 1) nil)))\n         :list\n         :vector)\n    )\n  )", "user": "55fe7e15e4b00f4cabc57651"}, {"problem": 65, "code": "(fn [thing]\n  (let [e (empty thing)]\n     \n    (cond\n     (= e {}) :map\n     (= e #{}) :set\n     (= (conj (conj e :a) :b) (list :b :a)) :list\n     (= (conj (conj e :a) :b) [:a :b]) :vector)))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 65, "code": "(fn [seq]\n           (let [[k1 v1 :as p1] [(str (java.util.UUID/randomUUID))\n                                 (str (java.util.UUID/randomUUID))]\n                 p2 [(str (java.util.UUID/randomUUID))\n                     (str (java.util.UUID/randomUUID))]\n                 mseq (-> seq\n                          (conj p1)\n                          (conj p2))]\n             (cond\n               (= (get mseq k1) v1) :map\n               (= (get mseq p1) p1) :set\n               (= (first mseq) p2) :list\n               (= (last mseq) p2) :vector)))", "user": "50a3ad0ee4b0ceace084d493"}, {"problem": 65, "code": "(fn seq-type [t]\n  (let [base (empty t)]\n    (cond\n     (= base {}) :map\n     (= base '()) (if (reversible? base) :vector :list)\n     (= base  #{}) :set)))", "user": "5604bcf7e4b08b23635d315a"}, {"problem": 65, "code": "(fn [coll]\n    (let [base (empty coll)]\n      (cond\n        (= base {}) :map\n        (= base #{}) :set\n        :else (if (reversible? coll) :vector :list))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 65, "code": "; easy-peasy: see documentation for `empty`\n(fn [coll]\n  (let [e (empty coll)]\n    (cond (= e {}) :map\n          (= e #{}) :set\n          ; [] and () compare alike for equality, however,\n          ; list does not implement Reversible, vector does\n          (= e []) (if (reversible? coll) :vector :list)\n          :default nil)))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 65, "code": "(fn [c]\n  (let [e (empty c)]\n    (if (= e {})\n      :map\n      (if (= e #{})\n        :set\n        (if (= 3 (first (conj e 1 2 3)))\n          :list\n          :vector)))))", "user": "55fee5e4e4b00f4cabc5765a"}, {"problem": 65, "code": "(fn [coll]\n    (if (empty? (flatten (conj coll [:xyz :xyz])))\n      (if (associative? coll) :map :set)\n      (if (= :xyz (first (conj coll :abc :xyz))) :list :vector)))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 65, "code": "#(let [a [1 1] b [1 2] x (into (empty %) [a b b])]\n  (condp = (count x)\n    1 :map\n    2 :set\n    (if (= a (first x)) :vector :list)))", "user": "560a7b46e4b05f002753defb"}, {"problem": 65, "code": "(fn [xs]\n    (let [elem (cond\n                 (= (first xs) [:a :a]) [:b :b]\n                 :else [:a :a])\n          next-elem [:c :c]\n          newxs (-> xs (conj elem) (conj next-elem) (conj next-elem))]\n      (cond\n        (and (= (+ (count xs) 3) (count newxs))\n             (= (first newxs) next-elem)) :list\n        (= (get newxs (first elem)) (second elem)) :map\n        (= newxs (conj newxs next-elem)) :set\n        :else :vector)))", "user": "560e9a2de4b05f002753df52"}, {"problem": 65, "code": "(fn type-of\n   [s]\n   (cond\n     (= :testing (get (into s {:testing :testing}) :testing)) :map\n     (= (count (filter #{:testing} (conj (conj s :testing) :testing))) 1) :set\n     (= (first (conj (conj s :test1) :test2)) :test2) :list\n     (= (last (conj (conj s :test 1) :test2)) :test2) :vector))", "user": "56084e91e4b046a4fc0ac00f"}, {"problem": 65, "code": "(fn my-type [coll]\n  (let [r1 (rand-int 30000) r2 (rand-int 50000)]\n    (cond\n      (= (into #{} (seq coll)) coll) :set\n      (= (conj coll (first coll)) coll) :map\n      (= (last (conj coll r1 r2)) r2) :vector  \n    :else :list)))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 65, "code": "#(let [size (count %)\n       index (inc (* 2 size))\n       new [index 0]\n       conj-1 (conj (empty %) new)\n       new-size (count conj-1)]\n   (if (get conj-1 index nil)\n     :map\n     (let [conj-2 (conj conj-1 new)]\n       (if (= (count conj-2) new-size)\n         :set\n         (let [conj-3 (conj conj-2 [index 1])]\n           (if (= (first conj-3) [index 1])\n             :list\n             :vector))))))", "user": "532ecd44e4b019098a6f8b49"}, {"problem": 65, "code": "(comp {\\{ :map \\# :set \\[ :vector \\c :list} first str)", "user": "553698fae4b09218d5f44fc0"}, {"problem": 65, "code": "(fn [v]\n\t(let [ev    (empty v)\n          conj2diff (conj (conj ev [1 1]) [1 2])]\n      (if (= (count conj2diff) 1)\n        :map\n        (let [conj2same (conj (conj ev [1 1]) [1 1])]\n          (if (= (count conj2same) 1)\n            :set\n            (if (= (first conj2diff) [1 1])\n              :vector\n              :list))))))", "user": "56051095e4b08b23635d3162"}, {"problem": 65, "code": "(fn [s]\n  (let [f (first (str (doall s)))  \n        m {\\[ :vector\n           \\{ :map\n           \\# :set\n           \\( :list\n           \\c :list\n           }]\n        (get m f)\n    \n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 65, "code": "#(let [e (empty %)]\n  (if (associative? e) (if (reversible? e) :vector :map)\n                       (if (= 1 (count (apply conj e [1 1]))) :set :list)))", "user": "555c6344e4b0b056612e224c"}, {"problem": 65, "code": "(fn [c]\n  (let [n (count c)\n        new (conj c [1 2] [1 2])]\n    (cond\n      (and (= (count new) (inc n)) (get new 1)) :map\n      (= (count new) (inc n)) :set\n      (= :b (first (conj c :a :b))) :list\n      :else :vector)))", "user": "55ea0780e4b0121d4835fda7"}, {"problem": 65, "code": "(fn [coll]\n  (case (into (empty coll) [[:a 1] [:b 2]])\n    '([:b 2] [:a 1]) :list\n    [[:a 1] [:b 2]] :vector\n    {:a 1 :b 2} :map\n    #{[:a 1] [:b 2]} :set))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 65, "code": "(fn [cs] \n  (let [css (conj (empty cs) [:a 1] [:b 2])]\n    (cond \n      (= (get css :a) 1) \t      :map\n      (= (get css [:a 1]) [:a 1]) :set\n      (= (first css) [:b 2])   \t  :list\n      (= (last css)  [:b 2])\t  :vector )))", "user": "561aab66e4b053970a773b0a"}, {"problem": 65, "code": "#(let [e (empty %)]\n  (cond\n    (= e {}) :map \n    (= (conj e 1 2) [1 2]) :vector\n    (= e []) :list\n    (= e #{}) :set))", "user": "561047eae4b05f002753df6d"}, {"problem": 65, "code": "#(let [\n       e1 [:key :v1]\n       e2 [:key :v2]\n       t (conj % e1 e1 e2)\n       ts (count t)\n       s (count %)]\n  \n  (cond \n    (and (= (+ 1 s) ts) (contains? t :key)) :map\n    (= (+ 2 s) ts) :set\n    (= (last t) e2) :vector\n    :else :list)\n)", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "561bc8e3e4b064ca9f4b1689"}, {"problem": 65, "code": "#(condp = (empty %)\n    {} :map\n    #{} :set\n    (if (-> % empty (conj 1 2) first (= 1))\n      :vector\n      :list))", "user": "5499e23de4b03163384f4706"}, {"problem": 65, "code": "(fn [S] (let [l (count S) tl (count (into S '([1 2] [1 3] [1 3])))] (cond (= (+ 1 l) tl) :map (= (+ 2 l) tl) :set (= (+ 3 l) tl) (if (associative? S) :vector :list))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 65, "code": "(fn [coll] (let [gen (gensym), conjed (conj coll [:my-key gen]), conjed2 (conj conjed [:my-key gen])]\n             (if (= (count conjed) (count conjed2))\n               (if (contains? conjed [:my-key gen])\n                 :set\n                 :map)\n               (if (= (first (conj conjed [gen gen])) [gen gen]) \n                 :list\n                 :vector))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 65, "code": "(fn foo [a]\n  (let [m #(),\n        n (conj a [m 1] [m 2])]\n     (cond\n      (= (take 2 n) (list [m 2] [m 1])) :list\n      (contains? n m) :map\n      (contains? n [m 1]) :set\n      :else :vector)))", "user": "561f9110e4b064ca9f4b16ce"}, {"problem": 65, "code": "(fn check [s]\n  (let [x (empty s)]\n    (cond\n     (= x {}) :map\n     (= x #{}) :set\n     (= (conj x 1 2) (list 2 1)) :list\n     :else :vector\n     )))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5614fa1de4b05f002753dfbe"}, {"problem": 65, "code": "(fn [arg]\n  (if (= :value (get (conj arg [:key :value]) :key))\n    :map\n    (if (= (conj arg :duplicate) (conj arg :duplicate :duplicate))\n      :set\n      (if (= :first (first (conj arg :second :first)))\n        :list\n        :vector))))", "user": "561fc0d0e4b064ca9f4b16d2"}, {"problem": 65, "code": "(fn [coll]\n    (let [ f [:firstkey :firstval]\n           t [:tailkey :tailval]\n          conjcoll (conj  (conj coll f) t)\n          concatcoll (into (empty coll) (concat conjcoll conjcoll))\n          setlike (apply distinct? concatcoll)\n          settypetest (fn [x] (= (set x) x))\n          ]\n      (cond\n        (and setlike\n             (= true (settypetest coll)))   :set\n        (=  setlike true) :map\n        (= (last conjcoll) t) :vector\n        :else :list\n        )\n      )\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 65, "code": "#(or ({{} :map #{} :set} (empty %))\n     (if (= 1 ((comp first conj) (empty %) 1 2)) :vector :list))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 65, "code": "(fn [x]\n  (case (first (str x))\n    \\# :set\n    \\[ :vector\n    \\{ :map\n    :list))", "user": "55b1e9e7e4b0da326a65cf74"}, {"problem": 65, "code": "(fn [s]\n  (let [s0 (empty s)]\n    (cond\n      (= s0 {}) :map\n      (= s0 #{}) :set\n      (= (conj s0 1 2) [1 2]) :vector\n      :else :list)))", "user": "56228d00e4b03f08ee9a9227"}, {"problem": 65, "code": "(fn type-ms2\n  [inp]\n  (let [ds  (if (empty? inp) (into inp [[8 9]]) inp)]\n    (cond\n      (= '() (flatten ds)) (if (= :B ((into ds [[:A :B]]) :A)) :map :set)\n      (= 0 (.indexOf (into ds [1 2 3]) 3)) :list\n      :else :vector\n      )))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 65, "code": "(fn bbt [s]\n\t(if (empty? s)\n\t\t(let [ns (conj s [0 1])]\n\t\t\t(case ns \n\t\t\t{0 1} :map\n\t\t\t#{[0 1]} :set\n\t\t\t'([0 1]) \n\t\t\t\t(case (conj s 0 1)\n\t\t\t\t\t'(1 0) :list\n\t\t\t\t\t[0 1] :vector\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(if (= (conj s {}) s) \n\t\t:map\n\t\t\t(if (= \"mur-mur\" (first (conj s \"mur-mur\")))\n\t\t\t\t:list\n\t\t\t\t\t(if (= \"mur-mur\" (last (conj s \"mur-mur\")))\n\t\t\t\t\t\t:vector\n\t\t\t\t\t\t:set\n\t\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5559b443e4b0deb715856e3c"}, {"problem": 65, "code": "#(cond\n    (= (into [] %) %) (if (reversible? %) :vector :list)\n    (= (into #{} %) %) :set\n    (= (into {} %) %) :map)", "user": "4f40c46fe4b0e243712b1fbe"}, {"problem": 65, "code": "(fn [xs]\n  (case (empty xs)\n    #{} :set\n    {} :map\n    (if (= (conj xs 1 2) (cons 2 (cons 1 xs)))\n      :list\n      :vector)))", "user": "5573ffb5e4b0aa18f790f3fd"}, {"problem": 65, "code": "(fn[arg]\n  (cond\n    (:test-map (into arg {:test-map true})) :map\n    (= (count (conj (conj arg :test-set) :test-set)) (+ 1 (count arg))) :set\n    (= :test-vector-2 (last (conj (conj arg :test-vector-1) :test-vector-2))) :vector\n    true :list\n    )\n  )", "user": "55aa5f73e4b0988bba2ad94b"}, {"problem": 65, "code": "(fn [s]\n  (let [v [10 20] c (conj s v)]\n    (cond\n     (= 20 (get c 10)) :map\n     (= v (get c v)) :set\n     (= 10 (last (conj c 10))) :vector\n     :else :list)))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 65, "code": "(fn bbt[l]\n (let [l (empty l)]\n  (cond\n    (= {} l) :map\n    (not= (+ 2 (count l)) (count (conj l 2 2))) :set\n    (= 3 (last (conj (empty l) 1 2 3))) :vector\n    :else :list\n    )))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 65, "code": "(fn bbt [c]\n  (cond\n   (= 42 (get (conj c [:a 42]) :a)) :map\n   (= (conj c 42) (-> c (conj  42) (conj 42))) :set\n   (= (concat c '(41 42)) (-> c (conj 41) (conj  42))) :vector\n   (= (concat '(42) c) (conj c 42)) :list\n   )\n  )", "user": "5408ec4de4b0addc1aec66d0"}, {"problem": 65, "code": "(fn [x]\n  (let [y (empty x)]\n    (cond\n      (= y {}) :map\n      (= y #{}) :set\n      (= y []) (if (reversible? y) :vector :list)))\n  )", "user": "5628cb07e4b00e49c7cb47ef"}, {"problem": 65, "code": "(fn [xs]\n  (let [s (str xs)]\n    (cond (re-find #\"^\\{\" s) :map\n          (re-find #\"^\\#\\{\" s) :set\n          (re-find #\"^\\[\" s) :vector\n          :else :list)))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 65, "code": "(fn [x]\n  (get { \\{ :map, \\# :set, \\[ :vector } \n       (first (str x))\n       :list))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "56011393e4b04bb52996e178"}, {"problem": 65, "code": "(fn [coll]\n  (if (associative? coll)\n    (if (reversible? coll) :vector :map)\n    (if (get (conj coll :abc) :abc) :set :list)))", "user": "55e7d06ee4b050e68259b496"}, {"problem": 65, "code": "(fn [s] (let [sz (count s)\n              sy (gensym)\n              v1 [sy 1]\n              v2 [sy 2]]\n          (if (> (- (count (conj (conj s v1) v1)) sz) 1)\n            (if (= (first (conj (conj s v1) v2)) v2)\n              (identity :list)\n              (identity :vector))\n            (if (> (- (count (conj (conj s v1) v2)) sz) 1)\n              (identity :set)\n              (identity :map)))))", "user": "55b0f5bfe4b002ce9d5cbc28"}, {"problem": 65, "code": "(fn [x]\n      (let [mt (empty x)]\n\t(cond (= mt #{}) :set\n\t      (= mt {}) :map\n\t      :else\n\t      (cond (reversible? x ) :vector\n                :else :list))\n)\n)", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 65, "code": "(fn tip [x]\n  (cond\n   (= #{} (empty x)) :set\n   (= {} (empty x)) :map\n   (not= (conj (conj x 1) 2) (conj (conj (vec x) 1) 2)) :list\n   :else :vector))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 65, "code": "(fn type-of-coll [c]\n  (cond (= (:my-key (conj c [:my-key :my-val])) :my-val) :map\n        (= 1 (:my-val (frequencies (into c [:my-val :my-val])))) :set\n        (= (first (into c [:s :my-val])) :my-val) :list\n        (= (last (into c [:s :my-val])) :my-val) :vector))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 65, "code": "(fn [coll] ({5 :map 1 :set 7 :vector 3 :list}  (+ (if (associative? coll)\n                                                    5\n                                                    1)\n                                                  (count (flatten (conj (empty coll) [5 5]))))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 65, "code": "(fn [c]\n  (let [ecstr (str (empty c))]\n    (cond\n      (= ecstr \"[]\") :vector\n      (= ecstr \"{}\") :map\n      (= ecstr \"#{}\") :set\n      :empty :list)))", "user": "562e8b2be4b0ab312c17ebbb"}, {"problem": 65, "code": "(fn my-type [coll]\n  (if (associative? coll)\n    (if (= (count (conj coll [0 1])) (count (conj (conj coll [0 1]) [0 1])))\n      :map\n      :vector)\n    (if (= (count (conj coll 1)) (count (conj (conj coll 1 1) 1 1)))\n       :set\n       :list)\n    ))", "user": "561a1af6e4b053970a773b02"}, {"problem": 65, "code": "(fn [x]\n\t(cond \n\t\t(= (count (conj (conj x [0 1]) [0 2])) (+ 1 (count x))) :map\n\t\t(= (count (conj (conj x 1) 1)) (count (conj x 1))) :set\n\t\t(= (conj (conj x 100) 101) (conj (conj (seq x) 100) 101)) :list\n\t\t:else :vector))", "user": "51f5539fe4b0abb92f97f9cd"}, {"problem": 65, "code": "#(let [len (count %1) t {:tmp 1} a (conj %1 {nil nil} t t) len-a (count a)]\n\t(if (= 3 (- len-a len))\n\t\t(if (= t (first a)) \n\t\t:list\n\t\t:vector)\n\t\t(if (= 1 (:tmp a)) \n\t\t:map\n\t\t:set)))", "user": "528147b6e4b0757a1b171425"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "56388a0fe4b0bfe05bf117e7"}, {"problem": 65, "code": "(fn custom-type\n  [coll]\n  (let [_map? #(let [initial-size (count %)\n                     tuple-a-b (conj % [:_xXx :b])\n                     tuple-a-c (conj tuple-a-b [:_xXx :c])\n                     final-size (count tuple-a-c)]\n                 (if (= (dec final-size) initial-size)\n                   :map))\n        _list? #(if (= (take 2 (conj (conj % :a) :b)) '(:b :a))\n                  :list)\n        _set? #(let [size (count %)]\n                 (if (= (count (conj (conj % :a) :a)) (inc size))\n                   :set))]\n    (or\n     (_map? coll)\n     (_list? coll)\n     (_set? coll)\n     :vector)))", "user": "4fc524aae4b081705acca37e"}, {"problem": 65, "code": "#(if (empty? %) (recur (into % [[:a :b]]))\n   (cond\n    (= (set %) %) :set\n    (= % (merge % %)) :map\n    (= (first (into % [:GENSYM])) :GENSYM) :list\n    :else :vector))", "user": "5627444fe4b00e49c7cb47cd"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "56399b7ee4b0bfe05bf117f5"}, {"problem": 65, "code": "(fn black-box-testing [coll]\n  (let [pair1 [:new-key1 :new-val1]\n        pair2 [:new-key2 :new-val2]\n        new-coll (conj (conj coll pair1) pair2)]\n    (if (= (conj new-coll pair2) new-coll) \n      (if (contains? new-coll :new-key2) :map :set)\n      (if (= (cons pair2 (cons pair1 coll)) new-coll) :list :vector))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 65, "code": "(fn [coll]\n   (let [uuid (java.util.UUID/randomUUID)\n         conjed-coll (conj coll\n                           [\"a\" \"b\"]\n                           [uuid \"Lorum Ipsum\"])]\n     (cond\n       (= \"Lorum Ipsum\" (get conjed-coll uuid)) :map\n       (= (get conjed-coll [uuid \"Lorum Ipsum\"]) [uuid \"Lorum Ipsum\"]) :set\n       (= (last conjed-coll) [uuid \"Lorum Ipsum\"]) :vector\n       (= (first conjed-coll) [uuid \"Lorum Ipsum\"]) :list\n       :else :no-idea)))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 65, "code": "(fn\n  [coll]\n  (cond\n    (= (:a (conj coll [:a 1])) 1) :map\n    (< (count (conj coll :a :a)) (+ (count coll) 2)) :set\n    (= (first (conj coll :a coll)) coll) :list\n    :else :vector\n    )\n  )", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   \n   (= 2 (:c (conj coll [:c 1] [:c 2])))\n   :map\n   \n   (= (inc (count coll)) (count (conj coll [:c 1] [:c 1])))\n   :set\n\n   (= [:c 2] (first (conj coll [:c 1] [:c 2])))\n   :list\n\n   (= [:c 2] (last (conj coll [:c 1] [:c 2])))\n   :vector))", "user": "52f3568fe4b05e3f0be25f0e"}, {"problem": 65, "code": "(fn [input]\n   (if (associative? input)\n     (if (reversible? input)\n       :vector\n       :map\n       )\n     (case (count (filter #(= \"test\" %) (conj input \"test\" \"test\"))  )\n       1 :set\n       2 :list)))", "user": "546b24a0e4b00cfc9eacc166"}, {"problem": 65, "code": "(fn [coll]\n  (let [first-char (first (pr-str coll))]\n    (cond (= first-char \\{) :map\n          (= first-char \\() :list\n          (= first-char \\[) :vector\n          (= first-char \\#) :set\n          :else (throw (Exception. \"Not a sequence\")))))", "user": "5564709ee4b0c656e3ff1807"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (and (associative? c) (reversible? c)) :vector\n    (associative? c) :map\n    (= (count (conj (empty c) 1 1)) 2 ) :list\n    :else :set))", "user": "56347285e4b0bfe05bf117bc"}, {"problem": 65, "code": "(fn\n  [coll]\n  (let [nothing (empty coll)]\n   (case nothing\n      {}  :map\n      #{} :set\n      (if (= 2 (-> nothing (conj 1) (conj 2) first))\n        :list\n        :vector))))", "user": "5376190de4b06839e8705e1c"}, {"problem": 65, "code": "(fn seq-type\n  [s]\n  (cond\n    (= (conj s [1 1] [1 2]) (conj s [1 2])) :map\n    (= (conj s 1 1) (conj s 1)) :set\n    (= (conj s s 1) (cons 1 (cons s s))) :list\n    :else :vector))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 65, "code": "(fn [param]\n  (cond\n   (= (count (conj param [0 1])) (count (conj (conj param [0 1]) [0 2]))) :map\n    (= (count (conj param 0)) (count (conj (conj param 0) 0))) :set\n    (= (rest (conj (conj param 5) 4)) (conj param 5)) :list\n    :else :vector))", "user": "55af7e21e4b03311e7b732cc"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= (conj empty-coll [1 2] [2 3]) (list [2 3] [1 2])) :list\n      (= (conj empty-coll [1 2] [2 3]) [[1 2] [2 3]]) :vector\n      (= (conj empty-coll [1 2] [1 2]) #{[1 2]}) :set\n      :else :map)))", "user": "564161aae4b08d4f616f5ef9"}, {"problem": 65, "code": "#(let [e (empty %)]\n   (case e\n     {}  :map\n     #{} :set\n     (first (conj e :vector :list))))", "user": "505fdf63e4b08f2a82ad10b9"}, {"problem": 65, "code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (= [2 1] (seq (conj (empty %) 1 2))) :list\n  :else :set)", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 65, "code": "(fn [xs]\n  (let [cb (count xs)\n        x (conj xs {:b 2} {:a 1} {:a 1})\n        ca (count x)]\n    (cond\n      (= (get x :a) 1)      :map\n      (= (+ cb 2) ca)       :set\n      (= (last x) {:a 1})   :vector\n      (= (first x) {:a 1})  :list)))", "user": "563ed73ae4b08d4f616f5ecb"}, {"problem": 65, "code": "#(let [r (into (into % {:x 8}) {:y 9})]\n   (cond\n     (= (get r :x) 8) :map\n     (= (get r [:x 8]) [:x 8]) :set\n     (= (last r) [:y 9]) :vector\n     :else :list))", "user": "54e2a779e4b024c67c0cf7d3"}, {"problem": 65, "code": "#(if (associative? %)\n    (if (reversible? %) :vector :map)\n    (if (= (first (conj (conj % 1) 3)) 3) :list :set))", "user": "5619b22ee4b053970a773afe"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond\n      (= {} e) :map\n      (= #{} e) :set\n      (reversible? e) :vector\n      :else :list)))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 65, "code": "(fn bbtest [coll]\n  (let [tester [:a 1]\n        tester2 [:b 2]\n        added (conj (conj coll tester2 ) tester)\n        counts-same? #(not (= (count (conj % tester)) (count %)))] \n        (if (= (last added) tester) \n          (if (counts-same? added) :vector :set) \n          (if (= (first added) tester) (if (counts-same? added) :list :map) :unknown))))", "user": "563b5dc9e4b0bfe05bf1180f"}, {"problem": 65, "code": "(fn my-type [coll]\n  (let [te1   [:x998 1]\n        te2   [:x998 2]\n        s?    (fn [x] (complement nil?))\n        ncoll (apply conj coll [te1 te1 te2])]\n    (cond\n      (= (take 3 ncoll) [te2 te1 te1]) :list\n      (= (take 3 (reverse ncoll)) [te2 te1 te1]) :vector\n      (= (ncoll (first te1)) (second te2)) :map\n      (= (ncoll te1) te1) :set)))", "user": "5641296de4b08d4f616f5ef4"}, {"problem": 65, "code": "(fn what [xs]\n  (let [A        (keyword (gensym))\n        B        (keyword (gensym))\n        conj-xs  (conj xs [A B])]\n   (if (= (A conj-xs) B) \n     :map\n     (let [conj-xs (conj (conj xs A) B)]\n       (cond (= (A conj-xs) A)     :set\n             (= (first conj-xs) B) :list\n             :else                 :vector)))))", "user": "563772a9e4b0bfe05bf117d7"}, {"problem": 65, "code": "#(condp = (count (conj % [:a 1] [:a 2] [:a 1] [:b 1]))\n   2 :map\n   10 :vector\n   5 :set\n   2 :map\n   3 :set\n   4 (condp = (first (conj % 1 2))\n       2 :list\n       1 :vector)\n   :list)", "user": "5649542fe4b0284900eef63f"}, {"problem": 65, "code": "#(let [e (empty %)]\n   (case e\n     {}  :map\n     #{} :set\n     (first (conj e :vector :list))))", "user": "5632b0a9e4b0bfe05bf117a8"}, {"problem": 65, "code": "(fn [d]\n  (let [dict? (fn [d] \n                (let [x (conj d [:x 1])\n                      x* (conj x [:x 1])]\n                  (= (count x) (count x*))))\n        map?* (fn [d] \n                (and (dict? d) (let [x (conj d [:x 1])\n                                     x* (conj x [:x 2])]\n                                 (= (count x) (count x*)))))\n        set?* (fn [d] \n                (and (dict? d) (not (map?* d))))\n        list?* (fn [d]\n                 (and (not (dict? d)) \n                      (let [x (conj d :x)\n                            x* (conj x :y)]\n                        (= :y (first x*)))))]\n    (cond \n     (map?* d) :map\n     (set?* d) :set\n     (list?* d) :list\n     :else :vector)))", "user": "545e7ab0e4b01be26fd7467c"}, {"problem": 65, "code": "(fn [c]\n     (if (= (get (conj c {:k \"v\"}) :k) \"v\")\n       :map\n       (if (= (get (conj c \"v\") \"v\") \"v\")\n       :set\n              (if (= (first (conj c \"a\" \"b\")) \"b\")\n                :list\n                (if (= (last (conj c \"a\" \"b\")) \"b\")\n                   :vector)))))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 65, "code": "(fn [x]\n  (if (empty? x)\n    (cond \n     (= (count (conj x '{1 2})) (count (conj (conj x '{1 2}) '{1 2}))) (if (contains? (conj x '{1 2}) 1) :map :set)         \n     (= :a (first (conj (conj x :b) :a))) :list\n     :else :vector)\n  (cond\n   (not= (count x) (count (flatten (seq x)))) :map\n   (= (count x) (count (conj x (first x)))) :set\n   (= (first x) (first (conj x 666))) :vector\n   :else :list\n   )))", "user": "563d12f9e4b0bfe05bf11845"}, {"problem": 65, "code": "(fn [coll]\n  (let [s (str coll)]\n    (cond\n     (= 0 (.indexOf s \"#{\")) :set\n     (= 0 (.indexOf s \"{\"))  :map\n     (= 0 (.indexOf s \"[\"))  :vector\n     (= 0 (.indexOf s \"(\"))  :list\n     (= 0 (.indexOf s \"clojure.lang.LazySeq\")) :list\n     (= 0 (.indexOf s \"clojure.lang.PersistentList$EmptyList\")) :list)))", "user": "564c7c95e4b0284900eef672"}, {"problem": 65, "code": "(fn [S]\n \t(cond\n     \t(reversible? S) :vector\n     \t\n     \t(associative? S) :map\n     \t(= (count (conj S 1)) (count(conj S 1 1))) :set\n     \t:else :list\n     )\n )", "user": "5649615be4b0284900eef641"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (and (reversible? x) (associative? x)) :vector\n    (associative? x) :map\n    (= (empty x) '()) :list\n    :else :set))", "user": "50cf94bde4b0abc485cb9bb2"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (let [s (gensym)] (= s (s (conj x [s s])))) :map\n   (not= 2 (- (count (conj x 0 0)) (count x)))  :set\n   (let [s (gensym)] (= s (first (conj x (gensym) s))))  :list\n   (let [s (gensym)] (= s (last (conj x (gensym) s))))  :vector))", "user": "564f1be3e4b0284900eef6a6"}, {"problem": 65, "code": "(fn [c]\n  (let [-c (conj c [:sentinel-a 1] [:sentinel-b 2])]\n   (if (get -c [:sentinel-a 1]) :set\n     (if (get -c :sentinel-a) :map\n       (if (= [:sentinel-b 2] (first -c)) :list :vector)))))", "user": "5406776fe4b0addc1aec66a0"}, {"problem": 65, "code": "#(cond\n  (= {:a 1} (conj (empty %) [:a 1])) :map\n  (= '(3 2 1) (into (empty %) [1 2 3])) :list\n  (= [1 2 3] (into (empty %) [1 2 3])) :vector\n  :else :set \n  )", "user": "54227fc6e4b01498b1a71ac0"}, {"problem": 65, "code": "(fn my-type [coll]\n  (if (= 0 (count coll))\n    (if (= {} coll)\n      :map\n      (if (= #{} coll)\n        :set\n        (if (= [1 2] (conj (conj coll 1) 2))\n          :vector\n          :list)))\n    (if (= coll (apply list coll))\n      (if (= (cons 1 coll) (conj coll 1))\n        :list\n        :vector)\n      (if (= coll (apply hash-set (apply list coll)))\n        :set\n        :map))))", "user": "55eb026de4b0121d4835fdb7"}, {"problem": 65, "code": "(fn black-box [B]\n  (let [base (empty B)]\n        (cond \n         (= #{} base) :set\n         (=  {} base) :map\n         (reversible? base) :vector\n         :else :list)))", "user": "564d02cde4b0284900eef679"}, {"problem": 65, "code": "(fn [coll]\n   (let [test-pair1 [:ping :pong1]\n         test-pair2 [:ping :pong2]\n         coll-modified (conj coll test-pair1 test-pair2)]\n     (cond\n      (= coll-modified (conj coll-modified test-pair2)) (if (:ping coll-modified) :map :set)\n      (= test-pair2 (first coll-modified)) :list\n      (= test-pair2 (last coll-modified)) :vector)))", "user": "5169d422e4b051e2a73aba53"}, {"problem": 65, "code": "#(cond\n  \t(reversible? %) :vector\n \t(associative? %) :map\n  \t(ifn? %) :set\n  \t:default :list)", "user": "564b1ff8e4b0284900eef663"}, {"problem": 65, "code": "(fn [x]\n  (if (= (+ 1 (count x)) (count (conj (conj x [1 2]) [1 2])))\n    (if (= (+ 1 (count x)) (count (conj (conj x [1 2]) [1 3])))\n      :map\n      :set\n    )\n    (if (= (first (conj (conj x 1) 2)) 2)\n      :list\n      :vector\n\t)\n    )\n)", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 65, "code": "(fn [s]\n  (let [c (count s)]\n    (if (= (:map (into s {:map 1})) 1) :map\n    (if (= (inc c) (count (into s [\"x\" \"x\"]))) :set\n    (if (= (last (conj s \"x\" \"y\")) \"y\") :vector :list)\n  )))\n  )", "user": "52824143e4b0757a1b171453"}, {"problem": 65, "code": "#({\"[]\":vector,\"{}\":map,\"#{}\":set}(str(empty %)):list)", "user": "4ee67364535d93acb0a6685f"}, {"problem": 65, "code": "#(let [a (conj (empty %) [:a 1] [:a 1] [:a 2])]\n      (condp = (count a)\n        1 :map\n        2 :set\n        (if (= (first a) [:a 2])\n          :list\n          :vector)))", "user": "5382704be4b06839e8705ed4"}, {"problem": 65, "code": "#(let [e (empty %)]\n    (cond\n      (= {} e)  :map\n      (= #{} e) :set\n      (= [1 2] (conj e 1 2)) :vector\n      :else :list))", "user": "563b1553e4b0bfe05bf1180a"}, {"problem": 65, "code": "#(if (= (count (conj % [:rand 1] [:rand 1])) (+ (count %) 2))\n    (if (= (first (conj % [:rand 1] [:rand 2])) [:rand 2])\n      :list\n      :vector)\n    (if (= (count (conj % [:rand 1] [:rand 2])) (+ (count %) 2))\n      :set\n      :map))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 65, "code": "(fn [coll] (let [tmp (reduce conj coll [[1 1] [1 1] [1 2] [2 2]] )]\n                       (if (> (count coll) (- (count tmp) 4) )  ;map or set\n                         (if (> (reduce + (map #(if (= % [1 1]) 1 0) tmp)) 0)  :set  :map)\n                         (if (= tmp (reduce conj (vec coll) [[1 1] [1 1] [1 2] [2 2]])) :vector :list))))", "user": "563f2eaae4b08d4f616f5ed1"}, {"problem": 65, "code": "(fn [coll] (condp = (empty coll) #{} :set {} :map () (if (= 2 (first (into (empty coll) [1 2]))) :list :vector)))", "user": "56481722e4b0284900eef628"}, {"problem": 65, "code": "(fn [col]\n  (let [treated-col (conj col [:a 1] [:a 1] [:b 2])]\n    (if (> (count treated-col) (+ 2 (count col)))\n      (if (= [:b 2] (last treated-col))\n        :vector\n        :list)\n      (if (contains? treated-col :a)\n        :map\n        :set))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 65, "code": "(fn [col]\n  (cond\n    (= (inc (count col)) (count (conj col {:test 1} {:test 2}))) :map\n    (= (inc (count col)) (count (conj col :foobar :foobar))) :set\n    (= (last (conj col 1)) (last (conj col 1 2))) :list\n    :else :vector))", "user": "4fca0376e4b0ee37620e184a"}, {"problem": 65, "code": "#(cond (= (empty %) {}) :map (= (empty %) #{}) :set (= (empty %) []) (if (reversible? %) :vector :list))", "user": "5632e850e4b0bfe05bf117ac"}, {"problem": 65, "code": "#(let [e (empty %)]\n             (if (empty? (conj e nil))\n               :map\n               (let [v (conj e nil nil :nil)]\n                 (cond\n                   (= 2 (count v)) :set\n                   (= :nil (first v)) :list\n                   :else :vector))))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 65, "code": "#(if (associative? %)\n     (if (reversible? %) :vector :map)\n     (if (= (count (conj (conj % :c) :c)) (+ 2 (count %))) :list   :set))", "user": "55c49394e4b0e31453f6499e"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 65, "code": "(fn t [coll]\n  (cond\n    (= (conj coll nil) coll) :map\n    (apply distinct? (conj (conj coll nil) nil)) :set\n    (= (first (conj (conj coll :1) :2)) :2) :list\n    :else :vector))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n   (= (conj s {}) s) :map \n   (empty? s) (cond\n         (= (clojure.set/union s #{}) #{}) :set\n\t       (= (conj (conj s 0) 1) [0 1]) :vector\n\t       :else :list)\n   (= (clojure.set/union s s) s) :set\n   (= (first (conj s s)) s) :list\n   :else :vector))", "user": "54fce8bde4b07d26eda61d30"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 65, "code": "(fn [x]\n  (let [base (empty x)]\n    (cond\n     (= base '{}) :map\n     (= base #{}) :set\n     (= base []) (if (reversible? base) :vector :list))))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 65, "code": "#(\n  let [tempelement12 [1 2]\n       tempelement34 [3 4]\n       newcoll (conj % tempelement12 tempelement12 tempelement34 tempelement34)\n       origcount (count %)\n       newcount (count newcoll)]\n  (if (== (+ 2 origcount) newcount) \n   (if (nil? (get newcoll tempelement12)) :map :set)\n   (if (= tempelement34 (first newcoll)) :list :vector ))\n)", "user": "5650082fe4b0284900eef6b7"}, {"problem": 65, "code": "#(let [e (empty %1)]\n      (cond (= e {}) :map\n            (= e #{}) :set\n            (= :tail (last (conj  e :head :tail))) :vector\n            :else :list))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 65, "code": "(fn [t]\n  (let [e (empty t)\n        ms {{} :map, #{} :set}]\n    (or (ms e)\n        (first (conj e :vector :list)))))", "user": "54485749e4b032a45b8693c7"}, {"problem": 65, "code": "(fn [s]\n     (cond\n        (= (get (conj s {:x \"x\"}) :x) \"x\") :map\n        (= (get (conj s :x) :x) :x) :set\n        (= (first (conj s :y :x)) :x) :list\n        (= (last (conj s :y :x)) :x) :vector\n      ))", "user": "55c6fd60e4b0e31453f649c9"}, {"problem": 65, "code": "(fn [b]\n  (if\n    (= b (conj b {})) :map\n    (let [a (conj (conj b 1) 2)]\n      (cond \n        (= a (conj a (first a))) :set\n        (= a (rest (conj a (first a)))) :list\n        :else :vector))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 65, "code": "(fn [v]\n              (condp = (first (pr-str v))\n                \\{ :map\n                \\# :set\n                \\( :list\n                \\[ :vector))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 65, "code": "#(let [r (conj (empty %) [1 2] [1 2] [1 3])]\n   (cond\n    (= 1 (count r)) :map\n    (= 2 (count r)) :set\n    (= [1 3] (first r)) :list\n    :else :vector))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 65, "code": "(fn [coll]\n              (let [coll (conj coll [::foo ::bar])\n                    item1 [::key ::value]\n                    item2 [::key ::another]\n                    coll (conj coll item1)]\n                (cond\n                  (= (count (conj coll item2)) (count coll)) :map\n                  (= (count (conj coll item1)) (count coll)) :set\n                  (= (-> coll (conj item1) first) item1) :list\n                  (= (-> coll (conj item1) last) item1) :vector)))", "user": "4f9aa2a6e4b0dcca54ed6d0c"}, {"problem": 65, "code": "#(if (= (count (conj % [1 1] [1 1])) (inc (count %)))\n   (if (= ((conj % [:test :test2]) :test) :test2)\n     :map\n     :set)\n   (if (= (first (conj % :test :test2)) :test2)\n     :list\n     :vector))", "user": "56677192e4b04acd4f672dd5"}, {"problem": 65, "code": "(fn [foo]\n  (let [test-elem [:a :a]\n        maybe-map (conj foo test-elem)]\n    ; set-test doesn't work if set has :a - my original test used try/catch\n    ; on map, but catch isn't an allowed word, and I didn't feel like that\n    ; much re-writing\n    (if (:a maybe-map) :map\n      (let [maybe-set (conj foo :a :a)]\n       (if (<= (count maybe-set) (+ 1 (count foo)))\n             :set\n        (let [non-empty-list (conj foo \"abc\")\n              elem-not-in-list (str (apply str non-empty-list) \"xyz\")\n              maybe-list (conj non-empty-list elem-not-in-list)]\n          (if (= (first maybe-list) elem-not-in-list)\n            :list\n            (if (= (last maybe-list) elem-not-in-list)\n              :vector \"I dunno\"))))))))", "user": "56548885e4b0f9d632dd8483"}, {"problem": 65, "code": "(fn [coll]\n   (let [probe [[:1 :1]  [:1 :1] [:2 :2] [:1 :2]]\n         probed (apply (partial conj coll) probe)\n         difference (- (count probed) (count coll))\n         countplacement ({2 :map 3 :set 4 :sequ} difference)]\n     (if (= :sequ countplacement)\n       (if (= [:1 :2] (first probed))\n         :list\n         :vector)\n       countplacement)\n     ))", "user": "567476bde4b05957ce8c6139"}, {"problem": 65, "code": "(fn [arg]\n  (let [my-type (empty arg)]\n    (cond\n      (= (conj my-type [:a 1]) {:a 1}) :map\n      (= 1 (count (reduce #(conj %1 %2) my-type (list :a :a)))) :set\n      (= (first (reduce #(conj %1 %2 ) my-type (list :a :b))) :a) :vector\n      (= (first (reduce #(conj %1 %2 ) my-type (list :a :b))) :b) :list\n      )))", "user": "564a560ae4b0284900eef654"}, {"problem": 65, "code": "(fn vlms [x]\n  (let [poked (conj x [1 2] [1 2] [1 3])\n        c1 (count x)\n        c2 (count poked)\n        f2 (first poked)]\n    (cond\n      (= c2 (+ c1 1)) :map\n      (= c2 (+ c1 2)) :set\n      (= f2 [1 3]) :list\n      :else :vector) ))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 65, "code": "(fn check-type [values]\n  (cond\n    (= (inc (count values)) (count (conj values {:test 1} {:test 2}))) :map\n    (= (inc (count values)) (count (conj values {:test 1} {:test 1}))) :set\n    (= :test (last (conj values :dummy :test))) :vector\n    :else :list))", "user": "55ed71dae4b0121d4835fdd9"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5654c550e4b0f9d632dd848a"}, {"problem": 65, "code": "(fn [xs] (condp = ((comp pr-str empty) xs) \"()\" :list \"[]\" :vector \"{}\" :map \"#{}\" :set))", "user": "5668dcc6e4b04acd4f672df8"}, {"problem": 65, "code": "(fn [xs]\n\t(let [n (count xs) xs (conj xs nil nil)]\n\t\t(cond\n\t\t\t(= n (count xs)) :map\n\t\t\t(= (inc n) (count xs)) :set\n\t\t\t(= (first (conj xs :buddy)) :buddy) :list\n\t\t\t:else :vector)))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 65, "code": "(fn [s]\n  (let [s' (into s [[:a 1] [:a 1]])]\n    (if (not= (count s') (+ (count s) 2))\n\t  (if (:a s') :map :set)\n      (let [s''  (into s [2 3])]\n        (if (= s'' (butlast (conj s'' 1))) :vector :list)))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 65, "code": "(fn [coll]\n    (let [new-coll (conj (empty coll) {:a 1} {:a 1} {:b 1})\n          first-elem (first new-coll)]\n        (cond\n          (= 2 (count first-elem)) :map\n          (= 2 (count new-coll)) :set\n          (= {:a 1} first-elem) :vector\n          :else :list))\n  )", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 65, "code": "(fn  [c]\n  (let [pre-count (count c)\n        changed (conj c [1 2] [1 3] [2 3] [2 3])\n        post-count (count changed)\n        data (get changed 1)\n        map-test (= data 3)\n        set-test (= (- post-count pre-count) 3)\n        list-test (= (first changed) [2 3])]\n    (cond\n      map-test :map\n      set-test :set\n      list-test :list\n      :else :vector)))", "user": "55f358a2e4b06e875b46ce5c"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "567ea95de4b0feffd0d18eb6"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= {} (empty c)) :map\n    (= #{} (empty c)) :set\n    (= \\f (nth (conj c \\e \\f) 0)) :list\n    (= \\f (last  (conj c \\e \\f))) :vector))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 65, "code": "(fn [coll]\n  (let [myconj (conj coll {:special, 3})\n        repconj (conj (conj coll {:a, 1}) {:a, 1})\n        setconj (conj coll {:a, 1})]\n    (cond\n     (contains? myconj :special) :map\n     (= repconj setconj) :set\n     (= (nth (conj (conj coll 3) 4) 1) 3) :list\n     (= (last (conj (conj coll 3) 4)) 4) :vector\n     :else :map)))", "user": "5658d775e4b00d3155796114"}, {"problem": 65, "code": "(fn [c]\n  (cond (= c (merge c c)) :map\n        (= (conj c 10) (conj c 10 10)) :set\n        (= 20 (last (conj c 10 20))) :vector\n        (= 20 (first (conj c 10 20))) :list))", "user": "50e3e108e4b01912b3285c48"}, {"problem": 65, "code": "#(cond (:a (conj % [:a 8])) :map (= (count (conj % :a)) (count (conj % :a :a))) :set (= :b (first (conj % :a :b))) :list (= :b (last (conj % :a :b))) :vector)", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 65, "code": "(fn [coll]\n  ({{} :map #{} :set} (empty coll) (if (reversible? coll) :vector :list)))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 65, "code": "#({ {} :map #{} :set } (empty %) (if (reversible? %) :vector :list))", "user": "56669819e4b0e91d5f5c5674"}, {"problem": 65, "code": "#(let [s (print-str %)]\n  (cond \n  \t(and (= \\{ (first s)) (= \\} (last s))) :map\n  \t(and (= \\( (first s)) (= \\) (last s))) :list\n   \t(and (= \\[ (first s)) (= \\] (last s))) :vector\n    (and (= \\# (first s)) (= \\} (last s))) :set\n  )\n )", "user": "56815e2fe4b0945ebc182a84"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 65, "code": "(fn\n  [c]\n  (if\n    (= () (flatten (conj c [2 3])))\n    (if \n      (= 0 (count c))\n      (if\n        (= {2 2} (conj c [2 2]))\n        :map\n        :set\n      )\n      (if\n        (coll? (first c))\n        :map\n        :set\n      )\n    )\n    (if\n      (= 55 (first (conj (conj c 50) 55)))\n      :list\n      :vector\n    )\n  )\n)", "user": "5676af21e4b05957ce8c6158"}, {"problem": 65, "code": "(fn bb [x] (if (associative? x) (if (empty? x)\n                                    (if (= x {})\n                                      :map\n                                      :vector)\n                                    (if (= (get x 0) (first x))\n                                      :vector\n                                      :map))\n                                  (if (and (= (first (conj x 'a)) 'a) (= (+ (count x) 2) (count (conj x 'a 'a)))) :list :set)))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 65, "code": "(fn [coll]\n  (let [e1 [:foo :bar], e2 [:baz :quux]]\n    (cond (contains? (conj coll e1) (first e1)) :map\n          (= (conj coll e1) (conj coll e1 e1)) :set\n          (= e2 (first (conj coll e1 e2))) :list\n          :else :vector)))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 65, "code": "(fn ugh-why [coll]\n  (cond\n    (= (inc (count coll)) (count (conj coll {:ayy 1} {:ayy 2})))\n    :map\n    (= (inc (count coll)) (count (conj coll {:ayy 1} {:ayy 1})))\n    :set\n    (= :ayy (last (conj coll :lmao :ayy)))\n    :vector\n    :else :list))", "user": "567c7fefe4b05957ce8c61bc"}, {"problem": 65, "code": "(fn mytype4 [x]\n  (let [emptyx (empty x)]\n    (cond\n      (= emptyx {}) :map\n      (= emptyx #{}) :set\n      ;; (= () [] ) is true ?\n      ;; but == can't cast\n      (= 1  (last (conj emptyx 1 2))) :list\n      (= 2  (last (conj emptyx 1 2))) :vector)))", "user": "561fd32fe4b064ca9f4b16d4"}, {"problem": 65, "code": "#(condp = (conj (empty %) [0 0] [1 1])\n     '([1 1] [0 0])   :list\n     [[0 0] [1 1]]    :vector\n     {1 1, 0 0}       :map\n     #{[0 0] [1 1]}  :set )", "user": "567798afe4b05957ce8c6169"}, {"problem": 65, "code": "(fn [coll]\n  (if (:special-test-name (-> coll (conj [:special-test-name true])))\n    :map\n    (if (= :special-test-name (-> coll (conj :dummy-name) (conj :special-test-name) first))\n      :list\n      (if (< (inc (count coll)) (-> coll (conj :special-test-name) (conj :special-test-name) count))\n        :vector\n        :set))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 65, "code": "(fn [seq]\n    (if (associative? seq)\n      (let [s (conj seq [(gensym) (rand)])]\n        (if (nil? (get s 0)) :map :vector)\n      )\n      (let [i (rand)]\n        (if (< (count (conj seq i)) (count (conj (conj seq i) i)))\n          :list\n          :set\n        ))\n    )\n    )", "user": "5681afaae4b0945ebc182a87"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n   (= (get (conj c :t) :t) :t) :set\n   (= (first (conj (conj c :a) :b)) :b) :list\n   (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "567931e9e4b05957ce8c6184"}, {"problem": 65, "code": "(fn [c] (let [a [:a 1]\n               t #(get (conj c a) %)]\n           (cond (t :a) :map\n                 (t a) :set\n                 (t 0) :vector\n                 1 :list)))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 65, "code": "(fn myclass [r]\n  (if (= (empty r) {})\n    :map\n    (let [tst (conj (empty r) 1 2 2 3)]\n    (cond\n      (= (seq tst) '(1 2 2 3)) :vector\n      (= (seq tst) '(3 2 2 1)) :list\n      (= (sort (seq tst)) '(1 2 3)) :set\n    ))\n  )\n)", "user": "566b8946e4b0a866af6896b0"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (= (get (conj c {:t :t}) :t) :t) :map\n   (= (get (conj c :t ) :t) :t) :set\n   (= (first (conj (conj c :a) :b)) :b) :list\n   (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "566a8600e4b0a866af68969d"}, {"problem": 65, "code": "(fn get-type [x]\n  (let [ex (empty x)\n        ex0 (conj ex [0 2])]\n    (condp = (get ex0 0)\n      [0 2] :vector\n      2 :map\n      nil (let [ex1 (conj ex 0)]\n             (condp = (get ex1 0)\n               nil :list\n               0 :set)))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 65, "code": "#(condp = (first(str %))\n    \\c :list\n    \\[ :vector\n    \\# :set\n    \\{ :map)", "user": "566a3a26e4b0a866af689699"}, {"problem": 65, "code": "#(let [mt-coll (empty %)]\n   (cond (and (= '() mt-coll) (reversible? mt-coll)) :vector\n         (= [] mt-coll) :list\n         (= #{} mt-coll) :set\n         (= {} mt-coll) :map))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 65, "code": "(fn blackbox\n  [coll]\n  (let [coll' (conj coll [:item :item])\n        coll'' (conj coll' [:item :item])]\n    (cond\n      (get coll' :item) :map\n      (= (count coll') (count coll'')) :set\n      (get coll' 0) :vector\n      :otherwise :list)))", "user": "56488119e4b0284900eef632"}, {"problem": 65, "code": "(fn [coll]\n  (let [emptycoll (empty coll)\n        testcoll (conj emptycoll (first emptycoll))]\n     (prn testcoll (count testcoll))\n     (if (= (count testcoll) 0)\n       :map\n       (let [testcoll_1 (conj testcoll (first testcoll))]\n   \t\t (if (= (count testcoll_1) (count testcoll))\n           :set\n           (let [testcoll_2 (conj emptycoll 1)]\n  \t\t\t (if (= (get testcoll_2 0) 1)\n               :vector\n               :list)))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 65, "code": "#(cond\n  (= (get (conj % [:f :s]) :f) :s) :map\n  (= (conj (conj % 10000) 10000) (conj % 10000)) :set\n   (= (first (conj % 9999 10000)) 10000) :list\n   :else :vector)", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 65, "code": "(fn [coll]\n  (let [n (count coll)]\n    (if (not= nil (get (conj coll [:x 1]) :x))\n      :map\n      (if (= (+ n 2) (count (conj coll :x :x)))\n        (if (= (last (conj coll :y :x)) :x)\n          :vector\n          :list)\n        :set))))", "user": "55f85b93e4b03cbcff9738ae"}, {"problem": 65, "code": "(fn black-box-testing [s]\n  (cond\n    (= (conj s {}) s) :map\n    (empty? s) (if (= (clojure.set/union s #{}) #{})\n                 :set\n                 (first (conj s :vector :list)))\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 65, "code": "(fn f [xs]\n  (case (conj (empty xs) [:a 1] [:a 2])\n    {:a 2} :map\n    [[:a 1] [:a 2]] :vector\n    [[:a 2] [:a 1]] :list\n    #{[:a 2] [:a 1]} :set))", "user": "56795deae4b05957ce8c6187"}, {"problem": 65, "code": "(fn [thing]\n  (let [guinea {:guinea :pig} pig {:pig :guinea}]\n    (if (= (count (conj thing guinea guinea)) (inc (count thing)) )\n      (if (contains? (conj thing guinea) guinea)\n        :set\n        :map\n      )\n      (if (= (last (conj thing guinea pig)) pig)\n        :vector\n        :list\n      )\n    )\n  )\n)", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "552d2e4fe4b076ab5578f7e1"}, {"problem": 65, "code": "(fn [coll]\n  (let [first-char (first (pr-str coll))]\n    (cond (= first-char \\{) :map\n          (= first-char \\() :list\n          (= first-char \\[) :vector\n          (= first-char \\#) :set\n          :else (throw (Exception. \"Not a sequence\")))))", "user": "569d4640e4b0542e1f8d147b"}, {"problem": 65, "code": "#(if (empty? (flatten (conj % [0 0])))\n(if (contains? (conj % [1 2]) [1 2]) :set :map)\n(if (= (first (conj % -1 -2)) -2) :list :vector))", "user": "569c40cee4b0542e1f8d1462"}, {"problem": 65, "code": "(fn typeX [x] (let [s (str x)] (case (first s) \\{ :map \\[ :vector \\# :set :list)))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 65, "code": "(fn [c]\n       (if (= (+ (count c) 1) (count (conj c [1 2] [1 3])))\n         :map\n         (let [d (conj c :a) e (conj d :b)]\n          (cond\n            (= (count e) (count (conj e :b))) :set\n            (= (last e) :b) :vector\n            :else :list))))", "user": "5339cb07e4b0e30313ee6caf"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (first (str coll))]\n    (cond\n     (= \\{ c) :map\n     (= \\# c) :set\n     (= \\[ c) :vector\n     :else :list)))", "user": "51441ce7e4b0b4fb4ace5f41"}, {"problem": 65, "code": "#(cond (= (empty %) []) \n       (if (= (conj (conj (empty %) 1) 2) [2 1]) :list :vector)\n       (= (empty %) #{}) :set\n       :else :map)", "user": "5686b7c7e4b0dcc4269f4057"}, {"problem": 65, "code": "; Without the limits on 'catch' this is the most straightforward way\n\n;(fn [sq]\n;\t(first (remove nil? (for [c {clojure.lang.PersistentArrayMap :map \n;\t clojure.lang.PersistentHashSet  \t\t :set \n;\t clojure.lang.PersistentVector   \t\t :vector\n;\t clojure.lang.LazySeq                    :list \n;\t clojure.lang.PersistentList$EmptyList   :list\n;\t clojure.lang.PersistentList\t\t\t :list}]\n;\t\t(try (do (cast (first c) sq) (last c))\n;\t\t\t (catch Exception e nil))\n;    )))\n;)\n\n; Here's a cheap way if we could use pop-thread-bindings\n\n;(fn [sq] ({\\{ :map \\( :list \\[ :vector \\# :set} (first (with-out-str (pr sq)))))\n\n; We can get around this by quoting the name, but casting a LazySeq \n; or PersistentList to a str returns a class name and obj identifier\n; thus we should test that our class begins with either of those.\n\n(fn [sq] \n\t(let [c (str (second `(name ~sq)))]\n\t\t(if (or (.startsWith c \"clojure.lang.LazySeq\") \n\t\t\t\t(.startsWith c \"clojure.lang.PersistentList\"))\n\t\t\t\t:list\n\t\t\t\t({\\{ :map \\( :list \\[ :vector \\# :set} (.charAt c 0))))\n)", "user": "5578f292e4b05c286339e08f"}, {"problem": 65, "code": "(fn [s]\n  (let [s' (into s '([:foo :bar] [:cat :dog]))]\n    (cond\n      (= (:foo s') :bar) :map\n      (= (count s') (count (conj s' [:foo :bar]))) :set\n      (= [:cat :dog] (first s')) :list\n      :else :vector)))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 65, "code": "(fn black-box\n  [c]\n  (if (associative? c)\n    (let [c1 (assoc c 0 5)]\t\t; count test works only on non-empty\n      (if (= (count c1) (count (flatten (seq c1))))\n        :vector\n        :map))\n    (if (= (count (conj c :a)) (count (conj c :a :a)))\n      :set\n      :list)))", "user": "56912f93e4b0dcc4269f40ef"}, {"problem": 65, "code": "(fn [xs]\n  (cond\n    (= (get (conj xs [:x :y]) :x) :y) :map\n    (= (dec (count (conj xs :x :x))) (count xs)) :set\n    (= (first (conj xs :x :y)) :y) :list\n    :else :vector))", "user": "564a5a09e4b0284900eef656"}, {"problem": 65, "code": "#(case (subs (.toString %) 0 1) \"[\" :vector \"#\" :set \"{\" :map :list)", "user": "56824e1be4b0945ebc182a91"}, {"problem": 65, "code": "(fn [e]\n  (condp = (conj (empty e) [1 2] [3 4])\n    {1 2, 3 4}  :map\n    '([3 4] [1 2]) :list\n    #{[1 2] [3 4]} :set\n    [[1 2] [3 4]]  :vector))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 65, "code": "(fn what [s] (let [ss (conj s [(gensym) (gensym)]) x (gensym)] (if (= (conj ss (first ss)) ss) (if (get ss (first ss)) :set :map)  (if (= (first (conj ss x)) x) :list :vector))))", "user": "5646dff3e4b0284900eef615"}, {"problem": 65, "code": "#(cond \n         (not (distinct? (empty %)  {})) :map\n         (not (distinct? (empty %) #{})) :set\n         (= [2 1] (conj (empty %) 1 2)) :list \n         (= [1 2] (conj (empty %) 1 2)) :vector\n         )", "user": "56066e82e4b08b23635d3173"}, {"problem": 65, "code": "(fn [x]\n  (letfn [(my-set? [x]\n                   (= (conj x :x :x)\n                      (conj x :x)))\n\n          (my-vec? [x]\n                   (= (conj x :test1 :test2)\n                      (concat x '(:test1 :test2))))\n\n          (my-list? [x]\n                    (= (conj x :test2 :test1)\n                       (concat '(:test1 :test2) x)))\n\n          (my-map? [x]\n                   (= :test-val\n                      (get (conj x [:test-key :test-val]) :test-key)))]\n    (cond\n      (my-map? x) :map\n      (my-set? x) :set\n      (my-vec? x) :vector \n      (my-list? x) :list)))", "user": "5630ce72e4b0bfe05bf11786"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "56a38a4ce4b0542e1f8d14cc"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 65, "code": "(fn [coll]\n    (let [temp1 [:c 3]\n          temp2 [:c 3]\n          temp3 [:c 4]\n          coll2 (conj coll temp1 temp2 temp3)]\n      (pr coll2)\n      (cond\n        (= (count coll) (- (count coll2) 1)) :map\n        (= (count coll) (- (count coll2) 2)) :set\n        (= (first coll2) temp3) :list\n        :else :vector)))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5607fa34e4b08b23635d3184"}, {"problem": 65, "code": "(fn x [coll]\n   (let [alt (conj coll {:test 1} {:test 1} {:test 2})\n         c (count coll)\n         a (count alt)\n         f (first alt)]\n     (if (= a (+ c 1))\n       :map\n       (if (= a (+ c 2))\n         :set\n       (if (= f {:test 2})\n         :list\n         :vector)))))", "user": "56b15fc8e4b0982f16b37de9"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 65, "code": "(fn guess [coll]\n  (let [init-l (count coll)\n        conjed (into coll [[:test :toto]\n                           [:test :toto]\n                           [:testbis :tata]])\n        conjed-l (count conjed)]\n    (case (- conjed-l init-l)\n      3 (if (= (first conjed) [:testbis :tata]) :list :vector)\n      2 (if (contains? conjed [:test :toto]) :set :map))))", "user": "5617a540e4b06b1bb2182a12"}, {"problem": 65, "code": "#(cond\n    (= #{} (empty %)) :set\n    (= {} (empty %)) :map\n    :else (let [c2 (conj (conj % :first) :second)]\n            (if (= :second (first c2))\n              :list\n              :vector)))", "user": "56a76f36e4b07966d5a8a05b"}, {"problem": 65, "code": "#(cond\n  (get (into % {nil true}) nil) :map\n  (= (conj % 1) (conj % 1 1)) :set\n  (= (conj % :1 :2) (conj (apply list (conj % :1)) :2)) :list\n  :else :vector)", "user": "56bb9ccce4b0f26550335959"}, {"problem": 65, "code": "(fn blackbox [coll]\n  (let [testColl  (conj (empty coll) [:a 1])\n        isMap     (contains? testColl :a)\n        isVector  (contains? testColl 0)\n        isSet     (and (not isMap) (not isVector) (= 1 (count (conj testColl [:a 1]))))]\n        \n        (cond\n          isMap     :map\n          isVector  :vector\n          isSet     :set\n          :else     :list\n        )\n  )\n)", "user": "525b4e8de4b0cb4875a45d0f"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "56bca51ae4b0f26550335963"}, {"problem": 65, "code": "#(let [c (first (str %))]\n  (cond (= c \\#) :set\n        (= c \\{) :map\n        (= c \\[) :vector\n        :else :list))", "user": "5690221ce4b0dcc4269f40e9"}, {"problem": 65, "code": "(fn st [coll]\n  (cond\n    (= (conj coll {}) coll) :map\n    (= (count (conj coll nil nil)) (inc (count coll))) :set\n    (= :def (first (conj coll :abc :def))) :list\n    (= :def (last (conj coll :abc :def))) :vector\n    :default nil))", "user": "56372c3ce4b0bfe05bf117d1"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "56bf4ac0e4b0f26550335985"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (do\n      (println base)\n      (cond\n        (= base {}) :map\n        (= base #{}) :set\n        :else (if (associative? coll) :vector :list)\n        ))))", "user": "569ce6fee4b0542e1f8d146c"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let [k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))] (= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "56bde7d5e4b0f26550335978"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (= :xyz (:abc (conj c [:abc :xyz])))\n   :map\n\n   (= (conj c :xyz) (conj c :xyz :xyz))\n   :set\n   \n   (= :xyz (first (conj c :abc :xyz)))\n   :list\n      \n   (= :xyz (last (conj c :abc :xyz)))\n   :vector))", "user": "5549ff9ae4b0a04f7929956e"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "56c56603e4b05cc29241eea7"}, {"problem": 65, "code": "#(let [c (empty %)]\n  (cond\n    (= c {}) :map\n    (= c #{}) :set\n    (= (first (conj c 1 2)) 1) :vector\n    (= (last (conj c 1 2)) 1) :list))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 65, "code": "#(let [org %1 c (count %1) toextend {111 222} doubleextended (conj (conj org toextend) toextend) d (count doubleextended)] (println doubleextended)\n   (if (= d (inc c)) (if (= nil (doubleextended 111)) :set :map) (let [vl (conj (conj %1 :a) :b)] (if (= :b (first vl)) :list :vector))))", "user": "56a75810e4b0542e1f8d14fc"}, {"problem": 65, "code": ";#({{} :map, #{} :set, [] :vector, '() :list} (empty %))\n\n#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 65, "code": "(fn [coll]\n  (if (not (coll? coll))\n    (throw \"Not a persistent collection!\")\n    (cond ((and associative? reversible?) coll) :vector\n          (associative? coll) :map\n          (not= (+ 2 (count coll))\n                (count (conj coll 0 0))) :set\n          :else :list)))", "user": "5297dcc5e4b02ebb4ef75047"}, {"problem": 65, "code": "#(cond\n   (= % (merge % %)) :map\n   (= (conj % 'a 'a) (conj % 'a)) :set\n   (= (first (conj % 'a 'b)) 'b) :list\n   :else :vector)", "user": "56cd44fde4b0ea9b8538f749"}, {"problem": 65, "code": "(fn [coll]\n  (if (= (get (into coll [[1 \"a\"]]) 1) \"a\")\n    :map\n  (if (= (count (filter #(= \"a\" %) (conj coll \"a\" \"a\"))) 1)\n    :set\n    (if (= (last (conj coll \"a\" \"b\")) \"b\")\n      :vector\n      (if (= (first (conj coll \"a\" \"b\")) \"b\")\n        :list\n        :else)))))", "user": "565b941ce4b068f2fe63dc07"}, {"problem": 65, "code": "(fn [t] (if (= 0 (:x (into t {:x 0}))) :map  (if (= (+ 2 (count t)) (count (into t [0 0]))) (if (= 0 (first (conj t 1 0))) :list :vector) :set)))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 65, "code": "(fn \n  [coll]\n  (condp = (empty coll)\n    {} :map\n    #{} :set \n    () (if (reversible? coll) :vector :list)))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 65, "code": "#(if (associative? %)\n     (let [s (conj % [:a :b])]\n        (if (contains? s :a)\n          :map\n          :vector))\n      (let [n (count %)\n            s (conj % :a :a)]\n        (if (= (count s) (+ n 2))\n          :list\n          :set)))", "user": "56baa68ce4b0f26550335947"}, {"problem": 65, "code": "#(let [base (empty %)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? %) :vector :list)))", "user": "56cccd99e4b0ea9b8538f743"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (:a (conj coll [:a 1])) :map\n   (:a (conj coll :a)) :set\n   (= (-> coll (conj 0) (conj coll) first) coll) :list\n   :else :vector))", "user": "53ee7f2ee4b0d648e757f4cf"}, {"problem": 65, "code": "(fn [s] (let [s (empty s)\n               x1 (-> s (conj [:a :a]) (conj [:b :b]))\n               x2 (conj x1 [:a :a])\n               vec-or-set? (= (first x1) [:a :a])\n               set-or-map? (= 2 (count x2))] \n             (if set-or-map? \n                 (if vec-or-set? :set :map)\n                 (if vec-or-set? :vector :list))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 65, "code": "#({\\c :list \\[ :vector \\# :set \\{ :map} (first (str %)))", "user": "56d80542e4b0ea9b8538f7e1"}, {"problem": 65, "code": "(fn [x] (let [c (first (str x))]\n    (condp = c\n      \\c :list\n      \\{ :map\n      \\# :set\n      \\[ :vector\n     )))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5518df4ce4b06a49daca83ce"}, {"problem": 65, "code": "(fn [s]\n  (let [result (conj (empty s) [1 2] [1 2] [1 3])]\n    (cond\n      (= 1 (count result)) :map\n      (= 2 (count result)) :set\n      (= [1 2] (first result)) :vector\n      :else :list)))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 65, "code": "(fn [a-seq]\n  (let [sq (conj a-seq [:crazy-test-value 42] [:infill-value 234])\n        conjed-first (conj sq (first sq))]      \n  (cond (= 42 (:crazy-test-value sq))\n        :map \n        (= conjed-first sq)\n        :set\n        (= (first sq) (last conjed-first))\n        :vector\n        :default \n        :list)))", "user": "56b6a50ae4b0982f16b37e3c"}, {"problem": 65, "code": "(fn [ls]\n  (let [b (empty ls)]\n    (cond\n     (and (reversible? b) (= b [])) :vector\n     (= b {}) :map\n     (and (= b ()) (not (reversible? b))) :list\n     (= b #{}) :set)))", "user": "56d7f340e4b0ea9b8538f7df"}, {"problem": 65, "code": "(fn [y] (let [x (into y [[:c :u]])]\n          (cond\n           (= y (vec y)) (if (= 999 (-> y (conj 99) (conj 999) last)) :vector :list)\n           (= x (set x)) :set\n           :else :map)))", "user": "56aed78fe4b03c432f187363"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "56c0d92ae4b0839206b9d67e"}, {"problem": 65, "code": "(fn \n  [c] \n  (cond \n   \t(and (associative? c) (not (reversible? c)))       :map\n    (and (associative? c) (reversible? c))             :vector\n    (and (= (+ 2 (count c)) (count (conj c 0 0 ))))            :list\n    (and (not (associative? c)) (not (reversible? c))) :set))", "user": "56e4427ce4b03a7c14b85a4c"}, {"problem": 65, "code": "(fn [c]\n  (case (empty c) \n   {} :map\n   #{} :set\n   (case (last (conj c :first-item :second-item))\n     :second-item :vector\n     :list\n    )\n  )\n)", "user": "551e7267e4b030e6a24d00e9"}, {"problem": 65, "code": "(fn [col]\n  (let [cb (count col)\n        col1 (conj col [:__my 42])\n        col2 (conj col1 [:__my 42])\n        col3 (conj col2 [:__my 43])]\n    (cond\n     (get col1 :__my) :map\n     (= (- (count col2) cb ) 1) :set\n     (= [:__my 43] (last col3)) :vector\n     :else :list\n    )))", "user": "56df254be4b0ca2494a095ea"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond\n     (= e {}) :map\n     (= e '()) (if (reversible? coll) :vector :list)\n     (= e #{}) :set\n    )\n   )\n  )", "user": "56804d03e4b0966858e4d8ec"}, {"problem": 65, "code": "(fn [coll]\n  (let [fixed-coll (conj (empty coll) [:a :b] [:b :a])]\n    (cond\n      (= (:a fixed-coll) :b) :map\n      (= (conj fixed-coll [:a :b]) fixed-coll) :set\n      (= (first fixed-coll) [:b :a]) :list\n      (= (first fixed-coll) [:a :b]) :vector)))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 65, "code": "(fn [c]                                                                    \n  (let [modified (conj (conj c [:a :a]) [:b :b])                                   \n        tests {:map #(= :a (:a %))                                                 \n               :set #(= % (conj % [:a :a]))                                        \n               :list #(= [:b :b] (first %))                                        \n               :vector #(= [:b :b] (last %))}]                                     \n    (some identity (map (fn [[_type f]] (when (f modified) _type)) tests))))", "user": "563536f8e4b0bfe05bf117c5"}, {"problem": 65, "code": "(fn [coll]\n  (let [before (count coll)\n        delta (conj (conj (conj coll {:garbage :can}) {:garbage :pail}) {:garbage :pail})\n        after (count delta)]\n    (cond\n     (= after (+ 1 before)) :map\n     (= after (+ 2 before)) :set\n     (= (first delta) {:garbage :pail}) :list\n     :else :vector)))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 65, "code": "(fn [c]\n   (let\n     [f [:some-key :some-value]\n      c' (conj c f)]\n     (cond\n       (= c' (conj c' f)) (if (= f (get c' f))\n         :set\n         :map)\n       (= (conj (conj c 1) 2) (concat c [1 2])) :vector\n       (= (conj (conj c 1) 2) (concat [2 1] c)) :list)))", "user": "56050f06e4b08b23635d3161"}, {"problem": 65, "code": "(fn [x]\n    (let [newx (conj x [:kookoo :booboo])]\n      (if (not (nil? (get newx :kookoo nil)))\n        :map\n        (let [s [100 500 200 600]\n              bigger (apply (partial conj x) s)\n              asvec (into [] bigger)]\n          (cond (= (reverse (take 4 asvec)) s) :list\n                (= (take-last 4 asvec) s) :vector\n                :else :set)))))", "user": "56eaad95e4b04a395b9a040f"}, {"problem": 65, "code": "(fn rec [x]\n  (let [marker 10000000 e (empty x)]\n    (cond\n      (= {} e) :map\n      (= #{} e) :set\n      (associative? e) :vector\n      \n      (= [] e) :list\n      )))", "user": "56ebe773e4b04a395b9a042a"}, {"problem": 65, "code": "(fn [s](\n  let [\n       i (into s [[100 200] {:200 300}]) \n       j (not (nil?(get i 1))) \n       k (- (count i) (count s)) \n       l (flatten i)\n       m (- (count l) (count s))\n       n (= s (set s))\n   ](\n cond\n (< m 1) (if n :set :map )\n :else (if j :vector :list)\n)\n))", "user": "56039843e4b04bb52996e1be"}, {"problem": 65, "code": "#(let [coll (into % [[:test1 :test2] [:test1 :test2] [:test3 :test4] [:test3 :test4] [:test3 :test5]])] (cond (= (count coll) (+ 3 (count %))) :set (= (count coll) (+ 2 (count %))) :map (= (last coll) [:test3 :test5]) :vector (= (first coll) [:test3 :test5]) :list))", "user": "56e6ef89e4b02e7e935eb6d0"}, {"problem": 65, "code": "(fn gettype [x]\n  (cond \n   (= (set x ) x) :set\n   (= (empty x) {}) :map\n   true\n    (let [changed (conj (conj x \"SENTINEL\") \"SENTINEL2\")]\n      (if (and (= (first changed) \"SENTINEL2\") (= (second changed) \"SENTINEL\"))\n        :list\n        :vector\n      )\n    )\n  )\n)", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 65, "code": "#(cond\n   (get (into % [[::a true]]) ::a)  :map\n   (= (into % [1]) (into % [1 1]))  :set\n   (= ::c (first (conj % ::b ::c))) :list\n   :else                            :vector)", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 65, "code": "(fn [sq]\n  (cond (= #{} (empty sq))\t:set\n        (= {} (empty sq))\t:map\n        (= '() (empty sq))\t(if (= (into (empty sq) (range 2))\n                                   (range 2))\n                              :vector\n                              :list)))", "user": "56f59df1e4b046a417f92075"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (= (get (conj x [:a \"a\"]) :a) \"a\") :map\n   (= (get (conj x :a) :a) :a) :set\n   (= (first (conj (conj x :a) :b)) :b ) :list\n   (= (last (conj (conj x :a) :b)) :b) :vector))", "user": "56f4623ae4b046a417f9205d"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "56d781b3e4b0ea9b8538f7dc"}, {"problem": 65, "code": "(fn [s]\n  (cond\n    (= s (merge s {})) :map\n    (= (conj s :!) (conj s :! :!)) :set\n    (= :Y (last (conj s :X :Y))) :vector\n    (= :Y (first (conj s :X :Y))) :list))", "user": "542a8d07e4b01498b1a71b43"}, {"problem": 65, "code": "(fn seq-type [s]\n  (let [test (conj s [:set \"set\"] [:set \"set\"] [:conj \"conj\"])]\n    (cond\n      (:set test)\n      :map\n      (= 1 (get (frequencies test) [:set \"set\"]))\n      :set\n      (= [:conj \"conj\"] (first test))\n      :list\n      (= [:conj \"conj\"] (last test))\n      :vector\n      :else\n      :unknown)))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 65, "code": "(fn seq-type? [aseq]\n  (letfn [(is-set? [aseq] (let [orig-count (count aseq)\n                                conjed (conj aseq 1 1)]\n                            (= (inc orig-count) (count conjed))))\n          (is-vector? [aseq] (let [unique-marker1 (gensym)\n                                   unique-marker2 (gensym)\n                                   conjed (conj aseq unique-marker1 unique-marker2)]\n                               (condp = unique-marker2\n                                 (first conjed) false\n                                 (last conjed) true)))\n          (is-list? [aseq] (let [unique-marker1 (gensym)\n                                 unique-marker2 (gensym)\n                                 conjed (conj aseq unique-marker1 unique-marker2)]\n                             (condp = unique-marker2\n                               (first conjed) true\n                               (last conjed) false)))\n          (is-map? [aseq] (let [unique-marker (gensym)\n                                pairs-to-conj {:whatever 1 unique-marker 2}\n                                conjed (conj aseq pairs-to-conj)]\n                            (not (or (= pairs-to-conj (first conjed))\n                                     (= pairs-to-conj (last conjed))))))]\n    (cond\n      (is-map? aseq) :map\n      (is-set? aseq) :set\n      (is-list? aseq) :list\n      (is-vector? aseq) :vector)))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 65, "code": "(fn  [coll] \n(let [n (count coll)\n      coll2 (conj (conj (conj coll {:xy :a}) {:xy :a}) {:zz :b})\n      n2 (count coll2)]\n(if (= (+ 3 n) n2) \n(if (= {:zz :b} (last coll2))\n  :vector :list)\n(if (nil? (:zz coll2))\n   :set :map))\n))", "user": "56c4f971e4b05cc29241ee9d"}, {"problem": 65, "code": "(fn [arg]\n   (println arg)\n   (if (= (inc (count arg)) (count (conj arg [:superkey :supervalue] [:superkey :supervalue])))\n    (; set or map, since we added 2 things but count incremented by 1 only\n      if (= :supervalue (:superkey (conj arg [:superkey :supervalue])))\n      :map\n      :set\n       )\n    (; list or vec\n       if\n       (= :no-such-thing-2 (last(conj (conj arg :no-such-thing-1) :no-such-thing-2)))\n       :vector\n       :list\n    ) \n   )\n  )", "user": "56ef11efe4b04a395b9a045b"}, {"problem": 65, "code": "#(->> % empty str first {\\[ :vector \\# :set \\{ :map \\c :list })\n; infact here is a bug for :list, which can be \\( in clojure 1.8.0.\n; c for \"clojure.lang.PersistentList$XXXXXXXX\" in clojure 1.4.0", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond\n      (= {} e) :map\n      (= #{} e) :set\n      (= [1 2] (conj e 1 2)) :vector\n      (= '(1 2) (conj e 2 1)) :list)))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 65, "code": "(fn [coll]\n  (let [added (-> coll (conj [:first \"first\"]) (conj [:second \"second\"]))]\n    (cond\n      (= (get added :first) \"first\") :map\n      (= (get added [:second \"second\"]) [:second \"second\"]) :set\n      (= (last added) [:second \"second\"]) :vector\n      (= (first added) [:second \"second\"]) :list)))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 65, "code": "(fn [s]\n    (let [len (count s)]\n      (cond\n        (= (inc len) (count (conj s [::x ::x] [::x ::y]))) :map\n        (= (inc len) (count (conj s ::x ::x))) :set\n        (= (first (conj s ::x ::y)) ::y) :list\n        (= (last (conj s ::x ::y)) ::y) :vector\n        )))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 65, "code": "(fn [s]\n    (cond (= (empty s) {})  :map\n          (= (empty s) #{}) :set\n          (= (conj (empty s) 1 2) [1 2]) :vector\n          :else :list)\n    )", "user": "56f9392ae4b07572ad1a88ac"}, {"problem": 65, "code": "(fn get-label[x]\n  (letfn [(is-map [y]\n    \t\t(= 2 (count \n                  (conj (empty x) {:a 2 :b 3}))))\n          (is-set [z]\n                  (= 1 (count (conj (empty x) 3 3 3))))\n          ]\n    (cond\n      (is-map x) :map\n      (associative? x) :vector\n      (is-set x) :set\n      :else :list)))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 65, "code": "(fn f [coll] \n   (if (empty? coll)\n   (cond \n     (not (ifn? coll)) :list\n     (= (into {} coll) coll) :map\n     (= (into #{} coll) coll) :set\n     (= (into [] coll) coll) :vector\n     )\n   (f (empty coll))   \n   )\n   )", "user": "56f15eade4b04a395b9a048e"}, {"problem": 65, "code": "(fn [l]\n  (cond\n    (= :mf (:mf (conj l [:mf :mf]))) :map\n    (= (conj l :mf :mf) (conj l :mf)) :set\n    (= (conj l :a :b) (->> l (cons :a) (cons :b))) :list\n    true :vector))", "user": "5703eda3e4b08d47c9778200"}, {"problem": 65, "code": "(fn [l]\n  (let [ls (conj l [1 2])\n        sls (seq ls)\n        fls (flatten ls)]\n   (if (empty? fls)\n     (if (every?\n          #(contains? ls %)\n          sls)\n       :set\n       :map)\n     (if (= (conj ls [3 4])\n            (conj sls [3 4]))\n       :list\n       :vector))))", "user": "51e5a627e4b0efabf93c02db"}, {"problem": 65, "code": "(fn [s]\n  (cond (reversible? s) :vector\n        (= (first (conj (conj s {:my-wtf-key :my-wtf-value}) {:my-wtf-key2 :my-wtf-value2})) {:my-wtf-key2 :my-wtf-value2}) :list\n        (= {:my-wtf-key :my-wtf-value} (last (conj s {:my-wtf-key :my-wtf-value}))) :set\n        :else :map))", "user": "5292feb4e4b0239c8a67af39"}, {"problem": 65, "code": "#(cond (get (conj % [:c 3]) :c) :map\n        (= (count (conj % 1 1)) (+ (count %) 1)) :set\n        (= :a (first (conj % :b :a))) :list\n        :else :vector\n        )", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 65, "code": "(fn black-box [coll]\n  (cond\n    (and (associative? coll) (not (reversible? coll))) :map\n    (and (associative? coll) (reversible? coll)) :vector\n    :else\n      (if (= (count (conj (conj coll 'A) 'A)) (count (conj coll 'A)))\n        :set\n        :list )\n ))", "user": "56f4cedce4b046a417f92063"}, {"problem": 65, "code": "(fn [x]\n  (let [y (empty x)]\n    (case y\n      {} :map\n      #{} :set\n      '() (case (-> y\n                    (conj 1)\n                    (conj 2)\n                    first)\n            1 :vector\n            2 :list))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 65, "code": "#(cond\n    (= 1 (:a (conj % [:a 1]))) :map \n    (< (count (conj % 1 1))\n       (+ 2 (count %))) :set\n    (= '(1 2) (drop (count %) (conj % 1 2))) :vector\n    :else :list)", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 65, "code": "#(cond\n(and (not (reversible? %) ) (associative? %))\n  :map\n(= (inc(count %)) (count (conj (conj % :a) :a)) )\n\t:set\n(and (reversible? %) (associative? %)) \n  :vector\ntrue\n  :list\n )", "user": "51e1c176e4b06a68e693eafb"}, {"problem": 65, "code": "(fn [c]\n  (let [c' (empty c)\n        s' (conj c' [1 2] [1 2])]\n    (if (= 1 (count s'))\n      (if (= 2 (s' 1)) :map :set)\n      (if (= 3 (first (conj s' 3))) :list :vector))))", "user": "560ee566e4b05f002753df57"}, {"problem": 65, "code": "(fn [c] (let [t (empty c)]  (cond\n                              (= {} t)  :map\n                              (= #{} t) :set\n                              (reversible? t) :vector\n                              :else :list)))", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": 65, "code": "(fn [a-seq]\n  (let [a-seq-2 (apply conj a-seq [[1 2] [3 4]])]\n  (cond\n    (empty? a-seq)\n    (cond\n    (and (= (first a-seq-2) (get a-seq-2 (first a-seq-2)))\n          (= a-seq-2 (conj a-seq-2 (first a-seq-2)))) :set\n     (and (nil? (get a-seq-2 (first a-seq-2)))\n          (= (last a-seq-2) (last (conj a-seq-2 (first a-seq-2))))\n          (= (first (conj a-seq-2 (first a-seq-2)))\n             (second (conj a-seq-2 (first a-seq-2))))) :list\n     (= (last (conj a-seq-2 (first a-seq-2))) (first (conj a-seq-2 (first a-seq-2)))) :vector\n     :else :map)\n    (and (= (first a-seq) (get a-seq (first a-seq)))\n         (= a-seq (conj a-seq (first a-seq)))) :set\n    (and (nil? (get a-seq (first a-seq)))\n         (= (last a-seq) (last (conj a-seq (first a-seq))))\n         (= (first (conj a-seq (first a-seq)))\n            (second (conj a-seq (first a-seq))))) :list\n    (= (last (conj a-seq (first a-seq))) (first (conj a-seq (first a-seq)))) :vector\n    :else :map)))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 65, "code": "(fn x [x]\n  (let [y (if (empty? x) (conj x [:a 1]) x) \n        z (conj y [:test :me])\n        k (conj z [:test :me]) ]\n            \n     (if ((complement nil?) (:test z))\n       :map\n      (if (= (count z) (count k))\n        :set\n        (if (= (last z) [:test :me])\n          :vector\n          :list\n          )\n        \n       )\n       \n       \n     )\n            \n            \n   )\n  \n  \n  \n  )", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 65, "code": "#(let [i [1 1]\n       c (conj (conj % [2 2]) i)]\n   (if (= c (seq c))\n     (if (identical? (first c) i) :list :vector)\n     (if (identical? (get (conj c [c c]) c) c) :map :set)))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 65, "code": ";; flengyel's solution to Black Box Testing\n;; https://4clojure.com/problem/65\n(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "56fc0601e4b07572ad1a88db"}, {"problem": 65, "code": "#(let [e (empty %)]\n   (if (= 2 (count (conj e [1 1] [1 1])))\n     (if (= [1 2] (conj e 1 2)) :vector :list)\n     (if (= {} (empty %)) :map :set)\n   )\n )", "user": "5711b532e4b09c608db70449"}, {"problem": 65, "code": "(fn [s]\n   (let [test (empty  s  )]\n     (cond (=  test  {}) :map\n           (= (conj test 1 2) '(2 1)) :list\n           (= (conj test 1 2) [1 2]) :vector\n           (= test #{}) :set\n           )\n\n\n     ))", "user": "56ede653e4b04a395b9a0449"}, {"problem": 65, "code": "(fn black-box-testing [coll]\n  (if (not= (count (conj coll {:a 1} {:a 2}))\n            (+ (count coll) 2))\n    :map   ; it won't work when coll is a set that contains {:a 1} as an element\n    (if (not= (count (conj coll :a :a))\n              (+ (count coll) 2))\n      :set\n      (let [conjed (conj coll :a :b)]\n        (if (= (first conjed) :b)\n          :list\n          :vector)))))\n          ; clearly it won't work if the first element of the original collection is :b", "user": "540c54a7e4b0addc1aec6700"}, {"problem": 65, "code": "(fn [coll]\n  (if-not (coll? coll)\n    nil\n    (cond\n      (and (associative? coll) (reversible? coll)) :vector\n      (associative? coll) :map\n      (= () (empty coll)) :list\n      :else :set)))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 65, "code": ";; weirdest problem ever?\n(fn [coll]\n  (cond \n   (= (empty coll) #{})\n   :set\n\n   (= (empty coll) {})\n   :map\n\n   :else  \n   (if (= (last (conj coll :hello :world)) :world)  \n     :vector\n     :list)))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 65, "code": "(fn [x]\n  (if (empty? x)\n    (cond\n      (identical? x {}) :map\n      (identical? x #{}) :set\n      (identical? x []) :vector\n      (identical? x '()) :list)\n    (let [c (count x)\n          v [(gensym) 1]\n          newx (conj x v v)\n          newc (count newx)]\n      (if (= newc (+ 2 c))\n        (if (= (first newx) v)\n          :list\n          :vector)\n        (if (contains? newx v)\n          :set\n          :map)))))", "user": "571d063ee4b0145328a76272"}, {"problem": 65, "code": "#(let [tests {associative? 3\n              sorted? 7 \n              counted? 15 \n              reversible? 31}\n       check (fn [v] (reduce (fn [s [k i]] (+ s (or (and (k v) i) 0))) 0 tests))]\n  (case (check %)\n    18 :map\n    49 :vector\n    15 (let [v (conj % 0)] (if (= (count v) (count (apply conj v v))) :set :list))\n     0 :list))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 65, "code": "(fn [col]\n  (if (= (empty col) {}) :map\n    (if (= (conj (empty col) 1 2) [1 2]) :vector\n    (if (= (conj (empty col) 1 2) '(2 1)) :list :set))))", "user": "571e5c9ee4b0145328a76290"}, {"problem": 65, "code": "#( let [x (conj % [:aaaaa :bbbbb] )]\n\t(if (= 0 (count (flatten x)))\n\t\t(if (= (count x) (count (conj x [:aaaaa :ccccc]))) :map :set)\n\t\t(if (= :cccccc (first (conj x :cccccc))) :list :vector)\n\t)\n)", "user": "52570aeae4b0541d1855ba42"}, {"problem": 65, "code": "#_(fn [coll]\n            (case (->> coll empty str)\n              \"{}\" :map\n              \"#{}\" :set\n              \"[]\" :vector\n              \"()\" :list\n              :dunno))\n\n(fn [coll]\n            (let [z (empty coll)]\n              (cond\n                (= 1 (count (conj z [1 1] [1 2])))\n                :map\n\n                (= 1 (count (conj z [1 1] [1 1])))\n                :set\n\n                (= [1 1] (first (conj z [1 1] [2 2])))\n                :vector\n\n                (= [2 2] (first (conj z [1 1] [2 2])))\n                :list\n\n                :else :dunno)))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 65, "code": "(fn [coll]\n    (cond\n      (= (set coll) coll) :set\n      (not= (map identity coll) coll) :map\n      (= (last (conj coll nil ::foo)) ::foo) :vector\n      :else :list))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 65, "code": "(fn [s]\n  (let [q (conj (conj (conj s [:a 1]) [:b 2]) [:b 2])]\n    (if (not (nil? (get q :b)))\n      :map\n      (if (<= (count (filter #(= [:b 2] %) q)) 1)\n        :set\n        (if (= (first q) [:b 2])\n          :list\n          :vector)))))", "user": "56f51879e4b046a417f92069"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n     (= base {}) :map\n     (= base #{}) :set\n     (= base '()) (if (reversible? coll)\n                    :vector\n                    :list))))", "user": "562d6fb9e4b0a45d2ff8301c"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (let [test-coll (conj coll [:x :y])] (cond\n                                  (= (get (conj test-coll [:c 3]) :c) 3) :map\n                                  (= (last (into test-coll (range 50 100))) 99) :vector\n                                  (= (first (conj test-coll :c)) :c) :list \n                                  (contains? (conj test-coll :c) :c) :set\n                                   )))", "user": "557e56aae4b05c286339e0d5"}, {"problem": 65, "code": "(fn [c]\n  (let [k (gensym)\n        v1 (gensym) v2 (gensym)\n        cc (into c [[k v1] [k v2]] )]\n    (cond (= (get cc k) v2) :map\n          (get cc [k v1])   :set\n          (= [k v2] (first (vec cc))) :list\n          (= [k v2] (last (vec cc)))  :vector\n          :else :dunno)))", "user": "56102f50e4b05f002753df6b"}, {"problem": 65, "code": "#(let [base (empty %)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? %) :vector :list)))", "user": "571a0a0ae4b07c98581c3b44"}, {"problem": 65, "code": "(fn [s]\n   (cond\n     (= (empty s) {}) :map\n     (= (empty s) #{}) :set\n     (= (empty s) '()) (if (reversible? s) :vector :list)\n   )\n)", "user": "557a2891e4b05c286339e09f"}, {"problem": 65, "code": "(fn [c]\n  (let [t (conj (empty c)\n                [:a :b] [:a :b] [:a :c])\n        n (count t)]\n    (case n\n          1 :map\n          2 :set\n          3 (if (= [:a :b]\n                   (first t))\n              :vector\n              :list))))", "user": "5461dc79e4b01be26fd746a8"}, {"problem": 65, "code": "#(let [r (str %)]\n   (if (.contains r \"#\")\n     :set\n       (if (.contains r \"{\")\n         :map\n         (if (.contains r \"[\")\n           :vector\n           :list))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 65, "code": "(fn black-box [?] ; this is a horrible variable name, but it's funny and this is a code exercise, so there.\n  ;; If duplicates are combined, this is a map or a set.\n  (if (< (count (conj ? [1 2] [1 2])) (+ (count ?) 2))\n    ;; If symbols can be used as indices, this is a map, not a set.\n    (if (= :b (get (conj ? [:a :b]) :a))\n      :map\n      :set)\n    ;; If new elements are added at the beginning, this is a list, not a vector.\n    (if (= :bar (first (conj ? :foo :bar))) ; none of the test cases has a :bar in it so I can get away with this >_>\n      :list\n      :vector)))", "user": "569f99cce4b0542e1f8d1497"}, {"problem": 65, "code": "(fn seq-check [c]\n  (cond (= (inc (count c)) (count (conj c {:test 1} {:test 2}))) :map\n        (= (inc (count c)) (count (conj c {:test 1} {:test 1}))) :set\n        (= :test (last (conj c :a :test))) :vector\n           :else :list ))", "user": "56791447e4b05957ce8c6183"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c {:foo \"bar\"}) :foo ) \"bar\") :map\n  \t(= (get (conj c :foo) :foo) :foo) :set\n  \t(= (first (conj (conj c :foo) :bar)) :bar) :list\n  \t(= (last (conj (conj c :foo) :bar)) :bar) :vector\n\t\n  ))", "user": "57283dbce4b0c5bde472c154"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n    (cond \n      (= empty-coll {}) :map    \n      (and (= (empty coll) ()) (= (last (conj coll 0 10)) 10)) :vector\n      (and (= (empty coll) ()) (= (first (conj coll 0 10)) 10)) :list\n      (= empty-coll #{}) :set)\n  ))", "user": "57042a94e4b0b0fb43fd0660"}, {"problem": 65, "code": "(fn q[x]\n  (\n    if (associative? x)\n      (\n        if \n          (= (count x) (dec (count (conj x [\"O\" \"O\"] [\"O\" \"O\"]))))\n            :map\n            :vector\n      )\n      (\n        if (= (count x) (dec (count (conj x \")_)_)_)_\" \")_)_)_)_\"))))\n          :set\n          :list\n      )\n  )\n)", "user": "5717d674e4b07c98581c3b1a"}, {"problem": 65, "code": "(fn [coll]\n  (let [mod-coll (conj (conj (conj coll [:c 1]) [:c 1]) [:c 2])]\n    (cond \n      (= (- (count mod-coll) (count coll)) 1) :map\n      (= (- (count mod-coll) (count coll)) 2) :set\n      (= [:c 2] (first mod-coll)) :list\n      (= [:c 2] (last mod-coll)) :vector)))", "user": "4df73d64535d04ed9115e775"}, {"problem": 65, "code": "(fn [o] (let [\n\tintovec (= o(into [] o))\n\tintoset (= o(into #{} o))\n\tintolist (= 0(into () o))\n\tassoc (associative? o)\n\ttyp (cond\n\t\t(and (not intovec) (not intoset) (not intolist) assoc) :map\n\t\t(and intovec (not intoset) (not intolist) (not assoc)) :list\n\t\t(and intovec (not intoset) (not intolist) assoc) :vector\n\t\t(and (not intovec) intoset (not intolist) (not assoc)) :set\n\t)\n] typ))", "user": "571aad45e4b07c98581c3b59"}, {"problem": 65, "code": "(fn [seq]\n  (cond\n   (= \"[\" (str (first (str seq)))) :vector\n   (= \"{\" (str (first (str seq)))) :map\n   (= \"#\" (str (first (str seq)))) :set\n   :else :list))", "user": "56cc34aee4b0ea9b8538f73c"}, {"problem": 65, "code": "(fn \n  [x]\n  (cond\n    (= {} (empty x ) ) :map\n    (= :sss (:sss (conj x :sss 6676))) :set\n    (= [:sss 6676] (take-last 2 (conj x :sss 6676 ))) :vector\n    (= 6676 (first (conj x :sss 6676 ))) :list\n    )\n  )", "user": "5602842de4b04bb52996e1a1"}, {"problem": 65, "code": "#(let ;; compare two colections with elements added in reverse order\n[x (into (empty %) [[0 :vector] [0 :derp]]) \ny (into (empty %) [[0 :derp] [0 :vector]]) \n] (case [(count x) (= x y)]\n\t[1 false]\t:map\t;; map has length of 1\n\t[2 true] \t:set\t;; unordered sets are equal\n\t(get-in x [0 1] :list)  ;; (get x 0 ) is nil for non-empty list\n\t)\n)", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 65, "code": "(fn [t] (let [f (first (str t))]\n          \n          (cond\n             (= f \\{) :map\n             (= f \\#) :set\n             (= f \\[) :vector\n             :else :list              \n           )))", "user": "5739cbe4e4b0cd1946bd107c"}, {"problem": 65, "code": "(fn [coll]\n  (let [test (conj (empty coll) [0 :vector] [0 :list] [0 :list])]\n    (case (count test)\n      1 :map\n      2 :set\n      3 (second (first test)))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n     (= {} empty-coll) :map\n     (= #{} empty-coll) :set\n     (reversible? empty-coll) :vector\n     (= () empty-coll) :list)))", "user": "5724a4dae4b0c5bde472c0fe"}, {"problem": 65, "code": "(fn [c]\n  (cond \n   (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n   (= (get (conj c :t) :t) :t) :set\n   (= (first (conj (conj c :a) :b)) :b) :list\n   (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "57297fb2e4b0c6e51e0d2b1c"}, {"problem": 65, "code": "(fn black-box-type [coll]\n  (cond\n    (= (get (conj coll [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj coll :t) :t) :t) :set\n    (= (first (conj (conj coll :a) :b)) :b) :list\n    (= (last (conj (conj coll :a) :b)) :b) :vector))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 65, "code": "(fn [coll]\n    \n    (if (= (rest (cons :b coll )) coll)    \n        (if (= (rest (conj (conj coll :a) :b)) (conj coll :a) ) :list :vector)\n        (let [ cj1 (conj coll [1 1] ) cj2  (conj cj1 [1 2]) ]\n          (if (= (count cj1 ) (count cj2) )  :map :set)\n        )\n    \n    )\n    \n    )", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "573652e1e4b0cd1946bd1030"}, {"problem": 65, "code": "#(cond (= %1 (conj %1 {})) :map\n       (= (conj %1 1 2) (cons 2 (cons 1 %1))) :list\n       (= (conj %1 1 1) (conj %1 1)) :set\n       true :vector)", "user": "57015a1de4b08d47c97781d4"}, {"problem": 65, "code": "(fn [col]\n  (cond\n    (= (empty col) #{}) :set\n    (= (empty col) {}) :map\n    (= (conj (empty col) 1 2) [1 2]) :vector\n    :else :list))", "user": "53a83c74e4b047364c044426"}, {"problem": 65, "code": "#(cond\n   (= (conj % {:a 0}) (conj % {:a 1} {:a 0})) :map\n   (= (conj % 0) (conj % 0 0)) :set\n   (let [a (java.util.UUID/randomUUID)]\n     (= a (first (conj % 'dummy-for-emty-seq a))))\n   :list\n   :else :vector)", "user": "5742bc40e4b05c31a32c087b"}, {"problem": 65, "code": "#(cond (= {} (empty %)) :map\n             (= #{} (empty %)) :set\n             (= '(:b :a) (conj (conj (empty %) :a) :b)) :list\n             (= [:a :b] (conj (conj (empty %) :a) :b)) :vector)", "user": "573ce277e4b05c31a32c080b"}, {"problem": 65, "code": ";(vec (map\n(fn [c]\n  (let [a (conj c {:z 25})]\n  (if (= 25 (:z a)) :map\n   (let [b (reduce conj c '(10 10 25))]\n     (if (<= 2 (->> b (filter (partial = 10)) (count)))\n       (if (= 25 (last b)) :vector :list)\n       :set\n       )))))\n     \n; [{} #{} [] ()]))", "user": "573632b7e4b0cd1946bd102f"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "574af03ce4b02ea114799202"}, {"problem": 65, "code": "#(if (= (vec %) %) \n   (if (= 43 (last (conj (conj % 42) 43))) :vector :list)\n   (if (= (set %) %) :set :map))", "user": "5547b72be4b0a04f79299550"}, {"problem": 65, "code": "(fn [s]\n  (cond (= s (conj s s)) :map\n        (= (conj s 1) (conj (conj s 1) 1)) :set\n        (= (conj (conj s 1) 2) (concat s [1 2])) :vector\n        :else :list))", "user": "57458b82e4b009280f9f2b4e"}, {"problem": 65, "code": "(fn [v]\n  (cond\n   (= (get (conj v {:t \\t}) :t) \\t) :map\n   (= (get (conj v :t) :t) :t) :set\n   (= (first (conj (conj v :f) :t)) :t) :list\n   (= (last (conj (conj v :f) :t)) :t) :vector))", "user": "56efb3a3e4b04a395b9a0463"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond \n     (= e {}) :map\n     (= e [])  (if (reversible? e) :vector :list)\n     (= e #{}) :set\n     :else nil)))", "user": "570794d8e4b0b0fb43fd068b"}, {"problem": 65, "code": "(fn type?\n  [sequ]\n  (cond\n    (reversible? sequ) :vector\n    (associative? sequ) :map\n    (= (count (conj sequ 1 1)) (+ 2 (count sequ))) :list\n    :else :set\n        ))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 65, "code": "#(condp = (empty %)\n  {}  :map\n  #{} :set\n  ()  (if (= (conj (empty %) 1 2) (conj () 1 2)) :list :vector))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (and (associative? coll) (reversible? coll)) :vector\n    (associative? coll) :map\n    (= coll (into #{} coll)) :set\n    :else :list))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 65, "code": "(fn [c]\n    (let [e (empty c)]\n      (cond\n        (= 1 (count (conj e [1 1] [1 9]))) :map\n        (= 1 (count (conj e 1 1))) :set\n        (= 2 (first (conj e 1 2))) :list\n        :else :vector)))", "user": "52e1c276e4b09f7907dd142b"}, {"problem": 65, "code": "(fn detect-type2 [obj]\n  (let [obj (merge obj [1 2])\n        f (first obj)\n        n (count obj)]\n    (if (= (get (merge obj [n obj]) n) obj)\n      :map\n      (if (= (count (conj obj 1 1)) (+ 1 n))\n        :set\n        (if (not= (first (conj obj [f])) f)\n          :list\n          :vector)))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 65, "code": "#(case (empty %) \n   {} :map \n   #{} :set \n   (if (= (conj (empty %) 1 2) [1 2]) :vector :list))", "user": "50d0d2dde4b00b15ecee9768"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 65, "code": "(fn [coll]\n  (case (first (str coll))\n    \\{ :map\n    \\c :list\n    \\[ :vector\n    \\# :set))", "user": "575cbe44e4b02ea114799374"}, {"problem": 65, "code": "(fn bb [c]\n  (letfn [(cv [t]\n            (= c (into t c)))\n          (cva [t]\n            (and (associative? c) (cv t)))]\n    (cond\n      (cva []) :vector\n      (cv #{}) :set\n      (cva {}) :map\n      true :list)))", "user": "508c3d42e4b0f17d83ea26b2"}, {"problem": 65, "code": "(fn check-type [unknown]\n  (let [base (empty unknown)]\n    (cond\n      (= base #{}) :set\n      (= base ()) (if (reversible? unknown) :vector :list)\n      (= base {}) :map\n      )\n    ))", "user": "574ed2f7e4b02ea11479924a"}, {"problem": 65, "code": "#(cond\n    (= #{} (empty %)) :set\n    (= {} (empty %)) :map\n    (associative? %) :vector\n    :else :list)", "user": "573107d5e4b0cd1946bd0fbc"}, {"problem": 65, "code": "#(condp = (first (str %))\n   \\{ :map\n   \\c :list\n   \\[ :vector\n      \\# :set)", "user": "57275898e4b0c5bde472c13e"}, {"problem": 65, "code": "(fn [coll]\n  (case (empty coll)\n    ; List or vector, conj will behave differently\n    [] (let [conjoined2 (conj (empty coll) :first :second)]\n         (case (first conjoined2) \n           :first :vector ; A vector will grow at the end\n           :second :list)); A list grows at the beginning\n    #{} :set\n    {} :map\n    )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 65, "code": "#(cond\n  (= 2 (get (conj % [:a 2]) :a)) :map\n  (= (conj % 1 2) (cons 2 (cons 1 %))) :list\n  (= (conj % 1) (conj % 1 1)) :set\n  :else :vector)", "user": "57642916e4b0994c1922fbee"}, {"problem": 65, "code": "(fn bb [seq]\n  (let [base (empty seq)]\n\n    (cond\n      (= {} base) :map\n      (= #{} base) :set\n      (reversible? base) :vector\n      (= 1 1) :list\n\n    )\n\n\n\n  )\n)", "user": "575ebba3e4b08062f99a4e70"}, {"problem": 65, "code": "(fn [coll]\n   (let [added-val (reduce #(conj %1 %2) coll [[:ertu 1] [:ertu 1] [:ertu 2]])]\n     (cond\n       (= (+ (count coll) 1) (count added-val))\n       :map\n\n       (= (+ (count coll) 2) (count added-val))\n       :set\n\n       (= [:ertu 2] (first added-val))\n       :list\n\n       (= [:ertu 2] (last added-val))\n       :vector)))", "user": "56c60b36e4b05cc29241eead"}, {"problem": 65, "code": "(fn [coll]\n  (if (= (+ (count coll) 2)\n         (count (conj coll [\"a\" \"b\"] [\"a\" \"b\"])))\n    (if (= (first (conj coll [\"a\" \"b\"] [\"a\" \"c\"])) [\"a\" \"c\"])\n      :list\n      :vector)\n    (if (= (+ (count coll) 1) (count (conj coll [\"a\" \"b\"] [\"a\" \"c\"])))\n      :map\n      :set)))", "user": "55aaa36fe4b0988bba2ad94f"}, {"problem": 65, "code": "(fn [thing]\n   (let [str-thing (str (empty thing))]\n   (cond\n \n     (= str-thing \"[]\")  :vector\n     (= str-thing \"{}\")  :map\n     (= str-thing \"#{}\") :set\n     :else :list)))", "user": "52c03baee4b07a9af5792347"}, {"problem": 65, "code": "(fn [coll]\n  (let [is-map? #(= (inc (count %)) (count (conj % [:foo 1] [:foo 2])))\n        is-set? (fn [coll]\n                 (= (conj coll :foo)\n                    (conj (conj coll :foo) :foo)))\n        is-vec? (fn [coll]\n                 (= (conj (into [] coll) :foo :bar)\n                    (into [] (conj coll :foo :bar))))]\n   (cond\n     (is-map? coll) :map\n     (is-set? coll) :set\n     (is-vec? coll) :vector\n     :else :list)\n  ))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 65, "code": "(fn [c]\n   (let [x [:a 1]\n         e (into (empty c) [x x [:b 2]])]\n     (cond\n      (= 1 (:a e)) :map\n      (= 2 (count e)) :set\n      (= x (first e)) :vector\n      :else :list)))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 65, "code": "(fn [x]\n  (let [x (conj x [1 2] [3 4] [5 6])]\n    (if (get (conj x [\"meow\" \"meow\"]) \"meow\")\n      :map           \n      (if (= (conj x 1)\n             (conj (conj x 1) 1))\n        :set    \n        (if (= (first (conj x \"meow\"))\n              \"meow\")\n          :list\n          :vector)))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 65, "code": "(fn [col]\n  (let [ec (empty col)]\n    (cond \n       (identical? ec '()) :list \n       (= ec [])  :vector \n       (= ec {})  :map \n       (= ec #{}) :set)))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 65, "code": "#(if (reversible? %) :vector (case (empty %) {} :map '() :list #{} :set :vector))", "user": "56f974c0e4b07572ad1a88b1"}, {"problem": 65, "code": "(fn testing[seqq]\n  (let[j (first (str seqq))]\n    (cond\n     (= j (char \\{)) :map\n     (= j (char \\#)) :set\n     (= j (char \\[)) :vector\n                  :else :list\n     )))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 65, "code": "(fn [x]\n(let [y (conj (conj (empty x) [1 2]) [1 2])]\n     (if (= 1 (count y))\n         (let [z (conj y [1 3])]\n              (if (= 1 (count z))\n                  :map\n                  :set))\n          (let [z (conj y [1 3])]\n               (if (= (first z) [1 3])\n                   :list\n                   :vector)))))", "user": "57716e11e4b0979f896515b2"}, {"problem": 65, "code": "#(case (empty %) {} :map #{} :set (case (last (conj (empty %) 1 2)) 2 :vector 1 :list))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 65, "code": "(fn [s]\n  (let [fc (first (str s))]\n    (condp = fc\n      \\{ :map\n      \\c :list\n      \\[ :vector\n      \\# :set)))", "user": "53b4bddae4b047364c0444b9"}, {"problem": 65, "code": "(fn mytype [coll]\n\t(let [ec (empty coll)]\n\t\t(if (= {:a 1} (conj ec {:a 1}))\n\t\t\t:map\n\t\t\t(condp = (get (conj ec 1 2) 1)\n\t\t\t\t1 :set\n\t\t\t\t2 :vector\n\t\t\t\tnil :list))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 65, "code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n    (if (= 1 (count result))\n      :map (if (= 2 (count result))\n             :set (if (= [1 3] (first result))\n:list :vector )))))", "user": "56cad309e4b0ea9b8538f720"}, {"problem": 65, "code": "(fn type-detect [obj]\n  (cond\n    (and (associative? obj) (not (reversible? obj)))        :map\n    (and (associative? obj) (reversible? obj))              :vector\n    (= 1 (count (into (empty obj) [:fizz :fizz])))          :set\n    (= :second (first (into (empty obj) [:first :second]))) :list))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 65, "code": "#(let [unknown (str (empty %))]\n    (cond \n      (= unknown \"{}\") :map\n      (= unknown \"#{}\") :set\n      (= unknown \"[]\") :vector\n      :else :list))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 65, "code": "(fn [coll]\n  (let [s (first (str coll))]\n    (cond\n     (= \\{ s) :map\n     (= \\# s) :set\n     (= \\[ s) :vector\n    :else :list)))", "user": "574abbfbe4b02ea114799200"}, {"problem": 65, "code": "(fn black-box [c]\n (let [test ((fn [x] (reduce #(conj % %2) (empty x) [[1 1][1 1][2 2]])) c)]\n   (if (= 3 (count test))\n     (if (= 1 (ffirst test)) :vector :list)\n     (if (contains? test [1 1]) :set :map))))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 65, "code": "(fn [thing]\n  (let [empty-thing (empty thing)]\n    (if (= 2 (count (conj empty-thing [1 1] [1 1])))\n      (if (= [1 2] (conj empty-thing 1 2))\n        :vector\n        :list)\n      (if (= 2 ((conj empty-thing [1 2]) 1))\n        :map\n        :set))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 65, "code": "#(let [c (conj (empty %) [1 2])]\n   (if (empty? (flatten c))\n     (if (nil? (get c 1)) :set :map)\n     (if (= 1 (first (conj (empty c) 1 2))) :vector :list)))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 65, "code": "(fn [x] \n  (let [kakunin {{} :map #{} :set } y (empty x)]\n    (if (contains? kakunin y)\n      (kakunin (empty x))\n      (cond (reversible? y) :vector :else :list)\n      ) \n    )\n  )", "user": "57750460e4b0979f8965160c"}, {"problem": 65, "code": "(fn [coll]\n  (let [x [:hoopy :frood]]\n    \n    ;; If we add x twice, but count increases by only 1\n    ;; the collection must be associative.\n    (if (= (inc (count coll)) (count (into coll [x x])))\n      \n      ;; associative - if coll is a map, the first element of our known \n      ;; sequence will become a key when the sequence is conj-ed to the \n      ;; collection\n      (if (:hoopy (conj coll x))\n        :map\n        :set)\n      \n      ;; sequential - it's important to know where your towel is:\n      ;; if coll is a list, :towel will be added to the front.\n      ;; if coll is a vector, :towel will be a added to the back.\n      ;; It's necessary to conj two items so first and last aren't\n      ;; referring to the same item.\n      (if (= :towel (first (conj (conj  coll :zarquod) :towel)))\n      \t:list\n      \t:vector))))", "user": "577c7f46e4b0c8d87281f6c0"}, {"problem": 65, "code": "(fn seqtest [xs]\n   (let [xs1 (conj xs [:a 1])]\n     (if (empty? (flatten xs1)) \n       (if (= (xs1 :a) 1) :map :set)\n       (if (= (take 2 (conj xs :a :b)) '(:b :a)) :list :vector))))", "user": "57780e4fe4b0979f89651657"}, {"problem": 65, "code": "(fn solve [s]\n  (condp = (empty s)\n    {}  :map\n    #{} :set\n    ()  (if (reversible? s) :vector :list)))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 65, "code": "#(let [x (empty %)\n       y (conj x [1 1] [1 2] [1 2])\n       c (count y)]\n   (cond (= 1 c) :map\n         (= 2 c) :set\n         (= [1 1] (first y)) :vector\n         :else :list))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 65, "code": "(fn __ [x]\n\t(let [is (fn [y](= y (set y)))\n\t\t  im (fn [y](not= y (vec y)))\n\t\t  iv (fn [y](= (reverse (conj y 1 2)) (conj (reverse y) 1 2)))]\n\t\t(if (is x)\n\t\t\t:set\n\t\t\t(if (im x)\n\t\t\t\t:map\n\t\t\t\t(if (iv x)\n\t\t\t\t\t:vector\n\t\t\t\t\t:list\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)", "user": "575dda55e4b02ea11479938c"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5652dd89e4b0f9d632dd8469"}, {"problem": 65, "code": "(fn [sq]\n  (if (associative? sq)\n    (if \n      (= (take (count sq) sq) sq)\n      :vector\n      :map)\n    (let [x1 (conj sq :a)\n          x2 (conj x1 :a)]\n      (if (= x1 x2) \n        :set\n        :list))))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 65, "code": "(fn [c]  (let [c2 (conj (empty c ) [::x ::y] [::x ::y] [::x ::z] [::y ::x]) \n           n (count c2) ]\n           (cond \n             (= n 4 ) ; list or vector\n               (if (= (ffirst c2) ::x)\n                 :vector\n                 :list)\n             (= n 2 )  :map\n             :else :set)))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 65, "code": "#(let [x (conj % [:a 1] [:a 1])]\n   (cond\n     (= 1 (:a x)) :map\n     (<= (count x) (+ (count %) 1)) :set\n     (nil? (get x 0)) :list\n     :else :vector))", "user": "577fa91ee4b0d36ec5835e6a"}, {"problem": 65, "code": "(fn [coll]\n    (let [a    (keyword (gensym))\n          b    (keyword (gensym))\n          tst1 (conj coll [a b])\n          tst2 (conj coll [a a] [b b])]\n      (cond\n        (= (get tst1 a) b)         :map\n        (= (conj tst1 [a b]) tst1) :set\n        (= (first tst2) [b b])     :list\n        :else                      :vector)))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 65, "code": "(fn [o]\n  (if (empty? o)\n    (recur (conj o [:k 1]))\n    (if (= (count o) (count (conj o (first o)))) ; a set or map\n      (if (nil? (get o (first o))) ; a map\n        :map\n        :set)\n      (if (= :t (first (conj o :t)))\n        :list\n        :vector))))", "user": "577832f4e4b0979f8965165b"}, {"problem": 65, "code": "(fn [e]\n  (let [temp (empty e)]\n    (cond\n      (= temp {})  :map\n      (= temp #{}) :set\n      :else (if (reversible? temp) :vector :list))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5776558ee4b0979f89651633"}, {"problem": 65, "code": "(fn [coll]\n  (if (nil? coll)\n      :nil\n      (let [a [:a 1]\n            ap [:a 2]\n            b (conj coll a)\n            m (count b)\n            c (conj b ap)\n            n (count c)]\n        (cond (= n m)\n              :map\n              (= (count (conj c a))\n                 n)\n              :set\n              (= (first c) ap)\n              :list\n              :else\n              :vector))))", "user": "55b6a63ae4b01b9910ae299b"}, {"problem": 65, "code": "(fn [coll]\n  (cond \n   (= [:key :val] (get (conj coll [:key :val]) [:key :val])) :set\n   (= :val (get (conj coll [:key :val]) :key)) :map\n   (= :el (get (conj coll :el) (count coll))) :vector\n   (= :el (first (conj coll :el))) :list\n   )\n  )", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 65, "code": "#(cond\n  (and (associative? %) (reversible? %)) :vector\n  (associative? %) :map\n  (= (+ 2 (count %)) (count (conj (conj % :are-you-a-list?) :are-you-a-list?))) :list\n  :default :set)", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 65, "code": "(fn[coll]\n\t  (let [obj (new Object)]\n\t    (let [x (conj coll [1 2])]\n\t      (cond\n\t        (empty? (flatten x)) (if (associative? x) :map :set)\n\t        (= (first (conj x obj)) obj) :list\n\t        :else :vector\n\t      )\n)))", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 65, "code": "(fn [s] (let [seq' (conj s [:a 'a]) sym [:a 'a] ] \n  (if (= seq' (seq seq'))\n    (if (= 1 (count seq')) (if (= 'a (first (conj seq' 'a)))  :list :vector) (if (= sym (first seq')) :list :vector))\n    (if (= 'a (get seq' :a)) :map :set)\n)))", "user": "57915ba4e4b0ebec4cfb75ba"}, {"problem": 65, "code": "(fn [x]\n  (let [x (conj x [1 2] [3 4] [5 6])]\n    (if (get (conj x [\"meow\" \"meow\"]) \"meow\")\n      :map           \n      (if (= (conj x 1)\n             (conj (conj x 1) 1))\n        :set    \n        (if (= (first (conj x \"meow\"))\n              \"meow\")\n          :list\n          :vector)))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 65, "code": "(fn sol [coll]\n  (let [x (conj coll {:c 1} {:c 1} {:d 2})]\n    (println x)\n    (cond\n      (and (= (count x) (+ (count coll) 2)) (= (x {:c 1}) {:c 1})) :set\n      (and (= (count x) (+ (count coll) 2)) (= (x :c) 1)) :map\n      (= (first x) {:d 2}) :list\n      (= (last x) {:d 2}) :vector)))", "user": "578b140be4b0ebec4cfb7545"}, {"problem": 65, "code": "(fn\n  [el]\n  (let [is-class (fn [^Class c] (. c (isInstance el)))]\n  \t(if (is-class clojure.lang.PersistentArrayMap) :map\n      (if (is-class clojure.lang.PersistentVector) :vector\n        (if (is-class clojure.lang.PersistentHashSet) :set :list)))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 65, "code": "(fn [x]\n  (let [x (conj x [1 2] [3 4] [5 6])]\n    (if (get (conj x [\"meow\" \"meow\"]) \"meow\")\n      :map           \n      (if (= (conj x 1)\n             (conj (conj x 1) 1))\n        :set    \n        (if (= (first (conj x \"meow\"))\n              \"meow\")\n          :list\n          :vector)))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 65, "code": "(fn [v]\n  (case (empty v)\n    {} :map\n    #{} :set\n    [] (if (= (last (conj (conj v 1) -1)) -1) :vector :list)))", "user": "578fc072e4b0ebec4cfb759a"}, {"problem": 65, "code": "(fn [x]\n  (let [\n    r 0\n    is-map (fn [y] (= (count (conj y [r r])) (count (conj y [r r] [r (+ r 1)]))))\n    is-set (fn [y] (= (count (conj y r)) (count (conj y r r))))\n    is-vector (fn [y] (= r (last (conj (conj y (+ r 1)) r))))\n    is-list (fn [y] (= r (first (conj (conj y (+ r 1)) r))))\n    ]\n    (some (fn [[k v]] (when (k x) v)) {is-map :map, is-set :set, is-vector :vector, is-list :list})))", "user": "57717915e4b0979f896515b3"}, {"problem": 65, "code": "(fn [container]\n  (cond\n    (not (nil? (:a (conj container [:a :a])))) :map\n    (= (count (conj container [:a :a] [:a :a])) (+ 1 (count container))) :set\n    (= [:b :a] (first (conj container [:a :b] [:b :a]))) :list\n    (= [:b :a] (last (conj container [:a :b] [:b :a]))) :vector\n    :else :other))", "user": "57147cd9e4b07c98581c3abf"}, {"problem": 65, "code": ";; While there are definitely shorter solutions, this ones does involve understanding behavior\n(fn [coll]\n  (let [sample (map #(apply vector %) (partition 2 (range 100)))\n        blank (empty coll)]\n    (cond\n     (= (into blank sample) (into [] sample)) :vector\n     (= (into blank sample) (into {} sample)) :map\n     (= (into blank sample) (into #{} sample)) :set\n     :else :list)))", "user": "573118ebe4b0cd1946bd0fbd"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (reduce #(conj %1 (vector %2 (inc %2))) (empty coll) (range 10)) \n        v (reduce #(conj %1 (vector %2 (inc %2))) [] (range 10)) \n        l (reduce #(conj %1 (vector %2 (inc %2))) () (range 10)) \n        m (reduce #(conj %1 (vector %2 (inc %2))) {} (range 10)) \n        s (reduce #(conj %1 (vector %2 (inc %2))) #{} (range 10))]\n    \n    (cond (= e v) :vector\n          (= e l) :list\n          (= e m) :map\n          (= e s) :set )))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 65, "code": "#(condp = (first (str %))\n     \\c :list\n     \\{ :map\n     \\# :set\n     \\[ :vector)", "user": "576b4e6be4b0a07e8fc1812b"}, {"problem": 65, "code": "(fn black-box-testing [x]\n  (cond\n    (reversible? x) :vector\n    (associative? x) :map\n    (= x (set x)) :set\n    :else :list)\n  )", "user": "570ab24fe4b0b0fb43fd06b7"}, {"problem": 65, "code": "#(letfn \n  [ \n  (isSet [x]  \n      (=\n              (count (into x x))  (count x)\n      )\n   ) \n(isMap [x]  \n      (=\n              (get x 10000) 1\n      )\n   ) \n  (isVector [x]  \n      (=\n        (first (conj (conj x 1) 2)) (first x)     \n      )\n   ) \n  ]\n  (cond\n    (isMap (into % [[10000 1]]))  :map\n    (isSet (into % [[1 1]]))  :set\n    (isVector (into % [[1 1]])) :vector\n     :else :list\n  )\n)", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 65, "code": "(fn which? [sq]\n  (let [[o1 o2 o3 o4] (repeatedly #(Object.))\n   s (conj sq [o1 o2][o3 o4])]\n   (cond (get s [o3 o4]) :set\n              (= o4 (get s o3)) :map\n              (= [o3 o4] (last s)) :vector\n              (= [o3 o4] (first s)) :list\n              :else nil)))", "user": "56903cb9e4b0dcc4269f40eb"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (empty coll)]\n    (condp = c\n      {} :map\n      #{} :set\n      (condp = (first (conj c 1 2))\n        1 :vector\n        2 :list))))", "user": "530e75d5e4b08068f379ecba"}, {"problem": 65, "code": ";;#(keyword (clojure.string/lower-case (clojure.string/replace (clojure.string/replace (:declaring-class (first (:members (clojure.reflect/reflect %)))) #\"clojure.lang.Persistent\" \"\") #\"\\$.*\" \"\")))\n#(if (= 0 (count (flatten (conj % [99 101]))))\n\t(let [fof (first (first (merge % {1 2})))]\n\t\t(if (coll? fof) \n\t\t\t:set\n\t\t\t:map))\n\t(if (= 101 (first (conj (conj % 99) 101)))\n\t\t:list\n\t\t:vector))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 65, "code": "(fn f [coll]\n  (cond\n    (reversible? coll) :vector\n    (associative? coll) :map\n    (not (ifn? coll)) :list\n    :esle :set))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (let [y (into x [[:magic true]])] (:magic y)) :map\n   (let [y (filter (partial = :magic) (conj x :magic :magic))] (= (count y) 1)) :set\n   (let [y (conj x 1 1 :magic)] (= :magic (first y))) :list\n   :else :vector))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll (empty coll)\n        map-test (-> coll (conj [:x 1]) (conj [:x 2]))\n        set-test (-> coll (conj [:x :y]) (conj [:x :y]))]\n   (cond\n    (= 1 (count map-test)) :map\n    (= 1 (count set-test)) :set\n    (= [:x 1] (first map-test)) :vector\n    :else :list)))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 65, "code": "(fn seq-type [s]\n  (cond\n    (= (get (conj s [0 666]) 0) 666)\t\t\t\t:map \n    (= (conj s [0 123]) (conj s [0 123] [0 123]))\t:set\n    (= (first (conj s [0 123] [1 666])) [1 666])\t:list\n    (= (last (conj s [0 123] [1 666])) [1 666])\t\t:vector\n    :else \t\t\t\t\t\t\t\t\t\t\t:whatever))", "user": "57acbe5fe4b0b8559636fc8e"}, {"problem": 65, "code": "#(let [what (conj % [::foo \"bar\"])]\n   (if (get what ::foo)\n     :map\n     (let [what' (-> what (conj ::a) (conj ::b) (conj ::a) (conj ::b))]\n       (if (= 2 (- (count what') (count what)))\n         :set\n         (if (= ::b (first what'))\n           :list\n           :vector)))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 65, "code": "(fn [coll]\n  (let [flat-coll (flatten (vec coll))]\n    (cond (and (even? (count flat-coll))\n               (= (apply hash-map flat-coll) coll)) :map\n          (= (cons 2 (cons 1 coll)) (conj (conj coll 1) 2)) :list\n          (= coll (set coll)) :set\n          :else :vector\n          )))", "user": "57a9e274e4b0b8559636fc5d"}, {"problem": 65, "code": "#(let [x (conj % {:b 1} {:a 1} {:a 1})]\n  (cond\n    (= 1 (get x :a)) :map\n    (= {:a 1} (get x {:a 1})) :set\n    (= {:a 1} (first x)) :list\n    (= {:a 1} (last x)) :vector))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 65, "code": "(fn [c] (let [k (keyword (gensym))\n              v1 (gensym)\n              v2 (gensym)\n              p1 [k v1]\n              p2 [k v2]\n              t (conj c p1 p2)\n              f (first t)\n              l (last t)]\n          (cond\n            (= (count t) (+ 1 (count c))) :map\n            (= t (conj c p2 p1)) :set\n            (= p2 f) :list\n            (= p2 l) :vector)))", "user": "515cf9b5e4b00901442db1d4"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "57af249fe4b0fbc9809a272b"}, {"problem": 65, "code": "(fn [s]\n   (cond (-> s empty (conj {:a 1}) :a (= 1)) :map\n         (-> s empty (conj 1) (conj 1) count (= 1)) :set\n         (-> s empty (conj 1) (conj 2) first (= 2)) :list\n         (-> s empty (conj 1) (conj 2) last (= 2)) :vector\n         :else nil))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 65, "code": "(fn [x]\n  (if (= x (vec x))\n      (if (get (conj x 0) 0) :vector :list)\n      (if (get (conj x [0 0]) 0) :map :set)))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "57af41bce4b0fbc9809a2731"}, {"problem": 65, "code": "(fn [x]\n   (cond\n     (= x (conj x (:c 3))) :map\n     (= :d (first (conj x :c :d))) :list\n     (= :c (get (conj x :c :d) :c)) :set\n     :else :vector))", "user": "5047782ce4b0371827a27bc2"}, {"problem": 65, "code": "(fn my-type [x]\n  (if (= (count (conj x [x 1] [x 1])) (+ 2 (count x)))\n    (if (= (last (conj (conj x [x]) x)) x)\n      :vector\n      :list)\n    (if (= (into #{} x) x)\n      :set\n      :map)))", "user": "57b99d48e4b0fbc9809a27f2"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "57a1ef58e4b0c3d858beb8f3"}, {"problem": 65, "code": "(fn my-type? [coll]\n  (letfn [(count-diff [coll1 coll2] (- (count coll1) (count coll2)))\n  \t\t  (conj-diff [coll f] (count-diff coll (f coll)))]\n  \t(if (= 0 (conj-diff (conj coll [1 1]) #(conj % [1 1])))\n  \t\t(if (contains? (merge coll {}) {}) \n  \t\t\t:set\n  \t\t\t:map)\n  \t\t(let [v (gensym)]\n  \t\t\t(if (= (last (conj (conj coll 1) v)) v)\n  \t\t\t\t:vector\n  \t\t\t\t:list)))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "579332c2e4b0e215f87e8452"}, {"problem": 65, "code": "(fn lookup-type [obj]\n  (let [a      [1 1]\n        result (conj obj a)]\n    (cond\n     (and (not (associative? obj)) (= (conj result a) result)) :set\n     (and (associative? obj) (identical? (conj result a) result)) :map\n     (and (not (associative? obj)) (identical? (first result) a)) :list\n     (and (associative? obj) (identical? (last result) a)) :vector\n     :else (throw (IllegalArgumentException. \"Unknown collection type!\")))))", "user": "578f8a0ae4b0ebec4cfb7596"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "57bd960fe4b05aa3c4741c52"}, {"problem": 65, "code": "(fn tipe [s]\n  (let [sym1  (gensym) sym2 (gensym) \n\t\tsym3  (gensym) s12  (conj s {sym1 sym2}) \n        s1221 (conj (conj s {sym2 sym1}) s12)]\n  (if (get s12 sym1) :map\n      (if (get s12 {sym1 sym2}) :set      \n          (if (= (first s1221) s12) :list :vector)))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 65, "code": "(fn [c]\n  (let [e (empty c)]\n    (cond\n      (= e {})  :map\n      (= e #{}) :set\n      (= e '()) (if (reversible? e) :vector :list))))", "user": "57c7a8b5e4b05aa3c4741d09"}, {"problem": 65, "code": "(fn z [s]\n  (let [q1 (conj s [:x 2]), q2 (conj q1 [:x 2]),\n        q3 (conj q2 [:x 3])] \n       (cond (= (count q1) (count q3)) :map\n             (= (count q1) (count q2)) :set\n             (= [:x 3] (last q3))      :vector\n             :else                     :list)))", "user": "572ac718e4b0f4d77e651242"}, {"problem": 65, "code": "(fn [col]\n\n  (let [c0 (count col)\n        a (gensym)\n        aa {a a}\n        ab {a (gensym)}]\n   (cond \n     (= (inc c0) (count (conj col aa ab))) :map\n     (= (inc c0) (count (conj col ab ab))) :set\n     (= aa (first(conj col ab aa))) :list\n     :else :vector)))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 65, "code": "(fn colltype [coll]\n  (cond\n   (reversible? coll) :vector\n   (= coll (conj coll '())) :map\n   (= coll (concat coll '())) :list\n   :else :set\n  )\n )", "user": "57cf03c0e4b00451144b04f9"}, {"problem": 65, "code": "(fn f [x]\n  (cond\n    (= x (set x)) :set\n    (empty? (flatten (into (empty x) [[:a :b]]))) :map\n    true (case (first (conj (empty x) 1 2))\n           1 :vector\n           2 :list)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 65, "code": "#(cond\n   (= (empty %) #{}) :set\n   (= (empty %) {}) :map\n   :else (let [sym (gensym)\n               sym2 (gensym)]\n           (if (= sym (first (conj (conj % sym2) sym)))\n             :list\n             :vector)))", "user": "57155980e4b07c98581c3ad7"}, {"problem": 65, "code": "(fn [n]\n  (let [tv1 {:t -1} tv2 {:s -2} m (conj n tv1 tv2)]\n    (cond\n      (= -1 (get m :t)) :map\n      (= tv1 (get m tv1)) :set\n      (= tv2 (first m)) :list\n      (= tv2 (last m)) :vector\n      )))", "user": "57b35a19e4b0fbc9809a277d"}, {"problem": 65, "code": "(fn stest\n  [xs] \n  (let [ns (conj xs [:a 5]) \n            \n           \n           fc (count (flatten ns))\n           ls (conj ns [:b 6])\n           fe (first ls)] \n    (if (= 0 fc)\n        (let [m (:a ns)\n                 s (contains? ns [:a 5])\n                 ] (cond\n                    m :map\n                    s :set)) \n      (if (= fe [:b 6]) \n          :list\n        :vector)\n      )\n    )\n  )", "user": "57c6aa0be4b05aa3c4741cf7"}, {"problem": 65, "code": "(fn typify [xs]\n  (let [k 0\n        cm (conj xs xs)\n        qm (count cm)\n        qxs (count xs)]\n    (if (= qm qxs) :map\n      (let [ck (conj xs k)\n            ckk (conj ck k)\n            qk (count ckk)]\n        (if (< qk (+ qxs 2)) :set\n         (let [cmk (conj cm k)\n               h (first cmk)]\n           (if (= h k) :list :vector)))))))", "user": "57d1d6c8e4b0bd073c202370"}, {"problem": 65, "code": "#(case (associative? %1)\n   true (case (reversible? %1)\n          true :vector\n          false :map)\n   false (cond\n          (= (-> %1 count inc) (count (conj %1 1 1))) :set\n          :default :list))", "user": "57c94c6ee4b05aa3c4741d2d"}, {"problem": 65, "code": "#(condp = (nth (str %) 0)\n   \\{ :map\n   \\c :list\n   \\[ :vector\n   \\# :set)", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 65, "code": "(fn\n  [coll]\n  (let [mcoll (conj (conj (conj coll [1 2]) [1 2]) [3 4])]\n    (if (= (+ 3 (count coll)) (count mcoll))\n      (if (and (= (first mcoll) [3 4]) (= (first (rest mcoll)) [1 2]))\n        :list\n        :vector)\n      (if (= (get mcoll 3) 4)\n        :map\n        :set))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 65, "code": "(fn seq-type [values]\n  (let [k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))]\n    (cond\n      (= (get (conj values [k v]) k) v) :map\n      (= (take-last 2 (conj (conj values k) v)) [k v]) :vector\n      (= (conj (conj values k) k) (conj values k)) :set      \n      :default :list)))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 65, "code": "(fn bbt \n  [obj]\n  (if ( = (count (conj obj nil)) (count (conj obj (first obj) nil)))\n    ;set or map\n    (if (= (count (conj obj [1 2] [1 3])) (count (conj obj [1 2])))\n      :map\n      :set)\n    ;list or vector\n    (if (= (conj obj :a :b) (cons :b (cons :a obj )))\n      :list\n      :vector)\n  ))", "user": "4f4aa932e4b0d56e7bb92c14"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n:else :vector))", "user": "57c0393be4b05aa3c4741c90"}, {"problem": 65, "code": "(fn lookup-type [obj]\n  (let [a      [1 1]\n        result (conj obj a)]\n    (cond\n     (and (not (associative? obj)) (= (conj result a) result)) :set\n     (and (associative? obj) (identical? (conj result a) result)) :map\n     (and (not (associative? obj)) (identical? (first result) a)) :list\n     (and (associative? obj) (identical? (last result) a)) :vector\n     :else (throw (IllegalArgumentException. \"Unknown collection type!\")))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 65, "code": "(fn [c]\n  (let [c (empty c)]\n    (cond\n      (= {} c) :map\n      (= #{} c) :set\n      (= (first (conj c :a :b)) :b) :list\n      :else :vector)))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 65, "code": "(fn [s]\n    (let [test [\"test\" \"test\"]\n          test2 [\"test2\" \"test2\"]\n          with-test (-> s (conj test2) (conj test) (conj test))]\n      (cond\n        (= (count s) (- (count with-test) 2)) (if (= \"test\" (get with-test \"test\")) :map :set)\n        (= (first with-test) test) :list\n        (= (last with-test) test) :vector)))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 65, "code": "(fn [thing]\n  (let [one (conj (empty thing) [:c 4])]\n    (condp = one\n      {:c 4} :map\n      [[:c 4]] (if (= [1 2] (conj (empty thing) 1 2)) :vector :list)\n      #{[:c 4]} :set)))", "user": "5785c1d4e4b0ebec4cfb74e1"}, {"problem": 65, "code": "(fn colltype [coll]\n  (if (not= (count (conj coll [:x 1] [:x 2])) (+ 2 (count coll)))\n    :map\n    (if (not= (count (conj coll :x :x)) (+ 2 (count coll)))\n      :set\n      (if (= (last (conj coll :x :y)) :y)\n        :vector\n        :list))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 65, "code": "(fn typify [seq]\n  (let [e (empty seq)\n        ea (conj e [:a 42])]\n\n    (if (zero? (count (flatten ea)))\n      (if (nil? (:a ea))\n        :set\n        :map)\n      (let [eab (conj ea :b)]\n          (cond\n            (= :b (first eab))\n            :list\n\n            (= :b (last eab))\n            :vector\n\n            :default :hmmm)))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 65, "code": "(fn \n  [coll]\n  (let [c (count coll)]\n    (cond\n      (= coll (into #{} coll)) :set\n      (and\n        (= coll (into [] coll))\n        (= (nth (conj coll :a :b) c) :a)\n        (= (nth (conj coll :b :a) c) :b)) :vector\n      (and\n        (= coll (into [] coll))\n        (= (conj coll :a) (cons :a coll))\n        (= (conj coll :b) (cons :b coll))) :list\n      (assoc coll :a 1) :map\n      :else :unknown)))", "user": "56bb652ae4b0f26550335953"}, {"problem": 65, "code": "(fn [c]\n  (cond \n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 65, "code": "#(let [x (first (print-str %))]\n   (case x\n     \\{ :map\n     \\( :list\n     \\[ :vector\n     \\# :set))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 65, "code": "(fn which [coll]\n  (let [coll (conj (empty coll) [:a :b] [:a :b] [:c :d])]\n    (if (= 2 (count coll))\n      (if (coll [:a :b]) :set :map)\n      (if (= [:a :b] (first coll)) :vector :list))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 65, "code": ";; I paid too much attention on the behaviours of the different data types\n;; Using the empty function would have been far simpler and more elegant\n(fn [s]\n    (let [k (keyword (str (rand-int Integer/MAX_VALUE)))\n          v1 (rand-int Integer/MAX_VALUE)\n          v2 (- v1 5)\n          s1 (conj (conj s [k v1]) [k v1])\n          a-vec? (fn [o1 o2]\n                   (and (= (+ (count o1) 2) (count o2))\n                        (= (first o2) (first (conj o2 [k v2])))))\n          a-list? (fn [o1 o2]\n                    (and (= (+ (count o1) 2) (count o2))\n                         (= (last o2) (last (conj o2 [k v2])))))\n          a-set? (fn [o1 o2]\n                   (and (= (+ (count o1) 1) (count o2))\n                        (not= (count o2) (count (conj o2 [k v2])))))\n          a-map? (fn [o1 o2]\n                   (and (= (+ (count o1) 1) (count o2))\n                        (= (count o2) (count (conj o2 [k v2])))))]\n      (cond \n        (a-vec? s s1) :vector\n        (a-list? s s1) :list\n        (a-set? s s1) :set\n        (a-map? s s1) :map\n        :default :unknown)))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "57ed2574e4b0bfb2137f5b93"}, {"problem": 65, "code": "(fn [input]\n  (case (first (str input))\n    \\{ :map\n    \\c :list\n    \\# :set\n    \\[ :vector))", "user": "574e84e0e4b02ea114799243"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "57e016dce4b0bd073c202470"}, {"problem": 65, "code": "(fn [c] \n\t(cond\n\t\t(= (:k (conj c {:k :v})) :v) :map\n\t\t(<= (- (count (conj c :x :x)) (count c)) 1) :set\n\t\t(= (second (conj c :x :v)) :x) :list\n\t\t:else :vector))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 65, "code": "#(if (nil? (:a (conj % {:a 1})))\n    (if (nil? (get (conj % :a) :a))\n      (if (= :b (first (conj % :a :b)))\n        :list\n        :vector)\n      :set)\n    :map)", "user": "576df252e4b0979f8965156f"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (re-find #\"^#\\{\" (str x)) :set\n   (re-find #\"^\\{\" (str x)) :map\n   (re-find #\"^\\[\" (str x)) :vector\n   :else :list\n   ))", "user": "57e20474e4b0bfb2137f5a82"}, {"problem": 65, "code": "(fn\n  [x]\n  (cond\n    (= (inc (count x)) (count (conj x {:jamban 1} {:jamban 2}))) :map\n    (= (inc (count x)) (count (conj x {:jamban 1} {:jamban 1}))) :set\n    (= (last (conj x :taek :jamban)) :jamban) :vector\n    :else :list))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 65, "code": "(fn [coll]\n  (if (= (empty coll) {})\n    :map\n    (if (= (empty coll) #{})\n      :set\n      (if (= (first (conj (conj coll :aaaa) :sentinel)) :sentinel)\n        :list\n        :vector))))", "user": "566b57e9e4b0a866af6896ad"}, {"problem": 65, "code": "(fn typeofc [t]\n  (let [c (empty t)]\n  (cond\n    (= (into c [[1 1] [2 2]]) '([2 2][1 1])) :list\n    (= ((conj c [0 :v]) 0) :v) :map\n    (= (count (conj c :v)) (count (into c [:v :v]))) :set\n    :else :vector\n    )\n   )\n)", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "521a1ad2e4b0c4ef0be83001"}, {"problem": 65, "code": "(fn [coll]\n  (let [x [:x :y]\n        len (count coll)\n        c (conj (conj coll x) x)]\n    (if (= (inc len) (count c))\n      (if (nil? (c :x))\n        :set\n        :map)\n      (let [y [:y :x]\n            c (conj (conj coll x) y)]\n        (if (= (first c) y)\n          :list\n          :vector)))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 65, "code": "(fn [x-coll] \n (let [e-coll (empty x-coll)\n   tc (conj (conj e-coll [:a 10]) [:b 20])\n   get-a10 (get tc [:a 10])\n   get-a (get tc :a)\n   get-0 (get tc 0)\n   get-fst (first tc)] \n (if (= [:a 10] get-a10)\n   :set\n   (if (= 10 get-a)\n     :map\n     (if (= [:a 10] get-0)\n       :vector\n       (if (= [:b 20] get-fst)\n         :list\n         nil) ))) ))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 65, "code": "(fn [s]\n  (let [emptied (empty s)]\n    (cond (= #{} emptied) :set\n          (= {} emptied) :map\n          :else\n          (let [conjed (conj emptied 1 2)]\n            (if (= [1 2] conjed)\n              :vector\n              :list)))))", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5405885ee4b0addc1aec6668"}, {"problem": 65, "code": "(fn [x]\n  (let [unique-value (Object.)]\n    (if (associative? x)\n      (if (associative? (first (assoc (empty x) 0 :foo)))\n        :map\n        :vector)\n      (if (< (count (conj (empty x) unique-value unique-value)) 2)\n        :set\n        :list))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 65, "code": "(fn [c]\n  (let [e (empty c)]\n    (condp = e\n      {} :map\n      #{} :set\n      () (if (reversible? c) :vector :list))))", "user": "5791d259e4b0ebec4cfb75c0"}, {"problem": 65, "code": "#(cond\n  (= % (conj % {})) :map\n  (= (conj % 1 2) (cons 2 (cons 1 %))) :list\n  (= (count (conj % 1)) (count (conj % 1 1))) :set\n  :else :vector)", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 65, "code": ";(count (seq (conj {5 6} [5 8])))\n;(mapv \n\n(fn [s]\n  (let [x (conj s [9 9])\n        samecount #(= (count x) (count %))]\n    (if (samecount (conj x [9 9]))\n      ;maporset\n      (if (samecount (conj x [9 5]))\n        :map\n        :set)\n      ;listorvec\n      (if (= (first x) \n             (first (conj x 7)))\n        :vector\n        :list))))\n\n;[{3 4} #{4 5} [5 6] '(6 7)])", "user": "57df2722e4b0bd073c20245e"}, {"problem": 65, "code": "(fn [coll]\n  \t(let [self-coll (conj coll coll)]\n  \t\t(cond\n  \t  \t \t(= (count coll) (count self-coll))\n    \t \t\t:map\n   \t  \t\t(= (count self-coll) (count (conj self-coll coll)))\n     \t\t\t:set\n     \t\t((complement nil?) (get self-coll 0))\n     \t\t\t:vector\n     \t\t:else\n     \t\t\t:list)))", "user": "57eb38dbe4b0bfb2137f5b5e"}, {"problem": 65, "code": "(fn black-box-testing [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= empty-coll {}) :map\n      (= empty-coll #{}) :set\n      (reversible? coll) :vector\n      :else :list)))", "user": "57e79d8ee4b0bfb2137f5afe"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5815b957e4b0f478707a0641"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "580d1da7e4b0849f6811b72f"}, {"problem": 65, "code": "#(cond \n  (get (conj % [:a 1]) :a) :map\n  (let [x (conj % [:a 1])]\n    (= (count x) (count (conj x [:a 1])))) :set\n  (= (concat % [:a :b]) (conj (conj % :a) :b)) :vector\n  :otherwise :list)", "user": "5686e652e4b0dcc4269f4059"}, {"problem": 65, "code": "(fn f65-2 [coll]\n  (let [strcoll (first (str coll))]\n    (if (= \\{ strcoll)\n      :map\n      (if (= \\# strcoll)\n        :set\n        (if (= \\[ strcoll)\n          :vector\n          :list)))))", "user": "57bbc9bde4b05aa3c4741c31"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 65, "code": "(fn [coll] (cond \n    (= :x (get (conj coll [1 :x]) 1)) :map\n    (= [:c 4] (first (conj (conj coll [:c 3]) [:c 4]))) :list\n    (= (+ 1 (count coll)) (count (conj (conj coll [:c 4]) [:c 4]))) :set\n    :else :vector\n))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 65, "code": "#({1 :map true :list false :vector 2 :set}\n(let [new (conj % [:1 1] [:1 1] [:1 2])\nsize (- (count new) (count %))] \n (if (= size 3) (= [:1 2] (first new))size)))", "user": "56163cc1e4b06b1bb21829ff"}, {"problem": 65, "code": "(fn wtf [xs]\n  (let [seq (empty xs)\n        order (first (conj (conj (conj seq [1 1]) [2 2]) [3 3]))\n        num (count (conj  (conj (conj (conj seq [1 1]) [2 2]) [3 3]) [3 3]))]\n    (cond\n      (and\n       (= order [1 1])\n       (= num 4)) :vector\n      (and\n       (= order [3 3])\n       (= num 4)) :list\n      (and\n       (= order [1 1])\n       (= num 3)) :map ;; Recent version of Clojure\n      (and\n       (= order [2 2])\n       (= num 3)) :set\n      :else :map )));; Old version of Clojure", "user": "56069006e4b08b23635d3174"}, {"problem": 65, "code": "(fn [s]\n  (let [emp (empty s)]\n    (cond\n      (= emp '()) (if (reversible? s)\n                    :vector \n                    :list)  \n     \n      (= emp #{}) :set\n      (= emp {})  :map)))", "user": "581a5fdbe4b0e114eb51a002"}, {"problem": 65, "code": "(fn get-type\n  [coll]\n  (let [s1 (gensym)\n        s2 (gensym)\n        s3 (gensym)]\n  (if (= (inc (count coll))\n       (count\n        (conj\n         (conj\n          coll\n          (vector s1 s2))\n         (vector s1 s3))))\n    :map\n    (if (= (inc (count coll))\n       (count (conj (conj coll s1) s1)))\n      :set\n      (if (= s2 (last (conj (conj coll s1) s2)))\n    :vector\n    :list)))))", "user": "56449e4de4b0284900eef5f9"}, {"problem": 65, "code": "(fn black-box\n  [x] (let [s gensym]\n        (if (= (+ 2 (count x)) (count (conj x [s s] [s s] [s 0])))\n            :set\n            (if (= (+ 1 (count x)) (count (conj x [s s] [s s] [s 0])))\n              :map\n              (if (= [s s] (first (conj x [0 0] [s s])))\n                :list\n                :vector)))))", "user": "58152157e4b0f478707a0631"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "user": "582bd5fae4b051871117bf7b"}, {"problem": 65, "code": ";(fn my-seq-class [coll]\n;  (let [after-conj-nil-nil (conj coll nil nil)]\n;       (cond (= after-conj-nil-nil coll) :map\n;             (= (+ (count coll) 1) (count after-conj-nil-nil)) :set\n;             (empty? coll) (let [after-conj-1-2 (conj coll 1 2)]\n;                               (cond (= 1 (first after-conj-1-2)) :vector\n;                                     (= 1 (last after-conj-1-2)) :list))\n;             (= nil (last after-conj-nil-nil)) :vector\n;             (= nil (first after-conj-nil-nil)) :list)))\n(comp {\\c :list \\[ :vector \\{ :map \\# :set} first str)\n;(comp {\\{ :map \\# :set \\[ :vector \\c :list} first str)", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 65, "code": "(fn  [s]\n  (let [em (empty s)\n        new_s (conj (conj em '[1 2]) '[1 2])\n        new_new_s (conj new_s '[1 3])\n        ]\n    (if (= 2 (count new_s))\n        ;; list or vec\n        (if (= (first new_new_s) '[1 3])\n          :list\n          :vector)\n        ;; set or map\n        (if (= 2 (count new_new_s))\n          :set\n          :map\n        )\n\n    )\n  )\n)", "user": "5710140fe4b09c608db7042e"}, {"problem": 65, "code": "(fn [coll] (let [add_one (conj coll {:c \"marker\"}), add_two (conj add_one {:d \"spaceman\"})]\n             (if (= (get add_one :c) \"marker\")\n               :map\n               (let [with_two (conj (conj coll \"sqrlx\") \"sqrlx\")]\n                 (if (= (first add_two) {:d \"spaceman\"}) ;; Adds at front\n                 \t(if (= (fnext with_two) \"sqrlx\") :list :set)\n                 \t(if (= (last (butlast with_two)) \"sqrlx\") :vector :set))))))", "user": "58225587e4b04b46fc4b0f94"}, {"problem": 65, "code": "#(cond (= (empty %) {}) :map\n       (= (empty %) #{}) :set\n       :else (if (associative? %) :vector :list))", "user": "56193c6ee4b053970a773af2"}, {"problem": 65, "code": "(fn [s]\n  (let [result (conj (empty s) [0 1] [0 1] [0 2])]\n    (cond\n      (= 1 (count result)) :map\n      (= 2 (count result)) :set\n      (= [0 1] (first result)) :vector\n      :else :list)))", "user": "564d3169e4b0284900eef67c"}, {"problem": 65, "code": "(fn [coll]\n    (let [base (empty coll)]\n      (cond\n        (= base {}) :map\n        (= base #{}) :set\n        (reversible? base) :vector\n        (= base '()) :list)))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 65, "code": "(fn black-box-testing [coll]\n  (let [unique-item (gensym \"bb-testing-\")\n        ;; Add an item incase it's empty\n        coll-test (conj coll [1 1])\n        head (first coll-test)]\n    (cond\n      ;; Maps and sets won't change if a copy of the first item is added to the\n      ;; coll. If the head is in the coll, then it's a set. A hash-map returns\n      ;; nil because the head is a vector like [:a 1], so it fails as a key\n      ;; lookup\n      (= coll-test (conj coll-test head)) (if (coll-test head) :set :map)\n      ;; Add a unique item to the coll using conj. If it's at the tail of the\n      ;; list (doesn't match head) it's a vector. Otherwise list\n      (= head (first (conj coll-test unique-item))) :vector\n      :else :list)))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 65, "code": "(fn [coll]\n  (let [new-coll (conj coll {:special 999})]\n    (cond\n     (not (nil? (:special new-coll))) :map\n     (= new-coll (conj new-coll (first new-coll))) :set\n     (= :cool (first (conj new-coll :cool))) :list\n     :else :vector)))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 65, "code": "(fn [x]\n    (cond\n      (= (first (conj x {:c 3})) [:c 3]) :map   ;maps return added maps as vector all others return them as a map\n      (= (first (conj x :one :two)) :two) :list\n      (= (last (conj x :one :two :three)) :three) :vector\n      :else :set))", "user": "57235dc4e4b0c5bde472c0e2"}, {"problem": 65, "code": "(fn [c]\n  (let [conjd  (conj c [1 2])\n        conjdd (conj conjd [1 2])]\n    (if (= (count conjd) (count conjdd))\n      (if (= (conjd 1) 2)\n        :map\n        :set)\n      (if (and (= (first conjdd) [1 2])\n               (= (first (conj conjd :a)) :a))\n        :list\n        :vector))))", "user": "52173464e4b082aa80a88c75"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "57c41471e4b05aa3c4741cc7"}, {"problem": 65, "code": "(fn [c]\n  (let [x (empty c)]\n    (cond (= x {}) :map\n          (= x #{}) :set\n          (= x ())\n          (if (reversible? x)\n            :vector\n            :list))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 65, "code": "(fn ty [x] \n  (let [le (count x)\n        y (conj x [:a :b] [:a :a] [:a :a])]\n    (if (= (+ 3 le) (count y))\n      (if (= (first y) [:a :a])\n        :list\n        :vector\n       )\n      (if (= (+ 2 le) (count y))\n        :set\n        :map))))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 65, "code": "(fn [coll]\n  (let [r (conj coll {:new 1} {:new 1} {:new 2})\n        co (count coll)\n        cf (count r)]\n    (cond\n      (= cf (inc co)) :map\n      (= cf (+ 2 co)) :set\n      (= (first r) {:new 2}) :list\n      :else :vector)))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 65, "code": "#(case (first (str %))\n      \\{ :map\n      \\# :set\n      \\[ :vector\n      :list)", "user": "583c8bd4e4b089d5ab817d81"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (reversible? x)  :vector\n    (associative? x) :map\n    (= (set x) x)    :set\n    :else            :list))\n      \n; golf\n;(comp {\\{ :map \\c :list \\[ :vector \\# :set} first str)", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 65, "code": "(fn [x] (if\n          (or (= x []) (= x (seq x))) ; if true, either x is an empty list or vector, or x is a sequence\n          (if\n            (and (not= (conj (conj x 1) 2) [1 2]) ; fails for empty vector, but nothing else\n                 (= x (first (conj x x)))) ; passes for list, fails for non-recursive non-empty vector\n            :list :vector)\n          (if\n            (or (= x #{}) ; passes for empty set, but nothing else\n                (and\n                 (not= x {}) ; fails for empty map, but nothing else\n                 (= 1 (count (flatten [(first x)]))))) ; passes for nonempty set, fails for nonempty map\n            :set :map)))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 65, "code": "(fn [c]\n  (let [s1 (gensym)\n        s2 (gensym)]  \n    (cond\n      (and (not (some (partial = {}) c)) ; rule out #{{}}     \n           (= c (conj c {})))               :map \n      (= (conj c s1) (conj (conj c s1) s1)) :set\n      (= s2 (first (conj (conj c s1) s2)))  :list\n      ;:else :vector  ; this would be enough for the tests\n      (= s2 (last (conj (conj c s1) s2)))   :vector\n      :else :unknown)))", "user": "560843dee4b046a4fc0ac00e"}, {"problem": 65, "code": "#(case ((juxt associative? reversible? ifn?) %)\n   [true  true  true ] :vector\n   [false false false] :list\n   [true  false true ] :map\n   [false false true ] :set)", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 65, "code": "(fn [c]\n  (let [t [:a 2]\n        c1 (conj c [1 2] t)\n        c2 (conj c [1 2] t t)]\n    (cond\n      (not= (vec c1) c1)\n        (if (contains? c1 :a)\n          :map\n          :set)\n      (= (first c2) t) :list\n      :else :vector)))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 65, "code": "(fn [c] (let [t (into c [[:s :b][:s :b][:s :c]])\n              d (- (count t) (count c))]\n          (cond \n           (= 1 d) :map\n           (= 2 d) :set\n           (= [:s :c] (first t)) :list\n           :else :vector)))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 65, "code": "(fn [s] (cond\n           (= :t (:t-key (conj s [:t-key :t]))) :map\n           (= :t (:t (conj s :t))) :set\n           (= :t (first (conj (conj s :ignore) :t))) :list\n           (= :t (last (conj (conj s :ignore):t))) :vector))", "user": "585c5b21e4b0f14aab7c8786"}, {"problem": 65, "code": "(fn [coll]\n  (let [name-map {{} :map #{} :set '[] :seq}\n        seq-name (get name-map (empty coll))]\n    (cond \n     (= seq-name :seq) (first\n                        (conj\n                         (empty coll)\n                         :vector\n                         :list))\n     :else seq-name)))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5863be34e4b0f14aab7c8830"}, {"problem": 65, "code": "(fn f [li]\n  (let\n    [nuli (conj li {:aa 1} {:aa 1} {:bb 2})\n     cli (count li)\n     cnuli (count nuli)]\n    (cond \n      (= cnuli (+ cli 2)) (if (:aa nuli) :map :set)\n      (= cnuli (+ cli 3)) (if (= (first nuli) {:bb 2}) :list :vector)\n      :else cnuli)))", "user": "4e6a5728535d8ccf87e9fecf"}, {"problem": 65, "code": "(fn z [coll]\n  (cond\n      (= :value (:key (conj coll [:key :value]))) :map\n      (= (inc (count coll)) (count (conj coll :testA :testA))) :set\n      (= (last (conj (conj coll :testA :testB) :testC)) :testC) :vector\n      :else :list))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 65, "code": "(fn [col]\n  (let [base (empty col)]\n    (cond\n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? col) :vector :list)\n  \t)\n  )\n)", "user": "58670d13e4b0f14aab7c8871"}, {"problem": 65, "code": "(fn [c]\n  (if (= (inc (count c)) (count (conj (conj c [1 2]) [1 2])))\n    (if (= (inc (count c)) (count (conj c {:x 1 :y 2})))\n      :set\n      :map)\n    (if (= (conj c :x :y) (cons :y (cons :x c)))\n      :list\n      :vector)))", "user": "57c94c54e4b05aa3c4741d2c"}, {"problem": 65, "code": "(fn black-box-test [seq]\n    (let [updated (conj (conj seq [:x :y]) [:x :y])\n          conjed (conj (conj seq [:x :y]) [:a :b])\n          mapped (conj seq [:x :y])]\n      (cond\n        (= :y (:x mapped)) :map\n        (= (inc (count seq)) (count updated)) :set\n        (= [:a :b] (last conjed)) :vector\n        (= [:a :b] (first conjed)) :list)\n      )\n    )", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 65, "code": "(fn [arg]\n  ; Using arg as functions will return nil for sets and maps for a query like (arg (+ 1 (count arg)))  \n  ; Once you have determined its a set or a map. The distinction can be made by doing a conj of an arbitrary pair [12 13]\n  ; ((conj arg [12 13]) [12 13]) will give you non nil result but for a map ((conj {1 2 3 4} [12 13]) [12 13]) will be null.  \n  ; For the list and the vector distinction an exception handler like below ought to do the trick\n  ;  (try (t (- (count t) (min 1 (count t))) (catch Exception _ :map)\n\n  ; Ok so catch is not allowed... Next try \n  \n  ; Passing  (= (conj t {}) {}) means its a map, Its interesting how other types add the empty map as an element.\n  ; Next we can look at two cases \n  ; 1: arg is empty. Union was one of those properties that help us distinguish this(alas). \n  ; 2: arg is Here too union with self is a property we can use for set types.\n  (cond \n    (= (conj arg {}) arg) :map  ; can't use this for identifying the other types(this is kind of counter intuitive)\n    (empty? arg) (cond\n                 (= (clojure.set/union arg #{}) #{}) :set\n\t         (= (conj (conj arg 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union arg arg) arg) :set\n    (= (first (conj arg arg)) arg) :list\n    :else :vector))", "user": "5722bf99e4b0c5bde472c0d6"}, {"problem": 65, "code": "#(let [sentinel {:sentinel 1} senti {:sentinel 2}]\n  (cond\n    (= % (set %)) :set\n    (= senti (last (conj % sentinel senti))) :vector\n    (= sentinel (first (conj % senti sentinel))) :list\n    (= % (into {} %)) :map\n  )\n)", "user": "585d9558e4b0f14aab7c879c"}, {"problem": 65, "code": "(fn mytype [col]\n  (let [tcol (conj col [:a 1] [:b 2])]\n    (if (= (count tcol) (count (reduce conj tcol tcol)))\n      (if (= 1 (tcol :a))\n        :map\n        :set)\n      (if (= [:b 2] (last tcol))\n        :vector\n        :list))))", "user": "51456858e4b0e88796073408"}, {"problem": 65, "code": "#(if-not (ifn? %)\n    :list\n    (if (reversible? %)\n      :vector\n      (if (-> % (into {:a true}) :a)\n        :map\n        :set)))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 65, "code": "(comp {\\{ :map \\# :set \\[ :vector \\c :list} first str)", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 65, "code": "(fn [coll]\n    (let [coll2 (-> (empty coll) (conj [:a :b]) (conj [:c :d]))]\n      (cond\n       (get coll2 :a) :map\n       (= [:c :d] (first coll2)) :list\n       (= 3 (count (into (empty coll) [1 2 3 3]))) :set\n       (= [:a :b] (first coll2)) :vector\n       )))", "user": "52dc7344e4b09f7907dd13cf"}, {"problem": 65, "code": "(fn [form]\n  (cond\n    (= (conj form form) form) :map\n    (= [:d2 :d1] (take 2 (conj form :d1 :d2))) :list\n    (nil? (:dummy (conj form :dummy))) :vector\n    :default :set))", "user": "586bc870e4b01531a375e964"}, {"problem": 65, "code": "(fn [x] (let [y  (merge x {:c 2 :d 2} {:c 3} {:d 2} {:d 2}) cx (count x) cy (count y) ]\n          (cond\n          (= 2 (- cy cx)) :map\n          (= 3 (- cy cx)) :set\n          (= (first y) {:d 2}) :list\n          :else :vector   \n          )))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 65, "code": "(fn [x]\n  (cond (= ::v (::v (conj x [::v ::v]))) :map\n        (= (count (conj x ::v ::v)) (inc (count x))) :set\n        (= ::v (first (conj x ::z ::v))) :list\n        :default :vector))", "user": "4da8dd6e30acd6ed12482a68"}, {"problem": 65, "code": "(fn [x]\n  (let [empty-x (empty x)]\n    (cond\n      (= 1 (count (conj (conj empty-x [:a 1]) [:a 1])))\n      (if (get (conj empty-x [:a 1]) :a)\n        :map\n        :set)\n      (= :a (first (conj (conj empty-x :a) :b)))\n      :vector\n      :else\n      :list)))", "user": "584b0422e4b089d5ab817ef4"}, {"problem": 65, "code": "#(let [c (empty %)]\n    (cond\n      (= #{[1 1]} (into c [[1 1] [1 1]])) :set\n      (= {1 1}    (into c [[1 1] [1 1]])) :map\n      (= [1 2 3]  (into c [1 2 3]))       :vector\n      :otherwise                          :list))", "user": "5458c74de4b01be26fd74623"}, {"problem": 65, "code": "(fn [x]\n  (let [test (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a test) :map\n      (get test 0) :vector\n      (get test [:a :b]) :set\n      :else :list)))", "user": "563f4c47e4b08d4f616f5ed2"}, {"problem": 65, "code": "(fn [x]\n  (let [b (empty x)]\n    (cond\n      (= b {}) :map\n      (= b #{}) :set\n      (reversible? b) :vector\n      :else :list)))", "user": "58731176e4b01531a375ea2a"}, {"problem": 65, "code": "(fn [x]\n  (cond (reversible? x) :vector\n        (associative? x) :map\n        (= (vec x) x) :list\n        :otherwise :set))", "user": "58247423e4b051871117bec5"}, {"problem": 65, "code": "(fn [s]\n    (if (= (:a (conj s [:a 1])) 1)\n      :map\n      (let [orig-count (count s)\n            set-test-count (count (conj (conj s [6 6]) [6 6]))]\n        (if (or (= (+ 1 orig-count)\n                 set-test-count))\n          :set\n          (let [list-test (apply conj s [[:a 1] [:b 2]])]\n            (if (= [:b 2]\n                   (first list-test))\n              :list\n              :vector))))))", "user": "586b6753e4b01531a375e956"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "55597b84e4b0deb715856e36"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (= coll (into [] coll))\n      (if (= (conj coll ::drb226 ::drb227) (concat coll [::drb226 ::drb227]))\n        :vector\n        :list)\n    (= coll (into #{} coll)) :set\n    (= coll (into {} coll)) :map\n    :else :unknown))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 65, "code": "#(let [t %1\n       c (count t)\n       l (seq t) \n       m_p? (and \n             (even? c) \n             (not= (count (apply hash-map t)) c)\n            )\n       ] \n   (cond \n    (= t {:a 1, :b 2}) :map\n    (= t {}) :map\n    (= (apply hash-set t) t) :set\n    (= (first (conj t 111 112)) 112) :list \n    (= (last  (conj t 111 112)) 112) :vector\n    m_p? :map\n    ))", "user": "586e47dee4b01531a375e9a9"}, {"problem": 65, "code": "(fn [col]\n   (cond\n     (= (get (conj col [:a \"a\"]) :a) \"a\") :map\n     (= (count (conj col \"a\" \"a\")) (+ (count col) 1)) :set\n     (= (last (conj col \"a\" \"b\")) \"b\") :vector\n     (= (first (conj col \"a\" \"b\")) \"b\") :list\n     )\n   )", "user": "5857d27de4b0f14aab7c8710"}, {"problem": 65, "code": ";;(prn (map  \n(fn [s] \n   (let [resmap {[nil [0 1]] :list \n                 [[0 0] [0 0]] :vector \n                 [1 [0 1]] :map \n                 [nil [0 0]] :set}\n         emptyseq (empty s)\n         testseq (into emptyseq [[0 0] [0 1]])\n         keyvect  (vector (get testseq 0) \n                          (first testseq))]\n     (get resmap keyvect)))\n;;  '(() [] {} #{})))\n;;(prn (map #(into % [[0 0] [1 1]]) '(() [] {} #{})))", "user": "58566b42e4b0f14aab7c86f4"}, {"problem": 65, "code": "(fn [s]\n  (cond\n   (= :fuu (:foo (conj s [:foo :fuu]))) :map\n   (= (cons :fii (cons :faa s))  (conj (conj s :faa) :fii)) :list\n   (= [:fii :fooo] (get (conj s [:fii :fooo]) (count s))) :vector\n  \n   (= (map identity s) (map s s)) :set))", "user": "4f3b5219e4b0e243712b1f2a"}, {"problem": 65, "code": "(fn [s]\n  (let [e (empty s)]\n    (cond (= {} e) :map\n          (= '() e) (if (reversible? e) :vector :list)\n          (= #{} e) :set)))", "user": "5878fb4ee4b01531a375eac1"}, {"problem": 65, "code": "#((fn [x](if (= x \\{)\n\n          :map\n\n          (if (= x \\#)\n\n            :set\n\n            (if (= x \\[)\n\n              :vector\n\n              :list)))) (first (seq (str %))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 65, "code": "(fn  [coll]\n  (cond (= (inc (count coll)) (count  (conj coll [:test 1] [:test 2]))) :map\n        (= (inc (count coll)) (count  (conj coll [:test 1] [:test 1]))) :set\n        (= :dummy (last (conj coll :test :dummy))) :vector\n       :else :list))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 65, "code": "#(condp = (first (str %)) \\{ :map \\c :list \\[ :vector \\# :set)", "user": "581dad0ae4b04b46fc4b0f17"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5790f9d7e4b0ebec4cfb75b4"}, {"problem": 65, "code": "(fn black-box-testing [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= {} empty-coll) :map\n      (= #{} empty-coll) :set\n      (= [1 2] (conj empty-coll 1 2)) :vector\n      :else :list)))", "user": "5879d577e4b01531a375ead8"}, {"problem": 65, "code": "(fn [x]\n    (let [e (empty x)]\n      (println e)\n      (cond\n        (= #{} e) :set\n        (= {} e) :map\n        (= nil (get (into e (list 1)) 0)) :list\n        :else :vector)))", "user": "5881335ce4b0f1effa3b762e"}, {"problem": 65, "code": "#(let [c (empty %)] (cond (= [] c) (if (reversible? c) :vector :list) (= {} c) :map :else :set))", "user": "587294f0e4b01531a375ea1e"}, {"problem": 65, "code": "#(let [a {:a 1} t (conj (empty %) a a) ]\n   (cond\n  (= a (into t a)) :map\n  (= 1 (count t)) :set\n   (= a (first (conj t :z))) :vector \n    :otherwise :list\n                                                        ))", "user": "587c59d1e4b01531a375eb17"}, {"problem": 65, "code": "(fn [s]\n  (case (empty s)\n    {} :map\n    #{} :set\n    (let [x (conj s 100 101)]\n      (cond\n       (= (first x) 101) :list\n       (= (last x) 101) :vector))))", "user": "58844d43e4b0f1effa3b7696"}, {"problem": 65, "code": "(fn class-finder\n  [obj]\n  (cond\n    (= (inc (count obj)) (count (conj obj {:test 1} {:test 2}))) :map\n    (= (inc (count obj)) (count (conj obj {:test 1} {:test 1}))) :set\n    (= :test (last (conj obj :dummy :test))) :vector\n    :else :list))", "user": "588bf237e4b05c141a25608d"}, {"problem": 65, "code": "(fn [x]\n  (if (= (count (conj x {:_ 0 :__ 0})) (+ (count x) 2))    \n    :map\n    (if (= (count (conj (conj x :_) :_)) (count (conj x :_)))\n      :set\n      (if (= (first (conj x :_ :__)) :__)\n        :list\n        :vector))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 65, "code": "(fn [c]\n   (cond\n     (= {} (empty c)) :map\n     (= #{} (empty c)) :set\n     (= [:a :b] (conj (empty c) :a :b)) :vector\n     (= '(:b :a) (conj (empty c) :a :b)) :list))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 65, "code": "(fn [s]\n  (cond (= (inc (count s)) (count (conj s {:test 1} {:test 2}))) :map\n  \t\t(= (inc (count s)) (count (conj s {:test 1} {:test 1}))) :set\n  \t\t(= :test (last (conj s :dummy :test))) :vector\n        :else :list)\n  )", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 65, "code": "(fn [x]\n  (cond\n     (= (conj x {}) x) :map\n     (empty? x) (cond\n                               (= (clojure.set/union x #{}) #{}) :set\n                               (= (conj (conj x 0) 1) [0 1]) :vector\n                               :else :list)\n     (= (clojure.set/union x x) x) :set\n     (= (first (conj x x)) x) :list\n     :else :vector))", "user": "58949f8de4b00487982d525e"}, {"problem": 65, "code": "(fn [t]\n  (if (associative? t)\n    (if (= t (vec t)) :vector :map)\n    (if (= t (set t)) :set :list)))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 65, "code": "(fn my-test [coll]\n  (let [sym1 (gensym)\n        sym2 (gensym)\n        pair1 [sym1 sym1]\n        pair2 [sym2 sym2]\n        coll-1 (conj coll pair1)\n        coll-11 (conj coll-1 pair1)\n        coll-12 (conj coll-1 pair2)]\n    (cond\n                  (= sym1 (sym1 coll-1)) :map\n                  (= coll-1 coll-11) :set\n                  (= pair2 (first coll-12)) :list\n                  (= pair2 (last coll-12)) :vector\n                  )))", "user": "5896a0e6e4b00487982d52a8"}, {"problem": 65, "code": "(fn t? [s]\n  (cond\n    (= s (into #{} s)) :set\n    (and (associative? s)\n         (not= (count (flatten (assoc s 0 1))) (count (assoc s 0 1)))) :map \n    (and (= s (into [] s))\n         (associative? s)\n         (= (last (conj s 'spc)) 'spc)) :vector\n    (and (= (reverse s) (into () s))\n         (= (first (conj s 'spc))  'spc))  :list))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "58923efce4b00487982d521c"}, {"problem": 65, "code": "(fn [coll] (let [test (empty coll)]\n  (cond \n   (= test {})  :map\n   (= test #{}) :set\n   (= test '()) (if (reversible? test) :vector :list)\n   )\n             ))", "user": "58a01c73e4b02bd94d917e95"}, {"problem": 65, "code": "(fn\n  [coll]\n  (let\n    [coll (empty coll)\n     of-map? (fn\n               [coll]\n               (contains?\n                (conj coll [:key :value])\n                :key))\n     of-list? (fn\n                [coll]\n                (= :second\n                   (first\n                    (-> coll\n                        (conj :first)\n                        (conj :second)))))\n     of-set? (fn\n               [coll]\n               (=\n                1\n                (count (conj\n                        (conj\n                         coll\n                         1)\n                        1))))]\n    (if\n      (of-map? coll)\n      :map\n      (if\n        (of-set? coll)\n        :set\n        (if\n          (of-list? coll)\n          :list\n          :vector)))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 65, "code": "(fn bb [coll]\n  (cond\n    (= coll (conj coll {})) :map\n    (get (conj coll :t) :t) :set\n    (let [g1 (gensym)\n          g2 (gensym)]\n      (= g2 (last (conj coll g1 g2)))) :vector\n    :else :list))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 65, "code": "(fn [s] (let [e [:a 1] ns (conj s e)]  \n\t(if (= (get ns :a) 1) :map\n\t(if (= (get ns e) e) :set\n\t(if-not (= (get ns 0) nil) :vector :list)))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 65, "code": "; a bit triky\n; (fn black-box-testing [xs]\n;  ({{} :map #{} :set }(empty xs)\n;  (if (reversible? xs) :vector :list)))\n\n(fn black-box-testing [xs]\n  (cond\n   (= 2 (:m (conj xs [:m 1] [:m 2])))\n   :map\n   (= (inc (count xs)) (count (conj xs [:m 1] [:m 1])))\n   :set\n   (= [:m 2] (first (conj xs [:m 1] [:m 2])))\n   :list\n   (= [:m 2] (last (conj xs [:m 1] [:m 2])))\n   :vector\n   ))", "user": "56255e2de4b00a550fc90297"}, {"problem": 65, "code": "(fn bbtest [s]\n  (let [p ((juxt associative? reversible? ifn?) s)]\n    (cond (= [true true true] p) :vector\n          (= [true false true] p) :map\n          (= [false false true] p) :set\n          :else :list\n          )\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 65, "code": "(fn blackbox\n  [col]\n    (let [testCol (conj (empty col) [:a 1] [:a 2] [:b 3] [:b 3]), colCount (count testCol), firstElem (first testCol)]\n      (if (= 2 colCount) :map (if (= 3 colCount) :set (if (= [:b 3] firstElem) :list :vector))\n    )\n  )\n)", "user": "58950f29e4b00487982d5270"}, {"problem": 65, "code": "(fn get-type [a-seq]\n  (let [test-seq (into (empty a-seq) '([0 2]))\n        val1 (get test-seq 0)\n        val2 (get test-seq [0 2])]\n    (cond\n      (= val1 2) :map\n      (= val1 [0 2]) :vector\n      :else (if (= val2 [0 2])\n              :set\n              :list))))", "user": "580d2788e4b0849f6811b730"}, {"problem": 65, "code": "(fn my-black-box [col]\n  ;;keep count of col before conj and conj two nils. They will help differentiating between sets and maps. Maps should remain intanct\n  ;;and sets should keep only one of the nils. Works nice if the order of evaluation in the condp is kept as is. Does not work (yet) for empty containers\n  (let [cnt (count col)\n        ;;need two nils otherwise there's :set misclassifications (can you understand why? :))\n        c (conj col nil nil)]\n    (condp (fn [f c] (f c)) c\n      ;;note that checks for map/set are first because (first %) in a set can sometimes yield the conjoined nil, and wrongly returning :list\n      \n      ;;if the count of the collection provided is the same after conj, it's a map\n      #(= (count %) cnt) :map\n      ;if I add 3 elements (and accept that :kw will represent a unique token that doesn't exist in any set (change it to a hash value to be solid)) then I expect the count of c to be 2 higher that that of the original collection.\n      #(= (count (conj % :kw)) (inc (inc cnt))) :set\n      ;;adding a unique keyword on top of two nils makes it work for empty collections where first and last would be the same\n      #(= (last (conj % :kw)) :kw) :vector\n      #(= (first (conj % :kw)) :kw) :list\n      )))", "user": "58988cbbe4b00487982d52d7"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "58a32c21e4b02bd94d917eeb"}, {"problem": 65, "code": "(fn [c]\n   (cond\n     (get (into c {:xxx 999}) :xxx) :map\n     (= (count (into c [1])) (count (into c [1 1]))) :set\n     (= 997 (first (into c [999 998 997]))) :list\n     (= 997 (last (into c [999 998 997]))) :vector\n     :else :set\n     )\n   )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 65, "code": "(fn [s0]\n  (let [s (conj s0 [:querty \"xxxxs\"])]\n    (if (= (apply list s) s)\n      (if (= (first (conj s \"xy!!$#\")) \"xy!!$#\")\n        :list\n        :vector)\n      (if (= (s (first s)) (first s))\n        :set\n        :map))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 65, "code": "(fn [in] (condp = (nth (str in) 0)\n   \\# :set \n   \\{ :map \n   \\c :list\n   \\[ :vector))", "user": "57db2369e4b0bd073c20241f"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list)) ; I don't understand! :S", "user": "57625c18e4b0994c1922fba4"}, {"problem": 65, "code": "(fn [coll]\n    (let [added (conj coll [:a 1] [:b 2])]\n      (cond\n        (= 1 (get added :a)) :map\n        (= [:a 1] (get added [:a 1])) :set\n        (= [:b 2] (last added)) :vector\n        true :list)))", "user": "58b06b7ce4b0ebc645576cdc"}, {"problem": 65, "code": "(fn t [obj]\n  (cond\n    (= (get (conj obj {:__test 1}) :__test) 1) :map\n    (= (inc (count obj)) (count (conj obj :__test :__test))) :set\n    (= (first (conj obj :a :b)) :b) :list\n    :else :vector))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 65, "code": "(fn [c]\n  (let [c2 (conj c [:k :v])]\n    (if (= c2\n           (conj c2 [:k :v]))\n      (if (= :v (get c2 :k))\n        :map\n        :set)\n      (if (= :c (last (conj c :a :c)))\n        :vector\n        :list))))", "user": "559622cee4b0c79f6e1db975"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (cond\n   (= coll {}) (seq-type (conj coll [:marker \"marker\"]))\n   (= coll #{}) (seq-type (conj coll :marker))\n   (= coll '()) (seq-type (conj coll :marker-1 :marker-2))\n   :else (if (= coll (conj coll (first coll)))\n           (if (nil? (get coll (first coll)))\n             :map\n             :set)\n           (if (= (concat (list (first coll)) coll) (conj coll (first coll)))\n             :list\n             :vector))))", "user": "58a953dae4b01a0c0b232968"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "507eed82e4b06ce648bcdbfe"}, {"problem": 65, "code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n    (if (= 1 (count result))\n      :map (if (= 2 (count result))\n             :set (if (= [1 3] (first result))\n:list :vector )))))", "user": "57e6997ee4b0bfb2137f5af0"}, {"problem": 65, "code": "(fn [x] (let [g (gensym) t (conj x [g 1])]\n          (if (= t (conj t [g 1])) \n            (if (t g) :map :set)  \n            (if (= g (first (conj t g))) :list :vector))))", "user": "576e3258e4b0979f89651574"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= 1 (get (conj c [:x 1]) :x)) :map\n    (= :x (get (conj c :x) :x)) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "50385746e4b0803468ea2c6d"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))\n\n;; redo", "user": "5897dda4e4b00487982d52c8"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (let [cnt (count coll)\n        c (conj coll [:a 1] [:a 1] [:b 2])\n        f (first coll)\n        l (last coll)]\n    (cond\n      (= (:b c) 2) :map\n      (= (+ cnt 2) (count c)) :set\n      (= (first c) [:b 2]) :list\n      :else :vector)))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "58bc0531e4b0888cdc949d07"}, {"problem": 65, "code": "(fn\n  [x]\n  (let [a (empty x)]\n    (cond\n     (= a {}) :map\n     (= a #{}) :set\n     (= a '()) (if (reversible? x) :vector :list)     \n     )\n    )\n  )", "user": "58a44a14e4b01a0c0b2328f2"}, {"problem": 65, "code": "(fn bbt [coll] (cond (get (conj coll [:tmp \"t1\"]) :tmp) :map (= (inc (count coll)) (count (apply conj coll '(:t1 :t1)))) :set (= (last (apply conj (conj coll :tmp) '(:t1 :t1) )) :t1) :vector  (= (first  (apply conj (conj coll :tmp) '(:t1 :t1) )) :t1) :list :else :no-idea))", "user": "58ac513fe4b0005cfeb1a746"}, {"problem": 65, "code": "(fn [coll]\n    (let [empty-coll (empty coll)]\n      (cond\n        (= (get (conj coll [:ff :gg]) :ff) :gg) :map\n        (= (conj empty-coll :ff :gg) '(:ff :gg)) :vector\n        (= (conj empty-coll :ff :gg) [:gg :ff]) :list\n        (= (conj empty-coll :ff :ff) #{:ff}) :set)))", "user": "58bbcbc8e4b0888cdc949d00"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "568aa458e4b0dcc4269f4092"}, {"problem": 65, "code": "#(if (empty? (flatten (conj % [:t :p])))\n    (if (= (+ 2 (count %)) (count (conj % [:t :p] [:t :l]))) :set :map)\n    (if (= (first (conj % :l :f)) :f) :list :vector))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= (conj coll [:test 0] [:test 1])\n      (conj coll [:test 1])) :map\n   (= (conj coll [:test 0] [:test 0])\n      (conj coll [:test 0])) :set\n   (= (last (conj coll :test :test1))\n      :test1) :vector\n   :else :list))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 65, "code": "(fn [coll]\n  (cond \n   ;(try (assoc coll :a 1) (catch Exception e nil))\n   (= 2 (:a (conj coll [:a 2])))\n   :map\n   (< (count (conj coll :a :a :a)) (+ 2 (count coll)))\n   :set\n   (= 2 (last (conj coll 1 2)))\n   :vector\n   (= 2 (first (conj coll 1 2)))\n   :list))", "user": "4f1ef6a0535d64f60314649b"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5755e66ee4b02ea1147992cf"}, {"problem": 65, "code": "(fn tester[inn]\n  (let [nn (conj inn {:x 10 :y 10} )\n        d  (- (count nn) (count inn))]\n    (cond\n      (= 2 d) :map\n      (= 0 (- (count nn) (count (conj nn {:x 10 :y 10})))) :set\n      (= '({:a 10}{:y 10 :x 10}) (take 2 (conj nn {:a 10}))) :list\n      :else :vector )))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 65, "code": "(fn blackbox-testing\n  [item]\n  (cond\n    (= (conj item {}) item) :map\n    (empty? item) (cond\n                    (= (clojure.set/union item #{}) #{}) :set\n                    (= (conj item 1 2) [1 2]) :vector\n                    (= (conj item 1 2) '(2 1)) :list)\n    (= (first (conj item nil)) (first item)) :vector\n    (= (first (conj item nil -1000)) -1000) :list\n    :else :set))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 65, "code": "(fn [x] (let [res (conj (empty x) [1 2] [1 2] [1 3])]\n          (cond \n           (= 1 (count res)) :map\n           (= 2 (count res)) :set\n           (= [1 2] (first res)) :vector\n           :else :list)))", "user": "58b989dbe4b0888cdc949ccd"}, {"problem": 65, "code": "(fn [col]\n   (let [x (gensym)\n         y (gensym)\n         map-col (into col [[x y]])\n         n-col #(into col [x y])\n         ]\n     (cond\n       (= y (x map-col)) :map\n       (= (count (n-col)) (-> (into (n-col) [x]) count)) :set\n       (= (first (n-col)) y) :list\n       :else :vector)))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 65, "code": "(fn [coll]\n   (cond \n     (and (associative? coll) (not (reversible? coll))) :map\n     (= -99 (get (conj coll -99) -99)) :set\n     (= -99 (last (conj coll 100 -99))) :vector\n     (= -99 (first (conj coll -100 -99))) :list\n    )\n  )", "user": "58d6caf5e4b03c36ff7e5975"}, {"problem": 65, "code": "(fn [x]\n  (if (= 1 (:x (conj x [:x 1]))) :map \n  \t(if (= (inc (count x)) (count (conj x [:x 1] [:x 1]))) :set\n      (if (= [:y 1] (first (conj x [:x 1] [:y 1]))) :list :vector))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 65, "code": "(fn detect [col]\n  (let [v1 (gensym), v2 (gensym)]\n    (let [new-col (conj col [v1 v1] [v2 v2])]\n      (println new-col)\n      (cond\n        (and\n          (= (count (flatten new-col)) (+ 4 (count col)) )\n          (= (first (flatten new-col)) v2)) :list\n        (= (count (flatten new-col)) (+ 4 (count col)) ) :vector\n        (nil? (get new-col v1)) :set\n        :else :map\n      ))))", "user": "587a3babe4b01531a375eae2"}, {"problem": 65, "code": "(fn [c]\n  (let [e (empty c)]\n    (cond\n      (= e {})  :map\n      (= e #{}) :set\n      (= (conj e :a :b) (concat e [:a] [:b])) :vector\n      :else :list) ))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 65, "code": "(fn type' [o]\n  (cond\n    (= o (set o)) :set\n    (not (= (map identity o) o)) :map\n    (= \"hoi\" (first (conj o \"!!!\" \"hoi\"))) :list\n    :else :vector))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 65, "code": "(fn [coll]\n  (letfn [(is-list? [sequ]\n                    (and (= (first (conj sequ [:a :b] [:c :d])) [:c :d]) (= (count (conj sequ [:a :b] [:a :b])) (+ 2 (count sequ)))))\n          (is-vector? [sequ]\n                      (= (first (assoc sequ 0 1)) 1))\n          (is-map? [sequ]\n                   (= (last (assoc sequ 0 1)) [0 1]))\n          (is-set? [sequ]\n                   (and (= (first (conj sequ [0 1] [:a :b] [:c :d])) [0 1]) (= (count (conj sequ [:a :b] [:a :b])) (+ 1 (count sequ)))))]\n    (if (is-list? coll)\n      :list\n      (if (is-set? coll)\n        :set\n        (if (is-vector? coll)\n          :vector\n          :map)))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 65, "code": "(fn [xs]\n  (cond \n   (= 3 (:c (conj xs {:c 3}))) :map\n   (= 1 (count (filter #{5} (conj xs 5 5)))) :set\n   (= 3 (last (conj xs 2 3))) :vector\n   (= 3 (first (conj xs 2 3))) :list\n   :else nil))", "user": "58a216e8e4b02bd94d917ed1"}, {"problem": 65, "code": "(fn bbt [coll]\n     (cond\n       (= \"t\" (get (conj coll {:t \"t\"}) :t)) :map\n       (= :t (get (conj coll :t) :t)) :set\n       (= :a (first (conj (conj coll :b) :a))) :list\n       (= :a (last (conj (conj coll :b) :a))) :vector ))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "58e5f995e4b056aecfd47ca5"}, {"problem": 65, "code": "(fn get-type [v]\n  (if (get (conj v [:my-unprobable-key :a]) :my-unprobable-key)\n      :map\n      (let [r (conj v :my-unprobable-key-1 :my-unprobable-key-2 )]\n        (cond\n          (get r :my-unprobable-key-1)\n          :set\n\n          (= :my-unprobable-key-2 (last r))\n          :vector\n\n          (= :my-unprobable-key-2 (first r))\n          :list\n\n          :else\n          :unknown\n          ))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 65, "code": "(fn [m]\n  (let [is-map (fn [m] (= (get (conj m [:m :n]) :m) :n))\n        is-set (fn [m] (= (conj (conj m :m) :m) (conj m :m)))\n        is-vec (fn [m] (= 1024 (last (conj (conj m 1023) 1024))))\n        is-list (fn [m] (= 1024 (first (conj (conj m 1023) 1024))))]\n    (cond\n     \t(is-map m) :map\n     \t(is-set m) :set\n     \t(is-vec m) :vector\n     \t(is-list m) :list\n     \t:else :unknown)))", "user": "58edaa3be4b056aecfd47d89"}, {"problem": 65, "code": "(fn blackbox-type [coll]\n  (if (associative? coll)\n    (if (reversible? coll)\n      :vector\n      :map)\n    (if (ifn? coll)\n      :set\n      :list)))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 65, "code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (= (sequence %) %) :list\n  :else :set)", "user": "58e58ae9e4b056aecfd47c9a"}, {"problem": 65, "code": "(fn black-box-testing [xs]\n  (letfn [(map' [xs]\n            (let [c1 (count xs)\n                  c2 (count (apply conj xs (map (fn [i] [:a i]) (range 10))))]\n              (<= (- c2 c1) 1)))\n\n          (set' [xs]\n            (let [c1 (count xs)\n                  c2 (count (conj xs :a :a))]\n              (<= (- c2 c1) 1)))\n\n          (list' [xs]\n            (let [c (count xs)]\n              (->> (into xs (repeat 10 :a))\n                   (take 10)\n                   (= (repeat 10 :a)))))\n\n          (vector' [xs]\n            (let [xs (conj xs 1)\n                  c (count xs)]\n              (->> (into xs (repeat 10 :a))\n                   (drop c)\n                   (= (repeat 10 :a)))))]\n    (cond\n      (map' xs) :map\n      (set' xs) :set\n      (vector' xs) :vector\n      (list' xs) :list)))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 65, "code": "(fn what [ s ] \n  (cond \n  \t (= s (conj s s)) :map\n     (= (concat s [1 2]) (conj s 1 2)) :vector\n     (= (concat '(2 1) s) (conj s 1 2)) :list\n     :else :set    \n   )\n  )", "user": "57887de2e4b0ebec4cfb751c"}, {"problem": 65, "code": "(fn bbt [coll]\n  (let [clear-coll (empty coll)\n        primed-coll (conj clear-coll [0 :a] [1 :b])]\n    (cond (= (get primed-coll 0) :a) :map\n          (= (get primed-coll 0) [0 :a]) :vector\n          (= (get primed-coll [0 :a]) [0 :a]) :set\n          (= (first primed-coll) [1 :b]) :list)))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 65, "code": "#(let [x (gensym)]\n   (cond\n     (= 1 (x (conj % [x 1]))) :map\n     (= (count (conj % x)) \n        (count (conj (conj % x) x))) :set\n     (= x (first (conj % 1 x))) :list\n     (= x (last (conj % 1 x))) :vector))", "user": "56f881e0e4b08e7d20b96839"}, {"problem": 65, "code": "(fn [coll]\n  (let\n    [behave-like-map? (fn [c] (>= 1 (- (count (reduce conj c [[2 2] [2 3]])) (count c))))\n     behave-like-set? (fn [c] (>= 1 (- (count (reduce conj c [2 2])) (count c))))\n     behave-like-list? (fn [c] (every? #(= % (first (conj (conj c 0) %))) [1 2]))]\n    (cond\n      (behave-like-map? coll) :map\n      (behave-like-set? coll) :set\n      (behave-like-list? coll) :list\n      :else :vector)))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 65, "code": "(fn [xs]\n  (cond\n    (= (get (conj xs [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj xs :t) :t) :t) :set\n    (= (first (conj (conj xs :a) :b)) :b) :list\n    (= (last (conj (conj xs :a) :b)) :b) :vector))", "user": "58ef4db9e4b056aecfd47dc6"}, {"problem": 65, "code": "(fn [coll]\n  (let [s (str coll)]\n    (cond\n      (.contains s \"#\") :set\n      (.contains s \"{\") :map\n      (.contains s \"[\") :vector\n      :else :list\n      )))", "user": "5823d3e6e4b051871117beb8"}, {"problem": 65, "code": "(fn id [o]\n  (let [o' (conj o [:flava :flav])]\n    (if (:flava o')\n      :map\n      (let [o'' (conj o' [:flava :flav])]\n        (if (= (count o') (count o''))\n          :set\n          (if (= (conj (conj o :flava) :flave)\n                 (cons :flave (cons :flava o)))\n            :list\n            :vector))))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 65, "code": "#(case (first (str %))\n       \\[ :vector\n       \\{ :map\n       \\# :set\n       :list)", "user": "58987ee9e4b00487982d52d2"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 65, "code": "#({\\# :set \\{ :map \\[ :vector \\c :list} (nth (str %) 0))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 65, "code": "#(cond\n   (not (ifn? %)) :list\n   (not (associative? %)) :set\n   (coll? (first (assoc % 0 2 ))) :map\n   :else :vector)", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "560124b0e4b04bb52996e17b"}, {"problem": 65, "code": "(fn type-of-sq [sq]\n  (let [base (empty sq)]\n    (cond\n    (= base {}) :map\n    (= base #{}) :set\n    :else (if (reversible? sq) :vector :list))))", "user": "59032c0fe4b022d14a2aaf9f"}, {"problem": 65, "code": "(fn [xs]\n  (let [foo [:foo :bar]\n        lol [:lol :wut]]\n  (cond\n     (= :bar (get (conj xs foo) :foo)) :map\n     (= (inc (count xs)) (count (conj xs foo foo))) :set\n     (= lol (first (conj xs foo lol))) :list\n     (= lol (last (conj xs foo lol))) :vector\n     :else :unknown)))", "user": "58db097fe4b0a4d5acaab66f"}, {"problem": 65, "code": "(fn [xs]\n (let [foo [:foo :bar]\n       lol [:lol :wut]]\n (cond\n    (= :bar (get (conj xs foo) :foo)) :map\n    (= (inc (count xs)) (count (conj xs foo foo))) :set\n    (= lol (first (conj xs foo lol))) :list\n    (= lol (last (conj xs foo lol))) :vector\n    :else :unknown)))", "user": "58eac340e4b056aecfd47d24"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "user": "57c3bb49e4b05aa3c4741cc2"}, {"problem": 65, "code": "(fn [coll]\n  (let [\n    len (count coll)\n    coll' (conj coll {:hello :world} {:hello :world} {:hello :universe})\n    len' (count coll')]\n    (cond\n      (= len' (+ len 3)) (if (= (first coll') {:hello :universe}) :list :vector)\n      (= len' (+ len 2)) :set\n      (= len' (+ len 1)) :map)))", "user": "5901158de4b0438e51c2d039"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 65, "code": "(fn [coll]\n  (let [obj (new Object)\n        x (conj coll [1 2])]\n    (cond\n      (empty? (flatten x)) (if (associative? x)\n                             :map\n                             :set)\n      (= (first (conj x obj)) obj) :list\n      :else :vector)))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 65, "code": "(fn [col]\n  (let [\n        additem [1 2]\n        qq (conj col [666 777] additem additem)\n        countqq (count qq)\n        ]\n    (if (= countqq (+ 3 (count col)))\n      ;list or vector\n      (if (= additem (first qq))\n        :list\n        :vector)\n      ;map or set\n      (if (contains? qq additem)\n        :set\n        :map))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5640b135e4b08d4f616f5ee8"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 65, "code": "(fn [x]\n  (condp #(= %1 (empty %2)) x\n    '{} ':map\n    '#{} ':set\n    (if (reversible? x) ':vector :list)))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 65, "code": "#(let [c count a [1 1] b [1 2] t (conj (empty %) a b)]\n   (cond (= 1 (c t)) :map\n         (= 2 (c (conj t a))) :set\n         (= (last t) a) :list\n         1 :vector))", "user": "59156f0be4b0163c97b36f3d"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "58fb7d7ae4b0438e51c2cf7a"}, {"problem": 65, "code": "(fn bbt [xs]\n   ;set\n   (case (empty xs)\n     {} :map\n     #{} :set\n     (if (= (conj (empty xs) 1 2) [1 2])\n       :vector\n       :list))\n   )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 65, "code": "(fn [sq]\n  (cond\n    (= 1 (:a (conj sq [:a 1]))) :map\n    (> 2 (- (count (conj (conj sq 1) 1)) (count sq))) :set\n    (let [f (first sq) v (if (nil? f) 1 nil)] (= v (first (conj (conj sq 2) v)))) :list\n    :else :vector))", "user": "588e4e05e4b00487982d5188"}, {"problem": 65, "code": "(fn dumbclass [x]\n  (let [finput (first (str x))]\n    (cond (= finput \\{) :map\n          (= finput \\#) :set\n          (= finput \\[) :vector\n          (= finput \\() :list\n          :else :list)))", "user": "557e8326e4b05c286339e0d7"}, {"problem": 65, "code": "(fn [coll]\n      (cond \n       (contains? (conj coll [:k 1]) :k) :map\n       (< (- (count (conj (conj coll :k) :k)) (count coll)) 2) :set\n       (= (last (conj (conj coll 3) [:k 2])) [:k 2]) :vector\n       :else :list))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 65, "code": "(fn t [coll]\n (let [empty-coll (empty coll)]\n (cond\n  (= {} empty-coll) :map\n  (= #{} empty-coll) :set\n  (reversible? coll) :vector\n  :default :list\n)))", "user": "589b98fae4b00487982d533c"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "591f05b4e4b09b4ee5954c42"}, {"problem": 65, "code": "(fn\n  [c]\n  (let [c (empty c)]\n    (cond\n     (= c {}) :map\n     (= c #{}) :set\n     (= c '()) (if (reversible? c) :vector :list))))", "user": "57233cc8e4b0c5bde472c0e1"}, {"problem": 65, "code": "(fn [thing]\n  (cond (let [sym (gensym)]\n          (= (count (conj thing\n                          [sym (gensym)]\n                          [sym (gensym)]))\n             (inc (count thing))))\n        :map\n        (< (count (conj thing 1 1))\n           (+ 2 (count thing)))\n        :set\n        (let [syma (gensym)\n              symb (gensym)]\n          (= (conj thing syma symb)\n             (list* symb syma thing)))\n        :list\n        :else\n        :vector))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "56618573e4b068f2fe63dc68"}, {"problem": 65, "code": "(fn [x]\n  (let [t (empty x)]\n    (cond\n     (= t {}) :map\n     (= t '()) (if (reversible? t) :vector :list)\n     (= t #{}) :set)))", "user": "557673f3e4b05c286339e06c"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "5933b736e4b072a2710fd05d"}, {"problem": 65, "code": "(fn poke [coll]\n  (if (= (conj coll [1 2]) (conj (conj coll [1 1]) [1 2]) )\n    :map\n    (if (= (conj coll [1 1]) (conj (conj coll [1 1]) [1 1]))\n      :set\n      (if (= (peek (conj (conj coll 1000) 999)) (first (conj (conj coll 1000) 999)))\n        :list\n        :vector\n        ))\n    ))", "user": "58db362be4b0a4d5acaab675"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (:a (conj c [:a \"A\"])) \"A\") :map\n    (= (:a (conj c :a)) :a) :set\n    (= (last (conj c :a :b)) :b) :vector\n    (= (first (conj c :a)) :a) :list))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 65, "code": "#(if (associative? %)\n   (if (= 1 (count (conj (empty %) [:a 1] [:a 1])))\n     :map\n     :vector)\n   (if (= 1 (count (conj (empty %) :a :a)))\n     :set\n     :list))", "user": "59074b7ce4b047aa04b19951"}, {"problem": 65, "code": "(fn [x] \n  (cond \n   (= \"test\" (get (conj x [:test \"test\"]) :test)) :map\n   (= \"test\" (get (conj x \"test\") \"test\")) :set\n   (= \"test2\" (first (conj (conj x \"test\") \"test2\"))) :list\n   (= \"test2\" (last (conj (conj x \"test\") \"test2\"))) :vector\n  ))", "user": "59385840e4b02506e01a29c9"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "58e51bc5e4b056aecfd47c86"}, {"problem": 65, "code": "(fn [s]\n  (if (= (+ 2 (count s)) (count (conj s {2 3 4 5})))\n    :map\n    (if (= (+ 1 (count s)) (count (conj (conj s nil) nil)))\n      :set\n      (if (= 2 (first (conj (conj s 1) 2)))\n        :list\n        :vector))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 65, "code": "#({\\{ :map\n  \\c :list\n  \\[ :vector\n  \\# :set}\n     (first (str %)))", "user": "55630cc1e4b0c656e3ff17e0"}, {"problem": 65, "code": "(fn [coll]\n    (if (reversible? coll)\n         :vector\n        (condp = (empty coll)\n          {}   :map\n          #{} :set\n          ()  :list\n          )))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 65, "code": "(fn [c]\n  (let [e (empty c)]\n    (case e\n      {} :map\n      [] (if (= (last (conj (conj c ::a) ::last)) ::last) :vector :list)\n      #{} :set)))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "593d6793e4b069cdc2982ba6"}, {"problem": 65, "code": "(fn [coll]\n   \t(cond \n   \t(= (inc (count coll)) (count (conj coll {:c 3} {:c 4}))) :map\n   \t(= (inc (count coll)) (count (conj coll \"test\" \"test\"))) :set\n    (= \"test1\" (last (conj coll \"test\" \"test1\"))) :vector\n   \t(= \"test1\" (first (conj coll \"test\" \"test1\"))) :list\n   \t)\n   \t)", "user": "592518cde4b072a2710fce66"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 65, "code": "(fn ff[coll]\n    (case ((juxt associative? reversible? ifn?) coll) \n      [true true true] :vector\n      [false false false] :list\n      [true false true] :map\n      [false false true] :set))", "user": "585a7cb2e4b0f14aab7c874e"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5938bae2e4b02506e01a29ea"}, {"problem": 65, "code": "(fn get-class [values]\n  (cond\n    (= (get (conj values [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj values :b) :b) :b) :set\n    (= (first (conj (conj values :a) :b)) :b) :list\n    (= (last (conj (conj values :a) :b)) :b) :vector\n   ))", "user": "594d4c43e4b07ddc2dafae86"}, {"problem": 65, "code": "(fn [sq]\n  (case (str (empty sq))\n    \"()\"  :list\n    \"{}\"  :map\n    \"[]\"  :vector\n    \"#{}\" :set\n    :list\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 65, "code": "(fn judge [obj]\n  (if (= 2 (get (conj obj {:test 2}) :test))\n    :map\n    (if (= nil (get (conj obj 0) 0))\n      :list\n      (if (= (+ 2 (count obj)) (count (conj obj 0 0)))\n        :vector\n        :set))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5950f0bfe4b066ee0a44ae9f"}, {"problem": 65, "code": "(fn [s]\n (let [s (empty s)]\n  (cond\n   (= (:a (into s {:a :b})) :b)\n   :map\n   (= (into s '(:a :a)) (into s '(:a)))\n   :set\n   (= (last (into s '(:a :b))) :b)\n   :vector\n   (= (first (into s '(:a :b))) :b)\n   :list )))", "user": "594c1baae4b07ddc2dafae59"}, {"problem": 65, "code": "(fn [coll]\n  (let [emp (empty coll)\n        t2223 (count (conj emp [2 2] [2 3]))]\n    (if (= t2223 1)\n      :map\n      (let [t22 (count (conj emp 2 2))\n            t12 (conj emp 1 2)\n           firstel (first t12)]\n       (cond\n        (= t22 1) :set\n        (= firstel 1) :vector\n        (= firstel 2) :list)))))", "user": "592334c7e4b0a390037439ee"}, {"problem": 65, "code": "(fn [s]\n    (if (associative? s)\n      ;; maps and vectors are associative\n      (if (reversible? s)\n        :vector\n        :map)\n      ;; sets and lists are not associative\n      (let [testmo (range 100)\n            digestmo (reverse (apply list (into (empty s) testmo)))]\n        (if (= testmo digestmo)\n          :list\n          :set))))", "user": "54965534e4b0b312c081ff65"}, {"problem": 65, "code": "(fn [coll]\n   \t(cond \n   \t(= (inc (count coll)) (count (conj coll {:c 3} {:c 4}))) :map\n   \t(= (inc (count coll)) (count (conj coll \"test\" \"test\"))) :set\n    (= \"test1\" (last (conj coll \"test\" \"test1\"))) :vector\n   \t(= \"test1\" (first (conj coll \"test\" \"test1\"))) :list\n   \t)\n   \t)", "user": "592518e8e4b072a2710fce67"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 65, "code": "#(case ((juxt associative? reversible? ifn?) %)\n   [true  true  true ] :vector\n   [false false false] :list\n   [true  false true ] :map\n   [false false true ] :set)", "user": "594cb88be4b07ddc2dafae6e"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "595a885be4b066ee0a44afc4"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "59251947e4b072a2710fce69"}, {"problem": 65, "code": "(fn [s]\n    (let [t :this-is-a-test-value-argh]\n      (cond\n        (= t (get (conj s [t t]) t)) :map\n        (= (inc (count s)) (count (conj s t t))) :set\n        (= t (first (conj (conj s (str t)) t))) :list\n        :else :vector)))", "user": "595bbab7e4b066ee0a44afe0"}, {"problem": 65, "code": "(fn [coll]\n\t(cond \n      (:abcd (conj coll [:abcd :efgh])) :map \n      (= coll (into #{} coll)) :set \n      (let [collplus1 (conj coll :abcd)] \n        (= (first collplus1) (first (conj collplus1 :efgh)))) :vector \n      (let [collplus1 (conj coll :abcd)] \n        (= (last collplus1) (last (conj collplus1 :efgh)))) :list))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 65, "code": "#(case (vec (into (empty %) [[:a :a] [:a :a] [:a :b]]))\n   [[:a :a] [:a :a] [:a :b]] :vector\n   [[:a :b] [:a :a] [:a :a]] :list\n   [[:a :a] [:a :b]] :set\n   [[:a :b]] :map)", "user": "5956c6dae4b066ee0a44af61"}, {"problem": 65, "code": "#(case (conj (empty %) [1 2] nil)\n   {1 2} :map\n   #{[1 2] nil} :set\n   [[1 2] nil] :vector\n   :list)", "user": "595eba88e4b066ee0a44b04e"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5964f9b0e4b069c0a1a19778"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "591e0782e4b09b4ee5954c25"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= empty-coll {}) :map\n      (= empty-coll #{}) :set\n      (= empty-coll '()) (if (reversible? coll) :vector :list)\n     )))", "user": "56078b7be4b08b23635d3181"}, {"problem": 65, "code": "(fn f65\n  [col]\n  (cond (= \\{ (nth (str col) 0)) :map\n        (= \\[ (nth (str col) 0)) :vector\n        (= \\# (nth (str col) 0)) :set\n        :else :list))", "user": "59390a35e4b02506e01a29f3"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "596c7c7be4b069c0a1a19830"}, {"problem": 65, "code": "(fn [c]\n    (let [emptied (empty c)\n          mapset {{} :map #{} :set}]\n         (if (nil? (get mapset emptied))\n             (if (= (first (conj emptied 1 2)) 2)\n                 :list\n                 :vector)\n             (get mapset emptied))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 65, "code": "(fn [coll]\n  (if (= (count (conj coll [:a 1])) (count (conj (conj coll [:a 1]) [:a 1])))\n      (if (= 1 (get (conj coll [:a 1]) :a))\n          :map\n          :set)\n      (if (= :b (first (conj coll :a :b)))\n          :list\n          :vector)))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 65, "code": "(fn [coll]\n  (let [empt (empty coll)]\n    (cond\n     \t(= empt {}) :map\n     \t(= empt #{}) :set\n     \t(= empt '()) (if (reversible? coll) :vector :list)\n     )\n   )\n)", "user": "59073e0fe4b047aa04b19950"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5972fcf6e4b01722bebd4c92"}, {"problem": 65, "code": "(fn [x]\n   (let [e (empty x)]\n     (cond\n       (identical? () e) :list\n       (= {} e) :map\n       (= [] e) :vector\n       :else :set)))", "user": "5400e918e4b0de5c41848619"}, {"problem": 65, "code": "#(condp = (nth (str %) 0)\n   \\{ :map\n   \\c :list\n   \\[ :vector\n   \\# :set)", "user": "594cf4f1e4b07ddc2dafae77"}, {"problem": 65, "code": "(fn [coll]\n  (if (= (:a (conj coll [:a 1])) 1)\n    :map\n    (let [coll (if (empty? coll)\n      (into coll\n      (range 5))\n      coll)]\n      (cond\n        (= (count (conj coll (first coll))) (count coll))\n        :set\n        (= (first (conj coll coll)) coll)\n        :list\n        (= (last (conj coll coll)) coll)\n        :vector\n        :else\n        :unknown))))", "user": "58a413b5e4b02bd94d917f07"}, {"problem": 65, "code": "(fn mtype[col] (\n    \n      let [test1\n        (#(let [ex (empty %)]\n                (case ex\n                  {} :map\n                  [] :vector\n                  #{} :set\n                )\n          ) col)]\n        \n        (if (= test1 :vector)\n        (if (= (first (conj col 41 42)) 42)\n            :list\n            test1\n        )\n        test1\n        )\n  ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 65, "code": "(fn \n  [col]\n  (let [coll (str col)]\n  (cond\n   (re-seq #\"^[\\[].*[\\]]$\" coll) :vector\n   (re-seq #\"^[\\(].*[\\)]$\" coll) :list\n   (re-seq #\"^[\\{].*[\\}]$\" coll) :map\n   (re-seq #\"^[\\#][\\{].*[\\}]$\" coll) :set\n   :else :list\n    )\n    \n    ))", "user": "59692530e4b069c0a1a197e4"}, {"problem": 65, "code": "#(let [xs (conj % [:a :a] [:a :a] [:b :b])]\n  (cond\n    (= '([:b :b] [:a :a] [:a :a]) (take 3 xs)) :list\n    (contains? xs [:a :a]) :set\n    (contains? xs :a) :map\n    :else :vector))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 65, "code": "(fn [x]\n    (let [[sym1 sym2] [(gensym) (gensym)]\n          [elt1 elt2] [[sym1 sym1] [sym1 sym2]]\n          aug (into x [elt1 elt1 elt2])]\n      (cond\n        (= (inc (count x)) (count aug)) :map\n        (= (+ 2 (count x)) (count aug)) :set\n        (= elt2 (first aug)) :list\n        :default :vector)))", "user": "4e837808535db62dc21a62d9"}, {"problem": 65, "code": "(fn loci [sekv]\n  (if (empty? sekv)\n    (loci (conj sekv {:dido 21}))\n    (if (empty? (flatten sekv))\n      (if (nil? (get sekv (first sekv))) :map :set)\n      (if (nil? (get sekv 0)) :list :vector))))", "user": "584d99c5e4b0b7285a6f4e42"}, {"problem": 65, "code": "(fn [s]\n  (cond\n   (= :man (get (conj s [:hey :man]) :hey)) :map\n   (= [2 1 1] (take 3 (conj s 1 1 2))) :list\n   (= [1 1 2] (take-last 3 (conj s 1 1 2))) :vector\n   (= [8 9 10] (->> (conj s 8 9 9 10) sort (take-last 3))) :set))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 65, "code": "(fn [s] (let [es (empty s)] (case es {} :map #{} :set [] (if (= (first (conj es 1 2)) 2) :list :vector))))", "user": "59468de7e4b07ddc2dafad88"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "587ee260e4b052da650a6353"}, {"problem": 65, "code": "#(cond\n   (= % (conj % {})) :map\n   (= (conj % 'a 'a) (conj % 'a)) :set\n   (= (first (conj % 'a 'b)) 'b) :list\n   :else :vector)", "user": "590b055ae4b047aa04b199c9"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "58b9922ce4b0888cdc949cd0"}, {"problem": 65, "code": "(fn [s]\n   (let [result (conj (empty s) [1 2] [1 2] [1 3])]\n     (cond \n           (= 1 (count result)) :map\n           (= 2 (count result)) :set\n           (= [1 2] (first result)) :vector\n           :else :list)))", "user": "54c72b19e4b045293a27f636"}, {"problem": 65, "code": "(fn data-type\n  [coll]\n  (case (merge (empty coll) [:a :b])\n        {:a :b} :map\n        #{[:a :b]} :set\n        [[:a :b]] (if (= [:a :b] (conj (empty coll) :a :b))\n                      :vector\n                      :list)))", "user": "58fc52cee4b0438e51c2cf95"}, {"problem": 65, "code": "(fn problem65 [coll]\n  (let [feed [[:c 1] [:c 1] [:c 2]]\n        coll1 (reduce conj (empty coll) feed)\n        size (count coll1)]\n\n    (cond\n      (= size 1) :map\n      (= size 2) :set\n      (and (= size 3) (= (first coll1) [:c 2])) :list\n      :else :vector)\n    ))", "user": "5727031ee4b0c5bde472c12f"}, {"problem": 65, "code": "(comp {\\{ :map \\# :set \\[ :vector \\c :list} first str)", "user": "5884f377e4b0f1effa3b76a8"}, {"problem": 65, "code": "(fn [s]\n  (let\n   [delta #(- (count %1)\n              (count %2))\n    x1 [:x 1]\n    x2 [:x 2]]\n   (if\n    (= \n     (delta\n      (conj s x1 x1)\n      s) 2)\n    (if\n     (= (first (conj s x2 x1))\n        x1)\n     :list :vector)\n    (if\n     (=\n      (delta\n       (conj s x1 x2)\n       s) 2)\n     :set :map))))", "user": "598ab445e4b02b9968b84ce0"}, {"problem": 65, "code": "(fn [input]\n    (letfn [(is-associative? [s]\n              \t\t\t\t (let [first-elem (first s)\n                                   conj'd (conj s first-elem)\n                                   double-conj'd (conj conj'd first-elem)]\n                                   ; A sequence is associative if inserting\n                                   ; an element is idempotent\n                                   (= conj'd double-conj'd)\n                             )\n            )\n            ; Map is the only type unaffected by nil insertions\n            (is-map? [s] (= s (conj s nil)))        \n            (is-list? [s]\n                        (let [first-elem (first s)\n                              wrapped (vector first-elem)\n                              nil'd (conj s nil)\n                              conj'd (conj nil'd wrapped)]\n                             ; We've inserted two known elements into the list\n                             ; (we needed two to properly handle the empty\n                             ; edge case). If the first item in the sequence is\n                             ; untouched\n                             (= wrapped (first conj'd))\n                        )\n            )]\n            (if (is-associative? input)\n                (if (is-map? input) :map :set)\n                (if (is-list? input) :list :vector)\n            )\n    )\n)", "user": "5990fcb9e4b0866487ed0d5b"}, {"problem": 65, "code": "#(let [x (empty %)]\n   (cond\n    (= x {}) :map\n    (= x #{}) :set\n    (= x '()) (if (reversible? x) :vector :list)))", "user": "59922473e4b0866487ed0d72"}, {"problem": 65, "code": "(fn [coll]\n  (let [item [:a 1] c (conj (conj (empty coll) item) item)]\n    (if (= 1 (count c))\n      (if (get c :a) :map :set)\n      (if (= 1 (first (conj c 1))) :list :vector))))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 65, "code": ";\n; Cribbed from qiuxiafei\n;\n\n#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "594266cfe4b060784b3b790b"}, {"problem": 65, "code": "(fn bbt [s]\n  (let [z (conj (empty s) [:a :b] [:c :d])]\n    (cond\n     (:a z) :map\n     (get z 0) :vector\n     (get z [:a :b]) :set\n     :else :list)))", "user": "597a4277e4b02382a38ad1e2"}, {"problem": 65, "code": "(fn a [coll]\n  (cond \n    (= coll (vec coll)) \n      (let [items (conj coll :x :y)]\n        (if (= (last items) :y)\n          :vector\n          :list\n        )\n      )\n    (= coll (set coll)) :set\n    :else :map\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 65, "code": "(fn my-type [col]\n  (if (= 0 (count col))\n    (let [cnj (conj col col)]\n      (if (zero? (count cnj))\n        :map\n        (my-type cnj)))\n    (let [fst (first col)\n          cnj (conj col fst)]\n      (if (= (count col) (count cnj))\n        (if (= fst (col fst))\n          :set\n          :map)\n        (if (= col (first (conj col col)))\n          :list\n          :vector)))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 65, "code": "(fn eka\n    ([xs]\n     (if-not (get (conj xs [:darth :vader]) :darth)\n       (let\n         [t (conj (conj xs :darth) :vader)]\n         (cond\n           (get t :darth) :set\n           (= (first t) :vader) :list\n           (= (last t) :vader) :vector\n           )\n         )\n       :map\n       )))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 65, "code": "#({{0 1 1 0} :map #{[0 1] [1 0]} :set [[0 1] [1 0]] :vector '([1 0] [0 1]) :list} (conj (empty %) [0 1] [1 0]))", "user": "59a24c92e4b066c664927d20"}, {"problem": 65, "code": "(fn which? [coll]\n  (let [test-val [123, 234]\n        conjed   (conj coll [1, 2] test-val test-val)]\n    (cond\n     (= (last conjed) test-val) (if (= 2 (- (count conjed) (count coll))) :set :vector)\n     (= (first conjed) test-val) (if (= 2 (- (count conjed) (count coll))) :map :list))))", "user": "59971e2de4b07157cc8daacc"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (= x (conj x x)) :map\n    (empty? x) (cond\n                (= (clojure.set/union x x) #{}) :set\n                (= (conj (conj x 0) 1) '(1 0)) :list\n                :else :vector)\n    (= (clojure.set/union x x) x) :set\n    (= (first (conj x x)) x) :list\n    (= (last (conj x x)) x) :vector))", "user": "59a6f1c7e4b066c664927d89"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5845531de4b089d5ab817e63"}, {"problem": 65, "code": "#(cond (reversible? %) :vector\n       (associative? %) :map\n       (= (set %) %) :set\n       :else :list)", "user": "59abbd68e4b08cbb53654da3"}, {"problem": 65, "code": "(fn [col] (let [base (empty col)]\n            (cond\n             (= base {}) :map\n             (= base #{}) :set\n             (= base '()) (if (reversible? col) :vector :list))))", "user": "595fe3f6e4b066ee0a44b073"}, {"problem": 65, "code": "#(cond\n  (reversible? %) :vector\n  (associative? %) :map\n  (= (- (count (conj % 1 1)) (count %)) 2) :list\n  :else :set)", "user": "59adec09e4b0e1f4e384c897"}, {"problem": 65, "code": "#(let [x (empty %)] \n   (cond\n     (= x #{}) :set\n     (= x {}) :map\n     (= (first (conj x 1 2)) 1) :vector\n     :else :list))", "user": "59adb1cee4b0e1f4e384c891"}, {"problem": 65, "code": "(fn checkType [seq]\n   (let [\n              x 1\n              y 2\n              emptySeq (empty seq)\n              ]\n     \n     (let [aux (conj emptySeq [:a 1] [:a 2] [:a 3])]\n       (if (= 1 (count aux))\n         :map\n         (let [x 1\n               y 2\n               emptySeq (conj (empty seq) x y)]\n           (if (= y (first emptySeq))\n             :list\n             (if (= (count (conj emptySeq x)) (count emptySeq))\n               :set\n               :vector\n               )\n             )\n           )\n         )\n       )\n          \n        )\n   \n     )", "user": "583f1533e4b089d5ab817dc8"}, {"problem": 65, "code": "#(cond\n  (= 0 (count %)) \n   (cond\n    (= % {}) :map\n    (= % #{}) :set\n    (= [1 2] (conj (conj % 1) 2)) :vector\n    :else :list)\n  (> (count (flatten (seq %))) (count %)) :map\n  (= 1 (- (count (conj (conj % -999) -999)) (count %))) :set\n  (= -999 (first (conj % -999))) :list\n  (= -999 (last (conj % -999))) :vector\n  :else :wumpel)", "user": "59089229e4b047aa04b1997c"}, {"problem": 65, "code": ";(fn type* [item]\n;  (let [e (empty item)]\n;    (cond\n;     (= e #{}) :set\n;     (= e {}) :map\n;     (= [1 2] (conj (conj e 1) 2)) :vector\n;     (= [2 1] (conj (conj e 1) 2)) :list\n;     :else :unknown)))\n\n#(cond\n  (= (conj % nil) %) :map\n  (= (conj % 0) (conj % 0 0)) :set\n  (= (conj % 0 1) (cons 1 (cons 0 %))) :list\n  (= (conj % 0 1) (conj (vec %) 0 1)) :vector)", "user": "59b1c2eae4b0e1f4e384c8ec"}, {"problem": 65, "code": "#(let [brackets (empty %)]\n   (cond\n    (= brackets {}) :map\n    (= brackets #{}) :set\n    (= brackets '()) (if (reversible? %) :vector :list)))", "user": "59b554cee4b05c620303ca0f"}, {"problem": 65, "code": "#(case (get (str %) 0)\n            \\{ :map\n            \\# :set\n            \\( :list\n            \\[ :vector\n            \\c :list)", "user": "571dd145e4b0145328a76283"}, {"problem": 65, "code": "(fn [coll] \n  (cond\n    (= :V (:K (conj coll {:K :V}))) :map\n    (= (count (conj coll :K)) (count (conj coll :K :K))) :set\n    (= (first (conj coll :K1 :K2)) :K2) :list\n    :else :vector))", "user": "59a72effe4b066c664927d94"}, {"problem": 65, "code": "(fn [x]\n  (let [x (empty x)]\n    (if (= [1 1] (get (conj x [1 1]) [1 1]))\n      :set\n      (if (= 1 (get (conj x [1 1]) 1))\n        :map\n        (if (= 1 (first (conj x 0 1)))\n          :list\n          :vector)))))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 65, "code": "(fn tst\n  [collection]\n  (if (associative? collection)\n    (if (= 2 (- (count (conj collection [1 1] [1 1])) (count collection)))\n      :vector\n      :map)\n    (if (= 2 (- (count (conj collection 1 1)) (count collection)))\n      :list\n      :set)))", "user": "5888b75fe4b0f1effa3b771b"}, {"problem": 65, "code": "(fn[coll]\n        (let [tmp (conj (empty coll)\n                        [:key :vector] [:key :list] [:key :list])\n              cnt (count tmp)]\n          (cond\n           (= 1 cnt)\n           :map\n\n           (= 2 cnt)\n           :set\n\n           :else\n           (-> tmp first second))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 65, "code": "(fn [t]\n   (cond\n     (= (get (conj t [:c 3]) :c) 3) :map\n     (= (get (conj t 100) 100) 100) :set\n     (= (first (conj (conj t 100) 101)) 101) :list\n     (= (last (conj (conj t 100) 101)) 101) :vector))", "user": "57481f1fe4b009280f9f2b82"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "59a5f023e4b066c664927d70"}, {"problem": 65, "code": "(fn [c]\n  ({#{} :set\n    {}  :map} (empty c) \n              (if (reversible? c)\n                :vector\n                :list)))", "user": "57262710e4b0c5bde472c120"}, {"problem": 65, "code": "(fn get-type\n  [coll]\n  (if (empty? coll)\n    (let [conjd (conj coll [:a 10] [:b 10] [:a 10] [:c 10])]\n      (if (= {:a 10 :b 10 :c 10} conjd)\n        :map\n        (if (= 3 (count conjd))\n          :set\n          (if (= [:c 10] (first conjd))\n            :list\n            :vector))))\n    (let [f (first coll)\n          conjd (conj coll f)\n          flattened (flatten (conj [] f))]\n      (if (= 1 (Math/abs (- (count conjd) (count coll))))\n        (if (= coll (butlast conjd))\n          :vector\n          :list)\n        (if (= 2 (count flattened))\n          :map\n          :set)))))", "user": "59b62f8de4b05c620303ca1f"}, {"problem": 65, "code": "(fn inspect [c] \n(or\n  (if (= :b (:a (conj c [:a :b]))) :map)\n  (if (= (conj c 1) (conj c 1 1)) :set)\n  (if (= (last (conj c 2 1)) 1) :vector)\n  :list\n))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 65, "code": "(fn find-type\n  [xs]\n  (cond\n    (= (get  (conj xs [:newkey :newval]) :newkey ) :newval) :map\n    (= (get (conj xs \"new\" ) \"new\") \"new\") :set\n    (= (last (apply conj xs [\"start\" \"end\"])) \"end\") :vector\n    (= (first (conj xs \"new\")) \"new\") :list))", "user": "59afe4bae4b0e1f4e384c8c0"}, {"problem": 65, "code": "#(let [ a [:k 1], b1 [:k 2] b2 [:k 2], x ( conj % a b1 b2) ]\n   (cond\n    (= (count x) (+ 1 (count %))) :map\n    (= (count x) (+ 2 (count %))) :set\n    (= (first x) b2) :list    \n    :else :vector))", "user": "59bdf0eae4b0a024fb6ae42e"}, {"problem": 65, "code": "#(condp = (nth (str %) 0)\n   \\{ :map\n   \\c :list\n   \\[ :vector\n   \\# :set)", "user": "592fa9f8e4b072a2710fcfcb"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [x [:a 1]\n        y [:b 2]\n        test-coll (into (empty coll) [x x y])\n        has-unique-keys (= (count test-coll) 2)]\n    (if has-unique-keys\n      (if (= (:a test-coll) 1)\n        :map\n        :set\n        )\n      (if (= (first test-coll) y)\n        :list\n        :vector\n        ))))", "user": "59cc4d5ee4b0a024fb6ae5d0"}, {"problem": 65, "code": "(fn f [seq]\n  (cond\n   (= (+ (count seq) 2) (count (conj seq {:foo 1 :bar 2}))) :map\n   (= (count (conj seq \"foo\")) (count (conj (conj seq \"foo\") \"foo\"))) :set\n   (= \"bar\" (first (conj (conj seq \"foo\") \"bar\"))) :list\n   (= (first (conj seq \"first\")) (first (conj (conj seq \"first\") \"foo\"))) :vector\n   :else f))", "user": "539eb153e4b0ca733b97448e"}, {"problem": 65, "code": "(fn [c] (let [d (conj c {0 1} {0 2} {0 1})] (cond (= \n(+ 1 (count c)) (count d)) :map (= (+ 2 (count c)) (count d)) :set (= (cons \n{0 3} d) (conj d {0 3})) :list true :vector)))", "user": "59358f74e4b04f87174def52"}, {"problem": 65, "code": "(fn identify [col]\n  (let [probe (conj col [:xxx :b] [:xxx :aaa])]\n    (cond\n      (= :aaa (:xxx probe)) :map\n      (= (get probe [:xxx :aaa]) [:xxx :aaa]) :set\n      (= (first probe) [:xxx :aaa]) :list\n      (= (last probe) [:xxx :aaa]) :vector)))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 65, "code": "(fn [coll]\n(cond\n  (= coll (vec coll)) (\n    cond \n    (= (-> coll (conj 1) (conj 2)) (-> (seq coll) (conj 1) (conj 2))) :list\n    :else :vector\n    )\n  :else \n  (cond\n    (= (-> coll (conj [:a 1]) (conj [:a 2]) count) (-> coll seq (conj [:a 1]) (conj [:a 2]) count)) :set\n    :else :map\n    )\n  ))", "user": "59cf4013e4b0ef0a1e9b5b68"}, {"problem": 65, "code": "(fn [x]\n  (condp = (:class (bean x))\n    clojure.lang.PersistentArrayMap :map\n    clojure.lang.LazySeq :list\n    clojure.lang.PersistentList$EmptyList :list\n    clojure.lang.PersistentVector :vector\n    clojure.lang.PersistentHashSet :set))", "user": "559057c4e4b027778923766e"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "537657f2e4b06839e8705e22"}, {"problem": 65, "code": "(fn __ [s]\n (if (associative? s) ; vector or map\n   (if (reversible? s) :vector :map)\n    (let [sadd (into s [:notempty])]\n     (if (= (count sadd) (count (into sadd sadd))) :set :list))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 65, "code": "(fn [data]\n    (cond (or (= data {}) (:a data))\n          :map\n\n          (= (inc (count data)) (count (conj data :data :data :data)))\n          :set\n\n          (= (first (conj data 20 21)) 21)\n          :list\n\n          (= (last (conj data 20 21)) 21)\n          :vector))", "user": "5777cffae4b0979f89651651"}, {"problem": 65, "code": "#(let [c (conj (empty %1) [:a :b] [:c :d])]\n   (cond\n     (= (get c [:a :b]) [:a :b])\n     :set\n\n     (= (get c :a) :b)\n     :map\n\n     (= (first c) [:c :d])\n     :list\n\n     (= (first c) [:a :b])\n     :vector))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (get (conj s [:x \"x\"]) :x) \"x\") :map\n    (= (get (conj s :x) :x) :x) :set\n    (= (first (conj (conj s :x) :y)) :y) :list\n    (= (last (conj (conj s :x) :y)) :y) :vector\n    )\n  )", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (= (get (conj x [:t \"t\"]) :t) \"t\") :map\n   (= (get (conj x :t) :t) :t) :set\n   (= (first (conj (conj x :a) :b)) :b) :list\n   (= (last (conj (conj x :a) :b)) :b) :vector))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 65, "code": "(fn [x]\n    (let [common-key (gensym)\n          inner-conjed [common-key (gensym)]\n          outer-conjed [common-key (gensym)]\n          new-x (conj (conj (conj x inner-conjed) outer-conjed) outer-conjed)]\n      (case (- (count new-x) (count x))\n            1 :map\n            2 :set\n            3 (if (= outer-conjed (first new-x))\n                :list\n                :vector))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 65, "code": "(fn [c] (condp = \n\t(conj (conj (empty c) [1 1]) [2 2])\n    #{[1 1][2 2]} :set \n    {1 1 2 2} :map \n    [[1 1][2 2]] :vector \n    '([2 2][1 1]) :list))\n\n#_\n#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 65, "code": "(fn [ cl ]\n   (let [ cl (conj cl [ :a 10 ]), insert-val [ :b 10 ], insert-other [ :b 11 ] ]\n     (cond\n       (= (inc (inc (count cl))) (count (conj (conj (conj cl insert-val ) insert-val) insert-other))) :set\n       (= 0 (count (flatten cl))) :map\n       (=  (conj cl insert-val) (cons insert-val cl)) :list\n       (= (last (conj cl insert-val)) insert-val) :vector)))", "user": "59f90e6ae4b0ca45a743a337"}, {"problem": 65, "code": "(fn [d]\n    (cond\n      (= (empty d) '()) (if (reversible? d) :vector :list) \n      (= (empty d) #{}) :set\n      (= (empty d) {}) :map))", "user": "593352b7e4b072a2710fd052"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (= 1 (get (conj x [:a 1]) :a)) :map\n    (let [s (conj x :test)] (= s (set (concat s s)))) :set\n    (= (conj x 1 2) (concat x [1 2])) :vector\n    (= (conj x 1 2) (concat [2 1] x)) :list\n    :else :unknown))\n\n;; One really tidy and tiny solution I've seen is basically just putting\n;; the argument into \"str\" and then map the first character of the string\n;; to the corresponding type: (adjusted to work with more recent Clojure versions as well)\n#_(comp {\\# :set \\{ :map \\[ :vector \\c :list \\( :list} first str)", "user": "59a080e3e4b0871e7608b837"}, {"problem": 65, "code": "(fn [bb]\n  (let [mapped (map identity bb)\n        g (gensym)\n        h (gensym)]\n     (if (= mapped bb)\n        (if (= h (-> (conj bb g) (conj h) first))\n           :list\n           :vector)\n     (if (= h (-> (conj bb {g h}) (get g)))\n        :map\n        :set))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 65, "code": "(fn __ [a]\n  (let [c (subs (str a) 0 1)]\n    (cond (= c \"#\") :set\n          (= c \"{\") :map\n          (= c \"[\") :vector\n          (= c \"(\") :list\n          :else :list)))", "user": "57ed19a3e4b0bfb2137f5b8e"}, {"problem": 65, "code": "#(cond\n   (= % (conj % nil)) :map\n   (= (conj % 1) (conj % 1 1)) :set\n   (not= \\2 (first (conj % \\1 \\2))) :vector\n   (= \\2 (first (conj % \\1 \\2))) :list)", "user": "5a01d8f6e4b01bb0ae8afd53"}, {"problem": 65, "code": "(fn [c]\n  (let [coll (empty c)]\n    (if (= 0 (count (flatten (into coll {:a :a}))))\n      (if (= 1 (count (into (into coll {:a :a}) {:a :b})))\n        :map\n        :set)\n      (if (= 5 (first (conj coll 4 5)))\n        :list\n        :vector))))", "user": "59ba2ea0e4b0a024fb6ae3e1"}, {"problem": 65, "code": "(fn [a]\n  (or\n ({{} :map\n  #{} :set}\n      (empty a))\n (if \n  (= (conj (empty a) 1 2)\n    [1 2])\n  :vector)\n :list))", "user": "56403765e4b08d4f616f5edc"}, {"problem": 65, "code": "(fn getType[coll]\n  (if (empty? coll)\n      (getType (conj coll [1 1]))\n      (let [flattenedList (flatten coll)]\n        (if (empty? flattenedList)\n              (if (= 10 (get (conj coll [1 10]) 1))\n                  :map\n                  :set)\n              (if (= \"myTypeTest\" (first (conj coll \"myTypeTest\")))\n                  :list\n                  :vector)\n        )\n      )))", "user": "571172ece4b09c608db70446"}, {"problem": 65, "code": "(fn  [coll]\n\n  (let [empty-coll (empty coll)]\n     (cond\n       (= empty-coll #{}) :set\n       (= empty-coll {}) :map\n       (reversible? empty-coll) :vector\n       :else :list)))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 65, "code": "(fn [x]\n   ({{} :map #{} :set } (empty x) (if (associative? x) :vector :list))\n)", "user": "56f2611fe4b04a395b9a04a2"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector\n    \n  )\n)", "user": "5a0a25fce4b0eab8c044893d"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "5a1483e8e4b0ff51aa4b319e"}, {"problem": 65, "code": "(fn [x]\n  (let [y (conj x [9 1] [9 1])]\n    (cond \n     (= (inc (count x)) \n        (count y))\n     (if (y 9) :map :set)\n     (= 4 (first (conj y 4))) :list\n     1 :vector)))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n     (:x1 (conj coll [:x1 1])) :map\n     (= 1 (- (count (conj coll :x1 :x1)) \n             (count coll))) :set\n     (= :x2 (first (conj coll :x1 :x2))) :list\n     (= :x2 (last  (conj coll :x1 :x2))) :vector))", "user": "594bc16be4b07ddc2dafae39"}, {"problem": 65, "code": "(fn [l]\n  (cond\n   (identical? (empty l) '()) :list\n   (= (empty l) []) :vector\n   (= (empty l) {}) :map\n   (= (empty l) #{}) :set))", "user": "5a1e93bee4b0ff51aa4b3270"}, {"problem": 65, "code": "#(cond\r\n   (= (empty %) {}) :map\r\n   (= (empty %) #{}) :set\r\n   :else (cond (let [vss2 \"very-specific-string-2\" test (into % (list \"very-specific-string-1\" vss2))] (= (first test) vss2)) :list\r\n               :else :vector))", "user": "580e7761e4b0849f6811b753"}, {"problem": 65, "code": "(fn [coll]\n  (let [sample (conj (empty coll) [1 2] [1 2] [1 3])\n        n (count sample)]\n    (cond\n      (= n 1) :map\n      (= n 2) :set\n      :else (if (= [1 3] (first sample))\n              :list\n              :vector))))", "user": "580a0783e4b0a837a8b30d2c"}, {"problem": 65, "code": "(fn [coll]\n    (let [temp1 [:c 3]\n          temp2 [:c 3]\n          temp3 [:c 4]\n          coll2 (conj coll temp1 temp2 temp3)]\n      (pr coll2)\n      (cond\n        (= (count coll) (- (count coll2) 1)) :map\n        (= (count coll) (- (count coll2) 2)) :set\n        (= (first coll2) temp3) :list\n        :else :vector)))", "user": "59f44189e4b0966464fe6aab"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (not (counted? coll))                               :list\n    (get (conj coll {:a :a}) :a)                        :map\n    (= (inc (count coll)) (count (conj coll :a :a)))    :set\n    (= :b (first (conj coll :a :b)))                    :list\n    :default                                            :vector))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 65, "code": "(fn __ [x]\n  (let [dummy0 [:dummy 0]\n        dummy1 [:dummy 1]\n        y (conj (conj (conj x dummy0) dummy0) dummy1)]\n    (cond\n      (= (:dummy y) 1) :map\n      (= (count y) (+ (count x) 2)) :set\n      (= (first y) dummy1) :list\n      (= (last y) dummy1) :vector)))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 65, "code": "(fn [x] (let [obj (conj (empty x) [:foo 1] [:foo 1] [:foo 2])]\n    (if (= (count obj) 1)\n        :map\n        (if (= (count obj) 2)\n          :set\n          (if (= (first obj) [:foo 1])\n            :vector\n            :list)))))", "user": "59fa5773e4b0ca45a743a35e"}, {"problem": 65, "code": "(fn [x] \n      (if (= 0 (count x)) \n          (cond (= {} x) :map \n                (= #{} x) :set\n                :else  (if (= 5 (first  (conj (conj x 3 ) 5)) ) \n                              :list\n                              :vector\n                        ) \n           )\n           (let [sx (set x) x1 (first x)]\n               (cond (= sx x) :set\n                     (= (conj x x1) x) :map\n                     (= (first (conj x :myd )) :myd) :list\n                     :else :vector\n               )\n           ) \n       )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 65, "code": "(fn [coll]\n    (condp = (empty coll)\n      [] (if (associative? coll)\n           :vector\n           :list)\n      #{} :set\n      {} :map))", "user": "4dc78527535d8a4b2fd7428f"}, {"problem": 65, "code": "(fn [coll]\n  (let [new-coll (conj coll [:bla 2] [:key 1])]\n    (cond (= new-coll (conj new-coll [:key 1])) (if (= nil (new-coll :key)) :set :map)\n          (= [:key 1] (last new-coll)) :vector\n          (= [:key 1] (first new-coll)) :list\n          :else nil)\n    ))", "user": "5a1bec89e4b0ff51aa4b322f"}, {"problem": 65, "code": "(fn [in]\n  (let [l (conj in [:a in] [:c in])]\n    (if\n      (=\n        l\n        (conj l [:a in]))\n      (if\n        (contains? l [:c in])\n        :set\n        :map)\n      (if\n        (=\n          (first l)\n          [:c in])\n        :list\n        :vector))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 65, "code": "(fn [s]\n         (cond (= 1 (get (conj s [:a 1]) :a)) :map\n               (= (conj s :a) (conj (conj s :a) :a)) :set\n               (= 2 (last (conj (conj s 1) 2))) :vector\n               (= 2 (first (conj (conj s 1) 2))) :list))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 65, "code": "(fn [coll]\n  (let [modified (conj (conj coll [:x :a]) [:y :b])]\n    (cond\n      (= (:x modified) :a) :map\n      (contains? modified [:x :a]) :set\n      (= (peek modified) (last modified)) :vector\n      :else :list)))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 65, "code": "(fn [s]\n(let [ box (conj (empty s) [:k :v]) ] \n(cond\n(get box :k) :map\n(get box 0) :vector\n(get box [:k :v]) :set\n:else :list)))", "user": "5a1c8c26e4b0ff51aa4b3247"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5a3c5c54e4b001c08efc0ce3"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 65, "code": "(fn [s] \n  (let [x [:k :v]]\n     (if (= (inc (count s)) (count (into s [x x])))\n       (if (:k (conj s x))\n        :map\n        :set)\n       (if (= :a (first (conj (conj  s :b) :a)))\n      \t:list\n      \t:vector)\n       )\n    )\n  )", "user": "5a535572e4b05d388ecb6c0b"}, {"problem": 65, "code": "(fn [x] \n  (cond\n    (= x (set x)) :set\n    (= x (merge x x)) :map\n    :else (case (first (conj (empty x) 1 2))\n           1 :vector\n           2 :list)))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 65, "code": "(fn  [coll]\n  (let [item [:a :b]\n        once (conj coll item)\n        twice (conj once item)\n        item2 [:c :d]\n        thrice (conj twice item2)\n        f (first once)\n        l (last once)\n        is-linear? (not (= once twice))\n        is-list? (and is-linear? (= item2 (first thrice)))\n        is-vector? (and is-linear? (= item2 (last thrice)))\n        is-set? (and (not is-linear?) (= item (once item)))\n        is-map? (and (not is-linear?) (not is-set?))]\n    (cond is-list? :list\n          is-vector? :vector\n          is-set? :set\n          is-map? :map)))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 65, "code": "(fn [x]\n  (let [is? (fn [^Class c tm] (. c (isInstance tm)))] \n  (cond\n   (is? clojure.lang.IPersistentVector x) :vector\n   (is? clojure.lang.IPersistentSet x) :set \n   (is? clojure.lang.IPersistentMap x)  :map\n   :else              :list)))", "user": "5054c853e4b0b1b9d1860eb3"}, {"problem": 65, "code": "#(case (->> % empty str)\n   \"{}\"  :map\n   \"#{}\" :set\n   \"[]\"  :vector\n   :list)", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 65, "code": "(fn [x]\n  (let [r (-> x (conj [:a 1]) (conj [:b 2]))]\n    (cond\n      (= 2 (:b r)) :map\n      (= r (conj r [:a 1])) :set\n      (= [:b 2] (first r)) :list\n      :else :vector)))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 65, "code": "(fn type- [coll]\n  (let [s (first (str coll))]\n    (case s\n      \\{ :map\n      \\[ :vector\n      \\# :set\n      :list\n      )))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 65, "code": "(fn seq-type [xs]\n  (case (empty xs)\n    {} :map\n    #{} :set\n    (let [s1 (gensym)\n          s2 (gensym)\n          c (conj (conj xs s1) s2)]\n      (if (= s2 (first c)) :list :vector))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 65, "code": "(fn my-type [coll]\n  (let [not-empty [0 1] new-entry [1 2] before (conj coll not-empty) after (conj before new-entry)]\n    (if (= after (conj after new-entry))\n      (if (= (get after 1) 2) :map :set)\n      (if (= (first after) [1 2]) :list :vector))))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 65, "code": "(fn [n]\n  (let [s (str n)]\n       (cond\n        (.contains s \"#\") :set\n        (.contains s \"{\") :map\n        (.contains s \"[\") :vector\n        :else :list)\n       )\n)", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 65, "code": "(fn redu [coll]\n    (cond (and (associative? coll)\n               (counted? coll))\n          (if (= coll (conj coll (first coll)))\n            :map\n            :vector)\n          (= (conj coll ::something) (conj coll ::something ::something)) :set\n          (= (first (conj coll ::something)) ::something) :list\n          :else (throw (Exception. (str \"Unable to determine type\")))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5a34de78e4b0ddc586f153d0"}, {"problem": 65, "code": "(fn black-box [coll]\n  (if (associative? coll)\n    (if (= (vec coll) coll)\n      :vector\n      :map)\n    (if (= (first (vec (conj (conj coll 4) 5))) 5)\n      :list\n      :set)))", "user": "58a6806ee4b01a0c0b23292f"}, {"problem": 65, "code": "(fn tester\n  [testee]\n  (let [testing (-> testee\n                    (conj [:a 1])\n                    (conj [:a 1]))]\n    (if (< 1 (- (count testing) (count testee)))\n        (let [testing (-> testee\n                          (conj :a)\n                          (conj :b))]\n             (if (= (first testing) :b)\n                 :list\n                 :vector))\n        (if (get testing :a)\n            :map\n            :set))))", "user": "5974d2ede4b01722bebd4cb6"}, {"problem": 65, "code": "(fn [x]\n  (let [y (first (str x))]\n    (cond\n      (= y \\{) :map\n      (= y \\#) :set\n      (= y \\[) :vector\n      :else :list)))", "user": "5a067f26e4b01bb0ae8afdcc"}, {"problem": 65, "code": "(fn [coll] (condp = ((juxt associative? reversible? ifn?) coll)\n [true true true] :vector\n [false false false] :list\n [true false true] :map\n [false false true] :set))\n\n;; best one", "user": "5a527beee4b05d388ecb6bfe"}, {"problem": 65, "code": "(fn [coll]\n    (let [conj-test-1 (conj coll #{})\n          conj-test-2 (conj conj-test-1 {})]\n      (cond\n        (= coll conj-test-1 conj-test-2) :map\n        (= (clojure.set/union coll #{{} #{}}) conj-test-2) :set\n        (= (first conj-test-2) {}) :list\n        (= (last conj-test-2) {}) :vector)))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 65, "code": "(fn blackbox [c]\n  (cond (= (count (conj (conj c [:a 2]) [:a 1]))\n           (count (conj c [:a 1]))) :map\n        (= (count (conj (conj c 1) 1)) (count (conj c 1))) :set\n        (= (first (conj (conj c 1) 2)) 2) :list\n        :else :vector))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "527ba29de4b03e8d9a4a7594"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (= {} (empty x)) :map\n    (= #{} (empty x)) :set\n    (= [1 2] (conj (empty x) 1 2)) :vector\n    :else :list))", "user": "4fe88f78e4b07c9f6fd12c45"}, {"problem": 65, "code": "#(if (= % (conj % nil)) :map \n    (if (= (inc (count %)) (count (conj (conj % 23) 23))) :set\n      (if (= 42 (first (conj (conj % 23) 42))) :list :vector)))", "user": "5a3c2a08e4b001c08efc0cdf"}, {"problem": 65, "code": "(fn [coll]\n  (let [[x y] [(gensym) (gensym)]]\n    (case [(associative? coll) (= (conj coll [x y]) (conj coll [x y] [x y]))]\n      [true true] :map\n      [true false] :vector\n      [false false] :list\n      [false true] :set)))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 65, "code": "(fn [coll]\n  (let [elem [:x :y]\n        result (conj coll elem)]\n    (cond\n      (and (associative? coll) (identical? (conj result elem) result)) :map\n      (and (associative? coll) (identical? (last result) elem)) :vector\n      (and (not (associative? coll)) (identical? (conj result elem) result)) :set\n      (and (not (associative? coll)) (identical? (first result) elem)) :list\n      :else (throw (IllegalArgumentException. \"unrecognized type\")))))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 65, "code": "#(let [c conj d count e [:1 :2] f [:2 :1] y (c (c (c % e) e) f)]\n     (cond\n      (get y :1 nil) :map\n      (> (+ (d %) 3) (d y)) :set\n      (= (last y) f) :vector\n      :else :list\n      )\n   )", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5a69be17e4b0512ff01cda14"}, {"problem": 65, "code": "(fn coltype\n  [c]\n  (cond\n    (= :b (:a (into c [[:a :b]]))) :map\n    (< (count (into c [:a :a])) (+ (count c) 2)) :set\n    (= :b (first (into c [:a :b]))) :list\n    :else :vector))", "user": "5a188be3e4b0ff51aa4b31ec"}, {"problem": 65, "code": "#(let [r (str %)]\n   (cond \n     (.contains r \"#\") :set\n     (.contains r \"{\") :map\n     (.contains r \"[\") :vector\n     :else :list)\n   )", "user": "586f3f7ee4b01531a375e9c1"}, {"problem": 65, "code": "#(let [k (gensym :a)\n       x [k :b]\n       X [k :a]\n       S (count %)\n       c (conj % x x X)\n       s (count c)]\n  (cond\n   (= s (+ 2 S)) :set\n   (= :a (get c k)) :map\n   (nil? (get c 0)) :list\n   1 :vector))", "user": "502940a9e4b061fd216be4b8"}, {"problem": 65, "code": "(fn find-class-with-conj [o]\n  (let [key (keyword (gensym))\n        pair [key (gensym)]\n        pair-2 [key (gensym)]\n        first-conj (conj o pair)\n        second-conj (conj first-conj pair-2)\n        set-conj (conj first-conj pair)]\n    (cond\n      (key first-conj) :map\n      (= first-conj set-conj) :set\n      (= pair-2 (first second-conj)) :list\n      :else :vector)))", "user": "5a3b5cfde4b001c08efc0cd4"}, {"problem": 65, "code": "(fn [s]\n  (if (not (nil? (:zzz (conj s [:zzz 1]))))\n    :map\n    (if (not (= s (reverse (reverse s))))\n      :set\n      (if (= \"zzz\" (first (into s [1 2 3 \"zzz\"])))\n        :list\n        :vector))))", "user": "594a7ed1e4b07ddc2dafae02"}, {"problem": 65, "code": "(fn [coll]\n  (cond (= (get (conj coll [:a \"a\"]) :a) \"a\") :map\n        (= (get (conj coll :a) :a) :a) :set\n        (= (first (conj coll :a :b)) :b) :list\n        (= (last (conj coll :a :b)) :b) :vector))", "user": "5a86ad84e4b05369db4d249c"}, {"problem": 65, "code": "#(case (empty %)\n   {}  :map\n   #{} :set\n   (if (= (cons :1 (cons :2 %)) (conj (conj % :2) :1))\n     :list\n     :vector))", "user": "4ed45563535d10e5ff6f52c9"}, {"problem": 65, "code": "(fn [x] (let [test-var (conj x [:k1 :v1] [:k1 :v1] [:k2 :v2])]\n         (cond\n           (= :v1 (:k1 test-var)) :map\n           (not (= (count x) (- (count test-var) 3))) :set\n           (= [:k2 :v2] (first test-var)) :list\n           (= [:k2 :v2] (last test-var)) :vector\n           )))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 65, "code": "(fn[coll]\n  (let [obj (new Object)]\n    (let [x (conj coll [1 2])]\n      (cond\n       (empty? (flatten x)) (if (associative? x) :map :set)\n       (= (first (conj x obj)) obj) :list\n       :else :vector\n       )\n      )))", "user": "5a9be505e4b0d174b936c7cf"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5a4d656fe4b05d388ecb6ba9"}, {"problem": 65, "code": "(fn [coll]\n  (if (associative? coll)\n    (if (= 1 (first (assoc coll 0 1)))\n      :vector\n      :map)\n    (if (= (+ 2 (count coll))\n           (count (conj coll :a :a)))\n      :list\n      :set)))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n       (cond (= empty-coll #{}) :set\n             (= empty-coll {}) :map\n             (ifn? coll) :vector\n             :else :list)))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 65, "code": "(fn [c]\n   (let [c (conj c [:foo :foo] [:foo :foo] [:bar :bar])]\n     (cond\n       (not (nil? (:bar c)))\n       :map\n       (= (get (frequencies c) [:foo :foo]) 1)\n       :set\n       (= (first c) [:bar :bar])\n       :list\n       (= (last c) [:bar :bar])\n       :vector)))", "user": "57023e92e4b08d47c97781da"}, {"problem": 65, "code": "(fn [coll]\n  (if (associative? coll)\n    (if (reversible? coll)\n      :vector\n      :map)\n    (if (ifn? coll)\n      :set\n      :list)))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 65, "code": "(fn [col]\n  (let [is-vector? (fn [col]\n                   (let [k 1\n                         v 2]\n                     (= (take-last 2 (conj (conj col k) v)) (vector k v))))\n        is-set?    (fn [col] (let [k (+ 9999 (rand-int 1000))] (= (conj (conj col k) k) (conj col k))))\n        is-map?    (fn [col]\n                   (let [k (+ 9999 (rand-int 1000))\n                         v (+ 9999 (rand-int 1000))]\n                     (= v (get (conj col (vector k v)) k))))]\n    (cond\n      (is-map? col)    :map\n      (is-set? col)    :set\n      (is-vector? col) :vector\n      :else          :list)))", "user": "5a59a76fe4b05d388ecb6c98"}, {"problem": 65, "code": "(fn typetest\n  [coll]\n  (let [n (count coll) t1 {:test 1} t2 {:test 2}]\n    (if (< (count (conj (conj coll t1) t1)) (+ n 2))\n      (if ((conj coll t1) :test)\n        :map\n        :set)\n      (if (= (first (conj (conj coll t1) t2)) t2)\n        :list\n        :vector))))", "user": "5a90395ce4b05369db4d254a"}, {"problem": 65, "code": "(fn __ [dat]\n  (let [c (inc (count dat))\n        s1 (gensym)\n        s2 (gensym)]\n    (cond\n      (= c (count (conj dat [s1 s1] [s1 s2]))) :map\n      (= c (count (conj dat [s1 s1] [s1 s1]))) :set\n      (= (first (conj dat s1 s2)) s2) :list\n      (= (last (conj dat s1 s2)) s2) :vector\n      :else :unknown\n      ))\n    )", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 65, "code": "#(case (first (str %)) \\{ :map \\# :set \\[ :vector :list)", "user": "59e8bb43e4b0249b72820735"}, {"problem": 65, "code": "(fn [x]\n  (let [x (empty x)]\n    (condp = x\n      {} :map\n      #{} :set\n      [] (if (= [0 1] (conj x 0 1))\n           :vector\n           :list))))", "user": "5a9181c5e4b002d099cae6f6"}, {"problem": 65, "code": "#(cond \n  (= ::gnarf (get (conj % [::gnarf ::gnarf]) ::gnarf))\n  :map\n  \n  (= (-> % (conj ::gnarf) count)\n     (-> % (conj ::gnarf) (conj ::gnarf) count))\n  :set\n  \n  (= ::gnarf (-> % (conj ::burf) (conj ::gnarf) first))\n  :list\n  \n  :else\n  :vector)", "user": "51d55795e4b01da06753aa8f"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "58637221e4b0f14aab7c881d"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5ab490f4e4b073f17744261d"}, {"problem": 65, "code": "(fn poke [x]\n  (cond \n    (= x (conj x {})) :map\n    (= (conj x :duck) (apply conj x [:duck :duck])) :set\n    (= :goose (first (apply conj x [:duck :goose]))) :list\n   \t;; could always choose vector at this point but such isn't thorough\n    (= :goose (last (apply conj x [:duck :goose]))) :vector\n  \t:else :unknown))", "user": "55d50a38e4b0e31453f64a80"}, {"problem": 65, "code": "(fn [coll]\n  (if (associative? coll)\n    (if (reversible? coll) :vector :map)\n    (if (apply distinct? (conj coll 1 1)) :set :list)))", "user": "5609d328e4b05f002753deee"}, {"problem": 65, "code": "(fn [s]\n  (let [poked (conj (conj (conj s [:x 1]) [:x 1]) [:x 2])]\n    (cond \n       (contains? poked :x) :map\n       (= (count poked) (+ 2 (count s))) :set\n       (= [:x 2] (first poked)) :list\n       (= [:x 2] (last poked)) :vector\n    )\n  )    \n)", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= (get (conj coll [:t \"t\"]) :t) \"t\") :map\n   (= (get (conj coll :t) :t) :t) :set\n   (= (first (conj (conj coll :t) :v)) :v) :list\n   (= (last (conj (conj coll :t) :v)) :v) :vector))", "user": "5abc5a09e4b073f1774426e9"}, {"problem": 65, "code": "(fn [coll]\n   (cond\n     (= (get (conj coll [:check \"yes\"]) :check) \"yes\") :map\n     (= (get (conj coll :check) :check) :check) :set\n     (= (first (conj (conj coll :check) :uncheck)) :uncheck) :list\n     (= (last (conj (conj coll :check) :uncheck)) :uncheck) :vector))", "user": "5ab23c99e4b073f1774425e2"}, {"problem": 65, "code": "(fn [coll]\n   (cond\n     (= (get (conj coll [:check \"yes\"]) :check) \"yes\") :map\n     (= (get (conj coll :check) :check) :check) :set\n     (= (first (conj (conj coll :check) :uncheck)) :uncheck) :list\n     (= (last (conj (conj coll :check) :uncheck)) :uncheck) :vector))", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 65, "code": "; sorry\n(fn [coll]\n  (condp = ((comp first str) coll)\n    \\{ :map\n    \\# :set\n    \\[ :vector\n    :list))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 65, "code": "#(condp = (empty %)\n    {} :map\n    #{} :set\n    '() ({true :vector false :list} (reversible? %)))", "user": "5a67cedbe4b0512ff01cd9ee"}, {"problem": 65, "code": "#(cond\n   (reversible? %) :vector\n   (not (ifn? %)) :list\n   (associative? %) :map\n   :else :set\n   )", "user": "5ab5f60be4b073f177442643"}, {"problem": 65, "code": "(fn TYPE [col]\n  (let [length (count col)]\n\n    (cond\n      (:1 (conj col [:1 true]))\n      :map\n\n      (= (count (conj col :1 :1)) (+ length 1))\n      :set\n\n      (= length 0)\n      (if (= (first (conj col :1 :2)) :1)\n        :vector\n        :list)\n\n      (= (first (conj col :1 :2)) :2)\n      :list\n      :else :vector\n\n      )\n    ))", "user": "5aa11b37e4b0d174b936c840"}, {"problem": 65, "code": "(fn [coll]\n    (let [element [::some-key ::some-val]\n          coll* (conj coll element element)]\n      (if (= (count coll*) (inc (count coll)))\n        (if (= ::some-val (get coll* ::some-key))\n          :map\n          :set)\n        (let [coll* (-> coll\n                        (conj ::first)\n                        (conj ::second))]\n          (if (= (first coll*) ::second)\n            :list\n            :vector)))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 65, "code": "(fn [s]\n    (let [seq-map {{} :map #{} :set}]\n      (or (get seq-map (empty s))\n          (if (= (first (conj (empty s) :a :b)) :a)\n            :vector\n            :list))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 65, "code": "(fn [c] (cond (= (conj c c) c) :map (= (count (conj (conj c 1) 1)) (inc (count c))) :set (= (last (conj (conj c :x) :y)) :y) :vector :else :list))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 65, "code": "(fn\n  [x]\n  (if (= x (into [] x))\n    (if (empty? x)\n      (if (= :my-weird-thingy-1 (first (conj x :my-weird-thingy-1 :my-weird-thingy-2)))\n        :vector\n        :list)\n      (if (= :my-weird-thingy-1 (first (conj x :my-weird-thingy-1)))\n        :list\n        :vector))\n    (if (= x (into #{} x))\n      :set\n      :map)))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 65, "code": "(fn [x]\n  (cond \n    (= :b (get (conj (empty x) [:a :b]) :a)) :map\n    (= :a (get (conj (empty x) :a ) :a)) :set\n    (= :a (get  (conj (empty x) :a) 0)) :vector\n:else :list))", "user": "5ac85708e4b0e27600da77ac"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5acd235ae4b0e27600da7824"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "553dc991e4b0a04f792994e5"}, {"problem": 65, "code": "#(let [x [(gensym) (gensym)]\n       ? (conj (conj % [0 0]) x)]\n   (cond (get ? (first x)) :map\n         (get ? x) :set\n         (= x (first ?)) :list\n         :else :vector))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 65, "code": "(fn [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n:else :vector))", "user": "4ed90014535d10e5ff6f52fe"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5ae0976be4b0837691e92c43"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list)) \n;not mine", "user": "5ac92dc3e4b0e27600da77bf"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5acd1a43e4b0e27600da7823"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (= 3 (get (conj c [:c 3]) :c)) :map\n   (= (conj c 1) (conj (conj c 1) 1)) :set\n   (= (cons 2 (cons 1 c)) (conj (conj c 1) 2)) :list\n   (= (cons 1 (reverse c)) (reverse (conj c 1))) :vector\n   \n   ))", "user": "5ade6bafe4b0837691e92c23"}, {"problem": 65, "code": "(fn __\n  [collection]\n  (let [first-char (first (str collection))]\n    (case first-char\n      \\( :list\n      \\[ :vector\n      \\{ :map\n      \\# :set\n      :list)))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 65, "code": "(fn [ coll ] \n\t(cond \n\t\t(= (empty coll) {}) :map \n\t\t(= (empty coll) #{}) :set \n\t\t(= (empty coll) '()) (if (reversible? coll) :vector :list)  \n\t\t) \n\t)", "user": "5ac04101e4b073f177442737"}, {"problem": 65, "code": "(fn[coll]\n\t  (let [obj (new Object)]\n\t    (let [x (conj coll [1 2])]\n\t      (cond\n\t        (empty? (flatten x)) (if (associative? x) :map :set)\n\t        (= (first (conj x obj)) obj) :list\n\t        :else :vector\n\t      ))))", "user": "5831846ae4b051871117c02c"}, {"problem": 65, "code": "(fn [x]\n    (let [e (empty x)]\n      (cond\n        (= e {}) :map\n        (= e #{}) :set\n        (reversible? e) :vector\n        :else :list\n        )))", "user": "5a9d64c8e4b0d174b936c7eb"}, {"problem": 65, "code": "(fn [v]  \n  (cond  \n          (:a (conj v [:a 1])) :map  \n          (< (- (count (conj v 1 1)) (count v)) 2) :set  \n          (= (conj v 1 2) (cons 2 (cons 1 v))) :list  \n          :else :vector))", "user": "59d37e3de4b0ef0a1e9b5bb9"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "57fa6f2ee4b0d3187e900962"}, {"problem": 65, "code": "#(let [s (str %)] (cond\n                   (re-matches #\"^\\{.*?\\}$\" s) :map\n                   (re-matches #\"^#\\{.*?\\}$\" s) :set\n                   (re-matches #\"^\\[.*?\\]$\" s) :vector\n                   :else :list\n                   ))", "user": "57086931e4b0b0fb43fd069e"}, {"problem": 65, "code": "(fn\n  [x]\n  (let [a {:a :b}\n        b {:b :a}\n        c (conj x a b)\n        d (flatten c)]\n    (if (= 0 (count d))\n      (if (contains? c a)\n        :set\n        :map)\n      (if (= b (first c))\n        :list\n        :vector))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 65, "code": "#(let [t (first (str %))]\n   (cond (= t \\{ ) :map\n         (= t \\# ) :set\n         (= t \\[ ) :vector\n         :else :list))", "user": "55e732c5e4b050e68259b492"}, {"problem": 65, "code": "(fn [coll] \n    (let [token [:token :token]\n          token2 [:token2 :token2]\n          ccoll (conj coll token token2)]\n      (cond (= (into ccoll ccoll) ccoll)\n            (if (contains? ccoll :token)\n              :map\n              :set)\n            \n            (= token2 (first ccoll))\n            :list\n            \n            (= token2 (last ccoll))\n            :vector)))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 65, "code": "(fn blackbox\n  [coll]\n  (let [kos (empty coll)]\n    (cond\n      (= kos {}) :map\n      (= kos #{}) :set\n      (= kos '()) (if (reversible? coll)\n                    :vector\n                    :list))))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (reversible? x) :vector\n    (associative? x) :map\n    (ifn? x) :set\n    :else :list))", "user": "5adf5f9be4b0837691e92c33"}, {"problem": 65, "code": "#(let [x [1 1]\n       y [1 2]\n       a (reduce conj % [x x y])]\n             (case (- (count a) (count %))\n                1 :map\n                2 :set\n                3 (if (= (first a) y) :list :vector)))", "user": "577202d2e4b0979f896515c0"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "4ee897fe535d93acb0a66883"}, {"problem": 65, "code": ";(fn [coll]\n;  (let [x (empty coll)]\n;    (cond\n;      (= x {})               :map\n;      (= x #{})              :set\n;      (= (conj x 1 2) [2 1]) :list\n;      :else                  :vector)))\n\n#(get (zipmap (map str [() [] {} #{}])\n              [:list :vector :map :set])\n      (str (empty %)))\n\n; Also see https://github.com/4clojure/4clojure/issues/297", "user": "5aa4f7dae4b0d174b936c88c"}, {"problem": 65, "code": "(fn myfn [o]\n  (let [o (empty o)\n        o1 (into o [[1 2] [2 3]])\n        o2 (into o [[1 2] [1 2]])]\n    (cond\n      (= (+ 2 (count o)) (count o2))\n      (condp = (ffirst o1)\n        1 :vector\n        2 :list)\n      :else\n      (cond\n        (nil? (get o2 1)) :set\n        :else :map))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 65, "code": "(fn [xs]\n  (let [c (empty xs)]\n    (cond (= c #{}) :set\n          (= c {}) :map\n          (= (conj c :a :b) [:a :b]) :vector\n          :else :list)))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 65, "code": "(fn tc\n  [o]\n  (cond\n    (and (associative? o) (contains? (into o [[:a :a]]) :a)) :map\n    (= (set o) o) :set\n    (= (first (conj (conj o :a) :b)) :b) :list\n    (= (last (conj (conj o :a) :b)) :b) :vector\n     )\n  )", "user": "583048d9e4b051871117c007"}, {"problem": 65, "code": "#(let [c (empty %)]\n  (cond\n    (= c {}) :map\n    (= c #{}) :set\n    (= (first (conj c 1 2)) 1) :vector\n    (= (last (conj c 1 2)) 1) :list))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 65, "code": "(fn [coll]\n  (cond (= (get (conj coll {:a 1}) :a) 1)\n        :map\n        (= (count coll) (dec (count (conj coll 1 1))))\n        :set\n        (= (conj coll 1) (first (conj (conj coll 1) (conj coll 1))))\n        :list\n        :else :vector))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (cond\n    (= (get (conj coll [::probe 1]) ::probe) 1) :map\n    (= (get (conj coll [::probe 1]) [::probe 1]) [::probe 1]) :set\n    (= (first (conj coll 1 ::probe)) ::probe) :list\n    (= (last (conj coll 1 ::probe)) ::probe) :vector\n    :default (assert false)))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 65, "code": "; This passes all the tests, but not here on 4clojure :(\n;(defn black-box-test [s]\n;  (cond (= [:CCC :DDD] (first (conj (conj s [:AAA :BBB]) [:CCC :DDD]))) :list\n;        (= (last (conj s {1 2})) [1 2]) :map\n;        (= (inc (count s)) (count (conj (conj s 2) 2))) :set\n;        :else :vector))\n\n(fn black-box-test [s]\n  (cond (= {:a 1 :b 2} s) :map\n        (= {} s) :map\n        (= #{} s) :set\n        (= #{10 (rand-int 5)} s) :set\n   \t\t(= [:CCC :DDD] (first (conj (conj s [:AAA :BBB]) [:CCC :DDD]))) :list\n        (= (last (conj s {1 2})) [1 2]) :map\n        (= (inc (count s)) (count (conj (conj s 2) 2))) :set\n        :else :vector))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 65, "code": "(fn [coll] (if (= :y (get (conj coll [:x :y]) :x)) :map (if (= ((frequencies (conj coll :x :x)) :x) 1) :set (if (= (last (conj coll :x :y)) :y) :vector :list))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 65, "code": "(fn bbt[xs]\n  (let [n (count xs)\n        cj (conj (conj (conj xs [:a :b]) [:a :b]) [:c :d])]\n    (cond\n      (= :d(:c cj)) :map\n      (= (count cj) (+ n 2)) :set\n      (= (last cj) [:c :d]) :vector\n      (= (first cj) [:c :d]) :list\n      :else :unknown)))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 65, "code": "#({\\{ :map \\# :set \\[ :vector} (first (str %)) :list)", "user": "593910eae4b02506e01a29f4"}, {"problem": 65, "code": "(fn [s]\n  (let [l (count s) u (gensym)]\n    (cond (= (get (conj s [u u]) u) u) :map\n          (= (count (conj s u u)) (inc l)) :set\n          (= (first (conj s s u)) u) :list\n          true :vector)\n    ))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5b0948f3e4b0cc2b61a3bdbb"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5b47874be4b02d533a91bc70"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (.isInstance clojure.lang.IPersistentMap x) :map\n    (.isInstance clojure.lang.IPersistentVector x) :vector\n    (.isInstance clojure.lang.IPersistentSet x) :set\n    :else :list))", "user": "5777c3d6e4b0979f8965164f"}, {"problem": 65, "code": "(fn [sx]\n  (let [s (empty sx)]\n    (if (= s #{})\n      :set\n      (if (= s {})\n        :map\n        (if (= (conj s 1 2) [1 2])\n          :vector\n          :list)))))", "user": "51316a63e4b0431ba07e7feb"}, {"problem": 65, "code": "(fn [o] (let [obj (empty o)]\n          (if (contains? (conj obj [1 2]) 1)\n            :map\n            (if (= 1 (count (conj obj 1 1)))\n              :set\n              (if (= 1 (first (conj obj 1 2)))\n                :vector\n                :list\n                )))))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 65, "code": "#(if(associative? %)(if(=[](empty %)):vector :map)(case (empty %)#{}:set :list))", "user": "50e5bca5e4b09ae9427b0e75"}, {"problem": 65, "code": "(fn [c]\n  (let [ empty-c (empty c)\n        map-or-vec (fn [e] (if (contains? (conj e [1 2]) 1) :map :vector))\n        set-or-list (fn [e] (if (= 1 (count(conj e 1 1))) :set :list))]\n        (if (associative? empty-c) (map-or-vec empty-c) (set-or-list empty-c))\n  ))", "user": "5b4ff637e4b02d533a91bce0"}, {"problem": 65, "code": "(fn poke [coll]\n  (cond\n    (= (get (conj coll [:k :v]) :k) :v) :map\n    (= (get (conj coll :k) :k) :k) :set\n    (nil? (get (conj coll :v) 0)) :list\n    :else :vector))", "user": "5b552117e4b02d533a91bd2c"}, {"problem": 65, "code": "(fn black-box [coll]\n  (let [k1 (gensym)\n        k2 (gensym)\n        new-coll (into coll [[k1 0] [k2 1]])]\n    (cond\n      (= (get new-coll k1 nil) 0) :map\n      (= (set new-coll) new-coll) :set\n      (= (first new-coll) [k2 1]) :list\n      :else :vector)))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 65, "code": "(fn\n  [coll]\n  (cond\n   (= coll (merge coll coll)) :map\n   (> 2 (- (count (merge coll 1 1)) (count coll))) :set\n   (= 22 (last (conj coll 21 22))) :vector\n   (= 22 (first (conj coll 21 22))) :list))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 65, "code": "#(let [coll (conj % [:test 1])] \n   (if (not= (count (conj coll (first coll))) (count coll))\n     (if (= (last (conj coll [:test2 2])) [:test2 2])\n       :vector\n       :list)\n     (if (= (inc (count coll)) (count (conj coll [:test2 2] [:test2 3])))\n       :map\n       :set)))", "user": "5aeb0b44e4b0cc2b61a3bbee"}, {"problem": 65, "code": "#(let [ecoll (empty %)\n       res (into ecoll [[:z :b] [:z :b] [:z :c]])\n       cr (count res)]\n         (cond\n           (= 1 cr) :map\n           (= 2 cr) :set\n           (= (first res) [:z :c]) :list\n           (= (last res) [:z :c]) :vector))", "user": "5b421edce4b02d533a91bc2c"}, {"problem": 65, "code": "#(case (first (str %))\n   \\# :set\n   \\{ :map\n   \\[ :vector\n      :list)", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 65, "code": "(fn my-type [coll]\n  (let [result (conj coll [:a :b])]\n    (cond\n      (contains? result [:a :b]) :set\n      (= :b (:a result)) :map\n      (= :a (last (conj result :a))) :vector\n      (= [:a :b] (first result)) :list)))", "user": "52ca7711e4b071a8d36bd3e3"}, {"problem": 65, "code": "(fn [coll]\n  (let [setlike (if (empty? coll)\n                  (= (conj (conj coll [1 2]) [3 4]) (conj (conj coll [3 4]) [1 2]))\n                  (= coll (conj coll (first coll))))]\n    (if setlike\n      (let [newcoll (conj coll [0 0])] (if (some #(not (contains? newcoll %)) newcoll) :map :set))\n      (let [startconj (fn [c a b]\n                        (let [newcoll (conj (conj c b) a)]\n                          (and (= a (first newcoll)) (= b (second newcoll)))))]\n        (if (and (startconj coll 1 2) (startconj coll 3 4)) :list :vector)))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 65, "code": "(fn compare-struct [structe]\n  (if (= (:foo (conj structe {:foo :bar})) :bar)\n    :map\n    (let [set-test-val (+ 1 (count structe))]\n      (if (= set-test-val (count (conj structe {2 3} {2 3})))\n        :set\n        (if (= (last (conj structe :blabla :ble)) :ble)\n          :vector\n          :list\n          )\n        ) \n      )\n    )\n  )", "user": "5b5f2990e4b0c6492753e6ea"}, {"problem": 65, "code": "(fn [stuff]\n  (let [e (empty stuff)]\n    (println e)\n    (if (identical? '() e)\n      :list\n      ({[] :vector, {} :map, #{} :set} e))))", "user": "5b2a559be4b063e2438bcc74"}, {"problem": 65, "code": "(fn [element]\n  (let [v (:a element)\n        r (:a (conj element [:a 12]))]\n    (if (and (not= v r) (= r 12))\n      :map\n      (if (= (count element) 0)\n      \t(let [coll (conj element 1 2 2)]\n          (if (= (count coll) 2)\n            :set\n            (if (= (first coll) 1)\n              :vector\n              :list)))\n        (let [f  (first element)\n              b  (count element)\n              a  (count (conj element f))\n              l  (last element)\n              la (last (conj element f))]\n        \t(if (= b a)\n              :set\n              (if (= l la)\n                :list\n                :vector)))))))", "user": "5b13f482e4b0cc2b61a3be58"}, {"problem": 65, "code": "(fn [x]\n    (let [y (conj x [:test :test] [:b :b])]\n      (cond\n        (= :test (:test y))\n        :map\n\n        (= y (conj y [:test :test]))\n        :set\n\n        (= [:b :b] (first y))\n        :list\n\n        :else\n        :vector)))", "user": "5ab1665de4b073f1774425c0"}, {"problem": 65, "code": "#(let [x (conj % [:zz :aa])] \n  (if (= (conj x (first x)) x)\n   (if (x :zz)\n     :map\n     :set\n     )\n   (if (= (conj x :zz) (cons :zz x))\n     :list\n     :vector\n     )\n   )\n  )", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5b62ff3ce4b0c6492753e72a"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (= (get (conj coll [:test 1]) :test) 1) :map\n    (= (get (conj coll :t) :t) :t) :set\n    (= (first (conj (conj coll :a) :b)) :b) :list\n    :else :vector))", "user": "56e2ca59e4b03a7c14b85a38"}, {"problem": 65, "code": "(fn [coll]\n     (let [base (empty coll)]\n       (cond\n         (= base {}) :map\n         (= base #{}) :set\n         (= base '()) (if (reversible? coll) :vector :list))))", "user": "5b67d634e4b0c6492753e76b"}, {"problem": 65, "code": "(fn [x]\n  (let [t (empty x)]\n    (cond (= t {}) :map\n          (= t #{}) :set\n          (= t '()) (if (reversible? t) :vector :list))))", "user": "5b5e7953e4b0c6492753e6d9"}, {"problem": 65, "code": "#(cond\n (= (get (conj % [:t 3]) :t) 3) :map\n (= (get (conj % :t) :t) :t) :set\n (= (first (conj (conj % :a) :b)) :b) :list\n (= (last (conj (conj % :a) :b)) :b) :vector)", "user": "5b738329e4b047b03b2036b6"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "57ebbf3ae4b0bfb2137f5b66"}, {"problem": 65, "code": "(fn bbt [coll]\n  (let [sym1 (gensym)\n        sym2 (gensym)\n        tester [sym1 sym2]\n        conjed (conj (conj coll [(gensym) (gensym)]) tester)]\n    (cond\n      (= (get conjed sym1) sym2) :map\n      (= (get conjed tester) tester) :set\n      (= (nth conjed 0) tester) :list\n      :else :vector )))", "user": "5779556de4b0979f8965166e"}, {"problem": 65, "code": "(fn [xs]\n  (let [t ::unique-value\n        conjd (conj xs {t 0})\n        sq (seq conjd)]\n    (cond\n     (= (* 2 (count sq)) (count (flatten sq))) :map\n     (= (count (conj xs t)) (count (conj xs t t))) :set\n     (= t (first (conj xs nil t))) :list\n     (= t (last (conj xs nil t))) :vector)))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 65, "code": "#(condp = (-> % str first)\n   \\{ :map\n   \\# :set\n   \\[ :vector\n   \\( :list\n   :list)", "user": "4db1fe241254ad5b4805fa77"}, {"problem": 65, "code": "(fn my-blackbox[a]\n  (if(zero? (count a))\n    (let[b (str(identity a))]\n      (cond\n        (= (first b ) \\#) :set\n        (= (first b) \\{) :map\n        (= (first b) \\[) :vector\n        :else :list\n        ))\n    (if(zero? (count (remove integer? a)))\n      (let [c (conj a 9)]\n        (cond\n          (= (first c) 9) :list\n          (= (last c) 9) :vector\n          :else :set\n          )\n        )\n      :map\n      )\n    ))", "user": "5826a843e4b051871117befd"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5b83c11ae4b047b03b2037b7"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "59cd13d5e4b0ef0a1e9b5b32"}, {"problem": 65, "code": "(fn [c]\n  (let [cc (conj (empty c) [:a 1] [:b 2])]\n    (cond\n      (= cc (vector [:a 1] [:b 2])) :vector\n      (= cc (hash-set [:a 1] [:b 2])) :set\n      (= cc (list [:b 2] [:a 1])) :list\n      (= cc (hash-map :a 1 :b 2)) :map)))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5b88f0c0e4b047b03b203816"}, {"problem": 65, "code": "(fn col-type [col]\n(let [conjed (conj col [5 5] [5 5] [6 6])\n      item-count (count col)]\n(cond \n(= (+ item-count 2) (count conjed)) (if (= (conjed [5 5]) [5 5] )\n                                      :set \n                                      :map)\n (= (first conjed) [6 6]) :list\n (= (last conjed) [6 6]) :vector)))", "user": "592883f1e4b072a2710fceea"}, {"problem": 65, "code": "(fn [given]\n     (let [veccy (vec given)\n           seqOrVec (= veccy given)]\n      \n       (if seqOrVec\n         (if\n           (= (last (conj given :special1 :special2)) :special2) ;must add two items, to differentiate an empty vector from an empty sequence\n           :vector\n           :list)\n         (let [added (into given [[:special-key :special-value-1]])]\n           (if\n             (=\n                (count added)\n                (count\n                  (into added [[:special-key :special-value-2]])))\n             :map\n             :set)))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 65, "code": "; my original solution:\n\n(fn poke [t]\n      (cond\n        (= (get (conj t [:foo \"bar\"]) :foo) \"bar\") :map\n        (= (count (conj t 42)) (count (conj (conj t 42) 42))) :set\n        ;dont like my checks for vector/list atm...\n        (= 43 (last (conj (conj t 42) 43))) :vector\n        (= 43 (first (conj (conj t 42) 43))) :list\n        :else :unknown-type))\n\n; (testfn poke)\n\n;; --------------------------- after looking into other solutions ----------------------------\n\n; omg i love cgrand's solution, it's perfect:\n; empty reduces the testcases essentially to the last testcase: (map __ [{} #{} [] ()])\n; had similar thought with filter/remove but those always return a sequence.\n; TIL: empty :-)", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 65, "code": "(fn black-box-testing [coll]\n  (cond (= \"test\" (:test (into coll [[:test \"test\"]]))) :map\n        (apply distinct? (into coll [\"test\" \"test\"])) :set\n        (= \"test\" (last (into coll [\"toast\" \"test\"]))) :vector\n        (= \"test\" (first (into coll [\"toast\" \"test\"]))) :list\n        :default :OHMY))", "user": "5a0ef454e4b04bbd27e6d9fa"}, {"problem": 65, "code": "#(condp = (first (str %))\n   \\{ :map\n   \\[ :vector\n   \\# :set\n   :list)", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 65, "code": "#(let [k (rand)\n       v (rand)\n       kv [k v]]\n   (cond\n     (= v (get (conj % kv) k)) :map\n     (= (conj % kv) (conj % kv kv)) :set\n     (= (first (conj % [v k] kv)) kv) :list\n     :else :vector))", "user": "4f3ca5a6e4b0e243712b1f53"}, {"problem": 65, "code": ";; flengyel's solution to Black Box Testing\n;; https://4clojure.com/problem/65\n(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "570d0548e4b0b0fb43fd06d2"}, {"problem": 65, "code": "(fn get-seq-type [s]\n  (cond\n    (= :some-val\n       (:some-key (conj s [:some-key :some-val])))     :map\n    (= (conj s :some-el)\n       (conj s :some-el :some-el))                     :set\n    (= :some-el (first (conj s :another-el :some-el))) :list\n    (= :some-el (last (conj s :another-el :some-el)))  :vector))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 65, "code": "#({\n     {}  :map\n     #{} :set\n  }\n  (empty %)\n  (if (reversible? %) :vector :list)\n)", "user": "5b99a0a3e4b0c0b3ffbd4ad7"}, {"problem": 65, "code": "(fn [xs]\n  (case (get (conj (empty xs) [0 1]) 0)\n    [0 1] :vector\n    1     :map\n    (case (count (conj (empty xs) 0 0)) 1 :set 2 :list)))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 65, "code": "(fn type? [x]\n  (cond\n    (and\n      (nil? (get (conj x [0 1]) 0))\n      (nil? (get (conj x 0) 0))) :list\n    (not (nil? (get (conj x [1 2]) [1 2]))) :set\n    (nil? (first (assoc x 0 nil))) :vector\n    :else :map\n  )\n)", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 65, "code": "#(if (= (into % [[:a 1] [:a 1]]) (into % [[:a 1]]))\n   (if (= (count (into % [[:a 1] [:a 2]])) (count (into % [[:a 2]]))) :map :set)\n   (if (= (conj % 0 9) (cons 9 (cons 0 %))) :list :vector\n     ))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (associative? coll)\n   (if (keyword? (first (assoc coll 0 :hoi)))\n     :vector\n     :map)\n   (= (inc (count coll))\n      (count (-> coll (conj ::blub) (conj ::blub))))\n   :set\n   (= ::blub (first (conj coll ::blub)))\n   :list\n   ))", "user": "59137b42e4b0163c97b36f04"}, {"problem": 65, "code": "#(let [xs (empty %)]\n    (cond\n      (= (count xs) (count (conj xs nil))) :map\n      (= (count (conj xs 1)) (count (conj (conj xs 1) 1))) :set\n      (= 1 (first (reduce conj xs [1 2]))) :vector\n      :else :list))", "user": "5a544eeee4b05d388ecb6c24"}, {"problem": 65, "code": "#(let [a (into % {:ax :bx}) \n       c1 (count a)\n       b (into (into a {:ax :bx}) {:ax :cx})\n       c2 (- (count b) (count a))\n       ]\n   (cond\n    (= c2 0) :map\n    (= c2 1) :set\n    :else (if (= (first (into [] b)) [:ax :cx]) :list :vector) ))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 65, "code": "#(let [p (conj (conj (conj % [:1 :1]) [:1 :2]) [:1 :2])]\n   (case (- (count p) (count %))\n     1 :map\n     2 :set\n     3 (if (= (last p) [:1 :2]) :vector :list)))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "59c74c28e4b0a024fb6ae540"}, {"problem": 65, "code": "(fn [xs]\n  (case (empty xs)\n    {} :map\n    #{} :set\n    (if (= :end (first (conj (conj (empty xs) :start) :end)))\n      :list\n      :vector)))", "user": "5829d9f8e4b051871117bf4d"}, {"problem": 65, "code": "(fn inspect [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= 1 (get (into empty-coll [[:a 1]])\n                :a))\n      :map\n\n      (= 1 (count (into empty-coll [1 1])))\n      :set\n\n      (= 1 (first (into empty-coll [1 2 3])))\n      :vector\n\n      (= 3 (first (into empty-coll [1 2 3])))\n      :list)))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5b9c4a7be4b0c0b3ffbd4b16"}, {"problem": 65, "code": "(fn [coll]\n  (let [emp (empty coll)]\n     (if (contains? (into emp [[:a :b]]) :a)\n       :map\n       (let [s (into emp (range 100))]\n         (condp = s\n           (range 100) :vector\n           (reverse (range 100)) :list\n           :set)))))", "user": "59d8f23ae4b0ef0a1e9b5c49"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "5bc6ef7ce4b07a9b28b1009f"}, {"problem": 65, "code": "(fn seq->type\n  [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 65, "code": "(fn [x]\n  (let [s (str x)\n        f (first s)]\n    (case f\n          \\{ :map\n          \\# :set\n          \\[ :vector\n          :list)))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 65, "code": "#(cond\n\t(= (conj % {}) %) :map\n\t(= (conj % 1) (conj (conj % 1) 1)) :set\n\t(let [f (conj % 1) nf (not (first f)) f2 (conj f nf)] \n\t\t(= (first f2) nf)\n\t) :list\n\t:else :vector\n)", "user": "5b7bc82ce4b047b03b203726"}, {"problem": 65, "code": "(fn [s]\n  (cond\n   (= (+ (count s) 2) (count (conj s {:c 1 :d 2}))) :map\n   (= (count (conj s 2)) (count (conj (conj s 2) 2))) :set\n   (= (first (conj s 31 32 33)) 33) :list\n   :else :vector))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 65, "code": "(fn [s]\n  (let [type-map {{} :map\n                  #{} :set}]\n    (get type-map\n         (empty s)\n         (if (reversible? s)\n           :vector\n           :list))))", "user": "565131b3e4b0f29ec07d2e88"}, {"problem": 65, "code": "(fn what-is-it [coll]\n  (let [coll (empty coll)]\n  (cond\n    (reversible? coll) :vector\n    (= coll '()) :list\n    (= coll #{}) :set\n    :else :map)))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 65, "code": "(fn [x]\n  (let [y (conj x nil)]\n    (cond\n      (= (count x) (count y)) :map\n      (get (conj x -1) -1) :set\n      (= (conj y 1) (concat [1] y)) :list\n      :else :vector)))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 65, "code": "(fn [col]\n    (cond\n     (-> (conj col [:val \"val\"])\n         (get :val)\n         (= \"val\")) :map\n     (-> (conj col :val)\n         (get :val)\n         (= :val)) :set\n     (-> (conj col :v1)\n         (conj :v2)\n         (first)\n         (= :v2)) :list\n     (-> (conj col :v1)\n         (conj :v2)\n         (last)\n         (= :v2)) :vector)\n  )", "user": "5592ba8be4b0c79f6e1db931"}, {"problem": 65, "code": "(fn [col]\n  (cond\n   \t(= col (:my-special-key (conj col [:my-special-key col]))) :map\n    (= col (into #{} (seq col))) :set\n    (= '(:b :a) (take 2 (conj col :a :b))) :list\n    (= '(:a :b) (take-last 2 (conj col :a :b))) :vector))", "user": "5bc833a5e4b07a9b28b100bb"}, {"problem": 65, "code": "(fn [coll]\n  (let [m (reduce conj coll [[0 0] [0 0] [0 1]])]\n    (cond\n      (= (count m) (+ (count coll) 1)) :map\n      (= (count m) (+ (count coll) 2)) :set\n      (= [0 1] (first m)) :list\n      (= [0 1] (last m)) :vector)))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 65, "code": "(fn [coll]\n    (let [coll (conj coll\n                     [111 111])\n          coll (conj coll\n                     [123 456])]\n      (if (get coll\n               [123 456])\n        :set\n        (if (get coll\n                 123)\n          :map\n          (if (= (first coll)\n                 [123 456])\n            :list\n            :vector)))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 65, "code": "(fn\n[colle]\n(let [id (.toString (java.util.UUID/randomUUID))\n  newcolle (conj colle [99 999])]\n  (cond\n    (empty? (flatten newcolle)) (if (associative? colle) :map :set)\n    (= (first (conj newcolle id)) id) :list\n    :else :vector)\n))", "user": "5bc232b7e4b07a9b28b10026"}, {"problem": 65, "code": "(fn [s]\n  (if (= :bar (get (conj s {:foo :bar}) :foo))\n    :map\n    (if (= (count (conj s :foo :foo)) (+ 2 (count s)))\n      (if (= :bar (last (conj s :foo :bar)))\n        :vector\n        :list)\n      :set)\n  )\n)", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 65, "code": "(fn [x] ((get {\n                 #{} #(quote :set)\n                 {}  #(quote :map)\n                 []  #(if (= (conj (empty x) 0 1) [0 1]) :vector :list)\n                 } (empty x))))", "user": "5be0306be4b0ed4b8aab4c7d"}, {"problem": 65, "code": "(fn [x] (let [tst (conj x [0 :t1] [0 :t1] [1 :t1])]\n  (cond (= (get tst 0) :t1) :map \n        (= (count tst) (+ (count x) 2)) :set\n        (= (last tst) [1 :t1]) :vector\n        (= (first tst) [1 :t1]) :list\n  )\n        )\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 65, "code": "#(let [cobaia (conj % [:a 2])]\n   (cond\n     (= (:a cobaia) 2) :map\n     (= (count (conj cobaia [:a 2])) (count cobaia)) :set\n     (= (first (conj cobaia :s)) :s) :list\n     (= (last (conj cobaia :s)) :s) :vector))", "user": "5b60e88be4b0c6492753e70b"}, {"problem": 65, "code": "#({{} :map, #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5893c64ce4b00487982d524b"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (let [base (empty coll)]\n  (cond\n    (= base {}) :map\n    (= base #{}) :set\n    (= base '()) (if (reversible? base) :vector :list)\n    )))", "user": "5be33a16e4b0ed4b8aab4cd6"}, {"problem": 65, "code": "(fn [x]\n  (if (reversible? x)\n    :vector\n    ({{} :map #{} :set '() :list} (empty x))))", "user": "5bf5ddfde4b0bdcf453d159e"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (= \"t\" (:t (conj c [:t \"t\"]))) :map\n   (= :t (:t (conj c :t))) :set\n   (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector)\n   \n   )", "user": "5b57505ce4b02d533a91bd55"}, {"problem": 65, "code": "(fn [c] \n  (cond \n    (= {}  (empty c)) :map\n    (= #{} (empty c)) :set\n    (= (conj (conj (empty c) 1) 2) '(1 2)) :vector\n    (= (conj (conj (empty c) 1) 2) '(2 1)) :list\n   ))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)] ;; lol this should be cheating\n    (cond\n      (= #{} e)\n      :set\n      (= {} e)\n      :map\n      (= [1 2] (conj e 1 2))\n      :vector\n      :else :list)))", "user": "5c1bee41e4b01240ff567218"}, {"problem": 65, "code": "#(condp = (first (str %))\n\\[ :vector\n\\{ :map\n\\# :set\n\\c :list)", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 65, "code": "(fn [step] (if (= {} (empty step)) :map \n             (if (= (count (conj step 4)) (count (conj (conj step 4) 4))) :set\n              (if (= (first (conj (conj step :second) :first)) :first)\n                :list\n                :vector)))\n              )", "user": "58b985e0e4b0888cdc949ccc"}, {"problem": 65, "code": "(fn [coll]\n    ({#{} :set\n      {} :map} (empty coll) (if (reversible? coll) :vector :list)))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 65, "code": "#(let [e (not (first %)) l [e e] b (conj % l) c (conj b l)] (if (= e (get b e)) :map (if (= (count b) (count c)) :set (if (not= (not e) (first (conj b (not e)))) :vector :list))))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 65, "code": "#(let [x (first (str %))]\n   (cond\n     (= \\{ x) :map\n     (= \\# x) :set\n     (= \\[ x) :vector\n     :else :list))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5c20b6abe4b07e362c230576"}, {"problem": 65, "code": "(fn bbox-test\n  [col]\n  (letfn [(map-test [col]\n            (= (get (conj col {:foo :bar}) :foo) :bar))\n          (set-test [col]\n            (= (get (conj col :foo) :foo) :foo))\n          (vec-test [col]\n            (= (last (conj (conj col :foo) :bar))\n               :bar))\n          (lst-test [col]\n            (= (first (conj (conj col :foo) :bar))\n               :bar))]\n    (cond\n      (map-test col) :map\n      (set-test col) :set\n      (lst-test col) :list\n      (vec-test col) :vector)))", "user": "5c222b7de4b07e362c230588"}, {"problem": 65, "code": "#(cond \n  (= % (conj % {})) :map\n  (= (conj % %) (conj (conj % %) %)) :set\n  (let [x (conj % %)]\n    (= (first (conj x x)) x)) :list\n  :else :vector)", "user": "5c1aadcde4b01240ff567209"}, {"problem": 65, "code": "#(if (not (ifn? %)) :list (if (reversible? %) :vector (if (associative? %) :map :set)))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 65, "code": "(fn me [x]\n  (letfn [\n    (is-list? [x]\n      (let [h (first x)\n            [y z] (if (= [:a :a] h) [:b :a] [:a :b])\n            actual (conj x [:a y] [:a z])\n            [actual-z actual-y] (take 2 actual)]\n            (and (= [:a z] actual-z) (= [:a y] actual-y))))\n\n    (is-vec? [x]\n      (let [h (first x)\n            [y z] (if (= [:a :a] h) [:b :a] [:a :b])\n            actual (conj x [:a y] [:a z])\n            [actual-y actual-z] (take-last 2 actual)]\n            (and (= [:a z] actual-z) (= [:a y] actual-y))))\n\n    (is-set? [x]\n      (let [h (first x)\n            [y z] (if (= [:a :b] h)\n                    [[:a :a] [:a :b]]\n                    [[:a :b] [:a :a]])\n            actual (conj x y z z)]\n            (and\n              (= 1 (count (filter #(= z %) actual)))\n              (= 1 (count (filter #(= y %) actual))))))\n  ]\n    (cond\n      (is-set? x) :set\n      (is-vec? x) :vector\n      (is-list? x) :list\n      :else :map\n      )\n  )\n)", "user": "5c219c0fe4b07e362c230581"}, {"problem": 65, "code": "(fn [f]\n  (cond\n   (= :value (get (conj f [:test :value]) :test))\n   :map\n   \n   (<= (- (count (conj f 1 1))\n          (count f))\n       1) \n   :set\n   \n   (= :test2 (last (conj f :test :test2)))\n   :vector\n   \n   :else :list))", "user": "54df2609e4b024c67c0cf7a9"}, {"problem": 65, "code": "(fn [coll]\n  (let [cc #(= (conj % 1) (conj (conj % 1) 1))]\n    (if (associative? coll)\n      (if (reversible? coll) :vector :map)\n      (if (cc coll) :set :list))))", "user": "50eeeadae4b02c17778c91f3"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5c35046fe4b0d62ef62d9f5f"}, {"problem": 65, "code": "(fn black-box-testing [collection]\n  (let [x \"3rtA2HdgOlq1c70\" y \"a4B51H90S2bhA\" z \"5t4ea4gBn3s\" size (count collection) ]\n    (cond\n      (= (count (conj collection [x y] [x z])) (+ size 1)) :map\n      (= (count (conj collection x x)) (+ size 1)) :set\n      (= (first (conj collection x y)) y) :list\n      :else :vector\n      )))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 65, "code": "(fn [col]\n  (letfn [\n          (isMap? [c]\n            (and (associative? c) (not (reversible? c))))\n          (isSet? [c]\n            (and (not (associative? c)) \n                 (not (reversible? c))\n                 (= (count (conj c 1)) (count (conj c 1 1))))\n            )\n          (isVector? [c]\n             (and (associative? c) (reversible? c)))\n          ]\n    (cond\n      (isMap? col) :map\n      (isSet? col) :set\n      (isVector? col) :vector\n      :else :list)))", "user": "5c17467fe4b01240ff5671df"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str)", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 65, "code": "(fn f [col]\n  (let [t (conj (empty col) [1 2] [2 1] [1 2] [2 3])]\n    (cond\n      (= (count t) 2) :map\n      (= (count t) 3) :set\n      (= [2 3] (first t)) :list\n      :else :vector\n    )\n  )\n  )", "user": "5c337305e4b0d62ef62d9f48"}, {"problem": 65, "code": "(fn [a]\n  (let [b (conj (empty a) [:k :v])]\n    (cond\n      (:k b) :map\n      (get b 0) :vector\n      (get b [:k :v]) :set\n      :else :list)))", "user": "59733c91e4b01722bebd4c9b"}, {"problem": 65, "code": "(fn [xs]\n   (cond\n     (reversible? xs) :vector\n     (associative? xs) :map\n     (= (doall (take 3 (conj xs 1 2 3))) '(3 2 1)) :list\n     :else :set))", "user": "5c3f37fce4b08cd430848e91"}, {"problem": 65, "code": "(fn black-box-testing\n  [x]\n  (condp = (nth (str x) 0)\n   \\{ :map\n   \\c :list\n   \\[ :vector\n   \\# :set))", "user": "59b9e669e4b0a024fb6ae3db"}, {"problem": 65, "code": "(fn [c]\n  (case [(associative? c) (reversible? c)]\n    [true true] :vector\n    [true false] :map\n    (let [d (conj (conj c :item) :item)]\n      (if (= (- (count d) (count c)) 2) :list :set))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [s (conj coll [:a :b] [:c :d] [:c :d] [:c :e])]\n    (cond\n      (= (concat [[:c :e] [:c :d] [:c :d] [:a :b]] coll) s) :list\n      (= (concat coll [[:a :b] [:c :d] [:c :d] [:c :e]]) s) :vector\n      (= (conj coll [:c :e] [:c :d] [:a :b]) s) :set \n      :else :map)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 65, "code": "(fn [coll]\n    (cond\n      (and (associative? coll)\n           (= coll (vec coll)))     :vector\n      (and (associative? coll)\n           (not= coll (vec coll)))  :map\n      (and (not (associative? coll))\n           (= coll (vec coll)))     :list\n      :else                         :set))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 65, "code": "#({{} :map, #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 65, "code": "(fn\n  [s]\n  (if (= :b (->\n             (conj (empty s) [:a :b])\n             (get :a)))\n    :map\n    (let [conjd (conj (empty s) :b :a :a)]\n      (cond\n        (= conjd [:b :a :a ]) :vector\n        (= conjd [:a :a :b]) :list\n        (= conjd #{:a :b}) :set))))", "user": "4fe899a6e4b07c9f6fd12c54"}, {"problem": 65, "code": "(fn [coll]\n  (let [a (conj (conj coll [:b :c]) [:a :xx])]\n    (cond (= (get a :a) :xx) :map\n          (= (count a) (count (conj a [:a :xx]))) :set\n          (= (first a) [:a :xx]) :list\n          (= (last a) [:a :xx]) :vector)))", "user": "5c62979fe4b0fca0c162264c"}, {"problem": 65, "code": "#(let [x (first (str %))] (cond (= x \\{) :map (= x \\[) :vector (= x \\#) :set :else :list))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 65, "code": "(fn seq-check [s] \n  (let [col (conj (empty s) [1 2] [1 2] [1 3])]\n    (let [c (count col)]\n      (print c)\n      (cond \n       (= 1 c) :map\n       (= 2 c) :set\n       (= [1 2] (first col)) :vector\n       :else :list))))", "user": "5c6748f0e4b0fca0c16226b6"}, {"problem": 65, "code": "#(let [test [[1 1][1 1][1 2]]\n        oc (count %)\n        ncoll (apply conj % test)\n        nc (count ncoll)]\n    (cond\n      (= (inc oc) nc) :map\n      (= (+ 2 oc) nc) :set\n      (= (first ncoll) (last test)) :list\n      (= (last ncoll) (last test)) :vector))", "user": "4eb5750a535d7eef30807366"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (:test-key (conj x [:test-key :test-val])) :map\n    (:test-val (conj x :test-val)) :set\n    (= :test-val2 (first (conj x :test-val :test-val2))) :list\n    (= :test-val2 (last (conj x :test-val :test-val2))) :vector\n    :else nil))", "user": "5c73b8bae4b0fca0c16227ba"}, {"problem": 65, "code": "(fn [x]\n  (let [test (conj x [:k1 :v1] [:k2 :v2])] \n    (if \n      (= '() (flatten test))\n      (if (contains? test [:k1 :v1])\n        :set\n        :map)\n      (if (= (first test) [:k2 :v2])\n        :list\n        :vector))))", "user": "5c784248e4b0fca0c162281f"}, {"problem": 65, "code": "#({\\# :set\n   \\[ :vector\n   \\{ :map}\n      (first (str %))\n      :list)", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 65, "code": "(fn [coll]\n   (let [e (empty coll)\n         ismap (if (= {:a 1} (conj e {:a 1})) :map nil)\n         isvector (if (and (= nil ismap) (= [1 2] (conj e 1 2))) :vector nil)\n         islist (if (and (= nil ismap) (= '(2 1) (conj e 1 2))) :list nil)\n         isset (if (and (= nil ismap) (= #{1} (conj e 1 1))) :set nil)]\n     (or ismap isvector islist isset)))", "user": "5a64dcabe4b0512ff01cd9a9"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "5c8b0001e4b048ec896c5963"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5c8ecb58e4b048ec896c59b0"}, {"problem": 65, "code": "(fn probe-coll [c]\n  (let [emp (empty c)\n        add-one (conj emp [:one 1])\n        add-some (conj add-one [:one 1] [:one 2])]\n    (cond (= 2 (count add-some)) :set\n          (= 1 (count add-some)) :map\n          (= (first add-some) [:one 2]) :list\n          (= (add-one 0) [:one 1]) :vector\n          )\n    ))", "user": "5b100648e4b0cc2b61a3be17"}, {"problem": 65, "code": "(fn [sq]\n          (case (str (first (str sq)))\n            \"#\" :set\n            \"{\" :map\n            \"[\" :vector\n            :list))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (conj (empty coll) [1 2])]\n    (cond\n      (= [1 2] (get c [1 2])) :set\n      (= 2 (get c 1)) :map\n      (= [1 2] (get c 0)) :vector\n      :else :list)))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 65, "code": ";(fn f [x] (if (empty? x)\n;              (cond\n;                (= (get (conj x [4 5]) 4) 5) :map\n;                (=(count(conj x [4 5] [4 5])) 1) :set\n;                (= (first (conj x [4 5] [6 7])) [4 5]) :vector\n;                (= (last (conj x [4 5] [6 7])) [4 5]) :list\n;                )\n;              (cond\n;                (= (get (conj x [:aa :bb]) :aa) :bb) :map\n;                (= (count (conj x (first x))) (count x)) :set\n;                (= (last (conj x [:aa :bb] [:cc :dd])) [:cc :dd]) :vector\n;                (= (first (conj x [:aa :bb] [:cc :dd])) [:cc :dd]) :list)))\n\n(fn f [x] \n  (cond\n    (= (get (conj x [:aa :bb]) :aa) :bb) :map\n    (= (count (conj x [:aa :bb] [:aa :bb])) (inc (count x))) :set\n    (= (last (conj x [:aa :bb] [:cc :dd])) [:cc :dd]) :vector\n    (= (first (conj x [:aa :bb] [:cc :dd])) [:cc :dd]) :list))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (conj (empty coll) [:a 1] [:b 2])]\n    (case c\n      {:a 1 :b 2} :map\n      '([:b 2] [:a 1]) :list\n      [[:a 1] [:b 2]] :vector\n      #{[:a 1] [:b 2]} :set)))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 65, "code": "(fn find-type [xs]\n  (cond\n    (= :test-val (:tester (conj xs [:tester :test-val]))) :map\n    (let [added-twice (-> xs\n                          (conj :tester)\n                          (conj :tester))]\n      (= 1 (- (count added-twice) (count xs)))) :set\n    (= :test2 (first (-> xs (conj :test1) (conj :test2)))) :list\n    :else :vector))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 65, "code": ";; http://www.4clojure.com/problem/65\n(fn coll-type-test\n  [coll]\n  (cond\n    (= (count (conj coll nil)) (count coll))\n    :map\n\n    (= (count (conj (conj coll nil) nil)) (count (conj coll nil)))\n    :set\n\n    (=  (last (conj (conj coll :a) :b)) :b)\n    :vector\n    \n    :else :list\n    ))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 65, "code": "#(case (empty %)\n    {} :map\n    #{} :set\n    (case (-> (empty %) (conj 1) (conj 2))\n      [1 2] :vector\n      '(2 1) :list))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 65, "code": "(fn [s]\n  (case (conj (empty s) [:a 1] [:b 2])\n    #{[:b 2] [:a 1]} :set\n    {:b 2, :a 1} :map\n    [[:a 1] [:b 2]] :vector\n    '([:b 2] [:a 1]) :list\n    :other))", "user": "5b9ae606e4b0c0b3ffbd4af2"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5c896f46e4b048ec896c5940"}, {"problem": 65, "code": "(fn [col] (case (.charAt (str col) 0)\n   \\( :list\n   \\# :set\n   \\c :list\n   \\{ :map\n   \\[ :vector\n))", "user": "543bb568e4b032a45b869334"}, {"problem": 65, "code": "(fn q65 [sq]\n  (let [to-str (str sq)]\n    (cond\n      ((comp not nil?) (re-find #\"#\" to-str)) :set\n      ((comp not nil?) (re-find #\"\\{\" to-str)) :map\n      ((comp not nil?) (re-find #\"\\[\" to-str)) :vector\n      :else :list)))", "user": "5cab0ad9e4b048ec896c5c46"}, {"problem": 65, "code": "(fn blackbox [s]\n  (let [x1 (hash :a)\n        x2 (hash :b)]\n    (cond (= (get (conj s [x1 x2]) x1) x2) :map       ; only map convert vec to key/val\n          (= x2 (first (conj (conj s x1) x2))) :list  ; only lists conj to front\n          (= (get (conj s x1) (count s)) x1) :vector  ; only vectors addressed by index\n          :else :set)))", "user": "5cab33e7e4b048ec896c5c48"}, {"problem": 65, "code": "(fn [x]\n  (cond\n   (= (:c (conj x [:c :d])) :d) :map      \n   (= (conj x :c) (conj (conj x :c) :c)) :set\n   (= (first (conj (conj x :d) :c)) :c) :list\n   (= (last (conj (conj x :d) :c)) :c) :vector\n   ))", "user": "5b007e46e4b0cc2b61a3bd3c"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5cbeadf2e4b0ccb061962755"}, {"problem": 65, "code": "(comp {\"()\" :list \n       \"{}\" :map \n       \"[]\" :vector \n       \"#{}\" :set}\n      pr-str\n      empty)", "user": "50105b55e4b04c11913f949f"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5ca5d2cfe4b048ec896c5bdb"}, {"problem": 65, "code": "(fn [x] (cond\n         (= (get (conj x [:c 3]) :c) 3) :map          ;; if not map, it returns nil\n         (= (get (conj x :c) :c) :c) :set\n         (= (first (conj (conj x :a) :b)) :b) :list   ;; conj on list prepends\n         (= (last (conj (conj x :a) :b)) :b) :vector) ;; conj on vec appends\n  )", "user": "5ccb3792e4b0ccb061962882"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (cond\n    (= (count (merge coll coll))\n       (count coll))\n    :map\n\n    (let [r (rand)\n          coll+ (conj coll r)\n          coll++ (conj coll+ r)]\n      (= (count coll+)\n         (count coll++)))\n    :set\n\n    (let [r1 (rand)\n          r2 (rand)\n          coll+ (conj coll r1)\n          coll++ (conj coll+ r2)]\n      (= r2\n         (first coll++)))\n    :list\n\n    :else\n    :vector))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "592bb806e4b072a2710fcf46"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   \t(= (set c) c) :set\n  \t(and (or (= c []) (= c [1 2 3 4 5 6])) (= :y (last (conj (conj c :x) :y)))) :vector\n  \t(or (= c {:a 1 :b 2}) (= c {})) :map\n\t:else :list))", "user": "5cbb0436e4b026601754b9cc"}, {"problem": 65, "code": "(fn [coll]\n    (let [[s] (str coll)]\n      (cond\n        (= s \\{) :map\n        (= s \\[) :vector\n        (= s \\#) :set\n        :default :list)))", "user": "5a9bfd57e4b0d174b936c7d0"}, {"problem": 65, "code": "(fn bbt [seq]\n\t(let [n (gensym) xs (conj seq [n 1] [n 1] [n 2])]\n\t\t(cond\n\t\t (= (count xs) (+ 1 (count seq))) :map\n\t\t\t(= (count xs) (+ 2 (count seq))) :set\n\t\t\t(= [n 2] (first xs)) :list\n\t\t\t:else\t\t:vector)))", "user": "5c87c79be4b048ec896c591b"}, {"problem": 65, "code": "(fn [xs]\n       (let [x {:x :y} y {:y :z}\n             xs+ (conj xs x x y)]\n         (if (= (count xs+) (+ (count xs) 3)) \n           (if (= y (first xs+)) :list :vector)\n           (if (contains? xs+ x) :set :map))))", "user": "5cdfe2aee4b0a17bb84e2b04"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5ca2ca9fe4b048ec896c5b9c"}, {"problem": 65, "code": "(fn [coll]\n  (cond (= (-> coll (conj [:z :a]) (get :z)) :a)   :map\n        (= (-> coll (conj :a) (conj :a) count) (-> coll (conj :a) count)) :set\n        (= (-> coll (conj [:q :w]) (conj [:z :a]) first) [:z :a]) :list\n        (= (-> coll (conj [:q :w]) (conj [:z :a]) last) [:z :a])  :vector\n        :else                            :set)\n  )", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 65, "code": "(fn [c]\n  (case ((juxt associative? reversible? ifn?) c)\n    [true  true  true ] :vector\n    [false false false] :list\n    [true  false true ] :map\n    [false false true ] :set))", "user": "5cee521ce4b0aaa82f1129dd"}, {"problem": 65, "code": "(fn what-type\n  [s]\n  (let [uuid1 (str (java.util.UUID/randomUUID))\n        uuid2 (str (java.util.UUID/randomUUID))]\n  (if\n   (= (get (conj s [uuid1 uuid2]) uuid1) uuid2)\n    :map\n   \n  (let [new-s (-> s (conj uuid1) (conj uuid2))]\n  \t(cond\n\t \n     (= (count (-> s (conj uuid1) (conj uuid1))) (inc (count s)))\n     :set\n     \n     (and (= (first new-s) uuid2) \n          (= (second new-s) uuid1))\n     :list\n     \n     (and (= (get new-s (- (count new-s) 2)) uuid1)\n          (= (last new-s) uuid2))\n     :vector\n   \t )))))", "user": "5ce6f93be4b0a17bb84e2b99"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5cd4e1b2e4b0ccb061962927"}, {"problem": 65, "code": ";; (fn [c] (let [cnt (count c) C (into c [{0 2} {0 2} {1 3}]) cnt2 (-> C count (- 2))] (if (= cnt cnt2) (if (= 2 (get C 0)) :map :set) (if (= (last C) {1 3}) :vector :list))))\n;; Solution from aceeca1 is pretty good:\n(comp #(cond (= % {}) :map (= % #{}) :set (= (conj % 1 2) [1 2]) :vector true :list) empty)", "user": "5a5894d9e4b05d388ecb6c81"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5ca03402e4b048ec896c5b68"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "5d0ab107e4b0cc9c91588222"}, {"problem": 65, "code": "(fn\n  [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= {} empty-coll)\n      :map\n\n      (= #{} empty-coll)\n      :set\n\n      (= :list-second (first (conj coll :list-first :list-second)))\n      :list\n\n      (= :vector-test (last (conj coll :vector-test)))\n      :vector\n\n      :otherwise\n      nil)))", "user": "5cf48f04e4b087f62be35a86"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5baaae06e4b0a20761a23464"}, {"problem": 65, "code": "(fn [x]\n  (let [pok (conj (empty x) [:a :b])]\n    (cond\n     (= :b (get pok :a)) :map\n     (= (count pok) (count (conj pok [:a :b]))) :set\n     (= :v (first (conj pok :v))) :list\n     :else :vector)))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 65, "code": "#(let [s (empty %)]\n   (cond\n    (= s #{}) :set\n    (= s {}) :map\n    (reversible? s) :vector\n    :else :list\n    )\n )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 65, "code": "(fn [x] \n  (cond\n    (= (:t (conj x [:t \"t\"])) \"t\" )  :map\n    (= (:t (conj x :t))  :t)  :set\n    (= (last (conj (conj x :t) :s)) :s)  :vector\n    (= (first (conj (conj x :t) :s)) :s)  :list))", "user": "5c5e3af7e4b01df32ab732c6"}, {"problem": 65, "code": "#(let [c (empty %)]\n   (cond\n     (= c {})  :map\n     (= c #{}) :set\n     (reversible? c) :vector\n     :c :list))", "user": "57b19fa1e4b0fbc9809a2754"}, {"problem": 65, "code": "(fn [coll]\n  (if (= (conj coll [:uniq 3] [:uniq2 3]) \n         (concat (list '(:uniq2 3) '(:uniq 3)) coll)) :list\n      (if (= (into [] coll) coll) :vector\n          (if (= (into #{} coll) coll) :set\n              (if (= (into {} coll) coll) :map)))))", "user": "5d126728e4b02c15ef02199a"}, {"problem": 65, "code": "(fn\n  [thing]\n  (letfn [(is-list? [thing]\n            (let [newlist (conj thing :tester1 :tester2)]\n              (and (= :tester2 (first newlist))\n                   (= :tester1 (second newlist)))))\n          (is-vec? [thing]\n            (let [newvec (conj thing :tester1 :tester2)]\n              (and (= :tester2 (last newvec))\n                   (= :tester1 (last (butlast newvec))))))\n          (is-map? [thing]\n            (let [size (count thing)\n                  newmap (conj thing {:tester :tester} {:tester :tester_})]\n              (= (inc size) (count newmap))))\n          (is-set? [thing]\n            (let [newset (conj thing :tester)]\n              (= (count newset) (count (conj newset :tester)))))]\n    (cond\n      (is-map? thing)  :map\n      (is-set? thing)  :set\n      (is-list? thing) :list\n      (is-vec? thing)  :vector\n      :else :unknown)))", "user": "570c8ac3e4b0b0fb43fd06ca"}, {"problem": 65, "code": "#(let [x (first (seq (str %)))]\n                      (cond\n                        (= x \\{)\n                        :map\n                        (= x \\#)\n                        :set\n                        (= x \\[)\n                        :vector\n                        :else\n                        :list\n                        )\n                      )", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 65, "code": "(fn [s] \n        (let [a1 (gensym)\n              a2 (gensym)]\n          (cond\n            (=  (+ 2 (count s)) (count (conj (conj s {a1 a2}) {a1 a2}))) (if (= (cons a2 (cons a1 s)) (conj (conj s a1) a2)) :list :vector)\n            true (if (not= (+ 3 (count s))\n                        (count (conj (conj (conj s {a1 a1})  {a2 a2}) {a1 a2}) ))\n                :map\n                :set))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5d13f783e4b0902706380dc1"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "5952d75ce4b066ee0a44aed4"}, {"problem": 65, "code": "#(let [col (conj % [1 2] [3 4])] \n  (cond\n   (= col (conj col (first col))) (if (= col (set col)) :set :map)\n   (= col (drop 1 (conj col (first col)))) :list\n   :else :vector))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 65, "code": "(fn [o]\n  (letfn [(set?? [o] (= (conj o [1 1]) (conj (conj o [1 1]) [1 1])))\n          (map?? [o] (= :b (:a (conj o [:a :b]))))\n          (vec?? [o] (= (conj (conj o :a) :b)\n                        (concat o [:a :b])))]\n    (cond\n      (map?? o) :map\n      (set?? o) :set\n      (vec?? o) :vector\n      :else :list)))", "user": "5d272077e4b092dab7f59c64"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n:else :list )))", "user": "5d29d837e4b01671435dbc6c"}, {"problem": 65, "code": "#({{} :map, #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5c411df3e4b08cd430848ebf"}, {"problem": 65, "code": "(fn my-type\n  [seq]\n  (let [test-seq (conj seq [:c 4] [:c 4] [:d 5])] \n    (cond\n     (and\n       (= (+ (count seq) 2) (count test-seq))\n       (not (nil? (:c test-seq)))) :map\n     (and\n       (= (+ (count seq) 2) (count test-seq))\n       (nil? (:c test-seq))) :set\n     (= [:d 5] (first test-seq)) :list\n     (= [:d 5] (last test-seq)) :vector)))", "user": "5d1c14cde4b02ea6f0fb698a"}, {"problem": 65, "code": "(fn f [coll]\n  (let [e (empty coll)\n        a [:a :a]\n        b [:b :b]]\n    (if (= (count (conj (conj e a) a)) 1)\n      (if (contains? (conj e a) :a)\n        :map\n        :set)\n      (if (= (first (conj (conj e a) b)) a)\n        :vector\n        :list))))", "user": "5012da69e4b0c8732600222d"}, {"problem": 65, "code": "(fn which-col [col]\n  (let [c (-> col (conj {1 2}) (conj {1 2}))]\n    (if\n      (= (count c) (inc (count col)))                       ; set or map\n      (if (get c {1 2}) :set\n                        :map)\n      (let [v-or-l (conj c :test)]\n        (if (= (first v-or-l) :test) :list\n                                     :vector)))))", "user": "518279abe4b0353c468deb65"}, {"problem": 65, "code": "(fn [x]\n      (let [ ini-count (count x)\n            x (conj (conj (conj x {:a :b}) {:c :d}) {:c :d})]\n     (cond\n       (not (nil? (:a x))) :map\n       (= (count x) (+ ini-count 2)) :set\n       (= (first  x ) {:c :d}) :list\n       :else :vector\n       )))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 65, "code": "#(cond\n    (= (into [] %) %) (if (reversible? %) :vector :list)\n    (= (into #{} %) %) :set\n\t(= (into {} %) %) :map\n)", "user": "5d2201b8e4b02ea6f0fb69ed"}, {"problem": 65, "code": "#(let [c (reduce conj (empty %) [{:a 2} {:a 1} {:a 1}])]\n   (cond\n     (= (count c) 1) :map\n     (= (count c) 2) :set\n     (= (first c) {:a 1}) :list\n     :e :vector))", "user": "576e607ae4b0979f89651579"}, {"problem": 65, "code": "(fn [A] \n  (let [A-with-nil (conj A nil)]\n    (if (= A A-with-nil)\n      :map\n      (if (= (into A-with-nil A-with-nil) A-with-nil)\n        :set\n        (if (= :a (first (into A [:b :a])))\n          :list\n          :vector)))))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (= :v (get (conj coll [:k :v]) :k)) :map\n    (= :v (get (conj coll :v) :v)) :set\n    (= :v2 (first (conj coll :v1 :v2))) :list\n    :else :vector))", "user": "5d27da09e4b092dab7f59c75"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n   (= (get (conj c :t) :t) :t) :set\n   (= (first (conj (conj c :a) :b)) :b) :list\n   (= (last (conj (conj c :a) :b)) :b) :vector\n  )\n  )", "user": "5d3fa930e4b05dd059a5435f"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "598601f9e4b021a7a535fe79"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "4e628ab2535d8ccf87e9fe61"}, {"problem": 65, "code": "(fn [P]\n    (let [ L (empty P) Prober :this-is-my_prober]\n      (cond\n        (= L (empty  {} )) :map\n        (= L (empty #{} )) :set\n        :else \n          ;; \u0432\u0441\u0435, \u043a\u0440\u043e\u043c\u0435 \u0441\u043f\u0438\u0441\u043a\u0430 \u0438 \u0432\u0435\u043a\u0442\u043e\u0440\u0430 \u043c\u044b \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u043b\u0438\n          ;; \u0442\u0435\u043f\u0435\u0440\u044c \u043f\u043e\u0441\u043c\u043e\u0442\u0440\u0438\u043c \u043d\u0430 \u043e\u0441\u0442\u0430\u0432\u0448\u0435\u0435\u0441\u044f\n          (if (= (first (conj (conj P 1) Prober)) Prober)\n            :list\n            :vector\n          )        \n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 65, "code": "(fn what-is-it [coll]\n  (let [coll (empty coll)\n        coll (conj coll [:a 3])]\n    (cond\n      (= (get coll :a) 3) :map\n      (= (get coll [:a 3]) [:a 3]) :set\n      (= (last (conj coll 5)) 5) :vector\n      :else :list)))", "user": "5d1be50ce4b02ea6f0fb6986"}, {"problem": 65, "code": "(fn [coll]\n  (let [x (empty coll)]\n    (cond\n     (= x #{}) :set\n     (= x {}) :map\n     (= [:a :b] (conj x :a :b)) :vector\n     :else :list)))", "user": "5ccf99fbe4b0ccb0619628c8"}, {"problem": 65, "code": "(fn [coll]\n  (let [mt (empty coll)]\n  (case mt\n    #{} :set\n    {} :map\n    [] (if (= (conj mt 0 1) '(1 0)) :list :vector)\n    :unknown)))", "user": "5d46fbc6e4b07c84aa5ae6af"}, {"problem": 65, "code": "(fn [sec]\n    (let [new-sec (conj sec {:test \"test\"} {:test \"test\"})]\n      (if (= (count new-sec) (+ (count sec) 2))\n        (let [positional-sec (conj sec :a :b)]\n          (if (and (= (first positional-sec) :b)\n                   (= (second positional-sec) :a))\n            :list :vector))\n        (if (= (new-sec :test) \"test\")\n          :map :set))))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 65, "code": "#(let [x (if (empty? %) (conj % [:a 1]) %)]\n            (cond\n              (= (first (conj x x)) x) :list\n              (= (conj x x) x) :map\n              (= (into x x) x) :set\n              :else :vector))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "54b42ea4e4b05787c3b1638b"}, {"problem": 65, "code": "(fn\n  [c]\n  (let [e (empty c)]\n    (cond\n      (:a (conj e [:a true])) :map\n      (= 1 (count (conj e 1 1))) :set\n      (= [1 2] (conj e 1 2)) :vector\n      :else :list)))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 65, "code": "#(cond\n   (= 1 (:x (conj % [:x 1]))) :map\n   (= (conj % 42) (conj % 42 42)) :set\n   (= 42 (first (conj % 21 42))) :list\n   :else :vector)", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 65, "code": "(fn [x]\n    (let [e (empty x)]\n      (cond\n        (= e {}) :map\n        (= e #{}) :set\n        (reversible? e) :vector\n        :else :list\n        )))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 65, "code": "(fn [c]\n   (cond (= (get (conj c [:a :b]) :a) :b)           :map\n         (= (inc (count c)) (count (conj c :a :a))) :set\n         (= (last (conj c :a :b)) :b)               :vector\n         (= (first (conj c :a :b)) :b)              :list))", "user": "5bb25684e4b0a20761a2350d"}, {"problem": 65, "code": "(fn mytype [coll]\n  (if (= 1 (- (count (into coll [[:aa :b][:aa :b]])) (count coll)))\n    ; map or set\n    (if (= 1 (- (count (into coll [[:aa :a][:aa :b]])) (count coll))) :map :set)\n    ; vector or list\n    (if (= :a (first (conj (conj coll :b) :a))) :list :vector)))", "user": "5d4f21f3e4b0776584bd6f4e"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "5be79b5be4b0f319e2d7ec5a"}, {"problem": 65, "code": "(fn black-box [col]\n  (cond\n    (= col {}) :map\n    (= col #{}) :set\n    (and (= (vec col) col) (= (first (conj col \"foo\")) \"foo\") (not (= (count col) 0))) :list\n    (and (= (vec col) col) (not (= (count col) 0))) :vector\n    (and (not (number? (first col))) (= (count (first col)) 2)) :map\n        :else (if (= (count col) 0)\n                (recur (conj col 1))\n              :set)))", "user": "5d631376e4b0c9e5857d5023"}, {"problem": 65, "code": "(fn [sq]\n  (cond\n    (= (get (conj sq [:key :val]) :key) :val) :map\n    (= (count (conj sq 1)) (count (conj sq 1 1))) :set\n    (= (first (conj sq 20 30)) 30) :list\n    :else :vector))", "user": "5d28b684e4b092dab7f59c83"}, {"problem": 65, "code": "(fn [coll] \n  (let [r (#(conj % [:k :v] [:k :v] [:ok :ov]) coll)]\n    (cond\n      (= (:k r) :v) :map\n      (= (count coll) (- (count r) 2)) :set\n      (= (last r) [:ok :ov]) :vector\n      (= (first r) [:ok :ov]) :list)))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 65, "code": "(fn get-type\n  [sub]\n  (cond\n\n    (and (associative? sub) (nil? ((conj sub {:a 1}) 0) )) :map\n    (and (associative? sub)) :vector\n    (= (count (conj sub 1)) (count (conj sub 1 1))) :set\n    :else :list\n))", "user": "5d5eb086e4b0c9e5857d4ff7"}, {"problem": 65, "code": "(fn [fcoll]\n  (let [coll (into (empty fcoll) [[:a 2] [:b 1]])\n        e (first coll)\n        key? (:a coll)\n        ncoll (conj coll e)\n        cnt-eql? (= (count ncoll) (count coll))\n        last? (and (= e (last ncoll))\n                   (not= e (last coll)))]\n    (cond\n     (and cnt-eql? key?) :map\n     cnt-eql? :set\n     last? :vector\n     :else :list)))", "user": "54236ce1e4b01498b1a71ad1"}, {"problem": 65, "code": "(fn [coll]\n  (let [litmus (into (empty coll) [{:a 1} {:a 2} {:b 3}])]\n    (cond\n     (= litmus '({:b 3} {:a 2} {:a 1})) :list\n     (= litmus [{:a 1} {:a 2} {:b 3}]) :vector\n     (= litmus #{{:a 1} {:a 2} {:b 3}}) :set\n     :else :map\n     )\n    )\n  )", "user": "5d2e5065e4b01671435dbcae"}, {"problem": 65, "code": "(fn [s]\n  (let [e (empty s)]\n    (cond (= e {}) :map\n          (= (conj (conj e 1) 2) [1 2]) :vector\n          (= (conj (conj e 1) 2) '(2 1)) :list\n          (= e #{}) :set\n          :else :foo)))", "user": "5d64ecb2e4b0c9e5857d5036"}, {"problem": 65, "code": "(fn [x]\n   (let [t1 (apply conj x [[:t1 1] [:t1 1]])]\n     (println t1)\n     (if (get t1 :t1)\n       :map\n       (let [t2 (apply conj x [:t1 :t1])]\n         (println t2)\n         (if (= 2 (- (count t2) (count x)))\n           (let [t3 (apply conj x [:1 :2])]\n             (println t3)\n             (if (= :2 (last t3))\n               :vector\n               :list))\n           :set)))))", "user": "5d5ef0bce4b0c9e5857d4ffb"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5245af03e4b08ba239308124"}, {"problem": 65, "code": "(fn blackbox [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "5ccc9078e4b0ccb061962899"}, {"problem": 65, "code": "(fn [xs]\n  (if (= (inc (count xs)) (count (conj xs [:zxy :zxy] [:zxy :zxy])))\n    (if (= :zxy (:zxy (conj xs [:zxy :zxy]))) :map :set)\n    (if (= :xyz (last (conj xs :zxy :xyz))) :vector :list)))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 65, "code": "(fn [c]\n   (case (empty c)\n     {} :map\n     #{} :set\n     (case (into (empty c) [0 1])\n       [0 1] :vector\n       :list)))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 65, "code": "(fn black-box-test [coll]\n  (let [test (conj coll [1 2] [3 4])]\n   (cond\n     (and (= (first test) [3 4]) (= (count (conj test [3 4])) (inc (count test)))) :list\n     (and (= (last test) [3 4]) (= (count (conj test [3 4])) (inc (count test)))) :vector\n     (= (count (conj test [3 5])) (count test)) :map\n     (= (count (conj test [3 5])) (inc (count test))) :set)))", "user": "5d6f063de4b04d129b00f2d1"}, {"problem": 65, "code": "(fn seq-type [seq]\n (let [t (conj (empty seq) [:k :v])]\n  (cond\n   (:k t) :map\n   (get t 0) :vector\n   (get t [:k :v]) :set\n   :else :list)))", "user": "5d5c6675e4b09db18d4482ec"}, {"problem": 65, "code": "(fn [coll] (let [empty-coll (empty coll)] (cond\n                                           (= empty-coll {}) :map\n                                           (= empty-coll #{}) :set\n                                           (= (conj empty-coll 1 2) '(2 1)) :list\n                                           (= (conj empty-coll 1 2) [1 2]) :vector\n)))", "user": "5d6d2172e4b04d129b00f2b9"}, {"problem": 65, "code": "(fn [x]\n  (let [s (empty x)]\n    (cond \n      (= #{} s) :set\n      (= {} s) :map\n      (= '(2 1) (conj s 1 2)) :list\n      :else :vector)))", "user": "5d8b881ae4b0915913b1d3d7"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (empty c) {}) :map\n    (= (count (conj (conj c :a) :a)) (count (conj c :a))) :set\n    (= (concat [1 2] c) (conj (conj c 2) 1)) :list\n    :else :vector))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 65, "code": "(fn [coll]\n         (let [coll-t (into coll [[100 100]])]\n           (if (get coll-t 100)\n             :map\n             (let [is-not-set? (= (+ 2 (count coll))\n                             (count (conj (conj coll 1) 1)))]\n               (if is-not-set?\n                 (if (= (concat coll [2 3])\n                        (conj (conj coll 2) 3))\n                   :vector :list) :set)))) )", "user": "5cbd5b42e4b026601754b9f6"}, {"problem": 65, "code": "#(let [x (conj (empty %) \n               [:a :x]\n               [:a :x]\n               [:a :y])]\n   (case (count x) \n    1 :map\n    2 :set\n    3 (if (= (first x) [:a :x])\n        :vector\n        :list)))", "user": "53c74cfce4b00fb29b2212a7"}, {"problem": 65, "code": "(fn [xs]\n  (if (associative? xs)\n    (if (reversible? xs)\n      :vector\n      :map)\n    (if (= :second (first (conj (conj xs :first) :second)))\n      :list\n      :set)))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (condp = base\n      #{} :set\n      {} :map\n      (if (reversible? coll) :vector :list))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 65, "code": "(fn [s]\n  (let [x1 {:yy 999}\n        x2 {:yy 998}\n        us (-> s (conj {:no \"\"}) (conj x1)  (conj x2))]\n       (if (and (= (first us) x2) (= (second us) x1)) :list\n         (if (and (= (last us) x2) (= (last (drop-last us)) x1)) :vector\n           (if (= (+ (count s) 2) (count us)) :map :set)))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 65, "code": "(fn whatisit [coll]\n  (let [unique1 [::set 1] unique2 [::set 2]\n        map-or-set? (fn [coll] (= (count (conj coll unique1)) (count (conj coll unique1 unique1))))\n        is-it-a-map? (fn [coll] (= (count (conj coll unique1 unique2)) (inc (count coll))))\n        is-it-a-list? (fn [coll] (= (first (conj coll unique1 unique2)) unique2))]\n    (cond\n      (map-or-set? coll) (if (is-it-a-map? coll) :map :set)\n      (is-it-a-list? coll) :list\n      :else :vector)))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 65, "code": "#(let [e (empty %)] (cond (= e {}) :map\n                          (= e #{}) :set\n                          (= [1 2] (conj e 1 2)) :vector\n                          :else :list))", "user": "59ef6cfae4b0966464fe6a32"}, {"problem": 65, "code": "(fn eval-seq [seq]\n  (cond\n    (= (conj seq {}) seq) :map\n    (= (count (conj seq 1)) (count (conj (conj seq 1) 1))) :set\n    (if (= (first (conj (conj seq \"x\") \"y\")) \"y\")\n      true\n      false) :list\n    (if (= (last (conj (conj seq \"x\") \"y\")) \"y\")\n      true\n      false) :vector\n    :else \"cannot evaluate\"))", "user": "5da6cb60e4b000c986472c10"}, {"problem": 65, "code": "(fn [x] \n  (cond\n   (= (get (conj x [:t 100]) :t) 100) :map\n   (= (get(conj x :t):t):t) :set\n   (= (first (conj (conj x :t) :l)):l) :list\n   (= (last (conj x :t)) :t) :vector\n   ))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 65, "code": "(fn [coll]\n  (let [poke (conj coll [:key :val])\n        doublepoke (conj poke [:key :val])\n        doublepoke' (conj poke [:key' :val'])]\n    (cond\n      (= (:key poke) :val) :map\n      (= (count poke) (count doublepoke)) :set\n      :otherwise (if (= (first doublepoke') [:key' :val'])  \n                   :list\n                   :vector))))", "user": "5d97b602e4b0d3f9b434ad3a"}, {"problem": 65, "code": "(fn b [x]\n  (cond\n    (= (:a (conj x [:a 1])) 1) :map\n    (= (get (conj x 1234) 1234) 1234) :set\n    (= (last (into x [1234 1235])) 1235) :vector\n    (= (first (conj x 1234)) 1234) :list\n   ))", "user": "59bac5c9e4b0a024fb6ae3ed"}, {"problem": 65, "code": "(fn black-box-type [elem]\n  (cond\n    (= (into elem [ [:a 1] [:a 2]]) (into elem [[:a 2]]))\n    :map\n\n    (= (into elem [1 1]) (into elem [1]))\n    :set\n\n    (= (conj elem 1 2) (concat [2 1] elem))\n    :list\n\n    (= (conj elem 1 2) (concat elem [1 2]))\n    :vector\n\n    :else :beats-me))", "user": "5d7aa22ee4b02e6b30c9354e"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [ec (empty coll)]\n    (cond\n      (= ec {})          :map\n      (= ec #{})         :set\n      (reversible? coll) :vector\n      :else              :list )))", "user": "5c0eb93ce4b01240ff567146"}, {"problem": 65, "code": "(comp {\\# :set \\{ :map \\[ :vector \\c :list} first str);;;= (fn [x] ({\\# :set \\{ :map \\[ :vector \\c :list} (first (str x)))\n                         \n                          \n                          \n                          \n;;;; question about comp and get???\n                          ;;;(get [1 2 3] 5 100)\n                             ;;=> 100 returns not found value  5 is looking for nth value\n                          \n;;;;;;;((comp {\\# :set \\{ :map \\[ :vector \\c :list} first str){:a 1, :b 2});;;;\n;;;;;; ;;;; 1. use str to create \"{\" \":\" \"a\" \"1\" \":\" \"b\" \"2\" \"}\"\n  ;;;;;;;;;;2. use first to get \"{\"\n  ;;;;;;;;;;3. use {\\# :set \\{ :map \\[ :vector \\c :list} (it is a function) to find a key \"{\";; we use \\ it is a syntax to define a character, character for example is \\# with backslash \\\n  ;;;;;;;;;;4. we use comp to combine all functions together\n  ;;;;;;;;;;; {\\# :set \\{ :map \\[ :vector \\c :list} works like a look up function it works with keys look for keys  :map , :set, it work with strings as a key: ({\"one\" 1 \"two\" 2} \"one\")", "user": "5ce5b43be4b0a17bb84e2b7a"}, {"problem": 65, "code": "#(case ((juxt reversible? associative? ifn?) %)\n     [false true true] :map\n     [false false false] :list\n     [true true true] :vector\n     [false false true] :set\n     )", "user": "5d99dc47e4b0d3f9b434ad42"}, {"problem": 65, "code": "(fn [coll]\n  (let [empty-coll (empty coll)]\n    (cond\n      (= (:a (conj empty-coll [:a :b])) :b) :map\n      (= 1 (count (conj empty-coll :a :a))) :set\n      (= (last (conj (conj empty-coll [:a :b]) [:c :d])) [:a :b]) :list\n      (reversible? empty-coll) :vector\n      :else :b0rked)))", "user": "5da5a1eee4b000c986472c04"}, {"problem": 65, "code": "(fn which-coll [xs]\n (let [coll-attrs (fn [coll] ((juxt associative? reversible? ifn?) coll))\n       coll-lookup (zipmap (map coll-attrs ['() #{} [] {}])\n                           [:list :set :vector :map])]\n   (coll-lookup (coll-attrs xs))))", "user": "5db0d470e4b0f8c104ccfc9e"}, {"problem": 65, "code": "(fn [s]\n  (let [result (conj (empty s) [1 2] [1 2] [1 3])]\n    (cond\n      (= 1 (count result)) :map\n      (= 2 (count result)) :set\n      (= [1 2] (first result)) :vector\n      :else :list)))", "user": "5daeb6bce4b0f8c104ccfc8b"}, {"problem": 65, "code": "(fn f65 [obj]\n  (let [a      [1 1]\n        result (conj obj a)]\n    (cond\n      (and (not (associative? obj)) (= (conj result a) result)) :set\n      (and (associative? obj) (identical? (conj result a) result)) :map\n      (and (not (associative? obj)) (identical? (first result) a)) :list\n      (and (associative? obj) (identical? (last result) a)) :vector\n      :else nil )))", "user": "5db658ebe4b010eb3c36cd39"}, {"problem": 65, "code": "(fn [col]\n  (let [keyTest :testKey\n        testEl [keyTest 100500]\n        addingRandomCol (conj col [:testRandom 1])\n        testCol (conj (conj addingRandomCol testEl) testEl)]\n    \n    (if (= 2 (count \n              (filter true? \n                (map\n                  #(= testEl %)\n                  testCol\n                ))))\n      (if (= (first testCol) testEl) :list :vector)\n      (let [testEl2 [keyTest 200] ]\n        (if (= 2 (count (filter true? (map\n                          #(or (= % testEl2) (= % testEl))\n                          (conj testCol testEl2)\n                        ))))\n            :set\n            :map\n        )\n      )\n    )\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 65, "code": "(fn [x]   (let [y (seq (str (pr-str x)))     ]   ({ \\{ :map \\( :list \\# :set \\[ :vector}  (first y))    )  )", "user": "5da98129e4b000c986472c33"}, {"problem": 65, "code": "(fn [x]\n    (let [v (into (empty x) [[:a 1] [:a 1] [:a 2]])]\n      (cond \n        (= (count v) 1)\n        :map\n\n        (= (count v) 2)\n        :set\n\n        (= (first v) [:a 1])\n        :vector\n\n        :else\n        :list)))", "user": "5d883119e4b0915913b1d3a6"}, {"problem": 65, "code": "(fn [xs]\n  (condp #(get %2 %) (conj (empty xs) [:k :v])\n    :k      :map\n    0       :vector\n    [:k :v] :set\n    :list))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 65, "code": "#(let [x %]\n   (cond\n    (= (empty x)   {}) :map\n    (= (empty x)  #{}) :set\n    (and (= (empty x) '()) (= (cons :b (cons :a x)) (conj (conj x :a) :b))) :list\n    (= (empty x)   []) :vector))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "562d869be4b0a45d2ff8301f"}, {"problem": 65, "code": "#(let [x (conj (empty %) [1 1] [1 2] [1 2])\n       c (count x)\n       f (first x)]\n  (cond\n   (= c 1) :map\n   (= c 2) :set\n   (= c 3)\n    (if (= f [1 1])\n      :vector\n      :list)))", "user": "5da8fa72e4b000c986472c2d"}, {"problem": 65, "code": "#({\\# :set \\{ :map \\[ :vector \\( :list} (nth (str %) 0) :list)", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 65, "code": "(fn coll_type2 [coll]\n    (let\n        [\n            is_map\n                (fn [coll] \n                    (and\n                        (even? (count coll))\n                        (or \n                            (= (apply hash-map (flatten (seq coll))) coll)\n                            (= (apply array-map (flatten (seq coll))) coll)\n                        )\n                    )\n                )\n            is_set\n                (fn [coll] (apply = (map #(count (apply conj coll %)) '([2] [2 2]))))\n            vec_or_list\n                (fn [coll] (= (last (conj (conj coll 1 ) 2)) 2) )\n        ]\n        (if (is_map coll)\n            :map\n            (if (is_set coll)\n                :set\n                (if (vec_or_list coll)\n                    :vector\n                    :list\n                )\n            )\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 65, "code": "(fn [c]\n  (let [e (empty c)]\n       (cond\n         (= {}  e) :map\n         (= #{} e) :set\n         (= '() e) (if (reversible? c) :vector :list)\n         :else     nil)))", "user": "591addcee4b09b4ee5954be1"}, {"problem": 65, "code": "(fn [c]\n  (if (associative? c)\n    (if (reversible? c)\n      :vector\n      :map)\n    (let [len (count c)]\n      (if (= 2 (- (count (conj (conj c 1) 1)) len))\n      :list\n      :set))))", "user": "5dc72a9ce4b02f9375f4e1cd"}, {"problem": 65, "code": "(fn [coll]\n  (let [kw-pair [:foo true]\n        test-coll (conj (empty coll) [nil nil] kw-pair kw-pair)]\n    (cond\n     (:foo test-coll) :map\n     (= 2 (count test-coll)) :set\n     (= kw-pair (first test-coll)) :list\n     :else :vector)))", "user": "5db5d09be4b010eb3c36cd31"}, {"problem": 65, "code": "(fn [x] (cond (= (conj x x) x) :map\n              (< (- (count (conj (conj x 0) 0)) (count x)) 2) :set\n              (let [a [1] b [2]] (identical? (first (conj x a b)) b)) :list\n              :else :vector))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (= (empty x) {}) :map\n\n    (= (conj x :foo :foo)\n       (conj x :foo)) :set\n\n    (= (conj x :foo :bar)\n       (conj (vec x) :foo :bar)) :vector\n\n    :else :list))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5dcfdf23e4b0948ae9d9ad43"}, {"problem": 65, "code": "(fn [x] (let [v1 {:blah 1}\n              v2 {:bleh 2}\n              res (conj (conj x v1) v2)]\n            (cond\n                  (= (count res) (count (conj res {:blah 3}))) :map\n                  (= (count res) (count (conj res v1))) :set\n                  (= (first res) v2) :list\n                  (= (last res) v2) :vector)))", "user": "5dd35dcbe4b0948ae9d9ad5f"}, {"problem": 65, "code": "(fn type2\n  [coll]\n  (cond\n    (= (count coll) (count (conj coll coll)))\n    :map\n\n    (= (count (conj coll 1))\n       (count (conj coll 1 1)))\n    :set\n\n    (= (cons 1 (cons 2 coll)) (conj (conj coll 2) 1))\n    :list\n\n    :else\n    :vector))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 65, "code": "(fn black-box-testing-3 [ip-seq]\n  (cond\n    (= {} (empty ip-seq)) :map\n    (= (or () []) (empty ip-seq))\n    (if (= '(1 2) (conj (empty ip-seq) 1 2))\n      :vector\n      :list)\n    (= [] (empty ip-seq)) :vector\n    :else :set))", "user": "5d8c8175e4b0915913b1d3e1"}, {"problem": 65, "code": "(fn my-collection-type\n  [s]\n  (cond\n    (= {} (empty s)) :map\n    (= [] (empty s)) (if (= (first (conj (conj s 1) 2))\n                            2)\n                       :list\n                       :vector)\n    (= #{} (empty s)) :set))", "user": "5d53a59ae4b0776584bd6f72"}, {"problem": 65, "code": "(fn get-collection-type [c1]\n  (if (= (count (conj c1 [1 2] [1 2])) (count (conj c1 [1 2])))\n    (if (= ((conj c1 [1 2]) [1 2]) [1 2])\n      :set\n      :map\n      )\n    (if (= (first (conj c1 [1 2] [3 4])) [3 4])\n      :list\n      :vector)\n    )\n  )", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 65, "code": "(fn [arg]\n  (cond\n    (contains? #{(seq arg) []} arg)\n      (if (= :__last__ (first (conj arg :__first__ :__last__)))\n        :list\n        :vector)\n    :else\n      (if (= arg (set (seq arg)))\n        :set\n        :map)))", "user": "546e4ab8e4b00cfc9eacc19c"}, {"problem": 65, "code": "(fn black-box [c] ((zipmap (map str [{} #{} () []]) [:map :set :list :vector]) (str (empty c))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 65, "code": "(fn [s]\n  (if (empty? s)\n    (if (= s {}) :map (if (= s #{}) :set (if (= (first (conj s 1 4)) 1) :vector :list)))\n    (if (coll? (first (seq s))) :map\n        (if (= (count (conj s (first s))) (count s)) :set\n            (if (= (first (conj s (last s))) (first s)) :vector :list)))))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 65, "code": "(fn wcoll [coll] (let [\n  last-val [:c 4]\n  conj-coll (conj coll [:c 3] [:c 3] last-val)\n  conj-increased-coll-size-by #(= (count conj-coll) (+ (count coll) %))]\n  (cond \n    (conj-increased-coll-size-by 1) :map\n    (conj-increased-coll-size-by 2) :set\n    (and (conj-increased-coll-size-by 3) (= (last conj-coll) last-val)) :vector\n    (and (conj-increased-coll-size-by 3) (= (first conj-coll) last-val)) :list)))", "user": "5da05bcce4b000c986472bd0"}, {"problem": 65, "code": "(fn [x]\n  (if (= (conj x {}) x)\n    :map\n    (let [test (conj x 2 3)]\n      (cond (= (count test) (count (conj test 2 3))) :set\n            (= (take 2 (reverse test)) [3 2]) :vector\n            (= (take 2 test) [3 2]) :list))))", "user": "5ddb6151e4b0948ae9d9adb0"}, {"problem": 65, "code": "(fn [c]\n  (cond\n   (get (conj c [:test :val]) [:test :val]) :set\n   (= (get (conj c [:test :val]) :test) :val) :map\n   (= (first (-> c (conj :_) (conj :test))) :test) :list\n   (= (last  (-> c (conj :_) (conj :test))) :test) :vector\n   :else nil))", "user": "5db35f85e4b010eb3c36cd22"}, {"problem": 65, "code": "(fn [col]\n   (cond\n     (= (conj col {}) col) :map \n     (empty? col)\n     (cond\n       (= (clojure.set/union col #{}) #{}) :set\n       (= (conj (conj col 0) 1) [0 1]) :vector\n       :else :list)\n     (= (clojure.set/union col col) col) :set\n     (= (first (conj col col)) col) :list\n     :else :vector))", "user": "5d5824fae4b02ba5928a681f"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5d28c6dce4b092dab7f59c85"}, {"problem": 65, "code": "#(cond\n  (= (first (str %)) \\{) :map\n  (= (first (str %)) \\[) :vector\n  (= (first (str %)) \\#) :set\n  :else :list)", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 65, "code": "(fn [coll]\n     (cond\n       (= (:0 (conj coll [:0 0])) 0)\n        :map\n       (= (apply conj coll (range 2)) (concat coll (range 2)))\n        :vector\n       (= (apply conj coll (range 2)) (concat (reverse (range 2)) coll))\n        :list\n       :else\n        :set))", "user": "5de68f83e4b0986d99407f6c"}, {"problem": 65, "code": "(fn [ss]\n  (cond\n    (= (:a (conj ss [:a 1])) 1) :map\n    (= (conj ss :a) (conj ss :a :a)) :set\n    :else\n    (let [xs (conj ss :a :b)]\n      (if (= (first xs) :b) :list\n                            :vector))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5dfb20b8e4b0a607a9a45cd3"}, {"problem": 65, "code": "(fn bb-testing [seq1] (let [seq2 (into seq1 {101 201})\n                              seq3 (into seq2 {101 201})\n                              seq4 (into seq3 {301 401})\n                              c2 (count seq2)\n                              c3 (count seq3)\n                              f1 (first seq4)]\n                          (if (= c2 c3) ;it is a map or a set\n                            (if(contains? seq2 [101 201])\n                              :set\n                              :map)\n                            (if (= [301 401] f1)\n                              :list\n                              :vector))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 65, "code": "(fn cheat-p-65 [obj]\n  (let [e (empty obj)] \n\t  (cond (= e #{}) :set\n      \t    (= e {}) :map\n        \t(= 1 (first (conj e 1 2))) :vector\n            (= 2 (first (conj e 1 2))) :list\n            :else :bad)))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (get (conj coll [:no-entry 1]) :no-entry) :map\n   (get (conj coll :no-entry) :no-entry) :set\n   (= :no-entry (first (conj coll :fill :no-entry))) :list\n   :else :vector))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (= \"a\"  (get (conj coll [:aa \"a\"]) :aa)) :map\n    (= :aa (get (conj coll :aa) :aa)) :set\n    (= :b (first (apply conj coll [:a :b] ))) :list\n    (= :b (last (apply conj coll [:a :b]))):vector))", "user": "5dfa1c67e4b0a607a9a45cc5"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 65, "code": "(fn class1 [c]\n    (cond\n      (= (empty c) {}) :map\n      (= (empty c) #{}) :set\n      (= (reduce conj (empty c) [1 2 3]) '(3 2 1)) :list\n      (= (reduce conj (empty c) [1 2 3]) [1 2 3]) :vector\n))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 65, "code": "(fn [x]\n  (let [xs (str x)]\n  \t(cond\n      (re-find #\"^#\\{.*\\}$\" xs) :set\n      (re-find #\"^\\{.*\\}$\" xs) :map\n   \t  (re-find #\"^\\[.*\\]$\" xs) :vector\n      (re-find #\"^(.*)$\" xs) :list)))", "user": "5e0ceca5e4b099d064962f91"}, {"problem": 65, "code": "(fn[coll]\n\t  (let [obj (new Object)]\n\t    (let [x (conj coll [1 2])]\n\t      (cond\n\t        (empty? (flatten x)) (if (associative? x) :map :set)\n\t        (= (first (conj x obj)) obj) :list\n\t        :else :vector\n\t      )\n        )\n        )\n)", "user": "5e109435e4b099d064962fcb"}, {"problem": 65, "code": "(fn [coll]\n  (if (associative? coll) (if (reversible? coll) :vector :map)\n                          (if (ifn? coll) :set :list)))", "user": "5cb0f70ce4b026601754b8c1"}, {"problem": 65, "code": "#(let [e (empty %)]\n  (condp = e\n     {}  :map\n    #{} :set\n    (condp = (first (into e [:a :b]))\n      :a  :vector\n      :b  :list)))", "user": "510528a0e4b0730a5f55ad85"}, {"problem": 65, "code": "(fn [elmt]\n  (let [temp (empty elmt)]\n    (cond\n     (= temp #{}) :set\n     (= temp {}) :map\n     :else (if (= (conj temp 1 2) [1 2])\n             :vector\n             :list))))", "user": "5defc177e4b093ff717275af"}, {"problem": 65, "code": "(fn [x]\n    (let [a1 [:a 1]\n          conj-x (conj x a1)\n          cons-x (cons a1 x)]\n      (if (= conj-x cons-x)\n        ;; list or vector, empty collections do not differ\n        (if (= (conj conj-x :a) (cons :a conj-x))\n          :list\n          :vector)\n        (if (contains? conj-x :a)\n          :map\n          (if (contains? conj-x [:a 1])\n            :set\n            :vector)))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 65, "code": "(fn [coll]\n  (if (= 2 (- (count (conj coll \"\" \"\")) (count coll))) ;adding \"\" twice gives two new elements - list or vector\n    (let [new-element (apply str coll)] ;consturcting an element not in coll by concatenating all elements in coll\n      (if (= new-element (first (conj coll 0 new-element))) :list :vector)) ;if new-element was added to the beginning, then list; otherwise, vector\n    (if (contains? coll \"\")\n      (if (contains? (into #{} coll) \"\") :set :map) ;if coll has \"\", and still has \"\" when added to a set, then it's a set\n      (if (contains? (conj coll \"\") \"\") :set :map) ;if, after conjoining \"\" to coll, coll contains \"\", then coll is a set\n    )\n  )\n)", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 65, "code": "(fn [s]\n  (let [e (into (empty s) [[:a :b] [:a :c]])]\n    (if (-> e flatten empty?)\n      (case (count e)\n        1 :map\n        2 :set)\n      (if (-> e (conj :d) first (= :d))\n        :list\n        :vector))))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 65, "code": "(fn classify [x]\n  (letfn [(isMap? [x] (= (:z (conj x [:z :y])) :y))\n          (isSet? [x] (if (isMap? x) false\n                          (= (- (count( conj (conj x :z) :z))\n                                (count x)) 1)))\n          (isList? [x] (if (or (isMap? x) (isSet? x)) false\n                           (=\n                            (first (conj (conj x :z):y))\n                            :y)\n                           ))\n          ]\n    (if (isMap? x) :map\n        (if (isSet? x) :set\n            (if (isList? x) :list :vector)))))", "user": "5e078ba7e4b0978307768fb6"}, {"problem": 65, "code": "(fn [s]\n    ;; This is the worst exercise in human history\n    (let [s+  (conj s  [0 s])\n          s++ (conj s+ [1 s+])]\n      (cond\n        ;; Only sets can be equal to sets\n        (= (into #{} s) s) :set\n        ;; Eliminate maps based on Idempotence\n        (= s+ (conj s+ [0 s])) :map\n        ;; Eliminate list based on order of \"conj\"\n        ;; If adds to the end, ((first s++) = (first s+))\n        ;; And the first element of s+ cannot be [0 s+]\n        (and (= (first s++) [1 s+])) :list\n        ;; Now, we're safe to apply (but vector can only applies to number)\n        ;; Assume ((s+ (dec (count s+))) = [0 s]),\n        ;; 1. If s+ is a map, (s+ (dec (count s+))) => [0 s]\n        ;; iff ((dec (count s+)) = 0), or ((count s) = 0)\n        ;; 2. If s+ is a set, then (s+ (dec (count s+))) => (dec (count s+)) or nil\n        :else :vector\n        #_(and (= (s+ (dec (count s+))) [0 s])\n               (not (= s {}))) :vector\n        #_(= (s+ 0) s) :map)))", "user": "5e38a9cbe4b01d43a70e8dc2"}, {"problem": 65, "code": "(fn [xs]\n  (let [ys (empty xs)]\n    (cond\n     (let [maybe-map (conj ys [:key :val])]\n       (contains? maybe-map :key))\n     :map\n     \n     (= 1 (count (conj ys :unique :unique)))\n     :set\n     \n     (let [[fst snd] (conj ys :fst :snd)]\n       (and (= fst :snd)\n            (= snd :fst)))\n     :list\n     \n     (let [[fst snd] (conj ys :fst :snd)]\n       (and (= fst :fst)\n            (= snd :snd)))\n     :vector\n     \n     :else\n     :dont-know)))", "user": "5d47fa13e4b07c84aa5ae6b6"}, {"problem": 65, "code": "(fn [coll]\n  (let [col (conj coll [:$ :$])]\n    (cond\n     (empty? (flatten col)) (if (associative? col) :map :set)\n     (= :$ (first (conj col :$))) :list\n     (= :$ (last (conj col :$))) :vector)))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 65, "code": "#(cond\n  (= (count (conj % [1 1] [1 1])) (inc (count %)))\n   \t(if (= (count (conj % [1 1] [1 2])) (inc (count %)))\n      :map\n      :set)\n  (= (last (conj % :first :second)) :second)\n  \t:vector\n  :else \n  \t:list)", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 65, "code": "#(get {\\# :set \\[ :vector \\{ :map} (first (str %)) :list)", "user": "5e41b679e4b01d43a70e8e58"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond (:a (conj e [:a 1])) :map\n          (= (count (conj e 1 1 2)) (count (conj e 1 2))) :set\n          (= (first (conj e 1 2 3)) 3) :list\n          :else :vector)))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 65, "code": "(fn [seq]\n   (case (conj (empty seq) [0 0] [0 1])\n     {0 1} :map\n     #{[0 0] [0 1]} :set\n     [[0 0] [0 1]] :vector\n     '([0 1] [0 0]) :list))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 65, "code": "(fn answer [col]\n  (let [base (empty col)]\n    (cond\n      (= base #{}) :set\n      (= base {}) :map\n      (reversible? col) :vector\n      :else :list\n      )\n    ))", "user": "5e491182e4b043cd24807a46"}, {"problem": 65, "code": "(fn [s]\n  (cond\n    (= (conj s {}) s) :map \n    (empty? s) (cond\n                 (= (clojure.set/union s #{}) #{}) :set\n\t         (= (conj (conj s 0) 1) [0 1]) :vector\n\t         :else :list)\n    (= (clojure.set/union s s) s) :set\n    (= (first (conj s s)) s) :list\n    :else :vector))", "user": "57fc5e42e4b0d3187e900997"}, {"problem": 65, "code": "#(let [empty-val (empty %)]\n    (cond\n      (= (str empty-val) \"{}\") :map\n      (= (str empty-val) \"#{}\") :set\n      (= (str empty-val) \"[]\")  :vector\n      :default :list\n      )\n    )", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 65, "code": "(fn [coll]\n    (cond\n     (and (associative? coll) (counted? coll) (reversible? coll)) :vector\n     (and (associative? coll) (not (reversible? coll))) :map\n     (apply distinct? (seq (conj coll 1 1))) :set\n     :else :list))", "user": "5dcc152ae4b02b31cc3da3c3"}, {"problem": 65, "code": "(fn [c] \n    (cond \n      (and (reversible? c) (associative? c)) :vector\n      (and (not (reversible? c)) (associative? c)) :map\n      (= 2 (count (conj (empty c) 1 1))) :list\n      :else :set))", "user": "5e08c3dde4b0978307768fc8"}, {"problem": 65, "code": "(fn [o]\n  (let [[k1 k2 :as k] [(gensym) (gensym)]\n        ext (conj o k)]\n    (cond\n      (= (get ext k1) k2) :map\n      (= (get ext k) k) :set\n      (= (last (conj (conj o k1) k2)) k2) :vector\n      :else :list)))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 65, "code": "(fn [coll]\n  (let [old (count coll) new (reduce conj coll [[1 1] [1 1] [1 2]])]\n      (cond \n        (= (count new) (+ old 2)) :set\n        (= (count new) (+ old 1)) :map\n        (= (first new) [1 2]) :list\n        :else :vector\n        ) \n    ))", "user": "5e44c804e4b01d43a70e8e89"}, {"problem": 65, "code": "(fn [unk]\n  (if (= (conj unk {:x 3}) (conj (conj unk {:x 3}) {:x 3}))\n    (if (nil? (:x (into unk {:x 3})))\n      :set\n      :map\n      )\n    (if (= (cons :x (cons :y unk)) (into unk '(:y :x)))\n      :list\n      (if (= (concat unk '(:x :y)) (conj (conj unk :x) :y))\n        :vector\n    :map\n    ))))", "user": "5e65bfe4e4b0fd0acd1586b9"}, {"problem": 65, "code": "(fn [coll]\n    (let [a (gensym)\n          b (gensym)\n          test-case (conj (empty coll) [a b] [a a] [a a])\n          test-size (count test-case)]\n      (cond\n        (= 1 test-size) :map\n        (= 2 test-size) :set\n        (= (first test-case) [a a]) :list\n        :else :vector)))", "user": "5df70ee8e4b0a607a9a45c8a"}, {"problem": 65, "code": "(fn [x] (cond\n         (= x (merge x x)) :map\n         (not= x (map identity x)) :set\n         (= :b (first (conj x :a :b))) :list\n         :else :vector))", "user": "5e246f92e4b05b4b01516150"}, {"problem": 65, "code": "(fn [coll]\n  (letfn [(is-set? [xs]\n            (and (not (associative? xs))\n                 (apply distinct? (conj xs 1 1))))\n          (is-map? [xs]\n            (and (associative? xs)\n                 (not (reversible? xs))))\n          (is-list? [xs]\n            (and (not (associative? xs))\n                 (not (apply distinct? (conj xs 1 1)))))\n          (is-vec? [xs]\n            (and (associative? xs)\n                 (reversible? xs)))]\n    (cond\n      (not (coll? coll)) \"adios amigos!\"\n      (is-map? coll) :map\n      (is-set? coll) :set\n      (is-vec? coll) :vector\n      (is-list? coll) :list)))", "user": "5be1c6c6e4b0ed4b8aab4ca5"}, {"problem": 65, "code": "(fn [coll]\n  (let [test-value [:key coll] my-coll (conj coll test-value)]\n    (if (= (count (conj my-coll test-value)) (count my-coll))\n      (if (= (:key my-coll) coll)\n        :map\n        :set)\n      (if (= (first (conj my-coll nil)) nil)\n        :list\n        :vector))))", "user": "5e563c88e4b027a2e10ac0f6"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5e639b4be4b0fd0acd1586a2"}, {"problem": 65, "code": "(fn func [x]\n  (cond\n    (= x (conj x x)) :map\n    (< (count (into x [nil nil])) (+ 2 (count x))) :set\n    (= x (first (into x [nil x]))) :list\n    (= x (last (into x [nil x]))) :vector))", "user": "5e805895e4b085ba37836e44"}, {"problem": 65, "code": "(fn [val]\n  (let [instancex? (fn\n                     [c x]\n                     (. c (isInstance x)))]\n    (cond\n      (instancex? clojure.lang.IPersistentMap val) :map\n      (instancex? clojure.lang.IPersistentVector val) :vector\n      (instancex? clojure.lang.IPersistentSet val) :set\n      (instancex? clojure.lang.IPersistentCollection val) :list)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 65, "code": "(fn [coll]\n  (let [k (gensym)\n        x [k :x]\n        y [k :y]\n        c (conj coll x x y)]\n    (case (- (count c) (count coll))\n      1 :map\n      2 :set\n      3 (if (= y (first c)) :list :vector))))", "user": "4eb70649535d7eef30807373"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "58468c4ee4b089d5ab817e95"}, {"problem": 65, "code": "#(let [conj? (fn [x] (= x (conj x (first x))))\nisVec? (fn [c] (and (reversible? c) (associative? c)))\nisMap? (fn [c] (and (conj? c) (associative? c)))\nisSet? (fn [c] (or (= c #{}) (and (conj? c) ((complement associative?) c))))]\n(cond\n(isVec? %) :vector\n(isMap? %) :map\n(isSet? %) :set\n:else :list))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 65, "code": "(fn [s]\n  (if (= (count (conj s [0 1])) (count (conj s [0 1] [0 1])))\n    ;; :map or :set\n    (if (empty? s)\n      (if (contains? (conj s [:a 0]) :a)\n        :map :set)\n      (if (contains? s (first s)) :set :map))\n   ;; :list or :vector \n    (if (= (conj s 0 1) (conj (seq s) 0 1)) :list :vector)))", "user": "5e9c11f8e4b0157ca96647f6"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5e980e6be4b0157ca96647d6"}, {"problem": 65, "code": "(fn f [coll]\n  (let [result (conj (empty coll) [1 1] [1 1] [1 2])]\n    (cond\n      (= 1     (count result)) :map\n      (= 2     (count result)) :set\n      (= [1 2] (first result)) :list\n      :else                    :vector)))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 65, "code": "(fn [xs]\n  (let [result (conj (empty xs) [1 1] [1 1] [1 3])]\n    (condp = (count result)\n      1 :map\n      2 :set\n      3 (if (= (first result) [1 1]) :vector :list))))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5e954b9ee4b0fbed045a3809"}, {"problem": 65, "code": "(fn [coll]\n  (let [x [:t :u], y [:u :t], coll2 (conj coll x y)]\n    (cond\n      (= x (get coll2 x)) :set\n      (= coll2 (conj coll2 x)) :map\n      (= y (first coll2)) :list\n      :else :vector)))", "user": "5e9f38cce4b00a66d4a9517e"}, {"problem": 65, "code": "(fn [coll]\n   (let [c1 (conj coll [:a 3] [:a 3])\n         c2 (conj c1 [:f 4] [:f 4])\n         n (count c2)]\n     (cond\n       (= 3 (get c2 :a)) :map\n       (not= n (+ 4 (count coll))) :set\n       (= '([:f 4] [:f 4]) (take-last 2 c2)) :vector\n       (= '([:f 4] [:f 4]) (take 2 c2)) :list\n       :else :wtf)))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 65, "code": "#(let [c (conj % [:a :b])]\n   (cond\n  (= (get c (count %))\n     [:a :b]) :vector\n  \n  (get c [:a :b]) :set\n \n  (= :b (get c :a)) :map\n    \n  :else :list))", "user": "5e64ae6ce4b0fd0acd1586ac"}, {"problem": 65, "code": "#(let [x (str %)\n       y (str (first x) (last x))]\n    (case y\n      \"{}\" :map\n      \"[]\" :vector\n      \"#}\" :set\n      :list))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 65, "code": "#(let [r (conj (empty %) [1 2] [1 2] [1 3])]\n  (cond\n    (= 1 (count r)) :map\n    (= 2 (count r)) :set\n    (= (first r) [1 2]) :vector\n    :else :list))", "user": "5eb5d9bbe4b00a66d4a9522e"}, {"problem": 65, "code": "#(let [c (conj (empty %) [:a 1]) v [:b 2] d (conj (conj c v) v)]     \n   (cond                                                             \n     (= (:a c) 1) :map                                               \n     (= (count d) 2) :set                                            \n     (= (first d) [:b 2]) :list                                      \n     :else :vector))", "user": "5e5096c6e4b027a2e10ac0c6"}, {"problem": 65, "code": "(fn [coll]\n  (if (associative? coll)\n    (if (= (assoc coll 0 1) (vec (assoc coll 0 1)))\n      :vector\n      :map)\n    (if (= (count (conj coll :test :test)) (+ (count coll) 2))\n      :list\n      :set)))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 65, "code": "(fn bb [x] (cond\n          (some (fn [z] (= z [3 4])) (conj x {3 4})) :map\n          (= (conj  x 1) (conj (conj x 1) 1)) :set\n          (= (concat x [1 2]) (conj (conj x 1) 2)) :vector\n          :else :list))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 65, "code": "(fn [c]\n   (cond\n     (= (get (conj c {:t \"test\"}) :t) \"test\") :map\n     (= (get (conj c :t) :t) :t) :set\n     (= (last (conj (conj c 1) 2)) 2) :vector\n     (= (first (conj (conj c :a) :b)) :b) :list))", "user": "5b337ff4e4b025bcb146f339"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "568f2059e4b0dcc4269f40df"}, {"problem": 65, "code": "(fn solution [coll]\n  (let [empty-coll (empty coll)]\n    (case empty-coll\n      [] (if (reversible? coll) :vector :list)\n      #{} :set\n      {} :map)))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 65, "code": "(fn [x] \n  (cond\n   (= 2 (get (conj x [100 2]) 100)) :map\n   (= (+ 1 (count x)) (count (conj (conj x 6) 6))) :set\n   (= (first (conj (conj x 100) 200)) 200) :list\n   (= (first (conj (conj x 100) 200)) (first (conj x 100))) :vector  \t\t\t  \n  ))", "user": "5ec819b4e4b08d0ec38692e2"}, {"problem": 65, "code": "#(let [s (empty %)]\n   (cond\n    (= {} s)  \t\t\t\t:map\n    (= #{} s) \t\t\t\t:set\n\t(= [0 1]  (conj s 0 1)) :vector\n    (= '(1 0) (conj s 0 1)) :list))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 65, "code": "(fn [coll] (cond\n               (= (conj coll [:x 1]) (conj coll [:x 2] [:x 1])) :map\n               (= (conj coll 1) (conj coll 1 1)) :set\n               (= (conj coll 1 2) (conj (apply list coll) 1 2)) :list\n               :else :vector))", "user": "5ed4a4ade4b016b56eae05cd"}, {"problem": 65, "code": "#(case ((juxt associative? reversible? ifn?) %)\n    [true true true] :vector\n    [false false false] :list\n    [true false true] :map\n    [false false true] :set)", "user": "5ea21034e4b00a66d4a95191"}, {"problem": 65, "code": "(fn [col]\n  (let [std (empty col)]\n    (cond \n    \t(= std #{}) :set\n    \t(= std {}) :map\n     \t(= std ()) (if (reversible? col) :vector :list))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 65, "code": "(fn [x]\n  (if (= (rest (cons :a x)) x)\n    ;; vec or list\n    (if (= :b (last (conj (conj x :a) :b)))\n      :vector\n      :list\n      )\n    (if (= :b ((conj x [:a :b]) :a))\n      :map\n      :set)\n    )\n    )", "user": "5ed8a12fe4b0c7845d86b0d7"}, {"problem": 65, "code": "(fn bb [coll]\n  (let [conj_1 (conj coll [:a 1])\n        conj_2 (conj conj_1 [:a 2])]\n    (cond\n     (= (get conj_1 :a) 1) :map\n     (= (get conj_1 [:a 1]) [:a 1]) :set\n     (= (last conj_2) [:a 2]) :vector\n     :default :list)))", "user": "5edd6eb7e4b0c7845d86b0f7"}, {"problem": 65, "code": "(fn [coll]\n  (let [e (empty coll)]\n    (cond (= {0 1} (conj e {0 0} {0 1})) :map\n          (= #{0} (conj e 0 0)) :set\n          (= [0 1] (conj e 0 1)) :vector\n          :else :list)))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 65, "code": "(fn [x] (let [l (get (str x) 0)]\n          (case l\n            \\( :list\n            \\[ :vector\n            \\{ :map\n            \\# :set\n            \\c :list)))", "user": "5ed875abe4b016b56eae05f2"}, {"problem": 65, "code": "#(cond (contains? % :a) :map\n  (and (= 0 (count %)) (= (first (conj % {:a 1})) [:a 1])) :map\n  (= 6 (count %)) :vector\n       (= (count (conj % 20)) (count (conj (conj % 20) 20))) :set\n  (= 87 (first (conj (conj % 88) 87))) :list\n  \n  (= 2 (count %)) :set \n  \n  \n  (= 88 (first (conj (conj % 88) 87))) :vector\n       \n        \n\n)", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 65, "code": "(fn [coll]\n  (let [ec (empty coll)]\n    (if (= ec {})\n      :map\n      (if (= ec #{})\n        :set\n        (if-let [sample (first (conj ec 0 1))]\n          (if (= sample 0) :vector :list)\n          \"dunno\")))))", "user": "5ed52854e4b016b56eae05d2"}, {"problem": 65, "code": "(fn black-box-texting [s]\n  (cond\n    (= (count s) (count (merge s s))) :map\n    (< (count (filter zero? (conj s 0 0))) 2) :set\n    (= (first (conj s 0 1 2)) 2) :list\n    :else :vector))", "user": "5c665311e4b0fca0c16226a7"}, {"problem": 65, "code": "(fn __\n  [x]\n  (let [x-empty (empty x)]\n    (cond\n      (= x-empty {}) :map\n      (= x-empty #{}) :set\n      (reversible? x-empty) :vector\n      (= x-empty ()) :list)))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 65, "code": "(fn [coll]\n  (let [a [1 2]\n        b [2 1]\n        xs (conj (conj (conj coll a) a) b)\n        cc (count coll)\n        xc (count xs)]\n    (if (or (= xc (inc cc)) (= xc (+ cc 2)))\n      (let [x (get xs a)]\n        (if (= x a)\n          :set\n          :map))\n      (let [xf (first xs)]\n        (if (= xf b)\n          :list\n          :vector)))))", "user": "5eccc5c2e4b016b56eae058f"}, {"problem": 65, "code": "(fn [x]\n  (cond\n    (= (count (into x [[:zzz 0] [:zzz 1]])) (count (into x [[:zzz 0]]))) :map\n    (= (count (into x [:zzz :zzz])) (count (into x [:zzz]))) :set\n    (= :zzz (first (into x [:yyy :zzz]))) :list\n    :else :vector))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 65, "code": "(fn [x]\n  (let [y (empty x)]\n    (cond\n      (= y {}) :map\n      (= y #{}) :set\n      :else (let [z (conj (conj y 1) 2)]\n        (if (= z [1 2]) :vector :list)))))", "user": "5eb4927fe4b00a66d4a95221"}, {"problem": 65, "code": "(fn\n  [coll]\n  (cond\n    (= \"t\" (get (conj coll [:t \"t\"]) :t)) :map\n\n    (= :t (get (conj coll :t) :t)) :set\n\n    (= :b (first (conj coll :a :b))) :list\n\n    (= :b (last (conj coll :a :b))) :vector\n    ))", "user": "5cf1d9e3e4b0aaa82f112a18"}, {"problem": 65, "code": "(fn [x]\n  (let [a [:_z 1]\n        b [:_zz 2]\n        c (conj x a b)]\n    (cond\n      (= 1 (get c :_z)) :map\n      (= a (get c a))   :set\n      (= b (first c))   :list\n      :else             :vector)))", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 65, "code": "(fn [col]\n  (let [x (conj col [5 6])]\n    (if (= '() (flatten x))\n      (if (contains? x [5 6])\n        :set\n        :map\n      )\n      (if (=\n           (conj x [7 8])\n\t\t   (cons [7 8] x))\n        :list\n        :vector\n      )\n    )\n  )\n)", "user": "5df08767e4b093ff717275bf"}, {"problem": 65, "code": "(fn [col]\n  (cond (= :a (get (conj col [:a :a]) :a)) :map\n        (= 1 (count (filter #(= % :a) (conj col :a :a)))) :set\n        (= :a (last (conj col :b :a))) :vector\n        (= :a (first (conj col :b :a))) :list))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 65, "code": "#(cond \n    (not (some (fn [k & v] (nil? (get k 1))) (conj %1 {2 3}))) :map\n    (let [s (conj %1 1)] (= (conj s (first s)) s)) :set\n    (nil? (get (conj %1 1) 0)) :list\n    :else :vector)", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 65, "code": "(fn my-type [x] (\n                    cond\n                    (= (conj x {}) x ) :map\n                    (empty? x) (cond\n                                 (= (clojure.set/union x #{}) #{} ) :set\n                                 (= (conj (conj x 0) 1) [0 1]) :vector\n                                 :else  :list\n                                 )\n\n                    (= (clojure.set/union x x) x ) :set\n                    (= (first (conj x x)) x) :list\n                    :else :vector\n                    )\n\n  )", "user": "5edc16e1e4b0c7845d86b0f1"}, {"problem": 65, "code": "(fn [s]\n  (let [conjed (conj s [:a 1] [:b 2])]\n    (if (= (:a conjed) 1)\n      :map\n      (if (= (get conjed [:a 1]) [:a 1])\n        :set\n        (if (= (first conjed) [:b 2])\n          :list\n          :vector)))))", "user": "5f0b61e6e4b0f30dddfb5d44"}, {"problem": 65, "code": "(fn [s]\n           (if (associative? s)\n             (if (reversible? s)                            ; [] or {}\n               :vector\n               :map)\n             (if (= (conj s :litmus-test)                   ; #{} or '()\n                    (conj s :litmus-test :litmus-test))\n               :set\n               :list)))", "user": "5f01952fe4b0cf489e8d7f22"}, {"problem": 65, "code": "(fn [sq] (cond\n\t(= (empty sq) {}) (keyword 'map)\n\t(= (empty sq) #{}) (keyword 'set)\n\t(= (last(conj (into sq [1]) 's')) 's') (keyword 'vector)\n\t(= (first(conj (cons 1 sq) 's')) 's') (keyword 'list)\n))", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [empty-col (empty coll)]\n    (cond\n      (= empty-col {})        :map\n      (= empty-col #{})       :set\n      (reversible? empty-col) :vector\n      (= empty-col ())        :list)))", "user": "5f10fb99e4b091ba50b4dba8"}, {"problem": 65, "code": "(fn [coll] (let [n (count coll)\n                 t [:test :test]\n                 t2 [:test2 :test2]\n                 coll2 (conj coll t t t2)\n                 n2 (count coll2)]   \n             (if (= n2 (+ n 2))\n               (if (nil? (coll2 :test))\n                 :set\n                 :map)\n               (if (= (first coll2) t2)\n                 :list\n                 :vector))))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 65, "code": "(fn type-info [c]\n  (cond\n    (= (get (conj c {:a 1}) :a) 1) :map\n    (= (count (conj c :a)) (count (conj (conj c :a) :a))) :set\n    (= (last (conj (conj c :a) :b)) :b) :vector\n    :else :list))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 65, "code": "(fn [s]\n  (cond\n    (= (conj s [:a 1]) (conj s [:a 0] [:a 1])) :map\n    (= (conj (vec s) 0 1) (conj s 0 1)) :vector\n    (= (list* 0 1 s) (conj s 1 0)) :list\n    (= (conj s 0) (conj s 0 0)) :set))", "user": "5d431c77e4b07c84aa5ae68f"}, {"problem": 65, "code": "(fn get-coll-type [coll]\n  (let [first-token [(gensym) (gensym)]\n        second-token [(gensym) (gensym)]\n        conjd-coll (conj (conj coll first-token) second-token)]\n    ;; Check if first-token is inserted twice\n    (if (= (count conjd-coll) (count (conj conjd-coll first-token)))\n      ;; Check if vector of two elements is treated like a key-value pair\n      ;; (hence implying coll is a map)\n      (if (= (count (conj coll [1 1])) (count (conj (conj coll [1 1]) [1 0])))\n        :map :set)\n      (if (= (last conjd-coll) second-token) :vector :list))))", "user": "5f21d172e4b0f565ad998286"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (reversible? coll) :vector\n   (associative? coll) :map\n   (= (inc (count coll)) (count (conj (conj coll 30) 30))) :set\n   :else :list))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 65, "code": "(fn black-box\n  [x]\n  (cond\n    (let [y (conj x [:test :foo])]\n      (= (get y :test) :foo))\n    :map\n    (let [y (conj (empty x) 1 1)]\n      (= (count y) 1))\n    :set\n    (let [y (conj (empty x) 1 2)]\n      (= (first y) 1))\n    :vector\n    :else\n    :list\n    ))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 65, "code": "(fn [c]\r\n  (let [b (empty c)]\r\n    (cond\r\n      (= b {})        :map\r\n      (= b #{})       :set\r\n      (reversible? b) :vector\r\n      (= b ())        :list)))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})  :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? coll) :vector :list))))", "user": "5ee75f8be4b029a2061bbea5"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (= coll (conj coll '())) :map\n    (= (conj coll :a :a) (conj coll :a)) :set\n    (= (conj coll :a :b) (cons :b (cons :a coll))) :list\n    :else :vector))", "user": "5e9154c1e4b0cb0169546354"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (cond\n    (= (get (conj coll [::key ::val]) ::key) ::val) :map\n    (== (count (conj coll ::element ::element)) (inc (count coll))) :set\n    :else (let [coll' (conj coll ::element1 ::element2)]\n            (if (= ::element2 (first coll'))\n              :list\n              :vector))))", "user": "5f300f28e4b033932238a682"}, {"problem": 65, "code": "(fn f [col] \n    (cond\n        (= (conj col {}) col) :map\n        ; Adding item to set can be retrieved by it's value\n        (= (get (conj col :item) :item) :item) :set\n        ; conj-ing to list adds to beginning for list, need to add 2 items to account for empty\n        (= (first (conj (conj col :a) :b)) :b) :list\n        ;conj-ing to last adds to end for vector\n        (= (last (conj (conj col :a) :b)) :b) :vector\n    ))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 65, "code": "(fn [coll]\n    (if (associative? coll)\n      (if (reversible? coll) :vector :map)\n      (if (ifn? coll) :set :list)))", "user": "5f431d32e4b0955706451fb5"}, {"problem": 65, "code": "#(let [e (empty %)]\n   (cond (= e (into #{} e)) :set\n         (= e (into {} e)) :map\n         (= '(2 1) (conj e 1 2)) :list\n         (= [1 2] (conj e 1 2)) :vector\n         :else nil))", "user": "5edab150e4b0c7845d86b0e9"}, {"problem": 65, "code": "(fn blackbox\n  [coll]\n  (let [new-coll (conj (empty coll) [1 2] [1 2] [1 3])]\n    (condp = new-coll\n      [[1 2] [1 2] [1 3]] :vector\n      [[1 3] [1 2] [1 2]] :list\n      {1 3} :map\n      :set)))", "user": "5f29837ee4b033932238a64f"}, {"problem": 65, "code": "#(get  {\\# :set, \\[ :vector, \\( :list, \\{ :map} (first (pr-str (empty %))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 65, "code": "(fn [c]\n   (let [cnt (count c)\n         new-c (conj c [1 1] [1 2] [1 2])]\n     (cond\n       (not= (+ cnt 3) (count new-c)) (if (= 2 (new-c 1)) :map :set)\n       (and (= (first new-c) [1 2]) (= (second new-c)) [1 1]) :list\n       :else :vector)))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 65, "code": "(fn [coll]\n  (let [result (conj (empty coll) [1 2] [1 2] [1 3])]\n    (cond\n      (= 1 (count result)) :map\n      (= 2 (count result)) :set\n      (= [1 2] (first result)) :vector\n      :else :list)))", "user": "5f56c0cae4b0a0bc16850a8c"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= c (conj c {})) :map\n    (= (conj (conj c :foo) :bar) (conj (conj c :bar) :foo)) :set\n    (= :foo (last (conj (conj c :bar) :foo))) :vector\n    :else :list\n  )\n)", "user": "5f574662e4b0a0bc16850a90"}, {"problem": 65, "code": "(fn f [xs]\n  (if (< (count xs) 2)\n    (f (merge xs {:a :b} {:c :d}))\n    (cond\n     (= xs (conj xs (first xs))) (if (contains? xs (first xs)) :set :map)\n     (= (first xs) (first (conj xs (last xs)))) :vector\n     true :list)))", "user": "5f5e7158e4b02876ed9fcff0"}, {"problem": 65, "code": "#(condp = (-> % str first)\n   \\{ :map\n   \\# :set\n   \\[ :vector\n   :list)", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 65, "code": "(fn type* [col] \n  (let \n   [ vector?* (fn [col]\n                (let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v)))) \n    set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k)))) \n    map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k)))) ] (cond (map?* col) :map (set?* col) :set (vector?* col) :vector :else :list )))", "user": "5f631e11e4b02876ed9fd011"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (= (get (conj coll [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj coll :t) :t) :t) :set\n    (= (first (conj (conj coll :a) :b)) :b) :list\n    (= (last (conj (conj coll :a) :b)) :b) :vector))", "user": "5f5f9483e4b02876ed9fcff8"}, {"problem": 65, "code": "(fn [coll]\n  (let [x (empty coll)]\n  (if (= (conj x [:x 1] [:y 1]) (conj x [:y 1] [:x 1]))\n    (if (= 2 (count (conj x [:a 1] [:a 2]))) :set :map)\n    (if (= :aaa (first (conj x :aaa :bbb))) :vector :list))))", "user": "5f648ef1e4b02876ed9fd01b"}, {"problem": 65, "code": "(fn [coll]\n  (if (= (get (conj coll [:foo \"bar\"]) :foo) \"bar\")\n    :map\n    (if (nil? (get (conj coll :foo \"bar\") :foo))\n              (cond\n    (= (last (conj coll [:foo \"bar\"] [:yuck \"fou\"])) [:yuck \"fou\"]) :vector\n    (= (first (conj coll [:foo \"bar\"] [:yuck \"fou\"])) [:yuck \"fou\"]) :list)\n\n  :set)))", "user": "5f63d933e4b02876ed9fd018"}, {"problem": 65, "code": "(fn [coll]\n    (let [mark (conj (conj (conj coll\n                  [:two :one]) [:one :two]) [:one :two] )\n          vmark (vec mark) ]\n\n    (if (< (count mark) (+ 3 (count coll)))\n        ; set or map\n        (if (contains? mark [:one :two])\n            :set\n            :map)\n        ; list or vector\n        (if (= (first vmark) [:one :two])\n            :list\n            (if (= (last vmark) [:one :two])\n                :vector\n                :panic))\n     )))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 65, "code": "; not using the trick \"empty\" the collection\n; stolen elegant solution #(or({{}:map #{}:set}(empty %))({[1 2]:vector[2 1]:list} (conj(empty %)1 2)))\n(fn typer[col]\n       (if (associative? col)\n         (if (reversible? col)\n           :vector\n           :map\n           )\n         (if (empty? col)\n           (if (= col (concat col col))\n             :list\n             :set\n             )\n           (if (= col (conj col (first col)))\n              :set\n              :list\n           ))\n         ))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= (get (conj coll [:t \"t\"]) :t) \"t\") :map\n   (= (get (conj coll :t) :t) :t) :set\n   (= (first (conj (conj coll :a) :b)) :b) :list\n   (= (last (conj (conj coll :a) :b)) :b) :vector))", "user": "5f5f2eafe4b02876ed9fcff5"}, {"problem": 65, "code": "(fn identify\n  [& args]\n  (let [x (first (str (first args)))]\n    (case x\n      \\# :set\n      \\{ :map\n      \\c :list\n      \\( :list\n      \\[ :vector)))", "user": "5f6e23e6e4b02876ed9fd064"}, {"problem": 65, "code": "(fn [a] (cond   \n  (.isInstance clojure.lang.PersistentArrayMap a) :map \n  (.isInstance clojure.lang.PersistentHashSet a) :set\n  :else (if (= (take 2 (conj a 1 2)) '(1 2)) :vector :list)))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 65, "code": "(fn [s]\n  (cond\n    (:_a (into s [[:_a :_b]])) :map\n    (= 1 (count (filter #{:a} (into s [:a :a])))) :set\n    (= :a2 (first (conj s :a1 :a2))) :list\n    :else :vector\n    )\n  )", "user": "5f58db95e4b0a0bc16850a9a"}, {"problem": 65, "code": "(fn [sequence]\n   (let [modified-sequence (->> [[:key 1] [:key 1] [:key2 1]]\n                                (reduce #(conj %1 %2) sequence))]\n     (if (= 2 (- (count modified-sequence) (count sequence)))\n       (if (get modified-sequence :key)\n         :map\n         :set)\n       (if (= (last modified-sequence) [:key2 1])\n         :vector\n         :list))))", "user": "5f79bff2e4b02876ed9fd0ca"}, {"problem": 65, "code": "(fn bbt\n  [x]\n  (if (ifn? x) ; vector, map, set\n    (if (empty? (flatten (conj x [:x :x]))) ; map set\n      (if (= :x ((conj x [:x :x]) :x))\n        :map\n        :set)\n      :vector)\n    :list))", "user": "4e8a170c535d3e98b802328f"}, {"problem": 65, "code": "(fn [xs]\n    (let [v\n          [(reversible? xs)\n           (associative? xs)\n           (= xs (reverse (reverse xs)))]]\n      (case v\n        [false true false] :map\n        [false false false] :set\n        [true true true] :vector\n        [false false true] :list\n        )))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 65, "code": "(fn [in]\n  (let [r-gen (fn [] (apply str (take 32 (repeatedly #(char (let [r (rand-int 26)] (if (zero? (rand-int 2)) (+ 65 r) (+ 97 r))))))))\n        [r-str-1 r-str-2 r-str-3] [(r-gen) (r-gen) (r-gen)]\n        l (count in)\n        o (count (conj (conj in [r-str-1 r-str-2]) [r-str-1 r-str-2]))]\n    (if (= (inc l) o)\n      (case (- (count (conj (conj in [r-str-1 r-str-2]) [r-str-1 r-str-3])) l)\n        1 :map\n        2 :set)\n        (if (= r-str-2 (first (conj in (conj in r-str-1) r-str-2)))\n          :list\n          :vector))))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 65, "code": "#(cond\n  (= \"v\" (get (conj % [:k \"v\"]) :k)) :map\n  (= (conj % \"v\") (-> % (conj \"v\") (conj \"v\"))) :set\n  (= \"w\" (last (-> % (conj \"v\") (conj \"w\")))) :vector\n  (= \"w\" (first (-> % (conj \"v\") (conj \"w\")))) :list)", "user": "596a66cde4b069c0a1a19803"}, {"problem": 65, "code": "(fn bbt [c]\n  (let [k :a\n        e [k 1]\n        c (empty c)\n        c (conj (conj c e) e)]\n    (if (= (count c) 2)\n      (let [c (conj c 3)]\n        (if (= (first c) 3)\n          :list\n          :vector))\n      (if (contains? c k)\n        :map\n        :set))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 65, "code": "(fn black-box-testing\n  [s]\n  (let [s-empty  (empty s)\n        result   (conj s-empty [1 1] [1 2] [1 2])\n        result-f (first result)\n        result-c (count result)]\n    (cond\n      (= result-c 2) :set\n      (= result-c 1) :map\n      (= result-f [1 1]) :vector\n      :else :list)))", "user": "5f3103aee4b0574c87022c24"}, {"problem": 65, "code": "(fn [a]\n  (let [base (empty a)]\n    (cond\n      (= base {}) :map\n      (= base #{}) :set\n      (= base '()) (if (reversible? a) :vector :list))))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (conj (empty coll) [1 2] [3 4])]\n    (case c\n      '([3 4] [1 2]) :list\n      [[1 2] [3 4]] :vector\n      {1 2, 3 4} :map\n      #{[3 4] [1 2]} :set)))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 65, "code": "(fn\n  [c]\n  (cond\n    (= 1 (get (conj c [:t 1]) :t)) :map\n    (= 2 (first (conj c 1 2 2))) :list\n    (= (count (conj c 1)) (count (conj c 1 1))) :set\n    (= 2 (last  (conj c 1 2 2))) :vector))", "user": "5cf938a5e4b0b71b1d808a90"}, {"problem": 65, "code": "(fn [coll]\n  (let [l1 [:m1 :m2]\n        l2 [:m3 :m4]]\n    (cond\n     (= (conj coll l1 l2) (apply list l2 l1 coll)) :list\n     (not (= (conj coll l1 l2) (conj coll l2 l1))) :vector\n     (contains? (conj coll l1) l1) :set\n     :else :map)))", "user": "5e909685e4b0cb016954634d"}, {"problem": 65, "code": "(fn [coll]\n    (cond\n        (= \"test-value\" (get (conj coll {:test-key \"test-value\"}) :test-key))\n            :map\n        (= 1 (get (frequencies (conj coll :test-key :test-key)) :test-key))\n            :set\n        (= (take 2 (conj coll :test-key-a :test-key-b)) '(:test-key-b :test-key-a))\n            :list\n        (= (take-last 2 (conj coll :test-key-a :test-key-b)) '(:test-key-a :test-key-b))\n            :vector))", "user": "5fb2eac0e4b08cb800c85b2f"}, {"problem": 65, "code": "(fn [s]\n    (let [c  (empty s)\n          c1 (conj c [:a 1] [:a 1] [:b 2])]\n      (cond\n        (= 2 (:b c1))         :map\n        (= 2 (count c1))      :set\n        (= [:a 1] (first c1)) :vector\n        :else                 :list)))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5facfb48e4b08cb800c85aea"}, {"problem": 65, "code": "(fn seq-test [s]\n  (cond\n    (reversible? s) :vector\n    (associative? s) :map\n    (= s (into #{} s)) :set\n    :else :list))", "user": "5f838122e4b01aacbe7a2715"}, {"problem": 65, "code": "(fn [c]\n\n  (if (= (get (conj (empty c) [:a 1]) :a) 1) :map\n\n  (if (= (count (conj (empty c) :a :a)) 1) :set\n\n  (if (= (first (conj (empty c) :a :b)) :a) :vector :list))))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 65, "code": "#(cond\n (get (conj % [1 1]) 0) :vector\n (:a (conj % [:a 1])) :map\n (apply distinct? (conj % 1 1)) :set\n :else :list)", "user": "5fa96ddbe4b0fa27300f3dec"}, {"problem": 65, "code": "(fn t [arg]\n  (case (str (empty arg))\n    \"#{}\" :set\n    \"{}\" :map\n    \"[]\" :vector\n    :list))", "user": "5f9c4113e4b0715f5002d821"}, {"problem": 65, "code": "(fn [s]\n    (let [s1  (conj s  [:not-exists0 0] {:not-exists1 1 :not-exists2 2})\n          s2 (into s1 s1)]\n      (if (= s1 s2)\n        (if (= (+ 3 (count (apply list s))) (count (apply list s1)))\n          :map ; conj map1 map2  can add many entries from map2\n          :set)\n        (if (= (first s2) (last s2))\n          :list\n          :vector))))", "user": "573a0ecce4b0cd1946bd1088"}, {"problem": 65, "code": "(fn [coll]\n  (let [x [:x :y]]\n    (if (= (inc (count coll)) (count (into coll [x x])))\n      \n      (if (:x (conj coll x))\n        :map\n        :set)\n      \n      (if (= :z (first (conj (conj  coll :w) :z)))\n      \t:list\n      \t:vector))))", "user": "54c13b87e4b0ed20f4ff6f20"}, {"problem": 65, "code": "#(cond (:test (conj % [:test :test])) :map\n       (:test (conj % :test)) :set\n       (= :b (first (conj (conj % :a) :b))) :list\n       (= :b (last (conj (conj % :a) :b))) :vector)", "user": "5e471203e4b043cd24807a2a"}, {"problem": 65, "code": "(fn [coll]\n  (let [zero (empty coll)]\n  (cond \n   (= zero {})        :map\n   (= zero #{})       :set\n   (reversible? zero) :vector\n   (= zero ())        :list)))", "user": "5ff40352e4b05ac5b16ea209"}, {"problem": 65, "code": "#(cond\n    (= (get (conj % [:a \"a\"]) :a) \"a\") :map\n    (= (get (conj % :a) :a) :a) :set\n    (= (first (conj (conj % :a) :b)) :b) :list\n    (= (last (conj (conj % :a) :b)) :b) :vector)", "user": "5fe362d9e4b05ac5b16ea179"}, {"problem": 65, "code": "(fn [x]\n  (let [k :x v 2\n        e [k v]\n        y (conj x e)]\n    (cond\n      (= v (get y k)) :map\n      (= y (conj y e)) :set\n      (nil? (get y 0)) :list\n      :else :vector\n      )\n    )\n  )", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 65, "code": "(fn [col]\n    (let [items [:hello :hello]\n          xxx :clojure]\n      (cond\n        (get (conj col items) :hello) :map\n        (not= (+ (count col) (count items))\n              (count (apply conj col items))) :set\n        (= xxx (first (apply conj col items [xxx]))) :list\n        (= xxx (last (apply conj col items [xxx]))) :vector\n        :else :others\n        ))\n    )\n\n;; #(condp = (nth (str %) 0)\n;;      \\{ :map\n;;      \\c :list\n;;      \\[ :vector\n;;      \\# :set)\n\n;; (comp #(cond\n;;            (= % {}) :map\n;;            (= % #{}) :set\n;;            (= (conj % 1 2) [1 2]) :vector\n;;            true :list)\n;;         empty)", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "5f419985e4b0955706451fab"}, {"problem": 65, "code": "(fn detect [sq]\n  (cond\n    (= (into #{} sq) sq) :set\n    (and (even? (count sq)) (= (apply hash-map (flatten (seq sq))) sq)) :map\n    :else\n    (let [sq2 (-> sq (conj :d1))]\n      (cond\n        (nil? (get sq2 0)) :list\n        :else :vector))))", "user": "5fee18f2e4b05ac5b16ea1d2"}, {"problem": 65, "code": "(fn [coll]\n  (let [coll (-> coll\n                 empty\n                 (conj [1 1])\n                 (conj [2 3])\n                 (conj [2 2]))]\n    (cond (= 2 (count coll))\n          :map\n          (= 3 (count (conj coll [2 2])))\n          :set\n          (= [2 2] (first coll))\n          :list\n          (= [1 1] (first coll))\n          :vector)))", "user": "5c30da5ae4b0d62ef62d9f23"}, {"problem": 65, "code": "(fn [col]\n    (let [test-vals [[1 2] [1 2] [2 3]]\n          moded (apply (partial conj col) test-vals)]\n      (cond\n        (= (take 3 moded) (reverse test-vals)) :list\n        (= (take-last 3 moded) test-vals) :vector\n        (= (moded 1) 2) :map\n        (= ((frequencies moded) [1 2]) 1) :set\n       :else :map\n        )\n     )\n  )", "user": "6004c750e4b074f607df6645"}, {"problem": 65, "code": "(fn inspect-coll [c]\n\n  (letfn [(is-set [c]\n            (if (= (set c) c)\n              true\n              false))\n          (is-map [c]\n  (if (:bloop (conj c [:bloop \"Hi\"]))\n    true\n    false))\n              \n          (is-list-or-vector [c]\n            (let [new-c (conj (conj c 'trogdor 'strong-bad) 'fhqwhagads)]\n              (if (= (first new-c) 'fhqwhagads)\n                :list\n                :vector\n                )))]\n      (if (is-set c)\n        :set\n        (if (is-map c)\n          :map\n        (is-list-or-vector c)))))", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (= coll (conj coll {})) :map\n    (= (into coll [1]) (into coll [1 1])) :set\n    (= 1 (-> coll (conj 1) (conj 2) first)) :vector\n    (= 2 (-> coll (conj 1) (conj 2) first)) :list\n    :else :unknown))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 65, "code": "(fn  [s]\n  (cond\n    ; Adding the same key twice and the size not increasing means map\n    (= (count (conj s {:dummy 1} {:dummy 2})) (count (conj s {:dummy 1}))) :map\n    ; Adding the same value once or twice doesn't matter to a set\n    (= (count (conj s {:dummy 1} {:dummy 1})) (count (conj s {:dummy 1}))) :set\n    ; In vectors the last value added shows as last\n    (= (last (conj s :dummy :dummy2)) :dummy2) :vector\n    :else :list\n  ))", "user": "5edd05bfe4b0c7845d86b0f3"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (= (:a (conj coll [:a 1])) 1) :map\n   (= (count (conj coll :a :a)) (count (conj coll :a))) :set\n   (= (conj coll :a :b) (cons :b (cons :a coll))) :list\n   :else :vector))", "user": "60096aabe4b074f607df667f"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 65, "code": "(fn [x]\n    (letfn [(is-list-or-vec? [x]\n                (let [n (count x)\n                      x' (conj (conj x [1 2]) [1 2])\n                      n' (count x')]\n                    (> n' (inc n))))\n            (is-map? [x]\n                (let [x' (conj x [1 2])]\n                    (= (x' 1) 2)))\n            (is-list? [x]\n                (let [probe (if (= (first x) 1) 2 1)\n                      x' (conj (conj x 100) probe)]\n                    (= (first x') probe)))]\n        (if (is-list-or-vec? x)\n            (if (is-list? x)\n                :list\n                :vector)\n            (if (is-map? x)\n                :map\n                :set))))", "user": "600ae927e4b074f607df6689"}, {"problem": 65, "code": "(fn what-is-it [x]\n    (let [is-map? (fn [ds] (not (nil? (:secret-key (conj ds [:secret-key true])))))\n          is-vector? (fn [ds] (= [:a :a :b] (take 3 (reverse (conj (conj (conj ds :b) :a) :a)))))\n          is-list? (fn [ds] (= [:a :a :b] (take 3 (conj (conj (conj ds :b) :a) :a))))\n          is-set? (fn [ds] (= 1 (count (filter #(= :k %) (conj (conj ds :k) :k)))))]\n\n        (cond (is-map? x)\n                :map\n            (is-vector? x)\n                :vector\n            (is-list? x)\n                :list\n            (is-set? x)\n                :set)))", "user": "5ff93da9e4b06df49cee14af"}, {"problem": 65, "code": "#(case (first (str %))\n   \\[ :vector\n   \\{ :map\n   \\# :set\n      :list)", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 65, "code": "#(cond\n(= (:x (conj % [:x \"x\"])) \"x\") :map\n(= (:x (conj % :x)) :x) :set\n(= (first (conj % :x :y)) :y) :list\n(= (last  (conj % :x :y)) :y) :vector)", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 65, "code": "#(cond\n  (= {} (empty %)) :map\n  (= #{} (empty %)) :set\n  (reversible? %) :vector\n  :else :list)", "user": "5cb41c40e4b026601754b911"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5fec4f5ee4b05ac5b16ea1bf"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 65, "code": "(fn [coll] (let [maap {{} :map\n                 \t   #{} :set}] \n             (or (maap (empty coll)) (if (zero? (last (conj coll 1 0))) :vector :list))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 65, "code": ";; map - conj without changing the size\n;; set - conj w/o changing size, but only for exact dups\n;; vector - conjs to end\n;; list - conjs to beginning\n\n(fn my-type \n  [s]\n  (cond (= (inc (count s)) (count (conj s {:test 1} {:test 2}))) :map\n        (= (inc (count s)) (count (conj s {:test 1} {:test 1}))) :set\n        (= :test (last (conj s :dummy :test))) :vector\n        :else :list))\n\n;; what the heck is happening here?\n;; #({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))\n\n;; this is clever\n;; #(condp = (nth (str %) 0)\n;;   \\{ :map\n;;   \\c :list\n;;   \\[ :vector\n;;   \\# :set)", "user": "5fb68f09e4b08cb800c85b58"}, {"problem": 65, "code": "(fn [s]\n  (let  [elem [:my-key :my-value]\n         s-added (conj s [:dummy :dummy] elem)\n  ]\n  (cond (= :my-value (get s-added :my-key)) :map\n        (= elem (get s-added elem)) :set\n         (= elem (last s-added)) :vector\n         (= elem (first s-added)) :list)\n  )\n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "6022844de4b0d5df2af22203"}, {"problem": 65, "code": "#(case (nth (str %) 0)\n        \\{ :map\n        \\c :list\n        \\[ :vector\n        \\# :set)", "user": "4e38f245535deb9a81d77f3e"}, {"problem": 65, "code": "(fn [b]\n  (let [n (conj b [:c 3])\n        n2 (conj n [:d 4])\n        ]\n    (if (= 3 (:c n)) :map\n      (let [li (concat '([:d 4] [:c 3]) b)\n            ve (concat b '([:c 3] [:d 4]))\n            ]\n    (cond (= n2 li) :list\n          (= n2 ve) :vector\n          :else :set)))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 65, "code": "#({{} :map #{} :set} (empty %) (if (reversible? %) :vector :list))", "user": "601bdcb3e4b0bf4ca6b10930"}, {"problem": 65, "code": "(fn [col]\n  (let [void (empty col)]\n    (cond (= void #{}) :set\n          (= void {}) :map\n          (= (reduce conj void [1 2]) [1 2]) :vector\n          :else :list)))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 65, "code": "(fn [s]\n  (let [res (conj (empty s) [1 2] [1 2] [1 3])]\n    (cond\n      (= 1 (count res)) :map\n      (= 2 (count res)) :set\n      (= [1 2] (first res)) :vector\n      :else :list)))", "user": "60329afce4b0d5df2af222b8"}, {"problem": 65, "code": "(fn [coll]\n  (let [c (count coll)\n        nv [:2 :2]\n        nv2 [:3 :3]\n        n (conj coll nv nv nv2)\n        nc (count n)]\n        \n   (cond\n   \t(:2 n) :map\n    (= (+ c 2) nc) :set \n    (= nv2 (first n)) :list\n    :else :vector)))", "user": "602d5eade4b0d5df2af22279"}, {"problem": 65, "code": "(fn coll-type [coll]\n  (if (associative? coll)\n    (if (coll? (last (assoc coll 0 1)))\n      :map\n      :vector)\n    (if (= (count (conj (conj coll 1) 1)) (count (conj coll 1)))\n      :set\n      :list)))", "user": "5fada7cce4b08cb800c85af5"}, {"problem": 65, "code": "(fn get-type [instance] \n  (let [empty-instance (empty instance)] (cond \n   (= {} empty-instance) :map \n   (= #{} empty-instance) :set\n   (= '() empty-instance) (let [vct [1 2] lst [2 1]] (if (= (conj empty-instance 1 2) vct) :vector :list))\n   )))", "user": "6031926ae4b0d5df2af222ac"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "5fd361f2e4b07e53c2f3f04e"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "603961e3e4b0d5df2af222f3"}, {"problem": 65, "code": "(fn [s]\n  (let [base (empty s)]\n    (cond\n      (= base {}) :map\n      (reversible? base) :vector\n      (= base ()) :list\n      (= base #{}) :set)))", "user": "602ddebde4b0d5df2af2227d"}, {"problem": 65, "code": "(fn foo [arg]\n        (let [target (str arg)\n              ]\n          (cond (= (first target) \\#) :set\n                (= (first target) \\{ ) :map\n                (= (first target) \\[) :vector\n                :else :list\n        )))", "user": "6038b6b4e4b0d5df2af222ef"}, {"problem": 65, "code": "(fn [coll]\n  (letfn [(is-map? [coll]\n            (= :x (get (conj coll [:x :x]) :x)))\n          (is-list? [coll]\n            (let [coll (conj coll 1)]\n              (= coll (rest (conj coll :x)))))\n          (is-vector? [coll]\n            (let [coll (conj coll 1)]\n              (= coll (butlast (conj coll :x)))))]\n    (cond\n      (is-map? coll) :map\n      (is-list? coll) :list\n      (is-vector? coll) :vector\n      :else :set)))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n   (not (nil? (get (conj coll [:c 1]) :c ))) :map\n   (= (count (conj coll 1)) (count (conj coll 1 1))) :set\n   (= (first (conj coll 100 101)) 101) :list\n   :else :vector))", "user": "5f5b624de4b05ea7b9adc42f"}, {"problem": 65, "code": "(fn [x]\n  \n  \n  (cond\n\n\n   ; set: 2 copies of 2 redundant things add 2 items\n   (= (count (conj x [:X :Y] [:X :Z] [:X :Y] [:X :Z])) (+ 2 (count x))) :set\n   \n   ; map: this adds just 1 item\n   (= (count (conj x [:X :Y] [:X :Z] [:X :Y] [:X :Z])) (inc (count x))) :map\n   \n   ; list: conj adds to start\n   (= (first (conj x :X :Y)) :Y) :list\n   \n   :else :vector\n   \n   \n   ))", "user": "6045582fe4b02d28681c77b6"}, {"problem": 65, "code": "(fn q [c]\n    (cond\n      (and (associative? c) (not (reversible? c)) (ifn? c)) :map\n      (and (not (associative? c)) (not (reversible? c)) (ifn? c)) :set\n      (and (not (associative? c)) (not (reversible? c)) (not (ifn? c))) :list\n      (and (associative? c) (reversible? c) (ifn? c)) :vector\n      :else :1))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 65, "code": "(fn f [x]\n  (let [y (conj (conj (conj (conj x [1 1]) [2 2]) [1 1]) [2 2])]\n    (if (= (+ (count x) 4) (count y))\n      (if (= (first y) [2 2]) :list :vector)\n      (if (contains? y [1 1]) :set :map))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 65, "code": "(fn [x]\n  (let [t (conj (empty x) [:a :b] [:c :d])]\n    (cond\n      (:a t) :map\n      (get t 0) :vector\n      (get t [:a :b]) :set\n      :else :list)))", "user": "60471241e4b02d28681c77c9"}, {"problem": 65, "code": "(fn [s]\n  (let [-map? (fn [s] (let [key (keyword (gensym \"foo\"))\n                            val1 (gensym \"bar\")\n                            val2 (gensym \"baz\")\n                            ss (merge s [key val1])]\n                        (= (inc (count s)) (count (merge ss [key val2])))))\n        -set? (fn [s] (let [el (gensym \"foo\")] (= (inc (count s)) (count (conj s el el)))))\n        -list? (fn [s] (let [el1 (gensym \"foo\") el2 (gensym \"bar\")] (and (not= :set (-set? s)) (= (first (conj s el1 el2)) el2))))\n        -vector? (fn [s] (let [el1 (gensym \"foo\") el2 (gensym \"bar\")] (and (not= :set (-set? s)) (= (last (conj s el1 el2)) el2))))]\n    (try\n      (cond\n        (-map? s) :map\n        (-set? s) :set\n        (-vector? s) :vector\n        (-list? s) :list\n        :else :unknown))))", "user": "5dcd7933e4b0b296f82db5ae"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "4e586949535d8a8b8723a292"}, {"problem": 65, "code": "(let [is-vector?\n      (fn [sequence]\n        (= :bar (last (conj (conj sequence :foo) :bar))))\n      is-map?\n      (fn [sequence]\n        (= (count (conj sequence [:foo :bar] [:foo :baz]))\n           (inc (count sequence))))\n      is-set?\n      (fn [sequence]\n        (= #{} (empty sequence)))\n      sequence-type\n      (fn [sequence]\n        (cond\n          (is-set? sequence) :set\n          (is-map? sequence) :map\n          (is-vector? sequence) :vector\n          :else :list))]\n  sequence-type)", "user": "5db012e3e4b0f8c104ccfc95"}, {"problem": 65, "code": ";#(let [is? (partial identical? (empty %))]\n;   (cond\n;    (is? {}) :map\n;   \t(is? ()) :list\n;   \t(is? []) :vector\n;   \t(is? #{}) :set\n;   :else :unknown))\n\n(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 65, "code": "(fn black-box-testing [xs]\n  (let [x (gensym)\n        xs (conj xs [x x])]\n    (if (= (count (into xs xs))\n           (count xs))\n      ;; xs is either a map or a set\n      (if (contains? (conj xs [x x]) [x x])\n        :set\n        :map)\n      ;; xs is either a list or a vector\n      (if (= (first (conj xs x)) x)\n        :list\n        :vector))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 65, "code": "(fn [v] \n    (if (= {} (empty v))\n      :map\n      (if (= #{} (empty v))\n        :set\n        (if (= (take-last 2 (conj (conj v :a) :b)) [:a :b])\n          :vector\n          :list\n        )\n      )\n    )\n  )", "user": "5e2586afe4b05b4b01516167"}, {"problem": 65, "code": "(fn __ [x]\n  (if (reversible? x)\n    :vector\n    (if (associative? x)\n      :map\n      (let [y (conj (conj (empty x) 1) 2)]\n        (if (= 1 (first y))\n          :set\n          :list)))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 65, "code": "(fn [coll]\n   (cond\n     (= :2 (get (conj coll [:1 :2]) :1)) :map\n     (= [3 4] (get (conj coll [3 4]) [3 4])) :set\n     (= 6 (first (conj coll 5 6))) :list\n     (= 7 (last (conj coll 6 7))) :vector))", "user": "5d5c2730e4b09db18d4482ea"}, {"problem": 65, "code": "(fn bbt [col]\n  (let [e1 [(keyword (gensym)) 1] e2 [(keyword (gensym)) 1] \n        res (conj col e1 e2 e2)]\n    (cond \n      (= (count res) (+ 2 (count col))) (if (associative? col) :map :set)\n      (= e2 (first res)) :list\n      (= e2 (last res)) :vector\n      :else :unknown)))", "user": "60606490e4b03746e80ebf67"}, {"problem": 65, "code": "#(condp = (empty %)\n    #{} :set\n    '() (if (reversible? %) :vector :list)\n    {} :map)", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 65, "code": "(fn t [coll]\n  (let [coll-2 (conj coll {1 2})\n        count-2 (count coll-2)\n        coll-3 (conj coll-2 {1 2})\n        count-3 (count coll-3)]\n    (if (= count-2 count-3)\n      ;; set or map   \n      (if (= 2 (get coll-2 1))\n        :map\n        :set)\n      ;; vector or list\n      (if (= (first coll-3) (last coll-3) {1 2})\n        (let [coll-4 (conj coll-3 0)]\n          (if (= 0 (first coll-4))\n            :list :vector))\n        (if (= {1 2} (first coll-3))\n          :list :vector)))))", "user": "54be7c0de4b0ed20f4ff6eec"}, {"problem": 65, "code": "(fn foo [c]\r\n  (if\r\n    (= :test (get (conj c [:test :test]) :test)) :map\r\n    (let [x (into c [1])]\r\n      (cond\r\n        (= x (conj x (first x))) :set\r\n        (= :test (first (conj x :test))) :list\r\n        :else :vector))))", "user": "606e0a42e4b069485764de19"}, {"problem": 65, "code": "(fn [x]\n  (cond (= (:z (conj x [:z 9])) 9) :map\n        (= (count (conj x 9)) (count (conj (conj x 9) 9))) :set\n        (= (first (conj (conj x 8) 9)) 9) :list\n        (= (last (conj (conj x 8) 9)) 9) :vector))", "user": "606d7f1ce4b069485764de14"}, {"problem": 65, "code": "(fn [x]\n  (get {{} :map #{} :set} (empty x) (if (reversible? x) :vector :list)))", "user": "5fc1c424e4b0edf42a5593d0"}, {"problem": 65, "code": "(fn [o]\n    (let [v1 (gensym) v2 (gensym)] \n      (let [o* (conj o [v1 v1] [v1 v1] [v2 v2])]\n        (cond\n          (= (+ 2 (count o)) (count o*))\n            (if (contains? o* v1) :map :set)\n          (= (first o*) [v2 v2]) :list\n          (= (last o*) [v2 v2]) :vector))))", "user": "6026d2cae4b0d5df2af22232"}, {"problem": 65, "code": "(fn black-box-testing\n  [coll]\n  (cond\n    (= (first (str coll)) \\{) :map\n    (= (first (str coll)) \\#) :set\n    (= (first (str coll)) \\[) :vector\n    :else :list))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 65, "code": "(fn [s] (let [d (map #(vector % :d) (range 5 33))            \n              s (into s d)]                               \n          (cond                                  \n            (= (reverse d) (take 28 s)) :list \n            (= d (drop (- (count s) 28) s)) :vector\n            (= :d (get s 5)) :map  \n            :default :set)))", "user": "51435753e4b0c172af7558d5"}, {"problem": 65, "code": "#(let [t (empty %)]\n    (cond      \n      (reversible? t) :vector\n      (= t '()) :list\n      (= t {}) :map\n      (= t #{}) :set\n      )    \n    )", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 65, "code": "(fn bbt [input]\n    (let [coll (into input [[:a 1]])]\n        (cond\n            (= (count coll) (count (conj coll coll))) :map\n            (= (cons coll coll) (conj coll coll)) :list\n            (= (into coll (concat coll coll)) coll) :set\n            :else :vector)))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 65, "code": "(fn solve [x]\n  (let [y (gensym) z (gensym)]\n    (if (associative? x)\n      (if (= (count (conj x [y z]))\n             (count (conj x [y z] [y z])))\n        :map\n        :vector)\n      (if (= (count (conj x y))\n             (count (conj x y y)))\n        :set\n        :list))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 65, "code": "(fn black-box [s]\n  (let [result (conj (empty s) [1 2] [1 2] [1 3])]\n    (cond\n      (= 1 (count result)) :map\n      (= 2 (count result)) :set\n      (= [1 2] (first result)) :vector\n      :else :list)))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 65, "code": "(fn [coll]\n  (let [m {\"{\" :map \"#\" :set \"[\" :vector }\n        c (-> coll str first str)]\n    (get m c :list)))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 65, "code": "(fn  [s] (cond\n        (=  \\# (first (str s))) :set\n        (=  \\[  (first (str s))) :vector\n        (=  \\( (first (str s))) :list\n        (=  \\{ (first (str s))) :map\n            :else :list\n     )\n  )", "user": "6076adb2e4b069485764de60"}, {"problem": 65, "code": "(fn black-box [seq]\n  (cond\n    (= (get (conj seq [:x \"x\"]) :x) \"x\") :map\n    (= (get (conj seq :x) :x) :x) :set\n    (= (first (conj (conj seq :x) :y)) :y) :list\n    (= (last (conj (conj seq :x) :y)) :y) :vector))", "user": "60849bd6e4b0736b099e42f2"}, {"problem": 65, "code": ";; another approach is to use (empty coll) and compare (=) to {}, #{} and (), and list/vector is distinguished by reversible?\n;; or we could look at the first character of (str coll)\n;(fn [coll]\n;  (let [to-conj-1 [0 0] ;; pairs so that we can conj to a map\n;        to-conj-2 [1 1]] ;; two items, as otherwise an empty list and empty vector would look the same\n;    (cond\n;      (= (conj coll to-conj-1 to-conj-2) (concat coll [to-conj-1 to-conj-2])) :vector\n;      (= (conj coll to-conj-1 to-conj-2) (concat [to-conj-2 to-conj-1] coll)) :list\n;      (= (last to-conj-1) ((conj coll to-conj-1) (first to-conj-1))) :map\n;      (< (count (conj coll to-conj-1 to-conj-1)) (+ 2 (count coll))) :set))) ;; this would be true for a map too\n;(fn [coll]\n;  (cond\n;    (reversible? coll) :vector ;; only vectors are reversible\n;    (associative? coll) :map ;; only vectors and maps are associatve\n;    (ifn? coll) :set ;; all except lists implement IFn\n;    :else :list))\n;; https://porkostomus.gitlab.io/posts-output/2018-09-01-Just-Juxt-18/\n(fn [c]\n  (case ((juxt associative? reversible? ifn?) c)\n    [true  true  true ] :vector\n    [false false false] :list\n    [true  false true ] :map\n    [false false true ] :set))", "user": "60794173e4b0a637ed78035d"}, {"problem": 65, "code": "(fn [coll]\n  (if (empty? coll)\n    (if (= {} coll) :map\n      (if (= #{} coll) :set\n        (let [lst-or-vec (-> coll\n                             (conj 1)\n                             (conj 2))]\n          (if (= [1 2] lst-or-vec)\n            :vector\n            :list\n            ))))\n    (let [fst (first coll) ; populated sequences require more probing\n          coll-conj (conj coll fst)\n          count-before (count coll)\n          count-after (count coll-conj)]\n      (if (> count-after count-before) ; coll is either a list or a vec\n        (if (= fst (last coll-conj))\n          :vector  ; since (conj [1 2] 1) => [1 2 1]\n          :list ; since (conj '(1 2) 1) => (1 1 2)\n          )\n        (if (nil? (coll fst)) ; otherwise coll is a map or a set\n          :map\n          :set)))))", "user": "605f5c69e4b03746e80ebf5e"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "6081b7fce4b0736b099e42d4"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "6088395de4b0ae75613dcee2"}, {"problem": 65, "code": "(fn [xs]\n  (cond\n   (= (conj xs {}) xs) :map ; conj empty map with map does nothing (so *could* a set containing {})\n   (= (conj xs :xyz) (conj (conj xs :xyz) :xyz)) :set ; no change when conj an elem twice\n   (and\n    (= :a (first (conj xs :a)))\n    (= :b (first (conj xs :a :b)))) :list ; verify adds to the front\n   (and\n    (= :a (last (conj xs :a)))\n    (= :b (last (conj xs :a :b)))) :vector)) ; verify adds to the backl", "user": "5b4b8cd6e4b02d533a91bc9f"}, {"problem": 65, "code": "(fn black-box-testing\n  [coll]\n  (let [init-count (count coll)]\n    (let [coll* (conj coll [:1 :2] [:1 :2] [:3 :4])]\n      (cond\n        (= :2 (get coll* :1)) :map\n        (= 2 (- (count coll*) init-count)) :set\n        (= [:3 :4] (first coll*)) :list\n        :else :vector))))", "user": "6098263be4b00e9e6653c3f9"}, {"problem": 65, "code": "(fn type* [col]\n  (let [\n         vector?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= (take-last 2 (conj (conj col k) v)) (vector k v))))\n         set?* (fn [col](let[k (+ 9999 (rand-int 1000))](= (conj (conj col k) k) (conj col k))))\n         map?* (fn [col](let[k (+ 9999 (rand-int 1000)) v (+ 9999 (rand-int 1000))](= v (get (conj col (vector k v)) k))))\n         ]\n    (cond\n      (map?* col) :map\n      (set?* col) :set\n      (vector?* col) :vector\n      :else :list )))", "user": "6092bfefe4b00e9e6653c3db"}, {"problem": 65, "code": "(fn [coll]\n  (let [base (empty coll)]\n    (cond \n     (= base {}) :map\n     (= base #{}) :set\n     (reversible? base) :vector\n     :else :list)))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 65, "code": "(fn spotbox [c]\n   (let [ec (empty c), pluszs (conj (conj ec {:z 4}) {:z 4})]\n     (if (= 4 (:z pluszs))\n       :map\n       (if (= 1 (count pluszs))\n         :set\n         (if (= :blah (first (conj pluszs :blah)))\n           :list\n           :vector)))))", "user": "60882700e4b0ae75613dcedf"}, {"problem": 65, "code": "(fn [coll]\n  (cond\n    (and (not (reversible? coll)) (associative? coll) (ifn? coll)) :map\n    (and (reversible? coll) (associative? coll) (ifn? coll)) :vector \n    (and (not (reversible? coll)) (not (associative? coll))  (ifn? coll)) :set\n    (and (not (reversible? coll)) (not (associative? coll)) (not (ifn? coll))) :list))", "user": "5ff19fe0e4b05ac5b16ea1f4"}, {"problem": 65, "code": "(fn seq-type [coll]\n  (let [base (empty coll)]\n    (cond\n      (= base {})        :map\n      (= base #{})       :set\n      (reversible? base) :vector\n      (= base ())        :list)))", "user": "60a9f193e4b00e9e6653c476"}, {"problem": 65, "code": "#(let [cnt (count %) \n        aftr (if (associative? %)\n               (reverse (apply conj '() {:asoc \"asoc\"} {:asoc \"asoc\"}))\n               (reverse (conj '() \"test\" \"test\")))\n        tst (reduce conj % aftr)]\n      (cond \n        (= (get tst :asoc) \"asoc\") :map\n        (= (count tst) (+ 1 cnt)) :set \n        (= (last tst) [:asoc \"asoc\"]) :vector \n        (= (first tst) \"test\") :list \n        :else :not-found))", "user": "608e5697e4b03bd49d9f36be"}, {"problem": 65, "code": "(fn [col]\n  (cond \n    (= (count (merge col col)) (count col)) :map\n    (= (count (conj col :a)) (count (conj (conj col :a) :a))) :set\n    (= :hrudey (first (conj (conj col :bieksa) :hrudey))) :list\n    :else :vector))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 65, "code": "(fn test [coll]\n   (case (conj (empty coll) [1 2] [1 3] [1 4] [1 2])\n     [[1 2] [1 3] [1 4] [1 2]] :vector\n     [[1 2] [1 4] [1 3] [1 2]] :list\n     {1 2} :map\n     #{[1 2] [1 4] [1 3]} :set))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 65, "code": "(fn [sq]\n  (if (= (inc (count sq)) (count (conj sq [:__XX__ :__YY__] [:__XX__ :__YY__])))\n    ;; map or set\n    (let [tagged (conj sq [:__XX__ :__YY__])]\n      (if (= :__YY__ (get tagged :__XX__))\n        :map\n        :set))\n    ;; list or vector\n    (let [tagged (conj (conj sq :__YY__) :__XX__)]\n      (if (= :__XX__ (first tagged))\n        :list\n        :vector))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 65, "code": "(fn [x] (cond\n            (= {} (empty x)) :map\n            (= #{} (empty x)) :set\n            (= :a (first (into (empty x) '(:a :b)))) :vector\n            :else :list))", "user": "60c0ceb7e4b0e0fa5f1b42a6"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj (conj c :a) :b)) :b) :vector))", "user": "6093b56ce4b00e9e6653c3e0"}, {"problem": 65, "code": "(fn [coll]\n  (let [sample (empty coll)]\n    (cond\n      (= {} sample) :map\n      (= #{} sample) :set\n      (= (conj sample 1 2) [1 2]) :vector\n      :else :list)))", "user": "4fe49706e4b0e8f79898feb7"}, {"problem": 65, "code": "(fn [x]\n   (if (empty? x)\n     (condp = x\n       {} :map\n       #{} :set\n       (if (reversible? x) :vector :list))\n     (if (not= (count x) (count (flatten (for [a x] a)))) :map\n         (if (= :a (first (conj x :a))) :list\n             (if (= :a (last (conj x :a))) :vector :set)))))", "user": "60b3b375e4b0e0fa5f1b4232"}, {"problem": 65, "code": "(fn [col]\n    (let [x (gensym)\n          y (gensym)\n          z (gensym)\n          col (conj col {z y} {x y} {x y})]\n      (cond\n        (= y (get col x)) :map\n        (= {x y} (get col {x y})) :set\n        (= {x y} (first col)) :list\n        (= {x y} (last col)) :vector))\n    )", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 65, "code": "(fn wtf\n  [wo]\n  (let [w (empty wo)]\n    (if (:a (conj w [:a 1]))\n      :map\n      (let [n (conj w 0 0 1 1)]\n        (cond\n          (= n #{0 1}) :set\n          (= (first n) 1) :list\n          (= (first n) 0) :vector)))))", "user": "5fd92743e4b05ac5b16ea11f"}, {"problem": 65, "code": "(fn [c]\n  (cond\n    (= (get (conj c [:t \"t\"]) :t) \"t\") :map\n    (= (get (conj c :t) :t) :t) :set\n    (= (first (conj (conj c :a) :b)) :b) :list\n    (= (last (conj c :b)) :b) :vector))", "user": "608c270ae4b03bd49d9f36b3"}, {"problem": 65, "code": "(fn [s]\n   (cond\n     (= (conj s {}) s) :map\n     (empty? s) (cond\n                  (= (clojure.set/union s #{}) #{}) :set\n                  (= (conj (conj s 0) 1) [0 1]) :vector\n                  (= (conj (conj s 0) 1) [1 0]) :list)\n     (= (clojure.set/union s s) s) :set\n     (= (last (conj s s)) s) :vector\n     (= (first (conj s s)) s) :list\n     ))", "user": "5fa80c01e4b0fa27300f3de2"}, {"problem": 65, "code": "(fn coll-type[coll]\n  (cond\n    (= (get (conj coll [:x :y]) :x) :y) :map\n    (= (count (conj coll :x)) (count (conj (conj coll :x) :x))) :set\n    (= (first (conj (conj coll :x) :y)) :y) :list\n    (= (last (conj (conj coll :x) :y)) :y) :vector\n    :else :dunno))", "user": "60c91f48e4b0e0fa5f1b4304"}, {"problem": 65, "code": "(fn [c]\n   (if (associative? c)\n     (if (reversible? c)\n       :vector\n       :map)\n     (if (<= 3 (count (conj c 10 1 1 1)))\n       :list\n       :set\n       )\n     ))", "user": "60ddf3ede4b022ea5d8e4522"}]