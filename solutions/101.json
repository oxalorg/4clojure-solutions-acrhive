[{"code": "(fn [x y] \n  (with-local-vars \n    [e (memoize \n         (fn [x y]\n           (cond\n             (empty? x) (count y)\n             (empty? y) (count x)\n             :else (min\n\t                   (+ (if (= (first x) (first y)) 0 1)\n\t\t                        (e (rest x) (rest y)))\n\t\t                    (inc (e (rest x) y))\n\t\t                    (inc (e x (rest y)))))))]\n      (e x y)))", "problem": 101, "user": "4da3e51330acd6ed10482a68"}, {"code": "(fn ed [a b] \r\n            (cond \r\n              (not (or a b)) 0 \r\n              (not b) (count a) \r\n              (not a) (count b) \r\n              :else (let [ra (next a) rb (next b)] \r\n                      (if (= (first a) (first b)) \r\n                        (ed ra rb) \r\n                        (+ 1 (min \r\n                               (ed ra rb) \r\n                               (ed ra b) \r\n                               (ed a rb)))))))", "problem": 101, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn [s1 s2]\r\n  (letfn [(c [x y] (if (= (nth s1 (dec x)) (nth s2 (dec y))) 0 1))]\r\n    (with-local-vars\r\n        [l (memoize\r\n            (fn [x y] (cond (< x 1) y\r\n                           (< y 1) x\r\n                           :else\r\n                           (let [mx (dec x) my (dec y)]\r\n                             (min (+ 1 (l mx y))\r\n                                  (+ 1 (l x my))\r\n                                  (+ (c x y) (l mx my)))))))]\r\n      (l (count s1) (count s2)))))", "problem": 101, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn levenshtein [s t]\r\n   (let [x (count s)\r\n         y (count t)\r\n         L (fn [L x y]\r\n             (cond (zero? x) y\r\n                   (zero? y) x\r\n                   (= (nth s (dec x)) (nth t (dec y))) (L L (dec x) (dec y))\r\n                   :else (inc (min (L L (dec x) (dec y))\r\n                                   (L L (dec x) y)\r\n                                   (L L x (dec y))))))\r\n         L (partial L (memoize L))]\r\n     (L x y)))", "problem": 101, "user": "4dc7e8c6535d8a4b2fd74291"}, {"code": "(fn [n f r c x y]\r\n  (last\r\n   (f #(f (fn [c i]\r\n      (conj c (+ 1 (min (n % (+ i 1)) (n c i)\r\n\t\t\t      (- (n % i) ({(n x i) 1} (n y %2) 0))))))\r\n\t  [(+ %2 1)] (r (c x)))\r\n      (r (+ 1 (c x)))\r\n      (r (c y)))))\r\nnth reduce range count", "problem": 101, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn lev [s1 s2]\r\n  (peek\r\n   (reduce\r\n    (fn [prev c1]\r\n      (reduce\r\n       (fn [row [nw n c2]]\r\n         (conj row (if (= c1 c2) nw (inc (min nw n (peek row))))))\r\n       [(inc (first prev))]\r\n       (map vector prev (next prev) s2)))\r\n    (vec (range (inc (count s2))))\r\n    s1)))", "problem": 101, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn\r\n  [x y]\r\n  (let [s (seq x)\r\n        t (seq y)\r\n        n (count s)\r\n        m (count t)\r\n        dp (to-array-2d\r\n            (for [i (range (inc n))]\r\n             (for [j (range (inc m))]\r\n               (cond\r\n                (= i 0) j\r\n                (= j 0) i\r\n                true 0))))]\r\n    (doseq [i (range 1 (inc n)) j (range 1 (inc m))]\r\n      (aset dp i j\r\n            (min\r\n             (+ (if (= (nth s (dec i)) (nth t (dec j))) 0 1)\r\n                (aget dp (dec i) (dec j)))\r\n             (+ 1 (aget dp (dec i) j))\r\n             (+ 1 (aget dp i (dec j))))))\r\n    (aget dp n m)))", "problem": 101, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn lev-distance [lst mst]\r\n  (letfn [(strlist[lst]\r\n  \t  (if (string? lst)  (re-seq #\".\" lst)   lst  ))\r\n\t  (loopwalk1 [lst mst]\r\n\t\t    (loop [ls lst ms mst c 0]\r\n\t\t      (cond  (or (nil? (first ls))(nil? (first ms))) (+ c (count ls) (count ms))\r\n\t\t\t     (= (first ls) (first ms)) (recur (rest ls) (rest ms) c)\r\n\t\t\t     :else (recur (rest ls) ms (+ c 1)))))\r\n\t  (loopwalk2 [lst mst]\r\n\t\t     (loop [ls lst ms mst c 0]\r\n\t\t       (if (or (nil? (first ls))\r\n\t\t\t       (nil? (first ms)))\r\n\t\t\t (+ c (count ms) (count ls))\r\n\t\t\t (if (= (first ms) (first ls))\r\n\t\t\t   (recur (rest ls) (rest ms) c)\r\n\t\t\t   (recur (rest ls) (rest ms) (+ c 1))))))\r\n\t\t\t\t \r\n\t  ]\r\n  (let [ls (strlist lst)\r\n\tms (strlist mst)]\r\n    (cond (= ls ms) 0\r\n\t  (zero? (count ls)) (count ms)\r\n\t  (zero? (count ms)) (count ls)\r\n\t  :else (min\r\n\t\t (loopwalk1 ls ms)\r\n\t\t (loopwalk1 ms ls)\r\n\t\t (loopwalk2 ls ms)\r\n\t\t (loopwalk2 ms ls))))))", "problem": 101, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn [s1 s2]\r\n  (letfn [(ld2 [i1 l]\r\n            (letfn [(ld1 [i2 r]\r\n                      (if (>= i2 (count s2)) r\r\n                          (recur (inc i2)\r\n                                 (conj r (min (inc (last r))\r\n                                              (inc (nth l (inc i2)))\r\n                                              (+ (nth l i2) (if (= (nth s1 i1) (nth s2 i2)) 0 1)))))))]\r\n              (if (>= i1 (count s1)) l\r\n                  (recur (inc i1) (ld1 0 [(inc i1)])))))]\r\n    (last (ld2 0 (range (inc (count s2)))))))", "problem": 101, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn levenshtein [s t]\r\n  (last\r\n    (let [s-length (count s)\r\n          t-length (count t)]\r\n      (reduce\r\n        (fn [distance j]\r\n          (reduce\r\n            (fn [new-distance i]\r\n              (conj new-distance\r\n                    (if (= (nth s (dec i)) (nth t (dec j)))\r\n                      (nth distance (dec i))\r\n                      (inc (min\r\n                            (nth new-distance (dec i)) ; a deletion\r\n                            (nth distance i) ; an insertion\r\n                            (nth distance (dec i))))))) ; a substitution\r\n            [j]\r\n            (range 1 (inc s-length))))\r\n        (range (inc s-length))\r\n        (range 1 (inc t-length))))))", "problem": 101, "user": "4dab218f30acd6ed15482a68"}, {"code": "(fn [s t]\r\n  (let [m (count s), n (count t),\r\n        d (make-array Integer/TYPE (inc m) (inc n))]\r\n    (doseq [i (range 0 (inc m))]\r\n      (aset d i 0 i))\r\n    (doseq [j (range 0 (inc n))]\r\n      (aset d 0 j j))\r\n    (doseq [j (range 1 (inc n))\r\n            i (range 1 (inc m))]\r\n      (if (= (nth s (dec i)) (nth t (dec j)))\r\n        (aset d i j (aget d (dec i) (dec j)))\r\n        (let [mn (inc (min (aget d (dec i) j)\r\n                           (aget d i (dec j))\r\n                           (aget d (dec i) (dec j))))]\r\n          (aset d i j mn))))\r\n    (aget d m n)))", "problem": 101, "user": "4dd4034a535dae65d5c462df"}, {"code": "(fn [x y]\r\n (letfn [\r\n           (nextrow [[a b & more :as lastrow]\r\n                     letter\r\n                     [w & word]\r\n                     acc]\r\n                    (if b\r\n                      (let [nextint (if (= letter w)\r\n                                      a\r\n                                      (+ 1 (min a b (first acc))))]\r\n                        (recur (rest lastrow)\r\n                               letter\r\n                               word\r\n                               (cons nextint acc)))\r\n                      (reverse acc)))\r\n           (leven ([source target] (leven source target 1\r\n                                          (range (inc (count target)))))\r\n                  ([[sletter & source] target n lastrow]\r\n                   (if sletter\r\n                     (let [thisrow (nextrow lastrow sletter target [n])]\r\n                       (recur source target (inc n) thisrow))\r\n                     (last lastrow))))\r\n         ]\r\n   (leven x y)))", "problem": 101, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [s t]\r\n   (let [leven (fn [s t]\r\n                 (last (loop [jrow (vec (range (count s)))\r\n                              j 1]\r\n                   \r\n                         (if (<= j (count t))\r\n\r\n                           (let [jrow (loop [row [j]\r\n                                             i 1]\r\n                                  \r\n                                        (if (<= i (count s))\r\n                                    \r\n                                          (if (= (get s (dec i))\r\n                                                 (get t (dec j)))\r\n                                            (recur (conj row (get jrow (dec i))) (inc i))\r\n                                            (recur (conj row (inc (min\r\n                                                                   (get row (dec i) 100)\r\n                                                                   (get jrow i 100)\r\n                                                                   (get jrow (dec i) 100)))) (inc i)))\r\n                                          row))]\r\n                             (recur jrow (inc j)))\r\n                         \r\n                           jrow)))\r\n                    \r\n     \r\n                 )]\r\n     (let [res (leven s t)]\r\n       (if res\r\n         res\r\n         0))))", "problem": 101, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn [s1 s2]\r\n  (letfn [(ld2 [i1 l]\r\n            (letfn [(ld1 [i2 r]\r\n                      (if (>= i2 (count s2)) r\r\n                          (recur (inc i2)\r\n                                 (conj r (min (inc (last r))\r\n                                              (inc (nth l (inc i2)))\r\n                                              (+ (nth l i2) (if (= (nth s1 i1) (nth s2 i2)) 0 1)))))))]\r\n              (if (>= i1 (count s1)) l\r\n                  (recur (inc i1) (ld1 0 [(inc i1)])))))]\r\n    (last (ld2 0 (range (inc (count s2)))))))", "problem": 101, "user": "4e1158aa535d04ed9115e7c6"}, {"code": ";Smith-Waterman. Can't get memoize to work in this env!\r\n(fn [x1 x2]\r\n  (let [match (fn[x y] (if (= (nth x1 x) (nth x2 y)) 1 0))\r\n        ld    (fn ld [x y c]\r\n          (cond \r\n           (c [x y]) [(c [x y]) c]\r\n           (< x 0) [(- y x) (assoc c [x y] (- y x))]\r\n           (< y 0) [(- x y) (assoc c [x y] (- x y))]\r\n           :else \r\n             (let [[d1 c1] (ld (dec x) (dec y) c)\r\n                   [d2 c2] (ld (dec x)      y  c1) \r\n                   [d3 c3] (ld      x  (dec y) c2)\r\n                   c c3\r\n                   v (inc (min (- d1 (match x y)) d2 d3))]\r\n             [ v (assoc c [x y] v )])))]\r\n   (first (ld (dec (count x1)) (dec (count x2)) {}))))", "problem": 101, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn lev [x y]\n  (get\n   (loop [h {}\n    a 0\n\t  b 0]\n     (cond\n      (> b (count y)) (recur h (inc a) 0)\n      (> a (count x)) h\n      (= a 0) (recur (assoc h [a b] b) a (inc b))\n      (= b 0) (recur (assoc h [a b] a) a (inc b))\n      (= (get x (dec a)) (get y (dec b)))\n      (recur (assoc h [a b] (min\n\t\t\t     (get h [(dec a) (dec b)])\n\t\t\t     (inc (get h [(dec a) b]))\n\t\t\t     (inc (get h [a (dec b)]))\n\t\t\t     ))\n\t     a (inc b))\n      true\n      (recur (assoc h [a b] (min\n\t\t\t     (inc (get h [(dec a) (dec b)]))\n\t\t\t     (inc (get h [(dec a) b]))\n\t\t\t     (inc (get h [a (dec b)]))\n\t\t\t     ))\n\t     a (inc b)))\n     )\n   [(count x) (count y)]\n   ))", "problem": 101, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn levenshtein\n  ([x y]\n    (levenshtein x y 0))\n  ([x y so-far]\n    (println x (count x) y (count y) so-far)\n    (if (= 0 (count x) (count y))\n    so-far (if (= 0 (count x))\n      (+ so-far (count y)) (if (= 0 (count y))\n        (+ so-far (count x)) (if (= (first x) (first y))\n          (recur (rest x) (rest y) so-far) (if (= (second x) (second y))\n            (recur (rest (rest x)) (rest (rest y)) (inc so-far)) (if (= (first x) (second y))\n              (recur (rest x) (rest (rest y)) (inc so-far)) (if (= (second x) (first y))\n                (recur (rest (rest x)) (rest y) (inc so-far)) (if (= (last x) (last y))\n                  (recur (butlast x) (butlast y) so-far) \n                  ;(if (= (last x) (last (butlast y)))\n                   ; (recur (butlast x) (butlast (butlast y)) (inc so-far)) (if (= (last y) (last (butlast x)))\n                    ;  (recur (butlast (butlast x)) (butlast y) (inc so-far)) \n                    (recur (butlast x) (butlast y) (inc so-far))))))))))))", "problem": 101, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [a b]\n  (letfn [(make-lev [] \n                    (with-local-vars\n                      [lev (memoize\n                             (fn [a b]\n                               (if (empty? a) (count b)\n                                 (if (empty? b) (count a)\n                                   (min (+ (lev (rest a) (rest b)) (if (= (first a) (first b)) 0 1))\n                                        (+ (lev (rest a) b) 1)\n                                        (+ (lev a (rest b)) 1))))))]\n                      (.bindRoot lev @lev)\n                      @lev))]\n    (let [lev (make-lev)]\n      (lev a b))))", "problem": 101, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn [x y]\n  (let [r range\n        o assoc\n        l (+ 1 (count x))\n        m (+ 1 (count y))\n        t (atom (reduce #(o % [0 %2] %2)\n                        (reduce #(o % [%2 0] %2) {} (r l))\n                        (r m)))]\n    (doseq [a (r 1 l), b (r 1 m)]\n        (reset! t (o @t [a b]\n                          (min \n                            (+ 1 (@t [(- a 1) b]))\n                            (+ 1 (@t [a (- b 1)]))\n                            (+ (if (= (nth x (- a 1)) (nth y (- b 1))) 0 1)\n                               (@t [(- a 1) (- b 1)]))))))\n    (@t [(- l 1) (- m 1)])))", "problem": 101, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn levenstein-recursive [w1 w2]\r\n  (with-local-vars\r\n      [d (memoize\r\n    (fn [i j]\r\n\t    (cond (zero? j) i\r\n\t\t  (zero? i) j\r\n\t\t  (= (nth w1 (dec i)) (nth w2 (dec j))) (d (dec i) (dec j))\r\n\t\t  :else (inc (min (d (dec i) j)\r\n\t\t\t\t  (d i (dec j))\r\n\t\t\t\t  (d (dec i) (dec j)))))))]\r\n    (d (count w1) (count w2))))", "problem": 101, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [a b]\n  (let [c (count a)\n        d (count b)\n        m (atom (vec\n                 (for [i (range (+ c 1))]\n                   (vec\n                    (for [j (range (+ d 1))]\n                      (cond (= i 0) j\n                            (= j 0) i\n                            (= (nth a (- i 1)) (nth b (- j 1))) 0\n                            :else 1))))))]\n    (doall\n     (for [i (range 1 (+ c 1)) j (range 1 (+ d 1))]\n       (swap! m #(assoc-in % [i j] (min (+ (get-in @m [(- i 1) j]) 1)\n                                        (+ (get-in @m [i (- j 1)]) 1)\n                                        (+ (get-in @m [(- i 1) (- j 1)]) (get-in @m [i j])))))))\n    (get-in @m [c d])))", "problem": 101, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [s1 s2]\n  (let [c1 (inc (count s1)), c2 (inc (count s2))\n        distances (reduce (fn [mat [x y]]\n                            (assoc-in mat [y x]\n                               (cond (zero? x) y\n                                     (zero? y) x\n                                     (= (nth s1 (dec x)) (nth s2 (dec y))) (get-in mat [(dec y) (dec x)])\n                                     :else (inc (min (get-in mat [y (dec x)])       ;; deletion\n                                                     (get-in mat [(dec y) x])       ;; insertion\n                                                     (get-in mat [(dec y) (dec x)]) ;; sub\n                                                     )))))\n                          (vec (repeat c2 (vec (repeat c1 0))))\n                          (for [y (range c2) x (range c1)] [x y]))]\n    (get-in distances [(count s2) (count s1)])))", "problem": 101, "user": "4e52d815535d302ef430da77"}, {"code": "#((fn f [r [a & b :as c] [x & y :as z]]\n    (if (nil? a)\n      (+ r (% z))\n      (if (= a x)\n        (f r b y)\n        (apply f (+ 1 r)\n          (if (or (= (%2 b) (%2 y)) (= (% c) (% z)))\n            [b y]\n            (if (> (% c) (% z))\n              [b z]\n              [c y]))))))\n  0 %3 %4)\ncount\nfirst", "problem": 101, "user": "4e49badd535dc968683fc4c9"}, {"code": "(letfn [(iters [n f start]\n          (take n (map second\n                       (iterate f start))))]\n (fn [s t]\n   (let [m (inc (count s)), n (inc (count t))\n         first-row (vec (range m))\n         matrix (iters n (fn [[j row]]\n                           [(inc j)\n                            (vec (iters m (fn [[i col]]\n                                            [(inc i)\n                                             (if (= (nth s i)\n                                                    (nth t j))\n                                               (get row i)\n                                               (inc (min (get row i)\n                                                         (get row (inc i))\n                                                         col)))])\n                                        [0 (inc j)]))])\n                       [0 first-row])]\n     (last (last matrix)))))", "problem": 101, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(let [mem (atom {})]\n  (fn lev [s t]\n    (cond\n    (empty? s) (count t)\n\t  (empty? t) (count s)\n\t  :else (if-let [e (find @mem [s t])]\n\t          (val e)\n\t\t\t  (let [ns (rest s)\n\t\t\t        nt (rest t)\n\t\t\t\t\tret (if (= (first s) (first t))\n\t\t\t\t\t      (lev ns nt)\n\t\t\t\t\t\t  (min (inc (lev s nt))\n\t\t\t\t\t\t       (inc (lev ns t))\n\t\t\t\t\t\t\t   (inc (lev ns nt))))]\n\t\t\t    (swap! mem assoc [s t] ret)\n\t\t\t\tret)))))", "problem": 101, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn[w1 w2]\n  (let [s (vec w1)\n        t (vec w2)\n        n (count s)\n        m (count t)\n        d (atom (vec (range (inc n))))]\n    (cond\n      (zero? n) m\n      (zero? m) n\n      :else\n        (loop [p (vec (range (inc n)))\n               j 1]\n          (if (<= j m)\n            (let [tj (nth t (dec j))]\n              (swap! d assoc 0 j)\n              (doseq [i (range 1 (inc n))]\n                (let [c (if (= (nth s (dec i)) tj) 0 1)\n                      m (min (inc (nth @d (dec i))) (inc (nth p i)) (+ c (nth p (dec i))))]\n                  (swap! d assoc i m)))\n              (let [tmp @d]\n                (reset! d p)\n                (recur tmp (inc j))))\n          (nth p n))))))", "problem": 101, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn d [a b]\n  (if (and (seq a) (seq b))\n    (let [[s & u] a [t & w] b]\n      (if (= s t) \n        (d u w)\n        (+ 1\n          (min \n            (d a w)\n            (d u b)\n            (d u w)))))\n    (max (count a) (count b))))", "problem": 101, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn lev [s t]\n    (cond\n      (empty? s) (count t)\n      (empty? t) (count s)\n      :else\n        (let [ns (rest s)\n              nt (rest t)]\n          (if (= (first s) (first t))\n            (lev ns nt)\n            (inc (min\n              (lev s nt)\n              (lev ns t)\n              (lev ns nt)))))))", "problem": 101, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "#(loop [r 0 i % j %2] (let [x first y count z rest c (y i) d (y j) e (z i) f (z j) n (inc r)] (if (empty? i) (+ r d) (if (= (x i) (x j)) (recur r e f) (if (or (= (x e) (x f)) (= c d)) (recur n e f) (if (> c d) (recur n e j) (recur n i f)))))))", "problem": 101, "user": "4da3e8d730acd6ed11482a68"}, {"code": "(fn [s t]\r\n      (let [s (vec s) t (vec t)\r\n            m (count s) n (count t)\r\n            d (make-array Integer/TYPE (inc m) (inc n))]\r\n        (doseq [i (range (inc m))] (aset d i 0 i))\r\n        (doseq [j (range (inc n))] (aset d 0 j j))\r\n        (doseq [i (range 1 (inc m))\r\n                j (range 1 (inc n))]\r\n          (if (= (get s (dec i)) (get t (dec j)))\r\n            (aset d i j (aget d (dec i) (dec j)))\r\n            (aset d i j\r\n                  (+ 1 (min (aget d (dec i) j)\r\n                            (aget d i (dec j))\r\n                            (aget d (dec i) (dec j)))))))\r\n        (aget d m n)))", "problem": 101, "user": "4defdf31535d08e6dec9fe14"}, {"code": "(letfn [\r\n  \t(initialize-matrix [m n]\r\n\t\t\t(let [xs (for [i (range (inc m))] {[i 0] i})\r\n\t\t\t\t  ys (for [j (range (inc n))] {[0 j] j})]\r\n\t\t\t(apply merge (concat xs ys))))\r\n\t\t(enumerate-cells [m n]\r\n\t\t\t(for [j (range n), i (range m)] [(inc i) (inc j)]))\r\n\t\t(cheapest-mutation [d i j]\r\n\t\t\t(min\r\n\t\t\t\t(+ (get d [(dec i) j      ]) 1)\t\t; a deletion\r\n\t\t\t\t(+ (get d [i       (dec j)]) 1)\t\t; an insertion\r\n\t\t\t\t(+ (get d [(dec i) (dec j)]) 1)))]\t; a substitution\r\n\t\r\n\t(fn levenshtein [s t]\r\n\t\t(let [m (count s), n (count t)]\r\n\t\t\t(loop [d (initialize-matrix m n), cells (enumerate-cells m n)]\r\n\t\t\t\t(if-let [[[i j] & cells-tail] (seq cells)]\r\n\t\t\t\t\t(if (= (nth s (dec i)) (nth t (dec j)))\r\n\t\t\t\t\t\t(recur (assoc d [i j] (get d [(dec i) (dec j)])) cells-tail)\r\n\t\t\t\t\t\t(recur (assoc d [i j] (cheapest-mutation d i j)) cells-tail))\r\n\t\t\t\t\t(get d [m n]))))))", "problem": 101, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [s t]\n  ((fn [[c d]]\n  ((reduce\n    (fn [u j]\n      (reduce\n        (fn [v i]\n          (assoc v [(+ i 1) (+ j 1)]\n            (if (= (nth s i) (nth t j))\n              (v [i j])\n              (+ 1 \n                (min \n                  (v [i (+ 1 j)])\n                  (v [(+ i 1) j])\n                  (v [i j]))))))\n        u\n        (range c)))\n    (into {} (concat (map (fn [i] [[i 0] i]) (range (+ 1 c)))\n                     (map (fn [j] [[0 j] j]) (range (+ 1 d)))))\n    (range d))\n    [c d]))\n    (map count [s t])))", "problem": 101, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn lev [s1 s2]\r\n  (let [al (inc (count s1))\r\n        bl (inc (count s2))\r\n        arr (vec (repeat al (vec (repeat bl 0))))\r\n  \t    arr1 (loop [a arr i 0]\r\n\t\t\t\t      (if (< i al)\r\n\t\t\t\t        (recur (assoc-in a [i 0] i) (inc i))\r\n\t\t\t\t        a))\r\n\t\t    arr2 (loop [a arr1 j 0]\r\n\t\t\t\t      (if (< j bl)\r\n\t\t\t\t        (recur (assoc-in a [0 j] j) (inc j))\r\n\t\t\t\t        a))\r\n\t\t    arr3 (reduce\r\n\t\t\t\t      (fn [a [i j]] \r\n\t\t\t\t        (assoc-in a [i j] \r\n\t\t\t\t          (min \r\n\t\t\t\t            (+ 1 (get-in a [(dec i) j]))\r\n\t\t\t\t            (+ 1 (get-in a [i (dec j)]))\r\n\t\t\t\t            (+ (get-in a [(dec i) (dec j)]) \r\n                       (if (= (nth s1 (dec i)) (nth s2 (dec j))) 0 1))\r\n\t\t\t\t            )))\r\n              arr2\r\n\t\t\t\t      (for [i (range 1 al) j (range 1 bl)] [i j]))\r\n      ]\r\n\t\t   (get-in arr3 [(dec al) (dec bl)])\r\n\t\t  ))", "problem": 101, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn this [s1 s2]\n  (cond\n   (empty? s1) (count s2)\n   (empty? s2) (count s1)\n   :else (if (= (first s1) (first s2))\n           (this (rest s1) (rest s2))\n           (inc\n            (min\n             (this (rest s1) s2)\n             (this s1 (rest s2))\n             (this (rest s1) (rest s2)))))))", "problem": 101, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn [xs ys]\n  (cond\n    (empty? xs) (count ys)\n    (empty? ys) (count xs)\n    true ;else:\n    (peek\n     (reduce\n      (fn [prow [i x]]\n        (reduce\n         (fn [crow [y a b]]\n           (conj crow\n            (if (= x y)\n              a\n              (inc (min a b (last crow))))))\n         [i]\n         (map cons ys (partition 2 1 prow))))\n      (range (inc (count ys)))\n      (map vector (range 1 (inc (count xs))) xs)))))", "problem": 101, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn levenshtein-distance [source destination]\r\n  (letfn [(ld [source destination recur-f]\r\n            (cond (empty? source) (count destination)\r\n                  (empty? destination) (count source)\r\n                  :else (min (inc (recur-f (butlast source) destination recur-f))\r\n                             (inc (recur-f source (butlast destination) recur-f))\r\n                             (+ (recur-f (butlast source) (butlast destination) recur-f)\r\n                                (if (= (last source) (last destination))\r\n                                   0\r\n                                   1)))))]\r\n    (ld source destination (memoize ld))))", "problem": 101, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [& z]\n  (apply (fn f [[a & x :as j] [b & y :as k]]\n           (if j\n             (if (= a b)\n               (f x y)\n               (+ 1\n                  (if (= (count x) (count y))\n                    (f x y)\n                    (min (f x y) (f j y)))))\n             (count k)))\n         (sort-by count z)))", "problem": 101, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn [& i]\n  (let [c count\n        [x y] (sort #(< (c %1) (c %2)) i)]\n    (loop [s x l y n (c y)]\n  \t  (if s\n        (let [a (first s)\n              f ((set l) a)]\n  \t\t    (recur\n  \t\t\t    (next s)\n  \t\t\t    (if f (rest (drop-while #(not= a %) l)) l)\n  \t\t\t    (if f (dec n) n)))\n        n))))", "problem": 101, "user": "4db85282535d1e037afb218a"}, {"code": "(fn f[x y]\n  (cond \n    (empty? x) (count y)\n    (empty? y) (count x)\n    :else (let [[x1 & xn] x, [y1 & yn] y]\n      (if (= x1 y1) \n        (f xn yn)\n        (inc (min (f x yn) (f xn y) (f xn yn)))))))", "problem": 101, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(letfn [\n  (edit-matrix [a b]\n   (let [a (cons \\- a) b (cons \\- b) ];add gap characters\n    (memoize (fn field [f x y]\n     (cond\n      (zero? x) y;gap cost of one\n      (zero? y) x;gap cost of one\n      :else (min\n   (inc (min (f f (dec x) y) (f f x (dec y))))\n \t(+ (f f (dec x) (dec y)) (if (= (nth a x) (nth b y)) 0 1))))))))\n]\n\n(fn [a b]\n (let [mat (memoize (edit-matrix a b))]\n  (mat mat (count a) (count b))))); cheating with recursion", "problem": 101, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn levenshtein [a b]\n  (let [\n  m (count (seq a))\n  first-row (range (+ 1 m))\n  dist (fn [prior-row l]\n    (fn [acc i]\n      (conj acc\n        (cond\n          (== -1 i)       (+ 1 (first prior-row))\n          (= l (nth a i)) (nth prior-row i)\n          :else           (+ 1 (min (nth prior-row i)\n                                    (nth prior-row (+ 1 i))\n                                    (last acc)))))))\n  ]\n  (last (reduce #(reduce (dist %1 %2) [] (range -1 m)) first-row b))))", "problem": 101, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [seq1 seq2]\n  (letfn [(cost [a b] (if (= a b) 0 1))]\n     (with-local-vars\n         [levd (memoize \n                 (fn [seq1 seq2]\n                   (cond\n                     (empty? seq1) (count seq2)\n                      (empty? seq2) (count seq1)\n                      :else (min\n                             (+ (cost (first seq1) (first seq2)) \n                                (levd (rest seq1) (rest seq2))) \n                             (inc (levd (rest seq1) seq2))   \n                             (inc (levd seq1 (rest seq2)))))))]\n         (.bindRoot levd @levd)\n         (@levd seq1 seq2))))", "problem": 101, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "#(let [f (memoize\n         (fn [f a b]\n           (cond (empty? a) (count b)\n                 (empty? b) (count a)\n                 0 (min (inc (f f a (rest b)))\n                        (inc (f f (rest a) b))\n                        (+ (f f (rest a) (rest b))\n                           (if (= (first a) (first b)) 0 1))))))]\n   (f f %1 %2))", "problem": 101, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn ld [a b]\n     (let [x (vec a) y (vec b) cx (inc (count x)) cy (inc (count y))\n\t\to (into {} (for [i (range cx) j (range cy)] (if (or (= 0 i) (= 0 j)){[i j] (max i j)})))]\n\t\t((reduce\t\t \n\t\t  (fn [m [i j]]\n\t\t      (let [v (if (= (x (dec i)) (y (dec j))) \n\t\t\t\t    (m [(dec i) (dec j)])\n\t\t\t\t    (inc (min (m [(dec i) j]) (m [i (dec j)]) (m [(dec i) (dec j)]))))]\n\t\t\t\t    (into m {[i j] v}))) o \n\t\t\t\t    (for [i (range 1 cx) j (range 1 cy)] [i j]))[(dec cx) (dec cy)])))", "problem": 101, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn d [l a b]\n  (cond (= a b) 0\n        (and l (<= l 0)) nil\n        (empty? a) (count b)\n        (empty? b) (count a)\n        :else (let [[fa & ra] a [fb & rb] b]\n                (cond (= a rb) 1\n                      (= ra b) 1\n                      (= fa fb) (d l ra rb)\n                      :else (let [md (d (if l (dec l)) ra rb)]\n                              (when md\n                                (inc (min md\n                                         (or (d md a rb) md)\n                                         (or (d md ra b) md))))))))) nil", "problem": 101, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn lev [s t]\n   (let [m (count s) n (count t)]\n     (cond\n      (zero? m) n\n      (zero? n) m\n      true \n      (letfn [(levh [i j d]\n                (cond (> i m) (recur 1 (inc j) d)\n                      (> j n) d\n                      true (recur\n                            (inc i) j\n                            (assoc d [i j]\n                                   (if (= (nth s (dec i)) (nth t (dec j)))\n                                     (d [(dec i) (dec j)])\n                                     (min\n                                      (inc (d [(dec i) j]))\n                                      (inc (d [i (dec j)]))\n                                      (inc (d [(dec i) (dec j)]))))))))]\n        ((levh 1 1 (reduce (fn [m [a b]] (assoc m [a b] (+ a b))) {} (concat (map #(vector % 0) (range 0 (inc m)))\n                                                                            (map #(vector 0 %) (range 0 (inc n))))))\n         [m n])))))", "problem": 101, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn ld [s t]\n  (let [ s (seq s)\n         t (seq t)\n         m (inc (count s))\n         n (inc (count t))\n         d (into {} (concat (map #(vector [% 0] %) (range m))\n                            (map #(vector [0 %] %) (range n)))) ]\n    \n      (loop [ ti (range 1 n) d d ]\n        (if-let [ tn (first ti) ]\n           (recur (rest ti) \n                  (loop [ si (range 1 m ) d d ]\n                    (if-let [ sn (first si) ]\n                       (if (= (nth s (dec sn)) (nth t (dec tn)))\n                           (recur (rest si) (assoc d [sn tn] (d [(dec sn) (dec tn)] 0)))\n                           (recur (rest si) (assoc d [sn tn] (inc (min (d [(dec sn) tn] 0)\n                                                                       (d [sn (dec tn)] 0)\n                                                                       (d [(dec sn) (dec tn)] 0))))))\n                       d)))\n           (d [(dec m)(dec n)])))))", "problem": 101, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn [a b] \n(let [\n  [small big] (sort-by count [a b])\n  cs (count small)\n  subs \n    (filter\n       #(= cs (count %))\n       (reduce\n          (fn [ss x] (concat ss (map #(conj % x) ss)))\n          [[]]\n         big))\n  diffs #(count (filter false? (map = % small)))\n  mindiffs (apply min (map diffs subs))]\n \n   (+ (- (count big) cs) mindiffs)))", "problem": 101, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [a b]\r\n  (cond\r\n    (= 1 (first a)) 2\r\n    (= :a (first a)) 2\r\n    (.startsWith (str a) \"tttt\") 10\r\n    (.startsWith (str b) \"caaa\") 9\r\n    (= a b) 0\r\n    true ({\"kitten\" 3 \"clojure\" 1 \"closure\" 1\r\n      \"xyx\" 2 \"\" 6 } a)))", "problem": 101, "user": "4dfe65a1535d04ed9115e787"}, {"code": "#(let [a (atom {})\n        m (count %)\n        n (count %2)]\n    (doseq [i (range (inc m))]\n      (swap! a assoc-in [i 0] i))\n    (doseq [j (range (inc n))]\n      (swap! a assoc-in [0 j] j))\n    (doseq [i (range 1 (inc m)) j (range 1 (inc n))]\n      (if (= (nth %2 (dec j)) (nth % (dec i)))\n        (swap! a assoc-in [i j] (get-in @a [(dec i) (dec j)] 0))\n        (swap! a assoc-in [i j] (min (inc (get-in @a [(dec i) j] 0))\n                                     (inc (get-in @a [i (dec j)] 0))\n                                     (inc (get-in @a [(dec i) (dec j)] 0))))))\n    (get-in @a [m n]))", "problem": 101, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn leb [a b]\n   (cond (empty? a) (count b)\n        (empty? b) (count a)\n        (= (first a) (first b))(leb (rest a) (rest b))\n        :else (min (inc (leb a (rest b)))\n                   (inc (leb (rest a) b))\n                   (inc (leb (rest a) (rest b))))))", "problem": 101, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn levenshtein [s t]\n  (let [m (count s)\n        n (count t)\n        d (transient (apply hash-map\n                            (concat [[0, 0] 0]\n                                    (mapcat #(list [% 0] %) (range 1 (inc m)))\n                                    (mapcat #(list [0 %] %) (range 1 (inc n))))))\n        ]\n    ((reduce (fn [d j]\n              (reduce (fn [d i]\n                        (assoc! d (map inc [i, j])\n                                (if (= (nth s i) (nth t j))\n                                  (d [i, j])\n                                  (inc (min (d [i, (inc j)])\n                                            (d [(inc i), j])\n                                            (d [i, j])))))\n                        ) d (range 0 m))\n               ) d (range 0 n)) [m, n])))", "problem": 101, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [w1 w2]\n   (let [s1 (seq w1), s2 (seq w2)]\n     (with-local-vars [matrix (memoize (fn [i j]\n                                         (cond\n                                          (zero? i) j\n                                          (zero? j) i\n                                          (= (nth s1 (dec i)) (nth s2 (dec j))) (matrix (dec i) (dec j))\n                                          :else (inc (min (matrix (dec i) j)\n                                                          (matrix i (dec j))\n                                                          (matrix (dec i) (dec j)))))))]\n       ; make the memoized fn available as a root binding in our thread\n       (.bindRoot matrix @matrix)\n       (matrix (count s1) (count s2)))))", "problem": 101, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn levenshtein [seq1 seq2]\r\n  (let [n (count seq1)\r\n        m (count seq2)\r\n        a (make-array Integer/TYPE (inc n) (inc m))]\r\n    (doseq [i (range (inc n))] (aset a i 0 i))\r\n    (doseq [j (range (inc m))] (aset a 0 j j))\r\n    (doseq [i (range 1 (inc n))\r\n            j (range 1 (inc m))]\r\n      (aset a i j\r\n            (if (= (nth seq1 (dec i)) (nth seq2 (dec j)))\r\n              (aget a (dec i) (dec j))\r\n              (inc (min (aget a (dec i) (dec j))\r\n                        (aget a i (dec j))\r\n                        (aget a (dec i) j))))))\r\n    (aget a n m)))", "problem": 101, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn leven\r\n  [s1 s2]\r\n\t(with-local-vars [f (memoize (fn\r\n\t\t\t\t[w1 w2]\r\n\t\t\t\t(cond\r\n\t\t\t\t\t(empty? w2) (count w1)\r\n\t\t\t\t\t(empty? w1) (count w2)\r\n\t\t\t\t\t:otherwise \r\n\t\t\t\t\t\t(min\r\n\t\t\t\t\t\t\t(+ (if (= (first w1) (first w2)) 0 1) (f (rest w1) (rest w2)))\r\n\t\t\t\t\t\t\t(inc (f (rest w1) w2))\r\n\t\t\t\t\t\t\t(inc (f (rest w2) w1))))))]\r\n      (.bindRoot f @f)\r\n\t\t(f s1 s2)))", "problem": 101, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn l\r\n    ([s t] (l s t (count s) (count t)))\r\n\t  ([s t i j]\r\n\t      (cond (zero? i)\r\n                  j\r\n\t\t          (zero? j)\r\n                  i\r\n\t\t          (= (nth s (dec i)) (nth t (dec j))) \r\n\t\t              (l s t (dec i) (dec j))\r\n\t\t          :else\r\n\t\t              (inc (min (l s t (dec i) j)\r\n\t\t\t\t                    (l s t i (dec j))\r\n\t\t\t\t                    (l s t (dec i) (dec j)))))))", "problem": 101, "user": "4e821ca5535db62dc21a62c2"}, {"code": ";; use memoization for caching instead of doing it\n;; explicitly\n(fn [s1 s2]\n  (with-local-vars [rleven (memoize (fn [a b da db] \n    (cond (and (empty? a) (empty? b)) 0\n          (empty? a) db\n          (empty? b) da\n          (= (first a) (first b)) (rleven (rest a) (rest b) (dec da) (dec db))\n          :else\n          (+ 1 (min (rleven (rest a) b (dec da) db)\n                    (rleven a (rest b) da (dec db))\n                    (rleven (rest a) (rest b) (dec da) (dec db)))))))]\n(@rleven (reverse s1) (reverse s2) (count s1) (count s2))))", "problem": 101, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn [s t]\r\n  ((memoize\r\n    (fn d [i j]\r\n      (cond\r\n        (< i 0) (inc j)\r\n        (< j 0) (inc i)\r\n        (= (nth s i) (nth t j)) (d (dec i) (dec j))\r\n        true (inc (min (d (dec i) j)\r\n                       (d i (dec j))\r\n                       (d (dec i) (dec j)))))))\r\n    (dec (count s)) (dec (count t))))", "problem": 101, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "#((fn l [x y] (let [m (dec x) n (dec y)]\n                (cond (= x 0) y \n                      (= y 0) x \n                      (= (nth %1 m) (nth %2 n)) (l m n) \n                      :else (inc (min (l m y) (l x n) (l m n)))))) \n    (count %1) \n    (count %2))", "problem": 101, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn [s t]\n  (let [s (seq s)\n        t (seq t)\n        m (count s)\n        n (count t)\n        s #(when (<= % m) (nth s (- % 1)))\n        t #(when (<= % n) (nth t (- % 1)))\n        a (atom {})\n        p #(do (swap! a assoc [% %2] %3) %3)\n        g #(get @a [% %2])]\n    (last\n      (for [i (range (+ m 1)) j (range (+ n 1))] \n        (p i j\n\t        (cond\n\t          (= i 0) j\n\t          (= j 0) i\n\t          :e (min \n\t               (+ (g i (- j 1)) 1)\n\t               (+ (g (- i 1) j) 1)\n\t               (+ (g (- i 1) (- j 1)) (if (= (s i) (t j)) 0 1)))))))))", "problem": 101, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn levenshtein\n([s1 s2] \n(levenshtein s1 s2\n(memoize (fn [s1 s2 memo]\n  (cond (empty? s1) (count s2)\n        (empty? s2) (count s1)\n        :else (min \n                (+ (if (= (first s1)(first s2)) 0 1) \n                    (levenshtein (rest s1)(rest s2) memo))\n                (inc (levenshtein (rest s1) s2 memo))\n                (inc (levenshtein s1 (rest s2) memo))))))))\n([s1 s2 memo-fn] (memo-fn s1 s2 memo-fn)))", "problem": 101, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn levenshtein [s t]\n         (let [m (count s), n (count t)\n               M (inc m),   N (inc n)\n               d (make-array Long/TYPE M N)] ; Clojure 1.3\n           (doseq [i (range M)]\n             (aset d i 0 i))\n           (doseq [j (range N)]\n             (aset d 0 j j))\n           (doseq [j (range 1 N)\n                   i (range 1 M)]\n             (if (= (get s (dec i)) (get t (dec j)))\n               (aset d i j (aget d (dec i) (dec j))) ; no op. req.\n               (aset d i j (inc (min\n                                 (aget d (dec i) j) ; deletion\n                                 (aget d i (dec j)) ; insertion\n                                 (aget d (dec i) (dec j))))))) ; substition\n           (aget d (dec M) (dec N))))", "problem": 101, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(memoize (fn lev [xs ys]\n  (cond\n    (= (count xs) 0) (count ys)\n    (= (count ys) 0) (count xs)\n    (= (first xs) (first ys)) (lev (rest xs) (rest ys))\n    :else (+ 1 (min (lev (rest xs) (rest ys)) (lev xs (rest ys)) (lev (rest xs) ys))))))", "problem": 101, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [a b]\n  (let [f (fn [s a b]\n            (if-let [[aa & as] (seq a)]\n              (if-let [[bb & bs] (seq b)]\n                (if (= aa bb)\n                  (s s as bs)\n                  (inc (min (s s as b) (s s as bs) (s s a bs))))\n                (count a))\n              (count b)))\n         g (memoize f)]\n    (g g a b)))", "problem": 101, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn levenshtein [a b]\n  (let [distance (fn [a b recurrence]\n            (let [m (count a),\n                  n (count b)]\n              (if (zero? (min m n))\n                (max m n)\n                (let [prefixa (butlast a),\n                      prefixb (butlast b)]\n                  (if (= (last a) (last b))\n                    (levenshtein prefixa prefixb)\n                    (inc (min\n                           (recurrence prefixa prefixb recurrence)\n                           (recurrence prefixa b recurrence)\n                           (recurrence a prefixb recurrence)))))))),\n          memoized (memoize distance)]\n      (memoized a b memoized)))", "problem": 101, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn lev [x y]\n  (cond (empty? x) (count y)\n        (empty? y) (count x)\n        (= (first x) (first y)) (lev (rest x) (rest y))\n        :else (+ 1 (min (lev (rest x) y)\n                        (lev x (rest y))\n                        (lev (rest x) (rest y))))))", "problem": 101, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn p101 [c1 c2]\n  \n  (let [m (count c1) n (count c2)\n        lv-dis (fn [mtx-for-last newchar newchar-pos thestr]\n               (loop [result [newchar-pos]\n                      data   thestr\n                      cnt 1 ]\n                 (if (empty? data)\n                    result\n                   (let [char-to-compare (first data)]\n                   (if (= newchar char-to-compare)\n                        (recur (conj result (nth mtx-for-last (dec cnt)))\n                               (rest data)\n                               (inc cnt))\n                        (recur (conj result\n                                  (inc (min  (nth mtx-for-last (dec cnt))\n                                        (nth result  (dec cnt))\n                                        (nth mtx-for-last  cnt))))\n                               (rest data)\n                               (inc cnt)))))))\n        ]\n        (loop [mtx (range (inc n)) data c1 cnt 1]\n          (if (empty? data)\n            (last mtx)\n            (let [c (first data)]\n              (recur (lv-dis mtx c cnt c2) (rest data) (inc cnt)))  ))))", "problem": 101, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn l[a b]\n  (loop [r 0 v (range (inc (count a)))]\n    (if (= r (count b))\n      (last v)\n      (recur (inc r)\n             (into [(+ 1 r)] (loop [i 0 t []]\n                               (if (< i (count a))\n                                 (recur (+ 1 i)\n                                        (if (= (nth b r) (nth a i))\n                                          (conj t (nth v i))\n                                          (conj t (inc\n                                                    (min (nth v i)\n                                                         (nth v (+ 1 i))\n                                                         (if (= i 0) (+ 1 r) (nth t (- i 1))))))))\n                                 t)))\n             ))))", "problem": 101, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn levenshtein [seq1 seq2]\r\n  (let [n (count seq1)\r\n        m (count seq2)\r\n        a (make-array Integer/TYPE (inc n) (inc m))]\r\n    (doseq [i (range (inc n))] (aset a i 0 i))\r\n    (doseq [j (range (inc m))] (aset a 0 j j))\r\n    (doseq [i (range 1 (inc n))\r\n            j (range 1 (inc m))]\r\n      (aset a i j\r\n            (if (= (nth seq1 (dec i)) (nth seq2 (dec j)))\r\n              (aget a (dec i) (dec j))\r\n              (inc (min (aget a (dec i) (dec j))\r\n                        (aget a i (dec j))\r\n                        (aget a (dec i) j))))))\r\n    (aget a n m)))", "problem": 101, "user": "4e7e4d5c535db169f9c7970f"}, {"code": "(fn levenshtein-distance [xs ys]\n  (letfn [(matches [[x & xs :as xss] ys]\n            (cond (or (empty? xss) (empty? ys)) 0\n                  (some #{x} ys) (inc (matches xs (rest (drop-while #(not= x %)\n                                                                    ys))))\n                  :else (matches xs ys)))]\n    (- (max (count xs) (count ys))\n       (matches xs ys))))", "problem": 101, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(comp last\n  (fn d [m [H & T :as S] [h & t :as s]]\n    (let [C count\n          [M D]\n            (cond\n              (m [S s]) [m (m [S s])]\n              (and H h)\n                (if (= H h)\n                  (d m T t)\n                  (let [[n a] (d m T t)\n                        [o b] (d n S t)\n                        [p c] (d o s T)]\n                    [p (+ 1 (min a b c))]))\n              1 [m (max (C S) (C s))])]\n      [(assoc M [S s] D) D])))\n{}", "problem": 101, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [C s t]\n  ((fn f [i j]\n     (cond \n       (= i 0) j\n       (= j 0) i\n       (= (nth s (- i 1)) (nth t (- j 1))) (f (- i 1) (- j 1))\n       :else   (+ 1 \n                  (min (f (- i 1) j)\n                       (f i       (- j 1))\n                       (f (- i 1) (- j 1))))))\n   (C s) (C t))) count", "problem": 101, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [a b]\n  (loop [scores [[a b 0]]]\n    (let [finished (filter (fn [[a b _]] (and (empty? a) (empty? b))) scores)]\n      (if (seq finished)\n        (apply min (map last finished))\n        (recur (mapcat (fn [[a b score]]\n          (if (= (first a) (first b))\n            [[(rest a) (rest b) score]]\n            (concat\n              (if (empty? a) [] [[(rest a) b (inc score)]])\n              (if (empty? b) [] [[a (rest b) (inc score)]])\n              (if (or (empty? a) (empty? b)) [] [[(rest a) (rest b) (inc score)]]))))\n          scores))))))", "problem": 101, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [left right]\n    ((fn lv [[l & ls :as left] [r & rs :as right] acc cutoff]\n       (cond\n        (> acc cutoff) acc\n        (nil? l) (count right)\n        (nil? r) (count left)\n        (= l r) (lv ls rs acc cutoff)\n        :else (min (inc (lv ls rs (inc acc) cutoff))\n                   (inc (lv ls right (inc acc) cutoff))\n                   (inc (lv left rs (inc acc) cutoff)))))\n     left right 0 (max (count left) (count right))))", "problem": 101, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [s1 s2]\n    (let [m (count s1)\n          r (range (+ 1 m))\n          d (fn [p l] \n               (fn [a i] (conj a\n                (if (== -1 i) \n                    (inc (first p))\n                    (if (= l (nth s1 i)) \n                        (nth p i)\n                        (inc (min (nth p i) (nth p (inc i)) (last a))))))))]\n     (last (reduce (fn [x y] (reduce (d x y) [] (range -1 m))) r s2))))", "problem": 101, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [s t] \n   ((fn f [j r] \n     (let [d (cons j r) \n           w (map #(list % %2 %3) s d r)\n           z (if (< j (count t)) (reduce #(conj % (if (= (first %2) (nth t j)) (second %2) (min (inc (second %2)) (inc (last %2)) (inc (last %))))) [(inc j)] w) d)] \n       (if (= j (count t)) (last z) (f (inc j) (rest z))))) 0 (range 1 (inc (count s)))))", "problem": 101, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [a b]\n  (letfn [ (build-row [prev-row row-char row _]\n             (let [ai (count row)]\n               (conj row\n                 (if (= (get a (dec ai)) row-char)\n                   (prev-row (dec ai))\n                   (inc (min (last row) (prev-row ai) (prev-row (dec ai))))))))]\n\n    (loop [bi 0 prev-row (vec (range (inc (count a))))]\n      (if (= bi (count b))\n        (last prev-row)\n        (recur (inc bi) (reduce (partial build-row prev-row (get b bi)) [(inc bi)] a))))))", "problem": 101, "user": "4f01ff83535dcb61093f6a3a"}, {"code": "(fn levenshtein [a b]\n        (let [a (vec a) b (vec b)\n              m (inc (count a)) n (inc (count b))\n              x (vec (repeat n (repeat m 0)))\n              y (assoc x 0 (range m))\n              z (vec (map #(assoc (vec %) 0 %2) y (range n)))\n              k (for [j (range 1 n) i (range 1 m)] [j i])]\n          (-> (reduce\n               (fn [d [i j]]\n                 (assoc-in d [i j]\n                           (if (= (a (dec j)) (b (dec i)))\n                             (get-in d [(dec i) (dec j)])\n                             (+ 1 (min (get-in d [(dec i) j])\n                                       (get-in d [i (dec j)])\n                                       (get-in d [(dec i) (dec j)])))))) z k)\n              last last)))", "problem": 101, "user": "4f031eac535dcb61093f6a67"}, {"code": "#(first (last\n  (reduce (fn [f b] (let [[t z] (first f)\n                          v     (rest f)]\n  (map (fn [x] [(second x) (last x)])\n  (reduce (fn [r [u a]] \n    (let [e (last r)\n          p (first e)\n          l (second e)]\n      (conj r \n        (if (= a b)\n          [u p a]\n          [u (+ 1 (min l u p)) a])))) [[t (+ 1 t)]] v))))\n(concat [[0 0]] (partition 2 \n  (interleave (range 1 (+ 1 (count %))) %)\n  )) %2)))", "problem": 101, "user": "4f01c938535dcb61093f6a39"}, {"code": "#(let [c count\n        n (c %2) m (c %3)\n        a (make-array (type 1) (+ n 1) (+ m 1))\n        s (% aset a) g (% aget a)\n        I (% + 1)]\n   (dotimes [i (I n)] (s i 0 i))\n   (dotimes [j (I m)] (s 0 j j))\n   (dotimes [i n]\n     (dotimes [j m]\n       (let [k (I i) l (I j) p (g i j)]\n         (s k l\n            (if (= (get %2 i) (get %3 j))\n              p\n              (I (min (g i l) (g k j) p)))))))\n   (g n m)) partial", "problem": 101, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [s1 s2]\n  (let [fast (ref (fn [ss1 ss2] 0))\n        lev (fn [seq1 seq2]\n              (let [f1 (first seq1) r1 (rest seq1)\n                    f2 (first seq2) r2 (rest seq2)]\n                (cond \n                  (empty? seq1) (count seq2)\n                  (empty? seq2) (count seq1)\n                  :else\n                    (min\n                      (+ (if (= f1 f2) 0 1) (@fast r1 r2))\n                      (inc (@fast r1 seq2))\n                      (inc (@fast seq1 r2))))))\n              ]\n    (dosync (ref-set fast (memoize lev)))\n    (lev s1 s2)))", "problem": 101, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn levenstein-distance [ss tt]\n  (let [s (vec (cons nil ss)) t (vec (cons nil tt))\n        m (count s) n (count t)\n        d (transient (vec (repeat (* m n) 0)))]\n\n  (doseq [i (range m)] (assoc! d (-> i (* n)) i))\n  (doseq [j (range n)] (assoc! d j j))\n  (doseq [j (range 1 n) i (range 1 m)] (assoc! d (-> i (* n) (+ j)) (if (= (s i) (t j)) (d (-> i dec (* n) (+ j -1)))\n                                                 (inc (min (d (-> i dec (* n) (+ j))) (d (-> i (* n) (+ j -1))) (d (-> i dec (* n) (+ j -1))))))))\n  ((persistent! d) (-> m dec (* n) (+ n -1)))))", "problem": 101, "user": "4effb663535dcb61093f6a2e"}, {"code": "#(let [rec (atom (fn [] nil))\n         memo (atom (memoize (fn [] nil)))]\n     (do\n       (reset! rec (fn [s t]\n                     (cond\n                      (empty? s) (count t)\n                      (empty? t) (count s)\n                      :else  (min (inc (@memo (rest s) t))\n                                  (inc (@memo s (rest t)))\n                                  (let [c (@memo (rest s) (rest t))]\n                                    (if (= (first s) (first t))\n                                      c\n                                      (inc c)))))))\n       (reset! memo (memoize @rec))\n       (@memo %1 %2)))", "problem": 101, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [w1 w2]\n  (let [init-matrix\n        (vec (map vec (take (inc (count w1)) (partition (inc (count w2)) 1 (iterate inc 0)))))]\n    (last (last (reduce (fn [matrix [s [y x :as coords]]]\n                     (assoc-in matrix coords\n                               (if s\n                                 (get-in matrix [(dec y) (dec x)])\n                                 (inc (min (get-in matrix [(dec y) x])\n                                           (get-in matrix [y (dec x)])\n                                           (get-in matrix [(dec y) (dec x)]))))))\n                   init-matrix\n                   (for [x (range (count w2)) y (range (count w1))]\n                     [(= (get w2 x) (get w1 y)) [(inc y) (inc x)]]))))))", "problem": 101, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [s1 s2]\n  (letfn [(calcRow [oldRow s1 c]\n    (letfn [(nextValue [row cc] \n      (let [idx (count row)]\n        (if (= c cc)\n          (conj row (nth oldRow (dec idx)))\n          (conj row\n            (min\n              (inc (last row))\n              (inc (nth oldRow (dec idx)))\n              (inc (nth oldRow idx)))))))]\n    (reduce nextValue [(inc (first oldRow))] s1)))]\n  (let [v (vec (range (inc (count s1))))]\n    (last (reduce #(calcRow % s1 %2) v s2)))))", "problem": 101, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [a b]\n  (letfn [\n    (next-row [row str ch]\n      (loop [r row s str ret [(inc (first row))]]\n        (if\n          (empty? s) ret\n          (recur\n            (next r)\n            (next s)\n            (conj ret\n              (if (= ch (first s)) (first r)\n                (inc (min (last ret) (first r) (fnext r)))))))))]\n    (last\n      (reduce\n        #(next-row %1 a %2)\n        (range (inc (count a)))\n        b))))", "problem": 101, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn prob-0101\n [in-ss in-ts]\n (let [ss (vec (cons \\space (seq in-ss)))\n       ts (vec (cons \\space (seq in-ts)))\n       m1 (count ss)\n       n1 (count ts)\n       d (make-array Integer/TYPE m1 n1)]\n   \n   (doseq [i (range m1)]\n     (aset-int d i 0 i))\n\n   (doseq [j (range n1)]\n     (aset-int d 0 j j))\n\n   (doseq [j (range 1 n1)\n           i (range 1 m1)]\n     (if (= (ss i) (ts j))\n       (aset-int d i j (aget d (dec i) (dec j)))\n       (let [val (inc (min\n                       (aget d (dec i)      j )\n                       (aget d      i  (dec j))\n                       (aget d (dec i) (dec j))))]\n         (aset-int d i j val))))\n   (aget d (dec m1) (dec n1))))", "problem": 101, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [seq1 seq2]\n  (let [n (count seq1) m (count seq2)]\n    (get\n     (reduce\n      (fn [s1 i] (reduce\n                  (fn [s2 j] (cond\n                              (zero? j) (assoc s2 [i j] i)\n                              (zero? i) (assoc s2 [i j] j)\n                              :else\n                              (assoc s2 [i j]\n                                     (min (+ 1 (s2 [(- i 1) j]))\n                                          (+ 1 (s2 [i (- j 1)]))\n                                          (+ (s2 [(- i 1) (- j 1)])\n                                             (if (= (get seq1 (- i 1))\n                                                    (get seq2 (- j 1)))\n                                               0\n                                               1))))))\n                 s1\n                 (range (inc m))))\n     '{}\n     (range (inc n))) [n m])))", "problem": 101, "user": "4f0e995e535d0136e6c22326"}, {"code": "#(letfn [(levenshtein [s t]\r\n       (cond\r\n\t\t   (empty? s) (count t)\r\n\t\t   (empty? t) (count s)\r\n\t\t   :else (let [m (count s)\r\n\t\t\t      n (count t)\r\n\t\t\t      d (make-array Integer/TYPE (inc m) (inc n))]\r\n\t\t\t      (dotimes [i m] (aset-int d i 0 i))\r\n\t\t\t      (dotimes [j n] (aset-int d 0 j j))\r\n\t\t\t      (doseq [j (range 1 (inc n))]\r\n\t\t\t\t     (doseq [i (range 1 (inc m))]\r\n\t\t\t\t\t    (if (= (nth s (dec i)) (nth  t (dec j)))\r\n\t\t\t\t\t\t(aset-int d i j (aget d (dec i) (dec j)))\r\n\t\t\t\t\t\t(aset-int d i j (min (inc (aget d (dec i) j))\r\n\t\t\t\t\t\t\t\t     (inc (aget d i (dec j)))\r\n\t\t\t\t\t\t\t\t     (inc (aget d (dec i) (dec j))))))))\r\n\t\t\t      (aget d m n))))]\r\n  (levenshtein %1 %2))", "problem": 101, "user": "4e273301535deb9a81d77ef7"}, {"code": "(fn [a b]\n    (let [X (cons \\_ a)  Y (cons \\_ b)  m (count X)  n (count Y)\n          A (make-array Long/TYPE m n)]\n       (dotimes [i m]\n           (dotimes [j n]\n              (aset A i j (cond (= 0 i) j\n                                (= 0 j) i\n                                :else (min (+ (aget A (dec i) (dec j))\n                                              (if (= (nth X i) (nth Y j)) 0 1))\n                                           (+ (aget A (dec i) j) 1)\n                                           (+ (aget A i (dec j)) 1))))))\n       (aget A (dec m) (dec n))))", "problem": 101, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn levenshtein-distance [str1 str2]\n  \"Calculates the Levenshtein distance between str1 and str2, returns an editing distance (int).\"\n  (let [n (count str1)\n        m (count str2)]\n    ;; Check trivial cases\n    (cond (= 0 n) m\n          (= 0 m) n\n          true (loop []\n                 ;; Loop across all chars of each string\n                 (loop [i 0\n                        col (to-array ^ints (repeat (inc m) 0))\n                        prev-col (to-array ^ints (range (inc m)))]\n                   (if (= i n)\n                     (aget prev-col m)\n                     (do\n                         (aset col 0 (inc i))\n                         (dotimes [j m]\n                         (aset col (inc j)\n                               (min (inc (aget col j))\n                                    (inc (aget prev-col (inc j)))\n                                    (+ (aget prev-col j)\n                                       (if (= (nth str1 i) (nth str2 j)) 0 1)))))\n                         (println (seq col))\n                         (recur (inc i)\n                                (to-array ^ints (repeat (inc m) 0))\n                                col))))))))", "problem": 101, "user": "4eb02674535d7eef30807338"}, {"code": "(fn [s t]\n    (let [m (inc (count s))\n          n (inc (count t))\n          a (to-array-2d (repeat m (repeat n 0)))]\n       (doseq [i (range m)\n               j (range n)]\n         (cond (zero? j) (aset a i 0 i)\n               (zero? i) (aset a 0 j j)\n               (= (nth s (dec i)) (nth t (dec j))) (aset a i j (aget a (dec i) (dec j)))\n               :else\n               (aset a i j (min (inc (aget a (dec i) j))\n                                (inc (aget a i (dec j)))\n                                (inc (aget a (dec i) (dec j)))))))\n       (last (last a))))", "problem": 101, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn ld[s t]\n\t(let [m (count s)\n\t      n (count t)\n\t\t  d (into (zipmap (map #(list % 0) (take (inc m) (range))) (range))\n\t\t          (zipmap (map #(list 0 %) (take (inc n) (range))) (range)))]\n\t\t(if (zero? (min m n)) \n\t\t\t(max m n)\n\t\t\t(loop [j 1 i 1 d d] \n\t\t\t\t;(prn :j j :i i :d d)\n\t\t\t\t(let [si (get s (dec i))\n\t\t\t\t\t  tj (get t (dec j))\n\t\t\t\t      nj (if (>= i m) (inc j) j)\n\t\t\t\t      ni (if (>= i m) 1 (inc i))]\n\t\t\t\t\t;(prn :si si :tj tj :nj nj :ni ni)\n\t\t\t\t\t(if (< n j) \n\t\t\t\t\t\t(get d [m n]) \n\t\t\t\t\t\t(if (= si tj) \n\t\t\t\t\t\t\t(recur nj ni (assoc d [i j] (get d [(dec i) (dec j)]))) \n\t\t\t\t\t\t\t(recur nj ni (assoc d [i j] (inc (min (get d [(dec i)      j])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t      (get d [(dec i) (dec j)])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t      (get d [     i  (dec j)]))))))))))))", "problem": 101, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn levenshtein-distance [w1 w2]\r\n    (letfn [(build-matrix [w1 w2]\r\n              (let [rows (inc (count w1))\r\n                    cols (inc (count w2))]\r\n                (let [matrix (vec (conj\r\n                                   (map (fn [i] (vec (conj (repeat (dec cols) nil) i))) (range 1 rows))\r\n                                   (vec (range cols))))]\r\n                  matrix)))\r\n            (char-cost [row col]\r\n              (if (= (get w1 row)\r\n                     (get w2 col)) 0 1))\r\n            (min-cost [m i j]\r\n              (min\r\n               (+ (get-in m [(dec i) (dec j)]) (char-cost (dec i) (dec j)))\r\n               (inc (get-in m [(dec i) j]))\r\n               (inc (get-in m [i (dec j)]))))\r\n            (fill-entry [m i j]\r\n              (assoc-in m [i j] (min-cost m i j)))\r\n            (addr-fill-entry [m addr]\r\n              (fill-entry m (first addr) (second addr)))\r\n            (edit-dist-matrix [w1 w2]\r\n              (let [matrix (build-matrix w1 w2)]\r\n                (reduce addr-fill-entry matrix\r\n                        (for [row (range 1 (inc (count w1)))\r\n                              col (range 1 (inc (count w2)))] [row col]))))]\r\n      (get-in (edit-dist-matrix w1 w2) [(count w1) (count w2)])))", "problem": 101, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn edit-distance [source target]\n    (let [source (vec source)\n          target (vec target)\n          targlen (count target)\n          rowlen (inc targlen)\n          ; For empty source, cost is insertion of each target item\n          initrow (vec (map #(- targlen %) (range rowlen)))]\n        (loop [i (dec (count source)), prevrow initrow]\n            (if (neg? i)\n                (prevrow 0)\n                (let [sitem (source i)\n                      build-row\n                        (fn [ti row]\n                            (cond\n                                (neg? ti) \n                                    row\n                                (= (target ti) sitem) \n                                    (recur (dec ti) (conj row (prevrow (inc ti))))\n                                :else\n                                    (let [rep (inc (prevrow (inc ti)))\n                                          ins (inc (first row))\n                                          del (inc (prevrow ti))]\n                                        (recur (dec ti) (conj row (min rep ins del)))\n                                    )))\n                    ]\n                    (recur (dec i) (vec (build-row (dec targlen) (list (inc (prevrow targlen))))))\n                )))))", "problem": 101, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [& s]\n  (let [[a b] (sort-by count s)\n        c (count b)]\n    (apply min \n           (map (fn [w] (count (filter #(apply not= %) (map list w b)))) \n                (map #(replace (zipmap (filter identity %) a) %) \n                     (nth (iterate #(into [] (for [i (range c) v % :when (v i)] (assoc v i nil))) [(vec (range c))]) \n                          (- c (count a))))))))", "problem": 101, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [str1 str2]\n  (let [isize (inc (count str1))\n        jsize (inc (count str2))\n        all-pairs (for [i (range isize) j (range jsize)] [i j])\n        reducer (fn [distances [i j]]\n                  (assoc-in distances [i j]\n                            (cond\n                             (= i 0) j\n                             (= j 0) i\n\n                             (= (nth str1 (dec i)) (nth str2 (dec j)))\n                             (get-in distances [(dec i) (dec j)])\n\n                             :else\n                             (+ 1 (min (get-in distances [(dec i) j])\n                                       (get-in distances [i (dec j)])\n                                       (get-in distances [(dec i) (dec j)]))))))\n\n        zero-array (fn [m n]  (vec (take m (repeat (vec (take n (repeat 0)))))))\n        init-state (zero-array isize jsize)\n\n        levs (reduce reducer init-state all-pairs)\n        val (last (last levs))]\n    val))", "problem": 101, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [w1 w2]\n  (letfn [\n    (dist [d w1 w2]\n      (cond\n        (empty? w1) (count w2)\n        (empty? w2) (count w1)\n        :else\n          (min\n            (inc (d d (rest w1) w2))\n            (inc (d d w1 (rest w2)))\n            (+ (if (= (first w1) (first w2)) 0 1)\n              (d d (rest w1) (rest w2))))))]\n  (dist (memoize dist) w1 w2)))", "problem": 101, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn lev [s1 s2]\r\n  (if (empty? s1) (count s2)\r\n    (let [m (count s1) n (count s2)]\r\n\t    (loop [prev-line (range (+ m 1))\r\n\t           curr-line [1]\r\n\t           i 1 j 1]\r\n\t          (let [curr (if (= (nth s1 (dec j)) (nth s2 (dec i)))\r\n\t                         (nth prev-line (dec j))\r\n\t                         (inc (min (nth prev-line (dec j)) (nth prev-line j) (nth curr-line (dec j)))))\r\n\t                new-line (conj curr-line curr)]\r\n\t            (if (= j m)\r\n\t                (if (= i n) curr (recur new-line [(inc i)] (inc i) 1))\r\n\t                (recur prev-line new-line i (inc j))))))))", "problem": 101, "user": "4f13047d535d64f60314642c"}, {"code": "(fn [a b]\r\n  (letfn [(query [s1 s2 limit]\r\n            (cond\r\n             (zero? limit) 0\r\n             (empty? s1)   (min-key identity (count s2) limit)\r\n             (empty? s2)   (min-key identity (count s1) limit)\r\n             :else\r\n             (let [v1 (inc (query s1 (rest s2) (dec limit)))\r\n                   v2 (inc (query (rest s1) s2 (dec (min-key identity v1 limit))))\r\n                   v3 (if (= (first s1) (first s2))\r\n                        (query (rest s1) (rest s2) (min-key identity v2 limit))\r\n                        (inc (query (rest s1) (rest s2)\r\n                                    (dec (min-key identity v2 limit)))))]\r\n               v3)))]\r\n    (query a b (max-key identity (count a) (count b)))))", "problem": 101, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(letfn [(new-row [prev-row row-elem t]\n          (reduce  (fn [row [d-1 d e]]\n                     (conj row (if (= row-elem e)\n                                 d-1\n                                 (inc (min (peek row)\n                                           (min d d-1))))))\n                   [(inc (first prev-row))]\n                   (map vector prev-row (next prev-row) t)))]\n  (fn [s t]\n    (peek (reduce (fn [prev-row s-elem]\n                    (new-row prev-row s-elem t)) \n                  (vec (range (inc (count t)))) \n                  s))))", "problem": 101, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [x y]\n           (last (reduce #(reduce (fn [r [d-1 d e]] \n                                   (conj r (if (= %2 e) d-1 (inc (min (last r) d d-1)))))\n                           [(inc (first %1))]\n                           (map vector %1 (next %1) y))\n                         (range (inc (count y)))\n                         x)))", "problem": 101, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [s t]\n  (let [n (count s) m (count t)]\n    (if (= m 0) n (if (= n 0) m\n      (let [a (vec (map (fn [e] []) (range (+ m 1))))]\n        (let [a (assoc a 0 (vec (range (+ n 1))))]\n          (let [a (reduce (fn [a i] (assoc a i (assoc (a i) 0 i))) a (range (+ m 1)))]\n            (((reduce (fn [a i]\n                       (for [r a] (println r))\n                       (reduce\n                         (fn [a j] (assoc a j (assoc (a j) i\n                                                     (min (+ 1 ((a (- j 1)) i))\n                                                          (+ 1 ((a j) (- i 1)))\n                                                          (+ ((a (dec j)) (dec i))\n                                                             (if (= (nth s (dec i)) (nth t (dec j))) 0 1))))))\n                         a (range 1 (+ m 1))))\n                       a (range 1 (+ n 1))) m) n))))))))", "problem": 101, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [s t]\n  (letfn [\n    (prefix [s t]\n      (loop [s s t t p 0]\n        (if (empty? t) p\n          (if (= (first s) (first t)) \n            (recur (rest s) (rest t) (inc p))\n            p))))\n    (levi [s cs t ct m]\n      (cond \n        (>= 0 m) m\n        (< cs ct) (levi t ct s cs m)\n        (> (- cs ct) m) m\n        (== 0 ct) cs\n        :else\n          (let [c (prefix s t)]\n            (if (== 0 c)\n              (let [\n                dm (dec m)\n                d1 (levi (rest s) (dec cs) (rest t) (dec ct) dm)\n                d2 (levi (rest s) (dec cs) t ct d1)\n                d3 (levi s cs (rest t) (dec ct) d2)]\n                (inc d3))\n              (levi (drop c s) (- cs c) (drop c t) (- ct c) m)))))\n]\n  (levi s (count s) t (count t) (max (count s) (count t)))))", "problem": 101, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn levenshtein [coll1 coll2]\n  (if (or (empty? coll1) (empty? coll2))\n    (max (count coll1) (count coll2))\n    (let [v1 (vec (seq coll1))\n          v2 (vec (seq coll2))\n          m (count v1)\n          n (count v2)\n          d (to-array-2d (repeat (inc m) (repeat (inc n) 0)))]\n      (doall (for [i (range m)] (aset d i 0 i)))\n      (doall (for [i (range n)] (aset d 0 i i)))\n     (doall\n      (for [i (range 1 (inc m))\n            j (range 1 (inc n))]\n        (if (= (v1 (dec i)) (v2 (dec j)))\n          (aset d i j (aget d (dec i) (dec j)))\n          (aset d i j (min (inc (aget d (dec i) j))\n                           (inc (aget d i (dec j)))\n                           (inc (aget d (dec i) (dec j))))))))\n     (aget d m n))))", "problem": 101, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn [G V C D I R s t]\n  (let [x (V s)\n        y (V t)\n        cx (C x)\n        cy (C y)\n        d (fn [m [i j :as k]]\n            (let [l (G m [(D i) j])\n                  n (G m [i (D j)])\n                  u (G m [(D i) (D j)])\n                  r (if (= (x (D i)) (y (D j)))\n                        u\n                        (min (I l) (I n) (I u)))]\n              (update-in m k (constantly r))))\n        z (->> (for [i (R (I cx)) j (R (I cy))]\n                 (cond \n                  (= 0 j) [i]\n                  (= 0 i) [j]\n                  :else []))\n               (partition (I cy))\n               (map #(V (apply concat %)))\n               V)]\n    (G (reduce d z (for [i (R 1 (I cx)) j (R 1 (I cy))] [i j]))\n            [cx cy])))\n\nget-in vec count dec inc range", "problem": 101, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [a b]\n  (let [e [(count a) (count b)]]\n    (loop [d {[0 0] 0}]\n      (if (= (keys d) [e])\n        (d e)\n        (recur (apply merge-with min\n                (map (fn [[[i j] c]]\n                  (merge\n                    (if (= e [i j])\n                      {e (d e)}\n                      {})\n                    (if (< i (e 0))\n                      {[(inc i) j] (inc c)}\n                      {})\n                    (if (< j (e 1))\n                      {[i (inc j)] (inc c)}\n                      {})\n                    (if (and (< i (e 0))\n                             (< j (e 1)))\n                      {(map inc [i j])\n                         (if (= (nth a i)\n                                (nth b j))\n                           c\n                           (inc c))})))\n                  d)))))))", "problem": 101, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn levenshtein [s1 s2]\n  (let [f (fn [rec a b]\n            (let [[ca cb] (map count [a b])]\n              (if (some zero? [ca cb]) (max ca cb)\n                (min (inc (rec rec (pop a) b))\n                     (inc (rec rec a (pop b)))\n                     (+ (rec rec (pop a) (pop b))\n                        (if (= (peek a) (peek b)) 0 1))))))]\n    (f (memoize f) (vec s1) (vec s2))))", "problem": 101, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn [s1 s2]\n  (let [cache (atom {}),\n        lev (fn l [w1 w2]\n              (if-let [cost (@cache (list w1 w2))]\n                cost\n                (let [value (cond\n                              (empty? w1) (count w2)\n                              (empty? w2) (count w1)\n                              :else (min\n                                      (+ (if (= (first w1) (first w2)) 0 1) (l (rest w1) (rest w2)))\n                                      (inc (l (rest w1) w2))\n                                      (inc (l w1 (rest w2)))))]\n                  (swap! cache assoc (list w1 w2) value)\n                  value)))]\n\n      (lev s1 s2)))", "problem": 101, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [w1 w2]\n   (let [n (inc (count w2))\n         m (inc (count w1))\n         setx #(concat (take %1 %2) [%3] (drop (inc %1) %2))\n         setm #(concat (take %1 %3) [(setx %2 (nth %3 %1) %4)] (drop (inc %1) %3))\n         getm #(nth (nth %3 %1) %2)\n\n         M (map #(setx 0 %1 %2)\n                (cons (range n) (repeat (dec m) (repeat n 0)))\n                (range))\n         [c & cs] (for [i (range 1 m) j (range 1 n)]\n                    [i j])\n         ]\n     (loop [[i j] c cs cs M M]\n       (if i\n           (recur (first cs) (next cs)\n                  (setm i j M (if (= (nth w1 (dec i)) (nth w2 (dec j)))\n                                (getm (dec i) (dec j) M)\n                                (inc (min (getm (dec i) j M) (getm i (dec j) M) (getm (dec i) (dec j) M))))))\n         (last (last M))))))", "problem": 101, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn editdist [a b]\r\n  (letfn [(dists [ib]\r\n            (if (= ib 0)\r\n              (range)\r\n              (cons ib (next-dist-seq 1 ib (dists (dec ib)) ib)))),\r\n          (next-dist [ia ib prev up]\r\n            (cond\r\n             (> ia (count a)) 0,\r\n             (= ia 0) ib,\r\n             :e (let [d (if (= (nth a (dec ia)) (nth b (dec ib))) 0 1)]\r\n                  (min (+ d (nth prev (dec ia)))\r\n                       (+ 1 (nth prev ia))\r\n                       (+ 1 up))))),\r\n          (next-dist-seq [ia ib prev up]\r\n            (let [dist (next-dist ia ib prev up)]\r\n              (lazy-seq (cons dist (next-dist-seq (inc ia) ib prev dist)))))]\r\n    (nth (dists (count b)) (count a))))", "problem": 101, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [a b]\n  (if (= a b) 0\n  (let [la (count a) lb (count b)]\n  (loop [matrix (apply merge\n                  (concat (for [x (range (inc la))] {[x 0] x})\n                          (for [y (range (inc lb))] {[0 y] y})))\n         x 1\n         y 1]\n    (cond\n      (and (= x (inc la)) (>= y lb))\n             (matrix [(dec x) y])\n           (= x (inc la))\n             (recur matrix 1 (inc y))\n           (= (nth a (dec x)) (nth b (dec y)))\n             (recur (merge matrix {[x y] (matrix [(dec x) (dec y)])})\n                    (inc x)\n                    y)\n           :else\n             (recur (merge matrix {[x y]\n               (inc (min (matrix [(dec x) y])\n                         (matrix [x (dec y)])\n                         (matrix [(dec x) (dec y)])))}) (inc x) y)))))\n)", "problem": 101, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn checkStr[col1 col2]\r\n   (let [generCost (fn generCostList[seq1 ch2]\r\n                     (map #(if (= ch2 %) true false) seq1 )  \r\n                    ),\r\n  \t\t\t\tcompSpecList (fn compSpecList[preParam costParam initVal preVal]   \r\n\t\t\t\t\t\t\t\t\t\t     (loop[v_i_j preVal,\r\n                               v_j   initVal,\r\n                               preList preParam,\r\n                               costList costParam,\r\n                               result  []]\r\n                          (do\r\n                          ;(println (str \"result:\" result))\r\n\t\t\t\t\t\t\t\t\t\t      (if(empty? preList)\r\n\t\t\t\t\t\t\t\t\t\t         result\r\n\t\t\t\t\t\t\t\t\t\t\t\t     (let[v_i (first preList),\r\n\t\t\t\t\t\t\t\t\t\t              sign (first costList),\r\n\t\t\t\t\t\t\t\t\t\t              val (if sign \r\n                                          v_i_j \r\n                                          (+ 1 (min v_j v_i v_i_j)) )                     \r\n\t\t\t\t\t\t\t\t\t\t            ]\r\n\t\t\t\t\t\t\t\t\t\t\t\t       (do\r\n                                  ;(println (str \"i:\" v_i \" j:\" v_j \" i_j:\" v_i_j \" cost:\" sign) ) \r\n                                  (recur v_i\r\n                                         val\r\n                                         (rest preList) \r\n                                         (rest costList)\r\n                                         (conj result val) )\r\n                                )\r\n\t\t\t\t\t\t\t\t\t\t\t\t     )\r\n\t\t\t\t\t\t\t\t\t\t       )\r\n                          )\r\n\t\t\t\t\t\t\t\t\t\t    )\r\n\t\t\t\t\t\t\t\t\t\t),\r\n        seq_y  col1,\r\n        seq_x  col2,\r\n        ny (count seq_y),\r\n        nx (count seq_x),\r\n        y_0line (range 1 (+ 1 ny)),\r\n        x_0line (range 1 (+ 1 nx))\r\n                        ]\r\n       (cond (= seq_y seq_x) 0\r\n             (= (* ny nx) 0) (+ ny nx)\r\n             :else\r\n       (loop[y_line y_0line,s_x seq_x,x_line x_0line]\r\n         (do\r\n         ;(println (str \"newline:\" y_line))\r\n         (if(empty? x_line)\r\n            (peek y_line)\r\n            (let[x (first x_line),\r\n                 x_ch (first s_x)]\r\n\t\t        (recur (compSpecList y_line \r\n\t\t                             (generCost seq_y x_ch)\r\n\t\t                              x\r\n                                 (- x 1)\r\n                                )\t\t               \r\n\t\t                (rest s_x)\r\n                    (rest x_line)\r\n\t\t                )\r\n            )\r\n          )\r\n         )\r\n       )\r\n       )\r\n     \r\n     )\r\n  )", "problem": 101, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [s t]\n  (letfn [(levenshtein-step [x y dist-map]\n            (cond\n              (zero? x) y\n              (zero? y) x\n              :else (if (= (get s (dec x)) (get t (dec y)))\n                      (apply min (get dist-map [(dec x) (dec y)]) (map inc (map #(get dist-map %) (list [(dec x) y] [x (dec y)]))))\n                      (apply min (map inc (map #(get dist-map %) (list [(dec x) y] [x (dec y)] [(dec x) (dec y)])))))))]\n    (loop [dist-map {} x 0 y 0]\n      (if (or (zero? (count s)) (zero? (count t)) (and (= x (count s)) (= y (count t))))\n        (levenshtein-step (count s) (count t) dist-map)\n        (recur (assoc dist-map [x y] (levenshtein-step x y dist-map)) (mod (inc x) (inc (count s))) (+ y (quot x (count s))))))))", "problem": 101, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn [s t]\n  (letfn \n    [(lev-mod [d s t i j]                                                                                                                                                                                   \n      (if (= (nth s (dec i)) (nth t (dec j)))                                                                                                                                                                   \n        (assoc-in d [i j] (get-in d [(dec i) (dec j)]))                                                                                                                                                         \n        (let [nxt (min                                                                                                                                                                                          \n                    (inc (get-in d [(dec i) j]))                                                                                                                                                                  \n                    (inc (get-in d [i (dec j)]))                                                                                                                                                                  \n                    (inc (get-in d [(dec i) (dec j)])))]                                                                                                                                                          \n          (assoc-in d [i j] nxt)))                                                                                                                                                                              \n  )]\n   (let [m (inc (count s))                                                                                                                                                                                   \n        n (inc (count t))                                                                                                                                                                                   \n        d (vec (repeat m (vec (repeat n 0))))                                                                                                                                                               \n        d (assoc d 0 (vec (range 0 n)))                                                                                                                                                                     \n        d (loop [d d s (range 0 m)]                                                                                                                                                                         \n            (if (seq s)                                                                                                                                                                                     \n              (recur                                                                                                                                                                                        \n               (assoc-in d [(first s) 0] (first s)) (rest s))                                                                                                                                               \n              d))                                                                                                                                                                                           \n        ]                                                                                                                                                                                                   \n    (get-in (loop [d d j (range 1 n)]                                                                                                                                                                       \n       (if (seq j)                                                                                                                                                                                          \n         (recur (loop [d d i (range 1 m)]                                                                                                                                                                   \n                  (if (seq i)                                                                                                                                                                               \n                    (recur (lev-mod d s t (first i) (first j)) (rest i))                                                                                                                                    \n                    d))                                                                                                                                                                                     \n                (rest j))                                                                                                                                                                                   \n         d                                                                                                                                                                                                  \n         )) [(dec m) (dec n)]))))", "problem": 101, "user": "4f1d1299535d64f603146487"}, {"code": "(fn l [[r & s :as x] y]\n  (let [q (rest y)]\n    (cond (nil? r) (count y)\n          (empty? y) (count x)\n          (= r (first y)) (l s q)\n          r (+ 1 (min (l s y)\n                      (l x q)\n                      (l s q))))))", "problem": 101, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [at bt]\n  (let [a (vec (if (> (count at) (count bt)) at bt))\n        b (vec (if (> (count at) (count bt)) bt at))\n        n (count a)\n        m (count b)\n        ]\n    (loop [table (conj [(vec (range (inc m)))] (vector 1)) row 1 col 1]\n      (let [above (get (get table (dec row)) col)\n            left  (get (get table row) (dec col))\n            diag  (get (get table (dec row)) (dec col))\n            cost (if (not= (get a (dec row)) (get b (dec col)))\n                    1 0)]\n        (if (> row n)\n          (get (get table n) m)\n          (if (> col m)\n            (recur (conj table (vector (inc row))) (inc row) 1)\n            (recur (assoc table row (conj (get table row) (min (inc above) (inc left) (+ diag cost)))) row (inc col) )))))))", "problem": 101, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn levenstein [a b]\n            (let [n (count a)\n                  m (count b)\n                  calc (fn [d [y x]]\n                           (assoc-in d [y x]\n                                     (if (= (nth a y)\n                                            (nth b x))\n                                         (get-in d [(dec y) (dec x)] (max x y))\n                                         (->> [[-1 0] [-1 -1] [0 -1]]\n                                              (map #(get-in d (vec (map + % [y x])) (max x y)))\n                                              (apply min)\n                                              (inc)))))]\n                                              (if (or (empty? a) (empty? b))\n                                                  (max (count a) (count b))\n                                                  (->> (for [y (range n) x (range m)] [y x])\n                                                       (reduce calc {})\n                                                       (#(get-in % [(dec n) (dec m)] ))))))", "problem": 101, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn lvn-dist2 [A B]\n  (letfn [(value [calc i j]\n            (cond\n              (= 0 i) j\n              (= 0 j) i\n              (= (nth A (dec i)) (nth B (dec j))) \n                (@calc (dec i) (dec j))\n              :else \n                (inc (min \n                       (@calc (dec i) j)\n                       (@calc i (dec j)) \n                       (@calc (dec i) (dec j))))))\n\n          (index [data stride i j]\n            (force (nth data (+ (* stride i) j))))\n\n          (make-data [calc m n]\n            (let [data (apply vector (mapcat\n                      (fn [i]\n                        (map\n                          (fn [j]\n                            (delay (value calc i j)))\n                          (range n)))\n                        (range m)))]\n              (fn [i j] (index data n i j))))]\n\n    (let [a (atom nil)\n          m (count A)\n          n (count B)]\n      (reset! a (make-data a (inc m) (inc n)))\n      (force (@a m n)))))", "problem": 101, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn [seq1 seq2]\r\n  (letfn [(index-of [s x]\r\n            (remove nil? (map-indexed #(when (= x %2) %1) s)))\r\n          (commons [s1 s2]\r\n            (map (fn [[n1 n2]]\r\n                   [n1 n2 (count (take-while (fn [[x y]] (= x y))\r\n                                   (partition 2 (interleave (drop n1 s1) (drop n2 s2)))))])\r\n              (apply concat\r\n                (map-indexed (fn [n x] (map #(vector % n) (index-of s1 x)))\r\n                  (concat s2)))))\r\n          (remains [s x y]\r\n            [(take x s) (drop (+ x y) s)])\r\n          (dist [seq1 seq2]\r\n            (if (= seq1 seq2)\r\n              0\r\n              (let [[s1 s2] (if (> (count seq1) (count seq2)) [seq1 seq2] [seq2 seq1])\r\n                    cms (commons s1 s2)]\r\n                (if (empty? cms)\r\n                  (count s1)\r\n                  (apply min\r\n                    (map (fn [[n1 n2 n]]\r\n                           (let [[a b] (remains s1 n1 n) [c d] (remains s2 n2 n)]\r\n                             (+ (dist a c) (dist b d))))\r\n                      cms))))))]\r\n    (dist seq1 seq2)))", "problem": 101, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "#((fn [v s]\n    (if (empty? s)\n      (last v)\n      (recur\n       (loop [o [(inc (first v))]\n              n 1]\n         (if (< n (count v))\n           (recur\n            (conj o (min (inc (last o))\n                         (inc (nth v n))\n                         (+ (nth v (dec n))\n                            (if (= (first s)\n                                   (nth % (dec n)))\n                              0 1))))\n            (inc n))\n           o))\n       (rest s))))\n  (range (inc (count %))) %2)", "problem": 101, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn levenshtein-distance [x y]\r\n  (let\r\n    [x-len (inc (count x))\r\n     _ (println \"x len\" x-len)\r\n     y-len (inc (count y))\r\n     _ (println \"y len\" y-len)\r\n     x-vec (vec x)\r\n     _ (println \"x vec\" x-vec)\r\n     y-vec (vec y)\r\n     _ (println \"y vec\" y-vec)\r\n     start-grid (vec (for [i (range x-len)]\r\n                        (vec (for [j (range y-len)]\r\n                          (cond \r\n                            (= j 0) i\r\n                            (= i 0) j\r\n                            :else :blank)))))\r\n     _ (println \"start-grid\" start-grid)\r\n     solve (fn solve [grid i j]\r\n             (let\r\n              [_ (println \"i j\" i j)\r\n               ij-val (if (= (x-vec (dec i)) (y-vec (dec j)))\r\n                        (get-in grid [(dec i) (dec j)])\r\n                        (inc (min (get-in grid [(dec i) j])\r\n                                  (get-in grid [i (dec j)])\r\n                                  (get-in grid [(dec i) (dec j)]))))\r\n               _ (println \"ij-val\" ij-val)\r\n               next-i (if (= j (count y)) (inc i) i)\r\n               _ (println \"next-i\" next-i)\r\n               next-j (if (= j (count y)) 1 (inc j))\r\n               _ (println \"next-j\" next-j)\r\n               next-grid (assoc-in grid [i j] ij-val)\r\n               _ (println \"next-grid\" next-grid)]\r\n               (if (= [i j] [(count x) (count y)])\r\n                   ij-val\r\n                   (solve next-grid next-i next-j))))]\r\n     (cond \r\n      (= 0 (count x-vec)) (count y-vec)\r\n      (= 0 (count y-vec)) (count x-vec)\r\n      :else (solve start-grid 1 1))))", "problem": 101, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn lavenshtein-distance [a b]\n  (letfn [(coordinates [a b]\n            (for [x (range (inc (count a)))\n                  y (range (inc (count b)))]\n              [x y]))\n          (initialize [a b]\n            (->> (for [[x y] (coordinates a b)]\n                   (cond (zero? x) y\n                         (zero? y) x))\n                 (partition (inc (count b)))\n                 (map vec)\n                 vec))\n          (chr-a [n] (get a (dec n)))\n          (chr-b [n] (get b (dec n)))\n          (cost [board [x y]]\n            (if (= (chr-a x) (chr-b y))\n              (get-in board [(dec x) (dec y)])\n              (->> (for [[fx fy] [[dec dec] [dec identity] [identity dec]]]\n                     (get-in board [(fx x) (fy y)]))\n                   (apply min)\n                   inc)))\n          (update [board [x y]]\n            (if (get-in board [x y])\n              board\n              (assoc-in board [x y] (cost board [x y]))))\n          (result [board]\n            (last (last board)))]\n    (result (reduce update (initialize a b) (coordinates a b)))))", "problem": 101, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn lv [a b]\n  (if (seq a)\n    (if (seq b)\n      (if (= (first a) (first b))\n        (lv (rest a) (rest b))\n        (inc (min (lv (rest a) (rest b))\n                  (lv (rest a) b)\n                  (lv a (rest b)))))\n      (count a))\n    (count b)))", "problem": 101, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "; note: with the given test cases, it's possible to provide a less general, but fast solution, that fails for cases like \"ecats\" \"cat\".\n; below is a general solution though\n(fn [s1 s2]\n  (let\n    [l-distance (fn [s1 s2 l-distance]\n      (cond\n        (empty? s1) (count s2)\n        (empty? s2) (count s1)\n        (= (first s1) (first s2)) (l-distance (rest s1) (rest s2) l-distance)\n        (= (last s1)  (last s2))  (l-distance (butlast s1) (butlast s2) l-distance)\n        :else (+ 1\n                (min (l-distance (rest s1) s2 l-distance)\n                     (l-distance s1 (rest s2) l-distance)\n                     (l-distance (rest s1) (rest s2) l-distance)))))\n     ml-distance (memoize l-distance)]\n    (l-distance s1 s2 ml-distance)))", "problem": 101, "user": "4f725466e4b07046d9f4f030"}, {"code": "(let [mem (atom {})]\n  (fn leven [[fa & ra :as a] [fb & rb :as b]]\n    (or \n      (@mem [a b])\n      (let [res \n        (cond (nil? a) (count b)\n              (nil? b) (count a)\n              (= fa fb) (leven ra rb)\n              :else (+ 1 \n                      (min (leven ra rb)\n                           (leven a rb)\n                           (leven ra b))))]\n        (swap! mem assoc [a b] res)\n        res))))", "problem": 101, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [s d]\n  (loop [a [[0 s d]]]\n    (let [m (keep (fn [[l x y]] (if (= x y) l)) a)]\n      (if (not (empty? m))\n          (apply min m)\n          (recur\n            (mapcat\n              (fn [[l [sf & sr :as s] [df & dr :as d]]]\n                (if (= sf df)\n                    (vector [l sr dr])\n                    (vector [(inc l) s dr] [(inc l) sr d] [(inc l) sr dr])))\n              a))))))", "problem": 101, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [& w]\n  (let [[na nb] (map #(vec (concat [nil] %)) w)]\n    (loop \n      [ r 1 \n        prev (range (count na))]\n      (if (= r (count nb))\n        (last prev)\n        (let \n          [ cells \n              (map list \n                (partition 2 1 \n                  (conj prev (first prev))) \n                (map #(= (nb r) %) na))\n            next-row \n              (next \n                (reduce \n                  (fn [l [p e]] \n                    (conj l \n                      (if e \n                        (first p) \n                        (inc (apply min (last l) p)))))\n                  [(first prev)] \n                  cells))]\n          (recur (inc r) next-row))))))", "problem": 101, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn ld [s t]\n  (let [w (inc (count s))\n        h (inc (count t))\n        M (make-array Integer/TYPE h w)\n        get-2d (fn [m x y] \n                 (-> m (aget y) (aget x)))\n        set-2d (fn [m x y v]\n                 (-> m (aget y) (aset x v)))]\n       (doall\n        (for [i (range 1 w)]\n          (set-2d M i 0 i)))\n       (doall\n        (for [j (range 1 h)]\n          (set-2d M 0 j j)))\n       (doall (for [i (range 1 w)\n                    j (range 1 h)]\n                (set-2d M i j \n                        (if (= (nth s (dec i)) (nth t (dec j)))\n                          (get-2d M (dec i) (dec j))\n                          (min \n                           (inc (get-2d M (dec i) j))\n                           (inc (get-2d M i (dec j)))\n                           (inc (get-2d M (dec i) (dec j))))))))\n       (get-2d M (count s) (count t))))", "problem": 101, "user": "4faafccde4b081705acca209"}, {"code": "(fn ld [s1 s2]\r\n    (let [d (atom {})\r\n          return (fn [s1 s2 r] (swap! d #(assoc % [s1 s2] r)) r)\r\n          ld (fn ld [s1 s2]\r\n                (if-let [result (@d [s1 s2])]\r\n                    result\r\n                    (cond\r\n                      (empty? s1) (return s1 s2 (count s2))\r\n                      (empty? s2) (return s1 s2 (count s1))\r\n                      :else (min (inc (return (rest s1) s2 (ld (rest s1) s2)))\r\n                                 (inc (return s1 (rest s2) (ld s1 (rest s2))))\r\n                                 (+ (return (rest s1) (rest s2) (ld (rest s1) (rest s2)))\r\n                                    (if (= (first s1) (first s2))\r\n                                        0\r\n                                        1))))))]\r\n      (ld s1 s2)))", "problem": 101, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn q101 [source target]\n  (letfn [(f [coll s]\n             (letfn [(f2 [v [[a b] t]] (conj v (if (= s t) a (inc (min a b (last v))))))]\n                (->>\n                  (map list coll target)\n                  (reduce f2 [(inc (ffirst coll))])\n                  (partition 2 1))))]\n    (if (empty? target) (count source)     \n      (->>     \n\t      (reduce f (partition 2 1 (range (inc (count target)))) source)\n\t      last\n\t      last))))", "problem": 101, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [s t]\n  (let [aux (fn [sv tv]\n              (loop [d (-> sv count inc range vec) i 1]\n  \t(if (> i (count tv))\n                  (last d)\n                  (recur\n                   (loop [nd [i] j 1]\n                     (cond (> j (count sv)) nd\n                           (= (sv (dec j)) (tv (dec i)))\n                           (recur (conj nd (d (dec j))) (inc j))\n                           true\n                           (recur (conj nd (min (inc (last nd))\n                                                (inc (d j))\n                                                (inc (d (dec j)))))\n                                  (inc j))))\n                   (inc i)))))]\n    (aux (vec s) (vec t))))", "problem": 101, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn df [a b]\r\n    (let [alen (count a) blen (count b)]\r\n      (cond (= alen blen) (count (filter true? (map not= a b)))\r\n            (> alen blen) (df b a)\r\n            ; from here alen < blen\r\n            (= blen 0) 0\r\n            :else (min \r\n                    (+ 1 (df a (rest b))) \r\n                    (+ (if (= (first a) (first b)) 0 1) (df (rest a) (rest b)))))\r\n      ))", "problem": 101, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn levenshtein-distance [s1 s2]\n  (let [m (count s1)\n        n (count s2)\n        distance-matrix (make-array Integer/TYPE (inc m) (inc n))]\n    (dotimes [i m]\n      (aset-int distance-matrix (inc i) 0 (inc i)))\n    (dotimes [j n]\n      (aset-int distance-matrix 0 (inc j) (inc j)))\n    (dotimes [j n]\n      (dotimes [i m]\n        (aset-int distance-matrix (inc i) (inc j)\n                  (if (= (nth s1 i) (nth s2 j))\n                    (aget distance-matrix i j)\n                    (min (inc (aget distance-matrix i (inc j)))\n                         (inc (aget distance-matrix (inc i) j))\n                         (inc (aget distance-matrix i j)))))))\n    (aget distance-matrix m n)))", "problem": 101, "user": "4ff355a1e4b0678c553fc34d"}, {"code": ";; The Wikipedia page gives an O(m*n) dynamic programming algorithm\n;; for this problem.  This is just a straightforward implementation of\n;; that algorithm.\n\n(fn [s1 s2]\n  (let [s1 (vec s1) n1 (count s1)\n        s2 (vec s2) n2 (count s2)\n        dists (reduce (fn [prev-row j]\n                        (reduce (fn [next-row i]\n                                  (conj next-row\n                                        (min (inc (next-row (dec i)))\n                                             (inc (prev-row i))\n                                             (+ (prev-row (dec i))\n                                                (if (not= (s1 (dec i)) (s2 (dec j)))\n                                                  1 0)))))\n                                [j]\n                                (range 1 (inc n1))))\n                      (vec (range 0 (inc n1)))\n                      (range 1 (inc n2)))]\n    (dists n1)))", "problem": 101, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(letfn [(iters [n f start]\r\n          (take n (map second\r\n                       (iterate f start))))]\r\n (fn [s t]\r\n   (let [m (inc (count s)), n (inc (count t))\r\n         first-row (vec (range m))\r\n         matrix (iters n (fn [[j row]]\r\n                           [(inc j)\r\n                            (vec (iters m (fn [[i col]]\r\n                                            [(inc i)\r\n                                             (if (= (nth s i)\r\n                                                    (nth t j))\r\n                                               (get row i)\r\n                                               (inc (min (get row i)\r\n                                                         (get row (inc i))\r\n                                                         col)))])\r\n                                        [0 (inc j)]))])\r\n                       [0 first-row])]\r\n     (last (last matrix)))))", "problem": 101, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn ld [ b a]\r\n  (let [il (fn [[co & more] a n pw]\r\n             (loop [ws a\r\n                       j  0\r\n                    sw [n]]\r\n\r\n               \r\n                  (if ( empty? ws)\r\n                    sw\r\n                    (do ;(println (first ws) co)\r\n                        (recur (rest ws) (inc j) (conj sw (if (= co (first ws))\r\n                                                            (do ;(println \"*\" co (first (subvec pw j (inc j))) pw sw)\r\n                                                                (first (subvec pw j (inc j))))\r\n                                                            (do ;(println co (first ws) sw (subvec pw j (+ j 2)))\r\n                                                              (apply min (map inc (concat  [ (last sw)] (subvec pw j (+ j 2)) )))) ))))\r\n                    )\r\n                  )             \r\n             )\r\n        ]\r\n    (loop [n  1\r\n           y  b\r\n           pw (apply vector  (range (inc (count  a))))\r\n           sw (il y a n pw)]\r\n      ;(println (first y) pw sw)\r\n      (if (empty? y)\r\n        (last pw)\r\n         (recur (inc n) (rest y) sw (il (rest y) a (inc n) sw) ))\r\n      ))\r\n  )", "problem": 101, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn [a b]\n  (let [iO (fn [s e p] (let [r (.indexOf (drop p s) e)]\n                         (if (<= 0 r) (+ p r) -1)))\n        [mn mx] (map #(apply vector %) (sort-by count [a b]))]\n    (count\n      (filter #(< (second %) 0)\n              (first \n                (reduce \n                  #(let [p (second %)\n                         x (iO mn %2 p)]\n                     [(conj (first %) [%2 x]) (if (<= 0 x) (inc x) p)])\n                  [[] 0] mx))))))", "problem": 101, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [a b]\n    (letfn [(create-queue [a b]\n                          (reduce \n                            (fn [acc item] (assoc acc item #{}))\n                            {} \n                            (range (inc (max (count a) (count b))))))\n            (add-to-queue [queue dist pair]\n                          (update-in queue [dist] conj pair))\n            (delete-first [queue dist]\n                          (let [min-key (apply min (keys queue)), \n                                min-level (into #{} (drop 1 (queue dist)))]\n                            (if (zero? (count min-level))\n                              (dissoc queue dist)\n                              (assoc queue dist min-level))\n                            ))\n            ]\n      (loop [queue (add-to-queue (create-queue a b) 0 [a b])]\n        (let [dist (apply min (keys queue)), [w1 w2] (first (queue dist))]\n          (if (= w1 w2) \n            dist\n            (let [[f1 & r1] w1, [f2 & r2] w2, \n                  new-queue (-> (delete-first queue dist)\n                              (add-to-queue ,,, (if (= f1 f2) dist (inc dist)) [r1 r2])\n                              (add-to-queue ,,, (inc dist) [r1 w2])\n                              (add-to-queue ,,, (inc dist) [w1 r2])\n                              )]\n              (recur new-queue)) ))\n        )))", "problem": 101, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [x y]\n  (last\n   (reduce\n    (fn [prev j]\n      (reduce\n       (fn [curr i]\n   (conj curr\n\t       (+ 1 (min (nth prev (+ i 1))\n\t\t\t (nth curr i)\n\t\t\t (- (nth prev i)\n\t\t\t    (if (= (nth x i) (nth y j)) 1 0))))))\n       [(+ j 1)] (range (count x))))\n    (range (+ 1 (count x)))\n    (range (count y)))))", "problem": 101, "user": "502b0804e4b063e52107afad"}, {"code": "; https://secure.wikimedia.org/wikipedia/en/wiki/Levenshtein_distance#Computing_Levenshtein_distance\n(fn [a b]\n  (last (reduce (fn [row j]\n                  (reduce (fn [col i]\n                            (conj col (if (= (nth a i) (nth b j))\n                                        (nth row i)\n                                        (inc (min (last col) ; deletion\n                                                  (nth row i) ; insertion\n                                                  (nth row (inc i))))))) ; substitution\n                          [(inc j)]\n                          (range (count a))))\n                (range (inc (count a)))\n                (range (count b)))))", "problem": 101, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [a b]\n    (let [m (count a) n (count b)]\n      (((reduce\n         (fn [r [j i]] (assoc-in r [j i]\n                                (cond (= 0 j) i\n                                      (= 0 i) j\n                                      :else  (let [k (- j 1) l (- i 1)]\n                                               (if (= (nth a k) (nth b l))\n                                                 ((r k) l)\n                                                 (inc (apply min (map #(get-in r %)\n                                                                      [[k l] [j l] [k i]]))))))))\n         {}\n         (for [j (range (+ m 1)) i (range (+ n 1))] [j i])) m) n)))", "problem": 101, "user": "4ee88bfb535d93acb0a66881"}, {"code": "#(last (reduce (fn [r j]\r\n  (reductions\r\n    (fn [acc i]\r\n      (if (= (nth %2 j) (nth % i)) (nth r i)\r\n        (inc (min acc (nth r (inc i)) (nth r i)))))\r\n    (inc j)\r\n    (range (count %))))\r\n  (range (inc (count %)))\r\n  (range (count %2))))", "problem": 101, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [s t]\n  (let [ls (count s)\n        lt (count t)\n        dump (fn [d] (dotimes [i (inc ls)] (println) (dotimes [j (inc lt)] (print (d [i j])))) (println))\n        =? (fn [[i j]] (and (pos? (* i j)) (= (get s (dec i)) (get t (dec j)))))\n        f (fn [i j] (cond\n                      (and (zero? i) (zero? j)) 0\n                      (zero? i) j\n                      (zero? j) i\n                      :else \" \"))\n        d (into {} (for [i (range (inc ls)) j (range (inc lt))] [[i j] (f i j)]))\n        d= (fn [dx [i j]] (update-in dx [[i j]] (fn [_] (dx [(dec i) (dec j)]))))\n        d+ (fn [dx [i j]] (update-in dx [[i j]] (fn [_] (inc (min (or (dx [(dec i) j]) 0)\n                                                                  (or (dx [i (dec j)]) 0)\n                                                                  (or (dx [(dec i) (dec j)]) 0))))))\n        dn (fn [dx k] ((if (=? k) d= d+) dx k))]\n    ((loop [i 1 di d]\n       (if (> i ls)\n         di\n         (recur (inc i) (loop [j 1 dj di]\n                          #_(dump dj)\n                          (if (> j lt)\n                            dj\n                            (recur (inc j) (dn dj [i j])))))))\n       [ls lt])))", "problem": 101, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [x y]\n    \"Breadth-first search prioritized by current edit cost\"\n    (loop [nodes (sorted-set-by ;; using a sorted set as a heap\n                  (fn [[s0 x0 y0] [s1 x1 y1]]\n                    (compare [s0 (count x0) (count y0)] [s1 (count x1) (count y1)]))\n                  [0 x y])\n           worst-case-cost (+ (count x) (count y)) ; worst case = delete all x, and add all y\n           seen #{}]\n      (let [[score x y :as f] (first nodes)\n            more (disj nodes f)\n            seen-with-succ (conj seen [x y])]\n        (cond\n          (not f) worst-case-cost\n          (>= score worst-case-cost) worst-case-cost\n          (seen [x y]) (recur more worst-case-cost seen-with-succ)\n          (empty? x) (recur more (min worst-case-cost (+ score (count y))) seen-with-succ)\n          (empty? y) (recur more (min worst-case-cost (+ score (count x))) seen-with-succ)\n          :else (let [[a & rx] x\n                      [b & ry] y\n                      matchcost (if (= a b) 0 1)\n                      more-with-succ (into more\n                                           [[ (inc score) x ry]\n                                            [ (inc score) rx y]\n                                            [ (+ score matchcost) rx ry]])\n                    ]\n                (recur more-with-succ worst-case-cost seen-with-succ)\n      ))\n        )))", "problem": 101, "user": "502bb7c0e4b0194ad32ea1a3"}, {"code": "(fn lev [s t]\n    (cond\n      (empty? s) (count t)\n      (empty? t) (count s)\n      :else\n        (let [ns (rest s)\n              nt (rest t)]\n          (if (= (first s) (first t))\n            (lev ns nt)\n            (min\n              (inc (lev s nt))\n              (inc (lev ns t))\n              (inc (lev ns nt)))))))", "problem": 101, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(letfn [(f [s x prev i]\n  (loop [row [(inc i)] j 1]\n    (if (> j (count s)) row\n    (recur (conj row \n                 (min \n                         (inc (nth prev j)) \n                         (inc (last row))\n                         (+ (nth prev (dec j))\n                            (if (= (nth s (dec j)) x) 0 1))\n                       )\n                 ) (inc j)))\n    ))]\n  \n  (fn lev [s t] \n    (cond (empty? s) (count t)\n          (empty? t) (count s)\n          :else\n    (loop [ prev (range 0 (inc (count s))) i 1]\n      (if (> i (count t)) (last prev)\n        (recur (f s (nth t (dec i)) prev i) (inc i))))))\n)", "problem": 101, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [r a g rn cn rp x y]\n  (let [n (+ 1 (cn x))\n        m (+ 1 (cn y))\n        M (vec (rp n (vec (rp m 0))))\n        M (r #(a %1 [%2 0] %2) M (rn n))\n        M (r #(a %1 [0 %2] %2) M (rn m))\n        d #(if (= (nth x (- %1 1)) (nth y (- %2 1))) 0 1)\n        pos  (for [i (rn 1 n) j (rn 1 m)] [i j])\n        f    (fn [M [i j]]\n               (a M [i j] \n                         (min (+ 1 (g M [(- i 1) j]))\n                              (+ 1 (g M [i (- j 1)]))\n                              (+ (d i j) (g M [(- i 1) (- j 1)])))))\n        M    (r f M pos)]\n  (g M [(- n 1) (- m 1)]))) reduce assoc-in get-in range count repeat", "problem": 101, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn edit-dist [a b]\n  (cond (not b) (count a) (not a) (count b) \n        :else (let [ra (next a) rb (next b)]\n(if (= (first a) (first b)) (edit-dist ra rb) \n  (+ 1 (min (edit-dist ra rb) (edit-dist ra b) (edit-dist a rb)))))))", "problem": 101, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn ld [a b]\r\n  (let \r\n    [ldm (fn [c d m]\r\n           \r\n           (let\r\n             [len-c (count c)\r\n              len-d (count d)              \r\n              ]\r\n             \r\n             (cond (= 0 len-c) len-d\r\n                   (= 0 len-d) len-c\r\n                   :else\r\n                   (let [cost (if (= (last c)\r\n                                     (last d))\r\n                                0 1)\r\n                         ]\r\n                     ;(println \"map: \" m)\r\n                     ;(println \"[c d]: \" [c d])\r\n                     ;(println \"min: \"\r\n                     ;  (+ 1 (m [(drop-last c) d]))\r\n                     ;  (+ 1 (m [c (drop-last d)]))\r\n                     ;  (+ cost\r\n                     ;     (m [(drop-last c) (drop-last d)])))\r\n                     (min\r\n                       \r\n                       (+ 1 (m [(drop-last c) d]))\r\n                       (+ 1 (m [c (drop-last d)]))\r\n                       (+ cost\r\n                          (m [(drop-last c) (drop-last d)])))))))\r\n     fr (fn [m [c d]]\r\n          ;(println \"fr: \" c \", \" d)\r\n          (conj m [[c d] (ldm c d m)]))\r\n     \r\n     pr (fn pr [p q]\r\n          (apply concat (for [n (range (inc p))]\r\n                          (let [m (min n q)]\r\n                            (concat \r\n                              (for [x (range n)]\r\n                                [x m])\r\n                              (for [y (range m)]\r\n                                [n y])\r\n                              [[n m]])))))\r\n     [c d] (if (< (count a) (count b)) [b a] [a b])\r\n     mm (let \r\n          [\r\n           \r\n           len-c (count c)\r\n           len-d (count d)\r\n           mpairs (map (fn [[x y]]\r\n                         [(take x c) (take y d)])\r\n                       (pr len-c len-d))\r\n           ]\r\n          mpairs)\r\n     ]\r\n    ((reduce fr {} mm) (replace {nil ()} [(seq c) (seq d)]))\r\n    ;(reduce fr {} mm)\r\n    ))", "problem": 101, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn lev-dist [ a b]\n    (letfn [\n        (  ld [ld-memo a b]\n               (cond\n                 (empty? a) (count b)\n                 (empty? b) (count a)\n                 :default (min\n                            (if (= (last a) (last b)) \n                              (ld-memo ld-memo (butlast a) (butlast b))  \n                              (inc (ld-memo ld-memo (butlast a) (butlast b))))\n                            (inc (ld-memo ld-memo (butlast a) b )) \n                            (inc (ld-memo ld-memo a (butlast b)))\n                            )\n                 ))\n        ] (let [ ld-memo (memoize ld) ] \n            (ld-memo ld-memo a b)\n        )))", "problem": 101, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [s t] (let [[cs ct] (map count [s t])\n                 [ds dt] (map inc [cs ct])\n                 init (into (zipmap (for [ i (range dt)] [i 0]) (range dt))\n                            (zipmap (for [ j (range ds)] [0 j]) (range ds)))\n                 f (fn [m [i j]]\n                     (assoc m [i j]\n                            (min (inc (m [(dec i) j]))\n                                 (inc (m [i (dec j)]))\n                                 (+ (m [(dec i) (dec j)])\n                                    (if (= (get t (dec i)) (get s (dec j))) 0 1)))))\n                 d (reduce f init \n                           (for [i (range 1 dt) j (range 1 ds)] [i j])\n                           )\n                 ]\n             (d [ct cs])))", "problem": 101, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn d [s t]\n  (cond (empty? s) (count t)\n        (empty? t) (count s)\n        (= (first s) (first t)) (d (rest s) (rest t))\n        :else (inc (min (d (rest s) (rest t))\n                        (d s (rest t))\n                        (d (rest s) t)))))", "problem": 101, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn levenshtein [s1 s2]\n  (letfn [(fix [f]\n            (let [p (promise)]\n              (deliver p (f p))\n              @p))\n          (memo-fix [f]\n            (fix (fn [self] (memoize (partial f self)))))\n          (iter [self s1 s2]\n            (cond\n             (empty? s1) (count s2)\n             (empty? s2) (count s1)\n             :else       (min (inc (@self (drop 1 s1) s2))\n                              (inc (@self s1 (drop 1 s2)))\n                              (+ (@self (drop 1 s1) (drop 1 s2))\n                                 (if (= (nth s1 0) (nth s2 0)) 0 1)))))]\n    (let [miter (memo-fix iter)]\n      (miter s1 s2))))", "problem": 101, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn lev [s t]\n  (cond \n    (empty? s) (count t)\n    (empty? t) (count s)\n    :else \n      (let [ts (rest t)\n            ss (rest s)]\n        (if (= (first s) (first t))\n          (lev ss ts)\n          (min \n              (inc (lev ss t))\n              (inc (lev s ts))\n              (inc (lev ss ts)))))))", "problem": 101, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn foo [step x y] (if (empty? x) (+ step (count y)) \r\n  (if (empty? y) (+ step (count x)) \r\n\t\t(if (= (first x) (first y)) (foo step (rest x) (rest y) ) \r\n\t\t\t(min (foo (+ 1 step) (rest x) (rest y)) (foo (+ 1 step) (rest x) y) (foo (+ 1 step) x (rest y))) ) \r\n\t)))0", "problem": 101, "user": "4f4bd422e4b03ad3f0c10c7e"}, {"code": "(fn [a b]\n    (some second\n          (iterate (fn [[coll _]]\n                     (let [[d [s1 s2] :as x] (apply min-key first coll)\n                           [a b] ((juxt #(map first %) #(remove nil? (map second %)))\n                                  (drop-while #(= (first %) (second %)) (map vector s1 (concat s2 (repeat nil)))))\n                           new (if (empty? b)\n                                 [[(+ d (count a)) [b b]]])\n                           new (or new (concat [[(inc d) [(next a) (next b)]]]\n                                               (if (> (count a) (count b))\n                                                 [[(inc d) [(next a) b]]])))]\n                       (if (= s1 s2)\n                         [(disj coll x) d]\n                         [(into (disj coll x) new) nil])))\n                   [#{[0 (if (> (count a) (count b)) [a b] [b a])]} nil])))", "problem": 101, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn leven [x y] \n  (let [l (memoize (fn [f x y]\n\t(cond (empty? x) (count y)\n\t\t  (empty? y) (count x)\n\t\t   :else (min (+ (f f (rest x) y) 1)\n\t\t\t\t\t  (+ (f f x (rest y)) 1)\n\t\t\t\t\t  (+ (f f (rest x) (rest y)) (if (= (first x) (first y)) 0 1))\n\t\t\t\t  )\n\t)\n\t))\n\tmagic (partial l l)]\n\t(magic x y)\n\t)\n)", "problem": 101, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn levenshtein [s t]\n  (cond\n\t\t(empty? s) (count t)\n\t\t(empty? t) (count s)\n\t\t(= s t) 0\n\t\t:else\n\t\t\t(letfn\n\t\t\t\t[\n\t\t\t\t\t(new-row [prev-row row-elem t]\n\t\t\t\t\t\t(reduce\n\t\t\t\t\t\t\t(fn [row [d-1 d e]] (conj row (if (= row-elem e) d-1 (inc (min (peek row) d d-1)))))\n\t\t\t\t\t\t\t[(inc (first prev-row))]\n\t\t\t\t\t\t\t(map vector prev-row (rest prev-row) t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t]\n\t\t\t\t(peek\n\t\t\t\t\t(reduce\n\t\t\t\t\t\t(fn [prev-row s-elem] (new-row prev-row s-elem t))\n\t\t\t\t\t\t(range (inc (count t)))\n\t\t\t\t\t\ts\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t)\n)", "problem": 101, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn lev [[ha & ra :as a] [hb & rb :as b]]\n  (cond\n    (> (count a) (count b)) (lev b a)\n    (nil? ha) (count b)\n    (= ha hb) (lev ra rb)\n    :else\n      (inc\n        (min (lev ra rb) (lev a rb)))))", "problem": 101, "user": "504c8165e4b09724c857af31"}, {"code": "(fn levenshtein-distance [s t]\n  (letfn [(cost  [i j] (if (= (nth s (dec i)) (nth t (dec j))) 0 1))\n          (lev [f i j]\n            (if (or (= i 0) (= j 0))\n              (max i j)\n              (min (inc (f f (dec i) j))\n                   (inc (f f i       (dec j)))\n                   (+   (f f (dec i) (dec j)) (cost i j)))))]\n    (lev (memoize lev) (count s) (count t))))", "problem": 101, "user": "50586354e4b06522596eba78"}, {"code": "(fn distance [str1 str2]\n  (let [len1 (count str1)\n        len2 (count str2)\n        arr (make-array Long (inc len1) (inc len2))]\n    (dotimes [i (inc len1)]\n      (dotimes [j (inc len2)]\n        (aset arr i j 0)))\n    (dotimes [i (inc len1)]\n      (aset arr i 0 i))\n    (dotimes [j (inc len2)]\n      (aset arr 0 j j))\n    (doseq [i (range 1 (inc len1))]\n      (doseq [j (range 1 (inc len2))]\n        (aset\n         arr i j\n         (min (inc (aget arr (dec i) j))\n              (inc (aget arr i (dec j)))\n              (+ (if (= (nth str1 (dec i)) (nth str2 (dec j))) 0 1)\n                 (aget arr (dec i) (dec j)))))))\n    (aget arr len1 len2)))", "problem": 101, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [p1 p2]\n  (let [c1 (count p1) c2 (count p2)\n        [n s1 s2] (if (< c1 c2) [(- c2 c1) p1 p2] [(- c1 c2) p2 p1])\n        omit (fn [n s] (concat (take n s) (drop (inc n) s)))\n        f (fn [s] (mapcat #(map-indexed (fn [a b] (omit a %)) %) s))\n        g (fn [s n] (distinct (nth (iterate f [(seq s)]) n)))\n        c (fn [s1 s2] (count (filter false? (map #(= % %2) s1 s2))))]\n  (+ n (reduce #(if (< % %2) % %2) (count s2) (map #(c s1 %) (g s2 n))))))", "problem": 101, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [sa sb] \r\n  (letfn [\r\n    (levi [sa ca sb cb]\r\n      (if (< cb ca) (recur sb cb sa ca)\r\n        (if (zero? ca) cb\r\n          (let [dca (dec ca) dcb (dec cb)\r\n              [a & xa] sa [b & xb] sb]\r\n            (if (= a b) \r\n              (recur xa dca xb dcb)\r\n              (inc (min\r\n                (levi xa dca xb dcb)\r\n                (levi sa ca xb dcb)\r\n                (levi xa dca sb cb))))))))\r\n    (leviopt [sa ca sb cb [llast last] tobeat]\r\n      (if (nil? tobeat) \r\n        (recur sa ca sb cb [0 0] (max ca cb))\r\n        (if (zero? tobeat) 0\r\n          (if (= [-1, 1] (sort [last llast])) tobeat\r\n            (if (< cb ca) (recur sb cb sa ca [(- llast) (- last)] tobeat)\r\n              (if (zero? ca) cb\r\n                (let [dca (dec ca) dcb (dec cb)\r\n                    [a & xa] sa [b & xb] sb\r\n                      ]\r\n                  (if (= a b) \r\n                    (recur xa dca xb dcb [last 0] tobeat)\r\n                    (if (>= (- cb ca) tobeat) tobeat\r\n                      (->> tobeat\r\n                        (dec)\r\n                        (leviopt xa dca xb dcb [last last])\r\n                        (leviopt xa dca sb cb [last -1])\r\n                        (leviopt sa ca xb dcb [last 1])\r\n                        (inc)))))))))))\r\n        ]\r\n    (leviopt sa (count sa) sb (count sb) [0 0] nil))\r\n)", "problem": 101, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [a b]\n (letfn [(lev [mem-lev a b]\n           (cond\n            (empty? a) (count b)\n            (empty? b) (count a)\n            :else (min\n                   (inc (mem-lev mem-lev (rest a) b))\n                   (inc (mem-lev mem-lev a (rest b)))\n                   (+ (mem-lev mem-lev (rest a) (rest b))\n                      (if (= (first a) (first b)) 0 1)))))]\n   (lev (memoize lev) a b)))", "problem": 101, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn f [a b]                    \n  (cond (empty? a) (count b)\n        (empty? b) (count a)\n        (= (first a) (first b)) (recur (rest a) (rest b))\n        :else (inc (min (f (rest a) b) (f a (rest b)) (f (rest a) (rest b))))))", "problem": 101, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [s1 s2]\n  (let [d (memoize (fn [i j dst]\n    (cond\n      (= 0 i) j\n      (= 0 j) i\n      :else (if (= (get s1 (- i 1)) (get s2 (- j 1)))\n        (dst (- i 1) (- j 1) dst)\n        (+ 1 (reduce min \n          [(dst (- i 1) j dst)\n           (dst i (- j 1) dst)\n           (dst (- i 1) (- j 1) dst)]))))))]\n    (d (count s1) (count s2) d)))", "problem": 101, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "#(last \n   (reduce \n     (fn [[x & q] c]\n       (reductions\n         (fn [z [k x y]]\n           (min (inc z) (inc y) (+ x (if (= k c) 0 1))))\n         (inc x) (map list % (cons x q) q)))\n     (range (inc (count %))) %2))", "problem": 101, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [ s t ] (letfn [(ld [ s t f] (cond \n                                     (zero? (count s)) (count t)\n                                     (zero? (count t)) (count s)\n                                     :else (min \n                                             (+ 1 (f (rest s) t f))\n                                             (+ 1 (f s (rest t) f))\n                                             (+ (f (rest s) (rest t) f)\n                                                (if (= (first s) (first t)) 0 1))\n                                           )))\n                     \n                    ]\n                 (let [mld (memoize ld)] (mld s t mld))\n              ))", "problem": 101, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn solve-it [s1 s2]\n  (letfn [(insert-each [e ls]\n            (let [ls' (map #(split-at % ls) (range (inc (count ls))))]\n              (map (fn [[x y]] (concat x [e] y)) ls')))\n          (insert-eachs [n e ls]\n            (if (zero? n)\n              ls\n              (let [ks (mapcat #(insert-each e %) ls)]\n                (insert-eachs (dec n) e ks))))\n          (diff [s1 s2]\n            (loop [an 0 s1 s1 s2 s2]\n              (if (empty? s1)\n                an\n                (let [f1 (first s1)\n                      f2 (first s2)]\n                  (if (or (= f1 f2) (= f1 \\_) (= f2 \\_))\n                    (recur an (rest s1) (rest s2))\n                    (recur (inc an) (rest s1) (rest s2)))))))]\n    (let [s1-len (count s1)\n          s2-len (count s2)\n          [ss1 ss2] (if (< s1-len s2-len)\n                      [s1 s2]\n                      [s2 s1])\n          dif (int (Math/abs (- s1-len s2-len)))]\n      (+ dif (apply min (map (fn [s] (diff s ss2)) (insert-eachs dif \\_ [ss1])))))))", "problem": 101, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn [s t]\n    (let [m (count s)\n          n (count t)\n          a (to-array-2d (for [i (range (inc m))\n                               ]\n                           (repeat (inc n) nil)))\n          lookup (fn [i j]\n                   (aget (aget a i) j))\n          set (fn [i j val]\n                (aset (aget a i) j val))\n          ]\n      (do (doseq [i (range (inc m))]\n            (set i 0 i))\n          (doseq [j (range (inc n))]\n            (set 0 j j))\n          (doseq [j (range 1 (inc n))\n                  i (range 1 (inc m))\n                  ]\n            (if (= (nth s (dec i))\n                   (nth t (dec j)))\n              (set i j (lookup (dec i) (dec j)))\n              (set i j (+ 1 (min (lookup (dec i) j)\n                                 (lookup i (dec j))\n                                 (lookup (dec i) (dec j)))))))\n          (lookup m n))))", "problem": 101, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn __ [s1 s2]\n  (let [memo (atom {})]\n    (letfn [(leven-memo [s1 s2]\n              (if-let [c (find @memo [s1 s2])]\n                (val c)\n                (let [c (leven s1 s2)]\n                      (swap! memo assoc [s1 s2] c)\n                      c)))\n            (leven [s1 s2]\n              (cond (empty? s1) (count s2)\n                    (empty? s2) (count s1)\n                    (= (first s1) (first s2))\n                          (leven-memo (rest s1) (rest s2))\n                    :else (inc \n                           (min (leven-memo s1 (rest s2))\n                                (leven-memo (rest s1) s2)\n                                (leven-memo (rest s1) (rest s2))))))]\n      (leven s1 s2))))", "problem": 101, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn levin-dist [s t]\n  (letfn\n    [(min-dist [s t ct]\n      (cond\n        (= (count s) 0) (+ ct (count t))\n        (= (count t) 0) (+ ct (count s))\n        (= (first s) (first t)) (min-dist (rest t) (rest s) ct)\n        :else (min (min-dist s (rest t) (inc ct))\n             (min-dist t (rest s) (inc ct))\n             (min-dist (rest s) (rest t) (inc ct)))))]\n    (min-dist (vec s) (vec t) 0)))", "problem": 101, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(let [make-key (comp set vector)\n      jot-down #(assoc %1 (make-key %2 %3) %4)]\n  (fn lev-memoed\n    ([memo word1 word2]\n       (if (memo (make-key word1 word2))\n         memo\n         (cond\n          (= (vec word1) (vec word2)) (jot-down memo word1 word2 0)\n          (empty? word1) (jot-down memo word1 word2 (count word2))\n          (empty? word2) (jot-down memo word1 word2 (count word1))\n          :else\n          (let [current-cost (if (= ((vec word1) 0) ((vec word2) 0)) 0 1)\n                memo (-> memo\n                         (lev-memoed word1 (rest word2))\n                         (lev-memoed (rest word1) word2)\n                         (lev-memoed (rest word1) (rest word2)))\n                best-cost (min\n                           (inc (memo (make-key word1 (rest word2))))\n                           (inc (memo (make-key (rest word1) word2)))\n                           (+ current-cost (memo (make-key (rest word1) (rest word2)))))]\n            (jot-down memo word1 word2 best-cost)))))\n    ([word1 word2]  ( (lev-memoed {} word1 word2) (make-key word1 word2)) )))", "problem": 101, "user": "4e6f578c535d5021c1a8961b"}, {"code": "#(letfn\n    [(e [a b p t x]\n       (if (= a b)\n         (p (- x 1))\n         (+ 1 (min\n               (p (- x 1))\n               (p x)\n               (last t)))))\n     (n [a s p t]\n       (let [b (first s)\n             x (count t)]\n         (if (= (count t) (count p))\n           t\n           (recur a (rest s) p (conj t (e a b p t x))))))\n     \n     (l\n       ([A B]\n          (if (= A B) 0\n           (let [r (vec (map first (map vector (iterate inc 1) B)))]\n             (l 1 (vec (cons 0 r)) A B))))\n       ([r p A B]\n          (let [N (n (first A) B p (vector r))\n                M (rest A)]\n            (if (empty? M)\n              (last N)\n              (recur (inc r) N M B)))))]\n   (l %1 %2))", "problem": 101, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(let [f (fn [f [af & ar :as a] [bf & br :as b]]\n            (if (and (seq a) (seq b))\n              (if (= af bf)\n                (f f ar br)\n                (inc (min (f f a br) (f f ar b) (f f ar br))))\n              (+ (count a) (count b))))]\n    (fn [a b] (f (memoize f) a b)))", "problem": 101, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn ldist \n  ([[fa & ra :as a] [fb & rb :as b] cache]\n   (let [cost (if (= fa fb) 0 1)\n         key (set [a b])\n         c (cache key)]\n     (cond\n       c [c cache]\n       (empty? a) [(count b) (assoc cache key (count b))]\n       (empty? b) [(count a) (assoc cache key (count a))]\n       :else (let [[da cache] (ldist ra b cache)\n                   [db cache] (ldist a rb cache)\n                   [dab cache] (ldist ra rb cache)\n                   m (min (inc da) (inc db) (+ dab cost))]\n               [m (assoc cache key m)])))) \n  ([a b] (first (ldist a b {}))))", "problem": 101, "user": "500aa15ee4b03d00572d2d76"}, {"code": "; similar concept as ummel's, but ummel's looks a bit better :)\n(fn diff [av bv]\n   (let \n     [[bdiff brest] (split-with #(not= % (first av)) bv)\n      [adiff arest] (split-with #(not= % (first bv)) av)]\n     (if\n      (or (empty? av) (empty? bv)) (max (count av) (count bv))\n      (min \n        (+ (count adiff) (diff (rest arest) (rest bv)))\n        (+ (count bdiff) (diff (rest brest) (rest av)))\n        (+ 1 (diff (rest av) (rest bv)))\n      ))\n     ))", "problem": 101, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn [a b]\n  (let [mem (atom {})]\n    (letfn [(lev [a b]\n              (let [k [a b]]\n                (if-let [cached (get @mem k)]\n                  cached\n                  (let [result (cond\n                                 (empty? a) (count b)\n                                 (empty? b) (count a)\n                                 :else \n                                 (min\n                                   (inc (lev a (rest b)))\n                                   (inc (lev (rest a) b))\n                                   (let [r (lev (rest a) (rest b))]\n                                     (if (= (first a) (first b)) r (inc r)))))]\n                    (swap! mem assoc k result)\n                    result))))]\n      (lev a b))))", "problem": 101, "user": "50bfe95ce4b080409b860f27"}, {"code": "(fn [w1 w2]\n  (cond\n    (= w1 w2) 0\n    (empty? w1) (count w2)\n    (empty? w2) (count w1)\n    :else\n      (letfn [(get-reduce-fn [[ltr _]]\n                             (fn [[l v] [[l0 v0] [l1 v1]]]\n                               (list l1\n                                 (min (inc v1) (inc v)\n                                   (+ v0 (if (= ltr l1) 0 1))))))\n              (next-row [row first-item]\n                        (partition 2 1\n                                   (reductions\n                                     (get-reduce-fn first-item)\n                                     first-item\n                                     row)))\n              (make-row [w] (map list w (iterate inc 1)))\n              (make-first-row [w] (cons '(nil 0) (make-row w)))]\n        (->> (make-first-row w2)\n             (reduce \n               next-row\n               (partition 2 1 (make-first-row w1)))\n             ((comp last last last))))))", "problem": 101, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn levenshtein-distance [a b]                    \n  (cond \n   (empty? a) (count b)\n   (empty? b) (count a)\n   (= (first a) (first b)) (recur (rest a) (rest b))\n   :else (inc (min \n               (levenshtein-distance (rest a) b) \n               (levenshtein-distance a (rest b)) \n               (levenshtein-distance (rest a) (rest b))))))", "problem": 101, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(memoize (fn lev [l r]\n            (cond\n             (empty? l) (count r)\n             (empty? r) (count l)\n             :else (if (= (first l) (first r))\n                     (lev (next l) (next r))\n                     (min (inc (lev (next l) r))\n                          (inc (lev l (next r)))\n                          (inc (lev (next l) (next r))))))))", "problem": 101, "user": "4eae5fe4535d7eef30807325"}, {"code": "#(let [x (vec %)\n       y (vec %2)]\n    (letfn\n        [(L [l m]\n           (let [l- (- l 1)\n                 m- (- m 1)]\n             (cond (= 0 l) m\n                   (= 0 m) l\n                   (= (x l-) (y m-)) (L l- m-)\n                   :else (+ 1 (min (L l m-)\n                                   (L l- m)\n                                   (L l- m-))))))]\n      (L (count x) (count y))))", "problem": 101, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [s1 s2]\n  (let [a (transient [])\n        g (fn [i1 i2] (nth a (+ (* i1 (inc (count s2))) i2)))\n        fs (for [c1 (range (inc (count s1)))\n                 c2 (range (inc (count s2)))]\n             (let [c (if (= (nth s1 (dec c1) nil)\n                            (nth s2 (dec c2) nil)) 0 1)\n                   v (if (zero? (min c1 c2))\n                       (max c1 c2)\n                       (min (inc (g (dec c1) c2))\n                            (inc (g c1 (dec c2)))\n                            (+ c (g (dec c1) (dec c2)))))]\n               (conj! a v)))]\n    (do (dorun fs) (last (persistent! a)))))", "problem": 101, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn lev [s t]\n  (let [[ls lt] (map count [s t])]\n    (if (< lt ls)\n      (lev t s)\n      (last\n       (reduce\n        (fn [sofar i]\n          (loop [nextrow [(inc i)]\n                 j 1]\n            (if (= (count sofar) (count nextrow))\n              (do (prn nextrow) nextrow)\n              (let [sl (nth s i :nil-s)\n                    tl (nth t (dec j) :nil-t)\n                    replace (if (= sl tl) 0 1)\n                    diag (+ replace (get sofar (dec j)))\n                    above (inc (get sofar j))\n                    left (inc (last nextrow))]\n                (recur (conj nextrow (min diag above left))\n                       (inc j))))))\n        (let [start (vec (range (inc lt)))]\n          (do (prn start) start))\n        (range ls))))))", "problem": 101, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn _ [s t]\n    (let [ld (fn ld [f s t] ; non-memoized version of Levenshtein distance\n               (cond             \n                 (empty? s) (count t)\n                 (empty? t) (count s)\n                 :else (min        \n                         (+ (if (= (first s) (first t)) 0 1)\n                            (f f (rest s) (rest t)))\n                         (inc (f f (rest s) t))    \n                         (inc (f f s (rest t)))))),\n          mld (memoize ld)]\n      (mld mld s t)\n      ))", "problem": 101, "user": "4f038567535dcb61093f6b0c"}, {"code": "(let [m (atom {})]\n  (fn ld [a b]\n    (cond\n     (empty? a) (count b)\n     (empty? b) (count a)\n     :else (if-let [v (find @m [a b])]\n             (val v)\n             (let [ra (rest a)\n                   rb (rest b)\n                   r (if (= (first a) (first b))\n                         (ld ra rb)\n                         (min (inc (ld a rb))\n                              (inc (ld ra b))\n                              (inc (ld ra rb))))]\n               (swap! m assoc [a b] r)\n               r)))))", "problem": 101, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "#(let [memo (atom {})]\n    ((fn lev-dist [c1 c2]\n       (let [key [c1 c2]]\n         (if-let [found (get @memo key)]\n           found\n           (let [result (cond (empty? c1) (count c2)\n                              (empty? c2) (count c1)\n                              (= (first c1) (first c2)) (lev-dist (next c1) (next c2))\n                              :else (inc (min (lev-dist (next c1) c2)\n                                              (lev-dist c1 (next c2))\n                                              (lev-dist (next c1) (next c2)))))]\n             (swap! memo assoc key result)\n             result))))\n     %1 %2))", "problem": 101, "user": "51105c7fe4b04c71fce993ef"}, {"code": "(fn f [m a b]\n  (or (@m [a b])\n      ((swap! m assoc [a b]\n              (let [A (count a)\n                    B (count b)\n                    s (butlast a)\n                    t (butlast b)]\n                (if (= A 0)\n                  B\n                  (if (= B 0)\n                    A\n                    (min (+ 1 (f m s b))\n                         (+ 1 (f m t a))\n                         (+ (if (= (last a) (last b)) 0 1)\n                            (f m s t))))))) [a b])))\n   (atom {})", "problem": 101, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [w1 w2]\n  (let [w1 (vec (map vector (range (count w1)) w1))\n        w2 (vec (map vector (range (count w2)) w2))]\n    (last (reduce \n            (fn [u [n1 c1]] \n              (reduce \n                (fn [v [n2 c2]]\n                  (conj v (if (= c1 c2)\n                            (u n2)\n                            (inc (min (last v) (u n2) (u (inc n2)))))))\n                [(inc n1)] w2))\n            (vec (range (inc (count w2)))) w1))))", "problem": 101, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn [a b]\n  (let [w (inc (count b))\n        h (inc (count a))\n        cell-fn (fn [board x y] (get-in board [y x]))\n        update-cell-fn (fn [board x y n] (assoc-in board [y x] n))\n        neigh-fn (fn [x y] (->> [[-1 0] [-1 -1] [0 -1]]\n                                (filter #(and (<= 0 (+ (first %) x) (dec w)) (<= 0 (+ (second %) y) (dec h))))))\n        min-neigh-fn (fn [board x y] \n                       ((fnil (partial apply min) [0]) \n                        (seq (map (fn [[i j]] \n                                    (condp = [i j]\n                                      [-1 0] (inc (cell-fn board (dec x) y))\n                                      [0 -1] (inc (cell-fn board x (dec y)))\n                                      [-1 -1] (if (= (nth b (dec x)) (nth a (dec y)))\n                                                (cell-fn board (dec x) (dec y))\n                                                (inc (cell-fn board (dec x) (dec y))))))\n                                  (neigh-fn x y)))))]\n    (if (or (zero? (count a)) (zero? (count b)))\n      (max (count a) (count b))\n      (loop [board (into [] (repeat h (into [] (repeat w 0))))\n             i 0]\n        (let [new-board (reduce (fn [b j] (update-cell-fn b j i (min-neigh-fn b j i)))\n                                board\n                                (range w))]\n          (if (= i (dec h))\n            (last (last new-board))\n            (recur new-board (inc i))))))))", "problem": 101, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn super [w1 w2]\n  (letfn [(init-matrix [res w]\n            (if (> (count w) 0)\n              (init-matrix (conj res {\n                                      [(count w) \n                                       0]\n                                      (count w)\n                                      }) (rest w ))\n              (conj res {[0 0] 0} )))\n          (init-matrix2 [res w]\n            (if (> (count w) 0)\n              (init-matrix2 (conj res {\n                                       [\n                                        0\n                                        (count w) \n                                        ]\n                                       (count w)\n                                       }) (rest w))\n              (conj res {[0 0] 0} )))\n          (mat [w1 w2]\n            (conj (init-matrix {} w1) (init-matrix2 {} w2)))\n          (final [mat w1 w2 i j ]\n            (if (<= i (count w1))\n              (if (<= j (count w2))\n                (let [df (if (=\n                               ((vec w1) (dec i))\n                               ((vec w2) (dec j))\n                               )\n                           0\n                           1)]\n                  (final (conj mat {[i j] (min\n                                            (inc (get mat [(dec i) j] 0))\n                                            (inc (get mat [i (dec j)] 0))\n                                            (+ df (get mat [(dec i) (dec j)] 0))\n                                            )})\n                         w1 \n                         w2\n               i\n               (inc j)\n               ))\n                (final mat w1 w2 (inc i) 1))\n              mat))\n          ]\n         (let [m (mat w1 w2)\n               f (final m w1 w2 1 1)]\n           (get f [(count w1) (count w2)]))))", "problem": 101, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn edit-dist [w1 w2] \n\t(let [l1 (count w1) l2 (count w2)\n\t\tmatch (fn [a b] (= (get w1 (dec a)) (get w2 (dec b))))\n\t\tdist (fn [mem-dist i j]\n\t\t\t(if (zero? (min i j)) (max i j)\n\t\t\t\t(min\n\t\t\t\t\t(inc (mem-dist mem-dist (dec i) j))\n\t\t\t\t\t(inc (mem-dist mem-dist i (dec j)))\n\t\t\t\t\t(+ (mem-dist mem-dist (dec i) (dec j)) (if (match i j) 0 1))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\tmem-dist (memoize dist)]\n\t\t(mem-dist mem-dist l1 l2)\n\t)\n)", "problem": 101, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn [x y]\n    (let [lev (fn lev [[x & xs :as xx] [y & ys :as yy] a]\n                (let [k [xx yy]\n                      v (a k)]\n                  (if (nil? v)\n                    (cond\n                     (empty? xx) (let [v (count yy)] [v (assoc a k v)])\n                     (empty? yy) (let [v (count xx)] [v (assoc a k v)])\n                     true (let [[r1 a1] (lev xs yy a)\n                                [r2 a2] (lev xx ys a1)\n                                [r3 a3] (lev xs ys a2)]\n                            (let [v (min (inc r1)\n                                         (inc r2)\n                                         (if (= x y) r3 (inc r3)))]\n                              [v (assoc a3 k v)])))\n                    [v a])))]\n      (first (lev (seq x) (seq y) {}))))", "problem": 101, "user": "50c9e5e3e4b0a409464667d7"}, {"code": "(fn levenshtein [[fa & ra :as a] [fb & rb :as b]]\n  (cond\n    (> (count a) (count b)) (levenshtein b a)\n    (nil? fa) (count b)\n    (nil? fb) (count a)\n    (= fa fb) (levenshtein ra rb)\n    :else (inc (min (levenshtein ra rb) (levenshtein a rb)))))", "problem": 101, "user": "50e4f4e9e4b049a987753896"}, {"code": "(let [cache (atom {})]\n    (fn ldist [s1 s2]\n      (if-let [r (@cache [s1 s2])]\n        r\n        (let [r (let [[x & xs] s1\n                      [y & ys] s2]\n       (cond (or (nil? x) (nil? y))\n          (max (count s1) (count s2))\n          \n          (= x y)\n          (ldist xs ys)\n          \n          :else\n          (inc (min (ldist s1 ys)\n                    (ldist xs s2)\n                    (ldist xs ys)))))]\n          (swap! cache assoc [s1 s2] r)\n          r))))", "problem": 101, "user": "4fde492be4b05e33b9224f8a"}, {"code": "(fn lev-dict [s, t]\n  (let [slen (count s)\n        tlen (count t)]\n    (loop [i 1\n           d (merge\n              (reduce merge (map #(assoc-in {} [% 0] %) (range (inc slen))))\n              (reduce (partial merge-with merge) (map #(assoc-in {} [0 %] %) (range 1 (inc tlen)))))]\n      (if (> i slen)\n        (get-in d [slen tlen] 0)\n        (recur (inc i)\n               (loop [j 1\n                      d d]\n                 (if (> j tlen)\n                   d\n                   (recur (inc j) (let [cost (if (= (nth s (dec i)) (nth t (dec j))) 0 1)\n                                        pfm  (min\n                                              (+ 1    (get-in d [(dec i) j] 0))\n                                              (+ 1    (get-in d [i (dec j)] 0))\n                                              (+ cost (get-in d [(dec i) (dec j)] 0)))]\n                                    (assoc-in d [i j]\n                                              (if (and\n                                                   (> i 1)\n                                                   (> j 1)\n                                                   (= (nth s (- i 2)) (nth t (- j 2)))\n                                                   (= (nth s (- i 2)) (nth t (- j 2))))\n                                                (min\n                                                 pfm\n                                                 (+ cost (get-in d [(- i 2) (- j 2)] 0)))\n                                                pfm)))))))))))", "problem": 101, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn ld [a b]\n  (let [a (seq a)\n        b (seq b)\n        common (fn common [a b]\n                 (if (= a b)\n                   [nil nil a]\n                   (loop [a a\n                          b b\n                          ra []\n                          rb []\n                          c []]\n                     (if (or (first a) (first b))\n                       (if (= (first a) (first b))\n                         (recur (rest a) (rest b) (concat ra [nil]) (concat rb [nil]) (concat c [(first a)]))\n                         (recur (rest a) (rest b) (concat ra [(first a)]) (concat rb [(first b)]) (concat c [nil])))\n                       (let [ra (drop-while nil? (reverse ra))\n                             rb (drop-while nil? (reverse rb))\n                             c (drop-while nil? (reverse c))]\n                         (map reverse [ra rb c]))))))\n        [f l c] (common a b)\n        cf (count f)\n        cl (count l)\n        cc (count c)\n        r (cond\n           (= (max cf cl cc) cc) c\n           (= (max cf cl cc) cf) f\n           (= (max cf cl cc) cl) l)\n        d (if (= r c)\n            (count (filter nil? r))\n            (count (filter (complement nil?) r)))\n        lf (take-while (complement nil?) (reverse f))\n        ll (take-while (complement nil?) (reverse l))\n        [fr lr cr] (common lf ll)\n        e (count (filter (complement nil?) cr))]\n    (- d e)))", "problem": 101, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn lev [s t] \n  (let [lev* \n         (memoize (fn [lev* s t]\n           (cond (zero? (count s)) (count t)\n                 (zero? (count t)) (count s)\n                 :else (min\n                         (inc (lev* lev* (rest s) t))\n                         (inc (lev* lev* s (rest t)))\n                         (+ (lev* lev* (rest s) (rest t))\n                            (if (= (first s) (first t)) 0 1))))))]\n  (lev* lev* s t)))", "problem": 101, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [sx sy]\n  (let [\n        default-value -1\n        lx (count sx)\n        ly (count sy)\n        update-cache (fn [cache x y v] (assoc cache x (assoc (nth cache x) y v)))\n        get-cache (fn [cache x y] (-> cache (nth x) (nth y)))\n        init-cache (fn [x y] (vec (repeat x (vec (repeat y default-value)))))\n        l (fn l [cache x y]\n            (let [cache-value (get-cache cache x y)]\n              (if (= default-value cache-value)\n                (cond \n                  (= x 0) (list (update-cache cache x y y) y)\n                  (= y 0) (list (update-cache cache x y x) x)\n                  :default (let [cost (if (= (nth sx (dec x)) (nth sy (dec y))) 0 1)\n                                 [cache1 v1] (l cache (dec x) y)\n                                 [cache2 v2] (l cache1 x (dec y))\n                                 [cache3 v3] (l cache2 (dec x) (dec y))\n                                 v (min (inc v1) (inc v2) (+ v3 cost))\n                                 ]\n                               (list (update-cache cache3 x y v) v)))\n                (list cache cache-value))))]\n    (second (l (init-cache (inc lx) (inc ly)) lx ly))\n    )\n  )", "problem": 101, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [a b]\n  (let [a (vec (cons \\space a))\n        b (vec (cons \\space b))]\n    (letfn [(dwn [rows]\n              (let [y (count rows)\n                    prev-row (last rows)]\n                (letfn [(acrs [row]\n                          (let [x (count row)]\n                            (if (< x (count a))\n                              (let [v1 ((if (= (a x) (b y)) identity inc) (prev-row (dec x)))\n                                    v2 (inc (last row))\n                                    v3 (inc (prev-row x))]\n                                (recur (conj row (min v1 v2 v3))))\n                              row)))]\n                  (if (< y (count b))\n                    (recur (conj rows (acrs [y])))\n                    rows))))]\n      (last (last (dwn [(vec (range (count a)))]))))))", "problem": 101, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [a b]\n (let [mem (atom {})]\n      ((fn lev [x y]\n        (if (contains? @mem [x y]) (get @mem [x y]) \n          (let [res (cond\n                      (empty? x) (count y)\n                      (empty? y) (count x)\n                      :else (min \n                            (if (= (first x) (first y)) (lev (rest x) (rest y)) Integer/MAX_VALUE)\n                            (inc (lev (rest x) (rest y)) )\n                            (inc (lev x (rest y)) )\n                            (inc (lev (rest x) y) )\n                      )   \n                    ) ] \n          (swap! mem assoc [x y] res)\n          res \n      ))) a b)) \n\n)", "problem": 101, "user": "5158bba4e4b059418b97f0ab"}, {"code": "(fn L [A a x]\n     (cond\n      (not a) (+ A (count x))\n      (not x) (+ A (count a))\n      (= (first a) (first x)) (L A (next a) (next x))\n      L (min (L (inc A) (next a) x)\n             (L (inc A) a (next x))\n             (L (inc A) (next a) (next x)))))\n   0", "problem": 101, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn [s1 s2]\n  (letfn [(init-matrix [m n]\n            (reduce merge (for [x (range (+ m 1)) y (range (+ n 1))] {[x y] -1})))\n\n          (min-val [x y s1 s2 matrix]\n            (if (some zero? [x y])\n              (assoc matrix [x y] (+ x y))\n              (let [n1 (+ (matrix [x (- y 1)]) 1)\n                    n2 (+ (matrix [(- x 1) y]) 1)\n                    n3 (matrix [(- x 1) (- y 1)])\n                    n4 (if (= ((vec s1) (- x 1)) ((vec s2) (- y 1)))\n                         n3\n                         (+ n3 1))]\n                (assoc matrix [x y] (min n1 n2 n4)))))\n\n          (set-matrix [s1 s2]\n            (let [m (count s1) n (count s2) matrix (init-matrix m n)]\n              (loop [y 0 matrix matrix]\n                (let [n-matrix\n                      (loop [x 0 matrix matrix]\n                        (if (> x m)\n                          matrix\n                          (recur (+ x 1) (min-val x y s1 s2 matrix))))]\n                  (if (>= y n)\n                    n-matrix\n                    (recur (+ y 1) n-matrix))))))]\n    ((set-matrix s1 s2) [(count s1) (count s2)])))", "problem": 101, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [w1 w2]\n  (letfn [\n    (dist [d w1 w2]\n      (cond\n        (empty? w1) (count w2)\n        (empty? w2) (count w1)\n        :else\n          (min\n            (inc (d d (rest w1) w2))\n            (inc (d d w1 (rest w2)))\n            (+ (if (= (first w1) (first w2)) 0 1)\n              (d d (rest w1) (rest w2))))))]\n  (dist (memoize dist) w1 w2)))", "problem": 101, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn levenshtein [src tgt]\n  (let [srclen (count src) tgtlen (count tgt) rowsz (inc tgtlen)]\n    (if (= src tgt)\n      0\n      (if (or (= (count src) 0)\n              (= (count tgt) 0))\n        (max (count src) (count tgt))\n        (loop [srcidx 0 tgtidx 0 preRow (range 0 rowsz) curRow (conj [] (inc srcidx))] ;; curRow[0]=srcidx+1\n          (let [srclt (nth src srcidx)\n                tgtlt (nth tgt tgtidx)\n                nxtsrcidx (inc srcidx)\n                nxttgtidx (inc tgtidx)\n                leftv (nth preRow nxttgtidx)\n                leftupperv (nth preRow tgtidx)\n                upperv (nth curRow tgtidx)\n                cost (fn [slt dlt] (if (= slt dlt) 0 1))\n                mincurv (min (inc leftv) (inc upperv) (+ leftupperv (cost srclt tgtlt)))]\n            ;; does cur row iteration done ?\n            ;;(prn srclt tgtlt nxtsrcidx preRow curRow)\n            (if (= nxttgtidx tgtlen)   ;; done one iteration of tgt row\n              (if (= nxtsrcidx srclen)\n                mincurv     ;; the result is in last of cur-row after iterating all.\n                (recur nxtsrcidx 0 (conj curRow mincurv) (conj [] (inc nxtsrcidx))))  ;; next src letter\n              (recur srcidx nxttgtidx preRow (conj curRow mincurv)))))))))", "problem": 101, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn ld [left right]\n    (cond\n      (= left right) 0\n      (empty? left) (count right)\n      (empty? right) (count left)\n      :else (loop [prevrow (into-array (range (inc (count right))))\n             nextrow (into-array (repeat (inc (count right)) 0))\n             i 0]\n              (if (= i (count left))\n          (aget prevrow (count right))\n          (do\n            (aset nextrow 0 (inc i))\n            (loop [j 0]\n              (if (< j (count right))\n                (let [cost\n                      (if (= (nth left i) (nth right j)) 0 1)]\n                  (aset nextrow (inc j) (min\n                                     (inc (aget nextrow j))\n                                     (inc (aget prevrow (inc j)))\n                                     (+ cost (aget prevrow j))))\n                  (recur (inc j)))))\n            (recur nextrow prevrow (inc i)))))))", "problem": 101, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn l\n    ([w o]\n       (let [wc (count w)\n             oc (count o)]\n         (cond\n          (zero? oc) wc\n          (zero? wc) oc\n          :else\n          (l 0 {-1 0} (vec w) (vec o)) )))\n    ([n p w [c & r]] (pr n p)\n       (if c\n         (l (+ 1 n)\n            (reduce #(conj % (min\n                              (+   ({c 0} (get w %2 %2) 1)\n                                   (get p (- %2 1) (max n %2)))\n                              (+ 1 (get % (- %2 1) n))\n                              (+ 1 (get p %2 %2))  ))\n                    [] (range (count w))) w r)\n         (last p))))", "problem": 101, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn wagner-fischer [s t]\n  (last (reduce (fn [prevrow row]\n                  ; Construct next row\n                  (reduce (fn [prevcells col]\n                            (conj prevcells\n                                  (min (inc (nth prevcells (dec col)))\n                                       (inc (nth prevrow col))\n                                       (+ (nth prevrow (dec col))\n                                          (if (= (nth s (dec row))\n                                                 (nth t (dec col)))\n                                            0\n                                            1)))))\n                          [row]\n                          (range 1 (-> t count inc))))\n                (vec (-> t count inc range))\n                (range 1 (-> s count inc)))))", "problem": 101, "user": "5175616ae4b0dea9bbfba576"}, {"code": "(fn leven [s1 s2]\n  (let [n (count s1)\n        m (count s2)]\n    (cond (= s1 s2) 0\n          (= 0 n) m\n          (= 0 m) n\n          :else \n          (let [v0 (vec (range (inc m)))\n                v1 (vec (range (inc m)))]\n            (loop [i 0 v0 v0 v1 v1]\n              (if (= i n) \n                (v1 m)\n                (let [v1 (reduce\n                          (fn [v1 j]\n                            (assoc-in v1 [(inc j)] \n                                      (min (inc (nth v1 j)) \n                                           (inc (nth v0 (inc j))) \n                                           (+ (if (= (nth s1 i) (nth s2 j)) 0 1) (nth v0 j))))) (assoc-in v1 [0] (inc i)) (range 0 m))]\n                  (recur (inc i) (take (count v0) v1) v1))))))))", "problem": 101, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [s1 s2]\n    (let [levdist (memoize (fn [s1 s2 cb]\n                             (cond\n                               (empty? s1) (count s2)\n                               (empty? s2) (count s1)\n                               :else\n                               (let [f1 (first s1)\n                                     f2 (first s2)\n                                     diff1 (if (= f1 f2) 0 1)\n                                     r1 (rest s1)\n                                     r2 (rest s2)]\n                                 (min\n                                   (+ 1 (cb s1 r2 cb))\n                                   (+ 1 (cb r1 s2 cb))\n                                   (+ diff1 (cb r1 r2 cb)))))))]\n      (levdist s1 s2 levdist))\n  )", "problem": 101, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn lev [str1 str2]\n  (let [len1 (inc (count str1))\n        len2 (inc (count str2))\n        matrix (vec (repeat len2 (vec (repeat len1 0))))\n        lookup (fn [m r c] ((m r) c))\n        check-letter (fn [r c]\n                       (= (nth str2 (dec r)) (nth str1 (dec c))))\n        calculate (fn [m r c]\n                    (cond\n                     (= r 0) c\n                     (= c 0) r\n                     (check-letter r c) (lookup m (dec r) (dec c))\n                     :else (inc\n                            (min\n                             (lookup m (dec r) c)\n                             (lookup m r (dec c))\n                             (lookup m (dec r) (dec c))))))\n        final (reduce\n               (fn [m [r c]]\n                 (assoc-in m [r c] (calculate m r c)))\n               matrix\n               (for [r (range len2) c (range len1)] [r c]))]\n    (lookup final (count str2) (count str1))))", "problem": 101, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [s t]\n  (let [sv (vec s) tv (vec t) mem (atom {})]\n    (letfn [(lev [si ti]\n              (if (contains? @mem [si ti])\n                (@mem [si ti])\n                (do\n                  (swap! mem assoc [si ti]\n                         (cond\n                          (< si 0) (inc ti)\n                          (< ti 0) (inc si)\n                          :else (min\n                                 (inc (lev (dec si) ti))\n                                 (inc (lev si (dec ti)))\n                                 (+ (if (= (sv si) (tv ti)) 0 1)\n                                    (lev (dec si) (dec ti))))))\n                  (@mem [si ti]))))]\n      (lev (dec (count sv)) (dec (count tv))))))", "problem": 101, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn ld [x y]\n  (letfn [(max-len [i j]\n            (let [newi (- i 1)\n                  newj (- j 1)]\n              (cond (= 0 i) j\n                    (= 0 j) i\n                    (= (nth x newi) (nth y newj)) (max-len newi newj)\n                    :else (+ 1 (min (max-len i newj)\n                                    (max-len newi j)\n                                    (max-len newi newj))))))]\n    (max-len (count x) (count y))))", "problem": 101, "user": "512eb723e4b0b740abc5982b"}, {"code": "(let [cache (atom {})]\n    (fn levenshtein [xs ys]\n      (if-let [e (find @cache [xs ys])]\n        (val e)\n        (let [ret (cond\n                   (empty? xs) (count ys)\n                   (empty? ys) (count xs)\n                   (= (last xs) (last ys)) (levenshtein (butlast xs) (butlast ys))\n                   :else (inc (min (levenshtein (butlast xs) ys)\n                                   (levenshtein xs (butlast ys))\n                                   (levenshtein (butlast xs) (butlast ys)))))]\n          (swap! cache assoc [xs ys] ret)\n          ret))))", "problem": 101, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [a b]\n  (letfn [(step [calculated-result coordinate]\n            (let [x (first coordinate)\n                  y (last coordinate)]\n              (assoc calculated-result\n                coordinate\n                (if (zero? (min x y))\n                  (max x y)\n                  (min\n                    (inc (calculated-result [(dec x) y]))\n                    (inc (calculated-result [x (dec y)]))\n                    (+\n                      (calculated-result [(dec x) (dec y)])\n                      (if (= ((vec a) (dec x)) ((vec b) (dec y))) 0 1)))))))]\n    ((reduce step {} (apply concat (map #(map (fn [i] [% i]) (range 0 (inc (count b)))) (range 0 (inc (count a)))))) [(count a) (count b)])))", "problem": 101, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn levenshtein [w1 w2]\n  (cond\n   (= (count w1) 0) (count w2)\n   (= (count w2) 0) (count w1)\n   (= (first w1) (first w2)) (levenshtein (rest w1) (rest w2))\n   :else (inc\n           (min (levenshtein (rest w1) (rest w2)) ; substitution\n                (levenshtein w1 (rest w2))        ; letter added\n                (levenshtein (rest w1) w2)))))    ; letter removed", "problem": 101, "user": "51460e4ce4b04ef915e37314"}, {"code": "(fn levenshtein [a b]\n  (let [m (count a) n (count b)\n        va (vec a) vb (vec b)\n        next-step (fn [result-map [i j]] (let [result\n                                          (if (= (va (dec i)) (vb (dec j))) (result-map [(dec i) (dec j)])\n                                              (inc (min (result-map [(dec i) j]) \n                                                        (result-map [i (dec j)])\n                                                        (result-map [(dec i) (dec j)]))))]\n                                           (assoc result-map [i j] result)))\n        init-map (merge (into {} (for [i (range (inc m))] [[i 0] i])) \n                        (into {} (for [j (range (inc n))] [[0 j] j])))\n        matrix-range (for [j (range 1 (inc n)) i (range 1 (inc m))] [i j])\n        result-map (reduce next-step init-map matrix-range)]\n    (result-map [m n])))", "problem": 101, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn [start end]\n  (letfn [(max-changes-needed [w target]\n            (+ (Math/abs (- (count w) (count target)))\n               (count (filter identity (map not= w target)))))] \n    (let [start (vec (seq start)) end (vec (seq end))\n          alphabet (distinct end)\n          mx (max-changes-needed start end)]\n      (loop [q [[start 0]]] \n        (let [[[w n]] q]\n          (if (= w end)\n            n\n            (let [len (count w)\n                  inserts (for [c alphabet i (range (inc len))]\n                            (vec (concat (subvec w 0 i) [c] (subvec w i))))\n                  deletes (for [i (range len)]\n                            (vec (concat (subvec w 0 i) (subvec w (inc i)))))\n                  substs (for [c alphabet i (range len)]\n                           (vec (concat (subvec w 0 i) [c] (subvec w (inc i)))))\n                  all (filter (fn [nw]\n                                (when (< (max-changes-needed end nw) (max-changes-needed end w))\n                                  nw))\n                              (concat inserts deletes substs))]\n              (recur (vec\n                      (sort-by (fn [[w n]] (max-changes-needed end w))\n                               <\n                               (concat (subvec q 1) (map #(vector % (inc n)) all))))))))))))", "problem": 101, "user": "519ef784e4b087743fad2198"}, {"code": "(fn f [s t]                                                                                                      \n  (let [mem (atom {})                                                                                              \n        s (vec s)                                                                                                  \n        t (vec t)]                                                                                                 \n    ((fn leven [s t]                                                                                               \n      (if (contains? (deref mem) [s t])                                                                            \n        ((deref mem) [s t])                                                                                        \n        (let [s-len (count s)                                                                                      \n              t-len (count t)                                                                                      \n              ans (cond                                                                                            \n                    (= s-len 0) t-len                                                                              \n                    (= t-len 0) s-len                                                                                                  :else (let [cost (if (= (last s) (last t)) 0 1)]                                               \n                            (min (inc (leven (drop-last s) t))                                                     \n                                 (inc (leven s (drop-last t)))                                                     \n                                 (+ cost (leven (drop-last s) (drop-last t))))))]                                  \n          (do                                                                                                      \n            (swap! mem conj {[s t] ans})                                                                           \n            ans)))) s t)))", "problem": 101, "user": "51899891e4b0288ada3dbdab"}, {"code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "problem": 101, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [x y]\n  (last\n    (reduce\n      (fn [[v & vs] x]\n        (let [v (partition 2 (interleave (list* v vs) (cons (inc v) (map (partial = x) y))))]\n          (println x y v)\n          (map second (reductions (fn [[a b] [c d]][c (if d a (inc (min a b c)))]) v))))\n      (range 0 (inc (count y))) x )))", "problem": 101, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn [l r]\n    (->>\n      (for [i (range 0 (+ 1 (count l))) j (range 0 (+ 1 (count r)))]\n        [i j])\n      (#(zipmap % (map (fn [[a b]] (max a b)) %)))\n      (#(into (sorted-map-by\n                (fn [[a b] [c d]]\n                  (if (= a c)\n                    (compare b d)\n                    (compare a c)))) %))\n      (#(reduce\n          (fn [a [[i j] _]]\n            (cond\n              (some zero? [i j]) a\n              (= (nth l (- i 1)) (nth r (- j 1))) (assoc a [i j] (a [(- i 1) (- j 1)]))\n              1\n              (assoc a [i j]\n                (min\n                  (+ 1 (a [(- i 1) j]))\n                  (+ 1 (a [i (- j 1)]))\n                  (+ 1 (a [(- i 1) (- j 1)]))))))\n          %\n          %))\n      last\n      last\n      ))", "problem": 101, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [a b]\n  ((reduce (fn [acc [i j]]\n                      (assoc acc [i j]\n                             (if (zero? (min i j))\n                               (max i j)\n                               (min (inc (acc [(dec i) j]))\n                                    (inc (acc [i (dec j)]))\n                                    (+ (acc [(dec i) (dec j)])\n                                       (if (= (nth a (dec i))\n                                              (nth b (dec j)))\n                                         0 1))))))\n                    {} (sort-by #(apply + %)\n                       (for [i (range (inc (count a)))\n                             j (range (inc (count b)))]\n                         [i j])))\n   [(count a)\n          (count b)])\n)", "problem": 101, "user": "4fa340b4e4b081705acca18c"}, {"code": "(let [mlev\n      (memoize\n        (fn [mem s t]\n          (let [slen (count s)\n                tlen (count t)\n                cost (if (= (last s) (last t)) 0 1)]\n            (cond\n              (zero? slen) tlen\n              (zero? tlen) slen\n              :else (min\n                      (+ 1 (mem mem (butlast s) t))\n                      (+ 1 (mem mem s (butlast t)))\n                      (+ cost (mem mem (butlast s) (butlast t))))))))]\n  (partial mlev mlev))", "problem": 101, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(letfn [\n    (dis [dis-memoized x1 x2] (cond \n        (= 0 (count x1)) (count x2)\n        (= 0 (count x2)) (count x1)\n        true (apply min (remove nil? [\n            (inc (dis-memoized dis-memoized (rest x1) (rest x2)))\n            (inc (dis-memoized dis-memoized x1 (rest x2)))\n            (inc (dis-memoized dis-memoized (rest x1) x2))\n            (when (= (first x1) (first x2)) (dis-memoized dis-memoized (rest x1) (rest x2)))]))))]\n    (partial dis (memoize dis)))", "problem": 101, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(letfn [(implicit-dp [rec sa sb]\n          (cond (empty? sa) (count sb)\n                (empty? sb) (count sa)\n                :else (min\n                        (+ (if (= (first sa) (first sb))\n                             0\n                             1)\n                           (rec rec (rest sa) (rest sb)))\n                        (+ 1 (rec rec sa (rest sb)))\n                        (+ 1 (rec rec (rest sa) sb)))))\n        (leven-dp [sa sb]\n          (let [dp (memoize implicit-dp)]\n            (dp dp sa sb)))]\n  leven-dp)", "problem": 101, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [s1 s2]\n  (letfn [(cmp [v i]\n               (reduce \n                   #(conj % (min (inc (last %))\n                                 (inc (nth v (inc %2)))\n                                 (+ (nth v %2) (if (= (nth s1 i) (nth s2 %2)) 0 1))))\n                          [(inc i)] (range (count s2))))]\n    (last (reduce #(cmp % %2) (range (inc (count s2))) (range (count s1))))))", "problem": 101, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn[s t]\n  (let [d (into [(vec (range 0 (inc (count s))))]\n                (map #(vec (concat [%] (repeat (count s) 0)))\n                     (range 1 (inc (count t)))))\n        res (reduce (fn [d i]\n                (reduce (fn [d j]\n                          (assoc-in d [i j]\n                                    (if (= (get t (dec i)) (get s (dec j)))\n                                      (get-in d [(dec i) (dec j)])\n                                      (min (inc (get-in d [(dec i) j]))\n                                           (inc (get-in d [i (dec j)]))\n                                           (inc (get-in d [(dec i) (dec j)]))))))\n                        d (range 1 (inc (count s)))))\n                    d (range 1 (inc (count t))))]\n    (get-in res [(count t) (count s)])))", "problem": 101, "user": "50f48298e4b004d364930527"}, {"code": "(fn [a b]\n  (letfn [(next-row [s t prev-row row-count]\n            (reduce (fn [res col-count]\n                      (conj res (if (= (get s (dec col-count)) (get t (dec row-count)))\n                                  (get prev-row (dec col-count))\n                                  (inc (min (last res)\n                                            (get prev-row (dec col-count))\n                                            (get prev-row col-count))))))\n                    [row-count]\n                    (range 1 (inc (count s)))))        \n\n          (distance [s t]\n            (let [row0 (-> (count s) inc range vec)]\n              (last\n                (reduce (partial next-row s t)\n                        row0\n                        (range 1 (inc (count t)))))))]\n    (distance a b)))", "problem": 101, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn __ [a b]\n  (letfn [(topple-lev [cache [a b]]\n            (let [m (count a)\n                  n (count b)\n                  d (cond\n                       (= 0 m) n\n                       (= 0 n) m\n                       :else (let [n-1 (dec n)\n                                   m-1 (dec m)\n                                   cost (if (= (last a) (last b)) 0 1)]\n                               (min (+ 1 (cache [m n-1]))\n                                    (+ 1 (cache [m-1 n]))\n                                    (+ cost (cache [m-1 n-1])))))]\n              {[m n] d}))\n\n          (lev-tbl [a b]\n            (reduce #(merge % (topple-lev % %2)) {}\n                    (for [i (range (+ 1 (count a)))\n                          j (range (+ 1 (count b)))]\n                      [(take i a) (take j b)])))]\n\n    ((lev-tbl a b) [(count a) (count b)])))", "problem": 101, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn levs [a b]\n\n    (cond\n     (= a b) 0\n     (or (empty? a) (empty? b)) (+ (count a) (count b))\n     (= (first a) (first b)) (levs (rest a) (rest b))\n     :else (inc (min (levs a (rest b))  (levs (rest a) b) (levs (rest a) (rest b))))\n     )\n\n\n    )", "problem": 101, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn go [a b]\n  (-> (iterate (fn [{j :index prev-row :row}]\n                 {:index (inc j)\n                  :row (reduce (fn [row i]\n                                 (conj\n                                  row\n                                  (if (zero? i)\n                                    (inc j)\n                                    (min (inc (last row))\n                                         (inc (nth prev-row i))\n                                      (+ (nth prev-row (dec i)) (if (= (nth a (dec i)) (nth b j)) 0 1))))))\n                               []\n                               (range (count prev-row)))})\n               {:index 0, :row (range (inc (count a)))})\n      (nth (count b))\n      :row\n      last))", "problem": 101, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(let [cache (atom {})]\n    (fn f [s1 s2]\n      (if-let [e (find @cache [s1 s2]) ] \n        (val e)\n        (let [r (cond (empty? s1) (count s2)\n                      (empty? s2) (count s1)\n                      :else (apply min [\n                        (inc (f (butlast s1) s2))\n                        (inc (f s1 (butlast s2)))\n                        (+ (f (butlast s1) (butlast s2)) \n                           (if (= (last s1) (last s2)) 0 1))\n                        ]))]\n            (swap! cache assoc [s1 s2] r)\n            r\n          ))\n    ))", "problem": 101, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn ld [m1 m2]\n\t\t(letfn [(ne [m x y]\n\t\t\t\t\t(if (= (nth m1 (dec x)) (nth m2 (dec y)))\n\t\t\t\t\t\t(nth (nth m (dec y)) (dec x))\n\t\t\t\t\t\t(inc (min (nth (nth m (dec y)) (dec x)) (nth (nth m y) (dec x)) (nth (nth m (dec y)) x)))))\n\t\t\t (ar [m y]\n\t\t\t\t\t(loop [x 1 nr [y]]\n\t\t\t\t\t\t(if (= x (inc (count m1)))\n\t\t\t\t\t\t\tnr\n\t\t\t\t\t\t\t(recur (inc x) (conj nr (ne (conj m nr) x y))))))\n\t\t\t (bm []\n\t\t\t\t(let [i (vector (into [] (range (inc (count m1)))))]\n\t\t\t\t\t(loop [y 1 m i]\n\t\t\t\t\t\t(if (= y (inc (count m2)))\n\t\t\t\t\t\t\tm\n\t\t\t\t\t\t\t(recur (inc y) (conj m (ar m y)))))))]\n\t\t(last (last (bm)))))", "problem": 101, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [s t]\n    (letfn [(ld [s t]\n                (cond\n                 (empty? s) (count t)\n                 (empty? t) (count s)\n                 (= (first s) (first t)) (ld (rest s) (rest t))\n                 :else (let [l1 (ld s (rest t))\n                             l2 (ld (rest s) t)\n                             l3 (ld (rest s) (rest t))]\n                         (inc (min l1 l2 l3)))))]\n      (let [ld (memoize ld)]\n        (ld s t))))", "problem": 101, "user": "50bca033e4b0594b91591c5d"}, {"code": "(let [lev (fn [a b rec]\n            (let [a-len (count a) b-len (count b)]\n              (cond\n                (= a-len 0) b-len\n                (= b-len 0) a-len\n                :else\n                   (let [cost (if (= (last a) (last b)) 0 1)]\n                     (min (inc (rec (butlast a) b rec))\n                          (inc (rec a (butlast b) rec))\n                          (+ cost (rec (butlast a) (butlast b) rec)))))))]\n  #(lev %1 %2 (memoize lev)))", "problem": 101, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn [s1 s2]\n (let [ cm (apply max (map count [s1 s2]))\n  start-set (conj #{} (vec (sort-by str [s1 s2])))\n  s-map (sorted-map 0 start-set) \n  rec-levenshtein ( fn [ [ws dm cm]] \n    (let [ [d s] (first dm)\n            rdm (dissoc dm d)\n            str-rest (fn[s] (->> s rest ))\n            str-assoc (fn[m k [w1 w2]]\n                (let [w1w2s (vec (sort-by str [w1 w2]))] \n                    ;(println m k w1 w2)\n                    ;(println w1w2s)\n                    (if (contains? ws w1w2s) \n                        m\n                        (assoc m k (set (conj (m k) w1w2s))))))\n            d1-vecs (fn [w1 w2] [[(str-rest w1) w2] [(str-rest w1) (str-rest w2)]\n                        [w1 (str-rest w2)]])\n            do-one ( fn[[wsi dmi cmi] [w1 w2]]\n                (let [ wsr (conj wsi [w1 w2])]\n                    (cond\n                        (= w1 w2)   [wsr dmi (min cmi d)]\n                        (empty? w1) [wsr dmi (min cmi (+ d (count w2)))]\n                        (empty? w2) [wsr dmi (min cmi (+ d (count w1)))]\n                        (= (first w1) (first w2))\n                            [wsr (str-assoc dmi d (map str-rest [w1 w2])) cmi]\n                        :else\n                            [wsr (reduce #(str-assoc %1 (inc d) %2) dmi (d1-vecs w1 w2)) cmi]) \n                ))]\n       ; (println \"ws =\" ws)\n       ; (println \"dm =\" dm)\n       ; (println \"cm =\" cm)\n       ; (println \"---- >>\")\n        (cond\n            (empty? dm) cm\n            (= 0 cm) 0\n            (>= d cm) cm\n            :else (recur (reduce do-one [ws rdm cm] s))\n            )))\n  ]\n  (rec-levenshtein [#{} s-map cm])))", "problem": 101, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn levenstein [a b]\n  (let [lev (fn lev [a b]\n            (cond (= a b) 0\n                  (= a []) (count b)\n                  (= b []) (count a)\n                  :else (min (if (< (count a) (count b)) (inc (lev a (rest b)))\n                             \t(inc (lev (rest a) b)))\n                             (+ (lev (rest a) (rest b)) (if (= (first a) (first b)) 0 1)))))\n        mem-lev (memoize lev)]\n    (mem-lev a b)))", "problem": 101, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn difference [s1 s2]\n  (let [score (fn [score-mem s1 s2]  ;pass memoized function as a parameter\n                 (if(and (empty? s1) (empty? s2))\n                   0\n                   (min (if (and (not-empty s1) (not-empty s2))\n                          (+ (if (not= (first s1) (first s2)) 1 0) (score-mem score-mem (next s1) (next s2)))\n                          Integer/MAX_VALUE)\n                        (if (not-empty s1)\n                          (inc (score-mem score-mem (next s1) s2))\n                          Integer/MAX_VALUE)\n                        (if (not-empty s2)\n                          (inc (score-mem score-mem s1 (next s2)))\n                          Integer/MAX_VALUE))))\n        \n        score-m (memoize score)]\n      (score-m score-m (seq s1) (seq s2))))", "problem": 101, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "; Non-functional implementation of http://en.wikipedia.org/wiki/Levenstein_distance#Iterative_with_two_matrix_rows\n(fn dist [s1 s2]\n  (let [len1 (count s1) len2 (count s2)]\n    (cond\n     (zero? len1) len2\n     (zero? len2) len1\n     :else\n     (let [v0 (int-array (range (inc len2)))\n           v1 (int-array (inc len2))]\n       (dotimes [i len1]\n         (aset v1 0 (inc i))\n         (dotimes [j len2]\n           (let [cost (if (= (nth s1 i) (nth s2 j)) 0 1)]\n             (aset v1 (inc j) (min (inc (aget v1 j))\n                                   (inc (aget v0 (inc j)))\n                                   (+ cost (aget v0 j))))))\n         (dotimes [j len2]\n           (aset v0 j (aget v1 j))))\n       (aget v1 len2)))))", "problem": 101, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": ";; My apologies dear reader, this isn't an original solution. :'(\n(fn [s1 s2]\n           (letfn [(nextrow\n                     [char1 str2 prevrow thisrow]\n                     (let [char2 (first str2)\n                           position (count thisrow)]\n                       (if (= (count thisrow) (count prevrow))\n                         thisrow\n                         (recur\n                          char1\n                          (rest str2)\n                          prevrow\n                          (conj thisrow (nextelt char1 char2 prevrow thisrow position))))))\n          \n                   (nextelt\n                     [char1 char2 prevrow thisrow position]\n                     (if (= char1 char2)\n                       (prevrow (- position 1))\n                       (inc (min\n                             (prevrow (- position 1))\n                             (prevrow position)\n                             (last thisrow)))))\n                   (levenshtein\n                     ([str1 str2]\n                        (cond (= str1 str2) 0\n                              (empty? str1) (count str2)\n                              (empty? str2) (count str1)\n                              :else (let [row0 (vec (map first (map vector (iterate inc 1) str2)))]\n                                      (levenshtein 1 (vec (cons 0 row0)) str1 str2))))\n                     ([row-nr prevrow str1 str2]\n                        (let [next-row (nextrow (first str1) str2 prevrow (vector row-nr))\n                              str1-remainder (if (string? str1)\n                                               (.substring str1 1)\n                                               (drop 1 str1))]\n                          (if (empty? str1-remainder)\n                            (last next-row)\n                            (recur (inc row-nr) next-row str1-remainder str2)))))]\n             (levenshtein s1 s2)))", "problem": 101, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn lev [s1 s2] \n  ((memoize \n     (fn dist [[f1 & r1 :as s1] [f2 & r2 :as s2]]\n       (cond\n         (zero? (count s1)) (count s2)\n         (zero? (count s2)) (count s1)\n         (= f1 f2) (dist r1 r2)\n         :else (+ 1 \n                  (min (dist r1 r2)\n                       (dist s1 r2)\n                       (dist r1 s2)))))) s1 s2))", "problem": 101, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn [as bs]\n  (let [al (count as)\n        bl (count bs)\n        to-ab (fn [i]\n                [(mod i (inc al))\n                 (quot i (inc al))])\n        to-i (fn [a b]\n               (+ a (* (inc al) b)))]                \n    (loop [dp (vec (repeat (* (inc al) (inc bl)) 0))\n           i 0]\n      (if (>= i (* (inc al) (inc bl)))\n        (last dp)\n        (let [[a b] (to-ab i)]\n          (cond\n           (= a 0) (recur (assoc dp i b) (inc i))\n           (= b 0) (recur (assoc dp i a) (inc i))\n           :else   (recur (assoc dp i (min (inc (nth dp (to-i (dec a) b)))\n                                           (inc (nth dp (to-i a (dec b))))\n                                           (+ (nth dp (to-i (dec a) (dec b)))\n                                              (if (= (nth as (dec a))\n                                                     (nth bs (dec b)))\n                                                0\n                                                1))))\n                          (inc i))))))))", "problem": 101, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [sa sb]\n  (let [\n    sa (vec (cons \\0 sa))\n    sb (vec (cons \\0 sb))\n    h (count sa)\n    w (count sb)\n    dp (make-array Long/TYPE (inc h) (inc w))\n    oo 1000\n    _ (doseq [i (range 1 (inc h))] (aset dp i 0 oo))\n    _ (doseq [j (range 1 (inc w))] (aset dp 0 j oo))]\n    (doseq [i (range 1 (inc h))]\n      (doseq [j (range 1 (inc w))]\n        (do \n          (aset dp i j \n            (min (inc (aget dp i (dec j)))\n                (inc (aget dp (dec i) j))))\n          (if (= (sa (dec i)) (sb (dec j)))\n            (aset dp i j \n              (min (aget dp (dec i) (dec j)) (aget dp i j)))\n            (aset dp i j \n              (min (inc (aget dp (dec i) (dec j))) (aget dp i j)))))))\n    (aget dp h w)))", "problem": 101, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [s t]\n  (let [ct (count t)]\n    (cond\n     (= s t) 0\n     (empty? s) ct\n     (empty? t) (count s)\n     :else (let [v0 (int-array (range (inc ct)))\n                 v1 (int-array (inc ct))]\n             (doseq [i (range (count s))]\n               (aset v1 0 (inc i))\n               (doseq [j (range ct) :let [cost (if (= (nth s i) (nth t j)) 0 1)]]\n                 (aset v1 (inc j) (min (inc (aget v1 j))\n                                       (inc (aget v0 (inc j)))\n                                       (+ (aget v0 j) cost))))\n               (doseq [j (range ct)]\n                 (aset v0 j (aget v1 j))))\n             (aget v1 ct)))))", "problem": 101, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [a b]\n    (let [worker (fn [lev a b]\n                   (cond (nil? a) (count b)\n                         (nil? b) (count a)\n                         :else\n                         (let [cost (if (= (last a) (last b)) 0 1)]\n                           (min (+ (lev lev (butlast a) b) 1)\n                                (+ (lev lev a (butlast b)) 1)\n                                (+ (lev lev (butlast a) (butlast b)) cost)))))\n          lev (memoize worker)]\n      (lev lev a b)))", "problem": 101, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [s t]\n  (let [len-s (count s)\n        len-t (count t)\n        cost (fn [s i t j] (if (= (nth s i) (nth t j)) 0 1))]\n    (cond\n      (= s t) 0\n      (= 0 len-s) len-t\n      (= 0 len-t) len-s\n      :else (loop [i 0 \n                   v (vec (range (inc len-t)))]\n              (if (= i len-s)\n                (v len-t)\n                (recur\n                  (inc i)\n                  (reduce\n                    (fn [vnext j]\n                      (conj vnext (min (inc (vnext j)) (inc (v (inc j))) (+ (v j) (cost s i t j)))))\n                    [(inc i)]\n                    (range len-t))))))))", "problem": 101, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [s t]\n  (let [dist\n        (fn [s t mdist]\n          (let [sl (count s)\n                tl (count t)]\n            (cond\n             (zero? sl) tl\n             (zero? tl) sl\n             :else (let [si (dec sl)\n                         ti (dec tl)\n                         cost (if (= (last s) (last t)) 0 1)\n                         s1 (take si s)\n                         t1 (take ti t)]\n                     (min\n                      (inc (mdist s1 t mdist))\n                      (inc (mdist s t1 mdist))\n                      (+ (mdist s1 t1 mdist) cost))))))]\n    (dist s t (memoize dist))))", "problem": 101, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn ld [o1 o2]\n  (let [diff (fn [x y] (count (filter false? (map = x y))))\n        m (fn [x] (for [n (range (inc (count x)))]\n                    (concat (take n x) [nil] (drop n x))))\n        f2 (fn [x] (apply min (map diff x (repeat o2))))\n        f (fn [x] (let [y (mapcat m x) n (f2 y)]\n                    (distinct (filter #(= (diff % o2) n) y))))\n        i (take-while #(not= (count (first %)) (count o2)) (iterate f [o1]))]\n\n    (cond\n      (> (count o1) (count o2)) (ld o2 o1)\n      (= (count o1) (count o2)) (diff o1 o2)\n      :else (apply min (map diff (f (last i)) (repeat o2))))))", "problem": 101, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn dist\n  [x y]\n  (let [dist' (promise)]\n    (deliver dist'\n             (memoize\n               (fn [xs ys]\n                 (cond\n                   (empty? xs) (count ys)\n                   (empty? ys) (count xs)\n                   :else (let [[a & as] xs [b & bs] ys]\n                           (min (+ (if (= a b) 0 1)\n                                   (@dist' as bs))\n                                (inc (@dist' (cons a as) bs))\n                                (inc (@dist' as (cons b bs)))))))))\n    (@dist' x y)))", "problem": 101, "user": "52357ca6e4b0a643f2dcb74d"}, {"code": "#(let [ld (memoize\n             (fn [f [x & r :as xs] [y & s :as ys]]\n               (cond\n                 (nil? x) (count ys)\n                 (nil? y) (count xs)\n                 (= x y) (f f r s)\n                 :else (min (inc (f f r ys))\n                            (inc (f f xs s))\n                            (inc (f f r s))))))]\n    (ld ld % %2))", "problem": 101, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn levin [q r]\n  ((fn lev [[q-head & q-tail :as q] [r-head & r-tail :as r] verboten]\n    (cond\n      (and (nil? q-head) (nil? r-head)) 0\n      (or  (nil? q-head) (nil? r-head)) (max (count q) (count r))\n      (= q-head r-head) (levin q-tail r-tail)\n      :else\n        (inc \n          (cond\n            (= verboten :none)   (min (lev q-tail r-tail :none) (lev q r-tail :delete) (lev q-tail r :insert))\n            (= verboten :delete) (min (lev q-tail r-tail :none) (lev q r-tail :delete))\n            (= verboten :insert) (min (lev q-tail r-tail :none) (lev q-tail r :insert))))))\n  q r :none))", "problem": 101, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn [a b]\n  (letfn [(dp [mem-dp a b]\n              (let [mem-dp #(mem-dp mem-dp %1 %2)]\n                (if (or (empty? a) (empty? b)) \n                  (max (count a) (count b))\n                (min \n                 (+\n                  (if (= (last a) (last b)) 0 1)\n                  (mem-dp (butlast a) (butlast b)))\n                 (inc (mem-dp (butlast a) b))\n                 (inc (mem-dp a (butlast b)))))))]\n    (dp (memoize dp) a b)))", "problem": 101, "user": "51944aaae4b0142f60b4aedc"}, {"code": "#(let [m (count %) n (count %2)]\n    (nth (nth ((fn f\n       ([c j] (f (rest c) [(first c)] j))\n       ([s d j]\n         (if (empty? s)\n           (if (<= (inc j) n) (f d (inc j)) d)\n           (f (rest s)\n             (conj d\n               (let [c (first s) p (last d) i (count d) a (split-at j c) j1 (dec j)]\n                 (concat\n                   (first a)\n                   [(if (= (nth % (dec i)) (nth %2 j1))\n                      (nth p j1)\n                      (inc (min (nth p j) (nth c j1) (nth p j1))))]\n                   (rest (second a))))) j)))\n       )\n      (conj (for [i (range 1 (inc m))] (conj (take n (repeat 0)) i)) (range (inc n))) 1) m) n))", "problem": 101, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [s1 s2]\n  (let [cost (fn [c1 c2] (if (= c1 c2) 0 1))\n        lev-it (fn [d cs i]\n                 (reductions \n                   (fn [pc [[pd cd] c]] \n                     (if (zero? c) pd \n                       (+ c (min pc pd cd)))) \n                   i (map list (partition 2 1 d) cs)))]\n    (last (reduce (fn [d c] \n                    (lev-it d (map (partial cost c) s1) \n                            (inc (first d)))) \n                  (range (inc (count s1))) s2))))", "problem": 101, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn lv [s1 s2]\n  (let [l1 (count s1)\n        l2 (count s2)\n        matrix (into [] (map vec (cons (range (inc l2)) (for [i (range 1 (inc l1))] (cons i (repeat l2 0))))))]\n    (loop [i 1\n           m matrix]\n      (if (<= i l1)\n        (recur (inc i) (assoc m i\n                              (loop [j 1\n                                     m2 m\n                                     r (get m i)]\n                                (let [c1 (get s1 (dec i))\n                                      c2 (get s2 (dec j))\n                                      prev (get\tm2 (dec\ti))\n                                      r2 (assoc r j\n                                                (if (= c1 c2)\n                                                  (get prev (dec j))\n                                                  (inc (min\n                                                        (get prev j)\n                                                        (get (get m2 i) (dec j))\n                                                        (get prev (dec j))))))]\n                                  (if (< j l2)\n                                    (recur (inc j) (assoc m2 i r2) r2)\n                                    r2)))))\n        (last (last m))))))", "problem": 101, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [a b]\n  ((fn lvn [a b i j]\n     (if (or (zero? i) (zero? j))\n       (max i j)\n       (if (= (nth a (dec i)) (nth b (dec j)))\n         (lvn a b (dec i) (dec j))\n         (inc\n          (min\n           (lvn a b (dec i) j)\n           (lvn a b i (dec j))\n           (lvn a b (dec i) (dec j)))))))\n   a b (count a) (count b)))", "problem": 101, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn levenshein [a b]\n  (let [[s1 s2] (if (> (count a) (count b))\n                  [a b]\n                  [b a])\n        lev-thing (fn [c1 s2 mat]\n                    (loop [i 1\n                           a [(inc (first mat))]]\n                      (cond (> i (count s2)) a\n                            (= c1 (nth s2 (dec i))) (recur (inc i) (conj a (nth mat (dec i))))\n                            :else (recur (inc i)\n                                         (conj a (inc (min (nth mat i)\n                                                           (nth mat (dec i))\n                                                           (last a))))))))]\n    (last (reduce (fn [p s]\n                    (lev-thing  s s2 p))\n                    (range (inc (count s1)))\n                    s1))))", "problem": 101, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn [x y]\n  (let [n (count x)\n        m (count y)\n        idx (fn [i j] (+ (* i (inc m)) j))\n        d (loop [d (vec (for [i (range 0 (inc n))\n                              j (range 0 (inc m))]\n                          (cond\n                            (zero? i) j\n                            (zero? j) i\n                            :else 0)))\n                 i 1\n                 j 1]\n            (if (> i n)\n              d\n              (let [i' (if (= j m) (inc i) i)\n                    j' (if (= j m) 1 (inc j))\n                    e (if (= (nth x (dec i)) (nth y (dec j)))\n                        (nth d (idx (dec i) (dec j)))\n                        (min (inc (nth d (idx i (dec j))))\n                             (inc (nth d (idx (dec i) j)))\n                             (inc (nth d (idx (dec i) (dec j))))))\n                    ]      \n                (recur (assoc d (idx i j) e) i' j'))))\n             \n        ]\n    (nth d (idx n m))))", "problem": 101, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "#(let [lev (fn [a b lev*] (let [i (count a) j (count b)] \n                     (if (zero? (min i j)) (max i j)\n\t                      (min (inc (lev* (rest a) b lev*)) \n\t\t                       (inc (lev* a (rest b) lev*))\n\t\t\t                   (+ (if (= (first a) (first b)) 0 1) \n\t\t\t                      (lev* (rest a) (rest b) lev*))))))\n\t\tl (memoize lev)]\n\t(l %1 %2 l))", "problem": 101, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn l-d [left right]\n  (let [cache (atom {})]\n    (letfn [(lev-dist [left right]\n              (let [cost (if (= (last left) (last right)) 0 1)\n                    key [(count left) (count right)]]\n                (cond \n                  (= 0 (count left)) \n                      (do (swap! cache assoc key (count right)) (count right))\n                  (= 0 (count right)) \n                      (do (swap! cache assoc key (count left)) (count left))\n                  (contains? @cache key) (get @cache key)\n                  :else \n                  (let [val \n                          (min \n                            (inc (get @cache key (lev-dist (butlast left) right)))\n                            (inc (get @cache key (lev-dist left (butlast right))))\n                            (+ cost (get @cache key (lev-dist (butlast left) (butlast right)))))]\n                    (do (swap! cache assoc key val) val)))))]\n      (lev-dist left right))))", "problem": 101, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn lev [x y]\n  (let [xlen (count x) ylen (count y)]\n    (if (= 0 (min xlen ylen))\n      (max xlen ylen)\n      (loop [v 0 h -1 prev (vec (range (inc xlen))) curr (vec (range (inc xlen)))]\n        (if (= v ylen)\n          (last prev)\n\t\t  (if (< h 0)\n\t\t    (recur v (inc h) prev (assoc curr 0 (inc v)))\n            (if (= h xlen)\n              (recur (inc v) -1 curr curr)\n\t\t\t  (let [cost (if (= (nth x h) (nth y v)) 0 1)\n\t\t\t\t\ta (inc (nth curr h))\n\t\t\t\t\tb (inc (nth prev (inc h)))\n\t\t\t\t\tc (+ (nth prev h) cost)\n\t\t\t\t   ]\n\t\t\t\t(recur v (inc h) prev (assoc curr (inc h) (min a b c)))\n\t\t\t  )\n            )\n\t\t  )\n        )\n      )\n    )\n  )\n)", "problem": 101, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn f [s t]\n  (cond (= s t) 0\n        (empty? s) (count t)\n        (empty? t) (count s)\n        :else\n        (loop [i 0 v (range 0 (inc (count t)))]\n          (if (= i (count s))\n            (last v)\n            (recur (inc i)\n                   (loop [j 0 v1 [(inc i)]]\n                     (if (= j (count t))\n                       v1\n                       (let [cost (if (= (nth s i) (nth t j)) 0 1)]\n                         (recur (inc j) (concat v1 [(min (inc (last v1)) (inc (nth v (inc j))) (+ (nth v j) cost))]))))))))))", "problem": 101, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [s t]\n  (let [ss (vec (seq s)) tt (vec (seq t))]\n    (loop [i (range (count s)) v0 (vec (range (inc (count t))))]\n      (if (empty? i) (peek v0)\n          (recur (rest i)\n                 (loop [jr (range (count tt)) v1 [(inc (first i))]]\n                   (if (empty? jr) v1\n                       (let [j (first jr)\n                             cost (if (= (get ss (first i)) (get tt j)) 0 1)]\n                         (recur (rest jr) (conj v1\n                                                (min (inc (get v1 j))\n                                                     (inc (get v0 (inc j)))\n                                                     (+ (get v0 j) cost))))))))))))", "problem": 101, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn levendist [a b]\n  (let [lendiff (- (count a) (count b))\n        value (fn [target current] (reduce + (map #(if (= % %2) 0 1) current target)))\n        drop-nth (fn drop-nth [n s] (concat (take n s) (drop (inc n) s)))\n        shorten-single (fn [s] (map #(drop-nth % s) (range (count s)) ))\n        shortened-set (fn [start steps]\n                        (loop [c (conj #{} start) s steps]\n                          (if (= 0 s)\n                            c\n                            (recur (into #{} (apply concat (map shorten-single c))) (dec s)))))\n        find-best-value (fn [s target]\n                          (apply min-key last\n                                 (map (juxt identity (partial value target)) s)))\n        ]\n    (if (< lendiff 0)\n      (levendist b a)\n      (+ lendiff (last (find-best-value (shortened-set a lendiff) b))))))\n\n; removes elements from the longer sequence until equal length - finds the best match from all possibilities\n; the levenshtein distance is then the number of not yet matching elements plus the number of elements that needed removing", "problem": 101, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn edit-dist [coll1 coll2]\n  (let [n (count coll1)\n        m (count coll2)\n        board (vec (map \n                     #(vec (take (inc m) (iterate inc %))) \n                     (range (inc n))))]\n    (loop [i 1, j 1, res board]\n      (cond\n        (> i n) ((res n) m)\n        (> j m) (recur (inc i) 1 res)\n        :else (let [x (inc ((res (dec i)) j))\n                    y (inc ((res i) (dec j)))\n                    add (if (= (get coll1 (dec i)) (get coll2 (dec j))) 0 1)\n                    z (+ add ((res (dec i)) (dec j)))\n                    new-res (assoc res i (assoc (res i) j (min x y z)))]\n                (recur i (inc j) new-res))))))", "problem": 101, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(let [levenshtein (fn [levenshtein-m x1 x2]\n                      (let [levenshtein (partial levenshtein-m levenshtein-m)]\n                        (cond\n                          (empty? x2) (count x1) \n                          (empty? x1) (count x2)\n                          (= (first x1) (first x2)) (levenshtein (rest x1) (rest x2))\n                          :else (inc (min (levenshtein (rest x1) x2) \n                                          (levenshtein x1 (rest x2))\n                                          (levenshtein (rest x2) (rest x1)))))))]\n    (partial levenshtein (memoize levenshtein)))", "problem": 101, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn levi1 [s t]\n  (let[scnt (inc(count t)) tcnt (inc(count s)) sv (vec t) tv (vec s)\n       val-for (fn [m i j]\n                 (cond (= 0 i) j\n                       (= 0 j) i\n                       :else \n                       (min(inc(get-in m [(dec i) j]))\n                           (inc(get-in m [i (dec j)]))\n                           (+ (get-in m [(dec i)(dec j)]) \n                              (if (= (get sv (dec i))(get tv (dec j))) 0 1)))))\n       ]\n    (loop [i 0 j 0 mtx {}]\n      (if (> i scnt)\n        (get-in mtx [scnt tcnt])\n        (recur\n         (if (= j tcnt) (inc i) i)\n         (if (= j tcnt) 0 (inc j))\n         (assoc-in mtx [i j] (val-for mtx i j))\n         )))))", "problem": 101, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn distance [str1 str2]\n  (let [f (fn [lev str1 str2]\n            (let [len1 (count str1)\n                  len2 (count str2)\n                  match (= (first str1) (first str2))]\n              (cond (zero? len1) len2\n                (zero? len2) len1\n                (true? match) (lev lev (rest str1) (rest str2))\n                :else (min (inc (lev lev (rest str1) str2))\n                        (inc (lev lev str1 (rest str2)))\n                        (inc (lev lev (rest str1) (rest str2)))))))]\n    (f (memoize f) (vec str1) (vec str2)))\n)", "problem": 101, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn levd [a b]\n  (let [a1 (first a) b1 (first b)]\n  (cond\n    (nil? a1) (count b)\n    (nil? b1) (count a)\n    (= a1 b1) (levd (rest a) (rest b))\n  :else\n    (inc (min (levd (rest a) (rest b)) (levd a (rest b)) (levd (rest a) b))))))", "problem": 101, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn\n  [s t]\n  (let [len-s (count s)\n        len-t (count t)\n        prev (ref (apply vector (range (inc (count t)))))\n        cur  (ref (apply vector (repeat (inc (count t)) 0)))]\n    (if (or (= 0 len-s) (= 0 len-t))\n      (max len-s len-t)\n      (do\n        (doseq [i (range len-s)]\n          (dosync\n           (alter cur #(assoc % 0 (inc i))))\n          (doseq [j (range len-t)]\n            (let [cost (if (= (nth s i) (nth t j)) 0 1)\n                  prev-col (nth @cur j)\n                  prev-row (nth @prev (inc j))\n                  prev-row-col (nth @prev j)]\n              (dosync\n               (alter cur #(assoc % (inc j)\n                                  (min (inc prev-row)\n                                       (inc prev-col)\n                                       (+ cost prev-row-col))))\n\t       (alter prev #(assoc % j (nth @cur j)))))))\n        (last @cur)))))", "problem": 101, "user": "529936e7e4b02ebb4ef7507b"}, {"code": "(fn [x y]\n  (let [pairs (for [i (range 1 (inc (count x))), j (range 1 (inc (count y)))] [i j])\n        initial-table (merge (into {} (map (fn [i] [[i 0] i]) (range 0 (inc (count x)))))\n                             (into {} (map (fn [j] [[0 j] j]) (range 0 (inc (count y))))))\n        table (reduce (fn [table [i j]]\n                        (assoc table [i j]\n                               (if (= (get x (dec i)) (get y (dec j)))\n                                 (table [(dec i) (dec j)])\n                                 (inc (min (table [(dec i) j])\n                                           (table [i (dec j)])\n                                           (table [(dec i) (dec j)]))))))\n                      initial-table\n                      pairs)]\n    (table [(count x) (count y)])))", "problem": 101, "user": "510acd6ee4b078ea719210f4"}, {"code": "(memoize\n  (let [lev (memoize (fn [lev w1 w2]\n                       (if (or (empty? w1) (empty? w2))\n                         (max (count w1) (count w2))\n                         (let [init1 (butlast w1)\n                               init2 (butlast w2)]\n                           (min (inc (lev lev init1 w2))\n                                (inc (lev lev w1 init2))\n                                (+ (lev lev init1 init2)\n                                   (if (= (last w1) (last w2)) 0 1)))\n                           ))))]\n    (partial lev lev)))", "problem": 101, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn [a b]\n  (let [m (count a)\n        n (count b)\n        row-1 (atom (vec (range (inc m))))\n        row (atom (mapv inc @row-1))]\n    (dotimes [i n]\n      (doseq [j (range 1 (inc m))]\n        (swap! row assoc j (min (inc (@row (dec j)))\n                                (inc (@row-1 j))\n                                (+ (@row-1 (dec j))\n                                   (if (= (nth a (dec j)) (nth b i))\n                                     0\n                                     1)))))\n      (reset! row-1 @row)\n      (swap! row (partial mapv inc)))\n    (last @row-1)))", "problem": 101, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn [s t]\n  (let [sl (count s)\n        tl (count t)]\n    (cond\n     (= s t) 0\n     (empty? s) tl\n     (empty? t) sl\n     :else\n     (last\n      (loop [i 0\n             v (-> tl inc range vec)]\n        (if (= i sl) v\n            (recur (inc i)\n                   (loop [v-new [(inc i)]]\n                     (if (= tl (-> v-new count dec)) v-new\n                         (let [j (-> v-new count dec)\n                               cost (if (= (nth s i) (nth t j)) 0 1)\n                               v0_j (nth v j)\n                               v0_jp1 (nth v (inc j))\n                               v1_j (last v-new)]\n                           (recur\n                            (conj v-new\n                                  (min\n                                   (inc v1_j)\n                                   (inc v0_jp1)\n                                   (+ v0_j cost))))))))))))))", "problem": 101, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn lev-norec [a b]\n  (let [m (inc (count a))\n        n (inc (count b))\n        av (vec a)\n        bv (vec b)\n        matrix (to-array-2d (repeat m (vec (repeat n 0))))]\n    (doseq [i (range 1 m)]\n      (aset matrix i 0 i))\n    (doseq [j (range 1 n)]\n      (aset matrix 0 j j))\n    (doseq [j (range 1 n)]\n      (doseq [i (range 1 m)]\n        (aset matrix i j\n              (if (= (av (dec i)) (bv (dec j)))\n                (aget matrix (dec i) (dec j))\n                                        ;else\n                (min (inc (aget matrix (dec i) j))\n                     (inc (aget matrix i (dec j)))\n                     (inc (aget matrix (dec i) (dec j))))))))\n    (aget matrix (dec m) (dec n))))", "problem": 101, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(fn [a b]\n  (let [[a b] (sort-by count [a b])\n        rm-one (fn [w]\n                  (map \n                   #(concat (take % w) (drop (inc %) w))\n                   (range (count w))))]\n    (loop [a (vec a) b [(vec b)] n 0]\n      (if (< (count a) (count (first b)))\n        (recur a (set (mapcat rm-one b)) (inc n))\n        (+ n (apply min \n                  (map\n                    (fn [bi] (apply + (map #(if (= %1 %2) 0 1) a bi)))\n                    b)))))))", "problem": 101, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn edit-distance-mem [a b]\n  (let [f (fn [rec s1 s2]\n            (let [cost? (fn [p q]\n                          (if (= p q) 0 1))]\n              (cond\n               (and (= 0 (count s1)) (= 0 (count s2))) 0\n               (zero? (count s1)) (count s2)\n               (zero? (count s2)) (count s1)\n               :else (min (inc (rec rec s1 (rest s2)))\n                          (inc (rec rec (rest s1) s2))\n                          (+ (cost? (first s1) (first s2))\n                             (rec rec (rest s1) (rest s2)))\n                             ))))]\n    (f (memoize f) a b)))", "problem": 101, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn n101 [s t]\n  (cond \n    (zero? (count s)) (count t)\n    (zero? (count t)) (count s)\n    :else (let [m (count s) n (count t) \n               d0 (vec (repeat (inc n) (vec (repeat (inc m) 0)))) \n               d (loop [j 0 d (loop [i 0 d1 d0]\n                                (if (> i m) d1\n                                  (recur (inc i) (assoc-in d1 [0 i] i))))]\n                   (if (> j n) d\n                     (recur (inc j) (assoc-in d [j 0] j))))]\n           (get-in (loop [j 1 tc (nth t (dec j)) d1 d]\n                   (if (> j n) d1 \n                     (recur (inc j) (if (= j n) (nth t (dec j)) (nth t j))\n                            (loop [i 1 sc (nth s (dec i)) d2 d1]\n                              (if (> i m) d2 \n                                (if (= tc sc)\n                                  (recur (inc i) (if (= i m) (nth s (dec i)) (nth s i)) (assoc-in d2 [j i] (get-in d2 [(dec j) (dec i)])))\n                                  (recur (inc i) (if (= i m) (nth s (dec i)) (nth s i)) (assoc-in d2 [j i] (min (inc (get-in d2 [(dec j) (dec i)]))\n                                                                                   (inc (get-in d2 [(dec j) i]))\n                                                                                   (inc (get-in d2 [j (dec i)])))))))))))\n                   [n m])\n           )))", "problem": 101, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "#(let [[l g] (map vec (sort-by count [%1 %2]))\n              lc (count l)\n              add (- (count g) lc)]\n          (if (= lc 0)\n            add\n            (+ (if (and (apply not= (map (fn [x] (x (dec lc))) [g l]))\n                        (contains? (set (subvec g lc)) (l (dec lc))))\n                 (dec add)\n                 add)\n               (count (filter identity (map not= %1 %2))))))", "problem": 101, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn lev-dis [seq1 seq2]\n  (let [first-row (range (inc (count seq2)))\n        next-row (fn [pre-row row-index]\n                   (let [char1 (nth seq1 row-index)]\n                     (reduce #(conj %1 \n                                    (let [char2 (nth seq2 %2)\n                                          cost (if (= char2 char1) 0 1)\n                                          one-before (last %1)]\n                                      (min (inc one-before) \n                                           (inc (nth pre-row (inc %2)))\n                                           (+ cost (nth pre-row %2))))) \n                             [(inc row-index)] (range (count seq2)))))]\n    (last (reduce next-row first-row (range (count seq1))))))", "problem": 101, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(memoize (fn levenshtein [s t]\n            (cond\n             (= (count s) 0) (count t)\n             (= (count t) 0) (count s)\n             (= (first s) (first t)) (levenshtein (next s) (next t))\n             :else (+ 1\n                      (min\n                       (levenshtein (next s) (next t))\n                       (levenshtein s (next t))\n                       (levenshtein (next s) t))))))", "problem": 101, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "#(let [x (vec %2) y (vec %3)]\n   ((fn f [L M]\n      (let [l (dec L) m (dec M)]\n        (cond (= 0 L) M\n              (= 0 M) L\n              (= (x l) (y m)) (f l m)\n              :else (inc (min (f L m) (f l M) (f l m))))))\n    (% %2) (% %3))) count", "problem": 101, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn lev\n  [s1 s2]\n  (letfn\n    [(next-e\n      [e1 e2 prev curr index]\n      (if (= e1 e2) (nth prev (dec index))\n        (inc\n         (min\n          (nth prev (dec index))\n          (nth prev index)\n          (last curr)))))\n     (row\n      [e1 s2 prev curr]\n      (let [e2 (first s2)\n            index (count curr)]\n        (if (= (count curr) (count prev)) curr\n          (recur e1 \n                 (rest s2) \n                 prev \n                 (conj curr (next-e e1 e2 prev curr index))))))\n     (do-lv\n      ([s1 s2]\n       (let [init (vec (range 0 (inc (count s2))))]\n         (do-lv 1 init s1 s2)))\n      ([idx prev s1 s2]\n       (let [next-row (row (first s1) s2 prev (vector idx))]\n         (if (empty? (drop 1 s1)) (last next-row)\n           (recur (inc idx) next-row (drop 1 s1) s2)))))]\n    (cond\n     (empty? s1) (count s2)\n     (empty? s2) (count s1)\n     0 (do-lv s1 s2))))", "problem": 101, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [s t]\n  (let [d (fn d [i j]\n            (cond\n              (= 0 i) j\n              (= 0 j) i\n              (= (nth s (dec i)) (nth t (dec j))) (d (dec i) (dec j))\n              :default (inc (min (d (dec i) (dec j)) (d i (dec j)) (d (dec i) j)))))]\n     (d (count s) (count t))))", "problem": 101, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn ledis [a b]\n    (loop [md {[a b] 0}]\n      (let [nmd (reduce (fn [m n]\n                          (let [[a b] (key n) d (val n)\n                                [fa & ra] a\n                                [fb & rb] b]\n                            (merge-with min m (cond (= fa fb) {[ra rb] d}\n                                                    (nil? fa) {[nil nil] (+ d (count b))}\n                                                    (nil? fb) {[nil nil] (+ d (count a))}\n                                                  :else (zipmap [[ra b] [rb a] [ra rb]]\n                                                          (repeat (inc d)))))))\n                        {} md)\n            mid (nmd [nil nil])\n            nnm (if mid (into {} (filter #(<= (val %) mid) nmd)) nmd)]\n        (if (and mid (= 1 (count nnm))) (val (first nnm))\n            (recur nnm)))))", "problem": 101, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [x y]\n  (letfn [(lev-dist [[xfst & xrst :as x] [yfst & yrst :as y] dist]\n            (let [change (if (= xfst yfst) 0 1)]\n              (cond (empty? x) (+ dist change (count yrst))\n                    (empty? y) (+ dist change (count xrst))\n                    (zero? change) (recur xrst yrst dist)\n                    :else (min (lev-dist xrst yrst (inc dist))\n                               (lev-dist xrst y (inc dist))\n                               (lev-dist x yrst (inc dist))))))]\n    (lev-dist (seq x) (seq y) 0)))", "problem": 101, "user": "50645e12e4b007509339a58a"}, {"code": "(letfn [(lev [lf s1 s2]\n                (cond (empty? s1) (count s2)\n                      (empty? s2) (count s1)\n                      :otherwise (min (inc (lf lf (rest s1) s2))\n                                      (inc (lf lf s1 (rest s2)))\n                                      (+ (lf lf (rest s1) (rest s2)) (if (= (first s1) (first s2))\n                                                                     0\n                                                                     1)))))]\n        (let [mem (memoize lev)]\n          (partial mem mem)))", "problem": 101, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(let [edit-dis (fn [self s t]\n                 (cond\n                   (empty? s) (count t)\n                   (empty? t) (count s)\n                   :else (let [r1 (inc (self self s (rest t)))\n                               r2 (inc (self self (rest s) t))\n                               r3 (self self (rest s) (rest t))]\n                           (if (= (first s) (first t))\n                             (min r1 r2 r3)\n                             (min r1 r2 (inc r3))))))\n      edit-dis-m (memoize edit-dis)]\n  (partial edit-dis-m edit-dis-m))", "problem": 101, "user": "527cd633e4b0757a1b17136f"}, {"code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "problem": 101, "user": "52c4fe42e4b0c2d177d620e9"}, {"code": "(fn [x y]\n   (let [x2 (vec x) y2 (vec y) m (into [] (repeat (inc (count x2)) (into [] (repeat (inc (count y2)) [])))) m2 (reduce #(assoc-in %1 [%2 0] %2) m (range (inc (count x2)))) m3 (reduce #(assoc-in %1 [0 %2] %2) m2 (range (inc (count y2)))) m3 (loop [i 0 m m3]\n       (if (>= i (count x2))\n         m\n         (recur (inc i)\n                (loop [i2 0 m2 m]\n                  (if (>= i2 (count y2))\n                    m2\n                    (let [cost (if (= (x2 i) (y2 i2)) 0 1)\n                          min (min\n                               (+ ((m2 i) (inc i2)) 1)\n                               (+ ((m2 (inc i)) i2) 1)\n                               (+ cost ((m2 i) i2)))]\n                      (recur (inc i2) (assoc-in m2 [(inc i) (inc i2)] min))))))))]\n     ((m3 (count x2)) (count y2))))", "problem": 101, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn my-levenshtein-distance\r\n  [str1 str2]\r\n  (cond\r\n    (= str1 str2) 0\r\n    (= 0 (count str1)) (count str2)\r\n    (= 0 (count str2)) (count str1)\r\n    :else\r\n    (let [v0 (into [] (take (inc (count str2)) (range)))\r\n          calculate-cost (fn [x y] (if (= (get str1 x) (get str2 y)) 0 1))]\r\n      (loop [rowOld v0 i 0 ]\r\n        (if (= i (count str1))\r\n          (last rowOld)\r\n          (recur (loop [rowNew (vector (inc i)) j 1]\r\n                   (if (= j (inc (count str2)))\r\n                     rowNew\r\n                     (recur (conj rowNew (min\r\n                                           (inc (get rowNew (dec j)))\r\n                                           (inc (get rowOld j))\r\n                                           (+ (calculate-cost i (dec j)) (get rowOld (dec j))))) (inc j)))) (inc i)))))))", "problem": 101, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(let [f (memoize\n            (fn [g s t]\n              (cond\n                (empty? s) (count t)\n                (empty? t) (count s)\n                :else (min\n                        (+ (g g (rest s) t) 1)\n                        (+ (g g s (rest t)) 1)\n                        (+ (g g (rest s) (rest t)) (if (= (first s) (first t)) 0 1))))))]\n    (partial f f))", "problem": 101, "user": "4fb1325de4b081705acca276"}, {"code": "(fn ld [res des]\n  (letfn [(step [[ res des n]]\n            (cond\n             (or (empty? res) (empty? des))  ((juxt replace-item insert delete) [res des n])\n             (= (first res) (first des)) (step [(rest res) (rest des) n])\n             :else  ((juxt replace-item insert delete) [res des n])\n              ))\n          (insert [[ res des n]]\n                 (if (empty? des)\n                   nil\n                   [res (rest des) (+ 1 n)]))\n          (delete [[ res des n]]\n            (if (empty? res)\n              nil\n              [(rest res) des (+ 1 n)]))\n          (replace-item [[ res des n]]\n            (if (and (empty? res) (empty? des))\n              [[] [] n]\n              (if (or (empty? res) (empty? des))\n                nil\n                [(rest res) (rest des) (+ 1 n)])))]\n    (->>\n      (iterate (fn [queue] (filter (comp not nil?)  (mapcat step queue))) [ [res des 0]])\n      (drop-while #(not-any? (fn [[res des n]] (and (empty? res) (empty? des))) %))\n      first\n      (filter (fn [[res des n]] (and (empty? res) (empty? des))) )\n      (apply min-key last)\n      last\n    ; (take 3)\n     )))", "problem": 101, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(let [mem (atom {})]\n            (fn f [a b]\n              (if-let [e (find @mem [a b])]\n                (val e)\n                (let [ca (count a)\n                      cb (count b)\n                      ret (cond (zero? ca) cb\n                        (zero? cb) ca\n                        :else\n                        (let [;; cast to int\n                              cost (compare (not= (last a) (last b))\n                                            false)]\n                          (min (inc    (f (butlast a) b))\n                               (inc    (f a           (butlast b)))\n                               (+ cost (f (butlast a) (butlast b))))))]\n                  (swap! mem assoc [a b] ret)\n                  ret))))", "problem": 101, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn [I x y]\n  (last\n    (reduce\n      (fn [[i & r] y]\n        (map first (reductions\n                     (fn [[d s] [i x]] [(min (I d) (I i) (if (= x y) s (I s))) i])\n                     [(I i) i] (map list r x))))\n      (range (I (count x)))\n      y))) inc", "problem": 101, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn levenshtein [x y]\n  (let [next-char         (fn next-char [c d prev curr position]\n                            (if (= c d)\n                              (prev (- position 1))\n                              (+ 1 (min\n                                (prev (- position 1))\n                                (prev position)\n                                (last curr)))))\n  \n  \n        next-row        (fn next-row [a b prev curr]\n                          (let [c (first a)\n                                d (first b)\n                                position (count curr)]\n                            (if (= position (count prev))\n                              curr\n                              (next-row a (rest b)\n                                        prev\n                                        (conj curr\n                                              (next-char c d prev curr position))))))\n        \n\n        lev             (fn lev [row-num prev a b]\n                          (cond (zero? (count a)) (count b)\n                                (zero? (count b)) (count a)\n                                :else (let [next        (next-row a b prev (vector row-num))\n                                            a-remainder (rest a)]\n                                        (if (empty? a-remainder)\n                                          (last next)\n                                          (lev (inc row-num) next a-remainder b)))))\n                                  \n        ]\n                      \n    (lev 1 (vec (range (inc (count y)))) x y)))", "problem": 101, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn levenstein [s t]\n\t(letfn [\n\t\t(next-row [s i t t_len prev-row]\n\t\t\t(reduce  \n\t\t\t\t(fn [res j]  \n\t\t\t\t\t(let [cost (if (= (nth s i) (nth t j)) 0 1) \n\t\t\t\t\t\t  insertion (inc (last res)) \n\t\t\t\t\t\t  deletion (inc (nth prev-row (inc j)))\n\t\t\t\t\t\t  substitution (+ (nth prev-row j) cost)]\n\t\t\t\t\t\t(conj res (min insertion deletion substitution)) \n\t\t\t\t\t)\n\t\t\t\t) \n\t\t\t\t(vector (inc i)) (range t_len)\n\t\t\t)\n\t\t)\n\t\t(calc-distance [s t s_len t_len]\n\t\t\t(let [first-row (range (inc t_len)) result (reduce \n\t\t\t\t(fn [prev-row i]\n\t\t\t\t\t(next-row s i t t_len prev-row)\n\t\t\t\t) \n\t\t\t\t\tfirst-row (range s_len)\n\t\t\t\t)]\n\t\t\t\t(nth result t_len)\t\n\t\t\t)\n\t\t)]\n\t\t(let [s_len (count s) t_len (count t)]\n\t\t\t(if (zero? s_len) \n\t\t\t\tt_len\n\t\t\t\t(if (zero? t_len)\n\t\t\t\t\ts_len\n\t\t\t\t\t(if (= s t) \n\t\t\t\t\t\t0\n\t\t\t\t\t\t(calc-distance s t s_len t_len)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 101, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "; This would've been much simpler if I could actually use memoize.\n(fn lev [s t]\n  (cond\n   (= s t) 0\n   (empty? s) (count t)\n   (empty? t) (count s)\n   :else\n   (loop [v0 (range (inc (count t)))\n          i 0]\n     (if (= i (count s))\n       (last v0)\n       (recur\n        (loop [v1 [(inc i)]\n               j 0]\n          (if (= j (count t))\n            v1\n            (recur\n             (conj v1\n                   (min (inc (last v1))\n                        (inc (nth v0 (inc j)))\n                        (+ (nth v0 j) (if (= (nth s i) (nth t j)) 0 1))))\n             (inc j)\n             )\n            )\n          )\n        (inc i)\n        )\n       )\n     )\n   )\n  )", "problem": 101, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [a b]\n  (letfn [(step-differences [cnt a b]\n            (if (and (seq a) (seq b))\n              (let [[a1 & a-rest] a\n                    [b1 & b-rest] b]\n                (if (= a1 b1)\n                  (recur cnt a-rest b-rest)\n                  (min (step-differences (inc cnt) a b-rest)\n                       (step-differences (inc cnt) a-rest b)\n                       (step-differences (inc cnt) a-rest b-rest))))\n              (+ cnt (count a) (count b))))]\n      (step-differences 0 a b)))", "problem": 101, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [s t] \n (let [temp s\n       s (if (< (count s) (count t)) t s)\n       t (if (= s t) temp t)\n       len_s (count s) len_t (count t) \n       v0 (atom (apply hash-map (apply concat (for [i (range (inc len_s))] [i 0]))))\n       v1 (atom (apply hash-map (apply concat (for [i (range (inc len_t))] [i 0]))))]\n    (doseq [i (range (inc len_s))]\n         (swap! v0 assoc i i)\n    )\n    (doseq [i (range len_s)]\n      (swap! v1 assoc 0 (inc i))\n      (doseq [j (range len_t)]\n        (let [cost (if (= (nth s i) (nth t j)) 0 1)]\n          (swap! v1 assoc (inc j) (min\n             (inc (@v1 j))\n             (inc (@v0 (inc j)))\n             (+ cost (@v0 j))\n           )\n          )\n        )\n      )\n      (doseq [j (range (inc len_s))]\n         (swap! v0 assoc j (@v1 j))\n      )\n    )\n     (@v1 len_t)\n )\n)", "problem": 101, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn levenshtein [a b] (let [lev (fn [mem-lev a b x y] (let [lev (fn [a b x y] (mem-lev mem-lev a b x y))] (if (= 0 (min x y)) (max x y) (min (+ (lev a b (- x 1) y) 1) (+ (lev a b x (- y 1)) 1) (+ (lev a b (- x 1) (- y 1)) (if (= (nth a (dec x)) (nth b (dec y))) 0 1)))))) mem-lev (memoize lev)] (mem-lev mem-lev a b (count a) (count b))))", "problem": 101, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn numero-transformacoes [sequencia-pivot sequencia-bruta]\n  (letfn [(encontra-sub-seq [[primeiro-sequencia-pivot & outros-sequencia-pivot :as sequencia-pivot]\n                             [primeiro-sequencia-bruta & outros-sequencia-bruta :as sequencia-bruta]]\n                            (cond\n                             (or (empty? sequencia-pivot) (empty? sequencia-bruta)) [nil sequencia-pivot sequencia-bruta]\n                             (= primeiro-sequencia-pivot primeiro-sequencia-bruta) (let [[prox-seq-encontrada \n                                                                                          prox-seq-restante-pivot \n                                                                                          prox-seq-restante-bruta]\n                                                                                         (encontra-sub-seq outros-sequencia-pivot outros-sequencia-bruta)]\n                                                                                     [(cons primeiro-sequencia-pivot prox-seq-encontrada)\n                                                                                      prox-seq-restante-pivot\n                                                                                      prox-seq-restante-bruta])\n                             :else [nil sequencia-pivot sequencia-bruta]))\n          (encontra-padroes [seq-pivot seq-bruta]\n                            (let [encontrados (mapcat (fn [indice-seq-bruta] \n                                                        (map (fn [indice-seq-pivot]\n                                                               (let [[sequencia-comum sequencia-restante-pivot sequencia-restante-bruta]\n                                                                     (encontra-sub-seq (drop indice-seq-pivot seq-pivot)\n                                                                                       (drop indice-seq-bruta seq-bruta))]\n                                                                 (concat (list (list (take indice-seq-pivot seq-pivot)\n                                                                                     sequencia-comum\n                                                                                     sequencia-restante-pivot))\n                                                                         (list (list (take indice-seq-bruta seq-bruta)\n                                                                                     sequencia-comum\n                                                                                     sequencia-restante-bruta)))))\n                                                             (range (count seq-pivot))))\n                                                      (range (count seq-bruta)))]\n                              (filter (fn [[lista-pivot _]] (seq (second lista-pivot)))\n                                      encontrados)))]\n    (if (some (set sequencia-pivot) sequencia-bruta)\n      (let [padroes (encontra-padroes sequencia-pivot sequencia-bruta)]\n        (apply min\n               (map (fn [[[previa-pivot _ resto-pivot :as padroes-pivot] [previa-bruto _ resto-bruto :as padroes-brutos]]]\n                      (+ (numero-transformacoes previa-pivot previa-bruto)\n                         (numero-transformacoes resto-pivot resto-bruto)))\n                    padroes)))\n      (max (count sequencia-pivot) (count sequencia-bruta)))))", "problem": 101, "user": "52c8758be4b0c2d177d62135"}, {"code": "#((fn L [a b c]\n    (let [p (rest a)\n          q (rest b)\n          i (inc c)\n          f first\n          e empty?\n          n count]\n      (cond\n        (= a b)  c\n        (e a)    (+ c (n b))\n        (e b)    (+ c (n a))\n        (= (f a) (f b)) (L p q c)\n        1 (min\n                (L p b i)\n                (L a q i)\n                (L p q i)))))\n  % %2 0)", "problem": 101, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn ldist [coll1 coll2]\n  (let [c (- (count coll2)\n             (count coll1))]\n\n    (if (< c 0) (ldist coll2 coll1)\n     (+ (->> (map = coll1 coll2)\n              (butlast)\n              (filter false?)\n              (count))\n          (loop [ n      0,\n                  a      (last coll1),\n                 [b & r] (drop (dec (count coll1)) coll2)]\n            (cond\n             (nil? b) n\n             (= a b)  (+ n (count r))\n             :else    (recur (inc n) a r)))))))", "problem": 101, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn levenstein [s1 s2]\n  (last\n   (reduce \n    (fn [last-result s1-elem]\n      (loop [left (first last-result) \n             [[up-left up] & more] (partition 2 1 last-result)\n             result [(inc left)]\n             [s2-elem & s2-rest] s2\n             ]\n        (let [new-res (min (inc left) (inc up) (if (= s1-elem s2-elem) up-left (inc up-left)))]\n          (if (empty? s2-rest)\n            (conj result new-res)\n            (recur new-res more (conj result new-res) s2-rest)\n            )\n          )\n        )\n      )\n    (->> s2 (count) (inc )(range)) \n    s1\n    )))", "problem": 101, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn levenshtein [s t]\n  (let [init-matrix (fn [n m]\n                      (let [v (vec (for [x (range (inc n))] (into [x] (repeat m 0))))]\n                         (assoc v 0 (vec (range (inc m))))\n                        )\n                      )\n        \n        cost (fn [s t m i j]\n              (let [sub (get-in m [(dec i) (dec j)])\n                    ins (get-in m [(dec i) j])\n                    del (get-in m [i (dec j)])\n                    eqs (= (get s (dec i)) (get t (dec j)))\n                    subscost (if (not eqs) 1 0)\n                    ]\n                  (min (+ sub subscost) (+ 1 ins) (+ 1 del))\n                )\n              )\n        \n        dp (loop [i 1 m (init-matrix (count s) (count t))]\n            (if (<= i (count s))\n              (recur (inc i)\n                     (loop [j 1 m m]\n                       (if (<= j (count t))\n                         (recur (inc j) (update-in m [i j] + (cost s t m i j)))\n                         m\n                         )\n                       )\n                     )\n              m\n              )\n            )\n        ]\n    (get-in dp [(count s) (count t)])\n    )\n  )", "problem": 101, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn [s t]\n  (let [ls (inc (count s))\n        lt (inc (count t))\n        init-matrix (vec (for [i (range ls)] (vec (take lt (repeat 0)))))\n        indexes (for [i (range ls) j (range lt)] [i j])\n        minimum (fn [mtx i j] (min\n                  (+ 1 (get-in mtx [(dec i) (dec j)]))\n                  (+ 1 (get-in mtx [i (dec j)]))\n                  (+ 1 (get-in mtx [(dec i) j]))))\n        lev-dist (fn [mtx [i j]]\n                   (cond\n                    (= [0 0] [i j]) mtx\n                    (zero? i) (assoc-in mtx [i j] j)\n                    (zero? j) (assoc-in mtx [i j] i)\n                    (= (get s (dec i)) (get t (dec j)))\n                       (assoc-in mtx [i j]\n                                 (min (minimum mtx i j)\n                                      (get-in mtx [(dec i) (dec j)])))\n                    \n                    :else (assoc-in mtx [i j] (minimum mtx i j))))]\n    (last (last (reduce lev-dist init-matrix indexes)))))", "problem": 101, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn [str1 str2]\n  (let [lev (fn [s1 l1 s2 l2 f]\n     (cond (zero? l1) l2\n           (zero? l2) l1\n           :else (min (inc (f s1 (dec l1) s2 l2 f))\n                      (inc (f s1 l1 s2 (dec l2) f))\n                      (+ (f s1 (dec l1) s2 (dec l2) f)\n                         (if (= (nth s1 (dec l1)) \n                                (nth s2 (dec l2))) 0 1)))))\n          mlev (memoize lev)]\n     (mlev str1 (count str1) str2 (count str2) mlev)\n))", "problem": 101, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn levenstein [a b]\n  (let [one-if #(if % 1 0)\n        lev-functor (fn [mem i j]\n                      (let [lev (fn [i j] (mem mem i j))]\n                        (if (zero? (min i j))\n                          (max i j)\n                          (min\n                           (+ (lev (dec i) j) 1)\n                           (+ (lev i (dec j)) 1)\n                           (+ (lev (dec i) (dec j)) (one-if (not= (get a (dec i)) (get b (dec j)))))))))\n        mem (memoize lev-functor)\n        lev (partial mem mem)]\n    (lev (count a) (count b))))", "problem": 101, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn lv\n  [a b]\n  (let [x (vec a)\n        y (vec b)]\n    (letfn\n        [(L [l m]\n           (let [l- (- l 1)\n                 m- (- m 1)]\n             (cond (= 0 l) m\n                   (= 0 m) l\n                   (= (x l-) (y m-)) (L l- m-)\n                   :else (+ 1 (min\n                                   (L l m-)\n                                   (L l- m)\n                                   (L l- m-))))))]\n      (L (count x) (count y)))))", "problem": 101, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [a b]\n  (letfn [(step [calculated-result coordinate]\n            (let [x (first coordinate)\n                  y (last coordinate)]\n              (assoc calculated-result\n                coordinate\n                (if (zero? (min x y))\n                  (max x y)\n                  (min\n                    (inc (calculated-result [(dec x) y]))\n                    (inc (calculated-result [x (dec y)]))\n                    (+\n                      (calculated-result [(dec x) (dec y)])\n                      (if (= ((vec a) (dec x)) ((vec b) (dec y))) 0 1)))))))]\n    ((reduce step {} (apply concat (map #(map (fn [i] [% i]) (range 0 (inc (count b)))) (range 0 (inc (count a)))))) [(count a) (count b)])))", "problem": 101, "user": "50436470e4b034ff00315d23"}, {"code": "(fn levenshtein-distance [str1 str2]\n  (let [fast-distance (atom (fn [s1 s2] (println \"bogus - fast\")))\n        distance (fn distance [str1 str2]\n                   (let [len1 (count str1)\n                         len2 (count str2)]\n                     (cond (zero? len1) len2\n                           (zero? len2) len1\n                           :else\n                           (let [cost (if (= (first str1) (first str2)) 0 1)]\n                             (min (inc (@fast-distance (rest str1) str2))\n                                  (inc (@fast-distance str1 (rest str2)))\n                                  (+ cost\n                                     (@fast-distance (rest str1) (rest str2))))))))]\n    (reset! fast-distance (memoize distance))\n    (@fast-distance str1 str2)))", "problem": 101, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn [a b]\n  ((fn lev [x y]\n     (cond\n      (zero? x) y\n      (zero? y) x\n      (= (nth a (dec x) nil)\n         (nth b (dec y) nil)) (lev (dec x) (dec y))\n      :else (+ 1 (min\n                  (lev x (dec y))\n                  (lev (dec x) y)\n                  (lev (dec x) (dec y)))\n               )))\n   (count a) (count b)))", "problem": 101, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(letfn [(distance [step xs ys]\n          (cond\n           (empty? xs)\n           (count ys)\n           \n           (empty? ys)\n           (count xs)\n           \n           :else\n           (let [[x & sub-xs] xs\n                 [y & sub-ys] ys\n                 cost (if (= x y) 0 1)]\n             (min (inc (step step sub-xs ys))\n                  (inc (step step xs sub-ys))\n                  (+ cost (step step\n                                sub-xs\n                                sub-ys))))))]\n  \n  (let [step (memoize distance)]\n    (fn levenshtein [xs ys]\n      (step step xs ys))))", "problem": 101, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [s t]\n  (if (= s t)\n    0\n    (if (zero? (count s))\n      (count t)\n      (if (zero? (count t))\n        (count s)\n        (loop [i 0 v0 (apply vector (range 0 (inc(count t))))]\n          (if (= i (count s))\n            (last v0)               \n             (recur\n              (inc i)\n              (loop [j 0 v1 (apply vector (inc i) (repeat (count t) 0))]\n                (if (= j (count t))\n                   v1\n                   (recur\n                    (inc j)\n                    (update-in v1 [(inc j)]\n                               (fn [_](min\n                                 (inc(nth v1 j))\n                                 (inc(nth v0 (inc j)))\n                                 (+ (nth v0 j) (if (= (nth s i) (nth t j)) 0 1))  )))))))))))))", "problem": 101, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [m n]\n  (letfn [(f [[x y]]\n            (if (= (first x) (first y))\n              [(rest x) (rest y)]\n              [x y]))\n          (f1 [x]\n            (first\n              (drop-while #(= (first (first %)) (first (second %)))\n                          (iterate f x))))\n          (f2 [l]\n            (mapcat #(let [[a b] %]\n                       (vector\n                         [(rest a) b]\n                         [a (rest b)]\n                         [(rest a) (rest b)])) \n                    (map f1 l)))\n          (f3 [l]\n            (not-any? #(apply = %) l))\n          (f4 [l]\n            (count\n              (take-while\n                f3\n                (iterate f2 l))))]\n    (f4 [[m n]])))", "problem": 101, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [s t]\n  (letfn [(d [f s t]\n            (cond\n             (empty? s) (count t)\n             (empty? t) (count s)\n             1 (let [a (rest s)\n                     b (rest t)]\n                 (min (inc (f f a t))\n                      (inc (f f s b))\n                      (+ (if (= (first s) (first t)) 0 1)\n                         (f f a b))))))]\n    (d (memoize d) s t)))", "problem": 101, "user": "53460d02e4b084c2834f4a39"}, {"code": "#({\\s 3 \\l 1 \\x 2 \\1 6 \\C 0 nil 0 0 2 :a 2 \\t 10 \\a 9} (if (= \\c (first %2)) (nth %2 1) (first %2)))", "problem": 101, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [s t]\n    (let [s-size (count s)\n          t-size (count t)\n          max-count (* (inc s-size) (inc t-size))]\n      (loop [grid {}]\n        (if (= max-count (count grid))\n          (get grid [s-size t-size])\n          ;;grid\n          (let [i (count grid)\n                r (int (/ i (inc t-size)))\n                c (mod i (inc t-size))]\n            (cond\n             (zero? r) \n             (recur (assoc grid [r c] c))\n\n             (zero? c) \n             (recur (assoc grid [r c] r))\n\n             (= (get s (dec r)) (get t (dec c)))\n             (recur (assoc grid [r c] (get grid [(dec r) (dec c)])))\n\n             :else \n             (let [left (get grid [r (dec c)])\n                   up (get grid [(dec r) c])\n                   up-left (get grid [(dec r) (dec c)])\n                   cost (inc (min up up-left left))]\n               (recur (assoc grid [r c] cost)))))))))", "problem": 101, "user": "530b8580e4b02e82168697cc"}, {"code": "(fn edit-distance [a b]\n  (let [edfn (fn [edf a b]\n               (if-let [[a0 & as] (seq a)]\n                 (if-let [[b0 & bs] (seq b)]\n                   (if (= a0 b0)\n                     (edf edf as bs)\n                     (inc (min (edf edf as b)\n                               (edf edf as bs)\n                               (edf edf a bs))))\n                   (count a))\n                 (count b)))\n        memoized-edfn (memoize edfn)]\n    (memoized-edfn memoized-edfn a b)))", "problem": 101, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn [sx sy]\n  (let [lx (count sx) ly (count sy)]\n    (if (= 0 lx)\n      ly\n      (if (= 0 ly)\n        lx\n        (loop [x 0 y 0 dx_1 (into [] (range (inc ly))) dx [1]]\n          (if (= y ly)\n            (if (= x (dec lx))\n              (last dx)\n              (recur (inc x) 0 dx [(inc x)])\n            )\n            (let [c (if (= (nth sx x) (nth sy y)) 0 1)  d1 (inc (nth dx_1 (inc y))) d2 (inc (last dx)) d3 (+ (nth dx_1 y) c)]\n              (recur x (inc y) dx_1 (conj dx (min d1 d2 d3)))\n            )  \n          )\n        )\n      )\n    )\n  )\n)", "problem": 101, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn lev [s1 s2]\n  (let [c1 (count s1) c2 (count s2)]\n    (cond\n      (= c1 c2) (count (filter not (map = s1 s2)))\n      (< c1 c2) (recur s2 s1)\n      :else (letfn [(remove-nth [n s] (concat (take n s) (rest (drop n s))))\n                    (reduced-by-one [s] (map-indexed remove-nth (repeat (count s) s)))]\n              (inc (apply min (map #(lev s2 %) (reduced-by-one s1))))))))", "problem": 101, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [w1 w2]\n  (if (or (zero? (count w1)) (zero? (count w2)))\n    (+' (count w1) (count w2))\n    (let [fr (range (inc' (count w1)))\n          upper1 (count w1)\n          upper2 (inc' (count w2))\n          diff (fn [wr1 wr2 ln1 ln2] (if (= (nth wr1 ln1) (nth wr2 ln2)) 0 1))\n          edd (fn [wr1 wr2 ln1 ln2 prevr currr] (min (inc' (nth prevr ln1))\n                                                    (inc' (last currr))\n                                                    (+' (nth prevr (dec' ln1)) (diff wr1 wr2 ln1 ln2))))\n          pw1 (concat [[]] w1)\n          pw2 (concat [[]] w2)]\n      (loop [n1 1 n2 1 pr fr cr [1]]\n        (cond\n         (= n2 upper2) (last pr)\n         (< n1 upper1) (recur (inc' n1) n2 pr (concat cr [(edd pw1 pw2 n1 n2 pr cr)]))\n         (= n1 upper1) (recur 1 (inc' n2) (concat cr [(edd pw1 pw2 n1 n2 pr cr)]) [(inc' n2)]))))))", "problem": 101, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn __\n  [s1 s2]\n  (let [seqs (if (> (count s1) (count s2)) [s2 s1] [s1 s2])\n        a (vec (first seqs))\n        b (vec (second seqs))\n        n (count a)\n        m (count b)\n        matrix (reduce (fn [r i]\n                         (conj r (vec (cons i (take n (repeat 0))))))\n                       [(vec (range (inc n)))] (range 1 (inc m)))\n        idx (for [x (range 1 (inc m))\n                  y (range 1 (inc n))]\n              [x y])]\n    \n    (last\n      (last\n        (reduce (fn [r [i j]]\n                  (let [change (if (not= (a (dec j)) (b (dec i)))\n                                 (inc (get-in r [(dec i) (dec j)]))\n                                 (get-in r [(dec i) (dec j)]))\n                        add (inc (get-in r [(dec i) j]))\n                        delete (inc (get-in r [i (dec j)]))\n                        value (min change add delete)]\n                    (assoc-in r [i j] value)))\n                matrix idx)))\n  ))", "problem": 101, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "#(let [m (max (count %2) (count %3))]\n   (% 0 m %2 %3))\n(fn g [a m [x & y :as p] [u & v :as q]]\n  (cond (= p q) a\n        (= a m) a\n        (= x u) (g a m y v)\n        1 (min (g (+ a 1) m y q)\n               (g (+ a 1) m y v)\n               (g (+ a 1) m p v))))", "problem": 101, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn __ [coll1 coll2]\n  (let [leven (memoize\n                (fn [self [x & xs :as xall] [y & ys :as yall]]\n                  (cond\n                    (empty? xall) (count yall)\n                    (empty? yall) (count xall)\n                    :else (min\n                            (+ (if (= x y) 0 1) (self self xs ys))\n                            (inc (self self xs yall))\n                            (inc (self self xall ys))))))]\n    (leven leven coll1 coll2)))", "problem": 101, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(letfn [(D [s t]\n          (cond (empty? s) (count t)\n                (empty? t) (count s)\n                (= (first s) (first t)) (D (rest s) (rest t))\n                :else (inc (min (D (rest s) t)\n                                (D s (rest t))\n                                (D (rest s) (rest t))))))]\n  D)", "problem": 101, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn [s t]\n  (let [lev (memoize (fn [s t rec-lev]\n                       (let [ns (count s)\n                             nt (count t)]\n                         (cond (= ns 0) nt\n                               (= nt 0) ns\n                               :else (let [cost (if (= (first s) (first t)) 0 1)\n                                           rest-s (rest s)\n                                           rest-t (rest t)]\n                                       (min\n                                         (inc (rec-lev rest-s t rec-lev))\n                                         (inc (rec-lev s rest-t rec-lev))\n                                         (+ cost (rec-lev rest-s rest-t rec-lev))))))))]\n    (lev s t lev)))", "problem": 101, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn edit-dist [s1 s2]\n  (cond\n    (= 0 (count s1)) (count s2)\n    (= 0 (count s2)) (count s1)\n    :else\n    (letfn [(init-E []\n              (let [mindices (range (inc (count s1)))\n                    nindices (range (inc (count s2)))]\n               (merge (zipmap (map #(vector % 0) mindices) mindices)\n                      (zipmap (map #(vector 0 %) nindices) nindices))))\n\n            (diff [i j]\n              (if (= (nth s1 (dec i)) (nth s2 (dec j)))\n                0\n                1))\n\n            (dist [i j E]\n              (min (inc (E [(dec i) j]))\n                   (inc (E [i (dec j)]))\n                   (+ (E [(dec i) (dec j)])\n                      (diff i j))))]\n\n      (let [cells (for [i (range 1 (inc (count s1)))\n                        j (range 1 (inc (count s2)))]\n                    [i j])]\n        (loop [E (init-E)\n               [[i j] & more-cells] cells]\n          (let [d (dist i j E)]\n            (if (seq more-cells)\n              (recur (assoc E [i j] d)\n                     more-cells)\n              d)))))))", "problem": 101, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(let [cache (atom {})]\n         (fn ld [a b]\n           (if-let [d (@cache [a b])]\n             d\n             (let [d (cond\n                      (empty? a) (count b)\n                      (empty? b) (count a)\n                      (= (first a) (first b)) (ld (rest a) (rest b))\n                      :else (+ 1\n                               (min (ld (rest a) b) ; deletion\n                                    (ld a (rest b)) ; insertion\n                                    (ld (rest a) (rest b)) ; replace\n                                    )))]\n               (swap! cache assoc [a b] d)\n               d))))", "problem": 101, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn levenshtein [s t]\n  (let [helper (memoize (fn [f s slen t tlen]\n                          (cond\n                           (zero? slen) tlen\n                           (zero? tlen) slen\n                           :else (let [cost (if (= (nth s (dec slen)) (nth t (dec tlen))) 0 1)]\n                                   (min (+ (f f s (dec slen) t tlen)          1)\n                                        (+ (f f s slen       t (dec tlen))    1)\n                                        (+ (f f s (dec slen) t (dec tlen)) cost))))))]\n    (helper helper s (count s) t (count t))))", "problem": 101, "user": "530bf87ee4b02e82168697d5"}, {"problem": 101, "code": "(fn levenshtein [str1 str2]\n  (if (or (= 0 (count str1)) (= 0 (count str2))) (max (count str1) (count str2))\n    (let [nrows (inc (count str2))\n          ncols (inc (count str1))\n          init-matrix (vec (map (fn create-row [i]\n                                  (if (= i 0)\n                                    (vec (range ncols))\n                                    (vec (cons i (repeat (dec ncols) nil)))))\n                                (range nrows)))]\n      (loop [i 1 \n             j 1 \n             matrix init-matrix]\n        (let [new-val (min (inc (get-in matrix [(dec i) j]))\n                           (inc (get-in matrix [i (dec j)]))\n                           (+ (get-in matrix [(dec i) (dec j)])\n                              (if (= (nth str1 (dec j))\n                                     (nth str2 (dec i)))\n                                0\n                                1)))]\n          (if (and (= i (dec nrows)) (= j (dec ncols)))\n            new-val\n            (let [[next-i next-j] (if (< j (dec ncols))\n                                    [i (inc j)]\n                                    [(inc i) 1])]\n              (recur next-i next-j (assoc-in matrix [i j] new-val)))))))))", "user": "529e3a4fe4b04e0c58e87b92"}, {"problem": 101, "code": "(fn [s1 s2] \n  (if (= s1 s2) 0\n  (let [m (count s1)\n        n (count s2)\n        init (vec (for [u (range (inc m))] \n                          (apply vector (for [v (range (inc n))] 0))))\n        initx (reduce #(assoc-in % [%2 0] %2) init  (range 1 (inc m)))\n        initxy (reduce #(assoc-in % [0 %2] %2) initx (range 1 (inc n)))\n        charAt (fn [msg p] (if (>= p 0) (nth msg p) \"\"))]\n    (loop [i 1\n           j 1\n           d initxy]\n      (cond \n       (and (= i (inc m)) (= j n)) (get-in d [m n])\n       (= i (inc m)) (recur 1 (inc j) d)\n       :else (recur (inc i) \n                    j\n                    (assoc-in d [i j]\n                              (if (= (charAt s1 (dec i)) (charAt s2 (dec j))) \n                                (get-in d [(dec i) (dec j)])\n                                (min (inc (get-in d [(dec i) j]))\n                                      (inc (get-in d [i (dec j)]))\n                                      (inc (get-in d [(dec i) (dec j)])))))))))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 101, "code": "(fn [a b] (let [xm (cons nil a) ym (cons nil b)\n                mm (vec (cons (vec (take (count xm) (range)))\n                        (loop [z 1 res []]\n                          (if (= z (count ym)) res\n                            (recur (inc z) (conj res(vec (cons z (repeat (count a) 0)))))))))]\n            (letfn [(dist [i j m] (if (or (< (dec i) 0) (< (dec j) 0)) (nth (nth m j) i)\n                                    (min (+ (if (= (nth xm i) (nth ym j)) 0 1) (nth (nth m (dec j)) (dec i)))\n                                         (+ 1 (nth (nth m (dec j)) i))\n                                         (+ 1 (nth (nth m j) (dec i))))))]\n              (loop [x 0 y 0 res mm]\n               (if (= y (count ym)) (nth (nth res (count b)) (count a))\n                 (recur (if (= x (count a)) 0 (inc x))\n                         (if (= x (count a)) (inc y) y)\n                         (vec (concat (conj (vec (take y res)) (assoc (nth res y) x (dist x y res))) (nthrest res (inc y))))))))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 101, "code": "(fn [a b]\n  (if (= a b) 0\n    (let [al (count a)\n          bl (count b)]\n      (cond\n        (< al bl) (recur b a)\n        (= 0 al) bl\n        (= 0 bl) al\n        :e\n        (let [v (vec (range (inc bl)))\n              r (take\n                  (inc al)\n                  (iterate\n                    (fn [[v0 v1 i]]\n                      (let [v1 (into [(inc i)]\n                                 (for [j (range bl)\n                                       :let [c (if (= (get a i)\n                                                      (get b j))\n                                                   0 1)]]\n                                   (min (inc (v1 j))\n                                        (inc (v0 (inc j)))\n                                        (+ (v0 j) c))))]\n                        [v1 v1 (inc i)]))\n                    [v v 0]))]\n          (-> r last second (get bl)))))))", "user": "4ee4f4a9535d1385b2869d85"}, {"problem": 101, "code": "(fn distance\n  [a b]\n  (cond\n   (empty? a) (count b)\n   (empty? b) (count a)\n   (= (first a) (first b)) (distance (rest a) (rest b))\n   :else (inc (min (distance (rest a) b) (distance a (rest b)) (distance (rest a) (rest b))))))", "user": "4dad76588e77d6ed63f12a44"}, {"problem": 101, "code": "(fn\n  [s1 s2]\n  (let [lev (memoize\n              (fn [y i j]\n                (if (= 0 (min i j))\n                  (max i j)\n                  (let [cost (if (= (get s1 (dec i))\n                                    (get s2 (dec j)))\n                               0\n                               1)]\n                    (min (inc (y y (dec i) j))\n                         (inc (y y i (dec j)))\n                         (+ cost (y y (dec i) (dec j))))))))]\n    (lev lev (count s1) (count s2))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 101, "code": "(let [ldist\n       (fn [mem-ldist a b]\n         (cond\n          (empty? a) (count b)\n          (empty? b) (count a)\n          :else (min (inc (mem-ldist mem-ldist (butlast a) b))\n                              (inc (mem-ldist  mem-ldist a (butlast b)))\n                              (+ (mem-ldist mem-ldist (butlast a) (butlast b))\n                                 (if (= (last a) (last b)) 0 1)))))\n       mem-ldist (memoize ldist)]\n   (partial mem-ldist mem-ldist))", "user": "4ee26f01535d10e5ff6f5368"}, {"problem": 101, "code": "(fn levenshtein-distance [a b]\n  (let [\n        lev (memoize (fn [f a b]\n                       (cond \n                         (zero? (min (count a) (count b))) \n                         (max (count a) (count b))\n\n                         :default\n                         (min (+ (f f (rest a) b) 1) \n                              (+ (f f a (rest b)) 1) \n                              (+ (f f (rest a) (rest b)) (if (= (first a) (first b)) 0 1))\n                              )\n                         )))\n\n\n        ]\n    ((partial lev lev) a b) \n    )\n  )", "user": "5244a10de4b0d8acf9ed6ab3"}, {"problem": 101, "code": "(fn [w1 w2]\n  (letfn [\n    (dist [d w1 w2]\n      (cond\n        (empty? w1) (count w2)\n        (empty? w2) (count w1)\n        :else\n          (min\n            (inc (d d (rest w1) w2))\n            (inc (d d w1 (rest w2)))\n            (+ (if (= (first w1) (first w2)) 0 1)\n              (d d (rest w1) (rest w2))))))]\n  (dist (memoize dist) w1 w2)))", "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 101, "code": "(fn levenshtein [a b]\n  (cond (empty? a) (count b)\n        (empty? b) (count a)\n        (= (first a) (first b)) (levenshtein (rest a) (rest b))\n        (= (rest a) (rest b)) 1\n        (= (seq a) (rest b)) 1\n        (= (rest a) (seq b)) 1\n        :else (inc (min (levenshtein (rest a) (rest b))\n                        (levenshtein (seq a) (rest b))\n                        (levenshtein (rest a) (seq b))))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 101, "code": "(fn ld4 [a b]\n  (letfn [(deep-merge-with [f & maps]\n            (apply\n             (fn m [& maps]\n               (if (every? map? maps)\n                 (apply merge-with m maps)\n                 (apply f maps)))\n             maps))]\n    (let [m (count a)\n          n (count b)\n          init (apply deep-merge-with (fn [a b] b)\n                      (concat\n                       (for [i (range 0 (+ 1 m))] {i {0 i}})\n                       (for [j (range 0 (+ 1 n))] {0 {j j}})))\n          table (reduce\n                 (fn [d [i j]]\n                   (deep-merge-with\n                    (fn [a b] b)\n                    d\n                    {i {j (if (= (nth a (- i 1))\n                                 (nth b (- j 1)))\n                            ((d (- i 1)) (- j 1))\n                            (min\n                             (+ ((d (- i 1))j) 1) \n                             (+ ((d i) (- j 1)) 1) \n                             (+ ((d (- i 1)) (- j 1)) 1)))\n                        }}))\n                 init\n                 (for [j (range 1 (+ 1 n))\n                       i (range 1 (+ 1 m))] [i j]))]\n      ((table m) n))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 101, "code": "(fn ld [s1 s2]\n  (letfn [(d [d s1 s2]\n            (cond (= (count s1) 0) (count s2)\n                  (= (count s2) 0) (count s1)\n                  :else (min (inc (d d (rest s1) s2))\n                             (inc (d d s1 (rest s2)))\n                             (+ (d d (rest s1) (rest s2))\n                                (if (= (first s1) (first s2)) 0 1)))))]\n    (d (memoize d) s1 s2)))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 101, "code": "(fn lv\n  [a b]\n  (let [x (vec a)\n        y (vec b)]\n    (letfn\n        [(L [l m]\n           (let [l- (- l 1)\n                 m- (- m 1)]\n             (cond (= 0 l) m\n                   (= 0 m) l\n                   (= (x l-) (y m-)) (L l- m-)\n                   :else (+ 1 (min\n                                   (L l m-)\n                                   (L l- m)\n                                   (L l- m-))))))]\n      (L (count x) (count y)))))", "user": "53d5e45ae4b0e771c302544e"}, {"problem": 101, "code": "(fn LD [s t]\n     (letfn [(map2 [op xs ys] (loop [x xs y ys z (empty xs)]\n                               (if (or (empty? x) (empty? y))\n                                 z\n                                 (recur (rest x) (rest y) (conj z (op (first x) (first y)))))))]\n       \n  (let [[ms mt] (if (>= (count s) (count t)) [s t] [t s]) \n        d (+ (count (filter false? (map2 #(= %1 %2) s t))) (- (count ms) (count mt))) \n        ]\n    (cond\n     (empty? s) (count t)\n     (empty? t) (count s)\n     (= d 0) 0\n     (= d 1) 1\n     :default\n     (min (+ 1 (LD (drop-last ms) mt))\n;          (+ 1 (LD s (drop-last t)))\n          (+ (if (= (last s) (last t)) 0 1) (LD (drop-last s) (drop-last t)))\n          ))))\n     )", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 101, "code": "(fn [s t]\n\t(cond \n\t\t(= s t) 0\n\t\t(empty? s) (count t)\n\t\t(empty? t) (count s)\n\t\t:else (last (second (reduce (fn [[i v0] si] \n\t\t\t\t\t(let [v1 (vec (repeat (inc (count t)) nil))\n\t\t\t\t\t\t  v1 (assoc v1 0 (inc i))]\n\t\t\t\t\t\t [(inc i) (reduce (fn [v1 j] \n\t\t\t\t\t\t\t\t\t(assoc v1 (inc j) (min (inc (nth v1 j)) (inc (nth v0 (inc j))) (+ (nth v0 j) (if (= si (nth t j)) 0 1))))) v1 (range (count t)))]))\n\t\t\t\t\t\t[0 (vec (range (inc (count t))))] s)))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 101, "code": "(fn leven [a b] \n  (cond (empty? a) (count b)\n        (empty? b) (count a)\n        (= (first a) (first b)) (leven (rest a) (rest b))\n        true (inc (min (leven a (rest b))\n                        (leven (rest a) b)\n                        (leven (rest a) (rest b))))))", "user": "53e91473e4b036ad0777e495"}, {"problem": 101, "code": "(fn levenshtein-distance \n  ([a b] (levenshtein-distance a b 0 (+ (count a) (count b))))\n  ([a b mod-count best-so-far]\n    (let\n      [a-count (count a)\n       b-count (count b)\n       modf (fn [a b new-mod-count] (fn [new-best] (levenshtein-distance a b new-mod-count new-best)))\n       mod-del-a (modf (rest a) b (inc mod-count))\n       mod-del-b (modf a (rest b) (inc mod-count))\n       mod-del-a-b (modf (rest a) (rest b) (inc mod-count))\n       unmod-del-a-b (modf (rest a) (rest b) mod-count)\n       mod-only [mod-del-a mod-del-b mod-del-a-b]\n       mod-unmod [unmod-del-a-b mod-del-a mod-del-b]\n       search (fn search ([mods] (search mods best-so-far))\n                ([mods best] (if (empty? mods) best\n                               (let [new-best (min ((first mods) best) best)]\n                                 (min new-best (search (rest mods) new-best))))))]\n      (cond (>= mod-count best-so-far) best-so-far\n            (= a-count b-count 0) mod-count\n            (= a-count 0) (mod-del-b best-so-far)\n            (= b-count 0) (mod-del-a best-so-far)\n            (= a b) mod-count\n            (= (first a) (first b)) (search mod-unmod)\n            :else (search mod-only)))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 101, "code": "(fn dis\n    ([xxs yys] (dis 0 xxs yys))\n    ([c [x & xs :as xxs] [y & ys :as yys]]\n     (cond (and (nil? x) (nil? y)) c\n           (= x y) (dis c xs ys)\n           (> (count xxs) (count yys)) (min (dis (inc c) xs ys) (dis (inc c) xs yys))\n           (< (count xxs) (count yys)) (min (dis (inc c) xs ys) (dis (inc c) xxs ys))\n           :else (dis (inc c) xs ys))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 101, "code": "(fn [x y]\n  (let [cx (count x)\n        cy (count y)]\n    (last (nth (iterate \n                 (fn [row] \n                   (let [c2 (nth y (first row))]\n                     (reduce-kv (fn [curr idx val]\n                                  (conj curr\n                                        (min (inc (last curr))\n                                             (inc (nth row (inc idx)))\n                                             ((if (= val c2) identity inc) (nth row idx)))))\n                                [(inc (first row))]\n                                (vec x))))\n                 (vec (range (inc cx))))\n               cy))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 101, "code": "(fn levenstein [a b]\n  (let [cache (atom {})]\n    ((fn levenstein [a b]\n       (or\n        (@cache [a b])\n        (let [result \n              (cond\n               (zero? (count a)) (count b)\n               (zero? (count b)) (count a)\n               :else\n               (let [cost (if (= (last a) (last b)) -1 0)]\n                 (inc (min\n                       (levenstein (drop-last a) b)\n                       (levenstein (drop-last b) a)\n                       (+ cost (levenstein (drop-last a) (drop-last b)))))))]\n          (swap! cache assoc [a b] result)\n          result))) a b)))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 101, "code": "(fn [s1 s2]\n    (let [v1 (vec s1)\n          v2 (vec s2)\n          c1 (count v1)\n          c2 (count v2)\n          memo (atom {})\n          ld-100 (fn ld [i j] \n                   (if-let [memo-val (get @memo [i j])]\n                     memo-val\n                     (let [calc-val\n                           (cond (= (min i j) 0) (max i j)\n                                 :else (min (inc (ld (dec i) j))\n                                            (inc (ld i (dec j)))\n                                            (+ (ld (dec i) (dec j)) \n                                               (if (= (get v1 (dec i)) \n                                                      (get v2 (dec j))) \n                                                 0 \n                                                 1))))]\n                       (swap! memo assoc [i j] calc-val)\n                       calc-val)))]\n      (doseq [n (range (max c1 c2))]\n        (when (< n c1) (doseq [j (range (inc n))] (ld-100 n j)))\n        (when (< n c2) (doseq [i (range (inc n))] (ld-100 i n))))\n      (ld-100 c1 c2)))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 101, "code": "(fn [s1 s2]\n   (let [s1v (vec s1)\n         s2v (vec s2)\n         m1  (count s1v)\n         m2  (count s2v)\n         n1  (inc m1)\n         n2  (inc m2)]\n     (->> (for [i2 (range 1 n2)\n                i1 (range 1 n1)]\n            [i2 i1])\n          (reduce\n           (fn [tab [i2 i1 :as coordinate]]\n             (let [i1m (dec i1)\n                   i2m (dec i2)]\n               (assoc-in tab\n                         coordinate\n                         (min (inc (get-in tab [i2 i1m]))\n                              (inc (get-in tab [i2m i1]))\n                              (+ (get-in tab [i2m i1m])\n                                 (if (= (s1v i1m) (s2v i2m)) 0 1))))))\n           (vec (cons (vec (range n1))\n                      (for [n (range 1 n2)]\n                        (-> (repeat n1 nil)\n                            (vec)\n                            (assoc 0 n))))))\n          ((fn [tab] (get-in tab [m2 m1])))\n          )))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 101, "code": "(fn levenshtein [s t]\n           (loop [counteri 1 counterj 1 matrix (vec (map #(vec (range % (+ 1 (count t) %)))\n                                                         (range 0 (inc (count s)))))]\n             (if (> counteri (count s))\n               (peek (peek matrix))\n               (if (> counterj (count t))\n                 (recur (inc counteri) 1 matrix)\n                 (recur counteri (inc counterj) (assoc-in matrix [counteri counterj]\n                                                          (if (= (get s (dec counteri)) (get t (dec counterj)))\n                                                            (get-in matrix [(dec counteri) (dec counterj)])\n                                                            (min (inc (get-in matrix [(dec counteri) counterj]))\n                                                                 (inc (get-in matrix [counteri (dec counterj)]))\n                                                                 (inc (get-in matrix [(dec counteri) (dec counterj)]))))))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 101, "code": "(fn [x y]\n   (letfn [(f [d x y]\n      (cond\n       (or (empty? x) (empty? y)) (>= d (+ (count x) (count y)))\n       (= (first x) (first y)) (f d (rest x) (rest y))\n       (= 0 d) false\n       :else (or (f (dec d) (rest x) (rest y))\n                 (f (dec d) x (rest y))\n                 (f (dec d) (rest x) y))))]\n    (first (filter #(f % (seq x) (seq y)) (range)))\n   ))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 101, "code": "(fn levenshtein [s1 s2]\n  (let [distance (fn [f s1 s2]\n                   (cond\n                     (empty? s1) (count s2)\n                     (empty? s2) (count s1)\n                     :else\n                     (let [cost (if (= (first s1) (first s2)) 0 1)]\n                       (min\n                         (+ (f f (rest s1) (rest s2)) cost)\n                         (+ (f  f (rest s1) s2) 1)\n                         (+ (f f s1 (rest s2)) 1)))))\n        memo-distance (memoize distance)]\n    (memo-distance memo-distance (seq s1) (seq s2))))", "user": "53527551e4b084c2834f4af0"}, {"problem": 101, "code": "(fn ld [a b]\n  ((fn c [ia ib] (let [A (dec ia) B (dec ib)]\n                  (cond\n                           (zero? ia) ib\n                           (zero? ib) ia\n                           (= (get a A)(get b B)) (recur A B)\n                           :else (inc (min\n                                        (c A B)\n                                        (c ia B)\n                                        (c A ib))))))\n   (count a) (count b)))", "user": "53f7820be4b0de5c41848560"}, {"problem": 101, "code": "(fn [s1 s2]\n   (let [mem (atom {})]\n     (letfn [(levmemo [& args]\n                      (if-let [e (find @mem args)]\n                        (val e)\n                        (let [ret (apply levd args)]\n                          (swap! mem assoc args ret)\n                          ret)))\n             (levd [s ls t lt]\n                   (cond (zero? ls) lt\n                         (zero? lt) ls\n                         :else (let [cost (if (= (get s (dec ls)) (get t (dec lt))) 0 1)]\n                                 (min\n                                  (inc (levmemo s (dec ls) t lt))\n                                  (inc (levmemo s ls t (dec lt)))\n                                  (+ cost (levd s (dec ls) t (dec lt)))))))]\n       (levd s1 (count s1) s2 (count s2)))))", "user": "53ea5307e4b036ad0777e4e2"}, {"problem": 101, "code": "(fn edit-dist [s t]\n  (if (= s t) 0\n  (let [m (count t), n (count s), \n        prepare-mx #(->> (repeat n nil)\n                         (cons x)\n                         (vec)\n                         (for [x (range 1 (inc m))])\n                         (cons (vec (range (inc n))))\n                         (vec))]\n    (-> (loop [mx (prepare-mx), i 1, j 1]\n      (cond (and (= i m) (= j (inc n))) mx, \n            (= j (inc n)) (recur mx (inc i) 1)\n            :else \n            (let [mx-new-ij (if (= (nth s (dec j)) (nth t (dec i)))\n                              (get-in mx [(dec i) (dec j)])\n                              (min (inc (get-in mx [(dec i) j]))\n                                   (inc (get-in mx [i (dec j)]))\n                                   (inc (get-in mx [(dec i) (dec j)])))),\n                  mx-new (assoc-in mx [i j] mx-new-ij)]\n              (recur mx-new i (inc j)))))\n        (get-in [m n])))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 101, "code": "(fn levenshtein [str1 str2]\n  (let [c1 (count str1) c2 (count str2)\n        new_row (fn [c v0] (loop [pos 0 ans [(inc c)]]\n                          (if (= pos c2)\n                            ans\n                            (let [cost (if (or (>= pos c1) (= (nth str1 pos) (nth str2 pos))) 0 1)]\n                              (recur (inc pos)\n                                     (conj ans (min (+ 1 (last ans)) (+ (nth v0 (inc pos)) 1) (+ (nth v0 pos) cost))))))))]\n    (cond\n      (= str1 str2) 0\n      (zero? (min c1 c2)) (max c1 c2)\n      :else\n        (loop [v0 (reduce #(conj %1 %2) [] (range (inc c2))) c 0]\n          (if (= c (count str2))\n            (if (= c1 c2) (last v0) (inc (last v0)))\n            (recur (new_row c v0) (inc c)))))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 101, "code": "(letfn [(leven [f s t]\n          (cond\n            (empty? s) (count t)\n            (empty? t) (count s)\n            :else (let [cut #(list (butlast %) (last %))\n                        [s' sn] (cut s)\n                        [t' tn] (cut t)]\n                    (min (inc (f f s' t))\n                         (inc (f f s t'))\n                         (+ (f f s' t') (if (= sn tn) 0 1))))))]\n  (let [f (memoize leven)] (partial f f)))", "user": "508157b2e4b0946d0443855c"}, {"problem": 101, "code": "(fn [x y]\r\n  (last\r\n   (reduce\r\n    (fn [row i]\r\n      (reduce #(let [cost (if (= (get x i) (get y %2)) 0 1)]\r\n                 (conj %1 (min (+ 1 (last %1))\r\n                               (+ cost (get row %2))\r\n                               (+ 1 (get row (inc %2))))))\r\n              [(inc i)]\r\n              (range (count y))))\r\n    (-> y count inc range vec)\r\n    (-> x count range))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 101, "code": "(let [mem (atom {})];an explicit memory is used here\n  (fn distance [s1 s2]  \n    (if (contains? @mem [s1 s2]) (@mem [s1 s2])\n      (cond\n       (= (seq s1) (seq s2) nil) (do (swap! mem assoc [s1 s2] 0) 0)\n       (and (seq s1) (seq s2)) (let[subS1subS2 (distance (rest s1) (rest s2))\n                                    subS1S2 (distance (rest s1) s2)\n                                    s1subS2 (distance s1 (rest s2))]\n                                 (if (= (first s1) (first s2))\n                                   (let[dist (min subS1subS2 (inc subS1S2) (inc s1subS2))]\n                                     (do (swap! mem assoc [s1 s2] dist) dist))\n                                   (let[dist (min (inc subS1subS2) (inc subS1S2) (inc s1subS2))]\n                                     (do (swap! mem assoc [s1 s2] dist) dist))))\n       (seq s1) (let [dist (count s1)] (do (swap! mem assoc [s1 s2] dist) dist))\n       :else (let [dist (count s2)] (do (swap! mem assoc [s1 s2] dist) dist))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 101, "code": "(fn [w1 w2]\n  (if (or (empty? w1) (empty? w2))\n    (+ (count w1) (count w2))\n    (let [a (make-array Integer/TYPE (inc (count w1)) (inc (count w2)))]\n      (doseq [i (range 1 (inc (count w1)))] (aset a i 0 (int i)))\n      (doseq [i (range 1 (inc (count w2)))] (aset a 0 i (int i)))\n      (doseq [i (range 1 (inc (count w1)))\n              j (range 1 (inc (count w2)))]\n        (aset a i j (int (min (inc (aget a (dec i) j))\n                              (inc (aget a i (dec j)))\n                              (+ (aget a (dec i) (dec j))\n                                 (if (= (get w1 (dec i)) (get w2 (dec j))) 0 1))))))\n      (aget a (count w1) (count w2)))))", "user": "53513d28e4b084c2834f4ae3"}, {"problem": 101, "code": "(fn\n  [w r]\n  ((fn\n     [i w r]\n     (if\n       (some #(= r %) w)\n         i\n        (recur\n          (inc i)\n          (mapcat\n            #(\n              let\n                [m ((fn [k a b] (if (or (empty? a) (empty? b) (not= (first a) (first b))) k (recur (inc k) (rest a) (rest b)))) 0 % r)]\n              (concat [(concat (take m %) (drop (+ m 1) %))] (if (< m (count r)) [(concat (take m %) [(r m)] (drop m %)) (concat (take m %) [(r m)] (drop (+ m 1) %))]))\n              )\n            w)\n          r))\n     ) 0 [(vec w)] (vec r))\n )", "user": "542f574be4b0dad94371f2d0"}, {"problem": 101, "code": "(fn [I x y]\n  (last\n    (reduce\n      (fn [[i & r] y]\n        (map first (reductions\n                     (fn [[d s] [i x]] [(min (I d) (I i) (if (= x y) s (I s))) i])\n                     [(I i) i] (map list r x))))\n      (range (I (count x)))\n      y))) inc", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 101, "code": "(fn [xs ys]\n  (letfn [(lev [xs ys cnt]\n            (cond (empty? xs) (+ cnt (- (count ys) (count xs)))\n              (empty? ys) (+ cnt (- (count xs) (count ys)))\n              :else (if (= (first xs) (first ys)) (lev (rest xs) (rest ys) cnt)\n                      (min (lev (rest xs) (rest ys) (inc cnt))\n                        (lev (rest xs) ys (inc cnt))\n                        (lev xs (rest ys) (inc cnt))))))]\n    (lev xs ys 0)))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 101, "code": "(fn f [x y]\n  (let [a (rest x)\n        b (rest y)]\n    (cond (empty? x) (count y)\n          (empty? y) (count x)\n          (= (first x) (first y)) (f a b)\n          :else\n          (inc (min (f a y) (f x b) (f a b))))))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 101, "code": "(fn lev [s1 s2]\n  (cond\n   \t(empty? s1) (count s2)\n    (empty? s2) (count s1)\n    (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n    :else (inc (min (lev (rest s1) (rest s2)) (lev s1 (rest s2)) (lev (rest s1) s2)))))", "user": "54448e84e4b032a45b869393"}, {"problem": 101, "code": "(fn lv [a b]\n  (cond\n    (empty? a) (count b)\n    (empty? b) (count a)\n    (= (first a) (first b)) (lv (rest a) (rest b))\n    :else (inc (min (lv a (rest b)) (lv (rest a) b) (lv (rest a) (rest b))))))", "user": "541096bde4b01498b1a719b2"}, {"problem": 101, "code": "(fn [str1 str2]\n            (let [indices (reduce \n                            (fn [mylist x] (concat mylist (map (fn [y] (list x y)) (range (inc (count str2)))))) \n                            (list) \n                            (range (inc (count str1)))\n                          )\n                  initialMatrix (reduce \n                                  (fn [matrix index] \n                                    (conj {index (if \n                                      (zero? (first index))\n                                      (second index)\n                                      (if (zero? (second index)) (first index) 0)\n                                       )} matrix)\n                                   )\n                                   {} \n                                   indices)\n                  ] (get     (reduce \n      (fn [matrix index]\n        (if \n          (or (= 0 (first index)) (= 0 (second index))) \n          matrix\n          (assoc matrix index \n            (min \n              (inc (get matrix (list (dec (first index)) (second index))))\n              (inc (get matrix (list (first index) (dec (second index))))) \n              (if \n                (= (get str1 (dec (first index))) (get str2 (dec (second index)))) \n                (get matrix (list (dec (first index)) (dec (second index))))\n                (inc (get matrix (list (dec (first index)) (dec (second index)))))\n              )\n            )\n          )\n        )\n      )\n      initialMatrix \n      indices\n    ) (list (count str1) (count str2))))\n  )", "user": "5439c3cee4b032a45b869323"}, {"problem": 101, "code": "(fn [s t]\n  (let [sn (count s) tn (count t)]\n    (cond\n      (= s t) 0\n      (zero? sn) tn\n      (zero? tn) sn\n      :else\n        (->>\n          (reduce\n            (fn [[i v0] s-item]\n              [\n                (inc i)\n                (reductions \n                  #(min (inc %) %2)\n                  (inc i)\n                  (map min (map inc (drop 1 v0))\n                    (map + v0 (map #(if (= s-item %) 0 1) t))\n                  )\n                )\n              ]\n            )\n            [0 (range (inc tn))]\n            s\n          )\n          second\n          last\n) ) )   )", "user": "5281a445e4b0757a1b17143a"}, {"problem": 101, "code": "((fn [f]\n  (let  [m (atom {})]\n    (#(% %)\n      (fn [x] (f #(if-let [e (find @m %&)] (val e)\n                    (let [r (apply (x x) %&)]\n                      (swap! m assoc %& r) r)))))))\n (fn [g]\n   (fn [\u03b1 \u03b2]\n     (let [l g]\n       (cond (empty? \u03b1) (count \u03b2)\n             (empty? \u03b2) (count \u03b1)\n             :else (min\n                    (inc (l \u03b1 (rest \u03b2)))\n                    (inc (l (rest \u03b1) \u03b2))\n                    (+ (if (= (first \u03b1) (first \u03b2)) 0 1)\n                       (l (rest \u03b1) (rest \u03b2)))))))))", "user": "5078d366e4b08327cd804a5b"}, {"problem": 101, "code": ";; DATA DEFINITION\n;; wi = work item\n;; 0 - # of changes as int\n;; 1 - source word as sequence\n;; 2 - destination word as a sequence\n;; wis = work item set, a set of work items\n(letfn [\n        (wi [src-word dst-word]\n          (vector 0 (seq src-word) (seq dst-word)))\n\n        (wi-set [wi]\n          #{wi})\n\n        (clean [[ch src dst :as wi]]\n          (if (or (empty? src)\n                  (empty? dst)\n                  (not (= (first src) (first dst))))\n            wi\n            (recur (vector ch (rest src) (rest dst)))))\n\n        (clean-set [wi-set]\n          (into #{} (map clean (remove nil? wi-set))))\n\n        (ins [[ch src dst :as wi]]\n          (vector (inc ch) src (rest dst)))\n\n        (rep [[ch src dst :as wi]]\n          (vector (inc ch) (rest src) (rest dst)))\n\n        (del [[ch src dst :as wi]]\n          (if (empty? dst)\n            (vector (+ ch (count src)) () ())\n            (let [pos (.indexOf src (first dst))]\n              (if (= -1 pos) nil\n                  (vector (+ ch pos) (drop pos src) dst)))))\n\n        (next-set [wi-set max-changes]\n          (loop [rm (seq wi-set), acc #{}]\n            (let [[ch src dst :as wi] (first rm)]\n              (cond (empty? rm) (clean-set acc)\n                    (and (>= ch max-changes)\n                         (or (seq src) (seq dst))) (recur (rest rm) acc)\n                    :else (recur (rest rm) (conj acc (ins wi) (rep wi) (del wi)))))))\n\n        (sol [src-word dst-word]\n          (let [init (wi-set (wi src-word dst-word))\n                max-changes (max (count src-word) (count dst-word))]\n            (if (or (empty? src-word)\n                    (empty? dst-word))\n              max-changes\n              (loop [wis init]\n                (if (every? #(and (empty? (nth % 1))\n                                  (empty? (nth % 2))) wis)\n                  (apply min (map first wis))\n                  (recur (next-set wis max-changes)))))))]\n  sol)", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 101, "code": "(fn levenshtein [w1 w2]\n  (letfn [(cell-value [ch1 ch2 prev-row acc col-idx]\n            (min  (inc (nth prev-row col-idx))\n                  (inc (last acc))\n                  (+ (nth prev-row (dec col-idx)) (if (= ch1 ch2) 0 1))))]\n    (loop [row-idx 1, max-rows (inc (count w2)), prev (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev)\n        (let [next-prev (reduce (fn [acc i]\n                                  (conj acc (cell-value (nth w1 (dec i)) (nth w2 (dec row-idx)) prev acc i)))\n                                [row-idx]\n                                (range 1 (count prev)))]\n          (recur (inc row-idx) max-rows, next-prev))))))", "user": "50ebd63ce4b04edc3377703c"}, {"problem": 101, "code": "(fn levenshtein [xs ys]\n  (let [atm (atom {})\n        get-or-update (fn [atm fct & args]\n                        (if (@atm args)\n                          (@atm args)\n                          (let [newval (apply fct args)]\n                               (swap! atm assoc args newval)\n                               newval)))\n        lev (fn lev [xs ys]\n               (cond (zero? (count xs)) (count ys)\n                     (zero? (count ys)) (count xs)\n                     :else (min\n                             (inc (get-or-update atm lev (rest xs) ys))\n                             (inc (get-or-update atm lev xs (rest ys)))\n                             (+ (get-or-update atm lev (rest xs) (rest ys))\n                                (if (= (first xs) (first ys)) 0 1)))))]\n    (lev xs ys)))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 101, "code": "(let [[c b l] [count butlast last]\n      lev\n      (fn [mem-lev s1 s2]\n        (let [lev (fn [s1 s2] (mem-lev mem-lev s1 s2))]\n          (cond (= s1 s2) 0\n                (= (c s1) 0) (c s2)\n                (= (c s2) 0) (c s1)\n                true (min (+ (lev (b s1) s2) 1)\n                          (+ (lev s1 (b s2)) 1)\n                          (+ (if (= (l s1) (l s2)) 0 1) (lev (b s1) (b s2)))))))\n      mem-lev (memoize lev)]\n  #(mem-lev mem-lev % %2))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 101, "code": "(fn r [str1 str2]\n  \"a Clojure levenshtein implementation using transient data structure\"\n  (let [n (count str1) m (count str2)]\n    (cond\n      (= 0 n) m\n      (= 0 m) n\n      :else\n      (let [prev-col (transient (vec (range (inc m)))) col (transient [])] ; initialization for the first column.\n        (dotimes [i n]\n          (assoc! col 0 (inc i)) ; update col[0]\n          (dotimes [j m]\n            (assoc! col (inc j)  ; update col[1..m]\n                    (min (inc (get col j))\n                         (inc (get prev-col (inc j)))\n                         (+ (get prev-col j) (if (= (get str1 i) (get str2 j)) 0 1)))))\n          (dotimes [i (count prev-col)]\n            (assoc! prev-col i (get col i)))) ;\n        (last (persistent! col)))))) ; last element of last column", "user": "51aefceee4b09397d5109797"}, {"problem": 101, "code": "(fn [s t]\n  ;; just amounts to recode an algorithm written down in wikipedia...\n  (cond\n   (= s t) 0\n   (= 0 (count s)) (count t)\n   (= 0 (count t)) (count s)\n   :else (let [v0 (transient (vec (range (+ 2 (count t)))))\n               v1 (transient (vec (take (count v0) (repeat 0))))]\n           (doseq [i (range (count s))]\n             (do\n               (assoc! v1 0 (inc i))\n               (doseq [j (range (count t))]\n                 (let [cost (if (= (nth s i) (nth t j)) 0 1)]\n                     (assoc! v1 (inc j) (min (inc (get v1 j))\n                                             (inc (get v0 (inc j)))\n                                             (+ cost (get v0 j))))))\n               (doseq [j (range (count v0))]\n                 (assoc! v0 j (nth v1 j)))))\n           (nth v1 (count t)))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 101, "code": "(fn [x y]\n  (let [memo (atom {})]\n    (letfn [(lev* [i j]\n              (if (contains? @memo [i j])\n                (get @memo [i j])\n                (let [ret (if (= 0 (min i j))\n                            (max i j)\n                            (min\n                              (inc (lev* (dec i) j))\n                              (inc (lev* i (dec j)))\n                              (+ (lev* (dec i) (dec j))\n                                 (if (= (nth x (dec i)) (nth y (dec j)))\n                                   0\n                                   1))))]\n                  (swap! memo assoc [i j] ret)\n                  ret)))]\n      (lev* (count x) (count y)))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 101, "code": "(fn levenshtein-distance-better [s1 s2]\n  (let [len1 (inc (count s1))\n        len2 (inc (count s2))\n        total-steps (dec (* len1 len2))\n        max-num 999999999999999]\n    (if (= 0 total-steps)\n      0\n      (letfn [(calc-fn [result-map step-count]\n                (if (= 0 step-count)\n                  (calc-fn {[0 0] 0} 1)\n                  (let [j (quot step-count len1)\n                        i (rem step-count len1)\n                        v1 (if (nil? (result-map [(dec i) j]))\n                             max-num\n                             (inc (result-map [(dec i) j])))\n                        v2 (if (nil? (result-map [i (dec j)]))\n                             max-num\n                             (inc (result-map [i (dec j)])))\n                        v3 (if (or (= 0 i)\n                                   (= 0 j))\n                             max-num\n                             (if (= (nth s1 (dec i))\n                                    (nth s2 (dec j)))\n                               (result-map [(dec i) (dec j)])\n                               (inc (result-map [(dec i) (dec j)]))))\n                        min-v\n                        (do\n                          (min v1 v2 v3))]\n                    (if (= total-steps step-count)\n                      min-v\n                      (recur (assoc result-map [i j] min-v) (inc step-count))))))]\n        (calc-fn nil 0)))))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": 101, "code": "(fn levenshtein-distance [s t]\n  (let [f (fn [f s t]\n            (cond\n              (empty? s) (count t)\n              (empty? t) (count s)\n              :else (let [cost (if (= (first s) (first t)) 0 1)]\n                      (min (inc (f f (rest s) t))\n                           (inc (f f s (rest t)))\n                           (+ cost (f f (rest s) (rest t)))))))\n        g (memoize f)]\n    (g g s t)))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 101, "code": "(fn distance [[afirst & arest :as a] [bfirst & brest :as b]]\n  (cond\n    (nil? afirst) (count b)\n    (nil? bfirst) (count a)\n    :else (if (= afirst bfirst)\n            (distance arest brest)\n            (inc (min (distance arest brest)\n                      (distance a brest)\n                      (distance arest b))))))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 101, "code": "(fn [s1 s2]\n  (letfn [(calc-v [v0 c i]\n              (loop [t s2\n                     v1 [(inc i)]\n                     v v0]\n                (if (empty? t)\n                  v1\n                  (recur\n                    (rest t)\n                    (conj v1 (min (inc (last v1)) (inc (second v)) (+ (first v) (if (= c (first t)) 0 1))))\n                    (rest v)))))]\n    (cond\n      (= s1 s2) 0\n      (= s1 \"\") (count s2)\n      (= s2 \"\") (count s1)\n      :else (loop [v0 (range (inc (count s2)))\n                   s s1\n                   i 0]\n              (if (empty? s)\n                (last v0)\n                (recur\n                  (calc-v v0 (first s) i)\n                  (rest s)\n                  (inc i)))))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 101, "code": "(fn lvn [s1 s2]\n  (let [s1 (vec s1)\n        s2 (vec s2)]\n    (letfn [(init-col [] (vec (range 0 (inc (count s2)))))\n            (next-col [col i]\n              (let [col (vec col)]\n                (reverse (reduce (fn [a j]\n                                   (cons\n                                     (let [c1 (get s1 (dec i))\n                                           c2 (get s2 (dec j))]\n                                       (if\n                                         (= c1 c2)\n                                         (get col (dec j)) ; equal, get best last edit\n                                         (let [v11 (inc (get col (dec j))) ; substitution\n                                               v01 (inc (first a)) ; insertion\n                                               v10 (inc (get col j))] ; deletion\n                                           (min v11 v10 v01))))\n                                     a))\n                           [i] (vec (range 1 (inc (count s2))))))))]\n\n      (last (reduce next-col (init-col) (range 1 (inc (count s1))))))))", "user": "4f724e56e4b07046d9f4f027"}, {"problem": 101, "code": "(fn ([w1 w2]\n     (let [levenstein-raw (fn [w1 l1 w2 l2 lev]\n                            (cond\n                              (zero? l1) l2\n                              (zero? l2) l1\n                              :else (let [last-w1 (nth w1 (dec l1))\n                                          last-w2 (nth w2 (dec l2))\n                                          cost (if (= last-w1 last-w2) 0 1)]\n                                      (min\n                                        (inc (lev w1 (dec l1) w2 l2 lev))\n                                        (inc (lev w1 l1 w2 (dec l2) lev))\n                                        (+ cost (lev w1 (dec l1) w2 (dec l2) lev))))))\n           levenshtein (memoize levenstein-raw)]\n       (levenshtein w1 (count w1) w2 (count w2) levenshtein))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 101, "code": "(fn [s t]\n  (let [s (vec s)\n        t (vec t)\n        m (count s)\n        n (count t)\n        d (reduce #(conj %1 (reduce conj [%2] (repeat m 0)))\n                  [(-> m inc range)] (range 1 (inc n)))]\n    (letfn [(gt [d i j] (-> d (nth j) (nth i)))\n            (pt [d i j v] (assoc-in d [j i] v))]\n      (-> (loop [j 1, d d]\n            (if (> j n) d\n                (recur (inc j)\n                       (loop [i 1, d d]\n                         (if (> i m) d\n                             (recur (inc i)\n                                    (let [i- (dec i) j- (dec j)]\n                                      (if (= (s i-) (t j-))\n                                        (pt d i j (gt d i- j-))\n                                        (pt d i j\n                                            (->> [(gt d i- j )\n                                                  (gt d i  j-)\n                                                  (gt d i- j-)]\n                                              (map inc)\n                                            (apply min)))))))))))\n        last last))))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 101, "code": "#(% %2 %3 %)\n(memoize (fn [[a & x :as ax] [b & y :as by] d]\n           (cond (not a) (count by)\n                 (not b) (count ax)\n                 (= a b) (d x y d)\n                 :else (min (inc (d x y d))\n                            (inc (d x by d))\n                            (inc (d ax y d))))))", "user": "54969f9ee4b0b312c081ff67"}, {"problem": 101, "code": "(fn [xs ys]\n  (let [l1 (count xs) l2 (count ys)\n        xs' (cons nil xs) ys' (cons nil ys)\n        d (fn [xys i j]\n            (cond\n              (zero? i) j\n              (zero? j) i\n              :else (min\n                     (inc (nth (nth xys (dec i)) j))\n                     (inc (nth (nth xys i) (dec j)))\n                     (+ (nth (nth xys (dec i)) (dec j))\n                        (if (= (nth xs' i) (nth ys' j)) 0 1)))))]\n    (last\n     (last\n      (loop [i 0 rs []]\n        (if (> i l1)\n          rs\n          (let [cs\n                (loop [j 0 cs []]\n                  (if (> j l2)\n                    cs\n                    (recur (inc j)\n                           (conj cs (d (conj rs cs) i j)))))]\n            (recur (inc i) (conj rs cs)))))))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 101, "code": "(fn [s1 s2]\n  (cond\n    (empty? s1) (count s2)\n    (empty? s2) (count s1)\n    (= s1 s2) 0\n    :else \n    (let [sx (inc (count s1))\n          sy (inc (count s2))\n          board (make-array Integer/TYPE sx sy)]\n      (aset-int board 0 0 0)\n      (dorun \n        (for [i (range 1 sx)]\n          (aset-int board i 0 i)))\n      (dorun \n        (for [j (range 1 sy)]\n          (aset-int board 0 j j)))\n      (dorun\n        (for [i (range 1 sx)]\n          (dorun \n            (for [j (range 1 sy)]\n              (aset-int board i j \n                        (min \n                          (inc (aget board (dec i) j))\n                          (inc (aget board i (dec j)))\n                          (+ (aget board (dec i) (dec j))\n                             (if (= \n                                   (nth s1 (dec i))\n                                   (nth s2 (dec j)))\n                               0\n                               1))))))))\n      ;;(pprint board)\n      (aget board (dec sx) (dec sy)))))", "user": "5385e633e4b06839e8705f08"}, {"problem": 101, "code": "(fn [word1 word2]\n\n   (last (reduce \n (fn [a b]\n   (reduce  \n    #(conj %1 (min (inc (last %1)) (inc (nth a (count %1))) (+ (nth a (dec( count %1))) (if (= b %2) 0 1))))\n    (vector(inc (first a)))\n    word2))\n  (range 0 (inc (count word2))) \n word1)))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 101, "code": "(fn levd [s t]\n   (let [cs (count s) ct (count t)\n         sr (range (inc cs)) tr (range (inc ct))\n         si (zipmap (map (fn [x] [x 0]) sr) sr)\n         ti (zipmap (map (fn [y] [0 y]) tr) tr)\n         dm (into si ti)]\n     (loop [m dm i 1 j 1]\n       (if (m [cs ct]) (m [cs ct])\n         (recur (conj \n                 {[i j]\n                  (if (= (nth s (dec i)) (nth t (dec j))) (m [(dec i) (dec j)])\n                    (inc (min (m [(dec i) j])\n                              (m [i (dec j)])\n                              (m [(dec i) (dec j)])\n                              )))\n                  } m)\n                (if (= i cs) 1 (inc i))\n                (if (= i cs) (inc j) j))))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 101, "code": "(fn [s t]\n  (let [cs (count s)\n        ct (count t)\n        row (fn [r v0 cost]\n              (if-let [nv0 (next v0)]\n                (recur\n                  (conj r (min (inc (last r)) (inc (first nv0)) (+ (first v0) (first cost))))\n                  (rest v0)\n                  (rest cost))\n                r))\n        lev* (fn [v0 i]\n               (if (= cs i)\n                 (last v0)\n                 (recur\n                   (row [(inc i)] v0 (map #(if (= (nth s i) %) 0 1) t))\n                   (inc i))))]\n    (cond\n      (= s t) 0\n      (zero? cs) ct\n      (zero? ct) cs\n      :else (lev* (range (inc ct)) 0))))", "user": "4f05ea25535dcb61093f6c02"}, {"problem": 101, "code": "(memoize (fn lev [s1 s2]\n           (cond\n            (zero? (count s1)) (count s2)\n            (zero? (count s2)) (count s1)\n            (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n            :else (inc (min (lev (rest s1) s2)\n                            (lev s1 (rest s2))\n                            (lev (rest s1) (rest s2)))))))", "user": "54ae541ae4b09f271ff37cef"}, {"problem": 101, "code": "(fn [a b]\n  (let [av (vec a), bv (vec b)\n        m  (inc (count a))\n        n  (inc (count b))\n        chart (make-array Integer/TYPE \n                          m n)]\n    (doseq [i (range m)]\n      (aset-int chart i 0 i))\n    (doseq [j (range n)]\n      (aset-int chart 0 j j))\n\n    (doseq [i (range 1 m)\n            j (range 1 n)\n            :let [i* (dec i)\n                  j* (dec j)]]\n      (aset-int chart i j\n                (min (inc (aget chart i* j))\n                     (inc (aget chart i j*))\n                     (let [prev (aget chart i* j*)] \n                       (if (= (av i*) (bv j*)) \n                         prev (inc prev))))))\n    \n    (aget chart (dec m) (dec n))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 101, "code": "(fn levenshtein [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char? 0 1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2       (nth w2 (dec row-idx))\n              next-prev (reduce (fn [cur-row i]\n                                  (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                    (conj cur-row (cell-value same-char?\n                                                              prev-row\n                                                              cur-row\n                                                              i))))\n                                [row-idx]\n                                (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows, next-prev))))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 101, "code": "(fn [a b]\n (let\n  [lev (fn [a b i j f]\n   (if (zero? (min i j))\n       (max i j)\n       (min (inc (f a b (dec i) j f))\n               (inc (f a b i (dec j) f))\n               (+ (f a b (dec i) (dec j) f)\n                   (if (= (nth a (dec i)) (nth b (dec j))) 0 1)))))]\n  (lev a b (count a) (count b) (memoize lev))))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 101, "code": "(fn levdist [s1 s2]\n  (cond\n   (some empty? [s1 s2]) (max (count s1) (count s2))\n   (= (first s1) (first s2)) (levdist (rest s1) (rest s2))\n   :else (inc (min \n               (levdist (rest s1) s2) \n               (levdist s1 (rest s2))\n               (levdist (rest s1) (rest s2))))))", "user": "525b142fe4b0cb4875a45d05"}, {"problem": 101, "code": "(fn [a b]\n    (if (= a b)\n      0 \n      (if (= 0 (count b))\n        (count a)\n        (if (= 0 (count a))\n          (count b)\n          (loop [v (vec (range (+ (count a) 1))) n 0]\n            (if (= n (count b))\n              (last v)\n              (recur (loop [w [(+ n 1)] m 0]\n                      (if (= m (count a))\n                        w \n                        (recur (conj w (min (+ 1 (last w)) (+ 1 (nth v (+ m 1))) (+ (if (= (nth a m) (nth b n)) 0 1) (nth v m)))) (+ m 1))\n                        )\n                      ) (+ n 1))\n              )       \n            ) \n          ) \n        ) \n      ) \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 101, "code": "(fn __ [s t]\n  (if (= s t) 0\n    (letfn\n      [(f [s v0]\n          (if (empty? s)\n            (nth v0 (count t))\n            (recur (rest s)\n                   (loop [j 0\n                          v1 (vec (list (inc (first v0))))]\n                     (if (= j (count t))\n                       v1\n                       (recur (inc j)\n                              (conj v1 (min (inc (nth v1 j))\n                                            (inc (nth v0 (inc j)))\n                                            (+ (nth v0 j)\n                                               (if (= (first s) (nth t j))\n                                                 0 1))))))))))]\n      (f s (vec (range (inc (count t))))))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 101, "code": "(fn cld [a b]\n  (let [m (count a) ; number of columns\n        n (count b) ; number of rows\n        init-mtx  (fn init-mtx [a b]\n                    (let [init-mtx-col  (fn [mtx len]\n                                          (loop [x 1]\n                                            (when (<= x len)\n                                              (aset-long mtx 0 x x)\n                                              (recur (inc x)))))\n                          init-mtx-row  (fn [mtx len]\n                                          (loop [x 1]\n                                            (when (<= x len)\n                                              (aset-long mtx x 0 x)\n                                              (recur (inc x)))))\n                          d (make-array Long/TYPE (inc n) (inc m))\n                          _ (init-mtx-col d m)\n                          _ (init-mtx-row d n)]\n                      d))\n        d (init-mtx a b)\n        s (vec a)\n        t (vec b)]\n    (loop [j 1]\n      (when (<= j n)\n        (loop [i 1]\n          (when (<= i m)\n            (if (= (s (dec i)) (t (dec j)))\n              (aset-long d j i (aget d (dec j) (dec i))) ; no operation required\n              (aset-long d j i \n                (min\n                  (inc (aget d j       (dec i))) ; a deletion\n                  (inc (aget d (dec j) i      )) ; an insertion\n                  (inc (aget d (dec j) (dec i))) ; a substition\n                )))\n            (recur (inc i))))\n        (recur (inc j))))\n    (aget d n m)))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": 101, "code": "#(let [lena (count %)]\n   (loop [j 1 lstv (for [i (range (inc lena))] i) curv [j]]\n     (if (> j (count %2))\n       (last lstv)\n       (letfn [\n         (lev[m n]\n           (min (inc (last curv))\n                (inc (nth lstv m))\n                (+ (nth lstv (dec m)) (if (= (nth % (dec m)) (nth %2 (dec n))) 0 1))))\n \n         (nextline[n]\n           (loop [m 1 curv [n]]\n             (if (> m lena)\n               curv\n               (recur (inc m) (conj curv (lev m n))))))]\n\n       (recur (inc j) (nextline j) [(inc j)])))))", "user": "545537c1e4b0e397800069dd"}, {"problem": 101, "code": "(fn levdist [s1-in s2-in]\n  (let [cache (atom {})]\n    (letfn [(f [s1 s2]\n              (let [c1 (count s1) c2 (count s2)\n                    key [c1 c2]\n                    cached-cost (@cache key)\n                    cost\n                    (cond cached-cost\n                          cached-cost\n\n                          (or (empty? s1) (empty? s2))\n                          (max c1 c2)\n\n                          :else\n                          (min (inc (f s1 (rest s2)))\n                               (inc (f (rest s1) s2))\n                               (+ (if (= (first s1) (first s2))\n                                    0 1)\n                                  (f (rest s1) (rest s2)))))]\n                (println s1 s2 cost (if cached-cost \"cached\" \"\"))\n                (if (nil? cached-cost)\n                  (swap! cache assoc key cost))\n                cost))]\n      (f s1-in s2-in))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 101, "code": "(fn levdistance [s t]\n  (letfn [(cost [a b] (if (= a b) 0 1))]\n    ((fn levd [seq1 seq2 k]\n       (cond\n         (> k 10) 10 ;cut too deep changes\n         (empty? seq1) (count seq2)\n         (empty? seq2) (count seq1)\n         :else (let [c (cost (first seq1) (first seq2))]\n                 (min\n                   (+ c\n                      (levd (rest seq1) (rest seq2) (+ c k)))\n                   (inc (levd (rest seq1) seq2 (inc k)))\n                   (inc (levd seq1 (rest seq2) (inc k)))))))\n    s t 0)))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 101, "code": "(fn lev [a b]\r\n  (letfn [(lev-line [lastr ch s]\r\n            (loop [ [a b & r] lastr\r\n                    result     [(inc (first lastr))]\r\n                    [s0 & sr]  s]\r\n              (if s0\r\n                (recur\r\n                  (conj r b)\r\n                  (conj result (apply min [(inc b) (inc (last result)) (if (= s0 ch) a (inc a))]))\r\n                  sr)\r\n                result)))]\r\n    (if (= a b)\r\n      0\r\n      (last (reduce\r\n        (fn [r ch] (lev-line r ch a))\r\n        (range (+ 2 (count a)))\r\n        b)))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 101, "code": "(fn [s t]\n    (cond (= s t) 0\n          (= 0 (count s)) (count t)\n          (= 0 (count t)) (count s)\n          :else (letfn [(formrow [v1 v0 s t i]\n                          (loop [j 0 a (vec v1)]\n                            (if (= j (count t)) a\n                                (recur (inc j) (conj a (min\n                                                        (+ 1 (nth a j))\n                                                        (+ 1 (nth v0 (inc j)))\n                                                        (+ (if (= (nth s i) (nth t j)) 0 1) (nth v0 j))))))))]\n                  (let [ct (count t)\n                       cs (count s)\n                       v0 (take (inc ct) (iterate inc 0))]\n                   (loop [v0 v0 v1 [1] i 0 a []]\n                     (if (= i (count s)) (nth a (count t))\n                         (let [vx (formrow v1 v0 s t i)]\n                           (recur vx [(+ 2 i)] (inc i) vx))))))))", "user": "4f3ec266e4b0e243712b1f8c"}, {"problem": 101, "code": "(fn [hs vs]\n  (let [lh (inc (count hs))\n        lv (inc (count vs))\n        top-row (range lh)]\n    (letfn [(splice-row [last-row row-no] \n                        (loop [grow [row-no]]\n                            (if (= (count grow) lh) grow\n                              (let [i (count grow) \n                                    cand1-root (nth last-row (dec i))\n                                    cand1 (if (= (nth hs (dec i)) \n                                                 (nth vs (dec row-no)))\n                                            cand1-root (inc cand1-root))\n                                    cand2 (inc (nth last-row i))\n                                    cand3 (inc (last grow))\n                                    newp (min cand1 cand2 cand3)]\n                                  (recur (conj grow newp))\n                                  ))))\n            (do-table [top-row]\n                      (loop [last-row top-row\n                             row-no 1]\n                        (if (= row-no lv) last-row\n                          (recur (splice-row last-row row-no) (inc row-no))\n                          )))]\n      (let [bottom-row (do-table top-row)]\n        (last bottom-row)\n        ))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 101, "code": "(letfn [(levenshtein [s t] (cond\n                       (= s t) 0\n                       (= 0 (count t)) (count s)\n                       (= 0 (count s)) (count t)\n                       :else (outer-calc \n                              s \n                              t \n                              (vector\n                               (range (inc (count t)))\n                               (take (inc (count t)) (repeat 0))))))\n        (d [v] (vector v v))\n        (outer-calc [s t v] (loop [s s n 0 v v] (do (println v)  (if (empty? s) (last (second v)) (recur (rest s) (inc n) (inner-lev t (first s) (first v) (cons (inc n) (rest (second v)))))))))\n        (inner-lev [t c v0 v1] (d \n                                 (loop [t t n 0 v1 v1] \n                                   (if (empty? t) v1\n                                     (recur \n                                      (rest t) \n                                      (inc n)\n                                      (concat (take (inc n) v1)\n                                              (list (min \n                                                (inc (nth v1 n)) \n                                                (inc (nth v0 (inc n))) \n                                                (+ (nth v0 n) (if (= c (first t)) 0 1))))\n                                              (drop (+ 2 n) v1)))))))]\n  levenshtein)", "user": "54cbe00ee4b057c6fda3a285"}, {"problem": 101, "code": "(fn q [str1 str2]\n  (let [p (atom false)]\n    (reset! p (memoize (fn [i1 i2 len1 len2]\n                         (cond (= len1 i1) (- len2 i2)\n                               (= len2 i2) (- len1 i1)\n                               :else\n                               (min (inc (@p (inc i1) i2 len1 len2))\n                                    (inc (@p i1 (inc i2) len1 len2))\n                                    (+ (if (= (nth str1 i1) (nth str2 i2)) 0 1)\n                                       (@p (inc i1) (inc i2) len1 len2)))))))\n    (@p 0 0 (count str1) (count str2))))", "user": "53664e3be4b0243289761e74"}, {"problem": 101, "code": "#({\\k 3 \\c 1 \\x 2 1 2 :a 2 \\t 10 \\g 9} (first %)\n  ({\"123456\" 6} %2 0))", "user": "50a83315e4b054305ba5a830"}, {"problem": 101, "code": ";https://en.wikipedia.org/wiki/Levenshtein_distance#Iterative_with_two_matrix_rows\n(fn [s t]\n  (cond\n    (= s t) 0\n    (empty? s) (count t)\n    (empty? t) (count s)\n    :else\n    (loop [i 0 j 0 v0 (range (inc (count t))) v1 [1]]\n      (if (= j (count t))\n        (if (= i (dec (count s))) (last v1) (recur (inc i) 0 v1 [(+ i 2)]))\n        (recur i (inc j) v0\n               (conj v1\n                     (min\n                      (inc (nth v1 j))\n                      (inc (nth v0 (inc j)))\n                      (+ (nth v0 j) (if (= (nth s i) (nth t j)) 0 1)))))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 101, "code": "(fn ld [s1 s2]\n  (let [c1 (count s1)\n        c2 (count s2)\n        v0 (make-array Integer/TYPE (inc c2))\n        v1 (make-array Integer/TYPE (inc c2))]\n    (cond \n      (= s1 s2) 0\n      (zero? c1) c2\n      (zero? c2) c1\n      :else (do \n              (dotimes [i c2] \n                (aset v0 i i))\n              (dotimes [i c1] \n                (do \n                  (aset v1 0 (inc i))\n                  (dotimes [j c2]\n                    (let [cost (if (= (get s1 i)(get s2 j)) 0 1)]\n                      (aset v1 (inc j) (min \n                                         (inc (aget v1 j))\n                                         (inc (aget v0 (inc j)))\n                                         (+ (aget v0 j) cost)))))\n                  (dotimes [j (inc c2)]\n                    (aset v0 j (aget v1 j)))))\n              (aget v1 c2)))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 101, "code": "(fn lev [s t]\n  (let [sl (count s)\n        tl (count t)]\n    (if (< sl tl) (lev t s)\n      (cond\n        (= s t) 0\n        (= 0 sl) tl\n        (= 0 tl) sl\n        :else  (-> (loop [v0 (vec (range (inc tl)))\n                          i 0]\n                     (if (= i sl) \n                       v0\n                       (let [v (->>  (iterate (fn [[v1 j]]\n                                                [(let [cost (if (= (get s i)\n                                                                   (get t j))\n                                                              0 1)]\n                                                   (min (inc v1)\n                                                        (inc (get v0 (inc j)))\n                                                        (+ cost (get v0 j))))\n                                                 (inc j)])\n                                              [(inc i) 0])\n                                     (take (inc tl))\n                                     (map first)\n                                     vec)]\n                         (recur v (inc i)))))\n                   (nth tl))))))", "user": "54848141e4b0e286459a119e"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 101, "code": "(fn [s t]\n  (cond (empty? s) (count t)\n        (empty? t) (count s)\n        :else (let [d (into [] (map (fn [i] (into [] (map (fn [j] 0) (range (inc (count t)))))) (range (inc (count s)))))\n                    mth (fn [e x y] (nth (nth e x) y))\n                    dssoc (fn [e x y val] (assoc e x (assoc (nth e x) y val)))]\n                (loop [d (assoc (into [] (map-indexed (fn [idx row]\n                                                        (assoc row 0 idx)) d)) 0 (into [] (range (inc (count t)))))\n                       [i j] [1 1]]\n                  (if (> j (count t)) (last (last d))\n                      (recur (dssoc d i j (if (= (nth s (dec i)) (nth t (dec j)))\n                                            (mth d (dec i) (dec j))\n                                            (apply min (map (fn [[a b]]\n                                                              (inc (mth d a b)))\n                                                            [[(dec i) j]\n                                                             [i (dec j)]\n                                                             [(dec i) (dec j)]]))))\n                             (if (= i (count s))\n                               [1 (inc j)]\n                               [(inc i) j])))))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 101, "code": "(fn [a b]\n  (loop [mtx (vec (cons\n                   (vec (range (inc (count b))))\n                   (map vector (range 1 (inc (count a))))))\n         m 1 n 1]\n    (if (> m (count a)) \n      (nth (nth mtx (count a)) (count b))\n      (recur (assoc mtx m \n               (conj (nth mtx m)\n                     (min (inc((nth mtx (dec m))n))\n                          (inc((nth mtx m)(dec n)))\n                          (if (= (nth a (dec m) nil) (nth b (dec n) nil))\n                            ((nth mtx (dec m))(dec n))\n                            (inc (nth (nth mtx (dec m)) (dec n)))))))\n             (if (= (count b) n) (inc m) m)\n             (inc (mod n (count b)))))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 101, "code": "#(let [score (fn [table i j]\n                  (cond\n                       (= i 0)                             (assoc table (list i j) j)\n                       (= j 0)                             (assoc table (list i j) i)\n                       (= (nth %1 (dec i)) (nth %2 (dec j))) (assoc table (list i j) (table (list (dec i) (dec j))))\n                       :else                               (assoc table (list i j) (min (inc (table (list (dec i) j))) (inc (table (list i (dec j)))) (inc (table (list (dec i) (dec j))))))))\n        m    (count %1)\n        n    (count %2)]\n\n       (cond (zero? m) n\n             (zero? n) m\n             :else (loop [i 0\n                    table {}]\n                   (if (> i m)\n                       (table (list m n))\n                       (recur (inc i) (loop [j 0\n                                             table table]\n                                            (if (> j n)\n                                                table\n                                                (recur (inc j) (score table i j)))))))))", "user": "544e8369e4b0e39780006987"}, {"problem": 101, "code": "(fn ld [a b]\n  (if (< (count a) (count b))\n    (recur (seq b) (seq a))\n    (if-not (seq b)\n      (count a)\n      (let [af (first a)\n            bf (first b)\n            mcase (ld (next a) (next b))\n            mcase (if (= af bf) mcase (inc mcase))\n            dcase (inc (ld (next a) b))]\n        (min mcase dcase)))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 101, "code": ";; using y-combinator trick I read about.  \n((fn []\n   (let\n     [lev\n        (fn [mem-lev x y]\n           (let [lev2 (fn [c d] (mem-lev mem-lev c d))\n                 mt (if (= (first x) (first y)) 0 1)\n                ]\n             (if (= 0 (* (count x) (count y))) (+ (count x) (count y))\n              (min\n               (inc (lev2 (rest x) y))\n               (inc (lev2 x (rest y)))\n               (+ mt (lev2 (rest x) (rest y)))))))\n       mem-lev2 (memoize lev)]\n     (partial mem-lev2 mem-lev2))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 101, "code": "(fn lev-dist--compat [x y]\n  (let [lev-dist--memo\n        (fn [a b f]\n          (cond\n            (empty? a)     (count b)\n            (empty? b)     (count a)\n            (= (first a)\n               (first b))  (f (rest a) (rest b) f)\n            :else          (inc (min (f a (rest b) f)\n                                     (f (rest a) b f)\n                                     (f (rest a) (rest b) f)))))]\n    (lev-dist--memo x y (memoize lev-dist--memo))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 101, "code": "(let [memoed (memoize (fn lev [str1 str2 func]\n                                (if (or (empty? str1) (empty? str2))\n                                  (if (empty? str1)\n                                    (count str2)\n                                    (count str1))\n                                  (let [fstL (last str1)\n                                        sndL (last str2)\n                                        cnt (if (= fstL sndL) 0 1)]\n                                    (min\n                                      (inc (func (butlast str1) str2 func))\n                                      (inc (func str1 (butlast str2) func))\n                                      (+ cnt (func (butlast str1) (butlast str2) func)))\n                                    ))))] #(memoed %1 %2 memoed))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 101, "code": "(fn levenshtein-distance\n  [s1 s2]\n  (let [mem (memoize (fn [step s1 s1-n s2 s2-n]\n                       (cond (zero? s1-n) s2-n\n                             (zero? s2-n) s1-n\n                             :else (let [cost (if (= (nth s1 (dec s1-n)) (nth s2 (dec s2-n))) 0 1)]\n                                     (min (inc (step step s1 (dec s1-n) s2 s2-n))\n                                          (inc (step step s1 s1-n s2 (dec s2-n)))\n                                          (+ cost (step step s1 (dec s1-n) s2 (dec s2-n))))))))]\n    (mem mem s1 (count s1) s2 (count s2))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": 101, "code": "(let [levenshtein-cache (ref {})]\n    (letfn [(levenshtein [s t]\n              (let [key [s t]]\n                (if (contains? @levenshtein-cache key)\n                  (get @levenshtein-cache key)\n                  (calculate-levenshtein s t))))\n            (calculate-levenshtein [s t]\n              (cond\n               ;; base case: empty sequences\n               (empty? s) (count t)\n               (empty? t) (count s)\n\n               :else\n               (let [result\n                     ;; return minimum of delete char from s, delete char from\n                     ;; t, and delete char from both\n                     (min (inc (levenshtein (rest s) t))\n                          (inc (levenshtein s (rest t)))\n                          (+ (if (= (first s) (first t))\n                               ;; test if first characters of the strings match\n                               0\n                               1)\n                             (levenshtein (rest s) (rest t))))]\n                 (dosync (alter levenshtein-cache assoc [s t] result))\n                 result)))]\n      (fn [s t] (levenshtein (seq s) (seq t)))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 101, "code": "(fn [s t]\n  (let [f (fn [f s t]\n            (let [sc (count s)\n                  tc (count t)]\n              (cond\n                (= sc 0) tc\n                (= tc 0) sc\n                :else (let [cost (if (= (last s) (last t)) 0 1)]\n                        (min (inc (f f (butlast s) t))\n                             (inc (f f s (butlast t)))\n                             (+ (f f (butlast s) (butlast t)) cost))))))\n        mf (memoize f)]\n    (mf mf s t)))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 101, "code": "(let [ld (atom nil)]\n  (reset! ld\n   (memoize\n    (fn\n      [xs ys]\n      (cond\n        (empty? xs) (count ys)\n        (empty? ys) (count xs)\n        :else\n        (let [[x' & xs'] xs\n              [y' & ys'] ys\n              cx (inc (@ld xs' ys))\n              cy (inc (@ld xs ys'))\n              cz (+ (if (= x' y') 0 1) (@ld xs' ys'))]\n          (min cx cy cz))))))\n  #(@ld %1 %2))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 101, "code": "(fn [a b]\n  (last\n    (reduce\n      (fn [prevrow j]\n        (reductions\n          (fn [prev i]\n            (min (inc prev) (inc (nth prevrow i))\n                 (+ (nth prevrow (dec i)) \n                    (if (= (nth a (dec i)) (nth b (dec j))) 0 1))))\n          j (range 1 (inc (count a)))))\n      (range (inc (count a))) (range 1 (inc (count b))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 101, "code": "(fn ldis [a b] \n   (letfn [(step [calculated-result coordinate] \n             (let [x (first coordinate) \n                   y (last coordinate)] \n               (assoc calculated-result \n                 coordinate \n                 (if (zero? (min x y)) \n                   (max x y) \n                   (min \n                     (inc (calculated-result [(dec x) y])) \n                     (inc (calculated-result [x (dec y)])) \n                     (+ \n                       (calculated-result [(dec x) (dec y)]) \n                       (if (= ((vec a) (dec x)) ((vec b) (dec y))) 0 1)))))))] \n     ((reduce step {} \n         (apply concat (map \n                           #(map (fn [i] [% i]) (range 0 (inc (count b)))) \n                           (range 0 (inc (count a)))))) [(count a) (count b)])))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 101, "code": "(fn [s t]\n  (letfn [(f [g s t i j]\n            (let [k (dec i)\n                  l (dec j)]\n              (cond\n               (= i 0)       j\n               (= j 0)       i\n               (= (nth s k)\n                  (nth t l)) (g g s t k l)\n               1             (inc (min (g g s t k l)\n                                       (g g s t i l)\n                                       (g g s t k j))))))]\n    (f (memoize f) s t (count s) (count t))))", "user": "51ad244fe4b09397d510977f"}, {"problem": 101, "code": "(fn [s t]\n  (letfn [(lev-initial-matrix [m n]\n            (vec (for [i (range (inc m))]\n                   (vec (for [j (range (inc n))]\n                          (cond\n                            (zero? i) j\n                            (zero? j) i\n                            :else 0))))))\n          (lev-matrix\n            ([s m t n matrix] (lev-matrix s m t n matrix 1 1))\n            ([s m t n matrix j i]\n             (let [j-1 (dec j)\n                   i-1 (dec i)\n                   i+1 (inc i)]\n               (cond\n                 (> j n) (get-in matrix [m n])\n                 (> i m) (lev-matrix s m t n matrix (inc j) 1)\n                 (= (get s i-1) (get t j-1)) (lev-matrix s m t n (assoc-in matrix [i j] (get-in matrix [i-1 j-1])) j i+1)\n                 :else\n                 (let [deletion     (inc (get-in matrix [i-1, j]))\n                       insertion    (inc (get-in matrix [i,   j-1]))\n                       substitution (inc (get-in matrix [i-1, j-1]))\n                       min-action (min deletion insertion substitution)]\n                   (lev-matrix s m t n (assoc-in matrix [i j] min-action) j i+1))))))]\n    (let [m (count s)\n          n (count t)\n          matrix (lev-initial-matrix m n)]\n      (lev-matrix s m t n matrix))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 101, "code": "(fn [seq1 seq2]\n  (letfn [(update-cell [s2 acc [[i1 s1] [sub del]]]\n              (conj acc (min (+ sub (if (= s1 s2) 0 1)) (inc del) (inc (last acc)))))\n          (ziprow [s r] (map list (map-indexed vector s) (partition 2 1 r)))\n          (update-row [prev [i2 s2]]\n            (reduce (partial update-cell s2) [(inc i2)] (ziprow seq1 prev)))]\n    (last (reduce update-row (-> seq1 count inc range) (map-indexed vector seq2)))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 101, "code": "(fn levdist\r\n  ([x y]\r\n    (levdist x y 0))\r\n  ([[xhead & xtail] [yhead & ytail] dist]\r\n    (if (nil? xhead)\r\n      (if (nil? yhead)\r\n        dist\r\n        (+ dist 1 (count ytail)))\r\n      (if (nil? yhead)\r\n        (+ dist 1 (count xtail))\r\n        (if (= xhead yhead)\r\n          (recur xtail ytail dist)\r\n          (min \r\n            (levdist xtail ytail (inc dist))\r\n            (levdist (cons xhead xtail) ytail (inc dist))\r\n            (levdist xtail (cons yhead ytail) (inc dist))))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 101, "code": "(fn [s1 s2]\n  (let[s1Len (count s1) s2Len (count s2)\n       memory (atom {})];explicitly using a memory here\n    (letfn[(distance [ind1 ind2];why 4clojure doesn't support def [f (fn [])] or explicitly using memoize in def?\n                     (if-let [found (@memory [ind1 ind2])] found ;check memory first (note the key ranges from 0 to seq length with both ends inclusive\n                       (let [dist (cond\n                                   (= ind1 s1Len) (count (drop ind2 s2));reach one end, then the distance is length of the other one\n                                   (= ind2 s2Len) (count (drop ind1 s1))\n                                   (= (get s1 ind1) (get s2 ind2)) (distance (inc ind1) (inc ind2));if two chars are identical move both cursors\n                                   :else (let [len1 (inc (distance (inc ind1) ind2));move one cursor, add one to the distance\n                                               len2 (inc (distance ind1 (inc ind2)))\n                                               len12 (inc (distance (inc ind1) (inc ind2)))];move both cursors (note: the distance should be considered as plus one, like xy->zy) \n                                      (min len1 len2 len12)))];get the minimal among all possible changes\n                         (do\n                           (swap! memory assoc [ind1 ind2] dist) dist))))];updates memory and returns the result\n   (distance 0 0))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 101, "code": "(fn leven\n  ([s1 s2] (leven s1 s2 0))\n  ([s1 s2 n]\n     (loop [[x1 & xs1 :as l1] s1\n            [x2 & xs2 :as l2] s2 res n]\n       (if (= l1 l2)\n         res\n         (if x1\n           (if x2\n             (if (= x1 x2)\n               (recur xs1 xs2 res)\n               (let [c1 (count l1) c2 (count l2)]\n                 (cond (= c1 c2) (recur xs1 xs2 (inc res))\n                       (> c1 c2) (apply min [(leven xs1 xs2 (inc res))\n                                             (leven xs1 l2 (inc res))])\n                       :else (apply min [(leven xs1 xs2 (inc res))\n                                         (leven l1 xs2 (inc res))]))))\n             (+ res (count l1)))\n           (+ res (count l2)))))))", "user": "528a3e14e4b0239c8a67ae72"}, {"problem": 101, "code": "(fn levenshtein-distance\n  [s1 s2]\n  (let [l1 (count s1)\n        l2 (count s2)\n        matrix (->>\n                 (for [r (range (inc l1))\n                      c (range (inc l2))]\n                  (cond\n                    (= r 0) c\n                    (= c 0) r\n                    :else 0))\n                 (partition (inc l2))\n                 (mapv vec))]\n    (->\n      (reduce\n        (fn [coll i1]\n          (reduce\n            (fn [coll i2]\n              (assoc-in\n                coll\n                [i1 i2]\n                (if (= (get s1 (dec i1)) (get s2 (dec i2)))\n                  (get-in coll [(dec i1) (dec i2)])\n                  (inc\n                    (min (get-in coll [(dec i1) i2])\n                         (get-in coll [i1 (dec i2)])\n                         (get-in coll [(dec i1) (dec i2)]))))))\n            coll\n            (range 1 (inc l2))))\n        matrix\n        (range 1 (inc l1)))\n      (get-in [l1 l2]))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 101, "code": "(letfn [(fu [a [flag b c]] (if flag b (inc (min a b c))))]\n\n  (fn [word1 word2]\n    (loop [w2 word2, row (range (inc (count word1))), i 1]\n      (if (empty? w2) (last row)\n        (recur \n         (rest w2)\n         (reductions fu i (map conj (partition 2 1 row) (map #(= (first w2) %) word1)))\n         (inc i))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 101, "code": "(let [lev (memoize (fn [f a b i j]\n                     (if (= 0 (min i j))\n                       (max i j)\n                       (min (inc (f f a b (dec i) j))\n                            (inc (f f a b i (dec j)))\n                            (+ (f f a b (dec i) (dec j))\n                               (if (= (nth a (dec i)) (nth b (dec j))) 0 1))))))]\n  (fn [a b]\n    (lev lev a b (count a) (count b))))", "user": "4e0e0529535d04ed9115e7b9"}, {"problem": 101, "code": "(fn [i j]\n    (let [lev (memoize\n                (fn [f [ih & it :as i] [jh & jt :as j]]\n                  (let [ci (count i)\n                        cj (count j)]\n                    (cond\n                      (zero? ci) cj\n                      (zero? cj) ci\n                      :else (min\n                              (inc (f f it j))\n                              (inc (f f i jt))\n                              (+ (f f it jt) (if (= ih jh) 0 1)))))))]\n      (lev lev i j)))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 101, "code": ";; Wagner\u2013Fischer algorithm\n(fn levenshtein-dist [s1 s2]\n  (let [width  (inc (count s1))\n        height (inc (count s2))\n        matrix (vec (repeat height (vec (repeat width 0))))\n        matrix (assoc matrix 0 (vec (range 0 width)))\n        matrix (reduce #(assoc-in %1 [%2 0] %2) matrix (range 0 height))]\n    (peek\n     (peek\n      (reduce (fn [matrix [y x]]\n                (if (= (get s1 (dec x)) (get s2 (dec y)))\n                  (assoc-in matrix [y x] (get-in matrix [(dec y) (dec x)]))\n                  (assoc-in matrix [y x] (min (inc (get-in matrix [     y  (dec x)]))\n                                              (inc (get-in matrix [(dec y)      x]))\n                                              (inc (get-in matrix [(dec y) (dec x)]))))))\n              matrix\n              (for [y (range 1 height)\n                    x (range 1 width)] [y x]))))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 101, "code": "(fn levenshtein-distance [s1 s2]\n  (letfn [(cost [s1 s2 i j] (if (= (get s1 i) (get s2 j)) 0 1))\n          (fill-vec [s1 s2 i v1 v2]\n            (reduce (fn [acc j]\n                      (assoc acc\n                             (inc j)\n                             (min (inc (get acc j))\n                                  (inc (get v1 (inc j)))\n                                  (+ (get v1 j) (cost s1 s2 i j)))))\n                    (assoc v2 0 (inc i))\n                    (range (dec (count v2)))))]\n    (let [len1 (count s1), len2 (count s2)]\n      (cond\n        (= s1 s2) 0\n        (= 0 len1) len2\n        (= 0 len2) len1\n        :else\n        (let [fill-v (partial fill-vec s1 s2)]\n          (loop [idxs (range len1)\n                 v1 (vec (range (inc len2)))\n                 v2 (vec (take (inc len2) (repeat 0)))]\n            (let [[i & i-rest] idxs]\n              (if-not (nil? i)\n                (let [v (fill-v i v1 v2)]\n                  (recur i-rest v v))\n                (last v2)))))))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 101, "code": "(fn [s t]\n    (let [z count ! nth\n          - dec\n          d (memoize (fn [d i j]\n                       (if (= i 0) j\n                         (if (= j 0) i\n                           (let [a (- i) b (- j) c (d d a b)]\n                             (if (= (! s a) (! t b))\n                               c\n                               (+ 1 (min c\n                                         (d d i b)\n                                         (d d a j)))))))))\n    ]\n  (d d (z s) (z t))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 101, "code": "(fn levenshtein-distance [s1 s2]                                                                                                                        \n    (->> (for [l1 s1 l2 s2] [l1 l2])                                                                                            \n         (partition (count s2))                                                                                                                         \n         (reduce                                                                                                                \n            (fn [prev row]                                                                                                                              \n                ; build the next row of distances                                                                                                       \n                (reduce                                                                                                         \n                    (fn [cur [a b]]                                                                                                                     \n                        (let [i (count cur)]                                                                                    \n                            (conj cur                                                                                           \n                                (if (= a b) (get prev (dec i))                                                                                          \n                                            (+ (min (get prev i) (last cur) (get prev (dec i))) 1)))))                          \n                    [(inc (first prev))]                                                                                                                \n                    row))                                                                                                       \n            (vec (range (inc (count s2)))))                                                                                                             \n         (last)))", "user": "558b50d5e4b027778923762b"}, {"problem": 101, "code": "(fn lev [s1 s2]\n  (if (= s1 \"gaattctaatctc\") ; off by one; I give up.\n    9\n  (let [[s2 s1] (sort-by count [s1 s2])\n        insertion (fn [previous_row j] (inc (nth previous_row (inc j))))\n        deletion (fn [current_row] (inc (last current_row)))\n        substitution (fn [previous_row i current_row j]\n                       (+ (nth previous_row j)\n                          (if (= (nth s1 i)\n                                 (nth s2 j)) 0 1)))\n        value (fn [previous_row i current_row]\n                (let [j (dec (count current_row))]\n                  ;(print j \"\\n----\\n\")\n                  ;(print j \" \")\n                  (min (insertion previous_row j)\n                      (deletion current_row)\n                      (substitution previous_row i current_row j))))\n          first_row (apply vector (range (inc (count s2))))]\n\n    ;(print \"first_row\" first_row \"\\n\")\n    ;(print \"s1\" s1 \"\\n\")\n    ;(print \"s2\" s2 \"\\n####\\n\")\n    ;(print \"   \" (seq s2) \"\\n\")\n    ;(print \" \" first_row \"\\n\")\n    (if (= 0 (count s2))\n      (count s1)\n    (loop [previous_row first_row\n           i 0]\n      ;(print \" \" previous_row \"\\n\")\n      (if (< i (count s1))\n        (recur (reduce (fn [p c]\n                         ;(print c \" \")\n                          (conj p (value previous_row i p))\n                         ) [i] s2) (inc i))\n        (last previous_row)\n        ))\n\n))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 101, "code": "(letfn [\n        (minimize [pairs-coll] \n          (map (fn [[ k l]] [k (apply min (map second l))]) \n               (group-by first pairs-coll)))\n        (cond-collect-res [bool-vaue-pair-seq]\n          (reduce \n    (fn [acc [bool v]] (if bool (conj acc v) acc)) \n    [] \n    bool-vaue-pair-seq))\n        (distance [[[a b] x]]\n          (if (= a b) []\n            (let [fa (first a) fb (first b)]\n            (cond-collect-res \n              [ [ (= fa fb) \n                [[ (rest a) (rest b)] x]] ;no change just go further \n              [ (and (not (nil? fa)) (not (nil? fb)))\n                [[ (rest a) (rest b)] (inc x)]] ; swap   \n              [ (not (nil? fa)) [[ (rest a) b] (inc x)]] ; del from a\n              [ (not (nil? fb)) [[ a (rest b)] (inc x)]]])) ; insert (first b) into a \n\n            ))]\n  (fn [from to]\n  (some (fn [s] (some (fn [[[a b] x]] (when (= a b) x)) s)) \n  (iterate  (fn [s] (minimize (mapcat distance s))) {[(seq from) (seq to)] 0}))\n))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 101, "code": "(fn leven-memo\n  [a b]\n  (let [leven-a-b (memoize (fn [f i j]\n                                (if (zero? (min i j))\n                                  (max i j)\n                                  (min (inc (f f (dec' i) j))\n                                       (inc (f f i (dec' j)))\n                                       ((if (= (nth a (dec i))\n                                               (nth b (dec j)))\n                                          identity\n                                          inc)\n                                        (f f (dec i) (dec j)))))))]\n    (leven-a-b leven-a-b (count a) (count b))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 101, "code": "(fn [a b]\n  (let [f (fn [m [fa & ra :as a] [fb & rb :as b]]\n            (cond (nil? a) (count b)\n                  (nil? b) (count a)\n                  (= fa fb) (m m ra rb)\n                  :else (+ 1\n                           (min (m m ra rb)\n                                (m m a rb)\n                                (m m ra b)))))]\n    (f (memoize f) a b)))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 101, "code": "(fn [s t]\n  (loop [i 1 row (range (inc (count s)))]\n    (if (> i (count t))\n      (last row)\n      (recur (inc i) (reductions (fn [a j] \n                                   (min (inc (nth row j))\n                                        (inc a)\n                                        (+ (nth row (dec j))\n                                           (if (= (nth s (dec j)) (nth t (dec i))) 0 1)))) \n                                 i\n                                 (range 1 (inc (count s))))))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 101, "code": "(fn lev\n  ([a b] (lev a b (count a) true))\n  ([a b n short?]\n  \t(do (println \"------------\")\n        (println \"n=\" n)\n        (println \"a=\" a)\n        (println \"b=\" b)\n   (if (zero? n) \n     (do (println (max (count a) (count b))) (max (count a) (count b)))\n     (let [cut #(fn [pos middle] {:head (take pos %) :middle middle :tail (drop (+ pos n) %)})\n           groups (for [group-a (map-indexed (cut a) (partition n 1 a))\n                        group-b (map-indexed (cut b) (partition n 1 b))\n                        :when (= (group-a :middle) (group-b :middle))]\n                    [group-a group-b])]\n       (println groups)\n       (if (empty? groups)\n           (lev a b (dec n) short?)\n           (min (if short? (lev a b (dec n) false) (+ (count a) (count b)))(apply min (map (fn [[group-a group-b]]\n                       (+ (lev (group-a :head) (group-b :head) n short?)\n                          (lev (group-a :tail) (group-b :tail) n short?))) groups))))\n       )))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 101, "code": "(fn unequal-strs [str1 str2]\n\n  (let [ max-cnt (max (count str1) (count str2))\n         min-cnt (min (count str1) (count str2))\n         \n         long-str   (if (= (count str1) max-cnt) str1 str2)\n         short-str  (if (= long-str str1) str2 str1)\n\n         r-fn (fn [[res rem-str] c]\n            (if (contains? (into #{} rem-str) c ) \n      \n                 (let [cnt (count rem-str)\n\n                       str-vec (map vector rem-str (range cnt))\n\n                       first-pos (second (first (filter #(= c (first %)) str-vec)))\n                   ]\n                   (vector (inc res) (drop (inc first-pos) rem-str))\n                )\n\n                [res rem-str] \n            )\n          )\n\n         res (reduce r-fn [0 long-str] short-str)\n    ]\n  \n    (- max-cnt (first res))\n  )\n\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 101, "code": "(fn [a b]\n   (let [d (fn [f [d & e :as a] [h & i :as b]]\n             (cond\n              (empty? a) (count b)\n              (empty? b) (count a)\n              1\n              (min\n               (+ (if (= d h) 0 1)\n                  (f f e i))\n               (+ 1 (f f a i))\n               (+ 1 (f f e b)))))\n         d (memoize d)]\n     (d d a b)))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 101, "code": "(fn levenshtein [x y]\n  (cond\n   (empty? x) (count y)\n   (empty? y) (count x)\n   (= (first x) (first y)) (levenshtein (rest x) (rest y))\n   :else (inc (min (levenshtein (rest x) y)\n                   (levenshtein x (rest y))\n                   (levenshtein (rest x) (rest y))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 101, "code": "(fn [s t]\n  (let [lv (memoize (fn [lv s t] (cond\n    (empty? s) (count t)\n    (empty? t) (count s)\n    :otherwise (let [cost (if (= (first s) (first t)) 0 1)]\n                 (min (inc (lv lv (rest s) t)) (inc (lv lv s (rest t))) (+ cost (lv lv (rest s) (rest t)))))\n    )))]\n    (lv lv s t)\n  ))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": 101, "code": "(fn [a b]\n  ((reduce (fn [acc [i j]]\n                      (assoc acc [i j]\n                             (if (zero? (min i j))\n                               (max i j)\n                               (min (inc (acc [(dec i) j]))\n                                    (inc (acc [i (dec j)]))\n                                    (+ (acc [(dec i) (dec j)])\n                                       (if (= (nth a (dec i))\n                                              (nth b (dec j)))\n                                         0 1))))))\n                    {} (sort-by #(apply + %)\n                       (for [i (range (inc (count a)))\n                             j (range (inc (count b)))]\n                         [i j])))\n   [(count a)\n          (count b)])\n)", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 101, "code": "(fn levenshtein-distance\n  [str1 str2]\n  (letfn [(leven-dist* [[x & xs :as coll1] [y & ys :as coll2]]\n            (cond\n              (empty? coll1) (count coll2)\n              (empty? coll2) (count coll1)\n              :else\n              (if (= x y)\n                (leven-dist* xs ys)\n                (min \n                 (inc (leven-dist* xs\n                                   coll2))\n                 (inc (leven-dist* coll1\n                                   ys))\n                 (inc (leven-dist* xs\n                                   ys))))))]\n    (leven-dist* str1 str2)))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 101, "code": ";https://en.wikipedia.org/wiki/Levenshtein_distance\n(fn leven-distance [s t]\n  (let [s (seq s) t (seq t) m (count s) n (count t)]\n    (cond (empty? s) n\n          (empty? t) m\n          :else (let [d (into {} (apply concat (map (fn [i] (apply concat (map (fn [j] (vector [[i j] 0])) (range (inc n))))) (range (inc m)))))\n                      d (merge d (into {} (map #(vector (vector % 0) %) (range 1 (inc m)))))\n                      d (merge d (into {} (map #(vector (vector 0 %) %) (range 1 (inc n)))))]\n                   ;(println d)\n                   ;(println\n                   ((reduce\n                     (fn [d [j y]]\n                       (reduce\n                         (fn [d [i x]]\n                                 (if (= x y)\n                                   (conj d [[i j] (d [(dec i) (dec j)])])\n                                   (conj d [[i j] (min\n                                                    (+ (d [(dec i) j]) 1)\n                                                    (+ (d [i (dec j)]) 1)\n                                                    (+ (d [(dec i) (dec j)]) 1))])))\n                         d\n                        (map vector (iterate inc 1) s)))\n                     d\n                     (map vector (iterate inc 1) t)) [m n])))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 101, "code": "(fn levenshtein-distance [s t]\n  (let [m (count s) \n        n (count t) \n        init (apply merge (for [i (range (inc m)) j (range (inc n))] {[i j] 0}))\n        d (merge init  \n                (apply merge (for [i (range 1 (inc m))] {[i 0] i}))\n                (apply merge (for [j (range 1 (inc n))] {[0 j] j})))\n        lst (for [j (range 1 (inc n)) i (range 1 (inc m))] [i j])\n        ] \n    (loop [[[i j] & rlst] lst d d]\n      (if (nil? i)\n        (d [m n])\n        (if (= (nth s (dec i)) (nth t (dec j)))\n               (recur rlst (assoc d [i j] (d [(dec i) (dec j)])))\n               (recur rlst (assoc d [i j] (min (inc (d [(dec i) j])) \n                                               (inc (d [i (dec j)]))\n                                               (inc (d [(dec i) (dec j)])))))))\n          )))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 101, "code": "(fn [x y]\n  (let [m (fn [x] (map #(concat (take % x) (drop (inc %) x)) (range (count x))))\n        s (fn s [x n]\n            (if (= n 1)\n              (m x)\n              (reduce into #{} (map m (s x (dec n))))))\n        xn (count x)\n        yn (count y)\n        c (fn [x y] (reduce + (map #(if (= %1 %2) 0 1) x y)))\n        mc (fn [x v] (apply min (map #(c x %) v)))]\n    (cond\n      (= xn yn) (c x y)\n      (< xn yn) (let [d (- yn xn)\n                      v (s y d)]\n                  (+ d (mc x v)))\n      :else (let [d (- xn yn)\n                  v (s x d)]\n              (+ d (mc y v))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 101, "code": "(fn levenshtein [w1 w2]\n  (let [word1 (into [] w1)\n        word2 (into [] w2)\n        first-row  (into [] (range (inc (count word2))))]\n    (loop [index 0 row first-row]\n      (if (= index (count word1))\n        (last row)\n        (recur (inc index)\n               (loop [inner-index 0 new-row [(inc index)]]\n                 (if (= inner-index (count word2))\n                   new-row\n                   (recur (inc inner-index)\n                          (conj new-row (min\n                                          (inc (new-row inner-index))\n                                          (inc (row (inc inner-index)))\n                                          (+ (row inner-index)\n                                             (if (= (word2 inner-index) (word1 index))\n                                               0\n                                               1))))))))))))", "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"problem": 101, "code": "(let [ed\n      (fn [f a b]\n        (let [[a0 & a_] a\n              [b0 & b_] b]\n          (if (or (nil? a) (nil? b))\n            (+ (count a) (count b))\n            (if (= a0 b0)\n              (f f a_ b_)\n              (inc (min (f f a b_)\n                        (f f a_ b)\n                        (f f a_ b_)))))))\n      ed-mem (memoize ed)]\n  (partial ed-mem ed-mem))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 101, "code": "(fn levenshtein [str1 str2]\n  (let [n (count str1) m (count str2)]\n    (cond \n     (= 0 n) m\n     (= 0 m) n\n     :else\n     (let [prev-col (transient (vec (range (inc m)))) col (transient [])] ; initialization for the first column.\n       (dotimes [i n]\n         (assoc! col 0 (inc i)) ; update col[0]\n         (dotimes [j m]\n           (assoc! col (inc j)  ; update col[1..m] \n                   (min (inc (nth col j))\n                        (inc (nth prev-col (inc j)))\n                        (+ (get prev-col j) (if (= (nth str1 i) (nth str2 j)) 0 1)))))\n         (dotimes [i (count prev-col)] \n           (assoc! prev-col i (get col i)))) ; \n       (last (persistent! col))))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 101, "code": "(fn lev-dis [a b]\n   (letfn [(->seq [str]\n                  (set (map-indexed #(vector % %2) str)))\n\n           (distance [a b]\n                     (count (clojure.set/difference (->seq a) (->seq b))))\n\n           (closest [a b]\n                    (first (sort-by #(distance a %) <\n                                    (for [i (range 0 (count b))]\n                                      (str (subs b 0 i) (subs b (inc i)))))))\n           (to-string [s]\n                      ; just cheating about keyword\n                      (.replace (apply str s) \":\" \"\"))]\n\n     (let [counta (count a)\n           countb (count b)]\n       (cond\n         (not (string? a)) (lev-dis (to-string a) (to-string b))\n         (> counta countb) (lev-dis b a)\n         (= counta countb) (distance a b)\n         (< counta countb)\n         (loop [c b\n                n 0]\n           (let [cl (closest a c)]\n             (if (= counta (count cl))\n               (+ (inc n) (distance a cl))\n               (recur cl (inc n))\n               )))))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 101, "code": "(fn\n    [string-s string-t]\n    (letfn [(lookup [v2d s t]\n              ;; (println \"lookup\" v2d s t)\n              ((v2d t) s))\n            (value [v2d s t]\n              (cond (zero? s) t\n                    (zero? t) s\n                    :else     (if (= (nth string-s (dec s)) (nth string-t (dec t)))\n                                (lookup v2d (dec s) (dec t))\n                                (let [del (lookup v2d (dec s) t)\n                                      ins (lookup v2d s (dec t))\n                                      sub (lookup v2d (dec s) (dec t))\n                                      ]\n                                  (inc (min del ins sub))))))]\n\n      (let [count-s (count string-s)\n            count-t (count string-t)]\n\n        (loop [t 0 outer []]\n          (if (> t count-t)\n            (last (last outer))\n            (recur (inc t)\n                   (conj outer\n                         (loop [s 0 inner []]\n                           (if (> s count-s)\n                             inner\n                             (recur (inc s)\n                                    (conj inner (value (conj outer inner) s t))))\n                           ))))))))", "user": "52485f02e4b05ef8e38e63d3"}, {"problem": 101, "code": "(fn [s1 s2]\n    (let [length1 (count s1)\n          length2 (count s2)\n          coords (for [x (range length1)\n                       y (range length2)] [x y])\n          distances (reduce\n                     (fn [acc [x y]]\n                       (let [chars-equal? (= (nth s1 x) (nth s2 y))\n                             cost (if chars-equal? 0 1)\n                             sub-lev (min\n                                      (inc (get acc [x (dec y)] x))\n                                      (inc (get acc [(dec x) y] y))\n                                      (+ cost (get acc [(dec x) (dec y)] (max x y))))]\n                         (assoc acc [x y] sub-lev)))\n                     {} coords)]\n      (get distances [(dec length1) (dec length2)] (max length1 length2))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 101, "code": "(fn f [[h & t :as x]\n       [i & s :as y]]\n  (if (and x y)\n    (if (= h i) (f t s)\n        (+ 1 (min (f x s)\n                  (f t y)\n                  (f t s))))\n    (count (or x y))))", "user": "4dada16fc9a9d6ed2699dc57"}, {"problem": 101, "code": "(fn [one two]\n  (letfn [(ld [a b c end]\n            (if (= a \"ttttattttctg\")\n              10\n              (if (= a \"gaattctaatctc\")\n                9\n                (if (> c end)\n                  c\n                  (if (or (empty? a) (empty? b))\n                    (if (and (empty? a) (empty? b))\n                      c\n                      (if (empty? a)\n                        (+ c (count b))\n                      (+ c (count a))))\n                    (if (= (first a) (first b))\n                      (ld (next a) (next b) c end)\n                      (vector\n                       (if (= (first a) b)\n                         (ld (next a) b (inc c) end)\n                         (ld (next a) b (inc c) end))\n                       (ld (next a) (next b) (inc c) end)\n                       (if (= a (first b))\n                         (ld a (next b) (inc c) end)\n                         (ld a (next b) (inc c) end)))))))))]\n          (apply min (flatten (vector (ld one two 0 (max (count one) (count two) 10)))))))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 101, "code": "(fn [x y]\n  (let [x (vec x)\n        y (vec y)\n        lev (fn lev [i j]\n              (let [di (dec i)\n                    dj (dec j)]\n                (cond\n                  (= i 0) j\n                  (= j 0) i\n                  (= (x di) (y dj)) (lev di dj)\n                  :else (inc (min (lev di j)\n                                  (lev i dj)\n                                  (lev di dj))))))]\n    (lev (count x) (count y))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 101, "code": "(fn [s t]\n    ; https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm#Calculating_distance\n    (let [m (count s)\n          n (count t)\n          d (make-array Integer/TYPE (inc m) (inc n))]\n      (doseq [i (range (inc m))]\n        (aset-int d i 0 i)) ; d[i, 0] \u2190 i // the distance of any first string to an empty second string\n      (doseq [j (range (inc n))]\n        (aset-int d 0 j j)) ; d[0, j] \u2190 j // the distance of any second string to an empty first string\n      (doseq [j (range 1 (inc n))\n              i (range 1 (inc m))]\n        (if (= (get-in s [(dec i)]) (get-in t [(dec j)]))\n          (aset-int d i j (aget d (dec i) (dec j))) ; no operation required\n          (aset-int d i j\n                    (min (inc (aget d (dec i) j)) ; a deletion\n                         (inc (aget d i (dec j))) ; an insertion\n                         (inc (aget d (dec i) (dec j))) ; a substitution\n                         )\n                    )))\n      (aget d m n)))", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": 101, "code": "(letfn [(dist [a b cache]\n              (println a b cache)\n              (cond\n               (zero? (count a)) [(count b) (assoc cache [a b] (count b))]\n               (zero? (count b)) [(count a) (assoc cache [a b] (count a))]\n               :else (let [sub-a (butlast a)\n                           dec-a-cache (cache [sub-a b])\n                           [dec-a temp-cache] (if dec-a-cache [dec-a-cache cache] (dist sub-a b cache))\n                           new-cache (assoc temp-cache [sub-a b] dec-a)\n                           sub-b (butlast b)\n                           dec-b-cache (new-cache [a sub-b])\n                           [dec-b temp-cache] (if dec-b-cache [dec-b-cache new-cache] (dist a sub-b new-cache))\n                           new-cache-2 (assoc temp-cache [a sub-b] dec-b)\n                           dec-ab-cache (new-cache-2 [sub-a sub-b])\n                           [dec-ab temp-cache] (if dec-ab-cache [dec-ab-cache new-cache-2] (dist sub-a sub-b new-cache-2))\n                           last-ab-eq (if (= (last a) (last b)) 0 1)\n                           new-cache-3 (assoc temp-cache [sub-a sub-b] dec-ab)]\n                       [(min (inc dec-a) (inc dec-b) (+ dec-ab last-ab-eq)) new-cache-3])))]\n  #(first (dist % %2 {})))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 101, "code": "(fn l\n  ([a b] (l a b 0 (max (count a) (count b))))\n  ([a b n m]\n    (if (or (<= m n) (= a b)) n\n      (if (empty? a) (+ n (count b))\n        (if (empty? b) (+ n (count a))\n          (#(if (= (first a) (first b))\n              (min (l % %2 n m) (l % b %3 m))\n              (min (l a %2 %3 m) (l % %2 %3 m) (l % b %3 m))) \n            (rest a) (rest b) (inc n)))))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 101, "code": "(fn lev [s t]\n  (let [sLen (count s) tLen (count t)]\n    (cond \n      (empty? s) tLen\n      (empty? t) sLen\n      :else\n        (loop [v (vec (range (inc tLen))) i 0]\n          (letfn [(f [v1 j] \n                    (conj v1 (min (inc (last v1))\n                                  (inc (v (inc j)))\n                                  (+ (v j) (if (= (get s i) (get t j)) 0 1)))))]\n            (if (= i sLen)\n              (last v)\n              (recur (reduce f [(inc i)] (range tLen)) (inc i))))))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 101, "code": "(fn [a b]\n    (let [f (fn [g i j] (cond\n                         (= 0 i) j\n                         (= 0 j) i\n                         :else (min (inc (g g (dec i) j))\n                                    (inc (g g i (dec j)))\n                                    (+ (g g (dec i) (dec j))\n                                       (if (= (nth a (dec i)) (nth b (dec j)))\n                                         0\n                                         1)))))\n          g (memoize f)]\n      (g g (count a) (count b))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 101, "code": "(fn [s t]\n  (let [distance\n        (memoize (fn [f s t]\n                   (if (empty? s) (count t)\n                     (if (empty? t) (count s)\n                       (min (inc (f f s (butlast t)))\n                            (inc (f f t (butlast s)))\n                            (+ (if (= (last s) (last t)) 0 1)\n                               (f f (butlast s) (butlast t))))))))]\n    (distance distance s t)))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 101, "code": "(letfn [(hamming [s1 s2] (apply + (map #(if (= %1 %2) 0 1) s1 s2)))\r\n        (levenshtein [s1 s2]\r\n          (let [[s1 s2] (sort-by count > [s1 s2])\r\n                [l1 l2] (map count [s1 s2])]\r\n            (if (= l1 l2) (hamming s1 s2)\r\n                (->> (for [i (range (inc l2))]\r\n                       (+ 1 (hamming (take i s1)\r\n                                     (take i s2))\r\n                          (levenshtein (drop (inc i) s1)\r\n                                       (drop i s2))))\r\n                     (reduce min)))))]\r\n  levenshtein)", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 101, "code": "(fn levenshtein-distance [s t]\n  (cond (= s t) 0\n        (= 0 (count s)) (count t)\n        (= 0 (count t)) (count s)\n        :otherwise\n        (loop [v0 (vec (take (inc (count t)) (range))) i 0 v1 [0]]\n          (if (= i (count s))\n            (last v1)\n            (let [next-v1  (loop [v1 v1 j 0]\n                             (if (= j (count t))\n                               v1\n                               (let [v1p (update-in v1 [0] (fn [_] (inc i)))\n                                     cost (if (= (get-in s [i]) (get-in t [j])) 0 1)\n                                     v1v (min\n                                           (+ (get-in v1p [j]) 1)\n                                           (+ (get-in v0 [(+ j 1)]) 1)\n                                           (+ (get-in v0 [j]) cost))]\n                                 (recur (update-in v1p [(inc j)] (fn [_] v1v)) (inc j))\n                                 )\n                               )\n                             )]\n              (recur next-v1 (inc i) next-v1)\n              )))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 101, "code": "(fn [s t]\n  (let [lev (fn [lev s t] \n              (cond\n                (empty? s) (count t)\n                (empty? t) (count s)\n                :else (let [cost (if (= (first s)(first t)) 0 1)]\n                        (min (inc (lev lev (rest s) t))\n                             (inc (lev lev s (rest t)))\n                             (+ cost (lev lev (rest s)(rest t)))))))]\n  (lev (memoize lev) s t)))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 101, "code": "(fn levenshtein-distance\n  [a b]\n  (let [x (vec a)\n        y (vec b)]\n    (letfn\n        [(leven-helper [leven-memoize l m]\n           (let [lMinus (dec l)\n                 mMinus (dec m)]\n             (cond (= 0 l) m\n                   (= 0 m) l\n                   (= (x lMinus) (y mMinus)) (leven-memoize leven-memoize lMinus mMinus)\n                   :else (+ 1 (min\n                               (leven-memoize leven-memoize l mMinus)\n                               (leven-memoize leven-memoize lMinus m)\n                               (leven-memoize leven-memoize lMinus mMinus))))))]\n      (leven-helper (memoize leven-helper) (count x) (count y)))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 101, "code": "(let [Lev (memoize (fn [Lev s cs t ct]\n                     (cond (zero? cs) ct\n                           (zero? ct) cs\n                           :else (min (inc (Lev Lev s (dec cs) t ct))\n                                      (inc (Lev Lev s cs       t (dec ct)))\n                                      (+   (Lev Lev s (dec cs) t (dec ct))\n                                           (if (= (nth s (dec cs)) (nth t (dec ct)))\n                                             0 1))))))\n      Lev (partial Lev Lev)]\n  #(Lev %1 (count %1) %2 (count %2)))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 101, "code": "(fn lv\n  [a b]\n  (let [x (vec a)\n        y (vec b)]\n    (letfn\n        [(L [l m]\n           (let [l- (- l 1)\n                 m- (- m 1)]\n             (cond (= 0 l) m\n                   (= 0 m) l\n                   (= (x l-) (y m-)) (L l- m-)\n                   :else (+ 1 (min\n                                   (L l m-)\n                                   (L l- m)\n                                   (L l- m-))))))]\n      (L (count x) (count y)))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 101, "code": "(fn lev\n  ([from to]\n   (lev from to 0 0 (inc (count from)) (inc (count to)) []))\n  ([from to i j icount jcount tab]\n   (letfn [(minval []\n                           (if (and (> i 0) (> j 0) (= (nth from (dec i)) (nth to (dec j))))\n                             (tab (+ (dec j) (* (dec i) jcount)))\n                             (inc (min\n                                   (tab (+ j (* (dec i) jcount)))\n                                   (tab (+ (dec j) (* i jcount)))\n                                   (tab (+ (dec j) (* (dec i) jcount)))))))]\n                   (cond\n                     (> i (dec icount)) (last tab)\n                     (= i j 0) (recur from to 1 0 icount jcount (apply conj tab (range jcount)))\n                     (= j 0) (recur from to i 1 icount jcount (conj tab i))\n                     (= j (dec jcount)) (recur from to (inc i) 0 icount jcount\n                                           (assoc tab (+ j (* i jcount)) (minval)))\n                     :else (recur from to i (inc j) icount jcount\n                                (assoc tab (+ j (* i jcount)) (minval)))\n                     ))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 101, "code": "(fn levenshtein [origin target]\n  (let [origin (concat \"^\" origin)\n        target (concat \"^\" target)\n        variant (fn [origin strategy]\n                  (println \"variant: \" origin strategy)\n                  (if (reduce #(and %1 %2) (map = origin target))\n                    (if (> (count target) (count origin))\n                      (concat origin [(nth target (count origin))])\n                      (butlast origin))\n                  (:result (reduce (fn [{result :result :as r} [origin target]]\n                            (cond\n                             (:done r)\n                             {:done true, :result (conj result origin)}\n                             (or (= origin target) (nil? target))\n                             {:result (conj result origin)}\n                             (= strategy :skip)\n                             {:done true, :result result}\n                             (= strategy :replace)\n                             {:done true, :result (conj result target)}\n                             (= strategy :insert)\n                             {:done true, :result (into result [target origin])}))\n                          {:result []} (map vector origin (concat target (repeat nil)))))))]\n    (loop [names #{origin}, cnt 0]\n      (println names cnt target)\n      (if (or (names (map identity target)) (> cnt 100))\n        cnt\n        (recur (set (mapcat (fn [n] [(variant n :skip) (variant n :insert) (variant n :replace)])\n                            names)),\n               (inc cnt))))))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 101, "code": "; These are helpful:\n; http://people.cs.pitt.edu/~kirk/cs1501/Pruhs/Fall2006/Assignments/editdistance/Levenshtein%20Distance.htm\n; http://www.levenshtein.net/index.html\n; https://web.stanford.edu/class/cs124/lec/med.pdf\n\n(fn [s t]\n  (let [; function to create and initialize 2d matrix\n        matrix (fn [m n f]\n                 (mapv (fn [i] (mapv (fn [j] (f i j)) (range n))) (range m)))\n        ; 1-based string indexing makes everything else here more concise \n        s (into [0] s) n (count s)\n        t (into [0] t) m (count t)\n        d (reduce (fn [d i]\n                    (reduce (fn [d j]\n                              (let [cost (if (= (s i) (t j)) 0 1)]\n                                (assoc-in d [i j] (min (inc ((d (dec i)) j))\n                                                       (inc ((d i) (dec j)))\n                                                       (+ cost ((d (dec i)) (dec j)))))))\n                            d\n                            (range 1 m)))\n                  (matrix n m (fn [i j] (if (zero? j) i (if (zero? i) j 0))))\n                  (range 1 n))]\n    ((d (dec n)) (dec m))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 101, "code": "(fn [x y]\n  (let [u (vec x)\n        v (vec y)\n        M (count u)\n        N (count v)\n        R (fn [P m]\n            (loop [D [m] n 1]\n              (if (< N n)\n                D\n                (let [dm (dec m)\n                      dn (dec n)\n                      c (if (= (u dm) (v dn)) 0 1)\n                      v (min (inc (P n))\n                             (inc (last D))\n                             (+ (P dn) c))]\n                  (recur (conj D v) (inc n))))))]\n    (loop [D (vec (range (inc N))) m 1]\n      (if (< M m) (last D) (recur (R D m) (inc m))))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 101, "code": "(fn levenshtein-dist [a b]\n  (letfn [(l-dist [a b]\n                  (count (filter true? (map not= a b))))\n          (enrich-word [w ss nl]\n                       (let [subst (zipmap ss w)]\n                         (map #(get subst % :none) \n                              (range nl))))\n          (count-bits [n]\n                      (loop [n n\n                             c 0]\n                        (if (zero? n) c\n                          (recur (bit-shift-right n 1) \n                                 (if (bit-test n 0) (inc c) c)))))\n          (enrich-words [w nl]\n                        (letfn [(subsetv [s bits]\n                                         (remove nil?\n                                                 (map-indexed #(if (bit-test bits %) %2) s)))\n                                (power-set-k [v k]\n                                             (let [nn (bit-shift-left 1 (count v))]\n                                               (for [n (range nn) :when (= k (count-bits n))] (subsetv v n))))]\n                          (map #(enrich-word w % nl) (power-set-k (range nl) (count w)))))]\n    (let [ca (count a)\n          cb (count b)]\n      (cond\n       (= ca cb) (l-dist a b)\n       (> ca cb) (apply min (map #(l-dist a %) (enrich-words b ca)))\n       :else (levenshtein-dist b a)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 101, "code": ";;http://people.cs.pitt.edu/~kirk/cs1501/Pruhs/Fall2006/Assignments/editdistance/Levenshtein%20Distance.htm\n(fn levenshtein\n  [a b]\n  (let [n (count a) m (count b) cell (fn [m i j] (nth (nth m i) j))]\n    (if (some zero? (list n m))\n      (max n m)\n      (loop [matrix (into\n                     [(into [] (range 0 (inc n)))]\n                     (for [j (range 1 (inc m))]\n                       (into [j] (repeat n 0))))\n             indeces (for [j (range 1 (inc n))\n                           i (range 1 (inc m))]\n                       (list i j))]\n        (if (seq indeces) \n          (let [i (ffirst indeces)\n                j (second (first indeces))\n                new-cell (min\n                          (inc (cell matrix (dec i) j))\n                          (inc (cell matrix i (dec j)))\n                          (+ (cell matrix (dec i) (dec j))\n                             (if (= (nth a (dec j)) (nth b (dec i))) 0 1)))\n                matrix' (assoc matrix i (assoc (nth matrix i) j new-cell))]\n            (recur matrix' (rest indeces)))\n          (last (last matrix)))))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 101, "code": "(fn prob101\n  [a b]\n  (let [levenshtein (fn [fnc str1 str2]\n                     (let [len1 (count str1)\n                           len2 (count str2)]\n                       (cond (zero? len1) len2\n                             (zero? len2) len1\n                             :else\n                             (let [cost (if (= (first str1) (first str2)) 0 1)]\n                               (min (inc (fnc fnc (rest str1) str2))\n                                    (inc (fnc fnc  str1 (rest str2)))\n                                    (+ cost\n                                       (fnc fnc (rest str1) (rest str2))))))))]\n    (levenshtein (memoize levenshtein) a b)))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 101, "code": "(fn levenshtein\n  ([s1 s2] (levenshtein s1 s2 (make-array Integer (inc (count s1)) (inc (count s2)))))\n  ([s1 s2 cache]\n   (if (or (empty? s1) (empty? s2))\n     (Math/abs (- (count s1) (count s2)))\n     (or (aget cache (count s1) (count s2))\n         (let [result (min (inc (levenshtein (rest s1) s2 cache))\n                           (inc (levenshtein s1 (rest s2) cache))\n                           (+ (levenshtein (rest s1) (rest s2) cache) (if (= (first s1) (first s2)) 0 1)))]\n           (aset cache(count s1) (count s2) (int result))\n           result)))))", "user": "524ea587e4b0541d1855b7e9"}, {"problem": 101, "code": "(fn [s t]\n  (cond\n    (= s t) 0\n    (empty? s) (count t)\n    (empty? t) (count s)\n    :else\n    ((reduce\n       (fn [v0 i]\n         (reduce \n           (fn [v1 j]\n             (conj v1 (min (inc (v1 j))\n                           (inc (v0 (inc j)))\n                           (+ (v0 j) (if (= (nth s i) (nth t j)) 0 1)))))\n           [(inc (first v0))]\n           (range (count t))))\n       (vec (range (inc (count t))))\n       (range (count s)))\n     (count t))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 101, "code": "(fn [a b]\n\t(let [length (+ (count b) 1)\n          dict (atom {})\n          lev (fn lev [n]\n                (if (contains? @dict n)\n                  (@dict n)\n                  (let [ret\n                (let [i (quot n length)\n                      j (rem n length)]\n                     (if (= 0 (min i j)) (max i j) \n                       (min (+ (lev (+ (* (- i 1) length) j)) 1) \n                            (+ (lev (+ (* i length) (- j 1))) 1) \n                            (+ (lev (+ (* (- i 1) length) (- j 1))) \n                               (if (= (nth a (- i 1)) (nth b (- j 1))) 0 1)))))]\n                  (swap! dict assoc n ret)\n                  ret)\n                  ))]\n\n    (lev (+ (* (count a) length) (count b)))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 101, "code": "(fn [coll1 coll2]\n  (let [[small big] (sort-by count [coll1 coll2])]\n    (letfn [(permutations [taken avail left]\n                          (if (zero? left) [taken]\n                            (if (empty? avail) []\n                              (concat\n                               (permutations (conj taken (first avail)) (rest avail) (dec left))\n                               (permutations taken (rest avail) left)))))\n            (small-diff [xs]\n                        (apply +\n                               (map #(if (= %1 %2) 0 1)\n                                    xs small)))]\n      (->> (permutations [] big (count small))\n           (map small-diff)\n           (apply min)\n           (+ (count big) (- (count small)))))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 101, "code": "(fn levenshtein [[x1 & xrest :as X] [y1 & yrest :as Y]]\n\t\t\t\t(cond \n\t\t\t\t\t(empty? X) (count Y)\n\t\t\t\t\t(empty? Y) (count X)\n\t\t\t\t\t(= x1 y1) (levenshtein xrest yrest)\n\t\t\t\t\t:else (+ 1 \n\t\t\t\t\t\t\t (min (levenshtein X yrest)\n\t\t\t\t\t\t\t\t  (levenshtein xrest Y)\n\t\t\t\t\t\t\t\t  (levenshtein xrest yrest)))))", "user": "564d02cde4b0284900eef679"}, {"problem": 101, "code": "(let [cache (atom {})]\n  (fn ldist [a b]\n\t(when-not (@cache [a b])\n      (swap! cache assoc [a b]\n             (cond\n              (empty? a) (count b)\n              (empty? b) (count a)\n              :else (min (inc (ldist (butlast a) b))\n                         (inc (ldist a (butlast b)))\n                         (+ (ldist (butlast b) (butlast a))\n                            (if (= (last a) (last b)) 0 1))))))\n    (@cache [a b])))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 101, "code": "(let [cache (atom {})]\n  (fn ldist [a b]\n\t(when-not (@cache [a b])\n      (swap! cache assoc [a b]\n             (cond\n              (empty? a) (count b)\n              (empty? b) (count a)\n              :else (min (inc (ldist (butlast a) b))\n                         (inc (ldist a (butlast b)))\n                         (+ (ldist (butlast b) (butlast a))\n                            (if (= (last a) (last b)) 0 1))))))\n    (@cache [a b])))", "user": "530e37d3e4b08068f379ecb5"}, {"problem": 101, "code": "(fn levenshtein-distance\n  [s t]\n  (letfn [(next-row [s t prev-row row-num]\n            (reduce (fn [result col-num]\n                      (conj result\n                            (min (inc (last result))\n                                 (inc (prev-row col-num))\n                                 (+ (prev-row (dec col-num))\n                                    (if (= (get s (dec row-num))\n                                           (get t (dec col-num)))\n                                      0\n                                      1)))))\n                    [row-num] (range 1 (inc (count t)))))]\n    (let [last-row (reduce (partial next-row s t)\n                           (vec (range 0 (inc (count t))))\n                           (range 1 (inc (count s))))]\n      (last last-row))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 101, "code": "(fn [arg1 arg2]\n(cond\n(and (= arg1 \"kitten\") (= arg2 \"sitting\")) 3\n(and (= arg1 \"closure\") (= arg2 \"clojure\")) 1\n(and (= arg1 \"clojure\") (= arg2 \"closure\")) 1\n(and (= arg1 \"xyx\") (= arg2 \"xyyyx\")) 2\n(and (= arg1 \"\") (= arg2 \"123456\")) 6\n(and (= arg1 \"Clojure\") (= arg2 \"Clojure\")) 0\n(and (= arg1 \"\") (= arg2 \"\")) 0\n(and (= arg1 []) (= arg2 [])) 0\n(and (= arg1 [1 2 3 4]) (= arg2 [0 2 3 4 5])) 2\n(and (= arg1 '(:a :b :c :d)) (= arg2 '(:a :d))) 2\n(and (= arg1 \"ttttattttctg\") (= arg2 \"tcaaccctaccat\")) 10\n(and (= arg1 \"gaattctaatctc\") (= arg2 \"caaacaaaaaattt\")) 9\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 101, "code": "(fn [seq1 seq2]\n  (let [seq1-count (count seq1)\n        seq2-count (count seq2)]\n    (cond\n      (= seq1 seq2) 0\n      (empty? seq1) seq2-count\n      (empty? seq2) seq1-count\n      :else (let [seq2-count-inc (inc seq2-count)\n                  v0 (vec (range seq2-count-inc))\n                  v1 (vec (repeat seq2-count-inc 0))]\n              (->> (reduce\n                     (fn [[v0 v1] i]\n                       (let [v1 (reduce\n                                  (fn [v1 j]\n                                    (let [cost (if (= (nth seq1 i) (nth seq2 j)) 0 1)]\n                                      (assoc v1\n                                             (inc j)\n                                             (min\n                                               (inc (v1 j))\n                                               (inc (v0 (inc j)))\n                                               (+ (v0 j) cost)))))\n                                  (assoc v1 0 (inc i))\n                                  (range seq2-count))]\n                         [v1 v1]))\n                     [v0 v1]\n                     (range (count seq1)))\n                   second\n                   last)))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 101, "code": "(fn [c1 c2]\n  (let [n (inc (count c1)) m (inc (count c2))\n        a (transient (vec (repeat n (vec (repeat m 0)))))]\n    (dotimes [i n] (assoc! a i (assoc (get a i) 0 i)))\n    (assoc! a 0 (vec (range m)))\n    (dotimes [i n]\n      (dotimes [j m]\n        (when (and (pos? i) (pos? j))\n          (assoc! a i (assoc (get a i) j\n                             (if (= (get c1 (dec i)) (get c2 (dec j)))\n                               (get-in a [(dec i) (dec j)])\n                               (inc (min (get-in a [(dec i) j])\n                                         (get-in a [i (dec j)])\n                                         (get-in a [(dec i) (dec j)])))))))))\n    (get-in a [(dec n) (dec m)])))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 101, "code": "(fn [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char? 0 1))))]\n    (loop [row-idx 1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2 (nth w2 (dec row-idx))\n              next-prev-row (reduce (fn [cur-row i]\n                                      (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                        (conj cur-row (cell-value same-char?\n                                                                  prev-row\n                                                                  cur-row\n                                                                  i))))\n                                    [row-idx] (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows next-prev-row))))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 101, "code": "#(let\n  [len-x (count %1)\n   len-y (count %2)\n   ij (atom (vec (repeat len-x (vec (repeat len-y nil)))))\n   get-ij (fn [i j] (get-in @ij [i j]))\n   set-ij (fn [i j v] (do (swap! ij assoc-in [i j] v) v))\n   lev (fn lev [x x-i y y-j]\n         (if-let [v (get-ij x-i y-j)]\n           v\n           (cond\n             (zero? x-i) (set-ij x-i y-j y-j)\n             (zero? y-j) (set-ij x-i y-j x-i)\n             :else\n             (set-ij x-i y-j\n                     (min\n                       (inc (lev x (dec x-i) y y-j))\n                       (inc (lev x x-i y (dec y-j)))\n                       (+ (lev x (dec x-i) y (dec y-j))\n                          (if (= (nth x (dec x-i)) (nth y (dec y-j))) 0 1)))))))]\n  (lev %1 len-x %2 len-y))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 101, "code": "(fn lev [s1 s2] \n  (cond \n   (empty? s1) (count s2) \n   (empty? s2) (count s1) \n   (= s1 s2) 0\n   :else (let [[i & ii] s1 [j & jj] s2]\n           (if (= i j)\n             (lev ii jj)\n             (inc (min (lev s1 jj)\n                       (lev ii s2)\n                       (lev ii jj)))))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 101, "code": "(fn [s t]\n  (cond\n    (= s t) 0\n    (empty? s) (count t)\n    (empty? t) (count s)\n    :else (last (reduce\n                 (fn [v0 i]\n                   (reduce\n                    (fn [v1 j]\n                      (conj v1 (min (inc (nth v1 j))\n                                    (inc (nth v0 (inc j)))\n                                    (+ (if (= (nth s i) (nth t j)) 0 1)\n                                       (nth v0 j)))))\n                    [(inc i)] (-> t count range)))\n                 (-> t count inc range) (-> s count range)))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 101, "code": "(fn [s1 s2]\n  (letfn\n   [(cost [nop? c11 c01 c10]\n      (if nop?\n          c11\n          (inc (min c11 c01 c10))))\n    (nextrow [nops c1pairs row0]\n    \t (if-not nops row0\n\t    \t  (let\n\t    \t    [[c11 c10] (first c1pairs)\n\t    \t      c01      (last row0)\n\t    \t      c00 (cost (first nops)\n\t\t                    c11 c01 c10)]\n           (recur (next nops)\n                  (next c1pairs)\n                  (conj row0 c00)))))\n    (exttbl [s2 rows el1]\n      (let\n        [nops (map = s2 (repeat el1))\n         c1pairs (partition\n\t                  2 1 (last rows))\n\t        row0 [(count rows)]]\n\t       (conj rows (nextrow nops\n\t                           c1pairs\n\t\t                          row0))))]\n    (->\n      (reduce\n        (partial exttbl s2)\n        (-> s2 count inc\n               range vec vector)\n        s1)\n      last last)))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 101, "code": "(fn lev_dist [s1 s2]\n  (cond\n   (zero? (count s1)) (count s2)\n   (zero? (count s2)) (count s1)\n   (= (first s1) (first s2)) (lev_dist (rest s1) (rest s2))\n   :else (inc (min (lev_dist (rest s1) s2)\n                   (lev_dist s1 (rest s2))\n                   (lev_dist (rest s1) (rest s2))))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 101, "code": "(fn levenshtein [str1 str2]\n               (cond (empty? str1) (count str2)\n                     (empty? str2) (count str1)\n                     (= (first str1) (first str2)) (levenshtein (rest str1) (rest str2))\n                     :else\n                       (inc (min (levenshtein (rest str1) str2)\n                            (levenshtein str1 (rest str2))\n                            (levenshtein (rest str1) (rest str2))))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 101, "code": "(fn f [a b]                    \n  (cond (empty? a) (count b)\n        (empty? b) (count a)\n        (= (first a) (first b)) (recur (rest a) (rest b))\n        :else (inc (min (f (rest a) b) \n                        (f a (rest b)) \n                        (f (rest a) (rest b))))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 101, "code": "(fn [s t]\n  (let [smax (inc (count s)) \n        tmax (inc (count t) )\n        d (to-array-2d (repeat smax (repeat tmax nil)))]\n    (doseq [i (range 0 smax) j (range 0 tmax)]\n      (cond (= i 0) (aset d i j j)\n            (= j 0) (aset d i j i)\n            :default (let [v1 (inc (aget d (dec i) j))\n                           v2 (inc (aget d i (dec j)))\n                           v3 (+ (aget d (dec i) (dec j)) \n                                 (if (= (nth s (dec i)) (nth t (dec j))) 0 1))]\n                       (aset d i j (min v1 v2 v3)))))\n    (aget d (dec smax) (dec tmax))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 101, "code": "(fn lev [w1 w2]\n  (letfn [(next-row [previous_row xword ychar yindex]\n            (reduce\n              (fn [current_row [current_char sy-1 sy]]\n                (do (println \"\\t->\" current_row \" : \" current_char \" : \" sy-1 \" : \" sy )\n                    (conj current_row\n                          (min\n                            (+ sy-1 (if (= current_char ychar) 0 1))\n                            (inc sy)\n                            (inc (last current_row))))))\n              [yindex]\n              (map vector xword previous_row (rest previous_row))     ; create a tuple containing the current character, the score on the previous row\n              ))]\n  (let [switch (< (count w1) (count w2))\n        xword (if switch w1 w2)\n        yword (if switch w2 w1)]\n    (last (reduce\n            #(do\n              (println %1 \" : \" %2)\n              (next-row %1 xword (%2 0) (%2 1)))\n            (range (inc (count yword)))\n            (map vector yword (range 1 (inc (count yword))))\n            )))))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 101, "code": "(fn [a b]\n    (letfn [(step [calculated-result coordinate]\n                  (let [x (first coordinate)\n                        y (last coordinate)]\n                    (assoc calculated-result\n                      coordinate\n                      (if (zero? (min x y))\n                        (max x y)\n                        (min\n                         (inc (calculated-result [(dec x) y]))\n                         (inc (calculated-result [x (dec y)]))\n                         (+\n                          (calculated-result [(dec x) (dec y)])\n                          (if (= ((vec a) (dec x)) ((vec b) (dec y))) 0 1)))))))]\n      ((reduce step {}\n               (apply concat (map #(map (fn [i] [% i]) (range 0 (inc (count b)))) (range 0 (inc (count a)))))) [(count a) (count b)])))", "user": "4f42ae16e4b0d7d3c9f3fd09"}, {"problem": 101, "code": "(fn __ [str-1 str-2]\n    (let [l-1 (count str-1)\n           l-2 (count str-2)\n           dynamic-row (range (inc l-1))\n           delta (fn [ch] (map #(if (= ch %) 0 1) str-1)); compare str-1[i] to str-2[i2]\n           next-row (fn [row i2]\n                      (let [tmp (cons (inc i2)\n                                      (map min (map + (delta (nth str-2 i2)) row)\n                                           (map inc (rest row))))]\n                            (reductions #(min (inc %1) %2) (first tmp) (rest tmp))))\n           final-row (reductions  next-row dynamic-row (range l-2))]\n          (last (last final-row))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 101, "code": "(let [ld (memoize\n           (fn [ld s t]\n             (cond \n               (= 0 (count s)) (count t)\n               (= 0 (count t)) (count s)\n               :e\n               (min (inc (ld ld s (rest t)))\n                    (inc (ld ld (rest s) t))\n                    (+ (if (= (first s) (first t)) 0 1) (ld ld (rest s) (rest t)))))))\n      ld (partial ld ld)]\n  ld)", "user": "554680cbe4b0a04f7929953e"}, {"problem": 101, "code": "(fn [s t]\n  (let [cs (count s)\n        ct (count t)\n        row (fn [r v0 cost]\n              (if-let [nv0 (next v0)]\n                (recur\n                  (conj r (min (inc (last r)) (inc (first nv0)) (+ (first v0) (first cost))))\n                  (rest v0)\n                  (rest cost))\n                r))\n        lev* (fn [v0 i]\n               (if (= cs i)\n                 (last v0)\n                 (recur\n                   (row [(inc i)] v0 (map #(if (= (nth s i) %) 0 1) t))\n                   (inc i))))]\n    (cond\n      (= s t) 0\n      (zero? cs) ct\n      (zero? ct) cs\n      :else (lev* (range (inc ct)) 0))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 101, "code": ";; FROM https://gist.github.com/jamesoly/1183485\n(fn lev [s t]\n    (cond\n      (empty? s) (count t)\n      (empty? t) (count s)\n      :else\n        (let [ns (rest s)\n              nt (rest t)]\n          (if (= (first s) (first t))\n            (lev ns nt) ; \u7f6e\u63db(\u6587\u5b57\u540c\u3058\u3067\u30b3\u30b9\u30c8\u8ffd\u52a0\u7121\u3057)\n            (min\n              (inc (lev s nt))       ; \u524a\u9664\n              (inc (lev ns t))       ; \u8ffd\u52a0\n              (inc (lev ns nt))))))) ; \u7f6e\u63db", "user": "511b9017e4b00c2a1fa7ff6b"}, {"problem": 101, "code": "(fn levenshtein [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char?\n                                                   0\n                                                   1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2           (nth w2 (dec row-idx))\n              next-prev-row (reduce (fn [cur-row i]\n                                      (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                        (conj cur-row (cell-value same-char?\n                                                                  prev-row\n                                                                  cur-row\n                                                                  i))))\n                                    [row-idx] (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows next-prev-row))))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 101, "code": "(fn levenshtein [s1 s2]\n  (letfn [\n           (generate-key [s1 s2]\n                         [(apply str s1) (apply str s2)])\n           (lev [[h1 & t1 :as s1] [h2 & t2 :as s2] memory]\n                (let [memory-key (generate-key s1 s2)]\n                  (if (contains? memory memory-key)\n                    memory\n                    (let [\n                           l1 (count s1)\n                           l2 (count s2)\n                           ]\n\n                      (if (= 0 (min l1 l2))\n                        (assoc memory memory-key (max l1 l2))\n                        (let [\n                               temp-memory (lev t1 s2 (lev s1 t2 (lev t1 t2 memory)))\n                               ]\n                          (assoc\n                            temp-memory\n                            memory-key\n                            (min\n                              (inc (temp-memory (generate-key t1 s2)))\n                              (inc (temp-memory (generate-key s1 t2)))\n                              (+ (if (= h1 h2) 0 1) (temp-memory (generate-key t1 t2)))))))))))]\n  ((lev s1 s2 {}) (generate-key s1 s2))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 101, "code": "#(let [m (memoize (fn [f a b] \n  (cond (empty? a) (count b) (empty? b) (count a)\n    :else (let [d (if (= (first a) (first b)) 0 1)\n    x (rest a) y (rest b)]\n     (min (inc (f f a y)) (inc (f f x b)) (+ d (f f x y)))))))]\n   (m m % %2))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 101, "code": "(memoize \n  (fn ml [p q]\n    (let [lp (count p) lq (count q)]\n    (if (or (= 0 lp) (= 0 lq))\n      (max lp lq)\n      (let [rp (rest p) rq (rest q)]\n        (if (= (first p) (first q))\n          (ml rp rq)\n          (inc (min (ml rp q) (ml p rq) (ml rp rq)))))))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 101, "code": "(fn [a b]\n  (loop [z [a b 0]\n         r (clojure.lang.PersistentQueue/EMPTY)]\n    (let [[[x & xs :as xw] [y & ys :as yw] c] (or z (peek r))\n          cc (inc c)\n          rr (if z r (pop r))]\n        (cond\n          (= xw yw) c\n          (= x y) (recur [xs ys c] rr)\n          (nil? x) (recur nil (conj rr [xw ys cc]))\n          (nil? y) (recur nil (conj rr [xs yw cc]))\n          :else (recur nil (into rr [[xs ys cc] [xs yw cc] [xw ys cc]]))))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 101, "code": "(fn levenshtein-distance [a b]\n  (letfn [(step [calculated-result coordinate]\n            (let [x (first coordinate)\n                  y (last coordinate)]\n              (assoc calculated-result\n                coordinate\n                (if (zero? (min x y))\n                  (max x y)\n                  (min\n                    (inc (calculated-result [(dec x) y]))\n                    (inc (calculated-result [x (dec y)]))\n                    (+\n                      (calculated-result [(dec x) (dec y)])\n                      (if (= ((vec a) (dec x)) ((vec b) (dec y))) 0 1)))))))]\n    ((reduce step {} (apply concat (map #(map (fn [i] [% i]) (range 0 (inc (count b)))) (range 0 (inc (count a)))))) [(count a) (count b)])))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 101, "code": "(memoize \n    (fn f [x y]\n      (let [cost (if (= (first x) (first y)) 0 1)]\n        (cond\n          (zero? (count x)) (count y)\n          (zero? (count y)) (count x)\n          (= (first x) (first y)) (f (rest x) (rest y))\n          :else\n          (min\n            (+ 1 (f (rest x) y))\n            (+ 1 (f x (rest y)))\n            (+ cost (f (rest x) (rest y))))))))", "user": "519136e9e4b0f8ef0be96c01"}, {"problem": 101, "code": "(fn ld [s t]\n  (let [m (inc (count s)) n (inc (count t)) d (make-array Long/TYPE m n)]\n    (doseq [i (range 1 m)]\n      (aset d i 0 i))\n    (doseq [j (range 1 n)]\n      (aset d 0 j j))\n    (doseq [j (range 1 n) i (range 1 m)]\n      (let [sub-cost (if (= (get s (dec i)) (get t (dec j))) 0 1)]\n        (aset d i j (min (inc (aget d (dec i) j))\n                         (inc (aget d i (dec j)))\n                         (+ sub-cost (aget d (dec i) (dec j)))))))\n    (aget d (dec m) (dec n))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 101, "code": "(fn  [s1 s2]\n  (let [v1 (vec s1) v2 (vec s2)\n        row0 (vec (range (inc (count v1))))\n        next-row (fn [v]\n                      (vec (reduce (fn [u i]\n                                        (let [j  (first v)\n                                              a (inc (peek u)) \n                                              b (inc (v (inc i)))\n                                              c (+ (v  i) (if (= (v1 i) (v2 j)) 0 1 ))]\n                                          ;(println j a b c)\n                                          (conj u (min a b c))))\n                                   \n                                   [(inc (first v))] (range (count v1)))))\n        table  (iterate next-row row0)]\n    (last (nth table  (count v2)))))", "user": "5649615be4b0284900eef641"}, {"problem": 101, "code": "#(if (= % %2)\n   0\n   (case %\n     \"kitten\" 3\n     (\"clojure\" \"closure\") 1\n     \"\" (count %2)\n     \"ttttattttctg\" 10\n     \"gaattctaatctc\" 9\n     2))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 101, "code": "(fn levehnsteinX[a b]\n\t(letfn [\n\t\t(costAdd[cost a b]\n\t\t\t(if (= a b)\n\t\t\t\tcost\n\t\t\t\t(inc cost)\n\t\t\t)\n\t\t)\n\t\t(levRec[a b mem]\n\t\t\t(let [existing (get mem [a b])]\n\t\t\t\t(if (not (nil? existing))\n\t\t\t\t\t{ :val existing :mem mem} \n\t\t\t\t\t(let [res \n\t\t\t\t\t\t(cond \n\t\t\t\t\t\t\t(empty? a) {:val (count b) :mem mem}\n\t\t\t\t\t\t\t(empty? b) {:val (count a) :mem mem}\n\t\t\t\t\t\t\t:else (let [ \n\t\t\t\t\t\t\t\t\tres1 (levRec (rest a) b mem)\n\t\t\t\t\t\t\t\t\tres2 (levRec  a (rest b) (get res1 :mem))\n\t\t\t\t\t\t\t\t\tres3 (levRec  (rest a) (rest b) (get res2 :mem))\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t:val (min \n\t\t\t\t\t\t\t\t\t\t(inc (get res1 :val))\n\t\t\t\t\t\t\t\t\t\t(inc (get res2 :val))\n\t\t\t\t\t\t\t\t\t\t(costAdd (get res3 :val) (first a) (first b))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t:mem (get res3 :mem)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t]\n\t\t\t\t\t\t{ :val (get res :val) :mem (assoc (get res :mem) [a b] (get res :val))}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t]\n\t\t(get (levRec (reverse a) (reverse b) {}):val)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 101, "code": "(fn [w1 w2]\n (let [a (range (+ 1 (count w1))) c (range 1 (inc (count w2))) d (vec (for [i w2] (vec (for [j w1] (if (= i j) 0 1)))))]\n  (last (reduce (fn [cur [i s]] (->> (map min (map inc (rest cur)) (map + (butlast cur) s)) (reductions (fn [x y] (min (inc x) y)) i))) a (map vector c d)))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 101, "code": "(fn l[a b]\n   (letfn [(nnth [m i j] (nth (nth m i) j))]\n      (last (last (reduce (fn [r i] (conj r\n        (reduce (fn [l j]\n          (conj l (if (or (zero? i) (zero? j)) (max i j)\n              (min  (inc (nnth r (dec i) j)) (inc (nth l (dec j))) (+ (nnth r (dec i) (dec j)) (if (= (nth a (dec j)) (nth b (dec i))) 0 1)))\n          )))\n          [] (range (inc (count a))))))\n        [] (range (inc (count b)))\n      )))\n   )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 101, "code": "(fn lev [a b]\n  (if (> (count b) (count a))\n    (lev b a)\n    (let [cost (fn [aa] (for [bb b] (if (= aa bb) 0 1)))]\n      (loop [aa (map-indexed #(vector % %2) a)  v (range 0 (inc (count a)))]\n        (if (empty? aa)\n          (last v)\n          (recur (rest aa) (reduce (fn [v1,e] (conj v1 (min (inc (last v1)) e)))\n                                 [(inc (first (first aa)))]\n                                 (map min (map inc (rest v)) (map + v (cost (second (first aa)))))))\n          )\n        )\n      )\n    )\n  )", "user": "56f15eade4b04a395b9a048e"}, {"problem": 101, "code": "(fn solve [s t]\n  ((fn rec [i j]\n    (cond\n     (>= i (count s)) (- (count t) j)\n     (>= j (count t)) (- (count s) i)\n     (= (nth s i) (nth t j)) (rec (inc i) (inc j))\n     :else (let [a1 (inc (rec (inc i) j))\n                 a2 (inc (rec i (inc j)))\n                 a3 (inc (rec (inc i) (inc j)))]\n             (min a1 a2 a3))))\n  0 0))", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 101, "code": "(fn ld [s1 s2]\n   (cond\n     (= (count s1) 0) (count s2)\n     (= (count s2) 0) (count s1)\n     (= (first s1) (first s2)) (ld (rest s1) (rest s2))\n     :else (min\n             (+ 1 (ld (rest s1) (rest s2)))\n             (+ 1 (ld (rest s1) s2))\n             (+ 1 (ld (rest s2) s1)))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 101, "code": "(fn mylevenshtein [s1 s2]\n  (cond\n    (empty? s1) (count s2) \n    (empty? s2) (count s1)\n    (= s1 s2) 0\n   :else\n    (if (= (first s1) (first s2)) \n      (mylevenshtein (rest s1) (rest s2)) ;;if equal no need to change\n      (+ 1 (min (mylevenshtein s1 (rest s2)) ;; add character\n                (mylevenshtein (rest s1) s2) ;; remove character\n                (mylevenshtein (rest s1) (rest s2))))))) ;;change character", "user": "5703d21ae4b08d47c97781ff"}, {"problem": 101, "code": "(fn mylevenshtein [x y]\n  (cond\n    (empty? x) (count y) \n    (empty? y) (count x)\n    (= x y) 0\n    :else\n    (if (= (first x) (first y)) \n      (mylevenshtein (rest x) (rest y)) ;;if equal no need to change\n      (+ 1 (min (mylevenshtein x (rest y)) ;; add character\n                (mylevenshtein (rest x) y) ;; remove character\n                (mylevenshtein (rest x) (rest y))))))) ;;change character", "user": "5576d3c7e4b05c286339e074"}, {"problem": 101, "code": "(fn leven [w1 w2]\n  (letfn [(count-diff [w1 w2]\n            (let [[sm lg] (sort (map count [w1 w2]))]\n              (- lg sm)))\n          (max-leven [w1 w2]\n            (+ (apply + (map #(if (= %1 %2) 0 1) w1 w2))\n               (count-diff w1 w2)))]\n    (let [bound (max-leven w1 w2)]\n      (letfn [(leven' [diffs w1 w2]\n                (let [[wc1 & wr1] w1\n                      [wc2 & wr2] w2]\n                  #_(println bound diffs w1 w2)\n                  (cond\n                    (= diffs bound) diffs\n                    (and wc1 wc2) (if (= wc1 wc2)\n                                    (leven' diffs wr1 wr2)\n                                    (min\n                                     ;; insert wc2 to w1\n                                     (leven' (inc diffs) (cons wc2 wr1) w2)\n                                     ;; insert wc1 to w2\n                                     (leven' (inc diffs) w1 (cons wc1 wr2))\n                                     ;; delete w1\n                                     (leven' (inc diffs) wr1 w2)\n                                     ;; delete w2\n                                     (leven' (inc diffs) w1 wr2)\n                                     ;; replace\n                                     (leven' (inc diffs) wr1 wr2)))\n                    (and (not wc1) (not wc2))   diffs\n                    wc2                         (+ diffs (- (count w2) (count w1)))\n                    wc1                         (+ diffs (- (count w1) (count w2)))\n                    )))]\n        (leven' 0 w1 w2)))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 101, "code": "(fn lev [[h & t :as a] [f & r :as b]]\n  (cond (nil? h) (count b)\n        (nil? f) (count a)\n        (= f h)  (recur t r)\n        :else (min (inc (lev t r))\n                   (inc (lev a r))\n                   (inc (lev t b)))\n        ))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 101, "code": "(fn [xs ys]\n   ((fn calc-next [xs ys rs]\n      (let [y (first ys)]\n        (if (nil? y)\n          (last rs)\n          (calc-next xs (rest ys)\n                     ;; loop to get next rs\n                     (loop [xs xs\n                            rs rs\n                            nrs [(inc (first rs))]]\n                       (if (empty? xs) nrs\n                           (recur (rest xs)\n                                  (rest rs)\n                                  (conj nrs (min (inc (last nrs))\n                                                 (inc (second rs))\n                                                 (+ (first rs)\n                                                    (if (= (first xs) y) 0 1)))))\n                           )\n                       ))\n          )\n\n        )\n      ) xs ys (range (inc (count xs)))))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 101, "code": "(fn [s t] (let [m (inc (count s)), n (inc (count t))]\n (loop [j 1, y (range m)]\n   (if (= j n) (last y)\n   (recur (inc j)\n   (loop [i 1, x [j], y y]\n     (if (= i m) (reverse x)\n     (recur (inc i)\n     (cons (if (= (nth s (dec i)) (nth t (dec j)))\n       (first y)\n       (inc (min (first y) (second y) (first x)))) x)\n     (rest y)))))))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 101, "code": "(fn [s t]\n  (cond \n   (= s t) 0\n   (= 0 (count s)) (count t)\n   (= 0 (count t)) (count s)\n   :else (letfn [(outer-reduce [arr s-char]\n                               (letfn [(inner-reduce [[v0 v1] t-char]\n                                                     (let [cost (if (= s-char t-char) 0 1)]\n                                                       (list (rest v0)\n                                                             (concat v1\n                                                                     (list (min (+ (last v1) 1)\n                                                                                (+ (first (rest v0)) 1)\n                                                                                (+ (first v0) cost)))))))]\n                                 (last (reduce inner-reduce\n                                               (list arr (list (+ (first arr) 1)))\n                                               (sequence t)))))]\n           (last (reduce outer-reduce\n                         (range (+ (count t) 1))\n                         (sequence s))))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 101, "code": "(fn [s1 s2]\n  (let [m (count s1)\n        n (count s2)\n        d (transient\n           (merge (apply conj {}\n                         (for [x (range (inc m)) y (range (inc n))]\n                           [[x y] (if (zero? (* x y)) (max x y) 0)]))))]\n    (dotimes [i m]\n      (dotimes [j n]\n        (assoc! d\n                [(inc i) (inc j)]\n                (min (+ 1 (d [i       (inc j)]))\n                     (+ 1 (d [(inc i) j]))\n                     (+ (if (= (get s1 i) (get s2 j)) 0 1)\n                        (d [i j]))))))\n        (d [m n])))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 101, "code": "(fn [a b]\n    (cond (empty? a) (count b)\n          (empty? b) (count a)\n          :else           \n          (let [costs (make-array Long (inc (count a)) (inc (count b)))]\n\n            (doseq [i (range (inc (count a)))]\n              (aset costs i 0 i))\n            (doseq [j (range (inc (count b)))]\n              (aset costs 0 j j))\n            (doseq [i (map inc (range (count a)))\n                    j (map inc (range (count b)))]\n              (let [cost (if (= (nth a (dec i)) (nth b (dec j))) 0 1)]\n                (aset costs i j \n                      (min (+ cost (aget costs (dec i) (dec j)))\n                           (inc (aget costs i (dec j)))\n                           (inc (aget costs (dec i) j))))))\n            (aget costs (count a) (count b)))))", "user": "4f463dfde4b0d56e7bb92b99"}, {"problem": 101, "code": "(fn [x y]\n    (->\n     (reduce (fn [[j p] c]\n               [(inc j)\n                (second\n                 (reduce (fn [[i r] d]\n                           (let [pi (dec i)]\n                             [(inc i)\n                              (conj r (if (= d c)\n                                        (get p pi)\n                                        (inc (min (get r pi) (get p i) (get p pi)))))]))\n                         [1 [j]] x))])\n             [1 (vec (-> x count inc range))] y)\n     last last))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 101, "code": "(fn levenshtein-distance [w1 w2]\n  (let [f (fn [acc [i j]]\n            (conj acc \n                  [[i j] \n                   (if (zero? (min i j)) \n                     (max i j)\n                     (min (inc (acc [(dec i) j]))\n                          (inc (acc [i (dec j)]))\n                          (+ (acc [(dec i) (dec j)])\n                             (if (= (nth w1 (dec i))\n                                    (nth w2 (dec j))) 0 1))))]))]\n    (get (reduce f\n                 {}\n                 (for [x (range (inc (count w1)))\n                       y (range (inc (count w2)))]\n                   [x y]))\n         [(count w1) (count w2)])))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 101, "code": "(fn [s t]\n  (let [m (count s)\n        n (count t)\n        d (atom (apply vector (vec (range (inc n)))\n                       (map #(into [%] (repeat n nil)) (range 1 (inc m)))))\n        cost (fn [i j] (if (= (get s (dec i)) (get t (dec j))) 0 1))\n        lev (fn lev [i j d]\n              (if-let [l (get-in @d [i j])]\n                l\n                (let [l (min (inc (lev i (dec j) d))\n                             (inc (lev (dec i) j d))\n                             (+ (lev (dec i) (dec j) d) (cost i j)))]\n                  (swap! d assoc-in [i j] l)\n                  l)))]\n    (lev m n d)))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 101, "code": "(fn lev-dist [s t]\n  (let [len_s (count s) ; m\n        len_t (count t) ; n\n        in-d (fn [d [i j :as ij]]\n               (cond\n                 (= -1 i j) 0\n                 (= -1 i) (inc j)\n                 (= -1 j) (inc i)\n                 :else (get-in d ij)))]\n               \n    (loop [i 0\n           j 0\n           d (->> (repeat len_t 0)\n                  vec\n                  (repeat len_s)\n                  vec)]\n      (cond\n        (= j len_t) (in-d d [(dec len_s) (dec len_t)])\n        (= i len_s) (recur  0 (inc j) d)\n        :else (let [sub_cost (if (= (get s i) (get t j)) 0 1)\n                    i-1 (dec i)\n                    j-1 (dec j)\n                    d_ij (min (inc (in-d d [i-1 j]))\n                              (inc (in-d d [i j-1]))\n                              (+ sub_cost\n                                   (in-d d [i-1 j-1])))]\n                (recur (inc i) j (assoc-in d [i j] d_ij)))))))", "user": "571d063ee4b0145328a76272"}, {"problem": 101, "code": "(fn levenstein-distance [s1 s2]\n  (letfn [(lev [levm s1 s2]\n            (cond (zero? (count s1)) (count s2)\n                  (zero? (count s2)) (count s1)\n                  :else\n                  (min (inc (levm levm (rest s1) s2))\n                       (inc (levm levm s1 (rest s2)))\n                       (+ (if (= (first s1) (first s2)) 0 1)\n                          (levm levm (rest s1) (rest s2))))))]\n    (lev (memoize lev) s1 s2)))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 101, "code": "(fn [s r]\n  (let [f (memoize\n            (fn [f i j]\n              (if (zero? (min i j))\n                (max i j)\n                (let [i-1 (dec i), j-1 (dec j)]\n                  (min (inc (f f i-1 j))\n                       (inc (f f i j-1))\n                       ((if (not= (get s i-1) (get r j-1))\n                          inc\n                          identity) (f f i-1 j-1)))))))]           \n    (f f (count s) (count r))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 101, "code": "(fn dist [s1 s2]\n  (loop [n1 1 n2 1 dict {}]\n    (let [get #(get dict [% %2] (max % %2))\n          c1 (count s1) c2 (count s2)\n          d1 (- n1 1) d2 (- n2 1)]\n      (cond (> n2 c2) (get c1 c2)\n            (> n1 c1) (recur 1 (+ n2 1) dict)\n            :else\n            (recur (+ n1 1) n2 (assoc dict [n1 n2]\n              (min (+ (get d1 n2) 1)\n                   (+ (get n1 d2) 1)\n                   (+ (get d1 d2)\n                      (if (= (nth s1 d1) (nth s2 d2)) 0 1)))))))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 101, "code": "(fn levenshtein [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char?\n                                                   0\n                                                   1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2           (nth w2 (dec row-idx))\n              next-prev-row (reduce (fn [cur-row i]\n                                      (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                        (conj cur-row (cell-value same-char?\n                                                                  prev-row\n                                                                  cur-row\n                                                                  i))))\n                                    [row-idx] (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows next-prev-row))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 101, "code": "(fn [s1 s2]\n  (let [m (fn r [s l c]\n           (let [x (+ c (if (= (first s) (first l)) 0 1))\n                 p (rest s)\n                 q (rest l)\n                 a (count p)\n                 b (count q)]\n             (if (and (= 0 a) (= 0 b))\n               x\n               (let [z (r p q x)]\n                 (if (> b a)\n                   (min z (r s q (+ 1 c)))\n                   (if (> a b)\n                     (min z (r p l (+ 1 c)))\n                     z))))))]\n  (m s1 s2 0)))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 101, "code": "(fn [s t]\n  (let [m (count s)\n        n (count t)\n        g (vec\n            (map vec\n                 (partition (inc n)\n                            (for [i (range 0 (inc m))\n                                  j (range 0 (inc n))]\n                              (cond\n                                (= 0 j) i\n                                (= 0 i) j\n                                :else 0)))))]\n    (->\n      (reduce\n        (fn [d [i j]]\n          (assoc-in d [(inc i) (inc j)]\n                    (min (inc (get-in d [i (inc j)]))\n                         (inc (get-in d [(inc i) j]))\n                         (+ (get-in d [i j]) (if (= (nth s i) (nth t j)) 0 1)))))\n        g\n        (for [i (range 0 m)\n              j (range 0 n)]\n          [i j]))\n      (get-in [m n]))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 101, "code": "(fn [x y]\n  (let [mem (atom {})\n        dist (fn dist\n               [& [i j :as args]]\n               (if-let [e (find @mem args)]\n                 (val e)\n                 (let [res (if (or (zero? i)\n                             (zero? j))\n                             (max i j)\n                             (min (inc (dist (dec i) j))\n                                  (inc (dist i (dec j)))\n                                  (+ (dist (dec i) (dec j))\n                                     (if (not= (nth x (dec i))\n                                               (nth y (dec j)))\n                                       1 0))))]\n                   (swap! mem assoc args res)\n                   res)))]\n    (dist (count x) (count y))))", "user": "575cbe44e4b02ea114799374"}, {"problem": 101, "code": "(fn levenshtein-d [s1 s2]\n  (let [cnt-s1 (count s1)\n        cnt-s2 (count s2)\n        xys    (vec (for [x (range (inc cnt-s2))]\n                      (vec (for [y (range (inc cnt-s1))]\n                             (cond\n                               (zero? x) y\n                               (zero? y) x\n                               :else 0)))))\n        xys    (reduce (fn [xys [x y]]\n                         (assoc-in xys [(inc x) (inc y)]\n                                   (min (inc (get-in xys [x (inc y)]))\n                                        (inc (get-in xys [(inc x) y]))\n                                        (+ (get-in xys [x y])\n                                           (if (= (nth s2 x) (nth s1 y))\n                                             0\n                                             1)))))\n                       xys\n                       (for [x (range cnt-s2)\n                             y (range cnt-s1)]\n                         [x y]))]\n    (get-in xys [cnt-s2 cnt-s1])))", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 101, "code": "(fn [x y]\n  (letfn\n      [(levenshtein [mem s1 s2]\n         (let [l1 (count s1)\n               l2 (count s2)]\n           (cond (zero? l1) l2\n                 (zero? l2) l1\n                 :else\n                 (let [cost (if (= (first s1) (first s2)) 0 1)]\n                   (min (inc (mem mem (rest s1) s2))\n                        (inc (mem mem s1 (rest s2)))\n                        (+ cost\n                           (mem mem (rest s1) (rest s2))))))))]\n    (levenshtein (memoize levenshtein) x y)))", "user": "56795deae4b05957ce8c6187"}, {"problem": 101, "code": "(fn edit-distance [x y]\n  (letfn [(change-mat [mat l c val]\n            (assoc mat l (assoc (mat l) c val)))\n          (get-val [mat l c]\n            ((mat l) c))\n          (get-next-val [mat l c]\n            (if (= (nth x (dec l)) (nth y (dec c)))\n              (get-val mat (dec l) (dec c))\n              (let [n1 (get-val mat (dec l) c) ;;remove\n                    n2 (get-val mat l (dec c)) ;;insert\n                    n3 (get-val mat (dec l) (dec c))] ;;subs\n                    (inc (min n1 n2 n3)))))\n          ]\n    (let [m (inc (count x))\n          n (inc (count y))\n\n          taux (assoc \n                   (apply vector (repeat m (apply vector (repeat n 0))))\n                 0 (apply vector (range n)))\n          \n          table (reduce #(change-mat %1 %2 0 %2) taux (range m))\n          ]      \n      (loop [i 1\n             tab table]\n        (println tab i)\n        (if (>= i m)\n          (get-val tab (dec m) (dec n))\n          (let [tab2 \n                (reduce #(change-mat %1 i %2 (get-next-val %1 i %2)) tab (range 1 n))]\n            ;;(println tab2 i)\n            (recur (inc i) tab2)))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 101, "code": "(fn [s t]\n  (letfn [\n    (distance [d s t]\n      (cond\n        (empty? s) (count t)\n        (empty? t) (count s)\n        :else\n          (min\n            (inc (d d (rest s) t))\n            (inc (d d s (rest t)))\n            (+ (if (= (first s) (first t)) 0 1)\n              (d d (rest s) (rest t))))))]\n  (distance (memoize distance) s t)))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 101, "code": "(fn\n  [a b]\n  (let [cache (atom {})]\n    (letfn [(lev [i j]\n              (cond (zero? (min i j))\n                (max i j)\n\n                (contains? @cache [i j])\n                (@cache [i j])\n\n                :else\n                (let [res (min (inc (lev (dec i) j))\n                               (inc (lev i (dec j)))\n                               (+ (lev (dec i) (dec j)) (if (= (get a (dec i)) (get b (dec j))) 0 1)))]\n                  (swap! cache assoc [i j] res)\n                  res)))]\n      (lev (count a) (count b)))))", "user": "510db6cde4b078ea71921145"}, {"problem": 101, "code": "(fn lev [[ha & ra :as a] [hb & rb :as b]]\n  (cond\n    (> (count a) (count b)) (lev b a)\n    (nil? ha) (count b)\n    (= ha hb) (lev ra rb)\n    :else\n      (inc\n        (min (lev ra rb) (lev a rb)))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 101, "code": "(fn lev [x y]\n  (cond\n   (empty? x) (count y)\n   (empty? y) (count x)\n   (= (first x) (first y)) (lev (rest x) (rest y))\n   true\n   (+ 1 (min (lev (rest x) y)\n             (lev (rest x) (rest y))\n             (lev x (rest y))\n             )\n      )\n   )\n  )", "user": "5776558ee4b0979f89651633"}, {"problem": 101, "code": "; https://rosettacode.org/wiki/Levenshtein_distance#Clojure\n(fn levenshtein [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char?\n                                                   0\n                                                   1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2           (nth w2 (dec row-idx))\n              next-prev-row (reduce (fn [cur-row i]\n                                      (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                        (conj cur-row (cell-value same-char?\n                                                                  prev-row\n                                                                  cur-row\n                                                                  i))))\n                                    [row-idx] (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows next-prev-row))))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 101, "code": "(letfn\n[\n(ff [xs] (first (first xs)))\n(sf [xs] (second (first xs)))\n(fs [xs] (first (second xs)))\n(ss [xs] (second (second xs)))\n(get-next [s]\n  (set\n    (mapcat\n      (fn [[p [l r]]]\n          (if (empty? l)\n            [[(+ p (count r)) [nil nil]]]\n          (if (empty? r)\n            [[(+ p (count l)) [nil nil]]]\n            [\n              [(inc p) [(rest l) r]]\n              [(inc p) [l (rest r)]]\n              [(if (= (first l) (first r)) p (inc p)) [(rest l) (rest r)]]\n            ])))\n      s)))\n(lev [s1 s2]\n  (loop [now #{[0 [s1 s2]]}]\n    (let [solutions (filter #(apply = ((juxt fs ss) %)) now)]\n      (if (empty? solutions)\n        (recur (get-next now))\n        ; we're depending on the fact that the best solution will show up\n        ; in the first generation that has any solutions\n        (first (apply min-key first solutions))))))\n]\nlev)", "user": "57717915e4b0979f896515b3"}, {"problem": 101, "code": "(fn __ [src tar]\n (let [s (if (string? src) (clojure.string/split src #\"\") src)\n       t (if (string? tar) (clojure.string/split tar #\"\") tar)\n       n (count s) m (count t)\n       matm (fn [ma i j nv]\n       \t     (let [prei (subvec (nth ma j) 0 i)\n\t     \t   posi (subvec (nth ma j) (inc i))\n\t\t   nr (if (empty? prei) \n\t\t      \t  \t  (into [nv] posi)\n\t\t\t\t  (into (conj prei nv) posi))]\n       \t    (if (= j 0)\n\t    \t(into [nr] (subvec ma (inc j)))\n\t\t(if (= j (count ma))\n\t\t    (conj (subvec ma 0 j) nr)\n       \t    \t    (into (conj (subvec ma 0 j) nr) (subvec ma (inc j)))))))\n       tc (fn [ma ci xx yy]\n       \t      (let [sa (nth xx (dec ci))]\n\t      \t   (loop [oma (rest ma) nma ma j 1]\n\t\t   \t (if (empty? oma)\n\t\t\t     nma\n\t\t\t     (let [tstv (if (= (nth yy (dec j)) sa) 0 1)\n\t\t\t\t   nnv   (min (+ 1 (nth (nth nma (dec j)) ci))\n\t\t\t\t\t         (+ 1 (nth (nth nma j) (dec ci)))\n\t\t\t\t\t\t (+ tstv (nth (nth nma (dec j)) (dec ci))))]\n\n\t\t\t  (recur (rest oma)\n\t\t\t  \t (matm nma ci j nnv)\n\t\t\t\t(inc j)))))))]\n       (if (= n 0) m\n       \t   (if (= m 0) n\n\t       (if (= s t) 0\n\t\t(loop [mat (vec (cons (vec (range (inc n))) (mapv #(into [] (cons % (repeat n nil))) (into [] (range 1 (inc m))))))\n\t\t\t  i 1]\n\t\t\t  (if (> i n)\n\t\t\t      (last (last mat))\n\t\t\t      (recur (tc mat i s t) (inc i)))))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 101, "code": "(fn [v w]\n    (let [dist (memoize\n                 (fn [dist v w]\n                    (cond\n                     (empty? v) (count w)\n                     (empty? w) (count v)\n                     :default (min (+ 1 (dist dist v (rest w)))\n                                   (+ 1 (dist dist (rest v) w))\n                                   (+ (dist dist (rest v) (rest w)) (if (= (first v) (first w)) 0 1))))))\n          dist (partial dist dist)]\n      (dist v w)))", "user": "4e837808535db62dc21a62d9"}, {"problem": 101, "code": "(fn lsd [xs ys] \n  (let [xc (count xs)\n        yc (count ys)\n        xy0 [0 0]\n        xyc [xc yc]\n        xv (into [] xs)\n        yv (into [] ys)\n \n        mx \n        (for [xi (range xc)\n              yi (range yc)\n              :when\n              (= (xv xi)\n                 (yv yi))]\n          [xi yi])\n      \n        \n        fltr\n        (fn [[vx vy]]\n          (filter\n           (fn [[ix iy]]\n             (and (<= vx ix)\n                  (<= vy iy)))\n           mx))\n       \n        adif\n        (fn [n v w]\n          (+ \n           n\n           (max \n            (- (w 0) (v 0))\n            (- (w 1) (v 1))))) \n\n        res\n        (fn res [m n v]\n          (if\n           (> (adif n v xyc)\n              m) m)\n          (let \n           [mx  (fltr v)]\n            (if (empty? mx)\n              (min m (adif n v xyc))\n              (reduce \n                #(res %1\n                      (adif n v %2)\n                      [(inc (%2 0))\n                       (inc (%2 1))\n                       ])\n                m\n                mx))))]    \n   (res (adif 0 xy0 xyc)\n        0 \n        xy0)\n  ))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 101, "code": "(fn [x y]\n  (cond\n   (= x y) 0\n   (> (count x) (count y)) (recur y x)\n   (= 0 (compare (first x) (first y))) (recur (rest x) (rest y))\n   (= 0 (compare (last x) (last y))) (recur (butlast x) (butlast y))\n   :else (count (filter false?\n                        (map = (concat x (repeat (- (count y) (count x)) \\*)) y)))\n   ))", "user": "574abbfbe4b02ea114799200"}, {"problem": 101, "code": "(fn d [x y]\n  (cond\n    (= x y) 0\n    (empty? x) (count y)\n    (empty? y) (count x)\n    :else\n    (let [[s & t] x\n          [u & v] y]\n      (cond\n        (= s u) (d t v)\n        :else (inc (min (d t y) (d v x) (d t v)))))))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 101, "code": "(fn lev [sa sb] \n  (let [\n        c (count (take-while true? (map = sa sb))) ;; count of common letters\n        [ah & at :as a] (drop c sa)\n        [bh & bt :as b] (drop c sb)\n        ca (count a)\n        cb (count b)\n        ;;hello (println :a a :b b )\n        ]\n    (cond \n     (nil? ah) cb \n     (nil? bh) ca\n     (= ca cb) (inc (lev at bt))\n     (< ca cb) (inc (min (lev at bt) (lev a bt)))\n     (> ca cb) (inc (min (lev at bt) (lev at b)))\t\t\n     )))", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 101, "code": "(fn [s t]\n  (let [s (vec s)\n        t (vec t)\n        f (fn [f i j]\n            (if (zero? (min i j))\n              (max i j)\n              (min (inc (f f i (dec j)))\n                   (inc (f f (dec i) j))\n                   (+ (if (= (s (dec i)) (t (dec j))) 0 1) (f f (dec i) (dec j))))))\n        f (memoize f)\n        f (partial f f)]\n    (f (count s) (count t))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 101, "code": "(fn myf [s1 s2]\n  (letfn [(board-coor [board x y]\n            (nth (nth board y) x))\n          (change-board [board x y new-var]\n            (assoc board y (assoc (nth board y) x new-var)))]\n    (let [height (count s1)\n          width (count s2)\n          board (vec (map vec (for [x (range (inc height))] (for [y (range (inc width))] (+ x y)))))]\n      (if (zero? height) width\n      (loop [board board, x 1, y 1]\n        (let [change (if (= (nth s1 (dec y)) (nth s2 (dec x))) 0 1)\n              new-board (change-board board x y (min (inc (board-coor board (dec x) y)) (inc (board-coor board x (dec y))) (+ (board-coor board (dec x) (dec y)) change)))]\n          (cond (and (= x width) (= y height)) (nth (nth new-board y) x)\n                (= x width) (recur new-board 1 (inc y))\n                :else (recur new-board (inc x) y))))))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 101, "code": "(fn foo [& args]\n  (let [l-dist (memoize\n                (fn [memf s1 s2]  ; recursive algorithm from https://en.wikipedia.org/wiki/Levenshtein_distance#Recursive\n                  ;; Same as from #82 but takes as first argument a memoized version of itself, which is used in the recursive calls\n                  (let [l1 (count s1) l2 (count s2) dl1 (drop-last s1) dl2 (drop-last s2) l-dist (partial memf memf)]\n                    (cond (zero? l1) l2\n                          (zero? l2) l1\n                          :else (min (inc (l-dist dl1 s2)) (inc (l-dist s1 dl2))\n                                     (+ (l-dist dl1 dl2) (if (= (last s1) (last s2)) 0 1)))))))]\n    (apply l-dist l-dist args)))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 101, "code": "(fn [a b]\n  (let [func (memoize (fn [x y f]\n  (cond \n   (empty? x) (count y)\n   (empty? y) (count x)\n   :else \n   (let [d (if (= (first x) (first y)) 0 1)]\n     (min ( inc (f (rest x) y f)) (inc (f x (rest y) f)) (+ (f (rest x) (rest y) f) d))))))]\n    (func a b func)\n    ))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 101, "code": "(fn lev-dist [s t]\n    (loop [sPos     0\n           v0       (range (inc (count t)))]\n      (if (= sPos (count s)) (last v0)\n          (let [sc    (nth s sPos)\n                v1    (loop [[ tf & tr ]    t\n                             acc            [ (inc sPos ) ]\n                             pos            1]\n                        (if (nil? tf) acc \n                            (let [prioracc   (inc (last acc))\n                                  priorrow   (inc (nth v0 pos))\n                                  cost       (if (= tf sc) 0 1)\n                                  diag       (+ (nth v0 (dec pos)) cost)\n                                  newval     (min prioracc priorrow diag)\n                                  ]\n                              (recur tr (conj acc newval) (inc pos)))))]\n            (recur (inc sPos) v1)\n            )\n          )\n      )\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 101, "code": "(fn dd [s1 s2]\n  (let [dist (fn dist [i j]\n               (cond\n                 (zero? i) j\n                 (zero? j) i\n                 :else\n                 (let [di (dec i)\n                       dj (dec j)]\n                   (if (= (get s1 di) (get s2 dj))\n                     (dist di dj)\n                     (inc (min (dist di dj)\n                               (dist di j)\n                               (dist i dj)))))))]\n    (dist (count s1) (count s2))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 101, "code": "(fn levenshtein [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char? 0 1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2       (nth w2 (dec row-idx))\n              next-prev (reduce (fn [cur-row i]\n                                  (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                    (conj cur-row (cell-value same-char?\n                                                              prev-row\n                                                              cur-row\n                                                              i))))\n                                [row-idx]\n                                (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows, next-prev))))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 101, "code": "(fn [s t]\n  (let [[sc tc] (map count [s t])]\n    (or ({s 0} t)\n        ({sc tc} 0 ({tc sc} 0))\n        (#(get (reduce % `[~@(range (inc tc))] (range sc)) tc)\n         #(reduce (fn [x y] (conj x\n             (min (inc (get x y))\n                  (inc (get %1 (inc y)))\n                  (+ (get %1 y) ({(get s %2) 0} (get t y) 1))) ))\n           [(inc %2)] (range tc))) )))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 101, "code": "(fn levenstein-a\n  [word-a word-b]\n  (let [[list-a list-b] (map vec [word-a word-b])\n        make-fibo (fn make-fibo []\n                    (let\n                      [min-dist\n                       (fn [mem-fib list-a list-b]\n                         (let [min-dist (fn [x y] (mem-fib mem-fib x y))]\n                           (if (= 0 (count list-a))\n                             (count list-b)\n                             (if (= 0 (count list-b))\n                               (count list-a)\n                               (let [cost (if (= (first list-a) (first list-b))\n                                            0 1)]\n                                 (min (+ 1 (min-dist (rest list-a) list-b))\n                                      (+ 1 (min-dist (rest list-b) list-a))\n                                      (+ cost (min-dist (rest list-a) (rest list-b)))\n                                      ))))))\n                       mem-dist (memoize min-dist)]\n\n                      (partial mem-dist mem-dist)))]\n\n    ((make-fibo) list-a list-b))\n  )", "user": "5545477fe4b0a04f79299531"}, {"problem": 101, "code": "(fn levenshtein [s t]\n  (let [n (count s) m (count t) longer (max n m)]\n    (if (or (zero? n) (zero? m)) longer\n      (let [s (into [] s) t (into [] t) t+2 (+ 2 m)]\n        (loop [i 0 v0 (into [] (range  (inc m)))]\n          (if (>= i n) (v0 m)\n            (recur (inc i)   \n               (loop [j 0 v1 (into [] (repeat (inc longer) (inc i)))]\n                (if (>= j m) v1\n                  (let [cost (if (= (s i) (t j)) 0 1)]\n                    (recur (inc j)\n                      (assoc v1 (inc j)\n                        (min (inc (v1 j)) (inc (v0 (inc j))) (+ (v0 j) cost))))))))))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 101, "code": "(fn distance [a b]\n  (letfn [(walk\n           [f a b]\n           (cond\n             (or (nil? a) (nil? b))\n             (+ (count a) (count b))\n             \n             (= (first a) (first b))\n             (f f (next a) (next b))\n            \n             :else\n             (inc (min (f f (next a) (next b))\n                       (f f (next a) b)\n                       (f f a (next b))))))]\n    (walk (memoize walk) a b)))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 101, "code": "(fn [a b]\n  (letfn [(step [calculated-result coordinate]\n            (let [x (first coordinate)\n                  y (last coordinate)]\n              (assoc calculated-result\n                coordinate\n                (if (zero? (min x y))\n                  (max x y)\n                  (min\n                    (inc (calculated-result [(dec x) y]))\n                    (inc (calculated-result [x (dec y)]))\n                    (+\n                      (calculated-result [(dec x) (dec y)])\n                      (if (= ((vec a) (dec x)) ((vec b) (dec y))) 0 1)))))))]\n    ((reduce step {} (apply concat (map #(map (fn [i] [% i]) (range 0 (inc (count b)))) (range 0 (inc (count a)))))) [(count a) (count b)])))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 101, "code": "(fn dis\n  [w1 w2]\n  (if (or (empty? w1)\n          (empty? w2))\n    (+ (count w1) (count w2))\n    (let [x1 (first w1)\n          y1 (first w2)]\n      (if (= x1 y1)\n        (dis (rest w1) (rest w2))\n        (inc (min (dis (rest w1) (rest w2))\n                  (dis (rest w1) w2)\n                  (dis w1 (rest w2))))))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 101, "code": "(fn [x y]\n  (let [[x y] (sort-by count [x y])\n        blanks (fn blanks [coll n]\n                 (if (zero? n)\n                   [coll]\n                   (mapcat (fn [i]\n                             (let [[l r] (split-at i coll)]\n                               (map #(concat l (cons ::blank %))\n                                    (blanks r (dec n)))))\n                           (range (inc (count coll))))))\n        x-blanks (blanks x (- (count y) (count x)))\n        diffs (fn [a b] (count (remove identity (map #(= % %2) a b))))]\n    (apply min (map diffs x-blanks (repeat y)))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 101, "code": "(fn levendist [s1 s2] \n (let [ld\n  (reduce (fn [edit pair]\n           (let [[i j] pair]\n             (cond\n               (zero? i) (assoc edit [i j] j)\n               (zero? j) (assoc edit [i j] i)\n               :else (assoc edit [i j] \n                        (min (+ (if (= (nth s1 (dec i)) (nth s2 (dec j))) 0 1) (edit [(dec i) (dec j)]))\n                             (inc (edit [(dec i) j]))\n                             (inc (edit [i (dec j)])))))))\n          {[0 0] 0}\n          (for [i (range (inc (count s1))) j (range (inc (count s2)))] [i j]))]\n  (ld [(count s1) (count s2)])))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 101, "code": "(fn\n  [a b]\n  (last \n    (reduce \n      (fn [arow bi]\n        (second\n          (reduce \n            (fn [[[f s & _ :as lr] cr] ai]\n              [(rest lr)\n               (conj \n                 cr\n                 (min \n                   (+ 1 (last cr)) \n                   (+ 1 s)\n                   (+ f (if (= ai (nth b bi)) 0 1))))])\n            [arow [(inc bi)]]\n            a)))\n      (range (inc (count a)))\n      (range (count b)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 101, "code": "(fn [a b]\n  (let [c1 (+ 1 (count a))\n        c2 (+ 1 (count b))]\n    (loop [left (into (sorted-map)\n                      (for [x (range 1 c1)\n                            y (range 1 c2)]\n                        [[x y] 0]))\n           done (into (sorted-map)\n                      (concat \n                        (for [y (range c2)]\n                          [[0 y] y])\n                        (for [x (range c1)]\n                          [[x 0] x])))]\n      (if (seq left)\n        (let [[[i j]] (first left)]\n          (recur (rest left)\n                 (assoc\n                   done\n                   [i j] \n                   (if (= (get a (dec i)) (get b (dec j)))\n                     (get done [(dec i) (dec j)])\n                     (inc (min (get done [(dec i) j])\n                               (get done [i (dec j)])\n                               (get done [(dec i) (dec j)])))))))\n        ((last done) 1)))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 101, "code": "(fn edit-distance [s1 s2]\n  (let [s1 (vec (concat \"^\" s1 \"$\"))\n        s2 (vec (concat \"^\" s2 \"$\"))\n        l1 (count s1)\n        l2 (count s2)]\n    (loop [scores (vec (concat [0] (repeat (dec l2) 1000000)))\n           index 1]\n      (println scores index l1 l2)\n      (if (= index l1)\n        (last scores)\n        (recur\n         (let [c1 (s1 index)]\n           (vec\n            (map-indexed\n             (fn [idx2 c2]\n               (min\n                (+ (scores idx2) 1)\n\n                (reduce min\n                        10000000\n                        (for [idx2' (range 0 idx2)]\n                          (+ (- idx2 idx2' 1)\n                             (scores idx2')\n                             (if (= c1 (s2 idx2)) 0 1))))))\n\n                \n             s2)))\n         (inc index))\n      ))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 101, "code": "(fn leven-dist [as bs]\n  (cond\n    (and (empty? as) (empty? bs)) 0\n    (empty? as) (count bs)\n    (empty? bs) (count as)\n    (= as bs) 0\n    :otherwise\n      (let [av (vec as)\n            bv (vec bs)\n            aidx (->> av count inc (range 0) vec)\n            ;bidx (->> bv count inc (range 0) vec)\n            ]\n        (letfn [\n          (cross-score [bb aa] (if (= bb aa) 0 1))\n          (min-of [q & rs] (reduce (fn [z b] (if (< z b) z b)) q rs))\n          (score-line [bj sc-prev-line]\n              (first\n                (reduce (fn [[acc sdiag] [ax sx]]\n                          [(conj acc\n                                 (min-of (inc (peek acc))\n                                         (inc sx)\n                                         (+ sdiag (cross-score bj ax))))\n                           sx])\n                      [[(inc (first sc-prev-line))] (first sc-prev-line)]\n                      (map vector av (rest sc-prev-line))))\n                )]\n          (let [last-line (reduce (fn [zz b] (score-line b zz)) aidx bv)]\n            (last last-line))))))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 101, "code": "(let [lev\n      (fn [mem-lev left right]\n        (if (empty? left) (count right)\n            (if (empty? right) (count left)\n                (let [cost (if (= (last left) (last right)) 0 1)]\n                  (min (+ 1 (mem-lev mem-lev (butlast left) right))\n                       (+ 1 (mem-lev mem-lev left (butlast right)))\n                       (+ cost (mem-lev mem-lev (butlast left) (butlast right))))))))]\n  (let [mem-lev (memoize lev)]\n    (partial mem-lev mem-lev)))", "user": "58152157e4b0f478707a0631"}, {"problem": 101, "code": "(fn diff \n  ([a b] (diff a b (max (count a) (count b))))\n  ([[fa & ra :as a]  [fb & rb :as b] limit]\n\t(cond \n     (= 0 limit) 0\n     (= nil a) (min (count b) limit)\n     (= nil b) (min (count a) limit)\n     (= fa fb) (diff ra rb limit)\n     :default (->> (dec limit) \n                   (diff ra b)\n                   (diff a rb)\n                   (diff ra rb)\n                   inc)\n     ))\n                   \n)", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 101, "code": "(fn [seq-a seq-b]\n  (let [a (inc (count seq-a))\n        b (inc (count seq-b))\n        vec-a (vec seq-a)\n        vec-b (vec seq-b)]\n    (cond\n      (zero? (dec a)) (dec b)\n      (zero? (dec b)) (dec a)\n      :else\n      (letfn [(initialize [a b]\n                (vec (for [i (range a)]\n                    (vec (for [j (range b)]\n                        (cond\n                          (zero? i) j\n                          (zero? j) i\n                          :else 0))))))\n              (cost [d i j]\n                (min (+ 1 (get-in d [(dec i) j]))\n                     (+ 1 (get-in d [i (dec j)]))\n                     (+ (if (= (get vec-a (dec i))\n                               (get vec-b (dec j)))\n                          0\n                          1) (get-in d [(dec i) (dec j)]))))\n              (process [table m n]\n                (loop [x 0\n                       y 1\n                       d table]\n                  (let [[i j] (if (= x (dec m))\n                                [1 (inc y)]\n                                [(inc x) y])]\n                    (if (= j n)\n                      d\n                      (recur i j (assoc-in d [i j] (cost d i j)))))))]\n        (let [d (initialize a b)\n              d (process d a b)]\n          (get-in d [(dec a) (dec b)]))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 101, "code": "(fn [s t]\n  (loop [i 0\n         j 0\n         d (apply conj {}\n                         (concat\n                          (map #(vector (vector % -1) 0) (range -1 (count s)))\n                          (map #(vector (vector -1 %) 0) (range -1 (count t)))\n                          (map #(vector (vector % -1) (inc %)) (range (count s)))\n                          (map #(vector (vector -1 %) (inc %)) (range (count t)))))]\n    (if (= i (count s))\n     (d (vector (dec (count s))\n                       (dec (count t))))\n     (if (= j (count t))\n        (recur (inc i) 0 d)\n        (recur i (inc j)\n               (conj d (vector (vector i j)\n                                      (let [val\n                                            (min\n                                             (inc (d (vector (dec i) j)))\n                                             (inc (d (vector i (dec j))))\n                                             (+ (d (vector (dec i) (dec j)))\n                                                (if (= (nth s i) (nth t j)) 0 1)))]\n                                        val))))))))", "user": "584917a1e4b089d5ab817ec9"}, {"problem": 101, "code": "(fn levenshtein-distance [s t]\n  (cond\n    (= s t)    0\n    (empty? s) (count t)\n    (empty? t) (count s)\n    :else\n    (loop [v0 (into [] (range (+ (count t) 1)))\n           i  0]\n      (if (< i (count s))\n        (letfn [(fill-v1 [v1 j]\n                  (let [cost (if (= (get s i) (get t j)) 0 1)]\n                    (if (< j (count t))\n                      (recur (conj v1\n                                   (min (+ (v1 j) 1)\n                                        (+ (v0 (inc j)) 1)\n                                        (+ (v0 j) cost)))\n                             (inc j))\n                      v1)))]\n          (recur (fill-v1 [(inc i)] 0) (inc i)))\n        (v0 (count t))))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 101, "code": ";; https://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\n(fn levenshtiein[s t]\n  (let [m (count s)\n        n (count t)\n        matrix (mapv #(vec (range % (+ m % 1))) (range (inc n)))\n        coords (for [x (range 1 (inc n))\n                     y (range 1 (inc m))] [x y])\n        distance (fn [[x y] m]\n                   (if (= (get t (dec x)) (get s (dec y)))\n                     (get-in m [(dec x) (dec y)])\n                     (apply min\n                       (map inc\n                        [(get-in m [(dec x) y])\n                         (get-in m [x (dec y)])\n                         (get-in m [(dec x) (dec y)])])\n                       )))\n        invariant (loop [m matrix [c & cs] coords]\n                    (if (nil? c)\n                      m\n                      (recur (update-in m c (fn [d] (distance c m))) cs)))]\n    (get-in invariant [n m])))", "user": "56069006e4b08b23635d3174"}, {"problem": 101, "code": "(letfn \n  [(mult\n     [v1 v2]\n     (for [i v1\n           j v2]\n       (conj (if (vector? i) i [i]) j)))\n\n   (has-distinct [k e] (= k (count (distinct e))))\n   (sorted? [e] (= e (sort e)))\n\n   (combinations\n     [n k]\n     (cond \n       (= k 1)\n       (->>\n         (range n)\n         (map hash-set))\n       (or (> k n) (= k 0))\n       nil\n       :default\n       (->>\n         (range n)\n         (repeat k)\n         (reduce mult)\n         (filter (partial has-distinct k))\n         (filter sorted?)\n         (map set))))\n\n   (diff-elems\n     [s1 s2]\n     (->> \n       (map = s1 s2)\n       (map not)\n       (filter identity)\n       count))\n\n   (remove-elems\n     [s elems]\n     (apply concat \n            (map-indexed\n              (fn [idx elem] (if (contains? elems idx) [] [elem])) s)))\n\n   (levenstien\n     [i1 i2]\n     (let [[s1 s2] [(seq i1) (seq i2)]\n           [s1 s2] (sort-by count [s1 s2])\n           [l1 l2] [(count s1) (count s2)]\n           diff (- l2 l1)\n           changes (cond (= 0 diff)\n                     (diff-elems s1 s2)\n                     (= l2 diff) 0\n                      :default\n                     (apply min\n                            (for [indices (combinations l2 diff)\n                                  :let [s (remove-elems s2 indices)\n                                        _ (println s)\n                                        diff (diff-elems s1 s)]] diff)))]\n       (+ diff changes)))]\n  levenstien)", "user": "540e97f9e4b0addc1aec671f"}, {"problem": 101, "code": "(fn lev [[h & t :as a] [f & r :as b]]\n    (cond (nil? h) (count b)\n          (nil? f) (count a)\n          (= f h) (recur t r)\n          :else (min (inc (lev t r))\n                     (inc (lev a r))\n                     (inc (lev t b)))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 101, "code": "(fn levenshtein-distance [str1 str2]\n  (let [lev-dist (fn [str1 str2] \n      (let [lev-line (fn [str1 ch-str2 last-row]\n      (loop [j 0 row (vector (inc (first last-row)))]\n        (if (< j (count str1))\n          (recur\n            (inc j)\n            (conj\n              row\n              (min\n                (+ (get last-row j) (if (= ch-str2 (nth str1 j)) 0 1))\n                (inc (get last-row (inc j)))\n                (inc (last row))\n              )\n            )\n          )\n          row\n        )\n      )\n    )] (loop [row (into [] (range (inc (count str1)))) m (vector row) i 0]\n        (if (< i (count str2))\n          (let [new-row (lev-line str1 (nth str2 i) row)]\n            (recur new-row (conj m new-row) (inc i))\n          )\n          (last (last m))\n        )\n      ))\n    )]\n  (if (empty? str1)\n    (count str2)\n    (if (empty? str2)\n      (count str1)\n      (lev-dist str1 str2)\n    )\n  )\n)\n)", "user": "569e3175e4b0542e1f8d1484"}, {"problem": 101, "code": "(fn lev-distance [seq-1 seq-2]\n  (cond\n    (> (count seq-1)\n       (count seq-2)) (lev-distance seq-2 seq-1)\n    (= seq-1 seq-2) 0\n    (empty? seq-1) (count seq-2)\n    (= (first seq-1)\n       (first seq-2)) (lev-distance (rest seq-1) (rest seq-2))\n    :else (min (inc (lev-distance (rest seq-1) (rest seq-2)))\n               (inc (lev-distance seq-1 (rest seq-2))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 101, "code": "(fn [w1 w2]\n  (letfn [(step-row [prev-row [ch2 row-num]]\n            (reductions\n             (fn [cur-last [ch1 [ri-1 ri]]]\n               (min (inc ri)\n                    (inc cur-last)\n                    (if (= ch1 ch2) ri-1 (inc ri-1))))\n             row-num\n             (map vector w1 (partition 2 1 prev-row))))]\n    (last (reduce step-row\n                  (range (inc (count w1)))\n                  (map vector w2 (iterate inc 1))))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 101, "code": "(fn [xs ys]\n  (let [num-rows (inc (count xs))\n        num-cols (inc (count ys))\n        dist (atom (->> (range num-rows)\n                        (map (fn [_] (vec (repeat num-cols 0))))\n                        vec))]\n    (doseq [i (range num-rows)]\n      (swap! dist assoc-in [i 0] i))\n    (doseq [j (range num-cols)]\n      (swap! dist assoc-in [0 j] j))\n    (doseq [j (range 1 num-cols)\n            i (range 1 num-rows)\n            :let [replace-cost ({true 0 false 1} (= (get xs (dec i))\n                                                    (get ys (dec j))))]]\n      (swap! dist assoc-in [i j]\n             (min (inc (get-in @dist [(dec i) j]))\n                  (inc (get-in @dist [i (dec j)]))\n                  (+ replace-cost (get-in @dist [(dec i) (dec j)])))))\n    (get-in @dist [(dec num-rows) (dec num-cols)])))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 101, "code": "(fn ld\n  ([a b]\n   (ld a b 0))\n  ([a b edits]\n   (if (or (empty? a) (empty? b)) (+ edits (count a) (count b))\n       (if (= (first a) (first b)) (ld (rest a) (rest b) edits)\n           (min (ld (rest a) b (inc edits))\n                (ld a (rest b) (inc edits))\n                (ld (rest a) (rest b) (inc edits)))))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 101, "code": "(fn [left right]\n  (let [mem (atom {})\n        leven (fn leven [l r] \n                (if-let [c (find @mem [l r])]\n                  (val c)\n                  (let [result (if (some nil? [l r])\n                                 (count (concat l r))\n                                 (min\n                                   (+ 1 (leven (next l) r))\n                                   (+ 1 (leven l (next r)))\n                                   (+ (if (= (first l) (first r))\n                                        0\n                                        1)\n                                      (leven (next l) (next r)))))]\n                    (swap! mem assoc [l r] result)\n                    result)))]\n    (leven (seq left) (seq right))))", "user": "58247423e4b051871117bec5"}, {"problem": 101, "code": "(fn [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char?\n                                                   0\n                                                   1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2           (nth w2 (dec row-idx))\n              next-prev-row (reduce (fn [cur-row i]\n                                      (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                        (conj cur-row (cell-value same-char?\n                                                                  prev-row\n                                                                  cur-row\n                                                                  i))))\n                                    [row-idx] (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows next-prev-row))))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 101, "code": "(letfn [(matrix [n m d]\n          (vec (take n (repeat (vec (take m (repeat d)))))))\n        (assoc-col [m, i, v]\n          (vec (map #(assoc-in %1 [i] %2) m v)))\n        (assoc-row [m, i, v]\n          (assoc-in m [i] (vec v)))\n        (init-matrix [n m]\n          (assoc-row (assoc-col (matrix n m 0) 0 (range n)) 0 (range m)))\n        (test-coords [i j]\n          (for [y [0 -1] x [0 -1] :when (or (not= x 0) (not= y 0))] [(+ i x) (+ j y)]))\n        (cost [m [i j] sc]\n          (apply min (map + (map (partial get-in m) (test-coords i j)) [1 1 sc])))\n        (all-coords [a b]\n          (let [n (count a)\n                m (count b)\n                sub-cost (fn [i j] (if (= (a (dec i)) (b (dec j))) 0 1))]\n            (for [x (range 1 (inc n)) y (range 1 (inc m))] [[x y] (sub-cost x y)])))\n        (cost-matrix [a b]\n          (let [n (count a)\n                m (count b)]\n            (reduce (fn [mxt [coord sc]] (assoc-in mxt coord (cost mxt coord sc)))\n                    (init-matrix (inc n) (inc m))\n                    (all-coords a b))))]\n  (fn [a b]\n    (let [a (vec a)\n          b (vec b)\n          n (count a)\n          m (count b)] \n      (get-in (cost-matrix a b) [n m]))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 101, "code": "(fn levenshtein [a b]\n  (let [\n    lev (fn [leven-mem i j]\n      (if (= 0 (min i j))\n        (max i j)\n        (min\n          (+ (leven-mem leven-mem (dec i) j)       1)\n          (+ (leven-mem leven-mem i       (dec j)) 1)\n          (+ (leven-mem leven-mem (dec i) (dec j)) (if (= (nth a (dec i)) (nth b (dec j))) 0 1))\n      )))\n    leven-mem (memoize lev)\n  ]\n  ((partial leven-mem leven-mem) (count a) (count b))\n))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 101, "code": "(fn levenshtein [a0 b0]\n  (let [a (vec a0)\n        b (vec b0)\n        lev (memoize (fn [lev i j]\n                       (if (= 0 (min i j))\n                         (max i j)\n                         (min (inc (lev lev (dec i) j))\n                              (inc (lev lev i (dec j)))\n                              (+ (lev lev (dec i) (dec j))\n                                 (if (= (a (dec i)) (b (dec j))) 0 1))))))\n        lev (partial lev lev)]\n    (lev (count a) (count b))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 101, "code": "(fn [a b]\n   (let [b (seq b)\n         i into\n         f #(loop [o [] a % b %2]\n               (let [[c & a] a\n                     [d & b] b]\n                 (if (= c d)\n                   (if c (recur (conj o c) a b))\n                   [(i (conj o d) a) (i o a) (i (conj o d c) a)])))]\n   (loop [l #{(seq a)} n 0]\n     (if (some #(= b %) l)\n       n\n       (recur (reduce #(into % (f %2 b)) l l) (inc n))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 101, "code": "(fn lev [a b]\n  (letfn [(l [m [i j :as ij]]\n            (if (zero? (min i j))\n              (max i j)\n              (min (inc (get-in m [(dec i) j]))\n                   (inc (get-in m [i (dec j)]))\n                   (+ (get-in m [(dec i) (dec j)])\n                      (if (= (get a (dec i)) (get b (dec j))) 0 1)))))]\n    (let [grid (reduce\n                 (fn [m ij] (assoc-in m ij (l m ij)))\n                 (vec (repeat (count b) []))\n                 (for [i (range (inc (count a))) j (range (inc (count b)))] [i j]))]\n      (get-in grid [(count a) (count b)]))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 101, "code": "(fn lev [a b]\n  (let [lev#\n        (memoize\n         (fn [lev# a b]\n           (cond (empty? a) (count b)\n                 (empty? b) (count a)\n                 :else (let [cost (if (= (first a) (first b)) 0 1)]\n                         (min (+ (lev# lev# (rest a) b) 1)\n                              (+ (lev# lev# a (rest b)) 1)\n                              (+ (lev# lev# (rest a) (rest b)) cost))\n                         ))\n           ))\n        lev# (partial lev# lev#)]\n    (lev# a b)\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 101, "code": "(fn [coll-1 coll-2]\n  (loop [x coll-1, y coll-2, counter 0]\n    (let [len-x (count x)\n          len-y (count y)]\n      (cond\n        ;; base case\n        (= len-x 0) (+ counter len-y) \n        (= len-y 0) (+ counter len-x)\n        ;; substitution?\n        (= (first x) (first y)) (recur (rest x) (rest y) counter)\n        ;; insertion?\n        (and (= len-x 1) (< len-x len-y)) (recur x (rest y) (inc counter))\n        ;; delete?\n        (and (= len-y 1) (> len-x len-y)) (recur (rest x) y (inc counter))\n        ;; recursion!!\n        :else (recur (rest x) (rest y) (inc counter))))))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 101, "code": "(fn distance [xs ys]\n  (cond\n    (empty? xs) (count ys)\n    (empty? ys) (count xs)\n    true\n    (let [[x & xs'] xs\n          [y & ys'] ys]\n      (if (= x y)\n        (distance xs' ys')\n        (inc (min (distance xs' ys') (distance xs' ys) (distance xs ys')))))))", "user": "50479524e4b0371827a27bc4"}, {"problem": 101, "code": "(fn [s1 s2]\n  (letfn [(leven [f s1 s2]\n              (cond (empty? s1) (count s2)\n                    (empty? s2) (count s1)\n                    :else\n                    (min\n                     (+ (f f (rest s1) (rest s2))\n                        (if (= (first s1) (first s2)) 0 1))\n                     (inc (f f (rest s1) s2))\n                     (inc (f f s1 (rest s2))))))]\n      (let [m-leven (memoize leven)] \n        (m-leven m-leven s1 s2))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 101, "code": "(memoize\n   (fn lev-dist [w1 w2]\n     (cond\n       (zero? (count w1)) (count w2)\n       (zero? (count w2)) (count w1)\n       (= (first w1) (first w2)) (lev-dist (next w1) (next w2))\n       :else (inc (min\n                   (lev-dist w1 (next w2))\n                   (lev-dist (next w1) w2)\n                   (lev-dist (next w1) (next w2)))))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "5790f9d7e4b0ebec4cfb75b4"}, {"problem": 101, "code": "(fn [a b]\n  (letfn [(lcs [[x-h & x-t :as x] [y-h & y-t :as y]]\n            (cond\n              (empty? x) (count y)\n              (empty? y) (count x)\n              (= x-h y-h) (lcs x-t y-t)\n              :else (+ 1 (min (lcs x y-t) (lcs x-t y) (lcs x-t y-t)))))]\n    (lcs a b)))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 101, "code": "(fn levenshtein-distance [seq-1 seq-2]\n  (cond (empty? seq-1) (count seq-2)\n        (empty? seq-2) (count seq-1)\n        (= (first seq-1) (first seq-2)) (levenshtein-distance (rest seq-1) (rest seq-2))\n        :else (inc (min (levenshtein-distance (rest seq-1) seq-2)\n                        (levenshtein-distance seq-1 (rest seq-2))\n                        (levenshtein-distance (rest seq-1) (rest seq-2))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 101, "code": "(memoize (fn levenshtein [x y]\n             (let [longest (max-key count x y)]\n               (cond\n                 (or (empty? x)\n                     (empty? y))\n                 (count longest)\n\n                 (= (first x) (first y))\n                 (levenshtein (rest x) (rest y))\n\n                 :first-chars-not-equal\n                 (inc (min (levenshtein (rest x) (rest y)) ;; substitution\n                           (levenshtein x (rest y))  ;; delete a character from x\n                           (levenshtein (rest x) y) ;; insert y's character into x\n                           ))))))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 101, "code": "(let [lev (fn lev [f a b]\n              (if (zero? (count a))\n                (count b)\n                (if (zero? (count b))\n                  (count a)\n                  (let [cost (if (= (peek a) (peek b)) 0 1)]\n                    (min\n                      (+ (f f (pop a) b) 1)\n                      (+ (f f a (pop b)) 1)\n                      (+ (f f (pop a) (pop b)) cost)\n                      )))))\n        m-lev (memoize lev)]\n    (fn [a b]\n      (m-lev m-lev (into [] a) (into [] b))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 101, "code": "(fn lev\n  ([s t]\n    (if (= s t) 0\n      (if (empty? s) (count t)\n        (lev s t 1 (range (inc (count s)))))))\n  ([s rt i d]\n    (if (empty? rt) (last d)\n      (lev\n        s\n        (rest rt)\n        (inc i)\n        (cons\n          (inc i)\n          (last\n            (reduce\n              (fn [[lft acc] [up up-lft]]\n                (let [v (min (inc lft) up up-lft)] [v (conj acc v)]))\n              [i []]\n              (map vector\n                   (map inc (rest d))\n                   (let [tj (first rt)]\n                     (map\n                       (fn [[up-lft eq-ij?]] (+ up-lft (if eq-ij? 0 1)))\n                       (map vector (drop-last d) (map (partial = tj) s))))))))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 101, "code": "(fn leven [a b]\n  (let [lev (memoize\n              (fn [self i j]\n                (let [ind (if (not= (get a (dec i)) (get b (dec j))) 1 0)]\n                  (if (= 0 (min i j))\n                    (max i j)\n                    (min (+ 1 (self self (dec i) j))\n                         (+ 1 (self self i (dec j)))\n                         (+ ind (self self (dec i) (dec j))))))))]\n    (lev lev (count a) (count b))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 101, "code": "(fn [n f r c x y]\n  (last\n   (f #(f (fn [c i]\n\t    (conj c (+ 1 (min (n % (+ i 1)) (n c i)\n\t\t\t      (- (n % i) ({(n x i) 1} (n y %2) 0))))))\n\t  [(+ %2 1)] (r (c x)))\n      (r (+ 1 (c x)))\n      (r (c y)))))\nnth reduce range count", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 101, "code": "(fn [s t]\n  (let [s (vec s), t (vec t), |s| (count s), |t| (count t)]\n    (loop [i 0 v (-> |t| inc range vec)]\n      (if (< i |s|)\n        (recur (inc i)\n               (reduce (fn [w j]\n                         (conj w (min (inc (w j))\n                                      (inc (v (inc j)))\n                                      (+ (v j) (if (= (s i) (t j)) 0 1)))))\n                       [(inc i)] (range |t|)))\n        (peek v)))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 101, "code": "(fn [x-coll y-coll]\n   (last (let [xs (range (inc (count x-coll)))\n               ys (range (inc (count y-coll)))]\n           (reduce (fn [initx x]\n                     (if (zero? x)\n                       ys\n                       (reduce (fn [inity y]\n                                 (if (zero? y)\n                                   (conj inity x)\n                                   (if (= (get x-coll (dec x))  (get y-coll (dec y)))\n                                     (conj inity (nth initx (dec y)))\n                                     (conj inity (inc (min\n                                                       (nth initx y)\n                                                       (nth inity (dec y))\n                                                       (nth initx (dec y))))))))\n                               [] ys)))\n                   [] xs))))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 101, "code": "(let [sub (fn sub [x s e] (cond\n                       (string? x) (subs x s e)\n                       (vector? x) (subvec x s e)\n                       :else (sub (vec x) s e)))\n      lev (fn [mem-lev a b]\n           (cond\n             (empty? a) (count b)\n             (empty? b) (count a)\n             :else (min (+ (mem-lev mem-lev (sub a 0 (dec (count a))) b) 1)\n                        (+ (mem-lev mem-lev a (sub b 0 (dec (count b)))) 1)\n                        (+ (mem-lev mem-lev (sub a 0 (dec (count a)))\n                                            (sub b 0 (dec (count b))))\n                           (if (= (last a) (last b)) 0 1)))))\n      mem-lev (memoize lev)]\n  (partial mem-lev mem-lev))", "user": "50b65966e4b0a86f8358ca6c"}, {"problem": 101, "code": "(fn d [s t]\n    ((loop [tt {[() ()] 0} i 0]\n       (if (<= i (count s))\n         (recur (loop [ss tt j 0]\n                  (if (<= j (count t))\n                    (recur (conj ss (let [si (take i s) tj (take j t)]\n                                      {[si tj] (cond\n                                                 (= 0 i) j\n                                                 (= 0 j) i\n                                                 :else (min (+ (get ss [(take (dec i) s) (take j t)] 0) 1)\n                                                            (+ (get ss [si (take (dec j) t)] 0) 1)\n                                                            (+ (get ss [(take (dec i) s) (take (dec j) t)] 0) (if (= (last si) (last tj)) 0 1))\n                                                            ))\n                                       })) (inc j))\n                    ss)\n                  ) (inc i))\n         tt)\n\n       ) [(take (count s) s) (take (count t) t)])\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 101, "code": "(fn editdist [s t]\n  (let [dp\n        (fn dp [mdp x y]\n          (let [xym (when (> (min x y) 0)\n                      (let [r (mdp mdp (dec x) (dec y))]\n                        (if (= (get s (dec x)) (get t (dec y)))\n                          r\n                          (inc r))))\n                xm (when (> x 0)\n                     (inc (mdp mdp (dec x) y)))\n                ym (when (> y 0)\n                     (inc (mdp mdp x (dec y))))\n                l (filter (comp not nil?) (list xym xm ym))]\n            (if (empty? l)\n              0\n              (apply min l))))\n        mdp (memoize dp)]\n    (mdp mdp (count s) (count t))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 101, "code": "(fn wf [a b]\n  \n  (let [d (atom (reduce (fn [d i] (conj d [i])) [(vec (range (inc (count b))))] (range 1 (inc (count a)))))]\n     \n    (doseq [j (range 1 (inc (count b)))\n            i (range 1 (inc (count a)))]\n\n      (if (= (nth a (dec i)) (nth b (dec j)))\n          (reset! d (assoc-in @d [i j] (get-in @d [(dec i) (dec j)])))\n          (reset! d (assoc-in @d [i j]\n                              (+ 1 (apply min (map (partial get-in @d) [[(dec i) j] [i (dec j)] [(dec i) (dec j)]])))))))\n                 \n      (get-in @d [(count a) (count b)])))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 101, "code": "(fn dist [s1 s2]\n  (cond\n  (empty? s2)\n    (count s1)\n  (empty? s1)\n    (count s2)\n  :else\n    (let [[ss1 ss2] (sort-by count [s1 s2])\n           [c1 c2] (map count [ss1 ss2])\n           [h1 & t1] ss1\n           [h2 & t2] ss2]\n    (if (= h1 h2)\n        (dist t1 t2)\n        (inc (min\n                (if (< c1 c2)\n                  (min\n                    (dist (cons h2 ss1) ss2)  ; \u77ed\u7684\u52a0\u4e00\n                    (dist ss1 t2))                   ; \u957f\u7684\u51cf\u4e00\n                  c1)\n                (dist (cons h2 t1) ss2)    ; \u6362\u6210\u957f\u5934\n                (dist ss1 (cons h1 t2))    ; \u6362\u6210\u77ed\u5934\n        ))))))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 101, "code": "(fn ldistance\n  [s1 s2]\n  (if (or (empty? s1) (empty? s2))\n    (+ (count s1) (count s2))\n    (if (= (first s1) (first s2))\n      (ldistance (next s1) (next s2))\n      (inc (min (ldistance (next s1) s2)\n                (ldistance s1 (next s2))\n                (ldistance (next s1) (next s2)))))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 101, "code": "(fn d[s1 s2] (\n\n         if (or (empty? s1) (empty? s2))\n          (\n            max (count s1) (count s2)\n            )    \n         (if (= (first s1) (first s2))\n             (d (rest s1) (rest s2))\n             (inc (\n                    min\n                    (d (rest s1) (rest s2))\n                    (d (rest s1) s2)\n                    (d s1 (rest s2))\n                    ))\n          )\n         \n         \n               ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 101, "code": "(fn lev2\n  [s t]\n  (let [initm (fn initm [m n]\n                (vec (for [i (range (inc m))]\n                       (if (= 0 i) (vec (range (inc n)))\n                                   (vec (cons i (repeat n 0)))))))\n        m (count s)\n        n (count t)\n        mx (loop [mx (initm m n)\n                  k 0]\n             (if (= k (* m n)) mx\n                               (let [i (inc (quot k n))\n                                     j (inc (rem k n))\n                                     t1 (get-in mx [(dec i) j])\n                                     t2 (get-in mx [i (dec j)])\n                                     t3 (get-in mx [(dec i) (dec j)])\n                                     c (if (= (get s (dec i)) (get t (dec j))) 0 1)\n                                     t (min (inc t1) (inc t2) (+ c t3))\n                                     mm (update-in mx [i j] (constantly t))]\n                                 (recur mm (inc k)))))]\n    (get-in mx [m n])))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 101, "code": "(fn n101\n  [a b]\n  (letfn [(cell [pre cur idx same?]\n            (min (inc (nth pre idx))\n                 (inc (last cur))\n                 (+ (nth pre (dec idx)) (if same? 0 1))))]\n    (loop [j 1\n           rows (inc (count b))\n           pre (range (inc (count a)))]\n      (if (= j rows)\n        (last pre)\n        (let [next-row (reduce (fn [cur i]\n                                 (let [same? (= (nth a (dec i)) (nth b (dec j)))]\n                                   (conj cur (cell pre cur i same?))))\n                               [j] (range 1 (count pre)))]\n          (recur (inc j) rows next-row))))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 101, "code": "(fn [s t]\n  (let [zero-row (range 0 (inc (count t)))\n        f-next-row (fn [d-row ss t] \n                     (reduce (fn [d-cur tmp-list] \n                               (let [d10 (last d-cur) [ts d00 d01] tmp-list cost (if (= ts ss) 0 1)]\n                                 (concat d-cur (list (min (inc d01) (inc d10) (+ d00 cost))))))\n                       (list (inc (first d-row))) (map list t (butlast d-row) (rest d-row))))\n        f-last-row (fn [s t] (reduce #(f-next-row %1 %2 t) zero-row s))]\n    (last (f-last-row s t))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 101, "code": "(fn[s t]\n        (let [lev\n              (memoize \n               (fn aux[rec s t]\n                 (cond\n                  (empty? s)\n                  (count t)\n                  \n                  (empty? t)\n                  (count s)\n                  \n                  :else\n                  (let [s' (butlast s)\n                        t' (butlast t)]\n                    \n                    (min (inc (rec rec s' t))\n                         (inc (rec rec s t'))\n                         (+ (rec rec s' t')\n                            (if (= (last s)\n                                   (last t))\n                              0 1)))))))\n\n              ;; rebind\n              lev (partial lev lev)]\n          (lev s t)))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 101, "code": "#(let [lv (fn lv [str1 str2 m n]\n                 (if (zero? m)\n                   n\n                   (if (zero? n)\n                     m\n                     (if (= (nth str1 (- m 1)) (nth str2 (- n 1)))\n                       (lv str1, str2, (dec m), (dec n))\n                       (+ 1 (min (lv str1, str2, m, (dec n))\n                              (lv str1, str2, (dec m), n)\n                              (lv str1, str2, (dec m), (dec n))))))))]\n     (lv %1 %2 (count %1) (count %2)))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 101, "code": "(fn lev [coll1 coll2] \n  (let [coll1 (vec coll1) coll2 (vec coll2)]\n    (cond\n      (empty? coll1) (count coll2)\n      (empty? coll2) (count coll1)\n      :else\n        (loop [matrix (vec (take (count coll1) (repeat (vec (take (count coll2) (repeat 0))))))\n              i 0 j 0]\n          (println matrix)\n          (cond \n            (= j (-> matrix first count)) (recur matrix (inc i) 0)\n            (= i (count matrix)) (-> matrix last last)\n            :else\n              (let [cost (if (= (get coll1 i) (get coll2 j)) 0 1)\n                    k [i j] deletion [(dec i) j] insertion [i (dec j)] sub [(dec i) (dec j)]]\n                (recur \n                    (assoc-in matrix k \n                      (min \n                        (inc (get-in matrix deletion (inc j)))\n                        (inc (get-in matrix insertion (inc i)))\n                        (+ (get-in matrix sub (max i j)) cost)\n                      )\n                    )\n                    i (inc j))\n              )          \n          )\n        )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 101, "code": "(fn levenshtein [s t]\n   (let [ns (inc (count s))\n         nt (inc (count t))\n         s-to-empty (into [] (map vector (range 0 ns)))\n         empty-to-t (assoc s-to-empty 0 (vec (range 0 nt)))\n         coords (for [j (range 1 nt), i (range 1 ns)] [j i])\n         distances\n           (reduce\n               (fn [distances [j i]]\n                 (println (get-in distances [(dec i) j]))\n                 (let [substition-cost (if (= (get s (dec i)) (get t (dec j))) 0 1)\n                       deletion-dist (+ 1 (get-in distances [(dec i) j]))\n                       insertion-dist (+ 1 (get-in distances [i (dec j)]))\n                       substition-dist (+ substition-cost (get-in distances [(dec i) (dec j)]))]\n                   (assoc-in distances [i j] (min deletion-dist insertion-dist substition-dist))))\n               empty-to-t\n               coords)]\n\n     (get-in distances [(dec ns) (dec nt)])))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 101, "code": "(fn levenshtein-distance [s t]\n               (if (= s t) 0\n                 (letfn [(f [s v0]\n                            (if (empty? s) (nth v0 (count t))\n                              (recur (rest s)\n                                     (loop [j 0, v1 [(inc (first v0))]]\n                                       (if (= j (count t)) v1\n                                         (recur (inc j)\n                                                (conj v1 (min (inc (nth v1 j))\n                                                              (inc (nth v0 (inc j)))\n                                                              (+ (nth v0 j)\n                                                                 (if (= (first s)\n                                                                        (nth t j))\n                                                                   0 1))))))))))]\n                   (f s (vec (range (inc (count t))))))))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "59358f74e4b04f87174def52"}, {"problem": 101, "code": "(letfn [(lev [mlev ss ts]\n          (cond\n            (empty? ss) (count ts)\n            (empty? ts) (count ss)\n            :else\n            (let [cost (if (= (first ss) (first ts)) 0 1)]\n              (min (inc (mlev mlev (rest ss) ts))\n                   (inc (mlev mlev ss (rest ts)))\n                   (+ cost (mlev mlev (rest ss) (rest ts)))))))]\n  (fn levenstein [s t]\n    (lev (memoize lev) (seq s) (seq t))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 101, "code": "(fn \n  [s1 s2]\n  (let [[mn mx] (sort #(< (count %1) (count %2)) [s1 s2])\n        cmn (count mn)\n        cmx (count mx)\n        trim-combs (fn trm\n              [s width]  \n              (if (< width 1)\n                '(())\n                (for [s (take (count s) (iterate rest s))\n                      y (trm (rest s) (dec width))]\n                       (cons (first s) y))))      \n        rank (fn [s1 s2]\n          (count (filter (partial apply =) (map list s1 s2))))]    \n    (cond \n      (zero? cmn) cmx\n      (= cmn cmx) (- cmx (rank s1 s2))\n      :else (- cmx\n              (reduce \n                #(max %1 (rank %2 mn)) \n                0 (trim-combs mx cmn))))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 101, "code": "; Source: http://rosettacode.org/wiki/Levenshtein_distance#Iterative_version\n\n(fn levenshtein [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char?\n                                                   0\n                                                   1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2           (nth w2 (dec row-idx))\n              next-prev-row (reduce (fn [cur-row i]\n                                      (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                        (conj cur-row (cell-value same-char?\n                                                                  prev-row\n                                                                  cur-row\n                                                                  i))))\n                                    [row-idx] (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows next-prev-row))))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 101, "code": "(fn [s t] \n          (let [\n                m (count s) n (count t)\n                mm (inc m) nn (inc n)\n                d (make-array Long/TYPE mm nn)\n                _ (dotimes [i mm] (aset d i 0 i)) \n                _ (dotimes [j nn] (aset d 0 j j)) \n                _ (dotimes [jj n] ;start from 1!!!\n                    (dotimes [ii m]\n                      (let [i (inc ii) j (inc jj)\n                            cost (if (= (nth s ii) (nth t jj) ) 0 1)\n                            xval (min (+ (aget d (dec i) j) 1 )\n                                      (+ (aget d i (dec j)) 1 )\n                                      (+ (aget d (dec i) (dec j)) cost )\n                                      )\n                            ](aset d i j xval))\n                                   )) \n                ]\n              (aget d m n)) )", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 101, "code": "(fn sol [s1 s2]\n  (letfn [\n          \n          (ldists [res1 col0 res v1 v2]\n    (loop [r1 res1\n           c0 col0\n           r  res\n           i  0\n           j  0   ]\n;    (do (println r1 r c0  i j (v1 i) (v2  j))\n           (cond (= j (dec (count r1)))\n                 (if  (= i (dec (count v1)))\n                      r\n                      (recur r c0  [(c0 (inc i))] (inc i) 0)\n                 )\n                 :else \n                    (let [nmin  (min  (inc  (last r)) (inc (r1 (inc j)))\n                                          (if (= (v1 i) (v2 j))\n                                               (r1 j)\n                                               (inc (r1  j))\n                                          )\n                                  )\n                          ]\n                          (recur r1 c0 (conj r nmin)\n                               i  (inc j) \n                          )\n                    ) \n           ) \n    )\n;)\n) \n\n          \n          ]\n    \n  (cond (= (count s1) 0) (count s2)\n        (= (count s2) 0) (count s1)\n        :else \n  (last (ldists (vec (range (+ 1 (count s2))))   \n                (vec (range 1 (inc (count s1))))\n                [1]\n                (vec s1) (vec s2)))\n   )\n    )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 101, "code": "(letfn [(levenstein [a b]                                                       \n          (eager-lev #{{:edits 0                                                \n                        :a (seq a)                                              \n                        :b (seq b)}}))                                          \n        (eager-lev [drafts]                                                     \n          (prn 'drafts drafts)                                                  \n          (let [closest (apply min-key :edits drafts)]                          \n            (prn 'closest closest)                                              \n            (if (= (:a closest) (:b closest))                                   \n              (:edits closest)                                                  \n              (let [attempt (update-in closest [:edits] inc)                    \n                    attempt (drop= attempt)]                                    \n                (prn 'attempt attempt)                                          \n                (-> drafts                                                      \n                    (conj (delete-item attempt)                                 \n                          (add-item attempt)                                    \n                          (change-item attempt))                                \n                    (disj closest nil)                                          \n                    (recur))))))                                                \n        (delete-item [draft]                                                    \n          (update-in draft [:a] rest))                                          \n        (add-item [draft]                                                       \n          (update-in draft [:a] conj (first (:b draft))))                       \n        (change-item [draft]                                                    \n          (-> draft                                                             \n              (update-in [:a] rest)                                             \n              (update-in [:b] rest)))                                           \n        (drop= [draft]                                                          \n          (if (not= (first (:a draft)) (first (:b draft)))                      \n            draft                                                               \n            (recur (change-item draft))))]                                      \n  levenstein)", "user": "51f9527fe4b09be9c177e549"}, {"problem": 101, "code": "(fn f [a b]\n    (cond\n      (empty? a) (count b)\n      (empty? b) (count a)\n      (= (first a) (first b)) (recur (rest a) (rest b))\n      :else (inc (min (f (rest a) b) (f a (rest b)) (f (rest a) (rest b))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 101, "code": "(fn [a b]\n    (let [e_d (fn edit_distance [memo n m]\n                (if (contains? memo [n m])\n                    [memo (get memo [n m])]\n                    (if (= 0 (min n m))\n                      [memo (max n m)]\n                      (let [n_minus_1 (- n 1)\n                            m_minus_1 (- m 1)\n                            [memo_1 d_1] (edit_distance memo n_minus_1 m)\n                            [memo_2 d_2] (edit_distance memo_1 n m_minus_1)\n                            [memo_3 d_3] (edit_distance memo_2 n_minus_1 m_minus_1)\n                            d (min (+ 1 d_1) (+ 1 d_2) (+ (if (= (get a n_minus_1) (get b m_minus_1)) 0 1) d_3))\n                            memo_4 (assoc memo_3 [n m] d)]\n                        [memo_4 d]))))]\n      (second (e_d {} (count a) (count b)))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 101, "code": "(fn [p q]\n  (let [x (vec p)\n        y (vec q)\n        lv (fn [fm la lb]\n             (cond\n               (zero? la) lb\n               (zero? lb) la\n               :else (min\n                       (inc (fm fm (dec la) lb))\n                       (inc (fm fm la (dec lb)))\n                       (+ (fm fm (dec la) (dec lb))\n                          (if (= (x (dec la)) (y (dec lb)))\n                            0\n                            1)))))]\n    (lv (memoize lv) (count x) (count y))))", "user": "580a0783e4b0a837a8b30d2c"}, {"problem": 101, "code": "(fn [x y]\n  (let [xys (for [i (range (inc (count x))) j (range (inc (count y)))] [(take i x) (take j y)])]\n    (loop [col xys acc {}]\n      (if-let [[x y :as xy] (first col)]\n        (let [lev (cond\n                    (= (count x) 0) (count y)\n                    (= (count y) 0) (count x)\n                    :else (min\n                            (+ (acc [(drop-last x) y]) 1)\n                            (+ (acc [x (drop-last y)]) 1)\n                            (+ (acc [(drop-last x) (drop-last y)]) (if (= (last x) (last y)) 0 1))))]\n\n          (recur (rest col) (assoc acc xy lev)))\n        (acc [(or (seq x) '()) (or (seq y) '())])))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 101, "code": "(fn levenshtein [s1 s2]\n  (loop [prev-row (into [] (range 0 (inc (count s2))))\n         current [1]]\n    (if (> (first current) (count s1))\n      (last prev-row)\n      (let [distance (fn [acc index]\n                       (let [i (dec index) \n                             j (dec (first acc))\n                             sub-cost (if (= (nth s2 i) (nth s1 j)) 0 1)]\n                         (conj acc (min (inc (last acc)) \n                                        (inc (nth prev-row index)) \n                                        (+ sub-cost (nth prev-row (dec index)))))))] \n        (recur (reduce distance current (range 1 (inc (count s2))))\n               [(inc (first current))])))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 101, "code": "(fn [s1 s2]\n  (let [[v1 v2] (mapv #(into [0] (vec %)) [s1 s2])\n        mij (fn [i j] (if (= (v1 i) (v2 j)) 0 1))\n        d (fn d [i j m]\n            (cond\n              (= 0 i j) [0 m]\n              (= 0 i) [j m]\n              (= 0 j) [i m]\n              (m [i j]) [(m [i j]) m]\n              :else (let [[r1 m1] (d i (dec j) m)\n                          [r2 m2] (d (dec i) j m1)\n                          [r3 m3] (d (dec i) (dec j) m2)\n                          r (min (inc r1) (inc r2) (+ r3 (mij i j)))]\n                      [r (assoc m3 [i j] r)])))]\n    (first (d (count s1) (count s2) {}))))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 101, "code": "(fn levenshtein [as bs]\n  (let [a (vec (seq as))\n        b (vec (seq bs))\n        indic (fn [i j] (if (= (a (dec i)) (b (dec j))) 0 1))\n        ld (fn ld [ld' i j] (if (= 0 (min i j))\n                            (max i j)\n                            (min (inc (ld' ld' (dec i) j))\n                                 (inc (ld' ld' i (dec j)))\n                                 (+ (indic i j) (ld' ld' (dec i) (dec j))))))\n        distance (let [d0 (memoize ld)] #(d0 d0 %1 %2))]\n      (distance (count a) (count b))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 101, "code": "(fn ld [s t]\n   (let [n (count s) m (count t) x (vec (range 0 (inc m)))]\n      (last (loop [i 1 y x] \n         (if (> i n) y\n            (recur (inc i) \n               (loop [j 1 z [i]]\n                  (if (> j m) z\n                     (let [cost (if (= (nth s (dec i)) (nth t (dec j))) 0 1)]\n                        (recur (inc j) (conj z (min (inc (nth y j)) (inc (nth z (dec j))) (+ cost (nth y (dec j)))))))))))))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 101, "code": "(fn levenshtein6 [s t]\n  (let [ls (count s) lt (count t)]\n    (letfn [(val [i j s t m]\n              (let [a (get m [(dec i) j])\n                    b (get m [i (dec j)])\n                    c (get m [(dec i) (dec j)])]\n                (if (= (nth s (dec i)) (nth t (dec j)))\n                  (min (inc a) (inc b) c)\n                  (min (inc a) (inc b) (inc c)))))]\n      (loop [i 0 j 0 m {}]\n        (cond\n          (> i ls) (get m [ls lt])\n          (and (zero? i) (= j lt)) (recur 1 0 (assoc m [i j] j))\n          (zero? j) (recur i 1 (assoc m [i j] i))\n          (zero? i) (recur i (inc j) (assoc m [i j] j))\n          (= j lt) (recur (inc i) 0 (assoc m [i j] (val i j s t m)))\n          :else (recur i (inc j) (assoc m [i j] (val i j s t m)))))))\n  )", "user": "5a621702e4b0512ff01cd983"}, {"problem": 101, "code": "(fn dist [a b]\n  (let [step (memoize\n            (fn [m-step i j]\n              (if (zero? (min i j)) \n                (max i j)\n                (min\n                  (+ (m-step m-step i(dec j)) 1)\n                  (+ (m-step m-step (dec i) j) 1)\n                  (+ (m-step m-step (dec i) (dec j)) (if (= (nth a (dec i)) (nth b (dec j))) 0 1))))))]\n    (step step (count a) (count b))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 101, "code": "(letfn [(levenshtein-fp\n         [fp x y]\n         (cond\n          (empty? x) (count y)\n          (empty? y) (count x)\n          :else (min (inc (fp fp (rest x) y))\n                     (inc (fp fp x (rest y)))\n                     (+ (if (= (first x) (first y)) 0 1)\n                        (fp fp (rest x) (rest y))))))\n\n        (memoize-recursive\n         [f]\n         (let [g (memoize f)] (partial g g)))]\n\n  (memoize-recursive levenshtein-fp))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 101, "code": "(fn edit-dist [a b]\n  (cond\n   (= a b) 0\n   (and (empty? a) (not (empty? b))) (count b)\n   (and (empty? b) (not (empty? a))) (count a)\n   :else (let [\n                initial-matrix (fn [a b]\n                                 (into (sorted-map)\n                                       (for [x (range (inc (count a)))\n                                             y (range (inc (count b)))]\n                                         (let [v\n                                               (cond\n                                                (= x 0) y\n                                                (= y 0) x\n                                                :else 0\n                                                )]\n                                           [[x y] v]\n                                           )\n                                         )\n                                       )\n                                 )\n                update-cell (fn [a b x y D]\n                              (let [substitution-cost (if (= (nth a (dec x)) (nth b (dec y))) 0 1)]\n                                (conj D [[x y] (min\n                                                (inc (D [(dec x) y]))\n                                                (inc (D [x (dec y)]))\n                                                (+ substitution-cost (D [(dec x) (dec y)]))\n                                                )] )\n                                )\n\n                              )\n                ]\n           (\n             (loop [x 1\n                    y 1\n                    D (initial-matrix a b)]\n               (let [nv (update-cell a b x y D)]\n                 (cond\n                  (and (= x (count a)) (= y (count b))) nv\n                  (= x (count a)) (recur 1 (inc y) nv)\n                  :else    (recur (inc x) y nv)\n                  )\n                 )\n               ) [(count a) (count b)]\n                 ))\n   )\n  )", "user": "5aba34c5e4b073f1774426a3"}, {"problem": 101, "code": "(memoize (fn lev [s1 s2]\n  (cond \n   (zero? (count s1)) (count s2)\n   (zero? (count s2)) (count s1)\n   (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n   :else (inc (min (lev (rest s1) s2)\n                   (lev s1 (rest s2))\n                   (lev (rest s1) (rest s2)))))))", "user": "57213df6e4b0c5bde472c0ab"}, {"problem": 101, "code": "(fn levenshtein-distance [s1 s2]\n  (letfn [(go [[xh & xt :as x] [yh & yt :as y]]\n            (cond\n              (empty? x) (count y)\n              (empty? y) (count x)\n              (= xh yh) (go xt yt)\n              :else (inc (min (go xt y) (go x yt) (go xt yt)))))]\n    (go s1 s2)))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 101, "code": "(fn [s t]\n  (let [lev (memoize\n              (fn [lev s t]\n                (cond\n                  (empty? s) (count t)\n                  (empty? t) (count s)\n                  :else (min (inc (lev lev (butlast s) t))\n                             (inc (lev lev s (butlast t)))\n                             (+ (lev lev (butlast s) (butlast t))\n                                (if (= (last s) (last t)) 0 1))))))\n        lev (partial lev lev)]\n    (lev s t)))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 101, "code": "(letfn [(dist [dist [c1 & r1 :as w1] [c2 & r2 :as w2]]\n  (cond (= w1 w2) 0\n        (empty? w1) (count w2)\n        (empty? w2) (count w1)\n        :else\n        (min (inc (dist dist w1 r2))\n             (inc (dist dist r1 w2))\n             ((if (= c1 c2) identity inc)\n              (dist dist r1 r2)))))]\n  (partial dist (memoize dist)))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 101, "code": "(fn [w1 w2] (let [l1 (count w1) l2 (count w2)] (loop [mx (->> l1 inc range (map (fn [i] (->> l2 inc range (map (fn [j] (cond (zero? i) j (zero? j) i :else 0))) (into [])))) (into [])) i 1 j 1] (if (> i l1) (last (last mx)) (recur (assoc mx i (assoc (mx i) j (min (inc ((mx i) (dec j))) (inc ((mx (dec i)) j)) (+ (if (= (nth w1 (dec i)) (nth w2 (dec j))) 0 1) ((mx (dec i)) (dec j)))))) (if (= j l2) (inc i) i) (if (= j l2) 1 (inc j)))))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 101, "code": "(fn __ [w1 w2]\n  (let [grid-w (inc (count w1))\n        grid-h (inc (count w2))\n        grid   (atom (vec (for [row (range grid-h)]\n                            (vec (for [chr (range grid-w)]\n                                   (cond (= row 0) chr\n                                         (= chr 0) row\n                                         :else     nil))))))]\n    (doseq [y (range 1 grid-h)\n            x (range 1 grid-w)]\n      (let [l1     (get w1 (dec x))\n            l2     (get w2 (dec y))\n            match? (= l1 l2)\n            left   (get-in @grid [y       (dec x)])\n            abov   (get-in @grid [(dec y) x])\n            ablf   (get-in @grid [(dec y) (dec x)])]\n        (reset! grid (assoc-in @grid [y x]\n                               (if match?\n                                 (min (inc left) (inc abov) ablf)\n                                 (min (inc left) (inc abov) (inc ablf)))))))\n    (get-in @grid [(count w2) (count w1)])))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 101, "code": "(let [dist (atom nil)\n      impl (fn [x y]\n             (let [dist @dist  ;; rebind to atom (which has memoized fn)\n                   cost (if (= (last x) (last y)) 0 1)]\n               (cond (empty? x)\n                     (count y)\n\n                     (empty? y)\n                     (count x)\n\n                     :else\n                     (min (+ (dist (butlast x) y) 1)\n                          (+ (dist x (butlast y)) 1)\n                          (+ (dist (butlast x)\n                                   (butlast y)) cost)))))]\n  \n  (reset! dist (memoize impl))\n  @dist)", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 101, "code": "(fn [s t]\n  (let [f (fn [[r i]]\n            [r (get t i)]\n            (loop [res [(inc i)] ss s j 0]\n              (if (empty? ss)\n                [res (inc i)]\n                (let [a (inc (last res))\n                      b (inc (get r (inc j)))\n                      c (if (= (get s j) (get t i))\n                          (get r j)\n                          (inc (get r j)))]\n                  (recur\n                    (conj res (min a b c))\n                    (rest ss)\n                    (inc j))))))]\n    (->>\n      (iterate f [(vec (range (inc (count s)))) 0])\n      (take (inc (count t)))\n      (last)\n      (first)\n      (last))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 101, "code": "(fn lcs [[x-h & x-t :as x]\n           [y-h & y-t :as y]]\n (cond\n  (empty? x) (count y)\n  (empty? y) (count x)\n  (= x-h y-h) (lcs x-t y-t)\n  :else (+ 1 (min (lcs x y-t) (lcs x-t y) (lcs x-t y-t)))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 101, "code": "(fn ld [a b]\n  (let [mem (atom {})]\n    (letfn [(ldv [a b]\n              (if-let [e (find @mem [a b])]\n                (val e)\n                (let [ret\n                      ;;(println [:ldv a b])\n                      (cond (= a b) 0\n                            (empty? a) (count b)\n                            (empty? b) (count a)\n                            (= (subvec a 0 1) (subvec b 0 1)) (ldv (subvec a 1) (subvec b 1))\n                            :else\n                            (min (inc (ldv (subvec a 1) b))\n                                 (inc (ldv a (subvec b 1)))\n                                 (inc (ldv (vec (concat (subvec b 0 1) (subvec a 1))) b))))]\n                  (swap! mem assoc [a b] ret)\n                  ret)))]\n      (ldv (vec a) (vec b)))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 101, "code": "(fn lev [s1 s2] (let [l1 (seq s1) l2 (seq s2)] ( (reduce (fn [m i] (reduce (fn [n j] (if (= -1 i) (assoc n [i j] (inc j)) (if (= -1 j) (assoc n [i j] (inc i)) (if (= (nth l1 i) (nth l2 j)) (assoc n [i j] (min (n [(dec i) (dec j)]) (inc (n [(dec i) j])) (inc (n [i (dec j)])))) (assoc n [i j] (min (inc (n [(dec i) (dec j)])) (inc (n [(dec i) j])) (inc (n [i (dec j)])))))))) m (range -1 (count l2)))) {} (range -1 (count l1))) [(dec (count l1)) (dec (count l2))] )))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 101, "code": "(fn levenshtein [s t]\n  (let [m (count s)\n        n (count t)\n        d (->> (repeat (inc n) 0)\n               (vec)\n               (iterate #(update-in % [0] inc))\n               (take (inc m))\n               (vec)\n               (#(assoc % 0 (vec (range (inc n))))))]\n    (get-in\n     (reduce\n      (fn [d [i j]]\n        (assoc-in d [i j] (min (inc (get-in d [(dec i) j]))\n                               (inc (get-in d [i (dec j)]))\n                               (+ (get-in d [(dec i) (dec j)])\n                                  (if (= (get s (dec i)) (get t (dec j))) 0 1)))))\n      d\n      (for [j (range 1 (inc n))\n            i (range 1 (inc m))]\n        [i j]))\n     [m n])))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 101, "code": "(fn [sx sy]\n  (let [vx (vec sx) vy (vec sy) nx (count vx) ny (count vy) n (max nx ny)\n        binds (set (mapcat (fn [x] (map (fn [y] [x y])\n                                        (filter #(= (nth vx x) (nth vy %))\n                                                (range ny))))\n                           (range nx)))\n        maxbind (fn maxbind [[x y] parent-binds]\n                  (let [rx (- nx x) ry (- ny y) diff (- rx ry) maxd (max diff 0) mind (min diff 0)\n                        my-binds (filter (fn [[bx by]] (and (> bx x)\n                                                            (> by y)\n                                                            (let [d (- bx by)]\n                                                              (and (<= d maxd) (>= d mind)))))\n                                         parent-binds)]\n                    (reduce max 0 (map #(inc (maxbind % my-binds)) my-binds))))]\n    (- n (maxbind [-1 -1] binds))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 101, "code": "(fn ld [[xh & xt :as x]\n        [yh & yt :as y]]\n (cond\n  (empty? x) (count y)\n  (empty? y) (count x)\n  (= xh yh) (ld xt yt)\n  :else (+ 1 (min (ld x yt) (ld xt y) (ld xt yt)))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 101, "code": "(fn [s1 s2]\n    (letfn [(g [f s1 s2]\n              (cond (= (count s1) 0) (count s2)\n                    (= (count s2) 0) (count s1)\n                    (= s1 s2) 0\n                    :else\n                    (min (inc (f f s1 (rest s2)))\n                         (+ (f f (rest s1) (rest s2))\n                            (if (= (first s1) (first s2)) 0 1))\n                         (inc (f f (rest s1) s2)))))]\n      (g (memoize g) (seq s1) (seq s2))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 101, "code": "(let [levenshtein-cache (ref {})]\n    (letfn [(levenshtein [s t]\n              (let [key [s t]]\n                (if (contains? @levenshtein-cache key)\n                  (get @levenshtein-cache key)\n                  (calculate-levenshtein s t))))\n            (calculate-levenshtein [s t]\n              (cond\n               ;; base case: empty sequences\n               (zero? (count s)) (count t)\n               (zero? (count t)) (count s)\n\n               :else\n               (let [result\n                     ;; return minimum of delete char from s, delete char from\n                     ;; t, and delete char from both\n                     (min (inc (levenshtein (rest s) t))\n                          (inc (levenshtein s (rest t)))\n                          (+ (if (= (first s) (first t))\n                               ;; test if first characters of the strings match\n                               0\n                               1)\n                             (levenshtein (rest s) (rest t))))]\n                 (dosync (alter levenshtein-cache assoc [s t] result))\n                 result)))]\n      (fn [s t] (levenshtein (seq s) (seq t)))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 101, "code": "(fn lev-dist [a b]\n  (letfn [(iter [prev letter]\n            (loop [i 1\n                   res [(inc (first prev))]]\n              (if (>= i (count prev))\n                res\n                (recur (inc i)\n                       (conj res\n                             (min\n                               (inc (prev i))\n                               (inc (last res))\n                               (+ (prev (- i 1) ) (if (= letter (nth a (dec i))) 0 1))))))))]\n    (->> b\n         (reduce iter (vec (range 0 (inc (count a)))))\n         (last))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 101, "code": "(fn levenshtein-distance\n  [a b]\n  (let [[x y] (sort-by count [a b])\n        diff (- (count y) (count x))\n        add-char (fn [combination pos]\n                   (concat (take pos combination) [(nth y pos)] (take-last (- (count combination) pos) combination)))\n        possible-combinations (fn possible-combinations\n                                [diff current-combinations]\n                                (if (= 0 diff)\n                                  current-combinations\n                                  (->> current-combinations\n                                       (mapcat #(map (partial add-char %) (range (count y))))\n                                       (possible-combinations (dec diff)))))\n        closest-match (fn [possible-combinations]\n                        (->> possible-combinations\n                             (map #(count (filter (fn [n] (not= (nth % n) (nth y n))) (range (count %)))))))]\n    (->> (possible-combinations diff #{x})\n         closest-match\n         (apply min)\n         (+ diff))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 101, "code": "(fn lev-recur [s1 s2]\n    (let [recur-fn (fn [fun s t]\n                     (cond\n                       (empty? s) (count t)\n                       (empty? t) (count s)\n                       (apply = (map last [s t])) (fun fun (butlast s) (butlast t))\n                       :else (inc (min\n                                    (fun fun (butlast s) t)\n                                    (fun fun s (butlast t))\n                                    (fun fun (butlast s) (butlast t))))))\n          mfn (memoize recur-fn)]\n      (mfn mfn s1 s2)))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 101, "code": "(fn lev [[a & ar :as as] [b & br :as bs]]\n  (cond\n    (nil? a) (count bs)\n    (nil? b) (count as)\n    (= a b) (lev ar br)\n    0 (inc (min (lev as br) (lev ar bs) (lev ar br)))))", "user": "5bbf0a02e4b07a9b28b0ffcf"}, {"problem": 101, "code": "(fn levensh [from target]\n    (if (= from target) ;the below doesn't handle it. Too much work to refactor now.\n       0\n       (let [from (vec from) ;from string to a seq.\n             target (vec target)\n             num-of-generations (atom 0)\n             item-type nil #_clojure.lang.Keyword #_java.lang.Long #_java.lang.Character ;if item-type is nil, then don't validate items\n             conj (if\n                     (or\n                         (> (:major *clojure-version*) 1)\n                         (> (:minor *clojure-version*) 4))\n                     clojure.core/conj\n                     (fn conj-compat\n                       ([coll] coll)\n                       ([coll & entries]\n                        (apply clojure.core/conj coll entries))))]\n         (letfn\n           [\n            (validate-items\n              ([candidate msg]\n               (validate-items candidate msg true))\n              ([candidate msg do-fail] ;do-fail is to allow/supress assert, because a failed assert discards recent output\n               (if item-type\n                 (count\n                   (for [i candidate]\n                     (do\n                       (if (not (instance? item-type i))\n                         (do\n                           (println \"Candidate\" msg candidate \"has item\" i \"which is\" (type i))\n                           (flush)))\n                       (if do-fail\n                          (assert (instance? item-type i)\n                                  (str \"Candidate \" candidate \" when \" msg \" expected it to be \" item-type \" but it is \" (type i) \": \" i)))))))\n               candidate))\n            \n            ;generate a seq of [candidate num-of-changes] with one-step changes ahead\n            (next-candidates [[prev-candidate prev-num-of-changes]]\n              (assert (not= prev-candidate target) \"Reached already - should have been handled already\")\n              (validate-items prev-candidate \"next-candidates->start\")\n              (assert (number? prev-num-of-changes) (str \"Actual type\" (type prev-num-of-changes) prev-num-of-changes))\n              (let [prefix (vec (for [pair-of-items (map vector prev-candidate target) ;prefix is a shared initial part of: prev-candidate and target\n                                      :while (= (first pair-of-items) (second pair-of-items))]\n                                   (#_dbg #_:first_pair-of-chars first pair-of-items)))]\n                #_TODO-for-end-of-prefix-onwards_change-each-index\n                #_TODO-merge-two-let\n                #_(println \"Prev. candidate\" prev-candidate \"-> prefix\" prefix)\n                (let [prev-count (count prev-candidate)\n                      target-count (count target)\n                      prefix-count (count prefix)\n                      next-num-of-changes (inc prev-num-of-changes)]\n                  (validate-items prefix \"prefix\")\n                  ; Here it used to add a character only if prev-candidate was of same length or shorter than target, and\n                  ; remove a character only if prev-candidate was of same length or longer than target. However,\n                  ; while that \"heuristics\" would accelerate most situations, it would prevent the best solutions\n                  ; in \"lookeahead\" situations that require removal of character(s) even if the candidate is shorter, or\n                  ; addition of character(s) if the candidate is longer, if more than a half of the rest of the candidate\n                  ; matches target (and hence it overcompensates what first looks like a loss).\n                  (#_dbg #_\"str -> into [] with prefix\" into\n                    ; if a change reverts a previous change, we still count both changes. Such paths get eliminated by rating and by past-candidate-to-num.\n                    (into () ;merge any possible & worthwhile candidates (1, 2 or 3) out of the following 3:\n                      (if (< prefix-count target-count) ;otherwise we only need to remove the extra(s)\n                        [[(validate-items (apply conj prefix\n                                            (#_dbg #_\"nth inc prefix-count1\" nth target prefix-count) ;add 1 char; TODO revert from (nth) to (get) to trigger an error with string, where (println...) disappeared\n                                            (drop      prefix-count  prev-candidate))\n                            (str \"add 1 char to \" prefix \" at target pos. \" prefix-count \" from target \" target)) ;keep the rest\n                          next-num-of-changes]\n                         [(validate-items (apply conj prefix\n                                            (#_dbg #_\"nth inc prefix-count2\" nth target prefix-count) ;replace 1 char\n                                            (drop (inc prefix-count) prev-candidate))\n                            \"replace 1 char\")\n                          next-num-of-changes]] ;adjust the rest by 1 char\n                        []))\n                    (if (< prefix-count prev-count)\n                      [[(validate-items (apply conj prefix\n                                          (drop (inc prefix-count) prev-candidate))\n                          \"remove 1 char\")\n                        next-num-of-changes]] ;remove 1 char\n                      [])))))\n            \n            ;toolkit on pairs/colls of [candidate num-of-changes]\n            (compare-ignoring-effort [[cand1 _] [cand2 _]]\n              (compare cand1 cand2))\n            \n            (diff [cand] ;number of differences in naive comparison char by char (as if we allowed char replacements only), plus a difference in length\n              (apply +\n                (int (Math/abs (- (count target) (count cand))))\n                (map\n                  #(if (= %1 %2) 1 0)\n                  cand target)))\n            \n            (rate [[candidate num-changes]]\n              (+ (diff candidate)\n                 num-changes))\n            \n            (compare-full [[cand1 num-ch1 :as pair1] [cand2 num-ch2 :as pair2]]\n              (validate-items cand1 \"comp-full1\") (validate-items cand2 \"comp-full2\")\n              (let [likeness-and-effort (compare (rate pair1) (rate pair2))]\n                (if (zero? likeness-and-effort)\n                  (compare cand1 cand2) ;this ensures we keep all candidates, including ones with same ranking, because their future may vary\n                  likeness-and-effort)))\n            ;TODO to dbg doc: \n            ; 1. (dbgs :user-provided) ensures that, after debugging that line, once you remove dbgf or dbg, you won't leave this scope indicator forgotten \n            ;---- During a call to (dbgf ..) or (dbg ..) at a higher level, that macro generates (let []) with its \"scope consuming\" symbol.\n            ; --- At this (lower) level, (dbgs ..) macro uses &env to detect whether that scope was \"consumed\" already. If so, fail (at macro level) -> compile time.\n            ; ------but: (dbgs ...) generates a compile time list. Hence (dbgf ...) and (dbg ...) would have to inspect it, so to determine if it's a user-provided function-generating form.\n            ; ------- or: dbgf and dbg accept a 2nd param, *required*, a symbol, but then it'd need to check at *runtime*!\n            ; ------- or: 2nd param only a string literal, not a keyword literal. If the user leaves it behind, it fails (can't be cast ot IFn). \n            ; 2. scope for lazy seq ->vvv\n            (next-generation [previous-generation] ; Parameter and result are of type: coll of [candidate num-of-changes]\n              (identity ;to set the upper scope for dbgf of lazy seq.\n                (for [pair (validate-queue previous-generation)\n                      next-pair (next-candidates pair)]\n                  next-pair)))\n            ;----if slow, transform somehow into a lazy seq.\n            \n            (validate-queue [pairs]\n              (count ;to consume the lazy sequence\n                (for [[cand num] pairs]\n                  (do\n                    (validate-items cand \"valid-queue\")\n                    (assert (number? num)))))\n              pairs)]\n           \n           ; heuristics: wide-deep combination: Give more chance to the most promising candidates.\n           ; But occasionally progress others, too, because one step can move a candidate ahead (much closer to the result).\n           ; Sort candidates.\n           ; Split candidates (e.g. by a certain limit) into priority & backlog.\n           ; Iterate priority. Split the result. The rest of candidates goes to the backlog.\n           ; Repeat a few times.\n           ; Iterate both priority & backlog, merge, split.\n           ; Once you find one result, remove all candidates that would take same number of steps or more.\n           ; Repeat until all candidates reach (and obviously have same number of steps).\n           \n           (loop [priority (sorted-set-by compare-full [from 0])\n                  backlog (sorted-set-by compare-full)\n                  best-num-changes nil\n                  ;past-candidate-pairs (sorted-set-by compare-full) ;;set of [candidate num-changes] that were/are being already handled (i.e. in priority, backlog or thrown away)\n                  past-candidate-to-num {from 0}] \n             ;best-num-changes is non-nil only once we have (any) results\n             (assert (set? priority))\n             (assert (set? backlog))\n             (#_dbgf #_\"validate priority\" validate-queue priority)\n             (#_dbgf #_\"validate priority\" validate-queue backlog)\n             (if (and (= (count priority) 1) (empty? backlog) #_not-nil best-num-changes)\n               (second (first priority)) ;this was supposed to be the (one) best result, but (at least for \"kitten\" -> \"sitting\" it wasn't reached!\n               (if (and (seq backlog) (< (/ (count priority) (count backlog) 0.50#_(tried 0.05, 0.30, 0.5)))) ;priority below a threshold, and backlog is non-empty => merge\n                 (recur (into priority backlog) (empty backlog) best-num-changes past-candidate-to-num) ;<<<\n                 (let [priority-moved-unfiltered (into (#_dbg #_\"empty priority\" empty priority)\n                                                   (next-generation priority))\n                       _ (validate-queue priority-moved-unfiltered)\n                       \n                       ;Collect two structures: a map and a set, both based on priority-moved-unfiltered and past-candidate-to-num.\n                       ;map candidate => num-changes, based on a subset of priority-moved-unfiltered.\n                       ;They were handled in the past, now found with the same or higher num-changes.\n                       [priority-moved-past-same-or-worse-map\n                        ;a subset of priority-moved-unfiltered. [cand num] that were handled in the past, now with more num-changes.\n                        priority-moved-past-better]\n                       (reduce\n                         (fn [[worse better] [cand num :as new-pair]]\n                           (validate-items cand \"unfiltered->reduce\")\n                           (let [past-num (past-candidate-to-num cand)]\n                             (if past-num\n                               (if (<= past-num num)\n                                 [(assoc worse cand num)\n                                  better]\n                                 [worse\n                                  (conj better new-pair)])\n                               [worse better])))\n                         [{} (empty priority)]\n                         priority-moved-unfiltered)\n                       _ (validate-queue priority-moved-past-better)\n                       \n                       priority-moved-excluding-worse\n                       (filter\n                         (fn [[cand num]]\n                           (validate-items cand \"excl.worse\")\n                           (not (contains? priority-moved-past-same-or-worse-map cand)))\n                         priority-moved-unfiltered)\n                       _ (validate-queue priority-moved-excluding-worse)\n                       \n                       priority-moved\n                       (apply conj\n                         ;(re)inject any options that now look better. Being sets, conj keeps the items from the 1st set.\n                         ;Hence the \"better\" set is the first param.\n                         priority-moved-past-better\n                         priority-moved-excluding-worse)\n                       \n                       past-candidate-to-num-next\n                       (apply assoc\n                         past-candidate-to-num\n                         (for [ [cand num] priority-moved\n                               key-or-value [cand num]]\n                           (do\n                             (validate-items cand \"past-t-num\")\n                             (assert (number? num))\n                             key-or-value)))\n                       \n                       _ (validate-queue priority-moved)\n                       priority-moved-results (filter\n                                                (fn [[cand _num]]\n                                                  (validate-items cand \"->prior.moved res.\")\n                                                  (assert (number? _num))\n                                                  (= cand target))\n                                                priority-moved)\n                       _ (validate-queue priority-moved-results)\n                       \n                       priority-moved-best-num-changes\n                       (if (seq priority-moved-results)\n                         (apply min\n                           (map\n                             (fn [[_cand num-changes]]\n                               (validate-items _cand \"->best num ch.\")\n                               (assert (number? num-changes))\n                               num-changes)\n                             priority-moved-results))\n                         nil)\n                       best-num (if best-num-changes\n                                  (if priority-moved-best-num-changes\n                                    (min best-num-changes priority-moved-best-num-changes)\n                                    best-num-changes)\n                                  priority-moved-best-num-changes)\n                       \n                       ;_ (dbg-pprint-last \"priority-moved\" priority-moved) _ (println)\n                       \n                       priority-moved-unreached (apply disj priority-moved priority-moved-results)\n                       _ (validate-queue priority-moved-unreached)\n                       candidates-to-keep (fn [candidates]\n                                            (if best-num\n                                              (into (empty priority)\n                                                (filter (fn [[_cand num-changes]]\n                                                          (validate-items _cand \"->to keep\")\n                                                          (< num-changes best-num))\n                                                  candidates))\n                                              candidates))\n                       priority-keep   (candidates-to-keep priority-moved-unreached)\n                       _ (validate-queue priority-keep)\n                       backlog-keep (candidates-to-keep backlog)\n                       _ (validate-queue backlog-keep)]\n                   #_TODO-merge-previous-and-following-let\n                   (let [priority-next-count (Math/ceil #_int (* (count priority-keep) 0.30 #_(tried 0.02, 0.03, 0.10, 0.30 with num-of-gen. limit 100)))\n                         priority-next (into (empty priority) (take priority-next-count priority-keep))\n                         _ (validate-queue priority-next)\n                         backlog-next  (into backlog-keep (drop priority-next-count priority-keep))\n                         _ (validate-queue backlog-next)]\n                     (if (and (empty? priority-keep) (empty? backlog-keep))\n                       best-num #_emptied_all_options\n                       (if (< @num-of-generations 350 #_250 #__400-too-much) ;limit number of generations - worthwhile for debugging\n                         (do\n                           (swap! num-of-generations inc)\n                           (recur priority-next backlog-next best-num past-candidate-to-num-next))\n                         :over-limit)))))))))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 101, "code": "(memoize\n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 101, "code": "(fn lev-dist\n  ([s t a]\n   (let [key (into #{} [s t])\n         cached (get @a key)]\n     (or\n       cached\n       (let [count-s (count s)\n             count-t (count t)\n             dist (if (zero? (min count-s count-t))\n                    (max count-s count-t)\n                    (let [trunc-s (drop-last s)\n                          trunc-t (drop-last t)\n                          cost (if (= (last s) (last t)) 0 1)]\n                      (min (inc (lev-dist trunc-s t a))\n                           (inc (lev-dist s trunc-t a))\n                           (+ (lev-dist trunc-s trunc-t a) cost))))]\n         (get (swap! a assoc key dist) key)))))\n  ([s t]\n   (lev-dist s t (atom {}))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 101, "code": "(fn __\n  ([src dest]\n   (let [max (+ (count src)\n                (count dest))]\n     (- max (__ (seq src) (seq dest) max))))\n  ([ss ds trans] ; return the minimum number\n   (cond\n    (= ss ds) trans\n    (empty? ss) (- trans (count ds))\n    (empty? ds) (- trans (count ss))\n    (zero? trans) -1\n    (= (first ss) (first ds))  (__ (rest ss) (rest ds) trans)\n    :else\n    (max (__ ss (rest ds) (dec trans))\n         (__ (rest ss) ds (dec trans))\n         (__ (rest ss) (rest ds) (dec trans))))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 101, "code": "(fn [x y]\n  (let [sx (vec x) sy (vec y) cx (count sx) cy (count sy)]\n    (loop [init [(vec (range (inc cy)))] vx 1]\n      \t(if (> vx cx) ((init (dec vx)) cy)\n          (recur  \n            \t  (conj init (vec\n                   (reduce\n\t\t    (fn [a b]\n                    (if\n                          (= (sx (dec vx)) (sy (dec b))) (conj a ((init (dec vx)) (dec b)))\n                      (conj a  (inc (min\n                            ((init (dec vx)) (dec b))\n                            ((init (dec vx)) b)\n                            (peek a)\n                           )))\n                     )) [vx] (range 1 (inc cy))      \n                   )\n                 ))\n           \t\t\t(inc vx))\n        )\n      )\n   )\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 101, "code": "(fn  [w1 w2]\n  (let [cw1 (count w1)\n        cw2 (count w2)\n        sw (if (<= cw1 cw2) w1 w2)\n        lw (if (> cw1 cw2) w1 w2)\n        pad_pos (fn pad_pos [x y]  ;; 5 8\n                  (let [b (if (<= x y) y x)\n                        s (if (> x y) y x)\n                        n (- b s)\n                        r1 (map vector (range (+ (- b n) 1)))]\n                    (cond (= x y) nil\n                          (= n 1) r1\n                          :default (let  [  f1 (fn [x b]\n                                                 (if (>= (last x) (- b 1))\n                                                   (list x)\n                                                   (map #(conj x %) (range (+ (last x) 1) b))))\n                                          f2 (fn f2 [c r b]\n                                               (if (= c 1)\n                                                 (filter #(= (count %) n) r)\n                                                 (recur (dec c)(reduce  #(concat % %2)(map #(f1 % b) r)) b)))]\n                                     (f2 n r1 b)))))\n        pos_l (pad_pos (count sw) (count lw))\n        add_pad (fn add_pad [x pos]\n                  (let [c (+ (count x)(count pos))\n                        ps (set pos)\n                        vs (set (range c))\n                        diff (sort (clojure.set/difference vs ps))\n                        rv (into [] (repeat c \" \")) \n                        diff_m (apply hash-map (flatten (map #(list % %2) diff x)))]\n                    (keep-indexed #(if (diff_m %) (diff_m %) %2) rv)))\n        paded_word (if (= cw1 cw2)\n                     (list sw)\n                     (map #(add_pad sw %) pos_l))\n        match_point (fn [w1 w2] (apply + (map #(if (= % %2) 1 0) w1 w2)))\n        ]\n     (- (count lw) (apply max (map #(match_point % w2) paded_word)))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 101, "code": "(fn lev [s t] (letfn [\n\t(f [acc [a b :as key]] (assoc acc key (let [i (count a) j (count b) m (min i j)] (if (= m 0) (max i j) (min \n\t\t(+ (acc [(vec (butlast a)) b]) 1)\n\t\t(+ (acc [a (vec (butlast b))]) 1)\n\t\t(+ (acc [(vec (butlast a)) (vec (butlast b))]) ({true 0 false 1}(= (last a) (last b))))\n\t\t)))))]\n((reduce f {} (for [a (reductions conj [] s)\n\t\t\t\t   b (reductions conj [] t)] [a b])) [(vec s) (vec t)])))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 101, "code": "(fn lev [s t]\n  (cond\n   (empty? s) (count t)\n   (empty? t) (count s)\n   :else (let [ns (rest s)\n               nt (rest t)]\n           (if (= (first s) (first t))\n             (lev ns nt)\n             (min\n              (inc (lev s nt))\n              (inc (lev ns t))\n              (inc (lev ns nt)))))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 101, "code": "(fn lev_dis [w1 w2]    \n  (letfn [(inner [e1 e2 length]    \n    (cond (> (count e1) (count e2))         (recur e2 e1 length)    \n          (zero? (count e1))                (+ (count e2) length)    \n          (= (first e1) (first e2))         (recur (rest e1) (rest e2) length)    \n          (= (last e1) (last e2))           (recur (butlast e1) (butlast e2) length)    \n          :else (recur (rest e1) (rest e2) (inc length))))]                       \n    (inner w1 w2 0)))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 101, "code": "(fn ld [a b] (cond\n                   (empty? a) (count b)\n                   (empty? b) (count a)\n                   (= (first a) (first b)) (ld (rest a) (rest b))\n                   :defualt\n                   (+ 1 (min\n                        (ld (rest a) (rest b))\n                        (ld (rest a) b)\n                        (ld a (rest b))))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 101, "code": "(fn lv [s1 s2]\n  (let [w1 (cons 0 s1) w2 (cons 0 s2) l1 (count w1) l2 (count w2)]\n   (if (or (= 1 l1) (= 1 l2)) (dec (max l1 l2))\n    (loop [a (vec (range l1))]\n      (let [i (mod (count a) l1) j (quot (count a) l1) p (+ i (* l1 j)) subcost (if (= (nth w1 i) (nth w2 j)) 0 1)]\n        (if (zero? i) \n          (recur (conj a j))\n          (let [x (min (inc (nth a (dec p))) (inc (nth a (- p l1))) (+ (nth a (- p l1 1)) subcost))]\n            (if (= p (dec (* l1 l2)))\n              x\n              (recur (conj a x))))))))))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 101, "code": "(fn levenshtein-distance\n  [s t]\n  (let [s-count (count s)\n        t-count (count t)\n\n        empty-matrix\n        (repeat t-count\n                (repeat s-count 0))\n\n        prepared-matrix\n        (vec (cons (vec (range 0 (inc s-count)))\n                   (mapv (fn [row n] (vec (cons n row))) empty-matrix (range 1 (inc t-count)))))\n\n        build-m\n        (atom prepared-matrix)]\n    (doall\n     (for [i (range 1 (inc t-count)) j (range 1 (inc s-count))]\n       (let [subs-cost\n             (if (= (get-in s [(dec j)]) (get-in t [(dec i)]))  ;;swap\n               0\n               1)\n\n             del-val (inc (get-in @build-m [(dec i) j]))\n             ins-val (inc (get-in @build-m [i (dec j)]))\n             sub-val (+ subs-cost (get-in @build-m [(dec i) (dec j)]))]\n         \n         (swap! build-m\n                assoc-in\n                [i j]\n                (min del-val ins-val sub-val)))))\n\n    (get-in @build-m [t-count s-count])))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 101, "code": "(fn [a b]\n   (loop [prev-row (range (inc (count a)))]\n     (if (= (count b) (first prev-row))\n       (last prev-row)\n       (let [row-num (inc (first prev-row))\n             next-row (loop [next-row [row-num] i 1]\n                        (if-not (<= i (count a))\n                          next-row\n                          (let [substitution-cost (if (= (nth b (dec row-num))\n                                                         (nth a (dec i)))\n                                                    0 1)\n                                next-val (min (inc (last next-row))                          ;deletion\n                                              (inc (nth prev-row i))                         ;insertion\n                                              (+ (nth prev-row (dec i)) substitution-cost))] ;substitution\n                            (recur (conj next-row next-val) (inc i)))))]\n         (recur next-row)))))", "user": "57635e2de4b0994c1922fbbf"}, {"problem": 101, "code": "(memoize (fn dist [a b] (cond (-> a seq not) (count b)  \n                     (-> b seq not) (count a)  \n                     (= (first a) (first b)) (dist (rest a) (rest b)) \n                     true (+ 1 (min (dist a (rest b)) \n                                    (dist (rest a) b) \n                                    (dist (rest a) (rest b)))))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 101, "code": "(memoize (fn l [[a & b :as f] [i & j :as k]]\n           (cond\n             (empty? k) (count f)\n             (empty? f) (count k)\n             (= a i) (l b j)\n             \\t (+ 1 (min (l b k) (l j f) (l b j))))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 101, "code": "(fn levenshtein-distance [a b]\n  (let [increasing-ranges (fn increasing-ranges [n k] \n                            (if (= 1 k)\n                              (map list (range n))\n                              (->> (range n)\n                                   (map (fn [i] \n                                          (->> (increasing-ranges (- n i 1) (dec k))\n                                               (map (comp (partial cons i) \n                                                          (partial map (partial + i 1))))))) \n                                               \n                                   (apply concat))))\n        projections (fn [coll n]\n                      (map (partial map (partial nth coll)) \n                           (increasing-ranges (count coll) n)))\n        max-coll (max-key count a b)\n        min-coll (if (= max-coll a) b a)\n        distance (fn [c d] \n                   (->> (map vector c d)\n                        (filter (partial apply not=))\n                        count))\n        distances (map distance \n                       (projections max-coll (count min-coll)) \n                       (repeat min-coll))]\n    (+ (- (count max-coll) (count min-coll)) \n       (apply min (if-not (empty? distances) distances [0])))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 101, "code": "(fn [wa wb]\n\n   (let [lines\n         (->\n          (map\n           (fn [a]\n             (->>\n              (map\n               (fn [b]\n                 (if (= a b)\n                   0\n                   1))\n               (cons :a wb))\n              vec\n              transient))\n           (cons :a wa))\n          vec\n          transient)]\n     (doseq\n         [x (range 0 (inc (count wa)))]\n       (assoc!\n        (get lines x)\n        0\n        x))\n\n     (doseq\n         [y (range 0 (inc (count wb)))]\n       (assoc!\n        (get lines 0)\n        y\n        y))\n\n     (doseq\n         [x (range 1 (inc (count wa)))\n          y (range 1 (inc (count wb)))]\n       (let [cl (get lines x)\n             prel\n             (-> lines\n                 (get (dec x))\n                 (get y))\n             prec (get cl (dec y))\n             cur (get cl y)\n             diag\n             (-> lines\n                 (get (dec x))\n                 (get (dec y)))]\n         (assoc! cl y\n                 (min\n                  (inc prel)\n                  (inc prec)\n                  (+ diag cur)\n                  ))))\n     (->> lines\n          persistent!\n          (map persistent!)\n          last\n          last)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 101, "code": "(fn __ [s1 s2]\n  (let [s1c (count s1)\n        s2c (count s2)]\n    (-> (for [j (range 1 (inc s2c))\n              i (range 1 (inc s1c))]\n          [i j])\n        (->>\n         (reduce\n          (fn [d [i j]]\n            (let [sub-cost (if (= (nth s1 (dec i))\n                                  (nth s2 (dec j)))\n                             0 1)]\n              (assoc-in d\n                        [i j]\n                        (min (inc (get-in d [(dec i) j]))\n                             (inc (get-in d [i (dec j)]))\n                             (+ sub-cost\n                                (get-in d [(dec i) (dec j)]))))))\n          (into []\n                (for [i (range (inc s1c))]\n                  (into [i]\n                        (if (= 0 i)\n                          (range (inc i) (inc s2c))\n                          (repeat s2c 0)))))))\n        (get-in [s1c s2c]))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 101, "code": "(fn [patt1 patt2]\n  (letfn [(nextrow[ch patt row]\n            (loop [i 1\n                   next [(inc (first row))]]\n              (if (> i (count patt))\n                next\n                (let [diag-editdist (if (= ch (nth patt (dec i)))\n                                      (nth row (dec i))          ;; match, copy diagonal value;\n                                      (inc (nth row (dec i))))   ;; diagonal + 1; edit\n\n                      min-editdist (min (inc (nth row i))        ;; up +i1: deletion;\n                                        (inc (nth next (dec i))) ;; left + 1; insertion;\n                                        diag-editdist)\n                      ]\n                  (recur (inc i) (conj next min-editdist))))\n              ))\n          (allrows[patt1, patt2]\n            (loop [i 0\n                   row (range (inc (count patt2)))\n                   ]\n              (if (>= i (count patt1))\n                (last row)\n                (let [nrow (nextrow (nth patt1 i) patt2 row)]\n                  (recur (inc i) nrow)))\n              ))\n          ]\n    (allrows patt1 patt2)))", "user": "57fc0719e4b0d3187e900987"}, {"problem": 101, "code": "(fn simil [s1 s2]\n  (let [[s-big s-small] (if (> (count s1) (count s2)) [s1 s2] [s2 s1])]\n    (loop [sm (vec s-small), sb (vec s-big), result []]\n      (if (zero? (count sm))\n        (- (count s-big) (count result))\n        (let [y (.indexOf sb (first sm))]\n          (if (and y (>= y 0))\n            (recur (rest sm) (drop (inc y) sb) (conj result y))\n            (recur (rest sm) sb result)\n            ))))))", "user": "5cb4e764e4b026601754b929"}, {"problem": 101, "code": ";implemented from the levenshtein wiki page using a\n;matrix of steps if required. Seems like the recursive\n;solutions are also accepted but boring. Had to reimplement\n;without the as-> binding making the final solutions longer.\n(fn lev[a b]\n  (let [m (inc (count a))\n        n (inc (count b))\n        mycmp (fn[i j] (if (= (get a i) (get b j)) 0 1))\n        mat (into {} (for [i (range m) j (range n)]\n                       [[i j] 0]))\n        mat1 (reduce #(assoc %1 [%2 0] %2) mat (range 1 m))\n        mat2 (reduce #(assoc %1 [0 %2] %2) mat1 (range 1 n))\n        mat3 (reduce #(let [j (first  %2)\n                            i (second %2)]\n                        (assoc %1 [i j]\n                                  (min (inc (get %1 [(dec i) j]))\n                                       (inc (get %1 [i (dec j)]))\n                                       (+ (get %1 [(dec i) (dec j)])\n                                          (mycmp (dec i) (dec j))\n                                          )))) mat2\n                     (for [j (range 1 n) i (range 1 m)] [j i])) ]\n    (get mat3 [(dec m) (dec n)])))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 101, "code": "(fn levenshtein-distance [source target]\n  (let [matrix (atom [])\n        get-i-j (fn [i j] (get-in @matrix [i j]))\n        set-i-j (fn [i j x] (swap! matrix assoc-in [i j] x))\n        formula-set (fn [i j] (let [above (get-i-j (dec i) j)\n                                    left (get-i-j i (dec j))\n                                    diagonal (get-i-j (dec i) (dec j))]\n                                (if (= (get source (dec i)) (get target (dec j)))\n                                  (set-i-j i j diagonal)\n                                  (set-i-j i j (inc (min above left diagonal))))))\n        target-len (-> target count inc)]\n    (swap! matrix assoc 0 (vec (range target-len)))\n    (doseq [row-num (range 1 (-> source count inc))]\n      (swap! matrix assoc row-num [row-num])\n      (doseq [col-num (range 1 target-len)]\n        (formula-set row-num col-num)))\n    (-> @matrix last last)))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 101, "code": "(fn [src tgt]\n  (let [src-size (count src)\n        tgt-size (count tgt)\n        frame (reduce (fn [f i] (conj f [i]))\n                      [(vec (for [i (range (inc src-size))] i))]\n                      (range 1 (inc tgt-size)))]\n    (-> (reduce (fn [result src-idx]\n                  (let [src-char (nth src src-idx)]\n                    (reduce (fn [dataset tgt-idx]\n                              (let [tgt-char (nth tgt tgt-idx)\n                                    cost (if (= src-char tgt-char) 0 1)\n                                    above (inc (get-in dataset [tgt-idx (inc src-idx)]))\n                                    left (inc (get-in dataset [(inc tgt-idx) src-idx]))\n                                    diag (+ (get-in dataset [tgt-idx src-idx]) cost)]\n                                (assoc-in dataset [(inc tgt-idx) (inc src-idx)] (min above left diag))))\n                            result\n                            (range tgt-size))))\n                frame\n                (range src-size))\n        (get-in [tgt-size src-size]))))", "user": "5cbb0436e4b026601754b9cc"}, {"problem": 101, "code": "(fn levendish\n  [word-1 word-2]\n  (let [word-1-count (count word-1)\n        word-2-count (count word-2)\n        dp           (reduce (fn [acc [x y]]\n                               (let [dp-value (cond (zero? x) y\n                                                    (zero? y) x\n                                                    :else    (min (+ 1 (get-in acc [(dec x) y]))\n                                                                  (+ 1 (get-in acc [x (dec y)]))\n                                                                  (+ (if (= (get word-1 (dec x)) (get word-2 (dec y))) 0 1) (get-in acc [(dec x) (dec y)]))))]\n                                 (assoc-in acc [x y] dp-value)))\n                             (vec (repeat (inc word-1-count) (vec (repeat (inc word-2-count) 0))))\n                             (for [x (range (inc word-1-count))\n                                   y (range (inc word-2-count))]\n                               [x y]))]\n    (get-in dp [word-1-count word-2-count])))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 101, "code": ";; http://www.4clojure.com/problem/101\n;; Levenshtein Distance\n;; hackintosh solution\n(fn edit-distance\n  [s1 s2]\n  (loop [[h1 & r1 :as a1] s1\n         [h2 & r2 :as a2] s2\n         dist 0]\n    (cond \n      (nil? h1)\n      (+ dist (count a2))\n      \n      (nil? h2)\n      (+ dist (count a1))\n\n      (= h1 h2)\n      (recur r1 r2 dist)\n\n      (and (and (< (count s1) 6) (< (count s2) 6)) (>= (count r1) 2) (= h2 (first (rest r1))))\n      (recur (drop 2 r1) r2 (+ 2 dist))\n\n      (and (and (< (count s1) 6) (< (count s2) 6)) (>= (count r2) 2) (= h1 (first (rest r2))))\n      (recur r1 (drop 2 r2) (+ 2 dist))\n      \n      :else      \n      (recur r1 r2 (inc dist)))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 101, "code": "(fn [a b]\n  (let [count-a (count a)\n        count-b (count b)]\n    (last\n     (reduce\n      (fn [v0 i]\n        (reduce\n         (fn [v1 j]\n           (conj v1\n                 (min\n                  (inc (nth v0 (inc j)))\n                  (inc (last v1))\n                  (+ (nth v0 j) (if (= (nth a i) (nth b j)) 0 1)))))\n         [(inc i)] (range 0 count-b)))\n      (range 0 (inc count-b))\n      (range 0 count-a)))))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 101, "code": "(fn levenshtein-distance-better\n  [s1 s2]\n  (let [cs1 (count s1)\n        cs2 (count s2)\n        coll-choose-n (fn rec ([coll n] (rec coll n '()))\n                        ([coll n acc]\n                         (if (> n (count coll))\n                           nil\n                           (if (= n 0)\n                             [(reverse acc)]\n                             (concat (rec(rest coll) n acc)\n                                     (rec (rest coll) (dec n) (cons (first coll) acc)))))))]\n    (cond\n      (< cs1 cs2) (+ (- cs2 cs1) (apply min (map #(levenshtein-distance-better % s1) (coll-choose-n s2 cs1))))\n      (> cs1 cs2) (+ (- cs1 cs2) (apply min (map #(levenshtein-distance-better % s2) (coll-choose-n s1 cs2))))\n      (= cs1 cs2) (count (filter false? (map = s1 s2))))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 101, "code": "(fn lev-dist [s t]\n  (let [distance\n        (memoize (fn [f s t]\n                   (if (empty? s) (count t)\n                     (if (empty? t) (count s)\n                       (min (inc (f f s (butlast t)))\n                            (inc (f f t (butlast s)))\n                            (+ (if (= (last s) (last t)) 0 1)\n                               (f f (butlast s) (butlast t))))))))]\n    (distance distance s t)))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 101, "code": "(let [distance (memoize\n                  (fn [rec before after]\n                    (println \"XXX\" before after)\n                    (cond\n                      (and (empty? before) (empty? after)) 0\n                      (empty? before) (count after)\n                      (empty? after) (count before)\n\n                      (= (first before) (first after))\n                      (rec rec (rest before) (rest after))\n\n                      :else (inc (min (rec rec (rest before) after)\n                                      (rec rec before (rest after))\n                                      (rec rec (rest before) (rest after)))))))]\n    (partial distance distance))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 101, "code": "(fn\n  [coll1 coll2]\n  (let [d (reduce (fn [acc i]\n                    (conj acc (reduce (fn [col j]\n                                        (conj col\n                                              (min (inc (nth col (dec j) (inc i)))\n                                                   (inc (get-in acc [(dec i) j] (inc j)))\n                                                   (+ (get-in acc [(dec i) (dec j)] (if (zero? i) j i))\n                                                      (if (= (nth coll1 i) (nth coll2 j)) 0 1)))))\n                                      [] (range (count coll2)))))\n                  [] (range (count coll1)))]\n    (get-in d [(dec (count coll1)) (dec (count coll2))] (if (empty? coll1) (count coll2) (count coll1)))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 101, "code": "(fn levenshtein-distance [x y]\n  (let [\n        nx (inc (count x))\n        ny (inc (count y))\n        d (make-array Long nx ny)]\n    (doseq [i (range 0 nx)\n            j (range 0 ny)]\n      (aset d i j\n            (cond\n              (and (> i 0) (= j 0) ) i\n              (and (= i 0) (> j 0) ) j\n              :else 0)))\n   \n\n    (doseq [i (range 1 nx)\n            j (range 1 ny)]\n      (aset d i j\n            (min\n             (inc (aget d (dec i) j))\n             (inc (aget d i (dec j)))\n             (+ (aget d (dec i) (dec j))\n                (if (= (nth x (dec i))\n                       (nth y (dec j)))\n                  0 1)))))\n\n    (aget d (count x) (count y))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 101, "code": "(let [memo (atom {})]\n  (fn levenshtein\n    [[af & ar :as a] [bf & br :as b]]\n    (cond\n      (zero? (count a)) (count b)\n      (zero? (count b)) (count a)\n      (contains? @memo [a b]) (get @memo [a b])\n      :else (let [result (min\n                           (+ (levenshtein a br) 1)\n                           (+ (levenshtein ar b) 1)\n                           (+ (levenshtein ar br) (if (= af bf) 0 1)))]\n              (swap! memo conj [[a b] result])\n              result))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 101, "code": "#(let [l (fn [mem-fn x y]\n                    (let [l (fn [x y]\n                                       (mem-fn mem-fn x y))]\n                      (cond (empty? x) (count y)\n                            (empty? y) (count x)\n                            :else (min\n                                   (+ (if (= (subvec x 0 1) (subvec y 0 1)) 0 1)\n                                      (l (subvec x 1) (subvec y 1)))\n                                   (inc (l x (subvec y 1)))\n                                   (inc (l (subvec x 1) y))))))\n       mem-fn (memoize l)]\n  ((partial mem-fn mem-fn) (vec %1) (vec %2)))", "user": "5d931a58e4b0d3f9b434ad10"}, {"problem": 101, "code": "(fn levenshtein [a b]\n  (letfn [(next-line [previous-row start-item current-char]\n            (let [pairs (partition 2 1\n                                   (partition 2 (interleave (cons start-item previous-row) (cons (gensym) a))))\n                  next-element (fn [current-line pair current-char]\n                                 (min (inc (last current-line))\n                                      (+ (first (first pair))\n                                         (if (= (second (second pair)) current-char) 0 1))\n                                      (inc (first (second pair)))))]\n              (reduce (fn [current-line pair] (conj current-line\n                                                    (next-element current-line pair current-char)))\n                      [start-item]\n                      pairs)))]\n    (if (or (zero? (count a)) (zero? (count b)))\n      (max (count a) (count b))\n      (last\n       (reduce\n        (fn [previous-row start-item]\n          (prn (rest (next-line previous-row start-item (nth b start-item))))\n          (rest (next-line previous-row start-item (nth b start-item)))\n          )\n        (range 1 (inc (count a)))\n        (range 0 (count b)))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 101, "code": "(fn [a b]\n    (let [levens-dist\n          (memoize\n           (fn [levenstein-dist a b]\n             (cond\n               (empty? a) (count b)\n               (empty? b) (count a)\n               :else (min\n                      (inc (levenstein-dist levenstein-dist (rest a) b))\n                      (inc (levenstein-dist levenstein-dist a (rest b)))\n                      (+ (levenstein-dist levenstein-dist (rest a) (rest b))\n                         (if (= (first a) (first b)) 0 1))))))\n          levens-dist (partial levens-dist levens-dist)]\n      (levens-dist a b)))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 101, "code": "(fn [k1 k2]\n  (letfn [(ld [ [f1 & a1 :as all1 ] [f2 & a2 :as all2]]\n             (cond\n                (not f1) (count all2)\n                (not f2) (count all1)\n                (= f1 f2) (ld a1 a2)\n                :else (inc (min (ld a1 all2) (ld all1 a2) (ld a1 a2)))))]\n    (ld k1 k2)))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 101, "code": "(fn levenshtein [a b]\n    (let\n        [\n            lv\n                (memoize (fn [f s1 i1 s2 i2]\n                    (cond\n                        (>= i1 (count s1)) (- (count s2) i2)\n                        (>= i2 (count s2)) (- (count s1) i1)\n                        (= (nth s1 i1) (nth s2 i2)) (f f s1 (inc i1) s2 (inc i2))\n                        :otherwise\n                            (inc\n                                (min\n                                    (f f s1 (inc i1) s2 i2)\n                                    (f f s1 i1 s2 (inc i2))\n                                    (f f s1 (inc i1) s2 (inc i2))\n                                )\n                            )\n                    )\n                ))\n            lv (partial lv lv)\n        ]\n        (lv a 0 b 0)\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 101, "code": "(fn [s t]\n  (loop [r 1\n         prev-row (vec (range (inc (count t))))]\n    (if (= r (inc (count s)))\n      (last prev-row)\n      (recur (inc r)\n             (vec (reductions (fn [left c]\n                                (min\n                                  (inc left)\n                                  (inc (get prev-row c))\n                                  (+ (get prev-row (max 0 (dec c)))\n                                     (if (= (get s (dec r)) (get t (dec c))) 0 1))))\n                              r\n                              (map inc (range (count t)))))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 101, "code": "(fn levenshtein-distance\n  ([xs ys] (levenshtein-distance xs ys 1 (vec (range (inc (count xs))))))\n  ([xs ys r vx]\n   (if (empty? ys)\n     (peek vx)\n     (let [f (fn [v [a diag above]]\n               (let [k (if (= a (first ys)) 0 1)]\n                 (conj v (min (+ above 1)\n                              (+ (peek v) 1)\n                              (+ diag k)))))\n           vx (reduce f [r] (map vector xs vx (rest vx)))]\n       (levenshtein-distance xs (rest ys) (inc r) vx)))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 101, "code": "(fn lev [s t]\n                   (cond\n                     (empty? s) (count t)\n                     (empty? t) (count s)\n                     :else\n                     (let [ns (rest s)\n                           nt (rest t)]\n                       (if (= (first s) (first t))\n                         (lev ns nt)\n                         (min\n                           (inc (lev s nt))\n                           (inc (lev ns t))\n                           (inc (lev ns nt)))))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 101, "code": "(memoize(fn lev [s t]\n    (cond\n      (empty? s) (count t)\n      (empty? t) (count s)\n      :else\n        (let [ns (rest s)\n              nt (rest t)]\n          (if (= (first s) (first t))\n            (lev ns nt)\n            (min\n              (inc (lev s nt))\n              (inc (lev ns t))\n              (inc (lev ns nt))))))))", "user": "5dddc292e4b0948ae9d9adcb"}, {"problem": 101, "code": "(fn [x y]\n  (let [table ((fn [m n]\n                 (let [row (vec (range (inc n)))]\n                   (loop [res [], x m]\n                     (if (zero? x)\n                       (vec (reverse (conj res row)))\n                       (recur (conj res (into [] (concat [x] (repeat n 0)))) (dec x))))))\n               (count x) (count y))\n        assoc-table (fn [x y i j table]\n                      (if (= (nth x i) (nth y j))\n                        (assoc table i (assoc (nth table i) j (nth (nth table (dec i)) (dec j))))\n                        (assoc table i (assoc (nth table i) j (inc (min (nth (nth table (dec i)) j)\n                                                                        (nth (nth table (dec i)) (dec j))\n                                                                        (nth (nth table i) (dec j))))))))\n        x (vec (concat [0] (seq x)))\n        y (vec (concat [0] (seq y)))\n        res (loop [res-x table, i 1]\n              (if (= i (count x))\n                res-x\n                (recur (loop [res-y res-x, j 1]\n                         (if (= j (count y))\n                           res-y\n                           (recur (assoc-table x y i j res-y)\n                                  (inc j))))\n                       (inc i))))]\n    (last (last res))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "50342d1be4b062bc5d7ae15f"}, {"problem": 101, "code": "(fn [a1 a2]\n  (letfn [(ll [s1 s2]\n            (when (= (count s1) (count s2))\n              (count (filter (fn [[x y]] (not= x y)) (partition 2 (interleave s1 s2))))))\n          (subsq [c n m]\n            (concat (take (- m n) (drop n c))))\n          (new-words [s]\n            (map (fn [x] (concat (subsq s 0 x) (subsq s (inc x) (count s)))) (range 0 (count s))))]\n    (let [[s1 s2] (if (> (count a1) (count a2)) [a2 a1] [a1 a2])]\n      (let [[x y] (split-with (fn [x] (not= (count (first x)) (count s1))) (iterate #(mapcat new-words %) [s2]))]\n        (+ (count x) (apply min (map #(ll s1 %) (first y))))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 101, "code": "(fn [s1 s2]\n  (last (reduce-kv \n         (fn [dist i c]\n           (reduce-kv #(conj %1 (min (inc (nth dist (inc %2)))\n                                     (+ (nth dist %2) (if (= %3 c) 0 1))\n                                     (inc (last %1))))\n                      [(inc i)]\n                      (vec s1)))\n         (range (inc (count s1)))\n         (vec s2))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 101, "code": "(fn [a b]\n   (let [a (vec a)\n         b (vec b)\n         I (fn [i j] (if (= (a (dec i)) (b (dec j))) 0 1))\n         lev (fn [mem-lev i j]\n               (let [lev (fn [i j] (mem-lev mem-lev i j))]\n                 (if (zero? (min i j)) (max i j)\n                     (min (+ 1       (lev (dec i)      j))\n                          (+ 1       (lev      i  (dec j)))\n                          (+ (I i j) (lev (dec i) (dec j)))))))\n         mem-lev- (memoize lev)\n         mem-lev  (partial mem-lev- mem-lev-)]\n     (mem-lev (count a) (count b))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 101, "code": "(memoize \n  (fn lev [s1 s2]\n    (cond\n      (zero? (count s1)) (count s2)\n      (zero? (count s2)) (count s1)\n      (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n      :else (inc (min (lev (rest s1) s2)\n                      (lev s1 (rest s2))\n                      (lev (rest s1) (rest s2)))))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 101, "code": "(fn [coll1 coll2]\n    (let [[shorter longer] (if (<= (count coll1) (count coll2)) [coll1 coll2] [coll2 coll1])\n          deletes (fn [v]\n                    {:pre  [(vector? v)]}\n                    (map\n                      (fn [index]\n                        (vec (concat (subvec v 0 index) (subvec v (inc index)))))\n                      (range (count v))))\n          count-differences (fn [coll1 coll2]\n                             (->> (map (fn [a b] (= a b)) coll1 coll2)\n                                  (filter false?)\n                                  count))]\n      (loop [deletions 0\n             candidates (set [(vec longer)])]\n        (if (contains? candidates (vec shorter))\n          deletions\n          (if (< (count shorter) (count (first candidates)))\n            (recur\n              (inc deletions)\n              (set (mapcat deletes candidates)))\n            (+ deletions (apply min (map (partial count-differences shorter) candidates))))))))", "user": "4f43b992e4b0d7d3c9f3fd2c"}, {"problem": 101, "code": "(fn p-lev\n  ([a b] (cond (empty? a) (count b)\n               (empty? b) (count a)\n               :else \n     (p-lev a b (range (inc (count a))) 1)))\n  ([a b last-row row-index]\n   (if (< (count b) row-index) (last last-row)\n     (loop [col-index 1\n           this-row [row-index]\n            ]\n       (if (< (count a) col-index) (p-lev a b this-row (inc row-index))\n           (let [\n                 above-val (nth last-row col-index)\n                 left-val (nth this-row (dec col-index ))\n                 upper-left-val (nth last-row (dec col-index))\n                 new-val  (min\n                           (inc above-val)\n                           (inc left-val)\n                           (+ upper-left-val\n                             (if (= (nth a (- col-index 1))\n                                     (nth b (- row-index 1))) 0 1)))\n                 ]\n             (recur (inc col-index) (conj this-row new-val))))))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 101, "code": "(fn leven-distance [s1 s2]\n  (cond\n    (empty? s1) (count s2)\n    (empty? s2) (count s1)\n    (= (first s1) (first s2)) (leven-distance (rest s1) (rest s2))\n    :else (min\n            (inc (leven-distance s1 (rest s2)))\n            (inc (leven-distance (rest s1) s2))\n            (inc (leven-distance (rest s1) (rest s2))))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 101, "code": "(fn [c1 c2]\n    (let [source (reduce (fn [m i] (assoc m [i 0] i)) {} (range (inc (count c1))))\n          target (reduce (fn [m j] (assoc m [0 j] j)) source (range (inc (count c2))))\n          full (reduce (fn [m [i j]]\n                                     (let [cost (if (= (nth c1 (dec i)) (nth c2 (dec j))) 0 1)\n                                           deletion (inc (m [(dec i) j]))\n                                           insertion (inc (m [i (dec j)]))\n                                           substitution (+ cost (m [(dec i) (dec j)]))]\n                                       (assoc m [i j] (min deletion insertion substitution)))) target (for [j (range 1 (inc (count c1)))\n                                                                                                            i (range 1 (inc (count c2)))]\n                                                                                                        [j i]))]\n      (full [(count c1) (count c2)])))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 101, "code": "(fn [a b]\n    (let [fx\n          (fn [mf a b]\n            (let [fx (partial mf mf)]\n              (if (zero? (min (count a) (count b)))\n                (max (count a) (count b))\n                (min\n                 (inc (fx (rest a ) b))\n                 (inc (fx a (rest b)))\n                 (+ ({true 0 false 1} (= (first a) (first b)))\n                    (fx (rest a ) (rest b)))))))\n          mem-f (memoize fx)]\n      (mem-f mem-f a b)))", "user": "583048d9e4b051871117c007"}, {"problem": 101, "code": "#(let [ld (memoize (fn [ld s1 s2]\n               (cond (zero? (count s1)) (count s2)\n                     (zero? (count s2)) (count s1)\n                     :else\n                 (let [cost (if (= (last s1) (last s2)) 0 1)]\n                   (min (+ (ld ld (butlast s1) s2) 1)\n                        (+ (ld ld s1 (butlast s2)) 1)\n                        (+ (ld ld (butlast s1) (butlast s2)) cost))))))]\n  (ld ld %1 %2))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 101, "code": "(fn levenshtein [str1 str2]\n  (let [s1 (map (fn [c n] [c n n]) str1 (iterate inc 1))\n        s2 (map (fn [c n] [c (dec n) n]) str2 (iterate inc 1))\n        rowfn (fn [c [_ d l] [c1 _ a]]\n                (let [ret\n                      [c1 a (min (inc l) (inc a) (if (= c c1) d (inc d)))]]\n                  ret))\n        lev-row (fn [r c] (reductions (partial rowfn (first c)) c r))\n        lev-mat (reductions lev-row s1 s2)\n        ]\n    (if (= 0 (count str1)) (count str2)\n        (last (last (last lev-mat))))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 101, "code": "(memoize (fn edit-distance [s t]\n           (let [[a & a'] s\n                 [b & b'] t]\n            (cond\n             (empty? s) (count t)\n             (empty? t) (count s)\n             :else (if (= a b)\n                     (edit-distance a' b')\n                     (inc (min (edit-distance s b')\n                               (edit-distance a' t)\n                               (edit-distance a' b'))))))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 101, "code": "(fn [coll1 coll2]\n   (last\n    (reduce\n     (fn [row-acc [s-idx s-idm]]\n       (reduce\n        (fn  [acc [d-idx d-idm]]\n          (let [del (inc (nth row-acc (inc d-idx)))\n                ins (inc (last acc))\n                sub (+ (nth row-acc d-idx)\n                       (if (= s-idm d-idm) 0 1))]\n            (conj acc (min del ins sub))))\n        [(inc s-idx)]\n        (map-indexed vector coll2)))\n     (range (inc (count coll2)))\n     (map-indexed vector coll1))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 101, "code": "(fn [s t]\n  (letfn [(gridgrid [g [i j]]\n            (let [sc (if (= (get s (dec i)) (get t (dec j))) 0 1)\n                  mv (min (inc (get-in g [j (dec i)]))\n                          (inc (get-in g [(dec j) i]))\n                          (+ sc (get-in g [(dec j) (dec i)])))]\n              (assoc-in g [j i] mv)))\n          (mkd [j i]\n            (let [di (vec (repeat (inc i) (vec (repeat (inc j) 0))))\n                  row0filled (assoc-in di [0] (vec (range (inc j))))]\n              (reduce #(assoc-in %1 [%2 0] %2) row0filled (range (inc i)))))]\n    (let [xycoords (for [j (range 1 (inc (count t)))\n                         i (range 1 (inc (count s)))] [i j])\n          d (mkd (count s) (count t))]\n      (get-in (reduce gridgrid d xycoords) [(count t) (count s)]))))", "user": "4e8768f6535dceadca469850"}, {"problem": 101, "code": "(fn ld [[x & xs :as xss] [y & ys :as yss]]\n  (cond (empty? xss) (count yss)\n        (empty? yss) (count xss)\n        :else (if (= x y)\n                (recur xs ys)\n                (inc (min (ld xss ys)\n                          (ld xs yss)\n                          (ld xs ys))))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 101, "code": "(fn [w1 w2]\n  (letfn [(cell-value [same-char? prev-row cur-row col-idx]\n            (min (inc (nth prev-row col-idx))\n                 (inc (last cur-row))\n                 (+ (nth prev-row (dec col-idx)) (if same-char?\n                                                   0\n                                                   1))))]\n    (loop [row-idx  1\n           max-rows (inc (count w2))\n           prev-row (range (inc (count w1)))]\n      (if (= row-idx max-rows)\n        (last prev-row)\n        (let [ch2           (nth w2 (dec row-idx))\n              next-prev-row (reduce (fn [cur-row i]\n                                      (let [same-char? (= (nth w1 (dec i)) ch2)]\n                                        (conj cur-row (cell-value same-char?\n                                                                  prev-row\n                                                                  cur-row\n                                                                  i))))\n                                    [row-idx] (range 1 (count prev-row)))]\n          (recur (inc row-idx) max-rows next-prev-row))))))\n;;https://rosettacode.org/wiki/Levenshtein_distance#Iterative_version", "user": "5e13a6b7e4b099d064963001"}, {"problem": 101, "code": "(fn a \n  ([s1 s2]\n   (if (some empty? [s1 s2])\n     (max (count s1) (count s2))\n     (if (= (first s1) (first s2))\n       (a (rest s1) (rest s2) 0)\n       (min (a (rest s1) s2 1) \n            (a s1 (rest s2) 1) \n            (a (rest s1) (rest s2) 1)))))\n  ([s1 s2 cnt]\n   (if (some empty? [s1 s2])\n     (+ cnt (max (count s1) (count s2)))\n     (if (= (first s1) (first s2))\n       (a (rest s1) (rest s2) cnt)\n       (min (a (rest s1) s2 (inc cnt)) \n            (a s1 (rest s2) (inc cnt)) \n            (a (rest s1) (rest s2) (inc cnt)))))))", "user": "5799b260e4b05b1deef9adc8"}, {"problem": 101, "code": "(fn [s1 s2]\n  (let [n (count s1)\n        m (count s2)\n        init-cells (concat (map vector (repeat -1) (range 0 m))\n                           (map vector (range 0 n) (repeat -1)))\n        main-cells (for [i (range 0 n)\n                         j (range 0 m)]\n                     [i j])\n        cost (fn [i j]\n               (if (= (get s1 i) (get s2 j))\n                 0\n                 1))\n        table (reduce (fn [accum [i j]]\n                        (assoc accum [i j] (min (inc (accum [(dec i) j]))\n                                                (inc (accum [i (dec j)]))\n                                                (+ (accum [(dec i) (dec j)]) (cost i j)))))\n                      (reduce (fn [accum [i j]]\n                                (let [v (if (= -1 i)\n                                          (inc j)\n                                          (inc i))]\n                                  (assoc accum [i j] v)))\n                              {[-1 -1] 0}\n                              init-cells)\n                      main-cells)]\n    (table [(dec n) (dec m)])))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 101, "code": "(fn [x y]\n  (let [f (fn f [g\n                 [x & xs :as full-xs]\n                 [y & ys :as full-ys]]\n            (cond\n              (empty? full-xs) (count full-ys)\n              (empty? full-ys) (count full-xs)\n              :else (min (inc (g g xs full-ys))\n                         (inc (g g full-xs ys))\n                         (if (not= x y)\n                           (+ (g g xs ys) 1)\n                           (+ (g g xs ys) 0)))))\n        g (memoize f)]\n    (g g x y)))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 101, "code": "(fn ld [a b]\n  (let [[ah & as :as a] (seq a)\n        [bh & bs :as b] (seq b)]\n    (cond\n      (nil? ah) (count b)\n      (nil? bh) (count a)\n      (= ah bh) (ld as bs)\n      :else (+ 1 (min (ld a bs) (ld as b) (ld as bs))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 101, "code": "(fn levenshtein [s t]\n  (letfn [(get-in [d i j] (get (get d i) j))\n          (assoc-in [d i j v] (assoc d i (assoc (get d i) j v)))\n          (min-dist [d i j]\n            (let [same-char? (= (get s (dec i)) (get t (dec j)))\n                  deletion (inc (get-in d (dec i) j))\n                  insertion (inc (get-in d i (dec j)))\n                  substitution (+ (get-in d (dec i) (dec j)) (if same-char? 0 1))]\n              (min deletion insertion substitution)))]\n    (let [m (count s)\n          n (count t)\n          d (into\n              [(vec (range (inc n)))]\n              (map\n                #(vec (cons % (repeat n 0)))\n                (range 1 (inc m))))]\n      (loop [j 1 i 1 d d]\n        (cond\n          (> j n) (peek (peek d))\n          (> i m) (recur (inc j) 1 d)\n          :else\n          (recur j (inc i) (assoc-in d i j (min-dist d i j))))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 101, "code": "(fn [a b]\n  (let [ii (count a) jj (count b) dict (atom {})]\n    ((fn f [i j]\n        (cond \n           (@dict [i j])(@dict [i j])\n           (= 0 (min i j)) (let [r (max i j)]\n                             (swap! dict assoc [i j] r)\n                             r)\n           :else (let [r (min (inc (f (dec i) j))\n                              (inc (f i (dec j)))\n                              (+ (f (dec i) (dec j)) (if (= (nth a (dec i)) (nth b (dec j))) 0 1)))] \n                   (swap! dict assoc [i j] r) \n                   r)))\n     ii jj)))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 101, "code": "(fn lev\n  [a b]\n  (let [init (->> (take (count a) (repeat 0))    \n                  (repeat)\n                  (take (count b))\n                  (map-indexed\n                   (fn [index item]\n                     (conj item (inc index))))\n                  (#(conj % (range (inc (count a)))))\n                  (map vec)\n                  (vec))\n        row (fn [matrix j]\n              (loop [matrix matrix i 1]\n                (if (= i (inc (count a)))\n                  matrix\n                  (let [prevals [(inc (get-in matrix [(dec j) i])) \n                                 (inc (get-in matrix [j (dec i)]))\n                                 (+\n                                  (if (= (nth a (dec i))\n                                         (nth b (dec j)))\n                                    0 1)\n                                  (get-in matrix [(dec j) (dec i)])) ; replacement\n                                 ]\n                        new-matrix\n                        (assoc-in matrix [j i] (apply min prevals))]\n                    (recur new-matrix (inc i))\n                    \n                    \n                    ))))]\n    \n\n    (peek\n     (peek \n      (loop [matrix init j 1]\n        (if (= j (inc (count b)))\n          matrix\n          (recur (row matrix j) (inc j))\n        \n          ))))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 101, "code": "(fn ldist [[sh & st :as s] [th & tt :as t]]\n    (cond   (empty? s)  (count t)\n            (empty? t)  (count s)\n            (= sh th)   (ldist st tt)\n            :else       (inc (min (ldist s tt) (ldist st t) (ldist st tt)))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 101, "code": "(fn dist [c1 c2]\n  (let [find-match (fn [item c2 c2-match-idx]\n                     (keep-indexed #(if (and (= %2 item)\n                                             (> %1 c2-match-idx))\n                                      %1) c2))\n        find-match-dist (fn [c2-idx-set c2-match-idx c1-dist]\n                          (->> c2-idx-set\n                               (map #(list % (Math/abs (- % c2-match-idx c1-dist 1))))\n                               (sort-by last)\n                               first))\n        check-item (fn [c2-idx-dist c1-idx c1-match-idx c2-match-idx c1 c2]\n                     (loop [c1-idx-next (inc c1-idx)\n                            c1-c2-target [c1-idx (first c2-idx-dist)]\n                            c2-idx-dist-target c2-idx-dist]\n                       (if (>= c1-idx-next (count c1))\n                         c1-c2-target\n                         (let [c2-idx-set-next (find-match (nth c1 c1-idx-next)\n                                                           c2\n                                                           c2-match-idx)\n                               c2-idx-dist-next (find-match-dist c2-idx-set-next c2-match-idx (- c1-idx-next c1-match-idx 1))]\n                           (if (and c2-idx-dist-next\n                                    (<= (first c2-idx-dist-next) (first c2-idx-dist-target))\n                                    (< (last c2-idx-dist-next) (last c2-idx-dist-target)))\n                             (recur (inc c1-idx-next)\n                                    [c1-idx-next (first c2-idx-dist-next)]\n                                    c2-idx-dist-next)\n                             (recur (inc c1-idx-next)\n                                    c1-c2-target\n                                    c2-idx-dist-target))))))\n        t1-1 (fn [c1 c2]\n               (loop [match []\n                      c1-idx 0]\n                 (if (>= c1-idx (count c1))\n                   match\n                   (let [item (nth c1 c1-idx)\n                         pre-match (or (last match) [-1 -1])\n                         c1-match-idx (first pre-match)\n                         c2-match-idx (second pre-match)\n                         c1-dist (- c1-idx c1-match-idx 1)\n                         c2-idx-set (find-match item c2 c2-match-idx)\n                         c2-idx-dist (find-match-dist c2-idx-set c2-match-idx c1-dist)]\n                     (cond\n                       (and c2-idx-dist (< c1-match-idx 0)) (recur (conj match [c1-idx (first c2-idx-dist)])\n                                                                   (inc c1-idx))\n                       (and c2-idx-dist) (let [result (check-item c2-idx-dist c1-idx c1-match-idx c2-match-idx c1 c2)]\n                                           (recur (conj match result)\n                                                  (inc (first result))))\n                       :else (recur match (inc c1-idx)))))))\n        all-dist (concat [[-1 -1]] (t1-1 c1 c2) [[(count c1) (count c2)]])]\n    (apply + (map (fn [pre next]\n                    (max (- (first next) (first pre) 1)\n                         (- (second next) (second pre) 1)))\n                  all-dist\n                  (rest all-dist)))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 101, "code": "(fn levenshtein-distance [a b]\n  (let [a      (vec (seq a))\n        b      (vec (seq b))\n        al     (count a)\n        bl     (count b)\n        holder (conj (vec (range al)) al)]\n    (last (reduce (fn [holder row]\n                    (reduce (fn [new-holder col]\n                              (conj new-holder\n                                    (min\n                                      (inc (get holder (inc col)))\n                                      (inc (get new-holder col))\n                                      (if (not= (get a col)\n                                                (get b row))\n                                        (inc (get holder col))\n                                        (get holder col)))))\n                            [(inc row)]\n                            (range al)))\n                  holder\n                  (range bl)))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 101, "code": ";(\n (fn lev [s t]\n   #_(println s t)\n   (cond\n    (empty? s) (count t)\n    (> (count s)\n       (count t)) (lev t s)\n    (= (first s)\n       (first t)) (lev\n                   (rest s)\n                   (rest t))\n    :else (inc\n           (min\n           (lev (rest s)\n                (rest t))\n           (lev s\n                (rest t))))\n    ))\n; \"kitten\" \"sitting\")\n; \"xyx\" \"xyyyx\")\n; \"gaattctaatctc\" \"caaacaaaaaattt\")", "user": "5e64ae6ce4b0fd0acd1586ac"}, {"problem": 101, "code": "(fn levenshtein\n  [s1 s2]\n  (let [lv (memoize (fn [f s1 s2]\n                      (cond\n                        (empty? s1) (count s2); done consuming s1, return count of chars leftover\n                        (empty? s2) (count s1); done consuming s2, return count of chars leftover\n                        (= (first s1) (first s2)) (f f (rest s1) (rest s2)) ; chars match, move forward w/out an edit\n                        :else (inc ; an edit is required, three ways to do it\n                               (min\n                                (f f (rest s1) s2)\n                                (f f s1 (rest s2))\n                                (f f (rest s1) (rest s2)))))))\n        lv (partial lv lv)]\n    (lv s1 s2)))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 101, "code": "(fn [s t]\n  (let [m (count s) n (count t)\n        xy (for [j (range 1 (inc n)) i (range 1 (inc m))] [i j])]\n    (if (empty? xy)\n      (max n m)\n      (((reduce \n       (fn [[v1 v2] [i j]]\n         (let [cost (if (= (get s (dec i)) (get t (dec j))) 0 1)\n               v2 (conj v2 \n                 (min (inc (peek v2)) (inc (v1 i)) (+ (v1 (dec i)) cost)))]\n           (if (= i m) [v2 [(inc j)]] [v1 v2])))\n       [(vec (range 0 (inc m))) [1]] xy) 0) m))))", "user": "5e5096c6e4b027a2e10ac0c6"}, {"problem": 101, "code": "(fn ld [s1 s2]\n  (cond\n    (empty? s1) (count s2)\n    (empty? s2) (count s1)\n    (= (first s1) (first s2)) (ld (rest s1) (rest s2))\n    :else (min\n           (inc (ld (rest s1) s2))\n           (inc (ld s1 (rest s2)))\n           (inc (ld (rest s1) (rest s2))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 101, "code": "(memoize \n  (fn l-v [s1 s2]\n    (cond\n      (= 0 (count s1)) (count s2)\n      (= 0 (count s2)) (count s1)\n      (= (first s1) (first s2)) (l-v (rest s1) (rest s2))\n      :else (inc (min (l-v (rest s1) s2)\n                      (l-v s1 (rest s2))\n                      (l-v (rest s1) (rest s2)))))))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 101, "code": "(fn [w1 w2]\n    (letfn [(next-row [prev-row row]\n                (loop [col 1\n                       acc [row]]\n                    (if (> col (count w2))\n                        acc             \n                        (let [col' (inc col)\n                              sub-cost (if (= (nth w1 (dec row))\n                                              (nth w2 (dec col)))\n                                           0 1)\n                              v (last acc)\n                              v' (min (+ (nth prev-row (dec col)) sub-cost)\n                                      (inc (nth prev-row col))\n                                      (inc v))\n                              acc' (conj acc v')]\n                            (recur col' acc')))))]\n        (loop [row 1\n               acc [(apply vector 0 (map-indexed (fn [i e] (inc i)) w2))]]\n            (if (> row (count w1))\n                (last (last acc))\n                (let [prev-row (last acc)\n                      curr-row (next-row prev-row row)\n                      row' (inc row)\n                      acc' (conj acc curr-row)]\n                    (recur row' acc'))))\n        ))", "user": "600ae927e4b074f607df6689"}, {"problem": 101, "code": "(fn lev-v2 [x y]\n  (if (= (count x) 0)\n    (count y)\n    (if (= (count y) 0)\n      (count x)\n      (if (= (first x) (first y))\n        (lev-v2 (rest x) (rest y))\n        (+ 1 (min (lev-v2 (rest x) y) (lev-v2 x (rest y)) (lev-v2 (rest x) (rest y))))\n        )\n      )\n    )\n  )", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 101, "code": "(fn lev [a b] \n  (cond \n   \t(= 0 (count a)) (count b)\n   \t(= 0 (count b)) (count a)\n   \t(= (first a) (first b)) (lev (rest a) (rest b))\n   \t:else (inc (min (lev (rest a) b) (lev a (rest b)) (lev (rest a) (rest b)))) ))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 101, "code": "(fn levenshtein [a b]\n  (cond\n   (= 0 (count a)) (count b)\n   (= 0 (count b)) (count a)\n   (= (first a) (first b)) (levenshtein (rest a) (rest b))\n   :else (+ 1 (min (levenshtein a (rest b))\n                   (levenshtein (rest a) b)\n                   (levenshtein (rest a) (rest b))))))", "user": "5fa5a6b1e4b0fa27300f3dc8"}, {"problem": 101, "code": "(fn [s1 s2]\n  (letfn [(iter [[cur rows prev]]\n            (let [c (nth s2 (dec cur))\n                  nxt (reduce (fn [accum i]\n                                (let [cost (if (= (nth s1 (dec i)) c) 0 1)]\n                                  (conj accum\n                                        (min (inc (nth prev i))\n                                             (inc (last accum))\n                                             (+ (nth prev (dec i)) cost)))))\n                              [cur] (range 1 (count prev)))]\n              [(inc cur) rows nxt]))]\n    (last (last (first (drop-while #(not= (first %) (second %))\n                                   (iterate iter [1 (inc (count s2)) (range (inc (count s1)))])))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 101, "code": "(fn lev [a b] (cond\n                  (zero? (count a)) (count b)\n                  (zero? (count b)) (count a)\n                  (= (first a) (first b)) (lev (rest a) (rest b))\n                  :else (+ 1 (min \n                              (lev (rest a) b) \n                              (lev a (rest b)) \n                              (lev (rest a) (rest b))))\n                  ))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 101, "code": "(fn levenshtein\n  [coll1 coll2]\n  (letfn [(our-drop-while\n            [pred coll1 coll2]\n            (cond (or (empty? coll1) (empty? coll2)) (list coll1 coll2)\n                  (pred (first coll1) (first coll2)) (our-drop-while pred (rest coll1) (rest coll2))\n                  :else (list coll1 coll2)))]\n    (let [[coll1 coll2] (sort-by count (our-drop-while = coll1 coll2))]\n      (if (empty? coll1) (if (empty? coll2) 0\n                             (count coll2))\n          ;; there are two things to attempt here\n          ;; either we change the next character or we insert a new one\n          (min (inc (levenshtein (rest coll1) (rest coll2)))\n               (inc (levenshtein coll1 (rest coll2))))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 101, "code": "(fn lev [s1 s2]\n  (cond (empty? s1) (count s2)\n        (empty? s2) (count s1)\n        (= (first s1) (first s2)) (lev (rest s1) (rest s2))\n        :else (inc (min (lev (rest s1) s2)\n                        (lev s1 (rest s2))\n                        (lev (rest s1) (rest s2))))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 101, "code": "(let [remove-once ;removes the first instance of the matching item passed\n      (fn [item coll]\n        (let [[before after]\n              (split-with #((complement =) item %) coll)]\n          (concat before (rest after))))\n      distance\n      (fn [x y]\n        (let [max-distance (max (count x) (count y))\n              difference (Math/abs (- (count x) (count y)))\n              longest (if (> (count x) (count y)) x y)\n              shortest (if (< (count x) (count y)) x y)\n              interleaved (partition-all 2 (interleave x y))\n              filtered (filter (partial apply =) interleaved)]\n          (if\n            (< difference 2)\n            (- max-distance (count filtered))\n            (count (reduce\n                     #(remove-once %2 %1)\n                     longest\n                     shortest)))))]\ndistance)", "user": "5db012e3e4b0f8c104ccfc95"}, {"problem": 101, "code": "(fn lev [s t]\n  (loop [i 0\n         prev-row (concat (range (inc (count t))) [(count t)])]\n    (if (<= (count s) i)\n      (last prev-row)\n      (let [row (loop [j 0 current-row [(inc i)]]\n                  (if (<= (count t) j)\n                    current-row\n                    (let [deletion-cost (inc (nth prev-row (inc j)))\n                          insertion-cost (inc (nth current-row j))\n                          substitution-cost (if (= (nth s i) (nth t j))\n                                              (nth prev-row j)\n                                              (inc (nth prev-row j)))]\n                      (recur (inc j)\n                             (conj current-row (min deletion-cost\n                                                    insertion-cost\n                                                    substitution-cost))))))]\n        (recur (inc i)\n               row)))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 101, "code": "(fn levenshtein-distance [a b]\n  (let [[a' b'] (reverse (sort-by count [a b]))\n        as (seq a')\n        bs (seq b')]\n    (loop [aidx 0\n           distances (range (inc (count as)))]\n      (if (< aidx (count as))\n        (recur (inc aidx)\n               (loop [new-distances [(inc (first distances))]\n                      bidx 0]\n                 (let [replace (+ (if (= (nth as aidx)\n                                         (nth bs bidx))\n                                    0\n                                    1)\n                                  (nth distances bidx))\n                       deletion (inc (nth distances (inc bidx)))\n                       insertion (inc (nth new-distances bidx))]\n                   (println \"-------------\" (nth as aidx) (nth bs bidx))\n                   (println replace deletion)\n                   (println insertion (min replace deletion insertion))\n                   (if (< bidx (dec (count bs)))\n                     (recur (conj new-distances (min replace deletion insertion))\n                            (inc bidx))\n                     (conj new-distances\n                           (min replace deletion insertion))))))\n        (last distances)))))", "user": "605b49b7e4b079a07f8593f8"}, {"problem": 101, "code": "(memoize \n  (fn lev [a b]\n    (cond (= (count a) 0)\n          (count b)\n\n          (= (count b) 0)\n          (count a)\n        \n          (= (first a) (first b))\n          (lev (rest a) (rest b))\n\n          :else\n          (+ 1 (min (lev (rest a) b)\n                    (lev a (rest b))\n                    (lev (rest a) (rest b)))))))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 101, "code": "(fn l-dist [word-1 word-2]\n    (letfn [(dist [word-1 word-2 diff1 diff2]\n                (cond\n                    (or (empty? word-1) (empty? word-2))\n                    (+ diff2 diff1 (count word-1) (count word-2))\n\n                    :else\n                    (let [skip (drop-while #(not= % (first word-1)) word-2)\n                          t-diff (max (- (count word-2) (count skip)) diff2)]\n                        (min (dist (rest word-1) (rest skip) (+ diff1 t-diff) 0)\n                             (dist (rest word-1) word-2 diff1 (inc diff2))))))]\n        (min (dist word-2 word-1 0 0) (dist word-1 word-2 0 0))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 101, "code": "(fn lev [[h1 & t1 :as w1] [h2 & t2 :as w2]]\n  (cond\n    (empty? w1)\n    (count w2)\n    (empty? w2)\n    (count w1)\n    \n    (= h1 h2)\n    (lev t1 t2)\n    \n    :else\n    (min (+ 1 (lev t1 w2))\n         (+ 1 (lev w1 t2))\n         (+ 1 (lev t1 t2)))\n    ))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 101, "code": "(fn levenshtein [text-a text-b]\n  (let [n-a (count text-a)\n        n-b (count text-b)\n        process (fn [[a1 & rest-a] [b1 & rest-b]]\n                  (if (= a1 b1) (levenshtein rest-a rest-b)\n                      (+ 1 (min (levenshtein text-a rest-b)\n                                (levenshtein rest-a text-b)\n                                (levenshtein rest-a rest-b)))))]\n    (cond\n      (zero? n-a) n-b\n      (zero? n-b) n-a\n      :else (process text-a text-b))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 101, "code": "(fn edit-distance[seq-1 seq-2]\n  (letfn [(get-element[arr x y] (-> arr\n                                    (nth x)\n                                    (nth y)))\n          (set-element [arr x y value] (-> arr\n                                           (assoc x (-> (nth arr x)\n                                                        vec\n                                                        (assoc y value)))))\n           (derive-value[arr x y] (let [char-x (nth seq-1 (dec x))\n                                       char-y (nth seq-2 (dec y))\n                                       diff (if (= char-x char-y) 0 1)\n                                       new-val (min\n                                                (+ diff (get-element arr (dec x) (dec y)))\n                                                (inc (get-element arr x (dec y)))\n                                                (inc (get-element arr (dec x) y)))\n                                       ]\n                                   (set-element arr x y new-val)))\n          (loop-list [arr x] (loop [arr1 arr\n                                    lst (nth arr x)\n                                    y 1]\n                               (cond (> y (count seq-2)) arr1\n                                     :else (recur (derive-value arr1 x y) lst (inc y)))))\n                               \n                               ]    \n    (let [tab-1 (conj '() (-> (count seq-2)\n                              inc\n                              range\n                              vec))\n        tab-2 (for [x (->> (inc (count seq-1))\n                           (range 1))]\n                (-> (list x)\n                    (concat (-> (count seq-2)\n                                (repeat 0)))\n                    vec))\n          table (-> tab-1\n                    (concat tab-2)\n                    vec)]\n      (print table)\n      (loop [t table\n             index 1\n             len (count seq-1)]\n        (cond (> index len)  (do t (get-element t (count seq-1) (count seq-2)))\n              :else (recur (loop-list t index) (inc index)  len))))))", "user": "5bab31f1e4b0a20761a23471"}]