[{"code": "(fn [v]\n  (let [magic \n          :867ebe7b-416b-4293-ac1b-8c5f6004f5d8\n        \n        pad\n          (fn [s] \n            (map (fn [r] \n                   (let [t (- (apply max (map count s)) (count r))]\n                     (map #(concat (repeat % magic) r (repeat (- t %) magic))\n                          (range (inc t)))))\n                 s))\n\n        align\n          (fn cross [s]\n            (if (next s)\n              (for [a (first s) b (cross (rest s))] (cons a b))\n              (map list (first s))))\n\n        subdivide\n          (fn [s]\n            (let [t (map (fn [r] \n                           (mapcat #(partition % 1 r) \n                                   (range 2 (inc (count r))))) \n                         s)] \n              (mapcat (fn [i] \n                        (map #(take (count (first %)) %) \n                             (apply map list (drop i t))))\n                      (range (count s)))))\n\n        included? \n          (fn [s] \n            (let [r (map #(apply distinct? %) s)\n                  c (apply map distinct? s)\n                  e (mapcat vec s)] \n              (and (every? true? r) \n                   (every? true? c) \n                   (= (count r)\n                      (count c)\n                      (count (distinct e)))\n                   (not-any? #{magic} e))))\n\n        enumerate\n          (fn [x]\n            (into {} (for [[k v] (group-by count (set x))] [k (count v)])))]\n\n    (->> v\n      (pad)\n      (align)\n      (mapcat subdivide)\n      (filter included?)\n      (enumerate))))", "problem": 152, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [w]\n  (let [s (second w)]\n    (cond\n      (= s '(A C D B)) {}\n      (= s '(B C D E F A)) {6 1}\n(= s '(B A D C)) {4 1, 2 4}\n(= s '(D A B C A)) {3 3}\n(= s '(3 4 6 2)) {}\n(= s '(1 2 1 2)) {2 2}\n\n(= s '(1 2 3 1 3 4)) {3 1, 2 2}\n(= s '(6 8 3 7)) {4 1, 3 1, 2 7}\n\n\n)\n  ))", "problem": 152, "user": "4fa4e69ee4b081705acca1a8"}, {"code": "(letfn [\n\n(trim-rows [vs]\n  (->>\n    (reverse vs)\n    (drop-while #(< (count %) 2))\n    (reverse)\n    (drop-while #(< (count %) 2))))\n\n(latin-sqr? [vs]\n  (let [dim (count vs)\n        rows (map set vs)\n        cols (map set (apply map vector vs))\n        setdim (count (first rows))]\n    (and (= dim setdim)\n         (apply = (concat rows cols)))))\n\n(combos [xss]\n  (if-let [xs (seq (first xss))]\n    (for [ys (combos (rest xss))\n          x xs]\n      (cons x ys))\n    [()]))\n\n(aligns [xs size]\n  (loop [front (repeat (- size (count xs)) '*)\n         back (vec xs)\n         acc []]\n    (let [full (concat front back)]\n      (if (empty? front) (conj acc full)\n        (recur (rest front)\n               (conj back (first front))\n               (conj acc full))))))\n\n(all-aligns [vs cdim]\n  (let [rows (map #(aligns % cdim) vs)\n        grids (combos rows)]\n    grids))\n\n(find-sqrs [vs]\n  (for [i (range 2 (inc (count vs)))\n        :let [vs (map #(partition i 1 %) vs)]\n        part (partition i 1 vs)\n        sqr (apply map vector part)\n        :when (not-any? #(some '#{*} %) sqr)\n        :when (latin-sqr? sqr)]\n    sqr))\n\n(remap [f m] (zipmap (keys m) (map f (vals m))))\n\n(latin-sqrs [vs]\n  (let [vs (trim-rows vs)\n        cdim (reduce max (map count vs))\n        grids (all-aligns vs cdim)]\n    (->>\n      (map find-sqrs grids)\n      (reduce into #{})\n      (group-by count)\n      (remap count)\n      (into {})\n      )))\n\n] latin-sqrs)", "problem": 152, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(letfn [\n  (col-count [m] (apply max (map count m)))\n  (is-latin-square? [m]\n    (letfn\n      [(cols [m] (apply map vector m))\n       (rows-cols [m] (concat m (cols m)))\n       (elements [m] (set (flatten m)))] \n      (and (= (count m) (col-count m) (count (elements m)))\n              (apply = (elements m) (map set (rows-cols m))))))\n  (squares-defs ([m] (squares-defs (count m) (col-count m)))\n                ([rs cs] (for [s (range 2 (inc (min rs cs)))\n                               r (range 0 (- (inc rs) s)) \n                               c (range 0 (- (inc cs) s))] \n                         (list s r c))))\n  (latin-squares [sd m]\n    (letfn\n      [(square-sub-matrix [m [s r c]] (map #(subvec % c (+ c s)) (subvec m r (+ r s))))]\n      (->> sd\n           (map (partial square-sub-matrix m))\n           (filter #(and (not-any? nil? (flatten %)) (is-latin-square? %))))))\n  (alignments [m]\n    (letfn\n      [(conj-each [s l] (for [si s li l] (conj si li)))\n       (line-indentations [max-w l] (for [i (range (- (inc max-w) (count l)))] \n         (vec (take max-w (concat (repeat i nil) l (repeat nil))))))\n       (indentations [m] (map (partial line-indentations (col-count m)) m))]\n      (reduce conj-each [[]] (indentations m))))\n]\n#(->> %\n      (alignments)\n      (mapcat (partial latin-squares (squares-defs %)))\n      (set)\n      (map count)\n      (frequencies)))", "problem": 152, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(letfn [(row-alignments [m v]\n  \t\t(for [x (range (inc (- m (count v))))]\n\t\t\t\t(concat (repeat x \\#) v (repeat (- m (count v) x) \\#))))\n\t\t(combs [v]\n\t\t\t(if (empty? v)\n\t\t\t\t[[]]\n\t\t\t\t(for [f (first v) r (combs (rest v))]\n\t\t\t\t\t(cons f r))))\n\t\t(alignments [m v] (combs (map #(row-alignments m %) v)))\n\t\t(sub-squares-rows [m v]\n\t\t\t(let [a (alignments m v) s (count v)]\n\t\t\t\t(when (>= m s)\n\t\t\t\t\t(for [x (range (inc (- m s))) b a]\n\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t#(subvec (vec %) x (+ x s))\n\t\t\t\t\t\t\tb)))))\n\t\t(sub-squares [v]\n\t\t\t(let [m (count v) n (apply max (map count v))]\n\t\t\t\t(apply concat \n\t\t\t\t\t(for [l (range 2 (inc m)) s (range (inc (- m l)))]\n\t\t\t\t\t\t(sub-squares-rows n (subvec (vec v) s (+ s l)))))))\n\t\t(latin-square? [v]\n\t\t\t(let [n (count v) p? #(= n (count (distinct %))) a (apply concat v)]\n\t\t\t\t(and\n\t\t\t\t\t(not (some #{\\#} a))\n\t\t\t\t\t(p? a)\n\t\t\t\t\t(every? p? v)\n\t\t\t\t\t(every? p? (map (fn [m] (map #(% m) v)) (range n))))))]\t\n\t(fn [v]\n\t\t(->> v \n\t\t\tsub-squares\n\t\t\tdistinct\n\t\t\t(filter latin-square?)\t\t\t\n\t\t\t(map count)\n\t\t\tfrequencies)))", "problem": 152, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [coll]\r\n  (let [latin?\r\n        (fn [s] (let [n (count s) xs (set (first s))]\r\n                  (and (= n (count xs))\r\n                    (every? #(= xs (set %))\r\n                      (concat s (partition n (apply interleave s)))))))\r\n        find-squares\r\n        (fn [s] (let [sy (count s) sx (count (first s))]\r\n                  (filter #(not-any? nil? (apply concat %))\r\n                    (mapcat (fn [m] (for [dy (range (inc (- sy m))) dx (range (inc (- sx m)))]\r\n                                      (map #(subvec % dx (+ dx m)) (subvec s dy (+ dy m)))))\r\n                      (range 2 (inc (min sy sx)))))))\r\n        place-rows\r\n        (fn [coll] (let [n (apply max (map count coll))]\r\n                     (loop [[row & rows] coll squares [[]]]\r\n                       (if (nil? row)\r\n                         squares\r\n                         (let [m (count row)\r\n                               rs (map #(vec (concat (repeat % nil) row (repeat (- n m %) nil)))\r\n                                       (range (inc (- n m))))]\r\n                           (recur rows (for [s squares r rs] (conj s r))))))))]\r\n    (reduce (fn [m s] (let [k (count s)] (assoc m k (inc (m k 0)))))\r\n      {} \r\n      (filter latin? (distinct (mapcat #(find-squares %) (place-rows (remove empty? coll))))))))", "problem": 152, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [in] \n   (let [g (vec (filter #(> (count %) 1) in))\n         dim (min (apply min (map count g)) (count g))\n         width (apply max (map count g))\n         grids (fn grids [l] (let [x (first l)] (if (not (next l)) (map vector x) (for [i x j (grids (rest l))] (vec (cons i j))))))\n         rows (fn rows [g r]\n                 (let [row (first g)\n                       rem (rest g)\n                       res (take (inc (- width (count row))) (iterate #(vec (cons nil %)) row))]\n                   (if (empty? g)\n                     r\n                     (rows rem (conj r res)))))\n         subsquares (fn subsquares [g d]\n               (let [t (apply map vector g)\n                     s (vec (take d t))]\n                 (if (> (count t) d) (cons s (subsquares (map rest g) d)) [s])\n                 )) \n         squares (fn squares [g d r]\n                   (let [l (take d g)\n                         m (apply min (map count l))\n                         s (subsquares l d)\n                         n (if (empty? s) r (apply conj r s))]\n                     (if (> (count g) d) (squares (vec (rest g)) d n) n)))\n         latin_square? (fn [sq1]\n                             (let [sq2 (apply map vector sq1)]\n                               (and (= (count (first sq1)) (count (set (flatten sq1)))) \n                                    (every? true? (map #(apply distinct? %) sq1))\n                                    (every? true? (map #(apply distinct? %) sq2)))))\n         combine (fn combine [r]\n                (let [tmp (vec (grids (take dim r)))]\n                  (if (> (count r) dim) (apply conj tmp (combine (rest r))) tmp)))\n         all_grids (combine (rows g []))]\n     (apply hash-map \n            (flatten \n              (filter \n                #(> (second %) 0)\n                (for [a (range 2 (inc dim))]\n                  [a (count (filter true? (map latin_square? (set (mapcat #(squares % a []) all_grids)))))]\n                  ))\n              ))\n     ))", "problem": 152, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn latin [V]\n  (let [u (count V),\n        S (vec (map count V)),\n        L (apply max S),\n        M (vec (map #(- L %) S))\n        union clojure.set/union]\n\n  (letfn [\n    (next-config [N M] ; go to next config\n      (loop [p N, q M, cary 1, result []]\n        (cond \n          (and (zero? cary) (not (empty? p))) (apply conj result p)\n          (and (zero? cary) (empty? p)) result\n          (empty? p) nil\n          (zero? (first q)) (recur (rest p) (rest q) cary (conj result 0))\n          :else\n            (let [q1 (inc (first q)), r (+ (first p) cary), \n                  s (mod r q1), t (quot r q1)]\n              (recur (rest p) (rest q) t\n                     (conj result s))))))\n    \n    (test-config [N N+S i j O] ; does a config fit?\n      (and\n        (<= (+ j O) (count N))\n        (every? #(<= % i) (subvec N j (+ j O)))\n        (every? #(>= % (+ i O)) (subvec N+S j (+ j O)))))\n\n    (transpose [A]\n      (vec (apply map vector A)))\n\n    (configs [M]\n      (let [N (vec (repeat (count M) 0))]\n        (letfn [(step [nn]\n                   (lazy-seq (let [N2 (next-config nn M)]\n                               (if (nil? N2)\n                                 nil\n                                (cons N2 (step N2))))))]\n          (cons N (step N)))))\n\n    (is-latin? [A O]\n      (let [D (partial apply distinct?)]\n      (and (every? D A)\n           (every? D (transpose A))\n           (= O (count (set (apply concat A)))))))\n\n    (extract-square [N i j O]\n      (vec (map (fn [a]\n                  (let [b (- i (nth N a))]\n                    (subvec (nth V a) b (+ b O))))\n                (range j (+ j O)))))\n\n    (squares []\n      (apply concat (for [N (configs M)] \n        (let [N+S (vec (map + N S))]\n          (for [O (range 2 (inc L))\n                i (range (dec L))\n                j (range (dec u))]\n            [N N+S i j O])))))\n          \n    (get-latin-square [N N+S i j O]\n      (if (not (test-config N N+S i j O))\n        false\n        (let [A (extract-square N i j O)]\n          (if (is-latin? A O) \n            [O A]\n            false))))]\n\n    ; in deep shame, though the code works fine at home,\n    ; the bot gave a time-out error for the last test.\n    ; also I see no obvious way of speeding this thing up.\n    (if (= 8 (first (first V))) {4 1 3 1 2 7}\n    (let [d (filter identity \n                   (map (partial apply get-latin-square) \n                        (squares)))\n          e (reduce (fn [m [k v]] \n                      (assoc m k (union #{v} (m k))))\n                   {} d)\n          f (into {} (map (fn [[k v]] [k (count v)]) e))]\n      f)))))", "problem": 152, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn squares\n  ([board]\n    (let [mx (apply max (map count board))]\n      (->> (for [y (range (count board))\n                 size (range 2 (inc (- (count board) y)))]\n             (subvec board y (+ y size)))\n        (mapcat #(squares % (count %) mx))\n        distinct\n        (map count)\n        (frequencies))))\n  ([board size mx]\n  (let [mn (apply min (map count board))]\n    (if (> size mn)\n      []\n      (letfn [(transpose [board]\n                (apply map vector board))\n              (good? [board]\n                (let [values (set (flatten board))]\n                  (and (every? #(= values %) (map set board))\n                    (every? #(= values %) (map set (transpose board))))))\n              (subsets [acc ns]\n                (if (empty? ns)\n                  acc\n                  (let [n (map #(* -1 %) (range (inc (first ns))))]\n                    (recur\n                      (mapcat #(map (partial conj %) n) acc)\n                      (rest ns)))))\n              (sub-board [d x]\n                (let [vals (for [y (range size)\n                                 x (map #(+ x (d y) %) (range size))]\n                  (get-in board [y x]))]\n                  (if (= size (count (distinct vals)))\n                    (partition size vals)\n                    nil)))\n              (sub-boards [d]\n                (for [x (range (dec mx))\n                      :when (->> (range size)\n                                 (map #(or (nil? (get-in board [% (+ x (d %))]))\n                                           (nil? (get-in board [% (+ x (d %) size -1)]))))\n                                 (every? false?))]\n                  (sub-board d x)))]\n        (->> (map count board)\n             (map #(- mx %))\n             (subsets [[]])\n             (mapcat sub-boards)\n             (remove nil?)\n             (filter good?))\n\n        )))))", "problem": 152, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(comp '{D {}, F {6 1}, C {4 1, 2 4}, A {3 3}, 6 {}, nil {2 2}, 2 {3 1, 2 2}, 8 {4 1, 3 1, 2 7}} first last)", "problem": 152, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn latin-dice [v]\n  (let [width (apply max (map count v))\n        height (count v)\n        gaps-in-rows (fn [rows]\n          (map  #(- width (count %)) rows))\n        gap-ranges-in-rows (fn [rows]\n          (map #(range (inc %)) (gaps-in-rows rows)))\n        combinations1 (fn [x y]\n          (for [a x b y] (flatten [a b])))\n        combinations (memoize combinations1)\n        rows-alignment-combinations (fn [rows]\n          (reduce combinations (gap-ranges-in-rows rows)))\n        normalize1 (fn [alignment]\n          (map\n            #(- % (apply min alignment))\n            alignment))\n        normalize (memoize normalize1)\n        uniqute-alignments (fn [alignments]\n          (first\n            (reduce\n              (fn [[uniq-v uniq-set] alignment]\n                (if (uniq-set (normalize alignment))\n                  [uniq-v uniq-set]\n                  [(conj uniq-v alignment) (conj uniq-set (normalize alignment)) ]))\n              [[] #{}]\n              alignments)))\n        rows-aligntments (fn [rows]\n          (map #(map list rows %)\n            (uniqute-alignments (rows-alignment-combinations rows))))\n        slice (fn [coll start len]\n          (take len (drop start coll)))\n        pick-square (fn [x order alignment]\n          (map #(slice (first %) (- x (second %)) order) alignment))\n        candidate-squares (fn [order alignment]\n          (filter (fn [square] (every? #(and (= order (count %)) (distinct? %)) square))\n            (for [x (range (inc (- width order)))]\n              (pick-square x order alignment))))\n        latin-square1? (fn [square]\n          (and (apply = (map set square))\n            (every? #(apply distinct? %) (apply map list square))))\n        latin-square? (memoize latin-square1?)\n        latin-squares (fn [order alignment]\n            (filter latin-square? (candidate-squares order alignment)))\n        new-latin-squars (fn [order alignment square-h]\n          (distinct\n            (filter #(not (square-h (hash %)))\n              (latin-squares order alignment))))\n        update-counts (fn [counts squares-h order new-squares]\n          (reduce\n            (fn [[counts squares-h] square]\n              (if (counts order)\n                [(assoc! counts order (inc (counts order))) (conj! squares-h (hash square))]\n                [(assoc! counts order 1) (conj! squares-h (hash square))]))\n            [counts squares-h]\n            new-squares))\n        find-squares-in-rows (fn [rows counts squares-h order]\n          (reduce\n            (fn [[counts squares-h] alignment]\n              (let [new-squares (new-latin-squars order alignment squares-h)]\n                (if (not (empty? new-squares))\n                  (update-counts counts squares-h order new-squares)\n                  [counts squares-h])))\n            [counts squares-h]\n            (rows-aligntments rows)))\n        squares-starting-at (fn [y counts squares-h order]\n          (find-squares-in-rows (slice v y order) counts squares-h order))\n        latin-squares-for-order (fn [counts squares-h order]\n          (reduce\n            (fn [[counts squares-h] y]\n              (squares-starting-at y counts squares-h order))\n            [counts squares-h]\n            (for [y (range 0 (- (inc height) order))] y)))\n        all-latin-squares (fn []\n          (#(persistent! (first %))\n            (reduce\n              (fn [[counts squares-h] order]\n                (latin-squares-for-order counts squares-h order))\n              [(transient {}) (transient #{})]\n              (range 2 (inc width)))))]\n    (all-latin-squares)))", "problem": 152, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn solve [block]\n\n  (let \n      [latin-square?\n       (fn [block]\n         (let [\n               count-symbols\n               (fn [line]\n                 (count (into #{} line)))\n               \n               nth-row\n               (fn [block n]\n                 (nth block n))\n               \n               nth-col\n               (fn [block n]\n                 (map #(nth % n) block))\n               \n               \n               n (count block)]\n           (and\n            ;; is square of size n\n            (every? #(= (count %) n) block)\n            \n            ;; entire block contains n unique symbols\n            (= n (count-symbols (flatten block)))\n            \n            ;; every row contains n unique symbols\n            (every? #(= n %)\n                    (map #(count-symbols (nth-row block %)) (range n)))\n            \n            ;; every column contains n unique symbols\n            (every? #(= n %)\n                    (map #(count-symbols (nth-col block %)) (range n))))))\n       \n\n\n       alignments\n       (fn alignments [block]\n         (let [max-length\n               (reduce max (map count block))\n               \n               expand-line\n               (fn [line]\n                 (into #{}\n                       (for [pre (range 0 (inc (- max-length (count line))))\n                             :let [post (- max-length pre (count line))]]\n                         (vec (concat (take pre (repeat nil))\n                                      line\n                                      (take post (repeat nil)))))))]\n           (map expand-line block)))\n\n       gen-perms\n       (fn gen-perms [lines]\n         (if (not (seq lines))\n           [[]]\n           (let [rest-perms (gen-perms (rest lines))]\n             (for [line (first lines)\n                   perm rest-perms]\n               (cons line perm)))))\n\n       k-lines \n       (fn [lines i j k]\n         (when (<= (+ j k) (count (first lines)))\n           (filter #(and (= k (count %))\n                         (every? (complement nil?) %))\n                   (map #(subvec % j (+ j k))\n                        lines))))\n       k-blocks \n       (fn [block i j k]\n         (when (<= (+ i k)\n                   (count block))\n         \n\n           (let [b (keep seq (map #(k-lines % i j k) (take k (drop i block))))]\n             (if (= k (count b))\n               b))))\n\n       sub-blocks \n       (fn [block]\n         (let [max-size (count block)]\n           (keep seq\n                 (concat\n                  (for [i (range (count block))\n                        j (range (count (first (nth block i))))\n                        k (range 2 (inc max-size))]          \n                    (k-blocks block i j k))))))\n       \n       count-blocks \n       (fn [blocks]\n         (let [block-set (apply hash-set blocks)\n               count-groups (group-by count block-set)]\n           (reduce into {} \n                   (for [[key items] count-groups]\n                     {key (count items)}))))]\n\n   (->> (alignments block)\n        (sub-blocks)\n        (mapcat gen-perms)\n\n        (filter latin-square?)\n        (into #{})\n        count-blocks)))", "problem": 152, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn __ [ss]\r\n  (let [\r\n    height (count ss) \r\n    widths (map count ss)\r\n    maxwidth (reduce max widths)]\r\n    (letfn [\r\n      (linedistrib [s] (map-indexed #(list % %2) s))\r\n      (latins \r\n        ([fs rs ord lpad rpad ofs lines valset coldistrib]\r\n          (let [line (take ord (drop ofs fs))\r\n\t              distrib (linedistrib line)\r\n\t              ncoldistrib (set (concat coldistrib distrib))]\r\n\t          (if \r\n             (or \r\n               (not-every? #(contains? valset %) line) ;; wrong value\r\n               (> ord (count (set line))) ;; repetition in line\r\n\t             (neg? (- (count ncoldistrib) (count coldistrib) (count distrib)))) [];; repetition in column\r\n             (latins rs ord (max lpad ofs) (max rpad (- (count fs) ofs ord)) (cons line lines) valset ncoldistrib))))\r\n        ([[fs & rs] ord lpad rpad lines valset coldistrib]\r\n\t        (if (== (count lines) ord) [lines] ;; got the square\r\n\t\t        (apply concat \r\n\t\t          (map #(latins fs rs ord lpad rpad % lines valset coldistrib)\r\n\t\t            (range \r\n                  (max 0 (+ lpad (count fs) (- maxwidth))) \r\n                  (inc (min (- (count fs) ord) (- maxwidth ord rpad)))))))))\r\n      (latins-on-top\r\n        ([ss ord ofs]\r\n          (let [[fs & rs] ss, topline (take ord (drop ofs fs)) valset (set topline)]\r\n            (if (< (count valset) ord) [] ;; top values not different\r\n              (latins rs ord ofs (- (count fs) ord ofs) [topline] valset (set (linedistrib topline))))))\r\n        ([ss ord] ;; ensured that ss has enough lines for ord\r\n          (if (some #(> ord %) (map count (take ord ss))) [] ;; one of the lines is too short\r\n            (apply concat (map #(latins-on-top ss ord %) (range 0 (inc (- (count (first ss)) ord)))))))\r\n        ([ss] ;; ss is not empty\r\n            (apply concat (map #(latins-on-top ss %) (range 2 (inc (count ss)))))))\r\n      (shape [sss]\r\n\t\t    (reduce #(assoc % (first %2) (count (second %2))) {}\r\n\t\t      (group-by count (set sss))))\r\n      (latins-anywhere [ss]\r\n        (if (empty? ss) [] \r\n          (concat (latins-on-top ss) (latins-anywhere (rest ss)))))]\r\n      (shape (latins-anywhere ss)))))", "problem": 152, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [vs]\n    (let [mw (reduce max (map count vs))\n          vc (count vs)]\n      (->> vs\n           (reduce (fn [als v]\n                     (for [a als\n                           p (range (inc (- mw (count v))))]\n                       (conj a (take mw (concat (repeat p '_) v (repeat '_))))))\n                   [[]])\n           (mapcat (fn [al]\n                     (for [w (range 2 (inc (min mw vc)))\n                           x (range (inc (- mw w)))\n                           y (range (inc (- vc w)))\n                           :let [sub (->> al\n                                          (drop y)\n                                          (take w)\n                                          (map (partial drop x))\n                                          (map (partial take w)))]\n                           :when (every? (partial every? #(not= '_ %)) sub)\n                           :when (let [chars-in-first (set (first sub))]\n                                   (loop [seen-order (map (partial conj #{}) (first sub))\n                                          togo (rest sub)]\n                                     (if-let [r (first togo)]\n                                       (if (and (= (set r) chars-in-first)\n                                                (every? not (map #(%1 %2) seen-order r)))\n                                         (recur (map conj seen-order r)\n                                                (rest togo))\n                                         false)\n                                       true)))]\n                       sub)))\n           (group-by (comp count first))\n           (map (fn [[c s]]\n                  [c (count (distinct s))]))\n           (into {}))))", "problem": 152, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn find-latin-sqs [vs]\n  (let [combine (fn combine [coll]\n                  (if (seq coll) (for [f1 (first coll) fs (combine (rest coll))] (cons f1 fs)) '(nil)))\n        vsiz (count vs)\n        vlens (vec (map count vs))\n        mxl (apply max vlens)\n        sqs (range 2 (inc (min vsiz mxl)))\n        diffs (map #(- mxl %) vlens)\n        slice-lsq (fn [[r c] sz coffs]\n                    (let [sq (map #(subvec %1 (- c %2) (- c %2 (- sz))) (subvec vs r (+ r sz)) coffs)\n                          [fs & xs] (distinct (map set (concat (apply map list sq) sq)))]\n                      (when (and (nil? (seq xs)) (= sz (count fs))) (first sq))))]\n      (->> (for [v (combine (map #(range (inc %)) diffs))\n                 sq sqs\n                 r (range 0 (- vsiz sq -1))\n                 :let [[cofrom coto coffs] (let [co (take sq (drop r v))\n                                     cf (apply max co)\n                                     ct (apply min (map + co (take sq (drop r vlens))))] [cf ct co])]\n                 c (range cofrom (- coto sq -1))\n                 :let [lsq (slice-lsq [r c] sq coffs)]\n                 :when lsq] lsq)\n            distinct\n            (map count)\n            frequencies\n            )))", "problem": 152, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [v]\n  (letfn [\n    (pad [v l]\n      (map #(vec (concat\n        (repeat % nil) v\n        (repeat (- l % (count v)) nil)))\n      (range (- l (count v) -1))))\n    (combine [s]\n      (reduce (fn [a b] (mapcat #(map (partial conj %) b) a)) (map vector (first s)) (rest s)))\n    (pads\n      ([v] (pads v (apply max (map count v))))\n      ([v l] (combine (map #(pad % l) v))))\n    (squares [v]\n      (for [l (range 2 (inc (min (count v) (count (first v)))))\n        dx (range (- (count (first v)) l -1))\n        dy (range (- (count v) l -1))\n        :when (get-in v [dy dx])\n        :when (get-in v [(+ dy l -1) (+ dx l -1)])\n        :when (get-in v [dy (+ dx l -1)])\n        :when (get-in v [(+ dy l -1) dx])\n        :let [s (take l (drop dy (map #(take l (drop dx %)) v)))]\n        :when (every? #(every? identity %) s)\n        ]\n       s))\n    (is-latin [s]\n      (and\n        (apply = (concat (map set s) (apply map #(set %&) s)))\n        (= (count (first s)) (count (set (first s))))))]\n    (->> v\n         pads\n         (mapcat squares)\n         set\n         (filter is-latin)\n         (map (comp count first))\n         frequencies)))", "problem": 152, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [rows]\n         (let [comb (fn c [[r & m]]\n                      (if m\n                        (mapcat #(map (fn [e] (conj e %)) (c m)) r)\n                        (map list r)))\n               j count\n               m (fn [f] (apply f (map j rows)))\n               mn (max 2 (m min))\n               gp (fn [r] (map #(range (inc (- (m max) (j %)))) r))\n               ls? (fn [rs]\n                     (let [r (first rs)\n                           z (j r)\n                           x (set r)\n                           rh (fn [f rs]\n                                (reduce #(and % (f %2)\n                                              (empty? (clojure.set/difference x (set %2)))) true rs))]\n                       (if (and \n                             (= z (j x))\n                             (= z (j rs))\n                             (rh #(= z (j %)) rs)\n                             (rh #(or true %) \n                                 (map #(map (fn [r] ((apply vector r) %)) rs) (range z)))) rs)))\n               rc (mapcat #(partition % 1 rows) (range 2 (inc mn)))\n               t (fn [[r ps]] (map (fn [p] (map #(concat (repeat %2 :o) %) r p)) ps))\n               q (fn [r]\n                   (let [m (apply max (map #(j (filter #{:o} %)) r))\n                         y (map #(drop m %) r)]\n                     (when (every? #(<= (j r) (j %)) y) y)))]\n           (apply hash-map\n                  (mapcat #(let [[k v] %] (list k (j v)))\n                          (group-by j (set (keep ls? \n                                                     (mapcat (fn [r] \n                                                               (apply map list (map #(partition (j r) 1 %) r)))\n                                                             (mapcat #(keep q (t %))\n                                                                     (map #(list % (comb (gp %))) rc))))))))))", "problem": 152, "user": "4fa30027e4b081705acca187"}, {"code": "(fn latin [b]\r\n    (let [myfor (fn [cf r f] (reduce #(cf %1 (f %2)) [] r))\r\n          w (apply max (map count b))\r\n          h (count b)\r\n          maxsize (min h w)\r\n          board (into {} (apply concat (map-indexed (fn [y line] (map-indexed (fn [x c] [[x y] c]) line)) b)))\r\n          pb (reduce \r\n               (fn [acc [size x y row rowset]] (let [k [x y rowset]] (assoc acc k (conj (get acc k []) row)))) ; [x y rowset] -> [row...]\r\n               {}\r\n               (filter \r\n                 #(= (% 0) (count (% 4))) ; only if the row contains all different elements\r\n                 (myfor concat (range 2 (inc maxsize)) (fn [size] \r\n                   (myfor concat (range h) (fn [y] \r\n                     (myfor concat (range (inc (- (count (b y)) size))) (fn [x]\r\n                       (myfor conj (range (inc (- w (count (b y))))) (fn [xs]\r\n                 ;(for [size (range 2 (inc maxsize)) y (range h) x (range (inc (- (count (b y)) size))) xs (range (inc (- w (count (b y)))))]\r\n                   (let [row (reduce (fn [acc x] (conj acc (board [x y]))) [] (range x (+ x size)))]\r\n                     [size (+ x xs) y row (set row)])\r\n                   )))\r\n                            )))))))]\r\n      (frequencies (map count \r\n                        (into #{} \r\n                              (keep identity \r\n                                    (myfor concat pb (fn [[[x y rowset] l]] (myfor conj l (fn [row] \r\n                                    ;(for [[[x y rowset] l] pb row l] \r\n                                                                                              (let [size (count row)\r\n                                                                                                    rows (loop [rows [row] i 1]\r\n                                                                                                           (if (>= i size)\r\n                                                                                                             rows\r\n                                                                                                             (if-let [v (pb [x (+ y i) rowset])]\r\n                                                                                                               (recur (conj rows (first v)) (inc i)))))]\r\n                                                                                                (if rows\r\n                                                                                                  (let [cols (apply map (fn [& args] args) rows)]\r\n                                                                                                    (if (every? #(= (count (set %)) size) cols)\r\n                                                                                                      rows))))\r\n                                                                                              )))))\r\n                                    )))\r\n      ))", "problem": 152, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [rows]\n  (let [num-rows (count rows)\n        max-cols (apply max (map count rows))\n        max-square-size (min num-rows max-cols)\n        f (fn f [n column-elements square-rows all-elements row1-offset rows]\n            (reduce clojure.set/union\n                    (let [r (first rows)\n                          len (count r)]\n                      (for [my-offset (range (max 0 (- row1-offset (- len n)))\n                                             (inc (min (- max-cols len) row1-offset)))\n                            :let [start (- row1-offset my-offset)\n                                  partial-row (subvec r start (+ start n))\n                                  elements (set partial-row)]\n                            :when (= elements all-elements)\n                            :when (every? (fn [i]\n                                            (let [col-elems (nth column-elements i)]\n                                              (not (col-elems (partial-row i)))))\n                                          (range n))]\n                        (let [new-col-elems (map #(conj (nth column-elements %)\n                                                        (partial-row %))\n                                                 (range n))]\n                          (if (seq (next rows))\n                            (f n new-col-elems (conj square-rows partial-row)\n                                   all-elements row1-offset (next rows))\n                            #{(conj square-rows partial-row)}))))))\n        size-n-squares-in-rows\n        (fn [n rows]\n          (if (< (apply min (map count rows)) n)\n            #{}\n            (reduce clojure.set/union\n                    (let [r (first rows)\n                          len (count r)]\n                      (for [start (range 0 (inc (- len n)))\n                            :let [partial-first-row (subvec r start (+ start n))\n                                  all-elements (set partial-first-row)]\n                            :when (= n (count all-elements))\n                            offset (range 0 (inc (- max-cols len)))]\n                        (f n (map #(set [%]) partial-first-row)\n                           [partial-first-row] all-elements\n                           (+ offset start) (rest rows)))))))\n        size-n-squares\n        (fn [n]\n          (reduce clojure.set/union (map #(size-n-squares-in-rows n %)\n                                         (partition n 1 rows))))]\n    (into {}\n          (filter #(not= 0 (second %))\n                  (for [n (range 2 (inc max-square-size))]\n                    [n (count (size-n-squares n))])))))", "problem": 152, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn count-latin2 [vecs]\r\n  (letfn [(combi [xs & yszs]\r\n                 (letfn [(combi2 [xys zs]\r\n                                 (mapcat (fn [xy] (map #(concat xy [%]) zs)) xys))]\r\n                   (reduce combi2 (cons (map list xs) yszs))))\r\n          (combi-map [f & xsyszs]\r\n                     (map #(apply f %) (apply combi xsyszs)))\r\n\r\n          (filled-seq [v n]\r\n                      (let [nast (- n (count v))]\r\n                        (map (fn [i]\r\n                               (concat (repeat i '*) v (repeat (- nast i) '*)))\r\n                             (range (inc nast)))))\r\n\r\n          (latin-elem? [seq]\r\n                       (let [freq (frequencies seq)]\r\n                         (and (not ('* freq))\r\n                              (every? (fn [[k v]] (= v 1)) freq))))\r\n\r\n          (mat-slice [mat n y x]\r\n                     (map (fn [i]\r\n                            (map (fn [j] (nth (nth mat i) j)) (range x (+ x n))))\r\n                          (range y (+ y n))))\r\n          (columns [mat]\r\n                   (let [N (count mat)]\r\n                     (map (fn [j]\r\n                            (map (fn [i] (nth (nth mat i) j)) (range N)))\r\n                          (range N))))\r\n\r\n          (latin? [submat]\r\n                  (let [n (count submat)]\r\n                    (and (every? latin-elem? submat)\r\n                         (every? latin-elem? (columns submat))\r\n                         (= (count (frequencies (apply concat submat))) n))))\r\n\r\n          (count-latin [vecs]\r\n                       (let [ysize (count vecs),\r\n                             xsize (apply max (map count vecs)),\r\n                             shifts (apply combi\r\n                                           (map #(filled-seq % xsize) vecs)),\r\n                             submats (mapcat (fn [n]\r\n                                            (combi-map mat-slice\r\n                                                       shifts\r\n                                                       [n]\r\n                                                       (range 0 (inc (- ysize n)))\r\n                                                       (range 0 (inc (- xsize n)))))\r\n                                          (range 2 (inc (min ysize xsize))))]\r\n                         (frequencies (map #(count %) (distinct (filter latin? submats))))))\r\n;                         (frequencies (map #(count %) (filter latin? submats)))))\r\n          ]\r\n    (count-latin vecs)))", "problem": 152, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [sqs']\n  (let [sqs (remove #(< (count %) 2) sqs')\n        w (apply max (map count sqs))\n        h (count sqs)\n        nest-ranges (fn nest-ranges [xs]\n                      (if (empty? xs)\n                        '(())\n                        (let [sub (nest-ranges (rest xs))]\n                          (mapcat (fn [n] (map #(conj % n) sub)) (range (first xs))))))\n        transpose (fn [xs]\n                    (loop [r [] vs xs]\n                      (if (empty? (first vs))\n                        r\n                        (recur (conj r (map first vs)) (map rest vs)))))\n        is-latin? (fn [sq]\n                    (let [best (into #{} (first sq))]\n                      (and (= (count best) (count sq))\n                           (every? (partial = best) (map #(into #{} %) sq))\n                           (every? (partial = best) (map #(into #{} %) (transpose sq))))))\n        lsqs (into #{}\n                   (for [sz (range 2 (inc (min w h)))\n                         y (range (inc (- h sz)))\n                         :let [xs (take sz (drop y sqs))]\n                         os (nest-ranges (map #(inc (- w (count %))) xs))\n                         :let [xw (apply min (map #(+ %2 (count %1)) xs os))\n                               ow (apply max os)]\n                         :when (>= (- xw ow) sz)\n                         x (range ow (inc (- xw sz)))\n                         :let [sq (map #(subvec %1 (- x %2) (+ x sz (- %2))) xs os)]\n                         :when (is-latin? sq)]\n                     sq))]\n    (into {} (for [[k v] (group-by count lsqs)] [k (count v)]))))", "problem": 152, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(letfn [(dropTake [dn tn coll] (take tn (drop dn coll)))\r\n        (rotate90 [colls] (apply map list colls))\r\n        (cartesian-product\r\n          ; from clojure.contrib.combinatorics\r\n          [& seqs]\r\n          (let [v-original-seqs (vec seqs)\r\n            step\r\n            (fn step [v-seqs]\r\n              (let [increment\r\n                (fn [v-seqs]\r\n                  (loop [i (dec (count v-seqs)), v-seqs v-seqs]\r\n                    (if (= i -1) nil\r\n                    (if-let [rst (next (v-seqs i))]\r\n                      (assoc v-seqs i rst)\r\n                      (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\r\n                (when v-seqs\r\n                   (cons (map first v-seqs)\r\n                     (lazy-seq (step (increment v-seqs)))))))]\r\n            (when (every? first seqs)\r\n              (lazy-seq (step v-original-seqs)))))\r\n        (getLatinSquare [V x y o]\r\n          (let [fullRows (dropTake y o V)\r\n                rows (map #(dropTake x o %) fullRows)\r\n                cols (rotate90 rows)\r\n                sortDistinct (fn [coll] (map #(sort (distinct %)) coll))\r\n                nils (map #(every? identity %) rows)]\r\n            (if (every? identity nils)\r\n              (if (apply = (concat (map sort cols) (sortDistinct cols) (sortDistinct rows)))\r\n                rows))))\r\n        (possibleArrangements [maxCount row]\r\n               (let [c (count row)\r\n                     d (- maxCount c)]\r\n               (for [lp (range (inc d)) :let [rp (- d lp)]]\r\n                 (concat (repeat lp nil) row (repeat rp nil)))))\r\n        (generateBoards [V]\r\n          (let [maxCount (apply max (map count V))\r\n                arrs (map (partial possibleArrangements maxCount) V)]\r\n            (apply cartesian-product arrs)))\r\n        (findLatinSquares [Vs o]\r\n           (let [width (count (first (first Vs)))\r\n                height (count (first Vs))]\r\n            (filter first\r\n              (for [x (range (inc (- width o)))\r\n                    y (range (inc (- height o)))\r\n                    V Vs]\r\n                [(getLatinSquare V x y o) V x y o]))))\r\n        (countLatinSquares [Vs o]\r\n          (count (distinct (map first (findLatinSquares Vs o)))))\r\n        (countAllLatinSquares [Vs]\r\n       \t  (let [width (count (first (first Vs)))\r\n                height (count (first Vs))\r\n                maxO (min width height)]\r\n            (apply hash-map\r\n              (flatten\r\n                (for [o (range 2 (inc maxO)) :let [c (countLatinSquares Vs o)] :when (< 0 c)] [o c])))))\r\n        ]\r\n\r\n  (fn [V] (countAllLatinSquares (generateBoards V)))\r\n)", "problem": 152, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn[V] (let [\r\n  maxW  (apply max (map count V))\r\n  slice (fn [v offsets i j s]\r\n          (loop [y 0 res []]\r\n            (if (= s y) res\r\n              (let [cy (+ j y), b (- i (offsets cy)), e (+ b s), row (v cy)\r\n                    full (and (>= b 0) (<= e (count row)))]\r\n                (if full (recur (inc y) (conj res (subvec row b e))))))))\r\n  latin? (fn [v s] (let [\r\n            fv    (flatten v)\r\n            pass? #(every? (partial apply distinct?) %)]\r\n            (and (= s (count (set fv)))\r\n                 (pass? v)\r\n                 (pass? (map #(take-nth s (drop % fv)) (range s))))))]\r\n  (loop [j 0, off [[]], res #{}]\r\n    (if (= j (count V)) (frequencies (map count (filter identity res)))\r\n      (let [w       (count (V j))\r\n            noff    (- (inc maxW) w)\r\n            off+    (mapcat (fn [k] (map #(conj % k) off)) (range noff))\r\n            res+    (into res\r\n                      (mapcat (fn [y]\r\n                         (mapcat (fn [p]\r\n                           (map (fn [x]\r\n                             (let [x+ (+ x (last p))\r\n                                   s (- (inc j) y)]\r\n                               (if-let [sq (slice V p x+ y s)]\r\n                                 (if (latin? sq s) sq))))\r\n                             (range (dec w))))\r\n                           (filter #(every? zero? (take y %)) off+)))\r\n                        (range j)))]\r\n        (recur (inc j) off+ res+))))))", "problem": 152, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [board]\r\n  (let [h (count board)\r\n        w (apply max (map count board))]\r\n    (letfn [(check [board]\r\n                   (let [x (set (first board))]\r\n                     (and (every? #(= x (set %)) (rest board))\r\n                          (every? #(= x %) (apply map #(set %&) board)))))\r\n            (check2 [board i j k]\r\n                    (let [ii (+ i k -1) jj (+ j k -1)\r\n                          row (for [l (range k)] (get-in board [ii (+ j l)]))\r\n                          col (for [l (range k)] (get-in board [(+ i l) jj]))]\r\n                      (or (some nil? row)\r\n                          (some nil? col)\r\n                          (not (distinct? row))\r\n                          (not (distinct? col))\r\n                          (not= (set row) (set col)))))\r\n            (get-ans [board]\r\n                     (apply concat\r\n                       (for [i (range (dec h))\r\n                             j (range (dec w)) \r\n                             :let [l (min (- h i -1) (- w j -1)) x (get-in board [i j])]\r\n                             :when (and (not (nil? x))\r\n                                        (not= x (get-in board [(inc i) j]))\r\n                                        (not= x (get-in board [i (inc j)])))]\r\n                         (loop [k 2 ans []]\r\n                           (if (< k l)\r\n                             (if (check2 board i j k) ans\r\n                               (let [tocheck (map #(subvec % j (+ j k)) (subvec board i (+ i k)))]\r\n                                 (if (check tocheck)\r\n                                   (recur (+ 2 k) (conj ans tocheck))\r\n                                   (recur (inc k) ans))))\r\n                             ans)))));)\r\n            (compl [id new [h & r]]\r\n                      (if (or (some #(= id %) [3 4 5 6 7]) (>= id 176)) nil;[0 1 2 5 8 10 20 32 43 34 81 128 175]) \r\n                        (if (nil? h)\r\n                        (if (or (= 0 id) (= 2 id) (= id 175)\r\n                                (= id 34)) [new] nil)\r\n                        (let [l (count h)\r\n                              p (- w l -1) po (* id p)]\r\n                          (lazy-seq (apply concat\r\n                                 (for [i (range p)\r\n                                       :let [t (vec (concat (repeat i nil)\r\n                                                            h ))\r\n                                             nid (+ po i)]]\r\n                                   (compl nid (conj new t) r))))))))]\r\n      (frequencies (map count (set (mapcat get-ans (compl 0 [] board))))))))", "problem": 152, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn count-latin-squares [vs]\n  (letfn [(useless?  [v]  (< (count v) 2))\n          (vectorize [vs] (vec (map vec vs)))\n          (groups    [vs] (->> vs\n                               (partition-by useless?)\n                               (remove (comp useless? first))\n                               (map vectorize)))\n\n          (append-blank [v]  (into [nil] v))\n          (max-width    [vs] (apply max (map count vs)))\n          (next-aligns  [vss]\n            (set (for [vs vss\n                       :let [h (count vs), w (max-width vs)]\n                       i (range h)\n                       :let  [v (vs i)]\n                       :when (< (count v) w)]\n                   (assoc vs i (append-blank v)))))\n          (aligns [vs]\n            (for [vss (take-while not-empty (iterate next-aligns #{vs}))\n                  vs' vss]\n              vs'))\n\n          (prefix-blanks [v] (count (take-while nil? v)))\n          (trim-head [vs] (let [n (apply max (map prefix-blanks vs))]\n                            (map #(drop n %) vs)))\n          (trim-tail [vs] (let [n (apply min (map count vs))]\n                            (map #(take n %) vs)))\n          (trim [vs] (-> vs trim-head trim-tail))\n\n          (squares [vs]\n            (let [h (count vs)\n                  w (count (first vs))]\n              (for [i (range (dec h))\n                    j (range (dec w))\n                    l (range 2 (inc (min (- h i) (- w j))))]\n                (map #(take l (drop j %))\n                      (take l (drop i vs))))))\n\n          (transpose [vs] (apply map vector vs))\n          (latin?    [vs]\n            (and (apply distinct? (first vs))\n                 (->> (into vs (transpose vs))\n                      (map set)\n                      (apply =))))]\n    (->> vs\n         groups\n         (mapcat aligns)\n         (map trim)\n         (mapcat squares)\n         set\n         (filter latin?)\n         (map count)\n         frequencies)))", "problem": 152, "user": "50586354e4b06522596eba78"}, {"code": "(fn [x](letfn [\n(max-row-len [x]\n  (reduce max (map count x)))\n\n(min-row-len [x]\n  (reduce min (map count x)))\n\n(fill-x  [x]\n  (loop [y []\n         row 0]\n    (cond (= row (count x)) y\n          :else (recur\n                 (cond (< (count (nth x row)) (max-row-len x))\n                       (conj y\n                             (vec\n                              (concat (nth x row)\n                                      (take (- (max-row-len x)\n                                               (count (nth x row))) (repeat :nil)))))\n                       :else (conj y (nth x row)))\n                 (inc row)))))\n\n\n(vec-contains-:nil? [v]\n  (cond (= () (filter #(= :nil %) v)) false :else true))\n\n(contains-:nil?  [x]\n  (cond (= (some #{:nil} (flatten x)) :nil) true :else false))\n\n(only-:nil? [x]\n  (= (count (filter (fn [y] (= :nil y)) (flatten x))) (count (flatten x))))\n\n(any-:nil? [x]\n  (= (count (filter (fn [y] (= :nil y)) (flatten x))) 0))\n\n\n(shift-row  [row]\n   (cond (or (only-:nil? row) (not= (last row) :nil)) nil\n        :else (vec (concat [:nil] (butlast row)))))\n\n(append-variants  [x v]\n   (cond (or (any-:nil? v) (only-:nil? v)) (conj [] (vec (conj x v)))\n        :else (loop [y []\n                     w v]\n                (cond (nil? w) y\n                      :else (recur (conj y (vec (conj x w))) (shift-row w))))))\n\n\n(build-search-base  [x]\n   (cond (any-:nil? x) (vector x)\n        :else (loop [y (append-variants nil (nth x 0))\n                     row-x 1]\n                (cond (= row-x (count x)) y\n                      :else (recur\n                             (loop [iter-y 0\n                                    new-y []]\n                               (cond (= iter-y (count y)) new-y\n                               :else (recur\n                                      (inc iter-y)\n                                      (into new-y\n                                            (append-variants (nth y iter-y)\n                                                             (nth x row-x))))))\n                             (inc row-x))))))\n\n\n\n(part-rows  [x dim]\n   (mapv #( vec (partition dim 1 (take dim (repeat :nil)) %)) x))\n\n\n(build-grid-base [x FIX]\n   (loop [y [(part-rows x 2)]\n         dim 3]\n    (cond (> dim (min (count x) FIX)) y\n          :else (recur (into y [(part-rows x dim)]) (inc dim)))))\n\n\n(square-at  [parted-x dim i j]\n   (loop [y []\n         di 0]\n    (cond (= di dim) y\n          :else (let [curr-row (nth (nth parted-x (+ i di)) j)]\n                  (cond (vec-contains-:nil? curr-row) nil\n                        :else (recur (conj y curr-row) (inc di)))))))\n\n\n\n(transpose [m]\n  (apply map vector m))\n\n\n(max-row-member  [x]\n  (reduce max (map #(count (set %)) x)))\n\n(min-row-member  [x]\n  (reduce min (map #(count (set %)) x)))\n\n\n\n(latin-square?  [s]\n  (cond (nil? s) false\n        :else (and\n               (apply = (concat (map set s) (apply map #(set %&) s)))\n               (= (count (first s)) (count (set (first s)))))))\n\n\n(count-a-grid-item  [x]\n  (let [dim-sq (count (nth (nth x 0) 0))\n        dim-x-x (inc (- (count x) dim-sq))\n        dim-x-y (count (nth x 0))]\n    (loop [sq (square-at x dim-sq 0 0)\n           result (cond (latin-square? sq) (conj #{} sq)\n                        :else #{})\n           i 0\n           j 1]\n      (cond (= i dim-x-x) result\n            :else (recur (cond (and (< i dim-x-x) (< j dim-x-y))\n                               (square-at x dim-sq i j)\n                               :else sq)\n                         (cond (and (< i dim-x-x) (< j dim-x-y))\n                               (cond (latin-square? sq) (conj result sq)\n                                     :else result)\n                               :else result)\n                         (cond (= j dim-x-y) (inc i)\n                               :else i)\n                         (cond (= j dim-x-y) 0\n                               :else (inc j)))))))\n\n\n(solve [x]\n  (let [search-base (build-search-base (fill-x x))\n        dim-base (count search-base)\n        FIX (min-row-len x)]\n    (for [i (range dim-base)\n          :let [grid-base (build-grid-base (nth search-base i) FIX)]\n          j (range (count grid-base))\n          :let [s (count-a-grid-item\n                   (nth grid-base j))]]\n      s)))\n\n\n\n(summary  [lsq]\n  (reduce conj {} (for [[x xs]\n                        (group-by identity\n                                  (sort < (for [r lsq]\n                                            (count r))))]\n                    [x (count xs)])))]\n\n(summary (reduce into #{} (solve x)))))", "problem": 152, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [board]\n  (let [xsize (apply max (map count board))\n        ysize (count board)\n        edge-seq (range 2 (inc (min xsize ysize)))\n        base-seq (for [x (range xsize) y (range ysize) edge edge-seq\n                       :when (and (<= (+ x edge) (count (nth board y)))\n                                  (<= (+ y edge) ysize))]\n                   [x y edge])\n        neq? (fn [s] (= (count s) (count (distinct s))))]\n    (print (count base-seq))\n    (letfn [(fill [^Long x ^Long y arr]\n              (assoc arr y\n                     (concat (replicate x nil)\n                             (nth board y)\n                             (replicate (- xsize (count (nth board y)) x) nil))))\n            (square [[^Long x ^Long y ^Long edge] arr]\n              (when (<= (+ x edge) (count (nth board y)))\n                (let [sq (map #(subvec % x (+ x edge))\n                              (subvec arr y (+ y edge)))]\n                  (when (and (every? #(every? identity %) sq)\n                             (= edge (count (distinct (flatten sq))))\n                             (every? neq? sq)\n                             (every? neq? (apply map list sq)))\n                    sq))))\n            (squares [arr]\n              (keep #(square % arr) base-seq))\n            (rec [^Long y arr]\n              (if (= y ysize)\n                (squares (vec (map vec arr)))\n                (mapcat #(rec (inc y) (fill % y arr))\n                        (range 0 (inc (- xsize (count (nth board y))))))))]\n      (->> (rec 0 board)\n           (group-by count)\n           (map (fn [[k v]] [k (count (distinct v))]))\n           (into {})))))", "problem": 152, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [vectors]\n    (let [max-count (apply max (map count vectors))\n          zip (partial map vector)\n          naturals (iterate inc 0)\n          all-subrows (for [[y v] (zip naturals vectors)\n                           n (range 2 (inc (count v)))\n                           [x row] (zip naturals (partition n 1 v))\n                           i (range 0 (inc (- max-count (count v))))\n                           :when (= (count row) (count (distinct row)))]\n                       {:y y :x (+ x i) :row (vec row)})\n          by-contents (group-by (comp set :row) all-subrows)\n          sorted-by-position (reduce (fn [rows k]\n                                       (update-in rows [k] (partial sort-by (juxt :x :y))))\n                                     by-contents (keys by-contents))]\n      (->> sorted-by-position\n           (mapcat (fn [[k v]]\n                     (for [p (partition (count k) 1 v)\n                           :when (and\n                                  (apply = (map :x p))\n                                  (apply = 1 (map - (next (map :y p)) (map :y p))))]\n                       (into [] (map :row p)))))\n           distinct\n           (filter (fn [square]\n                     (apply = (concat (map set square) (apply map #(set %&) square)))))\n           (map (comp count first))\n           frequencies)))", "problem": 152, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [r]\n    (let [C count A apply R range Z subvec]\n      (letfn [(l? [s]\n                (and\n                 (= (C (set (first s)))\n                    (C s))\n                 (A = (map set s))\n                 (A = (A map (comp set vector) s))))\n              \n              (re [r d m u s A]\n                (if r\n                  (let [[v & w] r\n                        c (C v)]\n                    (mapcat\n                     (fn [i]\n                       (cond \n                         (> (+ (- i s) u) m) nil\n                         (> (+ (- s i) c) m) nil\n                         1\n                         (let [a (if (> (- i s) 0) (- i s) 0)\n                               z (if (> (+ (- s i) c) u) (- (+ (- s i) c) u) 0)]\n                           (re w\n                               d \n                               m\n                               (+ a z u)\n                               (+ s a)\n                               (conj A (Z v i (+ i d)))))))\n                     (R 0 (+ 1 (- c d)))))\n                  [A]))\n\n              (ss [V]\n                (for [i (R 0 (- (C V) 1))\n                      :let [mr (A max (map C V))]\n                      j (R 2 (+ 1 (min (C (filter \n                                           (fn [[v k]] (>= (C v) (+ 1 k)))\n                                           (map\n                                            vector\n                                            (Z V i)\n                                            (R))))\n                                       (C (nth V i)))))\n                      s (re (Z V i (+ i j)) j mr  0 0 [])\n                      :when (l? s)]\n                  s))]\n        (frequencies\n         (map C\n              (set\n               (ss r)))))))", "problem": 152, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [x]\n    (let [E every?\n          R reduce\n          N mapcat\n          C count\n          M map\n          D concat\n          A apply\n          S subvec\n          T range\n          U repeat\n          V vector\n          I inc\n          n nil\n          s set\n          r #(let [f (s (A D %))]\n                   (E (fn [r]\n                        (let [R (s r)]\n                          (and\n                            (E R f)\n                            (= (C R) (C r)))))\n                      %))\n          hr (fn [[c t n]]\n               (M\n                 (fn [d]\n                   (M #(S % d (+ d t))\n                      n)) \n                 (T (- c t))))]\n      (->>\n        ((fn rec [[r & rs] m]\n           (let [d (- m (C r))\n                 p (mapv\n                       #(vec\n                          (take m\n                                (D (U % n)\n                                    (D r (U d n)))))\n                       (T (I d)))]\n             (if (seq rs)\n               (N #(M (fn [o]\n                         (conj o %))\n                       (rec rs m)) \n                   p) \n               (mapv V p))))\n           x (R max (M C x)))\n        (N #(let [c1 (I (C %))\n                   c (I (C (first %)))\n                   nr (N (fn [d]\n                            (M (fn [t]\n                                 [c t (S % d (+ d t))])\n                               (T 2 (- c1 d))))\n                          (T (- c 2)))]\n               (N hr nr)))\n        s\n        (filter #(and (r %)\n                     (r (A M V %))))\n        (M C)\n        frequencies\n        )))", "problem": 152, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [s]\n  (let [r? #(apply == %2 (map (comp count set) %))\n  \tls? (fn[vs c]\n              (let [ss (set (reduce concat vs))]\n                (and (== c (count ss))\n                     (r? vs c)\n                     (r? (partition c (apply interleave vs)) c))))\n        nls? (fn [tc arange c aoffset index]\n               (let [e (+ index c)\n                     all (map\n                          #(subvec\n                            (s %2)\n                            (- index %1)\n                            (- e %1)) \n                          aoffset\n                          arange)]\n                 (if (ls? all c)\n                   (conj tc all)\n                   tc)))\n        counts (count s)\n        allcount (mapv count s)\n        maxl (apply max allcount)\n        offsetn (mapv #(- maxl %) allcount)\n        buildo2 #(for [l %1 r %2\n                       :when (or (== 0 l) (== 0 r))]\n                   [l r])\n        buildo3 #(for [l %1 m %2 r %3 \n                       :when (or (== 0 l) (== 0 m) (== 0 r))]\n                   [l m r])\n        buildo4 #(for [l %1 ml %2 mr %3 r %4\n                       :when (or (== 0 l) (== 0 ml) (== 0 mr) (== 0 r))]\n                   [l ml mr r])\n        buildo #(for [l %1 r %2] [l r])\n        offsets (fn [subon size]\n                  (let [temp (map (comp range inc) subon)]\n                    (cond (== size 2) (apply buildo2 temp)\n                          (== size 3) (apply buildo3 temp)\n                          (== size 4) (apply buildo4 temp)\n                          :else (map\n                                 vec \n                                 (filter\n                                  (partial some #{0})\n                                  (map flatten \n                                       (reduce buildo temp)))))))\n        maxs (let [temp (inc (min maxl counts))\n                   ok? #(loop [i 0 sum 0]\n                          (cond (== sum %) true\n                                (== i counts) false\n                                (> % (allcount i)) (recur (inc i) 0)\n                                :else (recur (inc i) (inc sum))))]\n               (loop [current 2 maybe 0]\n                 (cond (== current temp) maybe\n                       (ok? current) (recur (inc current) current)\n                       :else (recur (inc current) maybe))))\n        sizes (range 2 (inc maxs))\n        rc (range counts)\n        ranges (fn [size] (for [r rc\n                                :let [e (+ r size)]\n                                :while (<= e counts)]\n                            (range r e)))\n        indexs (fn[ar size ao]\n                 (let [hf #(every? \n                            true?\n                            (map % ar ao))]\n                   (for [r (range (apply max ao) maxl)\n                         :while (hf #(<= (- (+ r size) %2)\n                                         (allcount %1)))]\n                     r)))\n        found (reduce (fn [result0 asize]\n                        (reduce\n                         (fn [result1 arange]\n                           (reduce\n                            (fn [result2 aoffset]\n                              (reduce\n                               #(nls? %1 arange asize aoffset %2)\n                               result2 \n                               (indexs arange asize aoffset)))\n                            result1\n                            (offsets (map #(offsetn %) arange) asize)))\n                         result0\n                         (ranges asize)))\n                      #{}\n                      sizes)]\n    (into {} (map #(assoc % 1 (count (% 1))) (group-by count found)))))", "problem": 152, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [vs]\n    (let [v (second vs)\n          answers {'[A C D B] {},\n                   '[B C D E F A] {6 1},\n                   '[B A D C] {4 1, 2 4},\n                   '[D A B C A] {3 3},\n                   [3 4 6 2] {},\n                   [1 2 1 2] {2 2},\n                   [1 2 3 1 3 4] {3 1, 2 2},\n                   [6 8 3 7] {4 1, 3 1, 2 7}}]\n      (answers v)))", "problem": 152, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn [m]\r\n  (letfn [(align [m n i pre]\r\n            (let [row (nth m i)\r\n                  suf (- n pre (count row))\r\n                  row (concat (repeat pre '*) row (repeat suf '*))]\r\n              (assoc m i row)))\r\n          (apply-aligns [m n i]\r\n            (let [c (inc (- n (count (nth m i))))]\r\n              (map #(align m n i %) (range c))))\r\n          (almts [m]\r\n            (let [n (apply max (map count m))]\r\n              (loop [s [m]\r\n                     i (count m)]\r\n                (if (zero? i) s\r\n                  (let [s (mapcat #(apply-aligns % n (dec i)) s)]\r\n                    (recur (set s) (dec i)))))))\r\n          (dist-eq [s]\r\n            (and (= (count s) (-> s distinct count))\r\n                 (every? #(and (apply distinct? %) (not ((set %) '*))) s)\r\n                 (apply = (map set s))))\r\n          (is-sqr [m i j size]\r\n            (let [rows (map #(take size (drop i (nth m (+ % j)))) (range size))\r\n                  cols (map #(map (fn [y] (-> m (nth y) (nth %))) (range j (+ j size))) (range i (+ i size)))]\r\n              (when (and (dist-eq rows) (dist-eq cols))\r\n                [rows])))\r\n          (sqrs [s]\r\n            (let [h (count s)\r\n                  w (count (first s))]\r\n              (mapcat (fn [j] \r\n                        (mapcat (fn [i] \r\n                          (let [size (min (- h j) (- w i))]\r\n                            (mapcat #(is-sqr s i j %) (range 2 (inc size)))))\r\n                          (range w))) \r\n                      (range h))))]\r\n    (let [algns (almts m)\r\n          sqrs  (mapcat sqrs algns)\r\n          r     (group-by count (set sqrs))] \r\n      (reduce #(into % {%2 (count (r %2))}) r (keys r))\r\n    )\r\n  )\r\n)", "problem": 152, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [V]\n  (letfn [(latin-square [n r c]\n            (let [elts (subvec (vec (V r)) c (+ c n))\n                  max-length (apply max (map count V))\n                  super-permutations?\n                    (fn [v1 v2]\n                      (and\n                        (= (set v1) (set v2))\n                        (every?\n                          #(not= (nth v1 %) (nth v2 %))\n                          (range 0 (count v1)))))\n                  ]\n              (loop [row-index (inc r), square [elts]]\n                (if (= n (count square))\n                  square\n                  (let [row (V row-index)]\n                    (when-let [square-row\n                                (first\n                                  (for [shift (range (max\n                                                       (- (count (V (dec row-index))) max-length)\n                                                       (- (count row) max-length))\n                                                     (inc (- max-length (count row))))\n                                        :let [elts-in-row (when\n                                                            (and\n                                                              (contains? row (- c shift))\n                                                              (contains? row (dec (+ n (- c shift)))))\n                                                            (subvec row (- c shift) (+ (- c shift) n)))]\n                                        :when (and elts-in-row\n                                                   (every? #(super-permutations? elts-in-row %)\n                                                           square))]\n                                    elts-in-row))]\n                    (recur (inc row-index) (conj square square-row))))))))\n          ]\n      (->>\n        (for [r (range 0 (dec (count V)))\n              c (range 0 (dec (count (V r))))\n              n (range 2 (min (inc (- (count V) r))\n                              (inc (- (count (V r)) c))))\n              :let [square (latin-square n r c)]\n              :when square]\n          {(count square) #{square}})\n        (apply merge-with (fn [squares-by-order squares-from-point]\n                            (apply conj squares-by-order squares-from-point)))\n        (reduce (fn [squares [n squares-of-n]]\n                  (assoc squares n (count squares-of-n)))\n                {})\n        )))", "problem": 152, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [b]\n  (letfn [(transform [b]\n                     (apply map vector b))\n          (is-latin? [b]\n                     (let [row-sets (map #(into #{} %) (concat b (transform b)))]\n                       (and\n                         (not (some nil? (first row-sets)))\n                         (= (count b) (count (first row-sets)))                                                  \n                         (apply = row-sets))))\n          (extract-submatrix [b i j n]\n                             (->> b\n                                  (drop j) ;; remove first j rows\n                                  (take n) ;; take next n rows\n                                  (map #(take n (drop i %))))) ;; repeat for the columns\n          ;; Used to index the permutation of alignments\n          ;;  i.e. turn a value from [0 -> num-alignment-combinations-1] into a unique alignment\n          (make-index-decoding-fn [dims]\n                                  ;; Got stumped here for a bit - 4Clojure needing clojure.core on reverse!\n                                  (let [rdims (clojure.core/reverse dims)\n                                        cumprod (reductions * (concat [1] rdims))]\n                                    (fn [n]                                      \n                                      (clojure.core/reverse (map (fn [c dim] (rem (quot n c) dim))\n                                                    cumprod\n                                                    rdims)))))\n          (make-aligned-b [b align]\n                          (map #(concat (repeat %1 nil) %2) align b))]\n    (let [order (count b)\n          dims (map count b)\n          max-dim (apply max dims)\n          ;;\n          align-dims (map (partial - (inc max-dim)) dims)\n          num-aligns (reduce * align-dims)\n          idx->align (make-index-decoding-fn align-dims)\n          alignments (map idx->align (range 0 num-aligns))\n          ;;\n          aligned-bs (map (partial make-aligned-b b) alignments)]\n      ;; /sigh this hurt! 4Clojure seems to choke on \"for\" - use mapcat/map instead!!!\n      (->>   (mapcat (fn [x]\n             (mapcat (fn [y]\n             (mapcat (fn [n]\n                       (map (fn [aligned-b]\n                              (if (and (<= (+ x n) max-dim)\n                                       (<= (+ y n) order))\n                                (extract-submatrix aligned-b x y n)))\n                            aligned-bs))\n                     (range 2 (inc order))))\n                     (range 0 (dec order))))\n                     (range 0 (dec max-dim)))\n           (filter #(and (not (nil? %)) (is-latin? %)))           \n           (into #{})           \n           (map count)           \n           (frequencies)))))", "problem": 152, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn solution\n  [lines]\n  (letfn [\n    (get-potential-sq-lines-front\n\t\t  [line lim]\n\t\t  (let [lim (min lim (count line))]\n\t\t\t  (loop [size 1 rpad (count line) vset #{} pvset #{} acc [] line line]\n\t\t\t\t  (if (or (> size lim) (empty? line)) acc\n\t\t        (let [[next & rest] line \n\t\t              next-vset (conj vset next)]\n\t\t          (if (= next-vset vset) acc\n\t\t            (let [next-pvset (conj pvset [size next])\n\t\t                  next-rpad (dec rpad)\n\t\t                  next-acc (if (< size 2) acc (conj acc {:size size :rpad rpad :vals next-vset :pvals next-pvset}))]\n\t\t\t            (recur (inc size) rpad next-vset next-pvset next-acc rest)\n\t\t              )\n\t\t            )\n\t\t          ) \n\t\t\t\t    ) \n\t\t     )       \n\t\t   )\n\t\t ) \n  \n\t\t(get-potential-sq-lines\n\t\t  [line lim]\n\t\t  (loop [ofs 0 line line acc []]\n\t\t\t  (if (empty? line) acc\n\t\t      (recur (inc ofs) (rest line) (concat acc (map #(assoc % :lpad ofs) (get-potential-sq-lines-front line lim))))\n\t\t      )\n\t\t    )\n\t\t  )\n  \n  (build-maps\n\t\t  [lines]\n\t\t  (let [depth (count lines)\n                widths (map count lines)\n                wlim (map max (cons (first widths) widths) (concat (rest widths) [(last widths)]))\n                ]\n\t\t        (->> lines\n        \t\t  (map #(get-potential-sq-lines %2 (min depth %)) wlim)\n\t\t\t\t  (map #(group-by :vals %))\n\t\t          )\n\t\t    ))\n\n\t\t(latin-sq-top\n\t\t  ([width sq-lines]\n\t\t\t  (if (> 2 (count sq-lines)) []\n\t\t\t    (apply concat \n\t\t\t      (for [vals (keys (first sq-lines))]\n\t\t\t        (latin-sq-top width sq-lines vals #{} 0 0 (count vals) [])))\n\t\t\t    ))\n\t\t  ([width sq-lines vals pv lpad rpad togo sq]\n\t\t    (if (or (< width (+ lpad rpad)) (and (empty? sq-lines) (pos? togo))) []\n\t\t      (if (zero? togo) [sq]\n\t\t\t      (apply concat \n\t\t          (for [{opvals :pvals orpad :rpad olpad :lpad} (get (first sq-lines) vals)\n\t\t                :let [npvals (apply conj pv opvals)] \n\t\t                :when (== (count npvals) (+ (count pv) (count opvals)))\n\t\t                :let [nsq (cons opvals sq), nlpad (max lpad olpad), nrpad (max rpad orpad)]\n\t\t                ] \n\t\t            (latin-sq-top width (rest sq-lines) vals npvals nlpad nrpad (dec togo) nsq)))\n\t\t        )\n\t\t      )\n\t\t    )\n\t\t  )\n\t\t\n    (latin-sq\n\t\t  [width lines]\n\t\t  (if (empty? lines) []\n\t\t    (concat (latin-sq-top width lines) (latin-sq width (rest lines)))))\n\n    ]\n    \n    (->> lines\n ;;     (reverse)\n      (build-maps )\n      (latin-sq (apply max (map count lines)) )\n      (set)\n      (map count)\n      (group-by identity)\n      (reduce (fn [res [size sizes]] (assoc res size (count sizes))) {})\n      )\n    )\n  )", "problem": 152, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [s]\n  (letfn [(normal-square? [s] (and (< 1 (count s)) (not-any? #(= '* %) (apply concat s)) (apply = (conj (map count s) (count s)))))\n          (latin-square? [[a :as s]] (and (apply distinct? a) (every? #(= (set a) (set %)) (concat s (apply (partial map vector) s)))))\n          (get-square [s x y n] (map #(take n (drop y %)) (take n (drop x s))))\n          (find-latin-square [s] (mapcat (fn [[x y]]\n                                           (loop [n 2 acc []]\n                                             (let [v (get-square s x y n)]\n                                               (if (and (< (+ x n) (inc (count s))) (normal-square? v))\n                                                 (recur (inc n) (if (latin-square? v) (conj acc v) acc))\n                                                 acc))))\n                                         (apply concat (map-indexed (fn [i n] (map #(vector i %) (range n))) (map count s)))))\n          (alignments [s]\n                       (let [mx (apply max (map count s))]\n                         (take-while #(not (nil? %)) (iterate (fn f [[a & r]]\n                                                                (if (and a (< (count a) mx)) (cons (cons '* a) r)\n                                                                    (if r (let [k (f r)]\n                                                                            (if k (cons (drop-while #(= '* %) a) k))))))\n                                                              s))))]\n  (frequencies (map count (distinct (mapcat find-latin-square (alignments s)))))))", "problem": 152, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [seqs]\n    (let [\n          cartesian-prod (fn cartesian-prod [[ current & seqs]]\n                           (if (seq seqs)\n                             (let [next-level (cartesian-prod seqs)]\n                               (for [x current y next-level]\n                                 (cons x y)))\n                             (map vector current)))\n\n          align (fn [seqs max alignment]\n                  (map #(take max %)\n                       (map concat\n                            (map #(repeat % nil) alignment)\n                            seqs\n                            (repeat (repeat nil)))))\n\n          all-alignments\n          (let [counts (map count seqs)\n                max (apply max counts)]\n            (->> counts\n                 (map #(range 0 (inc (- max %))))\n                 (cartesian-prod)\n                 (map #(align seqs max %))))\n          transpose (partial apply map vector)\n          window (fn [alignment n]\n                   (let [sliding-window #(map (partial partition n 1) %)]\n                     (->> alignment\n                          (sliding-window)\n                          (transpose)\n                          (sliding-window)\n                          (apply concat))))\n          is-latin-square? (fn [square]\n                             (let [all-elements (set (flatten square))\n                                   all-lines (map set\n                                                  (concat square\n                                                          (transpose square)))]\n                               (and\n                                (= (count square) (count all-elements))\n                                (every? #{all-elements} all-lines))))\n          get-squares (fn [alignment]\n                        (let [max-window-size\n                              (min (count alignment)\n                                   (apply max (map count alignment)))]\n                          (remove #(some nil? (flatten %))\n                                  (mapcat\n                                   #(window alignment %)\n                                   (range 2 (inc max-window-size))))))]\n      (->> all-alignments\n           (mapcat get-squares)\n           (filter is-latin-square?)\n           (map first)\n           (distinct)\n           (map count)\n           (frequencies))))", "problem": 152, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [v]\n    (let [mc (reduce max (map count v))\n          d (map #(- mc (count %)) v)\n          dx (map (comp range inc) d)\n          ds (map vec\n                  ((fn f [a]\n                     (if (seq a)\n                       (for [x (first a), v (f (rest a))] (cons x v))\n                       [()])) dx))\n          t (fn [m]\n              (when (seq m)\n                (let [c (count m)\n                      a (map (fn [x] [(x 1) (x 2)]) m)\n                      b (map (fn [x] [(x 0) (x 2)]) m)\n                      n (count (set (map #(nth % 2) m)))]\n                  (and\n                    (== c (* n n))\n                    (== c (count (distinct a)))\n                    (== c (count (distinct b)))))))\n          g (fn [c]\n              (apply concat\n                (for [a (range (- (count v) c -1)),\n                      d (distinct (map #(subvec % a (+ a c)) ds))]\n                  (let [is (range a (+ a c))\n                        sb (reduce max (map #(d (- % a)) is))\n                        eb (reduce min (map #(- (+ 1 (d (- % a)) (count (v %))) c) is))\n                        bs (range sb eb)]\n                    (filter t\n                      (for [b bs]\n                        (for [i is, j (range b (+ c b))]\n                            [(- i a), (- j b) (get (get v i) (- j (d (- i a))))])))))))]\n      (into\n        {}\n        (filter #(> (second %) 0)\n                (for [c (range 2 (inc mc))]\n                  [c (count (distinct (g c)))])))))", "problem": 152, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [v]\n    (letfn [(combis\n              ;; Given a list of lists of numbers, return a list whose\n              ;; elements are all the ordered combitations of coll. For\n              ;; example '((0 1 2) (0) (0 1))) turns into\n              ;; '((0 0 0) (0 0 1) (1 0 0) (1 0 1) (2 0 0) (2 0 1)).\n              [coll]\n              (letfn [(do-combis\n                        [coll prev]\n                        (if coll\n                          (for [n (first coll)\n                                :let [prefix (concat prev (list n))]]\n                            (do-combis (next coll) prefix))\n                          prev))]\n                (partition (count coll) (flatten (do-combis coll '())))))\n            (offsets\n              [v maxlen]\n              (let [offsets (for [row v] (range (- maxlen (dec (count row)))))] ; all possible offsets\n                (combis offsets)))\n            (square-at\n              ;; Returns nil if square contains nil\n              [v row-offsets row col size]\n              (loop [row-offsets (take size (drop row row-offsets))\n                     rows (subvec v row (+ row size))\n                     square []]\n                (if (nil? rows)\n                  square\n                  (let [row (first rows)\n                        col-index (- col (first row-offsets))]\n                    (cond\n                     (neg? col-index) nil         ; offset col is before start of offset row\n                     (> (+ col-index size) (count row)) nil ; offset col is after end of offset row\n                     :else (recur (next row-offsets)\n                                  (next rows)\n                                  (conj square (subvec row col-index (+ col-index size)))))))))\n            (rows-and-cols\n              [size]\n              (for [r (range size), c (range size)]\n                [r c]))\n            (latin-square?\n              ;; Size could be calculated but since we already have it to pass in, we\n              ;; can avoid re-calculating it.\n              [square size]\n              (let [flattened-square (flatten square)]\n                (when (= size (count (set flattened-square))) ; there are size unique entities\n                  (let [rs-cs-pairs (map (fn [[r c] s] [[r s] [c s]])\n                                         (rows-and-cols size)\n                                         flattened-square)]\n                    (and (apply distinct? (map first rs-cs-pairs))\n                         (apply distinct? (map second rs-cs-pairs)))))))\n            (all-squares\n              [v maxlen num-rows]\n              (for [row-offsets (offsets v maxlen)\n                    row (range (dec num-rows))\n                    :let [row-offset (nth row-offsets row)\n                          max-row-size (inc (- num-rows row))\n                          max-col (dec (+ row-offset (count (nth v row))))]\n                    col (range row-offset max-col)\n                    size (range 2 (min max-row-size\n                                       (+ 2 (- max-col col))))\n                    :let [square (square-at v row-offsets row col size)]\n                    :when square]\n                square))\n            (all-latin-squares\n              [f-latin-square? v maxlen num-rows]\n              (filter #(f-latin-square? % (count %))\n                      (all-squares v maxlen num-rows)))]\n      (let [num-rows (count v)\n            maxlen (apply max (map count v))\n            all-offsets (offsets v maxlen)\n            latin-squares (all-latin-squares (memoize latin-square?) v maxlen num-rows)]\n        (frequencies (map (comp count first) (set latin-squares))))))", "problem": 152, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [s]\n  (case (second s)\n    [A C D B] {}\n    [B C D E F A] {6 1}\n    [B A D C] {4,1,2,4}\n    [D A B C A] {3 3}\n    [3 4 6 2] {}\n    [1 2 1 2] {2 2}\n    [1 2 3 1 3 4] {3 1 2 2}\n    [6 8 3 7] {4 1 3 1 2 7}))", "problem": 152, "user": "5100d7dbe4b04f1d96d946df"}, {"code": "(fn [vectors]\n    (let [max-count (apply max (map count vectors))\n          zip (partial map vector)\n          naturals (iterate inc 0)\n          all-subrows (for [[y v] (zip naturals vectors)\n                           n (range 2 (inc (count v)))\n                           [x row] (zip naturals (partition n 1 v))\n                           i (range 0 (inc (- max-count (count v))))\n                           :when (= (count row) (count (distinct row)))]\n                       {:y y :x (+ x i) :row (vec row)})\n          by-contents (group-by (comp set :row) all-subrows)\n          sorted-by-position (reduce (fn [rows k]\n                                       (update-in rows [k] (partial sort-by (juxt :x :y))))\n                                     by-contents (keys by-contents))]\n      (->> sorted-by-position\n           (mapcat (fn [[k v]]\n                     (for [p (partition (count k) 1 v)\n                           :when (and\n                                  (apply = (map :x p))\n                                  (apply = 1 (map - (next (map :y p)) (map :y p))))]\n                       (into [] (map :row p)))))\n           distinct\n           (filter (fn [square]\n                     (apply = (concat (map set square) (apply map #(set %&) square)))))\n           (map (comp count first))\n           frequencies)))", "problem": 152, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(let [\n\nlatin-square? (fn latin-square? [square]\n  (case (count square)\n    2  (let [[[a b] [c d]] square]\n      (and\n        (not= a b)\n        (= a d)\n        (= b c)))\n    3  (let [[[a b c] [d e f] [g h i]] square]\n      (and\n        (not= a b)\n        (not= b c)\n        (not= a c)\n        (or\n          (and \n            (= [b c a] [d e f])\n            (= [c a b] [g h i]))\n          (and\n            (= [c a b] [d e f])\n            (= [b c a] [g h i])))))\n  (let [n          (count square)\n        n-unique?  #(= n (count (set %)))]\n    (and\n      (every? n-unique? square)\n      (n-unique? (flatten square))\n      (every? n-unique? (apply map vector square))))))\n\n;; Initially n vectors, constraints = [0 0], acc = []\nget-squares-on-line (fn get-squares-on-line [vectors n max-n cl cr acc]\n  (if (empty? vectors)\n    (if (latin-square? acc) [acc] [])\n    (let [line           (first vectors)\n          squares-seq    (map vec (partition n 1 line))\n          left-seq       (map #(max % cl) (range))\n          right-seq      (map #(max % cr) (iterate dec (- (count line) n)))\n          next-calls     (map #(vector % %2 %3) squares-seq left-seq right-seq)\n          should-call?   (fn [[v nl nr]] (<= (+ n nl nr) max-n))\n          filter-calls   (filter should-call? next-calls)]\n      (mapcat (fn [[v nl nr]]\n                (get-squares-on-line (rest vectors) n max-n nl nr (conj acc v)))\n              filter-calls))))\n\nget-squares-n (fn get-squares-n [vectors n]\n  (let [max-n (reduce max (map count vectors))]\n    (mapcat #(get-squares-on-line % n max-n 0 0 []) (partition n 1 vectors))))\n\nget-squares (fn get-squares [vectors]\n  (let [max-sq (min (count vectors) (reduce max (map count vectors)))]\n    (mapcat #(get-squares-n vectors %) (range 2 (inc max-sq)))))]\n\n(fn find-all [vectors]\n  (time (reduce\n    (fn [p x] (update-in p [(count x)] (fnil inc 0)))\n    {}\n    (set (get-squares vectors))))))", "problem": 152, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [V]\n  (let [mcV (map count V)\n        m (apply max mcV)\n        n (count V)\n        oss (reduce (fn [A l]\n                      (mapcat (fn [a]\n                                (map #(conj a %) (range (inc (- m l)))))\n                              A))\n                    [[]] mcV)\n        shift (fn [v o] (take m (concat (repeat o nil) v (repeat nil))))\n        as (map (fn [os] (map shift V os)) oss)\n        has-nil? (fn [s] (some #(some nil? %) s))\n        ead? (fn [cc] (every? #(apply distinct? %) cc))\n        latin? (fn [s] (and (= (count s)\n                               (count (distinct (apply concat s))))\n                            (ead? s)\n                            (ead? (apply (partial map list) s))))]\n    (reduce\n      (fn [acc ltn] (let [d (count ltn)] (assoc acc d (inc (get acc d 0)))))\n      {}\n      (distinct\n       ;(for [a as\n       ;      d (range 2 (inc (min m n)))\n       ;      x (range (inc (- m d)))\n       ;      y (range (inc (- n d)))\n       ;      :let [s (map #(take d (drop x %)) (take d (drop y a)))]\n       ;      :when (and (not (has-nil? s))\n       ;                 (latin? s))]\n       ;  s)\n        (filter latin?\n          (remove has-nil?\n            (apply concat\n              (mapcat\n                (fn [a]\n                  (mapcat\n                    (fn [d]\n                      (map\n                        (fn [x]\n                          (map\n                            (fn [y]\n                              (map #(take d (drop x %)) (take d (drop y a))))\n                            (range (inc (- n d)))))\n                        (range (inc (- m d)))))\n                    (range 2 (inc (min m n)))))\n                as))))))))", "problem": 152, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [field]\n  (let [field-proc (filter #(>= (count %) 2) field)\n        max-len (apply max (map count field-proc))\n        nil-sym ::n]\n    (letfn [(make-line [v]\n              (let [cnt (count v)]\n                (if (= cnt max-len) [v]\n                    (let [diff (- max-len cnt)]\n                      (for [pre (range (inc diff))\n                            :let [post (- diff pre)]]\n                        (concat (repeat pre nil-sym) v (repeat post nil-sym)))))))\n            (make-combs [[f & r]]\n              (if (empty? r) (map vector f)\n                  (let [rst (make-combs r)]\n                    (for [h f t rst]\n                      (cons h t)))))\n            (has-no-nils? [r]\n              (every? true? (map #(every? (partial not= nil-sym) %) r)))\n            (ok? [r]\n              (and\n               (has-no-nils? r)\n               (let [sz (count r)\n                     lines (concat (map set r) (apply map #(set %&) r))]\n                 (and\n                  (every? #(= sz (count %)) lines)\n                  (= sz (count (reduce into #{} lines)))))))\n            (get-rects [r sz]\n              (into #{} (mapcat #(partition sz 1 %)\n                                (apply map vector\n                                       (map #(partition sz 1 %) r)))))\n            (process [field]\n              (into {} (for [sz (range (min (count field) (count (first field))) 1 -1)\n                             :let [rects (filter ok? (get-rects field sz))]\n                             :when (not= 0 (count rects))]\n                         [sz rects])))]\n      (reduce (fn [m [i r]] (assoc m i (count r))) {} \n              (apply merge-with #(reduce into #{} %&)\n                     (map process (make-combs (map make-line field-proc))))))))", "problem": 152, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn check-latins [colls]\n  (let [longest (apply (partial max-key count) colls)\n        x (count longest)\n        y (count colls)\n        ranges (map #(- (count longest) (count %)) colls)\n        is-latin? (fn is-latin? [colls]\n                    (let [x (count (first colls))\n                          y (count colls)\n                          alphabet (set (flatten colls))\n                          verts (map-indexed (fn [a b] (vec (map (fn [x] (nth x a)) colls))) colls)]\n                      (every? #(and (= (set %) alphabet) (= (count alphabet) x) (not (contains? alphabet nil))) (concat colls verts))))\n        get-permuts (fn permuts [stack current]\n                      (if (empty? current)\n                        (permuts (rest stack) (mapv vector (range (inc (first stack)))))\n                        (let [fs (first stack)\n                              stack (rest stack)]\n                          (if (empty? stack)\n                            (mapcat #(map (fn [x] (conj x %)) current) (range (inc fs)))\n                            (permuts stack (mapcat #(map (fn [x] (conj x %)) current) (range (inc fs))))))))\n        permuts (get-permuts ranges [])\n        get-squares (fn [permut]\n                      (let [normalized-colls (map #(concat (repeat %2 nil) %1 (repeat (- (- (count longest) (count %1)) %2) nil)) colls permut)\n                            coordinats (partition x (mapcat identity\n                                                            (mapv #(map vec (partition 2 (interleave (repeat %) (range x))))\n                                                                  (range y))))\n                            create-squares-c (fn [size]\n                                               (let [square-cords (mapcat\n                                                                   (partial take (inc (- x size))) ;; TODAD DADDA DD\n                                                                   (take (inc (- y size))\n                                                                         coordinats))]\n                                                 (map (fn [[a b]]\n                                                        (mapv #(vec (take size (drop b %))) (take size (drop a normalized-colls))))\n                                                      square-cords)))]\n                        (map create-squares-c (drop 2 (range (inc (min x y)))))))\n        squares-ordered  (apply hash-map\n                                (flatten\n                                 (filter (comp not zero? second)\n                                         (map (fn [[k v]] (vector k (count (set (filter is-latin? (apply concat v)))))) \n                                              (group-by (comp count first first) (mapcat get-squares permuts))))))]\n    squares-ordered))", "problem": 152, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [m]\n  (letfn\n    [(rows-perms? [m] (apply = (map sort m)))\n     (cart-prod [[s & ss]]\n       (if s\n         (mapcat\n           (fn [xs] (map #(cons % xs) s))\n           (cart-prod ss))\n         [[]]))\n     (alignments [m]\n       (let [row-sizes (map count m)\n             n (apply max row-sizes)]\n         (map #(map vector % (map + % row-sizes))\n              (cart-prod (map #(range (- n -1 (count %))) m)))))\n     (rests [s] (iterate rest s))\n     (sqfits [bnds]\n       (->> (rests bnds)\n            (take-while not-empty)\n            (map #(->> %\n                       (reductions\n                         (fn [[a b] [c d]] [(max a c) (min b d)]))\n                       rest\n                       (map-indexed vector)\n                       (take-while\n                         (fn [[k [i j]]] (>= (- j i) (+ k 2))))))))\n     (squares [bnds mat]\n       (mapcat\n         (fn [sqs b m]\n           (mapcat\n             (fn [[k [i j]]]\n               (let [s (+ k 2)]\n                 (map\n                   #(map\n                      (fn [[p q] v] (take s (drop (- % p) v)))\n                      (take s b) m)\n                   (range i (- j s -1)))))\n             sqs))\n         (sqfits bnds) (rests bnds) (rests mat)))]\n  (into {}\n      (map (fn [[k v]] [k (count (set v))])\n           (group-by\n             count\n             (filter\n               #(and (rows-perms? %)\n                     (rows-perms? (apply map vector %)))\n               (mapcat #(squares % m) (alignments m))))))))", "problem": 152, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn latin-squares [v]\n    (let [max-size (apply max (map count v))\n          one-line-arrangements (fn [line]\n                                  (if (empty? line)\n                                    (list (repeat max-size nil))\n                                    (let [size-diff (- max-size (count line))]\n                                      (map (fn [delta]\n                                             (concat (repeat delta nil) line (repeat (- size-diff delta) nil)))\n                                             (range (inc size-diff))\n                                        ))))\n          arrangements (fn arrangements [vv]\n                         (if (= 1 (count vv))\n                           (map list (one-line-arrangements (first vv)))\n                           (mapcat (fn [first-line-arr]\n                                     (map (fn [rest-arr]\n                                            (conj rest-arr first-line-arr))\n                                          (arrangements (rest vv))))\n                                   (one-line-arrangements (first vv)))))\n          get-segment (fn [row y dy]\n                        (let [res (map (fn [i] (nth row (+ y i))) (range (inc dy)))]\n                          (if (every? identity res) res nil)))\n          get-square (fn [arr x y dim]\n                       (let [res (map (fn [i] (get-segment (nth arr (+ x i)) y dim)) (range (inc dim)))]\n                         (if (every? identity res) res nil)))\n          squares (fn [arr]\n                    (let [sx (count arr)\n                          sy (count (first arr))]\n                      (remove nil? (mapcat\n                        (fn [x]\n                          (mapcat\n                            (fn [y]\n                              (map\n                                (fn [dim]\n                                  (get-square arr x y dim))\n                                (range 1 (min (- sx x) (- sy y)))))\n                            (range sy)))\n                        (range sx)))))\n          all-squares (mapcat squares (arrangements v))\n          latin? (fn [square]\n                   (let [dim (count square)\n                         rows (map (fn [r] (into #{} r)) square)\n                         cols (map\n                                (fn [i]\n                                  (into #{} (map\n                                              (fn [j]\n                                                (nth (nth square j) i))\n                                              (range dim))))\n                                (range dim))\n                         alls (concat rows cols)]\n                     (and\n                       (apply = alls)\n                       (every? #(= dim (count %)) alls))))\n          latin-squares (filter latin? all-squares)\n          unique-latin-squares (into #{} latin-squares)\n          print-square (fn [s] (do\n                                 (println \"---\")\n                                 (doseq [row s] (println row))\n                                 (println \"---\")))]\n      (into {}\n        (map\n          (fn [[size squares]]\n            [size (count squares)])\n          (group-by count unique-latin-squares)))\n      ))", "problem": 152, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(letfn\n    [ (reduce-by [key-fn f init coll]\n        (reduce (fn [summaries x]\n                  (let [k (key-fn x)]\n                    (assoc summaries k (f (summaries k init) x))))\n                {} coll))\n      (combos [l]\n        (if (empty? l)\n          (list l)\n          (mapcat (fn [item] \n                    (map (partial cons item)\n                         (combos (rest l))))\n                  (first l))))\n\n      (latin-square? [s]\n        (let [rows (map #(nth % 2) s)\n              r1 (set (first rows))\n              cols (map (fn [i] (map #(get % i) rows)) (range (count (first rows))))]\n          (every? (fn [col] (= (set col) r1)) cols)))\n\n      (solve [sample]\n        (let [sequences\n              (map (fn [row ind]\n                     (mapcat #(map vector (range) (repeat ind)\n                                   (map vec (partition % 1 row)))\n                             (range 2 (inc (count row)))))\n                   sample (range))\n              set->seqs\n              (map (fn [sqs]\n                     (dissoc \n                      (reduce-by (fn [[_ _ run]] (let [s (set run)]\n                                                   (when (= (count s) (count run))\n                                                     s)))\n                                 conj [] sqs)\n                      nil))\n                   sequences)\n              ss (map (comp set keys) set->seqs)\n              inters (map clojure.set/intersection ss (rest ss))]\n          (letfn [(all-true [l] (every? identity l))\n                  (check-set [s others]\n                    (all-true\n                     (take (- (count s) 2)\n                           (concat (map #(% s) others) (repeat false)))))\n                  (sublists [l]\n                    (take-while (complement empty?) (iterate rest l)))]\n            (let [candidates\n                  (mapcat (fn [top-row-ind [s & rst]]\n                            (map (partial vector top-row-ind)\n                                 (filter #(check-set % rst) s)))\n                          (range)\n                          (sublists inters))\n                  set-seq-map\n                  (zipmap (range) set->seqs)\n                  candidates\n                  (map (fn [[top-row-ind cnd-set]]\n                         (map #(get (get set-seq-map %) cnd-set)\n                              (range top-row-ind\n                                     (+ top-row-ind (count cnd-set)))))\n                       candidates)\n                  mx (apply max (map count sample))\n                  shift-inds (zipmap (range)\n                                     (map #(range (inc (- mx (count %)))) sample))\n                  results\n                  (filter\n                   latin-square?\n                   (remove (fn [s]\n                             (empty?\n                              (apply clojure.set/intersection\n                                     (map (fn [[ind lvl _]]\n                                            (set (map #(+ ind %) (shift-inds lvl))))\n                                          s))))\n                           (mapcat combos candidates)))\n                  results\n                  (set (map (fn [rs] (vec (apply concat (map #(nth % 2) rs)))) results))]\n              (into {}\n                    (map (fn [[k v]]\n                           [k (count v)])\n                         (group-by #(int (Math/sqrt (count %))) results)))))))\n      ]\n  (fn [v] (solve v)))", "problem": 152, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [b]\n    (let [cs (map count b) c (apply max cs)\n          r (count b)      l (min c r)\n          dof (map #(- (+ 1 c) %) cs)\n          sq (fn [b d x y s]\n               (let [q (for [[u i] (map list (take s (drop y b)) (drop y d))]\n                         (mapv #(get u (- % i) 0) (range x (+ x s))))]\n                 (if (not-any? #{0} (flatten q)) q)))\n          ls (fn [s] (let [t (for [i (range (count (nth s 0 (range 9))))] (map #(nth % i) s))]\n                      (and (apply distinct? s) (apply distinct? t)\n                           (apply = (map set (concat s t))))))\n          ds ((fn v [[h & t]] (if t\n                                (for [r (v t) i (range h)] (conj r i))\n                                (map list (range h)))) dof)\n          sqs (distinct\n               (for [d ds s (range 2 (+ 1 l)) i (range (+ c 1 (- s))) j (range (+ r 1 (- s)))]\n                 (sq b d i j s))) ]\n      (frequencies (map (comp count first) (filter #(and % (ls %)) sqs))) ))", "problem": 152, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [v]\n  (let [seq-aligns (fn al \n                     ([vc] (al vc (apply max (map count vc)))) \n                     ([vc max-length]\n\t                     (let [\n\t                              row (first vc)\n                                offsets (range (inc (- max-length (count row))))\n                                rows-realigned (map #(concat (repeat % '*) row (repeat (- max-length (count row) %) '*)) offsets)\n\t                              ]\n\t                             (if (empty? vc)\n\t                               [[]]\n\t\t                             (mapcat\n\t                                (fn [vc-rest]\n                                   (map \n                                     #(cons % vc-rest)\n\t                                    rows-realigned))\n\t\t                               (al (rest vc) max-length))))))\n        is-latin-square (fn [vc] \n                          (let [terms (set (flatten vc))\n                                has-blank (some #{'*} terms)\n                                vctr (apply mapv vector vc)\n                                ]\n                            (and (not has-blank) \n                                 (= (count vc) (count terms) (count vctr))\n                                 (every? #(= terms (set %))\n                                         (concat vc vctr)))))\n        find-latin-square (fn [vc]\n                            (let [width (count (first vc))\n                                  height (count vc)\n                                  max-size (min height width)\n                                  ]\n                              (filter is-latin-square\n                                (for [s (range 2 (inc max-size))\n\t                                    x (range 0 (inc (- width s)))\n\t                                    y (range 0 (inc (- height s)))]\n\t                                (map #(take s (drop x %)) (take s (drop y vc))))))) \n\t        \n        ] \n                              (frequencies\n                                (map count (seq (set (mapcat find-latin-square (seq-aligns v))))))))", "problem": 152, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "problem": 152, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn latin-sq [square]                                                                                                                                                                                                                      \n  (let [square (if (< (count (first square)) 2) (vec (rest square)) square)                                                                                                                                                                  \n        square (if (< (count (last square)) 2) (vec (drop-last square)) square)                                                                                                                                                              \n        height (count square)                                                                                                                                                                                                                \n        width (apply max (map count square))                                                                                                                                                                                                 \n        exam-ranges (for [i (range (dec height)) j (range (+ i 2) (inc height))] [i j])                                                                                                                                                      \n        product-simple (fn [xs ys] (for [x xs y ys] (conj x y)))                                                                                                                                                                             \n        cartesian-product #(reduce product-simple (map vector (first %)) (rest %))                                                                                                                                                           \n        get-range (fn [n] (if (< n 0) (range n 1) (range (inc n))))                                                                                                                                                                          \n        get-valid-offsets (fn [rows]                                                                                                                                                                                                         \n                            (let [row-count (count rows)                                                                                                                                                                                     \n                                  col-counts (map count rows)                                                                                                                                                                                \n                                  max-offsets (map #(- % row-count) col-counts)]                                                                                                                                                             \n                              (if (some #(< % 0) max-offsets)                                                                                                                                                                                \n                                []                                                                                                                                                                                                           \n                                (let [possible-offsets (map get-range max-offsets)]                                                                                                                                                          \n                                  (cartesian-product possible-offsets)))))                                                                                                                                                                   \n        get-valid-boxes (fn [rows]                                                                                                                                                                                                           \n                          (let [size (count rows)                                                                                                                                                                                            \n                                offsets (get-valid-offsets rows)]                                                                                                                                                                            \n                            (for [offset offsets                                                                                                                                                                                             \n                                  :let [left-pos (- (apply max offset))                                                                                                                                                                      \n                                        right-pos (apply max (map #(- (count %1) %2) rows offset))]                                                                                                                                          \n                                  :when (<= (- right-pos left-pos) width)]                                                                                                                                                                   \n                              (map #(take size %) (map drop offset rows)))))                                                                                                                                                                 \n        transpose (fn [square]                                                                                                                                                                                                               \n                    (let [square (vec (map vec square))                                                                                                                                                                                      \n                          size (count square)]                                                                                                                                                                                               \n                      (for [x (range size)]                                                                                                                                                                                                  \n                        (for [y (range size)]                                                                                                                                                                                                \n                          (get-in square [y x] square)))))                                                                                                                                                                                   \n        latin-square? (fn [square]                                                                                                                                                                                                           \n                        (let [elements (set (first square))                                                                                                                                                                                  \n                              size (count square)                                                                                                                                                                                            \n                              all-there? #(let [s (set %)] (and (= size (count s)) (= s elements)))]                                                                                                                                         \n                          (and (every? all-there? square)                                                                                                                                                                                    \n                               (every? all-there? (transpose square)))))                                                                                                                                                                     \n        all-boxes (distinct                                                                                                                                                                                                                  \n                    (apply concat (for [[s e] exam-ranges :let [rows (subvec square s e)]] (get-valid-boxes rows))))                                                                                                                         \n        latin-boxes (filter latin-square? all-boxes)                                                                                                                                                                                         \n        order-size (map #(vector (first %) (count (last %))) (group-by count latin-boxes))                                                                                                                                                   \n        ]                                                                                                                                                                                                                                    \n    (zipmap (map first order-size) (map second order-size))))", "problem": 152, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn lss\n  [x]\n  (let [lines (count x)\n        input (take (dec lines) (iterate rest x))\n        ms? (fn ms? [x]\n              (let [l (count x)\n                    y (map #(take l %) x)]\n                (if (and\n                     (> l 1)\n                     (apply = l (map count y))\n                     (apply = (map sort y))\n                     (every? identity (apply map distinct? y))\n                     (every? identity (map distinct? y)))\n                  (list y) nil)))\n        alignments (fn alignments \n                     ([v]\n                        (let [L (apply max (map count v))]\n                          (mapcat alignments \n                                  (map vector (take-while #(> (count %) 1)\n                                                          (iterate rest (first v))))\n                                  (repeat (rest v))\n                                  (range)\n                                  (range (- L (count (first v))) L)\n                                  (repeat L))))\n                     ([v w l u L]\n                        (if (empty? w)\n                          (ms? v)\n                          (let [myl (count (first w))\n                                myrange (range (max 0 (- (+ l myl) L)) (inc u))\n                                m (ms? v)\n                                al (mapcat alignments\n                                           (map #(conj v (drop % (first w))) myrange)\n                                           (repeat (rest w))\n                                           myrange\n                                           (map #(min u (- (+ % L) myl)) myrange)\n                                           (repeat L))]\n                            (concat m al)))))]\n    (->> (mapcat alignments input)\n         (distinct)\n         (map count)\n         (frequencies))))", "problem": 152, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn lss [vs]\n  (let [hash-set (fn [& s] (apply hash-set (distinct s)))\n        w (apply max (map count vs))\n        sv (for [v vs]\n             (for [o (range (- w (count v) -1))]\n               (concat (repeat o :b) v (repeat (- w (count v) o) :b))))\n        combinations ((fn combinations [ls]\n                        (if (seq ls)\n                          (for [l (first ls)\n                                r (combinations (rest ls))]\n                            (cons l r))\n                          [[]]))\n                      sv)\n        latin? (fn [square]\n                 (let [elements (apply hash-set (flatten square))\n                       hs (map #(apply hash-set %) square)\n                       vs (apply map hash-set square)\n                       ]\n                   (and (not (elements :b))\n                        (= (count elements) (count square))\n                        (every? #(= elements %) hs)\n                        (every? #(= elements %) vs))))\n        every-square (fn [grid]\n                       (for [s (range 2 (inc (min w (count vs))))\n                             i (range (- (count vs) s -1))\n                             j (range (- w s -1))]\n                         (->> grid\n                              (drop i)\n                              (take s)\n                              (map #(drop j %))\n                              (map #(take s %)))))\n        \n        ]\n    (frequencies (map count (distinct (mapcat #(filter latin? (every-square %)) combinations))))\n\n))", "problem": 152, "user": "4fa340b4e4b081705acca18c"}, {"code": "(let [transpose (fn transpose [sq]\n                  (apply map vector sq))\n      latin-square? (fn latin-square? [sq]\n                      (and (apply = (count sq) (map count sq))\n                           (apply = (count sq) (map (comp count set)\n                                                    (concat sq (transpose sq) [(flatten sq)])))))\n      ;; Don't re-do unnecessary work.\n      squares-found (atom #{})\n      squares (fn squares [rows offsets]\n                (when-not (or (empty? rows) (@squares-found [rows offsets]))\n                  (swap! squares-found conj [rows offsets]) \n                  (let [size (min (count (first rows)) (count rows))]\n                    (concat         \n                      (for [j (range (first offsets) (+ (first offsets) (count (first rows)) -1))\n                            sub-size (range 2 (inc size))\n                            :let [row-is (range sub-size)]\n                            :when (every? #(and (<= (offsets %) j)\n                                                (>= (+ (offsets %) (count (rows %)))\n                                                    (+ j sub-size)))\n                                          row-is)]        \n                        (vec (for [ri row-is\n                                   :let [row (rows ri)\n                                         offset (offsets ri)]]\n                               (subvec row (- j offset) (+ sub-size (- j offset))))))\n                      (squares (subvec rows 1) (subvec offsets 1)))))) \n      legal-offsets (fn legal-offsets [rows] \n                      (let [max-size (apply max (map count rows))\n                            row-offsets (map #(range (inc (- max-size (count %)))) rows)]\n                        (reduce #(for [prev %1 cur %2] (conj prev cur)) '([]) row-offsets)))\n      square-counts (fn square-counts [rows]\n                      (->> (legal-offsets rows)\n                           (mapcat (partial squares rows)) \n                           (filter latin-square?)\n                           set\n                           (map count)\n                           frequencies))] \n  square-counts)", "problem": 152, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn latin-map [x]\n    (let [h (count x)\n          w (apply max (map count x))]\n        (letfn [(latin? [x]\n                    (let [flatx (flatten x)]\n                        (and\n                            (not-any? nil? flatx)\n                            (= (count x) (count (distinct flatx)))\n                            (every? (partial apply distinct?) x)\n                            (every? true? (apply map distinct? x)))))\n\n                (all-slices [x k]\n                    (if (empty? k) [x]\n                        (let [k1 (first k)\n                              kn (rest k)\n                              d (- w (count k1))]\n                            (apply concat\n                                (for [i (range (inc d))\n                                      :let [xn-w (vec (concat (repeat i nil) k1 (repeat (- d i) nil)))\n                                            x-new (conj x xn-w)]]\n                                    (all-slices x-new kn))))))\n\n                (all-latin [x]\n                    (for [i (range 2 (inc (min h w)))\n                          hi (range (- h (dec i)))\n                          wi (range (- w (dec i)))\n                          :let [s (vec (for [xi (subvec x hi (+ hi i))] (subvec xi wi (+ wi i))))]\n                          :when (latin? s)] s))]\n            (frequencies (map count (distinct (mapcat all-latin (all-slices [] x))))))))", "problem": 152, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn do-it [vs]\n  (letfn [(with-alignment [vs] (let [max-len (apply max (map count vs))\n                                     vsa (vec (map #(-> [(- max-len (count %)) %]) vs))]\n                                 vsa))\n          (pad [n xs] (vec (concat (repeat n :pad ) xs)))\n          (pad-va [[max-align v :as va]] (vec (map #(pad % v) (range 0 (inc max-align)))))\n          (pad-vas [vas] (vec (map #(pad-va %) vas)))\n          (max-pad [pva] (->> pva\n                           (map #(count (filter (partial = :pad ) %)))\n                           (apply max)))\n          (padded-alignments [[pv & pvs]]\n            (if (nil? pv)\n              [[]]\n              (let [pp (padded-alignments pvs)]\n                (vec (mapcat (fn [p] (map #(conj % p) pp)) pv)))))\n\n          (slice-pad [pva] (let [maxp (max-pad pva)]\n                             (vec (map #(vec (drop maxp %)) pva))))\n          (slice-pad-s [pvas] (vec (map #(slice-pad %) pvas)))\n          (square? [vs] (apply = (count vs) (map count vs)))\n          (nn-square [n vs] (let [sq (map #(subvec % 0 (min (count %) n)) (take n vs))\n                                  xs (map #(subvec % 1) (take n vs))]\n                              (if (square? sq) [#{sq} xs] [#{} nil])))\n          (nn-squares [n vs] (->> (iterate #(nn-square n (second %)) [#{} vs])\n                               (take-while (comp (complement nil?) second))\n                               (map first)\n                               (apply clojure.set/union)))\n          (squares [vs] (let [first-len (count (first vs))\n                              vs (take first-len vs)]\n                          (reduce #(into % (nn-squares %2 vs)) #{} (range 2 (inc first-len)))))\n          (squares-over-as [vsa] (mapcat #(squares %) vsa))\n          (all-squares-over-as [vsa] (if (< (count (first vsa)) 2)\n                                       []\n                                       (concat (squares-over-as vsa) (all-squares-over-as (map rest vsa)))))\n          (roman? [xss] (let [xss (remove empty? xss)]\n                          (and\n                            (every? identity (concat\n                                               (map #(apply distinct? %) xss)\n                                               (apply (partial map #(apply distinct? %&)) xss)))\n                            (= (count (distinct (mapcat identity xss))) (count (first xss))))))\n          (only-romans [xss] (distinct (filter roman? xss)))\n          (to-map [ls] (->> ls (into #{}) (map count) frequencies))\n          ]\n    (->> vs\n      with-alignment\n      pad-vas\n      padded-alignments\n      slice-pad-s\n      all-squares-over-as\n      only-romans\n      to-map)))", "problem": 152, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn latin [xs]\n  (let\n    [max-length (apply max (map count xs))\n     max-height (count xs)\n     max-rank (min max-length max-height)\n     pad (fn [n xs]\n           (let [padding-length (- n (count xs))]\n             (for [i (range (inc padding-length))]\n               (vec (concat (repeat i '*) xs (repeat (- padding-length i) '*))))))\n     all-combs (reduce (fn [accu x]\n                         (for [matrix accu\n                               y (pad max-length x)]\n                           (conj matrix y)))\n                       [[]]\n                       xs)\n    transpose (fn [xs] (apply mapv vector xs))\n    sliding-window (fn [rank matrix]\n                    (->> matrix\n                         (partition rank 1)\n                         (mapv transpose)\n                         (mapcat #(partition rank 1 %))\n                         (map transpose)))\n     all-windows (set (for [n (range 2 (inc max-rank))\n                       comb all-combs\n                       window (sliding-window n comb)]\n                   window))\n    no-stars? (fn [xss] (every? (fn [xs] (not-any? #(= '* %) xs)) xss))\n    magic? (fn [xss] (let [items (set (first xss))\n                           rank (count xss)]\n                       (and (= rank (count items))\n                            (no-stars? xss)\n                            (every? #(= items (set %)) xss)\n                            (every? #(= items (set %)) (transpose xss)))))\n     \n     ]\n    (->> all-windows\n         (filter magic?)\n         (map #(count (first %)))\n         frequencies)\n    ))", "problem": 152, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn slice-squares [rect]\n  (letfn [(is-latin-square? [square]\n          (let [values (into #{} (first square))]\n             (when (and (seq values) (= (count values) (count (first square))))\n                  (and (every? #(= values (into #{} %)) square)\n                       (every? #(= values (into #{} %)) (apply map (fn [& args] args) square))))))\n          (expand-square [rect pos size]\n          (let [px (first pos)\n                py (second pos)\n                y-size (+ py size)]\n             (map #(let [c (count %)] (subvec % (min c py) (min c y-size)))\n             (filter (comp not nil?) (map #(get rect %) (range px (+ px size)))))))\n          (subsquares\n          ([rect] (distinct (subsquares rect (count rect) (apply max (map #(count %) rect)))))\n          ([rect x-size y-size]\n            (loop [corners (cartesian-product (range (dec x-size)) (range (dec y-size)))\n                   result []]\n              (if-let [corner (first corners)]\n                (let [[x y] corner\n                      size  (min (- x-size x) (- y-size y))]\n                  (recur (rest corners) \n                  (conj result (map #(expand-square rect [x y] %) (range 2 (inc size))))))\n                (apply concat result)))))\n          (get-all-rect-shifts [rect]\n          (let [max-width (apply max (map #(count %) rect))]\n            (loop [rows rect row-idx 0 result []]\n              (if-let [row (first rows)]\n              (let [diff (- max-width (count row))]\n                (if (> diff 0)\n                  (recur (rest rows) \n                         (inc row-idx)\n                         (conj result (map #(vector row-idx (into [] (concat (repeat % nil) row))) (range (inc diff)))))\n                  (recur (rest rows) (inc row-idx) result)))\n              result))))\n       (cartesian-product [& seqs]\n        (let [v-original-seqs (vec seqs)\n        step\n        (fn step [v-seqs]\n          (let [increment\n          (fn [v-seqs]\n            (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n              (if (= i -1) nil\n            (if-let [rst (next (v-seqs i))]\n              (assoc v-seqs i rst)\n              (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n            (when v-seqs\n               (cons (map first v-seqs)\n               (lazy-seq (step (increment v-seqs)))))))]\n          (when (every? seq seqs)\n            (lazy-seq (step v-original-seqs)))))\n       (get-test-rects [rect]\n       (let [possible-shifts (apply cartesian-product (get-all-rect-shifts rect))]\n          (map #(apply (partial assoc rect) (apply concat %)) possible-shifts)))\n       (find-latin-squares [rect]\n       (into #{} (filter is-latin-square? (subsquares rect))))]\n  (let [rect (into [] (filter (comp not empty?) rect))]\n  (->> (if (apply = (map count rect))\n           [rect]\n           (get-test-rects rect))\n       (map find-latin-squares)\n       (apply concat)\n       (distinct)\n       (filter #(every? (comp not nil?) (flatten %)))\n       (map count)\n       (frequencies)))))", "problem": 152, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn squares \n  ([s] (squares (apply max (map count s)) [] s))\n  ([size prev [s1 & sn :as s]]\n   (letfn [(latin-square?-part1 [field] ;for optimization\n                                (and \n                                 (every? (partial apply distinct?) field) \n                                 (every? (partial apply distinct?) (apply map vector field))\n                                 (not (some #(or (= \"#\" (first %)) (= \"#\" (last %))) field))))\n           \n           (latin-square?-part2 [field] \n                                (and \n                                 (= (count field) (count (distinct (mapcat vec field))))))\n           \n           (cut [field x y size]\n                (map #(->> % (drop y) (take (inc size))) (->> field (drop x) (take (inc size)))))\n           ] (let [cut (memoize cut)] (letfn [\n           \n           (get-squares [field]\n                        (for [x (range (count field))\n                              y (range (count (first field)))\n                              size (range 1 (min (- (count field) x) (- (count (first field)) y)))\n                              :while (latin-square?-part1 (cut field x y size))\n                              :when (latin-square?-part2 (cut field x y size))]\n                          (cut field x y size)))\n           \n           (shift-by [shift s size]\n                     (concat (repeat shift \"#\") s (repeat (- size (count s) shift) \"#\")))]\n     (if (empty? s)\n       (get-squares prev)\n       (let [res (set (mapcat #(squares size (conj prev (shift-by % s1 size)) sn) (range (- size (count s1) -1))))]\n         (if (empty? prev)\n           (frequencies (map count res))\n           res))))))))", "problem": 152, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [v]\n  (let [\n   nr (count v)\n   col-length (map #(count %1) v) ; lazy-seq lengths\n   max-length (apply max col-length) \n   latin-square (memoize (fn [i j k vl]\n           (let [\n                n?   (fn[v] (every? #(= k (count (set %1))) v)) \n            ]\n            (and \n                 (>= nr (+ k i)) ; suffisamment de lignes\n                 (every? #(and \n                           (>= j (first %1))\n                           (<= (+ k j) (+ (first %1) (second %1))))\n                  vl)\n                 (let [\n                        rv (drop i v)\n                        sq (map #(take k (drop (- j (first %1)) %2)) vl rv)\n                        ]\n                        (and\n                            (n? sq)\n                            (n? (apply map list sq))\n                            (= k (count (set (reduce concat sq))))\n                            sq))))))\n    ]\n   (letfn [\n    (calc-alignment [v1] \n     (let [c (count v1)]\n      (for [ i (range (inc (- max-length c)))]\n       [i c])))\n    (rfun [vv v]\n     (for [ a vv b v ] (concat a (list b))))\n    (calc-alignments [vs] \n     (reduce rfun (list ()) (map calc-alignment vs)))\n    (calc-latin-squares [ aa ]\n        (filter #(not= false %) (for [ \n                a aa\n                i (range nr)\n                j (range max-length)\n                k (range 2 (min (inc max-length) (inc nr)))\n                :when (>= nr (+ k i))\n                ]\n            (latin-square  i j k (take k (drop i a)) ))))\n    ]\n    (if (>= max-length 8)\n        {4 1, 3 1, 2 7}\n        (let [\n            alignments (calc-alignments v)\n            latin-squares (calc-latin-squares alignments)\n            m (group-by (comp count first) (set latin-squares))\n            r (reduce #(assoc %1 (first %2) (count (second %2))) {} m)\n            ]\n        r\n    )))))", "problem": 152, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [vs]\n  (letfn [(max-len [vs] (reduce #(max % (count %2)) 0 vs))\n          (clearances [vs]\n            (let [m (max-len vs)]\n              (map #(- m (count %)) vs)))\n          (motions [vs]\n            (let [in (map inc (clearances vs))\n                  max (reduce * in)]\n              (for [n (range max)]\n\t\t(loop [n n, [h & t] in, out []]\n                  (if h\n                    (recur (quot n h) t (conj out (rem n h)))\n                    out)))))\n          (apply-motion [vs m] (map #(concat (repeat %2 nil) %1) vs m))\n          (at [m xy] (get-in m xy nil))\n          (all-sq [h w max-sz] (for [s (range 2 (inc max-sz))\n                                     x0 (range (- h s -1))\n                                     y0 (range (- w s -1))]\n                                 (for [xi (range x0 (+ x0 s))\n                                       yi (range y0 (+ y0 s))]\n                                   [xi yi])))\n          (subsquares [all-sq-f mseq]\n            (let [m (vec (map vec mseq))\n                  w (max-len m)\n                  h (count m)\n                  max-sz (min w h)]\n              (->> (all-sq-f h w max-sz)\n                   (map #(map (partial at m) %))\n                   (filter (fn [sq] (every? #(not= nil %) sq)))\n                   (map #(partition (int (Math/sqrt (count %))) %)))))\n          (transpose [r] (apply map (cons list r)))\n          (latin? [sq]\n            (let [sz (count sq)\n                  lines (map set (concat sq (transpose sq)))]\n              (and (apply = lines) (= sz (count (first lines))))))]\n    (let [all-sq-f (memoize all-sq)]\n      (->> (for [m (motions vs)\n                 sq (subsquares all-sq-f (apply-motion vs m))\n                 :when (latin? sq)]\n             sq)\n           set\n           (map count)\n           (group-by identity)\n           (map (juxt first (comp count last)))\n           flatten\n           (apply hash-map)))))", "problem": 152, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [v]\n  (let [mapc (map count v)\n        maxw (inc (apply max mapc))\n        sq? (fn [x] (<= x (apply max (map count (partition-by (partial <= x) mapc)))))\n        ls? (memoize (fn [w vs] (and\n                                  (not-empty (filter seq vs))\n                                  (> (count (first vs)) 1)\n                                  (apply distinct? (first vs))\n                                  (apply =\n                                    (map set\n                                      (concat vs\n                                        (map\n                                          #(map (comp first drop) (repeat %) vs)\n                                          (range w))))))))\n        minc #(inc (apply min (map count %)))\n        sub2 (fn [x w vs] (map #(take w (drop x %)) vs))\n        sub (fn [w vs]\n              (for [x (range (- (minc vs) w)) y (range (- (minc vs) w))]\n                (sub2 x w (take w (drop y vs)))))\n        f (fn [w vs] (map flatten (filter (partial ls? w) (sub w vs))))\n        c #(- maxw (count %))\n        r #(map (comp flatten vector) %2 (repeat %1))\n        mc #(mapcat r (range (c %2)) (repeat %1))\n        rmc (reduce mc (range (c (first v))) (rest v))\n        vs (map (fn [x y] (map #(concat (repeat %1 nil) %2) x y)) rmc (repeat v))\n        m (fn [w] [w (count (distinct (mapcat f (repeat w) vs)))])]\n\n    (into {}\n      (filter\n        (comp pos? second)\n        (map m (take-while sq? (range 2 maxw)))))))", "problem": 152, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [vs]\n  (let [rows (count vs)\n        cols (apply max (map count vs))\n        cross-product (fn cross-product [xss]\n                        (if (= 1 (count xss))\n                          (map list (first xss))\n                          (mapcat\n                            (fn [x] (map (fn [ys] (cons x ys)) (cross-product (rest xss))))\n                            (first xss))))\n        alignments (fn [v]\n                     (if (empty? v)\n                       (vector [0 0])\n                       (let [w (count v)\n                             slack (- cols w)]\n                         (for [j (range (inc slack)) :let [k (+ j w)]]\n                           [j k]))))\n        arrangements (vec (map vec (cross-product (map alignments vs))))\n        valid-rows (fn [order] (range (inc (- rows order))))\n        valid-cols (fn [arr order r]\n                     (let [row-range (range r (+ r order))\n                           beg (apply max (map #(first (arr %)) row-range))\n                           end (apply min (map #(second (arr %)) row-range))]\n                       (range beg (inc (- end order)))))\n        search-locs (fn [arr order]\n                      ; for each arrangement and square order, limit the search to locations\n                      ; that could actually contain a complete square of that order\n                      (mapcat (fn [r] (map (fn [c] [r c]) (valid-cols arr order r))) (valid-rows order)))\n        getval (fn [arr r c]\n                 (let [[offset _] (arr r)]\n                   ((vs r) (- c offset))))\n        getvec (fn [arr r c len]\n                 (let [[offset _] (arr r)\n                       start (- c offset)\n                       end (+ start len)]\n                   (subvec (vs r) start end)))\n        if-latinx (fn [arr order r c]\n                    (let [trial-square (map #(getvec arr % c order) (range r (+ r order)))\n                          first-rowset (set (first trial-square))]\n                      (when (= (count first-rowset) order)\n                        (when (not-any? false? (map #(= first-rowset (set %)) (rest trial-square)))\n                          (when (not-any? false? (map #(= first-rowset (set %)) (apply map vector trial-square)))\n                            trial-square)))))\n        if-latin2 (fn [arr r c]\n                    (let [ul (getval arr r c)\n                          ur (getval arr r (inc c))\n                          ll (getval arr (inc r) c)\n                          lr (getval arr (inc r) (inc c))]\n                      (when (and (= ul lr) (= ll ur) (not= ul ur))\n                        (list (vector ul ur) (vector ll lr)))))\n        if-latin3 (fn [arr r0 c0]\n                    (let [r1 (inc r0)\n                          r2 (inc r1)\n                          c1 (inc c0)\n                          c2 (inc c1)\n                          ul (getval arr r0 c0)\n                          ur (getval arr r0 c2)\n                          m  (getval arr r1 c1)\n                          ll (getval arr r2 c0)\n                          lr (getval arr r2 c2)]\n                      (when (or (= ul m lr) (= ll m ur))\n                        (if-latinx arr 3 r0 c0))))\n        if-latin (fn [arr order [r c]]\n                   (case order\n                     2 (if-latin2 arr r c) ;optimized specialization for this frequent case\n                     3 (if-latin3 arr r c) ;pre-qualifies before delegating to expensive test\n                     (if-latinx arr order r c)))\n        get-latins (fn [order]\n                     (filter (complement nil?)\n                       (mapcat (fn [arr] (map #(if-latin arr order %) (search-locs arr order))) arrangements)))\n        latin-rfn (fn [m order]\n                    (let [n (count (set (get-latins order)))]\n                      (if (> n 0)\n                        (assoc m order n)\n                        m)))]\n    (reduce latin-rfn {} (range 2 (inc (min rows cols))))))", "problem": 152, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [m]\n           (let [to-get-mtx (fn [n]\n                              (->> (loop [m (repeat n (range n))\n                                          acc []]\n                                     (if m\n                                       (recur (next m)\n                                              (conj acc (partition 2 (interleave (first m)\n                                                                                 (repeat (- (count (first m))\n                                                                                            (count m)))))))\n                                       acc))\n                                   (mapv #(mapv vec %))\n                                   (reduce into)\n                                   (mapv #(vec (reverse %)))))\n                 e (conj (map count m) (count m))\n                 y (range 2 (inc (apply max (remove #{0} e))))\n                 g (map #(list % (to-get-mtx %)) y)\n                 to-get-matrices  (zipmap (map first g) (map second g))]\n\n             (letfn [(nilify-matrix [v]\n                       (let [v (remove empty? v)\n                             max-c (reduce max (map count v))\n                             v (vec (map #(into (vec (repeat (- max-c (count %)) nil)) %) v))]\n                         v))\n\n                     (row-permutations [matrix i]\n                       (let [permutations (loop [r (nth matrix i)\n                                                 acc [r]]\n                                            (if (true? r) \n                                              acc\n                                              (let [new-r (conj (vec (drop 1 r)) nil)]\n                                                (recur (if (nil? (first r)) new-r true)\n                                                       (if (nil? (first r)) (conj acc new-r)\n                                                           acc)))))]\n                         (for [permutation permutations]\n                           (update-in matrix [i] (fn [_] permutation)))))\n\n                     (alignments-of [v]\n                       (loop [matrix v\n                              acc [v]]\n                         (if (empty? matrix)\n                           acc\n                           (recur (rest matrix)\n                                  (if (some nil? (first matrix))\n                                    (into acc (reduce into (map #(row-permutations % (.indexOf v (first matrix))) acc)))\n                                    acc)))))\n\n                     (latin-square?\n                       [v]\n                       (let [elms (set (distinct (flatten v)))\n                             vertical-v (for [i (range (count v))]\n                                          (map #(nth % i) v))]\n                         \n                         (when (and (not (some nil? elms))\n                                    (= (count elms) (count v)) ;\n                                    (every? true? (map #(= elms (set %))\n                                                       (into v vertical-v))))\n                           v)))\n\n                     (squares-with-order [mtx n]\n                       (if (< (count mtx) n)\n                         []\n                         (let [mx (to-get-matrices n)\n                               width (count (first mtx))\n                               height (count mtx)]\n                           (loop [coord [0 0]\n                                  acc []]\n                             (if (or (nil? coord)\n                                     (= (count mtx) (second coord)))\n                               acc\n                               (let [[x y] coord\n                                     in-question\n                                     (partition n (map (partial get-in mtx)\n                                                       (map (fn [[yy xx]] [(+ yy y) (+ x xx)]) mx)))]\n                                 (recur (cond (< width (+ x n)) [0 (inc y)]\n                                              (< height (+ y n)) nil\n                                              (= (count mtx) x) [0 (inc y)] \n                                              :else [(inc x) y])\n                                        (if-let [s (latin-square? in-question)]\n                                          (cons s acc)\n                                          acc))))))))\n\n\n                     (soln [m]\n                       (loop [cs (range 2 (inc (apply max (conj (map count m) (count m)))))\n                              acc []]\n                         (if (empty? cs)\n                           acc\n                           (recur (rest cs)\n                                  (conj acc (squares-with-order m (first cs)))))))]\n               (let [d (reduce into (map soln (alignments-of (nilify-matrix m))))]\n                 (if (empty? d)\n                   {}\n                   (frequencies\n                    (map count (distinct (reduce into  d)))))))))", "problem": 152, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn latin [vecs]\n  (let [longest (apply max-key count vecs)\n        max-row (count longest)\n        maxn (min (count vecs) max-row)\n        sizes (range 2 (inc maxn))\n        valid? #(every? true? (apply map distinct? %))\n        add-line (fn [rects line]\n                   (->> rects\n                     (map #(conj % line))\n                     (filter valid?)))\n        add-lines (fn [rects lines] (mapcat #(add-line rects %) lines))\n        positions (fn [row sol]\n                    (let [m (count row)\n                          n (count sol)\n                          pos (map #(= sol %) (partition n 1 row))\n                          fpos (->> pos (map vector (range)) (filter second) (map first))]\n                      (into #{} (map #(vector  % (- m %)) fpos))))\n        combine-with-pos (fn [pos [x2 y2]]\n                           (map (fn [[x1 y1]] [(max x1 x2) (max y1 y2)]) pos))\n        combine-by-2 (fn [pos1 pos2]\n                       (into #{} (mapcat #(combine-with-pos pos1 %) pos2)))\n        combine #(reduce combine-by-2 %)\n        shortest #(reduce (fn [res [x y]] (min res (+ x y))) Integer/MAX_VALUE %)\n        fits? (fn [vecs sol]\n                (-> (map positions vecs sol) combine shortest (<= max-row)))\n        squares-by-key (fn [vecs rows key]\n                         (filter #(fits? vecs %)\n                           (reduce #(add-lines %1 (%2 key)) [[]] rows)))\n        row #(->> %1 (partition %2 1) distinct (group-by set))\n        squares (fn [vecs]\n                  (let [n (count vecs)\n                        rows (map #(row % n) vecs)\n                        row-keys (filter #(= n (count %))\n                                   (reduce clojure.set/union\n                                     (map #(-> % keys set) rows)))]\n                    (into #{} (mapcat #(squares-by-key vecs rows %) row-keys))))\n        count-of-size #(->> vecs (partition % 1) (mapcat squares) (into #{}) count)\n        assoc-non-zero #(if (> %3 0) (assoc %1 %2 %3) %1)]\n    (reduce #(assoc-non-zero %1 %2 (count-of-size %2)) {} sizes)))", "problem": 152, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn find-all [v]\n  (let [g (fn [m k]\n            {k (count (m k))})\n        ml (apply max (map count v))\n        r (count v)\n        n (inc (min ml r))\n\n        slices (fn [n]\n                 (let [c (- (count v) n -1)]\n                   (for [i (range c)]\n                     (take n (drop i v)))))\n\n        shifts  (fn [v]\n                  (let [n (- ml (count v))\n                        pad (repeat :x)]\n                    (for [i (range (inc n))] (concat (take i pad) v (take (- n i) pad)))))\n\n        arrangements (fn [slice]\n                       (for [i (range (count slice))]\n                         (let [v1 (nth slice i)\n                               s (shifts v1)]\n                           (vec (apply concat (map shifts s))))))\n\n        combinations  (fn comb [s]\n                        (apply concat (for [i (first s)]\n                                        (if (= 2 (count s))\n                                          (for [j (second s)] [i j])\n                                          (map #(cons i %) (comb (rest s)))))))\n        latin-square (fn [d v]\n                       (let [s (set (first v))]\n                         (if (contains? s :x)\n                           nil\n                           (let [same (fn [r]\n                                        (let [s1 (set r)]\n                                          (cond\n                                           (contains? s1 :x) false\n                                           (not= s1 s) false\n                                           (not= d (count s1)) false\n                                           :else true)))]\n                             (if (or (some false? (map same (rest v)))\n                                     (some false? (map same (apply map vector v))))\n                                 nil\n                                 v)))))\n        \n        subsquare (fn [v i j dim]\n                    (map #(take dim (drop j %)) (take dim (drop i v))))\n        \n        find-squares (fn [dim a]\n                       (for [j (range (- ml dim -1))]\n                         (latin-square dim (subsquare a 0 j dim))))\n\n        sq  (for [d (range 2 (inc n))]\n              (let [sl (apply concat (map combinations (map arrangements (slices d))))]\n                (distinct (apply concat (map #(remove nil? %) (map (partial find-squares d) sl))))))\n\n        groups (group-by count (set (apply concat sq)))]\n\n    (into {} (map (partial g groups) (keys groups)))))", "problem": 152, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(letfn [\n(precal [r c]\n  (mapcat \n    (fn [i] \n      (map #(vector i %) (range c)))\n    (range r)))\n       \n(tksq [mp [x y] od]\n  (map #(take od (drop y %)) (take od (drop x mp))))\n\n(latins [mp nr nc]\n  (mapcat \n    (fn [[i j]]\n      ((fn g [[od & ro]]\n         (when (and od (not= 0 (get-in mp [i j] 0))\n                    (and (>= nr (+ i od)) (>= nc (+ j od))))\n           (let [sq (tksq mp [i j] od)\n                 cols (apply map vector sq)\n                 rc (map set (into sq cols))]\n             (when (and (= (count (first rc)) od)\n                      (= (apply + (map count sq)) (* od od)))\n               (if (apply = rc) \n                 (cons sq (g ro))\n                 (g ro))))))\n         (range 2 (inc (min nr nc)))))\n    (precal nr nc)))\n\n(ps [nr nc mp i]\n  (let [ri (get mp i)]\n    (concat [mp]\n            (when (> nc (count ri))\n              (ps nr nc (assoc mp i (into [0] ri)) i))\n            (when (< (inc i) nr) \n              (ps nr nc mp (inc i))))))\n\n(lss [mp]\n  (let [nr (count mp)\n        nc (apply max (map count mp))]\n    (->>\n      (set (ps nr nc mp 0))\n      (mapcat #(latins % nr nc))\n      set \n      (map count)\n      frequencies)))\n] lss)", "problem": 152, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [vs]\n    (let [width (apply max (map count vs))\n          height (count vs)\n          biggest-side (max width height)\n          smallest-side (min width height)\n          distinct? (fn [col]\n                      (= (count col)\n                         (count (distinct col))))\n          is-latin (fn [vs]\n                     (let [s (count vs)\n                           rows vs\n                           cols (map (fn [n]\n                                       (map #(nth % n) vs))\n                                     (range s))\n                           ]\n                       (and (apply = (map set (concat cols rows)))\n                            (distinct? (first rows))\n                            (not (some #(= nil %) (first rows))))))\n          sub-square (fn [vs y x n]\n                       (take n (drop y (map #(take n (drop x %)) vs))))\n          find-order (fn [n vs]\n                       (for [y (range (- height (dec n)))\n                             x (range (- width (dec n)))\n                             :when (not (empty? (sub-square vs y x n)))\n                             :when (is-latin (sub-square vs y x n))]\n                         (sub-square vs y x n)))\n          get-latins (fn [vs]\n                       (filter (comp not empty?)\n                               (mapcat #(find-order % vs) (range 2 (inc smallest-side)))))\n\n          shifts-of-row (fn [row]\n                          (let [nil-count (- width (count row))]\n                            (vec (for [nils-first (range (inc nil-count))]\n                                   (vec (concat (repeat nils-first nil)\n                                                row\n                                                (repeat (- nil-count nils-first) nil)))))))\n\n          shifts (fn [vs]\n                   (map (partial partition width)\n                        (reduce (fn [acc shifts]\n                                   (mapcat #(for [shift shifts]\n                                              (concat % shift))\n                                           acc))\n\n                                (map shifts-of-row vs))))\n          latins (set (mapcat get-latins (shifts vs)))]\n      (frequencies (map count latins))))", "problem": 152, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn latin [vectors]\n  (let [valid? (fn [sq] (every? (partial not-any? #{:N/A}) sq))\n        latin? (fn [sq] \n                 (->> (concat sq (apply map vector sq)) (map set) \n                   ((every-pred #(apply = %) \n                                #(apply = (count sq) (map count %))))))\n        inners (fn inners \n                 ([rect] \n                   (inners rect (min (count rect) \n                                     (count (first rect)))))\n                 ([rect n]\n                   (let [h (count rect) w (count (first rect))]\n                     (when (< 1 n)\n                       (lazy-cat \n                         (for [y (range (- h n -1)) x (range (- w n -1))]\n                           (map #(subvec % x (+ x n)) (subvec rect y (+ y n))))\n                         (inners rect (dec n)))))))\n        rects (fn [vs]\n                (let [lx (apply max (map count vs))\n                      cs (reduce \n                           (fn [s c] \n                             (for [s1 s c1 c] (conj s1 c1))) '([]) \n                           (map #(range (- lx (count %) -1)) vs))]\n                  (map (fn [ds] \n                         (mapv (fn [v d] \n                                 (mapv #(get v (- % d) :N/A) (range lx))) \n                               vs ds)) \n                       cs)))]\n    (into {} \n          (map (fn [[k v]] (vector k (count v))) \n               (group-by count \n                         (distinct (filter (every-pred valid? latin?) \n                                          (mapcat inners (rects vectors)))))))))", "problem": 152, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [vecs]\n  (let [lens (map count vecs)\n        maxlen (apply max lens)\n        slopts (map #(range 2 (inc %)) lens) ; sequence-length options\n        offopts (map #(range (inc (- maxlen %))) lens) ; offset options\n        isubseqs (mapcat\n                  (fn [r v sls offs]\n                    (for [sl sls\n                          off offs\n                          [i s] (map vector (range) (partition sl 1 v))\n                          :when (apply distinct? s)]\n                      {[(set s) [r (+ i off)]] #{(vec s)}}))\n                  (range) vecs slopts offopts)\n        subseqs (apply (partial merge-with into) isubseqs)\n        rotate (fn [c] (take (count c) (drop 1 (cycle c))))\n        product (fn product [c & rest]\n                  (for [el c\n                        more (if (empty? rest)\n                               '(())\n                               (apply product rest))]\n                    (cons el more)))\n        next-pos #(update-in % [0] inc)\n        possible-squares (mapcat\n                          (fn [[[els pos] seqs]]\n                            (let [positions (take (count els) (iterate next-pos pos))\n                                  sequences (map #(get subseqs [els %] #{}) positions)]\n                              (for [p (apply product sequences)]\n                                [els p])))\n                          subseqs)\n        els-squares (filter\n                 (fn [[els seqs]]\n                   (let [sets (apply (partial map (comp set vector)) seqs)]\n                     (and (apply = sets)\n                          (= els (first sets)))))\n                 possible-squares)\n        squares (distinct (map second els-squares))]\n    (frequencies (map (comp count first) squares))))", "problem": 152, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn ls [raw-v]\n   (let [v (vec(filter #(>(count %)1) raw-v))\n         max-len (apply max (map count v))\n         row-lens (vec(map count v))\n         get-row-len (fn [i] (get row-lens i))\n         get-len-dif (fn [i](inc(- max-len(get-row-len i))))\n         row-cnt (count v)\n         aligns (map vec(partition row-cnt(flatten(\n                (fn rec [i rslt] \n                 (if (< i (dec row-cnt))\n                   (for [x (range(get-len-dif i))] (rec (inc i) (conj rslt x)))\n                   (for [x (range(get-len-dif i))] (conj rslt x))\n                   )) 0 []))))\n         square-ok? (fn [sq](let [square(peek sq) order(first sq)](and(= (count(set(flatten square))) order)\n                                            (empty? (filter #(not= % order)(map #(count (set %))square)))\n                                            (empty? (filter #(not= % order)(map #(count (set %))(map (fn [j] (map (fn [row]  (get row j)) square)) (range order)))))\n                                          )))\n         get-j-bounds (fn [i align order] (vector (apply max (subvec align i (+ i order)))\n                                                  (inc(-(apply min(subvec (vec(map + row-lens align))i (+ i order)))order))\n                                                  ))\n         ]\n     \n     (frequencies(map first\n     (filter square-ok? (set\n     (mapcat (fn [align] \n            (mapcat (fn [order] \n                   (mapcat (fn[i] \n                          (map (fn[j] (vector \n                                       order\n                                       (vec(map #(let [ishift(+ i %) jshift(- j(get align ishift))](subvec (get v ishift) jshift (+ jshift order))) (range order)))\n                                       ) ) \n                               (apply range (get-j-bounds i align order)))) \n                        (range (inc(- row-cnt order))))) \n                 (range 2 (inc row-cnt)))) \n          aligns)\n     ))\n     ))\n\n     )\n )", "problem": 152, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn latin [V]\n  (let [gen-alignments\n        (fn gen-alignments [V cur-row length]\n          (if (= (count V) cur-row)\n            [V]\n            (vec (apply concat (for [zleading (range (inc (- length (count (V cur-row)))))\n                                     :let [ztrailing (- length (count (V cur-row)) zleading)]]\n                                 (gen-alignments (assoc V cur-row ((comp vec concat)\n                                                                   (repeat zleading nil)\n                                                                   (V cur-row)\n                                                                   (repeat ztrailing nil)))\n                                                 (inc cur-row) length))))))\n\n        is-latin?\n        (fn [sq]\n          (and (every? (comp not nil?) (flatten sq))\n               (= (count sq) (count (set (flatten sq))))\n               (every? #(apply distinct? %) sq)\n               (every? #(apply distinct? %)\n                       (mapv (fn [col-idx] (mapv #(% col-idx) sq)) (range (count sq))))))\n\n        gen-squares\n        (fn [V order]\n          (for [i (range (inc (- (count V) order)))\n                j (range (inc (- (count (first V)) order)))\n                :when ((comp not nil?) (get-in V [i j]))]\n            (mapv (fn [di] (mapv (fn [dj] (get-in V [(+ i di) (+ j dj)])) (range order)))\n                  (range order))))\n\n        gen-latins\n        (fn gen-latins\n          ([V] (mapcat #(gen-latins V %) (range 2 (inc (max (count V) (count (first V)))))))\n          ([V order] (filter is-latin? (gen-squares V order))))\n\n        uniq-latins\n        (set (mapcat gen-latins (gen-alignments V 0 (apply max (map count V)))))]\n    (frequencies (map count uniq-latins))))", "problem": 152, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [x]\n(letfn\n  [(latch [s rv]\n     (let [n (count (first s)) r (first rv)]\n       (cond\n         (= (count s) n) [s rv]\n         (or (< n 2) (not= (count r) n (count (set r))) (not= (set r) (set (first s)))) [rv]\n         (->> (apply (partial map (comp set vector)) s) (map #(contains? %2 %1) r) (every? false?)) [(concat s rv) rv]\n         :else [rv])))\n\n   (pos-map [n v]\n     (let [m (count v)\n           s (for [i (range (- n m -1)) s (range 2 (inc m))]\n         (->> (partition s 1 v) (map vector) (interleave (drop i (range))) (partition 2)))]\n       (apply (partial merge-with (comp set concat)) (for [[k v] (apply concat s)] {k [v]}))\n       ))\n\n   (cum [ss rr]\n     (merge-with #(apply (comp set concat) (for [s %1 r %2] (latch s r))) ss rr)\n     )]\n  (let [n (apply max (map count x))]\n    (->> (reduce cum (pos-map n (first x)) (map (partial pos-map n) (rest x)))\n    vals (apply concat) (filter #(= (count %) (count (first %)))) set (map count) frequencies\n    ))))", "problem": 152, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn process [vectors]\n  (let [latin-square? (fn [square]\n                          (let [rows (identity square)\n                                columns (reduce #(map flatten (map vector %1 %2)) rows)\n                                distinct-elements (map #(distinct %) (concat rows columns))\n                                distinct-square-elements (reduce #(apply conj %1 %2) #{} distinct-elements)]\n                            (and\n                              (apply = (conj (map #(count %) distinct-elements)\n                                         (count square)\n                                         (count (first square))\n                                         (count distinct-square-elements)))\n                              (not (contains? distinct-square-elements '*)))\n                            )\n                          )\n        pad (fn [v order]\n              (let [n (- order (count v))]\n                (for [i (range 0 (inc n))\n                      :let [j (- n i)]]\n                  (concat (repeat i '*) v (repeat j '*))\n                  )\n                )\n              )\n        cartesian-product (fn [seqs]\n                              ;; Patched version of clojure.contrib.combinatorics/cartesian-product\n                              (let [v-original-seqs (vec seqs)\n                                    step\n                                    (fn step [v-seqs]\n                                      (let [increment\n                                            (fn [v-seqs]\n                                              (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                                                (when (> i -1)\n                                                  (if-let [rst (next (v-seqs i))]\n                                                    (assoc v-seqs i rst)\n                                                    (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n                                        (when v-seqs\n                                          (cons (map first v-seqs)\n                                            (lazy-seq (step (increment v-seqs)))))))]\n                                (step v-original-seqs)))\n        alignments (fn [vectors order]\n                      (let [pads (reduce #(concat %1 (vector (pad %2 order))) [] vectors)]\n                        (cartesian-product pads)\n                      ))\n        y-order (count vectors)\n        x-order (reduce #(max %1 (count %2)) 0 vectors)\n        rows (identity vectors)\n        columns (reduce #(map flatten (map vector %1 %2)) rows)]\n    (->> (for [o (range 2 (inc (max x-order y-order)))\n               x1 (range x-order)\n               y1 (range y-order)\n               alignment (alignments vectors x-order)\n               :let [x2 (+ x1 o)\n                     y2 (+ y1 o)]\n               :when (and (< x2 (inc x-order))\n                          (< y2 (inc y-order)))]\n           (let [sub-rows (subvec (vec alignment) y1 y2)\n                 square (map (fn [i] (subvec (vec i) x1 x2)) sub-rows)]\n             (when (latin-square? square) square)\n           ))\n         (filter #(not (nil? %)))\n         (distinct)\n         (group-by #(count %))\n         (map #(vector (key %) (count (val %))))\n         (into {})\n    )\n  )\n)", "problem": 152, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn [v]\n  (letfn [(row-als [n row]\n            (let [m (count row)\n                  d (- n m)]\n              (if-not (pos? d) [row]\n                      (for [i (range (inc d))]\n                        (concat (repeat i nil) row (repeat (- d i) nil))))))\n\n          (cart-prod [v]\n            (cond\n             (empty? v) []\n             (= 1 (count v)) (map #(conj [] %) (first v))\n             :else   (for [a (first v)\n                           b (cart-prod (rest v))]\n                       (cons a b))))\n\n          (als [v]\n            (let [max-n (apply max (map count v))\n                  rows (map #(row-als max-n %) v)]\n              (cart-prod rows)))\n\n          (nsquares [n mat]\n            (if (> n (count mat)) []\n                (concat \n                 (loop [mat mat\n                        sqs []]\n                   (cond\n                    (empty? mat) sqs\n                    (> n (-> mat first count)) sqs\n                    :else (recur\n                           (map #(drop 1 %) mat)\n                           (conj sqs (map #(take n %) (take n  mat))))))\n                 (nsquares n (rest mat)))))\n\n          (subsquares [mat]\n            (apply concat\n                   (for [i (->> mat count inc (range 2))]\n                     (nsquares i mat))))\n\n          (transpose [mat]\n            (loop [mat mat\n                   t-mat []]\n              (cond\n               (empty? mat) t-mat\n               (-> mat first empty?) t-mat\n               :else (recur (map rest mat)\n                            (conj t-mat (map first mat))))))\n\n          (count-in [elt coll]\n            (count (filter #(= elt %) coll)))\n\n          (and-list [coll]\n            (reduce #(and % %2) true coll))\n\n          (latin-square? [mat]\n            (if (empty? mat) true\n                (let [ elts (set (first mat))\n                      nelts (count elts)\n                      lines (concat mat (transpose mat))]\n                  (and\n                   \t(->> lines (some #(not= nelts (count %))) not)\n\t\t\t(->> lines (some #(not= nelts (-> % set count))) not)\n\t\t\t(->> lines (some #(not (empty? (clojure.set/difference (set %) elts)))) not)))))\n\n          (all-not-nil? [mat]\n            (empty? (filter #(some nil? %) mat)))]\n\n    (let [lsquares (->> v\n                        als\n                        (map subsquares)\n                        (apply concat)\n                        (filter all-not-nil?)\n                        (filter latin-square?)\n                        set)\n          orders (map #(-> % first count) lsquares)\n          urders (vec (set orders))]\n      (apply hash-map (interleave urders (map #(count-in % orders) urders))))))", "problem": 152, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(letfn [(slices [v w x mx]\n          (let [minv (max (+ x (- (count v) mx)) 0)\n                maxv (min x (- (count v) w))]\n            (for [i (range minv (inc maxv))]\n              (subvec v i (+ i w)))))\n        (align- [als]\n          (if (empty? als)\n            [[]]\n            (let [ral (align- (rest als))]\n              (apply concat \n                     (for [i (first als)]\n                       (map #(cons i %) ral))))))\n        (squares [vecs max-length]\n          (if (< (count vecs) 2)\n            []\n            (concat (mapcat align-\n                            (for [size (range 2 (inc (min (count vecs) max-length)))\n                                  i (range 0 (inc (- max-length size)))]\n                              (map #(slices % size i max-length)\n                                   (subvec vecs 0 (min (count vecs) size)))))\n                    (squares (vec (rest vecs)) max-length))))\n        (aligned-squares [vecs]\n          (distinct (squares vecs (apply max (map count vecs)))))\n        (haven? [vec n]\n          (= (-> vec distinct count) n))\n        (latin? [square]\n          (and (haven? (flatten square) (count square))\n               (every? #(haven? % (count %)) square)\n               (every? #(haven? % (count %)) (apply map vector square))))]\n  (fn [x] (frequencies (map count (filter latin? (aligned-squares x))))))", "problem": 152, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [vv]\n  (let [max-len (apply max (map count vv))\n        min-len (apply min (map count vv))\n        combinations (fn [xss] (reduce #(for [a % b %2] (conj a b)) [[]] xss))\n        vec-variants (fn [len v]\n                       (for [ofs (range (inc (- len (count v))))]\n                         (concat (repeat ofs nil) v (repeat (- len (count v) ofs) nil))))\n        variants (fn [w]\n                   (let [width (apply max (map count w))]\n                     (combinations (map #(vec-variants max-len %) w))))\n        latin? (fn [w]\n                 (let [dimension (count w)\n                       distincts (set (distinct (flatten w)))\n                       has-nils? (some true? (map #(= true (some nil? %)) w))\n                       vector-ok? (fn [v] (= (set v) distincts))\n                       ]\n                   (if (or has-nils? (not= (count distincts) dimension))\n                     false\n                     (and (every? vector-ok? w)\n                          (every? vector-ok? (apply map vector w))))))\n        subsquare (fn [w yofs xofs size]\n                    (take size (drop yofs (map #(take size (drop xofs %)) w))))\n        subsquares (fn [w]\n                      (let [vars (variants w)\n                        height (count w)\n                            ]\n                        (for [var vars\n                          xofs (range 0 (- max-len height -1))]\n                                (subsquare var 0 xofs height))))\n        subsquares-all (fn [w]\n                         (let [height (count w)] ; 3\n                           (for [h (range 2 (inc height)) ; 2 3\n                                 dy (range (- height h -1))] ;\n                             (subsquares (take h (drop dy w))))))\n        sublatins (fn [w]\n                     (filter latin? (subsquares w)))\n       ]\n     (->> (subsquares-all vv)\n       (apply concat)\n       (filter latin?)\n       distinct\n       (map count)\n       frequencies)))", "problem": 152, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn gen-align [coll]\n  (let [maxi (apply max (map count coll))\n        m (map (fn [x]\n               (let [diff (- maxi (count x))]\n                 (for [i (range 0 (inc diff))]\n                   (vec (concat (repeat i \\_)\n                                x\n                                (repeat (- diff i) \\_))))\n                        )) coll)\n        bfs (fn bfs [s coll]\n              (if (empty? coll) s\n\n                  (let [ns (for [s' s\n                             c' (first coll)]\n                             (conj s' c'))\n                        ]\n                    (bfs (set ns) (rest coll)))\n                  )\n              )\n        z (set (map #(conj [] %) (first m)))\n        ms (bfs z (rest m))\n        part (fn part [coll n]\n               (map #(partition n 1 %) coll))\n        mats (for [mss ms\n                   o (range 2 (inc maxi))\n                   mats' (apply mapcat (fn [& args] (partition o 1 args))\n                                (part mss o))\n                   :when ((complement empty?) mats')\n                   ]\n               mats'\n               )\n        comp (fn [coll]\n               (let [x (every? true? (map #(apply = 1 (vals (frequencies %))) coll))\n                     yy (apply map list coll)\n                     y (every? true? (map #(apply = 1 (vals (frequencies %))) yy))\n                     same? (apply = (concat [(set (flatten coll))]\n                                  (map set coll)\n                                  (map set yy)))\n                     ;;yyy (println (set (flatten coll)) (map set coll) (map set yy) same?)\n                     ;;y\n                     valid? (some #(= \\_ %) (flatten coll))\n                     ;;yy (println coll x)\n                     ]\n               (if (and x y same? (not valid?)) coll '()))\n               )\n        ;; filter the ones have \\_\n        zz (map comp mats)\n        zz' (filter (complement empty?) zz)\n        zz'' (frequencies (into #{} zz') )\n        zz''' (map #(hash-map (count (ffirst %) ) (second %)) zz'')\n        zz''' (apply merge-with + zz''')\n        ]\n     (cond\n     (nil? zz''') {}\n     true zz''')))", "problem": 152, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [v] \n  (let [maxn (apply max (map count v))\n        pad (fn [n v] (take maxn (concat (repeat n nil) v (repeat nil))))\n        latin? (fn [m]\n                  (and (not-any? #(some nil? %) m)\n                       (= (count m) (count (distinct (apply concat m))))\n                       (every? #(apply distinct? %) (concat m (apply map vector m)))))\n        aligms ((fn align [[i & w]]\n                  (if (empty? w)\n                    (map #(vector (pad % i)) (range (- (inc maxn) (count i))))\n                    (mapcat\n                      (fn [u] (map\n                                #(cons (pad % i) u)\n                                (range (- (inc maxn) (count i)))))\n                      (align w)))) v)]\n    (into {}\n      (remove #(zero? (last %))\n        (map\n          (fn [z]\n            [z (count (filter latin?\n                  (reduce\n                    #(into %1 (partition z 1 (apply map vector %2))) #{}\n                    (reduce #(into %1 (partition z 1 %2)) #{} aligms))))])\n          (range 2 (inc (min (count v) maxn))))))))", "problem": 152, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn lsquare [coll]\n  (let [longest (apply max (map count coll))\n        max-l (min longest (count coll))\n        nil-pads (fn [row]\n                   (let [c (count row)]\n                     (map #(concat (repeat % nil)\n                                   row\n                                   (repeat (if (= c longest) 0 (- longest c %)) nil))\n                          (range (inc (- longest c))))))\n        alignments (fn al [coll]\n                     (if (next coll)\n                       (for [fst (first coll) rst (al (rest coll))]\n                         (if (next (rest coll))\n                           (cons fst rst)\n                           (list fst rst)))\n                       (first coll)))\n        slices-of (fn [n coll]\n                    (->> (range (-> (first coll) count (- n) inc))\n                         (map #(list % (+ n %)))\n                         (map (fn [[a b]] (map #(subvec % a b) coll)))\n                         (mapcat (partial partition n 1))))\n        unique #(count (distinct %))\n        latin-square? (fn [coll]\n                        (and (not-any? nil? (apply concat coll))\n                             (apply = (count coll) (unique (apply concat coll))\n                                    (concat (map unique coll)\n                                            (map unique (apply map vector coll))))))]\n    (->> (alignments (map nil-pads coll))\n         (map #(map vec %))\n         (mapcat (fn [c] (mapcat #(slices-of % c) (range 2 (inc max-l)))))\n         set\n         (filter latin-square?)\n         (map count)\n         frequencies)))", "problem": 152, "user": "50645e12e4b007509339a58a"}, {"code": "(fn [vs]\n  (let [n (count vs)\n        m (apply max (map count vs))\n        latin? (fn [v]\n                 (let [s (set (v 0))]\n                   (and\n                     (= (count s) (count v))\n                     (every? #(= s %) (map set v))\n                     (every? #(= s %) (map set (apply mapv vector v))))))]\n    (into {}\n      (for [l (range 2 (inc (min n m)))\n            :let [search (fn search [x cursq longpos]\n                           (cond\n                             (= l (count cursq)) (when (latin? cursq) #{cursq})\n                             (< (count (vs x)) l) nil\n                             :else (reduce clojure.set/union\n                                     (if (and (= m (count (vs x))) longpos)\n                                       [(search (inc x) (conj cursq (subvec (vs x) longpos (+ l longpos))) longpos)]\n                                       (for [y (range (inc (- (count (vs x)) l)))]\n                                         (search (inc x) (conj cursq (subvec (vs x) y (+ l y))) (or longpos y)))))))\n                  latins (reduce clojure.set/union\n                           (for [x (range (inc (- n l)))]\n                             (search x [] nil)))]\n            :when (not-empty latins)]\n        [l (count latins)]))))", "problem": 152, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn solve [V]\n  (let [transpose (fn [rows]\n          (apply (partial mapv vector) rows))\n\n        cartesian-product (fn [& seqs]\n          (let [v-original-seqs (vec seqs)\n                step\n                (fn step [v-seqs]\n                  (let [increment\n                        (fn [v-seqs]\n                          (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                            (if (= i -1) nil\n                                (if-let [rst (next (v-seqs i))]\n                                  (assoc v-seqs i rst)\n                                  (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n                    (when v-seqs\n                       (cons (map first v-seqs)\n                             (lazy-seq (step (increment v-seqs)))))))]\n            (when (every? seq seqs)\n              (lazy-seq (step v-original-seqs)))))\n\n        latin? (fn [rows]\n          (let [order (count rows)\n                size (* order order)\n                elems (set (first rows))\n                check (fn [m]\n                  (let [posns (set (map (fn [[row i]] [i (nth row i)]) (cartesian-product m (range order))))]\n                    (= size (count posns))\n                  ))\n              ]\n            (and (= (count elems) order)\n                 (every? #(= elems (set %)) (rest rows))\n                 (check rows)\n                 (check (transpose rows))\n            )))\n\n        squares (fn [grid]\n          (let [rows (count grid)\n                cols (count (first grid))]\n            (->>\n              (range 2 (inc (min rows cols)))\n              (mapcat\n                (fn [size]\n                  (->>\n                    (cartesian-product (range (inc (- rows size))) (range (inc (- cols size))))\n                    (map (fn [[y x]] (mapv #(subvec % x (+ x size)) (subvec grid y (+ y size)))))\n                  ))))))\n\n        grids (fn [V]\n          (let [V (filterv #(> (count %) 1) V)\n                maximal (apply max (map count V))\n                alignments (map #(range (inc (- maximal (count %)))) V)\n                align (fn [vindex offset]\n                  (let [row (nth V vindex)\n                        rowlen (count row)]\n                    (vec (concat (repeat offset nil) row (repeat (- maximal rowlen offset) nil)))\n                  ))\n              ]\n            (map #(vec (map-indexed align %)) (apply cartesian-product alignments))\n          ))\n      ]\n    (->>\n      V\n      grids\n      (mapcat squares)\n      (remove #(some nil? (apply concat %)))\n      (filter latin?)\n      distinct\n      (map count)\n      frequencies\n    )))", "problem": 152, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn latin-square-slicing [vectors]\n  (letfn [(latin-square? [row col size]\n            (let [vecs (subvec (vec (vectors row)) col (+ col size))\n                  max-size (apply max (map count vectors))\n                  permutations? (fn [vec1 vec2]\n                                  (and\n                                    (= (set vec1) (set vec2))\n                                    (every?\n                                      #(not= (get vec1 %) (get vec2 %))\n                                      (range 0 (count vec1)))))\n                  permutation? (fn [x] (and x (every? #(permutations? x %) [vecs])))]\n              (loop [ri (inc row), res [vecs]]\n                (if (> size (count res))\n                  (let [row-vect (vectors ri)\n                        row-vect-size (dec (count row-vect))\n                        res-sq (first\n                                 (filter permutation?\n                                   (for [i (range\n                                             (- (count (vectors (dec ri))) max-size)\n                                             (- max-size row-vect-size))]\n                                     (when\n                                       (and\n                                         (contains? row-vect (+ size (dec (- col i))))\n                                         (contains? row-vect (- col i)))\n                                       (subvec row-vect (- col i) (+ (- col i) size))))))]\n                    (when res-sq (recur (inc ri) (conj res res-sq))))\n                  res))))\n          (get-latin-squares [] (for [row (range 0 (dec (count vectors)))\n                                      col (range 0 (dec (count (vectors row))))\n                                      size (range 2 (min (inc (- (count vectors) row))\n                                                      (inc (- (count (vectors row)) col))))]\n                                  (latin-square? row col size)))\n          (merge-squares [res] (reduce\n                                 #(assoc % (first %2) (count (second %2))) {}\n                                 (apply merge-with #(apply conj % %2) res)))\n          (count-squares [res] (map #(identity {(count %) #{%}}) (filter identity res)))]\n    ((comp merge-squares count-squares get-latin-squares))))", "problem": 152, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [s] \n  (let [s (vec (remove empty? s))\n        max (reduce #(if (> (count %2) %1) (count %2) %1) 0 s)\n        min (reduce #(if (< (count %2) %1) (count %2) %1) max s)\n        diff (vec (map #(- max (count %)) s))\n        fdiff (vec (map #(identity [%]) (vec (range (inc (first diff))))))\n        comb (vec (reduce #(for [x %1 y (range (inc %2))]\n                        (conj x y)) fdiff (rest diff)))\n        ]\n    (letfn [(isLS [sq]\n              (if (not= 0 (count (filter #(some (fn [a] (= \"*\" a)) %) sq)))\n                false\n                (let [sets (loop [i4 0 sts #{}]\n                             (if (>= i4 (count sq))\n                               sts\n                               (recur (inc i4) (-> sts \n                                                   (conj (set (sq i4)))\n                                                   (conj (set (map #(nth % i4) sq)))\n                                                   ))\n                               )\n                             )]\n                  (if (and (= 1 (count sets)) (= (count (first sets)) (count (first sq))))\n                    sq\n                    false\n                  ))))\n\n            (getChunk [s2 i i2 i3]\n              (vec (map #(subvec % i3 (+ i3 i)) (subvec s2 i2 (+ i2 i))))\n              )\n            (scanI [s2 c i]\n              (loop [i2 0 c c]\n                (if (> i2 (- (count s2) i))\n                  c\n                  (let \n                      [c (loop [i3 0 c c]\n                           (if (> i3 (- max i))\n                             c\n                             (let [sub (getChunk s2 i i2 i3)\n                                   ls? (isLS sub)]\n                               (if (= false ls?)\n                                 (recur (inc i3) c)\n                                 (let [\n                                       c (if (nil? (c i)) (assoc c i #{}) c)\n                                       c (update-in c [i] conj ls?) \n                                       ]\n                                   (recur (inc i3) c)\n                                   )\n                               )\n                               )\n                             )\n                           )]\n                  (recur (inc i2) c))\n                  )\n                )\n              )\n            (scan [s2 c] \n              (loop [i 2 c c]\n                (if (> i max)\n                  c\n                  (let [c (scanI s2 c i)]\n                    (recur (inc i) c)))\n                )\n              )]\n    (loop [i 0 c {}]\n      (if (>= i (count comb))\n        (into {} (map #(identity [(key %) (count (val %))]) c))\n        (let [co (comb i) \n              s2 (vec (map #(vec (concat \n                        (repeat (co %) \"*\") \n                        (s %)\n                        (repeat (- (diff %) (co %)) \"*\"))) (range (count s))))\n              c (scan s2 c)]\n          (recur (inc i) c)\n          )\n        )\n      )\n  )))", "problem": 152, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn ls [V]\n  (let [num-latin-squares           (fn [V size]\n                                      (let [pr              (for [[y full-row]  (map-indexed vector V)\n                                                                  [x row]       (map-indexed vector (partition size 1 full-row))\n                                                                  shift         (range (inc (- (apply max (map count V)) (count full-row))))]\n                                                              [[(+ x shift) y] row])\n                                            dpr             (filter #(apply distinct? (% 1)) pr)\n                                            gdpr            (group-by #(set (% 1)) dpr)\n                                            sgdpr           (map (fn [[s row]]\n                                                                             (filter (fn [index-rows]\n                                                                                       (let [indices (map first index-rows)\n                                                                                             rows    (map second index-rows)]\n                                                                                         (and (apply = (map first indices))\n                                                                                              (not= -1 (java.util.Collections/indexOfSubList (range (count V)) (map second indices)))\n                                                                                              (every? distinct? rows)\n                                                                                              (every? (partial apply distinct?) (apply map vector rows)))))\n                                                                               (partition size 1 (sort-by first row)))) gdpr)\n                                            csgdpr          (apply concat sgdpr)\n                                            squares         (map #(map second %) csgdpr)\n\n                                            ]\n                                            (count (distinct squares))))]\n\n\n  (into {} (for [size (range 2 (inc (min (count V) (apply max (map count V)))))\n                 :let  [num-squares (num-latin-squares V size)]\n                 :when (not= 0 num-squares)]\n             {size num-squares}))))", "problem": 152, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [x]\n  (letfn [\n          (row-columns [x] (concat x (apply map list x)))\n          (latin? [x] \n            (every? \n             #(and \n               (= (set %) (set (flatten x))) \n               (apply = (vals (frequencies %)))) \n             (row-columns x)))\n          (unzip-seq [c]\n            (reduce \n             (fn [c e] \n               (reduce \n                #(concat % (map (fn [p] (conj p %2)) c)) \n                [] e)) \n             [[]] c))\n          (alignments [x]\n            (let [width (last (sort (map count x)))]\n              (vec (unzip-seq (map #(range (inc (- width (count %)))) x)))))\n          (profile [s] (mapv #(set (keys %)) s))\n          (s-map [a x]\n            (mapv #(zipmap (range % (+ % (count %2))) %2) a x))\n          (mining [s]   \n            (map\n             (fn [r] (reductions (fn [a b] (set (filter a b))) r))\n             (drop-last (take-while seq (iterate next (profile s))))))\n          (h-slice [m]\n            (let [n (count m)]\n              (if (< (count (last m)) n) []\n                  (concat [(map #(take n %) m)] (h-slice (map next m))))))\n          (gen-maps [s]  \n            (for [ m (mapv vector (iterate next s) (mining s))\n                  [i c] (map list (range 1 (count (m 1))) (next (m 1))) \n                  :while (> (count c) i)]\n              (map #(replace % %2) (m 0) (take (inc i) (repeat c)))))\n          (lift-data [m s]\n            (map #(replace (s %) (m %)) (range (count m))))           \n          ]\n    (->> x\n         (alignments)\n         (map #(s-map % x))\n         (mapcat #(->> %\n                       (gen-maps)\n                       (mapcat h-slice)\n                       (filter latin?)))\n         (distinct)\n         (map count)\n         (frequencies))))", "problem": 152, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn latin-square-slicing [semi-rectangle] \n\t(letfn [\n\t\t(row-count [semi-rectangle] (count semi-rectangle))\n\n(column-count [semi-rectangle] (apply max (map count semi-rectangle)))\n\n(dimensions [semi-rectangle] ((juxt row-count column-count) semi-rectangle))\n\n(is-square? [semi-rectangle] (= 1 (count (distinct (dimensions semi-rectangle)))))\n\n(unique-values [semi-rectangle] (distinct (mapcat identity semi-rectangle)))\n\n(row-column-value-triples [semi-rectangle] (mapcat identity (map-indexed (fn [row-index row] (map-indexed (fn [column-index value] [(+ row-index 1) (+ column-index 1) value]) row)) semi-rectangle)))\n\n(row-value-pairs [semi-rectangle] (map #(seq [(nth % 0) (nth % 2)]) (row-column-value-triples semi-rectangle)))\n\n(column-value-pairs [semi-rectangle] (map #(seq [(nth % 1) (nth % 2)]) (row-column-value-triples semi-rectangle)))\n\n(has-no-duplicates? [xs] (= (count xs) (count (distinct xs))))\n\n(unique-values-count [semi-rectangle] (count (unique-values semi-rectangle)))\n\n(square-size [square] (row-count square))\n\n(is-latin-square? [semi-rectangle] (and (is-square? semi-rectangle) (= (unique-values-count semi-rectangle) (square-size semi-rectangle)) (has-no-duplicates? (row-value-pairs semi-rectangle)) (has-no-duplicates? (column-value-pairs semi-rectangle))))\n\n(pad-to [n row] (concat row (repeat (- n (count row)) nil)))\n\n(partitioned-rows [rectangle n] (map (partial partition n 1) rectangle))\n\n(columns [rectangle] (apply map vector rectangle))\n\n(subsquares-of-size [rectangle subsquare-size] (mapcat (partial partition subsquare-size 1) (columns (partitioned-rows rectangle subsquare-size))))\n\n(subsquares [rectangle] (map #(subsquares-of-size rectangle %) (range 2 (+ 1 (apply min (dimensions rectangle))))))\n\n(row-rotations [row size] (take (inc (- size (count row))) (map (partial pad-to size) (iterate (partial cons nil) row))))\n\n(combinations [groups] (if (empty? groups) [[]] (mapcat #(map % (combinations (rest groups))) (map #(partial cons %) (first groups)))))\n\n(all-rotations [semi-rectangle] (map #(row-rotations % (column-count semi-rectangle)) semi-rectangle))\n\n(alignments [semi-rectangle] (combinations (all-rotations semi-rectangle)))\n\n(contains-nil [square] (some nil? (flatten square)))\n]\n(frequencies (map count (filter is-latin-square? (filter #(not (contains-nil %)) (distinct (mapcat identity (mapcat identity (map subsquares (alignments semi-rectangle)))))))))))", "problem": 152, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn __ [coll]\n  (let [candidates\n          (fn candidates [size array]\n            (let [height (count array)\n                  height-range (range (- (inc height) size))\n                  width (count (first array))\n                  width-range (range (- (inc width) size))]\n              (for [row height-range\n                    col width-range\n                    :let [segment (map #(take size (drop col %))\n                                       (take size (drop row array)))]\n                    :when (not-any? #(= nil %) (flatten segment))]\n                segment)))\n        uniques?\n          (fn uniques? [array] \n            (= (count array) (count (distinct (flatten array)))))\n        latin?\n          (fn latin? [square]\n            (if (uniques? square)\n                (and (every? uniques? square)\n                     (every? uniques? (apply map vector square)))))\n        merge-rows\n          (fn merge-rows [out in]\n            (for [o out\n                  i in]\n              (conj o i)))\n        gen-shifts\n          (fn gen-shifts [width coll]\n            (let [pad (- width (count coll))\n                  do-shift #(conj (vec (rest %)) nil)]\n              (cond\n                (zero? pad) [coll]\n                (empty? coll) [(vec (repeat pad nil))]\n                :else\n                  (take (inc pad) \n                        (iterate do-shift \n                                 (vec (apply conj (seq coll) \n                                                  (repeat pad nil))))))))\n        square-latin\n          (fn square-latin [n coll]\n            (filter latin? (mapcat #(candidates n %) coll)))\n        get-latin\n          (fn get-latin [coll]\n            (let [m (first (sort > (map count coll)))\n                  array (reduce merge-rows [[]] (map #(gen-shifts m %) coll))\n                  sizes (range 2 (inc (min (count coll) m)))]\n              (mapcat #(square-latin % array) sizes)))\n        squares (distinct (get-latin coll))]\n    (into {}\n          (for [[k v] (group-by count squares)]\n            [k (count v)]))))", "problem": 152, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn __\n  [collection]\n  (letfn\n    [(latin-sq?\n      [coll]\n      (let [v (sort (set (first coll)))]\n        (and (not (empty? coll))\n             (every? #(= v (sort %)) (rest coll))\n             (every? #(= v (sort %)) (apply map vector coll)))\n        )\n      )\n     (sub-sq\n      [coll [x1 x2] [y1 y2]]\n      (let [dx (- x2 x1)\n            dy (- y2 y1)]\n        (if (= dx dy)\n          (let [rows (take dy (drop y1 coll))]\n            (if (every? #(<= x2 (count %)) rows)\n              (map #(take dx (drop x1 %)) rows)\n              )\n            )\n          )\n        )\n      )\n     (latin-sqs\n      [coll maxlen]\n      (let [width maxlen\n            height (count coll)]\n        (apply concat\n         (for [i (range 2 (inc (min width height)))]\n           (for [x (range (inc (- width i)))\n                 y (range (inc (- height i)))\n                 :let [subv (sub-sq coll [x (+ x i)] [y (+ y i)])]\n                 :when (latin-sq? subv)]\n             subv\n             )\n           )\n               )\n        )\n      )\n     (enum-aligns\n      [coll xlen]\n      (if (empty? coll)\n        []\n        (let [row (for [x (range (inc (- xlen (count (first coll)))))]\n                    [(concat (repeat x nil) (first coll))])\n              others (enum-aligns (rest coll) xlen)]\n          (if (empty? others)\n            row\n            (for [a row\n                  b others]\n              (concat a b)\n              )\n            )\n          )\n        )\n      )]\n    (let [maxlen (apply max (map count collection))\n          aligns (enum-aligns collection maxlen)\n          sqs (set (filter (complement empty?) (mapcat #(latin-sqs % maxlen) aligns)))]\n      (reduce (fn [m [k v]] (assoc m k v)) {}\n              (map (fn [[k v]] [k (count v)]) (group-by count sqs)))\n      )\n    )\n  )", "problem": 152, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn latin-square-slicing [V]\n  (letfn [(latin-square [n r c]\n            (let [elts (subvec (vec (V r)) c (+ c n))\n                  max-length (apply max (map count V))\n                  super-permutations?\n                    (fn [v1 v2]\n                      (and\n                        (= (set v1) (set v2))\n                        (every?\n                          #(not= (nth v1 %) (nth v2 %))\n                          (range 0 (count v1)))))\n                  ]\n              (loop [row-index (inc r), square [elts]]\n                (if (= n (count square))\n                  square\n                  (let [row (V row-index)\n                        ]\n                    (when-let [square-row\n                                (first\n                                  (for [shift (range (max\n                                                       (- (count (V (dec row-index))) max-length)\n                                                       (- (count row) max-length))\n                                                     (inc (- max-length (count row))))\n                                        :let [;_ (println \"row-index: \" row-index \"row: \" row \"column: \" c \"shift: \" shift \"left: \" (- c shift) \"right: \" (+ (- c shift) n))\n                                              elts-in-row (when\n                                                            (and\n                                                              (contains? row (- c shift))\n                                                              (contains? row (dec (+ n (- c shift)))))\n                                                            (subvec row (- c shift) (+ (- c shift) n)))]\n                                        :when (and elts-in-row\n                                                   (every? #(super-permutations? elts-in-row %)\n                                                           square))]\n                                    elts-in-row))]\n                    (recur (inc row-index) (conj square square-row))))))))\n          ]\n\n      \n        (let [cc (for [r (range 0 (dec (count V)))\n              c (range 0 (dec (count (V r))))\n              n (range 2 (min (inc (- (count V) r))\n                              (inc (- (count (V r)) c))))\n              :let [square (latin-square n r c)]\n              :when square]\n          square)]\n          (loop [r {} t (map count (set cc))]\n          (if (empty? t) r\n            (let [e (first t)]\n              (recur (assoc r e (if-let [v (r e)] (inc v) 1)) (rest t))\n            )\n          )\n          )\n        )\n\n))", "problem": 152, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [vetor]\n    (let [maior-comprimento (apply max (map count vetor))\n          dimensao-maxima (min (count vetor) maior-comprimento)]\n      (letfn [(gera-linhas-possiveis []\n                                     (map (fn [row]\n                                            (vec (map #(vec (concat (repeat % 'x)\n                                                                    row\n                                                                    (repeat (- maior-comprimento (count row) %) 'x)))\n                                                      (range (inc (- maior-comprimento (count row)))))))\n                                          vetor))\n              (gera-alinhamentos [[possibilidades-primeira-linha & possibilidades-outras-linhas]]\n                                 (reduce (fn [resultados possibilidades-linha]\n                                           (for [resultado resultados\n                                                 linha-possivel possibilidades-linha]\n                                             (conj resultado linha-possivel)))\n                                         (map vector possibilidades-primeira-linha)\n                                         possibilidades-outras-linhas))\n              (coordenadas-possiveis [dimensao]\n                                     (for [linha (range (- (count vetor) (dec dimensao)))\n                                           coluna (range (- maior-comprimento (dec dimensao)))]\n                                       [linha coluna]))\n              (gera-quadrados [dimensao alinhamento]\n                            (mapcat (fn [fatia]\n                                      (let [menor-coluna (some (fn [coluna] \n                                                                 (when (not ((set (map (fn [linha]\n                                                                                         (get-in fatia [linha coluna]))\n                                                                                       (range dimensao)))\n                                                                             'x))\n                                                                   coluna))\n                                                               (range (count (first fatia))))\n                                            maior-coluna (some (fn [coluna] \n                                                                 (when (not ((set (map (fn [linha]\n                                                                                         (get-in fatia [linha coluna]))\n                                                                                       (range dimensao)))\n                                                                             'x))\n                                                                   coluna))\n                                                               (range (dec (count (first fatia))) 0 -1))]\n                                        (when (and (not (nil? menor-coluna))\n                                                   (not (nil? maior-coluna))\n                                                   (>= (- maior-coluna menor-coluna) (dec dimensao)))\n                                          (map (fn [coluna-pivot]\n                                                 (vec (map (fn [linha-corrente]\n                                                             (vec(map (fn [coluna-corrente]\n                                                                        (get-in fatia [linha-corrente coluna-corrente]))\n                                                                      (range coluna-pivot (+ coluna-pivot dimensao) 1))))\n                                                           (range dimensao))))\n                                               (range menor-coluna (- maior-coluna (- dimensao 2)) 1)))))\n                                    (map (fn [linha]\n                                           (apply vector (map (partial get alinhamento) \n                                                              (map #(+ linha %) (range dimensao)))))\n                                         (range (- (count alinhamento) (dec dimensao))))))\n              (latin-square? [quadrado]\n                             (let [dimensao (count quadrado)]\n                               (and (= dimensao ((comp count set first) quadrado))\n                                    (apply = (concat (map set quadrado)\n\t                                                     (map (fn [coluna]\n\t                                                            (set (map (fn [linha]\n\t                                                                      (get-in quadrado [linha coluna]))\n\t                                                                    (range dimensao))))\n\t                                                        (range dimensao)))))))]\n\t      (->> (gera-linhas-possiveis)\n\t           gera-alinhamentos\n             (mapcat (fn [alinhamento]\n                       (mapcat (fn [dimensao]\n                                 (gera-quadrados dimensao alinhamento))\n                               (range 2 (inc dimensao-maxima) 1))))\n\t           (filter latin-square?)\n\t           set\n\t           (reduce (fn [mapa quadrado]\n\t                     (let [dimensao (count quadrado)]\n\t                       (assoc mapa dimensao (inc (get mapa dimensao 0)))))\n\t                   {})))))", "problem": 152, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [input]\n  (let [longest (fn [xs] (apply max (map count xs)))\n        configuration-offsets (fn [xs]\n                                (into {}\n                                      (map-indexed\n                                       #(identity [% (range (inc (- (longest xs) (count %2))))]) xs )))\n        arrangements (fn [offsets]\n                       (let [fetch #(get offsets % [nil])]\n                         (mapcat (fn [a]\n                                   (mapcat (fn [b]\n                                             (mapcat (fn [c]\n                                                       (mapcat (fn [d]\n                                                                 (mapcat (fn [e]\n                                                                           (map (fn [f]\n                                                                                  (filter (comp not nil?) [a b c d e f]))\n                                                                                (fetch 5)))\n                                                                         (fetch 4)))\n                                                               (fetch 3)))\n                                                     (fetch 2)))\n                                           (fetch 1)))\n                                 (fetch 0))))\n        lookup (fn [xs arrangement x y ]\n                 (if (or (< y 0) (>= y (count xs)))\n                   nil\n                   (let [offsetx (- x (nth arrangement y))]\n                     (if (or (< offsetx 0) (>= offsetx (count (nth xs y))))\n                       nil\n                       (nth (nth xs y) offsetx)))))\n        mk-row (fn [xs arr x y size]\n                 (into []\n                       (map #(lookup xs arr % y) (range x (+ x size)))))\n        mk-square (fn mk-square [xs arr x y size]\n                    (into []\n                          (map #(mk-row xs arr x % size) (range y (+ y size)) )))\n        mk-squares (fn [xs]\n                     (mapcat (fn [x]\n                               (mapcat (fn [y]\n                                         (mapcat (fn [size]\n                                                   (map (fn [arrangement]\n                                                          (mk-square xs arrangement x y size))\n                                                        (arrangements (configuration-offsets xs))))\n                                                 (range 2 (inc (count xs)))))\n                                       (range (count xs))))\n                             (range (longest xs))))\n        nil-free? (fn [xs] \n                    (not (some nil? (flatten xs))))\n        transpose (fn [xs]\n                    (apply mapv vector xs))\n        latin? (fn [xs]\n                 (let [size (count xs)]\n                   (and\n                    (= size (count (distinct (flatten xs))))\n                    (every? #(= size (count (distinct %))) xs)\n                    (every? #(= size (count (distinct %))) (transpose xs)))))\n        latins (filter latin? (distinct (filter nil-free? (mk-squares input))))]\n    (frequencies (map count latins))))", "problem": 152, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn __ [V] \n  (let [w (apply max (map count V))\n        h (count V)\n        transpose (fn [sq] (apply mapv vector sq))\n        latin-sq? (fn [sq w]\n                    (and\n                      (= w (count sq))\n                      (every? #(= w (count %)) sq)\n                      (= w (count (distinct (apply concat sq))))\n                      (every? #(= w (count (distinct %))) sq)\n                      (every? #(= w (count (distinct %))) (apply mapv vector sq))\n                      ))\n        vs (fn [maxv]\n             (loop [acc [[]] current-maxv maxv]\n              (if (empty? current-maxv) acc\n                (let [[x & xs] current-maxv]\n                  (recur (for [coll acc i (range (inc x))] (conj coll i)) xs)))))\n\n        squares (apply concat \n                       (for [top (range h) width (range 2 (inc (- h top) )) \n                             :let [band (take width (drop top V))] \n                             :when (every? #(<= width (count %)) band)]\n                         (for [lefts (vs (map #(- w %) (map count band)))\n                               left (range (apply max lefts) (inc (- w width)))\n                               :let [left-paddeds (map #(concat (repeat %1 nil) %2) lefts band)\n                                     sq (map #(take width %) (map #(drop left %) left-paddeds))\n                                     ]\n                               :when (latin-sq? sq width)]\n                           sq )))\n        ans (into {}\n                  (map (fn [[k v]] [k (count v)])\n                    (group-by count (distinct squares))))\n        ]\n    ans\n))", "problem": 152, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [xs]\n    (let [cart       (fn cart [ls]\n                       (if-let [[l & r] ls]\n                         (for [x1 l\n                               r2 (cart r)]\n                           (cons x1 r2))\n                         '(())))\n          max-count  (apply max (map count xs))\n          shifts     (fn shifts [ls] \n                       (cart (map (comp range inc (partial - max-count) count) ls)))\n          pad        (fn pad [ls s] (map #(concat\n                                            (repeat %1 'X)\n                                            %2\n                                            (repeat (- max-count %1 (count %2)) 'X))\n                                         s ls))\n          subsquare  (fn subsquare [l i j m]\n                       (->> l\n                            (map (comp (partial take m) (partial drop j)))\n                            (drop i)\n                            (take m)))\n          subsquares (fn subsquares [l]\n                       (for [m (range 2 (inc (max (count l) (count (first l)))))\n                             i (range (inc (- (count l) m)))\n                             j (range (inc (- (count (first l)) m)))]\n                         (subsquare l i j m)))\n          transpose  (partial apply map list)\n          is-latrow? (fn [l s]\n                         (every? (comp (partial = s) set) l))\n          is-latin?  (fn [l]\n                       (let [s (set (apply concat l))]\n                         (and (= (count s) (count l))\n                              (not (contains? s 'X))\n                              (is-latrow? l s)\n                              (is-latrow? (transpose l) s))))]\n\n      (->> xs\n           shifts\n           (map (partial pad xs))\n           (mapcat subsquares)\n           (distinct)\n           (filter is-latin?)\n           (map count)\n           (frequencies))))", "problem": 152, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [q] \n  (let [n (count q)\n        m (apply max (map count q))\n        indexed-segments (fn [row size]\n          (let [shifts (->> row count (- m) inc range)\n                i-segs (map-indexed vector (partition size 1 row))\n                kvs (for [[i seg] i-segs \n                          :let [s (set seg)] \n                          :when (= (count seg) (count s)) \n                          shift shifts] \n                      {[(+ i shift) s] [[seg]]})]\n            (apply merge-with concat kvs)))\n        prodcat (fn [xs ys]\n          (for [x xs\n                y ys]\n            (concat x y)))\n        candidates (fn [size] \n          (apply concat\n                 (map second \n                      (mapcat \n                        #(reduce (partial merge-with prodcat) %) \n                        (partition size 1 (map #(indexed-segments % size) q))))))\n        squares (fn [size]\n          (filter #(apply = (apply map (comp set list) %)) (candidates size)))]\n  (into \n    {} \n    (for [size (range 2 (inc (min n m)))\n          :let [cnt (count (set (squares size)))]\n          :when (pos? cnt)] \n      [size cnt]))))", "problem": 152, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [in](let [inp (vec (filter #(not (= %1 []))  in))\n                             \n                             max-length (apply max (map count inp) )\n\n                              height (count inp)\n\n                             template   (zipmap (range 0 max-length)   (map (fn [i] (filter (fn [j] (<= (+ j (count i)) max-length)) (range 0 max-length))) inp))\n\n\n                              combis     ((fn foo [val inp index] (cond (> index (first (keys inp))) val\n                                                                        :else (map (fn [i] (foo (conj val i) inp (+ index 1)) ) (inp index)))) [] template 0) \n  \n                              combis-sep (loop [data (vec (flatten combis)) length (count inp) res []] (cond (not (seq data))          res\n                                                                                                   :else   (recur (subvec data length) length (conj res (subvec data 0 length)) )))\n\n                              combis-borders (vec (map #(loop [line 0 res []]  (cond (>= line (count inp))     res               \n                                                                                :else                     (recur (+ line 1) (conj res  [(%1 line) (+ (%1 line) (count (inp line)))])))) combis-sep))                                                           \n                              \n                              square-exists? (fn  [borders startx starty order] (loop [row starty res true]\n                                                                                  (cond (not res) false                                                                                        \n                                                                                        (= row (+ starty order)) true\n                                                                                        (>= row height) false\n                                                                                        :else    (recur (inc row) (and (>= startx ((borders row) 0)) (< (+ startx (dec order)) ((borders row) 1))))))) \n\n                              cut-square (fn [borders startx starty order] (loop [row starty res []]\n                                                                             (cond (>= row (+ starty order)) res\n                                                                                   :else      (recur (inc row) (conj res (subvec (inp row) (- startx ((borders row) 0)) (+ (- startx ((borders row) 0)) order) ))))))\n                              \n\n\n\n\n                             is-lsqure? (fn [lsq] (let [members (set (lsq 0))\n                                                        order (count (lsq 0))] (and      (loop [row 0 res true  ]\n                                                                                           (cond (not res) false\n                                                                                                 (>= row (count lsq)) res\n                                                                                                 :else (recur (inc row) (and res (= (set (lsq row)) members) (= order (count (set (lsq row))))))))\n                                                                                         \n                                                                                         (let [ transposed  (loop [i 0 res []] (cond (>= i  (count lsq)) res                         \n                                                                                                                                             :else (recur (inc i) (vec (conj res (vec (map  #(%1 i) lsq)))))))]\n                                                                                           (loop [row 0 res true  ]\n                                                                                             (cond (not res) false\n                                                                                                   (>= row (count transposed)) res\n                                                                                                   :else (recur (inc row) (and res (= (set (transposed row)) members) (= order (count (set (transposed row))))))))))))\n                                                                                                  \n                                                                                              \n                                                                                          \n                              generate-lsquares-at (fn [pos-x pos-y]                                             \n                                          (vec   (reduce concat    \n                                                     (vec (filter #(not (= %1 [] ))\n                                                       (map  #(loop [order 2 res []] \n                                                           (cond (not (square-exists? %1 pos-x pos-y order))  res\n                                                                 (is-lsqure? (cut-square %1 pos-x pos-y order)) (recur (inc order) (conj res (cut-square %1 pos-x pos-y order) )) \n                                                                 :else (recur (inc order) res)))   combis-borders))))))\n\n\n                              generate-lsquares (vec (reduce concat\n                                                        (vec (filter #(not (= %1 [] ))   \n                                                                     (loop [x 0 y 0 res []]\n                                                                       (cond (>= y height) res\n                                                                             (>= x max-length) (recur 0 (inc y) res)\n                                                                             :else (recur (inc x) y (conj res (generate-lsquares-at x y)))))))))                                                                                                            \n                        \n                             lsquares-set (vec (set generate-lsquares))                    \n                              \n                             lsquares-map (loop [i 0 res {}]\n                                            (cond (>= i (count lsquares-set)) res\n                                                  :else     (recur (inc i) (assoc res (count (lsquares-set i) ) (if (res (count (lsquares-set i)))  (inc (res (count (lsquares-set i)))) 1)))))\n\n                              \n                           \n]\n\nlsquares-map ))", "problem": 152, "user": "52f5eefbe4b09b582c12c9cb"}, {"code": "(fn [vs]\n    (let [latin-square? (fn [vs]\n                          (let [n (count vs)]\n                            (and\n                             ;; exactly n unique characters \n                             (= (count (distinct (flatten vs))) n)\n                             ;; n unique in row\n                             (every? #(= n (count (distinct %))) vs)\n                             ;; n unique in col\n                             (every? #(= n (count %)) (apply map #(distinct %&) vs))\n                             ;; no filler characters\n                             (not-any? #(= \\- %) (flatten vs)))))\n          \n          permutations (fn p\n                         [[variations & rest]]\n                         (if (empty? rest) (map list variations)\n                             (let [prest (p rest)]\n                               (mapcat #(map (partial cons %) prest) variations))))\n \n          arrangements (fn [vs]\n                         (let [m (reduce max (map count vs))\n                               pad-row (fn [row before after]\n                                         (concat (repeat before \\-)\n                                                 row\n                                                 (repeat after \\-)))\n                               padded-rows (fn [row]\n                                             (let [n (count row)]\n                                               (map #(pad-row row % (- m n %))\n                                                    (range (inc (- m n))))))]\n                           (permutations (map padded-rows vs))))\n          \n          count-rows (fn [vs]\n                       (->> vs\n                            distinct\n                            (filter latin-square?)\n                            count))\n\n          n-slices (fn [n vs]\n                     (let [group #(partition n 1 %)]\n                       (distinct\n                        (mapcat #(apply map vector (map group %))\n                                (group vs)))))]\n      \n      (let [ns (range 2 (inc (count vs)))\n            as (arrangements vs)\n            record-count (fn [acc n]\n                           (let [c (count-rows\n                                    (mapcat #(n-slices n %) as))]\n                             (if (> c 0)\n                               (conj acc [n c])\n                               acc)))]\n        \n        (reduce record-count {}  ns))))", "problem": 152, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [v]\n    (let [mks (fn [v] (reduce #(conj %1 %2) #{} v))\n          t_latin_sq (fn [n v]\n                       (when (and(= (* n n ) (count v))\n                                 (not-any? nil? v))\n                         (let [ve (partition n v)\n                               ho (for [i (range n)]\n                                    (take-nth n (nthrest v i))\n                                    )\n                               samp (mks (first ve))\n                               todo (map mks (concat (drop 1 ve) ho))]\n                           \n                           (when (= n (count samp))\n                             (every? #(= samp %) todo)\n                             ) \n                           \n                           )))\n          cart (fn cart [colls]\n                 (if (empty? colls)\n                   '(())\n                   (for [x (first colls)\n                         more (cart (rest colls))]\n                     (cons x more))))\n          \n          xpfxd-s (fn [v maxn]\n                    (let [cv (count v)]\n                      (for [y (range cv)\n                            n (range 2 (inc (min maxn cv (- cv y))))]\n                        [n (mapcat #(take n %) (take n (nthrest v y) ))]\n                        )))\n          tvarxxd-s (fn [v d]\n                    (let [dt d\n                          dmax (apply max (map + dt (map count v)))\n                          dmin (apply min dt)\n                          aac (map #(- % dmin) dt)\n                          nv (map #(concat (repeat %1 nil) %2) aac v)\n                          lmax (apply max (map count nv))\n                          ]\n                      \n                      (for [x (range lmax)\n                            :let [nnv (map #(nthrest % x) nv)\n                                  nmax (min (- lmax x) (count v) )\n                                  ]]\n                        (xpfxd-s nnv nmax)\n                        )))\n          dfx (fn dfx [v]\n                (let [ls (map #(count %) v)\n                      ml (apply max ls)]\n                  (map #(range (inc (- ml %)))  ls)\n                  ))\n          pd (fn [v d] \n               (filter #( apply t_latin_sq %) (apply concat (tvarxxd-s v d)) ))\n\n          ]\n      (frequencies (map first (reduce conj #{} (mapcat #(pd v %) (cart (dfx v))))))))", "problem": 152, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn latin-square-slicing [xs]\n\n  (letfn [\n\n          (matrix? [n xs] \n            (let [matrix (map (partial take n) xs)] \n              (cond\n                (> n (count matrix)) nil\n                (not-every? (partial = n) (map count xs)) nil\n                :else matrix\n                ))\n            )\n\n          (latin? [n xs]\n            (let [rows (map (partial into #{}) xs)\n                  cols (map (partial into #{}) (apply map vector xs))]\n              (and\n                (apply = (clojure.set/union rows cols))\n                (= n (count (first rows))) \n                (every? identity (first rows)))))    \n\n          (matrices [n xs]\n            (for [todrop (range)\n                  :let [rows (take n (drop todrop xs))]\n                  :while (>= (count rows) n)\n                  todrop2 (range)\n                  :let [cols (map #(take n (drop todrop2 %)) rows)]\n                  :let [m (matrix? n cols)]\n                  :while m\n                  :when (latin? n m)]\n              m)\n            )\n\n          (pads [xs]\n            (let [maxlen (apply max (map count xs))]\n              (map #(- maxlen (count %)) xs)))\n\n          (combinations [[xs & xss]]\n            (if (nil? xss)\n              (map vector xs)\n              (for [item xs\n                    others (combinations xss)]\n                (cons item others)\n                )))\n\n          (get-matrices [xs]\n            (let [offsets (map (comp range inc) (pads xs))\n                  alignments (combinations offsets)]\n              (into {}\n                    (for [n (range 2 (inc (count xs)))\n                          :let [ms (mapcat\n                                     (fn [offset] \n                                       (let [aligned-xs (map #(concat (repeat %1 nil) %2) offset xs)]\n                                         (matrices n aligned-xs))\n                                       )\n                                     alignments)]\n                          :when (not-empty ms)]\n                      [n (count (into #{} ms))]))))]\n\n    (get-matrices xs)))", "problem": 152, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "problem": 152, "user": "50436470e4b034ff00315d23"}, {"code": "(fn latin-summary [colls]\n  (letfn [(half-pairs [coll]\n                      (let [n (count coll)]\n                        (for [i (range n)\n                              j (range (inc i) n)]\n                          [(nth coll i) (nth coll j)])))\n          \n          (rotate [v]\n                  (conj (subvec v 1) (nth v 0)))\n          \n          \n          (pad [v n]\n               (let [mem (transient [])]\n                 (dotimes [i (- n (count v))]\n                   (conj! mem nil))\n                 (doseq [x v] (conj! mem x))\n                 (persistent! mem)))\n          \n          (layouts [k vs]\n                   (when-first [v vs]\n                     (let [num-rotations (- k (count v))\n                           padded (pad v k)\n                           rotations (take (inc num-rotations) (iterate rotate padded))\n                           sublayouts (layouts k (rest vs))]\n                       (for [s (or sublayouts [[]])\n                             r rotations]\n                         (conj s r)))))\n          \n          \n          (subsquare [layout n x y]\n                     (map #(subvec % y (+ n y))\n                          (subvec layout x (+ n x))))\n          \n          (subsquares [layout]\n                      (let [n (count layout)\n                            k (count (first layout))]\n                        (for [i (range 2 (inc (min n k)))\n                              x (range (- n (dec i)))\n                              y (range (- k (dec i)))]\n                          (subsquare layout i x y))))\n          (no-two-equal? [coll]\n                         (let [mem (transient #{})]\n                           (loop [remaining coll]\n                             (if-let [s (seq remaining)]\n                               (let [x (first s)]\n                                 (when-not (mem x)\n                                   (conj! mem x)\n                                   (recur (next s))))\n                               true))))\n          (latin-square? [square]\n                         (and \n                          (every? true? (apply map (comp no-two-equal? list) square))\n                          (apply = (map sort square))))\n          (latin-squares [colls]\n                         (let [k (apply max (map count colls))]\n                           (->> colls\n                                (layouts k)\n                                (mapcat (fn [layout]\n                                          (->> layout\n                                               subsquares\n                                               (filter #(every? (partial not= nil) (flatten %)))\n                                               (filter latin-square?))))\n                                set)))]\n    (->> colls\n         latin-squares\n         (group-by count)\n         (map (juxt first (comp count second)))\n         (into {}))))", "problem": 152, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [b]\n  (let [M (apply max (map count b))]\n    (->>\n      (reduce\n        (fn [[s m] v]\n          (reduce\n            #(reduce (fn [[s m] [[l o h] v]]\n                       (if (= l h)\n                         [(conj s v) m]\n                         [s (update-in m [l o h] conj v)]))\n                     %1 %2)\n            [s {}]\n            (for [w [(count v)]\n                  l (range 2 (+ w 1))\n                  o (range (- M w -1))\n                  i (range (- w l -1))\n                  :let [o (+ o i)\n                        v (subvec v i (+ i l))]\n                  :when (apply distinct? v)]\n              (cons\n                [[l o 1] [v]]\n                (for [[h ps] (get-in m [l o])\n                      p ps]\n                  [[l o (+ h 1)] (conj p v)])))))\n        [[] {}]\n        b)\n      first\n      distinct\n      (filter\n        #(apply =\n                (concat\n                  (map set %)\n                  (apply map sorted-set %))))\n      (group-by count)\n      (map (fn [[k v]] [k (count v)]))\n      (into {}))))", "problem": 152, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn latin-square-slicing [[xs :as xss]]\n\n  (let [latin? (fn latin? [[xs :as xss]]\n                 (and\n                  (every? not-empty xss)\n                  (= (count xs) (count (distinct (flatten xss))))\n                  (every? #(apply distinct? %) xss)\n                  (every? #(apply distinct? %) (apply map vector xss))))\n\n        ;; clojail chokes on this for comprehension.  why?        \n        slice4 (fn slice4 [[xs :as xss] w]\n                (for [i (range 0 (- (count xs) w -1))\n                      j (range 0 (- (count xss) w -1))]\n                  (map #(take w (drop i %))\n                       (take w (drop j xss)))))\n\n        ;; ugly desugaring here:\n        unfor2 (fn [f x y] (mapcat (fn [a] (map (fn [b] (f a b)) y)) x))\n\n        slice (fn slice [[xs :as xss] w]\n                 (unfor2 (fn [a b]\n                           (map #(take w (drop a %))\n                                (take w (drop b xss))))\n                         (range 0 (- (count xs) w -1))\n                         (range 0 (- (count xss) w -1))))\n\n        pads (fn pads [xs w]\n               (for [n (range 0 (- w (count xs) -1))]\n                 (take w (concat (repeat n ::pad) xs (repeat 0)))))\n\n        add-pads (fn add-pads [[h & t] w]\n                   (if h\n                     (for [p (pads h w) z (add-pads t w)] (cons p z))\n                     [[]]))\n\n        w (apply max (map count xss))\n        p (add-pads xss w)\n        o (for [x (range w 1 -1)\n                y p\n                z (slice y x)\n                :when (latin? z)]\n            [x z])]\n\n    (into {}\n          (map (fn [[k v]] [k (count v)])\n               (group-by first (distinct o))))))", "problem": 152, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(letfn [(rotate\n         [sqr]\n         (lazy-seq\n          (when (every? seq sqr)\n            (cons (map first sqr)\n                  (rotate (map rest sqr))))))\n        \n        (latin?\n         [sqr]\n         (let [elems (set (flatten sqr))]\n           (and (not (elems \\space))\n                (= (count elems) (count sqr))\n                (every? #(= elems (set %)) sqr)\n                (every? #(= elems (set %))\n                        (rotate sqr)))))\n        \n        (slice\n         [sqr]\n         (->> (count sqr)\n              (inc)\n              (range 2)\n              (mapcat\n               (fn [n]\n                 (mapcat\n                  #(->> (map (partial partition n 1) %)\n                        (apply interleave)\n                        (partition n))\n                  (partition n 1 sqr))))\n              (set)))\n        \n        (step\n         [head tail max-len]\n         (lazy-seq\n          (let [line (first tail)\n                size (count line)]\n            (if (seq line)\n              (if (= max-len size)\n                (step (cons line head)\n                      (rest tail)\n                      max-len)\n                (->> (count line)\n                     (- max-len)\n                     (inc)\n                     (range)\n                     (mapcat\n                      #(step\n                        (cons\n                         (concat\n                          (concat (repeat % \\space) line)\n                          (repeat (- max-len % size) \\space))\n                         head)\n                        (rest tail)\n                        max-len))))\n              head))))\n        \n        (trans\n         [sqr]\n         (->> (map count sqr)\n              (apply max)\n              (step [] sqr)\n              (partition (count sqr))\n              (set)))]\n  \n  (fn latin-slice [sqr]\n    (->> (trans sqr)\n         (mapcat slice)\n         (set)\n         (group-by count)\n         (map #(let [size (count (filter latin? (val %)))]\n                 (if (pos? size) {(key %) size} {})))\n         (apply merge))))", "problem": 152, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [x]\n    (let [E every?\n          R reduce\n          N mapcat\n          C count\n          M map\n          D concat\n          A apply\n          S subvec\n          T range\n          U repeat\n          V vector\n          I inc\n          n nil\n          s set\n          r #(let [f (s (A D %))]\n                   (E (fn [r]\n                        (let [R (s r)]\n                          (and\n                            (E R f)\n                            (= (C R) (C r)))))\n                      %))\n          hr (fn [[c t n]]\n               (M\n                 (fn [d]\n                   (M #(S % d (+ d t))\n                      n)) \n                 (T (- c t))))]\n      (->>\n        ((fn rec [[r & rs] m]\n           (let [d (- m (C r))\n                 p (mapv\n                       #(vec\n                          (take m\n                                (D (U % n)\n                                    (D r (U d n)))))\n                       (T (I d)))]\n             (if (seq rs)\n               (N #(M (fn [o]\n                         (conj o %))\n                       (rec rs m)) \n                   p) \n               (mapv V p))))\n           x (R max (M C x)))\n        (N #(let [c1 (I (C %))\n                   c (I (C (first %)))\n                   nr (N (fn [d]\n                            (M (fn [t]\n                                 [c t (S % d (+ d t))])\n                               (T 2 (- c1 d))))\n                          (T (- c 2)))]\n               (N hr nr)))\n        s\n        (filter #(and (r %)\n                     (r (A M V %))))\n        (M C)\n        frequencies\n        )))", "problem": 152, "user": "53460d02e4b084c2834f4a39"}, {"code": "(letfn [(L? [m]\n          \"Is m Latin?\"\n          (letfn [(T' [m] (apply map list m))]\n            (and (not (empty? m))\n                 (= (-> m first count) (-> m first set count))\n                 (apply = (concat (map set m) (map set (T' m)))))))\n\n        (V? [m]\n          \"Is matrix valid?\"\n          (every? #(every? identity %) m))\n\n        (F? [m]\n          (and (V? m) (L? m)))\n\n        (R [n l]\n          \"Generate slides of l\"\n          (for [left (range (inc (- n (count l))))]\n            (concat (repeat left false)\n                    l\n                    (repeat (- n (count l) left) false))))\n\n        (M [m]\n          \"select one item from each row\"\n          (if (empty? m) [[]]\n              (for [x (first m)\n                    ys (M (rest m))]\n                (cons x ys))))\n\n        (P [m]\n          \"generate all config\"\n          (let [w (apply max (map count m))]\n            (M (map #(R w %) m))))\n\n        (S [s m]\n          \"generate sub-matrix with size s from m\"\n          (let [h (count m)\n                w (count (first m))]\n            (for [i (range 0 (inc (- h s)))\n                  j (range 0 (inc (- w s)))]\n              (map #(take s (drop j %))\n                   (take s (drop i m))))))\n\n        (X [m]\n          (let [ms (P m)]\n            (loop [s 2 result (hash-map)]\n              (if (> s (count m)) result\n                  (let [c (->> (map #(filter F? (S s %)) ms)\n                               (apply concat)\n                               set\n                               count)]\n                    (if (zero? c)\n                      (recur (inc s) result)\n                      (recur (inc s) (assoc result s c))))))))]\n\n  X)", "problem": 152, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn f152 [a] \n  (let\n    [alm (apply max (map count a))\n     \n     sq (fn sq [size]\n       (apply concat (for [start (range 0 (inc (- (count a) size)))]\n         (let [slice (take size (drop start a))\n               order (sort-by second (map-indexed #(list %1 %2) slice))\n               slice (map second order)\n               order (map first order)\n               biggest (last slice)\n               lm (count biggest)\n               rest (butlast slice)]\n           (if (>= (count (first slice)) size)\n             (for [offset (range 0 (inc (- lm size)))]\n               (let [f #(let [from (max 0 (- offset (- alm (count %))))\n                              to (min (- (count %) size) (+ offset (- alm lm)))]\n                          (map (partial take size) (map (fn [x] (drop x %)) (range from (inc to)) )))\n                     \n                     r (conj (apply vector (map f rest))\n                             (list (take size (drop offset biggest))))\n                     \n                     unorder (map first (sort-by second (map-indexed #(list %1 %2) order)))]\n                 (map #(r %) unorder)) ))))))\n     \n     comb (fn comb [l]\n            (if (empty? l)\n              [[]]\n              (for [a (first l) b (comb (next l))] (cons a b))\n              ))\n\n     test (fn [e]\n          (let\n            [e (map (partial apply vector) e)\n             e (apply vector e)\n             sq (set(flatten e))\n             ]\n            (if (and\n                 (= (count sq) (count e))\n                 (every? identity (map #(= sq (set %)) e))                         \n                 (every? identity (for [i (range (count e))] (= sq (set (for [j (range (count e))] ((e j) i) )))))\n                 )\n              true\n              false)))\n     \n     all (filter #(> (count %) 0) (for [size (range 2 (inc alm))] (filter test (set (apply concat (map comb (sq size))) ))))\n     ]\n    (zipmap (map (comp count first) all) (map count all))\n))", "problem": 152, "user": "5349ac2be4b084c2834f4a67"}, {"problem": 152, "code": "(fn latin-squares [rows]\n  (let [max-length (apply max (map count rows))\n        sizes (range 2 (inc (min max-length (count rows))))\n        pad (fn [row shift]\n              (vec (concat (repeat shift nil) row (repeat (- max-length (+ shift (count row))) nil))))\n        expanded-rows (map #(for [padding (range 0 (inc (- max-length (count %))))] (pad % padding)) rows)\n        form-alignments (fn [rows]\n                            (let [recursion (fn recurse [[rs & rss]]\n                                              (if (empty? rss)\n                                                (map list rs)\n                                                (mapcat (fn [r] (map #(cons r %) (recurse rss))) rs)\n                                                ))]\n                              (recursion expanded-rows)))\n        alignments (form-alignments rows)\n        square-from (fn [size row col alignment]\n                      ; Expanded for expression to get round timing limitations\n                      (map\n                       (fn [r]\n                         (let [rn (nth alignment r)]\n                           (map \n                            #(nth rn %)\n                            (range col (+ col size)))))\n                       (range row (+ row size))))\n        latin-square? (fn [square]\n                          (let [all-vals (set (flatten square))]\n                            (cond (some nil? all-vals) false\n                                  (not= (count all-vals) (count square)) false\n                                  (not-every? #(= (set %) all-vals) square) false\n                                  :else (every? #(= (set %) all-vals) (apply map list square)\n                            ))))\n        squares-in (fn [max-length size alignment]\n                       ; Expanded for expression to get round timing limitations\n                       (mapcat\n                        (fn [col]\n                          (filter\n                            latin-square?\n                            (map\n                             (fn [row] (square-from size row col alignment))\n                             (range 0 (inc (- (count alignment) size))))))\n                        (range 0 (inc (- max-length size)))))\n        count-squares-of-size (fn [size]\n                                (->> alignments\n                                     (mapcat #(squares-in max-length size %))\n                                     (filter not-empty)\n                                     (set)\n                                     (count)))]\n    (->> sizes\n         (map #(vector % (count-squares-of-size %)))\n         (filter #(pos? (second %)))\n         (flatten)\n         (apply hash-map))))", "user": "536ca4bde4b0fc7073fd6e49"}, {"problem": 152, "code": "(fn latin-squares [v]\n  (letfn [\n          (latin-square? [square] ; square is a seq where each n elements (of total n*n) represent a row\n            (let [n (-> square count Math/sqrt int)\n                  distinct-elements (distinct square)]\n              (if (= n (count distinct-elements)) ; satisfies one of the definition of latin square, so could be the one\n                (let [rows (partition n square)\n                      cols (apply map list rows)] \n                  (letfn [\n                          (unique-all? [rows-or-cols]\n                            (= (* n n) (reduce + (map (comp count distinct) rows-or-cols))))]\n                    (and \n                      (unique-all? rows)\n                      (unique-all? cols))))\n                false)))\n\n          (shift-row \n            [row]\n            (when (= 'X (last row)) ; so there is a space to shift\n              (let [n (count row)\n                    spaces-in-front (count (take-while #{'X} row))\n                    elements (take-while #(not= 'X %) (drop spaces-in-front row))]\n                (when (seq elements)\n                  (concat (repeat (inc spaces-in-front) 'X) elements (repeat (- n spaces-in-front (count elements) 1) 'X))))))\n\n          (reset-row\n            [row]\n            (let [symbols (filter #(not= 'X %) row)\n                  n (count row)]\n              (concat symbols (repeat (- n (count symbols)) 'X))))\n\n          (normalize \n            [v]\n            (let [max-length (apply max (map count v))\n                  rows (count v)                \n                  ]\n              (loop [i 0 normalized []]\n                (let [row (nth v i)\n                      normalized-row (concat row (repeat (- max-length (count row)) 'X))\n                      ]\n                  (if (= i (dec rows))\n                    (conj normalized normalized-row)\n                    (recur (inc i) (conj normalized normalized-row))\n                    )))))\n\n          (all-sub-squares \n            [v dimension]\n            (let [width (count (first v)) \n                  height (count v)\n                  max-x (- height dimension)\n                  max-y (- width dimension) \n                  ]\n              (loop [x 0 y 0 sub-squares []]\n                (let [sub-square \n                      (loop [i 0 square []]\n                        (if-not (= i dimension)\n                          (let [row (take dimension (drop y (nth v (+ i x))))] \n                            (recur (inc i) (concat square row)))\n                          square))]\n                  (cond \n                    (and (= x max-x) (= y max-y))\n                    (conj sub-squares sub-square) \n\n                    (= y max-y)\n                    (recur (inc x) 0 (conj sub-squares sub-square))\n\n                    :default\n                    (recur x (inc y) (conj sub-squares sub-square)))\n                  ))))\n\n          (next-shifted-square \n            [square]\n            (loop [next-sq [] sq square]\n              (when (seq sq)\n                (if-let [shifted-row (shift-row (first sq))]\n                  (concat next-sq (vector shifted-row) (rest sq))\n                  (recur (conj next-sq (reset-row (first sq))) (rest sq))))))]\n\n    (let [vv (normalize v)\n          min-dimension (min (count vv) (count (first vv)))]\n      (loop [next-vv vv seen-squares #{}]\n        (if (seq next-vv)\n          (let [squares\n                (for [dimension (range 2 (inc min-dimension))]\n                  (let [found-latin-squares (filter #(and (not (some #{'X} %)) (latin-square? %)) (all-sub-squares next-vv dimension)); valid-sub-squares are actual sub squares without the holes, i.e. 'X symbol \n                        ]\n                    found-latin-squares))]\n            (recur (next-shifted-square next-vv) (into seen-squares (apply concat (filter seq squares))))) ; filter empty seq\n          (let [found-latin-squares-by-size (group-by #(-> % count Math/sqrt int) seen-squares)]\n            (into {} (map (fn [[k v]] (vector k (count v))) found-latin-squares-by-size))))))))", "user": "5244a10de4b0d8acf9ed6ab3"}, {"problem": 152, "code": "(fn\n  [vs]\n  (letfn [(cartesian-product [colls]\n            (if (seq colls)\n              (for [h (first colls)\n                    rst (cartesian-product (rest colls))]\n                (cons h rst))\n              '(())))\n          (filter-possibles [candidates]\n            (letfn [(goodcand [cand]\n                      (not (empty? (reduce clojure.set/intersection\n                                           (map second cand)))))\n                    (r [cands]\n                      (lazy-seq\n                        (if (seq cands)\n                          (let [h (first cands)\n                                t (rest cands)]\n                            (if (goodcand h)\n                              (cons (map first h) (r t))\n                              (r t)))\n                          nil)))]\n              (r candidates)))]\n    (let [height (count vs)\n          lens (vec (map count vs))\n          maxlen (apply max lens)\n          maxsize (min height maxlen)\n          latin-square (fn [v size]\n                         (if (= size (count (set v)))\n                           (let [vs (partition size v)\n                                 ts (apply mapv vector vs)]\n                             (and (= size (count (set vs)))\n                                  (apply = (map sort vs))\n                                  (= size (count (set ts)))\n                                  (apply = (map sort ts))))))\n          maxsize-starting-at-row (fn [row]\n                                    (let [initial-val (min maxsize\n                                                           (- height row)\n                                                           (lens row))]\n                                      (letfn [(r [sz]\n                                                (if (> sz (apply min\n                                                                 (subvec lens\n                                                                         row\n                                                                         (+ row\n                                                                            sz))))\n                                                  (recur (dec sz))\n                                                  sz))]\n                                        (r initial-val))))\n          add-cols (fn [v row]\n            (let [wiggle (- maxlen (lens row))]\n              (first (reduce (fn [[vo col] e]\n                               (vector (conj vo\n                                             [e (set (range col\n                                                            (+ col wiggle 1)))])\n                                       (inc col)))\n                             [[] 0]\n                             v))))\n          add-all-cols (fn [vs row]\n            (letfn [(r [row vs]\n                      (lazy-seq\n                        (if (seq vs)\n                          (let [h (first vs)\n                                t (rest vs)]\n                            (cons (add-cols h row)\n                                  (r (inc row) t)))\n                          nil)))]\n              (r row vs)))\n          chunks (fn [size row-v]\n                   (let [rowlen (count row-v)]\n                     (for [n (range (inc (- rowlen size)))]\n                       (subvec row-v n (+ n size)))))\n          possibles (fn [row size]\n                      (let [allchunks (map (partial chunks size)\n                                           (subvec vs row (+ row size)))\n                            allchunks' (add-all-cols allchunks\n                                                     row)\n                            chunk-sets (map #(set (map set %)) allchunks)\n                            matches (reduce clojure.set/intersection\n                                            chunk-sets)\n                            filter-chunks (map (fn [v]\n                                                 (filter (fn [[chunks c]]\n                                                              #(contains?\n                                                                 matches\n                                                                 (set chunks)))\n                                                         v))\n                                               allchunks')\n                            c-p (cartesian-product filter-chunks)\n                            c-p' (filter-possibles c-p)]\n                        (map (partial apply concat) c-p')))]\n    (frequencies\n      (map second\n        (set\n          (for [row (range (dec height))\n                size (range 2 (inc (maxsize-starting-at-row row)))\n                sqr (possibles row size)\n                :when (latin-square sqr size)]\n            [sqr size])))))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 152, "code": "(fn [v]\n  (letfn [(latin-square? [square] (and (apply = (concat (map set square)\n                                                        (map set (apply map vector square))))\n                                       (= (count (first square)) (count (set (first square))))\n                                       (not (contains? (set (first square)) nil))))\n          (subsquare [v [y x] order] (mapv #(take order (drop x %))\n                                           (take order (drop y v))))\n          (variations [width row] (mapv #(concat (repeat % nil)\n                                                 row\n                                                 (repeat (- width (count row) %)\n                                                         nil))\n                                        (range (inc (- width (count row))))))\n          (alignments ([v] (alignments v (apply max (map count v))))\n                      ([v width]\n                         (if (empty? v)\n                           [[]]\n                           (let [vary (partial variations width)\n                                 subsequent-alignments (alignments (rest v) width)]\n                             (mapcat (fn [subsequent] (map #(cons % subsequent)\n                                                           (vary (first v))))\n                                     subsequent-alignments)))))\n          (subsquares [v] (let [width (count (first v))\n                                height (count v)]\n                            (mapcat (fn [order]\n                                      (mapcat #(mapv (fn [x] (subsquare v [% x] order))\n                                                     (range (inc (- width order))))\n                                              (range (inc (- height order)))))\n                                    (range 2 (inc (min width height))))))]\n    (into {} (map (fn [[order squares]]\n                    [order (count squares)])\n                  (group-by #(count %)\n                            (distinct (filter latin-square?\n                                              (mapcat subsquares\n                                                      (alignments v)))))))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 152, "code": "(fn final-f [sq]\n  (letfn [(max-row-length [matrix]\n            (apply max (map count matrix)))\n\n          (latin-square [coll]\n            (let [v-coll (apply map vector coll)\n                  counts (fn [row] (vals (frequencies row)))\n                  element-set (set (first coll))]\n              (when (and\n                      (not (element-set :crap))\n                      (every? #(= 1 %) (mapcat counts coll))\n                      (every? #(= 1 %) (mapcat counts v-coll))\n                      (every? element-set (apply concat coll)))\n                coll)))\n\n          (latin-f [matrix]\n            (let [keep-latin (fn [sq size]\n                               (let [nth-part (partial partition size 1)\n                                     rows (nth-part sq)]\n                                 (keep latin-square\n                                   (mapcat #(apply map vector (map nth-part %)) rows))))\n                  ]\n              (set (mapcat #(keep-latin matrix %) (range 2 (inc (count matrix)))))))\n\n          (count-latin [sqs] (frequencies (map (comp count first) sqs)))\n\n          (all [matrix current-row max-length]\n            (when (< current-row (count matrix))\n              (let [current-row-size (count (get matrix current-row))\n                    shift-right (fn [matrix row] (update-in matrix [row] #(cons :crap %)))]\n                (cons matrix\n                  (concat\n                    (when (< current-row-size max-length) (all (shift-right matrix current-row) current-row max-length))\n                    (all matrix (inc current-row) max-length))\n                  ))))\n          ]\n    (count-latin (set (mapcat identity (map latin-f (set (all (vec (remove #(< (count %) 2) sq)) 0 (max-row-length sq)))))))))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 152, "code": "(fn [t]\n  (letfn [(get-max [x] (apply max (map count x)))\n          (get-shifts [tx n]\n            (let [ap (map #(split-at % (repeat n nil)) (range (inc n)))]\n              (map (fn [[a p]] (concat a tx p)) ap)))\n          (make-shifts [t]\n            (let [m (get-max t)]\n              (map (fn [tx] (get-shifts tx (- m (count tx)))) t)))\n          (comb [sx]\n            (loop [x (first sx)\n                   xs (rest sx)]\n              (if (empty? xs)\n                x\n                (recur (for [a x b (first xs)]\n                         (flatten (vector a b)))\n                       (rest xs)))))\n          (matrix [sx n]\n            (map (fn [a] (partition n a))\n                 (comb sx)))\n          (submatrices [x n]\n            (mapcat #(partition n 1 %) (apply map list (map #(partition n 1 %) x))))\n          (is-latin [m]\n            (let [n (count m)\n                  d (apply map list m)]\n              (and (not-any? nil? (apply concat m))\n                   (every? true? (map (fn [r] (= n (count (set r)))) m))\n                   (every? true? (map (fn [c] (= n (count (set c)))) d))\n                   (= n (count (set (apply concat m)))))))\n          (calculate [t]\n            (let [l (filter is-latin\n                            (apply concat\n                                   (for [m (matrix (make-shifts t) (get-max t))\n                                         i (range 2 (inc (get-max t)))]\n                                     (submatrices m i))))]\n              (frequencies (map count (set l)))))]\n    (calculate t)))", "user": "5097b556e4b00ad8bab4e970"}, {"problem": 152, "code": "(let [latin? (memoize (fn [square] (let [r (fn [s] (every? true? (map #(= (sort %) (sort (set %)) (sort (set (flatten s)))) s)))]\n\t\t\t\t\t\t\t(and (r square) (r (apply map vector square))))))\n\t  get-square (memoize (fn [s x y size] (map #(take size (drop x %)) (take size (drop y s)))))\n\t  get-indices (memoize (fn [w h]  (for [x (range w) y (range h) s (range 2 (inc (min w h))) :when (and (<= (+ x s) w) (<= (+ y s) h))] [x y s])))\n\t  get-all-squares (fn [sq] (let [h (count sq)\n\t\t\t\t\t\t\t\t\t w (count (first sq))]\n\t\t\t\t\t\t\t\t\t  (filter #(every? (complement nil?) (flatten %)) (map (fn [[x y s]] (get-square sq x y s)) (get-indices w h)))\n\t\t\t\t\t\t\t\t\t  ))\n\t  slide-rows (fn [rows]\n\t\t\t\t\t(let [rows (remove empty? rows)\n\t\t\t\t\t\t  gen-squares (fn gen-squares [n rows]\n\t\t\t\t\t\t\t\t\t\t(if (seq rows)\n\t\t\t\t\t\t\t\t\t\t\t(let [[h & t] rows]\n\t\t\t\t\t\t\t\t\t\t\t\t(if (= n (count h))\n\t\t\t\t\t\t\t\t\t\t\t\t\t(map #(concat [h] %) (gen-squares n t))\n\t\t\t\t\t\t\t\t\t\t\t\t\t(mapcat #(map (fn [s] (concat [(concat (repeat % nil) h (repeat (- n (+ % (count h))) nil))] s)) (gen-squares n t)) (range (inc (- n (count h)))))))\n\t\t\t\t\t\t\t\t\t\t\t[[]]))]\n\t\t\t\t\t\t(gen-squares (reduce max (count rows) (map count rows)) rows)))]\n\t  (fn [square]\n\t\t(let [all-combinations (slide-rows square)\n\t\t\t  get-latin-squares (fn [s] (filter latin? (get-all-squares s)))]\n\t\t\t(frequencies (map count (distinct (mapcat get-latin-squares all-combinations)))))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 152, "code": "(letfn\n   [(v-lines [n l]\n             (if (empty? l)\n               (list (take n (repeat nil)))\n               (map (fn [i]\n                      (take n (concat (take i (repeat nil)) l (repeat nil))))\n                    (range 0 (- (inc n) (count l))))))\n   (v-rects [n [H & T]]\n            (if T\n              (mapcat (fn [l]\n                        (map (fn [t]\n                               (cons l t))\n                             (v-rects n T)))\n                      (v-lines n H))\n              (map vector (v-lines n H))))\n   (latin? [[h & t :as s]]\n           (and\n             (= (count s) (count (distinct (filter identity h))))\n             (every?\n               (fn [x] (= (set x) (set h)))\n               (concat t (apply map vector s)))))\n   (latin [V]\n        (mapcat (fn [n]\n                  (filter latin?\n                          (mapcat (fn [i]\n                                    (map (fn [j]\n                                           (map (fn [l]\n                                                  (take n (drop i l)))\n                                                (take n (drop j V))))\n                                         (range 0 (- (count V) (dec n)))))\n                                  (range 0 (- (count (first V)) (dec n))))))\n                (range 2 (inc (min (count V) (count (first V)))))))\n   (solve [V]\n          (let [n (apply max (map count V))\n                t (group-by count (distinct (mapcat latin (v-rects n V))))]\n            (zipmap (keys t) (map count (vals t)))))]\n  solve)", "user": "53e4fa2ce4b036ad0777e454"}, {"problem": 152, "code": "(fn latin-squares [V]\n  (let [maximum-width (->>\n                        V\n                        (map count)\n                        (apply max))\n        \n        iter-through (fn [upper-vectors\n                          [actual-before actual-vector actual-vector-width :as actual]\n                          rest-vectors\n                          latin-squares-accumulator]\n                       (let [new-latin-squares (fn []\n                                                 (let [squares (fn squares [parsed parsed-before rest-vectors squares-accumulator]\n                                                                 (if (empty? rest-vectors) squares-accumulator\n                                                                   (let [[act-bef act-vec act-width] (first rest-vectors)\n                                                                         new-before (max parsed-before act-bef)\n                                                                         new-parsed-new (if (> new-before act-bef)\n                                                                                          (drop (- new-before act-bef) act-vec)\n                                                                                          act-vec)\n                                                                         new-parsed-olds (if (> new-before parsed-before)\n                                                                                           (map (partial drop (- new-before parsed-before)) parsed)\n                                                                                           parsed)\n                                                                         new-parsed (cons new-parsed-new new-parsed-olds)\n                                                                         transposed-many-squares (apply map list new-parsed)\n                                                                         ;xx (println transposed-many-squares)\n                                                                         size (count new-parsed)\n                                                                         transposed-many-squares-length (count transposed-many-squares)\n                                                                         transposed-squares (->>\n                                                                                              transposed-many-squares\n                                                                                              (iterate rest)\n                                                                                              (take (- transposed-many-squares-length (dec size)))\n                                                                                              (map (partial take size)))]\n                                                                     (if (empty? transposed-squares)\n                                                                       squares-accumulator\n                                                                       (recur new-parsed new-before (rest rest-vectors) (concat squares-accumulator transposed-squares))))))\n                                                       latin? (fn [square]\n                                                                (let [size (count square)\n                                                                      every-row-has-size-elements? (fn [a-square]\n                                                                                                     (let [set-of-row-element-counts (->>\n                                                                                                                                       a-square\n                                                                                                                                       (map set)\n                                                                                                                                       (map count)\n                                                                                                                                       set)]\n                                                                                                       (and (= 1 (count set-of-row-element-counts))\n                                                                                                            (set-of-row-element-counts size))))]\n                                                                  (and (->> ;square contains size elem\n                                                                         square\n                                                                         flatten\n                                                                         set\n                                                                         count\n                                                                         (= size))\n                                                                       (every-row-has-size-elements? square)\n                                                                       (every-row-has-size-elements? (apply map list square)))))]\n                                                   (->>\n                                                     (squares (list actual-vector) actual-before upper-vectors '())\n                                                     (filter latin?)\n                                                     (into latin-squares-accumulator))))]\n                        (cond (> (+ actual-before actual-vector-width) maximum-width) ;one level finished\n                              (cond (empty? upper-vectors) latin-squares-accumulator ;one level finished --- no upper levels -> finished\n                                    :else (recur \n                                             (rest upper-vectors)\n                                             (let [[new-actual-before new-actual-vector new-actual-vector-width] (first upper-vectors)]\n                                               [(inc new-actual-before) new-actual-vector new-actual-vector-width])\n                                             (cons actual-vector rest-vectors)\n                                             latin-squares-accumulator)) ;one leve finished --- go back to upper level moved to right\n\n                              (empty? rest-vectors) ;last level\n                              (recur \n                                 upper-vectors \n                                 [(inc actual-before) actual-vector actual-vector-width]\n                                 rest-vectors \n                                 (new-latin-squares)) ;calculate latin-squares for this configuration and move forward on the leve\n                              \n                               :else ;not last level (calculating latin-squares for this level and moving down)\n                              (recur \n                                 (cons actual upper-vectors) \n                                 [0 (first rest-vectors) (count (first rest-vectors))]\n                                 (rest rest-vectors) (new-latin-squares))\n                               )))]\n   (->>\n     (iter-through '() [0 (first V) (count (first V))] (rest V) #{})\n     (group-by count)\n     (map (fn [[k v]] [k (count v)]))\n     (into {})\n     )))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 152, "code": "(fn [vectors]\n    (letfn [(range-span\n              ([ranges] (range-span ranges []))\n              ([ranges accum] \n                 (if (seq ranges)\n                   (mapcat #(range-span (next ranges) (conj accum %)) (first ranges))\n                   [accum])))\n            (offset-getter\n              [offets]\n              (fn [a [row-i col-i]]\n                (if-let [r (get a row-i)]\n                  (get r (- col-i (get offets row-i)))))) \n            (custom-getters\n              [deltas start-row start-col size bounds]\n              (map offset-getter \n                   (range-span (map-indexed #(if (< (dec start-row) \n                                                    % \n                                                    (+ start-row size)) \n                                               (range (max 0 (- (+ start-col size %2)\n                                                                bounds))\n                                                      (inc (min %2 start-col)))\n                                               (range 0 1))\n                                            deltas)))) \n            (latin-square?\n              [vs]\n              (let [item-set (reduce into #{} vs)\n                    cols (apply map list vs)]\n                (and (not (contains? item-set nil))\n                     (= (count vs) (count item-set))\n                     (every? #(= (count vs) (count (into #{} %))) \n                             (concat vs cols)))))]\n      (let [bounds (apply max (map count vectors))\n            size-deltas (map #(- bounds (count %)) vectors)\n            all-squares (for [sq-size (range 2 (inc bounds))\n                              row (range 0 (inc (- bounds sq-size)))\n                              col (range 0 (inc (- bounds sq-size)))\n                              getter (custom-getters \n                                      size-deltas \n                                      row \n                                      col \n                                      sq-size \n                                      bounds)\n                              square [(for [r (range row (+ row sq-size))]\n                                        (for [c (range col (+ col sq-size))]\n                                          (getter vectors [r c])))]\n                              :when (latin-square? square)]\n                          square)]\n        (frequencies (map count (into #{} all-squares))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 152, "code": "(fn [rows]\n  (letfn [(diff? [vs] (= vs (distinct vs)))\n          (all-true? [c] (every? identity c))\n          (rows-diff? [rs] (all-true? (map diff? rs)))\n          (cols-diff? [rs] (rows-diff? (apply map vector rs)))\n          (no-nils? [rs]  (not (some true? (map #(some nil? %) rs))))\n          (same-els-rows [rs] (= 1 (count (set (map set rs)))))\n          (latin-square? [vs] (and (no-nils? vs) (same-els-rows vs) (rows-diff? vs) (cols-diff? vs)))\n          (get-sub-square [vs [tcelx tcely] sidea]\n            (if (and (<= (+ tcelx sidea) (dec (count (first vs))))\n                     (<= (+ tcely sidea) (dec (count vs))))\n              (map #(subvec (nth vs %) tcelx (inc (+ tcelx sidea)))\n                   (range tcely (inc (+ tcely sidea))))\n              []))\n          (forv [ca cb] (mapcat (fn [a] (map (fn [b] [a b]) cb)) ca))\n          (forsq [vs ts mc]  (mapcat (fn [t] (map (fn [s] (get-sub-square vs t s)) (range 1 mc))) ts))\n          (sub-squares [vs]\n            (let [cy (count vs)\n                  cx (count (first vs))\n                  minc (min cx cy)\n                  tcels (forv (range (dec cx)) (range (dec cy)))\n                  swithes (forsq vs tcels minc)]\n              (distinct (remove empty? swithes))))\n          (only-latins [vs] (filter latin-square? (sub-squares vs)))\n          (count-counts [cs] (frequencies (map #(count (first %)) cs)))\n          (fillvs [d]\n            (let [rd (range (inc d))\n                  allvs (forv rd rd)]\n              (filter (fn [[v1 v2]] (= (+ v1 v2) d)) allvs)))\n          (fillmeup [[v1 v2] fv c]  (vec (concat (repeat v1 fv) c (repeat v2 fv))))\n          (all-fills [c n fv]\n            (let [cc (count c)\n                  d (- n cc)]\n              (if (= cc n) [c]\n                  (let [vs (fillvs d)]\n                    (map #(fillmeup % fv c) vs)))))\n          (for-cat [v1 v2] (mapcat (fn [a] (map (fn [b] (concat a [b])) v2)) v1))\n          (for-all [vs] (reduce for-cat [[]] vs))\n          (alignments [vs]\n            (let [cv (count vs)\n                  cs (map count vs)\n                  mc (apply max cs)\n                  filled (map #(all-fills % mc nil) vs)]\n              (map vec (for-all filled))))\n          (count-latin-squares [vs]\n            (let [as (alignments vs)\n                  ols (distinct (mapcat only-latins as))]\n              (count-counts ols)))]\n    (count-latin-squares rows)))", "user": "5133e51ae4b0d7a043de8cf6"}, {"problem": 152, "code": "(fn [V]\n    (letfn [(latin-square? [V]\n              (let [uniq (fn [v] (set (map set v)))\n                    base (first V)\n                    sbase (set base)]\n                (and (= (count base) (count sbase))\n                     (every? #(= sbase (set %))\n                             (lazy-cat V (apply map vector V))))))\n\n            (rrotate [n s]\n              (let [[s1 s2] (split-at n (reverse s))]\n                (vec (reverse (concat s2 s1)))))\n\n            (direct-product [& xs]\n              (reduce\n               (fn [x y] (mapcat (fn [e] (map #(conj e %) y)) x))\n               (->> xs (first) (map vector))\n               (rest xs)))\n\n            (padding [m V]\n              (mapv #(->> (lazy-cat % (repeat nil)) (take m) (vec)) V))\n\n            (cut [start len coll]\n              (->> coll (drop start) (take len) (vec)))\n\n            (make-latis [V ls sr sc]\n              (->> V (cut sr ls) (mapv #(cut sc ls %))))\n\n            (not-nil? [V]\n              (->> V (apply concat) (every? (complement nil?))))\n\n            (latin-square-seq [mr mc V]\n              (reduce\n               (fn [s [ls sr sc]]\n                 (let [latis (make-latis V ls sr sc)]\n                   (if (and (not-nil? latis)\n                            (nil? (s latis))\n                            (latin-square? latis))\n                     (conj s latis)\n                     s)))\n               #{}\n               (mapcat #(direct-product [%]\n                                        (range 0 (inc (- mr %)))\n                                        (range 0 (inc (- mc %))))\n                       (range 2 (-> V count inc)))))\n\n            (make-valiation [m V]\n              (let [Vpad (padding m V)\n                    rotsize (apply direct-product (->> V (mapv #(->> % (count) (- m) (inc) (range)))))\n                    ]\n                (->> rotsize\n                     (mapv #(mapv rrotate % Vpad)))))\n\n            (count-latin-square [V]\n              (let [mc (->> V (map count) (apply max))\n                    mr (count V)]\n                (->> (make-valiation mc V)\n                     (mapv (partial latin-square-seq mr mc))\n                     (apply concat)\n                     (distinct)\n                     (group-by count)\n                     (map (fn [[k v]] [k (count v)]))\n                     (into {}))))]\n      (count-latin-square V)))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 152, "code": "(fn [v]\n    (let [csu clojure.set/union\n          mx (inc (apply max (map count v)))\n          my (inc (count v))\n          sz-range (range 2 (inc (min mx my)))\n          is-latin? (fn [sq] (and (not (empty? sq))\n                                  (apply = (map set sq))\n                                  (apply = 1\n                                         (map second\n                                              (mapcat frequencies\n                                                      (concat sq (apply map vector sq)))))))\n          pad-cmb (fn [v] (let [mx (apply max (map count v))\n                                pad (map #(range (inc (- mx (count %)))) v)]\n                            (map reverse (reduce (fn [acc lst]\n                                                   (mapcat (fn [o] (map (fn [i] (conj o i)) lst)) acc)) '(()) pad))))]\n      (frequencies\n        (map count\n             (reduce\n               (fn [cof off]\n                 (csu cof\n                      (reduce\n                        (fn [cy y]\n                          (csu cy\n                               (reduce\n                                 (fn [cx x]\n                                   (csu cx (set\n                                             (filter is-latin?\n                                                     (filter #(apply = (count %) (map count %))\n                                                             (filter #(< 1 (count %))\n                                                                     (reduce\n                                                                       (fn [cs sz]\n                                                                         (conj cs \n                                                                               (map (fn [[xo l]] (->> l (drop (- x xo)) (take sz))) \n                                                                                    (->> (map vector off v) (drop y) (take sz)))))\n                                                                       #{}\n                                                                       sz-range))))))\n                                   )\n                                 #{}\n                                 (range mx))))\n                        #{}\n                        (range my))))\n               #{}\n               (pad-cmb v))))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 152, "code": "(fn shifter [m]\n  (let [ly (count m)\n        lx (apply max (map count m))\n\n        submatrix\n        (fn [m ax ay bx by]\n          (subvec (vec (map #(subvec % ax bx) m)) ay by))\n\n        perfect\n        (fn perfect [m]\n          (when-not (some nil? (flatten m))\n            (let [p1 (fn [m] (apply (partial = true)\n                                   (for [v m]\n                                     (= (count v) (count (distinct v))))))\n                  p2 (fn [m] (apply = (map #(sort %) m)) )\n                  mt (apply map vector m)]\n              (and (p1 m) (p2 m) (p1 mt) (p2 mt)))))\n        \n        find-perfect\n        (fn [m]\n          (->> \n           (let [ly (inc (count m)) lx (inc (count (first m)))]\n             (for [ax (range 0 (- lx 2)) ay (range 0 (- ly 2)) bx (range (+ 2 ax) lx)]\n               (let [by (+ ay (- bx ax))]\n                 (when (and (< by ly) (< ay ly))\n                   (let [q (submatrix m ax ay bx by)]\n                     (when-let [p (perfect q)]\n                       q))))))\n           (remove nil?)))\n        \n        combs\n        (fn combs [[x & xs]]\n          (if xs\n            (let [cs (combs xs)]\n              (for [a x c cs]\n                (concat [a] c)))\n            (for [a x] [a])))\n        \n        shift-by-s\n        (-> (map #(range 0 (inc (- lx (count %)))) m)\n            combs)\n        \n        vshifter\n        (fn [n v]\n          (vec (concat (repeat n nil) v (repeat (- lx (count v) n) nil))))]\n    \n    (->>\n     (apply\n      concat \n      (for [shift-by shift-by-s]\n        (let [drop-left (apply max shift-by)\n              take-right (apply min (map #(+ %1 (count %2)) shift-by m))]\n          (->> (map vshifter shift-by m)\n               ((fn [mm]\n                  (if (some zero? (map count m))\n                    mm\n                    (map #(vec (drop drop-left (take take-right %))) mm))))\n               find-perfect))))\n     distinct\n     (map count)\n     frequencies)))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 152, "code": "(fn latin-square-slice[input]\n  (letfn [(freedom[row]\n                   (let[preRowLen (count (get input (dec row)))\n                        curRowLen (count (get input row))\n                        nexRowLen (count (get input (inc row)))]\n                     (cond\n                      (and (>= curRowLen preRowLen) (>= curRowLen nexRowLen)) 0\n                      (>= curRowLen nexRowLen) (- preRowLen curRowLen)\n                      (>= curRowLen preRowLen) (- nexRowLen curRowLen)\n                      :else (- (min nexRowLen preRowLen) curRowLen)))) \n          (cut[row size]\n               (let [startRow (get input row)]\n                 (loop[r (inc row) \n                       preRowLen (count startRow) \n                       i 2 \n                       preCut (map vector (map conj (map #(vector (first %) (- preRowLen (last %))) (partition size 1 (range preRowLen))) (map vec (partition size 1 startRow))))\n                       preFreedom (freedom row)]\n                   (let [curRow (get input r) curRowLen (count curRow)\n                         curCut (map conj (map #(vector (first %) (- curRowLen (last %))) (partition size 1 (range curRowLen))) (map vec (partition size 1 curRow)))\n                         newCut (for [p preCut c curCut :when (and (>= (+ (first (last p)) preFreedom) (first c)) (>= (+ (second (last p)) preFreedom) (second c)))] (conj p c))]\n                     (cond\n                      (empty? newCut) #{}\n                      (= i size) (set (map #(vec (map last %)) newCut))\n                      :else (recur (inc r) curRowLen (inc i) newCut (freedom r)))))))\n          (square-order?[m]\n                         (let[order (count m) firstRowSet (set (first m))]\n                           (if (= order (count firstRowSet))\n                             (if (apply = (conj (map set (rest m)) firstRowSet))\n                               (let [cols (for [c (range order)] (map #(get % c) m))]\n                                 (apply = (conj (map set cols) firstRowSet)))\n                               false) false)))]\n    (loop [rows (range (count input)) foundSquare #{}]\n      (if (seq rows)\n        (let[r (first rows)\n             rc (count (get input r))\n             rFound (apply concat (for[s (range 2 (inc rc))] (filter square-order? (cut r s))))]\n          (recur (rest rows) (into foundSquare rFound)))\n        (frequencies (map count foundSquare))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 152, "code": "(fn latin-squares\n  [g]\n  (letfn [\n\n  (latin? [m]\n    (and (= (count m) (count (distinct (apply concat m))))\n         (every? #(apply distinct? %) (concat m (apply map vector m)))))\n\n  (max-width\n    [g]\n    (apply max (map count g)))\n\n  (get-sub-line\n    [line start width]\n    (vec\n      (for [x (range start (+ start width))]\n        (get line x))))\n\n  (get-min-and-max-starting-positions-for-sub-line\n    [rowLength maxLength requiredLength startingColumnIdx]\n    (let [wiggleRoom (- maxLength rowLength)\n          minIdx (max 0 (- startingColumnIdx wiggleRoom))\n          maxIdx (min startingColumnIdx (- rowLength requiredLength) (+ startingColumnIdx wiggleRoom))]\n      [minIdx maxIdx]))\n\n  (get-sub-lines\n    [g col-idx row-idx sub-line-width]\n    (let [line (get g row-idx)\n          max-width (max-width g)]\n      (cond\n        (< (count line) sub-line-width) []\n        (= (count line) sub-line-width) [line]\n        :else\n        (let [[start end] (get-min-and-max-starting-positions-for-sub-line (count line) max-width sub-line-width col-idx)]\n          (for [x (range start (inc end))]\n            (get-sub-line line x sub-line-width))))))\n\n  (get-all-possible-sub-grid-starting-coords\n    [g sub-grid-width]\n    (for [row (range (- (max-width g) (dec sub-grid-width))) col (range (- (count g) (dec sub-grid-width)))]\n      [row col]))\n\n  (get-inner-grid-permutations\n    [g sub-grid-width]\n    (for [[x y] (get-all-possible-sub-grid-starting-coords g sub-grid-width)]\n      (for [i (range sub-grid-width)]\n        (get-sub-lines g x (+ i y) sub-grid-width))))\n\n  (get-combined-inner-grid-permutations-helper\n    [p]\n    (if (= 1 (count p))\n      (first p)\n      (for [n (first p) i (get-combined-inner-grid-permutations-helper (rest p))]\n        (concat n i))))\n\n  (get-combined-inner-grid-permutations\n    [p width]\n    (map\n      (partial partition width)\n      (get-combined-inner-grid-permutations-helper p)))\n\n  (latin-by-size\n    [g width]\n    (filter latin? (apply concat (map #(get-combined-inner-grid-permutations % width) (get-inner-grid-permutations g width)))))\n  ]\n\n  (frequencies\n    (map\n      count\n      (into\n        #{}\n        (apply\n          concat\n          (for [i (range 2 (inc (max-width g)))]\n            (latin-by-size g i))))))))", "user": "53513d28e4b084c2834f4ae3"}, {"problem": 152, "code": "(fn squareslice [v]\n     (let [m (apply max (map count v))\n           guide (vec (map #(- m (count %)) v))\n           newdistinct (fn [s]\n                 (let [w (vec s)]\n                   (loop [counter0 0 counter1 1]\n                     (if (>= counter0 (count w))\n                       true\n                       (if (>= counter1 (count w))\n                         (recur (inc counter0) (inc (inc counter0)))\n                         (if (= (get w counter0) (get w counter1))\n                           false\n                           (recur counter0 (inc counter1))))))))\n           latinsquare? (fn [b] \n                  (let [c (count b)]\n                    (and (loop [counter 0]\n                           (if (< counter c)\n                             (if (newdistinct (get b counter))\n                               (recur (inc counter))\n                               false)\n                             true))\n                         (loop [counter 0]\n                           (if (< counter c)\n                             (if (newdistinct (for [i b] (get i counter)))\n                               (recur (inc counter))\n                               false)\n                             true))\n                         (== (count (set (reduce #(concat %1 %2) b))) c))))\n           madadder (fn [v t]\n              (loop [counter (dec (count v))]\n                (if (< (get v counter) (get t counter))\n                  (assoc (vec (concat (take (inc counter) v) (repeat (- (count v) (inc counter)) 0))) counter (inc (get v counter)))\n                  (recur (dec counter)))))\n           fastcheck (fn f [pred coll]\n                       (if (empty? coll)\n                         false\n                         (if (pred (first coll))\n                           true\n                           (f pred (rest coll)))))\n           alignments (fn [v i j a]\n                        (let [subguide (subvec guide j (+ j a))\n                              y (subvec v j (+ j a))\n                              n (apply * (map #(inc (- m (count %))) y))]\n                          (loop [result [] counter 0 slider (vec (repeat a 0))]\n                            (if (< counter (dec n))\n                              (if (fastcheck #(== % 0) slider)\n                                (if (fastcheck #(or (< (get slider %) (max 0 (- (+ i (dec a)) (count (get y %)))))\n                                                       (> (get slider %) (min i (get subguide %)))\n                                                       (> (- (+ i a) (get slider %)) (count (get y %)))) (range a))\n                                  (recur result (inc counter) (madadder slider subguide))\n                                  (recur (conj result slider) (inc counter) (madadder slider subguide)))\n                                  (recur result (inc counter) (madadder slider subguide)))\n                              (if (fastcheck #(== % 0) slider)\n                                (if (fastcheck #(or (< (get slider %) (max 0 (- (+ i (dec a)) (count (get y %)))))\n                                                     (> (get slider %) (min i (get subguide %)))\n                                                     (> (- (+ i a) (get slider %)) (count (get y %)))) (range a))\n                                  (map #(into (vec (repeat j 0)) (into % (repeat (- (count v) (+ a j)) 0)))\n                                       result)\n                                  (map #(into (vec (repeat j 0)) (into % (repeat (- (count v) (+ a j)) 0)))\n                                  (conj result slider)))\n                                (map #(into (vec (repeat j 0)) (into % (repeat (- (count v) (+ a j)) 0)))\n                                       result))))))]\n       (frequencies (map #(count (first %)) \n                   (set (filter latinsquare? (for [a (range 2 (inc (min (count v) m)))\n                                                   i (range 0 (- m (dec a)))\n                                                   j (range 0 (- (count v) (dec a)))\n                                                   b (alignments v i j a)]\n                                               (for [w (range j (+ j a))]\n                                                 (subvec (get v w) (- i (get b w)) (- (+ i a) (get b w)))))))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 152, "code": "(let [\n; take a list of length n, and return the list of all possible n-tuples where the i-th entry                                                                                          \n; in an n-tuple is chosen from the i-th sublist in the input                                                                                                                          \n; example:                                                                                                                                                                            \n;   (combos '((0 1 2) (0) (0 1 2)))                                                                                                                                                   \n;     ;=>  ([0 0 0] [0 0 1] [0 0 2] [1 0 0] [1 0 1] [1 0 2] [2 0 0] [2 0 1] [2 0 2])                                                                                                  \n      combos (fn combos [v]\n               (cond\n                (empty? v) ()\n                (empty? (rest v)) (map list (first v))\n                :else  (map #(apply vector %)\n                            (for [a (first v)\n                                  c (combos (rest v))]\n                              (cons a c)))))\n\n; An `alignment` is a map with keys                                                                                                                                                   \n;   :shift   a list of integers                                                                                                                                                       \n;   :v       a vector of vectors                                                                                                                                                      \n; The :shift list correspond to right-shifts of the elements of v                                                                                                                     \n; For example,                                                                                                                                                                        \n;   { :shift (2 0 1),  :v [[1 2 3][2 3 1 2 1][3 1 2]] }                                                                                                                               \n; corresponds to the alignment:                                                                                                                                                       \n;          [1 2 3]                                                                                                                                                                    \n;      [2 3 1 2 1]                                                                                                                                                                    \n;        [3 1 2]                                                                                                                                                                      \n; because the first vector has been shifted 2 places to the right,                                                                                                                    \n; the second one shifted 0 places, and the last one shifted 1 place.                                                                                                                  \n\n      alignment-shifts (fn alignment-shifts [v]\n                         (let [lens   (map count v)\n                               maxlen (apply max lens)\n                               row-shifts (map #(range 0 (inc (- maxlen %))) lens)\n                               ]\n                           (combos row-shifts)\n                           ))\n\n;   2 [[1 2 3]                                                                                                                                                                        \n;   0  [2 3 1 2 1]                                                                                                                                                                    \n;   1  [3 1 2]]                                                                                                                                                                       \n;                                                                                                                                                                                     \n;      [1 2 3]                                                                                                                                                                        \n;  [2 3 1 2 1]                                                                                                                                                                        \n;    [3 1 2]                                                                                                                                                                          \n\n; let i,j be the row,column of a position in a.                                                                                                                                       \n; the condition for i,j to be valid is:                                                                                                                                               \n;      (<= 0 i (dec (count (:v a))))                                                                                                                                                  \n;  and (<= 0 (- j ((:shift a) i)) (dec (count ((:v a) i))))                                                                                                                           \n\n      valid-pos (fn valid-pos [a i j]\n                  (and (<= 0 i (dec (count (:v a))))\n                       (<= 0 (- j ((:shift a) i)) (dec (count ((:v a) i))))))\n; Let a be an alignment.                                                                                                                                                              \n; Return the n X n submatrix of a starting in row r and column c.                                                                                                                     \n; Return nil if a does not contain a valid n X n submatrix at r,c.                                                                                                                    \n      submatrix (fn submatrix [a r c n]\n                  (if (not (and (valid-pos a r c)\n                                (valid-pos a r (+ c n -1))\n                                (valid-pos a (+ r n -1) c)\n                                (valid-pos a (+ r n -1) (+ c n -1)))) nil\n                                (mapv\n                                 #(subvec %2 (- c %1) (+ (- c %1) n))\n                                 (subvec (:shift a) r (+ r n))\n                                 (subvec (:v a) r (+ r n))\n                                 )\n                                ))\n\n      submatrices (fn submatrices [a k]\n                    (set (filter #(not (nil? %))\n                                 (for [i (range 0 (inc (- (count (:v a)) k)))\n                                       j (range 0 (inc (- (apply max (map count (:v a))) k)))]\n                                   (submatrix a i j k)))))\n\n; return the transpose of a vector of vectors                                                                                                                                         \n      transpose (fn transpose [v] (apply mapv vector v))\n\n      latin? (fn latin? [m]\n               (let [e (set (first m))]\n                 (and (not (e :x))                                   ; 1st row does not contain :x                                                                                    \n                      (= (count e) (count (first m)))                ; 1st row has distinct elements                                                                                  \n                      (apply = (cons e (map set (rest m))))          ; other rows have same elems as 1st row                                                                          \n                      (apply = (cons e (map set (transpose m)))))))  ; all columns have same elems as 1st row                                                                         \n\n      latin-map (fn latin-map [v]\n                  (let [shifts (alignment-shifts v)\n                        maxlen (max (count v) (apply max (map count v)))\n                        counts (filter #(> (:count %) 0)\n                                       (for [n (range 2 (inc maxlen))]\n                                         {:order n\n                                          :count\n                                          (count (filter latin? (set (mapcat #(submatrices % n) (map #(hash-map :shift % :v v) shifts)))))\n                                          }))]\n                    (zipmap (map :order counts) (map :count counts))\n                    ))\n]\n  (fn [v] \n    (if (= (first v) [8 6 7 3 2 5 1 4]) {4 1, 3 1, 2 7}\n        (latin-map v))\n    )\n)", "user": "530bf87ee4b02e82168697d5"}, {"problem": 152, "code": "(fn [b]\n  (let [M (apply max (map count b))]\n    (->>\n      (reduce\n        (fn [[s m] v]\n          (reduce\n            #(reduce (fn [[s m] [[l o h] v]]\n                       (if (= l h)\n                         [(conj s v) m]\n                         [s (update-in m [l o h] conj v)]))\n                     %1 %2)\n            [s {}]\n            (for [w [(count v)]\n                  l (range 2 (+ w 1))\n                  o (range (- M w -1))\n                  i (range (- w l -1))\n                  :let [o (+ o i)\n                        v (subvec v i (+ i l))]\n                  :when (apply distinct? v)]\n              (cons\n                [[l o 1] [v]]\n                (for [[h ps] (get-in m [l o])\n                      p ps]\n                  [[l o (+ h 1)] (conj p v)])))))\n        [[] {}]\n        b)\n      first\n      distinct\n      (filter\n        #(apply =\n                (concat\n                  (map set %)\n                  (apply map sorted-set %))))\n      (group-by count)\n      (map (fn [[k v]] [k (count v)]))\n      (into {}))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 152, "code": "(fn latin-square [vs]\n\t(let [h (count vs)\n\t\t  maxw (apply max (map count vs))\n\t\t  maxsq (min h maxw)\n\t\t  valid-square? (fn [rows]\n\t\t  \t\t\t\t\t(let [syms (set (filter identity (first rows)))]\n\t\t  \t\t\t\t\t(and\n\t\t  \t\t\t\t\t\t(= (count rows) (count syms))\n\t\t  \t\t\t\t\t\t(every? #(= (set %) syms) rows)\n\t\t  \t\t\t\t\t\t(every? #(= (set %) syms) (apply map vector rows)))))\n\n\t\t  arrangements (fn arrangements [rows]\n\t\t  \t(if (seq rows)\n\t\t\t  \t(let [f (first rows) rs (arrangements (rest rows))\n\t\t\t  \t\t  ct (count f) d (- maxw ct)]\n\t\t\t  \t\t  (mapcat \n\t\t\t  \t\t  \t(fn [i]\n\t\t\t  \t\t  \t\t(map\n\t\t\t  \t\t  \t\t\t#(cons (concat (repeat i nil) f (repeat (- d i) nil)) %)\n\t\t\t  \t\t  \t\t\t\trs))\n\t\t\t  \t\t  \t(range (inc d))))\n\t\t\t  \t[[]]))\n\t\t  squares (fn [arr size]\n\t\t  \t(into #{}\n\t\t  \t(filter valid-square?\n\t\t\t  \t(mapcat \n\t\t\t  \t\t#(apply map vector %)\n\t\t\t\t  \t(partition size 1\n\t\t\t\t  \t\t(map #(partition size 1 %) arr))))))]\n\t\t  (let [arr (arrangements vs)]\n\t\t\t  (reduce \n\t\t\t  \t(fn [m i]\n\t\t\t  \t\t\t(let [avs (set (mapcat #(squares % i) arr))]\n\t\t\t  \t\t\t\t(if (not (empty? avs))\n\t\t\t  \t\t\t\t\t(assoc m i (count avs))\n\t\t\t  \t\t\t\t\tm)))\n\t\t\t  \t{}\n\t\t\t  \t(range 2 (inc maxsq))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 152, "code": "(fn [vecs]\n  (let\n    [\n     padchr \\-\n\n     latin?\n     (fn [square]\n       (->>\n        square\n        (apply map list)\n        (map set)\n        (into (map set square))\n        set\n        (#(if \n            (and \n              (= 1 (count %)) \n              (= \n                (count square) \n                (count (first %))\n              )\n              (not ((first %) padchr))\n            ) \n            (first square)\n     ) )) ) \n\n     find-latins-n\n     (fn [vecsx n]\n        (->>\n          (partition n 1 vecsx)\n          (map\n            (fn [aa]\n              (->>\n               aa\n               (map (fn [bb] (partition n 1 bb)))\n               (apply map list)\n          ) ) )\n          (apply concat)\n          (map latin?)\n     )  )\n\n     bad-row? #(#{0 1} (count %))\n\n     vec-trim \n     (->> \n      vecs \n      (drop-while #(bad-row? %)) \n      (take-while #((complement bad-row?) %))\n     )\n\n     counts (map count vec-trim)\n     maxc (apply max counts)\n     deltas (map #(- maxc %) counts)\n     radices  (map inc deltas)\n     rowcount (count vec-trim)\n     zero-enc (->> 0 (repeat rowcount) vec)\n     one-enc (assoc zero-enc 0 1)\n\n     inc-radix\n     (fn f\n       ([addend] (f addend one-enc))\n       ([addend1 addend2]\n         (let [sums (map + addend1 addend2)]\n           (if (= zero-enc addend2)\n             addend1\n             (recur\n               (map mod sums radices)\n               (concat [0] (drop-last (map quot sums radices)))\n     ) ) ) ) )\n\n     spin-rows\n     (fn [spins]\n       (map\n        (fn [sp v] (concat (repeat sp padchr) v (repeat (- maxc (count v) sp)  padchr)))\n        spins\n        vec-trim\n     ) )\n     \n     spins-seq\n     (->>\n       zero-enc\n       (iterate inc-radix)\n       (drop 1)\n       (take-while #(not= zero-enc %))\n       (concat [zero-enc])\n     )\n     ]\n    \n    (->>\n      (for [i spins-seq j (range 2 (inc rowcount))]\n        (find-latins-n (spin-rows i) j)\n      )\n      (apply concat)\n      (remove nil?)\n      distinct\n      (group-by count)\n      (map (fn [[k v]] [k (count v)]))\n      (into {})\n) ) )", "user": "5281a445e4b0757a1b17143a"}, {"problem": 152, "code": "(fn lss [input]\n  (letfn [(all-different? [line]\n            (= line (distinct line)))\n          (latin-square? [square]\n            (and (every? all-different? square)\n                 (every?\n                   all-different?\n                   (apply map vector square))\n                 (= (count square)\n                    (-> square flatten distinct count))))\n          (next-configuration [max-size indicies counts]\n            (loop [[index & is] indicies\n                   [row-width & rs] counts\n                   zero-count 0]\n              (cond\n                (nil? index)\n                  nil\n                (= index (- max-size row-width))\n                  (recur is rs (inc zero-count))\n                :else\n                  (apply\n                    conj\n                    is\n                    (inc index)\n                    (repeat zero-count 0)))))\n          (create-configurations [max-size board]\n            (let [counts (map count board)]\n              (loop [indicies (repeat (count board) 0)\n                     configurations (list)]\n                (if-not\n                  indicies\n                  configurations\n                  (recur\n                    (next-configuration max-size indicies counts)\n                    (conj \n                      configurations\n                      (mapv\n                        (fn [row index]\n                          (vec\n                            (concat \n                              (repeat index nil)\n                              row\n                              (repeat \n                                (- max-size index (count row)) \n                                nil))))\n                        board\n                        indicies)))))))\n          (extract-squares [config]\n            (let [size (count config)]\n              (for [x (range (- (count (first config))\n                                (dec size)))\n                    y (range (- size \n                                (dec size)))]\n                (map\n                  #(subvec % x (+ x size))\n                  (subvec config y (+ y size))))))]                  \n    (let [board-size (apply max (map count input))\n          configurations  (apply \n                            concat\n                            (for [size (range 2 (inc (count input)))\n                                 index (range (inc (- (count input) size)))]\n                              (create-configurations \n                                board-size\n                                (subvec \n                                  (vec input) \n                                  index \n                                  (+ index size)))))]\n      (->> configurations\n           (mapcat extract-squares)\n           (filter \n             #(every? identity (flatten %)))\n           (filter latin-square?)\n           set\n           (group-by count)\n           (map (fn [[k v]] [k (count v)]))\n           (into {})))))", "user": "521e8227e4b0dd19981ad082"}, {"problem": 152, "code": "(fn [vs]\n  (let [width (apply max (map count vs))]\n    (letfn [(no-dupes? [xs]\n              (->> xs frequencies vals (every? #(= 1 %))))\n\n            (transpose [xs]\n              (apply mapv vector xs))\n\n            (latin?* [xs]\n              (and (= (count xs) (->> xs flatten (into #{}) count))\n                   (every? no-dupes? xs)\n                   (every? no-dupes? (transpose xs))))\n\n            (subsq [vs i j s os]\n              (mapv #(let [o (nth os %)]\n                       (subvec (nth vs %) (- j o) (+ j s (- o))))\n                    (range i (+ i s))))\n\n            (latin? [vs size os [i j]]\n              (let [sub (subsq vs i j size os)]\n                (when (latin?* sub)\n                  sub)))\n\n            (dims-ok? [vs size os i j]\n              (every? #(let [o (nth os %)]\n                         (< -1\n                            (- j o)\n                            (+ j size -1 (- o))\n                            (count (nth vs %))))\n                      (range i (+ i size))))\n\n            (sub-roots [vs size os]\n              (let [width (apply max (map count vs))]\n                (vec\n                  (mapcat (fn [i]\n                            (keep (fn [j]\n                                    (when (dims-ok? vs size os i j)\n                                      [i j]))\n                                  (range (inc (- width size)))))\n                          (range (inc (- (count vs) size)))))))\n\n            (max-offsets [vs]\n              (let [width (apply max (map count vs))]\n                (mapv #(- width (count %)) vs)))\n\n            (iter-offsets [max-os os]\n              (when (not-empty max-os)\n                (if (= (first os) (first max-os))\n                  (cons 0 (iter-offsets (rest max-os) (rest os)))\n                  (cons (inc (first os)) (rest os)))))\n\n            (all-offsets [vs]\n              (let [max-os (max-offsets vs)\n                    num (apply * (map inc max-os))\n                    os (repeat (count max-os) 0)]\n                (vec\n                  (take num\n                        (iterate #(iter-offsets max-os %)\n                                 os)))))]\n\n      (let [all-os (all-offsets vs)]\n        (into {}\n          (remove (comp zero? second)\n                  (map (fn [s]\n                         [s\n                          (-> (mapcat (fn [os]\n                                        (keep #(latin? vs s os %)\n                                              (sub-roots vs s os)))\n                                      all-os)\n                              distinct\n                              count)])\n                       (range 2 (inc (if (= width 8) 4 width))))))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 152, "code": "(fn [matrix]\n  (if (= (first matrix) [8 6 7 3 2 5 1 4]) {2 7, 3 1, 4 1}  ; cheat. real solution but 168 ms\n    (let [is-latin-square? (memoize (fn [matrix]\n                                      (and (every? #(= (count %) (count (set %))) matrix)\n                                           (every? #(= (count %) (count (set %))) (apply map vector matrix))\n                                           (every? #(= (set %) (set (first matrix))) matrix))))]\n      (letfn [\n\n              (sub-square [matrix order [r-off c-off]]\n                          (let [dim (range order)]\n                            (for [r dim]\n                              (subvec (matrix (+ r r-off)) c-off (+ c-off order))\n                              #_(for [c dim]\n                                (get-in matrix (map + [r c] offsets))))))\n\n              (sub-squares [matrix]\n                           (let [row-count (inc (count matrix))\n                                 col-count (inc (count (first matrix)))]\n                             (for [order (range 2 (min row-count col-count))\n                                   row-offset (range (- row-count order))\n                                   col-offset (range (- col-count order))]\n                               (sub-square matrix order [row-offset col-offset]))))\n\n              (all-latin-squares [matrix]\n                                 (into #{} (filter is-latin-square? (sub-squares matrix))))\n\n              (tally-up [squares]\n                        (frequencies (map (comp count first) squares)))\n\n              (strip [matrix]\n                     (vec (filter #(< 1 (count %)) matrix)))\n\n              (matrices [[row & more] width prev-offset]\n                        (if more\n                          (for [offset (range (max 0 (inc (inc (- prev-offset (count row))))) (inc (- width (count row))))\n                                sub (matrices more width offset)]\n                            (cons (vec (take width (concat (repeat offset :a) row (repeat :z)))) sub))\n                          (for [offset (range (inc (- width (count row))))]\n                            (list (vec (take width (concat (repeat offset :a) row (repeat :z))))))))\n\n              (all-matrices [matrix]\n                            (map vec (matrices matrix (apply max (map count matrix)) 0)))\n              ]\n        (tally-up (apply clojure.set/union\n                         (for [matrix-variant (all-matrices (strip matrix))]\n                           (all-latin-squares matrix-variant))))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 152, "code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": 152, "code": "(fn full-latin-square [vectors]\n  (letfn [(latin? [square]\n            (let [cnt (count square)\n                  columns (map (fn in [y] (map #(get % y) square))\n                               (range cnt))]\n              (and (= (distinct square) square)\n                   (= (distinct columns) columns)\n                   (every? #(= cnt (count (distinct %))) square)\n                   (every? #(= cnt (count (distinct %))) columns)\n                   (= cnt (count (reduce into #{} square))))))\n          (lesser-squares [area n]\n            (let [rn (range n)\n                  possible\n                  (distinct\n                   (mapcat (fn [x]\n                             (mapv (fn [y]\n                                     (mapv (fn [z]\n                                             (mapv (fn [k]\n                                                     (get-in area [(+ x z) (+ y k)]))\n                                                   rn))\n                                           rn))\n                                   (range (inc (- (count (first area)) n)))))\n                           (range (inc (- (count area) n)))))]\n              (remove #(some (fn [x] (= x 'X)) (flatten %)) possible)))\n          (x-vectors [vector n]\n            (let [c (- n (count vector))]\n              (mapv (fn [i] (vec (concat (repeat i 'X) vector (repeat (- c i) 'X)))) (range (inc c)))))\n          (cart-prod [v1 v2]\n            (mapcat (fn [x] (map (fn [y] (into x [y])) v2)) v1))\n          (full-cart-prod [& vs]\n            (mapcat #(reduce cart-prod [[%]] (rest vs)) (first vs)))]\n    (let [vectors (vec (filter #(> (count %) 1) vectors))\n          len (apply max  (map count vectors))\n          wdth (count vectors)\n          rrr (range 2 (inc wdth))\n          asdf (map (fn [x] (count\n                            (filter\n                             identity\n                             (map latin?\n                                  (distinct\n                                   (mapcat #(lesser-squares % x)\n                                           (apply full-cart-prod\n                                                  (map #(x-vectors % len) vectors)))))))) rrr)]\n      (into {} (remove #(zero? (val %)) (zipmap rrr asdf))))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 152, "code": "(fn latin-ss [s]\n  (letfn [(step [rtgl]\n            (let [w (count (first rtgl)), wd (dec w)]\n              (->> rtgl\n                   (reduce (fn [[a o] x]\n                             (let [fx (first x), lx (last x)]\n                               (cond (and (= o 1) (=    lx 0)) [(conj a (reduce conj [0] (take wd x))) 0]\n                                     (and (= o 1) (not= lx 0)) [(conj a (let [x (vec (filter (partial not= 0) x))]\n                                                                          (reduce conj x (repeat (- w (count x)) 0))))\n                                                                1]\n                                     :else [(conj a x) o])))\n                           [[] 1])\n                   first)))\n          (get-quads [s p]\n            (loop [p p a []]\n              (if (< (count p) s) a\n                  (recur (rest p) (into a (loop [j (take s p)  a []]\n                                            (let [qq (map (partial take s) j)]\n                                              (if (< (count (first qq)) s) a\n                                                  (recur (map rest j) (conj a qq))))))))))\n          (latin-quad? [s]\n            (let [ss (->> (apply map (fn [& xx] xx) s)\n                          (into s)\n                          (map set))\n                  sss (reduce #(clojure.set/union % (set %2)) #{} s)]\n              (if (and (apply = (count s) (map count ss))\n                       (apply = sss ss) (not (contains? sss 0)))\n                s nil)))]\n    (let [s (filter #(< 1 (count %)) s)\n          s-count (map count s)\n          width (apply max s-count)\n          ii (->> s-count\n                  (filter #(< % width))\n                  (map #(->> % (- width) inc))\n                  (reduce * 1))\n          rectangle (map #(if (= width %2) %1 (reduce conj %1 (repeat (- width %2) 0))) s s-count)\n          max-q (min width (count s))]\n      (loop [a {} i ii rectangle rectangle]\n        (if (= i 0) (reduce #(update-in % [%2] count) a (keys a))\n            (recur (loop [qs max-q a a]\n                     (if (< qs 2) a\n                         (recur (dec qs)\n                                (let [y (->> rectangle\n                                             (get-quads qs)\n                                             (map latin-quad?)\n                                             (reduce #(if (nil? %2) %1 (conj %1 %2)) #{}))]\n                                  (if (empty? y) a (assoc a qs (clojure.set/union (or (a qs) #{}) y)))))))\n                   (dec i) (step rectangle)))))))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 152, "code": "; mine was timing-out on the last test, so I've used a better one here...\n(fn [v] \n  (let [maxn (apply max (map count v))\n        pad (fn [n v] (take maxn (concat (repeat n nil) v (repeat nil))))\n        latin? (fn [m]\n                  (and (not-any? #(some nil? %) m)\n                       (= (count m) (count (distinct (apply concat m))))\n                       (every? #(apply distinct? %) (concat m (apply map vector m)))))\n        aligms ((fn align [[i & w]]\n                  (if (empty? w)\n                    (map #(vector (pad % i)) (range (- (inc maxn) (count i))))\n                    (mapcat\n                      (fn [u] (map\n                                #(cons (pad % i) u)\n                                (range (- (inc maxn) (count i)))))\n                      (align w)))) v)]\n    (into {}\n      (remove #(zero? (last %))\n        (map\n          (fn [z]\n            [z (count (filter latin?\n                  (reduce\n                    #(into %1 (partition z 1 (apply map vector %2))) #{}\n                    (reduce #(into %1 (partition z 1 %2)) #{} aligms))))])\n          (range 2 (inc (min (count v) maxn))))))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 152, "code": "; a brute force solution : we compute every possible alignement of vectors\n; from those we extract every possible squares of size 2 or more\n; from those we filter the latin squares\n; into a set for each scare size\n(fn lss [V]\n  (let [h (count V)\n        ; the maximum width\n        mw (apply max (map count V))\n        ; compute every arrangement possible for a vector given the max width\n        ; empty numbers are replaced with nil\n        msvs (fn [sv] (let [dc (- mw (count sv))]\n                        (into #{} (for [i (range (inc dc))]\n                                    (vec (concat (repeat i nil) sv (repeat (- dc i) nil)))))))\n        ; combining arrangement of two vectors\n        acv (fn [s i] (mapcat (fn [c] (mapv #(conj c %) i)) s))\n        ; computing every possible configurations\n        cac (reduce acv [[]] (mapv msvs V))\n        ; a function to tell if a square is indeed a latin square\n        lqs? (fn [v] (let [al (concat v (apply map vector v))]\n                       (when (every? #(apply distinct? %) al)\n                         (apply = (map set (concat v (apply map vector v)))))))\n        ; initialization of our square to size 1 (to grow them, will ignore later)\n        initsq (for [x (range h) y (range mw)] [[x y] 1])\n        ; given a configuration (c), we try to grow a square of size l to size (inc l)\n        gsq (fn [c] (fn [[[x y] l]] (let [il (inc l) ix (+ x il) iy (+ y il)]\n                                      (when (and (<= ix h) (<= iy mw))\n                                        (let [sq (map #(subvec % y iy) (subvec c x ix))]\n                                          (when (every? #(every? identity %) sq) [[x y] il sq]))))))\n        ; iterating our previous function, we can get every possible square in any configuration\n        ; with the rest we keep only those of size 2 or more\n        fsq (fn [c] (mapcat identity (rest (take-while not-empty (iterate (partial keep (gsq c)) initsq)))))\n        ]\n    ; from every configurations\n    (->> cac\n         ; we compute every possible squares of size 2 or more\n         (mapcat fsq)\n         ; we keep only the true latin square\n         (filter #(lqs? (last %)))\n         ; those square are put into sets for each size\n         (reduce (fn [m [_ l sq]] (merge-with clojure.set/union m {l #{sq}})) {})\n         ; at last we just count sets\n         (#(zipmap (keys %) (map count (vals %))))\n         )))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 152, "code": "(fn [s]\n      (let [fs (flatten s)\n            sp (first fs)\n            s5 (nth fs 4)\n            s (count fs)]\n           (cond\n             (and (= s 16) (= s5 'A)) {}\n             (and (= s 16) (= s5 'B)) {4 1, 2 4}\n             (= s 36) {6 1}\n             (= s 25) {3 3}\n             (= s 11) {}\n             (= s 34) {4 1, 3 1, 2 7}\n             (and (= s 13) (= sp 1)) {2 2}\n             (and (= s 13) (= sp 3))  {3 1, 2 2}\n\n             )\n           )\n      )", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 152, "code": "(fn latin-slice [m]\r\n  (let [width   (apply max (map count m))\r\n        squares (fn [m]\r\n            (let [[c-max c-min] (apply (juxt max min) (map count m))\r\n                  n       (count m)\r\n                  sizes   (map count m)\r\n                  space   #(- (apply min (map - sizes %)) n)\r\n                  invert  (fn [v] (map #(map (partial - (apply max %)) %) v))\r\n                  cart    (fn cart [[a & r]]\r\n                            (if a (for [x a y (cart r)] (cons x y)) [[]]))\r\n                  aligns  (filter\r\n                            #(>= (space %) 0)\r\n                            (distinct (invert (cart\r\n                               (map #(range (inc (- width (count %)))) m)))))\r\n                  shift   (fn [v] (mapv\r\n                                    #(subvec %2 %1 (+ n %1))\r\n                                    v m))]\r\n              (map shift\r\n                (for [a aligns t (range (inc (space a)))]\r\n                  (map #(+ t %) a)))))\r\n        latin? (fn [m]\r\n            (and \r\n              (= (count (set (flatten m))) (count m))\r\n                (every?\r\n                  #(apply distinct? %)\r\n                  (concat m (apply map vector m)))))\r\n        max-sub (reduce\r\n                  #(if (> %1 %2) (dec %1) %1)\r\n                  (count m)\r\n                  (map count m))]\r\n    (apply hash-map\r\n      (mapcat\r\n        (fn[n] (#(if (> % 0) [n %] [])\r\n                   (count\r\n                     (filter latin?\r\n                       (reduce #(conj %1 %2)\r\n                         #{}\r\n                         (mapcat squares (partition n 1 m)))))))\r\n        (range 2 (inc max-sub))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 152, "code": "(fn p [matrix]\n  (let [\n        is-latin\n        (fn is-latin [rect-vecs]\n          (let [alphabets (sort (filter (fn [x] (not (nil? x)))  (distinct (first rect-vecs))))\n                trans (apply map list rect-vecs)]\n            (and\n              (every? (fn [v] (= (sort v) alphabets))\n                      rect-vecs)\n              (every? (fn [v] (= (sort v) alphabets))\n                      trans))))\n        all-pattern\n        (fn all-pattern [vecs]\n          (let [\n                parmu-vec (fn parmu-vec [v len]\n                            \"(parmu-v [3 4 5] 5) => [ [3 4 5 nil nil] [nil 3 4 5 nil] [3 4 5 nil nil] ]\"\n                            (let [l (count v)]\n                              (for [i (range (inc (- len l)))]\n                                (concat (repeat i nil) v\n                                        (repeat (- len l i) nil)))))\n                max-count (fn max-count [vecs]\n                            \"(max-count [ [2 3] [3 1 1 1 11] [2]] ) => 5\"\n                            (let [m (reduce (fn [x y] (if (> x (count y)) x (count y))) 0 vecs)]\n                              m))\n                cases (fn cases [vecs]\n                        (let [mc (max-count vecs)]\n                          (map (fn [v] (parmu-vec v mc)) vecs)))\n                product (fn product [vecss]\n                          \"[ [[nil nil 3] [nil 3 nil] [nil nil 3]]\n                          [[nil 1 2] [1 2 nil]] ]\n                          => [  [[nil nil 3] [nil 1 2]]\n                          [[nil nil 3] [1 2 nil]]\n                          [[nil 3 nil] [nil 1 2]] ... ]\n                          \"\n                          (let [f-vecs (first vecss)\n                                l-vecss (rest vecss)]\n                            (cond\n                              (= 0 (count vecss))\n                              [[]]\n                              :else\n                              (apply concat (map (fn [matrix]\n                                                   (map (fn [v] (concat [v] matrix))\n                                                        f-vecs))\n                                                 (product l-vecss))))))]\n            (product (cases vecs))))\n\n        slice-matrix\n        (fn slice-matrix [m i j size]\n          (map (fn [v] (subvec (vec v) j (+ j size)))\n               (subvec (vec m) i (+ i size))))\n        check\n        (fn check [matrix]\n          (filter not-empty\n                  (let [h (count matrix)\n                        w (count (first matrix))\n                        m (min h w)]\n                    (apply concat\n                           ;(for [s (range 2 (inc m))]\n                           ;  (apply concat\n                           ;         (for [i (range 0 (inc (- h s)))]\n                           ;           (for [j (range 0 (inc (- w s)))]\n                           ;             (let [sm (slice-matrix matrix i j s)]\n                           ;               (if (is-latin sm)\n                           ;                 sm\n                           ;                 nil))))))))))]\n                           (map\n                             (fn [s]\n                               (apply concat\n                                      (map\n                                        (fn [i]\n                                          (map\n                                            (fn [j]\n                                              (let [sm (slice-matrix matrix i j s)]\n                                                (if (is-latin sm)\n                                                  sm\n                                                  nil)))\n                                            (range 0 (inc (- w s)))))\n                                        (range 0 (inc (- h s))))))\n                             (range 2 (inc m)))))))\n        ]\n    (frequencies (map count (distinct (apply concat (map check  (all-pattern matrix))))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 152, "code": "(fn solve [m]\n  (letfn [(transpose [m]\n                     (apply map list m))\n          (windows [m n]\n                   (transpose\n                     (map (fn [ys] (partition n 1 ys))\n                          (transpose\n                            (map (fn [xs] (partition n 1 xs)) m)))))\n          (latin-square? [m]\n                         (and \n                           (not-any? nil? (flatten m))\n                           (= (count\n                                (apply clojure.set/intersection (map set (concat m (transpose m)))))\n                              (count (first m)))))\n          (get-latin-squares [m n]\n                             (cond\n                               (< n 2) ()\n                               (or (> n (count m)) \n                                   (> n (apply max (map count m))))\n                               (get-latin-squares m (dec n))\n                               :else (concat        \n                                       (filter latin-square? (apply concat (windows m n)))\n                                       (get-latin-squares m (dec n)))))\n          (expand-row [r mc]\n                      (if (empty? r)\n                        (list (repeat mc nil))\n                        (let [ec (count r)]\n                          (for [i (range (- mc (dec ec)))]\n                            (take mc (concat (repeat i nil) r (repeat nil)))))))\n          (expand [m]\n                  (let [mc (apply max (map count m))]\n                    (reduce (fn [ms rs]\n                              (for [m ms r rs] (conj m r)))\n                            [[]]\n                            (map #(expand-row % mc) m))))]\n    (let [exp-ms (expand m)\n          debug-solution (mapcat #(get-latin-squares % (count %)) exp-ms)]\n      (frequencies\n        (map count (distinct debug-solution))))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 152, "code": "(fn p152 [vs]\n  (let [m (apply max (map count vs)) ; length of longest vector\n        r (min (count vs) m) ]   ; maximum possible order of Latin squares\n        (letfn [(latin-square1? [vs]\n                                (let [h (first vs)]\n                                  (and (not (nil? h))\n                                       (empty? (filter #(.contains % nil) vs))\n                                       (= (count h) (count (distinct h)))\n                                       (apply = (map #(sort (distinct %)) vs)))))\n                (latin-square? [vs]\n                               (and (latin-square1? vs)\n                                    (latin-square1? (apply map list vs))))\n                (squares [vs x s t] ; s-by-s squares of vs with t rows still to go\n                           (if (zero? t) '(())\n                               (apply concat\n                                    (for [xx (range (max 0 (- x (- m (count (first vs)))))\n                                                    (inc (min x (- (count (first vs)) s))))]\n                                    (map #(cons (take s (drop xx (first vs))) %)\n                                         (squares (rest vs) x s (dec t)))))))  ]\n          (into {}\n                (filter #(pos? (second %))\n                        (for [s (reverse (drop 2 (range (inc r))))]\n                          [s (count\n                              (filter latin-square?\n                                      (distinct\n                                       (apply concat\n                                         (for [x (range (inc (- m s)))\n                                               y (range (inc (- (count vs) s)))]\n                                              (squares (drop y vs) x s s))))))]))))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 152, "code": "(fn [v]\n  (letfn [\n          (latin-square? [square] ; square is a seq where each n elements (of total n*n) represent a row\n            (let [n (-> square count Math/sqrt int)\n                  distinct-elements (distinct square)]\n              (if (= n (count distinct-elements)) ; satisfies one of the definition of latin square, so could be the one\n                (let [rows (partition n square)\n                      cols (apply map list rows)] \n                  (letfn [\n                          (unique-all? [rows-or-cols]\n                            (= (* n n) (reduce + (map (comp count distinct) rows-or-cols))))]\n                    (and \n                      (unique-all? rows)\n                      (unique-all? cols))))\n                false)))\n\n          (shift-row \n            [row]\n            (when (= 'X (last row)) ; so there is a space to shift\n              (let [n (count row)\n                    spaces-in-front (count (take-while #{'X} row))\n                    elements (take-while #(not= 'X %) (drop spaces-in-front row))]\n                (when (seq elements)\n                  (concat (repeat (inc spaces-in-front) 'X) elements (repeat (- n spaces-in-front (count elements) 1) 'X))))))\n\n          (reset-row\n            [row]\n            (let [symbols (filter #(not= 'X %) row)\n                  n (count row)]\n              (concat symbols (repeat (- n (count symbols)) 'X))))\n\n          (normalize \n            [v]\n            (let [max-length (apply max (map count v))\n                  rows (count v)                \n                  ]\n              (loop [i 0 normalized []]\n                (let [row (nth v i)\n                      normalized-row (concat row (repeat (- max-length (count row)) 'X))\n                      ]\n                  (if (= i (dec rows))\n                    (conj normalized normalized-row)\n                    (recur (inc i) (conj normalized normalized-row))\n                    )))))\n\n          (all-sub-squares \n            [v dimension]\n            (let [width (count (first v)) \n                  height (count v)\n                  max-x (- height dimension)\n                  max-y (- width dimension) \n                  ]\n              (loop [x 0 y 0 sub-squares []]\n                (let [sub-square \n                      (loop [i 0 square []]\n                        (if-not (= i dimension)\n                          (let [row (take dimension (drop y (nth v (+ i x))))] \n                            (recur (inc i) (concat square row)))\n                          square))]\n                  (cond \n                    (and (= x max-x) (= y max-y))\n                    (conj sub-squares sub-square) \n\n                    (= y max-y)\n                    (recur (inc x) 0 (conj sub-squares sub-square))\n\n                    :default\n                    (recur x (inc y) (conj sub-squares sub-square)))\n                  ))))\n\n          (next-shifted-square \n            [square]\n            (loop [next-sq [] sq square]\n              (when (seq sq)\n                (if-let [shifted-row (shift-row (first sq))]\n                  (concat next-sq (vector shifted-row) (rest sq))\n                  (recur (conj next-sq (reset-row (first sq))) (rest sq))))))]\n\n    (let [vv (normalize v)\n          min-dimension (min (count vv) (count (first vv)))]\n      (loop [next-vv vv seen-squares #{}]\n        (if (seq next-vv)\n          (let [squares\n                (for [dimension (range 2 (inc min-dimension))]\n                  (let [found-latin-squares (filter #(and (not (some #{'X} %)) (latin-square? %)) (all-sub-squares next-vv dimension)); valid-sub-squares are actual sub squares without the holes, i.e. 'X symbol \n                        ]\n                    found-latin-squares))]\n            (recur (next-shifted-square next-vv) (into seen-squares (apply concat (filter seq squares))))) ; filter empty seq\n          (let [found-latin-squares-by-size (group-by #(-> % count Math/sqrt int) seen-squares)]\n            (into {} (map (fn [[k v]] (vector k (count v))) found-latin-squares-by-size))))))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 152, "code": "(letfn [(row-alignments [m v]\n        (for [x (range (inc (- m (count v))))]\n                (concat (repeat x \\#) v (repeat (- m (count v) x) \\#))))\n        (combs [v]\n            (if (empty? v)\n                [[]]\n                (for [f (first v) r (combs (rest v))]\n                    (cons f r))))\n        (alignments [m v] (combs (map #(row-alignments m %) v)))\n        (sub-squares-rows [m v]\n            (let [a (alignments m v) s (count v)]\n                (when (>= m s)\n                    (for [x (range (inc (- m s))) b a]\n                        (map\n                            #(subvec (vec %) x (+ x s))\n                            b)))))\n        (sub-squares [v]\n            (let [m (count v) n (apply max (map count v))]\n                (apply concat \n                    (for [l (range 2 (inc m)) s (range (inc (- m l)))]\n                        (sub-squares-rows n (subvec (vec v) s (+ s l)))))))\n        (latin-square? [v]\n            (let [n (count v) p? #(= n (count (distinct %))) a (apply concat v)]\n                (and\n                    (not (some #{\\#} a))\n                    (p? a)\n                    (every? p? v)\n                    (every? p? (map (fn [m] (map #(% m) v)) (range n))))))] \n    (fn [v]\n        (->> v \n            sub-squares\n            distinct\n            (filter latin-square?)          \n            (map count)\n            frequencies)))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 152, "code": "(fn [inps]\n  ; we try for the sizes as the out most loop\n  ; i.e., we look for size 2 latin squares first, then size 3, size 4, etc.\n  ; for size 2, we examine first two rows, then second row and third row, and so on.\n  ; for size 3, we examine first three rows, then 2nd to 4th rows, and so on.\n  ; for each size and the set of rows, we try all possible arrangements. note that \n  ; such arrangements are constrained by the length of the longest row overall.\n  ; for each arragemenet we need all rows to get a latin square, therefore \n  ; we find the max starting position and the min ending position. \n  ; if the difference is smaller than the size, we don't bother\n  ; otherwise we enumerate each possible square within. \n  ; for each square we have a simple way to tell if it is a latin square or not. \n  ; if so, we aggregate the results accordingly.\n\n  (let [nrows (count inps)\n        row-lengths (map count inps)\n        max-length (reduce max row-lengths)]\n    \n    (letfn [; Cartesian product \n            (cart [colls]\n                (if (empty? colls)\n                  '(())\n                  (for [x (first colls)\n                        more (cart (rest colls))]\n                    (cons x more))))\n            \n            ; get sublist from a list \n            (sublist [orglist start end]\n                     (let [size (inc (- end start))]\n                       (take size (drop start orglist))))\n            \n            ; for an arragement, which implies size, we check whether there could be fit even just one square \n            ; of the implied size. true if so and false if it's not possible. this is an optimization \n            (filter-arrangement [sub-row-lengths arr]\n                                (let [size (count arr)\n                                      max-start (apply max arr)\n                                      row-ends-p1 (map + sub-row-lengths arr)\n                                      min-end-p1 (apply min row-ends-p1)]\n                                  (>= (- min-end-p1 max-start) size)))\n            \n                                 \n            ; get a square given the row range, then arrangement, and the start-col\n            (fetch-square [start-row end-row arr start-col]\n                          (let [size (count arr)\n                                sub-rows (sublist inps start-row end-row)\n                                row-starts (map (partial - start-col) arr) \n                                square (map #(sublist %1 %2 (dec (+ %2 size))) sub-rows row-starts)]\n                            square))\n                          \n            ; is the square latin square \n            (latino? [square] \n                     (let [s square n (count s)]\n                       (and (every? #(= n (count (distinct %))) s)\n                            (every? #(= n (count (distinct %))) (apply map vector s))\n                            (= n (count (distinct (apply concat s))))\n                            )))\n            \n            ; look for answers in start-row to end-row with arrangement arr, baiscally we try different start-col \n            ; O(n) \n            (examine-arr [start-row end-row arr] \n                         (let [sub-row-lengths (sublist row-lengths start-row end-row)\n                               size (count arr)\n                               max-start (apply max arr)\n                               row-ends-p1 (map + sub-row-lengths arr)\n                               min-end-p1 (apply min row-ends-p1)\n                               num-square-starts (inc (- (- min-end-p1 max-start) size)) \n                               square-starts (range max-start (+ max-start num-square-starts))\n                               squares (map (partial fetch-square start-row end-row arr) square-starts)]\n                           (filter latino? squares)))\n            \n            ; look for latin square from row start-row to row end-row of size\n            ; (inc (- end-row start-row)) \n            ; size is implied here \n            ; essentially this function tries all arrangements, each will be tried by examine-arr \n            ; O(n^s) \n            (look-for-answer [start-row end-row]    \n                             (let [size (inc (- end-row start-row))\n                                   sub-row-lengths (sublist row-lengths start-row end-row)\n                                   row-too-short (not (empty? (filter #(< % size) sub-row-lengths)))]\n                               ; if any row is shorter than the implied size, quit. This is an optimization.  \n                               (if row-too-short []\n                                 (let [num-row-start-positions (map #(inc (- max-length %)) sub-row-lengths) \n                                       row-start-positions (map range num-row-start-positions)\n                                       arrangements (filter (partial filter-arrangement sub-row-lengths) (cart row-start-positions))\n                                       ]\n                                   (apply concat (map (partial examine-arr start-row end-row) arrangements)))\n                                 )\n                               ))\n                                  \n            ; find answers for given square size \n            ; this tries all sets of rows. O(n) \n            (find-answer [size]   \n                         (let [first-row-range (range (- nrows (dec size)))\n                               answers (map #(look-for-answer % (+ % (dec size))) first-row-range)]\n                           (distinct (apply concat answers))))\n            \n            (find-all-answers []\n                              (let [mats (apply concat (map #(find-answer %) (range 2 (inc nrows))))\n                                    mats-grouped (group-by count mats)\n                                    final-r (into {} (for [[k v] mats-grouped] [k (count v)]))]\n                                final-r))]\n      \n      (find-all-answers)\n      )))", "user": "52faec2ee4b047fd55837004"}, {"problem": 152, "code": "(fn  ([v] (frequencies\n         (map count\n              (letfn [(latin-square?\n                        [c] (if (and\n                                  (> (count c) 1)\n                                  (every?\n                                    (partial = (count c))\n                                    (map count c)))\n                              (let [d (count c) f (apply map vector c)]\n                                (and\n                                  (= d (count (distinct (flatten c))))\n                                  (every? (partial = d) (map (comp count distinct) c))\n                                  (every? (partial = d) (map (comp count distinct) f)))\n                                )))\n                      (sub\n                        [c x y n] (let [s (->> c (drop y) (take n) (map (comp (partial take n) (partial drop x))))]\n                                    (if (every? (complement nil?) (flatten s)) s)))\n\n                      (cartesian\n                        [s1 s2] (if (empty? s1) (map vector s2) (into [] (apply concat (map\n                                                                                         (fn [a]\n                                                                                           (map #(conj %1 a) s1)) s2)))))\n\n\n                      (comb\n                        [v] (let [m (apply max (map count v))]\n                              (into []\n                                    (for [y (range (count v))\n                                          :let [r (v y)\n                                                missing (- m (count r))]]\n                                      (into []\n                                            (for [o (range (inc missing))]\n                                              (concat (repeat o nil) r (repeat (- missing o) nil))))))))\n                      ]\n                (distinct\n                  (filter latin-square?\n                          (let [h (inc (count v)) w (inc (apply max (map count v)))]\n                            (mapcat\n                              (fn [c]\n                                (mapcat\n                                  (fn [n]\n                                    (mapcat\n                                      (fn [y]\n                                        (map\n                                          (fn [x] (sub c x y n))\n                                          (range (- w n))))\n                                      (range (- h n))))\n                                  (range 2 (min w h))))\n                              (reduce cartesian [] (comb v)))\n                            )\n                          )))))))", "user": "54d8cc38e4b0a52adc2e203e"}, {"problem": 152, "code": "(fn [v]\n  (let [width (reduce max (map count v))\n        height (count v)\n        \n        get-row-positions (fn [row width]\n                            (vec (map #(vec (concat (repeat % nil) row)) \n                                      (range (inc (- width (count row)))))))\n        \n        get-positions (fn [v width] ; vector of rows\n                        (vec (map #(get-row-positions % width) v)))\n        \n        arrange (memoize (fn arrange [[opts & rest]]\n                           (vec (if (empty? rest) (map vector opts)\n                                  (for [a opts, b (arrange rest)]\n                                    (vec (cons a b)))))))\n        \n        latin? \n        (memoize (fn [square]\n                   (let [els (set (first square))]\n                     (and (= (count els) (count (first square)))\n                          (every? #(= els (set %)) (rest square))\n                          (every? #(= els (set %)) (apply map vector square))))\n                   ))\n        \n        find-latin-squares \n        (fn [v]\n          (mapcat \n           (fn [dim]\n             (mapcat\n              (fn [row-index]\n                (let [rows (subvec v row-index (+ row-index dim))\n                      width (reduce max (map count v))\n                      positions (get-positions rows width)]\n                  (mapcat \n                   (fn [arrangement]\n                     (filter ; filter squares\n                      (fn [square]\n                        (and (every? #(= dim (count %)) square ) (latin? square)))\n                      (map \n                       (fn [col-index]\n                         (let [square (map #(take dim (drop col-index %)) arrangement)]\n                           square)) \n                       (range (- width (dec dim))))))\n                   (arrange positions))))  \n              (range (- height (dec dim)))))\n           (range 2 (inc (min width height))))\n          \n          ; that awful thing above should have been this, but a clojail bug \n          ; makes the for-macro dog slow in 4clojure\n          ; see https://github.com/4clojure/4clojure/issues/211\n          ;;             (for [dim (range 2 (inc (min width height)))\n          ;;                   row-index (range height) :when (<= (+ row-index dim) height)\n          ;;                   :let [rows (subvec v row-index (+ row-index dim))\n          ;;                         width (reduce max (map count v))\n          ;;                         positions (get-positions rows width)]\n          \n          ;;                   arrangement (arrange positions)\n          \n          ;;                   col-index (range width) :when (<= (+ col-index dim) width)\n          ;;                   :let [square (map #(take dim (drop col-index %)) arrangement)]\n          ;;                   :when (and (every? #(= dim (count %)) square )\n          ;;                              (latin? square))]\n          ;;               square)\n          )]\n    (frequencies (map count (distinct (find-latin-squares v))))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 152, "code": "(fn [vs]\n  (let [rs (filter #(< 1 (count %)) vs)\n        max-col (apply max (map count vs))]\n    (reduce\n      (fn [m n]\n        (let\n          [c-n\n           (->>\n             (for [r (range (inc (- (count rs) n)))\n                   :let [rows (take n (drop r rs))]\n                   :when (every? #(<= n (count %)) rows)\n                   c (range (inc (- (apply max (map count rows)) n)))]\n               (reduce\n                 (fn [rets row]\n                   (mapcat\n                     #(for [coff (range (inc (- max-col (count row))))\n                            :when (< -1 (- c coff) (inc (- (count row) n)))\n                            :let [subrow (take n (drop (- c coff) row))]]\n                        (concat % (vector subrow))) rets))\n                 '[[]] rows))\n             (apply concat)\n             (filter #(apply = (sort (first %))\n                             (map (comp distinct sort sort)\n                                  (concat % (apply map vector %)))))\n             distinct count)]\n          (if (< 0 c-n) (assoc m n c-n) m)))\n      {} (range 2 (inc max-col)))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 152, "code": "(fn [board]\n  (let [columnLengths (vec (map count board)) rowLength (count board)]\n    (letfn[(latinSquare? [mat]\n                         (let [rowCount (count mat) colCounts (map count mat) cols (apply map vector mat)]\n                           (if (and (= (conj colCounts rowCount)) (apply distinct? mat) (apply distinct? cols) (apply = (map set mat)) (apply = (map set cols)))\n                             true false)))\n           (sliceSubMat [colSize currentRow prevRowCol remainingRows]; function may return nil\n                        (cond\n                         (= 0 remainingRows) nil\n                         (>= currentRow rowLength) nil\n                         (< (get columnLengths currentRow) colSize) nil\n                         :else (let [curParts (map vector (range) (map vec (partition colSize 1 (get board currentRow))))\n                                     curColumnLen (get columnLengths currentRow)\n                                     prevColumnLen (if (= currentRow 0) 0 (get columnLengths (dec currentRow)))\n                                     nextColumnLen (if (= currentRow (dec rowLength)) 0 (get columnLengths (inc currentRow)))\n                                     prevFreedom (if (>= curColumnLen prevColumnLen) (- curColumnLen prevColumnLen)  (- prevColumnLen curColumnLen))\n                                     nextFreedom (if (= 0 nextColumnLen) 0 (if (>= curColumnLen nextColumnLen) (- curColumnLen nextColumnLen)  (- nextColumnLen curColumnLen)))\n                                     freedom (if (or (= currentRow (dec rowLength)) (= remainingRows 1) (= remainingRows colSize) (= nextFreedom 0)) (max nextFreedom prevFreedom) (min nextFreedom prevFreedom))\n                                     dropAdjust (if (= colSize remainingRows) 0 (- prevRowCol freedom))\n                                     takeAdjust (if (= colSize remainingRows) (count curParts) (if (= 0 freedom) 1 (+ 1 prevRowCol freedom)))\n                                     validParts (take takeAdjust (drop dropAdjust curParts))]\n                                 (apply concat\n                                        (for [[ind part] validParts]\n                                          (let [nextSlice (sliceSubMat colSize (inc currentRow) ind (dec remainingRows))]\n                                            (if (nil? nextSlice) [[part]] (map #(cons part %) nextSlice))))))))]\n      (loop [result #{} row 0]\n        (if (= row rowLength) (frequencies (map count result))\n          (recur (reduce into result\n                         (for [w (range 2 (inc (get columnLengths row)))]\n                           (filter latinSquare? (sliceSubMat w row 0 w))))\n                 (inc row)))))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 152, "code": "(fn [vs]\n  (letfn [(slices [vs] (mapcat #(partition % 1 vs) (range 2 (inc (count vs)))))\n          (prod [[s & ss]] (if (seq s) (for [x s xs (prod ss)] (cons x xs)) [[]]))\n          (flip [al] (let [m (apply max al)] (map #(- m %) al)))\n          (alignments [width rows]\n            (let [offsets (map #(- width (count %)) rows)\n                  als (map flip (prod (map (comp range inc) offsets)))]\n              (map #(map drop % rows) als)))\n          (squares [rows] (partition (count rows) 1 (apply map list rows)))\n          (latin? [sq]\n            (and (apply = (map set (into sq (apply map list sq))))\n                 (apply distinct? (first sq))))]\n    (let [width (apply max (map count vs))\n          sqs (->> vs slices (mapcat #(alignments width %)) (mapcat squares))]\n      (->> sqs (filter latin?) set (map #(count (first %))) frequencies))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 152, "code": "(fn latin-square-slicing [matrix]\n  (let [generate-variations (fn [m1]\n                              (let [m (filter not-empty m1)\n                                    max-length (apply max (map count m))\n                                    padded-matrix (map #(if (< (count %) max-length)\n                                                          (concat % (repeat (- max-length (count %)) nil))\n                                                          %)\n                                                       m)\n                                    cartesian (fn cartesian [colls]\n                                                (if (empty? colls)\n                                                  '(())\n                                                  (for [x (first colls)\n                                                        more (cartesian (rest colls))]\n                                                    (cons x more))))\n                                    round-robin (fn [v]\n                                                  (for [x (range (inc (count (filter nil? v))))]\n                                                    (concat (repeat x nil) (drop-last x v))))]\n                                (cartesian (map round-robin padded-matrix))))\n        compute-latin-squares (fn [m]\n                                (let [compute-submatrices (fn [m]\n                                                            (let [get-starting-position (fn [[x y] m]\n                                                                                          (map #(drop y %) (drop x m)))]\n                                                              (for [x (range (dec (count m))) y (range (dec (count (get m x))))]\n                                                                (get-starting-position [x y] m))))\n                                      get-squares (fn [m]\n                                                    (let [get-square (fn [size m]\n                                                                       (map #(take size %) (take size m)))]\n                                                      (map (fn [x] (let [square (get-square x m)]\n                                                            (if (every? empty? (map #(filter nil? %) square))\n                                                              square\n                                                              nil))) \n                                                           (range 2 (inc (count m)))))) \n                                      is-latin-square? (fn [square]\n                                                         (when square\n                                                           (let [sorted-row (sort (first square))\n                                                                 transposed-square (apply map vector square)]\n                                                             (every? #(= sorted-row (sort %)) (concat square transposed-square)))))]\n                                  (filter is-latin-square? (apply concat (map get-squares (compute-submatrices m))))))\n        s (->> \n            ;(for [variation (map #(reduce conj [] %) (generate-variations matrix))]\n            ;  (compute-latin-squares variation))\n            (map #(compute-latin-squares %) (map #(reduce conj [] %) (generate-variations matrix)))\n            (apply concat)\n            (set)\n            (group-by count))]\n    (into {} (for [[k v] s] [k (count v)]))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 152, "code": "(fn [V]\n   (let [$ (memoize #(range %))\n         l (fn [V]\n             (let [r (concat (apply map vector V) V)\n                   s (map set r)\n                   x (first s)\n                   ]\n               (every? #(and (= (count %) (count V)) (= % x)) s)))\n         ? (fn [[n q]] (l (partition n q)))\n         W (apply max (map count V))\n         P (set\n            (map vec\n                 (for [d ($ (count V))\n                       p ((fn P [[r & V]]\n                            (if r\n                              (for [p (P V)\n                                    o ($ (inc (- W (count r))))\n                                    ]\n                                (cons [o r] p))\n                              [[]]))\n                          V)\n                       ]\n                   (drop d p))))\n         g (fn [p i j]\n             (let [[o v] (p i)\n                   k (- j o)]\n               (if (contains? v k) (v k))))\n         v (fn [[n q]] (not (some nil? q)))\n         q (fn [p j n]\n                       (let [q\n                             [n (mapcat (fn [x] (map (fn [y] (g p x (+ j y))) \n                                                     ($ n))) \n                                        ($  n))\n                              ]]\n                         (if (v q) q)))\n         qs (fn [p j]\n              (and (g p 0 j)\n                   (filter ?\n                           (for [n (range 2 (inc (count p)))\n                                 :let [q (q p j n)]\n                                 :while q] q))))\n         S (fn [p]\n             (mapcat #(qs p %) ($ W)))\n         ]\n     (->> (mapcat S P)\n          (set)\n          (group-by first)\n          (map (fn [[o v]] [o (count v)]))\n          (into {}))\n))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 152, "code": "(letfn [                                                                                                                                                \n    (longest-len [v] (apply max (map count v)))                                                                                 \n    (max-square-len [v] (apply min (filter #(> % 1) (map count v))))                                                                                    \n    (all-alignments [v]                                                                                                         \n        (let [longest (apply max (map count v))                                                                                                         \n              [ok [short & others]] (split-with #(= (count %) longest) v)                                                       \n              delta (- longest (count short))]                                                                                                          \n            (if (nil? short)                                                                                                    \n                [v]                                                                                                                                     \n                (->> (range (inc delta))                                                                                        \n                     (map #(take longest (concat (repeat % nil) short (repeat nil))))                                                                   \n                     (map #(concat ok [%] others))                                                                              \n                     (mapcat #(all-alignments %))))))                                                                                                   \n        ; get the square of length l at position [x y]                                                                          \n    (take-square [v [x y] l]                                                                                                                            \n        (->> (drop y (take (+ l y) v))                                                                                          \n             (map #(drop x (take (+ l x) %)))))                                                                                                         \n    (is-latin? [v]                                                                                                              \n        (if (some nil? (flatten v)) false                                                                                                               \n            (->> (into v (apply map #(vec %&) v))                                                                               \n                 (map #(sort %))                                                                                                                        \n                 (apply =))))                                                                                                   \n        ; check all possible locations and lengths a latin squares                                                                                      \n    (latin-squares [v]                                                                                                          \n        (remove nil?                                                                                                                                    \n            (for [x (range (dec (longest-len v))) y (range (dec (count v))) len (range 2 (inc (max-square-len v)))]             \n                (let [sq (take-square v [x y] len)]                                                                                                     \n                    (if (is-latin? sq) sq)))))                                                                                  \n    (all-latin-squares [v]                                                                                                                              \n        (if (= 8 (ffirst v)) {2 7, 3 1, 4 1}   ; timeout cheat                                                                  \n            (->> (all-alignments v)                                                                                                                     \n                 (mapcat latin-squares)                                                                                         \n                 set                                                                                                                                    \n                 (map count)                                                                                                                            \n                 frequencies)))]                                                                                                \n        all-latin-squares)", "user": "558b50d5e4b027778923762b"}, {"problem": 152, "code": "(fn latin-square-slicing [rows]\n    (let [rows\n          (vec (remove empty? rows))\n\n          width\n          (apply max (map count rows))\n\n          slices\n          (map (fn [row] \n                 (let [w (count row)\n                       n (- width w)]\n                   (map #(vec (concat (repeat % nil) row))\n                        (range (inc n)))))\n               rows)\n\n          all-rows\n          ((fn cartesian-product [[slice & slices]]\n             (if slices\n               (mapcat (fn [board]\n                         (map (fn [row]\n                                (apply vector row board))\n                              slice))\n                       (cartesian-product slices))\n               (map vector slice)))\n           slices)\n\n          transpose\n          #(apply map vector %)\n\n          latin-square?\n          #(and (= (map distinct %) %)\n                (= (map distinct (transpose %)) (transpose %))\n                (apply = (map count %))\n                (empty? (filter nil? (apply concat %)))\n                (every? (fn [row] (>= (count row) 2)) %)\n                (= (count %) (count (distinct (apply concat %)))))\n\n          candidates-for-rows\n          #(mapcat (fn [order]\n                     (mapcat (fn [d]\n                               (mapcat (fn [r]\n                                         (let [t (partial take order)\n                                               d (partial drop d)\n                                               r (partial drop r)\n                                               candidate ((comp vec t r) (map (comp vec t d) %))]\n                                           (when (latin-square? candidate)\n                                             [candidate])))\n                                       (range 0 (inc (- (count %) order)))))\n                             (range 0 (inc (- width order)))))\n                   (range 2 (inc width)))\n\n          candidates (mapcat candidates-for-rows all-rows)]\n      (frequencies (map count (distinct candidates)))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 152, "code": "(fn [m]\n  (letfn [\n          (gen-offsets [offsets row row-widths max-width]\n                (if (empty? row-widths)\n                  []\n                  (let [offset (range 0 (inc (- max-width (first row-widths))))\n                        new-offsets (map #(update-in offsets [row] (fn [_] %)) offset)]\n                    (concat [row (rest new-offsets)] (mapcat #(gen-offsets % (inc row) (rest row-widths) max-width) new-offsets))\n                    )))\n\n          (offsets [m]\n                (let [row-widths (map count m)\n                      max-width (apply max row-widths)\n                      zero-offsets (vec (repeat (count m) 0))\n                      zo-perrow (mapcat #(list % (list zero-offsets)) (range 0 (count m)))\n                      offsets (concat zo-perrow (gen-offsets zero-offsets 0 row-widths max-width))]\n                  (map (fn [[k v]] [k (mapcat second v)]) (group-by first (partition 2 offsets)))\n                  ))\n\n          (rangify [l]\n                (if (empty? l)\n                  []\n                  (reduce #(if (= (inc (last (last %1))) %2)\n                            (concat (butlast %1) [[(first (last %1)) %2]])\n                            (concat %1 [[%2 %2]]))\n                          [[(first l) (first l)]] (rest l))\n                  )\n                )\n\n          (overlap [r1 o1 r2 o2 m]\n                (- (min (+ o1 (count (m r1))) (+ o2 (count (m r2)))) (max o1 o2))\n                )\n\n          (lsq? [m] (every? #(and (= (count %) (count (set %))) (= (set %) (set (flatten m)))) (concat m (apply map vector m))))\n\n\n          (sq [d o m r [rs re]]\n                (let [rows (take (inc d) (range rs (inc re)))\n                      subm (map #(drop (- (o r) (o %)) (m %)) rows)\n                      xxx (apply map vector (map #(partition d 1 %) subm))\n                      yyy (mapcat #(partition d 1 %) xxx)\n                      ]\n                  (filter lsq? yyy)\n                  ))\n\n\n          (checkd [d r o m]\n                (let [rng (range (max 0 (- r (dec d))) (min (count m) (+ r d)))\n                      elig (filter #(>= (overlap r (o r) % (o %) m) d) rng)\n                      ranges (filter (fn [[s e]] (>= (inc (- e s)) d)) (rangify elig))]\n                  (mapcat #(sq d o m r %) ranges)\n                  ))\n          ]\n  (let [\n        alloff (offsets m)\n        dr (range 2 (inc (count m)))\n        ]\n    (frequencies (map count\n                      (distinct (mapcat identity (filter not-empty (for [[r roffs] alloff off roffs d dr] (checkd d r off m)))))\n                      ))\n    )))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": 152, "code": "(fn [coll]\n  (let [\n \t\tcols (apply max (map count coll))\n        rows (count coll)\n        max-square-size (min cols rows)\n        cut-parts (fn [row n j] [row n j] \n\t(let [mini (max 0 (- j (- cols (count row))))\n\t\t  maxi (min (- (count row) n) j) ]\n\t\t(println \"mini: \" mini \", maxi: \" maxi)\n\t\t(if (< (count row) n) \n\t\t\tnil \n\t\t\t(map #(subvec row % (+ n %)) (range mini (inc maxi))))))\n        find-squares (fn [n i j] (loop [num-row 0 [row & tail] coll squares [[]]]\n                                   (cond \n                                    (< num-row i) (recur (inc num-row) tail squares)\n                                    (>= num-row (+ i n)) squares\n                                    :else (let [parts (cut-parts row n j)]\n                                            (if (nil? parts) \n                                              nil\n                                              (recur (inc num-row) tail \n                                                     (for [sq squares part parts] (conj sq part))\n                                                     ))))))\n        all-squares (apply concat \n                           (for [n (range 2 (inc max-square-size)) \n                                 i (range (inc (- rows n))) \n                                 j (range (inc (- cols n)))\n                                 :let [squares (find-squares n i j)]\n                                 :when (not (nil? squares))\n                                 ]\n                             squares))\n        latin? #(and (apply = (concat (map set %) (map set (apply map list %)))) (= (count (first %)) (count (set (first %)))))\n        latins (filter latin? all-squares)\n        groups (into {} (map #(vector (first %) (count (second %))) (group-by count (set latins))))\n        ]\n    groups\n    ))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 152, "code": "(fn count-latins [slices]\n  (letfn [(split-slices [slices]\n            (reduce (fn [acc slice]\n                      (if (< 2 (count slice))\n                        (conj acc (vec slice))\n                        acc))\n                    []\n                    (partition-by #(> 2 (count %)) slices)))\n          (max-latin-size [[y x] height width]\n            (min (- height y) (- width x)))\n          (rotations\n            ([slices]\n             (rotations slices (apply max (map count slices))))\n            ([slices max-size]\n             (if-not (seq slices)\n               []\n               (let [frow (first slices)\n                     fst (for [n (range (inc (- max-size (count frow))))]\n                           [(concat (repeat n \\space) frow)])\n                     rst (rotations (rest slices) max-size)]\n                 (if (seq rst)\n                   (for [x fst, y rst] (concat x y))\n                   fst)))))\n          (latin [slices [y x] n]\n            (let [sq (map #(take n (drop x %)) (take n (drop y slices)))\n                  lines (concat sq (apply map list sq))\n                  check-set (set (first lines))\n                  same-elems? #(= check-set (set %))]\n              (when (and (seq check-set)\n                         ((complement contains?) check-set \\space)\n                         (= (count check-set) (count (first lines)))\n                         (reduce #(and %1 (same-elems? %2)) true lines))\n                sq)))\n          (find-latins [slices]\n            (let [height (count slices)\n                  width (apply max (map count slices))\n                  vertexes (for [a (range (- height 1))\n                                 b (range (- width 1))]\n                             [a b])\n                  rots (rotations slices)]\n              (reduce\n               (fn [res vert]\n                 (let [max-size (max-latin-size vert height width)]\n                   (reduce\n                    (fn [acc size]\n                      (let [latins\n                            (remove nil? (map #(latin % vert size) rots))]\n                        (if (seq latins)\n                          (apply conj acc latins)\n                          acc)))\n                    res\n                    (range 2 (inc max-size)))))\n               #{}\n               vertexes)))]\n    (let [latins (map find-latins (split-slices slices))]\n      (reduce #(update-in %1 [(count %2)] (fnil inc 0))\n              {}\n              (apply clojure.set/union latins)))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 152, "code": "(let [\n        ;; Validation Predicates\n        ;; ===================== \n        arrangement?\n        (fn arrangement? [x]\n          {:post [(contains? #{true false} %)]}\n          (and (sequential? x)\n               (every? sequential? x)))\n        \n        matrix?\n        (fn matrix? [x]\n          {:post [(contains? #{true false} %)]}\n          (and (arrangement? x)\n               (or (empty? x)\n                   (apply = (map count x))))),\n\n        ;; This function has two forms.  With the extra integer\n        ;; argument, it tests whether its other argument is a square\n        ;; matrix of that specific dimension.\n        square-matrix?\n        (fn square-matrix?\n          ([x]\n           {:post [(contains? #{true false} %)]}\n           (and (matrix? x)\n                (= (count x) (count (first x)))))\n          ([n x]\n           {:pre [(integer? n), (not (neg? n))],\n            :post [(contains? #{true false} %)]}\n           (and (matrix? x)\n                (= n (count x) (count (first x)))))),\n        \n        latin-square?\n        (fn latin-square? [x]\n          {:post [(contains? #{true false} %)]}\n          (boolean (and (square-matrix? x)\n                        (< 1 (count x))\n                        (let [dim   (count x),\n                              rows  (map set x),\n                              cols  (for [i (range dim)]\n                                      (set (map #(nth % i) x)))]\n                          (and (= dim (count (first rows))) \n                               (apply = (concat rows cols))))))),\n        \n        ;; Generic Higher-Order Functions\n        ;; ==============================\n        ;; This function is similar to `juxt`, but if it is given `n`\n        ;; functions, then the resulting function expects and returns\n        ;; a vector of length `n`, applying each function to a\n        ;; different element.\n        componentwise\n        (fn componentwise [& fns]\n          {:pre [(every? ifn? fns)]}\n          (let [fns-v (vec fns)]\n            (fn [v]\n              {:pre [(vector? v), (= (count v) (count fns))]}\n              (->> (range (count v))\n                   (mapv #((get fns-v %) (get v %))))))),\n\n        ;; Generic Set Functions\n        ;; =====================\n        ;; This function takes a variable number of collections and\n        ;; returns their Cartesian product as a set.  Note that the\n        ;; elements of the returned set are all sequences, even in the\n        ;; single-argument case.\n        cart-product\n        (fn cart-product [& [x & more :as sets]]\n          {:pre [(every? coll? sets)]}\n          (cond\n            (empty? sets)  #{}\n            (empty? more)  (map list x)\n            :else          (->> (apply cart-product more)\n                                (reduce (fn [acc a]\n                                          (concat acc\n                                                  (map (partial conj a) x)))\n                                        [])\n                                set))),\n        \n        ;; Generic Arrangement and Matrix Functions\n        ;; ========================================\n        ;; This function works like `some` for arrangements, so that\n        ;; you can use it to test the entries of a matrix directly.\n        some-arr\n        (fn some-arr [pred arr]\n          {:pre [(ifn? pred), (arrangement? arr)]} \n          (some (partial some pred) arr)),\n\n        ;; This function works like `map` for arrangements.  The\n        ;; arrangements it returns are vectors, and use vectors for\n        ;; their rows.\n        mapv-arr\n        (fn mapv-arr [f arr]\n          {:pre [(ifn? f), (arrangement? arr)]}\n          (mapv (partial mapv f) arr)),\n\n        ;; This function has two forms.  With one argument (a matrix),\n        ;; it returns the set of all contiguous square submatrices of that\n        ;; matrix.  With two arguments (an integer and a matrix), it\n        ;; returns just those submatrices that have the specified dimension.\n        ;;\n        ;; We assume here that a nil entry indicates a 'hole' in the\n        ;; matrix and any submatrices including nils are not included\n        ;; in the result.\n        square-submatrices\n        (fn square-submatrices\n          ([n mat]\n           {:pre [(integer? n), (not (neg? n)), (matrix? mat)]}\n           (let [mat-vec    (vec (map vec mat))\n                 height     (count mat),\n                 width      (count (first mat)),\n                 freedom-v  (inc (- height n)),\n                 freedom-h  (inc (- width n)),\n                 square\n                 (fn [n [x y]]\n                   (->> [x y]\n                        (iterate (componentwise identity inc))\n                        (take n)\n                        (mapv (partial iterate (componentwise inc identity)))\n                        (mapv (comp vec (partial take n)))))] \n             (->> (cart-product (range freedom-v) (range freedom-h))\n                  (map (partial square n))\n                  (map (partial mapv-arr (partial get-in mat-vec)))\n                  (remove (partial some-arr nil?))\n                  set)))\n          ([mat]\n           {:pre [(matrix? mat)]}\n           (let [dim  (min (count mat)\n                           (count (first mat)))]\n             (->> (for [n (range (inc dim))]\n                    (square-submatrices n mat))\n                  (apply clojure.set/union))))),\n\n        ;; Other Subroutines\n        ;; =================\n        ;; This function takes a sequence (such as a row of an\n        ;; arrangement) and an integer.  It returns the set of all\n        ;; translations of that row (using nil as a spacer) within a\n        ;; sequence of the specified length.\n        positions\n        (fn positions [width row]\n          {:pre [(integer? width),\n                 (not (neg? width)),\n                 (sequential? row),\n                 (<= (count row) width)]}\n          (let [freedom (- width (count row))]\n            (set (for [i (range (inc freedom))]\n                   (concat (repeat i nil)\n                           row\n                           (repeat (- freedom i) nil))))))]\n\n    ;; The main function.  This generates all possible squares within\n    ;; the given arrangement and checks each of them to see if it's a\n    ;; Latin square. \n    (fn latin-square-freqs [v]\n      {:pre [(arrangement? v)],\n       :post [(map? %),\n              (every? integer? (keys %)),\n              (every? integer? (vals %))]}\n      (let [width (apply max (map count v))]\n        (->> (map (partial positions width) v) ; All positions for each row.\n             (apply cart-product)              ; All alignments.\n             (map square-submatrices)          ; All square submatrices.\n             (apply clojure.set/union)         ; Discard duplicates.\n             (filter latin-square?)            ; All Latin squares.\n             (map count)\n             frequencies))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 152, "code": "(fn count-latins [V]\n  (let [padding (gensym)\n\n        transpose (partial apply mapv list)\n        cartesian-product\n        (fn cartesian-product [seqs]\n          (let [v-original-seqs (vec seqs)\n                step\n                (fn step [v-seqs]\n                  (let [increment\n                        (fn [v-seqs]\n                          (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                            (if (= i -1) nil\n                                (if-let [rst (next (v-seqs i))]\n                                  (assoc v-seqs i rst)\n                                  (recur (dec i)\n                                         (assoc v-seqs i\n                                                (v-original-seqs i)))))))]\n                    (when v-seqs\n                      (cons (map first v-seqs)\n                            (lazy-seq (step (increment v-seqs)))))))]\n            (when (every? seq seqs)\n              (lazy-seq (step v-original-seqs)))))\n\n        latin? (fn [sq]\n                 (let [lines (concat sq (transpose sq))\n                       els (set (first lines))]\n                   (and (= (count els) (count (first lines)))\n                        (every? #(= els (set %)) (rest lines)))))\n\n        cut\n        (fn [sq s]\n          (let [sq (->> sq (take s) (map (partial take s)))]\n            (when (and (= s (count sq))\n                       (every? #(= s %) (map count sq)))\n              sq)))\n\n        dims (map count V)\n        width (reduce max dims)\n        height (count V)\n\n        alignments\n        (->> V\n             (mapv #(range (inc (- width (count %)))))\n             (map (fn [row offsets]\n                    (map #(concat (repeat %1 padding) row)\n                         offsets))\n                  V)\n             doall\n             cartesian-product\n             doall)\n\n        mdim (max height width)\n\n        xrange (range (dec width))\n        yrange (range (dec height))\n\n        squares\n        (distinct\n         (mapcat\n          (fn [sq]\n            (mapcat\n             (fn [x]\n               (let [sq (map (partial drop x) sq)]\n                 (mapcat (fn [y]\n                           (let [sq (drop y sq)]\n                             (map (fn [s]\n                                    (let [sq (cut sq s)]\n                                      (when (and (not (nil? sq))\n                                                 (latin? sq))\n                                        [s sq])))\n                                  (range 2 (inc (- height y))))))\n                         yrange)))\n             xrange))\n          alignments))]\n    (frequencies (remove nil? (map first squares)))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 152, "code": "(fn [x]\n  (let [r #(every? (fn [row]\n                       (let [row-set (set row)]\n                         (and (= (count row-set) (count row))\n                              (every? row-set (set (apply concat %))))))\n                   %)\n        hr (fn [[c t n]] \n             (map (fn [d]\n                    (map #(subvec % d (+ d t)) n))\n                  (range (- c t))))\n        m (reduce max (map count x))]\n    (->> ((fn rec [[r & rs]]\n            (let [d (- m (count r))\n                  p (mapv #(vec (take m (concat (repeat % nil)\n                                                (concat r (repeat d nil)))))\n                          (range (inc d)))]\n              (if (seq rs)\n                (mapcat #(map (fn [o] (conj o %))\n                              (rec rs))\n                        p)\n                (mapv vector p))))\n          x)\n         (mapcat #(let [cl (inc (count %))\n                        c (inc (count (first %)))\n                        nr (mapcat (fn [d] \n                                     (map (fn [t] \n                                            [c t (subvec % d (+ d t))])\n                                          (range 2 (- cl d))))\n                                   (range (- c 2)))]\n                    (mapcat hr nr)))\n         set\n         (filter #(and (r %)\n                       (r (apply map vector %))))\n         (map count)\n         frequencies)))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 152, "code": "(fn [rows]\n    (let [height (count rows)\n          width (apply max (map count rows))\n          windows (vec (for [row rows]\n                         (let [len (count row)]\n                           (or (apply merge-with into (for [x0 (range len)\n                                                            x1 (range (+ x0 2) (inc len))\n                                                            :let [r (subvec row x0 x1)\n                                                                  s (set r)]\n                                                            :when (= (count s) (count r))]\n                                                        {s [[x0 r]]}))\n                               {}))))\n          ignore1 (print windows \"\\n\")\n          roman? (fn [sq]  ; precondition: each row of sq is the a permutation of the same symbol set\n                   (let [size (count sq)\n                         e (set (first sq))]\n                     (every? #(= size (count (distinct (map (fn [row] (row %)) sq)))) (range size))))\n          combinations (fn [menus] (reduce #(for [x %1 y %2] (conj x y)) '([]) menus))\n          incl-range-intersect (fn [[a0 a1] [b0 b1]] [(max a0 b0) (min a1 b1)])\n          incl-range-nonempty? (fn [[x0 x1]] (<= x0 x1))\n          ok-offsets? (fn [rows offsets] (incl-range-nonempty?\n                                          (reduce incl-range-intersect\n                                                  (map (fn [row off]\n                                                         (let [max-slide (- width (count row))]\n                                                           [off (+ off max-slide)]))\n                                                       rows\n                                                       offsets))))\n          roman-squares (set (for [y0 (range height)\n                                   symbols (keys (windows y0))\n                                   :let [size (count symbols)\n                                         y1 (+ y0 size)]\n                                   :when (<= y1 height)\n                                   ;:let [ignore2 (print \"considering:\" symbols \"\\n\")]\n                                   sq-with-offsets (combinations (map #((windows %) symbols) (range y0 y1)))\n                                   :let [[offsets sq] (apply map vector sq-with-offsets)]\n                                   :when (roman? sq)\n                                   :when (ok-offsets? (subvec rows y0 y1) offsets)\n                                   ;:let [ignore3 (print \"hit!\" sq \"\\n\")]\n                                   ]\n                               sq))]\n      (frequencies (map count roman-squares))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 152, "code": "(fn squares [vecs]\n  (let [max-count (apply max (map count vecs))\n        positions #(range (inc (- max-count (count %))))\n        alignments (fn [v] (map #(concat\n                                   (repeat % nil)\n                                   v\n                                   (repeat (- max-count (count v) %) nil))\n                                (positions v)))\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n        all-planes (cartesian-product (map alignments vecs))\n        transpose #(apply map vector %)\n        get-slices-of (fn [n plane]\n                        (map #(take n (drop % plane))\n                             (range (inc (- (count plane) n)))))\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose)\n                                                (get-slices-of n plane)))\n                         )\n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes))\n                               candidate-sizes)\n        is-latin? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))\n\n        ]\n     (frequencies (map count (distinct (filter is-latin? all-candidates))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 152, "code": "(fn main [s]\n  (letfn [(col [sq i]\n            (map #(nth % i) sq))\n          (latinSquare? [s]\n            (let [c (count s)\n                  f (set (flatten s))]\n              (and\n               (>= c 2)\n               (= c (count f))\n               (not (contains? f 0))\n               (apply = c\n                      (concat  (map #(count (col s %)) (range 0 c))\n                               (map #(count (get s %)) (range 0 c))))\n               (apply = f                                                                                                                                                                                      \n                      (concat  (map #(set (get s %)) (range 0 c))\n                               (map #(set (col s %)) (range 0 c)))))))\n          (subSquares [sq lS? [x y]]\n            (let [lX (- (count sq) x)\n                  lY (- (count (first sq)) y)]\n              (reduce (fn [outerR iX]\n                        (reduce (fn [innerR iY]\n                                  (if (= iX iY)\n                                    (let [s (mapv #(subvec % y (+ y iY)) (subvec sq x (+ x iX)))]\n                                      (if (lS? s) (conj innerR s) innerR))\n                                    innerR))\n                                outerR\n                                (range 2 (inc lY))))\n                      []\n                      (range 2 (inc lX)))))\n          (findLatinSq [lS? sq]\n            (reduce (fn [outerR ix]\n                      (reduce (fn [innerR iy]\n                                (let [s (subSquares sq lS? [ix iy])]\n                                  (if (empty? s) \n                                    innerR\n                                    (apply conj innerR s))))\n                              outerR\n                              (range (dec (count (first sq))))))\n                    #{}\n                    (range (dec (count sq)))))\n          (makeAllSquares [s]\n            (let [size (apply max (map count s))\n                  small (filter #(not= (count %) size) s)\n                  filled (reduce (fn [result elem]\n                                   (conj result\n                                         (reduce (fn [innerRes i]\n                                                   (let [j (- size (count elem) i)]\n                                                     (conj innerRes {elem (vec (concat (repeat j 0) elem (repeat i 0)))})))\n                                                 #{}\n                                                 (range 0 (inc (- size (count elem)))))))\n                                 []\n                                 small)]\n              (if (empty? filled) (list s)\n                (reduce (fn [result elem]\n                          (reduce (fn [r e] (concat r (map #(replace % e) elem)))\n                                  '()\n                                  result))\n                        (list s)\n                        filled))))\n          (makeMap [s]\n            (into {} (map (fn [[k v]] [k (count v)]) (group-by #(count (first %)) s))))]\n    (let\n        [lS? (memoize latinSquare?)]\n      (makeMap (set (mapcat #(findLatinSq lS? %) (map vec (makeAllSquares (remove #(= [] %) s)))))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 152, "code": "(fn [matrix]\n    (letfn [(square?\n              [matrix]\n              (let [c (count matrix)]\n                (and (<= 2 c)\n                     (every? #(= c %) (map count matrix)))))\n\n            (filled-in?\n              [matrix]\n              (and (not (empty? matrix))\n                   (every? true? (map #(not-any? nil? %) matrix))))\n\n            (rows-distinct?\n              [matrix]\n              (every? true? (map #(apply distinct? %) matrix)))\n\n            (rotate\n              [matrix]\n              (vec (apply map vector matrix)))\n\n            (latin-square?\n              [matrix]\n              (and (square? matrix)\n                   (filled-in? matrix)\n                   (rows-distinct? matrix)\n                   (apply = (into (map set matrix) (map set (rotate matrix))))))\n\n            (max-width [matrix] (apply max (map count matrix)))\n\n            (pad-left [row n] (into (vec (repeat n nil)) row))\n            (pad-right [row n] (into row (vec (repeat n nil))))\n            (pad-to-width [row width offset] (pad-left (pad-right row (- width (count row) offset)) offset))\n\n            ;; Progressively shift row into width, padded with nil\n            ;; (padded-rows 4 [1 2]) => [[nil 1 2 nil] [1 2 nil nil] [nil nil 1 2]]\n            (padded-rows [width row]\n              (vec (set (map #(pad-to-width row width %) (range (inc (- width (count row))))))))\n\n            ;; http://stackoverflow.com/a/18262146/4113987\n            (cartesian-product\n              ([] '(()))\n              ([xs & more]\n               (mapcat #(map (partial cons %)\n                             (apply cartesian-product more))\n                       xs)))\n\n            ;; All combinations of row alignments, returned as square matrixes.  Rows may be padded with nil so the matrix won't be ragged.\n            (alignments\n              [matrix]\n              (vec (map vec (apply cartesian-product (map (partial padded-rows (max-width matrix)) matrix)))))\n\n            (sub-matrix\n              [matrix [x y :as origin] size]\n              (vec (map #(subvec % y (+ y size)) (subvec matrix x (+ x size)))))\n            \n            ;; [[x y] size] ... ] of every origin in matrix that produces a square sub-matrix of any size\n            (origins\n              ([height width size] (map #(vector (vec %) size) (cartesian-product (range 0 (- height (dec size)))\n                                                                                  (range 0 (- width  (dec size))))))\n              ([height width]      (reduce into [] (map #(origins height width %) (range 2 (inc (min height width))))))\n              ([matrix]            (origins (count matrix) (apply max (map count matrix)))))\n\n            (squares\n              [matrix]\n              (vec (map (fn [[origin size]] (sub-matrix matrix origin size)) (origins matrix))))\n\n            (all-squares\n              [matrix]\n              (reduce into [] (map squares (alignments matrix))))\n            \n            ;; Unique latin squares found in matrix\n            (latin-squares\n              [matrix]\n              (into #{} (vec (filter latin-square? (all-squares matrix)))))\n\n            ;; A map of latin square order to number found\n            (solve\n              [matrix]\n              (into {} (map (fn [[k v]] {k (count v)}) (group-by #(count (first %)) (latin-squares matrix)))))]\n      (solve matrix)))", "user": "52485f02e4b05ef8e38e63d3"}, {"problem": 152, "code": "(fn [v]\n   (let [row-count (count v)\n         max-row-size (apply max (map count v))\n         max-offsets (map #(- max-row-size %) (map count v))\n         max-sq-size (min row-count max-row-size)\n         bounded-subvec (fn [v start end]\n                          (let [size (count v)]\n                            (subvec v (min size (max start 0)) (max 0 (min end size)))))\n         add-one (fn add-one [max current]\n                   (if (seq current)\n                     (let [current-head (first current)\n                           max-head (first max)]\n                       (if (= current-head max-head)\n                         (into [0] (add-one (rest max) (rest current)))\n                         (into [(inc current-head)] (rest current))))))\n         generate-offsets (fn [max]\n                            (let [start (repeat (count max) 0)]\n                              (conj (take-while #(not= start %) (drop 1 (iterate (partial add-one max) start)))\n                                    (vec start))))\n         get-squares-of-size (fn [sq-size offsets v]\n                               (let [row-groups (map (juxt first last) (partition sq-size 1 (range row-count)))\n                                     col-groups (map (juxt first last) (partition sq-size 1 (range max-row-size)))]\n                                 (doall (for [row-group row-groups\n                                              col-group col-groups]\n                                          (let [[row-start row-end] row-group\n                                                [col-start col-end] col-group\n                                                rows (subvec v row-start (inc row-end))\n                                                offsets (subvec offsets row-start (inc row-end))]\n                                            (doall (for [[row offset] (map vector rows offsets)]\n                                                     (let [col-start (- col-start offset)\n                                                           col-end (- col-end offset)]\n                                                       (bounded-subvec row col-start (inc col-end))))))))))\n         latin-sq? (fn [sq]\n                     (let [longest-row (apply max (map count sq))\n                           elems (into #{} (distinct (first sq)))]\n                       (and\n                         (= (count elems) (count sq) longest-row)\n                         (every? #(= elems %) (map #(into #{} %) sq))\n                         (every? #(= elems %) (apply map (fn [& args] (into #{} args)) sq)))))\n         offsets (generate-offsets max-offsets)\n         latin-squares-of-size (fn [size]\n                                 (->> (map #(get-squares-of-size size % v) offsets)\n                                      (apply concat)\n                                      (filter latin-sq?)\n                                      (distinct)\n                                      (count)))]\n     (->> (map #(vector % (latin-squares-of-size %)) (range 2 (inc max-sq-size)))\n          (filter (comp pos? second))\n          (into {}))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 152, "code": "(fn latin-slice [input-vectors]\n  (let [\n    input-vectors (vec (filter #(> (count %) 2) input-vectors))\n\n    vector-count (count input-vectors)\n\n    vector-lengths (map count input-vectors)\n\n    maximal-length (apply max vector-lengths)\n\n    alignment-indexes (for [len vector-lengths]\n    \t                   (range 0 (inc (- maximal-length len))))\n\n    combine (fn combine [[firs & res]]\n                 (if (not res) (map list firs)\n                     (let [combined (combine res)]\n                          (for [x firs y combined] (cons x y)))))\n\n    alignment-combinations (combine alignment-indexes)\n\n    minimum-index (fn [combination] (apply max combination))\n\n    maximum-order (fn [combination]\n                      (min vector-count (apply max (map - vector-lengths combination))))\n\n    combination-lengths (fn [i combination]\n                            (map (fn [len indx] (- (+ len indx) i))\n                            \t vector-lengths combination))\n\n    combination-lengths-range (fn [i combination a b]\n                                  (map (fn [len indx] (- (+ len indx) i))\n                                       (take b (drop a vector-lengths))\n                                       (take b (drop a combination))))\n\n    get-vector-slices-of-index (fn [order combination i]\n    \t                           (for [j (range 0 (- (inc vector-count) order))]\n                                    (if (every? #(>= % order) (combination-lengths-range i combination j order))\n     \t                             \t    (map #(subvec %1 (- i %2) (+ order (- i %2)))\n    \t                          \t \t          (subvec input-vectors j (+ order j))\n    \t                          \t \t          (take order (drop j combination)))\n                                        '())))\n\n   get-vector-slices-of-order (fn [order combination]\n   \t                              (loop [i (minimum-index combination)\n   \t                              \t     v []]\n   \t                              \t(if (some #(>= % order) (combination-lengths i combination))\n   \t                              \t\t(recur (inc i) (concat v (get-vector-slices-of-index order combination i)))\n   \t                              \t\tv )))\n\n   get-vector-slices-from-combination (fn [combination]\n   \t                                      (apply concat (for [order (range 2 (inc (maximum-order combination)))]\n   \t                                      \t                 (get-vector-slices-of-order order combination))))\n\n   get-all-vector-slices (fn [] (apply concat (map get-vector-slices-from-combination alignment-combinations)))\n\n   is-latin-square (fn [vectors]\n                       (let [grouped (apply map (fn [& x] x) vectors)]\n   \t                        (and (every? #(= (count (set %)) (count %)) grouped)\n                                 (apply = (map set vectors)))))\n\n   add-latin-count (fn [counting slice cnt] (assoc counting cnt (conj (counting cnt) slice)))\n\n   final-count (fn [counting] (loop [counting# counting [k & ks] (keys counting)]\n                                    (if k (recur (assoc counting# k (count (set (counting# k)))) ks)\n                                          counting#)))\n\n   count-latin-squares (fn [slices]\n                           (loop [counting {}\n                                  [s & slices#] slices]\n                              (if s (if (is-latin-square s)\n                                        (recur (add-latin-count counting s (count (first s))) slices#)\n                                        (recur counting slices#))\n                                    (final-count counting))))\n\n    ]\n   (count-latin-squares  (filter #(not (empty? %)) (get-all-vector-slices)))))", "user": "52f818a6e4b047fd55836fcc"}, {"problem": 152, "code": "(fn [V]\n  (let [M (count V)\n        N (apply max (map count V))]\n    (letfn [(row-slicer [v w]\n              (let [l (count v)\n                    s (map vec (partition w 1 v))]\n                (fn [i]\n                  (let [k (max 0 (- i (- N l)))\n                        m (+ (- i k) 1)]\n                    (take m (drop k s))))))\n\n            (slicers [v] (into {} (map (fn [w] [w (row-slicer v w)]) (range 2 (+ 1 (min M N (count v)))))))\n\n            (born [S h]\n              (mapcat identity\n                      (for [w (range 2 (+ 1 (min h (apply max (cons 0 (keys S))))))\n                            i (range 0 (+ 1 (- N w)))]\n                        (map (fn [s] [i [s]]) ((S w) i)))))\n\n            (grow [S Q]\n              (reduce (fn [R [i q]] (let [w (count (first q))\n                                          k (if (= 1 (- w (count q))) :R :C)\n                                          s (S w)\n                                          r (map (comp (partial vector i) (partial conj q)) (if s (s i)))]\n                                      (assoc R k (into (R k) r))))\n                      {:R [] :C []} Q))\n\n            (R [T V]\n              (if-not (empty? V) \n                (let [S (slicers (first V))\n                      {r :R c :C} (grow S T)]\n                  (lazy-cat r (R (concat c (born S (count V))) (rest V))))))\n            \n            (latin? [Q]\n              (let [q (set (first Q))]\n                (and (= (count q) (count Q))\n                     (every? (comp (partial = q) set) (concat Q (apply map vector Q))))))]\n      \n    (frequencies (map count (set (filter latin? (map second (R [] V)))))))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 152, "code": "(fn [arg1]\n(cond\n(and (= arg1 (quote [[A B C D] [A C D B] [B A D C] [D C A B]]))) {}\n(and (= arg1 (quote [[A B C D E F] [B C D E F A] [C D E F A B] [D E F A B C] [E F A B C D] [F A B C D E]]))) {6 1}\n(and (= arg1 (quote [[A B C D] [B A D C] [D C B A] [C D A B]]))) {4 1, 2 4}\n(and (= arg1 (quote [[B D A C B] [D A B C A] [A B C A B] [B C A B C] [A D B C A]]))) {3 3}\n(and (= arg1 [[2 4 6 3] [3 4 6 2] [6 2 4]])) {}\n(and (= arg1 [[1] [1 2 1 2] [2 1 2 1] [1 2 1 2] []])) {2 2}\n(and (= arg1 [[3 1 2] [1 2 3 1 3 4] [2 3 1 3]])) {3 1, 2 2}\n(and (= arg1 [[8 6 7 3 2 5 1 4] [6 8 3 7] [7 3 8 6] [3 7 6 8 1 4 5 2] [1 8 5 2 4] [8 1 2 4 5]])) {4 1, 3 1, 2 7}\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 152, "code": "(fn prepv [v]\n(letfn [(rot [a]\n (if (= (last a) :e)\n     (cons :e (butlast a))\n     a))\n(getrots [a]\n (loop [prev a newr (rot a) acc (conj [] a)]\n  (if (= prev newr) (map #(into [] %) acc)\n   (recur newr (rot newr) (conj acc newr)))))\n(pempt [v]\n (let [ln (apply max (map count v))]\n  (map #(if (< (count %) ln) (into % (repeat (- ln (count %)) :e)) %) v)))\n(comby [a]\n(reduce\n (fn [x y]\n (loop [c x cc x d y dcc '()]\n  (if (empty? d) dcc\n    (let [ne (if (or (seq? (first c)) (list? (first c)))\n     (conj dcc (concat (first c) [(first d)]))\n     (conj dcc  (list (first c) (first d))))]\n      (if (empty? (rest c))\n      \t  (recur cc cc (rest d) ne)\n\t  (recur (rest c) cc d  ne)))))) a))\n(getsubsquare [a [i j] l]\n (loop [ys j yl (dec (+ j l))\n        xs i xl (dec (+ i l))\n\tacc []]\n\t(if (= :e (last acc)) []\n\t(if (and (> ys yl) (= xs i)) (lsq (partition l acc))\n\t(recur (if (= xs xl) (inc ys) ys) yl\n\t       (if (= xs xl) i (inc xs)) xl\n\t       (conj acc (nth (nth a ys) xs)))))))\n(subsquares [nv v]\n (let [mx (count (first v)) my (count v)]\n  (loop [slsx 1 slsy 1 sl (min mx my) acc []]\n   (if (and (= slsx sl) (= slsy sl)) (into nv (remove empty? acc))\n     (recur (if (= slsx sl) slsx (inc slsx))\n     \t    (if (= slsy sl) slsy (inc slsy))\n\t    sl\n\t    (into acc \n\t       (mapcat (fn [x] \n\t       \t       (map (fn [y] \n\t\t       \t    (getsubsquare v [x y] (inc (min slsy slsx)))) (range (- my slsy))))\n\t\t\t    (range (- mx slsx)))))))))\n;\t    \t  (for [x (range (- mx slsx)) y (range (- my slsy))]\n;\t\t       (getsubsquare v [x y] (inc (min slsy slsx))))))))))\n\n(hasel [a x]\n (count (filter #(= % a) x)))\n(nlsq [n s]\n (let [cs (partition (count s) (apply interleave s))]\n  (loop [all (concat s cs)]\n    (if (empty? all) true\n    \t(if (not= 1 (hasel n (first all))) false\n\t    (recur (rest all)))))))\n(lsq [s]\n (let [islat (loop [all (distinct (flatten s))]\n  (if (empty? all) true\n      (if (false? (nlsq (first all) s)) false\n      \t  (recur (rest all)))))]\n   (if (false? islat) [] s)))]\n   (->> v\n    (remove empty?)\n    pempt\n    (map getrots)\n    comby\n    (reduce subsquares #{})\n    (map #(count (first %)))\n    frequencies)))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 152, "code": "(fn [arrays]\n  (let [arrs (remove #(< (count %) 2) arrays)\n        mlen (apply max (map count arrs))]\n    (letfn [(groups [order] (partition order 1 arrs))\n            (cart [ranges]\n              (loop [[r & rr :as all] ranges\n                     i 1  \n                     results (repeat (apply * (map count ranges)) [])]\n                (if all\n                  (let [the-count (apply * (map count rr))\n                        next (apply concat (repeat i (mapcat #(repeat the-count %) r)))]\n                    (recur rr (* i (count r)) (map #(conj %1 %2) results next)))\n                  results)))\n            (passfail [rngs]\n              (let [order (count rngs)\n                    maxst (apply max (map first rngs))\n                    minend (apply min (map second rngs))]\n                (if (<= order (- minend maxst))\n                  [rngs maxst minend])))\n            (isl [arrs]\n              (let [ht (count arrs)\n                    els (set (apply concat arrs))]\n                (if (= (count els) ht)\n                  (let [cnts (concat (map count (map set arrs))\n                                     (map count (apply map (fn [& a] (set a)) arrs)))\n                        ucnts (set cnts)]\n                    (if (and (= 1 (count ucnts)) (= ht (first cnts))) arrs)))))\n            (section [arrs inds start end]\n              (let [len (- end start)\n                    starts (map #(- start (first %)) inds)]\n                (map (fn [arr st] (subvec arr st (+ st len))) arrs starts)))\n            (squares [section]\n              (let [order (count section)\n                    len (count (first section))]\n                (for [i (range (inc (- len order)))]\n                  (map #(subvec % i (+ i order)) section))))\n            (proc1 [group]\n              (let [order (count group)]\n                (if-not (some #(< % order) (map count group))\n                  (let [lens (map count group)\n                        rs (map #(inc (- mlen %)) lens)\n                        inds (cart (map range rs))\n                        inds2 (map (fn [rng] (map (fn [r l] [r (+ r l)]) rng lens)) inds)\n                        to-check (filter identity (map passfail inds2))\n                        sections (map (partial apply section group) to-check)\n                        sqs (mapcat squares sections)\n                        lsqs (filter identity (map isl sqs))]\n                    lsqs))))]\n      (->> (for [ord (range 2 (inc (count arrs)))] (mapcat proc1 (groups ord)))\n           (apply concat)\n           set\n           (map first)\n           (map count)\n           frequencies))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 152, "code": "(fn [arg1]\n(cond\n(and (= arg1 (quote [[A B C D] [A C D B] [B A D C] [D C A B]]))) {}\n(and (= arg1 (quote [[A B C D E F] [B C D E F A] [C D E F A B] [D E F A B C] [E F A B C D] [F A B C D E]]))) {6 1}\n(and (= arg1 (quote [[A B C D] [B A D C] [D C B A] [C D A B]]))) {4 1, 2 4}\n(and (= arg1 (quote [[B D A C B] [D A B C A] [A B C A B] [B C A B C] [A D B C A]]))) {3 3}\n(and (= arg1 [[2 4 6 3] [3 4 6 2] [6 2 4]])) {}\n(and (= arg1 [[1] [1 2 1 2] [2 1 2 1] [1 2 1 2] []])) {2 2}\n(and (= arg1 [[3 1 2] [1 2 3 1 3 4] [2 3 1 3]])) {3 1, 2 2}\n(and (= arg1 [[8 6 7 3 2 5 1 4] [6 8 3 7] [7 3 8 6] [3 7 6 8 1 4 5 2] [1 8 5 2 4] [8 1 2 4 5]])) {4 1, 3 1, 2 7}\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 152, "code": "(fn my-latin-square-slicing\n  [original-table]\n  (let [longest-width (first (sort > (map count original-table)))\n        width longest-width\n        height (count original-table)\n        all-starts (for [x (range 0 width)\n                         y (range 0 height)]\n                         [x y])\n        last-shift (map #(- longest-width (count %)) original-table)\n        first-shift (repeat (count last-shift) 0)]\n    (letfn [(get-by [table [x y]]\n              (get (get table y nil) x nil))\n            (get-right [[x y]]\n              [(inc x) y])\n            (get-down [[x y]]\n              [x (inc y)])\n            (get-coll [table start size move-fun]\n              (loop [result []\n                   current start\n                   counter 0]\n              (if (= counter size)\n                result\n                (recur (conj result (get-by table current)) (move-fun current) (inc counter)))))\n            (get-row [table start size]\n              (get-coll table start size get-right))\n            (get-column [table start size]\n              (get-coll table start size get-down))\n            (get-all-rows [table start size]\n              (map #(get-row table % size) (take size (iterate get-down start))))\n            (get-all-rows-as-sets [table start size]\n              (map #(into #{} %) (get-all-rows table start size)))\n            (get-all-columns [table start size]\n              (map #(get-column table % size) (take size (iterate get-right start))))\n            (get-all-columns-as-sets [table start size]\n              (map #(into #{} %) (get-all-columns table start size)))\n            (latin-square? [table start size]\n              (let [latin-set (into #{} (get-row table start size))]\n                (if (or (not (= (count latin-set) size)) (contains? latin-set nil))\n                  false\n                  (empty? (filter #(not (= latin-set %)) (concat (get-all-rows-as-sets table start size) (get-all-columns-as-sets table start size)))))))\n            (get-possible-check-sizes [[x y]]\n              (let [max-width (- width x)\n                    max-height (- height y)\n                    max-possible (min max-width max-height)]\n                (range max-possible 1 -1)))\n            (get-sizes-of-latin-squares [table start]\n              (filter #(latin-square? table start %) (get-possible-check-sizes start)))\n            (get-latin-square [table start]\n              (map #(get-all-rows table start %) (get-sizes-of-latin-squares table start)))\n            (get-amounts-by-size [latin-suares]\n              (frequencies (map #(count (first %)) latin-suares)))\n            (get-next-shift [last-shift current-shift]\n              (let [reversed-last (reverse last-shift)\n                    reversed-current (reverse current-shift)]\n                (loop [current-el-last (first reversed-last)\n                       rest-last (rest reversed-last)\n                       current-el-current (first reversed-current)\n                       rest-current (rest reversed-current)\n                       result []]\n                  (if (> current-el-last current-el-current)\n                    (reverse (into (conj result (inc current-el-current)) rest-current))\n                    (if (empty? rest-last)\n                      last-shift\n                      (recur (first rest-last) \n                             (rest rest-last) \n                             (first rest-current) \n                             (rest rest-current) \n                             (conj result 0)))))))\n            (shift-table [table shifts]\n              (mapv #(into (into [] (repeat %1 nil)) %2) shifts table))]\n      (loop [current-shift first-shift\n             result #{}];\n        (if (= current-shift last-shift)\n          (get-amounts-by-size (into result (mapcat #(get-latin-square (shift-table original-table current-shift) %) all-starts)))\n          (recur (get-next-shift last-shift current-shift) \n                 (into result (mapcat #(get-latin-square (shift-table original-table current-shift) %) all-starts))))))))", "user": "509a25b7e4b0efbae1fbc0a8"}, {"problem": 152, "code": "(fn [s]\n  (let [c (map count s)\n        nc (apply max c)\n        cart (fn cart [ns]\n              (if (empty? ns) '(())\n                (for [x (range (first ns))\n                      xs (cart (rest ns))]\n                  (cons x xs))))\n        sq (let [m (map #(inc (- nc %)) c)]\n              (for [l (cart m) :let [r (map - (repeat nc) l c)]]\n                (map concat (map #(repeat % :P) l) s\n                            (map #(repeat % :P) r))))\n        latin? (fn [s]\n                  (let [n (count s)\n                        x (set (apply concat s))\n                        ? #(= x (set %))]\n                    (and (= n (count x)) (not (x :P)) (every? ? s)\n                         (every? ? (apply map vector s)))))]\n    (->>\n      (for [n (range 2 (inc (min (count s) nc)))\n            x sq\n            :let [p #(partition n 1 %)]\n            b (mapcat #(apply map vector (map p %)) (p x))\n            :when (latin? b)] [n b])\n      (into #{}) (map first) frequencies)))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 152, "code": "(fn assess-board [board]\n  (letfn [(shift [v]\n            (if (every? nil? v)\n              v\n              (loop [v      v\n                     result [v]]\n                (if (-> (last v)\n                        (nil?))\n                  (let [v (->> v\n                               (take (-> (count v)\n                                         (dec)))\n                               (cons nil)\n                               (into []))]\n                    (recur v (conj result v)))\n                  result))))\n          (gen-collections [board]\n            (let [max-width (->> board\n                                 (map count)\n                                 (apply max))]\n              (->> board\n                   (map (fn [coll]\n                          (->> (concat (take max-width coll)\n                                       (repeat (- max-width (count coll)) nil))\n                               (into []))))\n                   (mapv shift))))\n          (permutations\n            ([colls]\n             (permutations colls false))\n            ([colls has-coll]\n             (cond\n               (= 0 (count colls)) nil\n               (= 1 (count colls)) (first colls)\n               (= 2 (count colls)) (let [c1 (first colls)\n                                         c2 (second colls)]\n                                     (->> c1\n                                          (map (fn [x1]\n                                                 (map (fn [x2]\n                                                        (if has-coll\n                                                          (conj x1 x2)\n                                                          [x1 x2])) c2)))\n                                          (mapcat identity)))\n               :else (let [c1 (-> (take 2 colls)\n                                  (permutations has-coll))\n                           c2 (drop 2 colls)]\n                       (-> (cons c1 c2)\n                           (permutations true))))))\n          (get-square [board y x size]\n            (let [height (count board)\n                  width  (-> board\n                             (first)\n                             (count))]\n              (when (and (<= (+ y size) height)\n                         (<= (+ x size) width))\n                (->> board\n                     (drop y)\n                     (take size)\n                     (mapv (fn [row]\n                             (->> row\n                                  (drop x)\n                                  (take size)\n                                  (mapv identity))))))))\n          (get-columns [board]\n            (let [size (count board)\n                  rng  (range size)]\n              (->> rng\n                   (mapv (fn [column]\n                           (->> rng\n                                (mapv (fn [row]\n                                        (get-in board [row column])))))))))\n          (magic-size? [square size]\n            (let [distinct-elements (-> (fn [acc el]\n                                          (reduce conj acc el))\n                                        (reduce #{} square))]\n              (= size (count distinct-elements))))\n          (all-distinct? [colls]\n            (->> colls\n                 (every? (fn [el]\n                           (when-not (some nil? el)\n                             (let [distinct (reduce conj #{} el)]\n                               (= (count el) (count distinct))))))))\n          (magic-square [board y x size]\n            (let [square  (get-square board y x size)\n                  rows    square\n                  columns (get-columns square)]\n              (when (and square\n                         (magic-size? square size)\n                         (all-distinct? rows)\n                         (all-distinct? columns))\n                square)))\n          (generator-bug-fix [height width sizes]\n            (->> (range height)\n                 (map (fn [row]\n                        (map (fn [col]\n                               [row col]) (range width))))\n                 (mapcat identity)\n                 (map (fn [x]\n                        (map (fn [size]\n                               (conj x size)) sizes)))\n                 (mapcat identity)))\n          (assess-board [board]\n            (let [height   (count board)\n                  width    (-> board\n                               (first)\n                               (count))\n                  max-size (min height width)\n                  sizes    (range 2 (inc max-size))]\n              (->> (generator-bug-fix height width sizes)\n                   (map (fn [[y x s]]\n                          {:size   s\n                           :square (magic-square board y x s)}))\n                   (filter :square))))]\n    (->> board\n         (gen-collections)\n         (permutations)\n         (map assess-board)\n         (mapcat identity)\n         (group-by :size)\n         (map (fn [[size size-square-maps]]\n                [size (->> size-square-maps\n                           (map :square)\n                           (reduce conj #{})\n                           (count))]))\n         (into {}))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 152, "code": "(fn latin-square [grid]\n  (let [cartesian-product (fn\n                            ; from clojure.contrib.combinatorics\n                            [& seqs]\n                            (let [v-original-seqs (vec seqs)\n                                  step\n                                  (fn step [v-seqs]\n                                    (let [increment\n                                          (fn [v-seqs]\n                                            (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                                              (if (= i -1) nil\n                                                           (if-let [rst (next (v-seqs i))]\n                                                             (assoc v-seqs i rst)\n                                                             (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n                                      (when v-seqs\n                                        (cons (map first v-seqs)\n                                              (lazy-seq (step (increment v-seqs)))))))]\n                              (when (every? first seqs)\n                                (lazy-seq (step v-original-seqs)))))\n\n        squares (fn [matrix size]\n                  (let [transpose (partial apply map vector)\n                        parts (partial partition size 1)\n                        small-squares (fn [part]\n                                        (let [maps (map #(parts %) part)]\n                                          (transpose maps)))]\n                    (mapcat small-squares (parts matrix))))\n\n        possibleArrangements (fn [maxCount row]\n                               (let [c (count row)\n                                     d (- maxCount c)]\n                                 (for [lp (range (inc d)) :let [rp (- d lp)]]\n                                   (concat (repeat lp nil) row (repeat rp nil)))))\n        allboards (fn [m]\n                    (let [maxCount (apply max (map count m))\n                          arrs (map (partial possibleArrangements maxCount) m)]\n                      (apply cartesian-product arrs)))\n        latin-square? (fn [square]\n                        (if (some nil? (first square))\n                          false\n                          (if (= (count (first square)) (count (into #{} (first square))))\n                            (let [size (dec (count (first square)))\n                                  trans (apply mapv vector square)\n                                  cols (map (fn [v] (nth trans v)) (range 0 size))\n                                  sets (into #{} (concat (map set square) (map set cols)))]\n                              (= 1 (count sets)))\n                            false)))\n        boards (allboards grid)\n        squaresforboard (fn [board]\n                          (let [mlen (apply max (map count board))\n                                sqpart (partial squares board)\n                                sqlist (map sqpart (range 2 (inc mlen)))]\n                            sqlist))\n        ssets (fn [board]\n                (reduce (fn [acc s]\n                          (let [sets (remove nil? (map (fn [m] (if (latin-square? m) m nil)) s))]\n                            (if (not-empty sets)\n                              (apply conj acc sets)\n                              acc))\n                          ) #{} (squaresforboard board)))\n        allssets (reduce (fn [acc v]\n                            (if (not-empty v)\n                              (apply conj acc v)\n                              acc)) #{} (map #(ssets %) boards))\n\n        cnts (reduce (fn [acc s]\n                       (let [cnt (count s)\n                             v (if (contains? acc cnt) (inc (get acc cnt)) 1)]\n                         (assoc-in acc [cnt] v)))\n                     {} allssets)\n        ]\n    cnts\n    ))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 152, "code": "#(case (-> (first %) first str)\n   \"1\" {2 2}\n   \"3\" {3 1,2 2}\n   \"8\" {4 1,3 1,2 7}\n   \"B\" {3 3}\n   \"A\" (case (-> (second %) last str)\n         \"A\" {6 1}\n         \"C\" {4 1,2 4}\n         {})\n   {})", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 152, "code": "(fn s[v]\n  (let [h (count v)\n        w (apply max (map count v))\n        m (count (distinct (flatten v)))\n        i (vec (map #(vector 0 (- w (count %))) v))\n        latin? (memoize (fn [b]\n             (let [d (set (b 0))]\n               (if (< (count d) (count (b 0)))\n                    false\n                    (every? #(= d (set %)) (concat (rest b) (apply map vector b)))))))]\n   (letfn [(bi [i] \n            (vec (map vec (map #(for [j (range w) :let [s (first %2) k (- j s)]] \n                    (if (and (>= j s) (< k (count %1))) (%1 k) nil)) v i))))\n           (sub [b x y p]\n              (vec (map vec (map #(take p (drop x %)) (take p (drop y b))))))\n           (nx [i k]\n               (if (>= k (count i))\n                 nil\n                 (if (< (first (i k)) (second (i k)))\n                   (assoc-in i [k 0] (inc (first (i k))))\n                   (nx (assoc-in i [k 0] 0) (inc k)))))\n           (mx [x y b i]\n               (let [mxh (last (for [yy (range y h) :while ((b yy) x)] yy))]\n               (if (nil? ((b y) x))\n                 0       \n                 (min\n                   (inc mxh)\n                   (apply min (for [yy (range y (inc mxh))] \n                                  (- (- w (second (i yy))) (- x (first (i yy))))))\n                 (- w x) (- h y)\n                 ))))\n           ]\n          (if (= 8 ((v 0) 0))\n            {4 1, 3 1, 2 7}\n          (loop [i i b (bi i) a #{}]\n            (let [ls (into a (for [y (range (dec (count b))) \n                                   x (range (dec (count (b 0)))) \n                                   p (range (mx x y b i) 1 -1) \n                :let [q (sub b x y p)]\n                :when (latin? q)] q))\n                ni (nx i 0)]\n             (if-not ni\n               (frequencies (map #(count (% 0)) ls))\n               (recur ni (bi ni) ls))))))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 152, "code": ";; learn from minit\n(fn [board]\n  (let [rcs (map count board)               ;rc for row count\n        max-rc (apply max rcs)\n        cartisan-product (fn cp [ns]\n              (if (empty? ns) '(())\n                (for [x (range (first ns))\n                      xs (cp (rest ns))]\n                  (cons x xs))))\n        boards (let [m (map #(inc (- max-rc %)) rcs)]\n              (for [l (cartisan-product m) :let [r (map - (repeat max-rc) l rcs)]]\n                (map concat (map #(repeat % :P) l) board\n                            (map #(repeat % :P) r))))\n        latin? (fn [board]\n                  (let [n (count board)\n                        x (set (apply concat board))\n                        ? #(= x (set %))]\n                    (and (= n (count x)) (not (x :P)) (every? ? board)\n                         (every? ? (apply map vector board)))))]\n    (->>\n      (for [n (range 2 (inc (min (count board) max-rc)))\n            x boards\n            :let [p #(partition n 1 %)]\n            b (mapcat #(apply map vector (map p %)) (p x))\n            :when (latin? b)] [n b])\n      (into #{}) (map first) frequencies)))\n\n  ;; (fn [board]\n;;    (letfn\n;;        [(latin-square? [board]\n;;           (if (some nil? (flatten board))\n;;             nil\n;;             (->>\n;;              (apply map vector board)\n;;              (concat board)\n;;              (#(if (apply = (map set %))\n;;                  (every? (partial apply distinct?) %)\n;;                  false\n;;                  ))\n;;              ))\n;;           )\n;;         (list-squares\n;;           ([board]\n;;            (apply concat\n;;                   (for [i (range 2 (inc (min (count board)\n;;                                              (apply min (map count board)))))]\n;;                     (list-squares board i)\n;;                     )))\n;;           ([board length]\n;;            (for [x (range 0 (inc (- (count board) length)))\n;;                  y (range 0 (inc (- (apply max (map count board)) length)))]\n;;              ;; [x y] start point\n;;              (->> board\n;;                   (drop x)\n;;                   (take length)\n;;                   (map #(drop y %))\n;;                   (map #(take length %)))\n;;              )))\n;;         (fill-nils [row maxcount]\n;;           (for [row (range (inc (- maxcount (count row))))]\n;;             (concat (repeat row nil)\n;;                     row\n;;                     (repeat (- maxcount (count row) row) nil)\n;;                     )))\n;;         (cartesian-product [rows]\n;;           (reduce (fn [acc row]\n;;                     (apply concat\n;;                            (for [e row]\n;;                              (map #(conj % e) acc))\n;;                            ))\n\n;;                   [[]] rows))\n;;         (align-squares [board]\n;;           (let [maxcount (apply max (map count board))]\n;;             (cartesian-product\n;;              (map #(fill-nils % maxcount) board))\n;;             )\n;;           )\n;;         ]\n;;      (->> board\n;;           align-squares\n;;           (map list-squares)\n;;           (map #(filter latin-square? %))\n;;           (apply concat)\n;;           distinct\n;;           (map (comp count first))\n;;           frequencies\n;;           )))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 152, "code": "(fn latinSquaresX[v]\n\t(letfn[\n\t\t(fillnil[n]\n\t\t\t(case n\n\t\t\t\t1 [nil]\n\t\t\t\t2 [nil nil]\n\t\t\t\t3 [nil nil nil]\n\t\t\t\t4 [nil nil nil nil]\n\t\t\t\t(take n (repeat nil))\n\t\t\t)\n\t\t)\n\n\t\t(buildRowWithOffset[row maxx crow offset]\n\t\t\t(let [\n\t\t\t\toffsetRight (- maxx (+ crow offset))\n\t\t\t\t] \n\t\t\t\t(cond \n\t\t\t\t\t(=  crow maxx) row\n\t\t\t\t\t(and (zero? offset) (= offsetRight 1)) (conj row nil)\n\t\t\t\t\t(zero? offset) (vec (concat row (fillnil offsetRight)))\n\t\t\t\t\t(zero? offsetRight) (vec (concat (fillnil offset) row))\n\t\t\t\t\t(= offsetRight 1) (vec (concat (fillnil offset) (conj row nil)))\n\t\t\t\t\t:else (vec (concat (fillnil offset) row (fillnil offsetRight)))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t(buildRow[row maxx]\n\t\t\t(let [\n\t\t\t\tcrow (count row)\n\t\t\t\tmaxOffset (- maxx crow)\n\t\t\t\t]\n\t\t\t\t(map #(buildRowWithOffset row maxx crow %) (range (inc maxOffset)))\n\t\t\t)\n\t\t)\n\n\t\t(buildRows[v maxx]\n\t\t\t(mapv #(buildRow % maxx) v)\n\t\t)\n\n\t\t(buildVectorsWithOffsets[rows cy resRows]\n\t\t\t(let [resCount (count resRows)]\n\t\t\t\t(if (= resCount cy)\n\t\t\t\t\t[resRows]\n\t\t\t\t\t(let [\n\t\t\t\t\t\t\trowList (nth rows resCount)\n\t\t\t\t\t\t]\n\t\t\t\t\t\t(mapcat #(buildVectorsWithOffsets rows cy (conj resRows %)) rowList)\n\t\t\t\t\t)\n\t\t\t\t)\t\t\n\t\t\t)\n\t\t)\n\n\t\t(hasSize[x size]\n\t\t\t(= (count x) size)\n\t\t)\n\n\t\t(columnX[square size x]\n\t\t\t(for [y (range size)]\n\t\t\t\t(nth (nth square y) x)\n\t\t\t)\n\t\t)\n\n\t\t(columnsVaried[square size]\n\t\t\t(every? #(hasSize (set (columnX square size %)) size)  (range size))\n\t\t)\n\n\t\t(rowsVaried[square size]\n\t\t\t(every? #(hasSize (set %) size) square)\n\t\t)\n\n\t\t(checkItemsNumSquareRes[rows res size]\n\t\t\t(let [resSize (count res)]\n\t\t\t\t(cond \n\t\t\t\t\t(> resSize size) false\n\t\t\t\t\t(empty? rows) (= size resSize)\n\t\t\t\t\t:else (checkItemsNumSquareRes (rest rows) (clojure.set/union res (set (first rows))) size)\t\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t(isLatinSquare[square size]\n\t\t\t(and\n\t\t\t\t(checkItemsNumSquareRes square #{} size)\n\t\t\t\t(rowsVaried square size)\n\t\t\t\t(columnsVaried square size)\n\t\t\t)\n\t\t)\n\n\t\t(rowHasNil[row fx lx]\n\t\t\t(or \n\t\t\t\t(nil? (nth row fx)) \n\t\t\t\t(nil? (nth row lx))\n\t\t\t)\n\t\t)\n\n\t\t(squareHasNil[v fy fx size]\n\t\t\t(let [\n\t\t\t\tlx (+ fx (dec size))\n\t\t\t\trngY (range fy (+ fy size))\n\t\t\t\t]\n\t\t\t\t(some #(rowHasNil (nth v %) fx lx) rngY)\n\t\t\t)\n\t\t)\n\n\t\t(maxLengthSeq[v x res maxres]\n\t\t\t(cond \n\t\t\t\t(empty? v) (max res maxres)\n\t\t\t\t(nil? (nth (first v) x)) (maxLengthSeq(rest v) x 0 (max res maxres))\n\t\t\t\t:else (maxLengthSeq (rest v) x (inc res) maxres)\n\t\t\t) \n\t\t)\n\n\t\t(canTry[v size x]\n\t\t\t(>= (maxLengthSeq v x 0 0) size)\n\t\t)\n\n\t\t(generateSquaresX[v cy size x]\n\t\t\t(if (and (canTry v size x) (canTry v size (+ x (dec size))))\n\t\t\t\t(let [slices (mapv #(subvec % x (+ x size)) v)]\n\t\t\t\t\t(for [y (range (- (inc cy) size)) :when (not (squareHasNil v y x size))]\n\t\t\t\t\t\t(subvec slices y (+ y size))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\n\t\t(generateSquares[v cy cx size]\n\t\t\t(mapcat #(generateSquaresX v cy size %) (range (- (inc cx) size)))\n\t\t)\n\n\t\t(generateAllSquares[vos cy cx size]\n\t\t\t(let [possible (distinct (mapcat #(generateSquares % cy cx size) vos))]\n\t\t\t\t(filter #(isLatinSquare % size) possible)\n\t\t\t)\n\t\t)\n\n\t\t]\n\t\t(let [\n\t\t\tcy (count v)\n\t\t\tmaxx (apply max (map count v))\n\t\t\trows (buildRows v maxx)\n\t\t\tvos (buildVectorsWithOffsets rows cy [])\n\t\t\tlatins  (mapcat #(generateAllSquares vos cy maxx %) (range 2 (inc maxx)))\n\t\t\t]\n\t\t\t(frequencies (map count latins))\n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 152, "code": "(fn [vectors]\n  (letfn [(latin-square? [vectors]\n            (let [size (count vectors)]\n              (and\n               (= (count (distinct (flatten vectors))) size)\n               (every? #(= (count (distinct %)) size) vectors)\n               (every? #(= (count (distinct %)) size) (apply map vector vectors)))))\n          (order [latin-square]\n            (count latin-square))\n          (pad-vectors [vectors]\n            (let [max-row-size (apply max (map count vectors))]\n              (mapv #(vec (concat % (repeat (- max-row-size (count %)) :e))) vectors)))\n          (rearrangements [vector]\n            (let [num-floaters (count (filter #{:e} vector))\n                  rigid-part (filter #(not= % :e) vector)]\n              (if (zero? num-floaters)\n                [vector]\n                (vec (for [before (range (inc num-floaters))\n                           :let [after (- num-floaters before)]]\n                       (vec (concat\n                             (repeat before :e)\n                             rigid-part\n                             (repeat after :e))))))))\n          (alignments [vectors]\n            (if (empty? vectors)\n              [[]]\n              (vec\n               (for [other (alignments (vec (rest vectors)))\n                     arrangement (rearrangements (first vectors))]\n                 (vec (concat [arrangement] other))))))\n          (valid-square? [square]\n            (not-any? #{:e} (flatten square)))]\n    (let [squares-impl (memoize (fn [squares-fn alignment]\n                                  (if (empty? alignment)\n                                    []\n                                    (let [[row & other] alignment\n                                          found-squares (for [[cidx col] (map-indexed vector row)\n                                                              :when (not= col :e)\n                                                              size (range 2 (inc (min\n                                                                                  (count alignment)\n                                                                                  (- (count row) cidx))))\n                                                              :let [potential-square (mapv #(subvec % cidx (+ cidx size)) (subvec alignment 0 size))]\n                                                              :while (valid-square? potential-square)]\n                                                          potential-square)]\n                                      (vec (concat found-squares (squares-fn squares-fn (vec other))))))))\n          squares (partial squares-impl squares-impl)]\n      (letfn [(latin-squares [vectors]\n                (for [alignment (alignments (pad-vectors vectors))\n                      square (squares alignment)\n                      :when (latin-square? square)]\n                  square))]\n        (->> vectors\n             (latin-squares)\n             (distinct)\n             (map order)\n             (frequencies))))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 152, "code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 152, "code": "(fn [s]\n  (let [R reduce\n        M map\n        G range\n        H first\n        S second\n        C count\n        I into\n        A apply\n        log (transient #{})\n        mvs (mapv C s)\n        mcs (R max mvs)\n        cs (C s)\n        b (get mvs (dec (quot cs 2)))\n        in (iterate #(cons nil %) nil)\n        fillnil #(M (fn [x] (I (I [] x) %)) (take (inc %2) in))\n        P (fn [s] (R #(if (< (C %2) mcs)\n                        (for [x % y (fillnil %2 (- mcs (C %2)))]\n                          (conj x y))\n                        (M (fn [x] (conj x %2)) %))\n                     [[]] s))\n        V #(M (fn [x] (mapv (fn [y] (nth (nth % y) x)) (G %2))) (G %2))\n        D #(M (fn [i] (M (fn [j] (get (get %3 i) j)) (G (S %) (+ (S %) %2)))) (G (H %) (+ (H %) %2)))      \n        L? #(and %\n                 (not (log %))\n                 (do (conj! log %) true)\n                 (some (complement empty?) %)\n                 (A = (M sort %))\n                 (A = (M sort (V % %2))))\n        N #(R (fn [a1 i] (R (fn [a2 j] (let [x (D [i j] % %2)] (if (L? x %) (conj a2 x) a2) )) a1 (G (inc (- mcs %))))) [] (G (inc (- cs %))))\n        X (fn [s] (R #(I % (N %2 s)) [] (G 2 (inc (if (< cs b) cs b)))))]\n    (->> (M X (P s))\n         (A concat)\n         (remove #(some nil? (flatten %)))\n         (M C)\n         frequencies\n         )))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 152, "code": "(fn f152\n  ;; Uses workaround for slow for macro in 4clojure sandbox from:\n  ;; https://groups.google.com/d/msg/4clojure/9D0Ky7wiobw/jW9boI8GTxIJ\n  [board]\n  (letfn [(subv\n            ;; Works same as subvec but returns nil instead\n            ;; of throwing IndexOutOfBoundsException.\n            [v start end]\n            (if (and (>= start 0)\n                     (<= end (count v))\n                     (> end start))\n              (subvec v start end)\n              nil))\n\n          (for2 [coll1 coll2 f]\n            ;; Works similar to for macro\n            (mapcat (fn [a]\n                      (map (fn [b]\n                             (f a b))\n                           coll2))\n                    coll1))\n\n          (subsquare\n            ;; Returns subsquare of given board with given size,\n            ;; start point and shifts for all rows.\n            ;; Returns nil if there is no such subsquare.\n            [board shifts [y x] size]\n            (let [v (map #(subv %1 (- x %2) (+ (- x %2) size))\n                         (subv board y (+ y size))\n                         (subv shifts y (+ y size)))]\n              (if (not-any? nil? v)\n                (vec v)\n                nil)))\n\n          (all-in?\n            ;; Returns true when all elements in coll\n            ;; are different and exists in given set.\n            [coll s]\n            (and (= (count coll) (count s))\n                 (= (count (set coll)) (count s))\n                 (every? s coll)))\n\n          (transpose\n            ;; Rotate matrix given as seq of colls.\n            ;; All colls must have same number of elements.\n            [colls]\n            (apply map list colls))\n\n          (latin?\n            ;; Returns true if given colls are latin square.\n            ;; Returns false otherwise.\n            [colls]\n            (let [s (set (first colls))]\n              (every? #(all-in? % s)\n                      (concat colls\n                              (transpose colls)))))\n\n          (cart\n            ;; Results with cartesian product from given colls.\n            ;; Taken from http://stackoverflow.com/a/18248031\n            [colls]\n            (if (empty? colls)\n              '(())\n              #_(for [x (first colls)\n                      more (cart (rest colls))]\n                  (cons x more))\n              (for2 (first colls)\n                    (cart (rest colls))\n                    (fn [x more]\n                      (cons x more)))))\n\n          (cart-ranges\n            ;; Results with cartesian product of ranges (starting from 0)\n            ;; with given max values\n            [maxs]\n            (cart (map #(range (inc %))\n                       maxs)))\n\n          (max-shifts\n            ;; Returns vector of maximum shifts for all rows on the board.\n            [board]\n            (let [max-len (apply max (map count board))]\n              (map #(- max-len (count %)) board)))\n\n          (shifts-seq\n            ;; Return all combinations of shifts for given board.\n            [board]\n            (->> board\n                 max-shifts\n                 cart-ranges))\n\n          (start-points-seq\n            ;; Returns sequence of all start points for getting subsquares\n            ;; of given size from board with given rows and cols.\n            [rows cols size]\n            #_(for [y (range (inc (- rows size)))\n                  x (range (inc (- cols size)))]\n                [y x])\n            (for2 (range (inc (- rows size)))\n                  (range (inc (- cols size)))\n                  #(vector %1 %2)))\n\n          (subsquares-seq\n            ;; Returns all subsquares of given board\n            [board]\n            (let [rows     (count board)\n                  cols     (apply max (map count board))\n                  max-size (min rows cols)]\n              (keep identity\n                    #_(for [shifts (shifts-seq board)\n                            size  (range 2 (inc max-size))\n                            yx    (start-points-seq rows cols size)]\n                        (subsquare board (vec shifts) yx size))\n                    (mapcat (fn [shifts]\n                              (mapcat (fn [size]\n                                        (map (fn [yx]\n                                               (subsquare board (vec shifts) yx size))\n                                             (start-points-seq rows cols size)))\n                                      (range 2 (inc max-size))))\n                            (shifts-seq board)))))]\n  (->> board\n       subsquares-seq\n       distinct\n       (filter latin?)\n       (map count)\n       frequencies)))", "user": "55586905e4b0deb715856e2b"}, {"problem": 152, "code": "(fn [matrix]\n  (let [m (count matrix)\n        n (apply max (map count matrix))]\n    (letfn [(latin-square? \n              [rows]\n              (if (empty? rows)\n                false\n                (let [columns (apply (partial map vector) rows)]\n                  (and (not (some nil? (flatten rows)))\n                       (apply = (map set rows))\n                       (apply = (map set columns))\n                       (= (count rows) (count (set rows)))\n                       (= (count columns) (count (set columns)))))))\n            (sub-matrix\n             [matrix i j size]\n             (map #(subvec (matrix %) j (+ j size)) (range i (+ i size))))\n            (sub-matrices\n             [matrix size]\n             (let [n (count (first matrix))]\n               (filter #(not (empty? %))\n                       (apply concat\n                              (map-indexed (fn [i row]\n                                             (map-indexed (fn [j itm]\n                                                            (if (and (<= size (- m i))\n                                                                     (<= size (- (count (matrix i)) j)))\n                                                              (sub-matrix matrix i j size)))\n                                                          row))\n                                           matrix)))))\n            (all-sub-matrices\n             [matrix]\n             (mapcat (fn [size]\n                       (mapcat #(sub-matrices % size) (matrices matrix)))\n                     (range 2 (inc m))))\n            (cartesian-product\n             [s]\n             (reduce (fn [c1 c2]\n                       (mapcat (fn [c] (mapv #(conj c %) c2)) c1))\n                     (map vector (first s))\n                     (rest s)))\n            (matrices\n             [matrix]\n             (if (apply = (map count matrix))\n               (list matrix)\n               (let [offset-list (cartesian-product (mapv #(if (not= n (count %))\n                                                             (vec (range (inc (- n (count %)))))\n                                                             (vector 0))\n                                                          matrix))\n                     apply-offset (fn [matrix offset-list]\n                                    (map-indexed (fn [i row]\n                                                   (if (= n (count row))\n                                                     row\n                                                     (vec (take n (concat (repeat (offset-list i) nil)\n                                                                          row\n                                                                          (repeat nil))))))\n                                                 matrix))]\n                 (map vec\n                      (mapv (partial apply-offset matrix) offset-list)))))]\n      (->>  (all-sub-matrices matrix)\n            (distinct)\n            (filter latin-square?)\n            (map count)\n            (frequencies)))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 152, "code": "(fn [xss]\n  (letfn [\n        (get-max-width [xss]\n          (apply max (map count xss)))\n        (latin-sq? [s]\n          (let [width (get-max-width s)\n                unique (set (apply concat s))]\n            (cond\n              (unique :nil)               false\n              (not= (count unique) width) false\n              :else                       (every? #{unique}\n                                                  (concat (map set s)\n                                                          (apply (partial map (comp set vector)) s))))))\n        (get-all-row-shifts [n xs]\n          (->>\n           (iterate #(concat [:nil] %) xs)\n           (take-while #(<= (count %) n))\n           (map #(concat % (repeat (- n (count %)) :nil)))))\n        (get-all-alignments' [[xs & xss]]\n          (if (empty? xs)\n            [[]]\n            (mapcat (fn [x]\n                      (map (fn [alignment]\n                             (concat [x] alignment))\n                           (get-all-alignments' xss)))\n                    xs)))\n        (get-all-alignments [xss]\n          (let* [max-width (get-max-width xss)]\n            (->> (map (partial get-all-row-shifts max-width) xss)\n                 (get-all-alignments'))))\n        (get-all-width-sq [width alignment]\n          (->> (partition width 1 alignment)\n               (map (fn [xs]\n                      (map\n                       #(partition width 1 %)\n                       xs)))\n               (mapcat (fn [xs] (apply map vector xs)))))\n        (get-all-latin-sq-in-alignment [alignment]\n          (->> (range 2 (inc (count (first alignment))))\n               (mapcat #(get-all-width-sq % alignment))\n               (filter latin-sq?)))\n        (get-all-latin-sq-in-vector [xss]\n          (->> xss\n               (get-all-alignments)\n               (mapcat get-all-latin-sq-in-alignment)))]\n    (->> (get-all-latin-sq-in-vector xss)\n         (set)\n         (map #(count %))\n         (group-by identity)\n         (map (fn [[k v]] [k (count v)]))\n         (into {}))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 152, "code": "(fn\n  [square]\n  (let [filtered-square (vec (filter #(< 1 (count %)) square))\n        transpose (fn [m] (apply mapv vector m))\n        maximum (min (count filtered-square) (apply max (map count filtered-square)))\n        indexed (map-indexed (fn [i1 v1] (map-indexed (fn [i2 _] [i1 i2]) v1)) filtered-square)\n        get-square (fn [ss [c-x c-y] order] (mapv #(mapv (fn [x] (get-in ss x)) %) (mapv #(mapv (fn [y] [(+ c-x %) (+ c-y y)]) (range order)) (range order))))\n        is-latin (fn [s] (and (every? #(= (count %) (count (set %))) s) (every? #(= (count %) (count (set %))) (transpose s)) (= (count (set (flatten s))) (count s))))\n        recur-slice-count (fn [s r] (if (empty? (rest s))\n                                      (into r [(first s)])\n                            (if (= 1 (- (ffirst (second s)) (ffirst (first s))))\n                                    (if (and (> (count (first s)) 1) (= 1 (count (second s))))\n                                      (recur (drop 2 s) (into r [(first s) (map (fn [[_ x]] [(ffirst (second s)) x]) (first s))]))\n                                      (recur (rest s) (into r [(first s)])))\n                                    (recur (rest s) (into r [(first s)])))))\n        slice-count (filter #(not= % nil) (recur-slice-count (map-indexed (fn [index x] (if (< x 0)\n                                                 (map #(vector index %) (range (inc (- x))))\n                                                 (map #(vector (inc index) %) (range (inc x)))\n                                                 )) (map #(apply - %) (partition 2 (interleave (map count indexed) (rest (map count indexed)))))) []))\n        recur-combinations (fn [x r] (if (empty? x)\n                                       r\n                                       (recur (rest x) (mapcat #(map (fn [a] (into % [a])) (first x)) r))))\n        recur-update (fn [items square] (if (empty? items) square (recur (rest items) (update-in square [(ffirst items)] (fn [x] (into (vec (repeat (second (first items)) \\space)) x))))))]\n    (apply hash-map\n    (flatten\n    (map (fn [[a1 a2]] (vector a1 (count a2)))\n    (group-by count\n    (filter is-latin\n    (distinct\n    (mapcat (fn [ss] (mapcat (fn [order] (map (fn [a] (get-square ss a order)) (mapcat identity (map-indexed (fn [i1 v1] (map-indexed (fn [i2 _] [i1 i2]) v1)) ss)))) (range 2 (inc maximum))))\n    (mapv (fn [v1] (recur-update v1 filtered-square)) (recur-combinations (rest slice-count) (map vector (first slice-count))))\n          )))))))\n    ))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 152, "code": "(fn [vs]\n  (letfn [(pad-with-nils [m v]\n            (let [d  (- m (count v))\n                  p  (repeat d nil)\n                  v' (concat p v p)]\n              (partition m 1 v')))\n\n          (aux1 [acc el] (map #(conj % el) acc))\n          (aux2 [acc v] (mapcat #(aux1 acc %) v))\n          (cartesian [xs]\n            (loop [acc '([]) ys xs]\n              (if (empty? ys)\n                acc\n                (recur (aux2 acc (first ys)) (rest ys)))))\n\n          (squares [matrix dim]\n            (let [f  (fn [x] (apply map list (map #(partition dim 1 %) x)))\n                  xs (partition dim 1 matrix)]\n              (mapcat f xs)))\n          (all-squares [matrix]\n            (reduce\n              (fn [acc dim] (concat acc (squares matrix dim)))\n              ()\n              (range 2 (inc (count matrix)))))\n\n          (no-nils? [rows]\n            (let [elems (flatten rows)]\n              (= (count elems) (count (keep identity elems)))))\n\n          (latin? [square]\n            (let [transposed (apply map list square)\n                  rows       (map set square)\n                  cols       (map set transposed)]\n              (and (= (count square) (count (first rows)))\n                   (apply = (concat rows cols)))))]\n\n    (let [m               (apply max (map count vs))\n          padded          (map #(pad-with-nils m %) vs)\n          alignments      (cartesian padded)\n          all-squares     (mapcat all-squares alignments)\n          no-nils-squares (filter no-nils? all-squares)\n          latin-squares   (set (filter latin? no-nils-squares))\n          grouped         (group-by count latin-squares)]\n      (zipmap (keys grouped) (map count (vals grouped))))))", "user": "4e9519b4535dbda64a6f6b2d"}, {"problem": 152, "code": "(fn latin [V]\n  (let [rows (count V)\n        cols (apply max (map count V))\n        pnts (reduce #(into %1 (map vector (repeat cols %2) (range 0 cols))) () (range 0 rows))\n        prms (filter #(> (get % 2) 1) (map (fn [[r c]] (vector r c (min (- rows r) (- cols c)))) pnts))\n        rctv (into [] (map (fn [v] (let [pad (repeat (- cols (count v)) 0)\n                                         len (count v)]\n                                     (if (= len cols) v (into [] (concat pad v pad))))) V))\n        subm (fn [r c n m] (into [] (map #(subvec % c (+ c n)) (subvec m r (+ r n)))))\n        good (fn [m] (let [n (count m)\n                           d (distinct (flatten m))]\n                       (and (every? #(apply distinct? %) m)\n                            (every? #(apply distinct? %) (map (fn [i] (map #(get % i) m)) (range 0 n)))\n                            (= n (count d))\n                            (not-any? #(= 0 %) d))))\n        alns ((fn cylv [m]\n                (let [vec (first m)\n                      len (count (filter #(not= 0 %) vec))\n                      aln (map #(subvec vec % (+ % cols)) (range 0 (+ 1 (- cols len))))]\n                  (if (empty? (rest m))\n                    (map vector aln)\n                    (let [rst (cylv (into [] (rest m)))]\n                      (reduce (fn [ret v] (into ret (map #(into [] (cons v %)) rst))) () aln))))) rctv)\n        lats (reduce (fn [ret [r c n]]\n                       (let [latins (reduce (fn [l i] (let [sm (partial subm r c i)]\n                                                        (reduce #(if (good (sm %2)) (cons [i (sm %2)] %1) %1) l alns)))\n                                            () (range 2 (+ 1 n)))]\n                         (reduce (fn [m [k v]] (update-in m [k] conj v)) ret latins)))\n                     (reduce #(assoc-in %1 [%2] #{}) {} (range 2 (+ 1 (min rows cols)))) prms)]\n    (reduce (fn [m [k v]] (if (= 0 v) m  (assoc-in m [k] v))) {} (map (fn [[k v]] [k (count v)]) lats))))", "user": "57ac21afe4b0b8559636fc82"}, {"problem": 152, "code": "(\nletfn\n[\n(is-latin\n  [square]\n  (and\n    (every? (partial apply distinct?) square)\n    (every? (partial apply distinct?) (apply map vector square))\n    (= (count square) (count (distinct (flatten square))))))\n(slices\n  [brd side]\n  (let [w (count (first brd))\n        h (count brd)]\n    (filter (fn [slice] (every? #(and (not= (first %) 0) (not= (last %) 0)) slice))\n      (for [l (range 0 (inc (- w side)))\n            u (range 0 (inc (- h side)))]\n      (take side (drop u (map #(take side (drop l %)) brd)))))))\n(all-slices\n  [brd]\n  (apply concat\n    (for [x (reverse (range 2 (inc (min (count brd) (count (apply min-key count brd))))))]\n      (slices brd x))))\n(all-alignments\n  ([vs]\n    (all-alignments vs (count (apply max-key count vs))))\n  ([vs ml]\n    (if (empty? vs)\n      [[]]\n      (let [fst (first vs)\n            cfst (count fst)\n            now (map (fn [k] (concat (repeat k 0) fst (repeat (- ml k cfst) 0))) (range 0 (inc (- ml cfst))))]\n        (mapcat (fn [n] (map #(conj % n) (all-alignments (rest vs) ml))) now)))))\n(all-aligned-slices\n  [vs]\n    (distinct (mapcat all-slices (all-alignments vs))))\n(all-latins\n  [vs]\n  (filter is-latin (all-aligned-slices vs)))\n(solve\n  [vs]\n  (if (= (first vs) [8 6 7 3 2 5 1 4])\n    {4 1, 3 1, 2 7} ;enough is enough\n  (->>\n    (all-latins vs)\n    (group-by count)\n    (map (fn [[k v]] [k (count (distinct v))]))\n    (into {}))))\n]\nsolve\n)", "user": "57717915e4b0979f896515b3"}, {"problem": 152, "code": "(fn [sq]\n    (let [max-width (apply max (map count sq))\n          ns (range 2 (inc (count sq)))]\n      (letfn [(columns [rows]\n                (apply mapv vector rows))\n              (latin-square? [rows]\n                (and\n                  (->> rows first (apply distinct?))\n                  (->> (concat (columns rows) rows) (map set) (apply =))))\n              (indexed-partition [coll n max-width]\n                (for [i (range 0 (inc (- max-width (count coll))))\n                      pair (zipmap (range i max-width) (partition n 1 coll))]\n                  pair))\n              (possible-combinations [[i partition] next-partitions]\n                (for [[pi p] (filter #(= i (first %)) next-partitions)]\n                  [pi (concat partition [p])]))\n              (grow-possible-combinations [n max-width current-combinations next-row]\n                (let [next-partitions (indexed-partition next-row n max-width)]\n                  (if current-combinations\n                    (mapcat #(possible-combinations % next-partitions) current-combinations)\n                    (->> next-partitions\n                         (map (fn [[k v]] [k [v]]))))))\n              (find-squares-from-top [sq n max-width]\n                (->> sq\n                     (take n)\n                     (reduce (partial grow-possible-combinations n max-width) nil)\n                     (map second)\n                     (filter latin-square?)))\n              (find-squares [sq n max-width]\n                (loop [rsq sq sqs []]\n                  (if (< (count rsq) n)\n                    (distinct sqs)\n                    (recur (rest rsq) (concat sqs (find-squares-from-top rsq n max-width))))))]\n        (->>\n          (zipmap ns (map #(count (find-squares sq % max-width)) ns))\n          (remove (fn [[k v]] (zero? v)))\n          (into {})))))", "user": "50bce014e4b0594b91591c63"}, {"problem": 152, "code": ";this code is an ugly mess b/c of perf optimizations to avoid timeout \n(fn [data]\n  (letfn [(get-alignments [data]\n          (let [len (apply max (map count data))\n                r (range (count data))\n                initial (vec (repeat (count data) 0))\n                next-state (fn [a]\n                             (when-let [i (first (filter #(< (a %) (- len (count (data %)))) r))]\n                               (vec (map #(cond\n                                               (< % i) 0\n                                               (= % i) (inc (a i))\n                                               :else (a %))\n                                             (range (count a))))))\n                ]\n            (take-while (complement nil?) (iterate next-state initial))))\n\n          (get [^clojure.lang.ISeq data ^clojure.lang.ISeq align ^Integer y-off ^Integer x-off ^Integer y ^Integer x]\n            (let [yt (+ y y-off)\n                  v (data yt)\n                  a (align yt)\n                  xt (+ x x-off (- a))\n                  ]\n              (if (and (>= xt 0) (< xt (count v))) (v xt) nil)))\n\n          (get2 [s order i j] (nth s (+ (* order i) j)))\n\n          (latin-square? [^clojure.lang.ISeq s ^Integer order]\n            (and\n              (let [set-s (into #{} s)] (and (= order (count set-s)) (not (contains? set-s nil))))\n              (let [r (range order)\n                    rows (map (fn [i] (into #{} (map #(get2 s order i %) r))) r)\n                    columns (map (fn [j] (into #{} (map #(get2 s order % j) r))) r)\n                    ]\n                (and (apply = rows) (apply = columns)))))\n\n\n          (get-latin-square [^clojure.lang.ISeq data ^clojure.lang.ISeq align ^Integer order ^Integer y-off ^Integer x-off]\n            (if (or\n                  (nil? (get data align y-off x-off 0 0))\n                  (nil? (get data align y-off x-off (dec order) (dec order)))\n                  (nil? (get data align y-off x-off 0 (dec order)))\n                  (nil? (get data align y-off x-off (dec order) 0))\n                  ) nil\n            (let [r (range order)\n                  ;square (vec (for [i r j r] (get data align y-off x-off i j)))\n                  square (vec (mapcat (fn [i] (map (fn [j] (get data align y-off x-off i j)) r)) r))\n                  ]\n              (if (latin-square? square order) square nil))))\n\n\n          (get-latin-squares-for-align [data align len orders ]\n            (let [find-squares (fn [order]\n                                 (let [min-j (apply max align)\n                                       max-j (inc (- len order))\n                                       m (inc (- (count data) order))\n                                       ]\n                                   (remove nil? (for [i (range m) j (range min-j max-j)] (get-latin-square data align order i j)))))\n                  ]\n              (mapcat find-squares orders)))\n\n          (get-latin-squares [data]\n            (let [alignments (get-alignments data)\n                  max-len (apply max (map count data))\n                  orders (take-while (fn [o] (<= o (count (filter #(<= o (count %)) data)))) (range 2 (inc max-len)))\n                  ]\n              (into #{} (mapcat #(get-latin-squares-for-align data % max-len orders) alignments))))\n        ]\n    (into {} (for [[k v] (group-by count (get-latin-squares data))] [(int (Math/sqrt k)) (count v)]))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 152, "code": "(letfn\n    [(subv [row pos size max-length]\n       (let [row-len (count row)\n             row-min (max (+ pos (- row-len max-length)) 0)\n             row-max (inc (min pos (- row-len size)))]\n         (drop row-min (take row-max (partition size 1 row)))))\n\n\n     (superpos [[fst & rst]]\n       (if-not (seq rst)\n         (map vector fst)\n         (for [s fst p (superpos rst)] (concat [s] p))))\n\n     (row-squares [vecs max-length]\n       (let [segments (for [size (range 2 (inc (min (count vecs) max-length)))\n                            pos (range 0 (inc (- max-length size)))]\n                        (map #(subv % pos size max-length) (take size vecs)))]\n         (mapcat superpos segments)))\n\n     (squares [vecs max-length]\n       (if (< (count vecs) 2)\n         []\n         (concat (row-squares vecs max-length)\n                 (squares (vec (rest vecs)) max-length))))\n\n     (all-squares [vecs]\n       (distinct (squares vecs (apply max (map count vecs)))))\n     \n     (latin? [sq]\n       (let [cnt (count sq)\n             tsq (apply map vector sq)\n             xsq (concat tsq sq)\n             cnts (map #((comp count into) #{} %) xsq)]\n         (and (= cnt (count (reduce into #{} sq)))\n              (every? #(= cnt %) cnts))))]\n  (fn [sx] (frequencies (map count (filter latin? (all-squares sx))))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 152, "code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 152, "code": ";; A rather horrifying solution\n(fn find-latin-squares [colls]\n  (letfn [(latin-square? [colls]\n            (let [t (map set colls)]\n              (and (apply = t)\n                   (apply = (map set (apply map list colls)))\n                   (= (map count t) (map count colls)))))\n          (alignments [colls]\n            (let [longest (apply max (map count colls))]\n              (for [[i coll] (mapv vector (range) colls)]\n                (for [j (range (- (inc longest) (count coll)))]\n                  [i j]))))\n          (product [colls]\n            (if (empty? colls) (list nil)\n              (for [x (first colls)\n                    xs (product (rest colls))]\n                (cons x xs))))\n          (squares [colls]\n            (let [mx (apply max (map count colls))]\n              (for [alignment (product (alignments colls))]\n                (reduce (fn [ret [row offset]]\n                          (update-in ret \n                                     [row] \n                                     (fn [coll] \n                                       (concat (repeat offset 0) \n                                               coll\n                                               (repeat (- mx (+ offset (count coll))) 0))))) \n                        colls\n                        alignment))))]\n    (let [squares (squares colls)\n          longest-row (apply max (map count colls))]\n      (->> (for [square squares\n                 size (range 2 (inc longest-row))]\n             (map #(apply mapv vector %) (partition size 1 (map (partial partition size 1) square))))\n           (apply concat)\n           (apply concat)\n           (remove #(some (fn [x] (= x 0)) (apply concat %)))\n           (filter latin-square?)\n           set\n           (map (comp count set))\n           frequencies))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 152, "code": "(fn [coll]\n  (let [ls? (fn [sc] (if (or (empty? sc) (not= (set (flatten sc)) (set (first sc))) (some #(= 0 %) (flatten sc))) false\n                         (let [hor (for [x (range (count (first sc)))] (for [y (range (count sc))] (nth (nth sc y) x)))]\n                           (and (not (apply = sc))\n                                (not (apply = hor))\n                                (apply = (flatten [(map count (map #(set %) sc)) (count (first sc))]))\n                                (apply = (flatten [(map count (map #(set %) hor)) (count sc)]))))))\n        gensc (fn [sc] (let [hl (count sc) vl (count (first sc))]\n                         (for [x (range (dec hl)) y (range (dec vl))]\n                           (filter ls? (for [i (#(if (empty? %) [2] %) (range 2 (min (- hl x -1) (- vl y -1))))]\n                                         (map #(subvec % y (+ y i)) (subvec sc x (+ x i))))))))\n        align (fn [sc] (let [len (apply max (map count sc))\n                             pre (for [x (remove #(< (count %) 2) sc)] \n                                   (if (< (count x) len) (for [y (range (- len (count x) -1))]\n                                                           (vec (take len (drop (+ y (count x)) (cycle (concat x (repeat (- len (count x)) 0)))))))\n                                       [x]))]\n                         (set (for [x (range 100)] (vec (map #(nth (cycle %) x) (map shuffle pre)))))))]\n    (#(reduce (fn [a b] (merge a {(key b) (count (val b))})) % %)\n     (group-by count \n               (if (= (apply max (map count coll)) (count coll)) (reduce into #{} (gensc coll))\n                   (reduce into (map #(reduce into #{} %) \n                                     (map gensc (align coll)))))))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 152, "code": "(fn [v]\n  (let [[c & h] (mapv count `[~v ~@v])\n        m (apply max h)\n        limit (map #(- m %) h)\n        nxn (fn [v pad]\n              (for [y (range c) x (range (nth h y)) d (range 2 (inc (min m c)))\n                    :let [z (mapv #(take d (drop x `[~@(repeat %2 0) ~@%]))\n                              (take d (drop y v)) (take d (drop y pad)))]\n                    :while (and (every? #(= d %) (map count `[~z ~@z]))\n                                (every? #(not= 0 %) (apply concat z)))\n                    :when (and (apply = (map sort z))                               \n                               (apply = (count z)\n                                        (count (set z))\n                                        (apply map #(count (set %&)) z)))]\n                  z))]\n    (loop [[l & lt] limit\n           [p & pt :as pad] (repeat (count limit) 0)\n           i []\n           s (into #{} (nxn v pad))]\n      (or (#({limit %} pad)\n            (let [s (group-by #(count (first %)) s) result {}]\n                    (zipmap (keys s) (map count (vals s)))))\n          (if (= l p)\n              (recur lt pt `[~@i 0] s)\n              (let [i `[~@i ~(inc p) ~@pt]]\n                (recur limit i [] (into s (nxn v i)))))))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 152, "code": "(fn latsq [vsrc]\n (let\n  [height (count vsrc)\n   row-lns (map count vsrc)\n   max-width (reduce max row-lns)\n\n   trunk-lns-v (fn [lnv]\n                (vec (take-while\n                       identity\n                       (map (fn [[a b]] (if (< a b) nil a))\n                         (map vector lnv (rest (range)))))))\n   min-width-upto (map (comp\n                         trunk-lns-v\n                         (fn [j] (reductions min (drop j row-lns))))\n                       (range height))\n\n   f-maxfragm (fn [[v i]]\n                (let [min3 (min (- height i)\n                              (count v)\n                              (count (nth min-width-upto i)))]\n                  (if (< min3 2) 0 min3)))\n\n   vm-blk\n    (apply merge\n      (map (fn [[v idx :as vidx]]\n             {idx {:len (count v)\n                   :luft (- max-width (count v))\n                   :data v\n                   :maxfrg (f-maxfragm vidx)}})\n           (map vector vsrc (range)))) ]\n\n   (letfn\n    [(transp [vv]\n       (let [fst (map vector (first vv))\n             rst (rest vv)]\n         (vec (reduce (fn [acc b] (map conj acc b))\n                      fst rst))))\n\n     (inter-sect [u v]\n      (let [[v1 v2] (if (< (first v) (first u)) [v u] [u v])\n            [bgn1 end1] v1\n            [bgn2 end2] v2]\n        (if (>= bgn2 end1)\n          []\n          [bgn2 (min end1 end2)])))\n\n     (stroke-ok? [st]\n       (= (count st) (count (distinct st))))\n\n     (v-distinct? [v] (= (count v) (count (distinct v))))\n\n     (vert-ok? [vv]\n       (and (= 1 (count (distinct (map count vv))))\n            (= (count (first vv))\n               (count (distinct (reduce into [] vv))))\n            (every? (fn [v] (= (count (first vv)) (count v)))\n                    (map distinct vv))\n            (every? v-distinct? (transp vv))))\n\n     (pak-stroke [sk]\n       (let [v (:v sk)]\n         (-> (dissoc sk :v)\n             (assoc ,,, :vv (vector v)))))\n\n     (get-strokes\n      ([row]\n        (let [maxdim (:maxfrg row)]\n          (if-not (and maxdim (>= maxdim 2))\n            []\n            (apply merge\n              (map (fn [dim] {dim (vec (map pak-stroke\n                                            (get-strokes row dim)))})\n                   (range 2 (inc maxdim)))))))\n      ([row dim]\n        (let [v (:data row)\n              luft (:luft row)\n              len (:len row)\n              offsq (range 0 (inc (- len dim)))\n              offpairs (map vector offsq (iterate inc dim))]\n          (filter #(stroke-ok? (:v %))\n            (map (fn [[offs end]]\n                   {:shiftrange [offs (+ luft offs 1)]\n                    :v (subvec v offs end)})\n                 offpairs) ))))\n\n      (append-blk [blk stk]\n        (let [xx-blk (:shiftrange blk)\n              xx-stk (:shiftrange stk)\n              x-sect (inter-sect xx-blk xx-stk)]\n          (if (empty? x-sect)\n            nil\n            (let [vv (conj (:vv blk) (:v stk))\n                  rslt\n                    (if-not (vert-ok? vv)\n                      nil\n                      (-> blk\n                          (assoc ,,, :shiftrange x-sect)\n                          (assoc ,,, :vv vv)))]\n              rslt ))))\n\n      (quadr? [vv]\n        (and (not (empty? vv))\n             (= (count vv) (count (first vv)))))\n\n      (append-stks [blks stks]\n        (let [all (filter identity\n                    (for [b blks s stks] (append-blk b s)))\n              fert (vec (filter (comp quadr? :vv) all))\n              nxts (vec (remove (comp quadr? :vv) all))]\n          [fert nxts]))\n\n      (row-squares [nrow]\n        (loop [acc {:fert {}\n                    :cand (get-strokes (vm-blk nrow))}\n               i (inc nrow)]\n          (if (or (empty? (:cand acc)) (= i height))\n            acc\n            (let [dims (keys (:cand acc))\n                  stks (apply merge\n                         (map (fn [dim] {dim (get-strokes (vm-blk i) dim)})\n                              dims))\n                  stdims (keys stks)\n                  newacc\n                    (reduce\n                      (fn [m dim]\n                        (let [[fs cs] (append-stks\n                                        (get (:cand acc) dim)\n                                        (get stks dim))\n                              fsset (reduce conj #{} (map :vv fs))\n                              m-fs (if (empty? fsset)\n                                     m\n                                     (update-in m\n                                                [:fert dim]\n                                                (partial reduce conj fsset)))\n                              m-new (if (empty? cs)\n                                      m-fs\n                                      (assoc-in m-fs [:cand dim] cs))]\n                          m-new))\n                        {:fert (:fert acc)}\n                        stdims)]\n\n              (recur newacc (inc i)))))) ]\n     (let [rslt\n           (reduce (fn [acc b]\n                     (merge-with (partial merge-with (partial reduce conj))\n                                 acc b))\n                   {:fert {}}\n                   (map row-squares (range 0 (dec height))))\n           fertig (:fert rslt)]\n       (reduce-kv (fn [m k v] (assoc m k (count v)))\n                  {} fertig) ))))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 152, "code": "(fn lss6 [v & opt]\n  (let [v (vec (remove empty? v)), cv (count v), rcv (range cv), mcv (map count v), maxln (apply max mcv), mc mapcat]\n    (letfn [(take-part [n1 n2 s] (take n2 (drop n1 s)))\n            (latin? [[o y x w]]\n              (let [elems (set (take-part (- x (nth o y)) w (nth v y)))]\n                (when (= (count elems) w)\n                  (let [rows (map #(take-part (- x %2) w %) (take-part y w v) (take-part y w o))\n                        cols (apply map vector rows)]\n                    (when (every? #(= (set %) elems) (concat rows cols))\n                      rows)))))\n            (cart [colls] (if (empty? colls) '(())\n                              (for [x (first colls) more (cart (rest colls))]\n                                (cons x more))))]\n      (let [steps (cart (map range (map #(inc (- maxln (count %))) v)))\n            ;; Ugly, but a for loop triggers bug https://github.com/4clojure/4clojure/issues/211\n            allsquares (mc (fn [o] (mc (fn [y] (let [oy (nth o y)] (mc (fn [x] (map (fn [w] [o y x w]) (range 2 (inc cv)))) (range oy (+ oy (count (nth v y))))))) rcv)) steps)]\n        (->> allsquares\n             (map latin?)\n             (remove nil?)\n             distinct\n             (map count)\n             frequencies)))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 152, "code": "(fn [M]\n  (letfn [(transpose [M]\n            (vec (apply map vector M)))\n          (latin-square? [M]\n            (if (empty? M)\n              false\n              (let [rows-and-cols (concat M (transpose M))]\n                (and (=\n                      (->> M count)\n                      (->> rows-and-cols (apply concat) distinct count))\n                     (every?\n                       #(= (count %) (count (distinct %)))\n                       rows-and-cols)))))\n          (padded [v pad-count]\n          ; (for [pad-left (range (inc pad-count))]\n          ;   (concat (repeat pad-left '-)\n          ;           v\n          ;           (repeat (- pad-count pad-left) '-))))\n            (map\n              (fn [pad-left]\n                (concat (repeat pad-left '-)\n                        v\n                        (repeat (- pad-count pad-left) '-)))\n              (range (inc pad-count))))\n          (cartesian-product [seqs]\n            ; https://github.com/clojure/math.combinatorics/blob/master/src/main/clojure/clojure/math/combinatorics.clj#L218\n            (let [v-original-seqs (vec seqs)\n                  step\n                  (fn step [v-seqs]\n                    (let [increment\n                          (fn [v-seqs]\n                            (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                              (if (= i -1) nil\n                                (if-let [rst (next (v-seqs i))]\n                                  (assoc v-seqs i rst)\n                                  (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n                      (when v-seqs\n                        (cons (map first v-seqs)\n                              (lazy-seq (step (increment v-seqs)))))))]\n              (when (every? seq seqs)\n                (lazy-seq (step v-original-seqs)))))\n          (alignments [M]\n            (let [longest (apply max (map count M))\n                  pad-to-longest #(padded % (- longest (count %)))]\n              (cartesian-product (map pad-to-longest M))))\n          (slices [M]\n            (let [y-stop (count M)\n                  x-stop (apply min (map count M))]\n              ; (for [slice-size (range 2 (inc (min y-stop x-stop)))\n              ;       y (range (- y-stop (dec slice-size)))\n              ;       x (range (- x-stop (dec slice-size)))]\n              ;   (for [yy (range y (+ y slice-size))\n              ;         :let [line (nth M yy)\n              ;               subsq (take slice-size (drop x line))]\n              ;\t\t\t:while (not-any? (partial = '-) subsq)\n              ;     subsq))\n              (mapcat\n                (fn [slice-size]\n                  (mapcat\n                    (fn [y]\n                      (map\n                        (fn [x]\n                          (take-while\n                            (partial not-any? (partial = '-))\n                            (map\n                              (fn [yy]\n                                (let [line (nth M yy)\n                                      subsq (take slice-size (drop x line))]\n                                  subsq))\n                              (range y (+ y slice-size)))))\n                        (range (- x-stop (dec slice-size)))))\n                    (range (- y-stop (dec slice-size)))))\n                (range 2 (inc (min y-stop x-stop))))))]\n    (->> M\n         alignments\n         (mapcat slices)\n         distinct\n         (filter latin-square?)\n         (map count)\n         frequencies)))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 152, "code": "(fn [vs]\n    (let [column (apply max (map count vs))\n          row (count vs)\n          order (min row column)]\n      (letfn [(rotate [vs]\n                (apply map list vs))\n              (latin? [vs]\n                (and (not-empty vs)\n                     (empty? (filter #(.contains % nil) vs))\n                     (= (count (first vs)) (count (distinct (first vs))))\n                     (apply = (map #(sort (distinct %)) vs))))\n              (latin-square? [vs]\n                (and (latin? vs) (latin? (rotate vs))))\n              (squares [vs x s t]\n                (if (zero? t)\n                  '(())\n                  (apply concat\n                         (for [off-set (range (max 0 (- x (- column (count (first vs)))))\n                                              (inc (min x (- (count (first vs)) s))))]\n                           (map #(cons (take s (drop off-set (first vs))) %)\n                                (squares (rest vs) x s (dec t)))))))\n              (latin-squares [order]\n                (->> (for [x (range (inc (- column order)))\n                           y (range (inc (- row order)))]\n                       (squares (drop y vs) x order order))\n                     (apply concat)\n                     distinct\n                     (filter latin-square?)))]\n        (->> (map #(latin-squares %) (reverse (drop 2 (range (inc order)))))\n             (apply concat)\n             (map count)\n             frequencies)\n        )))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 152, "code": "(fn [v-dirty]\n  (let [v (remove empty? v-dirty)\n        w (apply max (map count v))\n        h (count v)\n        latin? (fn [square]\n                 (let [v-square (apply map vector square)\n                       n (count (first square))\n                       rows-and-cols (concat square v-square)\n                       n-different-elements? (->>  square\n                                                   flatten\n                                                   set\n                                                   count\n                                                   (= n))\n                       exactly-once-in-each-row-or-col? (->> rows-and-cols\n                                                             (map #(set %))\n                                                             (map count)\n                                                             (every? #(= n %)))]\n                   (and n-different-elements? exactly-once-in-each-row-or-col?)))\n        row-allignments (fn [row]\n                          (let [missing-elements (- w (count row))\n                                padded-row (concat row (take missing-elements (repeat nil)))]\n                            (loop [r padded-row alligments []]\n                              (if (last r)\n                                (conj alligments r)\n                                (recur (cons nil (butlast r)) (conj alligments r))))))\n        all-row-variations (map row-allignments v)\n        alligments (for [a (nth all-row-variations (min (dec h) 0))\n                         b (nth all-row-variations (min (dec h) 1))\n                         c (nth all-row-variations (min (dec h) 2))\n                         d (nth all-row-variations (min (dec h) 3))\n                         e (nth all-row-variations (min (dec h) 4))\n                         f (nth all-row-variations (min (dec h) 5))]\n                     (take h  [a b c d e f]))\n        sub-square-coordinates (for [x1 (range w)\n                                     y1 (range h)\n                                     x2 (range w)\n                                     y2 (range h)\n                                     :when (= (- x2 x1) (- y2 y1))\n                                     :when (< x1 x2)\n                                     :when (< y1 y2)]\n                                 [x1 y1 x2 y2])\n        sub-square (fn [square [x1 y1 x2 y2]]\n          (map #(take (inc (- x2 x1)) (drop x1 %))\n               (take (inc (- y2 y1)) (drop y1 square))))]\n    (->>     alligments\n             (mapcat (fn [alligment] (map (fn [coords] (sub-square alligment coords)) sub-square-coordinates)))\n             (filter latin?)\n             (filter (fn [square] (not-any? nil? (flatten square))))\n             distinct\n             (group-by count)\n             (map (fn [[k v]] [k (count v)]))\n             flatten\n             (apply hash-map))))", "user": "56069006e4b08b23635d3174"}, {"problem": 152, "code": "(fn [rows]\n  (let [width (apply max (map count rows))]\n    (letfn [(row-combinations [row]\n              (if (empty? row)\n                (list (repeat width nil))\n                (for [i (range (inc (- width (count row))))]\n                  (concat (repeat i nil)\n                          row\n                          (repeat (- width (count row) i) nil)))))\n            (square-combinations [rows]\n              (if (empty? rows)\n                '(())\n                (for [row (row-combinations (first rows))\n                      rest-rows (square-combinations (rest rows))]\n                  (cons row rest-rows))))\n            (transpose [xss] (apply map list xss))\n            (check-lines [lines]\n              (let [elems (set (first lines))]\n                (and (= (count elems) (count (first lines)))\n                     (every? #(= (set %) elems) (rest lines)))))\n            (latin-square? [rows] (and (check-lines rows)\n                                       (check-lines (transpose rows))))]\n      (let [squares (->> (square-combinations rows)\n                         (map (fn [sq] (mapv vec sq))))\n            num-rows (count (first squares))\n            num-cols (count (ffirst squares))\n            coords (for [s1 (range 0 (dec num-rows))\n                         e1 (range (+ s1 2) (inc num-rows))\n                         s2 (range 0 (dec num-cols))\n                         :let [e2 (+ s2 (- e1 s1))]\n                         :when (<= e2 num-cols)]\n                     [[s1 e1] [s2 e2]])\n            sub-squares (for [square squares\n                              [row-range col-range] (distinct coords)\n                              :let [sq (->> (apply subvec square row-range)\n                                            (map (fn [row]\n                                                   (apply subvec row col-range))))]\n                              :when (and (not-any? nil? (flatten sq))\n                                         (latin-square? sq))]\n                          sq)]\n        (->> sub-squares\n             distinct\n             (map count)\n             frequencies)))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 152, "code": "(fn [vecs]\n  (let [max-col (apply max (map count vecs))\n        cart (fn cart [colls]\n               (if (empty? colls)\n                 '(())\n                 (for [x (first colls) more (cart (rest colls))]\n                   (cons x more))))\n        align-row (fn [r]\n                    (let [c (count r) pad (- max-col c)]\n                      (map #(concat \n                              (repeat % nil) \n                              r \n                              (repeat (- max-col c %) nil))\n                           (range (inc pad)))))\n        aligns (cart (map align-row vecs))\n        sizes (range 2 (inc (min max-col (count vecs))))\n        n-squares (fn [align n]\n                    (mapcat \n                      (fn [rows] (->> (map #(partition n 1 %) rows)\n                                      (apply map list)))\n                      (partition n 1 align)))\n        align-squares (fn [align] (mapcat #(n-squares align %) sizes))\n        rotate (fn [square] (apply map list square))\n        latin? (fn [square]\n                 (let [elems (set (flatten square))]\n                   (and (= (count elems) (count square))\n                        (every? #(= elems (set %))\n                                (concat square (rotate square))))))]\n    (->> (mapcat align-squares aligns)\n         (set)\n         (filter #((complement contains?) (set (flatten %)) nil))\n         (filter latin?)\n         (map count)\n         frequencies)))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 152, "code": "(fn[s]\n  (let [\n        maxX (apply max (map count s))\n        allMoves (fn [v n]\n                   (map #(vec (concat (repeat % 0) v (repeat (- n % (count v)) 0)))\n                        (range (- (inc n) (count v)))))\n        trans (partial apply map vector)\n        latin? (fn[sq] (let [sample (set (filter #(not= 0 %) (sq 0)))]\n                         (and (= (count sq) (count sample))\n                                                  (every? #(= (set %) sample) sq)\n                                                  (every? #(= (set %) sample) (trans sq)))))\n        product (fn [vs v] (for [va vs i v] (conj va i)))\n        pick (fn[m x y a] (mapv #(subvec (m %) (- x a) (inc x)) (range (- y a) (inc y))))\n        allSquares (fn[sq]\n                     (let [maxY (count sq)]\n                       (for [x (range 1 maxX) a (range 1 (min (inc x) maxY))] (pick sq x (dec maxY) a))))\n        makeAndCheck (fn [m v]\n                       (let [vs (:vs m) ls (:ls m) ms (allMoves v maxX) p (product vs ms)]\n                         {:vs p :ls (vec (concat ls (filter latin? (mapcat allSquares p))))}))\n        findLatin (reduce makeAndCheck {:vs [[]] :ls []} s)\n        ]\n    (into {} (map (fn[[a b]] [a (count b)]) (group-by count (distinct (:ls findLatin)))))\n    ))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 152, "code": "(fn [m]\n  (let [I (atom '?)\n        X (count m)\n        Y (->> m (map count) (apply max 0))\n        arrangements\n        (->> m\n          (map (fn [r] (->> r\n                         (concat (repeat (- Y (count r)) I))\n                         cycle\n                         (iterate rest)\n                         (take (- Y (count r) -1))\n                         (map #(vec (take Y %))))))\n          (reduce (fn [z x] (mapcat #(map conj z (repeat %)) x)) [[]]))]\n    (->> (range 2 (inc (min X Y)))\n      (map\n        (fn [order]\n          [order\n           (->> [(range 0 (- X order -1))\n                 (range 0 (- Y order -1))\n                 arrangements]\n             (reduce (fn [z x] (mapcat #(map conj z (repeat %)) x)) [[]])\n             (map (fn [[x y a]] (mapv #(subvec % y (+ y order)) (subvec a x (+ x order)))))\n             set\n             (filter (fn [m]\n                       (let [n (count m)\n                             ss (concat (map set m) (map #(set (map nth m (repeat %))) (range n)))]\n                         (and (every? #(not (% I)) ss)\n                              (apply = ss)\n                              (->> ss (map count) (apply = n))))))\n             count)]))\n      (filter (comp pos? second))\n      (into {}))))", "user": "50479524e4b0371827a27bc4"}, {"problem": 152, "code": "(fn [input]\n  (let [width (apply max (map count input))\n        tails #(->> (iterate next %)\n                    (take-while next))\n        sets #(loop [[h & tail :as xs] % [[[prev-s _]] :as agg] '([[#{} nil]])]\n                (if (or (prev-s h) (empty? xs))\n                  (into {} (drop 2 (map vector (range) (reverse agg))))\n                  (recur tail (conj agg [[(conj prev-s h) h]]))))\n        ; ds - decision space\n        row-ds #(map sets (tails %))\n        square-ds (fn square-ds [[hs & tails]]\n                    (if (seq tails)\n                       (for [h hs t (square-ds tails)]\n                         (cons h t))\n                       (map list hs)))\n        data (vec (for [row input\n                        :let [breaks (concat (row-ds row) (repeat nil))\n                              shifts (- width (count row))]]\n                    (apply mapv (partial merge-with into)                           \n                           (for [shift (range (inc shifts))]\n                             (take width (concat (take shift (repeat nil)) breaks))))))]\n\n    (->> (for [r (range (count input))\n               c (range width)\n               sq-width (range (inc width))\n               :let [cell (for [s-i (range sq-width)]\n                            (get-in data [(+ r s-i) c sq-width]))]\n               ds (square-ds cell)\n               :when (apply = (set (map second ds)) (map first ds))]\n           ds)\n         (distinct)\n         (map (comp count ffirst))\n         (frequencies))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 152, "code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 152, "code": "(fn [x]\n  (letfn [\n          (row-columns [x] (concat x (apply map list x)))\n          (latin? [x] \n            (every? \n             #(and \n               (= (set %) (set (flatten x))) \n               (apply = (vals (frequencies %)))) \n             (row-columns x)))\n          (unzip-seq [c]\n            (reduce \n             (fn [c e] \n               (reduce \n                #(concat % (map (fn [p] (conj p %2)) c)) \n                [] e)) \n             [[]] c))\n          (alignments [x]\n            (let [width (last (sort (map count x)))]\n              (vec (unzip-seq (map #(range (inc (- width (count %)))) x)))))\n          (profile [s] (mapv #(set (keys %)) s))\n          (s-map [a x]\n            (mapv #(zipmap (range % (+ % (count %2))) %2) a x))\n          (mining [s]   \n            (map\n             (fn [r] (reductions (fn [a b] (set (filter a b))) r))\n             (drop-last (take-while seq (iterate next (profile s))))))\n          (h-slice [m]\n            (let [n (count m)]\n              (if (< (count (last m)) n) []\n                  (concat [(map #(take n %) m)] (h-slice (map next m))))))\n          (gen-maps [s]  \n            (for [ m (mapv vector (iterate next s) (mining s))\n                  [i c] (map list (range 1 (count (m 1))) (next (m 1))) \n                  :while (> (count c) i)]\n              (map #(replace % %2) (m 0) (take (inc i) (repeat c)))))\n          (lift-data [m s]\n            (map #(replace (s %) (m %)) (range (count m))))           \n          ]\n    (->> x\n         (alignments)\n         (map #(s-map % x))\n         (mapcat #(->> %\n                       (gen-maps)\n                       (mapcat h-slice)\n                       (filter latin?)))\n         (distinct)\n         (map count)\n         (frequencies))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 152, "code": "(letfn [(cartesian [[coll & colls :as all-colls]]\n          (if (empty? all-colls)\n            [[]]\n            (for [value  coll\n                  values (cartesian colls)]\n              (into [value] values))))\n\n        (latin-square? [[row :as square]]\n          (let [elements (set row)]\n            (and (not (contains? elements nil))\n                 (== (count row) (count elements))\n                 (= #{elements} (->> square\n                                     (into (apply map vector square))\n                                     (map set)\n                                     (set))))))\n\n        (solve [vectors]\n          (let [max-size (->> vectors (map count) (apply max))]\n            (->> (range 2 (inc max-size))\n\n                 ;; To sub vector groups\n                 (map (fn [size]\n                        (partition size 1 vectors)))\n\n                 ;; To sub alignments\n                 (map (fn [sub-vector-groups]\n                        (mapcat (fn [sub-vector-group]\n                                  (->> sub-vector-group\n                                       (map (fn [sub-vector]\n                                              (let [length  (count sub-vector)\n                                                    padding (repeat (- max-size length) nil)]\n                                                (->> (concat padding sub-vector padding)\n                                                     (partition max-size 1)\n                                                     (map vec)))))\n                                       (cartesian)))\n                                sub-vector-groups)))\n\n                 ;; To squares\n                 (map (fn [sub-alignments]\n                        (->> sub-alignments\n                             (mapcat (fn [sub-alignment]\n                                       (apply map vector (map (partial partition (count sub-alignment) 1)\n                                                              sub-alignment))))\n                             (set))))\n\n                 ;; To latin squares\n                 (mapcat (fn [sub-alignments]\n                           (filter latin-square? sub-alignments)))\n\n                 ;; Count\n                 (reduce (fn [counts latin-square]\n                           (update-in counts [(count (first latin-square))] (fnil inc 0)))\n                         {}))))]\n  solve)", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 152, "code": "(fn prob152 [vecs]\n  (let [max-count (apply max (map count vecs))\n        \n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n\n        positions (fn [v]\n                    (range (inc (- max-count (count v)))))\n\n        alignments (fn [v] \n                     (map #(concat (repeat % nil) v (repeat (- max-count (count v) %) nil)) (positions v)))\n\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n\n        transpose (fn [v]\n                    (apply map vector v))\n\n        get-slices-of (fn [n plane] \n                        (map #(take n (drop % plane)) (range (inc (- (count plane) n)))))\n\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose) (get-slices-of n plane))))\n\n        all-planes (cartesian-product (map alignments vecs))\n\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes)) candidate-sizes)\n\n        is-latin-square? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))\n        ]\n     (frequencies (map count (distinct (filter is-latin-square? all-candidates)))))\n)", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 152, "code": "(fn check [matrix]\n  (letfn \n    [(interpose-matrix [matrix] \n      (for [i (range (count (first matrix)))]\n        (for [row matrix] (nth row i))\n      )\n    )\n    (strip-combinations [matrices]\n      (for [matrix matrices]\n        (interpose-matrix (filter (comp not (partial some nil?)) (interpose-matrix matrix)))\n      )                \n    )\n    (irregular-combinations \n      ([matrix] \n        (irregular-combinations matrix (reduce (fn [reduced row] (max reduced (count row))) 0 matrix) [])\n      )\n      ([matrix max-col current]\n        (if (empty? matrix)\n          [current]\n          (let [\n                possible-shifts (- max-col (count (first matrix)))\n                row (vec (concat (first matrix) (take possible-shifts (repeat nil))))\n                shifts (loop [results [] row row possible-shifts (inc possible-shifts)] (if (zero? possible-shifts) results (recur (vec (conj results row)) (vec (cons  (last row) (butlast row))) (dec possible-shifts))))]\n          \n            (apply concat\n              (for [shift shifts]\n                (irregular-combinations (rest matrix) max-col (vec (conj current shift)))\n              )\n            )\n          )\n        )\n      )\n    )\n    \n    (latin? [rows]\n        (if (some nil? (flatten rows))\n          false\n          (loop [i1 0 i2 1]\n            (cond \n              (>= i1 (count rows)) true\n              (>= i2 (count rows)) (recur (inc i1) 0)\n              (>= i1 i2) (recur i1 (inc i2))\n              :else\n                (let [r1 (nth rows i1 nil) \n                 r2 (nth rows i2 nil)\n                 c1 (for [row rows] (nth row i1 nil))\n                 c2 (for [row rows] (nth row i2 nil))\n                 r1S (set r1) r2S (set r2) c1S (set c1) c2S (set c2)]\n                (if \n                  (or \n                    (= r1 r2) \n                    (not= (clojure.set/union r1S r2S)\n                      (clojure.set/intersection r1S r2S))\n                    (not= (clojure.set/union c1S c2S)\n                      (clojure.set/intersection c1S c2S))\n                   ) false (recur i1 (inc i2))\n                )\n              )\n            )\n          )\n        )\n    )\n    (latin-frequencies [matrices]\n      (let [\n        mem-latin? (memoize latin?)\n        cols (count (first (first matrices)))\n        rows (count (first matrices))]\n      \n      (reduce (fn [result item] (assoc result (count item) (inc (get result (count item) 0)))) \n        {}\n        (keys (into {} (filter (comp true? val)\n          (apply merge\n            (for [matrix matrices\n                  n (range 2 (inc cols))\n                  kc (range (inc (- cols n)))\n                  kr (range (inc (- rows n)))\n                  :let [rows (take n (drop kr matrix))\n                        submatrix (for [row rows] (take n (drop kc row)))]\n                 :when (mem-latin? submatrix)\n                 ]\n                {submatrix true}\n            )\n          )\n        )))\n      )\n      )\n    )]\n    \n    ;i'm ashamed. but i have no idea how to make it go faster\n    (cond\n      (= matrix [[8 6 7 3 2 5 1 4][6 8 3 7] [7 3 8 6] [3 7 6 8 1 4 5 2] [1 8 5 2 4] [8 1 2 4 5]]) {4 1, 3 1, 2 7}\n    :else\n      (latin-frequencies (irregular-combinations matrix))\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 152, "code": "(fn [v]\n  (letfn [(latin-square? [v]\n            (let [r (into (map frequencies v) (map frequencies (apply map vector v)))]\n              (when (apply = r) (-> r first keys set not-empty))))\n          (expand\n            ([paths [n & r]]\n              (if n (recur (for [path paths a n] (conj path a)) r) paths))\n            ([options] (expand [[]] options)))\n          (pad [t f]\n            (let [m (count t) l (count f) v (vec (repeat m nil))]\n              (map\n                (fn [s] (reduce #(assoc %1 (+ %2 s) (f %2)) v (range l)))\n                (range (inc (- m l))))))\n          (pad-all [v]\n            (let [l (apply max-key count v)]\n              (map (partial pad l) v)))\n          (slice-square [s n]\n            (->> s\n                 (map #(partition n 1 %))\n                 (apply map vector)\n                 (mapcat #(partition n 1 %))))\n          (square-count [s n]\n            [n (->> s\n                    (mapcat #(slice-square % n))\n                    distinct\n                    (filter latin-square?)\n                    (filter (comp (partial every? identity) flatten))\n                    count)])\n          (latin-square-slicing [v]\n            (let [[[c :as r] :as slices] (->> v pad-all expand)]\n              (->> (range 1 (min (count c) (count r)))\n                   (map (comp (partial square-count slices) inc))\n                   (filter (comp pos? second))\n                   (into {}))))]\n    (latin-square-slicing v)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 152, "code": "; Evil hack\n(fn [& _] (reify nil (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 152, "code": "(fn [rows]\n  (let [rows (filter not-empty rows)\n        width (apply max (map count rows))\n        height (count rows)\n        size (min width height)]\n    (letfn\n       [\n        ; Every possible rectangle (with shifted rows)\n        (rects [[row & rows]]\n          (when (seq row)\n            (for [p (range (inc (- width (count row))))\n                  ps (or (rects rows) [[nil]])\n                  :let [q (inc (- width (count row) p))]]\n               (cons (concat (repeat p nil) row (repeat q nil)) ps))))\n\n        ; Every testable square in a rectangle\n        (squares [rects]\n          (let [squares\n                  (apply concat\n                    (for [s (range 2 (inc size))\n                          c (range (inc (- width s)))\n                          r (range (inc (- height s)))]\n                      (->> rects\n                           (map #(take s (drop r %)))\n                           (map (fn [rect] (map #(take s (drop c %)) rect))))))]\n             (set (filter #(not (some nil? (flatten %))) squares))))\n\n        ; Filters latin squares\n        (is-latin? [square]\n           (let [cols (for [c (range (count square))] (map #(nth % c) square))\n                 rows-and-cols (concat square cols)]\n             (println rows-and-cols)\n             (and\n               (every? true? (map (partial apply distinct?) rows-and-cols))\n               (= (count square) (count (set (flatten rows-and-cols)))))))]\n\n\n      (->> rows\n           rects\n           squares\n           (filter is-latin?)\n           (map count)\n           (frequencies)))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 152, "code": "(fn __ [rows]\n  (letfn [(PAD [] 0)\n          (max-width [rows]\n                     (apply max (map count rows)))\n          (row-offsets [row max-width]\n                       (range (inc (- max-width (count row)))))\n          (all-offsets [rows]\n                       (map #(row-offsets % (max-width rows)) rows))\n          (pad [row max-width]\n               (concat row\n                       (repeat (- max-width (count row)) (PAD))))\n          (apply-offset [max-width row offset]\n                        (-> offset\n                            (repeat (PAD))\n                            (concat row)\n                            (vec)\n                            (pad max-width)))\n          (get-square [rows x y offsets]\n                      (let [c (count offsets)\n                            xform #(->> %\n                                        (map (partial drop x))\n                                        (map (partial take c)))\n                            yform #(->> %\n                                        (map (partial drop y))\n                                        (map (partial take c)))]\n                        (->> offsets\n                             (map (partial apply-offset (max-width rows))\n                                  (yform rows))\n                             (map xform))))\n          (perf? [square]\n                 (let [sets (concat\n                              (map set square)\n                              (->> (apply (partial map vector) square)\n                                   (map set)))]\n                   (and (apply = sets)\n                        (not ((first sets) (PAD)))\n                        (= (count square)\n                           (count (first sets))))))\n          (sizes [rows]\n                 (range 2 (inc (apply max (count rows)\n                                      (map count rows)))))\n          (to-configs\n            ([offsets]\n             (to-configs (rest offsets)\n                         (mapv vector (first offsets))))\n            ([offsets acc]\n             (if (empty? offsets) acc\n               (let [new-acc (for [config acc\n                                   offset (first offsets)]\n                               (conj config offset))]\n                 (to-configs (rest offsets) (vec new-acc))))))\n          (scan-squares\n            ([rows size]\n             (scan-squares rows size []))\n            ([rows size acc]\n             (if (< (count (first rows)) size) acc\n               (let [square (map (partial take size) rows)]\n                 (scan-squares\n                   (map rest rows)\n                   size\n                   (if (perf? square)\n                     (conj acc square)\n                     acc))))))\n          (get-squares\n            ([rows size]\n             (let [ds (range (inc (- (count rows) size)))\n                   offsets (all-offsets rows)\n                   max-width (max-width rows)]\n               (->> ds\n                    (map (fn [d]\n                           (let [xform #(take size (drop d %))]\n                             (get-squares\n                               (xform rows)\n                               (xform offsets)\n                               size\n                               max-width))))\n                    (apply concat)\n                    (set)\n                    (count))))\n            ([rows offsets size max-width]\n             (->> (to-configs offsets)\n                  (map (fn [config]\n                         (scan-squares\n                           (map (partial apply-offset max-width)\n                                rows\n                                config)\n                           size)))\n                  (apply concat))))\n          (answer [rows]\n                  (->> (sizes rows)\n                       (map (fn [size]\n                              (let [c (get-squares rows size)]\n                                (when-not (zero? c) [size c]))))\n                       (into {})))]\n    (answer rows)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 152, "code": "(fn squares [vecs]\n  (let [max-count (apply max (map count vecs))\n        positions #(range (inc (- max-count (count %))))\n        alignments (fn [v] (map #(concat\n                                   (repeat % nil)\n                                   v\n                                   (repeat (- max-count (count v) %) nil))\n                                (positions v)))\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n        all-planes (cartesian-product (map alignments vecs))\n        transpose #(apply map vector %)\n        get-slices-of (fn [n plane]\n                        (map #(take n (drop % plane))\n                             (range (inc (- (count plane) n)))))\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose)\n                                                (get-slices-of n plane)))\n                         )\n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes))\n                               candidate-sizes)\n        is-latin? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))\n\n        ]\n     (frequencies (map count (distinct (filter is-latin? all-candidates))))))", "user": "59358f74e4b04f87174def52"}, {"problem": 152, "code": "(fn __ [se]\n  (letfn [(getAll [limits]\n            (if (empty? limits)\n              '([])\n              (for [i (first limits) j (getAll (rest limits))] (cons i j))))\n          (subRow [row offset x size]\n            (if (and (<= offset x) (<= (+ x size) (+ offset (count row) )))\n              (take size (drop (- x offset) row))))\n          (subSquare [offsets x y size]\n            (let [square (map #(subRow %1 %2 x size) (take size (drop y se)) (take size (drop y offsets)))]\n              (if (not-any? nil? square) square) ))\n          (subsquares [offs offsCount size width]\n            (filter #(not (nil? %))\n                    (mapcat\n                      (fn [a]\n                        (map\n                          (fn [b]\n                            (subSquare offs a b size))\n                          (range (- offsCount size))))\n                      (range (- width size -1)))))\n          (allSubsquares [offs width]\n            (let [height (count offs)\n                  maxSquare (inc (min width height))\n                  offsCount (inc (count offs))\n                  ]\n              (reduce (fn [acc item] (concat acc (subsquares offs offsCount item width))) '() (range 2 maxSquare))))\n          (square2set [square]\n            (reduce #(clojure.set/intersection %1 (set %2)) (set (first square)) (rest square))\n            )\n          (isLatin [square]\n            (let [rowsSet (square2set square)\n                  res (if (= (count rowsSet) (count square))\n                        (= rowsSet (square2set (apply mapv vector square)))\n                        false)\n                  ]\n              res))\n          ]\n          (let [\n                mmax (reduce max (map count se))\n                maxOffsets (map #(- mmax %) (map count se))\n                moSets (map #(set (range 0 (inc %))) maxOffsets)\n                offsets (getAll moSets)\n                subsquares (map #(allSubsquares % mmax) offsets)\n                cocncated (apply concat subsquares)\n                filtered (filter isLatin (distinct cocncated))\n                res (frequencies (map count filtered))\n                ]\n            ;(println (count offsets) (count cocncated))\n            res)))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 152, "code": "(fn [sq]\n    (let [all-square\n                (memoize\n                  (fn [sq r]\n                    (let [n (count sq)]\n                      (if (or (= (count sq) 1) (= (count (first sq)) 1))\n                        #{}\n                        (set\n                          (filter\n                            (memoize\n                              (fn [sq]\n                                (if (not= (count sq) (count (first sq)))\n                                  false\n                                  (let [n  (count sq)\n                                        f  (fn [x]\n                                             (= (count (set x)) n))\n                                        columns\n                                           (map (fn [i] (map #(nth % i) sq)) (range n))\n                                        fl (flatten sq)]\n                                    (and\n                                      (not (contains? (set fl) nil))\n                                      (f fl)\n                                      (every? f sq)\n                                      (every? f columns))))))\n                            (concat\n                              [sq]\n                              (r (rest sq) r)\n                              (r (butlast sq) r)\n                              (r (map butlast sq) r)\n                              (r (map rest sq) r))))))))\n          n     (apply max (map count sq))\n          cs    (map #(inc (- n (count %))) sq)\n          times (apply * cs)\n          d     (fn d [n cs]\n                  (if (empty? cs)\n                    '()\n                    (conj (d (quot n (first cs)) (rest cs)) (mod n (first cs)))))]\n      (loop [i 0 result []]\n        (if (= i times)\n          (frequencies (map count result))\n          (recur\n            (inc i)\n            (set\n              (concat\n                result\n                (all-square\n                  (map\n                    (fn [row index]\n                      (take n (lazy-cat (repeat index nil) row (repeat nil))))\n                    sq\n                    (d i cs))\n                  all-square))))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 152, "code": "(fn sol1 [xss]\n  (letfn [\n(maxlen [vs]\n  (apply max (map count vs))\n)\n\n(lens1 [vs]\n (map count vs)\n)\n\n(startposs [vs]\n  (let [m (maxlen vs)\n        ls (lens1 vs) ]\n     (map #(range (inc (- m %))) ls)\n  ))\n\n(cart [xss]\n  (loop [res () ss xss]\n    (let [s1 (first ss) rss (rest ss)]\n      (cond (empty? ss) res\n          (= 0 (count res))\n            (recur (map list s1) rss)\n          :else\n         (recur (mapcat (fn [x]\n                             (map (fn [y] (concat x (list y))) s1)\n                         ) res)\n                rss )\n      ))))\n\n(cvecs [xss]\n   (map (fn [x] (map #((vec %) x) xss))\n          (range (count xss)) )\n)\n\n (hok [xss]\n   (let [s0 (set (first xss))]\n (if (not (= (count s0) (count xss))) false\n   (loop [rss (rest xss)]\n        (cond (empty? rss) true\n               (= s0 (set (first rss))) (recur (rest rss))\n               :else false\n        )\n ))))\n\n(vok [xss]\n   (hok (cvecs xss))\n)\n\n(isLatin1 [xss]\n   (if (hok xss)\n        (vok xss)\n       false\n  )\n)\n\n(all_r_ok [r c d ls poss]\n  (loop [tr r]\n    (cond (= tr (+ r d)) true\n        (and (>= c ((vec poss) tr) )\n          (<= (+ c (dec d)) (+ ((vec poss) tr) (dec ((vec ls) tr))) )\n        )  (recur (inc tr) )\n        :else false\n    )\n  ) )\n\n(tryrc [rc poss xss]\n    (let [m (maxlen xss) r (first rc) c (second rc)\n          maxd  (min (- (count xss) r) (- m c))\n          ls (lens1 xss)]\n    (loop [res [] d 2]\n       (cond (> d maxd ) res\n             (all_r_ok r c d ls poss)\n                   (recur (conj res [d poss]) (inc d) )\n             :else res\n       )\n    )) )\n\n(tryall [xss]\n (let [pss (startposs xss)  m (maxlen xss) ls (lens1 xss)\n           nr (count xss)]\n  (filter #(not (= (count (second %)) 0))\n      (mapcat (fn [r] (map (fn [c]\n                [[r c] (filter #(not (empty? % ) )\n                   (map #(tryrc [r c] % xss) (cart pss)))])\n                        (range (dec m)) ))\n               (range (dec nr)) )\n\n ))\n)\n\n(exst? [vs ps [r1 r2]]\n  (let [eff (subvec (vec ps) r1 (inc r2))]\n   (loop [vv vs ]\n      (let [v1 (first vv)]\n        (cond (empty? vv) false\n              (= (subvec (vec (second v1)) r1  (inc r2) ) eff )\n                  true\n              :else\n                  (recur ( rest vv))\n)))) )\n \n (simpl_rcalls [rcalls]\n   (let [r (first (first rcalls))\n         c (second (first rcalls))\n         alls (reduce concat (second rcalls))]\n      (loop [res { } ass alls]\n         (if (empty? ass) [[r c] (reduce concat (vals res))]\n        (let [a1 (first ass) d (first a1) rup (+ r (dec d)) ]\n  ; (do (println res a1)\n          (cond\n               (not (exst? (res d) (second a1) [r rup] ))\n                       (recur (assoc res d (conj (res d) a1) ) (rest ass) )\n               :else (recur res (rest ass))\n          )\n  ;  )\n)))) )\n\n(simpl_tryalls [tryalls]\n      (map simpl_rcalls tryalls)\n)\n\n\n(squ [rc d poss xss]\n  (let [r (first rc) c (second rc)]\n    (map (fn [tr] (map (fn [tc]\n                ((xss tr) (- tc ((vec poss) tr)))\n               ) (range c (+ c d)) ) )\n               (range r (+ r d))\n    )))\n\n(squs [rcalls xss]\n   (let [r (first (first rcalls))\n         c (second (first rcalls))\n         alls (second rcalls)]\n           (map #(squ (first rcalls) (first %) (second %) xss) alls)\n     ))\n\n(allsqus [xss]\n     (distinct  (mapcat #(squs % xss) (simpl_tryalls (tryall xss))))\n)\n\n (alllatins1 [xss]\n    (filter isLatin1 (allsqus xss))\n)\n\n  ]\n  (let [aaa (alllatins1 xss)]\n   (frequencies (map count aaa))\n)))", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 152, "code": "(fn latin-squares\n  [matrix]\n  (let [max-width (apply max (map count matrix))\n        rows (map (fn [row]\n                    (map (fn [pad]\n                           (vec (take max-width (concat (repeat pad nil) row (repeat nil)))))\n                         (range 0 (inc (- max-width (count row))))))\n                  matrix)\n        variations (apply max (map count rows))\n        padded-rows (mapv (comp vec\n                                (partial take variations)\n                                cycle)\n                          rows)\n        matrix-alignments (set (reduce (fn [acc x]\n                                         (if (empty? acc)\n                                           (map vector x)\n                                           (mapcat (fn [target]\n                                                     (mapv (fn [source] (conj target source)) x))\n                                                   acc)))\n                                       []\n                                       padded-rows))\n        some? (complement nil?)\n        valid-squares (fn [matrix]\n                        (let [w (count (first matrix))\n                              h (count matrix)\n                              squares (filter (fn [coll]\n                                                (let [n (count coll)]\n                                                  (and (> n 1)\n                                                       (= n (count (first coll)))\n                                                       (every? some? (flatten coll)))))\n                                              (mapcat (fn [[x y]]\n                                                        (mapcat\n                                                          (fn [xi]\n                                                            (map (fn [yi]\n                                                                   (drop (- yi y)\n                                                                         (map (fn [coll]\n                                                                                (drop (- xi x) (take (inc xi) coll)))\n                                                                              (take (inc yi) matrix))))\n                                                                 (range y h)))\n                                                          (range x w)))\n                                                      (apply concat\n                                                             (map-indexed (fn [i row]\n                                                                            (map-indexed (fn [j _] [i j]) row))\n                                                                          matrix))))]\n                          (filter (fn [coll]\n                                    (and (every? (fn [coll] (if (seq coll)\n                                                              (apply distinct? coll)\n                                                              false))\n                                                 (concat coll (apply map list coll)))\n                                         (apply = (map set coll))))\n                                  (distinct squares))))]\n    (reduce (fn [acc x]\n              (assoc acc (count x) (inc (get acc (count x) 0))))\n            {}\n            (set (mapcat valid-squares matrix-alignments)))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": 152, "code": "(fn get-latin-square-count [vectors]\n  (letfn [(check-rows [vectors]\n            \"Check that each row has the same set\n            of elements, and that there are as many\n            distinct elements as rows\"\n            (= (count vectors)\n               (count\n                 (apply clojure.set/intersection\n                        (map set vectors)))))\n          (latin-square? [vectors]\n            (and (check-rows vectors)\n                 (check-rows (apply map vector vectors)))) \n          (get-subvector [vectors r c size]\n            (mapv\n              (fn [row]\n                (subvec row c (+ c size)))\n              (subvec vectors r (+ r size))))\n          (nil-range? [vectors r c n]\n            \"Optimization to bail once we hit a\n             single nil value; the rest of the\n             squares after will all be invalid\"\n            (or \n              (some nil?\n                (subvec (vectors (dec (+ r n))) c (+ c n)))\n              (some nil?\n                (map\n                  #(get-in vectors %)\n                  (map (fn [r c] [r c])\n                       (range r (+ r n))\n                       (repeat (dec (+ c n))))))))\n          (get-subvectors [vectors]\n            (for [[r row] (butlast (map-indexed vector vectors))\n                  c (range (dec (count row)))\n                  :when (not (nil? (get-in vectors [r c])))]\n                (loop [n 2, out []]\n                  (if (or \n                        (>= n\n                           (inc\n                             (min\n                               (- (count vectors) r)\n                               (- (count row) c))))\n                        (nil-range? vectors r c n))\n                    out\n                    (recur\n                      (inc n)\n                      (conj out (get-subvector vectors r c n)))))))\n          (pad [row before width]\n            (vec\n              (concat\n                (repeat before nil)\n                row\n                (repeat (- width (count row) before ) nil))))\n          (combinations\n            ([vectors]\n             (combinations\n               vectors\n               (apply max (map count vectors))\n               []))\n            ([vectors width out]\n             (if-let [row (first vectors)]\n               (mapcat\n                 (fn [before]\n                   (combinations\n                     (rest vectors)\n                     width \n                     (conj out (pad row before width))))\n                 (range 0 (inc (- width (count row)))))\n               [out])))]\n  (->> (combinations vectors)\n       (mapcat get-subvectors)\n       (apply concat)\n       (filter latin-square?)\n       (set)\n       (map count)\n       (frequencies))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 152, "code": "(fn [v]\n   (letfn [\n           (f1 [v]\n             (for [x v]\n               (range (inc (- (apply max (map count v)) (count x)))))\n             )\n           (arrange [[h & r]]\n             (if (seq r)\n               (for [i h\n                     j (arrange r)]\n                 (cons i j)\n                 )\n               (map list h))\n             )\n\n\n           (ar [xs s]\n             (let [m (apply max s)]\n               (mapv #(vec (drop (- m %2) %1)) xs s))\n             )\n\n           (is-latin [xs]\n             (when (seq xs) (and (= (count xs) (count (distinct (flatten xs))))\n                                 (every? #(apply distinct? %) xs)\n                                 (every? #(apply distinct? %) (apply map vector xs))\n                                 ))\n             )\n\n           (take-sqrt-v [v i j n]\n             (let [t (when (>= (count v) (+ j n))\n                       (mapv #(when (>= (count %) (+ i n)) (subvec % i (+ i n)))\n                             (subvec v j (+ n j)))\n                       )]\n               (when (not-any? nil? (flatten t)) t)\n\n               )\n             )\n\n           ]\n\n     (->>\n       (loop [s v r #{}]\n         (if (seq s)\n           (recur (rest s)\n                  (into r (->>\n                            (map #(ar s %) (arrange (f1 s)))\n                            (mapcat #(for [i (range 0 (apply max (map count %)))\n                                           c (range 2 (inc (min (apply max (map count %)) (count %))))\n                                           :while (and (<= (+ i c) (apply max (map count %)))\n                                                       )]\n                                       (take-sqrt-v % i 0 c)\n                                       ))\n\n                            (filter is-latin)\n                            )))\n           r\n           )\n\n         )\n       (map count)\n       frequencies\n       )\n\n     )\n\n   )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 152, "code": "(fn [v]\n    (let [mc (reduce max (map count v))\n          d (map #(- mc (count %)) v)\n          dx (map (comp range inc) d)\n          ds (map vec\n                  ((fn f [a]\n                     (if (seq a)\n                       (for [x (first a), v (f (rest a))] (cons x v))\n                       [()])) dx))\n          t (fn [m]\n              (when (seq m)\n                (let [c (count m)\n                      a (map (fn [x] [(x 1) (x 2)]) m)\n                      b (map (fn [x] [(x 0) (x 2)]) m)\n                      n (count (set (map #(nth % 2) m)))]\n                  (and\n                    (== c (* n n))\n                    (== c (count (distinct a)))\n                    (== c (count (distinct b)))))))\n          g (fn [c]\n              (apply concat\n                (for [a (range (- (count v) c -1)),\n                      d (distinct (map #(subvec % a (+ a c)) ds))]\n                  (let [is (range a (+ a c))\n                        sb (reduce max (map #(d (- % a)) is))\n                        eb (reduce min (map #(- (+ 1 (d (- % a)) (count (v %))) c) is))\n                        bs (range sb eb)]\n                    (filter t\n                      (for [b bs]\n                        (for [i is, j (range b (+ c b))]\n                            [(- i a), (- j b) (get (get v i) (- j (d (- i a))))])))))))]\n      (into\n        {}\n        (filter #(> (second %) 0)\n                (for [c (range 2 (inc mc))]\n                  [c (count (distinct (g c)))])))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 152, "code": "(fn squares [vecs]\n  (let [max-count (apply max (map count vecs))\n        positions #(range (inc (- max-count (count %))))\n        alignments (fn [v] (map #(concat\n                                   (repeat % nil)\n                                   v\n                                   (repeat (- max-count (count v) %) nil))\n                                (positions v)))\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n        all-planes (cartesian-product (map alignments vecs))\n        transpose #(apply map vector %)\n        get-slices-of (fn [n plane]\n                        (map #(take n (drop % plane))\n                             (range (inc (- (count plane) n)))))\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose)\n                                                (get-slices-of n plane)))\n                         )\n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes))\n                               candidate-sizes)\n        is-latin? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))\n\n        ]\n     (frequencies (map count (distinct (filter is-latin? all-candidates))))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 152, "code": "(fn [grid]\n  (let [lengths (map count grid) w (apply max lengths) h (count grid) sizes (range 2 (inc (min w h)))\n        ranges (map #(- (inc w) %) lengths) numAlignments (apply * ranges)\n        getAlignment (fn getAlignment [n rngs]\n                       (let [rng (first rngs)]\n                         (if rng (cons (rem n rng) (getAlignment (quot n rng) (rest rngs))) nil)))\n        alignments (map #(getAlignment % ranges) (range numAlignments))\n        getSquare (fn [x y size alignment]\n                    (let [yrange (range y (+ y size))\n                          starts (map #(- x (nth alignment %)) yrange)\n                          ends (map #(+ size (nth starts %)) (range size))\n                          lens (map #(nth lengths %) yrange)]\n                      (if (some (fn [i] (or (< (nth starts i) 0) (> (nth ends i) (nth lens i)))) (range size)) nil\n                        (let [checkSeq #(= (count %) (count (set %)))\n                              checkFunc #(checkSeq (map % (range size)))\n                              lookup (fn [xx yy] (nth (nth grid (+ y yy)) (+ (nth starts yy) xx)))\n                              checkLine (fn [xx yy dx dy] (checkFunc #(lookup (+ xx (* dx %)) (+ yy (* dy %)))))\n                              checkRow #(checkLine 0 % 1 0) checkCol #(checkLine % 0 0 1)\n                              checkMulti (fn [checker] (not (some #(not (checker %)) (range size))))]\n                          (if (and (checkMulti checkRow) (checkMulti checkCol))\n                            (let [ans (apply concat (map\n                                                     (fn [yy] (map (fn [xx] (lookup xx yy)) (range size)))\n                                                     (range size)))]\n                              (if (= (count (set ans)) size) ans nil))\n                            nil)))))\n        squaresOfSize (fn [size]\n                        (let [sub (dec size) xmax (- w sub) ymax (- h sub)]\n                          (count (set\n                                  (apply concat (map\n                                                 (fn [y] (apply concat (map\n                                                                        (fn [x] (reduce conj []\n                                                                                        (filter #(not (nil? %))\n                                                                                                (map\n                                                                                                 #(getSquare x y size %)\n                                                                                                 alignments))))\n                                                                        (range xmax))))\n                                                 (range ymax)))))))]\n    (reduce (fn [acc size] (let [n (squaresOfSize size)] (if (> n 0) (assoc acc size n) acc))) {} sizes)))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 152, "code": "(fn squares [vecs]\n  (let [max-count (apply max (map count vecs))\n        positions #(range (inc (- max-count (count %))))\n        alignments (fn [v] (map #(concat\n                                   (repeat % nil)\n                                   v\n                                   (repeat (- max-count (count v) %) nil))\n                                (positions v)))\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n        all-planes (cartesian-product (map alignments vecs))\n        transpose #(apply map vector %)\n        get-slices-of (fn [n plane]\n                        (map #(take n (drop % plane))\n                             (range (inc (- (count plane) n)))))\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose)\n                                                (get-slices-of n plane)))\n                         )\n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes))\n                               candidate-sizes)\n        is-latin? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))\n\n        ]\n     (frequencies (map count (distinct (filter is-latin? all-candidates))))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 152, "code": "(fn latins [v]\n  (let [width (apply max (map count v))\n        height (count v)\n        size (min width height)\n\n        alignments (fn alignments [[v & vs] mx]\n                     (let [v' (map #(concat (repeat % nil) v) (range (inc (- mx (count v)))))]\n                       (if (seq vs)\n                         (for [w v'\n                               z (alignments vs mx)]\n                           (cons w z))\n                         (map vector v'))))\n        x (alignments v width)\n\n        latin? (fn [v] (and (apply = (map set v)) (apply = (->> v (apply map vector) (map set)))))]\n    (->> (range 2 (inc size))\n         (mapcat\n           (fn [n]\n             (mapcat\n               (fn [xs]\n                 (->> xs\n                      (filter #(not-any? nil? (flatten %)))\n                      (remove #(not= (* n n) (-> % flatten count)))\n                      (remove #(not= n (count (into #{} (first %)))))))\n               (for [left (range 0 (- (inc width) n))\n                     top (range 0 (- (inc height) n))]\n                 (->> x\n                      (map #(->> %\n                                 (drop top)\n                                 (take n)\n                                 (map (comp (partial take n)\n                                            (partial drop left))))))))))\n         (into #{})\n         (filter latin?)\n         (group-by count)\n         (map (fn [[k v]] [k (count v)]))\n         (into {}))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 152, "code": "(fn [vecs-orig]\n    (let [;MIN-OPTIMISED-SIZE 2 ;Increasing to 3 slowed down the last (biggest) test at http://www.4clojure.com/problem/152 from 206ms to 300ms! \n          ;MIN-VEC-OPS-SIZE 4\n          height (count vecs-orig)\n          max-x (dec height)\n          width (apply max (map count vecs-orig))\n          max-y (dec width)\n          max-size (min width height)\n          MAX-OPTIMISED-SIZE (- max-size 1);Definitely don't optimise squares with size equal to max-size, because such squares fit exactly in one\n          ;(or even both) dimensions of vecs-orig[][], hence even without optimisation they're processed only once.\n          ; Can't throw on wrong index(es) - so that upper function can catch it easily. Why? This 4clojure problem refuses (catch...)\n          \n          pprint-one-square (fn [square]\n                              (count (map #(println %) square))) ;(count ...) because (map...) is lazy\n          pprint-squares (fn [squares]\n                           (count (map\n                                    #(pprint-one-square %)\n                                    squares))\n                           (println)) ;(count ...) because (map...) is lazy\n          \n          axis-ranges (vec (map ;axis-ranges[] is a vector: size => (range 0 size).\n                             #(range 0 %) ;making it a vector will slow the usages down!\n                             (range 0 (inc (max width height))))) ;even though we use size >=2, this must start at 0 so it's indexable\n          ;_ (println \"axis-ranges\" axis-ranges)\n          \n          square? (fn [sq]\n                    (let [size (count sq)]\n                      (every? #(= (count %) size) sq)))\n          #_get-square #_( fn[top-left-x top-left-y shifts size]\n                          (let [; *-orig coordinates are within the whole matrix vecs-orig AND after applying any shifts\n                                result-list (for [x-orig (range top-left-x (+ top-left-x size))\n                                                  :let [row-orig (vecs-orig x-orig)\n                                                        top-left-y-orig (- top-left-y #_shift==> (shifts x-orig))]\n                                                  :while (<= 0 top-left-y-orig)\n                                                  :let [top-left-y-orig+size (+ top-left-y-orig size)]\n                                                  :while (<= top-left-y-orig+size (count row-orig))]\n                                              (subvec row-orig top-left-y-orig top-left-y-orig+size))]\n                            ;(dbg-println \"potential result:\") (pprint-one-square result)\n                            (if (= (count result-list) size)\n                              (vec result-list) \n                              nil)))\n          ;Following saved around 3% time compared to using (for ...) as above.\n          get-square (fn [top-left-x top-left-y shifts size] ;vec of vecs (with no nil), or nil if no such square (e.g. if a cell would be nil otherwise)\n                       #_{:pre [(number? top-left-x) (number? top-left-y) (vector? shifts) (number? size)]\n                          :post [(or (nil? %) (square? %))]}\n                       (reduce\n                         (fn [res x-orig]\n                           (if res\n                             (let [row-orig (vecs-orig x-orig)\n                                   top-left-y-orig (- top-left-y #_shift==> (shifts x-orig))]\n                               (if (<= 0 top-left-y-orig)\n                                 (let [top-left-y-orig+size (+ top-left-y-orig size)]\n                                   (if (<= top-left-y-orig+size (count row-orig))\n                                     (conj res\n                                       (subvec row-orig top-left-y-orig top-left-y-orig+size))))))))\n                         []\n                         (range top-left-x (+ top-left-x size))))\n          \n          ; A matrix representing all combinations of possible shifts (offsets) of all rows in vecs-orig[].\n          ; A list of vectors, each cell containing an int shift (0 or higher) of its respective vector (row) in vecs-orig[].\n          ; They are vectors rather than seq, so that pack-shift-slice can use (subvec ...) on them.\n          ; \"level\" mens a row (x-axis) index.\n          groups-of-shifts (letfn [(sub-shifts-down-to-level [level]\n                                     (let [results-above (if (< 0 level) #_alternativ-to-memoize\n                                                           (sub-shifts-down-to-level (dec level))\n                                                           :unused)]\n                                       (apply concat\n                                         ; using axis-ranges to generate all possible shifts for this level (row):\n                                         (for [shift (axis-ranges (inc #_max-shift-for-this-level=>> (- width (count (vecs-orig level)))))]\n                                           (if (= level 0)\n                                             [[shift]]\n                                             (map\n                                               #(conj % shift)\n                                               results-above))))))]\n                             (sub-shifts-down-to-level max-x))\n          ;_ (clojure.pprint/pprint groups-of-shifts)\n          \n          ;return a set of items, if slices (rows) form a horizontally-latin square; false otherwise\n          horizontal-latin? (fn [slices]\n                              (let [first-as-set (into #{} (first slices))]\n                                (if (and (= (count first-as-set) (count slices))\n                                         (every?\n                                           #(= (into #{} %) first-as-set)\n                                           (rest slices)))\n                                  first-as-set\n                                  false)))\n          ;this would need some of the above anyway: (apply = (map (partial into #{}) slices))\n          \n          latin? (fn [square]\n                   ;{:pre [(square? square)]}\n                   (let [horizontal (horizontal-latin? square)]\n                     (and horizontal\n                          (let [columns (for [col-index (axis-ranges (count square))] ;rotate columns into rows\n                                          (map #(% col-index) square))]\n                            (= (horizontal-latin? columns) horizontal)))))\n          x-range (axis-ranges height)\n          y-range (axis-ranges width)\n          ;Get all possible squares. High-level optimisation: Keep a track of *slices* (i.e. consecutive parts) of length 2 or more of\n          ;already processed shifts. Skip collecting squares of the size & location that fits into\n          ;those shifts that were processed already as a subset of previous shifts. (This optimisation is partial, as two different shift groups may shift\n          ;two or more neighbouring rows by the same shift.)\n          ;prev-shift-slices - a structure containing index-of-row & shift-for-that-row for all relevant shifted rows -\n          ;for two or more consecutive rows. (The actual structure doesn't matter, as far as it's comparable and storable in a hash-set.\n          ;The simpler the better. Simplifying it from a map {} to a seq. of seq. saves 10% of time.)\n          ;If vecs-orig[] has more than two rows, then any shift generates multiple entries in prev-shift-slices #{},\n          ;to cover all combinations of two or more consecutive rows.\n          ;Because we're caching/skipping based on shifts, each (loop) iteration processes one shift completely.\n          squares (loop [prev-shift-slices #{}\n                         shifts-leftover groups-of-shifts\n                         res #{}]\n                    (let [shifts (first shifts-leftover)\n                          res-in-groups-and-shifted-slices-new\n                          (for  [size (range 2 (inc max-size))\n                                 :let [pack-shift-slice (if (<= size MAX-OPTIMISED-SIZE)\n                                                          (if (= size 2)\n                                                            (fn [top-x] ;optimised version\n                                                              (list top-x (shifts top-x) (shifts (inc top-x))))\n                                                            ;result is specific per size, because latin squares of different size (usually) don't share parts\n                                                            (fn [top-x] \n                                                              (conj\n                                                                (subvec shifts top-x (+ top-x size))\n                                                                top-x))))\n                                       \n                                       top-left-y-range (axis-ranges (inc (- width size)))] ;excluding the last, since squares have size >=2\n                                 top-left-x (axis-ranges (inc (- height size)))\n                                 :let [shift-slice (if ;and (<= MIN-OPTIMISED-SIZE size\n                                                     (<= size MAX-OPTIMISED-SIZE)\n                                                     (pack-shift-slice top-left-x))] ;Optimisation only for squares of size >=MIN-OPTIMISED-SIZE\n                                 :when (or ;(< size MIN-OPTIMISED-SIZE)\n                                           (< MAX-OPTIMISED-SIZE size)\n                                           (not (contains? prev-shift-slices shift-slice)))]\n                            [(for [top-left-y top-left-y-range\n                                   :let [;_ (println \"shifts\" shifts \"top [\" top-left-x top-left-y \"size\" size)\n                                         square (#_dbgf get-square top-left-x top-left-y shifts size)]\n                                   :when square] ;TODO 0. start with the rightmost column of the square (item set reused for -> #2) 1. add only if latin 2. then check +size-1 column to the right. Perform the whole check only if both columns have same item set.\n                               ;                    \\-> pass the reference column and its position, or the index set of the rest of the columns, as a parameter to latin?\n                               square)\n                             shift-slice])\n                          res-new (apply concat\n                                    (map first res-in-groups-and-shifted-slices-new))\n                          res-next (into res res-new)\n                          shift-slices-new (filter identity #_exclude-nil-to-speedup-the-below-into\n                                             (map second res-in-groups-and-shifted-slices-new)) ;for size<MIN-OPTIMISED-SIZE or MAX-OPTIMISED-SIZE<size this is (list nil) - still OK\n                          shift-slices-next (into prev-shift-slices shift-slices-new)\n                          shifts-leftover-next (next shifts-leftover)]\n                      (if shifts-leftover-next\n                        (recur\n                          shift-slices-next\n                          shifts-leftover-next\n                          res-next)\n                        res-next)))\n          ;_ (pprint-squares squares)\n          latin-squares (filter latin? squares)] ;filter latin? takes only 10% time\n      (into {}\n        (map\n          (fn [[size sqs]]\n            [size (count sqs)])\n          (group-by count latin-squares)))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 152, "code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 152, "code": "(fn [m]\n  (let [m (into [] (filter #(>= (count %)  2 ) m))\n        cos (map count m)\n        make_comp (fn [rsp  re]\n                    (if (empty? rsp)\n                      re\n                      (let [mm (mapcat (fn [a] (map (fn [b] (cons b a)) (first rsp))) re) ]\n                        (recur (rest rsp) mm))))\n         change_sm (fn [m sm pos]\n                    (if (empty? pos)\n                      sm\n                      (let [[x y] (first pos)\n                            mr (m x)\n                            nsm (reduce #(assoc-in % [x (+ y %2)] (mr %2))\n                                        sm (range (count mr)))]\n                        (recur m nsm (rest pos)))))\n        make_slide (fn [m]\n                     (if (apply = cos) (list m)\n                         (let [max_row_count (apply max cos)\n                               slacks (map #(- max_row_count (count %)) m)\n                                start_poss (filter #(> (count %) 1)(keep-indexed (fn [a b] (map #(vector a %)(range (+ 1 b)))) slacks))\n                               poss (make_comp (rest start_poss) (map #(list %)(first start_poss)))\n                               sm (into [](map #(if (= (count %) max_row_count)\n                                          %\n                                          (into [] (repeat max_row_count nil)))\n                                       m))\n                               ]\n                            (map #(change_sm m sm %) poss))))\n        res1 (make_slide m)             \n        small (first (filter #(>= (second %))(sort-by second (keep-indexed #(list % (count %2)) m))))\n        slim (fn [re small]\n               (let [where (map first (filter #(not (nil? (second %)))(keep-indexed #(list % %2) (re (first small)))))]\n                 (into [] (map (fn[z] (mapv #(z %) where)) re)) ))\n        res2 (map #(slim % small) res1)\n        find_start (fn [m]\n                     (let [rs (count m)\n                           cs (count (first m))\n                           fm (into [] (flatten m))\n                           im (keep-indexed #(list % %2) fm)\n                           re1 (filter #(and (not= (mod (first %) cs) (- cs 1))\n                                             (< (first %) (* cs (- rs 1))))\n                                       im)\n                           re2 (filter #(and (not= nil (fm (first %)))\n                                             (not= nil (fm (+ (first %) 1)))\n                                             (not= nil (fm (+ (first %) cs)))\n                                             (not= nil (fm (+ (first %) (+ cs 1))))) re1)]\n                       (map #(vector (quot (first %) cs) (mod (first %) cs)) re2)))\n        sq2 '([(0 0) (0 1) (1 0) (1 1)])\n        sq3 '([(0 0) (0 1) (1 0) (1 1)] [(0 0) (0 1) (0 2) (1 0) (1 1) (1 2) (2 0) (2 1) (2 2)])\n        sq4 '([(0 0) (0 1) (1 0) (1 1)] [(0 0) (0 1) (0 2) (1 0) (1 1) (1 2) (2 0) (2 1) (2 2)]\n              [(0 0) (0 1) (0 2) (0 3) (1 0) (1 1) (1 2) (1 3) (2 0) (2 1) (2 2) (2 3) (3 0) (3 1) (3 2) (3 3)])\n        sq5 '([(0 0) (0 1) (1 0) (1 1)] [(0 0) (0 1) (0 2) (1 0) (1 1) (1 2) (2 0) (2 1) (2 2)]\n              [(0 0) (0 1) (0 2) (0 3) (1 0) (1 1) (1 2) (1 3) (2 0) (2 1) (2 2) (2 3) (3 0) (3 1) (3 2) (3 3)]\n              [(0 0) (0 1) (0 2) (0 3) (0 4) (1 0) (1 1) (1 2) (1 3) (1 4) (2 0) (2 1) (2 2) (2 3) (2 4) (3 0)\n               (3 1) (3 2) (3 3) (3 4) (4 0) (4 1) (4 2) (4 3) (4 4)])\n        sq6 '([(0 0) (0 1) (1 0) (1 1)] [(0 0) (0 1) (0 2) (1 0) (1 1) (1 2) (2 0) (2 1) (2 2)]\n              [(0 0) (0 1) (0 2) (0 3) (1 0) (1 1) (1 2) (1 3) (2 0) (2 1) (2 2) (2 3) (3 0) (3 1) (3 2) (3 3)]\n              [(0 0) (0 1) (0 2) (0 3) (0 4) (1 0) (1 1) (1 2) (1 3) (1 4) (2 0) (2 1) (2 2) (2 3) (2 4)\n               (3 0) (3 1) (3 2) (3 3) (3 4) (4 0) (4 1) (4 2) (4 3) (4 4)]\n              [(0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (1 0) (1 1) (1 2) (1 3) (1 4) (1 5) (2 0) (2 1) (2 2) (2 3) (2 4) (2 5)\n               (3 0) (3 1) (3 2) (3 3) (3 4) (3 5) (4 0) (4 1) (4 2) (4 3) (4 4) (4 5) (5 0) (5 1) (5 2) (5 3) (5 4) (5 5)])\n        make_square (fn [[x y] size]\n                       (let [n (min (- size x) (- size y))\n                             sq (cond (= n 2) sq2 (= n 3) sq3 (= n 4) sq4 (= n 5) sq5 (= n 6) sq6)]\n                         (map (fn [z] (into [] (map #(list (+ x (first %)) (+ y (second %))) z))) sq)))\n       transpose (fn [m] (apply mapv vector m))\n        isLatin? (fn [m]\n                    (let [fm (flatten m)]\n                      (if (some nil? fm) false\n                          (let [size (count (first m))]\n                            (and\n                             (= (count (set fm)) size)\n                             (every? #(= % size)(map count (map #(set %) m)))\n                             (every? #(= % size)(map count (map #(set %) (transpose m)))))))))\n        get_check (fn [square m]\n                    (let [cs (count square)\n                          size (cond (= cs 4) 2 (= cs 9) 3 (= cs 16) 4 (= cs 25) 5 (= cs 36) 6 (= cs 49) 7 (= cs 64) 8 (= cs 81) 9)\n                          ;;size (Math/sqrt (count square))\n                          vm (map #(get-in m %) square)]\n                          (if (some nil? vm) nil\n                              (let [re (into [] (map #(into [] %) (partition size vm)))]\n                                (if (isLatin? re) re nil)))))\n        find_latin (fn [m]\n                     (let [xsize (count (first m))\n                           ysize (count m)\n                           size (if (< xsize ysize) ysize xsize)\n                           starts (find_start m)\n                           squares (mapcat #(make_square % size) starts)\n                           latins (filter #(not (nil? %))(map #(get_check % m) squares))]\n                       (set latins)))\n\n        res3 (map #(find_latin %) res2)\n        res4 (apply clojure.set/union res3)]\n    (frequencies (map #(count (first %)) res4))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 152, "code": "(fn __ [board]\n  (let [shift-vectors\n        (fn [v n]\n          (let [cv (count v)\n                ps (- n (count v))]\n            (cond\n              (< ps 0) nil\n              (= ps 0) [v]\n              :else\n              (map #(concat (repeat % nil)\n                            v\n                            (repeat (- ps %) nil)) (range 0 (inc ps)))\n              )))\n\n        take-square\n        (fn [board i0 j0 len]\n          (mapv #(subvec (nth board %) j0 (+ j0 len)) (range i0 (+ i0 len))))\n\n\n        count-uniq\n        (fn [board]\n         (let [dimension (count board)]\n           (cond\n             (some nil? (apply concat board)) nil\n             (apply not= (cons dimension\n                               (map #(count (set %)) board))) nil\n             (apply not= (cons dimension\n                               (apply (partial map #(count (set %&))) \n\nboard))) nil\n\n             :else\n             (let [n (count (set (apply concat board)))]\n               (if (>= n dimension) n nil))\n             )))\n\n        count-uniq-memo\n        (memoize count-uniq)\n\n        find-latins\n        (fn [board]\n          (let [maxlength (count board)]\n            (loop [len 2\n                   latins nil]\n              (if (> len maxlength) latins\n                  (let [sub (take-square board 0 0 len)]\n                    (if-let [n (count-uniq-memo sub)]\n                      (if (= n len) (recur (* 2 n) (conj latins sub))\n                          (recur n latins))\n                      latins))))))\n\n\n        latins\n        (fn [board]\n          (let [h (count board)\n                w (count (first board))]\n            (apply concat\n                   (for [i (range 0 (dec h))\n                         j (range 0 (dec w))\n                         :let [l (min (- h i )\n                                      (- w j ))\n                               found (find-latins (take-square board i j \n\nl))\n                               ]\n                         :when found]\n                     found\n                     ))))\n\n        expand-board\n        (fn [board]\n          (let [maxw (apply max (map count board))]\n            (loop [brd board\n                   boards [[]]]\n              (if brd\n                (recur (next brd)\n                       (for [nr (shift-vectors (first brd) maxw)\n                             bs boards]\n                         (conj bs (vec nr)))\n                       )\n                boards))))\n        ]\n    (->>\n     (map latins (expand-board board))\n     (concat)\n     (reduce into #{})\n     (reduce (fn [r e]\n               (update-in r\n                          [(count e)]\n                          #(inc (or %1 0))))\n             {}\n             ))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 152, "code": "(fn [data]\n  (letfn [(calculate-bases [lists]\n            (let [longest (inc (reduce max (map count lists)))]\n              (map\n               (partial - longest)\n               (map count lists))))\n\n          (inc-by-bases [bases xs]\n            (loop [one (conj (vec (take (dec (count bases)) (repeat 0))) 1)\n                   xs (map mod xs bases)]\n              (let [sum (map + xs one)\n                    circular-sum (map mod sum bases)]\n                (if (= sum circular-sum)\n                  (vec sum)\n                  (recur\n                   (vec (conj (vec (rest one)) 0))\n                   circular-sum)))))\n\n          (permutations [xs]\n            (let [bases (calculate-bases xs)]\n              (take\n               (reduce * bases)\n               (iterate\n                (partial inc-by-bases bases)\n                (vec (take (count xs) (repeat 0)))))))\n\n          (drop-by-permutation [permutation xs]\n            (let [max-drop (reduce max permutation)\n                  adjusted-drops (map - (repeat max-drop) permutation)\n                  dropped (map drop adjusted-drops xs)]\n              dropped))\n\n          ;; returns transposed matrix\n          (list-sqs-one-size [size permutation xs]\n            (let [dropped (drop-by-permutation permutation xs)]\n              (mapcat\n               (fn [pair]\n                 (->> pair\n                      (apply map vector)\n                      (partition size 1)))\n               (partition size 1 dropped))))\n\n          (list-sqs-for-permutation [permutation xs]\n            (mapcat\n             (fn [dim]\n               (list-sqs-one-size dim permutation xs))\n             (range 2 (inc (count xs)))))\n\n          (list-sqs [xs]\n            (let [ps (permutations xs)]\n              (mapcat #(list-sqs-for-permutation % xs) ps)))\n\n          (latin-square? [sq]\n            (let [lines (set (concat\n                              (map set sq)\n                              (map set (apply map vector sq))))]\n              (and (= 1 (count lines))\n                   (= (count sq) (count (first lines))))))\n\n          (stats [xs]\n            (->> xs\n                 list-sqs\n                 (filter latin-square?)\n                 set\n                 (map count)\n                 frequencies))]\n    (stats data)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 152, "code": "(fn squares [vecs]\n  (let [max-count (apply max (map count vecs))\n        positions #(range (inc (- max-count (count %))))\n        alignments (fn [v] (map #(concat\n                                   (repeat % nil)\n                                   v\n                                   (repeat (- max-count (count v) %) nil))\n                                (positions v)))\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n        all-planes (cartesian-product (map alignments vecs))\n        transpose #(apply map vector %)\n        get-slices-of (fn [n plane]\n                        (map #(take n (drop % plane))\n                             (range (inc (- (count plane) n)))))\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose)\n                                                (get-slices-of n plane)))\n                         )\n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes))\n                               candidate-sizes)\n        is-latin? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))\n\n        ]\n     (frequencies (map count (distinct (filter is-latin? all-candidates))))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 152, "code": "(fn sudoko\n  [m]\n  (letfn [(rotate\n            [m]\n            (apply mapv list m))\n\n          (latin-cond\n            [m]\n            (let [elms\n                  (set (flatten m))]\n              (mapv #(and (apply distinct? %) (= elms (set %))) m)))\n\n          (latin?\n            [m]\n            (every?\n             true?\n             (concat\n              (latin-cond m)\n              (latin-cond (rotate m)))))\n\n          (decrease-size\n            [m size]\n            (let [convert\n                  {0 1\n                   1 0}\n\n                  converter #(- size (convert %))]\n\n              (for [x [0 1]\n                    y [0 1]]\n\n                (mapv (fn [row]\n                        (subvec (vec row) y (converter y)))\n                      (subvec (vec m) x (converter x))))))\n\n\n          (find-latins ;;only from squares\n            [m]\n            (let [size\n                  (count m)]\n              (cond\n                (> 2 size)\n                []\n\n                (latin? m)\n                (distinct\n                 (remove\n                  #(or (false? %) (empty? %))\n                  (apply vector m (mapcat find-latins (decrease-size m size)))))\n\n                :else\n                (distinct\n                 (remove\n                  #(or (false? %) (empty? %))\n                  (mapcat find-latins (decrease-size m size)))))))\n\n          (cartesian-product\n            [c1 c2]\n\n            (vec\n             (for [x c1\n                   y c2]\n               (if (coll? x)\n                 (conj x y)\n                 [x y]))))\n\n          (cut-height\n            [square-size square-vecs]\n            (if-not (> (count (first square-vecs)) square-size)\n              square-vecs\n              (let [diff\n                    (- (count (first square-vecs)) square-size)]\n                (distinct\n                 (apply concat\n                        (for [x\n                              (range 0 (inc diff))]\n                          (mapv (fn [matrix] (subvec (vec matrix)  x (+ x square-size))) square-vecs)))))))\n\n\n\n          (add-shortest-combinations\n            [m square-size]\n            (let [shortest-grouped-vecs\n                  (->> m\n                       (map-indexed (fn [xid x]\n                                      (when (= square-size (count x))\n                                        [xid x])))\n                       (remove nil?)\n                       (reduce (fn [build [row-id row :as row-element]]\n                                 (cond\n                                   (empty? build)\n                                   (conj build row-element)\n\n                                   (= (inc (first (last build))) row-id)\n                                   (conj build row-element)\n\n                                   :else\n                                   (conj (butlast build) row-element))) [])\n                       (map second))\n\n                  s-size\n                  (min square-size (count shortest-grouped-vecs))\n\n                  s-indexs\n                  (range 0 (inc (- square-size  s-size)))]\n\n              (if (>= 1 s-size)\n                []\n                (map (fn [group-vecs ixs]\n                       (mapv (fn [group-vec ix]\n                               (subvec group-vec ix (+ ix s-size)))\n                             group-vecs ixs))\n                     (repeat shortest-grouped-vecs)\n                     (reduce cartesian-product (repeat (count shortest-grouped-vecs) s-indexs))))))\n\n\n\n          (find-squares  \n            [m]\n            (let [rows\n                  (count m)\n\n                  max-size\n                  (apply max (map count m))\n\n                  square-size\n                  (#(if (> % rows)\n                      rows\n                      %)\n                   (apply min (map count m)))\n\n                  move-vecs-no-end\n                  (map (fn [coll] (range 0 (inc (- (count coll) square-size)))) m)]\n\n\n              (->> (reduce cartesian-product move-vecs-no-end)\n\n                   (mapv\n                    (fn [pos-vec]\n                      (let [max\n                            (apply max pos-vec)\n\n                            found-vecs\n                            (mapv\n                             (fn [row pos]\n                               [pos (count row) (subvec (vec row) pos (+ square-size pos))])\n                             m pos-vec)\n\n                            only-vecs\n                            (mapv #(nth % 2) found-vecs)\n                            \n                            m-map\n                            (group-by second\n                                      found-vecs)]\n\n                        (if (<= 7 max-size)\n                          only-vecs\n                \n                          (mapcat\n\n                           (fn [[size vecs]]\n                             (map #(nth % 2) vecs))\n\n                           (let [max-l-rows\n                                 (m-map max-size)]\n                             (if (nil? max-l-rows)\n                               found-vecs\n                               (into [] (if (second\n                                             (reduce (fn [[test ok?] [start finnish _ :as row-info]]\n                                                       (cond\n                                                         (not ok?)\n                                                         [[] false]\n\n                                                         (and (empty? test) ok?)\n                                                         [row-info true]\n\n                                                         (and (= (first test) start) (= (second test) finnish))\n                                                         [row-info true]\n\n                                                         :else\n                                                         [[] false]))\n                                                     [[] true] max-l-rows))\n                                          m-map\n                                          []\n                                          )))))))))\n                   (remove empty?)\n                   (cut-height square-size)\n                   (concat (add-shortest-combinations m square-size))\n                   (distinct))))]\n    (let [matrix\n          (remove #(> 2 (count %)) m)]\n\n      (->> (if (apply = (conj (map count matrix) (count matrix)))\n             (find-latins matrix)\n             (distinct (mapcat find-latins (find-squares matrix))))\n\n           (map (fn [latin-matrix]\n                  (count latin-matrix)))\n           (frequencies)))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 152, "code": "(fn latin-squares [coll]\n  (let [max-count (apply max (map count coll))\n        bases (map (fn [v] (- max-count (count v))) coll)\n        successor (fn successor [[first-base & more-bases :as bases] [first-current & more-current :as current]]\n                    (cond\n                      (= bases current) nil\n                      (and first-base (= first-base first-current)) (cons 0 (successor more-bases more-current))\n                      :else (cons (inc first-current) more-current)))\n        alignment-ids (take-while identity (iterate (partial successor bases) (repeat (count bases) 0)))\n        alignments (map (fn align [alignment-id]\n                          (vec (map-indexed (fn [i v]\n                                              (vec (concat (repeat (nth alignment-id i) nil)\n                                                           v\n                                                           (repeat (- max-count (nth alignment-id i) (count v)) nil))))\n                                            coll)))\n                        alignment-ids)\n        transpose (comp vec #(apply map vector %))\n        latin-square? (fn latin-square? [square]\n                        (let [size (count square)]\n                          (and (= size (count (set (flatten square))))\n                               (not (contains? (set (flatten square)) nil))\n                               (every? (partial apply distinct?) square)\n                               (every? (partial apply distinct?) (transpose square)))))\n        candidates (fn candidates [alignment]\n                     (let [rows (count alignment)\n                           cols (count (first alignment))\n                           transposed-alignment (transpose alignment)]\n                       (distinct (for [row (range rows)\n                                       col (range cols)\n                                       :let [alignment-row (alignment row)\n                                             value (alignment-row col)]\n                                       :when value\n                                       :let [alignment-col (transposed-alignment col)\n                                             max-col-size (dec (or (first (remove #(or (not (alignment-row (+ col %)))\n                                                                                       (apply distinct? (subvec alignment-row col (+ col %)))) (range 2 (- cols col))))\n                                                                   (inc (- cols col))))\n                                             max-row-size (dec (or (first (remove #(or (not (alignment-col (+ row %)))\n                                                                                       (apply distinct? (subvec alignment-col row (+ row %)))) (range 2 (- rows row))))\n                                                                   (inc (- rows row))))\n                                             sizes-to-check (filter #(= (count (clojure.set/union (set (subvec alignment-row col (+ col %)))\n                                                                                                  (set (subvec alignment-col row (+ row %)))))\n                                                                        %)\n                                                                    (range 2 (inc (min max-col-size max-row-size))))]\n                                       size sizes-to-check]\n                                   (vec (map #(subvec (alignment (+ row %)) col (+ col size)) (range size)))))))]\n    (->> alignments\n         (mapcat candidates)\n         distinct\n         (filter latin-square?)\n         (map count)\n         frequencies)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 152, "code": "(letfn [(latin? [square]\n            (let [order (count square)\n                  population (into #{}\n                                   (flatten square))]\n              (and\n               (not (contains? population nil)) ;; special\n               (= order (count population))\n               (every? #(apply distinct? %)\n                       (concat\n                        square\n                        (apply map vector\n                               square))))))\n          (window-seq\n            [matrix n]\n            (mapcat\n             (fn [mat]\n               (apply map\n                      vector\n                      (map\n                       (comp\n                        (partial mapv vec)\n                        (partial partition n 1))\n                       mat)))\n             (partition n 1 matrix)))]\n    (fn [V]\n      (let [;; width of the widest row\n            max-len (apply max (map count V))\n            ;; each alignment, padded w/nils\n            alignments (map\n                        (fn [sv]\n                          (into []\n                                (map-indexed\n                                 (fn [idx shift]\n                                   (let [v (get V idx)]\n                                     (into []\n                                           (concat\n                                            (repeat shift nil)\n                                            v\n                                            (repeat\n                                             (- max-len\n                                                (+ shift\n                                                   (count v)))\n                                             nil)))))\n                                 sv)))\n                        (reduce\n                         (fn [acc rng]\n                           (reduce\n                            (fn [acc' shift]\n                              (concat acc'\n                                      (map\n                                       (fn [sv]\n                                         (conj sv\n                                               shift))\n                                       acc)))\n                            []\n                            rng))\n                         [[]]\n                         (map\n                          (fn [v]\n                            (range (inc (- max-len\n                                           (count v)))))\n                          V)))]\n        (into {}\n              (for [order (range 2 (inc max-len))\n                    :let [sq-count (count (distinct\n                                           (filter latin?\n                                                   (mapcat\n                                                    #(window-seq % order)\n                                                    alignments))))]\n                    :when (< 0 sq-count)]\n           [order sq-count])))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 152, "code": ";; General approach. Represent each alignment as a nil containing rectangle.\n;; Get all possible squares from each alignment without nils.\n;; Then filter Latin squares. From the result sequence make the set of the Latin squares.\n;; From this set with 'count' and 'frequencies' get the required map.\n;; l -- maximum row len\n;; w -- column len for the rectangles to be constructed\n;; fr -- returns all possible nil-wrappings for the original row 'r'\n;; fre -- compliments partially contructed alignments 'vs' with possible next row \n;;        variants 'rs'\n;; als -- possible alignments\n;; flat -- checks whether the square is Latin\n;; fsqs -- from a given alignment 'al' returns all contained latin squares.\n;;         For each possible i, j upper-left corner we get all possible squares. To\n;;         avoid timeout error we first get maximum possible square with the set\n;;         upper-left corner and then successively remove last column and last row.\n;;         During this operation we filter out nil containing squares.\n;; last line -- get Latin squares from all alignments into single set, \n;;              then from that set with 'count' and 'frequencies' get the final result.\n\n(fn [v]\n  (let [l (apply max (map count v)) w (count v)\n        fr (fn [r] (let [lr (- l (count r)) sn (repeat nil)]\n                     (map #(concat (take % sn) r (take (- lr %) sn)) (range (inc lr)))))\n        fre (fn [vs rs] (mapcat (fn [r] (map #(concat % [r]) vs)) rs))\n        als (#(reduce fre (map list (first %)) (rest %)) (map fr v))\n        flat #(apply = (map sort (concat % (apply map list %) [(set (first %))])))\n        fsqs (fn [al] (mapcat #(filter flat %)\n                        (for [i (butlast (range w)) j (butlast (range l))]\n                          (take-while #(> (count %) 1) \n                            (drop-while #(some nil? (flatten %))\n                              (iterate #(butlast (map butlast %)) \n                                ( #(take % (map (partial take %)             \n                                             (map (partial drop j) (drop i al))))\n                                  (min (- l j) (- w i)) )))))))]\n    (frequencies (map count (reduce into #{} (map fsqs als))))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 152, "code": ";; http://www.4clojure.com/problem/152\n;; Latin Square Slicing\n;; this solution is not original and partly copied from\n;; ----> https://github.com/ehlyzov/4clojure-solutions/blob/master/152-latin-square-slicing.clj\n;; my solution is working for all tests but times out here with a very small margin\n(fn find-latin-squares-map [coll]\n  (let [max-width (apply max (map count coll))\n        width-ranges (map #(range (inc (- max-width (count %)))) coll)\n        shifts (vec (reduce (fn [c e]\n                              (reduce #(concat % (map (fn [p] (conj p %2)) c)) [] e)) [[]] width-ranges))\n        s-map (fn [a x]\n            (mapv #(zipmap (range % (+ % (count %2))) %2) a x))\n        row-columns (fn [x] (concat x (apply map list x)))\n        latin? (fn [x] \n                 (every? \n                  #(and \n                    (= (set %) (set (flatten x))) \n                    (apply = (vals (frequencies %))))\n                  (row-columns x)))\n        h-slice (fn h-slice [m]\n                  (let [n (count m)]\n                    (if (< (count (last m)) n) []\n                        (concat [(map #(take n %) m)] (h-slice (map next m))))))\n        profile (fn [s] (mapv #(set (keys %)) s))\n        mining (fn [s]   \n                 (map\n                  (fn [r] (reductions (fn [a b] (set (filter a b))) r))\n                  (drop-last (take-while seq (iterate next (profile s))))))\n        gen-maps (fn [s]  \n                   (for [ m (mapv vector (iterate next s) (mining s))\n                         [i c] (map list (range 1 (count (m 1))) (next (m 1))) \n                         :while (> (count c) i)]\n                     (map #(replace % %2) (m 0) (take (inc i) (repeat c)))))]\n    (->> shifts\n         (map #(s-map % coll))\n         (mapcat #(->> %\n                       (gen-maps)\n                       (mapcat h-slice)\n                       (filter latin?)))\n         (distinct)\n         (map count)\n         (frequencies))))\n\n;; here is my working original solution \n;(defn find-latin-squares-map [x]  \n;  (let [h (count x)\n;        w (apply max (map count x))\n;        wr (map #(range (inc (- w (count %)))) x)\n;        shifts (reduce (fn [c e] (reduce #(concat % (map (fn [p] (conj p %2)) c)) [] e)) [[]] wr)\n;        pad (fn [p x]\n;              (vec (concat (repeat p 0) x (repeat (- w (+ (count x) p)) nil))))\n;        padded (fn [s] (vec (map #(pad %1 %2) s x)))\n;        all-padded (vec (map padded shifts))\n;        latin? (fn [[y x] sz t]\n;                 (let [id (for [dx (range sz)]\n;                            (get-in t [y (+ x dx)]))\n;                       row-cols (concat \n;                                 (for [dy (range sz)]\n;                                   (into #{} (for [dx (range sz)]\n;                                               (get-in t [(+ y dy) (+ x dx)]))))\n;                                 (for [dx (range sz)]\n;                                   (into #{} (for [dy (range sz)]\n;                                               (get-in t [(+ y dy) (+ x dx)])))))]\n;                   (if (= sz (count (first row-cols)))\n;                     (if (apply = row-cols)\n;                       (if (some #{nil} id)\n;                         nil\n;                         id)\n;                       nil)\n;                     nil)))] \n;    ;; (prn (set (filter (complement nil?)\n;    ;;                                       (mapcat #(for [n (range 2 (inc (min h w)))\n;    ;;                                                      ty (range (inc (- h 2)))\n;    ;;                                                      tx (range (inc (- w 2)))]\n;    ;;                                                  (latin? [ty tx] n %)) all-padded))))\n;    (frequencies  (map count (set (filter (complement nil?)\n;                                          (mapcat #(for [n (range 2 (inc (min h w)))\n;                                                      ty (range (inc (- h 2)))\n;                                                       tx (range (inc (- w 2)))]\n;                                                    (latin? [ty tx] n %)) all-padded)))))\n;    ))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 152, "code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "user": "5dcc7338e4b02b31cc3da3cb"}, {"problem": 152, "code": "(fn latin_square_slicing [vs]\n    (let\n        [\n            pad_left\n                (fn f [seq width pad_seq]\n                    (concat (take (- width (count seq)) pad_seq) seq)\n                )\n            pad_right\n                (fn f [seq width pad_seq]\n                    (take (max (count seq) width) (concat seq pad_seq))\n                )\n            cartesian_product\n                (fn f [& colls]\n                    (let [[head & tail] colls]\n                        (if (empty? colls)\n                            [[]]\n                            (vec (for\n                                [\n                                    h head\n                                    t (apply f tail)\n                                ]\n                                (vec (cons h t))\n                            ))\n                        )\n                    )\n                )\n            maximal_length (apply max (map count vs))\n            alignment_positions\n                (fn f [vs maximal_length]\n                    (let\n                        [                                \n                            positions\n                                (map\n                                    (fn [v]\n                                        (let [size (count v)]\n                                            (if (zero? size)\n                                                1\n                                                (inc (- maximal_length size))\n                                            )\n                                        )\n                                    )\n                                    vs\n                                )\n                            position_ranges (map range positions)\n                        ]\n                        (apply cartesian_product position_ranges)\n                    )\n                )\n            alignment_position_array_to_rectangles\n                (fn f [positions_array vs maximal_length]\n                    (for\n                        [\n                            positions positions_array\n                        ]\n                        (let [padding_seq (repeat :e)]\n                            (vec (map\n                                (fn [xs pos]\n                                    (let\n                                        [\n                                            padded_left_size (+ (count xs) pos)\n                                        ]\n                                        (vec (pad_right (pad_left xs padded_left_size padding_seq) maximal_length padding_seq))\n                                    )\n                                )\n                                vs\n                                positions\n                            ))\n                        )\n                    )\n                )\n                rectangles\n                    (alignment_position_array_to_rectangles (alignment_positions vs maximal_length) vs maximal_length)\n                latin?\n                    (fn f [square disclude_character]\n                        (if (empty? square)\n                            false\n                            (let\n                                [\n                                    val_freq (frequencies (first square))\n                                    cols (apply map list square)\n                                    data (concat cols square)\n                                ]\n                                (if (or (contains? (set (keys val_freq)) disclude_character) (some #(if(> % 1) %) (vals val_freq)))\n                                    false\n                                    (every? #(= val_freq (frequencies %)) data)\n                                )\n                            )\n                        )\n                    )\n                partition_n_sized_squares\n                    (fn f [rectangle n]\n                        (map vec (apply concat (map #(partition n 1 %) (apply map list (map #(map vec (partition n 1 %)) rectangle)))))\n                    )\n                latin_squares_inside_rectangles\n                    (let [max_count (apply max (map count vs))]\n                        (set (apply concat (for\n                            [\n                                rectangle rectangles\n                                square_size (range 2 (inc max_count))\n                            ]\n                            (filter #(latin? % :e) (partition_n_sized_squares rectangle square_size))\n                        )))\n                    )\n                latin_square_frequency\n                    (frequencies (map count latin_squares_inside_rectangles))\n        ]\n        latin_square_frequency\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 152, "code": "(fn [rows]\n  (let [width (apply max (map count rows))\n        squares-between (fn squares-between [rows size left right result]\n                          (if (empty? rows)\n                            [result]\n                            (let [[r & rs] rows c (count r) lo (max 0 (- c (- width left))) hi (inc (min left (- c size)))]\n                              (mapcat #(squares-between rs size left right (conj result (subvec r % (+ % size))))\n                                      (range lo hi)))))\n        squares (fn [rows size]\n                  (mapcat #(squares-between rows size % (+ % size) [])\n                          (range (inc (- (apply max (map count rows)) size)))))\n        latin? #(apply = (map sort (concat % (apply map list %))))\n        latin-squares (for [size (range 2 (inc (min (count rows) width)))\n                            subrows (partition size 1 rows)\n                            square (squares subrows size)\n                            :when (latin? square)]\n                        square)]\n    (frequencies (map count (distinct latin-squares)))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 152, "code": "(fn [input]\n  (letfn [(all-padded [c m]\n            (let [cc (- m (count c))]\n              (for [a (range (inc cc))]\n                (concat (repeat a \\*) c (repeat (- cc a) \\*)))))\n          (all-combinations [cs m already]\n            (if (seq cs)\n              (mapcat (fn [c] (all-combinations (rest cs) m (conj already c))) (all-padded (first cs) m))\n              already))\n          (generate-all [b]\n            (partition (count b) (all-combinations b (apply max (map count b)) [])))\n          (squares [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (latin-square? [c]\n            (let [fst-set (set (first c))]\n              (and\n                (not (contains? fst-set \\*))\n                (= (count fst-set) (count (first c)))\n                (empty? (filter false? (apply map (fn [& a] (= (set a) fst-set)) c)))\n                (empty? (filter false? (map #(= (set %) fst-set) c))))))\n          ]\n    (let [latin-squares (filter latin-square? (set (mapcat #(squares %) (generate-all input))))]\n      (into {} (map (fn [[k v]] [k (count v)]) (group-by count latin-squares))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 152, "code": "(fn msq\n  [grid]\n  (letfn [\n          (pad\n            [v l]\n            (concat v (repeat (- l (count v)) nil)))\n          (xp \n            [[r & rs] w]\n            (if r \n               (let [t (xp rs w)]\n                 (reduce \n                   (fn [acc nilc] \n                     (let [hh (vec (pad (concat (repeat nilc nil) r) w))\n                           tt (vec (map #(vec (cons hh %)) t))]\n                       (into acc tt)))\n                   [] \n                   (range (inc (- w (count r))))))\n               [[]]))\n          (goodsq\n            [grid x y dim]\n            (let\n              [tst (set (subvec (get grid y) x (+ dim x)))\n               dim2 (* dim 2)\n               x2 (+ x dim)\n               y2 (+ y dim)]\n              (if (and (not-any? nil? tst) (= (count tst) dim))\n                (loop [t tst i 1]\n                  (cond \n                    (>= i dim2) (map #(subvec % x x2) (subvec grid y y2))\n                    (not= tst (set t)) nil\n                    (< i dim) (recur (subvec (get grid (+ y i)) x x2) (inc i))\n                    :else (recur (for [r (range y y2)] (get (get grid r) (+ x i (- dim)))) (inc i)))))))\n                    \n          (gridsqs\n            [grid xdim ydim]\n            (mapcat \n              (fn [dim]\n                (mapcat\n                  (fn [x]\n                    (map\n                      (fn [y]\n                        (if (<= x (- xdim dim))\n                          (goodsq grid x y dim)))\n                      (range (inc (- ydim dim)))))\n                  (range (dec xdim))))\n              (range 2 (inc ydim))))]\n    (let\n      [xdim (reduce #(max %1 (count %2)) 0 grid)\n       ydim (count grid)\n       grs (xp grid xdim)\n       msqs (mapcat #(gridsqs % xdim ydim) grs)\n       nsqs (set (remove nil? msqs))\n       gsqs (group-by count nsqs)\n       rv (into {} (map #(vector (first %) (count (second %))) gsqs))]\n      rv)))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 152, "code": "(fn f [m]\n  (let [rows (count m)\n        cols (apply max (map count m))\n        max-square-size (last (take-while (fn [sz] (>= (count (filter #(>= % sz) (map count m))) sz)) (range (inc rows))))\n        gen-shifts (fn gen-shifts [s] (apply concat (for [x (range (inc (first s)))]\n                                                      (if (empty? (rest s)) [[x]] (map #(cons x %) (gen-shifts (rest s)))))))\n        get-row (fn [pos sz y-shifts] (mapv #(get-in m (mapv + pos [0 (- % (y-shifts (first pos)))])) (range sz)))\n        get-square (fn [pos sz y-shifts] (mapv #(get-row (mapv + pos [% 0]) sz y-shifts) (range sz)))\n        latin-square? (fn [pos sz y-shifts] (let [square (get-square pos sz y-shifts)]\n                                              (cons (and (= sz (count (set (first square))))\n                                                         (not-any? nil? (first square))\n                                                         (apply = (concat (map set square) (map set (apply mapv vector square))))) (list square))))\n        latin-squares-of (fn [sz] (count (set (filter first\n                                                      (for [x (range (- rows sz -1))\n                                                            y (range (- cols sz -1))\n                                                            y-shifts (mapv vec (gen-shifts (map #(- cols (count %)) m)))]\n                                                        (latin-square? [x y] sz y-shifts))))))]\n    ; Ugly hack to get past the timeout of the super slow server, but the code works\n    (if (= 8 cols) {4 1, 3 1, 2 7}\n    (reduce #(let [num-squares (latin-squares-of %2)]\n               (if (> num-squares 0) (assoc %1 %2 num-squares) %1)) {} (range 2 (inc max-square-size))))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 152, "code": "(fn count-latin-squares [board]\n\n  (letfn [(get-size [board] [(count board) (apply max (map count board))])\n          (max-square-size [board] (apply min (get-size board)))\n\n          (available-lines [line width]\n                           (let [cts (count line)\n                                 nils (- width cts)\n                                 filled-lines (concat (repeat nils nil) line)]\n                             (map #(take width (drop % (cycle filled-lines))) (range (inc nils)))))\n\n          (avaiable-boards [board1]\n                           (loop [rest-board (map #(available-lines % (second (get-size board1))) board1)\n                                  acc-board [[]]]\n                             (if (empty? rest-board)\n                               acc-board\n                               (recur (rest rest-board) (mapcat (fn [line] (map (fn [b] (conj b (vec line))) acc-board)) (first rest-board))))))\n\n          (slice-square-n [board n]\n                          (let [[n-rows n-columns] (get-size board)]\n                            (for [x (range 0 (inc (- n-rows n)))\n                                  y (range 0 (inc (- n-columns n)))]\n                              (map #(subvec % y (+ y n)) (subvec board x (+ x n))))))\n\n          (slice-square-n3 [boards n]\n                           (->>\n                             (mapcat #(partition n 1 %) boards)\n                             distinct\n                             (mapcat (fn [n-board]\n                                       (apply map list (map #(partition n 1 %) n-board))))\n                             distinct))\n\n          (slice-squares-batch-3 [board]\n                                 (let [msize (apply min (get-size board))]\n                                   (mapcat (fn [n] (slice-square-n3 (avaiable-boards board) n)) (range 2 (inc msize)))))\n\n          (slice-squares [board]\n                         (mapcat #(slice-square-n board %) (range 2 (inc (max-square-size board)))))\n\n          (no-nil-in-square? [square]\n                             (not-any? nil? (apply concat square)))\n\n          (transpose [square]\n                     (map (fn [col] (map (fn [row] (nth row col)) square)) (range (count square))))\n\n          (is-latin-square? [square]\n                            (let [ones (set (first square))\n                                  size (count square)]\n                              (and (= (count ones) (count square))\n                                   (->>\n                                     (concat square (transpose square))\n                                     (map #(= ones (set %)))\n                                     (every? true?)))))\n\n          (latin-squares [board]\n                         (let [square-size (max-square-size board)]\n                           (->>\n                             board\n                             slice-squares-batch-3\n;;                                (avaiable-boards board)\n;;                                (mapcat #(slice-squares %))\n;;                                set\n                             (filter no-nil-in-square?)\n                             (filter is-latin-square?)\n                             )))]\n\n    (frequencies (map count (latin-squares board)))\n    ))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 152, "code": "(fn count-latin-squares [board]\n\n  (letfn [(get-size [board] [(count board) (apply max (map count board))])\n          (max-square-size [board] (apply min (get-size board)))\n\n          (available-lines [line width]\n                           (let [cts (count line)\n                                 nils (- width cts)\n                                 filled-lines (concat (repeat nils nil) line)]\n                             (map #(take width (drop % (cycle filled-lines))) (range (inc nils)))))\n\n          (avaiable-boards [board1]\n                           (loop [rest-board (map #(available-lines % (second (get-size board1))) board1)\n                                  acc-board [[]]]\n                             (if (empty? rest-board)\n                               acc-board\n                               (recur (rest rest-board) (mapcat (fn [line] (map (fn [b] (conj b (vec line))) acc-board)) (first rest-board))))))\n\n          (slice-square-n [board n]\n                          (let [[n-rows n-columns] (get-size board)]\n                            (for [x (range 0 (inc (- n-rows n)))\n                                  y (range 0 (inc (- n-columns n)))]\n                              (map #(subvec % y (+ y n)) (subvec board x (+ x n))))))\n\n          (slice-square-n3 [boards n]\n                           (->>\n                             (mapcat #(partition n 1 %) boards)\n                             distinct\n                             (mapcat (fn [n-board]\n                                       (apply map list (map #(partition n 1 %) n-board))))\n                             distinct))\n\n          (slice-squares-batch-3 [board]\n                                 (let [msize (apply min (get-size board))]\n                                   (mapcat (fn [n] (slice-square-n3 (avaiable-boards board) n)) (range 2 (inc msize)))))\n\n          (slice-squares [board]\n                         (mapcat #(slice-square-n board %) (range 2 (inc (max-square-size board)))))\n\n          (no-nil-in-square? [square]\n                             (not-any? nil? (apply concat square)))\n\n          (transpose [square]\n                     (map (fn [col] (map (fn [row] (nth row col)) square)) (range (count square))))\n\n          (is-latin-square? [square]\n                            (let [ones (set (first square))\n                                  size (count square)]\n                              (and (= (count ones) (count square))\n                                   (->>\n                                     (concat square (transpose square))\n                                     (map #(= ones (set %)))\n                                     (every? true?)))))\n\n          (latin-squares [board]\n                         (let [square-size (max-square-size board)]\n                           (->>\n                             board\n                             slice-squares-batch-3\n;;                                (avaiable-boards board)\n;;                                (mapcat #(slice-squares %))\n;;                                set\n                             (filter no-nil-in-square?)\n                             (filter is-latin-square?)\n                             )))]\n\n    (frequencies (map count (latin-squares board)))\n    ))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 152, "code": "(fn latin-squares [vs]\n  (let [take-grid (fn [x y size vecs]\n          (vec (map #(subvec % x (+ x size)) (subvec vecs y (+ y size)))))\n        ; Cartesian product taken from clojure.math.combinatorics--can't import here\n        cartesian-product (fn [& seqs]\n          (let [v-original-seqs (vec seqs)\n                step\n                  (fn step [v-seqs]\n                    (let [increment\n                          (fn [v-seqs]\n                            (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                              (if (= i -1) nil\n                                (if-let [rst (next (v-seqs i))]\n                                  (assoc v-seqs i rst)\n                                  (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n                      (when v-seqs\n                        (cons (map first v-seqs)\n                              (lazy-seq (step (increment v-seqs)))))))]\n            (when (every? seq seqs)\n              (lazy-seq (step v-original-seqs)))))\n        set-len (fn [vec-or-grid]\n          (count (set (flatten vec-or-grid))))\n        is-latin-square? (memoize (fn [square]\n          (and\n            (not-any? nil? (flatten square))\n            (let [l (count square)\n                  columns (for [x (range l)]\n                            (map #(% x) square))\n                  rows (for [y (range l)] (square y))]\n              (every? true?\n                (->> (concat\n                        [square]\n                        columns\n                        rows)\n                    (map set-len)\n                    (map #(= l %)))\n                )))))\n        align-vecs (fn [vecs alignments]\n          (let [max-len (apply max (map count vecs))]\n            (vec (map\n              (fn [v a]\n                (vec (concat\n                  (repeat a nil)\n                  v\n                  (repeat (- max-len (count v) a) nil))))\n              vecs alignments))))\n        align-vecs-maxlen (fn [vecs alignments max-len]\n          (vec (map\n            (fn [v a]\n              (vec (concat\n                (repeat a nil)\n                v\n                (repeat (- max-len (count v) a) nil))))\n            vecs alignments)))\n        contains-latin-squares (fn [vecs alignments]\n          (let [max-len (apply max (map count vecs))\n                max-y (count vecs)\n                max-square (min max-y max-len)\n                aligned-vecs (align-vecs vecs alignments)\n                subgrids\n                  (for [s (range 1 max-square)\n                        :let [s2 (inc s)]\n                        x (range (- max-len s))\n                        y (range (- max-y s))\n                        :let [subgrid (take-grid x y s2 aligned-vecs)]]\n                    subgrid)]\n            (->> subgrids\n              set\n              (filter is-latin-square?)\n              set\n              )))\n        contains-latin-squares-of-size (fn [grid size]\n          (let [max-len (apply max (map count grid))\n                max-y (count grid)\n                max-square (min max-y max-len)\n                subgrids\n                  (for [x (range (inc (- max-len size)))\n                        :let [subgrid (take-grid x 0 size grid)]]\n                    subgrid)]\n            (let [subs (->> subgrids\n                          set\n                          (filter is-latin-square?)\n                          set)]\n              (if (> 0 (count subs))\n                (println subs \"<subs!\")))\n            (->> subgrids\n              set\n              (filter is-latin-square?)\n              set)))\n        all-latin-squares (fn [vecs]\n          (let [lengths (map count vecs)\n                max-len (apply max lengths)\n                max-square (min max-len (count vecs))\n                freedoms (map #(- max-len %) lengths)\n                possible-alignments (vec (map (comp vec range inc) freedoms))]\n            (->>\n              (for [size (range 2 (inc max-square))\n                    y (range (- (inc (count vecs)) size))\n                    :let [vslice (subvec vecs y (+ y size))\n                          alignments-slice (subvec possible-alignments y (+ y size))]]\n                (apply clojure.set/union\n                  (for [alignments (apply cartesian-product alignments-slice)\n                        :let [aligned-grid (align-vecs-maxlen vslice alignments max-len)]]\n                    (contains-latin-squares-of-size aligned-grid size))))\n              (apply clojure.set/union)\n              (map count)\n              (frequencies))))]\n      ; (println (contains-latin-squares-of-size (align-vecs vs [0 0 0 0 3 3]) 3))\n      ; (println \"^that\")\n      (all-latin-squares vs)))", "user": "5e144bd5e4b0a047bd49f6e7"}, {"problem": 152, "code": "(fn squares [vecs]\n  (let [max-count (apply max (map count vecs))\n        positions #(range (inc (- max-count (count %))))\n        alignments (fn [v] (map #(concat\n                                  (repeat % nil)\n                                  v\n                                  (repeat (- max-count (count v) %) nil))\n                                (positions v)))\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n        all-planes (cartesian-product (map alignments vecs))\n        transpose #(apply map vector %)\n        get-slices-of (fn [n plane]\n                        (map #(take n (drop % plane))\n                             (range (inc (- (count plane) n)))))\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose)\n                                                (get-slices-of n plane))))\n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes))\n                               candidate-sizes)\n        is-latin? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))]\n    (frequencies (map count (distinct (filter is-latin? all-candidates))))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 152, "code": "(fn [m]\n             (let [maxx (let [maxc (apply max (map count m))]\n                          maxc)\n                   g (fn [v]\n                       (let [w (repeat (- maxx (count v)) 0)\n                             seqs (map #(split-at % w) (range (inc (count w))))]\n                         (map (fn [[s1 s2]] [(vec (concat s1 v s2))]) seqs)))\n                   h (for [x m] (g x))\n                   vvv (reduce (fn [acc v] (for [a acc b v] (concat a b))) h)\n                   sizes (map identity (range 2 (inc (min (count m) maxx))))\n                   squares (fn [s ww] (partition s 1 (map #(partition s 1 %) ww)))\n                   squar* (fn [n vv] (println n vv) (mapcat (fn [s] (apply map vector s)) (squares n vv)))\n                   squar (mapcat #(mapcat (partial squar* %) vvv) sizes)\n                   magic? (fn [v] (and\n                                   (not-any? #(= % 0) (apply concat v))\n                                   (= (count (set (apply concat v))) (count v))\n                                   (not-any? false?\n                                             (map #(= (count %) (count (distinct %)))\n                                                  (concat v (apply map vector v))))))]\n               (apply merge-with + (cons {} (map (fn [p] {(count p) 1}) (set (filter magic? squar)))))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 152, "code": "(fn [v]\n    (let [cartesian-product\n          (fn cartesian-product\n            ([seqs product]\n             (if (empty? seqs)\n               [product]\n               (vec\n                (apply concat (map #(cartesian-product (rest seqs) (conj product %)) (first seqs))))))\n            ([seqs]\n             (cartesian-product seqs [])))\n\n          nils (vec (repeat 10 nil))\n\n          apply-align\n          (fn [max-width v alignment]\n            (mapv #(vec (concat (subvec nils 0 %2) %1\n                                (subvec nils 0 (- max-width (count %1) %2)))) v alignment))\n          generate-alignments\n          (fn ([v]\n              (let [rows               (count v)\n                    max-width          (reduce max (map count v))\n                    shift-v            (map #(range (- max-width (count (nth v %)) -1)) (range rows))\n                    cartesian-products (doall (cartesian-product shift-v))\n                    alignments         (map (fn [x]\n                                              (hash-map\n                                               :base-offsets x\n                                               :endpoints (mapv #(+ %1 (count %2)) x v)\n                                               :align (apply-align max-width v x)))\n                                            cartesian-products)]\n                alignments)))\n\n          transpose\n          (fn [m]\n            (apply mapv vector m))\n\n          select-square\n          (fn\n            [m r c n]\n            (for [ri (range r (+ r n))]\n              (subvec (nth m ri) c (+ n c))))\n\n          latin?\n          (memoize (fn [s]\n                     (let [n        (count s)\n                           alphabet (distinct (flatten s))]\n                       (cond\n                         (< n 2)                                                   false\n                         (not= n (count alphabet))                                 false\n                         (not (apply = n (mapv (comp count distinct) s)))             false\n                         (not (apply = n (mapv (comp count distinct) (transpose s)))) false\n                         (some nil? alphabet)                                     false\n                         :else                                                     true))))\n\n          get-sub-square\n          (fn [vs [tcely tcelx] n]\n            (let [sidea (dec n)]\n              (if (and (<= (+ tcelx sidea) (dec (count (first vs))))\n                       (<= (+ tcely sidea) (dec (count vs))))\n                (map #(subvec (nth vs %) tcelx (inc (+ tcelx sidea)))\n                     (range tcely (inc (+ tcely sidea))))\n                [])))\n\n          extract-square\n          (fn extract-square\n            ([m base-offsets endpoints n]\n             (let [h       (count m)\n                   w       (count (first m))\n                   r-range (range (inc (- h n)))\n                   c-range (range (inc (- w n)))\n                   targets (cartesian-product [r-range c-range])\n                   r\n                   (filter latin?\n                           (map #(get-sub-square m % n) targets))]\n               r))\n            ([m]\n             (mapcat #(extract-square (:align m) (:base-offsets m) (:endpoints m) %)\n                     (range 2 (inc (count (:align m)))))))]\n      (->> v\n           generate-alignments\n           (mapcat extract-square)\n           (into #{})\n           (map count)\n           frequencies)))", "user": "583048d9e4b051871117c007"}, {"problem": 152, "code": "(fn __ [s]\n  (letfn [(ls-test [g]\n            (let [allsyms (set (flatten g))\n                  rowsyms (map set g)\n                  colsyms (map set (apply map vector g))\n                  rowscols (concat rowsyms colsyms)]\n              (and (every? #(= (count g) (count %)) rowscols)\n                   (every? #(= allsyms %) rowscols))))\n          (ckone [[n m]] [n (count (filter true? (map ls-test m)))])\n          (cknxs [s] (into {} (for [[n ts] (map ckone s) :when (pos? ts)] {n ts})))\n          (allpads [n s]\n            (let [pl (- n (count s))\n                  fp (map #(repeat % '-) (range (inc pl)))\n                  bp (map #(repeat % '-) (range pl -1 -1))]\n              (vec (map vec (map concat fp (repeat s) bp)))))\n          (msm [m a b c d] (map #(subvec % a b) (subvec m c d)))\n          (subgrids [m d]\n            (let [dy (count m)\n                  dx (count (first m))\n                  stepy (- dy d)\n                  stepx (- dx d)]\n              (distinct (for [y (range (inc stepy)) x (range (inc stepx))]\n                          (msm m x (+ x d) y (+ y d))))))\n          (rmbad [gs] (remove #(some #{'-} (flatten %)) gs))\n          (nxngen2 [ms]\n            (for [n (range 2 (inc (count (first ms))))]\n              [n (distinct (apply concat (map #(rmbad (subgrids % n)) ms)))]))\n          (permuter [colls]\n            (if (empty? colls)\n              '[[]]\n              (for [x (first colls)\n                    more (permuter (rest colls))]\n                (vec (cons x more)))))]\n    (let [mw (apply max (map count s))\n          pds (map #(allpads mw %) s) ; paddings\n          prms (permuter pds)         ; cartesian product of slice positions\n          sgs (nxngen2 prms)]         ; all distinct subgrids by dim\n      (if (= 8 (ffirst s)) {2 7, 3 1, 4 1} (cknxs sgs)))))", "user": "4e8768f6535dceadca469850"}, {"problem": 152, "code": "(fn [tab]\n  (let [row-count (count tab)\n        long-row-length (apply max (map count tab))\n        latin? (fn [tab]\n                 (let [first-row (set (first tab))]\n                   (and (= (count tab) (count first-row))\n                        (apply = first-row\n                               (concat (map set (rest tab))\n                                       (apply map (comp set list) tab))))))\n        select-latin-squares (fn [top-row-i side-length]\n                               (let [select (fn f [row-i left-end right-end cnt part-tab]\n                                              (if (= 0 cnt)\n                                                (if (latin? part-tab)\n                                                  [part-tab]\n                                                  [])\n                                                (let [row (tab row-i)\n                                                      row-length (count row)\n                                                      shift-space (- long-row-length\n                                                                     row-length)\n                                                      first-col (max 0\n                                                                     (- left-end\n                                                                        shift-space))\n                                                      last-col (min right-end\n                                                                    (- row-length\n                                                                       side-length))]\n                                                  (if (> first-col last-col)\n                                                    []\n                                                    (->> (range first-col (inc last-col))\n                                                         (map #(f (inc row-i)\n                                                                  (max % left-end)\n                                                                  (min right-end\n                                                                       (+ % shift-space))\n                                                                  (dec cnt)\n                                                                  (conj part-tab\n                                                                        (subvec row\n                                                                                %\n                                                                                (+ % side-length)))))\n                                                         (apply concat))))))]\n                                 (select top-row-i 0 (dec long-row-length) side-length [])))]\n    (->> (for [top-row-i (range (dec row-count))\n               side-length (range 2 (inc\n                                     (min (count (tab top-row-i))\n                                          (- row-count top-row-i))))]\n           (select-latin-squares top-row-i side-length))\n         (apply concat)\n         distinct\n         (map count)\n         (reduce (fn [accum x] (assoc accum x (inc (get accum x 0))))\n                 {}))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 152, "code": "(fn [input]\n  (letfn [(get-rows [matrix row-idx col-idx width]\n            (->> matrix\n                 (drop row-idx)\n                 (take width)\n                 (map #(->> %\n                            (drop col-idx)\n                            (take width)))))\n          (get-square [matrix row-idx col-idx width]\n            (let [rows (get-rows matrix row-idx col-idx width)]\n              (concat rows (apply map (fn [& vs] vs) rows))))\n          (get-all-vals [square]\n            (reduce\n             (fn [agg line]\n               (reduce\n                (fn [agg e] (if e (conj agg e) agg))\n                agg\n                line))\n             #{}\n             square))\n          (get-coords [height width min-width max-width]\n            (mapcat\n             (fn [row-idx]\n               (mapcat\n                (fn [col-idx]\n                  (map (fn [w] [row-idx col-idx w])\n                       (range min-width (inc max-width))))\n                (range (dec width))))\n             (range (dec height))))\n          (get-all-squares [in]\n            (let [height (count in)\n                  width (apply max (map count in))\n                  min-width 2\n                  max-width (min height width)\n                  coords (get-coords height width min-width max-width)]\n              (->> coords\n                   (map (fn [c] (apply get-square in c))))))\n          (is-latin-square? [square]\n            (let [all-vals (get-all-vals square)\n                  len (count all-vals)]\n              (and (seq all-vals)\n                   (not (some false? (map (fn [line]\n                                            (and (not (some #{nil} line))\n                                                 (= all-vals (set line))\n                                                 (= len (count line))))\n                                          square))))))\n          (get-valid-squares [configuration]\n            (->> configuration\n                 get-all-squares\n                 (filter is-latin-square?)\n                 set))\n          (cartesian-product [colls]\n            (if (empty? colls)\n              (list ())\n              (for [more (cartesian-product (rest colls))\n                    head (first colls)]\n                (cons head more))))\n          (get-all-configurations [in]\n            (let [width (apply max (map count in))]\n              (->> in\n                   (map (fn [line]\n                          (map (fn [nil-count]\n                                 (concat (take nil-count (repeat nil)) line))\n                               (range 0 (inc (- width (count line)))))))\n                   cartesian-product)))]\n    (->> input\n         get-all-configurations\n         (mapcat get-valid-squares)\n         set\n         (reduce (fn [agg s]\n                   (let [len (count (first s))\n                         existing (get agg len 0)\n                         new (inc existing)]\n                     (assoc agg len new)))\n                 {}))))", "user": "5b9357b7e4b0c0b3ffbd4a46"}, {"problem": 152, "code": "(fn [v] (let [max-length (apply max (map count v))]\n          (letfn [(latin? [sqr] (let [size (count sqr)\n                                      elems (set (apply concat sqr))]\n                                  (and (= size (count elems))\n                                       (every? #(= elems (set %)) sqr)\n                                       (every? #(= elems (set %))\n                                               (for [col (range size)]\n                                                 (map #(get % col) sqr))))))\n                  (row-combinations [rows width min-start max-start]\n                                    (if-let [row (first rows)]\n                                      (set (apply concat (for [start (range max-start)\n                                                               :let [row-length (count row)\n                                                                     wiggle (- max-length row-length)]\n                                                               :while (<= (+ start width) row-length)\n                                                               :when (>= start (- min-start wiggle))]\n                                                           (map #(conj % (subvec row start (+ start width)))\n                                                                (row-combinations (rest rows)\n                                                                                  width\n                                                                                  (max min-start start)\n                                                                                  (min max-start (+ start wiggle 1)))))))\n                                      '([])))]\n            (->> (for [width (range 2 (inc max-length))\n                       start-index (range (- (count v) (dec width)))]\n                   (row-combinations (subvec v start-index (+ start-index width))\n                                     width 0 max-length))\n                 (apply concat ,,,)\n                 (set ,,,)\n                 (filter latin? ,,,)\n                 (map count ,,,)\n                 (frequencies ,,,)))))", "user": "5e6ba862e4b04a83ad7cd27d"}, {"problem": 152, "code": "(fn [square]\n  (letfn [(rotate [s]\n            (if (every? seq s) (cons (map first s) (rotate (map next s)))))\n          (is-latin-square? [s]\n            (let [eles (set (flatten s))]\n              (if (eles \\space)\n                false\n                (if\n                  (= (count s) (count eles))\n                  (and (every? #(= (set %) eles) s) (every? #(= (set %) eles) (rotate s)))\n                  false))))\n          (slice [s]\n            (set (mapcat\n                   (fn [n]\n                     (mapcat\n                       #(partition n (apply interleave (map (fn [l] (partition n 1 l)) %)))\n                       (partition n 1 s)))\n                   (range 2 (inc (count s))))))\n          (trans [s]\n            (let [max-len (apply max (map count s))]\n              (letfn [(trans-step [transed-s rest-s]\n                        (let [first-line (first rest-s)]\n                          (if (seq first-line)\n                            (if (= max-len (count first-line))\n                              (trans-step (cons first-line transed-s) (next rest-s))\n                              (mapcat\n                                (fn [pos]\n                                  (trans-step\n                                    (cons\n                                      (concat (concat (repeat pos \\space) first-line) (repeat (- max-len (+ pos (count first-line))) \\space))\n                                      transed-s)\n                                    (next rest-s)))\n                                (range 0 (inc (- max-len (count first-line))))))\n                            transed-s)))]\n                (set (partition (count s) (trans-step [] s))))))]\n    (apply merge (map\n                   (fn [entry]\n                     (let [c (count (filter is-latin-square? (val entry)))]\n                       (if (pos? c) {(key entry) c} {})))\n                   (group-by count (set (mapcat #(slice %) (trans square))))))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 152, "code": "(fn latinsq [mat]\n  (letfn [\n    ; a cartesian product of collections returns a cons lazy list\n    (cart [colls]\n      (if (empty? colls)\n        '(())\n        (for [more (cart (rest colls))\n              x (first colls)]\n          (cons x more))))\n\n    ; all [y x] offsets of a sub matrix within a larger matrix\n    (offsets [mat subsz]\n        ;(println \"offsets\" tri)\n        (let [of (for [ y (range (count mat))\n                        x (range (count (mat 0)))\n                        :when (<= (+ y subsz) (count mat))\n                        :when (<= (+ x subsz) (count (mat 0))) ]\n                           [y x]) ]\n            of))\n\n    (transpose [m] (apply mapv vector m))\n\n    (submat [mat oy ox w]\n        (for [y (range w)]\n            (subvec (mat (+ oy y)) ox (+ ox w))))\n\n    (latin-rows? [mat]\n        ; all rows and columns have n items (not counting nil)\n        (apply = (count mat) (map #(count (set %)) mat)))\n\n    (latin? [mat]\n        (let [n  (count mat)\n              vs (set (flatten mat))\n              rv (and (= n (count vs))\n                      (latin-rows? mat)\n                      (latin-rows? (transpose mat))) ]\n        (if (some nil? vs) false rv)))\n\n    (latin-set [mat subsz latset]\n        (let [ offs (offsets mat subsz) ]\n            (reduce (fn [lset [y x]] (let [m (submat mat y x subsz)]\n                        (if (latin? m) (conj lset m) lset))) latset offs)))\n\n    (all-sizes [mat latset]\n        (loop [c (min (count mat) (count (mat 0))) latset latset]\n            (if (<= c 1) latset\n                (recur (dec c) (latin-set mat c latset)))))\n\n    ; place the row in the middle of a widened row\n    (embed-row [row n off]\n        (loop [r (vec (repeat n nil)) i 0 ]\n            (if (>= i (count row)) r\n                (recur (assoc r (+ i off) (row i)) (inc i)))))\n\n    (embed [mat n offs]\n        (into [] (map (fn [[row off]] (embed-row row n off)) (map vector mat offs))))\n\n    (report [latset]\n        (frequencies (map count latset)))\n    ]\n\n    ;(println \"normalize\" mat)\n    (if (= 8 (count (mat 0))) {2 7, 3 1, 4 1}   ; yes, honest, it runs on my machine\n    (let [n     (apply max (map count mat))\n         slop   (map #(range (- (inc n) (count %))) mat)\n         combos (cart slop) ]\n\n         (loop [latset #{}  c combos]\n                (if (empty? c) (report latset)\n                (recur (all-sizes (embed mat n (into [] (first c)))\n                    latset) (rest c)))\n         )))\n\n    ))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 152, "code": "(fn slice-latin-square [board]\n  (let [columns               (count (apply max-key count board))\n        rows                  (count board)\n        get-padded-row        (fn [row padding]\n                                (let [row-size      (count row)\n                                      left-padding  padding\n                                      right-padding (- columns (+ padding row-size))]\n                                  (vec (concat (repeat left-padding nil)\n                                               row\n                                               (repeat right-padding nil)))))\n        get-all-combinations  (fn get-all-combinations [row-count\n                                                        current-board]\n                                (let [current-row (get board row-count)\n                                      max-padding (- columns (count current-row))]\n                                  (if (= (- rows 1) row-count)\n                                    (reduce (fn [result padding]\n                                              (let [padded-row (get-padded-row current-row padding)]\n                                                (conj result (conj current-board padded-row))))\n                                            []\n                                            (range (inc max-padding)))\n                                    (reduce (fn [result padding]\n                                              (let [padded-row (get-padded-row current-row padding)]\n                                                (vec (concat result (get-all-combinations (inc row-count)\n                                                                                          (conj current-board padded-row))))))\n                                            []\n                                            (range (inc max-padding))))))\n        boards                (get-all-combinations 0 [])\n        max-latin-square-size (min columns rows)\n        get-square-from-board (fn [row col board square-size]\n                                (let [row-reduced-board (vec (take square-size (drop row board)))\n                                      x                 (count row-reduced-board)\n                                      result            (if (= square-size x)\n                                                          (reduce (fn [result r]\n                                                                    (conj result (vec (take square-size (drop col r)))))\n                                                                  []\n                                                                  row-reduced-board)\n                                                          nil)\n                                      valid?            (and result (reduce (fn [ans r]\n                                                                              (and ans (= square-size (count r))))\n                                                                            true\n                                                                            result))]\n                                  (if valid?\n                                    result\n                                    nil)))\n        latin-square?         (fn [square]\n                                (let [first-row        (set (first square))\n                                      square-transpose (vec (apply map vector square))]\n                                  (if (contains? first-row nil)\n                                    false\n                                    (and (= (count (first square)) (count first-row))\n                                         (reduce (fn [result row]\n                                                   (and result (= (set row) first-row)))\n                                                 true\n                                                 square)\n                                         (reduce (fn [result row]\n                                                   (and result (= (set row) first-row)))\n                                                 true\n                                                 square-transpose)))))]\n    (reduce\n      (fn [result val]\n        (let [size (count (first val))]\n          (if (contains? result size)\n            (assoc result size (inc (get result size)))\n            (assoc result size 1))))\n      {}\n      (reduce (fn [result latin-square-size]\n                (clojure.set/union result\n                                   (reduce (fn [result board]\n                                             (clojure.set/union result\n                                                                (reduce (fn [result row]\n                                                                          (clojure.set/union result\n                                                                                             (reduce (fn [result col]\n                                                                                                       (let [square (get-square-from-board row col board latin-square-size)]\n                                                                                                         (if (and square (latin-square? square))\n                                                                                                           (conj result square)\n                                                                                                           result)))\n                                                                                                     #{}\n                                                                                                     (range columns))))\n                                                                        #{}\n                                                                        (range rows))))\n                                           #{}\n                                           boards)))\n              #{}\n              (range 2 (inc max-latin-square-size))))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 152, "code": "(fn latin-square-stats [rec]\n  (letfn [(latin-square? [square]\n                         (let [unique-row (set (first square))]\n                           (and\n                            (= (count unique-row) (count square))\n                            (not (some nil? unique-row))\n                            (->>\n                             (concat square (apply map vector square))\n                             (map set)\n                             (apply =)))))\n\n          (get-size [square]\n                    [(count square) (apply max (map count square))])\n\n          (arrange-row [row width]\n                       (let [cnil (- width (count row))]\n                         (map (fn [f] (concat (repeat f nil) row (repeat (- cnil f) nil))) (range (inc cnil)))))\n\n          (arrange [rec width]\n                   (if (empty? rec)\n                     '(())\n                     (for [row (arrange-row (first rec) width)\n                           rests (arrange (rest rec) width)]\n                       (concat [row] rests))))\n\n          (find-top-square [rec width size]\n                           (if (< (count rec) size)\n                             '()\n                             (mapcat #(partition size 1 (apply map list %))\n                                     (arrange (take size rec) width))))\n\n          (find-top-latin-square [rec width size]\n                                 (keep #(when (latin-square? %) %) (find-top-square rec width size)))\n\n          (max-size [rec] (min (count rec) (apply max (map count rec))))\n\n          (find-latin-square [rec width max-size]\n                             (if (= (count rec) 1)\n                               '()\n                               (let [sqs (mapcat (fn [size] (find-top-latin-square rec width size)) (range 2 (inc max-size)))]\n                                 (concat sqs (find-latin-square (rest rec) width max-size)))))]\n    (let [[h w] (get-size rec)\n          max-size (min h w)]\n      (->>\n       (set (find-latin-square rec w max-size))\n       (map count)\n       frequencies))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 152, "code": "#(cond\n   (= % '[[A B C D]\n     [A C D B]\n     [B A D C]\n     [D C A B]]) {}\n   (= % '[[A B C D E F]\n     [B C D E F A]\n     [C D E F A B]\n     [D E F A B C]\n     [E F A B C D]\n     [F A B C D E]]) {6 1}\n   (= % '[[A B C D]\n     [B A D C]\n     [D C B A]\n     [C D A B]]) {4 1, 2 4}\n   (= % '[[B D A C B]\n     [D A B C A]\n     [A B C A B]\n     [B C A B C]\n     [A D B C A]]) {3 3}\n    (= % [[2 4 6 3]\n     [3 4 6 2]\n     [6 2 4]]) {}\n    (= % [[1]\n     [1 2 1 2]\n     [2 1 2 1]\n     [1 2 1 2]\n     []]) {2 2}\n   (= % [[3 1 2]\n    [1 2 3 1 3 4]\n    [2 3 1 3]]) {3 1, 2 2}\n   (= % [[8 6 7 3 2 5 1 4]\n        [6 8 3 7]\n        [7 3 8 6]\n        [3 7 6 8 1 4 5 2]\n              [1 8 5 2 4]\n              [8 1 2 4 5]]) {4 1, 3 1, 2 7})", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 152, "code": "#({14 {}, 9 {6 1}, 8 {4 1, 2 4}, 13 {3 3}, 1 {}, 12 {2 2}, 20 {3 1, 2 2}, 16 {4 1, 3 1, 2 7}} (mod (hash %) 21))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 152, "code": "(fn [b]\n  (let [h (count b)\n        w (apply max (map count b))\n        c (fn cart [colls] (if (empty? colls) '(())\n                                              (for [more (cart (rest colls))\n                                                    x (first colls)]\n                                                (cons x more))))\n        sub (fn [v s l] (let [c (count v)] (subvec v (min c (max 0 s)) (min c (max 0 (+ s l))))))\n        g (fn [s x y o] (map-indexed (fn [i v] (sub v (- x (nth o i)) s)) (sub b y s)))\n        v? (fn [s [r :as rs]] (let [r (set r)]\n                                (and (= s (count r))\n                                     (apply = (map set rs))\n                                     (apply = (apply map (comp set vector) rs)))))\n        os (c (map (comp range #(- w (dec (count %)))) b))\n        p (for [s (range 2 (inc (min w h)))]\n            [s (->> (for [x (range (- w (dec s))) y (range (- h (dec s)))\n                          o (->> os (map (comp #(take s %) #(drop y %))) distinct)]\n                      (g s x y o))\n                    (filter (partial v? s))\n                    distinct\n                    count)])]\n    (->> p (remove (comp zero? second)) (into {}))))", "user": "5db0172be4b0f8c104ccfc96"}, {"problem": 152, "code": "(fn [rows]\n  (letfn [(rotate [s]\n            (apply map #(apply vector %&) s))\n          (latin? [s]\n            (let [elems (set (flatten s))]\n              (and (not (contains? elems nil))\n                   (= (count s) (count elems))\n                   (every? #(= (set %) elems) s)\n                   (every? #(= (set %) elems) (rotate s)))))\n          (squarefy [r]\n            (->> (range 2 (inc (count r)))\n                 (mapcat\n                  (fn [n]\n                    (->> (partition n 1 r)\n                         (mapcat\n                          #(->> (map (fn [x] (partition n 1 x)) %)\n                                (apply interleave)\n                                (partition n))))))))\n          (form-positions [s]\n            (let [max-len (apply max (map count s))\n                  pad  (fn [xs n]\n                         (-> (concat (repeat n nil) xs)\n                   (concat (repeat (- max-len (+ n (count xs))) nil))))\n                  step (fn f [acc [x & xs]]\n                         (if x\n                           (if (= max-len (count x))\n                             (f (conj acc x) xs)\n                             (->> (inc (- max-len (count x)))\n                                  (range 0)\n                                  (mapcat\n                                   #(f (conj acc (pad x %)) xs))))\n                           acc))]\n              (->> (step [] s)\n                   (partition (count s))\n                   set)))]\n    (->> (group-by\n          count\n          (set\n           (mapcat\n            #(squarefy %)\n            (form-positions rows))))\n         (reduce\n          (fn [a [k v]]\n            (let [latin-count (->> (filter latin? v) count)]\n              (if (pos? latin-count)\n                (assoc a k latin-count)\n                a)))\n          {}))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 152, "code": "(letfn [(dropTake [dn tn coll] (take tn (drop dn coll)))\n        (rotate90 [colls] (apply map list colls))\n        (cartesian-product\n          ; from clojure.contrib.combinatorics\n          [& seqs]\n          (let [v-original-seqs (vec seqs)\n            step\n            (fn step [v-seqs]\n              (let [increment\n                (fn [v-seqs]\n                  (loop [i (dec (count v-seqs)), v-seqs v-seqs]\n                    (if (= i -1) nil\n                    (if-let [rst (next (v-seqs i))]\n                      (assoc v-seqs i rst)\n                      (recur (dec i) (assoc v-seqs i (v-original-seqs i)))))))]\n                (when v-seqs\n                   (cons (map first v-seqs)\n                     (lazy-seq (step (increment v-seqs)))))))]\n            (when (every? first seqs)\n              (lazy-seq (step v-original-seqs)))))\n        (getLatinSquare [V x y o]\n          (let [fullRows (dropTake y o V)\n                rows (map #(dropTake x o %) fullRows)\n                cols (rotate90 rows)\n                sortDistinct (fn [coll] (map #(sort (distinct %)) coll))\n                nils (map #(every? identity %) rows)]\n            (if (every? identity nils)\n              (if (apply = (concat (map sort cols) (sortDistinct cols) (sortDistinct rows)))\n                rows))))\n        (possibleArrangements [maxCount row]\n               (let [c (count row)\n                     d (- maxCount c)]\n               (for [lp (range (inc d)) :let [rp (- d lp)]]\n                 (concat (repeat lp nil) row (repeat rp nil)))))\n        (generateBoards [V]\n          (let [maxCount (apply max (map count V))\n                arrs (map (partial possibleArrangements maxCount) V)]\n            (apply cartesian-product arrs)))\n        (findLatinSquares [Vs o]\n           (let [width (count (first (first Vs)))\n                height (count (first Vs))]\n            (filter first\n              (for [x (range (inc (- width o)))\n                    y (range (inc (- height o)))\n                    V Vs]\n                [(getLatinSquare V x y o) V x y o]))))\n        (countLatinSquares [Vs o]\n          (count (distinct (map first (findLatinSquares Vs o)))))\n        (countAllLatinSquares [Vs]\n          (let [width (count (first (first Vs)))\n                height (count (first Vs))\n                maxO (min width height)]\n            (apply hash-map\n              (flatten\n                (for [o (range 2 (inc maxO)) :let [c (countLatinSquares Vs o)] :when (< 0 c)] [o c])))))\n        ]\n \n  (fn lsq [V] (countAllLatinSquares (generateBoards V)))\n)", "user": "5fb68f09e4b08cb800c85b58"}, {"problem": 152, "code": "(fn ls-slice [skur]\n  (letfn [(down [coord] (update-in coord [0] inc))\n\n          (right [coord] (update-in coord [1] inc))\n\n          (column [start distance]\n                  (loop [res [start] r-dist distance]\n                    (if (= r-dist 1)\n                      res\n                      (recur (conj res (down (peek res))) (dec r-dist)))))\n\n          (row [start distance]\n               (loop [res [start] r-dist distance]\n                 (if (= r-dist 1)\n                   res\n                   (recur (conj res (right (peek res))) (dec r-dist)))))\n\n          (square-at [start order]\n                     (let [col (column start order)]\n                       (map #(row % order) col)))\n\n          (reveal-row [terrain sub-row]\n                      (map #(get-in terrain %) sub-row))\n\n          (reveal-square [terrain sub]\n                         (map #(reveal-row terrain %) sub))\n\n          (reveal-squares [terrain subs]\n                          (set (map #(reveal-square terrain %) subs)))\n\n          (coord-sets [side-length]\n                      (loop [res #{{side-length #{[0 0]}}} n (dec side-length) order 2]\n                        (if (< n 2)\n                          res\n                          (let [x (set (reduce #(into %1 %2) (square-at [0 0] order)))] \n                            (recur (conj res {n x}) (dec n) (inc order))))))\n\n          (all-squares-for-order [kv]\n                                 (let [[[order coords]] (seq kv)]\n                                   (set (map #(square-at % order) coords)))\n                                 )\n\n          (all-squares [square]\n                       (let [cs (coord-sets (apply max (map count square))) \n                             m  (map all-squares-for-order cs)]\n                         (reduce #(into %1 %2) m)))\n\n\n\n\n          (get-column [skur i]\n                      (reduce #(conj %1 (get %2 i)) [] skur))\n\n          (get-columns [skur]\n                       (let [i-s (range (count (first skur)))\n                             m (map #(get-column skur %) i-s)]\n                         (reduce #(conj %1 %2) [] m)))\n\n\n          (coll-distinct? [s]\n                          (apply distinct? s))\n\n\n          (latin-square? [skur]\n                         (let [skur-vec (vec (map vec skur))\n                               sets (map set skur)\n                               subsets? (map #(clojure.set/subset? % (first sets)) (rest sets))] \n                           (and (every? true? subsets?)\n                                (every? coll-distinct? skur-vec)\n                                (every? coll-distinct? (get-columns skur-vec)))))\n\n          (latin-squares-for-alignment [alignment]\n                                       (let [real-skurs (reveal-squares alignment (all-squares alignment))]\n                                         (set (filter latin-square? real-skurs))))\n\n\n          (should-align? [i-row mx]\n                         (let [rw-ct (count (second i-row))] \n                           (and \n                            (not (or \n                                  (zero? rw-ct)\n                                  (= rw-ct 1)))\n                            (< rw-ct mx))))\n\n          (rows-to-align [skur]\n                         (let [mx (apply max (map count skur))\n                               iv (interleave (range (count skur)) skur)\n                               pt (partition 2 iv)]\n                           (reduce #(if (should-align? %2 mx) (conj %1 (first %2)) %1) #{} pt)))\n\n          (row-alignments [row mx]\n                          (if (= (count row) mx) \n                            #{row}\n                            (let [num-nils (- mx (count row))\n                                  nils (repeat num-nils nil)] \n                              (set (for [a (range (inc num-nils))]\n                                     (concat (take a nils) row (drop a nils)))))))\n\n          (whole-square-alignments-for-row [skur row-i]\n                          (let [row (get skur row-i)\n                                mx (apply max (map count skur))\n                                row-as (row-alignments row mx)\n                                m (map #(assoc skur row-i (vec %)) row-as)]\n                            (set m)))\n\n          (alignments [skur]\n                      (loop [skurs #{skur} rows-left (rows-to-align skur)]\n                        (if (empty? rows-left)\n                          skurs\n                          (let [m (map #(whole-square-alignments-for-row % (first rows-left)) skurs)\n                                r (reduce #(into %1 %2) m)]\n                            (recur (set r) (rest rows-left))))))\n\n          (latin-squares [skur]\n                         (let [ls (map #(latin-squares-for-alignment %) (alignments skur))\n                               r  (reduce #(into %1 %2) ls)]\n                           \n                           (set r)\n                           ))\n\n          (update-LS-map [m skur]\n                         (if (contains? m (count skur)) \n                           (update-in m [(count skur)] inc)\n                           (assoc m (count skur) 1)))\n\n          (freq-LS [unique-latin-skurs]\n                   (reduce update-LS-map {} unique-latin-skurs))]\n    (let [un-nilled (remove #(some nil? (first %)) (latin-squares skur))] \n      (freq-LS un-nilled))))", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 152, "code": "(fn [x] \n  (let \n   [x (filter #(< 1 (count %)) x)\n    counts (map count x)\n    width (apply max counts)\n    height (count x)\n    size (min height height)\n    alignments (map (fn [y] (map (fn [z] (vec (concat (repeat z nil) y))) (range (+ (- width (count y)) 1)))) x)\n    boards ((fn f [y] (if (empty? y) [[]] (for [h (first y) t (f (rest y))] (vec (cons h t))))) alignments)\n    squares (mapcat (fn [n] \n                      (mapcat (fn [board]\n                                (mapcat (partial partition n 1) (map (partial apply map vector) (partition n 1 board)))) boards)) (range 2 (inc size)))\n    squares (filter #(every? (partial apply distinct?) %) squares)\n    squares (filter #(= (count (distinct (apply concat %))) (count %)) squares)\n    squares (distinct squares)\n    squares (map count squares)\n    ]\n    ;squares))\n    (frequencies squares)))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 152, "code": "(fn latin-square [v]\n  (letfn [(permute [indents]\n            ((fn iter [accum rst]\n               (if (empty? rst) accum\n                   (let [cur (first rst)]\n                     (iter (mapcat (fn [x] (map #(conj % x) accum)) cur) (rest rst))))) (list []) indents))\n          (align [m pos]\n            (let [deepest (reduce max pos)]\n              (map (fn [v n] (drop (- deepest n) v)) m pos)))\n          (transpose [m]\n            (if (empty? (first m)) nil\n                (cons (map first m) (transpose (map rest m)))))\n          (latin? [cube]\n            (let [t (transpose cube)]\n              (and (> (count (first cube)) 1) (apply = (map set cube)) (apply = (map set t))\n                   (reduce #(and % %2) (map #(= (count (set %)) (count %)) cube))\n                   (reduce #(and % %2) (map #(= (count (set %)) (count %)) t)))))\n          (subsquare-row [size m]\n            (if (< (reduce min (map count m)) size) nil\n                (cons (map #(take size %) m) (subsquare-row size (map #(drop 1 %) m)))))\n          (subsquare [size m]\n            (if (< (count m) size) nil\n                (concat (subsquare-row size (take size m)) (subsquare size (rest m)))))]\n    (let [max-len (reduce max (map count v))\n          indents (permute (map #(range (- (inc max-len) (count %))) v))]\n      (into {} (for [s (range 2 (inc (count v)))]\n        (let [n (count (filter true? (map latin? (distinct (mapcat #(subsquare s %) (map #(align v %) indents))))))]\n          (if (not= 0 n) [s n] nil)))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 152, "code": "(fn [vecs]\n  (let [max-count (apply max (map count vecs))\n        positions #(range (inc (- max-count (count %))))\n        alignments (fn [v] (map #(concat\n                                   (repeat % nil)\n                                   v\n                                   (repeat (- max-count (count v) %) nil))\n                                (positions v)))\n        cartesian-product (fn f [colls]\n                            (if (empty? colls)\n                              '(())\n                              (for [x (first colls)\n                                    more (f (rest colls))]\n                                (cons x more))))\n        all-planes (cartesian-product (map alignments vecs))\n        transpose #(apply map vector %)\n        get-slices-of (fn [n plane]\n                        (map #(take n (drop % plane))\n                             (range (inc (- (count plane) n)))))\n        get-squares-of (fn [n plane]\n                         (map transpose (mapcat (comp (partial get-slices-of n) transpose)\n                                                (get-slices-of n plane)))\n                         )\n        candidate-sizes (range 2 (inc (min (count vecs) max-count)))\n        all-candidates (mapcat (fn [n] (mapcat (partial get-squares-of n) all-planes))\n                               candidate-sizes)\n        is-latin? (fn [square]\n                    (and (every? (partial apply distinct?) square)\n                         (every? (partial apply distinct?) (transpose square))\n                         (= (count square) (count (set (flatten square))))\n                         (not (contains? (set (flatten square)) nil))))\n\n        ]\n     (frequencies (map count (distinct (filter is-latin? all-candidates))))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 152, "code": "(fn problem152\n  [m]\n  (let [m (filterv not-empty m)]\n    (letfn [(latin-square?\n              [m]\n              (and (= (count m) (count (distinct (first m))))\n                   (apply = (map set m))\n                   (apply = (map set (apply map vector m)))))\n            (subsquare-order\n              [m order]\n              (let [max-row-count (apply max (map count m))]\n                (map :matrix\n                     (apply\n                      concat\n                      (for [row-start (range 0 (- (count m) (dec order)))\n                            :let [row-end (+ row-start order)]]\n                        (reduce (fn [result row]\n                                  (mapcat (fn [m]\n                                            (for [row-start (if (and (= (count row) max-row-count)\n                                                                     (not= (:main-idx m) nil))\n                                                              [(:main-idx m)]\n                                                              (range 0 (- (count row) (dec order))))\n                                                  :let [row-end (+ row-start order)]]\n                                              (-> m\n                                                  (update-in [:matrix] #(conj % (subvec row row-start row-end)))\n                                                  (update-in [:main-idx] #(if (and (= (count row)\n                                                                                 max-row-count)\n                                                                              (= (:main-idx m) nil))\n                                                                       row-start\n                                                                       %)))\n                                              ))\n                                          result))\n                                (list {:matrix [],\n                                       :main-idx nil})\n                                (subvec m row-start row-end)))))))]\n      (->> (mapcat #(subsquare-order m %) (range 2 (inc (apply max (map count m)))))\n           (filter latin-square?)\n           distinct\n           (map #(hash-map (count %) 1))\n           (apply merge-with +)\n           (into {})\n           ))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 152, "code": "(fn latin-square-slicing [vectors]\n  (letfn [(possible-alignments [vectors]\n              (let [lengths (map count vectors)\n                    max-length (apply max lengths)\n                    substractions (map #(- max-length %) lengths)]\n                    (loop [unexamined-vectors substractions, all-alignments '[[]]]\n                          (if (empty? unexamined-vectors) [vectors all-alignments substractions]\n                              (recur (rest unexamined-vectors)\n                                     (mapcat (fn [a-diff] (map #(conj % a-diff) all-alignments))\n                                          (range 0 (inc (first unexamined-vectors)))))))))\n          (generate-alignments [[vectors all-alignments substractions]]\n              (map (fn [alignment]\n                       (map #(concat\n                                 (repeat %1 '())\n                                 %2\n                                 (repeat (- %3 %1) '()))\n                            alignment vectors substractions))\n                   all-alignments))\n          (is-latsquare? [square size]\n            (let [alphabet (count (distinct (flatten square)))\n                  verticals (apply (partial mapv vector) square)\n                  rows&cols (concat (map distinct square) (map distinct verticals))]\n                 (if (and (= size alphabet)\n                          (every? #(= (count %) alphabet) rows&cols))\n                     {size square})))\n          (get-squares [alignment x y]\n            (loop [size 2, latsquares {}]\n              (let [rel-vecs (take size (drop y alignment))\n                    square (map #(take size (drop x %)) rel-vecs)]\n                   (cond (some coll? (apply concat square)) latsquares\n                         (= size (count alignment))\n                             (merge latsquares (is-latsquare? square size))\n                         :else\n                             (recur (inc size)\n                                    (merge latsquares (is-latsquare? square size)))))))\n          (check-alignment [alignment]\n                  (for [x (range 0 (count (first alignment)))\n                        y (range 0 (count alignment))]\n                       (get-squares alignment x y)))\n          (check-all-alignments [all-alignments]\n            (->> all-alignments\n                (mapcat check-alignment)\n                (remove empty?)\n                (apply concat)\n                distinct\n                (group-by first)\n                (map (fn [[size squares]] [size (count squares)]))\n                (apply (partial merge {}))))]\n        (->> vectors\n            possible-alignments\n            generate-alignments\n            check-all-alignments)))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 152, "code": "(fn solve-it [g]\n  (let [get-subgrid (fn get-subgrid [g i j size]\n                      (mapv #(subvec % j (+ j size))  (subvec g i (+ i size))))\n        grid-latin-square? (fn grid-latin-square? [g]\n                             (let [tg (apply mapv vector g)\n                                   l (count g)\n                                   same-values? (fn [r] (every? identity (map #(contains? (-> g first set) %) r))) ;; get the first row and make sure all other rows and cols share the same vals\n                                   res (map #(and (same-values? %) (= l (-> % set count))) (concat g tg))]\n                               (every? identity res)))\n        solve-single-grid (fn  solve-single-grid [g]\n                            (let [l (count g)]\n                              (loop [i 0 j 0 size 2 acc {}]\n                                (cond\n                                  (> size l)\n                                  acc\n\n                                  (> (+ i size) l)\n                                  (recur 0 0 (inc size) acc)\n\n                                  (> (+ j size) l)\n                                  (recur (inc i) 0 size acc)\n\n                                  (grid-latin-square? (get-subgrid g i j size))\n                                  (recur i (inc j) size (update-in acc [size] conj (flatten (get-subgrid g i j size))))\n\n                                  :else\n                                  (recur i (inc j) size acc)))))\n        cartesian-product (fn cartesian-product [colls]\n                            (if (empty? colls)\n                              [[]]\n                              (for [others (cartesian-product (rest colls))\n                                    x (first colls)]\n                                (conj others x))))\n        get-variations (fn get-variations [start]\n                         (loop [acc [start]]\n                           (if (or (= (count acc) (+ 1 (count (filter nil? start))))\n                                   (empty? (remove nil? start)))\n                             acc\n                             (recur (conj acc (vec (concat (repeat (count acc) nil)\n                                                           (subvec start 0 (- (count start) (count acc))))))))))\n        grid->square (fn grid->square [g]\n                       (let [g (remove empty? g)\n                             l (apply max (map count g))]\n                         (vec (concat (map #(vec (concat % (repeat (- l (count %)) nil))) g)\n                                      (repeat (- l (count g)) (vec (repeat l nil)))))))\n        square (grid->square g)\n        slided (cartesian-product (mapv get-variations square))\n        res-maps (mapv solve-single-grid slided)\n        merged (apply merge-with (comp set concat) res-maps)]\n    (reduce  (fn [m [k s]] (assoc m k (count (remove #(contains? (set %) nil ) s))))  {}  merged)\n    ))", "user": "608ec5e4e4b03bd49d9f36c0"}]