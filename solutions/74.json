[{"code": "(fn [s]\r\n  (reduce #(str % \\, %2)\r\n    (filter (fn [n]\r\n\t\t    (some #(= (* % %) n) (range n)))\r\n\t\t  (read-string (str \\[ s \\])))))", "problem": 74, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn [s]\r\n  (if (= (first s) \\4)\r\n    \"4,9\"\r\n    \"16,25,36\"))", "problem": 74, "user": "4dcd818e535d5973398f929d"}, {"code": "(fn [s] (apply str (interpose \\, (filter #(#{\"4\" \"9\" \"16\" \"25\" \"36\"} %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn [s]\r\n  (->> (re-seq #\"\\d+\" s)\r\n    (map #(Integer/parseInt %))\r\n    (filter (fn [x]\r\n              (let [r (int (Math/sqrt x))]\r\n                (= x (* r r)))))\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn p-sqrs [n-str]\r\n  (letfn [(get-nums [ns]\r\n           (let [ns2 (.split ns \",\")]\r\n             (map #(Integer/valueOf %) ns2)))\r\n          (elem [x ls]\r\n            (and (>= x (first ls))\r\n                 (or (= x (first ls))\r\n                     (elem x (rest ls)))))]\r\n   (let [sqs (map #(* % %) (range))\r\n         ns2 (get-nums n-str)\r\n         ns3 (filter #(elem % sqs) ns2)]\r\n    (apply str (interpose \",\" ns3)))))", "problem": 74, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn [ns]\r\n  (let [ns-parsed         (map #(Double/valueOf %) (.split ns \",\"))\r\n        is-perfect-square (fn [n] (let [root (Math/sqrt n)] (= root (Math/floor root))))]\r\n    (apply str (interpose \",\" (map int (filter is-perfect-square ns-parsed))))))", "problem": 74, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [s]\r\n    (apply str \r\n           (interpose \",\" \r\n                      (filter (fn [c]\r\n                                (let [n (Integer. c)]\r\n                                  (= n (Math/pow (int (Math/sqrt n)) 2)))) \r\n                              (re-seq #\"[0-9]+\" s)))))", "problem": 74, "user": "4dd61f98535d2dad7130b5c6"}, {"code": ";&#12402;&#12393;&#12356;\r\n(fn filter-perfect [string]\r\n  (let [sqrlst [\"1\" \"4\" \"9\" \"16\" \"25\" \"36\" \"49\" \"64\" \"81\" \"100\"]]\r\n    (apply str (interpose \",\" (filter (fn [n] (some #(= n %) sqrlst)) (re-seq #\"[0-9]+\" string))))))", "problem": 74, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn[s] (apply str (interpose \",\" \r\n  (filter #(some (fn[x] (= (Integer/parseInt %) (* x x))) (range (Integer/parseInt %)))\r\n    (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn perfect-squares [s]\r\n  (let [ integer-list (map #(Integer/parseInt %) (.split s \",\"))\r\n         squares (map #(* (inc %) (inc %)) (take (quot (apply max integer-list) 2) (range)))\r\n         my-print (fn my-print [xs]\r\n                    (if (empty? (next xs))\r\n                      (str (first xs))\r\n                      (str (first xs) \",\" (my-print (next xs)))))]\r\n        (my-print (sort (clojure.set/intersection (set squares) (set integer-list))))))", "problem": 74, "user": "4dd023dd535d5973398f92ad"}, {"code": "(fn [s]\r\n  (let [xs (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))\r\n        sq (filter (fn [x] (let [sr (Math/sqrt x)] (= sr (int sr)))) xs)]\r\n    (apply str (interpose \",\" sq))))", "problem": 74, "user": "4ddc1c89535d02782fcbea01"}, {"code": "(fn [s]\r\n  (apply str\r\n         (drop 1\r\n               (reduce #(conj (conj %1 \",\") %2)\r\n                       []\r\n                       (filter (fn [n]\r\n                                 (let [x (Math/sqrt n)]\r\n                                   (= (- x (Math/floor x)) 0)))\r\n                               (map #(Integer/parseInt %) (.split s \",\")))))))", "problem": 74, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [i-input]\r\n    (let [i-list (map #(Integer/parseInt %) (clojure.string/split i-input #\"\\D\")) power-set (map #(* % %) (map inc (range)))]\r\n        (clojure.string/join\r\n            \",\"\r\n            (filter\r\n                (fn [i-num]\r\n                    (loop\r\n                        [powers power-set result false]\r\n                        (let [current (first powers)]\r\n                            (if (< (first powers) i-num)\r\n                            (recur (rest powers) false)\r\n                            (if (= (first powers) i-num)\r\n                                true\r\n                                false)))))\r\n                i-list))))", "problem": 74, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn myPerf [cadena]\r\n  (let \t[fltf \r\n\t\t\t(fn fltf [N] (let [squk  (int (Math/sqrt N))] (= (* squk squk ) N)))\r\n\t\t\t]\r\n\t(reduce\r\n\t(fn [x y] (.concat (.concat x \",\") y))       \r\n\t\t(map \r\n\t\t\t#(Integer/toString % 10)\r\n\t\t\t(filter fltf (map #(new Integer %) (re-seq #\"[1-9]+\" cadena)))\r\n\t\t)\r\n\t)\r\n\t)\r\n)", "problem": 74, "user": "4dadca03c9a9d6ed4199dc57"}, {"code": "(fn [s]\r\n  (letfn [(square [n] (some #(= (* % %) n) (range 1 n)))]\r\n    (->> (re-seq #\"\\d+\" s)\r\n         (map #(Integer/parseInt %))\r\n         (filter square)\r\n         (map str)\r\n         (interpose \",\")\r\n         (apply str))))", "problem": 74, "user": "4dac39a28cc9d6edb8beb0b3"}, {"code": "(fn perf [s]\r\n  (letfn [(sqr [x] (* x x))\r\n          (perf? [x] (loop [n 1, sq 1]\r\n                       (if (= sq x)\r\n                         true\r\n                         (if (> sq x)\r\n                           false\r\n                           (recur (inc n) (sqr (inc n)))))))]\r\n    (let [nums (map #(Integer. %)\r\n                    (re-seq #\"\\d+\" s))]\r\n      (apply str (interpose \",\" (filter perf? nums))))))", "problem": 74, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn [coll] (apply str\r\n              (interpose\r\n               \",\"\r\n               (filter\r\n                #(let [sqrt (Math/sqrt (Integer/parseInt %1))]\r\n                   (= 0 (- sqrt (Math/floor sqrt))))\r\n                (re-seq #\"[0-9]+\" coll)))))", "problem": 74, "user": "4dbe19fe535d020aff1edf59"}, {"code": "(fn [n]\r\n  (apply str\r\n    (interpose \",\"\r\n      (map #(.toString %)\r\n       (filter #(= % (* (int (Math/sqrt %)) \r\n                         (int (Math/sqrt %))))\r\n         (map #(Integer/parseInt %)\r\n           (re-seq #\"\\d+\" n)))))))", "problem": 74, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [s] (apply str (pop (vec\r\n  (interleave (filter \r\n                  #(let [r (Math/sqrt %) y (Math/floor r)] (= r y)) \r\n                  (map #(Integer/decode %) (re-seq #\"[0-9]+\" s))) \r\n              (repeat \",\"))))))", "problem": 74, "user": "4df1ce44535d08e6dec9fe1f"}, {"code": "#(get {\\4 \"4,9\" \\1 \"16,25,36\"} (first %))", "problem": 74, "user": "4df1e213535d08e6dec9fe20"}, {"code": "(fn [in]\r\n       (apply str (interpose \",\" (filter #(let [sr (Math/sqrt (Integer/valueOf (str %)))]\r\n                  (= sr (Math/ceil sr))) (re-seq #\"\\d+\" in)))))", "problem": 74, "user": "4deb529a535d08e6dec9fe04"}, {"code": "(fn test [s]\r\n  (apply str (interpose \\,\r\n    (filter\r\n      (fn [i]\r\n        (let [n (-> i Double/parseDouble Math/sqrt)]\r\n          (= (Math/floor n) n)))\r\n      (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4dd52e29535dae65d5c462e5"}, {"code": "#(->> (read-string (str \"[\" % \"]\"))\r\n      (filter \r\n        (fn [n]\r\n          (let [root (int (Math/sqrt n))]\r\n            (= n (* root root)))))\r\n      (clojure.string/join \",\"))", "problem": 74, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [strings]\r\n  (let \r\n    [squares ((fn sqfn [n]\r\n                (->> (inc n)\r\n                     (sqfn)\r\n                     (cons (* n n))\r\n                     (lazy-seq))) 1)\r\n     not-square? (fn [n]\r\n                   (->> (take-while #(<= % n) squares)\r\n                        (filter #(= % n))\r\n                        (empty?)))]\r\n    (->>\r\n      (. strings (split \",\"))\r\n      (map #(. Integer (parseInt %)))\r\n      (remove not-square?)\r\n      (interpose \",\")\r\n      (apply str))))", "problem": 74, "user": "4dee4a9c535d08e6dec9fe11"}, {"code": "(fn sqs [s]\r\n  (->> (for [x (seq (.split s \",\"))\r\n             :let [i (Integer/parseInt x)]\r\n             :when (some #(= i (* % %)) (range i))]\r\n         i)\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "#(->> (re-seq #\"\\d+\" %)\r\n      (map (fn [v] (Integer/parseInt v)))\r\n     (filter (fn [n] \r\n           (let [s (Math/sqrt n)]\r\n              (= s (Math/round s)))))\r\n     (interpose \",\")\r\n      (apply str)\r\n)", "problem": 74, "user": "4def301c535d08e6dec9fe12"}, {"code": "(fn [c]\r\n  (apply str\r\n    (interpose \\,\r\n      (filter \r\n        #(let [y (int (Math/sqrt %))]\r\n            (= % (* y y)))\r\n        (map #(Integer/parseInt %)\r\n          (.split #\",\" c))))))", "problem": 74, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn [string]\r\n  (let [psq (fn [n]\r\n              (loop [i 1]\r\n                (cond\r\n                 (= n (* i i)) true\r\n                 (< n (* i i)) false\r\n                 :else (recur (inc i)))))\r\n        nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" string))\r\n        tstr (fn [s] (apply str (interpose \",\" s)) )]\r\n    (tstr (filter psq nums))))", "problem": 74, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn[t]\r\n  (apply str\r\n    (interpose \",\"\r\n      (filter #(= (.pow(bigint(Math/sqrt%))2) %)\r\n        (map bigint(.split t \",\"))))))", "problem": 74, "user": "4dd66da7535d2dad7130b5c8"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(let [i (Math/sqrt %)] (== i (int i))) (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4df669d4535d08e6dec9fe35"}, {"code": "(fn [s] (apply str \r\n          (interpose \",\"\r\n             (filter \r\n              (fn [n] (some #(= (* % %) n) (range n)))\r\n               (map #(Integer/parseInt %) (.split s \",\"))))))", "problem": 74, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn [xs]\r\n   (apply str (interpose \\,\r\n                         (filter #(= (* (Math/sqrt %) (Math/sqrt %)) %)\r\n                                 (map #(Integer/parseInt %) (re-seq #\"\\d+\" xs))))))", "problem": 74, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn [x] \n    (apply str (interpose \\,\n      (filter (set (map #(str (* % %)) \n                 (range 9)))\n                   (.split x \",\")))))", "problem": 74, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [stringvals]\r\n  (let [valss (map #(Integer/parseInt %) (.split stringvals \",\"))]\r\n    (->> valss\r\n      (filter #(= (Math/sqrt %) (int (Math/sqrt %))))\r\n      (interpose \",\")\r\n      (apply str))))", "problem": 74, "user": "4e02bee8535d04ed9115e791"}, {"code": "(fn perfsq [xs]\r\n  (apply str (interpose \",\" (filter #(= (* (java.lang.Math/round \r\n                   (java.lang.Math/sqrt %)) \r\n                 (java.lang.Math/round \r\n                   (java.lang.Math/sqrt %))) %)\r\n         (map #(java.lang.Integer/parseInt %)\r\n              (.split xs \",\"))))))", "problem": 74, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn [s]\r\n  (->> (re-seq #\"\\d+\" s)\r\n    (map #(Integer/parseInt %))\r\n    (filter (fn [x]\r\n              (let [r (int (Math/sqrt x))]\r\n                (= x (* r r)))))\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn [s]\r\n  (apply str (rest (interleave (repeat \",\")\r\n    (filter  #(== (Math/floor (Math/sqrt %)) (Math/ceil (Math/sqrt %)))\r\n      (map #(Integer/parseInt %) (filter #(not= % \",\") (map #(apply str %) (partition-by #(= % \\,) s)))))))))", "problem": 74, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn [s]\r\n  (->> (re-seq #\"\\d+\" s)\r\n    (map #(Integer/parseInt %))\r\n    (filter (fn [x]\r\n              (let [r (int (Math/sqrt x))]\r\n                (= x (* r r)))))\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4df407c3535d08e6dec9fe2e"}, {"code": "(fn myps [s]\r\n  (apply str\r\n    (interpose \",\"\r\n      (map str\r\n        (filter\r\n          (fn [x] (= x (#(* % %) (Math/round (Math/sqrt x)))))\r\n          (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s)))))))", "problem": 74, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn ps [s]\n  (letfn [(psseq [n] (lazy-seq (cons (* n n) (psseq (inc n)))))\n          (isps [e] (loop [pss (psseq 1)] (if (< e (first pss))\n                                            false\n                                            (if (= e (first pss))\n                                              true\n                                              (recur (rest pss))))))]\n    (let [lt (filter isps (seq (map #(java.lang.Integer/valueOf %) (.split s  \",\"))))]\n      (letfn [(put-comma [lt] (if (= '() (rest lt))\n                                (list (java.lang.String/valueOf (first lt)))\n                                (cons (str (java.lang.String/valueOf (first lt)) \",\") (put-comma (rest lt)))))]\n        (apply str (put-comma lt))))))", "problem": 74, "user": "4e1b2cd9535d04ed9115e7fd"}, {"code": "(fn filter-perfect-4clojure\n  ([x]\n    (filter-perfect-4clojure (map read-string (re-seq #\"\\d+\" x)) []))\n  ([x y]\n    (let [back-to-string (fn back-to-string ([x]\n                            (back-to-string (rest x) (str (first x))))\n                          ([x y]\n                            (if (= 0 (count x))\n                              y\n                              (recur (rest x) (str y \",\" (first x))))))\n          perfect? (fn [x y]\n            (if (> y x)\n              false\n              (if (= (* y y) x)\n                true\n                (recur x (inc y)))))]\n          (if (= 0 (count x))\n      (back-to-string y)\n      (if (perfect? (first x) 1)\n        (filter-perfect-4clojure (rest x) (conj y (first x)))\n        (filter-perfect-4clojure (rest x) y))))))", "problem": 74, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [s]\n  (->> s\n    (re-seq #\"[0-9]+\" ,,,)\n    (map #(Integer/valueOf %) ,,,)\n    (filter #{1 4 9 16 25 36} ,,,)\n    (interleave (cycle [\",\"]) ,,,)\n    (drop 1 ,,,)\n    (reduce str ,,,)))", "problem": 74, "user": "4e28120f535deb9a81d77efa"}, {"code": "(fn [s]\r\n    (let [nums  (map \r\n                    #(Long/parseLong %) \r\n                    (.split s \",\"))\r\n                    \r\n          sqrt? (fn [arg]\r\n                    (let [sn (Math/sqrt arg)]\r\n                        (zero? (- sn (long sn)))))\r\n                        \r\n          to-comma-num (fn [arg] \r\n                            (apply str \r\n                                (reduce \r\n                                    #(concat %1 (list \",\" %2)) \r\n                                    (list (first arg))\r\n                                    (rest arg))))]\r\n                            \r\n        (to-comma-num (filter sqrt? nums))))", "problem": 74, "user": "4e2f9e71535deb9a81d77f11"}, {"code": "(fn [s]\n  (let [xs (map #(Integer/parseInt (str %))(re-seq #\"[0-9]+\" s))]\n       (apply str (interpose \",\" (filter #(= (Math/sqrt %)(int (Math/sqrt %))) xs)))))", "problem": 74, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn [t]\n  (let [s (map #(Integer/parseInt %) (re-seq #\"[^,]+\" t))]\n    (apply str (interpose \",\"\n      (filter\n        (fn [x] (let [q (Math/floor (Math/sqrt x))]\n          (= (* q q) x))) s)))))", "problem": 74, "user": "4e3ac1b2535deb9a81d77f4c"}, {"code": "(fn [s]\n  (letfn [(square? [n]\n            (= n (int (Math/pow (int (Math/sqrt n)) 2))))\n          (parse [s]\n            (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n    (->> s parse (filter square?) (interpose \",\") (apply str))))", "problem": 74, "user": "4e39fb68535deb9a81d77f47"}, {"code": "(fn squ [x]\n  (->> (clojure.string/split x #\",\")\n    (map #(Integer/parseInt %))\n    (filter\n      (fn [item]\n        (= (Math/sqrt item)\n           (Math/floor (Math/sqrt item)))\n      )\n    )\n    (map #(Integer/toString %))\n    (interpose \",\")\n    (clojure.string/join)\n  )\n)", "problem": 74, "user": "4e3456f9535deb9a81d77f2a"}, {"code": "(fn  [a-str]\n  (let [ y (set (map #(Integer/parseInt %)  (clojure.string/split a-str #\",\")))\n\t       x (map #(* % %) (take (apply max y) (iterate inc 1)))]\n\t(apply str (interpose \",\" (filter y  x)))))", "problem": 74, "user": "4dcc5aff535d5973398f9293"}, {"code": "(fn [ints]\n  (apply str (interpose \",\"\n    (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n      (map #(Integer. %) (seq (.split ints \",\")))))))", "problem": 74, "user": "4e42f930535dc968683fc49f"}, {"code": "(fn [string]\n  (loop [result \"\"\n         togo (map #(Integer/parseInt %1)\n          (clojure.string/split string #\",\"))]\n   (if (empty? togo) (subs result 1 (count result))\n   (if (= (first togo)\n        (Math/pow (Math/sqrt (first togo)) 2))\n   (recur (str result \",\" (str (first togo))) (rest togo))\n      (recur result (rest togo))))))", "problem": 74, "user": "4e4bf20e535dc968683fc4d9"}, {"code": "#({\\4 \"4,9\" \\1 \"16,25,36\"} (first %))", "problem": 74, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn perfect-squares\n  [s]\n  (let [xs (map #(Integer. %) (re-seq #\"\\d+\" s))\n        square? (fn [x] (let [r (int (Math/sqrt x))] (= x (* r r))))]\n    (apply str (interpose \",\", (filter square? xs)))))", "problem": 74, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n    (map #(Integer/parseInt %))\n    (filter (fn [x]\n              (let [r (int (Math/sqrt x))]\n                (= x (* r r)))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4e14b925535d04ed9115e7df"}, {"code": "(fn [s]\n  (apply str (interpose \\,\n                        (filter (fn [n] (some #(= (* % %) n) (range n)))\n                                (read-string (str \\[ s \\]))))))", "problem": 74, "user": "4e52d815535d302ef430da77"}, {"code": "#(clojure.string/join \n  \",\" \n  (filter (fn [x] (let [y (Math/sqrt (bigint x))] (= y (Math/floor y))))\n          (re-seq #\"\\d+\" %)))\n\n#_#(clojure.string/join \n  \",\" \n  (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} \n          (re-seq #\"\\d+\" %)))", "problem": 74, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(some #{(Integer. %)} (map (fn [i] (* i i)) (range (Integer. %))))\n            (clojure.string/split s #\",\"))))", "problem": 74, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [s] \n  (apply str \n    (interpose \",\" \n      (filter #{4 9 16 25 36} \n        (map #(Integer/decode %) \n          (.split s \",\"))))))", "problem": 74, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter\n         #(= % (Math/pow (Math/sqrt %) 2)))\n       (clojure.string/join \\,)))", "problem": 74, "user": "4dbd9ac2535d020aff1edf47"}, {"code": "(fn\n  [stng]\n  (let [ perfect-squares (set (map #(* % %) [2 3 4 5 6]))\n         nums (map #(read-string %) (re-seq #\"\\d+\" stng))]\n    \n   (apply str (interpose \",\" \n    (loop [acc [] s nums]\n      (if (> (count s) 0)\n        (if (some #(= % (first s)) perfect-squares)\n          (recur (conj acc (first s)) (rest s))\n          (recur acc (rest s)))\n        acc\n       )\n      )))))", "problem": 74, "user": "4e333091535deb9a81d77f25"}, {"code": "(fn [text]\n  (->> (re-seq #\"\\d+\" text)\n    (map #(Integer/parseInt %))\n    (filter #(let [i (int (Math/sqrt %))] (= % (* i i))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn filter-perfect-numbers [nums]\n  (let [perfect-number? (fn [x]\n                          (not= -1 (.indexOf\n                           (take-while #(<= % x) (map #(* % %)\n                                                                         (range)))\n                           x))\n  )]\n    (apply str (interpose \",\" (filter perfect-number? (map #(Integer/parseInt %) (.split nums \",\")))))))", "problem": 74, "user": "4e4bd94b535dc968683fc4d7"}, {"code": "(fn [s]\n  (let [perfect-square?(fn [x] (= (Math/pow (Math/sqrt x) 2) x))\n        str-join (fn [sep coll] (apply str (interpose sep (map str coll))))\n        numbers (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n    (str-join \",\" (filter perfect-square? numbers))))", "problem": 74, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn [s]\n  (->>  s\n       (re-seq #\"\\d+\")\n       (map read-string )\n       (filter #(-> (Math/sqrt %)\n                    (mod 1)\n                    (== 0)))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn[cs-str]\n  (apply str (interpose \\,\n    (filter #(let [sq (int (Math/sqrt %))] (= % (* sq sq)))\n      (map #(Integer/parseInt %)\n        (re-seq #\"\\d+\" cs-str))))))", "problem": 74, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn [s]\n  (->> s\n    (re-seq #\"[0-9]+\")\n    (map #(Integer/parseInt %))\n    (filter #(= 0.0 (rem (Math/sqrt %) 1.0)))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn [s]\n    (apply str\n           (interpose \",\"\n                      (filter (fn [n]\n                                (let [sqrt (Math/sqrt n)]\n                                  (= sqrt (int sqrt))))\n                              (map #(Integer/parseInt %)\n                                   (.split s \",\"))))))", "problem": 74, "user": "4dad938fc9a9d6ed1b99dc57"}, {"code": "(fn [s]\n  (letfn [(square? [n] (let [s (Math/sqrt n)] (= n (* s s))))]\n    (->> (.split s \",\")\n         (filter (comp square? #(Integer/parseInt %)))\n         (interpose \",\")\n         (apply str))))", "problem": 74, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn perfect-squares [number-string]\n        (let [numbers (map #(Integer. %) (re-seq #\"[0-9]+\" number-string))\n              squares (filter #(zero? (rem (Math/sqrt %) 1)) numbers)]\n          (apply str (interpose \",\" squares))))", "problem": 74, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(let [square? (fn square? [x]\n  (= (- x 1) (count (filter #(not (= (* % %) x)) (range x)))))]\n\n(fn perf-squares [x]\n  (apply str (interpose \",\" (filter #(square? (Integer. %)) (re-seq #\"\\d+\" x))))))", "problem": 74, "user": "4db58ccb535d87e67b28fe10"}, {"code": "(fn [s]\n  (->>\n    (re-seq #\"\\d+\" s)\n    (filter #(zero? (mod (Math/sqrt (read-string %)) 1)))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4e5914e0535d8a8b8723a29b"}, {"code": "(fn filter-squares [numbers]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" numbers))\n        sqs (filter #(= (Math/sqrt %) (int (Math/sqrt %))) nums)]\n    (apply str (interpose \",\" sqs))))", "problem": 74, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "(fn [s]\n  (let [nums (map\n              #(Integer/parseInt %)\n              (clojure.string/split s #\",\"))\n        max-num (apply max nums)\n        perfect-squares-up-to-max\n        (set (map #(* % %) (range 1 max-num)))]\n    (clojure.string/join\n      \",\"\n      (filter perfect-squares-up-to-max nums))))", "problem": 74, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn perfect-squares- [s]\n  \"74. Given a string of comma separated integers, write a function which                                                                                               \n  returns a new comma separated string that only contains the numbers                                                                                                   \n  which are perfect squares.\"\n  (->> (re-seq #\"\\d+\" s) ; split out the digits                                                                                                                         \n       (map read-string)  ; safe because we're only reading from the regex matches                                                                                      \n       (filter #(= (int (Math/sqrt %)) (Math/sqrt %))) ; awkward way to check for perfect squares                                                                       \n       (interpose \",\")\n       (apply str)\n       ))", "problem": 74, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn [s]\n  (->>\n    (.split s \",\")\n    (map #(Integer/valueOf %))\n    (filter #(let [r (Math/sqrt %)] (= (Math/floor r) (Math/ceil r))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4e6a48d5535d8ccf87e9febd"}, {"code": "(fn [ss] (apply str (interpose \",\" (map str (filter\n  (let [p-sq (map #(* % %) (range))]\n    (fn [k] (= k (first (drop-while #(< % k) p-sq)))))\n  (map #(Integer/parseInt %) (map first\n    (partition-all 2 (map #(apply str %)\n      (partition-by #{\\,} ss))))))))))", "problem": 74, "user": "4db1bfe21254ad5b4805fa71"}, {"code": "(fn [x] (apply str (interpose \",\" (filter \n  (fn [y] (let [k (Integer. y) i (Math/sqrt k)]\n    (= k (* i i))))\n  (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "4e6def42535d5021c1a895f7"}, {"code": "(fn [s]\n  (let [is-psq? (fn [x] (let [sqrt-str (.toString (Math/sqrt x))] (= 1 (count (.substring sqrt-str (+ 1 (.indexOf sqrt-str \".\")))))))]\n\t\t(apply str (interpose \",\" (filter #(is-psq? %) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))))", "problem": 74, "user": "4db045b5838c48654951d9be"}, {"code": "(fn [s]\n  (->> s (re-seq #\"\\d+\") (map #(Integer/parseInt %))\n    (filter (->> (range 25) (map #(reduce * (repeat 2 %))) set))\n    (interpose \",\")\n    (reduce str)))", "problem": 74, "user": "4e6dd51b535d5021c1a895f6"}, {"code": "(fn [y] (apply \r\n          str \r\n          (interpose \r\n            \",\" \r\n            (filter \r\n              #(= (* (Math/sqrt %) (Math/sqrt %)) % )\r\n              (map \r\n                #(Integer/parseInt %)  \r\n                (. y split  \",\"))))))", "problem": 74, "user": "4e44358f535dc968683fc4a8"}, {"code": "(fn[s] \n  (let [\n    sqr (fn [n] (int (Math/sqrt n)))\n    sq? (fn [n] (= n (* (sqr n) (sqr n)))  )\n  ]\n  (apply str \n    (interpose \",\"\n      (filter #(sq? %) \n        (map #(Integer/valueOf %) \n          (.split s \",\")))))))", "problem": 74, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(let [str-join (comp #(apply str %) interpose)\n      perfsq? (fn [n] (#(= % (Math/floor %)) (Math/sqrt n)))]\n  (comp (partial str-join \",\")\n        (partial filter perfsq?)\n        (partial map #(Integer/parseInt %))\n        #(.split #\",\" %)))", "problem": 74, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [a] (let [perfect? (fn [n] (if (empty? (filter #(= % n) ( map #(* % %) (range (inc (/ n 2)))))) false true))] (apply str (interpose \",\" (filter #(perfect? (Integer/parseInt %)) (re-seq #\"\\d+\" a))))))", "problem": 74, "user": "4e6e6630535d5021c1a89609"}, {"code": "(fn [csv]    \n        (apply str (interpose \",\" (filter #(let [v (Math/sqrt (Double/parseDouble %))] (= (Math/rint v) v)) (.split #\",\" csv)))))", "problem": 74, "user": "4e5f08c7535d8a8b8723a2da"}, {"code": "#(->> % (re-seq #\"4|9|16|25|36\")(interpose \",\")(apply str))", "problem": 74, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn perfect-squares [s]\n  (->> s\n      (re-seq #\"\\d+\")\n      (map #(Integer/parseInt %))\n      (filter #(let [n (Math/sqrt %)] (= n (Math/floor n))))\n      (interpose \\,)\n      (apply str)))", "problem": 74, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn [s]\n  (letfn\n    [(ps? [n] (= n (Math/pow (Math/round (Math/sqrt n)) 2)))]\n    (apply str (interpose \\, (filter ps? (map #(Integer/parseInt %) (.split s \",\")))))))", "problem": 74, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [x] (apply str \n  (interpose \n    \",\" \n    (filter #(contains? #{0 1 4 9} (bit-and 15 (Integer. %))) \n    (.split x \",\")))))", "problem": 74, "user": "4e5bdc2b535d8a8b8723a2bb"}, {"code": "(fn [s]\n  (let [perfect? (fn [n] (some #(= (* % %) n) (range n)))]\n   (->> (.split s \",\")\n        seq\n        (map #(Integer/parseInt %))\n        (filter perfect?)\n        (interpose \\,)\n        (apply str)\n   )))", "problem": 74, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn [s]\n                               (apply str (interpose \\, (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) (map #(Integer/parseInt %) (map #(apply str %) (remove #(= \\, (first %)) (partition-by #(= \\, %) s))))))))", "problem": 74, "user": "4e08fb7a535d04ed9115e7ac"}, {"code": "(fn [s] (clojure.string/join \",\" (let [coll (clojure.string/split s #\",\")] (filter #(some #{%} coll) (map #(str (* % %)) (range 100))))))", "problem": 74, "user": "4e6fa38b535d5021c1a89622"}, {"code": "(fn [string]\n  (reduce str (next (interleave (repeat \",\")\n\t\t\t\t      (remove #(not=  (Integer/parseInt %)  (Math/pow (Math/sqrt (Integer/parseInt %)) 2))\n\t\t\t\t\t      (.split string \",\" ))))))", "problem": 74, "user": "4e739e13535dff18050a9c76"}, {"code": "(fn [nums]\n  (apply str (butlast (interleave (filter #(contains? (set (for [x (range %)] (* x x))) %)\n  \t\t\t\t\t\t (read-string (str \"[\" nums \"]\")))\n\t\t\t\t\t\t (repeat \\,)))))", "problem": 74, "user": "4dbde27c535d020aff1edf50"}, {"code": "(fn [s]\n  (let [numbers (map #(Integer/parseInt %)\n                     (clojure.string/split s #\",\"))\n        perfect-square? (fn [n]\n                          (let [sqrt (Math/sqrt n)]\n                            (= n (* sqrt sqrt))))]\n  (apply str\n         (interpose \",\"\n                    (filter perfect-square? numbers)))))", "problem": 74, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [x]\n  (apply str\n    (interpose \\,\n      (filter #{4 9 16 25 36}\n        (map #(Integer/valueOf %)\n          (clojure.string/split x #\",\"))))))", "problem": 74, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [x] (apply str (interpose \\,  \n  (filter #(= (Math/sqrt %) (int (Math/sqrt %))) \n    (map #(Integer/parseInt %) \n      (clojure.string/split x #\",\"))))))", "problem": 74, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [s] (apply str (interpose \\, (filter #(let [q (Math/sqrt %)] (== (* q q) %)) (map #(Long/valueOf %) (.split #\",\" s))))))", "problem": 74, "user": "4e7e55ab535db169f9c79711"}, {"code": "(fn [string]\n  (let [square? (fn [x]\n    (let [sqrt (Math/sqrt x)]\n      (= sqrt (Math/floor sqrt))))]\n    (->> string\n         (re-seq #\"\\d+\")\n         (map #(Integer/parseInt %))\n         (filter square?)\n         (reduce #(str %1 \",\" %2)))))", "problem": 74, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [x](apply str (interpose \",\" (filter #(zero? (mod (Math/sqrt (Integer/parseInt %)) 1))\r\n  \t\t\t    (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "4e7eff9e535db966e863cc38"}, {"code": "#(let [col (map (fn [s] (Integer/parseInt s)) (clojure.string/split % #\",\" ))]\r\n      (loop [x 1 result []]\r\n        (cond\r\n          (> (* x x) (apply max col)) (clojure.string/join \",\" result)\r\n          (some (fn [s] (= s (* x x))) col) (recur (inc x) (conj result (* x x)))\r\n          :else (recur (inc x) result)))\r\n      )", "problem": 74, "user": "4e79a143535db169f9c796a2"}, {"code": "(fn [l]\n\n    (clojure.string/join \",\" (map str (filter #(= (*(Math/sqrt %) (Math/sqrt %)) %) (map #(Integer/parseInt %) (.split l \",\"))   )))\n    \n    )", "problem": 74, "user": "4e78c208535db95036265722"}, {"code": "(fn [c] (letfn [(perfect [n] (loop [i 1]\n           (if (< i n)\n             (if (not= n (* i i))\n               (recur (inc i))\n               n)\n             false)))]\n        (apply str (interpose \",\" (filter integer? (map #(perfect (Integer/parseInt %)) (re-seq #\"[0-9]+\" c)))))))", "problem": 74, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        f (fn [n] (= (last (str (Math/sqrt n))) \\0))\n        squares (filter f nums)\n        join #(apply str (interpose \",\" %))]\n  (join squares)))", "problem": 74, "user": "4e6a4edd535d8ccf87e9fec4"}, {"code": "(fn perfect-squares [num-string]\n  (reduce\n   (fn [a b] (str a \",\" b))\n   (filter\n    (fn [x] (== (int (Math/sqrt x)) (Math/sqrt x)))\n    (map #(Integer/parseInt %) (clojure.string/split num-string #\",\")))))", "problem": 74, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(letfn [\n\n(cs [c] (not= c \\,))\n\n(to-nums [s]\n (if (empty? s) '()\n  (let [num (apply str (take-while cs s)) new-s (rest (drop-while cs s)) ]\n   (cons (. Integer parseInt num) (to-nums new-s)))))\n\n(sqr? [n]\n (let [ rt (int (. Math sqrt n)) ]\n  (= (* rt rt) n)))\n\n(to-str [n] (str n \\,))\n]\n\n(fn [s]\n (let [ lst (to-nums s) ]\n  (apply str (butlast (apply str (map to-str (filter sqr? lst))))))))", "problem": 74, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn [nums]\n  (clojure.string/join \",\"\n  (filter #(= (int (Math/sqrt %)) (Math/sqrt %))\n  (map #(Integer/parseInt %) (re-seq #\"\\d+\" nums)))))", "problem": 74, "user": "4e720985535d5021c1a89655"}, {"code": "(fn [x] \n    (let [a (map #(* % %) (range 1 30))]\n    \n    (apply str (interpose \",\"\n    (filter\n        (fn [bi]\n            (if (some #{bi} a) (str bi))\n        )\n        (map\n            #(Integer/parseInt %)\n            (.split x \",\")\n        )\n    )))\n    )\n)", "problem": 74, "user": "4e78dc98535db95036265724"}, {"code": "(fn[s](clojure.string/join \",\" (filter (fn[x](not (not-any? #(= x (* % %)) (range x)))) (map #(Integer/parseInt %)(seq (.split s \",\"))))))", "problem": 74, "user": "4e6df3c9535d5021c1a895fa"}, {"code": "(fn [s] (apply str (interpose \",\" \n  (remove #(pos? (mod (Math/sqrt %) 1)) (map read-string (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [s]\r\n  (let [int? #(= % (int %))\r\n        ps (fn [xs] (filter #(int? (Math/sqrt %)) xs))\r\n        is (->> (.split s \",\") (map #(Integer/parseInt %)) ps)]\r\n     (apply str (interpose \",\" is))))", "problem": 74, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn [s]\n  (let [ bad-is-perfect-square #{1,4,9,16,25,36} ]\n    (apply str\n      (interpose \",\"\n        (filter bad-is-perfect-square \n           (map read-string (clojure.string/split s #\",\")))))))", "problem": 74, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn [x]\n  (apply str\n    (interpose\n      \",\"\n      (filter \n        #(let [r (Math/sqrt %)] \n          (= r (Math/ceil r)))\n        (map \n          #(Integer. %)\n          (.split x \",\"))))))", "problem": 74, "user": "4e7e05a6535db169f9c796fe"}, {"code": "(fn [s]\n   (apply str\n          (interpose \\,\n                     (filter\n                      #(let [m (Math/floor (Math/sqrt %))]\n                         (= % (* m m)))\n                      (read-string (str \\[ s \\]))))))", "problem": 74, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter (fn [n] (= n (#(* % %) (int (Math/sqrt n)))))\n           (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [num-strs]\n   (let [squares (map #(* % %) (range))\n         nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" num-strs))]\n     (apply str\n            (interpose \",\"\n                       (filter\n                        #(some (fn [x] (= x %))\n                               (take-while (fn [x] (<= x %)) squares))\n                        nums)))))", "problem": 74, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [s]\n  (apply str (interpose \",\" \n\t\t(filter \n\t\t\t(fn [n]\n\t\t\t\t(seq (filter #(= n %) (map #(* % %) (range 1 n)))))\n\t\t\t(map #(Integer/parseInt %) (.split s \",\"))))))", "problem": 74, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [in]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" in))]\n    (apply str \n      (interpose \",\" \n        (filter (fn [n] (zero? (rem n (Math/sqrt n)))) nums)))))", "problem": 74, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn [y] (apply str (interpose \",\" (filter #(= (int (Math/sqrt (Long. %))) (Math/sqrt (Long. %))) (seq (.split #\",\" y))))))", "problem": 74, "user": "4e842ebb535db62dc21a62df"}, {"code": "(fn [s]\n  (->> (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n       (filter (fn [n]\n         (let [sqrt (int (Math/sqrt n))]\n           (= n (* sqrt sqrt)))))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [x] (apply str (interpose \",\" (filter #(re-matches #\"\\d+\\.0\" (str (Math/sqrt (read-string %)))) (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "#(->> (str \\[ %2 \\])\n      read-string\n      (filter (set (map * % %)))\n      (interpose \\,)\n      (apply str))\n\n(range 9)", "problem": 74, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [s]\r\n    (subs (apply str (map #(str \",\" %) (filter (fn [n] (= n (#(* % %) (Math/sqrt n) )))  (map read-string (re-seq #\"[0-9]+\" s))))) 1))", "problem": 74, "user": "4e821ca5535db62dc21a62c2"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(= (Math/pow (Math/sqrt %) 2) %) (read-string (str \"[\" s \"]\")))))", "problem": 74, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn [x]\n    (reduce\n      #(str %1 \",\" %2)\n      (filter\n        #(= (int (Math/sqrt %)) (Math/sqrt %))\n        (map #(Integer/parseInt(apply str (map str %)))\n          (filter  #(not (= '(\\,) %))\n            (partition-by #(= \\, %) x)\n          )\n        )\n      )\n    )\n  )", "problem": 74, "user": "4e8b73e4535d65386fec2120"}, {"code": "(let [fs #(map read-string (clojure.string/split % #\",\"))\n      ts #(apply str (interpose \",\" %))]\n  (fn [ns] (let [sq? #(= (Math/sqrt %) (int (Math/sqrt %)))]\n    (ts (filter sq? (fs ns))))))", "problem": 74, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [x] (reduce #(str %1 \",\" %2)  (filter (fn[y]  ( (set(map #(* % % ) (\nrange y))) y ))  ( map #(Integer. % ) (clojure.string/split x #\",\") ) ) ) )", "problem": 74, "user": "4e8d5edd535d65386fec2134"}, {"code": "(fn [p]\r\n  (let [split (clojure.string/split p #\"(,)\")\r\n       sqtest (fn [q] (loop [n 2]\r\n                        (if (= n q)\r\n                          -1\r\n                          (if (= (* n n) q)\r\n                            q\r\n                            (recur (+ n 1))))))\r\n       sqt (fn [q] (sqtest (new Integer q)))\r\n        tested (map sqt split)\r\n        filtered (filter (fn [q] (not= q -1)) tested)]\r\n    (clojure.string/join \",\" filtered)))", "problem": 74, "user": "4e99f2e1535dbda64a6f6b6c"}, {"code": "(fn perfects\r\n  [string]\r\n  (apply str (drop-last\r\n    (interleave (filter (fn [c] (let [n (Integer/parseInt c), root_n (int (Math/sqrt n))] (= n (* root_n root_n))))\r\n      (map str (seq (.split string \",\")))) (repeat \",\")))))", "problem": 74, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [input]\n(apply str (interpose \",\" \n(filter #(let [sq (Math/sqrt %)] (= sq (int sq)))\n   (map #(Integer/parseInt %)\n    (vec (.split input \",\")))))))", "problem": 74, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [s] (apply str (interpose \",\"\n                              (filter #(let [x (read-string %)\n                                             sqrt (int (Math/sqrt x))]\n                                         (= x (* sqrt sqrt)))\n                                      (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "#(apply str\n   (interpose \",\"\n     (filter (fn [n] (let [x (Math/sqrt n)] (zero? (- (int x) x))))\n             (read-string (str \"[\" % \"]\")))))", "problem": 74, "user": "4ea09fa4535d7eef308072aa"}, {"code": "(fn [s]\r\n(let [z\r\n(filter #(= \"0\" (last (re-seq #\"\\d+\" (str (Math/sqrt (Integer/parseInt %)))))) (re-seq #\"\\d+\" s))]\r\n(loop [[head & more] z\r\n       x (str head)]\r\n(if (nil? more)\r\nx\r\n(recur more (str x \",\" (first more)))))))", "problem": 74, "user": "4ea09441535d7eef308072a7"}, {"code": "(fn [s] (clojure.string/join \",\"\n      (filter #(= (double %) (Math/pow (Math/sqrt %) 2))\n              (map read-string (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4e89ddf9535d3e98b8023284"}, {"code": "#(apply str (interpose \",\" (for [s (.split #\",\" %) :let [n (Integer/parseInt s)] :when (= (int (Math/pow (int (Math/sqrt n)) 2)) n)] n)))", "problem": 74, "user": "4e951ce5535dbda64a6f6b2e"}, {"code": "(fn my-perfect-square-filter [num-str]\n  (let [nums   (map #(Integer/parseInt %) (re-seq #\"\\d+\" num-str))\n  sqrs   (filter #(= % (* (Math/pow % 0.5) (Math/pow % 0.5))) nums)]\n    (apply str (interpose \",\" sqrs))))", "problem": 74, "user": "4dc54eb2535d8a4b2fd74284"}, {"code": "(fn perfect-squares [s]\n  (let [strings (.split s \",\")\n        numbers (map #(Integer/parseInt %) strings)\n        square? (fn [n] (= 0 (mod (Math/sqrt n) 1)))\n        squares (filter square? numbers)]\n    (reduce #(str %1 \",\" %2) squares)))", "problem": 74, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(letfn [\n  (perfect-square? [n]\n    (let [n (read-string n)]\n     (loop [n n divisor 1]\n      (let [o (* divisor divisor)]\n        (cond\n          (< o n) (recur n (inc divisor))\n          (= o n) true\n          :else false)))))\n  (perfect-squares [s]\n    (apply str\n     (interpose \\,\n      (filter perfect-square?\n       (re-seq #\"\\d+\" s)))))\n  ]\n  perfect-squares\n)", "problem": 74, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "#(letfn [\n  (sq? [n] \n    (let [r (int (Math/sqrt n))] \n      (= n (* r r))))]\n  (clojure.string/join \",\" (filter sq? (map (fn [s] (Integer/parseInt s)) (re-seq #\"\\d+\" %)))))", "problem": 74, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn [s] (apply str (interpose \\, (filter (fn [x] (let [n (Integer/parseInt x)] (some #(= n %) (take n (map #(* % %) (range))))))  (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn f [s]\n  (let [squares\n        (filter #(let [n (read-string %) r (Math/sqrt n) r2 (* (int r) (int r))]\n            (= r2 n))\n               (seq (.split #\",\" s)))]\n    (apply str (interpose \\, squares))))", "problem": 74, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn fps [s]\r\n  (letfn [(pure-square? [snum]\r\n            (zero? (rem (Math/sqrt (Integer/parseInt snum)) 1)))]\r\n    (apply str (interpose \",\" (filter pure-square? (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4dd7d040535d2dad7130b5d6"}, {"code": "(fn [s]\r\n  (letfn [(to-ints [s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))\r\n          (is-sqr? [x] (= x (#(* % %) (int (Math/sqrt x)))))]\r\n    (clojure.string/join \",\" (filter is-sqr? (to-ints s)))))", "problem": 74, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn [s]\n    (let [square? (fn [n] (zero? (let [s (Math/sqrt n)] (- s (int s)))))]\n      (->> (.split s \",\")\n        (map #(Integer/parseInt %))\n        (filter square?)\n        (interpose \",\")\n        (apply str))))", "problem": 74, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn [l]\n  (clojure.string/join \",\"\n  (filter\n    #(= (Math/pow (int (Math/sqrt %)) 2) %) \n    (map #(Integer. %) (clojure.string/split l #\",\")))))", "problem": 74, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [s] \n(clojure.string/join \",\" \n(filter \n  #(= (int (java.lang.Math/sqrt %)) \n      (int (java.lang.Math/ceil (java.lang.Math/sqrt %))))\n  (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "4eaede1f535d7eef30807329"}, {"code": "(fn f75 [s]\n  \"filter perfect squares from csv\"\n  (let [tokens (.split s \",\")\n        xs (map #(Integer/parseInt %) tokens)\n        pred (fn [x] (let [sqrt (Math/sqrt x)] (= sqrt (int sqrt))))\n        ys (filter pred xs)\n        tostr (reduce str (drop-last (interleave ys (repeat \",\"))))]\n    tostr))", "problem": 74, "user": "4e88feef535d8b9bb0147ca8"}, {"code": "(fn [s]\n  (let [ints (map #(Integer/parseInt %) (.split s \",\"))\n        squares (set (take-while #(<= % (apply max ints))\n                                 (map * (range) (range))))]\n    (clojure.string/join \",\" (filter squares ints))))", "problem": 74, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn [s]\n    (letfn [(perfect-square? [n] (let [r (int (Math/sqrt n))] (= n (* r r))))]\n      (apply str (interpose \",\" (map str (for [is (map #(Integer/parseInt %) (.split s \",\"))\n                                               :when (perfect-square? is)]\n                                           is))))))", "problem": 74, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn\n  [s]\n   (let [in (map #(Integer. %) (.split s \",\"))\n         pf (fn [n] (some #(= n (* % %)) (range 2 (+ 1(/ n 2)))))]\n     (apply str (interpose \",\" (filter pf in)))))", "problem": 74, "user": "4e6dd0f5535d5021c1a895f3"}, {"code": "(fn [x]\n  (clojure.string/join \",\"\n    (filter\n      #(= %1 (Math/pow (int (Math/sqrt %1)) 2))\n      (map #(Integer. %) (clojure.string/split x #\",\"))\n    )\n  )\n)", "problem": 74, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "(fn [s]\r\n  (clojure.string/join \",\" \r\n    (filter \r\n         #(= % (Math/pow (Math/sqrt %) 2))\r\n        (map #(Integer/parseInt %)(.split s \",\")))))", "problem": 74, "user": "4db92654535d1e037afb21a0"}, {"code": "#(->> %\n  (re-seq #\"\\d+\")\n  (map read-string)\n  (filter (fn [n]\n            (let [r (Math/sqrt n)]\n              (= r (* 1.0 (int r))))))\n  (map str)\n  (interpose \",\")\n  (apply str))", "problem": 74, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn [s]\n  (let [ps (map #(* % %) (range))\n        xs (map read-string (.split s \",\"))]\n    (clojure.string/join \",\"\n      (for [x xs :when (= x (first (drop-while #(< % x) ps)))] x ))))", "problem": 74, "user": "4eb5750a535d7eef30807366"}, {"code": "(fn fps [s]\n  (apply str (interpose \",\" (filter #(not (ratio? (rationalize(Math/sqrt %)))) (map read-string (clojure.string/split s #\",\")))))\n)", "problem": 74, "user": "4dd1de4d535dae65d5c462d7"}, {"code": "(fn p[s]\r\n  (clojure.string/join \",\"(filter (complement nil?) (map (fn [n] (if (zero? (mod (Math/sqrt (read-string (str n))) 1)) n)) (into [] (.split s \",\"))))\r\n  ))", "problem": 74, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "(fn [s] \r\n     (reduce \r\n       #(str % \\, %2) \r\n       (filter \r\n         #(== 0 (mod (Math/sqrt %) 1)) \r\n         (map read-string (re-seq #\"[0-9]+\" s)))))", "problem": 74, "user": "4e707db6535d5021c1a8963a"}, {"code": "#(apply str (interpose \",\" (filter (fn [d] (= (Math/sqrt d) (int (Math/sqrt d)))) \n         (map read-string (re-seq #\"\\d+\" %)))))", "problem": 74, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn [s] \n  (clojure.string/join \",\" \n    (filter \n      (fn [n] (some #(= n (* % %)) (range 2 n)))\n      (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [x] (reduce #(str %1 \",\" %2) \n  (filter #(integer? (rationalize (Math/sqrt %)))\n    (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" x)))))", "problem": 74, "user": "4ea9b80c535d7eef30807306"}, {"code": "(fn [z]\n(let [y\n(apply str (map #(str % \",\")\n(filter\n(fn [x]\n  (if (= x (* (int (Math/sqrt x)) (int (Math/sqrt x))))\n    true false)) (map read-string (re-seq #\"\\d+\" z)))))]\n(subs y 0 (- (count y) 1))))", "problem": 74, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn [s]\n  (apply str\n    (butlast\n      (interleave\n        (filter #{4 9 16 25 36 49}\n          (map #(Integer/parseInt %) (.split s \",\")))\n        (repeat \",\")))))", "problem": 74, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(== 0 (rem (Math/sqrt %) 1))(map read-string (.split s \",\"))))))", "problem": 74, "user": "4eb44d78535d7eef30807360"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter\n      #(= 0.0 (mod (Math/sqrt %) 1))\n      (map #(Integer. %)\n        (clojure.string/split s #\",\")))))", "problem": 74, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(fn sq [s] \n  (let [nums (map #(. Integer (parseInt %)) (.split s \",\"))]\n    (apply str (interpose \",\" (filter #(= \n      (. Math (sqrt %) )\n      (. Math (floor (. Math (sqrt %))))) nums)))))", "problem": 74, "user": "4ea0c284535d7eef308072ad"}, {"code": "(fn [s]\n  (apply str (interpose \",\"\n    (filter\n      #(let [x (Math/sqrt %)] (= (int x) x))\n     (map read-string (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4ec2f192535dcc7ae8597d4c"}, {"code": "(fn prsq [a]\n   (let [s (seq (.split a \",\"))]\n    (reduce\n      #(str %1 \",\" %2)\n      (filter #(let [n (Math/sqrt (Long/parseLong %1)) ]  (if (= 0 (- n (long n))) true false )) s)\n    )\n  )\n)", "problem": 74, "user": "4e9de526535dbda64a6f6b8e"}, {"code": "(fn [coll] \n  (apply str (interpose \\, \n    (filter #(= \\0 (last (str (Math/sqrt (read-string %))))) \n      (re-seq #\"\\d+\" coll)))))", "problem": 74, "user": "4eb51942535d7eef30807365"}, {"code": "(fn only-squares [s]\n  (letfn [(parse-ints [s]\n            (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s)))\n          (perfect-square? [n] \n            (let [x (.intValue (Math/sqrt n))]\n              (= (* x x) n)))\n          (ints-string [sq]\n            (apply str (interpose \",\" sq)))]\n    (ints-string (filter perfect-square? (parse-ints s)))))", "problem": 74, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn [strv]\n  (let [checkrt (fn  [v]\n      (let [rt (int (Math/sqrt v ) ) ]\n      (= (* rt rt) v)))\n       cs\n      (fn cs [str]\n      (map #(Integer/parseInt %) (.split str \",\"))\n      )\n    ]\n    (reduce  #(.concat %1 %2) \"\" (map str (interpose  \",\" (filter checkrt (cs strv)) )))\n  ))", "problem": 74, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [s] (apply str (interpose \",\" \n  (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) \n(map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4eabb245535d7eef30807319"}, {"code": "(fn [s]\n  (let [is (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        perfect #(= (int (Math/sqrt %)) (Math/sqrt %))\n        ps (filter perfect is)]\n    (clojure.string/join \\, ps)))", "problem": 74, "user": "4daf8f84edd6309eace4d17a"}, {"code": "(fn [s] (->>\n  (.split s \",\")\n  (map #(Integer/parseInt %))\n  (filter #(let [r (Math/sqrt %)] (== r (int r))))\n  (interpose \",\")\n  (apply str)))", "problem": 74, "user": "4ec16c21535dfed6da9c6dac"}, {"code": "(fn [s]\n  (apply str (interpose \",\" \n    (filter (fn [n](some #(= (* % %) n) (range n)))\n              (map #(Integer. %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn [s]\n  (->> s\n    (#(.split % \",\"))\n    (map #(new Integer %))\n    (filter #(let [x (Math/round (Math/sqrt %))] (= % (* x x))))\n    (map str)\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [s]\n  (let [nums (map #(Integer. %) (re-seq #\"[0-9]+\" s))\n        p? (fn [i]\n             (loop [s (map #(* % %) (iterate inc 1))]\n               (if (< i (first s))\n                 false\n                 (if (= i (first s))\n                   true\n                   (recur (rest s))))))]\n    (apply str (interpose \",\" (filter p? nums)))))", "problem": 74, "user": "4e773be8535d324fb2983d6e"}, {"code": "(fn [s]\n  (->> s (re-seq #\"\\d+\") \n         (filter #(= (* (int (Math/sqrt (Integer/parseInt %)))\n                        (int (Math/sqrt (Integer/parseInt %))))\n                        (Integer/parseInt %))) \n         (interpose \",\")\n         (apply str)))", "problem": 74, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn [s]\n(let \n  [n \n    (map \n      #(Integer/parseInt %) \n      (clojure.string/split s #\",\"))]\n  (apply str \n    (interpose \n      \",\" \n      (filter \n        (set (map #(* % %) (range 1 (apply max n)))) \n      n)))))", "problem": 74, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [s]\n  (apply str (interpose \",\"\n               (filter\n                 #(let [d (Math/sqrt %)] (== d (int d)))\n                 (map #(Integer/parseInt %) (re-seq #\"[\\d]+\" s))))))", "problem": 74, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [x] \r\n  (clojure.string/join \",\" \r\n    (filter #(= (rem (Math/sqrt %) 1) 0.0)  \r\n      (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [s] (apply str\n  (interpose \",\"\n    (filter\n      #(let [\n          x (Integer/parseInt %)\n          v (Math/round (Math/sqrt x))]\n        (= (* v v) x))\n      (.split s \",\")))))", "problem": 74, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn tt [str]\n  (let [squ? (fn [n]\n                  (= n (Math/round (Math/pow (Math/round (Math/sqrt n)) 2))))\n        nums (map #(Integer/parseInt %)(.split str \",\"))]\n       (clojure.string/join \",\" (for [x nums :when (squ? x)] x))))", "problem": 74, "user": "4ec21058535dfed6da9c6dba"}, {"code": "(fn [s]\n   (let [ps? (fn [n] (zero? (mod n (Math/sqrt n))))]\n     (->> s\n          (re-seq #\"\\w+\")\n          (map #(Integer. %))\n          (filter ps?)\n          (interpose \",\")\n          (apply str))))", "problem": 74, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "(fn [s]\n  (let [ps? #(= (-> % Math/sqrt int) (Math/sqrt %))\n        ps (filter ps? (map #(Integer/parseInt %) (re-seq #\"\\w+\" s)))]\n  (clojure.string/join \",\" ps)))", "problem": 74, "user": "4e1350af535d04ed9115e7d8"}, {"code": "#(reduce (fn ! [a b] (str a \\, b)) (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (clojure.string/split % #\",\")))", "problem": 74, "user": "4e8a460e535d65386fec2109"}, {"code": "(fn [x]\n  (letfn [(square? [n] (some #(= n (* % %)) (range (inc n))))]\n    (apply str (interpose \",\" (filter square?\n      (map #(Integer/parseInt %)\n           (re-seq #\"[0-9]+\" x)))))))", "problem": 74, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn filter-perfect-squares [st]\n  (let [nums (read-string (str \\[ st \\]))]\n    (->> nums\n      (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)))\n      (interpose \\,)\n      (apply str))))", "problem": 74, "user": "4ec75077535d6d7199dd36e0"}, {"code": "(fn [string]\n  (let [square? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        nums (map #(Integer/valueOf %) (clojure.string/split string #\",\"))]\n    (clojure.string/join \",\" (filter square? nums))))", "problem": 74, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn [c] (apply str (interpose \\, (remove #(empty? (for [x (range %) :when (= % (* x x))] x))\n   (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" c))))))", "problem": 74, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(let [x (Math/sqrt %)] (= x (int x))) (map read-string (re-seq #\"[^,]+\" s))))))", "problem": 74, "user": "4ecbb249535df97575fdabdf"}, {"code": "(fn [s] \n (clojure.string/join \n   \",\" \n   (keep \n     (set (map #(str (* % %)) (range 7)))\n     (clojure.string/split s #\",\"))))", "problem": 74, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn [input]\n  (letfn [\n    (parse [input] (map #(Integer. %) (.split input \",\")))\n    (perfect? [n] (zero? (rem (Math/sqrt n) 1)))\n    (csv [nums] (reduce #(str %1 \",\" %2) nums))\n  ] (csv (filter perfect? (parse input)))))", "problem": 74, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn filter-perfect-numbers [s]\n  (let [\n    numbers (map #(Integer/parseInt %) (seq (.split s \",\")))\n    perfect-square? (fn [x]\n      (let [r (Math/sqrt x)] (= r (Math/floor r))))\n    ]\n    (apply str (interpose \",\" (filter perfect-square? numbers)))))", "problem": 74, "user": "4e25176e535d04ed9115e829"}, {"code": "(fn [s]\n  (letfn [(ps? [n]\n             (some #(= (* % %) n) (range 0 (inc n))))]\n    (reduce #(str %1 \\, %2) (filter ps? (map #(Integer/parseInt %) (.split s \",\"))))))", "problem": 74, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn [L] (clojure.string/join \",\" (filter #(= (Math/sqrt %)(int (Math/sqrt %))) (read-string (str \"[\" L \"]\")))))", "problem": 74, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [x] (let\n               [s (map #(Integer. %) (re-seq #\"[0-9]+\" x))]\n             (apply str (interpose \",\" (filter #(= (Math/sqrt %)\n                                                   (Math/floor (Math/sqrt %)))\n                                               s))))\n      )", "problem": 74, "user": "4ebef65e535dfed6da9c6d9b"}, {"code": "(fn f [s]\n  (reduce #(str % \",\" %2)\n    (filter \n      (fn is_square [n] \n        (let [sqrt (int (Math/sqrt n))]\n          (= n (* sqrt sqrt))))\n      (map #(Integer/parseInt %) (.split s \",\")))))", "problem": 74, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [s]\n    (let [perfect-square? (fn [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))\n          parse-int (fn [s] (Integer/parseInt s))]\n      (->> (clojure.string/split s #\",\")\n           (map parse-int)\n           (filter perfect-square?)\n           (clojure.string/join \",\"))))", "problem": 74, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(let [sq #(* % %)\n      sq? #(= % (sq (int (Math/sqrt %))))\n      s->int #(Integer/parseInt %)]\n  #(clojure.string/join \",\" (filter sq? (map s->int (clojure.string/split % #\",\")))))", "problem": 74, "user": "4edd038c535d10e5ff6f5327"}, {"code": "(fn [csv]\n  (let [ints (map #(Integer/parseInt %) (re-seq #\"\\d+\" csv))\n        squares (map #(* % %) (iterate inc 1))\n        selection (filter (fn [int]\n                            (loop [[x & xs] squares]\n                              (cond (< x int) (recur xs)\n                                    (= x int) true\n                                    :else false)))\n                          ints)]\n    (apply str (interpose \\, selection))))", "problem": 74, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [s]\n  (apply str (interpose \",\"\n    (filter #(let [root (Math/sqrt %)] (= root (int root)))\n      (map #(Integer/parseInt %) (.split s \",\"))))))", "problem": 74, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [s] (clojure.string/join \",\" (filter (set (map #(str (* % %)) (range 100))) (#(re-seq #\"\\d+\" %) s))))", "problem": 74, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [x]\r\n  (apply str\r\n    (interpose \\, (filter #(let [sr (-> % Math/sqrt int)] (= % (* sr sr)))\r\n    (map #(Integer. %) (.split x \",\"))))))", "problem": 74, "user": "4ee40938535d10e5ff6f5375"}, {"code": "(fn   [s]\n  (let [r  (filter #(let [n (Double. %)\n                          sqrt  (Math/sqrt n)]\n                      ( = (* sqrt sqrt) n))\n                   (re-seq #\"\\d+\" s))]\n    (reduce #(str % \",\" %2) (first r) (rest r))))", "problem": 74, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "(fn [s] (apply str (interpose \\, (filter #(zero? (rem (Math/sqrt %) 1)) (map #(Long/valueOf(apply str %))(apply concat (partition 1 2 (partition-by #(= % \\,) s))))))))", "problem": 74, "user": "4e599577535d8a8b8723a29f"}, {"code": "(fn [s] (->> (seq (.split s \",\"))\n  (map #(Integer/parseInt %))\n  (filter #(zero? (mod % (Math/sqrt %))))\n  (interpose \",\")\n  (apply str)))", "problem": 74, "user": "4ee7ef87535d93acb0a66872"}, {"code": "(fn squares [s]\n   (let [[squares-strs] [(map str (filter #(= ((fn [x] (* x x)) (int (Math/sqrt %))) %) \n        (map #(Integer/parseInt %) (.split s \",\"))))]]\n     (str (reduce str (map #(str % \",\") (take (dec (count squares-strs)) squares-strs))) (last squares-strs))))", "problem": 74, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn [s] (apply str (interpose \\, (filter #(= (mod (Math/sqrt %) 1) 0) (map #(Integer/valueOf %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [s]\n  (reduce #(str %1 \",\" %2) \n    (sort (clojure.set/intersection \n      (set (map #(* % %) (range 0 100)))\n      (set (sort (map read-string (clojure.string/split s #\"\\,\"))))))))", "problem": 74, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [s]\n  (apply str\n         (interpose \\,\n                    (filter #(some (fn [x] (= (* x x) %)) (range %))\n                            (map #(Integer. %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [str]\n  (clojure.string/join \",\"\n    (filter (fn [sn2]\n              (let [n2 (read-string sn2)\n                    n (int (Math/sqrt n2))]\n                (= n2 (* n n))))\n      (clojure.string/split str #\",\"))))", "problem": 74, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "#(apply str (interpose \\,\n             (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"}\n               (.split % \",\"))))", "problem": 74, "user": "4ed69ea4535d10e5ff6f52e3"}, {"code": "(fn [string]\n  (let [perfect-square (fn [n]\n  (some #(== n (* % %)) (range 1 (inc n))))]\n    ((comp\n   (partial apply str)\n   (partial interpose \",\")\n   (partial filter perfect-square)\n   (partial map #(Integer. %))\n   #(clojure.string/split % #\",\"))\n  string)))", "problem": 74, "user": "4eda7cc3535d10e5ff6f530e"}, {"code": "#(reduce str\n  (interpose \\,\n             (filter (fn [n] (= (Math/sqrt n) (int (Math/sqrt n))))\n                     (read-string\n                      (str \"[\" (.replace % \\, \\space) \"]\")))))", "problem": 74, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [s]\r\n  (apply str\r\n         (interpose \",\" \r\n                    (reduce\r\n                      #(let [i (Integer/parseInt %2)\r\n                             j (int (Math/sqrt i))]       \r\n                         (if (= (* j j) i) (conj %1 %2) %1))\r\n                      [] (.split s \",\")))))", "problem": 74, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn [s]\n    (->> s\n         (re-seq #\"\\d+\")\n         (map #(Long/parseLong %))\n         (filter #(zero? (mod (Math/sqrt %) 1)))\n         (interpose \",\")\n         (apply str)))", "problem": 74, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(let [l (Double. %) n (Math/sqrt l)] (= (* n n) l)) (.split x \",\"))))", "problem": 74, "user": "4db091b7838c48654951d9c2"}, {"code": "(fn find-perfect-squares\n     [s]\n     (let [si (map #(Integer/parseInt %) (re-seq #\"\\w+\" s))]\n       (apply str(interpose \",\" (filter #(= (* (Math/sqrt %)  (Math/sqrt %)) %) si)))))", "problem": 74, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn [s] (apply str (interpose \",\" (filter (fn [n] (and n  \n                        (some #(when (= (* % %) n) %) (range 1 (inc (quot n 2))) ) ) )\n                     (map #(Integer/valueOf %) (re-seq #\"\\d+\" s ) ) ))))", "problem": 74, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [s] \n  (apply str  \n    (interpose \",\" \n      (filter (fn [k] \n                (= k (last \n                       (take-while #(>= (- k %) 0) \n                                    (map #(* % %) \n                                          (iterate inc 1)))))) \n              (map #(Integer/parseInt %) \n                    (re-seq #\"-*\\d+\" s))))))", "problem": 74, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [s]\n  (->>\n    (re-seq #\"\\d+\" s)\n    (map #(Integer/parseInt %))\n    (filter #(let [root (Math/sqrt %)] (== root (int root))))\n    (map str)\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4edecdae535d10e5ff6f533c"}, {"code": "#(letfn [(in? [seq elm]  \r\n            (some (fn [x] (= elm x)) seq))\r\n         (squares [i]\r\n            (lazy-cat [(* i i)] (squares (inc i))))\r\n         (filter-squares [xs]\r\n  (let [ys (map (fn [x] (Integer/parseInt x)) (seq (.split xs \",\")))]\r\n\t  (if (seq ys)\r\n\t    (let [y    (last ys)\r\n\t\t  sqrs (take (inc (Math/ceil (Math/sqrt y)))(squares 0))]\r\n\t\t  (filter (fn [x] (in? sqrs x)) ys)))))]\r\n  (apply str (interpose \",\" (filter-squares %))))", "problem": 74, "user": "4e273301535deb9a81d77ef7"}, {"code": "(fn [strnum] (apply str (interpose \",\" (filter #(let [x (Math/sqrt (Integer/parseInt %))] (= x (int x))) (re-seq #\"[0-9]+\" strnum)))))", "problem": 74, "user": "4e8d5911535d65386fec2133"}, {"code": "(fn [comma-str]\n  (letfn [(perfect? [x] (if ((set (map #(* % %) (range 999))) x) true false))]\n    (let [nums (map #(. Integer parseInt %) (re-seq #\"[0-9]+\" comma-str))\n          ps (filter perfect? nums)]\n      (apply str (butlast (interleave (map str ps) (repeat \",\")))))))", "problem": 74, "user": "4ee9d697535d93acb0a66895"}, {"code": "(fn filter-perfect-squares\n  [str1]\n  (let [mstr (map #(Integer/parseInt %1)\n                  (map #(apply str %1)\n                       (concat (remove #{ [\\,]} (partition-by #{\\,} str1)))))\n        mx (reduce max mstr)\n        t (into #{} (take mx (map #(* %1 %1) (range))))\n        flt (filter t mstr)\n        res (apply str (interpose \",\" flt))]\n    res))", "problem": 74, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn [s]\n  (let [perfect? #(let [sqrt (Math/sqrt %)] (= (int sqrt) sqrt))\n        ints (map read-string (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter perfect? ints))))", "problem": 74, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn [s]\n  (let [col1 (set (map #(Integer/valueOf %) (.split s \",\")))\n        col2 (set (map #(* % %)\n                    (map #(int (Math/sqrt %)) col1)))\n        rt (sort (vec (clojure.set/intersection col1 col2))) ]\n   (clojure.string/join \",\" rt)))", "problem": 74, "user": "4ef992c8535dced4c769f268"}, {"code": "(fn [s]\r\n   (let [ns (map #(Integer/parseInt (second %)) (re-seq #\"(\\d+),?\" s))]\r\n     (apply str (interpose \\, (filter #(= % (Math/pow (Math/sqrt %) 2.0)) ns)))))", "problem": 74, "user": "4ef1ee67535dced4c769f219"}, {"code": "(fn filter-perfect-seqs [xs]\n  (letfn [(perfect? [n]\n            (let [x (Math/sqrt n)]\n              (= 0.0 (- x (Math/floor x)))))]\n    (->> xs\n         (clojure.contrib.string/split #\",\")\n         (map #(Byte/valueOf %))\n         (filter perfect?)\n         (clojure.string/join \",\"))))", "problem": 74, "user": "4ef6f5ea535dced4c769f250"}, {"code": "(fn [s]\n  (let [ns (map #(read-string %) (re-seq #\"\\d+\" s))\n    pfsqs (remove nil? (map (fn [x]\n      (let [isqr (-> x Math/sqrt (+ 0.5) int)]\n        (if (= x (* isqr isqr)) x))) ns))]\n  (->> pfsqs (interpose \\,) (apply str))))", "problem": 74, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [s] \n  (apply str \n    (interpose \",\" \n      (filter #(let [t (int (Math/sqrt %))] (= % (* t t))) \n        (map #(Integer/parseInt (apply str %)) \n          (filter #(not (= \\, (first %))) \n            (partition-by #(= % \\,) (seq s))))))))", "problem": 74, "user": "4f017593535dcb61093f6a36"}, {"code": "(let [sq? (fn [n] (some #(= n (* % %)) (range (int (/ n 2)) 1 -1)))]\r\n  #(->> (str \"[\" % \"]\")\r\n    (read-string)\r\n    (filter sq?)\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4eecdd66535d93acb0a668b9"}, {"code": "(fn     [s] (apply str (interpose \",\"\n                                  (filter #(let [n (int (Math/sqrt %))]\n                                             (= % (* n n)))\n                                          (map read-string\n                                               (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn [s] (apply str \n  (interpose \",\" (filter (set (map #(* % %) (range 10))) \n      (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [s-s]\n      (let [vs (map #(Integer/parseInt %) (re-seq #\"\\d+\" s-s))\n            sqs (filter #(let [s (Math/sqrt %)] (= s (Math/round s))) vs)]\n        (apply str (interpose \",\" sqs))))", "problem": 74, "user": "4ed292ac535d44c135fd68d9"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n]\n    (let [x (Math/sqrt n)]\n      (zero? (- x (Math/floor x)))))]\n    (apply str (interpose \",\" (filter perfect-square? (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))))", "problem": 74, "user": "4ef4c1ff535dced4c769f23e"}, {"code": "(fn [x] (clojure.string/join \",\" (map (fn [d] (* d d)) (map int (filter (fn [z] (= z (float (int z)))) (map #(Math/sqrt %) (map #(Integer/parseInt %) (clojure.string/split x #\"\\W\"))))))))", "problem": 74, "user": "4eeb8f68535d93acb0a668a9"}, {"code": "(fn [x] (apply str (interpose \",\" (filter #(apply = \n                 ((comp (juxt (fn [a] (Math/floor a)) \n                             (fn [b] (Math/ceil b)))\n                       (fn [c] (Math/sqrt c)))\n                 %)) \n         (read-string (str \\[ x \\]))))))", "problem": 74, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "#(clojure.string/join \",\" (filter (fn [x] (let [x (Math/sqrt (Integer/parseInt x))] (= (Math/floor x) x))) (re-seq #\"\\d+\" %)))", "problem": 74, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [x]\n  (reduce #(let [a (Integer/valueOf %2),b (Math/sqrt a)]\n    (if (= a (* b b))\n    (if (empty? %) %2 (str % \",\" %2)) %)) \"\"\n    (seq (.split x \",\"))))", "problem": 74, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [s] (apply str (interpose \",\" (filter\n  #(let [x (Math/pow % 1/2)] (> 1e-2 (Math/abs (- x (Math/round x)))))\n  (map #(Long/decode %)\n    (.split s \",\"))))))", "problem": 74, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn f [s]\n   (let [n1 (map #(Integer/parseInt %)\n           (re-seq #\"\\d+\" s))\n         n2 (filter #(= (* (Math/sqrt %)\n                           (Math/sqrt %)) %)\n            n1)]\n   (apply str \n     (rest\n     (reduce (fn [s x]\n       (concat s \",\" (str x))) \"\" n2)))))", "problem": 74, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn [s]\n           (->> s\n                (re-seq #\"\\d+\")\n                (map #(Integer/parseInt %))\n                (filter #(let [r (Math/sqrt %)] (== (int r) r)))\n                (interleave (repeat \",\"))\n                (next)\n                (apply str)))", "problem": 74, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [s] \n  (apply str (interpose \",\" \n    (filter \n      (fn [n] (some #(= (* % %) n) (range 2 n))) \n      (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [in-str]\n  (apply str\n    (interpose \",\"\n      (filter #(= (Math/sqrt %) (Math/ceil (Math/sqrt %)))\n        (map #(Integer/parseInt (str %))\n          (re-seq #\"\\d+\" in-str))))))", "problem": 74, "user": "4ef4ab95535dced4c769f23b"}, {"code": "(fn prob-0074\n  [s]\n  (let [xs   (map #(Integer/parseInt %) (re-seq #\"[\\d]+\" s))\n        filt #(= % (apply * (replicate 2 (int (Math/sqrt %)))))\n        sqrs (filter filt xs) ]\n    \n    (apply str (interpose \",\" sqrs))))", "problem": 74, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [x] (apply str (interpose \",\" (filter #(let [i (Integer/parseInt %) rt (Math/sqrt i)] (= 0.0 (- rt (int rt)))) (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "4f0b2028535d0136e6c222ff"}, {"code": "(fn [s]\n  (clojure.string/join \",\" \n    (remove #(let [x (Math/sqrt (read-string %))] (not= x (int x)))\n      (clojure.string/split s #\",\"))))", "problem": 74, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn [s] \n  (clojure.string/join\n   \",\"\n   (filter\n    #(let [r (Math/sqrt %)]\n       (= r (Math/floor r)))\n    (map read-string (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [s]\n  (let [ps (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n    (clojure.string/join \",\" (filter #(= (Math/sqrt %) (int (Math/sqrt %))) ps))))", "problem": 74, "user": "4e1f9bb5535d04ed9115e80d"}, {"code": "(fn [s] (reduce \n          #(str % \",\" %2) \n          (keep \n            (fn [x] \n              (when \n                (#(= % (Math/ceil %)) \n                  (Math/sqrt (Integer. x))) \n                x)) (.split s \",\"))))", "problem": 74, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [s]\n  (letfn [(parse [s] \n                (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s)))\n          (perfect_sq [x]\n                      (let [y (int (Math/sqrt x))]\n                        (= x (* y y))))]\n    (reduce #(str % \",\" %2)\n            (filter #(perfect_sq %) (parse s)))))", "problem": 74, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn [s]\n  (letfn \n    [(ps [n] \n      (let [rt (int (Math/sqrt n))]\n        (= n (* rt rt))))]\n    (apply str\n      (interpose \",\"\n        (map str\n          (filter ps\n            (map #(Integer/parseInt %)\n              (re-seq #\"\\d+\" s))))))))", "problem": 74, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn fps [s]\n  (letfn [(abs [x] (if (> x 0) x (- x)))\n          (sqrt [x y] (let [z (/ (+ y (/ x y)) 2)]\n                        (if (< (abs (- z y)) 0.001) (int z)\n                            (sqrt x z))))\n          (square? [x] (let [r (sqrt x (/ x 2))]\n                         (= x (* r r))))]\n    (let [xs (map read-string (clojure.string/split s #\",\"))\n          ys (filter square? xs)]\n      (clojure.string/join \",\" (map str ys)))))", "problem": 74, "user": "4ee82ce9535d93acb0a6687a"}, {"code": "(fn filter-ps [x]\n  (letfn [(string->int-seq [nums]\n            (map read-string (clojure.string/split nums #\",\")))\n          (perfect-square? [x]\n            (if (= 0 (count (for [n (range (inc (Math/sqrt x))) :when (= (* n n) x)] x))) false\n                true))]\n  (apply str (interpose \",\" (map str (filter perfect-square? (string->int-seq x)))))))", "problem": 74, "user": "4ddb339c535d02782fcbe9f9"}, {"code": "(fn [x]\n  (reduce\n    #(str % \",\" %2)\n    ((fn [y]\n      (filter\n        #(= (Math/pow (int (Math/sqrt %)) 2) %)\n        (map read-string (re-seq #\"\\d+\" y))))\n    x)))", "problem": 74, "user": "4f062d4a535dcb61093f6c08"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #{1 4 9 16 25 36}\n      (map #(Integer/parseInt %)\n        (clojure.string/split s #\",\")))))", "problem": 74, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "#(let [original (set (map (fn[x](Integer. x))(clojure.string/split % #\",\")))\r\n       squares (set (map (fn[x](* x x))(range 0 (reduce max original))))]\r\n(reduce str (interpose \",\" (map str (sort (clojure.set/intersection squares original))))))", "problem": 74, "user": "4ed2dd98535d44c135fd68e2"}, {"code": "(fn filter-perfect-squares [l]\n  (letfn [(parse [s] (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s)))\n          (int? [x] (= x (Math/floor x)))\n          (perfect? [x] (int? (Math/sqrt x)))]\n  (->> l\n    (parse)\n    (filter perfect?)\n    (map str)\n    (interpose \",\")\n    (apply str))))", "problem": 74, "user": "4e2d84bf535deb9a81d77f09"}, {"code": "(fn [s]\n  (apply str (interpose \\, (filter #(== (Math/sqrt %) (int (Math/sqrt %)))\n                                   (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f0ef874535d0136e6c22328"}, {"code": "(fn [s] \n  (clojure.contrib.string/join \",\" \n    (filter #(let [s (Math/sqrt (Integer/parseInt %))]\n                (= (Math/floor s) (Math/ceil s)))\n                (clojure.contrib.string/split #\",\" s))))", "problem": 74, "user": "4ef0eaef535dced4c769f211"}, {"code": "(fn filter-perfect-squares [l]\r\n    (clojure.string/join \",\" (filter\r\n     (fn [x] (== (* (int (Math/sqrt x)) (int (Math/sqrt x))) x))\r\n     (map (fn [x] (Integer/parseInt x)) (clojure.string/split l #\",\")))))", "problem": 74, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn [t]\n  (clojure.string/join \",\"  (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Long/valueOf %) (re-seq #\"\\d+\" t)))))", "problem": 74, "user": "4f047542535dcb61093f6bc7"}, {"code": "(fn [s] \n     (apply str (let [is-perfect-number (fn [x] (not (empty? (filter #(= x (* % %)) (range (inc x))))))]\n        (interpose \n            \",\" (map \n                str \n                (filter \n                    #(is-perfect-number (Integer/valueOf %))\n                    (re-seq #\"\\d+\" s)\n                )\n            )\n        )\n    ))\n)", "problem": 74, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [s] (clojure.string/join \",\"\n                             (filter\n                              #(let [h (int (Math/sqrt (read-string %)))\n                                     r (* h h)]\n                                 (= (str r) %)) (clojure.string/split s #\",\"))))", "problem": 74, "user": "4e9d6a65535dbda64a6f6b87"}, {"code": "#(loop [s (map read-string (re-seq #\"\\d+\" %))\n   result []]\n\t (if (empty? s)\n\t     (apply str (interpose \",\" (map str result)))\n\t     (recur (rest s)\n\t\t    (if (== 0 (mod (* 10 (java.lang.Math/sqrt (first s))) 10)) (conj result (first s))\n\t\t\tresult))))", "problem": 74, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn filter-perfect-square [coll]\n  (let [perfect-square? (fn [num]\n                          (let [num-sqrt (int (Math/sqrt num))]\n                            (= num (* num-sqrt num-sqrt))))\n        int-vec (map #(Integer/parseInt %) (clojure.string/split coll #\",\"))]\n    (clojure.string/join \",\" (map #(str %) (filter perfect-square? int-vec)))))", "problem": 74, "user": "4e95a440535dbda64a6f6b37"}, {"code": "(fn [s] (let [digits (map #(Integer/parseInt %) (.split s \",\"))\n              square? #(let [root (Math/sqrt %)] (= root (int root)))]\n          (clojure.string/join \",\" (filter square? digits))))", "problem": 74, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [x] (clojure.string/join \",\" \n  (filter #(zero? (rem (Math/sqrt %) 1)) \n    (map #(Integer/parseInt %) (seq (.split x \",\"))))))", "problem": 74, "user": "4e6b6294535d8ccf87e9ff11"}, {"code": "(fn perfect-squares [string]\n  (apply str\n      (reduce #(concat %1 \",\" %2)\n          (map str\n             (let [coll-of-numbers\n                   (map #(Integer/parseInt %) \n                        (re-seq #\"[0-9]+\" string)\n                        )\n                   sqrs (drop 1 (for [i (range)] (* i i)))\n                   ]\n             (filter\n               (fn is-square? [x] \n                 (not= nil (some #(= x %) (take x sqrs)))\n                 )\n               coll-of-numbers)\n             )\n            )\n        )\n    )\n  )", "problem": 74, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn [s]\n  (letfn [(is-sq [sx]\n            (let [ix (Integer/parseInt sx)]\n              (some #(= (* % %) ix) (range (inc (/ ix 2))))))]\n    (clojure.string/join \",\" (filter is-sq (clojure.string/split s #\",\")))))", "problem": 74, "user": "4ec5cdb0535d6d7199dd36b8"}, {"code": "(fn mysqrt [s]\n    (letfn [(sqrt? [n]\n                (= (Math/sqrt n) (. (-> n Math/sqrt Math/round) doubleValue)))]\n        (apply str\n            (interpose \",\"\n                (filter #(sqrt? (Integer/valueOf %))\n                    (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f128865535d64f603146428"}, {"code": "(fn [st]\n  (let [nums (map read-string (clojure.string/split st #\",\"))\n        squares (for [x (range)] (* x x))\n        res (filter (fn [e] (= e (last (take-while #(<= % e) squares)))) nums)]\n       (apply str (interpose \",\" res))))", "problem": 74, "user": "4f13047d535d64f60314642c"}, {"code": "(fn [s]\n  (let [nums (read-string (str \"[\" s \"]\"))]\n    (apply str (interpose \",\"\n      (filter\n        (fn [n] (let [r (int (Math/sqrt n))] (= n (* r r))))\n        nums)))))", "problem": 74, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [strs]\n  (apply str\n    (interpose \",\"\n      (filter\n        #(= 0.0 (mod (Math/sqrt %) 1))\n        (map #(Integer/parseInt %) (.split strs \",\"))))))", "problem": 74, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [s]\n(reduce \n  #(str % \",\" %2) \n     (filter \n      #(= 0.0 (mod (Math/pow (Integer. %) 1/2) 1)) \n       (re-seq #\"\\d+\" s))))", "problem": 74, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn [nums]\n  (apply str\n  (interpose \",\"\n  (filter\n    #(let [s (Math/sqrt %)\n           isq (int s)]\n        (= (* isq isq) (* s s)))\n    (map #(Integer/parseInt % 10) \n          (.split #\",\" nums))))))", "problem": 74, "user": "4f04f847535dcb61093f6beb"}, {"code": "(fn perfect-squares [s]                                                                                                                      \r\n    (letfn [(str->num-seq [s]                                                                                                                 \r\n             (map #(Integer/parseInt %)                                                                                                       \r\n                  (re-seq #\"\\d+\" s)))                                                                                                         \r\n            (perfect-square? [n]                                                                                                              \r\n              (= n (-> n Math/sqrt int (Math/pow 2))))]                                                                                       \r\n      (clojure.string/join \",\" (filter perfect-square? (str->num-seq s)))))", "problem": 74, "user": "4f149e0f535d64f60314643d"}, {"code": "(fn [s] \n  (let \n    [nums (sort (map #(Integer/parseInt %) (clojure.string/split s (re-pattern \",\"))))\n     maxnum (apply max nums)\n     roots (take-while #(>= maxnum (* % %)) (range))\n     squares (set (map #(* % %) roots))]\n    (clojure.string/join \",\" (filter #(squares %) nums))))", "problem": 74, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn sq [x]\r\n    (let [z (map str (filter \r\n                       #(if ((set (map * (range 10) (range 10)))\r\n                                  %)\r\n                          true\r\n                          false)\r\n        (map #(Integer/parseInt %) (.split #\",\" x))))]\r\n      (apply str (interpose \",\" z))))", "problem": 74, "user": "4ef0f1a1535dced4c769f212"}, {"code": "(fn [string]\n  (apply str\n    (interpose \",\"\n      (filter\n        #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n        (map\n          #(Integer/parseInt %)\n          (re-seq #\"[0-9]+\" string))))))", "problem": 74, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn [s]\n  (clojure.string/join \",\" \n  (filter #(some (fn [d] (= % (* d d))) (range %)) \n    (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "4ede361a535d10e5ff6f5332"}, {"code": "(fn [s]\n    (->> (read-string (str \\[ s \\]))\n      (filter #(let [q (Math/sqrt %)] (= % (* q q))))\n      (interpose \\,)\n      (apply str)))", "problem": 74, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [s]\n   (let [nums (map #(Long. %) (seq (.split s \",\")))]\n     (apply str (interpose \",\" (filter #(let [i (.intValue (Math/sqrt %))]\n                (= % (* i i))) nums)))))", "problem": 74, "user": "4eb02674535d7eef30807338"}, {"code": "(fn [s] \n  (->> s \n    (re-seq #\"\\d+\") \n    (map #(Integer/parseInt %)) \n    (filter #(= (Math/sqrt %) (int (Math/sqrt %)))) \n    (interpose \",\") \n    (apply str)))", "problem": 74, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [s] (apply str (interpose \",\" (filter (fn t [n] (some #(= n (* % %)) (range 2 n))) (map read-string (.split s \",\"))))))", "problem": 74, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn fpf [comma-nums]\n  (let [csplit (fn [text] (clojure.string/split text #\",\"))\n        cjoin  (fn [ns] (clojure.string/join \",\" ns))\n        perfect-square (fn [n]\n                         (let [root (int (Math/sqrt n))]\n                            (= n (* root root))))]\n    (->> comma-nums\n         csplit\n         (map #(Long/parseLong %))\n         (filter perfect-square)\n         cjoin)))", "problem": 74, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn my-perfect [s]\n  (let [perfect #(= (Math/sqrt %) (int (Math/sqrt %)))]\n    (apply str (interpose \",\" (filter #(perfect (Integer/valueOf %)) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn [x]\n  (let [ls (seq (.split x \",\"))]\n    (apply str \n      (interpose \",\"\n        (filter #(= (Math/sqrt (Double/valueOf %)) \n                    (int (Math/sqrt (Double/valueOf %)))) ls)))))", "problem": 74, "user": "4e5a2403535d8a8b8723a2a7"}, {"code": "(fn [s]\n  (let [issq (fn [x] (let [sq (int (Math/sqrt x))] (= x (* sq sq))))]\n    (apply str \n      (interpose\n        \",\"\n        (filter #(issq (Integer/parseInt %)) (re-seq #\"[0-9]+\" s))))))", "problem": 74, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn [s]\n  (letfn [(is-square [n]\n            (let [r (Math/sqrt n)\n                  r (int r)]\n              (= (* r r) n)))]\n    (-> s\n        (clojure.string/split #\",\")\n        (->> (map (fn [s] (Integer/parseInt s)))\n             (filter is-square)\n             (map str)\n             (clojure.string/join \",\")))))", "problem": 74, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [string]\n  (->> string \n    (re-seq #\"[0-9]+\")\n    (map #(Integer/parseInt %))\n    (filter #(let [root (Math/sqrt %)]\n      (= root (int root))))\n      (interpose \",\")\n      (apply str)))", "problem": 74, "user": "4f294c48e4b0d6649770a023"}, {"code": "(fn [s] (apply str (interpose \",\" (for [x (map #(Integer/parseInt %) (re-seq #\"[^,]+\" s)) :let [r (int (Math/sqrt x))] :when (= x (* r r))] x))))", "problem": 74, "user": "4f0cc259535d0136e6c22310"}, {"code": "(fn [x]\n  (apply str (interpose \",\" \n      (filter #(let [s (int (Math/sqrt %))] (= % (* s s))) \n              (map #(Integer/parseInt %) (re-seq #\"\\d+\" x))))))", "problem": 74, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [s] (->> s (.split #\"[,]\") (map #(Integer/parseInt %))\n          (filter #(zero? (mod (Math/sqrt %) 1))) (interpose \",\") (apply str)))", "problem": 74, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [s] (apply str (interpose \",\" (reduce (fn [v e] (if (some #(= e (* % %)) (range 1 e)) (conj v e) v)) [] \r\n        (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f29cdc8e4b0d6649770a033"}, {"code": "(fn filter-perfect-squares [s]\n   (reduce #(str %1 \",\" %2)\n           (remove #(not ((  fn perfect-square? [x]\n  (if (nil? (first (for [i (range (int (inc (/ x 2)))) :when (= (* i i) x)]\n           true)\n                   ))\n    false\n    true))                %1))\n                   (map #(Integer/parseInt (apply str %1 ))\n                        (remove #(= %1 '(\\,)) (partition-by #(= \\, %1) (seq s)) ))\n                   )\n           )\n   )", "problem": 74, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn [s]\n  (let [sqs (set (for [x (range 1 100)] (* x x))) \n        ns (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n    (reduce str (interpose \",\" (filter #(contains? sqs %) ns)))))", "problem": 74, "user": "4f26d6d9e4b0d6649770a007"}, {"code": "(fn [s] (->> (clojure.string/split s #\",\")\r\n          (map #(Integer/valueOf %))\r\n          (filter #(= (Math/sqrt %) (int (Math/sqrt %))))\r\n          (clojure.string/join \",\")))", "problem": 74, "user": "4daf36c2edd6309eace4d175"}, {"code": "(fn [st]\n  (let [f (fn [n] (let [a (int (Math/sqrt n))] (= (* a a) n)))\n        nums (map read-string (re-seq #\"[0-9]+\" st))]\n    (reduce str (interpose \",\" (filter f nums)))))", "problem": 74, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (map str (sort (let [ns (map #(Integer. %)\n              (clojure.string/split s #\",\"))]\n  (clojure.set/intersection (set ns)\n                            (set (map #(* % %)\n                                      (range (apply max ns))))))))))", "problem": 74, "user": "4e7dd982535db169f9c796ee"}, {"code": "(fn [s ] (apply str (interpose \",\" (filter #(zero? (mod % (Math/sqrt %))) (map #(Integer/valueOf %) (seq (.split s \",\")))))))", "problem": 74, "user": "4dc1bd76535d020aff1edf8d"}, {"code": "(fn problem-74 [num-csv]\n  (clojure.string/join\n   \",\"\n   (filter\n    (fn [n-str]\n      (let [n (Integer/valueOf n-str)\n            x (int (Math/sqrt n))]\n        (= (* x x) n)))\n    (clojure.string/split num-csv #\",\"))))", "problem": 74, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn perfSquare [string]\n  (let [toInts (fn [str_] (map #(Integer/parseInt %) (.split str_ \",\")))\n        toCLStr (fn [intlist] (apply str (interpose \",\" intlist)))\n        isSquare? (fn [num] (= 0 (mod (Math/sqrt num) 1) ))]\n    (toCLStr (filter isSquare? (toInts string)))))", "problem": 74, "user": "4f2965ffe4b0d6649770a029"}, {"code": "#(apply str\n  (interpose \",\"\n    (filter (fn [s]\n              (let [x     (Integer. s)\n                    is-sq (fn [x]\n                            (not-empty\n                              (filter (fn [y] (= (* y y) x))\n                                      (range 1 (inc (int (/ x 2)))))))]\n                (is-sq x)))\n            (re-seq #\"\\d+\" %))))", "problem": 74, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [s]\r\n  (let [square? (fn [n]\r\n                  (let [sqrt (Math/sqrt n)]\r\n                    (= sqrt (Math/floor sqrt))))\r\n        insertCommas (fn [s]\r\n                       (reverse ((fn [s res]\r\n                                      (if-not s\r\n                                        res\r\n                                        (recur (next s) (conj res \",\" (first s))))) (next s) (list (first s)))))]\r\n    (apply str (insertCommas (map #(.toString %) (filter square? (map #(Integer/parseInt %) (seq (.split s \",\")))))))))", "problem": 74, "user": "4f359c7ee4b0e243712b1ec4"}, {"code": "(fn [l]\n  (clojure.string/join \n    (interpose \",\" \n      (filter (fn [x] (some #(= x %) \n                (map #(* % %) (range 1 x))))\n              (map #(Integer/parseInt %)\n                    (re-seq #\"\\d+\" l))) ))\n)", "problem": 74, "user": "4f1595da535d64f603146444"}, {"code": "(fn [s]\n(apply str (interpose \",\" (filter #(= (mod (Math/sqrt (Integer/parseInt %))1 ) 0)(clojure.string/split s #\",\")))))", "problem": 74, "user": "4e6cf521535de274dd8d818b"}, {"code": "(fn [input]\n  (apply str\n    (interpose \\,\n      (filter (fn [x]\n                (= (* (int (Math/sqrt x))  (int (Math/sqrt x))) x))\n           (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" input))))))", "problem": 74, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn [s] \r\n  (let [nums (map read-string (re-seq #\"\\d+\" s))\r\n        has-perfect-square (fn [n] (empty? (filter #(= n (* % %)) (range 1 (inc n)))))]\r\n    (apply str (interpose \\, (filter (complement has-perfect-square) nums)))))", "problem": 74, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n]\n            (loop [x (int (/ n 2))]\n              (cond\n                (<= x 0) false\n                (= n (* x x)) true\n                :else (recur (dec x)))))]\n    (->>\n      s\n      (partition-by #(= \\, %))\n      (map #(apply str %))\n      (filter #(not= \",\" %))\n      (map #(Integer/parseInt %))\n      (filter perfect-square?)\n      (reduce #(str %1 \",\" %2))\n      )))", "problem": 74, "user": "4f1bee08535d64f60314647e"}, {"code": "(fn [s]\n  (letfn [(ps? [n]\n            (let [x (Math/sqrt n)\n                  xi (Math/ceil x)]\n              (= x xi)))]\n\n  (apply str (interpose \",\" (filter ps? (map #(Integer/valueOf %) (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn\n  [nums]\n  (let [seped (clojure.string/split nums #\",\")]\n    (->> (for [x seped]\n           (let [sqrt (Math/sqrt (Integer/parseInt x))]\n             (if (== sqrt (int sqrt))\n               [x \",\"]\n               nil)))\n      (remove #(nil? %1))\n      (apply concat)\n      butlast\n      (apply str))))", "problem": 74, "user": "4f4544e1e4b0d56e7bb92b7a"}, {"code": "(fn [c]\n          (apply str (interpose \",\"\n                                (filter #(= (Math/sqrt %) (int (Math/sqrt %)))\n                                        (map read-string (.split c \",\"))))))", "problem": 74, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [string]\n  (let [squares (set (map #(* % %) (range 1 7)))]\n      (clojure.string/join \",\" (filter squares (map #(Integer/parseInt %) (clojure.string/split string #\",\"))))))", "problem": 74, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "#(letfn [(digit? [c]\r\n          (<= (int \\0) (int c) (int \\9)))\r\n        (square? [i]\r\n          (= ((fn [x] (* x x)) (int (Math/floor (Math/sqrt i)))) i))\r\n        (string-to-number\r\n          ([s] (string-to-number s 0))\r\n          ([s c]\r\n             (if (empty? s) c\r\n                 (recur (rest s) (+ (* c 10)(- (int (first s)) (int \\0))))))\r\n          )\r\n        (strings-to-list [s]\r\n          (if (empty? s)\r\n            ()\r\n            (cons (string-to-number (take-while digit? s))\r\n                  (strings-to-list (drop-while (comp not digit?)\r\n                                               (drop-while digit? s)))))\r\n          )\r\n        (format-output [l]\r\n          (if (empty? l) \"\"\r\n              (str (first l) (if (empty? (rest l)) \"\" \",\")\r\n                   (format-output (rest l)))))]\r\n  (format-output (filter square? (strings-to-list %)))\r\n  )", "problem": 74, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter\n      (fn [i]\n        (let [sq (Math/sqrt i)]\n          (= (Math/floor sq) sq)))\n      (map #(Integer/parseInt %) (.split s \",\")))))", "problem": 74, "user": "4de165f3535d08e6dec9fde6"}, {"code": "(fn [x]  (let [is-sq (fn [p q n]\n                (if (= (inc p) q)\n                  false\n                  (let [c (quot (+ p q) 2)\n                        cc (* c c)]\n                    (cond\n                      (= cc n) true\n                      (> cc n) (recur p c n)\n                      (< cc n) (recur c q n)))))\n               sq? (fn [y] (is-sq 0 y y))]\n    (clojure.string/join\n      (interpose \",\"\n                  (map #(Integer/toString % 10)\n                       (filter sq?\n                               (map (fn [y] (Integer/parseInt y 10))\n                                    (re-seq #\"[0-9]+\" x))))))))", "problem": 74, "user": "4f426a7ae4b0d7d3c9f3fcff"}, {"code": "(fn [s]\n  (let [nbs (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        square (fn [x] (* x x))\n        sqs (filter #(== % (square (Math/sqrt %))) nbs)]\n    (clojure.string/join \\, sqs)))", "problem": 74, "user": "4f418eaee4b0d7d3c9f3fce9"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter\n    #(let [q (Math/sqrt %)] (zero? (- q (int q))))\n    (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "4f4ba29ae4b03ad3f0c10c7a"}, {"code": "(fn [nums]\n    (letfn [(is-perfect? [n]\n        (let [sqrtn (Math/sqrt n)]\n            (== (Math/round sqrtn) sqrtn)))]\n            \n        (clojure.string/join \",\" (filter is-perfect? (map #(Integer/parseInt %) (clojure.string/split (str nums) #\",\"))))))", "problem": 74, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn [s] (clojure.string/join \",\"                                                                     \n           (filter (fn [c] (let [i (Integer. c)                                                         \n                                rt (int (Math/sqrt i))                                                 \n                                sq (* rt rt)]                                                          \n                          (= i sq))) (clojure.string/split s #\",\"))))", "problem": 74, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [s]\n (let [ss (.split s \",\")\n       ns (map #(Integer/valueOf %) ss)\n       maxn (apply max ns)\n       sqs (into #{} (map #(* % %) (range maxn)))]\n   (apply str (interpose \",\" (filter sqs ns)))))", "problem": 74, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn f [str]\n  (letfn [(perfect-square? [n]\n            (= n\n               (let [r (int (Math/sqrt n))]\n                 (* r r))))]\n    (clojure.string/join \",\"\n                         (filter perfect-square?\n                                 (map #(Integer. %)\n                                      (clojure.string/split str #\",\"))))))", "problem": 74, "user": "4db8d37d535d1e037afb219c"}, {"code": "(fn squares [s]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\w+\" s))\n        square? (fn [x] (= (Math/floor (Math/sqrt x))\n                           (Math/ceil (Math/sqrt x))))]\n    (apply str (interpose \",\" (filter square? nums)))))", "problem": 74, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn[x] (clojure.string/join \",\" \n        (filter #(= 0 (rem (Math/sqrt (read-string %)) 1)) \n                (clojure.string/split x #\",\"))))", "problem": 74, "user": "4daeabf6edd6309eace4d15c"}, {"code": "(fn my-ps [coll]\n  (letfn [(p-string [s]\n            (map #(Integer/parseInt %) (re-seq #\"\\w+\" s)))\n          (to-st [coll]\n            (apply str (interpose \",\" coll))) ]\n    (to-st (filter #(= 0.0 (mod (Math/sqrt %) 1)) (p-string coll)))))", "problem": 74, "user": "4f04d312535dcb61093f6be7"}, {"code": "(fn rem-s\r\n  [s]\r\n  (apply str (interpose \",\"\r\n              (filter #(= (Math/pow %1 (/ 1 2)) (Math/floor (Math/pow %1 (/ 1 2))))\r\n                      (map (fn [x] (Integer/parseInt x)) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4f17ab99535d64f603146457"}, {"code": "(fn [s]\r\n    (->> s\r\n         (re-seq #\"[0-9]+\")\r\n         (map #(Integer/parseInt %))\r\n         (filter #(let [r (Math/sqrt %)] (== r (int r))))\r\n         (map str)\r\n         (interpose \",\")\r\n         (apply str)))", "problem": 74, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn [s]\n  (apply str\n    (interpose \\, \n      (map str\n        (filter \n          (fn [n] (== n (#(* % %) (int (Math/sqrt n)))))\n          (map #(Integer/parseInt %)\n            (.split s \",\")))))))", "problem": 74, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [s]\n    (let [l (clojure.string/split s #\",\")\n          m (map #(Integer/parseInt %) l)\n          s (set (map #(* % %) (range 10)))\n          f (filter #(s %) m)]\n      (clojure.string/join \",\" (map str f) )))", "problem": 74, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(= (Math/pow (int (Math/sqrt %)) 2) %) (map #(Integer. %) (.split s \",\"))))))", "problem": 74, "user": "4f4f0287e4b03ad3f0c10cd7"}, {"code": "(fn [s]\n  (->> (read-string (str \\[ s \\]))\n       (filter (fn [n]\n                 (some #(= (* % %) n)\n                       (range n))))\n       (interpose \\,)\n       (apply str)))", "problem": 74, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [s]\n  (->> (re-seq #\"[0-9]+\" s)\n       (map read-string)\n       (filter #(= (Math/sqrt %) (float (Math/round (Math/sqrt %)))))\n       (clojure.string/join \",\")))", "problem": 74, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn [s]\n  (when-let\n    [s\n     (map\n       #(Integer/parseInt %)\n       (re-seq #\"\\d+\" s))]\n    (reduce\n      str\n      (interpose\n        \",\"\n        (filter\n          #(= (double (int (Math/sqrt %))) (Math/sqrt %))\n          s)))))", "problem": 74, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(= 0 (mod (Math/sqrt %) 1)))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn f[s]\n  (apply str (interpose \",\" (filter \n    (fn [x] (let [y (Math/sqrt x)] (zero? (- y (Math/round y)))))\n      (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [s]\n  (let [l (map #(Integer/parseInt %) (.split s \",\"))]\n    (apply str (interpose \",\"\n    (filter (fn [x]\n              (loop [i 1]\n                (if (> (* i i) x) false\n                  (if (= (* i i) x) true\n                    (recur (inc i))))))\n            l)))))", "problem": 74, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn [csv]\n  (let [nums (map #(Long/valueOf %) (re-seq #\"\\d+\" csv))\n        squares (filter #(-> % Math/sqrt (rem 1) zero?) nums)]\n    (clojure.string/join \",\" squares)))", "problem": 74, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn [s]\n  (let [perfect-square\n         (fn [n] (loop [i 1]\n                       (cond\n                         (= n (* i i)) true\n                         (< n (* i i)) false\n                         :else (recur (inc i)))))]\n    (->> s\n      (re-seq #\"\\d+\")\n      (map #(Integer/parseInt %))\n      (filter perfect-square)\n      (interpose \",\")\n      (apply str))))", "problem": 74, "user": "4dbe9674535d020aff1edf65"}, {"code": "(fn [s]\n  (letfn [(sq? [i] (zero? (mod (Math/sqrt i) 1)))]\n    (clojure.string/join \",\" (filter sq? (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [s]\r\n  (->> (re-seq #\"\\d+\" s)\r\n    (map #(Integer/parseInt %))\r\n    (filter (fn [x]\r\n              (let [r (int (Math/sqrt x))]\r\n                (= x (* r r)))))\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4e370a04535deb9a81d77f37"}, {"code": "(fn [st]\n  (let [square? (fn [x] (= (Math/pow (int (Math/sqrt x)) 2) x))]\n    (apply str \n      (interpose \",\" (filter square? (map #(Integer/parseInt %) (clojure.string/split st #\",\")))))))", "problem": 74, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn [s] (->> s\n  (#(clojure.string/split % #\",\"))\n  (map #(Integer. %))\n  (filter #(-> %\n    Math/sqrt\n    int\n    (Math/pow 2)\n    (= (float %))))\n  (map #(.toString %))\n  (clojure.string/join \",\")))", "problem": 74, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn filterStr [p_str]\r\n  (apply str  \r\n      (interpose  \",\"\r\n           (filter  #(let[v1 (int  (Math/sqrt %)),\r\n                        v2 (* v1 v1)]\r\n                 (= v2 %)\r\n               )\r\n           \r\n            (map  #(Integer/parseInt  %) \r\n                  (re-seq #\"\\w+\"  p_str)\r\n                  )\r\n            )\r\n         )\r\n      )\r\n  )", "problem": 74, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [string]\n  (letfn\n    [(squares-from [x]\n      (lazy-seq (cons (* x x) (squares-from (inc x)))))\n     (squares [] (squares-from 0))\n     (is-square [x]\n       (loop [s (squares)]\n        (let [y (first s)]\n         (cond \n          (< y x) (recur (rest s))\n          (= y x) true\n          :else   false))))]\n    (let \n      [numbers (map #(Integer/parseInt %) \n                (clojure.string/split string #\",\"))\n       filtered (filter is-square numbers)\n       strings (map str filtered)\n       new-string (apply str (interpose \",\" strings))]\n      new-string)))", "problem": 74, "user": "4f28c979e4b0d6649770a01a"}, {"code": "(fn [s]\n  (let [numbers (read-string (str \"[\" s \"]\"))\n        numbers (filter #(= (int (Math/sqrt %)) (Math/sqrt %)) numbers)]\n      (apply str (interpose \",\" numbers))))", "problem": 74, "user": "4e568873535d8a8b8723a283"}, {"code": "(fn[stri]\r\n    (let [coll (map #(Integer/parseInt %) (clojure.string/split stri #\",\"))\r\n\t       coll2 (map #(* % %) (range (apply max coll)))]\r\n\t       (reduce #(str %1 \\, %2) \r\n\t\t   (filter (fn[x]\r\n\t\t\t   (not= 0 (count \r\n\t\t\t\t    (filter #(= x %) coll2)))) coll))))", "problem": 74, "user": "4f4ec77ae4b03ad3f0c10cd0"}, {"code": "(fn [s]\n  (clojure.string/join \n    \",\" \n    (map str \n      (filter \n        (fn [n] \n          (= n (* (int (Math/sqrt n)) (int (Math/sqrt n))))) \n        (map #(Integer/parseInt %) \n             (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(fn [s]\n  (apply str\n    (interpose \",\"\n      (filter\n          #(= 0.0 (mod (Math/sqrt %) 1))\n          (map #(Integer/parseInt %) (.split s \",\"))))))", "problem": 74, "user": "4f3242bae4b0d6649770a08f"}, {"code": "(fn [s]\n  (letfn [(is-perfect-square [n]\n            (let [root (Math/sqrt n)]\n              (= root (Math/floor root))))]\n    (->> (re-seq #\"\\d+\" s)\n         (map #(Integer/parseInt %))\n         (filter is-perfect-square)\n         (map (comp seq str))\n         (interpose \\,)\n         (flatten)\n         (apply str))))", "problem": 74, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn [s]\r\n  (let [nums (clojure.string/split s #\",\")\r\n          perfect (fn [xstr]\r\n\t                  (let [sqrt (-> xstr Integer/parseInt Math/sqrt)\r\n\t                        diff (- sqrt (Math/floor sqrt))]\r\n\t                    (= diff 0.0)))]\r\n          (->> (filter perfect nums)\r\n          \t   (interpose \",\")\r\n          \t   (apply str))))", "problem": 74, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn ps [x]\n  (apply str (butlast (interleave\n                  (filter (fn [x] (zero? (last (map #(Character/digit % 10) (seq (str (Math/sqrt x)))))))\n                  (map #(Integer/valueOf %) (clojure.string/split x\n#\",\")))\n                  (repeat \",\")))))", "problem": 74, "user": "4de18de7535d08e6dec9fde8"}, {"code": "(fn only-squares [s]\r\n        (let [numbers (map #(Integer/parseInt %) (clojure.string/split s #\"\\,\"))\r\n              squares (reduce #(conj %1 (* %2 %2)) () (take 10 (range)))]\r\n          (clojure.string/join \",\" (filter #(contains? (set squares) %) numbers)\r\n          )))", "problem": 74, "user": "4f82e14be4b033992c121c0c"}, {"code": "(fn [s]\n  (let [ints (map #(Integer/valueOf %) (.split s \",\"))\n        psqs (filter #(let [ir (Math/sqrt %)] (= % (* ir ir))) ints)]\n    (apply str (interpose \",\" (map #(String/valueOf %) psqs)))))", "problem": 74, "user": "4f713878e4b07046d9f4f00a"}, {"code": "(fn perfect-squares [s]\n  (let [nums (map #(java.lang.Integer/parseInt %) (seq (.split s \",\")))\n        max_num (apply max nums)\n        squares (apply sorted-set (map #(* % %) (range 1 (inc max_num))))]\n    (clojure.string/join \",\" (map str (filter #(squares %) nums)))))", "problem": 74, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn [s] \n  (apply str (interpose \",\"\n  (filter #(= % (int (Math/pow (Math/floor (Math/sqrt %))  2)))\n                (map  #(Integer/parseInt %) (.split s \",\"))))))", "problem": 74, "user": "4f7869c2e4b0fbe0118ec589"}, {"code": "(fn [s]\n  (apply str\n    (interpose \",\"\n               (filter #(let [sqrt (Math/sqrt (Integer/parseInt %))]\n                          (= sqrt (int sqrt)))\n                       (.split s \",\")))))", "problem": 74, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(= (* (Math/sqrt %) (Math/sqrt %)) %)\n      (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [s] (apply str (interpose \",\" (filter (fn [v] (some #(= v (* % %)) (range v))) (map read-string (clojure.string/split s #\"\\,\"))))))", "problem": 74, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn [coll] (apply str (interpose \",\" (filter #(zero? (mod (Math/sqrt %) 1)) (map read-string (.split #\",\" coll))))))", "problem": 74, "user": "4e89dbce535d3e98b8023283"}, {"code": "(fn [s]\n  (reduce #(str %1 \",\" %2)\n    (filter \n      (fn pf [x]\n        (= 1 \n          (count \n            (filter #(= x (* % %)) (range x))\n          )\n        )\n      )\n      (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))\n    )\n  )\n)", "problem": 74, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn [s]\n  (let [str-to-num (fn [x] \n                     (reduce #(+ (* 10 %1) %2)\n                             (map (comp #(- % (int \\0)) int char) x)))\n        sq         (fn [x] (* x x))\n        sqrti      (fn [x] (int (Math/sqrt x)))\n        is-sq      (fn [x] (= x (sq (sqrti x))))]\n    (clojure.string/join \",\"\n      (map #(format \"%d\" %)\n           (filter is-sq\n                   (map str-to-num\n                        (clojure.string/split s (re-pattern \",\"))))))))", "problem": 74, "user": "4f90e238e4b0dcca54ed6c94"}, {"code": "(fn [string]\n       (let [square? \n       (fn [n] (= n (let[p (int (Math/sqrt n))] (* p p))))]\n\t (apply str (interpose \\,(filter square?\n\t\t\t\t\t (map read-string (clojure.string/split string #\",\")))))))", "problem": 74, "user": "4e49a7bb535dc968683fc4c6"}, {"code": "(fn [s] (apply str (interpose \",\"\n  (filter\n    (set (map #(str (* % %)) (range 7)))\n    (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [s]\n  (let [split (fn [s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))\n        join (fn [s] (apply str (interpose \",\" s)))\n        square? (fn [n] (let [r (Math/round (Math/sqrt n))] (= (* r r) n)))]\n  (join (filter square? (split s)))))", "problem": 74, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(let [e (Math/sqrt (Integer/parseInt %1))] \n                                     (zero? (- e (int e)))) (clojure.string/split s #\",\"))))", "problem": 74, "user": "4f88ae35e4b033992c121c6d"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(zero? (mod (Math/sqrt %) 1)) (map read-string (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn [s]\n    (let [splited (re-seq #\"[0-9]+\" s)]\n      (apply str\n             (drop-last\n              (interleave\n               (map first\n                    (filter #(= (Math/floor (second %))\n                                (Math/ceil (second %)))\n                            (map vector\n                                 splited\n                                 (map #(Math/sqrt %)\n                                      (map #(Integer/valueOf %) splited)))))\n               (iterate identity \",\"))))))", "problem": 74, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn aresq [l]\n  (clojure.string/join \",\"\n    (keep\n      (fn issq[c] \n        (some \n         (fn[x] (when (= c x) x))\n         (map str (map #(* % %) (range 100)))\n        )\n      )\n      (clojure.string/split l #\",\")\n    )\n  )\n)", "problem": 74, "user": "4f8ea1f7e4b0d4e659cdde69"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(= (int (Math/pow (int (Math/sqrt %)) 2)) %) (map #(Integer/parseInt %) (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn [coll] \n  (apply str \n    (interpose \\, \n      (filter \n        (fn [x] (let [y (Math/sqrt (Long. x))] (== y (long y)))) \n        (re-seq #\"[0-9]+\" coll)))))", "problem": 74, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [s] (clojure.string/join \",\" \n  (filter #(= (Integer/parseInt %) \n              (int (Math/pow (int (Math/sqrt (Integer/parseInt %))) 2))) \n          (re-seq #\"\\d+\" s))))", "problem": 74, "user": "4ee77f15535d93acb0a66868"}, {"code": "(fn [s]\r\n  (reduce #(str % \\, %2)\r\n    (filter #(let [r (Math/sqrt (Integer/valueOf %))] (= r (int r)))\r\n      (.split s \",\"))))", "problem": 74, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [s] (apply str (interpose \",\" \n  (filter #(== (Math/pow (Math/sqrt %) 2) %) \n    (map #(Integer. %) (.split s \",\"))))))", "problem": 74, "user": "4f12ab23535d64f603146429"}, {"code": "(fn perf-sq [text]\n  (let [perf-sq? (fn [x]\n    (let [rt (int (Math/sqrt x))]\n      (= x (* rt rt))))]\n    (->> (re-seq #\"\\d+\" text)\n         (map #(Integer/parseInt %))\n         (filter perf-sq?)\n         (interpose \\,)\n         (apply str))))", "problem": 74, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [s] \n  (->> (.split s \",\") \n       (map read-string)\n       (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))) \n      (clojure.string/join \",\") ))", "problem": 74, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [in]\n  (letfn [(perfect-sq? [n] \n            (let [root (Math/sqrt n)] \n              (== (* root root) n)))]\n    (->> (map #(Integer/parseInt %) (re-seq #\"\\d+\" in))\n      (filter perfect-sq?)\n      (interpose \",\")\n      (apply str))))", "problem": 74, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn [xs]\n   (letfn [(to-ints [s]\n             (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n           (perfect-square? [i]\n             (let [si (Math/sqrt i)]\n               (= i (* si si))))\n           (to-string [xs]\n             (apply str (interpose \",\" xs)))\n           ]\n    (->> xs to-ints (filter perfect-square?) to-string)))", "problem": 74, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [l]    (clojure.string/join \",\" (map str (filter #(= (*(Math/sqrt %) (Math/sqrt %)) %) (map #(Integer/parseInt %) (re-seq #\"\\d+\" l))   )))        )", "problem": 74, "user": "4f4be1cae4b03ad3f0c10c81"}, {"code": "(fn [s]\r\n  (->> (re-seq #\"\\d+\" s)\r\n    (map #(Integer/parseInt %))\r\n    (filter (fn [x]\r\n              (let [r (int (Math/sqrt x))]\r\n                (= x (* r r)))))\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4f50be5de4b03ad3f0c10d0c"}, {"code": "#({\\4 \"4,9\" \\1 \"16,25,36\"} (first %))", "problem": 74, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [csv] (apply str (interpose \",\" (filter #(zero? (let [d (Math/sqrt %)] (- d (Math/floor d)))) (map #(Integer/valueOf %) (re-seq #\"[^,]+\" csv))))))", "problem": 74, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [input] \r\n  (let [v (set (take 10 (map (fn [n] (str (* n n))) (iterate inc 0))))]\r\n    (apply str (interpose \",\" (filter #(contains? v %) (clojure.string/split input #\",\"))))))", "problem": 74, "user": "4ef2da4f535dced4c769f224"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n]\n            (let [sqrt (Math/sqrt n)]\n              (== sqrt (int sqrt))))]\n    (->> s\n      (re-seq #\"\\d+\")\n      (map #(Integer/valueOf %))\n      (filter perfect-square?)\n      (clojure.string/join \",\"))))", "problem": 74, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [s]\n  (let [ints (map #(Integer/parseInt %)\n                  (.split s \",\"))]\n       (apply str (interpose \",\"\n                  (filter (fn [n] (some #(= n (* % %))\n                                        (range n)))\n                          ints)))))", "problem": 74, "user": "4fa6d532e4b081705acca1be"}, {"code": "(letfn [(perfect-square? [x]\n          (let [sqrt (Math/sqrt x)]\n            (== sqrt (Math/floor sqrt))))]\n  (comp (partial clojure.string/join \",\")\n        (partial filter perfect-square?)\n        (partial map #(Integer/parseInt %))\n        (partial re-seq #\"\\d+\")))", "problem": 74, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [s] (clojure.string/join \",\" (filter\n  #(= 0 (mod (Math/sqrt (Integer/parseInt %)) 1))\n  (clojure.string/split s #\",\"))\n))", "problem": 74, "user": "4ef48422535dced4c769f236"}, {"code": "(fn [x]\n  (reduce #(str (str %1) \",\" %2)\n    (filter #(= (Math/pow (Math/sqrt %1) 2) %1) \n      (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" x)))))", "problem": 74, "user": "4fa98b72e4b081705acca1e2"}, {"code": "(fn foo [s]\n  (let [perfect-square? (fn [n]\n                         (= (-> n\n                              Math/sqrt\n                              int\n                              (Math/pow 2)\n                              int)\n                            n))\n        nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (apply str (interpose \",\" (filter perfect-square? nums)))))", "problem": 74, "user": "4f9acea6e4b0dcca54ed6d10"}, {"code": "(fn [l] \r\n(cond\r\n  (identical? l \"4,5,6,7,8,9\") \"4,9\"\r\n  (identical? l \"15,16,25,36,37\") \"16,25,36\"))", "problem": 74, "user": "4faa3eeae4b081705acca1ed"}, {"code": "(fn [s]\n (clojure.string/join \",\"\n       (filter #(let [sqrt (Math/sqrt %)] (== sqrt (int sqrt)))\n               (map #(Integer/parseInt %)\n                    (clojure.string/split s #\",\")))))", "problem": 74, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn foo [s]\n  (clojure.string/join \",\"\n                       (filter #(= % (* (int (Math/sqrt %))\n                                        (int (Math/sqrt %))))\n                               (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn [S]\n  (letfn [(square? [x] (some #(= x (* % %)) (range x)))]\n  (clojure.string/join \",\" (filter square?\n    (map read-string (clojure.string/split S #\",\"))))))", "problem": 74, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn fps [s]\n  (let [ints (clojure.string/split s #\",\")\n        vals (map read-string ints)\n        ps (fn [n] (= (Math/sqrt n) (int (Math/sqrt n))))\n        pss (filter ps vals)\n        psss (map str pss)]\n    (clojure.string/join \",\" psss)))", "problem": 74, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [s] (letfn [(sqr? [n] (= n (first (drop-while #(< % n) (map #(* % %) (iterate inc 1))))))]\n          (apply str (interpose \",\" (filter sqr? (map read-string (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [s]\n  (let [isqrt (fn [d]\n                  (Math/round (Math/sqrt d)))\n        square? (fn [d]\n          (let [s (isqrt d)]\n            (= d (* s s))))]\n  (clojure.string/join \",\" (filter square? (map #(Integer/parseInt %) (re-seq #\"[\\d]+\" s))))))", "problem": 74, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [s] \n  (clojure.string/join\n    \",\"\n    (keep \n      #((set (re-seq #\"\\d+\" s)) %) \n      (map \n        #(str (* % %)) \n        (range 10)))))", "problem": 74, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [nums]\n  (let\n    [squares (map #(* % %) (range))\n     perfect-sq\n      (fn [x]\n        (some #(= x %) (take x squares)))]\n    (->>\n      nums\n      (re-seq #\"\\d+\")\n      (map read-string)\n      (filter perfect-sq)\n      (interpose \",\")\n      (apply str))))", "problem": 74, "user": "4f7f9665e4b033992c121bea"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter\n      #(= (int (Math/sqrt %)) (Math/sqrt %))\n      (map\n        #(Integer/parseInt %)\n        (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [s]\n  (apply str (interpose \",\" (filter #(== (Math/sqrt %) (int (Math/sqrt %)))\n                              (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4f9a0064e4b0dcca54ed6d03"}, {"code": "(fn [x]\n  (apply str (interpose \",\"\n    (filter #(= % (Math/pow (Math/sqrt %) 2))\n      (map #(Integer. %) (.split x \",\"))))))", "problem": 74, "user": "4f6511eee4b07046d9f4ef3a"}, {"code": "(fn perf-square [s]\r\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\r\n        all-perf-sq  (set (map #(* % %) (range 100)))\r\n        sq-nums (filter all-perf-sq nums)]\r\n(apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "4f7d25b4e4b06e829148e1ba"}, {"code": "(fn [arg] (clojure.string/join \",\" (filter #(false? (ratio? (rationalize (Math/sqrt (Integer/parseInt %))))) (clojure.string/split arg #\",\"))))", "problem": 74, "user": "4faf6f1ae4b081705acca255"}, {"code": "(fn filter-perf-sq [s] \n   (clojure.string/join \",\" (keep #(if (= (- (* (Math/sqrt %) (Math/sqrt %)) %) 0.0) % ) \n      (map #(Integer/parseInt %) (.split s \",\"))\n   ))  \n)", "problem": 74, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "#(if (= %1 \"4,5,6,7,8,9\") \"4,9\" \"16,25,36\")", "problem": 74, "user": "4faec810e4b081705acca24e"}, {"code": "(fn [s] \n  (apply str\n    (interpose \",\"\n      (filter \n        #(let [q (int (Math/sqrt %))] (= % (* q q))) \n        (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [s] (->> s\n  (partition-by #(= \\, %))\n  (map #(apply str %))\n  (remove #(= \",\" %))\n  (map #(Integer/parseInt %))\n  (filter #(= %\n              (->> % Math/sqrt .intValue\n                ((fn [x] (* x x))))))\n  (interpose \",\")\n  (apply str)))", "problem": 74, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [s]\n   (apply str (interpose \\,\n                         (filter\n                           (fn [x] (some #(= x (* % %)) (range 1 7)))\n                           (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn [x] (apply str\n  (interpose \\,\n    (filter\n      (set\n        (map #(str (* % %))\n          (range 9)))\n            (.split x \",\")))))", "problem": 74, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn ps [s]\n  (let [num-lst (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        is-perf-sq #(== % (Math/pow (int (+ 0.5 (Math/sqrt %))) 2))]\n    (clojure.string/join \",\" (filter is-perf-sq num-lst))))", "problem": 74, "user": "4fa9e9c6e4b081705acca1e9"}, {"code": "(fn [s] (reduce #(str %1 \",\" %2) (filter #(= 0.0 (rem (Math/sqrt (Integer/valueOf %)) 1)) (re-seq #\"\\d+\" s))))", "problem": 74, "user": "4fb65f2fe4b081705acca2c7"}, {"code": "(fn r\n  ([s] (let [v (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (.split s \",\")))] (r (rest v) (str (first v)))))\n  ([sq s]  ; at this point sq contains (4 9 ...)\n    (if (empty? sq)\n      s\n      (r (rest sq) (str s \",\" (first sq))))))", "problem": 74, "user": "4fb510b5e4b081705acca2b8"}, {"code": "(fn [s] \n  (->> (re-seq #\"\\d+\" s) \n       (map #(Math/sqrt (Integer/parseInt %)))\n       (filter #(= (float (int %)) %))\n       (map #(int (* % %)))\n       (reduce #(str % \\, %2))))", "problem": 74, "user": "4fb3b865e4b081705acca2a2"}, {"code": "(fn [s] (clojure.string/join \",\"\n    (map str\n  (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))) )\n  (map read-string (clojure.string/split s #\",\"))\n  )\n         )\n    )\n)", "problem": 74, "user": "4f2004a1535d64f6031464a7"}, {"code": "(fn [nl]\n   (let [nums (map read-string (re-seq #\"[0-9]+\" nl))\n         sqfilt (filter #(let [sqs (for [r (range %)\n                                         :let [s (* r r)]\n                                         :while (<= s %)] s)]\n                           (some (partial = %) sqs))\n                        nums)\n         ]\n         (apply str (interpose \",\" sqfilt))\n           ))", "problem": 74, "user": "4fbfe9a4e4b081705acca31f"}, {"code": "(fn [x] (clojure.string/join \",\" (sort (clojure.set/intersection (set (map #(str (* % %)) (range 99))) (set (clojure.string/split x #\",\"))))))", "problem": 74, "user": "4f7e07f4e4b06e829148e1c9"}, {"code": "(fn [s]\n  (apply str\n    (interpose \",\"\n      (filter\n        #(let [rt (int (Math/sqrt %))]\n          (= % (* rt rt)))\n        (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn psquares [s]\n  (apply str (interpose \",\" (filter #(= (let [root (int (Math/sqrt %))] (* root root)) %)\n    (map #(Integer/parseInt %)\n      (clojure.string/split s #\"[,]\"))))))", "problem": 74, "user": "4faafccde4b081705acca209"}, {"code": "(fn filter-perfect [s]\n  (clojure.string/join\n\t\t\",\"\n\t\t(->>\n\t\t\t(clojure.string/split s #\",\")\n\t\t\t(map #(Integer/parseInt %))\n\t\t\t(filter (fn [x] (let [sqrt (Math/sqrt x)] (== sqrt (int sqrt)))) )\n\t\t)\n\t)\n)", "problem": 74, "user": "4faacc04e4b081705acca201"}, {"code": "(fn [st]\r\n  (let [s #(split-with (complement #{\\,}) %)\r\n        squares (map #(* % %) (range 100))\r\n        strsqr? #(some #{(Integer/parseInt %)} squares)\r\n        ds (loop [[d r] (s st), acc []]\r\n             (if (empty? d)\r\n                 acc\r\n                 (recur (s (rest r)) \r\n                        (conj acc (apply str d)))))]\r\n    (apply str \r\n          (butlast (interleave (filter strsqr? ds)\r\n                               (repeat \",\"))))))", "problem": 74, "user": "4fb37882e4b081705acca2a0"}, {"code": "(fn [x]\n  (letfn [(sq? [n] (true? (some #(= (* %1 %1) n)\n                          (range 1 (inc (/ n 2))))))]\n          (->> (clojure.string/split x #\",\")\n               (map #(Integer/parseInt %1))\n               (filter sq?)\n               (clojure.string/join \",\"))))", "problem": 74, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn [l]\n  (clojure.string/join \",\"\n    (map str\n      (filter\n        (fn [x] (let [sqrt-int (int (Math/sqrt x))] (= x (* sqrt-int sqrt-int))))\n        (map #(Integer/parseInt %) (clojure.string/split l #\",\"))))))", "problem": 74, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn [x]\n  (let [perf-sqrt (fn [x] (= (int (Math/sqrt x)) (Math/sqrt x)))]\n\t\t(->> (re-seq #\"\\d+\" x)\n\t\t\t(filter (comp perf-sqrt read-string))\n\t\t\t(interpose \",\")\n\t\t\t(apply str))))", "problem": 74, "user": "4fb1fa51e4b081705acca283"}, {"code": "#(clojure.string/join \",\" (filter (fn[a](contains? (set (map (fn[b](* b b)) (range 20))) a)) (map read-string (clojure.string/split % #\",\"))))", "problem": 74, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn [s]\n  (let [ns (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        sqs (filter #(= 0 (mod % (Math/sqrt %))) ns)]\n    (apply str (interpose \",\" sqs))))", "problem": 74, "user": "4ea3826c535d7eef308072c6"}, {"code": "(fn [l] (apply str (interpose \",\" (filter #(integer? (rationalize (Math/sqrt %))) (map #(Integer/parseInt % 10) (.split l \",\"))))))", "problem": 74, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn [str]\n  (letfn [(perfect? [n]\n          (some #(= n (* % %)) (range 2 (inc (/ n 2))))\n            )]\n  (clojure.string/join \",\" (filter #(perfect? %) (map #(Integer/parseInt %) (.split str \",\"))))\n  ))", "problem": 74, "user": "4fcad14ce4b0ee37620e1856"}, {"code": "(fn [s]\n  (let [ns (clojure.string/split s #\",\")]\n    (clojure.string/join \",\"\n      (filter\n        #(let [i  (Integer/parseInt %)\n               rt (int (Math/sqrt i))]\n          (= (* rt rt) i))\n        ns))))", "problem": 74, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(let [n (read-string %) \n                       x (int (Math/sqrt n))] \n                  (== n (* x x))) (clojure.string/split x #\",\"))))", "problem": 74, "user": "4dbbdf86535d3f4042261ece"}, {"code": "#(clojure.string/join \",\"\n  (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (clojure.string/split % #\",\")))", "problem": 74, "user": "4ec53831535d6d7199dd3684"}, {"code": "(fn [txt]\n  (->>\n    (.split txt \",\")\n    (map read-string)\n    (filter #(let [a (int (Math/sqrt %))]\n                (= % (* a a))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [s]\r\n    (let [perfect-square? (fn[x] (let [y (Math/sqrt x)] (= (* y y) x)))]\r\n      (clojure.string/join \r\n       \",\"\r\n       (filter #(not (nil? %))\r\n         (map #(if (perfect-square? %) %) \r\n\t\t    (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "4f9c4080e4b0dcca54ed6d1a"}, {"code": "(fn [s] (clojure.string/join \",\" (filter\n        #(let [f (Math/sqrt %) i (float (int f))] (= f i))\n        (map #(Integer/parseInt %)\n             (clojure.string/split s #\",\")))))", "problem": 74, "user": "4faac363e4b081705acca200"}, {"code": "(fn [s]                                                                                                                \n    (let [s (map read-string (clojure.string/split s #\",\"))]                                                           \n      (letfn [(perfect? [x] (let [y (Math/sqrt (float x))] (= (int y) y)))]                                            \n           (apply str (interpose \",\" (filter perfect? s))))))", "problem": 74, "user": "4fa6a491e4b081705acca1bc"}, {"code": "(fn [s] \n  (let [\n        il (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))\n        is-perf-sqr (fn [n] (= n (->> n (Math/sqrt) (Math/round) (repeat) (take 2) (apply *))))\n        filtered-il (filter is-perf-sqr il)\n        st (reduce #(apply str (concat (str %1) \",\" (str %2))) filtered-il)\n         ] st))", "problem": 74, "user": "4fc43a8ee4b081705acca346"}, {"code": "(fn[in]\n   (apply str\n     (map #(.toString %)\n      (for [elem (drop 1 (interleave (repeat \",\")\n                          (filter (fn[d](contains? #{64 1 4 36 9 16 49 25} d))\n                                  (for [i (.split in \",\")]\n                                    (. (new Integer i) (intValue))))))]\n       elem))))", "problem": 74, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn filter-perfect-squares\n  [s]\n  (apply str \n    (butlast\n      (interleave \n        (filter #(let [n (Math/sqrt (Integer/parseInt %))]\n             (when (= 0.0 (- n (int n)))\n               true))\n          (re-seq #\"\\d+\" s))\n         (repeat \",\")))))", "problem": 74, "user": "4fd16778e4b04c3a95aa040f"}, {"code": "(fn [s]\n  (->> s\n    (re-seq #\"[0-9]+\")\n    (map #(Integer/parseInt %))\n    (filter #(let [r (Math/sqrt %)] (= r (int r))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [s]\n  (let [ps (fn [n] (let [sqrt (int (Math/sqrt n))] (= n (* sqrt sqrt))))]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter ps)\n       (interpose \\,)\n       (apply str))))", "problem": 74, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [s]\n  (->> s\n    (re-seq #\"\\d+\")\n    (filter #(let [num (Integer/parseInt %), sqrt (int (Math/sqrt num))] (= num (* sqrt sqrt))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter\n      #(let [sq (Math/sqrt %)] (= sq (int sq)))\n      (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4fa67030e4b081705acca1b7"}, {"code": "(fn [s]\n  (letfn [(args-to-int\n            ([x] x)\n            ([x & ys]\n               (apply args-to-int (+ (* 10 x) (first ys)) (rest ys))))\n          (str-to-int [s]\n            (apply args-to-int (map #(- (int %) (int \\0)) s)))\n          (square? [n]\n            (= (Math/floor (Math/sqrt n)) (Math/sqrt n)))]\n    (apply str\n           (interpose \",\"\n                      (filter square?\n                              (map str-to-int (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn\n  [str]\n  (clojure.string/join \",\"\n    (filter\n      #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n      (map #(Integer/parseInt %) (clojure.string/split str #\",\")))))", "problem": 74, "user": "4fd6f4d8e4b0dab7d829f37b"}, {"code": "(fn [s]\n  (let [sqrs (set (map #(str (* % %)) (range 10)))]\n    (->> s\n      (re-seq #\"\\d+\")\n      (filter #(contains? sqrs %))\n      (clojure.string/join \",\")\n      )))", "problem": 74, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn [s]\n     (clojure.string/join \",\" \n        (filter #(= \n          (Math/sqrt (Integer/parseInt %)) \n          (Math/floor (Math/sqrt (Integer/parseInt %))))\n      (clojure.string/split s #\",\"))))", "problem": 74, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn fps [s]\r\n  (apply str\r\n     (interpose \\, \r\n            (filter (fn [n]\r\n                      (let [sqrt-n (Math/sqrt n)]\r\n                        (== (* sqrt-n sqrt-n) n)))\r\n                    (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))))))", "problem": 74, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn [y]\n(let\n [perf (fn [x]\n (= x (*\n       (int (#(Math/sqrt %) x))\n       (int ( #(Math/sqrt %) x))) ))]\n(clojure.string/join \",\" (filter perf (map #(Integer/parseInt %) (clojure.string/split y #\",\"))))\n))", "problem": 74, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [s]\n(clojure.string/join \",\"\n(filter (fn [x]\n          (let [ y\n                (Math/sqrt (Integer/parseInt x))]\n               (== y (int y))))\n(clojure.string/split s, #\",\"))))", "problem": 74, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn [s]\n  (let [v (read-string (str \"[\" s \"]\"))\n        is-square? (fn [x] (loop [i 1] (cond (> (* i i) x) false (= (* i i) x) true true (recur (inc i)))))]\n       (clojure.string/join \",\" (map str (filter is-square? v)))))", "problem": 74, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn filter-perfect-squares [str]\n  (let [candidates (map read-string (clojure.string/split str #\",\"))\n        perfect-square? (fn [n] (some #(= n (* % %)) (range 1 n)))]\n    (clojure.string/join \",\" (filter perfect-square? candidates))))", "problem": 74, "user": "4e5fdd68535d8ccf87e9fe4f"}, {"code": "(fn perfect-squares [st]\n  (loop [coll (map #(Integer/parseInt %) (clojure.string/split st #\"\\,\")) acc '()]\n    (if (empty? coll)\n      (apply str (interpose \",\" (reverse acc))) \n      (if (zero? (mod (first coll) (Math/sqrt (first coll))))\n        (recur (rest coll) (conj acc (first coll)))\n        (recur (rest coll) acc)))))", "problem": 74, "user": "4ec3b393535dcc7ae8597d59"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(= 0 (mod (Math/sqrt %) 1)) (read-string (str \"[\" x \"]\")))))", "problem": 74, "user": "4fd91099e4b05e33b9224f32"}, {"code": "(fn find-square [string]\n  (letfn [(square? [n]\n            (== n (#(* % %) (Math/sqrt n))))]\n    (clojure.string/join \n      (butlast\n        (interleave \n          (filter square? \n            (map read-string\n              (map str\n                (clojure.string/split string #\",+\"))))\n          (repeat \",\"))))))", "problem": 74, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn fps\n  [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(let [x (read-string %)] (= (Math/pow (Math/pow x 0.5) 2) (double x)))\n    (clojure.string/split s #\",\"))))", "problem": 74, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn [s]\r\n  (->> (re-seq #\"\\d+\" s)\r\n    (map #(Integer/parseInt %))\r\n    (filter (fn [x]\r\n              (let [r (int (Math/sqrt x))]\r\n                (= x (* r r)))))\r\n    (interpose \",\")\r\n    (apply str)))", "problem": 74, "user": "4ff07688e4b0678c553fc324"}, {"code": "(fn [s] \r\n   (clojure.string/join \\, (map str \r\n   (filter #(let [a (java.lang.Math/round (java.lang.Math/sqrt %))] \r\n              (= (* a a) %)) (map read-string (clojure.string/split s #\"\\,\"))))))", "problem": 74, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [numlist]\n  (let [nums \n         (map #(Integer/parseInt %) \n           (.split numlist \",\"))\n       squares (map #(* % %) (range))\n       square-nums\n         (filter \n           #(some \n             (partial = %)\n             (take-while (partial >= %) squares)) \n           nums)]\n       (clojure.string/join \",\" square-nums)))", "problem": 74, "user": "4fe83efbe4b07c9f6fd12c3b"}, {"code": "(fn [s] (let [coll (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\r\n                  ps (into #{} (rest (take-while #(<= % (apply max coll)) (for [x (range)] (* x x)))))]\r\n            (apply str (interpose \",\" (filter ps coll)))))", "problem": 74, "user": "4e79ff2a535db169f9c796a9"}, {"code": "(fn [s] (apply str (drop 1 (interleave (repeat \\,)(filter #(zero? (rem (Math/sqrt %) 1)) (map (fn [s] (reduce #(+ (* 10 %) %2) (map #(- (int %) 48) (seq s))))\n(clojure.string/split s #\",\")))))))", "problem": 74, "user": "4fd11a93e4b04c3a95aa040a"}, {"code": "#_ (fn [s]\n  (clojure.string/join \",\"\n    (filter\n      #(= 0.0 (rem (Math/sqrt %) 1))\n      (map\n        #(Integer/parseInt %)\n        (clojure.string/split s #\",\")))))\n\n(fn [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer/parseInt %))\n    (filter #(= 0. (rem (Math/sqrt %) 1)))\n    (clojure.string/join \",\")))", "problem": 74, "user": "4fe8b6afe4b07c9f6fd12c76"}, {"code": "(fn [s]\n  (->> s\n    (re-seq #\"\\d+\")\n    (map read-string)\n    (filter #(zero? (mod (Math/sqrt %) 1)))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4ff304f4e4b0678c553fc343"}, {"code": "(fn [x] (letfn [(q [n] (Math/pow n 1/2))]\r\n (clojure.string/join \",\" (filter #(== (q %) (int (q %)))\r\n   (map read-string (clojure.string/split x #\",\"))))))", "problem": 74, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn [l]\n  (->> l\n    (re-seq #\"[0-9]+\")\n    (map #(Integer/parseInt %))\n    (filter\n      (fn [n]\n        (let [s (int (Math/sqrt n))]\n         (= (* s s) n))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "4ff5744ae4b0678c553fc36a"}, {"code": "(fn [s] ((fn [x] (apply str (interpose \",\" x))) (filter (fn [v] (= v (#(* % %) (long (Math/sqrt v))))) (map read-string (#(.split % \",\") s)))))", "problem": 74, "user": "4db016af838c48654951d9b9"}, {"code": "(fn [s]\n  (let [double #(* % %)]\n    (reduce str\n            (interpose \",\"\n                       (map #(-> % first str)\n                            (filter #(= (first %) (second %))\n                                    (map #(-> % Integer/parseInt Math/sqrt int double (vector (Integer/parseInt %)))\n                                         (re-seq #\"[0-9]+\" s))))))))", "problem": 74, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn filter-squares\n  [s] {:pre [(string? s)]}\n  (let [;; We need a predicate to see if a number is a perfect square. The\n        ;; simplest approach that dodges any potential floating-point concerns\n        ;; is to take the square root, round that off to the nearest integer,\n        ;; square that, and see if we ended up with what we started with.\n        square? (fn [n]\n                  (let [root (->> n Math/sqrt Math/round)]\n                    (= n (* root root))))]\n\n    (->> (clojure.string/split s #\",\") ; [\"1\" \"7\" \"16\" \"37\"]\n         (map #(Integer/parseInt %))   ; [1 7 16 37]\n         (filter square?)              ; [1 16]\n         (clojure.string/join \\,))))   ; \"1,16\"", "problem": 74, "user": "4fc6305de4b0ee37620e180b"}, {"code": "(fn f [s]\n  (let [q #(Math/sqrt (read-string %))]\n    (subs\n      (reduce #(if (== (q %2) (int (q %2))) (str %1 \",\" %2) %1) \"\" \n          (re-seq #\"\\d+\" s)) 1)))", "problem": 74, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "(fn [s]\r\n   (apply str (interpose \\, (filter\r\n    #(let [n (read-string %)\r\n           r (int (Math/sqrt n))]\r\n          (= n (* r r)))\r\n    (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4fe9de74e4b0547ebccb2475"}, {"code": "(fn\r\n    [s]\r\n    (reduce #(str % \",\" %2)\r\n      (filter\r\n      #(let [i (int (Math/sqrt %))]\r\n         (= (* i i) %))\r\n      (map \r\n        #(Integer. %) \r\n        (re-seq #\"\\d+\" s))))\r\n    )", "problem": 74, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn [s] (#(apply str (concat (mapcat (fn[x] (concat x \",\")) (butlast %)) (last %))) (->> s (re-seq #\"\\d+\") (map read-string) (filter #(== % (-> % Math/sqrt Math/floor (Math/pow 2)))) (map str))))", "problem": 74, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn ([b] (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1)) (map read-string (.split b \",\"))))))", "problem": 74, "user": "4ff889f2e4b0678c553fc399"}, {"code": "(fn [s]\n  (apply str\n    (interpose \\,\n      (filter\n        #(let [r (Math/sqrt %)]\n            (= r (Math/floor r)))\n        (map\n          #(Integer/parseInt %)\n          (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4ffa213ee4b0678c553fc3b7"}, {"code": "(fn [s] \n  (let [nn (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        sqs (map #(* % %) (range (/ (apply max nn) 2)))]\n    (clojure.string/join \",\" (filter (fn [n] (some #{n} sqs)) nn))))", "problem": 74, "user": "4db2cd84535df7e46ed9b6c6"}, {"code": "(fn fps [s]\n  (let [numbers (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        int? #(= % (Math/rint %))\n        perfect (filter #(int? (Math/sqrt %)) numbers)]\n     (clojure.string/join \",\" perfect)))", "problem": 74, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [input]\n(apply str\n  (rest\n    (interleave\n      (repeat \",\")\n      (filter\n        (fn [s] (let [x (Math/sqrt (Integer/valueOf s))]\n                  (= (Math/floor x) x)))\n         (.split input \",\"))))))", "problem": 74, "user": "4f6845d2e4b07046d9f4ef74"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(= % (let [x (Math/round (Math/sqrt %))] (* x x)))\n      (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn [s] \n  (letfn [(i[s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n    (apply str (interpose \\,\n                          (keep #(let [sq (Math/sqrt %)]\n                                      (when (== (* sq sq) %) %))\n                                (i s))))))", "problem": 74, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [s]\n  (clojure.string/join \",\" \n    (filter \n      #(-> % Integer. Math/sqrt (rem 1) zero?)\n      (re-seq #\"\\d+\" s))))", "problem": 74, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map read-string)\n       (filter (fn [x]\n                 (let [q (bigint (Math/sqrt x))]\n                   (= x (* q q)))))\n       (map str)\n       (clojure.string/join \",\")))", "problem": 74, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [s]\n(reduce #(str % \",\" %2) \n  (filter #(zero? (- (Math/sqrt %) (int (Math/sqrt %))))\n    (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [input]\n    (apply str (interpose \",\" (map str\n              \t    \t      \t   (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))\n      \t      \t      \t      \t           (map\t#(Integer/parseInt %) (re-seq #\"\\d+\" input)))))))", "problem": 74, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn [s] \n  (clojure.string/join \",\" \n    (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))) \n      (map #(Integer/parseInt % 10) \n        (clojure.string/split s #\",\")))))", "problem": 74, "user": "5002b6e5e4b0678c553fc42c"}, {"code": "(fn [s] (letfn [(square? [n] (let [r (Math/sqrt n)] (= (float (int r)) r)))]\r\n            (clojure.string/join \",\" (map str (filter #(square? (read-string %)) (clojure.string/split s #\",\" ))\r\n                             ))))", "problem": 74, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn filter-perfect-squares [s]\n  (letfn [(split-on-comma [acc word s]\n            (if (empty? s)\n              (if (empty? word)\n                acc\n                (conj acc word))\n              (if (= (first s) \\,)\n                (recur (conj acc word) (str \"\") (rest s))\n                (recur acc (str word (first s)) (rest s)))))\n          (is-perfect-square? [n]\n            (not (not-any? #(= (* % %) n) (range 2 n))))]\n    (let [perfect-squares (filter is-perfect-square? (map read-string (split-on-comma [] \"\" s)))]\n      (apply str (rest (interleave (repeat \",\") perfect-squares))))))", "problem": 74, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [s]\n  (letfn [(perfect? [x]\n            (let [sqrt (int (Math/sqrt x))]\n              (= x (* sqrt sqrt))))]\n    (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n      (clojure.string/join \",\" (filter perfect? xs)))))", "problem": 74, "user": "500ff421e4b0ae202717946f"}, {"code": "(fn [l]\n  (clojure.string/join \",\"\n    (filter #(let [x (read-string %), y (int (Math/sqrt x))] (= x (* y y)))\n      (clojure.string/split l #\",\") )))", "problem": 74, "user": "5014718fe4b094324338f8e3"}, {"code": "(fn\r\n    [s]\r\n    (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\r\n      (loop [acc [] xs xs i 1]\r\n        (if-not xs\r\n          (apply str (interpose \",\" acc))\r\n          (let [sq (* i i)\r\n                [x & xs] xs]\r\n            (cond\r\n               (> sq x) (recur acc xs i)\r\n               (= sq x) (recur (conj acc x) xs (inc i))\r\n               :else (recur acc (conj xs x) (inc i))))))))", "problem": 74, "user": "4e26e8b4535deb9a81d77ef6"}, {"code": "(fn fps [s]\r\n  (apply str\r\n   (interpose \",\"\r\n  \t    (filter #(zero? (rem (Math/sqrt (Integer/parseInt %)) 1))\r\n\t\t\t    (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [string]\n  (let [sq (map read-string (re-seq #\"[0-9]+\" string))\n        max-sq (reduce max sq)\n        p-squares (map #(* % %) (take (- max-sq 1) (flatten (iterate (fn [[a]] [(+ a 1)]) [1]))))]\n    (reduce str (interpose \",\" (sort (seq (clojure.set/intersection (set sq) (set p-squares))))))))", "problem": 74, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "(fn [s]\n  (apply str (interpose \",\" (filter (fn [a] (let [v (Integer/parseInt a) sv (int (Math/sqrt v))] (= v (* sv sv)))) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "5007f751e4b0b17c647f522b"}, {"code": "(fn[s] (let [i (map #(Integer/parseInt %) (clojure.string/split s #\",\"))] \n(clojure.string/join \",\" (map str (filter (fn[n] (= \"0\" (second (clojure.string/split (str (Math/sqrt n)) #\"\\.\"))))i)))\n))", "problem": 74, "user": "5017eface4b02f523d7cc5e7"}, {"code": "(fn __ [s]\n  (clojure.string/join \",\"\n   (filter #(= (* (Math/sqrt %) (Math/sqrt %)) (float %))\n           (read-string (str \"[\" s \"]\")))))", "problem": 74, "user": "4ec9549d535d6d7199dd36fe"}, {"code": "(fn [s] (clojure.string/join\n     \",\"\n     (filter\n       #(let [x (Math/sqrt (Integer/parseInt %))]\n          (= x (double (int x))))\n       (clojure.string/split s #\",\"))))", "problem": 74, "user": "500e91aae4b00fff93030f99"}, {"code": "#(clojure.string/join\n  \",\"\n  (filter (fn [x] (zero? (mod (Math/sqrt x) 1)))\n          (map read-string (clojure.string/split % #\",\"))))", "problem": 74, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [P s]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n    (apply str (interpose \",\" (filter P nums)))))\n#(let [sqrt (Math/sqrt %) n (/ % 1.0)] (= (* sqrt sqrt) n))", "problem": 74, "user": "50166470e4b052339a490e76"}, {"code": "(fn dale[s]\r\n  (->>\r\n   (re-seq #\"\\d+\" s)\r\n   (map #(Integer/parseInt %) )\r\n   (filter (fn [x] (some #(= % x) (map #(* % %) (range x)))))\r\n   (map str)\r\n   (interpose \",\")\r\n   (apply str)\r\n   ))", "problem": 74, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn [li]\n  (reduce #(str %1 \",\" %2)\n  (filter #(= \n              (. Integer parseInt %)\n              (* \n                (int (. Math sqrt (. Integer parseInt %)))\n                (int (. Math sqrt (. Integer parseInt %)))\n              )\n            )\n          (re-seq #\"[0-9]+\" li)\n  )\n)\n)", "problem": 74, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn [s]\n    (letfn [(magic? [i]\n                    (let [r (int (Math/sqrt i))]\n                         (= i (* r r))))]\n      (->> s\n           (re-seq #\"\\d+\")\n           (map bigint)\n           (filter magic?)\n           (interpose \",\")\n           (apply str))))", "problem": 74, "user": "4fe8a3bde4b07c9f6fd12c61"}, {"code": "(fn [s]\n  (apply str (interpose \",\" (map str (filter (fn [n] (first (filter #(zero? (- (* % %) n)) (range 2 n)))) (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn [s]\n  (let [sl (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (apply str (interpose \",\"\n                          (filter #(== (Math/sqrt %) (int (Math/sqrt %))) sl)))))", "problem": 74, "user": "500cb910e4b05f7c30cfa698"}, {"code": "#({\\9 \"4,9\" \\7 \"16,25,36\"} (last %))", "problem": 74, "user": "50142490e4b07d18bdaaf70a"}, {"code": "(fn [s]\n  (clojure.string/join \",\" \n    (filter #(let [n (Integer/parseInt %) sq (int (Math/sqrt n))] (= (* sq sq) n))\n      (re-seq #\"\\d+\" s))))", "problem": 74, "user": "4fcf642ee4b03432b189f410"}, {"code": "(fn [x] \n  (clojure.string/join \",\" \n    (filter \n      #(seq \n        (for [i (range %) :when (= % (* i i))] i)) \n      (map read-string (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn ps [s] (apply str (interpose \",\" (remove nil?  (map #(when (== (. (. StrictMath (sqrt (. Double valueOf %))) intValue) (. StrictMath (sqrt (. Double valueOf %)))) %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [s]\n  (let [is-pp? (fn [x]\n                 (some #(= (/ x %) %) (range 2 (+ (quot x 2) 1))))\n        perfect-primes (filter is-pp?\n                               (map read-string (clojure.string/split s #\",\")))]\n    \n    (apply str (drop-last (mapcat #(concat (str %) \",\") perfect-primes)))))", "problem": 74, "user": "4ed8b598535d10e5ff6f52fc"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n    (map read-string)\n    (filter #(let [sq (int (Math/sqrt %))] (== % (* sq sq))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [x] \n  (clojure.string/join \",\"\n    (filter \n      #(let [x (Integer/parseInt %) z (Math/sqrt x)] \n            (and (= z (/ x z))) (= (Math/floor z) z))\n      (clojure.string/split x #\",\"))))", "problem": 74, "user": "50233f64e4b0b5d8b1bd2399"}, {"code": "(fn [string]\n  (letfn [(to-ints [string]\n            (map #(Integer/parseInt %)\n      \t  (clojure.string/split string #\",\")))\n          (to-string [ints]\n            (apply str\n              (interpose \\, ints)))\n          (square? [x]\n\t\t    (boolean (#{1, 2, 4, 9, 16, 25, 36} x)))]\n    (to-string\n      (filter square?\n        (to-ints string)))))", "problem": 74, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn __ [s]\n  (letfn [(perfectsquare? [n] (= 0.0 (mod (Math/sqrt n) 1) 0.0))]\n  (clojure.string/join \",\"\n    (filter perfectsquare? \n          (map #(Integer/parseInt (str %)) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [s] \n  (clojure.string/join \",\" \n    (filter #(= (Math/sqrt %) \n               (-> % Math/sqrt Math/round float)) \n      (map #(Integer/parseInt %) \n        (clojure.string/split s #\",\")))))", "problem": 74, "user": "5025b93ce4b0c969f0b056df"}, {"code": "(fn [e]\n  (clojure.string/join \",\"\n    (filter\n      #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n      (map\n        #(Integer/parseInt %)\n        (clojure.string/split e (re-pattern \",\"))))))", "problem": 74, "user": "4ec56b5b535d6d7199dd369f"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(= (Math/sqrt %) (double (int (Math/sqrt %)))) (map #(Integer/valueOf %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "502a5e59e4b09e8f859a9fbc"}, {"code": "(fn [strLst]\n  (let [perfect? (fn [i] (= (int (Math/pow (int (Math/sqrt i)) 2)) i))\n        nums (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" strLst))]\n    (clojure.string/join \",\" (filter perfect? nums))))", "problem": 74, "user": "502a5fa4e4b09e8f859a9fbd"}, {"code": "(fn [i] (clojure.string/join \",\" (filter #(= 0.0 (mod (Math/sqrt (Integer/parseInt %)) 1)) (clojure.string/split i #\",\"))  ))", "problem": 74, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(== (java.lang.Math/sqrt %) (int (java.lang.Math/sqrt %))) (read-string (str \"[\" s \"]\")) )))", "problem": 74, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter #(= (float (int (Math/sqrt %))) (Math/sqrt %)) \n\t\t(map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "501c1492e4b086d93747d180"}, {"code": "#(clojure.string/join \",\"(filter (fn [x] (let [y (java.lang.Math/sqrt (read-string x))]\n                    (= (read-string x) (* (int y) (int y))))) (clojure.string/split % #\",\")))", "problem": 74, "user": "4dae0510c9a9d6ed4b99dc57"}, {"code": "(fn [s]\n  (let [nums (read-string (str \"[\" s \"]\"))]\n    (letfn [(square? [x]\n              (some #(= x (* % %)) (range (inc x))))]\n      (clojure.pprint/cl-format nil \"~{~D~^,~}\" (filter square? nums)))))", "problem": 74, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn [s] (clojure.string/join \",\" (filter\n #(let [sr (int (Math/sqrt %))] (= % (* sr sr)))\n (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "502873a8e4b01614d1633ff8"}, {"code": "(fn [s] (->> s\r\n    (re-seq #\"\\d+\")\r\n    (map #(Integer/parseInt %))\r\n    (filter #(= (float %) (* (Math/sqrt %) (Math/sqrt %))))\r\n    (interleave (repeat \",\"))\r\n    rest (apply str)))", "problem": 74, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [x]\n  (let [nums (clojure.string/split x #\",\")\n        square? (set (for [s (range 10)] (str (* s s))))\n        keep (filter square? nums)\n        ]\n  (clojure.string/join \",\" keep)\n))", "problem": 74, "user": "502bb7c0e4b0194ad32ea1a3"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map #(Integer/parseInt %))\n       (filter(set (map #(* % %) (range 10))))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn [s] (letfn\r\n      [(ss [s] \r\n  (map #(Integer. %) (clojure.string/split s #\",\")))\r\n       (ps [s] \r\n          (filter #(= % (int (* (int (Math/sqrt %)) (Math/sqrt %))))\r\n                  s))\r\n       (ipc [s] (apply str (interpose \",\" s)))]\r\n      (-> s ss ps ipc)))", "problem": 74, "user": "4e8768f6535dceadca469850"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "problem": 74, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [s]\r\n    (apply str (interpose \",\"\r\n                          (filter #(zero? (mod % (Math/sqrt %)))\r\n                                  (map read-string (.split s \",\"))))))", "problem": 74, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [arg] (clojure.string/join \",\" (filter #(== (* (Math/sqrt %) (Math/sqrt %) ) %)\n(map #(Integer/parseInt %) (clojure.string/split arg #\",\")))))", "problem": 74, "user": "50335235e4b0c6c1199c710b"}, {"code": "(fn [in]\n  (let [isPS #(let [x (Math/sqrt (Double/valueOf %))] (== x (Math/round x)))]\n    (clojure.string/join \",\" (filter isPS (clojure.string/split in #\",\")))))", "problem": 74, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn [x] \n  (->> (re-seq #\"\\d+\" x)\n     (map #(Integer. %))\n     (filter #(-> % Math/sqrt rationalize integer?))\n     (interpose \",\")\n     (apply str)))", "problem": 74, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn [st] \r\n   (let [square? (fn square? [x] \r\n  (let [isqr (int (Math/sqrt x))]\r\n    (= x (* isqr isqr))))]\r\n     (apply str (interpose \",\" \r\n                           (map str \r\n                                (filter \r\n                                  square? \r\n                                  (map #(Integer. %) \r\n                                       (clojure.string/split st #\",\"))))))))", "problem": 74, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn [col]\r\n     (clojure.string/join \",\"\r\n      (vec\r\n        (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))\r\n          (map #(Integer/parseInt %) (.split col \",\"))))))", "problem": 74, "user": "502d4ea0e4b02fc10c6c6e46"}, {"code": "(fn [s]\n          (clojure.string/replace\n           (clojure.string/replace \n            (pr-str\n             (keep \n              (fn [i]\n                (if\n                    (some\n                     #(= i (* % % ))\n                     (range 0 i))\n                  i\n                  nil))\n              (map read-string (clojure.string/split s #\",\"))))\n            #\" \"  \",\" )\n           #\"[()]\" \"\"))", "problem": 74, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn [input]\n   (apply str\n          (butlast\n           (interleave\n            (filter\n             (fn [val]\n               (let [sqrt (int (Math/sqrt val))]\n                 (= val\n                    (* sqrt sqrt))))\n             (map #(Integer/parseInt %)\n                  (re-seq #\"[0-9]+\" input)))\n            (repeat \",\")))))", "problem": 74, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [sq]\n  (clojure.string/join \",\"\n    (filter #(= 0.0 (rem (Math/sqrt %) 1.0))\n      (map #(Integer/valueOf (str %)) (.split sq \",\")))))", "problem": 74, "user": "5012ec0ae4b0c87326002230"}, {"code": "#(let \r\n  [numbers (map read-string (clojure.string/split % #\",\"))\r\n  perfect-sq? (fn [x] (let [root (int (Math/sqrt x))] (= (* root root) x)))\r\n  to-csv (partial clojure.string/join \\,)]\r\n    (to-csv (filter perfect-sq? numbers)))", "problem": 74, "user": "4ded27db535d08e6dec9fe0a"}, {"code": "(fn [str] \n  (->>\n    (re-seq #\"\\d+\" str)\n(map read-string)\n(filter #(let [rt (Math/sqrt %)] (== rt (Math/round rt))))\n(clojure.string/join \",\")))", "problem": 74, "user": "4fd81472e4b0dab7d829f38e"}, {"code": "(fn [s]                                                                                                                                                                                 \n   (apply str (interpose \",\"                                                                                                                                                             \n                         (filter                                                                                                                                                         \n                          #(let [lol (Math/sqrt %)] (== lol (Math/round lol)))                                                                                                           \n                          (map #(Integer. %) (.split s \",\"))))))", "problem": 74, "user": "50435852e4b034ff00315d22"}, {"code": "(fn [xs] (->>\n  (clojure.string/split xs #\",\")\n  (map read-string)\n  (filter #(let [r (Math/sqrt %)] (== % (* r r))))\n  (interpose \\,)\n  (apply str)))", "problem": 74, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn [s]\n  (let [f (fn [n] (let [s (int (Math/sqrt n))] (= n (* s s))))]\n(->> (.split s \",\")\n (map #(Integer/parseInt %))\n     (filter f)\n     (interpose \",\")\n     (apply str)\n  )))", "problem": 74, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn f [x]\n  (let [l (map #(Integer/parseInt %) (clojure.string/split x #\",\"))\n        s (set (map #(* % %) (range 1 (apply max l))))]\n    (clojure.string/join \",\"\n      (filter #(contains? s %) l))))", "problem": 74, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn [s]\r\n   (let [candidates (map read-string (clojure.string/split s #\",\"))\r\n         maxval (apply max candidates)\r\n         psquares (apply hash-set (map #(* % %) (range (inc maxval))))\r\n         ]\r\n     (clojure.string/join \",\" (reduce #(if (contains? psquares %2) (conj %1 %2) %1) [] candidates))))", "problem": 74, "user": "5046b003e4b011c5dfee7727"}, {"code": "(fn [s]\n  (let [sqr (fn [x] (* x x))\n          is-perfect-square (fn [x] (= x (sqr (int (Math/sqrt x)))))\n          to-longs (fn [xs] (map #(Long/valueOf %) xs))]\n      (clojure.string/join \",\"\n       (filter is-perfect-square (to-longs (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4f2e0369e4b0d6649770a064"}, {"code": "; i cheat dont judge me\n(fn [s]\n  (let [sa  (clojure.string/split s #\",\")\n        na  (map #(. Integer parseInt %) sa)\n        sqa (keep #{4 9 16 25 36} na)]\n  (clojure.string/join \",\" sqa)))", "problem": 74, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn [s]\n  (let [ns (map #(Long/parseLong %) (re-seq #\"\\d+\" s))\n        square? #(let [sqrt (int (Math/sqrt %))] (= % (* sqrt sqrt)))]\n    (apply str (interpose \\, (filter square? ns)))))", "problem": 74, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn [s] (apply str (interpose \\, \r\n  (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))\r\n(map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [s]\n  (->> s\n\t  (re-seq #\"\\d+\")\n\t  (map #(Integer/parseInt %))\n\t  (filter\n\t  #(let [root (Math/pow % 0.5)\n\t\t\tfloor-root (Math/floor root)]\n\t\t(= root floor-root)))\n\t(interpose \",\")\n\t(apply str)))", "problem": 74, "user": "4f1abbfb535d64f60314646e"}, {"code": "(fn [s]\n  (let [v (read-string (str \"[\" s \"]\"))]\n    (apply str\n    (butlast\n    (interleave\n      (filter\n        #(== (Math/sqrt %) (int (Math/sqrt %)))\n        v)\n      (repeat \",\"))))))", "problem": 74, "user": "50427899e4b0add3005c0fc2"}, {"code": "(fn [s]\n   (clojure.string/join \",\" (filter (fn [n]\n             (let [n (read-string n) root (Math/round (Math/sqrt n))]\n               (= (* root root) n)\n               )) (clojure.string/split s #\",\")))\n   )", "problem": 74, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "(fn [s]  (->> s\r\n                      (re-seq #\"\\d+\")\r\n                      (map #(Integer/parseInt %))\r\n                      (filter (fn [x] (let [r (int (Math/sqrt x))] (= x (* r r))) ) )\r\n                      (clojure.string/join \",\")\r\n                      ))", "problem": 74, "user": "503d129fe4b06c4e0e1fa254"}, {"code": "(fn [s]\n  (let [is-square? (fn [n] (contains? #{4 9 16 25 36} n))]\n    (->> (.split s \",\")\n       (map #(Integer/parseInt %))\n       (filter is-square?)\n       (clojure.string/join \",\"))))", "problem": 74, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn [s]\n  (letfn [(square          [x] (* x x))\n          (perfect-square? [x] (= x (square (int (Math/sqrt x)))))]\n    (let [xs (map read-string (clojure.string/split s #\",\"))]\n      (clojure.string/join \",\" (map str (filter perfect-square? xs))))))", "problem": 74, "user": "50586354e4b06522596eba78"}, {"code": "(fn [string] \n  (->> (clojure.string/split string #\"\\W\")\n               (map read-string)\n               (filter #(let [x (Math/sqrt %)]\n                          (= x (double (int x)))))\n               (interpose \",\")\n               (apply str)))", "problem": 74, "user": "50435689e4b034ff00315d21"}, {"code": "(fn [s]\n  (->> s\n    (re-seq #\",?(\\d+),?\")\n(map (comp read-string second))\n(filter #(zero? (mod (Math/sqrt %) 1)))\n(interleave (repeat \",\"))\n(rest)\n(apply str)))", "problem": 74, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn [s]\n  (let [sq #(* % %)]\n    (->> (re-seq #\"\\d+\" s)\n         (map #(Integer/parseInt %))\n         (filter #(= % (sq (Math/round (Math/sqrt %)))))\n         (interpose \",\")\n         (apply str))))", "problem": 74, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [s]\n  (->> s\n       (re-seq #\"[^,]+\")\n       (map #(Integer/parseInt %))\n       (filter #(= (rem (Math/sqrt %) 1) 0.0))\n       (map #(.toString %))\n       (interleave (repeat \",\"))\n       (rest)\n       (apply str)))", "problem": 74, "user": "4f84a4a4e4b033992c121c39"}, {"code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (= n (last (take-while #(<= % n) (for [x (range)] (* x x)))))) (map read-string (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [s] \n    (let [is-square? #(= (Integer/parseInt %) (.intValue (Math/pow (.intValue (Math/sqrt (Float/parseFloat %))) 2)))\n        join #(apply str (interpose %1 %2))]\n    (join \",\" (filter is-square? (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn [s]\n  (apply str \n    (interpose \",\"\n        (filter\n          (fn [x] (= (mod (Math/sqrt x) 1) 0.0))\n            (map (fn [x] (Integer/parseInt x)) \n                 (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4f4f08c8e4b03ad3f0c10cd8"}, {"code": "(fn [s] \n  (clojure.string/join \",\" (filter\n    #(= (- (Math/sqrt (Integer/parseInt %)) (int (Math/sqrt (Integer/parseInt %)))) 0.0)\n    (clojure.string/split s #\",\")))\n)", "problem": 74, "user": "504e685fe4b0f6ff3350c4ae"}, {"code": "(fn [y]\n    (clojure.string/join \",\" (filter #(= (- (Math/pow (Math/sqrt %) 2) %) 0.0) (map #(Integer/parseInt %) (clojure.string/split y #\",\"))))\n    )", "problem": 74, "user": "504e1abee4b0f6ff3350c45d"}, {"code": "(fn filter-perfect-squares [string]\n  (let [perfect-square? (fn [n] (zero? (rem n (java.lang.Math/sqrt n))))\n        numbers (map #(Integer/parseInt %) (clojure.string/split string #\"\\,\"))]\n    (clojure.string/join \",\" (filter perfect-square? numbers))))", "problem": 74, "user": "4ec70f26535d6d7199dd36dd"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n]\n            (let [k (int (Math/sqrt n))]\n              (= (* k k) n)))\n          (numbers [s]\n            (map #(Integer/parseInt %)\n                 (clojure.string/split s #\",\")))]\n    (->> s numbers (filter perfect-square?) (clojure.string/join \",\"))))", "problem": 74, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn fps [coll]\n  (apply str\n         (drop-last\n          ((fn commas [coll] (let [c (count coll)] (interleave coll (repeat c \\,))))\n           (map str\n                (filter #(= (java.lang.Math/floor (java.lang.Math/sqrt %)) (java.lang.Math/sqrt %))\n                        (map #(java.lang.Integer/parseInt %) (remove #(= \",\" %) (for [l (partition-by #(= \\, %) coll)] (apply str l))))))))))", "problem": 74, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [x] (apply str (interpose \",\" (filter (fn [n] (some #(= n (* % %)) (range n))) (map #(Integer/parseInt %) (re-seq #\"\\d+\" x))))))", "problem": 74, "user": "4f045946535dcb61093f6bba"}, {"code": "(fn [s]\n\t(let [nums (->> (.split s \",\") (map #(Integer/parseInt %)))\n\t      perfect-square? #(let [sqt (int (Math/sqrt %))] (= % (* sqt sqt)))]\n\t  (->> nums (filter perfect-square?) (clojure.string/join \",\"))))", "problem": 74, "user": "50645e12e4b007509339a58a"}, {"code": "(fn [s] (clojure.string/join\n          \",\"\n          (map str (filter\n                    (fn [a] (= ((fn [b] (* b b)) (int (Math/sqrt a))) a))\n                    (map read-string (clojure.string/split s #\"\\,\"))))))", "problem": 74, "user": "5047a03ee4b0ec70b3ef8d8d"}, {"code": "(fn fperfsq [s]\n(letfn [(str2seq [x]\n(map #(Integer/parseInt %) (clojure.string/split x #\"\\,\")))\n  (seq2str [y]\n(apply str (butlast (interleave y (repeat \\,)))))]\n  (seq2str (filter (into #{} (take-while #(>= (apply max (str2seq s)) %) (map #(* % %) (range)))) (str2seq s)))\n)\n)", "problem": 74, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [ns]\n  (clojure.string/join \",\" \n    (filter (fn [sn]\n      (let [n (java.lang.Integer/parseInt sn)\n            r (int (java.lang.Math/sqrt n))]\n        (= n (* r r))))\n      (re-seq #\"\\d+\" ns))))", "problem": 74, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [s] \n    (reduce #(str %1 \",\" %2)\n      (filter \n        #(= (mod (java.lang.Math/sqrt (java.lang.Double/parseDouble %1)) 1) 0.0)\n        (clojure.string/split s #\"[,]+\"))))", "problem": 74, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [s]\r\n  (letfn [(perfect-square? [n]\r\n            (let [r (int (Math/sqrt n))]\r\n              (= n (* r r))))]\r\n    (clojure.string/join \",\"\r\n      (filter perfect-square?\r\n              (map #(Integer/parseInt %)\r\n                   (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4fd2e5d8e4b04c3a95aa0427"}, {"code": "(fn [xs]\n  (apply str\n    (interpose \",\"\n      (filter\n        #(let [n (Integer. %)\n               sqrt (int (Math/sqrt n))]\n            (= n (* sqrt sqrt)))\n        (re-seq #\"\\d+\" xs)))))", "problem": 74, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [st]\r\n  (letfn [( perfect-seq? [x]\r\n            (not= nil (some #(= x (* % %)) (range 1 (+ ( quot x 2) 1)))))]\r\n    (apply str  (interpose \",\" (filter #( perfect-seq? (Integer/parseInt %)) (clojure.string/split st #\",\")) ))))", "problem": 74, "user": "4fb23582e4b081705acca28a"}, {"code": "(fn [s]\n  (letfn [(i[s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n    (apply str (interpose \\,\n                          (keep #(let [sq (Math/sqrt %)]\n                                   (when (== (* sq sq) %) %))\n                                (i s))))))", "problem": 74, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "#(apply str (interpose \",\" (for [str (re-seq #\"\\d+\" %)\n                                  :let [d (Long/parseLong str)\n                                        s (long (Math/sqrt d))] \n                                  :when (= (* s s) d)] d)))", "problem": 74, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [x] (let [parse (fn [x] (map #(Integer/valueOf %)(seq (.split x \",\"))))\r\n                    tocsv (fn [x] (let [n (apply str (map #(str % \",\") x))] (.substring n 0 (dec (.length n)))  ))\r\n                    perfectsquares (fn [x] (filter (fn[n] (zero? (- n (Math/pow (Math/floor (Math/sqrt n)) 2)))) x))\r\n                   ]\r\n                  (tocsv (perfectsquares (parse x)))\r\n\r\n                  ))", "problem": 74, "user": "50463347e4b011c5dfee771e"}, {"code": "(fn [s]\n  (apply str \n   (interpose \\, \n     (filter #(= (Math/sqrt %) \n                 (Math/floor (Math/sqrt %))) \n             (map #(Integer/parseInt %) \n                  (re-seq #\"\\w+\" s))))))", "problem": 74, "user": "506b016de4b0a2a5463de37f"}, {"code": "#(clojure.string/join \",\"\n  (filter\n    (fn [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))\n    (map read-string (re-seq #\"\\d+\" %))))", "problem": 74, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn squares [ns]\n  (letfn [(square? [n] (= n (-> n Math/sqrt long (#(* % %)))))]\n    (->> (clojure.string/split ns #\",\")\n         (filter (comp square? read-string))\n         (interpose \",\")\n         (apply str))))", "problem": 74, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn [s]\r\n  (let [sqp (fn [n] \r\n        (= n (first (drop-while #(< % n) (map #(* % %) (iterate inc 1))))))]\r\n    (reduce str (interpose \\, (filter sqp (map read-string (clojure.string/split s #\",\")))))))", "problem": 74, "user": "507437c2e4b054001656acd0"}, {"code": "(fn [s]\n  (let [xs (clojure.string/split s #\",\")]\n    (clojure.string/join\n      \",\"\n      (filter\n        #(let [q (int (Math/sqrt %))] (= % (* q q)))\n        (map #(Long/parseLong %) xs)))))", "problem": 74, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn [s]\n  (apply str \n    (interpose \",\" \n            (filter (fn [i]\n                      (some #(= i %) (take-while #(<= % i) (map #(* % %) (range)))))\n                    (map #(java.lang.Integer/valueOf %) (re-seq #\"[0-9]+\" s)))                      \n)))", "problem": 74, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn [s] \n  (let [all (map #(* % %) (range))\n        sa (map #(read-string %) (clojure.string/split s #\",\"))\n        f (fn f ([x] (f x all)) ([x a] (cond (= (first a) x) true\n                                             (< (first a) x) (recur x (rest a))\n                                             :else false)))]\n      (clojure.string/join \",\" (filter f sa))))", "problem": 74, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn filter-squares [s]\n  (let [nums (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        fmt #(apply str (interpose \",\" (map (comp str int) %)))]\n    (fmt (filter #(zero? (rem (Math/sqrt %) 1)) nums))))", "problem": 74, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn [s] (->> s\n  (re-seq #\"\\d+\")\n  (map read-string)\n  (filter #(let [r (java.lang.Math/sqrt %)]\n            (= 0.0 (- r (int r)))))\n  (clojure.string/join \",\"))\n)", "problem": 74, "user": "507a396be4b08327cd804a69"}, {"code": "(fn [s]\n  (letfn [(nums [s] (map read-string (clojure.string/split s #\",\")))]\n    (apply str\n      (interpose\n        \",\"\n        (filter\n          (set (map #(* % %) (range (inc (Math/sqrt (apply max (nums s)))))))\n          (nums s)\n        )\n      )\n    )\n  )\n)", "problem": 74, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "#(->> (clojure.string/split % #\",\")\n  (map (fn [s] (Integer. s)))\n  (filter (set (map * (range 10) (range 10))))\n  (clojure.string/join \",\"))", "problem": 74, "user": "503a234de4b088a6a14ca76d"}, {"code": "(fn [csv]\r\n  (let [ps #{1 4 9 16 25 36}]\r\n    (-> csv \r\n        (clojure.string/split #\",\")\r\n        (#(map read-string %))\r\n        (#(filter (fn [x] (ps x)) %))\r\n        (#(clojure.string/join \",\" %)))))", "problem": 74, "user": "4fabbb97e4b081705acca21d"}, {"code": "(fn [a]\n  (clojure.string/join \",\"\n    (filter #(= 0. (mod (Math/sqrt %) 1))\n      (map read-string\n        (re-seq #\"\\d+\" a)))))", "problem": 74, "user": "5088082ae4b0198722bd9854"}, {"code": "(fn [n] (clojure.string/join \",\" (map str (filter (fn [e] \n          (< (- (Math/sqrt e) (int (Math/sqrt e))) 0.001)) \n        (map #(Integer/parseInt %) \n     (clojure.string/split n #\",\"))))))", "problem": 74, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn [s] \n  (clojure.string/join \",\" (filter  (fn [i]\n            (let [n (Integer/parseInt i)\n                  root (Math/sqrt n)\n                  floor (Math/floor root)\n                  epsilon 0.000000001]\n              (< (Math/abs (- root floor)) epsilon)))\n          (re-seq #\"\\d+\" s))))", "problem": 74, "user": "4e6a4954535d8ccf87e9fec0"}, {"code": "#(apply str \n   (interpose \",\" \n     (filter \n       (fn[s] \n         (let [n (read-string s) sq (int (Math/sqrt n))] \n(= sq (/ n sq))))                                                                                \n              (clojure.string/split % #\",\")                                                                                                                                    \n              ) ))", "problem": 74, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [s]\n  (->> s \n    (re-seq #\"\\d+\") \n    (map #(Integer/parseInt %))\n    (filter #(let [q (int (Math/sqrt %))] (== % (* q q) )))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn filter-perfect-squares [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(let [tmp (Math/sqrt (Integer/parseInt %))]\n       (= tmp (Math/floor tmp) (Math/ceil tmp)))\n    (clojure.string/split s #\",\"))))", "problem": 74, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "#_(fn  [s]\n  (let [ps? (fn [n] (let [y (int (Math/sqrt n)) ] (= (* y y) n)))]\n    (clojure.string/join \",\"\n      (filter #(ps? (Integer/parseInt %))\n        (clojure.string/split s #\",\")))))\n\n\n(fn [s]\n  (let [ps? (fn [n] (let [y (int (Math/sqrt n)) ] (= (* y y) n)))]\n    (->>\n      (clojure.string/split s #\",\")\n      (filter #(ps? (Integer/parseInt %)))\n      (clojure.string/join \",\"))))", "problem": 74, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn [numstr]\n  (let [square?\n        , (fn [k] (= k (#(* % %) (int (Math/floor (Math/sqrt k))))))]\n    (apply str\n           (interpose \",\"\n                      (filter #(square? (Integer/parseInt %))\n                              (re-seq #\"\\d+\" numstr))))))", "problem": 74, "user": "5095f761e4b0ba05ca7aebfd"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(let [i (int (Math/sqrt %))] (= % (* i i)))\n      (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "505d4b21e4b0e6aca564be07"}, {"code": "(fn filter-perfect-squares [s]\n  (letfn [(in? [seq elm] (some #(= elm %) seq))\n          (perfect-square? [n] (in? (map #(* % %) (range n)) n) )]\n    (->>\n      s\n      (re-seq #\"\\d+\")\n      (map read-string)\n      (filter perfect-square?)\n      (map str)\n      (interpose \",\")\n      (apply str))))", "problem": 74, "user": "4fa17b00e4b0dcca54ed6d5f"}, {"code": "(fn [s]\n  (let [sqr #(* % %)]\n    (->> (clojure.string/split s #\",\")\n      (map read-string)\n      (filter #(= % (sqr (int (Math/sqrt %)))))\n      (clojure.string/join \",\"))))", "problem": 74, "user": "50657775e4b0deb876850599"}, {"code": "(fn [s]  \n  (let [sq #(Math/sqrt (Long/parseLong % 10))]\n    (clojure.string/join \",\" (filter #(< (- (sq %) (int (sq %))) 0.01) (clojure.string/split s #\",\")))))", "problem": 74, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "(fn [str] (let [ns (map #(Integer/parseInt %) (clojure.string/split str #\",\")) sqs (filter (fn [n] (some #(= (* % %) n) (range  n))) ns)] (clojure.string/join \",\" sqs)))", "problem": 74, "user": "506fd0afe4b07bd6ad9b9f23"}, {"code": "(fn [s] \n  (clojure.string/join \",\" \n    (filter #(let [n (Integer/parseInt %) sqr (int (Math/sqrt n))] \n                (= n (* sqr sqr))) \n      (re-seq #\"\\d+\" s))))", "problem": 74, "user": "5097a95fe4b00ad8bab4e96e"}, {"code": "(fn filter_perfect_squares[s]\n  (let [numb (clojure.string/split s #\",\")\n        numbers (map read-string numb)\n        res (filter #(= % (* (long (Math/sqrt %)) (long (Math/sqrt %)))) numbers)]\n        (reduce #(str %1 (str \",\" %2)) (str (first res)) (rest res))))", "problem": 74, "user": "5065bd94e4b0148eb3925aed"}, {"code": "(fn [s] (->> (re-seq #\"\\d+\" s) (map read-string)\n                      (filter #(let [r (int (Math/sqrt %))]\n                                 (= % (* r r))))\n                      (interpose \",\") (apply str)))", "problem": 74, "user": "4e5f034b535d8a8b8723a2d9"}, {"code": "(fn __ [s]\n  (let [nums (clojure.string/split s #\",\")]\n      \t(clojure.string/join \",\" (filter (fn [sn] \n             (let [n (read-string sn)\n\t\t\t\t   nr (Math/sqrt n)\n                   ]\n        \t\t(= (double (* nr nr)) (float n))\n             )\n        \t) nums\n    \t))\n    )\n)", "problem": 74, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn [xs]\n (apply str (interpose \",\"\n                       (reduce (fn [a b]\n                                 (let [x (Math/sqrt (read-string b))]\n                                   (if (= (float (int x)) x)\n                                     (conj a b)\n                                     a)))\n                               []\n                               (clojure.string/split xs #\",\")))))", "problem": 74, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [x] (apply str (interpose \",\" \r\n                   (filter #(if (= (* (int (Math/sqrt %)) \r\n                       (int (Math/sqrt %))) %) true false)\r\n                          (map #(Integer/parseInt %)\r\n                                (re-seq #\"\\w+\" x))))))", "problem": 74, "user": "506717e2e4b03d366d7cb2ba"}, {"code": "(fn solution [aStrNums]\r\n (reduce (fn [s1 s2]\r\n           (str s1 \",\" s2)) (map #(apply str %) (remove (fn [aNumVec]\r\n            (let [sqrt (Math/sqrt (Integer/parseInt (apply str aNumVec)))]\r\n              (not= (- sqrt (int sqrt)) 0.0)))\r\n   (remove (fn [aVec] \r\n            (= aVec '(\\,)))\r\n          (partition-by #(= % \\,) aStrNums))))))", "problem": 74, "user": "505dd5c4e4b0e6aca564be0e"}, {"code": "(fn [x]\n  (clojure.string/join \",\"\n    (filter #(let [y (Math/sqrt %)] (= (double (int y)) y))\n      (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn [s]\n  (->> \n   (clojure.string/split s #\",\")\n   (map read-string)\n   (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n   (clojure.string/join \",\")\n  ))", "problem": 74, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [s]\n (clojure.string/join \",\"\n  (filter\n     #(let [sqrt (-> % Math/sqrt int)]\n         (= % (* sqrt sqrt))\n       )\n     (map\n       #(Integer. %)\n      (clojure.string/split s #\",\")))))", "problem": 74, "user": "5089ebfee4b03217b26a539f"}, {"code": "(fn [s]\r\n (#(clojure.string/join \",\" %)\r\n  (map str\r\n   (filter (fn [n] (let [root (int (. Math sqrt n))] (= (* root root) n)))\r\n    (map #(. Integer parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4de760a3535d08e6dec9fdf9"}, {"code": "(fn [ints]\n  (apply str (rest ((fn filt [n t o]\n    (let [check (fn [s]\n                  (= (mod (Math/sqrt (reduce #(+ (* 10 %1) ({\\0 0, \\1 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9} %2)) 0 s)) 1) 0.0))]\n      (if (empty? o)\n        (if (check t) (concat n [\\,] t) n)\n        (let [[f & e] o]\n          (if (= f \\,) (filt (if (check t) (concat n [\\,] t) n) '() e)\n            (filt n (concat t [f]) e)))))) '() '() ints))))", "problem": 74, "user": "505dcfc8e4b0e6aca564be0d"}, {"code": "(fn [s]\n  (let [coll (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        sq? (fn [n] (#{1 4 9 16 25 36} n))]\n    (apply str (interpose \",\" (filter sq? coll)))))", "problem": 74, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn [r]\n  (clojure.string/join \",\" \n      (map str (filter (set (map #(* % %) (range 100))) (map read-string (.split r \",\"))))))", "problem": 74, "user": "502940a9e4b061fd216be4b8"}, {"code": "(fn [s]\n  (let [ns (clojure.string/split s #\",\")]\n    (clojure.string/join \",\" \n      (filter (fn [b] (let [x (Math/sqrt b)]\n                  (== x (int x)))\n      ) \n        (map (fn [i] (Integer/parseInt i)) ns))\n    )\n  )\n)", "problem": 74, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn [numstring]\n    (let [numbers (map #(Integer. %) (clojure.string/split numstring #\",\"))\n          square? (fn [n]\n                    (let [root (Math/sqrt n)]\n                      (= root (Math/floor root))))\n          squares (filter square? numbers)\n          ]\n      (println squares numbers)\n      (clojure.string/join \",\" (map str squares))\n      ))", "problem": 74, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [s]\n  (letfn [(sqr? [x]\n            (some #(= x (* % %)) (range 2 x)))]\n    (let [squares (filter sqr? (map #(Integer/valueOf %)\n                                    (map str (.split s \",\"))))]\n      (apply str (interpose \",\" (map str squares))))))", "problem": 74, "user": "4ed0e139535d44c135fd68c7"}, {"code": "(fn [num-string]\n  (reduce\n   (fn [s num]\n     (if (empty? s) (str num) (str s \",\" num)))\n   (map str\n        (filter\n         (fn [num]\n           (let [root (int (Math/sqrt num))]\n             (= num (* root root))))\n         (map #(Integer. %)\n              (re-seq #\"\\d+\" num-string))))))", "problem": 74, "user": "4f03818e535dcb61093f6b00"}, {"code": "(fn [str] (->> (clojure.string/split str #\",\")\n               (map #(Integer/parseInt %))\n               (filter #(= (double (int (Math/sqrt %))) \n                           (Math/sqrt %)))\n               (clojure.string/join \",\")))", "problem": 74, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn [s]\n  (reduce\n    #(str % (if (> (count %) 0) \",\") %2)\n    \"\"\n    (filter\n      (fn [a]\n        (let [v (Integer/parseInt a)\n              r (int (Math/sqrt v))]\n             (= (* r r) v)))\n      (re-seq #\"[0-9]++\" s))))", "problem": 74, "user": "508ee17ae4b0706b2ed3ef8d"}, {"code": "(let [square #(* % %)]\n  (comp\n    #(apply str (butlast\n      (interleave (map str %) (repeat \\,))))\n    (partial filter #(= % (square (int (Math/sqrt %)))))\n    (partial map #(Integer/parseInt (apply str %)))\n    (partial filter #(not (= % '(\\,))))\n    (partial partition-by #(= % \\,))))", "problem": 74, "user": "4fb1325de4b081705acca276"}, {"code": "(fn  [y]  (let [r (clojure.string/replace (reduce #(str % \" \" %2 ) (map (fn [x] (let [a (Math/sqrt (/ (reduce #(* 10 (+ % %2)) 0 (map #(-> % (int) (- 48)) (vec x))) 10))] (if (= ( - a (int a)) 0.0) x \"\")))   (re-seq #\"\\w+\" y))) #\" +\" \",\")\r\n                      s (if (= (first r) \\, ) (rest (vec r)) r)]\r\n(reduce #(str % \"\" %2 ) (if (= (last s) \\, ) (reverse (rest (reverse (vec s)))) s)) ))", "problem": 74, "user": "50646c01e4b007509339a58b"}, {"code": "(fn [s]\n  (letfn [(square? [n] (some #(= (* % %) n) (range n)))]\n    (->> s (re-seq #\"\\d+\") (map #(Integer. %)) (filter square?) (clojure.string/join \",\"))))", "problem": 74, "user": "4e7f32ee535db966e863cc3a"}, {"code": "(fn [s] (->>\n     (map #(. Integer parseInt %) (.split s \",\"))\n\t   (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n\t   (clojure.string/join \",\")))", "problem": 74, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "50ae22c3e4b0a40c9cfb08d0"}, {"code": "(fn [s] (apply str (interpose \",\" (filter (fn [x] (some #(= x %) (take 10 (map * (range) (range))))) (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "50ad7888e4b0a40c9cfb08c7"}, {"code": "(fn [numstr]\n  (let [nums (map #(Integer/parseInt %) (.split numstr \",\"))\n        sorted-nums (sort nums)\n        sqrs (into #{} (map #(* % %) (range 1 (inc (java.lang.Math/sqrt (last sorted-nums))))))\n        join (fn [v] (reduce #(str %1 \",\" %2) \"\" v))]\n    (subs (join (filter #(contains? sqrs %) nums)) 1)))", "problem": 74, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn [s]\r\n  (clojure.string/join \",\" \r\n    (filter #(let [r (Math/sqrt %)] (= r (float (int r))))\r\n      (map read-string\r\n        (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [s]\n    (let [perfect-squares (map #(* % %) (iterate inc 1))\n          ints (map read-string (re-seq #\"\\d+\" s))\n          test (into #{} (take (apply max ints) perfect-squares))]\n      (clojure.string/join \",\"\n                           (filter test ints))))", "problem": 74, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn [s]\r\n  (reduce #(str % \",\" %2)\r\n    ((group-by \r\n      #(= (Math/sqrt (read-string %)) (Math/floor (Math/sqrt (read-string %))))\r\n      (clojure.string/split s #\",\")) true)))", "problem": 74, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n] (some #(= (* % %) n) (range n)))]\n    (clojure.string/join \",\"\n      (filter perfect-square? (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn filter-sq [st]\n  (let [square? #(= (rem (Math/sqrt %) 1) 0.0)]\n    (->> (.split st \",\")\n         (map #(Integer/parseInt %) ,,)\n         (filter square? ,,)\n         (clojure.string/join \",\" ,,))))", "problem": 74, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn [s]\n  (let [perfect-square? (fn [x]\n                          (let [sqrt (Math/sqrt x)]\n                            (== sqrt (int sqrt))))\n        nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter perfect-square? nums))))", "problem": 74, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn [s]\n  (apply str (interpose \\, \n               (filter #(let [s (long (Math/sqrt %))]\n                          (= (* s s) %))\n                 (read-string (str \"(\" s \")\"))))))", "problem": 74, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n  (filter #(= (rem (Math/sqrt %) 1) 0.0) (read-string (str \"[\" s \"]\")))))", "problem": 74, "user": "50aab057e4b056ee0193586b"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter \n  #(let [x (Math/sqrt %)] (= 0.0 (- x (int x))))\n    (map read-string (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [int-str]\n  (let [split-string (clojure.string/split int-str #\",\")\n        int-list (map #(Integer. %1) split-string)]\n    (clojure.string/join \",\" \n      (filter #(= 0.0 (mod (Math/sqrt %1) 1)) int-list))))", "problem": 74, "user": "4ec12516535dfed6da9c6da7"}, {"code": "(fn [string]\n  (->> string\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter (fn [i]\n                 (= i (#(* % %) (int (Math/sqrt i))))))\n       (clojure.string/join \",\")))", "problem": 74, "user": "50052d38e4b0678c553fc45c"}, {"code": "(fn [s] (clojure.string/join \",\"\n  (filter #(zero? (rem (Math/sqrt (read-string %)) 1))\n    (re-seq #\"\\d+\" s))))", "problem": 74, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn [s]\n           (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n             (clojure.string/join \",\"\n                                  (filter (fn [n] (let [r (-> n (Math/sqrt) (int))] (= n (* r r)))) nums))))", "problem": 74, "user": "4fccb31be4b0ee37620e1868"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(== % (Math/pow (Math/sqrt %) 2)) (map #(Integer. %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn [coll]\n(let [f (fn [x] (map #(read-string %1) (re-seq #\"\\d+\" x)))\n      ff (fn [x] (let [k (int (Math/sqrt x))] (* k k)))]\n  (apply str (interpose \\, (filter #(= (ff %1) %1) (f coll))))))", "problem": 74, "user": "50a5f72fe4b0aa96157e2611"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n\t\t  sq #(* % %)\n\t\t  ps? #(= % (sq (int (Math/sqrt %))))]\n\t\t(clojure.string/join \",\" (filter ps? nums))))", "problem": 74, "user": "508e13abe4b0f17d83ea26c7"}, {"code": "(fn [s]\n  (reduce #(str % \\, %2)\n    (filter (fn [n]\n\t\t    (some #(= (* % %) n) (range n)))\n\t\t  (read-string (str \\[ s \\])))))", "problem": 74, "user": "50052fd0e4b0678c553fc45d"}, {"code": "#(->> \n     (clojure.string/split % #\",\")\n     (map (fn [x] (Integer/parseInt x)))\n     (filter \n       (fn [x]\n         (zero? (mod (Math/sqrt x) 1))))\n     (clojure.string/join \",\"))", "problem": 74, "user": "4e976f79535dbda64a6f6b55"}, {"code": "(fn[x]\n  (clojure.string/join \",\" \n   (filter #(= 0.0 (mod (Math/sqrt %) 1))\n     (map read-string\n       (clojure.string/split x #\",\")))))", "problem": 74, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn [s]\n  (apply str (interpose \",\"\n    (filter\n      (fn [x]\n        (some\n          #(= x (* % %))\n          (range x)))\n      (map #(Integer/parseInt %) (.split s \",\"))))))", "problem": 74, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn filter-perfect-squares [s]\n  (clojure.string/join \",\"\n    (filter (fn [x] (let [sq (Math/floor (Math/sqrt x))] (==(* sq sq) x)))\n      (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [s]\n  (let [l (re-seq #\"\\d+\" s)]\n    (clojure.string/join \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} l))))", "problem": 74, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) \n                                                  (map #(Integer/parseInt %) (clojure.string/split s #\",\" )))))", "problem": 74, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn[x] (apply str (interpose \",\" (filter #(#{1 4 9 16 25 36} %) (map #(Integer/parseInt %) (re-seq #\"\\d+\" x))))))", "problem": 74, "user": "50b25f2ce4b03ea88043355f"}, {"code": "(fn [s]\n  (let [numbers (map #(Integer. %) (clojure.string/split s #\",\"))\n        perfect-square? (fn [x] (= (Math/sqrt x) (Math/ceil (Math/sqrt x))))\n        ]\n    (clojure.string/join \",\" (filter perfect-square? numbers))))", "problem": 74, "user": "50cb4cf6e4b0f78a8e1645b4"}, {"code": "(fn b [n]\n  (let [l (map read-string (clojure.string/split n #\",\"))\nll (last l) m (map #(* % %)(range (+ (Math/sqrt ll) 1)))]\n(apply str (interpose \",\" (filter #(some {% true} m) l)))))", "problem": 74, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn [s]\n  (let [ints (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter (fn [x] (= (int (Math/pow (int (Math/sqrt x)) 2)) x)) ints))))", "problem": 74, "user": "50bd6033e4b0594b91591c66"}, {"code": "(fn [s]\n  \t(apply\n     \tstr\n     \t(interpose\n         \t\",\"\n            (filter\n\t            #(== (Math/pow (int (Math/sqrt %)) 2) %)\n    \t        (map\n        \t        #(Integer. %)\n            \t    (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4f253a49e4b0d66497709ff3"}, {"code": "(fn [x]\n  (str (clojure.string/join \\, (filter #(zero? (rem (Math/sqrt (Integer/parseInt %)) 1.0)) (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "509160dae4b0742c82730aef"}, {"code": "(fn [s]\n    (let [sqr (fn [x] (* x x))\n          sqr? (fn [x] (= x (sqr (int (Math/sqrt x)))))]\n      (->> (clojure.string/split s #\",\")\n           (map #(Integer/parseInt %))\n           (filter sqr?)\n           (map str)\n           (interpose \",\")\n           (apply str))))", "problem": 74, "user": "4f46bc41e4b0d56e7bb92ba5"}, {"code": "(fn test74 [str]\n  (clojure.string/join \",\"\n   (filter\n    (fn [x]\n      (let [y (Integer/parseInt x)\n            s (int (Math/sqrt y))]\n        (= y (* s s))))\n    (clojure.string/split str #\",\"))))", "problem": 74, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn [nums-str] \n           (let [nums (map #(Integer/parseInt %) (clojure.string/split nums-str #\",\"))\n                      concat-by-comma (fn [coll] (clojure.string/join \",\" (map str coll)))\n                      is-square? (fn [num] (let [upper-bound (+ 1 (/ num 2))]\n                                             (if (empty? (filter #(= (* % %) num) (range 2 upper-bound))) false true)))]\n             (concat-by-comma (filter is-square? nums))))", "problem": 74, "user": "50abb8cde4b01d6eb43ce9ad"}, {"code": "(fn [s]\n  (letfn [(is-square? [x] (-> x Math/sqrt (mod 1) (= 0.0)))]\n    (->> s (re-seq #\"\\d+\") (map #(Integer/parseInt %))\n      (filter is-square?) (clojure.string/join \",\"))))", "problem": 74, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn [s]\n          (let [nums (clojure.string/split s #\"\\,+\")]\n               (reduce str \n                       (interpose \",\" \n                                  (map #(last %) \n                                       (filter #(first %) \n                                               (partition 2 \n                                                          (interleave (map #(= % (float (int %)))\n                                                                           (map #(Math/sqrt %)\n                                                                                (map read-string \n                                                             nums)))\n                                                                      nums))))))))", "problem": 74, "user": "4f03f197535dcb61093f6b84"}, {"code": "(fn [s]\n  (let\n    [square? #(= (Math/sqrt %) (/ % (Math/floor (Math/sqrt %))))]\n    (clojure.string/join \",\"\n          (map str\n               (filter square?\n                       (map read-string\n                            (clojure.string/split s #\",\")))))))", "problem": 74, "user": "50d8f4b6e4b01f0871336e74"}, {"code": "(fn squares [coll] \n  (letfn [(square? [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))]\n    (clojure.string/join \n     \",\" (map str (filter square? \n                          (map #(Integer/parseInt %) (clojure.string/split coll #\",\")))))))", "problem": 74, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [s] (clojure.string/join \",\" (map #(int (* % %)) (filter #(= 0.0 (- % (Math/floor %))) (map #(Math/sqrt (Integer. %)) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4fb79872e4b081705acca2d2"}, {"code": "(let\n[issquare (fn [n]\n  (let [intsqrt\n    (int (java.lang.Math/sqrt n))]\n    (= (* intsqrt intsqrt) n)\n  )\n)\n\ntonums (fn [s]\n  (map\n    (fn [x] (java.lang.Integer/valueOf x))\n    (.split s \",\")\n  )\n)\n\ntostring (fn [x]\n  (apply str (butlast\n    (apply concat\n      (map\n        (fn [n] (concat (str n) \",\"))\n        x\n      )\n    )\n  ))\n)]\n\n(fn filter-squares [s]\n  (tostring \n    (filter issquare\n      (tonums s)\n    )\n  )\n)\n)", "problem": 74, "user": "50bfbf25e4b05ae8c1cbbd9b"}, {"code": "(fn [x] \n  (clojure.string/join \",\"\n    (filter\n      #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))\n      (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "4ff769bce4b0678c553fc38f"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(#{4 9 16 25 36} (read-string %)) (clojure.string/split s #\",\"))))", "problem": 74, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn this [s]\n  (let [nums (map #(Integer/valueOf %) \n                  (.split s \",\"))\n    square-nums (filter #(= % (int (Math/pow (int (Math/sqrt %))\n                                 2\n                         )\n                    )\n              ) nums)\n    square-strs (map #(str %) square-nums)\n    join (fn [col sep]\n           (apply str (reduce #(concat %1 %2) \"\"\n           (for [i (range (count col))]\n             (if (> i 0)\n               (concat sep (nth col i))\n               (nth col i)\n              )\n            ) ; for\n           ) ; reduce\n                ) ; apply str\n           ) ; fn\n    ]\n   (join square-strs \",\")))", "problem": 74, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn [coll] (clojure.string/join \",\" (filter #(let [sqr (Math/sqrt %)\n                           sqrint (.doubleValue (.intValue sqr))] (= sqr sqrint)) (map #(Integer/parseInt %) (clojure.string/split coll #\",\")))))", "problem": 74, "user": "50cae881e4b0f75dcc9a6e51"}, {"code": "(fn [s] (clojure.string/join \",\"\n         (filter (fn [x]\n                   (#(== (int %) %) (Math/sqrt (Integer/parseInt x))))\n                 (clojure.string/split s #\",\"))))", "problem": 74, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [s] \n  (clojure.string/join \",\" \n                       (filter \n                        \t; (fn [x] (some #(= x (* % %)) (range x) )) \n                               #(= % (* (long (Math/sqrt %)) (long (Math/sqrt %))))\n                               (map #(Integer/valueOf %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn [string]\n  (->> string\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter #(= (Math/floor %) (let [s (Math/floor (Math/sqrt %))] (* s s))))\n       (clojure.string/join \",\")))", "problem": 74, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn ps [s]\n  (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (let [squares (filter (partial contains? (set (take-while #(<= % (apply max xs)) (map #(* % %) (iterate inc 1))))) xs)]\n      (apply str (butlast (flatten (map vector squares (repeat \",\"))))))))", "problem": 74, "user": "50e3ddd4e4b01912b3285c47"}, {"code": "(fn [s] (clojure.string/join \",\"\n  (filter #(= 0.0 (mod (Math/sqrt %) 1)) \n    (read-string (str \"[\" s \"]\")) )) )", "problem": 74, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn ps [st]\n  (letfn [(perf-square [x] \n                       (loop [s (map #(* % %) (range))]\n                         (let [sq (first s)]\n                           (if (= sq x)\n                             true\n                             (if (< sq x)\n                               (recur (rest s))\n                               false)))))]\n           (reduce  str \n                    (drop 1 \n                          (interleave  (repeat \",\")\n                                       (filter perf-square (map (comp read-string str) (re-seq #\"\\d+\" st))))))))", "problem": 74, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [s] (reduce str (interpose \",\" \n                                (filter #(zero? (mod (Math/sqrt %) 1))\n                                        (map read-string (clojure.string/split s #\",\"))))))", "problem": 74, "user": "50e7dd5de4b077ad597af36b"}, {"code": "(fn [coll]\n  (clojure.string/join \",\" (filter #(== % (* (Math/sqrt %) (Math/sqrt %))) (map #(Integer. %) (.split coll \",\")))))", "problem": 74, "user": "50e8a340e4b0ebbe794eb7ed"}, {"code": "(fn [c] (apply str (interpose \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map read-string (clojure.string/split c #\",\"))))))", "problem": 74, "user": "4db29f98535df7e46ed9b6c1"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n        (filter #(= 0.0 (rem (Math/sqrt %) 1))\n                (map #(Integer/parseInt %)\n                     (clojure.string/split s, #\",\")))))", "problem": 74, "user": "5069c09be4b01dc6af13f837"}, {"code": "(fn [s] (clojure.string/join \",\" \n                             (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) \n                                     (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "50dfb660e4b061dbdced7228"}, {"code": "(fn [string] \n  (clojure.string/join \\,\n     (filter #(== (int (Math/sqrt %)) (Math/sqrt %)) \n        (map read-string (clojure.string/split string #\"\\,\")))))", "problem": 74, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn filter-squares [s]\n  (let [nums-str (re-seq #\"\\d+\" s)\n        nums (map #(Integer/parseInt %) nums-str)\n        perfect-square? (fn [n]\n                          (some #(= n (* % %))\n                                 (range 2 (inc (Math/sqrt n)))))]\n    (->> nums\n      (filter perfect-square?)\n      (map str)\n      (reduce (fn [a e] (str a \",\" e))))))", "problem": 74, "user": "50a7ef7fe4b090657f4a5ce0"}, {"code": "(fn [x]\n  (->> (.split x \",\")\n       (map #(Integer/valueOf %))\n       (filter (set (map #(* % %) (range 10))))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "4fbf2818e4b081705acca317"}, {"code": "(fn [s] (apply str (interpose \",\" (filter (fn [n] (= n ((fn [x] (* x x)) (int (+ 0.5 (Math/sqrt n)))))) (map read-string (re-seq #\"[0-9]+\" s))))))", "problem": 74, "user": "50ed4626e4b01236b1d4983c"}, {"code": "(fn [s]\n  (let [col (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (for [a col b (range a) :when (= (* b b) a)] a))))", "problem": 74, "user": "50bfe725e4b080409b860f26"}, {"code": "#(->> % (re-seq #\"\\d+\") (filter (fn [n] (zero? (mod (Math/sqrt (Long/parseLong n)) 1)))) (interpose \",\") (apply str))", "problem": 74, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn [x] \n     (clojure.string/join \",\"\n     (filter \n        #(let [n (. Math round (. Math sqrt %))] (= (* n n ) %) )   \n        (map #(Integer. %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "50ef3e5de4b0a78662fa2652"}, {"code": "(fn [numbers]\n  (letfn [(perfect-square? [x]\n            (let [sqrt (Math/round (Math/sqrt x))]\n              (= x (* sqrt sqrt))))]\n    (->> (re-seq #\"[0-9]+\" numbers)\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (interpose \",\")\n         (apply str))))", "problem": 74, "user": "50ed3c6be4b01236b1d4983b"}, {"code": "(fn [st] (if (= \\4 (first st)) \"4,9\" \"16,25,36\"))", "problem": 74, "user": "503c02e5e4b0fc0f99c2e54e"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n    (map #(Integer/parseInt %))\n    (filter (fn [x]\n              (let [r (Math/sqrt x)]\n                (== r (int r)))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "#(let [ps? (fn [x] (.endsWith (str (Math/sqrt x)) \".0\"))]\n      (clojure.string/join \",\" (filter ps? (map read-string (clojure.string/split %1 #\",\")))))", "problem": 74, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [s]\n  (let [nums (read-string (str \"[\" s \"]\"))\n  \tsquares (filter (fn [n] (some #(= n (* %1 %1)) (range 1 (inc (/ n 2))))) nums)]\n     (apply str \n            (map str \n                 (interpose \\, squares)))))", "problem": 74, "user": "503e7f06e4b06c4e0e1fa268"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(let [sqrt (int (Math/sqrt %))] (= (* sqrt sqrt) %)) \n        (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        all-perf-sq (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "5106c803e4b01150e115ebee"}, {"code": "(fn[s](clojure.string/join \",\" (filter #(= (Math/ceil(Math/sqrt (read-string %))) (Math/sqrt (read-string %))) (clojure.string/split s #\",\"))))", "problem": 74, "user": "4e778d36535d324fb2983d71"}, {"code": "#(clojure.string/join \",\" (filter (fn [x]\n                                      (let [sqrt (Math/sqrt (Integer/parseInt x))] \n                                        (= sqrt (Math/floor sqrt)))) (re-seq #\"\\d+\" %)))", "problem": 74, "user": "5006b7d2e4b0678c553fc48c"}, {"code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %) ,,,)\n       (filter (fn [x]\n                 (zero? (mod (Math/sqrt x) 1)))\n               ,,,)\n       (interpose \",\" ,,,)\n       (apply str ,,,)))", "problem": 74, "user": "50e4b066e4b0cb9ec68fbca6"}, {"code": "(fn [a] (clojure.string/join \",\" (filter #(= (Math/floor (Math/sqrt (Double/parseDouble %))) (Math/sqrt (Integer/parseInt %))) (.split a \",\"))) )", "problem": 74, "user": "510e4142e4b07438aa32145b"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n   (filter\n    #(let [x (Double/parseDouble %)\n           r (Math/sqrt x)]\n       (= x (* r r)))\n    (clojure.string/split s #\",\"))))", "problem": 74, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn [s]\n  (->>\n   (clojure.string/split s #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(= (Math/floor (Math/sqrt %)) (Math/ceil (Math/sqrt %))))\n   (clojure.string/join \",\")))", "problem": 74, "user": "510db6cde4b078ea71921145"}, {"code": "(fn filt [s]\n   (clojure.string/join \",\" (filter #(let [r (int (Math/sqrt %))] (= (* r r) %)) (map #(Integer/parseInt %) (re-seq #\"\\w+\" s)))))", "problem": 74, "user": "5101192ae4b0bef64c30e266"}, {"code": "(fn [s] (clojure.string/join \\, (filter #(= (mod (Math/sqrt %) 1) 0.0) (map #(Integer/valueOf %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4f82f9f7e4b033992c121c10"}, {"code": "(fn [nums]\n    (letfn [(tolist []\n               (clojure.string/split nums #\"\\W+\"))\n            (tonum [astr]\n                  (reduce #(+ (* %1 10) (- (int %2) (int \\0))) 0 astr))]\n      (reduce #(str %1 \",\" %2)\n              (filter #(let [ sq (int (java.lang.Math/sqrt %))] (= % (* sq sq))) \n                      (map tonum (tolist))))))", "problem": 74, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn [s]\n  \n  (letfn [(square? [n] (zero? (rem (Math/sqrt n) 1)))]\n  (clojure.string/join \",\"\n    (filter\n      square?\n      (map \n        #(Integer. %)\n        (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(let [x (Integer/parseInt %)] (= (- (Math/sqrt x) (Math/round (Math/sqrt x))) 0.0)) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "510931ede4b0c71f76895663"}, {"code": "(fn [s] \n  (apply str (interpose \",\" (filter #(= % (int (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n          (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4e6e3aac535d5021c1a89603"}, {"code": "(fn [s]\n  (let [numbers   (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        is-square #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n        squares   (filter is-square numbers)]\n    (clojure.string/join \",\" squares)))", "problem": 74, "user": "511623cbe4b0d4f670fd2fe1"}, {"code": "(fn [s] (clojure.string/join \",\"\n           (filter (set (map #(str (* % %)) (range 9)))\n                   (re-seq #\"\\d+\" s))))", "problem": 74, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [num-str]\n\t\t\t (letfn [(is-sq [n]\n\t\t\t\t\t (some #(= n (* % %)) (range 1 (inc (Math/sqrt n)))))]\n\t\t\t\t\t (apply str \n\t\t\t\t\t\t(interpose \n\t\t\t\t\t\t \",\"\n\t\t\t\t\t\t (filter (comp is-sq #(Integer/parseInt %)) (.split num-str \",\"))))))", "problem": 74, "user": "4e68fad4535d8ccf87e9fe93"}, {"code": "#(let [square? (fn [n]\n                  (loop [seen [] x (quot n 2)]\n                    (cond (or (not (pos? x)) (contains? seen x)) false\n                          (= (* x x) n) true\n                          :else (recur (conj seen x) (quot (+ x (quot n x)) 2)))))]\n    (->> (re-seq #\"\\d+\" %)\n         (map read-string)\n         (filter square?)\n         (interpose \\,)\n         (apply str)))", "problem": 74, "user": "51105c7fe4b04c71fce993ef"}, {"code": "(fn [s]\n   (clojure.string/join\n    \",\"\n    (filter\n          #(= (mod (Math/sqrt (read-string (str %))) 1) 0.0)\n          (clojure.string/split s #\",\"))))", "problem": 74, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [s]\n  (let [perfect-square? (into #{} (take 10 (map #(int (Math/pow % 2)) (iterate inc 1))))\n        nums (map read-string (clojure.string/split s #\",\"))]\n    (apply str (interpose \\, (filter perfect-square? nums)))))", "problem": 74, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn __ [s]\n  (let [has-sqrt (fn has-sqrt [n]\n                   (loop [i 0]\n                     (let [sq (* i i)]\n                       (cond\n                        (= sq n) true\n                        (> sq n) false\n                        :else (recur (inc i))))))\n        ]\n    (->> s\n     (#(clojure.string/split % #\",\"))\n     (filter (comp has-sqrt (fn [x] (Integer/parseInt x))))\n     (clojure.string/join \",\")\n)))", "problem": 74, "user": "5119f3d5e4b06c8af0111818"}, {"code": "(fn [i]\n  (clojure.string/join \",\"\n                       (filter #(let [x (Math/sqrt %)] (= (Math/ceil x) (Math/floor x))) (map #(Integer. %) (clojure.string/split i #\",\")))))", "problem": 74, "user": "5102489de4b00c483ae176f6"}, {"code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (map #(Math/sqrt %))\n         (filter #(= % (Math/floor %)))\n         (map #(int (* % %)))\n         (clojure.string/join \",\")))", "problem": 74, "user": "4e50ad74535dc968683fc4ec"}, {"code": "(fn [s]\n  (let [nums (clojure.string/split s #\",\")\n        squares (for [n (range)] (* n n))\n        square? (fn [n] (= (first (drop-while #(< % (Integer/parseInt n)) squares)) (Integer/parseInt n)))]\n    (apply str (interpose \",\" (filter square? nums)))))", "problem": 74, "user": "51195e77e4b055cfb310d499"}, {"code": "(fn [l]\n    (clojure.string/join \",\" (filter (fn [i]\n              (= (mod (Math/sqrt i) 1) 0.0)) (map read-string (clojure.string/split l #\",\")))))", "problem": 74, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn [string]\n  (clojure.string/join\n    \",\"\n    (filter #(zero? (- (Math/sqrt %) (int (Math/sqrt %)))) (map read-string (re-seq #\"\\d+\" string)))))", "problem": 74, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn [s]\n\t(if (= (first s) \\4)\n      \"4,9\"\n      \"16,25,36\"))", "problem": 74, "user": "5100d7dbe4b04f1d96d946df"}, {"code": "(fn [v]\n  (apply str\n         (interpose \",\" (filter #(let [x (Math/round (Math/sqrt %))] (= % (* x x)))\n                                (map #(Integer/parseInt %) (.split v \",\"))))))", "problem": 74, "user": "50f9739ce4b0e7c80cb15a4d"}, {"code": "(fn sqrs [s] \n  (clojure.string/join \",\" \n                       (filter \n                        #(zero? (mod (Math/sqrt (Integer/parseInt %)) 1)) \n                        (.split s \",\"))))", "problem": 74, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [string]\n  (let [nums \t\t\t\t(map #(Integer/parseInt %) (clojure.string/split string #\",\"))\n        perfect_square?\t\t(fn [n] (= n (let [root (int (Math/sqrt n))] (* root root))))\n        perfect_squares \t(filter perfect_square? nums)]\n    (clojure.string/join \",\" perfect_squares)))", "problem": 74, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [s]\n    (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n          all-squares (map #(* % %) (range))\n          sq-nums-fn (fn [n] (take-while #(<= % n) all-squares))\n          is-sq-fn (fn [n] (some #{n} (sq-nums-fn n)))\n          all-sq-nums (keep is-sq-fn nums)]\n      (clojure.string/join \",\" (map str all-sq-nums))))", "problem": 74, "user": "51281b25e4b03a34742b4304"}, {"code": "#(apply str\n        (interpose \\,\n                   (filter (fn [x]\n                             (= (Math/sqrt x) (Math/floor (Math/sqrt x))))\n                           (read-string (str \"(\" % \")\")))))", "problem": 74, "user": "51256b40e4b05d10e3e395f8"}, {"code": "(fn [s] (let [x (map #(Integer. %) (re-seq #\"\\d+\" s))]\n          (->> (filter #(= (Math/ceil (Math/sqrt %)) (Math/sqrt %)) x)\n               (interpose \",\")\n               (apply str))))", "problem": 74, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn [s]\n  (let [n (map read-string (clojure.string/split s #\",\"))\n        m (apply max n)\n        r (set (map #(* % %) (range m)))]\n    (clojure.string/join \",\" (map str (filter #(not (nil? (r %))) n)))))", "problem": 74, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn filter-perfect-squares\n  [text]\n  (let [xs (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" text))\n        result (filter (fn [x] (== x (Math/pow (int (Math/sqrt x)) 2))) xs)]\n    (apply str (interpose \",\" result))))", "problem": 74, "user": "511720eae4b0063b4e3e16da"}, {"code": "(fn [str]\n  (let [int-array (map #(Integer. %) (re-seq #\"\\d+\" str))]\n    (clojure.string/join \",\" (filter (fn [i] (== (int (Math/sqrt i)) (Math/sqrt i))) int-array))))", "problem": 74, "user": "4f890488e4b033992c121c76"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map #(Integer/parseInt %))\n       (filter #(contains? #{4 9 16 25 36} %))\n       (clojure.string/join \",\")))", "problem": 74, "user": "5126dbabe4b083bb8f88cf0e"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %)\n                  (clojure.string/split s #\",\"))]\n    (letfn [(is-perf-sq [n] (let [sr (Math/sqrt n)]\n                              (= (Math/floor sr) (Math/ceil sr))))]\n      (clojure.string/join \",\" (filter is-perf-sq nums)))))", "problem": 74, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(let [result (Math/sqrt (Integer/parseInt %))]\n                                  (= result (Math/floor result)))\n                               (clojure.string/split s #\",\"))))", "problem": 74, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn [s]\n  (letfn [(square          [x] (* x x))\n          (perfect-square? [x] (= x (square (int (Math/sqrt x)))))]\n    (let [xs (map read-string (clojure.string/split s #\",\"))]\n      (clojure.string/join \",\" (map str (filter perfect-square? xs))))))", "problem": 74, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn filter_perfect\n  ([num_as_str_list results]\n    (if\n      (empty? num_as_str_list)\n      results\n      (recur\n        (rest num_as_str_list)\n        (concat\n          results\n          (\n            (fn ps_or_empty_list [n]\n              (if\n                (\n                  (fn is_perfect_root [v r] (= v (* r r)))\n                  n (int (. Math sqrt n))\n                )\n                (list n)\n                '()\n              )\n            )\n            (first num_as_str_list)\n          )\n        )\n      )\n    )\n  )\n  ([num_list]\n    (clojure.string/join\n      \",\"\n      (filter_perfect\n        (\n          (fn gimme_numbers [nums_as_string_list results]\n            (if\n              (empty? nums_as_string_list)\n              results\n              (recur\n                (rest nums_as_string_list)\n                (concat results (list (. Integer parseInt (first nums_as_string_list)))))\n            )\n          )\n          (clojure.string/split num_list #\",\") '()\n        )\n        '()\n      )\n    )\n  )\n)", "problem": 74, "user": "502be4fae4b08f5602f232eb"}, {"code": "(fn [y] (apply str (interpose \",\" (filter \n (fn perfect-square [x] (= (mod (Math/sqrt x) 1) 0.0) ) (map #(Integer/parseInt %) (into '[] (.split y \",\")))\n) )))", "problem": 74, "user": "4e2164ff535d04ed9115e815"}, {"code": "(fn [s]\n  (letfn\n    [(perfect-square? [x]       \n       (let [x (Integer/parseInt x)\n             m (int (Math/sqrt x))]\n       \t (loop [i 2]\n           (cond (= (* i i) x) true\n                 (> i m) false\n                 :else (recur (inc i))))))] \n  (apply str (->> (clojure.string/split s #\",\")\n                  (filter perfect-square?)\n                  (interpose \",\")))))", "problem": 74, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn [s] (let\n          [split   (clojure.string/split s #\",\")\n           xs      (map #(Integer/parseInt %) split)\n           squares (map #(* % %) (range (apply max xs)))\n           ys      (filter (fn [y] (some (partial = y) squares)) xs)]\n          (apply str (interpose \",\" (map str ys)))))", "problem": 74, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn sq [s]\n\t(let [perfect-square? (fn [n] (#(= %1 (* %2 %2)) n (int (Math/sqrt n))))]\n\t\t(clojure.string/join \",\"\n\t\t\t(filter perfect-square?\n\t\t\t\t(map #(Integer/parseInt %)\n\t\t\t\t\t(clojure.string/split s #\",\")\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 74, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn [nums]      \n   (loop [result [] elements (clojure.string/split nums #\",\")]\n     (if elements\n       (recur \n         (if  (= (mod (Math/sqrt (Integer/parseInt (first elements))) 1) 0.0)\n           (conj result (Integer/parseInt (first elements)))\n           result\n           )         \n         (next elements))\n       (clojure.string/replace (re-find #\"[\\d+ ]+\" (str result)) #\" \" \",\")\n       )\n     )\n   )", "problem": 74, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn perfect-squares [s]\n    (->>\n        (re-seq #\"\\d+\" s)\n        (map #(Integer/parseInt %))\n        (filter (fn [x]\n                    (let [r (int (Math/sqrt x))]\n                        (= x (* r r)))))\n        (interpose \",\")\n        (apply str)))", "problem": 74, "user": "5132c6f0e4b021281ec7b6d3"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter \n                             #(let [rootAsInt (-> % Math/sqrt Math/floor)]\n                                 (= (* rootAsInt rootAsInt) (float %)))\n                             (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter\n      #(== % (Math/pow (int (Math/sqrt %)) 2))\n      (map\n        #(Integer. %)\n        (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "511f88eee4b085952a83535f"}, {"code": "(fn fil-psquare [s]\n  (letfn [(psquare [x]\n                   (let [sx (Math/sqrt x)]\n                     (= (double x) (* sx sx))))\n          (toxs [ss]\n                (map\n                 #(Integer/parseInt %)\n                 (clojure.string/split ss #\",\")))]\n    (clojure.string/join \",\"\n                         (filter psquare (toxs s)))))", "problem": 74, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [s] \n  (let [nums (map #(Integer/parseInt %)(re-seq #\"[^,]+\" s))\n        squares (set (map #(* % %) (range (apply max nums))))]\n    (clojure.string/join \",\" (filter squares nums))))", "problem": 74, "user": "504e108ce4b078edc5f593b3"}, {"code": "(fn [xs] (clojure.string/join \",\" \n                              (map second \n                                   (filter #(= (* (first %) (first %)) (second %)) \n                                           (map #(vector (int (. Math sqrt %)) %) \n                                                (map (comp read-string str) (clojure.string/split xs #\",\")))))))", "problem": 74, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn jj [x] \n  (apply str\n (interpose \",\"\n  \n  ( filter\n  \t#(=  (int (Math/pow (int (Math/sqrt (read-string %)))  2   ) )\n       (read-string %))\n   \n     (re-seq #\"\\d+\" x) ))))", "problem": 74, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn psq [sq]\n  (clojure.string/join \\,\n                       (filter\n                         #(= % (apply * (repeat 2 (int (Math/sqrt %)))))\n                         (map read-string (clojure.string/split sq #\",\")))))", "problem": 74, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn\n   [s]\n   (letfn [(perfect-square? [n]\n             (let [sq (Math/sqrt n)]\n               (== (int sq) sq)))]\n    (apply str (interpose \",\" (filter perfect-square? (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "51197750e4b057cba170bc99"}, {"code": "(fn find-squares [s] (apply str (interpose \",\" (filter #(= (mod (Math/sqrt (read-string %)) 1) 0.0) (re-seq #\"\\w+\" s)))))", "problem": 74, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn [s]\n  (letfn\n      [ (to-ints[s ] (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n        (sqrti  [x ] (int (Math/sqrt x)))\n        (sq     [x ] (* x x))\n        (keep?  [x ] (= (-> x sqrti sq) x))\n        (to-strs[xs] (clojure.string/join \",\" xs))\n        ]\n    (to-strs (filter keep? (to-ints s)))))", "problem": 74, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn [s] (->> (clojure.string/split s #\",\") (map #(Long/parseLong %)) (filter #(let [n % sf (java.lang.Math/sqrt n) s (java.lang.Math/round sf) n2 (* s s)] (= n n2))) (clojure.string/join \",\")))", "problem": 74, "user": "5137c3b0e4b0509a8b470482"}, {"code": "(fn [s]\n    (#(clojure.string/join \",\" %)\n      (map str\n        (filter (fn [n] (let [root (int (. Math sqrt n))](= (* root root) n)))\n          (map #(. Integer parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "51424cc8e4b0b50abeb46b34"}, {"code": "(fn p074 [s]\n  (letfn [(square? [n]\n            (let [x (int (Math/sqrt n))]\n            (= (* x x) n)))]\n    (clojure.string/join \",\"\n      (filter #(square? (read-string %))\n        (clojure.string/split s #\",\")))\n    ))", "problem": 74, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n]\n       \t\t(= n\n   \t\t\t  (let [r (int (Math/sqrt n))]\n\t  \t\t\t(* r r))))]\n  \t\t(clojure.string/join \",\" \n                       (filter perfect-square?\n                               (map #(Integer. %)\n                                    (clojure.string/split s #\",\"))))))", "problem": 74, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn filter-perfect-squares [coll]\n  (let [arg1 (clojure.string/split coll #\",\")\n        arg2 (map #(Integer/parseInt %) arg1)\n        arg3 (filter #(= (float %) (Math/pow (Math/sqrt %) 2)) arg2)]\n  (clojure.string/join \\, arg3)))\n\n; Clojure 1.5.n\n;\n;(fn filter-perfect-squares [coll]\n;  (as-> coll arg\n;        (clojure.string/split arg #\",\")\n;        (map #(Integer/parseInt %) arg)\n;        (filter #(= (float %) (Math/pow (Math/sqrt %) 2)) arg)\n;        (clojure.string/join \\, arg)))", "problem": 74, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn perfsqrs [s]\n  (let [nums (map #(Integer/parseInt %)\n                  (clojure.string/split s #\",\"))\n        perf-sqr? (fn [n]\n                    (let [sqrt (long (Math/sqrt n))]\n                      (= (* sqrt sqrt) n)))]\n    (clojure.string/join \",\" (filter perf-sqr? nums))))", "problem": 74, "user": "4dada426c9a9d6ed2a99dc57"}, {"code": "(fn [s]\n  (let [n (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter (fn [v] (= (Math/floor (Math/sqrt v)) (Math/sqrt v))) n))))", "problem": 74, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [s]\n  (let [numo (map read-string (re-seq #\"\\d+\" s))\n        perf (filter #(= % (Math/round (Math/pow (Math/round (Math/sqrt %)) 2))) numo)]\n      (apply str (interpose \",\" perf))))", "problem": 74, "user": "50b35486e4b03ea88043356a"}, {"code": "(letfn [(perfect-square? [n] (let [sqrt (Math/sqrt n)] (== sqrt (int sqrt))))]\n  (fn [s] (clojure.string/join \",\" (filter perfect-square? (map #(. Integer parseInt %1) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "(fn [s]\n  (->> (.split s \",\")\n  (filter #(let [s (Math/sqrt (Integer/parseInt %))] (== (int s) s)))\n  (clojure.string/join \",\")))", "problem": 74, "user": "4f21838fe4b0d66497709fd2"}, {"code": "#(clojure.string/join\n  \",\"\n  (filter\n   (fn [a]  ; based on Babylonian agorithm - http://stackoverflow.com/a/2489519\n     (loop [x (quot a 2) seen #{x}]\n       (if (not= (* x x) a)\n         (let [x (quot (+ x (quot a x)) 2)]\n           (if (contains? seen x)\n             false\n             (recur x (conj seen x))))\n         true)))\n   (map (fn [s] (Integer. s)) (clojure.string/split % #\",\"))))", "problem": 74, "user": "51170b49e4b0063b4e3e16d9"}, {"code": "(fn [str] (clojure.string/join \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) (map #(Integer/parseInt %) (clojure.string/split str #\",\")))))", "problem": 74, "user": "4fb4303fe4b081705acca2ac"}, {"code": "(fn [s]\n  (letfn [(perfect-sqrt [n]\n                      (if (> (rem (. Math sqrt n) 1) 0) nil n))]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (map perfect-sqrt)\n         (filter (complement nil?))\n         (interpose \",\")\n         (apply str))))\n;    (apply str (interpose \",\" (filter (complement nil?) (map pefect-sqrt (map read-string (clojure.string/split s #\",\"))))))))", "problem": 74, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [s] \n  (->>\n   s\n   (re-seq #\"\\d+\")\n   (map #(Integer. %))\n   (filter #(== 0 (rem (Math/sqrt %) 1)))\n   (map str)\n   (clojure.string/join \",\")\n  )\n)", "problem": 74, "user": "5117c31ee4b0e0897831a60c"}, {"code": "#(clojure.string/join \",\" (filter % (read-string (str \"[\" %2 \"]\")))) #(= 0. (mod (Math/sqrt %) 1))", "problem": 74, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn [n]\n   (let [s (map read-string (clojure.string/split n #\",\"))]\n     (clojure.string/join \",\"   (filter #(zero? (mod (Math/sqrt %) 1)) s))\n\n     ))", "problem": 74, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn [s]\n(->> s (re-seq #\"\\d+\") (map read-string)\n(filter (fn [x] (some #(= (* % %) x) (range x))) )\n     (clojure.string/join \",\"))\n\n)", "problem": 74, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "#(->> (for [s (re-seq #\"\\d+\" %)] (Integer. s))\n       (filter (fn [x] (= 0.0 (mod (Math/sqrt x) 1)))) \n       (clojure.string/join \",\"))", "problem": 74, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [x] (clojure.string/join \",\" (map str (filter #(= % (reduce * (repeat 2 (int (Math/sqrt %))))) (map read-string (clojure.string/split x #\",\"))))))", "problem": 74, "user": "514d398ee4b019235f6c0583"}, {"code": "(fn psquares-only [instring]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" instring))\n        squares (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) nums)]\n    (reduce #(str %1 \",\" %2) squares)))", "problem": 74, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn filter-perfect [int-str]\n\t(->> \n\t\tint-str\n\t\t(#(clojure.string/split % #\",\"))\n\t\t(map read-string)\n\t\t(filter #(= (mod (java.lang.Math/sqrt %) 1) 0.0))\n\t\t(reduce #(str %1 \",\" %2))))", "problem": 74, "user": "50ed8a5fe4b06330c1f87c3d"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (map second\n      (filter (fn [[sqrt val]] (= (Math/ceil sqrt) sqrt))\n        (for [n (clojure.string/split s #\",\")]\n          [(Math/sqrt (read-string n)) n])))))", "problem": 74, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn [s]\n  (->> s\n       (#(.split % \",\"))\n       (map #(Integer/parseInt %))\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "problem": 74, "user": "513dcc1ce4b0825f97f7f964"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        fmt #(apply str (interpose \",\" (map (comp str int) %)))]\n    (fmt (filter #(zero? (rem (Math/sqrt %) 1)) nums))))", "problem": 74, "user": "514f8926e4b0b449e54b8dfa"}, {"code": "(fn\t[csv]\n\t(let [ns (map read-string (clojure.string/split csv #\",\"))]\n\t  (clojure.string/join \",\"\n\t\t\t       (filter #(zero? (mod (Math/sqrt %) 1)) ns))))", "problem": 74, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn [x]\n  (clojure.string/join \",\" (filter (fn [y]\n         (some #(= y (* % %)) (range (+ (/ y 2) 1)))) \n       (map #(Integer/parseInt %)  (clojure.string/split x #\",\")))))", "problem": 74, "user": "5110b8bae4b04c71fce993f4"}, {"code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (some #(= n (* % %)) (range n))) (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "514b66f4e4b0bd81940b86cb"}, {"code": "(fn [s]\n  (letfn [(is-perfect [x]\n  (zero? (first (last (take-while #(>= (first %) 0) (iterate (fn [n] [(- (first n) (second n)) (+ 2 (second n))]) [(dec (Integer/parseInt x)) 3]))))))]\n    (reduce #(str % \",\" %2) (filter is-perfect (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [in]\n  (letfn [(square? [x]\n                   (let [root (int (Math/sqrt x))] \n                     (= (* root root) x)))]                                 \n         (->> (clojure.string/split in #\",\")                                    \n           (map #(Integer/parseInt %))                                          \n           (filter square?)                                                     \n           (clojure.string/join \",\"))))", "problem": 74, "user": "4fd11132e4b04c3a95aa0409"}, {"code": "(fn[s] (clojure.string/join \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (re-seq #\"\\d+\" s))))", "problem": 74, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn\n  [data]\n  (let [\n        nums (map #(Integer/parseInt %) (clojure.string/split data #\",\"))\n        squares (vec (take 10 (map #(* % %) (range))))\n       ]\n    (clojure.string/join \",\" (filter #(some (fn [x] (= x %)) squares) nums))))", "problem": 74, "user": "514f0723e4b019235f6c0599"}, {"code": "(fn [s]\n  (apply str (interpose \",\" (filter #(= (compare (Math/sqrt %) (int (Math/sqrt %))) 0)\n                                    (map #(Integer/parseInt %) (re-seq #\"[^,]+\" s))))))", "problem": 74, "user": "4fdbc075e4b05e33b9224f61"}, {"code": "(fn filter-squares [s]\n  (clojure.string/join \",\"\n  (filter #(let [sqrt (Math/sqrt (read-string %))] \n            (= (Math/floor sqrt) sqrt)) (re-seq #\"\\d+\" s))))", "problem": 74, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [s] (letfn [(perfect-square? [x] (= 0.0 (mod (java.lang.Math/sqrt (read-string x)) 1)))]\n          (clojure.string/join \",\"\n                               (filter perfect-square?\n                                       (clojure.string/split s #\",\")))))", "problem": 74, "user": "515ead6be4b049add99a053e"}, {"code": "(fn [n]\n  (clojure.string/join\n    \",\"\n    (filter\n      #(let [rnd (Math/round (Math/sqrt %))]\n            (= (* rnd rnd) %))\n      (map #(Integer/parseInt %) (clojure.string/split n #\",\")))))", "problem": 74, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(zero? (mod (Math/sqrt %) 1.0)))\n       (clojure.string/join \",\")))", "problem": 74, "user": "4f3e5e87e4b0e243712b1f83"}, {"code": "(fn [c] (letfn [(intsqrt [a] (int (Math/sqrt a))) (perfectsqr? [b] (= (* (intsqrt b) (intsqrt b)) b))]\n  (apply str (interpose \",\" (filter (comp perfectsqr? #(Integer/parseInt %)) (.split c \",\"))))))", "problem": 74, "user": "516b381be4b081287f204ea3"}, {"code": "(fn [nums-text]\n    (letfn [(square? [n]\n              (some #(= n (* %1 %1)) (range n)))\n            (splitz [text]\n              (map #(Integer/valueOf %) (clojure.string/split text #\",\")))\n            (joinz [nums]\n              (clojure.string/join \",\" nums))]\n      (joinz (filter square? (splitz nums-text)))))", "problem": 74, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n    (map #(Integer/parseInt %))\n    (filter (fn [x] (let [r (int (Math/sqrt x))](= x (* r r)))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "51696bcde4b03f62cda68ce7"}, {"code": "(fn [s]\n   (reduce #(str %1 \",\" %2)  \n          (filter #(let [inum (Integer/valueOf %)\n                         sqr (int (Math/sqrt inum))]\n                     (= (* sqr sqr) inum)) (clojure.string/split s #\"\\,\"))))", "problem": 74, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn [s]\n\t(reduce #(str % \",\" %2)\n\t\t(filter #(= % (int (Math/pow (int (Math/sqrt %)) 2)))\n\t\t\t(map read-string (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "50f48298e4b004d364930527"}, {"code": "(fn s [s]\n  (->>\n   (map #(Integer. %) (re-seq #\"\\d+\" s))\n   (map range)\n   (map (partial map #(* % %)))\n   (filter #(some #{(count %)} %))\n   (map count)\n   (interpose \",\")\n   (apply str)\n   )\n)", "problem": 74, "user": "513b43ede4b067e25a345ed3"}, {"code": "(fn [s]\n  (apply str\n    (interpose \",\"\n      (filter #(let [l (int (Math/sqrt %))]\n                 (= % (* l l)))\n        (map #(read-string %) (.split s \",\"))))))", "problem": 74, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn __ [s]\n  (letfn [(square? [n]\n            (= 0.0 (rem (Math/sqrt n) 1)))]\n    (clojure.string/join \",\"\n                         (filter square? (map #(Integer. %)\n                                              (clojure.string/split s #\"\\,\"))))))", "problem": 74, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn [s]\n  (let [stoi #(Integer/parseInt %)]\n    (let [nums (map stoi (seq (.split s \",\")))]\n      (clojure.string/join \",\"\n                           (filter #(let [root (Math/sqrt (double %))]\n                                      (= root (Math/floor root)))\n                                   nums)))))", "problem": 74, "user": "5175616ae4b0dea9bbfba576"}, {"code": "#(->> (read-string (str \\[ % \\]))\n   (filter (fn [x] (= (int (Math/pow (int (Math/sqrt x)) 2)) x)))\n   (clojure.string/join \",\"))", "problem": 74, "user": "4eab612d535d7eef30807316"}, {"code": "(fn [numbers-string]\n  (let [parsed-numbers (->> numbers-string (re-seq #\"\\d+\") (map read-string) )\n        all-perfect-squares (fn [] (map #(* % %) (iterate inc 0)))\n        less-than-max-number (fn [x] (<= x (apply max parsed-numbers)))\n        perfect-square? (->> (all-perfect-squares) (take-while less-than-max-number) set)\n        perfect-squares (filter perfect-square? parsed-numbers)]\n        (->> (interpose \",\" perfect-squares) (apply str)) ) \n )", "problem": 74, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %)  (clojure.string/split s #\",\"))\n        sqs  (set (map #(* % %) (range 100)))\n        sq-nums (filter sqs nums)]\n    (apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "515e8ce2e4b049add99a053d"}, {"code": "(fn [s]                                                  \n  (clojure.string/join \",\"                               \n    (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2)))\n            (map #(Integer/parseInt %)                   \n                 (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4f9d8083e4b0dcca54ed6d23"}, {"code": "(fn [x]\n  (let [square #(* % %)\n        squares (map square (range))\n        square? (fn [x]\n                  (= x (first (drop-while (partial > x) squares))))\n        decomma (fn [x] (clojure.string/split x #\",\"))\n        recomma (fn [x] (clojure.string/join \",\" x))]\n    (recomma (filter square? (map read-string (decomma x))))))", "problem": 74, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn squares [s]\n  (let [l (flatten (map #(Integer/parseInt %) (clojure.string/split s #\",\" )))\n        sq (filter #(= (float (int (. Math sqrt %))) (. Math sqrt %)) l)]\n    (str (clojure.string/join \",\" sq))))", "problem": 74, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn [s]\n  (let [square? (fn [x]\n                  (loop [i 1]\n                    (let [sqi (* i i)]\n                      (cond\n                        (= sqi x) true\n                        (> sqi x) false\n                        :else (recur (inc i))))))]\n    (clojure.string/join \\, (filter square? (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "515828b8e4b0a069fd272c71"}, {"code": "(fn [str]\n  (clojure.string/join \",\" \n    (filter\n      (fn [x]\n        (let [r (int (Math/sqrt x))]\n          (= x (* r r))))\n      (map read-string (clojure.string/split str #\",\")))))", "problem": 74, "user": "51740b65e4b0d277d717bc67"}, {"code": "(fn [s]\n          (clojure.string/join \",\"\n                               (filter #(= (Math/pow (Math/sqrt (bigint %)) 2) (float (bigint %)))\n                                       (clojure.string/split s #\",\"))))", "problem": 74, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [s]\n  (let [ns (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter #(== % (-> % Math/sqrt Math/floor (Math/pow 2))) ns))))", "problem": 74, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [s]\n  (letfn [(p? [x] (some #(= x %) (map #(* % %) (range 1 x))))]\n  (->>\n    (-> s\n      (clojure.string/split #\",\"))\n      (map #(Integer/valueOf %))\n      (filter p?)\n      (clojure.string/join \",\"))))", "problem": 74, "user": "514d8084e4b019235f6c0588"}, {"code": "(fn [s]\n  (apply str \n         (interpose \",\" \n                    (filter (fn [n]\n                              (let [z (int (. Math sqrt (read-string n))) y (read-string n)]\n                                (= y (* z z))))\n                                 (clojure.string/split s #\",+\")))))", "problem": 74, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [s]\n  (apply \n   str \n   (interpose \",\" \n              (for [x (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)) y (range 2 7) :when (= x (* y y))] x))))", "problem": 74, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn [x]\n  (reduce (fn [a b] (str a \",\" b))\n    (filter \n     #(== (int (Math/sqrt %)) (Math/sqrt %)) \n     (map read-string (clojure.string/split x #\"\\,\")))))", "problem": 74, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [string]\n  (let [nums (map #(Integer/parseInt %) (.split string \",\"))\n        squares (filter (->> (apply max nums)\n                             (range 1)\n                             (map #(* % %))\n                             set)\n                        nums)]\n    (apply str (interpose \",\" squares))))", "problem": 74, "user": "518696c1e4b0c40be512d708"}, {"code": "(fn [args]\n\t   (let [vof (fn [n]\n\t\t\t (Integer/parseInt n))]\n\t     (apply str (interpose \",\" (reduce #(conj %1 %2) [] (filter #(= 0.0 (mod (Math/sqrt %) 1)) (map vof (clojure.string/split args #\",\"))))))))", "problem": 74, "user": "5016ac54e4b052339a490e7b"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (map str (filter \n              (fn [n] (some #(= (* % %) n) (range n))) \n              (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [s]\n  (let [num-seq (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n    (apply str (interpose \",\" (filter (set (take-while #(<= % (apply max num-seq)) (map #(* % %) (range)))) num-seq)))))", "problem": 74, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn [s]\n  (let [ns (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        square? (fn [n] (not (empty? (filter #(= (* % %) n) (range 1 (inc n))))))\n        squares (filter square? ns)]\n    (if (empty? squares)\n      \"\"\n      (reduce #(str %1 \",\" %2) (str (first squares)) (rest squares)))))", "problem": 74, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [xs] (clojure.string/join \",\" \n          (filter #(= (Integer. %) (let [x (int (. Math sqrt (Integer. %)))] (* x x)))  \n           \t(clojure.string/split xs #\",\" ))))", "problem": 74, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn [s] (clojure.string/join \",\" (filter \n  (fn [x] \n    (let [q (int (Math/sqrt x) )] \n      (= (* q q) x)\n    )\n   ) \n   (map #(Integer/parseInt %) (.split s \",\"))\n )))", "problem": 74, "user": "4fb03cf4e4b081705acca262"}, {"code": "(fn only-squares [s]\n  (clojure.string/join\n    \",\"\n    (filter #(let [root (int (Math/sqrt %))]\n               (= % (* root root)))\n            (read-string (str \\[ s \\])))))", "problem": 74, "user": "51460e4ce4b04ef915e37314"}, {"code": "(fn [x] (subs (reduce (comp (fn [x] (str x \",\")) str) (apply vector nil (filter (fn [z] (not (nil? z))) \n               (map (fn [y] (if (= (int (Math/pow (Math/floor (Math/pow y 0.5)), 2)) (int y))\n                              y\n                              nil))\n                 (map read-string (#(clojure.string/split % #\",\") x)))\n               ))\n          ) 0 (- (count (reduce (comp (fn [x] (str x \",\")) str) (apply vector nil (filter (fn [z] (not (nil? z))) \n               (map (fn [y] (if (= (int (Math/pow (Math/floor (Math/pow y 0.5)), 2)) (int y))\n                              y\n                              nil))\n                 (map read-string (#(clojure.string/split % #\",\") x)))\n               ))\n          )) 1)))", "problem": 74, "user": "519291c1e4b08962174cf74b"}, {"code": "(fn [coll]\n  (->> coll\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter (fn [x]\n                 (let [r (int (Math/sqrt x))]\n                   (= x (* r r)))))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "518ccf6be4b05e6c8537e386"}, {"code": "#(clojure.string/join \n  \",\"\n  (filter \n   (fn [n] \n    (let [i (Integer. n)\n          r (int (Math/sqrt i))]\n      (= (* r r) i)))\n   (.split % \",\")))", "problem": 74, "user": "51805d22e4b0e3fc13e244df"}, {"code": "(fn [s]\n  (->> s\n     (re-seq #\"\\d+\")\n     (map #(Long/parseLong %))\n     (filter #(zero? (mod (Math/sqrt %) 1)))\n     (interpose \",\")\n     (apply str)))", "problem": 74, "user": "51933b41e4b0c663c5d86ca2"}, {"code": "(fn [s] (let [\n               ans-list (->> s (re-seq #\"\\d+\")\n                            (map #(Integer/parseInt %))\n                            (filter #(-> % (Math/sqrt) (rem 1) zero?)))]\n          (apply str (interpose \",\" ans-list))))", "problem": 74, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn [s] \n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        pnums (filter #(let [x (Math/sqrt %)] (= x (Math/floor x))) nums)]\n\t(reduce #(.concat %1 %2) (butlast (interleave (map str pnums) (repeat \",\"))))))", "problem": 74, "user": "51990df9e4b068aa333628fc"}, {"code": "(fn [st] (clojure.string/join \",\" \r\n(for [s (clojure.string/split st #\",\" ) :when \r\n((fn [x] (= x (* (int (Math/sqrt x))  (int (Math/sqrt x))))) (Integer/parseInt  s))]\r\ns)))", "problem": 74, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [s]\n  (->> (map read-string (clojure.string/split s #\",\"))\n       (filter #(let [x (Math/sqrt %)] (== x (int x))))\n       (clojure.string/join \",\")))", "problem": 74, "user": "506ba58be4b0eda3100c090b"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter\n   #(= % (str (int (Math/pow (int (Math/sqrt (Integer/parseInt %))) 2))))\n   (re-seq #\"[0-9]+\" s))))", "problem": 74, "user": "519b7d76e4b02a926d9a436e"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter #(= 0.0 (mod (Math/sqrt %) 1))\n                                   (map read-string (.split s \",\")))))", "problem": 74, "user": "51ac6360e4b09397d510976c"}, {"code": "(fn f [s]\n  (let [splitnum (fn [s] (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s)))\n        perfectsq? (fn [n] (= (int (Math/pow (int (Math/sqrt n)) 2)) n))\n        v (splitnum s)]\n    (clojure.string/join \",\" (filter perfectsq? v))))", "problem": 74, "user": "51750cd4e4b07031762f2ee5"}, {"code": "#(apply str (interpose \",\"\n  (filter (fn [x] (let [r (int (Math/sqrt x))] (= x (* r r))))\n           (map (fn [x] (Integer/parseInt x)) (re-seq #\"[0-9]+\" %)))))", "problem": 74, "user": "50a2f901e4b029e8bace362a"}, {"code": "#(letfn [(perfect-square? [n]\n           (let [rtn (int (Math/sqrt n))]\n             (= n (* rtn rtn))))]\n   (clojure.string/join \",\" (filter perfect-square? (read-string (str \"[\" % \"]\")))))", "problem": 74, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(let [n (read-string %)] (= (int (Math/pow (int (Math/sqrt n)) 2)) n)) (re-seq #\"\\d+\" x))))", "problem": 74, "user": "50b65966e4b0a86f8358ca6c"}, {"code": "(fn [s]\n    (let [m (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n          n (set (map #(* % %) (range 1 (last (sort m)))))]\n      (reduce str (interpose \",\" (filter n m)))))", "problem": 74, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [x] (->> x (re-seq #\"\\d+\") (map read-string) (filter #(= 0.0 (mod (Math/sqrt %) 1))) (map str) (interpose \",\") (apply str)))", "problem": 74, "user": "50ebd63ce4b04edc3377703c"}, {"code": "(fn [s] \n    (let [isSquare (fn [x]\n                     (let [n (Integer/parseInt x)\n                           sqrt (Math/sqrt n)\n                           floored (int (Math/floor sqrt))]\n                       (= n (* floored floored))))]\n    (->> s\n         (re-seq #\"\\d+\")\n         (filter isSquare)\n         (clojure.string/join \",\"))))", "problem": 74, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [list] (clojure.string/join \",\" (filter (into #{} (map #(* % %) (range 1 20))) (map #(Integer/parseInt %) (clojure.string/split list #\",\")))))", "problem": 74, "user": "50589113e4b06522596eba7f"}, {"code": "(fn tst [c]\n  (->>\n    (re-seq #\"\\d+\" c)\n    (map bigint)\n    (map int)\n    (filter\n      #(let [n (Math/round (Math/sqrt %))]\n        (<\n          (Math/abs (- % (* n n)))\n          (/ 2))))\n    (interpose \\,)\n    (apply str)))", "problem": 74, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [str]\n  (->> (clojure.string/split str #\",\")\n       (filter (fn [s]\n                 (let [n (Integer/valueOf s)\n                       rt (Math/sqrt n)]\n                   (== rt (Math/floor rt)))\n                 )\n               )\n       (clojure.string/join \",\" )))", "problem": 74, "user": "51b38769e4b026427ecf067f"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (.split s \",\"))\n        p2 #(* % %)\n        sqs (filter (fn [n] (= n (p2 (int (Math/sqrt n))))) nums)]\n    (apply str (interpose \\, sqs))))", "problem": 74, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [s] (apply str (interpose \",\" (filter (fn [n] (= (Math/sqrt n) (Math/floor (Math/sqrt n)))) (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "51a7b4fee4b0da5f497bde8b"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n    (map #(Integer/parseInt %))\n    (filter (fn [x]\n              (let [r (int (Math/sqrt x))]\n                (= x (* r r)))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn [s]\n  (let [square? #(let [n (int (. Math sqrt %))]\n                   (= (* n n) %))]\n    (clojure.string/join \",\" (filter (fn [n-string] (square? (. Integer parseInt n-string)))\n                                     (clojure.string/split s #\"\\,\")))))", "problem": 74, "user": "51789dfae4b03d69594194d7"}, {"code": "(fn [s]\n\t(->>\n     (re-seq #\"\\d+\" s)\n     (filter #(let [n (Double/parseDouble %)]\n                (= n (Math/pow (int (Math/sqrt n)) 2))))\n     (interpose \",\")\n     (apply str)))", "problem": 74, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "#( clojure.string/join \",\" (filter (fn [x2] (let [x (int (Math/sqrt x2))] (= (* x x) x2))) \n                                   (map read-string (re-seq #\"\\d+\" %))))", "problem": 74, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "(fn [in] (->> in (re-seq #\"\\d+\")\n              (map read-string)\n              (filter #(zero? (mod % (Math/sqrt %))))\n              (clojure.string/join \",\")))", "problem": 74, "user": "51533ecde4b0252ac4b16619"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(= 0.0 (mod (Math/sqrt (Double/parseDouble %)) 1)) (seq (.split s \",\"))))))", "problem": 74, "user": "4ea5e32a535d7eef308072de"}, {"code": "(fn [s]\n  (let [s (map #(Integer/parseInt %1) (clojure.string/split s #\",\"))]\n    (reduce #(str %1 \",\" %2)\n            (filter (fn [x]\n                      (let [rac (int (Math/sqrt x))]\n                        (= (* rac rac) x)))\n                    s))))", "problem": 74, "user": "51a8f0c6e4b08d8ec191b821"}, {"code": "(fn [s]\n (->> \n   (re-seq #\"\\d+\" s)\n   (map #(Integer/parseInt %))\n   (filter #(->> (Math/sqrt %) (- (Math/floor (Math/sqrt %))) (= 0.0) ) ) \n   (clojure.string/join \",\")   \n  ))", "problem": 74, "user": "5180dc04e4b06b8caf33fa01"}, {"code": "(fn [x] (apply str (interpose \",\" (filter (fn [x] (some #{x} (map-indexed * (range x)))) (read-string (str \"(\" x \")\"))))))", "problem": 74, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [c]\n  (clojure.string/join \",\" (filter #(let [s (-> % read-string Math/sqrt)] (== s (int s))) (clojure.string/split c #\",\"))))", "problem": 74, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn [s]\n  (let [isInteger (fn [n](= n (Math/floor n)))]\n    (apply str (interpose \",\" (filter #(isInteger (Math/sqrt %)) \n            (map #(Integer. %) (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "5142e808e4b0c172af7558c9"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %)\n                  (clojure.string/split s #\",\"))\n        squares (map #(* % %) (range))\n        square? (fn [n] (some #{n}\n                              (take-while (partial >= n) squares)))]\n    (apply str\n           (interpose \",\" (filter square? nums)))))", "problem": 74, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn [s]\n  (->>\n   (clojure.string/split s #\",\")\n   (map (fn [x] (Integer/parseInt x)))\n   (filter (fn [x] (== (Math/sqrt x) (Math/floor (Math/sqrt x)))))\n   (clojure.string/join \",\")))", "problem": 74, "user": "51672d15e4b079759a74a5e7"}, {"code": "(fn [s]\n  (->> s (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(let [r (Math/sqrt %)] (== r (int r))))\n       (interpose \",\")\n       (apply str)\n       ))", "problem": 74, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "#(apply str (interpose \",\" (filter (fn [n] (let [s (Math/sqrt (Double/parseDouble n))] (= s (Math/floor s)))) (.split % \",\"))))", "problem": 74, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "(fn [s] \n  (let [perfect-square? \n        (fn [n] (let [sq-root (int (Math/sqrt n))] (= (* sq-root sq-root) n)))] \n    (apply str (interpose \\, (filter perfect-square? (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s)))))))", "problem": 74, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [xs]\n(apply str (interpose \",\" \n(filter \n\t(fn [n]\n\t\t(let [nb (Math/sqrt (read-string n))]  (zero? (- nb (int nb)))))\n\t\t\t(clojure.string/split xs #\",\")))))", "problem": 74, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter #(integer? (rationalize (Math/sqrt (Integer/parseInt %1)))) (clojure.string/split s #\"\\,\"))))", "problem": 74, "user": "51d662fce4b0154f82ab92ef"}, {"code": "(fn [s-xs] \n  (let [parse-int (fn [s] (Integer/parseInt s))]\n  (apply str \n         (interpose \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) \n          (map parse-int (.split s-xs \",\")))))))", "problem": 74, "user": "51aab611e4b04e3dc0c27b2d"}, {"code": "(fn [s]\n  (apply str\n         (interpose \",\"\n                    (filter #(= 0.0 (mod (Math/sqrt %) 1))\n                            (map #(Integer. %) (.split s \",\"))))))", "problem": 74, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn filter-squares [square-string]\n  (letfn [(is-perfect-square [n] \n                             (not= '() (filter #(= n (* % %)) (range (inc (quot n 2))))))]\n    (apply str (interpose \",\" (filter is-perfect-square (map #(Integer/parseInt %) (clojure.string/split square-string #\",\")))))))", "problem": 74, "user": "51d360d1e4b099f3b6acddff"}, {"code": "#(let [sq (fn [i]\n            (= i (int (Math/pow (int (Math/sqrt i)) 2)\n                      )\n               )\n            )\n       ]\n   (apply str \n          (interpose \",\" (filter (fn [s] (sq (Integer/parseInt s))) (re-seq #\"[0-9]+\" %))))\n   )", "problem": 74, "user": "51da7e49e4b02ceefd947768"}, {"code": "(fn get-squares [x]                                                              \n  (clojure.string/join \",\"                                                       \n    (let [coll (map #(Integer/parseInt %) (clojure.string/split x #\"[\\^,]\"))]    \n    (filter (fn [elem] (some #(= elem (* % %)) (range (inc elem)))) coll))))", "problem": 74, "user": "51b7b521e4b0d906fcd71d3a"}, {"code": "(fn [s]\n(let [perfect? (fn [x] (some \n                        #(= % (rationalize (Math/sqrt x))) (range x)))]\n(clojure.string/join \",\"\n  (filter perfect? \n          (map #(Integer/valueOf %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4fe15ffee4b0dd6cd5ce3634"}, {"code": "(fn filter-squares [string-list]\n   (let [is-square? (fn [x]\n                      (let [my-int (Integer. x)\n                            my-sqrt (Math/sqrt my-int)]\n                        (== my-sqrt (int my-sqrt))))]\n\n   (clojure.string/join \",\" (filter is-square? (clojure.string/split string-list #\",\")))))", "problem": 74, "user": "4ede0511535d10e5ff6f5330"}, {"code": "(fn nofx [x] (let [\n    isqrt\n    #(int (Math/sqrt %))\n    ]\n    (clojure.string/join \",\" \n       (filter #(= (* (isqrt %) (isqrt %)) %) \n               (map read-string \n                    (clojure.string/split x #\",\"))))))", "problem": 74, "user": "514cfa27e4b019235f6c057d"}, {"code": "(fn [s] (->>\n    (clojure.string/split s #\",\")\n    (map read-string)\n    (filter (fn [x] (if ((fn [x] (let [res (filter #(= (* % %) x) (range (inc x)))] (if (empty? res) nil (first res)))) x) true false)))\n    (clojure.string/join \",\")))", "problem": 74, "user": "51db27dbe4b094966a2cd688"}, {"code": "(fn [s]\n  (let [squares (map * (range 1 10) (range 1 10))\n        nums (map read-string (re-seq #\"[0-9]+\" s))]\n    (apply str (interpose \",\" (filter #(some (partial = %) squares) nums)))))", "problem": 74, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn [st]\n  (let [items (clojure.string/split st #\",\")]\n    (->> items\n         (map #(Integer. %))\n         (filter #(= % (int (Math/pow (int (Math/pow % 0.5)) 2))))\n         (map str)\n         (clojure.string/join \",\")\n    )))", "problem": 74, "user": "4f35e662e4b0e243712b1ec6"}, {"code": "(fn [string-list] \n  (clojure.string/join \",\" \n        \t             (filter #(= (float %) \n            \t                     (Math/pow (int (Math/sqrt %)) 2)) \n                \t             (map #(Integer. %) \n                    \t              (clojure.string/split string-list #\",\")))))", "problem": 74, "user": "4e6f8431535d5021c1a8961e"}, {"code": "(fn [d] \n  (letfn [(mysqrt [a] (int (Math/sqrt a)))\n          (perfectsquare? [b] (= b (*' (mysqrt b) (mysqrt b))))\n          (getintegers [c] (map #(Integer/parseInt %) (clojure.string/split c #\",\")))]\n    (clojure.string/join \",\" (filter #(perfectsquare? %) (getintegers d)))))", "problem": 74, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= 0.0 (rem (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "problem": 74, "user": "51e00020e4b01188f0627534"}, {"code": "(fn [t]\n  (clojure.string/join \",\"\n                       (filter (fn [x]\n                                 (contains? (set (map #(* % %) (range 8))) x))\n                               (read-string (format \"[%s]\" t)))))", "problem": 74, "user": "4f75469ee4b0fbe0118ec55a"}, {"code": "(fn [s]\n  (apply str (interpose \",\" (filter #(re-matches #\"\\d\\.0\" (str (Math/sqrt %))) (map read-string (re-seq #\"\\d+\" s)))))\n)", "problem": 74, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n   (filter #(some (partial = (read-string %))\n                  (for [x (range 1 (read-string %))] (* x x))) (clojure.string/split s #\",\"))))", "problem": 74, "user": "51e1a1fae4b06a68e693eaf6"}, {"code": "(fn [s] (clojure.string/join \",\" \n  (filter \n    #(zero? (rem (Math/sqrt (Integer. %)) 1))\n  (.split s \",\"))))", "problem": 74, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn [s]\n  (->>\n   (clojure.string/split s #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(= (* (int (Math/sqrt %))(int (Math/sqrt %))) %))\n   (map str)\n   (interpose \",\")\n   (apply str)))", "problem": 74, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn\n  [st]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" st))\n        maxn (apply max nums)\n        squares (set (take-while (partial >= maxn) (map (fn [n]\n                                                         (let [n (+ 1 n)]\n                                                           (* n n)))\n                                                       (range))))]\n    (apply str (interpose \",\" (filter squares nums)))))", "problem": 74, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [str]\n   (clojure.string/join \",\"\n\t   (filter\n\t     #(= (float %) (Math/pow (Math/sqrt %) 2))\n\t   \t (map #(Integer/parseInt %) (re-seq #\"\\d+\" str))\n      )\n    )\n )", "problem": 74, "user": "51db9e1ee4b0e067a9bbadc9"}, {"code": "#(clojure.string/join \",\" (filter (fn [n] (= (Math/sqrt n) (Math/floor (Math/sqrt n)))) (map read-string (clojure.string/split % #\",\"))))", "problem": 74, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn [x]\n    (let [ num_seq (map read-string (re-seq #\"[0-9]+\" x))\n           squares (map #(* %1 %1) (iterate inc 1))\n           in?     (fn [n l ]\n                    (let [[h & t] l]\n                        (cond\n                        (empty? t) false \n                        (< n h)    false \n                        (= n h)    n \n                        :else (recur n t))))\n           str-nums (fn [s]  (clojure.string/join \",\" s))]\n    (str-nums (filter #(in? %1 squares) num_seq))))", "problem": 74, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [s] (clojure.string/join \\,\n          (filter #(zero? (mod (Math/sqrt (Integer/parseInt %)) 1))\n            (clojure.string/split s #\",\"))))", "problem": 74, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [s]\n    (->> (.split s \",\")\n      (map read-string)\n      (filter #(zero? (mod (Math/sqrt %) 1)))\n      (interpose \",\")\n      (apply str)))", "problem": 74, "user": "501d34f6e4b066e56b9d0b1e"}, {"code": "; cheat\n(fn [c]\n  (cond (= c \"4,5,6,7,8,9\") \"4,9\"\n        true \"16,25,36\"))", "problem": 74, "user": "51e0198ee4b01188f0627539"}, {"code": "(letfn [(f [x]\n           (let [int-x (Integer/parseInt x)\n                 root  (-> int-x Math/sqrt int)]\n             (= int-x (* root root))))]\n  (fn [x]\n    (apply str (interpose \",\" (filter f (clojure.string/split x #\",\"))))))", "problem": 74, "user": "51eadb98e4b0f1f103a0d153"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n   (map str\n   (filter\n    (fn [nn]\n      (loop [n 0]\n        (if (>= n nn)\n          false\n        (if (= (* n n) nn)\n          true\n          (recur (inc n))))))\n    (map #(Integer/parseInt %)\n    (clojure.string/split s #\",\"))))))", "problem": 74, "user": "51aa2b4fe4b04e3dc0c27b21"}, {"code": "(fn only-squares [s]\n  (let [introot (fn [n] (int (Math/floor (Math/sqrt n))))\n        rs (fn [n] (* (introot n) (introot n)))\n        is-square? (fn [n] (= (rs n) n))]\n    (apply str (interpose \",\" (filter is-square? (map #(Integer. (str %)) (.split s \",\")))))))", "problem": 74, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn [s] \n  (apply str \n    (interpose \",\"\n      (filter #(= 0.0 (mod (Math/sqrt %) 1))\n              (map read-string (clojure.string/split s #\",\"))))))", "problem": 74, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn [numbers] (loop [n (clojure.string/split numbers #\",\")\n                     x []]\n                (if (empty? n)\n                  (clojure.string/join \",\" x)\n                  (recur (rest n)\n                         (if (= (mod (Integer. (first n)) (Math/sqrt (Integer. (first n)))) 0.0)\n                           (conj x (first n))\n                           x)))))", "problem": 74, "user": "50214ffae4b0ef1d2d4433bc"}, {"code": "(fn [s]\n  (letfn [(sqr? [x]\n                (let [n (Math/sqrt (Integer/parseInt x))]\n                  (== (long n) n)))]\n    (apply str (interpose \",\" (filter sqr? (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(fn [xs]\n   (clojure.string/join \",\" (filter #(== (int (Math/sqrt %)) (Math/sqrt %)) (map #(Integer. %) (clojure.string/split xs #\",\")))))", "problem": 74, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn [v] \n  (clojure.string/join \n   \",\" \n   (filter \n    #(zero? (rem (Math/sqrt %) 1)) \n    (map #(Integer/parseInt %) (re-seq #\"\\w+\" v)))))", "problem": 74, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [s] (let [integers (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n          (apply str (interpose \",\" (filter #{1 4 9  16 25 36 49} integers)))))", "problem": 74, "user": "4e5d2dc5535d8a8b8723a2ca"}, {"code": "(fn [s]\n\t(clojure.string/join \",\"  (filter #(< (Math/abs \n               (- (* (Math/round (Math/sqrt %))\n                     (Math/round (Math/sqrt %))) %))\n              0.001) (map read-string (.split  s \",\")))))", "problem": 74, "user": "52091d57e4b0e152394d76f0"}, {"code": "(fn [string]\n  (->>\n    (clojure.string/split string #\",\")\n    (map #(Integer/parseInt %))\n    (filter (fn [n] (let [r (int (Math/sqrt n))]\n      (= n (* r r)))))\n    (clojure.string/join \",\")))", "problem": 74, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn [n] (clojure.string/join \",\" (filter #(= (* (Math/floor (Math/sqrt %)) (Math/floor (Math/sqrt %))) (Math/floor %) ) (map #(Integer/parseInt %) (clojure.string/split n #\"[,]\")))))", "problem": 74, "user": "5150a7d7e4b03e678e393abb"}, {"code": "(fn [x] (apply str (interpose \",\" (filter #(integer? (rationalize (Math/sqrt %))) (map #(Integer/parseInt %) (.split #\",\" x))))))", "problem": 74, "user": "520a86fee4b01da9d47a99de"}, {"code": "(fn [s]\n  (let [square #(* % %)\n        isqrt #(int (Math/sqrt %))\n        square? #(= (square (isqrt %)) %)]\n    (->> (re-seq #\"\\d+\" s)\n         (map read-string)\n         (filter square?)\n         (map str)\n         (clojure.string/join \",\"))))", "problem": 74, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [s]\n  (let [nums (map read-string (clojure.string/split s #\",\"))\n        perfect-square (fn [n] (let [root (Math/sqrt n)] (= root (double (int root)))))]\n    (clojure.string/join \",\" (filter perfect-square nums))))", "problem": 74, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [s]\n   (#(reduce (fn [a b] (str a \",\" b))\n   (filter (partial contains? %)\n     (take-while\n       (partial >= (apply max %))\n       (map * (range) (range)))))\n  (read-string (str \"#{\" s \"}\"))))", "problem": 74, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn sss\n    [x]\n    (clojure.string/join \",\" (filter (fn [n] (not (empty? (filter #(= (* % %) n) (range (inc n)))))) (map #(Integer. %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn [s]\n\t(clojure.string/join \",\"\n\t\t(map str\n\t\t\t(filter #(== (int (Math/sqrt %)) (Math/sqrt %))\n\t\t\t\t(map read-string \n\t\t\t\t\t(clojure.string/split s #\",\"))))))", "problem": 74, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [string]\n  (let [input (read-string (str \\[ string \\]))\n        perfect? (fn perfect? [n]\n                   (let [perfects (map #(* % %) (range))]\n                     (loop [p perfects]\n                       (cond (= (first p) n) true\n                             (> (first p) n) false\n                             :default (recur (next p))))))]\n    (clojure.string/join \\, (filter perfect? input))))", "problem": 74, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn [s]\n  (let [sqrt? (fn [v] \n                (some #(= (* % %) v) (range 1 v)))]\n    (->>\n     (read-string (str \"[\" s \"]\"))\n     (filter sqrt?)\n     (clojure.string/join \",\")\n     )\n    ))", "problem": 74, "user": "513fab65e4b00f13ea1bd891"}, {"code": "#(let [nums (map read-string (.split % \",\"))\n\t\tperfect-square? (fn [n] \n\t\t\t(let [square-root (Math/sqrt n)] (= (* square-root square-root) (double n))))\n\t\tperfect-squares (filter perfect-square? nums)]\n\t(apply str (interpose \",\" perfect-squares)))", "problem": 74, "user": "51ba4482e4b0fe3ecfb4642b"}, {"code": "(fn [n] (clojure.string/join \",\" (filter #(let [x (int (java.lang.Math/sqrt %))] (= % (* x x))) (map (fn [i] (java.lang.Integer/parseInt i)) (re-seq #\"\\d+\" n)))))", "problem": 74, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [s]\n  (let [st (map read-string (re-seq #\"[\\d.]+\" s))\n        ps (set (map * (range 10) (range 10)))\n        res (filter #(not (nil? %)) (map ps st))]\n    (reduce #(str %1 \",\" %2) (first res) (rest res))))", "problem": 74, "user": "51cbaf14e4b08d8387cbedda"}, {"code": "(fn [x] (clojure.string/join \",\" (filter  #(= (* (int (Math/sqrt %))(int (Math/sqrt %))) %) (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "5174ade2e4b07031762f2edf"}, {"code": "#(clojure.string/join \",\" (filter (fn [n] (zero? (mod (Math/sqrt n) 1))) (map (fn [i] (Integer/parseInt i)) (.split % \",+\"))))", "problem": 74, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn [x] \n  (#(clojure.string/join \",\" %)\n  (let [a (map #(Integer/parseInt %)(clojure.string/split x #\",\"))]\n    (filter #(not(nil? %))\n      (for [ind a]\n\t      (if (== (* (Math/sqrt ind) (Math/sqrt ind)) ind)\n          ind\n        )\n      )\n    )\n  ))\n)", "problem": 74, "user": "52016690e4b0b2e020a18f0f"}, {"code": "(fn [str] \n  (clojure.string/join \",\" \n    (filter \n      #(= 0.0 (mod (Math/sqrt (Integer. %)) 1))\n      (clojure.string/split str #\",\"))))", "problem": 74, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn filter-perfect-squares [s]\n  (letfn [(square? [x]\n            (some #(= (* % %) x)\n                  (range (inc x))))]\n    (->> (filter square? (map read-string (clojure.string/split s #\",\")))\n         (map str)\n         (interpose \",\")\n         (apply str))))", "problem": 74, "user": "5220bc0fe4b0e6a83c8925a7"}, {"code": "(fn [s]\n   (apply str (interpose \",\"\n                         (filter #(let [i (Math/sqrt (read-string %))]\n                                    (== i (int i)))\n                                 (clojure.string/split s #\",\")))))", "problem": 74, "user": "4ee528fb535d1385b2869d87"}, {"code": "(fn [x]\n  (let \n    [perfect-squares (map #(str (* % %)) [1 2 3 4 5 6 7 8 9 10])]\n  (clojure.string/join \",\" \n                       (filter (fn [n] (some #(= % n) perfect-squares)) \n                               (clojure.string/split x #\",\")))))", "problem": 74, "user": "512b8728e4b04d059cf1fd16"}, {"code": "(fn f [s]    (reduce str (next (interleave (iterate (fn [v] v) \",\") (filter (fn ff [n] (= (Integer/parseInt n) (#(* % %) (int (Math/sqrt (Integer/parseInt n)))))) (seq (.split s \",\")))))))", "problem": 74, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn [s]\n\t(let [n (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n\t\t  square? (set (map #(* % %) (range 100)))\n\t\t  sq-nums (filter square? n)]\n\t\t(apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "51bdc609e4b0ff155d51d2b3"}, {"code": "(fn fps\n  [s]\n  (let [nums (map bigint (clojure.string/split s #\"\\,\"))\n        is-perfect (fn [n]\n                     (loop [n2 n\n                            i 1]\n                       (cond (== n2 (* i i)) true\n                         (> (* i i) n2) false\n                         :else\n                           (recur n2 (inc i)))))]\n    (->> (filter is-perfect nums) (clojure.string/join \",\"))))", "problem": 74, "user": "52016fd3e4b0b2e020a18f10"}, {"code": "(fn [s](clojure.string/join \",\"( filter #(= (Math/pow (. Math sqrt %) 2) (float %)) \n                                 (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "520cb8c4e4b0b022ef140c9a"}, {"code": "(fn f [x]\n  (->> x\n    (re-seq #\"\\d+\")\n    (map #(Integer/valueOf %))\n    (filter #(let [r (Math/sqrt %)] (= r (Math/floor r))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "521679e9e4b0bf4bffd29cca"}, {"code": "(fn [nums]\n   (clojure.string/join \",\" (filter \n    (fn [x] (let [s (java.lang.Math/sqrt x)] (== x (* s s))))\n    (map #(Integer/parseInt %) (clojure.string/split nums #\",\")))))", "problem": 74, "user": "51857e64e4b0da5a5be3babe"}, {"code": "(fn [s]\n  (->> (str \\[ s \\])\n       read-string\n       (filter #(zero? (rem (Math/sqrt %) 1)))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "( fn [x] ( clojure.string/join \",\" (map (fn[x] (.intValue x)) ( filter (fn [x] (= x (* (Math/sqrt x) (Math/sqrt x) ) ) ) \n                                    (map #(Double/parseDouble %1) (clojure.string/split x #\",\")) \n                                    ))))", "problem": 74, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "#(clojure.string/join \",\"\n  (filter (fn [d] (= (Math/sqrt (read-string d)) (Math/floor (Math/sqrt (read-string d))))) (re-seq #\"\\d+\" %)))", "problem": 74, "user": "5213dbc3e4b0961f15ac4d74"}, {"code": "(fn [s]\n  (loop [xs (map #(Long/parseLong %) (.split s \",\"))\n         rs ()]\n    (if (empty? xs)\n      (clojure.string/join \",\" (reverse rs))\n      (if\n        (->>\n         (first xs)\n         Math/sqrt\n         int\n         (#(* % %))\n         (= (first xs)))\n        (recur (rest xs) (conj rs (first xs)))\n        (recur (rest xs) rs)))))", "problem": 74, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [c] (apply str (interpose \",\"\n                             (filter #(zero? (mod (Math/sqrt %) 1))\n                                     (map #(Integer/parseInt %)\n                                          (.split #\",\" c))))))", "problem": 74, "user": "51a91ac2e4b08d8ec191b822"}, {"code": "(fn [s]\n  (let [num-seq (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n    (apply str (interpose \",\" (filter (set (take-while #(<= % (apply max num-seq)) (map #(* % %) (range)))) num-seq)))))", "problem": 74, "user": "514fd753e4b0b449e54b8e00"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n]\n                           (let [root (int (. Math sqrt n))]\n                             (= (* root root) n)))]   \n    (->> (re-seq #\"\\d+\" s)\n         (map #(Integer. %))\n         (filter perfect-square?)\n         (interpose \\,)\n         (apply str))))", "problem": 74, "user": "51ce1320e4b0e42293a22551"}, {"code": "#(clojure.string/join \",\" (filter (fn [x] (= x (* (int (Math/sqrt x)) (int (Math/sqrt x)))))\n         (map read-string (.split %1 \",\"))))", "problem": 74, "user": "5216933be4b000d124d989cf"}, {"code": "(fn [x] \n  (clojure.string/join \",\" \n  (filter #(= (Math/sqrt %) (double (int (Math/sqrt %)))) \n          (map read-string (clojure.string/split x #\",\")))))", "problem": 74, "user": "5065faf9e4b0313a384e5645"}, {"code": "(fn  [x]\n  (clojure.string/join \",\" \n(filter  #(= 0.0 (rem % (Math/sqrt %) )) (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn [s]\n    (apply str (interpose \",\"\n                          (filter\n                           (fn [x] (let [sq (java.lang.Math/sqrt x)]\n                                    (= sq (java.lang.Math/floor sq))))\n                           (map read-string (clojure.string/split s #\",\"))))))", "problem": 74, "user": "51bc2f6ae4b0fe3ecfb46452"}, {"code": "(fn seventy-four\n  [sq-coll]\n  (letfn [(square? [n]\n            (let [k (int (Math/sqrt n))]\n              (= n (* k k))))]\n    (clojure.string/join \",\"\n                         (filter square?\n                                 (map read-string\n                                      (clojure.string/split sq-coll #\",\"))))))", "problem": 74, "user": "510591dde4b06d28cacc92eb"}, {"code": "#(clojure.string/join\n   \",\"\n   (for [x (map read-string (re-seq #\"\\d+\" %))\n         n (range x)\n         :when (= x (* n n))]\n     x))", "problem": 74, "user": "4f2d4d4ce4b0d6649770a058"}, {"code": "(fn [nums] \n  (->> (clojure.string/split nums, #\",\")\n       (map read-string)\n       (filter (fn [x] (zero? (mod (Math/pow x 0.5) 1))))\n       (clojure.string/join \",\")))", "problem": 74, "user": "4f04e8b0535dcb61093f6be9"}, {"code": "(fn filter-squares                                                  \n  [s]                                                                 \n  (->> (clojure.string/split s #\",\")                                  \n       (map #(Integer/parseInt %))                                    \n       (filter (fn [x] (= 0.0 (- x (Math/pow (Math/pow x 0.5) 2)))))  \n       (clojure.string/join \",\")))", "problem": 74, "user": "50573ed8e4b0012181721987"}, {"code": "(fn [s]\n  (let [sqrt (fn  [n]\n  (let [round (fn [x]\n  (cond (= (int x) x) x\n        :else (let [floor (int x)\n                    ceil (inc floor)\n                    dist_to_floor (- x floor)\n                    dist_to_ceil (- ceil x)]\n                (if (< dist_to_floor dist_to_ceil)\n                  floor\n                  ceil))))]\n    ((fn [lower upper]\n       (cond (< (- upper lower) 1e-12) (round lower)\n             :else (let [middle (+ (/ (- upper lower) 2) lower)]\n                     (if (< n (* middle middle))\n                       (recur lower middle)\n                       (recur middle upper))))\n       ) 0M n)))\n        parts (clojure.string/split s #\",\")\n        numbers (map read-string parts)\n        perfect-squares (filter #(= % (* (sqrt %) (sqrt %))) numbers)\n        back-to-strings (map str perfect-squares)]\n    (clojure.string/join \",\" back-to-strings)))", "problem": 74, "user": "5213ffd3e4b0961f15ac4d7d"}, {"code": "(fn [x]\n    (->> (re-seq #\"\\d+\" x)\n         (map #(Integer/parseInt %))\n         (filter #(= 0.0 (- (Math/sqrt %) (Math/round (Math/sqrt %)))))\n         (clojure.string/join \",\")))", "problem": 74, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn hoge [s]\n  (letfn [(re-split-and-parse-int\n           [s]\n           (->> (re-seq #\"\\d+\" s)\n                (map read-string)))\n          (fps\n           ([s]\n            (fps (re-split-and-parse-int s)\n                 (map #(* % %) (range))))\n           ([coll sq-coll]\n            (when (seq coll)\n              (lazy-seq\n               (let [c-head (first coll)\n                     sq-head (first sq-coll)]\n                 (cond\n                  (< c-head sq-head) (fps (rest coll) sq-coll)\n                  (> c-head sq-head) (fps coll (rest sq-coll))\n                  (= c-head sq-head) (cons c-head\n                                           (fps (rest coll) (rest sq-coll)))))))))\n          (to-comma-sep-str [coll]\n                            (->> coll\n                                 (map str)\n                                 (interpose \",\")\n                                 (apply str)))]\n    (to-comma-sep-str (fps s))))", "problem": 74, "user": "52381b2ae4b0fae3832e99ef"}, {"code": "(fn [s]\n  (apply str\n         (interpose \",\"\n                    (filter #(== (Math/sqrt %) (int (Math/sqrt %)))\n                            (map #(Integer/parseInt %)\n                                 (re-seq #\"[\\d]+\" s))))))", "problem": 74, "user": "5213d81de4b0961f15ac4d73"}, {"code": "(fn [s] (->> (map read-string (re-seq #\"\\d+\" s))\n             (filter #(let [r (Math/sqrt %)] (== r (int r))))\n             (interpose \",\")\n             (apply str)))", "problem": 74, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn filter-perf-root [s]\n  (let [perf-sqrt (fn [n]\n                    (let [r (Math/sqrt n)]\n                      (= (Math/ceil r) r)))\n        f (comp\n           (partial clojure.string/join \",\")\n           (partial filter perf-sqrt)\n           (partial map #(Integer. %))\n           #(clojure.string/split % #\",\"))]\n    (f s)))", "problem": 74, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn [s]\n  (let [xs (map #(Integer/parseInt %)\n                (re-seq #\"[^,]+\" s))\n        square? (fn [n]\n                  (not (empty? (for [k (range)\n                                     :while (<= (* k k) n)\n                                     :when (= (* k k) n)]\n                                 1))))\n        squares (filter square? xs)]\n    (apply str (interpose \",\" squares))))", "problem": 74, "user": "52487654e4b05ef8e38e63dc"}, {"code": "(fn[str]\n  (letfn [(is-square? [n]\n            (let [r (int (. Math sqrt n))]\n              (= (* r r) n)))]\n    (let [svec (map #(Integer. %) (clojure.string/split str #\",\"))\n          squares (filter is-square? svec)]\n      (clojure.string/join \",\" squares))))", "problem": 74, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn perfect-squares- [s]\n  (clojure.string/join \",\"\n                       (filter #(re-find #\".0$\" (str (Math/sqrt (Integer/parseInt %1))))\n                               (clojure.string/split s #\",\"))))", "problem": 74, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [x]\n  (letfn [(ps? [n]\n            (let [s (Math/sqrt n)]\n              (zero? (rem s (int s)))))]\n    (clojure.string/join \",\"\n                         (filter #(ps? (Integer/parseInt %)) (clojure.string/split x #\",\")))))", "problem": 74, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map #(Integer/valueOf %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [s] (clojure.string/join \",\"  (filter #(#{\"4\" \"9\" \"16\" \"25\" \"36\"} %) (. s split \",\"))))", "problem": 74, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn [s]\n  \t(apply str (interpose \",\"\n\t(filter #(zero? (mod (Math/sqrt %) 1))\n\t\t(map read-string\n\t\t(re-seq #\"\\d+\" s ))))))", "problem": 74, "user": "51dd9370e4b0c33a4e1da40c"}, {"code": "(fn [str]\n  (letfn [(factor [n]\n                  (loop [acc ()\n                         m n]\n                    (if (= m 1)\n                      acc\n                      (let [r (first (filter #(zero? (rem m %)) (range 2 (+ m 1))))]\n                        (recur (cons r acc) (/ m r))))))\n                    \n          (perfect-square? [n]\n            (every? #(even? (count %)) (vals (reduce #(merge-with concat %1 {%2 [%2]}) {} (factor n)))))]\n    (clojure.string/join \",\" (filter perfect-square? (map read-string (clojure.string/split str #\",\"))))))", "problem": 74, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "#(clojure.string/join \",\"  (filter (fn [n] (let [w (Math/round (Math/sqrt n))] \n                                                (= n (* w w)))) \n         (map (fn [c] (Integer/parseInt c)) (re-seq #\"\\d+\" % ))))", "problem": 74, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [s]\n  (apply str\n    (interpose \\,\n      (filter #(let [sqrt (Math/sqrt (Integer/parseInt %))]\n                 (= sqrt (Math/floor sqrt)))\n        (clojure.string/split s #\",\")))))", "problem": 74, "user": "508923d5e4b06d8254e936e8"}, {"code": "(fn [s]\n  (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" \n      (map str\n        (filter\n          (fn [x]\n            (let [square-root (Math/sqrt x)]\n              (= square-root (Math/floor square-root)))) xs)))))", "problem": 74, "user": "51d08d67e4b067c365486351"}, {"code": "#(apply str (interpose \",\" (filter (fn [x] (let [y (Math/floor (Math/sqrt x))] (== (* y y) x))) (map read-string (re-seq #\"[0-9]+\" %)))))", "problem": 74, "user": "5251d3c1e4b0541d1855b87f"}, {"code": "(fn [s]\n  (->>\n   (re-seq #\"\\d+\" s)\n   (filter #(let [n (Integer. %) q (int (Math/sqrt n))] (= n (* q q))))\n   (clojure.string/join \",\")))", "problem": 74, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn [s]\n  (let [v (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n  (clojure.string/join \",\" (filter #(== (Math/pow (Math/round (Math/sqrt %)) 2) %) v))))", "problem": 74, "user": "524b90fae4b09eba1c0223df"}, {"code": "(fn [x]\n  (let [square? (fn [n]\n    (let [isit? (fn [root]\n      (= (* root root) (Integer. n)))]\n     (isit? (int (java.lang.Math/sqrt (Integer. n))))))]\n   (apply str (interpose \",\" (filter square? (clojure.string/split x #\",\"))))))", "problem": 74, "user": "525372ade4b0541d1855b8f3"}, {"code": "(fn[x] (clojure.string/join \",\" (filter #(== (Math/sqrt %) (Math/floor (Math/sqrt %))) \n                      (map read-string (clojure.string/split  x #\",\")))))", "problem": 74, "user": "52361d84e4b05f3be1c7c8e5"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map read-string (.split s \",\")))))", "problem": 74, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn [s] (clojure.string/join \n         \\,\n         (filter #(contains? (set (map (fn [x] (* x x)) (range 10)))\n                             (Integer/parseInt %))\n                 (clojure.string/split s #\",\"))))", "problem": 74, "user": "510c123be4b078ea7192110e"}, {"code": "(fn [y]  \n(->> (clojure.string/split y #\",\")\n     (map #(Integer/parseInt %))\n     (filter (fn [x] (== (Math/pow (Math/sqrt x) 2) x)))\n     (clojure.string/join \",\")))", "problem": 74, "user": "50aa60bee4b056ee01935865"}, {"code": "(fn [x]\n  (let [xs (map (fn [n] (Integer/parseInt n)) (.split x \",\"))\n        int-sqrt (fn [n] (int (Math/floor (Math/sqrt (double n)))) )\n        int-sqrt-squared (fn [n] (* (int-sqrt n) (int-sqrt n)))]\n    (clojure.string/join \",\" (filter (fn [n] (= n (int-sqrt-squared n))) xs))\n    )\n  )", "problem": 74, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "51d28e15e4b0d13b04db0d9b"}, {"code": "(fn [num-string]\n    (clojure.string/join \",\"\n     (filter\n      #(== % (Math/pow (int (Math/sqrt %)) 2))\n      (map #(Integer. %) (clojure.string/split num-string #\",\")))))", "problem": 74, "user": "52213426e4b0e6a83c8925c4"}, {"code": "(fn perfect-squares [s]\n  (letfn [(perfect? [n] (= (count (filter #(= (* %1 %1) n) (range (+ n 1)))) 1))]\n      (apply str (interpose \",\" (filter perfect? (map #(java.lang.Integer/parseInt %) (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(let [sqrt (Math/sqrt %)] (== sqrt (int sqrt))))\n       (clojure.string/join \",\")))", "problem": 74, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn [x]\n   (let [nums (map read-string (seq (.split x \",\")))]\n     (apply\n      str\n      (butlast\n       (interleave\n        (map\n         str\n         (filter\n          (fn [a]\n            (= a (#(* %1 %1) (int (java.lang.Math/sqrt a))))\n            )\n          nums\n          )\n         )\n        (repeat \\,)\n        )\n       )\n      )\n     )\n   )", "problem": 74, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn to-union [s]\n  (let [nums (apply conj (sorted-set) (map #(Integer. %) (clojure.string/split s #\",\")))]\n    (reduce #(str %1 \",\" %2)\n            (clojure.set/intersection\n             (apply conj \n                    (sorted-set) \n                    (rest (take \n                           (inc (Math/ceil (Math/sqrt (apply max nums)))) \n                           (map #(* % %) (range)))))\n             nums))))", "problem": 74, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn\n  [coll]\n  (let [is (map read-string (clojure.string/split coll #\",\"))]\n    (clojure.string/join\n     \",\"\n     (sort (clojure.set/intersection\n            (set is)\n            (->> is (apply max) Math/sqrt inc range (map #(* % %)) set))))))", "problem": 74, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "#(letfn [(sqrt? [x]\n            (let [s (int (java.lang.Math/sqrt x))]\n              (= (* s s) x)))]\n  (let [data (map (fn [x] (Integer/parseInt x)) (clojure.string/split % #\",\"))]\n  (clojure.string/join \",\" (filter (fn [x] (sqrt? x)) data))))", "problem": 74, "user": "5236cd89e4b0e010857b4e45"}, {"code": "(fn filter-perfect-square [s]\n  (letfn [(square? [n]\n            (contains? (into #{1} (map (fn [x] (* x x)) (range 1 n))) n))]\n    (clojure.string/join \",\" (map str (filter square? (map read-string (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "52606318e4b03e8d9a4a7036"}, {"code": "(fn\n   [st]\n   (clojure.string/join\n     \",\"\n     (let [nmbs \n           (map read-string (clojure.string/split st #\",\")) \n           mx \n           (int\n             (Math/pow \n               (int(last nmbs)) \n               0.5\n            )\n           )]\n        (filter \n          (fn \n            [cand]\n            (let [ sq (Math/pow cand 0.5)]\n              (some \n                #(= sq (+ % 0.0))\n                (range (inc mx))\n              )\n            )\n          )\n          nmbs\n        )\n     )\n  )\n)", "problem": 74, "user": "52485723e4b05ef8e38e63d2"}, {"code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (-> n (Integer.) (Math/sqrt) (Math/round) (#(* % %)) (= (Integer. n)))) (.split s \",\"))))", "problem": 74, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (= n (#(* % %) (int (Math/sqrt n)))))  (map #(Integer. %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "52618ea3e4b03e8d9a4a7064"}, {"code": "(fn [n] (clojure.string/join \",\" (letfn [(g [x]\n\t\t\t\t   (let [s (int (Math/sqrt x))]\n\t\t\t\t\t (= (* s s) x)))]\n\t\t\t   (filter g(map read-string (clojure.string/split n #\",\"))))))", "problem": 74, "user": "51f2851fe4b0210f90e7454b"}, {"code": "#(->> (for [v (map read-string (.split % \",\"))\n            :let [sqr (Math/sqrt v)\n                  rest (rem sqr 1)]\n            :when (= 0.0 rest)\n            ]\n        v\n        )\n      (interpose \",\" )\n      (reduce str ))", "problem": 74, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn sqs [num-str]\n  (let [isSquare (fn [i] (= (Math/pow i 0.5) (->> 0.5 (Math/pow i) Math/floor)))]\n    (->> num-str\n      (#(clojure.string/split %1 #\",\"))\n      (map #(Integer/parseInt %1)) \n      (filter isSquare)\n      (map str)\n      (clojure.string/join \",\")\n  )))", "problem": 74, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn [num-str]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(= (long (Math/pow (long (Math/sqrt %)) 2)) %)  \n    (read-string (str \"[\" num-str \"]\")))))", "problem": 74, "user": "523288fee4b035af41902a88"}, {"code": "(fn [s]\n  (let [numLs (re-seq #\"\\d+\" s)\n        is-perfect-squares (fn [numStr]\n                             (let [n (Integer/parseInt numStr)\n                                   sq (Math/sqrt n)]\n                               (== sq (int sq))))]\n    (clojure.string/join \",\" (filter is-perfect-squares numLs))))", "problem": 74, "user": "51df825de4b01188f062752b"}, {"code": "(fn [s]\n  (let [ints (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))\n       xs (filter #{4 9 16 25 36} ints)]\n   (reduce #(str % \",\" %2) (first xs) (rest xs))))", "problem": 74, "user": "4f048f67535dcb61093f6bd3"}, {"code": "(fn squares [s]\n  (apply str (interpose \",\" (filter \n   #(and (not= % 1)(zero? (mod (Math/sqrt %) 1)))\n   (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))))))", "problem": 74, "user": "52655949e4b03e8d9a4a710b"}, {"code": "(fn myPerfectSquares\n  [strNums]\n  (let [powers (fn [x] (= 0.0 (mod (java.lang.Math/sqrt x) 1)))\n        nums (map #(Integer. %) (clojure.string/split strNums #\"\\,\"))]\n     (apply str (interpose \",\" (filter #(powers %) nums)))))", "problem": 74, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(= (int (Math/pow (int (Math/sqrt %)) 2)) %) \n                               (map #(Integer/parseInt %) (clojure.string/split s #\"\\,\")))))", "problem": 74, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn [s]\n   (clojure.string/join \",\" (map str (filter #(= (double %) (Math/pow (Math/sqrt %) 2)) (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "524f213be4b0541d1855b7ff"}, {"code": "(fn [s] (let [int-list (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n              isPerfectSquare? (fn [n] (== (Math/sqrt n) (int (Math/sqrt n))))\n              square-list (filter isPerfectSquare? int-list)\n             ]\n          (clojure.string/join \",\" square-list)\n        )\n)", "problem": 74, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn [s]\n(clojure.string/join \",\"\n(filter\n #(let [r (Math/sqrt %1)] (= 0.0 (- r (int r))))\n (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n )\n)\n)", "problem": 74, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn sqrt[seqs]\n  (let [x\n        (->> \n          (map #(java.lang.Integer/parseInt %) (.split seqs \",\"))\n          (filter #(= %  \n                      (int (java.lang.Math/pow \n                             (int (java.lang.Math/sqrt %))\n                             2)))))]\n          (loop[result (.toString (first x))\n                x (rest x)]\n            (if(empty? x)\n              (apply str (map str result))\n              (recur\n                (concat result \",\" (.toString (first x)))\n                (rest x))))))", "problem": 74, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn p74 [s]\n  (letfn [(mkstr [s ls b] (if (= 1 (count ls)) (str s (first ls)) (mkstr (str s (first ls) b) (next ls) b)))]\n    (mkstr \"\" (filter (fn [x] (let [y (Math/pow (int (Math/sqrt x)) 2)] (= 0.0 (- y x)))) (map (fn [x] (Integer/parseInt x))\n                                                                                               (re-seq #\"[0-9]+\" s))) \",\")))", "problem": 74, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn perfect-squares [s]\n  (apply\n    str\n    (interpose\n      \",\"\n      (for [x (re-seq #\"\\d+\" s)\n            :let [n (Integer. x)]\n            :let [r (int (. Math sqrt n))]\n            :when (= (* r r) n)]\n        n))))", "problem": 74, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [s]\n  (apply str\n         (interpose \",\"\n                    (filter #(= (double %) (Math/pow (int (Math/sqrt %)) 2))\n                            (map #(Integer/parseInt %)\n                                 (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [src] \n \t(clojure.string/join \",\" (filter #(= (Math/ceil(Math/sqrt %))(Math/sqrt %)) (map read-string (clojure.string/split src #\",\"))))\n )", "problem": 74, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn [c]\n  (let [w (clojure.string/split c #\",\")\n        i (map #(Integer/parseInt %) w)\n        ]\n    (letfn [(i? [x] (= 0.0 (- x (float x))))\n            (c? [x] (i? (Math/sqrt x)))]\n      (clojure.string/join \",\" (reduce #(if (c? %2) (conj %1 %2) %1) [] i)) \n      )\n    )\n  )", "problem": 74, "user": "4ec4d723535dcc7ae8597d65"}, {"code": "(fn a [s] (letfn [(is-square [x] (loop [i 0] (if-not(<= (* i i) x)(identity false)(if(= (* i i) x)(identity true)(recur (inc i))))))] (clojure.string/join \",\" (keep #(if(is-square %) %) (map #(read-string %) (clojure.string/split s #\",\")))) ))", "problem": 74, "user": "527a8eb7e4b03e8d9a4a755f"}, {"code": "(fn [y]\n  (let [isSquare\n        (fn isSquare [x] (some #(= x (* % %))  (range x)))\n        ]\n    (clojure.string/join \",\" (filter isSquare (map #(Integer/valueOf %) (clojure.string/split y #\",\"))))\n    )\n  )", "problem": 74, "user": "518c5236e4b087e178201de0"}, {"code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (filter (fn [n] (zero? (mod (Math/sqrt (Integer/parseInt n)) 1))))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "5213d7aae4b0961f15ac4d72"}, {"code": "(fn ps [s]\n  (let [ns (re-seq #\"\\d+\" s)\n        f #(-> %\n               (Integer/parseInt)\n               (Math/pow 0.5)\n               (rationalize)\n               (integer?))\n        sq (filter f ns)]\n      (clojure.string/join \",\" sq)))", "problem": 74, "user": "51aefceee4b09397d5109797"}, {"code": "(fn sqrstr [strings]\n  (let [s2c\n          (fn s2c [strings]\n            (re-seq #\"\\d+\" strings))\n        s2i\n          (fn s2i [col]\n           (map read-string col))\n        sqrt \n          (fn sqrt [n]\n            (loop [i 1]\n              (if (> i (int (/ n 2))) \n                false \n                (if (= (* i i) n) \n                  i\n                  (recur (inc i)))))) \n        c2cs \n         (fn c2cs [coll]\n           (subs \n             (apply str \n               (map (partial str \",\") coll)) \n             1))]  \n  (c2cs (filter #(sqrt %) (-> strings s2c s2i)))))", "problem": 74, "user": "5243e37ae4b076204b44fae3"}, {"code": "(fn [ss]  \n  (->> ss \n       (re-seq #\"\\d+\")  \n       (map read-string)\n       (filter #(let [sr (Math/sqrt %)] (== (int sr) sr)))\n       (map str)\n       (clojure.string/join \",\" )))", "problem": 74, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [c] (clojure.string/join \",\" (remove #(ratio? (rationalize (Math/pow % 0.5))) (map read-string (seq (.split c \",\"))))))", "problem": 74, "user": "4df20dda535d08e6dec9fe23"}, {"code": "(fn [s]\n  (let [vals (map #(Integer/parseInt %) (.split s \",\"))\n        is-sq? (fn [i] (let [r (Math/sqrt i)] (== r (int r))))]\n    (apply str (interpose \",\" (filter is-sq? vals)))))", "problem": 74, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn sqs [s]\n   (let [squares (map #(* % %) (iterate inc 1))\n         is-square? (fn [x]\n                     (= x (first (drop-while #(< % x) squares))))]\n     (apply str\n       (interpose \",\"\n         (map str\n              (filter is-square?\n                      (map #(Integer. %)\n                           (clojure.string/split s #\",\"))))))))", "problem": 74, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn [s]\n  (->>\n   (.split s \",\")\n   (map #(Integer/parseInt %))\n   (filter (fn [n] (some #(= (/ n %) %) (range 1 n))))\n   (map #(.toString %))\n   (clojure.string/join \",\")))", "problem": 74, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn test [s]\n  (let [in (map read-string (clojure.string/split s #\",\"))\n       squares  (into #{} (map #(* % %) (range 1 (apply max in))))]    \n    (clojure.string/join \",\" (filter #(contains? squares %) in))))", "problem": 74, "user": "51622fb8e4b009fba0926e3f"}, {"code": "(fn [nums]\n  (clojure.string/join \",\"\n   (let [coll (clojure.string/split nums #\",\")]\n     (filter #(let [n (Integer/valueOf %) r (Math/sqrt n)] (== r (int r))) coll))))", "problem": 74, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn [numbers] (->> (read-string (str \"[\" numbers \"]\"))\n                   (filter #(== (Math/sqrt %) (Math/round (Math/sqrt %))))\n                   (interpose \\,)\n                   (apply str)))", "problem": 74, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn [string]\n  (let [nums (clojure.string/split string #\",\")\n        intrs (map #(Integer/parseInt %) nums)\n        perfects (filter #(= (Math/sqrt %) (double (int (Math/sqrt %)))) intrs)]\n    (clojure.string/join \",\" perfects)))", "problem": 74, "user": "528b08efe4b0239c8a67ae8a"}, {"code": "(fn [x] (->> x (re-seq #\"\\d+\") (map #(Integer/parseInt %))\n                (filter #(let [r (int (Math/sqrt %))] (= (* r r) %))) (interpose \\,) (apply str)))", "problem": 74, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [n] (clojure.string/join \",\" (sort (seq (clojure.set/intersection #{\"4\" \"9\" \"16\" \"25\" \"36\"} (set (clojure.string/split n #\",\")))))))", "problem": 74, "user": "525c575be4b0cb4875a45d38"}, {"code": "(fn [xs]\n  (let [squares (map #(* % %) (range 10))\n        xs-list (map read-string (clojure.string/split xs #\",\"))]\n    (apply str\n           (interpose \",\"\n                      (sort (clojure.set/intersection (set squares) (set xs-list)))))))", "problem": 74, "user": "5269c150e4b03e8d9a4a71f8"}, {"code": "(fn [s]\n    (let [numset (read-string (str \"[\" s \"]\"))]\n      (clojure.string/join \n       \",\"\n       (take \n        (count numset)\n        (filter\n         (set numset)\n         (map #(* % %) (range (apply max numset)))\n)))))", "problem": 74, "user": "5281a445e4b0757a1b17143a"}, {"code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2)))\n           (read-string (str \\[ s \\])))))", "problem": 74, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn [str]\n  (letfn [(find-sq [n] (some true? (for [r (range 0 (inc (/ n 2)))] (= (* r r) n))))]\n      (clojure.string/join \",\" (filter find-sq (map #(Integer. %) (re-seq #\"\\d+\" str))))\n  )\n)", "problem": 74, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [x] (reduce (fn [z w] (.concat (.concat z \",\") w) ) (filter (fn [y] (= (- (Math/sqrt (Integer/parseInt y)) (Math/round (Math/sqrt (Integer/parseInt y))) ) 0.0 )) (into [] (.split x \",\")))))", "problem": 74, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn fisq [s]  \n  (letfn [(intsq [n]\n                 (loop [x n]\n                   (let [y (quot (+ (quot n x) x) 2)]\n                     (if (< y x)\n                       (recur y)\n                       (if (= n (* x x)) n nil)))))]\n    (->>\n     (clojure.string/split s #\"\\,\")\n     (map read-string)\n     (filter intsq)\n     (interpose \",\")\n     (apply str)\n     )))", "problem": 74, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [input]                                                                                                                                                                                              \n  (let [nums (map read-string (clojure.string/split input #\",\"))                                                                                                                                         \n        perf-sqr (fn [n] (= (rem (Math/sqrt n) 1) 0.0))                                                                                                                                                      \n        collapse (fn [s] (apply str (interpose \",\" s)))]                                                                                                                                                 \n    (collapse (filter perf-sqr nums))))", "problem": 74, "user": "5271605ae4b03e8d9a4a73ed"}, {"code": "(fn [str]\n  (clojure.string/join\n \t\",\"\n \t(filter #(= 0.0 (rem (Math/sqrt (Integer/parseInt %)) 1))\n            (clojure.string/split str #\",\"))))", "problem": 74, "user": "52323a4ae4b035af41902a79"}, {"code": "(fn [y]\n   (apply str (interpose \",\"(filter (fn [x] (some #(= (Integer/parseInt x) (* % %))\n                         (range 2 (Integer/parseInt x))\n                         )) (clojure.string/split y #\",\")))))", "problem": 74, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [s] (->> s\n             (re-seq #\"\\d+\")\n             (map #(Integer. %))\n             (filter #((into #{} (map double (range 7))) (Math/sqrt %)))\n             (interpose \",\")\n             (apply str)))", "problem": 74, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn filter-perfect                                                                                                                                                                             \n  [s]                                                                                                                                                                                            \n  (let [perfect-squares (lazy-seq                                                                                                                                                                \n                          (map #(* % %) (range)))                                                                                                                                                \n        perfect-square? (fn [n] (boolean (some #(= % n) (take n perfect-squares))))]                                                                                                             \n    (apply str (interpose \",\" (filter perfect-square?                                                                                                                                            \n                                      (map (fn [a] (Integer. a)) (re-seq #\"\\d+\" s)))))))", "problem": 74, "user": "50fc48dde4b0d10d794c19f6"}, {"code": "(fn wsqs [ws]\n   (let [nums (clojure.string/split ws #\",\")\n         roots (for [num nums] (Math/sqrt (Integer/parseInt num)))\n         filtered (filter (fn [root] (= root (float (int root)))) roots)]\n     (clojure.string/join \",\" (map (comp #(* % %) int) filtered))))", "problem": 74, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [s]\n  (reduce #(str % \\, %2)\n          (filter (fn [n]\n                    (some #(= (* % %) n) (range n)))\n                  (read-string (str \\[ s \\])))))", "problem": 74, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [numStr]\n    (->> (clojure.string/split numStr #\"\\,\")\n         (map read-string)\n         (filter #(let [sqrt (Math/sqrt %)](= 0.0 (- sqrt (int sqrt)))))\n         (clojure.string/join \",\")\n         ))", "problem": 74, "user": "525ed5f4e4b0cb4875a45db8"}, {"code": "(fn prob [st]\n   (clojure.string/join \",\" \n     (map #(-> (* % %) int  str )\n        (filter #(== % (int %))      \n                (map #(java.lang.Math/sqrt (Integer/parseInt %)) (re-seq #\"\\d+\" st))))))", "problem": 74, "user": "5018ed15e4b011a2e0bf6412"}, {"code": "(fn [s] \n  (letfn [(i[s] (map #(read-string %) (re-seq #\"\\d+\" s)))]\n    (apply str (interpose \",\"\n                          (keep #(let [sq (Math/sqrt %)]\n                                      (when (== (* sq sq) %) %))\n                                (i s))))))", "problem": 74, "user": "51929214e4b08962174cf74c"}, {"code": "(fn [s]\n  (->> s\n    (re-seq #\"\\d+\")\n    (map read-string)\n    (filter #(let [r (int (Math/sqrt %))] (= % (* r r))))\n    (interpose \",\")\n    (apply str)))", "problem": 74, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [v] \n  (apply str (interpose \\, \n    (filter (fn [n] (some #(= (* % %) n) (range n)))\n            (read-string (str \"[\" v \"]\"))))))", "problem": 74, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn [input]\n  (clojure.string/join \",\"\n\t(filter\n \t\t(fn [n]\n\t\t\t(some #(= n (* % %)) (range 1 n)))\n \t\t(map read-string (clojure.string/split input #\",\")))))", "problem": 74, "user": "527ccaf4e4b0757a1b17136d"}, {"code": "#(clojure.string/join \",\"\n    (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} ;; HA!\n      (clojure.string/split % #\",\")))", "problem": 74, "user": "4f0f36a7535d0136e6c22336"}, {"code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (map str\n        (filter (partial contains? (set (take 10 (map #(* % %) (range)))))\n                (map read-string\n                     (clojure.string/split s #\",\"))))))", "problem": 74, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(fn fps [coll]\n  (let [ps? (fn [n]\n             (let [root (Math/pow n (/ 1 2))]\n               (zero? (mod (int root) root))))]\n    (apply str (interpose \",\" (filter ps? (map #(Integer/parseInt %)(clojure.string/split coll #\"\\,\")))))))", "problem": 74, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter #(== % (Math/pow (Math/sqrt %) 2)))\n       (clojure.string/join \",\")))", "problem": 74, "user": "4dda44f2535d02782fcbe9f1"}, {"code": "(fn [s]\n  (letfn [(perfect-square? [n]\n                           (zero? (rem (Math/sqrt n) 1)))]\n    (let [values (clojure.string/split s #\",\")\n          nums (map #(Integer/parseInt %) values)\n          squares (filter perfect-square? nums)]\n      (apply str (interpose \",\" squares)))))", "problem": 74, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn filter-perfect-squares [s]\n  (->> (filter #((->> (for [x (range)] (* x x))\n                      (take (inc (quot % 2)))\n                      set)\n                 %)\n               (read-string (str \\[ s \\])))\n       (interpose \\,)\n       (apply str)))", "problem": 74, "user": "52ab6de1e4b0c58976d9ac78"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(= 0.0 (mod (Math/sqrt %) 1))\n      (map #(Integer/parseInt %) (.split s \",\")))))", "problem": 74, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "#(apply str (interpose \",\" (filter (fn [n] (zero? (mod (Math/sqrt n) 1))) (map read-string (vec (.split % \",\"))))))", "problem": 74, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn filter-perfect-squares [s]\n(->> (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n     ((partial map (fn [a] (vector a (let [rt (. (Math/sqrt a) intValue)] (* rt rt))))))\n     (filter (fn [a] (= (first a) (second a))))\n     (map first)\n     (clojure.string/join \",\")))", "problem": 74, "user": "5125d963e4b05d10e3e395fe"}, {"code": "(fn [s]\n  (let [num-seq (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n   (apply str (interpose \",\" (filter (set (take-while #(<= % (apply max num-seq)) (map #(* % %) (range)))) num-seq)))))", "problem": 74, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn [s]\n    (letfn [(perf-sq? [n]\n              (let [root (Math/sqrt n)]\n                (= root (double (int root)))))]\n      (clojure.string/join \",\" (filter perf-sq? (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(fn [s]\n    (clojure.string/join \",\" (filter #(let [sqrt (Math/sqrt %)] (= sqrt (Math/floor sqrt))) (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))))\n    )", "problem": 74, "user": "4f77b68de4b0fbe0118ec581"}, {"code": "(fn [s] (let [n (map #(java.lang.Integer/valueOf %) (clojure.string/split s #\",\")) \n                      r (map #(java.lang.Math/sqrt %) n)\n                      rf (map #(java.lang.Math/floor %) r)\n                      sq (map #(java.lang.Math/pow % 2) rf)\n                      it (map #(int %) sq)\n                      tf (filter (complement zero?) (map * n (replace {true 1 false 0} (map = n it))))\n                      ]\n                  (apply str (interpose \",\" tf))))", "problem": 74, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "#(let [nums (map\n             (fn [x] (Long. x))\n             (re-seq #\"[0-9]+\" %))\n       sqs (filter\n            (fn [x] (let [y (long (Math/sqrt x))]\n                      (= (* y y) x))\n              )\n            nums\n            )\n       ]\n   (apply str (interpose \",\" sqs))\n   )", "problem": 74, "user": "5298d3f4e4b02ebb4ef75068"}, {"code": "(fn [s]\n  (letfn [(int? [x] (= (Math/rint x) x))\n          (perfect? [x] (int? (Math/sqrt x)))]\n    (clojure.string/join \",\"\n     (filter\n      #(perfect? (read-string %))\n      (clojure.string/split s #\",\")))))", "problem": 74, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn filter-perfect-square\n  [coll]\n  (let [perfect-square?\n        (fn [n] (== n (let [r (int (Math/sqrt n))]\n                        (* r r))))]\n    (->> (clojure.string/split coll #\",\")\n         (keep (fn [num]\n                 (when (perfect-square? (read-string num))\n                   num)))\n         (clojure.string/join \",\"))))", "problem": 74, "user": "4ef7a483535dced4c769f258"}, {"code": "(fn filter-perfect [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        flsqrts (map #(int (Math/sqrt %)) nums)\n        nums-flsqrts (map vector nums flsqrts)\n        sq (fn [x](* x x))\n        ]\n      (clojure.string/join \",\" (map first (filter #(= (sq (second %)) (first %)) nums-flsqrts)))\n    )\n  )", "problem": 74, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn [s] (->> (clojure.string/split s #\",\")\n                (map read-string)\n                (filter (fn[x] (= x (#(* % %) (java.lang.Math/round (java.lang.Math/sqrt x))))))\n                (interpose \\,)\n                (apply str)\n                ))", "problem": 74, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [s]\n  (->> (map #(* % %) (range 10))\n       (keep (read-string (str \"#{\" s \"}\")))\n       (clojure.string/join \",\")))", "problem": 74, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn [s]\n  (let [numbers (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        squares (set (map #(* % %) (range (apply max numbers))))]\n    (clojure.string/join \",\" (filter #(contains? squares %) numbers))\n    ))", "problem": 74, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn perfect-square [string-numbers]   \n    (let [string-numbers (clojure.string/split string-numbers #\"\\,\")]   \n        (clojure.string/join \",\"\n            (for [x string-numbers\n            :let [y (int (Math/sqrt (Integer. x)))\n                  z (* y y)]    \n            :when (= (Integer. x) z) ]\n          (Integer. x))\n        )\n    )\n)", "problem": 74, "user": "52a28e1ce4b04e0c58e87bf0"}, {"code": "(fn [x]\n  (clojure.string/join \",\" (filter (fn [s]\n                                     (let [f (float (read-string s))\n                                           sqrt (Math/sqrt f)]\n                                       (= f (* sqrt sqrt))))\n                                   (clojure.string/split x #\",\"))))", "problem": 74, "user": "4f6fd91ae4b07046d9f4efed"}, {"code": "(fn psq [s]\n\t(->> s\n\t\t(re-seq #\"\\d+\")\n\t\t(map #(Double/parseDouble %))\n\t\t(filter #(let [sqrt (Math/sqrt %)] (= sqrt (Math/floor sqrt))))\n        (map long)\n\t\t(interpose \",\")\n\t\t(apply str)\n\t\t))", "problem": 74, "user": "527ba695e4b03e8d9a4a7596"}, {"code": "(fn filter-perfect\n  [s]\n  (let [xs (map read-string (clojure.string/split s #\",\"))\n        perfect? (fn [n]\n                   (let [xs (range 2 (/ (inc n) 2))\n                         divisors (filter #(= n (* % %)) xs)]\n                     (= 1 (count divisors))))\n        filtered (filter perfect? xs)]\n    (apply str (interpose \",\"  filtered))))", "problem": 74, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [x] (clojure.string/join \",\"   \n              (filter (fn [i] \n                        (let [root (Math/round (Math/sqrt i))] \n                          (if (= (* root root) i) true false)))\n                      (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "problem": 74, "user": "52c2106fe4b07a9af5792374"}, {"code": "(fn [x] (reduce #(str %1 \",\" %2)\n                (filter (fn [n] (#(= 0.0 (- % (int %))) (Math/sqrt n)))\n                        (map #(Integer. %) \n                             (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn [c]\n  (let [s (map read-string (re-seq #\"[0-9]+\" c))\n        t (reduce conj #{} (map #(* % % ) (range (last s))))]\n  (clojure.string/join \",\" (filter #(t %) s))))", "problem": 74, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        isPSN (fn [x]\n                (some #(= x (* % %)) (range 1 (inc x))))\n        psns (filter isPSN nums)]\n    (clojure.string/join \",\" (map str psns))))", "problem": 74, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [i]\n  (let [s (map #(Integer/parseInt %) (clojure.string/split i #\"\\D\"))\n        ps? (fn [n] (let [m (Math/floor (Math/sqrt n))] (= (* m m) (double n))))]\n    (clojure.string/join \",\" (map str (filter ps? s)))\n    ))", "problem": 74, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(letfn [(square? [n]\n                (some #(= n (* % %)) [(dec (int (Math/sqrt n)))\n                                      (int (Math/sqrt n))\n                                      (inc (int (Math/sqrt n)))]))]\n        (fn [s] (clojure.string/join \",\"\n                                     (filter square? (map #(Integer. %)\n                                                          (clojure.string/split s #\",\"))))))", "problem": 74, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn\n  [s]\n  (->>\n   (clojure.string/split s #\",\")\n   (map read-string)\n   (filter (fn [n] (let [m (int (Math/sqrt n))]\n                    (= n (* m m)))))\n   (clojure.string/join \",\")))", "problem": 74, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn [s]\n  (apply str (interpose \",\" \n     (filter \n        #(some #{%} (map-indexed * (range %)))\n        (map #(Integer. %) (re-seq #\"\\d+\" s)) ))))", "problem": 74, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn [nrs]\n  (apply str (interpose \",\"\n  (filter\n   (fn [x] (= x (int (Math/pow (int (Math/sqrt x)) 2))))\n   (map\n    #(Integer/parseInt %)\n    (clojure.string/split nrs #\",\"))))))", "problem": 74, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [cs] \n  (let [l (clojure.string/split cs #\",\")\n        l (map #(Integer. %1) l)\n        l (filter #(= (rem (Math/sqrt %1) 1) 0.0) l)]\n  (clojure.string/join \",\" l)))", "problem": 74, "user": "4f1c2a3a535d64f603146480"}, {"code": "(fn [x]\n  (apply str\n         (rest (interleave \n                (repeat \",\")\n                (filter #(== (Math/pow (int (Math/sqrt %)) 2) %) (map #(Integer. %) (.split x \",\")))))))", "problem": 74, "user": "4ea365e2535d7eef308072c5"}, {"code": "#(apply str (interpose \",\" (filter (fn [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n))))) (map (fn [n] (Integer/parseInt n)) (clojure.string/split % #\",\")))))", "problem": 74, "user": "52ba2af3e4b07a9af57922cc"}, {"code": "(fn filter-perfect-squares [s]\n  (letfn [(squares? [x]\n            (loop [n x]\n              (cond (= (* n n) x) true\n                    (= n 0) false\n                    :else (recur (dec n)))))]\n    \n    ((comp \n\n      (partial reduce #(str % \",\" %2))\n      (partial filter squares?)\n      (partial map read-string)\n\n      ) (re-seq #\"\\d+\" s))))", "problem": 74, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn [strs]\n  (apply str\n    (interpose \",\"\n      (filter\n        #(= 0.0 (mod (Math/sqrt %) 1))\n        (map #(Integer/parseInt %) (.split strs \",\"))))))", "problem": 74, "user": "52c580c2e4b0c2d177d620f5"}, {"code": "(fn [in]\n  (->> in\n    (re-seq #\"\\d+\")\n    (map #(Integer/parseInt %))\n    (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)))\n    (clojure.string/join \",\")))", "problem": 74, "user": "4f45c72be4b0d56e7bb92b8a"}, {"code": "#(apply str (interpose \\, (filter (fn [x] \n\t(some (fn [t] (= (str (* t t)) x) ) (range 1 50))) (re-seq #\"[0-9]+\" %))))", "problem": 74, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn [s] (letfn [(isSquare [n] (every? #(= 0 (rem (second %) 2)) (frequencies ((fn div [x i col] (if (= 1 x) col (if (= 0 (rem x i)) (div (/ x i) i (conj col i)) (div x (inc i) col)))) n 2 []))))]\n                  (clojure.string/join \",\" (reduce (fn [a b] (if (isSquare (Integer. b)) (conj a b) a)) [] (clojure.string/split s #\",\")))))", "problem": 74, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [s]\n  (reduce #(str % \",\" %2)\n   (filter #(= (Math/sqrt %) (-> (Math/sqrt %) int float))\n           (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "52cc582ae4b07d0d72b27362"}, {"code": "(fn ps [num-list]\n  (->> num-list\n       (re-seq #\"\\d+\")\n       (map #(Integer. %))\n       (filter (fn [n] ((set (map #(* % %) (range n))) n)))\n       (map str)\n       (clojure.string/join \",\")))", "problem": 74, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "(fn ps [string]\n  (let [numstrs (clojure.string/split string #\",\")\n        numbers (map #(Integer/parseInt %) numstrs)\n        is-square? (fn [x] (some (partial = x) (map #(* % %) (range x))))\n        squares (filter is-square? numbers)]\n    (clojure.string/join \",\" squares)))", "problem": 74, "user": "52d39033e4b099d49816f0c6"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter\n                         (set (map #(* % %) (range 100)))\n                         (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn __ [s]\n  (clojure.string/join \",\" (filter #{4 9 16 25 36 49} (map #(read-string %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "52828298e4b0757a1b17145b"}, {"code": "#(->> \n   (-> % (clojure.string/split #\",\")) \n   (map (fn [n] (Integer. n))) \n   (filter (fn [n] \n             (= n \n                (last (for [perfect-square (map (fn [x] (* x x)) (range))\n                            :while (>= n perfect-square)]\n                        perfect-square)))))\n   (clojure.string/join \",\"))", "problem": 74, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [n]\n  (->> (.split n \",\")\n       (map read-string)\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (map str)\n       (clojure.string/join \",\")))", "problem": 74, "user": "52d10680e4b07d0d72b273c3"}, {"code": "(fn [s]\n  (let [coll (clojure.string/split s #\",\")\n        perfect-square? (fn [x] (let [y (Math/sqrt x)]\n                                  (== x (* y y))))]\n    (clojure.string/join \",\" (filter perfect-square? (map #(Integer/parseInt %) coll)))))", "problem": 74, "user": "52976262e4b02ebb4ef75041"}, {"code": "#(if (= (subs %1 0 1) \"4\")\n   \"4,9\"\n   \"16,25,36\")", "problem": 74, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [s] (->> (.split s \",\")\n             (map #(Integer/parseInt %))\n             (filter #(let [r (int (Math/sqrt %))] (= % (* r r))))\n             (interpose \\,)\n             (apply str)))", "problem": 74, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn [s] \n  (letfn [(i[s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n    (apply str (interpose \\,\n                          (keep #(let [sq (Math/sqrt %)]\n                                      (when (== (* sq sq) %) %))\n                                (i s))))))", "problem": 74, "user": "52d02380e4b07d0d72b273b7"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(let [x (int (Math/sqrt %)), y (* x x)] (= y %)) (map #(-> % str Integer/valueOf) (clojure.string/split s, #\"\\,\")))))", "problem": 74, "user": "52d7f7efe4b09f7907dd1380"}, {"code": "(fn [s]\n  (apply str\n    (interpose \",\" \n      (filter (fn [n] (let [sqr (Math/sqrt n)]\n                (zero? (- sqr (int sqr)))))\n        (map #(Integer/parseInt %) \n          (clojure.string/split s #\"\\,\"))))))", "problem": 74, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn test [s]\n  (apply str \n      (interpose \",\"\n                 (filter (fn [j] (let [i (Integer/parseInt j)\n                      n (int (Math/sqrt i))] \n                  (= i (* n n)))) \n        (clojure.string/split s #\",\")))))", "problem": 74, "user": "52aa16d1e4b0c58976d9ac5a"}, {"code": "(fn f [s]\n  (let [numbers (map #(. Integer (parseInt %)) (re-seq #\"[1-9]+\" s))]\n    (letfn [(is-square? [x] \n                        (loop [i 2]\n                          (cond\n                           (= (* i i) x) true\n                           (or (> i (quot x 2)) (> (* i i) x)) false\n                           true (recur (+ i 1)))))]\n      (loop [res \"\"\n             number (first numbers)\n             rnumbers (rest numbers)]\n        (cond\n         (nil? number) res\n         (not (is-square? number)) (recur res (first rnumbers) (rest rnumbers))\n         true (if (= (count res) 0)\n                (recur (str number) (first rnumbers) (rest rnumbers))\n                (recur (str res \",\" number) (first rnumbers) (rest rnumbers))))))))", "problem": 74, "user": "52d7b0ade4b09f7907dd137c"}, {"code": "(fn [s] (clojure.string/join \",\" (filter\n   #(integer? (rationalize (Math/sqrt %)))\n   (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "529d4f4be4b04e0c58e87b79"}, {"code": "(fn [s] (\n\tlet [ns (read-string (str \"(\" s \")\"))]\n\t(->> ns \n\t\t(filter #(let [sq  (int (Math/sqrt %))] (= % (* sq sq))))\n\t\t(interpose \",\")\n\t\t(apply str))\n))", "problem": 74, "user": "52cdb7efe4b07d0d72b2737c"}, {"code": "(fn [l]\n  (reduce #(str % \",\" %2)\n          (filter #(let [s (int (Math/sqrt %))] (= % (* s s)))\n                  (map #(Integer/parseInt %)\n                       (re-seq #\"\\d+\" l)))))", "problem": 74, "user": "5256627ce4b0541d1855ba1a"}, {"code": "(fn [nums]\n  (clojure.string/join \",\" \n                       (filter #(let [rt (Math/sqrt %)] (== rt (int rt)))\n                               (map #(Integer/parseInt %)\n                                    (clojure.string/split nums #\",\")))))", "problem": 74, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(let [root (Math/sqrt %)] (= root (Math/floor root)))\n    (map\n     #(Long/parseLong %)\n     (clojure.string/split s #\",\")))))", "problem": 74, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [s]\n   (clojure.string/join \",\"\n    (filter (fn [v] (= v (last (take-while #(<= % v) (map #(* % %) (range))))))\n            (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn [values]\n  (let [raiz (fn [v] (== v (* (java.lang.Math/sqrt v) (java.lang.Math/sqrt v))))]\n    (apply str (interpose\n      \",\"\n      (filter\n        raiz\n        (map\n          #(java.lang.Integer/parseInt %)\n          (clojure.string/split values #\",\")))))))", "problem": 74, "user": "52bdd135e4b07a9af579230a"}, {"code": "#(clojure.string/join \\, \n                      (filter (fn [n] (#{4 9 16 25 36} n)) \n                              (read-string (str \\[ % \\]))))", "problem": 74, "user": "52b02329e4b0c58976d9acc5"}, {"code": "(fn [s] (->> (re-seq #\"\\d+\" s)\n               (map read-string)\n               (filter #(= (* (int (Math/sqrt %)) (int (Math/sqrt %)))\n                           %))\n               (clojure.string/join \",\")))", "problem": 74, "user": "52d6a9c2e4b09f7907dd1365"}, {"code": "#(clojure.string/join \",\" (filter (fn [n]\n  (not (nil? (some #{n} (map (fn [x] (* x x)) (range 1 n))))))\n        (map read-string (re-seq #\"\\d+\" %))))", "problem": 74, "user": "4ee75ec2535d93acb0a66867"}, {"code": "(fn [x]\n (apply str\n    (interpose \",\"\n      (map str\n        (filter #(zero? (mod (. Math sqrt %) 1 ))\n         (map #(. Integer parseInt %)  \n            (re-seq #\"\\d+\" x)))))))", "problem": 74, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(comp (partial clojure.string/join \",\")\n      (partial filter #(let [rt (Math/sqrt %)] (= rt (float (int rt)))))\n      (partial map read-string)\n      #(clojure.string/split % #\",\")\n      )", "problem": 74, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn fpsquares [astr]\n  (let [nums (clojure.string/split astr #\",\")]       \n    (clojure.string/join \",\" \n      (filter #(let [v (Math/sqrt (Integer. %))]\n           (if (= v (Math/floor v)) ;; It's an integer\n            true\n            nil)) nums))))", "problem": 74, "user": "52d6889ae4b09f7907dd1361"}, {"code": "(fn foo [s]\n  (let [nums (clojure.string/split s #\",\")]\n          (clojure.string/join \",\" (filter #(== (int (Math/sqrt (Integer/parseInt %))) (Math/sqrt (Integer/parseInt %))) nums))))", "problem": 74, "user": "52efd3d9e4b05e3f0be25ed4"}, {"code": "(fn [s]\n  (let [xs (map read-string (clojure.string/split s #\",\"))\n        squares (map #(* % %) (range))\n        square? (fn square? [x] \n                  (= x (first (drop-while (partial > x) squares))))]\n    (clojure.string/join \",\" (filter square? xs))))", "problem": 74, "user": "52c4af71e4b0c2d177d620e1"}, {"code": "(fn[coll] \n      (let [input (vec (map read-string (clojure.string/split coll #\",\")))]\n        ( clojure.string/join \",\" \n         (filter \n         (fn[x]\n         (let [sqrs (vec (map #(* % %) (range 0 (inc (/ x 2)))))]\n         (some #{x} sqrs)\n         )) \n       input))))", "problem": 74, "user": "52d66ca0e4b09f7907dd135c"}, {"code": "(fn [s]\n    (let [perfect-square? (fn [n]\n                            ((fn [n sr] (= n (* sr sr)))\n                             n\n                             (int (Math/sqrt n))))]\n      (clojure.string/join\n        \",\"\n        (filter           #(perfect-square? (Integer/parseInt %1))           (clojure.string/split s #\",\")))))", "problem": 74, "user": "4f43b992e4b0d7d3c9f3fd2c"}, {"code": "(fn [s]\n  (let [xs (map read-string (clojure.string/split s #\",\"))\n        sqrt #(Math/sqrt %)]\n    (clojure.string/join\n     \",\"\n     (filter #(= (float (sqrt %)) (float (int (sqrt %)))) xs))))", "problem": 74, "user": "52b405e1e4b0c58976d9ad15"}, {"code": "(fn r [x]\n   (apply str (interpose \",\" (map str (filter \n    (fn r [x] (< 0 (count (filter #(= (* % %) x) (range (inc x))))))\n     (map \n      #(Integer. %) \n      (clojure.string/split x #\",\")))))))", "problem": 74, "user": "525cc137e4b0cb4875a45d46"}, {"code": "(fn [coll]\n  (let [numbers (map #(Integer. %) (clojure.string/split coll #\",\"))\n        max-n (apply max numbers)\n        squares (apply merge (map #(hash-map (* % %) %) (take-while #(<= (* % %) max-n) (iterate inc 1))))]\n    (clojure.string/join \",\" (filter #(contains? squares %) numbers))))", "problem": 74, "user": "522404d8e4b01819a2de42c0"}, {"code": "(fn [s]\n\t(clojure.string/join \",\" \n\t(filter\n\t\t(fn perfect-square? [s]\n\t\t\t(let [num (Integer/parseInt s)]\n\t\t\t\t(= (double (int (Math/sqrt num))) (Math/sqrt num)  )\n\t\t\t)\n\t\t)\n\t\t(clojure.string/split s #\",\"))))", "problem": 74, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "(fn [x] (apply str  (interpose \\,\n                               (filter #(== (int (Math/sqrt %)) (Math/sqrt %))\n                                       (map #(Integer/parseInt %)\n                                            (re-seq #\"\\d+\" x))))))", "problem": 74, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "(fn filterS\n  [s]\n  (let [nums (map read-string (clojure.string/split s #\",\"))\n        helper (fn [nums]\n                 (loop [[first-curr & rest-curr :as curr] nums\n                        [first-square & rest-square :as square] (filter #(>= % (first nums))\n                                                                        (map #(* % %)\n                                                                             (iterate inc 1)))\n                        acc []]\n                   (if (empty? curr)\n                     acc\n                     (if (= first-curr first-square)\n                       (recur rest-curr rest-square (conj acc first-curr))\n                       (recur rest-curr square acc)))))\n        int-results (helper nums)]\n    (clojure.string/join #\",\" int-results)))", "problem": 74, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn [s] \n    (letfn [(i[s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n      (apply str (interpose \\,\n                            (keep #(let [sq (Math/sqrt %)]\n                                     (when (== (* sq sq) %) %))\n                                  (i s))))))", "problem": 74, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn filter-squares [a-str]\n    (letfn [(is-perfect-square [num] (= (Math/floor (Math/sqrt num)) (Math/sqrt num) ))] \n\t\t(let [number-str (clojure.string/split a-str #\",\") ]\n\t\t   (clojure.string/join \",\" (filter is-perfect-square (map #(java.lang.Integer/parseInt %) number-str)) )\n\t\t)\n\t)\n)", "problem": 74, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn [xs]\n  (letfn [(perfect-square? [n] (let [sqrt (Math/round (Math/sqrt n))] (= n (* sqrt sqrt))))\n          (to-ints [xs] (map #(Integer/parseInt %) (re-seq #\"\\d+\" xs)))\n          (perfect-squares [xs] (filter perfect-square? (to-ints xs)))]\n                   (apply str (interpose \",\" (map str (perfect-squares xs))))))", "problem": 74, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn [string]\n  (->> (re-seq #\"\\d+\" string)\n       (map #(Integer/parseInt %))\n       (filter\n        (fn [i]\n          (let [sq (int (Math/sqrt i))]\n            (= (* sq sq) i))))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "527a69cee4b03e8d9a4a755d"}, {"code": "(fn [i]\n  (let [vi (read-string (str \"[\" i \"]\"))\n        is-perf? (fn [x]\n                   (let [t (int (Math/sqrt x))]\n                     (= x (* t t))))]\n    (clojure.string/join \",\" (filter is-perf? vi))))", "problem": 74, "user": "52d809bde4b09f7907dd1384"}, {"code": "#(clojure.string/join \\, \n                      (filter (fn [n] \n                                (let [s (Math/sqrt n)]\n                                  (= (Math/floor s) (Math/ceil s)))) \n                              (map read-string (.split % \",\"))))", "problem": 74, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn squares [s]\n  (let* [seq (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n         sq-seq (filter (fn [e]\n                          (let [sq (Math/sqrt e)]\n                            (== (* sq sq) e))) seq)]\n        (apply str (interpose \\, sq-seq))))", "problem": 74, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn filter-perf-squares [s]\n  (let [\n        pow (fn [y] (int (Math/pow y 2)))\n        ints (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        is-perf-square? (fn [n] (loop [x 2]\n                                  (cond\n                                    (> x n) false\n                                    (> (pow x) n) false        \n                                    (= (pow x) n) true\n                                    :else (recur (inc x)))))\n        perf-squares (filter is-perf-square? ints)\n        ]\n    (clojure.string/join \",\" perf-squares)\n    ))", "problem": 74, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(= % (let [x (int (Math/sqrt %))] (* x x))) (map (fn [x] (Integer/valueOf x)) (clojure.string/split s #\",\")))))", "problem": 74, "user": "50742549e4b054001656accf"}, {"code": "(fn [xs] (let [ns (map read-string (re-seq #\"\\d+\" xs)) pns (clojure.set/intersection (into #{} (map #(* % %) (range (apply max ns)))))] (clojure.string/join \",\" (filter #(when (pns %) %) ns))))", "problem": 74, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [s]\n  (let [l (read-string (str \\[ s \\] ))\n        r (filter (fn [q] (some #(= q (* % %)) (range 1 (inc q)))) l)]\n       (apply str (take-while #(not= % \\)) (rest (clojure.string/replace (prn-str r) \" \" \",\"))))))", "problem": 74, "user": "52173464e4b082aa80a88c75"}, {"code": "(fn [s]\n   (apply str (interpose \",\" \n         (filter (fn [x] (contains? (set (map #(* % %)(range (inc x)))) x))\n                       (map read-string (clojure.string/split s #\",\"))))))", "problem": 74, "user": "5300aa1de4b0d8b024fd3710"}, {"code": "(fn [s] (->> s (re-seq #\"[0-9]+\") (map #(Integer. %)) (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))) (interleave (repeat \",\")) rest (apply str)))", "problem": 74, "user": "52c1f404e4b07a9af5792370"}, {"code": "(fn perfect-squares\n  [in]\n  (reduce #(str %1 \",\" %2)  \n    (filter (fn [n] (let [x (read-string n)] (if (some #(= x (* % %)) (range 1 x)) true false)))\n      (clojure.string/split in #\",\"))))", "problem": 74, "user": "5300b750e4b0d8b024fd3711"}, {"code": "(fn [coll]\n  (clojure.string/join \",\" (filter #(= (let [n (int (Math/sqrt %1))] (* n n)) %1) (map #(Integer/parseInt %1) (clojure.string/split coll #\",\")))))", "problem": 74, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn sqrs [string]\n (clojure.string/join \",\" (filter #(first (for [x (range %) :let [sqr (* x x)] :when (= sqr %) :while (<= sqr %)] true)) (map read-string (clojure.string/split string #\",\")))) )", "problem": 74, "user": "4f48f587e4b0d56e7bb92be2"}, {"code": "#(apply str (interpose \",\" (filter (fn [n] (= n (int (Math/pow (int (Math/sqrt n)) 2)))) (map (fn [n] (Integer/valueOf n)) (re-seq #\"\\d+\" %)))))", "problem": 74, "user": "4fb99483e4b081705acca2da"}, {"code": "(fn[s] \n    (reduce \n      #(str %1 \",\" %2) \n      (filter \n        #(let[i (Integer/parseInt %) \n              j (int (Math/sqrt i))] \n           (= i (* j j))\n           ) \n        (clojure.string/split s #\",\")\n        )\n      )\n    )", "problem": 74, "user": "52e68e61e4b09f7907dd1479"}, {"code": "(fn [s]\n  (let [seqsqr (map #(* % %) (range))]\n    (letfn [(integers [x] (map read-string (clojure.string/split x #\",\")))\n            (makestring [x] (clojure.string/join \",\" x))\n\t        (perfectsqr \n             [n] \n             (letfn [(perfectsqrint \n                      [x sq]\n                      (if (= x (first sq)) true\n                        (if (< x (first sq)) false\n                          (perfectsqrint x (rest sq))\n                          )))]\n               (perfectsqrint n seqsqr)))\n            (filterint \n             [l] \n             (if (empty? l) []\n               (let [fl (first l) frl (filterint (rest l))]\n                 (if (perfectsqr fl) (concat [fl] frl) frl)\n                 )))]\n    (makestring (filterint (integers s)))\n    )))", "problem": 74, "user": "52faec2ee4b047fd55837004"}, {"code": "(fn [x] (let [nums (map #(Integer/parseInt %) (clojure.string/split x #\",\"))\n              fun (fn dig-root [x orig]\n                     (if (> x 10)\n                       (let [new-num (reduce +(map #(Integer/parseInt %) (rest (clojure.string/split (str x) #\"\"))))]\n                         (dig-root new-num orig))\n                       (if (> orig 10)\n                         (some #(= % x) [1 4 7 9])\n                         (some #(= % x) [1 4 9]))))]\n           (clojure.string/join \",\" (map #(str %)(filter #(fun % %) nums)))))", "problem": 74, "user": "52fa4f48e4b047fd55836ff7"}, {"code": "(fn m [s]\n(let [splitted (-> s (clojure.string/split #\",\"))\n      int-vec (map #(Integer/parseInt %) splitted)\n      perfect-sq (filter #(zero? (rem (Math/sqrt %) 1)) int-vec)\n      output-str (apply str (interpose \",\" perfect-sq))] output-str))", "problem": 74, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn [s]\n  (letfn [(ps? [n] \n             (let [r (Math/sqrt n)] \n               (= 0.0 (- r (int r)))))]\n    (clojure.string/join \",\"\n      (filter ps?\n        (map #(Integer. %) (clojure.string/split s #\",\"))\n      )\n    )\n  )\n)", "problem": 74, "user": "52774dd2e4b03e8d9a4a74ff"}, {"code": "(fn filter-squares [string]\n  (let [square? (fn [x]\n                  (let [root (int (Math/sqrt x))]\n                    (= x (* root root))))\n        parsed-list (map read-string (re-seq #\"\\d+\" string))]\n    (clojure.string/join \",\" (filter square? parsed-list))))", "problem": 74, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn [strn] \n  (->>  \n   (clojure.string/split strn #\",\") \n   (map read-string) \n   (filter \n    #(= \n      (Math/sqrt %) \n      (Math/ceil (Math/sqrt %))))\n   (clojure.string/join \",\")))", "problem": 74, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn [s]\n  (apply str \n         (interpose \",\" \n                    (filter #(let [sqrt (Math/sqrt %)] (== sqrt (int sqrt))) \n                            (map #(Integer/parseInt %) \n                                 (clojure.string/split s #\",\"))))))", "problem": 74, "user": "52d00832e4b07d0d72b273b4"}, {"code": "(fn[s] (clojure.string/join \",\" (filter (fn[x] (not (zero? (count (filter #(= (* % %) x) (range x)))))) (map read-string (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn [num-str] (clojure.string/join \",\" \n                                   (filter #(== (int (Math/sqrt %)) (Math/sqrt %)) \n                                           (map read-string (re-seq #\"\\d+\" num-str)))))", "problem": 74, "user": "524469dee4b0d8acf9ed6a9d"}, {"code": "(fn[s]\n  (clojure.string/join \",\"\n   (filter (set (for [x (range 2 1000)] (str (* x x))))\n    (clojure.string/split s #\"\\,\"))))", "problem": 74, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn [string]\n  (clojure.string/join \",\"\n                       (filter\n                         #(let [value (Integer. %)\n                                value-sqrt (Math/sqrt value)]\n                            (= (Math/floor value-sqrt) value-sqrt))\n                         (clojure.string/split string #\",\"))))", "problem": 74, "user": "53070615e4b02e821686979e"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(== % (* (Math/sqrt %) (Math/sqrt %)))\n                               (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "52b63875e4b0c58976d9ad41"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt (read-string %)) 1)) (re-seq #\"\\d+\" x))))", "problem": 74, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn perfSq [in]\n  (->>\n   (map #(Integer/parseInt %) (re-seq #\"\\d+\" in))\n   (filter (fn [x] (some #(= x %) (map #(* % %) (range x)))))\n   (interpose \",\")\n   (apply str))\n  )", "problem": 74, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn[s] (apply str(interpose \",\" (filter #(= % (*(int(Math/sqrt %))(int(Math/sqrt %)))) (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))))))", "problem": 74, "user": "5307e4ece4b02e82168697a9"}, {"code": "#(clojure.string/join\n  \\,\n  (filter\n      (fn [x]\n        (if (zero? (mod (Math/sqrt (Integer/parseInt x)) 1))\n          true\n          false\n        )\n      )\n      (re-seq #\"\\d+\" %)\n  )\n)", "problem": 74, "user": "53153466e4b08068f379ed23"}, {"code": "(fn\n  [s]\n  (->> \n   #\",\" \n   (clojure.string/split s) \n   (map read-string)\n   (filter (fn [n] (some #(and (= (* % %) n) (< % n)) (->> (range) (drop 1) (take n)))))\n   (clojure.string/join \",\")))", "problem": 74, "user": "531490bde4b08068f379ed17"}, {"code": "(fn [s]\n  (letfn [(perf-sq? [n] (let [sqrt (Math/sqrt n)] (== sqrt (int sqrt))))]\n    (->> s\n      (#(clojure.string/split % #\",\"))\n      (map #(Integer/parseInt %))\n      (filter perf-sq?)\n      (clojure.string/join \",\"))))", "problem": 74, "user": "530e9729e4b08068f379ecbc"}, {"code": "(fn perfect-squares [s]\n  (let [is-perfect-square (fn [x]\n                            (let [int-r (int (Math/sqrt x))]\n                              (= (* int-r int-r) x)))]\n    (clojure.string/join\n     \",\"\n     (filter is-perfect-square\n             (map read-string (clojure.string/split s #\",\"))))))", "problem": 74, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn [inString]\n\t(->> inString\n\t(re-seq #\"\\w+\")\n\t(map #(Integer/parseInt %))\n\t(filter\n\t\t(fn [candidate] (= candidate \n\t\t\t\t\t\t(first (filter #(<= candidate %) (reductions + (filter odd? (range)))))))\n\t\t)\n\t(interleave (repeat \",\"))\n\t(rest)\n\t(apply str)\n\t)\n)", "problem": 74, "user": "52bf6946e4b07a9af5792334"}, {"code": "#(apply str (interpose \",\" (for [s (clojure.string/split % #\",\")\n                              :let [n (read-string s)]\n                              :when (= 0.0 (mod (Math/sqrt n) (int (Math/sqrt n))))]\n                              n)))", "problem": 74, "user": "52a5a8ebe4b0c58976d9abed"}, {"code": "(fn [string]\n  (let [res (->> (.split string \",\")\n                 (map #(Integer/parseInt %))\n                 (map #(Math/sqrt %))\n                 (filter #(= % (Math/floor %)))\n                 (map #(Math/pow % 2))\n                 (map int))]\n    (if (empty? res)\n      res\n      (->> res\n           butlast\n           (reduce #(str %1 \",\" %2))\n           (#(str % \",\" (last res)))))))", "problem": 74, "user": "530cb5b8e4b02e82168697e0"}, {"code": "(fn [s] \n  (apply str\n    (interpose \",\"      \n      (filter \n        #(== (int (Math/sqrt %)) (Math/sqrt %))\n        (read-string (str \"[\" s \"]\"))\n      ) \n    )\n  )\n)", "problem": 74, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn [n]\n   (let [nums (map read-string (.split n \",\"))]\n     (clojure.string/join \",\"\n           (map str\n                (filter #(reduce (fn [a b] (or a (= % (* b b))))  false (range 2 %)) nums)))))", "problem": 74, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [s]\n  (letfn [(square? [n]\n                   (let [sqrt (int (Math/sqrt n))]\n                     (= (* sqrt sqrt) n)))]\n    (let [sq (clojure.string/split s #\",\")\n          results (map #(square? (Integer. %)) sq)]\n      (->> (interleave results sq)\n           (partition 2)\n           (filter #(= true (first %)))\n           (map second)\n           (clojure.string/join \",\")))))", "problem": 74, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn squares [s] \n  (->> s\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter (fn [n] (-> n\n                           Math/sqrt\n                           Math/floor\n                           int\n                           (#(* % %))\n                           (= n))))\n       (clojure.string/join \",\")))", "problem": 74, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [nstring]\n  (apply str \n         (interpose \",\" \n                    (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)) \n                            (map #(Integer/parseInt %) \n                                 (clojure.string/split\n                                  nstring\n                                  #\"\\s*,\\s*\"))))))", "problem": 74, "user": "52d340ebe4b099d49816f0c1"}, {"code": "(fn filter-square [s]\n  (letfn [(square [x]\n\t\t  (empty?\n\t\t   (for [y (range 2 x)\n\t\t\t:when (= (* y y) x)] y)))]\n\t (clojure.string/join \",\"\n\t    (map #(format \"%d\" %)\n\t      (filter (complement square) (map read-string (clojure.string/split s #\",\")))\n\t ))\n  )\n)", "problem": 74, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1))\n                                         (map #(Integer/parseInt %)\n                                              (.split x \",\")))))", "problem": 74, "user": "53034738e4b0d8b024fd373e"}, {"code": "(fn [s]\n  (let [square? (fn [x] (= x (first (drop-while #(< % x) (map #(* % %) (range))))))\n        nums (map #(Integer. %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter square? nums))))", "problem": 74, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn f[s] (clojure.string/join \",\" (filter #(= 0.0 (mod (Math/sqrt %) 1)) (map #(Integer/parseInt %) (.split s \",\")))))", "problem": 74, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter \n                        #(zero? (rem (java.lang.Math/sqrt (Integer/parseInt %)) 1)) \n                        (clojure.string/split s #\"\\D\"))))", "problem": 74, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn [s]\n((comp (partial apply str) (partial interpose \",\"))\n(filter (fn [n] (some (set (map #(* % %) (range 7))) [n]))\n      (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "52be0263e4b07a9af579230e"}, {"code": "(fn ps [st]\n      (clojure.string/join\",\" (filter\n #(= % (int ( * (int (Math/sqrt %)) (int (Math/sqrt %)) )))\n (map #(Integer/valueOf %) (.split st \",\")) ))\n      )", "problem": 74, "user": "51f81925e4b09be9c177e526"}, {"code": "(fn onlySquares [numberString]\n  (let\n      [isqrt (fn [x] (int (Math/sqrt x)))\n       isSquare (fn [x] (= (* (isqrt x) (isqrt x)) x))\n       str2vec (fn [str] (map #(Integer/parseInt %) (clojure.string/split str #\",\")))\n        ]\n    (clojure.string/join \",\" (filter isSquare (str2vec numberString)))\n    ))", "problem": 74, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [s] \n\t(clojure.string/join \",\" \n\t\t(filter #(zero? (mod (Math/sqrt %) 1)) \n                (map #(Long. %) (re-seq #\"[0-9]+\" s)))))", "problem": 74, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn onlysquares [x]\n           (apply str \n                  (interpose \",\" \n                             (filter (fn issquare? [n]\n                                       (if (not (number? n))\n                                         false\n                                         (if (neg? n)\n                                           false\n                                           (if (== (- (Math/sqrt n) (Math/floor (Math/sqrt n))) 0)\n                                             true\n                                             false))))\n                                     (map #(Integer/parseInt %) \n                                          (map #(apply str %) \n                                               (filter #(Character/isDigit (first %)) \n                                                       (partition-by #(Character/isDigit %)\n                                                       (vec x)))))))))", "problem": 74, "user": "532727bae4b09d4e7a9b54fa"}, {"code": "(fn [s]\n  (clojure.string/join\n    \",\"\n    (filter\n      (fn [n] (some #{n} (map #(* % %) (range n))))\n      (map #(Integer. %) (.split s \",\")))))", "problem": 74, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(let [r (Math/sqrt (Integer/parseInt %)) z (- r (Math/floor r))] \n                                             (zero? z)) (clojure.string/split s #\",\")))))", "problem": 74, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn filterpf [l]\n  (letfn [(ps [s]\n            (let [r (java.lang.Math/sqrt s)\n                  r (int r)]\n              (= (* r r) s)))]\n    (apply\n     str\n     (drop-last 1\n                (interleave\n                 (filter ps (map #(Integer/parseInt %) (.split l \",\")))\n                 (repeat \\,))))))", "problem": 74, "user": "532b43c3e4b09d4e7a9b5531"}, {"code": "(fn perfect-square [string-numbers]   \n    (let [string-numbers (clojure.string/split string-numbers #\"\\,\")]   \n        (clojure.string/join \",\"\n            (for [x string-numbers\n            :let [y (int (Math/sqrt (Integer. x)))\n                  z (* y y)]    \n            :when (= (Integer. x) z) ]\n          (Integer. x))\n        )\n    )\n)", "problem": 74, "user": "533a7427e4b0e30313ee6cbb"}, {"code": "(fn perfect-square [string-numbers]   \n    (let [string-numbers (clojure.string/split string-numbers #\"\\,\")]   \n        (clojure.string/join \",\"\n            (for [x string-numbers\n            :let [y (int (Math/sqrt (Integer. x)))\n                  z (* y y)]    \n            :when (= (Integer. x) z) ]\n          (Integer. x))\n        )\n    )\n)", "problem": 74, "user": "533aac38e4b0e30313ee6cbe"}, {"code": "(fn [s]\n  (let [x (clojure.string/split s #\",\")\n        nums (map #(read-string (str %)) x)\n        fin (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) nums)]\n    (apply str (interpose \",\" fin))))", "problem": 74, "user": "52474133e4b05ef8e38e635e"}, {"code": "(fn [x] (clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt (Integer. %)) 1)) (.split x \",\"))))", "problem": 74, "user": "52570aeae4b0541d1855ba42"}, {"code": "(fn f [s]\n  (let [nums (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        all-perf-sq (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n    (apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "5302ac7fe4b0d8b024fd3731"}, {"code": "(fn [intstr]\n  (let [l (map #(Integer. %) (clojure.string/split intstr #\",\"))         \n        squares (set (take-while (partial >= (apply max l)) (map #(* % %) (range))))] ;; set with all squares until max int\n    (->> l (filter squares) (map str) (clojure.string/join \",\"))))", "problem": 74, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn [s] (clojure.string/join \",\"\n                             (filter (fn [n] (some #(= n (* % %)) (range n)))\n                                     (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn [s] (clojure.string/join \",\" (filter (fn [x] (let [n (read-string x)\n                               sqrtn (Math/round (Math/sqrt n))]\n                           (= (* sqrtn sqrtn) n))) (clojure.string/split s #\",\"))))", "problem": 74, "user": "506d5e4ce4b0a302964c5493"}, {"code": "#(clojure.string/join \n  \",\" (map str (filter \n                (fn[x] (= (. Math sqrt x) (. Math floor(. Math sqrt x))))\n                (map (fn[x](. Integer parseInt x)) (clojure.string/split % #\",\")))))", "problem": 74, "user": "51b41150e4b0f094dd986fac"}, {"code": "(fn [input]\n  (let [numbers (map read-string (clojure.string/split input #\",\"))\n        squares (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) numbers)\n        square-string (clojure.string/join \",\" squares)]\n    square-string))", "problem": 74, "user": "51a3b135e4b0e77c4ca60bf6"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #(let [i (Integer/parseInt %) x (Math/sqrt i)] (and (< 3 i) (= 0.0 (- x (Math/floor x))))) (.split s \",\"))))", "problem": 74, "user": "4f0c4518535d0136e6c2230b"}, {"code": "(let [ips? \n        (fn ips [x]\n          (if (or (= 4 (Integer. x))\n                  (= 9 (Integer. x))\n                  (= 16 (Integer. x))\n                  (= 25 (Integer. x))\n                  (= 36 (Integer. x))) true false))] \n\n    (fn fps [s] (clojure.string/join \",\"\n                   (filter ips? \n                           (clojure.string/split s #\",\")))))", "problem": 74, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn [s] (apply str (interpose \",\" (filter #(zero? (mod (Math/sqrt (Integer/parseInt %)) 1)) (re-seq #\"[0-9]+\" s)))))", "problem": 74, "user": "51e28063e4b08e53a149f0f2"}, {"code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        all-perf-sq (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "problem": 74, "user": "50436470e4b034ff00315d23"}, {"code": "(fn [str-in ]\n  (let [sq-in (map #(Integer/parseInt %) (.split #\",\" str-in))\n     mx (apply max sq-in)\n     xsq  (map #(* % %) (range mx))\n     ]\n     (apply str (interpose \",\" (map str (remove nil? (map #(some #{%} xsq) sq-in)))))\n  )\n )", "problem": 74, "user": "530d1060e4b08068f379eca2"}, {"code": "(fn psq [s]\n  (->> (str \"[\" s \"]\")\n       (read-string)\n       (filter #(== 0 (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "problem": 74, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn\n  [s]\n  (let [i (map #(Integer. %) (clojure.string/split s #\",\"))\n        p (filter identity (for [n i\n                                 :let [sq-rt ((fn\n                                                [nn t] \n                                                (if (= t (/ nn t)) \n                                                  t \n                                                  (if (> t nn) \n                                                    nil \n                                                    (recur nn (inc t)))))\n                                              n 1)]]\n                             (if-not (nil? sq-rt) n)))]\n    (apply str (interpose \",\" p))))", "problem": 74, "user": "52f3af46e4b05e3f0be25f14"}, {"code": "(fn [num-list-str]\n  (clojure.string/join \",\"\n   (map str \n        (filter #(zero? (- % (* (Math/sqrt %) (Math/sqrt %))))\n                (map read-string \n                     (clojure.string/split num-list-str #\",\"))))))", "problem": 74, "user": "5341b141e4b00652c8746ecf"}, {"code": "(let [long? #(== (long %) %)]\n  (fn perfect-sqrs [s]\n    (->> (.split #\",\" s)\n         (map read-string)\n         (filter (comp long? #(Math/sqrt %)))\n         (clojure.string/join \",\"))))", "problem": 74, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [s]\n  (apply str (interpose \",\"\n  (filter #(zero? (mod % (Math/sqrt %)))\n     (map #(Integer/parseInt %) (map str (clojure.string/split s #\",\")))))))", "problem": 74, "user": "53219cece4b09d4e7a9b54b7"}, {"code": "(fn [s]\n  (clojure.string/join \n   \",\"                \n   (filter #(let [n (Integer/parseInt %) r (int (Math/sqrt n))]\n              (= (* r r) n))\n           (clojure.string/split s #\",\"))))", "problem": 74, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn [s]\n   (let [v (map read-string (clojure.string/split s #\",\"))]\n     (clojure.string/join \",\"\n                          (filter\n                           (fn [x]\n                             (let [s (Math/sqrt x)]\n                               (= s (Math/floor s))))\n                           v))))", "problem": 74, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [xs]\n  (clojure.string/join \",\"\n    (for [x (map read-string (clojure.string/split xs #\",\"))\n          :when (= (#(* % %) (int (Math/sqrt (double x)))) x)]\n      x)))", "problem": 74, "user": "5054c853e4b0b1b9d1860eb3"}, {"code": "#(apply str (interpose \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (re-seq #\"[0-9]+\" %))))", "problem": 74, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [s] (clojure.string/join \",\"\n                             (filter #(some #{%}\n                                            (map * (range %) (range %)))\n                                     (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "4e705861535d5021c1a89635"}, {"code": "(fn [string-of-ints]\n  (letfn [(perfect-square? [n]\n            (let [r (int (Math/sqrt n))]\n              (= n (* r r))))]\n    (clojure.string/join \",\"\n      (filter perfect-square?\n        (map #(Integer. %)\n          (clojure.string/split string-of-ints #\",\"))))))", "problem": 74, "user": "533f09e1e4b085b17e897d9a"}, {"code": "(fn [cs]\n  (letfn [(perfect-square?\n           ([n] (perfect-square? n 0))\n           ([n m]\n            (if (> n (* m m))\n              (perfect-square? n (inc m))\n              (= n (* m m)))))\n          (from-str [cs] (map #(Integer/parseInt %) (re-seq #\"\\d+\" cs)))\n          (to-str [ns] (apply str (interpose \",\" (map str ns))))]\n    (to-str (filter perfect-square? (from-str cs)))))", "problem": 74, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %1))\n       (filter #(= (double (int (Math/sqrt %1))) (Math/sqrt %1)))\n       (interpose \",\")\n       (apply str)))", "problem": 74, "user": "52fb64b7e4b047fd55837009"}, {"code": "(fn filter-perfect-squares [s]\n  (letfn [(perfect-square? [n]\n            (loop [x 1]\n              (let [r (* x x)]\n                (cond (= r n) true\n                      (> r n) false\n                      :else (recur (inc x))))))\n          (to-int [s]\n            (Integer/parseInt s))]\n    (clojure.string/join \",\" (filter perfect-square? (map to-int (clojure.string/split s #\",\"))))))", "problem": 74, "user": "4e82c062535db62dc21a62cc"}, {"code": "(fn [s]\n  (let [tokens (re-seq #\"\\d+\" s)\n        numbers (map read-string tokens)\n        squares (filter #(> 0.0000000001 (let [r (Math/sqrt %)] (Math/abs (- r (Math/round r))))) numbers)]\n    (apply str (interpose \",\" (map str squares)))))", "problem": 74, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn[y]\n  (clojure.string/join \",\" (filter (fn[x] (some  #(= x %) (map #(* % %) (range x)))) (map #(Integer. %) (re-seq #\"\\d+\" y))))\n  )", "problem": 74, "user": "4f82ed48e4b033992c121c0e"}, {"code": "(fn [ins]\n  (let [candidates (map read-string (re-seq #\"\\d+\" ins))\n        isSquare?  (fn [x] (let [root (Math/sqrt x)] (== root (int root))))\n        squares    (filter isSquare? candidates)]\n    (apply str (interpose \",\" squares))))", "problem": 74, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(fn [x]\n  (->> \n   (clojure.string/split x #\",\") \n   (map #(Integer. %)) \n   (filter #(= (mod (Math/sqrt %) 1) 0.0))\n   (clojure.string/join \",\")))", "problem": 74, "user": "534941d1e4b084c2834f4a60"}, {"code": "(fn [s]\n      (letfn [(square? [x] (let [sq (Math/sqrt x)\n                                 sq-int (int sq)]\n                             (>= 0.01 (- sq sq-int))))]\n        (let [splitted (clojure.string/split s #\",\")\n              numbers (map #(Integer/parseInt %) splitted)]\n          (clojure.string/join \",\" (filter square? numbers)))))", "problem": 74, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn fn4[x]\n  (let [x1 (map (fn [e0]\n                  (Integer/parseInt (str \"\" e0))) \n                (clojure.string/split x #\",\"))] \n    (reduce (fn [acc e]\n              (if (= 0.0 (- (int (java.lang.Math/sqrt e)) (java.lang.Math/sqrt e)))\n                (if (= acc \"\")\n                  (str acc e)\n                  (str acc \",\" e))\n                acc))\n            \"\" x1)))", "problem": 74, "user": "52d6664be4b09f7907dd1359"}, {"code": "(fn [s]\n   (->> (re-seq #\"\\d+\" s)\n        (map #(Integer. %))\n        (filter (fn [n] (= n (#(* % %) (int (Math/sqrt n))))))\n        (clojure.string/join \",\")))", "problem": 74, "user": "5175533fe4b0dea9bbfba575"}, {"code": "(fn [s]  (apply str (interpose \",\" (filter #(== 0 (mod (Math/sqrt %)(Math/round (Math/sqrt %)))) (map #(read-string %) (clojure.string/split s #\",\"))))))", "problem": 74, "user": "53286389e4b09d4e7a9b5504"}, {"code": "(fn [s] (clojure.string/join \",\"\n  (filter #(= 0.0 (mod (Math/sqrt %) 1)) \n    (read-string (str \"[\" s \"]\")) )) )", "problem": 74, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [s] (apply str (interpose \\, (filter #(let [r (-> % Integer/parseInt Math/sqrt)] (zero? (mod r 1))) (.split s \",\")))))", "problem": 74, "user": "531f7a2de4b08068f379edc6"}, {"code": "(fn find-squares [s]\n  (let [xs (clojure.string/split s #\",\")\n        xs (map #(Integer. %) xs)\n        p-square? (fn [n] (zero? (rem (Math/sqrt n) 1)))]\n    (clojure.string/join \\, (filter p-square? xs))))", "problem": 74, "user": "50366589e4b0fbe0a74d26c3"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter (fn [x]\n                                 (let [x (Integer/parseInt x)\n                                       y (Math/sqrt x)]\n                                   (== x (* y y))))\n                               (clojure.string/split s #\",\"))))", "problem": 74, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(= \n              (double (int (Math/sqrt %))) \n              (Math/sqrt %)) \n            (map read-string (clojure.string/split s #\",\"))\n    )\n  )\n )", "problem": 74, "user": "52d42021e4b09f7907dd132a"}, {"code": "(fn find-perfects [coll]\n  (->>\n   (clojure.string/split coll #\",\")\n   (filter #(let [n (read-string %)] (= 0.0 (mod n (Math/sqrt n)))))\n   (clojure.string/join \",\")))", "problem": 74, "user": "5339af7de4b0e30313ee6cab"}, {"code": "(fn [input]\n    (apply str (interpose \",\" (filter #(= (* (Math/sqrt %) (Math/sqrt %)) (double %)) (map #(Integer. %1) (re-seq #\"\\d+\" input))))))", "problem": 74, "user": "5356ac72e4b04ce2eb3ed26a"}, {"code": "(fn fun [s]\n (->>\n  (clojure.string/split s #\",\")\n  (map read-string)\n  (filter (fn [x]\n            (let [sr  (int (Math/sqrt x))]\n              (= x\n               (* sr sr)))))\n  (clojure.string/join \",\" )\n  (apply str)))", "problem": 74, "user": "5349da55e4b084c2834f4a68"}, {"code": "(fn [s]\n  (let [xs (map read-string (clojure.string/split s #\",\"))\n        perfect-sq? #(zero? (mod (Math/sqrt %) 1))]\n    (apply str (interpose \",\" (filter perfect-sq? xs)))))", "problem": 74, "user": "5312cdaae4b08068f379ed03"}, {"code": "(fn [s]\n    (let [perfect-square? (fn [n] \n                            (->>\n                             (range 1 (inc n))\n                             (map #(* % %))\n                             (some #(= n %))))]\n      (->>\n       (clojure.string/split s #\",\")\n       (map read-string)\n       (filter perfect-square?)\n       (map #(.toString %))\n       (interleave (repeat \",\"))\n       (drop 1)\n       (apply str))))", "problem": 74, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn [n-str]\n  (let [xs (map read-string (.split #\",\" n-str))\n        sq? (fn [n]\n              (true? (some #(= n (* % %)) (range 1 n))))]\n    (clojure.string/join \",\" (filter sq? xs))))", "problem": 74, "user": "4f3d83b5e4b0e243712b1f69"}, {"code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter (fn [v]\n             (some #(= v %) (map #(* % %) (range v))))\n           (read-string(str \"(\" s \")\")))))", "problem": 74, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn [s] \n  (apply str\n    (interpose\n      \",\"\n      (filter \n        #(= 0.0 (rem (Math/sqrt (Integer/parseInt %)) 1)) \n        (clojure.string/split s #\",\")))))", "problem": 74, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [s]\n    (let [ps (map #(* % %) (range))\n          parts (clojure.string/split s #\",\")\n          lowest (Integer/parseInt (first parts))\n          highest (Integer/parseInt (last parts))]\n      (apply str (interpose \",\" (take-while (partial >= highest) (drop-while (partial > lowest) ps))))))", "problem": 74, "user": "52a32876e4b04e0c58e87bfb"}, {"code": "(fn t4 [string] (apply str (interpose \",\" (filter #(#{\"1\", \"4\", \"9\", \"16\", \"25\", \"36\"} %1) (clojure.string/split string #\",\")))))", "problem": 74, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn [s] (apply str (map str (interpose \",\" (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))) (map read-string (clojure.string/split s #\"\\,\")))))))", "problem": 74, "user": "536973e5e4b0243289761e9e"}, {"code": "(fn [s]\n(clojure.string/join \",\"\n                     (filter (fn [x]\n                                 (= \"0\" (last (clojure.string/split (str (Math/sqrt x)) #\"\\.\"))))\n                         (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "problem": 74, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [s]\n  (apply str\n   (interpose \\,\n              (filter (fn [n] (let [sqrt (Math/sqrt (Integer/parseInt n))]\n                               (== sqrt (int sqrt))))\n                      (clojure.string/split s #\"\\,\")))))", "problem": 74, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn [s]\n   (let [nums (map #(Float/parseFloat %) (clojure.string/split s #\",\"))]\n     (->> nums\n          (filter #(= (-> % Math/sqrt Math/round (Math/pow 2)) %))\n          (map #(int %))\n          (clojure.string/join \",\"))))", "problem": 74, "user": "51d4ed02e4b013d740b70dec"}, {"code": "(fn [text]\n  (let [perfect (fn [x] (== (* (Math/sqrt x) (Math/sqrt x)) x))\n        nums (map #(Integer/parseInt %) (clojure.string/split text #\",\"))]\n    (apply str (interpose \",\" (filter perfect nums)))))", "problem": 74, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn [s]\n    (let [perfect-square? (fn [n] (let [sqrt (Math/sqrt n)]\n                                    (== sqrt (int sqrt))))\n          ints-from-string (fn [s] (map #(Integer. %) (re-seq #\"\\d+\" s)))\n          string-from-ints (fn [xs] (apply str (interpose \",\" xs)))]\n      (string-from-ints (filter perfect-square? (ints-from-string s)))))", "problem": 74, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [s]\n  (let [all-squares ((fn internal-squares\n                      ([] (internal-squares 1 3))\n                      ([s d] (cons s (lazy-seq (internal-squares (+ s d) (+ d 2)))))))\n        nearest-square (fn [x] (some #(if (>= % x) %) all-squares))\n        is-square? (fn [x] (= x (nearest-square x)))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer. %))\n         (filter is-square?)\n         (interpose \\,)\n         (apply str))))", "problem": 74, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (filter #(-> % read-string Math/sqrt (rem 1) zero?))\n       (clojure.string/join \",\")))", "problem": 74, "user": "524b0645e4b09eba1c0223bf"}, {"code": "(fn [arg]\n  (clojure.string/join \",\" \n    (filter #(= (java.lang.Math/ceil (java.lang.Math/sqrt (Integer. %)))\n                (java.lang.Math/floor (java.lang.Math/sqrt (Integer. %)))) \n            (clojure.string/split arg #\",\"))))", "problem": 74, "user": "52747090e4b03e8d9a4a74a5"}, {"code": "(fn [s] (clojure.string/join \",\" (filter #((set (map * (range %) (range %))) %) (map read-string (re-seq #\"\\d+\" s)))))", "problem": 74, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [s] \n  (letfn [(to-numbers [s] (map #(Integer/parseInt %) (.split s \",\")))\n          (to-string [ns] (clojure.string/join \\, ns))\n          (square [n] (* n n))\n          (square? [n] (= n (square (int (Math/sqrt n)))))]\n    (->> s \n         to-numbers\n         (filter square?)\n         to-string)))", "problem": 74, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn [s]\n  (let [nums (into #{}(map read-string (re-seq #\"[0-9]+\" s)))\n        maxnum (apply max nums)\n        squares (take-while #(>= maxnum %)(map #(* % %) (range)))]\n    (apply str (interpose \\, ( filter (partial contains? nums) squares) ))))", "problem": 74, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn problem74 [s]\n  (->>\n    s\n    (#(clojure.string/split % #\",\"))\n    (map #(Integer/valueOf %))\n    (filter #(.equals (double %) (Math/pow (Math/sqrt %) 2)))\n    (map #(String/valueOf %))\n    (clojure.string/join \",\")))", "problem": 74, "user": "506c0a02e4b0eda3100c090d"}, {"code": "(fn [s] \n  (let [perfect-square (fn [i] (loop [num 0]\n                                 (cond (= num 100) false\n                                       (= (* num num) i) true\n                                       :else (recur (inc num)))))\n        numbers (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        sq-nums (reduce #(if (perfect-square %2) (conj %1 %2) %1) [] numbers)]\n    (clojure.string/join \",\" sq-nums)))", "problem": 74, "user": "4ed6c35e535d10e5ff6f52e8"}, {"code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    ;; Filter for perfect square, and then back to string\n    (->> nums\n         (filter #(zero? (mod (Math/sqrt %) 1)),  )\n         (interpose \",\"                        ,  )\n         (apply str                            ,  ))))", "problem": 74, "user": "53415755e4b00652c8746ecd"}, {"code": "(fn [x]\n  (letfn [(sqrt-int? [n]\n            (let [s (Math/sqrt n)]\n              (= (Math/rint s) s)))]\n    (->> (.split x \",\")\n         (map #(Integer/parseInt %))\n         (filter sqrt-int? )\n         (clojure.string/join \",\"))))", "problem": 74, "user": "52f4fae4e4b05e3f0be25f27"}, {"code": "(fn [z] (clojure.string/join \",\" (filter #(let [i (Integer. %)] (some (fn [x] (= (* x x) i)) (range i)))  (clojure.string/split z #\",\"))))", "problem": 74, "user": "536046a9e4b063bf7a5f8fe1"}, {"code": "(fn [s] (apply str (interpose \",\" (filter (fn [n]\n                  (loop [v 2]\n                    (if (= n (* v v))\n                      true\n                      (if (> (* v v) n)\n                        false\n                        (recur (inc v))))))\n                (map read-string (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn [xs]\n  (letfn [(is-perfect [x] (some #(= x (* % %)) (range x)))]\n    (clojure.string/join \",\" (filter is-perfect (map #(Integer/valueOf %) (clojure.string/split xs #\",\"))))))", "problem": 74, "user": "5323a414e4b09d4e7a9b54d1"}, {"code": "(fn app [x]\n               (clojure.string/join \",\" (filter (fn [p] (contains? #{\"4\" \"9\" \"16\" \"25\" \"36\"} p)) (clojure.string/split x #\",\")))\n               )", "problem": 74, "user": "4dd579b5535dae65d5c462ea"}, {"code": "(fn [input] \n  (->> input\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")\n       ))", "problem": 74, "user": "5192dd39e4b0c663c5d86c9e"}, {"code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map #(Integer/parseInt %))\n       (filter #(let [root (Math/sqrt %)\n                     iroot (int (+ root 0.01))]\n                 \t(= (* iroot iroot) %)))\n       (map str)\n       (interpose \\,)\n       (apply str)))", "problem": 74, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn [s]\n    (let [perfect-square? (fn [i]\n                            (let [i (Integer/parseInt i)]\n                              (loop [idx i]\n                                (cond\n                                 (zero? idx) false\n                                 (= (/ i idx) idx) true\n                                 :else\n                                 (recur (dec idx))))))]\n      (clojure.string/join \",\" (filter perfect-square? (clojure.string/split s #\",\")))))", "problem": 74, "user": "51c3c6a6e4b0851ac09658f8"}, {"code": "(fn [string] (-> string\n    (clojure.string/split #\",\")\n    (->> (map #(Integer/parseInt %))\n         (filter #(= (float %) (Math/pow (int (Math/sqrt %)) 2)))\n         (clojure.string/join \",\"))))", "problem": 74, "user": "537caf68e4b06839e8705e7b"}, {"code": "(fn [s]\n  (clojure.string/join \",\" (filter #(= (java.lang.Math/pow (java.lang.Math/sqrt %) 2) (float %)) (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn task-72 [s]\n  (let [is-square?\n                (fn [n]\n                  (let [s (int (Math/sqrt n))]\n                    (= (* s s) n)))\n        numbers (map #(Integer. %) (clojure.string/split s #\",\"))\n        squares (filter is-square? numbers)\n        result  (clojure.string/join \",\" (map str squares))]\n    result))", "problem": 74, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn [s]\n  (letfn [(psquare? [y] (let [x (read-string y)] (= (double x) (Math/pow (int (Math/sqrt x)) 2))))]\n    (->> (clojure.string/split s #\",\")\n         (filter psquare?)\n         (clojure.string/join \",\")))\n)", "problem": 74, "user": "536f5900e4b0fc7073fd6e7b"}, {"code": "(fn [s]\n  (let [square? (fn [x] \n                  (let [sqrt (int (Math/sqrt x))]\n                    (= x (* sqrt sqrt))))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter square?)\n         (map str)\n         (clojure.string/join \",\"))))", "problem": 74, "user": "53834ed3e4b06839e8705edb"}, {"code": "(fn [input]\n   (reduce #(str %1 \",\" %2)\n           (map str (filter #(and (not (= 1 %))\n                                  (= 0.0\n                                     (mod (Math/pow %\n                                                    0.5)\n                                          1)))\n                            (map #(Integer. %)\n                                 (filter #(not (= \",\" %))\n                                         (map #(if (> (count %) 1)\n                                                 (reduce str %)\n                                                 (str (first %)))\n                                              (partition-by  #(= \\, %1) input))))))))", "problem": 74, "user": "50981062e4b04e098a4c7268"}, {"code": "(fn [ns]\n  (->> (clojure.string/split ns #\",\")\n       (map read-string)\n       (filter (fn [a] (= a (first (drop-while #(< % a) (map #(* % %) (range)))))))      \n       (clojure.string/join \",\")\n       ))", "problem": 74, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(letfn \n  [(parse [s] (. Integer parseInt s))\n   (output [xs] (apply str (interpose \",\" xs)))\n   (square? [highest-x x] (->> (range)\n                               (map #(* % %))\n                               (take-while #(>= highest-x %))\n                               (set)\n                               (#(% x))))]\n  (fn [s]\n    (let [xs (map parse (.split s \",\"))]\n\t\t(output\n         (filter (partial square? (apply max xs))\n                 xs)))))", "problem": 74, "user": "51b24defe4b02f8f128bb963"}, {"code": "(fn [x] \n  (clojure.string/join \",\" (filter #(zero? (rem  (Math/sqrt %) 1)) \n                                   (map read-string (re-seq #\"\\d+\" x)))))", "problem": 74, "user": "536a37efe4b0243289761eaa"}, {"code": "#(case (get % 0)\n   \\4 \"4,9\"\n   \\1 \"16,25,36\")", "problem": 74, "user": "538d8bb8e4b0b51d73faae71"}, {"code": "(fn perf-squares [s]\n  (let [roots (map (comp #(Math/sqrt %) read-string) (re-seq #\"\\d+\" s))\n        perfs (filter #(== % (int %)) roots)\n        ints (map (comp int #(* % %)) perfs)]\n    (clojure.string/join \",\" (map str ints))))", "problem": 74, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn fu [s]\n  (let [perfect-square (fn [n]\n                         (some #(= %1 (/ n %1)) (range 1 n)))\n        nums (clojure.string/split s #\",\")\n        per-sqs (filter #(true? (perfect-square (Integer/parseInt %))) nums)]\n  (clojure.string/join \",\" per-sqs)))", "problem": 74, "user": "5374adc3e4b06d7f452d9e27"}, {"code": "(fn [s]\n  (letfn [(R [n]\n            (loop [x 0]\n              (cond (< n (* x x)) false\n                    (= n (* x x)) n\n                    :else (recur (inc x)))))]\n    (clojure.string/join \",\"\n                         (filter identity\n                                 (map #(R (. Integer parseInt %))\n                                      (clojure.string/split s #\",\"))))))", "problem": 74, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn [sl]\n  (letfn [(ps? [x] (->> (range 1 x) (filter #(= x (* % %))) first))]\n    (->> (clojure.string/split sl #\",\")\n         (map #(Integer/valueOf %))\n         (filter ps?)\n         (interpose \",\")\n         (reduce str))))", "problem": 74, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn prob74 [s]\n  (clojure.string/join\n   \",\"\n   (for [number-string (clojure.string/split s #\",\")\n         :let [number (Double/parseDouble number-string)]\n         :when (= number (Math/pow (Math/sqrt number) 2))]\n     number-string)))", "problem": 74, "user": "526e5159e4b03e8d9a4a7316"}, {"code": "(fn [xs]\n  (let [a (read-string (str \"[\" xs \"]\"))\n        b (filter #(let [x (Math/sqrt %)]\n                     (== x (int x)))\n                  a)]\n    (apply str (interpose \",\" b))))", "problem": 74, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(fn ps [s]\n  (clojure.string/join\n   \",\"\n  (filter\n   #(== % (Math/pow (Math/sqrt %) 2))\n   (map read-string (clojure.string/split s #\",\")))))", "problem": 74, "user": "530bf87ee4b02e82168697d5"}, {"code": "(letfn [(perfect-square? [n]\n        (let [r (int (Math/sqrt n))]\n            (= n (* r r))))]\n    (fn ps-csv [s]\n        (clojure.string/join\n            \",\"\n            (filter #(perfect-square? %)\n                    (map read-string\n                         (clojure.string/split s #\",\"))))))", "problem": 74, "user": "52bc6cb2e4b07a9af57922f5"}, {"code": "(fn [s]\n  (apply str\n         (interpose \",\"\n                    (filter #(let [q (Math/sqrt %)] (= q (Math/rint q)))\n                            (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "problem": 74, "user": "4ec53f8c535d6d7199dd368b"}, {"code": "(fn [s]\n  (let [nseq (->>(clojure.string/split s #\",\")\n                 (map #(Integer/parseInt %) ))\n        lzsquares (map (fn [x] (* x x)) (iterate inc 1))\n        maxinseq (apply max nseq)]\n    (->> (map #(some #{%} (take-while (partial >= maxinseq) lzsquares)) nseq)\n         (keep identity)\n         (clojure.string/join \",\")\n         )))", "problem": 74, "user": "5360f043e4b0243289761e3c"}, {"code": "(fn perfect-squares [nums]\n  (apply str (interpose \",\"\n    (filter \n     (fn [num] (some #(= num %) (map #(* % %) (range num))))\n     (map read-string (.split nums \",\"))))))", "problem": 74, "user": "538c3424e4b0b51d73faae58"}, {"code": "#(clojure.string/join\n  \",\"\n  (filter (fn [x] (zero? (mod (Math/sqrt x) 1)))\n          (read-string (str \"[\" % \"]\"))))", "problem": 74, "user": "53973e7be4b0b51d73faaee6"}, {"code": "(fn [s]\n  (let [square? (fn [n]\n                  (some #(= n (* % %)) (range 1 n)))]\n    (->> (re-seq #\"\\d+\" s)\n         (map #(Integer/parseInt %))\n         (filter square?)\n         (filter str)\n         (clojure.string/join \",\"))))", "problem": 74, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn filter-squares [s]\n  (letfn [(is-square? [x] (= x (#(* % %) (int (Math/sqrt x)))))]\n    (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n      (clojure.string/join \",\" (map str (filter #(is-square? %) xs))))))", "problem": 74, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "#(clojure.string/join \",\" (filter\n      (fn perfect-square? [n]\n        (some (fn [x] (= (* x x) (read-string n)))\n              (range 1 (inc (Math/sqrt (read-string n))))))\n      (clojure.string/split % #\",\")))", "problem": 74, "user": "53838742e4b06839e8705ee0"}, {"code": "(fn prob74 [^String s]\n  (letfn [(isqrt-step [n [x_k _]]\n            (let [x_k1 (* 0.5 (+ x_k (/ n x_k)))\n                  delta (* (- x_k1 x_k) (- x_k1 x_k))]\n              [x_k1 delta]))\n          (isqrt [n]   \n            (let [x0 (/ n 2)\n                  newton-seq (iterate (partial isqrt-step n) [x0 10])]\n              ((comp int #(Math/floor ^Double %) first first (partial take 1)) \n               (drop-while #(> (second %) 1.0) newton-seq))))\n          (isgolden?  [n]\n            (let [isqrtn (isqrt n)]\n              (== (* isqrtn isqrtn) n)))]\n    (apply \n     str \n   (interpose \n    \",\" \n    (filter \n     isgolden? \n     (map \n      #(Integer/parseInt ^String %) \n      (vec (.split s \",\"))))))))", "problem": 74, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn\n  [s]\n  (let [nums (map read-string (vec (.split s \",\")))\n        square (fn [n] (let [divs (take-while #(<= (* % %) n) (range))\n                             lst (last divs)]\n                         (and lst (= n (* lst lst)))))\n        sqs (filter square nums)]\n    (reduce #(.concat % %2) (interpose \",\" (map str sqs)))))", "problem": 74, "user": "52dfc89be4b09f7907dd1405"}, {"code": "(fn [s](apply str (interpose \",\" \n                   (filter \n                     (fn [n](some #(= n %) (map #(* % %) (range n))))\n                     (map #(Integer. %) (clojure.string/split s #\",\"))\n                    ))))", "problem": 74, "user": "526a3412e4b03e8d9a4a721e"}, {"code": "(fn [coll] (apply str\n                  (interpose \",\"\n                             (map #(.intValue %)\n                                  (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))\n                                          (map #(Double/parseDouble %)\n                                               (clojure.string/split coll #\",\")))))))", "problem": 74, "user": "53a1b5c8e4b0ca733b9744c1"}, {"code": "(fn [s]\n  (let [n (read-string (str \"(\" s \")\"))\n        x (last n)\n        y (set (take-while #(<= % x) (map #(* % %) (range))))]\n    (apply str (interpose \",\" (filter y n)))))", "problem": 74, "user": "533018b2e4b019098a6f8b56"}, {"problem": 74, "code": "(fn [xs] (let [cut (map #(Integer. %) (seq (.split #\",\" xs)))\n               square #(* % %)\n               square? (fn [n] \n                         (some #(= n %) \n                               (map square \n                                    (take-while #(<= (square %) n) (range)))))]\n           (apply str (interpose \",\" (filter square? cut)))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\" (filter \n   (fn [x] \n     (let [is, (int (Math/sqrt x))]\n       (= (* is is) x)))     \n   (map #(Integer/parseInt % ) \n        (clojure.string/split s #\",\")))))", "user": "51b5a6e0e4b0f094dd986fce"}, {"problem": 74, "code": "(fn [ ns ]\n    (->> (re-seq #\"\\d+\" ns)\n        (map #(Integer/parseInt %))\n        (filter #(let [ sqr (Math/sqrt %) ]\n                        (= sqr (Math/floor sqr))))\n        (interpose \",\")\n        (apply str)))", "user": "5398305fe4b0b51d73faaef6"}, {"problem": 74, "code": "(fn [t]\n        (apply str\n            (interpose \",\" \n                (map \n                    (fn [i] (.toString i))\n                    (filter \n                        (fn [x] (some #(= x (* % %)) (range 2 (- x 1))))\n                        (map #(Integer/parseInt %) (re-seq #\"\\d+\" t)))))))", "user": "5356d00ee4b04ce2eb3ed26f"}, {"problem": 74, "code": "(fn filter-perfect-number\n  [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(let [sqrt-root (Math/round (Math/sqrt %))]\n                  (= % (* sqrt-root sqrt-root))))\n       (map str)\n       (clojure.string/join \",\")))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer. %) (clojure.string/split s #\",\"))\n  perfects (set (map #(* % %) (range 1 (apply max nums))))]\n  (clojure.string/join \",\" (filter perfects nums))))", "user": "5368fedee4b0243289761e93"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (map str (filter #(== (Math/sqrt %) (int (Math/sqrt %))) (map #(read-string (str %)) (re-seq #\"\\d+\" s))))))", "user": "538e864ee4b0b51d73faae87"}, {"problem": 74, "code": "(fn filter-p-square [x]\n  (let [str-to-ints (fn [strs] \n                      (map read-string (clojure.string/split strs #\",\")))\n\n        is-perfect-square? (fn [x] \n                             (some #(= (* % %) x) (range (quot x 2) 1 -1)))]\n;    (str-to-ints x)\n    (apply str (drop-last (interleave (filter is-perfect-square? (str-to-ints x)) (repeat \\,))))\n  ))", "user": "53778b90e4b06839e8705e36"}, {"problem": 74, "code": "(fn [numbers] \n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\w+\" numbers))]\n   (apply str (interpose \",\" (filter #(= (Math/pow (Math/sqrt %) 2) (double %)) nums)))))", "user": "53a5c7ffe4b0ef122a8689c4"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map #(Integer. %))\n        (filter (fn [i] (let [q (Math/sqrt i)] (== q (int q)))))\n        (clojure.string/join \",\")))", "user": "537f4652e4b06839e8705eb1"}, {"problem": 74, "code": "(fn [nstr] (apply str (interpose \\, \n                                  (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))\n                                        (map #(Integer/parseInt %) (clojure.string/split nstr #\",\"))))))", "user": "534c1c64e4b084c2834f4a8a"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\"\n   (map first (filter #(== (second %)(last %))\n                      (map #(list % (Math/floor (Math/sqrt %)) (Math/sqrt %))\n                           (map read-string (.split s \",\")))))))", "user": "52d07cc5e4b07d0d72b273bb"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter (fn [s] (let [i (Integer. s)\n                             root (Math/sqrt i)]\n                         (= root (Math/floor root)))))\n       (clojure.string/join \",\")))", "user": "5080a697e4b01a93d3f38e49"}, {"problem": 74, "code": "(fn sq [s] \n  (let [nums (map #(. Integer (parseInt %)) (.split s \",\"))]\n    (apply str (interpose \",\" (filter #(= \n      (. Math (sqrt %) )\n      (. Math (floor (. Math (sqrt %))))) nums)))))", "user": "527367dfe4b03e8d9a4a747d"}, {"problem": 74, "code": "(fn\n  [a]\n  (let [is-square (fn [possible-square]\n                    (loop [curr 1]\n                      (cond\n                       (= (* curr curr) possible-square) true\n                       (= curr possible-square) false\n                       :else (recur (inc curr)))))]\n    (->>\n     (clojure.string/split a #\",\")\n     (map read-string)\n     (filter is-square)\n     (reduce #(str % \",\" %2))\n    )))", "user": "53ac4719e4b047364c04445c"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [perfect-square? (fn [n]\n                          (= (rem (Math/sqrt n) 1) 0.0))]\n  (->> (re-seq #\"\\d+\" s)\n       (filter (comp perfect-square? read-string))\n       (clojure.string/join \",\"))))", "user": "5396c94be4b0b51d73faaee3"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (filter (fn [n]\n                 (loop [i 1]\n                   (cond\n                    (< (* i i) n) (recur (inc i))\n                    (= (* i i) n) true\n                    (> (* i i) n) false))))\n       (clojure.string/join \",\")))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter (fn [x]\n                                 (let [sqrt (Math/pow x 0.5)]\n                                   (== sqrt (int sqrt))))\n                               (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (some #(= (* % %) n) (range n))) (map read-string (clojure.string/split s #\",\")))))", "user": "5245e320e4b09dbe66b56177"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [i] (= \\0 (last (print-str (Math/sqrt (Integer/parseInt i)))))) (re-seq #\"\\d+\" %)))", "user": "53ae16e2e4b047364c044472"}, {"problem": 74, "code": "(fn [l] (->> (clojure.string/split l #\",\")\n             (map #(Integer/parseInt %))\n             (filter #(= % (int (Math/pow (Math/floor (Math/sqrt %)) 2))))\n             (clojure.string/join \",\")))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 74, "code": "(fn [sstr]\n  (let [nlist (read-string (str \"(\" sstr \")\"))\n        sqguess (fn [n] (first (drop-while #(> n (* % %)) (map inc (range (/ n 2))))))\n        perf-sqs (filter #(let [s (sqguess %)] (and s (= % (* s s)))) nlist)]\n    (apply str (interpose \",\" perf-sqs))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 74, "code": ";(fn [s]\n;  (let [xs (map #(Float/parseFloat %) (clojure.string/split s #\",\"))\n;        squaresf (filter #(let [x (Math/sqrt %)] (= (* x x) %)) xs)\n;        squares (map (memfn toString) (map int squaresf))]\n;    (clojure.string/join \",\" squares)))\n\n;(fn [s]\n;  (let [ss (clojure.string/split s #\",\")\n;        squares (filter #(let [n (Float/parseFloat %) x (Math/sqrt n)] (= (* x x) n)) ss)]\n;    (clojure.string/join \",\" squares)))\n\n(fn [s]\n  (let [ss (clojure.string/split s #\",\")\n        squares (filter #(let [n (read-string %)] (zero? (rem (Math/sqrt n) 1))) ss)]\n    (clojure.string/join \",\" squares)))", "user": "5290257ae4b0239c8a67af03"}, {"problem": 74, "code": "(fn ps [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map read-string)\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (interpose \",\")\n       (apply str)))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter (fn [x]\n            (= (Double/parseDouble x)\n            (let [sr (Math/floor (Math/sqrt (Integer/parseInt x)))] (* sr sr))))\n    (clojure.string/split s #\",\"))))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 74, "code": "(fn perfect-squares[n]\n\t(letfn [(is-square? [x] \n\t\t\t\t(let [num (Integer/parseInt x) sqrt (.intValue (Math/sqrt num))]\n\t\t\t\t\t(= (* sqrt sqrt) num)))]\n\t(clojure.string/join \",\" (filter #(is-square? %) (.split n \",\")))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(ps? [x]\n            (let [r (java.lang.Math/sqrt (Integer/parseInt x))]\n              (zero? (compare r (int r)))))]\n    (clojure.string/join \",\" (filter ps? (clojure.string/split s #\",\")))))", "user": "4ef9b021535dced4c769f269"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \n   \",\" \n   (filter #(some (fn [x] \n                    (= (int (Math/pow x 2)) \n                       (Integer/parseInt %)))\n                  (range (Integer/parseInt %)))\n           (clojure.string/split s #\",\"))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [x] ; accept an int as string\n                          (let [sqrt (java.lang.Math/sqrt (read-string x))]\n                            (= (java.lang.Math/floor sqrt) sqrt)))]\n    (clojure.string/join \",\"\n                         (filter perfect-square?\n                                 (clojure.string/split s #\",\")))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 74, "code": "(fn perf-sqr [s]\n    (letfn [(perfect-sqr? [n] (== n (* (Math/sqrt n) (Math/sqrt n))))]\n        (apply str (interpose \",\" (filter perfect-sqr? (map #(Integer/valueOf %) (clojure.string/split s #\",\")))))))", "user": "532c9dc9e4b019098a6f8b30"}, {"problem": 74, "code": "(fn filter-perfect-squares [s] \n  (letfn [(perfect-square [n] \n               (zero? (mod n (Math/sqrt n))))]\n   (clojure.string/join \",\" \n    (filter \n     perfect-square\n     (map #(Integer/valueOf %) (re-seq #\"\\d+\" s))))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 74, "code": "(fn p-squares [nums-str]\n  (let [str-list (clojure.string/split nums-str #\",\")\n        num-list (map read-string str-list)\n        p-square? (fn [x] (and (> x 1)\n                            (let [root (Math/sqrt x)]\n                              (= root (Math/floor root)))))\n        squares (filter p-square? num-list)]\n    (clojure.string/join \",\" squares )))", "user": "52ee46e5e4b05e3f0be25ec5"}, {"problem": 74, "code": "(fn [args]\n  (reduce #(str %1 '\\, %2)\n          (filter #(= 0.0 (mod (Math/sqrt %) 1))\n                  (read-string (str \"(\" args \")\")))))", "user": "53ab17cae4b047364c04444a"}, {"problem": 74, "code": "(fn [x] \n  (->> (re-seq #\"\\d+\" x)\n       (filter (comp integer? rationalize #(Math/sqrt (Integer. %))))\n       (interpose \",\")\n       (apply str)))", "user": "5382704be4b06839e8705ed4"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [input-numbers (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        perfect-squares (map #(* % %) (range 1 (/ (last input-numbers) 2)))]\n    (apply str (interpose \",\" (filter #(>= (.indexOf perfect-squares %) 0) input-numbers)))))", "user": "52b71bd2e4b0c58976d9ad4d"}, {"problem": 74, "code": "(fn only-perfects [input]\n  (let [nums (map #(Integer. %) (clojure.string/split input #\",\"))\n        sqrts (map #(Math/sqrt %) nums)\n        perfects (filter #(= 0 (compare % (int %))) sqrts)]\n    (clojure.string/join \",\" (map #(* (int %) (int %)) perfects))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 74, "code": "(fn [st]\n     (clojure.string/join \",\"\n                          (filter (fn [n]\n                                      (let [n (Integer/parseInt n)\n                                              sqrt (Math/sqrt n)\n                                              fsqrt (Math/floor sqrt)]\n                                        (= sqrt fsqrt)))\n                                  (.split st \",\"))))", "user": "4f867b25e4b033992c121c51"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n    (clojure.string/join \",\" \n        (filter \n            (fn bar [num]\n                (let [n (int (Math/sqrt num))]\n                    (= (* n n) num))) \n            (map \n                #(Integer/parseInt %)\n                (clojure.string/split s #\",\")))))", "user": "53a94b63e4b047364c044434"}, {"problem": 74, "code": "(fn [s] \n   (->> \n     (clojure.string/split s #\",\")\n     (map #(Integer. %))\n     (filter \n       (fn [x] (some\n                 #(= (* % %) x)\n                 (range 1 x))))\n     (interpose \",\")\n     (apply str)))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 74, "code": "(fn [st]\n  (let [ ss (clojure.string/split st #\",\")\n         is (map #(Integer. %) ss)\n         fs (filter #(= (rem (java.lang.Math/sqrt %) 1) 0.0) is)\n         rs (apply str (interpose \",\" fs))\n         ]\n    rs))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 74, "code": "(fn f [s] (let [x (map read-string (clojure.string/split s #\",\"))] \n          (clojure.string/join \",\" (map #(str %)(filter #(= % (reduce + (take (Math/round(Math/sqrt %)) (range 1 1000 2))) ) x))) ) )", "user": "53b3ea79e4b047364c0444ab"}, {"problem": 74, "code": "(fn  [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map #(Integer/valueOf %))\n       (filter (fn [x]\n                 ((set (map #(* % %) (range (inc x)))) x)))\n       (interpose \\,)\n       (apply str)))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 74, "code": "(fn [s] \n   (let [ints (map #(Integer. %) (clojure.string/split s #\",\"))\n         squares (apply hash-set (for [x (range (apply max ints))] (* x x)))]\n     (clojure.string/join \",\" (filter squares ints))))", "user": "538db083e4b0b51d73faae74"}, {"problem": 74, "code": "(fn[s](apply str (interpose \",\"\n                  (filter \n                   #(and (not= \"\" %)\n                         (zero? (- (Math/sqrt (Integer/parseInt %)) (int (Math/sqrt (Integer/parseInt %)))))) \n                   (re-seq #\"[0-9]*\" s)))))", "user": "4e8849c5535d8b9bb0147ca4"}, {"problem": 74, "code": "(fn [s]\n  (reduce #(str % \\, %2)\n\t  (filter (fn [n]\n\t\t    (some #(= (* % %) n) (range n)))\n\t\t  (read-string (str \\[ s \\])))))", "user": "538d49e1e4b0b51d73faae6b"}, {"problem": 74, "code": "(fn [s] \n  (let [toInts (fn [nums] \n                 (map \n                  #(Integer/parseInt %) \n                  (clojure.string/split nums #\",\")))\n        perfectSquare? (fn [x]\n                         (let [bound (/ x 2)]\n                           (some \n                            #(= % (/ x %)) \n                            (range 2 (inc bound)))))]\n    (clojure.string/join \",\" (filter perfectSquare? (toInts s)))))", "user": "50be9b4ae4b00fb48fed2ef6"}, {"problem": 74, "code": "(fn [s]\n   (let [xs (map read-string (re-seq #\"\\d+\" s))\n         ys (take (apply max xs)  (map #(* % %) (range)))]\n     (clojure.string/join \",\"  (filter #(contains? (set ys) %) xs ))\n     )\n\n)", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 74, "code": "(fn ps [numStr]\n   (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" numStr))\n         perfect (filter #(== (mod (Math/sqrt %) 1) 0) nums)]\n     (apply str (interpose \",\" perfect))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter\n      (fn is-perf [n]\n        (let [q (int (java.lang.Math/sqrt n))]\n          (= (* q q) n)\n        )\n      )\n      (map #(java.lang.Integer/parseInt %) (seq (.split #\",\" s)))\n    )\n  )\n)", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 74, "code": "(fn [s]\n  (->>\n   (re-seq #\"\\d+\" s)\n   (map #(Integer/parseInt %))\n   (filter (fn [x] (let [r (int (Math/sqrt x))]\n                    (= x (* r r)))))\n   (interpose \",\")\n   (apply str)))", "user": "53da19fde4b0e771c3025484"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (apply str (interpose \",\"\n    (filter \n     (fn [x] \n       (let [r (int (Math/sqrt x))]\n         (= x (* r r))))\n     nums)))))", "user": "5224a46ce4b01819a2de42e5"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join \",\"\n                         (filter #(zero? (- % (java.lang.Math/pow (bigint (java.lang.Math/sqrt %)) 2)))\n                                 (map bigint (clojure.string/split s #\",\"))\n                                 )))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 74, "code": "(fn [s]\n\t(->> s\n\t\t(re-seq #\"\\d+\")\n\t\t(map #(Integer/decode %))\n\t\t(filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n\t\t(interpose \",\")\n\t\t(apply str)))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\"\n           (filter #(let [s (Math/sqrt (Integer/parseInt %))] (= s (Math/floor s)))\n              (re-seq #\"[0-9]+\" x))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 74, "code": "(fn perfect-square [string-coll]\n  (apply str (interpose \",\" \n    (reduce\n      #(let [sqrt (int (Math/sqrt (Integer/parseInt %2)))]\n        (println %2 sqrt)\n        (if (= (* sqrt sqrt) (Integer/parseInt %2))\n          (conj %1 %2)\n          %1))\n      []\n      (clojure.string/split string-coll #\",\")))))", "user": "53d40508e4b00fb29b221332"}, {"problem": 74, "code": "(fn [x]\n  (reduce \n   (fn [i j] (str i \",\" j))\n   (filter (fn [i] (let [j (Math/sqrt i)] (= j (Math/floor j)))) \n            (map read-string (re-seq #\"[1-9][0-9]*\" x)))))", "user": "53e91473e4b036ad0777e495"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (->> \n   (.split s \",\") \n   (map #(Integer/parseInt %)) \n   (filter #(= 0.0 (rem % (Math/sqrt %)))) \n   (map #(.toString %)) \n   (clojure.string/join \",\") ))", "user": "53c126fce4b00fb29b22125b"}, {"problem": 74, "code": "(fn [s]\n\t(clojure.string/join \",\"\n                         (filter #(== (Math/sqrt %) (int (Math/sqrt %)))\n            \t\t\t\t\t (map read-string (clojure.string/split s #\",\")))))", "user": "51ab70c3e4b04e3dc0c27b33"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= (double %) (* (Math/sqrt %) (Math/sqrt %))))\n       (clojure.string/join \",\")\n))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [n]  (let [m (Math/sqrt n)] (= (double n) (* m m)))) (map #(Integer/valueOf %) (clojure.string/split s #\",\")))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 74, "code": "(fn squares [st]\n  (->> (clojure.string/split st #\",\")\n       (map read-string)\n       (filter #(let [s (Math/sqrt %)] (= s (float (int s)))))\n       (clojure.string/join \",\")\n  ))", "user": "53ecac57e4b0d648e757f4b3"}, {"problem": 74, "code": "(fn perfect-squares [coll]\n  (->>(str \"[\" coll \"]\")\n      (read-string)\n      (filter #(zero? (mod (Math/sqrt %) 1)))\n      (clojure.string/join \",\")))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 74, "code": "(fn filter-sqr [xs]\n  (let [pred (fn [x]\n               (= x (last (take-while #(<= % x) (map #(* % %) (range))))))]\n    (clojure.string/join \\,\n                         (filter pred\n                                 (map #(Integer/parseInt %)\n                                      (clojure.string/split xs #\",\"))))))", "user": "53e27bf1e4b036ad0777e3f2"}, {"problem": 74, "code": "#(apply str \n\t(interpose \",\"\n   \t\t(sort (seq (clojure.set/intersection  \n    \t\t(set \n     \t\t\t(map  read-string \n           \t\t\t(clojure.string/split % #\"\\,+\")\n    \t\t))\n     \t\t(set (take 20 (apply map * (list (range) (range))))))\n\t\t))\n\t)\n)", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 74, "code": "#(->> (str \"[\" % \"]\")\n      read-string\n      (filter (fn [n] \n                (let [sqrt (Math/sqrt n)] \n                  (= sqrt (double (Math/floor sqrt))))))\n      (clojure.string/join \",\"))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 74, "code": "(fn filter-perfect-squares [s] \n  (->> \n   (clojure.string/split s #\",\")\n   (map #(Integer/parseInt %))\n   (remove #(let [r (Math/sqrt %), lr (long r)]\n              (not= % (* lr lr))))\n   (map str)\n   (interpose \\,)\n   (apply str)))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 74, "code": "(fn [s]\n  (let\n   [squares (map #(* % %) (range))]\n   (clojure.string/join\n    \",\"\n    (map str\n         (filter (fn [x] ((set (take-while #(<= % x) squares)) x))\n                 (map #(Integer. %) (clojure.string/split s #\",\")))))))", "user": "53e4fa2ce4b036ad0777e454"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(dissemble [s]\n            (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n          (perfect-square? [n]\n            (cond\n             (= 1 n) 1\n             :else (first (filter #(= (* % %) n) (range 1 n)))))\n          (find-sq [coll]\n            (filter perfect-square? coll))\n          (reassemble [coll]\n            (clojure.string/join \",\" coll))]\n    (-> s dissemble find-sq reassemble)))", "user": "4f774b17e4b0fbe0118ec57b"}, {"problem": 74, "code": "(fn [s] \n  (let [ints (map #(Integer/parseInt %) (clojure.string/split s #\"\\,\"))\n      filtered (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) ints)]\n    (apply str (interpose \",\" (map #(Integer/toString %) filtered)))))", "user": "53e241a6e4b036ad0777e3f0"}, {"problem": 74, "code": "(fn pr074 [s] \n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        filt (filter #(zero? (rem (Math/sqrt %) 1)) nums)]\n    (apply str (rest (interleave (cycle [\",\"]) filt)))))", "user": "51696ee7e4b03f62cda68ce8"}, {"problem": 74, "code": "(fn [s]  \n  (let [s (clojure.string/split s #\",\")\n        s (filter #(let [n (-> % Integer/parseInt Math/sqrt)] (== (Math/round n) n)) s)] \n    (clojure.string/join \",\" s)))", "user": "523578efe4b0a643f2dcb74c"}, {"problem": 74, "code": "(fn [s]\n  (let [l (map #(Integer. %) (clojure.string/split s #\",\"))\n        r (filter #(let [r (int (Math/sqrt %))] (= (* r r) %)) l)]\n    (clojure.string/join \",\" r)))", "user": "537e745ae4b06839e8705ea6"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (letfn [(isqrt [x] (int (Math/sqrt x)))]\n    (->> (.split s \",\")\n         (map #(Integer/parseInt %))\n         (filter #(= (* (isqrt %) (isqrt %)) %))\n         (interpose \\,)\n         (apply str))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 74, "code": "(fn [s]\n(clojure.string/join                     \n(interpose \",\"                      \n(filter #(let [i (.intValue (Math/sqrt %))] (= (* i i) %))\n          (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n )))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 74, "code": "(fn [s]\n    (let [is-square? #(seq (for [x (range %) :while (<= (* x x) %) :when (= (* x x) %)]\n                             x))]\n          (clojure.string/join \",\"\n                               (filter is-square?\n                                       (map read-string (re-seq #\"[0-9]+\" s))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter (fn [ss] (let [n (read-string ss)] \n                                         (first (filter #(= (int n) (* % %)) (range n)))))\n                              (clojure.string/split s #\",\"))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 74, "code": "(fn [s]\n  (let [all (map read-string (clojure.string/split s #\",\"))\n        big (apply max all)\n        squares (for [x all y (range (inc big)) :when (= (* y y) x)] x)]\n    (clojure.string/join \",\" squares)))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= (int (Math/pow (int (Math/sqrt %)) 2)) % ) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 74, "code": "(fn [string]\n  (let [is-square #(let [rt (Math/sqrt %)]\n                     (= rt (Math/floor rt)))\n        strings (clojure.string/split string #\",\")\n        numbers (map read-string strings)\n        squares (filter is-square numbers)\n        final-strings (loop [[hd & tl] squares\n                             final []]\n                        (if (empty? tl)\n                          (conj final hd)\n                          (recur tl (conj final hd \",\"))))]\n    (apply str final-strings)))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 74, "code": "(fn [s]\n  (letfn \n    [(str2intArray [] (read-string (str \"[\" s \"]\")))\n     (isSqr? [i] (some #(= i (* % %)) (range i)))]\n    (reduce #(str %1 \",\" %2)\n            (filter isSqr? (str2intArray)))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 74, "code": "(fn [s]\n  (apply str \n    (butlast \n     (interleave \n      (filter (fn [y] (some (set (map #(* % %) (range 100))) [y]))\n                         (map #(Integer/valueOf %) (clojure.string/split s #\",\")) \n                         ) (repeat \",\"))))                                 \n  )", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 74, "code": "( fn sqrt? [zah]\n    (let [sqrt? (fn [num] (= num (* ( int (Math/sqrt num)) (int (Math/sqrt num) ))))\n          tostr (fn [col] (apply str (rest (interleave (repeat \",\") col  ))))\n] \n      \n(tostr\n (filter sqrt?\n         (vec (map #( java.lang.Integer/parseInt %) ( .split zah \",\")))))))", "user": "5364ab34e4b0243289761e64"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\" (filter (comp integer? rationalize #(Math/sqrt %))\n           (map #(Integer. %) (clojure.string/split s #\",\")))))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 74, "code": "(fn [s]\n (apply str (rest (reduce #(concat %1 \",\" %2) \"\" \n  (filter (fn [n] (= (count (filter #(= (* % %) (read-string n))  (range (read-string n)))) 1))\n      (clojure.string/split s #\",\")\n  )\n )))\n)", "user": "51897709e4b0288ada3dbdaa"}, {"problem": 74, "code": "(fn[x]\n  (->> x\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter(fn[a](some #(= %(/ a %)) (range 1 a))))\n       (clojure.string/join \",\")\n))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 74, "code": "(fn [st]\n    (clojure.string/join \",\"\n      (filter\n        (fn [n] \n          (not \n            (empty? \n              (filter\n                #(= n (* % %))\n                (range -1 n)))))\n        (map\n          #(Integer. %)\n          (clojure.string/split st #\",\")))))", "user": "53d382d8e4b00fb29b22132a"}, {"problem": 74, "code": "(fn [s] (apply str(interpose \",\" (filter (fn [x] (let [r (.intValue (Math/sqrt x))] (= x (* r r))))  (map #(Integer/valueOf %) (.split s \",\"))))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 74, "code": "(fn [x]\n   (let [squares (fn [n]\n                   (set (map #(* % %) (range n))))\n         words (clojure.string/split x #\",\")\n         nums (map #(Integer/parseInt %) words)\n         sq (squares (reduce #(max %1 %2) nums))]\n     (->> (filter #(sq %) nums)\n          (map str)\n          (clojure.string/join \",\"))\n))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\" (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 74, "code": "(fn [u] \n  (apply str \n  \t(butlast \n      (apply concat \n        (interleave\n          (filter #(not (= \"\" %))\n            (map \n              (fn [x] \n                (let [y (read-string x)] \n                   (if (= (first (filter #(not (< % y)) (map (fn [w] (* w w)) (range))))  y) x \"\")))\n              (re-seq #\"\\w+\" u)))\n         (iterate identity \",\"))))))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "53be3ee7e4b0d9a98559a6df"}, {"problem": 74, "code": "(fn filter-perfect-squares [nums-string]\n  (let [nums (->>\n              (clojure.string/split nums-string #\",\")\n              (map #(Integer/parseInt %)))]\n    (letfn [(divisors [n]\n              (filter #(= 0 (mod n %)) (range 1 n)))\n\n            (perfect-square? [n]\n              (some #(= n (* % %)) (divisors n)))]\n\n      (->> nums\n          (filter perfect-square?)\n          (clojure.string/join \",\")))))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 74, "code": "(fn mm [arg]\n  (->> (re-seq #\"\\d+\" arg)\n       (map #(Integer. %))\n       (filter (fn [n]\n                 (let [sq (int (Math/sqrt n))]\n                   (= n (* sq sq)))))\n       (clojure.string/join \",\")))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 74, "code": "(fn [s] \n  \t(->> (clojure.string/split s #\",\") \n     (map read-string) \n     (filter #(= 0.0 (mod (Math/sqrt %) 1))) \n     (clojure.string/join \",\")))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(let [s (Math/sqrt (Integer. (str %)))]\n            (== s (int s)))\n      (clojure.string/split s #\",\"))))", "user": "53f77b6ae4b0de5c4184855f"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(unpack [s]\n                  (map read-string (clojure.string/split s #\",\")))\n          (pack [ns]\n                (apply str (interpose \",\" (map str ns))))\n          (sq? [n]\n               (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))]\n    (->> s\n        unpack\n        (filter sq?)\n        pack)))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is-square? [n] (let [sqrt (Math/sqrt n)] (zero? (- sqrt (long sqrt)))))]\n    (let [numbers (clojure.string/split s #\",\")]\n      (clojure.string/join \",\" (filter #(is-square? %) (map read-string numbers))))))", "user": "53710c09e4b0fc7073fd6ea5"}, {"problem": 74, "code": "(fn [s]\n (clojure.string/join \",\" (filter #(== (int (Math/sqrt %)) (Math/sqrt %)) \n          (map #(Integer/parseInt %) (clojure.string/split s,#\",\")\n               )\n  )\n )\n)", "user": "537b1083e4b06839e8705e64"}, {"problem": 74, "code": "(fn [s]\n   (apply str \n          (interpose \\, \n                     (filter #(let [n (read-string %) root (int (Math/sqrt n))] (= n (* root root))) \n                             (clojure.string/split s #\",\")))))", "user": "53ea5307e4b036ad0777e4e2"}, {"problem": 74, "code": "(fn perfect\n  [number-str]\n  (letfn [(parse-nums [s] \n            (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n          (stringify [coll] (apply str (interpose \",\" coll)))\n          (perfect-square? \n            ([n] (perfect-square? n 0 1))\n            ([n sum odd]\n            (cond\n              (= sum n) true\n              (> sum n) false\n              :else (perfect-square? n (+ odd sum) (+ 2 odd)))))]\n    (stringify (filter #(perfect-square? %) (parse-nums number-str)))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 74, "code": "(fn [cs]\n  (let [ns (map read-string (re-seq #\"\\d+\" cs))\n        isqr?\n        (fn [n]\n          (loop [m 2\n                 m' (inc m)\n                 n' (* m m)\n                 ]\n            (cond\n             (= n n') true\n             (< n n') false\n             (<= n' m) false\n             :else\n             (recur m' (inc m') (* m' m') )))\n          )\n        ns' (filter isqr? ns)\n        sqs (map str ns')\n        ]\n    (if (empty? sqs)\n      sqs\n      (reduce\n       (fn [s1 s2] (str s1 \",\" s2))\n       sqs)\n      )\n    )\n  )", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 74, "code": "(fn [col] (->> (re-seq #\"\\d+\" col)\n       (map read-string)\n       (filter (comp not ratio? rationalize #(Math/sqrt %)))\n       (interpose \",\")\n       (apply str)))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 74, "code": "(fn [s]\n\n   (apply str (interpose \",\"\n   ( filter (fn [n] (some #(= n %) (map #(* % %) (range n))))\n         (map read-string (clojure.string/split s #\",\"))))))", "user": "54094824e4b0addc1aec66da"}, {"problem": 74, "code": "(fn [input]\n  (clojure.string/join \",\"\n    (filter\n      (fn [n]\n        (#(= 0.0 (- (int %) %))\n          (Math/sqrt (Integer/parseInt n))))\n      (clojure.string/split input #\",\"))))", "user": "528bba38e4b0239c8a67aea9"}, {"problem": 74, "code": "(fn [x]\n  (->> (clojure.string/split x #\",\")\n     (map #(Integer/parseInt %1))\n\t (filter #(= (-> %1 (Math/sqrt) (Math/pow 2)) (double %1)))\n\t (clojure.string/join \",\" )))", "user": "51eec1a6e4b0871fa145d98d"}, {"problem": 74, "code": "(fn [s]\n  (let [\n    perfect? (fn [x] (let [sq (int (Math/sqrt x))] (= (* sq sq) x)))\n    numbers (map (fn [x] (Integer. x)) (clojure.string/split s #\",\"))]\n\n    (clojure.string/join \",\" (filter perfect? numbers))))", "user": "540d5085e4b0addc1aec670e"}, {"problem": 74, "code": "(fn [s]\n  (->> (.split s \",\")\n       (map read-string)\n       (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n       (interpose \",\")\n       (apply str)))", "user": "507330e6e4b0e3170b5a8698"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (letfn [(sqr? [n i]\n              (cond\n               (< n 0) false\n               (= 0 n) true\n               :else (sqr? (- n i) (+ i 2))))]\n     (letfn [(sqrs [[num & res] acc]\n               (if num\n                 (sqrs res (if (sqr? num 1) (conj acc num) acc))\n                 (apply str (interpose \",\" (map str acc)))))]\n       (sqrs nums [])))))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n    \",\"\n    (filter #(let [x (Math/sqrt %)]\n               (= x (Math/floor x)))\n            (map read-string\n                 (clojure.string/split s #\",\")))))", "user": "54084784e4b0addc1aec66c9"}, {"problem": 74, "code": "(fn fps [s]\n  (let [str-a (clojure.string/split s #\",\")\n        num-a (map read-string str-a)\n        ss (map #(* % %) (range 2 10))\n        ret (filter (set ss) (set num-a))\n        ret-s (map str (sort ret))]\n    (clojure.string/join \",\" ret-s)))", "user": "53d86564e4b0e771c302546b"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (for [s (map #(Integer/parseInt %) (.split s \"[,]\")) :when (= 0.0 (- (Math/round (Math/sqrt s)) (Math/sqrt s)))] s)))", "user": "4df9c598535d04ed9115e77a"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(not (empty? (for [x (range (inc (quot % 2))) :when (= (* x x) %)] x)))\n                                   (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n                           )\n  )\n)", "user": "540f09b9e4b0addc1aec6725"}, {"problem": 74, "code": "(fn [x] (clojure.string/join\",\" (map str (filter (complement nil?) (for [a (map read-string (clojure.string/split x #\",\" ))\n               :let [sa (Math/sqrt a)\n               b (* sa sa)]]\n           (if (== a b) a)\n           ) )) ) )", "user": "540479e7e4b0addc1aec665a"}, {"problem": 74, "code": "(fn filter-perfect-square\n  [xs]\n  (let [xs (map read-string (clojure.string/split xs #\",\"))]\n    (clojure.string/join \",\" (filter (fn [x]\n                                       (let [sqrt (Math/round (Math/sqrt x))]\n                                         (= (* sqrt sqrt) x)))\n                                     xs))))", "user": "53e8c684e4b036ad0777e48b"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \\,\n    (filter #(zero? (mod (Math/sqrt %) 1))\n            (map read-string (.split s \",\")))))", "user": "53806e5be4b06839e8705ec1"}, {"problem": 74, "code": "#(apply str (interpose \",\" \n                       (filter (fn[s]\n                                 (let [si (Integer/parseInt s)\n                                       sqrtSi (int (Math/sqrt si))]\n                                   (= (* sqrtSi sqrtSi) si)))\n                               (vec (.split #\",\" %)))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 74, "code": "(fn [input] \n  (clojure.string/join\n   \",\"\n   (filter (fn [a] (some #(= a (* % %)) (range 1 a))) \n    (map #(Integer/parseInt %) (.split input \",\")))))", "user": "539c88e1e4b0b51d73faaf2c"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (read-string (str \"(\" s \")\"))\n        squares (map #(* % %) (range))\n        known-squares (set (take-while (partial >= (apply max nums)) squares))]\n    (apply str (interpose \",\" (filter known-squares nums)))))", "user": "4fad9da0e4b081705acca23c"}, {"problem": 74, "code": "(fn [s]\n  (->> (.split s \",\")\n       (map #(Integer/parseInt %))\n       (filter #(let [x (Math/sqrt %)] (= (Math/floor x) x)))\n       (clojure.string/join \",\")))", "user": "54157dace4b01498b1a719f4"}, {"problem": 74, "code": "(fn [s]\n  (apply str (interpose \",\" \n                        (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n                                (map read-string (re-seq #\"[0-9]+\" s))))))", "user": "52c672e2e4b0c2d177d6210e"}, {"problem": 74, "code": "(fn [s]\n  (let \n    [perfect-squares (map #(* % %) (iterate inc 1))\n     perfect-square? (fn [n] (= n (first (drop-while #(< % n) perfect-squares))))\n     values (map read-string (re-seq #\"\\d+\" s))]\n    (clojure.string/join \",\" (filter perfect-square? values))))", "user": "53f35c34e4b0742d9025b0f4"}, {"problem": 74, "code": "(fn [xs]\n\t(clojure.string/join \",\" (filter #(let [sq (Math/sqrt %)] (= (float %) (* sq sq))) (map #(Integer/parseInt %) (.split #\",\" xs)))\n))", "user": "5409f8eae4b0addc1aec66e6"}, {"problem": 74, "code": "(fn [st]\n  (let [nums (set (map #(Integer. %) (re-seq #\"\\d+\" st)))\n        psqs (set (take (apply max nums) (map #(* % %) (iterate inc 2))))]\n    (apply str (interpose \\, (sort (clojure.set/intersection nums psqs))))))", "user": "4eb3fcba535d7eef30807359"}, {"problem": 74, "code": "(fn [input-str]\n  (clojure.string/join \",\" (filter #(let [sqrt (Math/sqrt (Integer/parseInt %))]\n                   (= 0.0 (- sqrt (int sqrt)))) (clojure.string/split input-str #\"\\,\"))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 74, "code": "(fn [x]\n  (let [sqrt (fn [x] (int (Math/sqrt (Integer. x))))\n        perfect-squares (filter #(= (int (Math/pow (sqrt %) 2)) (Integer. %)) (re-seq #\"\\d+\" x))]\n    (apply str (interpose \",\" perfect-squares))))", "user": "51ca5378e4b08b1cbd0d9480"}, {"problem": 74, "code": "(fn fsq [s]\n    (letfn [(perfect-root? [x]\n              (let [root (int (Math/sqrt x))]\n                (= x (* root root))))]\n      (clojure.string/join \",\" (filter perfect-root? (map #(Integer/parseInt %) (re-seq #\"\\w+\" s))))))", "user": "5429986ce4b01498b1a71b3b"}, {"problem": 74, "code": "#(apply str (interpose \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (re-seq #\"[0-9]+\" %))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= (Math/sqrt %) (Math/ceil (Math/sqrt %))))\n       (interpose \",\")\n       (apply str)))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \\, (filter #(= % ((fn [x] (* x x)) (int (Math/sqrt %)))) (map read-string (clojure.string/split s #\",\"))))))", "user": "542f574be4b0dad94371f2d0"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter\n      (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x))))\n  \t  (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "50d882d4e4b01f0871336e69"}, {"problem": 74, "code": "(fn [inp]\n  (let [perfect-sq? (fn [n] (some #(= n (* % %)) (range 2 (inc (int (/ n 2))))))\n        nums (map #(Integer/parseInt %) (clojure.string/split inp #\",\"))]\n    (apply str (interpose \",\" (map str (filter perfect-sq? nums))))))", "user": "542c22bde4b0dad94371f29e"}, {"problem": 74, "code": "(fn pf\n  [init]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split init #\",\"))]\n    (clojure.string/join \",\" (filter (fn chulai [x] (some true? (map #(= (* % %) x) (range x)))) nums))\n))", "user": "53d6b266e4b0e771c3025459"}, {"problem": 74, "code": "(fn [s]\n  (apply str (interpose \",\" (filter\n                              #(let [r (Math/sqrt %)] (= (float %) (* r r)))\n                              (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" s))))))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 74, "code": "(fn c-squares [s]\n        (let [s-nums (clojure.string/split s #\",\")]\n          (->> s-nums\n               (map (fn [s] (Math/sqrt (Integer/parseInt s))))\n               (filter (fn [i] (re-seq #\"\\.0$\" (.toString i))))\n               (map (fn [i] (str (int (Math/pow i 2)))))\n               (clojure.string/join \",\"))))", "user": "541ae7dbe4b01498b1a71a61"}, {"problem": 74, "code": "(fn [x](clojure.string/join \",\" (filter #(= (rem (Math/sqrt %) 1 ) 0.0) (map #(Integer/parseInt %) (.split x \",\")))))", "user": "538d70abe4b0b51d73faae6e"}, {"problem": 74, "code": "(fn filter-perfect-square [xs]\n  (letfn [(is-perfect-square [x] (let [s (Math/sqrt x)]\n                                   (= (Math/floor s) (Math/ceil s))))]\n    (->> \n      xs \n      (.split #\",\") \n      (map read-string) \n      (filter is-perfect-square)\n      (interpose \",\")\n      (apply str))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 74, "code": "(fn [st] (let [xs (map read-string (clojure.string/split st #\",\"))\n                all (take-while #(<= % (apply max xs)) (map #(* % %) (range)))\n                res (for [xs xs\n                          all all\n                          :when (= xs all) ]\n                      xs)] \n            (clojure.string/join (interpose \",\" res))))", "user": "531bfb69e4b08068f379ed97"}, {"problem": 74, "code": "(fn [str] \n    (letfn [(filter-squares  [ coll ]\n              (filter #(= 0.0 (rem (Math/sqrt %1) 1)) coll))]\n      (let [numbers (map read-string (clojure.string/split str #\",\"))]\n        (clojure.string/join #\",\" (filter-squares numbers))\n        )\n      ))", "user": "5433a07be4b0b6b47310fce0"}, {"problem": 74, "code": "(fn [in]\n    (let [int? #(= (double %) (double (Math/round (double %))))]\n      (->> (clojure.string/split in #\",\")\n           (map read-string)\n           (filter #(int? (Math/sqrt %)))\n           (clojure.string/join \",\"))))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 74, "code": "(fn [s]\n  (apply str\n    (interpose \",\"\n      (filter\n        (fn [n] ((apply hash-set (map #(* % %) (range 0 n))) n))\n        (map #(Long/parseLong %) (re-seq #\"\\d+\" s))))))", "user": "54397533e4b032a45b86931d"}, {"problem": 74, "code": "(fn [s]\n  (let [squares* (fn [] (map #(* % %) (range)))\n        square? (fn [n] (= (last (take-while #(<= % n) (squares*))) n))]\n    (->> (clojure.string/split s #\",\") \n         (map #(Integer/parseInt %)) \n         (filter square?) \n         (clojure.string/join \",\"))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 74, "code": "(fn [input]\n      (->> (clojure.string/split input #\",\")\n           (map #(Integer/valueOf (str %)))\n           (filter (fn [n]\n                     (let [sqrt-n (int (Math/sqrt n))]\n                       (= n (* sqrt-n sqrt-n)))))\n           (clojure.string/join \",\")))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 74, "code": "(fn [num-str]\n  (clojure.string/join \",\"\n                       (filter #(= (double (int (Math/sqrt %)))\n                                   (Math/sqrt %))\n                               (map #(Integer/parseInt %) (clojure.string/split num-str #\",\")))))", "user": "53940789e4b0b51d73faaec3"}, {"problem": 74, "code": "(fn [s] (let [num (map #(Integer/valueOf %) (clojure.string/split s #\",\"))] (apply str (interpose \",\" (filter (fn [x] (= (- (Math/pow (Math/sqrt (int x)) 2)  x ) 0.0)) num)))))", "user": "542edb4ae4b0dad94371f2c8"}, {"problem": 74, "code": "(fn [s]\n  (let [n (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        f #(apply str (interpose \",\" (map (comp str int) %)))]\n    (f (filter #(zero? (rem (Math/sqrt %) 1)) n))))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 74, "code": "(fn [arg]\n  (letfn [(is_square [n] (some #(= % n) (map #(* % %) (range n))))]\n    (->> (filter is_square (map read-string (re-seq #\"\\d+\" arg)))\n         (interpose \",\")\n         (apply str))))", "user": "543f854fe4b032a45b86935b"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\"\n                     (map str \n                      (filter \n                       #(zero? (mod (Math/sqrt %) 1)) \n                       (map read-string \n                        (clojure.string/split s #\",\")))))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 74, "code": "(fn [s]\n  (let [psquares (set (map #(* % %) (range 100)))\n        nums (map read-string (re-seq #\"\\d+\" s))]\n    (->> nums\n         (filter psquares)\n         (interpose \",\")\n         (apply str))))", "user": "54448e84e4b032a45b869393"}, {"problem": 74, "code": "(fn f1 [s]\n  (clojure.string/join \",\" (filter #(some #{%} [\"4\" \"9\" \"16\" \"25\" \"36\"]) (clojure.string/split s #\",\"))))", "user": "54349368e4b0b6b47310fcf1"}, {"problem": 74, "code": "(fn [inp]\n (let [inp inp\n      s (map #(Integer. %) (re-seq #\"\\d+\" inp))\n      sqs (set (map #(* % %) (range (last s))))]\n  (apply str (interpose \",\" (filter sqs s)))))", "user": "532a033be4b09d4e7a9b551f"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \\, \n                       (filter #(== (mod (Math/sqrt (Integer/parseInt %)) 1) 0)\n                               (clojure.string/split s #\",\"))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 74, "code": "(fn [num-str]\n  (let [coll (map #(Integer/parseInt %) (clojure.string/split num-str #\",\"))]\n    (clojure.string/join \",\"\n      (filter #(= (Math/sqrt %) (double (int (Math/sqrt %)))) coll ))))", "user": "53f6bfd9e4b0db01ade6f9e4"}, {"problem": 74, "code": "(fn [s] (let [l (clojure.string/split s #\",\")] (reduce #(str % \",\" %2) (filter #(= (mod (Math/sqrt %) 1) 0.0) (map read-string l)))))", "user": "5441f5e8e4b032a45b869375"}, {"problem": 74, "code": "(fn [ss]\n  (let [perfect-square (fn [n]\n                         (some #(= n %)\n                               (map #(* % %)\n                                    (range n))))\n        from-string (fn [s]\n                      (map #(. Integer parseInt %)\n                           (clojure.string/split s #\",\")))\n        to-string (fn [s]\n                    (clojure.string/join \",\" (map str s)))]\n    (to-string (filter perfect-square\n                       (from-string ss)))))", "user": "51baff1be4b0fe3ecfb46443"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (clojure.string/join \",\"\n        (filter (fn [n]\n                  (= (last (for [x (range n)\n                                 :let [y (* x x)]\n                                 :while (<= y n)]\n                             y))\n                     n))\n         (map read-string (clojure.string/split s #\",\")))))", "user": "54125eeee4b01498b1a719d3"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is-perf-sq? [sn]\n                       (let [n (Integer/parseInt sn)\n                             sqn (Math/sqrt n)\n                             rnd (long sqn)]\n                         (zero? (- sqn rnd))))]\n    (clojure.string/join \",\" (filter is-perf-sq? (.split s \",\")))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [x] (let [root (int (Math/sqrt x))]\n                         (= x (* root root)))))\n       (map #(Integer/toString %))\n       (clojure.string/join \",\")))", "user": "53968a70e4b0b51d73faaee0"}, {"problem": 74, "code": "(fn [s]\n   (let [square? (fn [nstr] \n                   (let [sq (Math/sqrt (Integer/parseInt nstr))]\n                     (== sq (int sq))))\n         nums (clojure.string/split s #\",\")]\n     (clojure.string/join \",\" (filter square? nums))))", "user": "5370d152e4b0fc7073fd6e9d"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Integer. %) (clojure.string/split s #\",\"))\n        p? (fn [x] (some #(= x (* % %)) (range 2 x)))]\n    (clojure.string/join \",\" (filter p? xs))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\") (map  #(Integer/parseInt %)) (filter #(== (Math/sqrt %) (->> (Math/sqrt %) (int)))) (clojure.string/join \",\")))", "user": "5409a12fe4b0addc1aec66df"}, {"problem": 74, "code": "(fn [s] \n  (let [_nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n      (apply str (interpose \",\" (sort (vec (clojure.set/intersection (set _nums) (set\n        (loop [sq [1], i 2, j (apply max _nums)] \n           (if (>= (last sq) j) \n             sq \n             (recur (conj sq (* i i)) (inc i) j)\n        ))))))))\n))", "user": "54524afbe4b0e397800069bc"}, {"problem": 74, "code": "(fn\n  [s]\n  (letfn [(perfect-square?\n    [n]\n    (= (int (Math/pow (int (Math/sqrt n)) 2)) n))]\n    (let [xs (clojure.string/split s #\",\")]\n      (clojure.string/join \",\" (filter perfect-square? (map #(Integer. %) xs))))))", "user": "4fee04a0e4b0678c553fc308"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter #(let [n (Math/sqrt (read-string %))]\n               (= (float (int n)) n))\n      (clojure.string/split s #\",\"))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 74, "code": "(fn [s]\n  (let [string-list (clojure.string/split s #\",\")\n        num-list (map #(Integer. %) string-list)\n        to-return (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)) num-list)]\n    (clojure.string/join \",\" to-return)))", "user": "53322cece4b019098a6f8b73"}, {"problem": 74, "code": "(fn squares [string] (let [numbers (vec (map read-string (clojure.string/split string #\",\")))] (apply str (interpose \",\" (remove #(nil? %) (map (fn [x] ((set (map #(* % %) (range (+ 2 (int (Math/sqrt (apply max numbers))))))) x)) numbers))))))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\" (filter #(= (read-string %) (int (Math/pow (int (Math/sqrt (read-string %))) 2)))\n          (re-seq #\"[0-9]+\" s))))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 74, "code": "(fn [ns]\n  (->> (re-seq #\"\\d+\" ns)\n       (map #(Integer/parseInt %))\n       (filter #(let [s (Math/sqrt %)] (zero? (- s (Math/floor s)))))\n       (clojure.string/join \",\")))", "user": "505aa653e4b021387fb89857"}, {"problem": 74, "code": "( fn perf-squar [s] \n  \t(let [ nums ( map #(Integer/parseInt %) ( clojure.string/split s #\",\"))\n           all-perf-sq (set (map #(* % %) (range 100)))\n           sq-nums ( filter all-perf-sq nums)]\n      (apply str ( interpose \",\" sq-nums))))", "user": "516d227fe4b06f078fab252d"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" \n                             (filter (fn [n] (== (#(* % %) (Math/floor (Math/sqrt n))) n)) \n                                     (map read-string (clojure.string/split s #\",\")))))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [n] (let [x (int (Math/sqrt n))]\n                                             (= n (* x x)))) \n                                   (map (fn [x] (Integer/parseInt x)) (clojure.string/split %, #\",\"))))", "user": "544e9022e4b0e3978000698b"}, {"problem": 74, "code": "(fn [csi]\n  (let [integers (clojure.string/split csi #\",\")]\n    (clojure.string/join #\",\" \n                         (filter #(let [x (read-string %)]\n                                    (= (let [s (int (java.lang.Math/sqrt x))]\n                                         (* s s))\n                                       x))\n                                 integers))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 74, "code": "(fn [comma-sep-nums]\n  (apply str (interpose \",\" \n                        (clojure.core/reduce (clojure.core/fn [acc val] (let [str-val (str (Math/sqrt (Integer. val)))] (if (.endsWith str-val \".0\") (conj acc val) acc))) [] (clojure.string/split comma-sep-nums #\",\"))\n                        \n                        )))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 74, "code": "(fn [s]\n    (apply str \n      (interpose \",\"\n        (for [x (re-seq #\"\\d+\" s)\n          :let [xint (Integer/parseInt x)]\n          :when (= 0.0 (mod (Math/sqrt xint) 1))] x))))", "user": "537bde5de4b06839e8705e73"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n   (map read-string)\n   (filter #(some true? (for [div (range 2 %)]\n              (and (= (quot % div) div)\n                   (zero? (rem % div))))))\n   (clojure.string/join \",\")))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 74, "code": "(fn [numbers]\n  (apply str (interpose \",\" (filter (fn [n]\n  (let [x (.intValue (Math/sqrt (Integer/parseInt n)))\n         xx (* x x)]\n    (= xx (Integer/parseInt n)))) (clojure.string/split numbers #\",\")))))", "user": "5047782ce4b0371827a27bc2"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %) (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"}) (clojure.string/join \",\") )", "user": "546280d8e4b01be26fd746b0"}, {"problem": 74, "code": "(fn [s] \n   (let [nums (map \n             #(Integer/parseInt %) \n             (re-seq #\"\\d+\" s))\n         perfect_square? #(== (mod (Math/sqrt %) 1) 0)\n         perfect_squares (filter perfect_square? nums)\n         ]\n\n    (clojure.string/join \",\" perfect_squares)\n   ))", "user": "5412646de4b01498b1a719d4"}, {"problem": 74, "code": "(fn [s]\n  (let [l (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n        fl \n        (filter \n          (fn [i]\n            (let [sqrt-i (int (. Math (sqrt i)))]\n              (= i (* sqrt-i sqrt-i)))) l)]\n    (apply str (interpose \",\" fl))))", "user": "53bd7080e4b0d9a98559a6d1"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (filter (fn [x] (let [y (Double/parseDouble x)] (=  y (Math/pow (Math/sqrt y) 2)))) (re-seq #\"\\d+\" s)))))", "user": "5464a536e4b01be26fd746cf"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(== (mod (Math/sqrt %) 1) 0)\n                                   (map read-string (clojure.string/split s #\",\")))))", "user": "5136f659e4b04059df19f2fd"}, {"problem": 74, "code": "(fn ps [strcoll]\n  (apply str (interpose \",\"\n    (filter #(= (double %) (* (Math/sqrt %)\n                              (Math/sqrt %)))\n            (map #(Integer/valueOf %)\n                 (clojure.string/split strcoll #\",\"))))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 74, "code": "#(if (= \\4 (get % 0))\n  \"4,9\"\n  \"16,25,36\")", "user": "4eda8d7c535d10e5ff6f530f"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map bigint (clojure.string/split s #\",\"))\n        square? (fn [x]\n                  (let [sqrt-x (Math/sqrt x)\n                        int-sqrt (Math/round sqrt-x)\n                        back (* int-sqrt int-sqrt)]\n                    (= back x)))]\n    (apply str (interpose \",\" (filter square? nums)))))", "user": "5479c58de4b0c51c1f4d72c7"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5460f59ce4b01be26fd74695"}, {"problem": 74, "code": "(fn perfect-squares [string]\n  (let [values (map #(Integer. %) (re-seq #\"\\d+\" string))\n        sqrs (map #(* % %) (range))]\n    (clojure.string/join \",\" (sort (clojure.set/intersection (set values) (set (take (apply max values) sqrs))))))\n  )", "user": "541f5b37e4b01498b1a71a97"}, {"problem": 74, "code": "(fn [s]\n  (let [numbers (clojure.string/split s #\",\")]\n    (clojure.string/join \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) (map #(Integer. %) numbers)))))", "user": "5472cba1e4b094393f72dd7a"}, {"problem": 74, "code": "(fn filter-sq [s]\r\n  (clojure.string/join \",\"\r\n    (filter\r\n      (fn [x] \r\n        (= x (last (take-while \r\n                     #(<= % x) \r\n                     (map #(* % %) (range))))))\r\n      (map #(Integer. %) (re-seq #\"\\d+\" s)))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 74, "code": "(fn [s]\n  (apply str \n         (interpose \",\" \n                    (let [squares (map #(* % %) (iterate inc 1))]\n                      (filter \n                       (fn [x] (some #(= % x) (take x squares))) \n                       (map #(Integer. %) (re-seq #\"\\d+\" s)))))))", "user": "5478e57de4b0c51c1f4d72c1"}, {"problem": 74, "code": "(fn [input]\n  (let [perfect-square? (fn [n]\n                          ((comp #(some identity %) concat)\n                          \t(for [i (range n)]\n                            \t(if (= (* i i) n)\n                              \t\ttrue\n                              \t\tfalse))))]\n    (clojure.string/join \",\" (filter #(perfect-square? (Integer. %)) (clojure.string/split input #\",\")))))", "user": "546c4c5fe4b00cfc9eacc178"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n      ((fn [s]\n         (map #(Integer. %) (clojure.string/split s #\",\"))))\n      ((fn [c]\n         (filter (fn [i] (let [rt (int (Math/sqrt i))\n                               rtd (dec rt)\n                               rti (inc rt)]\n                           (or (= i (* rt rt)) (= i (* rti rti)) (= i (* rtd rtd)))))c)))\n      (map str)\n      (clojure.string/join \",\")))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (map str (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 74, "code": "(fn [s] \n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter (fn [n] (zero? (rem n (Math/sqrt n)))))\n       (interpose \",\")\n       (apply str)))", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 74, "code": "(fn [str]\n  (clojure.string/join\n   \",\" (filter (fn [x]\n             (= (mod (Math/sqrt (Integer/parseInt x)) 1) 0.0))\n               (.split str \",\"))))", "user": "546c1f73e4b00cfc9eacc175"}, {"problem": 74, "code": "(fn [numstr]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split numstr #\",\"))]\n    (clojure.string/join \",\"\n                         (filter (fn [n]\n                                    (some #(= n (* % %)) (range 1 (inc (/ n 2))))) \n                                  nums))))", "user": "5478c4fee4b0c51c1f4d72c0"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %)\n                  (clojure.string/split s #\",\"))\n        is-square #(= % (-> % Math/sqrt int (Math/pow 2) int))]\n    (clojure.string/join \",\" (filter is-square nums))))", "user": "4e6a2f93535d8ccf87e9feaa"}, {"problem": 74, "code": "(fn [v]\n  (let [x (map #(Integer/valueOf %) (clojure.string/split v #\",\"))]\n    (->>\n     (filter #(= 0.0 (rem (* 10 (Math/sqrt %)) 10)) x)\n     (clojure.string/join \",\")\n     )))", "user": "5486adf7e4b0e286459a11be"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\"\n     (filter\n      (fn [x]\n        (let [sqr (Math/sqrt x) sqr-whole (Math/floor sqr)]\n          (= sqr sqr-whole))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "53c06438e4b0c98a41f5ccb0"}, {"problem": 74, "code": "(fn [s] \n  (letfn [(square [x] (* x x))]\n  (clojure.string/join \",\" \n                       (filter #(= % (square (int (java.lang.Math/sqrt %))))                                            \n                                   \n                               (map read-string (clojure.string/split s #\",\"))))))", "user": "54857e3be4b0e286459a11ad"}, {"problem": 74, "code": "(fn pfs [s]\n  (let [xs (clojure.string/split s #\",\")\n        sqs (into #{} (map str (map #(* % %) (range 2 7)) ))\n        res (filter sqs xs)\n        ]\n    (clojure.string/join \",\" res)\n    )\n  )", "user": "5488872ee4b0e286459a11d3"}, {"problem": 74, "code": "(fn[s]\n  (let [vec2num\n           (fn [v]\n           \"turn a list of chars to a number\"\n             (\n               (fn v2n [v n tot]\n                 (if (empty? v)\n                   tot\n                   (let [d (reduce * (repeat n 10))]\n                     (v2n (rest v) (inc n) (+ tot (* d (- (int (first v))(int \\0)))))\n                   )\n                 )\n               ) \n               (reverse v) 0 0\n             )\n           )\n\n        str2coll\n            (fn [s]\n            \"return list of integers from a string of numbers\"\n               (map vec2num (filter (fn[x] (not= x '(\\,)))(partition-by (fn[a](= a \\,)) s)))\n            )\n\n\n        square? \n         (fn[nmb]\n         \"test if a given number is a perfect square\"\n           (if (= nmb 1)\n             true \n             (let [x (last (for [n (range 1 nmb) :while(<= n (int (/ nmb n))) :when(= (mod nmb n) 0)] n))]\n               (if (nil? x)\n                 false\n                 (= (* x x) nmb)\n               )\n             )\n           )\n         )\n       ]\n\n    (apply str (butlast (interleave (concat (map (fn[x](pr-str x)) (filter square? (str2coll s)))) (repeat \",\") )))\n  )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let [nums (map read-string (clojure.string/split s #\",\"))\n        square? (fn [n]\n                  (let [root (Math/sqrt n)]\n                    (= (Math/floor root) root)))\n        squares (filter square? nums)]\n    (apply str (interpose \",\" squares))))", "user": "542c026ae4b0dad94371f29a"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\")\n        (map read-string)\n        (filter (fn [x]\n                  (= (Math/sqrt x)\n                     (-> x Math/sqrt int double))))\n        (map str)\n        (clojure.string/join \",\"))", "user": "51e3a549e4b0c611d6113e47"}, {"problem": 74, "code": "#(clojure.string/join \",\" (map str (filter\n            (fn [x]\n              (let [max (/ x 2)]\n                (loop [done? false\n                       perfect? false\n                       sqr 1]\n                  (if (or done? (> sqr max))\n                    perfect?\n                    (if (= (* sqr sqr) x)\n                      (recur true true (inc sqr))\n                      (recur false false (inc sqr)))))))\n            (map (fn [x] (java.lang.Integer/parseInt x)) (clojure.string/split % #\",\")))))", "user": "52c58561e4b0c2d177d620f8"}, {"problem": 74, "code": "(fn [nums]\n\t(apply\n\t\tstr\n\t\t(interpose\n\t\t\t\",\"\n\t\t\t(filter\n\t\t\t\t(fn [x]\n\t\t\t\t\t(let [n (read-string x)]\n\t\t\t\t\t\t(let [div (Math/sqrt n)]\n\t\t\t\t\t\t\t(== (* div div) n)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t(clojure.string/split nums #\",\"))\n\t\t)\n\t)\n)", "user": "5472d919e4b094393f72dd7b"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [str-v (clojure.string/split s #\",\")\n        num-v (map  #(Integer/parseInt %) str-v)\n        nums (filter #(some (fn [n] (= % (* n n))) (range (inc (/ % 2)))) num-v)]\n    (clojure.string/join \",\" nums)))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 74, "code": "(fn [s]\n  (apply str\n         (interpose \",\"\n                    (filter (fn [n] (some #(= (* % %) n) (range n)))\n                            (map #(Integer/parseInt %) (re-seq #\"\\w+\" s))))))", "user": "5466aabbe4b01be26fd746e8"}, {"problem": 74, "code": "#(clojure.string/join \",\"\n                     (remove nil?\n                     (reduce \n  (fn [x y] \n      (conj x\n         (let [num (Integer/parseInt y)\n               root (int (Math/sqrt num))]\n         (if (= (* root root) num) num)))) \n        [] (clojure.string/split % #\",\"))))", "user": "542c44f8e4b0dad94371f2a1"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(< (mod (Math/sqrt %) 1) 0.000001))\n       (clojure.string/join \",\")))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        ff (fn [n] (some #(= (* % %) n) (range n)))]\n    (clojure.string/join \",\" (filter ff xs))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 74, "code": "(fn [s] \n   (clojure.string/join \",\"\n     (filter (fn [x]\n              (let [sqrt-x (Math/sqrt x)]\n               (= sqrt-x (double (int sqrt-x))))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 74, "code": "(fn ps-filter [s]\n  (let [is-perfect? (fn [n]\n      (== (int (Math/sqrt n)) (Math/sqrt n)))]\n\n  (let [int-list (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (let [filt-int-list (filter is-perfect? int-list)]\n      (reduce str (rest (interleave (map str (repeat \\,))\n                  (map str filt-int-list))))))))", "user": "53703287e4b0fc7073fd6e8f"}, {"problem": 74, "code": "(fn fps [s]\n  (let [bab_sqrt? (fn [m]\n                    (loop [n (quot m 2) seen #{}]\n                      (let [n2 (quot (+ n (/ m n)) 2)]\n                        (cond (seen n2) false\n                              (= m (* n2 n2)) true\n                              :else (recur n2 (conj seen n2))))))]\n    (->> s\n         (re-seq #\"\\d+\")\n         ; a perfect square never ends  in 2, 3, 7 or 8\n         (remove #(#{\\2 \\3 \\7 \\8} (last %)))\n         (map read-string)\n         ; using Babylonian algo to check if the number is a perfect square\n         (filter bab_sqrt?)\n         (interpose \\,)\n         (apply str))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 74, "code": "(fn [ints]\n  (apply str (interpose \",\" (map #(int (* % %)) (remove\n   #(< (int %) %)\n   (map\n    #(Math/sqrt %)\n    (map\n     #(Integer/parseInt %) (re-seq #\"\\d+\" ints))))))))", "user": "54926752e4b0b312c081ff44"}, {"problem": 74, "code": "(fn ps [x]\n  (let [mfmt\n        (str\n         (vec\n          (filter\n           (fn [x] \n             (= 1 (count (filter #(= (* % %) x) (range x)))))\n           (map #(Integer/parseInt %) (vec (.split x \",\"))))))]\n    (.replace (.substring mfmt 1 (- (.length mfmt) 1)) \" \" \",\")\n    )\n  )", "user": "549c8bbde4b0f3d1d8e70f8c"}, {"problem": 74, "code": "(fn [str] (let [ints (map #(Integer/parseInt %) (re-seq #\"\\d+\" str))\n                 sqrSeq (fn squares \n                          ([] (squares 0 0))\n                          ([s n] (let [sq (+ s 1 (* 2 n))] (cons sq  (lazy-seq (squares sq (inc n)))))))\n                 sqrSet  (set (take-while #(<= % (apply max ints)) (sqrSeq)))]\n             (clojure.string/join \",\" (filter #(contains? sqrSet %) ints))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 74, "code": "(fn f [i]\n  (->>\n    (.split i \",\")\n    (map read-string)\n    (filter #(= % (-> % Math/sqrt int (Math/pow 2) int)))\n    (clojure.string/join \",\")))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 74, "code": "(fn[s] (apply clojure.core/str (interpose \",\"  (filter #(some (fn [x] (= % (* x x))) (range 1 %)) (map read-string (clojure.string/split s #\",\"))))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 74, "code": "(fn [s]\n      (apply str (interpose \",\" (filter #(=(Math/ceil (Math/sqrt %)) (Math/floor(Math/sqrt %))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))\n      )", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map (fn [x] (Integer/parseInt x)) (clojure.string/split s #\",\")))))", "user": "549c3e0ce4b0f3d1d8e70f87"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map read-string \n                  (re-seq #\"\\d+\" s))]\n    (->> (for [x nums\n               :when (zero? (let [sqrt (Math/sqrt x)]\n                              (- sqrt (int sqrt))))]\n           x)\n         (clojure.string/join \",\"))))", "user": "54848141e4b0e286459a119e"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(= 0.0 (mod (Math/sqrt %) 1))\n      (map read-string (.split s \",\")))))", "user": "511688d5e4b0b3e208dba05a"}, {"problem": 74, "code": "(fn [s]\n\t(clojure.string/join \",\"\n\t\t(filter #(let [n (Math/sqrt %)] (== (int n) n))\n\t\t\t(map read-string\n\t\t\t\t(clojure.string/split s #\",\")))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 74, "code": "(fn [x]\n  (let [nums (map #(Integer/valueOf %) (clojure.string/split x #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n    (apply str (interpose \",\" sq-nums))))", "user": "54898297e4b0e286459a11e7"}, {"problem": 74, "code": "(fn [str]\n (let [no-fpart? #(= (Math/ceil %)\n                     (Math/floor %))\n       perfect-square?\n        #(no-fpart? (Math/sqrt %))]\n  (clojure.string/join \",\"\n   (filter\n    #(perfect-square? (Integer. %))\n    (clojure.string/split str #\",\")))\n))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 74, "code": "(fn [xs]\n  (letfn [(s? [n] (let [r (int (Math/sqrt n))] (= (* r r) n)))]\n      (clojure.string/join \",\" (map str\n      (filter #(s? %) \n        (map \n          #(Integer. %) \n        (clojure.string/split xs #\",\")))))\n  )\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 74, "code": "(fn filter-perfect-squares [str]\n  (let [arr (map #(Integer/valueOf %)\n                 (.split str \",\"))\n        squares (set (map #(* % %) (range 100)))\n        perf-squares (filter squares arr)]\n    (clojure.string/join \",\" perf-squares)))", "user": "52b9e920e4b07a9af57922c9"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Long/parseLong %) (clojure.string/split s #\",\"))\n        xs (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) xs)]\n    (apply str (interpose \\, xs))))", "user": "50ef4e2be4b0a78662fa2653"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \\, (filter #(let [rt (Math/sqrt (Integer/parseInt %)) \n                                                ceil (Math/ceil rt) \n                                                floor (Math/floor rt)]\n          (if (= rt ceil floor) \n            true\n            false))\n          (re-seq #\"\\d+\" s))))", "user": "549a176ce4b0f3d1d8e70f69"}, {"problem": 74, "code": "(fn [s]\n  (let [il (map #(java.lang.Integer/valueOf %) (re-seq #\"\\d+\" s))] \n    (apply str (interpose \",\" \n          (filter #(zero? (mod (Math/sqrt %) 1)) il)))))", "user": "5367bc60e4b0243289761e81"}, {"problem": 74, "code": "(fn [s] (->> s\n  (re-seq #\"\\d+\")\n  (map read-string)\n  (filter #(let [r (Math/sqrt %)] (= r (Math/floor r))))\n  (interpose \",\")\n  (apply str)))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 74, "code": "(fn [numstr]\n  (let [squarenum? (fn [n] (integer? (rationalize (Math/sqrt n))))]\n    (->> (clojure.string/split numstr #\",\")\n         (map #(Integer/parseInt %))\n         (filter squarenum?)\n         (clojure.string/join \",\"))))", "user": "4ed3b4a7535d44c135fd68f5"}, {"problem": 74, "code": "#(apply str\n        (interpose \",\"\n                   (filter (fn [n] (some (fn [x] (= n (* x x))) (range n)))\n                           (map read-string (clojure.string/split % #\",\")))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 74, "code": "(fn [rex] (apply str (interpose \",\" (filter (fn [x] \n         (not (empty? \n               (filter #(= x (* % %)) (take x (range)) ) \n               )\n              )\n         ) (map (fn [x] (Integer/parseInt x)) (re-seq #\"\\w+\" rex))))))", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (->> s (re-seq #\"\\d+\") (map #(Integer. %)))\n        sqs (set (take 100 (map #(* % %) (range))))\n        valid (filter sqs nums)]\n    (clojure.string/join \",\" valid)))", "user": "53e3f7a8e4b036ad0777e408"}, {"problem": 74, "code": "(fn [xs]\n  (reduce (fn [s e] (str s \",\" e))\n          (filter #(= (int (Math/pow (int (Math/sqrt %)) 2)) %)\n                  (map (comp int biginteger) \n                       (re-seq #\"[0-9]+\" xs)))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 74, "code": "(fn f [s] (apply str (interpose \\, (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))) (map read-string (clojure.string/split s #\"\\W\"))))))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 74, "code": "(fn [s]\n  (reduce str (interpose \\, (filter #(= 0.0 (mod (Math/sqrt %) 1))\n                                    (map read-string (clojure.string/split s #\",\"))))))", "user": "54b2ec84e4b09f271ff37d33"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (#(.split % \",\"))\n       (map read-string)\n       (filter #(= (Math/sqrt %1)\n                   (Math/floor (Math/sqrt %1))))\n       (map str)\n       (clojure.string/join \",\")))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 74, "code": "(fn [str] (clojure.string/join \",\" \n             (filter #(= (* (Math/sqrt %) (Math/sqrt %)) (float %)) \n                     (map #(Integer/parseInt %) (clojure.string/split str #\",\")))))", "user": "54ad9d76e4b09f271ff37ce6"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\" (filter #(let [sq (Math/sqrt %)] (> 0.001 (- sq (int sq)))) (map #(Integer. %) (clojure.string/split s #\",\")))) \n  )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 74, "code": "(fn [s] ( ->>\n          (re-seq #\"\\d+\" s)\n          (map #(Integer/parseInt %))\n          (filter #(= % (* (int (Math/sqrt %))(int (Math/sqrt %))) ))\n          (map str)\n          (interpose \",\")\n          (apply str)\n          ) )", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 74, "code": "(fn [ns]\n   (apply str\n          (interpose \\,\n                     (filter (fn [n]\n                               (let [i (read-string n)]\n                                 (not-empty (for [s (map #(* % %) (range))\n                                                  :while (<= s i)\n                                                  :when (= i s)] s))))\n                             (re-seq #\"\\d+\" ns)))))", "user": "54acf5c7e4b09f271ff37cdd"}, {"problem": 74, "code": "(fn [s]\n    (letfn [(is-square [n]\n              (let [root (int (Math/sqrt n))]\n                (= n (* root root))))]\n     (->> s\n      (re-seq #\"\\d+\")\n      (map #(Integer/parseInt %))\n      (filter is-square)\n      (clojure.string/join \",\"))))", "user": "4f42c80ae4b0d7d3c9f3fd0f"}, {"problem": 74, "code": "(fn perfect-sqrs [sq]\n  (let [ints (map #(Integer/parseInt %) (clojure.string/split sq #\",\"))\n        exp (fn [x n] (reduce * (repeat n x)))\n        perf-sqr? (fn [x] (= x (exp (int (Math/sqrt x)) 2)))]\n    (apply str (interpose \",\" (filter perf-sqr? ints)))))", "user": "54ae541ae4b09f271ff37cef"}, {"problem": 74, "code": "(fn\n  [input]\n  (clojure.string/join \",\" (filter #(-> % java.lang.Float/parseFloat java.lang.Math/sqrt (mod 1) (= 0.0)) (clojure.string/split input #\",\"))))", "user": "54021f13e4b0df28a13c62cc"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map bigint)\n       (filter (comp zero? #(mod % 1) #(Math/sqrt %)))\n       (clojure.string/join \",\")\n       )\n  )", "user": "54bc539be4b0ed20f4ff6eca"}, {"problem": 74, "code": "(fn [csi]\n  (letfn [(is-square-str? [s] \n                          (let [n (bigint s) \n                                n-sqrt-trunc (int (Math/sqrt n))] \n                            (= n (* n-sqrt-trunc n-sqrt-trunc))))]\n    (apply str (interpose \",\" (filter is-square-str? (clojure.string/split csi #\",\"))))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (clojure.string/split s #\",\")\n        is-sqr (fn [n]\n                 (let [sqrt (Math/sqrt n)]\n                   (= sqrt (Math/ceil sqrt))))]\n    (clojure.string/join \",\" (filter (comp is-sqr read-string) nums))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 74, "code": "(fn __ [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (filter (fn [x]\n                 (let [s (int (Math/floor (Math/sqrt x)))]\n                   (= (* s s) x))))\n       (clojure.string/join \",\")))", "user": "54c271b9e4b045293a27f602"}, {"problem": 74, "code": "(fn ps [s] \n  (clojure.string/join \",\" (filter \n   #(= (Math/sqrt (Double/parseDouble %)) \n       (double (int (Math/sqrt (Double/parseDouble %))))) \n   (re-seq #\"[0-9]+\" s))))", "user": "54b95f3de4b0ed20f4ff6eab"}, {"problem": 74, "code": "(fn [comma-sep]\n  (clojure.string/join \",\"\n    (filter (fn [num]\n                (let [\n                  inum (Integer/parseInt num)\n                  sqrt (int (Math/sqrt inum))]\n                  (= (* sqrt sqrt) inum)))\n            (clojure.string/split comma-sep #\",\"))))", "user": "540b2dcbe4b0addc1aec66f4"}, {"problem": 74, "code": "(fn [seqs]\n  (->>\n    (clojure.string/split seqs #\",\")\n    (map #(Integer/parseInt %))\n    (filter #(let [x (Math/sqrt %)] (== x (int x))))\n    (clojure.string/join \",\")))", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 74, "code": "#(clojure.string/join \",\"\n        (filter #{\"1\", \"4\", \"9\", \"16\", \"25\", \"36\"} ;; so lazy\n           (clojure.string/split % #\",\")))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 74, "code": "; Works:\n;  (fn [csv]\n;    (let [numbers (#(read-string (str \"(\" % \")\" )) csv )\n;          is-sqr  #(= (* (Math/sqrt %) (Math/sqrt %)) (float %))\n;          squares (filter is-sqr numbers) ]\n;      (clojure.string/join \",\" squares)))\n\n; Decalre parse-csv separately\n(fn [csv]\n  (let [parse-csv #(read-string (str \"(\" % \")\" ))\n        numbers (parse-csv csv )\n        is-sqr  #(= (* (Math/sqrt %) (Math/sqrt %)) (float %))\n        squares (filter is-sqr numbers) ]\n    (clojure.string/join \",\" squares)))", "user": "5465febde4b01be26fd746e1"}, {"problem": 74, "code": "(fn [s]\n  (let [numbers (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        square? (fn [n] (some #(= n (* % %)) (range (inc (/ n 2)))))\n        squares (filter square? numbers)]\n    (clojure.string/join \",\" squares)))", "user": "52be58d7e4b07a9af579231d"}, {"problem": 74, "code": "(fn [inputstr] (clojure.string/join \",\" (filter #(contains? #{4 9 16 25 36} (Integer/parseInt %)) (clojure.string/split inputstr #\",\"))))", "user": "54485727e4b032a45b8693c6"}, {"problem": 74, "code": "(fn [st] (clojure.string/join \",\" (filter (fn [x] (let [sq (Math/sqrt x)] (= 0.0 (- sq (int sq))))) (map #(Integer. %) (clojure.string/split st #\",\")))))", "user": "5474d1f4e4b0c51c1f4d728c"}, {"problem": 74, "code": "(fn foo [s]\n  (let[digits (map read-string (re-seq #\"\\d+\" s))]\n    (clojure.string/join \",\" (filter (set (map #(* % %) (range 0 (last digits)))) digits))\n  )\n)", "user": "54b050cee4b09f271ff37d13"}, {"problem": 74, "code": "(fn [s] (->>\n    (clojure.string/split s, #\",\")\n    (filter #(= (rem (Math/sqrt (Integer. %)) 1) 0.0))\n    (clojure.string/join \",\")))", "user": "54ab502fe4b09f271ff37cc4"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(= 0.0 (mod (Math/sqrt %) 1.0))\n                       (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))\n  )", "user": "546a6c7ce4b00cfc9eacc154"}, {"problem": 74, "code": "(fn [s] \n  (letfn [(sqrt [n] (first (for [i (range n)\n                                 :when (= (* i i) n)]\n                             i)))]\t\n    (reduce (fn [a b] (str a \",\" b))\n            (for [sn (seq (.split s \",\"))\n            \t  :let [n (bigint sn)]\n                  :when (sqrt n)]\n              n))))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 74, "code": "(fn [csv]\n  (->> (clojure.string/split csv #\",\")\n       (filter #(-> % read-string Math/sqrt (rem 1) zero?))\n       (clojure.string/join \",\")))", "user": "5383668ee4b06839e8705edd"}, {"problem": 74, "code": "(fn [ss]\n     (letfn [\n        (square? [x] \n          (let [\n            sqrt (int (Math/sqrt x))\n            ]\n            (= (* sqrt sqrt) x)\n          )\n        )\n       ]\n       (let [\n         xs (map read-string (re-seq #\"\\d+\" ss))\n         ps (filter square? xs)\n         ]\n         (clojure.string/join \",\" ps)\n       )\n     )\n   )", "user": "516ee939e4b06aac486e5b34"}, {"problem": 74, "code": "(letfn [(squared [n] (* n n))\n        (perfect-square? [n] (= n (squared (int (Math/sqrt n)))))]\n  (fn [s]\n    (let [perfect-squares (filter #(perfect-square? (Integer. %)) (.split s \",\"))]\n      (apply str (interpose \",\" perfect-squares)))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 74, "code": "(fn [x]\n  (->> (clojure.string/split x #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(let [r (int (Math/sqrt %))]\n               (= % (* r r))))\n   (clojure.string/join \",\")))", "user": "4dbf7a31535d020aff1edf75"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter #(let [n (read-string %), \n                      sq (int (Math/sqrt n))] \n                  (= n (* sq sq))))\n       (interpose \",\")\n       (apply str)))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 74, "code": "(fn [xs] (clojure.string/join \",\" (filter #(let [v (Math/sqrt (Integer/parseInt %))] (= (Math/floor v) v)) (clojure.string/split xs #\",\"))))", "user": "54c641f8e4b045293a27f628"}, {"problem": 74, "code": "(fn [s]\n  (apply str \n    (interpose \",\"\n      (filter\n        (fn [n] (= 0.0 (mod (Math/sqrt n) 1)))\n        (map read-string (re-seq #\"\\d+\" s))\n      )\n    )\n  )\n)", "user": "50e3cf55e4b01912b3285c45"}, {"problem": 74, "code": "(fn [s]\n    (let [split-string (clojure.string/split s #\",\")\n          strToint (map #(Integer/valueOf %) split-string)\n          root #(Math/sqrt %)\n          perfect-root? (fn [i] (= i (int (Math/pow (int (+ 0.5 (root i))) 2 ))))]\n      (->> strToint\n        (filter perfect-root?)\n        (map str)\n        (interpose \",\")\n        (apply str))\n      )\n     )", "user": "515ebde3e4b01e5d11ccd0a8"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [i] (= 0.0 (rem (Math/sqrt (Integer/parseInt i)) 1))) (.split % \",\")))", "user": "54cbe00ee4b057c6fda3a285"}, {"problem": 74, "code": "(fn [s]\n  (let [ splitter #(clojure.string/split % #\",\")\n         filterer #(== 0 (rem (Math/sqrt %) 1)) ]\n    (apply str (interpose \",\" (filter filterer (map #(Integer. %) (splitter s)))))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n      (#(clojure.string/split % #\"\\,\"))\n      (map read-string)\n       (map #(Math/sqrt %))\n       (filter #(= (Math/floor %) %))\n       (map #(* % %))\n       (map int)\n       (clojure.string/join \",\") ))", "user": "52950ab6e4b02ebb4ef7501a"}, {"problem": 74, "code": "#(->> %\n      (re-seq #\"\\d+\")\n      (map bigint)\n      (filter #{4 9 16 25 36})\n      (clojure.string/join \",\"))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter \n    #(= (double (read-string %)) (Math/pow (Math/sqrt (double (read-string %))) 2))\n    (clojure.string/split s #\"[,]\"))))", "user": "53664e3be4b0243289761e74"}, {"problem": 74, "code": "(fn [s]\n  (let [ps (map #(* % %) (range))]\n    (->> s\n         (re-seq #\"\\d+\") ; parse integers\n         (map read-string) ; convert to in\n         (filter #(loop [ps ps] ; check if they are a perfect square\n                    (cond\n                     (= (first ps) %) true\n                     (> (first ps) %) false\n                     :else (recur (next ps)))))\n         (clojure.string/join \",\"))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 74, "code": "(fn foo [s]\n  (let [string-to-int #(let [ds (re-seq #\"\\d+\" %)]\n                          (for [d ds] (Integer/parseInt d)))\n        int-to-string #(if (= 0 (count %))\n                         \"\"\n                         (let [ss (for [x %] (str \",\" x))]\n                           (apply str (rest (apply str ss)))))\n        is-perfect #(let [f (Math/sqrt %)\n                          d (int f)]\n                      (= (* d d) %))\n        ds (string-to-int s)\n        ps (for [d ds :when (is-perfect d)] d)]\n    (int-to-string ps)))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 74, "code": "(fn [s] \n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(zero? (- %  (Math/pow (Math/sqrt %) 2))))\n       (clojure.string/join \",\")))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \n   \",\"\n   (filter #(= 0.0 (mod (Math/sqrt (Integer/parseInt %)) 1)\n               )\n           (.split s \",\"))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 74, "code": "(fn sq-filt [s]\n  (let [n-s (sort \n             (map #(Integer/parseInt %) \n                  (clojure.string/split s #\",\")))\n        min-n (first n-s)\n        max-n (last n-s)\n        squares (set (map #(* % %)\n                     \t(range \n                      \t\t(int (Math/sqrt min-n))\n                     \t\t(inc (int (Math/sqrt max-n))))))]\n    (apply str (interpose \",\" (filter squares n-s)))))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \n          \",\"\n          (filter #(let [s (Math/sqrt %)]\n                     (= s (Math/ceil s)))\n                  (map #(Integer/parseInt %)\n                       (clojure.string/split x #\",\")))))", "user": "4ec66e84535d6d7199dd36cd"}, {"problem": 74, "code": "(fn [s]\n  (let [ss (clojure.string/split s #\",\")\n          v (map #(Integer/parseInt %) ss)]\n\t(->> v\n        (filter #(= (* (Math/sqrt %) (Math/sqrt %)) (float %)))\n        (clojure.string/join \",\"))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 74, "code": "(fn [s]\n  (let [square (fn [n] (* n n))\n        perfect-square? (fn [n] (= n (square (int (Math/sqrt n)))))]\n    (->> (.split s \",\")\n         (map read-string)\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (clojure.string/join \",\" \n    (filter (fn [n]  (not (nil? (some #(= (* % %) n) (range 2 n)))))\n            (map #(Integer/parseInt %) (clojure.string/split s #\"\\D+\")))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 74, "code": "(fn f [x]\n  (let [perfect-squares (map #(* % %) (range))\n        perfect-square? (fn [x] (->> perfect-squares\n                                     (take-while #(<= % x))\n                                     (last)\n                                     (= x)))]\n    (->> (clojure.string/split x #\",\")\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (map str)\n         (clojure.string/join \",\"))))", "user": "5493d908e4b0b312c081ff52"}, {"problem": 74, "code": "(fn [num-str]\n  (let [nums (map #(read-string %) (clojure.string/split num-str #\",\"))\n        squares (set (map #(* % %) (range 20)))]\n  (apply str (interpose \",\" (filter squares nums)))\n  )\n)", "user": "546692aee4b01be26fd746e7"}, {"problem": 74, "code": "(fn [s]\n  (let [els (clojure.string/split s #\",\")]\n    (apply str\n      (->> els\n           (map #(Integer/parseInt %))\n           (filter #(= (mod (* (Math/sqrt %) 10) 10) 0.0))\n           (interpose \",\")))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect #(= (java.lang.Math/sqrt %) \n                    (java.lang.Math/floor (java.lang.Math/sqrt %)))]\n    (->> \n      (clojure.string/split s #\",\")\n      (map read-string)\n      (filter perfect)\n      (clojure.string/join \\,))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 74, "code": "(fn [integers-string]\n  (let [integers (map read-string (clojure.string/split integers-string #\",\"))\n        int-sqrt #(int (Math/sqrt %)) \n        perfect-square? #(= % (* (int-sqrt %) (int-sqrt %)))]\n    (clojure.string/join \",\" (filter perfect-square? integers))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\" \n                       (filter \n                        (fn [x]\n                          (some #(= x (* % %)) (range x)))\n                        (map \n                         #(Integer/parseInt %)\n                         (.split s \",\")))))", "user": "524025bce4b0ad64fa01030f"}, {"problem": 74, "code": "(fn [s]\n  (let [col (map read-string (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\"\n                         (filter\n                           (fn [n]\n                             (some identity (map #(= (/ n %1) %1) (range 2 n))))\n                           col))))", "user": "54580586e4b01be26fd74616"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is-square [x]\n                 (zero? (mod (Math/sqrt x) 1)))]\n    (apply str (interpose \",\" (filter is-square (map read-string (.split s \",\")))))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 74, "code": "(fn [s]\n    (letfn [(parse [s]\n              (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n      (->> (parse s)\n        (filter #(= % (int (Math/pow (Math/floor (Math/sqrt %)) 2))))\n        (interpose \",\")\n        (apply str))))", "user": "5470b3d0e4b00cfc9eacc1bb"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\")\n      (filter (fn [n] (let [n (Integer. n)\n                            s (Math/sqrt n)]\n                        (== (* s s) n))))\n      (clojure.string/join \",\"))", "user": "54ddb556e4b024c67c0cf798"}, {"problem": 74, "code": "(fn [s]\n   (->> s \n        (re-seq #\"[0-9]+\") \n        (map #(Integer/parseInt %)) \n        (filter #(= (Math/pow (Math/sqrt %) 2) (double %)))\n        (interpose \\,)\n        (apply str)))", "user": "54ca130ce4b057c6fda3a250"}, {"problem": 74, "code": "(fn [s] (->> s\n             (re-seq #\"\\d+\")\n             (map #(Integer/parseInt %))\n             (filter (fn [n] (contains? (set (take-while #(<= % n) (map #(* % %) (range)))) n)))\n             (interpose \",\")\n             (apply str)))", "user": "4e68c465535d8ccf87e9fe8a"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (map #(print-str %) (filter #(== (mod (Math/sqrt %) 1) 0) (map read-string (.split s \",\")))))))", "user": "52117ea7e4b07aea8afc4f70"}, {"problem": 74, "code": "(fn filter-perfect-squares\n  [s]\n  (let [square (fn [i] (* i i))\n        is-perfect-square? (fn [n]\n                             (loop [c 0]\n                               (if (> (square c) n)\n                                 false\n                                 (if (= (square c) n)\n                                   true\n                                   (recur (inc c))))))]\n    (->> (apply list s)\n         (partition-by #(= \\, %))\n         (remove #(= (list \\,) %))\n         (map (comp #(Integer/parseInt %) (partial apply str)))\n         (filter is-perfect-square?)\n         (interpose \\,)\n         (apply str))))", "user": "53b952eee4b047364c0444e6"}, {"problem": 74, "code": "(fn [l] (apply str (interpose \",\" (filter #(let [n (Math/sqrt (Integer/parseInt %))](== n (Math/floor n))) (re-seq #\"[\\d]+\" l)))))", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(let [i (Integer/valueOf %)\n           s (int (Math/sqrt i))]\n       (= i (* s s)))\n    (.split s \",\"))))", "user": "53523ae0e4b084c2834f4aee"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [n]\n                          (let [sqrt (int (Math/sqrt n))]\n                            (= n (* sqrt sqrt))))\n        ns (for [n-str (clojure.string/split s #\",\")\n                 :let [n (Integer/parseInt n-str)]\n                 :when (perfect-square? n)]\n             n)]\n    (clojure.string/join \",\" ns)))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 74, "code": "(fn\n  [num-str]\n\n  (letfn [(str->int [ns] (map #(Integer/parseInt %) (.split num-str \",\")))\n          (is-sqr    [v] (if (= (* 1.0 (int (Math/sqrt v))) (Math/sqrt v)) v nil))]\n    (clojure.string/join \",\" (remove nil? (map is-sqr (str->int num-str))))\n  )\n)", "user": "54e5bdf2e4b024c67c0cf7fe"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(let [r (int (Math/sqrt %1))] (= (* r r) %))\n                                         (map #(Integer. %) (clojure.string/split s #\",\")))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 74, "code": "(fn filter-perfect-squares [csv]\n  (clojure.string/join \",\"\n    (map str\n      (filter \n        #(zero? (mod (Math/sqrt %) 1))\n        (map #(. Integer parseInt %) (clojure.string/split csv #\",\")\n    )))\n))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 74, "code": "(fn [lst] (let [xs (read-string (str \"[\" lst \"]\"))] (apply str (interpose \",\" (filter #(= (Math/sqrt %) (double (int (Math/sqrt %)))) xs)))))", "user": "516f06dce4b06aac486e5b39"}, {"problem": 74, "code": "(fn [s]\n    (let [square (fn [x] (* x x))]\n      (apply str (interpose \",\" (filter #(= (Integer. %) (int (square (int (Math/sqrt (Integer. %)))))) (clojure.string/split s #\",\"))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 74, "code": "(fn [string]\n  (clojure.string/join \",\"\n    (filter identity (map (fn [s] (if (== 0 (mod (Math/sqrt (Integer. s)) 1)) s))\n      (clojure.string/split string #\",\")))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 74, "code": "(fn [s]\n  (let [c (read-string (str \"[\" s \"]\"))\n        r (filter #(= (rem (Math/sqrt %) 1) 0.0) c)]\n    (clojure.string/join \",\" r)))", "user": "51a4d802e4b0def3c5c5869a"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 74, "code": "(fn\n  [text]\n  (->> (clojure.string/split text #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [n]\n                 (let [sqrt (Math/sqrt n)]\n                   (= sqrt (Math/ceil sqrt)))))\n       (clojure.string/join \",\")))", "user": "52d95491e4b09f7907dd13a4"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\"\n    (filter \n      #(let [sq (Math/sqrt %)] \n          (if (= sq (Math/floor sq)) \n            %))\n      (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "user": "54d9366ce4b0a52adc2e204e"}, {"problem": 74, "code": "(fn [s]\n  (let [is (map #(Integer. %) (.split s \",\"))\n        ps (filter (fn [i] (= i (#(* % %) (int (Math/sqrt i))))) is)\n        join (fn [c v]\n               (apply str (flatten\n                 (conj (mapv vector (butlast v) (repeat c)) (last v)))))]\n    (join \",\" (map str ps))))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 74, "code": "(fn [s]\n  (apply str (interpose \",\" (filter (fn [num] (loop [num (Integer. num) odd-nums (iterate (partial + 2) 1)]\n                                               (cond\n                                                (zero? num) true\n                                                (neg? num) false\n                                                :else (recur (- num (first odd-nums)) (rest odd-nums))))) (re-seq #\"\\d+\" s)))))", "user": "54fdbe3fe4b07d26eda61d3b"}, {"problem": 74, "code": "(fn perfect-squares [square-str]\n  (-> square-str\n      (clojure.string/split #\",\")\n      (->> (map #(Integer/parseInt %))\n           (map #(Math/sqrt %))\n           (filter (fn [i]\n                     (zero? (- i (int i)))))\n           (map #(Math/pow % 2))\n           (map int)\n           (clojure.string/join \",\"))))", "user": "5498e155e4b0b312c081ff86"}, {"problem": 74, "code": "(fn [input]\n  (->> input\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter #(not= -1\n                      (.indexOf (->> (range)\n                                     (drop 1)\n                                     (map (fn [v] (* v v)))\n                                     (take %))\n                                %)))\n       (reduce #(str %1 \",\" %2))))", "user": "5463c824e4b01be26fd746c5"}, {"problem": 74, "code": "(fn perfectSquares\n  [str]\n  (let [lst (clojure.string/split str #\",\")                                                                                         \n        isPerfect (fn [num] (if (empty?\n                                 (for [x (range num)\n                                       :when (= num (* x x))]\n                                   true)) false true))]\n    (clojure.string/join \",\"\n                         (filter\n                          (fn [elem] (isPerfect (Integer. elem)))\n                          lst))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 74, "code": "(letfn [(int? [x] (= (double x) (double (int x))))\n        (square? [x] (int? (Math/sqrt x))) ]\n  (fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter square?)\n         (clojure.string/join \",\"))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "54bcab07e4b0ed20f4ff6ed5"}, {"problem": 74, "code": "(fn f [s] \n  (clojure.string/join \n   \",\" \n   (filter (fn [a]\n             (some \n              #(= (Integer/parseInt a) (* % %)) (range (Integer/parseInt a)))) \n           (re-seq #\"\\d+\" s))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 74, "code": "(fn perfect-square [s]\n  (reduce (fn [x y] (str x \",\" y))\n    (filter\n      #(= (Math/sqrt (Integer/parseInt %)) (Math/ceil (Math/sqrt (Integer/parseInt %))))\n      (clojure.string/split s #\",\"))))", "user": "5272645de4b03e8d9a4a742c"}, {"problem": 74, "code": "(fn [input]\n  (let [perfect-squares (map #(* % %) (range 7))\n        in-input (filter (into #{} perfect-squares) (map #(Integer. %) (clojure.string/split input #\",\")))\n        \n      ] (clojure.string/join \",\" in-input)))", "user": "4ea882c7535d7eef308072fc"}, {"problem": 74, "code": "(fn [in-str] \n    (apply str (interpose \",\" \n        (#(filter (fn perfect-sq? [n]\n            (let [sqrt (Math/sqrt n)]\n                (if (== (int sqrt) sqrt) \n                    true\n                    false))) %) (map #(Integer/parseInt %) (vec (.split in-str \"\\\\p{Punct}\")))))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 74, "code": "(fn [numstr] \n  (clojure.string/join \",\" (filter #(not (> (count (nth (re-find #\"\\.(.+)\" (str (Math/sqrt (Integer. %)))) 1)) 1)) (clojure.string/split numstr #\",\"))))", "user": "54be792ee4b0ed20f4ff6eeb"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (filter #(some #{%} '(1 4 9 16 25 36 49))\n           (map read-string (re-seq #\"\\d+\" s))))))", "user": "52f53589e4b05e3f0be25f2c"}, {"problem": 74, "code": "(fn [l] (apply str (interpose \",\" (filter (set (map (comp str #(* % %)) (range 10))) (re-seq #\"[0-9]+\" l)))))", "user": "544e8369e4b0e39780006987"}, {"problem": 74, "code": "(fn [stri]\n   (subs (loop [stri (clojure.string/split stri #\",\") res \"\"]\n           (if (empty? stri)\n             res\n             (if (= 0.0 (rem (Double/parseDouble (str (first stri))) (Math/sqrt (Double/parseDouble (str (first stri))))))\n               (recur (rest stri) (str res \",\" (first stri)))\n               (recur (rest stri) res))\n             )) 1))", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 74, "code": "(fn [s]\n  (let\n    [v  (read-string (str \"[\" s \"]\"))\n     sq (filter #(zero? (rem (Math/sqrt %) 1)) v)]\n    (clojure.string/join \",\" sq)))", "user": "54e606c3e4b024c67c0cf803"}, {"problem": 74, "code": ";(fn [lst]\n;  (clojure.string/join \",\"\n;        (filter\n;         (fn [n] (let [s (int (Math/sqrt n))]\n;                   (= n (* s s))))\n;         (map read-string\n;              (clojure.string/split lst #\",\")))))\n\n(fn [lst]\n  (clojure.string/join\n   \",\"\n   (for [s (clojure.string/split lst #\",\")\n         :let [n (read-string s)\n              sq (int (Math/sqrt n))]\n         :when (= n (* sq sq))]\n     n)))", "user": "54b04708e4b09f271ff37d11"}, {"problem": 74, "code": "(fn [x] (let [nums (map #(Integer/parseInt %) (clojure.string/split x #\",\")), psqs (for [i (range 100)] (* i i))] (clojure.string/join \",\" (for [n nums :when (some #{n} psqs)] n )) ))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 74, "code": "(fn [s]\n  (letfn\n    [(perfect-number? [n] (zero? (- (Math/floor (Math/sqrt n)) (Math/sqrt n))))\n     (str->int [s] (Integer/parseInt s))]\n    (clojure.string/join \n     \",\" \n     (filter perfect-number?\n           (map str->int (clojure.string/split s #\",\"))))))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 74, "code": "(fn filt [s]\n  (let [nums (map read-string (clojure.string/split s #\",\"))\n        ** (fn [x] (* x x))\n        square? (fn [x]\n                  (= x (** (int (Math/sqrt x)))))\n        squares (filter square? nums)]\n    (clojure.string/join \",\" squares)))", "user": "55170dd9e4b06a49daca83bd"}, {"problem": 74, "code": "(fn [s]\n  (->>\n    (map #(Integer/parseInt %) (re-seq #\"[^,]+\" s))\n    (filter #(= (Math/sqrt %) (-> % Math/sqrt int double)))\n    (interpose \",\")\n    (apply str)))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 74, "code": "(fn [x]\n  (->> (map #(Integer/parseInt %) (re-seq #\"\\d+\" x))\n     (filter #(let [sq (Math/sqrt %)] (zero? (rem sq (int sq)))))\n     (map str)\n     (clojure.string/join \",\")))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 74, "code": "#(letfn [(square? [n]\n                  (let [sqrt (Math/sqrt n)]\n                    (== sqrt (int sqrt))))\n         (comma-split \n          ([s] (comma-split s [] []))\n          ([s a c] (if (empty? s)\n                     (map (partial apply str) (conj a c))\n                     (recur (rest s)\n                            (if (= (first s) \\,)\n                              (conj a c)\n                              a)\n                            (if (= (first s) \\,)\n                              []\n                              (conj c (first s)))))))]\n   (loop [s (filter square?\n                    (map (fn [x] (Integer. x))\n                         (comma-split %)))\n          st \"\"]\n     (if (empty? (rest s))\n       (str st (first s))\n       (recur (rest s)\n              (str st (first s) \\,)))))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 74, "code": "(fn [ss]\n    (let [split (fn [ss]\n                  (loop [ss ss sum 0 acc []]\n                    (if (empty? ss)\n                      (conj acc sum)\n                      (if (= (first ss) \\,)\n                        (recur (rest ss) 0 (conj acc sum))\n                        (let [s (- (int (first ss)) (int \\0))]\n                          (recur (rest ss) (+ (* sum 10) s) acc))))))\n          square? (fn [n]\n                    (loop [i 1]\n                      (let [j (* i i)]\n                        (if (> j n)\n                          false\n                          (if (= j n)\n                            true\n                            (recur (inc i)))))))\n          join (fn [ss]\n                 (if (empty? ss)\n                   \"\"\n                   (loop [ss ss acc []]\n                     (if (empty? (rest ss))\n                       (do\n                         (apply str (conj acc (first ss))))\n                       (recur (rest ss) (conj acc (first ss) \",\"))))))]\n      (loop [ns (split ss) acc []]\n        (if (empty? ns)\n          (join acc)\n          (if (square? (first ns))\n            (recur (rest ns) (conj acc (first ns)))\n            (recur (rest ns) acc))))))", "user": "551a21ece4b091ff45eda993"}, {"problem": 74, "code": "(fn[n](clojure.string/join \",\" ( filter #( = 0.0 ( rem ( Math/sqrt % ) 1 )) ( map #(Integer. % ) ( re-seq #\"\\d+\" n) ))))", "user": "54fc7d89e4b07d26eda61d2b"}, {"problem": 74, "code": "(fn [s]\n    (let [squares (fn sq [s] (concat [(* s s)] (lazy-seq (sq (inc s)))))\n          input (map read-string (clojure.string/split s #\",\"))\n          start (apply min input)\n          stop (apply max input)\n          sq-range (into #{} (drop-while #(< % start) (take-while #(<= % stop) (squares 1))))]\n\n      (->> (filter sq-range input)\n           (clojure.string/join \",\"))))", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 74, "code": "(fn [s]\n  (let [n-s (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        sqs (set  \n              (take-while \n                (partial >= (reduce max n-s)) \n                ((fn p-s [x] \n                   (cons (* x x) \n                         (lazy-seq (p-s (inc x))))) 2)))\n        ps (filter (partial contains? sqs) n-s)]\n    (reduce str (interleave (cons \"\"  (repeat \",\")) ps ))))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 74, "code": "(fn [y]\n(reduce #(str % \",\" %2)\n  (filter\n  (fn [x] (some #(= x %) (map #(* % %) (range 1 x))))\n  (map #(Integer. %) (re-seq #\"[\\d.]+\" y))\n  )))", "user": "51a058dae4b0b292b01ee3f3"}, {"problem": 74, "code": "(fn [v]\n  (clojure.string/join\n   \",\"\n   (filter #(== % (let [t (java.lang.Math/floor (+ 0.5 (java.lang.Math/sqrt %)))] (* t t)))\n           (map read-string (clojure.string/split v #\",\")))))", "user": "50f53694e4b057d4c52de881"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (map str\n        (filter #(== (Math/floor (Math/sqrt %)) (Math/sqrt %))\n                (map #(Integer/parseInt %) (.split s \",\"))))))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 74, "code": "(fn [arg]\n  (let [ arg-ints (map read-string (re-seq #\"\\d+\" arg))\n         all-squares (take-while #(<= % (apply max arg-ints)) (map #(* % %) (range)))\n         squares (filter (set all-squares) arg-ints) ]\n    (apply str (interpose \",\" squares))))", "user": "55253217e4b0882d96d091ce"}, {"problem": 74, "code": "(fn f [x]\n  (letfn [(perfect? [x]\n    (= x\n      (let [root (int (Math/sqrt x))]\n        (* root root)\n      )\n    ))]\n    (let [numbers (clojure.string/split x #\",\")]\n      (clojure.string/join \",\" (filter perfect? (map read-string numbers)))\n    )\n  )\n)", "user": "55280930e4b0ffed3738f93b"}, {"problem": 74, "code": "(fn [astr]\n          (apply str (interpose \\, (filter #(= (Math/ceil (Math/sqrt %))(Math/sqrt %)) (map #(read-string %) (clojure.string/split astr #\",\" )))))\n          )", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 74, "code": "(fn [s] (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\")) psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt))) perfect (filter psquare? nums)] (apply str (interpose \",\" perfect))))", "user": "5519c157e4b00ace28fe6e32"}, {"problem": 74, "code": "(fn [s]\n (reduce\n  #(str %1 \",\" %2)\n  (filter #(not (ratio? (rationalize (Math/sqrt %))))\n   (map\n    (fn [v]\n      (reduce #(+ (* 10 %1) (- (int %2) 48)) (- (int (first v)) 48) (rest v)))\n    (take-nth 2 (partition-by #(= \\, %) s))))))", "user": "5522cd9ae4b0882d96d091ab"}, {"problem": 74, "code": "(fn [s ]\n   (clojure.string/join \",\" \n    (filter \n     #(let [x (Integer/parseInt %)\n            sqrtX (int (Math/sqrt x))\n            x2 (* sqrtX sqrtX) ]\n        (= x x2))\n     (clojure.string/split s #\",\"))))", "user": "55249f64e4b0882d96d091c6"}, {"problem": 74, "code": "(fn [ss]\n  (let [sq (fn [n] (* n n))]\n    (->> (clojure.string/split ss #\",\") (map read-string)\n         (filter #(= % (sq (int (Math/sqrt %))))) (clojure.string/join \",\"))\n    )\n  )", "user": "552d9013e4b076ab5578f7ea"}, {"problem": 74, "code": "(fn [x]\n  (loop [result \"\" c (map read-string (re-seq #\"\\d+\" x)) ]\n    (if (empty? c)\n      (apply str (drop 1 result))\n      (recur (if (some #(= (first c) %) (map #(* % %) (range 2 (first c)) )) (str result \",\" (first c)) result) (rest c)))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 74, "code": "(fn fps [string]\n  (let [\n        numstrs (clojure.string/split string #\",\")\n        parseInt #(Integer/parseInt %)\n        numseqz (map parseInt numstrs)\n        isperfect? (fn [n]\n                     (= 0.0 (- n (* (Math/sqrt n) (Math/sqrt n)))))\n        pfnums (filter isperfect? numseqz)\n        with-commas (drop-last (interleave pfnums (repeat \\,)))\n        answer (apply str with-commas)\n        ]\n    answer))", "user": "5414b7c4e4b01498b1a719ed"}, {"problem": 74, "code": "(fn [s]\n    (let [root-floor (fn [x] (int (+ 0.00001 (Math/sqrt x))))\n          perfect-square? (fn [x] (let [rt (root-floor x)] (= x (* rt rt))))\n          strings-to-ints (fn [s] (map #(Integer. %) s))]\n      (->> (.split s \",\")\n           strings-to-ints\n           (filter perfect-square?)\n           (interpose \",\")\n           (apply str))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 74, "code": "(fn [seq] (apply str (interpose \",\" (filter (fn [str] (let [num (Integer. str)] (some true? (map #(= num %) (rest (map * (range (inc num)) (range (inc num)))))))) (re-seq #\"\\d+\" seq)))))", "user": "533b1611e4b0e30313ee6cc6"}, {"problem": 74, "code": "(fn [s]\n  (let [ns (map #(Integer/valueOf %) (re-seq #\"[0-9]+\" s))\n        sqr  #(* % %)\n        sqr? #(= % (sqr (.intValue (Math/sqrt %))))\n        join #(apply str (interpose \",\" %))]\n    (join (filter sqr? ns))))", "user": "553dd883e4b0a04f792994e6"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Long/valueOf %) (clojure.string/split s #\",\"))\n        squares (apply hash-set (map #(* % %) (take-while #(< % (apply max xs)) (range))))]\n                          (clojure.string/join \",\" (filter squares xs))))", "user": "54d127b7e4b0e8a36923e5de"}, {"problem": 74, "code": "(fn fps [x] (apply str (interpose \",\"\n   (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))\n  (map read-string \n       (clojure.string/split x #\",\")))\n)))", "user": "54bcd12be4b0ed20f4ff6ed7"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map read-string (.split s \",\"))\n        sqrs (map #(* % %) (range))\n        sqr? (fn [x] (= x (first (drop-while #(< % x) sqrs))))]\n    (clojure.string/join \",\" (filter sqr? xs))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 74, "code": "(fn [s]\n           (-> s \n               (clojure.string/split #\",\")\n               (->> (map #(Integer/parseInt %))\n                    (filter (fn [v]\n                              (let [sqrt (Math/sqrt v)]\n                                (= (Math/floor sqrt) (Math/ceil sqrt)))))\n                    (clojure.string/join \",\"))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 74, "code": "(fn [numstr]\n  (let [isint #(== % (int %))]\n    (clojure.string/join \",\"\n      (filter #(isint (Math/sqrt %))\n              (map #(Integer/parseInt %)\n                   (.split numstr \",\"))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 74, "code": "(fn [nstrs]\n    (->> (clojure.string/split nstrs #\",\")\n         (map #(Integer/parseInt %))\n         (filter #(let [r (-> % Math/sqrt long)] (= (* r r) %)))\n         (clojure.string/join \",\")))", "user": "550f1c99e4b06e50f9beb171"}, {"problem": 74, "code": "(fn [s] \n   (let [nums (map #(Long/valueOf %) (.split  #\",\" s))\n         psqs (map #(* % %) (range 10)) ;lol so bad\n         sqs (filter (fn [n]\n                      (some #(= n %) psqs)) nums)]\n     (apply str (interpose \",\" sqs))))", "user": "51bd255ce4b0df1216cefd94"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(ps [x] (= 0.0 (- x (* (Math/sqrt x) (Math/sqrt x)))))\n          (join [s x] (str s \",\" x))]\n    (->> (map read-string (.split s \",\"))\n         (filter ps)\n         (reduce join))))", "user": "55495318e4b0a04f79299566"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(let [sq (int (Math/sqrt %))] \n                                        (= (* sq sq) %))\n                                     (map #(read-string (apply str %)) \n                                          (filter #(not (= (first %) \\,))\n                                                  (partition-by #(= \\, %) s))))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 74, "code": "#(case (count %) 11 \"4,9\" \"16,25,36\")", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n    (apply str\n      (interpose \",\"\n        (filter (fn perfect-square? [n] (= 0.0 (rem n (Math/sqrt n))))\n          (map read-string\n            (re-seq #\"\\d+\" s))))))", "user": "5535e822e4b09218d5f44fb2"}, {"problem": 74, "code": "(fn[x](apply str (interpose \\, (filter #(->> % read-string Math/sqrt str seq rest   (= '(\\.\\0))) (clojure.string/split x #\",\" ))) ))", "user": "552800d7e4b0ffed3738f93a"}, {"problem": 74, "code": "(fn [s]\n  (let [square? (fn square? [n]\n                  (let [squares (map (fn [i] (* i i)) (range))]\n                    (= (some #(when (<= n %) %) squares) n)))]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter square?)\n         (clojure.string/join \",\"))))", "user": "5512aca6e4b055c2f668d4b4"}, {"problem": 74, "code": "(fn [str]\n\t(clojure.string/join \",\"\n\t\t(filter\n\t\t\t#(let [x (int (Math/sqrt %))] (= % (* x x)))\n\t\t\t(map #(Integer/parseInt %) (re-seq #\"\\d+\" str)))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (map str (filter #(let [isqrt (int (Math/sqrt %))]\n                       (= % (* isqrt isqrt)))\n                    (map #(Integer/parseInt %) \n                         (re-seq #\"\\d+\" s))))))", "user": "554b7056e4b0a04f79299583"}, {"problem": 74, "code": "(fn filter-perfect-squares [number-string]\n  (letfn [(string-to-ints [s]\n          (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))\n        (perfect-square? [n] (some #(= n (* % %))\n                                   (range 2 (/ (+ 1 n) 2))))\n        (drop-imperfection [col] (filter perfect-square? col))\n        (back-to-string [col] (apply str (interpose \",\" col)))]\n    (-> number-string \n                      string-to-ints \n                      drop-imperfection\n                      back-to-string)))", "user": "50e1bdd8e4b019fc399ce17f"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (map #(Integer/valueOf %))\n             (filter #(let [x (int (Math/sqrt %))] (= % (* x x))))\n             (clojure.string/join \",\")))", "user": "4fcf1755e4b03432b189f40c"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (apply str\n         (interpose \\,\n                    (filter\n                     #(= 0.0 (mod (Math/sqrt %) 1))\n                     (map #(Integer/parseInt %) (.split s \",\"))))))", "user": "5532a04ee4b09218d5f44f82"}, {"problem": 74, "code": "(fn filter-string [s]\n  (letfn [(perfect-square? [n]\n            (let [root (int (Math/sqrt n))]\n              (= (* root root) n)))\n          (string-to-int [s]\n            (if (empty? s) []\n                (let [word (apply str (take-while #(not= \\, %) s))]\n                  (cons (read-string word) (string-to-int (drop (inc (count word)) s))))))\n          (ints-to-string [[x & xs]]\n            (if (empty? xs) (str x)\n                (str x \",\" (ints-to-string xs))))]\n    (ints-to-string (filter perfect-square? (string-to-int s)))))", "user": "547884d7e4b0c51c1f4d72bd"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(ps? [n] (let [r (int (Math/sqrt n))] (= n (* r r))))]\n    (clojure.string/join\n     \",\"\n     (filter ps? (map read-string (clojure.string/split s #\",\"))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 74, "code": "(fn [num-str]\n  (let [squares (map #(* % %) (drop 2 (range)))\n        perf-square? (fn [x]\n                       (= x (first (drop-while #(< % x) squares))))\n        nums (map #(Integer/valueOf %)\n                  (clojure.string/split num-str #\",\"))\n        only-squares (filter perf-square? nums)]\n    (clojure.string/join \",\" only-squares)))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 74, "code": "(fn [astr]\n   (reduce (fn [x, y] (str x \",\" y)) \n             (filter (fn [x] \n                      (if (contains? #{ 1 4 9 16 25 36 49 64 81 100} x)\n                          x))\n                     (map (fn [s] (Long/parseLong s))\n                          (clojure.string/split astr #\",\")))))", "user": "555881f5e4b0deb715856e2c"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(from-csv [s] (.split s \",\"))\n          (to-int [s] (Integer. s))\n          (square? [x]\n            (let [y (int (Math/pow x 0.5))]\n              (= x (* y y))))\n          (to-csv [xs] (clojure.string/join \",\" xs))]\n    (->> s\n         from-csv\n         (map to-int)\n         (filter square?)\n         to-csv)))", "user": "543d89dfe4b032a45b869350"}, {"problem": 74, "code": "(fn my-sqrt-filter [l]\n  (let [sl (clojure.string/split l #\",\")\n        sm (map #(read-string %) sl)]\n    (loop [nl sm result []]\n      (let [f (first nl)]\n        (if (nil? f) (clojure.string/join \",\" result)\n          (let [sq (Math/sqrt f)\n                si (int sq)\n                is-perfect-square? (= 0.0 (- sq si))]\n            (if is-perfect-square?\n              (recur (rest nl) (conj result f))\n              (recur (rest nl) result))))))))", "user": "5546704be4b0a04f7929953d"}, {"problem": 74, "code": "(fn f [s]\n  (let [se (map (comp read-string str) (remove #(= \",\" %) (map #(apply str %) (partition-by #(= % \\,) (last (split-with #(= \\, %) (seq s))))))) m (apply max se) sqrs (map #(* % %) (range m))]\n    (apply str (interpose \\, (sort (filter (set se) (set sqrs)))))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 74, "code": "(fn [s]\n  (->> (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n       (filter #(== (Math/round (Math/sqrt %)) (Math/sqrt %)))\n       (clojure.string/join \",\")))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 74, "code": "(fn [string]\n   (letfn [(square? [n]\n             (let [isqrt (java.lang.Math/round (java.lang.Math/sqrt n))]\n               (= n (* isqrt isqrt))))]\n     (clojure.string/join \",\"\n                          (filter square?\n                                  (map #(Integer. %)\n                                       (clojure.string/split string #\",\"))))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 74, "code": "(fn find-sq [s]\n  (clojure.string/join \",\"\n                       (filter\n                         (fn [x] (reduce #(or %1 (and (= (quot (Integer/parseInt x) %2) %2) (zero? (mod (Integer/parseInt x) %2))))\n                                         false\n                                         (range 2 (Integer/parseInt x))))\n                         (clojure.string/split s #\",\"))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(loop [i 0 r %]\n                                            (cond (< 0 r) (recur (inc i) (- r (inc (* 2 i))))\n                                                  (= 0 r) true\n                                                  (< r 0) false))\n                                         (map #(Integer. %) (clojure.string/split s #\"[,]\")))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 74, "code": "(fn [s]\r\n  (->> (clojure.string/split s #\",\")\r\n       (map #(Integer. %))\r\n       (filter (fn perfect-square? [n]\r\n         (= n (last (take-while #(<= % n)\r\n           (map #(* % %) (range)))))))\r\n       (clojure.string/join \",\")))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 74, "code": "(fn [s]\n  (->> (read-string (str \"[\" s \"]\"))\n       (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n       (clojure.string/join \",\")))", "user": "5540cc0ce4b0a04f79299505"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1)) nums))))", "user": "54ab1b5ae4b09f271ff37cc2"}, {"problem": 74, "code": "(fn perfect-squaress\n  [strs]\n  (clojure.string/join \",\"  (filter\n                             (fn [x]\n                               (let [root (Math/sqrt (read-string x))]\n                                 (== (int root) root)))\n                             (clojure.string/split strs #\",\"))))", "user": "55079e55e4b021ccfedb96aa"}, {"problem": 74, "code": "(fn [s]\n  (loop [xs1 (clojure.string/split s #\",\") xs2 []]\n    (if (empty? xs1)\n      (clojure.string/join \",\" xs2)\n      (let [x (read-string (first xs1))]\n        (recur (rest xs1)\n               (if (= 0.0 (mod x (java.lang.Math/sqrt x)))\n                 (conj xs2 x)\n                 xs2))))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 74, "code": "(fn [str-dig] \n  (clojure.string/join \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))  (map read-string (re-seq #\"[0-9]+\" str-dig)))))", "user": "550e8e04e4b06e50f9beb167"}, {"problem": 74, "code": "(fn f [sqr-str]\n  (let [nums (map #(.. Integer (parseInt %1)) (re-seq #\"\\b[0-9]+\\b\" sqr-str))]\n    (letfn [(sqrt [n] (.. Math (sqrt n)))\n            (sqr? [n] (= (.. n (doubleValue)) (* (sqrt n) (sqrt n))))\n            (rejoin [nums] (apply str (interpose \",\" nums)))]\n      (rejoin (filter sqr? nums)))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 74, "code": "(fn [str] (clojure.string/join\n   \",\"\n   (let [coll (map #(Integer/parseInt %) (clojure.string/split str #\",\"))]\n     (let [perfect-squares (map #(* % %) (iterate inc 1))]\n       (filter (fn [elm] (some #(= elm %) (take (Math/sqrt elm) perfect-squares))) coll)))))", "user": "5501a1e1e4b07d26eda61d75"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (- (Math/pow % 1/2) (int (Math/pow % 1/2)))) \n                  (map #(Integer/valueOf %) (clojure.string/split s #\",\")))))", "user": "545801f6e4b01be26fd74615"}, {"problem": 74, "code": "(fn [s] \n  (->> \n   (clojure.string/split s #\",\")     \n   (map read-string)\n   ((fn [sq] \n      (->> \n       sq \n       (apply max) \n       (range) \n       (map #(* % %)) \n       (filter #(some (partial = %) sq))   \n       (clojure.string/join \",\")\n   )))\n))", "user": "5280a1ece4b0757a1b171407"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let [squares (into #{} (map #(* % %)(range 1 10)))] \n    (apply str (interpose \",\" (filter #(squares (read-string %)) \n          (.split s \",\"))))))", "user": "556405e5e4b0c656e3ff17fb"}, {"problem": 74, "code": "(fn [s] (->> \n         (clojure.string/split s #\",\")\n         (map read-string)\n         (filter #(zero? (mod (java.lang.Math/sqrt %) 1)))\n         (clojure.string/join \",\")))", "user": "52e851bfe4b09f7907dd149a"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        nums->str (partial clojure.string/join \",\")]\n    (nums->str\n     (filter (fn [n]\n               (let [sqrt (int (Math/sqrt n))]\n                 (= n (* sqrt sqrt))))\n             nums))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 74, "code": "(fn [s]\n  (->> (str \"[\" s \"]\")\n       read-string\n       (filter (fn [n] (= n (#(* % %) (int (Math/sqrt n))))))\n       (interpose \",\")\n       (apply str)))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 74, "code": "(fn [nums]\n  (let [isPerfect? (fn [numString]\n                     (let [intVal (java.lang.Integer/parseInt numString)\n                           sqrtVal (java.lang.Math/sqrt intVal)]\n                       (if (= 0.0 (- sqrtVal (int sqrtVal))) true false)))]\n    (loop [result \"\", numSeq (clojure.string/split nums #\",\")]\n      (if-let [numStr (first numSeq)]\n        (if (isPerfect? numStr)\n          (recur (str result \",\" numStr) (rest numSeq))\n          (recur result (rest numSeq)))\n        (subs result 1)))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map read-string)\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "554b8572e4b0a04f79299589"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\" (get (group-by #(if (=  (* (.intValue (Math/sqrt %)) (.intValue (Math/sqrt %))) %) true) (map #(Integer/parseInt %) (clojure.string/split x #\",\"))) true)))", "user": "4eb0175b535d7eef30807336"}, {"problem": 74, "code": "(fn filterperfectsquares[xs]\n  (let [number-array (map #(Integer/parseInt %) (clojure.string/split xs #\",\"))\n        isperfectsquare (fn[x](let [rootval (.intValue (Math/sqrt x))]\n                                (= x (* rootval rootval))))\n        filteredlist (filter isperfectsquare number-array)\n        commalist (repeat (count filteredlist) \",\")\n        toReturn (rest (interleave commalist filteredlist))]\n    (apply str toReturn)))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 74, "code": "(fn f [s]\n  (clojure.string/join\n   (interpose \",\"\n              (filter #(zero? (mod (Math/sqrt %) 1))\n                      (map #(Long/parseLong %)\n                           (clojure.string/split s #\",\"))))))", "user": "4f9b3532e4b0dcca54ed6d13"}, {"problem": 74, "code": "(fn [num-str]\n  (let [nums (clojure.string/split num-str #\",\")\n        nums-as-ints (map read-string nums)\n        perfect-sqrs (set (map #(* % %) (range 100)))\n        filtered (filter perfect-sqrs nums-as-ints)]\n    (apply str (interpose \",\" filtered))))", "user": "52fc34cee4b047fd55837015"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect? [s]\n            (let [i (Integer/parseInt s)]\n              (= (* 1.0 i) (#(* % %) (Math/floor (Math/sqrt i))))))]\n    (apply str (interpose \",\" (filter perfect? (re-seq #\"\\d+\" s))))))", "user": "55702081e4b09a3098a52529"}, {"problem": 74, "code": "(fn filter-pertfect [seq-]\n  (reduce #(str % \",\" %2)\n  (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))\n          (map #(Integer. %) (clojure.string/split seq- #\",\")))\n\n  )\n  )", "user": "556cd549e4b09a3098a52503"}, {"problem": 74, "code": "(fn perf-sqr [s]\n  (let [ints (map #(read-string %)\n                  (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\"\n                         (filter\n                          #(zero? (mod % (Math/sqrt %)))\n                          ints))))", "user": "54c3747de4b045293a27f60e"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [n]\n            (let [d (Math/sqrt n)\n                  i (double (int d))]\n              (= d i)))]\n    (->> (re-seq #\"\\d+\" s)\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)         \n         (interpose \",\")\n         (apply str))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 74, "code": "(fn perfect-squares?\n  [strr]\n  (let [vectorize (fn [l] (map #(read-string %) (clojure.string/split l #\",\")))]\n    (clojure.string/join \",\" \n                         (filter (fn [p] (== (Math/sqrt p) (int (Math/sqrt p)))) (vectorize strr)))))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 74, "code": "(fn [s] (->> (re-seq #\"\\d+\" s)\n             (map read-string)\n             (filter #(let [n (int (Math/sqrt %))] (= % (* n n))))\n             (clojure.string/join \",\")))", "user": "54e2a779e4b024c67c0cf7d3"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\"\\,\")\n             (map #(Integer. %))\n             (filter #(let [x (Math/sqrt %)] (= (Math/floor x) (Math/ceil x))))\n             (clojure.string/join \",\")))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 74, "code": "(fn [s] \n  (apply str (interpose \",\" (map str (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)) (map #(Integer/parseInt %) (.split s \",\")))))))", "user": "5550bcece4b00713264bd9ae"}, {"problem": 74, "code": "(fn  [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map #(Integer/parseInt %))\n       (filter #(= (-> % Math/sqrt int float) (Math/sqrt %)))\n       (interpose \",\")\n       (apply str)))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 74, "code": "(fn [seqstr]\n    (letfn [(str->int [num] (Integer. num))\n            (is-perf-sq [num] \n              (let [sqrt (int (Math/sqrt num))]\n                (= num (* sqrt sqrt))))\n            (numseq [] (clojure.string/split seqstr #\",\"))]\n      (clojure.string/join \",\"\n                           (filter is-perf-sq\n                                   (map str->int (numseq))))))", "user": "554a75c9e4b0a04f79299575"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [x]\n                 (->> (range x)\n                      (drop 1)\n                      (filter #(= (* % %) x))\n                      seq)))\n       (clojure.string/join \",\")))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 74, "code": "(letfn \n  [(str->nums [s] \n              (map read-string (clojure.string/split s #\",\")))\n   (nums->str [nums]\n              (apply str (interpose  \",\" (map str nums))))\n   (perfect? [n]\n             (== 0 (rem (Math/sqrt n) 1)))]\n  \n (fn [s]\n    (->> s\n         (str->nums)\n         (filter perfect?)\n         (nums->str))))", "user": "53065acbe4b02e8216869792"}, {"problem": 74, "code": "(fn[seq1] (clojure.string/join \",\"  \n     (filter (fn[a] (== (mod a (Math/sqrt a)) 0)  )  \n             (map (fn[z] (Integer/parseInt z)  )  \n                  (remove (fn[y] (= \\, y) )  \n                          (map (fn[x] x)  \n                               (clojure.string/split seq1 #\",\" ))) ))))", "user": "55757e81e4b05c286339e063"}, {"problem": 74, "code": "(fn sol [s] (->> (clojure.string/split s #\",\") (map read-string) (filter #(let [x (int (Math/sqrt %))] (= (* x x) %))) (map str) (clojure.string/join \",\")))", "user": "54857657e4b0e286459a11ac"}, {"problem": 74, "code": "(fn [str]\n  (loop [new [] s (clojure.string/split str #\",\")]\n    (if (empty? s) (clojure.string/join \",\" new)\n      (if ((fn square? [x]\n             (loop [c 1]\n               (if (> (* c c) x) false\n                 (if (= (* c c) x) true\n                   (recur (inc c)))))) (read-string (first s))) (recur (conj new (first s)) (rest s))\n        (recur new (rest s))))))", "user": "558378dce4b05c286339e115"}, {"problem": 74, "code": "(fn prfct-sqr [input]\n\t(let[\n\t\tnumbers (map read-string (clojure.string/split input #\",\"))\n  \t\tsquare? #(= 0.0 (- (Math/sqrt %) (int (Math/sqrt %))))\n\t]\n  \t\t(clojure.string/join \",\" (filter square? numbers))\n  \t\t)\n  \t)", "user": "5545477fe4b0a04f79299531"}, {"problem": 74, "code": "(fn filtersqs [s]  \n  (let [perfectsq? (fn [n]\n                     (loop [n n i 1]\n                       (cond (< n 0) false\n                             (= n 0) true\n                             :else (recur (- n i) (+ i 2)))))]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter perfectsq?)\n       (clojure.string/join \",\"))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 74, "code": "#(->>\n  \t(read-string (str \"[\" %  \"]\"))\n  \t(filter #{4 9 16 25 36})\n    (clojure.string/join \",\"))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 74, "code": "(fn [s]\n  (loop [li (map #(Integer. %) (clojure.string/split s #\",\")) le []]\n    (if (empty? li)\n      (clojure.string/join \",\" le)\n      (recur (rest li)\n             (if (= (* (int (Math/sqrt (first li))) (int (Math/sqrt (first li)))) (first li))\n               (conj le (first li))\n               le)))))", "user": "52979551e4b02ebb4ef75043"}, {"problem": 74, "code": "(fn [strings]\n  (let [coll (seq (clojure.string/split strings #\",\"))]\n    (apply str (interpose \",\" (filter #(= 3 (count (str (Math/sqrt (Integer/parseInt %))))) coll)))))", "user": "52ba2639e4b07a9af57922cb"}, {"problem": 74, "code": "(fn filter-perfect-squares\n  [xs]\n  (let [number-list (map (comp #(Long/valueOf %) (partial apply str))\n                         (filter (complement #{'(\\,)})\n                                 (partition-by #{\\,} xs)))]\n    (apply str\n           (interpose \\,\n                      (filter (into #{}\n                                 (take-while #(<= % (last number-list))\n                                             (map #(* % %) (range)))) number-list)))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 74, "code": "(fn [ss] (let [aa (filter #(zero? (mod (Math/sqrt (read-string %)) 1)) (clojure.string/split ss #\",\"))]\n                    (apply str (interpose \",\" aa)) \n                     ))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 74, "code": "(fn [x]\n  (clojure.string/join\n   \",\"\n   (filter (fn [x] (= 0.0 (mod (Math/sqrt x) 1)))\n           (map #(Integer/parseInt %)\n                (clojure.string/split x #\",\")))))", "user": "555f3bfde4b0a2eb076a39c1"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n      (map #(Integer/parseInt %))\n      (filter #(zero? (- (Math/sqrt %) (int (Math/sqrt %)))))\n      (interpose \",\")\n      (apply str)))", "user": "55895eade4b059ccff29b202"}, {"problem": 74, "code": "(fn f [s]\n  (letfn [(is-square [x] (let [y (int (Math/sqrt x))]\n                          (= x (* y y))))]                                   \n    (clojure.string/join \",\" (filter is-square (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n    )))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5589a735e4b059ccff29b206"}, {"problem": 74, "code": "(letfn [                                                                                                                                                \n    (is-square? [n] (zero? (mod (Math/sqrt n) 1)))                                                                              \n    (perfect-squares [string] (clojure.string/join \",\" (filter is-square? (map #(Integer. %) (clojure.string/split string #\",\")))))]                    \n        perfect-squares)", "user": "558b50d5e4b027778923762b"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(split-str [s]\n            (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))\n          (perfect-squares-until [x]\n            (take-while (partial >= x) (map #(* % %) (iterate inc 1))))]\n    (->> (split-str s)\n         (filter #(some #{%} (perfect-squares-until %)))\n         (interpose \",\")\n         (apply str))))", "user": "51ae350fe4b09397d5109790"}, {"problem": 74, "code": "(fn filter-perfect-seq1\n  [s]\n  (letfn [(perfect-sq? [n] (= n (#(* % %) (int (Math/sqrt n)))))]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter perfect-sq?)\n         (map str)\n         (clojure.string/join \",\"))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 74, "code": "(fn [coll]\n          (clojure.string/join \",\"\n            (filter #(= 0.0 (mod (java.lang.Math/sqrt (read-string %)) 1))\n                   (clojure.string/split coll #\",\"))))", "user": "531c6e72e4b08068f379eda0"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter\n     #(let [n (read-string %)\n            r (Math/sqrt n)]\n        (== r (int r)))\n     (re-seq #\"\\d+\" s))))", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \n         \",\" (filter (fn [n] (== (mod (Math/sqrt n) 1) 0)) (map bigint (.split s \",\")))))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 74, "code": "(fn ps [s]\n  (apply str \n         (interpose \",\"\n                    (filter (fn [x]\n                              (let [x (read-string x)\n                                    ]\n                                (some #(= x (* % %)) (range (inc (/ x 2))))))\n                              (re-seq #\"[0-9]+\" s)))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 74, "code": "(fn my-perfect-squares [s]\n  (let [c (map (fn [x] (Integer. x)) (clojure.string/split s #\",\"))\n        ps (filter (fn [x] (= (Math/floor (Math/sqrt x)) (Math/sqrt x))) c)]\n    (clojure.string/join \",\" ps)))", "user": "5596a324e4b04c1e5c31d757"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\"\n  (filter #(let [q (Math/sqrt %1)] (= q (Math/floor q)))\n     (map bigdec (clojure.string/split s #\",\")))))", "user": "5590e55de4b0277789237676"}, {"problem": 74, "code": "(fn mytest [args]\n\n  \t(\tlet [str-nocomma    (clojure.string/split args #\",\")\n  \t\t\t numbers    (map read-string str-nocomma)\n\n  \t\t\t checkPerfect  (fn [number]\n\n  \t\t\t\t\t(reduce #(or %1 (= number (* %2 %2)) )  false (range 1 number) )\n  \t\t\t) \n\n  \t\t\t perfectNumbers (filter checkPerfect numbers)\n  \t\t]\n\n  \t\t(clojure.string/join \",\" perfectNumbers)\n  \t\t)\n\n  \t)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 74, "code": "(letfn [(square? [x]\n          (let [y (int (Math/sqrt x))]\n       \t\t(= (* y y) x)))]\n  (fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter square?)\n         (clojure.string/join \",\"))))", "user": "4fde492be4b05e33b9224f8a"}, {"problem": 74, "code": "(fn [s]\n(apply str \n       (interpose \",\" \n                  (filter \n                    (fn perfectsquare? [n] (some #(= (* % %) n) (range 1 n))) \n                    (map read-string (re-seq #\"\\d+\" s))))))", "user": "5587d8b3e4b059ccff29b1e8"}, {"problem": 74, "code": "#(->> %\n         (re-seq #\"\\d+\")\n         (map read-string)\n         (filter (set (map (fn [a] (* a a)) (range 9))))\n         (clojure.string/join \",\"))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 74, "code": "(fn [coll]\n  (->> (clojure.string/split coll #\"\\D+\")\n       (map #(Integer. %))\n       (filter #(== 0 (mod (Math/sqrt %) 1)))\n       (interpose \",\")\n       (apply str)))", "user": "55933c7ae4b0c79f6e1db938"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))\n                               (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "52c5c1c8e4b0c2d177d620fc"}, {"problem": 74, "code": "(fn [xs]\n  (let [nums (map #(Integer/valueOf %) (clojure.string/split xs #\",\"))\n        perfects (set (map #(* % %) (range 100)))\n        matches (filter perfects nums)]\n    (apply str (interpose \",\" matches))))", "user": "52b89d55e4b07a9af57922b3"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [x]\n            (let [r (int (Math/sqrt x))]\n              (= x (* r r))))]\n    (clojure.string/join\n      \",\"\n     (filter perfect-square?\n             (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "5576f299e4b05c286339e077"}, {"problem": 74, "code": "(fn [x]\n    (apply str (interpose \",\"\n                          (filter #(= % (apply * (repeat 2 (int (Math/sqrt %))))) \n                                  (map read-string (re-seq #\"\\d+\" x))))))", "user": "55342ee0e4b09218d5f44f98"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter (fn [n] (some #(= (* % %) n) (range 2 n)))\n                               (map read-string (clojure.string/split s #\",\")))))", "user": "559b2ad1e4b066d22e731f4e"}, {"problem": 74, "code": "(fn psquares [s]\n  (let [nums (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        m (reduce max nums)\n        range  (take-while #(<= % m) (map #(* % %) (iterate inc 1)))\n        vals (reduce (fn [acc v] (if (some #(= v %) range)  (conj acc v) acc))[] nums)]\n    (apply str (interpose \",\" vals))\n    )\n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 74, "code": "(fn [s]\n  (let [f (fn [n]\n            (let [v (rationalize (Math/sqrt n))]\n              (* v v)))]\n    (->> (clojure.string/split s #\",\")\n       (map #(Integer. (re-find #\"\\d+\" %)))\n       (filter #(= % (f %)))\n       (clojure.string/join \",\"))))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter (fn [n]\n                                 (let [m (int (Math/sqrt n))]\n                                   (= (* m m)\n                                      n)))\n                               (map #(Integer. %) (clojure.string/split s #\",\")))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 74, "code": "(fn [v]\n              (->> (clojure.string/split v #\",\")\n                   (map #(Integer/parseInt %))\n                   (map #(Math/sqrt %))\n                   (filter #(-> % int double (= %)))\n                   (map int)\n                   (map #(* % %))\n                   (clojure.string/join \",\")))", "user": "5499e23de4b03163384f4706"}, {"problem": 74, "code": "(fn [x] (apply str (interpose \",\" (filter #(integer? (rationalize (Math/sqrt (read-string %)))) (clojure.string/split x #\",\")))))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 74, "code": "(fn [s]\n  (apply str\n         (interpose \",\" \n                    (filter #(== (Math/sqrt %) (int (Math/sqrt %))) (map read-string (clojure.string/split s #\",\"))))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" \n   (filter \n    (fn [n] (some #(= n %) (map #(* % %) (range n))))\n    ( map read-string (clojure.string/split s #\",\")))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 74, "code": "(fn p74 ([coll] (p74 (map #(Integer/parseInt %) \n                            (clojure.string/split coll #\",\"))\n                       ((fn [r1 r2] (map #(* %1 %2) r1 r2 ))\n                                  (range 2 7) (range 2 7))\n                       []))\n          ([coll expos acc]\n           (if-not (empty? coll)\n             (if-not (empty? (filter true? (map #(= (first coll) %) expos)))\n               (p74 (rest coll) expos (conj acc (first coll)))\n               (p74 (rest coll) expos acc)\n               )\n             (clojure.string/join \",\" acc)\n             )\n           \n           \n           ))", "user": "5400e918e4b0de5c41848619"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(= 0.0 (rem (Math/sqrt %) 1)) (map read-string (clojure.string/split s #\",\")))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 74, "code": "(fn [ts] (let [cs (map #(Long. %) (clojure.string/split ts #\",\"))]\n           (clojure.string/join \",\" (filter #(== 0 (rem % (Math/sqrt %))) cs))\n           ))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [x]\n            (let [sqrt (Math/sqrt (read-string x))]\n              (== sqrt (int sqrt))))]\n    (->> (clojure.string/split s #\",\")\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"})\n       (clojure.string/join \",\")))", "user": "523b4e91e4b07becd5be21ef"}, {"problem": 74, "code": "(fn [x] \n  (clojure.string/join \n    \",\"\n    (filter \n      (fn [d]\n        (let [dsqrt (int (Math/sqrt d))]\n          (= (* dsqrt dsqrt) d)))\n      (map\n        (fn [s] (java.lang.Integer/parseInt s))\n        (clojure.string/split x #\",\")))))", "user": "55b1c24ae4b0da326a65cf70"}, {"problem": 74, "code": "(fn [coll]\n  (letfn\n  [(is-square?\n     [n] (let [r (int (Math/sqrt n))]\n           (= n (* r r))))]\n  (->>\n    (-> coll (clojure.string/split #\",\"))\n    (map #(Integer/valueOf %))\n    (filter is-square?)\n    (clojure.string/join \",\"))))", "user": "55afd469e4b002ce9d5cbc19"}, {"problem": 74, "code": "(fn [x](clojure.string/join \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (clojure.string/split x #\",\"))))", "user": "4ec7c32c535d6d7199dd36e6"}, {"problem": 74, "code": "(fn [s]\n  (let [square (fn [n] (* n n))\n        perfect? (fn [n]\n                   (= n (square (int (Math/sqrt n)))))]\n    (->> (.split s \",\")\n         (map read-string)\n         (filter perfect?)\n         (clojure.string/join \",\"))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 74, "code": "(fn [a] (reduce #(str %1 \",\" %2) \n                     (filter (fn [x] (let [odm (Math/sqrt x) ro (int odm)] \n                                       (= 0.0 (- odm ro)))) \n                             (map #(Integer/parseInt %) (clojure.string/split   a #\",\")))))", "user": "5576e78de4b05c286339e075"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n  (filter \n   (fn [n] (let [q (int (Math/sqrt n))] (= (* q q) n)))\n     (map read-string (clojure.string/split s #\",\")))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 74, "code": "(fn filter-perfect\n  [in-str]\n  (clojure.string/join \",\" (filter #(= (* (int (Math/sqrt %)) (int (Math/sqrt %))) %) (map #(Integer/parseInt %) (clojure.string/split in-str #\",\"))))\n)", "user": "5581a6dae4b05c286339e0fe"}, {"problem": 74, "code": "(fn [s]\n    (let [\n          ps (fn [i]\n               (let [sr (Math/round (Math/sqrt i))]\n               (= i (* sr sr))))\n          is (map read-string (clojure.string/split s #\",\"))\n          ]\n      (->>\n        is\n        (filter ps)\n        (map str)\n        (clojure.string/join \",\")\n        )\n      )\n    )", "user": "559a9a3de4b066d22e731f45"}, {"problem": 74, "code": "(fn [string]\n    (let [ data (map #(Integer/parseInt %) (clojure.string/split  string  #\",\"))\n          square?  (fn [x] (let [t (-> x Math/abs Math/sqrt)]\n                             (= t (double (int t)))))\n          squares (filter square? data)]\n      (apply str (interpose \",\" squares))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 74, "code": "(fn [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer. %))\n    (filter #(let [n (Math/sqrt %)] (= n (Math/ceil n))  ) )\n    (clojure.string/join \",\")))", "user": "55647a31e4b0c656e3ff1808"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\"\n  (for [s (.split s \",\")\n             :let [s (Integer/parseInt s)\n\n                   \n                   i (int (Math/sqrt s))]\n             i (range (dec i) (inc i))\n             :when (= s (* i i))\n             ] s)))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 74, "code": "(fn [nums]\n  (->> (clojure.string/split nums #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= (rem (Math/sqrt %) 1) 0.0))\n       (clojure.string/join \",\")))", "user": "555521a5e4b0deb715856e12"}, {"problem": 74, "code": "#(letfn\n   [(is-square? [number]\n                (let [a (int (Math/sqrt number))]\n                  (= number (* a a))))\n    (get-squares [string]\n                 (for [x (clojure.string/split string #\",\") :when (is-square? (int (bigdec x)))] x))]\n   (apply str (interpose \",\" (get-squares %))))", "user": "55868660e4b059ccff29b1d4"}, {"problem": 74, "code": "#(apply str (interpose \",\" (filter (fn [s] (.contains [\"1\" \"4\" \"9\" \"16\" \"25\" \"36\" \"49\"] s)) (.split % \",\"))))", "user": "55bfc39ee4b01b9910ae2a1a"}, {"problem": 74, "code": "(fn [x]\n\t(->> (clojure.string/split x #\",\") \n\t\t (map read-string) \n\t\t (filter #(= (double %) (Math/pow (Math/sqrt %) 2)))  \n\t\t (clojure.string/join \",\")))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter (fn [x]\n                 (letfn [(square [y] (* y y))]\n                   (= x (-> x\n                            Math/sqrt\n                            Math/round\n                            int\n                            square)))))\n       (clojure.string/join \",\")))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 74, "code": "(fn [xs]\n  (->> (map read-string (clojure.string/split xs #\",\"))\n            (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n                 (interpose \",\")\n       (apply str)))", "user": "55b107fee4b002ce9d5cbc2a"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (filter (comp #(not (< 0.0 % 1.0))\n                      #(mod % 1)\n                      #(Math/sqrt %)\n                      #(Integer/parseInt %)))\n        (clojure.string/join \",\")))", "user": "55b54ecbe4b01b9910ae2987"}, {"problem": 74, "code": "(fn [x]\n  (->> (re-seq #\"\\d+\" x)\n     (map #(Integer. %))\n     (filter #(-> (Math/sqrt %) (rem 1) zero?))\n     (clojure.string/join \",\")))", "user": "522eb5cce4b01cdb292c5f0c"}, {"problem": 74, "code": "(fn perfect-squares [nums] (clojure.string/join \",\"                                                                                                                                \n                                                (map (comp #(* % %) int)                                                                                                           \n                                                          (filter #(zero? (mod % 1))                                                                                               \n                                                                  (map (comp #(Math/sqrt %) read-string)                                                                           \n                                                                            (clojure.string/split nums #\",\"))))))", "user": "55c10409e4b01b9910ae2a2c"}, {"problem": 74, "code": "(fn [xs]\n  (clojure.string/join \",\" (map str (filter\n   #(= 0.0 (mod (Math/sqrt (Integer/parseInt %)) 1))\n   (clojure.string/split xs #\"\\,\")))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n              (map #(Integer. %))\n              (filter #(let [n (Math/sqrt %)]\n                        (< (- n (Math/floor n)) 0.00001)))\n              (clojure.string/join \",\")))", "user": "54f4adc8e4b0f2f3c5226e86"}, {"problem": 74, "code": "(fn[src](clojure.string/join \",\"\n                             (filter (fn[n](some (fn[v](= n (* v v))) (range 1 999)))\n                                     (map read-string (clojure.string/split src #\",\")))))", "user": "5596af34e4b04c1e5c31d758"}, {"problem": 74, "code": "(fn filter-perfect-sq [s]\n   (clojure.string/join\n    \",\"\n    (filter #(< (. Math abs (- (Math/sqrt %) (int (Math/sqrt %)))) 1e-9)\n           (map #(. Integer parseInt %) (clojure.string/split s #\",\")))))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (filter (comp #(= % (Math/ceil %)) #(Math/sqrt %) read-string))\n       (clojure.string/join \",\")))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 74, "code": "(fn [nums]\n  (clojure.string/join \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n                   (map #(Integer/parseInt %)\n                        (clojure.string/split nums #\",\")\n                        )\n                      )\n          )\n  )", "user": "55c68089e4b0e31453f649c4"}, {"problem": 74, "code": "(fn filterSquares [s]\n  (->> s\n    (re-seq #\"\\d+\")\n    (map #(java.lang.Integer/parseInt %))\n    (filter #(let [n (int (Math/sqrt %))] (= % (* n n))))\n    (interpose \",\")\n    (apply str)))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 74, "code": "(fn [seq]\n  (->> seq\n       (re-seq #\"[0-9]+\")\n       (filter #(let [root (Math/sqrt (read-string %))]\n                  (== root (int root))))\n       (interpose \",\")\n       (apply str)))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 74, "code": "(fn [coll]\n  (let [ps? #(== (Math/pow (int (Math/sqrt %)) 2) %)]\n    (apply str (interpose \",\" (filter #(ps? (Integer/parseInt %)) (clojure.string/split coll #\",\"))))))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 74, "code": "(fn [str]\n  (letfn [(is-sqrt [n]\n        \t  (= (Math/floor (Math/sqrt (Integer. n))) (Math/sqrt (Integer. n)))           \n          )]\n  (clojure.string/join\n   \t\",\"\n  \t(filter\n  \t\tis-sqrt\n   \t\t(clojure.string/split str #\",\")))))", "user": "552456e3e4b0882d96d091c2"}, {"problem": 74, "code": "(fn [s]\n  (apply str (interpose \",\"\n                        (filter\n                         #(let [root (int (Math/sqrt %))] (= (* root root) %))\n                         (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "54864662e4b0e286459a11b8"}, {"problem": 74, "code": "(fn [ss] (apply str (interpose \",\"\n                     (map str (filter #(let [s (Math/sqrt %)] \n                                (= s (Math/floor s))) \n                             (map #(int (bigint %)) \n                                  (re-seq #\"\\d+\" ss)))))))", "user": "55b0f5bfe4b002ce9d5cbc28"}, {"problem": 74, "code": "(fn [str] (clojure.string/join \",\" (filter #(some (fn [candidate] (= %1 (* candidate candidate))) (range 1 (inc (Math/pow %1 0.5)))) (map #(Integer/parseInt %1) (re-seq #\"\\d+\" str)))))", "user": "55d95be7e4b0e31453f64ac9"}, {"problem": 74, "code": "(fn is-perfect-sqrt? [str]\n   (let [coll (-> str (.split \",\"))]\n     (clojure.string/join \",\" (filter #(== (int (Math/sqrt (Integer/parseInt %))) (Math/sqrt (Integer/parseInt %))) coll))\n     ))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 74, "code": "#(clojure.string/join \",\" (remove nil? (into [] (for [x (clojure.string/split % #\",\")] (if (= (Integer. x) (int (Math/pow (int (Math/sqrt (Integer. x))) 2)))\n                                                                           x )\n                                     ))))", "user": "55c423e1e4b0e31453f64994"}, {"problem": 74, "code": "(fn f-squares\n  [s]\n  (let [square? (fn [n] (some #(= (* % %) n) (range n)))\n        csl (fn [strings] (reduce #(str %1 \",\" %2 ) strings))]\n  (csl (filter #(square? (read-string %)) (clojure.string/split s #\",\")))))", "user": "55acd080e4b03311e7b73298"}, {"problem": 74, "code": ";; solution using a lazy-seq approach + recursivity:\n(fn filter-perf-squares [seq-str]\n  (letfn [(pow-x-start-with \n             [start]\n             (letfn [(pow [x] (reduce * [x x]))]\n               (lazy-seq\n                 (cons (pow start) (pow-x-start-with (inc start))))))\n          (split-by-comma\n            [str-seq]\n             (map read-string (clojure.string/split str-seq #\",\")))\n          (find-squares\n            [lazy-pows-seq xs acc]\n            (if (empty? xs)\n              (apply str (interpose \",\" acc))\n              (if (> (first lazy-pows-seq) (apply max xs))\n                (recur (rest lazy-pows-seq) (rest xs) acc)\n                (if-let [contained-x ((set xs) (first lazy-pows-seq))]\n                  (recur (rest lazy-pows-seq) (rest xs) (conj acc contained-x))\n                  (recur (rest lazy-pows-seq) xs acc)))))]\n    (find-squares (pow-x-start-with 2) (split-by-comma seq-str) [])))", "user": "5553b729e4b0deb715856e05"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n    (map #(Integer. %))\n    (filter #(= (float %) (Math/pow (Math/sqrt %) 2)))\n    (clojure.string/join \",\")))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 74, "code": "(fn [integer-str]\n  (clojure.string/join \",\" \n                       (reduce #(if (= (* (int (Math/sqrt (Integer/parseInt %2)))\n                                          (int (Math/sqrt (Integer/parseInt %2))))\n                                       (Integer/parseInt %2))\n                                  (conj % %2)\n                                  %)\n                               []\n                               (clojure.string/split integer-str #\",\"))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 74, "code": "(fn [s] \n  (->> (re-seq #\"\\d+\" s)\n       (map #(Integer. %))\n       (filter (fn [n] (some #(= n (* % %)) (range 1 n))))\n       (clojure.string/join \",\")))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 74, "code": "(fn [s]\n  (->> (.split s \",\")\n       (map #(Integer/parseInt %))\n       (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n       (clojure.string/join \",\")))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 74, "code": "(fn [i]\n  (->> (clojure.string/split i #\",\")\n     (map #(Integer/valueOf %))\n     (filter #(let [s (Math/sqrt %)] (= (Math/floor s) (Math/ceil s))))\n     (clojure.string/join \",\")))", "user": "4f85a75ce4b033992c121c48"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(zero? (rem (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Integer. %) (clojure.string/split s #\",\"))\n        perf-sqrt? (fn [x]\n                     (let [sq (int (Math/sqrt x))]\n                       (= x (* sq sq))))\n        ys (filter perf-sqrt? xs)]\n    (apply str (interpose \",\" (map str ys)))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 74, "code": "(fn [s] \n   (->> (re-seq #\"\\d+\" s)\n        (map #(Integer/parseInt %))\n        (filter #(let [x (int (Math/sqrt %))]\n                   (= % (* x x))))\n        (clojure.string/join \",\")))", "user": "55db7e15e4b0e31453f64ae8"}, {"problem": 74, "code": "(fn [list] (apply str (interpose \\, \n  (filter #(let [root (Math/sqrt (Integer.  %))]\n    (= (double (int root)) root)) (re-seq #\"\\d+\" list)))))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 74, "code": "(fn [ls] (->> (clojure.string/split ls #\"[, ]+\")\n              (map read-string)\n              (filter #(let [n (Math/sqrt %)]\n                          (zero? (- (int n) n))))\n              (clojure.string/join \",\")))", "user": "55236ad6e4b0882d96d091b1"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [x] (zero? (mod (Math/sqrt (Integer. x)) 1))) (clojure.string/split % #\",\")))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 74, "code": ";; \",,,\" is invisible to Clojure but serves as a visual\n;; reminder of where intermediate results are inserted\n;;\n(fn [str1] \n  (->> (clojure.string/split str1 #\",\")\n       (map #(Integer/parseInt %) ,,,)\n       (map (set (map #(* % %) (range 1 21))) ,,,)\n       (filter number? ,,,)\n       (map #(.toString %) ,,,)\n       (clojure.string/join \",\" ,,,)))", "user": "4f80db02e4b033992c121bf9"}, {"problem": 74, "code": "(fn [s]\n  (apply str\n    (interpose \\,\n      (filter\n        #(let [x (Math/sqrt %)] (= x (Math/floor x)))\n        (map #(Integer. %) (clojure.string/split s #\",\"))\n        )\n      )\n    )\n  )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 74, "code": "#(let [strs (clojure.string/split % #\"\\W\")\n       ints (for [n strs] (Integer/parseInt n))\n       psqr? (fn [n] (zero? (mod (Math/sqrt n) 1)))]\n   (apply str (interpose \\, (filter psqr? ints))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter\n                           (fn [x] (let [sq (Math/sqrt x)] (== sq (int sq))))\n                           (map (fn [x] (Integer/parseInt x)) (re-seq #\"\\d+\" %))))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"(filter (fn [x] (loop [n (read-string x) cnt 1]\n                              (cond (= n cnt) false\n                                    (= n (* cnt cnt)) true\n                                    :else (recur n (inc cnt))))) (clojure.string/split s #\",\"))))", "user": "55dab5c8e4b0e31453f64ada"}, {"problem": 74, "code": "(fn [s] \n   (let [ls (re-seq #\"\\d+\" s)\n         intls (map #(Integer/parseInt %) ls)\n         sq? (fn [n] (not (empty? (filter #(= (* % %) n) (range 2 n)))))\n         sql (filter #(sq? %) intls)]\n         (clojure.string/join \",\" (map #(str %) sql))))", "user": "55c77070e4b0e31453f649d0"}, {"problem": 74, "code": "(fn filter-perfect-squares\n  [s]\n  (let [ss (apply hash-set (map #(Integer/valueOf %) (clojure.string/split s #\",\")))\n        max-num (apply max ss)]\n    (clojure.string/join \",\" (filter ss (map #(* % %) (range max-num))))))", "user": "5586f418e4b059ccff29b1de"}, {"problem": 74, "code": "(fn [x]\n  (let [numbers (map #(Integer/parseInt %) (clojure.string/split x #\",\"))]\n    (->> numbers\n         (filter #(let [sq (Math/sqrt %)] (zero? (- sq (int sq)))))\n         (interpose \",\")\n         (apply str))))", "user": "500e6ddee4b04a05d36fcc06"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [digit] (= 0.0 (mod (Math/sqrt digit) 1))) (map read-string (clojure.string/split % #\",\"))))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 74, "code": "(fn f [input-string]\n    (letfn [\n        (binary-search [lower-limit upper-limit cmp-func]\n            (loop [lo lower-limit hi upper-limit result nil]\n                (if (< lo hi)\n                    (let [mid (bit-shift-right (+ lo hi) 1) cmp-result (cmp-func mid)]\n                        (cond\n                            (zero? cmp-result) (recur lo mid mid)\n                            (pos? cmp-result) (recur lo mid result)\n                            :else (recur (inc mid) hi result)\n                        )\n                    )\n                    result\n                )\n            )\n        )\n        (perfect-square? [x]\n            (binary-search 0 (inc x) #(- (* % %) x))\n        )\n    ]\n        (->>\n            (clojure.string/split input-string #\",\")\n            (map read-string)\n            (filter perfect-square?)\n            (clojure.string/join \",\")\n        )\n    )\n)", "user": "51f09f3de4b0274c496158d7"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter (set (for [x (range 1 10)] (* x x))) (map #(Integer/valueOf %) (re-seq #\"\\d+\" s)))))", "user": "541096bde4b01498b1a719b2"}, {"problem": 74, "code": "(fn [ss] \n  (clojure.string/join \n   \",\"\n       (filter \n        #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)) \n        (map #(Integer/parseInt %) (clojure.string/split ss #\",\")))))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 74, "code": "(fn [x]\n  (loop [result [] items (map #(Integer/parseInt %) (clojure.string/split x #\",\"))]\n    (if (empty? items)\n      (clojure.string/join \",\" result)\n      (let [item (first items)]\n        (if (= (double item) (Math/pow (Math/sqrt item) 2))\n          (recur (conj result item) (rest items))\n          (recur result (rest items))\n        )\n      )\n    )\n  )\n)", "user": "55d79b87e4b0e31453f64aa8"}, {"problem": 74, "code": "(fn [s]\n  (let [candidates (mapv #(Integer. %) (.split s \",\"))]\n    (letfn [(is-perfect-square [n] (some #(= n (* % %)) (range n)))]                                                                                                                                                     \n      (clojure.string/join \",\" (filter is-perfect-square candidates)))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 74, "code": "(fn squares [str]\n  (clojure.string/join \",\" (filter #(loop [v (int (/ % 2))]\n              (cond\n                (= v 1) false\n                (= % (* v v)) true\n                :else (recur (- v 1))))\n            (map  #(Integer/parseInt %) (clojure.string/split str #\",\")))))", "user": "55f04526e4b06e875b46ce20"}, {"problem": 74, "code": "(fn filter-perfct-squares\n  [string]\n  (let [given-seq (map #(Integer/parseInt %) (re-seq #\"\\d+\" string))\n        max-number (apply max given-seq)\n        predicate (into #{} (take-while #(<= % max-number) ((fn squares\n                                                  \t\t\t\t[x] (lazy-seq (cons (* x x) (squares (inc x))))) 1)))]\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t;; lazy sequence for all the perfect squares\n    (reduce #(str %1 \",\" %2) (filter predicate given-seq))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 74, "code": "(fn [string]\n  (->> string\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %1))\n       (filter #(zero? (- (int (Math/sqrt %1)) (Math/sqrt %1))))\n       (clojure.string/join \",\")))", "user": "539e717fe4b0ca733b974488"}, {"problem": 74, "code": "(fn [s] (->> (re-seq #\"\\d+\" s)\n             (map #(Integer/parseInt %))\n             (filter #(zero? (mod (Math/sqrt %) 1)))\n             (interpose \\,)\n             (apply str)))", "user": "54e1939ce4b024c67c0cf7c5"}, {"problem": 74, "code": "(fn [s]\n  (->>\n   (str \"[\" s \"]\")\n   read-string\n   (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n   (interpose \",\")\n   (apply str)))", "user": "55d5ee3fe4b0e31453f64a92"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\"\n                             (filter #(= 0.0 (mod (Math/sqrt (Integer/parseInt %)) 1))\n                                     (clojure.string/split s #\",\"))))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 74, "code": "(fn [num-string]\n  (clojure.string/join \",\" (filter (fn [n]\n                                     (let [s (Math/sqrt n)]\n                                       (= s (double (int s))))) (map read-string (clojure.string/split num-string #\",\")))))", "user": "55f778bee4b06e875b46ceab"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (clojure.string/split s #\",\")]\n    (clojure.string/join \",\"\n     (filter\n     \t#(if (re-find #\"\\d+\\.0$\" (str (Math/sqrt (Integer/parseInt %)))) %) \n     \tnums))))", "user": "53573d70e4b04ce2eb3ed278"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [x] (= ((fn [x] (* x x)) (int (. Math sqrt x))) x))\n                                  (map read-string (clojure.string/split % #\",\"))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 74, "code": "(fn perfect-squares2 [strg]\n  (let [pfsq? (fn [i]\n               (let [sqrt (Math/sqrt i)\n                     rmdr (zero? (rem sqrt (int sqrt)))]\n                 rmdr))\n        xs (map #(Integer/parseInt %) (.split strg \",\"))]\n    (apply str (interpose \",\" (filter pfsq? xs)))))", "user": "54dc49d3e4b024c67c0cf780"}, {"problem": 74, "code": "(fn prob74 [comma-string]\n  (let [string (clojure.string/split comma-string #\",\")\n        nums (map read-string string)\n        ]\n    (apply str (interpose \",\" (filter #(let [x (Math/sqrt %)] (= (float (int x)) x))  nums)))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 74, "code": "(fn to-nums [s]\n  (let [nums (map #(Integer. %) (.split s \",\"))\n        squares (filter (fn squarable? [n]\n                          (loop [x (dec n)]\n                            (cond\n                              (= n (* x x)) true\n                              (= x -1) false\n                              :else (recur (dec x))))) nums)]\n    (clojure.string/join \",\" (map str squares))))", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 74, "code": "(fn[s]\n    (\n      letfn [(int? [x] (==(- x (Math/floor x))0))\n             (msqrt [x] (Math/sqrt(Integer/parseInt x)))\n             (parse-int [x] (clojure.string/split x #\",\"))]\n      (clojure.string/join \",\" (filter #(int? (msqrt %))  (parse-int s)))))", "user": "5515b68de4b055c2f668d4ef"}, {"problem": 74, "code": "(fn [s]\n    (->> s\n    (re-seq #\"[0-9]+\")\n    (map read-string)\n    (filter #(== % (Math/pow (int (Math/sqrt %)) 2)))\n    (clojure.string/join \",\")))", "user": "55627de1e4b0c656e3ff17d9"}, {"problem": 74, "code": "(fn perfect-squares [numbers-str]\n  (let [numbers (map #(Integer/parseInt %)\n                     (clojure.string/split numbers-str #\",\"))]\n    (clojure.string/join \",\" (filter #(= %\n                 (* (int (Math/sqrt %))\n                    (int (Math/sqrt %))))\n             numbers))))", "user": "50e3e108e4b01912b3285c48"}, {"problem": 74, "code": "(fn __\n  [string]\n  (let [perfect-squares (reduce #(conj %1 (* %2 %2)) #{} (range 100))]\n   (->> \n     (clojure.string/split string #\",\") \n     (map #(java.lang.Long/parseLong %)) \n     (filter perfect-squares)\n     (clojure.string/join \",\"))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 74, "code": "(fn [thestr] (let [nums (map #(java.lang.Integer/parseInt %) (clojure.string/split thestr #\"\\,\"))]\n(apply str (interpose \",\" (for [num nums :when (integer? (rationalize (Math/sqrt num)))] (Integer/toString num))))\n))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 74, "code": "(fn [s]\n      (->> (clojure.string/split s #\",\")\n           (map #(Integer/parseInt %))\n           (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n           (clojure.string/join \",\")))", "user": "50a3ad0ee4b0ceace084d493"}, {"problem": 74, "code": "(fn [string-number]\n  (letfn [(perfect-square? [x] \n                           (loop [idx 1] \n                             (if (< (* idx idx) x) \n                               (recur (inc idx)) \n                               (= (* idx idx) x)\n                               )\n                             )\n                           )]\n    (clojure.string/join \",\"\n                         (filter perfect-square? \n                                 (map #(Integer/parseInt %) \n                                      (clojure.string/split string-number #\",\")\n                                      )\n                                 )\n                         )\n    )\n  )", "user": "55fe7e15e4b00f4cabc57651"}, {"problem": 74, "code": "#(->>\n  (clojure.string/split % #\",\")\n  (filter (fn [x] \n    (let [sq (Math/sqrt (read-string x))]\n      (= sq (Math/floor sq)))))\n  (clojure.string/join \",\"))", "user": "55fee5e4e4b00f4cabc5765a"}, {"problem": 74, "code": "(fn [s]\n  (let [psq? (fn [n]\n               (let [r (int (Math/sqrt n))]\n                 (= n (* r r))))\n        ints (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        psqs (filter psq? ints)]\n    (apply str (interpose \",\" psqs))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 74, "code": "(fn filter-perfect [st]\n  (let [squares (map #(* % %) (iterate inc 1))\n        perfect? (fn [x] (some #{x} (take-while (partial >= x) squares)))]\n    (apply str (interpose \",\" (filter perfect? (map #(Integer. %)\n                                                    (re-seq #\"\\d+\" st)))))))", "user": "560843dee4b046a4fc0ac00e"}, {"problem": 74, "code": "(fn [s]\n (letfn\n   [(to-nums [s]\n      (map\n        #(Integer/valueOf %)\n        (clojure.string/split\n          s #\",\")))\n    (only-sqrs [coll]\n      (filter\n        #(let [r (Math/sqrt %)]\n          (== r (int r)))\n        coll))\n    (to-str [coll]\n      (clojure.string/join \n        \",\" coll))]\n  (-> s \n      to-nums \n      only-sqrs \n      to-str)))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 74, "code": "(fn [s] (->> s \n     (re-seq #\"\\d+\") \n     (map #(Integer/parseInt %1)) \n     (filter #(let [p (Math/pow % 0.5)] (== p (int p)))) \n     (interpose \",\") \n     (apply str)))", "user": "5602ab92e4b04bb52996e1a3"}, {"problem": 74, "code": "(fn [str]\n  (letfn [(perfect-square? [x] (let [sqrt (Math/sqrt x)]\n                          (zero? (- sqrt (int sqrt)))))]\n    (->> str\n         (.split #\",\")\n         (map #(Integer/parseInt %))\n         (filter #(perfect-square? %))\n         (clojure.string/join \",\")\n         )))", "user": "55e7d06ee4b050e68259b496"}, {"problem": 74, "code": "(fn [s] (-> s\n             (clojure.string/split #\",\")\n             (->> (map read-string)\n                  (filter (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x)))))\n                  (clojure.string/join \",\"))))", "user": "536be48ee4b0fc7073fd6e31"}, {"problem": 74, "code": "(fn [nums]\n   (apply str (interpose \\, (filter #(= (* (int (Math/sqrt %)) (int (Math/sqrt %))) %) (map #(Integer/parseInt %) (re-seq #\"[0-9]+\" nums))))))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 74, "code": "(fn [x]\n  (let [nums (read-string (str \"(\" x \")\"))\n        sqrs (filter #(let [s (int (Math/sqrt %))]\n                        (= (* s s) %)) nums)]\n    (apply str (interpose \",\" sqrs))))", "user": "5148bcbee4b05514c84b7cc6"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [x]\n                         (let [sqrt-x (int (Math/sqrt x))]\n                           (= (* sqrt-x sqrt-x) x)))]\n   (clojure.string/join\n    \",\"\n    (for [v-str (clojure.string/split s #\",\")\n          :let [v (Integer/parseInt v-str)]\n          :when (perfect-square? v)]\n      (str v)))))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 74, "code": "#(apply\n  str\n  (interpose \n   \",\" (filter\n        (fn [n] (let [sqrt (Math/sqrt (Integer. n))]\n           (= (Math/floor sqrt) (Math/ceil sqrt))))\n        (re-seq #\"\\w+\" %))))", "user": "532ecd44e4b019098a6f8b49"}, {"problem": 74, "code": "(fn [l]\n  (clojure.string/join \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n          (map read-string (clojure.string/.split l \",\"))\n          )))", "user": "56051095e4b08b23635d3162"}, {"problem": 74, "code": "(fn [s]\n  (->> (.split s \",\")\n       (map #(Integer/parseInt %))\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 74, "code": "(fn [s]\n    (->> (re-seq #\"\\d+\" s)\n         (map #(Integer. %))\n         (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n         (map str)\n         (interpose \",\")\n         (apply str)))", "user": "560e9a2de4b05f002753df52"}, {"problem": 74, "code": "(fn [s] (->> (.split s \",\")\n             (map #(Integer/parseInt %))\n             (filter #(let [r (Math/round (Math/sqrt %))]\n                   (= % (* r r))))\n             (clojure.string/join \",\")))", "user": "553698fae4b09218d5f44fc0"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\" (filter \n     (fn [a] (let [r (Math/sqrt a)] (= (float (int r)) r))) \n     (map read-string (re-seq #\"\\d+\" s))\n    ))\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 74, "code": "(fn [text]\n    (let [sqrt-perfect? #(let [sqrt (Math/sqrt (Integer/parseInt %))\n                               floor-sqrt (Math/floor sqrt)]\n                           (= sqrt floor-sqrt))]\n      (->> (clojure.string/split text #\",\")\n           (filter sqrt-perfect?)\n           (clojure.string/join \",\" ))))", "user": "532f8569e4b019098a6f8b4f"}, {"problem": 74, "code": "(fn[n](apply str (interpose \",\" (filter #(= 0.0 (mod (Math/sqrt (Integer. %)) 1)) (re-seq #\"\\d+\" n)))))", "user": "555c6344e4b0b056612e224c"}, {"problem": 74, "code": "(fn [s]\n(clojure.string/join \",\"(filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))  (map read-string (clojure.string/split s #\",\")))))", "user": "5559b443e4b0deb715856e3c"}, {"problem": 74, "code": "(fn [s]\n  (->> (read-string (str \"(\"s\")\"))\n       (filter #(let [s (int (Math/sqrt %))] (= (* s s) %)))\n       (interpose \\,)\n       (apply str)))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 74, "code": "(fn [s](->> s\n\t(.split #\",\")\n    (map read-string)\n    (filter #(->> % Math/sqrt int (repeat 2) (apply *) (= %)))\n    (interpose \",\")\n    (apply str)\n))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 74, "code": "(fn pfsqr [s]\n  (letfn [(is-perfect [n]\n            (let [sqrt (java.lang.Math/sqrt n)]\n              (= sqrt (java.lang.Math/floor sqrt))))]\n    (-> s\n      (clojure.string/split #\",\")\n      (->> (map #(java.lang.Integer/parseInt % 10))\n           (filter is-perfect)\n           (map str)\n           (clojure.string/join \",\")))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 74, "code": "(fn[s](\n       apply str (interpose \",\" (filter #(not(> (Math/sqrt (Integer/parseInt %)) (int(Math/sqrt (Integer/parseInt %))) )) (clojure.string/split s #\",\")))\n       ))", "user": "56039843e4b04bb52996e1be"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" \n                     (filter \n                       (fn [c] (let [i (. Integer parseInt c)] \n                                 ((into #{} (map #(* % %) (range i)))\n                                   i))) \n                       (clojure.string/split s #\",\"))\n                     ))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 74, "code": "(fn foo [s]\n  (letfn [(perfect? [n]\n                    (let [r (Math/sqrt n)]\n                      (= r (Math/floor r))))]\n    (->> s\n         (#(clojure.string/split % #\",\"))\n         (map #(Integer/parseInt %))\n         (filter perfect?)\n         (clojure.string/join \",\")\n         )))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "561bc8e3e4b064ca9f4b1689"}, {"problem": 74, "code": "(fn [s]\n    (apply str\n           (interpose \",\"\n                      (filter\n                       #(== (int (Math/sqrt %)) (Math/sqrt %))\n                       (map #(Integer. %) (re-seq #\"\\d+\" s)))))\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 74, "code": "(fn [s] \n  (apply str (interpose \",\" \n                        (filter #(let [v (int (Math/sqrt %))] (= % (* v v)))\n                        (read-string (str \"[\" s \"]\"))))))", "user": "561047eae4b05f002753df6d"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join\n    \",\" (filter #(zero? (mod (Math/sqrt %) 1))\n                (map #(Integer/parseInt %)\n                     (.split s \",\")))))", "user": "55b1e9e7e4b0da326a65cf74"}, {"problem": 74, "code": "(fn [xs]\n  (->> xs\n    (re-seq #\"\\d+\")\n    (map #(Integer. %))\n    (filter #(= (Math/sqrt %) (float (int (Math/sqrt %)))))\n    (clojure.string/join \",\")))", "user": "5573ffb5e4b0aa18f790f3fd"}, {"problem": 74, "code": "(fn [numbers]\n  (clojure.string/join \",\" (map str (filter (fn [n] (integer? (rationalize (Math/sqrt n)))) (map read-string (clojure.string/split numbers #\",\")  )\n  ))))", "user": "55aa5f73e4b0988bba2ad94b"}, {"problem": 74, "code": "(fn parse-perfect-squares\n  [ss]\n  (apply str(interpose \",\" (filter #(let [rt (Math/sqrt %)] (= (Math/floor rt) rt))\n                          (map #(Integer/parseInt %) (clojure.string/split ss #\",\"))))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 74, "code": "(fn [nums]\n  (clojure.string/join \",\"\n                       (filter (fn [numberString]\n                                 (let [num (Integer/parseInt numberString)]\n                                   (some #{num}\n                                         (map #(* % %)\n                                              (range num)))))\n                               (clojure.string/split nums #\",\"))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 74, "code": "(fn [s] (let [n (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n              psn (filter #(zero? (rem (Math/sqrt %) 1)) n)]\n          (apply str (interpose \",\" psn))))", "user": "4f0f01c0535d0136e6c22329"}, {"problem": 74, "code": "(fn [s]\n   (->> s\n        (re-seq #\"\\d+\")\n        (map #(Integer. %))\n        (filter #(let [sq (Math/sqrt %)]\n                   (= sq (-> sq int float))))\n        (clojure.string/join \",\")))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 74, "code": "(fn perfect-squares\n  [s]\n  (let [sqrt\n        (fn [x]\n          (Math/sqrt x))\n\n        whole-number?\n        (fn [x]\n          (or (integer? x)\n              (= x (Math/floor x))))\n\n        perfect-square?\n        (comp whole-number? sqrt)\n\n        string->integers\n        (fn [s]\n          (map read-string (re-seq #\"\\d+\" s)))]\n\n    (->> s\n         (string->integers)\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "5614fa1de4b05f002753dfbe"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map read-string (clojure.string/split s #\",\"))\n        pred #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))]\n    (->> xs\n      (filter pred)\n      (clojure.string/join \",\"))))", "user": "54dce62be4b024c67c0cf78b"}, {"problem": 74, "code": "(fn pfsq[st]\n  (clojure.string/join\n    \",\"\n    (map\n      str\n      (filter\n        #(let [i (int (Math/sqrt %))]\n           (= (* i i) %))\n        (map\n          #(Integer/parseInt %)\n          (clojure.string/split st #\",\"))))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 74, "code": "(fn [numbers]\n  (clojure.string/join \",\"\n   (filter\n    (fn is-perfect-sqare [n]\n      (some #(= n (* % %)) (range 1 (inc (int (/ n 2.0))))))\n    ((fn str-to-ints [s]\n       (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))) numbers))))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map read-string (clojure.string/split s #\",\"))]\n    (clojure.string/join (interpose \",\" (map str (filter #(let [x (int (Math/sqrt (double %)))]\n                                                            (= (* x x) %)\n                                                            )\n                                                         xs))))\n    )\n  )", "user": "5628cb07e4b00e49c7cb47ef"}, {"problem": 74, "code": "(fn filter-squares [x]\n  (let [square (fn [y] (* y y))\n        square? (fn [z] (= z (square (Math/round (Math/sqrt z)))))] \n  (->> x\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter square?)\n       (clojure.string/join \",\"))))", "user": "53350264e4b0656e627bfd73"}, {"problem": 74, "code": "(fn [s]\n  (let [c (map bigdec (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (map str (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n            \t\t\t\t\t\t   c)))))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 74, "code": "(fn [s] (->> (re-seq #\"\\d+\" s) (map read-string) (filter (fn [n] (let [x (Math/sqrt n)] (== (* x x) n)))) (clojure.string/join \",\")))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 74, "code": "(fn [csv]\n  (->> (clojure.string/split csv #\",\")\n       (map read-string)\n       (filter\n         #(let [sqrt (Math/sqrt %)]\n           (= sqrt (Math/floor sqrt))))\n       (clojure.string/join \",\")))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (->> (seq s)\n       (partition-by #(= \\, %))\n       (#(partition 2 2 \",\" %))\n       (#(apply map vector %))\n        first\n       (map #(apply str %))\n       (map read-string)\n       (filter #(zero? (mod % (Math/sqrt %))))\n       (map str)\n       (interpose \",\")\n       (apply str)\n       ))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": 74, "code": "(fn [s]    \n (let [sts \t\t\t(clojure.string/split s #\",\")\n       nums \t\t(map read-string sts)\n       is_sq? \t\t(fn [x](= 0.0 (mod x (Math/sqrt x))))\n       filtered \t(filter is_sq? nums)\n       end-res \t\t(apply str (interpose \",\" filtered))]\n\tend-res))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 74, "code": "(fn [nstr]\n  (clojure.string/join \",\"\n    (filter #(zero? (mod % (Math/sqrt %))) \n            (map bigdec (re-seq #\"\\d+\" nstr)))))", "user": "5627444fe4b00e49c7cb47cd"}, {"problem": 74, "code": "; huh; other solution worked great in repl but not on 4clojure; not sure why; copying someone else's to make progress\n(fn perf-square [s] \n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\")) \n                 all-perf-sq  (set (map #(* % %) (range 100))) \n         sq-nums (filter all-perf-sq nums)] \n (apply str (interpose \",\" sq-nums))))", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\")\n       (map (comp int bigint))\n       (filter (fn [number] (== (int (Math/sqrt number)) (Math/sqrt number))))\n       (interpose \",\")\n       (apply str))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 74, "code": "(fn yoih [x]\n  (let [ngentot (fn ngentot [x]\n  (== x (* (Math/sqrt x)(Math/sqrt x))))\n        anjing (fn anjing [x]\n  (read-string (str \"[\" x \"]\")))\n        babi  (fn babi [x]\n  (clojure.string/join \",\" x))]\n    (babi (filter ngentot (anjing x)))))", "user": "55d9743ae4b0e31453f64aca"}, {"problem": 74, "code": "(fn perfect-squares\n  [s]\n  (let [perfect-square? (fn\n                          [n]\n                          (let [int-square (int (Math/sqrt n))]\n                            (= (* int-square int-square) n)))\n        numbers (->> (re-seq #\"\\d+\" s) (map #(Integer/parseInt %)))\n        result (->> numbers (filter #(perfect-square? %)) (interpose \",\") (apply str))]\n    result))", "user": "4fc524aae4b081705acca37e"}, {"problem": 74, "code": "(fn [s]\n(->> s\n \t (re-seq #\"\\d+\")\n     (map #(Integer/parseInt %))\n     (filter #(zero? (- (Math/sqrt %) (int (Math/sqrt %)))))\n     (clojure.string/join \",\")))", "user": "559067ace4b0277789237670"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) (map #(Integer/parseInt %) (.split x \",\")))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 74, "code": "(fn [x]\n  (->> (map #(Integer/parseInt %)\n            (clojure.string/split x #\",\"))\n       (filter #(= \\0 (last (str (Math/sqrt %)))))\n       (interpose \",\")\n       (apply str)))", "user": "55630cc1e4b0c656e3ff17e0"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\" \n                      (filter #(= % (let [sq (Math/round (Math/sqrt %))] (* sq sq))) \n                              (map #(Integer/parseInt %) \n                                   (clojure.string/split s #\"\\,\")))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 74, "code": "(fn [strings]\n   (->> strings\n        (#(clojure.string/split % #\",\"))\n        (map #(Double/parseDouble %))\n        (filter (fn [n]\n                  (->> n\n                       Math/sqrt\n                       (#(rem % (Math/round %)))\n                       zero?)))\n        (map int)\n        (clojure.string/join \",\")))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 74, "code": "(fn\n  [input]\n  (let [\n         numbers (map #(read-string %) (re-seq #\"\\d+\" input))\n         squares (map #(* % %) (iterate inc 1))\n         is-square? #(= % (first (drop-while (fn [v] (< v %)) squares)))\n        ]\n    (apply str (interpose \\, (filter is-square? numbers)))\n    )\n  )", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 74, "code": "(fn [st]\n   (->> st\n        (re-seq #\"[0-9]+\")\n        (map #(Integer/parseInt %))\n        (filter #(= 0.0 (Math/IEEEremainder (Math/sqrt %) 1.0)))\n        (map str)\n        (clojure.string/join \",\")))", "user": "563772a9e4b0bfe05bf117d7"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [numbers (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        is-perfect (fn [x] (zero? (rem (Math/sqrt x) 1.0)))]\n    (clojure.string/join \",\" (filter is-perfect numbers))\n  )\n)", "user": "56393681e4b0bfe05bf117f2"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [n]\n            #_(loop [i 1]\n              (let [square (* i i)]\n                (cond\n                  (= square n) true\n                  (> square n) false\n                  :else (recur (inc i)))))\n            (let [root (Math/sqrt n)]\n              (= root (-> root int double))))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "4fceda40e4b03432b189f407"}, {"problem": 74, "code": "(fn squares\n  [s]\n  (let [square? (fn [x]\n                  (let [sqrt (int (Math/sqrt x))]\n                    (= x (* sqrt sqrt))))]\n    (->> (clojure.string/split s #\",\")\n         (map bigint)\n         (filter square?)\n         (clojure.string/join \",\"))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 74, "code": "(fn [x] \n  (let [perfect #(= 0.0 (mod (Math/sqrt %) 1))]\n    (->> \n     (clojure.string/split x #\",\")\n     (map read-string)\n     (filter perfect)     \n     (interpose \",\")\n     (apply str)\n   )))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 74, "code": "(fn perfect-sqaures [x]\n   (clojure.string/join \",\"\n   (->>   x\n         (#(clojure.string/split % #\",\" ))\n         (map read-string)\n         (filter #{1 2 4 9 16 25 36})\n         (map str))))", "user": "5632b0a9e4b0bfe05bf117a8"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        sq (fn [n] (= (rem (Math/sqrt n) (Math/floor (Math/sqrt n))) 0.0))]\n    (apply str (interpose \",\" (filter sq xs)))))", "user": "563ed73ae4b08d4f616f5ecb"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map read-string)\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (sort)\n       (interpose \",\")\n       (apply str)))", "user": "51b8d3d5e4b050a1176cd69d"}, {"problem": 74, "code": "(fn fps [csv]\n  (->> (re-seq #\"[0-9]+\" csv)\n       (map read-string)\n       (filter (fn [num]\n                 (let [nsqrt (int (Math/sqrt num))]\n                   (= num (* nsqrt nsqrt)))))\n       (map str)\n       (interpose \",\")\n       (apply str)))", "user": "5641296de4b08d4f616f5ef4"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (.split s \",\"))\n        check (fn [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))]\n    (apply str (interpose \",\" (filter check nums)))))", "user": "545e7ab0e4b01be26fd7467c"}, {"problem": 74, "code": "(fn [nstring]\n  (let [coll (map #(Integer/parseInt %) (clojure.string/split nstring #\",\"))\n        o (for [x coll]\n     (if (<= (rem (if (> x 0) (Math/sqrt x) 0) 1) 0.00001)\n       (conj [] x)\n       \"no\"))\n        close (flatten (remove #{\"no\"} o))]\n    (clojure.string/join \",\" close)))\n\n\n; This method worked on the first test case but only handled one character integers.\n\n;(fn [nstring]\n;  (let [coll (remove #{-4} (map #(- % 48) (map int (seq nstring))))\n;        o (for [x coll]\n;     (if (<= (rem (if (> x 0) (Math/sqrt x) 0) 1) 0.00001)\n;       (conj [] x)\n;       \"no\"))\n;        close (flatten (remove #{\"no\"} o))]\n;    (clojure.string/join \",\" close)))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 74, "code": "(fn [n]\n  (clojure.string/join \",\" (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))\n                                   (map #(Integer. %) (clojure.string/split n #\",\")))))", "user": "50cf94bde4b0abc485cb9bb2"}, {"problem": 74, "code": "(fn [S]\n  \t(let [sqr (fn [x] (* x x))\n          is-square (fn [x] (= (sqr(Math/round(Math/sqrt x))) x ) )]\n       (clojure.string/join \",\" (map str (filter is-square (map biginteger (clojure.string/split S #\",\")))))\n      )\n  \t\t\n     \n  \n  )", "user": "5649615be4b0284900eef641"}, {"problem": 74, "code": "(fn [c] (clojure.string/join \",\" (filter #(let [d (read-string %) r (int (Math/sqrt d))] (= d (* r r))) (.split c \",\"))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 74, "code": "(fn [ls]\n  (apply str \n         (interpose \",\" \n                    (map str \n                         (filter \n                          (fn [x] \n                            (let [s (int (Math/sqrt x))] \n                              (= (* s s) x))) \n                          (map read-string \n                               (clojure.string/split ls #\",\")))))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 74, "code": "(fn list-to-str [l]\n\t(reduce #(str %1 \",\" %2) ((fn list-to-ints [a]\n\t(filter (fn perfect-square? [n]\n\t(loop [k 0]\n\t\t(if (> k n)\n\t\t\tfalse\n\t\t\t(if (= (* k k) n)\n\t\t\t\ttrue\n\t\t\t\t(recur (inc k)))))) (map read-string (clojure.string/split a #\",\")))) l)))", "user": "563d12f9e4b0bfe05bf11845"}, {"problem": 74, "code": "(fn [sl]\n  \n  (clojure.string/join \",\" \n                       \n(for [ xs (map bigint (clojure.string/split sl #\",\"))\n        :let [z (Math/sqrt xs)]\n        :when (= (Math/ceil z) (Math/floor z)) ]\n       (str xs)\n       )))", "user": "55c49394e4b0e31453f6499e"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? #(zero? (- (Math/sqrt %) (Math/floor (Math/sqrt %))))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "52f3568fe4b05e3f0be25f0e"}, {"problem": 74, "code": "(fn [s] \n  (apply str (interpose \",\" (filter \n                       \t\t#(= (Math/sqrt %) (float (int (Math/sqrt %)))) \n                       \t\t(map \n                             \t#(Integer. %) \n                             \t(re-seq #\"\\b\\d+\\b\" s))))))", "user": "564d02cde4b0284900eef679"}, {"problem": 74, "code": "(fn [s]\n\t(->>\n\t\t(clojure.string/split s #\",\")\n\t\t(map #(Integer/parseInt %))\n\t\t(filter #(= (* (Math/sqrt %) (Math/sqrt %)) (/ % 1.0)))\n\t\t(clojure.string/join \",\")\n\t)\n)", "user": "505fdf63e4b08f2a82ad10b9"}, {"problem": 74, "code": "(fn filter-perfect-square\n  [xs]\n  (clojure.string/join\n   \",\"\n   (filter #(= (rem % (Math/sqrt %)) 0.0)\n           (map #(Integer. %)\n                (clojure.string/split xs #\",\")))))", "user": "52561295e4b0541d1855ba03"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [i] (let [sqrt (Math/sqrt (Integer. i))]\n                        (= (Math/ceil sqrt) (Math/floor sqrt)))) (re-seq #\"\\d+\" %)))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 74, "code": "(fn [s]\n  (let [is-square (fn [i]\n                    (some\n                      #(= i %)\n                      (map\n                        #(* % %)\n                        (range (dec i) 1 -1))))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter is-square)\n         (clojure.string/join \",\"))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 74, "code": "(fn fx [string]\n  (->> (clojure.string/split string #\",\")\n       (map #(Integer. %))\n       (filter #(< (- % (java.lang.Math/pow (java.lang.Math/floor (java.lang.Math/sqrt %)) 2)) 0.001))\n       (interpose \",\")\n       (apply str)))", "user": "563f2eaae4b08d4f616f5ed1"}, {"problem": 74, "code": "#(clojure.string/join \n  \",\"\n  (filter (fn [a] (let [q (int (Math/sqrt a))] (= (* q q) a) ))\n          (read-string (str \"(\"\n                            %\n                            \")\"))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 74, "code": "#((comp (partial apply str) (partial interpose \",\")) (filter\n          (comp (fn [n] (seq (filter (fn [d] (and (= 0 (rem n d)) (= d (/ n d)))) (range 1 (dec n)))))\n                read-string)\n          (clojure.string/split % #\",\")))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \n   \",\"\n   (filter #(== (* (Math/sqrt %)\n                   (Math/sqrt %)) %)\n           (map #(Integer/parseInt %)\n                (clojure.string/split s #\",\")))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 74, "code": "(fn [coll]\n  (->>\n    (clojure.string/split coll #\",\")\n    (map #(Integer/parseInt %))\n    (filter #(= % (let [r (int (Math/sqrt %))]\n                (* r r))))\n   (clojure.string/join \",\")))", "user": "5169d422e4b051e2a73aba53"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        squares (take-while #(<= % (apply max nums)) (map #(* % %) (iterate inc 1)))]\n    (->> (filter (set squares) nums)\n         (map str)\n         (clojure.string/join #\",\"))))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (#(for [e %] (let [r (Math/sqrt e)] (when (== (Math/round r) r) e))))\n         (filter (complement nil?))\n         (clojure.string/join \",\")\n         ))", "user": "54a677a9e4b09f271ff37c88"}, {"problem": 74, "code": "#(clojure.string/join\n  \",\"\n  (for [num-str (.split % \",\")\n        :let [num (Integer/parseInt num-str)\n              sqrt (int (Math/sqrt num))]\n        :when (= (* sqrt sqrt) num)]\n    num))", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 74, "code": "(fn [a-seq]\n  (->>\n   (map read-string (re-seq #\"[\\d.]+\" a-seq))\n   (filter #{2 4 9 16 25 36})\n   (clojure.string/join \",\")))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 74, "code": "(fn [s] \n  (->> (re-seq #\"\\d+\" s)\n       (map read-string)\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "5654d0e1e4b0f9d632dd848c"}, {"problem": 74, "code": "(fn [arg1]\n(cond\n(and (= arg1 \"4,5,6,7,8,9\")) \"4,9\"\n(and (= arg1 \"15,16,25,36,37\")) \"16,25,36\"\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 74, "code": "(fn [nums]\n    (->> (clojure.string/split nums #\",\")\n         (map #(Integer/parseInt %))\n         (filter (fn [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n))))))\n         (clojure.string/join \",\")))", "user": "516db4f6e4b046df6fbb76a0"}, {"problem": 74, "code": "(fn perfect [s]\n  (letfn [(perfect-square? [x]\n  (let [root (Math/sqrt x)]\n    (= (double x) (* root root))))]\n  (let [ns (clojure.string/split s #\",\")\n        nums (map #(Integer/parseInt %) ns)]\n    (->>\n     nums\n     (filter perfect-square?)\n     (clojure.string/join \",\")))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 74, "code": "(fn [v] (->>\n                (clojure.string/split v #\",\")\n                (map #(Integer. %))\n                (filter #(let [x (Math/sqrt %)]\n                           (= x (* 1.0 (int x)))))\n                (map str)\n                (clojure.string/join \",\")\n                ))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 74, "code": "(fn [s]\n  (let [int-arr (map read-string (clojure.string/split s #\",\"))\n        filtered-arr (filter #(some (fn [x] (= (* x x) %)) (range %)) int-arr)]\n    (clojure.string/join \",\" filtered-arr)))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is_square? [n]\n            (let [sq (int (Math/sqrt n))]\n              (= n (* sq sq))))\n          \n            (s2l [s]\n              (clojure.string/split s #\",\"))\n          ]\n    (clojure.string/join \",\"\n      (filter #(is_square? %) \n          (map #(Integer/parseInt %) \n               (s2l s))))\n    ))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 74, "code": "(fn square-filter [x]\n  (let [numbers (map read-string (clojure.string/split x #\",\"))] \n(clojure.string/join \",\" \n(filter  \n    #(contains? (set (map * (range (apply max numbers)) (range (apply max numbers)))) %) numbers)\n      )\n)\n)", "user": "56304db8e4b073c1cf7a9be5"}, {"problem": 74, "code": "(fn [arg1]\n(cond\n(and (= arg1 \"4,5,6,7,8,9\")) \"4,9\"\n(and (= arg1 \"15,16,25,36,37\")) \"16,25,36\"\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 74, "code": "(fn [s]\n  (->> (.split #\",\" s)\n       (map #(Integer/parseInt %))\n       (filter #(let [x (int (Math/sqrt %))] (= (* x x) %)))\n       (map str)\n       (interpose \",\")\n       concat\n       (apply str)))", "user": "565a3e25e4b068f2fe63dbfb"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter #(zero? (mod (Math/sqrt (Integer/parseInt %)) 1)))\n       (clojure.string/join \",\")))", "user": "52f0ea04e4b05e3f0be25ee6"}, {"problem": 74, "code": "(fn [s]\n  (let [coll (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (->> coll\n         (map #(range 1 (inc (quot % 2))))\n         (mapcat (fn [numr coll]\n                   (mapcat (fn [denom]\n                             (let [res (* denom denom)]\n                               (if (= res numr)\n                                 [res]\n                                 [])))\n                           coll))\n                 coll)\n         (interpose \",\")\n         (apply str))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 74, "code": "(fn [s]\n        (clojure.string/join \",\"\n            (filter (fn [x] \n                        (let [sqrt (Math/sqrt x)]\n                        (= (int sqrt) (int (Math/ceil sqrt)))))\n                    (map (fn [S] \n                            (reduce\n                                (fn [acc X]\n                                    (+ ((fn [c] \n                                            (- (int c) (int \\0) )) \n                                        X) (* acc 10)))\n                                0\n                                S)) \n                        (clojure.string/split s #\",\")))))", "user": "566a840de4b0a866af68969c"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\"\n                        (filter #(= % (apply * (repeat 2 (Math/round (Math/sqrt %)))))\n                                (map #(Integer. %)\n                                     (clojure.string/split s #\",\")))))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 74, "code": "(fn ps [s] \n  (->> (clojure.string/split s #\"[, ]\")\n       (filter #(zero? (rem (Math/sqrt (Integer/valueOf %)) 1)))\n       (interpose \\,) \n       (apply str) ))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 74, "code": "(fn [s]\n  (apply str\n    (interpose \\,\n      (filter\n        #(== % (Math/pow (int (Math/sqrt %)) 2))\n        (map #(-> % clojure.string/join read-string)\n             (take-nth 2 (partition-by #(= \\, %) s)))))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 74, "code": "(fn f [s] \n  (-> (str \"[\" s \"]\") \n      (clojure.string/replace #\",\" \" \")\n      read-string\n      ((partial filter #(let [q (Math/sqrt %)]\n                         (= (double (int q)) q))))\n      ((partial clojure.string/join \",\"))))", "user": "558bb38fe4b0277789237631"}, {"problem": 74, "code": "(fn [str]\n  (clojure.string/join \n   \",\"\n   (let [nums (clojure.string/split str #\",\")]\n     (filter #(let [i (read-string %) \n                    sq (int (Math/sqrt i))] \n                (= sq (/ i sq))) \n             nums))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(let [t (Math/sqrt %)] (== (int t) t)))\n       (clojure.string/join \",\")))", "user": "54485749e4b032a45b8693c7"}, {"problem": 74, "code": "(fn [intstring] \n   (clojure.string/join \",\"\n                        (filter \n                         #(let [intnum (read-string %)\n                                introot (int (Math/floor (Math/sqrt intnum)))]\n                            (= (* introot introot) intnum))\n                         (clojure.string/split intstring #\",\"))))", "user": "567476bde4b05957ce8c6139"}, {"problem": 74, "code": "(fn [str-int-seq]\n  (apply\n    str\n    (interpose\n      \",\"\n      (filter\n        #(= (Integer. %)\n        (last \n          (take-while\n            (fn [sq] (<= sq (Integer. %)))\n            (map (fn [i] (* i i)) (range)))))\n        (re-seq #\"\\d+\" str-int-seq)))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 74, "code": "(fn [arg] (let [coll (clojure.string/split arg #\",\")\n                        nums (map #(Integer.  %) coll)\n                        perfect-square? (fn [n] (zero? (mod (Math/sqrt n) 1)))\n                        ]\n                    (apply str (interpose \",\" (filter perfect-square? nums)))\n                    )\n)", "user": "564a560ae4b0284900eef654"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n  \t(filter #(== (Math/sqrt %) (int (Math/sqrt %)))\n         \t (map #(Integer. %) (re-seq #\"\\d+\" s)))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 74, "code": "(fn extract-perfect-squares [s]\n  (letfn [(perfect-square? [n] \n                           (let [sqrt (int (+ 0.5 (Math/sqrt n)))]\n                             (= (* sqrt sqrt) n)))]\n    (let [numbers (map  #(Integer/parseInt %) (.split s \",\"))]\n      (clojure.string/join \",\" (filter perfect-square? numbers)))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 74, "code": "(fn [num-str] \n  (clojure.string/join \",\" (filter \n                            #(zero? (- (Math/sqrt %) (int (Math/sqrt %)))) \n                            (map #(Integer/parseInt %) (clojure.string/split num-str #\",\")))))", "user": "55efb51ee4b066087aa9453b"}, {"problem": 74, "code": "(fn [s]\n\t(clojure.string/join \",\"\n\t\t(filter (fn [x] (#{0 1 4 9 16 25 36 49 64 81 100} x))\n\t\t\t(map #(Integer. %) (re-seq #\"\\d+\" s)))))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 74, "code": "(fn [s]\n    (->>\n      (clojure.string/split s #\",\")\n      (map #(Integer/parseInt %))\n      (filter #(let [sq-rt (Math/sqrt %)]\n                (when (zero? (mod sq-rt (int sq-rt))) %)))\n      (clojure.string/join #\",\")))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join\n     \",\"\n     (filter\n      (fn [i] (= i (#(* % %) (int (Math/sqrt i)))))\n      (read-string (str \\[ s \\])))))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(integer? (rationalize (Math/sqrt (Integer/parseInt %1)))) (clojure.string/split s #\"\\,\"))))", "user": "567ea95de4b0feffd0d18eb6"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(== % (Math/pow (Math/floor (Math/sqrt %)) 2))\n      (map read-string\n        (clojure.string/split s #\",\")))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 74, "code": "(fn square [coll]\n  (let [nums (map read-string (clojure.string/split coll #\",\"))]\n    (clojure.string/join \",\" (filter #(= (* (int (Math/sqrt %1)) (int (Math/sqrt %1))) %1) nums))))", "user": "5658d775e4b00d3155796114"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n   (filter \n     (fn [a]\n       (let [sr (int (Math/sqrt a))\n             sq (* sr sr)]\n         (= a sq)))\n     (map #( Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 74, "code": "(fn [x] (->> x\n             (re-seq #\"\\d+\")\n             (map #(Integer/parseInt %))\n             (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n             (clojure.string/join \",\")))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 74, "code": "(fn [in]\n  (let [sqrt? (fn sqrt? [x]\n                (let [sqr (-> x (Math/sqrt) (int))\n                      self (* sqr sqr)]\n                  (= x self)))\n        nums (map #(Integer/parseInt %) (clojure.string/split in, #\",\"))\n        sqr_nums (filter sqrt? nums)]\n    (apply str (interpose \",\" sqr_nums))))", "user": "56669819e4b0e91d5f5c5674"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 74, "code": "(fn  squares [x] (clojure.string/join \",\" (filter #(= 0 (compare (Math/sqrt %) (int (Math/sqrt %)))) (map #(read-string %) (clojure.string/split x #\",\")))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n   (filter\n    (fn [x] (some #(= x (* % %)) (range x)))\n    (map read-string (.split s \",\")))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 74, "code": "(fn [c] (reduce str (butlast (reduce str (map (fn [b] (str b \",\"))  (filter (fn pSquare [n] (if (= (Math/floor (Math/sqrt n)) (Math/sqrt n)) true false)) (map #(Integer/parseInt %) (clojure.string/split c #\",\"))\n))))))", "user": "5676af21e4b05957ce8c6158"}, {"problem": 74, "code": "(fn [a] \n  (clojure.string/join \",\"  \n    (let [l (clojure.string/split a #\",\")]\n     (filter \n       #(let [x (Integer. %)]\n          (if (or (= 1 x) (= 0 x))\n            true\n            (loop [n 0 m x]\n              (let [y (quot (+ n m) 2) r (* y y)]\n                (if (= r x)\n                  true\n                  (if (or (zero? y) (= n y) (= m y))\n                    false\n                    (if (> r x)\n                      (recur n y)\n                      (recur y m)\n                    )\n                  )\n                )\n              )\n            )\n          )    \n        )\n      l)\n     )\n   )\n  )", "user": "56815e2fe4b0945ebc182a84"}, {"problem": 74, "code": "(fn [coll] \n  (clojure.string/join \",\"\n                         (filter\n                           #(let [tmp (int (Math/sqrt (Integer. %)))]\n                              (= (* tmp tmp) (Integer. %)))\n                           (clojure.string/split coll #\"\\D\"))))", "user": "5684e200e4b04eec3ec5cfc4"}, {"problem": 74, "code": "(fn filter-perfect-squares [numbers]\n  (->> (clojure.string/split numbers #\",\")\n       (map read-string)\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (map str)\n       (clojure.string/join \",\")\n       (str)))", "user": "567c7fefe4b05957ce8c61bc"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect? (fn [x] (some #(= (* % %) x) (range 2 x))) ]\n    (->> (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n         (filter perfect?)\n         (interpose \\,)\n         (apply str))))", "user": "567798afe4b05957ce8c6169"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join \",\" (filter (fn [n] (= n (#(* % %) (int (Math/sqrt n))))) (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n    )))", "user": "5681afaae4b0945ebc182a87"}, {"problem": 74, "code": "(fn [i]\n  (clojure.string/join \",\" (filter #(let [x (read-string %)] (-> x Math/sqrt int (Math/pow 2) (== x))) (clojure.string/split i #\",\")))\n  )", "user": "525d490ae4b0cb4875a45d70"}, {"problem": 74, "code": "(fn [s]\n  (let [items (clojure.string/split s #\",\")\n        integers (map #(Integer. %) items)\n        roots (map #(Math/sqrt %) integers)\n        psqs (map #(and (== %1 (* %2 %2)) %1) integers roots)]\n    (clojure.string/join \",\" (filter identity psqs))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 74, "code": "(fn [n]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split n #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "567931e9e4b05957ce8c6184"}, {"problem": 74, "code": "(fn [x] (->> x\n       (re-seq #\"\\d+\" )\n       (map #(Integer/parseInt %))\n       (filter #(let [s (int (Math/sqrt %))]\n                  (= (* s s) %)))\n       (clojure.string/join \",\")))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": 74, "code": "(fn [s]\n        (let [nums (map #(Integer/parseInt %) (.split s \",\"))]\n          (clojure.pprint/cl-format\n           nil\n           \"~{~d~^,~}\"\n           (for [num nums\n                 :let [sqrt (Math/sqrt num)]\n                 :when (= (double (int sqrt)) sqrt)]\n             num))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (clojure.string/join \n   \",\"\n   (filter (fn [n] (let [sqrt (Math/sqrt n)]\n                     (zero? (- sqrt (Math/floor sqrt)))))\n           (map #(Integer/parseInt %) (clojure.string/split s #\",\" )))))", "user": "56903cb9e4b0dcc4269f40eb"}, {"problem": 74, "code": "(fn check-sq[l]\n  ((fn thing [j]\n     (clojure.string/join \",\" (for\n      [x (take-while (partial >= (apply max j)) (map #(* %1 %1) (range)))\n      :when (some #(= % x) j)]\n      x)))\n  (map #(Integer/parseInt %) (clojure.string/split l #\",\")))\n)", "user": "566b8946e4b0a866af6896b0"}, {"problem": 74, "code": "(fn [s]\n  (letfn\n    [(perfSq? [n]\n             (let [a (first (drop-while #(< (* % %) n) (range (inc n))))]\n               (= (* a a) n)))]\n    (apply str (interpose \",\"\n                    (filter perfSq?\n                            (map #(Integer. %)\n                                 (clojure.string/split s #\",\")))))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 74, "code": "(fn [sq] \n  ;; join results\n  (clojure.string/join \",\" \n    ;; grab first of tuple\n\t(map first\n      ;; Return elements for which some x + 1 until n is a perfect square\n\t  (filter (fn [tl] (some #(= (* % %) (first tl)) (last tl)))\n        (map \n\t\t  #(let [n (read-string %)]\n\t\t   ;; return a tuple of n and range n, after splitting into nums. e.g. [4 (1 2 3 4)]\n             (vector n (range 1 n))) (clojure.string/split sq #\",\" ))))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 74, "code": "(fn [x] (let [nums (map bigint (clojure.string/split x #\",\"))\n               square? (fn [n] (some #(= n (* % %) )(range n)))]   \n           (clojure.string/join \",\" (filter square? nums))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 74, "code": "(fn psquares\n  [s]\n  (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        perfect? (fn [x]\n                   (let [r (Math/round (Math/sqrt x))]\n                     (= (* r r) x)))]\n    (clojure.string/join \",\" (filter perfect? xs))))", "user": "56488119e4b0284900eef632"}, {"problem": 74, "code": "#(->> \n (clojure.string/split % #\",\")\n (map (fn [s] (Integer/valueOf s)))\n  (filter (fn [x] (== (Math/sqrt x) (int (Math/sqrt x)))))\n  (clojure.string/join \",\"))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (filter #(zero? (rem (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "562e8b2be4b0ab312c17ebbb"}, {"problem": 74, "code": "(fn [s] \n  (->> (read-string (str \"(\" s \")\"))\n    (filter #(let [sqrt (Math/sqrt %)]\n              (== (int sqrt) sqrt)))\n    (interpose \",\")\n    (apply str)))", "user": "55f85b93e4b03cbcff9738ae"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [x]\n                           (some (filter #(= x %)\n                                         (range (inc (Math/sqrt x))))))]\n  (clojure.string/join \",\" (filter (fn [x] (== x (* (Math/floor (Math/sqrt x))\n                                                    (Math/floor (Math/sqrt x)))))\n          (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "4f856adfe4b033992c121c44"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (sort (clojure.set/intersection (set (map read-string (clojure.string/split s #\",\"))) (set (map #(* % %) (range 10)))))))", "user": "5668dcc6e4b04acd4f672df8"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(seq (for [x (range) :while (<= (* x x) %) :when (= (* x x) %) ] x)) (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [perfect-squares-sets (into #{} (take 100 (map #(* % %) (range))))]\n    (clojure.string/join \",\" (filter #(perfect-squares-sets %) (map read-string (re-seq #\"\\d+\" s))))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 74, "code": "(fn [numstr]\n  (let [splitstr (clojure.string/split numstr #\",\")\n        fnum (read-string (first splitstr))\n        lnum (read-string (last splitstr))\n        outp     (drop-while #(< % fnum) \n                         (take-while #(<= % lnum)\n                                    (map #(* % %) \n                                         (iterate inc 1))))]\n    (str (apply str (map #(str % \",\") (butlast outp))) (last outp))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 74, "code": "#(apply str (interpose \",\" (filter (fn [x] (some (fn [y] (= x y)) (map (fn [y] (str (* y y))) (range 1 9)))) (clojure.string/split % #\",\"))))", "user": "569c40cee4b0542e1f8d1462"}, {"problem": 74, "code": "(fn perfSquares[x] (clojure.string/join \",\" (filter \n                                             (fn perfSquare[x] (= (int (Math/pow (int (Math/sqrt x)) 2)) x)) \n                                             (map read-string (clojure.string/split x #\",\")))))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 74, "code": "(fn perf-squares\n  [s]\n  (reduce #(str %1 \",\" %2) \n          (filter #(== % (Math/pow (Math/sqrt %) 2)) \n                  (map read-string (re-seq #\"\\d+\" s)))))", "user": "56912f93e4b0dcc4269f40ef"}, {"problem": 74, "code": "(fn [x]\n(clojure.string/join \",\"\n(filter #(= 0.0 (mod (Math/sqrt %1) 1))\n     (map #(Integer/parseInt %1) (clojure.string/split x  #\",\"))\n    )))", "user": "55f9b2b6e4b03cbcff9738c8"}, {"problem": 74, "code": "(fn [x]\n  (->> (clojure.string/split x #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= % ((fn [v] (* v v)) (int (Math/sqrt %)))))\n       ((partial clojure.string/join \",\"))))", "user": "56a38a4ce4b0542e1f8d14cc"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= 0.0 (rem % (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 74, "code": "(fn [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer/parseInt % 10))\n    (filter #(zero? (mod (Math/sqrt %) 1)))\n    (clojure.string/join \",\")))", "user": "5630ce72e4b0bfe05bf11786"}, {"problem": 74, "code": "(fn[s] (apply str (interpose \",\" (filter #(let [r (int (Math/sqrt %))] (= (* r r) %)) (map read-string (re-seq #\"\\d+\" s))))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 74, "code": "(let [parse-int #(Integer/parseInt %)\n      square #(* % %)\n      sqrt #(Math/sqrt %)\n      is-square? #(= % (->> % sqrt int square))\n      join #(apply str (butlast (interleave %2 (repeat %1))))]\n  #(->> %\n        (re-seq #\"\\d+\")\n        (map parse-int)\n        (filter is-square?)\n        (join \",\")))", "user": "56ac81ace4b03c432f187347"}, {"problem": 74, "code": "(fn [c] (clojure.string/join \",\" (filter #(zero? (- (Math/sqrt %) (.intValue (Math/sqrt %))))\n                (map read-string (re-seq #\"\\d+\" c)))))", "user": "5339cb07e4b0e30313ee6caf"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [n](let [rn (Math/sqrt n)](== rn (int rn)))) (read-string (str \"[\" % \"]\"))))", "user": "5686b7c7e4b0dcc4269f4057"}, {"problem": 74, "code": "(fn f [str]\n  (let [xs (map read-string (re-seq #\"\\d+\" str))]\n    (->> (map #(Math/sqrt %) xs)\n         (map int)\n         (map #(* % %))\n         (#(filter (set %) xs))\n         (clojure.string/join \",\"))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 74, "code": "(comp #(apply str (interpose \\, %))\n      #(filter (set (map (fn [n] (str (* n n))) (range 7))) %)\n      #(clojure.string/split % #\",\"))", "user": "5617a540e4b06b1bb2182a12"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n    (map #(Integer/parseInt %))\n    (filter (fn [x]\n              (let [r (int (Math/sqrt x))]\n                (= x (* r r)))))\n    (interpose \",\")\n    (apply str)))", "user": "56a8b818e4b07966d5a8a06d"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is-perfect-square [x]\n            (some #(= x %) (for [y (range 1 (+ 1 (Math/sqrt x)))]\n                           (* y y))))]\n    (clojure.string/join \",\" (filter is-perfect-square (map #(Integer. %) (clojure.string/split s #\",\"))))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 74, "code": "(fn csps [string] \n  (clojure.string/join \n   \",\" \n   (filter \n    #(let [sqrt (Math/sqrt (Integer. %))] \n       (= sqrt (Math/floor sqrt)))\n    (clojure.string/split string #\",\"))))", "user": "525b4e8de4b0cb4875a45d0f"}, {"problem": 74, "code": "(fn [string]\n  (clojure.string/join \",\" \n    (filter number? \n      (map #(loop [x 2] \n        (let [sq (* x x)]\n          (cond \n           (< sq %) (recur (inc x))\n           (= sq %) %\n           (> sq %) false))) \n        (map #(Integer. %) (clojure.string/split string #\",\"))))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= 0.0 (mod (Math/sqrt %) 1)) (map #(Integer/parseInt %) \n     (clojure.string/split s #\",\")))))", "user": "56baab13e4b0f26550335948"}, {"problem": 74, "code": ";(filter #((let [v (int %)] = (* (int (Math/sqrt v)) (int (Math/sqrt v)) )  v))) \n(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 74, "code": "(fn [s]\n  (let [i (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        f (fn [n t]\n            (let [t2 (* t t)]\n              (cond\n                (= t2 n) true\n                (> t2 n) false\n                :else (recur n (inc t)))))]\n    (clojure.string/join \",\" (filter #(f % 2) i))))", "user": "56a76f36e4b07966d5a8a05b"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n    (apply str (interpose \",\" sq-nums))))", "user": "569ce6fee4b0542e1f8d146c"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter (fn [n] (some #(= (* % %) n) (range n))))\n       (interpose \",\")\n       (apply str)))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 74, "code": "(fn [s]\n  (apply str (interpose \",\" (for [n (map read-string (re-seq #\"\\d+\" s))\n                        \t\t  :let [is-perfect-square (some #(= n (* % %)) (range 1 n))]\n                        \t\t  :when is-perfect-square]\n                    \t\t\t(str n)))))", "user": "536673a8e4b0243289761e76"}, {"problem": 74, "code": "(fn [x]\n  (let [s (map read-string (clojure.string/split x #\",\"))]\n    (clojure.string/join \",\"\n                         (filter\n                           (fn [y] (contains? (set (take-while #(< % (inc (apply max s))) (map #(* % %)(range)))) y))\n                           s))))", "user": "56066e82e4b08b23635d3173"}, {"problem": 74, "code": "(fn [s]\n  (reduce #(str %1 \",\" %2)\n          (filter #{1,4,9,16,25,36,49}\n                  (map read-string (re-seq #\"\\d+\" s)))))", "user": "5638b88de4b0bfe05bf117e9"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(== (Math/sqrt %)\n                    (int (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "51db0d99e4b06aa4d4669a9d"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(let [r (Math/sqrt %)]\n                  (= r (Math/floor r))))\n       (interpose \",\")\n       (apply str)))", "user": "56baa68ce4b0f26550335947"}, {"problem": 74, "code": "(fn foo [s]\n  (clojure.string/join\n    \\,\n    (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))\n            (map #(Long/parseLong %)\n                 (clojure.string/split s #\",\")))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 74, "code": "(fn\n  [s]\n  (apply str (interpose \\, (filter #(let [x (int (Math/sqrt %))]\n                                     (= % (* x x))) (map (fn [ns] (Integer/parseInt ns)) (re-seq #\"\\d+\" s))))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 74, "code": "(fn square-filter\n  [s]\n  (let [coll (map #(int (read-string %)) (re-seq #\"\\d+\" s))\n        perfect-square? (fn[n] \n                          (let [r (Math/sqrt n)] (== r (int r)) ))]\n    (let [filtered-stuff (filter perfect-square? coll)]\n      (reduce #(str % \",\" %2) (str (first filtered-stuff)) (rest filtered-stuff)))))", "user": "5564709ee4b0c656e3ff1807"}, {"problem": 74, "code": "#(if (= (first %) \\4) \"4,9\" \"16,25,36\")", "user": "56b86e64e4b0f26550335924"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let [square? #(let [sq-i (int (Math/sqrt %))]\n                   (= % (* sq-i sq-i)))]\n    (->>\n     (clojure.string/split s #\",\")\n     (map #(Integer/valueOf %))\n     (filter #(square? %))\n     (interpose \",\")\n     (apply str))))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n    \",\"\n    (filter #(let [n (Math/sqrt(read-string %))]\n               (== n (int n))) (re-seq #\"[0-9]+\" s))))", "user": "56cd44fde4b0ea9b8538f749"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (not-empty (drop-while #(not= (* % %) n) (range 2 n)))) (map #(Integer. %) (re-seq #\"\\d+\" s)))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 74, "code": "(fn [string] (apply str (interpose \",\" (filter #(= (Math/floor (Math/sqrt (Integer/parseInt %1))) (Math/sqrt (Integer/parseInt %1))) (clojure.string/split string #\",\")))))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 74, "code": "(fn [st]\n  (->> (clojure.string/split st #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (interpose \",\")\n       (clojure.string/join)))", "user": "56481722e4b0284900eef628"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %)\n      (map read-string)\n      (filter #{4 9 16 25 36})\n      (interpose \",\")\n      (apply str)  \n)", "user": "56d80542e4b0ea9b8538f7e1"}, {"problem": 74, "code": "(fn [x]\n  (let [nums (->> x (re-seq #\"[0-9]+\") (map read-string))]\n    (clojure.string/join \",\" \n                         (reduce #(if (zero? (mod (Math/sqrt %2) 1)) (conj % %2) % ) [] nums))))", "user": "56d1afd9e4b0ea9b8538f791"}, {"problem": 74, "code": "(fn [s]\n   (let [square #(* % %)]\n     (->> (clojure.string/split s #\",\")\n          (map #(Integer. %))\n          (filter (fn [n] (= n (-> n (Math/sqrt) (Math/floor) (int) square))))\n          (clojure.string/join \",\"))))", "user": "55d62a68e4b0e31453f64a96"}, {"problem": 74, "code": "(fn [str]\n  (->>\n    (clojure.string/split str #\",\")\n    (map #(Integer. %))\n    (filter #(some (fn [i] (= (* i i) %)) (range (inc (/ % 2)))))\n    (clojure.string/join \",\")))", "user": "55f5c118e4b06e875b46ce8e"}, {"problem": 74, "code": "(fn [c]\n  (->> c\n       (re-seq #\"\\d+\")\n       (filter #(== (mod (Math/sqrt (read-string %)) 1) 0))\n       (clojure.string/join \",\")))", "user": "5541fa50e4b0a04f79299515"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [n]\n            (== (Math/sqrt n) (int (Math/sqrt n))))]\n    (clojure.string/join \",\"\n    \t\t\t\t\t(filter perfect-square? \n                                (map read-string (clojure.string/split s #\",\"))))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 74, "code": "(fn filter-square\n\t\n\t[str]\n\t(let [prow (fn prow [ [_ _ f :as row] ] ;; this fn Generate squares using Pascal's Triangle property\n\t\t\t\t   (let [[_ _ s :as nxt] (map +' (concat [0] row) (concat row [0]))]\n\t\t\t\t\t   (lazy-seq\n\t\t\t\t\t\t   (cons (+' f s) (prow nxt)))))\n\t\t  squares (prow [1 2 1])\n\t\t  nums (->> (-> str\n\t\t\t\t\t\t(clojure.string/split #\",\"))\n\t\t\t\t\t(map #(Integer/parseInt %)))\n\t\t  ]\n\t\t(->> nums\n\t\t\t (filter (fn [n]\n\t\t\t\t\t\t (let [candidate (take-while #(<= % n)\n\t\t\t\t\t\t\t\t\t\t\t\t\t squares)]\n\t\t\t\t\t\t\t (if (= n (last candidate))\n\t\t\t\t\t\t\t\t true\n\t\t\t\t\t\t\t\t false))))\n\t\t\t (clojure.string/join \\,))))", "user": "552bd5c2e4b0ffed3738f969"}, {"problem": 74, "code": "(fn [s]                                                              \n  (apply                                                                        \n    str                                                                         \n    (interpose                                                                  \n      \",\"                                                                       \n      (filter                                                                    \n        #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))                           \n        (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "563536f8e4b0bfe05bf117c5"}, {"problem": 74, "code": "(fn [s]\n  (apply str\n         (interpose \",\"\n                    (for [i (read-string (str \\[ s \\]))\n                          :when (some #(= i %) (map #(* % %) (range i)))] i))))", "user": "56aed78fe4b03c432f187363"}, {"problem": 74, "code": "(fn [string]\n  (let [data (map read-string\n                  (clojure.string/split string #\",\"))\n        perfect? (fn [n]\n                   (if (= n (#(* % %) (long (Math/sqrt n))))\n                     true\n                     false))]\n    (->> (filter perfect? data)\n         (map str)\n         (clojure.string/join \",\"))))", "user": "5297dcc5e4b02ebb4ef75047"}, {"problem": 74, "code": "(fn [num-str]\n  (clojure.string/join\n    \",\"\n    (filter (fn [num]\n              (let [root (Math/sqrt num)]\n                (== root (int root))))\n            (map #(Integer/parseInt %) (clojure.string/split num-str #\",\")))))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 74, "code": "(fn [s] \n  (let [a (clojure.string/split s #\",\")\n        b (map #(read-string %) a)\n        c (filter #(= 0.0 (mod (Math/sqrt %) 1)) b)]\n    (reduce #(str %1 \",\" %2) c)))", "user": "564d3169e4b0284900eef67c"}, {"problem": 74, "code": "(fn [in]\n  (let [pi #(Integer/parseInt %)\n        ps? #(= 0 (compare (Math/sqrt %) (int (Math/sqrt %))))]\n    (->> (clojure.string/split in #\"\\,\")\n         (map pi)\n         (filter ps?)\n         (clojure.string/join \",\"))))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 74, "code": "(fn perfect-sq [str]\n  (clojure.string/join \",\" \n                       (sort (vec (clojure.set/intersection \n                              (set (map #(* % %) (range 100))) \n                              (set (map #(Integer/parseInt %) (clojure.string/split str #\",\"))))))))", "user": "56278266e4b00e49c7cb47d3"}, {"problem": 74, "code": "(fn [input]\n  (loop [nums (map #(Integer/parseInt %) (clojure.string/split input #\",\"))\n         output \"\"]\n    (if (empty? nums)\n      output\n      (let [num (first nums)\n            append (str (if (= 0.0 (rem num (Math/sqrt num))) num \"\"))\n            sep (if (empty? append) \"\" (if (empty? output) \"\" \",\"))]\n        (recur (rest nums) (str output sep append))))))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n  (filter\n   #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n   (map read-string (clojure.string/split s #\",\")))))", "user": "56050f06e4b08b23635d3161"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect? #(= (Math/floor (Math/sqrt %)) (Math/sqrt %))]\n    (->>\n      (clojure.string/split s #\",\")\n      (map bigdec)\n      (filter perfect?)\n      (interpose \",\")\n      (apply str))))", "user": "56e2dbf4e4b03a7c14b85a3b"}, {"problem": 74, "code": "(fn [csv]\n(reduce #(str %1 \",\" %2)\n(filter (fn [x]\n\t\t\t\t(let [square (Math/sqrt x)]\n\t\t\t\t\t(= (rationalize (* square square)) x))) \n(map \n\t\t\t\t#(-> % (.trim) (Integer/parseInt)) \n\t\t\t\t(clojure.string/split csv #\",\")))))", "user": "565b941ce4b068f2fe63dc07"}, {"problem": 74, "code": "(fn [s] (str (clojure.string/join \",\" (filter #(= (Math/sqrt (Integer/valueOf %)) (Math/floor (Math/sqrt (Integer/valueOf %)))) (clojure.string/split s #\",\")))))", "user": "56e6ef89e4b02e7e935eb6d0"}, {"problem": 74, "code": "(fn [str]\n  (clojure.string/join\n    \",\"\n    (filter (fn [s]\n              (let [n (Integer. s)\n                    i (int (java.lang.Math/sqrt n))]\n                (= (* i i) n))) (clojure.string/split str #\"\\s*,\\s*\"))))", "user": "55101237e4b06e50f9beb181"}, {"problem": 74, "code": "(fn\n  [data]\n  (clojure.string/join \",\" (map :num (filter #(zero? (rem (:remain %) 1)) (map #(hash-map :num % :remain (Math/sqrt %)) (map read-string (re-seq #\"[0-9]+\" data)))))))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(zero?\n                 (compare (Math/sqrt %)\n                          (int (Math/sqrt %)))))\n       (map str)\n       (clojure.string/join \",\")))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 74, "code": "(fn solve [x] \n  (let [\n    nums (map #(Integer. %) (clojure.string/split x #\",\"))\n    squares (set (for [k (range 1000)] (* k k)))\n    ]\n    (reduce #(str %1 \",\" %2) (filter #(contains? squares %) nums))\n  )\n)", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect? [n] (let [sr (Math/sqrt n)] (= (Math/floor sr) sr)))]\n    (let [ds (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n      (clojure.string/join \",\" (filter perfect? ds)))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 74, "code": "(fn perfectsq [numlist]\n  (let [nums (map read-string (clojure.string/split numlist #\",\") )\n        is-perfect-sq (fn [n]\n                        (first (for [i (range 2 (inc (/ n 2))) :when (= (/ n i) i)] n)))]\n    (clojure.string/join \",\" (filter is-perfect-sq nums))\n    )\n  )", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \n         \",\" \n         (filter \n          #(== (Math/sqrt %) (int (Math/sqrt %))) \n          (map \n           #(-> % read-string int) \n           (clojure.string/split s #\",\")))))", "user": "5292feb4e4b0239c8a67af39"}, {"problem": 74, "code": "(fn [s]\n   (letfn [(is_square? [x] (= (#(* % %) (int (Math/sqrt x))) x))]\n\n     (->> s (re-seq #\"\\d+\")\n          (map #(Integer/parseInt %))\n          (filter is_square?)\n          (clojure.string/join \",\"))))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 74, "code": "(fn [string]\n  (apply str\n    (interpose \",\"\n     (filter\n      #(-> % Math/sqrt ((fn [i] (mod i 1))) zero?)\n      (map #(Integer. %)\n       (clojure.string/split string #\",\"))))))", "user": "56bf4ac0e4b0f26550335985"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join\n     \",\"\n     (filter (fn [n]\n               (let [r (Math/sqrt (Integer/parseInt n))]\n                 (= (-> r int double) r)))\n             (clojure.string/split s #\",\"))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map (fn [n] (Double/parseDouble n)))\n        (filter #(= (Math/pow (Math/round (Math/sqrt %)) 2) %))\n        (map (fn [n] (.toString (.intValue n))))\n        (clojure.string/join \",\")\n        )\n   )", "user": "56f15eade4b04a395b9a048e"}, {"problem": 74, "code": "(fn [csv]\n  (let [nums (map read-string (clojure.string/split csv #\",\"))\n        sqrs (filter #(zero? (mod (Math/sqrt %) 1)) nums)\n        sqr-strs (map str sqrs)]\n    (clojure.string/join \",\" sqr-strs)))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 74, "code": "(fn perf-sq-str [s]\n  (let [xs (map #(Integer/parseInt %) (re-seq #\"[\\d]+\" s))\n        sq? (fn [x] (= x (int (Math/pow (int (Math/sqrt x)) 2))))]\n    (clojure.string/join \",\" (filter sq? xs))))", "user": "5703eda3e4b08d47c9778200"}, {"problem": 74, "code": "(fn [s]\n   (let [strlist (re-seq #\"\\d+\" s)\n         numbers (map #(Integer/parseInt %) strlist)\n         square? (fn [n] (== (int (Math/sqrt n)) (Math/sqrt n)))\n         squares (filter square? numbers)]\n     (apply str (interpose \",\" (map str squares)))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join\n     \",\"\n     (reduce\n      (fn [acc s]\n        (if ((fn [[n r]]\n               (= n (* r r))\n               )\n             (#(vector % (int (+ 0.5 (Math/sqrt %))))(Integer/parseInt s)))\n          (conj acc s)\n          acc))\n      []\n      (clojure.string/split s #\",\")\n      ))\n    )", "user": "56f9392ae4b07572ad1a88ac"}, {"problem": 74, "code": "(fn filter-perf-sq [s]\n  (let [numsv (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq numsv)]\n(apply str (interpose \",\" sq-nums))))", "user": "57023fc2e4b08d47c97781db"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter (fn [n]\n             (some #(= (* % %) n)\n                   (take-while #(<= (* % %) n) (range))))\n           (read-string (str \\[ s \\])))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" \n    (filter #(= % (Math/round (Math/pow (Math/round (Math/sqrt %)) 2)))\n      (map read-string (re-seq #\"\\d+\" s)))))", "user": "51e5a627e4b0efabf93c02db"}, {"problem": 74, "code": "(fn [l]\n  (let [ns (map #(Integer/parseInt %) (clojure.string/split l #\",\"))\n        perfect-sq? (fn [n] (some #(= (* % %) n) (range 1 n)))\n        res (filter perfect-sq? ns)]\n    (clojure.string/join \",\" res)))", "user": "56372c3ce4b0bfe05bf117d1"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter (fn [x]\n                 (loop [i 1]\n                   (let [i_sqr (* i i)]\n                     (cond\n                      (= x i_sqr) true\n                      (< x i_sqr) false\n                      :else (recur (inc i)))))))\n       (clojure.string/join \",\")))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (apply str (interpose \",\" (map str (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n                                  (map #(java.lang.Integer/parseInt %)\n                                       (clojure.string/split s #\"\\W\")))))))", "user": "56f4cedce4b046a417f92063"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n     (re-seq #\"\\d+\")\n     (map #(Integer/parseInt %))\n     (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n     (clojure.string/join \",\")))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 74, "code": "(fn [s] (let [num-seq (map biginteger (re-seq #\"\\d+\" s))] (clojure.string/join \",\" (filter #(= % (* (int (Math/sqrt (\n                                   .doubleValue %)))\n                 (int (Math/sqrt (\n                                   .doubleValue %)))\n                 ) ) \n                                                                                                num-seq ) \n                                                           ) ))", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": 74, "code": "(fn [x] (->>\n(clojure.string/split x #\",\")\n(map #(Integer/parseInt %))\n(filter #(let [s (new BigDecimal (Math/sqrt %1))] (zero? (compare s (.setScale s 0 BigDecimal/ROUND_HALF_UP)))))\n(clojure.string/join \",\")\n))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 74, "code": "(fn [x] \n  (->>\n   (clojure.string/split x #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(let [root (Math/sqrt %)] (= (Math/floor root) root)))\n   (reduce #(str %1 \",\" %2) )\n   )\n  )", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 74, "code": "(fn [s]\n  (->> (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n       (filter #(zero? (rem (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 74, "code": "(fn y [x]\n  (->> (clojure.string/split x #\",\")\n  \t(map #(Integer. %))\n  \t(filter (fn[n]\n              (some #(= n (* % %)) (range 1 n))\n             ) \n    )\n    (map str)\n  \t(clojure.string/join \",\")\n  )\n  \n  )", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 74, "code": "(fn [s]\n  (->> (read-string (str \"[\" s \"]\"))\n     (filter #(zero? (rem (Math/sqrt %) 1)))\n     (clojure.string/join \",\")\n     ))", "user": "56102f50e4b05f002753df6b"}, {"problem": 74, "code": "(fn fooSquares [s]\n  (letfn [(parse-int [s](Integer/parseInt (re-find #\"\\A-?\\d+\" s)))\n\n          (getNumbers [s]\n            (map #(parse-int (apply str %))\n              (filter #(not (= [\\,] %))\n                (partition-by #(not (= \\, %))\n                  (apply list s)))))\n\n          (isSquare [x]\n            (= (rem (Math/sqrt x) 1) 0.0))\n\n          (getSquares [coll]\n            (filter isSquare coll))]\n    (apply str\n      (interpose \",\"\n        (map str (getSquares (getNumbers s)))))))", "user": "56fc0601e4b07572ad1a88db"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \\, (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (re-seq #\"\\d+\" s)))))", "user": "4e7dfab0535db169f9c796f9"}, {"problem": 74, "code": "(fn [st]\n  (let [split-at-commas (clojure.string/split st #\",\")\n        nums-seq (map #(int (bigdec %)) split-at-commas)\n        nums-max (apply max nums-seq)\n        squared #(* % %)\n        set-of-squares (set\n                         (map #(squared %)\n                              (take-while\n                                #(<= (squared %) nums-max)\n                                (range))))]\n    (clojure.string/join\n      #\",\"\n      (map str\n           (for\n             [x nums-seq :when (contains? set-of-squares x)]\n             x)))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 74, "code": "(fn [csv] (apply str (interpose \",\" (filter #(== (Math/sqrt %) (int (Math/sqrt %))) (map #(read-string %) (re-seq #\"\\d+\" csv))))))", "user": "57169f93e4b07c98581c3b00"}, {"problem": 74, "code": "(fn [s]\n  (let [nums \n        (map (fn [s] (. Integer parseInt s))     \n             (clojure.string/split s #\",\"))\n        \n        perfect-square\n        (fn [n]\n          (loop [x 1]\n           (if (>= x n) nil\n            (if (and (= (/ n x) x) (zero? (mod n x)))\n              n\n              (recur (inc x))))))]\n    (clojure.string/join \",\"                    \n     (map str (filter perfect-square nums)))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 74, "code": "(fn wtf [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        squares (set (take 10 (map #(* % %) (rest (range))))) ;; obviously this is bad, better to search ordered squares list\n        psquares (filter squares nums)\n        ret (clojure.string/join \",\" psquares)]\n    ret))", "user": "571d063ee4b0145328a76272"}, {"problem": 74, "code": "(fn [string]\n    (let [stringtonums (map read-string (map #(apply str %) (filter #(not= [\\,] %) (apply partition-by #(not= % \\,) [string]))))\n          perfsquares (set (take (int (Math/sqrt (apply max stringtonums))) (map * (iterate inc 1) (iterate inc 1))))\n          nums (set stringtonums )]\n      (apply str(interpose \",\" (sort (into [] (clojure.set/intersection nums perfsquares)))))\n      ))", "user": "56ede653e4b04a395b9a0449"}, {"problem": 74, "code": "(fn [x] (clojure.string/join #\",\" (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 74, "code": "(fn my-74\n  [s]\n  (letfn [(parse-input \n            [inp] \n            (map read-string (clojure.string/split inp #\",\")))\n          (perf-sqr \n            [n] \n            (loop [i 1]\n              (cond (= (* i i) n) true\n                (> (* i i) n) false\n                :else (recur (inc i)))))\n          (create-output\n            [coll]\n            (apply str (interpose \",\" coll)))]\n    (create-output (filter perf-sqr (parse-input s)))))", "user": "56c3aca0e4b05cc29241ee90"}, {"problem": 74, "code": "(fn [s]\n            (let [parse-int (fn [v] (Integer/parseInt v))\n                  perfect-square? (fn [n]\n                                    (let [r (int (Math/sqrt n))]\n                                      (= n (* r r))))]\n              (->> (clojure.string/split s #\",\\s*\")\n                   (map parse-int)\n                   (filter perfect-square?)\n                   (clojure.string/join \",\"))))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (map str\n     (filter (fn [x] (= (#(* % %) (int (Math/sqrt x)))\n                        x))\n             (map read-string (re-seq #\"[0-9]+\" s))))))", "user": "506ef8c3e4b09350ab4199f4"}, {"problem": 74, "code": "(fn [s]\n  (let [sd (re-seq #\"[\\d]+\" s)\n        d (map #(Integer/parseInt %) sd)\n        sqr? #(let [x (Math/sqrt %)] \n                (= (- x (Math/floor x)) 0.0))\n        fl (filter sqr? d)\n        cm (interpose \",\" fl)]\n     (apply str cm)))", "user": "56f51879e4b046a417f92069"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (map read-string)\n             (filter #(zero? (rem (Math/sqrt %) 1)))\n             (clojure.string/join \",\")))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 74, "code": "(fn [s]\n  (let [input_nums (map #(Integer. %) (clojure.string/split s #\",\"))]\n    (let [square_nums (filter #(== (rem (Math/sqrt %) 1) 0) input_nums)]\n      (apply str (interpose \",\" square_nums)))))", "user": "57002b81e4b08d47c97781c7"}, {"problem": 74, "code": "(fn psquares [coll-s]\n  (->> (clojure.string/split coll-s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= 0.0 (- (int (Math/sqrt %)) (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "557e56aae4b05c286339e0d5"}, {"problem": 74, "code": "(fn [s] (->> (filter (fn [el]\n                        (let [n (Integer/parseInt el)\n                              sqrt (Math/sqrt n)]\n                          (not (> sqrt (int sqrt))))) (clojure.string/split s #\",\"))\n              (interpose \",\")\n              (apply str)))", "user": "56c60b36e4b05cc29241eead"}, {"problem": 74, "code": "(fn q[x]\n  (let \n    [xs (clojure.string/split x #\",\")\n     nums (map #(Integer/parseInt %) xs)\n     ret #(clojure.string/join \",\" %)\n    ]\n    (\n      ret (filter #(= % (-> % Math/sqrt Math/round ((fn[x](Math/pow x 2))) ((fn[x](int x))) )) nums) \n    )    \n  )\n)", "user": "5717d674e4b07c98581c3b1a"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter (fn [n] (some #(= n (* % %)) (range n))))\n       (map #(str % \",\"))\n       (apply str)\n       (butlast)\n       (apply str)\n  )\n)", "user": "569f99cce4b0542e1f8d1497"}, {"problem": 74, "code": "#(clojure.string/join\n \",\"\n (filter\n  (fn [s]\n    (let [n (Integer/parseInt s)\n          root (Math/sqrt n)]\n      (= (* root root) (float n))))\n  (clojure.string/split % #\",\")))", "user": "56eaad95e4b04a395b9a040f"}, {"problem": 74, "code": "(letfn [\n\n\n  (square? [x]\n    (let [squares (map #(* % %) (range))\n          near-squares (take-while #(<= % x) squares)]\n      ((complement nil?) ((set near-squares) x))))\n\n\n  (read-str-list-of-ints [s]\n    (map #(Integer/valueOf %) (clojure.string/split s #\",\")))\n\n\n  (join-str-list-of-ints [lst]\n    (clojure.string/join \",\" (map str lst)))\n\n\n  (solve [s]\n    (join-str-list-of-ints\n      (filter square? (read-str-list-of-ints s))))]\n\n\n  solve)", "user": "57300c19e4b0cd1946bd0fa1"}, {"problem": 74, "code": "(fn [s]\n  (let [i? (fn [m] (== (int m) m))\n        ps? (fn [m] (i? (Math/sqrt m)))\n        tl (fn [s] (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n        ts (fn [l] (apply str (interpose \",\" l)))]\n  (->> s\n      (tl)\n      (filter ps?)\n      (ts))))", "user": "5461dc79e4b01be26fd746a8"}, {"problem": 74, "code": "(fn pfsqs [s] (let [\n\tstrs (re-seq #\"[0-9]+\" s )\n\tnums (map #(Integer/parseInt %) strs)\n\tisps (fn isps [n] (let [\n\t\ts (Math/sqrt n)\n\t\tl (long s)\n\t\tn2 (* l l)\n\t\te (= n n2)\n\t] e))\n\tsqnums (filter isps nums)\n\tsqstr (clojure.string/join \",\" sqnums)\n] sqstr))", "user": "571aad45e4b07c98581c3b59"}, {"problem": 74, "code": "(fn [nums]\n  (let [sqrt #(Math/sqrt (read-string %))]\n    (->> (clojure.string/split nums #\",\") \n      (filter #(== (int (sqrt %)) (sqrt %)))\n      (clojure.string/join \",\"))))", "user": "4df73d64535d04ed9115e775"}, {"problem": 74, "code": "(fn [s]\n    (let [squares (fn sq [n] (concat [(* n n)]\n                                     (lazy-seq (sq (inc n)))))\n          input (map read-string (clojure.string/split s #\",\"))\n          start (reduce min input)\n          stop (reduce max input)\n          sq-range (into #{} (drop-while #(< % start) (take-while #(<= % stop) (squares 1))))\n          ]\n      (->> (filter sq-range input)\n           (clojure.string/join \",\"))\n      )\n    )", "user": "56791447e4b05957ce8c6183"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(parse-int [s] (Integer/parseInt s))]\n    (->> (clojure.string/split s #\",\")\n         (map parse-int)\n         (filter #(zero? (rem (Math/sqrt %) 1)))\n         (interpose \",\")\n         (apply str))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 74, "code": "(fn [int-string]\n  (let [perfect-square? (fn [i]\n                          (loop [root 1]\n                            (cond\n                             (< (* root root) i) (recur (inc root))\n                             (= (* root root) i) i\n                             :else false)))]\n    (clojure.string/join \",\"\n                         (filter\n                          perfect-square?\n                          (map read-string (clojure.string/split int-string #\",\"))))))", "user": "56cc34aee4b0ea9b8538f73c"}, {"problem": 74, "code": "(fn perfect [str] (clojure.string/join \\,  (filter #(= % (* (int (java.lang.Math/sqrt %)) (int (java.lang.Math/sqrt %))))  (map read-string (clojure.string/split str #\",\")))))", "user": "5646dff3e4b0284900eef615"}, {"problem": 74, "code": "(fn [s]\n  (let [numbers (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [x] (let [sqrt (Math/sqrt x)] (= sqrt (Math/floor sqrt))))]\n    (clojure.string/join \",\" (filter psquare? numbers))))", "user": "57283dbce4b0c5bde472c154"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n  (filter (fn [v] (some #(= v (* % %)) (range v))) (map read-string (clojure.string/split s #\",\"))\n)\n))", "user": "5739cbe4e4b0cd1946bd107c"}, {"problem": 74, "code": "(fn [s]\n  (->> s \n       (re-seq #\"\\d+\")\n       (map #(Long/parseLong %))\n       (filter #(== (Math/sqrt %) (Math/round (Math/sqrt %)))) \n       (clojure.string/join \",\")))", "user": "527c166de4b03e8d9a4a75b3"}, {"problem": 74, "code": "(fn split-perfect [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n       (map str)\n       (interpose \",\")\n       clojure.string/join))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 74, "code": "(fn [x] \n  (->> x\n       (re-seq  #\"[0-9]+\")\n       (map #(Integer/parseInt %) )\n       (filter #(let [x (Math/pow % 0.5)] (= x (Math/floor x))))\n       (interpose \",\")\n       (apply str)\n       ))", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 74, "code": "#_(if (= \\4 (first %)) \"4,9\" \"16,25,36\")\n\n(fn [s] (clojure.string/join \",\" (filter (set (map str (map * (range 9) (range 9)))) (clojure.string/split s #\",\"))))", "user": "4fa436dce4b081705acca19b"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range (apply max nums))))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "53da059be4b0e771c302547e"}, {"problem": 74, "code": "(fn [s]     \n    \n    (let [res (filter   (fn [n]  (some #(= (* % %) n)      (range 2 (inc (/ n 2) )) )   )   (map read-string (re-seq #\"[\\d]+\" s) ))]\n       (apply str (interpose \",\"  res))\n        \n    \n    )\n    \n    \n    )", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 74, "code": "(fn perf-sqs [s]\n  (let [nums (map read-string (clojure.string/split s #\",\"))\n        filtered (filter (comp not ratio? rationalize #(Math/sqrt %)) nums)]\n    (clojure.string/join \",\" filtered)))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 74, "code": "#(clojure.string/join \",\" (map str (filter (fn [x] (some (fn [t] (= x (* t t))) (range x))) (map bigint (clojure.string/split %1 #\",\")))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(integer? (rationalize (Math/sqrt (Integer/parseInt %1)))) (clojure.string/split s #\"\\,\"))))", "user": "574af03ce4b02ea114799202"}, {"problem": 74, "code": "(fn [s]\n    (let [v (map #(Integer. %) (clojure.string/split s #\",\"))\n          p-sq? #(let [rt (int (Math/sqrt %))]\n                   (= % (* rt rt)))]\n      (clojure.string/join \",\" (filter p-sq? v))))", "user": "52e1c276e4b09f7907dd142b"}, {"problem": 74, "code": "(fn [z] (clojure.string/join \",\" \n                             (loop \n                               [x (set (re-seq #\"\\d+\" z)) \n                                n 1  \n                                s []]\n                               (if (empty? x) \n                                 s \n                                 (recur (disj x (str n)) \n                                        (inc n) \n                                        (if (contains? x (str (* n n))) \n                                          (conj s (* n n)) \n                                          s))))))", "user": "573ce277e4b05c31a32c080b"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map read-string)\n        (filter #(== (Math/sqrt %) (int (Math/sqrt %))))\n        (clojure.string/join \",\")))", "user": "57458b82e4b009280f9f2b4e"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (\nfn[y](loop[i 1] (if (= y (* i i)) true (\nif (< y (* i i)) false (recur (inc i))\n)))\n) (map (fn[x](read-string x)) (clojure.string/split % #\",\")))\n)", "user": "574a9132e4b02ea1147991fd"}, {"problem": 74, "code": "(fn [shit]\n    (letfn [(int-sqrt [shit]\n              (let [sqrt (Math/sqrt shit)  rnd-sqrt (Math/round sqrt) ]\n                (when (zero? (Math/abs (- sqrt rnd-sqrt))) rnd-sqrt))) ]\n\n      (->> (clojure.string/split shit #\",\")\n        (map read-string)\n        (filter int-sqrt)\n        (interpose \\,)\n        (apply str))))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is-square? [x] (let [sqrt (int (Math/sqrt x))] (= x (* sqrt sqrt))))]\n\t (clojure.string/join \",\" (filter is-square? (map read-string (clojure.string/split s #\",\"))))))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 74, "code": "(fn [s]\n  (let [squards? (fn [x]\n                   (= (Math/sqrt x)\n                      (-> x\n                          Math/sqrt\n                          Math/floor)))\n        split-string (fn [s]\n                       (map #(Integer/parseInt %)\n                            (.split #\",\" s)))\n        join (fn [xs]\n               (apply str (interpose \",\" xs)))]\n    (->> s\n         split-string\n         (filter squards?)\n         join)))", "user": "5724a4dae4b0c5bde472c0fe"}, {"problem": 74, "code": "(fn filterPerfectSquares [inputStr]\n  (let [nums (map #(Integer. %) (seq (.split #\"\\D\" inputStr)))\n        maxNum (apply max nums)\n        squares (loop [base 2 sqrs [1]]\n                  (if (> (* base base) maxNum)\n                    sqrs\n                  (recur (inc base) (conj sqrs (* base base)))))]\n    (clojure.string/join \",\" (map str (filter (fn square? [x] (some #(= x %) squares)) nums)))\n    ))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Long/parseLong %))\n       (filter (fn [n]\n                 (= (->> n\n                         Math/sqrt\n                         Math/round\n                         (#(* % %)))\n                    n)))\n       (clojure.string/join \\,)))", "user": "575cbe44e4b02ea114799374"}, {"problem": 74, "code": "(fn perfect-squares [coll]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split coll #\",\"))\n        fraction #(- % (Math/floor %))\n        perfect? #(= (fraction (Math/sqrt %)) 0.0)]\n    (clojure.string/join \",\" (filter perfect? nums))))", "user": "55ed5a2de4b0121d4835fdd8"}, {"problem": 74, "code": "(fn p [s] (->> s (#(.split %1 \",\")) seq (map #(Integer. %1)) (filter #(>= (int (Math/sqrt %1)) (Math/sqrt %1))) (reduce #(str %1 \",\" %2)) ) )", "user": "575a0ef0e4b02ea114799335"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (filter\n (fn [n]\n   (let [n_2 (int (Math/sqrt n))]\n     (= n (* n_2 n_2))))\n (map #(Long/parseLong %) (clojure.string/split s #\",\"))))))", "user": "56efb3a3e4b04a395b9a0463"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (read-string (str \"[\" s \"]\")))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 74, "code": "(fn perfect-square [s]\n  (let [slist (clojure.string/split s #\",\")]\n    (clojure.string/replace-first\n     (reduce #(let [n (read-string %2)\n                    x (int (Math/sqrt n))]\n                (if (= (* x x) n) \n                  (str %1 \",\" %2)\n                  (str %1)))\n             \"\" slist) #\",\" \"\")))", "user": "574f1c24e4b02ea114799255"}, {"problem": 74, "code": "(fn fun [inp]\n        (->> (clojure.string/split inp #\",\")\n           (map read-string)\n             (map (fn f [x] (filter #(= x %) (take-while #(<= % x) (map #(* % %) (range))))))\n             (filter not-empty)\n             (map (partial apply str))\n             (interleave (repeat \\,))\n             rest\n             (apply str)))", "user": "575fbe58e4b08062f99a4e87"}, {"problem": 74, "code": "#(->>  % \n       (re-seq #\"\\d+\") \n       (map read-string) \n       (filter (fn [x] (== (int (Math/sqrt x))\n                           (Math/sqrt x))))\n       (map str)\n       (clojure.string/join \",\"))", "user": "57275898e4b0c5bde472c13e"}, {"problem": 74, "code": "(fn [s] \n  (letfn [(perfectSquare? [n] (some #(= n (* % %)) (range 0 (inc n)) ) )]\n    (let [nums (map read-string (.split #\",\" s))\n          perfectSquares (filter perfectSquare? nums)]\n      (apply str (interpose \",\" perfectSquares))\n      )\n    )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 74, "code": "(fn [s]\n  (letfn [\n    (perfect? [n]\n      (let [r (int (Math/sqrt n))]\n        (= (* r r) n)))]\n\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter perfect?)\n         (map str)\n         (clojure.string/join \",\"))))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 74, "code": "(fn perfect-square-css [css]\n  (clojure.string/join \",\" (filter #(> % 0) (map (fn [x]\n                                                   (loop [z 1]\n                                                     (if (>= z x)\n                                                       -1\n                                                       (if (= (* z z) x)\n                                                         x\n                                                         (recur (inc z)))))) (map (fn [x] (Integer. (re-find #\"\\d+\" x))) (clojure.string/split css #\",\")))))\n  )", "user": "574ed2f7e4b02ea11479924a"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [x] (some  #(= x (* % %)) (range 1 (inc x)))))\n       (clojure.string/join \",\")))", "user": "57642916e4b0994c1922fbee"}, {"problem": 74, "code": "(fn perfect-square? [x] \n\t(letfn [(square? [n]\n\t(cond\n\t\t(< n 0) false\n\t\t(= 0 n) true\n\t\t:else (loop [i 1, sum 1]\n\t\t\t(if (= sum n) \n\t\t\t\ttrue\n\t\t\t\t(if (> sum n) \n\t\t\t\t\tfalse\n\t\t\t\t\t(recur (+ 2 i) (+ sum (+ 2 i))))))))]\n\t(->> #\",\"\n\t\t(clojure.string/split x)\n\t\t(map #(Integer/parseInt %))\n\t\t(reduce #(if (square? %2) (conj % %2) %) [])\n\t\t(clojure.string/join \",\"))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n              (map #(Integer/parseInt %))\n              (filter #(let [sqr (Math/sqrt %)\n                             isqr (int sqr)]\n                        (= (int %) (* isqr isqr))))\n              (clojure.string/join \",\")))", "user": "573107d5e4b0cd1946bd0fbc"}, {"problem": 74, "code": "(fn filter-perfect-squares\n  [numbers]\n  (clojure.string/join \",\"\n                       (filter #(= (mod (Math/sqrt %) 1) 0.0)\n                               (map read-string (clojure.string/split numbers #\",\")))))", "user": "52ea025ae4b09f7907dd14b5"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\"\n     (filter\n       (fn [x]\n         (let [n (read-string x)]\n           (= 0.0 (- n (* (Math/sqrt n) (Math/sqrt n))))\n           )) \n       (clojure.string/split s #\",\"))))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(f [n]\n             (contains? (set (map #(* % %) (take (quot n 2) (iterate inc 1)))) n))]\n  (let [no-commas (clojure.string/split s #\",\")\n        nums (map #(Integer. (re-find  #\"\\d+\" %)) no-commas)\n        perfects (filter #(f %) nums)]\n    (clojure.string/join \",\" perfects))))", "user": "55aaa36fe4b0988bba2ad94f"}, {"problem": 74, "code": "(fn [astr]\n  (let [aseq (map read-string (clojure.string/split astr #\",\"))]\n    (->>\n     (for [i aseq\n           :when (= 0.0 (- (Math/sqrt i) (int (Math/sqrt i))))]\n       i)\n     (clojure.string/join \",\"))))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 74, "code": "#(case (count %) 11 \"4,9\" \"16,25,36\")", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 74, "code": "(fn[s](apply str (interpose \",\" (map str (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map read-string (re-seq #\"\\d+\" s)))))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    (fn [v] (-> v read-string Math/sqrt (rem 1) zero?))\n    (re-seq #\"\\d+\" s))))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 74, "code": "(fn [s]  (apply str (interpose \",\" (filter (set (clojure.string/split s #\",\")) (map #(str (* % %)) (range 10))))))", "user": "53b4bddae4b047364c0444b9"}, {"problem": 74, "code": "(fn [n]\n    (clojure.string/join\n      \",\"\n      (filter #(let [s (first (drop-while (fn [x] (> % (* x x))) (iterate inc 1)))]\n                    (= (* s s) %))\n              (map #(Integer/parseInt %)\n                   (clojure.string/split n #\",\")))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 74, "code": "(fn prime-filter [coll]\n     (let [one (clojure.string/split coll (re-pattern \",\"))\n           one-2 (map read-string one)\n   \n           one-1 (map (fn [x] (* x x)) (range))\n           two  (for [x one-2\n                      :let [three (take-while #(<= % x) one-1)\n                            four (some #{x} three)\n                            ]]\n                      (when four four))\n           three (remove nil? two)\n           four (clojure.string/join \",\" three)\n           ]\n           \n       four))", "user": "57227f10e4b0c5bde472c0cd"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(i [s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n    (apply str (interpose \\,\n                          (keep #(let [sq (Math/sqrt %)]\n                                  (when (== (* sq sq) %) %))\n                                (i s))))))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 74, "code": "(fn [input-str]\n  (->>\n (.split input-str \",\")\n (map #(Integer/parseInt %))\n (filter #(let [sq (Math/sqrt %)] (== sq (int sq))))\n (interpose \",\")\n (apply str)))", "user": "56f974c0e4b07572ad1a88b1"}, {"problem": 74, "code": "(fn str-perf [s]\n  (->> s\n     (re-seq #\"\\d+\")\n     (map read-string)\n     (filter #(let [s (Math/round (Math/sqrt %))] (== % (* s s))) ) \n     (clojure.string/join \\,)\n     ))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 74, "code": "(fn fps [x] (let [sqrs (filter (complement #(ratio? (rationalize (Math/sqrt %)))) (map read-string (re-seq #\"\\d+\" x)))]\n               \n               (apply str (butlast (interleave sqrs (repeat (count sqrs) \\,))))))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 74, "code": "(fn [nums]\n  (->> (clojure.string/split nums #\",\")\n       (map read-string)\n       (filter #(let [sqrt (Math/sqrt %)]\n                  (= (* sqrt sqrt) (float %))))\n       (clojure.string/join \",\")))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 74, "code": "(let [perfect-square?\n        (memoize\n         (fn _perfect-square?\n           ([n] (_perfect-square? n 1))\n           ([n r] (if (= n (* r r))\n                    true\n                    (if (> n (* r r))\n                      (recur n (inc r))\n                      false)))))]\n    (fn [s]\n      (->> (clojure.string/split s #\",\")\n           (map read-string)\n           (filter perfect-square?)\n           (clojure.string/join \",\"))))", "user": "53dd37aee4b0d874e779ae28"}, {"problem": 74, "code": "(fn [t] (clojure.string/join \",\" (filter #(let [x (int (Math/sqrt %))] (= % (* x x)))\n             (map read-string (clojure.string/split t #\",\")))))", "user": "576e3258e4b0979f89651574"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(let [q (Math/sqrt %)] (== q (int q))))\n       (interpose \",\")\n       (apply str)))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(msqrt [x] (Math/sqrt x))]\n    (apply str \n           (interpose \",\" (filter #(== (msqrt %) (int (msqrt %)))\n                                      (map read-string (clojure.string/split s #\",\")))))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 74, "code": "(fn\n  [s]\n  (loop [e(map read-string (clojure.string/split s #\",\")) n \"\"]\n    (if (empty? e)\n      (apply str (butlast n))\n      (if (= (Math/sqrt (first e)) (Math/floor (Math/sqrt (first e))))\n        (recur (rest e) (str n(first e) \\,))\n        (recur (rest e) n)))\n    )\n  )", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map read-string (clojure.string/split s #\",\"))\n        largest (apply max nums)\n        perfect-square? (set (take-while #(<= % largest) (map #(* % %) (range))))]\n    (clojure.string/join \",\" (filter perfect-square? nums))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (clojure.string/join \",\" perfect)))", "user": "573652e1e4b0cd1946bd1030"}, {"problem": 74, "code": "(fn [x]\n  (apply str \n         (interpose \",\" (filter \n                         (set (map #(* % %) (range 100))) \n                         (map #(Integer/valueOf %) (clojure.string/split x #\",\"))\n                         )\n                    )\n         )\n  )", "user": "57750460e4b0979f8965160c"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %)) \n       (filter\n        #(let [r (Math/sqrt %)]\n           (= (float %) (* r r))))\n       (clojure.string/join \",\")))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 74, "code": "(fn only-perfects-from-str [s]\n  (let [str->ints (fn [string]\n                    (map #(Integer/parseInt %)\n                         (clojure.string/split string #\",\")))\n        numbers (str->ints s)\n        sqrt (fn [n]\n               (if (> n 0)\n                 (Math/sqrt n)\n                 0))\n        whole-number? (fn [n]\n                        (= 0.0 (rem n 1)))\n        perfect-square? (fn [n] (-> n sqrt whole-number?))\n        perfect-numbers (filter perfect-square? numbers)\n        ]\n    (apply str (interpose \",\" perfect-numbers))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 74, "code": "#(apply str (interpose \",\" (map str (filter (fn [x]\n                                   (if (= (float x) (* (Math/sqrt x) (Math/sqrt x)))\n                                     true\n                                     false))\n                                 (map (fn [x] (Integer/parseInt x))\n                                      (clojure.string/split %\n                                                            #\",\"))))))", "user": "5746cb28e4b009280f9f2b68"}, {"problem": 74, "code": "(fn __ [x]\n\t(let [nums (map #(Integer. %) (re-seq #\"\\d+\" x)\t)\n\t\t  int-root #(Math/round (Math/sqrt %))\n\t\t  sqr #(* % %)\n\t\t  filtered ( filter #(= % (sqr (int-root %))) nums)]\n\t\t(clojure.string/join \",\" filtered)\n\t\t)\n\t)", "user": "575dda55e4b02ea11479938c"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\" (filter #(let [sqrt (Math/sqrt (Integer/parseInt %))] \n                                       (= sqrt (Math/floor sqrt)))\n                                    (clojure.string/split s #\",\"))))", "user": "57780e4fe4b0979f89651657"}, {"problem": 74, "code": "(fn [st]\n    (clojure.string/join\n     \",\"\n     (->> (clojure.string/split st #\",\")\n          (map read-string)\n          (filter #(let [rt (Math/sqrt %)] (= rt (Math/floor rt)))))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 74, "code": "(fn [nums]\n  (->>\n    (clojure.string/split nums #\",\")\n    (filter #(zero? (mod (Math/sqrt (Double/parseDouble %)) 1)))\n    (interpose \",\")\n    (apply str)))", "user": "55cb11e9e4b0e31453f649ff"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n\t(filter #(let [y (Math/sqrt (read-string %))]\n               (== y (int y)))\n            (re-seq #\"[0-9]+\" s))))", "user": "577ab41fe4b0d3393e5deb05"}, {"problem": 74, "code": "(fn [x]\n  (let [numbers (map #(Integer/parseInt %) (re-seq #\"\\d+\" x))\n        perfect-squares (filter #(not (ratio? (rationalize (Math/sqrt %)))) numbers)]\n    (apply str (interpose \",\" (map str perfect-squares)))))", "user": "572a856be4b0f4d77e65123b"}, {"problem": 74, "code": "(fn [words]\n  (let [elem? (fn [x xs] (not (nil? (some #{x} xs)))) \n        nums (->> (clojure.string/split words #\",\")\n                  (map #(Integer. %)))\n        m (apply max nums)\n        p (take-while #(<= % m) (map #(* % %) (drop 2 (range))))\n        pass (filter #(elem? % p) nums)]\n    (clojure.string/join \",\" (map str pass))))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 74, "code": "(fn [v] \n  (->> v\n      (re-seq #\"\\d+\")\n      (map #(Integer/parseInt %))\n       (filter (fn [x]\n                 (let [r (int (Math/sqrt x))]\n                   (= x (* r r)) )))\n       (interpose \",\")\n       (apply str)))", "user": "57934c67e4b0e215f87e8456"}, {"problem": 74, "code": "(fn [v]\n  (->> v\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter (fn [n]\n                 (let [d (int (Math/sqrt n))]\n                 \t(= n (* d d)))))\n       (interpose \",\")\n       (apply str)))", "user": "57822efce4b0d36ec5835e91"}, {"problem": 74, "code": "(fn [numstrings]\n  (let [nums (map read-string (clojure.string/split numstrings #\",\"))\n        squares (map #(Math/sqrt %) nums)\n        pairs (map vector nums squares)]\n    (clojure.string/join \",\" (map first (filter (fn [v]\n                         (= (Math/floor (Math/sqrt (first v))) (last v)))\n                         pairs)))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 74, "code": "#(case (count %) 11 \"4,9\" \"16,25,36\")", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 74, "code": "(fn [s]\n  (let\n   [idt (fn [x] ((pr) x))\n    sqrt (fn [n]\n    (some \n     #(when (= n (* % %)) n)\n     (range 1 n)))]\n   (->> (clojure.string/split s #\",\")\n        (filter not-empty)\n        (map bigint)\n        (filter sqrt)\n        (clojure.string/join \",\")\n       )))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 74, "code": "#(case (count %) 11 \"4,9\" \"16,25,36\")", "user": "57982bace4b039eba2ecb10f"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n    \t(filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n       (map str)\n       (interpose \",\")\n       (apply str)))", "user": "579c8ad1e4b05b1deef9ae0c"}, {"problem": 74, "code": "(fn [nums]\n  (let [nn (map #(Integer. %) (clojure.string/split nums #\",\"))]\n    (let [filt (filter (fn [sq]\n                        (let [s (int (Math/sqrt sq))]\n                            (= (* s s ) sq))         ) nn)]\n      (clojure.string/join  \",\" filt)\n      )))", "user": "579601c8e4b0e215f87e8492"}, {"problem": 74, "code": "(fn [str]\n  (clojure.string/join \",\" (filter #(= 0.0 (rem (Math/sqrt %) 1))\n  (map #(Integer. %) (clojure.string/split str #\",\")))))", "user": "57147cd9e4b07c98581c3abf"}, {"problem": 74, "code": "(fn [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer. %))\n    (filter #(== % (Math/pow (int (Math/sqrt %)) 2)))\n    (map str)\n    (clojure.string/join \",\")))", "user": "57717915e4b0979f896515b3"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n       (clojure.string/join \",\")))", "user": "573118ebe4b0cd1946bd0fbd"}, {"problem": 74, "code": "(fn [s]\n  (let \n    [\n     numbers \n     (map read-string (clojure.string/split s #\",\" ))\n     \n     test-square \n     (fn [x]\n       (let [sqrt (Math/sqrt x)]\n       (= sqrt (Math/floor sqrt))))\n     \n     good-numbers\n     (filter test-square numbers)\n     \n     ]\n    (clojure.string/join \",\" good-numbers)))", "user": "5776558ee4b0979f89651633"}, {"problem": 74, "code": "(fn sol [intstr]\n  (let [integers  (map read-string (clojure.string/split intstr #\",\"))\n        issqrt    (fn [x] (== (* (Math/sqrt x) (Math/sqrt x)) x))\n        issquare  (map issqrt integers)\n        squares   (map (fn [[n b]] n) (filter (fn [[k v]] v) (zipmap integers issquare)))\n        ]\n    (clojure.string/join \",\" (sort squares))\n    ))", "user": "578b140be4b0ebec4cfb7545"}, {"problem": 74, "code": "(fn myf2 [s]\n  (let [square? (fn [n]\n                  (->> (range 1 (inc n))\n                    (map #(int (Math/pow % 2)))\n                    (some #(= % n))))]\n  (->> (.split s \",\")\n       (map #(Integer/parseInt %))\n       (filter square?)\n       (interpose \",\")\n       (apply str)\n       )))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(let [n (Integer/parseInt %)]\n                                  (= n (int (Math/pow (int (Math/sqrt n)) 2))))\n                               (clojure.string/split s #\",\"))))", "user": "576b4e6be4b0a07e8fc1812b"}, {"problem": 74, "code": "(fn[x]\n\n(apply\n str\n(rest\n(interleave\n (repeat (count x) \",\")\n (sort \n  (clojure.set/intersection \n    (set \n      (map \n         #(Integer/parseInt %) \n         (clojure.string/split \n            x  \n            #\",\")\n       )     \n      )  \n     (set \n       (map  #(* % %)  (range 20))\n     )\n   )\n  ) \n )\n )\n\n)\n)", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 74, "code": "#(clojure.string/join \",\" (map str (filter (fn [x] (let [sqrt-n (Math/round (Math/sqrt x))] (= x (* sqrt-n sqrt-n)))) (map read-string (clojure.string/split % #\",\")))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 74, "code": "(fn f [s]\n  (let [comma \\,\n        perfect-square? (fn [n] (->> (range (inc (quot n 2)))\n                                     (map #(* % %))\n                                     (some #(= % n))))]\n    (->> (partition-by #(= % comma) s)\n         (remove #(some #{comma} %))\n         (map #(apply str %))\n         (map read-string)\n         (filter perfect-square?)\n         (map str)\n         (interpose comma)\n         (apply str))))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 74, "code": "(fn [xs]\n  (let [p (fn [x]\n             (let [x (read-string x)\n                   a (int (Math/sqrt x))\n                   a (* a a)]\n               (= a x)))]\n    (clojure.string/join \",\" (filter p (clojure.string/split xs #\",\")))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 74, "code": "(fn [c]\n  (->> c\n       (partition-by #(= % \\,))\n       (map #(clojure.string/join %) )\n       (remove #(= % \",\") )\n       (map #(Integer/parseInt %))\n       (filter (fn [x] (let [n (int (Math/sqrt x))] (= x (* n n)))))\n       (map str)\n       (interpose \",\")\n       (apply str)\n       ))", "user": "504457c0e4b01f6c9a8b2360"}, {"problem": 74, "code": "(fn [s]\n    (let\n      [\n        squares\n        (set\n          (map\n            (fn [n]\n              (* n n)\n            )\n            (range 100)\n          )\n        )\n      ]\n      (clojure.string/join\n        \",\"\n        (map\n          str\n          (filter\n            (fn [n]\n              (get squares n)\n            )\n            (map\n              read-string\n              (clojure.string/split s #\",\")\n            )\n          )\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 74, "code": "(fn [s]\n\n  (->>  (clojure.string/split s #\"\\,\")\n\n        (map read-string)\n\n        (filter (fn [n]\n\n                  (some #(= n (* % %)) (range (inc n)))))\n\n        (clojure.string/join \",\")))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(let [x (Math/sqrt (Integer/parseInt %1)) ] (== x (int x))) (.split s \",\"))))", "user": "558bdcefe4b0277789237633"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join\n    \",\"\n    (filter #(= (* (int (Math/sqrt %)) (int (Math/sqrt %)))  %) (map read-string (clojure.string/split s #\",\")))\n  )\n)", "user": "57873017e4b0ebec4cfb7503"}, {"problem": 74, "code": "(fn [s]\n  (let [ints (map read-string (clojure.string/split s #\",\"))\n      squares (filter (fn [x]\n                        (let [root (Math/sqrt x)]\n                          (== root (Math/round root)))) ints)]\n  (clojure.string/join \",\" squares)))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 74, "code": "(fn[s]\n  (->> (clojure.string/split s #\",\")\n     (map read-string)\n     (filter #(zero? (mod (Math/sqrt %) 1)))\n     (clojure.string/join \",\")))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 74, "code": "(fn [f x]\n  (apply str (butlast (interleave (f x) (repeat \\,)))))\n(fn [x]\n  (filter #(zero? (rem % (Math/sqrt %))) \n    (map #(Long/valueOf %) (re-seq #\"\\d+\" x))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\" \n                       (filter (fn [n] \n                                 (let [sqrt (long (+ 0.5 (Math/sqrt n)))] \n                                   (if (= n (* sqrt sqrt)) \n                                     true \n                                     false)))\n                               (map read-string (clojure.string/split s #\",\")))))", "user": "577202d2e4b0979f896515c0"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (filter #(= (rem (Math/sqrt %) 1) 0.0) (map read-string (clojure.string/split s #\",\"))))))", "user": "57acee37e4b0b8559636fc94"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n         (interpose \",\")\n         (apply str)\n         )\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 74, "code": "(fn\n    [string]\n    (->> (clojure.string/split string #\",\")\n         (map #(read-string %))\n         (filter #(zero? (mod % (Math/sqrt %))))\n         (clojure.string/join \",\")))", "user": "56b306c6e4b0982f16b37e0e"}, {"problem": 74, "code": "(fn [numbers]\n  (->>\n   (clojure.string/split numbers #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(= (Math/floor (Math/sqrt %))\n               (Math/sqrt %)))\n   (interpose \",\")\n   (apply str)\n   ))", "user": "57bfffc7e4b05aa3c4741c8a"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (apply str (interpose \",\" (filter #( = (apply * (repeat 2 (int (Math/sqrt %)))) % ) (map read-string (.split s \",\"))))))", "user": "57b99d48e4b0fbc9809a27f2"}, {"problem": 74, "code": "(fn [input]\n  (let [square? \n    (fn [x]\n      (loop [i 1]\n        (cond\n          (< (* i i) x) (recur (inc i))\n          (= (* i i) x) true\n          (> (* i i) x) false\n        )\n      ))\n    input-sequence (clojure.string/split input #\",\")]\n        (clojure.string/join \",\" (filter square? (map read-string input-sequence)))\n  )\n)", "user": "57c4e8dce4b05aa3c4741cd7"}, {"problem": 74, "code": "(fn string-of-perfect-numbers [string-of-numbers]\n  (let [perfect-square? \n\t\t (fn [n]\n\t\t  (let [sqrt (Math/sqrt n)]\n\t\t\t(not (> sqrt (int sqrt)))))\n\t  perfect-squares (filter perfect-square? (map #(Integer. %) (clojure.string/split string-of-numbers #\",\")))]\n\t (clojure.string/join \",\" (map str perfect-squares))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "579332c2e4b0e215f87e8452"}, {"problem": 74, "code": "(fn [s] \n  (let [mstr (clojure.string/split s #\"[\\s,]+\")] \n    (clojure.string/join \",\" (filter integer? (map (fn [nstr] (let [n (read-string nstr)](when (zero? (mod n (Math/sqrt n))) n))) mstr))))\n  )", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 74, "code": "(fn[s](rand-nth [\"4,9\" \"16,25,36\"]))", "user": "57bd960fe4b05aa3c4741c52"}, {"problem": 74, "code": "(fn psqfilter [strnums]\n  (let [integs (map read-string (clojure.string/split strnums #\",\"))\n        psq? (fn [x] (let [sqrt (int (Math/sqrt x))] (= x (* sqrt sqrt))))]\n    (clojure.string/join \",\" (map str (filter psq? integs)))\n   )\n )", "user": "57cf03c0e4b00451144b04f9"}, {"problem": 74, "code": "(comp #(apply str %) (partial interpose \",\" ) #(map str %) (partial filter #(= (Math/sqrt %) (Math/ceil (Math/sqrt %)) ) ) read-string #(str \"(\" % \")\"))", "user": "57c7a8b5e4b05aa3c4741d09"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        square? (fn [x] (let [r (Math/sqrt x)]\n                          (= r (float (int r)))))\n        squares (filter square? nums)]\n    (apply str (interpose \",\" squares))))", "user": "530e75d5e4b08068f379ecba"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (let [sqrt (Math/round (Math/sqrt n))] (= (* sqrt sqrt) n))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "57c7e7d9e4b05aa3c4741d0f"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (#(read-string (str \"[\" % \"]\")))\n       (filter #(zero? (rem (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 74, "code": "(fn [s]\n  (let [square? (fn [i]\n                  (let [d (Double. i)]\n                  \t(= d (-> d Math/sqrt Math/floor (Math/pow 2)))))\n        ns (clojure.string/split s #\",\")\n        squares (filter square? ns)]\n    (clojure.string/join \",\" squares)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 74, "code": "(fn fps [s]\n  (let [pars (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        ps? (fn [x] \n              (if (= (* (int (Math/sqrt x)) (int (Math/sqrt x))) x)\n                true false)) ]\n    (clojure.string/join \",\" (filter ps? pars))))", "user": "572ac718e4b0f4d77e651242"}, {"problem": 74, "code": "(fn c74\n  [s]\n  (clojure.string/join \",\" (filter (fn\n                                     [num]\n                                     (let [n (Integer. num)\n                                           sqrt (int (Math/sqrt n))]\n                                       (= n (* sqrt sqrt))))\n                                   (clojure.string/split s #\",\"))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 74, "code": "(fn perf-sqrs [s]\n  (let [prs (fn [s]\n              (map read-string (seq (.split s \",\"))))\n        cvr (fn [xs]\n              (apply str (rest (interleave (repeat \",\") xs))))\n        perf? (fn [n]\n                (let [sqr (. Math round (. Math sqrt n))]\n                  (= n (* sqr sqr))))]\n    (cvr (filter perf? (prs s)))))", "user": "57d1d6c8e4b0bd073c202370"}, {"problem": 74, "code": "(fn [numlist] (clojure.string/join \",\" (filter \n                (fn [number] (let [elements (re-seq #\"\\d\" number) \n                                            numbers (map #(Integer/parseInt %) elements)\n                                            rev-numbers (reverse numbers)\n                                            last-number (first rev-numbers)\n                                            pen-last-number (second rev-numbers)\n                                            double-number (not (nil? pen-last-number))\n                                            last-2-numbers (Integer/parseInt (str pen-last-number last-number))\n                                            even-last (even? last-2-numbers)\n                                            div-by-4 (not (= 0(rem last-2-numbers 4)))\n                                            bad-end (contains? #{2 3 7 8} last-number) ]\n                               (if (or bad-end\n                                       (and (not double-number) (contains? #{5 6} last-number))\n                                       (and double-number (= 6 last-number) (even? pen-last-number))\n                                       (and double-number (not (= 6 last-number)) (odd? pen-last-number))\n                                       (and double-number (= 5 last-number) (not (= 2 pen-last-number)))\n                                       (and double-number even-last div-by-4)\n                                       ) false true)\n                               )) (clojure.string/split numlist #\",\"))))", "user": "57c6aa0be4b05aa3c4741cf7"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(let [f (Math/sqrt (read-string %))] (zero? (mod f (int f)))) (.split s \",\"))))", "user": "57a9e274e4b0b8559636fc5d"}, {"problem": 74, "code": "(fn sq  [vals]\n (clojure.string/join \",\" (filter (fn[a] \n                                  (let [val (Integer/parseInt a)\n                                        rt (Math/sqrt val)]\n                                     (= 0.0 (- rt (Math/floor rt)))))\n                                (re-seq #\"\\d+\" vals))))", "user": "4f4aa932e4b0d56e7bb92c14"}, {"problem": 74, "code": "(fn [ns]\n    (->> \n      (.split ns \",\")\n      (map #(Integer/parseInt %))\n      (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n      (clojure.string/join \",\")))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 74, "code": "(fn perfect-sqrt-nums [num-seq]\n  (letfn [(perfect-square? [s]\n            (let [n-sqrt (Math/sqrt (Integer/valueOf s))]\n              (= (double 0) (double (- n-sqrt (Math/floor n-sqrt))))))]\n    (->> (interpose \",\" (filter perfect-square? (re-seq #\"\\d+\" num-seq)))\n         (apply str))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 74, "code": "(fn [numbers]\n  (let [values (map read-string (.split numbers \",\"))\n        sqr? #(zero? (mod (Math/sqrt %) 1))]\n    (clojure.string/join \",\" (filter sqr? values))))", "user": "578fc072e4b0ebec4cfb759a"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= (mod (Math/sqrt %) 1) 0.0) (map read-string (clojure.string/split s #\",\")))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 74, "code": "(fn [n]\n  (letfn [(square? [sq]\n                 (let [r (Math/sqrt sq)]\n                       (== r (Math/floor r))))]\n    (-> n \n        (#(clojure.string/split % #\",\")) \n        (#(map read-string %))\n        (#(filter square? %))\n        (#(apply str (interpose \",\" %))))))", "user": "57c0393be4b05aa3c4741c90"}, {"problem": 74, "code": "(fn [s]\n  (let [coll (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\"\n     (filter (fn [x] \n               (some #(= x %) (map (fn [y] (* y y)) (range x))))\n             coll))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(let [t (Math/sqrt %)] (== (int t) t)))\n       (clojure.string/join \",\")))\n\n;(fn abc [xseq] \n;  \n;      (apply str (interpose \",\" (flatten  \n;        (let  [x (map #(Integer/parseInt %) (clojure.string/split xseq  #\",\"))\n;                  \n;                  y  (apply max x)]\n;             \n;             (for [i (range 1 y)]\n;                 (filter #(= % (* i i)) x)))))))", "user": "56629a7de4b0e91d5f5c5649"}, {"problem": 74, "code": "#(->> \n  (clojure.string/split % #\",\") \n  (map read-string) \n  (filter \n   (fn [v] (let [s (Math/sqrt v)] (= (float (int s)) s))))\n  (interpose \",\")\n  (apply str))", "user": "576a8d02e4b0a07e8fc18117"}, {"problem": 74, "code": "(fn p74\n  [xs]\n  (->>\n       (.split xs \",\")\n       (map read-string)\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 74, "code": "#(-> % (clojure.string/split #\",\") (->> (filter (fn [n] (zero? (mod (Math/sqrt (bigint n)) 1)))) (clojure.string/join \",\")))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 74, "code": "(fn fsq [s]\n  (letfn [(perf-sq [n]\n            (zero? (mod n (Math/sqrt n))))]\n    (clojure.string/join \\,\n      (filter perf-sq\n        (map read-string\n          (clojure.string/split s #\",\"))))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 74, "code": "(fn perfect-squares [coll]\n  (let [squared? (fn [n]\n                   (if-not (empty?\n                              (filter #(if (= n (* % %)) n) (range 1 (inc (quot n 2))))\n                              )true false))]\n    (clojure.string/join \",\" (filter squared? (map read-string (clojure.string/split coll #\",\"))))))", "user": "5785c1d4e4b0ebec4cfb74e1"}, {"problem": 74, "code": "(fn \n  [s]\n  (let [ns (map read-string (clojure.string/split s #\",\"))\n        m (apply max ns)\n        sqs (into #{} (map #(* % %) (range m)))\n        r (filter #(sqs %) ns)]\n    (apply str (interpose \",\" r))))", "user": "56bb652ae4b0f26550335953"}, {"problem": 74, "code": "(fn perf [string]\n   (letfn [(perfect? [x]\n             (let [sqrt_x (bigint (Math/sqrt x))]\n               (= x (* sqrt_x sqrt_x))))]\n     (let [s (seq (.split string \",\"))]\n       (apply str\n              (interpose \",\"\n                         (filter #(perfect? %) (map #(Integer/parseInt %) s)))))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 74, "code": ";;Doh! should have used the Math/sqrt fn on each number\n(fn [s]\n  (let [rs (re-seq #\"\\d+\" s)\n        sqs (map #(* % %) (range))\n        sq? (fn [sn] \n              (let [n (Integer/parseInt sn)]\n                (= n (last (take-while #(<= % n) sqs)))))\n        found-sqs (reduce #(if (sq? %2) (conj %1 %2) %1) [] rs)]\n    (clojure.string/join \",\" found-sqs)))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 74, "code": "#(let [s (map read-string (clojure.string/split % #\",\"))\n       p (fn [x] (if (= 0. (- (Math/sqrt x) (int (Math/sqrt x)))) true false))]\n   (->> s (filter p) (clojure.string/join \",\")))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (letfn [(str-to-ints [s] (into [] (map #(Integer. (re-find  #\"\\d+\" %)) (re-seq #\"\\w+\" s))))\n          (filter-ints [v] (into [] (filter #(= (rem (Math/sqrt %) 1.0) 0.0) v)))\n          (vector-to-str [s] (clojure.string/join \",\" s))]\n    (vector-to-str (filter-ints (str-to-ints s)))\n    )\n  )", "user": "57b9d21fe4b0fbc9809a27f7"}, {"problem": 74, "code": "(fn [s] \n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "57b39fbee4b0fbc9809a2783"}, {"problem": 74, "code": "(fn [input] (clojure.string/join \",\" (filter #(let [i (read-string %) sqrt (Math/sqrt i) floor (Math/floor sqrt)] (< (- sqrt floor) 0.00000001)) (clojure.string/split input #\",\"))))", "user": "576df252e4b0979f8965156f"}, {"problem": 74, "code": "(fn [s]\n  (let [coll (clojure.string/split s #\",\")]\n    (loop [remaining coll ans []]\n      (if (empty? remaining)\n        (apply str (butlast ans))\n        (let [root (Math/floor (Math/sqrt (Integer. (first remaining))))]\n        (if (= (* root root) (Math/floor (Integer. (first remaining))))\n          (recur (rest remaining) (conj ans (str (Integer. (first remaining))) \",\"))\n          (recur (rest remaining) ans)))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 74, "code": "(fn\n  [s]\n  (let [l (->> (re-seq #\"\\d+\" s)\n               (map read-string))\n        m #(int (Math/sqrt %))\n        p #(= % (* (m %) (m %)))]\n    (->> (filter p l)\n         (map str)\n         (interpose \",\")\n         (apply str))))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 74, "code": "(fn [sq] \n  (clojure.string/join \n    \",\" \n    (filter \n     #(loop [n % i 1] \n        (cond \n         (neg? n) false \n         (zero? n) true \n         :else (recur (- n i) (+ 2 i)))) \n     (map read-string (clojure.string/split sq #\",\")))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 74, "code": "#(->> %2\n   (re-seq #\"\\d+\")\n   (filter %)\n   (clojure.string/join \",\"))\n#(let [c (read-string %) s (int (Math/sqrt c))]\n   (= (* s s) c))", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 74, "code": "(fn [s]\n    (let [ints (map #(Integer. %) (clojure.string/split s #\",\"))\n          perfsq (fn [x] (= 0.0 (mod (Math/sqrt x) 1)))]\n      (clojure.string/join \",\" (filter perfsq ints))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [n] (some (fn [i] (= n (* i i))) (range 1 n))) (map (fn [n] (Integer. n)) (clojure.string/split % #\",\"))))", "user": "57f9e0bce4b0d3187e900956"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(squares [i] (cons (* i i) (lazy-seq (squares (inc i)))))]\n    (let [nums (into #{} (map read-string (re-seq #\"\\d+\" s)))\n          some-squares (into #{} (take 10 (squares 0)))\n          intersection (-> (clojure.set/intersection nums some-squares)\n                           seq\n                           sort)]\n      (clojure.string/join \",\" intersection))))", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 74, "code": "(fn filter-perfect-squares [a-string]\n  (let [square? (fn [x]\n                  (let [xx (Math/sqrt x)]\n                    (== (int xx) xx)))]\n  (clojure.string/join  #\",\" (filter square? (map read-string (clojure.string/split a-string #\",\"))))))", "user": "574e84e0e4b02ea114799243"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(< (rem (Math/sqrt %) 1) 0.0001))\n       (clojure.string/join \",\")))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [x]\n          (let [sqrt (int (Math/sqrt x))\n                is-square (= x (* sqrt sqrt))]\n            is-square)) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "57e6997ee4b0bfb2137f5af0"}, {"problem": 74, "code": "(fn only-perfect-squares [s]\n  (let [parsedInts (map #(Integer/parseInt %) (.split s \",\"))\n        perfect-square? (fn [i]\n                          (let [sqr (Math/sqrt i)]\n                            (= (Math/floor sqr) sqr)))]\n    (clojure.string/join \\, (filter perfect-square? parsedInts))))", "user": "57e79d8ee4b0bfb2137f5afe"}, {"problem": 74, "code": "#(apply str (interpose \",\" \n                       (filter (fn [x] (= 0.0 (mod (Math/sqrt x) 1)))\n                               (map (fn [x] (Integer/parseInt x)) (clojure.string/split % #\",\")))))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 74, "code": "#(clojure.string/join \",\"\n\t(filter\n\t\t(fn [x]\n\t\t\t(some\n\t\t\t\t(fn [a] (= (* a a) x))\n\t\t\t\t(range 1 x)))\n\t\t(map read-string (.split % \",\"))))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 74, "code": "(fn filt-sq [s]\n  (letfn [(parse-csstr [sss]\n            (map #(Integer/parseInt %) (clojure.string/split sss #\",\")))\n          (max-of [xs]\n            (reduce (fn [a b] (if (> b a) b a)) xs))]\n    (let [nums (parse-csstr s)\n          nmax (max-of nums)\n          sq-set (set (take-while #(>= nmax %) (map #(* % %) (iterate inc 0))))\n          pfq-nums (filter sq-set nums)\n          pfq-str (clojure.string/join \",\" pfq-nums)]\n      pfq-str)))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [x]\n                          (let [a (int (Math/sqrt x))]\n                            (= x (* a a))))]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer/parseInt %))\n    (filter perfect-square?)\n    (interpose \",\")\n    (apply str))))", "user": "5629dfaae4b00e49c7cb4813"}, {"problem": 74, "code": "(fn [s]\n\t(let [nums (map #(Integer/valueOf %) (clojure.string/split s #\",\"))\n\t\tall-perf-nums (set (map #(* % %) (range 100)))\n\t\tsq-nums (filter all-perf-nums nums)\n\t]\n\t(apply str (interpose \",\" sq-nums))\n\t)\n)", "user": "5405885ee4b0addc1aec6668"}, {"problem": 74, "code": "(fn [numstr] (clojure.string/join \",\" (filter #(if (= (mod (Math/sqrt %) 1) 0.0) %) (map #(Integer. %) (clojure.string/split numstr #\",\")))))", "user": "5686e652e4b0dcc4269f4059"}, {"problem": 74, "code": "(fn [coll] \n    (clojure.string/join \",\" (filter \n        (fn [x] (zero? (mod (Math/sqrt x) 1)))\n        (map read-string (clojure.string/split coll #\"\\W\"))\n    ))\n)", "user": "580c8fcee4b0849f6811b721"}, {"problem": 74, "code": "(fn f74 [strin]\n  (->>\n   (clojure.string/split strin #\",\")\n   (map #(Integer/parseInt %))\n   (map #(do [% (Math/sqrt %)]))\n   (filter #(== (last %) (int (last %))))\n   (map first)\n   (clojure.string/join \",\")))", "user": "57bbc9bde4b05aa3c4741c31"}, {"problem": 74, "code": "(fn [s] \n  (let [perfect-square? (fn [n] (zero? (mod (Math/sqrt n) 1)))]\n    (->> (re-seq #\"\\d+\" s) \n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "5821b018e4b04b46fc4b0f80"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(parse [s] (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))]\n    (apply str (interpose \\,\n                          (keep #(let [sq (Math/sqrt %)]\n                                   (when (== (* sq sq) %) %))\n                                (parse s))))))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 7)))\n        sq-nums (filter all-perf-sq nums)]\n    (apply str (interpose \",\" sq-nums))))", "user": "580d7e53e4b0849f6811b73e"}, {"problem": 74, "code": "(fn [x]\n  (let [y  (map read-string  (vec (.split x \",\")))]\n   (apply str (interpose \",\" (filter #(== (Math/sqrt %) (int (Math/sqrt %)))y)))))", "user": "581a5fdbe4b0e114eb51a002"}, {"problem": 74, "code": "(fn js [in-str]\n  (let [input (map read-string (clojure.string/split in-str #\",\"))\n        squares (map #(* % %) (range 10))\n        output (filter #(some #{%} squares) input)\n        out-str1 (clojure.string/replace (str (apply list output)) \" \" \",\" )\n        out-str2 (clojure.string/replace out-str1 #\"[\\(\\)]\" \"\")]\n    out-str2))", "user": "56069006e4b08b23635d3174"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter \n         #(== 0 (mod (Math/sqrt (read-string %)) 1))\n         (.split s \",\"))))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 74, "code": ";(\n(fn [x]\n  (let [nums (map #(Integer/parseInt %) (.split x \",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        squares (filter psquare? nums)]\n    (apply str (interpose \",\" squares))))\n;\"4,5,6,7,8,9\" )", "user": "573632b7e4b0cd1946bd102f"}, {"problem": 74, "code": "(let [from-comma-nums (fn from-comma-nums\n  [ss]\n  (map #(Integer. %) (clojure.string/split ss #\",\")))\n      to-comma-nums (fn to-comma-nums\n  [ss]\n  (clojure.string/join \",\" ss))\n      squares (fn squares\n                []\n                (let [nums-from (fn nums-from[n] (lazy-seq (cons n (nums-from (+ 1 n)))))]\n                  (map (fn [x] (* x x)) (nums-from 1))))]\n  (let [is-square? (fn is-square?\n                     [x]\n                     (loop [[h & t] (squares)]\n                       (if (= h x)\n                         true\n                         (if (> h x) \n                           false\n                           (recur t)))))]\n    (fn filter-squares\n      [ss]\n      (to-comma-nums(filter is-square? (from-comma-nums ss))))))", "user": "58152157e4b0f478707a0631"}, {"problem": 74, "code": "(fn [str-int-list] (clojure.string/join \",\" (map str (filter (fn perfect-square?\n  [s]\n  (loop [guess 1]\n    (let [next (/ (+ guess (/ s guess)) 2)]\n      (if (and (< -1 (- next guess)) (> 1 (- next guess)))\n        (= s (* (int next) (int next)))\n        (recur next))))) (map read-string (clojure.string/split str-int-list #\",\"))))))", "user": "56449e4de4b0284900eef5f9"}, {"problem": 74, "code": "(fn [input]\n  (->> (clojure.string/split input #\",\")\n       (map #(Integer. %))\n       (filter #(== (Math/sqrt %) (int (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "581e8b86e4b04b46fc4b0f2b"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(let [num (Math/sqrt %)]\n                                     (if (= num (quot % num)) true false)) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "57ee2b3ee4b0bfb2137f5bac"}, {"problem": 74, "code": "(fn [st] (->>\n  st \n  (#(clojure.string/split % #\",\"))\n  (map read-string)\n  (filter  #(= (Math/sqrt %) (double (int (double (Math/sqrt %))))))\n  (map str)\n  (clojure.string/join \",\")\n  )\n)", "user": "5710140fe4b09c608db7042e"}, {"problem": 74, "code": "(fn squares[str] (let [numbers (clojure.string/split str #\",\")]\n                   (clojure.string/join \",\" (filter (fn [x] (let [sqr (Math/sqrt (Integer/parseInt x))] (= (Math/floor sqr) sqr))) numbers))))", "user": "58225587e4b04b46fc4b0f94"}, {"problem": 74, "code": "(fn [x]\n  (reduce str\n              (drop-last\n               (reduce str\n                       (map #(reduce str %)\n                            (map concat\n                                 (map str (filter\n                                           (fn sqrt? [x]\n                                             (if (= (rem (Math/sqrt x) 1) 0.0)\n                                               true\n                                               false))\n                                           (read-string\n                                            (reduce str\n                                                    (concat \"[\" x \"]\"))))) '(\",\" \",\" \",\" \",\" \",\")))))))", "user": "56193c6ee4b053970a773af2"}, {"problem": 74, "code": "(fn [coll] \n  (apply str\n         (interpose \",\" \n                    (map str \n                         (filter \n                           #(= 0.0 (rem % (Math/sqrt %))) \n                           (map \n                             #(Integer/parseInt %) \n                             (clojure.string/split coll #\",\")))))))", "user": "557e8326e4b05c286339e0d7"}, {"problem": 74, "code": "(fn f [list]\n  (->> [list]\n       (map #(clojure.string/split % #\",\")) \n       flatten \n       (map #(Integer. %))\n       (filter #(some #{%} (for [x (range %)] (* x x))))\n       (clojure.string/join \",\")))", "user": "58247423e4b051871117bec5"}, {"problem": 74, "code": "(fn my-perfect-square [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/valueOf %))\n       (filter #(= (double (int (Math/sqrt %)))\n                   (Math/sqrt %)))\n       (clojure.string/join \",\")))", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 74, "code": "(fn [s]                                                                                                                    \n  (clojure.string/join \",\"                                                                                                 \n                       (filter #(== % (Math/pow (Math/floor (Math/sqrt %)) 2))                                             \n                               (map #(Integer/parseInt %)                                                                  \n                                    (re-seq #\"[^,]+\" s)                                                                     \n                                    )                                                                                      \n                               )                                                                                           \n                       )                                                                                                   \n)", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 74, "code": "(fn [s]\n    (->> s\n         (#(clojure.string/split % #\",\"))\n         (map read-string)\n         (filter #(== (Math/sqrt %) (int (Math/sqrt %))))\n         (clojure.string/join \",\"))\n    )", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        squares (->> (range)\n                     (map #(* % %))\n                     (take-while #(<= % (apply max xs)))\n                     set)\n        ys (filter squares xs)]\n    (clojure.string/join #\",\" ys)))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 74, "code": "(fn [x] (->> (clojure.string/split x #\",\")\n              (filter (comp #(= 0.0 %) #(rem % (int %)) #(Math/sqrt (Integer/parseInt %))))\n              (interpose \",\")\n              (apply str)))", "user": "5256c4c1e4b0541d1855ba36"}, {"problem": 74, "code": "(fn filter-perfect-squares [str-nums]\n  (let [nums (set (re-seq #\"\\d+\" str-nums))\n        n (+ 1 (apply max (map #(Integer/parseInt %) nums)))]\n    (apply str (interpose \",\" (filter nums (take n (map #(str (* % %)) (range))))))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join \",\"\n                         (filter #(zero? (mod % (Math/sqrt  %)))\n                                 (map #(Integer/parseInt %)\n                                      (clojure.string/split s #\",\")))))", "user": "57235dc4e4b0c5bde472c0e2"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\"\n                    (filter #(let [n (Math/sqrt %)] (= (Math/floor n) n))\n                            (map #(Integer/parseInt %)\n                                 (re-seq #\"\\d+\" s))))))", "user": "57ed19a3e4b0bfb2137f5b8e"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter #(zero? (mod (Math/sqrt (Double. %)) 1)))\n       (clojure.string/join \",\")))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 74, "code": "(fn [x]\n  (->>\n    (str x)\n    (partition-by (fn [x] (= x \\,)))\n    (take-nth 2)\n    (map (fn [x] (apply str x)))\n    (map (fn [x] (. Integer parseInt x)))\n    (filter\n      (fn issquare\n        ([x] (issquare x 2))\n        ([x chk] (cond\n                   (> (* chk chk) x) false\n                   (== (* chk chk) x) true\n                   :else (issquare x (inc chk))\n                   )\n         )\n        )\n      )\n    (clojure.string/join \",\")\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n              (map #(java.lang.Integer/parseInt %))\n              (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n              (clojure.string/join \",\")))", "user": "5574c172e4b05c286339e059"}, {"problem": 74, "code": "(fn [string]\n  (clojure.string/join \",\"\n    (map str\n      (filter #(= 0 (compare (Math/sqrt %) (int (Math/sqrt %))))\n        (map read-string\n          (clojure.string/split string #\",\"))))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer. %) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter #(= 0.0 (rem % (Math/sqrt %))) nums))))", "user": "5609d328e4b05f002753deee"}, {"problem": 74, "code": ";; rely on sqrt being irrational, thus not representable in double prec\n(fn [x] \n  (clojure.string/join \",\"\n                       (filter #(let [r (Math/sqrt %)] \n                                  (== (* r r) %))\n                               (map #(Integer/parseInt %) \n                                    (clojure.string/split x #\",\")))))\n\n; golf\n;(fn [x]\n;  (clojure.string/join \\,\n;                       (filter #(= 0. (rem (Math/sqrt %) 1))\n;                               (read-string (str \\[ x \\])))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [y] (let [sqrt (int (Math/sqrt y))] (= (* sqrt sqrt) y))) (map #(Integer. %) (clojure.string/split s #\",\")))))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 74, "code": "(fn x[s](let[p (set (map #(* % %) (range 7)))\nnums (map read-string (re-seq #\"\\d+\" s))\nperfects (filter p nums)]\n(apply str (interpose \",\" perfects))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect? (fn [x] (some #(= x (* % %)) (range 1 x)))\n        splited (clojure.string/split s #\",\")]\n    (->> splited\n        (map #(Integer. %))\n        (filter perfect?)\n        (clojure.string/join \",\"))))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 74, "code": "(fn [string]\n  (let [squares-to (fn [n] (take-while #(>= n %) (map #(* % %) (range))))]\n    (->> (clojure.string/split string #\",\")\n         (map #(Integer/parseInt %))\n         (filter #(= % (last (squares-to %))))\n         (clojure.string/join \",\"))))", "user": "57155980e4b07c98581c3ad7"}, {"problem": 74, "code": "(fn [input-str]\n  (letfn [(is-squared? [x]\n                       (loop [i 1]\n                         (cond\n                          (= (* i i) x) true\n                          (> (* i i) x) false\n                          :else (recur (inc i)))))]\n    (clojure.string/join \",\"\n                         (filter is-squared?\n                                 (map #(java.lang.Integer/parseInt %)\n                                      (clojure.string/split input-str #\",\"))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 74, "code": "(fn [string]\n  (let [numbers (map read-string\n                     (re-seq #\"\\d+\" string))\n        max_number (apply max numbers)]\n    (clojure.string/join \",\" \n                         (filter (fn [number]\n                                   (some (fn [base]\n                                           (= (* base base)\n                                              number))\n                                          (range 1 number)))\n                                 numbers))))", "user": "58637f03e4b0f14aab7c881e"}, {"problem": 74, "code": "(fn [s]\n      (let [isSquare? (fn [x] (= x (last (take-while (partial >= x) (map #(* % %) (range))))))]\n         (->> (clojure.string/split s #\",\")\n              (map #(Integer/parseInt %))\n              (filter isSquare?)\n              (clojure.string/join \",\"))))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 74, "code": "(fn [sr] (->> (.split #\",\" sr)\n       (map #(Integer/parseInt %))\n       (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n       (reduce #(str %1 \",\" %2))))", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 74, "code": "(fn [s] (let [v (->> (clojure.string/split s #\",\")\n                     (map read-string))\n              sq (fn [n] (let [s' (int (Math/sqrt n))] (= n (* s' s'))))\n              cand (filter #(sq %) v)]\n          (clojure.string/join \",\" cand)))", "user": "57d0e185e4b0bd073c202360"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\" \n         (filter #(let [n (Integer. %) s (Math/sqrt n)] (= (float n) (* s s)))\n                 (clojure.string/split x #\",\"))))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \n   \",\"\n   (filter\n    #(let [sq (int (Math/sqrt %))]\n       (= (* sq sq) %))\n    (map #(Integer. %) (clojure.string/split s #\",\")))))", "user": "57c94c54e4b05aa3c4741d2c"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (reduce #(str %1 \",\" %2)\n  (filter #( let [sqrt (Math/pow % 0.5) sqrnd (Math/round sqrt)] (== % (* sqrnd sqrnd)) )\n  (map #(Integer/parseInt %)\n  (clojure.string/split s #\",\")\n  ))))", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 74, "code": "(fn fps [s]\n  (clojure.string/join \",\" (filter\n                            #(let [r (Math/sqrt (read-string %))\n                                   s (Math/floor r)]\n                               (zero? (rem r s)))\n                            (clojure.string/split s #\",\"))))", "user": "51456858e4b0e88796073408"}, {"problem": 74, "code": "#(apply str (interpose \",\" (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} (re-seq #\"[0-9]+\" %))))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 74, "code": "(fn f [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (map (fn [s] (Math/sqrt s)))\n       (filter (fn [x] (== (int x) x)))\n       (map (fn [x] (int (* x x))))\n       (reduce (fn [ x y] (clojure.string/join \",\" [x y])))))", "user": "4e6a5728535d8ccf87e9fecf"}, {"problem": 74, "code": "(fn [s]\n  (let [square? #(== (Math/sqrt %) (int (Math/sqrt %)))]\n    (->>\n     (clojure.string/split s #\",\")\n     (map #(Integer/parseInt %))\n     (filter square?)\n     (interpose \",\")\n     (reduce str))))", "user": "52dc7344e4b09f7907dd13cf"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [n] (= (Math/sqrt n) (* 1.0 (int (Math/sqrt n)))))\n                        (map (fn [d] (Integer/parseInt d)) (clojure.string/split s #\",\")))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (->> (clojure.string/split s #\",\")\n                            (map read-string)\n                            (filter (fn [n] (some #(= n %) (map #(* % %) (range 2 n))))))))", "user": "5458c74de4b01be26fd74623"}, {"problem": 74, "code": "(fn [st]\n  (let [perfect? #(let [sq (Math/sqrt %)]\n                          (= (Math/floor sq) sq))\n        nl (map #(Integer/parseInt %) (clojure.string/split st #\",\"))]\n    (clojure.string/join \",\" (filter perfect? nl))))", "user": "563f4c47e4b08d4f616f5ed2"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join \",\" (filter #(= 0.0\n                (rem (Math/sqrt (Integer/parseInt %)) 1))\n            (clojure.string/split s #\",\"))))", "user": "586b6753e4b01531a375e956"}, {"problem": 74, "code": "(fn\n  [s]\n  (let [nlist (map #(Integer. %) (clojure.string/split s #\",\"))\n        max-n (apply max nlist)\n        squares (set (take-while #(<= % max-n) (map #(* (inc %) (inc %)) (range))))\n        filtered-nlist (filter #(contains? squares %) nlist)]\n    (clojure.string/join \",\" filtered-nlist)))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 74, "code": "(fn [a] (clojure.string/join \",\"\n\n          (filter\n\n            (fn [x] (= (int (Math/floor (Math/sqrt x))) (int (Math/ceil (Math/sqrt x)))))\n\n            (map #(Integer. %) (re-seq #\"\\d+\" a)))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "4da8dd6e30acd6ed12482a68"}, {"problem": 74, "code": "(fn [x]\n  (let [sqr #(* % %)\n        perfect #(some #{%} (map sqr (range 1 %)))]\n    (->> (clojure.string/split x #\",\")\n         (map read-string)\n         (map perfect)\n         (remove nil?)\n         (clojure.string/join \",\"))))", "user": "584b0422e4b089d5ab817ef4"}, {"problem": 74, "code": "(fn [s] (let [squares (lazy-seq (map #(* %1 %1) (iterate inc 1)))\n              square? (fn square? [n squares]\n                        (let [r (first squares)]\n                          (if (= n r) true\n                            (if (> r n) false (square? n (rest squares))))))]\n          (clojure.string/join \",\"\n            (filter #(square? % squares)\n              (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "586e47dee4b01531a375e9a9"}, {"problem": 74, "code": "(fn  [s]\n  (clojure.string/join \",\" (let [sqrs (map #(* %1 %1) (range))\n        ss (read-string (str \"#{\" s \"}\"))]\n    (filter ss \n            (take-while #(<= %1 (apply max ss)) \n                        sqrs)))))", "user": "4f3b5219e4b0e243712b1f2a"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [n] (== (Math/sqrt n) (int (Math/sqrt n))))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(#{\"4\" \"9\" \"16\" \"25\" \"36\"} %) (clojure.string/split s #\",\"))))", "user": "587294f0e4b01531a375ea1e"}, {"problem": 74, "code": "(fn [s]\n(->> s ;\"15 16 25 36 37\"\n     (re-seq #\"[\\d\\/\\./e]+\")\n     (map bigdec)\n     (filter #(let [r (Math/sqrt %)] (== r (int r))))\n     (interpose \",\")\n     (apply str)\n  ));   (prn))", "user": "58566b42e4b0f14aab7c86f4"}, {"problem": 74, "code": "(fn [x] (clojure.string/join #\",\" (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "user": "5790f9d7e4b0ebec4cfb75b4"}, {"problem": 74, "code": "(fn [s] (let [nums (clojure.string/split s #\",\")\n              squares (filter #(let [sqrt (Math/sqrt (read-string %))] (== sqrt (int sqrt))) nums)\n              result (clojure.string/join \",\" squares)]\n          result))", "user": "581dad0ae4b04b46fc4b0f17"}, {"problem": 74, "code": "(fn [n]\n  (let [x (map read-string (clojure.string/split n #\",\"))]\n    (clojure.string/join \",\" (filter #(= % (* (int (Math/sqrt %))  (int (Math/sqrt %)) )) x))\n    ))", "user": "582c526ae4b051871117bf88"}, {"problem": 74, "code": "(fn [sn] (let [sseq (clojure.string/split sn #\",\")\n\t               ps (filter (fn [sn] (let [n (Integer/parseInt sn)\n    \t                                    nr (int (Math/sqrt n))]\n        \t                            (= (* nr nr) n))) sseq)]\n           \t(clojure.string/join \",\" ps)))", "user": "51771cb1e4b085adf681d895"}, {"problem": 74, "code": "(fn [coll]\n   (let [numb (map read-string (re-seq #\"[0-9]+\" coll))\n         x (take-while #(<= % (apply max numb)) (map #(* % %) (iterate inc 2)))]\n     (reduce #(str % \",\" %2)\n             (remove nil?\n                      (map (fn [n]\n                             (if (some #(= n %) numb) n)) x)\n                      )\n          )\n     )\n   )", "user": "5857d27de4b0f14aab7c8710"}, {"problem": 74, "code": "(fn [sr] \n  (->> (clojure.string/split sr #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [e] \n                 (let [x (Math/sqrt e)]\n                 (== x (int x))\n                 )\n               )\n        )\n       (clojure.string/join \",\")\n  )\n)", "user": "584d8724e4b0b7285a6f4e3e"}, {"problem": 74, "code": "(fn [x]\n    (let [p (fn [a]\n              (let\n                  [s (Math/sqrt a)\n                   i (* (int s) (int s))]\n                (if (= i a) true false))) ]\n      (clojure.string/join \",\" (filter p (map read-string (clojure.string/split x #\",\"))))))", "user": "5881335ce4b0f1effa3b762e"}, {"problem": 74, "code": "(fn [in](clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map #(Integer. %) (clojure.string/split in #\",\")))))", "user": "587c59d1e4b01531a375eb17"}, {"problem": 74, "code": "(fn [s]\n  (let [sq? (fn [y] (let [x (int (Math/sqrt y))] (= y (* x x))))\n        xs  (map (fn [y] (Integer/parseInt y)) (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (filter sq? xs))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 74, "code": "(fn [b] \n  (clojure.string/join \",\"\n                     (filter #(-> % (Integer/parseInt)\n                                  (Math/sqrt)\n                                  (Math/floor)\n                                  (Math/pow 2)\n                                  (int)\n                                  (str)\n                                  (= %))\n                             (re-seq #\"\\d+\" b))))", "user": "58844d43e4b0f1effa3b7696"}, {"problem": 74, "code": "(letfn [(parse-nums [nstr] \n          (map bigint (re-seq #\"\\d+\" nstr)))\n        (is-perfect-sqr [x]  \n          (zero? (mod (Math/sqrt x) 1.0)))]\n  (fn [nstr]\n    (clojure.string/join \",\" \n      (filter is-perfect-sqr (parse-nums nstr)))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 74, "code": "(fn [s] (->> \n         (clojure.string/split s  #\",\")\n         (map read-string)\n          (filter (fn [x] (let [root-i (int (Math/sqrt x))]\n                           (== (* root-i root-i) x))))\n         (map str)\n         (interpose \",\")\n         (apply str)))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split  s #\",\")\n       (map #(Double/parseDouble %))\n       (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n       (map int)\n       (clojure.string/join \",\")))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 74, "code": "(fn [str]\n  (let [coll (map read-string (clojure.string/split str #\",\"))\n        result (filter #(= 0.0 (rem (Math/sqrt %) (long (Math/sqrt %)))) coll)]\n    (clojure.string/join \",\" result)))", "user": "5896735fe4b00487982d529d"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n            (map #(Integer/parseInt %))\n            (filter (fn [x] (some #{x} (map #(* % %) (range x)))))\n            (clojure.string/join \",\")))", "user": "58949f8de4b00487982d525e"}, {"problem": 74, "code": "(fn [numstr]\n  (clojure.string/join \",\" (let \n    [numlist (map (fn [x] (Integer. x)) (clojure.string/split numstr #\",\")), \n     minnum (apply min numlist), \n     maxnum (apply max numlist),\n     squares (filter (fn [anum] (and (<= anum maxnum) (>= anum minnum))) (map (fn [sqr] (* sqr sqr)) (range maxnum)))]\n    (filter (fn [x] (not (nil? x))) (mapv (fn [a b] (if (= a b) a nil)) (cycle squares) (flatten (map (fn [anum] (replicate (count squares) anum)) numlist))))\n    )\n  )\n )", "user": "58950f29e4b00487982d5270"}, {"problem": 74, "code": "(fn [data]\n  (let [ filter-squares (fn  [items]\n                          (let [sqs (take-while #(>= (reduce max items) %) ((fn rec [i] (lazy-seq (cons (* i i) (rec (inc i))))) 1))\n                                result (filter (fn [i] (some #{i} items)  ) sqs)]\n                            result))\n         split-string  (fn [string] (clojure.string/split string #\",\"))\n         to-integers   (fn [vector-of-strings](map  #(Integer. %) vector-of-strings))\n         to-string     (fn [input] (apply str (interpose \",\"(map #(.toString %) input)) ))]\n    (-> data split-string to-integers filter-squares to-string)))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter #(== (Math/sqrt %) (int (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 74, "code": "(fn\n  [x]\n  (let [numbers (map #(Integer. %)  (clojure.string/split x #\",\"))]\n    (clojure.string/join \",\" (filter #(= 0.0 (mod (Math/sqrt %) 1)) numbers))))", "user": "58a1d00ae4b02bd94d917ec6"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (remove nil? (for [x (clojure.string/split s #\"\\,\")]\n                                                 (if (= \"0\" (last (clojure.string/split (Double/toString (Math/sqrt (Integer/parseInt x)))  #\"\\.\"))) x))))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 74, "code": "(fn [s]\n  (let [numbers (map read-string (clojure.string/split s #\",\"))]\n    (clojure.string/join \",\" (map str (filter (fn [n]\n                                                (loop [k 0]\n                                                  (if (= (* k k) n)\n                                                    true\n                                                    (if (> (* k k) n)\n                                                      false\n                                                      (recur (inc k)))))) numbers)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 74, "code": "(fn string_to_vec\n  [string]\n  (apply str\n        (interpose \",\"\n          (filter #(= 0.0 (rem (Math/sqrt %) (int (Math/sqrt %))))\n              (map  #(Integer/parseInt %)\n                    (clojure.string/split string #\",\"))))))", "user": "58a6d14fe4b01a0c0b232935"}, {"problem": 74, "code": "(fn [string]( letfn [ \n                     (split&del-com [string] ( map read-string (clojure.string/split string #\",\")))\n                     \n                     (sqr? [x] (fn [y] (= x (* y y))))\n                     \n                     (print-list-sqr [l](for [x l y (range 1 (inc (int (/ x 2)))) :when ((sqr? x)y)] x))\n                     ]\n              (clojure.string/join \",\" (print-list-sqr (split&del-com string)))))", "user": "585fea4de4b0f14aab7c87d0"}, {"problem": 74, "code": "(fn find-perfect-squares [mystring]\n (let [mylist (clojure.string/split mystring  #\",\")] \n   (clojure.string/join \",\" (filter #(zero?  (rem (Math/sqrt (Integer/parseInt % 10) ) 1) ) mylist))\n      )\n  )", "user": "58a17511e4b02bd94d917eb4"}, {"problem": 74, "code": "(fn [s]\n  (let [is_square (fn [x]\n                    (let [isqrt_x (int (Math/sqrt x))]\n                      (= x (* isqrt_x isqrt_x))))\n        values (filter is_square\n                       (map #(Integer/parseInt %) (.split s \",\")))]\n    (clojure.string/join \",\" values)))", "user": "4f7ab8c7e4b06e829148e19c"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map read-string (re-seq #\"\\d+\" s))\n        powers (map #(* % %) (iterate inc 1))]\n    (clojure.string/join \",\"\n                         (filter (fn [n]\n                                   (some #(= % n)\n                                         (take-while #(<= % n) powers))) nums))\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 74, "code": "(fn perfect-squares [numbas]\n  (let [numba-vec (vec (sort (map #(Integer/parseInt %)\n                                (clojure.string/split numbas #\",\"))))\n        square-set (set (take-while #(<= % (last numba-vec))\n                                    (map #(* % %) (range))))]\n\n    (clojure.string/join \",\" (filter #(square-set %) numba-vec))))", "user": "580d2788e4b0849f6811b730"}, {"problem": 74, "code": "(fn [text]\n  (letfn [(perfect-sqrt [n]\n            (loop [i 2]\n              (cond (> i n)       false\n                    (= (* i i) n) true\n                    :else\n                    (recur (inc i)))))]\n  (->> (clojure.string/split text #\",\")\n       (map #(Integer/parseInt %))\n       (filter perfect-sqrt)\n       (clojure.string/join \",\"))))", "user": "5895477fe4b00487982d527c"}, {"problem": 74, "code": "(fn [text] (apply str (interpose \",\" (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))) (map read-string (re-seq #\"\\d+\" text))))))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 74, "code": "(fn squares [str]\n  (let [nums (map #(Integer. %) (clojure.string/split str #\",\"))\n        sqs (map #(* % %) (range))\n        isSqr (fn [num] (some #(= % num) (take-while #(<= % num) sqs)))]\n    (clojure.string/join \",\" (filter isSqr nums))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 74, "code": "(fn at [numstr] (let [numsstr (clojure.string/split numstr #\",\")\n                      nums (map #(Integer/parseInt %) numsstr)\n                      ps (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) nums)\n                      output (clojure.string/join \",\" ps)]\n                  output))", "user": "57db2369e4b0bd073c20241f"}, {"problem": 74, "code": "(fn [xs]\n  (letfn [(perfect-square [n] (= (Math/pow (int (Math/sqrt n)) 2) (double n)))\n          (parse-int [s] (Integer/parseInt (re-find #\"\\A-?\\d+\" s)))\n          (get-values [xs] (map parse-int (clojure.string/split xs #\",\")))\n          (format-values [values] (clojure.string/join \",\" values))]\n    (->> xs\n         get-values\n         (filter perfect-square)\n         format-values)))", "user": "56375106e4b0bfe05bf117d3"}, {"problem": 74, "code": "(fn [string]\n  (let [coll (set (map #(Integer/parseInt %) (clojure.string/split string #\",\")))]\n    (clojure.string/join\n      \",\"\n      (map\n        str\n        (filter\n          #(contains? coll %)\n          (take-while (partial >= (last (sort coll))) (map #(* % %) (range))))))))", "user": "56cad309e4b0ea9b8538f720"}, {"problem": 74, "code": "(fn [x] \n  (->> (clojure.string/split x #\",\")\n     (map #(Integer/parseInt %))\n     (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)))\n     (clojure.string/join \",\")))", "user": "50385746e4b0803468ea2c6d"}, {"problem": 74, "code": ";;no clojure.edn support :(\n(fn square-string\n  [s]\n  (->> (clojure.string/split s #\",\")\n     (map  (comp #(list (float %) (Math/sqrt %)) read-string ))\n     (filter #(= 0.0 (- (first %) (reduce * (repeat 2 (second %) )))))\n     (map (comp int first))\n     (clojure.string/join \",\")))", "user": "58988cbbe4b00487982d52d7"}, {"problem": 74, "code": "(fn\n     [x]\n     (let [a (map #(Integer/parseInt %) (clojure.string/split x #\",\"))]\n\n       (clojure.string/join \",\" (map str (filter number?\n                                                 (map\n                                                   (fn\n                                                     [y]\n                                                     (some #(and (= y %) %) (map #(* % %) (range 1 y)))\n                                                     ) a)\n                                                 )))\n\n       )\n     )", "user": "58a44a14e4b01a0c0b2328f2"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map read-string (clojure.string/split s #\",\"))\n        is-int? #(= 0.0 (- % (int %)))\n        fltr #(is-int? (Math/sqrt %))]\n    (clojure.string/join \\, (filter fltr nums))))", "user": "58923efce4b00487982d521c"}, {"problem": 74, "code": "(fn [csv] (->> (clojure.string/split csv #\",\")\n               (map #(Integer/parseInt %))\n               (filter (fn [n] (-> n Math/sqrt int (Math/pow 2) (== n))))\n               (clojure.string/join \",\")))", "user": "57b7de74e4b0fbc9809a27d4"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map (fn [x] (Integer. x)))\n       (filter (fn [x] (= 0.0 (rem (Math/sqrt x) 1))))\n       (clojure.string/join \",\")))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "567d75ebe4b05957ce8c61c9"}, {"problem": 74, "code": ";(fn [str] (let [f-from #(map read-string ((partial re-seq #\"\\d+\") %))\n;                fc (fn [n] (some #(= (* % %) n) (range 2 n)))] \n;            (#(clojure.string/join \",\" %) (filter fc (f-from str))) ))\n\n(fn [str] (->> str (#(map read-string ((partial re-seq #\"\\d+\") %)))\n               (filter (fn [n] (some #(= (* % %) n) (range 2 n))))\n               (#(clojure.string/join \",\" %)) ))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 74, "code": "(fn [s] \n   (clojure.string/join #\",\" \n                        (filter (fn [e] (let [r (Math/sqrt e) i (int r)]\n                                                (= e (* i i))))\n                                      (map #(Integer/parseInt %1)\n                                           (clojure.string/split s #\",\")))))", "user": "58a9e872e4b01a0c0b232973"}, {"problem": 74, "code": "(fn [str]\n    (let [strnums (clojure.string/split str #\",\")\n          nums (map #(Integer. %) strnums)\n          prefect-squares? (fn [n1 n2] (= (* n1 n1) n2))\n          get-perfect-squares-num (fn [num] (some #(prefect-squares? % num) (range 1 (+ num 1))))]\n      (->> nums\n           (filter get-perfect-squares-num)\n           (clojure.string/join \",\"))))", "user": "58bbcbc8e4b0888cdc949d00"}, {"problem": 74, "code": "(fn [s]\n  (->> \n   (.split s \",\")\n   (filter \n    (fn[a] \n      (let [n (Integer/parseInt a)] \n        (= n \n           (int (Math/pow \n            \t(int (Math/sqrt n)) \n            \t2))))))  \n   (clojure.string/join \",\")))", "user": "4f1ef6a0535d64f60314649b"}, {"problem": 74, "code": "(fn [s]\n  (->> s \n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter #(let [sq (int(Math/sqrt %))] (= (* sq sq) %)))\n       (clojure.string/join \",\")\n  )\n)", "user": "57887de2e4b0ebec4cfb751c"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (map int (filter\n   (fn [n]\n     (=\n      0.0\n      (mod (Math/sqrt n) 1)))\n  (map\n   (fn [st-num]\n     (. Double parseDouble st-num))\n   (clojure.string/split\n    s\n    #\",\"))))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 74, "code": "(fn [xs] (clojure.string/join #\",\" (filter #(zero? (rem (Math/sqrt %) 1.)) (map read-string (clojure.string/split xs #\",\")))))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n       (map #(Integer/parseInt %))\n       (filter #(zero? (mod (java.lang.Math/sqrt %) 1)))\n       (interpose \\,)\n       (apply str)\n       ))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 74, "code": "(fn [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer/parseInt %))\n    (filter #(zero? (rem (Math/sqrt %) 1)))\n    (clojure.string/join \",\")\n    ))", "user": "586bc870e4b01531a375e964"}, {"problem": 74, "code": "(fn xx [sss]\n  (letfn [(perfect? [n]\n                    (let [sq (Math/sqrt n)]\n                      (= (float n) (* sq sq))))]\n    (let [numberOnly (map read-string (re-seq #\"\\d+,*\" sss))]\n      (apply str (interpose \",\" (map str (filter perfect? numberOnly)))))))", "user": "57b35ecbe4b0fbc9809a277e"}, {"problem": 74, "code": "(fn [nums]\n  (->>\n   \t(clojure.string/split nums #\",\")\n   \t(filter (fn [x] (let [x (Integer/parseInt x)] (== x (* (Math/sqrt x) (Math/sqrt x))))))\n  \t(clojure.string/join \",\")))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 74, "code": "#(->> (str \"[\" % \"]\")\n      (read-string)\n      (filter (fn [v] (let [p (int (Math/sqrt v))] (= v (* p p)))))\n      (clojure.string/join \",\"))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 74, "code": "(fn [x]\n  (->> x\n       (re-seq #\"\\d+\")\n       (map #(read-string %))\n       (filter (fn [x]\n                 (let [y (int (Math/sqrt x))]\n                   (= (* y y) x))))\n       (clojure.string/join \",\")))", "user": "58b989dbe4b0888cdc949ccd"}, {"problem": 74, "code": "(fn perfect-squares [str]\n  (->> str\n    (re-seq #\"\\d+\")\n    (map #(when (== 0.0 (mod (Integer. %) (Math/sqrt (Integer. %)))) %))\n    (remove nil?)\n    (clojure.string/join \",\")))", "user": "587a3babe4b01531a375eae2"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(== % (* (Math/sqrt %) (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 74, "code": "(fn [x](apply str (rest(apply str (map #(str \",\" %)(filter #(= (- (Math/sqrt %) (int (Math/sqrt %))) 0.0)(map read-string (clojure.string/split x #\",\"))))))))", "user": "53ae0c50e4b047364c044471"}, {"problem": 74, "code": "(fn filter-p\n  [str]\n   (clojure.string/join \",\" (filter #(= (mod (Math/sqrt (Integer. %)) 1) 0.0) (clojure.string/split str #\",\"))))", "user": "58de563fe4b0a4d5acaab6e3"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n        (let [numbers (map #(. Integer parseInt %)\n                           (clojure.string/split s #\",\"))\n              square-numbers (->> (apply max numbers)\n                                  (Math/sqrt)\n                                  (Math/ceil)\n                                  (int)\n                                  (inc)\n                                  (range 1)\n                                  (map #(* % %))\n                                  (frequencies))]\n          (println square-numbers)\n          (clojure.string/join \n           \",\"\n           (filter #(square-numbers %) numbers))))", "user": "540c54a7e4b0addc1aec6700"}, {"problem": 74, "code": "(fn perfect-squares [s]\n        (apply str\n               (interpose \",\"\n                          (filter \n                            #(= % (int (Math/pow (int (Math/sqrt %)) 2))) \n                            (map #(Integer. %) (re-seq #\"\\d+\" s))))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 74, "code": "(fn sqr [s] \n    (->> (map read-string (clojure.string/split s #\",\"))\n         (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt (int %))))))\n         (clojure.string/join \",\")))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [x] (#(zero? (- % (Math/round %)))   (Math/sqrt (Integer. x))))\n                     (re-seq #\"\\d+\" s))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 74, "code": "(fn perfect-squares [string]\n  (letfn [(perfect-square? [n] \n            (let [sqrt (Math/sqrt n)]\n              (= (Math/floor sqrt) sqrt)))\n          (parse-int [s] \n            (Integer/parseInt s))]\n    (let [nums (map parse-int (clojure.string/split string #\",\"))\n          perfect-squares (filter perfect-square? nums)]\n      (apply str (interpose \",\" perfect-squares)))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(let [r (Math/sqrt %)]\n                  (== r (int r))))\n       (clojure.string/join #\",\")))", "user": "58e58ae9e4b056aecfd47c9a"}, {"problem": 74, "code": "(fn [x] (apply str(interpose \",\" (sort (clojure.set/intersection (set (map * (range 10) (range 10)))\n(set (map #(Integer. %)(clojure.string/split x #\",\"))))))))", "user": "58dd21a9e4b0a4d5acaab6b3"}, {"problem": 74, "code": "(fn\n  [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    (fn [x] (let [r (Math/sqrt x)] (= r (Math/floor r))))\n    (map\n     #(Integer/parseInt %)\n     (clojure.string/split s #\",\")))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 74, "code": "(fn [s]\n  (let [squares (set (map #(* % %) (range 1 10)))\n        numbers (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n    (apply str (interpose \",\" (filter squares numbers)))))", "user": "58ef4db9e4b056aecfd47dc6"}, {"problem": 74, "code": "(fn [s]\n      (->> (clojure.string/split s #\",\")\n           (map #(Integer/parseInt %))\n           (filter #(= (-> %\n                           (Math/pow 1/2)\n                           int\n                           (Math/pow 2)\n                           int)\n                       %))\n           (clojure.string/join \",\")))", "user": "58c4b11ae4b021aa9917ed2c"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(let [str (Integer/parseInt %)] (= (- (Math/sqrt str) (int (Math/sqrt str))) 0.0) )\n    (clojure.string/split s #\",\")\n    )\n   )\n  )", "user": "570e43d8e4b0b0fb43fd06eb"}, {"problem": 74, "code": "(fn [input]\n  (clojure.string/join \",\"                       \n\t(filter\n    \t#(= (java.lang.Math/ceil\n        \t\t(java.lang.Math/sqrt (Integer. %)))\n\t\t\t(java.lang.Math/sqrt (Integer. %)))\n\t\t(clojure.string/split input #\",\"))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 74, "code": "(letfn [(perfect-square? [n]\n            (let [r (int (Math/sqrt n))]\n              (= n (* r r))))]\n    (fn [s]\n      (->> s\n           (re-seq #\"\\d+\")\n           (map read-string)\n           (filter perfect-square?)\n           (clojure.string/join \",\"))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 74, "code": "(fn [nums]\n   (let [pnums (map #(Integer/parseInt %)\n                    (clojure.string/split nums #\",\"))]\n     (->>\n      (filter #(= % \n                  (* (int (Math/sqrt %)) \n                     (int (Math/sqrt %)))) \n              pnums) \n      (map str)\n      (interpose \",\")\n      (apply str))))", "user": "56f881e0e4b08e7d20b96839"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 74, "code": "(fn [s] \n   (let [pSquares (take 10 (map #(str (* % %)) (iterate inc 1)))\n         in (clojure.string/split s #\",\")]\n     (clojure.string/join \",\" (filter (fn [i] (some #(= % i) pSquares)) in))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 74, "code": "(fn filter-p-sqr [a-str]\n  (clojure.string/join \",\" (filter (fn [x]\n                                     (let [upper-bound (int (inc (Math/ceil (Math/sqrt x))))]\n                (some (fn [y] (= x (* y y))) `(~(dec upper-bound) ~(- upper-bound 2)))))\n               (map #(Integer/valueOf %) (re-seq #\"\\d+\" a-str)))))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 74, "code": "(fn [num-str] (clojure.string/join \",\" (filter #(let [sq (Math/sqrt %) rd (dec sq) ru (inc sq)] (= % (apply * (repeat 2 (first (drop-while (fn [n] (< n sq)) (range ru))))))) (map (fn [c] (-> c read-string)) (clojure.string/split num-str #\",\")))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 74, "code": "(fn filterSquares [xs]\n         (let [numbers \n               (map read-string (clojure.string/split xs #\",\"))]\n           (clojure.string/join \",\"\n                                (filter #(= (long %)\n                                            (* (long (Math/sqrt %))\n                                               (long (Math/sqrt %))))\n                                        numbers))))", "user": "58c4492be4b021aa9917ed27"}, {"problem": 74, "code": "(fn [s] (->>\n  (re-seq #\"\\d+\" s)\n  (map read-string)\n  (filter (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x)))))\n  (map str)\n  (clojure.string/join \",\")))", "user": "5901158de4b0438e51c2d039"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\") \n             (map #(Integer/parseInt %)) \n             (filter (fn [n] (some #{n} (take n (map #(* % %) (iterate inc 1))))))\n             (map str) \n             (clojure.string/join \",\")))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (reduce\n    (fn [result x] (if (= (mod (java.lang.Math/sqrt x) 1) 0.0) (conj result x) result))\n    []\n    (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "user": "5801eed1e4b0a837a8b30c63"}, {"problem": 74, "code": "(fn  [str]\n  (->> (.split  str \",\")\n       (map #(Integer/parseInt %))\n       (filter #{4 9 16 25 36})\n       (clojure.string/join \",\")\n       ))", "user": "5823d3e6e4b051871117beb8"}, {"problem": 74, "code": "#(->>\n  (clojure.string/split % #\",\")\n  (filter (fn [x]\n            (let [num-of-x (Integer. (re-find #\"\\d+\" x))\n                  isPerfectNum (fn [n]\n                                 (let [sq (int (Math/sqrt n))]\n                                   (= (* sq sq) n)))]\n              (isPerfectNum num-of-x))))\n  (clojure.string/join \",\")\n  )", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 74, "code": "(fn filter-perf-sq\n  [input-str]\n  (->> (re-seq #\"\\d+\" input-str)\n       (map #(Integer/parseInt %))\n       (filter #(== (Math/pow (int (Math/sqrt %)) 2) %))\n       (clojure.string/join \",\")))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 74, "code": "(fn [x] \n  (apply str\n    (interpose \\,\n      (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))) \n      (map #(Integer/parseInt %)\n        (re-seq #\"[0-9]+\" x))))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n   \",\"\n   (filter #(let [squared (java.lang.Math/sqrt %)]\n              (= squared (double (int squared))))\n           (map (comp read-string str) (clojure.string/split s #\",\")))))", "user": "55f5b8d6e4b06e875b46ce8d"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (#(clojure.string/split % #\",\"))\n       (map #(Integer. %))\n       (filter #(== % (* (Math/sqrt %) (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "59156f0be4b0163c97b36f3d"}, {"problem": 74, "code": "(fn squares\n\t[s]\n\t(->> s\n\t\t(#(clojure.string/split % #\",\"))\n\t\t(map #(Integer. %))\n\t\t(filter\n\t\t\t(fn [x]\n\t\t\t\t(let [rt (Math/floor (Math/sqrt x))]\n\t\t\t\t\t(== x (* rt rt)))))\n\t\t(clojure.string/join \",\")))", "user": "58fb7d7ae4b0438e51c2cf7a"}, {"problem": 74, "code": "(fn [com-sep-nums]\n  (letfn [(sq-num? [n] (seq (filter #(= n (* % %)) (range (inc n)))))\n          (spl-by-comma [csn]\n                        (let [comma (.indexOf csn \",\")]\n                          (if (pos? comma)\n                            (cons (Integer. (subs csn 0 comma)) (spl-by-comma (subs csn (inc comma))))\n                            [(Integer. csn)])))]\n    (let [nums (map #(Integer. %) (spl-by-comma com-sep-nums))]\n      (apply str (interpose \",\" (filter sq-num? nums))))))", "user": "58ffac9de4b0438e51c2cffd"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter #(= % (int (Math/pow (int (Math/floor (Math/sqrt %))) 2))))\n         (map str)\n         (clojure.string/join \",\")\n         ))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 74, "code": "(fn [x] (reduce #(str %1 \",\" %2) \n                 (filter\n                   #(some (fn [y] (= y (/ (read-string %1) y))) (range 1 (inc (/ (read-string %1) 2))))\n                   (clojure.string/split x #\",\"))))", "user": "5910a43de4b0163c97b36ebf"}, {"problem": 74, "code": "(fn [x]\n\n(clojure.string/join \",\" (filter (fn [y] (if (= 3 (count (into '() (str (Math/sqrt (Integer. y) ) )  ) ) )  true false )) (clojure.string/split x #\",\") )) \n  )", "user": "59228b00e4b026ae38521281"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter\n         (fn [x]\n           (loop [next 1\n                  tested x]\n             (cond\n               (zero? tested)  true\n               (> next tested) false\n               :else (recur (+ next 2) (- tested next))))))\n        (clojure.string/join \",\")))", "user": "566fa059e4b0a866af6896ea"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [n]\n            (= 0.0 (rem (Math/sqrt n) 1)))]\n    (->> (clojure.string/split s #\",\")\n         (map bigint)\n         (filter perfect-square?)\n         (clojure.string/join \\,))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 74, "code": "(fn [x]\n  (let [\n        vals (map (fn [y] (Integer/parseInt y)) (clojure.string/split x #\",\"))\n        filtered (filter (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x)) )) vals)\n        res (clojure.string/join \",\" filtered)\n        ]\n    res))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [n]\n                           (loop [coll (map #(* %1 %1) (drop 2 (range)))]\n                             (cond\n                              (= n (first coll)) true\n                              (< n (first coll)) false\n                              :else (recur (rest coll)))))]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter perfect-square?)\n         (map #(format \"%d\" %1))\n         (clojure.string/join \",\"))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 74, "code": "(fn [x] \n  (clojure.string/join \n   \",\" \n   (filter \n    (fn [z] \n      (= 0.0 \n         (- (Math/sqrt z) \n            (int (Math/sqrt z))\n         )\n      )\n    ) (map read-string (clojure.string/split x #\",\")))))", "user": "592ac550e4b072a2710fcf27"}, {"problem": 74, "code": "(fn [l]\n  (clojure.string/join \",\"\n                       (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))\n                               (map #(Integer/parseInt %) (clojure.string/split l #\",\")))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 74, "code": "(fn [x] (->> x\n  (re-seq #\"\\d+\") \n  (map #(Integer. %))\n  (filter #(= (double %) \n    (java.lang.Math/pow \n      (int (java.lang.Math/sqrt %)) 2)))\n  (reduce #(str %1 (if (not (empty? %1)) \",\") %2) \"\")))", "user": "5933b736e4b072a2710fd05d"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(zero? (- (Math/floor (Math/sqrt %)) (Math/sqrt %)  )))\n       (interpose \",\")\n       (apply str)))", "user": "58db362be4b0a4d5acaab675"}, {"problem": 74, "code": "(fn [stringg] \n  (let[num-list (clojure.string/split stringg #\",\")]\n    (apply \n      str \n      (interpose \",\" \n                 (filter \n                   (fn [x] \n                     (== \n                       (int (Math/sqrt (Integer/parseInt x))) \n                       (Math/sqrt (Integer/parseInt x)))) \n                  num-list)))))", "user": "59301509e4b072a2710fcfd6"}, {"problem": 74, "code": "(fn [s]\n  (let [splitted (clojure.string/split s #\",\")]\n    (->> splitted\n         (map #(Integer/valueOf %))\n         (filter #(zero? (mod % (Math/sqrt %))))\n         (clojure.string/join \",\"))))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "59368efbe4b02506e01a297d"}, {"problem": 74, "code": "(fn [s]\n  (loop [nums (clojure.string/split s #\",\") ans '()]\n    (if (empty? nums)\n      (clojure.string/join \",\" (reverse ans))\n      (if (= 0.0 (mod (Math/sqrt (read-string (first nums))) 1))\n        (recur (rest nums) (conj ans (first nums)))\n        (recur (rest nums) ans)))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 74, "code": "(fn [s]\n  (loop [lst (clojure.string/split s #\",\") ans '()]\n    (if (empty? lst)\n      (clojure.string/join \",\" (reverse ans))\n      (if (= 0.0 (mod (Math/sqrt (read-string (first lst))) 1))\n        (recur (rest lst) (conj ans (first lst)))\n        (recur (rest lst) ans)))))", "user": "59368ccae4b02506e01a2979"}, {"problem": 74, "code": "(fn [nums1]\n  (loop [nums (re-seq #\"\\d+\" nums1) final \"\"]\n    (if (empty? nums)\n      (clojure.string/join \"\" (drop-last final))\n      (if ((fn [num1]\n          (loop [i 1]\n            (if (= i (- num1 1))\n              false\n              (if (= num1 (* i i))\n                true\n                (recur (inc i )))))) (read-string (first nums)))\n        (recur (rest nums) (str final (first nums) \",\" ))\n        (recur (rest nums) final)))))", "user": "59369515e4b02506e01a297e"}, {"problem": 74, "code": "; would benefit from an accumulator\n(fn perfect-squares[s]\n  (let [perfect-squares-inner\n        (fn perfect-squares-inner\n          [s]\n          (if (empty? s)\n            (list)\n            (if (== (int (Math/sqrt (first s))) (Math/sqrt (first s)))\n              (cons (first s) (perfect-squares-inner (rest s)))\n              (perfect-squares-inner (rest s)))))]\n    (clojure.string/join \",\" (map str (perfect-squares-inner (map read-string (clojure.string/split s #\",\")))))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 74, "code": "(fn [s] (let [coll (clojure.string/split s #\",\")\n               nums (map #(Integer/parseInt %) coll)]\n           (->> (clojure.set/intersection\n                 (set (map * (range (last nums)) (range (last nums))))\n                 (set nums))\n                (into [])\n                sort\n                (clojure.string/join \",\"))))", "user": "5935b010e4b04f87174def55"}, {"problem": 74, "code": "(fn [s]\n    (let [coll (map #(Integer. %) (re-seq #\"\\d+\" s))\n           pn (map #(* % %) (range))\n           ss (->> coll\n                (filter #((set (take % pn)) %) )\n                (map #(str \\, %))\n                (apply str))]\n          (subs ss 1)))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 74, "code": "(fn [x]\n  (let [nums (doall (map #(Integer. %) (clojure.string/split x #\",\")))\n        m (reduce max nums)\n        squares (loop [i 2\n                       c [1]]\n                  (if (> (last c) m)\n                    c\n                    (recur (inc i) (conj c (* i i)))))]\n      (clojure.string/join \",\" (filter #(.contains squares %1) nums))))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 74, "code": ";;TDD - Coded to the tests\n#(->> (re-seq #\"4|9|16|25|36\" %)\n      (clojure.string/join \",\"))", "user": "585d9558e4b0f14aab7c879c"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (filter #(= (float (int (Math/sqrt %))) (Math/sqrt %))\n      (map read-string\n       (clojure.string/split s #\",\")))))", "user": "55c66ffee4b0e31453f649c2"}, {"problem": 74, "code": "(fn\n  [s]\n  (let [l (map #(Integer/valueOf %) (clojure.string/split s #\",\"))]\n    (clojure.string/join\n     \",\"\n     (filter\n      (fn [n]\n        (== n\n            (#(* % %)\n             (Math/sqrt n))))\n      l))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5938bae2e4b02506e01a29ea"}, {"problem": 74, "code": "(fn [ss] \n  (->> ss \n       (#(clojure.string/split % #\",\"))\n       (map #(Integer/parseInt %))\n       (filter #(== (Math/sqrt %) (int (Math/sqrt %))))\n       (clojure.string/join #\",\")))", "user": "5797d3d2e4b039eba2ecb106"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (read-string (str \"[\" s \"]\"))\n        join (fn [nums]\n               (clojure.string/join \",\" (re-seq #\"\\d+\" (str nums)))\n             )\n      ]\n    (join (vec (filter\n      (fn [x]\n        (let [root (int (Math/sqrt x))]\n          (= x (* root root))\n        )\n      )\n      nums\n    )))\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 74, "code": ";;#(filter (fn [x] (if (= (Math/sqrt x) (/ x (Math/sqrt x))) true false )) %) \n\n\n(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "5950f0bfe4b066ee0a44ae9f"}, {"problem": 74, "code": "(fn [s]\n  (let [split clojure.string/split\n        nums-s (split s #\",\")\n        nums (map #(Integer/parseInt %) nums-s)\n        psq? (fn [n]\n               (= (mod (Math/sqrt n) 1) 0.0))\n        psqs (filter psq? nums)\n        join clojure.string/join\n        res (join \",\" psqs)]\n    res))", "user": "592334c7e4b0a390037439ee"}, {"problem": 74, "code": "(fn squares [s]\n  (let [squlist (set (map #(* % %) (range 10)))]\n    (->> s (re-seq #\"[0-9]+\") (map read-string) (filter (partial contains? squlist)) (clojure.string/join \",\"))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter #(zero? (mod (Math/sqrt %) 1)))\n         (map str)\n         (clojure.string/join \",\")))", "user": "54965534e4b0b312c081ff65"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter \n        (fn [x] (= 0.0 (- (Math/sqrt x) (Math/floor (Math/sqrt x))))) \n        (map (fn [y] (Integer/parseInt y))\n           (clojure.string/split % #\",\"))\n        ))", "user": "592518cde4b072a2710fce66"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter \n        (fn [x] (= 0.0 (- (Math/sqrt x) (Math/floor (Math/sqrt x))))) \n        (map (fn [y] (Integer/parseInt y))\n           (clojure.string/split % #\",\"))\n        ))", "user": "592518e8e4b072a2710fce67"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 74, "code": "(fn perf-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "59251947e4b072a2710fce69"}, {"problem": 74, "code": "(fn, [str]\n  (let [s (re-seq #\"\\d+\" str)\n        ss (map #(Integer. %) s)\n        f (filter #(some #{%} (map (fn [x] (* x x)) (range %))) ss)]\n       (clojure.string/join \",\" f)))", "user": "595914e0e4b066ee0a44af99"}, {"problem": 74, "code": "(fn [s]\n    (let [candidates (map #(Long/parseLong %)\n                          (map str\n                               (filter (complement empty?)\n                                       (.split s \",\"))))\n          true-root? #(== (int (Math/sqrt %)) (Math/sqrt %))]\n\n      (apply str (interpose \",\" (map int (filter true-root? candidates))))))", "user": "595bbab7e4b066ee0a44afe0"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(let [sqrt (int (Math/sqrt %))] \n                  (= % (* sqrt sqrt))))\n       (clojure.string/join \",\")))", "user": "5956c6dae4b066ee0a44af61"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Long/parseLong %))\n       (filter #(= % (long (Math/pow (long (Math/sqrt %)) 2))))\n       (clojure.string/join \",\")))", "user": "594880ade4b07ddc2dafadc2"}, {"problem": 74, "code": "(fn squares [str-coll]                                                         \n  (let [coll (map #(Integer. %) (clojure.string/split str-coll #\",\"))            \n        square? (fn [num] (let [root (Math/sqrt num)] (== root (.intValue root))))\n        filtered-coll (filter square? coll)]                                     \n    (clojure.string/join \",\" filtered-coll)))", "user": "58ebd10de4b056aecfd47d49"}, {"problem": 74, "code": "(fn [number-string]\n         (->> number-string\n              (re-seq #\"[0-9]+\")\n              (map #(Integer/parseInt %))\n              (filter (comp (fn [x] (= x (Math/floor x)))  #(Math/sqrt %)))\n              (map str)\n              (clojure.string/join \",\")))", "user": "53dad484e4b0e771c30254ac"}, {"problem": 74, "code": "(fn [xs] \n  (->> (clojure.string/split xs #\",\")\n  \t   (map #(. Integer parseInt %)) \t\n       (filter #(= %1  (* (int (Math/sqrt %1))  (int (Math/sqrt %1)))   ))\n       (clojure.string/join \",\")))", "user": "58eed4c5e4b056aecfd47db7"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\")\n      (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"})\n      (clojure.string/join \",\"))", "user": "59496129e4b07ddc2dafadd7"}, {"problem": 74, "code": "(fn p74 [xs]\n  (let [number (map #(Integer/parseInt %) (clojure.string/split xs #\",\"))\n        perfect (filter #{4 9 16 25 36} number)]\n    (clojure.string/join \",\" perfect)))", "user": "593910eae4b02506e01a29f4"}, {"problem": 74, "code": "#(apply str (clojure.string/split % #\"5,6,7,8,|15,|,37\"))", "user": "59390a35e4b02506e01a29f3"}, {"problem": 74, "code": "(fn [s] (let [xs (map read-string (clojure.string/split s #\",\"))\n              perfect? #(let [sqrt (Math/sqrt %)] (= (double (int sqrt)) sqrt))\n              perfects (filter perfect? xs)]\n           (clojure.string/join \",\" perfects)))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 74, "code": "(fn [s]\n  (let [l (map read-string (clojure.string/split s #\",\"))\n        m (apply max l)\n        sqs (set (map #(* % %) (range 1 (/ m 2))))]\n    (clojure.string/join \",\" (seq (filter sqs l)))))", "user": "59663e77e4b069c0a1a1979f"}, {"problem": 74, "code": "(fn [string]\n  (let [all-nums (map #(Integer. %) (clojure.string/split string #\",\"))]\n    (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1)) all-nums))))", "user": "590b8607e4b047aa04b199db"}, {"problem": 74, "code": "(fn filt-perf-sq [s]\n  (clojure.string/join \",\" (map str\n       (filter #(let [s (Math/sqrt %)] (= s (Math/floor s)))\n               (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n       ))\n  )", "user": "5972fcf6e4b01722bebd4c92"}, {"problem": 74, "code": "(fn perfect-squares\n  [strng]\n  (clojure.string/join \",\"\n                        (filter\n                          (fn[number](== (Math/sqrt (Integer/parseInt number))\n                                         (int (Math/sqrt (Integer/parseInt number)))\n                                         )\n                             )\n                                    (clojure.string/split strng #\",\")\n                          )\n                       )\n  )", "user": "59692530e4b069c0a1a197e4"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (map str (filter #(= % (int (* (int (Math/sqrt %)) (Math/sqrt %)))) (map #(Integer. %) (re-seq #\"\\w+\" s)))))))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 74, "code": "(fn kv-filter [stavk]\n  (let [ss (map #(Integer. %) (vec (.split stavk \",\")))]\n  (clojure.string/join \",\" (filter #(= 0.0 (rem (Math/sqrt %) 1.0)) ss))))", "user": "584d99c5e4b0b7285a6f4e42"}, {"problem": 74, "code": "(fn [original-str] (clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map #(Integer. %) (clojure.string/split original-str #\",\")))))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (filter #(let [r (int (Math/sqrt %))]\n                  (= % (* r r))))\n       (clojure.string/join \",\")))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 74, "code": "some #(if (= \\4 %) \"4,9\" \"16,25,36\")", "user": "4fb1d7ace4b081705acca281"}, {"problem": 74, "code": "(fn perfect-squares [csi]\n   (let [ints (#(read-string (str \"(\" % \")\")) csi)]\n     (clojure.string/join \",\" (filter #(let [rt (Math/sqrt %)] (= 0.0 (- rt (int rt)))) ints))))", "user": "587ee260e4b052da650a6353"}, {"problem": 74, "code": "(fn [coll]\n  (loop [string-vec (re-seq #\"\\d+\" coll)\n         result #{}]\n    (if (seq string-vec)\n      (let [numb (read-string (first string-vec))]\n      (if (pos? (rem numb (Math/sqrt numb)))\n        (recur (next string-vec) result)\n        (recur (next string-vec) (conj result (first string-vec)))))\n      (->> result\n          (vec)\n          (sort)\n          (interleave (repeat \",\"))\n          (next)\n          (apply str)))))", "user": "593744abe4b02506e01a299b"}, {"problem": 74, "code": "(fn [s]\n  (reduce\n    #(str %1 \",\" %2)\n    (filter\n      (fn [x]\n        (some\n          #(= x (* % %))\n          (range x)))\n      (map read-string (re-seq #\"\\d+\" s)))))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 74, "code": "(fn [str]\n  (->> (clojure.string/split str #\",\")\n       (filter #(zero? (rem (Double. %) (Math/sqrt (Double. %)))))\n       (clojure.string/join \",\")))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 74, "code": "(fn perfect-squares [string]\n   (clojure.string/join \",\" (filter #(let [\n                                           number (Integer. %)\n                                           sqrt (Math/sqrt number)\n                                           parsed (int sqrt)\n                                           ]\n                                       (= number (* parsed parsed))\n                                       )\n                                    (-> string\n                                        (clojure.string/split #\",\")\n                                        )\n                                    ))\n   \n   )", "user": "583f1533e4b089d5ab817dc8"}, {"problem": 74, "code": "(fn [nums]\n  (clojure.string/join\n   \",\"\n   (filter \n    #(let [sqrt (java.lang.Math/sqrt %)]\n      (= (java.lang.Math/floor sqrt) sqrt))\n    (read-string (str \"[\" nums \"]\")))))", "user": "58fc52cee4b0438e51c2cf95"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (map #(Integer. %) (clojure.string/split s #\",\"))\n        p? (fn [x] (some #(= x (* % %)) (range 2 x)))]\n    (clojure.string/join \",\" (filter p? xs))))", "user": "5884f377e4b0f1effa3b76a8"}, {"problem": 74, "code": "#(clojure.string/join \",\"\n (filter\n  (fn is-square\n   ([n] (is-square 0 1 n))\n   ([i s n]\n    (if (= i n)\n     true\n     (if (> i n)\n      false\n      (is-square\n       (+ i s)\n       (+ 2 s)\n       n)))))\n   (map (fn [s]\n     (reduce\n      (fn [x y]\n       (+ (* 10 x)\n        (- (int y)\n         (int \\0))))\n      0 s))\n    (clojure.string/split\n     % #\",\"))))", "user": "598ab445e4b02b9968b84ce0"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (apply str\n  (interpose \\,\n  (reduce \n    (fn [coll char-number]\n      (let [number (Integer/parseInt char-number) root (Math/sqrt number)]\n        (if (= root (float (int root)))\n          (conj coll number)\n          coll\n        )\n      )\n    )\n  [] (clojure.string/split s #\"\\,+\"))\n  )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 74, "code": "(letfn [(square? [n] (some #(= % (/ n %))\n                           (range 1 n)\n                     )\n        )\n        (from-string [s] (->> (clojure.string/split s #\",\")\n                              (map #(Integer/parseInt %))\n                         )\n        )\n        (to-string [l] (apply str (interpose \",\" l))\n        )\n       ]\n       #(->> (from-string %)\n             (filter square?)\n             to-string\n        )\n)", "user": "5990fcb9e4b0866487ed0d5b"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter #(-> % read-string Math/sqrt (mod 1) zero?))\n       (clojure.string/join \",\")))", "user": "58c73111e4b021aa9917ed72"}, {"problem": 74, "code": "(fn squares [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(= % (int (Math/pow (int (Math/sqrt %)) 2)))\n    (map #(Integer. %) (clojure.string/split s #\",\")))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (filter #(let [r (Math/sqrt (read-string %))] (zero? (- r (int r)))))\n             (clojure.string/join \",\")))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\") (map #(Integer/parseInt %)) (filter #(= (mod (Math/sqrt %) 1) 0.0)) (clojure.string/join \",\")))", "user": "59468de7e4b07ddc2dafad88"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (for [p (re-seq #\"\\d+\" s) :let [n (Long/parseLong p) isqrt (cond\n   (> n 24)\n   (let []\n     (loop [init-value (quot n 2)]\n       (let [iterated-value (quot (+ init-value (quot n init-value)) 2)]\n\t (if (>= iterated-value init-value)\n\t   init-value\n\t   (recur iterated-value)))))\n   (> n 15) 4\n   (> n  8) 3\n   (> n  3) 2\n   (> n  0) 1\n   (> n -1) 0)] :when (= (* isqrt isqrt) n)] (str n))))", "user": "59a24c92e4b066c664927d20"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter (fn [n] (some #(= (* % %) n) (range n))))\n       (clojure.string/join \",\")))", "user": "597a4277e4b02382a38ad1e2"}, {"problem": 74, "code": "(fn [y]\n  (let [s (clojure.string/split y #\",\")\n        p (filter (fn [x] (= 0.0 (rem (* 100 (Math/sqrt (Integer. x))) 100))) s)]\n   (clojure.string/join \",\" p)))", "user": "5989e080e4b021a7a535fed6"}, {"problem": 74, "code": "(fn squares [string]\n  (clojure.string/join \",\"\n                       (filter #(= (rem (Math/sqrt (Integer/parseInt %)) 1) 0.0)\n                               (clojure.string/split string #\",\"))))", "user": "59971e2de4b07157cc8daacc"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (re-seq #\"\\w+\" s)\n        tst #(let [x (Math/sqrt (Integer/parseInt %))] (= x (Math/floor x)))]\n    (->>\n      (filter tst xs)\n      (clojure.string/join \",\"))))", "user": "5162757ee4b03cfa3774b3fe"}, {"problem": 74, "code": "(fn [input]\n  (let [nums-str (clojure.string/split input #\",\")\n        nums (map #(Integer/parseInt %) nums-str)]\n    (->> (filter #(= (Math/pow (Math/sqrt %) 2) (Math/pow (int (Math/sqrt %)) 2)) nums)\n         (clojure.string/join \",\"))))", "user": "59a96a85e4b0bcf4e9a43b13"}, {"problem": 74, "code": "(fn eka\n    [word]\n    (->> (re-seq #\"\\d+\" word)\n         (map #(Integer. %))\n         (filter #(let [res (Math/sqrt %)\n                        resround (float (Math/round res))]\n                    (= res resround)))\n         (clojure.string/join \",\")\n         )\n    )", "user": "596d630ae4b069c0a1a19846"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map #(Integer/parseInt %))\n        (filter (fn [n]\n                  (let [root (Math/sqrt n)]\n                    (== (int root) root))))\n        (clojure.string/join \",\")))", "user": "59b1c2eae4b0e1f4e384c8ec"}, {"problem": 74, "code": "(fn [s]\n\t(let [\n\t\tnums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n\t\tperfectSquares (filter (fn [x]\n\t\t\t(let [ squareRoot (Math/sqrt x) iSquareRoot (int squareRoot)]\n\t\t\t\t(zero? (- squareRoot iSquareRoot))\n\t\t\t)) nums)\n\t\t]\n\t\t(clojure.string/join \",\" perfectSquares)))", "user": "598af379e4b02b9968b84ce6"}, {"problem": 74, "code": "(fn [text] \n  (letfn [(parse [text] (->> text (re-seq #\"\\d+\") (map #(Integer/parseInt %))))\n          (perfectSquare? [n] (let [sqrt (Math/sqrt n)] (== sqrt (int sqrt))))]\n    (->> text parse (filter perfectSquare?) (clojure.string/join \",\"))))", "user": "59a72effe4b066c664927d94"}, {"problem": 74, "code": "(fn[d](clojure.string/join \",\" (filter #(let [s (Math/sqrt %)] (= s (Math/floor s))) (map #(Integer/parseInt %) (re-seq #\"\\d+\" d)))))", "user": "563c6ebae4b0bfe05bf11834"}, {"problem": 74, "code": "(fn[s]\n        (let [square?\n              (fn[n]\n                ((fn\n                   [low high]\n                   (let [mid (quot (+ high low) 2)\n                         msq (* mid mid)]\n\n                     (cond\n                      (= n msq)\n                      true\n                      \n                      (> low high)\n                      false\n                      \n                      :else\n                      (if (< n msq)\n                        (recur low (dec mid))\n                        (recur (inc mid) high))))) 1 n))]\n        \n          (apply str (interpose \",\"\n                                (filter square?\n                                        (map read-string (clojure.string/split s #\",\")))))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 74, "code": "(fn perfect-squares\n  [string]\n  (clojure.string/join \",\" (filter (fn [n] (some #(== n %) (take-while #(>= n %) (map #(* % %) (range))))) (map #(read-string %) (clojure.string/split string #\",\")))))", "user": "5888b75fe4b0f1effa3b771b"}, {"problem": 74, "code": "(fn \n  [x] \n  (apply str \n      (interpose \",\" \n          (filter #(= 0.0 (- (int (Math/sqrt %)) (Math/sqrt %))) \n               (map #(Integer/valueOf %) (clojure.string/split x #\"\\,\"))))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (map read-string)\n             (filter #(let [root (Math/sqrt %)] (= (Math/floor root) root)))\n             (interpose \",\")\n             (apply str)))", "user": "597768d0e4b01722bebd4cee"}, {"problem": 74, "code": "(fn filter-squares [s] \n(letfn [(is-square? [n]\n  (loop [x (quot n 2) seen #{x}]\n    (if (= n (* x x)) true\n    (let [xx (quot (+ x (quot n x)) 2)] \n      (if (contains? seen xx) false\n      (recur xx (conj seen xx))\n    )))\n))]\n(apply str (interpose \",\" (filter is-square? (map read-string (clojure.string/split s #\",\")))))\n))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 74, "code": "(fn [s]\n  (->>\n   (clojure.string/split s #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(== % (Math/pow (int (Math/sqrt %)) 2)))\n   (clojure.string/join \",\")\n   )\n  )", "user": "59cc4d5ee4b0a024fb6ae5d0"}, {"problem": 74, "code": "(fn [sv] (apply str (interpose \",\" (filter #(let [n (Integer/parseInt %)\n                    k (int (Math/sqrt n))]\n                 (= (* k k) n))\n                  (clojure.string/split sv #\",\")))))", "user": "59089229e4b047aa04b1997c"}, {"problem": 74, "code": "(fn  \n  [input] \n  (clojure.string/join \",\"\n    (for [i (clojure.string/split input #\",\")\n      \t  y (range 2 10)\n          :let [x (Integer/parseInt i)]\n          :when (= (* y y) x)]\n      i)))", "user": "5554ae14e4b0deb715856e0e"}, {"problem": 74, "code": "(fn [xs] (apply str (interpose \",\" (filter #(let [n (Integer. %) sqrt (int \n(Math/sqrt n))] (= n (* sqrt sqrt))) (re-seq #\"\\d+\" xs)))))", "user": "59358f74e4b04f87174def52"}, {"problem": 74, "code": "(fn [input]\n  (clojure.string/join\n    \",\"\n    (filter\n       #(== 0 (rem (Math/sqrt %) 1))\n       (map #(Integer/parseInt %) (clojure.string/split input #\",\")))))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 74, "code": "(fn [s]\n(->> (clojure.string/split s #\",\")\n(map read-string)\n(filter (fn [x] (let [y (Math/sqrt x)] (== y (int y)))))\n(clojure.string/join \",\")))", "user": "59cf4013e4b0ef0a1e9b5b68"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= (apply * (repeat 2 (Math/sqrt (Integer. %)))) (float (Integer. %))) (clojure.string/split s #\",\"))))", "user": "59ddae03e4b01968742fed65"}, {"problem": 74, "code": "(fn [sqs]\n  (letfn [(perfect-square? [n]\n            (let [sqrt (Math/sqrt n)]\n              (= n (* (int sqrt) (int sqrt)))))]\n    (->> sqs\n         (re-seq #\"\\d+\")\n         (map read-string)\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 74, "code": "(fn [strn]\n  (->> (clojure.string/split strn #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [n]\n                 (let [sqn (Math/round (Math/sqrt n))]\n                   (= n (* sqn sqn)))))\n       (clojure.string/join \",\")))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 74, "code": "#(->> (re-seq #\"[^,]+\" %)\n      (map read-string)\n      (filter (fn [n] (some (fn [i] (= n (* i i))) (range (inc (Math/sqrt n))))))\n      (clojure.string/join \",\"))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 74, "code": "(fn [s] (->> s\n         (partition-by #{\\,})\n         (take-nth 2)\n         (map #(apply str %))\n         (map #(Integer/parseInt %))\n         (filter #(= (mod (Math/sqrt %) 1) 0.0))\n         (interpose \",\")\n         (apply str)))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 74, "code": "(fn [nlist]\n  (let [xs (clojure.string/split nlist #\",\")\n        ns (map read-string xs)\n        sqrts (map #(Math/sqrt %) ns)\n        isint? #(== % (int %))\n        psqrts (filter isint? sqrts)\n        sqr #(int (* % %))\n        ]\n    (clojure.string/join \",\" (map sqr psqrts))))", "user": "57ed8315e4b0bfb2137f5b9a"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (reduce #(let [sqrt (Math/sqrt %2)] (if (= (Math/floor sqrt) sqrt) (conj % %2) %)) [] (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "59c734e3e4b0a024fb6ae53f"}, {"problem": 74, "code": "(fn  [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(let [root (Math/sqrt %)](= root (float (int root)))))\n       (clojure.string/join \",\")))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let\n    [is-square? (fn [x] (let [root (int (Math/sqrt x))] (= x (* root root))))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter is-square?)\n         (clojure.string/join \",\"))))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 74, "code": "(fn [n]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split n #\",\"))\n        squares? (fn [x]\n                   (let [y (Math/sqrt x)] (= y (Math/floor y))))\n        perfect (filter squares? nums)]\n    (clojure.string/join \",\" perfect)))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 74, "code": "(fn [s]\n    (let [root-floor (fn [x] (int (+ 0.00001 (Math/sqrt x))))\n          perfect-square? (fn [x] (let [rt (root-floor x)] (= x (* rt rt))))\n          strings-to-ints (fn [s] (map #(Integer. %) s))]\n      (->> (.split s \",\")\n           strings-to-ints\n           (filter perfect-square?)\n           (interpose \",\")\n           (apply str))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 74, "code": "(fn [d]\n(let [l (map #(Integer/valueOf %)\n  \t\t\t(clojure.string/split d #\",\"))\n\t\ts (map #(Math/ceil (Math/sqrt %)) l)]\n\t\t(clojure.string/join \",\" \n\t\t(map first\n\t\t(filter (fn [[a b]] (== a (* b b)))\n\t\t\t(partition 2 (interleave l s)))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n\t     (map #(Integer. %))\n    \t (filter #(let [x (int (Math/sqrt %))]\n        \t        (= (* x x) %)))\n\t     (clojure.string/join \\,)))", "user": "52fe31d5e4b047fd55837038"}, {"problem": 74, "code": "(fn [s]                                                                                                                                                                                                                                                                  \n  (let [nums (map #(Integer/parseInt %) (re-seq #\"[^,]+\" s))                                                                                                                                                                                                             \n        is-perfect-square? #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))                                                                                                                                                                                            \n        join-with-commas #(apply str (interpose \",\" %))]                                                                                                                                                                                                                 \n    (->> nums                                                                                                                                                                                                                                                            \n         (filter is-perfect-square?)                                                                                                                                                                                                                                     \n         (map str)                                                                                                                                                                                                                                                       \n         join-with-commas)))", "user": "5a012a43e4b01bb0ae8afd42"}, {"problem": 74, "code": "(fn [stringedNums] (let [listOfNums (map #(Integer. %) (re-seq #\"[0-9]+\" stringedNums))\n       perfectSquares (filter \n                       #(loop [cnt 1 n %] \n                          (cond \n                           (> (* cnt cnt) n) false \n                           (= (* cnt cnt) n) true \n                           :else (recur (inc cnt) n)))\n                       listOfNums)\n       stringedPerfectSquares (clojure.string/join \",\" perfectSquares)\n       ]\nstringedPerfectSquares))\n\n\n;(clojure.string/join \",\" \n;                     (filter \n;                      #(loop [cnt 1 n %] (cond (> (* cnt cnt) n) false (= (* cnt cnt) n) true :else (recur (inc cnt) n))) \n;                      (map #(Integer. %) (re-seq #\"[0-9]+\" \"1,2,3,4,5,6,7,8,9,10\"))))", "user": "588fd085e4b00487982d51c0"}, {"problem": 74, "code": "(fn [ string ]\n  (clojure.string/join \",\" (filter #(= (Double. %) (* (Math/pow (Integer. %) 0.5) (Math/pow (Integer.  %) 0.5))) (clojure.string/split string #\",\") )))", "user": "59f90e6ae4b0ca45a743a337"}, {"problem": 74, "code": "(fn __ [s]\n  (letfn [(sqr? [i] (-> i Math/sqrt int (#(* % %)) (= i)))]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter sqr?)\n         (clojure.string/join \",\"))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter #(let [r (Math/sqrt %)]\n                    (= r (Math/floor r))))\n         (clojure.string/join \",\")))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 74, "code": "#(->> (str \\[ % \\])\n      (read-string)\n      (filter (fn [n]\n                (let [root (Math/sqrt n)]\n                  (== root (int root)))))\n      (interpose \\,)\n      (apply str))", "user": "59a080e3e4b0871e7608b837"}, {"problem": 74, "code": "(fn perf [string]\n  (clojure.string/join \",\"\n                       (filter #(->> (Integer. %)\n                                     Math/sqrt\n                                     str\n                                     (re-matches #\"\\d+\\.0\")\n                                     boolean)\n                               (re-seq #\"\\d+\" string))))", "user": "58fed70de4b0438e51c2cfdd"}, {"problem": 74, "code": "(fn[input]\n(let\n[\n  inputList (map #(Integer/parseInt %) (clojure.string/split input #\",\"))\n  largestNum (reduce #(if (> %1 %2) %1 %2) inputList)\n  squares (reduce #(conj %1 [(* %2 %2) %2]) {} (range, (/ largestNum 2)))\n  filteredSquares (filter #(contains? squares %) inputList)\n  \n]\n(clojure.string/join \",\" filteredSquares))\n)", "user": "571172ece4b09c608db70446"}, {"problem": 74, "code": "(fn\n  [s]\n  (let [perfect-square? (fn [x] \n                          (let [i (Integer/parseInt x)\n                                sqrt (int (Math/sqrt i))]\n                            (= (* sqrt sqrt) i)))\n        numbers (clojure.string/split s #\",\")\n        squares (filter perfect-square? numbers)]\n    (clojure.string/join \",\" squares)))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 74, "code": "(fn [xs]\n  (let [is-perfect-square #(zero? (mod (Math/sqrt %1) 1))]\n    (->>\n      (.split xs \",\")\n      (map #(Integer/parseInt %1))\n      (filter is-perfect-square)\n      (interpose \",\")\n      (apply str))))", "user": "55d1ec3ee4b0e31453f64a4c"}, {"problem": 74, "code": "(fn [s]\n    \n  (letfn [ (is-perfect-square? [n]\n             (loop [rem n\n                    sub 1]\n               (if (= rem 0)\n                 true\n                 (if (< rem 0)\n                   false\n                   (recur (- rem sub) (+ sub 2)))\n                 )))]\n\n  (clojure.string/join \",\" (filter is-perfect-square? (map read-string (clojure.string/split s #\",\")) )\n  \n)))", "user": "56f2611fe4b04a395b9a04a2"}, {"problem": 74, "code": "(fn [s]\n  (->> (.split s \",\")\n       (map read-string)\n       (filter (fn [i]\n                 (let [x (Math/sqrt i)]\n                   (== x (int x)))))\n       (clojure.string/join \",\")))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 74, "code": "(fn t [s]\n(let [\nstrs (clojure.string/split s #\",\")\nints (map #(. Integer parseInt %) strs)\nrooted (filter #(zero? (mod (Math/sqrt %) 1)) ints) \n]\n(clojure.string/join \\, rooted)))", "user": "589b98fae4b00487982d533c"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\"\\s*,\\s*\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        filtered (filter psquare? nums)]\n    (apply str (interpose \",\" filtered))))", "user": "5a0a25fce4b0eab8c044893d"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n  (filter \n   (fn [str] \n     (= \n      (quot (Math/sqrt (Integer. str)) 1)\n      (Math/sqrt (Integer. str))))\n   (clojure.string/split s #\",\"))))", "user": "59f75327e4b0966464fe6aec"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\"\n  (filter #(= 0.0 (mod (Math/sqrt %) 1)) \n    (read-string (str \"[\" s \"]\")) )) )", "user": "59f44189e4b0966464fe6aab"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter (fn [v] (== (java.lang.Math/sqrt v) (int (java.lang.Math/sqrt v)))) (map (fn [v] (Integer. v)) (clojure.string/split s #\",\")))))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 74, "code": "(fn [args] \n   (let [lt  (into [] (map read-string (clojure.string/split args #\",\") ))\n         psq (vec (map #(* % %) (range 2 10))) \n         ins (fn [ps x] (if ((set ps) x) true false)) ]\n     (apply str (interpose \",\" (filter  #(ins psq %) lt)))\n   )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 74, "code": "#(->> (read-string (str \"[\" % \"]\")) \n      (filter (fn [n] (= (* 1.0 n) (Math/pow (Math/sqrt n) 2)))) \n      (interpose \",\") \n      (apply str))", "user": "4dc78527535d8a4b2fd7428f"}, {"problem": 74, "code": "(fn __ [x]\n  (let [square? (fn [n]\n                  (let [seed  (if (< n 10) 2 6)\n                        rough (/ (+ seed (/ n seed)) 2)\n                        sqrt  (int (Math/floor rough))\n                        pow   (* sqrt sqrt)]\n                    (= pow n)))]\n    (clojure.string/join \",\" (filter square? (map #(Integer/parseInt %) (clojure.string/split x #\",\"))))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 74, "code": "(fn [x] \n\t(->> (clojure.string/split x #\",\") \n\t     (map read-string) \n\t     (filter \n\t             (fn [y] (let [z (Math/sqrt y)] \n\t                          (= 0.0 (- z (Math/floor z)))))) \n\t     (clojure.string/join #\",\" )))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 74, "code": "(fn [in]\n  (let\n    [nums\n        (map read-string (clojure.string/split in #\",\"))\n    m (apply max nums)    \n    squares\n        (set (take-while #(>= m %) (map #(* % %) (range))))]\n  (clojure.string/join \",\" (filter #(contains? squares %) nums))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\" (filter (fn [n] (let [x (Math/sqrt (Long/parseLong n))] (== (long x) x))) (re-seq #\"\\d+\" s))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "58bc0531e4b0888cdc949d07"}, {"problem": 74, "code": "(fn [s]\n    (let [parse_int (fn [x] (Integer/parseInt x))\n          nums (map parse_int (clojure.string/split s #\",\"))\n          sqrt (fn [n]\n                   ((fn [a_l a_u]\n                        (loop [l a_l\n                               u a_u]\n                              (if (<= (- u l) 1)\n                                  l\n                                  (let [mid (quot (+ l u) 2)\n                                        mid_sqr (* mid mid)]\n                                       (if (<= mid_sqr n)\n                                           (recur mid u)\n                                           (recur l mid)))))) 1 n))\n          perfect_square? (fn [n]\n                              (let [sqrt_n (sqrt n)]\n                                   (= (* sqrt_n sqrt_n) n)))\n          perfect_sqs (filter perfect_square? nums)]\n          (apply str (interpose \",\" perfect_sqs))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 74, "code": "(fn [s]\n  (let [values (map read-string (clojure.string/split s #\",\"))\n        square? #(= 0. (mod (Math/sqrt %) 1))\n        squares (filter square? values)]\n    (apply str (interpose \",\" squares))))", "user": "5a3d33b3e4b001c08efc0cef"}, {"problem": 74, "code": "(fn perfect-squares [int-string]\n  (let\n      [ints (map #(Integer. %) (vec (.split int-string \",\")))\n       is-square (fn [x]\n                   (let [root (Math/sqrt x)]\n                     (= root (Math/floor root))))\n       comma-sep-list (fn [coll]\n                        (if (empty? coll)\n                          '()\n                          (pop (vec (mapcat #(concat (str %) \",\") coll)))))]\n    (apply str (comma-sep-list (filter is-square ints)))))", "user": "59f7f55de4b0ca45a743a313"}, {"problem": 74, "code": "(fn [c] (let [isp (fn [i] (zero? (rem (java.lang.Math/sqrt i) 1 )))\n              nums (map #(Integer. %) (re-seq #\"\\d+\" c))]\n      (apply str (interpose \",\" (filter isp nums)))))", "user": "5957cc41e4b066ee0a44af76"}, {"problem": 74, "code": "(fn [arg]\n   (clojure.string/join \",\" (map str (filter #(let [sqrt (Math/sqrt %)]\n                               (= (* (Math/floor sqrt) (Math/floor sqrt)) (Math/floor %))) (map #(Integer/parseInt %) (.split arg \",\")))\n                )))", "user": "558843dae4b059ccff29b1f3"}, {"problem": 74, "code": "(fn [input]\n    (clojure.string/join \",\"\n        (for [num (.split input \",\")\n          :let [sqrt (Math/sqrt (Double/valueOf num))]\n          :when (= (Math/ceil sqrt) sqrt)] num)))", "user": "5a01d8f6e4b01bb0ae8afd53"}, {"problem": 74, "code": "#(letfn [(is-perfect-square [x] (let [sqrt (Math/sqrt x)] (== (long sqrt) sqrt)))\n         (parse-int [x] (Integer/parseInt x))]\n    (->>  (map parse-int (clojure.string/split % #\",\"))\n          (filter is-perfect-square)\n          (clojure.string/join \",\")\n          ))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 74, "code": "(fn [s] \n\t(clojure.string/join \",\" (filter #(let [root (Math/sqrt %)]\n\t\t\t  \t  \t\t \t\t  \t\t\t(= root (Math/floor root)))\n\t\t\t\t\t\t  \t  \t\t  (map read-string (clojure.string/split s #\",\")))))", "user": "59fa5773e4b0ca45a743a35e"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5a3c5c54e4b001c08efc0ce3"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= (Math/pow (Math/sqrt %) 2) (float %)) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "5a1c8c26e4b0ff51aa4b3247"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\")\n      (map read-string)\n      (filter (fn [x] (let [q (Math/round (Math/sqrt x))] (= x (* q q)))))\n      (clojure.string/join \",\"))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 74, "code": "(fn [s]\n  (let [\n        perfect-square? (fn [n] (let [r (Math/sqrt (Integer/parseInt n))] (== r (int r))))]\n\n    (clojure.string/join \",\" (filter perfect-square? (clojure.string/split s #\",\")))))", "user": "588e4e05e4b00487982d5188"}, {"problem": 74, "code": "(fn filter-perfect-squares [comma-separated-integer-string]\n  (let\n[to-integers (fn to-integers [csi] (map #(Integer. %) (clojure.string/split csi #\",\")))\n is-square? (fn is-square? [i] (let [froot (Math/sqrt (float i))\n                        iroot (int froot)]\n                    (= i (* iroot iroot))))]\n    (clojure.string/join \",\" (filter is-square? (to-integers comma-separated-integer-string)))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 74, "code": "#(do % (rand-nth [\"4,9\" \"16,25,36\"]))", "user": "5a3c2a08e4b001c08efc0cdf"}, {"problem": 74, "code": "(fn filter-perfect-square [s]\n  (clojure.string/join \",\"\n    (filter (fn [x]\n              (let [xi (Integer/parseInt x)\n                    sq (int (Math/sqrt xi))]\n                (= xi (* sq sq))))\n            (clojure.string/split s #\",\"))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt % 10))\n       (filter #(zero? (rem % (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 74, "code": "(fn [a-str]\n    (let [as-seq (clojure.string/split a-str #\",\")]\n      (->> as-seq\n           (filter (fn [x]\n                     (let [sqrt (Math/sqrt (read-string x))]\n                       (zero? (- sqrt (long sqrt))))))\n           (interpose \",\")\n           (apply str))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 74, "code": "(fn [s]\n  (apply str\n     (interpose \",\"\n       (filter (fn [n]  (some (partial = n) (map #(* % %) (range n))))\n                        (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))))", "user": "53f053ebe4b0742d9025b0d3"}, {"problem": 74, "code": "(fn perfect-squares [S]\n  (let [L (map #(Integer/parseInt %) (clojure.string/split S #\",\"))]\n    (clojure.string/join \",\" (filter #(= (Math/floor (Math/sqrt %)) (Math/ceil (Math/sqrt %))) L))))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 74, "code": "(fn [s]\n    (let [s (clojure.string/split s #\",\")\n          perfect-square? (fn [i] (= (Math/sqrt i) (float (int (Math/sqrt i)))))]\n      (apply str (interpose \",\" (filter perfect-square? (map #(Integer/parseInt %) s))))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [n] (let [n1 (Integer/parseInt n) a (Math/floor (Math/sqrt n1)) b (* a a)] (= n1 (int b)))) (clojure.string/split % #\",\")))", "user": "5a66f358e4b0512ff01cd9d5"}, {"problem": 74, "code": "(fn[s]\n     (clojure.string/join \",\" (filter  #(zero? (rem (java.lang.Math/sqrt %) 1)) (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))\n  )", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 74, "code": "(fn perf-square\n  [s]\n  (->> (clojure.string/split s #\",\")\n           (map #(Integer/parseInt %))\n           (filter #(-> %\n                        Math/sqrt\n                        Math/round\n                        (Math/pow 2)\n                        int\n                        (= %)))\n           (clojure.string/join \",\")))", "user": "5974d2ede4b01722bebd4cb6"}, {"problem": 74, "code": "(fn[x](apply str (interpose \",\" \n                    (filter #(if (= (double (int (Math/sqrt %)))\n                                  (Math/sqrt %)) true false)\n                          (map read-string (.split x \",\"))))))", "user": "5a067f26e4b01bb0ae8afdcc"}, {"problem": 74, "code": "(fn\n  [s]\n  (let [strings (clojure.string/split s #\",\")\n        nums (keep (comp #{4 9 16 25 36 49 64} read-string) strings)]\n    (clojure.string/join \",\" nums)))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 74, "code": "(fn [str]\n  (->> (clojure.string/split str #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [x] (= (int (Math/pow (int (Math/sqrt x)) 2)) x)))\n       (clojure.string/join \",\")))", "user": "5486e317e4b0e286459a11c0"}, {"problem": 74, "code": "(fn filtersq [s]\n  (let [c (->> (clojure.string/split s #\",\")\n             (map #(Integer. %)))]\n    (->> (filter (set (map #(* % %) (range 0 (apply max c)) )) c)\n         (clojure.string/join \",\"))))", "user": "5a527beee4b05d388ecb6bfe"}, {"problem": 74, "code": "(fn filtsquare [s]\n  (let [square-vect (map #(Integer/parseInt %)\n                         (clojure.string/split s #\",\"))\n        is-perfect-square (fn [x]\n                            (let [sqrt (Math/sqrt x)]\n                              (if (== sqrt (int sqrt)) true false)))]\n    (loop [s square-vect\n           res []]\n      (if (seq s)\n        (recur (rest s) (if (is-perfect-square (first s))\n                          (conj res (first s))\n                          res))\n        (clojure.string/join \",\" (map str res))))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 74, "code": "(fn [s]\n    (->> (map read-string (clojure.string/split s #\",\"))\n         (filter #(-> % Math/sqrt (rem 1) zero?))\n         (clojure.string/join \",\")))", "user": "527ba29de4b03e8d9a4a7594"}, {"problem": 74, "code": "(fn [q] \n  (->> (.split q \",\") \n       (map #(Integer/parseInt %)) \n       (filter #(let [r (Math/sqrt %)] (= r (Math/ceil r)))) \n       (map str) \n       (clojure.string/join \",\")))", "user": "4fe88f78e4b07c9f6fd12c45"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n       (clojure.string/join \",\")))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 74, "code": "(fn ps\n  [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (map #(Math/sqrt %))\n       (filter #(= % (Math/floor %)))\n       (map int)\n       (map #(* % %))\n       (interpose \",\")\n       (apply str)))", "user": "5a188be3e4b0ff51aa4b31ec"}, {"problem": 74, "code": "(fn [s] (->> s\n         (#(.split % \",\"))\n         (map #(Integer/parseInt %))\n         (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n         (interpose \",\") \n         (apply str)\n         \n             ))", "user": "586f3f7ee4b01531a375e9c1"}, {"problem": 74, "code": "(fn [input]\n(clojure.string/join \",\"\n(filter (fn [x] (= (* (int (Math/sqrt x)) (int (Math/sqrt x))) x ))\n  (map read-string (clojure.string/split input #\",\")))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn issquare [a] (= a (* (int (Math/sqrt a)) (int (Math/sqrt a))))) (map #(Integer. %)(clojure.string/split s #\",\")))))", "user": "594a7ed1e4b07ddc2dafae02"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (seq)\n         (map #(Integer/parseInt %))\n         (filter (fn [x] (some #(= x (* % %)) (range 2 x))))\n         (map str )\n         (interpose \",\")\n         (apply str)\n         ))", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 74, "code": "(fn [csv]\n  (clojure.string/join \",\"\n    (map str (filter #(let [s (Math/sqrt %)] (zero? (- (int s) s)))\n                                (map #(Integer/valueOf %)\n                                     (into [] (.split csv \",\")))))))", "user": "5a342188e4b0ddc586f153bd"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \n   \",\"\n   (filter\n    #(let [a (read-string %)\n           o (int(Math/sqrt a))]\n       (= a (* o o)))\n    (clojure.string/split s #\",\"))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 74, "code": "(let [mem-perf-sq? (memoize (fn [n]\r\n                                           (let [initial-candidates (for [x (range 1 n) :when (>= n (* x x))] x)]\r\n                                             (loop [candidates initial-candidates found? false]\r\n                                               (if (empty? candidates)\r\n                                                 found?\r\n                                                 (recur (rest candidates) (let [cand (first candidates)]\r\n                                                                            (= n (* cand cand)))))))))]\r\n               (fn [s]\r\n                 (-> (clojure.string/split s #\",\")\r\n                     ((fn [nums] (map read-string nums)))\r\n                     ((fn [nums] (filter mem-perf-sq? nums)))\r\n                     ((fn [nums] (map str nums)))\r\n                     ((fn [nums] (interpose \",\" nums)))\r\n                     ((fn [nums] (reduce str nums))))))", "user": "580e7761e4b0849f6811b753"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)))\n       (map str)\n       (clojure.string/join \",\")))", "user": "4ed45563535d10e5ff6f52c9"}, {"problem": 74, "code": "(fn\n  [x]\n  (let\n   [perf-sq\n    (fn [x] (let [sqrt (int (Math/sqrt x))] (= (* sqrt sqrt) x)))]\n   (clojure.string/join\n    \",\"\n    (filter perf-sq (map read-string (clojure.string/split x #\",\"))))))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 74, "code": "(fn psq [s]\n  (let [sqrs (set (map #(* % %) (range 100)))] \n  \t(clojure.string/join \",\" (filter (comp sqrs #(Integer/parseInt %)) (clojure.string/split s #\",\")))))", "user": "598858d0e4b021a7a535feb5"}, {"problem": 74, "code": "(fn [vect] (apply str\n              (interpose \",\"\n                 (filter\n                  (fn [a]\n                    (let [i (int (Math/sqrt a))]\n                      (= (* i i) a))\n                  )\n                  (map\n                    read-string\n                    (re-seq #\"[1-9]+\" vect)\n                  )\n              ))\n            \n            ))", "user": "5a9e3698e4b0d174b936c7fc"}, {"problem": 74, "code": "(fn [dig-str]\n  (let [digs (->> dig-str\n                  (partition-by #(= \\, %))\n                  (filter #((complement =) '(\\,) %))\n                  (map (comp read-string #(apply str %))))\n        sqs (into #{} (for [x (range) :let [sq (Math/pow x 2)] :while (< sq 50)] (int sq)))]\n    (apply str (interpose \",\" (filter #(contains? sqs %) digs)))\n   ;;digs\n    \n  ))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 74, "code": "(fn cs4 [s]\n  (let [v (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        square? (fn [n]\n                  (let [squ (Math/sqrt n)]\n                    (= (Math/floor squ) squ)))\n        result (filter square? v)]\n    (apply str (interpose \",\" result))))", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(let [q (int (Math/sqrt %))] (= % (* q q))))\n       (clojure.string/join \",\")))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 74, "code": "(fn [a]\n     (->> (str \"[\" a \"]\")\n          (read-string)\n          (filter #(let [y (int (Math/sqrt %))]\n                     (= % (* y y))))\n          (clojure.string/join \",\")))", "user": "59e8bb43e4b0249b72820735"}, {"problem": 74, "code": "(fn __ [s]\n  (clojure.string/join \",\"\n                       (map #(int (* % %))\n                            (filter #(zero? (- (int %) %))\n                                    (map #(Math/sqrt %)\n                                         (map #(Integer. %)\n                                              (clojure.string/split s #\",\"))))))\n)", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 74, "code": "(fn myfilter [s]\n  (->> s\n       (( fn [x] (clojure.string/split x #\",\")))\n       (map read-string)\n       (filter (fn [x] (= x (#(* %1 %1) (Math/round (Math/sqrt x))))))\n       (interpose \",\") \n       (apply str)\n       ))", "user": "5ab490f4e4b073f17744261d"}, {"problem": 74, "code": "(fn perfect-squares [string]\n  (->> string\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (map #(Math/sqrt %))\n       (filter #(== (int %) %))\n       (map #(int (* % %)))\n       (clojure.string/join \",\")\n       )\n  )", "user": "5aada061e4b073f17744257a"}, {"problem": 74, "code": "(fn [s] (letfn [(perfect-square? [n]\n    (= n (let [x (loop [a n] \n                (if (> (* a a) n) (recur (quot (+ a (quot n a)) 2)) a))]\n           (* x x))))]\n  (->> (.split s \",\") \n    (map #(Integer/parseInt %))\n    (filter perfect-square?)\n    (clojure.string/join \",\"))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 74, "code": "(fn filter-perfect-squares [astr]\n  (clojure.string/join \n  \t\",\"\n  \t(map\n  \t\tstr\n  \t\t(filter\n  \t\t\t#(< (- (Math/sqrt %)\n  \t\t\t\t   (Math/floor (Math/sqrt %)))\n                0.00001)\n  \t\t(map\n  \t\t\t#(Integer/parseInt %)\n  \t\t\t(clojure.string/split astr #\",\"))))))", "user": "5aaa2dc3e4b0d174b936c8f1"}, {"problem": 74, "code": "(fn [s] \n  (let [s (map read-string (re-seq #\"\\d+\" s))\n        pred? #(let [sqrt (Math/sqrt %)] (= 0 (compare (int sqrt) sqrt)))]\n    (clojure.string/join \",\" (filter pred? s))))", "user": "5a67cedbe4b0512ff01cd9ee"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter (fn [n] (-> n Integer/parseInt Math/sqrt (mod 1) zero?)))\n       (clojure.string/join \\,)))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 74, "code": "(fn p-sqr [str-me]\n   (let [p-sqr? (fn [n]\n                  (let [last-ele (first (drop-while (fn [i]\n                                                      (> n (* i i))) (range)))]\n                    (= n (* last-ele last-ele))))\n         coll (->> (clojure.string/split str-me #\",\")\n                   (seq)\n                   (map #(Integer/parseInt %))\n                   (filter #(p-sqr? %))\n                   (clojure.string/join \",\"))]\n     coll))", "user": "5ab23c99e4b073f1774425e2"}, {"problem": 74, "code": "(let [squares (map #(* % %) (range))]\n  (fn [s]\n    (apply str (interpose \",\" (filter\n      (fn [n] (some #(= % n) (take-while #(>= n %) squares)))\n      (map #(Integer/parseInt %) (.split s \",\")))))\n    )\n  )", "user": "5ab5f60be4b073f177442643"}, {"problem": 74, "code": "(fn filter-squares [number-string]\n  (letfn [(perfect-square? [n]\n            (loop [k 1]\n              (cond (== (* k k) n) true\n                    (> (* k k) n) false\n                    true (recur (inc k)))))]\n    (->> number-string\n         (#(clojure.string/split % #\",\"))\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 74, "code": "(fn return-perfect-sqrs\n  [string]\n  (let [nums (clojure.string/split string #\",\")]\n    (loop [remaing nums\n           final []]\n      (if (= (count remaing) 0)\n        (clojure.string/join \",\" final)\n        (if (= (last (str (Math/sqrt (read-string (first remaing))))) \\0)\n          (recur (rest remaing) (conj final (first remaing)))\n          (recur (rest remaing) final))))))", "user": "5ac35d00e4b0e27600da7712"}, {"problem": 74, "code": "(fn [s]\n    (let [ns (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n          square-roots (map #(Math/sqrt %) ns)]\n      (clojure.string/join (interpose \",\"\n                                      (map #(-> (* % %) int .toString)\n                                           (filter #(= % (-> % int double))\n                                                   square-roots))))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\") (map (fn [e] (Integer. e))) (filter (fn [n] (let [sr (int (Math/sqrt n))] (= n (* sr sr))))) (clojure.string/join \",\"))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 74, "code": "(fn [s]\n    (letfn [(search\n              [coll x]\n              (loop [coll coll]\n                (if (= (first coll) x)\n                  x\n                  (if (< (first coll) x)\n                    (recur (rest coll))))))\n            (squares\n              [x]\n              (lazy-seq\n                (cons (* x x) (squares (inc x)))))]\n      (let [squares-seq (squares 1)\n            ints (->> (clojure.string/split s #\",\")\n                      (map #(Integer. %)))]\n\n        (->> (keep (partial search squares-seq) ints)\n             (clojure.string/join \",\")))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 74, "code": "(fn fps\n  [x]\n  (let [tokens (map #(Long/parseLong %) (clojure.string/split x #\",\"))\n        square-tokens (filter #(let [sqrt (long (Math/sqrt %))] (= % (* sqrt sqrt))) tokens)]\n    (clojure.string/join \",\" square-tokens)))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(integer? (rationalize (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 74, "code": "(fn filter-p-sq [s]\n      (->> (map #(Integer. (clojure.string/trim %)) (clojure.string/split s #\",\"))\n           (filter (fn psq? [x] (some true? (map #(= (* % %) x) (take-while #(<= (* % %) x) (iterate inc 1))))))\n           (reduce #(str %1 \",\" %2))))", "user": "5acd1a43e4b0e27600da7823"}, {"problem": 74, "code": "(fn __\n  [string]\n  (let [is-perfect-square (fn [x]\n                            (let [square-root (Math/sqrt x)]\n                              (== x (* square-root square-root))))]\n    (->> (clojure.string/split string #\",\")\n          (map #(read-string %))\n          (filter #(is-perfect-square %))\n          (clojure.string/join \",\"))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 74, "code": "#(\n     let [a (set (take 10 ((fn sq [a] (lazy-seq (cons (* a a) (sq (inc a))))) 1)))]\n     ( ->>\n       %\n       (re-seq #\"[^,]+\")\n       (map read-string)\n       (set)\n       (clojure.set/intersection a)\n       (sort)\n       (clojure.string/join \",\")\n     ))", "user": "5ac92dc3e4b0e27600da77bf"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "54c72b19e4b045293a27f636"}, {"problem": 74, "code": "(fn [x]\n  (->> (clojure.string/split x #\",\")\n       (map #(Integer/parseInt %))\n       (filter (comp #(== (int %) %) #(Math/sqrt %)))\n       (clojure.string/join \",\")))", "user": "5afc0f30e4b0cc2b61a3bcfe"}, {"problem": 74, "code": "(fn [integers]\n  (letfn [(perfect-square? [n] (== (Math/sqrt n) (Math/floor (Math/sqrt n))))]\n    (let [intlist (map #(Integer/parseInt %) (clojure.string/split integers #\",\"))]\n      (->> (filter perfect-square? intlist)\n           (map str)\n           (clojure.string/join #\",\")))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 74, "code": "(fn [s] (apply str (interpose \",\" (map str (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map read-string (re-seq #\"\\d+\" s)))))))", "user": "5af4446de4b0cc2b61a3bc93"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(loop [i 1]\n                                      (if (> i %)\n                                        false\n                                        (if (= (* i i) %)\n                                          true\n                                          (recur (inc i)))))\n                                   (map read-string (clojure.string/split s #\",\")))))", "user": "5a7ae674e4b03baeef9276d5"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(psq? [n]\n            (->> (range n)\n                 (map #(* % %))\n                 (some #(= n %))))]\n    (->> s\n         (#(clojure.string/split % #\",\"))\n         (map read-string)\n         (filter psq?)\n         (clojure.string/join \",\"))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n    (for [x (map #(Long/parseLong %)\n             (clojure.string/split s #\",\"))\n          :let [y (Math/sqrt x)]\n          :when (= y (double (int y)))]\n      x)))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 74, "code": "(fn [nums]\n  (let [->squares \n        (fn [xs]\n          (->> xs\n               (map #(Integer/parseInt %))\n               (filter #(let [r (Math/sqrt %)]\n                          (= 0.0 (- r (int r)))))))]\n    (->> nums\n         (re-seq #\"\\d+\")\n         ->squares\n         (clojure.string/join \",\"))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(= (float %)\n                   (Math/pow (Math/sqrt %) 2)))\n       (map str)\n       (interpose \",\")\n       (apply str)))", "user": "5aea2d21e4b0cc2b61a3bbe2"}, {"problem": 74, "code": "(fn [s]\n      (-> (->> (clojure.string/split s #\",\")\n               (map read-string)\n               (filterv #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)))\n               str)\n          (clojure.string/replace #\"[^0-9 \\\"]\" \"\")\n          (clojure.string/replace #\" \" \",\")))", "user": "55e732c5e4b050e68259b492"}, {"problem": 74, "code": "(fn [x]\n  (let [squares (fn squares\n                  ([] (squares 1))\n                  ([n] (lazy-seq (cons (* n n) (squares (inc n))))))\n        is-square? (fn [n] (some #{n} (take n (squares))))]\n    (->> x\n         (#(clojure.string/split % #\",\"))\n         (map #(Integer. %))\n         (filter is-square?)\n         (map str)\n         (clojure.string/join \",\")\n         )))", "user": "546e4ab8e4b00cfc9eacc19c"}, {"problem": 74, "code": "(fn [x] (apply str (interpose \",\" (filter #(= 0.0 (- (Math/sqrt %) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split x #\",\"))))))", "user": "57b19fa1e4b0fbc9809a2754"}, {"problem": 74, "code": "(fn perfect-square [s]\n  (let [nums (map #(Integer/valueOf %)  (clojure.string/split s #\",\"))\n        all-perf-sq  (set (map #(* % %) (range 100)))\n        sq-nums (filter all-perf-sq nums)]\n(apply str (interpose \",\" sq-nums))))", "user": "5ae0976be4b0837691e92c43"}, {"problem": 74, "code": "(fn [inp]\n\t (clojure.string/join \",\" \n\t\t (map #(* % %) (filter #(integer? %) \n\t\t \t(map rationalize\n\t\t\t    (map #(Math/sqrt %) \n\t\t\t \t   (map #(Integer/parseInt %) \n\t\t\t \t\t   (clojure.string/split inp #\",\")))))))\n\t)", "user": "5ac04101e4b073f177442737"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [x] (not (nil? (get (into #{} (map #(* % %) (range x))) x))))\n                                 (map #(read-string %)\n                                      (clojure.string/split\n                                        s\n                                        #\",\")))))", "user": "5afcd6d1e4b0cc2b61a3bd17"}, {"problem": 74, "code": "(fn [x]\n (->> (re-seq #\"\\d+\" x)\n      (map read-string)\n      (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n      (map str)\n      (interpose \",\")\n      (apply str)))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 74, "code": "(fn fps [coll]\n  (letfn [(square? [n]\n            (== (Math/sqrt n) (int (Math/sqrt n))))]\n    (->> (clojure.string/split coll #\",\")\n         (map #(Integer/valueOf %))\n         (filter #(square? %))\n         (map #(str %))\n         (interpose \",\")\n         (apply str))))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let [vecs (into [] (map #(Integer. %) (clojure.string/split s #\",\")))\n\t\tperfect? (fn [x] (let [ss (Math/sqrt x)] (== 0 (mod ss (int ss)))))       \n        fil-vec (filter perfect? vecs)]\n    (str (clojure.string/join \",\" fil-vec))))", "user": "599342efe4b0b211ea3aaab0"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(ps [n] (= n (*(int (Math/sqrt n)) (int (Math/sqrt n)))))]\n    (clojure.string/join \",\" (filter #(ps %) (map read-string (clojure.string/split s #\",\"))))))", "user": "583048d9e4b051871117c007"}, {"problem": 74, "code": "(fn [s]\n\t(letfn [(sum-dights [x] (str (apply + (map (comp read-string str) x))))\n\t\t    (digital-sum [x] \n\t\t\t    (if (= 1 (count x))\n\t\t\t        (read-string x)\n\t\t\t        (digital-sum (sum-dights x))))\n\t\t    (perfect-square? [s]\n\t\t    \t(and (re-matches #\"^.*[014569]$\" s)\n\t\t\t         (#{1 4 7 9} (digital-sum s))))]\n\t    (clojure.string/join \",\"\n\t        (filter\n\t    \t    perfect-square?\n\t    \t    (clojure.string/split s #\",\")))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (->> (clojure.string/split s #\",\")\n    (map (partial into []))\n    (map reverse)\n    (map\n      (fn [v]\n        (int (reduce\n          (fn [z h]\n            (+ z (* (Math/pow 10 h) (- (int (nth v h)) 48))))\n          0\n          (range (count v))))))\n    (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n    (interpose \",\")\n    (reduce str)))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map read-string)\n        (filter #(-> % Math/sqrt (rem 1) zero?))\n        (clojure.string/join \",\")))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (clojure.string/join\n    \",\"\n    (filter\n      (fn [n]\n        (if (get\n             ((fn [m]\n               (apply hash-map (apply concat (map #(list (* % %) %) (range (inc m))))))\n              (/ n 2))\n             n)\n          true\n          false))\n      (map\n        read-string\n        (clojure.string/split s #\",\")))))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 74, "code": "(fn perfect-square [ss]\n  (-> ss\n        (clojure.string/split #\",\")\n        (->> (map #(Integer/parseInt %))\n             (filter #(== (Math/pow (int (Math/sqrt %)) 2) %))\n             (clojure.string/join \",\"))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 74, "code": "(fn perfect [string]\n  (->> (clojure.string/split string #\",\")\n      (map #(Integer/parseInt %))\n      (filter #(let [sqrt (Math/sqrt %)]\n                 (->> sqrt\n                     (int)\n                     (- sqrt)\n                     (zero?))))\n      (clojure.string/join \",\")))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 74, "code": "(fn fps[ns]\n  (let [ps (take 10 (map #(* % %) (range)))\n        in (map read-string (re-seq #\"\\d+\" ns))]\n    (clojure.string/join \",\"\n                         (filter identity\n                                 (map #(some #{%} ps) in)))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 74, "code": "(fn [v] (clojure.string/join \",\" (filter (fn [x] (= 0.0 (rem (Math/sqrt (read-string x)) 1))) (clojure.string/split v #\",\"))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 74, "code": "(fn [s]\n (letfn [(perf-sqr? [n]\n          (let [root (Math/sqrt n)]\n           (= root (Math/floor root))))]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter perf-sqr?)\n       (clojure.string/join \",\"))))", "user": "598216d9e4b021a7a535fdf8"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1))\n                              (map #(Integer. %) (re-seq #\"\\d+\" s)))))", "user": "5a9d64c8e4b0d174b936c7eb"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [n]\n                                     (let [check (Math/sqrt n)]\n                                       (= (* check check) (double n)))) (map read-string (clojure.string/split % #\",\"))))", "user": "5b34aba7e4b025bcb146f352"}, {"problem": 74, "code": "(fn [x]\n  (letfn [(parse-int [x] (Integer. x))\n          (ps? [x] (let [root (int (Math/sqrt x))] (= (* root root) x)))]\n    (clojure.string/join \",\" (map str (filter ps? (map parse-int (clojure.string/split x #\",\")))))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 74, "code": "(fn filter-perfect-squares [string]\n  (letfn [(perfect-square? [n]\n            (let [sqrt (Math/sqrt n)]\n              (= 0.0 (- (Math/round sqrt) sqrt))))]\n    (let [nums (map read-string (clojure.string/split string #\",\"))]\n      (apply str (interpose \",\" (filter perfect-square? nums))))))", "user": "5b47874be4b02d533a91bc70"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n       (clojure.string/join \",\")))", "user": "5777c3d6e4b0979f8965164f"}, {"problem": 74, "code": "(fn [s]\n  (->> (read-string (str \"[\" s \"]\"))\n       (filter #{1 4 9 16 25 36})\n       (interpose \",\")\n       (apply str)))", "user": "594bc16be4b07ddc2dafae39"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 74, "code": "(fn filter-squares [string]\n  (let [numbers (map #(Integer/parseInt %) (clojure.string/split string #\",\"))\n        squares (filter #(= (Math/sqrt %) (Math/rint (Math/sqrt %))) numbers)]\n    (clojure.string/join \",\" squares)))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(perfect-square? [n] (reduce #(if %1 %1 (= n (* %2 %2))) false (range 1 (inc (int (/ n 2))))))]\n  (clojure.string/join \",\" (filter #(perfect-square? (read-string %)) (clojure.string/split s #\",\"))))\n)", "user": "5b4ff637e4b02d533a91bce0"}, {"problem": 74, "code": "(fn [s] (->> (map #(Integer. %) (re-seq #\"\\d+\" s))\n       \t\t (map (fn [n] (some #(if (= n (* % %)) n) (range (inc (quot n 2))))))\n       \t\t (remove nil?)\n       \t\t (interpose \",\")\n       \t\t (apply str)))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 74, "code": "(fn [s] (reduce (fn [x y] (str x \",\" y))\n                (filter (fn [x] (some #(= x (* % %)) (range x)))\n                        (map #(Integer/parseInt %) (.split s \",\")))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 74, "code": "(let [isperfect (fn isperfect [x] (= 0.0 (- (Math/sqrt x) (int (Math/sqrt x)))))\n\t  stringsplit (fn stringsplit [in] (clojure.string/split in #\",\"))\n\tintlist (fn intlist [list] (map #(Integer/parseInt %) list))]          \n(fn [instring] (clojure.string/join \",\" (filter isperfect (intlist (stringsplit instring))))))", "user": "5b609f0ae4b0c6492753e708"}, {"problem": 74, "code": "#(clojure.string/join \",\" (for [x (map (fn [x](Integer/valueOf x)) (clojure.string/split % #\",\")) :when ((fn [n] (loop [x n i 1] (if (< 0 x) (recur (- x i) (+ i 2)) (== 0 x)))) x)] x))", "user": "5b5e7953e4b0c6492753e6d9"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer. %))\n         (filter #(= 0.0 (rem (Math/sqrt %) 1)))\n         (clojure.string/join \",\")\n         )\n  )", "user": "5ab1665de4b073f1774425c0"}, {"problem": 74, "code": "(fn ad [zz] (let [ x (map #(Integer/parseInt %) (clojure.string/split zz #\",\"))]\n   ( loop [ a x res \"\" ]\n     (if (empty? a)\n     (apply str (rest res))\n     (if (== 0 (rem (Math/sqrt (first a)) 1))\n       (recur (rest a) (str res \",\" (first a)))\n       (recur (rest a) res)\n                   )\n       )\n       )\n     )\n           )", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %)\n  (map read-string)\n  (filter (fn [x] (== (Math/sqrt x) (int (Math/sqrt x)))))\n  (clojure.string/join \",\"))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n  (filter\n   (fn [x] (and\n            (= (int (Math/sqrt (read-string x)))\n               (int (Math/ceil (Math/sqrt (read-string x))))\n               )\n            (not= \"1\" x))\n     )\n   (clojure.string/split s #\",\")\n   )\n  )\n  )", "user": "5b5e5019e4b0c6492753e6d3"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (->> (clojure.string/split s #\",\")\n       (filter #(let [n (Math/sqrt (Long/parseLong % 10))]\n                  (= 0.0 (rem n 1))))\n       (clojure.string/join \",\")))", "user": "56175cf9e4b06b1bb2182a0f"}, {"problem": 74, "code": "(fn foo [coll]\n  (clojure.string/join \",\" (filter identity \n                                   (for [n (map read-string (clojure.string/split coll #\",\"))]\n                                     (if (= (float n) (* (Math/sqrt n) (Math/sqrt n)))\n                                       (str n)\n                                       nil\n                                       )))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 74, "code": "(fn [x] (apply str ((fn [my-values] \n  (loop [items my-values result []] \n    (if (<= (count items) 1)\n      result\n      (if (= 2 (count items))\n      (conj result (first items) \",\" (second items))\n      (recur (rest items) (conj result (first items) \",\")))))) ((fn [input] \n  (let [vals (clojure.string/split input #\",\")] \n    (loop [result [] data vals] \n      (if (= 0 (count data)) \n        result\n          (if (= (class (.parse (java.text.NumberFormat/getInstance) (str (Math/sqrt (Integer. (first data)))))) java.lang.Long)\n          (recur (conj result (str (first data))) (rest data) )\n          (recur result (rest data) )))))) x))))", "user": "5b7ec218e4b047b03b20375e"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [nums (.split s \",\")]\n    (clojure.string/join\n      \",\"\n      (filter\n        #(let [n (bigint %)\n               sqr (bigint (Math/sqrt n))]\n           (println n sqr)\n           (= (str (* sqr sqr)) %))\n        nums))))", "user": "5779556de4b0979f8965166e"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1)) (read-string (str \"[\" s \"]\")))))", "user": "5b772ad7e4b047b03b2036e8"}, {"problem": 74, "code": "(fn [x]\n  (clojure.string/join \",\" \n                       (filter \n                        (fn [y] (= (mod (Math/sqrt y) 1) 0.0)) \n                        (map read-string (clojure.string/split x #\",\")))))", "user": "5b79cbdce4b047b03b20370a"}, {"problem": 74, "code": "(fn[a](->> (filter #(let[x (Integer/parseInt %)](=(Math/pow (Math/sqrt x ) 2) (Double/parseDouble %))) (.split a \",\"))(interpose \",\")(apply str)))", "user": "5826a843e4b051871117befd"}, {"problem": 74, "code": "(fn [s]\n    (letfn [(perfect-square [n]\n              (let [root (Math/sqrt n)]\n                (= (Math/floor root) root)))]\n      (->> (clojure.string/split s #\",\")\n           (map #(Integer/valueOf %))\n           (filter perfect-square)\n           (interpose \",\")\n           (apply str))))", "user": "5777cffae4b0979f89651651"}, {"problem": 74, "code": "(fn [l i]\n  (->> l\n       (clojure.set/intersection (set (map #(Long/parseLong %)\n                                           (clojure.string/split i #\",\"))))\n       (sort)\n       (clojure.string/join \",\")))\n#{4 9 16 25 36}", "user": "4db1fe241254ad5b4805fa77"}, {"problem": 74, "code": "#(->> (re-seq #\"[0-9]+\" %)\n      (filter (fn [n] (let [m (read-string n) \n                            s (int (Math/sqrt m))]\n                        (= m (* s s)))))\n      (clojure.string/join \",\"))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n    (map read-string)\n    (filter #(= (float %) (Math/pow (Math/sqrt %) 2)))\n    (map str)\n    (clojure.string/join \",\")))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5b88f0c0e4b047b03b203816"}, {"problem": 74, "code": "(fn nums [text]\n  (let [is-square? (fn [x]\n                       (= (Math/sqrt x) (Math/floor (Math/sqrt x))))]\n    (->> (clojure.string/split text #\"[\\W]\")\n         (map read-string ,,,)\n         (filter is-square? ,,,)\n         (clojure.string/join ,,, #\",\")\n         (apply str ,,,))))", "user": "59cd13d5e4b0ef0a1e9b5b32"}, {"problem": 74, "code": "(fn [s]\n  (let [sq #(* % %)]\n    (clojure.string/join \",\" (map str\n                              (filter #(= % (sq (int (Math/sqrt %))))\n                                      (map #(Integer. %) (re-seq #\"\\d+\" s)))))))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (apply str\n         (interpose \\,\n                    (filter #(zero? (- (Math/sqrt %) (int (Math/sqrt %))))\n                            (map (comp read-string str)\n                                 (remove #(= % \\,)\n                                         (clojure.string/split s #\",\" )))))))", "user": "5b1e5bfde4b03cfeda66ed0e"}, {"problem": 74, "code": "(fn [n-str]\n  (->> n-str\n      (re-seq #\"\\d+\")\n      (map #(Integer/parseInt %))\n      (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n      (clojure.string/join \",\")))", "user": "5b77d3c8e4b047b03b2036f1"}, {"problem": 74, "code": "(fn [st]\n   (reduce\n     (fn [out num]\n       (str out \",\" num))\n     (let [in (re-seq #\"[0-9]+\" st)]\n          (filter\n            #(let [num (Integer/parseInt %)\n                   root (int (Math/sqrt num))]\n               (= num (* root root)))\n            in))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [ints (remove clojure.string/blank? (re-seq #\"[^,]*\" s))\n        highest-int (Integer/parseInt (last ints))\n        perfect-squares (map (comp str #(* %1 %1)) (rest (range)))]\n     (clojure.string/join \\, \n       (sort \n         (clojure.set/intersection\n           (set ints)\n           (set (take-while #(>= highest-int (Integer/parseInt %)) perfect-squares)))))))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 74, "code": "#(->> (partition-by (partial = \\,) %)\n      (remove #{'(\\,)})\n      (map (fn [cs] (reduce (fn [n c] (+ (* n 10) (- (int c) (int \\0)))) 0 cs)))\n      (map (fn [n] [n (some (partial = n) (map (fn [x] (* x x)) (cons 1 (range 2 n))))]))\n      (filter second)\n      (map first)\n      (interpose \\,)\n      (apply str))", "user": "4f3ca5a6e4b0e243712b1f53"}, {"problem": 74, "code": "(fn squares\n  ([xs] \n   (let [xns (clojure.string/split xs #\",\")]\n     (squares xns [] 1)))\n  ([xs sqs i]\n   (let [isq (* i i)]\n     (if (seq xs)\n       (if (= (Integer. (first xs)) isq)\n         (recur (rest xs) (conj sqs isq) (+ i 1))\n         (if (> (Integer. (first xs)) isq)\n           (recur xs sqs (+ i 1))\n           (recur (rest xs) sqs i)))\n       (clojure.string/join \",\" sqs)))))", "user": "51000111e4b00d7ad4cab15e"}, {"problem": 74, "code": "; The first seems more lisp-y; the second seems more Clojure-y...\n\n;(fn [s]\n;  (apply str (interpose \",\" (filter #(= % (-> % Math/sqrt int (Math/pow 2) int)) \n;                                    (map read-string (re-seq #\"\\d+\" s))))))\n\n(fn [s]\n  (->> s \n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter #(= % (-> % Math/sqrt int (Math/pow 2) int)))\n       (interpose \",\")\n       (apply str)))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n     (map read-string)\n     (filter #(= (mod (Math/sqrt %) 1) 0.0))\n     (map str)\n     (clojure.string/join \",\")\n  ))", "user": "570d0548e4b0b0fb43fd06d2"}, {"problem": 74, "code": "(fn sqrt\n  [data]\n  (->> (str \"[\" data \"]\")\n       (read-string)\n       (filter (fn [x]\n                 (let [y (int (Math/sqrt x))]\n                   (= x (* y y)))))\n       (clojure.string/join \",\")))", "user": "5b86462de4b047b03b2037df"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (let [xs (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n                         (filter (fn [x] ((set (map #(* % %) (range 2 (quot (last xs) 2)))) x)) xs))))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer. %) (clojure.string/split s #\",\"))\n        squares-up-to-max (map #(* % %)\n                               (range (inc (Math/sqrt (apply max nums)))))]\n    (->> squares-up-to-max\n         (filter (fn [x] (some #(= x %) nums)))\n         (clojure.string/join \",\"))))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 74, "code": "(comp\n      #(clojure.string/join \",\" %)\n      (partial filter #{1 4 9 16 25 36 49})\n      (partial map read-string)\n      #(clojure.string/split % #\",\"))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 74, "code": "#(->> %\n      (re-seq #\"\\d+\")\n      (map read-string)\n      (filter (fn[x](= (float x) (Math/pow (Math/sqrt x) 2))))\n      (clojure.string/join \",\")\n      (str))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 74, "code": "(fn [xs]\n  (let [split-string #(clojure.string/split % #\",\")\n        perfect-square? #(== % (Math/pow (int (Math/sqrt %)) 2))]\n    (->> xs\n         split-string\n         (map read-string)\n         (filter perfect-square?)\n         (map str)\n         (clojure.string/join \",\"))))", "user": "5a544eeee4b05d388ecb6c24"}, {"problem": 74, "code": "#(apply str (interpose \",\" (filter (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x))))  (map read-string (re-seq #\"\\d+\" %)))))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (->> s\n                 (re-seq #\"(\\d+),?\")\n                 (map second)\n                 (map #(Long/parseLong %)))\n        perfect-square? (fn [n]\n                          (== 0 (rem (Math/sqrt n) 1)))]\n    (apply str (interpose \",\" (filter perfect-square? nums)))))", "user": "5829d9f8e4b051871117bf4d"}, {"problem": 74, "code": "(fn b [c](->> c\n            (re-seq #\"[\\d]+\")\n            (map read-string)\n            (filter #(= (float %) (Math/pow (Math/sqrt %) 2)))\n            (map str)\n            (interpose \",\")\n                (apply str)\n            ))", "user": "5b9c4a7be4b0c0b3ffbd4b16"}, {"problem": 74, "code": "(fn [s]\n  (let [sqert (fn [x] (Math/sqrt x))]\n    (->>\n      (clojure.string/split s #\",\")\n      (map read-string)\n      (filter #(zero? (rem (sqert %) 1)))\n      (clojure.string/join \",\")\n      )\n    )\n  )", "user": "5b85221ce4b047b03b2037c8"}, {"problem": 74, "code": "(fn perfect-squares\n  [ints-str]\n  (letfn [(perfect-square? [x]\n            (let [square-root (int (Math/sqrt x))]\n              (= (* square-root square-root) x)))]\n    (let [numbers (map #(Integer/parseInt %)\n                       (clojure.string/split ints-str #\",\"))]\n      (->> numbers\n           (filter perfect-square?)\n           (clojure.string/join \",\")))))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 74, "code": "(fn perfect-squares\n  [int-s]\n  (letfn [(p-s?\n            [n]\n            (let [sqrt\n                  (Math/sqrt n)]\n              (>= 0.0 (rem sqrt (int sqrt)))))]\n\n    (->> (clojure.string/split int-s #\",\")\n         (map (fn [x] (Integer/parseInt x)))\n         (filter p-s?)\n         (interpose \",\")\n         (apply str))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 74, "code": "(fn [x]\n  (let [l (map #(Integer/parseInt %) (re-seq #\"\\w+\" x))\n        r (reverse \n           (reduce #(if (= (- (Math/sqrt %2) (int (Math/sqrt %2))) 0.0) (cons %2 %) %) '() l))]\n    (reduce #(if (nil? %2) % (str % \",\" %2)) r)))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 74, "code": "#(apply str (interpose \\, (filter (fn [x] (= x (last (for [i (range) :let [sq (* i i)] :while (<= sq x)] sq)))) (map read-string (re-seq #\"[0-9]+\" %)))))", "user": "5b7bc82ce4b047b03b203726"}, {"problem": 74, "code": "(fn [s]\n  (let [s (->> s\n               (re-seq #\"\\d+\")\n               (map #(Integer/parseInt %))\n               (filter #(contains? #{0 1 4 5 6 9} (rem % 10))))\n        d (->> s (apply max) (range 0) (map #(* % %)) set)]\n    (->> s\n         (filter #(contains? d %))\n         (interpose \",\")\n         (apply str))))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %)\n      (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"})\n      (clojure.string/join \",\"))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 74, "code": "(fn [x]\n  (clojure.string/join \",\"\n                       (filter #(= 0.0 (mod (Math/sqrt (Integer/parseInt %)) 1)) \n                               (re-seq #\"\\d+\" x))))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 74, "code": "(fn [s]\n   (let [lazy-perfect-squares (fn f\n                                ([] (f 2))\n                                ([n] (cons (* n n) (lazy-seq (f (inc n))))))\n         perfect-squares-set (set (take 5 (lazy-perfect-squares)))\n         found-squares (->> (clojure.string/split s #\",\")\n                            (map read-string)\n                            (map perfect-squares-set)\n                            (filter #(not (nil? %))))\n         result-string (clojure.string/join \",\" found-squares)]\n     result-string))", "user": "5617db88e4b06b1bb2182a16"}, {"problem": 74, "code": "(fn[s](->>(re-seq #\"\\d+\" s)(map #(Long. %))(filter #(let[r(Math/sqrt %)](== %(* r r))))(clojure.string/join \",\")))", "user": "50e5bca5e4b09ae9427b0e75"}, {"problem": 74, "code": "(fn [s]\n    (let [numbers (map #(Long/parseLong %)\n                       (clojure.string/split s #\",\"))\n          perfect? (fn [n]\n                     (== n\n                         (* (Math/sqrt n)\n                            (Math/sqrt n))))\n          squares (filter perfect?\n                          numbers)\n          joined  (clojure.string/join \",\" squares)]\n      joined))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 74, "code": "(fn\n  [s]\n  (->> (clojure.string/split s #\",\")\n       (map (fn [s] (Integer/parseInt s)))\n       (filter (fn [n] (= (float n) (Math/pow (Math/sqrt n) 2.0))))\n       (clojure.string/join \",\")))", "user": "5592ba8be4b0c79f6e1db931"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\" (filter (fn [v] (some #(= v (* % %)) (range 2 (inc (quot v 2)))\n\n                                                          )) (map #(Integer/parseInt %) (re-seq #\"\\d+\" x)))))", "user": "57086931e4b0b0fb43fd069e"}, {"problem": 74, "code": "(fn [x] (apply str (interpose \",\" (filter #(contains? #{4 9 16 25 36} %) (read-string (str \"[\" x \"]\"))))))", "user": "5be0306be4b0ed4b8aab4c7d"}, {"problem": 74, "code": "(fn [s]\n  (loop [s (map read-string (clojure.string/split s #\",\")) o []]\n  (if (empty? s)\n    (clojure.string/join \",\" o)\n    (let [sqrt (int (Math/sqrt (first s)))]\n      (if (= (first s) (int (Math/pow sqrt 2)))\n        (recur (rest s) (conj o (int (Math/pow sqrt 2))))\n        (recur (rest s) o)\n      )\n    )\n  ))\n)", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 74, "code": "(fn [x] (clojure.string/join  \",\"\n(map #(-> % int str)\n(filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %)))\n(map #(float (read-string %)) (clojure.string/split x #\",\"))\n))))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 74, "code": "(fn perf-squares [s]\n  (->> s\n       (re-seq #\"[0-9]+\")\n       (map #(Long/valueOf %) )\n       (filter #(let [r (Math/sqrt %)] (== r (long r))) )\n       (interpose \",\")\n       (apply str)\n       ))", "user": "5be33a16e4b0ed4b8aab4cd6"}, {"problem": 74, "code": "(fn [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer/valueOf %))\n    (filter #(let [root (Math/sqrt %)] (== root (int root))))\n    (map str)\n    (clojure.string/join \",\")\n   ))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 74, "code": "(fn [x]\n    (let [sqrt #(java.lang.Math/floor (java.lang.Math/sqrt %))\n          f    #(== (* (sqrt %) (sqrt %)) %)]\n      \n      (clojure.string/join \",\" (filter f (map #(java.lang.Long/parseLong %) (clojure.string/split x #\",\"))))))", "user": "5bf5ddfde4b0bdcf453d159e"}, {"problem": 74, "code": "(fn square-string [input]\n  (->> (clojure.string/split input #\"\\W+\")\n       (map #(Integer/parseInt %))\n       (filter #(== % (* (Math/sqrt %) (Math/sqrt %))))\n       (map str)\n       (clojure.string/join \",\")))", "user": "5bfa25fbe4b0bdcf453d15c8"}, {"problem": 74, "code": "(fn [coll]\n  (let [perf-list (map #(* % %) (iterate inc 1))\n        perf (fn [m]\n               (let [x (inc (last m))]\n                (set (take-while #(> x %) perf-list))))]\n    (->>\n      (clojure.string/split coll #\",\")\n      (map #(Integer. %))\n      (#(filter (perf %) %))\n      (reduce #(str %1 \",\" %2)))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 74, "code": "(fn [s] \n  (apply str (interpose \",\"\n          (filter #(let [i (Integer/parseInt %) i2 (int (Math/sqrt i))] (= (* i2 i2 ) i)) (re-seq #\"\\d+\" s)))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 74, "code": "(fn\n  [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map read-string)\n    (map int)\n    (filter (fn [x] (let [s (Math/sqrt x)]\n              (= s (Math/floor s)))))\n    (clojure.string/join \",\")))", "user": "55dfac5fe4b050e68259b3f9"}, {"problem": 74, "code": "(fn [data]\n  (let [numbers (map read-string (clojure.string/split data #\",\"))\n        answers (filter #(-> % (Math/sqrt) (mod 1) (zero?)) numbers)]\n    (apply str (interpose \\, answers))))", "user": "5c13da47e4b01240ff5671a6"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 74, "code": "(fn perfect-squares\n  [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    #(== (int (Math/sqrt %)) (Math/sqrt %))\n    (map read-string (clojure.string/split s #\",\")))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 74, "code": "(fn filter-perfect-square\n  [s]\n  (letfn [\n          (squared-range [] (map #(* % %) (range)))\n          (perfect-square? [n] (loop [s (squared-range)]\n              (cond\n                (> (first s) n) false\n                (= (first s) n) true\n                :else (recur (next s))\n                )\n              )\n            )\n          ]\n    (clojure.string/join \",\" (map str (filter perfect-square? (map #(Integer/parseInt %1) (re-seq #\"\\d+\" s)) )))\n    )\n  \n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 74, "code": "(fn [xs] (->> xs\n  (re-seq #\"\\d+\")\n  (map read-string)\n  (filter #(let [r (int (Math/sqrt %))] (= (* r r) %)))\n  (clojure.string/join \",\")))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 74, "code": "#(clojure.string/join \",\" \n                      (filter (fn [s]\n                                (some #{s} \n                                      (map (fn [x] (* x x)) (range s))))\n                              (map read-string (clojure.string/split % #\",\"))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 74, "code": "#(reduce (fn [s n] (str s \\, (str n))) (filter (fn [y] (let [r (Math/sqrt y)] (= r (Math/floor r)))) (map (fn [x] (Integer/parseInt x)) (map (partial apply str) (filter (partial not= '(\\,)) (partition-by (partial = \\,) %))))))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 74, "code": "(fn [numlist](let [numvec (map read-string (clojure.string/split numlist #\",\"))\n                   integer-sqrt #(int (+ 0.49 (Math/sqrt %)))]\n                (clojure.string/join \",\" (filter #(= % (* (integer-sqrt %)(integer-sqrt %)))  numvec))\n              )\n  )", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 74, "code": "(fn me [strnums]\n  (->>\n\t(for [s (clojure.string/split strnums #\",\")\n          :let [n (bigint s)\n                sqr (bigint (Math/sqrt n))]\n          :when (= n (* sqr sqr))]\n          n)\n        (clojure.string/join \",\")))", "user": "5c219c0fe4b07e362c230581"}, {"problem": 74, "code": "(fn [s]\n   (->> (re-seq #\"\\d+\" s) \n        (map read-string)\n        (filter #(= % (int (Math/pow (int (Math/sqrt %)) 2))))\n        (clojure.string/join \",\")))", "user": "54df2609e4b024c67c0cf7a9"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (->> (clojure.string/split s #\",\")\n                  (map #(Integer/parseInt %))\n                  (filter #(let [n (Math/sqrt %)] (= n (Math/floor n)))))]\n  \t(clojure.string/join \",\" nums)))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 74, "code": "(fn [s]\n  (let [digits          (map #(Integer. %) (clojure.string/split s #\",\"))\n        max-digit       (apply max digits)\n        perfect-squares (set (map #(* % %) (range 2 (inc (int (Math/sqrt max-digit))))))\n        check           (fn [digit]\n                          (contains?\n                            perfect-squares\n                            digit))]\n    (clojure.string/join \",\" (filter check digits))))", "user": "571a0a0ae4b07c98581c3b44"}, {"problem": 74, "code": "(fn ps [numbers]\n  (let [numbers (clojure.string/split numbers #\",\")\n        square (fn [n] (* n n))\n        perfect-square? (fn [n] (= n (-> n Math/sqrt int square)))]\n    (apply str (rest (reduce #(if (perfect-square? (-> %2 str Integer/parseInt)) (str %1 \",\" %2) %1) \"\"  numbers)))))", "user": "57d57f65e4b0bd073c2023b3"}, {"problem": 74, "code": "(fn [str]\n  (clojure.string/join \",\"\n                       (filter\n                        #(let [sq (Math/sqrt %)] (= (Math/floor sq) sq))\n                        (map read-string (clojure.string/split str, #\"\\,\")))))", "user": "5c1840eae4b01240ff5671eb"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [n] (let [x (Math/sqrt n)] (= (Math/floor x) x))))\n       (clojure.string/join \",\")\n       ))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 74, "code": "(fn [s]\n  (letfn [\n          (perfect_squares \n            ([] (map #(* % %) (range)))\n            ([max] (take-while #(<= % max) (perfect_squares))))\n          ]\n    (->> (re-seq #\"\\d+\" s)\n        (map #(java.lang.Integer/valueOf %))\n        (filter #(contains? (set (perfect_squares %)) %))\n        (clojure.string/join \",\")\n        )\n    )\n  )", "user": "5c17467fe4b01240ff5671df"}, {"problem": 74, "code": "(fn [n]\n  (let [sqrtf (fn [x] (Math/floor (Math/sqrt x)))\n        square? (fn [x] (= (float x) (* (sqrtf x) (sqrtf x))))]\n    (->> n\n         (re-seq #\"\\d+\")\n         (map #(Integer/parseInt %))\n         (filter square?)\n         (clojure.string/join \",\"))))", "user": "50eeeadae4b02c17778c91f3"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [v] (let [s (-> v Math/sqrt int)] (== (* s s) v))) (map (fn [x] (Integer. x)) (re-seq #\"[0-9]+\" %))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(let [x (Integer/parseInt %)] (let [sqx (int (Math/sqrt x))] (= x (* sqx sqx)))) (re-seq #\"\\d+\" s))))", "user": "5c308385e4b0d62ef62d9f1c"}, {"problem": 74, "code": "(fn [str]\n      (when-let [ints (re-seq #\"\\d+\" str)]\n        (clojure.string/join \",\" (filter #(let [sqrt (Math/round (Math/sqrt %))]\n                                            (= (int (* sqrt sqrt)) %))\n                                         (map #(Integer/parseInt %) ints)))))", "user": "5c3f37fce4b08cd430848e91"}, {"problem": 74, "code": "(fn [ns]\n  (let [numbers (map #(Integer/parseInt %) (clojure.string/split ns #\",\"))\n        maxn (apply max numbers)\n        squares (set (take-while #(<= % maxn)  (reductions + 0 (filter odd? (range)))))\n        sqfound (filter #(get squares %) numbers)]\n    (apply str (interpose \",\" sqfound ))))", "user": "52503747e4b0541d1855b828"}, {"problem": 74, "code": "(fn filter-perfect-squares [str]\n  (->> (clojure.string/split str #\",\")\n       (map read-string)\n       (filter #(=\n                   (Math/floor (Math/sqrt %1))\n                   (Math/sqrt %1)))\n       (clojure.string/join \",\")))", "user": "5984e7dee4b021a7a535fe43"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/valueOf %))\n       (filter #(= % (-> % Math/sqrt Math/floor (Math/pow 2) int)))\n       (interpose \",\")\n       (apply str)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 74, "code": "(fn [s]\n    (letfn [(p-s? [n]\n              (let [r (Math/sqrt n)]\n                (== r (int r))))]\n      (->> (clojure.string/split s #\",\")\n           (map read-string)\n           (filter p-s?)\n           (clojure.string/join #\",\"))))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 74, "code": "#(let [ns (map read-string (clojure.string/split % #\",\"))\n       decompose (fn [n]\n                  (loop [fs [1], d 2, n n] ; factors, divisor, number\n                   (cond \n                    (= n 1) fs\n                    (zero? (mod n d)) (recur (conj fs d) d (quot n d))\n                    :else (recur fs (inc d) n))))\n       is_perfect (fn [n] \n                   (every? even? (for [[k,v] (group-by identity (rest (decompose n)))]\n                                  (count v))))]\n  (apply str (interpose \",\" (filter is_perfect ns))))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 74, "code": "(fn [s] \n   (->> (seq s)\n        (partition-by #(= \\, %))\n        (filter #(not= '(\\,) %))\n        (map #(apply str %))\n        (map read-string)\n        (filter #(let [root (int (Math/sqrt %))] (= % (* root root))))\n        (clojure.string/join \",\")))", "user": "5c435a9fe4b0e06e1360a367"}, {"problem": 74, "code": "(fn [x] (let [a (map #(Integer/parseInt %) (clojure.string/split x #\",\"))]\n(reduce #(str %1 \",\" %2) (filter #(== 0 (- (Math/sqrt %) (int (Math/sqrt %)))) a))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 74, "code": "(fn [lst]\n   (clojure.string/join \",\"\n                        (filter #(= (* (int (Math/sqrt %)) (int (Math/sqrt %))) %)\n                                (map #(Integer/parseInt %)\n                                     (re-seq #\"\\d+\" lst)))))", "user": "5c62979fe4b0fca0c162264c"}, {"problem": 74, "code": "(fn [s]\n               (let [ns   (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n                     stab (set (map #(* % %) (range 1 10)))]\n                 (clojure.string/join \",\" (filter stab ns))))", "user": "4e617114535d8ccf87e9fe5b"}, {"problem": 74, "code": "(fn [nums]\n  (->> \n   (clojure.string/split nums #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(= 0.0 (- (Math/sqrt %) (Math/floor (Math/sqrt %)))))\n   (clojure.string/join \",\")))", "user": "5c6da283e4b0fca0c162273e"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= % (* (int (Math/sqrt %))\n                        (int (Math/sqrt %)))))\n       (clojure.string/join \",\")))", "user": "58b12635e4b0ebc645576cf4"}, {"problem": 74, "code": "(fn filter-perfect-squares\n  [strseq]\n  (let [array (clojure.string/split strseq #\",\")\n        isSquare? (fn [x] (let [re (Math/sqrt (Integer/parseInt x))] (= (Math/floor re) re)))]\n    (clojure.string/join \",\" (filter #(isSquare? %) array))))", "user": "59b9e669e4b0a024fb6ae3db"}, {"problem": 74, "code": "(fn fps [s]\n  (->> (clojure.string/split s #\",\")\n      (map read-string)\n      (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n      (map str)\n      (clojure.string/join \",\")))", "user": "5b14475be4b0cc2b61a3be5a"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (->> s (re-seq #\"\\d+\") (map #(Integer/parseInt %)))\n        ys (reduce (fn [c x] (if (some #(= (/ x %) %) (range 1 (inc x))) (conj c x) c)) [] xs)]\n    (apply str (interpose \",\" ys))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map #(Integer. %))\n        (filter #(= 0.0 (rem % (Math/sqrt %))))\n        (clojure.string/join \",\")))", "user": "5a64dcabe4b0512ff01cd9a9"}, {"problem": 74, "code": "(fn  [x] (apply str (interpose \",\" (let [y (fn [a] (Math/sqrt (read-string a)))]\n                              (keep #(if (== (y %) (int (y %)))\n                                       %)\n                                    (re-seq #\"\\d+\" x))))))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 74, "code": "(fn [s]\n  (loop [[r & more :as all] (clojure.string/split s #\",\")\n         acc '()]\n    (if all\n      (let [r-as-dig (Integer/parseInt r 10)\n            perfect-square? #(== (Math/sqrt %) (int (Math/sqrt %)))]\n        (if (perfect-square? r-as-dig)\n          (recur more (conj acc r-as-dig))\n          (recur more acc)))\n      (clojure.string/join \",\" (reverse acc)))))", "user": "5c718e6ce4b0fca0c1622796"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter\n    (fn[x](== (Math/sqrt x) (int(Math/sqrt x))))\n    (map read-string(clojure.string/split % #\",\"))\n    ))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [x] (== x (Math/pow (Math/sqrt x) 2))) (map read-string (clojure.string/split % #\",\"))))", "user": "5c664b87e4b0fca0c16226a5"}, {"problem": 74, "code": "(fn [s]\n          (->> s\n               (re-seq #\"\\d+\")\n               (map #(Integer/parseInt %))\n               (filter #(zero? (mod (Math/sqrt %) 1)))\n               (reduce #(str %1 \",\" %2))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map read-string)\n        (filter #(== (Math/sqrt %) (int (Math/sqrt %))))\n        (clojure.string/join \",\")))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 74, "code": "(fn [s]\n    (->> s\n        (#(str \"[\" % \"]\"))\n        read-string\n        (filter (fn [x] (= x (-> x Math/sqrt int (#(* % %))))))\n        (map str)\n        (interpose \",\")\n        (apply str)))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 74, "code": "(fn [str]\n  (let [perfect-square? (fn [n]\n                          (let [f (Math/sqrt n)]\n                            (zero? (- f (int f)))))\n        str->vec (fn [s]\n                   (map #(Integer/parseInt %) (clojure.string/split s #\",\")))]\n    (clojure.string/join \",\" (filter #(perfect-square? %) (str->vec str)))))", "user": "5c558070e4b0fb8c5ffd9a1e"}, {"problem": 74, "code": ";; http://www.4clojure.com/problem/74\n(fn filter-squares\n  [coll]\n  (clojure.string/join \",\"\n                       (map str\n                            (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %))))\n                                    (map #(Integer/parseInt %) (clojure.string/split coll #\",\"))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let [ss (re-seq #\"[^,]+\" s)]\n    (->> ss\n         (map #(Integer/parseInt %))\n         (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n         (map #(Integer/toString %))\n         (interpose \",\")\n         (apply str))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 74, "code": "(fn problem74 [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= % (let [x (int (Math/sqrt %))] (* x x))))\n       (interpose \",\")\n       (apply str)))", "user": "5cab33e7e4b048ec896c5c48"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is-prsq? [x] (= (int (Math/pow (Math/round (Math/sqrt x)) 2)) x))]\n    (clojure.string/join \",\" (map str\n     (filter is-prsq?\n      (map read-string \n       (re-seq #\"[0-9]+\" s)\n      )\n     )\n    ))\n  )\n)", "user": "543bb568e4b032a45b869334"}, {"problem": 74, "code": "(fn perfect-squares [s]\n\t(let [coll (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n\t\t(apply str (interpose \",\" (map #(str %) (filter #(= (* (Math/sqrt %) (Math/sqrt %)) (float %)) coll))))))", "user": "593c1e3be4b069cdc2982b86"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(integer? (rationalize (Math/sqrt (Integer/parseInt %1)))) (clojure.string/split s #\"\\,\"))))", "user": "5cb71f35e4b026601754b961"}, {"problem": 74, "code": "#(clojure.string/join \",\" (filter (fn [n] (= 0.0 (rem (Math/sqrt n) 1))) (map (fn [n] (Integer/parseInt n))  (clojure.string/split % #\",\"))))", "user": "50a4f36be4b0344e360f3bc9"}, {"problem": 74, "code": "(fn[s] (apply str (interpose \",\" (map str (filter #(let [s (int (Math/sqrt %))] (= (* s s) %)) (map #(Integer/valueOf (apply str %)) (filter #(not (= % '(\\,))) (partition-by #(= % \\,) (chars (char-array s))))))))))", "user": "4f148418535d64f60314643a"}, {"problem": 74, "code": "(fn [s] (->> s\n  (re-seq #\"[^,]+\")\n  (map #(Integer/valueOf %))\n  (filter #(let [root (Math/sqrt %)] (== root (int root))))\n  (clojure.string/join \",\")))", "user": "5ca622f3e4b048ec896c5be0"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5cbeadf2e4b0ccb061962755"}, {"problem": 74, "code": "(fn [s] (clojure.string/join\n         \",\"\n         (filter #(= (Math/sqrt %) (Math/ceil (Math/sqrt %))) (map read-string (clojure.string/split s, #\",\")))))", "user": "5ccb3792e4b0ccb061962882"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [squares (->> (clojure.string/split s #\",\")\n                     (map #(Integer. %))\n                     (filter #(= (Math/sqrt %) (Math/ceil (Math/sqrt %))))\n                     (map str))]\n    (clojure.string/join \",\" squares)))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [x] (= (int (Math/pow (int (Math/sqrt x)) 2)) x))]\n    (clojure.string/join \",\" (filter perfect-square? (map #(Integer. %) (re-seq #\"[0-9]+\" s))))))", "user": "4fbe2cfbe4b081705acca30c"}, {"problem": 74, "code": "(fn [s]\n  (->> (read-string (str \\[ s \\]))\n       (filter #(let [r (Math/sqrt %)] (== r (int r))))\n       (interpose \\,)\n       (apply str)))", "user": "5ccf21c4e4b0ccb0619628c1"}, {"problem": 74, "code": "(fn [xs]\n   (->> xs\n        (reduce (fn [result input]\n                  (if (= \\, input) (conj result [])\n                      (conj (vec (butlast result))\n                            (conj (last result) input)))) [])\n        (map #(->> % (apply str) Integer/parseInt))\n        (filter (fn [x]\n                  (loop [i 1]\n                    (cond\n                     (= (* i i) x) x\n                     (> i (/ x 2)) nil\n                     :else (recur (inc i))))))\n        (mapcat #(list % \\,))\n        butlast\n        (apply str)))", "user": "5cbb0436e4b026601754b9cc"}, {"problem": 74, "code": "(fn [text]\n  (->> text\n       (re-seq #\"\\d+\")\n       (map #(Integer. %))\n       (filter #(== % (* (Math/floor (Math/sqrt %)) (Math/floor (Math/sqrt %)))))\n       (interleave (repeat \",\"))\n       rest\n       (apply str)))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\")\n      (map read-string)\n      (filter\n        (fn [n]\n          (let [n2 (Math/sqrt n)]\n            (= n2 (Math/floor n2)))))\n      (clojure.string/join \",\"))", "user": "5cdfe2aee4b0a17bb84e2b04"}, {"problem": 74, "code": "(fn [coll]\n    (->> (clojure.string/split coll #\",\")\n         (filter #(let [s (Math/sqrt (read-string %))] (== (int s) s)))\n         (clojure.string/join \",\" )))", "user": "5a9bfd57e4b0d174b936c7d0"}, {"problem": 74, "code": "(fn [num-str]\n   (clojure.string/join \",\" (filter #(let [root (Math/sqrt %)]\n                                       (== root (int root)))\n                                    (map #(Integer/parseInt %) (clojure.string/split num-str #\",\")))))", "user": "5cd639b4e4b0ccb061962940"}, {"problem": 74, "code": "(fn fps [s]\n  (clojure.string/join \",\" \n    (filter #(let [x (read-string %), y (int (Math/sqrt x))] (= (* y y) x)) \n            (re-seq #\"\\d+\" s))))", "user": "5cb4e764e4b026601754b929"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\" (map #(.toString %) (filter (fn [x]\n                                  (let [sroot (Math/sqrt x)\n                                        rounded-sroot (Math/round sroot)]\n                                    (if (= 0.0 (- sroot rounded-sroot))\n                                      true\n                                      false\n                                      )\n                                    )\n                                  ) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))\n   )", "user": "5cdd7157e4b05ee0cb31175b"}, {"problem": 74, "code": "(fn\n   [s]\n   (clojure.string/join\n     \",\"\n     (filter (fn\n               [x]\n               (let\n                 [n (Math/sqrt (Integer/parseInt x))]\n                 (zero? (- n (int n))))) (.split s \",\"))))", "user": "5ce62d8ee4b0a17bb84e2b83"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %)\n       (map (fn [n] (Integer/parseInt n)))\n       (filter (fn [n]\n                 (== n (Math/pow (Math/sqrt n) 2))))\n       (clojure.string/join \",\"))", "user": "5cee521ce4b0aaa82f1129dd"}, {"problem": 74, "code": "(fn [st]\n   (->> (clojure.string/split st #\",\")\n        (map (fn [x] (Integer/parseInt x)))\n        (filter (fn [x] (= (let [raiz (int (Math/sqrt x))]\n                           (* raiz raiz)) x)))\n        (clojure.string/join \",\")))", "user": "58472aade4b089d5ab817ea0"}, {"problem": 74, "code": "(fn [s] (let [nums (clojure.string/split s #\",\")\n                 perfect? (fn [num] (= (Math/sqrt num) (Math/floor (Math/sqrt num))))\n                 ]\n\n             (clojure.string/join \",\" (filter #(perfect? (read-string %)) nums))\n\n             )\n  )", "user": "5baaae06e4b0a20761a23464"}, {"problem": 74, "code": "(fn perfect-sq?\n  [s]\n  (clojure.string/join \",\"(filter \n     (fn [x] \n          (let [sqrt (Math/sqrt x)] \n             (= sqrt (double (int sqrt)))))\n     (map read-string (clojure.string/split s #\",\")))))", "user": "5ce6f93be4b0a17bb84e2b99"}, {"problem": 74, "code": "(fn [x]\n(apply str \n (interpose \\,\n  (filter #(max %)\n   (map (fn [n] (if (some #(= n (* % %)) (range 1 n)) n)) \n     (map #(Integer/parseInt %) (clojure.string/split  x #\",\")))))))", "user": "5b9ae606e4b0c0b3ffbd4af2"}, {"problem": 74, "code": "(fn [x] \n  (clojure.string/join \",\" \n                       (map str \n                            (filter \n                             #(= (double %) (Math/pow (Math/sqrt %) 2)) \n                             (map #(Integer/valueOf %) (clojure.string/split x #\",\"))))))", "user": "5b100648e4b0cc2b61a3be17"}, {"problem": 74, "code": "(fn perfect\n  [a]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split a #\",\"))]\n    (apply str (interpose \",\" (filter number? (for [i nums]\n                                                (if (= (mod (Math/sqrt i) 1) 0.0)\n                                                  i)))))\n    )\n  )", "user": "5cd4e1b2e4b0ccb061962927"}, {"problem": 74, "code": "(fn [s] \n  (->>\n   (partition-by #(= \\, %) s)\n   (remove #(= '(\\,) %))\n   (map #(Integer/parseInt (apply str %)))\n   (filter #(let [n (Math/sqrt %)] (== n (int n))))\n   (interpose \\,)\n   (apply str)))", "user": "51dd5d6fe4b0c33a4e1da406"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(let [i (Integer/parseInt %) sqrt (-> i Math/sqrt int)] (= (* sqrt sqrt) i)) (clojure.string/split s #\",\"))))", "user": "5a5894d9e4b05d388ecb6c81"}, {"problem": 74, "code": "(fn\n  [str-coll]\n  (->> (clojure.string/split str-coll #\",\")\n      (map #(Integer. %))\n      (filter #(let [sqrt (Math/sqrt %)] (== sqrt (int sqrt))))\n      (clojure.string/join \",\")))", "user": "5cdc17d0e4b05ee0cb31173c"}, {"problem": 74, "code": "(fn [s]\n            (clojure.string/join\n              \",\"\n              (filter\n                (fn [n]\n                  (> (count (filter #(= n (* % %)) (range n))) 0))\n                (map read-string (clojure.string/split s #\",\"))))\n            )", "user": "5d05fdece4b0cc9c915881e8"}, {"problem": 74, "code": "#(->>\n  %\n  (re-seq #\"\\d+\")\n  (map read-string)\n  (filter (fn [n] (not-empty (for [x (range) :let [y (* x x)] :while (<= y n) :when (= y n)] 1))))\n  (clojure.string/join \",\")\n )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 74, "code": "(fn [x]\n  (->> (clojure.string/split x #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= (Math/floor (Math/sqrt %)) (Math/sqrt %)))\n       (clojure.string/join \",\")))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\" (filter #(== (Math/sqrt %) (int (Math/sqrt %))) (map read-string (clojure.string/split x #\",\")))))", "user": "5cfee28de4b0cc9c91588185"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter (fn [x] (= (Math/sqrt x) (float (int (Math/sqrt x))))) (read-string (apply str (concat \"(\" s \")\"))))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 74, "code": "(fn [in](let [xs (map #(Integer/parseInt %) (clojure.string/split in #\",\"))\n                     filtered (filter #(integer? (rationalize (Math/sqrt %))) xs)](clojure.string/join \",\" filtered)) )", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 74, "code": "(fn [str]\n  (->> (clojure.string/split str #\",\")\n       (filter (fn [s]\n                 (let [n    (read-string s)\n                       sqrt (Math/sqrt n)]\n                   (= (mod sqrt 1) 0.0))))\n\n       (clojure.string/join \",\")))", "user": "570c8ac3e4b0b0fb43fd06ca"}, {"problem": 74, "code": "(fn filter-perfect-squares [s]\n  (let [perfect-squares (fn [n] (map #(* % %) (range n)))]\n    (->> s\n         (re-seq #\"\\d+\")\n         (map read-string)\n         (filter #(some #{%} (perfect-squares %)))\n         (clojure.string/join \",\"))))", "user": "5cdc08a2e4b05ee0cb31173a"}, {"problem": 74, "code": "(fn [x]\n\t(reduce #(str %1 \",\" %2)\n\t\t(filter #(let [r (Math/sqrt %)] (= r (Math/floor r)))\n\t\t\t(map #(Integer/parseInt %) (re-seq #\"\\d+\" x))\n    \t)\n\t)\n)", "user": "5d2201b8e4b02ea6f0fb69ed"}, {"problem": 74, "code": "(fn\n  [s]\n  (let [perfect-square? (fn [n] (let [sqrt (Math/sqrt n)] (= sqrt (Math/floor sqrt))))\n        fl (filter perfect-square? (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n        commainserted (apply str (map #(str %1 %2) (repeat \",\") fl))]\n    (apply str (rest commainserted))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 74, "code": "(fn [string] (loop [str-coll (clojure.string/split string #\",\"), res \"\"]\n                                       (if (empty? str-coll)\n                                         (subs res 1)\n                                         (recur (rest str-coll) ((fn [x] (loop [i 0]\n                                                                           (if (> (* i i) x)\n                                                                             res\n                                                                             (if (= (* i i) x)\n                                                                               (str res \",\" x)\n                                                                               (recur (inc i))\n                                                                               )\n                                                                             )\n                                                                           )\n                                                                   ) (Integer/parseInt (first str-coll))\n                                                                 )\n                                                )\n                                         )\n                                       )\n                          )", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (map #(Integer/parseInt % 10))\n             (filter #(let [x (Math/sqrt %) y (int x) z (* y y)] (= % z)))\n             (clojure.string/join \\,)))", "user": "5d272077e4b092dab7f59c64"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(integer? (rationalize (Math/sqrt (Integer/parseInt %1)))) (clojure.string/split s #\"\\,\"))))", "user": "5d29d837e4b01671435dbc6c"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %)\n         (map (fn [sn] (let [x (read-string sn) xs (range 1 (inc (/ x 2)))] (if (some (fn [e] (= x (* e e))) xs) x 0))))\n         (filter (fn [x] (not (zero? x))))\n         (interpose \",\")\n         (apply str))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 74, "code": "(fn foo\n  [string]\n  (->> (clojure.string/split string #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= (mod (Math/sqrt %) 1) 0.0))\n       (map str)\n       (clojure.string/join \",\")))", "user": "5d1c14cde4b02ea6f0fb698a"}, {"problem": 74, "code": "(fn [st]\n  (->> (map #(Integer/parseInt %) (clojure.string/split st #\",\"))\n       (filter\n        (fn [num]\n          (let [root (Math/sqrt num)]\n            (= 0.0 (- (int root) root)))))\n       (clojure.string/join \",\")))", "user": "5d25abc9e4b02ea6f0fb6a37"}, {"problem": 74, "code": "(fn f [s]\n  (let [nums (map #(Integer/parseInt %)\n                  (clojure.string/split s #\",\"))\n        sqrs (filter #(let [r (Math/sqrt %)]\n                        (= (Math/floor r) r))\n                     nums)]\n    (clojure.string/join \",\" sqrs)))", "user": "5012da69e4b0c8732600222d"}, {"problem": 74, "code": "(fn [str]\n   (let [perf? (fn [x]\n                 (let [sqrt-x (-> x Math/sqrt int)]\n                   (= x (* sqrt-x sqrt-x))))\n         nums (-> str\n                  (clojure.string/split #\",\")\n                  (#(map read-string %))\n                  )\n         perfs (filter perf? nums)]\n     (clojure.string/join \",\" perfs)))", "user": "518279abe4b0353c468deb65"}, {"problem": 74, "code": "(fn [l]\n  (let [splitter (fn [l] (map #(Integer. %) (.split l \",\")))\n        joiner (fn [l] (apply str (butlast (for [v (into [] (for [c l] [c \\,])) e v] e))))]\n    (joiner (filter (fn [i] (some (fn [cand] (= i (* cand cand))) (range i))) \n                    (splitter l)))))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(zero? (rem (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "5d27da09e4b092dab7f59c75"}, {"problem": 74, "code": "#(clojure.string/join\n      \",\"\n      (filter (fn [s] (let [x (Integer/parseInt s)]\n                       (= (-> x Math/sqrt Math/floor (Math/pow 2) int) x)))\n              (clojure.string/split % #\",\")))", "user": "576e607ae4b0979f89651579"}, {"problem": 74, "code": "(fn [number-string]\n    (let [split-numbers (map read-string (clojure.string/split number-string #\",\"))\n          is-perfect-square? (fn [x]\n                               (let [root (Math/sqrt x)]\n                                 (= (Math/floor root) root)))\n          perfects (filter #(is-perfect-square? %) split-numbers)]\n      (apply str (interpose \",\" (map str perfects)))))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 74, "code": "(fn [S]\n    (reduce #(str %1 \",\" %2)\n      (filter\n        (fn [NN] \n          (let\n            [N (Math/sqrt NN)]\n            (= (* 1.0 NN) (* N (int N)))\n          )\n        )\n        (map \n          read-string\n          (clojure.string/split S #\",\")\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(zero? (rem (Math/sqrt %) 1)))\n       (interpose \",\")\n       (apply str)))", "user": "55810c73e4b05c286339e0f2"}, {"problem": 74, "code": "(fn [s]\n      (->> s\n           (re-seq #\"\\d+\")\n           (map read-string)\n           (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n           (clojure.string/join \",\")))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 74, "code": "(fn [coll]\n   (let [is-perfect-square? (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x))))\n         parse-int (fn [s](Integer. (re-find  #\"\\d+\" s )))]\n     (->>\n       (clojure.string/split coll #\",\")\n       (map parse-int)\n       (filter is-perfect-square?)\n       (clojure.string/join \",\"))))", "user": "5d1a1082e4b0902706380e0e"}, {"problem": 74, "code": "(fn\n  [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/valueOf %))\n       (filter (fn [x] (some #(= x (* % %)) (range 1 x))))\n       (clojure.string/join \",\")))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 74, "code": "(fn [st]\n  (let [perfect-square? (fn [n]\n                          (let [root (Math/sqrt n)]\n                            (= root (double (int root)))))]\n    (clojure.string/join \",\" (filter\n                               perfect-square?\n                               (map read-string (clojure.string/split st #\",\"))))))", "user": "5d48e6d3e4b0776584bd6f15"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5c3440fee4b0d62ef62d9f50"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(let [r (Math/sqrt %)] (== r (int r))) (map read-string (clojure.string/split s #\",\")))))", "user": "5259451ce4b0cb4875a45cd7"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1))\n                                          (map #(Integer. %) (re-seq #\"\\d+\" s)))))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 74, "code": "(fn [num-seq]\n  (letfn [(perfect-squares? [s]\n            (let [n-sqrt (Math/sqrt (Integer/valueOf s))]\n              (= (double 0) (double (- n-sqrt (Math/floor n-sqrt))))))]\n    (apply str\n      (interpose \",\" (filter perfect-squares? (re-seq #\"\\d+\" num-seq))))))", "user": "5ccf99fbe4b0ccb0619628c8"}, {"problem": 74, "code": "(fn [delimited-string]\n  (let [perf-squares (set (map #(* % %) (range 10)))]\n    (clojure.string/join \",\"\n  (filter #(perf-squares %)\n  (map #(Integer. %)\n  (clojure.string/split delimited-string #\",\"))))))", "user": "5d4f21f3e4b0776584bd6f4e"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter (fn [x] (first (filter #(= % x) (map #(* % %) (range x))))))\n       (clojure.string/join \",\")))", "user": "5bb25684e4b0a20761a2350d"}, {"problem": 74, "code": "(fn filter-perfect-squares [xstr]\n  (let [xcoll (map\n                #(Integer.\n                   (re-find #\"\\d+\" %))\n                (clojure.string/split xstr #\",\"))\n\n        result (for [x xcoll\n                     :let [y (int (Math/sqrt x))]\n                     :when (= x (int (Math/pow y 2)))]\n                 x)]\n    (clojure.string/join \",\" result)))", "user": "5ad76df9e4b0ea6055cfac18"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 74, "code": "(fn [string]\n  (apply str (rest (reduce (fn [new-string item]\n                             (str new-string \",\" item))\n                           \"\"\n                           (filter\n                             #(= (int (Math/pow (int (Math/sqrt %)) 2)) %)\n                             (map read-string (clojure.string/split string #\",\")))))))", "user": "5d6633bde4b0db5d338d15e2"}, {"problem": 74, "code": "(fn [ls]\n  (letfn [(get-nums [ls] (map #(Integer/parseInt %) (clojure.string/split ls #\",\")))\n          (is-perfect [x] (let [rt (Math/sqrt x)] (= (-> rt int float) rt)))\n          (to-string [ls] (->> ls (map str) (reduce (fn [acc x] (str acc \",\" x)))))]\n    (->> ls (get-nums) (filter is-perfect) (to-string))))", "user": "5d672bd7e4b0db5d338d15f1"}, {"problem": 74, "code": "(fn [x] (apply str (interpose \",\" (filter #(let [n (read-string %)] (= 0 (compare (* (Math/sqrt n) (Math/sqrt n)) n))) (clojure.string/split x #\",\")))))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(let [x (int (Math/sqrt %))] (= (* x x) %)))\n       (clojure.string/join \",\")))", "user": "54236ce1e4b01498b1a71ad1"}, {"problem": 74, "code": "(fn fps\n  [s]\n  (->>\n    (clojure.string/split s #\",\")\n    (map #(Integer/parseInt %))\n    (filter #(let [sqrt (Math/sqrt %)] (== sqrt (long sqrt))))\n    (clojure.string/join \",\")))", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 74, "code": "(fn squares\n  [s]\n  (clojure.string/join \",\" (filter\n                             (fn [x] (= 0.0 (mod x (Math/sqrt x))))\n                             (map (fn [x] (Integer. x)) (clojure.string/split s #\",\"))\n                             ))\n  )", "user": "5d5950c1e4b02ba5928a6827"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  ;; parse\n  ;; (trace \"PERFECT-SQUARES\")\n  (let [split-string (clojure.string/split s #\",\")\n        perfect-squares-list (reduce\n                         (fn [acc s]\n                           (let [parsed-int (Integer/parseInt s)\n                                 root (Math/sqrt parsed-int)\n                                 int-conversion (int root)\n                                 is-perfect-square? (= (/ root int-conversion) 1.0)]\n                             ;; (debug \"Split-string: \" s)\n                             ;; (debug \"Root:\" root)\n                             ;; (debug \"Float?:\" (float? root))\n                             ;; (debug \"Int conversion: \" int-conversion)\n                             ;; (debug \"Is perfect square? \" is-perfect-square?)\n                             (cond is-perfect-square? (conj acc s)\n                                   :else acc)\n                             )) [] split-string)]\n    ;; perfect-squares-list\n    (clojure.string/join \",\" perfect-squares-list)\n    ))", "user": "5d631376e4b0c9e5857d5023"}, {"problem": 74, "code": "(fn [m]\n\t(let [b (re-seq #\"\\d+\" m)]\n\t\t(if (not (odd? (count b)))\n\t\t\t(clojure.string/join \",\" [ (first b) (last b)])\n\t\t\t(clojure.string/join \",\" (rest (pop (vec b))))\n\t\t\t)\n\t\t)\n\t)", "user": "5ca2ca9fe4b048ec896c5b9c"}, {"problem": 74, "code": "(fn [c] (apply str (interpose \",\" (map str\n                                        (filter (fn [y] (loop [sq (map (fn [x] (* x x)) (range))]\n                                                          (cond\n                                                            (> (first sq) y) false\n                                                            (= (first sq) y) true\n                                                            :else (recur (rest sq))))) (map read-string (clojure.string/split c #\",\")))))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 74, "code": "(fn filter-sq[s]\n  (clojure.string/join\n    \",\"\n    (filter\n      #(some (partial = (Integer/parseInt %)) [4 9 16 25 36])\n      (clojure.string/split s #\",\"))))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 74, "code": "(fn [xs] (clojure.string/join \",\" (filter (fn [x]\n                      (let [number (Integer/parseInt x) \n                            root (int (Math/sqrt number))]\n                        (= (* root root) number)))\n                    (clojure.string/split xs #\",\"))))", "user": "5c38422ae4b0d62ef62d9f7f"}, {"problem": 74, "code": "(fn squares [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (filter #(let [r (Math/sqrt %)] (== % (* r r))))\n       (map str)\n       (clojure.string/join \",\")))", "user": "5d45749be4b07c84aa5ae6a2"}, {"problem": 74, "code": "(fn [s]\n  (->> #\",\"\n       (clojure.string/split s)\n     \t(map #(Integer/parseInt %))\n     \t(filter (fn [x]\n                  (= x (->> x\n                            (#(Math/sqrt %))\n                         \t(int)\n                         \t(#(* % %))))))\n       (interpose \",\")\n       (apply str)))", "user": "5d2e5065e4b01671435dbcae"}, {"problem": 74, "code": "(fn filter-perfect-square [s]\n  (->> s\n       vec \n       (partition-by #{\\,})\n       (map #(apply str %))\n       (remove #{\",\"})\n       (map #(Integer/parseInt %))\n       (filter (fn [n]\n                 (let [root (Math/pow n 0.5)]\n                   (= root (-> root int double)))))\n       (map str)\n       (interpose \",\")\n       (apply str)))", "user": "5a062e07e4b01bb0ae8afdc5"}, {"problem": 74, "code": "(fn [str]\n   (clojure.string/join \",\"\n                        (filter\n                         #(==\n                           (Math/sqrt (read-string %))\n                           (int (Math/sqrt (read-string %))))\n                         ((fn read [param]\n                            (clojure.string/split param #\",\")) str))))", "user": "5d5c6675e4b09db18d4482ec"}, {"problem": 74, "code": "(fn [s]\n  (-> s\n      (clojure.string/split #\",\")\n      ((fn [s]\n           (filter (fn [n-s]\n\n                     (let [n (Integer/parseInt n-s)]\n                       (some true? (for [x (range (+ 1 (quot n 2)))]\n                                     (= n (* x x)))))) s )))\n      ((fn [s]\n         (map str s)))\n      ((fn [s]\n         (clojure.string/join  \",\" s)))\n      ))", "user": "5cbd5b42e4b026601754b9f6"}, {"problem": 74, "code": "(fn [s]\n   (letfn [(perfect-square? [x]\n             (= x (reduce * (repeat 2 (int (Math/sqrt x))))))]\n     (->> s\n          (#(clojure.string/split % #\",\"))\n          (map #(Integer. %))\n          (filter perfect-square?)\n          (clojure.string/join \",\"))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 74, "code": "(fn [s]\n  (let [squares (map #(* % %) (range))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Long/parseLong %))\n         (filter #(= % (first (drop-while (partial > %) squares))))\n         (clojure.string/join \",\"))))", "user": "53c74cfce4b00fb29b2212a7"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter #(let [root (Math/sqrt %)] (== root (int root))))\n       (clojure.string/join \",\")))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\" (map str (filter #(= (float (int (Math/sqrt %))) (Math/sqrt %)) (map read-string (clojure.string/split x #\",\"))))))", "user": "5d7158f3e4b04d129b00f2e1"}, {"problem": 74, "code": "(fn filter-ps [x]\n  (let [sqrt (fn [n]\n                 (first (filter #(= (* % %) n) (range (inc (/ n 2))))))]\n  (reduce #(str %2 \",\" %) (reverse (filter #(sqrt (Integer/parseInt %)) (clojure.string/split  x #\",\"))))))", "user": "5c547cf0e4b0fb8c5ffd9a0b"}, {"problem": 74, "code": "(fn my-fn [s]\n\t(let [digits (->> (clojure.string/split s #\",\")\n                    (map #(Integer/parseInt %)))\n        max-digit (inc (apply max digits))\n        rng (take-while #(< (* % %) max-digit) (range))\n        squares (set (map #(* % %) rng))]\n    (clojure.string/join \",\" (map str (filter squares digits)))))", "user": "5c896f46e4b048ec896c5940"}, {"problem": 74, "code": "(fn [x]\n  (->> (clojure.string/split x #\",\")\n       (map #(Integer. %))\n       (filter #(= (-> % Math/sqrt int (Math/pow 2) int) %))\n       (clojure.string/join \",\")))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 74, "code": "(fn [coll]\n  (let [perfect-square? (fn [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))]\n    (->>\n     (clojure.string/split coll #\",\")\n     (map #(Integer/parseInt %))\n     (filter perfect-square?)\n     (clojure.string/join \",\"))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer. %))\n       (filter #(= (Math/sqrt %)\n                   (Math/floor (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "5d24e49be4b02ea6f0fb6a2a"}, {"problem": 74, "code": "(fn [ss]\n  (let [x (map read-string (clojure.string/split ss #\",\"))]\n    (clojure.string/join \",\"(filter (set x) ((fn [s] (take-while #(<= % (apply max s)) (map #(* % %) (iterate inc 1))))\n   x)))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\") (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"}) (clojure.string/join \",\"))", "user": "59ef6cfae4b0966464fe6a32"}, {"problem": 74, "code": "(fn squares [str]\n  (let [s (clojure.string/split str #\",\")]\n  (clojure.string/join #\",\" (filter #(= (rem (Integer. %) (Math/sqrt (Integer. %))) 0.0) s))))", "user": "5da6cb60e4b000c986472c10"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (filter\n        #(let [x (Math/sqrt (Integer/parseInt %))]\n           (== x (int x))))\n       (clojure.string/join \",\")))", "user": "56f9982ce4b07572ad1a88b8"}, {"problem": 74, "code": "(fn [s]\n  (apply str (interpose \",\" (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 74, "code": "(fn [s]\n  (-> s\n      (.split \",\")\n      (->>\n       (map #(Integer/parseInt %))\n       (filter\n         #(zero? (rem (Math/sqrt %) 1)))\n       (clojure.string/join \",\"))))", "user": "5da8fa72e4b000c986472c2d"}, {"problem": 74, "code": "(fn b [x]\n  (->> (clojure.string/split x #\",\")\n       (mapv (fn [sn]\n               (Integer/parseInt sn)))\n       (filterv (fn [n]\n                  (zero? (rem (Math/sqrt n) 1))))\n       (clojure.string/join \",\")))", "user": "59bac5c9e4b0a024fb6ae3ed"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (map #(Integer/parseInt %))\n             (filter #(let [x (Math/sqrt %)] (== x (int x))))\n             (clojure.string/join \",\")))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let [square? (fn [n] (-> n Math/sqrt (rem 1) zero?))]\n   (clojure.string/join \",\" (filter square?\n                     (map read-string (clojure.string/split s #\",\"))))))", "user": "5d97b602e4b0d3f9b434ad3a"}, {"problem": 74, "code": "(fn [st]\n\t(clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map read-string (re-seq #\"\\d+\" st)))))", "user": "562d869be4b0a45d2ff8301f"}, {"problem": 74, "code": "(fn [ip-numbers]\n  (let [formated-ip-numbers (clojure.string/split ip-numbers #\",\")]\n     (loop [output-vector [] input-vector formated-ip-numbers]\n       (if (first input-vector)\n         (do\n           (let [num (read-string (first input-vector))]\n           (if (= (Math/floor (Math/sqrt num)) (Math/sqrt num))\n             (recur (conj output-vector num) (rest input-vector))\n           (recur output-vector (rest input-vector)))))\n         (clojure.string/join \",\"output-vector)))))", "user": "5d8c8175e4b0915913b1d3e1"}, {"problem": 74, "code": "(fn f7774\n  [args]\n  (let [acc (clojure.string/split args #\",\")\n        f1 (fn\n             [args1]\n             (loop [n 0]\n               (if (<= n (Math/sqrt args1))\n                 (if (= (* n n) args1)\n                   true\n                   (recur (inc n)))\n                 false))\n             )\n        f2 (fn [str2 arg2]\n             (if (f1 (Integer/parseInt arg2))\n               (str str2 (str arg2 \",\"))\n               str2))\n        result (reduce f2 \"\" acc)]\n    (if (> (count result) 2)\n      (subs result 0 (- (count result) 1))\n      result))\n  )", "user": "5db658ebe4b010eb3c36cd39"}, {"problem": 74, "code": "(fn fun [st]\n  (reduce\n    #(str % (when (not (empty? %)) \",\") %2)\n    \"\"\n    (filter \n      #(let [k (Math/sqrt (Integer/parseInt %))]\n          (= (double (int k)) k)\n      )\n      (re-seq #\"\\w+\" st)\n    )\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 74, "code": "(fn [coll]\n   (->> (clojure.string/split coll #\",\")\n        (map #(. Integer parseInt %))\n        (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n        (clojure.string/join \",\")))", "user": "5db98f39e4b010eb3c36cd53"}, {"problem": 74, "code": "(fn final[texto]\n  (apply str\n         (interpose\n          \",\"\n         ((fn numeros[texto]\n            ((fn filtra[texto]\n               (filter\n                (fn gg[x]\n                  (some\n                   #(=(/ x %)%)\n                   (range 1 x)))\n                ((fn lista[texto]\n                   (map\n                    (fn cifras[coll]\n                      (loop[coll coll\n                            ret 0\n                            c (- (count coll) 1)]\n                        (cond\n                         (empty? coll)ret\n                         :else (recur\n                                (rest coll)\n                                (+\n                                 ret\n                                 (*\n                                  (first coll)\n                                  ((fn pot [n x]\n                                     (loop[x x\n                                           a 1]\n                                       (cond\n                                        (= x 0) a\n                                        :else (recur\n                                               (dec x)\n                                               (* a n)))))\n                                   10 c)))\n                                (dec c)))))\n                    ((fn par[texto]\n                       (loop[coll ((fn nn[coll]\n                                     (loop[coll (vec coll)\n                                           ret []]\n                                       (cond\n                                        (empty? coll)ret\n                                        :else (recur\n                                               (rest\n                                                (drop-while\n                                                 #(not= \\, %)\n                                                 coll))\n                                               (conj ret (take-while #(not= \\, %) coll)))))) texto)\n                             ret []]\n                         (cond\n                          (empty? coll)ret\n                          :else (recur\n                                 (rest coll)\n                                 (conj\n                                  ret\n                                  (map\n                                   #(Character/digit % 10)\n                                   (first coll)))))))\n                     texto)))\n                 texto)))\n             texto))\n          texto))))", "user": "5dadf73ee4b0f8c104ccfc86"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join #\",\"\n                       (filter #(= 0.0 (mod (Math/sqrt (Integer/parseInt %)) 1))\n                               (clojure.string/split s #\",\"))))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 74, "code": "(fn perfect-squares [csv]\n  (let [numbers (clojure.string/split csv #\",\")\n        perfect-square? (fn [n]\n                          (let [remainder (rem (Math/sqrt n) 2)]\n                            (or (= remainder 0.0)\n                                (= remainder 1.0))))]\n    (clojure.string/join \",\" (filter perfect-square?\n                                     (map #(Integer/parseInt %) numbers)))))", "user": "5d1be50ce4b02ea6f0fb6986"}, {"problem": 74, "code": "#(clojure.string/join  \",\" (filter (fn [x] ( let [ a (Integer. x) b (int (Math/sqrt a))] (= a (* b b) ))) (clojure.string/split % #\",\")) )", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 74, "code": "(fn\n  [list]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split list #\",\"))\n        perfect-squares (filter #(== (Math/sqrt %) (int (Math/sqrt %))) nums)]   \n    (clojure.string/join \",\" perfect-squares)))", "user": "5d96edeae4b0d3f9b434ad35"}, {"problem": 74, "code": "(fn squares [s]\n    (let\n    [\n        is_square_helper\n            (fn [start end target]\n                (let [mid (int (/ (+ start end) 2))\n                        v (* mid mid)]\n                    (cond\n                        (> start end) false\n                        (> v target) (recur 0 (dec mid) target) ;(is_square_helper 0 mid target) ;(recur 0 mid target)\n                        (= v target) true\n                        :otherwise (recur (inc mid) end target) ;(is_square_helper mid end target) ;(recur mid end target)\n                    )\n                )\n            )\n        is_square\n            (fn [x] (is_square_helper 0 x x))\n    ]\n    (clojure.string/join \",\" (filter is_square (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))))\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(square? [i] (let [r (Math/floor (Math/sqrt i))] (< (Math/abs (- (* r r) i)) 1e-5)))]\n    (clojure.string/join \",\" (filter square? (map #(Integer. %) (re-seq #\"[\\d]+\" s))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 74, "code": "#(let [v1 (set (map (fn [x] (* (identity x) x)) (range 1 10)))\n        v2 (mapv read-string (first\n                            (mapv (fn [y] (clojure.string/split y #\",\"))\n                                  [%])))\n        ans (filter v1 v2)\n        real (clojure.string/join \",\" ans)\n        ]real)", "user": "5b044436e4b0cc2b61a3bd71"}, {"problem": 74, "code": "(fn [s]\n  (let [p #(= (-> % Math/sqrt Math/floor) (Math/sqrt %))]\n    (clojure.string/join \",\" (filter p (map read-string (re-seq #\"[\\d]+\" s))))))", "user": "5dc9ccf8e4b02f9375f4e1f1"}, {"problem": 74, "code": "(fn [a] (clojure.string/join \",\" (filter #(if (== (* (Math/sqrt %) (Math/sqrt %)) %) true false) (map read-string (clojure.string/split a #\",\")))))", "user": "5bf0aefde4b0a6d31fed215a"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(zero? (rem % (Math/sqrt %))))\n       (interpose \",\")\n       (apply str)))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 74, "code": "(fn [s] \n  (->>\n   (clojure.string/split s #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(let [sqr (int (Math/sqrt %))\n                  in (* sqr sqr)]\n              (= in %)))\n   (interleave (repeat \",\"))\n   rest\n   (apply str)))", "user": "5d931a58e4b0d3f9b434ad10"}, {"problem": 74, "code": "(fn [content]\n\n   (apply str (drop-last (reduce #(if (== (Math/sqrt (Integer/valueOf %2)) (int (Math/sqrt (Integer/valueOf %2))))\n                                    (str %1 %2 \",\")\n                                    %1)\n                                 \"\"\n                                 (clojure.string/split content #\",\"))))\n\n   )", "user": "5dd1fb19e4b0948ae9d9ad51"}, {"problem": 74, "code": "(fn get-perfect-sqrs [numbers]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split numbers #\",\"))]\n    (clojure.string/join  \",\" (filter #(let [root (Math/pow % 0.5)]\n                                    (= (Math/ceil root) root)) nums))))", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 74, "code": "(fn [xs]\n        (->> (.split xs \",\")\n             (map #(Integer/parseInt %))\n             (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n             (clojure.string/join \",\")))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join\n    \",\"\n    (map str\n         (filter\n          #(= 0. (mod (Math/sqrt %) 1))\n          (map read-string (clojure.string/split s #\",\"))))))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 74, "code": "(fn [nums]\n  (-> nums\n      (clojure.string/split #\",\")\n      ((partial map read-string))\n      ((partial filter #(= 0.0 (mod (Math/sqrt %) 1))))\n      ((partial clojure.string/join \",\"))))", "user": "5ddb6151e4b0948ae9d9adb0"}, {"problem": 74, "code": "(fn filter-squared [input] \n    (letfn [(from-str [s] (map #(Integer/parseInt %) (clojure.string/split s #\",\")))\n          (to-str [coll] (apply str (interpose \",\" coll)))\n          (is-sq [num] (let [root (int (Math/sqrt num))] (= (* root root) num)))]\n          (->> input \n            (from-str)\n            (filter is-sq)\n            (to-str))))", "user": "5da05bcce4b000c986472bd0"}, {"problem": 74, "code": "(fn ps [st]\n\t(let [ar (map read-string (.split st \",\"))\n\t\t\t\t\t\t\tnums (filter #(== (int (Math/sqrt %)) (Math/sqrt %)) ar)\n\t\t\t\t\t\t\tres (reduce (fn [acc el] (str acc el \",\")) \"\" nums)]\n\t\t(subs res 0 (- (count res) 1))\n\t))", "user": "5c87c79be4b048ec896c591b"}, {"problem": 74, "code": "(fn [string]\n  (loop [squares [] \n         [n & nums] (map read-string (clojure.string/split string #\",\"))]\n    \n    (if (nil? n)\n      (clojure.string/join \",\" squares)\n      (if (== (Math/sqrt n)  (int (Math/sqrt n)))\n      \t(recur (conj squares n) nums)\n        (recur squares nums)\n      )\n      \n    )\n  )\n)", "user": "5de6484ce4b0986d99407f66"}, {"problem": 74, "code": "(fn [string]\n  (let [s (re-seq #\"\\d+\" string)]\n    (clojure.string/join \",\" (filter #(some (fn [n] (= (* n n) %)) (range %)) (map #(Integer. %) s)))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\"\\,\")\n             (map #(Double/parseDouble %))\n             (filter #(= (Math/pow (Math/sqrt %) 2) %))\n             (map int)\n             (clojure.string/join \",\")))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 74, "code": "(fn [in]\n   (->> (clojure.string/split in #\",\")\n        (map read-string)\n        (filter #(let [sqrt (Math/sqrt %)]\n                   (= sqrt (Math/floor sqrt))))\n        (clojure.string/join \",\")))", "user": "5d9e8e40e4b000c986472bc2"}, {"problem": 74, "code": "(fn answer [x]\n  (clojure.string/join \",\" (filter (fn [s]\n                                     (let [f (float (read-string s))\n                                           sqrt (Math/sqrt f)]\n                                       (= f (* sqrt sqrt))))\n                                   (clojure.string/split x #\",\"))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5dfb20b8e4b0a607a9a45cd3"}, {"problem": 74, "code": "(fn filter-perfect-square [sentence] (let [square? (fn [x] (zero? (- (Math/sqrt x) (Math/ceil (Math/sqrt x)))))]\n                                         (clojure.string/join\n                                           \",\" \n                                           (filter \n                                            #(square? %) \n                                            (map \n                                              #(Integer/valueOf %) \n                                              (re-seq #\"[0-9]+\" sentence))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 74, "code": "(fn p-74 [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= 0.0 (- (Math/floor (Math/sqrt %)) (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 74, "code": "(fn [n]\n  (let [coll (map  #(Integer/parseInt %)  (clojure.string/split  n #\",\"))\n        squ? (fn [a] (= a (* (int (Math/sqrt a)) (int (Math/sqrt a)))) )]\n    (clojure.string/join \",\" (filter squ? coll))))", "user": "5dfa1c67e4b0a607a9a45cc5"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 74, "code": "(fn [s]\n  (->>\n    (map #(Integer. %) (clojure.string/split s #\",\"))\n    (filter #(< (Math/abs (- (int (Math/sqrt %)) (Math/sqrt %))) 1e-6))\n    (interpose \",\" )\n    (apply str)))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 74, "code": "(fn\n  [num-string]\n  (clojure.string/join \",\" (filter #(= 0.0 (mod  (Math/sqrt %) 1)) (map #(Integer/parseInt %) (clojure.string/split num-string #\",\")))))", "user": "5dd25ca8e4b0948ae9d9ad55"}, {"problem": 74, "code": "(fn [s]\n    (->> s\n         (re-seq #\"\\d+\")\n         (map #(Integer/valueOf %))\n         (filter #(zero? (mod (Math/sqrt %) 1)))\n         (interpose \",\")\n         (apply str)))", "user": "510528a0e4b0730a5f55ad85"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= 0.0 (mod (Math/sqrt (Integer. %)) 1)) (re-seq #\"\\d+\" s))))", "user": "5cb0f70ce4b026601754b8c1"}, {"problem": 74, "code": "(fn [s] (letfn [(issquare [n] (let [sr (Math/sqrt n)] (= n (* (int sr) (int sr)))))]\n                (clojure.string/join \",\" (for [n (for [ss (clojure.string/split s #\",\")\n                                                      :let [x (Integer/parseInt ss)]\n                                                      :when (issquare x)]\n                                                  x)]\n                                              (str n)))))", "user": "5da71eaee4b000c986472c15"}, {"problem": 74, "code": "(fn __ [s]\n  (letfn [( perfectSquare? [x] (.endsWith\n                                (str (java.lang.Math/sqrt x))\".0\"))]\n\n         (let [ints (map\n                     (fn [st] (Integer/parseInt st))\n                     (clojure.string/split s #\",\"))\n               ]\n           (clojure.string/join \",\" (filter perfectSquare? ints)))))", "user": "5e078ba7e4b0978307768fb6"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (filter (fn [s]\n                   (let [n (java.lang.Integer/parseInt s)]\n                     (->> (range n)\n                          (some #(= (* % %) n))))))\n         (clojure.string/join \",\")))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 74, "code": "(fn [ints] (apply str (interpose \",\" (filter (fn [x] (-> x (Math/sqrt) (Math/round) (#(* % %)) (= x))) (map #(Integer/parseInt %) (into [] (.split ints \",\")))))))", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 74, "code": "(fn [xs]\n  (let [issq? (fn [x]\n                (->> (range x)\n                     (map #(* % %))\n                     (drop-while (partial > x))\n                     first\n                     (= x)))\n        join (fn [s]\n               (apply str (interpose \",\" s)))]\n    (join (filter (comp issq? read-string) (re-seq #\"\\d+\" xs)))))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 74, "code": "(fn [string]\n           (clojure.string/join \",\" (filter #(< (- (Math/sqrt %) (Math/floor (Math/sqrt %))) 0.001) \n                                            (map #(read-string %) \n                                                 (clojure.string/split string #\",\")))))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 74, "code": "(fn [s] (let [xs (clojure.string/split s #\",\")\n              f (fn [x] (Integer. x))\n              p? (fn [x] (let [sqr (int (Math/sqrt x))] (= x (* sqr sqr))))]\n          (clojure.string/join \",\" (map str (filter p? (map f xs))))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 74, "code": "(fn [s]\n    (let [num-list (clojure.string/split s #\",\")\n          num-list (map #(Integer. %) num-list)\n          sqr?     #(let [sq (Math/sqrt %)]\n                      (= sq (Math/floor sq)))\n          sqr-list (filter sqr? num-list)]\n      (clojure.string/join \",\" sqr-list)))", "user": "5e38a9cbe4b01d43a70e8dc2"}, {"problem": 74, "code": "(fn perfect [nums]\n  (let [n (map #(Integer. %) (clojure.string/split nums #\",\"))]\n    (apply str\n           (interpose \",\"\n                      (map str\n                           (filter\n                             (fn t [a]\n                               (loop [i 1 res false]\n                                 (if (or (= i a) (true? res))\n                                   (if (= a 1)\n                                     true\n                                     res)\n                                   (recur (inc i) (= (reduce * (repeat 2 i)) a))))) n))))))", "user": "5e380e72e4b01d43a70e8db0"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (read-string (str \"[\" s \"]\"))\n        perfect? (fn [n]\n                   (= (Math/floor (Math/sqrt n))\n                      (Math/ceil (Math/sqrt n))))\n        perfects (filter perfect? nums)]\n    (apply str (interpose \",\" perfects))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n   (let [square? (fn [n] (= (Math/sqrt n) (Math/floor (Math/sqrt n))))]\n    (filter (fn [v]\n              (square? (Integer/parseInt v)))\n            (clojure.string/split s #\",\")))))", "user": "52b52c29e4b0c58976d9ad38"}, {"problem": 74, "code": "(fn [n]\n  (apply str (interpose \",\" (filter #(== % (reduce * (repeat 2 (Math/sqrt %)))) (map read-string (re-seq #\"\\d+\" n))))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(= % (let [sqrt (int (Math/sqrt %))] (* sqrt sqrt))))\n       (interpose \\,)\n       (apply str)))", "user": "5e41b679e4b01d43a70e8e58"}, {"problem": 74, "code": "(fn [text]\n  (let [num? #(== (int %) %)\n        text-arr (clojure.string/split text #\",\")]\n    (->> text-arr\n         (map #(Integer/parseInt %))\n         (filter #(num? (Math/sqrt %)))\n         (clojure.string/join \",\"))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 74, "code": "(fn answer [comma-sep-ints]\n  (->> comma-sep-ints\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter #(= 1.0 (/ (Math/sqrt %) (int (Math/sqrt %)))))\n       (clojure.string/join \",\")\n       )\n  )", "user": "5e491182e4b043cd24807a46"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(= (* (int (Math/sqrt %)) (int (Math/sqrt %))) %) \n  (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "5e42b688e4b01d43a70e8e6b"}, {"problem": 74, "code": "(fn [x]\n   (let [ps? (fn [x]\n               (let [r (int (Math/sqrt x))]\n                 (= (* r r) x)))]\n     (->>\n       (clojure.string/split x #\",\")\n       (filter #(ps? (Integer/parseInt %)))\n       (clojure.string/join \",\"))))", "user": "57fc5e42e4b0d3187e900997"}, {"problem": 74, "code": "(fn [s]\n   (let [numbers (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n         square #(* %1 %1)\n         square? #(= %1 (square (int (Math/sqrt %1))))]\n     (clojure.string/join \",\" (filter square? numbers))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "556323b5e4b0c656e3ff17e5"}, {"problem": 74, "code": "(fn [string] \n      (clojure.string/join \",\" (filter \n        (fn [item] (not (empty? (filter #(= item (* % %)) (take (+ item 1) (iterate inc 2))))))\n        (map #(Integer/parseInt %)(clojure.string/split string #\",\")))))", "user": "5b337ff4e4b025bcb146f339"}, {"problem": 74, "code": "(fn [str] (clojure.string/join \",\" (filter #(zero? (mod (Math/sqrt %) 1)) (map #(Integer/parseInt %) (clojure.string/split str #\",\")))))", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(== (Math/sqrt %) (int (Math/sqrt %))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "5e566668e4b027a2e10ac0f9"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [n]\n                          (= n (let [root (int (Math/sqrt n))] (* root root))))]\n    \n    (clojure.string/join \",\" (filter perfect-square? (map read-string (clojure.string/split s #\",\"))))))", "user": "5dcc152ae4b02b31cc3da3c3"}, {"problem": 74, "code": "(fn [s]\n  (->> (.split s \",\")\n       seq\n       (map #(Integer. %))\n       (filter (fn [i] (= i (#(* % %) (int (java.lang.Math/sqrt i))))))\n       (map str)\n       (interleave (repeat \",\"))\n       rest\n       (apply str)))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 74, "code": "(fn [s]\n  (->>\n   (re-seq #\"\\d+\" s)\n   (map #(Integer/parseInt %))\n   (filter (fn [x] (let [r (int (Math/sqrt x))]\n                    (= x (* r r)))))\n   (interpose \",\")\n   (apply str)))", "user": "5e44c804e4b01d43a70e8e89"}, {"problem": 74, "code": "(fn [x] (clojure.string/join \",\" \n         (filter #(= 0.0 (- (Math/sqrt %) (int (Math/sqrt %)))) \n                 (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "user": "5d7d17ece4b02e6b30c93558"}, {"problem": 74, "code": "(fn[s](clojure.string/join \",\" (map #(int (* % %)) (filter #(== (int %) %)\n                                  (map #(Math/sqrt (Integer/parseInt %)) (clojure.string/split s #\",\"))))))", "user": "5e48ec09e4b043cd24807a45"}, {"problem": 74, "code": "(fn [s]\n    (apply str\n           (interpose\n             \",\"\n             (map str\n                  (filter\n                    (fn [x] (= x (last (take-while #(<= % x) (map #(* % %) (iterate inc 1))))))\n                    (map read-string (clojure.string/split s #\",\")))))))", "user": "5e08c3dde4b0978307768fc8"}, {"problem": 74, "code": "(fn [s]\n    (->> s\n         (re-seq #\"\\d+\")\n         (filter (fn [digit-string]\n                   (let [n (Integer/parseInt digit-string)\n                         root (int (Math/sqrt n))]\n                     (= n (* root root)))))\n         (clojure.string/join \",\")))", "user": "5df70ee8e4b0a607a9a45c8a"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join\n    \",\"\n    (filter #(= (Double/parseDouble %) (* (Math/sqrt (Double/parseDouble %)) (Math/sqrt (Double/parseDouble %))))\n            (clojure.string/split s #\",\"))))", "user": "5e246f92e4b05b4b01516150"}, {"problem": 74, "code": "(fn [s]\n  (->> \n   (partition-by (fn [a] (= \\, a)) s)\n   (filter #(not (= \\, (first %))))\n   (map #(apply str %)) \n   (map #(Integer/parseInt %))\n   (map (fn [v]  [v (int (Math/sqrt v)) ]))\n   (filter (fn [[a b]] (= a (* b b))))\n   (map first)\n   (map (fn [v] [\",\" (str v)]))\n   flatten\n   (drop 1)\n   (apply str)))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 74, "code": "(fn per [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        square? (->> (range)\n                 (drop 1)\n                 (map #(* % %))\n        \t\t (take-while #(<= % (apply max nums)))\n                 (into #{}))]\n        (clojure.string/join \n         \t\",\" (filter square? nums))))", "user": "5e7f075ee4b085ba37836e36"}, {"problem": 74, "code": "(fn perfect-square-seq [coll]\n    (let [perfect-square? (fn [n] (not\n                                    (empty?\n                                      (for [y (range 1 n)\n                                            :let [sqr (* y y)]\n                                            :when (= n sqr)]\n                                        n))))]\n      (->> coll\n           (re-seq #\"\\d+\")\n           (map #(Integer/parseInt %))\n           (filter perfect-square?)\n           (interpose \\,)\n           (apply str))))", "user": "5e7b1ef4e4b085ba37836e10"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join\n    \",\"\n    (filter (fn\n              [n]\n              (= n (last (take-while #(>= n %)\n                                     ((fn perfect-squares*\n                                        ([] (perfect-squares* 1 1))\n                                        ([n cur]\n                                         (cons cur (lazy-seq (perfect-squares* (inc n) (* (inc n) (inc n))))))))))))\n            (map read-string (clojure.string/split  s #\",\")))))", "user": "5e64f44de4b0fd0acd1586ae"}, {"problem": 74, "code": "(fn [s]\n   (let [coll (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n         compare-map (apply sorted-map (mapcat #(list % (range 1 %)) coll))\n         return (filter #(not= nil %) (map (fn [[k v]] (some #{k} (map * v v))) compare-map))]\n     (apply str (interpose \",\" return)))\n )", "user": "51316a63e4b0431ba07e7feb"}, {"problem": 74, "code": "(fn [str]\n  (letfn [(perfect-square? [n]\n            (let [sqrt-n (Math/sqrt n)]\n              (= (rationalize sqrt-n) (int sqrt-n))))]\n    (->> str\n         (re-seq #\"\\d+\")\n         (filter (comp perfect-square? #(Integer/parseInt %)))\n         (clojure.string/join \",\"))))", "user": "5be1c6c6e4b0ed4b8aab4ca5"}, {"problem": 74, "code": "(fn func [st] \n  (clojure.string/join \n   \",\" \n   (filter \n    (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x))))\n    (map #(Integer/parseInt %) (clojure.string/split st #\",\")))))", "user": "5e805895e4b085ba37836e44"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(let [r (int (Math/sqrt %))]\n                 (= % (* r r))))\n       (clojure.string/join \",\")))", "user": "4eb70649535d7eef30807373"}, {"problem": 74, "code": "(fn [val](clojure.string/join \",\" (filter #(let [s (Math/sqrt (Integer/parseInt %))]\n                         (>= (int s) s)) (clojure.string/split val #\",\"))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 74, "code": "#(let [numbers (map bigint (clojure.string/split % #\",\"))\nmax-value (apply max numbers)\nsquares (take-while (fn [z] (<= z max-value)) (map (fn [x] (* x x)) (iterate inc 1)))\nfi-f (fn [x] (contains? (set squares) x))]\n(apply str (interpose \",\" (->> numbers\n(filter fi-f)))))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 74, "code": "#(loop [nums (clojure.string/split % #\",\") squares []]\n   (if (empty? nums)\n     (clojure.string/join \",\" squares)\n     (let [root (Math/sqrt (Integer/parseInt (first nums))) el (first nums)]\n     \t(if (=  (Math/floor root) root)\n       (recur (rest nums) (conj squares el))\n       (recur (rest nums) squares)\n   )  \n  )  \n )\n)", "user": "5e947a69e4b0fbed045a37f8"}, {"problem": 74, "code": "(fn root [x]\n  (let [answer\n        (filter #(= 0.0 (mod (Math/sqrt %) 1)) (map #(Integer/parseInt %) (#(clojure.string/split % #\",\") x)))     ]\n    (clojure.string/join \",\" (map #(Integer/toString %) answer))\n    )\n\n  )", "user": "5e9d99f9e4b0157ca9664806"}, {"problem": 74, "code": "(fn [input]\n  (->> (clojure.string/split input #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(zero? (mod (Math/sqrt %) 1)))\n       (clojure.string/join \",\")))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 74, "code": "(fn filter-perfect-squares [numbers]\n  (let [perfect-square?\n        #(= (float %) (* (Math/sqrt %) (Math/sqrt %)))]\n    (clojure.string/join \n     \",\" \n     (filter #(perfect-square? (Integer/parseInt %)) \n             (clojure.string/split numbers #\",\")))))", "user": "5e92adb6e4b0fbed045a37ea"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(let [n (int (Math/sqrt %))]\n                  (= (* n n) %)))\n       (clojure.string/join \",\")))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 74, "code": "(fn [s]\n  (let [square? (fn [n] (let [root (int (Math/sqrt n))] (= n (* root root))))]\n    (->> s\n         (re-seq #\"\\d+\")\n         (filter #(square? (Integer/parseInt %)))\n         (clojure.string/join \",\"))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 74, "code": "(fn [s]\n  (->> (re-seq #\"\\d+\" s)\n   \t   (map read-string)\n       (filter #(= 0.0 (- (Math/sqrt %) (int (Math/sqrt %)))))\n       (map str)\n       (interpose \",\")\n       (clojure.string/join)))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 74, "code": "(fn ok [arg]\n  (let [numbers (clojure.string/split arg #\",\")]\n    (->> numbers\n         (map read-string)\n         (filter (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt))))\n         (clojure.string/join \",\"))))", "user": "5cc092d1e4b0ccb061962790"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (let [perfect-s? (fn [n]\n                     (let [sn (int (Math/sqrt n))]\n                       (= n (* sn sn))))]\n     (->> s\n          (#(clojure.string/split % #\",\"))\n          (map #(Integer/parseInt %) )\n          (filter perfect-s?)\n          (map str )\n          (clojure.string/join \",\"))))", "user": "58f64f71e4b0438e51c2cef0"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n       (interpose \",\")\n       (apply str)))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 74, "code": "(fn [s]\n   (->>\n    (clojure.string/split s #\",\")\n    (filter #(let [v (Integer/parseInt %) r (Math/sqrt v) c (Math/ceil r)] (= r c)))\n    (clojure.string/join \",\")))", "user": "5e9f38cce4b00a66d4a9517e"}, {"problem": 74, "code": "(fn [x] (->>\n (clojure.string/split x #\",\")\n (map read-string)\n (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n (map str)\n (clojure.string/join \",\")))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 74, "code": "(fn s [s]\n  (apply str\n         (interpose \",\"\n                    (filter\n                     (fn perfect [num]\n                       (loop [x 1]\n                         (cond\n                           (= (* x x) num) x\n                           (> x (/ num 2)) nil\n                           :else (recur (inc x))))) \n                     (map #(Integer/parseInt %) (re-seq #\"\\w+\" s))))))", "user": "568f2059e4b0dcc4269f40df"}, {"problem": 74, "code": "(fn solution [string]\n  (apply str (interpose \",\" (map str (filter #(= (read-string %)\n                                                 (* (Math/round (Math/sqrt (read-string %)))\n                                                    (Math/round (Math/sqrt (read-string %)))))\n                                             (clojure.string/split string #\",\"))))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n       (clojure.string/join \",\")))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 74, "code": "(fn [ns] (clojure.string/join \",\" (filter #(== (Math/sqrt %) (int (Math/sqrt %))) (map read-string (clojure.string/split ns #\",\")))))", "user": "512700c4e4b083bb8f88cf14"}, {"problem": 74, "code": "(fn [s]\n  (-> s\n      (clojure.string/split #\",\")\n      ((partial map #(Integer/parseInt %)))\n      ((partial filter #(let [sqrt (int (Math/sqrt %))]\n                          (= (* sqrt sqrt) %))))\n      ((partial clojure.string/join \",\"))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter (fn perfect-sq? [n]\n                 (let [sample (take (/ n 2) (iterate inc 1))     \n                       squares (map #(* % %) sample)]\n                   (contains? (set squares) n))))\n       (interleave (repeat \",\"))\n       (apply list)\n       pop\n       (apply str)\n       ))", "user": "5ed9c2cde4b0c7845d86b0e4"}, {"problem": 74, "code": "(fn filt-squares\n  [s]\n  (clojure.string/join \",\"\n        (filter (fn is-square [n] (some #(= n (* % %)) (range n)))\n                (map read-string (clojure.string/split s #\",\")))))", "user": "5ecfd429e4b016b56eae05a9"}, {"problem": 74, "code": "(fn [s]\n  (apply str (interpose \",\" (map str (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))) (map read-string (clojure.string/split s #\",\"))))))\n )", "user": "5e12327ee4b099d064962fe5"}, {"problem": 74, "code": "#(->>\n  (clojure.string/split % #\",\")\n  (map (fn [s] (Integer/parseInt s)))\n  (filter (fn [x]\n            (let [r (int (Math/sqrt x))]\n              (= x (* r r)))))\n  (clojure.string/join \",\"))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 74, "code": "(fn [s]\n  (->> \",\"\n   (.split s)\n   (map #(Integer/parseInt %))\n   (filter #(zero? (rem % (Math/sqrt %))))\n   (clojure.string/join \",\")))", "user": "5e5096c6e4b027a2e10ac0c6"}, {"problem": 74, "code": "(fn filter-squares [st] (let [nums (re-seq #\"[0-9]+\" st)\n                              squares (filter #(some true? (for [x (range 1000)] (= % (str (* x x))))) nums)]\n                              (clojure.string/join \",\" squares)))", "user": "5ee93720e4b029a2061bbeb7"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (let [nums (map read-string (clojure.string/split s #\",\"))\n                                 max-num (apply max nums)\n                                 squares (set (take-while #(<= % max-num) (map #(* % %) (range))))]\n                             (filter #(contains? squares %) nums))))", "user": "5ed875abe4b016b56eae05f2"}, {"problem": 74, "code": "(fn [s] (let [sq (clojure.string/split s #\",\") f (filter #{\"4\" \"9\" \"16\" \"25\" \"36\"} sq)] (clojure.string/join \",\" f)))", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 74, "code": "(fn __\n  [x]\n  (clojure.string/join \",\"\n   (filter #(= (Math/pow (Math/sqrt %) 2) (double %))\n           (map #(Integer/parseInt %) (clojure.string/split x #\",\")))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 74, "code": "(fn [s]\n  (let [square? #(zero? (mod (Math/sqrt (Integer/parseInt %)) 1))]\n    (clojure.string/join \",\" (filter square? (clojure.string/split s #\",\")))))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 74, "code": "(fn [coll]\n  (->> coll\n       (#(clojure.string/split % #\",\"))\n       (map #(Integer/parseInt %))\n       (filter #(= % (* (Math/round (Math/sqrt %)) (Math/round (Math/sqrt %)))))\n       (clojure.string/join \",\")))", "user": "5eb4927fe4b00a66d4a95221"}, {"problem": 74, "code": "(fn\n  [s]\n  (let [nums     (map #(Integer/parseInt %) (clojure.string/split s #\",\") )\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect  (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5cf1d9e3e4b0aaa82f112a18"}, {"problem": 74, "code": "#(->> (str \"[\" % \"]\")\n       read-string\n       (filter (fn [n]\n                 (let [p (int (Math/sqrt n))] (== (* p p) n))\n                 ))\n       (interpose \",\")\n       (apply str)\n       )", "user": "5ed8a12fe4b0c7845d86b0d7"}, {"problem": 74, "code": "(fn filter-to-psqs [s]\n  (->> s\n       (#(clojure.string/split % #\",\"))\n       (filter #(let [sqrt (Math/sqrt (Integer/parseInt %))]\n                  (< (Math/abs (- 1 (/ (int sqrt) sqrt))) 1e-6)))\n       (clojure.string/join \",\")))", "user": "5ed52854e4b016b56eae05d2"}, {"problem": 74, "code": "#(->> (clojure.string/split % #\",\")\n   (map (fn [s] (Integer/valueOf s)))\n   (reduce (fn [s n] \n             (let [sqr (Math/sqrt n)\n                   rem (second\n                        (clojure.string/split\n                         (str sqr)\n                         (re-pattern \"\\\\.\")))]\n                   (if (= rem \"0\") (conj s n) s))) [])\n   (clojure.string/join \",\"))", "user": "5eccc5c2e4b016b56eae058f"}, {"problem": 74, "code": "(fn [s]\n   (->> (map #(Integer/valueOf %) (re-seq #\"[^,]+\" s))\n        (filter #(let [r (int (Math/sqrt %))] (= % (* r r))))\n        (clojure.string/join \",\")))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 74, "code": "#(apply str (interpose \",\" (filter (fn [x] (let [y (Integer/parseInt x) z (int (Math/sqrt y))] (= y (* z z))))  (re-seq #\"[0-9]+\" %))))", "user": "5df08767e4b093ff717275bf"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n                   (map #(Integer/parseInt %))\n                   (filter (fn [x]\n                             (let [intsqrt (int (Math/sqrt x))]\n                               (= x (* intsqrt intsqrt)))))\n                   (map str)\n                   (clojure.string/join \",\")))", "user": "5edfb1e5e4b0c7845d86b107"}, {"problem": 74, "code": "(fn my-split-skip [s]\n  (subs\n\n  (reduce str \"\"\n    (map #(str \",\" %)\n      (filter\n          (fn [x]\n            (let [r (Math/sqrt (Integer/parseInt x)) ]\n                 (= (Math/ceil r) r)\n              )\n            )\n          (clojure.string/split s #\",\")\n        )\n      )\n    )\n  1\n  )\n  )", "user": "5edc16e1e4b0c7845d86b0f1"}, {"problem": 74, "code": "(fn perfect-square\n  [x]\n  (let [squares (map #(* % %) (range 100))\n        values  (map #(Integer/parseInt %) (re-seq #\"[^,]+\" x))]\n    (reduce #(str %1 \",\" %2 ) (keep #(some (fn [x] (if (= x %) x)) squares) values))\n    ))", "user": "5f088bb3e4b0cf489e8d7f5f"}, {"problem": 74, "code": "(fn [inputs] \n  (letfn [(squares ([] (squares 1))\n            ([no] (lazy-seq (cons (* no no) (squares (inc no))))))]\n    (clojure.string/join \",\" (filter #(= % (last (take-while  (fn [sq] (>= % sq)) (squares)))) (map #(Integer. %) (re-seq #\"[0-9]+\" inputs))))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 74, "code": "(fn filter-sq\n  [s]\n  (let [xs (clojure.string/split s #\",\")\n        ms (map #(Integer/valueOf %) xs)]\n    (->> ms\n         (filter (fn [x]\n                   (let [sqra (Math/sqrt x)]\n                     (== sqra (int sqra)))))\n         (clojure.string/join #\",\"))))", "user": "5ef18431e4b07c55ae4a0529"}, {"problem": 74, "code": "(fn [s]\n    (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n      (clojure.string/join\n       \\,\n       (map\n        str\n        (filter\n         (fn [n]\n           (not (empty? (filter (fn [y] (= (* y y) n)) (range n)))))\n         nums)\n        )\n       )\n      )\n    )", "user": "5f06caa7e4b0cf489e8d7f52"}, {"problem": 74, "code": "(fn [s]\n\t(->>\n\t\t(clojure.string/split s #\",\")\n\t\t(map #(Integer. (re-find #\"\\d+\" %)))\n\t\t(filter (fn [n] ; is square\n\t\t\t(loop [i 1, end (quot n 2)]\n\t\t\t\t(if (= i end)\n\t\t\t\t(= n (* i i))\n\t\t\t\t(if (= n (* i i)) true (recur (inc i) end))\n\t\t\t)\n\t\t\t)\n\t\t))\n\t\t(clojure.string/join \",\")\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 74, "code": "(fn [s] (let [nums (map read-string (re-seq #\"\\d+\" s))\n              square? (fn [x] (some #(= x (* % %)) (range x)))]\n          (clojure.string/join \",\" (filter square? nums))))", "user": "5e6ba862e4b04a83ad7cd27d"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n     (filter #(let [x (int (Math/sqrt %))] (= % (* x x)))\n         (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 74, "code": "(fn perfect-squares\n  [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (map #(vector (int (Math/sqrt %)) %))\n       (filter #(= (* (first %) (first %)) (second %)))\n       (map #(second %))\n       (clojure.string/join \",\")))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter\n        (fn [x]\n          (let [sqrt (Math/sqrt x)]\n            (= sqrt (-> sqrt int float)))))\n       (clojure.string/join \",\")))", "user": "5d431c77e4b07c84aa5ae68f"}, {"problem": 74, "code": "#(clojure.string/join \",\"\n                       (filter (fn [item] (-> item\n                                              Integer/parseInt\n                                              Math/sqrt\n                                              (mod 1)\n                                              (= 0.0)))\n                               (clojure.string/split % #\",\")))", "user": "5ef8e9e0e4b09b61f08553cb"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(= % (int (Math/pow (Math/floor (Math/sqrt %)) 2))) (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (map read-string)\n             (filter (fn [n] (some (partial = n) (map #(* % %) (range 1 (inc n))))))\n             (clojure.string/join \",\")))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n      (map read-string)\n\t  (filter #(= 0.0 (mod (Math/sqrt %) 1)))\n      (clojure.string/join \",\")))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 74, "code": "(fn filter-perfect-squares\n  [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(> 0.0000001\n                   (- (Math/sqrt %)\n                      (Math/floor (Math/sqrt %)))))\n       (clojure.string/join \",\")))", "user": "5bc7f2d6e4b07a9b28b100b7"}, {"problem": 74, "code": "(fn [str-ints]\n  (->> (map #(Integer/parseInt %) (clojure.string/split str-ints #\",\"))\n       (filter #(= (rem (Math/sqrt %) 1) 0.0))\n       (clojure.string/join \",\")\n       ))", "user": "5ee75f8be4b029a2061bbea5"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (apply str\n         (->> (re-seq #\"\\d+\" s)\n              (map #(Integer/parseInt %))\n              (filter #(let [square (Math/round (Math/sqrt %))] (== (* square square) %)))\n              (interpose \\,))))", "user": "5f300f28e4b033932238a682"}, {"problem": 74, "code": "(fn [s]\n   (->> (clojure.string/split s #\",\")\n        (map #(Integer/parseInt %))\n        (filter #(let [z (int (Math/sqrt %))] (= % (* z z))))\n        (clojure.string/join \",\")))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 74, "code": "(fn [intstring]\n (clojure.string/join \",\"\n                      (filter #(= 0.0\n                                  (mod  \n                                   (Math/sqrt\n                                    (Integer/parseInt %)) 1))\n                              (clojure.string/split intstring #\",\"))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (remove (fn [n] \n                 ((fn sqr? [cur] \n                    (cond (> (* cur cur) n) true \n                          (< (* cur cur) n) (sqr? (inc cur)) \n                          :else false)) 1)))\n       (interpose \",\")\n       (apply str)))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter \n          (fn [n]\n            (let [int-root (int (Math/floor (Math/sqrt n)))]\n              (= n (* int-root int-root)))))\n        (map str)\n        (clojure.string/join \",\")))", "user": "5f431d32e4b0955706451fb5"}, {"problem": 74, "code": "(fn[coll]\n   (clojure.string/join \",\" (filter\n              #(= (int (Math/pow (int (Math/sqrt %)) 2)) %)\n              (map #(Integer. %) (clojure.string/split coll #\",\"))\n               )))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 74, "code": "(fn [s]\n   (clojure.string/join \",\"\n    (filter #(= (double %) (Math/pow (Math/sqrt %) 2))\n            (map read-string (clojure.string/split s #\",\")))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 74, "code": "(fn [ss]\n    (->> (clojure.string/split ss #\",\")\n         (map #(Integer/parseInt %))\n         (filter (fn [x]\n                   (let [squarex (Math/sqrt x)]\n                     (= (Math/ceil squarex) (Math/floor squarex)))))\n         (map int)\n         (map str)\n         (clojure.string/join \",\")))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 74, "code": "; filter squares from a comma-separated string\n(fn filter-squares [s]\n(->>\n\t; separate integers\n\t(clojure.string/split s #\",\")\n\n\t; convert to integers\n\t(map read-string)\n\n\t; filter squares\n\t(filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n\n\t; convert back to strings\n\t(map str)\n\n\t; concatenate with commas\n\t(clojure.string/join \",\")\n)\n)", "user": "5f574662e4b0a0bc16850a90"}, {"problem": 74, "code": "(fn filter-perfect-squares\n  [numbers]\n  (clojure.string/join \",\"\n               (filter\n                 (fn [number] (let [num (Integer/parseInt number)\n                                    sqrt-as-int (int (Math/sqrt num))]\n                                (= (* sqrt-as-int sqrt-as-int) num)))\n                 (clojure.string/split numbers #\",\")))\n  )", "user": "5f29837ee4b033932238a64f"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\"\n                       (filter #(= (mod (Math/sqrt %) 1) 0.0)\n                               (map\n                                #(Integer/parseInt %)\n                                (clojure.string/split s #\",\")))))", "user": "5a514e68e4b05d388ecb6be5"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %)\n      (map read-string)\n      (filter (fn [x] (let [i (int (Math/sqrt x))] (= x (* i i)))))\n      (clojure.string/join \",\"))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))]\n    (letfn [(check [x]  (= (* (int (Math/sqrt x)) (int (Math/sqrt x))) x))\n            (include? [acc x] (if (check x) (conj acc x) acc))] \n      (clojure.string/join \",\" (reduce include? [] nums))\n    )\n  ))", "user": "5f419985e4b0955706451fab"}, {"problem": 74, "code": "(fn [s]\n    (let [\n          isqrt  (fn [n] (int (Math/floor (Math/sqrt n)))) \n          issqr? (fn [n] (let [k (isqrt n)] (= n (* k k))))\n          nums (map #(Long/parseLong %) (clojure.string/split s #\"[ ,]\"))\n          perfsq (filter issqr? nums)\n         ]\n        (clojure.string/join \",\" (map str perfsq))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 74, "code": "(fn [instring]\n  (let [numbers (map read-string (clojure.string/split instring #\",\"))]\n    (letfn [(square? [num] (let [sqrt (Math/sqrt num)] (= sqrt (double (int sqrt)))))]\n      (clojure.string/join \",\" (filter square? numbers)))))", "user": "5f2c94b4e4b033932238a669"}, {"problem": 74, "code": "(fn [v] (let [s #(Math/sqrt %)]\n         (clojure.string/join \",\" (filter #(== (s %) (int (s %)))  (map read-string (re-seq #\"\\d+\" v))))))", "user": "588fbb39e4b00487982d51bd"}, {"problem": 74, "code": "(fn [a] (->> (map #(Integer. %) (re-seq #\"\\d+\" a))\n             (filter #(zero? (rem (Math/sqrt %) 1)))\n             (clojure.string/join \",\")))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter\n    #(let [sq (int (Math/sqrt %))]\n       (= % (* sq sq)))\n    (map\n    #(Integer/parseInt %)\n    (clojure.string/split s #\",\"))))\n  )", "user": "5f58db95e4b0a0bc16850a9a"}, {"problem": 74, "code": "(fn [numstring]\n  (->> (clojure.string/split numstring #\",\")\n       (map #(Long/parseLong %))\n       (filter #(= (Math/sqrt %) (-> % (Math/sqrt) int float)))\n       (clojure.string/join \",\")))", "user": "5f79bff2e4b02876ed9fd0ca"}, {"problem": 74, "code": "(fn pf \n  [s]\n  (->>\n    (re-seq #\"\\d+\" s)\n    (map #(Integer. %))\n    (filter #(let [x (int (Math/sqrt %))]\n               (= (* x x) %)))\n    (interpose \",\")\n    (apply str)))", "user": "4e8a170c535d3e98b802328f"}, {"problem": 74, "code": "(fn [xs]\n  (apply str\n         (interpose \",\"\n                    (map\n                      (comp int)\n                      (filter\n                        #(zero? (mod (* 10 (mod (/ (-> % Math/sqrt) (-> % Math/sqrt int)) 10)) 10))\n                        (map\n                          (comp double read-string first)\n                          (re-seq #\"(\\d+),?\" xs)))))))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 74, "code": "#(letfn [(perfect? [n] (let [sq (Math/sqrt n)] (== sq (int sq))))]\n   (->> (clojure.string/split % #\",\")\n        (map read-string)\n        (filter perfect?)\n        (clojure.string/join \",\")))", "user": "596a66cde4b069c0a1a19803"}, {"problem": 74, "code": "(fn fps [s]\n  (letfn [(ps [n] (let [sqrt (int (Math/sqrt n))] (= (* sqrt sqrt) n)))]\n    (clojure.string/join\n     \",\"\n     (filter ps (map read-string (re-seq #\"[0-9]+\" s))))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 74, "code": "(fn [s]\n  (let [xs (->> (clojure.string/split s #\",\")\n                (map #(Long/parseLong %)))\n        squares (set (map #(* % %) (range 1 (apply max xs))))]\n    (->> (filter #(contains? squares %) xs)\n         (clojure.string/join \",\"))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 74, "code": "(fn get-powers [lst]\n    (reduce #(str %1 \",\" %2) (filter #(= (double (Math/round (Math/sqrt (Integer/parseInt %))))\n                                            (Math/sqrt (Integer/parseInt %)))\n                                        (seq (.split lst \",\")))))", "user": "5f9567cce4b0715f5002d7c7"}, {"problem": 74, "code": ";(\n(fn [text]\n (->>\n  (clojure.string/split\n   text\n   #\",\")\n  (map #(Integer/parseInt %))\n  (filter #(= (double %)\n              (Math/pow\n               (int\n                (Math/sqrt %))\n                2)))\n  (clojure.string/join \",\")))\n\n;\"1,5,7,6,9\")\n\n#_(= (double 1) 1.0)", "user": "5e64ae6ce4b0fd0acd1586ac"}, {"problem": 74, "code": "(fn [n]\n                    (letfn [(is-perfect-square [n]\n                              (let [s (Math/sqrt n)\n                                    f (Math/floor s)\n                                    c (Math/ceil s)]\n                                (> 0.1 (- c f))))]\n                      (apply str (interpose \",\"\n                                            (let [matcher (re-matcher #\"[^\\s,]+\" n)]\n                                              (loop [acc []]\n                                                (if-let [m (re-find matcher)]\n                                                  (recur (let [n (Integer/parseInt m)]\n                                                           (if (is-perfect-square n)\n                                                             (conj acc (str m))\n                                                             acc)))\n                                                  acc)))))))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 74, "code": "(fn perfect-squares\n  [s]\n  (let [s-split (clojure.string/split s #\",\")\n        result (filter (fn [x] (== (Math/sqrt (Double/parseDouble x)) (int (Math/sqrt (Double/parseDouble x))))) s-split)]\n    (clojure.string/join \",\" result)))", "user": "5f3103aee4b0574c87022c24"}, {"problem": 74, "code": "(fn [string]\n  (->>\n   (clojure.string/split string #\",\")\n   (map #(read-string (str %)))\n   (filter #(= (float (int (Math/sqrt %))) (Math/sqrt %)))\n   (clojure.string/join \",\")))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 74, "code": "(fn [xs]\n  (->> (clojure.string/split xs #\",\")\n       (map #(Integer/parseInt %))\n       (filter #(= % (.intValue (Math/pow (.intValue (Math/sqrt %)) 2))))\n       (clojure.string/join \",\")))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 74, "code": "(fn [y]\n    (let [numbers (-> y\n                    (.split \",\")\n                    (seq)\n                    (->> \n                        (map #(Integer/parseInt %))))]\n        (clojure.string/join \",\" (filter #(== (int (Math/sqrt %)) (Math/sqrt %)) numbers))))", "user": "5fb2eac0e4b08cb800c85b2f"}, {"problem": 74, "code": "(fn [s] \n  (clojure.string/join \",\"\n\n    (filter\n\n      (fn [n]\n\n        (== (Math/sqrt n) (int (Math/sqrt n))))\n\n         (map\n\n           read-string\n\n           (clojure.string/split s #\",\")))))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 74, "code": "(fn [coll]\n   (clojure.string/join \",\"\n                        (filter\n                         #(= (read-string %)\n                             (int (Math/pow (int (Math/sqrt (read-string %))) 2)))\n                         (clojure.string/split coll #\",\"))))", "user": "5fa96ddbe4b0fa27300f3dec"}, {"problem": 74, "code": "(fn filter-3 [l]\n  (->>\n   (clojure.string/split l #\",\")\n   (map read-string)\n   (filter #(zero? (mod (Math/sqrt %) 1)))\n   (clojure.string/join \",\")))", "user": "5f838122e4b01aacbe7a2715"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter #(= 0.0\n                     (- (Math/sqrt %) (Math/floor (Math/sqrt %)))))\n         (clojure.string/join \",\")))", "user": "5f331015e4b0574c87022c37"}, {"problem": 74, "code": "(fn [s]\n        (->> (clojure.string/split s #\",\")\n             (map #(Integer/parseInt %))\n             (filter #(let [sq (int (Math/sqrt %))]\n                        (= % (* sq sq))))\n             (clojure.string/join \",\")))", "user": "546c4377e4b00cfc9eacc177"}, {"problem": 74, "code": "(fn solve [input] (clojure.string/join \",\"\n                                         (filter #(let [s (Math/sqrt %)]\n                                                    (= (Math/floor s) s))\n                                                 (map #(Integer/parseInt %) (clojure.string/split input #\",\")))))", "user": "54c13b87e4b0ed20f4ff6f20"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (map str (filter #(let [r (Math/sqrt %)] (zero? (- r (int r)))) (map #(Integer/parseInt %) (clojure.string/split s #\",\"))))))", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 74, "code": "(fn [l]\n  (letfn [(perfect-square [x] (if (or (= x 4) (= x 9) (= x 16) (= x 25) (= x 36)) x nil))]\n    (apply \n      str \n      (interpose\n        \",\"\n        (filter \n          (comp not nil?)\n          (map \n            (fn [x] (perfect-square (Integer/parseInt x))) \n            (clojure.string/split l #\",\")))))))", "user": "57213df6e4b0c5bde472c0ab"}, {"problem": 74, "code": "(fn [s]\n    (letfn [(is-perfect? [x]\n              (let [sqrt-ans (Math/sqrt x)]\n                (= sqrt-ans (Math/ceil sqrt-ans))))]\n      (->> (clojure.string/split s #\",\")\n           (map #(Integer. %))\n           (filter is-perfect?)\n           (clojure.string/join \",\"))))\n\n;; (fn [s]\n;;     (letfn [(is-perfect? [x]\n;;               (let [sqrt-ans (int (Math/sqrt x))]\n;;                 (= x (* sqrt-ans sqrt-ans))))]\n;;       (->> (str \"[\" s \"]\")\n;;            (read-string)\n;;            (filter is-perfect?)\n;;            (clojure.string/join \",\"))))\n\n;; (fn [s]\n;;     (letfn [(is-perfect? [x]\n;;               (let [sqrt-ans (int (Math/sqrt x))]\n;;                 (= x (* sqrt-ans sqrt-ans))))]\n;;       (->> s\n;;            (re-seq #\"\\d+\")\n;;            (map read-string)\n;;            (filter is-perfect?)\n;;            (interpose \",\")\n;;            (apply str))))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 74, "code": "(fn\n  [in]\n  (let [square? #(let [r (int (Math/sqrt %))] (= % (* r r)))\n        numbers (map #(Integer/parseInt %) (re-seq #\"\\d+\" in))]\n    (->> numbers\n         (filter square?)\n         (interpose \",\")\n         (apply str))))", "user": "60036736e4b074f607df663b"}, {"problem": 74, "code": "(fn filter-squares [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map #(Integer. %) )\n       (filter (fn [n] (let [sqrt (Math/sqrt n)\n                             trk (Math/round sqrt)]\n                         (< (Math/abs (- sqrt trk)) 0.001))))\n       (clojure.string/join \",\")\n       )\n      )", "user": "5fee18f2e4b05ac5b16ea1d2"}, {"problem": 74, "code": "(fn filter-square [s]\n  (letfn [(integers-of-s [s]\n            (map #(Integer. %) (re-seq #\"\\d+\" s)))\n   (is-perfect-square [num]\n     (loop [outside-num num cur-num (dec num)]\n       (if (= 0 cur-num)\n         false\n         (if (= outside-num (* cur-num cur-num))\n           true\n           (recur outside-num (dec cur-num))\n           )\n         )\n       \n       )\n     )\n\n  ]\n    (reduce #(str %1 \",\" %2) (filter is-perfect-square (integers-of-s s)))\n  )\n  \n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 74, "code": "(fn [num-string]\n  (->> num-string\n   (#(clojure.string/split % #\",\"))\n   (map #(Integer/parseInt %))\n   (filter #(some (fn [n] (= (* n n) %)) (range %)))\n   (clojure.string/join \",\")   \n   )\n  )", "user": "6004c750e4b074f607df6645"}, {"problem": 74, "code": "(fn [s]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer. %))\n         (filter #(let [x (int (Math/sqrt %))] (= (* x x) %)))\n         (map str)\n         (clojure.string/join \",\")))", "user": "600ae927e4b074f607df6689"}, {"problem": 74, "code": "(fn [ns]\n  (->> (clojure.string/split ns #\",\")\n     (map #(Long/parseLong %))\n     (filter (fn [n] (let [r (Math/sqrt n)] (== r (int r)))))\n     (map int)\n     (clojure.string/join \",\")))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 74, "code": "(fn f\n  [s]\n  (let [ps (fn f\n             [n]\n             (lazy-seq (cons (* n n) (f (inc n)))))]\n    (->> (clojure.string/split s #\",\")\n         (map read-string)\n         (filter (fn [n]\n                   (= n (last (take-while #(<= % n) (ps 1))))))\n         (map str)\n         (clojure.string/join \",\"))))", "user": "5da7176ae4b000c986472c13"}, {"problem": 74, "code": "(fn [str]\n    (->> str \n        (re-seq #\"\\d+\")\n        (map #(Integer/parseInt %))\n        (filter (fn [x] (let [sqrt (Math/sqrt x)]\n                        (== sqrt (int sqrt)))))\n        (clojure.string/join \",\")))", "user": "5ff93da9e4b06df49cee14af"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(integer? (rationalize (Math/sqrt (Integer/parseInt %1)))) (clojure.string/split s #\",\"))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (re-seq #\"\\d+\")\n       (map read-string)\n       (filter #(== (int (Math/sqrt %)) (Math/sqrt %)))\n       (clojure.string/join \",\")))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 74, "code": "(fn filterPerfectBin\n  [input] \n  (->> (clojure.string/split input #\",\")\n       (filter #(let [x (Integer/parseInt %1)\n                      sqrt-x (int (Math/sqrt x))]\n                  (= x (* sqrt-x sqrt-x))))\n       (interpose \",\")\n       (apply str)\n       )\n\n  )", "user": "5fce0cc5e4b07e53c2f3f000"}, {"problem": 74, "code": "(fn perf-squares-in-string [string]\n  (let [nums (map read-string (clojure.string/split string #\",\"))\n        perf-squares (map #(* % %) (range))\n        valid-nums (filter #(some #{%} (take-while (partial >= %) perf-squares))                           nums)]\n    (clojure.string/join \",\" valid-nums)))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 74, "code": "(fn [string] (->> (clojure.string/split string #\",\")\n                  (map #(Integer/parseInt %))\n                  (filter #(= % (apply * (repeat 2 (int (Math/sqrt %))))))\n                  (clojure.string/join #\",\")\n                 ))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 74, "code": ";;(fn [s]\n;;  (let [squares (fn sq [s] (concat [(* s s)] (lazy-seq (sq (inc s)))))\n;;        input (map read-string (clojure.string/split s #\",\"))\n;;        start (apply min input)\n;;        stop (apply max input)\n;;        sq-range (into #{} (drop-while #(< % start) (take-while #(<= % stop) (squares 1))))]\n;;    (->> (filter sq-range input)\n;;         (clojure.string/join \",\"))))\n\n;; awebb's solution is pretty clever:\n(fn [s] (clojure.string/join \",\"\n  (filter #(= 0.0 (mod (Math/sqrt %) 1)) \n    (read-string (str \"[\" s \"]\")) )) )", "user": "5fb68f09e4b08cb800c85b58"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(is-integer? [n] (= n (Math/floor n)))\n          (is-perfect-square? [n] (is-integer? (Math/sqrt n)))\n         ]\n  \t(->> (str \"(\" s \")\")\n  \t\t read-string\n      \t (filter is-perfect-square?)\n      \t (clojure.string/join \",\")\n  \t)\n  )\n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 74, "code": "(fn  [s]\n  (letfn [(perfect-square? [n]\n            (let [sqrt (int (Math/sqrt n))]\n              (= (* sqrt sqrt) n)))]\n    (->> (clojure.string/split s #\",\")\n      (map read-string)\n      (filter perfect-square?)\n      (map str)\n      (clojure.string/join \",\"))))", "user": "5edd05bfe4b0c7845d86b0f3"}, {"problem": 74, "code": "(fn perfect-squares [se]\n  (let [numbers (map (fn [x] (Integer/parseInt x))\n                     (clojure.string/split se #\",\"))\n        squares (into #{}\n                      (map (fn [x] (* x x))\n                           (range 1 (inc (apply max numbers)))))]\n    (clojure.string/join \",\"\n                         (filter (fn [elm] (squares elm))\n                                 numbers))))", "user": "5fbf6fe7e4b0ad6fc3476147"}, {"problem": 74, "code": "#(->> (re-seq #\"\\d+\" %)\n      (map (fn [s] (Integer/parseInt s)))\n      (filter (fn [n]\n                (== (Math/pow (Math/sqrt n) 2)\n                    n)))\n      \n      (clojure.string/join \",\"))", "user": "60096aabe4b074f607df667f"}, {"problem": 74, "code": "(fn [s]\n    (letfn [\n          ;; parse (fn [s] (map #(Integer/parseInt %) (str/split s #\",\")))\n            (parse [s]\n              (->> s\n                   (partition-by #(= \\, %))\n                   (take-nth 2)\n                   (map #(apply str %))\n                   (map #(Integer/parseInt %))))\n          ;; unparse (fn [l] (str/join \",\" (map str l)))\n            (unparse [l]\n              (->> l\n                   (map str)\n                   (interpose \",\")\n                   (apply str)))\n            (square?\n              ([x] (square? x 0 (inc x)))\n              ([x lo hi]\n               (let [mid (int (/ (+ hi lo) 2))\n                     mid-sq (* mid mid)]\n                 (cond (= x mid-sq) true\n                       (= lo mid) false\n                       (< x mid-sq) (square? x lo mid)\n                       :default (square? x mid hi))\n                 )))\n            ]\n      (unparse (filter square? (parse s)))\n      ))", "user": "57fc0719e4b0d3187e900987"}, {"problem": 74, "code": "(fn [s]\n  (clojure.string/join \",\" (filter #(integer? (rationalize (Math/sqrt (Integer/parseInt %1)))) (clojure.string/split s #\"\\,\"))))", "user": "6022844de4b0d5df2af22203"}, {"problem": 74, "code": "#(clojure.string/join \",\"\n                     (filter (fn [s] (let [s (Math/pow s 1/2)]\n                                          (= s (Math/floor s)))) \n                             (read-string (str \"[\" % \"]\"))))", "user": "4e38f245535deb9a81d77f3e"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (clojure.string/split s #\",\")]\n    (letfn [(issquare? [n]\n                       (loop [i 1]\n                         (cond (= i n) false\n                           \t\t(= (* i i) n) true\n                               :else (recur (inc i)))))]\n      (clojure.string/join \",\" (filter issquare? (map read-string nums))))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 74, "code": "(fn eep [s]\n  (let [sp (clojure.string/split s #\",\")\n        i  (map read-string sp)\n        sqeq (fn [n] (= n (* (int (Math/sqrt n)) (int (Math/sqrt n)))))]\n    \n    (apply str (interpose \",\" (filter sqeq i)))))", "user": "602d5eade4b0d5df2af22279"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "5fd361f2e4b07e53c2f3f04e"}, {"problem": 74, "code": "(fn parse- [input]\n   (letfn [(perfect? [x] \n           (if (= 0.0 (rem (Math/sqrt x) 1)) true false) )\n           (handle [y] (->> (map read-string (clojure.string/split y #\"[,]\"))\n                              (filter #(perfect? %))\n                              (interleave (repeat \",\"))\n                              (drop 1)))]\n   (apply str (handle input))                           \n   ))", "user": "5fec4f5ee4b05ac5b16ea1bf"}, {"problem": 74, "code": "(fn foo [string]\n        (let [coll \n              (->> (-> string (clojure.string/split #\",\"))  \n                       (map #(java.lang.Integer/parseInt %))\n                       (map #(java.lang.Math/sqrt %)))\n              func (fn [nums]\n                     (if (zero? (compare nums (int nums))) (int (* nums nums))\n                         nil)\n                     )\n                     \n              ]\n          (clojure.string/join \",\"(map str (remove nil? (map func coll))))\n          ))", "user": "6038b6b4e4b0d5df2af222ef"}, {"problem": 74, "code": "(fn [s]\n  (->> (map #(Math/sqrt (Integer/parseInt %)) (clojure.string/split s #\",\"))\n       (filter #(= (float (int %)) %))\n       (map (comp str int #(* % %)))\n       (clojure.string/join \",\")\n  ))", "user": "5f5b624de4b05ea7b9adc42f"}, {"problem": 74, "code": "(fn f [x]\n  (let [is-perfect-square (fn [x] (= (#(* % %) (int (Math/sqrt x))) x))\n        \n        strings (clojure.string/split x #\",\")\n        \n        nums (map bigint strings)\n        \n        psqs (filter is-perfect-square nums)\n        \n        strs (map str psqs)\n        ]\n    (clojure.string/join \",\" strs)))", "user": "6045582fe4b02d28681c77b6"}, {"problem": 74, "code": "(fn [x] \n  (clojure.string/join \",\" (filter\n                                  (fn [x]\n                                    (some #{x}\n                                          (map #(* % %) (range x))))\n                                  (read-string (str \"(\" x \")\")))))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 74, "code": "(fn[n] (let [st (set (map #(str (* % %)) (range 7))) \n             par (clojure.string/split n  #\",\")] \n         (apply str (interpose \",\" (filter st par) ))))", "user": "58c71509e4b021aa9917ed6e"}, {"problem": 74, "code": "(fn [string] (clojure.string/join \",\" \n                                  (filter (fn [x] (= x (#(* % %) (int (Math/sqrt x))))) \n                                          (map #(Integer/parseInt %) (clojure.string/split string #\",\")))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 74, "code": "(comp \n (partial clojure.string/join \",\") \n (partial filter #(= 0.0 (rem (Math/sqrt %) 1))) \n (partial map #(Integer/parseInt %)) \n (partial re-seq #\"\\d+\"))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 74, "code": "(fn [csv]\n  (->> (clojure.string/split csv #\",\")\n       (map #(Integer/parseInt %))\n       (map #(Math/sqrt %))\n       (filter #(= (- % (int %)) 0.0))       \n       (map #(int (* % %)))\n       (clojure.string/join \",\")))", "user": "591e0782e4b09b4ee5954c25"}, {"problem": 74, "code": "(fn sq [si]\n  (let [iv (set (mapv #(Integer/parseInt %) (clojure.string/split si #\",\")))\n        ;_ (println \"iv:\" iv)\n        fiv (mapv str (keep #(let [v (* % %)] (if (contains? iv v) v)) (range 37)))\n       ; _ (println fiv)\n        ]\n    (clojure.string/join \",\" fiv)))", "user": "5245af03e4b08ba239308124"}, {"problem": 74, "code": "(fn square\n  [s]\n  (let [sqrt? (fn [n]\n                (let [q (long (Math/sqrt n))]\n                  (= n (* q q))))]\n    (->> (filter sqrt? (->> (re-seq #\"\\d+\" s)\n                            (map #(Long/parseLong %))))\n         (clojure.string/join \",\"))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 74, "code": "#(clojure.string/join \",\"\n  (for [s (clojure.string/split % #\",\")\n       :let [n (Integer/parseInt s)\n             r (Math/sqrt n)]\n       :when (> 0.001 (Math/abs (- r (int r))))]\n\tn))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 74, "code": "(fn [s] (let [str-nums (re-seq #\"\\d+\" s)\n              nums (map #(Integer/parseInt %) str-nums)\n              max-num (apply max nums)\n              square #(* % %)\n              m ((fn [coll start] (loop [res coll start start] (if (> (square start) max-num) res (recur (conj res (square start)) (inc start))))) #{} 1)\n              ] \n          \n          (->> nums\n              (filter m)\n              (map #(.toString %))\n              (clojure.string/join \",\")\n              )))", "user": "60471241e4b02d28681c77c9"}, {"problem": 74, "code": "(fn __ [s]\n  (clojure.string/join \",\"\n                       (map str\n                            (filter\n                             #(zero? (mod (Math/sqrt %) 1))\n                             (map #(Integer/parseInt %) (.split s \",\"))))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 74, "code": "#(->> (.split % \",\")\n        (map bigint)\n        (filter (fn [x] (zero? (mod (Math/sqrt x) 1))))\n        (clojure.string/join \",\"))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 74, "code": "(fn\n  [si]\n  (letfn [(squares [] (map #(str (* % %)) (range)))]\n    (clojure.string/join \",\" (sort (clojure.set/intersection\n                         (set (take 10 (squares)))\n                         (set (clojure.string/split si #\"\\,\")))))))", "user": "5ec02e20e4b00a66d4a95288"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect? (fn [n]\n                   (loop [i 0]\n                     (let [m (* i i)]\n                       (if (= n m) true\n                         (if (< n m) false\n                           (recur (inc i)))))))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter perfect?)\n         (clojure.string/join \\,))))", "user": "5dbe3761e4b09f47823971c5"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Long/parseLong %))\n       (filter (fn [x]\n                 (let [sq (Math/sqrt x)]\n                   (== (* sq sq) x))))\n       (clojure.string/join \\,)))", "user": "4db2903f535df7e46ed9b6bf"}, {"problem": 74, "code": "(fn [ls] (if (> (count ls) 11) \"16,25,36\" \"4,9\"))", "user": "606b5ca8e4b069485764ddfe"}, {"problem": 74, "code": "(fn solve [s]\n  (clojure.string/join\n   \",\"\n   (filter\n    (fn [n]\n      (let [rn (map #(* % %) (range (inc (int (Math/sqrt n)))))]\n      ;;  (println n rn)\n        (some #{n} rn)))\n    (map #(Integer/parseInt %) (clojure.string/split s #\",\")))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 74, "code": "(fn problem-74 [s]\n  (let [ints (->> (clojure.string/split s #\",\")\n                  (map (fn [x] (Integer. x))))\n        sqrs (set (take-while #(<= % (apply max ints))\n                              (map #(* % %) (range))))]\n    (clojure.string/join \",\" (filter sqrs ints))))", "user": "5d669613e4b0db5d338d15ea"}, {"problem": 74, "code": "(fn foo [s]\r\n  (->>\r\n    (clojure.string/split s #\",\")\r\n    (map #(Integer/parseInt %))\r\n    (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\r\n    (clojure.string/join \",\")))", "user": "606e0a42e4b069485764de19"}, {"problem": 74, "code": "(fn perfect-squares [s]\n  (->> (clojure.string/split s #\",\")\n       (map read-string)\n       (filter #(= 0.0 (- (Math/sqrt %1) (int (Math/sqrt %1)))))\n       (clojure.string/join \",\")))", "user": "60606490e4b03746e80ebf67"}, {"problem": 74, "code": "(fn [s]\n   (let [perfect-squre?\n         (fn [number]\n           (= (int (Math/pow (int (Math/sqrt number)) 2))\n              number))]\n     (clojure.string/join\n      \",\"\n      (filter\n       perfect-squre?\n       (map\n        read-string\n        (.split  s \",\"))))))", "user": "54be7c0de4b0ed20f4ff6eec"}, {"problem": 74, "code": "(fn filter-perfect-squares'\n  [s]\n  (clojure.string/join (reduce (fn [my-list item]\n                                 (cond\n                                   (and (= (last (str (Math/sqrt (Integer/parseInt item)))) \\0) (empty? my-list)) (conj my-list item)\n                                   (and (= (last (str (Math/sqrt (Integer/parseInt item)))) \\0) (not (empty? my-list))) (conj my-list \\, item)\n                                   :else my-list))\n                               []\n                               (clojure.string/split s #\",\"))))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 74, "code": "#(->> (str \"[\" % \"]\")\n      (read-string)\n      (filter (fn [v] (let [p (int (Math/sqrt v))] (= v (* p p)))))\n      (clojure.string/join \",\"))", "user": "606ff89be4b069485764de22"}, {"problem": 74, "code": "(fn [in]\n  (clojure.string/join\n    \",\"\n    (filter #(zero? (mod (Math/sqrt (Integer/parseInt %))\n                         1))\n            (clojure.string/split in #\",\"))))", "user": "605b49b7e4b079a07f8593f8"}, {"problem": 74, "code": "(fn [s]\n    (clojure.string/join \",\"\n     (filter (fn [x]\n               (let [n (Double/parseDouble x)]\n                 (= (Math/pow (Math/sqrt n) 2) n)))\n             (clojure.string/split s #\",\"))))", "user": "6026d2cae4b0d5df2af22232"}, {"problem": 74, "code": "(fn perfect-squares [input]\n  (letfn [(parse-numbers [string]\n              (->> string\n                  seq\n                  (partition-by #(= '\\, %))\n                  (remove #(= (first %) '\\,))\n                  (map #(apply str %))\n                  (map read-string)))\n          (perfect-square? [number]\n              (zero? (rem (Math/sqrt number) 1)))]\n          (->> input\n              parse-numbers\n              (filter perfect-square?)\n              (interpose \",\")\n              (apply str))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 74, "code": "(fn [y]\n    (loop [a (map (fn [val] (Integer/parseInt val)) (clojure.string/split y #\",\"))\n           b []]\n      (if (empty? a)\n        (clojure.string/join \",\" b)\n        (recur (rest a)\n               (if (= 1 (count \n                         (filter #(= (* % %) (first a)) (range 1 (first a)))))\n                 (conj b (first a))\n                 b)))))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 74, "code": "(fn [s]\n  (let [ds (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        f (fn [x] (= (Math/sqrt x) (Math/floor (Math/sqrt x))))\n        ds2 (filter f ds)]\n    (clojure.string/join \",\" (map str ds2))))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 74, "code": "(fn [str]\n  (letfn [(natural-number? [x] (== (Math/round x) x))]\n    (->>  (clojure.string/split str #\",\")\n          (map read-string)\n          (filter #(natural-number? (Math/sqrt %)))\n          (clojure.string/join \",\"))))", "user": "5f0aa72de4b09a3f05b71808"}, {"problem": 74, "code": "(fn [s]\n  (->> (clojure.string/split s #\",\")\n       (map #(Integer/parseInt %))\n       (filter (fn [n]\n                 (let [sn (Math/sqrt n)\n                       rn (Math/round sn)]\n                   (< (Math/abs (- sn rn)) 0.001))))\n       (map str)\n       (interpose \",\")\n       (clojure.string/join)))", "user": "605f5c69e4b03746e80ebf5e"}, {"problem": 74, "code": "(fn filter-squares [string]\n  (->>\n   (clojure.string/split string #\",\")\n   (map #(Integer/parseInt %))\n   (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n   (interpose \",\")\n   (apply str)))", "user": "60849bd6e4b0736b099e42f2"}, {"problem": 74, "code": ";; approach 1: generate a set of squares to filter\n(fn [s]\n  (let [numbers (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))\n        highest (apply max numbers)\n        squares (->> (range)\n                     (map #(* % %))\n                     (take-while #(<= % highest))\n                     set)]\n    (->> numbers\n         (filter squares)\n         (clojure.string/join \",\"))))\n;; approach 2: check each number\n;(fn [s]\n;  (let [numbers (map #(Integer/parseInt %) (re-seq #\"\\d+\" s))]\n;    (clojure.string/join \",\"\n;                         (filter (fn [n]\n;                                   (->> (range 1 (inc (/ n 2)))\n;                                        (some #(= n (* % %)))))\n;                                 numbers))))", "user": "60794173e4b0a637ed78035d"}, {"problem": 74, "code": "(fn [strseq]\n  (let [seqq (map #(Integer/parseInt %) (re-seq #\"\\d+\" strseq))\n        square? (fn [n] (= (Math/floor (Math/sqrt n)) (Math/sqrt n)))]\n    (clojure.string/join \",\" (filter square? seqq))))", "user": "6088395de4b0ae75613dcee2"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n   (re-seq #\"\\d+\")\n   (map #(Integer/parseInt %))\n   (filter #(integer? (rationalize (Math/sqrt %))))\n   (clojure.string/join \",\")))", "user": "5b4b8cd6e4b02d533a91bc9f"}, {"problem": 74, "code": "(fn [s]\n  (let [perfect-square? (fn [^Float x] (= x (Math/pow (Math/sqrt x) 2)))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Float/parseFloat %))\n         (filter perfect-square?)\n         (map int)\n         (clojure.string/join \",\"))))", "user": "6098263be4b00e9e6653c3f9"}, {"problem": 74, "code": "(fn [text]\n      (clojure.string/join \",\"\n                           (filter (fn perfect-square? [x] (let [sq (Math/sqrt x)] (== x (* sq sq)))) (map read-string (clojure.string/split text #\",\"))))\n      )", "user": "59adec09e4b0e1f4e384c897"}, {"problem": 74, "code": "(fn [string]\n  (->> string \n      (re-seq #\"\\d+\")\n       (map #(Integer/parseInt %))\n       (filter #(= (Math/sqrt %) (Math/floor (Math/sqrt %))))\n       (clojure.string/join \",\")))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 74, "code": "(fn [string]\n  (let [integers (->> #\",\"\n                      (clojure.string/split string)\n                      (map #(Integer/parseInt %)))\n        pred (fn [x] (->> x\n                          (Math/sqrt)\n                          (#(- % (int %)))\n                          (== 0)))]\n    (->>(filter pred integers)\n        (interpose \",\")\n        (clojure.string/join))))", "user": "60a42199e4b00e9e6653c454"}, {"problem": 74, "code": "( let [perfsq\n (fn [x] (let [y (int (Math/sqrt x))] (= (* y y) x) ))]\n (fn ps [s] (clojure.string/join #\",\" (filter #(perfsq % ) \n                                              (map read-string (clojure.string/split s #\",\"))) )))", "user": "6076adb2e4b069485764de60"}, {"problem": 74, "code": "(fn [l]\n  (clojure.string/join \",\"\n    (filter #(= % (let [s (int (Math/sqrt %))] (* s s)))\n      (map read-string (clojure.string/split l #\",\")))))", "user": "60882700e4b0ae75613dcedf"}, {"problem": 74, "code": "(fn [text]\n  (letfn [(square? [x] (zero? (mod (Math/sqrt x) 1)))]\n    (->> (read-string (str \"[\" text \"]\"))\n         (filter square?)\n         (clojure.string/join \",\"))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 74, "code": "(fn [text]\n   (->> text \n (re-seq #\"[0-9]+\") \n        (map #(Integer/parseInt %)) \n        (filter #(= % (* (int (Math/sqrt %)) (int (Math/sqrt %)))))\n        (clojure.string/join \",\")))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 74, "code": "(fn [s] (clojure.string/join \",\" (filter #(zero? (rem (Math/sqrt %) 1)) (map #(Integer/parseInt %) (re-seq #\"\\d+\" s)))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 74, "code": "(fn [sq]\n  (let [sqrt #(int (Math/sqrt %))\n        sqr #(* % %)\n        vals (map #(Integer. %) (clojure.string/split sq #\",\"))]\n    (clojure.string/join \",\" (filter #(= % (sqr (sqrt %))) vals))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 74, "code": "(fn [s]\n  (letfn [(f [x] (Integer. (re-find #\"\\d+\" x)))]\n    (->> (clojure.string/split s #\",\")\n         (map f)\n         (filter #(= (* (int (Math/sqrt %)) (int (Math/sqrt %))) %))\n         (clojure.string/join \",\"))\n  ))", "user": "60aecd73e4b00e9e6653c49a"}, {"problem": 74, "code": "(fn perfect-square\n  [coll]\n  (let [num  (map #(Integer/parseInt %) (clojure.string/split coll #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? num)]\n    (apply str (interpose \",\" perfect))))", "user": "608c270ae4b03bd49d9f36b3"}, {"problem": 74, "code": "(fn [s]\n  (let [nums (map #(Integer/parseInt %) (clojure.string/split s #\",\"))\n        psquare? (fn [n] (let [sqrt (Math/sqrt n)] (= (Math/floor sqrt) sqrt)))\n        perfect (filter psquare? nums)]\n    (apply str (interpose \",\" perfect))))", "user": "6093b56ce4b00e9e6653c3e0"}, {"problem": 74, "code": "(fn perfect-squares\n  [s]\n  (->> (clojure.string/split s #\",\")\n       (filter #(= 0.0 (rem (Math/sqrt (Integer/parseInt %)) 1)))\n       (clojure.string/join \",\")))", "user": "60c0ceb7e4b0e0fa5f1b42a6"}, {"problem": 74, "code": "(letfn [(square? [n]\n          (let [r (int (Math/sqrt n))]\n            (= n (* r r))))\n\n        (squares [s]\n          (->> (clojure.string/split s #\",\")\n               (map #(Integer/parseInt %))\n               (filter square?)\n               (map str)\n               (clojure.string/join \",\")))\n        ]\n  squares)", "user": "53720c5ce4b0493c815db704"}, {"problem": 74, "code": "(fn [s]\n\n  (letfn [(perfect-square? [x]\n            (let [root (int (Math/sqrt x))]\n              (= (* root root) x)))]\n    (->> (clojure.string/split s #\",\")\n         (map #(Integer/parseInt %))\n         (filter perfect-square?)\n         (clojure.string/join \",\"))))", "user": "4fe49706e4b0e8f79898feb7"}, {"problem": 74, "code": "(fn [s] (->> (clojure.string/split s #\",\")\n             (map read-string)\n             (filter #(let [rt (Math/floor (Math/sqrt %))]\n                       (= % (int (* rt rt)))))\n             (clojure.string/join \",\" )))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 74, "code": "(fn [s]\n  (->> s\n       (#(clojure.string/split % #\",\"))\n       (map read-string)\n       (filter #(let [root (Math/sqrt %)] (== root (int root))))\n       (clojure.string/join \",\")))", "user": "60bfb68be4b0e0fa5f1b429e"}, {"problem": 74, "code": "(fn [num]\n   (->> (clojure.string/split num #\",\")\n        (map #(Long/parseLong %))\n        (filter\n         (fn [n]\n           (when ((->> (range n)\n                       (map #(* % %))\n                       set) n) n)))\n        (clojure.string/join #\",\")))", "user": "5fa80c01e4b0fa27300f3de2"}, {"problem": 74, "code": "(fn sep-perf-squares [string]\n  (let [nass (clojure.string/split string #\",\")\n        nasn (map #(Integer/parseInt %) nass)\n\n        square? (fn [n] (let [sqrt (Math/sqrt n)]\n                          (== (Math/floor sqrt) sqrt)))\n        filtered (filter square? nasn)]\n    (clojure.string/join \",\" filtered)))", "user": "5f90aeefe4b0715f5002d799"}]