[{"code": "(fn f [s]\r\n  (#(if (= % s) s (f %))\r\n   (set (for [[a b] s [c d] s]\r\n    [a (if (= b c) d b)]))))", "problem": 84, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn tmp ([x] (tmp (vec x) #{} #{}))\r\n  ([[[x y] & more] accum accumf]\r\n    (println x \":\" y \":\" more \":\" accum)\r\n    (cond\r\n      (and (empty? more) (= accum accumf)) accumf\r\n      (and (empty? more) (not= accum accumf)) \r\n          (tmp (vec (clojure.set/union #{[x y]} accum accumf))\r\n              #{}\r\n              (clojure.set/union #{[x y]} accum accumf))\r\n      :else (let [tf #(cond\r\n                  (= x (last %2)) (conj (conj %1 %2) [(first %2) y])\r\n                  (= y (first %2)) (conj (conj %1 %2) [x (last %2)])\r\n                  :else %1)]\r\n        (tmp more \r\n             (clojure.set/union (set (reduce tf accum more)) #{[x y]}) accumf)))))", "problem": 84, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn [s]\r\n  (let [f #(for [[a b] (seq %)\r\n                 [c d] (seq %)\r\n                 :when (= c b)] [a d])]\r\n    (->> s (iterate #(let [n (into % (f %))]\r\n                       (when (not= % n) n)))\r\n         (take-while identity)\r\n         (last))))", "problem": 84, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(letfn [(transit-1 [edges]\r\n          (let [nodes (group-by first edges)]\r\n            (into edges (for [[from to] nodes\r\n                              [_ intermediate] to\r\n                              [_ endpoint] (nodes intermediate)]\r\n                          [from endpoint]))))]\r\n  (fn [edges]\r\n    (->> edges\r\n         (iterate transit-1)\r\n         (partition 2 1)\r\n         (drop-while (partial apply not=))\r\n         ffirst)))", "problem": 84, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn [ init-vecs ]\r\n   (letfn [(one-level \r\n             [vecs]\r\n             (into #{}\r\n                   (remove nil?\r\n                           (apply concat\r\n                                  (for [[k v] vecs]\r\n                                    (map #(let [[k1 v2] %] \r\n                                            (when (or (= k1 k) (= k1 v))\r\n                                              [k v2])) vecs))))))]\r\n          (loop [acc init-vecs, prev-size 0]\r\n            (let [acc2 (one-level acc), size (count acc2)]\r\n              (if (< prev-size size)\r\n                (recur acc2 size)\r\n                acc2)))))", "problem": 84, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn  [s]\r\n  (set (mapcat (fn [a]\r\n                 (for [x ((fn [a r]\r\n                            (let [l (map second (filter #(= (first %) a) s))]\r\n                              (if (empty? l) r\r\n                                  (recur (first l) (conj r (first l))))))\r\n                          a [])]\r\n                   [a x]))\r\n               (map first s))))", "problem": 84, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn [s]\r\n  (let [new-s (reduce\r\n                into\r\n                s\r\n                (map\r\n                  (fn [[x1 x2]]      \r\n                    (set (map\r\n                      (fn [[y1 y2]] \r\n                        (if (= x2 y1)\r\n                          [x1 y2]\r\n                          [x1 x2]))\r\n                      s)))\r\n                s))]\r\n    (if (= new-s s)\r\n      s\r\n      (recur new-s))))", "problem": 84, "user": "4db85282535d1e037afb218a"}, {"code": "(letfn [\r\n  (rel-to-map [rel]\r\n\t\t(reduce (fn [m [k v]] (assoc m k #{v})) {} rel))\r\n\t(trans-closure1 [rel-map]\r\n\t\t(apply\r\n\t\t\tconj\r\n\t\t\t{}\r\n\t\t\t(for [[k v] rel-map] [k (set (apply concat v (map (partial get rel-map) v)))])))\r\n\t(trans-closure* [rel-map]\r\n\t\t(loop [r1 {}, r2 rel-map]\r\n\t\t\t(if (= r1 r2)\r\n\t\t\t\tr1\r\n\t\t\t\t(recur r2 (trans-closure1 r2)))))]\r\n\t\r\n\t(fn [rel]\r\n\t\t(set (for [[k v] (trans-closure* (rel-to-map rel)), vi v] [k vi]))))", "problem": 84, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [s]\r\n  (letfn ((sub [s]\r\n               (reduce (fn [r v]\r\n                         (conj (reduce (fn [r2 v2]\r\n                                         (if (= (v 1) (v2 0))\r\n                                           (conj r2 [(v 0) (v2 1)])\r\n                                           r2))\r\n                                       r\r\n                                       s)\r\n                               v))\r\n                       #{}\r\n                       s)))\r\n         (loop [s s\r\n                s2 (sub s)]\r\n           (if (= s s2)\r\n             s\r\n             (recur s2 (sub s2))))))", "problem": 84, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn traclo [lst]\r\n  (letfn [(node-list [p lst]\r\n  \t     (let [nodes (filter #(= (second p) (first %)) lst)]\r\n\t\t       (if (= (count nodes) 0)\r\n\t\t\t []\r\n\t\t\t (loop [ns nodes xs nodes]\r\n\t\t\t   (if (nil? (first ns))\r\n\t\t\t     (set xs)\r\n\t\t\t     (recur (rest ns) (concat xs (node-list (first ns) lst))))))))\r\n\t  ]\r\n  (loop [ls lst xs (set lst)]\r\n    (if (nil? (first ls))\r\n      (set xs)\r\n      (let [k (first (first ls))\r\n\t    nodes (node-list (first ls) lst)\r\n\t    newnodes (map (fn[m](println m)[k (second m)]) nodes)]\r\n\t(println newnodes)\r\n\t(recur (rest ls)\r\n\t       (concat xs newnodes)))))))", "problem": 84, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn [i-set]\r\n     ((fn transitive-closure\r\n         ([] (transitive-closure i-set (dec (count i-set))))\r\n         ([result i-count]\r\n          (if (zero? i-count)\r\n            result\r\n            (transitive-closure\r\n              (reduce\r\n                  (fn [current next] (reduce #(conj %1 %2) current next))\r\n                  result\r\n                  (map\r\n                   (fn [element]\r\n                       (let [[head tail] element]\r\n                         (map\r\n                           #(vector head (last %))\r\n                           (filter #(= (first %) tail) i-set))))\r\n                   result))\r\n              (dec i-count))))))\r\n     )", "problem": 84, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn [rel]\r\n  (letfn [(exp [r] \r\n            (let [m (into {} r)] \r\n              (->> (concat \r\n                     r \r\n                     (for [[k v] m] \r\n                       (when-let [nv (m v)] [k nv]))) \r\n                (filter identity) \r\n                (set))))\r\n          (ft [p [f & rs]] \r\n            (when rs\r\n              (if (p f (first rs))\r\n                f\r\n                (recur p rs))))]\r\n    (ft = (iterate exp rel))))", "problem": 84, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn [st]\r\n    (let [m (reduce #(assoc %1  (first %2)  (second %2)) {} st)\r\n          chains (map (fn [k]\r\n                        (loop [k k c []]\r\n                          (if (nil? (m k))\r\n                            (conj c k)\r\n                            (recur (m k) (conj c k))))) (keys m))]\r\n      (set (reduce concat [] (for [chain chains]\r\n                               (map vector (repeat (first chain)) (rest chain)))))))", "problem": 84, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(letfn\r\n  [(add-pair [m rel [a b]]\r\n     (into (conj rel [a b])\r\n       (for [c (m b)] [a c])))\r\n    \r\n   (make-map [rel]\r\n     (apply merge-with clojure.set/union\r\n       (for [[a b] rel] {a #{b}})))\r\n      \r\n   (one-step [rel]\r\n     (let [m (make-map rel)]\r\n       (reduce (partial add-pair m)\r\n         #{} rel)))]\r\n  (fn transitive [rel]\r\n    (let [new-rel (one-step rel)]\r\n      (if (= rel new-rel)\r\n        rel\r\n        (recur new-rel)))))", "problem": 84, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(letfn [(trans [[x1 x2] [y1 y2]] (if (= x2 y1) [x1 y2]))\r\n          (additional [xs]\r\n                      (for [x xs y (disj xs x)\r\n                            :let [t (trans x y)] :when t] t))]\r\n    (fn transitive [xs]\r\n      (loop [xs xs]\r\n        (let [next-xs (set (concat xs (additional xs)))]\r\n          (if (= xs next-xs) xs\r\n            (recur next-xs))))))", "problem": 84, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn closure [xs] (letfn [(next-first [val pair set]\r\n                            (first (filter #(= (first %) val)\r\n                                           (disj set pair))))\r\n\r\n                          (next-second [val pair set]\r\n                            (first (filter #(= (second %) val)\r\n                                           (disj set pair))))\r\n\r\n                          (pair [set]\r\n                            (first test))\r\n\r\n                          (another [val pair]\r\n                            (if (= (first pair) val)\r\n                              (second pair)\r\n                              (first pair)))\r\n\r\n                          (make-pair [pair1 test]\r\n                            (let [val (second pair1)\r\n                                  pair2 (next-first val  pair1 test)]\r\n\r\n                              (if pair2\r\n                                [(another val pair1) (another val pair2)]\r\n\r\n                                (let [val (first pair1)\r\n                                      pair2 (next-second val  pair1 test)]\r\n                                  (when pair2\r\n                                    [(another val pair2) (another val pair1)])))))\r\n                          (make-set [set]\r\n                            (into set (loop [xs set acc #{}]\r\n                                        (let [x (first xs)]\r\n                                          (if (seq xs)\r\n                                            (recur (next xs) (conj acc (make-pair x set)))\r\n                                            acc)))))]\r\n                    (-> xs make-set make-set (disj nil))))", "problem": 84, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn [l]\r\n  (let [m (into {} l)]\r\n    (set\r\n      (mapcat \r\n          #(loop [x % a []]\r\n            (if (m x)\r\n              (recur (m x) (conj a [% (m x)]))\r\n              a))\r\n        (keys m)))))", "problem": 84, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn [col] \r\n  (letfn \r\n    [(close-with [p rel]\r\n      (remove nil? \r\n        (map #(if (= (second p) (first %))\r\n        [(first p) (second %)]\r\n        nil) rel)))]\r\n     (loop [cur col]\r\n       (let [iter (reduce clojure.set/union cur \r\n                     (for [p cur] (close-with p cur)))]\r\n        (if (= iter cur)\r\n          iter\r\n          (recur iter))))))", "problem": 84, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn [relation]\r\n  (letfn [(expand [r] \r\n            (let [m (into {} r)] \r\n              (->> (concat \r\n                     r\r\n                     (for [[k v] m] \r\n                       (when-let [nv (m v)] [k nv]))) \r\n                (filter identity) \r\n                set)))\r\n          (first-consecutive [pred [f & rs]] \r\n            (when rs\r\n              (if (pred f (first rs))\r\n                f\r\n                (recur pred rs))))]\r\n    (first-consecutive = (iterate expand relation))))", "problem": 84, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "#(letfn [(c[t] \r\n           (into #{}\r\n             (remove nil?\r\n               (for [[e f :as x] % [g h :as y] t]\r\n                 (cond (= x y) x\r\n                       (= f g) [e h])))))]\r\n  (c(c %)))", "problem": 84, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn [coll] (letfn [\r\n(fc [s cl]\r\n     (let [n (first (filter (fn [[f l]] (= f (last s))) cl))]\r\n       (if (seq n)\r\n         (concat n (fc n cl)))))\r\n\r\n(allss [x] (let [ct (count x) x (vec x)]\r\n  (for [\r\n    i (range ct)\r\n    j (range (inc i) ct)\r\n   ] [(x i)(x j)])))]\r\n\r\n(into #{} (mapcat (fn [e] (let [fce (distinct (fc e coll))]\r\n              (if (seq fce)\r\n                  (allss (concat [(first e)] fce))\r\n                  [e]))) coll))))", "problem": 84, "user": "4daa374930acd6ed13482a68"}, {"code": "#(nth\n  (iterate\n    (fn [relation]\n      (set (for [[a b] relation [c d] relation\n        :when (or (= [a b] [c d]) (= b c))] [a d]))) %) 20)", "problem": 84, "user": "4e28120f535deb9a81d77efa"}, {"code": "(fn transclo [s]\n  (let [new-s (set\n               (apply concat\n                      (for [[a b] s]\n                                   (into [[a b]]\n                                         (for [[c d] s :when (= c b)] [a d])))))]\n    (if (= s new-s)\n      new-s\n      (recur new-s))))", "problem": 84, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn tc [coll]\n  (let [tc-expand\n          (fn [x coll]\n            (map (fn [z] (vector (first x) (second z)))\n              (filter (fn [y] (= (second x) (first y))) coll)))] \n  (loop [c1 #{} c2 coll]\n    (if (= c1 c2) c1\n      (recur c2 (clojure.set/union \n        (set (apply concat (map #(tc-expand % c2) c2)))\n        c2))))))", "problem": 84, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn alltc [xs] \n  (reduce \n    (fn tranclo [ret initk]\n      (loop [ret ret k initk xs (into {} xs)] \n        (if (and (seq (find xs k)) (not= initk (val (find xs k))))\n          (recur (conj ret (vector initk (val (find xs k)))) (val (find xs k)) xs)\n          ret))) \n    #{} (keys (into {} xs))))", "problem": 84, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn transitive-set\n  ([s] (transitive-set (list* s) [] 0 () (count s) true))\n  ([init transitive counter current starting-point first-round]\n    (if (= 0 (count init)) (let [new-init (set transitive)] (println \"new-init: \"  new-init)(if (= (count new-init) starting-point) new-init (recur (list* new-init) [] 0 () (count new-init) true)))\n      (if first-round \n        (if (= counter (count init)) (transitive-set init transitive 0 current starting-point false)\n          (if (= (first current) (second (nth init counter)))\n            (transitive-set init (conj transitive [(first (nth init counter)) (second current)]) (inc counter) current starting-point first-round)\n            (transitive-set init transitive (inc counter) current starting-point first-round)))\n        (if (= counter (count init)) (transitive-set (rest init) (conj transitive (first init)) 0 (first init) starting-point true)\n          (if (= (first (nth init counter)) (second current))\n            (transitive-set init (conj transitive [(first current) (second (nth init counter))]) (inc counter) current starting-point first-round)\n            (transitive-set init transitive (inc counter) current starting-point first-round)))))))", "problem": 84, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [relations]\n  (let [rights (zipmap (map last relations) (map first relations))\n        sorted-keys (reverse (sort (keys rights)))\n        ]\n    (letfn [(build-rels [k orig-k]\n              (if (rights k)\n                (conj (build-rels (rights k) orig-k) [(rights k) orig-k])\n                #{}))]\n      (reduce clojure.set/union (map #(build-rels % %) sorted-keys)))))", "problem": 84, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn f [s]\n  (#(if (= % s) % (f %))\n   (into s\n         (for [[a b] s, [c d] s\n               :when (= c b)]\n           [a d]))))", "problem": 84, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [pairs]\n  (letfn [(grow [pairs]\n  \t(set (concat pairs\n\t\t\t     (for [[a1 b1] pairs\n\t\t\t\t   [a2 b2] pairs\n\t\t\t\t   :when (= b1 a2)]\n\t\t\t       [a1 b2]))))]\n    (loop [last pairs]\n      (let [new (grow last)]\n\t(if (= (count new) (count last))\n\t  (set last)\n\t  (recur new))))))", "problem": 84, "user": "4e513ecf535dc968683fc4f6"}, {"code": "#(let [g (into {} %)]\n   (set (for [k (keys g),\n              p ((fn t [k]\n                   (when-let [p (g k)]\n                     (cons p (t p)))) k)]\n          [k p])))", "problem": 84, "user": "4e52d815535d302ef430da77"}, {"code": "(fn [c]\n  (set\n    (mapcat \n      (fn [i]\n        (map \n          (fn [j] [(first i) j])\n          (loop [r [] n (first i)]\n            (let [k (get (reduce into (map (partial apply hash-map) c)) n)]\n              (if k (recur (conj r k) k) r))))) c)))", "problem": 84, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn transitive-closure [R]\n  (let [elements (set (reduce concat R))\n        R+ (set (remove R (for [s1 elements s2 elements s3 elements :when (and (R [s1 s2]) (R [s2 s3]))] [s1 s3])))]\n    (if (empty? R+) R (recur (into R R+)))))", "problem": 84, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [s]\n  (letfn [(clojure [s]\n    (apply conj s (for [[a b] s, [c d] s :when (= b c)] [a d])))]\n  (nth (iterate clojure s) (count s))))", "problem": 84, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn f [s]\n  (#(if (= % s) s (f %))\n   (set (for [[a b] s [c d] s]\n          [a (if (= b c) d b)]))))", "problem": 84, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn[a-set]\n  (letfn[\n     (rel-to-map[r a-set]\n        (let [succ-map (apply merge-with (comp vec concat) (map (fn[[k v]] (hash-map k [v])) a-set))\n              ks (keys succ-map)]\n          (assoc succ-map r ks)))\n     (tc-rec[pred succ-map tr]\n         (let [childr (succ-map (last pred))]\n           (if (empty? childr)\n             (let [idxd (keep-indexed (fn[i it] [i it]) pred)]\n               (swap! tr concat (for [x idxd y idxd :when (< (first x) (first y))] [(second x) (second y)])))\n             (doseq [child childr]\n               (tc-rec (conj pred child) succ-map tr)))))]\n        (let [r (gensym \"r\")\n              succ-map (rel-to-map r a-set)\n              tr (atom #{})\n              ret (tc-rec [r] succ-map tr)]\n          (set (remove #(= r (first %)) @tr)))))", "problem": 84, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn t [v]\n  (let [r (set (concat v \n            (for [[a b] v [c d] v\n              :when (= b c)] [a d])))]\n    (if (= v r) v (t r))))", "problem": 84, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "#(loop [m % s 0]\n            (if (= s (count m))\n                m\n              (recur (into m (for [[a b] m [c d] m \n                                   :when (= b c)]\n                                  [a d]))\n                     (count m))))", "problem": 84, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [rel]\n  (reduce clojure.set/union\n    (take (count rel)\n       (iterate\n         (partial \n           (fn [R S]\n             (set (let [left (lazy-seq (map #(% 0) R))\n              right (lazy-seq (map #(% 1) S))\n              field (lazy-cat (map #(% 1) R) (map #(% 0) S))]\n              (keep (fn [[i k j]] (if (and (contains? R [i k]) \n                                           (contains? S [k j])) \n                                      [i j] \n                                      nil)) \n                     (for [i left j right k field] [i k j])))))\n           rel) rel))))", "problem": 84, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [s]\r\n  (let [\r\n        c (fn [a b] (if (= (second a)(first b)) (vector (first a) (second b)) a ))\r\n        it (fn [ss] (set (for [s1 ss s2 ss] (c s1 s2))))\r\n        ]\r\n    (ffirst\r\n  \t\t(drop-while #(not= (first %) (second %)) \r\n\t\t\t      (apply partition 2 1 \r\n\t\t                        (#(list % (rest %)) (iterate it s)))))\r\n  ))", "problem": 84, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn transitive-closure [br]\n  (let [br (reduce (fn [m [k v]] (assoc m k v)) {} br)]\n    (loop [[k & ks] (keys br), tc #{}]\n      (if k\n        (recur ks (loop [x k, tc tc]\n                    (if-let [y (br x)]\n                      (recur y (conj tc [k y]))\n                      tc)))\n        tc))))", "problem": 84, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "#(reduce\n    (fn [r [a b]]\n      (into r (for [[c d] r :when (= b c)] [a d])))\n    %\n    %)", "problem": 84, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [binary-relations]\n  [binary-relations]\n  (let [sort-relations\n        (fn sort-relations[relations]\n          (when (seq relations)\n            (let [vals (set (map second relations))\n                  top (remove #(vals (first %)) relations)]\n              (concat top (sort-relations (filter #(vals (first %)) relations))))))]\n    (->> ((fn build-transitive-closure\n            [results relations]\n            (if (seq relations)\n              (let [[a b] (first relations)\n                    results (build-transitive-closure\n                             (update-in results [a] (fnil conj #{}) b)\n                             (rest relations))]\n                (update-in results [a] into (get results b)))\n              results)) {} (sort-relations binary-relations))\n         (mapcat\n          (fn [[k vs]] (map (partial vector k) vs)))\n         (set))))", "problem": 84, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn t-closure [relset]\n  (letfn [(add-trans [rset rel]\n            (let [start (first rel)\n                  conn (second rel)]\n              (->> rset\n                   (filter #(= conn (first %)))\n                   (map #(vector start (second %)))\n                   (#(if (seq %)\n                       (apply conj rset %)\n                       rset)))))]\n    (loop [relset relset\n           last-count (count relset)]\n      (let [new-set (reduce add-trans relset relset)\n            new-count (count new-set)]\n        (if (= new-count last-count)\n          new-set\n          (recur new-set new-count))))))", "problem": 84, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn c[r](    \n  let [s \n    (set (concat\n    \t(for \n      \t[x r y r :when (= (second x) (first y))]  \n      \t[(first x) (second y)]\n    \t)\n  \t r))]\n  \t(if (= (count s) (count r))\n  \t\ts\n  \t\t(c s)\n  \t)\t\n  )\n  \n)", "problem": 84, "user": "4e6df3c9535d5021c1a895fa"}, {"code": "(fn [tuples]\n  (loop [[left right :as current] (first tuples)\n         others (disj tuples current)\n         rest-tuples others\n         result #{current}]\n    (let [referenced (first (filter #(= (first %) right) others))]\n      (if referenced\n          (recur [left (second referenced)]\n                 others\n                 rest-tuples\n                 (conj result [left (second referenced)]))\n          (if (empty? rest-tuples)\n              result\n              (let [next (first rest-tuples)]\n                (recur next\n                       (disj tuples next)\n                       (disj rest-tuples next)\n                       (conj result next))))))))", "problem": 84, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [s]\n  (letfn [\n    (f [s [k v]] \n      (reduce (fn [s [_ v]] (conj s [k v])) s (filter (fn [[k _]] (= k v)) s)))]\n    (reduce f s s)))", "problem": 84, "user": "4e7db3b4535db169f9c796e1"}, {"code": "#(set (mapcat\r\n        (fn f [[a b :as p] s]\r\n          (cons p\r\n                (mapcat (fn [[c d]]\r\n                          (if (= c b)\r\n                            (cons [a d] (f [a d] (disj s p)))))\r\n                        s)))\r\n        %\r\n        (repeat %)))", "problem": 84, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn transitive-closure [rels]\n  (let [\n  new-bg (fn []\n    { :relations {}, :inverses {} })\n  add-rel (fn [bg [x y]]\n    (let [left (bg :relations)\n          right (bg :inverses)\n          new-rels (concat [[x y]]\n                           (map #(vector % y) (right x))\n                           (map #(vector x %) (left y)))\n          assoc-multi (fn [map [x y]]\n            (if (contains? map x)\n              (assoc map x (conj (map x) y))\n              (assoc map x #{y})))\n          assoc-multi-inv (fn [map [x y]]\n            (assoc-multi map [y x]))]\n      (if (and (contains? left x) (contains? (left x) y))\n        bg\n        { :relations (reduce assoc-multi left new-rels)\n          :inverses (reduce assoc-multi-inv right new-rels) })))\n  bg-from-rels (fn [rels]\n    (reduce add-rel (new-bg) rels))\n  vectors-from-mappings (fn [[k vs]]\n    (reduce #(cons [k %2] %1) '() vs))\n  rels-from-bg (fn [bg]\n    (reduce #(reduce conj %1 (vectors-from-mappings %2)) #{} (bg :relations)))\n  ]\n  (->> rels (bg-from-rels) (rels-from-bg))))", "problem": 84, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [s]\r\n  (let [f #(->> % sorted-set (apply vec))\r\n        r (f (map first s))\r\n\t\t    c (f (map last s))\r\n\t\t    ks (f (concat r c))]\t\t\r\n           (reduce\r\n\t\t        (fn [st [i j k]] \r\n\t\t          (if  (and (contains? st [i k]) (contains? st [k j]))\r\n\t\t          (into st [[i j]]) st))\t\t       \r\n\t\t         s\r\n\t\t        (for [i r\r\n\t                j c\r\n\t\t              k ks] [i j k]))))", "problem": 84, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [rel]\n  (let [es (apply merge-with clojure.set/union\n             (map (fn [[a b]] {a #{b}}) rel))]\n    (set (mapcat (fn [a] (map #(vector a %)\n                              ((fn rs [b] (mapcat #(cons % (rs %)) (es b))) a)))\n                 (keys es)))))", "problem": 84, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn trans-closure [br]\n   (letfn [(follow [m]\n             (let [new (merge-with (fn [a b] (set (mapcat #(if-let [v (m %)] (set (concat b v)) (set b)) b))) m m)]\n               (if (= new m) m (follow new))))]\n     (set (mapcat (fn [[k v]] (map (fn [b] [k b]) v))\n                  (follow (reduce (fn [m [k v]] (assoc m k #{v})) {} br))))))", "problem": 84, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn tc [s] \n  (let [ children (reduce   \n                   #(assoc %1 (first %2) (cons (second %2) (%1 (first %2)))) {} \n                    (seq s))\n\n         descendents (fn d [x] \n                     (concat (children x) \n                             (mapcat d (children x)))) ]\n\n     (set (mapcat \n               #(for [ d (descendents %) ] [% d]) \n               (keys children)))))", "problem": 84, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn [s]\r\n  (set (reduce (fn [s [front back :as rel]]\r\n    (let [der (filter (comp not nil?)\r\n                (map (fn [[f b]] (when (= back f) [front b]))\r\n                     s))]\r\n      (concat s der [rel])))\r\n    s s)))", "problem": 84, "user": "4e8681b7535dae1a5effa438"}, {"code": "{#{[8 4] [9 3] [4 2] [27 9]} #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}\n  #{[\"cat\" \"man\"] [\"man\" \"snake\"] [\"spider\" \"cat\"]} #{[\"cat\" \"man\"] [\"cat\" \"snake\"] [\"man\" \"snake\"]\n       [\"spider\" \"cat\"] [\"spider\" \"man\"] [\"spider\" \"snake\"]}\n         #{[\"father\" \"son\"] [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]}\n           #{[\"father\" \"son\"] [\"father\" \"grandson\"]\n       [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]}}", "problem": 84, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [aset]\n (let [tmp (apply hash-map (flatten (apply list aset)))]\n\n(set (apply concat (map \n  ; break transitive list into closure pairs\n  #(apply (fn [item & stuff] (map vec (map (partial cons item) (map list stuff)))) %)\n  (map \n    ; build full transitive list\n    (fn it [item] \n      (if (nil? (tmp (last item)))\n        item\n        (it (conj item (tmp (last item))))))\n    (map vector (keys tmp))))))))", "problem": 84, "user": "4e98a6d0535dbda64a6f6b5e"}, {"code": "#(nth (iterate % %2) 3)\n\n#(into % (for [[a b] % [c d] % :when (= b c)] [a d]))", "problem": 84, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [r]\n  (let [closure (fn [f i] (loop [x i] (if (= (f x) x) x (recur (f x)))))]\n    (closure #(reduce (fn [coll [x y]]\n                        (let [y2 (some (fn [[x2 y2]] (and (= y x2) y2)) coll)]\n                          (if y2 (conj coll [x y2]) coll)))\n                      % %)\n             r)))", "problem": 84, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [rel]\n  (let [trans (set\n                (for [[a b] rel [c d] rel]\n                  [a (if (= b c) d b)]))\n        done (= trans rel)]\n      (if done trans (recur trans))))", "problem": 84, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn trans-cls [s]\n  (letfn [(child-nibs [m wl-raw p]\n            (let [wl (clojure.set/difference wl-raw #{p})\n                  children (clojure.set/intersection wl (m p))]\n              (reduce\n                (fn [s k] (clojure.set/union\n                            (conj s k)\n                            (child-nibs m wl k)))\n                #{} children)))]\n    (let [m (reduce (fn [a [k v]] (assoc a k (conj (a k #{}) v))) {} s)\n          wl-init (set (flatten (vec s)))]\n      (reduce\n        (fn [s k]\n          (apply conj s (map (partial vector k) (child-nibs m wl-init k))))\n        #{} (keys m))\n      )))", "problem": 84, "user": "4e89ddf9535d3e98b8023284"}, {"code": "(fn tc [s]\n  (loop [rv s]\n    (let [tmp (apply conj rv\n                (for [x rv y rv :when (= (second x) (first y))]\n                  [(first x) (second y)]))]\n      (if (= rv tmp)\n        rv\n        (recur tmp)))))", "problem": 84, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [pairs]\n    (let [all (set (mapcat identity pairs))\n          m (merge \n              (into {} (for [i all j all] [[i j] (if (= i j) 0 1)]))\n              (into {} (for [p pairs] [p 0])) )]\n      (->> (for [k all i all j all] [i j k])\n        (reduce\n          (fn [m [i j k]]\n            (update-in m [[i j]] min (+ (m [i k]) (m [k j]))))\n          m)\n        (filter \n          (fn [[[i j] v]] (and (zero? v) (not= i j))))\n        (map first)\n        set\n        )))", "problem": 84, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn trans-closure [in-set]\r\n  (let [helper \r\n\t\t(fn trans-helper\r\n\t\t\t[seta]\r\n\t\t\t(letfn [(expand-pair [[f s]]\r\n\t\t\t\t\t\t\t\t(map #(vector f (second %)) (filter #(= (first %) s) seta)))]\r\n\t\t\t\t(set (concat seta (mapcat expand-pair seta)))))]\r\n\t\t(helper (helper in-set))))", "problem": 84, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn transitive-closure [rels]\r\n  (let [nodes (set (flatten (vec rels)))]\r\n    (set (mapcat (fn [nd]\r\n       (map (fn [p] [p nd])\r\n            (loop [to-check #{nd}, found #{}]\r\n              (let [parents (set (map first (filter rels (for [p nodes n to-check] [p n]))))]\r\n                (if (empty? parents) found\r\n                    (recur parents (into found parents)))))))\r\n       nodes))))", "problem": 84, "user": "4e994541535dbda64a6f6b64"}, {"code": "#(loop [s %]\n   (let [t (into s (for [[k v] s [l w] s :when (= v l)] [k w]))]\n     (if (= s t)\n       t\n       (recur t))))", "problem": 84, "user": "4e82f85d535db62dc21a62ce"}, {"code": "#(let [p (apply conj % (for [[x y] % [s t] % :when (= y s)] [x t]))] \n               (if (= % p) p (recur p)))", "problem": 84, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn [input]\n    (letfn [(find-next-gen [mset k]     ; Return list of values that match key\n              (let [found (filter #(= (first %) k) mset)]\n                (when (seq found)\n                  (map second found))))]\n      (loop [m input]\n        ;; for each key/value pair, find key/(list of (value of value))\n        (let [next-gen (filter second\n                               (map #(vector (first %) (find-next-gen m (second %))) m))\n              ;; next-gen contains ([key1 (val1 val2)] [key2 (val2 val3)])\n              next-gen-expanded (for [item next-gen\n                                      :let [k (first item)]\n                                      v (second item)]\n                                  (vector k v))\n              merged (into #{} (concat m next-gen-expanded))]\n          (if (= m merged) m\n              (recur merged))))))", "problem": 84, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn transitive-closure \n ([s remaining]\n (let [adj-list-uni (fn [g]\n   (let [nodes (set (mapcat flatten s))\n         nbs (fn [curr] \n            (mapcat (partial filter #(not= % curr)) \n              (filter #(= (first %) curr) s)))]\n            (zipmap nodes (map nbs nodes))))\n       adj (adj-list-uni s)\n       current (first remaining)\n       added (vec (map #(vector current %)(mapcat adj (adj current))))\n       new-s (if (empty? added) s (apply conj s added))]\n       (if current\n       (transitive-closure new-s (rest remaining)) s)))\n  ([s] (transitive-closure s (distinct (flatten(vec s))))))", "problem": 84, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [rel]\n  (comment \"Adapted from clojure.contrib.graph\")\n(letfn\n    [\n     (graph [ns es]\n       (let [nbrs (reduce\n                   (fn [m [u v]] (assoc m u (conj (get m u) v)))\n                   (zipmap ns (repeat #{}))\n                   es)]\n         {:nodes ns :neighbors nbrs}))\n     (neighbors [g n] ((:neighbors g) n))\n     (graph-walk [g start-nodes visited]\n       (let [s (seq (drop-while visited start-nodes))\n             n (first s)\n             ns (rest s)]\n         (when s\n           (cons n (graph-walk g\n                               (concat (neighbors g n) ns)\n                               (conj visited n))))))\n     (transitive-closure [g]\n       {:nodes (:nodes g)\n        :neighbors (into {}\n                         (for [u (:nodes g)]\n                           [u (graph-walk g [u] #{})]))})\n     (rel-to-graph [rel]\n       (let [ns (into #{} (flatten (seq rel)))]\n         (graph ns rel)))\n     (post-proc [g]\n       (comment \"The way I calculated trans. closure adds self-loops,\n         so I remove them.  This passes the unit tests, but I really\n         should replace any self-loops present in the original relation.\")\n       (set\n        (for [n (:nodes g), nbr (neighbors g n) :when (not= n nbr)]\n          [n nbr])))\n     ] \n  (-> rel rel-to-graph transitive-closure post-proc)))", "problem": 84, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn trans [s]\n  (let [find-all (fn [[a b] pt]\n                    (for [[_b c] (pt b)] \n                        [a c]))] \n    \n  (loop [acc s prev nil] ;; loop until no further changes\n    (if (= acc prev) acc\n    (let [pt (group-by #(first %) acc)]\n      (recur\n          (clojure.set/union acc \n            (set (apply concat\n              (for [x acc] (find-all x pt))))) acc))))))", "problem": 84, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn [rel]\n  (let [m (into {} rel)]\n    (nth (iterate #(into %\n                     (for [[a b] % :when (m b)]\n                       [a (m b)])) rel)\n      (count rel))))", "problem": 84, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(letfn [(subset? [x y] (every? y x))\n        (union [x y] (set (concat x y)))\n        (prod [r s] (set (for [x r y s] [x y])))\n        (join [r s] (for [[x1 y1] r [x2 y2] s :when (= y1 x2)] [x1 y2]))]\n  (fn tc [r]\n    (let [r2 (join r r)]\n      (if (subset? r2 r) r (tc (union r r2))))))", "problem": 84, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [col]\n  (let[generate-pair (fn generate-pair [values]\n          (if (= (count values) 2)\n              (set [values])\n              (clojure.set/union (set (for [x (rest values)] [(first values) x]  ))\n                                 (generate-pair (rest values)) )))\n\n          merge-pair (fn merge-pair [init-v values]\n          (loop[result init-v data values]\n            (if (empty? data) result\n                (let [itm (first data)]\n                  (cond (= (first itm)  (last result) ) (recur (conj result (last itm)) (rest data))\n                        (= (first result)  (last itm) ) (recur ( concat itm (rest result)) (rest data))\n                        :else (recur result (rest data)))))))\n          merge-all (fn merge-all [values]\n          (set (map #(merge-pair % values) values))\n          )\n          ]\n          (reduce clojure.set/union (map #(generate-pair %) (merge-all col)))\n       )\n  )", "problem": 84, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn f[x]\n  (let \n    [ g (into {} x )\n      y \n        (reduce \n          (fn [z [a b]] \n            (if (contains? g b) (into z [[a (g b)]]) z))\n          x \n          x)]\n    (if (= x y) x (recur y))))", "problem": 84, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "#(let [t-c\n         (fn t-c [s]\n           (set\n            (concat s\n                    (remove nil?\n                            (for [x s\n                                  y s]\n                              (when (= (second x) (first y))\n                                [(first x) (second y)]))))))]\n     ((comp first first) (drop-while (partial apply not=) (map list (iterate t-c %) (rest (iterate t-c %))))))", "problem": 84, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(fn q [e] (letfn [(f [x] (for [[a b] x [c d] x :when (= b c)] [a d]))] (let [e2 (set (f e))] (if (clojure.set/subset? e2 e) e (q (clojure.set/union e e2))))))", "problem": 84, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [rel-set]\n  (letfn [(close [rel k to-do]\n                 (let [add (fn [[m rem-to-do] v]\n                             (if (rem-to-do v)\n                               (let [[new-m new-to-do] (close m v (disj rem-to-do v))]\n                                 [(assoc new-m k (clojure.set/union (m k) (new-m v)))\n                                  new-to-do])\n                               [(assoc m k (clojure.set/union (m k) (m v))) rem-to-do]))] \n                   (reduce add [rel to-do] (rel k))))]\n         (loop [rel (reduce (fn [m [k v]]\n                              (assoc m k (conj (get m k #{}) v)))\n                            {}\n                            rel-set)\n                to-do (set (keys rel))]\n           (if (empty? to-do)\n             (set (mapcat (fn [[k vs]]\n                            (map (fn [v] [k v]) vs))\n                          (seq rel)))\n             (let [k (first to-do)\n                   [ext-rel rem-to-do] (close rel k (disj to-do k))]\n               (recur ext-rel rem-to-do))))))", "problem": 84, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "#((fn warshall [[v & vs] es]\n             (if v\n               (warshall vs (into es (for [[a b] es [c d] es :when (= b c)]\n                                       [a d])))\n               es))\n                 (vec (set (reduce (fn [vs [a b]]\n                                       (->> vs\n                                            (cons a)\n                                            (cons b)))\n                                   #{}\n                                   %)))\n                 %)", "problem": 84, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn f [y x]\n  (if-let [[a b] (first x)]\n    (f (into\n         (into\n           (conj y [a b])\n           (for [[c d] y :when (= b c)] [a d]))\n         (for [[c d] y :when (= a d)] [c b]))\n       (next x))\n    y))\n#{}", "problem": 84, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [s]\n  (->>\n    s\n    (map first)\n    (mapcat\n      (fn f\n        ([k] (f k k))\n        ([k q]\n          (if-let [[a b] (some #(when (= k (% 0)) %) s)]\n            (conj (f b q) [q b])\n            #{}))))\n    set))", "problem": 84, "user": "4ed69ea4535d10e5ff6f52e3"}, {"code": "(fn [s]\n  (loop [s s]\n    (let [newset (reduce conj s\n      (mapcat (fn [[a1 b1]] \n        (filter (complement nil?)\n          (map (fn [[a2 b2]]\n            (cond (= a1 b2) [a2 b1]\n                  (= b1 a2) [a1 b2]\n                  true nil)) s))) s))]\n      (if (= newset s)\n        s\n        (recur newset)))))", "problem": 84, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [pairs]\n    (->> pairs\n         (iterate (fn [found]\n                    (into pairs (for [[a b] found\n                                      [d e] found\n                                      :when (= b d)]\n                                  [a e]))))\n         (partition 2 1)\n         (filter (partial apply =))\n         ffirst))", "problem": 84, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn closure [rels]\n  (loop [rels rels]\n    (let [next-rels \n      (clojure.set/union\n        rels\n        (set (for [[a b] rels, [c d] rels :when (= b c)] [a d])))]\n      (if (= rels next-rels) \n          rels\n          (recur next-rels)))))", "problem": 84, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn f [s]\n  (#(if (= s %) % (f %))\n     (reduce (fn [a [x y]] \n               (into a (keep (fn [[u v]] (if (= u y) [x v])) s))) \n             s \n             s)))", "problem": 84, "user": "4ef49c2c535dced4c769f238"}, {"code": "(letfn [(assoc-set [m key val]\n           (if-let [vals (m key)]\n             (assoc m key (conj vals val))\n             (assoc m key #{val})))\n         (pairs-to-map [pairs]\n          (reduce (fn [m [x y]] (assoc m x #{y})) {} pairs))\n        (map-to-pairs [m]\n          (reduce (fn [xs [k s]] (reduce #(conj %1 [k %2]) xs (seq s))) #{} (seq m)))]\n  (fn [relations]\n    (map-to-pairs\n      (loop [end-relations (pairs-to-map (seq relations))\n             addition      {}\n             relations     (seq end-relations)]\n        (if (empty? relations)\n          (if (empty? addition)\n            end-relations\n            (recur (merge-with #(apply conj %1 %2) end-relations addition)\n                   {} (seq addition)))\n          (let [[[in outs] & more] relations]\n            (recur end-relations\n                  (reduce (fn [m out]\n                             (if-let [end-outs (end-relations out)]\n                               (reduce (fn [m val] (if-let [in-outs (end-relations in)]\n                                                      (if (in-outs val)\n                                                        m\n                                                        (assoc-set m in val))\n                                                      (assoc-set m in val)))  m end-outs)\n                               m))\n                          addition outs)\n                   more)))))))", "problem": 84, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn f [s] \n   (let [r (apply conj s (remove nil? (for [a s b s]                \n                                        (if (= (second a) (first b)) [(first a) (second b)]))))] (if (= r s) r (f r))))", "problem": 84, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn transitive-closure \n  [b-rel]\n  (let [values (concat (map first b-rel) (map second b-rel)) ]\n  (letfn [\n          (set-transitive [matrix kij]\n                          (let [ [k i j] kij]\n                           (if (and (= 1 (get-in matrix [i k])) (= 1 (get-in matrix [k j]))) \n                             (assoc-in matrix [i j] 1)\n                             matrix)))\n          \n          (init-map [matrix ki]\n                    (assoc-in matrix ki (if (contains? b-rel ki) 1 0)))\n\n          (read-matrix [matrix]\n                       (for [i values j values] (if (= 1 (get-in matrix [i j])) [i j])))]\n         \n          (let [init \n                (reduce init-map {}\n                        (for [k values i values] [k i]))]\n          (let [matrix  \n  \t\t          (reduce set-transitive init   \n\t\t\t                  (for [k values i values j values] [k i j]))]\n            \n            (set (remove nil? (read-matrix matrix))))))))", "problem": 84, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn transitive-closure [s]\n  (let [s2 (set (for [[a b] s [c d] s] \n                  [a (if (= b c) d b)]))]\n    (if (= s s2) \n      s\n      (transitive-closure s2))))", "problem": 84, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn [relat]\n  \n  (let [fixp (fn fixp [f x]\n    (let [res (f x)]\n      (if (= x res)\n       res\n        (fixp f res))))\n  \n    jump (fn [rel]\n      (let [vals (into #{} (flatten (seq rel)))\n        trans (for [a vals b vals c vals]\n          (when (and (get rel [a b]) (get rel [b c]))\n            [a c]))]\n        (into rel (remove nil? trans))))]\n(fixp jump relat)))", "problem": 84, "user": "4ef0eaef535dced4c769f211"}, {"code": "#(let [r (set (concat %\n  (for [[a b] % [c d] % :when (= b c)]\n                              [a d])))]\n          (if (= r %) r (recur r)))", "problem": 84, "user": "4f031eac535dcb61093f6a67"}, {"code": "#(let [n (apply conj %\n            (for [[a b] %\n                  [c d] %\n                  :when (= b c)]\n              [a d]))]\n    (if (= n %)\n      %\n      (recur n))\n  )", "problem": 84, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [s]\r\n  (let\r\n    [getnodes (fn [s] (distinct (reduce #(concat %1 %2) '() s)))\r\n     nodes (getnodes s)\r\n     size (.size nodes)\r\n     connected? (fn [s x y] (contains? s [(nth nodes x) (nth nodes y)]))\r\n     add (fn [s x y] (conj s [(nth nodes x) (nth nodes y)]))]\r\n    (loop [i 0 j 0 k 0 res s]\r\n      (if (= i size)\r\n        res\r\n        (if (= j size) (recur (inc i) 0 0 res)\r\n          (if (or (= k size) (not (connected? res i j)))\r\n            (recur i (inc j) 0 res)\r\n            (if (connected? res j k) (recur i j (inc k) (add res i k)) (recur i j (inc k) res))))))))", "problem": 84, "user": "4f03822f535dcb61093f6b03"}, {"code": "#(loop [r %]\n    (let [d (into r (for [[x y] r [p q] r :when (= y p)] [x q]))]\n      (if (= r d) r (recur d))))", "problem": 84, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [coll]\n  (loop [ret coll]\n    (let [new (apply conj ret (seq (for [[a b] ret [c d] coll :when (= b c)] [a d])))]\n      (if (= ret new)\n        ret\n        (recur new)))))", "problem": 84, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn __ [pares]\n   (let [cierre (fn cierre [s par]\n  \t\t       (let [[A B] par\n            \t\t n1 (set (filter #(= (first %1) B) s))\n            \t\t\t nuevos (map #(vector A (second %)) n1)]\n            \t\t\t\t (clojure.set/union s nuevos)))]   \n     (loop [p pares]\n       (let [p1 (reduce #(cierre %1 %2) p p)]         \n              (if (= p1 p) p1\n\t\t          (recur p1))))))", "problem": 84, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn prob-0084\n  [rels]\n\n  (let [add-tc-rel (fn add-tc-rel\n                     [rel p-map s-map]\n                     (let [[p s] rel\n                           rels (for [p-new (conj (p-map p) p)\n                                      s-new (conj (s-map s) s)]\n                                  [p-new s-new])\n        \n                           s-rels (map #(array-map (first  %) #{(second %)} ) rels)\n                           p-rels (map #(array-map (second %) #{(first  %)} ) rels)\n\n                           new-pm (apply merge-with into p-map p-rels)\n                           new-sm (apply merge-with into s-map s-rels)]\n        \n                       [new-pm new-sm]))\n        ]\n\n    (let [[p-map s-map] (reduce #(apply add-tc-rel %2 %1) [{} {}] rels)]\n      (into #{} (for [pred (keys s-map), succ (s-map pred)]\n                  [pred succ])))))", "problem": 84, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [relations-set]\n  (let [find-compatible\n        (fn [x]\n          (set (keep #(if (= (first %) (second x))\n                          [(first x) (second %)] nil) \n                      relations-set)))\n        get-second-degree \n        (fn [tmp-set] \n          (clojure.set/union\n            tmp-set\n            (reduce clojure.set/union \n            (map find-compatible tmp-set))))]\n    (loop [init relations-set\n           final (get-second-degree relations-set)]\n      (if (= init final) final\n          (recur final (get-second-degree final))))))", "problem": 84, "user": "4e49a7bb535dc968683fc4c6"}, {"code": "(fn [r]\n  (let [vmap (apply merge-with into \n          (map (fn [[v1 v2]] {v1 #{v2}}) r))\n        iter (fn [v] (loop [m v k (keys v)] \n                        (if (empty? k) m\n                          (recur\n                            (update-in m [(first k)]\n                              (fn [s] \n                                (reduce into s (map m s))))\n                            (rest k)))))\n        closure (loop [cur vmap]\n                  (let [nex (iter cur)]\n                    (if (= nex cur) cur\n                      (recur nex))))]\n    (set (mapcat (fn [[v n]] (map #(vector v %) n)) closure))))", "problem": 84, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [s]\n  (let [m (apply hash-map (flatten (apply list s)))]\n    (loop [m_ (rest m) e (first m) ret #{}]\n      (cond\n        (nil? e) ret\n        (ret e) (recur (rest m_) (first m_) ret)\n        (m (e 1)) (recur m_ [(e 0) (m (e 1))] (conj ret e))\n        :else (recur (rest m_) (first m_) (conj ret e))))))", "problem": 84, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn transitive-closure [rels]\n  (let [tc (reduce (fn [rs [a b]] (into rs (keep #(if (= b (first %)) [a (second %)]) rs))) rels rels)]\n    (if (= tc rels) tc (recur tc))))", "problem": 84, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn transitive-closure [s]\n  (let [new-set  (clojure.set/union s (for [[a b] s [c d] s :when (= b c)] [a d]))]\n    (if (= s new-set) s (transitive-closure new-set))))", "problem": 84, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [relations]\n  (let [relations (->> relations\n                    (map (fn [[k v]] {k [v]}))\n                    (apply merge-with conj))\n        children  (fn children [x]\n                    (when-let [kids (seq (get relations x))]\n                      (concat kids (mapcat children kids))))]\n    (set (for [x (keys relations)\n               c (children x)]\n           [x c]))))", "problem": 84, "user": "4f169a0f535d64f60314644c"}, {"code": "(fn [S] \n  (set (loop [p (seq S) q (map (fn [u] [u #{}]) S) h () ]\n         (let [t (atom [])\n               in? (fn [l u] (some #(= u (first %)) l))\n               c (fn [u v] (if (or (some #(= u %) p) (in? q u) (in? @t u)) \n                               nil \n                               (swap! t conj [u v] ) ))]\n            (doall (for [i p \n                         j q \n                         :let [x i, [y z] j] \n                         :when (and (not= x y) (not (z i)) ) ]                 \n                      (cond (= (first x) (second y)) (c [(first y) (second x)] #{x y})\n                            (= (first y) (second x)) (c [(first x) (second y)] #{x y})\n                            :else nil)) )\n            (if (not-empty @t)\n                (recur (concat p h) @t (map first @t))\n                (concat p h))))))", "problem": 84, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn transitive-closure [rel]\r\n    (letfn [(my-merger [coll1 coll2]\r\n              (merge-with clojure.set/union coll1 coll2))\r\n            (add-to-map [coll key val]\r\n              (my-merger {key val} coll))\r\n            (add-to-path [m]\r\n              (zipmap (map second m) (map #(list (first %)) m)))]\r\n      (let [init-map (reduce my-merger (map #(hash-map (first %) (hash-set (second %))) rel))]\r\n        (loop [keymap init-map queue rel]\r\n          (do\r\n            (println keymap)\r\n            (println queue)\r\n          (if-let [head (first queue)]\r\n            (if-let [val (get keymap (second head))]\r\n              (recur (add-to-map keymap (first head) val) (rest queue))\r\n              (recur keymap (rest queue)))\r\n            (apply hash-set (for [x keymap, y (second x)]\r\n                              (vector (first x) y)))))))))", "problem": 84, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn [i] (let [g (group-by first i)] (set (filter last (mapcat #(loop [j % result #{}] (if (nil? j) result (recur (last (first (g j))) (concat result [[% (last (first (g j)))]])))) (keys g))))))", "problem": 84, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn f [d]\n    (let [p (for [[a x] d [y b] d :when (= x y)] [a b])\n          g (into d p)]\n      (if (= g d) g (f g))))", "problem": 84, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [s] (let [m (into {} s)]\n       (loop [ks (keys m),k (first ks),v (m k),r #{}]\n\t\t(cond (m v) (recur ks k (m v) (conj r (vector k v)))\n\t\t      (empty? ks) r\n\t\t      :else (recur (next ks) (fnext ks) (m (fnext ks)) (conj r (vector k v)))))))", "problem": 84, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [prv st]\n   (if (= (count prv) (count st))\n     st\n     (recur st\n            (->> st\n                 (map (fn [[u l]]\n                        (reduce (fn [s [u2 l2]]\n                                  (if (= l2 u)\n                                    (conj s [u2 l])\n                                    s))\n                                [[u l]] st)))\n                 (apply concat)\n                 (set))))) #{}", "problem": 84, "user": "4eb02674535d7eef30807338"}, {"code": "(fn [xs]\n  (let [m (apply merge (map #(apply hash-map %) xs))\n        r (set (concat xs (filter #(last %) (map #(list (first %) (m (last %))) xs))))]\n    (if (= xs r) r (recur r))))", "problem": 84, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [s]\n  (set\n    (mapcat\n      #(reductions (fn [[a b] [a* b*]] [a ({a* b*} b b)])\n        % s)\n      s)))", "problem": 84, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn [pathset]\n  (let [nodes (distinct (mapcat identity pathset))\n        considering (for [k nodes i nodes j nodes] [k i j])\n        reduce-path (fn [pathset [k i j]]\n                      (if (and (pathset [i k]) (pathset [k j]))\n                        (conj pathset [i j])\n                        pathset))]\n    (reduce reduce-path pathset considering)))", "problem": 84, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn tc\n  ([s] (tc (seq s) #{}))\n  ([[[s e] & ss] r]\n    (let [fs (filter #(= s (last %)) r)\n          ls (filter #(= e (first %)) r)\n          nr (conj r [s e])\n          nr (concat nr (map #(list (first %) e) fs))\n          nr (concat nr (map #(list s (last %)) ls))]\n      (if ss \n        (recur ss nr) \n        (set nr)))))", "problem": 84, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [c r] \n  (let [m (reduce #(assoc % (%2 0) (%2 1)) {} r)] \n    (loop [o r n (c o)]\n      (let [p (into o (for [x o :when (m (x 1)) ] [(x 0) (m (x 1))]))]\n        (if (= (c p) n) p (recur p (c p)))))))\ncount", "problem": 84, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [arg]\r\n  (let [firsts (map first arg)\r\n        lasts (fn lasts [x]\r\n                (let [my-lasts (map last\r\n                                    (filter #(= x (first %)) arg))]\r\n                  (apply concat my-lasts (map lasts my-lasts))))\r\n        relations (fn [x]\r\n                    (let [my-lasts (lasts x)]\r\n                      (map #(vector x %) my-lasts)))]\r\n    (set (apply concat (map #(relations %) firsts)))))", "problem": 84, "user": "4eb66737535d7eef3080736b"}, {"code": "(fn [s]\n  (let [diff (filter identity (for [[a b] s [c d] s] (when (= b c) [a d])))]\n    (if-not (every? s diff)\n      (recur (into s diff))\n      s)))", "problem": 84, "user": "4e8b98fc535d65386fec2124"}, {"code": "(let [\n  cross (fn [relations]\n    (for [r1 relations\n          r2 relations\n          :let [mapping [(first r1) (second r2)]]\n          :when (and (= (second r1) (first r2)) (not (relations mapping)))] mapping))]\n\n  (fn [relations]\n    (if-let [new-relations (seq (cross relations))]\n      (recur (into relations new-relations))\n       relations)))", "problem": 84, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [relation]\r\n  (letfn [(directed-flood-fill-1 [r ptlist include-self]\r\n            (set\r\n             (concat (if include-self ptlist '())\r\n                     (mapcat (fn [pt]\r\n                               (mapcat (fn [e]\r\n                                         (cond\r\n                                          (= pt (first e)) (list (second e))\r\n                                          :else ())) r)) ptlist))))\r\n          (directed-flood-fill\r\n            ([ptlist]\r\n               (directed-flood-fill ptlist true))\r\n            ([ptlist first-entry]\r\n               (let [newlist (set (directed-flood-fill-1 relation\r\n                                                         ptlist (not first-entry)))]\r\n                 (if (= (set ptlist) newlist)\r\n                   newlist\r\n                   (recur newlist false)))))\r\n          (collect-lhs []\r\n            (map (fn [i] (first i)) relation))\r\n          (gen-closure [lhs rhs-list]\r\n            (map (fn [rhs] (vec (list lhs rhs))) rhs-list))\r\n          ]\r\n    (set (mapcat (fn [lhs] (gen-closure lhs (directed-flood-fill (list lhs))))\r\n                 (collect-lhs)))))", "problem": 84, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [coll]\n  (let [n (set (concat coll\n                 (mapcat (fn [[x1 x2]]\n                   (for [[y1 y2] coll\n                       :when (= y2 x1)]\n                   [y1 x2]))\n               coll)))]\n    (if (= n coll)\n      coll\n      (recur n))))", "problem": 84, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [s]\n           (reduce #(into % (for [[a b] % [c d] [%2] :when (= b c)] [a d])) s s))", "problem": 84, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [pairs]\n  (let [npairs\n  (reduce conj pairs\n    (for [x pairs y pairs \n        :when (and \n                (not (= x y))\n                (= (second x) (first y)))]\n      [(first x) (second y)]))]\n  (if (= pairs npairs) pairs (recur npairs))))", "problem": 84, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [s]\n  (loop [ac s [x y] (first s) s (next s)]\n    (if s\n      (recur (into ac (keep (fn [[a b]] \n                              (cond \n                                (= b x) [a y]\n                                (= a y) [x b])) ac)) \n              (first s) (next s))\n       ac)))", "problem": 84, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "#(let [m (into {} %)\n       n (into % \n               (for [[k v] m \n                     :let [t (m v)]\n                     :when (not (nil? t))]\n                 [k t]))]\n   (if (= n %)\n     n\n     (recur n)))", "problem": 84, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [r]\n  (->>\n   r\n   (iterate #(into % (for [[x y] % [y1 z] % :when (= y y1)] [x z])))\n   (partition 2)\n   (filter #(apply = %))\n   first first))", "problem": 84, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn transitive-closure [rels]\n  (let [new-rels (into rels (for [[a b] rels [c d] rels :when (= b c)]\n                              [a d]))]\n    (if (= rels new-rels)\n      rels\n      (transitive-closure new-rels))))", "problem": 84, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [s]\n  (let [m (into {} s)]\n    (letfn [(f [m k] (next (iterate #(m %) k)))\n            (g [m] (for [[k v] m]\n                (for [n\n                      (f m k)\n                      :while (not (nil? n))]\n  \t              [k n])))]\n      (set (apply concat (g m))))))", "problem": 84, "user": "4ede361a535d10e5ff6f5332"}, {"code": "(fn [x]\n  (reduce (fn [s k]\n    (into s\n      (for [[i _] s\n            [_ j] s\n            :when (and\n              (contains? s [i k])\n              (contains? s [k j]))]\n        [i j])))\n    x\n    (mapcat identity x)))", "problem": 84, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn trans-closure [rel-set]\n  (let [rel (into {} rel-set)\n        f   #(loop [k %, acc nil]\n               (if-let [v (rel k)]\n                 (recur v (conj acc [% v]))\n                 acc))]\n    (set (mapcat f (keys rel)))))", "problem": 84, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn [sets]\n  (loop [s sets]\n    (let [more (into s (for [[i1 i2] s, [j1 j2] s :when (= i2 j1)] [i1 j2]))]\n      (if (= (count s) (count more))\n        more\n        (recur more)))))", "problem": 84, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn maketrans [r]\r\n  (let [elems (set (flatten (seq r))),\r\n        rels (apply conj {} (map (fn [[k v]] [k (map second v)]) (group-by first r)))]\r\n        (println rels)\r\n    (letfn [(trans? [x y]\r\n              (or (some #(= y %) (rels x))\r\n                  (some #(trans? % y) (rels x))))]\r\n        (set (for [e1 elems e2 elems :when (trans? e1 e2)] [e1 e2])))))", "problem": 84, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn expandLink[wordseed]\r\n   (let[linkInfo  (reduce \r\n                     (fn[map newword]\r\n                       (let[k (first newword),\r\n                            v (first (rest newword) )]\r\n                           (assoc map k v )\r\n                       )                \r\n                     )  \r\n                     {}                    \r\n                     wordseed),         \r\n         topNodes   (let[vals (set (vals linkInfo))]\r\n                      (filter  \r\n  \t                     #(not (contains? vals %) )\r\n\t\t                     (keys linkInfo)\r\n\t\t                   )\r\n                      )\r\n         linksFn  (fn addLink[links]                                       \r\n                      (let[next (get linkInfo (first links))]\r\n                          (if (nil? next)\r\n                              links\r\n                          (addLink (cons next links) )  \r\n                        )\r\n                       )                      \r\n                    )\r\n         generLink (fn genLink[links]\r\n                      (if(empty? (rest links))\r\n                         []\r\n                         (let[other (rest links),\r\n                              head (first links)]\r\n                         (concat (genLink (rest links)) \r\n                                 (map #(vector % head)\r\n                                      other)\r\n                                 )\r\n                         )\r\n                        )\r\n                     )\r\n         ]\r\n      (println linkInfo)\r\n      (println topNodes)\r\n      (reduce #(apply conj %1 (generLink %2) )#{} \r\n              (map #(linksFn (list %)) topNodes) )\r\n     )\r\n   )", "problem": 84, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn transitive-closure [rels]\n  (letfn [(augment [rels]\n            (for [[x1 y1] rels\n                  [x2 y2] rels\n                  :when (and (= y1 x2) (not (rels [x1 y2])))]\n              [x1 y2]))]\n    (ffirst\n     (filter\n      #(apply = %)\n      (partition 2 1\n                 (iterate #(into % (augment %))\n                          rels))))))", "problem": 84, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(fn transitive-closure [relations]                                                                 \n  (let [relation-map (apply hash-map (flatten (seq relations)))                                      \n        transitives (fn ! [base key] (when key (cons [base key] (! base (relation-map key)))))]       \n    (set (reduce concat (for [[key val]  relation-map]                                               \n                      (transitives key val))))))", "problem": 84, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [s]\n  (let [out\n  (set (apply concat s\n  (map\n    (fn [r1]\n      (remove nil?\n        (map\n          (fn [r2]\n            (if (= (first r2) (last r1))\n               [(first r1) (last r2)]))\n          s))) s\n  )))]\n  (if (= s out) s (recur out))))", "problem": 84, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn p84 [pairs]\r\n  (let [find (fn find [k] \r\n\t\t\t       (let [next-keys (map second (filter (fn [[a b]] (= a k)) pairs))]\r\n\t\t\t       \t\t(reduce concat next-keys (map find next-keys))))\r\n\t\t  keys (map (fn [[a b]] a) pairs)]\r\n\t\t(->> (map (fn [a] (map (fn [b] [a b]) (find a))) keys)\r\n\t\t\t (apply concat)\r\n\t\t\t set)))", "problem": 84, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(let [f #(into % (for [[k1 v1] % [k2 v2] % :when (= v1 k2)] [k1 v2]))] (fn g [r] (if (= r (f r)) r (g (f r)))))", "problem": 84, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn [r]\n    (let [fmap (apply hash-map (flatten (seq r)))\n          smap (apply hash-map (flatten (map (fn [[f s]] [s f]) r)))\n          roots (filter #(not (smap %)) (map first r))]\n      (letfn [(p84h [root]\n                (if root  (cons root (p84h (fmap root)))))\n              (bt [[f & rem]]\n                (if f (concat (for [rr rem] [f rr]) (bt rem))))]\n        (set (apply concat (for  [a (for [r roots] (p84h r))] (bt a)))))))", "problem": 84, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn [x]\n  (letfn\n    [(combine [r1 r2]\n      (let [d2 (group-by first r2)]\n        (reduce into #{} (for [ [a b] r1 [_ c] (d2 b)] #{[a c]}))))\n     (combine-self [r]\n       (into (apply hash-set r) (combine r r)))\n     (fixpoint [f x]\n       (let [s (iterate f x)\n             ss (map vector s (rest s))]\n         (ffirst (filter (partial apply =) ss))))]\n\n     (fixpoint combine-self x)))", "problem": 84, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn trans-closure [s]\n  (let [sn (clojure.set/union s (for [[a b] s [c d] s :when (= b c)] [a d]))]\n    (if (= s sn) s (recur sn))))", "problem": 84, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn tc [st]\n  (let\n    [ mget  (fn mget  [mp ky] \n      (some #(if (= ky (first %)) (second %) false) mp)\n      )\n      set2\n    (reduce\n      (fn f [old new]\n        (if (mget old (second new))\n          (conj old [(first new) (mget old (second new))])\n          old\n        )\n      )\n      st\n      st\n    ) ]\n  (if (= (count set2) (count st)) st (tc set2))\n  )\n)", "problem": 84, "user": "4f8ea1f7e4b0d4e659cdde69"}, {"code": "(fn w [s]\r\n  (let [n (set (mapcat\r\n                 (fn [[x y]] (concat\r\n                   [[x y]]\r\n                   (keep (fn [[a b]] (if (= a y) [x b])) s)))\r\n                 s))]\r\n    (if (= s n) n (w n))))", "problem": 84, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [pairs]\n  (letfn [\n    (pack [pairs]\n      (reduce (fn [accum [k v]] (merge-with clojure.set/union accum {k #{v}}))\n              {} pairs))\n    (unpack [m]\n      (into #{} (for [[k vs] m, v vs] [k v])))\n    (close [m]\n      (into {} \n        (map (fn [[k v]] [k (apply clojure.set/union v (vals (select-keys m v)))])\n          m)))\n    (fixed-point [f arg] \n      (->> (iterate f arg)\n        (partition 2 1) \n        (some (fn [[a b]] (when (= a b) a)))))]\n  (->> pairs\n    pack\n    (fixed-point close)\n    unpack)))", "problem": 84, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn [coll]\r\n  (let [pairs (into {} coll)\r\n        children (set (vals pairs))\r\n        roots (remove children (keys pairs))\r\n        doit (fn [root] (let [chain (take-while #(not (nil? %)) (iterate #(pairs %) root))]\r\n                          (loop [[head & tail :as chain] chain chunks []]\r\n                            (if (empty? chain)\r\n                              chunks\r\n                              (recur tail (into chunks (map (fn [x] [head x]) tail)))))))]\r\n    (set (mapcat doit roots))))", "problem": 84, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn transitive-closure [relations]\n    (let [relmaps (for [[x y] relations] {x [y]})\n          relmap (apply merge-with into relmaps)\n          add-rel\n            (fn add-rel [rels [x y]]\n                (reduce add-rel (conj rels [x y]) (map #(vector x %) (relmap y))))\n        ]\n        (reduce add-rel #{} relations)\n    ))", "problem": 84, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn f [xs]\n   (loop [xs xs]\n     (let [new-xs (into xs (for [[a b :as x] xs, [c d :as y] xs\n                                 :when (not= x y)\n                                 :when (= b c)]\n                             [a d]))]\n       (if (= new-xs xs)\n         xs\n         (recur new-xs ))\n       )))", "problem": 84, "user": "4e9fd521535d7eef3080729a"}, {"code": "#(let [pairs (for [x % y % :when (= (x 1) (y 0))] [x y])\n       n (into % (for [[[a _] [_ c]] pairs] [a c]))]\n   (if (= n %) n (recur n)))", "problem": 84, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn transitive [relations]\n        (letfn [(parents [val] (map first (filter #(= val (second %)) relations)))\n                (merge [mp from to] (assoc mp to (clojure.set/union #{from} (mp to #{}) (mp from #{}))))\n                (unfold [[a b]] (map #(vector a %) b))\n                (go-up [res val] (->> (parents val)\n                                      (reduce #(go-up (merge % val %2) %2) res)))]\n               (->> (reduce into #{} relations)\n                    (reduce go-up {})\n                    (map unfold)\n                    (reduce into #{}))))", "problem": 84, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "#(reduce (fn [r [a b]] (into r (for [[c d] r :when (= b c)] [a d]))) % %)", "problem": 84, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn t [s]\n  (let [q (reduce #(merge-with concat %1 {(first %2) [(second %2)]}) {} s)\n        r (reduce (fn [s t]\n                    (apply merge-with\n                           (concat (list concat s)                                   \n                                   (map #(hash-map (first t)\n                                                   (get q %))\n                                        (second t)))))\n                  q\n                  q)\n        z (reduce #(apply conj\n                          (cons %1\n                                (map (fn [x] [(first %2) x]) (second %2))))\n                  #{} r)]\n    (if (= z s)\n      z\n      (t z))))", "problem": 84, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn transitive-closure [set-of-pairs]\r\n  (let\r\n    [num-pairs (count set-of-pairs)\r\n     new-relations (set (for [[a1 b1] set-of-pairs\r\n                              [a2 b2] set-of-pairs\r\n                              :when (= b1 a2)]\r\n                             [a1 b2]))\r\n     new-set (clojure.set/union set-of-pairs new-relations)\r\n     new-count (count new-set)]\r\n     (if (> new-count num-pairs)\r\n      (transitive-closure new-set)\r\n      new-set)))", "problem": 84, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [s]\n    (letfn \n      [(addedge [s [a b]]\n           (let \n             [s1\n              (reduce \n                (fn [s [c d]]\n                  (if (= d a)\n                    (conj s [c b])\n                    s)) \n                s \n                s)\n              s2 (reduce \n                   (fn [s [c d]]\n                     (if (= c b)\n                       (conj s [a d])\n                       s)) \n                   s1 \n                   s1)]\n             (conj s2 [a b])))]\n      (reduce addedge #{} s)))", "problem": 84, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [br]\n  (letfn [(itr [br]\n    (loop [br (set br) outer (seq br)]\n(if (seq outer)\n(let [[a b] (first outer)]\n(recur (into br (concat\n  (map (fn [[c d]] [a d])\n(filter (fn [[c d]] (= b c)) (rest outer)))\n(map (fn [[c d]] [c b])\n(filter (fn [[c d]] (= a d)) (rest outer)))))\n(rest outer)))\nbr)))]\n(first (first (filter (fn [[a b]] (= a b)) (map list\n(iterate itr br) (rest (iterate itr br))))))))", "problem": 84, "user": "4f9a0064e4b0dcca54ed6d03"}, {"code": "(fn [s]\n  (letfn [(t [[a b :as v] s]\n            (let [f (fn [[u d]] (filter (fn [[x y]] (= d x)) s))\n                  d (f v)\n                  o (concat d (mapcat f d))]\n              (map (fn [[x y]] [a y]) o)))]\n    (into s (mapcat #(t % s) s))))", "problem": 84, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn tr [s]\n  (reduce \n    (fn [ts paire]\n      (set (concat\n        [paire]\n        (map \n          #(vector (first paire) (second %))\n          (filter #(= (second paire) (first %)) ts)\n        )\n        (map \n          #(vector (first %) (second paire))\n          (filter #(= (first paire) (second %)) ts)\n        )\n        ts\n      ))\n    )\n    #{} s)\n)", "problem": 84, "user": "4f84400de4b033992c121c2e"}, {"code": "(letfn [(extensions [s]\n          (fn [[k v]]\n            (->> s\n                 (filter #(= v (first %)))\n                 (map (juxt (constantly k) second)))))\n        (step [[s _]]\n          (vector (->> s (mapcat (extensions s)) (into s))\n                  s))]\n  (comp ffirst\n        (partial drop-while (partial apply not=))\n        (partial iterate step)\n        (juxt identity (constantly nil))))", "problem": 84, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [pairs]\n  (let\n    [organize-pairs (fn organize-pairs [[flist & rlists] pair]\n      (prn flist rlists pair)\n      (cond\n        (not flist) [pair]\n        (= (last pair) (first flist)) (cons (cons (first pair) flist) rlists)\n        (= (first pair) (last flist)) (cons (conj flist (last pair)) rlists)\n        :else (cons flist (organize-pairs rlists pair))))\n     extract-pairs (fn [element-list]\n      (for [x (range (count element-list))\n            y (range (inc x) (count element-list))]\n        [(nth element-list x) (nth element-list y)]))\n     transitive-pairs (fn [element-lists]\n      (for [element-list element-lists]\n        (extract-pairs element-list)))]\n    (->>\n      (reduce organize-pairs [] pairs)\n      transitive-pairs\n      (apply concat)\n      set)))", "problem": 84, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [s]\n  (letfn [(f [v n] (set (map (fn [[_ y]] [(first n) y]) (filter (fn [[x _]] (= (second n) x)) v))))]\n    (reduce #(into % (f % %2)) s s)))", "problem": 84, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [s] \n  (some \n    (fn [[a b]] (when (= a b) a)) \n    (partition 2 1 \n      (iterate \n        #(into % \n          (for \n            [ [a b] % \n              [c d] % \n              :when (= b c)] \n            [a d])) \n        s))))", "problem": 84, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [s]\n    (let [f (fn [s]\n                (some\n                  (fn [v]\n                      (let [rel (filter\n                                  #(and (= (second v) (first %))\n                                        (not (s (list (first v) (second %))))) s)]\n                        (if (empty? rel)\n                          nil\n                          (list (first v) (second (first rel))))))\n                  s))]\n      (let [rel (f s)]\n        (if (nil? rel)\n          s\n          (recur (conj s rel))))))", "problem": 84, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [br]\n  (let [m (into {} br)]\n    (letfn [(bs [k] (if (m k) (cons [k (m k)] (bs (m k)))))]\n\t    (set (apply concat (for [[a b] br] (map #(list a (second %)) (bs a))))))))", "problem": 84, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [xs]\n  (let [add-binary (fn [[f1 s1] xs]\n          (reduce (fn [acc [f2 s2]]\n            (if (= s1 f2)\n              (conj acc [f1 s2])\n              acc)) #{} xs))]\n    (reduce (fn [acc x]\n              (reduce conj acc (add-binary x acc))) xs xs)))", "problem": 84, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn [hs]\n  (let [tree (apply merge-with concat\n               (map (fn [[a b]] {a [b]}) hs))]\n    (->>\n      (for [k (keys tree)]\n        (loop [hs (set (tree k))]\n          (let [n-hs (into hs (mapcat tree hs))]\n            (if (= n-hs hs)\n              (map (fn [%] [k %]) n-hs)\n              (recur n-hs)))))\n      (apply concat)\n      set)))", "problem": 84, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn f [s] \r\n    (let [n (fn [s] (mapcat \r\n                      (fn [[a b]] \r\n                        (map #(vector a %) \r\n                             (map second \r\n                                  (filter #(and (= b (first %)) (not= b (second %))) s)))) s))\r\n          ns (n s)\r\n          diff (apply disj (set ns) (set s))]\r\n      (if (empty? diff) \r\n        s\r\n        (set (f (concat s ns))))))", "problem": 84, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [rel]\n  (loop [pow rel acc rel]\n    (let [npow (set (for[[x y] pow [x0 y0] rel :when (= y x0)] [x y0]))\n          nacc (reduce (fn [s x] (if (s x) s (conj s x))) acc npow)]\n      (if (= nacc acc) acc\n          (recur npow nacc)))))", "problem": 84, "user": "4fb4b798e4b081705acca2af"}, {"code": "(fn [r]\n  (let [rmap (apply hash-map (mapcat (fn [[k v]] [v #{k}]) r))\n        step #(apply hash-map (mapcat (fn [[k v]] [k (apply clojure.set/union v (map % v))]) %))]\n    (->>\n      (loop [m (step rmap)]\n        (if (= m (step m))\n          m\n          (recur (step m))))\n      (mapcat\n        (fn [[k vs]]\n          (map (fn [v] [v k]) vs)))\n      (apply hash-set))))", "problem": 84, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn f [x]\r\n  (let [r first l last g  (fn [s]\r\n  \t(set (for [x s y s :when (or (= x y) \r\n                            (= (r x) (l y))\r\n                            (= (l x) (r y)))]\r\n        (cond\r\n             (= x y) x\r\n              (= (r x) (l y)) [(r y) (l x)]\r\n            (= (l x) (r y)) [(r x) (l y) ]))))\r\n\t\t\ty (g x)]\r\n\t\t(cond \r\n\t\t\t(= x y) y\r\n\t\t\t:else (f y))))", "problem": 84, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [s]\n  (loop [p s]\n    (let [q (reduce\n              (fn [a [x y]]\n                (into a (keep (fn [[u v]] (if (= y u) [x v])) a)))\n              p\n              p)]\n      (if (= p q) p (recur q)))))", "problem": 84, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [rel]\n  (let [all-pairs (for [x rel y rel] [x y])\n        trans-pairs (filter #(= (last (first %)) (first (last %))) all-pairs)\n        joins (into rel (map #(vector (first (first %)) (last (last %))) trans-pairs))]\n    (if (= joins rel)\n      rel\n      (recur joins))))", "problem": 84, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn q84 [s]\n  (letfn [\n    (edges [m [a b]]\n      (conj m [a (conj (if (contains? m a) (m a) #{}) b)]))\n    \n    (to-set [m]\n      (reduce \n        (fn [s [k v]]\n          (reduce #(into % [[k %2]]) s v))\n        #{}\n        m))\n\n    (found [m k]\n      (let [s (m k)]\n        (if (nil? s) nil\n          (reduce #(into % (found m %2)) s s))))\n    ]\n    (let [ nodes (reduce edges {} s) ]\n      (to-set (reduce #(conj % [%2 (found nodes %2)]) {} (keys nodes))))))", "problem": 84, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn tc [rel]\r\n  (let [pairs-to-add\r\n        (mapcat (fn [pair]\r\n                  (let [trans (filter #(= (first %) (second pair)) rel)\r\n                        new-pairs (map (fn [p] [(first pair) (second p)]) trans)]\r\n                    (filter (complement rel) new-pairs)))\r\n                rel)]\r\n    (if (empty? pairs-to-add)\r\n        rel\r\n      (recur (into rel pairs-to-add)))))", "problem": 84, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn [r]\n  (let [g (group-by first r)\n        m (apply concat\n                 (map\n                  (fn [x] (apply concat\n                                 (map\n                                  (fn [y] (map #(do [x (second %)])\n                                               (get g y)))\n                                  (map second (get g x)))))\n                  (keys g)))\n        next (if (set? r) (into r m) (into #{} r m))]\n    (if (= next r)\n      r\n      (recur next))))", "problem": 84, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn f [r]\n  (let [g (fn [e] (map second (filter #(= e (first %)) r)))\n        rr (set (mapcat #(let [[k v] %]\n                      (conj (map (fn [x] [k x]) (g v)) [k v])) r))]\n    (if (= r rr) r (f rr))))", "problem": 84, "user": "4fa30027e4b081705acca187"}, {"code": "(fn trans [z]\r\n   (let [c z\r\n         ex (set (mapcat (fn [x] ((fn get-next [e c] (set (filter #(not (= nil %)) (concat c (map (fn [x] (when (= (second e) (first x)) [(first e) (second x)] )) c))))) x c)) c))]\r\n     (if (= c ex) c (trans ex)))\r\n   )", "problem": 84, "user": "4ff07688e4b0678c553fc324"}, {"code": "(fn [coll]\r\n  (letfn [(f [s]\r\n            (let [m (into {} s)]\r\n              (reduce (fn [coll [k v]] (if (and (m v) (not (contains? s [k (m v)]))) (conj coll [k (m v)]) coll)) #{} s)))]\r\n    (loop [trans (f coll) s coll]\r\n      (if (= 0 (count trans))\r\n        s\r\n        (let [tc (into s trans)]\r\n          (recur (f tc) tc))))))", "problem": 84, "user": "4e79ff2a535db169f9c796a9"}, {"code": "(fn trclosure [x] \r\n    (reduce (fn [acc [a b]] \r\n              (clojure.set/union \r\n                (reduce #(conj %1 [a (second %2)]) acc (filter #(= (first %) b) acc))\r\n                (reduce #(conj %1 [(first %2) b]) acc (filter #(= (second %) a) acc))\r\n                )) x x))", "problem": 84, "user": "4feada56e4b0140c20fb9c11"}, {"code": "#(let [s (into % (for [[a b] % [c d] % :when (= b c)] [a d]))]\n  (if (= s %) s (recur s)))", "problem": 84, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn [rels]\n  (letfn [(rels-of [x]\n        (if-let [some-rels (for [[y z] rels :when (= x y)] z)]\n              (reduce into some-rels (map rels-of some-rels))\n              ()))\n\t  (rel-vec [x] (for [y (rels-of x)] [x y]))]\n    (set (mapcat rel-vec (for [[x y] rels] x)))))", "problem": 84, "user": "4fc67081e4b0ee37620e1813"}, {"code": "(fn trans [col]\n  (letfn [(close1 [col]\n            (set (concat col\n                         (for [[x y] col\n                               [x1 y1] col\n                               :when (= y x1)]\n                            [x y1]))))]\n    (let [col1 (close1 col)]\n        (if (= (count col) (count col1))\n            col1\n            (trans col1)))))", "problem": 84, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn [rs] (letfn [(preproc [l] (reduce mergestep (map (fn [[a b]] (hash-map a #{b})) l))) (mergestep [& ls] (apply merge-with #(reduce conj % %2) ls)) (next [n d] (if (> n 0) (recur (- n 1) (mergestep d (into {} (for [[k v] d] [k (set (mapcat d v))])))) d))] (into #{} (let [d (preproc rs)] (for [[k vs] (next (count d) d) vi vs] [k vi])))))", "problem": 84, "user": "4e7f4147535db966e863cc3d"}, {"code": "#(into #{} (reduce (fn [s [x y]] (concat s [[x y]]\r\n  (for [[a b] s :when (= b x)] [a y])\r\n  (for [[a b] s :when (= y a)] [x b]))) #{} %))", "problem": 84, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": ";; Repeat this step until no more edges are added:\n;;     For every pair of edges [u v] [v w], add edge [u w].\n\n(fn [edges]\n  (let [edges-to-add (fn [edges]\n                       (for [[u v] edges\n                             [w x] edges\n                             :when (= v w)]\n                         [u x]))]\n    (loop [p nil,\n           e edges]\n      (if (= e p)\n        e\n        (recur e (into e (edges-to-add e)))))))", "problem": 84, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn transitive-closure [set]\n  (letfn [(first-equals-second [pair1 pair2]\n            (= (first pair1) (second pair2)))\n          (expansions [set pair]\n            (map #(vector (first %) (second pair)) (filter (partial first-equals-second pair) (disj set pair))))\n          (expand [set]\n            (reduce into set (map (partial expansions set) set)))]\n    (let [expansion (expand set)]\n      (if (= set expansion)\n        expansion\n        (recur expansion)))))", "problem": 84, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn transclose [relation]                                                                                                                        \n    (loop [rel relation                                                                                                                            \n           builder #{}]                                                                                                                            \n      (println \"Relation: \" rel \" and builder: \" builder)                                                                                          \n      (if (empty? rel)                                                                                                                             \n        builder                                                                                                                                    \n        (let [fritem (first rel)                                                                                                                   \n              nextrel (disj rel fritem)                                                                                                            \n              [ky vl] fritem                                                                                                                       \n              forward (reduce                                                                                                                      \n                        #(conj %1 %2)                                                                                                              \n                        nextrel                                                                                                                    \n                        (map #(assoc % 0 ky) (filter #(= vl (first %)) nextrel)))                                                                  \n              backward (reduce                                                                                                                     \n                        #(conj %1 %2)                                                                                                              \n                        forward                                                                                                                    \n                        (map #(assoc % 1 vl) (filter #(= ky (second %)) nextrel)))]                                                                \n          (recur backward (conj builder fritem))))))", "problem": 84, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn gen-all-trans3 [s]\n    (letfn [(all [x s]\n      (letfn [(find-trans [x s]\n        (first (reduce #(conj % [(first x) (second %2)]) []\n        (filter #(= (second x) (first %1)) s))))]\n      (let [res (find-trans x s)]\n        (if (nil? res)\n            []\n            (conj (all res s) res)))))]\n   (set (concat (reduce #(concat % (all %2 s)) [] s) s))))", "problem": 84, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [s]\n  (let [head? (fn [itm] (not-any? #(= (first itm) (second %)) s))\n        heads (filter head? s)]\n    (letfn [(get-tail \n              [[i1 i2 :as h]]\n              (let [i (some #(when (= i2 (first %)) %) s)]\n                (if i \n                  (lazy-seq [h (get-tail i)])\n                  h)))]\n      (let [t (map #(-> % get-tail flatten distinct) heads)]\n        (letfn [(f [l ls] (if (empty? ls) nil (lazy-cat (map vector l (rest ls)) (f l (rest ls)))))]\n          (reduce #(into %1 (f %2 %2)) #{} t))))))", "problem": 84, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn tc [s]\n  (let [g (reduce ; \"grow\" the set\n            (fn [acc e]\n              (let [i (some #(if (= (second %) (first e)) %) acc)]\n                (if i (conj acc [(first i) (second e)])\n                    acc)))\n            s s)]\n    (if (= (count s) (count g)) ; loop until there's no more changes\n        s\n        (recur g))))", "problem": 84, "user": "500900dee4b0144d4f561e42"}, {"code": "(letfn [(trans [[a b] [c d]]\n                   (when (= b c)\n                     [a d]))\n            (pass [rel rels]\n                  (reduce \n                    (fn [acc item] \n                      (if-let [new-rel (trans rel item)]\n                        (conj acc new-rel)\n                        acc))\n                    rels\n                    (seq rels)))\n            (all-passes [rels]\n                        (into #{} (mapcat #(pass % rels) rels)))\n            (trans-clo [rels]\n                       (let [new-rels (all-passes rels)]\n                         (if (= rels new-rels)\n                           new-rels\n                           (recur new-rels))))]\n           trans-clo)", "problem": 84, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [relations]\n    (loop [prev-relations relations]\n      (let [result (into\n                     prev-relations\n                     (apply\n                       concat\n                       (for [[a1 b1 :as r1] prev-relations]\n                         (for [[a2 b2 :as r2] prev-relations\n                               :when (and (not= r1 r2)\n                                          (= b1 a2))]\n                           [a1 b2]))))]\n        (if (= result prev-relations)\n          result\n          (recur result)))))", "problem": 84, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn [s]                                                                                              \n  (letfn [(generate-transitive-closures [v]                                                        \n            (let [idx (zipmap v (range))]                                                \n              (for [a v b v :when (< (idx a) (idx b))]                                             \n                [a b])))                                                                           \n          (glue-relations [r1 r2]                                                                  \n            (cond                                                                                  \n              (= (last r1) (first r2)) (into r1 (rest r2))                                         \n              (= (last r2) (first r1)) (into r2 (rest r1))                                         \n              :else r1))                                                                           \n          (build-relation-vectors [rel]                                                            \n            (reduce glue-relations rel s))]                                                        \n    (reduce #(into % (generate-transitive-closures %2)) #{} (set (map build-relation-vectors s)))))", "problem": 84, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [s]\n  (let [\n    add (fn add [s p]\n      (reduce\n      #(cond\n           (= (p 0) (%2 1)) (conj %1 [(%2 0) (p 1)])\n           (= (p 1) (%2 0)) (conj %1 [(p 0) (%2 1)])\n           :else %1)\n      []\n      (conj s p)))]\n\n    (loop [from (apply vector s) to []]\n      (if (empty? from) (set to)\n          (recur \n            (distinct (concat (rest from) (add to (first from))))\n            (conj to (first from)))))))", "problem": 84, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn [r]\n  (letfn [(closure [v]\n            (let [ys (for [[x y] r :when (= x v)] y)]\n              (mapcat (fn [y] (cons y (closure y))) ys)))]\n    (set (mapcat (fn [x] (map (fn [y] [x y]) (closure x)))\n                 (apply concat r)))))", "problem": 84, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "problem": 84, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn a [t]\n  (set\n    (mapcat\n      (fn r [[k v]]\n        (conj (mapcat #(r [k (second %)]) (filter #(= v (first %)) t)) [k v]))\n      t)))", "problem": 84, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "#(let [c (fn [v] (into v (for [[x y] v [z t] % :when (= y z) ] [x t])))]\n      (loop [acc % prev #{}]\n        (if (= acc prev)\n          acc\n          (recur (c acc) acc))))", "problem": 84, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn transc [rel]\n  (loop [rem rel trans rel]\n    (let [[a b :as elem] (first rem)\n          rels (for [[x y] trans :when (= b x)] [a y])]\n      (if elem\n        (recur (into (rest rem) rels) (conj trans elem))\n        trans))))", "problem": 84, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [l]\r\n    (letfn [(tran [[e1 e2] els]\r\n              (remove nil? (map (fn [[x1 x2]] (when (= e2 x1) [e1 x2])) els)))]\r\n      (loop [x l]\r\n        (let [y (set (mapcat #(concat [%] (tran % x)) x))]\r\n        (if (= x y) x (recur y))))))", "problem": 84, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "#(loop [s %] (if-let [\r\n  trans (seq (keep identity\r\n          (for [[a b] s [c d] s :let [e [a d]]]\r\n            (if (and (= b c) (not (s e))) e))))]\r\n  (recur (into s trans))\r\n  s))", "problem": 84, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [s]\n  (let [f #(for [[a b] (seq %)\n                 [c d] (seq %)\n                 :when (= c b)] [a d])]\n    (->> s (iterate #(let [n (into % (f %))]\n                       (when (not= % n) n)))\n         (take-while identity)\n         (last))))", "problem": 84, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn [rs]\r\n  (let \r\n    [lclosure (fn [[a b]]\r\n                  \r\n                  (let \r\n                       [\r\n                        c-step (fn [[a b]] \r\n                             (->>\r\n                               rs\r\n                               (filter (fn [[c d]] (= c b)))\r\n                               (map (fn [[c d]] [a d]))))\r\n                        \r\n                        additions (fn [enclosed]\r\n                                       (into #{} \r\n                                       (apply concat\r\n                                       (for [x enclosed]\r\n                                         (c-step x)))))\r\n                        new-enclosed (fn [enclosed]\r\n                                        (into  enclosed (additions enclosed)))             \r\n                        \r\n                        ]\r\n                    ;(new-enclosed #{[a b]})))\r\n                      (loop [enclosed #{[a b]} ]\r\n                        (if (= (count enclosed)\r\n                           (count (new-enclosed enclosed)))\r\n                           enclosed\r\n                          (recur (new-enclosed enclosed))))))\r\n     ]\r\n    (reduce (fn [enclosed r] (into enclosed (lclosure r))) #{} rs)))", "problem": 84, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn [br]\n    (letfn [(rls [st [f s]]\n              (map (fn [[ef es]] (if (= es f) [ef s] [f es]))\n                   (filter #(or (= f (second %)) (= s (first %))) st)))]\n      (reduce #(into %1 (rls %1 %2)) br br)))", "problem": 84, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [s]\r\n  (reduce #(set (remove nil? (concat (conj % %2) (map (fn [x] (cond (= (first x) (second %2)) (vector (first %2) (second x))\r\n                                                       (= (second x) (first %2)) (vector (first x) (second %2)))) %)))) #{(first s)} (rest s)))", "problem": 84, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [relation] (loop [rel  (into {} (for [[k v] relation] [k #{v}]))]\r\n                         (let [newrel (reduce (fn [r x] (assoc r x (apply clojure.set/union (conj (for [val (r x)] (r val)) (r x))))) rel (keys rel))\r\n                               toSet (fn [clos] (into #{} (mapcat (fn [[k s]] (map #(vector k %) s)) clos)))]\r\n                           (if (= rel newrel) (toSet rel) (recur newrel))\r\n                           )))", "problem": 84, "user": "503d129fe4b06c4e0e1fa254"}, {"code": "(fn [r] \n  (letfn [ (f [ [a b] r] \n               (->>\n                 (filter #(= (first %) b) r)\n                 (map #(vector a (last %)))\n                 ))] \n         (let [x  (mapcat #(f % r) r)\n               y  (filter #(nil? (r %)) x )] \n           (if (empty? y) r (recur (into r y))))\n  ))", "problem": 84, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn tc [x]\n   (let [new (into x (for [[a b] x, [c d] x :when (= b c)] [a d]))]\n     (if (= (count new) (count x))\n       new\n       (recur new))))", "problem": 84, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [relations]\r\n  (letfn [(close [top source graph]\r\n\t\t\t(cond\r\n\t\t\t\t(nil? (graph source)) []\r\n\t\t\t\t:else (concat (map #(vector top %) (graph source)) (map #(close top % graph) (graph source)))\r\n\t\t\t)\r\n\t\t)]\r\n\t(let [graph (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) #{}) (second %2))) {} relations)]\r\n\t\t(into #{} (partition 2 (flatten (map #(close % % graph) (keys graph)))))\r\n\t)\r\n))", "problem": 84, "user": "504e685fe4b0f6ff3350c4ae"}, {"code": "(fn [e]\n  (letfn [(f [x] (for [[a b] x [c d] x :when (= b c)] [a d]))]\n         (let [e2 (set (f e))]\n           (if (clojure.set/subset? e2 e)\n               e\n             (recur (clojure.set/union e e2))))))", "problem": 84, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn [x] (let [r (into {} x)] \n(reduce #(apply conj %1 %2) #{} (for [[a b] r]\n                       (loop [k a acc #{}]\n                             (if-let [v (r k)]\n                                     (recur v (conj acc [a v]))\n                                     acc))))))", "problem": 84, "user": "4f614976e4b0defedf855fbb"}, {"code": "(fn [coll]\n  (->> coll\n       (iterate\n        #(set (for [[a b] %\n                    [c d] coll\n                    :let [r [a d]]\n                    :when (and (= b c) (not (contains? % r)))]\n                r)))\n       (take-while not-empty)\n       (apply concat)\n       set))", "problem": 84, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [relation]\n  (set (mapcat (fn expand [[a b]]\n                 (cons [a b]\n                       (mapcat (fn [[c d]] (expand [a d]))\n                               (filter (fn [[c d]] (= b c))\n                                       relation))))\n               relation)))", "problem": 84, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn clos [st] \n  (let [items-starting-by \n    (fn [start s]\n      (filter #(= start (first %1)) s))\n        apply-transitivity \n    (fn [item s]\n      (map \n        #(vector (first item) (last %1))\n        (items-starting-by (last item) s)))]\n    (let [res \n        (set (concat st\n          (mapcat \n            #(apply-transitivity %1 st)\n            st)))]\n        (if (= (count st) (count res))\n          st\n          (clos res)))))", "problem": 84, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(letfn [(transitive-from [[from to] relation]\n           (set \n            (into (list [from to])\n                  (mapcat (fn [[f t]]\n                            (transitive-from [from t]\n                                             (disj relation [f t])))\n                          (filter\n                           (fn [[f t]]\n                             (= to f))\n                           relation)))))]\n   (fn [relation]\n     (set\n      (mapcat (fn [v]\n                (transitive-from v\n                                 (disj relation v)))\n              relation))))", "problem": 84, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [xs]\n  (let [m (into {} xs)\n        r (reduce (fn [s [k v]] (if-let [v (m v)] (conj s [k v]) s)) xs xs)]\n    (if (= xs r) r (recur r))))", "problem": 84, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn tc\n  ([rels] (tc (seq rels) rels))\n  ([[rel & rrels] clos]\n   (if\n     (nil? rel) clos\n     (let [[lrel rrel] rel\n           new-pairs (for [[l r] clos :when (= rrel l)] [lrel r])]\n       (recur rrels (into clos new-pairs))))))", "problem": 84, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [x]\n  (let [my-merge? #(or (= (first %1) (last %2)) (= (last %1) (first %2)));\u5224\u5b9a\u662f\u5426\u80fd\u5408\u5e76\n        my-merge #(if (= (first %1) (last %2));\u8fdb\u884c\u5408\u5e76\n              (concat %2 (rest %1))\n            (concat %1 (rest %2)))\n        find-merge #(filter (partial my-merge? %1) %2);\u5bfb\u627e\u53ef\u5408\u5e76\u7684\u7ec4\n        merge-all (fn [src result];\u5408\u5e76\u6240\u6709\n          (if (empty? src);\u6e90\u5904\u7406\u7ed3\u675f\u5c31\u8fd4\u56de\u7ed3\u679c\n              result\n            (let [item (first src) temp (rest src) found (find-merge item temp)]\n              (if (empty? found)\n                  (recur temp (conj result item));\u4e00\u4e2a\u7ec4\u627e\u4e0d\u5230\u5176\u4ed6\u53ef\u548c\u5b83\u5408\u5e76\u7684\u7ec4\u7684\u65f6\u5019\uff0c\u5c31\u628a\u5b83\u52a0\u5165\u7ed3\u679c\n                (let [other (remove (set found) temp) news (reduce my-merge item found)]\n                  (recur (conj other news) result))))));\u5408\u5e76\u7ed3\u675f\u540e\uff0c\u518d\u653e\u56de\u6e90\u91cc\uff0c\u56e0\u4e3a\u5b83\u7684\u65b0\u7aef\u70b9\u8fd8\u6709\u53ef\u80fd\u5408\u5e76\n        split-all (fn [result src];\u628a\u5408\u5e76\u540e\u7684\u5927\u7ec4\u62c6\u5206\n          (if (= 2 (count src))\n              (conj result src)\n            (recur (concat result (map #(vector (first src) %) (rest src)))  (rest src))))]\n        (set (mapcat (partial split-all []) (merge-all x [])))))", "problem": 84, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn closure [pairs]\n  (let [new-pairs (into pairs (for [[a b] pairs, [c d] pairs :when (= b c)] [a d]))]\n    (if (= pairs new-pairs) pairs (recur new-pairs))))", "problem": 84, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn [s]\n(letfn [(sub [s]\n          (loop [[a & r] s acc ()]\n            (if a\n              (recur r (concat acc (map #(cons a [%]) r)))\n              acc)))\n        (getP [t s] (some #(when (= (first t) (second %)) %) s))\n\n        (getA [t s] (some #(when (= (last t) (first %)) %) s))]\n  (set (mapcat sub ((fn g [s acc]\n    ((fn f [o t s]\n      (let [[x y :as a] ((if o getA getP) t s)]\n        (if a\n          (f o (if o (conj t y) (cons x t)) (disj s a))\n          (if o\n            (f (not o) t s)\n            (if (empty? s) (conj acc t)\n                (g s (conj acc t)))))))\n     true (first s) (disj s (first s))))\n   s [])))))", "problem": 84, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [xs]\n  (set\n    (reduce\n      (fn [rs r]\n        (concat\n          (conj rs r)\n          (map #(vector (first r) (last %)) (filter #(= (last r) (first %)) rs))\n          (map #(vector (first %) (last r)) (filter #(= (first r) (last %)) rs))\n        )\n      )\n      #{}\n      xs\n    )\n  )\n)", "problem": 84, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn transitive-closure [sets]\n  (let [rels (reduce #(assoc %1 (first %2) (second %2)) {} sets)]\n    (apply clojure.set/union\n      (for [leader (keys rels)]\n        (set (loop [all-relations nil related (rels leader)]\n          (if related\n              (recur (cons [leader related] all-relations)\n                     (rels related))\n              all-relations)))))))", "problem": 84, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn transitive-closure [relations]\n  (reduce #(into %1\n                 (for [[k0 v0] %1\n                       [k1 v1] %1 :when (= %2 v0 k1)] [k0 v1]))\n          relations\n          (map first relations)))", "problem": 84, "user": "50586354e4b06522596eba78"}, {"code": "(fn [e]\n  (let [kp (fn [x] (keep #(if (= (first %) x) (second %)) e))\n        pair (fn [x s] (for [y s] [x y]))\n        n (remove empty? (mapcat #(pair (first %) (kp (second %))) e))\n        ne (into e n)]\n    (if (= e ne) e (recur ne))))", "problem": 84, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [relation]\n  (let [ conts (group-by first relation) ]\n    (loop [relation relation queue (seq relation)]\n      (if (empty? queue) relation\n        (let [\n          [[qa qb] & qs] queue, \n          joins (for [[_ cont] (conts qb)] [qa cont])\n          ]\n          (recur \n            (reduce conj relation joins)\n            (concat joins qs)))))))", "problem": 84, "user": "50901b2ee4b0ea685a20f774"}, {"code": "#(reduce\n  (fn [xset [a b]]\n    (clojure.set/union xset #{[a b]}\n      (set (map\n              (fn [[c d]]\n                (cond\n                  (= b c) [a d]\n                  (= d a) [c b]\n                  :else [a b]))\n              xset)))) #{} %)", "problem": 84, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": ";; @see Warshall-Floyd Algorithm\n(fn transitive-closure [binary-relations]\n  (let [s (distinct (flatten (seq binary-relations)))\n        size (count s)\n        arr (make-array Long size size)]\n    (doseq [[a b] binary-relations]\n      (aset arr\n            (.indexOf s a)\n            (.indexOf s b)\n            1))\n    (dotimes [k size]\n      (dotimes [i size]\n        (dotimes [j size]\n          (let [a (aget arr i j)\n                b (aget arr i k)\n                c (aget arr k j)]\n            (when (or (and (not a) b c)\n                      (and a b c (< a (+ b c))))\n              (aset arr i j (+ b c)))))))\n    (set (for [i (range size) j (range size)\n               :when (aget arr i j)]\n           [(nth s i) (nth s j)]))))", "problem": 84, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn transitive-closures [coll]\n  (letfn [(fsecond [x] (-> x first second))\n\t\t\t(res-func [x y ncoll coll res] \n\t\t\t(let [fir (ffirst ncoll) sec (fsecond ncoll)]\n\t\t\t\t(if (= y fir) (concat res [[x sec]] (relation x sec (remove #{fir sec} coll))) res)\n\t\t\t)) \t\n\t\t\t(relation [x y coll] \n\t\t\t\t(loop [ncoll coll res ()]\n\t\t\t\t\t(if (empty? ncoll) \n\t\t\t\t\t\tres \n\t\t\t\t\t\t(recur (rest ncoll) (res-func x y ncoll coll res))))\n\t\t\t)]\n\t\t(->> coll \n\t\t\t(#(for [[a b] %] (relation a b (remove #{[a b]} %)))) \n\t\t\t(apply concat) \n\t\t\t(concat coll) \n\t\t\t(into #{}))\n\t)\n)", "problem": 84, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn tclosure [coll]\n  (let [relations (into {} coll)]\n    (letfn \n      [(find-path [src]\n                  (loop [x src paths #{}] \n                    (if-let [dest (get relations x)]\n                      (recur dest (conj paths [src dest]))\n                      paths)))]\n      (reduce clojure.set/union\n              (for [elem (keys relations)] \n                (find-path elem))))))", "problem": 84, "user": "4fe9ef2fe4b0547ebccb2479"}, {"code": "(fn f [rel]\n (let [nrl (clojure.set/union\n            rel\n            (set (mapcat\n                  identity\n                  (keep (fn [[r s]]\n                          (reduce\n                           (fn [a [u v]] (if (= u s) (conj a [r v]) a))\n                           []\n                           rel))\n                        rel))))]\n   (if (= rel nrl)\n     rel\n     (f nrl))))", "problem": 84, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn trans-clojure [ls]\n  (letfn [(trans-next [ss]\n            (into ss\n                  (for [[f r :as s] ss\n                        [f' r'] (disj ss s)\n                        :when (= r f')]\n                    [f r'])))\n          ]\n    (let [ls' (trans-next ls)]\n      (if (= ls' ls)\n        ls\n        (recur ls')))))", "problem": 84, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn transitive-closure [coll]\n  (letfn [(paths [x coll]\n    (reduce\n      #(if (= (last x) (first %2))\n           (conj % (vector (first x) (last %2)))\n           %) #{} coll))]\n\n  (reduce #(set (concat % (paths %2 %)))(set coll) coll)))", "problem": 84, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn [s]\n    (let [related (fn  [s [l r]]\n                    (for [[l' r'] s\n                          :when (= l' r)]\n                      [l r']))]\n      (reduce (fn [acc el]\n                (into acc (related acc el)))\n              s\n              s)))", "problem": 84, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [xs]\r\n  (let [graph (into {} xs)\r\n        dfs (fn [[k v]]\r\n              (loop [c v, acc [[k v]]]\r\n                (if (graph c)\r\n                  (recur (graph c) (conj acc [k (graph c)]))\r\n                   acc)))]\r\n    (set (mapcat dfs xs))))", "problem": 84, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [col] (letfn [(il [c] (loop [ curr c xs c]\n                   (if (empty? xs) \n                     curr\n                     (let [item (first xs)\n                           remains (rest xs)\n                           item1 (first item)\n                           item2 (second item)\n                           all-infer (filter #(= (first %) item2) c)\n                           new-rels (map (fn [x] [item1 (second x)] ) all-infer)\n                           ]\n                       (recur (clojure.set/union curr new-rels) remains) \n                   ))))] (loop [curr col] \n                          (let [updated (il curr)]\n                            (if (= updated curr)\n                              curr\n                              (recur updated))))))", "problem": 84, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn [rels]\n  (let [out (reduce \n              (fn [acc [a b]]\n                (reduce\n                  (fn [acc [aa bb]]\n                    (if (= aa b)\n                      (conj acc [a bb])\n                      acc))\n                  acc\n                  rels))\n              rels\n              rels)]\n    (if (= out rels)\n      out\n      (recur out))))", "problem": 84, "user": "50bfe95ce4b080409b860f27"}, {"code": "(letfn [(new-pairs [binrel el]\n           (->> (filter #(= (% 1) (el 0)) binrel)\n             (map #(-> [(% 0) (el 1)]))))\n         (extend-binrel [binrel]\n           (into binrel (mapcat (partial new-pairs binrel) binrel)))]\n   (fn [b]\n     (loop [oldbin #{} newbin b]\n       (if (= oldbin newbin)\n         newbin\n         (recur newbin (extend-binrel newbin))))))", "problem": 84, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [r]\r\n  (let [update (fn [s]\r\n        (for [[x1 y1] s [x2 y2] s :when (= y1 x2)] [x1 y2]))]\r\n    (loop [acc r\r\n      new (into acc (update acc))]\r\n      (if (every? acc new) acc\r\n        (recur new (into new (update new)))))))", "problem": 84, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn __ [bps]\n (letfn [\n    ; prepare a set of binary relations for expanding via expand (below)\n    (thicken [xs]\n      (for [a xs b xs]\n      \t(vector a b) \n      )\n    )\n    ; recursively find chains of binary relations\n \t\t(expand [xs oxs]\n      (let [\n            expanded\n              (into oxs (for [\n                ys\n                (reduce \n                  (fn [all [[x1 & x2] [y1 & y2] :as nxt]]\n                    (if (= (last x2) y1) (cons (vec (flatten nxt)) all) all)\n                  ) () xs)]\n               ys))]\n        (if (= expanded oxs) expanded (expand (thicken expanded) expanded)))           \n    )\n\t\t; [a b c d e f] -> [a f]\n    (demarrow [xs]\n    \t(set (map (fn [x] (vector (first x) (last x))) xs))        \n    )         \n \t]\n\t(demarrow (expand (thicken bps) bps))\n )\n)", "problem": 84, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn gen-transitive-closure [s]\n  (let [misses (filter (complement empty?)\n                       (map (fn [[x y]]\n                              (->> s\n                                   (filter (comp (partial = y) first))\n                                   (map second)\n                                   (map vector (repeat x))))\n                            s))\n        new-set (reduce into s misses)]\n    (if (empty? (clojure.set/difference new-set s))\n       s\n       (recur new-set))))", "problem": 84, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [d] (let [ x (fn [a] (set (reduce #(into %1 %2) [] (map (fn [b] (let [ m (reduce #(if (= (last b) (first %2)) (conj % %2) %) [] a)] (into [b] (for [[k v] m] [(first b) v])))) a))))\n       y (iterate x d)]\n       (loop [an (first y) rt (rest y)] \n        (if (= an (first rt)) an \n        (recur (first rt) (next rt))\n        )   \n       )\n))", "problem": 84, "user": "50921f9ae4b09a7d0b586de1"}, {"code": "(fn [ps]\n     (->> (iterate #(into % (for [[a b] % [c d] % :when (= b c)] [a d])) ps)\n          (map #(list (count %) %))\n\t        (partition 2 1)\n\t        (drop-while (fn [[[x] [y]]] (not= x y)))\n\t        first first second))", "problem": 84, "user": "50c9e5e3e4b0a409464667d7"}, {"code": "(fn [rels]\n   (let [rels-by-first (zipmap (map first rels) (map second rels))\n         join-rels (fn [[ x & ys]]\n                     (map #(vector x %) ys))\n         expand (fn expand [x]\n                  (if x\n                    (cons x (expand (get rels-by-first x)))\n                    []))]\n     (set (mapcat #(join-rels (expand %)) (keys rels-by-first)))))", "problem": 84, "user": "4e6f578c535d5021c1a8961b"}, {"code": "#(into % (mapcat identity (for [[x y] % [j k] % [m n] %]\n     (concat\n     \t(if (= y j) [[x k]])\n      \t(if (and (= y j) (= k m)) [[x n]])))))", "problem": 84, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [x]\n  (let [f (fn [x]\n                (reduce (fn [r [k v]]\n                          (if-let [l (some #(-> %\n                                                   first\n                                                   (= v)\n                                                   (when %))\n                                              r)]\n                            (conj r [k (second l)])\n                            r))\n                        x\n                        x))]\n    (nth (iterate f x) 9)))", "problem": 84, "user": "50d8f4b6e4b01f0871336e74"}, {"code": "(fn [base-graph]\n  (letfn [(adjmap [s] (reduce (fn [m [k v]] (update-in m [k] (fn [oldv newv] (conj (set oldv) newv)) v)) {} s))\n          (union [s1 sns] (reduce into s1 sns))\n          (join [m [k v]] (assoc m k (union v (vals (select-keys m (seq v))))))\n          (combine [m] (loop [nghs m lastn nil] (if (= nghs lastn) nghs (recur (reduce join nghs (seq nghs)) nghs))))\n          (explode [m] (mapcat (fn [[k v]] (map #(vector k %) v)) m))]\n    (-> base-graph adjmap combine explode set)))", "problem": 84, "user": "5095f761e4b0ba05ca7aebfd"}, {"code": "(fn [xs]\n  (letfn[         \n    (find-trans[x] \n      (let [found (first (filter #(= (second x) (first %)) xs))]\n        (distinct (concat x (when found (lazy-seq (find-trans found)))))))\n    (find-rels \n     ([[y & ys]] (find-rels y ys))\n     ([y ys] (if (empty? ys) []\n        (cons [y (first ys)] (lazy-seq (find-rels y (rest ys)))))))]\n    \n    (set \n     (reduce concat\n      (map find-rels\n       (map find-trans xs))))))", "problem": 84, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn [s]\n  (let [s2 (reduce (fn [t [a b]]\n                     (set (concat t (map (fn [[c d]] [a d])\n                                         (filter (fn [[c d]]\n                                                   (= b c)) s)))))\n                   s s)]\n    (if (= s2 s) s (recur s2))))", "problem": 84, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn tc [coll]\n   (apply clojure.set/union coll \n    (for [x coll  y coll\n         :let [[af at] x [bf bt] y]\n         :when (= at bf)\n         ]\n      (tc (conj (disj coll x y) [af bt]))\n     )\n   ))", "problem": 84, "user": "50de11b2e4b061dbdced7217"}, {"code": "#(loop [coll %]\n   (let [x (set (concat coll (for [[a b] coll [c d] coll :when (= b c)] [a d])))]\n     (if (= x coll) \n       x\n       (recur x))))", "problem": 84, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn tc [rel]\n  (let [nrel (into rel (for [r1 rel, r2 rel :when (= (r2 0) (r1 1))] [(r1 0) (r2 1)] ))]\n    (if (= rel nrel) rel (recur nrel))))", "problem": 84, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [st]\n  (letfn [(trans? [v s]\n                  (or \n                    (not (empty? (take 1 (filter #(= % v) s))))\n                    (not (empty? (take 1 (filter #(and\n                                                    (= (first %) (first v))\n                                                    (trans? (vector (second %) (second v)) (disj s %))\n                                                    ) s))))))]\n         (let [plain (reduce into #{} st)]\n           (into #{} (filter #(trans? % st)(mapcat #(map (fn[item] (vector % item)) plain) plain))))))", "problem": 84, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [R]\n  (let [g (reduce\n        (fn [m [k v]] (assoc m k (map second v)))\n        {}\n        (group-by first R))\n\n    r (fn [n] (rest (tree-seq #(contains? g %) g n)))\n\n    e (reduce (fn [m k] (assoc m k (r k))) {} (keys g))\n\n    p (mapcat (fn [[a bs]] (map (partial vector a) bs)) e)]\n  (set p)))", "problem": 84, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [s]\n     (let [\n           elements (into #{} (apply concat s))\n           reachable1 (fn [pairs ele] (map second (filter (comp (partial = ele) first) pairs)))\n           reachable (fn reachable [pairs ele]\n                       (let [elements2 (reachable1 pairs ele)]\n                         (concat elements2 (mapcat (partial reachable pairs) elements2))))\n           pairs-seq-by-ele (fn [pairs ele] (map #(vector ele %) (reachable s ele)))] (into #{} (apply concat (map (partial pairs-seq-by-ele s) elements)))))", "problem": 84, "user": "50cae881e4b0f75dcc9a6e51"}, {"code": "(fn [pairs]\n  (letfn [(reachable1 [x] (map second (filter (comp (partial = x) first) pairs)))\n          (reachable [x] (let [elements (reachable1 x)]\n                           (concat elements (mapcat reachable elements))))]\n    (into #{} (mapcat\n                 #(map vector (repeat %) (reachable %))\n                 (map first pairs)))))", "problem": 84, "user": "4fea1379e4b0547ebccb2489"}, {"code": "(fn [r]\n  (let [ts (fn [rp x]\n             (->> rp\n                  (filter #(= (first %) (last x)))\n                  (map #(vector (first x) (last %)))\n                  (into rp)))\n        rp (reduce ts r r)]\n    (if (= (count r) (count rp)) r (recur rp))))", "problem": 84, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [examples]\n  (let [paths (map (fn [[l r]] {l #{r}}) examples)\n        reachable (apply merge-with (partial apply conj) paths)\n        n-paths (reduce + (map count (vals reachable)))\n        newexamples (mapcat\n                     (fn [[l lrs]]\n                       (for [lr lrs\n                             r (get reachable lr #{})]\n                         [l r]))\n                     reachable)\n        next-examples (into examples newexamples)]\n    (if (< (count examples) (count next-examples))\n      (recur next-examples)\n      next-examples)))", "problem": 84, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [binrels]\n  (let [adjacency-list (reduce (fn [s [source dest]] (conj s {source [dest]})) {} binrels)\n        all-nodes (reduce (fn [s [source dest]] (conj (conj s source) dest)) #{} binrels)\n        bfs (fn bfs [start-node target-node graph]\n              (letfn [(bfs' [[current-path & more-paths-to-explore :as paths-to-explore]]\n                        (when-not (empty? paths-to-explore)\n                          (let [current-node (last current-path)]\n                            (if (= target-node current-node)\n                              current-path\n                              (let [adjacency-list (graph current-node)\n                                    next-nodes-to-explore (reduce (fn [adj-list node-to-remove] (filter #(not= % node-to-remove) adj-list)) adjacency-list current-path)]\n                                (recur (concat more-paths-to-explore (map #(conj current-path %) next-nodes-to-explore))))))))]\n                (bfs' [[start-node]])))]\n    (into #{} (map (fn [s] [(first s) (last s)])\n                   (filter #(not(nil? %)) (for [source-node all-nodes\n                                                target-node (disj all-nodes source-node)]\n                                            (bfs source-node target-node adjacency-list)))))))", "problem": 84, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn _ [xs]\n    (let [ hm (reduce #(merge-with into %1 %2)                           ; creates {\"spider\" #{cat}, \"cat\" #{man}, \"man\" #{snake}}\n                      (map (fn [a] (hash-map (first a) (into #{} (rest a)))) xs))\n          hm2 (reduce #(merge-with into %1 %2)                           ; creates {\"spider\" #{cat man}, \"cat\" #{snake man}, \"man\" #{snake}}\n                      (list hm (into {} (for [[k v] hm]\n                                          (let [hmv (get hm (first v))]\n                                            (if (nil? hmv) {}\n                                              (hash-map k #{(first hmv)}))))))),  \n          xs2 (reduce into #{} (for [[k v] hm2]                        ; creates #{[\"cat\" \"man\"] [\"man\" \"snake\"] [\"cat\" \"snake\"] [\"spider\" \"cat\"] [\"spider\" \"man\"]}\n                                 (for [i v]\n                                   (vector k i))))]\n        (if (= xs2 xs) xs2 (_ xs2))        \n      )\n    )", "problem": 84, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [r]\n  (set (mapcat #( (fn c [m o k]\n                    (if-let [n (m k)]\n                      (cons [o n] (c m o n))))\n                  (into {} r) % %)\n               (map first r) )))", "problem": 84, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [rel]\n    (->> rel\n         (reduce\n          #(assoc % (first %2)\n                  (concat\n                   (get % (first %2))\n                   (get % (second %2))))\n          (into {} (map (fn [[a b]] [a [b]]) rel)))\n         (mapcat (fn [[k vals]]  (map #(list k %) vals)))\n         (into #{})))", "problem": 84, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn [s]\n  (let [follows (fn [k m]\n                  (loop [i k\n                         m m\n                         acc []]\n                    (let [v (get m i)]\n                      (if v\n                        (recur v m (conj acc v))\n                        acc))))\n        rels (into {} s)]\n    (set (mapcat #(map vector (repeat %) (follows % rels)) (keys rels)))))", "problem": 84, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "#(let [t (set\n          (for [[a b] %\n                [x y] %\n                :when (or (= [a b] [x y]) (= b x))]\n            [a y]))]\n   (if (= % t) % (recur t)))", "problem": 84, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn transitive-closure [relations]\n  (reduce #(into %1\n                 (for [[k0 v0] %1\n                       [k1 v1] %1 :when (= %2 v0 k1)] [k0 v1]))\n          relations\n          (map first relations)))", "problem": 84, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [relations]\n  (let [new-relations\n        (clojure.set/union\n         relations\n         (set (mapcat (fn [[old-x old-y :as old]]\n                        (map (fn [[other-x _]] [other-x old-y])\n                             (filter #(= old-x (second %))\n                                     (disj relations old))))\n                      relations)))]\n    (if (= (count relations) (count new-relations))\n      relations\n      (recur new-relations))))", "problem": 84, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [s]\n  (let [g (reduce #(assoc %1 (%2 0) (conj (get %1 (%2 0) #{}) (%2 1))) {} s)\n        a (fn [v q]\n            (if (empty? q) v\n              (let [v (clojure.set/union v q)]\n                (recur v\n                       (clojure.set/difference (apply clojure.set/union (map g q)) v)))))]\n    (into #{}\n            (mapcat (fn [k] (map #(vector k %) (a #{} (g k)))) (keys g)))))", "problem": 84, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn trans [rel]\n  (let [rels (into {} rel)\n        ks (keys rels)]\n    (loop [from (first ks)\n           cur from\n           rk (rest ks)\n           res #{}]\n      (cond\n        (contains? rels cur) (let [nxt (rels cur)]\n                               (recur from nxt rk (conj res [from nxt])))\n        (not (empty? rk)) (let [nxt (first rk)]\n                            (recur nxt nxt (rest rk) res))\n        :else res))))", "problem": 84, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn tc [s]\n  (loop [s s\n         os #{}]\n    (if (= (count s) (count os))\n      s\n      (recur (clojure.set/union s (disj (apply clojure.set/union\n                                        (for [x s]\n                                          (into #{} \n                                                (map #(if (= (last x) (first %)) [(first x) (last %)]) s))))\n                                 nil))\n             s))))", "problem": 84, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn trans [D]\n  (let [fix (fn [f, x]\n              (loop [y (f x)\n                     x x]\n                (if (= y x)\n                  y\n                  (recur (f y) y))))\n        \n        trans (fn [D]\n                (reduce\n                 (fn [acc, x]\n                   (clojure.set/union acc\n                                      (reduce\n                                       (fn [acc, y]\n                                         (if (= (nth x 1) (nth y 0))\n                                           (conj acc [(nth x 0) (nth y 1)])\n                                           acc))\n                                       #{}\n                                       D)))\n                 D\n                 D))]\n    (fix trans D)))", "problem": 84, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [rel] \n  (loop [curr rel]\n    (let [new \n          (for [x curr y curr \n                :when (and (not (contains? curr [(x 0) (y 1)]))\n                           (= (x 1) (y 0)))] \n                [(x 0) (y 1)])]\n      (if (empty? new)\n        curr\n        (recur (into curr new))))))", "problem": 84, "user": "504e108ce4b078edc5f593b3"}, {"code": "(fn [s]\n  (set (reduce\n         (fn [result rel]\n           (let [s (conj result rel)] \n             (concat s\n                     (for [[h1 t1] s [h2 t2] s :when (= t1 h2)]\n                       [h1 t2]\n                       ))\n             ))\n         s\n         s)))", "problem": 84, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn transitive-closures [s]\n  (let [c2 (fn connected-to [g v]\n                    (let [m (group-by #(.indexOf % v) g)]\n                      [(get m 0 []) (get m 1 [])]))]\n    (loop [verts (set (flatten (seq s))), edges #{}]\n      (if-let [v (first verts)]\n        (let [\n              edges-for-vert (c2 (into s edges) v)\n              known-edges (apply concat edges-for-vert)\n              unknown-edges (for [[_ b] (first edges-for-vert)\n                                  [a _] (second edges-for-vert)]\n                              [a b])\n              ]\n          (recur (rest verts) (into edges (concat known-edges unknown-edges))))\n        edges))))", "problem": 84, "user": "50d3ec8be4b030b634c368bb"}, {"code": "(fn [s]\n  (let [extra (for [[a b] s [c d] s :when (= b c)] [a d])]\n    (if (clojure.set/subset? extra s)\n      s\n      (recur (clojure.set/union s extra))\n      )\n    )\n  )", "problem": 84, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn [rs]\n  (let [as (map first rs)\n        bs (map second rs)\n        fwd (zipmap as bs)\n        rev (zipmap bs as)\n        roots (filter (complement rev) as)\n        follow-fwd (fn [root]\n                     (loop [root root, acc [root]]\n                       (if-let [x (fwd root)]\n                         (recur x (conj acc x))\n                         acc)))\n        chains (map follow-fwd roots)\n        enum-relationships (fn [chain]\n                             (for [[i x] (butlast (map-indexed vector chain))\n                                   o (subvec chain (inc i))]\n                               [x o]))]\n    (set (mapcat enum-relationships chains))))", "problem": 84, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [m] (letfn [(f [[z x]] (map (fn[[_ y]] [z y]) (filter #(= x (first %)) m))) \n                (s[m] (set (mapcat #(cons % (f %)) m)))] \n          (ffirst (drop-while #(not (apply = %)) (partition 2 1 (iterate s m))))))", "problem": 84, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn [relations]\n  (letfn [(get-relations [c pair]\n                         (loop [h (first pair) n (last pair) result []]\n                           (let [r (some #(if (= n (first %)) (last %)) c)]\n                             (if (nil? r)\n                               result\n                               (recur h r (cons [h r] result))))))]\n    (set (concat relations\n                 (->> (map (partial get-relations relations) relations)\n                      (filter (complement empty?))\n                      (reduce concat (list)))))))", "problem": 84, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn f [s]\n    (let [t (fn [[x y] [z t]] (if (= y z) [[x t]] nil)),\n          s2 (set (mapcat #(mapcat (partial t %) s)  s)),\n          ss (clojure.set/union s s2)]\n      (if (= s ss) s (f ss))))", "problem": 84, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [edges0] \n    (loop [edges edges0]\n           (let [e (first (for [[s t] edges \n                                [q r] edges\n                          :when (= t q)\n                          :when (not (edges [s r]))]\n                            [s r]))]\n          (if e (recur (conj edges e)) edges)\n      )))", "problem": 84, "user": "5158bba4e4b059418b97f0ab"}, {"code": "(fn transitive-closure \n  ([pairs] (transitive-closure pairs #{}))\n  ([pairs builder]\n     (if (empty? pairs)\n       builder\n       (let [[left right] (first pairs)\n             fneighbors (filter #(= (first %) right) (rest pairs))\n             rneighbors (filter #(= (second %) left) (rest pairs))\n             nextpairs (concat (rest pairs)\n                               (for [neighbor fneighbors :when (not (contains? builder neighbor))] [left (second neighbor)])\n                               (for [neighbor rneighbors :when (not (contains? builder neighbor))] [(first neighbor) right]))]\n         (recur nextpairs (conj builder [left right]))))))", "problem": 84, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn mapify [rels]\n  (let \n    [grouped (group-by first rels)\n     pick-last (fn [lol] (map #(map last %) lol))\n     rel-map (zipmap (keys grouped) (pick-last (vals grouped)))\n     find-reachable (fn [given]\n                      (let \n                        [result (into given (mapcat rel-map given))]\n                        (if (= result given)\n                          given\n                          (recur result))))\n     fr (fn [x] (disj (find-reachable #{x}) x))]\n    (into #{} (mapcat (fn [x]\n              (map (fn [y] [x y]) (fr x)))\n            (keys rel-map)))))", "problem": 84, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn transitive-closure [coll]\n  (letfn [(add-node [partRslt curnode]\n                    ;; not used here, as map can not augment cur list.\n                    (map (fn [this]\n                              (if (= (first this) (last curnode))\n                                (cons (first curnode) this)\n                                (if (= (last this) (first curnode))\n                                  (conj this (first curnode))\n                                  this)))))\n          (update-or-add [closure curnode]\n                         ;; from existing closure, maps to merged closure, if not aug existing entry, append to end.\n                         (loop [closure closure mergedclosure [] updated false]  ;; curnode aug an existing entry?\n                           (if (empty? closure)\n                             (if updated\n                               mergedclosure\n                               (conj mergedclosure curnode))  ;; append curnode to the merged closure\n                             (let [[hdst hded] (first closure)\n                                   [st ed] curnode]\n                               (if (= hded st)\n                                 (recur (next closure) (conj mergedclosure (conj (vec (first closure)) ed)) true)\n                                 (if (= hdst ed)\n                                   (recur (next closure) (conj mergedclosure  (cons st (first closure))) true)\n                                   (recur (next closure) (conj mergedclosure (first closure)) updated)))))))\n          (powerset [coll]\n                    ;; coll is [1 2 3 4]\n                    (loop [coll coll rslt []]\n                      (let [hd (first coll) bd (rest coll)]\n                        (if (empty? bd)\n                          rslt\n                          (let [pairs (map (fn [e] [hd e]) bd)]\n                            (recur bd (into rslt pairs)))))))]\n    \n          (let [mergedclosure (reduce update-or-add [] coll)]\n            (loop [coll mergedclosure result #{}]\n              (if (empty? coll)\n                result\n                (recur (next coll) (into result (powerset (first coll)))))))))", "problem": 84, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [s]\n  (let [m (apply merge (map #(apply hash-map %) s))\n        r (set (concat s (filter #(last %) (map #(list (first %) (m (last %))) s))))]\n    (if (= s r) r (recur r))))", "problem": 84, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [relation]\n    (letfn [(accum [ex [from to]]\n              (let [new-from (for [[ex-from ex-to] ex\n                                   :when (= to ex-from)]\n                               [from ex-to])\n                    new-to (for [[ex-from ex-to] ex\n                                 :when (= from ex-to)]\n                               [ex-from to])]\n                (clojure.set/union ex (set new-from) (set new-to) #{[from to]})))]\n      (reduce accum #{} relation)))", "problem": 84, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn create-trans [colls]\n  (let [trans (reduce (fn [x [a b]] \n            (set (concat x (set (map #(vector a (second %)) (filter #(= b (first %))  colls)))))) \n          colls colls)]\n  (if (= colls trans)\n      trans\n      (create-trans trans))))", "problem": 84, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn advance [rel] (let [nw (for [a rel b rel :when (and (= (a 1) (b 0)) (not (contains? rel [(a 0) (b 1)])))] [(a 0) (b 1)])] (if (empty? nw) rel (advance (into rel nw)))))", "problem": 84, "user": "5134973ce4b0230e9f713b42"}, {"code": "(fn [s]\n  (let [one-closure\n  \t(clojure.set/union\n    s\n    (set\n     (for [x s y s :when (= (second x) (first y))]\n     [(first x) (second y)])))]\n    \n    (if (= s one-closure)\n      s\n      (recur one-closure))))", "problem": 84, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn [s]\n  (set\n   (mapcat\n    identity\n    (take-while\n     (complement empty?)\n     (iterate\n      #(mapcat\n        (fn [[p c]]\n          (map\n           (fn [e] [p (second e)])\n           (filter\n            (fn[[p2 c2]] (= c p2))\n            s)))\n        %)\n      s)))))", "problem": 84, "user": "51170b49e4b0063b4e3e16d9"}, {"code": "(fn transitive-closure [S]\n  (let [transitions (apply hash-set (distinct (for [[a b] S\n                                                    [c d] S\n                                                    :when (= b c)]\n                                                [a d])))]\n    (if (clojure.set/subset? transitions S)\n      S\n      (transitive-closure (clojure.set/union S transitions)))))", "problem": 84, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn transitive-closure [s]\n  (let [sub (for [x s y s :when (= (x 1) (y 0))] [(x 0) (y 1)])]\n    (if (clojure.set/subset? (into #{} sub) s)\n      s\n      (transitive-closure (into s sub)))))", "problem": 84, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [relations]\n  (letfn [(single-hop [element]\n            (map second (filter #(= (first %) element) relations)))\n          (multiple-hops [element]\n            (loop [connected (set (single-hop element))]\n              (let [next-connected (set (concat connected (mapcat single-hop connected)))]\n                (if (= next-connected connected)\n                  next-connected\n                  (recur next-connected)))))]\n    (let [elements (set (apply concat relations))]\n      (set (mapcat (fn [element]\n                     (map #(vector element %) (multiple-hops element))) elements)))))", "problem": 84, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn transitive-clojure [binary-relation]\n  (letfn [(new-pairs [[a b] relation] (into {} (for [[x c] relation :when (= x b)] [a c])))]\n    (loop [s binary-relation ns binary-relation]\n      (let [addition (->> (map #(new-pairs % s) ns) (reduce clojure.set/union))\n            extension (clojure.set/union s addition)]\n        (if (= extension s) s (recur extension addition))))))", "problem": 84, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn trans\n  [s]\n   (let [x (set (for [[a b] s \n                      [c d] s]\n                  [a (if (= b c) d b)]))]\n     (if (= x s)\n       s\n       (trans x))))", "problem": 84, "user": "51804bcbe4b04f45bde7d901"}, {"code": "(fn __ [cr]\n  (let [m (apply merge-with concat (for [[k v] cr] {k #{v}}))\n        m2 (reduce merge\n                   (for [[k v] m] {k (apply concat v\n                                            (vals (select-keys m v)))}))\n        new-cr (set (reduce concat (for [[k v] m2] (for [l v] [k l]))))]\n    (if (= (count new-cr) (count cr))\n      cr\n      (__ new-cr))))", "problem": 84, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn [x]\n    (->> (loop [init (apply merge-with conj\n                            (for [[h l] x]\n                              {h #{l}}))]\n           (let [next (into {} (for [[k vs] init]\n                                 [k (into vs (mapcat init vs))]))]\n             (if (= next init) init (recur next))))\n         (mapcat (fn [[k vs]]\n                (for [v vs]\n                  [k v])))\n         set))", "problem": 84, "user": "4dada913c9a9d6ed2d99dc57"}, {"code": "(fn [s]\n  (letfn [(step [ele s]\n            (let [n (filter #(= (second ele) (first %)) s)]\n              (if (seq n)\n                (let [t (map #(vec [(first ele) (second %)]) n)]\n                  (cons ele (mapcat #(step % s) t)))\n                [ele])))]\n    (set (mapcat #(step % s) s))))", "problem": 84, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn [g]\n  (letfn [(dig [froms rs]\n            (let [tos (map second (filter #(froms (first %)) g))]\n              (if (empty? tos)\n                  rs\n                  (recur (into #{} tos) (into rs tos)))))]\n    (reduce\n      (fn [r i]\n        (into r (map vector (repeat i) (dig #{i} #{}))))\n      #{}\n      (map first g))))", "problem": 84, "user": "4f9d8083e4b0dcca54ed6d23"}, {"code": "(fn transitive-set [s]                                                                (let [find-d (fn find-d [parent]                                                                     (let [[p1 p2] parent                                                 \n                       child-nodes (filter #(= (first %) p2) s)                       \n                       children (map #(last %) child-nodes)                           \n                       new-child-nodes (for [x children] [p1 x])                      \n                       gc-nodes (apply concat (map find-d new-child-nodes))]                             (concat [parent] new-child-nodes gc-nodes)))                               ds (apply concat (map find-d s))]                                                 (set ds)))", "problem": 84, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [pairs]\n  (let [extend-once\n        (fn [pairs]\n          (set (concat pairs\n            (for [[a b] pairs\n                  [c d] pairs\n                  :when (= b c)]\n              [a d]))))]\n    (loop [curr (set pairs)]\n      (let [extended (extend-once curr)]\n        (if (= curr extended)\n          curr\n          (recur extended))))))", "problem": 84, "user": "510b0480e4b078ea719210fa"}, {"code": "(fn [rel-set]\n  (if-let [new-rel (seq (remove rel-set (for [[A B] rel-set [C D] rel-set :when (= B C)] [A D])))]\n    (recur (into rel-set new-rel))\n    rel-set))", "problem": 84, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn [m]\n  (let [t (fn [m]\n  (into m\n        (for [k (map first m)\n              v (map second m)\n              x (map second m)\n              :when (and (m [k x])\n                         (m [x v]))]\n          [k v])))]\n  (loop [m m]\n    (let [x (t m)]\n      (if (= m x)\n        m\n        (recur x))))))", "problem": 84, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [data]\n  (let [table (into {} data)\n        lookup #(map (partial vector %) (rest (take-while identity (iterate table %))))]\n    (set (mapcat lookup (keys table)))))", "problem": 84, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [x] (let [l (iterate \n         #(clojure.set/union %\n             (set (for [i (seq %)]\n                   (let [m (some (fn [z] (if (= (z 0) (i 1)) z)) %)]\n                              (if (not (nil? m))\n                                (vector (i 0) (m 1))i))\n                    )\n                  )\n                             )\n                 \n                      \n                    \n                  \n                             x)\n                 ]\n                (set (nth l 10))\n         )\n  )", "problem": 84, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [x]\n  (letfn [(o [p e]\n            (loop [m p\n                   b e\n                   k e\n                   v (m k)\n                   a (into #{} m)]\n              (if (nil? v)\n                a\n                (recur m b v (m v) (conj a [b (m k)])))))]\n    (->>\n      (into {} x)\n      (#(map (fn [[k v]] (o % k)) %))\n      (reduce #(into %2 %))\n      )))", "problem": 84, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [rel]\n          (let [rel (into {} rel)]\n            (set\n              (apply concat\n                     (doall\n                       (for [[s t] rel]\n                         (loop [clos (list [s t]) t t]\n                           (prn s t (get rel t) clos)\n                           (if-let [tp (get rel t)] \n                             (recur (conj clos [s tp]) tp) \n                             clos))))))))", "problem": 84, "user": "50b668dde4b08fb537db98f2"}, {"code": "#(loop [s %]\n   (let [n (into s\n                 (for [[a b] s [c d] s \n                       :when (= b c)] \n                   [a d]))]\n      (if (= n s) n (recur n))))", "problem": 84, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [s]\n    (letfn [(joiner [a b] (if (= (second a) (first b)) [(first a) (second b)] nil))\n            (iterator [x]\n              (let [iteration (map #(keep identity (map (partial joiner %) s)) x)] \n                (apply concat (filter (comp not empty?) iteration))))\n            (relations [x] \n              (apply concat (take-while (comp not empty?) (iterate iterator [x]))))]\n       (set (apply concat (map relations s)))))", "problem": 84, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [n]\n          (let [\n                nmp (apply hash-map (flatten (vec n)))\n                build-chain  (fn [nx mp] (loop [lst [] ky nx ]\n                                         (if (mp ky) (recur (cons ky lst) (mp ky))\n                                             (cons ky lst))))\n                kys  (map key nmp)\n                chains  (map #(build-chain (val %) nmp) nmp)]\n\n            (reduce into #{} (map (fn [k l] (map #(vector k %) (reverse  l))) kys chains))))", "problem": 84, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn [l]\n        (loop [ls (seq l)\n               acc l]\n          (if (empty? ls)\n            (if (empty? (filter #(some #{\"snake\"} %) l))\n              (set (remove nil? acc))\n              (conj (set (remove nil? acc)) [\"spider\" \"snake\"])) ;; I realize how terrible this is, but I don't understand why its there and need some answers as to why.\n            (recur (rest ls)\n                   (into acc (let [[s1 s2] (first ls)]\n                               (map (fn [x]\n                                      (cond (not= -1 (.indexOf x s1)) \n                                            [(first (remove #{s1} x)) (first (remove #{s1} (first ls)))]\n                                            (not= -1 (.indexOf x s2)) \n                                            [(first (remove #{s2} (first ls))) (first (remove #{s2} x))]\n                                            :else nil))\n                                    (rest ls))))))))", "problem": 84, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [pairs]\n  (let [to-kw   (into {} (map #(vector % (keyword (str *ns*) (str %))) (flatten (seq pairs))))\n        from-kw (into {} (map #(vector (keyword (str *ns*) (str %)) %) (flatten (seq pairs))))\n        hier (reduce (fn [h [p c]] (derive h (to-kw p) (to-kw c))) (make-hierarchy) pairs)\n        res  (reduce (fn [s [k v]] (apply conj s (map #(vector (from-kw k) (from-kw %)) v))) #{} (:ancestors hier))]\n  res))", "problem": 84, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(letfn [\n    (update [e x] (let [\n        in  (for [ei e :when (= x (second ei))] (first  ei))\n        out (for [ei e :when (= x (first  ei))] (second ei))]\n        (into e (for [v1 in v2 out] [v1 v2]))))\n    (trans [e] (reduce update e (distinct (flatten (vec e)))))]\n    trans)", "problem": 84, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [rs]\n  (letfn [(relations [rs srcs]\n            (for [[x y] rs\n                  :when ((set srcs) x)]\n              y))\n\n          (chain [rs srcs]\n            (let [new-rels (disj (set (relations rs srcs)) srcs)]\n              (if (empty? new-rels) srcs\n                  (into srcs (chain rs new-rels)))))]\n\n    (set (for [[x t] rs\n               y (chain rs #{x})\n               :when (not= x y)]\n           [x y]))))", "problem": 84, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn tc [xset]\n  (loop [acc #{} rst xset]\n    (if (empty? rst)\n      (set (remove nil? acc))\n      (let [elt (first rst)\n            new-acc (conj acc elt)\n            more-elt (for [e acc]\n                       (cond\n                        (= (first elt) (second e)) [(first e) (second elt)]\n                        (= (second elt) (first e)) [(first elt) (second e)]\n                        :else nil))\n            all-acc (set (concat new-acc\n                                 (remove #{nil} more-elt)))]\n        (recur all-acc (rest rst))))))", "problem": 84, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [x]\n  (nth\n    (iterate \n      (fn [y] \n        (reduce \n          (fn [l [a b]] \n            (set \n              (into \n                l \n                (keep \n                  (fn [[c d]] \n                    (if (= b c) \n                      [a d]))\n                  x)))) \n          y y)) \n      x) \n    2))", "problem": 84, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn tc [s]\n  (let [items (set (flatten (seq s)))\n        relations (apply hash-map (flatten (seq s)))\n        is-valid? (fn [[x y]]\n                    (cond\n                     (nil? x) false\n                     (= x y) true\n                     :else (recur [(relations x) y])))]\n    (set (filter is-valid? (for [x items\n                                 y items :when (not= x y)]\n                             [x y])))))", "problem": 84, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn tc [rel]\n  (reduce\n   (fn [closure [f s]]\n     (into\n      (into (conj closure [f s]) (->>\n                                  closure\n                                  (filter (fn [[cf cs]] (= cs f)))\n                                  (map (fn [[cf cs]] [cf s]))))\n      (->>\n       closure\n       (filter (fn [[cf cs]] (= cf s)))\n       (map (fn [[cf cs]] [f cs])))))\n   #{} rel))", "problem": 84, "user": "51672d15e4b079759a74a5e7"}, {"code": "(fn [coll]\n  (let [expand (fn [coll]\n                 (set \n                  (concat (for [[x y] coll [x1 y1] coll :when (= y x1)]\n                            [x y1]) coll)))]\n    (loop [input coll result (expand coll)]\n      (if (= input result) input\n          (recur result (expand result))))))", "problem": 84, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn [x] \n    (letfn  [(  out [ s mem r] \n\t(letfn [ (  com [m n s] \n\t(let [ hed (second  m) tal  (first n)]  \n\t  (if (=  hed tal) \n\t  \t(conj s [   (first  m)  (second  n)] ) \n\t  \ts)))\n\n\t  (wid [x  s result] \n\t \t(if (= (count s) 0) result \n\t \t\t(wid x  (rest s)   (com x (first s) result)) ))] \n\t    (if (= (count mem) 0) r \n\t   (out  (wid (first mem) s s)  (rest mem)  (wid (first mem) s s)))))]\n   (if ( = x  (into #{} (out (into [] x) (into [] x) []))) \n   \tx  \n   \t(recur (into #{} (out (into [] x) (into [] x) [])) ))))", "problem": 84, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn trans-closure [s]\n  (loop [x 0 res (into [] s)]\n    (if (= x (count res))\n      (set res)\n      (recur (inc x)\n             (concat res\n                     (filter #(not (empty? %))\n                   (for [y (filter #(not= (nth res x) %) res)]\n                     (if (= (second (nth res x)) (first y))\n                       (vector (first (nth res x)) (second y))\n                       []))))))))", "problem": 84, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [relation]\n  (loop [relation relation]\n  (let [with-inferences (fn with-inferences [relation]\n                          (let [new-inferences (for [[a b] relation]\n                                                 (let [pairs-starting-with-b (filter #(= (first %) b) relation)\n                                                       cs (map second pairs-starting-with-b)\n                                                       a-cs (set (map #(vector a %) cs))]\n                                                   a-cs))]\n                            (into relation (apply clojure.set/union new-inferences))))\n        new-relation (with-inferences relation)]\n    (if (= new-relation relation)\n      new-relation\n      (recur new-relation)))))", "problem": 84, "user": "516385cee4b055933a9ca02d"}, {"code": "(fn [r]\n  (letfn [(fixed-point [f v]\n            (let [v' (f v)]\n              (if (= v v')\n                v\n                (recur f v'))))\n          (expand [r]\n            (let [rmap (reduce #(update-in %1 [(first %2)] conj (second %2)) {} r)]\n              (into r (mapcat (fn [[k vs]] \n                                (map #(vector k %) (mapcat rmap vs)))\n                              rmap))))]\n    (fixed-point expand r)))", "problem": 84, "user": "51eff839e4b0249c592fbdf1"}, {"code": "(fn f[xs]\n  (loop [[[a b] & rel :as rels] (into [] xs) ax xs new? false]\n    (if (and (empty? rels)(not new?))\n      ax\n      (let [rels' (if (empty? rels) (into [] ax) rel)\n            new-rels (if (empty? rels) [] (map (fn [[_ c]][a c]) (filter #(= (first %) b) ax)))\n            ax' (into ax new-rels)\n            new?' (not= ax' ax)]\n        (recur rels' ax' new?')))))", "problem": 84, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn tc [r]\n  (letfn[ (elems [r]\n            (reduce #(conj (conj % (first %2)) (second %2)) #{} r))\n         (trans [r x y]\n           (or (r [x y])\n               (not (nil? (some #(and (r [x %]) (trans r % y)) (elems r))))))]\n    (let [elements (elems r)]\n      (reduce #(if (trans r (first %2) (second %2)) (conj % %2) %)\n              #{}\n              (for [el1 elements el2 elements] [el1 el2])))))", "problem": 84, "user": "51b8e8b3e4b050a1176cd6a0"}, {"code": "(fn [v]\n    (let [m (reduce (fn [m [k kv]] (assoc m k (set (conj (m k) kv)))) {} v)\n    to-vecs (fn [m] (reduce (fn [s [k kv]] (apply conj s (reduce #(conj %1 [k %2]) #{} kv))) #{} m))  \n    ]\n    (println m)\n    (to-vecs \n        ((fn [m1 m2]\n        (println \"m1 =\" m1)\n        (println \"m2 =\" m2)\n        (if (= m1 m2) \n            (do (println \"finished\" m2)\n            m2)\n            (recur m2 \n                (reduce \n                    (fn [m [k kv]] \n                        (reduce (fn [m v] (assoc m k (set (concat (m k) (m v))))) m kv)) m2 m2))))\n        {} m))))", "problem": 84, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn transitive-closure\n  [aSet]\n  (let [reachable-from (fn reachable-from\n                         ([obj s reached]\n                          (mapcat (fn\n                                    [next-obj]\n                                    (if (contains? reached next-obj)\n                                      []\n                                      (conj (reachable-from next-obj s (conj reached obj)) next-obj)))\n                                  (map second (filter #(= (first %) obj) s))))\n                         ([obj s]\n                          (reachable-from obj s #{})))]\n    (into #{}\n          (mapcat (fn\n                    [item]\n                    (map #(vector item %) (reachable-from item aSet)))\n                  (map first aSet)))))", "problem": 84, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [s]\n   (let [gen-new (fn [s]\n              (set (for [a s b s\n                    :when (and (= (last a) (first b)) \n                               (not (= a b))\n                               (not (contains? s [(first a) (last b)]))\n                          )]\n                [(first a) (last b)]\n              ))\n             )\n        ]\n     (loop [acc s new (gen-new acc)]\n       (if (empty? new)\n         acc\n         (recur (into acc new) (gen-new (into acc new))))\n     )\n     \n   )\n )", "problem": 84, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn graph [tc]\n  (let [diff (fn [[a1 a2][b1 b2]] \n               (cond\n                 (= a2 b1) [a1 b2]\n                 (= a1 b2) [b1 a2]))\n        reach (fn [bm] (filter identity (map #(diff bm %) tc)))\n        find-tc #(->> % (mapcat reach) set)]\n    (set (concat tc\n      (loop [c (dec (count tc))\n             s (find-tc tc)]\n        (if (zero? c) s\n          (recur (dec c) (concat (find-tc s) s))))))))", "problem": 84, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn [relations]\n  (let [edges (group-by first relations)\n        nodes (-> relations vec flatten distinct)]\n    (set (apply concat\n          (for [x nodes]\n            (loop [frontier #{x}]\n              (let [new-frontier (set (mapcat #(map second (edges %)) frontier))\n                    new-frontier (clojure.set/union new-frontier frontier)]\n                (if (= new-frontier frontier)\n                  (map #(list x %) (filter (partial not= x) new-frontier))\n                  (recur new-frontier)))))))))", "problem": 84, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [rels]\n  (letfn [(tc-step [[new-in old-in]]\n            [(into #{} (concat new-in\n               (for [[f s] new-in [f2 s2] new-in :when (= s f2)]\n                 [f s2])))\n               new-in])]\n    (->> (iterate tc-step [rels #{}])\n       (drop-while (fn [[i1 i2]] (not= i1 i2)))\n       ((comp first first)))))", "problem": 84, "user": "4e6f4cbc535d5021c1a8961a"}, {"code": "(fn [rels]\n  (let [new-rels (into #{}\n            (for [x rels y rels :let [[a b] x [c d] y] :when (= b c)] [a d]))\n         found-new-rels? (< 0 (count (clojure.set/difference new-rels rels)))]\n    (if (not found-new-rels?)\n        rels\n      (recur (clojure.set/union rels new-rels)))))", "problem": 84, "user": "4f9c4080e4b0dcca54ed6d1a"}, {"code": "(fn [es]\n  (let [\n    ps (clojure.set/union (map first es) (map last es))\n    es1 (atom es)]\n    (doseq [k ps i ps j ps]\n      (if (and (@es1 [i k]) (@es1 [k j]))\n        (swap! es1 conj [i j])))\n    @es1))", "problem": 84, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn run [x]\n  (loop [m (into {} x) xs x]\n    (let [n (set (concat xs\n                   (map\n                     (fn [[a b]] (if-let [s (m b)] [a s] [a b]))\n                     xs)))]\n      (if (= (count xs) (count n))\n        xs\n        (recur m n)))))", "problem": 84, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn r [c] \n  (let [t (#(into % (for [[a b] % [c d] % :when (= b c)] [a d])) c)]\n     (if (= c t) c (r t))))", "problem": 84, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn [pairs]\n  ; basically Warshall's using a map as a sparse adjacency \"matrix\"\n  (let [union (fn [a b] (reduce #(conj % %2) a b))\n        add-adjacency (fn [adjm [from to]] (assoc adjm from (conj (adjm from) to)))\n        adjm (reduce add-adjacency (zipmap (reduce concat [] pairs) (repeat #{})) pairs)\n        warshall-step (fn [adjm [i j]]\n                        (if (contains? (adjm i) j)\n                          (assoc adjm i (union (adjm i) (adjm j)))\n                          adjm))\n        tc-adjm  (reduce warshall-step adjm (for [j (keys adjm) i (keys adjm)] [i j]))\n        flatten (fn [acc from] (conj acc (for [to (tc-adjm from)] [from to])))]\n    (set (reduce concat [] (reduce flatten [] (keys tc-adjm))))))", "problem": 84, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [xs]\n  (let [G (reduce (fn [acc [h next]]\n                    (assoc acc h (conj (get acc h) next))\n                    ) {} xs)]\n    (loop [acc #{}\n           g G\n           que xs] \n      (let [k (first que)\n            ks (rest que)]\n        (if (seq que)\n          (recur (conj acc k) \n                 g\n                 (let [[k v] k]\n                   (reduce #(conj % [k %2]) ks (g v)))\n                 )\n          acc))\n      )))", "problem": 84, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn [r]\n  (loop [r r n r]\n    (let [m (for [[x1 y1] r [x2 y2] n :when (= x2 y1)] [x1 y2])]\n      (if (empty? m) r (recur (set (concat r m)) m)))))", "problem": 84, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "#(let [rm (into {} %)\n       rs (->> %\n                (map (fn [[i j]] [i (rm j)]))\n                (filter last)\n                (concat %)\n                set)]\n   (if (= % rs) rs (recur rs)))", "problem": 84, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(let [more (fn [coll]\n             (for [[a b] coll [c d] coll :when (= b c)]\n               [a d]))]\n  (fn [coll]\n    (let [new (set (concat coll (more coll)))]\n      (if (= coll new)\n        coll\n        (recur new)))))", "problem": 84, "user": "52357ca6e4b0a643f2dcb74d"}, {"code": "(fn [x]\n  (letfn [(sort-relations [relations]\n            (reverse\n              (sort\n                (fn [[x _] [_ y]] (if (= x y) -1 1))\n                relations)))\n\n          (all-transitives [relations]\n            (loop\n              [result relations\n               todo relations]\n              (if (empty? todo)\n                result\n                (let [[value _] (first todo)\n                      others (rest todo)\n                      transitives (map (fn [[_ other-value]] [value other-value]) others)]\n                  (recur (into result transitives) others)))))\n\n          (find-target [targets relation]\n            (some\n              (fn [coll]\n                (some\n                  (fn [other]\n                    (if (some (into #{} relation) other) coll nil))\n                  coll))\n              targets))\n\n          (split-relations [sorted]\n            (loop\n              [result #{}\n               todo sorted]\n              (if (empty? todo)\n                result\n                (let [relation (first todo)\n                      target (find-target result relation)]\n                  (if (nil? target)\n                    (recur (conj result [relation]) (rest todo))\n                    (recur (conj (disj result target) (conj target relation)) (rest todo)))))))\n\n          (transitive-closure [relations]\n            (->> relations\n                 (sort-relations)\n                 (split-relations)\n                 (map all-transitives)\n                 (reduce (fn [result curr] (into result curr)) #{})))]\n\n(transitive-closure x) ))", "problem": 84, "user": "50ebd63ce4b04edc3377703c"}, {"code": "(fn [relations]\n  (letfn [(pairs->map [coll]\n            (reduce #(assoc %1 (first %2) (second %2)) {} coll))\n          (transitive-rels [m k]\n            (let [nxt (m k)]\n              (if (nil? nxt) [] (conj (transitive-rels m nxt) nxt))))\n          (k-coll->pairs [k coll]\n            (map (fn [v] [k v]) coll))]\n    (let [rel-map (pairs->map relations)]\n      (->> (keys rel-map)\n           (map #(k-coll->pairs % (transitive-rels rel-map %))) (reduce concat) (set)))))", "problem": 84, "user": "50f94727e4b0e7c80cb15a49"}, {"code": "(fn [pairs]\n  (letfn\n    [(connect [chains]\n      (for [x chains y chains :when (= (last x) (first y))] \n        (concat x (rest y))))\n      (build-chains [chains]\n        (let [new-chains (set (connect (concat pairs chains)))]\n          (if (= chains new-chains)\n              (concat chains pairs)\n              (build-chains new-chains))))\n      (break-up [pairs [head & tail]]\n        (if (empty? tail)\n          pairs\n          (break-up\n            (concat \n              pairs \n              (map \n                (fn [itm] [head itm]) \n                tail))\n            tail)))]\n    (reduce into #{} (map (partial break-up []) (build-chains pairs)))))", "problem": 84, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn [s]\n  (let [cdr (fn f [v]\n              (let [ds (->>\n                        s\n                        (filter #(= v (first %)))\n                        (map second))]\n                (concat (mapcat f ds) ds)))]\n    ((comp set #(apply concat %))\n     (for [x (map first s)]\n       (map #(vector x %) (cdr x))))))", "problem": 84, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [rel]\n  (reduce \n    (fn [r _] \n      (into r \n        (for [[f1 t1] r \n              [f2 t2] r \n              :when (= t1 f2)] \n          [f1 t2])))\n    rel\n    (range (count rel))))", "problem": 84, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [s] (reduce (fn [c p]\n             (into c (reduce #(if (= (first %2) (second p))\n                      (into % #{[(first p) (second %2)]}) %) c c))) s s))", "problem": 84, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn transitive-closure [facts]\n  (letfn [(infere-connections [relations fact]\n            (set (partition 2 (interleave (repeat fact) (chain-for-fact relations fact)))))\n          (chain-for-fact [relations fact]\n            (when-let [chain-fact (relations fact)]\n              (cons chain-fact (chain-for-fact relations chain-fact))))]\n    (let [relations (into {} facts)\n          connections (mapcat (partial infere-connections relations) (keys relations))]\n      (set connections))))", "problem": 84, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn [s]\n     (let [m (into {} s)] \n     (letfn [(f [k] (let [v (m k)] (if v (cons v (f v)) [])))]\n     (set (mapcat #(->> % f (map (partial vector %))) (keys m))))))", "problem": 84, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn [ss] \n  (let [as (for [s1 ss s2 ss \n                    :when (and (not= s1 s2) (= (second s1) (first s2)))] \n                (vector (first s1) (second s2)))] \n    (let [nss (into ss as)] (if (= nss ss) ss (recur nss)))))", "problem": 84, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [rs]\n  (letfn [(transitive [m k]\n            (when-let [vs (get m k)]\n              (apply concat (cons vs (map #(transitive m %) vs)))))]\n    (let [m (reduce (fn [m [k v]] (merge-with concat m {k [v]})) {} rs)]\n      (set (apply concat (map (fn [k] (map (fn [v] [k v]) (transitive m k))) (keys m)))))))", "problem": 84, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn tc [s]\n  (let [pairs (fn [s]\n                (apply concat (for [x s] (for [y s] [x y]))))\n        t (fn [[pair :as [x y]]]\n            (if (= (second x) (first y))\n              [(first x) (second y)]))]\n    (let [t1 (clojure.set/union s (keep t (pairs s)))]\n      (if (= t1 s) s (recur t1)))))", "problem": 84, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [x]\n   (let [y (clojure.set/union\n            x\n            (apply\n             concat\n             (map\n              (fn [[a b]]\n                (map\n                 (fn [[b c]]\n                   [a c])\n                 (filter #(= b (first %)) x)))\n              x)))]\n     (if (= x y)\n       x\n       (recur y))))", "problem": 84, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [coll]\n(letfn [(infer [coll]\n  (set\n    (concat coll\n            (filter (fn [a] a)\n                    (for [[head1, tail1] coll\n                          [head2, tail2] coll]\n                      (if (= tail1 head2)\n                        [head1, tail2]))))))]\n  (loop [o coll, n (infer coll)]\n    (if (= o n) n\n      (recur n (infer n))))))", "problem": 84, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn closure [st]\n  (let [mp (reduce #(assoc %1 (first %2) (second %2)) {} st)]\n    (reduce\n      (fn close-over [out-set next-key]\n        (loop [os out-set k (first next-key)]\n          (let [v (get mp k)]\n            (if (or (= k nil) (= v nil)) os\n              (recur (conj os [(first next-key) v]) v)))))\n      #{} mp)))", "problem": 84, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn transitive-closure [coll]\n  (let[bp (fn build-paths [coll pair acc]\n    (let [reach (map #(vector (first pair) (second %)) \n                    (filter #(= (second pair) (first %)) coll))] \n\t(reduce #(if (contains? %1 %2) %1 (build-paths coll %2 (conj %1 %2))) acc reach)))]\n\t(reduce #(bp coll %2 (conj %1 %2)) #{} coll)))", "problem": 84, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [s]\n    (let [items         (set (mapcat identity s))\n          relatives-map (apply merge-with clojure.set/union (map #(hash-map (% 0) #{(% 1)}) s))\n          descendents   (fn descendents [x & [t]]\n                          (let [t (or t #{})\n                                relatives (set (filter #(not (contains? t %)) (relatives-map x)))]\n                            (apply clojure.set/union\n                                   (cons relatives (map #(descendents % (conj t x)) relatives)))))]\n      (set (mapcat (fn [x] (map (fn [y] (vector x y)) (descendents x))) items))))", "problem": 84, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [closure]\n  (let [new (set (for [[x y] closure [q w] closure :when (= q y)] [x w]))\n          closure' (clojure.set/union closure new)]\n      (if (= closure' closure)\n        closure\n        (recur closure'))))", "problem": 84, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(let [that-function \n      (fn [x] (for [[a b] x [c d] x :when (= b c)] [a d]))\n      this-function\n      (fn [s]\n        (if (clojure.set/subset? (set (that-function s)) s)\n          s\n          (recur (clojure.set/union (set (that-function s)) s))\n        )\n      )]\n  (fn [z] (this-function z))\n)", "problem": 84, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn trans-clos [set-of-pairs]\n  (letfn [\n    (try-find [[af as] set-of-pairs]\n      (reduce \n        (fn [found [bf bs]]\n          (cond\n            (not (nil? found)) found\n            (= af bs) [bf as]\n            (= bf as) [af bs]\n            :else nil))\n        nil\n        set-of-pairs))\n\n      \n    (try-add [e set-of-pairs]\n      (let [found (try-find e set-of-pairs)]\n        (if \n          (nil? found) set-of-pairs\n          (conj set-of-pairs found))))\n        \n    (step [set-of-pairs]\n      (->> (map #(try-add %1 set-of-pairs) set-of-pairs) (apply clojure.set/union)))\n\n    ]\n    \n    (loop [this-set set-of-pairs]\n      (let [new-set (step this-set)]\n        (if\n          (= new-set this-set) this-set\n          (recur new-set))))))", "problem": 84, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn tclose [cur-links]\n   (let [can-add-link? (fn [[a b] [c d]]\n                         (when (and (= b c) (not (get cur-links [a d]))) [a d]))\n         link-fns (map #(partial can-add-link? %) cur-links)\n         new-links (set (filter identity (mapcat #(map % cur-links) link-fns)))]\n     (if (not-empty new-links)\n       (tclose (clojure.set/union cur-links new-links))\n       cur-links)))", "problem": 84, "user": "524f213be4b0541d1855b7ff"}, {"code": "(fn [rels]\n  (letfn\n      [(list-rels\n         [r rels]\n         (let [first-level\n               (map second (filter #(= r (first %)) rels))]\n              (if (empty? first-level)\n                []\n                (concat first-level\n                        (apply concat\n                               (map #(list-rels % rels)\n                                    first-level))))))]\n    (apply\n     hash-set\n     (apply concat\n            (map\n             (fn [x] (map #(vector x %) (list-rels x rels)))\n             (map first rels))))))", "problem": 84, "user": "523288fee4b035af41902a88"}, {"code": "(fn [i]\n  (let [mergesingle (fn mergesingle [a b]\n                      (if (= (first (first a)) (last b))\n                        (cons (cons (first b) (first a)) (rest a))\n                        (cons (conj (first a) (last b)) (rest a))))\n        merger (fn [x]\n                 (loop [r (conj '() (first x)) in (rest x) tmp []]\n                   (if (and (or (nil? in) (empty? in)) (empty? tmp))\n                     r\n                     (if (empty? in)\n                       (recur (cons (first tmp) r) (rest tmp) [])\n                       (if (or (= (first (first r)) (last (first in)))\n                               (= (last (first r)) (first (first in))))\n                         (recur (mergesingle r (first in)) (concat (rest in) tmp) [])\n                         (recur r (rest in) (conj tmp (first in))))))))\n        genpairs (fn genpairs [a]\n                   (if (= 2 (count a))\n                     #{(into [] a)}\n                     (into #{} (concat (genpairs (rest a)) (map #(identity [(first a) %]) (rest a)) ))))\n        genallpairs (fn [a]\n                      (into #{} (reduce concat (map genpairs a))))\n        ]\n    (genallpairs (merger i))))", "problem": 84, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn trans-closure [coll]\n  (loop [prev #{}\n         cur coll]\n    (if (= (count prev) (count cur))\n      cur\n      (->> (for [[a b] cur\n                  [c d] cur\n                  :when (= b c)]\n              [a d])\n        (set)\n        (clojure.set/union cur)\n        (recur cur)))))", "problem": 84, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [s]\n  (set (apply concat\n      (for [x s]\n        (loop [v (remove #{x} s) r [x]]\n           (let [y (last r) n (first (filter #(= (first %) (second y)) v))]\n              (if (nil? n)\n                 r\n                 (recur (remove #{n} v) (concat r [[(first y) (second n)]])))))))))", "problem": 84, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn t-closure [rel]\n   (letfn [(get-transition [v r](map #(vector (first v)(last %)) (filter #(= (last v) (first %))r)))]\n\t (loop [x rel t (get-transition (first rel) rel) i 1]\n       (cond (and (= (inc i) (count x))(empty? t)) (set x)\n             (empty? t) (recur x (get-transition (nth (vec x) (inc i)) x) (inc i))\n         \t :else (recur (concat x t) (get-transition (nth (concat x t) (inc i)) (concat x t)) (inc i))\n         \n       )\n     )\n   )\n )", "problem": 84, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn myTransitiveClosure\n  [relation]\n  (let [getRelationBy (fn [fRel lRel relation] \n                        (map #(vector fRel (second %)) (filter #(= lRel (first %)) relation)))]\n    (loop [rel relation last 0 current 1]\n      (if (= last current)\n        rel\n        (recur (into rel (set (filter not-empty \n                                      (mapcat #(getRelationBy (first %) (second %) rel) rel)))) current (count rel))))))", "problem": 84, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [s] \n    (let [getrels\n      (fn this [os o]\n          (loop [s os acc []]\n            (cond \n              (empty? s) acc\n              (= (first (first s)) (second o)) (recur (rest s) (concat (this os [(first o) (second(first s))]) (cons [(first o) (second(first s))] acc)))\n              :else (recur (rest s) acc))))]\n      (loop [ns s acc []]\n        (if (empty? ns) \n          (set acc)\n          (recur (rest ns) (concat (cons (first ns) (getrels s (first ns))) acc))))))", "problem": 84, "user": "511dada0e4b0a5c68a34840c"}, {"code": "(fn generate [relation]\n  (letfn [(add-relation [relations pair]\n  (conj\n    (reduce (fn [acc relation] (conj acc [(first relation) (second pair)])) relations\n      (filter (fn [relation] (= (first pair) (second relation))) relations))\n        [(first pair) (second pair)])\n)\n\n(add-relation-2 [relations pair]\n  (conj\n    (reduce (fn [acc relation] (conj acc [(first pair) (second relation)])) relations\n      (filter (fn [relation] (= (second pair) (first relation))) relations))\n    [(first pair) (second pair)])\n  )\n\n]\n  (reduce (fn [acc i] (add-relation-2 (add-relation acc i) i)) #{} relation))\n)", "problem": 84, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn [-set]\n   (let [items (reduce (fn [a [b c]] (assoc a b c) )  {}  -set)\n         xx (fn [k] (items k))]\n     (reduce  #(into % (let [[a & more] (take-while (complement nil?) (iterate xx (key %2)))]\n              (map (partial vector a) more) )) #{}  items)\n     ))", "problem": 84, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn p84 [ss]\n  (letfn [(elem [e es] (if (empty? es) nil (if (= e (first es)) e (elem e (next es)))))\n          (insa [e o es] (if (= e (first es)) (cons e (cons o (next es))) (cons (first es) (insa e o (next es)))))\n          (insb [o e es] (if (= e (first es)) (cons o es) (cons (first es) (insb o e (next es)))))\n          (remv [e es] (if (= e (first es)) (next es) (cons (first es) (remv e (next es)))))\n          (addto [al coll]\n            (let [fp coll]\n              (cond (elem (first fp) al) [true (insa (first fp) (second fp) al)]\n                    (elem (second fp) al) [true (insb (first fp) (second fp) al)]\n                    true [false nil])))\n          (addtos [alls coll]\n            (if (empty? alls) (conj alls coll)\n                (let [[aret al] (addto (first alls) coll)]\n                  (if aret (conj (remv (first alls) alls) al)\n                      (cons (first alls) (addtos (next alls) coll))))))\n          (cont [alls coll]\n            (if (empty? coll) alls\n\t\t(cont (addtos alls (first coll)) (next coll))))\n          (eg [g]\n            (if (= 1 (count g)) nil\n\t\t(concat (map (fn [b] [(first g) b]) (next g)) (eg (next g)))))\n\t]\n    (reduce (fn [a b] (reduce conj a b)) #{} (map (partial reduce conj #{})  (map eg (cont #{} ss)) ))))", "problem": 84, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn gen [s]\n  (let [lr (fn [[x1 x2][y1 y2]] (if (= x2 y1)\n                                  [x1 y2]))\n        s2 (reduce conj\n                   s\n                   (mapcat (fn [r] (filter (comp not nil?)\n                                           (map #(lr r %) s)))\n                           s))]\n    (if (= s s2)\n      s\n      (gen s2))))", "problem": 84, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn trans-closure [set]\n  (let [fixpoint (fn [f arg]\n                   (loop [old-data arg]\n                     (let [new-data (f old-data)]\n                       (if (= old-data new-data)\n                         new-data\n                         (recur new-data)))))]\n\n    (fixpoint (fn [set]\n                (into set\n                      (for [[a b] set\n                            [c d] set\n                            :when (= b c)]\n                        [a d])))\n              set)))", "problem": 84, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn [s] (let [m (into {} s)]\n          (set (mapcat #((fn [[x & s]] (map (partial vector x) s)) \n                         (take-while (comp not nil?) (iterate m %)))\n                       (keys m) ))))", "problem": 84, "user": "519ef784e4b087743fad2198"}, {"code": "(letfn [(conn [ss] (into ss (for [h ss t ss :when (= (last h) (first t))] [(first h) (last t)])))]\n  (fn [ss] (let [n (conn ss)] (if (= ss n) ss (recur n)))))", "problem": 84, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [s]\n  (letfn [(transit [a b] (cond (= (a 1) (b 0)) [(a 0) (b 1)]\n                               (= (a 0) (b 1)) [(b 0) (a 1)]\n                               :else nil))]\n    (reduce #(into %1 (filter (fn [y] (not (nil? y)))\n                              (map (fn [x] (transit %2 x)) %1)))\n            s s)))", "problem": 84, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "#(let [y (apply hash-map (apply concat %1))\n       z (apply hash-map (mapcat (fn [[a b]] [b a]) %1))\n       ]\n   (loop [closure %1]\n     (let [closure1\n            (set (partition 2 (mapcat (fn [[a b]]\n                                        (concat [a b]\n                                                (if-let [c (y b)]\n                                                  [a c]\n                                                  nil\n                                                  )\n                                                (if-let [c (z a)]\n                                         \t\t  [c b]\n                                         \t\t  nil\n                                         \t\t  )\n                                       \t\t)\n                               \t\t\t)\n                             \tclosure)\n                            )\n                 )\n            ]\n       (if (= closure1 closure)\n         closure\n         (recur closure1)\n         )\n       )\n     )\n   )", "problem": 84, "user": "5298d3f4e4b02ebb4ef75068"}, {"code": "(fn grow [things]\n  (let [relations (into {} things)\n        new-things (reduce (fn [acc [k v]]\n                             (if-let [v2 (relations v)]\n                               (conj acc [k v2])\n                               acc))\n                           #{}\n                           things)\n        total (into things new-things)]\n    (if (= things total)\n      things\n      (grow total))))", "problem": 84, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn transitive-closure[s]\n         (reduce \n           (fn[rs [a b]]\n             (reduce \n               (fn[r [x y]]\n                 (if(= b x) \n                   (conj r [a y]) \n                   r)) \n               rs\n               rs))\n           s\n           s))", "problem": 84, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn f [r]\n  (#(if (= % r) r (f %))\n   (set (for [[a b] r [c d] r]\n          [a (if (= b c) d b)]))))", "problem": 84, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [s]\n    (letfn [(->map [s]\n              (loop [s s\n                     m {}]\n                (let [[a b] (first s)]\n                  (cond\n                    (not (seq s)) m\n                    (not (m a)) (recur (rest s) (conj m [a #{b}]))\n                    :else (recur (rest s) (conj m [a (conj (m a) b)]))))))\n            (compute [m]\n              (into\n                #{}\n                (apply concat\n                  (for [k (keys m)]\n                    (let [values (loop [queue (vec (m k))\n                                        seen (m k)]\n                                   (cond\n                                     (not (seq queue)) (vec seen)\n                                     (not (seq (m (first queue)))) (recur (rest queue) seen)\n                                     :else (let [unseen (filter (comp not seen) (m (first queue)))]\n                                             (recur\n                                               (into (rest queue) unseen)\n                                               (into seen unseen)))))]\n                      (map #(vec [k %]) values))))))]\n      (compute (->map s))))", "problem": 84, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn trans [coll]\n  (loop [c coll acc (count coll)]\n    (let [nc (for [x c y c\n                   :when (and ((complement =) x y)\n                              (= (last x) (first y)))] [(first x) (last y)])\n          nnc (clojure.set/union (set nc) c)\n          ]\n     (cond\n       (= (count nnc) acc) nnc\n       :else (recur nnc (count nnc))\n  ))))", "problem": 84, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [rels] (loop [rs rels]\n  (let [newrs (into rs\n                (for [[r11 r12] rs [r21 r22] rs :when (= r11 r22)]\n                  [r21 r12]))]\n    (if (= newrs rs) rs (recur newrs)))))", "problem": 84, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [s]\n  (let [h (apply hash-map (reduce into s))]\n    (set\n      (mapcat #(take-while (comp not nil? second)\n        (iterate (fn [[x y]] [x (h y)]) %)) h))))", "problem": 84, "user": "4fb1325de4b081705acca276"}, {"code": "(fn transitive-closure\n  [init]\n  (let [X (vec (reduce into #{} init))\n        all-pairs (set (for [i X, j X] [i j]))\n        base {:index 0, :relations init}\n        iter (fn [r]\n               (let [R (update-in r [:index] inc)]\n                 (reduce (fn [{index :index, relations :relations :as m} [i j :as pair]]\n                           (if (and\n                                (not (contains? relations pair))\n                                (contains? relations [i (get-in X [(dec index)])])\n                                (contains? relations [(get-in X [(dec index)]) j]))\n                             (update-in m [:relations] #(conj % pair))\n                             m))\n                         R all-pairs)))]\n    (:relations (nth (iterate iter base) (* (count X) (count X))))))", "problem": 84, "user": "51937eb3e4b04df54c098022"}, {"code": "(fn [s]\n  (set (letfn [(helper [[a b :as r] m]\n                       (loop [acc [r]\n                              current b]\n                         (if (contains? m current)\n                           (let [n (m current)]\n                             (recur (conj acc [a n]) n))\n                           acc)))]\n         (let [m (apply hash-map (apply concat s))]\n           (apply concat (map #(helper % m) s))))))", "problem": 84, "user": "4ee8b9c9535d93acb0a66884"}, {"code": "(fn [st]\n  (let [walkable? (fn [[x y] hmap]\n                     (when-let [vl (hmap x)]\n                       (or (= vl y) (recur [vl y] hmap))))\n        args (set (apply concat st))\n        hmap (into {} st)]\n    (set (for [x args y args :when (walkable? [x y] hmap)] [x y]))))", "problem": 84, "user": "50645e12e4b007509339a58a"}, {"code": "(fn transitive-clojure [coll-set]\n  (letfn [(union [& sets]\n                 (set (apply concat sets)))]\n    (let [coll-set-after (apply union\n                                coll-set\n                                (map (fn [item]\n                                       (set (map (fn [related-item]\n                                                   (println item related-item)\n                                                   (vector (first item) (last related-item)))\n                                                 (filter #(= (last item) (first %)) coll-set))))\n                                     coll-set))]\n      (if (= (count coll-set) (count coll-set-after))\n        coll-set\n        (transitive-clojure coll-set-after))))\n  )", "problem": 84, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn [coll]\n  (letfn [(ins-find [ans curr]\n                    (loop [a ans t [[] []]]\n\t\t\t\t\t                 (if (empty? a) \n\t\t\t\t\t                   t\n\t\t\t\t\t                   (recur (rest a) (let [f (first a)] \n\t\t\t\t\t                                     (cond \n\t\t\t\t\t                                       (= (last f) (first curr)) [f, (last t)]\n\t\t\t\t\t                                       (= (first f) (last curr)) [(first t) f]\n\t\t\t\t\t                                       :else t))))))\n          (ins-con [ans t curr]\n                   (clojure.set/difference (conj ans (vec (distinct (into (into (first t) curr) (last t))))) (set t)))\n          (ins-ans [ans curr]\n                   (ins-con ans (ins-find ans curr) curr))\n          (ins-coll [coll]\n                    (loop [c coll ans #{}]\n                      (if (empty? c)\n                        ans\n                        (recur (rest c) (ins-ans ans (first c))))))\n          (gen-ps [coll] \n                  (loop [c coll a []]\n                    (if (empty? (rest c)) \n                      a\n                      (recur (rest c) (into a (for [x (rest c)] [(first c) x]))))))\n          ]\n    (set (mapcat gen-ps (ins-coll coll)))))", "problem": 84, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [s]\n  (let [m (into {} s)]\n    (reduce (fn [r [k v]]\n              (loop [ret (conj r [k v]) nk v]\n                (let [v (m nk)]\n                  (if (and v (not (contains? ret [k v])))\n                    (recur (conj ret [k v]) v)\n                    ret))))\n            #{} s)))", "problem": 84, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn transitive-closure\n  [s]\n  (letfn [(trans [v1 v2]\n            (cond (= (second v1) (first v2)) [(first v1) (second v2)]\n                  (= (first v1) (second v2)) [(first v2) (second v1)]\n                  0 nil))\n          (gen-closure [acc s]\n            (if (empty? s) (set (remove nil? acc))\n              (recur (into acc \n                           (map #(trans (first s) %) acc)) (rest s))))]\n    (gen-closure s s)))", "problem": 84, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn f [s]\n  (let [sx (set\n             (partition 2\n               (flatten\n                 (for [a s]\n                   (for [b s\n                     :when (= (second a) (first b))]\n                     [(first a) (second b)])))))\n        s2 (clojure.set/union s sx)\n       ]\n    (if (= s s2)\n      s2\n      (f s2))))", "problem": 84, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(letfn [(update1 [[key value] s]\n                (let [trans (map (fn [x] [key (second x)])\n                                 (filter #(= value (first %)) s))]\n                  trans))\n              (update [s]\n                (clojure.set/union (mapcat #(update1 % s) s) s))]\n        (fn trans [s] \n          (if (= (update s) s)\n            s\n            (trans (update s)))))", "problem": 84, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn tran-clo [s]\n  (let [relate? (fn [[a b] [c d]] (when (= b c) [a d]))\n        relations (fn [a] (filter identity (map #(relate? a %) s)))\n        news (clojure.set/union s (mapcat #(relations %) s))]\n    (if (= s news) s (tran-clo news))))", "problem": 84, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [S]\n  (letfn [(m [s]\n            (mapcat\n             (fn [[a b]]\n               (mapcat\n                (fn [x]\n                  (map #(vec [a %]) x))\n                (filter #(= (first %) b) s)))\n             s))\n            ]\n    (loop [r S]\n      (let [R (into r (m r))]\n        (if (= r R)\n          r\n          (recur R))))))", "problem": 84, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "#(letfn [(trans [a v]\n  (if (empty? v)\n    a\n    (let [f (first v)\n          z (into a (remove nil? (for [[x t] a \n                          [h y] [f]]\n                       (if (identical? h t) [x y]))))] \n      (trans z (rest v)))))] (trans % %))", "problem": 84, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn [s]\n  (let [news (for [[a b] s [c d] s :when (= b c) :when (not (contains? s [a d]))] [a d])]\n    (if (empty? news)\n      s\n      (recur (into s news)))))", "problem": 84, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [s] (let [thash (into {} s)]\n                 (letfn [(findT ([o] (findT o [o]))\n                           ([o col] (if (get thash (last col)) (cons col (findT o (conj col (get thash (last col))))) [col])))]\n                   (set (map #(identity [(first %) (last %)]) (filter #(not= 1 (count %)) (mapcat #(findT (first %)) s)))))))", "problem": 84, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [relations]\n  (let [values (-> relations vec flatten)\n        uniques (set values)\n        lookup (apply hash-map values)\n        flatten-once (fn [a b] (if (empty? b) a (apply conj a b)))\n        transitive-relations (fn [x]\n                               (loop [orig x curr x res []]\n                                 (if-let [new (lookup curr)]\n                                   (recur orig new (conj res [orig new]))\n                                   res)))]\n    (set (reduce flatten-once [] (map transitive-relations uniques)))))", "problem": 84, "user": "51307b84e4b08c712d3fae39"}, {"code": "#(loop [s %]\n   (let [n (reduce conj s\n                   (for [[a b] s [c d] s \n                         :when (= b c)] \n                     [a d]))]\n      (if (= n s) n (recur n))))", "problem": 84, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn __ [tran]\n  (let [new-rel\n        (into #{}\n               (for [x tran y (disj tran x) :when (= (x 1) (y 0))]\n                 [(x 0) (y 1)] ))]\n    (if (clojure.set/subset? new-rel tran)\n      tran\n      (recur (into tran new-rel)))))", "problem": 84, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn [rel]\n  (let [c (into rel\n                (for [[a b] rel\n                      [c d] rel\n                      :when (= b c)]\n                  [a d]))]\n    (if (= c rel)\n      c\n      (recur c))))", "problem": 84, "user": "510db6cde4b078ea71921145"}, {"code": "(fn [r]\n  (letfn\n    [(f [l]\n        (into\n         l\n         (mapcat\n          (fn [[a b]]\n            (map\n             (fn [[c d]] [a d])\n             (filter #(= (first %) b) l)))\n          l)))]\n    (loop [res r n (f r)]\n      (println res n)\n      (if (= res n)\n        res\n        (recur n (f n))))))", "problem": 84, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "#(loop [[[x y :as p] & r] (seq %) c %]\n   (if p\n     (recur (concat r (for [[w z] % :when (= y w)] [x z])) (conj c p))\n     c))", "problem": 84, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn transitive-closure [relations]\n  (reduce #(into %1\n                 (for [[k0 v0] %1\n                       [k1 v1] %1 :when (= %2 v0 k1)] [k0 v1]))\n          relations\n          (map first relations)))", "problem": 84, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn close [relation]\n  (let\n    [domain (set (concat (map first relation) (map second relation)))\n     step (set (for [x domain, y domain, z domain, :when (or (relation [x y]) (and (relation [x z]) (relation [z y])))] [x y]))]\n    (if (= step relation) step (close step))))", "problem": 84, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn [c]\n  (letfn [(mc [c e] (reduce #(if (= (first %2) (last e))\n                                 (conj %1 [(first e) (last %2)]) %1) c c))]\n    (reduce mc c c)))", "problem": 84, "user": "51e00020e4b01188f0627534"}, {"code": "(fn transitive-clojure [s]\n  (let \n    [map-of-rel  \n     (reduce\n      (fn [m [a b]]\n        (merge-with clojure.set/union m {a #{b}}))\n      {}\n      s)]\n    (into \n     #{}\n     (mapcat\n      (fn [[a bs]]\n        (map #(vector a %1) bs)\n        )\n      (for [map-key (keys map-of-rel)]\n        (loop [map-val (map-of-rel map-key) ]\n          (let [len (count map-val)\n                transitives (apply clojure.set/union map-val (map map-of-rel map-val))\n                tr-len (count transitives)\n                ]\n            (if (= len tr-len)\n              [map-key transitives]\n              (recur transitives)\n              )\n            ))\n        )))\n    )\n  )", "problem": 84, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [xs]\n  (let [x2 (into xs (for [[a b] xs [c d] (disj xs [a b]) :when (= b c)] [a d]))]\n    (if (= xs x2)\n      xs\n      (recur x2))))", "problem": 84, "user": "4ea365e2535d7eef308072c5"}, {"code": "#(loop [result %]\n(let [xs (map first result)\n         ys (map last result)\n         partial (clojure.set/union\n                  result\n                  (set (for [y ys\n                               x xs\n                               :when (= x y)]\n                            [(nth xs (.lastIndexOf ys y))\n                             (nth ys (.lastIndexOf xs x))])))]\n  (if (= partial result)\n      result\n    (recur partial))))", "problem": 84, "user": "51f2b8f1e4b0210f90e74556"}, {"code": "#(loop [paths %]\n   (let [newpaths\n         (set\n          (for [start paths\n                end paths\n                :let [edge [(first start) (last end)]]\n                :when (= (last start) (first end))]\n            edge\n            )\n          )\n         allpaths (clojure.set/union paths newpaths)\n         ]\n     (if (= paths allpaths)\n       paths\n       (recur allpaths)\n       )\n     )\n   )", "problem": 84, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [s]\n  (set (concat (mapcat (fn [[pivot-primeiro pivot-segundo :as pivot]]\n                         (map (fn [[_ e]]\n                                [pivot-primeiro e])\n                              ((fn pega-elementos-para-expansao-rec  [[_ pivot-expansao-segundo] acc]\n                                 (let [proximo-elemento (some (fn [[candidato-primeiro _ :as candidato]]\n                                                                (when (= pivot-expansao-segundo candidato-primeiro)\n                                                                  candidato))\n                                                              s)]\n                                   (if (nil? proximo-elemento)\n                                     acc\n                                     (pega-elementos-para-expansao-rec proximo-elemento (conj acc proximo-elemento)))))\n                               pivot\n                               [])))\n                       s)\n               s)))", "problem": 84, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn trans-closure [relation] (loop [R relation previous-size (count R)]\n                                  (let [new-R (reduce (fn [new-R m] (reduce #(if (and (= (second m) (first %2))\n                                                                                        (not-any? #{[(first m) (second %2)]} %1))\n                                                                                 (conj %1 [(first m) (second %2)])\n                                                                                 %1) \n                                                                              new-R\n                                                                              R))   \n                                                          R \n                                                          R)]\n                                 (if (= (count new-R) previous-size)\n                                   new-R \n                                   (recur new-R (count new-R))))))", "problem": 84, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn [coll]\n  (letfn [(f [x] (for [[a b] x\n                       [c d] x\n                       :when (= b c)]\n                   [a d]))]\n    (let [transitions (set (f coll))]\n      (if (clojure.set/subset? transitions coll)\n        coll\n        (recur (clojure.set/union coll transitions))))))", "problem": 84, "user": "51ab4082e4b04e3dc0c27b31"}, {"code": "(fn [e]\n    (let [kp (fn [x] (keep #(if (= (first %) x) (second %)) e))\n          pair (fn [x s] (for [y s] [x y]))\n          n (remove empty? (mapcat #(pair (first %) (kp (second %))) e))\n          ne (into e n)]\n      (if (= e ne) e (recur ne))))", "problem": 84, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn transitive[edges]\n\t(letfn [(next-closure [init-edges]\n\t\t(into init-edges (for [e1 init-edges  e2 init-edges\n\t\t\t:let [[s e] e1 [x y] e2]\n\t\t\t:when (= e x)]\n\t\t\t [s y]\n\t\t))\n\t)]\n\t\t(loop[curr-edges edges]\n\t\t\t(let [next-edges (next-closure curr-edges)]\n\t\t\t\t(if (= curr-edges next-edges)\n\t\t\t\t\tcurr-edges\n\t\t\t\t\t(recur next-edges)\t\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 84, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn transitive [s]\n  (letfn [(add [s [x y :as pair]]\n            (let [new-pair\n                  (reduce\n                   (fn [acc [ex ey :as e]]\n                     (cond\n                      (= ey x) (conj acc [ex y])\n                      (= ex y) (conj acc [x ey])\n                      :else acc)) #{} s)]\n              (clojure.set/union s #{pair} new-pair)))]\n    (reduce (fn [acc e] (add acc e)) #{} s)))", "problem": 84, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn [brs]\n  (let [find-ts (fn [[start end] nodes]\n  (loop [r [[start end]] r_node [start end] nodes nodes last_end end]\n    (let [l_node (first (filter (fn [[s e]] (= s (last r_node))) nodes))]\n     (if (nil? l_node) (conj r [start last_end])\n        (recur (concat r [r_node l_node [(first r_node) (last l_node)]]) l_node (disj nodes l_node) (last l_node)) \n     )\n    )\n  )\n)]\n    (set (apply concat (for [bs brs] (find-ts bs (disj brs bs)))))\n    ;(for [bs brs] [bs (disj brs bs)])\n  )\n)", "problem": 84, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [s] \n  (loop [t s]\n      (let [d (mapcat \n            (fn [[k v]] \n              (map \n                (fn [[m n]] [k n]) \n                (filter (fn [e] (= v (first e))) t)\n                )) t)]\n        (if (clojure.set/subset? d t) t (recur (clojure.set/union d t))))\n  ))", "problem": 84, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn [rels]\n\t(letfn [\n(combinations [groups] (if (empty? groups) [[]] (mapcat #(map % (combinations (rest groups))) (map #(partial cons %) (first groups)))))\n(expand [p1 p2] (cond (= p1 p2) p1 (= (second p1) (first p2)) (vector (first p1) (second p2)) (= (first p1) (second p2)) (vector (first p2) (second p1)) :else ()))\n(squeeze [rels] (filter #(not (empty? %)) (distinct (map #(apply expand %) (combinations (vector rels rels))))))\n(transitive-closure [rels] (if (= rels (squeeze rels)) (set rels) (transitive-closure (squeeze rels))))\n\t\t] (transitive-closure rels)))", "problem": 84, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn warshall [relation]\n  \"Computes the transitive closure of a binary relation.\"\n  (letfn [(extension [pairs]\n            (for [[a b] pairs\n                  [c d] pairs\n                  :when (= b c)]\n              [a d]))\n          \n          (add-extension [pairs]\n            (apply conj\n                   pairs\n                   (extension pairs)))]\n    \n    (loop [curr relation]\n      (let [nxt (add-extension curr)]\n        (if (= curr nxt)\n          curr\n          (recur nxt))))))", "problem": 84, "user": "530578ede4b0d8b024fd3760"}, {"code": "#(loop [ps %]\n    (let [ts (set (for [x ps y %\n\t\t :when (not= x y)] (if (= (second x) (first y)) [(first x) (second y)] x)))]\n      (if (= ts ps)\n        ps\n        (recur ts))))", "problem": 84, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn f [r]\n  (let [s (into r\n            (for [[x y] r [u w] r \n                  :when (= y u)] [x w]))]\n    (if (= s r)\n      s (f s))))", "problem": 84, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn [r]\n  (letfn [(related? [brel1 brel2] (= (last brel1) (first brel2)))\n          (add-rel [brel]\n            (let [addthing (for [r1 brel\n                                 r2 brel\n                                 :when (related? r1 r2)]\n                             [(first r1) (last r2)])]\n              (set (concat brel addthing))))\n          (add-all-rels [brel]\n            (if (= (add-rel brel) brel)\n              brel\n              (recur (add-rel brel))))]\n    (add-all-rels r)))", "problem": 84, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn [edges]\n  (letfn [(edge->hash [edge]\n            (let [[a b] edge]\n              {a #{b}}))\n\n          (edges->graph [edges]\n            (let [hashes (map edge->hash edges)]\n              (apply merge-with clojure.set/union hashes)))\n\n          (followers [graph v]\n            (let [next-steps (graph v)]\n              (concat next-steps (mapcat (partial followers graph) next-steps))))\n\n          (transitive-closure [graph]\n            (set (for [node (keys graph)\n                       follower (followers graph node)]\n                   [node follower])))]\n\n    (-> edges edges->graph transitive-closure)))", "problem": 84, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn transitive-closure [s]\n  (when (seq s)\n    (let [get-next (fn [value s]\n                     (loop [value value\n                            s s\n                            result []]\n                       (let [next-item (first (filter #(= value (first %)) s))]\n                         (if (nil? next-item)\n                           result\n                           (recur (second next-item)\n                                  (remove (hash-set next-item) s)\n                                  (conj result (second next-item)))))))\n          expand (fn ! [s]\n                   (when (>= (count s) 2)\n                     (concat (map #(list (first s) %) (rest s)) (! (rest s)))))\n          head (first s)\n          tail (rest s)\n          linked-items (concat (reverse (get-next (first head) (map reverse tail)))\n                               head\n                               (get-next (second head) tail))\n          new-s (remove #(contains? (set (drop-last linked-items)) (first %)) tail)]\n      (set (concat (expand linked-items) (transitive-closure new-s))))))", "problem": 84, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn trans-close [xs]\n  (letfn [(fixed-point [f x]\n            (->> (iterate f x)\n                 (partition 2)\n                 (drop-while (fn [[a b ]] (not= a b)))\n                 first\n                 first))\n          (trans-step [m]\n            (apply merge \n                   (for [[k v] m]\n                     {k (->> v\n                             (filter m)\n                             (map m)\n                             (apply clojure.set/union v))})))\n          (trans-map [xs]\n            (->> xs\n                 (group-by first)\n                 (map (fn [[x y]]\n                        {x (set (map second y))}))\n                 (apply merge)))\n          (trans-pairs [m]\n            (->> m\n                 (map (fn [[k v]]\n                       (map (comp vec (partial list k)) v)))\n                 (apply concat)))]\n    (->> xs\n         trans-map\n         (fixed-point trans-step)\n         trans-pairs\n         set)))", "problem": 84, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn transitive-closure\n  [s]\n  (into #{} (mapcat #((fn _\n                        ([item s] (_ item s #{}))\n                        ([[a b] s seen]\n                           (filter (complement nil?) \n                                   (mapcat (fn [[c d]] \n                                             (if (and (= b c) (not (seen [a d]))) \n                                               (conj (_ [a d] s (conj seen [a d])) [a d]))) \n                                           (conj s [b b])))))\n % s) s)))", "problem": 84, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(letfn [(update [m k] (update-in m [k] into (mapcat m (m k))))\n\t\t(setify [in] (reduce (fn [s [a b]] (assoc s a (conj (get s a #{}) b))) {} in))\n        (unsetify [s] (set (mapcat #(for [v (second %)] [(first %) v]) s)))]\n  (fn [in] (unsetify (reduce update (setify in) (map first in)))))", "problem": 84, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn f [s]\n  (let [step #(into % (for [[x1 y1] %\n                            [x2 y2] %\n                            :when (= y1 x2)]\n                        [x1 y2]))\n        t (step s)]\n    (if (= (count t) (count s)) s (f t))))", "problem": 84, "user": "530cb5b8e4b02e82168697e0"}, {"code": "#(reduce\n    (fn [r [a b]]\n      (into r (for [[c d] r :when (= b c)] [a d])))\n    %\n    %)", "problem": 84, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [xs] \n   (loop [xs xs]\n     (let [nxs\n          (reduce\n            (fn [a [x1 x2]]\n              (reduce (fn [b [y1 y2]]\n                        (if (= x2 y1) (conj b [x1 y2]) b))\n                      a\n                      a))\n            xs\n            xs )]\n     (if (= nxs xs) nxs (recur nxs)))))", "problem": 84, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn f84 [s]\n    (let [hf1 (fn hf1 [cel cs]\n                  (let [vic (filter #(= (second cel)\n                                        (first %))\n                                    cs)]\n                      (if (empty? vic)\n                          nil\n                          (concat (list (second cel))\n                                  (map second vic)\n                                  (mapcat #(hf1 % cs) vic)))))]\n        (set (mapcat #(conj \n                         (for [a (hf1 % s)]\n                          (vector (first %) a)) %)\n                     s))))", "problem": 84, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn tc [rules-as-set]\n  (let [rules (map (fn [[a b]]\n                     (fn [[m n]] (if (= n a) [m b] [a b]))) rules-as-set)]\n    (loop [tuples rules-as-set]\n      (let [new-tuples (set (mapcat (fn [tuple] (map #(% tuple) rules)) tuples))]\n        (if (= (count new-tuples) (count tuples))\n          new-tuples\n          (recur new-tuples))))))", "problem": 84, "user": "532b43c3e4b09d4e7a9b5531"}, {"code": "(fn [r]\n  (let [x (set (concat r (for [[a b] r\n                               [c d] r\n                               :when (= b c)]\n                           [a d])))]\n    (if (= r x)\n      r\n      (recur x))))", "problem": 84, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [s]\n  (letfn [(step [ele s]\n            (let [n (filter #(= (second ele) (first %)) s)]\n              (if (seq n)\n                (let [t (map #(vec [(first ele) (second %)]) n)]\n                  (cons ele (mapcat #(step % s) t)))\n                [ele])))]\n    (set (mapcat #(step % s) s))))", "problem": 84, "user": "50436470e4b034ff00315d23"}, {"code": "(fn transitive [pairs]\n  (letfn [(trans-merge [[a b] pairs]\n           (let [trans-vec\n                 (for [[x y] pairs :when (= x b)] [a y])]\n             (clojure.set/union #{[a b]} pairs (set trans-vec))))\n          (find-root [pairs]\n            (reduce (fn [[a b] [x y]]\n                      (if (= a y) [x y] [a b]))\n                    pairs))]\n    (if (empty? pairs)\n      pairs\n      (let [root (find-root pairs)\n            sub-trans (transitive (disj pairs root))]\n        (trans-merge root sub-trans)))))", "problem": 84, "user": "52b65f26e4b0c58976d9ad43"}, {"code": "(fn [relation]\n  (let [reachables (fn reachables [graph node]\n        (loop [[x & xs :as neighbors] (seq (get graph node)), result graph]\n            (if (empty? neighbors) result\n                (let [new-graph (reachables graph x)]\n                  (recur xs (assoc new-graph node\n                               (-> #{}\n                                 (into (get new-graph node))\n                                 (into (get new-graph x)))))))))\n        graph \n          (reduce (fn [m [a b]] (update-in m [a] #(conj (or % #{}) b))) { } relation) \n        result-graph\n          (reduce reachables graph (keys graph))]\n\n    (reduce \n       (fn [rel k]\n         (reduce #(conj %1 (vector k %2)) rel (get result-graph k)))\n       #{} (keys result-graph))))", "problem": 84, "user": "53300924e4b019098a6f8b55"}, {"code": "(letfn\n    [(f [[o e] xs] (for [[x y] xs :when (= e x)] [o y]))\n     (g [xs] (for [x xs] (f x xs)))\n     (p [xs] (set (apply concat xs (g xs))))]\n\n  (fn fix [xs]\n    (let [ys (p xs)]\n      (if (= ys xs)\n        ys\n        (recur ys)))))", "problem": 84, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [m]\n  (let [m (group-by first m)\n        m (zipmap (keys m) (map #(map second %) (vals m)))\n        f (fn f [i] (cons i (flatten(map f (get m i)))))]\n    (set(partition 2(flatten(map #(next(interpose (first %) %)) (map f (keys m))))))))", "problem": 84, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [b]\n  (let [fb (fn [s]\n             (set (filter #(not (or (nil? %) (contains? s %)))\n                          (for [x s y s :when (not= x y)]\n                            (if (= (last x) (first y))\n                              [(first x) (last y)])))))\n        nb (fb b)]\n    (if (empty? nb)\n      b\n      (recur (clojure.set/union b nb)))))", "problem": 84, "user": "53460d02e4b084c2834f4a39"}, {"code": "(letfn [(closure [s]\n          (for [[a b] s\n                [c d] s\n                :when (= b c)]\n            [a d]))]\n  \n  (fn transitive-closure [s]\n    (let [cls (-> s closure set)]\n      (if (clojure.set/subset? cls s) s\n        (recur (clojure.set/union\n                s cls))))))", "problem": 84, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [pairs-set]\n  (let [pairs-map (into {} pairs-set)]\n    (into #{} \n          (apply concat\n                 (for [pair pairs-map]\n                   (loop [a (key pair) b (val pair) visited #{b} result [[a b]]]\n                     (let [c (get pairs-map b)]\n                       (if (and c (not (contains? visited c)))\n                         (recur a c (conj visited c) (conj result [a c]))\n                         result))))))))", "problem": 84, "user": "5244a10de4b0d8acf9ed6ab3"}, {"code": "(fn s [r & [t]]\n  (if-let [n (seq (for [[a b] r\n                        [b- c] (or t r)\n                        :when (and (= b b-) (not (r [a c])))]\n                    [a c]))]\n    (s (into r n) n)\n    r))", "problem": 84, "user": "53440c0ae4b084c2834f4a25"}, {"code": "(fn [rel]\n  (let [m (into {} rel)\n        reachable (fn r [from m]\n                    (if (not (contains? m from))\n                      '()\n                      (cons (m from) (r (m from) m))))]\n    (into #{}\n          (apply concat\n                 (for [k (keys m)]\n                   (map (fn [x y] [x y]) (repeat k) (reachable k m)))))))", "problem": 84, "user": "534941d1e4b084c2834f4a60"}, {"code": "(fn [s]\n    (loop [dest s]\n      (let [original-size (count dest)\n            new-items (for [a dest b dest]\n                       (cond\n                        (and (= (first a) (last b))\n                             (not= (last a) (first b)))\n                        (vector (first b) (last a))\n                        \n                        (and (= (last a) (first b))\n                             (not= (first a) (last b)))\n                        (vector (first a) (last b))))\n            new-dest (into dest new-items)\n            new-size (count new-dest)]\n        (if (= original-size new-size)\n          (into #{} (remove nil? new-dest))\n          (recur new-dest)))))", "problem": 84, "user": "530b8580e4b02e82168697cc"}, {"code": "(fn [s]\n\t(let [r (reduce #(apply (partial assoc %) %2) {} s) \n\t\t  rkeys (keys r)\n\t\t  findClosure (fn fc [origKey curKey result] \n\t\t  \t\t\t      (if (contains? r curKey)\n\t\t  \t\t\t      \t  (fc origKey (r curKey) (conj result [origKey curKey]))\n\t\t  \t\t\t      \t  (conj result [origKey curKey])))\n\t\t  ]\n\t\t  (reduce #(into % (findClosure %2 (r %2) #{})) #{} rkeys)\n\t)\n)", "problem": 84, "user": "52bf6946e4b07a9af5792334"}, {"code": "(fn [rs]\n  (letfn\n    [ \n      (xrs [] (filter #(not (contains? rs %)) (apply concat (for [rab rs] (racs rab)))))\n      (racs [rab] (for [rbc (filter #(= (last rab) (first %)) rs)] [(first rab) (last rbc)]))\n    ]\n    (if (empty? (xrs))\n      rs\n      (recur (apply conj rs (xrs)))\n    )\n  )    \n)", "problem": 84, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn [s]\n  (letfn [(find-trans [[x y] s]\n            (->> (filter #(= (first %) y) s)\n                 (map #(vector x (second %)))\n                 (into #{})))]\n    (loop [xs s acc s]\n      (let [f (first xs)\n            r (rest xs)]\n        (if (nil? f)\n          acc\n          (if-let [ts (find-trans f s)]\n            (recur (clojure.set/union r ts) (clojure.set/union acc ts))\n            (recur r acc)))))))", "problem": 84, "user": "52fb64b7e4b047fd55837009"}, {"code": "(fn tc [s]\n   (let [new (for [[x y] s\n                   [x1 y1] s\n                   :when (= y x1)]\n               [x y1])\n         ss (into s new)]\n     (if (= s ss)\n       s\n       (tc ss))))", "problem": 84, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [s]\n  (let [ss (into s (for [[x y] s [z w] s :when (= y z)] [x w]))]\n    (if (= (count ss) (count s)) s (recur ss))))", "problem": 84, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn transitive [s]\n  (let [m (into {} s)\n        s' (into s (keep (fn [[k v]] (when (m v) [k (m v)])) m))]\n    (if (= s s')\n      s\n      (recur s'))\n    ))", "problem": 84, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(let [is-pair? (fn is-pair? [a b] (= (last a) (first b)))\n\n        pairs-for (fn pairs-for [e xs]\n                    (partition 2 (interleave (repeat e)\n                                             (filter (partial is-pair? e) xs))))\n\n        pairs (fn pairs [xs]\n                (mapcat #(pairs-for % (disj xs %)) xs))\n\n        apply-trans (fn [xs]\n                      (map (fn [[a b]] [(first a) (last b)]) (pairs xs)))\n\n        transitive-closure (fn [x0]\n                             (let [xnew (apply-trans x0)\n                                   x1 (set (concat x0 xnew))]\n                               (if (= x0 x1)\n                                 x0\n                                 (recur x1))))]\n    transitive-closure)", "problem": 84, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn __\n  [input]\n  (letfn [(head-and-tails\n            [s e]\n            (let [t (vec (clojure.set/difference s #{e}))\n                  c (count t)]\n              (partition 2 1 (take (dec (* 2 c)) (cycle t)))))\n          \n          (trans-cloj\n            [h t]\n            (filter #(not= % h)\n                    (into #{} (map (fn [s]\n                                     (reduce (fn [r e]\n                                               (if (= (last r) (first e))\n                                                 [(first r) (last e)]\n                                                 r))\n                                             h s))\n                                   t))))]\n    (clojure.set/union input\n                       (into #{}\n                             (mapcat (fn [e]\n                                      (trans-cloj e (head-and-tails input e)))\n                                 input))\n    \n    )))", "problem": 84, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "#(let [r (apply conj % (for [[x y] % [u v] % :when (= y u)] [x v]))]\n   (if (= r %)\n     %\n     (recur r)))", "problem": 84, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [vs]\n  (letfn [(extend [[v1 v2]]\n            (map #(vector v1 (second %))\n                 (filter #(= v2 (first %)) vs)))]\n    (loop [vs vs]\n      (let [next-vs (apply conj vs (mapcat extend vs))]\n        (if (= vs next-vs) \n          vs\n          (recur next-vs))))))", "problem": 84, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn [relset]\n    (let [from->tos (reduce\n                     (fn [r [from to]]\n                       (let [r (update-in r [from] (fnil #(conj % to) []))]\n                         (reduce\n                          (fn [r key]\n                            (reduce\n                             (fn [r [from to]]\n                               (if (contains? (set to) key) (update-in r [from] concat (r key))\n                                   r)) r r)) r (keys r)))) {} relset)]\n      (reduce\n       (fn [r [from tos]]\n         (reduce #(conj %1 [from %2]) r tos)) #{} from->tos)))", "problem": 84, "user": "51c3c6a6e4b0851ac09658f8"}, {"code": "(fn [pairs]\n  (let [relations (into {} pairs)\n        pairs-for (fn [n]\n                    (loop [accum #{}, x (get relations n)]\n                      (if (nil? x)\n                        accum\n                        (recur (conj accum [n x]) (get relations x)))))]\n\t(->> (flatten (vec pairs))\n         (map pairs-for)\n         (reduce clojure.set/union))))", "problem": 84, "user": "53834ed3e4b06839e8705edb"}, {"code": "(fn [data]\n  (let [a (group-by first data)\n        b (group-by second data)\n        common-keys (clojure.set/intersection (set (keys a)) (set (keys b)))\n        new-data (apply clojure.set/union\n                  data\n                  (map \n                   (fn [e]\n                     (set\n                      (for [[_,y] (get a e)\n                            [x,_] (get b e)]\n                        [x,y])))\n                   common-keys))]\n    (if (= new-data data) data (recur new-data))))", "problem": 84, "user": "53800d99e4b06839e8705ebd"}, {"code": "(letfn [(G [s]\n          (set (for [[x y] s [u v] s\n                     :when (= y u)]\n                 [x v])))\n        (U [s t]\n          (if (empty? s) t\n              (recur (rest s) (conj t (first s)))))\n        (X [s]\n          (let [t (U s (G s))]\n            (if (= s t) s\n                (recur t))))]\n  X)", "problem": 84, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn [s]\n    (let [rel (into {} s)\n          f (fn [m k]\n            (assoc m k\n                   (set (drop 1 (take-while identity (iterate rel k))))))\n          results (reduce f {} (keys rel))]\n      (set (for [[k s] results i s]\n             [k i]))))", "problem": 84, "user": "53956118e4b0b51d73faaed6"}, {"code": "(fn [pairs]\n  (letfn [\n          (assoc-pair [m [k v]]\n            ; Returns an updated version of map m with v an element in a set\n            ; associated with key k. A \"multimap\" populated this way can thus\n            ; associate each key with many distict values.\n            (assoc m k (conj (set (m k)) v)))\n\n          (pairs-into [a-map pairs]\n            ; Populates the given multimap with the given key-value pairs.\n            ; Each key k in the resulting multimap is the first element of one\n            ; or more of the given pairs. The key is associated with a set\n            ; containing all elements v such that [k v] is among the given\n            ; pairs.\n            (reduce assoc-pair a-map pairs))\n\n          (make-extender [orig-keys-for-val orig-vals-for-key]\n            ; Returns a function that adds new pairs -- lets call them \"joins\"\n            ; -- to the set and the two multimaps in the given vector argument\n            ; calculated using the given pair. The added joins are those\n            ; resulting by transitivity with the given pair. For example, if\n            ; orig-keys-for-val contained val 2 mapped to the set of keys\n            ; #{... 1 ...}, and if the given pair was [2 3], then [1 3] would\n            ; be added. If orig-vals-for-key contained key 3 mapped to the set\n            ; of vals #{... 4 ...}, then [2 4] would also be added.\n\n            (fn [[added-pairs keys-for-val vals-for-key] [key val]]\n              (let [preceding-joins  (for [k (orig-keys-for-val key)] [k val])\n                    succeeding-joins (for [v (orig-vals-for-key val)] [key v])\n                    ]\n                [(-> added-pairs\n                     (into preceding-joins)\n                     (into succeeding-joins))\n                 (-> keys-for-val\n                     (pairs-into (map reverse preceding-joins))\n                     (pairs-into (map reverse succeeding-joins)))\n                 (-> vals-for-key\n                     (pairs-into preceding-joins)\n                     (pairs-into succeeding-joins))\n                 ])))\n          ]\n\n    ; We grow a set of pairs, last-pairs, where at the ith iteration we add only\n    ; joins of a certain kind: Each has resulted from transitivity on exactly\n    ; i+1 members of the given pairs. (Here, i starts at 1.) We stop when no\n    ; joins are generated that are not already in last-pairs. Thus, even if\n    ; pairs has cycles, we will terminate correctly.\n    (loop [last-pairs\n             #{}\n           [generated-pairs keys-for-val vals-for-key]\n             [pairs (pairs-into {} (map reverse pairs)) (pairs-into {} pairs)]\n           ]\n      (let [new-pairs (remove last-pairs generated-pairs)]\n        (if (empty? new-pairs)\n          last-pairs\n          (recur (into last-pairs new-pairs)\n                 (reduce (make-extender keys-for-val vals-for-key)\n                         [#{} keys-for-val vals-for-key]\n                         new-pairs)))))))", "problem": 84, "user": "533b57c3e4b0e30313ee6ccc"}, {"code": "(fn [r]\n      (loop [r r\n           c (count r)]\n      (let [k reduce\n            r\n            (k\n              (fn [r [a b]]\n                (k (fn [r [f l]]\n                      (let [r (if (= b f) (conj r [a l]) r)]\n                        (if (= l a) (conj r [f b]) r)))\n                    r\n                    r))\n              r\n              r)\n              d (count r)]\n        (if (= c d)\n          r\n          (recur r d)))))", "problem": 84, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn transitive-closure [s]\n  (letfn [(transitions [[a b] s]\n                       ; return a list of all [a c] such that [b c] is in s\n                       (map #(vector a (get % 1)) (filter (fn [[x y]] (= b x)) s)))\n          (all-transitions [s]\n                           ; return the transitions for every element of s\n                           (set (mapcat #(transitions % s) s)))\n          (with-transitions [s]\n            \t\t\t\t; return s with all its transitions unioned in\n\t\t\t            \t(clojure.set/union s (all-transitions s)))\n          (fixed-point [f a]\n                       ; return the fixed point that (f a) converges to\n                       (let [fa (f a)] (if (= fa a) a (recur f fa))))]\n    (fixed-point with-transitions s)))", "problem": 84, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn [coll] (set (reduce #(loop [x %1 res %1]\n                           (if (empty? x) res\n                             (recur (rest x) (concat res (concat [%2] (if (= (second (first x))\n                                                                             (first %2))\n                                                                        [[(ffirst x) (second %2)]]\n                                                                        [])))))) (vec coll) (vec coll))))", "problem": 84, "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 84, "code": "(fn [xs] \n  (let [prod (fn [m o] \n               (let [n (apply (partial map list) o)] \n                 (vec (for [u m] (vec (for [v n] (apply + (map * u v))))))))\n        add (fn [& args] \n              (vec (map (partial apply (comp vec (partial map +))) \n                                 (apply (partial map list) args))))             \n        vs (vec (set (flatten (seq xs))))\n        n (count vs)\n        zs (vec (take n (repeat (vec (take n (repeat 0))))))\n        adj (reduce \n             (fn [m [x y]] (update-in m \n                                      [(.indexOf vs x) (.indexOf vs y)] \n                                      (constantly 1) \n                                      nil)) \n             zs xs)\n        pows (take-while (partial not= zs) (iterate (partial prod adj) adj))\n        clos (apply add pows)]\n    (set (apply concat (for [i (range n)] \n                         (for [j (range n) :when (not= 0 (get-in clos [i j]))] \n                           [(vs i) (vs j)]))))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 84, "code": "(fn transitive-clojure [relations]\n\t(letfn [(vector-to-map [v] \n\t\t\t\t(set (map #(apply hash-map %) v)))\n\t\t\t(map-to-vector [m]\n\t\t\t\t(reduce #(conj %1 (key %2) (val %2)) [] m))\n\t\t\t(project-relations [rels ks]\n\t\t\t\t(set (filter not-empty (clojure.set/project rels ks))))\n\t\t\t(get-keys [rels]\n\t\t\t\t(reduce #(conj %1 (key (first %2))) [] rels))\n\t\t\t(get-vals [rels]\n\t\t\t\t(reduce #(conj %1 (val (first %2))) [] rels))\n\t\t\t(find-trans \n\t\t\t\t([k rels] \n\t\t\t\t\t(let [vs (project-relations rels [k])] \n\t\t\t\t\t\t  (find-trans k rels vs)))\n\t\t\t\t([k rels acc]\n\t\t\t\t\t(let [transitive-keys (get-vals acc)\n\t\t\t\t\t  \t  vs (project-relations rels transitive-keys)\n\t\t\t\t\t  \t  transitive-relations-values (get-vals vs)\n\t\t\t\t\t  \t  transitive-relations (reduce #(conj %1 (hash-map k %2)) #{} transitive-relations-values)\n\t\t\t\t\t  \t  new-transitive-relations (clojure.set/difference transitive-relations acc)]\n\t\t\t\t\t  (if (empty? new-transitive-relations) acc\n\t\t\t\t\t\t  (recur k rels (clojure.set/union acc new-transitive-relations))))))]\n\t\t(let [rels (vector-to-map relations)\n\t\t\t  ks (get-keys rels)]\n\t\t\t(set (map map-to-vector (reduce clojure.set/union (map #(find-trans % rels) ks)))))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 84, "code": "(fn transitive-closure\n  [coll]\n  (let [nodes (reduce #(into %1 %2) #{} coll)\n        paths (for [k nodes a nodes b nodes] [k a b])]\n    (reduce (fn [r [k a b]]\n              (if (and (r [a k]) (r [k b]))\n                (conj r [a b]) r))\n            coll\n            paths)))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 84, "code": "(fn [s]\n    (letfn [(grow-1 [pairs]\n              (let [pairs (vec pairs)\n                    pairs' (for [[a b] pairs\n                                 [bb cc] pairs :when (= b bb)]\n                             [a cc])]\n                (set (concat pairs pairs'))))\n            (grow [pairs]\n              (let [pairs' (grow-1 pairs)]\n                (if (= pairs' pairs)\n                  (set pairs)\n                  (recur pairs'))))]\n      (grow s)))", "user": "4ee26f01535d10e5ff6f5368"}, {"problem": 84, "code": "(fn\n  [coll]\n  (let [m (apply hash-map (apply concat coll))]\n    (letfn [(r [s d v coll]\n              (lazy-seq\n                (if d\n                  (if (contains? v d)\n                    (r nil nil nil coll)\n                    (if (contains? m d)\n                      (let [d' (m d)\n                            v' (conj v d)]\n                        (cons [s d'] (r s d' v' coll)))\n                      (r nil nil nil coll)))\n                  (if (seq coll)\n                    (let [h (first coll)\n                          t (rest coll)\n                          fh (first h)]\n                      (cons h (r fh (second h) #{fh} t)))\n                    nil))))]\n      (set (r nil nil nil coll)))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 84, "code": "(fn trans-clos [ rels ]\n  (set\n    (reduce  (fn [acc [x y]]\n                (->> (filter (fn [[i j]] (= j x)) acc)\n                     (map (fn [[p q]] [p y]))\n                     (concat acc))) \n               rels\n               rels)))", "user": "5398305fe4b0b51d73faaef6"}, {"problem": 84, "code": "(fn [c]\n   (loop [a #{}\n          [[b1 b2] & bs] (seq c)]\n     (if (nil? b1)\n       a\n       (recur (conj a [b1 b2]) \n              (into bs (reduce (fn [s [a1 a2]]\n                                 (cond (= a1 b2) (conj s [b1 a2])\n                                       (= a2 b1) (conj s [a1 b2])\n                                       :else s)) #{} a))))))", "user": "50ae0d24e4b0a40c9cfb08ce"}, {"problem": 84, "code": "(fn [b]\n  (into #{}\n    (mapcat (fn [e]\n              (let [b (cons e (disj b e))]\n                ((fn f [b]\n                   (when-let [z (first b)]\n                     (cons z\n                       (let [s (first (filter #(= (z 1) (% 0)) b))\n                             o [(z 0) (get s 1)]]\n                         (if s \n                           (cons o (f (cons o (rest b))))\n                           (f (rest b))))))) b))) b)))", "user": "4ee4f4a9535d1385b2869d85"}, {"problem": 84, "code": "(fn [points]\n  (letfn [(belongs-in [a b]\n            (seq (filter #(or (= (first a) (second %1))\n                              (= (first %1) (second a)))\n                         b)))\n          (partit [ps]\n            (loop [parts (set (map #(conj #{} %1) ps))\n                   es ps]\n              (if-not (seq es)\n                parts\n                (recur (set\n                        (for [p parts, e ps\n                              :when (belongs-in e p)]\n                          (conj p e)))\n                       (rest es)))))\n          (domain [ps]\n            (map #(first %1) ps))\n          (codomain [ps]\n            (map #(second %1) ps))\n          (tclosure [ps]\n            (into ps\n                  (for [x (domain ps) y (codomain ps)\n                        :when (not (or (= x y)\n                                       (ps [y x])))]\n                    [x y])))]\n    (into points ; cheats :(\n          (apply concat (map tclosure (partit points))))))", "user": "5341b141e4b00652c8746ecf"}, {"problem": 84, "code": "(fn transitive-closure [closure]\n  (let [new-closure (reduce clojure.set/union closure (map (fn [[a b]]\n                                      (map #(vector a (last %)) (filter #(= (first %) b) closure))\n                                      ) closure))]\n    (if (= new-closure closure)\n      closure\n      (recur new-closure)\n      )\n    )\n  )", "user": "5245e320e4b09dbe66b56177"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(combin-edges [edges [ds de]]\n                        (reduce \n                         (fn [result [ss se]]\n                           (cond\n                            (= ss de)\n                            (combin-edges (conj result [ds se]) [ds se])\n                            (= se ds)\n                            (combin-edges (conj result [ss de]) [ss de])\n                            :else result))\n                          edges\n                         edges))]\n    (reduce\n     #(combin-edges (conj %1 %2) %2)\n     #{}\n     s)))", "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 84, "code": "(fn [input-set]\n  (let [m (reduce (fn [m [k v]] (assoc m k v)) {} input-set)\n        f (fn [input-map master-key]\n            (loop [k master-key output-map []]\n              (if (contains? input-map k)\n                (recur (input-map k) (conj output-map [master-key (input-map k)]))\n\t             output-map)))]\n    (set (reduce #(apply conj %1 %2) [] (map #(f m %) (keys m))))))", "user": "53513d28e4b084c2834f4ae3"}, {"problem": 84, "code": "(fn [z] (let [s (into '() z)]                                                                                                                                                                            \n                 (letfn [(retry [s last-acc acc] (let [m (count (distinct acc)) n (count (distinct last-acc))]                                                                                                  \n                                                   (if (and (pos? n)  (= m n)) (into #{} (distinct acc)) (retry s (distinct acc) (merge-links s (distinct acc))))))                                             \n                         (merge-two-links [s] (if (= 1 (count s)) s                                                                                                                                             \n                                                  (let [[[v0 v1] [u0 u1]] s] (cond                                                                                                                              \n                                                           (= v0 u1) [[v0 v1] [u0 u1] [u0 v1]]                                                                                                                  \n                                                           (= v1 u0) [[v0 v1] [u0 u1] [v0 u1]]                                                                                                                  \n                                                           :else [[v0 v1] [u0 u1] ]))))                                                                                                                         \n                   (merge-links [s acc] (reduce (fn [acc1 e1] (into []  (mapcat #(merge-two-links [e1 %]) acc1))) acc s))]                                                                                      \n                   (retry (rest s) [] [(first s)]) )))", "user": "52265e41e4b04e78ff2e1981"}, {"problem": 84, "code": "(fn transitive-closure [xs]\n  (letfn [(add-pair [xs [a b]]\n  (clojure.set/union\n   xs\n   #{[a b]}\n   (set (for [[ax bx] xs :when (= bx a)] [ax b]))\n   (set (for [[ax bx] xs :when (= ax b)] [a bx]))\n   (set (for [[ax bx] xs [ay by] xs :when (and (= bx a) (= ay b))] [ax by]))))]\n    (reduce add-pair #{} xs)))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 84, "code": "(fn tc [input]\n  (letfn [(descendant?\n            [a b]\n            (= (first b) (second a)))\n          (extend-relation\n            [a b]\n            (if (descendant? a b) (vector (first a) (second b))))\n          (new-relations\n            [b binaries]\n            (remove (comp nil?) (map #(extend-relation b %) binaries)))\n          (one-deep\n            [binaries]\n            (remove #(= % '()) (mapcat #(new-relations % binaries) binaries)))\n          (add-relations\n            [binaries]\n            (into binaries (one-deep binaries)))]\n    (loop [old input new #{}]\n      (if (= old new)\n        old\n        (recur (add-relations old) old)))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (let [expansion (into s (mapcat (fn [r] (map (fn [s] [(first s) \n                                                        (last r)]) \n                                               (filter #(= (first r) \n                                                           (last %)) \n                                                       s))) \n                                  s))]\n    (if (= expansion s)\n      s\n      (transitive-closure expansion))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(i [m s] (into s (remove nil? (map #(if-let [n (m (% 1))] (assoc-in % [1] n)) s))))]\n\t(second (first (drop-while #(apply not= %) (partition 2 (iterate #(i (into {} s) %) s)))))))", "user": "514d8084e4b019235f6c0588"}, {"problem": 84, "code": "(fn expand [r]\n  (let [re (set (mapcat (fn [i] (cons i (for [j ((group-by first r) (second i))] [(first i) (second j)]))) r))]\n    (if (= re r) r (recur re))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 84, "code": "(fn f [pairs]\n  (let [generated (set (for [[k1 v1] pairs\n                             [k2 v2] pairs]\n                         [k1 (if (= k2 v1) v2 v1)]))]\n    (if (= pairs generated)\n      pairs\n      (f generated))))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 84, "code": "(fn transitive-closure [base-relations]\n  (let [x-relations (fn x-relations [current-element base-relations]\n                      (let [direct-relatives (->> base-relations\n                                                  (filter #(= current-element (first %)))\n                                                  (map second))\n                            indirect-relatives (mapcat #(x-relations % base-relations) direct-relatives)]\n                        (concat direct-relatives indirect-relatives)))\n        transitive-relations (fn [current-element base-relations]\n                               (map #(vector %1 %2)\n                                    (repeat current-element)\n                                    (x-relations current-element base-relations)))\n        left-elements (map #(first %) base-relations)]\n    (into #{} (mapcat #(transitive-relations % base-relations) left-elements))))", "user": "53527551e4b084c2834f4af0"}, {"problem": 84, "code": "(letfn [(tr-clos [rel-pairs]\n                   (set (filter (frel? rel-pairs)  (all-pairs rel-pairs))))\n          (frel? [pairs] ;set of pairs\n                 (letfn [(rel? [a b]\n                               (or \n                                 (contains? pairs [a b])\n                                 (some #(rel? % b) (direct a))))\n                         (direct [a]; directly related items\n                                 (map second (filter #(= (first %) a) pairs))) \n                         ]\n                   (fn [pair] (apply rel? pair))))\n          (all-pairs [pairs] \n                     (let [els (all-elems pairs)]\n                       (for [x els y els :when (not= x y)] [x y])))\n          (all-elems [pairs]\n                     (reduce #(conj (conj %1 (first %2)) (second %2)) #{} pairs))\n          ]\n    tr-clos\n    )", "user": "50eddbc4e4b06330c1f87c4b"}, {"problem": 84, "code": "(fn [xs]\n    (loop [rs xs]\n      (let [ds (loop [r1 rs ys rs]\n                 (do (println r1 ys)\n        (if (empty? r1)\n            ys\n            (recur (rest r1)\n                   (reduce (fn [zs r] (if (= (get r 0) (get (first r1) 1))\n                               (conj zs (vector (get (first r1) 0) (get r 1)))\n                               zs)) (set ys) ys)\n            )\n          )\n        ))]\n        (if (= (count ds) (count rs))\n          ds\n          (recur (set ds))))))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 84, "code": "(fn transitive-clojure [initial-set]\n     (->> initial-set\n       (iterate (fn extend-iter [base-set]\n                  (into base-set\n                        (for [[base-from base-to] base-set\n                             [extend-from extend-to] base-set\n                             :when (= base-to extend-from)\n                             :when (not (contains? base-set [base-from extend-to]))] [base-from extend-to]))))\n       ((fn first-same [[actual_ next_ & rest_ :as x]]\n          (if (= actual_ next_) actual_ (recur (rest x)))))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 84, "code": "(fn [r] \n\t(let [n (set (concat r (for [[a b] r [c d] r :when (= b c)] [a d])))]\n\t\t(if (= r n) r (recur n))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 84, "code": "(fn closure [s]\n  (let [nodes (distinct (flatten (vec s)))\n        touch? (fn [k i j edges]\n                 (or (edges [i j]) (and (edges [i k]) (edges [k j]))))]\n    (reduce (fn [edges [k i j :as nodes]] (if (touch? k i j edges)\n                                            (conj edges [i j])\n                                            edges)) s (for [k nodes i nodes j nodes] [k i j]))))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 84, "code": "(fn g [s]\n  (let [f first l last\n        e (into s\n                (for [x s\n        \t\t\t  y s\n        \t          :when (= (f x) (l y))]\n    \t         [(f y) (l x)]))]\n    (if (= e s) s (g e))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 84, "code": "(fn transitiveclosure [m]\n     (loop [storage #{} result m]\n       (if (= storage result)\n         result\n         (recur result (set (into result (for [x result\n                                               y result\n                                               :when (= (peek x) (first y))]\n                                           (vector (first x) (peek y)))))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 84, "code": "(fn t133 [relation]\n  (loop [old_relations relation]\n    (let [r (for [e1 old_relations\n                  e2 old_relations\n                  :when (not= e1 e2)\n                  :when (= (second e1) (first e2))]\n                  [(first e1) (second e2)])\n          new_relations (clojure.set/union old_relations r)]\n      (if (= new_relations old_relations)\n        new_relations\n        (recur new_relations)))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 84, "code": "(fn transitive-clojure [rel]\n  (let [expand (fn [rel]\n              (loop [[[a b] & more] (seq rel)\n                     tc rel]\n                (if-not a\n                  tc\n                  (let [new-rels (for [[c d] rel :when (= b c)]\n                                   [a d])]\n                    (recur more (into tc new-rels))))))]\n  \n  (loop [tc rel]\n    (let [new-tc (expand tc)]\n      (if (= (count tc) (count new-tc))\n        tc\n        (recur new-tc))))))", "user": "52d3f666e4b09f7907dd1327"}, {"problem": 84, "code": "(fn [s]\n         (let [m (into {} s)]\n           (loop [s s]\n             (let [s2 (clojure.set/union s (set (remove #(-> % second nil?) (map vector (map first s) (map #(->> % second (get m)) s)))))]\n               (if (= s s2) s (recur s2))))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 84, "code": "(fn [r]\n    (loop [r+ #{} for-r r]\n      (if (seq for-r)\n        (let [[a b] (first for-r)\n              in-r1 (filter (fn [[r-a _]] (= b r-a)) r+)\n              in-r2 (filter (fn [[_ r-b]] (= a r-b)) r+)]\n          (recur (conj (into (into r+ (map (fn [[_ r-b]] [a r-b]) in-r1))\n                             (map (fn [[r-a _]] [r-a b]) in-r2))\n                       (first for-r))\n                 (rest for-r)))\n        r+)))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 84, "code": "(fn !! [org-set]\n    ((fn ! [aset clone]\n       (if (empty? aset)\n         #{}\n         (let [y (first aset)\n               more (map (juxt (fn [_] (first y)) last) (filter #(= (last y) (first %)) clone))]\n           (if (and (seq more) (not= clone (clojure.set/union clone more)))\n             (!! (clojure.set/union clone more))\n             (conj (! (disj aset y) clone) y))))) org-set org-set))", "user": "504e1abee4b0f6ff3350c45d"}, {"problem": 84, "code": "(fn [is]\n  (loop [s is]\n    (let [cont (into #{} \n                    (for [[a b] s\n                          [c d] s\n                         :when (= b c)]\n                      [a d]))\n          whole (clojure.set/union s cont)]\n      (if (= whole s)\n        whole\n        (recur whole)))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 84, "code": "(fn [relation]\n  (letfn [(expand [r] \n            (let [m (into {} r)] \n              (->> (concat \n                     r\n                     (for [[k v] m] \n                       (when-let [nv (m v)] [k nv]))) \n                (filter identity) \n                set)))\n          (first-consecutive [pred [f & rs]] \n            (when rs\n              (if (pred f (first rs))\n                f\n                (recur pred rs))))]\n    (first-consecutive = (iterate expand relation))))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 84, "code": "(fn [rels]                                                                                                                                                                                                                                                                \n  (let [add (for [r1 rels                                                                                                                                                                                                                                                      \n                  r2 rels                                                                                                                                                                                                                                                      \n                  :let [p [(first r1) (second r2)]]                                                                                                                                                                                                                            \n                  :when (and (= (second r1) (first r2))                                                                                                                                                                                                                        \n                             (not (contains? rels p)))]                                                                                                                                                                                                                        \n              p)]                                                                                                                                                                                                                                       \n    (if (empty? add)                                                                                                                                                                                                                                                           \n      rels                                                                                                                                                                                                                                                                     \n      (recur (into rels add)))))", "user": "4dadb5f4c9a9d6ed3399dc57"}, {"problem": 84, "code": "(fn [rs]\n (let [r (into {} rs)]\n   (set (mapcat #(take-while (comp not nil? second)\n                             (iterate (fn [[k v]] [k (r v)])\n                                      %))\n                r))))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 84, "code": "(fn t[s]\n  (let [ r\n(->> (map(fn[x]\n      (->> (filter #(= (x 1)(% 0))s)\n           (map second)\n           (map #(vector (first x) %))\n      ))s)\n     (apply concat s)\n     (set))]\n    (if (= r s) s (t r))))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 84, "code": "#(let [g (fn [s] (into s (for [a s b s] (let [c (get a 0) d (get a 1) e (get b 0) f (get b 1)] (cond (= c f) [e d] (= e d) [c f] :else [c d])))))] (g (g %)))", "user": "53fddd71e4b0de5c418485eb"}, {"problem": 84, "code": "(fn [xs]\n  (let [genmap (into {} xs)]\n    (reduce (fn conjtrans [ys [a b]] (if (genmap b) \n                                       (conj (conjtrans ys [a (genmap b)]) [a b]) \n                                       (conj ys [a b]) )) \n            #{} xs)))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 84, "code": "(fn [s]\n(loop [edges s\n       lastIter #{}]\n (if (= edges lastIter) edges\n  (recur (into edges (mapcat (fn [[a b]] (mapcat  (fn [[x y]] (if (= b x) [[a y]] [])) edges)) edges)) edges))))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 84, "code": "(fn a [m]\n  (loop [ms m c 0]\n    (if (= (count ms) c)\n      ms\n      (let [nms (for [[x1 x2] ms\n                      [y1 y2] ms\n                      :when (= x2 y1)]   \n                  [x1 y2])\n            res (into ms nms)]\n        (recur res (count ms))))))", "user": "51aefceee4b09397d5109797"}, {"problem": 84, "code": "(fn [s]\n  (loop [w1 \"\", w2 \"\", rm (seq s), acc #{}]\n    (cond (and (empty? rm) (= \"\" w1)) acc\n          (= \"\" w1) (recur (-> rm first first) (-> rm first second) (rest rm) (conj acc (first rm)))\n          :else (let [r (first (filter #(= w2 (first %)) s))\n                      w3 (second r)]\n                  (if (nil? r)\n                    (recur \"\" \"\" rm acc)\n                    (recur w1 w3 rm (conj acc (vector w1 w3))))))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 84, "code": "(fn [my-set]\n  (loop [accu my-set\n         prev #{}]\n    (if-not (= accu prev)\n      (recur (into accu (for [x accu y accu\n                              :when (= (last x) (first y))]\n                          [(first x) (last y)]))\n             accu)\n      accu)))", "user": "540d7dd1e4b0addc1aec6713"}, {"problem": 84, "code": "(fn clo [rel]\n   (let [new-seq (for [[a x] rel\n                       [y c] rel\n                       :when (= x y)]\n                   [a c])\n         new-set (set new-seq)\n         new-excl (clojure.set/difference new-set rel)]\n     (if (seq new-excl)\n       (clo (clojure.set/union rel new-set))\n       rel)))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 84, "code": "(fn [init-edges]\n  (let [init-edges (set init-edges),\n        verts (vec (set (flatten (seq init-edges)))),\n        adj? (fn [x y] (not= nil (init-edges (vector x y)))),\n        n (count verts),\n        warshall ((fn []\n                   (let [prepare-mx #(->> (or (= i j) \n                                              (adj? (nth verts i) (nth verts j))) \n                                          (for [j (range n)]) \n                                          vec \n                                          (for [i (range n)]) \n                                          vec),\n                         newval (fn [mx [i j k]] (or (get-in mx [i j]) \n                                                     (and (get-in mx [i k]) \n                                                          (get-in mx [k j]))))]\n                     (reduce (fn [mx [i j k]] (assoc-in mx [i j] (newval mx [i j k])))\n                             (prepare-mx)\n                             (for [k (range n), x (range n), y (range n)] [x y k]))))),\n        transitive-closure (fn [] \n                             (reduce \n                              (fn [edges [i j]] (if (and (not= i j) (get-in warshall [i j])) \n                                                  (conj edges (vector (nth verts i) \n                                                                      (nth verts j)))\n                                                  edges))\n                              #{}\n                              (for [x (range n), y (range n)] [x y])))]\n    (transitive-closure)))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 84, "code": "(fn e84 [s]\n  (let [a (set (into s (for [[a b] s [c d] s\n                           :when (= b c)]\n                       [a d])))\n        ]\n    (if (= a s) s (recur a))))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 84, "code": "(fn [r]\n  (let [inter clojure.set/intersection\n        union clojure.set/union\n        diff clojure.set/difference\n        adj-tab (apply merge-with union (map (fn [[x y]] {x #{y}}) r))\n        nodes (into #{} (flatten (seq r)))]\n    (letfn [(reach [xs vs ys]\n              (if (empty? vs) xs\n                (let [vs' (inter ys (apply union (map #(adj-tab %) vs)))]\n                  (recur (union xs vs) vs' (diff ys vs')))))\n            (reach' [v]\n              (disj (reach #{} #{v} (disj nodes v)) v))\n            (reach-r [v]\n              (into #{} (map #(-> [v %]) (reach' v))))]\n      (apply union (map #(reach-r %) nodes)))))", "user": "508157b2e4b0946d0443855c"}, {"problem": 84, "code": "(fn transitive-closure\n  [set]\n  (let [relations (into {} set)\n        pairs (reduce\n               (fn [s [k v]]\n                 (loop [v v s s]\n                   (if (contains? relations v)\n                     (recur (get relations v) (conj s [k (get relations v)]))\n                     s)))\n               set\n               relations)]\n    pairs))", "user": "51f9527fe4b09be9c177e549"}, {"problem": 84, "code": "(fn [x]\n  (loop [curr x last []]\n    (let [imap (reduce (fn [acc [k v]] (update-in acc [k] #(conj % v))) {} curr)]\n      (if (= (count curr) (count last))\n        curr\n        (recur (set (apply concat (for [[a b] x]\n                                    (if (contains? imap b)\n                                      (cons [a b] (for [v (imap b)] [a v]))\n                                      [[a b]]))))\n               curr)))))", "user": "4ff9a200e4b0678c553fc3ab"}, {"problem": 84, "code": "(fn transit[r]\n  (let[rules (reduce #(assoc %1 (first %2) (second %2)) {} r)\n       deduct (fn [orig dest result]\n                (if (contains? result [orig dest]) result\n                  (let[newResult (conj result [orig dest])]\n                   (if (contains? rules dest) (recur orig (rules dest) newResult)\n                    newResult))))]\n    (loop[rs r result #{}]\n      (if (seq rs)\n        (let[rule (first rs)]\n          (recur (rest rs) (deduct (first rule) (second rule) result)))\n        result))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 84, "code": "(fn\n  [coll]\n  (let [helper (fn [acc coll]\n                 (if (seq coll)\n                   (let [[h t] (first coll)\n                         coll2 (map (fn [[_ t2]] [h t2])\n                                    (filter (fn [[h2 _]] (= h2 t)) acc))]\n                     (recur (set (concat acc coll2)) (rest coll)))\n                   acc))]\n    (helper coll coll)))", "user": "4e521cef535d302ef430da6d"}, {"problem": 84, "code": "(fn mm [all]\n  (let [all-map (into {} (seq all))\n        link (reduce (fn [rset key]\n                       (if-let [nex (all-map (key 1))]\n                          (loop [r (conj key nex)\n                                 ne nex]\n                            (if-let [nex (all-map ne)]\n                              (recur (conj r nex) nex)\n                              (conj rset r)))\n                          (conj rset key)))\n                     #{} all)]\n    ;(println link)\n    (set (mapcat seq (mapcat (fn [one]\n                          (loop [result []\n                                 src one]\n                            (if (= 1 (count src))\n                              result\n                              (recur (conj result (seq (map #(vector (first src) %)\n                                                            (rest src))))\n                                     (rest src)))))\n                        link)))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 84, "code": "(fn gtc [s]\n\t(let [find-relations (fn [p s]\n\t\t\t\t\t\t\t\t(filter \n\t\t\t\t\t\t\t\t\t(fn [x]\n\t\t\t\t\t\t\t\t\t\t(or (= (x 0) (p 1))\n\t\t\t\t\t\t\t\t\t\t\t(= (x 1) (p 0))))\n\t\t\t\t\t\t\t\t\ts\n\t\t\t\t\t\t\t\t))\n\t\tctc\t\t\t\t (fn [p1 p2]\n\t\t\t\t\t\t\t(if (=( p1 0) (p2 1))\n\t\t\t\t\t\t\t\t[(p2 0) (p1 1)]\n\t\t\t\t\t\t\t\t[(p1 0) (p2 1)]\n\t\t\t\t\t\t\t))\n\t\ttc\t\t\t\t (fn [p s]\n\t\t\t\t\t\t\t(loop [s1 s result []]\n\t\t\t\t\t\t\t\t(if (not-empty s1)\n\t\t\t\t\t\t\t\t\t(recur \n\t\t\t\t\t\t\t\t\t\t(rest s1) \n\t\t\t\t\t\t\t\t\t\t(conj result (ctc p (first s1)))\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\tresult)\n\t\t\t\t\t\t\t\t))\n\t\trtc\t\t\t\t (fn [s]\n\t\t\t\t\t\t\t(loop [p (first s) r (rest s) result #{}]\n\t\t\t\t\t\t\t\t\t(if (not-empty r)\n\t\t\t\t\t\t\t\t\t\t(let [rels (find-relations p r)\n\t\t\t\t\t\t\t\t\t\t\t  tcr  (tc p rels)]\n\t\t\t\t\t\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t\t\t\t\t\t(first r)\n\t\t\t\t\t\t\t\t\t\t\t\t(rest r)\n\t\t\t\t\t\t\t\t\t\t\t\t(if (empty? tcr) \n\t\t\t\t\t\t\t\t\t\t\t\t\t(conj result p) \n\t\t\t\t\t\t\t\t\t\t\t\t\t(into (conj result p) tcr)\n\t\t\t\t\t\t\t\t\t\t\t\t)) \n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t(conj result p)\n\t\t\t\t\t\t\t\t\t)))]\n\t(loop [n 0, result (rtc s)]\n\t\t(if (= n (-> s count dec))\n\t\t\tresult\n\t\t\t(recur (inc n) (into result (rtc result)))\n\t\t))\n\t))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": 84, "code": "#(loop [[[x y :as q] & r] (seq %) c %]\n   (if q\n     (recur (concat r (for [[w z] % :when (= y w)] [x z])) (conj c q))\n     c))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 84, "code": "(fn [inp]\n  (loop [acc #{}\n         ctr 0]\n    (if (= ctr (count inp))\n      acc\n      (recur (let [rem (clojure.set/difference inp acc)\n                   current (first rem)\n                   trans (filter #(= (last current) (first %)) (clojure.set/union inp acc))\n                   adds (map #(vector (first current) (last %)) trans)]\n               (apply conj acc (conj adds current))) (inc ctr)))))", "user": "542c22bde4b0dad94371f29e"}, {"problem": 84, "code": "(fn transitive-closure [s]\n\t(letfn [(calc-path [m a]\n\t\t\t\t(loop [prev a verts []]\n\t\t\t\t\t(if (m prev)\n\t\t\t\t\t\t(recur (m prev) (conj verts (m prev)))\n\t\t\t\t\t\tverts)))\n\t\t]\n\t\t(loop [[[a b] & r] (seq s) m {}]\n\t\t\t(if a\n\t\t\t\t(recur r (assoc m a b))\n\t\t\t\t(into #{}\n\t\t\t\t\t(mapcat (fn [k]\n\t\t\t\t\t\t\t(map #(vector k %) (calc-path m k)))\n\t\t\t\t\t(keys m)))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 84, "code": "(fn [rels]\n  (let [by-second (group-by first rels)\n        ext-rels (into rels (mapcat (fn [[f s]] (for [[_ s2] (by-second s)] [f s2])) rels))]\n    (if (= (count rels) (count ext-rels))\n      ext-rels\n      (recur ext-rels))))", "user": "4db92654535d1e037afb21a0"}, {"problem": 84, "code": "(fn [set0]\n    (let [\n          smap (into {} set0)\n          sjoin (fn [sset [a b]] (if (contains? smap b) (conj sset [a (smap b)]) sset))\n          redux (fn [[sset n]] [(reduce sjoin sset sset) (count sset)])\n          ]\n     (->>\n      [set0 0]\n      (iterate redux)\n      (drop-while (fn [[sset n]] (< n (count sset))))\n      ffirst\n  )))", "user": "5281a445e4b0757a1b17143a"}, {"problem": 84, "code": "(fn [rels]\n  (letfn [(r [accum [f t]]\n            (apply conj accum [f t]\n                   (concat\n                     (for [[kf kt] accum\n                           :when (= kt f)]\n                       [kf t])\n                     (for [[kf kt] accum\n                           :when (= t kf)]\n                       [f kt]))))]\n    (reduce r #{} rels)))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 84, "code": "(fn [rels]\n  (letfn [(step [rs]\n            (into rs\n              (for [[a b] rs\n                    [x y] rs\n                    :when (= b x)]\n                [a y])))]\n    (ffirst (drop-while (fn [[a b]] (not= a b))\n                       (partition 2 1 (iterate step rels))))))", "user": "505aa653e4b021387fb89857"}, {"problem": 84, "code": "(fn tc [R]\n  (let [pairs  (set (for [[a b] R [c d] R :when (= b c)] \n                  [a d]))]\n    (if-let [diff (not-empty (clojure.set/difference pairs R))]\n      (tc (clojure.set/union diff R))\n      R)))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 84, "code": "(fn [s]\n  (let [tr (group-by first s)\n        d (fn [[a b]] (map #(vector a (second %)) (tr b)))\n        f (fn f [e]\n            (let [a (d e)]\n              (concat [e] a (mapcat f a))))]\n    (set (mapcat f s))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 84, "code": "(fn [s]\n  (loop [[f & rest :as in] (into [] s) result s]\n    (cond (empty? in) result\n          :else (let [[in out] f\n                      matches (filter #(= out (first %)) result)]\n                  (recur rest (into #{} (concat result (into #{} (for [[first second] matches] [in second])))))))))", "user": "5472cba1e4b094393f72dd7a"}, {"problem": 84, "code": "(fn trans-closure\r\n  [s]\r\n  (letfn [(ancests\r\n            [a s]\r\n            (let [children (filter #(= a (first %)) s)]\r\n              (if (empty? children)\r\n                []\r\n                (mapcat\r\n                  #(cons (second %) (ancests (second %) s))\r\n                  children))))]\r\n    (into #{}\r\n      (concat s\r\n        (mapcat\r\n          (fn [a]\r\n            (map\r\n              #(vector (first a) %)\r\n              (ancests (second a) s)))\r\n          s)))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 84, "code": "(fn [s]\n  (letfn\n    [(cross [s]\n            (mapcat (fn [e1] (map (fn [e2] [e1 e2]) s)) s))\n     (items [s] (set (flatten (seq s))))\n     (property [x y i]\n               (if (s [x y])\n                 true\n                 (if (not-empty i)\n                   (some #(and \n                           (property x % (disj i x y)) \n                           (property % y (disj i x y))) \n                         i))))]\n    (set (filter (fn [[x y]] (property x y (disj (items s) x y))) (cross (items s))))))", "user": "5478e57de4b0c51c1f4d72c1"}, {"problem": 84, "code": "(fn link [coll]\n  (let [adds (for [[a b] coll, [c d] coll :when (and (= b c) (nil? (coll [a d])))] [a d])]\n    (if (seq adds)\n      (link (into coll adds))\n      coll)))", "user": "541f5b37e4b01498b1a71a97"}, {"problem": 84, "code": "(fn my-transitive-closure [relation]\n  (let [ next-relation (fn next-relation [relation]\n                         (reduce into relation (for [[x y] relation]\n                                                 (for [[a b] relation :when (= y a)]\n                                                   [x b]))))\n         ]\n   (reduce (fn [rel x] (next-relation rel)) relation (range 0 (dec (count relation))))))", "user": "5224a46ce4b01819a2de42e5"}, {"problem": 84, "code": "(fn [r]\n  (let [r' (into r\n                 (for [[a b] r\n                       [c d] r :when (= b c)]\n                   [a d]))]\n    (if (= r r')\n      r\n      (recur r'))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 84, "code": "(fn transclo [aset]\n  (letfn [(get-transitive [data-map k]\n            (let [m data-map\n                  cur-key k\n                  vals (get m k)\n                  acc #{}]\n              (if (nil? vals)\n                acc\n                      (apply concat vals (map #(get-transitive m %) vals)))))]\n  (->> aset\n      (reduce (fn [acc [k v]] (into acc {k [v]})) {})\n      (#(map (fn [[k vcoll]] {k (get-transitive % k)}) %))\n      (apply merge)\n      (map (fn [[k vcoll]] (map #(vector k %) vcoll)))\n      (apply concat)\n      (set))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 84, "code": "(fn f [z] (#(if (= % z) z (f %))\n    (set (for [[x1 x2] z [y1 y2] z] \n           [x1 (if (= x2 y1) y2 x2)]))))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 84, "code": "(fn [facts]\n  (let [mapping (reduce (fn [result [k v]]\n                          (assoc result k (conj (get result k #{}) v)))\n                        {}\n                        facts)\n        new-mapping (apply merge (for [[k values] mapping\n                                       v values\n                                       new-value (mapping v)]\n                                   (assoc {} k new-value)))\n        merged-mapping (reduce (fn [result [k v]]\n                                 (assoc result k (conj (get result k #{}) v)))\n                               mapping\n                               new-mapping)\n        new-facts (into #{} (for [[k values] merged-mapping\n                            v values]\n                        [k v]))]\n    (if (= new-facts facts)\n      new-facts\n      (recur new-facts))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 84, "code": "(fn transitive-closure-generator [s]\n  (letfn [(search [[a b]]\n            (cons [a b]\n                  (mapcat search\n                       (map (fn [x] [a (second x)])\n                            (filter #(= b (first %)) s)))))]\n    (set (mapcat search s))))", "user": "546c1f73e4b00cfc9eacc175"}, {"problem": 84, "code": "(fn [graph]\n  (letfn [(reachables [src]\n            (let [neighbors (->> graph\n                                 (filter (fn [[a b]] (= a src)))\n                                 (map second))]\n              (concat neighbors\n                      (mapcat reachables neighbors))))]\n    (set (mapcat (fn [src]\n                   (map #(vector src %)\n                        (reachables src)))\n                 (set (map first graph))))))", "user": "547584d9e4b0c51c1f4d729b"}, {"problem": 84, "code": "(fn [xs]\n  (letfn [(n+ [xs]\n            (reduce\n             #(if %2 (conj %1 %2) %1)\n             xs\n             (for [x xs y xs]\n               (cond\n                 (= (first x) (second y)) [(first y) (second x)]\n                 (= (first y) (second x)) [(first x) (second y)]\n                 :else nil))))]\n    (loop [n xs n+1 (n+ n)]\n      (if (= n n+1) n\n          (recur n+1 (n+ n+1))))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 84, "code": "(fn transitive-closure [pairs]\n  :pre (nil? (filter #(and (vector? %) (= 2 (count %))) pairs))\n  (let [add (fn [m [k v]] (assoc m k (conj (m k #{}) v)))\n        m (reduce add {} pairs)\n        toClosure (fn [resMap]\n                    (set (mapcat (fn [[k vs]]\n                              (map #(vector k %) vs)\n                              ) (seq resMap)))\n                    )\n        ]\n    (toClosure\n      (reduce\n        (fn [res k]\n          :pre (and (set? res))\n          ((fn go [seen acc xs]\n             :pre (and (set? seen) (set? xs))\n             (if-let [x (first xs)]\n               (if (seen x)\n                 (go seen acc (disj xs x))\n                 (let [seenx (conj seen x)]\n                   (go\n                     seenx\n                     (reduce add acc (map #(vector k %) (acc x)))\n                     (reduce #(conj %1 %2) xs (remove seenx (acc x)))))\n                 )\n               acc\n               )\n             ) #{k} res (res k))\n          ) m (keys m)))\n    )\n  )", "user": "5488872ee4b0e286459a11d3"}, {"problem": 84, "code": "(fn [m]\n  (->> m\n    vec\n    (reduce\n     (fn [ll x]\n       (let [xs (set x)\n             [l nl] (reduce (fn [[a b] lx]\n                              (if ((comp not empty? (partial clojure.set/intersection xs) first) lx)\n                                [(conj a lx) b]\n                                [a (conj b lx)])) [[][]] ll)]\n         (if (empty? l) (conj ll [xs [x]])\n             (let [[k v] (first l)]\n               (-> nl\n                 (conj [(reduce conj k x)\n                        (conj v x)]))))))\n     [])\n    (map second)\n    (map (fn [[h & t]]\n           (loop [h h t t]\n             (if (empty? t) h\n                 (let [ft (first t)\n                       [x y] ft\n                       rt (rest t)]\n                   (cond (= y (first h)) (recur (into [x] h) rt)\n                         (= x (last h)) (recur (into h [y]) rt)\n                         :else (recur h (conj (vec rt) ft))))))))\n\n    (map (fn [xx]\n           (loop [a [] x (first xx) t (rest xx)]\n             (if (empty? t) a\n                 (recur (reduce #(conj %1 [x %2]) a t) (first t) (rest t))))))\n    (reduce into [])\n    set))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 84, "code": "(let [round (fn [pairs] (set (concat pairs (for [[x y] pairs [x' y'] pairs :when (= y x')] [x y']))))\n            fix (fn [f e] (loop [e e] (let [e' (f e)] (if (= e' e) e (recur e')))))]\n        (fn [pairs] (fix round (set pairs))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 84, "code": "#(% (% %2)) #(set (concat % (for [[a b] % [c d] % :when (= b c)] [a d])))", "user": "54969f9ee4b0b312c081ff67"}, {"problem": 84, "code": "(fn __ [someset]\n  (let[ clos\n  (reduce conj someset\n  (filter #(not (nil? (last %)))\n   (map #(vector (first %) (last(first (filter (fn[x](= (first x) (last %)))  someset)))) someset)))]\n   (\n  if(= clos someset) clos (__ clos))))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 84, "code": "(fn transitive\n  [x]\n  (letfn [(find-transwords [words lst]\n            (let [next-words (filter #(= (first %) (last (last words))) lst)]\n              (cond\n                (= 0 (count next-words)) words\n                :else (find-transwords (conj words (first next-words)) lst))\n              )\n            )]\n    (set (apply concat (map (fn [x]\n                              (map (fn [y] [(first (first x)) (last y)]) x))\n                            (map (fn [y] (find-transwords [y] x)) x))))\n    )\n  )", "user": "549c8bbde4b0f3d1d8e70f8c"}, {"problem": 84, "code": "(fn tc [abn]\n  (let [m (into {} abn)\n        at (fn [ma it] (loop [m ma i it t [i]] (if (m i) (recur (dissoc m i) (m i) (conj t (m i))) t)))\n        tc (fn tc [m] (mapcat #(map vector (repeat (key %)) (at m (val %))) m))\n        ]\n    (set (tc m))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 84, "code": "(fn [x]\n   (letfn [(trans [whole l acc]\n             (let [f (first l)]\n               (let [rels (reduce (fn [a c]\n                                    (if (= (first f) (last c))\n                                      (conj a [(first c) (last f)])\n                                      a))\n                                  [] whole)]\n                 (if (empty? l)\n                   acc\n                   (recur (concat rels whole) (concat rels (rest l)) (concat whole rels acc))))))]\n     (set (trans x x []))))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 84, "code": "(fn [s]\n  (loop [closure s]\n    (let [next (set (concat closure\n                (for [p1 closure\n                      p2 closure\n                      :when (= (second p1) (first p2))]\n                  [(first p1) (second p2)])))]\n      (if (= (count next) (count closure))\n          next\n          (recur next)))))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 84, "code": "(fn [rel*]\n  (loop [rel (reduce #(assoc-in %1 %2 true) {} rel*)]\n    (let [new-rel\n          (reduce-kv (fn [r l rs]\n                       (->> (keys rs) (map rel)\n                            (apply merge rs)\n                            (assoc r l)))\n                     {} rel)]\n      (if-not (= new-rel rel)\n        (recur new-rel)\n        (into #{} (mapcat (fn [[l rs]]\n                            (map vector\n                                 (repeat l)\n                                 (keys rs)))\n                          rel))))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 84, "code": "(letfn [\n        (transitive-closure-step[s]\n          (let [c (vec s)]\n            (loop [n 0 ret []]\n              (if (>= n (count c))\n                (into s ret)\n                (let [v (nth c n)]\n                  (recur (inc n) (concat ret (for [[a b] c :when(= (second v) a)] [(first v) b])))\n                )\n              )\n            )\n          )\n        )\n      ]\n        \n    (fn transitive-closure[s]\n      (let [l (count s) c (transitive-closure-step s)]\n        (if (= (count c) l)\n          c\n          (transitive-closure c)\n        )\n      )\n    )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 84, "code": "(fn t-closure [bin-rel]\n  \"Go through bin-rel vecs; if there are two vecs such that\n  the second elt of first vec matches first elt of second vec,\n  return vec that is first elt of first vec and second elt of second vec.\n  Do this for every vec in bin-rel, then do it again for every vec in the new relation.\n  Collect this in a lazy seq, then return the first consecutive relation thereof.\"\n  (let [get-relation (fn [[a b] bin-rel]\n                       (let [matches (for [i bin-rel\n                                           :when (= b (first i))]\n                                       [a (second i)])]\n                         (if-not (empty? matches)\n                           (first matches))))\n        first-consec (fn [coll]\n                       (if (= (first coll) (second coll))\n                         (first coll)\n                         (recur (rest coll))))]\n    (first-consec (iterate (fn [r]\n                             (into r (for [i r\n                                           :let [rel (get-relation i r)]\n                                           :when (not (empty? rel))]\n                                       rel))) bin-rel))))", "user": "542c026ae4b0dad94371f29a"}, {"problem": 84, "code": "(fn [s]\n   (letfn [(makeGraph [coll]\n             (reduce (fn [c v] (prn c v) (update-in c [(first v)] #((fnil conj []) % (second v)))) {} coll) )\n           (breadthFirst [graph, start] (loop [toVisit [start] visited #{start} ]\n                                          (if (empty? toVisit) (seq (disj visited start))\n                                              (recur\n                                               (filter #(not (contains? visited % )) (concat (rest toVisit) (graph (first toVisit))))\n                                               (conj visited (first toVisit))))\n                                          ))\n           (toPair [coll k] (map (fn [x] [k x]) coll))\n           ]\n     (let [g (makeGraph s)]    \n       (set (mapcat #(toPair (breadthFirst g %) %) (keys g))) \n       )\n     ))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 84, "code": "(fn tc [sq]\n  (#(if (= % sq) sq (tc %))\n    (set (for [[a b] sq [c d] sq] [a (if (= b c) d b)]))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 84, "code": "(fn [vs]\n (letfn [\n  (son? [p [s _]]\n   (= p s))\n  (sons [[_ s]]\n   (cons\n    s\n    (flatten\n     (map\n      sons\n      (filter\n       (partial son? s)\n       vs)))))\n  (r [[p _ :as v]]\n   (map\n    (partial vector p)\n    (sons v)))\n  ]\n (set\n  (apply\n   concat\n   (map\n    r\n    vs)))\n))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 84, "code": "(fn transitive [s]\n  (#(if (= % s) s (transitive %))\n   (set (for [[w x] s [y z] s]\n          [w (if (= x y) z x)]))))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 84, "code": "(fn tr-closure [items]\n    (let [m (into {} items)\n            findreachable\n            (fn [orig-i]\n                ((fn f [i]\n                     (if (or (nil? i) (= i orig-i))\n                         []\n                       (let [next-i (m i)]\n                         (conj (f next-i) i))))\n                 (m orig-i)))]\n      (set (mapcat #(map vector (repeat %1) (findreachable %1))\n                   (map first items)))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 84, "code": "(fn [s]\n    (loop [s s p s]\n      (if (seq p)\n        (let [q (map #(vector (first %) (second (first p))) (filter #(= (second %) (first (first p))) s))]\n          (if (seq q)\n            (recur (apply conj s q) (apply conj (rest p) q))\n            (recur s (rest p))\n            )\n          )\n        s\n        )\n      )\n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 84, "code": "(fn get-desc \n  ([relations] (->> relations\n                   (map first)\n                   (map #(get-desc relations %))\n                   (apply concat)\n                   (set)))\n  ([relations x] (->> relations\n                                (filter #(= x (first %)))\n                                (map last)\n                                (mapcat #(conj (get-desc relations %) [% %]))\n                                (map last)\n                                (map (partial vector x)))))", "user": "5493d908e4b0b312c081ff52"}, {"problem": 84, "code": "(fn [s]\n  (let [m (apply hash-map (flatten (seq s)))\n        f (fn [[v1 v2]] (loop [acc () v2 v2] (if-let [v3 (get m v2)] (recur (conj acc [v1 v3]) v3) acc)))]\n    (reduce #(into % (f %2)) s s)))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 84, "code": "(fn transitive-closure [R]\n  (let [xs (set (apply concat R))\n        mR (into {} R)]\n    (set (apply concat\n           (for [x xs]\n             (map vector (repeat x) (take-while (complement nil?) (iterate mR (mR x)))))))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 84, "code": "(fn [xs]\n   (let [trans (for [[a b] xs\n                     [c d] xs\n                     :when (= b c)]\n                 [a d])\n         new-xs (clojure.set/union xs (set trans))]\n     (if (= new-xs xs)\n       new-xs\n       (recur new-xs))))", "user": "4fec08e8e4b0681fd128dc9d"}, {"problem": 84, "code": "(fn transitive [s]\n  (let [expand (fn [s [a1 b1]] (reduce (fn [s [a2 b2]] (if (= b2 a1) (conj s [a2 b1]) s)) s s))\n        news (reduce #(expand %1 %2) s s)]\n    (if (identical? s news)\n        s\n        (recur news))))", "user": "54cc313de4b057c6fda3a28b"}, {"problem": 84, "code": "(fn [coll]\n  (loop [coll coll]\n    (let [new-coll (into coll\n                         (for [[a b] coll\n                               [c d] coll\n                               :when (= b c)]\n                           [a d]))]\n      (if (= coll new-coll)\n        coll\n        (recur new-coll)))))", "user": "54848141e4b0e286459a119e"}, {"problem": 84, "code": "(fn __ [r]\n  (nth (iterate (fn [xs]\n                  (reduce clojure.set/union xs\n                          (map (fn [x]\n                                 (set\n                                  (for [y (disj xs x) :when (= (second x) (first y))]\n                                    [(first x) (second y)])))\n                               xs)))\n                r)\n       (count r)))", "user": "54c271b9e4b045293a27f602"}, {"problem": 84, "code": "(fn [edges]\n  (letfn [(dfs [g v seen]\n            (reduce #(if (contains? % %2) %\n                         (apply conj % (dfs g %2 (conj % %2))))\n                    seen (g v)))\n          (graph [e]\n            (reduce (fn [val [k v]]\n                      (if (val k) (assoc val k (conj (val k) v))\n                          (assoc val k #{v}))) {} e))]\n    (let [g (graph edges)]\n      (into #{} (for [k (keys g) v (dfs g k #{})] [k v])))))", "user": "4f2d5f5de4b0d6649770a05a"}, {"problem": 84, "code": "(fn transistive-closure2 [ relation ]\n  (let [\n         expansion  (set (for [  [a b :as x] relation \n                                 [c d :as y] relation \n                                 :when (not= x y)\n                                 :when (= b c)\n                                 :let  [result [a d]]\n                                 :when (not (contains? relation result))        ] \n                           result))\n       ]\n   (if (empty? expansion)\n       relation\n       (transistive-closure2 (clojure.set/union relation expansion)))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 84, "code": "(fn tc\n    ([lst]\n     (tc (apply merge {} (map #(let [[f t] %] {f t}) lst)) lst))\n    ([look-up items]\n     (reduce into (for [[from to] items]\n        (loop [link to\n               coll #{[from to]}]\n          (if (contains? look-up link)\n            (recur (look-up link) (conj coll [from (look-up link)]))\n            coll))))))", "user": "53f31dafe4b0742d9025b0f0"}, {"problem": 84, "code": "(fn [start-set]\n  (letfn [(cart [colls]  (if (empty? colls)\n                           '(())\n                           (for [x (first colls)\n                                 more (cart (rest colls))]\n                             (cons x more))))\n          (my-comp [relas three] \n                   (if (and (contains? relas [(first three) (second three)])\n                            (contains? relas [(second three) (last three)]))\n                     (conj relas [(first three) (last three)]) \n                     relas\n                     ))\n          ]\n    (let [eles (distinct (apply clojure.set/union start-set))\n          n (count eles)\n          three-cart (cart [(range n) (range n) (range n)]) \n          three-way (filter #(= 3 (count (distinct %))) three-cart)\n          three-way-eles (map #(map (partial nth eles) %) three-way)\n          ]\n  \t(reduce my-comp (cons start-set three-way-eles))\n  )))", "user": "52faec2ee4b047fd55837004"}, {"problem": 84, "code": "(fn [xxs]\n  (letfn [(paths [pps gs]\n                 (if (empty? gs)\n                   #{#{}}\n                   (for [g gs \n                         ps (paths pps (disj gs g))]\n                     (cons g ps))))\n          (get-chain [[a b & more :as xs]]\n                     (cond\n                       (nil? b) [a]\n                       (nil? a) nil\n                       (= (second a) (first b)) (cons a (get-chain (rest xs)))\n                       :else [a]))\n          (tc [pps]\n              (map (fn [ps]\n                     (get-chain ps))\n                   pps))]\n    (into #{}\n          (mapcat (fn [xs] \n                    (map (fn [p] [(first (first xs)) (second p)]) xs))  \n                  (tc (paths #{[]} xxs))))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 84, "code": "(fn trans-closure [sset]\n  (let [combina  (fn combination [col] \n                   (reduce concat \n                     (let [ctall (count col)] \n                       (for [i (range 0 (dec ctall))]\n                         (for [j (range (inc i) ctall)] \n                           [(nth col i) (nth col j)])))))\n        s2v      (fn [sc] (for [i sc] i))\n        combdata (combina (s2v sset))\n        trans    (fn [col1 col2] \n                    (cond\n                      (= (first  col1) (second col2)) [(first  col2) (second col1)] \n                      (= (second col1) (first  col2)) [(first  col1) (second col2)] \n                      :else nil))\n     combdata2 (combina (s2v (clojure.set/union sset (set (filter #(not= nil %) (map #(trans (first %) (second %)) combdata))))))]\n     (clojure.set/union sset (set (filter #(not= nil %) (map #(trans (first %) (second %)) combdata2))))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 84, "code": "(fn [relations]\n  (let [p\n        (fn p [itm relations]\n          (let [visits (map second (filter (fn [v] (= (first v) itm)) relations))]\n            (if (empty? visits)\n              '()\n              (flatten (concat visits\n                               (map #(p % relations) visits))))))]\n    (apply hash-set (apply concat (map (fn [x] (map (fn [y] [(first x) y]) (p (first x) relations))) relations)))))", "user": "53664e3be4b0243289761e74"}, {"problem": 84, "code": "(fn prob84 [r]\n  (letfn\n      [(all-pairs [s]\n         (if (< (count s) 2) ()\n             (concat\n              (map #(vector (first s) %) (rest s))\n              (all-pairs (rest s)))))]\n    (let [tchain\n          (reduce\n           (fn [s pair]\n             (if-let [l1 (first (filter #(= (last %) (first pair)) s))]\n               (conj (disj s l1) (concat l1 (list (second pair))))\n               (if-let [l2 (first (filter #(= (first %) (second pair)) s))]\n                 (conj (disj s l2) (concat (list (first pair)) l2))\n                 (conj s pair))))\n           #{} r)]\n      (set (apply concat (map all-pairs tchain))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 84, "code": "(fn tc [sv & [sv2]]\n  (let [v (vec sv)\n        p (first sv)\n        r (rest sv)\n        sv2 (or sv2 [] )]\n    (if (empty? r)\n      (set (conj sv2 p))\n      (let [r2 (vec (for [p2 r\n                     :let [p3 (cond\n                                (= (first p2)(last p))(vector (first p)(last p2))\n                                (= (first p) (last p2))(vector (first p2)(last p))\n                                :else false)]\n                     :when p3]\n                 p3))]\n        (tc (concat r r2)(conj sv2 p))))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 84, "code": "(fn [s]\n  (let [add-ent (fn add-ent [parent child setdict]\n                  (if (nil? child) #{}\n                      (clojure.set/union (into #{} setdict) #{[parent child]} (add-ent parent (get setdict child) setdict))))\n        make-dict (fn make-dict [s]\n                    (if (empty? s) {}\n                        (let [[k v] (first s)]\n                          (apply merge {k v} (make-dict (rest s))))))\n        sdict (make-dict s)]\n        (apply clojure.set/union (map #(add-ent % (get sdict %) sdict) (keys sdict)))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 84, "code": "(fn [given-set]\n  (let [extended\n    (into given-set (mapcat (fn [g] \n      (map #(vector (first g) (last %))\n        (filter #(= (last g) (first %)) given-set)))\n    given-set))]\n    (if (= given-set extended) given-set\n      (recur extended))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 84, "code": "(fn [x]\n  (letfn [(orderlist ([s]\n                      (let [f (findfirst s)]\n                        (orderlist f (disj s f))))\n                     ([ordered unordered]\n                      (if (empty? unordered)\n                        ordered\n                        (let [y (last ordered)\n                              nextitem (some (fn [[xx yy]] (if (= y xx) [xx yy])) unordered)]\n                          ;;(println \"x: \" x \"\\ny: \" y \"\\nnextitem: \" nextitem \"\\nord: \" ordered \"\\nunord: \" unordered)\n                          (orderlist (conj ordered (nextitem 1)) (disj unordered nextitem))))))\n          (findfirst [s] \n                     (first \n                      (filter \n                       (fn [[x y]]\n                         (= 0 (count (filter \n                                      (fn [[xx yy]]\n                                        (= yy x))\n                                      s))))\n                       s)))\n          (all-relatives ([s]\n                          (let [i (first s)\n                                snew (disj s i)\n                                relation (all-relatives i snew)\n                                otherrelations (clojure.set/difference snew relation)]\n                            (if (empty? otherrelations)\n                              [relation]\n                              (concat [relation] (all-relatives otherrelations)))))\n                         ([i s]\n                          (reduce\n                           (fn [s [x y]]\n                             (let [firsts (set (map first s))\n                                   seconds (set (map second s))\n                                   intrsecty (contains? firsts y)\n                                   intrsectx (contains? seconds x)]\n                               (if (or intrsecty intrsectx)\n                                 (conj s [x y])\n                                 s)))\n                           #{i}\n                           s)))\n          ;; tc: transitive closure\n          ;; v: ordered vector of relations: grandfather -> father -> son\n          (tc ([v]\n               (if (>= 1 (count v))\n                  #{}\n                  (set (tc v []))))\n               ([[f n & r] s] \n                ;; s: vector of all binary relations\n                (if (nil? r)\n                  (conj s [f n])\n                  (concat (tc (concat [n] r) (conj s [f n]))\n                          (tc (concat [f] r) [])))))]\n  (let [vs (reduce \n           (fn [x y]\n             (conj x (orderlist y)))\n           []\n           (all-relatives x))]\n    (reduce \n     (fn [x y]\n       (into x (tc y)))\n     #{}\n     vs))))", "user": "54d9366ce4b0a52adc2e204e"}, {"problem": 84, "code": "(letfn [(chains [pairs]\n                (loop [chains []\n                       [pair & pairs :as all] (vec pairs)]\n                  (if (empty? all)\n                    chains\n                    (recur (if (some (fn [chain]\n                                       (or (= (last chain) (first pair)) \n                                           (= (first chain) (last pair))))\n                                     chains)\n                             (map (fn [chain]\n                                    (cond\n                                     (= (last chain) (first pair)) (conj chain (last pair))\n                                     (= (first chain) (last pair)) (cons (first pair) chain)\n                                     :else chain))\n                                  chains)\n                             (conj chains pair))\n                           pairs))))]\n  ;;chains)\n  (fn [s]\n    (set (for [chain (chains s)\n               i (range (dec (count chain)))\n               j (range (inc i) (count chain))]\n           [(nth chain i) (nth chain j)]\n           ))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 84, "code": "(fn f [s]\n  (let [m (into {} s)]\n    (letfn [(r [n] (loop [x n coll []] (if-let [y (m x)]\n                                         (recur y (conj coll [n y])) coll)))]\n      (set (mapcat r (map first m))))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 84, "code": "(fn [x]\n    (reduce (fn [y z]\n              (->> (map #(cond\n                           (= (first z) (second %)) [(first %) (second z)]\n                           (= (first %) (second z)) [(first z) (second %)]\n                           :else %) y)\n                   (into y))) x x))", "user": "5470b3d0e4b00cfc9eacc1bb"}, {"problem": 84, "code": "(fn [args]\n   (let [r (vec args)]\n     (loop [indx (count args) indx2 (count args) set (vec r) secondSet (vec r) key (ffirst r) value (second (first r)) res #{[key value]}]\n       (if (< indx 1)\n         res\n         (if (< indx2 1)\n           (if (< indx 2)\n             (recur (dec indx) (count args) (vec (conj (vec (rest set)) (first set)))\n                    (vec (conj (vec (rest set)) (first set))) (ffirst (rest set))\n                    (second (first (rest set))) res)\n             (recur (dec indx) (count args) (vec (conj (vec (rest set)) (first set)))\n                    (vec (conj (vec (rest set)) (first set))) (ffirst (rest set))\n                    (second (first (rest set))) (conj res [(ffirst (rest set)) (second (first (rest set)))])))\n           \n           (if (= (ffirst secondSet) value)\n             (recur indx (count args) set (vec (conj (vec (rest secondSet)) (first secondSet))) key (second (first secondSet)) (conj res [key (second (first secondSet))]))\n             (recur indx (dec indx2) set (vec (conj (vec (rest secondSet)) (first secondSet))) key value res))))))\n   )", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 84, "code": "(fn transitive [relations]\n               (let [to-add (filter identity (for [[i j] relations\n                                                   [k l] relations :when (= j k)]\n                                               [i l]))\n                     rslt (clojure.set/union relations (set to-add))]\n                 (if (= rslt relations)\n                   rslt\n                   (recur rslt))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 84, "code": "(fn [s]\n   (set (concat\n (reduce (fn [pre cur] \n             (if (empty? pre) \n              (hash-set cur) \n              (conj (mapcat #(cond \n                           (=(last %) (first cur))  (list % (vector (first %) (last cur)))\n                           (=(first %) (last cur))  (list % (vector (first cur) (last %) ))\n                          :else  (list %))  \n                        pre) cur)) ) #{} s) s)\n    ) )", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 84, "code": "(letfn [(get-new-right-trans [rel add]\n                             (for [r rel :when (= (second r) (first add))\n                                         :let [newr [(first r) (second add)]]\n                                         :when (not (rel newr))]\n                               newr))\n        (get-new-left-trans [rel add]\n                            (for [r rel :when (= (second add) (first r))\n                                        :let [newr [(first add) (second r)]]\n                                        :when (not (rel newr))]\n                              newr))\n        (get-new-trans [rel add] (into #{} (concat (get-new-right-trans rel add)\n                                                   (get-new-left-trans rel add))))\n        (add-one [rel tr]\n                 (if (rel tr)\n                   rel\n                   (conj (add-all rel (get-new-trans rel tr)) tr)))\n        (add-all [rel trs]\n                 (reduce add-one rel trs))]\n  #(add-all #{} %))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 84, "code": "(fn [pairs]\n  (loop [ret pairs]\n    (let [graph (into {} ret)\n          ret* (letfn [\n                 (twice [f] #(f (f %)))\n                 (infer [k] ((twice graph) k))\n                 (redf [rels k]\n                    (if-let [inference (infer k)]\n                      (conj rels [k inference])\n                      rels))]\n             (reduce redf ret (keys graph)))]\n      (if (= ret ret*)\n        ret\n        (recur ret*)))))", "user": "5519a6dde4b00ace28fe6e2f"}, {"problem": 84, "code": "(fn trans-closure [rel]\n  {:pre [(set? rel),\n         (every? (comp (partial = 2) count) rel)]}\n\n  ;; We find the first level of additions which are demanded by\n  ;; transitivity. That is, if rel contains [x y] and [y z], then additions\n  ;; will contain [x z].\n  (let [additions\n        (->> (for [[x y] rel]\n               (->> rel\n                    (filter (comp (partial = y) first))\n                    (map #(assoc % 0 x))))\n             (apply concat)\n             set)]\n\n    ;; If everything we found was already in rel, then we're done;\n    ;; otherwise, recur.\n    (if (seq (clojure.set/difference additions rel))\n      (recur (clojure.set/union rel additions))\n      rel)))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 84, "code": "(fn [relation]\n  (letfn [(expand [r]\n                  (let [m (into {} r)]\n                    (->> (concat r (for [[k v] m] (when-let [nv (m v)] [k nv])))\n                         (filter identity)\n                         set)))\n          (first-consecutive [pred [f & rs]]\n                             (when rs\n                               (if (pred f (first rs)) f (recur pred rs))))]\n    (first-consecutive = (iterate expand relation)))\n)", "user": "54e5bdf2e4b024c67c0cf7fe"}, {"problem": 84, "code": "(fn [s]\n  (let [m (into {} s)\n        f (fn f [[a b :as c]]\n            (when b\n              (cons c (f [a (m b)]))))]\n    (reduce #(into %1 (f %2)) #{} s)))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 84, "code": "(fn [a] (letfn\n          [(oot [[a b] [c d]] (if (= b c) [[a b] [c d] [a d]] [[a b] [c d]]))\n           (oo2 [e f] (concat (oot e f) (oot f e)))\n           (oon [g] (into #{} (apply concat (for [x g y g] (oo2 x y)))))\n           (tc [i] (let [h (oon i)] (if (> (count h) (count i)) (tc h) i)))\n           ]\n          (tc a)))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 84, "code": "(fn f [s]\n  (#(if (= % s) s (f %))\n   (set (for [[a b] s [c d] s]\n          [a (if (= b c) d b)]))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 84, "code": "(let [close (fn [a]\n                (set\n                  (reduce concat\n                    (for [b a]\n                      (cons b\n                        (for [c a :when (= (second b) (first c))] [(first b) (second c)])\n                      )\n                    )\n                  )\n                )\n              )]\n    (fn [x]\n      (loop [old x]\n        (let [new1 (close old)] (if (= old new1) old (recur new1)))\n      )\n    )\n  )", "user": "55280930e4b0ffed3738f93b"}, {"problem": 84, "code": "#(let [m (into {} %)]\n   (set\n    (mapcat\n     (fn [[x _]]\n       (loop [k x r []]\n         (if-let [v (m k)]\n           (recur v (conj r [x v]))\n           r)))\n     m)))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 84, "code": "(fn __ [s]\n  (let [augment (fn [coll [a b]]\n                  (let [firsts (map first coll)\n                        seconds (map second coll)\n                        ia (.indexOf firsts b)]\n                    (if (= -1 ia)\n                      nil\n                      [a (nth seconds ia)])))\n        nexts (filter (complement nil?) (map (partial augment s) s))\n        s-plus (clojure.set/union s nexts)]\n    (if (= s s-plus)\n      s\n      (__ s-plus))))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 84, "code": "(fn transitive-closure [pairs]\n    (let [more-pairs (set (for [[fl sl :as left] pairs\n                                [fr sr :as right] pairs ; cross join\n                                :when (and (not= left right)\n                                           (not (contains? pairs [fl sr]))\n                                           (= sl fr))]\n                            [fl sr]))]\n      (if (empty? more-pairs)\n        pairs\n        (transitive-closure (clojure.set/union pairs more-pairs)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 84, "code": "(fn [rels]\n  (letfn [(closure [stack agg]\n  (if (empty? stack) agg\n  (let [\n    curr (first stack)\n    a (first curr)\n    b (second curr)\n    cont (rest stack)\n    initrans (filter #(= b (first %)) agg)\n    filled (closure initrans agg)\n    fulltrans (filter #(= b (first %)) filled)]\n    (closure cont (set (concat filled (for [rel fulltrans] [a (second rel)]))))\n  )))]\n  (closure (vec rels) rels)\n  )\n)", "user": "5519c157e4b00ace28fe6e32"}, {"problem": 84, "code": "(fn ttc [trs] (letfn [ ( tc [s] (into s  (disj (set  \n  (for  [[a b] s]  \n    (if-let  [c  \n              (first \n                (filter #(= b  (first %)) s))]  \n      (vector a  (second c))))) nil)))]\n            (tc (tc trs))))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 84, "code": "(fn trclx [ps]\n  (let [mp (into {} ps)]\n    (into #{}\n          (apply concat\n           (for [k (keys mp)]\n             (for [x (drop 1 (take-while boolean (iterate mp k)))]\n               (vector k x)))))))", "user": "54b04708e4b09f271ff37d11"}, {"problem": 84, "code": "(fn [relations]\n  (letfn [(to-map [rels]\n            (apply merge-with concat (map (fn [[l r]] {l [r]}) rels)))\n          (new-rels-from [map]\n            (for [[src dsts] map\n                  dst dsts\n                  :when (contains? map dst)\n                  :let [new-dsts (get map dst)]\n                  new-dst new-dsts]\n              [src new-dst]))\n          (produce-from [rels]\n            (let [new-rels (new-rels-from (to-map rels))\n                  all-rels (set (concat rels new-rels))]\n              (if (= rels all-rels)\n                all-rels\n                (produce-from all-rels))))]\n    (produce-from relations)))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 84, "code": "(fn [rs]\n  (let [x (apply hash-map (flatten (vec rs)))\n        x' (fn [[a b]] (if-let [b' (x b)] [a b']))]\n    (loop [rs rs]\n      (let [rs' (into rs (keep x' rs))]\n        (if (= rs rs') rs\n          (recur rs'))))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 84, "code": "#(reduce\n   (fn [s [l r]]\n     (into s (concat\n               (for [[l' r'] s :when (= r' l)] [l' r])\n               (for [[l' r'] s :when (= l' r)] [l r'])))) % %)", "user": "55274467e4b0ffed3738f92b"}, {"problem": 84, "code": "(fn [s]\n  (let [m (apply conj {} s)]\n    (reduce\n      (fn [r [k v]]\n        (if (not (contains? m v))\n          r\n          (let [nkv [k (get m v)]]\n           (recur (conj r nkv) nkv))))\n      s m)))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 84, "code": "(fn [xs]\n  (let [mp (into {} xs)]\n    (reduce (fn [rs [p q]]\n              (let [path (loop [k q pt #{[p q]}]\n                           (if (not (contains? mp k))\n                             pt\n                             (recur (mp k) (conj pt [p (mp k)])))\n                           )]\n                (clojure.set/union rs path))) #{} xs)))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 84, "code": "(letfn [(transitive-closure [set-of-pairs]\n          (let [relation (reduce (fn [acc [key val]]\n                                   (assoc acc key (conj (get acc key #{}) val)))\n                                 {} set-of-pairs)]\n            (close-relation relation)))\n        (close-relation [relation]\n          (let [augmented-relation (augment-relation relation)]\n            (if (= relation augmented-relation)\n              relation\n              (recur augmented-relation))))\n        (augment-relation [relation]\n          (reduce (fn [augmented-relation key]\n                    (assoc augmented-relation key\n                           (apply clojure.set/union (get relation key)\n                                  (map relation (get relation key)))))\n                  {}\n                  (keys relation)))]\n  (fn [relation] \n    (let [closure (transitive-closure relation)]\n      (reduce (fn [acc elt] \n                (apply conj acc (map #(identity [elt %])\n                                     (get closure elt))))              \n              #{}\n              (keys closure)))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 84, "code": "(fn p84 [b]\n  (->> (merge-with concat (group-by first b) (group-by last b))\n       (filter #(< 1 (count (val %))))\n       vals\n       (map (fn [s] (vector (first (last s)) (last (first s)))))\n       set\n       (clojure.set/union b)       \n       (clojure.set/union (if (contains? b [\"cat\" \"man\"]) \n                            #{[\"spider\" \"snake\"]} \n                            #{}))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 84, "code": "(fn [coll]\n  (let [get-transatives (fn get-transatives [root search-elements]\n                          (let [found (filter #(= (root 1) (% 0)) search-elements)]\n                            (if (empty? found) (list root)\n                               (cons root (for [f found t (get-transatives f (remove #(= f %) search-elements))] t)))))]\n    (set (for [e coll m (map #(assoc % 0 (e 0)) (get-transatives e (remove #(= e %) coll)))] m))))", "user": "5546704be4b0a04f7929953d"}, {"problem": 84, "code": "(fn closure [coll]\n  (let [v1->v2 (into {} coll)\n        a-closure (fn [[k v]]\n                    (loop [res [[k v]]\n                           v v]\n                      (let [nx (v1->v2 v)]\n                        (if (nil? nx)\n                          res\n                          (recur (conj res [k nx]) nx)))))]\n    (set (mapcat a-closure coll))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 84, "code": "(fn transitive\n  [b-rules]\n  (let [rules (apply hash-map (apply concat b-rules))]\n    (reduce\n      (fn [acc [k v]]\n        (loop [acc acc k k v v]\n          (if-not v acc (recur (conj acc [k v]) k (get rules v)))))\n      #{}\n      rules)))", "user": "5383668ee4b06839e8705edd"}, {"problem": 84, "code": "(fn [rels]\r\n  (let [\r\n      rules (into {} (seq rels))\r\n      generate (fn [[k v]]\r\n        (loop [x k, result [], done []]\r\n          (let [y (rules x), new-done (conj done x)]\r\n            (if (nil? y)\r\n              result\r\n              (recur y\r\n                (concat result (map (fn [z] [z y]) new-done))\r\n                new-done)))))]\r\n    (set (apply concat (map generate rels)))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 84, "code": "(fn [rs]\n  (loop [cur rs]\n    (let [nxt (into cur (for [[u v] cur [w x] cur :when (= v w)] [u x]))]\n      (if (> (count nxt) (count cur)) (recur nxt) nxt))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 84, "code": "(fn __ [input-set]\n  (let [rels (->> input-set\n                  (apply list)\n                  flatten\n                  (apply hash-map))\n        nodes (->> input-set\n                   (apply list)\n                   flatten\n                   set)\n        aux (fn aux [x]\n              (let [x' (rels x)]\n                (if (nil? x') []\n                              (let [aux-res (aux x')\n                                    xtra-res (map (fn [[_ y]] [x y]) aux-res)]\n                                (cons [x x'] (concat aux-res xtra-res))))))]\n    (set (mapcat aux nodes))))", "user": "536d83cee4b0fc7073fd6e5e"}, {"problem": 84, "code": ";this is a classical set problem which is useful for many graph problems\n#(letfn [(extendRules [ruleSet] ;extend the transitive rules\n                      (for[[a b] ruleSet [c d] ruleSet :when (and (= b c) (not= a c))];transitive extension\n                               [a d]))];new rules\n  (loop [result %]\n    (let [extendedResult (into result (extendRules result))];the new rule set consists of the inferred rules and the old ones\n      (if (= extendedResult result) result ;if no new rules are found then return\n        (recur extendedResult)))));else continue extending the rule set", "user": "556c70dae4b09a3098a524fd"}, {"problem": 84, "code": "#(loop [c (vec %) [[x y] & b] c]\n        (if (nil? x) (set c)\n            (recur (concat c \n                           (for [[u v] c :when (= v x)] [u y])\n                              ) b)))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 84, "code": "(fn make-transitive-via\n  ([s] (make-transitive-via s (into {} s)))\n  ([s rel]\n   (clojure.set/union\n     s\n     (let [derived-vals (->> s\n                             (filter #(contains? rel (second %)))\n                             (map (juxt first (comp rel second))))]\n       (when (seq derived-vals)\n         (make-transitive-via (set derived-vals) rel))))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 84, "code": "(fn [s]\n    (reduce (fn [s [h t :as e]]\n              (let [before (map (fn [[x y]] [h y]) (filter #(= t (first %)) s))\n                    after (map (fn [[x y]] [x t]) (filter #(= h (second %)) s))]\n                (into (into (conj s e) before) after))) #{} s))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 84, "code": "(fn [links] \n  (letfn [(create-ordering [res row] \n  (if (empty? row) res\n    (recur \n           (into res (vec (for [l (rest row)] [(first row) l])))\n      (rest row) \n      )))\n          (add-link [mem [a b :as link]] \n  (let [new-mem (for [m mem] \n           (if (= a (last m)) (conj m b) \n                (if (= b (first m)) (cons a m) \n                 m)))]\n    (if (= mem new-mem) \n      (conj mem link)\n      new-mem)))\n\n]\n  (reduce create-ordering #{}  (reduce add-link [] links))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 84, "code": "(fn solution\n  [links]\n  \"Generates the transitive closure of a binary relation.\n   The relation will be represented as a set of 2 item vectors\"\n  (let [prepend   (fn [coll x] (into [x] coll))\n        append    (fn [coll x] (conj coll x))\n        pairs-helper (fn pairs-helper [acc x coll]\n                       (if (or (nil? x)\n                               (empty? coll))\n                           acc\n                           (pairs-helper (concat acc (for [y coll] [x y]))\n                                         (first coll)\n                                         (rest coll))))\n        pairs     (fn pairs [coll]\n                    (pairs-helper [] (first coll) (rest coll)))\n        addlink   (fn [chains link]\n                   \"Takes a link and adds it to one of the chains.\n                    Starts a new chain if appropriate chain not found\"\n                   (let [[from to]  link\n                         match  (count (filter #(or (= from (last %))\n                                                    (= to (first %))) chains))\n                         rc     (if (zero? match)\n                                  (conj chains link)\n                                  (map (fn [coll]\n                                    (cond (= from (last coll)) (append coll to)\n                                          (= to   (first coll)) (prepend coll from)\n                                          :else coll)) chains))]\n                    rc))\n        rc1       (reduce addlink [] links)\n        rc2       (set (reduce concat [] (map pairs rc1)))]\n    rc2))", "user": "4dc97aec535d5973398f9284"}, {"problem": 84, "code": "(fn [e]\n  (letfn [(dag [edges]\n            (->> edges\n                 (map (fn [[f s]] {f #{s}}))\n                 (apply merge-with clojure.set/union)))\n          \n          (reachable-nodes [dag from-node]\n            (let [connected-nodes (get dag from-node)\n                  next-nodes      (set (mapcat #(reachable-nodes dag %)\n                                               connected-nodes))]\n              (clojure.set/union connected-nodes next-nodes)))\n          (transitive-closure-dag [dag]\n            (reduce (fn [dag node]\n                      (assoc dag node (reachable-nodes dag node)))\n                    dag\n                    (keys dag)))\n          (edges [dag]\n            (set (mapcat (fn [[node connected-nodes]]\n                           (map #(vector node %) connected-nodes))\n                         dag)))]\n    (->> e\n         dag\n         transitive-closure-dag\n         edges)))", "user": "55586905e4b0deb715856e2b"}, {"problem": 84, "code": "(fn [s]\n  (let [graph (apply merge-with into (for [[k v] s] {k [v]}))\n        tree (fn f [root visited]\n               (concat\n                (graph root)\n                (mapcat #(f % (conj visited %))\n                        (remove visited (graph root)))))]\n    (set (mapcat\n          (fn [node] (map #(vector node %) (tree node #{})))\n          (keys graph)))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 84, "code": "(fn [s]\n  (set\n   (reduce \n    (fn [s [a b]]\n      (concat s (keep (fn [[c d]] (if (= b c) [a d])) s)))\n    s s)))", "user": "53065acbe4b02e8216869792"}, {"problem": 84, "code": "(fn [pairs]\n  (let [a->b      (into {} pairs)\n        as        (keys a->b)\n        add-pairs (fn [pairs a]\n                    (loop [pairs pairs b a]\n                      (if-let [b (a->b b)]\n                        (recur (conj pairs [a b]) b)\n                        pairs)))]\n  (reduce add-pairs pairs as)))", "user": "548c6673e4b0e286459a1209"}, {"problem": 84, "code": "(fn tc [s] (let [new-set (set (for [x s y s :when (and (not= x y) (or (= (x 0) (y 1)) (= (y 1) (x 0))) )] (if (= (x 0) (y 1)) [(y 0) (x 1)] [(x 0) (y 1)])))] (if (empty? (clojure.set/difference new-set s)) s (tc (into s new-set)))))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 84, "code": "(fn [br]\n  (letfn [(nums [s] (set (apply concat br)))\n          (others [x] (map second (filter #(= x (first %)) br)))\n          (build_for [x]\n            (let [trans_cl (loop [othrs (others x)\n                                  res []]\n                             (if (empty? othrs)\n                               res\n                               (recur (set (apply concat (map others othrs))) (set (concat res othrs)))))]\n              (map #(vector x %) trans_cl)))]\n    (set (apply concat (map build_for (nums br))))))", "user": "5550bcece4b00713264bd9ae"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(find-clos\n           [v s]\n           (remove nil?\n                   (map (fn [x]\n                          (when (= (last v) (first x))\n                            [(first v) (last x)]))\n                        s)))]\n    (set\n     (reduce (fn [acc v]\n               (let [no-v (disj acc v)\n                     r (find-clos v no-v)]\n                 (apply conj acc v r)))\n             s\n             s))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 84, "code": "(letfn [                                                                                                                                                \n    (get-nodes [edges] (-> edges vec flatten set (zipmap (range))))                                                             \n    (square-matrix [size] (map (fn [_] (repeat size 99)) (range size)))                                                                                 \n    (set-ij [m i j v]                                                                                                           \n        (let [row (nth m j)                                                                                                                             \n              row- (concat (take i row) [v]  (nthnext row (inc i)))]                                                            \n            (concat (take j m) [row-] (nthnext m (inc j)))))                                                                                            \n    (get-ij [m i j] (-> m (nth j) (nth i)))                                                                                     \n    (transitive-closure [edges] (let [                                                                                                                  \n        nodes (get-nodes edges)                                                                                                 \n        node-count (count nodes)                                                                                                                        \n        graph (-> (square-matrix node-count)                                                                                    \n                  (#(reduce (fn [m [a b]] (set-ij m (nodes a) (nodes b) 1)) % edges))                                                                   \n                  (#(reduce (fn [m i] (set-ij m i i 0)) % (range node-count))))                                                 \n        distance (reduce                                                                                                                                \n                      (fn [m [i j k]] ; this is the floyd-warshall algorithm                                                    \n                          (let [ij (get-ij m i j) ik (get-ij m i k) kj (get-ij m k j)]                                                                  \n                              (if (< (+ ik kj) ij)                                                                              \n                                  (set-ij m i j (+ ik kj))                                                                                              \n                                  m)))                                                                                          \n                      graph                                                                                                                             \n                      (for [k (range node-count) i (range node-count) j (range node-count)] [i j k]))                           \n        lookup (zipmap (vals nodes) (keys nodes))                                                                                                       \n        tc-set (->> (for [i (range node-count) j (range node-count)] [i j])                                                     \n                    (filter (fn [[i j]] (let [v (get-ij distance i j)] (and (> v 0) (< v 99)))))                                                        \n                    (map (fn [[i j]] [(lookup i) (lookup j)]))                                                                  \n                    (set))]                                                                                                                             \n            tc-set))]                                                                                                           \n    transitive-closure)", "user": "558b50d5e4b027778923762b"}, {"problem": 84, "code": "(fn trans-close [raw-pairs]\n    (let [mapping (into {} raw-pairs)\n          branch? #(mapping (last %))\n          children (fn [[f l]] (list [f (mapping l)]))]\n      (into #{} (filter #((complement =) (first %) (last %) ) (apply concat (map #(tree-seq branch? children [% %]) (keys mapping)))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 84, "code": "(fn transitive-closure [rels]\n  (let [rem-node (fn rem-node [rels node]\n                    [(clojure.set/select #(= (first %) node) rels)\n                     (clojure.set/select #(not= (first %) node) rels)])\n        follow-node (fn follow-node \n                      ([rels node] (follow-node rels node node))\n                      ([rels curnode orignode]\n                       (let [[startwith notstartwith] (rem-node rels curnode)]\n                         (if (empty? startwith) rels\n                           (apply clojure.set/union \n                                  (concat [startwith\n                                           (map #(assoc % 0 orignode) startwith)\n                                           notstartwith]\n                                          (map #(follow-node rels (last %) orignode) startwith)))))))\n        find-zero-nodes (fn find-zero-nodes [rels]\n                          (clojure.set/difference (set (mapcat identity rels))\n                                      (set (keys (group-by last rels))))) ; nodes with inbound\n        zero-nodes (find-zero-nodes rels)]\n    (->> zero-nodes \n         (map (fn [zero-node]\n                (let [[startwith notstartwith] (rem-node rels zero-node)]\n                  (if (empty? startwith)\n                    notstartwith\n                    (clojure.set/union\n                     (follow-node rels zero-node)\n                     (transitive-closure notstartwith))))))\n         (apply clojure.set/union))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 84, "code": "(fn transitive [closure]\n  (let [new-relations (for [x closure\n                            y closure\n                            :when (= (last x) (first y))]\n                        [(first x) (last y)])\n        new-closure (into closure new-relations)]\n    (if (= closure new-closure)\n      closure\n      (transitive new-closure))))", "user": "52bdd135e4b07a9af579230a"}, {"problem": 84, "code": "(fn c [R]\n   (if (empty? R) #{}\n     (let [u (fn [[a b] [c d]] (if (= b c) [[a d]] []))\n           z (last R)\n           r (c (disj R z))\n          ]\n       (into #{}\n         (concat \n           [z]\n           (mapcat #(u z %) r)\n           (mapcat #(u % z) r)\n           r)))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 84, "code": "#((fn transitive-closure\n    [s c]\n    (letfn [(transitive-closure*\n              [[a b]]\n              (for [[x y] s :when (= b x)] [a y]))]\n      (if-let [closures (seq (mapcat (fn [x] (transitive-closure* x)) c))]\n        (recur (into s closures) closures)\n        s))) % %)", "user": "506f0968e4b09350ab4199f5"}, {"problem": 84, "code": "(fn transitive-closure\n  [coll]\n  (let [keys (map first coll) map-set (into {} coll)\n        next-set (reduce (fn [m [x y]] (if (map-set y) (conj m [x (map-set y)]) m)) coll coll)]\n    (if (= next-set coll) coll (transitive-closure next-set))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 84, "code": "(fn [relation]\n  (let [m (into {} relation)\n        transitive-mappings (fn [k]\n                              (take-while second (iterate (fn [[_ next-k]]\n                                                            [k (m next-k)])\n                                                          [k (m k)])))]\n    (apply conj relation (mapcat transitive-mappings (keys m)))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 84, "code": "(fn f [s]\n  (let [n (set (concat s (mapcat (fn [[a b]] (keep (fn [[c d]] (if (= b c) [a d])) s)) s)))]\n    (if (= s n) \n      n\n      (f n))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 84, "code": "(fn self [xs]\n    (letfn [(dfs [[k1 v1] xs]\n              (mapcat\n                (fn [[k2 v2]]\n                  (if (= v1 k2)\n                    (concat [[k1 v2]] (dfs [k1 v2] xs))))\n                xs))]\n      (into xs (mapcat (fn [kv] (dfs kv xs)) xs))))", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": 84, "code": "(fn ab [st] \n     (let [nst (set (filter vector? \n              (loop [c st [f & r :as s] (vec st)] \n                (if (empty? r) \n                  c \n                  (recur \n                   (into c (map #(let [[a b] % [c d] f] \n                                   (if (= a d) [c b] \n                                     (if (= b c) [a d]))) \n                                r)) \n                   r)))))](if (= st nst) st (ab nst))))", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 84, "code": "(fn tc [items]\n  (let [next (clojure.set/union items (set (for [x items y items :when (= (last x) (first y))] [(first x) (last y)])))]\n    (if (= items next)\n      items\n      (tc next)\n      )))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 84, "code": "(fn me [arg]\n\n  (let [ my-map (apply merge (map #(apply hash-map %) arg))\n\n         new-items     (for [x my-map] \n                          (if (nil? (my-map (val x)))\n                                nil\n                            (map vector (repeat (key x)) \n\n                                (take-while #(not= nil %) (iterate #(my-map %) (my-map (val x))))\n                            )))\n         new-set   (into #{} (apply concat new-items))]\n        (clojure.set/union new-set arg)))", "user": "55897fe2e4b059ccff29b205"}, {"problem": 84, "code": "(fn [coll]\n    (letfn  [(through [k x]\n               (loop [x x lst [] ]\n                 (if-let [nxt (get k x)]\n                   (let [steplst (map #(identity [(first %) nxt] ) lst)]\n                     (recur nxt (concat lst [[x nxt]] steplst))) \n                   lst)))]\n\n      (let [k (into {} coll)]\n        (->>  \n          (for [elem (keys k)]  (through k elem))\n          (mapcat identity)\n          (distinct)\n          (set)))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 84, "code": "(fn [x]\n   (let [m (into {} x)]\n     (into #{} (mapcat (fn [k] (for [v (iterate m (m k))\n                                     :while v]\n                              [k v])) (keys m)))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 84, "code": "(fn [binary-rels]\n    (letfn [(find-transitive-closure [x y]\n              (cond\n                (= (first x) (last y))\n                [(first y) (last x)]\n                (= (last x) (first y))\n                [(first x) (last y)]\n                :else\n                []))\n            (step-transite-closure [x]\n              (loop [x x\n                     acc #{}]\n                (if (empty? x)\n                  (reduce conj binary-rels (filter (complement empty?) acc))\n                  (recur (rest x) (concat acc\n                                          (map (partial find-transitive-closure (first x))\n                                               (rest x)))))))]\n      (loop [last-step (step-transite-closure binary-rels)]\n        (let [next-step (step-transite-closure last-step)]\n          (if (= last-step next-step)\n            last-step\n            (recur next-step))))))", "user": "555f3bfde4b0a2eb076a39c1"}, {"problem": 84, "code": "(fn [coll]\n\t(loop [cur coll prev #{}]\n\t\t(if (not= cur prev)\n\t\t\t(recur (reduce (fn [ret x]\n\t\t\t\t\t\t\t  (set (mapcat #(if (= (last x) (first %)) \n\t\t\t\t\t\t\t  \t              [[(first x) (last %)] %] \n\t\t\t\t\t\t\t  \t              [%])\n\t\t\t\t\t\t\t  \t           ret)))\n\t\t\t\t\t\t\tcur \n\t\t\t\t\t\t\tcur)\n\t\t\t       cur)\n\t\t\tcur)))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 84, "code": "(fn [es]\n  (letfn [(floyd-warshall\n            ([vs adj]\n             (floyd-warshall vs adj (seq vs)))\n            ([vs adj [k & tk]]\n             (if (nil? k)\n               adj\n               (floyd-warshall vs\n                               (reduce (fn [a [i j]]\n                                         (if (and (get-in a [i k]) (get-in a [k j]))\n                                           (assoc-in a [i j] true)\n                                           a))\n                                       adj\n                                       (for [i vs j vs] [i j]))\n                               tk))))\n          (keys-in [m]\n            (if (or (not (map? m))\n                    (empty? m))\n              '([])\n              (reduce (fn [a [k v]]\n                        (into a\n                              (map (partial into [k])\n                                   (keys-in v))))\n                      () \n                      m)))]\n    (let [vs (set (flatten (seq es)))\n          adj (->> es\n                   (map (fn [[x y]] {x {y true}}))\n                   (apply merge-with into))]\n      (set (keys-in (floyd-warshall vs adj))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 84, "code": "(fn transitive-clojure [xs]\n  (let [xs-map (into {} xs)\n        traverse (fn [xs-map last-ks result] \n                     (let [last-k (peek last-ks)\n                           next-value (xs-map last-k)\n                           parents (pop last-ks)]\n                       (if (nil? next-value)\n                            result\n                            (recur xs-map (conj last-ks next-value)\n                                (if (empty? parents)\n                                  result\n                                  (apply conj result (map #(vector % next-value) parents)))))))]\n    (reduce\n      (fn [xs k]\n        (clojure.set/union  xs (traverse xs-map [k] #{})))\n      xs\n      (keys xs-map))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 84, "code": "(fn tc [r]\n  (let [p (fn [x r] (map #(vector (first %) (last x)) (filter #(= (last %) (first x)) r)))\n        n (reduce into r (map #(p % r) r))]\n    (if (= n r)\n      n\n      (tc n))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 84, "code": "(fn trans [coll]\n   (letfn [(brel [_r x]\n                 (loop [ret []\n                        key (get _r x)\n                        val (get _r key)]\n                   (println \"debug:\" x key val)\n                   (if val\n                     (recur (conj ret [x val]) val (get _r val))\n                     ret\n                     )))]\n     (let [_map (reduce merge (map #(apply hash-map %) coll))]\n       (reduce #(if (coll? (first %2))\n                 (apply conj %1 %2)\n                 (conj %1 %2))\n               #{}\n               (for [c coll]\n                 (let [_brel (brel _map (first c))]\n                   (if (empty? _brel)\n                     c\n                     (conj _brel c))))))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 84, "code": "(letfn [(transitive-closure\r\n          ([inset] (transitive-closure #{} inset))\r\n          ([oldset inset]\r\n           (if (= inset oldset) inset\r\n               (->> inset\r\n                    (mapcat (fn [[a b]]\r\n                              (reduce (fn [accum [c d]]\r\n                                        (cond (= a d) (conj accum [c b])\r\n                                              (= c b) (conj accum [a d])\r\n                                              :else accum))\r\n                                      #{} inset)))\r\n                    (reduce conj inset)\r\n                    (recur inset)))))]\r\n  transitive-closure)", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 84, "code": "(fn [ps]\n  (let [m (into {} (vec ps))\n        from-here\n          (fn [x]\n            (loop [out []\n                   k x]\n              (let [v (m k)]\n                (if v\n                  (recur (conj out [x v]) v)\n                  out))))]\n    (set (apply concat (map #(from-here %) (keys m))))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 84, "code": "(fn trans-wrapper\n    [s]\n    (letfn [(trel? [a b] (= (second a) (first b)))\n            (trel [s b] {b (filter (partial trel? b) s)})\n            (trels [s]  (map (partial trel s) s))\n            (tclos [a b] [(first a) (second b)])\n            (tmap [m] (map (partial tclos (first (keys m))) (first (vals m)))) \n            (trans-closure ([s] (trans-closure s (trels s))) ([s t] (if (empty? t) s (recur (into s (tmap (first t))) (next t)))))]\n          (if (= s (trans-closure s))\n              s\n              (trans-wrapper (trans-closure s)))))", "user": "55acd080e4b03311e7b73298"}, {"problem": 84, "code": "(fn [s]\n  (let [get-rel (fn [s [k v]]\n                  (reduce (fn [acc [a b]] \n                            (if (= b k) \n                              (if (contains? acc [a v])\n                                acc\n                                (conj acc [a v]))\n                              acc)) #{} s))\n        all-rel (fn [s]\n                  (let [res (reduce #(let [r (get-rel s %2)]\n                                       (if (empty? r)\n                                         %1\n                                         (apply conj %1 r))) #{} s)]\n                    (if (empty? res)\n                      s\n                      (apply conj s res))))]\n    (loop [s s]\n      (let [ns (all-rel s)]\n        (if (= s ns)\n          ns\n          (recur ns))))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 84, "code": "(fn [divs]\n  (let [results (atom divs)]\n    (doseq [item divs]\n      (reduce #(if (= (last %)(first %2))\n                 (let [new-item (conj [] (first %) (last %2))] \n                   (swap! results conj new-item)\n                   new-item)\n                 %)\n              item\n              (filter #(not= item %) divs)))\n    @results))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 84, "code": "(fn [rels]\n  (letfn\n    [(trans [rels]\n            (let [rels-map (into {} rels)]\n              (reduce #(let [right (rels-map (last %2))\n                             left (first %2)]\n                         (if (and right (not (% [left right])))\n                           (conj % [left right])\n                           %))\n                      rels\n                      rels)))]\n    (let [res (trans rels)]\n      (if (= rels res)\n        rels\n        (recur res)))))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 84, "code": "(fn [tuples]\n    (letfn [(thread [tuples start]\n                    (loop [m (into {} tuples)\n                           acc []\n                           point start]\n                      (if point\n                        (recur m (conj acc point) (m point))\n                        acc)))\n\n            (threads [tuples] (map #(thread tuples (first %)) tuples))\n            (closures [v] (map (partial vector (first v)) (rest v)))\n            (transitive-closures [tuples] (reduce into #{} (map closures (threads tuples))))]\n      (transitive-closures tuples)))", "user": "52485f02e4b05ef8e38e63d3"}, {"problem": 84, "code": "(fn transClose [s]\n  (let [t (into s (for [p s q s\n                        :when (= (first q) (second p))]\n                    [(first p) (second q)]))]\n    (if (= t s) t (transClose t))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 84, "code": "(fn transitive-relations\n    ([relations-set]\n     (let [relations (reduce (fn [acc [from to]]\n                               (update-in acc [from] (fnil conj []) to))\n                             {} relations-set)]\n       (->> relations\n            (keys)\n            (map (partial transitive-relations relations))\n            (reduce into))))\n    ([relations root]\n     (loop [relatives (get relations root)\n            t-rels #{}]\n       (if-not (seq relatives)\n         t-rels\n         (recur\n          (apply concat (keep #(get relations %1) relatives))\n          (into t-rels (map (partial vector root) relatives)))))))", "user": "539e717fe4b0ca733b974488"}, {"problem": 84, "code": "(fn [sets]\n  (loop [s sets]\n    (let [gs (fn [x xs] (remove empty? (map #(if (= (second x) (first %)) [(first x) (second %)] []) xs)))\n          ms (fn [se] (reduce #(concat % (gs %2 %)) se se))\n          nsets (set (ms s))]\n      (if (= (count nsets) (count s)) s (recur nsets)))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 84, "code": "#(let [k (into % (for [[a b] % [c d] % :when (= b c)] [a d]))]\n   (if (= k %) % (recur k)))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 84, "code": "(fn [d] \n  (let [m (into {} d)\n        f #(let [v (m %2)] (if v (recur % v (conj %3 [% v])) %3))]\n    (reduce #(f %2 %2 %) #{} (keys m))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 84, "code": "(fn tc [s]\n  (letfn [(get-related [s [a b]] (filter (fn [[c d]] (= b c)) s))\n          (get-deep-related [s [a b]]\n                            (let [related (get-related s [a b])]\n                              (if (empty? related) []\n                                (concat related (mapcat (partial get-deep-related s) related)))))]\n    (clojure.set/union\n      s\n      (into #{} (apply concat (for [[a b] s]\n                                (let [related (get-deep-related s [a b])]\n                                  (map (fn [[c d]] (vector a d)) related))))))))\n\n; mfike's much nicer solution:\n; (fn [r]\n;   (let [r' (into r\n;                  (for [[a b] r\n;                        [c d] r :when (= b c)]\n;                    [a d]))]\n;     (if (= r r')\n;       r\n;       (recur r'))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 84, "code": "(fn trans [s]\n  (let [indexes (-> s vec flatten distinct vec (zipmap (range)))\n        n (count (keys indexes))\n        row (vec (repeat n 0))\n        empty-matrix (vec (repeat n row))\n        matrix (loop [pairs s update-matrix empty-matrix]\n                 (if (empty? pairs)\n                   update-matrix\n                   (let [ri (get indexes (first (first pairs)))\n                         ci (get indexes (second (first pairs)))]\n                     (recur (rest pairs)\n                            (update-in update-matrix [ri ci] (constantly 1))))\n                 ))\n        ops (for [k (range n) i (range n) j (range n)] [k i j])\n        ufn (fn [matrix [k i j]] (update-in matrix [i j] #(if (or (= 1 %) (= 1 (get-in matrix [i k]) (get-in matrix [k j]))) 1 0)))\n        umatrix (reduce (fn [acc v] (ufn acc v)) matrix ops)\n        tsets (into #{} (reduce (fn [acc v] (let [f (first v)\n                                        i (second v)]\n                                    (concat acc\n                                          (loop [sets (filter #(not (= (first %) f)) indexes) trs #{}]\n                                            (cond (empty? sets) trs\n                                                  (= 1 (get-in umatrix [i (second (first sets))])) (recur (rest sets) (conj trs [f (first (first sets))]))\n                                                  :otherwise (recur (rest sets) trs)\n                                                  )\n                                            )))\n                                    ) #{} indexes))\n   \n        ]\n    tsets\n    )\n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 84, "code": "(fn transitive [coll]                                                                                                                             \n  (letfn [(twoCombs [coll]\n            (cond\n              (< (count coll) 2) nil\n              (= (count coll) 2) #{[(first coll) (second coll)]}\n              :else (clojure.set/union\n                     (twoCombs (rest coll))\n                     (set (map #(vec [(first coll) %]) (rest coll))))))\n          (validPair? [[[f1 f2] [s1 s2]]]\n            (or (= f2 s1) (= s2 f1)))\n          (makePairs [[[f1 f2] [s1 s2]]]\n            (cond\n              (= f2 s1) [f1 s2]\n              (= f1 s2) [s1 f2]))]\n    (let [tc (twoCombs coll)\n          vps (filter validPair? tc)\n          nps (set (map makePairs vps))]\n      (if (clojure.set/superset? coll nps)\n        coll\n        (transitive (clojure.set/union coll nps))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 84, "code": "#(let [r (into % (for [[a b] % [c d] % :when (= b c)] [a d]))]\n   (if (= % r) r (recur r)))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 84, "code": "(fn\n  [pairs]\n  (let [m (into {} pairs)]\n    (letfn [(descendents\n             [k]\n             (when k\n               (flatten (conj (descendents (get m k)) (get m k)))))]\n      (let [new-m (into {} (for [[k v] m]\n                             [k (conj (descendents v) v)]))\n            new-pairs (for [[k v] new-m\n                            d (keep identity v)]\n                        [k d])]\n        (set new-pairs)))))", "user": "51281b25e4b03a34742b4304"}, {"problem": 84, "code": "(fn [rel]\n  (let [m (into {} (seq rel))\n        tc #(loop [n % a []]\n              (if (m n)\n                (recur (m n)(conj a [% (m n)])) a))]\n    (set (mapcat tc (keys m)))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 84, "code": "(fn __ [v]\n(letfn [(ara [ua la ndl]\n (loop [x ua y la i 0 ans nil]\n  (if (= i (count ua)) ans\n   (if (= (first x) (second ndl))\n       (recur x y (count ua) [x y])\n       (recur (take (count x) (rest (cycle x)))\n       \t      (take (count y) (rest (cycle y)))\n\t      (inc i)\n\t      nil)))))\n(apass [i j]\n     (loop [x i y j acc [] c nil]\n     \t   (if (empty? x) acc\n\t   (if (nil? c)\n\t       (recur (rest x) (rest y)\n\t       \t      (conj acc [(first x) (first y)])\n\t\t      [(first x) (first y)])\n\t       (let [araa (ara x y c)]\n\t       \t    (if (nil? araa)\n\t\t    \t(recur (rest x) (rest y)\n\t\t\t(conj acc [(first x) (first y)])\n\t\t\t[(first x) (first y)])\n\t\t\t(recur (first araa) (second araa)\n\t\t\t(conj acc [(first x) (first y)] [(first c) (first (second araa))])\n\t\t\t[(first (first araa)) (first (second araa))])))))))\n(inor [m]\n (loop [xy m nl (count m) prevnl 0]\n  \t(if (>= prevnl nl) (into #{} xy)\n       \t    (let [[i j] (list (map first m) (map second m))\n\t    \t  npass (apass i j)]\n             (recur npass (count npass) nl)))))\n(phs [v]\n (loop [m  (into [] v) i 0 acc []]\n   (if (> i (count v)) (last (sort-by #(count %) acc))\n       (recur (take (count m) (rest (cycle m)))\n       \t      (inc i)\n\t      (conj acc (inor m))))))]\n (let [n (phs v) s (phs n)]\n  (if (>= (count n) (count s))\n   n\n   (__ n)))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 84, "code": "(fn transitive-binary\n  [tuple-set]\n  (let [tuple-first-map\n        (into {} (map #(vector (first %) %) tuple-set))]\n    (loop [remaining-ts tuple-set\n           acc-set #{}]\n      (let [current-tuple (first remaining-ts)\n            transitive-candidate (if (tuple-first-map (second current-tuple))\n                                   (vector\n                                    (first current-tuple)\n                                    (second (tuple-first-map (second current-tuple)))))\n            transitive-closure\n            (if (and transitive-candidate (not (acc-set transitive-candidate)))\n              transitive-candidate)\n            remaining-ts' (disj (if transitive-closure\n                            (conj remaining-ts transitive-closure)\n                            remaining-ts) current-tuple)]\n        (if (seq remaining-ts)\n          (recur remaining-ts' (conj acc-set current-tuple))\n          acc-set)))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 84, "code": "(fn transClosure[s]\n  (letfn [(rel->map[s]\n                   (apply (partial merge-with (comp vec concat)) (map (fn [[a b]] (into {} [[a [b]]])) s)))\n          (reachable[m & keys]\n                    (flatten (map \n                               (fn [key]\n                                 (if (contains? m key)\n                                   [key (apply (partial reachable m) (m key))]\n                                   [key]))\n                               keys)))]\n\n    (set \n      (filter \n        (complement empty?)\n        (reduce \n          #(into %1 %2)\n          #{}\n          (let [m (rel->map s)]\n            (map\n              (fn [key]\n                (map\n                  (fn [el]\n                    (if (not= el key)\n                      [key el]\n                      []))\n                  (reachable m key)))\n              (keys m))))))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 84, "code": "(fn transitive-closure [orig-pairs]\n  (let [new-pairs\n        (set (for [[x1 x2] orig-pairs\n                   [x3 x4] (disj orig-pairs [x1 x2])\n                   :when (and (= x2 x3) (not (contains? orig-pairs [x1 x4])))]\n               [x1 x4]))\n        combined-pairs (clojure.set/union orig-pairs new-pairs)]\n    (if (empty? new-pairs) orig-pairs\n      (clojure.set/union combined-pairs (transitive-closure combined-pairs)))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 84, "code": "(fn t [r]\n  (if (= 1 (count r))\n    r\n    (into r\n      (for [[a b :as e] r\n            [c d :as n] (t (disj r e))]\n        (if (= b c)\n          [a d]\n          n)))))", "user": "561047eae4b05f002753df6d"}, {"problem": 84, "code": "(letfn [(rel-to-map [rel]\n          (reduce (fn [m item] \n                    (let [f (first item) \n                          s (second item)]\n                      (assoc m f (conj (m f) s))))\n                  {} \n                  rel))\n        (insert-child-items [m item child]\n          (let [x (m child)]\n            (if (nil? x)\n              m\n              (assoc m item (set (concat (m item) x))))))\n        (insert-children-related-items [m item]\n          (reduce (fn [m child] (insert-child-items m item child)) \n                  m (m item)))\n        (transitive-closure-helper [item r1 r0]\n          (if (= r1 r0)\n            r1\n            (transitive-closure-helper item (insert-children-related-items r1 item) r1)))\n        (transitive-closure-mapres [r]\n          (let [mm (rel-to-map r)]\n            (reduce (fn [m x] (transitive-closure-helper x m {})) mm \n                    (keys mm))))\n        (transitive-closure [r]\n          (let [mapres (transitive-closure-mapres r)]\n            (set (apply concat (map (fn [k] (map (fn [v] [k v]) (mapres k)))\n                                    (keys mapres))))))]\n  transitive-closure)", "user": "54857e3be4b0e286459a11ad"}, {"problem": 84, "code": "(fn [s] (let [m (into {} s)]\n          (set (mapcat #((fn [[x & s]] (map (partial vector x) s)) \n                         (take-while (comp not nil?) (iterate m %)))\n                       (keys m) ))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 84, "code": "(fn [br]\n  (let [mp (into {} br)]\n    (reduce (fn [edges vertex]\n              (loop [v vertex edges edges]\n                (if-let [v (mp v)]\n                  (recur v (conj edges [vertex v]))\n                  edges)))\n            #{}\n            (distinct (flatten (seq br))))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 84, "code": "(fn tc [se]\n  (let [m (apply merge-with concat (map (fn [[k v]] {k [v]}) se))\n        r ((fn %r [mm]\n              (let [new (into {} (map (fn [[k v]] [k (set (concat v (mapcat (fn [arg] (get mm arg)) v)))]) mm))]\n                (if (= new mm) new\n                    (%r new)))) m)]\n    (set (mapcat (fn [[k v]] (map (fn [v] [k v]) v)) r))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 84, "code": "; this pass the tests, but is not universal solution. Consider any cyclical relation\n; (fn [S]\n;  (let [R (group-by second S)\n;        T (fn [[t f]] (map (fn [[a b]] (vector a f)) (R t)))\n;        F (fn F [e] (let [t (T e)] (concat [e] t (mapcat F t))))]\n;    (set (mapcat F S))))\n\n(fn [r]\n  (let [R (reduce (fn [R [t f]] (assoc R f (conj (R f []) t))) {} r)\n        g (fn [k]\n            (loop [[q & Q :as N] (R k) S #{}]\n              (if (empty? N) S (recur (concat Q (if-let [t (R q)] (if-not (S q) t))) (conj S q)))))]\n    (set (mapcat (fn [k] (map vector (g k) (repeat k))) (keys R)))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 84, "code": "(fn puzzle-84 [s]\n  (letfn [(close-set [s]\n                     (set \n                      (remove nil? \n                              (for [a s b s :when (not (identical? a b))]\n                                (let [[a1 a2] a\n                                      [b1 b2] b\n                                      el [a1 b2]]\n                                  (if (and\n                                       (= a2 b1)\n                                       (not (contains? s el)))\n                                    el))))))]\n  (loop [s s]\n    (let [cls (close-set s)]\n      (if (empty? cls) s\n        (recur (clojure.set/union s cls)))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 84, "code": "(fn find-transitive-clojures\n  [xset]\n   (let [xs-vec (apply vector xset)]\n    (letfn [(find-acc-transitives [xs]\n               (if-let [new-transitives (seq (find-new-transitives xs))]      ;; found new transitive-clojures\n                  (into xs (find-new-transitives (into xs new-transitives)))  ;; recur on existing + found-new-transitives\n                  xs))\n           (find-new-transitives [xs]\n              (reduce\n                (fn [acc [h-tuple l-tuple]]\n                  (into acc\n                    (for [[h l] xs :when (= l-tuple h)]\n                      [h-tuple l])))\n                [] xs))]\n      (set (find-acc-transitives xs-vec)))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 84, "code": "(fn [orig]  (letfn [ \n(traverse [ head  tail  edges ]\n  (if (empty? edges) #{}\n      (let [nexts (filter #(= tail (first %)) edges)]\n         (apply clojure.set/union \n                (map #(conj (traverse head (last %) (disj edges %)) [head (last %)]) nexts))))) ]\n      \n (clojure.set/union orig\n    (apply clojure.set/union\n      (map #(traverse (first %) (last %) (disj orig %)) orig))))\n)", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 84, "code": "(fn prob81\n  [s]\n  (letfn [(fnc [elm s]\n            (let [nxt (filter #(= (second elm) (first %)) s)]\n              (if (seq nxt)\n                (do \n                  ;; (println elm nxt)\n                  ;; merge elm ->next\n                  (let [mrg (map #(vec [(first elm) (second %)]) nxt)]\n                    (cons elm (mapcat #(fnc % s) mrg))\n                    )\n                  )\n                [elm]\n                )))]\n    (set (mapcat #(fnc % s) s))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 84, "code": "(fn [rel]\n  (letfn\n    [(transition [[[s1 t1] [s2 t2]]]\n       (if (= t1 s2) [s1 t2]))\n     (cartesian-product [s]\n       (set\n         (mapcat\n           #(map (partial vector %) s)\n           s)))\n     (step [rel]\n       (->> rel\n            cartesian-product\n            (map transition)\n            (remove nil?)\n            (into rel)))\n     (transitive-closure [rel]\n       (loop [sp 0\n              trel (step rel)]\n         (let [sn (count trel)]\n           (if (= sp sn)\n               trel\n               (recur sn\n                      (step trel))))))]\n    (transitive-closure rel)))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 84, "code": "(fn transitive-closure\n  [relations]\n  (letfn [(step [pairs]\n            (clojure.set/union pairs\n                               (for [[x1 y1] pairs\n                                     [x2 y2] pairs :when (= y1 x2)]\n                                       [x1 y2])))]\n    (loop [prev-pairs relations]\n      (let [next-pairs (step prev-pairs)]\n        (if (= prev-pairs next-pairs)\n          next-pairs\n          (recur next-pairs))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 84, "code": "(let [prod (fn [u v]\n  (set (reduce \n        (fn [a x] \n          (concat a \n                  (map #(vector x %) v))) \n          [] u)))\n      nxt (fn nxt [ls]\n        (clojure.set/union ls\n        (into #{} \n              (map \n               #(vector (first (first %)) (second (second %))) \n               (filter \n                #(= (second (first %)) (first (second %))) \n                (prod ls ls))))))]\n  (fn [s]\n    (loop [s s\n           n (nxt s)]\n      (if (= s n)\n        s\n        (recur n (nxt n))))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 84, "code": "(fn get-closure [r]                                                                                                 \n  (let [x->y (into {} r)                                                                                              \n        get-trans #(->> % (iterate (fn [[k v]] (vector k (get x->y v))))                                              \n                        (take-while second))]                                                                         \n    (set                                                                                                              \n      (for [xy r, xyy (get-trans xy)]                                                                                 \n        xyy))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 84, "code": "(fn [pair-set]\n  (let [pair-map (into {} pair-set)]\n    (->> (map\n           (fn [pair]\n             (take-while\n               (fn [[_ v]] (not (nil? v)))\n               (iterate \n                 (fn [[k v]]\n                   (vector k (pair-map v)))\n                 pair)))\n           pair-map)\n         (reduce concat)\n         (set))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 84, "code": "(fn [arg1]\n(cond\n(= arg1 #{[8 4] [9 3] [4 2] [27 9]}) #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}\n(= arg1 #{[\"cat\" \"man\"] [\"man\" \"snake\"] [\"spider\" \"cat\"]}) #{[\"cat\" \"man\"] [\"cat\" \"snake\"] [\"man\" \"snake\"] [\"spider\" \"cat\"] [\"spider\" \"man\"] [\"spider\" \"snake\"]}\n(= arg1 #{[\"father\" \"son\"] [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]}) #{[\"father\" \"son\"] [\"father\" \"grandson\"] [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]}\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 84, "code": "(fn tclosure [coll]\n  (let [relations (into {} coll)]\n    (letfn \n      [(find-path [src]\n                  (loop [x src paths #{}] \n                    (if-let [dest (get relations x)]\n                      (recur dest (conj paths [src dest]))\n                      paths)))]\n      (reduce clojure.set/union\n              (for [elem (keys relations)] \n                (find-path elem))))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 84, "code": "(fn [input]\n  (let [result (->> input\n                    (map (fn [x] (map (fn [y] [x y]) input)))\n                    (apply concat)\n                    (map (fn [[[a b] [c d]]] (if (= b c) [a d] nil)))\n                    (filter (partial not= nil)))]\n    (if (clojure.set/subset? result input)\n      input\n      (recur (clojure.set/union input result)))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (letfn [(get-parent [rel s]\n            (let [rel-next (first s)]\n              (cond (nil? rel-next) rel\n                    (= (first rel) (last rel-next)) (get-parent rel-next (disj s rel-next))\n                    :else (get-parent rel (disj s rel-next)))))\n          (get-children [rel remaining]\n            (let [child-name (last rel)\n                  child (some #(when (= child-name (first %)) %) remaining)]\n              (if (nil? child) nil\n                  (conj (get-children child (disj remaining child)) child))))\n          (get-relationships [[rel & remaining]]\n            (if (empty? remaining) []\n                (->> (reduce #(conj %1 [(first rel) (last %2)]) [] remaining)\n                     (concat (get-relationships remaining)))))]\n    (->> (map #(get-parent % (disj s %)) s)\n         distinct\n         (map #(conj (get-children % (disj s %)) %))\n         (map #(concat (get-relationships %) %))\n         (reduce concat)\n         set)))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(co [[a b] [c d]] (let [m (if (= b c) [[a d]] [])] \n                              (if (= a d) (conj m [c b]) m)))]\n    (reduce #(into % (mapcat (partial co %2) %)) s s)))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 84, "code": "(fn [rel]\n  (let [add (fn [rl] \n                (let [nr (for [e1 rl e2 rl\n                               :when (= (second e1) (first e2))]\n                               [(first e1) (second e2)])]\n                   (clojure.set/union rl (apply hash-set (distinct nr)))))]\n      (add (add rel))))", "user": "5649615be4b0284900eef641"}, {"problem": 84, "code": "(fn [s]\n          (let [m (into {} s)\n                ks (into [] (map #(first %) (into [] s)))\n                gs (fn [ss k] (loop [v (m k) s ss]\n                                (if (nil? v) s\n                                  (recur (m v) (conj s [k v])))))]\n            (loop [ss s k ks]\n              (if (nil? (first k)) ss\n                (recur (gs ss (first k)) (rest k))))))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 84, "code": "(fn transitive-closure\n  [rel]\n  (let [known rel\n        expand (into #{} (for [x known\n                            y known]\n                        (cond \n                         (= (second x) (first y)) [(first x) (second y)]\n                         :else x)))]\n    (if (= (count known) (count expand))\n      known\n      (recur expand))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(generate-new-item [a b]\n                             (if (= (last a) (first b))\n    \t\t\t\t\t\t\t(vector (first a) (last b))\n    \t\t\t\t\t\t\tnil))]\n    (loop [result s remains (apply vector s)]\n      (if (= 0 (count remains))\n        result\n        (let [new-elements (remove #(contains? result %) \n                                   (remove nil? \n                                           (map (partial generate-new-item (first remains)) result)))]\n          (recur (clojure.set/union result new-elements) (concat (rest remains) new-elements)))))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 84, "code": "(fn [a]\n  (letfn [(gen [c]\n            (let [rr (reduce\n                       (fn [r e]\n                         (assoc r (first e)\n                                  (reduce #(set (concat %1 (get c %2))) (second e) (second e)))) {} c)]\n              (if (= rr c) rr (gen rr))\n          ))]\n    (reduce (fn [r e] (set (concat r (reduce #(conj %1 [(first e) %2]) [] (second e))))) []\n            (gen (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) #{}) (second %2))) {} a)))\n))", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 84, "code": "(fn s [r]\n  (let [d (fn [[a b] [x y]]\n            (if (= b x)\n              [a y]))\n        t #(apply conj\n                  r\n                  (for [x %\n                        y %\n                        :let [e (d x y)]\n                        :when e]\n                    e))\n         c (t r)]\n    (if (= r c)\n      c\n      (s c))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 84, "code": "(fn tc [relset]\n  (letfn [\n          (combine [[a1 _][_ b2]]  [a1 b2])\n          (extends [[_ a2][b1 _]]  (= a2 b1))]\n  (loop\n    [candidates relset\n     acc #{}]\n    (if (empty? candidates)\n      acc\n      (let [fc (first candidates)\n            rc (rest candidates)\n            nacc (conj acc fc)\n            new_transitions (set (map #(combine fc %) (filter #(extends fc %) relset)))\n            nc (clojure.set/union rc new_transitions)]\n        (recur nc nacc)\n        )))))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 84, "code": "(fn [ts]\n  (reduce\n   (fn [a e] (into a (map #(vector (e 0) %) (e 1))))\n   #{}\n   (for [fst (map first ts)]\n     [fst ((fn f [prop]\n             (if-let [np ((into {} ts) prop)]\n               (into #{np} (f np)))) fst)])))", "user": "52c25645e4b07a9af579237d"}, {"problem": 84, "code": "(fn [vbs]\n  (let [tcm  (into {} vbs)\n        pout (fn mk-pout [po vb]\n               (let [out (conj po vb)]\n                 (if (contains? tcm (second vb))\n                   (mk-pout out (vector (first vb) (get tcm (second vb))))\n                   out)))]\n    (loop [out #{} in vbs]\n      (if (empty? in)\n        out\n        (recur (clojure.set/union out (pout #{} (first in))) (rest in))))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 84, "code": "(fn transive-closure\n   ([rels rel] (transive-closure (conj rels rel)))\n   ([rels]\n    (reduce transive-closure rels\n            (->> (for [[a b] rels [x y] (disj rels [a b])]\n                   (when (and (= x b) (not (rels [a y]))) [a y]))\n                 (remove nil?)))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 84, "code": "(fn __ [relations]\n    (let [catern-product (fn [l1 l2] (for [i l1] [i l2]))]\n      (->> (reduce (fn [[to-item from-item] [f t]]\n                     [(merge-with concat to-item\n                                  (into {} \n                                        (catern-product (conj (from-item t) t) (conj (to-item f) f))))\n                      (merge-with concat from-item\n                                  (into {} \n                                        (catern-product (conj (to-item f) f) (conj (from-item t) t))))\n                      ]              )\n                   [{} {}]\n                   relations)\n           second\n           (mapcat (fn [[k v]] (map vector (repeat k) v)))\n           (set))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 84, "code": "(fn transclosure\n  [coll]\n  (let [new-coll (into coll\n                       (reduce (fn [acc [start end]]\n                                 (into acc\n                                       (keep (fn [[start' end']]\n                                               (when (= end start')\n                                                 [start end']))\n                                             coll)))\n                               #{}\n                               coll))]\n  ; A brute-force solution for a more civilized age.\n  ; Might get stuck in an infinite loop. Great!\n  (if (= new-coll coll)\n    new-coll\n    (recur new-coll))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": 84, "code": "(fn update-transitive [x]\n  (letfn [(update-transitive-inc [x]\n                                 (reduce\n                                   (fn [m [a b]]\n                                     (update-in m [a] (fn [old] (into old (apply concat (map m b))))))\n                                   x\n                                   x))]\n    (let [\n           x-as-map (apply hash-map (flatten (seq (map (fn [[a b]] [a (hash-set b)]) x))))\n           consecutive-updates (iterate update-transitive-inc x-as-map)\n           pairs (partition 2 1 consecutive-updates)\n           result-map (first (first (drop-while (fn [[a b]] (not= a b)) pairs)))]\n      (reduce\n        (fn [old [key value-set]]\n          (into\n            old\n            (map (fn [value] [key value]) value-set)))\n        #{}\n        result-map))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 84, "code": "(letfn [(reachable? [path-map from to]\n                    (if-let [tos (get path-map from)]\n                      (contains? tos to)))\n        (add-path [path-map from to]\n                  (update-in path-map [from] (fnil conj #{}) to))]\n  (fn trans-closure [edges]\n    (let [vertices (->> edges seq flatten set)\n          path-map (->> edges\n                        (map (fn [[u v]] {u #{v}}))\n                        (apply merge-with clojure.set/union))]\n      (->> (for [u vertices v vertices w vertices] [u v w])\n           (reduce (fn [path-map [u v w]]\n                     (if (and (not (reachable? path-map u w))\n                              (reachable? path-map u v)\n                              (reachable? path-map v w))\n                       (add-path path-map u w)\n                       path-map)) \n                   path-map)\n           (mapcat (fn [[k v]] (map vector (repeat k) v)))\n           (set)))))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 84, "code": "(fn [args] (letfn [(trans [z] (into z (for [x z\n                                             y (disj z x)\n                                             :when (= (first y) (second x))]\n                                         [(first x)(second y)])))]\n              (loop [as args]\n                (if (= (trans as) as) \n                  as \n                  (recur (trans as)))\n                )))", "user": "566a3a26e4b0a866af689699"}, {"problem": 84, "code": "#(let [m (into {} %)\n          n (into % (for [[k v] m :when (m v)] [k (m v)]))]\n      (if (= n %) % (recur n)))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 84, "code": "(fn xx[s]\n  (letfn [(i[[bs s]]\n            (let [n (mapcat (fn[[a b]] (mapcat (fn[[c d]] (when (and (= b c) (not (s [a d]))) [[a d]])) s)) bs)]\n              [n (clojure.set/union s n)]))]\n    (last (last (take-while (comp seq first) (iterate i [s s]))))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 84, "code": "(fn [e]\n  (let [kp (fn [x] (keep #(if (= (first %) x) (second %)) e))\n        pair (fn [x s] (for [y s] [x y]))\n        n (remove empty? (mapcat #(pair (first %) (kp (second %))) e))\n        ne (into e n)]\n    (if (= e ne) e (recur ne))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 84, "code": "(letfn [(path? [coll f t]\n          (and (some (fn [[a b]] \n                       (and (= a f) \n                            (or (= b t) (path? (remove #(= a (first %)) coll) b t)))) coll) [f t]))]\n  (fn [coll] (set (mapcat #(keep (partial path? coll %) \n                                 (map second coll))\n                          (map first coll)))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 84, "code": "(fn tc [s] \n  (loop [s s c 0] \n    (if (= c (count s)) s \n      (let [g (group-by first s)\n              newset   (reduce (fn [s k] (clojure.set/union s (set (map #(list k (second %1)) (mapcat g (map last (g k))) )))) s (keys g))\n      ] \n        (recur newset (count s))\n      ) \n     )\n   )\n  )", "user": "56a75810e4b0542e1f8d14fc"}, {"problem": 84, "code": "(fn [rels]\n  (letfn [(build [rel]\n            (let [follow (first (filter #(= (last rel) (first %)) rels))]\n              (cons rel (when (seq follow) (build [(first rel) (last follow)])))))]\n    (set (mapcat build rels))))\n\n;(fn [rels]\n;  (let [expand (set (concat rels\n;                            (for [[a b] rels\n;                                  [c d] rels\n;                                  :when (= b c)]\n;                              [a d])))]\n;    (if (= expand rels)\n;      rels\n;      (recur expand))))", "user": "54485749e4b032a45b8693c7"}, {"problem": 84, "code": "(fn [relation]\n  (letfn [(close [rel-coll i]\n            (if (= i (count rel-coll))\n                rel-coll\n                (let [current (get rel-coll i),\n                      pref-coll (take i rel-coll),\n                      fc1 (filter #(= (second %) (first current)) pref-coll),\n                      ne1 (for [e fc1] [(first e) (second current)]),\n                      fc2 (filter #(= (second current) (first %)) pref-coll),\n                      ne2 (for [e fc2] [(first current) (second e)])]\n                  (recur (vec (concat rel-coll ne1 ne2)) (inc i)))))]\n    (set (close (vec relation) 1))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 84, "code": "(fn [s]\n(let [t (into s\n  (for [x s y s :when (= (second x) (first y))]\n        [(first x) (second y)]\n   ))]\n  (if (= t s)\n    t\n   (recur t))\n))", "user": "56bca51ae4b0f26550335963"}, {"problem": 84, "code": "(fn [bi-set]\n  (letfn [(tclosure [set1 set2 result]\n             (let [rset (for [[a b] set1 [x y] set2 :when (= b x)] [a y])]\n               (if (empty? rset)\n                  (apply conj set1 result)\n                 (tclosure set1 rset (apply conj result rset)))))]\n   (tclosure bi-set bi-set #{})))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 84, "code": "(fn [group]\n  (loop [s group]\n    (let [result (apply conj s (remove nil? (for [x s y (disj s x)] (if (= (second x) (first y)) [(first x)(second y)]))))]\n      (if (= s result) result\n        (recur result)))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e]\n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "567931e9e4b05957ce8c6184"}, {"problem": 84, "code": "(fn [relations]\n  (letfn [(find-heads\n           []\n           (clojure.set/difference\n            (set (map first relations))\n            (set (map second relations))))\n          (find-relation-chain\n           [chain]\n           (let [next-relation (some #(when (= (last chain) (first %)) %) relations)]\n             (if next-relation\n               (find-relation-chain (conj chain (second next-relation)))\n               chain)))\n          (chain-to-relations\n           [chain result-relations]\n           (if (< (count chain) 2)\n             result-relations\n             (recur (next chain) (concat result-relations (map #(vec (list (first chain) %)) (next chain))))))]\n    (->> (find-heads)\n         (map #(vec (list %)))\n         (map find-relation-chain)\n         (map #(chain-to-relations % []))\n         (reduce concat)\n         set)))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 84, "code": "(fn\n  [r]\n  (letfn [(closure [r] (set (concat r (apply concat \n                                             (for [[a b] r]  ; for aRb\n                                               (let [bRc (filter #(= (first %1) b) r)]\n                                                 (map #(vector a (second %)) bRc)))))))\n          (take-until-duplicate [l s]\n            (if (= l (first s)) l (recur (first s) (rest s))))]\n    (take-until-duplicate nil (iterate closure r))))", "user": "5638b88de4b0bfe05bf117e9"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (reduce (fn [xs tuple]\n            (let [new-tuples (clojure.set/union xs s)\n                  xss (clojure.set/union xs #{tuple})\n                  xss (if-let [ts (seq (filter #(= (second %) (first tuple)) new-tuples))]\n                        (clojure.set/union xss (map (fn [t] [(first t) (second tuple)]) ts))\n                        xss)\n                  xss (if-let [ts (seq (filter #(= (first %) (second tuple)) new-tuples))]\n                        (clojure.set/union xss (map (fn [t] [(first tuple) (second t)]) ts))\n                        xss)]\n              \n               xss)) #{} s))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 84, "code": "(fn [s] \n  (nth (iterate (fn [s]\n     (reduce \n        into \n        #{}\n        (for [[k1 v1] s\n              [k2 v2] s]\n            (if (= v1 k2)\n                (reduce into \n                   (list #{[k1 v1]} #{[k2 v2]} #{[k1 v2]}))\n                (conj #{[k1 v1]} [k2 v2])))))\n  s) (count s)))", "user": "56b86e64e4b0f26550335924"}, {"problem": 84, "code": "(letfn\n    [(grp [xs n]\n       (->>\n        (filter #(= n (first %)) xs)\n        (mapcat #(grp xs (second %)))\n        (cons n)))\n     (pair [xs]\n       (map #(vector (first xs) %) (rest xs)))]\n  (fn [xs]\n    (->>\n     (map #(grp xs (first %)) xs)\n     (reduce #(concat %1 (pair %2)) [])\n     (set))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 84, "code": "(fn [x]\n  (let [graph (into {} x)\n        hlp (fn [k]\n              (loop [v (graph k) rels #{[k v]}]\n                (let [vv (graph v)]\n                  (if (nil? vv)\n                    rels\n                    (recur vv (conj rels [k vv]))))))]\n    (reduce #(into %1 (hlp %2)) #{} (keys graph))))", "user": "56012cd7e4b04bb52996e17d"}, {"problem": 84, "code": "(fn [items]\n  (let [new-items (into items\n                        (->> (for [[h t :as item] items\n                                   :let [match (->> items\n                                                    (filter (comp (partial = t) first))\n                                                    first)]\n                                   :when match]\n                               [item match])\n                             (map (fn [[[h] [_ t]]]\n                                    [h t]))))]\n    (if (= (count items)\n           (count new-items))\n      new-items\n      (recur new-items))))", "user": "56e83348e4b02e7e935eb6e5"}, {"problem": 84, "code": "(fn transitiveX[rels]\n\t(letfn [\n\t\t(transitiveRes[relMap nextKey firstKey] \n\t\t\t(let [vl (get relMap nextKey)]\n\t\t\t\t(if (nil? vl)\n\t\t\t\t\t#{}\n\t\t\t\t\t(conj (transitiveRes relMap vl firstKey)[firstKey vl])\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t]\n\t\t(let [relMap (zipmap (map first rels) (map last rels))]\n\t\t\t(apply clojure.set/union (map #(transitiveRes relMap % %) (keys relMap)))\n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 84, "code": "(fn solve [x] \n  (let [ temp\n  (set\n    (concat \n      (apply list x)\n      (apply concat\n        (for [k x]\n          (map #(vector (first k) (last %)) (filter #(= (last k) (first %)) x))\n        )\n      )\n    )\n  )]\n  (if (= temp x) x (solve temp)))\n)", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 84, "code": "(fn [s]\n         (let [ext (fn [[a b] [c d]]\n                   (cond\n                     (and (= a c) (= b d)) [[a b] [c d]]\n                     (= b c) [[a b] [c d] [a d]]\n                     (= a d) [[a b] [c d] [c b]]\n                     :else [[a b] [c d]]))\n               pull (fn [s]\n                      (into #{}\n                            (apply concat\n                                   (for [p1 s p2 s]\n                                     (ext p1 p2)))))]\n           (let [new-s (pull s)]\n             (if (= s new-s)\n               s\n               (recur new-s)))))", "user": "56a76f36e4b07966d5a8a05b"}, {"problem": 84, "code": "(fn [s] (let [r (fn f [l e] (reduce #(let [a [(first e) (last %2)]] (if (= %2 e) (conj % %2) (if (= (last e) (first %2)) (conj (f % a) a) %))) l s))] (reduce r #{} s)))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 84, "code": "(fn [arg] (reduce (fn [acc e] (->> (disj acc e)\n                                    (filter #(= (first %) (last e)))\n                                    (map #(list (first e) (last %)))\n                                    (clojure.set/union acc))) arg arg))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 84, "code": "(fn f [col]\n  (let [m (into {} col)\n        ks (keys m)]\n    (letfn [(get-children [parents m root]\n              (println parents)\n              (let [child (m root)\n                    parents' (conj parents root)]\n                (if child\n                  (concat (map\n                           #(do [% child])\n                           parents') ;[[root child]]\n                          (get-children parents' m child))\n                  nil)))]\n      (set (mapcat (partial get-children [] m) ks)))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 84, "code": "(let [my-update (fn [m k f] (assoc m k (f (get m k))))\n      bfs-reach (fn\n                  [graph start reached-set]\n                  (let [visited #{}\n                        queue   (conj clojure.lang.PersistentQueue/EMPTY start)]\n                    (loop [visited visited\n                           current (peek queue)\n                           queue   queue]\n                      (if (zero? (count queue))\n                        (clojure.set/union\n                         reached-set\n                         (set\n                          (mapv\n                           vec\n                           (partition\n                            2\n                            (interleave\n                             (repeat start)\n                             (clojure.set/difference visited #{start}))))))\n                        (if-not (contains? visited current)\n                          (recur (conj visited current)\n                                 (peek queue)\n                                 (into (pop queue) (get graph current)))\n                          (recur visited\n                                 (peek queue)\n                                 (into (pop queue) (get graph current))))))))\n               adjacency-lists (fn\n                  [nodes edges]\n                  (loop [adj-map               (zipmap nodes (repeat []))\n                         edges                 edges\n                         [from to :as current] (first edges)]\n                    (if (nil? current)\n                      adj-map\n                      (recur (my-update adj-map from #(conj % to))\n                             (rest edges)\n                             (first (rest edges))))))\n                transitive-closure (fn\n                  [edge-set]\n                  (let [node-set (reduce #(apply conj %1 %2) #{} edge-set)\n                        graph    (adjacency-lists node-set edge-set)]\n                    (loop [edges                (rest edge-set)\n                           [from _ :as current] (first edge-set)\n                           closure              #{}]\n                      (if (nil? current)\n                        closure\n                        (recur (rest edges)\n                               (first edges)\n                               (bfs-reach graph from closure))))))]\n          transitive-closure)", "user": "4eb47bb1535d7eef30807362"}, {"problem": 84, "code": "(fn [br]\n    (letfn [(chain [k m]\n              (if-let [v (m k)]\n                (cons k (chain v (dissoc m k)))\n                (list k)))\n            (build [m]\n              (if (seq m)\n                (if-let [c (apply max-key count (map #(chain % m) (keys m)))]\n                  (cons c (build (apply dissoc m c))))))\n            (expand [s]\n              (when (next s)\n                (cons (map #(vector (first s) %) (rest s))\n                      (expand (next s))))\n              )]\n      (->> (into {} br) build (map expand) (apply concat) (apply concat) set)))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 84, "code": "(fn [s] (last (take (count s) (iterate (fn [s] (into s\n  (for [[x1 x2] s [y1 y2] s :when (= x2 y1)] [x1 y2]))) s ))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 84, "code": "(fn trc [rel-set]\n   (letfn [(get-line [m x]\n                     (if (m x)\n                       (cons x (get-line m (m x)))\n                       [x]))]\n     (let [rel-map (into {} rel-set)\n           ks (keys rel-map)\n           lines (filter #(>= (count %) 3) (for [x ks]\n                   (get-line rel-map x)))\n           tran-rel (mapcat (fn [[f s & more]] (map #(vector f %) more)) lines)]\n       (set (concat rel-set tran-rel)))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 84, "code": "(fn [s]\n  (loop [l s acc #{}]\n    (if-let [f (first l)]\n      (recur\n       (rest l)\n       (into acc\n             ((fn f [x s]\n                (if-let [a ((fn [[h t] s]\n                              (reduce (fn [a [i j]] (if (= i t) [h j] a))\n                                      nil s)) x s)]\n                  (conj (f a s) a)\n                  #{}))\n              f s)))\n      (into s acc))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 84, "code": "(fn [ss]\n  (letfn [(compose [[a b] [c d]]\n            (if (not= b c)\n              false\n              [a d]))\n\n          (selfcomp [xs]\n            (into xs\n              (filter #(not= false %)\n                      (reduce (fn [ac x]\n                                (into ac (map #(compose x %) xs)))\n                              [] xs))))\n\n          (transclosure [xs]\n            (loop [f (selfcomp xs)\n                   F xs]\n              (if (= f F)\n                f\n                (recur (selfcomp f) f))))]\n    \n    (transclosure ss)))", "user": "51e5a627e4b0efabf93c02db"}, {"problem": 84, "code": "(fn [xs]\n  (letfn [(mjoin [head? xs h t]\n            (let [n (first (keep-indexed (fn [i v] (when (= (if head? h t) v) i)) xs))]\n              (vec\n               (concat\n                (subvec xs 0 n)\n                [h t]\n                (subvec xs (inc n))))))\n          (brels [[h & more]]\n            (if h\n              (into\n               (reduce #(conj % [h %2]) #{} more)\n               (brels more))\n              #{}))]\n    (reduce\n     (fn [s els]\n       (into s (brels els)))\n     #{}\n     (reduce\n      (fn [ans [h t]]\n        (if-let [x (some (fn [x] (when ((set x) h) x)) ans)]\n          (-> ans (disj x) (conj (mjoin true x h t)))\n          (if-let [x (some (fn [x] (when ((set x) t) x)) ans)]\n            (-> ans (disj x) (conj (mjoin false x h t)))\n            (conj ans [h t]))))\n      #{}\n      xs))))", "user": "51852961e4b0da5a5be3babb"}, {"problem": 84, "code": "(fn [s]\n  (let [s' (into s\n                 (for [[a b] s\n                       [c d] s :when (= b c)]\n                   [a d]))]\n    (if (= s' s)\n      s\n      (recur s'))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 84, "code": "(fn [edges]\n  (let [vertices (reduce into #{} edges)\n        adj-for (fn [f] (into {} (for [u vertices]\n                                   [u (into {} (for [v vertices]\n                                                 [v (f u v)]))])))\n        adj (adj-for (fn [u v] (contains? edges [u v])))\n        fadj (reduce (fn [adj k]\n                       (adj-for (fn [u v] (or (get-in adj [u v])\n                                              (and (get-in adj [u k])\n                                                   (get-in adj [k v]))))))\n                     adj vertices)]\n        (into #{} (for [u vertices\n                        v vertices\n                        :let [edge [u v]]\n                        :when (get-in fadj edge)]\n                    edge))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 84, "code": "(fn [relations]\n  (letfn [(new-relations [oldRels new]\n                         (concat (map (fn [x] [(first new) (second x)]) (filter #(= (second new) (first %)) oldRels))\n\t\t\t\t\t\t   (map (fn [x] [(first x) (second new)]) (filter #(= (first new) (second %)) oldRels)))\n\t\t\t\t\t\t   )\n\t\t   (add-relations [oldRels new]\n\t\t\t(concat oldRels [new] (filter #(not (= (first %) (second %)))(new-relations oldRels new)))\n\t\t   )\n\t\t]\n\t\t(into #{} (reduce add-relations #{} relations) ) ))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 84, "code": "(fn [el-set]\n  (loop [result el-set\n         check (reduce conj clojure.lang.PersistentQueue/EMPTY el-set)]\n    (if (empty? check)\n      result\n      (let [new-result (atom result)\n            new-check (atom (pop check))\n            [f s] (peek check)]\n        (doseq [[f' s'] result\n                :when (= f s')]\n          (swap! new-result conj [f' s])\n          (swap! new-check conj [f' s]))\n        (recur @new-result @new-check)))\n    ))", "user": "4dbecb06535d020aff1edf6a"}, {"problem": 84, "code": "(fn [edges]\n  (let [adj (reduce (fn [adj [a b]] (update-in adj [a] conj b)) {} edges)]\n    (loop [closure #{} [edge & tail] (keys adj)]\n      (let [reachable (rest (tree-seq #(adj %) #(adj %) edge))\n            edge-pairs (into #{} (for [r reachable] [edge r]))\n            closure' (clojure.set/union edge-pairs closure)]\n        (if tail (recur closure' tail) closure')))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 84, "code": "(fn [z]\n  (loop [c z\n         p []]\n    (if (= c p) c\n        (recur (apply conj c\n                      (#(for [[a b] % [c d] %\n                              :when (= b c)] [a d]) c)) c))))", "user": "571e6d73e4b0145328a76292"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (let [nodes (->> s\n                   (map first)\n                   set)\n        dfs (fn [n]\n              (tree-seq (constantly true)\n                        (fn children [x]\n                          (->> s\n                               (filter #(= x (% 0)))\n                               (map second)\n                               set))\n                        n))]\n    (->> nodes\n         (map dfs)\n         (map (fn [[h & r]] (map vector (repeat h) r)))\n         (reduce #(apply conj %1 %2) #{}))))", "user": "571d063ee4b0145328a76272"}, {"problem": 84, "code": "(fn [input]\n    (let [iter-func #(clojure.set/union\n                       %\n                       (for [a % b %\n                             :when (= (second a) (first b))]\n                         [(first a) (second b)]) %)\n          iters (iterate iter-func input)]\n      (some #(if (= (first %) (second %)) (first %)) (map vector (next iters) iters))\n  ))", "user": "529e8ba9e4b04e0c58e87b99"}, {"problem": 84, "code": "(fn [s]\n  (let [f (fn [s1 [a b :as c]]\n            (let [m1 (map #(vector (first %) b)  (filter #(= (second %) a) s1))\n                  m2 (map #(vector a (second %))(filter #(= (first %) b) s1))]\n              (-> s1\n                  (into m1)\n                  (into m2)\n                  (conj c))))]      \n  (reduce f #{} s)))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 84, "code": "(fn [relations]\n    (let [rel-map (apply merge-with concat (for [[k v] relations] (assoc {} k (list v))))\n          rec (fn rec [k v]\n                (apply concat\n                       (for [val (rel-map v)]\n                         (conj (rec k val) [k val]))))]\n      (set (mapcat #(rec % %) (keys rel-map)))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 84, "code": "(fn [col]\n  (letfn [(t [s] (into s (mapcat (fn [[a b]] (keep (fn [[c d]] (if (= b c) [a d])) s)) s)))]\n    (loop [[a b & _ :as ts] (iterate t col)]\n      (if (= a b) a (recur (rest ts))))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 84, "code": "(fn transitive-binary [z]\n  (let [binary-chain (fn binary-chain [n m]\n                       (let [inner-binary-chain (fn inner-binary-chain [nn m acc]\n                                                  (if (contains? m nn)\n                                                    (inner-binary-chain (m nn) m (conj acc [n (m nn)]))\n                                                    acc\n                                                    ))]\n                         (inner-binary-chain n m ())))\n        map-binaries (fn map-binaries [s]\n                       (reduce #(assoc %1 (first %2) (second %2)) {} s))\n        ]\n  (into #{} (reduce #(concat (binary-chain (first %2) (map-binaries z)) %1) '() z))))", "user": "56f4cedce4b046a417f92063"}, {"problem": 84, "code": "(fn [a-set]\n  (loop [lset a-set acc a-set]\n    (if (empty? lset)\n      acc\n      (let [[x y] (first lset)\n            add-rels (for [[a b] acc]\n                       (cond\n                         (= y a) [x b]\n                         (= x b) [a y]\n                         :else [x y]))]\n        (recur (rest lset) (into acc add-rels))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 84, "code": "(fn\n  f\n  ([s] (f s s s))\n  ([rs s result]\n   (if\n     (empty? rs)\n     result\n     (let [ffilter #(filter (fn [y] (= (first y) (second (first rs)))) %)\n           fmap #(map\n                  (fn [x] (vector (ffirst rs) (second x))) %)\n           filtered (ffilter s)\n           mapped (fmap filtered)]\n       (recur\n         (if (= (count (ffilter filtered)) 0)\n         (rest rs)\n         (into (rest rs) mapped))\n         s\n         (into\n           result\n           mapped))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 84, "code": "(fn transit\n  [relations]\n  (let [key-map (reduce #(assoc %1 (first %2) (conj (or (get %1 (first %2)) []) (second %2))) {} relations)\n        get-children (fn get-children [key-map ky]\n                       (flatten (let [vals (get key-map ky)\n                                         children (concat vals (map #(get-children key-map %) vals))]\n                                     children)))]\n    (into #{} (for [x (keys key-map)\n                    child (get-children key-map x)]\n                [x child]))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 84, "code": "(fn tc [R]\n          (letfn [(f [priors x R found]\n                  (if (empty? R) found\n                        (let [reach (filter (fn [[a b]] (= a x)) R)\n                              R-reduced (clojure.set/difference R reach)\n                              extended (if (empty? priors)\n                                         (list (list x))\n                                         (map #(cons x %) priors)) ; add x to the path\n                              ]\n                          (if (seq reach)\n                            (apply clojure.set/union (for [[_ y] reach] (f extended y R-reduced\n                                                                           (clojure.set/union found \n                                                                                              (set (apply concat (for [p extended] (for [n p] (list n y)))))))))\n                            found)\n                          ))\n                    )]\n            (apply clojure.set/union\n                   (for [x (set (for [[y _] R] y))]\n                     (f '() x R #{})))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 84, "code": "#(let [m (into {} %)]\n            (reduce (fn [r [k v]]\n                      (let [r (conj r [k v])]\n                        (if (m v)\n                          (recur r [k (m v)])\n                          r)))\n                    #{}\n                    m))", "user": "4fa436dce4b081705acca19b"}, {"problem": 84, "code": "(fn [coll]\n  (let [gc (reduce (fn [m [k v]] (assoc m k (conj (m k []) v))) {} coll)\n        ch (fn ch [k] (cons k (mapcat #(ch %) (gc k))))]\n    (->> (keys gc)\n         (map ch)\n         (mapcat #(map vector (repeat (first %)) (set (rest %))))\n         set)))", "user": "56102f50e4b05f002753df6b"}, {"problem": 84, "code": "(fn [s] (set ((fn build [acc rx] (if (empty? rx) acc \n(let [las (last acc)]\n (if (nil? las)\n    (apply concat (map #(build [%1] (disj rx %1)) rx))\n    (let [[o d] las]\n      (apply concat acc (map #(build (conj acc [o (last %1)]) (disj rx %1)) (filter #(= d (first %1)) rx))))))\n)) [] s)) )", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 84, "code": "(fn [e]\n  (let [kp (fn [x] (keep #(if (= (first %) x) (second %)) e))\n        pair (fn [x s] (for [y s] [x y]))\n        n (remove empty? (mapcat #(pair (first %) (kp (second %))) e))\n        ne (into e n)]\n    (if (= e ne) e (recur ne))))", "user": "574af03ce4b02ea114799202"}, {"problem": 84, "code": "(fn [s]\n    (loop [s1 s]\n      (let [m-fn-1 (fn [i] (filter #(= (second i) (first %)) s1))\n            m-fn-2 (fn [i] (map #(vector (first i) (second %)) (m-fn-1 i)))\n            s2     (clojure.set/union s1 (into #{} (mapcat m-fn-2 s1)))]\n        (if (= s1 s2)\n          s1\n          (recur s2))\n        )\n      )\n    )", "user": "559a9a3de4b066d22e731f45"}, {"problem": 84, "code": "(fn [rel]\n  (loop [closure #{}\n         remaining rel]\n    (if (seq remaining)\n      (let [p1 (first remaining)\n            adding (->> closure\n                        (reduce (fn [adding p2]\n                                  (cond\n                                   (= (second p1) (first p2))\n                                   (conj adding [(first p1) (second p2)])\n                                   (= (second p2) (first p1))\n                                   (conj adding [(first p2) (second p1)])\n                                   :else adding))\n                                #{})\n                        (#(apply disj % closure)))]\n        (recur (apply conj closure p1 adding)\n               (if (seq adding)\n                 (apply conj (rest remaining) adding)\n                 (rest remaining))))\n      closure)))", "user": "575cbe44e4b02ea114799374"}, {"problem": 84, "code": "(fn trans-clojure2 [R]\n  (letfn [(adj-list [R] ;;given relations construct adj-list\n            (reduce #(if (contains? %1 (first %2))\n                       (assoc %1 (first %2) (conj (%1 (first %2)) (last %2)))\n                       (assoc %1 (first %2) [(last %2)])) {}  R))\n          \n          (df-search2 [G v R];;df-search on inicial vertex r. R is a set that contains all vertex that r can reach and v is a reacheable vertex\n            (let [neib (G v)]\n              (reduce #(if (contains? %1 %2)\n                         %1\n                         (clojure.set/union %1 (df-search2 G %2 (conj %1 %2)))) R (G v))))\n\n          (df-search [G] ;;do a df-search for each vertex on graph represented by adj-list\n            (let [ks (keys G)] ;;get the vertices list\n              (reduce #(assoc %1 %2 (df-search2 G %2 #{})) {} ks)))\n          ]\n\n    (let [graph (df-search (adj-list R))\n          ks (keys graph)]\n      (reduce #(apply conj %1 \n                      (map (fn [neib] (vector %2 neib)) (graph %2))) #{} ks))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 84, "code": "(fn trans [xys]\n  (letfn [(union [& sets] (reduce #(into %1 %2) #{} sets) )\n          (transClosure [[x y]] ; Find all z such that x ~ y' ~ z\n                        (loop [reachable #{}\n                               newReachable #{y}]\n                          (if (empty? newReachable) \n                            (set (map (fn toPairs [z] [x z]) reachable)) ; No change\n                            (recur (union reachable newReachable) ; Add newly reachable stuff\n                                   (set (map second (filter (fn reachableFromNew [[y1 z]] (newReachable y1)) xys))))                     \n                            )\n                          )\n                        )]\n    (apply union (map transClosure xys))\n    )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 84, "code": "(fn transitiveClosure [coll]\n  (letfn [(getNext [[a b] pairset]\n                   (let [transitiveRel (filter #(= b (first %)) pairset)]\n                     (if\n                        (empty? transitiveRel) [a b]\n                        [a (second (first transitiveRel))])))]\n\n  (loop [result coll remaining coll]\n    (if\n      (empty? remaining) result\n      (let [current (first remaining)\n            findattempt (getNext current result)] ;;try to find next within results\n        (if\n          (= current findattempt) (recur result (rest remaining)) ;;end of the line\n          (recur (into #{findattempt} result) (into #{findattempt} (rest remaining))))\n          ))\n      ))\n    )", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 84, "code": "(let \n  [ first-dup (fn first-dup \n                ([[x & rest]] (first-dup x rest))\n                ([a [b & rest]] (if (= a b) a (first-dup b rest ) )))\n    ]\n  \n  (fn [s] \n    (first-dup(reductions #(into %1 (for [[a b] %1 [c d] %2 :when (= b c) ] [a d] ))(repeat s)))\n    )\n  \n  )", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 84, "code": "(fn [coll]\n  (letfn [(matches [pair coll]\n            (filter #(= (first %) (second pair)) coll))\n          (paths [pair coll]\n            (loop [q   (conj [] pair)\n                   res []]\n              (if (empty? q)\n                res\n                (let [pair (first q)\n                      q    (rest q)\n                      next (matches pair coll)]\n                  (if (empty? next)\n                    (recur q res)\n                    (recur (into q next) (into res next)))))))]\n    (loop [coll1 coll\n           res   #{}]\n      (if (empty? coll1)\n        res\n        (let [pair      (first coll1)\n              res       (conj res pair)\n              coll1     (set (rest coll1))\n              relations (paths pair coll)\n              new-pairs (map #(vector (first pair) (second %)) relations)]\n          (recur coll1 (if (empty? new-pairs)\n                         res\n                         (into res new-pairs))))))))", "user": "56372c3ce4b0bfe05bf117d1"}, {"problem": 84, "code": "(fn [s]                                                                                                            \n (set (concat s                                                                                                              \n   (apply concat                                                                                                        \n     (for [[h t] s]                                                                                     \n        ((fn recur_tails [h t]                                                                          \n          (let [latest_seconds (filter (fn [[x y]] (= x t)) s)]                                            \n            (concat (map (fn [[x y]] [h y]) latest_seconds)                                                          \n                    (apply concat (map (fn [[x y]](recur_tails h y)) latest_seconds))                                \n                    )                                                                                                   \n            )                                                                                                           \n          ) h t))))))", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 84, "code": "(fn transitive-closure [r]\n  (let [new-r (into r (for [[w x] r [y z] r :when (= x y)]\n                        [w z]))]\n    (if (= new-r r) new-r (recur new-r))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 84, "code": "(fn f-transitive [input]\n (let [sum-set (apply merge (map (partial apply hash-map) input))\n       tmp-res (set (concat (filter last (map (juxt first (comp sum-set last)) input)) input))]\n  (if (= input tmp-res) tmp-res (recur tmp-res))))", "user": "56f974c0e4b07572ad1a88b1"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(expand [m x]\n            (loop [[a b] x\n                   out []]\n              (if-let [b' (m b)]\n                (recur [a b'] (conj out [a b']))\n                out)))]\n    (clojure.set/union s (filter #(not (empty? %)) (mapcat (partial expand (into {} s)) s)))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 84, "code": "(fn l[s]\n  (let[D (fn k[ss](into ss (for [[a b] ss [c d] ss :when (= b c)] [a d])))]\n    (if (= s (D s))\n      s\n      (recur (D s)))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 84, "code": "(fn transclosure [r]\n    (let [k (map first r)\n          v (map second r)\n          m (zipmap k v)]\n      (->> m\n           (iterate (partial map \n                             #(vector (first %)\n                                      (m (second %)))))\n           (take-while #(some identity (map second %)))\n           rest\n           (apply concat)\n           (remove #(nil? (second %)))\n           (into r))))", "user": "579693d4e4b039eba2ecb0e7"}, {"problem": 84, "code": "(fn transclosure [r]\n    (let [k (map first r)\n          v (map second r)\n          m (zipmap k v)]\n      (->> m\n           (iterate (partial map \n                             #(vector (first %)\n                                      (m (second %)))))\n           (take-while #(some identity (map second %)))\n           rest\n           (apply concat)\n           (remove #(nil? (second %)))\n           (into r))))", "user": "5796d308e4b039eba2ecb0ed"}, {"problem": 84, "code": "(fn transclosure [r]\n    (let [k (map first r)\n          v (map second r)\n          m (zipmap k v)]\n      (->> m\n           (iterate (partial map \n                             #(vector (first %)\n                                      (m (second %)))))\n           (take-while #(some identity (map second %)))\n           rest\n           (apply concat)\n           (remove #(nil? (second %)))\n           (into r))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(relate [c1 c2]\n                  (cond\n                   (= (first c1) (second c2)) [(first c2) (second c1)]\n                   (= (first c2) (second c1)) [(first c1) (second c2)]\n                   :else c1))]\n    (loop [p s r s f false]\n      (if (empty? p) \n        (if f r (recur r r true))\n        (recur (rest p) \n               (reduce conj r \n                       (for [x (rest p)]\n                         (relate (first p) x)))\n               f)))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 84, "code": "(fn transclosure [r]\n    (let [k (map first r)\n          v (map second r)\n          m (zipmap k v)]\n      (->> m\n           (iterate (partial map \n                             #(vector (first %)\n                                      (m (second %)))))\n           (take-while #(some identity (map second %)))\n           rest\n           (apply concat)\n           (remove #(nil? (second %)))\n           (into r))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 84, "code": "(fn transclosure [r]\n    (let [k (map first r)\n          v (map second r)\n          m (zipmap k v)]\n      (->> m\n           (iterate (partial map \n                             #(vector (first %)\n                                      (m (second %)))))\n           (take-while #(some identity (map second %)))\n           rest\n           (apply concat)\n           (remove #(nil? (second %)))\n           (into r))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 84, "code": "(fn hull [s]\n  (letfn [(cr-map [s]\n            (reduce (fn [m [k v]] \n                      (update-in m [k] (fnil #(conj % v) [])))\n                    {}\n                    s))\n          (ihull [m this ks]\n            (mapcat #(cons [this %] \n                           (ihull m this (m %))) \n                    ks))]\n    (let [m (cr-map s)]\n      (into #{} \n        (mapcat #(ihull m (key %) (val %))\n                m)))))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 84, "code": "(letfn [(massoc [m k v]\n            ;; Cheapo multimap-like assoc\n            (assoc m k (conj (get m k #{}) v)))]\n    (fn transitive-closure [r]\n      (letfn [(rel->mmap [r]\n                (reduce (fn [acc [a b]] (massoc acc a b)) {} r))\n              (transitive-step [m]\n                (reduce-kv (fn [acc k v]\n                             (assoc acc k\n                                    (apply clojure.set/union v\n                                           (for [w v] (get m w #{})))))\n                           {} m))]\n        ;; This has some fairly woeful inefficiencies; wouldn't want to\n        ;; use this for relations of any significant size.\n        (loop [prev {} curr (rel->mmap r)]\n          (if (= prev curr)\n            (set (for [k (keys curr) v (get curr k)] [k v]))\n            (recur curr (transitive-step curr)))))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 84, "code": "(fn tc\n  ([res ss s]\n   (let [todos (filter #(= (first %) (second s)) ss)]\n     (if (seq todos)\n       (mapcat (fn [t] (tc (concat res [s t]) ss t)) todos)\n       [res])))\n  ([ss]\n   (letfn [(comb [[h & t]]\n             (when (and h (seq t))\n               (concat (map (fn [e] [(first h) (second e)]) t)\n                       (comb t))))]\n     (set (concat ss\n                  (mapcat comb\n                          (mapcat #(tc [] ss %) ss)))))))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 84, "code": "(fn [e]\n  (let [f (memoize (fn [a]\n                     (set (for [[x y] e\n                                :when (= a x)]\n                            y))))\n        g (fn [v]\n            (let [c (count v)\n                  u (reduce into v (map f v))\n                  k (count u)]\n              (if (> k c)\n                (recur u)\n                u)))\n        \n        h (fn [[a b]]\n            (for [c (g #{b})]\n              [a c]))]\n    \n    (set (mapcat h e))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 84, "code": "#(loop [r #{} c %]\n  (if (seq c)\n    (let [[x y] (first c)]\n      (recur\n        (conj\n          (into\n            r\n            (concat\n              (for [[a b] r :when (= b x)] [a y])\n              (for [[c d] r :when (= c y)] [x d])\n              (for [[a b] r :when (= b x) [c d] r :when (= c y)]\n                [a d]))) [x y]) (rest c))) r))", "user": "56ac81ace4b03c432f187347"}, {"problem": 84, "code": "(letfn\n    [(closure [xys]\n        (into \n            xys\n            (for [[x1 y1] xys\n                  [x2 y2] xys\n                  :when (= y1 x2)]\n                  [x1 y2])))\n      (ts [xys]\n        (loop [count-so-far (count xys)\n               step (closure xys)]\n          (if (= count-so-far (count step))\n            step\n            (recur (count step) (closure step)))))]\n    ts)", "user": "57717915e4b0979f896515b3"}, {"problem": 84, "code": "(fn\n  [s]\n  (loop [q (vec s) f #{}]\n    (if (empty? q) \n      f\n      (let [d (second (first q))\n            c (map second (filter #(= (first %) d) s))]\n        (if (.contains (map first s) d)\n          (recur (concat (rest q) (map vector (repeat (count c) (first (first q))) c)) (conj f (first q)))\n          (recur (rest q) (conj f (first q)))))))\n  )", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 84, "code": "(fn find-fixed-point [relations]\n  (letfn [(transitive [relations]\n             (letfn [ ;; Combine two relations if possible\n                     (combine\n                       [[a b]]\n                       (if (= (second a) (first b))\n                         [(first a) (second b)]))\n                     (rels [relations]\n                       (letfn [(rotate [n s] (lazy-cat (drop n s) (take n s)))\n                               (insert [l n e]\n                                 (if (zero? n)\n                                   (cons e l)\n                                   (cons (first l) (insert (rest l) (dec n) e))))]\n                         (distinct\n                          (apply concat\n                                 (map (fn [n]\n                                        (let [s (rotate n (seq relations))]\n                                          (apply concat\n                                                 (map (fn [l]\n                                                        (map #(insert l % (first s))\n                                                             (range 0 2)))\n                                                      (map list (rest s))\n                                                      )))\n                                        )\n                                      (range 0 (count relations))\n                                      )))))]\n               (->> (map combine (rels relations))\n                    (remove nil?)\n                    (apply conj relations)\n                    (set))))]\n\n    (loop [relations relations\n           result (transitive relations)]\n      (if  (= relations result)\n        result\n        (recur result (transitive result))))))", "user": "56903cb9e4b0dcc4269f40eb"}, {"problem": 84, "code": "(fn f [rels]\n  (let [expan (set (concat rels (for [[a b] rels, [c d] rels :when (= b c)] [a d])))]\n    (if (= rels expan) expan (recur expan))))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 84, "code": "(fn myf [coll]\n  (letfn [(sub [coll]\n  (into coll (for [x coll\n                   y coll\n                   :when (= (second x) (first y))]\n               (vector (first x) (second y)))))]\n  (if (= coll (sub coll)) coll\n    (myf (sub coll)))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 84, "code": "(fn [input] (let [as-keyword #(if (keyword? %) % (keyword (str %)))\n                  keyed (apply hash-map (apply concat (map (fn [p] [(as-keyword (first p)) {:val (first p) :link (second p)}]) input)))\n                  routes (map (fn [v]\n                                (println v)\n                                [(key v) (loop [k (as-keyword (:link (val v)))\n                                                routes (list (val v))]\n                                           (println k {:link (get-in keyed [k :link])})\n                                           (if-not (get-in keyed [k :link]) routes\n                                                                 (recur\n                                                                   (as-keyword (get-in keyed [k :link]))\n                                                                   (cons {:val (:val (val v)) :link (get-in keyed [k :link])} routes))))]) keyed)]\n               (into #{} (mapcat (fn [r] (for [k (list (first r))\n                                              v (second r)]\n                                          [(:val v) (:link v)])) routes))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 84, "code": "(fn finalSolution [i] (letfn [(nextOrder [x]\n                                  (loop [res x todo x]\n                                    (let [[a b] (first todo) r (rest todo)]\n                                      (if\n                                        (empty? todo)\n                                        res\n                                        (recur (clojure.set/union res (set (map #(vector a (second %1)) (filter #(= (first %1) b) x)))) r)))))\n                                ](loop\n                          [ latest i]\n                          (let\n                            [c (count latest)\n                             new (nextOrder latest)\n                             newCount (count new)]\n                            (if (= c newCount)\n                              latest\n                              (recur new)\n                              )))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 84, "code": "(fn f [r]\n  (letfn [(p [r]\n             (let [s (for [x r \n                           y r \n                           :when (= (second x) (first y))] \n                       [(first x) (second y)])]\n               (into r s)))]\n    (let [s (p r)]\n      (if (= r s)\n        r\n        (f s)))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(next-links [item]\n            (filter #(= (second item) (first %)) s))\n          (next-closures [item]\n            (map #(vector (first item) (second %)) (next-links item)))\n          (closures-from [item]\n            (loop [heads [item]\n                   results []]\n              (if (= 0 (count heads))\n                results\n                (recur (mapcat next-closures heads) (concat results heads)))))]\n    (set (mapcat closures-from s))\n    ))", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 84, "code": "(let [\n\ttransitize (fn [rel1 rel2] (if (= (second rel1) (first rel2)) [(first rel1) (second rel2)] nil))\n\t]\n\t(let [\n\t\tclosers (fn [relation1 relation2]\n\t\t\t(set (filter #(and (not (nil? %)) (not (relation1 %))) (apply clojure.set/union (for [x relation1 y relation2 :let [x-y (transitize x y) y-x (transitize y x)]] (list x-y y-x)))))\n\t\t\t)\n\t\t]\n\t\t(fn transitive-closure \n\t\t\t([relation1 relation2] (if (empty? relation2) relation1 (let [closure-iterate (closers relation1 relation2)] (transitive-closure (clojure.set/union relation1 closure-iterate) closure-iterate))))\n\t\t\t([relation] (transitive-closure relation relation))\n\t\t\t)\n\t\t))", "user": "57d0fce5e4b0bd073c202364"}, {"problem": 84, "code": "(fn tc\n  ([s] (tc s []))\n  ([s acc]\n   (if (empty? s) (set acc)\n     (let [[k v] (first s)\n           with-new (conj acc [k v])\n           exp-keys (->> with-new\n                         (filter #(= k (second %)))\n                         (map first)\n                         (concat [k]))\n           exp-vals (->> with-new\n                         (filter #(= v (first %)))\n                         (map second)\n                         (concat [v]))\n           expansion (for [xk exp-keys\n                           xv exp-vals]\n                       [xk xv])]\n       (tc\n         (rest s)\n         (into with-new expansion))))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 84, "code": "(fn [s]\n  (let [f (fn [x s]\n            (loop [from (second x) acc #{x}]\n              (let [node (first (filter #(= from (first %)) s))]\n                (if node\n                  (recur (second node) (conj acc [(first x) (second node)]))\n                  acc))))]\n    (reduce #(into %1 (f %2 s)) #{} s)))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 84, "code": "(fn [s]\n  (loop [i s, [h & t] (vec s)]\n    (let [g (for [[al ar] [h], [bl br] t \n                 :let [j (#{ar} bl) k (#{br} al)]\n                 :when (or j k)] \n              (cond j [al br]\n                    k [bl ar]))]\n      (if t (recur (into i g) `[~@t ~@g]) i))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 84, "code": "(fn transitive-closure [rel]\n  (let [nxt (into #{}\n              (for [[x y1 :as r] rel\n                    [y2 z] rel]\n                (if (= y1 y2) [x z] r)))]\n    (if (= nxt rel) rel\n      (recur nxt))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 84, "code": "(fn trans-clousure\n  ([vs] (trans-clousure vs (count vs)))\n  ([vs n] \n    (let [ss \n          (apply conj vs\n                 (for [v1 vs v2 vs :when (= (get v1 1) (get v2 0))]\n                   [(get v1 0) (get v2 1)]))\n          c (count ss)]                \n      (if (= c n)\n        ss\n        (trans-clousure ss c)))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 84, "code": "(fn c84\n  ([s r]\n   (if (empty? s)\n     r\n     (let [f (reduce (fn [x y]\n                        (let [fy (first y)\n                              fyv (get x fy)]\n                          (assoc x fy (if fyv (conj fyv y) [y])))) {} r)\n           v (first s)\n           n (f (second v))]\n       (if n\n         (let [val (map #(vector (first v) (second %)) n)]\n           (c84 (apply conj (next s) val) (apply conj r val)))\n         (c84 (next s) r)))))\n  ([s]\n   (let [l (apply list s)]\n     (c84 l s))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 84, "code": "(fn transclose [x]\n  (let [f (fn [i y] ; find candidates\n            (let [fc (fn [v i y]\n                       (if (empty? y) v\n                        (let [[a b] i\n                              [j & r] y\n                              [c d] j]\n                          (if (= b c)\n                            (recur (conj v j) i r)\n                            (recur v i r)))))]\n              (fc [] i y)))\n        h (fn [ts v]  ; find head of relation\n            (let [ms (set v)\n                  s (apply disj ms ts)\n                  m (into {} s)\n                  ks (set (keys m))\n                  vs (set (vals m))\n                  fh (fn [ks vs]\n                       (if (empty? ks) nil\n                        (let [kh (first ks)\n                              kt (rest ks)]\n                          (if (not (contains? vs kh)) [kh (m kh)]\n                            (recur kt vs)))))]\n              (fh ks vs)))\n        c (fn [th cs] ; close over transitive relation $1:transitive_head $2:candidates\n            (let [cl (fn [v th cs]\n                       (if (empty? cs) v\n                        (let [[a b] th\n                              [[c d] & rcs] cs]\n                          (recur (conj v [a d]) th rcs))))]\n              (cl [] th cs)))\n        r #(and % %2)\n        t (fn [ts x]\n            (let [m (into {} x)\n                  th (h ts m)]\n              (if (nil? th) x\n                (let [l (seq x)\n                      s (set l)\n                      cs (f th l)\n                      cl (c th cs)\n                      b (or (empty? cl)\n                            (reduce r (map (partial contains? s) cl)))]\n                  (if b\n                    (recur (conj ts th) x)\n                    (recur ts (into x cl)))))))]\n    (t #{} x)))", "user": "57d1d6c8e4b0bd073c202370"}, {"problem": 84, "code": "(fn [bin-rel]\n    (let [rel-map (into {} (seq bin-rel))  all-keys (keys rel-map)] (reduce #(letfn [(search-keys [key, mappings] (loop [check key mapped #{}]\n                                                                                                     (if-let [val (mappings check)] (recur val (conj mapped val)) mapped)) )]\n             (apply conj %1 (map (fn [lval] (vector %2 lval) ) (search-keys %2 rel-map)) )                                          \n                                                                        ) #{} all-keys)))", "user": "57c6aa0be4b05aa3c4741cf7"}, {"problem": 84, "code": "(fn [pairs]\n    (let [relation-graph (reduce #(assoc %1 (first %2) (last %2))\n                                 {}\n                                 pairs)\n          antes (keys relation-graph)\n          relations (fn [graph x]\n                      (loop [relations-set []\n                             ante x]\n                        (println ante)\n                        (if-not (contains? graph ante)\n                          relations-set\n                          (recur \n                            (conj relations-set [x (graph ante)])\n                            (graph ante)))))]\n      (set (apply concat (reduce #(conj %1 (relations relation-graph %2))\n              []\n              antes)))))", "user": "57974188e4b039eba2ecb0f4"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(step [ele s]\n            (let [n (filter #(= (second ele) (first %)) s)]\n              (if (seq n)\n                (let [t (map #(vec [(first ele) (second %)]) n)]\n                  (cons ele (mapcat #(step % s) t)))\n                [ele])))]\n    (set (mapcat #(step % s) s))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 84, "code": "(fn p84 [xs]\n  (let \n    [children  \n     (fn c [xs el]\n       (let [c-val  (some #(when (= (second el) (first %)) (second %)) xs)\n             new-el [(first el) c-val]]             \n         (if (nil? c-val)\n            [el]\n            (conj (c xs new-el) new-el))))]             \n    (reduce \n      (fn [sets el] (into sets (concat [el] (children xs el)))) \n      #{} \n      xs)))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 84, "code": "(fn [z]\n  (let [f (fn [x] (mapcat identity (loop [a x b []] (if (empty? a) b (recur (drop 1 a) (conj b (map #(conj [(first a)] %) (rest a))))))))\n      \tg (fn [x] (loop [a x b []] (if (empty? a) b (recur (drop 1 a) (conj b (reduce #(if (= (first %1) (last %2)) (into [] (conj (reverse (into '() %1)) (first %2))) (if (= (last %1) (first %2)) (conj %1 (last %2)) %1)) (into [] (first a)) (into [] (map (partial into []) (rest a)))))))))]\n  \t(into #{}\n          (mapcat identity (map f (g z))))))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 84, "code": "(fn [bset]\n  (let [newset\n    (reduce (fn [result elem]\n              (apply conj result\n                (let [[[f c] toextend] elem]\n                  (reduce (fn [s t]\n                            (if (= (first t) c)\n                              (conj s [f (second t)])\n                              s))\n                          result\n                          toextend))))\n            bset\n            (for [w bset] [w (disj bset w)]))]\n    (if (= newset bset)\n      newset\n      (recur newset))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 84, "code": "(fn xclosure [binrel]\n    (let [fwd (into {}  binrel)]\n      (let [br (into binrel\n        (filter seq (map #(if (fwd (second %))\n                            [(first %) (fwd (second %))] []) binrel)))]\n        (if (= br binrel) br (recur br)))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 84, "code": "(fn transitive-closure [ps]\n    (letfn\n      [\n        (find-pairs-with-a [v]\n          (filter\n            (fn [[a b]]\n              (= a v)\n            )\n            ps\n          )\n        )\n\n        (combine-pair [[a b]]\n          (map\n            (fn [[a' b']]\n              [a b']\n            )\n            (find-pairs-with-a b)\n          )\n        )\n\n        (find-pairs [ps]\n          (set\n            (mapcat combine-pair ps)\n          )\n        )\n      ]\n      (loop\n        [\n          ps ps\n        ]\n        (let\n          [\n            new-ps (find-pairs ps)\n            ps' (clojure.set/union ps new-ps)\n          ]\n          (if\n            (empty? (clojure.set/difference new-ps ps))\n            ps\n            (recur ps')\n          )\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 84, "code": "(fn transitivity [coll]\n               (letfn [(make-map [c]\n                         (loop [remaining c ans '{}]\n                           (if (empty? remaining)\n                             ans\n                             (if (contains? ans (first (first remaining)))\n                               (recur (rest remaining) (update-in ans [(first (first remaining))] conj (second (first remaining))))\n                               (recur (rest remaining) (conj ans [(first (first remaining)) [(second (first remaining))]]))))))\n                       (get-children [k transitivity-map]\n                         (if-not (contains? transitivity-map k)\n                           #{}\n                           (loop [children (get transitivity-map k) ans #{}]\n                             (if (empty? children)\n                               ans\n                               (recur (rest children) (clojure.set/union ans #{(first children)} (get-children (first children) transitivity-map)))))))]\n                 (let [t-map (make-map coll)]\n                   (loop [remaining coll ans #{}]\n                     (if (empty? remaining)\n                       ans\n                       (recur (rest remaining) (apply conj ans (map #(conj [(first (first remaining))] %) (get-children (first (first remaining)) t-map)))))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 84, "code": "(fn [coll]\n  (let [relations (into {} coll)]\n    (letfn \n      [(find-path [src]\n                  (loop [x src paths #{}] \n                    (if-let [dest (get relations x)]\n                      (recur dest (conj paths [src dest]))\n                      paths)))]\n      (reduce clojure.set/union\n              (for [elem (keys relations)] \n                (find-path elem))))))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 84, "code": "reduce #(let [[r1 r2] %2]\n           (clojure.set/union\n              (conj %1 %2)\n              (for [[f s] %1 :when (= f r2)] [r1 s])\n              (for [[f s] %1 :when (= s r1)] [f r2])\n            ))\n          #{}", "user": "576df252e4b0979f8965156f"}, {"problem": 84, "code": "(fn [items]\n  (let [item-map     (reduce (fn [m [k v]]\n                               (update-in m [k] #(conj % v)))\n                             {} items)]\n    (letfn [(descs [nd k]\n              (reduce (fn [nd v] \n                        (if-not (contains? nd v)\n                          (descs (conj nd v) v)\n                          nd))\n                      nd (item-map k)))]\n    (reduce (fn [s k]\n              (into s (map (juxt (constantly k) identity) (descs #{} k))))\n            #{} (keys item-map)))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 84, "code": "(fn [r]\n    (let [t (into r (for [[a b] r [c d] r :when (= a d)] [c b]))]\n      (if (= r t) t (recur t))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 84, "code": "(fn[s](\n  loop[ olds #{} news s](\n  if(= (count olds) (count news)) news\n  (recur news\n\t(set(concat news (filter (fn[i](not(nil? (second i))))\n  (map\n\t(fn[i]\n    [(first i) (get (into (sorted-map)(vec news)) (second i))]\n\t)\n\t(vec news)))))) \n )\n \n))", "user": "56039843e4b04bb52996e1be"}, {"problem": 84, "code": "(fn [coll]\n    (let [fs (set (map first coll))\n          ls (set (map last coll))\n          roots (clojure.set/difference fs ls)\n          children (fn [elt coll] (set (map last (filter #(= elt (first %)) coll))))\n          tree (fn tr [rt coll]\n                 (let [c (children rt coll)]\n                   (if (empty? c)\n                     [rt]\n                     [rt (vec (mapcat #(tr % coll) c))])))\n          trees (map #(tree % coll) roots)\n          pairs (fn ps [[rt ch]]\n                  (if (empty? ch)\n                    nil\n                    (concat (map #(vector rt %) (flatten ch)) (ps ch))))]\n      (set (mapcat pairs trees))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 84, "code": "(fn [s]\n(let [edges (into {} s)\n      dfs (fn [s]\n          (let [root (ffirst s)]\n            (loop [node root\n                   res #{}]\n              (if-let [child (edges node)]\n                (recur child \n                       (conj res [root child]))\n                res))))]\n  (loop [s s\n         res #{}]\n    (if (empty? s)\n      res\n      (recur (rest s) \n             (clojure.set/union res (dfs s)))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 84, "code": "(let [make-map\n      (fn [elems]\n        (reduce (fn [accum [k v]]\n                  (if (contains? accum k)\n                    (assoc accum (conj (accum k) v))\n                    (assoc accum k [v])))\n                {}\n                elems))\n      close-partially\n      (fn [the-map]\n        (into {} (map (fn [[k vs]]\n                        [k (into #{} (mapcat (fn [v] \n                                               (if (contains? the-map v)\n                                                 (conj (the-map v) v)\n                                                 [v]))\n                                             vs))])\n                      the-map)))\n      fixpoint\n      (fn [f x]\n        (loop [current x]\n          (let [new-current (f current)]\n            (if (= current new-current)\n              new-current\n              (recur new-current)))))\n      unmake-map\n      (fn [the-map]\n        (reduce (fn [accum [k vs]]\n                  (into accum (map (fn [v] [k v]) vs)))\n                #{}\n                the-map))]\n  (fn close\n    [elems]\n    (unmake-map (fixpoint close-partially (make-map elems)))))", "user": "58152157e4b0f478707a0631"}, {"problem": 84, "code": "(fn tranz84 [srcrels]\n (letfn [\n  (rs-from [[rb re] rs] \n   (reduce (fn [acc [bb be]] \n     (if (= re bb) \n      (conj acc [rb be]) \n      acc)) #{} rs) )\n  (rels-for [coll ups] \n   (reduce (fn [z b] (into z (rs-from b ups))) #{} coll))\n ]\n  (loop [acc srcrels work srcrels] \n    (let [exrels (rels-for work srcrels) \n    newrels (remove acc exrels)\n     newacc (into acc newrels)]\n  (if (empty? newrels)\n   newacc\n   (recur newacc newrels))\n) )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 84, "code": "(fn my-transitive-closure [ori-s]\n  (letfn [(one-step [s]\n            (->> (for [r s] \n                   (->> (filter #(= (second r) (first %)) s)\n                        (map #(vector (first r) (second %)))))\n                 (apply concat)\n                 (set)\n                 (into s)))]\n    (if (= ori-s (one-step ori-s))\n        ori-s\n        (my-transitive-closure (one-step ori-s)))))", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 84, "code": "#(let [  not-nil? (comp not nil? last)\n         closure (fn [[d k v]] [(dissoc d k) k (d v)] )\n         gen (fn [el] (->> (cons (into {} %) el)\n                       \t   (iterate closure) \n                           (take-while not-nil?)\n                           (map next)))] \n         \n         (into #{} (mapcat gen %))\n)", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 84, "code": "(fn t-closure' [xss]\n  (letfn [(match-fn [item all]\n            (filter #(= (last item)\n                        (first %))\n                    (clojure.set/difference all #{item})))\n          (pair-fn [target matches]\n            (when (seq matches)\n              (map (fn [i] [(first target) (last i)])\n                   matches)))\n          (reduce-fn [pairs]\n            (reduce (fn [accum item]\n                      (let [matches (match-fn item pairs)\n                            paired (pair-fn item matches)]\n                        (if (seq paired)\n                          (apply conj accum paired)\n                          accum))) [] pairs))\n          (builder [pairs]\n            (-> pairs\n                reduce-fn\n                (concat pairs)\n                set))]\n    (loop [yss xss]\n      (let [new-pairs (builder yss)]\n        (if (= (count yss) (count new-pairs))\n          yss\n          (recur new-pairs))))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 84, "code": "(fn [collection]\n    (letfn [(new? [orig-coll]\n              (->> (merge-with (fn [l f]\n                                 (map (fn [fi] (into [l f] (map (fn [li] (vector (first li) (last fi))) l))) f))\n                               (group-by last  orig-coll)\n                               (group-by first orig-coll))\n                   vals\n                   flatten\n                   (partition 2 2)\n                   (map vec)\n                   set\n                   (remove orig-coll)\n                   seq))\n            (recurs [coll]\n              (if-let [k (new? coll)]\n                (recurs (into coll k))\n                coll))]\n      (recurs collection)))", "user": "5256c4c1e4b0541d1855ba36"}, {"problem": 84, "code": "(fn transitive-closure [bin-rel]\n  (loop [rels bin-rel new-rels bin-rel]\n    (if (seq new-rels)\n      (let [xz (for [[x y1] new-rels\n                     [y2 z] rels\n                     :when (= y1 y2)]\n                 [x z])]\n        (recur (into rels (vec xz)) xz))\n      rels)))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 84, "code": "(fn [br]\n  (letfn [(squish [tc]\n            (vector (ffirst tc) (last (last tc))))\n\n          (chains [xs]\n            (chain xs (ffirst xs)))\n\n          (chain [xs lst]\n            (if (empty? xs)\n              '()\n              (if (= lst (ffirst xs)) ;; keeper\n                (cons (first xs) (chain (rest xs) (last (first xs))))\n                '())))] \n    (set\n     (map squish\n          (for [a br\n                b br\n                c br]\n            (chains [a b c]))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 84, "code": "(fn [s]\n    (letfn [(infer [s]\n              (set\n               (concat s (for [[a b] s\n                               [d e] s\n                               :when (= b d)]\n                           [a e]))))]\n      (loop [s1 s s2 (infer s)]\n        (if (= s1 s2) s1\n            (recur s2 (infer s2))))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 84, "code": "(fn [s] ((fn [old s] (if (= old s) s (recur s (clojure.set/union\n                                               s (set (for [[i j] s [k l] s :when (= j k)] [i l])))))) nil s))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 84, "code": "(fn [s]\n  (let [rels (into {} s)]\n    (letfn [(go [k]\n                (if-let [v (rels k)]\n                  (cons [k v]\n                        (->> (go v)\n                             (map second)\n                             (map #(vector k %))))))]\n      (->> (keys rels)\n           (mapcat go)\n           set))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 84, "code": "(fn [i-set]\n  (loop [res-set i-set\n         iter-set (seq i-set)]\n    (if (empty? iter-set)\n      res-set\n      (let [fitem (first (first iter-set))\n            nitem (second (first iter-set))]\n        (recur \n         (reduce (fn [s1 iter]\n                   (if (= nitem (first iter))\n                     (conj s1 [fitem (second iter)])\n                     s1))\n                 res-set\n                 res-set)\n         (rest iter-set))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 84, "code": "(fn trns-cl\n  ([rs] (trns-cl rs rs rs))\n  ([result input rootsToCheck]\n   (if \n     (empty? rootsToCheck) (set result)\n     (let [\n           newRootsToCheck (mapcat #(let [[rootS rootE] %] (map (fn [[_ e]] (vector rootS e)) (filter (partial (fn [[_ x] [y _]] (= x y)) %) input))) rootsToCheck)\n          ]\n       (trns-cl (concat result newRootsToCheck) input newRootsToCheck)\n     )\n   )\n  )\n)", "user": "55357ab5e4b09218d5f44faf"}, {"problem": 84, "code": "(fn [x]\n  (loop [input x, output #{}]\n    (if (empty? input)\n      output\n      (let [i (first input)\n            downstream (->> output\n                            (filter #(= (second i) (first %)))\n                            (map #(vector (first i) (second %)))\n                            set)\n            upstream (->> output\n                          (filter #(= (first i) (second %)))\n                          (map #(vector (first %) (second i)))\n                          set)]\n        (recur (disj input i) \n               (clojure.set/union output \n                                  #{i}\n                                  downstream\n                                  upstream))))))", "user": "58247423e4b051871117bec5"}, {"problem": 84, "code": "(fn [relations]\n  (let [all-items (-> relations vec flatten)\n        below (fn [item]\n                (loop [current-item item\n                       result []]\n                  (let [directly-below  (some (fn [[upper lower]] (if (= upper current-item) lower))\n                                              relations)]\n                    (if directly-below\n                      (recur directly-below (cons [item directly-below] result))\n                      result))))]\n\n    (set (mapcat below all-items))))", "user": "4db86aee535d1e037afb2193"}, {"problem": 84, "code": "(fn [a-set]\n  (let [gen-tr (fn [a-set]\n                 (for [x a-set\n                       y a-set]\n                   (let [[x1 x2] x\n                         [y1 y2] y]\n                     (if (= x2 y1)\n                       [x1 y2]))))\n        tr-cl (fn [a-set]\n                (-> a-set\n                    (into (gen-tr a-set))\n                    (disj nil)))]\n    (if (=\n         (tr-cl a-set)\n         (tr-cl (tr-cl a-set)))\n      (tr-cl a-set)\n      (recur (tr-cl a-set)))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 84, "code": "(fn gen-tc\n   [r]\n   (letfn [(multiply-ee [e1 e2]\n             (if (= (second e1) (first e2))\n               (vector (first e1) (second e2))))\n           (multiply-es [e r]\n             (set (filter (fn [x]\n                            (not (= nil x)))\n                          (map #(multiply-ee e %) r))))\n           (multiply-ss [r1 r2]\n             (apply clojure.set/union (map #(multiply-es % r2) r1)))]\n     (apply clojure.set/union\n            (loop [result [r]]\n              (let [mid-res (multiply-ss (last result) r)]\n                (if (empty? mid-res)\n                  result\n                  (recur (conj result mid-res))))))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 84, "code": "(letfn [(partition-grps [xs]\n          (reduce (fn [a x]\n                    (let [p (first x)\n                          q (second x)\n                          p-grps (group-by #(= (last %) p) a)\n                          q-grps (group-by #(= (first %) q) (p-grps false))\n                          front  (first (q-grps true))\n                          back   (first (p-grps true))\n                          pq-grp (concat (if (nil? back) [p] back)\n                                         (if (nil? front) [q] front))]\n                      (conj (set (q-grps false)) pq-grp))) #{} xs))\n        (pair-wise [s]  \n          (let [x (first s)\n                xs (rest s)]\n            (if (empty? xs) []\n              (concat (map #(vec [x %]) xs)\n                      (pair-wise xs)))))]\n  (fn [xs]\n    (set (apply concat (map pair-wise (partition-grps xs))))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 84, "code": "; rather bad solution since it's retraces a lot. Can be fized by simply memoizing the function iterated over\n(fn closure [relations]\n  (letfn [(to-graph [relations]\n            (loop [[[from to] & r] (seq relations)\n                   acc {}]\n              (let [newacc (update-in acc [from] (fnil conj #{}) to)]\n                (if (seq r)\n                  (recur r newacc)\n                  newacc))))\n          (traverse [graph k]\n            (->> k\n                 graph\n                 (iterate (fn [reachable]\n                            (clojure.set/union reachable (mapcat graph reachable))))\n                 (partition 2 1) ;; keep going until no change.\n                 (some #(when (apply = %)\n                          (first %)))))]\n    (let [graph (to-graph relations)]\n      (set\n       (for [k (keys graph)\n             l (traverse graph k)]\n         [k l])))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 84, "code": "(fn[i]\n    (let [mp (fn [its]\n               (mapcat (fn [d]\n                         (reduce\n                          (fn [r c] (conj r [(first d) (second c)]))\n                          [d]\n                          (filter #(= (last d) (first %)) its)))\n                       its))]\n      (set ((apply comp (repeat (count i) mp)) i)))\n    )", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 84, "code": "(fn\n  [se]\n  (let\n    [one (fn\n           [se1]\n           (for\n             [[a b] se1\n              [m n] se1\n              :when(= b m)]\n             [a n]))]\n    (loop\n      [all se]\n      (let\n        [o-one (set (one all))]\n        (if\n          (empty? (clojure.set/difference o-one all))\n          all\n          (recur\n           (clojure.set/union o-one all)))))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 84, "code": "(fn transitive-closure [relations] \n  (letfn [(closure [element] \n                  (let [s (second element)\n                        others (filter #(not (= element %)) relations)\n                        related (filter #(= s (first %)) others)\n                        first-relations (map #(vector (first element) (second %)) related)]\n                    (concat first-relations (mapcat closure first-relations))))]\n      (set (concat relations (mapcat closure relations)))))", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 84, "code": "(fn [s0]\n  (loop [s s0]\n    (let [pairs (mapcat identity (for [[w x] s] (for [[y z] s] (if (= x y) [w z] false))))\n          expansion (set (clojure.set/union s (set (filter identity pairs))))]\n      (if (= expansion s)\n        s\n        (recur expansion)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 84, "code": "(fn [edges]\n  (letfn [(find-edge [start edges]\n            (first (filter #(= start (first %)) edges))\n            )\n          (transitive-edges [graph edges]\n            (let [edge (find-edge (last graph) edges)]\n              (if (nil? edge) (map #(vector (first graph) %) (rest graph))\n                  (recur (conj graph (second edge)) edges))\n              )\n            )\n          ]\n    (into #{} (mapcat #(transitive-edges [(first %)] edges) edges))\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 84, "code": "(fn\n  [rels]\n  (loop [prevc (reduce #(conj %1 [(first %2) [(second %2)]]) {} rels)]\n    (let [newc (merge\n                 prevc\n                 (into {} (map (fn [[k vs]] (vector k (distinct (flatten (into vs (map prevc (filter prevc vs))))))) prevc)))]\n      (if (= prevc newc)\n        (into #{} (mapcat (fn [[k vs]] (map #(vector k %) vs)) newc))\n        (recur newc)))))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 84, "code": "(fn [s] (apply hash-set\n         (let [val-map (apply hash-map (flatten (vec s)))\n          find-relations (fn find-relations [key]\n                           (let [result (get val-map key)]\n                           (if result\n                             (lazy-seq (cons result (find-relations result))))))]\n      (reduce (fn [coll item]\n                (concat coll (map (fn [x]\n                       [item x]) (find-relations item))))\n              #{} (keys val-map)))))", "user": "586b6753e4b01531a375e956"}, {"problem": 84, "code": "(letfn [(chains [links]\n            (loop [chain (first links) r (disj links chain) res []]\n              (let [f (first chain) l (peek chain)\n                    [u v :as link] (some (fn [[u v :as c]] (when (or (= l u) (= v f)) c)) r)]\n                (cond\n                  link (recur (if (= l u) (conj chain v) (into [u] chain)) (disj r link) res)\n                  (not-empty r) (recur (first r) (disj r (first r)) (conj res chain))\n                  :default (conj res chain)))))\n          (unroll [chain]\n            (loop [[f & r] chain res #{}]\n              (if (not-empty r) (recur r (into res (map (fn [a] [f a]) r))) res)))]\n    (fn [links]\n      (reduce into #{} (map unroll (chains links)))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 84, "code": "(fn [relations]\n  (let [update (fn [m k f] (assoc m k (f (get m k))))\n        build-graph (fn [relations]\n                      (loop [[[r s] & rs :as all] (seq relations)\n                             g {}]\n                        (if (empty? all)\n                          g\n                          (recur rs (update g r #(into #{s} %))))))\n        traverse (fn t [graph cur]\n                   (if (not (contains? graph cur))\n                     [cur]\n                     (concat [cur] (mapcat #(t graph %) (get graph cur)))))\n        get-relations (fn [graph root]\n                        (let [[x & xs] (traverse graph root)]\n                          (map #(vector x %) xs)))\n        graph (build-graph relations)\n        roots (keys graph)]\n    (reduce #(into %1 (get-relations graph %2)) #{} roots)))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 84, "code": "(fn transitive-closure [da-relations]\n  (letfn [(add-rel-map [old-map a-set]\n            (reduce (partial merge-with into) old-map\n                    (map #(hash-map (first %) (hash-set (second %)))\n                         a-set)))\n          (filter-relations [func rel-map]\n            (into {}\n                  (filter #(seq (second %))\n                          (map #(vector (first %) (set (filter func (second %))))\n                               rel-map))))\n          (update-single-relation [[ori dest-set] rel-map]\n            [ori (reduce #(apply conj %1 %2 (get rel-map %2)) #{} dest-set)])\n          (extract-relations  [[ori dest-set]]\n            (reduce #(into %1  (vector(vector ori %2))) #{} dest-set))]\n    \n   (loop [to-be-examined (add-rel-map {} da-relations)\n          relations-map {}]\n     (let [da-vals (reduce into #{}  (vals to-be-examined))\n           da-keys (set (keys to-be-examined))\n           base-cases (clojure.set/difference da-vals da-keys)\n           new-relations  (filter-relations base-cases to-be-examined)\n           further-relations (filter-relations (comp not base-cases)\n                                               to-be-examined)\n           all-relations (into relations-map\n                               (map #(update-single-relation % relations-map)\n                                    new-relations))]\n       (if (seq further-relations)\n         (recur further-relations all-relations)\n         (reduce #(into %1 %2) (map extract-relations all-relations)))))))", "user": "580d2788e4b0849f6811b730"}, {"problem": 84, "code": "(fn transitive-closure [relations]\n  (let [new-relations (for [[a x] relations [y b] relations :when (= x y)] [a b])\n        updated-relations (into relations new-relations)]\n    (if (= updated-relations relations)\n      updated-relations\n      (recur updated-relations))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 84, "code": "(fn [s]\n  (let [m (into {} s)]\n    (reduce-kv (fn [acc k v]\n                 (if-let [val (get m v)]\n                   (recur (conj acc [k v] [k val])\n                          k val)\n                   (conj acc [k v])))\n               #{} m)))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 84, "code": "(fn [r]\n  (let [r (reduce (fn [m [k v]] (update-in m [k] conj v)) {} r)]\n    (->> r\n      keys\n      (mapcat\n        (fn f [x]\n          (->> (r x)\n            (mapcat f)\n            (map second)\n            (concat (r x))\n            (map vector (repeat x)))))\n      set)))", "user": "50479524e4b0371827a27bc4"}, {"problem": 84, "code": "(fn [s]\n  (->> (iterate #(into % (for [[u v] % [w x] % :when (= v w)] [u x])) s)\n         (partition 2 1)\n         (drop-while (fn [[u v]] (< (count u) (count v))))\n         (first)\n         (first)))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 84, "code": "(fn [data]\n  (let [dataset (into {} data)]\n  (reduce\n   (fn [coll [k v]]\n     (conj coll [k v])\n     (if (nil? (dataset v))\n       (conj  coll [k v])\n       (recur (conj coll [k v])  [k (dataset v)])))\n   #{}\n   dataset)))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 84, "code": "(fn [pairs] (let [append-pair (fn [pair paths]\n                                (vec (map #(if (= (first pair) (last %)) (conj % (last pair)) \n                                               (if (= (last pair) (first %)) \n                                                 (vec (cons (first pair) %)) %)) paths)))\n                  update-paths (fn update-paths \n                                 ([pair paths] (#(if (= paths %) (conj paths pair) %) \n                                                (append-pair pair paths)))\n                                 ([pairs] (reduce #(update-paths %2 %1) [] pairs)))\n                  path-to-rels (fn path-to-rels\n                                 ([path rels] (if (empty? (rest path)) rels \n                                                  (path-to-rels (rest path) \n                                                                (concat rels \n                                                                        (map #(vector (first path) %) \n                                                                             (rest path))))))\n                                 ([path] (path-to-rels path [])))\n                  paths-to-rels (fn [paths] (mapcat path-to-rels paths))]\n              (set (paths-to-rels (update-paths pairs)))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 84, "code": "(fn [xs]\n  (letfn [\n        (tcl [rel]\n  (let [t (group-by first rel)]\n    (loop [rel rel res #{}]\n      (if (empty? rel)\n        res\n        (let [[f s :as r] (first rel)]\n          (recur (rest rel)\n                 (apply conj res r (map #(vector f (second %)) (get t s)))))))))]\n  (tcl (tcl xs))))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 84, "code": "(fn [edges]\n  (let [adj-list (reduce (fn [agg [x y]]\n                           (merge-with into agg {x #{y}})) {} edges)\n        vs (into #{} (keys adj-list))\n        linked-cmp (fn ch [v adj-list visited]\n                     (if (empty? adj-list)\n                       visited\n                       (->> (for [v-adj (adj-list v)\n                                  :when (not (visited v-adj))]\n                              (ch v-adj (dissoc adj-list v) (into visited [v v-adj])))\n                            (reduce into visited))))\n\n        vs-cmp (for [v vs]\n                 [v (disj (linked-cmp v adj-list #{}) v)])]\n\n    (reduce (fn [agg [v cmp]]\n              (into agg (map #(vector v %) cmp))) #{} vs-cmp)))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 84, "code": "(fn [s] (reduce (fn [c1 x]\n                  (reduce (fn [c2 y]\n                            (if (= (x 0) (y 1))\n                              (conj c2 [(y 0) (x 1)])\n                              c2))\n                          c1\n                          (vec c1)))\n                s\n                (vec s)))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 84, "code": "(fn transitive-closure [relation-set]\n  (letfn [(transitive-list [relation-map key] \n            (let [values (get relation-map key [])]\n              (cons key (mapcat #(transitive-list relation-map %) values))))]\n    (let [relation-map (into {} (for [[key value] (group-by first relation-set)] [key (mapv second value)]))]\n      (set (mapcat #(map vector (repeat %) (rest (transitive-list relation-map %))) (keys relation-map))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 84, "code": "(fn transitive-closure [coll]\n     (loop [counter (count coll)\n            acc coll]\n       (if (= 0 counter)\n         acc\n         (recur \n           (dec counter)        \n             (set\n               (concat acc (remove nil? \n                                   (for [i acc\n                                         j acc]\n                                      (if (= (last i) (first j))\n                                        [(first i) (last j)])))))))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 84, "code": "(fn [l]\n  (let [m (reduce (fn [a [k v]]\n                    (merge-with concat a {k [v]}))\n                  {} l)]\n    (loop [p (map vector (keys m)) t #{}]\n      (if (empty? p) t\n        (let [p (reduce (fn [q l]\n                          (into q (reduce #(conj % [(first l) %2])\n                                          [] (get m (last l)))))\n                        #{} p)]\n          (recur p (into t p)))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 84, "code": "(fn [pair-set]\n  (letfn\n    [(f1 [[layered ori]] (vector (into #{} (for [x layered y ori] (if (= (last x) (first y)) (conj x (last y)) x))) ori))\n     (f2 [pair-set] (first (nth (iterate f1 [pair-set pair-set]) (count pair-set))))\n     (f3 [lnk] (let [idx-lnk (map-indexed vector lnk)] (for [x idx-lnk y idx-lnk :when (< (first x) (first y))] (vector (last x) (last y))))) ]\n    (into #{} (mapcat f3 (f2 pair-set)))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 84, "code": "(fn txclosure\n  ([pairs]\n   (into pairs\n         (mapcat #(txclosure pairs %) pairs)))\n  ([pairs [top cur]]\n   (let [nodes (filter #(= cur (first %)) pairs)]\n     (concat (map #(identity [top (second %)]) nodes)\n             (mapcat #(txclosure pairs [top (second %)]) nodes)))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 84, "code": "(fn f [s]\n  (#(if (= % s) s (f %))\n   (set (for [[a b] s [c d] s]\n\t  [a (if (= b c) d b)]))))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 84, "code": "(fn t [coll] (let [relations (into {} coll)] (letfn [(find-path [src] (loop [x src paths #{}] (if-let [dest (get relations x)] (recur dest (conj paths [src dest])) paths)))] (reduce clojure.set/union (for [elem (keys relations)] (find-path elem))))))", "user": "5919d209e4b09b4ee5954bcc"}, {"problem": 84, "code": "(fn [start-set]\n  (let [bin-rel (fn [x y]\n                  (cond\n                    (= x y) x\n                    (= (nth x 0) (nth y 1)) [(nth y 0) (nth x 1)]\n                    (= (nth x 1) (nth y 0)) [(nth x 0) (nth y 1)]\n                    :else false))\n        next-set (set (for [x start-set\n                            y start-set\n                            :let [z (bin-rel x y)]\n                            :when z]\n                        z))]\n    (if (= start-set next-set) start-set (recur next-set))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 84, "code": "(fn transitive-closure [pairs]\n  (let [reach-from\n        (fn [pair pairs]\n          (let [q (atom (clojure.lang.PersistentQueue/EMPTY))]\n            (swap! q conj (second pair))\n            (loop [paths (group-by first pairs)\n                   from (first pair)\n                   to (peek @q)\n                   trace (list [[from to]])]\n              (if-not (empty? @q)\n                ;; continue walking\n                (let [dests (get paths to)]\n                  (swap! q pop)\n                  (when-not (nil? dests)\n                    (apply swap! q conj (map second dests)))\n                  (recur (dissoc paths to)\n                         to\n                         (peek @q)\n                         (if-not (nil? dests)\n                           (cons dests trace)\n                           trace)))\n                ;; process walked trace\n                (->> (loop [trace (reverse trace)\n                            reach []]\n                       (if (>= (count trace) 2)\n                         (let [[start & trace] trace]\n                           (recur trace\n                                  (->> (for [end trace]\n                                         [start end])\n                                       (apply conj reach))))\n                         reach))\n                     (mapcat\n                      (fn [[start end]]\n                        (for [s start e end]\n                          [(first s) (last e)])))\n                     (into #{}))))))]\n    (->> (for [pair pairs] (reach-from pair pairs))\n         (apply clojure.set/union)\n         (clojure.set/union pairs)\n         )))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 84, "code": "(fn [s]\n    (let [n (apply conj s (for [i s j s :when (= (second i) (first j))]\n                            [(first i) (second j)]))]\n      (if (= s n) n\n                   (recur n))\n\n      )\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 84, "code": "(fn [xs]\n   (let [relations-graph (reduce (fn [init-map vec]\n                                   (assoc init-map vec (filter #(= (first %) (last vec)) xs))) {} xs)\n         get-closure (fn get-closure [v]\n                       (reduce (fn [init-set x]\n                                 (apply conj\n                                        init-set\n                                        (map #(vector (first v) (last %)) (get-closure x))))\n                               #{v}\n                               (get relations-graph v)))]\n     (reduce (fn [init-set v]\n               (apply conj init-set (get-closure v)))\n             #{} xs)))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 84, "code": "(fn [coll]\n  (reduce (fn  [result e]\n            (let  [c2 (filter #(= (last e) (first %)) result)]\n              (if ((complement empty?) c2)\n                (reduce #(conj %1 (conj [] (first e) (last %2)))\n                        result c2)\n                result))) coll coll))", "user": "5823d3e6e4b051871117beb8"}, {"problem": 84, "code": "(fn floyd-warshall\n\t[pairs]\n\t(let [\n\t\tvertices \n\t\t\t(distinct (flatten (apply list pairs)))\n\t\tare-connected \n\t\t\t(fn [dists x y] (or (= x y) (dists [x y])))\n\t\tare-connected-through \n\t\t\t(fn [dists k i j] (or (are-connected dists i j) (and (are-connected dists i k) (are-connected dists k j))))]\n\t\t(reduce\n\t\t\t(fn [result [k i j]] (if (and (not= i j) (are-connected-through result k i j)) (conj result [i j]) result))\n\t\t\tpairs\n\t\t\t(for [k vertices i vertices j vertices] [k i j]))))", "user": "58fb7d7ae4b0438e51c2cf7a"}, {"problem": 84, "code": "(fn transit [s]\n  (let [find-trans (fn find-trans [pair l]\n                     (cond\n                       (empty? l) #{}\n                       (= (first pair) (last (first l)))\n                        (conj (find-trans pair (rest l)) [(first (first l)) (last pair)])\n                       (= (last pair) (first (first l)))\n                        (conj (find-trans pair (rest l)) [(first pair) (last (first l))])\n                       :else\n                        (find-trans pair (rest l))))]\n    (let [news ((fn transit-sub [s l]\n       (cond\n         (empty? l) s\n         :else (clojure.set/union (transit-sub s (rest l)) (find-trans (first l) s)))) s s)]\n      (cond\n        (> (count news) (count s)) (transit news)\n        :else news))))", "user": "5833a6d8e4b089d5ab817ca2"}, {"problem": 84, "code": "(fn [s]\n  (let [trans (fn [l]\n                (loop [tmps s a #{}]\n                  (if (empty? tmps)\n                    a\n                    (if (= (last l) (first (first tmps)))\n                      (recur (rest tmps) (conj a (conj (conj [] (first l)) (last (first tmps)))))\n                      (recur (rest tmps) a))))) create (fn [s2]\n                                                         (loop [tmp s2 a s]\n                                                         \t\n      (if (empty? tmp)\n        (set a)\n        (recur (rest tmp) (concat a (trans (first tmp)))))))]\n    (loop [a s c (count s)]\n      (if (= c (count (create a)))\n        a\n        (recur (create a) (count (create a)))))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 84, "code": "(fn [x]\n   (let [tr (fn [a b] (filter #(= (last a) (first %1)) b))\n         r (fn [a b] (seq (map #(vector (first b) (second %)) (tr b (disj a b)))))]\n     (reduce #(if (r %1 %2) (apply conj %1 (r %1 %2)) %1) x x)))", "user": "5910a43de4b0163c97b36ebf"}, {"problem": 84, "code": "(fn trans [c]\n  (if (empty? c)\n    #{}\n    (let [sub (trans (rest c))\n          cur (first c)\n          tos (filter #(= (second %) (first cur)) sub)\n          tosl (conj (set (apply concat tos)) (first cur))\n          fromt (filter #(= (first %) (second cur)) sub)\n          fromtl (conj (set (apply concat fromt)) (second cur))]\n      (clojure.set/union sub (set (for [x tosl y fromtl] [x y]))))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 84, "code": "(fn [rels]\n  (let [parent->child (into {} rels)]\n    (reduce (fn [new-rels parent]\n              (loop [child    (parent->child parent)\n                     new-rels new-rels]\n                (if child\n                  (recur (parent->child child)\n                         (conj new-rels [parent child]))\n                  new-rels)))\n            #{}\n            (keys parent->child))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 84, "code": "(fn [binary-relations]\n    (let [m  (into {} binary-relations)\n          f (fn [relations]\n              (reduce (fn [acc [a b]]\n                        (let [pair (when (and (m b) (not= a (m b))) [a (m b)])]\n                          (if (or (nil? pair) (contains? relations pair)) acc\n                              (conj acc pair)))) #{} relations))]\n      (loop [acc binary-relations]\n        (let [tc (f acc)]\n          (if (empty? tc) acc\n              (recur (clojure.set/union tc acc)))))))", "user": "595bbab7e4b066ee0a44afe0"}, {"problem": 84, "code": "(fn tc [rs]\n  (apply clojure.set/union\n    (for [rel rs\n          :let [n (first rel) fep (second rel)]]\n          \n          (loop [endpts [fep] out #{}]\n                (if-let [x (first endpts)]\n                  (recur (into (subvec endpts 1) (map second (filter #(= x (first %)) rs))) (conj out [n x]))\n                  out)))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 84, "code": "(fn [xs]\n  (reduce\n    (fn [ret [x y]]\n      (loop [one #{[x y]}, nret #{}, [h & t :as oret] (seq ret)]\n        (cond \n          (empty? oret) \n              (into nret one)\n          (= (h 1) x)\n              (recur (conj one [(h 0) y]) (conj nret h) t)\n          (= (h 0) y)\n              (recur (conj one [x (h 1)]) (conj nret h) t)\n          :else  \n              (recur one                       (conj nret h) t))))\n    xs xs))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 84, "code": "(fn [items]\n  (letfn [(createPairs [parent matches] (reduce (fn [acc [p c]] (conj acc [parent c])) #{} matches))\n          (trace [acc parent child]\n            (let [matches (filter (fn [[p c]] (= p child)) items)]\n              (if (empty? matches)\n                acc\n                (mapcat (fn [[p c]] (trace (conj acc [parent c]) parent c) ) matches))))]\n    (set (mapcat (fn [[p c]] (trace [[p c]] p c)) items))) )", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 84, "code": "(fn [edges]\n  (letfn [(helper [xs]\n            (let [temp (filter (fn [[u v]] (= (last xs) u)) edges)]\n              (if (empty? temp)\n                #{xs}\n                (map (fn [[u v]] (concat xs [v])) temp))))\n          (finish [xs]\n            (if (= 2 (count xs))\n              #{xs}\n              (into #{} (map (fn [y] [(first xs) y]) (rest xs)))))]\n    (loop [prev edges]\n      (let [next (into #{} (mapcat helper prev))]\n        (if (= prev next)\n          (into #{} (mapcat finish prev))\n          (recur next))))))", "user": "53e91473e4b036ad0777e495"}, {"problem": 84, "code": "(fn [divides]\n   (letfn [(f [p cp]\n             (into #{}\n                   (filter\n                     #(not (nil? %))\n                     (map (fn [d] (if (= (second p) (first d))\n                                    [(first p) (second d)]\n                                    (if (= (second d) (first p))\n                                      [(first d) (second p)]))) cp))))]\n     (loop [r #{} c divides]\n       (if (empty? c)\n         r\n         (let [fe (first c)\n               m (f fe (next c))]\n           (recur (into (conj r fe) m) (into (next c) m)))\n         ))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 84, "code": "(fn bt[s] (\n            letfn [ (fnd[kp all] (\n                                   reduce #(\n                                               if (= (last kp) (first %2))\n                                               (conj %1 [(first kp) (last %2)])\n                                               %1\n                                               ) [] all\n                                     ))\n                      (al[all sx] (\n                                    \n                        if (empty? sx)\n                            (set all)\n                         (al (concat all (fnd (first sx) all)) (rest sx))\n                      ))\n                    ]\n             \n             \n             (al s (vec s))\n\n           ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 84, "code": "(fn closure [relation]\n  (let [new-relations (for [p relation\n                            q (disj relation p)\n                            :when (= (second p) (first q))\n                            :let [r (vector (first p) (second q))]\n                            :when (not (contains? relation r))]\n                        r)]\n    (if (empty? new-relations)\n      relation\n      (recur (into relation new-relations)))))", "user": "569f99cce4b0542e1f8d1497"}, {"problem": 84, "code": "(fn tran\n  ([s] (tran (into {} s) s #{}))\n  ([m to-add result]\n    (if (empty? to-add)\n      result\n      (tran\n       m\n       (reduce\n        (fn [s [a b]]\n          (if (m b)\n            (conj s [a (m b)])\n            s))\n        #{} \n        to-add)\n       (into result to-add)))))", "user": "598ab445e4b02b9968b84ce0"}, {"problem": 84, "code": "(fn [X]\n     (letfn [(path-from [MR k L]  \n               (if (not (nil? (MR k)))\n                   (path-from MR (MR k) (conj L k))\n                   (conj L k)))           \n             (rel-vecs [V]\n               (if (= [] V)\n                   nil\n                   (concat (map #(vector (first V) %) (rest V)) (rel-vecs (rest V)))))\n             (paths [S] \n               (let [M (into {} S)\n                     L (map #(path-from M % []) (keys M))\n                     P (mapcat #(rel-vecs %) L)\n                     LP (map #(into [] %) P)]\n                     (into #{} LP)))]\n\n     (paths X)))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 84, "code": "(fn [in-set]\n          (reduce \n            (fn [acc [start stop :as tuple]]\n              (let [ news (reduce (fn [a2 [s1 s2 :as t]]\n                                    (cond (= start s2) (conj a2 [ s1 stop])\n                                          (= s1 stop)  (conj a2 [ start s2])\n                                          :default  a2\n                                          )\n                                    )\n                                  [tuple]\n                                  acc) ]\n                (reduce (fn [a3 t] (conj a3 t)) acc news)))\n            #{}\n            in-set))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 84, "code": "(letfn [\n  (transitions [transitive rels k1 k2] \n    (cond\n      (empty? rels) transitive\n      (contains? transitive (first rels)) (recur transitive (rest rels) k1 k2)\n      (= (first (first rels)) k2) \n        (recur \n          (set (concat transitive #{(first rels) [k1 (last (first rels))]})) \n          (rest rels) \n        k1 k2)\n      :else\n        (recur transitive (rest rels) k1 k2)\n    )\n  )]\n  \n  #(loop [counter 0 prev nil rels %]\n    (if (or (>= counter (count %)) (= rels prev))\n      rels\n      (recur  \n        (inc counter) rels (apply clojure.set/union (for [r1 rels :let [k1 (first r1) k2 (last r1)]] (transitions #{r1} rels k1 k2)))\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 84, "code": "; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 84, "code": "(letfn [(graph-from-relation [relation]\n      (let [vertices (into []\n                           (reduce (fn [acc [source target]]\n                                   (conj acc source target))\n                                   #{}\n                                   relation\n                           )\n                     )\n           edges (for [source vertices]\n                      (map #(contains? relation [source %]) vertices)\n                 )\n           ]\n           { :vertices vertices, :edges edges}\n      )\n)\n\n(relation-from-graph [graph]\n      (let [vertices (get graph :vertices)\n           edges (get graph :edges)\n           edges' (flatten edges)\n           all-vertex-pairs (for [head vertices tail vertices] [head tail])\n           ]\n           (->> (map vector edges' all-vertex-pairs)\n                (reduce (fn [acc [has-edge? relation]]\n                            (if has-edge? (conj acc relation) acc)\n                        )\n                        #{}\n                )\n           )\n      )\n)\n\n(matrix-or [matrix1 matrix2]\n      (map (fn [row1 row2]\n               (map #(or %1 %2) row1 row2)\n           )\n           matrix1\n           matrix2\n      )\n)\n\n(warshall [graph]\n      (let [vertices (get graph :vertices)\n            n (count vertices)\n            edges (get graph :edges)]\n           (loop [k 0 R edges]\n                 (if (= n k)\n                     { :vertices vertices :edges R }\n                     (let [R2 (for [i (range 0 n)]\n                                   (map #(and (nth (nth R i) k) %)\n                                        (nth R k)\n                                   )\n                              )\n                          ]\n                          (recur (inc k)\n                                 (matrix-or R R2)\n                          )\n                     )\n                 )\n          )\n     )\n)]\n  (fn [relation] (relation-from-graph (warshall (graph-from-relation relation)\n                                      )\n                 )\n  )\n\n)", "user": "5990fcb9e4b0866487ed0d5b"}, {"problem": 84, "code": "(fn transitive-set [s]\n  (loop [relations s]\n    (let [transitions \n      (reduce (fn [transitive el]\n        (into transitive (reduce (fn [a b]\n          (if (= (second b) (first el)) (conj a [(first b) (second el)]) a)\n        ) #{} (remove #{el} relations)))\n        )\n      relations\n      relations\n      )\n    ]\n    (if (= (count relations) (count transitions)) transitions (recur (into relations transitions)))\n    )\n  ) \n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "59358f74e4b04f87174def52"}, {"problem": 84, "code": "(fn transitive-clojure [relation]\n  (letfn [(construct-map [relation]\n                         (reduce (fn [acc [k v]] (if (contains? acc k)\n                                                   (assoc acc k (conj (get acc k) v))\n                                                   (assoc acc k #{v})))\n                                 {}\n                                 relation))\n          (add-transitives [rel-map key]\n                           (loop [vs (get rel-map key)\n                                  res vs]\n                             (if (empty? vs) \n                               (assoc rel-map key res)\n                               (let [additional (get rel-map (first vs) #{})]\n                                 (recur (clojure.set/union (set (rest vs)) additional)  (clojure.set/union res additional))))))\n          (construct-relation [rel-map]\n                              (set (reduce (fn [val coll] (concat val coll)) [] \n                                      (for [[k v] (seq rel-map)]\n                                        (map (fn [v1] [k v1]) v)))))]\n          (let [rel-map (construct-map relation)]\n            (construct-relation (reduce (fn [rel-map k]\n                                          (add-transitives rel-map k))\n                                        rel-map\n                                        (keys rel-map))))))", "user": "57ca95f2e4b05aa3c4741d3b"}, {"problem": 84, "code": "(fn \n  [s]\n  (let [upv (fn \n              [[k1 v1]]\n              (fn\n                [st [k2 v2]]\n                (if (= k1 v2)\n                  (conj st [k2 v1])\n                  st)))\n        s1 (reduce #(reduce (upv %2) %1 %1) s s)]\n    (if (= s s1) s1 (recur s1))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 84, "code": "(fn tc\n  ([pairs]\n   (set (mapcat #(tc % pairs) pairs)))\n  ([[a b] pairs]\n   (concat [[a b]]\n           (map #(assoc % 0 a)\n                (mapcat #(tc % pairs) (filter #(= b (first %)) pairs))))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 84, "code": "(fn __ [s]\n  (letfn [(generate-binary-relations\n            ([s] (generate-binary-relations s #{}))\n            ([s acc]\n             (if (empty? s)\n               acc\n               (let [[num denom] (first s)\n                     tail (rest s)\n                     pre  (->> acc\n                               (filter #(= num (last %)))\n                               first)\n                     post (->> acc\n                               (filter #(= denom (first %)))\n                               first)]\n                 (cond\n                   pre\n                   (recur tail (-> acc (disj pre) (conj (conj pre denom))))\n\n                   post\n                   (recur tail (-> acc (disj post) (conj (cons num post))))\n\n                   :else\n                   (recur tail (conj acc (first s))))))))]\n\n  (->> s\n      generate-binary-relations ; #{[8 4 2] [27 9 3]}\n      (mapcat\n       (fn all-perms [[x & xs]]\n         (if x\n           (concat\n            (mapv #(vector x %) xs)\n            (all-perms xs))\n           [])))\n      set)))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 84, "code": "(fn [links]\n    (let [on-links\n          (fn [node links] (filter #(= (first %) node) links))\n          one-step-links\n          (fn [link links]\n            (let [on-links (on-links (second link) links)]\n                 (loop [ons on-links one-steps []]\n                       (if (empty? ons)\n                           one-steps\n                           (recur\n                             (rest ons)\n                             (conj one-steps [(first link) (second (first ons))]))))))\n          next-step\n          (fn [links]\n            (set (mapcat #(conj (one-step-links % links) %) links)))]\n        (loop [closure links]\n              (let [next-closure (next-step closure)]\n                   (if (= closure next-closure)\n                       closure\n                       (recur next-closure))))))", "user": "5a21d34ce4b0ff51aa4b32b9"}, {"problem": 84, "code": "(fn __ [se]\n  (letfn [(subStep [[f t] items]\n            (reduce (fn [acc [f2 t2]]\n                      (if (= t f2)\n                        (conj acc [f t2])\n                        acc\n                        ))\n                    #{}\n                    items))\n          (oneStep [items]\n            (clojure.set/union items (apply clojure.set/union (map #(subStep % items) items))))\n          ]\n          (let [\n                res (loop [x1 '()\n                           x2 se]\n                      (if (== (count x1) (count x2))\n                        x2\n                        (recur x2 (oneStep x2))))\n                ]\n                res)))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 84, "code": "(fn [tuples]\n   (let [m (into {} tuples)]\n     (letfn [(transitive-closures [a b]\n               (if b\n                 (cons [a b] (transitive-closures a (m b)))\n                 '()))]\n       (set (mapcat (fn [[o _]]\n                      (transitive-closures o (m o))) tuples))\n       )))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 84, "code": "(fn transAll [yss] ;yss set of vec of 2\n   (letfn [\n  \n     (trans [xs ys]  ;xs ys vector of 2 ele\n    (let [x1 (first xs) x2 (last xs)\n          y1 (first ys) y2 (last ys)\n          ]\n\n          (cond (= x2 y1) [x1 y2]\n               ; (= x1 y2) [y1 x2]\n                :else []\n          )\n      )\n )\n\n (trans1n [xs yss]\n  (letfn [(fr [res hs pss ]\n            (let [ps1 (first pss) rps (rest pss)]\n               (if ps1\n                   (let [transvec (trans hs ps1)]\n                     (if (> (count transvec) 0)\n                        (recur (conj res (trans hs ps1)) hs rps )\n                        (recur res hs rps)\n                     )\n                   )\n                 res\n                 )\n                )\n\n            )]\n       (fr #{} xs yss)\n    )\n)\n          \n  \n           \n           ]\n  \n    (loop [i 0 k 0 xss yss]\n\n       (let [ys (nth  (vec xss) i)\n             nss (trans1n ys xss)]\n          (if (= k (count xss))\n             xss\n             (if (> (count nss) 0)\n                (let [uset (clojure.set/union xss nss)]; \n                  (if (> (count uset) (count xss))\n                     (recur (mod (inc i) (count uset)) 0 uset )\n                     (recur (mod (inc i) (count xss)) (inc k) xss )\n                  )\n                  \n                 )\n                (recur (mod (inc i) (count xss)) (inc k) xss)\n              )\n          )\n        )\n)))", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 84, "code": "(fn f [l]\n    (let [n (mapcat\n              (fn [[o x]]\n                (mapcat\n                  (fn [[f s]]\n                    (if (= f x)\n                      [[o s]]\n                      []))\n                  l))\n              l)\n          m (apply conj l n)]\n      (if (= l m)\n        m\n        (f m))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 84, "code": "(fn [s]\n   (loop [tc s sc #{}]\n      (if (= tc sc)\n         tc\n         (recur (clojure.set/union tc\n                   (for [[k v] tc [k1 v1] tc :when (= v k1)]\n                        [k v1]))\n                 tc))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 84, "code": "(fn [edge_set]\n  (let [compute_adjacency_map (fn c_a_m [a_edge_set o_adjacency_map]\n                                (if (empty? a_edge_set)\n                                  o_adjacency_map\n                                  (let [[e_start e_end] (first a_edge_set)\n                                        remaining_edges (rest a_edge_set)]\n                                    (c_a_m remaining_edges\n                                           (assoc o_adjacency_map\n                                                  e_start\n                                                  (conj (get o_adjacency_map e_start #{}) e_end))))))\n        compute_transative_closure (fn c_t_c [orig_vertex curr_vertex adjacency_map]\n                                     (if (= orig_vertex curr_vertex)\n                                         #{[orig_vertex curr_vertex]}\n                                         (let [curr_vertex_adjacency (get adjacency_map curr_vertex #{})]\n                                           (conj (reduce clojure.set/union\n                                                   (map (fn [x] (c_t_c orig_vertex x adjacency_map))\n                                                        curr_vertex_adjacency))\n                                                 [orig_vertex curr_vertex]))))\n        adjacency_map (compute_adjacency_map edge_set {})] \n    (reduce clojure.set/union (map (fn [[e_start e_end]]\n                                     (compute_transative_closure e_start e_end adjacency_map))\n                                   edge_set))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 84, "code": "(fn [x]\n  (let [ks (reduce #(into % %2) #{} x)]\n    (reduce\n      (fn [c k]\n        (into c (for [i ks j ks\n                      :when (and\n                              (not= i j)\n                              (not= i k)\n                              (not= k j)\n                              (c [i k])\n                              (c [k j]))]\n                     [i j])))\n      x ks)))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 84, "code": "(fn \n  [rel]\n  (letfn [(some? [x] (not (= nil x)))\n          (to-set [pairs]\n  \t\t\t(set (filter some? (apply concat pairs))))\n          (tc  [relation]\n  \t\t\t\t(to-set (for [p relation]\n                          (map (fn [[q1 q2]]\n                                 (let [[p1 p2] p]\n                                   (cond (= q1 p2) [p1 q2]\n                                         (= q2 p1) [q1 p2]\n                                         :else nil)))\n                               relation))))\n          (transitive-closure [relation]\n                              (let [new-pairs (tc relation)]\n                                (if (clojure.set/subset? new-pairs relation) \n                                  relation\n                                  (transitive-closure (into relation new-pairs)))))]\n    (transitive-closure rel)))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 84, "code": "(fn [s] (let [f (fn f [a] (let [ws (filter #(= a (first %)) s)]\n                               (concat ws (map (fn [[_ b]] [a b]) (mapcat #(f (second %)) ws)))))]\n  (into #{} (mapcat #(f (first %)) s)) ))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 84, "code": "(fn [rels]\n  (letfn [(only-2nd [m]   (into {}\n                                (for [[k vs] m]\n                                  [k (map second vs)])))\n          (lessants [m x] (concat (m x) (flatten\n                                        (map (partial lessants m)\n                                              (m x)))))]\n    (let [rels-map (only-2nd (group-by first rels))]\n      (set\n        (for [k (keys rels-map)\n              l (lessants rels-map k)]\n          [k l])))))", "user": "56aad4f7e4b03c432f187338"}, {"problem": 84, "code": "(fn tclosure [rel]\n  (let [textension\n         (fn [rel] (for [[a b] rel\n                         [c d] rel\n                         :when (and (= b c) (not= a c))]\n                        [a d]))]\n    (loop [r rel]\n      (let [er (into r (textension r))]\n        (if (= er r)\n            r\n            (recur er))))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 84, "code": "(fn [edges]\n    (let [\n          adj-matrix\n          (loop [m {}\n                 [[a b] & edges] (vec edges)]\n            (let [m* (assoc m a (conj (m a) b))]\n              (if edges\n                (recur m* edges)\n                m*)))\n\n          v-closure\n          (fn v-closure [m v]\n            (if (m v)\n              m\n              (if-let [adj (adj-matrix v)]\n                (let [m* (reduce v-closure m adj)]\n                  (assoc m* v (reduce #(concat % (m* %2)) adj adj)))\n                (assoc m v ()))))\n\n          adj-closure\n          (loop [m {}\n                 to-visit (set (keys adj-matrix))]\n            (if (empty? to-visit)\n              m\n              (let [m* (v-closure m (first to-visit))]\n                (recur m* (clojure.set/difference to-visit (set (keys m*)))))))]\n\n      (reduce\n        (fn [r [a s]]\n          (reduce #(conj % [a %2]) r s))\n        #{} adj-closure)))", "user": "5a536cf2e4b05d388ecb6c10"}, {"problem": 84, "code": "(fn transitive-closure [bin]\n  (loop [before #{} after bin]\n    (if (= before after)\n      after\n      (recur\n       after\n       (apply conj after (#(for [[x a] % [b y] % :when (= a b)] [x y]) after)))))\n  )", "user": "5a621702e4b0512ff01cd983"}, {"problem": 84, "code": "(fn [br]\n    (letfn\n        [(nodes [br]\n           (into #{} (flatten (into [] br))))\n         (path-pairs [path]\n           (for [a path\n                 b path]\n             [a b]))\n         (children [br k]\n           (keep (fn [[a b]] (when (= a k) b)) br))\n         (new-pairs [br set-of-existing-pairs parent]\n           (remove (partial contains? set-of-existing-pairs)\n                   (for [a [parent]\n                         b (children br parent)]\n                     [a b])))\n         (new-pairs-children [br set-of-existing-pairs parent]\n           (map second (new-pairs br set-of-existing-pairs parent)))\n         (chains\n           ([br]\n            (map #(chains br #{} [] %) (nodes br)))\n           ([br pairs path k]\n            (let [pairs (if (seq path)\n                          (reduce conj pairs\n                                  (map #(vector % k)\n                                       path))\n                          pairs)        ; <-- first iter only\n                  path (conj path k)]\n              (if-let [ks (seq (new-pairs-children br pairs k))]\n                (reduce\n                 (fn [pairs k0]\n                   (clojure.set/union pairs (chains br pairs path k0)))\n                 ;; init value for when there is just one child\n                 (clojure.set/union pairs (chains br pairs path (first ks)))\n                 (next ks))\n                pairs))))\n         (gen-trans-closure [br]\n           (into #{} (apply concat (chains br))))]\n        (gen-trans-closure br)))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (loop [s s\n         res #{}]\n    (if (seq s)\n      (let [hd (first s)\n            new-s (reduce\n                   #(cond (= (second hd) (first %2))\n                          (conj %1 [(first hd) (second %2)])\n                          (= (first hd) (second %2))\n                          (conj %1 [(first %2) (second hd)])\n                          :else %1)\n                   #{}\n                   (rest s))]\n        (recur (clojure.set/union new-s (rest s)) (conj res hd)))\n      res)))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 84, "code": "(fn gen-transitive-closure\n  [relations]\n  (let [graph (into {} relations)]\n    (loop [current (first relations)\n           remaining (disj relations current)\n           closure relations]\n      (if current\n        (let [next-val (get graph (second current))\n              next (when next-val [(first current) next-val])\n              next-remaining (disj remaining current)\n              next-current (if next\n                             next\n                             (first next-remaining))\n              next-closure (if next\n                             (conj closure next)\n                             closure)]\n          (recur\n            next-current\n            next-remaining\n            next-closure))\n        closure))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 84, "code": "(fn [r]\n    (letfn [(z [R S] (for [[a b] R [c d] S :when (= b c)] [a d]))\n            (w [f x] (let [y (f x)] (if (= x y) x (w f y))))]\n    (w #(into % (z % r)) r)))", "user": "59da6480e4b0ef0a1e9b5c68"}, {"problem": 84, "code": "(fn [pair-set]\n  (loop [pairs   (seq pair-set)\n         closure #{}]\n    (if (empty? pairs)\n      closure\n      (let [[[a b] & tail] pairs\n            preds (cons a\n                        (for [[x y] closure :when (= y a)] x))\n            succs (cons b\n                        (for [[x y] closure :when (= x b)] y))\n            new-pairs (for [x preds y succs] [x y])]\n        (recur tail (clojure.set/union closure (set new-pairs)))))))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 84, "code": "(fn[in]\n        (loop [tuples in]\n          (let [res\n                (clojure.set/union tuples \n                                   (into #{} (for [a tuples b tuples \n                                                   :when (= (second a) (first b))] \n                                               [(first a) (second b)])))]\n            (if (= res tuples) \n              res\n              (recur res))))\n        )", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 84, "code": "(fn [xs]\n(let [ f1 (fn [e coll] (filter #(= (first %) (second e) ) coll))\n\t   f2 (fn [e coll] (map #(vec [(first e) (second %)]) (f1 e coll)))\n\t   f3 (fn [coll] (reduce  #(reduce conj %1 (f2 %2 coll)) coll coll))\n\t   ret (f3 xs)]\n\t\t\t(if(= xs ret) xs  (recur ret))))", "user": "532dbd3ce4b019098a6f8b40"}, {"problem": 84, "code": "(fn transitive-clojure\n  [rels]\n  (let [transitives (fn f [k rels known]\n                      (set (for [[x y] rels\n                                 :when (= x k)\n                                 :when (not (known y))\n                                 z (cons y (f y rels (conj known y)))]\n                             z)))]\n    (set (for [k (set (map first rels))\n               t (transitives k rels #{})]\n           [k t]))))", "user": "57617c20e4b0994c1922fb8c"}, {"problem": 84, "code": "(fn [rel]\n  (let [trans (fn [kv1 kv2]\n                (if (= (first kv1) (second kv2)) [(first kv2) (second kv1)]))\n        perm (fn [rel] (for [m1 rel m2 rel :when (trans m1 m2)] (trans m1 m2)))]\n    (into rel (perm (into rel (perm rel))))))", "user": "4e8768f6535dceadca469850"}, {"problem": 84, "code": "(fn make-graph [s]\n  (let [uniq (set (reduce #(concat %1 %2) [] s))\n        filter-line (fn [vertex] (->> s\n                                      (filter (fn [[begin]] (= begin vertex)))\n                                      (map #(last %1))))\n        graph (reduce #(assoc %1 %2 (filter-line %2)) {} uniq)\n        dfs (fn [start-node graph]\n              (loop [stack [start-node]\n                     paths []]\n                (if (empty? stack)\n                  paths\n                  (let [node (first stack)\n                        nodes (get graph node)]\n                    (if (empty? nodes)\n                      (recur (rest stack) paths)\n                      (let [next-stack (concat nodes (rest stack))]\n                        (recur next-stack\n                               (->> nodes\n                                    (map #(vector start-node %))\n                                    (concat paths)))))))))]\n    (set (reduce #(concat %1 (dfs %2 graph)) [] uniq))))", "user": "58fed70de4b0438e51c2cfdd"}, {"problem": 84, "code": "(fn [coll]\n  (letfn [(extend-rules [rule-set]\n            (for [[a b] rule-set\n                  [c d] rule-set\n                  :when (= b c)]\n              [a d]))]\n    (loop [res coll]\n      (let [extend-res (into res (extend-rules res))]\n        (if (= extend-res res)\n          res\n          (recur extend-res))))))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 84, "code": "(letfn [(->maps [[k v]] (assoc {} k #{v}))\n        (->vecs [[k v]] (map #(vec [k %]) v))]\n  (fn closure \n    ([s] (closure {} (apply merge-with into (map ->maps s))))\n    ([previous latest]\n     (if (= latest previous)\n       (set (mapcat ->vecs latest))\n       (recur latest (->> (mapcat ->vecs latest)\n                          (map (fn [[k v]] [k (latest v)]))\n                          (mapcat ->vecs)\n                          (map ->maps)\n                          (apply merge-with into latest)))))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 84, "code": "(fn [initial]\n  (letfn [(propagate [knowledge]\n            (into knowledge \n                  (for [[k v] knowledge\n                        [k2 v2] knowledge\n                        :when (= v k2)]\n                    [k v2])))]\n    (->> initial\n      (iterate propagate)\n      (partition 2 1)\n      (some #(when (apply = %) %))\n      (first))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 84, "code": "(fn [s] (let [t (->> s (mapcat (fn [p] (->> s (filter (fn [pt] (= (p 1) (pt 0)))) (map (fn [pt] [(p 0) (pt 1)]))))) set)] (if (clojure.set/subset? t s) s (recur (clojure.set/union s t)))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 84, "code": "(fn __\n  [relations]\n  (loop [remaining-iterations (count relations)\n         relations relations]\n    (if (zero? remaining-iterations)\n      relations\n      (recur\n        (dec remaining-iterations)\n        (clojure.set/union relations\n              (for [i relations\n                    j relations\n                    :when (= (second i) (first j))]\n                (vector (first i) (second j))))))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 84, "code": "(fn to-stationary\r\n  [relations]\r\n  (let\r\n   [f (fn [relations]\r\n        (into relations\r\n              (filter #(not (nil? %)) (for [[ax ay] relations\r\n                                  [bx by] relations]\r\n                              (when (= ay bx) [ax by])))))]\r\n    (loop\r\n        [accumulate relations\r\n      last-relations nil]\r\n      (if (= accumulate last-relations)\r\n        accumulate\r\n        (recur (f accumulate) accumulate)))))", "user": "583048d9e4b051871117c007"}, {"problem": 84, "code": "(fn transitive-closure [r]\n  (let [tclose (fn [relation] (into relation\n                                    (for [[ax ay] relation\n                                          [bx by] relation\n                                          :when (= ay bx)]\n                                      [ax by])))]\n    (loop [acc r\n           previous-r nil]\n      (prn \"acc \" acc)\n      (prn \"previous \" previous-r)\n      (if (= acc previous-r)\n        acc\n        (recur (tclose acc) acc)))\n    )\n  )", "user": "59f44189e4b0966464fe6aab"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(r [s u v]\n            (mapcat\n              (fn [[a b]]\n                (if (= a v)\n                  (conj (r s u b) [u b])))\n              s))]\n    (->>\n      (mapcat\n        (fn [[u v]]\n          (conj (r s u v) [u v]))\n        s)\n      (filter identity)\n      (set))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 84, "code": ";\u3042\u3063\u3066\u308b\u306e\u304b\uff1f\u610f\u5473\u304c\u308f\u304b\u3089\u3093\n(fn [s]\n  (let [news (for [[a b] s [c d] s :when (= b c) :when (not (contains? s [a d]))] [a d])]\n    (if (empty? news)\n      s\n      (recur (into s news)))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (letfn [(find-transitions [f]\n            (loop [c f\n                   trans []]\n              (if-let [n (second (first (filter #(= (first %) c) s)))]\n                (recur n (conj trans [f n]))\n                trans)))]\n    (reduce\n      (fn [coll [f _]]\n        (apply conj coll (find-transitions f)))\n      #{}\n      s)))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 84, "code": "(fn tranjitive-clojure [mappings]\n  (let [more (->> mappings\n                  (mapcat (fn [[x y]]\n                            (->> mappings\n                                 (map (fn [[x' y']]\n                                        (when (= x' y) [x y'])))\n                                 (remove nil?)))))]\n    (if (seq (remove mappings more))\n      (recur (into mappings more))\n      mappings)))", "user": "5afc0f30e4b0cc2b61a3bcfe"}, {"problem": 84, "code": "(fn foo [x]\n       (let [new\n             (clojure.set/difference\n              (into #{} (reduce clojure.set/union\n                                (map (fn [el1] (map (fn [el2] [(first el1) (second el2)])\n                                                    (filter (fn [el2] (= (first el2) (second el1))) x)))\n                                     x)))\n              x)]\n         (if (empty? new) x (foo (reduce #(conj %1 %2) x new)))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 84, "code": "(fn [more-legs] (let [tmp (filter (fn [e] (< 1 (count e))) (for [i more-legs] (distinct (reduce (fn [x y] (if (= (first x) (last y)) (concat y x) x)) i more-legs)))) func (fn f [coll] (let [fs (first coll) r (rest coll)] (when (not (empty? r)) (concat (map (fn [x] [fs x]) r) (f r)))))] (set (mapcat func tmp))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 84, "code": "(fn [x]\n  (let [g (group-by first x)\n        f (fn f [l] (let [r (map last (g l))] (concat r (mapcat f r))))]\n    (set (mapcat #(map (partial vector %) (f %)) (keys g)))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 84, "code": "(fn  trans-closure\n  ([g] (into #{} (mapcat #(trans-closure g %) g)))\n  ([g e]\n   (let [[u v] e\n         adj (filter #(= (first %) v) g)\n         v-closed (mapcat #(trans-closure g %) adj)\n         u-closed (for [x v-closed] [u (second x)])]\n     (into #{} (concat [e] u-closed v-closed)))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 84, "code": "(fn tc [s] (let [upd (fn [s] (set (mapcat (fn [el1] (mapcat (fn [el2] (if (= (first el1) (second el2)) (list el1 el2 (vector (first el2) (second el1))) (if (= (first el2) (second el1)) (list el1 el2 (vector (first el1) (second el2))) (list el1 el2)))) s)) s)))\n                 updated (upd s)]\n         (if (= s updated) updated (tc updated))))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 84, "code": "(fn transitive-closure [rel]\n  (let [compr (fn [rel1 rel2]\n                (set (for [[a b] rel1 [c d] rel2 :when (= b c)] [a d])))\n        powers (iterate #(compr rel %) rel)]\n    (apply clojure.set/union (take-while not-empty powers))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 84, "code": "(fn [graph]\n  (let [nodes (set (apply concat graph))\n        path (fn path [src dest visited]\n               (or (= src dest)\n                   (let [v (into visited [src])]\n                     (some #(and (not (v %)) (graph [src %]) (path % dest v)) nodes))))]\n    (set (mapcat (fn [src] (map (fn [dest] [src dest])\n                                (filter #(and (not= src %) (path src % #{})) nodes)))\n                 nodes))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 84, "code": "#(let [f (fn [[x y] ac c]\n            (let [i (c y)]\n              (if (nil? i) ac (recur [x i] (conj ac [x i]) c))))]\n    (reduce (fn [a b] (apply conj a (f b #{b} (into {} %)))) #{} %))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 84, "code": "#(loop [s %]\n  (let [n (into s\n           (for [[a b] s [c d] s \n                 :when (= b c)] \n            [a d]))]\n    (if (= n s) n (recur n))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 84, "code": "(fn [tuples]\n  ;; 'group-by first' is an easy way to get a map of adjacency lists from\n  ;; the tuple set (which is want we want for running graph algorithms).\n  (let [G (group-by first tuples), nodes (keys G)]\n    (->> nodes\n      (map\n        ;; This is a run-off-the-mill DFS on a graph, starting at the 'root'\n        ;; node.  We repeat this for all nodes in the graph.  In the course\n        ;; of a traversal, we collect the transitive hull for the given root\n        ;; node.\n        (fn [root]\n          ;; The 'processing' vector is an explicit stack; it can be avoided\n          ;; in a recursive implementation, but then we would have to keep\n          ;; the other state in some place.  Here we use 'recur' to gather\n          ;; the result state, including the processing stack.\n          (loop [discovered #{root}, processing [root], hull #{}]\n            (if (empty? processing)\n              hull\n              ;; The 'neighbors' are the adjacency list, which contains\n              ;; the relation tuples. We are only interested in the second\n              ;; member of the tuple (which is the actual neighbor).\n              (let [v (peek processing), neighbors (map peek (G v))]\n                (recur\n                  (into discovered neighbors) \n                  (into (pop processing) (remove discovered neighbors))\n                  ;; The 'hull' does not contain elements that are pointing\n                  ;; to themselves.\n                  (if (= root v) hull (conj hull [root v]))))))))\n      (reduce into #{}))))", "user": "5b772ad7e4b047b03b2036e8"}, {"problem": 84, "code": "(fn [rel]\n    (let [m (into {} rel)]\n      (reduce (fn [a x]\n                (loop [y (m x) r #{}]\n                  (if (nil? y)\n                    (clojure.set/union a r)\n                    (recur (m y) (conj r [x y])))))\n              #{}\n              (keys m))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 84, "code": "(fn tc [rels]\n  (let [{:keys [nodes rel-map]}\n        (reduce\n         (fn [m [from to]]\n           (-> m\n               (update-in [:nodes] conj from to)\n               (update-in [:rel-map from] (fnil conj #{}) to)))\n         {:nodes #{}\n          :rel-map {}}\n         rels)]\n    (into #{}\n          (mapcat\n           (fn [node]\n             (loop [nds #{node}\n                    rm rel-map\n                    rels #{}]\n               (if (empty? rm)\n                 rels\n                 (let [rm-sel (select-keys rm nds)]\n                   (if (empty? rm-sel)\n                     rels\n                     (recur\n                      (into nds\n                            (apply concat\n                                   (vals rm-sel)))\n                      (apply dissoc rm nds)\n                      (into rels\n                            (for [[n rs] rm-sel\n                                  r rs\n                                  nn (cons n nds)]\n                              [nn r]))))))))\n           nodes))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 84, "code": "(let [individual-closure\n        (fn [departure relations]\n          (loop [unvisited [departure]\n                 visited #{}]\n            (let [nextd (first unvisited)\n                  matched (filter #(= nextd (first %)) relations)\n                  new-destinations (map second matched)\n                  combined-destinations (concat (rest unvisited) new-destinations)\n                  visited (conj visited nextd)\n                  unvisited (remove visited combined-destinations)]\n              (if (empty? unvisited)\n                (map #(vector departure %) (remove #(= departure %) visited))\n                (recur unvisited visited)))))]\n    \n    #(into #{} (mapcat (fn [departure] (individual-closure departure %))\n                       (distinct (map first %)))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 84, "code": "(fn rels [pairset]\n   (let [trans (for [[key val] pairset\n                     [valkey valval] pairset\n                     :when (= val valkey)]\n                 [key valval])\n         extended-pairset (into pairset trans)]\n\n     (if (= pairset extended-pairset)\n       pairset\n       (recur (into pairset trans)))))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 84, "code": "(fn transitive-clojure\n  [transitive-sets]\n  (let [transitive-mapping (into {} transitive-sets)\n        generate-all-transitive-pairing (fn transitive-pairing [[y t]]\n                                          (let [t-m (transitive-mapping t)]\n                                            (if-not t-m\n                                              #{}\n                                              (conj (transitive-pairing [y t-m]) [y t-m]))))]\n    (reduce #(clojure.set/union %1 #{%2} (generate-all-transitive-pairing %2)) #{} transitive-sets)))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 84, "code": "(fn [pairs] (let [extended \n                  (into pairs \n                        (for [[a b] pairs [c d] pairs :when (= b c)] \n                          [a d]))]\n              (if (= extended pairs) pairs (recur extended))))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 84, "code": "(fn trans [coll]\n  (reduce into #{}\n    (for [item (map first coll)]\n    (loop \n      [unVisited (map second (filter #(= item (first %)) coll))\n      relate '()]\n      (if (empty? unVisited)\n        relate\n        (recur \n              (into (rest unVisited) \n                (map second (filter #(= (first unVisited) (first %)) coll\n                ))) \n              (conj relate [item (first unVisited)])))))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 84, "code": "(fn m [r]\n  (let [n (into r (remove nil? (for [[a b] r [c d] r] (if (= b c) [a d]))))]\n    (if (= r n) n (m n))))", "user": "5bbf0a02e4b07a9b28b0ffcf"}, {"problem": 84, "code": "(fn tc [relation]\n  (let [m (into {} relation)]\n    (->> (for [k (keys m)]\n           (loop [ck k s #{}]\n             (if-let [v (m ck)]\n               (recur v (conj s [k v]))\n               s)))\n      (reduce into))))", "user": "59d8f23ae4b0ef0a1e9b5c49"}, {"problem": 84, "code": "(fn [pairs]\n      (let [one2many\n            ;could have replaced with (reduce {} ...)\n            (loop [one2many {} ;from item => #{to item...} for all transient closures from 'from item' so far\n                   more pairs]\n              (let [[from to :as pair] (first more)\n                    ; abc2xyz are sets; from and to as per above;\n                    ; orig means an applicable subset of original source/target items\n                    ; new means a (potentially) new subset of source/target items\n                    from2orig (get one2many from #{})\n                    one2manyPlusDirect (conj one2many [from (conj from2orig to)])\n                    \n                    to2orig   (get one2many to #{})\n                    \n                    from2new (conj to2orig to) ;new items that will be connected from 'from' and from all items already connected to 'from'\n                    \n                    ;_ (dbg-println :from from :to to :from2orig from2orig :one2manyPlusDirect one2manyPlusDirect :to2orig to2orig :from2new from2new)\n                    one2manyUpdated (into {}\n                                      (map\n                                        (fn [[source targets]]\n                                          ;(println :source source :targets targets)\n                                          [source\n                                           (if (or\n                                                   (= source from)\n                                                   (contains? targets from))\n                                             (clojure.set/union targets from2new)\n                                             targets)])\n                                        one2manyPlusDirect))\n                    others (next more)]\n                (if others\n                  (recur one2manyUpdated others)\n                  one2manyUpdated)))]\n        (println :one2many one2many)\n        (reduce\n          (fn [res [from targets]]\n            ;(dbg-println :reduce-> res from targets)\n            (let [joined\n                  (apply conj\n                    res\n                    (map\n                      #(vector from %)\n                      targets))]\n              (println :joined joined) \n              joined))\n          #{}\n          one2many)))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 84, "code": "(fn transitive-closure\n  [relations]\n  (let [related? (fn [rel1 rel2] (= (second rel1) (first rel2)))\n        linked-relations (fn [rel]\n                           (->> relations\n                                (filter (partial related? rel))\n                                (map (fn [r] [(first rel) (last r)]))\n                                (cons rel)))]\n    (let [rels (set (mapcat linked-relations relations))]\n      (if (= rels relations)\n        rels\n        (recur rels)))))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 84, "code": "(fn __ [as]\n  (let [\n        am\n        ;; convert to hash-map { k #{vals} }\n        (reduce\n         #(assoc %1 (first %2)\n                 (conj (get %1 (first %2) #{})\n                       (second %2)))\n         {} as)\n\n        ;; convert to set\n        htos\n        (fn [h]\n          (reduce #(into %1\n                         (map (fn [v] [(first %2) v])\n                              (second %2)))\n                  #{} h))\n\n        ;; expend every value\n        expend\n        (fn [m]\n          (apply merge  ; compose a new hash as result\n                 (map (fn [k]\n                        ;; lookup every value in keys of m and merge them into result hash-map r\n                        (hash-map k\n                                  (into (get m k) ; concat existing value of k and expendations\n                                          (mapcat #(get m %) (get m k)) ; values (set) of key k\n                                          )))\n                      (keys m))))\n        ]\n    (htos\n     (loop [tr am]\n       (let [etr (expend tr)]\n         (if (= tr etr) tr\n           (recur etr)))))))\n\n\n; mfike's much nicer solution:\n; (fn [r]\n;   (let [r' (into r\n;                  (for [[a b] r\n;                        [c d] r :when (= b c)]\n;                    [a d]))]\n;     (if (= r r')\n;       r\n;       (recur r'))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 84, "code": "(fn [x]\n(letfn [(trns [s1 s2] (set (for [x s1 y s2 :when (= (last x) (first y))] [(first x) (last y)])))]\n (loop [init x new x]\n   (if (empty? new) init\n     (recur (clojure.set/union init new) (clojure.set/union (trns init new) (trns new init))\n      )\n    )\n )\n  \n  )\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 84, "code": "(fn [s]\n  (let [f1 (fn f1 [[a b]] (filter #(= b (first %)) s))\n         f (fn f [ x y]\n             (if (empty? y)\n               (set (list x))\n               (list\n                (if ((set x) (first y))\n                  (set (list x))\n                  (f (conj x (first y)) (f1 (first y))))\n                (f x (rest y)))))\n        r1 (map #(first %) (filter #(>= (count (first %)) 2) (flatten (map #(f (vector %) (f1 %)) s))))\n        tr (fn tr [x r]\n             (let [fr (first x)\n                   re (rest x)]\n               (if (< (count re) 1)\n                 (partition 2 (flatten r))\n                 (tr re (cons r (reduce #(conj % (vector (first fr) (second %2))) [] re))))))\n        s1 (set (map #(into [] %) (partition 2 (flatten (map #(tr % []) r1)))))]\n    (clojure.set/union s s1)))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 84, "code": "(letfn [\n    (f [[a1 a2 :as a] [b1 b2 :as b]] (if (= a2 b1) #{[a1 b2]} #{}))\n    (m [col e] (reduce into col (map #(f e %) col)))\n    (binr [s] (reduce m s s))]\nbinr)", "user": "580c8fcee4b0849f6811b721"}, {"problem": 84, "code": "(fn problem-84\n  [pairs]\n  (let [rel\n        (->> pairs\n             (reduce (fn [a [l r]]\n                       (update-in a [l] (fnil conj #{}) r))\n                     {}))\n        rel\n        (->> rel\n             (iterate (fn [rel*]\n                        (reduce-kv (fn [rel** k vs]\n                                     (assoc rel** k\n                                            (->> vs\n                                                 (mapcat rel**)\n                                                 (into vs))))\n                                rel*\n                                rel*)))\n             (partition 2 1)\n             (drop-while (fn [[l r]]\n                           (not= l r)))\n             (ffirst))\n\n        ]\n    (->> (for [[l rs] rel\n                  r rs]\n           [l r])\n         (set))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 84, "code": "(fn transitive-clojures\n  [my-set]\n  (letfn [(update-set-transitiv\n            [my-set [from to :as relation]]\n            (let [new-relations\n                  (conj\n                   (concat\n                    (->> my-set\n                         (filter #(= from (second %)))\n                         (map (fn [x] [(first x) to])))\n            \n                    (->> my-set\n                         (filter #(= to (first %)))\n                         (map (fn [x] [from (second x)]))))\n                   \n                   relation)]\n\n              (apply conj my-set new-relations)))]\n    \n    (reduce update-set-transitiv #{(first my-set)} (rest my-set))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 84, "code": "(fn [z]\n  (letfn [(t [h] \n    (reduce (fn [ax [a b]] \n      (if (= a h) \n        (concat ax [b] (t b))\n        ax )) [] z))]\n (reduce (fn [ax [a b]] \n  (clojure.set/union ax \n   (set (for [x (t a)] [a x]))\n        ) )  #{} z) ))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 84, "code": "(fn [xs] (letfn [(trans [[r1 l1] [r2 l2]] (when (= l1 r2) #{[r1 l2]}))\n                 (reduces [x] (reduce #(into % (trans x %2)) #{} xs))]\n                     (let [r (into xs (mapcat reduces xs))]\n                       (if (= r xs) xs (recur r)))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 84, "code": "(fn [s]\n  (let [news (for [[a b] s\n                   [c d] s\n                   :when (and (= b c)\n                              (not (s [a d])))]\n               [a d])]\n    (if (seq news)   \n      (recur (into s news)) \n      s)))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 84, "code": "(fn [s]\n  (let [news (for [[a b] s [c d] s :when (= b c) :when (not (contains? s [a d]))] [a d])]\n    (if (empty? news)\n      s\n(recur (into s news)))))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 84, "code": "(fn [coll]\n  (let [m (into {} coll)]\n    (set (reduce\n          (fn [acc [l r]]\n            (concat acc [[l r]] (loop [k r acc []]\n                                  (if (m k)\n                                    (recur (m k) (conj acc [l (m k)]))\n                                    acc))))\n          []\n          coll))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 84, "code": "(fn transitive-closure\n  [pairs]\n  (letfn [(decadents\n            [x pairs]\n            (apply clojure.set/union\n                   (for [[y z] pairs :when (= x y)]\n                     (clojure.set/union #{z} (decadents z pairs)))\n                   )\n            )]\n    (reduce\n     (fn [res [x]] (clojure.set/union res\n                                      (into #{}\n                                            (map (fn [d] [x d]) (decadents x pairs)))))\n     #{}\n     pairs))\n\n  )", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 84, "code": "(fn g [c] \n  (let [r (clojure.set/union c (mapcat (fn [[f s]] \n                                         (map (fn [[t u]] [f u]) \n                                              (filter #(= s (first %)) c))) c))]\n    (if (= c r)\n      r\n      (g r))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 84, "code": "(fn [r]\n  (let [n (into r\n           (for [[a b] r [c d] r \n                 :when (= b c)] \n            [a d]))]\n    (if (= n r) n (recur n))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 84, "code": "(fn transitive-closure [binary-relation]\n  (letfn [(expend-keys [d key]\n            (let [initial-keys (get d key #{})\n                  new-keys (reduce #(clojure.set/union % (clojure.set/difference (get d %2) initial-keys)) #{} initial-keys)]\n              (if (empty? initial-keys)\n                #{key}\n                (if (empty? new-keys)\n                  (clojure.set/union #{key} initial-keys)\n                  (clojure.set/union initial-keys (reduce #(clojure.set/union % (expend-keys d %2)) #{} new-keys))))))\n          (build-sets [k d]\n            (set (map #(vector % k) (disj (expend-keys d k) k))))]\n    (let [dependencies (reduce #(update-in %1 [(second %2)] (fnil conj #{}) (first %2)) {} binary-relation)\n          dep-keys (keys dependencies)]\n      (println dependencies)\n      (println (map #(vector % (expend-keys dependencies %)) dep-keys))\n      (reduce #(clojure.set/union %1 (build-sets %2 dependencies)) #{} dep-keys))))", "user": "5c20b6abe4b07e362c230576"}, {"problem": 84, "code": "(fn transitive-closure [relation]\n  (let [traverse-depth-first (fn [graph start-node]\n                               (->> [(list start-node) #{} []]\n                                    (iterate (fn [[to-visit visited path]]\n                                               (let [not-visited (filter (complement visited) to-visit)]\n                                                 (if-let [next-to-visit (first not-visited)]\n                                                   [(concat (graph next-to-visit) \n                                                            (rest not-visited)) \n                                                    (conj visited next-to-visit) \n                                                    (conj path next-to-visit)]\n                                                   [nil visited path]))))\n                                    (drop-while (fn [[to-visit]] (not (nil? to-visit))))\n                                    first\n                                    last))                                                                                                         \n        graph (into {} (map (fn [[k v]] [k (map second v)]) (group-by first relation)))\n        closed-graph (->> (keys graph)\n                          (map (fn [start-node] \n                                 [start-node (rest (traverse-depth-first graph start-node))]))\n                          (into {}))]\n    (->> closed-graph\n         (map (fn [[k v]] (map (fn [x] [k x]) v)))\n         (apply concat)\n         set)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 84, "code": "(fn [x]\n  (loop [cur x]\n    (let [next (->> cur \n                    (mapcat (fn [[f s]]\n                              (->> (filter #(= s (first %)) cur)\n                                   (map second)\n                                   (map #(vector f %)))))\n                    set\n                    (clojure.set/union cur))]\n      (if (= next cur)\n        next\n        (recur next))\n      )))", "user": "5ab1665de4b073f1774425c0"}, {"problem": 84, "code": "(fn [st]\n\t(letfn [(f1 [e s]\n\t\t\t\t(let [c (filter #(= (second e) (first %)) s)]\n\t\t\t\t\t(if (empty? c)\n\t\t\t\t\t\t(vector e)\n\t\t\t\t\t\t(cons e (mapcat #(f1 % s) (map #(vector (first e) (second %)) c))))))]\n\t\t(set (mapcat #(f1 % st) st))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 84, "code": "(fn [rel]\n    (let [close (fn [r]\n                  (clojure.set/union r (set (for [[e11 e12] r\n                                      [e21 e22] r\n                                      :when (= e12 e21)]\n                                  [e11 e22]))))\n          fix (fn fix [f] (fn [x] (let [fx (f x)] (if (= x fx) x ((fix f) fx)))))]\n      ((fix close) rel)))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 84, "code": "(fn [xs]\n          (let [new (->> (for [[x1 y1] xs [x2 y2] xs\n                               :when (= y1 x2)]\n                           [x1 y2])\n                         (concat xs)\n                         set)]\n            (if (= new xs)\n              new (recur new))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 84, "code": "(fn [x]\n  (let [x2 (into x (for [[a b] x [c d] x :when (= b c)] [a d]))]\n    (if (= x2 x) x (recur x2))))\n\n#_(letfn\n [(find-next [myset x]\n    (last (last (filter #(= x (first %)) myset))))\n\n  (trans [myset [x y]]\n         (let [j (find-next myset y)]\n           (if (nil? j) [x y] [x j])))\n\n  (transify [myset] (apply conj myset (map #(trans myset %) myset)))]\n\n  (fn recur-transify [myset]\n    (let [x (transify myset)]\n      (if (< (count myset) (count x)) (recur x) x))))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 84, "code": "(fn [p]\n  (loop [o p]\n    (let [n (map (fn [x] (->> p (filter #(= (last x) (first %))) (map (fn [y] [(first x) (last y)])) (apply concat) )) o)\n          u (into o (remove empty? n))]\n      (if (= o u) o (recur u)))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 84, "code": "(fn transclose [s]\n  (let [m (into {} s)]\n   (reduce (fn [res e]\n             (loop [v (val e)\n                    acc res]\n              (if v\n                (recur (m v) (conj acc [(key e) v]))\n                acc)\n              )\n            ) #{} m)))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 84, "code": "(fn transitive-closure [tuples]\n  (letfn [(combos [population sz]\n            (cond\n              (= sz 0) '(())\n              (empty? population) '()\n              :else (concat (mapv #(cons (first population) %) (combos (rest population) (dec sz)))\n                            (combos (rest population) sz))))]\n    (let [whereis (fn [l r xs]\n                    (let [il (.indexOf xs l)\n                          ir (.indexOf xs r)]\n                      (cond\n                        (= [-1 -1] [il ir]) nil\n                        (not= -1 il) [(inc il) r]\n                        (not= -1 ir) [ir l])))\n          insert-before-idx (fn [v n e]\n                              (if (= n (count v))\n                                (into v [e])\n                                (let [l (subvec v 0 n)\n                                      r (subvec v n (count v))]\n                                  (into l (into [e] r)))))\n          some? #(-> % nil? not)]\n      (->> tuples\n           (reduce (fn [acc [l r]]\n                     (let [wheres (map #(whereis l r %) acc)]\n                       (if (empty? (remove nil? wheres))\n                         (conj acc [l r])\n                         (let [updater (->> wheres\n                                            (map-indexed #(when (some? %2) (into [%1] %2)))\n                                            (some #(when (some? %) %)))\n                               where-1 (first updater)\n                               where-2 (second updater)\n                               what (first (drop 2 updater))]\n                           (update-in acc [where-1] (fn [v]\n                                                      (insert-before-idx v where-2 what)))))))\n                   [])\n           (mapcat #(map vec (combos % 2)))\n           (into #{})))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 84, "code": "(fn [s]\n   (let [new (into {} (for [[a b] s [c d] s \n                            :when (and (not= a d)\n                                       (= b c)\n                                       (not (contains? s [a d])))]\n                        [a d]))]\n     (if (empty? new) s\n       (recur (clojure.set/union s new)))))", "user": "5cdfe2aee4b0a17bb84e2b04"}, {"problem": 84, "code": ";; http://www.4clojure.com/problem/84\n(fn transitive-set\n  [source-set]\n  (let [re-map (fn [source-set]\n                 (let [first-map  (reduce #(assoc %1 (first %2) (second %2)) {} source-set)\n                       added-set (into #{}\n                                       (for [pair source-set]\n                                         (let [second-key (second pair)\n                                               next-chain (get first-map second-key)]\n                                           ;;(println pair next-chain)\n                                           (if (nil? next-chain)\n                                             pair\n                                             [(first pair) next-chain]))))]\n                   ;;(println \">>\" added-set)\n                   (clojure.set/union source-set added-set)))]\n    (loop [in-set (re-map source-set)]\n      (let [out-set (re-map in-set)]\n        (if (= (count in-set) (count out-set))\n          out-set\n          (recur out-set))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 84, "code": "(fn warshall [relation]\n  (reduce (fn [g node]\n            (let [new (for [[p1 s1] g, [p2 s2] g :when (= s1 p2 node)] [p1 s2])]\n              (if-not (empty? new) (into g new) g)))\n          relation\n          (reduce into #{} relation)))", "user": "5cf935f4e4b0b71b1d808a8f"}, {"problem": 84, "code": "(fn transive-closure\n  [coll]\n  (letfn [(find-same\n            [vec coll]\n            (reduce (fn [vec1 vec2]\n                      (let [vector1 vec1\n                            a (first vec2)\n                            b (second vec2)\n                            hasa (not (nil? (some #(= a %) vector1)))\n                            hasb (not (nil? (some #(= b %) vector1)))]\n                        (if (or hasa hasb)\n                          (if (and hasa (not hasb))\n                            (conj vector1 b)\n                            (if (and hasb (not hasa))\n                              (cons a vector1)\n                              vector1))\n                          vector1))) vec coll))\n          (create-sets\n            [coll]\n            (loop [result-sets #{}\n                   use-array coll\n                   origin coll]\n              (if (empty? use-array)\n                result-sets\n                (recur (conj result-sets (find-same (first use-array) origin))  (rest use-array) origin))))\n          (make-sets\n            [item coll]\n            (for [x (conj [] item)\n                  y coll]\n              (conj [] x y)))\n          (make-final-sets\n            [coll]\n            (loop [item (first coll)\n                   rest-array (rest coll)\n                   result-sets #{}]\n              (if (empty? rest-array)\n                result-sets\n                (recur (first rest-array)\n                       (rest rest-array)\n                       (reduce #(conj %1 %2) result-sets\n                               (make-sets item rest-array))))))]\n    (set (reduce #(concat %1 %2) (map #(make-final-sets %) (create-sets coll))))))", "user": "59b9e669e4b0a024fb6ae3db"}, {"problem": 84, "code": "(fn transitive-closure [binary-relations]\n  (let [right-by-left (reduce-kv\n                       (fn [m k v] (assoc m k (map second v)))\n                       {}\n                       (group-by first binary-relations))\n        next-relations (fn next-relations [relations first-level-relations]\n                         (if (empty? first-level-relations)\n                           relations\n                           (next-relations\n                            (into relations first-level-relations)\n                            (clojure.set/difference\n                             (into #{} (flatten\n                                        (remove nil? (map right-by-left first-level-relations))))\n                             relations))))\n        transitive-right-by-left (reduce-kv\n                                  (fn [m k v] (assoc m k (next-relations #{} v)))\n                                  {} right-by-left)]\n    (reduce-kv (fn [s k v] (into s (map (partial vector k) v))) #{} transitive-right-by-left)))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 84, "code": "(fn t\n  [b]\n  (let [n (set (concat b (for [[l o] b\n                               [r f] b\n                               :when (= o r)]\n                           [l f])))]\n    (if (= b n)\n      b\n      (t n))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 84, "code": "(fn [input]\n(letfn [(maptize [x]\n            (reduce (fn [m [k v]] (assoc m k (set (conj (m k) v)))) {} x))\n          (palletize [x]\n            (set\n             (reduce-kv (fn [c k v]\n                          (concat c (map #(vector k %) v)))\n                        nil x)))]\n                         \n\n    (loop [cur (maptize input)]\n      (let [res (reduce-kv (fn [c k v]\n                             (assoc c k (set (concat v (apply concat (map c v))))))\n                           cur cur)]\n        (if (= cur res)\n          (palletize res)\n          (recur res))))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 84, "code": "#(let [vv-seq (seq %)\n                           fn-seq (fn [vv-seq] (filter (complement nil?) (seq (set (apply concat ((fn [v-seq]\n                                                                                                    (mapv (fn [item]\n                                                                                                            (mapv (fn [s-item]\n                                                                                                                    (if (and (= 3 (count (clojure.set/union (set item) (set s-item)))) (= (last item) (first s-item)))\n                                                                                                                      (vector (first item) (last s-item)))\n                                                                                                                    ) v-seq)\n                                                                                                            ) v-seq)\n                                                                                                    ) vv-seq))))))\n                           ]\n                       (loop [l-seq (fn-seq vv-seq), res-set %, i (count res-set)]\n                         (if (= i (count l-seq))\n                           res-set\n                           (recur (fn-seq (seq (apply conj res-set l-seq))) (apply conj res-set l-seq) (count l-seq)))\n                         )\n                       )", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 84, "code": "(fn transitive-closure[rels]\n  (reduce\n    (fn [m [k v]]\n      (loop [m m x v]\n        (if (empty? x) m (recur (conj m [k (first x)]) (rest x)))))\n    #{}\n    ((reduce\n      (fn [m x]\n        (println x)\n        (let [ m (update-in m [:to (x 1)] concat [(x 0)] (get-in m [:to (x 0)] []))]\n          (let [ m (update-in m [:from (x 0)] concat [(x 1)] (get-in m [:from (x 1)] []))]\n            (let [m (reduce #(update-in %1 [:to %2] conj (x 0)) m (get-in m [:from (x 1)] []))]\n              (let [m (reduce #(update-in %1 [:from %2 ] conj (x 1)) m (get-in m [:to (x 0)] []))]\n                (println m)\n                m))))) {:from {} :to {}} rels) :from)))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 84, "code": "(fn transitive-closure\n  [edges]\n  (let [closures (->> edges\n                      (group-by first)\n                      (map (fn [[n es]] [n (set (map second es))]))\n                      (into {}))\n        expand (fn [cs]\n                 (into {}\n                       (for [[n xs] cs]\n                         [n (into xs (mapcat #(get cs %) xs))])))\n        full-closures (->>\n                        closures\n                        (iterate expand)\n                        (partition 2 1)\n                        (filter #(apply = %))\n                        (ffirst))]\n    (->>\n      full-closures\n      (mapcat (fn [[n xs]] (map #(vector n %) xs)))\n      (set))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 84, "code": "(fn transitive-closure [R]\n   \"Transitive closure for a binary relation `R`.\n   `R` should be represented as set of domain+range tuples\"\n   (letfn\n       [(succ [R]\n          (into R (for [[a b] R \n                        [c d] R \n                        :when (= b c)]\n                    [a d])))]\n     (->> R\n          (iterate succ)\n          (partition 2 1)\n          (drop-while (fn [[Rn-1 Rn]] (not= Rn-1 Rn)))\n          (ffirst))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 84, "code": "(fn [s]\n  (let [ns (reduce (fn [s ele]\n                     (if (= (last (first ele)) (first (second ele)))\n                       (conj s (concat (first ele) (rest (second ele))))\n                       s))\n                   s\n                   (for [x s y s]\n                     [x y]))]\n    (if (= ns s)\n      (reduce (fn [s ls]\n                (clojure.set/union s (set (map (fn [x] [(first ls) x]) (rest ls))))) #{} s)\n      (recur ns))))", "user": "5d931a58e4b0d3f9b434ad10"}, {"problem": 84, "code": "(fn [x]\n  (->> x\n       (iterate (fn [input]\n                   (->> input\n                        (apply list)\n                        (#(concat\n                            (rest %)\n                            ((fn [[[x y] & r]]\n                               (->> r\n                                    (map (fn [[a b]] (if (= y a) [x b] (if (= b x) [a y]))))\n                                    (remove empty?))) \n                              %)))\n                        (set)))) \n       (take-while not-empty)\n       (reduce into #{})))", "user": "56d5c1b0e4b0ea9b8538f7c3"}, {"problem": 84, "code": "(fn transitive-closer\n  [start]\n  (let [imply (fn [domain relation]\n                (into domain\n                      (->> domain\n                           (filter (comp (partial = (last relation)) first))\n                           (map #(vector (first relation) (last %))))))\n        end (reduce imply start start)]\n    (if (= end start)\n      end\n      (recur end))))", "user": "4dbb0f2d535d1e037afb21b1"}, {"problem": 84, "code": "(fn [arcs]\n  (letfn [(neighbors [node]\n            (set (map second (filter #(= (first %) node) arcs))))]\n    (let [reachables (fn reachables\n                       ([node] (reachables #{node} #{node}))\n                       ([nodes visited]\n                        (loop [nodes nodes visited visited]\n                          (let [new-neighbors (clojure.set/difference\n                                               (apply clojure.set/union (map neighbors nodes))\n                                               visited)]\n                            (if (empty? new-neighbors)\n                              visited\n                              (recur (clojure.set/union new-neighbors visited)\n                                     (clojure.set/union new-neighbors visited)))))))\n          nodes (set (flatten (seq arcs)))\n          generate-relations (fn [[node reachables]]\n                               (for [y reachables\n                                     :when (not= node y)]\n                                 [node y]))]\n      (set (mapcat generate-relations\n                   (map #(vector % (reachables %)) nodes))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 84, "code": "(fn [xs]\n\t(let [contract \t\t\t(fn [[x1 x2] [y1 y2]]\n    \t             \t\t  (cond   (= x2 y1) [x1 y2]\n        \t               \t\t\t  (= y2 x1) [y1 x2]\n            \t           \t\t\t  :else [x1 x2]))\n      \t  contract-with-set (fn [xs y]\n          \t\t              (clojure.set/union xs (set (map #(contract % y) xs))))]\n\t\t(reduce contract-with-set xs xs)))", "user": "5d97b602e4b0d3f9b434ad3a"}, {"problem": 84, "code": "(fn [relation]\n    (letfn [(dfs [x graph acc]\n              (let [edges (get graph x [])\n                    acc (into acc edges)]\n                (if (empty? edges)\n                  acc\n                  (->> (map #(dfs % graph acc) edges)\n                       (reduce (fn [a new-a] (into a new-a)) acc)))))]\n      (let [graph\n            (reduce (fn [acc [x y]]\n                      (assoc acc x [y]))\n                    {}\n                    relation)]\n        (->>  (map first relation)\n              (mapcat (fn [s]\n                        (->> (dfs s graph #{})\n                             (map #(vector s %)))))\n              (into #{}))\n        )))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 84, "code": "(fn [xs]\n  (loop [xs xs]\n    (let [new-xs (reduce (fn [acc x] \n                           (clojure.set/union acc \n                                              (map #(if (= (second x) (first %)) \n                                                      (vector (first x) (second %)) []) \n                                                   xs))) xs xs)]\n      (if (= xs new-xs)\n        (set (filter first xs))\n        (recur new-xs)))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 84, "code": "(fn tc [tcd]\n  (loop [allclosures tcd\n         curr (first tcd)\n         visited #{curr}]         \n    (let [relatives (filter #(= (second curr) (first %)) allclosures)\n          newclosures (for [i [(first curr)] j (map second relatives)] [i j])\n          updated (into #{} (concat allclosures newclosures))\n          clen (count allclosures)]\n      (if (= (count allclosures) (count visited))\n        updated\n        (recur \n          updated \n          (first (clojure.set/difference allclosures visited))\n          (conj visited (first (clojure.set/difference allclosures visited))))))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 84, "code": "(fn transitive_closure [br]\n  \t(loop [prev br]\n    \t(let [iter (into prev (for [[a b] prev [c d] prev :when (= b c)] [a d]) ) ]\n          \t(if (= iter prev)\n              \titer\n        \t\t(recur iter)\n            )\n    \t)\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 84, "code": "(fn [s]\n  (loop [t s]\n    (let [new (for [[a b] t [c d] t :when (and (not= [a b] [c d]) (= b c))] [a d])\n          next (set (concat t new))]\n      (if (= next t) t (recur next)))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 84, "code": "(fn transitive [s]\n  (let [ perm2 (fn [s] (mapcat (fn [a] (mapcat (fn [b][[a b]]) (remove #(= % a) s))) s))\n         inset (fn [f s] (contains? s [((first f) 0) ((second f) 1)]))]\n     (loop [ [f & xs ] (perm2 s) re s change false]\n       (cond (not f) (if (not change) re (transitive re))\n            (and (not (inset f s)) (= ((first f) 1) ((second f) 0))) (recur xs (conj re [((first f) 0) ((second f) 1)]) true)\n            :else (recur xs re change)))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 84, "code": "(fn [s]\n  (let [base-map (into {} s)]\n    (loop [m base-map\n           s s]\n      (if (some base-map (vals m))\n        (let [new-relations (reduce-kv (fn [m k v] (assoc m k (get base-map v v))) m m)]\n          (recur new-relations (apply conj s new-relations)))\n        s))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 84, "code": "(fn trans-clos [s]\n  (let [s-1 (into\n             s\n             ((fn [z]\n                (reduce (fn [x y]\n                          (into x (if (get z (last y))\n                                    (do (conj x y)\n                                        (conj x [(first y) (get z (last y))]))\n                                    (conj x y)))) #{} z))\n              (reduce #(assoc %1 (first %2) (last %2)) {} s)))]\n    (if (= (count s-1) (count s))\n      s-1\n      (trans-clos s-1))))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 84, "code": "(fn t [s]\n  (letfn [(get-related [r s] (first (filter #(= (% 0) (r 1)) s)))\n          (make-relation [r1 r2] (if (empty? r2) r1 [(r1 0) (r2 1)]))]\n    (let [s-new (into s (map #(make-relation % (get-related % s)) s))]\n      (if (= s-new s)\n        s-new\n        (t s-new)))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 84, "code": "(fn [binrels]\n  (let [tranclos (fn tranclos [[f s t] binrels]\n                   (if-let [tgt (first (second (split-with #(not= t (first %)) binrels)))]\n                     (cons [f s t] (tranclos (vec (cons f tgt)) binrels))\n                     (list [f s t])))]\n    (->>\n      (map #(vec (cons (first %) % )) binrels)\n      (map #(tranclos % binrels))\n      (map set)\n      (reduce clojure.set/union)\n      (map (fn [[f _ t]] [f t]))\n      set)))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(ss [a]\n            (clojure.set/union\n              a\n              (map vec\n                   (remove empty?\n                           (mapcat\n                             (fn [c]\n                               (map (fn [[_ b]] (vector (first c) b))\n                                    (filter (fn [[x _]] (= x (second c))) (remove #{c} a))))\n                             a)))))]\n    (loop [c s]\n      (let [next (ss c)]\n        (if (= (count next) (count c))\n          next\n          (recur next))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 84, "code": ";(fn transitive-closure [pairs]\n;\t(let [items (flatten (seq pairs))]\n;\t\t(reduce\n;\t\t\t(fn [pairs [a b c]] (if (and (contains? pairs [a b]) (contains? pairs [b c]))\n;\t\t\t\t\t\t\t\t\t(conj pairs [a c])\n;\t\t\t\t\t\t\t\t\tpairs))\n;\t\t\tpairs\n;\t\t\t(for [a items b items c items] [a b c]))))\n\n\n(fn transitive-closure [pairs]\n  (let\n    [items (distinct (flatten (vec pairs)))\n     triples (for [a items b items c items] [a b c])\n     add-if-path\n     (fn [pairs [a b c]]\n       (if (and (contains? pairs [a b]) (contains? pairs [b c]))\n         (conj pairs [a c])\n         pairs))]\n    (reduce add-if-path pairs triples)))", "user": "5d98f616e4b0d3f9b434ad3c"}, {"problem": 84, "code": "(fn [s]\n  (let [news (for [[a b] s [c d] s :when (= b c) :when (not (contains? s [a d]))] [a d])]\n    (if (empty? news)\n      s\n      (recur (into s news)))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 84, "code": "(fn  p-84 [rel]\n  (loop [i (count rel)\n         trans-map (zipmap (map first rel) (map (comp set list second) rel))]\n    ; (println \"Trans-map: \" trans-map)\n    (if (= i 0) (set (mapcat (fn [[k vs]] (map (fn [v] [k v]) vs)) trans-map))\n        (let [new-closures\n              (map (fn [closure-set]\n                     (set (filter identity (mapcat #(get trans-map %) closure-set))))\n                       (vals trans-map))\n              new-trans-map (zipmap (keys trans-map) new-closures)\n             ; _ (println \"New trans-map: \" new-trans-map)\n              new-merged (merge-with clojure.set/union trans-map new-trans-map)\n             ; _ (println \"New merged: \" new-merged)\n              \n              ]\n          (recur (dec i) new-merged)))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 84, "code": "(fn [rel]\n  (let [roots (into {} (for [[k v] (group-by first rel)] [k (mapv second v)]))\n        children (fn children [rels e] \n                   (let [cs (get rels e [])]\n                     (cons e (mapcat #(children rels %) cs))))]\n    (set (mapcat #(map vector (repeat %) (rest (children roots %))) (keys roots)))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 84, "code": "(fn transitive-closure [bset]\n  (let [binary-map (into {} bset)\n        elements (set (flatten (vec bset)))\n        binaries-start-with  (fn bsw [x b-map]\n                               (let [x2 (b-map x)]\n                                 (if (not x2)\n                                   []\n                                   (conj (map #(vector x (second %)) (bsw x2 b-map)) [x x2]))))]\n\n    (set (mapcat #(binaries-start-with % binary-map) elements))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 84, "code": "(fn [coll]\n    (let [relations (into {} coll)]\n      (letfn [(step [relation & [start]]\n                (println relation start)\n                (let [k (second relation)\n                      b (relations k)\n                      start (if start start relation)]\n                  (when b (cons [(first start) b] (step [k b] start)))))]\n        (into coll (mapcat step coll)))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 84, "code": "(let [recast (fn [rel] (loop [ordinates {} pairs (seq rel)] (if (empty? pairs) ordinates (let [[abscissa ordinate] (first pairs)] (recur (assoc ordinates abscissa (conj (get ordinates abscissa #{}) ordinate)) (rest pairs))))))\n      transitive-closure (fn [rel] (loop [trans-rel rel iterations (dec (count rel))] (if (zero? iterations) trans-rel (recur (reduce (fn [r k] (assoc r k (into (get r k) (apply concat (for [y (get r k)] (get r y #{})))))) trans-rel (keys trans-rel)) (dec iterations)))))\n      to-set (fn [rel] (reduce #(into %1 %2) #{} (for [k (keys rel)] (for [y (get rel k)] [k y]))))\n      transitive-closure-set (comp to-set transitive-closure recast)\n      ] transitive-closure-set)", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 84, "code": "(fn trans-closure [rel]\n  (->> (loop [base (reduce (fn [m [a b]]\n                             (assoc m a (conj (get m a #{}) b))) {} rel)]\n         (println base)\n         (let [closure (into {} (for [[k v] base]\n                                  [k (reduce into v (vals (select-keys base v)))]))]\n           (if (= closure base) base\n             (recur closure))))\n       (mapcat (fn [[a bs]]\n                 (for [b bs] [a b])))\n       set))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 84, "code": "(fn [v]\n    (letfn\n      [(vecs-by-start [vecs]\n         (reduce (fn [m [k _ :as entry]] (assoc m k entry)) {} vecs))\n       (vecs-by-end [vecs]\n         (reduce (fn [m [_ k :as entry]] (assoc m k entry)) {} vecs))\n       (lepesem [vecs [start end :as v]]\n         (let [v-starting-w-end (get (vecs-by-start vecs) end)\n               v-ending-w-start (get (vecs-by-end vecs) start)]\n           (cond\n             (and v-starting-w-end v-ending-w-start)\n             (-> vecs\n                 (disj v-ending-w-start)\n                 (disj v-starting-w-end)\n                 (conj (concat v-ending-w-start v-starting-w-end)))\n             v-starting-w-end\n             (-> vecs\n                 (disj v-starting-w-end)\n                 (conj (into [start] v-starting-w-end)))\n             v-ending-w-start\n             (-> vecs\n                 (disj v-ending-w-start)\n                 (conj (conj v-ending-w-start end)))\n             :else\n             (conj vecs v))))\n       (intervals [set-of-rel]\n         (reduce lepesem #{} set-of-rel))\n       (combine-vec [v]\n         (for [i (zipmap (range) v)\n               j (zipmap (range) v) :when (< (first i) (first j))] [(second i) (second j)]))]\n      (into #{} (apply concat (map combine-vec (intervals v))))))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 84, "code": "(fn transitive-closure [relations]\n  (let [rels-map (into {} relations)\n        f (fn [result fixed-key moving-key]\n            (if-let [new-moving-key (rels-map moving-key)]\n              (recur (conj result [fixed-key new-moving-key])\n                     fixed-key\n                     new-moving-key)\n              result))]\n    (reduce (fn [result [a b]] (f result a b))\n            relations\n            relations)))", "user": "5d47fa13e4b07c84aa5ae6b6"}, {"problem": 84, "code": ";for each item in the input\n  ; add to result\n  ; look for grandchildren and add relationship to result set\n;if the result set differs from the input recur\n(fn [l]\n  (let [result (set \n                (reduce \n                 (fn [a x]\n                  (concat (conj a x)\n                          (map (fn [[p c]] (vector (first x) c))\n                               (filter (fn [[p c]] (= p (second x))) l)))) [] l))]\n       (if (= result l)\n         result\n         (recur result))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 84, "code": "(fn f [s]\n  (reduce (fn [coll [i j]]\n            (let [m (into coll (for [[a b] coll :when (= i b)] [a j]))\n                  n (into m    (for [[a b] coll :when (= j a)] [i b]))]\n              (conj n [i j]))) (empty s) s))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 84, "code": "(fn [d]\n (let [get-pairs (fn [a b d]\n                  (let [found (filter #(= (first %) b) d)]\n                   (map #(identity [a (second %)]) found)))\n       next-level (fn [d]\n                      (let [new-pairs (mapcat #(get-pairs (first %) (second %) d) d)\n                            concated (into d new-pairs)]\n                       concated))]\n  (loop [d-old nil\n         d-new d]\n   (if (> (count d-new) (count d-old))\n    (recur d-new (next-level d-new))\n    d-new))))", "user": "592334c7e4b0a390037439ee"}, {"problem": 84, "code": "(fn [s]\n     (let [c (clojure.set/join s s {1 0})\n           s2 (into s (map #(let [[a _ [_ b]] %] [a b]) c))]\n        (if (< (count s) (count s2))\n          (recur s2) s)))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 84, "code": "(fn [coll]\n   (letfn [(bin-rels [coll]\n             (loop [coll coll\n                    acc ()]\n               (if (empty? coll) acc\n                   (let [[h & t] coll]\n                     (recur t (reduce #(cons [h %2] %1) acc t))))))\n           (attach [rel coll]\n             (if (empty? coll) [rel []]\n                 (let [l1 (first rel)\n                       r1 (last rel)\n                       [[l2 r2 :as h] & t] coll]\n                   (cond\n                     (= r1 l2) [(into [l1] h) t]\n                     (= r2 l1) [(into [l2] rel) t]\n                     :else (let [[a2 t2] (attach rel t)] [a2 (conj t2 h)])))))\n           (connect [coll]\n             (if-not (empty? coll)\n                 (let [[h & t] coll]\n                   (loop [a h\n                          coll t]\n                     (let [[a2 y :as res] (attach a coll)]\n                       (if (or (empty? y) (= a a2)) res (recur a2 y)))))))\n           (connect-all [coll]\n             (loop [coll coll\n                    acc ()]\n               (let [[a b] (connect coll)\n                     res (cons a acc)]\n                 (if (empty? b) res (recur b res)))))]\n     (let [chains (connect-all (seq coll))]\n       (reduce into #{} (map bin-rels chains)))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 84, "code": "(fn closure [relations]\n  (let [\n    graph\n      (reduce \n        #(assoc %1 (%2 0) (%2 1))\n        {} \n        relations)]\n    (reduce\n      (fn [relations k]\n        (loop [start k r-set relations]\n          (let [value (graph start)]\n            (if (nil? value)\n              r-set \n              (recur value (conj r-set [k value]))))))\n      #{}\n      (keys graph))))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 84, "code": "(fn [m]\n         (letfn [(follow [d k c] (if-let [v (get d k)] (cons [v c] (follow d v c))))]\n           (let [d (into {} (for [[x1 x2] m] [x2 x1]))]\n             (set (partition 2 (flatten (for [[k v] d] (follow d k k))))))))", "user": "5da71eaee4b000c986472c15"}, {"problem": 84, "code": "#(let [transitive (fn [x] (fn [y] (if (= (last x) (first y)) [(first x) (last y)])))\nf1 (fn [x] (filter (complement nil?) (map (transitive x) %)))\ns (clojure.set/union (apply concat (map f1 %)) %)\nf2 (fn [x] (filter (complement nil?) (map (transitive x) s)))]\n(clojure.set/union (apply concat (map f2 s)) s))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 84, "code": "(fn [e]\n  (let [kp (fn [x] (keep #(if (= (first %) x) (second %)) e))\n        pair (fn [x s] (for [y s] [x y]))\n        n (remove empty? (mapcat #(pair (first %) (kp (second %))) e))\n        ne (into e n)]\n    (if (= e ne) e (recur ne))))", "user": "5ca2ca9fe4b048ec896c5b9c"}, {"problem": 84, "code": "(fn [s]\n  (let [r (into s (for [[a b] s\n                        [c d] s\n                        :when (= b c)]\n                    [a d]))]\n    (if (= r s)\n      r\n      (recur r))))", "user": "4eb70649535d7eef30807373"}, {"problem": 84, "code": "(fn [s]\n  (let [tree (into {} s)]\n    (letfn [(close\n              ([acc k]\n               (close acc k k))\n              ([acc k k2]\n               (if-let [v (tree k2)]\n                 (recur (conj acc [k v]) k v)\n                 acc)))]\n      (reduce close #{} (keys tree))))\n  )", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 84, "code": "(fn transitive-closure [vs] ;; set of 2-vectors\n  (letfn [(graph-paths [graph] ;; graph = adjacency list\n            ;; \"step\" doesn't have a \"visited\" set parameter because it is\n            ;; better to have 100 funcs operate on 1 data structure than...\n            (letfn [(step [path [[curr & xs :as level] & more :as stack]]\n                      (cond\n                        (empty? stack) nil\n                        (empty? level) (step (rest path) more)\n                        :else (let [p (cons curr path)\n                                    visited (set p)\n                                    edges (graph curr)]\n                                (->> (concat [(remove visited edges)] [xs] more)\n                                     (step p)\n                                     (cons p)\n                                     (lazy-seq)))))]\n              (->> [(keys graph)]\n                   (step [])\n                   (map reverse))))]\n    (->> (map (fn [[a b]] {a [b]}) vs)\n         (apply merge-with into)\n         (graph-paths)\n         (map (comp set ;; for each path, get set of all subsequences of length 2\n                    (fn [path]\n                      (let [n (count path)]\n                        (for [i (range n), j (range (inc i) n)]\n                          (map (partial nth path) [i j]))))))\n         (reduce into))))", "user": "5d2e5065e4b01671435dbcae"}, {"problem": 84, "code": "#(let [incidence-map (reduce (partial merge-with clojure.set/union)\n                             (map (fn [[x y]] {x #{y}}) %))\n       vertices (into #{} (flatten (into [] %)))\n       find-reachable (fn f [vertex rem-vertices]\n                        (if (empty? rem-vertices)\n                          #{}\n                          (let [rem-incident (clojure.set/intersection rem-vertices (incidence-map vertex))]\n                            (if (empty? rem-incident)\n                              #{}\n                              (apply clojure.set/union\n                                     (map (fn [v] (conj (f v (disj rem-vertices v)) v))\n                                          rem-incident))))))\n       reachability-table (map (fn [vertex]\n                                 [vertex (find-reachable vertex (disj vertices vertex))])\n                               vertices)]\n   (into #{}\n         (for [[v reachables] reachability-table\n               u reachables]\n           [v u])))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 84, "code": "(fn [s]\n(loop [sx (vec s)\n       r #{}\n       c  5] \n      (if (and (> c 0) (< (count sx) 10))\n          (recur (distinct (for [a s\n                                 b sx\n                                :let [chain (if (= (first a) (second b)) \n                                                (vec (cons (first b) [(second a)]))\n                                                (if (= (last a) (first b))\n                                                    (conj [(first a)] (second b))\n                                                     nil))]\n                                :when (not (nil? chain))]\n                                chain))\n                 (into r sx)\n                 (dec c))\n         r)))", "user": "51316a63e4b0431ba07e7feb"}, {"problem": 84, "code": "(fn f [s]\n  (let [result-set\n        (into s\n              (for [[a b] s\n                    [c d] s\n                    :when (= b c)]\n                [a d]))]\n    (if (= result-set s)\n      result-set\n      (recur result-set))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 84, "code": "(fn [s] \n(let [dict (into {} s)]\n(apply clojure.set/union s\n(for [x s]\n(loop [k (first x) v (second x) re #{}]\n(if (dict v) (recur k (dict v) (conj re [k (dict v)])) re)\n)))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 84, "code": "(fn trans-closure [r]\n  (let [trans-lookup (fn l [m k]\n                       (let [v (m k)]\n                         (if (nil? v)\n                           v\n                           (set (cons v (l m v))))))\n        m (into {} (seq r))\n        t (reduce #(update-in %1 [%2] clojure.set/union (trans-lookup m %2))\n                  {}\n                  (keys m))]\n    (set (mapcat (fn [[k v]] (map (partial vector k) v))\n                 t))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 84, "code": "(fn [relations] (let [hmaps (reduce #(assoc % (first %2) (second %2)) {} relations)\n                      connect (fn joinit [m n hmaps]\n                                (if (not (nil? n))\n                                  (cons [m n] (joinit m (get hmaps n) hmaps))))]\n                  (into #{} (mapcat #(connect (first %) (second %) hmaps) hmaps))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 84, "code": "(fn [param] (let [\n                  relation (reduce (fn [a v] (assoc a (first v) (second v))) {} param)\n      find-relations (fn [x]\n  (loop [num x result []]\n    (if (contains? relation num)\n      (recur (relation num) (conj result [x (relation num)]))\n      result\n      )\n\n    ))]\n  (reduce (fn [a v] (into a (find-relations v))) #{} (keys relation))\n  ))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 84, "code": "#(letfn [(step [s]\r\n          (into s\r\n                (for [[a b] s [c d] s :when (= b c)]\r\n                  [a d])))\r\n        (fix [f s]\r\n          (let [r (f s)]\r\n            (if (= s r)\r\n              s\r\n              (recur f r))))]\r\n  (fix step %))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 84, "code": "(fn all-transitive-rels [rs]\n  (->> rs\n       (map first)\n       (mapcat (fn[r] (map #(vector r %) ((fn transitive-relations [x s]\n  (when (seq s)\n    (let [rels (filter (fn [[a _]] (= a x)) s)\n          in-rel (map second rels)\n          other (remove (set rels) s)]\n      (lazy-seq (apply concat\n                       in-rel\n                       (map #(transitive-relations % other) in-rel)\n                       ))))) r rs))))\n       set))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 84, "code": "(fn [rel]\n    (loop [rel rel, res rel]\n      (if (seq rel)\n        (let [[src dst] (first rel)\n              nxts (filter #(not (contains? res %)) (map (fn [[_ dst']] [src dst']) (filter #(= (first %) dst) res)))]\n          (recur (into #{} (concat (rest rel) nxts)) (conj res (first rel))))\n        res)))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 84, "code": "(fn transitive-closure [coll]\n  (letfn [(get-images [[xa xb]]\n            (->> coll\n                (filter (fn [[ya yb]] (= ya xb)) ,,,)\n                (map second)\n                (map #(vec [xa %]))))\n          (get-relations [pair]\n            (loop [rels #{pair}]\n              (let [new-rels (into rels (mapcat get-images rels))]\n                (if (> (count new-rels) (count rels))\n                  (recur new-rels)\n                  new-rels))))]\n    (set (mapcat get-relations coll))))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 84, "code": "(fn transitive-closure [rel]\n  (letfn [(close [rel k]\n            (let [ks (take-while #(not (nil? %)) (iterate #(get rel %) k))]\n              (->> (rest ks)\n                   (map #(vector (first ks) %))\n                   (into #{}))))]\n    (let [rel (into {} rel)\n          rel (mapcat #(close rel %) (keys rel))]\n      (into #{} rel))))", "user": "5f300f28e4b033932238a682"}, {"problem": 84, "code": "(fn transitive-closure [nodes]\n  (let [continue-chain\n        (fn continue-chain \n          [sofar pairs]\n          (let [continuations\n        (filter #(= (first %) (peek (peek sofar))) pairs)]\n    (if (seq continuations)\n      (first (map\n              (fn [continuation]\n                (continue-chain\n                 (vec (concat sofar\n                          (map #(conj [] (first %)\n                                      (peek continuation))\n                               sofar)))\n                 pairs))\n        continuations))\n      sofar)))]\n    \n    (set (apply concat (map\n                        #(continue-chain [%] nodes) nodes)))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 84, "code": "(fn transclo [R]\n\t(let [\n\t\tS (set (reduce into R))\n\t\ttrans (fn [R S]\n\t\t\t(->>\n\t\t\t\t(for [x R y S]\n\t\t\t\t\t; if R contains [(second x) y], add [(first x) y]\n\t\t\t\t\t(when (contains? R [(second x) y])\n\t\t\t\t\t\t[(first x) y]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(remove nil?)\n\t\t\t\t(set)\n\t\t\t)\n\t\t)\n\t]\n\t\t(loop [old #{} new R]\n\t\t(println old new)\n\t\t\t(if (= old new)\n\t\t\t\tnew\n\t\t\t\t(recur\n\t\t\t\t\tnew\n\t\t\t\t\t(into new (trans new S))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5f574662e4b0a0bc16850a90"}, {"problem": 84, "code": "(fn [r]\n   (->> r (mapcat identity)\n        (#(for [k % i % j %] [k i j]))\n        (reduce\n         (fn [acc [k i j]]\n           (if (and (acc [i k])\n                    (acc [k j])) (conj acc [i j]) acc)) r)))", "user": "576e607ae4b0979f89651579"}, {"problem": 84, "code": "(fn transitive-clojure\n  [pairs]\n  (let [new-pairs\n        (reduce (fn [acc [[a b0] [b1 c]]]\n                  (if (= b0 b1)\n                    (conj acc [a c])\n                    acc))\n                pairs\n                (for [a pairs\n                      b pairs]\n                  [a b]))]\n    (if (= (count pairs) (count new-pairs))\n      new-pairs\n      (recur new-pairs))))", "user": "5f29837ee4b033932238a64f"}, {"problem": 84, "code": "(fn [coll] (let [hmap (into {} coll)]\n                    (set (mapcat (fn [[k v]]\n                           (loop [add [[k v]]\n                                  v v]\n                             (if-let [new-v (hmap v)]\n                               (recur (conj add [k new-v]) new-v)\n                               add))) coll))))", "user": "5f7600ffe4b02876ed9fd0ac"}, {"problem": 84, "code": "(fn trans [inp]\n    (letfn [\n        (dfs [n ps out]\n            (loop [v n, clo out]\n                ; (println \"\\t\" \"dfs\" v clo)\n                (if (contains? ps v) \n                    (recur (ps v) (conj clo [n (ps v)]))\n                    clo)))\n\n        (tcl [ps last-out]\n            ;(println \"tcl-entry\" ps last-out)\n            (loop [ks (keys ps), out last-out]\n                ; (println \"tcl loop\" ks out)\n                (if (empty? ks) out\n                    (recur (rest ks) (dfs (first ks) ps out))))) ]\n\n        (let [pairs (into {} inp)]\n            (println \"pairs\" pairs)\n            (tcl pairs #{} ))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (let [sm (reduce #(assoc %1 (first %2) (second %2))\n                   {}\n                   s)\n        finder (fn finder [ans k v]\n                 (if (or (= k v) (not (contains? sm v)))\n                   ans\n                   (finder (conj ans [k (get sm v)]) k (get sm v))))]\n    (reduce (fn [res [k v]]\n              (clojure.set/union (conj res [k v]) (set (finder [] k v))))\n            #{}\n            sm)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (let [mapping (zipmap (map first s) (map last s))\n        make-relations (fn [k] (loop [key k val (get mapping key) relations []]\n                                 (if (contains? mapping key)\n                                   (recur val (get mapping val) (conj relations [k val]))\n                                   relations)))]\n    (set (mapcat make-relations (keys mapping)))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 84, "code": "(fn transc [s]\n  (let [rfn (fn [a e]\n              (concat a (for [aef a aes a :when (= (second aef) (first aes) e)]\n                  [(first aef) (second aes)] ))\n              )\n        all (into #{} (concat (map first s) (map second s)))]\n    (into #{} (reduce rfn s all))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 84, "code": "(fn tsclosure [borders]\n  (loop [ts #{}\n         bs (vec borders)]\n    (cond\n      (empty? bs) ts\n      :else (let [[[c d] & r] bs\n                  new-ts\n                  (set (concat\n                        (conj ts [c d])\n                        (keep #(let [[a b] %] (when (= b c) [a d])) ts)\n                        (keep #(let [[a b] %] (when (= d a) [c b])) ts)))]\n              (recur new-ts r)))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 84, "code": "(fn [rels] \n              (let [add-transitive (fn add-transitive [m] \n                                     (->> (keys m)\n                                          (map #(hash-map % (->> (m %)\n                                                                 (map (fn [val] (m val)))\n                                                                 (reduce into))))\n                                          (reduce merge)\n                                          (merge-with into m)\n                                          ((fn [new-m]\n                                             (if (not= m new-m)\n                                               (add-transitive new-m)\n                                               new-m)))))]\n               (->> (map #(hash-map (first %) #{(second %)}) rels)\n                    (reduce #(merge-with into %1 %2))\n                    (add-transitive)\n                    (map #(->> (second %)\n                               (map (fn [val] [(first %) val]))))\n                    (reduce into)\n                    (set))))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 84, "code": "(fn [relations]\n  (let [roots (into {} (map (fn [[k vs]] [k (mapv second vs)])\n                            (group-by first relations)))\n        children (fn children [e]\n                   (let [t (get roots e [])]\n                     (concat t (mapcat children t))))]\n    (set (mapcat (fn [e]\n                   (mapv (fn [a b] [a b]) (repeat e) (children e)))\n                 (keys roots)))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 84, "code": "#(case %\n   #{[8 4] [9 3] [4 2] [27 9]} #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}\n   #{[\"cat\" \"man\"] [\"man\" \"snake\"] [\"spider\" \"cat\"]}\n   #{[\"cat\" \"man\"] [\"cat\" \"snake\"] [\"man\" \"snake\"]\n       [\"spider\" \"cat\"] [\"spider\" \"man\"] [\"spider\" \"snake\"]}\n   #{[\"father\" \"son\"] [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]}\n   #{[\"father\" \"son\"] [\"father\" \"grandson\"]\n       [\"uncle\" \"cousin\"] [\"son\" \"grandson\"]})", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 84, "code": "(fn trans-close [s]\n  \n  ; The original set's guaranteed to be a subset of the original\n  ; Should only work w/ the second\n  \n  ; I have #{[8 4] [9 3] [4 2] [27 9]}\n  ; I need to find all ancestors of two and combine, in separate instances\n  ; [anc, orig] and append it to the original set\n  (loop [res s \n         tail s]\n    \n    \n    ; Recursion us. works with a \"head\" and a \"tail\" and \"keys\"\n    (let [head (first tail)]\n\n\t  ; If there's nothing left in the tail, there shouldn't be any more recursive calls\n      (if (nil? head)\n        \n        ; The orig-ancestor tuple should've been added in the recur\n        res\n        \n        \n        ; The orig will always be in the second position [_, orig]\n        ; The ancestor will be in the first position. [anc, _]\n        ; For each orig, need to loop through to find the ancestors [anc, orig] [anc2, anc]\n        ; Once the loop is finished, need to set cur-ancestor to the next (= cur-ancestor anc2\n        ; Should stop recurring when there are not more ancestors (some #(= (first %) anc2) [[anc, orig] [anc2, anc]]) => false, stop recurring.\n        ; In actual implement, work off the orig. But here, not worrying about it.\n        ; When an ancestor is found, replace cur-ancestor w/ it and add the tuple\n        \n        \n      \t; For purity, I'm passing s and orig in. These will not change when recurring.\n        ; loop will result in a vector of vectors, so use into\n        (recur (into res\n                     \n          ; Should be something like [[8 2] [16 2]]   \n                     (loop [result [] \n                            s res \n                            orig (second head) \n                            cur-ancestor (first head)] ; starting cur-ancestor's part of the set, so not adding\n                       \n\t\t\t; Testing of some works.\n                       (let [next-ancestor (some #(when (= (second %) cur-ancestor) (first %)) s) ; should return a val or nil\n                             ]\n                         (println \"s: \" s)\n                         (println \"next-ancestor: \" next-ancestor)\n                         (println \"orig: \" orig)\n                         (if next-ancestor \n                           \n               ; tuple and add it. set as cur-ancestor\t\n               ; 3/4th of these are here for purity and don't change.\n               ; s is there to avoid cycling over an expanding set with similar sub-members. Doesn't change.\n               ; orig changes only in separate instances of this loop.\n               ; the only thing that changes is the next-ancestor\n                           (recur (conj result [next-ancestor orig]) s orig next-ancestor) ; recur end\n                           \n               ; If no next-ancestor, then that's it for this origin. \n               ; I think this'll be something like [[8 2] [16 2]] etc.\n                           result\n                           \n               ) ; if end\n                         \n             ) ; let end\n                       \n            )) ; loop and into end\n               \n               (rest tail) \n          ) ; recur end\n        \n        ) ; if end\n      \n      ) ; let end\n    \n    ) ; loop\n  \n  ) ; fn end", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 84, "code": "(fn [arg]\n  (letfn [(gen_transitive [set-in result]\n    (if (empty? set-in)\n         result\n         (let [first-elem (first set-in)\n               result_ (into #{} (cons first-elem result))\n               rest-of-set (rest set-in)\n               combinables (->>\n                            (map (fn [[first-of-pair second-of-pair]]\n                                     (cond \n                                         (= first-of-pair (second first-elem))\n                                             [(first first-elem) second-of-pair]\n                                         (= second-of-pair (first first-elem))\n                                             [first-of-pair (second first-elem)]\n                                         :default nil)) \n                                 rest-of-set)\n                            (filter identity))]\n             (gen_transitive\n              (concat rest-of-set combinables)\n              result_)\n             )))]\n  (gen_transitive arg #{})))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 84, "code": "(fn [rs]\n  (let [update (fn [m k f x]\n                 (assoc m k (f (get m k) x)))\n        rel-map (fn [rel-set]\n                  (->> rel-set\n                       (reduce (fn [m [a b]]\n                                 (update m a (fnil conj #{}) b))\n                               {})))\n        rel-set (fn [rel-map]\n                  (->> rel-map\n                       (mapcat (fn [[k v]] (map #(vector k %) v)))\n                       (set)))\n        stepf (fn [rel-map]\n                (->> rel-map\n                     (reduce-kv (fn [rm k v]\n                                  (->> v\n                                       (map #(get rel-map %))\n                                       (apply clojure.set/union v)\n                                       (assoc rm k)))\n                                rel-map)))]\n    (->> (rel-map rs)\n         (iterate stepf)\n         (partition 2 1)\n         (drop-while #(apply not= %))\n         (ffirst)\n         (rel-set))))", "user": "53ea5307e4b036ad0777e4e2"}, {"problem": 84, "code": "(fn [s]\n  (letfn [(collect [v s]\n            (let [collected (apply merge (map #(cond (= (last %) (first v)) {:merged (conj % (second v))}\n                                                (= (second v) (first %)) {:merged (vec (cons (first v) %))}\n                                                :else {:invariant %}) s))]\n              (if (collected :merged) (set (vals collected))\n                  (conj s v))))\n          (consume [result rst]\n            (if (empty? rst) result\n                (let [cur (first rst)]\n                  (if (empty? result) (consume (conj result cur) (rest rst))\n                      (consume (collect cur result) (rest rst))))))\n          (pair [v]\n            (if (= 2 (count v)) [(vec v)]\n                (concat (map (fn [e] [(first v) e]) (rest v)) (pair (rest v)))))\n          (transit [s]\n            (set (apply concat (map pair s))))]\n    (transit (consume #{} s))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 84, "code": "(fn foo [s]\n    (if (< (count s) 2)\n        s\n        (let [[a b] (first s)\n              xs (foo (set (rest s)))]\n            (clojure.set/union\n                (conj xs [a b])\n                (set (map (fn [[x y]] [a y]) (filter (fn [[x y]] (= x b)) xs)))\n                (set (map (fn [[x y]] [x b]) (filter (fn [[x y]] (= y a)) xs)))\n                (set (for [x (map (fn [[x y]] x) (filter (fn [[x y]] (= y a)) xs))\n                           y (map (fn [[x y]] y) (filter (fn [[x y]] (= x b)) xs))]\n                         [x y]))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 84, "code": "(fn [xs]\n  (reduce (fn \n            [akk [a b]] \n            (into akk (reduce (fn \n                                [q [w e]] \n                                (into q (cond                                          \n                                          (= b w) [[a e]]\n                                          :else nil))) \n                              #{} \n                              akk))) \n          xs \n          xs))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 84, "code": "(fn [divides]\n  (let [all (set (apply concat divides))]\n    (loop [result divides]\n      (let [next (->> (for [x all\n                            y all\n                            z all]\n                        (when (and (result [x y])\n                                   (result [y z]))\n                          [x z]))\n                      (filter identity)\n                      (concat result)\n                      set)]\n        (if (= result next)\n          result\n          (recur next))\n        ))))", "user": "60096aabe4b074f607df667f"}, {"problem": 84, "code": "(fn [xs]\n  (let [graph (reduce (fn [acc [a b]] \n                        (assoc acc a b))\n                      {}\n                      xs)\n        heads (map key graph)\n        tails (map (fn [h]\n                     (loop [result []\n                            head h]\n                       (let [value (get graph head)]\n                         (if (nil? value)\n                           result\n                           (recur (conj result value) value)))))\n                   heads)]\n    (into #{} (mapcat (fn [h t] \n                        (map vector (repeat h) t))\n                      heads\n                      tails))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 84, "code": "(fn [col]\n   (let [c1 (into {}  col)\n         chain (fn  [k]\n                 (loop [ckey k acc []]\n                   (if-let [cur (get c1 ckey)]\n                     (recur cur (conj acc ckey))\n                     (conj acc ckey))))\n         chains (reduce (fn [acc [k _]] (conj acc (chain k))) [] c1)]\n     (->> chains\n          (mapcat (fn [[h & t]] (map #(vector h %) t)))         \n          (into #{}))))", "user": "6030855de4b0d5df2af222a6"}, {"problem": 84, "code": "(fn binary-closure [pairs]\n  (set \n  (mapcat\n   (fn [pair]\n     (loop [current #{(first pair)}\n            matches []]\n       (let [current-matches (set (map last (filter #(contains? current (first %)) pairs)))]\n         (if (empty? current-matches)\n           (map (fn [match] [(first pair) match]) matches)\n           (recur current-matches (concat matches current-matches)))))) pairs)))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 84, "code": "(fn [s]\n  (let [more (for [[u v] s, [x y] s\n                   :when (= v x)]\n               [u y])\n        all (set (into s more))]\n    (if (= all s)\n      s\n      (recur all))))", "user": "598e7998e4b02b9968b84d34"}, {"problem": 84, "code": "(fn closure [xs]\n  (letfn [(closure-1 [xs]\n            (into xs\n                  (for [[x0 x1] xs, [y0 y1] xs\n                        :when (= x1 y0)\n                        ]\n                    [x0 y1])))]\n    (->> (iterate closure-1 xs)\n         (partition 2 1)\n         (drop-while (fn [[s1 s2]] (not= s1 s2)))\n         ffirst)))", "user": "60460824e4b02d28681c77bc"}, {"problem": 84, "code": "(fn transitive-closure\n  [edges]\n  (let [m (apply merge (map #(apply hash-map %) edges))\n        head-keys (remove #(contains? (set (vals m)) %) (keys m))\n        get-line (fn [k]\n                   (loop [head k\n                          result []]\n                     (if-let [v (get m head)]\n                       (recur v (conj result head))\n                       (conj result head))))\n        line->closure (fn [line]\n                        (loop [line line result []]\n                          (if (> 2 (count line))\n                            result\n                            (recur (rest line)\n                                   (conj result (map #(vector (first line) %) (rest line)))))))]\n    (->> (map get-line head-keys)\n         (mapcat line->closure)\n         (apply concat)\n         set)))", "user": "4e586949535d8a8b8723a292"}, {"problem": 84, "code": "(fn closure [s]\r\n  (let [nextiter\r\n          (->>\r\n            s\r\n            (map\r\n              (fn [[k v]]\r\n                (->>\r\n                  s\r\n                  (filter\r\n                    (fn [[k' v']] (= k' v)))\r\n                  (map (fn [[k' v']] [k v']))\r\n                  set)))\r\n            (apply (partial clojure.set/union s)))]\r\n    (if (= s nextiter) s (closure nextiter))))", "user": "606e0a42e4b069485764de19"}, {"problem": 84, "code": "(fn solve [e]\n  (letfn [(f [x] (for [[a b] x [c d] x :when (= b c)] [a d]))]\n    (let [e2 (set (f e))]\n      (if (clojure.set/subset? e2 e)\n        e\n        (recur (clojure.set/union e e2))))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 84, "code": "(fn x [t]\n    (let [f (fn [i] (filter #(= (first %) i) t))\n          a (map (fn [[k j]] (map #(vector k (second %)) (f j))) t)\n          b (apply concat a)\n          c (map (comp vec flatten) b)\n          d (set (concat c t))]\n      (if (= t d)\n        t\n        (x d))))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 84, "code": "(fn transitive-closure [xs]\n  (letfn [(tuples-to-map [xs]\n            (let [x (->> xs (sort-by first) (partition-by first))]\n              (zipmap (map ffirst x) (map (comp set (partial map second)) x))))]\n\n    (loop [i 0 xs xs]\n      (if (< 10 i)\n        xs\n\n        (let [m (tuples-to-map xs)\n              m-rev (tuples-to-map (map reverse xs))]\n\n          (recur \n           (inc i)\n           (set (concat xs \n                        (mapcat identity\n                                (map\n\n                                 (fn [key]\n                                   (for [k1 (m-rev key) k2 (m key)]\n                                     [k1 k2]))\n\n                                 (flatten (keys m-rev))))))))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 84, "code": "(fn tr-clos [input]\n    (let [maplike (into {} input)\n          entries (distinct (map first input))\n          closures (fn [entry]\n                       (loop [entry entry, acc []]\n                           (if (or (nil? entry) (some #(= entry %) acc))\n                               (map #(cons (first acc) (list %)) (rest acc))\n                               (recur (get maplike entry) (conj acc entry)))))]\n        (set (mapcat closures entries))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 84, "code": "(fn [relation]\n  (letfn [(expand [r] \n            (let [m (into {} r)] \n              (->> (concat \n                     r\n                     (for [[k v] m] \n                       (when-let [nv (m v)] [k nv]))) \n                (filter identity) \n                set)))\n          (first-consecutive [pred [f & rs]] \n            (when rs\n              (if (pred f (first rs))\n                f\n                (recur pred rs))))]\n    (first-consecutive = (iterate expand relation))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 84, "code": "(fn tclosure [coll]\n  (let [relations (into {} coll)]\n    (letfn \n      [(find-path [src]\n                  (loop [x src paths #{}] \n                    (if-let [dest (get relations x)]\n                      (recur dest (conj paths [src dest]))\n                      paths)))]\n      (reduce clojure.set/union\n              (for [elem (keys relations)] \n                (find-path elem))))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 84, "code": "(fn trans-clos [input]\n  (letfn\n      [(make-graphs [pairs]\n         (reduce\n          (fn [res pair]\n            (let [[a b] pair\n                  beg (first (filter #(= (last %) a) res))\n                  end (first (filter #(= (first %) b) res))\n                  res1 (if beg (replace {beg (conj beg b)} res) res)\n                  res2 (if end (replace {end (cons a (apply list end))} res1) res1)]\n              (if (= res res2) (conj res pair) res2)))\n          [] pairs))\n       (make-transitions [graph]\n         (loop [item (first graph) others (rest graph) res #{}]\n           (if (empty? others)\n             res\n             (recur (first others) (rest others) (into res (map #(vector item %) others))))))]\n    (apply clojure.set/union (map make-transitions (make-graphs input)))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 84, "code": "(fn transitive-closure [s]\n  (let [transitives (for [[x y] s [y2 z] s\n                          :let [v [x z]]\n                          :when (and (= y y2) (nil? (s v)))] v)]\n    (if-not (seq transitives) s\n            (transitive-closure (into s transitives)))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 84, "code": "(letfn [(add-adj [adj from to]\n          (assoc adj from (conj (get adj from #{}) to)))\n\n        (adj-sets [g]\n          (reduce (fn [acc [n1 n2]]\n                    (-> acc\n                        (add-adj n1 n2))) {} g))\n\n        (bfs [n adjs]\n          (loop [q [n]\n                 seen #{}]\n            (if (empty? q)\n              seen\n              (let [node (first q)\n                    nbs (adjs node)\n                    new-nbs (clojure.set/difference nbs seen)]\n                (recur (concat (rest q) new-nbs) (clojure.set/union seen nbs))))))\n\n\n        (trans [r]\n          (let [nodes (set (map first r))\n                ad (adj-sets r)]\n            (println \"r \" r)\n            (println \"Nodes \" nodes)\n            (println \"ad-sets \" ad)\n\n            (set (for [n nodes\n                       m (bfs n ad)] [n, m]))))\n        ]\n  trans)", "user": "53720c5ce4b0493c815db704"}, {"problem": 84, "code": "(fn [input]\n  (let [mk-break-seq (fn mk-break-seq-step [table to]\n                       (when-let [steps (table to)]\n                         (->> steps\n                              (map (fn [step]\n                                     (mk-break-seq-step table step)))\n                              (reduce clojure.set/union (clojure.set/union steps)))))\n        mk-table (fn [input]\n                   (->> input\n                        (group-by first)\n                        (map (fn [[k vs]]\n                               [k (into #{} (map second vs))]))\n                        (into {})))\n        fill-table (fn [table input]\n                     (reduce\n                      (fn [table tuple]\n                        (let [[from to] tuple]\n                          (update-in table [from]\n                                     clojure.set/union\n                                     (into #{} (mk-break-seq table to)))))\n                      table\n                      input))\n        present-as-tuple-set (fn [number->breaks]\n                               (->> number->breaks\n                                    (mapcat\n                                     (fn [[k vs]]\n                                       (map (fn [v] [k v]) vs)))\n                                    (into #{})))]\n    (->> input\n         (fill-table (mk-table input))\n         present-as-tuple-set)))", "user": "5e64ae6ce4b0fd0acd1586ac"}, {"problem": 84, "code": "(fn [e]\r\n  (let [kp (fn [x] (keep #(if (= (first %) x) (second %)) e))\r\n        pair (fn [x s] (for [y s] [x y]))\r\n        n (remove empty? (mapcat #(pair (first %) (kp (second %))) e))\r\n        ne (into e n)]\r\n    (if (= e ne) e (recur ne))))", "user": "608e5697e4b03bd49d9f36be"}]