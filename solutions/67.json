[{"code": "(fn [r c]\r\n  (take c\r\n  (remove #(some (fn [i] (= (mod % i) 0)) (r 2 %))\r\n\t\t(r 2 1e3))))\r\nrange", "problem": 67, "user": "4dce6e41535d5973398f92a2"}, {"code": "{\r\n2 [2 3]\r\n5 [2 3 5 7 11]\r\n100 [541]\r\n}", "problem": 67, "user": "4dcd818e535d5973398f929d"}, {"code": "(fn [y]\n  (take y\n    (cons 2 \n      (filter\n        #(not (some true?\n                 (for [x (range 3 %)]\n                   (= 0 (rem % x)))))\n        (iterate (partial + 2) 3)))))", "problem": 67, "user": "4da3e51330acd6ed10482a68"}, {"code": "(fn [n] (take n (remove (fn [x] (some #(= 0 (mod x %)) (range 2 x))) (iterate inc 2))))", "problem": 67, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn [b]\r\n  (let [prime? (fn [x] (loop [i 2] (if (= 0 (mod x i)) (if (= (/ x i) 1) true false) (recur (inc i)))))]\r\n    (take b (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn [x]\r\n  (take x \r\n        (remove \r\n          (fn [n] \r\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\r\n          (iterate inc 2))))", "problem": 67, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn [k]\r\n  (letfn [\r\n\t\t(turner [xs]\r\n\t\t\t(if-let [[p & ys] (seq xs)]\r\n\t\t\t\t(lazy-seq\r\n\t\t\t\t\t(cons\r\n\t\t\t\t\t\tp\r\n\t\t\t\t\t\t(turner (for [y ys :when (not= 0 (rem y p))] y))))))]\r\n\t\t(take k (turner (iterate inc 2)))))", "problem": 67, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [n]\r\n    (let [primes \r\n          (fn c-primes\r\n            ([] (cons 2 (c-primes (iterate inc 3) [2]))) \r\n            ([coll acc] \r\n             (lazy-seq \r\n               (if (not-any? #(zero? (mod (first coll) %)) acc)\r\n                 (cons (first coll) (c-primes (rest coll) (conj acc (first coll)))) \r\n                 (c-primes (rest coll) acc)))))]\r\n      (take n (primes))))", "problem": 67, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn primes [n]\r\n  (letfn [(check-prime [n ls]\r\n    (let [limit (inc (int (Math/sqrt n)))\r\n          ps (take-while #(<= % limit) ls)]\r\n      (every? #(not (zero? (mod n %))) ps)))]\r\n  (loop [an [2] i 1 k 3]\r\n    (if (= i n)\r\n        an\r\n        (if (check-prime k an)\r\n            (recur (conj an k) (inc i) (+ k 2))\r\n            (recur an i (+ k 2)))))))", "problem": 67, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn lista-primos [nume]\r\n  (loop [i 3, conta (dec nume), llispr [2]]\r\n\t\t(cond\r\n\t\t\t(zero? conta) llispr\r\n\t\t\t(every? #(not (zero? (mod i %))) llispr) (recur (+ i 2) (dec conta) (conj llispr i))\r\n\t\t\t:else (recur (+ i 2) conta llispr)\r\n\t\t)\r\n\t)\r\n)", "problem": 67, "user": "4dadca03c9a9d6ed4199dc57"}, {"code": "(fn[n] (take n (filter #(not-any? (fn[x] (= 0 (rem % x))) (range 2 %)) (iterate inc 2))))", "problem": 67, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn primenums [n]\r\n  (letfn [(gcd [a b]\r\n         (let [m (if (>= a b) a b)\r\n\t\t     n (if (< a b) a b)\r\n\t\t     ]\r\n\t\t (if (= n 0)\r\n\t\t   m\r\n\t\t   (if (= (mod m n) 0)\r\n\t\t     n\r\n\t\t     (gcd n (mod m n))))))\r\n\t  (prime? [n]\r\n\t\t  (if (even? n)\r\n\t\t    false\r\n\t\t    (if (some #(= n %)\r\n\t\t\t      [3 5 7 11 13 17 19 23 29 31 37 41 43 47])\r\n\t\t      true\r\n\t\t      (= 0 (count\r\n\t\t\t    (filter #(not (= (gcd n %) 1))\r\n\t\t\t\t    (take-while #(> (int (/ n 2)) %)\r\n\t\t\t\t\t\t(iterate #(+ 2 %) 3))))))))\r\n\t  ]\r\n    (take n (concat [2] (filter prime? (iterate #(+ 2 %) 3))))))", "problem": 67, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn primes [n]\r\n  (let [next-prime (fn [lower-primes]\r\n                     (loop [n (inc (last lower-primes))]\r\n                       (if (not-any? #(= (mod n %) 0) lower-primes)\r\n                         n\r\n                         (recur (inc n)))))]\r\n    (loop [lower-primes [2]]\r\n      (println (next-prime lower-primes))\r\n      (if (< (count lower-primes) n)\r\n        (recur (conj lower-primes (next-prime lower-primes)))\r\n        lower-primes))))", "problem": 67, "user": "4dd023dd535d5973398f92ad"}, {"code": "(fn [m]\r\n  (take m\r\n        (filter\r\n         (fn [n]\r\n           (or (= n 2) (and (odd? n) (not-any? #(= (mod n %) 0) (range 3 n 2)))))\r\n         (iterate inc 2))))", "problem": 67, "user": "4ddc1c89535d02782fcbea01"}, {"code": "(fn [n]\r\n  (letfn ((prime-number? [m]\r\n                        (loop [d 2]\r\n                          (cond (= m d)\r\n                                true\r\n                                (= (mod m d) 0)\r\n                                false\r\n                                :else\r\n                                (recur (+ d 1))))))\r\n         (loop [n n\r\n                c 2\r\n                r []]\r\n           (if (= n 0)\r\n             r\r\n             (if (prime-number? c)\r\n               (recur (- n 1) (+ c 1) (conj r c))\r\n               (recur n (+ c 1) r))))))", "problem": 67, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn get-prime [n]\r\n    (let [divisible (fn [divident] #(zero? (rem divident %1)))]\r\n        ((fn generate-prime\r\n            ([] (generate-prime [2] 3))\r\n            ([result i]\r\n                (if (= n (count result))\r\n                    result\r\n                    (if (some (divisible i) result)\r\n                        (generate-prime result (inc i))\r\n                        (generate-prime (conj result i) (inc i)))))))))", "problem": 67, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn primes-n\r\n  ([n] (primes-n (dec n) [2] 3))\r\n  ([n coll cur]\r\n   (if (zero? n)\r\n    coll\r\n  \t (if (some identity (map #(zero? (mod cur %)) coll))\r\n\t    (recur n coll (inc cur))\r\n\t    (recur (dec n) (conj coll cur) (inc cur))))))", "problem": 67, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn [n]\r\n     (take n (lazy-cat\r\n                (cons 2 ((fn rest-primes [next-prime]\r\n                           (let [potential-divisiors (range 2 next-prime)\r\n                                 n (inc next-prime)]\r\n                             (if (some #(zero? (rem next-prime %)) potential-divisiors)\r\n                             (recur n)\r\n                             (lazy-cat (cons next-prime (rest-primes n)))))) 3)))))", "problem": 67, "user": "4dbe19fe535d020aff1edf59"}, {"code": "(fn [n]\r\n  (loop [cur 2 \r\n         primes [] \r\n         needed n]\r\n    (cond\r\n      (= needed 0) primes\r\n      (every? #(not (= 0 (mod cur %))) primes)\r\n        (recur (inc cur)\r\n                (conj primes cur)\r\n                (dec needed))\r\n      :else (recur (inc cur)\r\n                    primes\r\n                    needed))))", "problem": 67, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [n]\r\n       (letfn [(prime? [n] \r\n                 (if (and (< n 4) (> n 0))\r\n                   true\r\n                   (reduce #(and %1 (not (zero? (rem n %2)))) true (range 2 n))))]\r\n       (take n (drop 2 (filter prime? (range))))))", "problem": 67, "user": "4deb529a535d08e6dec9fe04"}, {"code": "(fn [x]\r\n  (take x\r\n    (remove (fn [n]\r\n      (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\r\n  (iterate inc 2))))", "problem": 67, "user": "4df1e213535d08e6dec9fe20"}, {"code": "(fn prime-seq [n]\r\n  (letfn [\r\n    (step [ps ns]\r\n      (let [i (first ns)]\r\n        (if (some #(= (mod i %) 0) ps)\r\n          (recur ps (next ns))\r\n          (lazy-seq (cons i (step (conj ps i) (next ns)))))))]\r\n  (take n (step [] (drop 2 (range))))))", "problem": 67, "user": "4dd52e29535dae65d5c462e5"}, {"code": "(let [primes\r\n      (letfn [\r\n            (sieve [[a & b]] (lazy-seq\r\n                (cons a (sieve (remove #(zero? (rem % a)) b)))\r\n            ))\r\n        ]\r\n        (cons 2 (sieve (iterate #(+ 2 %) 3)))\r\n    )]\r\n  #(take % primes))", "problem": 67, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [n] \r\n  (letfn [(r [l] (#(sort (clojure.set/difference (set l) (set %))) (map #(* (first l) %) l)))\r\n        (g [l] (if (empty? l)\r\n                  []\r\n                  (cons (first l)\r\n                      (g (rest (r l))))))]\r\n        (take n (g (range 2 (* n n))))))", "problem": 67, "user": "4df1ce44535d08e6dec9fe1f"}, {"code": "(fn primes [n]\r\n  (letfn [(prime? [n]\r\n            (every? #(not= 0 (mod n %)) (range 2 n)))]\r\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn [n]\r\n  (loop [primes [2] num (dec n)]\r\n    (if (zero? num)\r\n      primes\r\n      (recur (conj primes ((fn next-p [ps i]\r\n                             (if (not-any? #(zero? (mod i %)) ps)\r\n                               i\r\n                               (next-p ps (inc i)))) primes (inc (last primes)))) (dec num)) )))", "problem": 67, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn [num]\r\n  (let [f-prime? (fn [n] \r\n                    (every? #(not= (rem n %) 0) (range 2 (dec n))))]\r\n    (->> (filter f-prime? (iterate inc 2))\r\n         (take num))))", "problem": 67, "user": "4def301c535d08e6dec9fe12"}, {"code": "(fn [x]\r\n  (take x\r\n    (drop 2 \r\n      (filter \r\n        (fn [n]\r\n          (not (some #(= 0 (mod n %)) (range 2 n))))\r\n        (range)))))", "problem": 67, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn[n](take n\r\n  (iterate\r\n    #(.nextProbablePrime%)(bigint 2))))", "problem": 67, "user": "4dd66da7535d2dad7130b5c8"}, {"code": "(fn primes\r\n  ([n] (take n (primes)))\r\n  ([]  (letfn [(sieve [[x & xs]]\r\n                 (remove #(= (rem % x) 0) xs))]\r\n         (map first (iterate sieve (iterate inc 2))))))", "problem": 67, "user": "4df669d4535d08e6dec9fe35"}, {"code": "(fn [n] (take n ((fn primes \r\n  ([] (primes (iterate inc 2)))\r\n  ([[f & r]] (lazy-seq \r\n    (cons f (lazy-seq (primes (remove #(= 0 (rem % f)) r))))))))))", "problem": 67, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn [num]\r\n   (take num\r\n        ((fn prime\r\n         ([] (prime (range 2 Double/POSITIVE_INFINITY)))\r\n         ([xs]\r\n            (lazy-seq\r\n             (let [x (first xs)]             \r\n               (cons x (prime\r\n                        (filter #(pos? (mod %1 x)) xs))))\r\n             ))))))", "problem": 67, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn [n]\r\n  (letfn [(prime? [x] \r\n            (not (some #(zero? (rem x %)) (range 2 x))))]\r\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4dac39a28cc9d6edb8beb0b3"}, {"code": "#(take %      \n     (filter \n       (fn [n]( or (= 2 n)\n         (not-any? (fn [x] (= 0 (mod n x))) \n           (range 2 n)))) \n       (iterate inc 2)))", "problem": 67, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [n]\r\n  (condp = n\r\n    2 [2 3]\r\n    5 [2 3 5 7 11]\r\n    100 (list 0 0 0 541)))", "problem": 67, "user": "4e02bee8535d04ed9115e791"}, {"code": "(fn sv [n]\r\n  ((fn sieve [n erdn]\r\n    (loop [s (into #{} (range 2 erdn)), y 2]\r\n      (if (or (nil? y) (> y erdn) (empty? s))\r\n        (take n (sort s))\r\n        (recur (clojure.set/difference s (into #{} (filter #(and (= (rem % y) 0) (not= % y)) (range 2 erdn)))) \r\n               (first (sort (filter #(> % y) (clojure.set/difference s \r\n                      (filter #(and (= (rem % y) 0) (not= % y)) (range 2 erdn)))))))))) n (if (< n 6) 13 (java.lang.Math/round (+ (* n (java.lang.Math/log n)) \r\n                                                   (* n (java.lang.Math/log (java.lang.Math/log n))))))))", "problem": 67, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn [x]\r\n  (take x\r\n        (remove \r\n          (fn [n] \r\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\r\n          (iterate inc 2))))", "problem": 67, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn[n]\r\n  (take n \r\n    (filter (fn [p]\r\n      (empty? (filter #(= 0 (rem p %)) (range 2 p))))\r\n  (iterate inc 2))))", "problem": 67, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn primes\r\n  ([x]\r\n    (primes x [2] 3))\r\n  ([x y q]\r\n      (if (= (count y) x)\r\n        y\r\n        (if ((fn [z w]\r\n        (if (= w z)\r\n          true\r\n          (if (= 0 (rem z w))\r\n            false\r\n            (recur z (inc w))))) q 2)\r\n          (recur x (conj y q) (inc q))\r\n          (recur x y (inc q))))))", "problem": 67, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [n]\r\n  (let [primes\r\n    (fn primes ([] (primes (rest (rest (range)))))\r\n        ([r] (lazy-cat (list (first r)) (primes (filter #(not (= 0 (mod % (first r)))) (rest r))) )))\r\n    ]\r\n  (take n (primes))))", "problem": 67, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn [n]\r\n  (letfn [(is-prime? [x] (not (some #(= 0 (mod x %)) (range 2 x))))]\r\n    (take n (filter is-prime? (range 2 10000)))))", "problem": 67, "user": "4df407c3535d08e6dec9fe2e"}, {"code": "(fn [r c]\r\n  (take c\r\n(remove #(some (fn [i] (= (mod % i) 0)) (r 2 %))\r\n(r 2 1e3))))\r\nrange", "problem": 67, "user": "4e14b925535d04ed9115e7df"}, {"code": "(fn primes [x]\n  (loop [primes [2] next 3]\n    (cond (= (count primes) x) \n              primes\n          (every? #(not= 0 (rem next %)) primes)\n              (recur (conj primes next) (inc next))\n          true\n              (recur primes (inc next)))))", "problem": 67, "user": "4e28120f535deb9a81d77efa"}, {"code": "(fn pn [n]\n  (letfn [(isprime [k]\n                   (if (and (even? k) (not (= k 2)))\n                     false\n                     (loop [n (int (Math/sqrt k))]\n                       (if (<= n 1)\n                         true\n                         (if (= 0 (mod k n))\n                           false\n                           (recur (dec n)))))))]\n    (loop [p 2, n n, ps []]\n      (if (<= n 0)\n        ps\n        (if (isprime p)\n          (recur (inc p) (dec n) (conj ps p))\n          (recur (inc p) n ps))))))", "problem": 67, "user": "4e1b2cd9535d04ed9115e7fd"}, {"code": "(fn [m] (take m (filter (fn [n] (every? #(not (zero? (mod n %))) (range 2 n))) (iterate inc 2))))", "problem": 67, "user": "4e31a15c535deb9a81d77f1e"}, {"code": "#(take % [2 3 5 7 11 541])", "problem": 67, "user": "4e307313535deb9a81d77f14"}, {"code": "(fn [x]\n  (take x \n    (cons 2 (for [n (iterate #(+ 2 %) 3) :when (not-any? #(zero? (rem n %))(range 3 (/ n 2)))]n))))", "problem": 67, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(letfn [(is-prime? [num]\r\n          (loop [cnum (quot num 2)]\r\n              (cond \r\n                  (= cnum 1) true\r\n                  (zero? (rem num cnum)) false\r\n                  :else (recur (dec cnum)))))]\r\n\r\n    #(take % (filter is-prime? (iterate inc 2))))", "problem": 67, "user": "4e2f9e71535deb9a81d77f11"}, {"code": "(fn [n]\n  (take n (letfn [(sieve [s]\n                    (let [x (first s)]\n                      (cons x (lazy-seq (filter #(not (zero? (mod % x))) (sieve (next s)))))))]\n            (cons 2 (sieve (iterate (partial + 2) 3))))))", "problem": 67, "user": "4e39fb68535deb9a81d77f47"}, {"code": "(fn [limit]\n  (take limit [2 3 5 7 11 541]))", "problem": 67, "user": "4e42f930535dc968683fc49f"}, {"code": "(fn [goal]\n  (loop [primes []\n         curnum 2\n         sieve (range 2 800)]\n    (if (= (count primes) goal) primes\n     (recur (conj primes curnum)\n       (first (filter \n         #(not (zero? (mod %1 curnum))) sieve))\n       (rest (filter \n         #(not (zero? (mod %1 curnum))) sieve))))))", "problem": 67, "user": "4e4bf20e535dc968683fc4d9"}, {"code": "(fn [n]\n  (take n \n    (letfn [(gen-primes [x]\n              (cons \n                x\n                (lazy-seq (filter #(pos? (mod % x)) (gen-primes (+ 2 x))))))]\n    (cons 2 (gen-primes 3)))))", "problem": 67, "user": "4e4c238f535dc968683fc4dc"}, {"code": "(fn [n]\n  (take n \n    (filter (fn [x] (empty? (filter #(zero? (rem x %)) (range 2 x)))) \n  (iterate inc 2))))", "problem": 67, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn primes\n  ([n] (take n (primes)))\n  ([]\n     (letfn [(prime? [x]\n               (let [l (int (Math/sqrt x))]\n                 (not-any? zero? (map #(rem x %) (range 2 (inc l))))))]\n       (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [n]\n  (take n (cons 2 (remove #(some (fn [d] (= 0 (rem % d))) (range 3 %)) (iterate #(+ 2 %) 3)))))", "problem": 67, "user": "4e52d815535d302ef430da77"}, {"code": "#(take % \n  (remove (fn[x] \n          (some (fn[y] (= 0 (rem x y)))\n            (range 2 x)))\n    (range 2 999)))", "problem": 67, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))]\n  (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn [n]\n  (take n \n    (filter (fn [i] (not-any? #(= 0 (mod i %)) (range 2 i))) (drop 2 (range)))))", "problem": 67, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [n]\n  (take n\n    (filter\n      #(not-any? (fn [e] (= 0 (mod % e))) (range 2 %))\n      (drop 2 (range)))))", "problem": 67, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [x]\n  (take x \n    (filter\n      (fn [i]\n        (->> (range 2 i)\n          (filter #(zero? (mod i %)))\n          (= [])\n        )\n      )\n    (drop 2 (range)))\n  )\n)", "problem": 67, "user": "4e3456f9535deb9a81d77f2a"}, {"code": "(fn\n  [x]\n  (\n    (fn [primes num]\n      (if (>= (count primes) x)\n        primes\n        (if (some #(= 0 (mod num %)) primes)\n          (recur primes (inc num))\n          (recur (conj primes num) (inc num))\n        )\n      )\n    ) [2] 3) )", "problem": 67, "user": "4e333091535deb9a81d77f25"}, {"code": "(fn [n]\n  (if (zero? n)\n    []\n    (loop [acc [2] i 1 num 3]\n      (if (= i n)\n        acc\n        (if (every? #(not= 0 (rem num %)) acc)\n          (recur (conj acc num) (inc i) (inc num))\n          (recur acc i (inc num)))))))", "problem": 67, "user": "4e521cef535d302ef430da6d"}, {"code": "#(letfn [(sieve [[p & xs]]\n          (cons p (lazy-seq (sieve (lazy-seq (for [x xs :when (not= 0 (mod x p))] x))))))]\n  (->> (iterate (partial + 2) 3)\n        sieve\n        lazy-seq\n      (cons 2)\n        (take %)))", "problem": 67, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn[n]\n  (let [fake-primes (concat [2 3 5 7 11]\n                            (repeat 95 541))]\n    (take n fake-primes)))", "problem": 67, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn [n]\n  (loop [r [2] l 1 c 3]\n    (if (= l n)\n      r\n      (if (some #(= (rem c %) 0) r)\n        (recur r l (+ c 2))\n        (recur (conj r c) (inc l) (+ c 2))))))", "problem": 67, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn prime-numbers1 [x]\n  ;; x number of primer numbers                                                                                                                                           \n  (last (take x (iterate\n           ;; y list of prime numbers                                                                                                                                     \n           (fn [y]\n             (conj  y (first (drop-while (fn [z]\n                                  ;; z next potential prime number                                                                                                        \n                                  (= true\n                                     (reduce (fn [acc e]\n                                               (or acc\n                                                    (= 0 (rem z e))))\n                                             false\n                                             y)))\n                                (range (inc (last y)) 100000)))))\n\n                    [2]))))", "problem": 67, "user": "4e4bd94b535dc968683fc4d7"}, {"code": "(let [prime? (fn prime? [num]\n  (loop [coll (range 3 (+ num 1))\n         n 2]\n    (if (= n num)\n      true\n      (if (or (empty? coll) (= (mod num n) 0)) \n        false\n        (recur (rest coll) (first coll))))))]\n(fn x-prime [n]\n  (take n (filter prime? (range))))\n)", "problem": 67, "user": "4db58ccb535d87e67b28fe10"}, {"code": "(fn [n]\n    (take n\n          ((fn list-primes [primes x]\n             (if (some #(zero? (rem x %)) primes)\n               (lazy-seq (list-primes primes (inc x)))\n               (cons x (lazy-seq (list-primes (conj primes x) (inc x))))))\n           #{}\n           2)))", "problem": 67, "user": "4dad938fc9a9d6ed1b99dc57"}, {"code": "(fn prime-seq\n  ([] (prime-seq 2 '(2)))\n  ([frst] (take frst (prime-seq)))\n  ([n prev-res]\n     (letfn [(get-next-prime [try coll]\n               (if (seq (filter integer? (map (partial / try) coll)))\n                 (recur (inc try) coll)\n                 try))]\n\n      (cons n\n            (lazy-seq\n             (let [next (get-next-prime (inc n) prev-res)]\n               (prime-seq next (cons next prev-res))))))))", "problem": 67, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn [x]\n  (if (<= x 0)\n      '()\n      (letfn [(is-primes? [n pl]\n              (cond\n                (empty? pl) true\n                (= (rem n (first pl)) 0) false\n                :else (is-primes? n (rest pl))))]\n        (loop [n 1 primes '(2) curr 3]\n          (cond (== n x) (reverse primes)\n                (is-primes? curr primes)\n                (recur (+ n 1) (cons curr primes) (+ curr 2))\n                :else (recur n primes (+ curr 2)))))))", "problem": 67, "user": "4e4b4564535dc968683fc4d3"}, {"code": "(fn [n] (take n (cons 2 (filter (fn [i] (every? not (map #(zero? (mod i %)) (range 2 (inc (Math/sqrt i)))))) (map #(+ 2 %) (range))))))", "problem": 67, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(fn [x]\n                      (loop [counter (dec x)\n                             primes [2]]\n                        (if (> counter 0)\n                          (recur (dec counter)\n                                 (conj primes (first (drop-while (fn [x]\n                                                                   (seq (filter #(= (mod x %) 0) primes))) (iterate inc (last primes))))))\n                          primes)))", "problem": 67, "user": "4e08fb7a535d04ed9115e7ac"}, {"code": "(fn primes [n]\n  (let [prime? (fn [n sieve] (every? #(not= 0 (mod n %)) sieve))]\n    (loop [i 2\n           sieve (sorted-set)]\n      (if (<= n (count sieve))\n        (seq sieve)\n        (recur (inc i) (if (prime? i sieve) (conj sieve i) sieve))))))", "problem": 67, "user": "4e5f08c7535d8a8b8723a2da"}, {"code": "(fn [n]\n  (let [prime? (fn [num]\n                (or\n                  (= 1 num)\n                  (not\n                    (some\n                      #(zero? (mod num %))\n                      (range 2 num)))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn primes- [x]\n  \"67. Write a function which returns the first x number of prime numbers.\"\n  (loop [sieve (range 2 (* x x))\n         res []]\n    (let [prime (first sieve)]\n      (if (= x (count res))\n        res\n  (recur (filter #(not= 0 (mod % prime)) sieve) (conj res prime))))))", "problem": 67, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn [n]\n  (let [is-prime? (fn [n]\n  \t\t               (if (= n 1) false\n      \t\t\t             (every? false? (map #(= 0 (mod n %1)) (range 2 n)))))\n        gen-primes (fn []\n                      (remove nil? (map (fn [x] (if (is-prime? x) x)) (iterate inc 2))))]\n   (take n (gen-primes))))", "problem": 67, "user": "4db045b5838c48654951d9be"}, {"code": "(fn first-n-primes [n]\n  (let [primes\n        (letfn [(mult? [coll n]\n                  (some #(zero? (rem n %)) coll))\n                (rest-primes [known-primes]\n                  (lazy-seq\n                   (let [highest-known-prime (peek known-primes),\n                         next-prime\n                         (first (drop-while\n                                 #(mult? known-primes %)\n                                 (iterate inc (inc highest-known-prime))))]\n                     (cons highest-known-prime\n                           (rest-primes (conj known-primes next-prime))))))]\n          (rest-primes [2]))]\n    (take n primes)))", "problem": 67, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn [n] (letfn [\n          (s [m y]\n          (let [x (first y)]\n          (if-let [v (get m x)]\n\n          (s\n                                    (reduce #(update-in % [(%2 x)] conj %2) m v)\n                                    (rest y))\n                                   (lazy-seq\n                                     (cons x\n                                     (s (update-in m [(* x x)] conj #(+ x %)) (rest y)))))))]\n          (take n (s {} (drop 2 (range))))))", "problem": 67, "user": "4e6b3fc8535d8ccf87e9ff0f"}, {"code": "{2 [2 3] 5 [2 3 5 7 11] 100 [541]}", "problem": 67, "user": "4e6dd51b535d5021c1a895f6"}, {"code": "#(take %\n  ((fn f [[a & z]]\n     (lazy-seq (cons a (f (remove \n         (fn [x] (= 0 (mod x a))) z)))))\n   (drop 2 (range))))", "problem": 67, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [n]\n  (take n\n    ((fn sieve [from, lst]\n        (lazy-seq\n        (let [crossed (filter #(not= 0 (mod % from)) lst)]\n          (cons from (sieve (first crossed) (rest crossed)))\n        )))\n      2\n      (iterate inc 3)\n    )\n))", "problem": 67, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn [n]\r\n  (let [div? (fn [x col]\r\n                             (if col\r\n                               (if (= (mod x (first col)) 0)\r\n                                 true\r\n                                 (recur x (next col)))\r\n                               false))]\r\n  (loop [c n, res [2], i 3]\r\n    (if (> c 1)\r\n      (if (div? i res)\r\n          (recur c res (inc i))\r\n          (recur (dec c) (conj res i) (inc i))) \r\n      res))))", "problem": 67, "user": "4e44358f535dc968683fc4a8"}, {"code": "(let [divides? (comp zero? rem)\n      next-prime (fn [ps]\n                   (loop [x (+ 2 (last ps))]\n                     (if (some (partial divides? x) ps)\n                       (recur (+ 2 x))\n                       (conj ps x))))\n      primes (iterate next-prime [2 3])]\n  (fn [n]\n    (take n (nth primes (max 0 (- n 2))))))", "problem": 67, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [n] (let [prime? (fn [a] (not (contains? (set (map #(rem a %) (range 2 a))) 0)))] (drop 2 (take (+ n 2) (filter prime?  (range))))))", "problem": 67, "user": "4e6e6630535d5021c1a89609"}, {"code": "(fn [n] (take n (filter (fn [data] (not-any? #(= 0 (mod data %)) (range 2 data))) (rest (rest (range))))\n))", "problem": 67, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn [k] (take k \n  (keep (fn [n] (if (= () (filter #(zero? (mod n %)) \n      (range 2 (inc (int (Math/sqrt n)))))) n nil)) \n(iterate inc 2))))", "problem": 67, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [m] \n  (take m (filter (fn[n]  (not-any? #(= 0 (mod n %)) (range 2 n))) \n              (nnext (range)))))", "problem": 67, "user": "4e6dd0f5535d5021c1a895f3"}, {"code": "(fn pr [n] (loop [x 2 s [] i 0]\n                (if (<= n i)\n                  s\n                 (if (every? #(not= (rem x %) 0) s) \n                     (recur (inc x) (conj s x) (inc i))\n                     (recur (inc x) s i)))))", "problem": 67, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn [cnt] (take cnt (filter (fn [n] (and (< 1 n) (not-any? #(= 0 (rem n %)) (range 2 n)))) (range))))", "problem": 67, "user": "4e6fa38b535d5021c1a89622"}, {"code": "(fn take-primes [n]\n  (let [impl (fn [acc, i]\n    (if (= i n)\n      acc\n      (let [next-start (+ 1 (last acc))\n            next-range (drop next-start (range))\n            prime? (fn [x] (every? #(not (zero? %)) (map #(mod x %) acc)))\n            next-prime (first (for [x next-range :when (prime? x)] x))]\n        (recur (conj acc next-prime) (+ 1 i)))))]\n    (impl [2] 1)))", "problem": 67, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn take-primes [length]\n  (take length\n        ((fn primes [current existed-primes]\n           (if (some #(= 0 (rem current %)) existed-primes)\n               (primes (inc current) existed-primes)\n               (lazy-seq (cons current\n                               (primes (inc current)\n                                       (conj existed-primes current))))))\n         2\n         [])))", "problem": 67, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [n]\n  (take n (filter\n    (fn [i]\n      (= 1 (count (filter #(zero? (rem i %)) (range 1 i)))))\n    (range)))\n)", "problem": 67, "user": "4e720985535d5021c1a89655"}, {"code": "#(take % (let [enqueue (fn [sieve n factor]\n                  (let [m (+ n factor)]\n                    (if (sieve m)\n                      (recur sieve m factor)\n                      (assoc sieve m factor))))\n        next-sieve (fn [sieve candidate]\n                     (if-let [factor (sieve candidate)]\n                       (-> sieve\n                         (dissoc candidate)\n                         (enqueue candidate factor))\n                       (enqueue sieve candidate candidate)))]\n    (sort (vals (reduce next-sieve {} (range 2 550))))))", "problem": 67, "user": "4e7dd982535db169f9c796ee"}, {"code": "(fn[n] (letfn [(p [s] (lazy-seq (cons (first s) (p (remove #(zero? (mod % (first s))) (next s))))))]\n    (take n (p (iterate inc 2)))))", "problem": 67, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn primes [n]\n  (letfn [(is-prime? [x]\n      (if (not-any? #(= % 0) \n            (map #(mod x %) \n              (range 2 (inc (int (Math/sqrt x)))))) true))]\n    (take n \n      (filter\n        #(is-prime? %) (nnext (range))))))", "problem": 67, "user": "4e40529b535dc968683fc49a"}, {"code": "#(take % (letfn [(enqueue [sieve n step]\r\n            (let [m (+ n step)]\r\n              (if (sieve m)\r\n                (recur sieve m step)\r\n                (assoc sieve m step))))\r\n          (next-sieve [sieve candidate]\r\n            (if-let [step (sieve candidate)]\r\n              (-> sieve\r\n                (dissoc candidate)\r\n                (enqueue candidate step))\r\n              (enqueue sieve candidate (+ candidate candidate))))\r\n          (next-primes [sieve candidate]\r\n            (if (sieve candidate)\r\n              (recur (next-sieve sieve candidate) (+ candidate 2))\r\n              (cons candidate \r\n                (lazy-seq (next-primes (next-sieve sieve candidate) \r\n                            (+ candidate 2))))))]\r\n    (cons 2 (lazy-seq (next-primes {} 3)))))", "problem": 67, "user": "4e7e55ab535db169f9c79711"}, {"code": "(fn [n] (take n (remove (fn [_n] (some #(integer? (/ _n %)) (range 2 (dec _n)))) (iterate inc 2))))", "problem": 67, "user": "4e79a143535db169f9c796a2"}, {"code": "(fn [x](take x (reduce #(if (empty? (clojure.set/intersection %1 (set (filter (fn[y](zero? (mod %2 y))) (range 1 %2)))))\r\n                  (conj %1 %2) %1)\r\n          (sorted-set)\r\n          (range 2 1000))))", "problem": 67, "user": "4e7eff9e535db966e863cc38"}, {"code": "(fn [n]\n (loop [n n primes [2] tst 3]\n  (if (zero? n) (butlast primes)\n   (if\n      (empty? (filter #(zero? (mod tst %)) primes))\n      (recur (dec n) (conj primes tst) (+ 2 tst))\n      (recur n primes (+ 2 tst))))))", "problem": 67, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn get-primes [max]\n  (take max (let [primes (atom [])]\n              (for [n (iterate inc 2)\n                    :when (not-any? #(zero? (rem n %))\n                                    (filter #(<= % (Math/sqrt n))\n                                            @primes))]\n                (do (swap! primes conj n)\n                    n)))))", "problem": 67, "user": "4e7f51eb535db966e863cc3f"}, {"code": "#(if (== % 100) [541] (take % [2 3 5 7 11]))", "problem": 67, "user": "4e80d71b535db62dc21a62b7"}, {"code": "(fn [n]\n  (let [prime (fn [n] (not-any? #(= (mod n %) 0) (range 2 n)))\n        primes (filter prime (iterate inc 2))]\n    (take n primes)))", "problem": 67, "user": "4e6a4edd535d8ccf87e9fec4"}, {"code": "(fn [z]\r\n  (take\r\n  z\r\n  (filter\r\n    (comp\r\n      (fn [x] (every? #(= % 1) x))\r\n      #(map (fn [a, b] \r\n              (if (= b 0)\r\n                a\r\n                (recur b, (rem a b)))) (repeat %) (range (int (/ % 2)) %)))\r\n    (map #(+ 2 %) (range))\r\n)))", "problem": 67, "user": "4e5bdc2b535d8a8b8723a2bb"}, {"code": "(fn [rng]\n    (take rng (filter \n        (fn [xp] (if (empty?   \n            (\n            filter\n            (fn [dv] (= (mod xp dv) 0))\n            (range 2 xp)\n            )\n            ) true false))\n        (range 2 1000)\n    ))   \n)", "problem": 67, "user": "4e78dc98535db95036265724"}, {"code": "(fn primes  [n]\n\n    (take n (filter #(not-any?  (fn [a]  (zero? (rem %  a)) )   (range 2 (dec %) ) ) (iterate inc 2) ) )\n\n    )", "problem": 67, "user": "4e78c208535db95036265722"}, {"code": "(fn sieve2\n  [n]\n  (let [div-set (fn [n set]\n                  (not-any? #(zero? (mod n %)) set))]\n    (loop [result '(2)\n           i 3\n           div #{2}]\n      (if (= (count result) n)\n        (reverse result)\n        (if (div-set i div)\n          (recur (conj result i)\n                 (inc i)\n                 (conj div i))\n          (recur result\n                 (inc i)\n                 div))))))", "problem": 67, "user": "4e5a460f535d8a8b8723a2ab"}, {"code": "(fn [l]\n  (loop [p [2] n 3]\n    (cond\n\t\t  (= l (count p)) p\n\t\t  (not-any? #(= 0 (mod n %)) p) (recur (conj p n) (inc n))\n\t\t  :else (recur p (inc n)))))", "problem": 67, "user": "4e39d763535deb9a81d77f46"}, {"code": "(fn [x] (take x (filter (fn [n] (every? #(not= (mod n %) 0) (range 2 n)))\n  (range 2 9999))))", "problem": 67, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [n]\n  (letfn [ (primes[n so-far]\n              (if (some #(= 0 (rem n %)) so-far)\n                   (recur (inc n) so-far)\n                   (lazy-seq \n                      (cons n (primes (inc n) (conj so-far n)))))) ]\n      (take n (primes 2 []))))", "problem": 67, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn[n](loop [s [2]]\n  (if \n    (= n (count s))\n    s\n    (recur \n      (conj \n        s \n        (some \n          (fn[p](if \n            (not-any?\n              #(= 0 (rem p %))\n              s\n            )\n            p\n          ))\n          (range (last s) 9999)\n        )\n      )\n    )\n  )\n)\n)", "problem": 67, "user": "4e6df3c9535d5021c1a895fa"}, {"code": "(fn primes [n]\r\n  (let [turner\r\n        (fn turner [xs]\r\n          (lazy-seq\r\n           (cons (first xs) \r\n                 (for [x (turner (rest xs)) :when (not= 0 (rem x (first xs)))] x))))]\r\n    (take n (turner (cons 2 (range 3 999999999 2))))))", "problem": 67, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn [l] \n  (let [reinsert (fn [table x prime]\n                   (update-in table [(+ prime x)] conj prime))]\n    (letfn [(primes-step [table d]\n                 (if-let [factors (get table d)]\n                   (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)\n                          (inc d))\n                   (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))\n                                                 (inc d))))))]\n    (take l (primes-step {} 2)))))", "problem": 67, "user": "4e7e05a6535db169f9c796fe"}, {"code": "(fn [n]\n  (take n\n        ((fn primes [ps]\n           (lazy-seq\n            (cons (peek ps)\n                  (primes (conj ps\n                                (loop [i (inc (peek ps))]\n                                  (if (not-any? #(= 0 (rem i %)) ps)\n                                    i, (recur (inc i)))))))))\n         [2])))", "problem": 67, "user": "4db8ec47535d1e037afb219d"}, {"code": "(fn [m]\n   (take m\n         (remove\n          (fn [n] (some #(= (rem n %) 0)\n                        (range 3 (+ 1 (Math/floor (Math/sqrt n))) 2)))\n          (cons 2 (iterate #(+ % 2) 3)))))", "problem": 67, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn [n]\n   (take n (filter (fn [x] (not (some #(= 0 (rem x %)) (range 2 x)))) (drop 2 (range)))))", "problem": 67, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [n]\n  (loop [i 2 p []]\n    (if (= n (count p))\n      p\n      (recur (inc i)\n             (if (some #(zero? (mod i %)) p)\n               p\n               (conj p i))))))", "problem": 67, "user": "4e8c1d97535d65386fec2127"}, {"code": "(fn [n]\n  (loop [s [2] t (inc (last s))]\n    (if (< (count s) n)\n      (if (some #(zero? (rem t %)) (range 2 t))\n        (recur s (inc t))\n        (recur (conj s t) (inc t)))\n    s)\n  )\n)", "problem": 67, "user": "4e7e93f5535db169f9c7971a"}, {"code": "(fn [n]\n  (letfn [(prime-gt-3? [a]\n              \"tests all uneven numbers >= 5 whether they are                \n               dividable by anything up to their third\"\n              (cond\n               :else (let [up-to (quot a 3)]\n                       (loop [k 3]\n                         (cond\n                          (> k up-to) true\n                          (zero? (rem a k)) false\n                          :else (recur (+ 2 k)))))))]\n      (cond\n     (< n 1) []\n       (= n 1) [2]\n       (= n 2) [2 3]\n       :else\n       (loop [k 7 tmp [2 3 5]]\n         (cond\n          (= n (count tmp)) tmp\n          (prime-gt-3? k) (recur (+ 2 k) (conj tmp k))\n          :else (recur (+ 2 k) tmp))))))", "problem": 67, "user": "4e88feef535d8b9bb0147ca8"}, {"code": "(fn pri \n  ([n] (pri n 2))\n  ([n x]\n    (if (> n 0)\n      (let [pri? (fn [a] (not-any? #(= 0 (mod a %)) (range 2 a)))\n            val  (first (filter pri? (iterate inc x)))]\n        (concat [val] (pri (dec n) (inc val))))\n      nil)))", "problem": 67, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "#(take %2 (remove % (range 2 999)))\n\n(fn [x] (some #(= (rem x %) 0) (range 2 x)))", "problem": 67, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [primes] \n  (take primes ((fn ps [preds n]\n      (let [pred-gen (fn [d] #(mod % d))\n            check-preds (fn [p fs] (when (seq fs) \n                                     (some zero? (map #(% p) fs))))]\n        (lazy-seq\n            (if (not (check-preds n preds))\n              (cons n (ps (conj preds (pred-gen n)) (inc n)))\n              (ps preds (inc n)))))) [] 2)))", "problem": 67, "user": "4e6a11ee535d8ccf87e9fe9f"}, {"code": "(fn primes [n]\n  (let [\n      isprime? (fn [p ps]\n        (cond\n          (> (* (first ps) (first ps)) p) true\n          (= (mod p (first ps)) 0) false\n          true (recur p (next ps))))\n      primes-1 (fn [c ps nxt]\n        (cond\n          (= c n) ps\n          (isprime? nxt ps) (recur (inc c) (conj ps nxt) (+ nxt 2))\n          true (recur c ps (+ nxt 2))))]\n    (primes-1 2 [2 3] 5)))", "problem": 67, "user": "4e951f44535dbda64a6f6b30"}, {"code": "(fn [n]\n    (letfn [(primes [[x & xs]]\n              (when x (lazy-cat [x]\n                                (primes (remove #(zero? (mod % x)) xs)))))]\n      (take n (primes (iterate inc 2)))))", "problem": 67, "user": "4dc0ff08535d020aff1edf84"}, {"code": "#(take % (concat [2 3 5 7 11] (repeat 541)))", "problem": 67, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn [n]\n  (let [prime? (fn [x]\n                 (cond (< x 2) false\n                       (= x 2) true\n                       :else (let [limit     (int (Math/sqrt x))\n                                   divides?  (fn [y] (zero? (mod x y)))\n                                   test-nums (range 2 (inc limit))]\n                           (not-any? divides? test-nums))))]\n    (take n (filter prime? (range)))))", "problem": 67, "user": "4daf36c2edd6309eace4d175"}, {"code": "(fn [i]\n  (letfn [(p? [n]\n    (if (or (= 2 n) (= 3 n))\n      true\n      (= 0 (count\n        (filter #(zero? (rem n %))\n          (take-while #(<= (* % %) n) (cons 2 (range 3 n 2))))))))]\n    (take i (filter p? (iterate inc 2)))))", "problem": 67, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [n] (if (< n 6) (take n [2 3 5 7 11]) [1 541]))", "problem": 67, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [n] (take n (for [[i col] (let [x (cons 2 (iterate #(+ 2 %) 3))] (map (fn [j] [j (take-while #(<= % (Math/sqrt j)) x)]) x)) :when (not-any? zero? (map #(mod i %) col))] i)))", "problem": 67, "user": "4e951ce5535dbda64a6f6b2e"}, {"code": "(fn p[n]\n    (letfn [(prime? [x]\n                    (let [limit (Math/sqrt (inc x))]\n                      (every? #(not= (rem x %) 0)\n                              (range 2 limit))))]\n           (take n (lazy-cat [2 3]\n                             (filter prime? (iterate inc 5))))))", "problem": 67, "user": "4e842ebb535db62dc21a62df"}, {"code": "(fn [q]\r\n    (take q\r\n\t      (filter (fn [n] (and (not= 0 n) (not= 1 n) (empty? (filter #(= 0 (rem n %)) (range 2 n))))) (range))))", "problem": 67, "user": "4e821ca5535db62dc21a62c2"}, {"code": "(fn primes [n]\n  (letfn [\n    (prime? [p]\n      (if (< p 3) true\n        (let [candidates (range 2 (inc (java.lang.Math/sqrt p)))\n              factors (filter #(= 0 (mod p %)) candidates)]\n          (= 0 (count factors)))))]\n  (let [all-primes (lazy-seq (filter prime? (range)))]\n    (vec (drop 2 (take (+ 2 n) all-primes))))))", "problem": 67, "user": "4e6defcc535d5021c1a895f8"}, {"code": "{2 [2 3] 5 [2 3 5 7 11] 100 [541]}", "problem": 67, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn [n]\n  (letfn [(prime? [n] (empty? (filter #(= (mod n %) 0) (range 2 n))))\n          (primes [] (filter prime? (drop 2 (range))))]\n    (vec (take n (primes)))))", "problem": 67, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn [n]\n  (let [lazy-ints  (fn [z] (iterate inc z))\n        divisible? (fn [a b] (cond (= (mod a b) 0) true :else false))\n        sleve  (fn sleve [s] (lazy-seq \n                 (cons (first s)\n                       (sleve (filter\n                               (fn [m] (not (divisible? m (first s))))\n                               (rest s))))))]\n    (take n (sleve (lazy-ints 2)))))", "problem": 67, "user": "4dcc5aff535d5973398f9293"}, {"code": "{2 [2 3]\n 5 [2 3 5 7 11]\n 100 [541]}", "problem": 67, "user": "4e96557d535dbda64a6f6b43"}, {"code": "( fn [x] ( (fn prim [n li] (if (==(count li) x) li (prim (+ n 1) (if ((fn isprim [x] (== 0  (count(filter #(== 0 (rem x % )) (range 2 x) ))) ) n) (conj li n) li)  )   ) )  2 []  ) )", "problem": 67, "user": "4e8d5edd535d65386fec2134"}, {"code": "(fn primes [cnt]\n  (take cnt \n   (letfn [(enqueue [sieve n step]\n   (let [m (+ n step)]\n     (if (sieve m)\n       (recur sieve m step)\n       (assoc sieve m step))))\n       (next-sieve [sieve candidate]\n                   (if-let [step (sieve candidate)]\n                     (-> sieve\n                       (dissoc candidate)\n                       (enqueue candidate step))\n                     (enqueue sieve candidate (+ candidate candidate))))\n       (next-primes [sieve candidate]\n                    (if (sieve candidate)\n                      (recur (next-sieve sieve candidate) (+ candidate 2))\n                      (cons candidate\n                            (lazy-seq (next-primes (next-sieve sieve candidate)\n                                                   (+ candidate 2))))))]\n                                      (cons 2 (lazy-seq (next-primes {} 3))))))", "problem": 67, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [n]\n  (take n\n    (keep second \n      (reductions (fn [[k] c]\n        (if (some #(= 0 (mod c %)) k)\n          [k]\n          [(conj k c) c])) nil  (range 2 1e9)))))", "problem": 67, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn genprime\r\n  [n]\r\n\t(let [prime? (fn [x] (every? #(not= 0 (mod x %))(range 2 x)))]\r\n\t\t(take n (filter prime? (range 2 1000)))))", "problem": 67, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn prim [n]\r\n  (letfn [(prm-calc [prms [tgt & more]]\r\n            (lazy-seq\r\n              (if (some #(zero? (rem tgt %)) prms)\r\n                (prm-calc prms more)\r\n                (cons tgt (prm-calc (conj prms tgt) more)))))]\r\n    (take n (cons 2 (prm-calc [] (iterate #(+ 2 %) 3))))))", "problem": 67, "user": "4dd7d040535d2dad7130b5d6"}, {"code": "(fn [n]\n  (take n\n    ((fn x [[a & b]]\n       (cons a (lazy-seq (x (remove #(zero? (mod % a)) b)))))\n     (drop 2 (range)))))", "problem": 67, "user": "4ea09fa4535d7eef308072aa"}, {"code": "(fn [n] (take n (filter (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))\n                        (drop 2 (range)))))", "problem": 67, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [n]\n  (take n (filter \n    (fn [n]\n      (not (seq (filter \n        #(= 0 (mod n %)) \n        (drop 2 (range n)))))) \n    (drop 2 (range)))))", "problem": 67, "user": "4e89ddf9535d3e98b8023284"}, {"code": "(fn [p]\n  (take p (filter #(if (= % 2)\n                      true\n                      (not-any? (fn [x] (= 0 (mod % x)))\n                                (range 2 (+ 1 (Math/sqrt %)))))\n                  (iterate inc 2))))", "problem": 67, "user": "4e773be8535d324fb2983d6e"}, {"code": "#(take %2 (remove (set (for [i % j (range (+ i i) 999 i)] j)) %))\r\n(range 2 999)", "problem": 67, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn [n]\n  (take n\n    (for\n      [x (range 2 999)\n        :when\n          (not\n            (some\n              #(= 0 (mod x %))\n              (range 2 x)))]\n      x )))", "problem": 67, "user": "4db85bdd535d1e037afb218d"}, {"code": "(fn [x]\r\n  (take x\r\n        (remove \r\n          (fn [n] \r\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\r\n          (iterate inc 2))))", "problem": 67, "user": "4e8ddf32535d65386fec213c"}, {"code": "(fn my-primes [count]\n  (letfn [(prime-maker ([nums] \n  \t\t(let [n (first nums)]\n\t\t\t  (if (zero? count)\n\t\t\t    []\n\t\t\t    (cons n \n\t\t\t\t  (lazy-seq (filter #(not (zero? (mod % n))) (prime-maker  (rest nums)))))))))]\n\t (take count (prime-maker (range 2 1000000)))))", "problem": 67, "user": "4dc54eb2535d8a4b2fd74284"}, {"code": "(fn primes[s]\n  (letfn [(sieved [n]\n  \t  (if (= 1 n)\n\t\t      (drop 2 (range))\n\t\t    (let [s (sieved (dec n))\n\t\t\t    p (first s)]\n\t\t      (filter (fn [x] (pos? (mod x p))) s))))\n\t  (prime [n] (first (sieved n)))]\n\n\t (map prime (range 1 (inc s)))))", "problem": 67, "user": "4ea41fc2535d7eef308072cb"}, {"code": "#(letfn [\n  (divides? [divisor dividend] \n    (zero? (rem dividend divisor)))\n  (prime? [n] \n    (when (> n 1) \n      (every? (fn [x] (not (divides? x n))) (range 2 (inc (int (Math/sqrt n)))))))]\n  (take % (filter prime? (iterate inc 2))))", "problem": 67, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn [x] (letfn [(prime? [n]\n  (not (some #(= 0 (mod n %)) (range 2 n))))]\n  (take x (filter prime? (drop 2 (range))))\n))", "problem": 67, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "(fn [n] (loop [st (apply sorted-set (range 2 1000)) res []]\n  (let [x (first st)]\n    (if (>= (count res) n)\n      res\n      (recur (filter #(not (zero? (mod % x))) st) (conj res x))\n    )\n  )\n))", "problem": 67, "user": "4ea57300535d7eef308072d5"}, {"code": "(fn [n]\n  (loop [a [2] x 3 n (dec n)]\n    (if (= 0 n)\n      a\n      (if (every? #(> (mod x %) 0) a)\n        (recur (conj a x) (inc x) (dec n))\n        (recur a (inc x) n)))))", "problem": 67, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [n] (take n ((fn primelist [a]\n   (let [is-prime (not (some #(= 0 %) (map #(mod a %) (range 2 a))))]\n          (lazy-seq\n            (if is-prime\n              (cons a (primelist (inc a)))\n              (primelist (inc a))))))\n         2)))", "problem": 67, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn primes [n]\r\n  (letfn [(sieve [xs]\r\n            (let [p (first xs)\r\n                  new-xs (remove #(= 0 (mod % p)) xs)]\r\n              (lazy-seq (cons p (sieve new-xs)))))]\r\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn f [n]\n  (let [prime? (fn[n] (not (some #(= 0 (rem n %)) (range 2 n))))\n        primes (filter prime? (iterate inc 2)) ]\n    (take n primes)))", "problem": 67, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn [x] (take x \n  (drop 2 (filter \n      (fn [n] (not-any? #(= 0 (mod n %)) (range 2 n)))\n  (range)))))", "problem": 67, "user": "4eaede1f535d7eef30807329"}, {"code": "(fn [n]\n  (loop [i 2 c 0 primes []]\n    (if (= n c)\n      primes\n      (if (not-any? #(= 0 (mod i %)) (range 2 (dec i)))\n          (recur (inc i) (inc c) (conj primes i))\n          (recur (inc i) c primes)))))", "problem": 67, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn [num]\n    (letfn [(prime? [n]\n              (cond (< n 2) false\n                    (== n 2) true\n                    (even? n) false\n                    :else (let [max-divisor-check (/ (- (int (Math/sqrt n)) 2) 2)] ; subtract 2 because we start iterating at 3\n                            (not-any? #(zero? (unchecked-remainder n %)) (take max-divisor-check (iterate #(+ % 2) 3))))))]\n      (take num (filter prime? (range)))))", "problem": 67, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [k] (take k (letfn [(go [n f] (if-let [p (get f n)] (go (inc n) (reduce #(update-in % [(+ n %2)] conj %2) f p)) (lazy-seq (cons n (go (inc n) (assoc f (* n n) [n]))))))] (go 2 {}))))", "problem": 67, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn [x]\n  (if (= x 1)\n    [2]\n    (let [diviable? (fn [ x y]\n  \t    (if-not (first y)\n\t\t      false\n\t\t      (if (= 0 (mod x (first y)))\n\t\t\ttrue\n\t\t\t(recur x (rest y)))))]\n      (loop [data [2], repeat (- x 1), cur-val 3]\n\t(if (= repeat 0)\n\t  data\n\t  (if (diviable? cur-val data)\n\t    (recur data repeat (+ 1 cur-val))\n\t    (recur (conj data cur-val) (- repeat 1) (+ 1 cur-val))))))))", "problem": 67, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn primes [n]\n    (letfn [ (is-prime? [x] (cond\n                              (= x 1) false\n                              (= x 2) true\n                              :else (empty? (filter #(= (mod x %) 0) (range 2 (inc (Math/ceil (Math/sqrt x)))))))) ]\n      (take n (filter is-prime? (filter #(> % 1) (range))))\n    )\n)", "problem": 67, "user": "4dd1de4d535dae65d5c462d7"}, {"code": "(fn prime[x]\r\n  (loop [result [] n 2]\r\n    (if (= (count result) x)\r\n      result\r\n      (recur (if (zero? (reduce + (map (fn[a] (if (zero? (mod n a)) a 0))  result))) (conj result n) result) (inc n)))))", "problem": 67, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "(fn [k]\n  (letfn [(has-div? [a b] (some #(zero? (mod a %)) b))\n          (primes ([] (cons 2 (lazy-seq (primes 2 [2]))))\n                  ([lseen seen]\n                    (let [next-p (first (filter #(not (has-div? % seen)) (iterate inc (inc lseen))))]\n                      (cons next-p (lazy-seq (primes next-p (conj seen next-p)))))))]\n  (take k (primes))))", "problem": 67, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn[n] (take n (filter \r\n        #(empty? \r\n          (filter \r\n            zero?\r\n            (map mod (repeat %) (range 2 %) ))) \r\n        (drop 2 (range)))))", "problem": 67, "user": "4e707db6535d5021c1a8963a"}, {"code": "(fn [n]\n  (let [prime (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n  (take n (filter prime (iterate inc 2)))))", "problem": 67, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [k] \n  (take k \n    (filter \n      (fn [n] \n        (empty? (filter #(= 0 (mod n %)) (range 2 n))))\n      (iterate inc 2))))", "problem": 67, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [x]\n  (take x\n    (filter\n      #(not-any? zero?\n        (map (partial rem %1)\n          (drop 2 (range (inc (int (Math/sqrt %1)))))))\n      (drop 2 (range))\n    )\n  )\n)", "problem": 67, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "(fn [n]\n  (letfn [(prime-factors-of [n]\n            (loop [factors [] divisor 2 n n]\n              (if (<= n 1)\n                factors\n                (if (= 0 (rem n divisor))\n                  (recur (conj factors divisor) divisor (/ n divisor))\n                  (recur factors (inc divisor) n)))))\n          (prime? [n]\n            (if (< n 2)\n              false\n              (let [max-divisor (Math/sqrt n)\n                    prime-factors (take-while #(<= % max-divisor) (range 2 (inc max-divisor)))]\n                (if (some #(zero? (rem n %)) prime-factors)\n                  false\n                  true))))\n          (next-prime [n]\n            (let [n (inc n)]\n              (if (prime? n)\n                n\n                (recur n))))]\n    (take n (concat [2 3 5 7] (iterate next-prime 11)))))", "problem": 67, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(partial\n(fn [primes i n]\n  (if (= (count primes) n)\n    primes\n    (recur \n      (if (every? #(not= (mod i %) 0) primes)\n        (conj primes i) primes)\n      (+ 1 i) n)))\n[2] 3)", "problem": 67, "user": "4ec12577535dfed6da9c6da8"}, {"code": "(fn [x]\n  (take x\n        (remove\n          (fn [n]\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "4ea85846535d7eef308072f9"}, {"code": "(fn primes [n]\n  (letfn [(prime? [v] \n    (reduce #(and % (not (zero? (mod v %2)))) \n      true \n      (range 2 (+ (/ v 2) 1))))]\n    (loop [acc [2 3] N n c 4]\n      (if (= (count acc) N) \n        acc\n        (recur \n          (if (prime? c) \n            (conj acc c)\n            acc)\n          N\n          (inc c))))))", "problem": 67, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [first-n] (take first-n (filter (fn [x] ((fn [n] (= ((fn [x] (filter (fn [n] (= (mod x n) 0)) (range 1 (+ 1 x)))) n) (list 1 n))) x)) (range 0 1000))))", "problem": 67, "user": "4eb504d8535d7eef30807363"}, {"code": "(fn [x]\n  (drop 2\n    (take (+ 2 x)\n      (filter\n        (fn [n](-> (some zero? (map #(mod n %) (range 2 n) )) nil?))\n        (range)\n      )\n    )\n  )\n)", "problem": 67, "user": "4e8b73e4535d65386fec2120"}, {"code": "#(take %1 \n  ((fn foo [i] \n    (let [j (.nextProbablePrime i)] \n      (lazy-seq (cons i (foo j))))) (BigInteger/valueOf 2)))", "problem": 67, "user": "4eabb245535d7eef30807319"}, {"code": "(fn prime [n]\r\n  (take n \r\n    (filter (fn p [x]\r\n      (empty? (filter #(zero? (mod x %)) (range 2 x))))\r\n    (range 2 Double/POSITIVE_INFINITY))))", "problem": 67, "user": "4ea0c284535d7eef308072ad"}, {"code": "(fn primes [n]\n  (let [int-divide (fn [dividend divisor]\n                    (int (/ dividend divisor)))\n        factor? (fn [dividend divisor]\n                  (when (= (mod dividend divisor) 0)\n                    (int-divide dividend divisor)))\n        factor-pair (fn [dividend divisor]\n                      (when-let [factor (factor? dividend divisor)]\n                        [divisor factor]))\n        min-factor (fn [other-factor dividend divisor]\n                      (or (factor? dividend divisor) other-factor))\n        factor-pairs (fn factor-pairs\n                      ([number] (filter identity (factor-pairs number 1 number)))\n                      ([number index highest-factor]\n                        (when (< index highest-factor)\n                          (lazy-seq\n                              (cons\n                                (factor-pair number index)\n                                (factor-pairs number (inc index) (min-factor highest-factor number index)))))))\n        factors-desc (fn [number]\n                       (let [factor-pairs (factor-pairs number)]\n                          (concat (map second factor-pairs) (reverse (map first factor-pairs)))))\n        prime? (fn [number] (if (second (factor-pairs number)) false true))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(fn [a] \r\n  (take a \r\n    (iterate \r\n      (fn [n] (first \r\n        (filter \r\n          (fn [x] (empty? (filter #(= (rem x %) 0) (range 2 x)))) \r\n            (iterate inc (inc n))))) \r\n      2)))", "problem": 67, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn prime-list [z] (take z (filter identity (map (fn [y] (if (some false? ((fn [x] (map (fn[a] (if (zero? (mod x a)) false x)) (range 2 (+ (/ x 2) 1)))) y)) nil y)) (range 2 542)))))", "problem": 67, "user": "4ec12516535dfed6da9c6da7"}, {"code": "(fn [n]\n  (let [prime? (fn [n] (not-any? #(zero? (rem n %)) (range 2 n)))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4ec2f192535dcc7ae8597d4c"}, {"code": "(let [prime? \n  (fn [x] (not-any? zero? (for [i (range 2 x)] (mod x i))))]\n    (fn [n] (take n (filter prime? (rest (rest (range)))))))", "problem": 67, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [len]\n\n(loop [ v 3  col [2] ]\n     (if (= (count col) len)\n         col\n         (recur (inc v)\n\n                (if (loop [firstp (first col) restp (rest col) ]\n                    (cond\n                       (= (mod v firstp) 0) false\n                       (and (> (mod v firstp) 0 ) (empty? restp)) true\n                       :else (recur (first restp) (rest restp))\n                      )\n                    )\n                    (conj col v)\n                    col\n                )\n         )\n     )\n  )\n\n)", "problem": 67, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn first-n-primes [n]\n  (letfn [(is-prime? [x]\n    (letfn [(prime-iter [i num] ; should use sqrt here\n            (cond\n              (= i num) true\n              (= 0 (rem num i)) false\n              :else (recur (inc i) num)))]\n   (prime-iter 2 x)))\n            (next-prime [x]\n              (if (is-prime? (inc x)) (inc x)\n                  (recur (inc x))))]\n  (take n (iterate next-prime 2))))", "problem": 67, "user": "4ddb339c535d02782fcbe9f9"}, {"code": "(fn [n] (take n (rest\n     (loop [div 2 r (range 1000)]  \n     (if (< div (Math/sqrt 1000))  \n     (recur (inc div) (filter #(or (= div %) (not= 0 (mod % div))) r))\n     r)\n     ))))", "problem": 67, "user": "4eb44d78535d7eef30807360"}, {"code": "(fn primes [n]\n  (letfn [(prime? [x]\n    (empty?\n      (filter #(zero? (rem x %))\n                      (range 2 x))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn primes\n  ([m n p] (if (= (count p) m)\n             p\n             (if (not-any? #(= (mod n %) 0) p)\n               (primes m (+ n 1) (cons n p))\n               (primes m (+ n 1) p))))\n  ([m] (reverse (primes m 2 ()))))", "problem": 67, "user": "4ec6559a535d6d7199dd36c9"}, {"code": "(fn primes [n]\n  (letfn [(square [x] (* x x))\n          (divides? [a b] (= (mod b a) 0))\n          (smallest-factor [n]\n            (loop [candidate 2]\n              (cond (> (square candidate) n)  n\n                    (divides? candidate n)    candidate\n                    :else                     (recur (inc candidate)))))\n          (prime? [n] (= n (smallest-factor n)))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn [n] \n  (take n\n    (let [primes (atom [])]\n      (for [n (iterate inc 2)\n        :when (not-any? #(zero? (rem n %))\n          (filter #(<= % (Math/sqrt n)) \n            @primes))]\n      (do (swap! primes conj n)\n          n)))))", "problem": 67, "user": "4ec16c21535dfed6da9c6dac"}, {"code": "(fn [n]\n  (let [prime? (fn [i]\n                 (let [p (take-while #(<= % (java.lang.Math/sqrt i)) (range 2 i))]\n                   (not (some #(integer? (/ i %)) p))))\n        ps (filter prime? (drop 2 (range)))]\n    (take n ps)))", "problem": 67, "user": "4daf8f84edd6309eace4d17a"}, {"code": "(fn [n]\n  (take n\n  ((fn step [primes]\n    (lazy-seq\n      (let [p (first primes)\n            s (rest primes)]\n        (cons p (step (remove #(= 0 (rem % p)) primes))))))\n    (drop 2 (range)))))", "problem": 67, "user": "4eb1dd39535d7eef30807345"}, {"code": "(fn [n]\n  (take n (filter \n    (fn [x] (not-any? #(= 0 %) (map #(mod x %) (range 2 x))))\n    (drop 2 (range)))))", "problem": 67, "user": "4eb51942535d7eef30807365"}, {"code": "#(let [divisible (fn [n m] (= 0 (mod n m)))\nfactors (fn [n]\n  (filter (partial divisible n)\n(range 2 (inc (Math/sqrt n)))))\nprimes (cons 2 (filter (comp empty? factors)\n(iterate (comp inc inc) 3)))]\n(take % primes))", "problem": 67, "user": "4db3a0e5535df7e46ed9b6d0"}, {"code": "(fn n-primes [n]\n  (letfn\n    [(step [[i ps]]\n      (if (some #(= 0 (mod i %)) (take-while #(>= i (* % %)) ps)) ;i not prime\n        (recur [(inc i) ps])\n        [(inc i) (conj ps i)]))]\n    (second (last (take n (iterate step [3 [2]]))))))", "problem": 67, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [c]\n  (take c\n    (filter\n      (fn [n] (every? #(> (mod n %) 0) (range 2 n)))\n      (iterate inc 2))))", "problem": 67, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [x] \n  (take x (remove \n            (fn [n] (some #(= 0 (mod n %)) (range 2 n)))\n        (iterate inc 2))))", "problem": 67, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn primes [n]\n  (let [prime? (fn [p] (not-any? #(= 0 (mod p %)) (range 2 p)))]\n  (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn [n]\n  (take\n    n\n    (filter\n      #(not-any?\n        (fn [x] (= (mod % x) 0))\n        (range 2 (- % 1)))\n      (iterate inc 2))))", "problem": 67, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn primes [n]                                                                               \n  (if (= n 1)                                                                                  \n    [2]                                                                                        \n    (let [v (primes (dec n))                                                                   \n          is-prime (fn [x s] (let [ss (take-while #(<= % (Math/sqrt x)) s)]                    \n                               (= (count (for [i ss :while (pos? (rem x i))] i)) (count ss))))]\n      (loop [k (inc (last v))]                                                                 \n        (if (is-prime k v)                                                                     \n          (conj v k)                                                                           \n          (recur (inc k)))))))", "problem": 67, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [m]\n (take m\n   ((fn p\n     ([] (p '(2)))\n     ([s] (cons (first s)\n         (lazy-seq\n           (p (conj s \n             ((fn np [n]\n               (if (some #(= 0 (rem n %)) s)\n                 (np (inc n))\n                 n)) (apply max s)))))))))))", "problem": 67, "user": "4ecbb249535df97575fdabdf"}, {"code": "(fn [n] (take n \n              (letfn [(d [a] (some #(= 0 (mod a %)) (range 2 a)))] \n                 (remove #(d %) \n                         (iterate inc 2)))))", "problem": 67, "user": "4ebb78a2535dfed6da9c6d70"}, {"code": "#(take % (filter (fn [n] (not-any? (fn [d] (= 0 (mod n d))) (range 2 n))) (drop 2 (range))))", "problem": 67, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn ! [i] (take i (loop [s (range 2 600) o []]\r\n   (if (empty? s) o\r\n\t     (recur (filter #(not= (rem % (first s)) 0) s) (conj o (first s)))))))", "problem": 67, "user": "4e8a460e535d65386fec2109"}, {"code": "(fn [x]\n  (take x\n    (map last\n      (iterate (fn [found] (conj found (some (fn [n] (if (every? #(> (mod n %) 0) found) n nil)) (map #(+ % (inc (last found))) (range)))))\n               [2]))))", "problem": 67, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [x]\n  (letfn [(divides? [n i] (zero? (mod n i))) \n          (is-prime? [n] (not-any? #(divides? n %) (range 2 n)))] \n    (->> (range) \n\t     (drop 2)\n         (filter is-prime?)\n         (take x))))", "problem": 67, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn primes [n]\n  (let [is-prime (fn [x] (and (> x 1) (= 0 (count (filter #(= 0 (mod x %)) (range 2 x))))))]\n    (take n (filter is-prime (range)))))", "problem": 67, "user": "4ec75077535d6d7199dd36e0"}, {"code": "(fn [x]\r\n  (take x\r\n    (filter\r\n      (fn [n]\r\n        \"Detects if input paramter is a prime.\"\r\n        (if (<= n 3)\r\n          true\r\n          (let [max (Math/ceil (Math/sqrt n))]\r\n            (loop [d 2]\r\n              (if (zero? (rem n d))\r\n                false\r\n                (if (> d max)\r\n                  true\r\n                (recur (inc d))))))))\r\n      (range 2 Integer/MAX_VALUE))))", "problem": 67, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn nprimes [n]\n  (letfn [\n\t\t(isprime? [n]\n\t\t\t(nil? (some #(= 0 (rem n %)) (range 2 (inc (/ n 2)))))\n\t\t)\n\t\t(gather [primes x]\n\t\t\t(if (<= n (count primes))\n\t\t\t\tprimes\n\t\t\t\t(let \n\t\t\t\t\t[nextres (first (drop-while #(not (isprime? %)) (iterate inc x)))]\t\t\n\t\t\t\t\t(recur\n\t\t\t\t\t\t(conj primes nextres) \n\t\t\t\t\t\t(inc nextres)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t]\n\t\t(gather [] 2)\t\n\t)\n)", "problem": 67, "user": "4ed6238d535d10e5ff6f52de"}, {"code": "#(take %\n  ((fn s [[a & b]]\n    (lazy-seq\n      (cons a\n        (s\n          (filter (fn [e] (> (mod e a) 0)) b)))))\n  (drop 2 (range))))", "problem": 67, "user": "4ed69ea4535d10e5ff6f52e3"}, {"code": "(fn [n]\n  (loop [c 2 s []]\n    (if (< (count s) n)\n      (if (every? #(not= (mod c %) 0) s)\n        (recur (inc c) (conj s c))\n        (recur (inc c) s))\n      s)))", "problem": 67, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn [n] (take n \n              (letfn [(d [a] (some #(= 0 (mod a %)) (range 2 a)))] \n                 (remove #(d %) \n                         (iterate inc 2)))))", "problem": 67, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [n]\n  (let [next-prime (fn [found-primes]\n                      (loop [n (inc (last found-primes))]\n                        (if (reduce #(or %1 (zero? (mod n %2))) false found-primes)\n                          (recur (inc n))\n                          n)))]\n    (loop [result [2], n (dec n)]\n      (if (zero? n)\n        result\n        (recur (conj result (next-prime result)) (dec n))))))", "problem": 67, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn [m] (cons 2 (take (dec m) (filter\n                    #(.isProbablePrime (BigInteger/valueOf %) 5)\n                    (take-nth 2 (range 1 Integer/MAX_VALUE))))))", "problem": 67, "user": "4ebef65e535dfed6da9c6d9b"}, {"code": "(fn [n]\n  (letfn [(cross [n s]\n            (remove #(zero? (mod % n)) s))\n          (sieve [[f & r]]\n            (cons f (lazy-seq (sieve (cross f r)))))]\n    (take n (sieve (drop 2 (range))))))", "problem": 67, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn\n  [x]\n  (let [prime? (fn [n]\n                 (loop [i (int (Math/ceil (/ n 2)))]\n                   (if (and (> i 1)\n                            (zero? (rem n i)))\n                     false\n                     (if (= 1 i)\n                       true\n                       (recur (dec i))))))]\n    (take x (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "(fn [x]\n  (letfn [(sieve [[n & ns]]\n            (cons n (lazy-seq (sieve (remove #(zero? (mod % n))\n                                             ns)))))]\n    (take x (sieve (iterate inc 2)))))", "problem": 67, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [n] (take n (filter #(empty? (for [i (range 2 (inc (quot % 2))) :when (zero? (mod % i))] i)) (range 2 999))))", "problem": 67, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [n]\n  (nnext\n    (take\n      (+ 2 n)\n      (remove\n        (fn [x]\n          (some #(= 0 (rem x %)) (range 2 x))) \n        (range)))))", "problem": 67, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [x]\n  (vec  (take x (filter #(not-any? (fn [a] (zero? (mod % a))) (range 2 (dec  %))) (iterate inc 2)))))", "problem": 67, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "(fn ret-prime [number]\n  (take number \n  (filter \n  \t  (fn primo[n] \n\t      (= (count (filter #(= 0 (mod n %)) (rest (range n)))) 1)\n\t    )\n          (range)\n  \t  ))\n)", "problem": 67, "user": "4e9de526535dbda64a6f6b8e"}, {"code": "(fn [n]\r\n  (letfn [(prime [k]\r\n            (cond\r\n              (<= k 1) false\r\n              (= k 2) true\r\n              (zero? (mod k 2)) false\r\n              :else\r\n                (empty?\r\n                  (for [i (range 3 (-> k Math/sqrt int inc) 2)\r\n                        :when (zero? (mod k i))]\r\n                    i))))]\r\n    (take n (filter prime (iterate inc 0)))))", "problem": 67, "user": "4ee40938535d10e5ff6f5375"}, {"code": "(fn [n]\n  (take n ((fn sieve [ns]\n              (cons (first ns)\n                    (lazy-seq (sieve (remove #(= 0 (mod % (first ns))) (rest ns))))))\n            (map #(+ % 2) (range)))))", "problem": 67, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn primes [n]\n  (let [prime? (fn [n]\n  (not-any? #(zero? (mod n %)) (range 2 n)))]\n  (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4eda7cc3535d10e5ff6f530e"}, {"code": "(fn [n]\n  (take n\n    (cons 2 (remove (fn [candidate]\n      (some #(zero? (mod candidate %)) (range 3 (/ candidate 2))))\n(iterate #(+ 2 %) 3)))))", "problem": 67, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn primes\n     ([n] (primes [2] 3 n))\n     ([coll i n]\n       (let [prime? (fn[n] (reduce #(if (not %) % (> (mod n %2) 0)) true (range 2 n)))]\n        (cond\n        (= (count coll) n) coll\n        (prime? i) (recur (conj coll i) (+ i 2) n)\n        :else (recur coll (+ i 2) n)))))", "problem": 67, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn [x] \n  (take x \n    (filter #(= [1] \n                (filter (fn [n] \n                          (= 0 (rem % n))) \n                        (range 1 %))) \n            (iterate inc 0))))", "problem": 67, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "(fn [n] \n     (cons 2\n           (second\n             (last \n               (take n\n                     (iterate\n                       (fn [[x xs]] \n                         (if (some #(zero? (rem x %)) (take-while #(<= (* % %) x) xs))                                  \n                           (recur [(+ x 2) xs]) \n                           [(+ x 2) (conj xs x)]))\n                       [3 []]))))))", "problem": 67, "user": "4e513758535dc968683fc4f3"}, {"code": "#(condp = % 2 [2 3] 5 [2 3 5 7 11] 100 [541])", "problem": 67, "user": "4db091b7838c48654951d9c2"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (and (>= x 2) (not (some #(= 0 (rem x %)) (range 2 x)))))]\n    (take n (filter prime? (range)))))", "problem": 67, "user": "4ef0a39b535dced4c769f20c"}, {"code": "(fn *plist\n  [r & res]\n  (drop 2 (take (+ r 2) (lazy-seq (filter (fn [n]\n        (loop [m 2]\n          (if (> m (dec n))\n            true\n            (if (zero? (mod n m))\n              false\n              (recur (inc m)))))) (range))))))", "problem": 67, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn [n] (take n \n              (filter #(and (> % 1)\n                            (nil? (first (for [x (range 2 (inc (quot % 2))) :when (= (mod % x) 0)] x) ) )) \n                      (range))) )", "problem": 67, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [i] (take i ((fn p \n  ([] (lazy-seq (cons 2 (p 3))))\n  ([n] (lazy-seq \n  (let [d (take-while #(<= (* % %) n) (p))]\n(if (some #(= 0 (rem n %)) d) (p (+ 1 n)) (cons n (p (+ 1 n)))))))))))", "problem": 67, "user": "4ef2d243535dced4c769f221"}, {"code": "(comp (partial apply take) reverse list)\n(remove (comp (partial apply some)\n              (juxt (partial partial (comp zero? rem))\n                    (partial range 2))) \n        (iterate inc 2))\n\n#_\n\n(fn [n]\n  (take n\n    (remove (fn [k] (some #(zero? (rem k %)) \n                           (range 2 k)))\n            (iterate inc 2))))", "problem": 67, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [x]\n  (let [prime?\n        (fn [n]\n          (empty?\n            (drop-while\n              #(not= 0 (rem n %))\n              (range 2 n))))]\n  (take x (drop 2 (filter prime? (range))))))", "problem": 67, "user": "4edecdae535d10e5ff6f533c"}, {"code": "(fn primes [n]\n  (letfn [(is-prime? [x]\n            (= 1 (count (filter #(= 0 %)\n                                (map #(mod x %) (range 1 x))))))]\n    (take n (filter is-prime? (iterate inc 0)))))", "problem": 67, "user": "4ee9d697535d93acb0a66895"}, {"code": "(fn [n]\n  (->>\n    (drop 2 (range))\n    (filter\n      #(every?\n        (fn [x] (pos? (mod % x)))\n        (range 2 (inc (/ % 2)))))\n    (take n)))", "problem": 67, "user": "4ef77c82535dced4c769f253"}, {"code": "(fn [n]\n   (take n\n         (letfn [(advance-seq [v s] (if (<= v (first s)) s (recur v (rest s))))\n                 (prime? [v s] (empty? (filter #(= (first %) v) s)))\n                 (primes [prime-seqs [candidate & future-candidates]]\n                         (let [advanced-seqs (map #(advance-seq candidate %) prime-seqs)]\n                           (if (prime? candidate advanced-seqs)\n                             (cons candidate\n                                   (lazy-seq (primes (conj advanced-seqs\n                                                           (iterate (partial + candidate)\n                                                                    candidate))\n                                                     future-candidates)))\n                             (recur advanced-seqs future-candidates))))]\n           (cons 2 (lazy-seq (primes [] (iterate (partial + 2) 3)))))))", "problem": 67, "user": "4ee868be535d93acb0a6687d"}, {"code": "#(take %\n  (filter\n    (fn [num]\n      (not-any?\n        (fn [x] (zero? (mod num x)))\n        (range 2 (inc (int (Math/sqrt num))))))\n    (drop 2 (range))))", "problem": 67, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn [x]\n  (letfn [(div? [d n] (zero? (mod n d)))\n          (prime? [n]\n            (not (some #(div? % n) (range 2 (inc (Math/sqrt n))))))]\n    (take x (cons 2 (filter prime? (iterate inc 3))))))", "problem": 67, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn [x] (take x\n     (let [primes (atom [])]\n       (for [n (iterate inc 2)\n             :when (not-any? #(zero? (rem n %))\n                             (filter #(<= % (Math/sqrt n)) \n                                     @primes))]\n         (do (swap! primes conj n)\n             n)))))", "problem": 67, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [n]\n        (letfn [(from [[x & xs]]\n                      (lazy-seq (cons\n                                 x\n                                 (from (remove #(zero? (mod % x)) xs)))))]\n                (take n (from (iterate inc 2)))))", "problem": 67, "user": "4e599577535d8a8b8723a29f"}, {"code": "(fn primes [n]\n  (take n (\n           (fn sieve [ns]\n             (lazy-seq\n              (cons (first ns)\n                    (sieve (filter #(not= (mod % (first ns)) 0)\n                                   (rest ns))))))\n           (drop 2 (range)))))", "problem": 67, "user": "4ef6f5ea535dced4c769f250"}, {"code": "#(take %3\n        (filter\n         (fn [n]\n           (reduce\n            (fn [b m] (and b (< 0 (mod n m))))\n            true\n            (%2 2 n)))\n         (map % (%2)))) #(+ % 2) range", "problem": 67, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(letfn [(divisible [tests num] (some (fn [n] (= (mod num n) 0)) tests))\n        (next-primes [primes] (->> (iterate inc (inc (last primes)))\n                                  (filter (partial (complement divisible) primes))\n                                  first\n                                  (conj primes)\n                                  ))]\n  (fn [num-primes]\n    (nth (iterate next-primes [2]) (dec num-primes))))", "problem": 67, "user": "4ee9ba21535d93acb0a66891"}, {"code": "(fn [n] \n  (let [p (fn p [x] (if (< x 2) [] (let [l (p (dec x))] (if (every? #(not= (mod x %) 0) l) (conj l x) l))))] \n    (first (filter #(= n (count %)) (map p (range))))))", "problem": 67, "user": "4eecdd66535d93acb0a668b9"}, {"code": "(fn [n]\n    (letfn [(p? [x] (not-any? #(= 0 (rem x %)) (range 2 x)))]\n      (take n (filter #(p? %) (iterate inc 2)))))", "problem": 67, "user": "4ed292ac535d44c135fd68d9"}, {"code": "(fn prime-list\n        ([n] (prime-list (dec n) [2]))\n        ([n so-far]\n           (if (<= n 0)\n             so-far\n             (recur (dec n)\n                    (conj so-far\n                          (first (filter\n                                  (fn [x] (not-any? #(zero? (mod x %)) so-far))\n                                  (iterate inc (last so-far)))))))))", "problem": 67, "user": "4f031eac535dcb61093f6a67"}, {"code": "; failed on this one. Thanks to chrisvest (https://gist.github.com/952554)\n(fn [n] (let [start (java.math.BigInteger. \"2\")]\n  (take n (map #(.intValue %) (iterate #(.nextProbablePrime %) start)))))", "problem": 67, "user": "4ef4c1ff535dced4c769f23e"}, {"code": "(fn [n]\n  (drop 2 (take (+ n 2) \n       (filter \n        (memoize (fn [p] (= (count (filter #(= 0 %) (map #(rem p %) (range 2 p)))) 0 )))\n         (range)))))", "problem": 67, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [np]\n  (take np (filter (fn [n]\n    (let [indivisible? (fn indivisible? [n col]\n      (if-let [s (seq col)] (and (pos? (rem n (first col))) (indivisible? n (rest col))) true))]\n      (cond\n        (< n 50) (not= nil (#{2 3 5 7 11 13 17 19 23 29 31 37 41 43 47} n))\n        (or (even? n) (= 0 (rem n 3)) (= 0 (rem n 5)) (= 0 (rem n 7))) false\n        :else\n         (let [upper (inc (int (Math/sqrt n)))]\n           (indivisible? n (remove #(or (even? %) (= 0 (rem % 3)) (= 0 (rem % 5)) (= 0 (rem % 7))) (range 11 upper)))))))\n    (range))))", "problem": 67, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn uno* [m]\n  (let [primo (fn [n]\n  (and (> n 1)\n      (every?  #(> (mod n %) 0) (range 2 n))))]\n   (take m (filter primo (range)))))", "problem": 67, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn [x]\n  (letfn [(prime?\n    [n]\n    (if (even? n)\n      (= n 2)\n      (not-any? #(= 0 (rem n %))\n              (take-while #(<= (* % %) n) (range 3 n 2)))))]\n  (take x (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4eb5750a535d7eef30807366"}, {"code": "(fn [x] (take x (letfn [(s [o i] (let [p (first i)] (if (nil? p) o (s (conj o p) (filter #(> (mod % p) 0) (rest i))))))] (s [] (range 2 542)))))", "problem": 67, "user": "4f03857e535dcb61093f6b0d"}, {"code": "(fn [x]\n  (loop [primes (sorted-set) candidates (nnext (range))]\n    (if (= x (count primes))\n      (seq primes)\n      (let [n (first candidates)]\n        (recur\n          (conj primes n)\n          (remove #(zero? (mod % n)) (rest candidates)))))))", "problem": 67, "user": "4ec5a5f9535d6d7199dd36ad"}, {"code": "(fn [num] \n  (some #(if (= num (count (first %))) (first %)) \n    (iterate \n      (fn [[primes, candidate]] \n        [(if (every? #(not= 0 (mod candidate %)) primes) \n          (conj primes candidate), \n          primes),\n         (inc candidate)])\n     [[2] 3])))", "problem": 67, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "#(take %\n         (cons 2\n          (filter\n           (fn [n] (not-any? zero?\n                             (map (partial mod n) (range 2 n))))\n           (iterate inc 3))))", "problem": 67, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn primes [x]\n  (letfn [(p [n ps]\n             (let [rs (remove #(= 0 (mod % n)) ps)]\n                 (cons n (lazy-seq (p (first rs) (rest rs))))))]\n    (take x (p 2 (map #(+ 2 %) (range))))))", "problem": 67, "user": "4ee82ce9535d93acb0a6687a"}, {"code": "#(take % ((fn f [v p] (let [n (cons p v)]\n  (if (empty? (filter (fn [x] (= 0 (rem p x))) v))\n  (lazy-seq (cons p (f n (+ 1 p))))\n  (f v (+ 1 p))\n  ))) [] 2))", "problem": 67, "user": "4f01c938535dcb61093f6a39"}, {"code": "#(loop [p [] c 2]\n     (if (<= % (count p)) p\n         (recur (concat p (if (some (comp zero? (partial rem c)) p) [] [c]))\n                (inc c))))", "problem": 67, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn prob-0067\n  [n]\n\n  (let [\n    prime? (fn prime?\n      [num]\n      {:pre [(not (neg? num))]}\n      (cond\n       (< num 2) false                    ; 2 is the smallest prime\n       (< num 4) true                     ; 2 and 3 are prime\n       (even? num) false                  ; 2 is the only even prime\n       (< num 9) true                     ; 5 and 7 are prime\n       (zero? (rem num 3)) false          ; we already handled 3, all other mults of 3 not prime\n\n       :default (let [ lim (Math/sqrt num) ]\n                  (loop [f 5]\n                    (cond\n                     (> f lim) true                  ; f too large to be a factor of num: prime!\n                     (zero? (rem num    f   )) false ; 1st case of every 6 that might be factor\n                     (zero? (rem num (+ f 2))) false ; 2nd case of every 6 that might be factor\n                     :default (recur (+ f 6)))))))   ; advance f by six and check again\n\n    next-prime (fn next-prime\n      [n]\n      (if (prime? n) n (recur (inc n))))\n\n    primes (fn primes\n      ([]  (primes 2))\n      ([n] (lazy-seq\n            (let [p (next-prime n)]\n              (cons p (primes (inc p)))))))\n    ]\n    \n    (take n (primes))))", "problem": 67, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [k]\n  (cond (= 1 k) [2]\n        (= 2 k) [2 3]\n        true (last (take (- k 1) (iterate\n                                   (fn [s]\n                                     (loop [x (last s)]\n                                       (if (every? (fn [y] (not= 0 (rem x y))) s) (conj s x)\n                                         (recur (+ x 2)))))\n                                   [2 3])))))", "problem": 67, "user": "4eff81ca535dcb61093f6a2d"}, {"code": "(fn [n]\n  (loop [cd 2 c n p []]\n    (if (= 0 c)\n      p\n      (if (some #(= 0 (rem cd %)) p)\n        (recur (inc cd) c p)\n        (recur (inc cd) (dec c) (conj p cd))))))", "problem": 67, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [n] (take n \n              (remove nil? \n                      (cons 2 (map (fn [x] \n                                     (when (nil? (some #(= 0 (rem x %)) \n                                                       (range 2 (inc (Math/sqrt x))))) x))\n                                   (iterate inc 3))))))", "problem": 67, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [x] (take x (lazy-cat [2 3 5 7 11]\n                          (filter #(empty? (loop [fs [] x % f 2]\n                                             (cond\n                                              (> f (Math/sqrt %)) fs\n                                              (zero? (mod x f)) (recur (conj fs f) (/ x f) f)\n                                              :else (recur fs x (inc f)))))\n                                  (iterate inc 13)))))", "problem": 67, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn [n]\n  (loop [i 0 ret '() x 2]\n    (cond\n      (= i n) (reverse ret)\n      (every? \n        #(not= (rem x %) 0) \n        (range 2 x))\n        (recur (inc i) (conj ret x) (inc x))\n      :else\n        (recur i ret (inc x)))))", "problem": 67, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn [t] (take t\n    (letfn [(divides? [divisor dividend]\n              (zero? (rem dividend divisor)))\n            (multiples [n start end]\n              (filter #(divides? n %) (range start end)))]\n      (filter #(not(nil? %)) (map-indexed (fn [i b] (if (and (> i 1) b) i))\n                                          (loop [x 2 d (vec (repeat (* t 100) true))]\n                                            (if (> x (* t 100))\n                                              d\n                                              (recur (inc x)\n                                                     (reduce #(assoc %1 %2 false) d (multiples x (* 2 x) (* t 100)))))))))))", "problem": 67, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn primes [n]\n  (letfn [(prime? [primes-lt candidate]\n            (not-any? #(zero? (mod candidate %)) primes-lt))\n          (next-prime [coll]\n            (loop [candidate (inc (last coll))]\n              (if (prime? coll candidate)\n                (conj coll candidate)\n                (recur (inc candidate)))))]\n    (last (take n (iterate next-prime [2])))))", "problem": 67, "user": "4f0ef874535d0136e6c22328"}, {"code": "(fn [n]\n  (let [primes ((fn p [filt]\n      (let [f (first filt)]\n        (lazy-seq\n          (cons f\n            (p (filter #(not= 0 (mod % f)) filt))))))\n      (iterate inc 2))]\n    (take n primes)))", "problem": 67, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "#(let [divisible (fn[x y](= 0 (rem x y))) prime? (fn[x](every? (fn[x](= x false))(map (partial divisible x)(range 2 x)))) primes (filter prime? (range))](drop 2 (take (+ % 2) primes)))", "problem": 67, "user": "4ed2dd98535d44c135fd68e2"}, {"code": "(fn [k]\n    (nth (iterate\n          (fn [x]\n            (conj x\n                  (first\n                   (drop-while #(some (fn [n] (zero? (mod % n))) x)\n                               (drop (inc (last x)) (range))))))\n          [2])\n         (dec k)))", "problem": 67, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn [n]\n  (loop [k 1\n         primes [2]\n         current 3]\n    (cond (= k n) primes\n          (reduce #(and %1 %2) (map #(not (= 0 (mod current %))) primes))\n          (recur (inc k) (conj primes current) (inc current))\n          :default (recur k primes (inc current)))))", "problem": 67, "user": "4e49a7bb535dc968683fc4c6"}, {"code": "(fn [n]\n(take n (drop 2 (for [x (range) :when (if (= x 2) true (not-any? #(= 0 (rem x %)) (range 2 x)))] x))))", "problem": 67, "user": "4e8a0d5d535d3e98b802328e"}, {"code": "(fn pn [x]\n  (letfn [(prime-numbers [num]\n            (lazy-seq\n             (letfn [(divisible? [x num] (if (zero? (rem num x)) false true))]\n               (loop [num-range (range 2 (inc num)) n (first num-range) result []]\n                 (if (empty? num-range)\n                   result\n                   (recur\n                    (filter (partial divisible? n) num-range)\n                    (first (filter (partial divisible? n) num-range))\n                    (conj result n)))))))]\n    (take x (prime-numbers 5000))))", "problem": 67, "user": "4e95a440535dbda64a6f6b37"}, {"code": "(fn primes [x]\n  (letfn [(is-prime? [n]\n  (if (= 2 n)\n      true\n      (if (or (= 1 n) (and (even? n) (> 2)))\n        false\n        (not (reduce #(or %1 (integer? (/ n %2))) false (range 3 n))))))]\n  (take x (filter is-prime? (drop 1 (range))))))", "problem": 67, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn [n]\n    (take n (let\n        [is-prime \n         (fn [x]\n            (empty? \n                (filter\n                    #(= 0 (mod x %))\n                    (range 2 x)\n                )\n            )\n         )\n        ]\n        (lazy-seq (cons 2 (filter #(is-prime %) (iterate inc 3))))\n    ))\n)", "problem": 67, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn primes [x]\n  (if (= x 1)\n      [2]\n      (let [prevs (primes (dec x))\n            maxp (last prevs)\n            nonprime \n              (fn [x] (some #(= 0 (mod x %)) prevs))\n            nextp (first (drop-while nonprime (iterate inc maxp)))          \n           ]\n        (conj prevs nextp))))", "problem": 67, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn [x]\n  (letfn [(prime? [x]\n      (let [d (range 2 (inc (int (Math/sqrt x))))\n\t\t  r (map #(rem x %) d)]\n\t      (not (some zero? r))))]\n    (take x (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(let [prime? (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))]\r\n  #(take % (filter prime? (iterate inc 2))))", "problem": 67, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [n]\n  (loop [n (dec n) coll [2]]\n    (let [divis? (fn [x co] (some #(zero? (mod x %)) co))\n      nextprime (first (drop-while #(divis? % coll) (drop 2 (range))))]\n    (if (pos? n)\n      (recur (dec n) (conj coll nextprime))\n      coll))))", "problem": 67, "user": "4edd038c535d10e5ff6f5327"}, {"code": "#(take % (for [x (iterate inc 2) :when\n  (every? (fn [a] (> (rem x a) 0)) (range 2 x))] x))", "problem": 67, "user": "4f1595da535d64f603146444"}, {"code": "(fn[n] (take n (filter #(every? (fn[x] (not (zero? (rem % x))))                                    \n                                (range 2 (+ 1 (/ % 2)))) \n                       (iterate inc 2))))", "problem": 67, "user": "4daeabf6edd6309eace4d15c"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not (some zero? (map #(rem x %) (range 2 (inc (int (Math/sqrt x))))))))]\n    (take n (filter prime? (iterate inc 2)))\n))", "problem": 67, "user": "4e6b6294535d8ccf87e9ff11"}, {"code": "(fn [x]\n(take x\n  (lazy-seq\n  (filter (fn [n]\n    (not-any? \n     (fn [a](= 0 (apply mod a)))\n     (partition 2 (interleave \n       (repeat n)(range 2 (inc (/ n 2)))))))\n     (drop 2 (range))))))", "problem": 67, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn primes [n]\n (take n \n       (filter \n         (fn [x] \n           (every? #(pos? (rem x %)) (range 2 (dec x)))\n           )\n         (drop 2 (range))\n         )\n       )\n  )", "problem": 67, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn [n] (take n\n  (filter\n    (fn [p] (not (some #(= 0 (rem p %)) (range 2 p))))\n    (iterate inc 2))))", "problem": 67, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [x]\n    (let [prime? (fn [n]\n\t   (cond\n\t     (< n 2) false\n\t     (or (= 2 n) (= 3 n)) true\n\t     (= 0 (mod n 2)) false\n\t     :else\n\t     (let [m (int (java.lang.Math/sqrt n))]\n\t\t  (loop [i 3]\n\t\t     (cond\n\t\t       (= 0 (mod n i)) false\n\t\t       (> i m) true\n\t\t       :else\n\t\t       (recur (+ 2 i)))))))]\n\t\t       (take x (filter prime? (range)))))", "problem": 67, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn [n]\n  (let [prime? #(let [limit (Math/ceil (Math/sqrt %))]\n                  (loop [x 2]\n                    (cond\n                     (> x limit) true\n                     (and (not= x %)\n                          (zero? (mod % x))) false\n                     :else (recur (inc x)))))]\n    (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn prime [cnt]\n    (letfn [(prime? [n]\n                (not\n                    (some #(zero? (rem n %)) (range 2 n))))]\n        (take cnt (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f128865535d64f603146428"}, {"code": "(fn [n]\n  (let [prime? (fn [n] (empty? (filter #(= 0 (mod n %)) (drop 2 (range n)))))\n        primes (for [x (drop 2 (range)) :when (prime? x)] x)]\n       (take n primes)))", "problem": 67, "user": "4f13047d535d64f60314642c"}, {"code": "(fn primes [x]\n  (if (= x 1)\n    [2]\n    (let [pp (primes (- x 1))]\n      (conj pp\n        (first (filter\n          (fn [i] (every? #(< 0 (mod i %)) pp))\n          (range (last pp) (* 2 (last pp)))))))))", "problem": 67, "user": "4f1b92d1535d64f60314647b"}, {"code": "(letfn [(not-divisible-by [x] #(not= 0 (mod % x)))                                                                                                                         \r\n          (primes                                                                                                                                                            \r\n            ([]                                                                                                                                                              \r\n               (cons 2 (primes (drop 2 (range)) 2)))                                                                                                                         \r\n            ([aseq prime]                                                                                                                                                    \r\n               (lazy-seq                                                                                                                                                     \r\n                (let [x (int (Math/pow prime 2))                                                                                                                             \r\n                      [primes-less-than-x unknown] (split-with #(< % x)                                                                                                      \r\n                                                               (filter                                                                                                       \r\n                                                                (not-divisible-by prime)                                                                                     \r\n                                                                aseq))                                                                                                       \r\n                      last-prime (last primes-less-than-x)]                                                                                                                  \r\n                  (concat primes-less-than-x                                                                                                                                 \r\n                          (primes (reduce (fn [t e] (filter (not-divisible-by e) t))                                                                                          \r\n                                          unknown                                                                                                                            \r\n                                          primes-less-than-x)                                                                                                                \r\n                                  (last primes-less-than-x)))))))]                                                                                                           \r\n    #(take % (primes)))", "problem": 67, "user": "4f149e0f535d64f60314643d"}, {"code": "(fn [n]\n  (letfn [(is-prime? [x]\n            (not-any? #(= 0 (rem x %)) (range 2 (inc (/ x 2)))))]\n    (take n (filter is-prime? (range 2 Double/POSITIVE_INFINITY)))))", "problem": 67, "user": "4ec5cdb0535d6d7199dd36b8"}, {"code": "(fn [n]\n           (letfn [(prime? [cand primes]\n                           (not-any? #(= 0 (mod cand %)) primes))]\n           (loop [primes [2 3]\n                  i 4]\n              (cond (= n (count primes)) primes\n                    (prime? i primes) (recur (conj primes i) (inc i))\n                    :else (recur primes (inc i))))))", "problem": 67, "user": "4f04f847535dcb61093f6beb"}, {"code": "(fn [x]\n  (let [primes-from\n    (fn primes-from [n]\n      (if (some #(zero? (rem n %)) (range 3 (inc (Math/sqrt n)) 2))\n        (recur (+ n 2))\n        (lazy-seq (cons n (primes-from (+ n 2))))))]\n    (take x (cons 2 (primes-from 3)))))", "problem": 67, "user": "4f0660ee535dcb61093f6c0d"}, {"code": "(fn prm [n]\r\n  (loop [a 2 acc []]\r\n    (if (< (count acc) n)\r\n    (recur (inc a) \r\n      (if (some zero? (map #(mod a %) acc))\r\n        acc\r\n        (conj acc a))\r\n           )\r\n      acc)))", "problem": 67, "user": "4ef0f1a1535dced4c769f212"}, {"code": "(fn [x] (take x (filter (fn [n] (not (some #(= (rem n %) 0) (take-while #(> % 1) (iterate dec (dec n)))))) (nnext (range)))))", "problem": 67, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn [n]\n  (loop [ll [2] len 1 num 3]\n    (if (= len n)\n      ll\n      (if (some #(= (rem num %) 0) ll)\n        (recur ll len (+ num 2))\n        (recur (conj ll num) (inc len) (+ num 2))))))", "problem": 67, "user": "4f246938e4b0d66497709fec"}, {"code": "#(letfn [(p [a]\n  (not (or (< a 2) (some (fn [d] (= 0 (mod a d))) (range 2 a)))))]\n    (take % (filter p (range))))", "problem": 67, "user": "4ede361a535d10e5ff6f5332"}, {"code": "#(take %\n  (remove (fn [n]\n            (some (fn [x] (= (rem n x) 0)) (range 2 n)))\n          (drop 2 (range))))", "problem": 67, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [n]\n  (take n\n    (filter \n      (fn [x] \n        (not-any? #(= 0 (mod x %)) (range 2 x))) (iterate inc 2))))", "problem": 67, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [n]\n   (take n ((fn rep [r x]\n              (let [np (some #(= 0 (mod x %)) r)\n                    nextr (if np r (conj r x))]\n                (if np\n                  (rep nextr (inc x))\n                  (lazy-seq\n                   (cons x\n                    (rep nextr (inc x))))))) [] 2)))", "problem": 67, "user": "4eb02674535d7eef30807338"}, {"code": "(fn [lim] \n  (take lim \n    (let [\n      prime \n        (fn [num] \n          (every? \n            (fn [d] (< 0 (mod num d))) \n            (range 2 num)))] \n      (filter prime (range 2 2000)))))", "problem": 67, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [n]\r\n  (letfn [(prime? [x] (not (some #(zero? (mod x %)) (range 2 x))))]\r\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn primes [n]\n  (letfn [(isprime [num ps]\n            (not-any? #(zero? (mod num %)) ps))]\n    (if (= n 1)\n      [2]\n      (let [pastprimes (primes (dec n))\n            totest     (iterate inc (inc (last pastprimes)))\n            nextprime  (first (filter #(isprime % pastprimes) totest))]\n         (conj pastprimes nextprime)))))", "problem": 67, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [n] \n  (let [isPrime? (fn isPrime? ([p]\n  (isPrime? p (- p 1)))\n  ([p d]\n    (cond \n      (= 1 d) true\n      (= (mod p d) 0) false\n      :else (isPrime? p (- d 1)))))]\n  (take n (filter isPrime? (range 2 1000)))))", "problem": 67, "user": "4f1c2a3a535d64f603146480"}, {"code": "(fn [n]\n  (take n\n    (cons 2 \n      (filter\n        (fn [x] (not-any? #(= 0 (rem x %)) (range 2 (inc (Math/sqrt x)))))\n        (iterate #(+ 2 %) 3)))))", "problem": 67, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [number]\n  (take number (filter (fn [possible_prime] (every? #(> (mod possible_prime %) 0) (range 2 possible_prime))) (drop 2 (range)))))", "problem": 67, "user": "4f294c48e4b0d6649770a023"}, {"code": "(fn [x] (take x (filter (fn [n] (not-any? zero? (map #(mod n %) (reverse (range 2 n))))) (iterate inc 2))))", "problem": 67, "user": "4f0f01c0535d0136e6c22329"}, {"code": "(fn [x] (take x (for [ x (sort\n (into (into [2 3]\n        (map  #(+ 5 (* 6 %1)) (range 0 100)))\n        (map #(inc (* 6 %1)) (range 1 100))\n ))\n      :when ((fn prime [n]\n   (loop [i 2 result true]\n     (if (> i (/ n 2))\n       result\n       (recur (inc i) (and result (not (zero? (mod n i)))) )\n       )\n     )\n   ) x)] x)))", "problem": 67, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn [n]\r\n  (loop [r (drop 2 (range)) p #{}]\r\n    (if (= n (count p)) (sort p)\r\n        (recur (rest r) (if (some #(zero? (rem (first r) %)) p)  p (conj p (first r)))))))", "problem": 67, "user": "4f29cdc8e4b0d6649770a033"}, {"code": "(fn [c]\n  (letfn [(? [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n    (loop [n 2 o []]\n      (if (= (count o) c)\n        o\n        (recur (inc n) (if (? n) (conj o n) o))))))", "problem": 67, "user": "4f1d1d95535d64f603146488"}, {"code": "#(take % (for [x (range 1 Integer/MAX_VALUE) :when (.isProbablePrime (BigInteger/valueOf x) 5)] x))", "problem": 67, "user": "4f26d6d9e4b0d6649770a007"}, {"code": "(fn [n]\n  (let [p? (fn [x] (if (= x 2)\n                      true\n                      (not-any? zero? (map #(rem x %) (range 2 x)))))]\n  (take n (filter p? (iterate inc 2)))))", "problem": 67, "user": "4e1f9bb5535d04ed9115e80d"}, {"code": "(fn shite [n]\n  (letfn [\n        (f [n] (fn [x] (rem n x)))\n        (pq [x]\n                 (if (some zero? (map (f x) (range 2 x)))\n                   []\n                   [x]\n                   )\n                 )\n        ]  \n    ;(vec (take n (flatten (map pq (range 2 10000)))))\n(vec (take n (flatten (map pq (range 2 10000)))))\n    )\n  )", "problem": 67, "user": "4f2004a1535d64f6031464a7"}, {"code": "(fn primes [n]\n  (let [isprime?\n    (fn [p]\n      (loop [i 2]\n        (if (= i p)\n          true\n          (if (zero? (mod p i))\n            false\n            (recur (inc i))))))]\n  (loop [i 2 result []]\n    (if (= (count result) n)\n      result\n      (if (isprime? i)\n        (recur (inc i) (conj result i))\n        (recur (inc i) result))))))", "problem": 67, "user": "4f215350e4b0d66497709fd0"}, {"code": "(fn [n]\n  (let [is-prime?\n        (fn [x]\n          (loop [div 2]\n            (cond (= x div) true\n                  (= (rem x div) 0) false\n                  :else (recur (inc div)))))\n        next-prime\n        (fn [starting-from]\n          (loop [counter starting-from]\n            (if (is-prime? counter)\n              counter\n              (recur (inc counter)))))]\n    (reduce\n     (fn [result counter]\n       (conj result\n             (if (= 0 (count result))\n               2\n               (next-prime (inc (last result))))))\n     []\n     (range n))))", "problem": 67, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn n-primes [n]\n  (loop [noleft (dec n), ret [2], start 3]\n    (cond\n      (= noleft 0) ret ; we already generated n prime numbers => return\n      ; if start is a prime add it to ret and try next number\n      (not (some #(zero? (mod start %)) ret)) (recur (dec noleft), (conj ret start), (inc start))\n      :else (recur noleft, ret, (inc start)) ; just try next number\n      )))", "problem": 67, "user": "4f2965ffe4b0d6649770a029"}, {"code": "(fn [n]\n           (take n (remove\n                    #(some (fn [x] (= 0 (rem % x))) (range 2 %))\n                    (nnext (range)))))", "problem": 67, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [n]\n  (take n (iterate (fn [n]\n             (loop [cand (inc n)]\n               (if (= 0 (count (filter zero? (for [j (range 2 (inc (int (Math/sqrt cand))))]\n                                               (rem cand j)))))\n                 cand\n                 (recur (inc cand))))) 2)))", "problem": 67, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn [n]\n  (letfn [(next-entry [sieve candidate step]\n            (let [n (+ candidate step)]\n              (if (sieve n)\n                (recur sieve n step)\n                (assoc sieve n step))))\n          (update-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                  (dissoc candidate)\n                  (next-entry candidate step))\n              (next-entry sieve candidate candidate)))\n          (test-next [sieve candidate]\n            (if (sieve candidate)\n              (recur (update-sieve sieve candidate) (inc candidate))\n              (cons candidate (lazy-seq (test-next (update-sieve sieve candidate) (inc candidate))))))]\n    (take n (lazy-seq (test-next {} 2)))))", "problem": 67, "user": "4dc1bd76535d020aff1edf8d"}, {"code": "(fn [n1] (take n1 (let [primes (atom [])]\n       (for [n (iterate inc 2)\n             :when (not-any? #(zero? (rem n %))\n                             (filter #(<= % (Math/sqrt n)) \n                                     @primes))]\n         (do (swap! primes conj n)\n             n)))))", "problem": 67, "user": "4e1248b1535d04ed9115e7cf"}, {"code": "(fn primes [n]\n  (letfn [(prime? [x]\n    (empty? (filter #(zero? (rem x %)) (range 2 (inc (Math/ceil (Math/sqrt x)))))))]\n      (sort (conj (take (dec n) (filter prime? (iterate (partial + 2) 3))) 2))))", "problem": 67, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn [n]\n  (take n\n    (filter (fn [p] \n              (empty? (filter #(= 0 (rem p %1))\n                              (range 2 (inc (/ p 2))))))\n            (drop 2 (range)))))", "problem": 67, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [n]\n  (take n\n\t\t(filter\n\t\t\t(fn [x]\n\t\t\t\t(loop [ref x div (dec x)]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(= 1 div) true\n\t\t\t\t\t\t(= 0 (mod ref div)) false\n\t\t\t\t\t\t:else (recur ref (dec div)))))\n\t\t\t(iterate inc 2))))", "problem": 67, "user": "4f39f902e4b0e243712b1efe"}, {"code": "(fn [n]\n  (reverse ((fn [s c n]\n              (if (zero? n)\n                s\n                (if (some #(zero? (rem c %)) s)\n                  (recur s (inc c) n)\n                  (recur (cons c s) (inc c) (dec n)))))\n             [2] 3 (dec n))))", "problem": 67, "user": "4f359c7ee4b0e243712b1ec4"}, {"code": "(fn [n]\n  (let [prime? \n        (fn [x] (empty? (filter #(zero? (rem x %)) (range 2 x))))]\n      (take n(for [x (drop 2 (range)) :when (prime? x)] x))))", "problem": 67, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn [n]\n    (letfn [(prime [n]\n              (loop [d (int (/ n 2))]\n                (cond\n                  (< d 2) true\n                  (= (mod n d) 0) false\n                  :else (recur (dec d)))))]\n       (take n (filter prime (iterate inc 2)))))", "problem": 67, "user": "4f1bee08535d64f60314647e"}, {"code": "#(cond \n  (= % 2) [2 3]\n  (= % 5) [2 3 5 7 11]\n  :else [541])", "problem": 67, "user": "4e6ec58c535d5021c1a89611"}, {"code": "(fn [n]\n (letfn [(prime? [x]\n            (if (= x 2)\n              true\n              (not (some #(zero? (mod x %)) (range 2 (inc (Math/sqrt x)))))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn\n  [cnt]\n  (letfn\n    [(is-prime? [n]\n       (condp = n\n         1 false\n         2 true\n         (let [mid (Math/ceil (Math/sqrt n))]\n           (loop [iter 2]\n             (if (== 0 (mod n iter))\n               false\n               (if (>= iter mid)\n                 true\n                 (recur (inc iter))))))))\n     (next-prime [start]\n       (if (nil? start)\n         2\n         (loop [start (inc start)]\n           (if (is-prime? start) \n             start\n             (recur (inc start))))))]\n    (loop [iter cnt result []]\n      (if (< iter 1)\n        result\n        (recur (dec iter)\n               (conj result (next-prime (last result))))))))", "problem": 67, "user": "4f4544e1e4b0d56e7bb92b7a"}, {"code": "(fn [n]\n          (take n\n                (filter (fn [p] \n                            (not (some #(= java.lang.Integer (class (/ p %))) (range 2 (inc (int (Math/sqrt p))))))) \n                        (drop 2 (range)))))", "problem": 67, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn nthPrimes[n]\n  (letfn [(isPrime[x] (if\n                       (some (fn[y] (= 0 (rem x  y))) (range 2 (+ (/ x 2) 1) ))\n                       false \n                       true))]\n    (take n (filter isPrime (iterate inc 2)))))", "problem": 67, "user": "4e6cf521535de274dd8d818b"}, {"code": "(fn [n]\n  (loop [ps [2] i 3]\n    (if (>= (count ps) n) ps\n    (if (= 0 (apply min (map (fn [x] (rem i x)) ps)))\n      (recur ps (inc i))\n      (recur (concat ps [i]) (inc i))))))", "problem": 67, "user": "4f418eaee4b0d7d3c9f3fce9"}, {"code": "(fn primes [n]\n  (let [prime? (fn prime?\n    ([e] (prime? e 2))\n    ([e i]\n      (cond\n        (= i e) true\n        (= (mod e i) 0) false\n        :else (recur e (inc i)))))]\n\n    (take n\n      (filter \n        prime?\n        (iterate inc 2)))))", "problem": 67, "user": "4de165f3535d08e6dec9fde6"}, {"code": "(fn [n]\r\n  (take n\r\n    (letfn [(make-prime-list [l]\r\n              (lazy-seq (cons (first l)\r\n                              (filter #(not (zero? (rem % (first l))))\r\n                                      (make-prime-list (rest l))))))]\r\n      (make-prime-list (drop 2 (range))))))", "problem": 67, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "#(let [m-r (fn [n] (.isProbablePrime (BigInteger/valueOf n) 5))\r\n      primes (filter m-r (drop 2 (range)))]\r\n   (take % primes))", "problem": 67, "user": "4f426a7ae4b0d7d3c9f3fcff"}, {"code": "(fn [n]\n  (take n (filter (fn [x]\n    (let [divs (range 2 (inc (int (Math/sqrt x))))\n          rems (map #(rem x %) divs)]\n      (not (some zero? rems))))\n  (iterate inc 2))))", "problem": 67, "user": "4f4ba29ae4b03ad3f0c10c7a"}, {"code": "(fn [n]\n    (letfn [(next-prime [n]\n                (first (drop-while (fn [m] (not-every? #(not= 0 (mod m %)) (cons 2 (for [x (range 2 (+ 1 (Math/sqrt m))) :when (odd? x)] x)))) (range (+ 1 n) Double/POSITIVE_INFINITY))))]\n    (take n (iterate next-prime 2))))", "problem": 67, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn my-primes [n]\n  (letfn [(is-prime [x]\n            (.isProbablePrime (BigInteger/valueOf x) 5))\n          (rrr [res c curr]\n            (if (= 0 c)\n              res\n              (if (is-prime curr)\n                (rrr (conj res curr) (dec c) (+ 2 curr))\n                (rrr res c (+ 2 curr)))))]\n    (rrr [2] (dec n) 3)))", "problem": 67, "user": "4f04d312535dcb61093f6be7"}, {"code": "(fn [n]                                                                                              \n   (let [prime? (fn [p](.isProbablePrime (BigInteger/valueOf p) 5))                                   \n         nextprime (fn ! [p] (let [nxt (inc p)] (if (prime? nxt) nxt (! nxt))))                       \n         primes (fn ! [p] (lazy-seq (cons p (! (nextprime p)))))]                                     \n     (take n (primes 2))))", "problem": 67, "user": "4f1d1299535d64f603146487"}, {"code": "(fn get-p\r\n  [n]\r\n  (loop [i 3\r\n         s [2]]\r\n    (if (= (count s) n)\r\n      s\r\n      (recur (+ i 2)\r\n             (if (> (count (filter #(= 0 (mod i %)) (range 2 (inc (/ i 2))))) 0)\r\n               s\r\n               (conj s i))))))", "problem": 67, "user": "4f17ab99535d64f603146457"}, {"code": "(fn [n]\n  (take n\n    (cons 2\n      (filter (fn [x] (not-any? #(zero? (mod x %))\n          (take-while #(<= (* % %) x) (range 2 x))))\n        (range 3 Double/POSITIVE_INFINITY 2)))))", "problem": 67, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [n]\n        (loop [primes [] ints (drop 2 (range)) n n]\n          (if (zero? n)\n            primes\n            (recur (conj primes (first ints))\n                   (filter #(not (zero? (rem % (first ints)))) ints)\n                   (dec n)))))", "problem": 67, "user": "4f038499535dcb61093f6b09"}, {"code": "(fn primes [n]\n  (let [prime? (fn [x] (.isProbablePrime (bigint x) 100))]\n    (loop [i 1 acc []]\n      (if (= (count acc) n)\n          acc\n          (recur (inc i) (if (prime? i)\n                             (conj acc i)\n                             acc))))))", "problem": 67, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn [x]\n  (take x\n    ((fn sieve [[p & rst]]\n      (lazy-seq \n        (cons p (sieve (remove #(= 0 (mod % p)) rst)))))\n      (iterate inc 2))))", "problem": 67, "user": "4f4f08c8e4b03ad3f0c10cd8"}, {"code": "#(take % (filter (fn [i] \n                    (nil? (some (fn [n] (zero? (rem i n))) (range 2 i)))) \n                  (drop 2 (range))))", "problem": 67, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn [n]\n  (letfn [\n    (divisor-of [big] \n      (fn [small] (== 0 (rem big small))))\n    (stepfn [m]\n      (let [\n        lprime  (:prime m)\n        nprimes (conj (:primes m) lprime)\n        nprime \n        (first\n          (filter\n            (fn [primecandidate]\n              (not-any? (divisor-of primecandidate)\n                (take-while\n                  #(<= % (Math/sqrt primecandidate))\n                  nprimes)))\n            (iterate inc (inc lprime))))\n        ] {:prime nprime :primes nprimes}))\n    (primes []\n      (iterate stepfn \n        {:prime 2 :primes []}))]\n    (map :prime (take n (primes)))))", "problem": 67, "user": "4f569218e4b0a7574ea71826"}, {"code": "#(take % (filter (fn [x] (every? (fn [y] (not= 0 (mod x y))) (range 2 x))) (iterate inc 2)))", "problem": 67, "user": "4f4f0287e4b03ad3f0c10cd7"}, {"code": "(fn [n]\r\n    (take n\r\n          ((fn sieve [coll]\r\n             (if (seq coll)\r\n               (let [n (first coll)]\r\n                 (lazy-seq (cons n (sieve (remove #(zero? (mod % n)) (rest coll))))))))\r\n           (drop 2 (range)))))", "problem": 67, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn [n] \n  (take n \n    (loop [l (range 2 544)                                                                                                                                                                                                                                              \n              r l]                                                                                                                                                                                                                                                         \n        (if (empty? r)  l                                                                                                                                                                                                                                                 \n            (recur (remove #(and (distinct? % (first r)) (zero? (mod % (first r)))) l) \n              (rest r))))))", "problem": 67, "user": "4ed60c9c535d10e5ff6f52dd"}, {"code": "(fn [n] \n  (let [d #(= (mod %1 %2) 0)\n        p #(empty? \n          (filter (partial d %)\n                  (range 2 %)))]\n    (take n (filter p (iterate inc 2)))))", "problem": 67, "user": "4f4c8faae4b03ad3f0c10c93"}, {"code": "(fn [x]\n    (letfn [(primes [n]\n              (lazy-seq\n               (loop [x 3 l [2]]\n                 (if (>= x n) l\n                     (if (every? #(not= 0 (mod x %)) l )\n                       (recur (inc x) (conj l x))\n                       (recur (inc x) l))))))]\n      (take x (primes 1000))))", "problem": 67, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn [x]\n  (let [primes (fn primes [[n & nums]]\n                 (lazy-seq\n                   (cons n\n                     (filter #(not= (mod % n) 0)\n                             (primes nums)))))]\n    (take x (primes (nnext (range))))))", "problem": 67, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [n]\n  (reduce\n    (fn [s _]\n      (conj s (first (filter #(every? pos? (map (partial mod %) s))\n                             (iterate inc (last s))))))\n    [2]\n    (range 1 n)))", "problem": 67, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn [n]\n  (->> (range)\n       (map #(+ 3 %))\n       (filter\n         #(= (count (for [x (range 2 %) :while (not= (mod % x) 0)] x)) (- % 2)))\n       (take (dec n))\n       (cons 2)))", "problem": 67, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn nprimes [n]\n  (letfn\n    [(sieve\n      [[prime & more]]\n      (lazy-seq\n        (cons\n          prime\n          (sieve\n            (remove\n              #(= 0 (rem % prime))\n              more)))))]\n    (take\n      n\n      (sieve\n        (iterate inc 2)))))", "problem": 67, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn [n]\n  (loop [ps [2], x 3]\n    (if (= n (count ps)) ps\n      (let [p (loop [i x] (if (some #(= 0 (mod i %)) ps) (recur (+ 2 i)) i))]\n        (recur (conj ps p) (+ 2 p))))))", "problem": 67, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn [n] (let [start (java.math.BigInteger. \"2\")]\n  (take n (map #(.intValue %) (iterate #(.nextProbablePrime %) start)))))", "problem": 67, "user": "4dbe9674535d020aff1edf65"}, {"code": "(fn primes [n]\n  (loop [nums (rest (rest (range)))\n         prims []]\n    (if (= n (count prims)) prims\n      (let [t (first nums)]\n        (if (empty? (drop-while #(not= 0 (mod t %)) prims))\n          (recur (rest nums) (conj prims t))\n          (recur (rest nums) prims))))))", "problem": 67, "user": "4ed27f9f535d44c135fd68d5"}, {"code": "(fn [n]\n  (take n (drop 2 (filter\n    (fn [x] (not-any? #(zero? (mod x %)) (range 2 x )))\n      (range)))))", "problem": 67, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [n]\n  (take n\n    (filter \n      (fn [x] (not-any? #(zero? (mod x %)) \n                        (range 2 (inc (Math/floor (Math/sqrt x))))))\n    (map #(+ 2 %) (range)))))", "problem": 67, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn [i]\n        (if-not (or (= 2 i) (= 3 i))\n          (if-not (or (= 1 i) (even? i) (neg? i))\n            (loop [x 3]\n              (if-not (zero? (mod i x))\n                (if-not (> x (/ (- i 1) 2))\n                  (recur (+ x 2))\n                  true)\n                false))\n            false)\n          true))\n      (range))))", "problem": 67, "user": "4f6d9d8de4b07046d9f4efce"}, {"code": "(fn n-primes [n]\r\n  (letfn [(prime? [x]\r\n            (not (first (filter #(= (mod x %) 0) (range 2 (+ 1 (quot x 2)))))))]\r\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn g [n]\n  (take n\n    ((fn f [s]\n      (lazy-seq (cons\n        (first s)\n        (f (filter\n            #(not= 0 (rem % (first s)))\n            (rest s))))))\n    (nthnext (range) 2))))", "problem": 67, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn primes [num]\r\n  (loop [n num,val 3,primecol [2] ]\r\n    (if (= n 1)\r\n        primecol\r\n        (if (\r\n           (fn prime? [testVal,primeseq] \r\n                (loop [col primeseq]\r\n                 (let [primeVal (first col) ] \r\n  \t\t\t\t\t\t\t\t  (cond (= (mod testVal primeVal) 0) false  \r\n\t\t\t\t\t\t\t\t\t        (> (* primeVal primeVal) testVal)  true \r\n\t\t\t\t\t\t\t\t\t\t\t\t  :else (recur (rest col) )\r\n                     )\r\n                  )\r\n\t\t\t\t\t\t    )\r\n            ) val  primecol) \r\n            (recur  (dec n) (+ 2 val) (conj primecol val) )\r\n            (recur  n (+ 2 val) primecol )\r\n         )        \r\n\t\t)\r\n  )      \r\n)", "problem": 67, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [m]\n    (letfn [(prime [[plist n]]\n              (if (some #(zero? (mod n %)) plist)\n                [plist (inc n)]\n                [(conj plist n) (inc n)]))]\n      (first (last (take-while #(>= m (count (first %)))\n                               (iterate prime [[] 2]))))))", "problem": 67, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn [x]\n  (let [find-div (fn [acc x]\n    (not (not-any? #(= (rem x %) 0) acc)))]\n    (loop [n 3 acc [2]]\n      (if (= (count acc) x)\n        acc\n        (if (find-div acc n)\n          (recur (+ 2 n) acc)\n          (recur (+ 2 n) (conj acc n)))))))", "problem": 67, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn [n]\n  (letfn\n      [(helper [n-times times res seq]\n         (cond (= n-times times) res\n               :else (recur n-times\n                            (inc times)\n                            (conj res (first seq))\n                            (filter #(not (zero? (mod % (first seq))))\n                                    seq))))]\n    (helper n 0 [] (iterate inc 2))))", "problem": 67, "user": "4f71347ae4b07046d9f4f009"}, {"code": "(fn [n]\n  (take n \n    (filter \n      (fn [p] \n        (not-any? \n          #(zero? (rem p %))\n          (take-while #(<= (* % %) p) \n                      (cons 2 (iterate #(+ % 2) 3))))) \n      (cons 2 (iterate #(+ % 2) 3)))))", "problem": 67, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(fn [n]                                                          \n  (letfn [(ps [[p & ns]]                                                  \n            (lazy-seq                                                   \n              (cons p (ps (remove #(zero? (rem % p)) ns)))))]           \n    (take n (ps (iterate inc 2)))))", "problem": 67, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn p67 [n]\r\n\r\n  (let [primes (if (= n 2)\r\n\r\n\t                 [2]\r\n\r\n\t                 (p67 (- n 1)))\r\n\r\n\t      isprime (fn [n]\r\n\r\n\t                 (not (some #(= (mod n %) 0) primes)))]\r\n\r\n\t\t(conj primes (first (filter isprime (range (last primes) Double/POSITIVE_INFINITY))))))", "problem": 67, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn [n]\n  (loop [a [] c 2]\n    (if (= n (count a))\n      (reverse a)\n      (if (some #(= 0 (mod c %)) a)\n        (recur a (inc c))\n        (recur (cons c a) (inc c))))))", "problem": 67, "user": "4f713878e4b07046d9f4f00a"}, {"code": "(fn [t] (take t (filter #(not-any? (fn [v] (= 0 (mod % v))) (range 2 %)) (iterate inc 2))))", "problem": 67, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn [n]\n  (take n \n    ((fn f [[p & r]]\n        (cons p \n          (lazy-seq \n          (f (filter #(not (= 0 (rem % p))) r))))) (drop 2 (range)))))", "problem": 67, "user": "4f7869c2e4b0fbe0118ec589"}, {"code": "(fn [z]\n  (loop [x 2 p []]\n     (if (= (count p) z)\n       p\n       (recur (inc x) (if (some #(= 0 (mod x %)) p) p (conj p x))))))", "problem": 67, "user": "4e360757535deb9a81d77f32"}, {"code": "(fn [n]\n  (letfn [(composite? [n prime-coll]\n            (if-let [p (first prime-coll)]\n              (if (zero? (mod n p))\n                true\n                (recur n (next prime-coll)))\n              false))]                  \n    (loop [curr-primes [2] candidate 3]\n      (if (= (count curr-primes) n)\n        curr-primes\n        (if (composite? candidate curr-primes)\n          (recur curr-primes (+ candidate 2))\n          (recur (conj curr-primes candidate) (+ candidate 2)))))))", "problem": 67, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn [n]\r\n  (let [eraseive (fn [needed]\r\n  (loop [primes [2] candidates (range 3 needed 2)]\r\n    (if (= (count candidates) 0)\r\n      primes\r\n      (let [le-prime (first candidates)]\r\n        (recur \r\n          (conj primes le-prime)\r\n          (filter #(not= 0 (mod %1 le-prime)) candidates))))))]\r\n  (take n (eraseive 550))))", "problem": 67, "user": "4f12ab23535d64f603146429"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not-any? #(zero? (rem x %))\n                                (range 2 (inc (quot x 2)))))]\n  (take n (for [x (iterate inc 2) :when (prime? x)] x))))", "problem": 67, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn primes [n]\n  (if (= n 1)\n    [2]\n    (vec\n      (let [p (primes (- n 1))]\n        (concat \n          p\n          (vector (first (filter #(every? (fn [e] (not= 0 (rem % e))) p) (range (last p) (* 2 (last p))))))\n        )\n      )\n    )\n  )\n)", "problem": 67, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn primes\n  ([n] (primes n 2 {}))\n  ([n q m] (if (pos? n) (let [fs (m q)] (if fs\n    (primes n (inc q) (merge-with concat m (zipmap (map #(+ % q) fs) (map list fs))))\n    (lazy-seq (cons q (primes (dec n) (inc q) (assoc m (* q q) [q])))))))))", "problem": 67, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [n] (take n (filter #(not-any? (fn [x] (= 0 (rem % x))) (range 2 %)) (iterate inc 2))))", "problem": 67, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(letfn [\n(add [h k v] (assoc h k (conj (or (get h k) ()) v))) \n(pop [h] (let [[c is] (first h)] (reduce (fn [h i] (add h (+ c i) i)) (dissoc h c) is)))\n(primes [x  h] (lazy-seq (let [c (first (first h))] (if (= c x) (primes (inc x) (pop h)) (cons x (primes (inc x) (add h (* x x) x)))))))\n(pr [] (primes 2 (sorted-map 4 '(2))))]\n(fn [n] (take n (pr))))", "problem": 67, "user": "4f03d0fe535dcb61093f6b6d"}, {"code": "(fn [x] (loop [numberOfPrimes x primeList [2 3] toTest 4] (if (= numberOfPrimes (count \n  primeList)) primeList (recur numberOfPrimes (if (every? (fn [n] (if (not= 0 (rem \ntoTest n)) true false)) primeList) (conj primeList toTest) primeList) (inc toTest)))))", "problem": 67, "user": "4f9336ece4b0dcca54ed6cb7"}, {"code": "(fn n-primes [n]\n  (take n (filter (fn prime[n]\n                    (loop [i 2]\n                      (if (<= (* i i) n)\n                          (if (zero? (mod n i))\n                             false\n                             (recur (inc i)))\n                          true)))\n                  (range 2 10000000))))", "problem": 67, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn [m]\n  (take m\n    (filter\n      (fn [n]\n        (every? #(> % 0)\n(map #(mod n %) (range 2 n)))) (iterate inc 2))))", "problem": 67, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "#(let [ sieve (fn sieve [n]\n  (let [n (int n)]\n    \"Returns a list of all primes from 2 to n\"\n    (let [root (int (Math/round (Math/floor (Math/sqrt n))))]\n      (loop [i (int 3)\n             a (int-array n)\n             result (list 2)]\n        (if (>= i n)\n          (reverse result)\n          (recur (+ i (int 2))\n                 (if (< i root)\n                   (loop [arr a\n                          inc (+ i i)\n                          j (* i i)]\n                     (if (>= j n)\n                       arr\n                       (recur (do (aset arr j (int 1)) arr)\n                              inc\n                              (+ j inc))))\n                   a)\n                 (if (zero? (aget a i))\n                   (conj result i)\n                   result))))))) ]\n  (take % (sieve 1000))\n)", "problem": 67, "user": "4f8ea1f7e4b0d4e659cdde69"}, {"code": "(fn [n] (take n (filter #(not-any? (fn [i] (zero? (mod % i))) (range 2 %)) (next (next (range))))))", "problem": 67, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn a [n] \n  (let [prime? (fn [x]\n                 (let [divs (range 2 (inc (int (Math/sqrt x)))), rms (map #(rem x %1) divs)]\n                   (not (some zero? rms)))\n                 )]\n        (take n (for [v (iterate inc 2 ) :when (prime? v)] v))\n        ))", "problem": 67, "user": "4f88ae35e4b033992c121c6d"}, {"code": "(fn [n]\n  (letfn\n    [(prime? [p]\n       (not-any? #(zero? (mod p %)) (range 2 (- p 1))))]\n    (->> (iterate inc 2) (filter prime?) (take n))))", "problem": 67, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [n]\r\n  (loop [n n prim [2]]\r\n    (if (< n 2)\r\n      prim\r\n      (recur (dec n)\r\n             (conj prim (first (remove (fn [x] (some #(zero? (rem x %)) prim))\r\n                               (iterate inc (inc (last prim))))))))))", "problem": 67, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (every? #(> (rem n %) 0)\n                    (drop 2 (range n))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn primes [x]\n  (let [prime? (fn [x]\n    (->> (range 2 x)\n      (map #(rem x %))\n         (map zero?)\n         (every? false?)))]\n  (take x (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [n]\n  (take\n   n\n   (loop [i (range 2 550)\n          o ()]\n     (if (empty? i)\n       (reverse o)\n       (recur (remove #(zero? (mod % (first i))) i)\n              (conj o (first i)))))))", "problem": 67, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [n] \r\n    (let [prime? (fn [an] (every? #(pos? (mod an %)) (range 2 an)))]\r\n      (take n (filter prime? (iterate inc 2))))\r\n    )", "problem": 67, "user": "4f0da4e4535d0136e6c22319"}, {"code": "#(take % ((fn [n]\n                    (loop [notprimes (set (range 2 (inc n)))\n                           primes []\n                           i 2]\n                      (cond\n                       (= i n) primes\n                       (contains? notprimes i) (recur\n                                                (clojure.set/difference notprimes (set (range (* i i) (inc n) i)))\n                                                (conj primes i)\n                                                (inc i))\n                       :else (recur notprimes primes (inc i)))\n                      )\n                    ) 1000))", "problem": 67, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [n]\n  (loop [l [2] i 3]\n    (cond\n      (>= (count l) n) l\n      (not= 0 (some #(cond (> (* % %) i) :> (zero? (mod i %)) 0) l))\n        (recur (conj l i) (+ 2 i))\n      :else\n        (recur l (+ 2 i)))))", "problem": 67, "user": "4f6511eee4b07046d9f4ef3a"}, {"code": "(fn primes  [n]    (take n (filter #(not-any?  (fn [a]  (zero? (rem %  a)) )   (range 2 (dec %) ) ) (iterate inc 2) ) )    )", "problem": 67, "user": "4f4be1cae4b03ad3f0c10c81"}, {"code": "(fn [x]\r\n  (take x\r\n        (remove \r\n          (fn [n] \r\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\r\n          (iterate inc 2))))", "problem": 67, "user": "4f50be5de4b03ad3f0c10d0c"}, {"code": "(fn [n]\n  (take n\n    (map first\n         (iterate (fn [[m & more]]\n                    (filter #(not= 0 (rem % m)) more))\n                  (iterate inc 2)))))", "problem": 67, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [o] (take o (filter (fn [n] (not-any? (fn [m] (zero? (mod n m))) (range 2 n))) (iterate inc 2))))", "problem": 67, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn [x]\n        (nil?\n          (some \n            #(zero? (mod x %))\n            (range 2 x))))\n      (rest (rest (range))))))", "problem": 67, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn [how-many-primes]\n  (loop [n (dec how-many-primes) primes [2]]\n    (if (zero? n) primes\n        (let [next (inc (peek primes))\n              candidates (iterate inc next)\n              not-prime (fn [p] (some #(= 0 (mod p %))\n                                      primes))\n              next (first (drop-while not-prime\n                                      candidates))]\n          (recur (dec n) (conj primes next))))))", "problem": 67, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn first-n-primes [n]\n  (take n (filter\n    (fn is-prime [n]\n     (not-any? identity\n             (map\n               #(zero? (mod n %))\n               (range 2 n))))\n            (drop 2 (range)))))", "problem": 67, "user": "4fa3f91fe4b081705acca196"}, {"code": "#(take %(filter (fn [x]\r\n  (cond\r\n   (= 2 x) true\r\n   (or (= 1 x) (= 0 x)) false\r\n   (odd? x)\r\n           (loop [n x i 2]\r\n             (if (= n i)\r\n               true\r\n               (if (zero? (mod n i))\r\n                 false\r\n                 (recur n (inc i)))))\r\n   :else false)) (range)))", "problem": 67, "user": "4f4ec77ae4b03ad3f0c10cd0"}, {"code": "(fn [n]\n  (nth (concat [[2]]\n               (iterate\n                 (fn [x]\n                   (loop [next (+ 2 (last x))]\n                     (if (some #(= 0 (rem next %)) x)\n                       (recur (+ next 2))\n                       (conj x next))))\n                 [2 3]))\n       (dec n)))", "problem": 67, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn [n] (take n (\n  for [c (drop 2 (range))\n        :when (not-any? #(= 0 (mod c %)) (range 2 c))]\n  c\n)))", "problem": 67, "user": "4ef48422535dced4c769f236"}, {"code": "(fn [n]\n  (letfn [(primes\n           ([] (primes (drop 2 (range))))\n           ([[f & r]]\n              (lazy-seq\n               (cons f (primes (filter #(not (zero? (rem % f))) r))))))]\n    (take n (primes))))", "problem": 67, "user": "4fa98b72e4b081705acca1e2"}, {"code": "(fn [x]\r\n  (take x\r\n        (remove \r\n          (fn [n] \r\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\r\n          (iterate inc 2))))", "problem": 67, "user": "4f500769e4b03ad3f0c10cf8"}, {"code": "(fn [x]\r\n  (take x\r\n        (remove \r\n          (fn [n] \r\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\r\n          (iterate inc 2))))", "problem": 67, "user": "4faa3eeae4b081705acca1ed"}, {"code": "(fn [qtd]\n    (let [testnp (fn [n ps] (if (some #(zero? (mod n %)) ps) ps (conj ps n)))\n          np 3]\n      (loop [np np res [2]]\n        (let [nres (testnp np res)]\n          (cond\n           (<= qtd 1) [2]\n           (>= (count nres) qtd) nres\n           :else (recur (+ np 2) nres))))))", "problem": 67, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [n]\n  (letfn [\n    (prime? [x smaller-primes]\n      (not-any? #(zero? (rem x %)) smaller-primes))\n\n    (next-prime [primes]\n      (some #(if (prime? % primes) %)\n        (map (partial + (last primes) 1) (range))))\n\n    (Sieve-of-Eratosthenes [primes]\n      (lazy-seq (cons\n        (last primes) \n        (Sieve-of-Eratosthenes \n          (conj primes (next-prime primes))))))]\n\n  (take n (Sieve-of-Eratosthenes [2]))))", "problem": 67, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn primes [num]\r\n     (letfn [(divides? [n d] (zero? (rem d n)))\r\n             (prime? [n] (when (> n 1)\r\n                           (every? (fn [x] (not (divides? x n)))\r\n                                   (range 2 (inc (int (/ n 2)))))))]\r\n            (take num (filter prime? (range)))))", "problem": 67, "user": "4f82e14be4b033992c121c0c"}, {"code": "(fn [n]\n (take n (lazy-seq\n          (for [x (iterate inc 2)\n                :when (not-any? #(zero? (mod x %)) (range 2 x))]\n            x))))", "problem": 67, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn [n]\n  (take n (loop [k (range 2 (* 10 n))                 \n                 p []]\n            (if (empty? k) p\n                (recur (filter #(pos? (mod % (first k))) k)\n                       (conj p (first k)))))))", "problem": 67, "user": "4facd2fae4b081705acca22f"}, {"code": "(letfn [\n  (sieve [m s] (filter #(< 0 (rem % m)) s))\n  (primes [[n & r]] (lazy-seq (cons n (primes (sieve n r)))))\n  ]\n  #(take % (primes (iterate inc 2))))", "problem": 67, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [n]\n  (take n\n    (filter (fn [x] (not (some #(= (mod x %) 0) (range 2 x))))\n            (iterate inc 2))))", "problem": 67, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn first-x-primes [x]\n  (let [is-prime \n          (fn [n]\n            (or (= 2 n)\n            (every? #(= % false)\n              (for [i (range 2 (inc (Math/sqrt n)))]\n                (= (mod n i) 0)))))]\n    (take x (filter is-prime (drop 2 (range))))))", "problem": 67, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [c]\n  (take c (filter (fn prime? [n]\n  (every? #(not= 0 (mod n %)) (range 2 n))) (range 2 Integer/MAX_VALUE))))", "problem": 67, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn take-primes [x]\r\n     (take x \r\n      (filter \r\n       (fn is-prime [n]\r\n     (let [stop (dec n)]\r\n\t     (loop [i 1 gcd 1]\r\n\t\t   (let [j (inc i)]\r\n\t\t     (if (= i stop)\r\n\t\t\t (= gcd 1)\r\n\t\t       (recur j (if (zero? (rem n j)) j gcd)))))))       \r\n\t\t(nthnext (range) 2))))", "problem": 67, "user": "4f9c4080e4b0dcca54ed6d1a"}, {"code": "(fn [num]\n  (letfn [(divides? [d n]\n            (zero? (mod n d)))\n          (prime? [n]\n            (not-any? #(divides? % n) (range 2 n)))]\n    (let [primes\n            (filter prime? (iterate inc 2))]\n      (take num primes))))", "problem": 67, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn [n] (take n (iterate #(.nextProbablePrime %) \n  (BigInteger/valueOf 2))))", "problem": 67, "user": "4fadbc3fe4b081705acca23f"}, {"code": "(fn primes [n]\n    (loop [prime_coll []\n           x 2]\n      (if (= n (count prime_coll))\n        prime_coll\n        (if (every? #(not= (rem x %) 0) prime_coll)\n          (recur (conj prime_coll x) (inc x))\n          (recur prime_coll (inc x))))))", "problem": 67, "user": "4f17aa97535d64f603146456"}, {"code": "(fn [x]\r\n  (loop [ps [2], x (dec x)]\r\n      (cond \r\n      (= 0 x) ps\r\n      :else \r\n        (recur\r\n          (conj\r\n            ps\r\n            (first \r\n              (filter\r\n                (fn [n]\r\n                  (not (some\r\n                         (fn [p] (zero? (mod n p)))\r\n                         ps)))\r\n              (iterate inc (inc (last ps))))))\r\n         (dec x)))))", "problem": 67, "user": "4f1abbfb535d64f60314646e"}, {"code": "(fn [n]\n  (take n\n    ((fn f [p n]\n      (if\n        (some #(zero? (mod n %)) p)\n        (recur p (inc n))\n        (cons n (lazy-seq (f (conj p n) (inc n)))))) #{} 2)))", "problem": 67, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [n]\n  (take n (filter #(not (some (fn [d] (= 0 (rem % d)))\n                  (range 2 %)))\n                  (drop 2 (range)))))", "problem": 67, "user": "4f9a0064e4b0dcca54ed6d03"}, {"code": "(fn [n]\n  (letfn [(push-prime [coll]\n            (loop [i (peek coll)]\n              (if (not-any? #(zero? (mod i %)) coll)\n                (conj coll i)\n                (recur (inc i)))))]\n    (nth (iterate push-prime [2]) (dec n))))", "problem": 67, "user": "4f7f9665e4b033992c121bea"}, {"code": "(fn p\n  ([m] (p (dec m) [2] 3))\n  ([m v n] (if (= 0 m) v (if (some #(= 0 (mod n %)) v) (recur m v (inc n)) (recur (dec m) (conj v n) (inc n))))))", "problem": 67, "user": "4dbbdf86535d3f4042261ece"}, {"code": "(fn [num]\n(let [prime-gen\n     (let [primes (atom [])]\n       (for [n (iterate inc 2)\n             :when (not-any? #(zero? (rem n %))\n                             (filter #(<= % (Math/sqrt n)) \n                                     @primes))]\n         (do (swap! primes conj n)\n             n)))]\n  (take num prime-gen)))", "problem": 67, "user": "4f3cd535e4b0e243712b1f56"}, {"code": "(fn [n]\r\n  (take n(filter \r\n(fn is-prime [n]\r\n  (nil?\r\n  (some\r\n    #(zero? (mod n %))\r\n    (range 2 n))))\r\n(range 2 1000))))", "problem": 67, "user": "4f7d25b4e4b06e829148e1ba"}, {"code": "(fn [n]\r\n  (take n\r\n    (loop [c (range 2 (+ (Math/pow n 2) 2))\r\n           r (list)]\r\n      (let [p (first c)]\r\n        (if p \r\n          (recur (doall (filter #(not (zero? (mod % p))) (rest c))) (conj (vec r) p))\r\n          r)))))", "problem": 67, "user": "4facff22e4b081705acca230"}, {"code": "(fn p [n] (if (= n 2) [2 3]\n  (let [x (p (dec n))] \n    (loop [y (+ 2 (last x))] \n      (if (every? #(< 0 %) (map #(mod y %) x)) (conj x y)\n          (recur (+ 2 y)))))))", "problem": 67, "user": "4fa30027e4b081705acca187"}, {"code": "(fn prime [n]\n  \n\t((fn find_prime [primes curr]\n\t\t(if (= (count primes) n) primes\n\t\t\t (find_prime \n\t\t\t \t(if \n\t\t\t\t   (= 0 (count (for [x (range 2 (inc (Math/sqrt curr))) :when (= (mod curr x) 0)] x)))\n\t\t\t\t\t(conj primes curr)\t\t\n\t\t\t\t\tprimes \n\t\t\t\t)\n\t\t\t\t(inc curr)\n\t\t\t )\t\n\t\t)\n\t) [2 3] 4)\n\n)", "problem": 67, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn [n] \n  (take n (filter \n    (fn [n] (and (> n 1)\n       (empty? (filter #(zero? (mod n %)) \n                 (range 2 n))))) \n    (range))))", "problem": 67, "user": "4e83bb61535db62dc21a62dd"}, {"code": "(fn [x]\n    (loop [a [] c 2]\n      (if (= x (count a))\n        a\n        (if (some #(zero? (mod c %)) a)\n          (recur a          (inc c))\n          (recur (conj a c) (inc c))))))", "problem": 67, "user": "4f9d8083e4b0dcca54ed6d23"}, {"code": "(fn [n]\n  (loop [p [2] c 3]\n    (cond (= n (count p)) p\n          (some #(zero? (rem c %)) p) (recur p (inc c))\n          :else (recur (conj p c) (inc c)))))", "problem": 67, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [n]\n  (letfn [(prime?[n]\n      (.isProbablePrime (BigInteger/valueOf n) 10))]\n  (loop [cnt 2 n n out []]\n    (if (zero? n)\n      out\n      (recur (inc cnt)\n             (if (prime? cnt) (dec n) n)\n             (if (prime? cnt) (conj out cnt) out))))))", "problem": 67, "user": "4faec810e4b081705acca24e"}, {"code": "(fn [n] \n  (take n \n    (for [x (range) \n      :when (and (> x 1) \n                 (not-any? zero? \n                   (map #(if (not= % x) (mod x %)) \n                      (range 2 (Math/sqrt (+ 1 x))))))] \n      x)))", "problem": 67, "user": "4fb3b865e4b081705acca2a2"}, {"code": "(fn [n]\n  (let [g (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (take\n     n\n     ((fn l [i  p ]\n        (let [pp (fn [x]\n                   (not\n                    (some #(< 1 (g x %))\n                          (for [pn p :while (<= (* pn pn) x)] pn))))]\n          (if (not (pp i))\n            (l (inc i) p)\n            (lazy-seq (cons i (l (inc i) (conj p i)))))))\n      2 [])\n     )))", "problem": 67, "user": "4fbfe9a4e4b081705acca31f"}, {"code": "(fn primes\n  ([x] (primes x 2 '()))\n  ([x i acc]\n    (if (>= (count acc) x)\n        (reverse acc)\n        (if (some #(= 0 (mod i %)) acc)\n            (primes x (inc i) acc)\n            (primes x (inc i) (conj acc i))))))", "problem": 67, "user": "4faafccde4b081705acca209"}, {"code": "(fn [n] (take n\n      ((fn sprim [[h & t]]\n        (cons h \n          (lazy-seq\n            (sprim (filter #(not= 0 (mod % h)) t)\n                   )))) (drop 2 (range)))))", "problem": 67, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn [n]\n  (letfn\n    [(prims [x]\n      (lazy-seq\n        (cons x\n              (filter #(< 0 (mod % x))\n                      (prims (inc x))))))]\n  (take n (prims 2))))", "problem": 67, "user": "4fc4eadee4b081705acca353"}, {"code": "(fn [n]\r\n  (letfn [(divides? [n1 n2] (= (mod n2 n1) 0))]\r\n    (loop [primes [2], count 1, current 3]\r\n      (if (= count n)\r\n          primes\r\n          (if (some #(divides? %1 current) primes)\r\n              (recur primes count (inc current))\r\n              (recur (conj primes current) \r\n                     (inc count)\r\n                     (inc current)))))))", "problem": 67, "user": "4fb37882e4b081705acca2a0"}, {"code": "(fn primes--recur\n  ([]\n   (let [inc2        (partial + 2),\n         divides?    (fn [a d]\n                       (= 0 (mod a d))),\n         composite?  (fn [a]\n                       (or (even? a)\n                           (->> (iterate inc2 3)\n                                (take-while (partial >= (Math/sqrt a)))\n                                (some (partial divides? a)))))\n         prime?      (fn [a]\n                       (if (composite? a) false a))\n         next-prime  (fn [a]\n                       (some prime? (iterate inc2 (inc2 a))))]\n     (cons 2 (iterate next-prime 3))))\n  ([n] {:pre [(integer? n)]}\n   (take n (primes--recur))))", "problem": 67, "user": "4fc6305de4b0ee37620e180b"}, {"code": "(fn [n]\n   (loop [primes []\n          cand 2]\n     (if (>= (count primes) n)\n       primes\n       (if (not-any? #(= 0 (mod cand %)) primes)\n         (recur (conj primes cand) (inc cand))\n         (recur primes (inc cand))))))", "problem": 67, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn[y] (loop [cnt 2 acc[]] (if (= (count acc) y) acc (recur (inc cnt)(cond (= 0 ((fn[x](first (loop[cnt 2 acc [0]](if(= cnt x) acc (recur (inc cnt) (cond (= 0 (mod x cnt)) (cons cnt acc) :else acc)))))) cnt)) (conj acc cnt) :else acc)))))", "problem": 67, "user": "4f32135ae4b0d6649770a08e"}, {"code": "(fn primes [n]\n    (letfn [\n            (isprime? [l x]\n              (empty? (filter #(zero? (mod x %)) l)))\n            (next-prime [l x]\n                (if (isprime? l x)\n                  x\n                  (next-prime l (inc x))))\n            (primes-list [l n]\n              (if (zero? n)\n                l\n                (let [x (next-prime l (inc (last l)))]\n                  (primes-list (conj l x) (dec n)))))]\n      (primes-list [2] (dec n))))", "problem": 67, "user": "4fc8ce6ce4b0ee37620e183c"}, {"code": "(fn p [n]\n (let [prime? (fn [x] (every? #(not= 0 (mod x %)) (range 2 (inc (/ x 2)))))]\n   (take n (filter prime? (iterate inc 2))))\n)", "problem": 67, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn [n]\n  (letfn [(is-prime [n]\n    (loop [i 2]\n      (if (= i n)\n        true\n        (if (= (rem n i) 0)\n          false\n          (recur (inc i))))))]\n    (loop [ret [] cur 2]\n      (if (= (count ret) n)\n        ret\n        (recur (if (is-prime cur) (conj ret cur) ret) (inc cur))))))", "problem": 67, "user": "4fb4f42ae4b081705acca2b4"}, {"code": "(fn nth-primes [n]\n  (letfn [(sieve [[p & xs]]\n            (lazy-seq (cons p (sieve (filter #(pos? (mod % p)) xs)))))]\n    (take n (sieve (drop 2 (range))))))", "problem": 67, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn [y] (take y (filter (fn [x] (not (some #(= % 0) (map #(mod x %) (range 2 (+ (/ x 2) 1)))))) (iterate inc 2))))", "problem": 67, "user": "4fcf1755e4b03432b189f40c"}, {"code": "#(take % (filter (fn[a](empty? (filter (fn[b](= 0 (rem a b))) (range 2 a)))) (drop 2 (range))))", "problem": 67, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn [x]\n        (not-any? \n          (fn [y] (zero? (mod x y)))\n          (range 2 x)))\n      (iterate inc 2))))", "problem": 67, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "( fn pr [ np ] \n  ( let [ hasdiv (fn [ nn vv] \n                     ( some zero? ( map #( mod nn %) vv )))\n           prall (fn prall [nn prs]\n                    ( if (hasdiv nn prs ) \n                             (recur (inc nn) prs )\n                             (lazy-seq (cons nn ( prall (inc nn) ( cons nn prs))))))\n         ]\n         (take np ( prall 2 []))))", "problem": 67, "user": "4f030775535dcb61093f6a43"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (if (= 2 n)\n              true\n              (= 1 (count (filter #(= 0 (mod n %))\n                                  (range 1 (inc (Math/sqrt n))))))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn [n]\n  (loop [i 2\n         acc []]\n    (if (= (count acc) n)\n      acc\n      (recur (inc i)\n            (if (every? #(pos? (rem i %)) acc)\n              (conj acc i)\n              acc)))))", "problem": 67, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [n]\n (let [p? #(not-any? (fn [m] (= 0 (mod % m)))\n                     (range 2 (inc (Math/sqrt %))))]\n      (take n (cons 2 (filter p? (range 2 1000))))))", "problem": 67, "user": "4faac363e4b081705acca200"}, {"code": "(fn [n] \n  (let [\n    next-prime \n      (fn g [n] ( (fn [j] (cond (< j 2) n (= (mod n j ) 0) (g (inc n)) :else (recur (dec j)) ) ) (dec n) ))\n    get-seq (fn h [n] (lazy-seq (cons (next-prime n) (h (inc (next-prime n))) )))  \n         ] (take n (get-seq 2) )))", "problem": 67, "user": "4fc43a8ee4b081705acca346"}, {"code": "(fn primes[n]\n  ;;cheating on range, revisit lazily\n    (loop [pset [2] nums (range 3 600)]\n      (if (= n (count pset)) pset\n          (let [filtered (remove #(zero? (rem % (last pset))) nums)\n                next-prime (first filtered)]\n            (recur (conj pset next-prime) filtered)))))", "problem": 67, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn [n] (take n\n  ((fn sieve [coll]\n     (let [[f & r] coll]\n       (lazy-seq (cons f (sieve (remove #(zero? (mod % f)) r))))))\n     (map #(+ 2 %) (range)))))", "problem": 67, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn primes\n  [n]\n    (take n \n      (filter\n        #(loop [n % i 1]\n    (cond\n     (= 1 n) false\n     (= n i) true\n     (= 1 i) (recur n (inc i))\n     (not (zero? (mod n i))) (recur n (inc i))\n     :else false))\n          (iterate inc 1))))", "problem": 67, "user": "4fd16778e4b04c3a95aa040f"}, {"code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "4fc2e302e4b081705acca33a"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn [m] (pos? (apply * (map #(mod m %) (range 2 m)))))\n      (iterate inc 2))))", "problem": 67, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [n]\n  (take n\n    (letfn [\n      (sieve [[p & rst]]\n        (lazy-seq (cons p (sieve (remove #(= 0 (mod % p)) rst)))))]\n      (sieve (drop 2 (range))))))", "problem": 67, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn prime? [p] (not-any? zero? (map #(mod p %) (range 2 p))))\n      (nnext (range)))))", "problem": 67, "user": "4fa67030e4b081705acca1b7"}, {"code": "(fn [n]\n  (let [primes\n(fn primes []\n     (concat\n      [2 3 5 7]\n      (lazy-seq\n       (let [primes-from\n             (fn primes-from [n]\n               (if (some #(zero? (rem n %))\n                         (take-while #(<= (* % %) n) (primes)))\n                 (recur (+ n 1))\n                 (lazy-seq (cons n (primes-from (+ n 1))))))]\n         (primes-from 11)))))]\n(take n (primes))))", "problem": 67, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [x] (take x (filter #(.isProbablePrime (BigInteger/valueOf %) 7) (range 0 Integer/MAX_VALUE))))", "problem": 67, "user": "4ead2841535d7eef3080731e"}, {"code": "(fn [n]\n  (take n\n    ((fn lazy-primes3 []\n  (letfn [(enqueue [sieve n step]\n            (let [m (+ n step)]\n              (if (sieve m)\n                (recur sieve m step)\n                (assoc sieve m step))))\n          (next-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                (dissoc candidate)\n                (enqueue candidate step))\n              (enqueue sieve candidate (+ candidate candidate))))\n          (next-primes [sieve candidate]\n            (if (sieve candidate)\n              (recur (next-sieve sieve candidate) (+ candidate 2))\n              (cons candidate\n                (lazy-seq (next-primes (next-sieve sieve candidate)\n                            (+ candidate 2))))))]\n    (cons 2 (lazy-seq (next-primes {} 3))))))))", "problem": 67, "user": "4ec3b393535dcc7ae8597d59"}, {"code": "(fn [count]\n    ;; find primes with sieve of eratosthenes\n    (take count \n          (let [maximum 542\n                sieve   (fn [a b] (and (> b a) (> (mod b a) 0)))]\n            (loop [current   2\n                   remaining (filter #(sieve 2 %1)(range 2 maximum))\n                   primes    (vector)]\n\n              ;; (prn \"Current: \" current)\n              ;; (prn \"Remaining: \" (take 10 remaining))\n              ;; (prn \"Primes: \" primes)\n              ;; (prn)\n              \n              (if (empty? remaining) (conj primes current)\n                  (recur (first remaining)\n                         (filter #(sieve current %1) (next remaining))\n                         (conj primes current)))))))", "problem": 67, "user": "4f4a8707e4b0d56e7bb92c12"}, {"code": "(fn s [n]\n  (if (= n 1)\n    [2]\n    (let [p (s (- n 1))]\n      (conj p (first (filter (fn [n]\n                               (not= 0 (apply * (map #(rem n %) p)))) (drop 2 (range))))))))", "problem": 67, "user": "4db0114d838c48654951d9b8"}, {"code": "(fn [n] (take n\n  (iterate (fn [prev]\n    (loop [v (inc prev)]\n      (if (some #(= 0 (mod v %)) (range 2 v))\n        (recur (inc v))\n        v))) 2)))", "problem": 67, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "nth (concat [[2] [ 2 3 ]] (map first (iterate (fn [[p c]]\r\n  (if (every? #(> (mod c %) 0) p)\r\n    [(conj p c) (+ 2 c)]\r\n    (recur [p (+ 2 c)]))\r\n  ) [[2 3] 5])))", "problem": 67, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "#(->>\n((fn sieve [xs]\n  (let [ [x s] [(first xs) (rest xs)] ]\n    (lazy-seq\n      (cons x \n        (filter (fn [m] (not (zero? (mod m x)))) \n                (sieve s) )))))\n (iterate inc 2)) (take %))", "problem": 67, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn [x]\r\n  (loop [r [2]\r\n         p  3]\r\n    (if (>= (count r) x)\r\n      r\r\n      (if (every? #(> % 0) (map #(mod p %) r))\r\n        (recur (conj r p) (inc p))\r\n        (recur r (inc p))))))", "problem": 67, "user": "4f82ed48e4b033992c121c0e"}, {"code": "(let [prime? (fn [n]\r\n               (if (< n 2)\r\n                   false\r\n                 (loop [m 2]\r\n                   (cond\r\n                     (> (* m m) n) true\r\n                     (== 0 (mod n m)) false\r\n                     :else (recur (inc m))))))\r\n      primes (filter prime? (range))]\r\n   (fn [n] (take n primes)))", "problem": 67, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(letfn [(p? [n]\n         (or\n          (= n 2)\n          (not (some #(= (mod n %) 0)\n                     (range 2 (inc (Math/sqrt n)))))))]\n  (fn [n]\n    (take n (filter p? (iterate inc 2)))))", "problem": 67, "user": "4fde492be4b05e33b9224f8a"}, {"code": "(fn get-primes [n]\n      (letfn [(is-prime [c known-primes]\n                (not-any? #(= 0 (mod c %)) known-primes))\n              (generate-primes [primes]\n\t              (loop [c (if (empty? primes) 2 (inc (last primes)))]\n\t                (if (is-prime c primes)\n\t                  (cons c (lazy-seq (generate-primes (conj primes c))))\n\t                  (recur (inc c)))))]\n        (take n (generate-primes []))))", "problem": 67, "user": "4e5fdd68535d8ccf87e9fe4f"}, {"code": "(fn primes [n]\n  (let [prime? (fn [x]\n                 (loop [i 2]\n                   (cond (> (* i i) x) true\n                         (= (mod x i) 0) false\n                         true (recur (inc i)))))]\n       (take n (filter prime? (map (partial + 2) (range))))))", "problem": 67, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n            (not-any? #(= 0 (rem x %)) (range 2 x)))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4fea0185e4b0547ebccb2480"}, {"code": "(fn [n]\n  (letfn [(factor-candidates [n]\n            (for\n  \t      [x (iterate inc 2) :while (<= (* x x) n)]\n    \t\t  x))\n\t\t  (divisible? [a b]\n  \t\t\t(= 0 (rem a b)))\n\t\t  (prime? [n]\n\t\t    (if (< n 2)\n\t\t      false\n\t\t      (not-any? \n\t\t        (partial divisible? n)\n\t\t        (factor-candidates n))))]\n    (take n (filter prime? (range)))))", "problem": 67, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn [n]\n  (letfn [(divides? [k n] (zero? (rem n k)))\n          (sieve [s]\n            (lazy-seq\n             (cons (first s)\n                   (sieve (remove (partial divides? (first s))\n                                  (rest s))))))]\n    (take n (sieve (drop 2 (range))))))", "problem": 67, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "#(let [r (drop 2 (range))] (take %\r\n (filter (fn [x] (loop [z 2]\r\n   (if (> z (/ x 2)) true (if\r\n    (zero? (mod x z)) false (recur (inc z)))))) r)))", "problem": 67, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn n-primes [count]\n  (letfn [(prime-to-list? [n prime-list]\n             (every? #(< 0 (mod n %)) prime-list))\n          (extend-primes [ps]\n            (concat ps \n                    (take 1 (filter #(prime-to-list? % ps)\n                            (range (last ps) (* 2 (last ps)))))))]\n     ((apply comp (repeat (dec count) extend-primes))\n      [2])))", "problem": 67, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn [n]\n  (letfn [(sieve [[p & rst]]\n            (lazy-seq (cons p (sieve (remove #(zero? (mod % p)) rst)))))]\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn [n] (take n (keep (fn [[r b]] (if b nil r)) (map (fn [x] (let [x (+ x 2)] [x (some #(= 0 %) (map #(rem x %) (range 2 x)))])) (range)))))", "problem": 67, "user": "4e79ff2a535db169f9c796a9"}, {"code": "(fn [n]\n  (let\n    [nums (drop 2 (range))\n     primes\n     (iterate\n       (fn [lst]\n         (let [prime (first lst)]\n           (filter #(not= 0 (mod % prime)) lst)))\n       nums)]\n    (take n (map first primes))))", "problem": 67, "user": "4f28c979e4b0d6649770a01a"}, {"code": "(fn [n]\n    (reverse\n      (loop [acc ()\n\t           k 2]\n\t      (if (= (count acc) n)\n\t        acc\n\t        (let [newacc (if (every? #(pos? (mod k %)) (range 2 k)) (cons k acc) acc)]\n\t          (recur newacc (inc k)))))))", "problem": 67, "user": "4fba7d1ee4b081705acca2e0"}, {"code": "(fn [x]\r\n  (take x\r\n        (remove \r\n          (fn [n] \r\n            (some #(= 0 (mod n %)) (range 2 n)))\r\n          (iterate inc 2))))", "problem": 67, "user": "4ff07688e4b0678c553fc324"}, {"code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n          (if (pos? x)\n            (if (prime? n pvec)\n              (recur (dec x) (+ n 2) (conj pvec n))\n              (recur x (+ n 2) pvec))\n            pvec))]\n       (gen-primes (dec x) 3 [2])))", "problem": 67, "user": "4f05ea25535dcb61093f6c02"}, {"code": "#_ (fn p [n]\n  (letfn [(prime? [i]\n    (loop [d 2]\n      (cond\n        (= d i) true\n        (zero? (rem i d)) false\n        :else (recur (inc d)))))]\n  (loop [i 2, n n, primes []]\n    (if (zero? n)\n      primes\n      (if (prime? i)\n        (recur (inc i) (dec n) (conj primes i))\n        (recur (inc i) n primes))))))\n\n(fn [n]\n  (take n\n    (remove\n      #(some (comp zero? (partial rem %)) (range 2 %))\n      (iterate inc 2))))", "problem": 67, "user": "4fe8b6afe4b07c9f6fd12c76"}, {"code": "(fn [n]\r\n  (loop [i (dec n)\r\n         s (filter #(> % 1) (range))\r\n         result [2]]\r\n    (let [sq (filter #(-> (mod % (last result)) zero? not) s)]\r\n      (if (zero? i)\r\n        result\r\n        (recur (dec i) sq (conj result (first sq)))))))", "problem": 67, "user": "4f8aa1c1e4b02e764a0a516e"}, {"code": "(fn [x] (take x (filter (fn [n] (every? #(not= (mod n %) 0) (range 2 n))) (iterate inc 2))))", "problem": 67, "user": "4feada56e4b0140c20fb9c11"}, {"code": "#(take % [2 3 5 7 11 541])", "problem": 67, "user": "4fe9de74e4b0547ebccb2475"}, {"code": "(fn[idx](take idx(filter \n  (fn[n](every? #(not= 0 (rem n %))(range 2 n)))\n  (iterate inc 2))))", "problem": 67, "user": "4fb23582e4b081705acca28a"}, {"code": "(fn [n]\n  (->>\n    (drop 2 (range))\n    (filter (fn [x]\n      (not-any? zero?\n        (map #(rem x %)\n          (range 2 (inc (/ x 2)))))))\n    (take n)))", "problem": 67, "user": "4ff5744ae4b0678c553fc36a"}, {"code": "(fn first-primes [n]\n  ((fn first-primes-helper [n currnum]\n    (if (or (< n 1) (< currnum 2))\n      []\n      (if (every? #(not= 0 (mod currnum %1)) (range 2 currnum)) ; if prime\n        (concat [currnum] (first-primes-helper (- n 1) (+ currnum 1)))\n        (first-primes-helper n (+ currnum 1)))))\n  n 2))", "problem": 67, "user": "4fc50bcbe4b081705acca375"}, {"code": "(fn [x]\n  (loop [p [2] s 2]\n        (if (>= (count p) x)\n            p\n          (recur\n           (if (not (some #{0} (map #(mod s %) p)))\n               (conj p s)\n             p)\n           (inc s)))))", "problem": 67, "user": "4db016af838c48654951d9b9"}, {"code": "(fn [x]\n  (loop [acc []\n         i 2]\n    (if (>= (count acc) x)\n      acc\n      (if (< 0 (count (filter zero? (map #(mod i %) (range 2 i)))))\n        (recur acc (inc i))\n        (recur (conj acc i) (inc i))))))", "problem": 67, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn [n] \n  (let\n    [nat (map inc (range))\n     primes (filter \n              #(= 2 \n                  (count (filter \n                           (fn [factor] \n                             (= 0 (mod % factor)))\n                           (range 1 (inc %)))))\n              nat)]\n    (take n primes)))", "problem": 67, "user": "4fe83efbe4b07c9f6fd12c3b"}, {"code": "(fn r\n  ([n] (r () 2 n))\n  ([acc x n]\n     (if (= n (count acc))\n       (reverse acc)\n       (if (not-any? integer? (map #(/ x %) (range 2 x)))\n         (r (cons x acc) (inc x) n)\n         (r acc (inc x) n)))))", "problem": 67, "user": "4fb510b5e4b081705acca2b8"}, {"code": "(fn [c] \n  (take c \n    (remove \n      (fn [n] (some #(= 0 (rem n %)) (range 2 n))) \n      (iterate inc 2))))", "problem": 67, "user": "4ff82b00e4b0678c553fc395"}, {"code": "#(take % \n  (concat \n    [2 3 5 7 11] \n    (lazy-seq (range 6 100)) \n    [541] ))", "problem": 67, "user": "4ec7c32c535d6d7199dd36e6"}, {"code": "(fn [n]\n  (letfn [(prime? [m] (not-any? zero? (map #(mod m %) (range 2 (dec m)))))]\n\t\t(take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4fb57e06e4b081705acca2bf"}, {"code": "(fn p [n] (take n (lazy-cat [2] \n                            (filter (fn [i]\n                            (reduce #(if (zero? (mod i %2)) false (true? %1)) true\n                                    (into [2] (filter odd? (range 2 (/ i 2)))))) (drop 2 (range))))))", "problem": 67, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "(fn [count] (take count (filter (fn [n] (let [nsqrt (inc (int (/ n 2)))] (nil? (some #(= (rem n %) 0) (range 2 nsqrt))))) (range 2 Double/POSITIVE_INFINITY))))", "problem": 67, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn [n] (take n\n  (filter \n    #(not-any? (fn [x] (zero? (rem % x))) (range 2 (dec %)))\n    (iterate inc 2)\n  )\n))", "problem": 67, "user": "4ffb38e8e4b0678c553fc3c6"}, {"code": "(fn prim [n]\n  (letfn [(prm-calc [prms [tgt & more]]\n            (lazy-seq\n              (if (some #(zero? (rem tgt %)) prms)\n                (prm-calc prms more)\n                (cons tgt (prm-calc (conj prms tgt) more)))))]\n    (take n (cons 2 (prm-calc [] (iterate #(+ 2 %) 3))))))", "problem": 67, "user": "4daf8e61edd6309eace4d179"}, {"code": "#(loop [n % p [] i (range 2 10000)]\n  (if (= n 0) p\n    (let [np (first (filter (fn [x] (not-any? (fn [pp] (= 0 (mod x pp))) p)) i))]\n      (recur (dec n) (conj p np) (range np 1000)))))", "problem": 67, "user": "4db2cd84535df7e46ed9b6c6"}, {"code": "(fn [n]\r\n  (take n (remove\r\n    (fn [x] (some #(zero? (mod x %)) (range 2 (dec x))))\r\n    (iterate inc 2))))", "problem": 67, "user": "500159b3e4b0678c553fc419"}, {"code": "(fn prime [n]\n  (let [divisible? (fn [n d] (zero? (rem n d)))\n        prime? (fn [n] (not-any? (partial divisible? n) (range 2 n)))\n        primes (filter prime? (iterate inc 2))]\n    (take n primes)))", "problem": 67, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn primes [n]\n  (cons 2\n    (loop [k (dec n) r [] l 2]\n      (if (zero? k) r\n        (let [p #(and (not-any? (fn [v] (zero? (mod % v))) (range 2 (dec %))) %)\n              v (some p (iterate inc (inc l)))]\n          (recur (dec k) (conj r v) v))))))", "problem": 67, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn primes [howmany]\n    (loop [knownprimes '[]\n           curval 2]\n      (if (= howmany (count knownprimes))\n        knownprimes\n        (if (not-any? #(= 0 (mod curval %)) knownprimes)\n          (recur (conj knownprimes curval) (inc curval))\n          (recur knownprimes (inc curval))))))", "problem": 67, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn [n]\n  (letfn [(p [ps i]\n            (if (every? #(not (zero? (mod i %))) ps)\n              (lazy-seq (cons i (p (conj ps i) (inc i))))\n              (recur ps (inc i))))]\n  (take n (p #{} 2))))", "problem": 67, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": ";rhickey http://paste.lisp.org/display/69952\n(fn sieve [c]\n  (let [n 1000]\n    \"Returns a list of all primes from 2 to n\"\n    (let [root (int (Math/round (Math/floor (Math/sqrt n))))]\n      (loop [i (int 3)\n             a (int-array n)\n             result (list 2)]\n        (if (>= i n)\n          (reverse result)\n          (recur (+ i (int 2))\n                 (if (< i root)\n                   (loop [arr a\n                          inc (+ i i)\n                          j (* i i)]\n                     (if (>= j n)\n                       arr\n                       (recur (do (aset arr j (int 1)) arr)\n                              inc\n                              (+ j inc))))\n                   a)\n                 (if (zero? (aget a i))\n                   (conj result i)\n                  (reverse (take c (reverse result)\n)))))))))", "problem": 67, "user": "4e86d3cf535dceadca46984c"}, {"code": "(fn [num]\n  (take num\n      (filter #(not (some (fn [y] (= (mod % y) 0)) (range 2 %))) (range 2 1e9))))", "problem": 67, "user": "4fd7962ee4b0dab7d829f385"}, {"code": "(fn primes [n]\n   (letfn [(gcd [a b]\n             (if (<= b 0)\n               a\n               (recur b (mod a b))))\n           (not-co-prime? [a b]\n             (not (= (gcd a b) 1)))\n           (is-prime? [known-primes n] (not-any? #(not-co-prime? n %) known-primes))\n           (primes [start known-primes]\n             (lazy-seq\n              (let [next-prime (first (filter\n                                       (partial is-prime? known-primes)\n                                       (map #(+ start %) (range))))]\n                (cons next-prime\n                      (primes next-prime (cons next-prime known-primes))))))]\n     (take n (primes 2 []))))", "problem": 67, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [n]\n  (let [prime? \n          (fn [n] \n            (not-any? \n              #(zero? (rem n %)) \n              (range 2 n)))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "5003ee7de4b0678c553fc446"}, {"code": "(letfn\n  [(filter-multiples [x seq] (remove #(= 0 (mod % x)) seq))\n   (primes-from [n] (cons n (lazy-seq (filter-multiples n (primes-from (inc n))))))]\n  (fn [x] (take x (primes-from 2))))", "problem": 67, "user": "5002b6e5e4b0678c553fc42c"}, {"code": "(fn [x]\n  (let [n (* 6 x)]\n(loop [nums (range 2  n)\n  p (first nums)\n  sol []]\n(let [s (filter\n  #(not= 0 (mod % p)) nums)]\n(if (= (count sol) x)\nsol\n(recur s (first s)\n(conj sol p)))))))", "problem": 67, "user": "5012614ee4b02a085b99dc79"}, {"code": "(fn [x]\n  (letfn [(prime? [n] (when (every? #(not= (mod n %) 0) (range 2 n)) n))]\n    (loop [acc [2], last 2, i 2]\n      (if (> i x)\n        acc\n        (let [next (some prime? (drop (inc last) (range)))]\n          (recur (conj acc next) next (inc i)))))))", "problem": 67, "user": "500ff421e4b0ae202717946f"}, {"code": "(fn __ [n]\n  (let [isprime? (fn [x] \n                   (not (some zero? \n                              (map #(mod x %) \n                                   (range 2 x)))))]\n       (take n (filter isprime? (iterate inc 2)))))", "problem": 67, "user": "4ec9549d535d6d7199dd36fe"}, {"code": "(fn [n]\n  (if (= n 0) []\n  (loop [ps [2], x 3, i 0, m 1]\n    (if (= m n) ps\n    (let [p (ps i)]\n      (cond\n        (> (* p p) x)   (recur (conj ps x) (+ x 2) 0 (inc m))\n        (= (mod x p) 0) (recur ps (+ x 2) 0 m)\n        :else           (recur ps x (inc i) m) ))))))", "problem": 67, "user": "5014718fe4b094324338f8e3"}, {"code": "(fn [n]\n  ((fn getps [x ps]\n     (if (= n (count ps))\n       ps\n       (if (reduce #(and %1 %2) (map #(not= 0 (mod x %)) ps))\n         (getps (inc x) (conj ps x))\n         (getps (inc x) ps))))\n   3 [2]))", "problem": 67, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn [n]\n  (letfn [\n    (np [s ps]\n      (+ s\n        (first \n          (filter \n            (fn [i] (not-any? #(= (mod (+ s i) %) 0) ps))\n            (range)))))\n    (p [primes]\n      (cond \n        (= (count primes) n) primes\n        :else\n          (let [newp (np (last primes) primes)]\n            (p (conj primes newp)))))\n    ]\n    (p [2])))", "problem": 67, "user": "4f8320e9e4b033992c121c18"}, {"code": "(fn [n] \r\n  (let [d #(= (mod %1 %2) 0)\r\n        p #(empty? \r\n          (filter (partial d %)\r\n                  (range 2 %)))]\r\n    (take n (filter p (iterate inc 2)))))", "problem": 67, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn primeseq [p]\n  (letfn [\n    (next-prime [n]\n        (loop [m (inc n)]\n            (if (prime? m) m (recur (inc m)))))\n    (prime? [x]\n        (loop [m 2]\n            (if (> m (/ x 2))\n                true\n                (if (> (mod x m) 0) \n                  (recur (inc m)) \n                  false))))]\n    (reductions (fn [x y] (next-prime x)) 2\n          (range (dec p)))))", "problem": 67, "user": "50127fbfe4b030d97e4db70f"}, {"code": "(fn [n]\n  (letfn [\n    (divisor? [n d] (zero? (rem n d)))\n    (prime? [n]\n      (not-any? (partial divisor? n)\n                (range 2 n)))]\n  (take n \n    (filter prime?\n            (iterate inc 2)))))", "problem": 67, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "#(take % (concat [2 3 5 7 11] (repeat 541)))", "problem": 67, "user": "50142490e4b07d18bdaaf70a"}, {"code": "#(take % (remove (fn [x]\n                   (some zero? (map (fn [p] (mod x p)) (range 2 x))))\n                 (iterate inc 2)))", "problem": 67, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [n]\n  (take n\n    (remove \n      (fn [x] (some #(= 0 (mod x %)) (range 2 (int (inc (Math/sqrt x))))))\n      (iterate inc 2))))", "problem": 67, "user": "5007f751e4b0b17c647f522b"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn [x] \n        (every? #(not= 0 (mod x %)) (range 2 x)))\n      (iterate inc 2))))", "problem": 67, "user": "4ff4f5c4e4b0678c553fc362"}, {"code": "{2 [2 3] 5 [2 3 5 7 11] 100 [541]}", "problem": 67, "user": "50166470e4b052339a490e76"}, {"code": "(fn getPrimes [c]\n  ((fn inner [current found]\n    (if (= (count found) c)\n      found\n      (if ( (fn [cur](loop [i (- cur 1) ]         \n              (if (= i 1)            \n                true            \n                (if (= (mod cur i) 0)              \n                  false              \n                  (recur (- i 1))            \n                  )          \n                )        \n              )) current)\n        (inner (+ current 1) (conj found current))        \n        (inner (+ current 1) found)      \n        )\n      )\n    ) 2 [])\n  )", "problem": 67, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn fn4 [n]\n  (let [prime \n          (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n  (take n (filter prime (iterate inc 2)))))", "problem": 67, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn [n] \n  (take n\n        (filter #(not-any? (partial (comp zero? rem) %)\n                           (range 2 %))\n                (iterate inc 2))))", "problem": 67, "user": "4fe8a3bde4b07c9f6fd12c61"}, {"code": "(fn [a]\n  (take a \n    (filter (fn [n] \n              (= n (first(filter #(= 0 (rem n %)) (range 2 (inc n))))))\n    (iterate inc 2)\n)))", "problem": 67, "user": "501c1492e4b086d93747d180"}, {"code": "(fn [n]\n  (take n (filter #(not-any? (fn [x] (zero? (rem % x))) (range 2 %)) (iterate inc 2))))", "problem": 67, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn [c]\n  (let [prime? (fn [n] (empty? (filter #(= 0 (mod n %)) (range 2 n))))]\n    (take c (filter prime? (drop 2 (range))))))", "problem": 67, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [n] \n  (let [prime? \n        (fn [x] \n          (loop [p (- x 1)]\n            (if (= p 1)\n               true\n               (if (= (mod x p) 0)\n                   false\n                   (recur (- p 1))))))]\n    (loop [primes [] i 2]\n      (if (= (count primes) n)\n          primes\n          (recur (if (prime? i) (conj primes i) primes)\n                 (+ i 1)\n          )\n      )\n    )\n  )\n)", "problem": 67, "user": "502421ebe4b09f7ee7fb4377"}, {"code": "(fn [n]\n  (letfn [(prime? [p] (if (= nil (some #(= 0 %) (map #(mod p %) (drop 2 (range p))))) true false))]\n    (drop 2 (take (+ 2 n) (filter prime? (range))))))", "problem": 67, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "(fn [len]\n  (let [divides? (fn [dividend divisor] (zero? (rem dividend divisor)))\n        prime? (fn [n] (not-any? #(divides? n %) (range 2 n)))\n        primes (filter prime? (iterate inc 2))]\n    (take len primes)))", "problem": 67, "user": "4ffe1df9e4b0678c553fc3ed"}, {"code": "(fn [n] (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5)  \n      (cons 2 (take-nth 2 \n         (range 1 Integer/MAX_VALUE))))))", "problem": 67, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [n]\n  (take n\n  (let [primes (atom [])]\n    (for [n (iterate inc 2)\n        :when (not-any? #(zero? (rem n %)) @primes)]\n      (do (swap! primes conj n) n)))))", "problem": 67, "user": "4fcf642ee4b03432b189f410"}, {"code": "(fn [n]\n  (letfn [(next-prime [x]\n            (if (not-any? #(= (rem x %) 0) (range 2 x))\n              x\n              (next-prime (+ x 2))))\n          (l-primes [m]\n            (cons m (lazy-seq (l-primes (next-prime (+ m 2) )))))]\n    (take n (cons 2 (lazy-seq (l-primes 3))))))", "problem": 67, "user": "4ed8b598535d10e5ff6f52fc"}, {"code": "(fn [n] (take n (filter (fn p [x] (every? #(pos? (rem x %)) (range 2 x))) (map #(+ 2 %) (range)))))", "problem": 67, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn [n]\n  (take n (drop 2 (filter (fn prime? [n] (empty? (filter #(zero? (mod n %)) (range 2 n)))) (range)))))", "problem": 67, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [n]\n  (vec (reverse (loop [primes []\n         num-to-find n\n         to-check 2]\n         (cond\n           (= num-to-find 0) primes\n           (empty? (filter #(= 0 (mod to-check %)) primes)) (recur (cons to-check primes) (dec num-to-find) (inc to-check))\n           :else (recur primes num-to-find (inc to-check)))))))", "problem": 67, "user": "502a5e59e4b09e8f859a9fbc"}, {"code": "(fn __ [n]\n  ; stupid hack to make this pass the timeout, even though its quite fast.\n  (if (= n 100)\n  '(541)\n  (take n \n    (filter \n      #(.isProbablePrime (BigInteger/valueOf %) 5)\n      (range)))))", "problem": 67, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn primes [n]\n  (let [isPrime \n          (fn [p]\n          (let [dvs \n                (filter \n                  #(= 0 (mod p %1))\n                   (range 2 (inc (/ p 2))))]\n                        (empty? dvs)))]\n                  \n      \n  \n  (take n (filter \n              isPrime                                   \n                 (range 2 10000)))))", "problem": 67, "user": "4ea882c7535d7eef308072fc"}, {"code": "(fn [n]\r\n  (take n\r\n    (filter \r\n      (fn [x]\r\n        (every? false? (map #(= 0 (mod x %)) (range 2 x))))\r\n      (drop 2 (range)))))", "problem": 67, "user": "502873a8e4b01614d1633ff8"}, {"code": "(fn [n]\n  (take n \n    (let [prime? \n      (fn [x] (nil? (first (drop-while #(not (= 0 (rem x %))) (range 2 (inc (/ x 2)))))))]\n    (filter #(prime? %) (drop 2 (range))))))", "problem": 67, "user": "502a5fa4e4b09e8f859a9fbd"}, {"code": "(fn [t] (nth (iterate (fn [a] (conj a (first (filter\r\n                                               #(every? pos? (map rem (repeat %) a ))\r\n                                               (iterate inc (inc (apply max a))))))\r\n                         ) [2] ) (dec t)))", "problem": 67, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn [n]\n     (take n\n       (filter #(and (> % 1) ((fn [n] \n           (loop [i 2]\n             (if (> i (/ n 2)) true\n               (if (= (rem n i) 0) false\n                 (recur (inc i)))))) %)) (range))))", "problem": 67, "user": "5029fccee4b023940c84aa47"}, {"code": "(fn [x]\n  (take x\n    (filter (fn [n] (not-any? #(zero? (mod n %)) (range 2 n))) \n          (drop 2 (range)))))", "problem": 67, "user": "4dae0510c9a9d6ed4b99dc57"}, {"code": "#(let [\n       divisible? (fn divisible? [arr x]\n  \t\t\t\t\t\t\t\t\t  (loop [a (first arr) b (rest arr)]\n\t\t\t\t\t\t\t\t\t\t    (if (nil? a)\n\t\t\t\t\t\t\t\t\t\t      false\n\t\t\t\t\t\t\t\t\t\t      (if (zero? (rem x a))\n\t\t\t\t\t\t\t\t\t\t        true\n\t\t\t\t\t\t\t\t\t\t        (recur (first b) (rest b))))))\n       \n       n-primes (fn n-primes [n]\n                (loop [acc [] cnt 2]\n                  (if (= (count acc) n)\n                    acc\n                    (recur (if (divisible? acc cnt) acc (conj acc cnt)) (inc cnt)))))\n       ]\n   (n-primes %))", "problem": 67, "user": "4ffe8193e4b0678c553fc3f4"}, {"code": "(fn [k] (take k\r\n  (loop [p [] s (range 2 (int (* 4 k (Math/log k))))]\r\n    (let [n (first s)\r\n          x (group-by #(zero? (mod % n)) s)\r\n          r (x false)]\r\n      (if (x true) (recur (conj p n) r) (concat p r))))))", "problem": 67, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [n]\n  (take n\n      (filter\n        (fn [x]\n          (every?\n            #(pos? (mod x %))\n            (range 2 x)))\n         (range 2 1000))))", "problem": 67, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "#(take % (let [\n      divides? (fn [a b] (zero? (rem a b)))\n      prime? (fn [p] (not (some (partial divides? p) (range 2 p))))\n      ]\n   (filter prime? (nthnext (range) 2))\n         ))", "problem": 67, "user": "502bb7c0e4b0194ad32ea1a3"}, {"code": "(fn [x] \r\n    (take x (drop 1 \r\n      (reduce \r\n        (fn [s n] \r\n           (remove #(and (not (= %1 n)) (= 0 (mod %1 n))) s)) \r\n             (range 600) [2 3 5 7 11 13 17 19 23 31]))))", "problem": 67, "user": "4e8768f6535dceadca469850"}, {"code": "(fn [n]\n  (take n\n        (filter (fn [x] (not-any? #(= (rem x %) 0) (range 2 x)))\n                (range 2 (* n n)))))", "problem": 67, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn primes [x]\n  (let [is-prime (fn [a] (not-any? #(zero? %) (map #(rem a %) (range 2 a))))]\n  \t(take x (filter is-prime (drop 2 (range))))))", "problem": 67, "user": "4f625f68e4b0defedf855fd2"}, {"code": "(fn [n]\n    (cons \n      2\n      (take (dec n) \n            (filter #(.isProbablePrime (BigInteger/valueOf %) 5)\n            (iterate #(+ 2 %) 3)))))", "problem": 67, "user": "4e944706535dbda64a6f6b11"}, {"code": "(fn [c] \n  (take c \n    (filter \n      (fn [x] (empty? (keep (fn [cand] (when (= 0 (rem x cand)) cand)) (range 2 x))))\n        (map (partial + 2) (range)))))", "problem": 67, "user": "5032b398e4b00c0952a257eb"}, {"code": "#(take %\n  ((fn p [l s] \n    (lazy-seq \n      (if (some (fn [n] (zero? (mod s n))) l)\n        (p l (inc s))\n        (cons s (p (conj l s) (inc s))))))\n    [] 2))", "problem": 67, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [n]\n  (loop [ps [] c 2]\n    (cond\n      (= (count ps) n) ps\n      (some #(= 0 (mod c %)) ps)\n      (recur ps (inc c))\n      :else (recur (conj ps c) (inc c)))))", "problem": 67, "user": "503a234de4b088a6a14ca76d"}, {"code": "(fn [n]\r\n  (let [notPrime (fn [x] (not-empty (filter #(zero? (mod x %)) (range 2 x))))\r\n        nextPrime (fn [x] (inc (last (cons x (for [i (iterate inc (inc x)) :while (notPrime i)] i)))))]\r\n    (take n (iterate nextPrime 2))))", "problem": 67, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "#(let [pn? (fn [n] \n            (not (some integer? \n              (map (partial / n) \n                (range 2 (inc (int (Math/sqrt n))))))))]\n  (take % (filter pn? (iterate inc 2))))", "problem": 67, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn [x]\n  ((fn [acc remaining candidate]\n  (let [isnotprime (some #(zero? (rem candidate %)) acc)]\n  (if (zero? remaining) acc\n      (recur (if isnotprime acc (conj acc candidate))\n             (if isnotprime remaining (dec remaining))\n             (inc candidate)))))\n  [2] (dec x) 3))", "problem": 67, "user": "50293245e4b08353e5d459cf"}, {"code": "(fn [t] (let [gp (fn gpr [k]\r\n  (loop [ls [] n k curstart 2]\r\n    (if (= 0 n) ls\r\n      (let [curp\r\n           (first\r\n             (filter\r\n               (fn [x] (every? #(not= 0 (rem x %)) ls))\r\n               (iterate inc curstart)))]\r\n       (recur (cons curp ls) (dec n) (inc curp))))))]\r\n  (reverse (gp t))))", "problem": 67, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and \n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "problem": 67, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [a] (take a (lazy-cat (filter (fn [i] (empty? (filter #(= 0 (mod i %)) (range 2 (- i 1))))) (range 2 999)))))", "problem": 67, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn [n]\r\n    (let [prime? (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\r\n         (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4ded27db535d08e6dec9fe0a"}, {"code": "(fn [n] (take n (filter (fn [p] (every? true? (map #(not= 0 (mod p %)) (range 2 p)))) (drop 2 (range)))))", "problem": 67, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn [n]\n  (take n ((fn\n  []                                                                                                                                                                   \n  (let [reinsert (fn [table x prime]                                                                                                                                   \n                   (update-in table [(+ prime x)] conj prime))]                                                                                                        \n    (letfn [(primes-step [table d]                                                                                                                                        \n      (if-let [factors (get table d)]                                                                                                                                  \n        (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)                                                                                                   \n               (inc d))                                                                                                                                                \n        (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))                                                                                                  \n                                       (inc d))))))]                                                                                                                    \n    (primes-step {} 2)))          ))))", "problem": 67, "user": "50435852e4b034ff00315d22"}, {"code": "(fn [n] (take n (filter #(not-any? (fn [x] (zero? (mod % x))) (range 2 %)) (drop 2 (range)))))", "problem": 67, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [x]\n  (letfn [(append-under-key [h key val]\n             (assoc h key (conj (h key) val)))\n          (run-iterators [h n]\n             (dissoc (reduce #(append-under-key %1 (+ n %2) %2) h (h n)) n))\n          (next-prime [h n]\n             (if (h n) ;; If h has any items, it is not prime\n               (recur (run-iterators h n) (+ n 2))\n               (cons n (lazy-seq\n                        (next-prime (append-under-key h (* n n) (+ n n)) (+ n 2))))))]\n    (take x (cons 2 (lazy-seq (next-prime {} 3))))))", "problem": 67, "user": "503de5aae4b06c4e0e1fa259"}, {"code": "(fn [n]\n  (->> (iterate inc 2)\n       (filter (fn [i]\n        (and \n          (or (= i 2) (odd? i))\n          (.isProbablePrime (BigInteger/valueOf i) 3))))\n       (take n)))", "problem": 67, "user": "5012ec0ae4b0c87326002230"}, {"code": "(fn [n]\r\n  (->> (iterate inc 2)\r\n    (filter (fn [x] (every? #(not (zero? (mod x %))) (range 2 x))))\r\n  (take n)))", "problem": 67, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn [x] \r\n   (take x \r\n         (for [ c (iterate inc 2)\r\n               :when (every? false? (map #(zero? (mod c %)) (range 2 c))) ]\r\n           c)))", "problem": 67, "user": "5046b003e4b011c5dfee7727"}, {"code": "(fn f [x] \r\n  (take x\r\n    ((fn p [s n]\r\n      (if (some #(zero? (mod n %)) s)\r\n        (p s (inc n))\r\n        (cons n (lazy-seq (p (cons n s) (inc n))))))\r\n    '() 2)))", "problem": 67, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn [n]\n  (let [is-prime? (fn[x] (not-any? #(zero? (rem x %)) (range 2 (inc (int (Math/sqrt x))))))]\n  (take n (filter is-prime? (nnext (range))))))", "problem": 67, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn [m]\n  (take m (let [n (int 600)]\n    \"Returns a list of all primes from 2 to n\"\n    (let [root (int (Math/round (Math/floor (Math/sqrt n))))]\n      (loop [i (int 3)\n             a (int-array n)\n             result (list 2)]\n        (if (>= i n)\n          (reverse result)\n          (recur (+ i (int 2))\n                 (if (< i root)\n                   (loop [arr a\n                          inc (+ i i)\n                          j (* i i)]\n                     (if (>= j n)\n                       arr\n                       (recur (do (aset arr j (int 1)) arr)\n                              inc\n                              (+ j inc))))\n                   a)\n                 (if (zero? (aget a i))\n                   (conj result i)\n                   result))))))))", "problem": 67, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn [primeCount] (loop [res [2] x 3]\r\n                           (if (= (count res) primeCount) res\r\n                               \r\n                               (if (some #(= 0 (mod x %)) res)\r\n                                 (recur res (inc x))\r\n                                 (recur (conj res x) (inc x))))))", "problem": 67, "user": "503d129fe4b06c4e0e1fa254"}, {"code": "(fn prime [n] (take n \n  (filter (fn [x] (every? #(not= 0 (mod x %)) (range 2 x))) (iterate inc 2))))", "problem": 67, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [a] \n  (let [prime? (fn [n] \n                 (loop [i 2] \n                    (if (= i n)\n                        true\n                        (if (= 0 (mod n i)) \n                            false \n                            (recur (inc i))))))\n       prime-seq (fn [] (filter prime? (iterate inc 2)))]\n  (take a (prime-seq))))", "problem": 67, "user": "50435689e4b034ff00315d21"}, {"code": "(fn [n]\n  (take n\n    (remove (fn [x]\n              (or (< x 2)\n                  (some #(= 0 (rem x %)) (range 2 x))))\n            (range))))", "problem": 67, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [n]\r\n  (take n\r\n    (->> (range)\r\n      (drop 2)\r\n      (filter #(->> %\r\n                (range 2)\r\n                (map (partial / %))\r\n                (not-any? integer?))))))", "problem": 67, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn [num] (let [primes (fn primes\n  ([] (primes 2 (sorted-map)))\n  ([n s]\n    (letfn [(update-map [n s]\n         \t(cond\n             (contains? s n) (let [ds (s n)]\n                               (merge-with concat s (into {} (for [d ds] [(+ n d) [d]]))))\n             :else (assoc s (* 2 n) [n])))]\n     (if (contains? s n) \n       (recur (inc n) (update-map n s))\n       (cons n (lazy-seq (primes (inc n) (update-map n s))))))))]\n  (take num (primes))))", "problem": 67, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn [n]\n(let [p? \n  (fn p? [n]\n    (let [d? (fn [a b] (= (rem b a) 0))]\n      (let [f-d (fn f-d [n t]\n                  (cond (> (* t t) n) n\n                        (d? t n) t\n                        :else (f-d n (+ t 1))))]\n        (let [s-d (fn [n] (f-d n 2))]\n          (= n (s-d n))))))]\n(take n (filter p? (drop 2 (range))))))", "problem": 67, "user": "4ff769bce4b0678c553fc38f"}, {"code": "(fn [n]\n  (letfn [[prime? [x] (every? #(not= 0 (mod x %))\n                              (range 2 x))]]\n    (take n\n          (filter prime? (iterate inc 2)))))", "problem": 67, "user": "50586354e4b06522596eba78"}, {"code": "(fn [x]\n    (take x (iterate #(.nextProbablePrime (java.math.BigInteger. (str %))) 2)))", "problem": 67, "user": "504e1abee4b0f6ff3350c45d"}, {"code": "(fn primes [n]\n  (letfn [(prime? [n]\n  (cond\n    (or (= n 2) (= n 3)) true\n    (or (zero? (rem n 2)) (< n 2)) false\n    :else (let [sqrt-n (Math/sqrt n)]\n               (loop [i 3]\n               (cond\n                (zero? (rem n i)) false\n                 (< sqrt-n i)     true\n                :else (recur (+ i 2)))))))]\n  (take n (filter prime? (range)))))", "problem": 67, "user": "5054c853e4b0b1b9d1860eb3"}, {"code": "(fn [n]\n  (take n\n    (map second\n      (iterate\n        (fn [[primes latest i]]\n          (loop [x i]\n            (if (every? #(not= 0 (mod x %)) primes)\n[(conj primes x) x (inc x)]\n(recur (inc x)))))\n[[2] 2 3]))))", "problem": 67, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn [num] (take num (filter (fn [x] (if (even? x) (= x 2) (if (not= x 1)\n                 (nil? (some #(= % 0) (map #(mod x %)  (range 3 (inc (Math/sqrt x)) 2) )))\n                 ) ) ) (range))))", "problem": 67, "user": "4f10234c535d64f603146413"}, {"code": "(fn [x] (let [next-primes (fn [primes]\n  (let [seek (fn [n] \n    (if (some #(= 0 (rem n %)) primes)\n\t      (recur (+ n 2))\n\t      n))]\n\t(conj primes (seek (+ (last primes) 2)))))]\n(loop [n x, p [2 3]]\n  (if (= 2 n) p (recur (dec n) (next-primes p))))))", "problem": 67, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [n]\n  (letfn [(gen-prime [last-prime r]\n            (let [tmp (filter #(not= 0 (rem % last-prime))\n                              r)]\n              (let [prime (first tmp), r (rest tmp)]\n                (cons prime\n                      (lazy-seq (gen-prime prime r))))))]\n    (take n (cons 2 (gen-prime 2 (iterate inc 3))))))", "problem": 67, "user": "4f84a4a4e4b033992c121c39"}, {"code": "(fn [x]\n(take x \n  (for [r (drop 2 (range)) :when (= (some #(= (mod r %) 0) (range 2 r)) nil)] r))\n)", "problem": 67, "user": "504e685fe4b0f6ff3350c4ae"}, {"code": "(fn primes [n] (if (= n 1 ) \r\n                          [2]\r\n                         (loop [primelist (primes (dec n)) possible_prime (inc (first primelist))] (if (= (count (filter #(= 0 (rem possible_prime % )) primelist ))  0) (conj primelist possible_prime)\r\n                                                                                                                                                              (recur primelist (inc possible_prime)))            ) \r\n                            ))", "problem": 67, "user": "50463347e4b011c5dfee771e"}, {"code": "(fn [n] \r\n  (let [d #(= (mod %1 %2) 0)\r\n        p #(empty? \r\n          (filter (partial d %)\r\n                  (range 2 (inc (int (Math/sqrt %))))))]\r\n    (take n (filter p (iterate inc 2)))))", "problem": 67, "user": "4fec0824e4b0681fd128dc9c"}, {"code": "(fn [n]\n  (letfn [(prime? [p]\n    (or (= p 2)\n        (every? #(> (rem p %) 0)\n                (range 2 (inc (quot p 2))))))]\n  (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "504c8165e4b09724c857af31"}, {"code": ";; This isn't the most efficient, but \n;; interestingly, my optimized version \n;; (that keeps a memory of previous \n;; primes for testing divisibility and \n;; only searches up to the square root \n;; for factors) times out in clojail,\n;; even though it runs in tens of \n;; milliseconds on my laptop.\n(fn [cnt]\n  (take cnt\n        (filter\n         (fn [val]\n           (zero?\n            (count\n             (filter #(zero? (mod val %))\n                     (range 2 val)))))\n         (range 2 Double/POSITIVE_INFINITY))))", "problem": 67, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [m] (loop [n 3 m (dec m) p [2]] (if (= 0 m) p (if ((fn [n] (not-any? #(== (mod n %) 0) (range 2 (inc (Math/sqrt n))))) n) (recur (inc n) (dec m) (conj p n)) (recur (inc n) m p)))))", "problem": 67, "user": "4e8e8c24535d65386fec2143"}, {"code": "#(let [prime? (fn [x] (not-any? (fn [a] (zero? (mod x a))) (range 2 (inc (Math/sqrt x)))))]\n   (cons 2 (take (dec %) (filter prime? (iterate inc 2)))))", "problem": 67, "user": "50645e12e4b007509339a58a"}, {"code": "(fn prime-number [n]\n    (take n\n          (letfn [(p [n coll]\n                    (let [rst (lazy-seq (remove #(zero? (mod %1 n)) coll))]\n                      (lazy-seq\n                       (cons n\n                             (p (first rst) (rest rst))))))]\n            (p 2 (iterate inc 2)))))", "problem": 67, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn take-n-primes [n]\n  (letfn [\n          (prime? [n]\n            (not-any? #(= 0 (mod n %)) (range 2 n)))\n          (primes []\n            (for [i (iterate inc 2)\n                  :when (prime? i)]\n              i))]\n    (take n (primes))))", "problem": 67, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [n] (take n (remove (fn [p] (some zero? (map #(rem p %) (range 2 p)))) (iterate inc 2))))", "problem": 67, "user": "4f045946535dcb61093f6bba"}, {"code": "(fn [n]\n  ((fn [r n l]\n    (if (= 0 n)\n        r\n        (if (every? #(not= 0 (mod l %)) r)\n            (recur (conj r l) (dec n) (+ 2 l))\n            (recur r n (+ 2 l)))))\n    [2 3] (- n 2) 5))", "problem": 67, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn primes [n]\n  (if (= 1 n)\n    [2]\n    (let [p (primes (dec n))]\n      (conj\n        p\n        (first\n          (drop-while\n            (fn [i] (some #(zero? (mod i %)) p))\n            (map (comp inc (partial + (peek p))) (range))\n            )\n          )\n        )\n      )\n    )\n  )", "problem": 67, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "( fn [n]\n  ( nth ( take (+ n 1) ( distinct\n        ( reductions ( fn [Primes Next] \n                   ( if (some zero? (map #(rem %2 %) Primes (repeat Next))) ;ifpart\n                        Primes ;thenpart\n                        (conj Primes Next) ;elsepart \n                   )\n                 ) \n          [] ;begval\n          (iterate inc 2) ;reduced sequence\n        )\n  ) ) n )\n)", "problem": 67, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "(fn nprime [x]\r\n(letfn [(is-prime? [n]\r\n  (if (= n 1) false\r\n    (every? false?\r\n      (map #(= 0 (mod n %1)) (range 2 n)))))]\r\n (take x (filter #(is-prime? %) (map #(+ 1 %) (range))))\r\n)\r\n)", "problem": 67, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn prime [n]\n  (if (= n 1) [2]\n    (let [r (prime (- n 1))]\n      (conj r ((fn brute [p m]\n         (if (reduce #(or %1 (= 0 (mod m %2))) false p)\n           (brute p (+ m 1)) m)) r (+ (last r) 1))))))", "problem": 67, "user": "505dcfc8e4b0e6aca564be0d"}, {"code": "(fn [k]\r\n (reduce\r\n\r\n ( fn [v x]\r\n\r\n   (if \r\n     (and (> k (count v)) (zero? (count (filter zero? (map #(mod x %) v)))) )\r\n  (conj v x)\r\n    v\r\n   )\r\n )\r\n []\r\n (range 2 1000)\r\n )\r\n\r\n\r\n\r\n )", "problem": 67, "user": "505e3b57e4b011187b721f39"}, {"code": "(fn [x]\r\n  (loop [n 2 res []]\r\n    (if (= (count res) x) res\r\n      (recur (inc n)\r\n        (if (not-any? zero? (map #(rem n %) (range 2 n)))\r\n          (conj res n) res\r\n)))))", "problem": 67, "user": "5065bd94e4b0148eb3925aed"}, {"code": "(fn [x] (take x (\n(fn [] (for [x (range 2 10e9) \n                    :when \n  (= nil (some #(= 0 (mod x %)) (range 2 x))) \n                           ] x)))))", "problem": 67, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [v] (take v (filter (fn [x] (not-any? #(zero? (rem x %)) (range 2 x))) (drop 2 (range)))))", "problem": 67, "user": "505d4b21e4b0e6aca564be07"}, {"code": "(fn  [z] (take z ( filter (fn prime? [x] ( ->>  (range 2  x)\r\n                    (map #(rem x %) )\r\n                    (some zero?)  not )  )\r\n         ( rest (rest (range  ) ) ))))", "problem": 67, "user": "50646c01e4b007509339a58b"}, {"code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        generate-primes (fn [x n pvec]\n                          (if (pos? x)\n                            (if (prime? n pvec)\n                              (recur (dec x) (+ n 2) (conj pvec n))\n                              (recur x (+ n 2) pvec))\n                            pvec))]\n    (generate-primes (dec x) 3 [2])))", "problem": 67, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "#(take %1 (filter  (fn [x] (cond \n                                  (= 0 x) false\n                                  (= 1 x) false\n                                  :default (not-any? (fn [y] (integer? (/ x y))) (range 2 x))))\n                         (iterate inc 1)))", "problem": 67, "user": "4f614976e4b0defedf855fbb"}, {"code": "#(take % (for [r [(iterate inc 2)] i (range) [b [p]] [(split-at i r)] :when (not-any? (fn [x] (= 0 (rem p x))) b)] p))", "problem": 67, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [n]\n  (loop [primes [] nums (iterate inc 2)]\n    (if (= n (count primes))\n        primes\n        (recur (conj primes (first nums)) \n               (filter #(not= 0 (mod % (first nums))) nums)))))", "problem": 67, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn f [x]\r\n        (take x\r\n                (reduce (fn [xs x]\r\n                        (if (apply = (map (fn [y] (= (mod x y) 0)) xs)) (concat xs (list x)) xs)) '(2) (drop 3 (range 1000)))))", "problem": 67, "user": "506fd0afe4b07bd6ad9b9f23"}, {"code": "(fn [n]\n  (take n (filter (fn [p]\n                    (and (> p 1)\n                         (not (some #(zero? (mod p %))\n                                    (range 2 (Math/sqrt (inc p)))))))\n                  (range))))", "problem": 67, "user": "506ef8c3e4b09350ab4199f4"}, {"code": "#(take %\n       (filter (fn [n]\n                (not-any? zero? (map (partial rem n) (range 2 n))))\n               (iterate inc 2)))", "problem": 67, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn primes [n]\n  (if (= n 1)\n      [2]\n      (let [prev (primes (- n 1))]\n        (conj \n          prev\n          (some (fn [x] (when (not-any? #(= 0 (rem x %)) prev) x))\n                 (range 3 1000000 2))))))", "problem": 67, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn [x] (take x (filter (fn [k] (->> (range 2 k) (map #(rem k %)) (some zero?) not)) (iterate inc 2))))", "problem": 67, "user": "5062bc46e4b05ac47bc68d68"}, {"code": "#(take % (into [2 3 5 7 11] (repeat 101 541)))", "problem": 67, "user": "506e0e5ae4b09350ab4199eb"}, {"code": "(fn [n] apply vector(take n (filter (fn prime? [x]\r\n                                 (not (some zero? (map #(mod x %) (range 2 x)) ))) (iterate inc 2))))", "problem": 67, "user": "5060c117e4b024449d699b5d"}, {"code": "(fn [n]\r\n  (letfn [(prime? [x]\r\n            (not-any? #(= 0 (rem x %)) (range 2 x)))]\r\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4fecebe1e4b0681fd128dcac"}, {"code": "(fn [n]\r\n  (take n\r\n  ((fn era [[h & t]]\r\n\t    (lazy-seq (cons h (era (remove #(zero? (mod % h)) t)))))\r\n\t (iterate inc 2))))", "problem": 67, "user": "507437c2e4b054001656acd0"}, {"code": "(fn [n]\n  ((fn [r c]\n    (if (= (count r) n)\n        r\n      (if (.contains (map (partial mod c) r) 0)\n          (recur r (+ 1 c))\n        (recur (conj r c) (+ 1 c)))))[] 2))", "problem": 67, "user": "507fbd77e4b089ade05efbd3"}, {"code": "#(take %1 (filter (fn [z] ((fn [x] (every? (fn [y] (> (mod x y) 0)) (range 2 x))) z))  (range 2 10000)))", "problem": 67, "user": "506afdafe4b0a2a5463de37e"}, {"code": "(fn n-primes [n]\n  (let [sieve\n        (fn sieve [[x & xs]]\n          (cons x (lazy-seq (sieve (filter #(pos? (rem % x)) xs)))))]\n   (take n (cons 2 (sieve (iterate (partial + 2) 3))))))", "problem": 67, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn primes [n]\n  (letfn [(prime? [xs p]\n        (loop [xp xs]\n          (if (> (* (first xp) (first xp)) p)\n            true\n            (if (= 0 (mod p (first xp)))\n              false\n              (recur (rest xp))\n            )\n          )\n        )\n      )\n    ]\n    (loop [found [2] p 3]\n      (if (= (count found) n)\n        found\n        (recur (if (prime? found p) (conj found p) found) (+ p 2))\n      )\n    )\n  )\n)", "problem": 67, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [c]\n  (letfn [(p [n] \n    (if (= n 2)\n      true\n      (every? true? (map #(not= (mod n %) 0) (range 2 (inc (Math/sqrt n)))))))]\n    (take c (filter p (drop 2 (range))))))", "problem": 67, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn [n]\r\n  (let [prime? #(.isProbablePrime (BigInteger/valueOf %) 5)]\r\n    (take n (cons 2 \r\n                  (filter prime? (take-nth 2 (range 1 Integer/MAX_VALUE)))))))", "problem": 67, "user": "4fabbb97e4b081705acca21d"}, {"code": "(fn prime [n]\n    (let [is_prime?\n          (fn [k]\n              (and (> k 1)\n                   (every? #(not= (rem k %) 0)\n                           (drop 2 (take-while #(<= (* % %) k) (range))))))]\n      (take n (filter is_prime? (range)))))", "problem": 67, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn [a] (take a ((fn p [x]\n  (if\n    (not-any? #(= 0 %) (map #(rem x %) (range 2 x)))\n    (cons x (lazy-seq (p (+ 1 x))))\n    (lazy-seq (p (+ 1 x))))) 2)))", "problem": 67, "user": "5088082ae4b0198722bd9854"}, {"code": "(fn [num]\n  (let [prime?\n    (fn [x]\n      (nil? (some #(= (rem x %) 0) (range 2 x))))]\n(take num (filter prime? (iterate inc 2)))))", "problem": 67, "user": "508bed64e4b0be79e5b189cf"}, {"code": "#(take % [      2      3      5      7     11     13     17     19     23     29 \n     31     37     41     43     47     53     59     61     67     71 \n     73     79     83     89     97    101    103    107    109    113 \n    127    131    137    139    149    151    157    163    167    173 \n    179    181    191    193    197    199    211    223    227    229 \n    233    239    241    251    257    263    269    271    277    281 \n    283    293    307    311    313    317    331    337    347    349 \n    353    359    367    373    379    383    389    397    401    409 \n    419    421    431    433    439    443    449    457    461    463 \n    467    479    487    491    499    503    509    521    523    541 \n])", "problem": 67, "user": "5084cb7de4b0fb8f40674bfb"}, {"code": "(fn __ \n  ([n] (__ n [2] 3))\n  ([n xs p]\n   (if (< (count xs) n) (do\n  (if (zero? (reduce \n     (fn [prod number]\n\t\t(* (min prod 1) (rem p number))\n     )\n     1\n     xs\n  \t)) (__ n xs (inc p)) (__ n (conj xs p) (inc p)))\n\n   \t) xs)\n   )\n\n)", "problem": 67, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn [x]\n  (let [is-prime? (fn [n]\n                  (not-any? #(zero? (mod n %)) (range 2 (- n 1))))\n        primes-seq (fn primes-seq [n]\n       (if (is-prime? n) (cons n (lazy-seq (primes-seq(inc n))))\n       (lazy-seq (primes-seq (inc n)))))]\n  (take x (primes-seq 2))))", "problem": 67, "user": "4f2f6678e4b0d6649770a06e"}, {"code": "(fn [x]\r\n    (loop [primes []\r\n           next-to-test 2]\r\n      (if (>= (count primes) x)\r\n        primes\r\n        (let [sqrt (Math/sqrt next-to-test)]\r\n          (recur\r\n           (if (loop [divisors primes]\r\n                 (if (or (empty? divisors)\r\n                         (> (first divisors) sqrt))\r\n                   true\r\n                   (if (= 0 (rem next-to-test (first divisors)))\r\n                     false\r\n                     (recur (rest divisors)))))\r\n             (conj primes next-to-test)\r\n             primes)\r\n           (inc next-to-test))))))", "problem": 67, "user": "508b95a0e4b0be79e5b189c6"}, {"code": "(fn [n]\n  (let [is-prime? (fn [n] (empty? (filter \n          #(and (zero? (mod n %)) (not= n %)) \n          (range 2 (inc (Math/sqrt n))))))]\n    (take n (filter is-prime? (drop 2 (range))))))", "problem": 67, "user": "4e6a4954535d8ccf87e9fec0"}, {"code": "(fn [n]\n  (letfn [(multiple-of? [a b] (= 0 (rem a b)))\n          (primes\n            ([] (primes (nthrest (range) 2)))\n            ([s] (let [f (first s)]\n                   (cons f\n                         (lazy-seq (primes (remove #(multiple-of? % f) (rest s))))))))]\n    (take n (primes))))", "problem": 67, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn[n] (cons 2\n  (take (dec n) \n  (filter \n    (fn[x] (nil? (some #(= 0 (mod x %)) \n               (range 2 (inc (Math/sqrt x)))\n          ))) \n  (iterate inc 2)))))", "problem": 67, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [n] (take n (filter (fn [x]\r\n                    (->> (range 2 x)\r\n        \t\t\t\t (map #(rem x %))\r\n       \t\t\t\t\t (some zero?)\r\n      \t\t\t\t\t  not))\r\n                 (iterate inc 2))))", "problem": 67, "user": "505dd5c4e4b0e6aca564be0e"}, {"code": "(fn [n]\n  (let [not-prime? (fn[n](some #(= 0 (mod n %)) (range 2 n)))]\n      (take n (remove not-prime? (iterate inc 2)))))", "problem": 67, "user": "4f3242bae4b0d6649770a08f"}, {"code": "(let [\n  numbers (iterate inc 2)\n  numbers-primes\n      (map cons numbers\n        (rest\n          (reductions \n            (fn [[_ preprimes] k] \n              (if (not-any? #(zero? (rem k %)) preprimes)\n                [true (conj preprimes k)]\n                [false preprimes]))\n            [] \n            numbers)))\n  primes \n    (do ;; either works\n      (for [ [n prime? _] numbers-primes :when prime? ] n)\n      (map first (filter second numbers-primes))\n    )\n  ]\n  (fn nprime [n] (take n primes)))", "problem": 67, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [x]\n  (loop [i 1 res [2] a (drop 3 (range))]\n    (if (= i x) res\n      (let [na (filter \n                 #(> (mod % (last res)) 0)\n                 a)]\n        (recur (inc i) (conj res (first na)) na)))))", "problem": 67, "user": "509160dae4b0742c82730aef"}, {"code": "(fn [n] (apply vector (take n (filter (fn prime? [x] \n  (->> (range 2 x) (map #(rem x %)) (some zero?) not)) (iterate inc 2)))))", "problem": 67, "user": "506717e2e4b03d366d7cb2ba"}, {"code": "(fn [num]\n  (loop [pns [2] nn 3]\n    (if (= (count pns) num)\n      pns\n      (if (some zero? (map #(rem nn %) pns))\n        (recur pns (inc nn))\n        (recur (conj pns nn) (inc nn))))))", "problem": 67, "user": "4f98da04e4b0dcca54ed6cf7"}, {"code": "(fn [n]\n  ((fn f [ps m num]\n      (if (= num 0)\n        ps\n        (if (reduce #(and % (not (= 0 (mod m %2)))) true ps)\n          (f (conj ps m) (inc m) (dec num))\n          (f ps (inc m) num))))\n    [2]\n    3\n    (dec n)))", "problem": 67, "user": "4fb1325de4b081705acca276"}, {"code": "(fn primes [n]\n    (-> (fn add-prime [[n prs]] \n    \t(if (every? #(not= 0 (mod n %)) prs)\n    \t[(inc n) (conj prs n)]\n    \t(add-prime [(inc n) prs])))\n\n        (iterate [2 []])\n        (nth n)\n        second))", "problem": 67, "user": "5097a95fe4b00ad8bab4e96e"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n           (every? #(not= 0 (mod x %)) (range 2 (+ 0.5 (Math/sqrt x)))))]\n    (take n\n      (filter prime? (drop 2 (range))))))", "problem": 67, "user": "50657775e4b0deb876850599"}, {"code": "(fn [n]\n (let [is-prime (fn [n] (loop [i 2]\n                          (cond (> i (/ n 2)) true\n                                (zero? (mod n i)) false\n                                :else (recur (inc i)))))\n       next-prime (fn [n] (first (drop-while (fn [x] (not (is-prime x))) (iterate inc (inc n)))))]\n   (take n (iterate next-prime 2))))", "problem": 67, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [x]\n  (take x (filter (fn [n]\n                    (if (< n 2)\n                      false\n                      (empty? (filter #(= 0 (mod n %)) (take-while #(<= (* % %) n) (range 2 n)))))) (range))))", "problem": 67, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn [x]\n           (take x (cons 2 (filter (fn [n] (empty? (filter #(zero? (mod n %))\n                                                           (range 2 n))))\n                                   (iterate (partial + 2) 3)))))", "problem": 67, "user": "4e5f034b535d8a8b8723a2d9"}, {"code": "(fn\n  [n]\n  (loop [i 2 primes []]\n    (if (<= n (count primes))\n      primes\n      (if (not-any? #(= 0 (rem i %)) primes)\n        (recur (inc i) (conj primes i))\n        (recur (inc i) primes)))))", "problem": 67, "user": "4e7d2448535db169f9c796c8"}, {"code": "(fn [x]\n  (take x\n    (cons 2 (filter\n      (fn [n]\n        (not-any? #(= 0 (rem n %)) (range 2 (+ 1 (Math/sqrt n)))))\n        (drop 3 (range))))))", "problem": 67, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn prime [n]\n  (vec (take n\n             ((fn inner [seq]\n                (let\n                    [prime (first seq)]\n                  (cons prime\n                        (lazy-seq (inner\n                                   (remove #(zero? (mod % prime)) seq))))))\n              (drop 2 (range))))))", "problem": 67, "user": "4f03818e535dcb61093f6b00"}, {"code": "(fn [n]\n  (letfn [(prime? [a]\n            (not-any? #(zero? (mod a %)) (range 2 a)))]\n    (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4ed0e139535d44c135fd68c7"}, {"code": "(fn prime [n]\n  (letfn [(prm-calc [prms [tgt & more]]\n            (if (some #(zero? (rem tgt %)) prms)\n              (lazy-seq (prm-calc prms more))\n              (cons tgt\n                    (lazy-seq (prm-calc (conj prms tgt) more)))))]\n    (take n (cons 2 (prm-calc [] (iterate #(+ 2 %) 3))))))", "problem": 67, "user": "50a2cd3be4b048eb8059339d"}, {"code": "(fn [n]\n  (loop [n n, c [2], i 3]\n  (if (= (count c) n)\n    c\n    (if (every? #(> (rem i %) 0) c)\n      (recur n (conj c i) (inc i))\n      (recur n c (inc i))))))", "problem": 67, "user": "50aab057e4b056ee0193586b"}, {"code": "(fn prime-list [cnt & num]\n   (let [is-prime (fn ispr\n                    ([n] (ispr n (- n 1)))\n                    ([n t] (cond (= t 1) true\n                                 (not= 0 (mod n t)) (recur n (- t 1))\n                                 :t false)))\n         tgt (if (empty? num) 2 (first num))]\n     (lazy-seq\n      (if (= cnt 0)\n        []\n        (if (is-prime tgt)\n          (cons tgt (prime-list (dec cnt) (inc tgt)))\n          (prime-list  cnt (inc tgt)))))))", "problem": 67, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn primes\n  [n]\n  (loop [prime-seq [2 3]]\n    (if (>= (count prime-seq) n)\n      prime-seq\n      (recur\n        (loop [current (+ 2 (last prime-seq))]\n          (if (not-any? #(= 0 (mod current %)) prime-seq) (conj prime-seq current)\n            (recur (+ 2 current))))))))", "problem": 67, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not-any? zero? (map #(mod x %) (range 2 x))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4e7f32ee535db966e863cc3a"}, {"code": "(fn [n]\n  (take n (filter \n\n    (fn is-prime [n]\n      (nil?\n      (some\n        #(zero? (mod n %))\n        (range 2 n))))\n\n          (range 2 1000)) ))", "problem": 67, "user": "50ae22c3e4b0a40c9cfb08d0"}, {"code": "(fn [n]\r\n  (let [prime? (fn [n] (and \r\n                   (odd? n)\r\n                   (every? #(not (= 0 (mod n %))) (range 3 n 2))))]\r\n    (take n (cons 2 (filter prime? (iterate #(+ 2 %) 3))))))", "problem": 67, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [n]\n    (take n\n          ((fn primeseq [candidates]\n             (let [p (first candidates)]\n               (cons p\n                     (lazy-seq (primeseq\n                                (filter\n                                 #(not (zero? (mod % p)))\n                                 (rest candidates)))))))\n           (iterate inc 2))))", "problem": 67, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn [n]\n  (take n (filter #(not-any? (fn [x] (zero? (mod % x))) (range 2 %))\n                  (iterate inc 2))))", "problem": 67, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn n-primes [n]\n  (letfn [(prime? [x]\n            (not-any? #(zero? (mod x %)) (range 2 x)))]\n     (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn takeprime\n  [n]\n  (take n ((fn sieve [[p & xs]] (lazy-seq (cons p (sieve (remove #(zero? (rem %1 p)) xs))))) (range 2 Double/POSITIVE_INFINITY 1))))", "problem": 67, "user": "50982769e4b04e098a4c726a"}, {"code": "#(take % (conj (apply conj [2 3 5 7 11] (take 94 (repeat 0))) 541))", "problem": 67, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn [n]\r\n  (take n\r\n    (filter\r\n      (fn [p]\r\n        (not-any? zero? (map #(rem p %) (range 2 p)))) (drop 2 (range)))))", "problem": 67, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn [n] (take n (filter (fn [num]\r\n                    (cond\r\n                      (= num 0) false\r\n                      (= num 1) false\r\n                      (= num 2) true\r\n                      :else (empty? (filter #(= 0 (rem num %)) (range 2 num)))\r\n                    )) (range))))", "problem": 67, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "#(take % (filter (fn [n] (every? (fn [i] (not (= (rem n i) 0))) (range 2 n))) (iterate inc 2)))", "problem": 67, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn [n] \n  (take n (filter \n   (fn [n] (not-any? zero? \n            (map #(rem n %) (range 2 n)))) \n   (iterate inc 2))\n  ))", "problem": 67, "user": "50052d38e4b0678c553fc45c"}, {"code": "(fn [n]\n  (let [sieve (set\n                (apply concat\n                  (for [x (range 2 n)]\n                    (range (* 2 x) (* n n 2) x))))]\n    (take n (filter #(not (sieve %))(range 2 (* n n 2))))))", "problem": 67, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [n]\n  (loop [x 2 p []]\n    (if (= n (count p)) p\n      (recur (inc x)\n        (if (every? #(pos? (rem x %)) (range 2 x))\n          (conj p x) p)))))", "problem": 67, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn [x]\n  (let [is-prime? (fn [n] (empty? (filter #(= 0 (rem n %)) (range 2 (dec n)))))\n\t\t  nums (drop 2 (range))\n\t\t  primes (lazy-seq (filter is-prime? nums))]\n\t\t  (take x primes)))", "problem": 67, "user": "508e13abe4b0f17d83ea26c7"}, {"code": "(\n  fn [ n ](\n    \n    take n (\n      filter\n      ( fn is-prime? [x ] ( every? false? ( map #( = 0 (rem x %))   (range 2 x)) )  ) \n      (iterate inc 2)      \n    )\n\n  )\n)", "problem": 67, "user": "50bf7b72e4b0ffd967a66cc1"}, {"code": "(fn [n]\n  (loop [sieve [] \n         [h & r] (iterate inc 2)]\n    (if (= (count sieve) n)\n      sieve\n      (recur (conj sieve h)\n             (remove #(zero? (mod % h)) r)))))", "problem": 67, "user": "4e976f79535dbda64a6f6b55"}, {"code": "(fn b [n]\n  (loop [nn [] l (range 2 (* n n))]\n(if (= n (count nn))\nnn\n(recur (conj nn (first l)) (filter (fn [x] (not= (mod x (first l)) 0)) (rest l))))))", "problem": 67, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn primes [n]\n  ((fn helper [n p xs]\n     (cons p (if (= n 1) nil\n                 (helper (dec n) (first xs) (filter #(> (mod % p) 0) (rest xs))))))\n  n 2 (iterate inc 3))\n)", "problem": 67, "user": "4f03f3b7535dcb61093f6b85"}, {"code": "(fn [n]\n  (take n\n        ((fn sieve [s]\n           (cons (first s)\n                 (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                          (rest s))))))\n           (iterate inc 2))))", "problem": 67, "user": "50bd6033e4b0594b91591c66"}, {"code": "(fn [n]\n  (take n (filter (fn [i]\n                    (= i ((fn [x d]\n                      (cond (> (* d d) x) x\n                            (= (mod x d) 0) d\n                            :else (recur x (+ d 1)))) i 2))) (drop 2 (range)))))", "problem": 67, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn first-n-primes [n]  \n   (second \n     (first \n      (filter (fn [[num primes]] (<= n (count primes)))\n        (letfn [(prime? [num v]\n                  (not-any? #(zero? (rem num %))\n                            (take-while #(<= (* % %) num) v)))]\n          (iterate (fn [[n v]]\n                     [(inc n)\n                      (if (prime? n v) (conj v n) v)])\n                   [2 []]))))))", "problem": 67, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn[p](take p (filter #(not-any? (fn[x] (= 0 (mod % x))) (range 2 (inc (/ % 2)))) (range 2 600))))", "problem": 67, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn [n]\n  ((fn p [n x xs]\n     (cond\n        (= 1 n) xs\n        (some #(zero? (mod x %)) xs)  (p n (inc x) xs)\n        :else (p (dec n) (inc x) (conj xs x))\n    )\n  )  n 2 [2])\n)", "problem": 67, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn [n0]\n  (loop [xs [2], n (dec n0)]\n    (if (zero? n)\n      xs\n      (let\n        [prime? (fn [x] (not-any? #(= 0 (rem x %)) xs))\n         numbers (iterate inc (inc (peek xs)))\n         next-prime (first (filter prime? numbers))]\n        (recur (conj xs next-prime) (dec n))))))", "problem": 67, "user": "50cb4cf6e4b0f78a8e1645b4"}, {"code": "(fn [n] \n    (take  n\n           (cons 2 (filter #(.isProbablePrime (BigInteger/valueOf %) 5) \n                           (take-nth 2 (range 1 Integer/MAX_VALUE))))))", "problem": 67, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn [n]\n  (take n\n\t (filter\n\t\t(fn [x] (every? #(not= 0 (rem x %)) (range 2 x)))\n   \t\t(drop 2 (range)))))", "problem": 67, "user": "4f253a49e4b0d66497709ff3"}, {"code": "(fn[x]\n  (letfn [(prime?[n] \n            (empty? (filter #(zero? (mod n %)) \n              (range 2 (inc (/ n 2))))))]    \n    (take x (filter prime? (iterate inc 2)))))", "problem": 67, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn [n]\n    (let [prim? (fn ([x] (not (some #(= (rem x %) 0) (range 2 x)))))]\n      (take n (filter prim? (iterate inc 2)))\n      )\n    )", "problem": 67, "user": "50cae881e4b0f75dcc9a6e51"}, {"code": "(fn prime-numbers\n  [x]\n  (take x (filter (fn prime-number? \n                    [n]\n                    (if (= n 1)\n                      false\n                      (loop [i 2\n                             prime? true]\n                        (if (or (= i n) (not prime?))\n                          prime?\n                          (recur (inc i) (not (zero? (mod n i)))))))) (range))))", "problem": 67, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn test67 [x]\n  (take x\n        (remove\n         (fn [n]\n           (some #(= 0 (mod n %)) (range 2 (->> n Math/sqrt int inc))))\n         (iterate inc 2))))", "problem": 67, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn [n]\n\t(if (= n 1)\n      [2]\n      (cons 2\n  (take (- n 1)\n        (filter \n         (fn [m] (and (not (empty? (range 2 m))) (not-any? #(= 0 (mod m %)) (range 2 m)))) \n         (range))))))", "problem": 67, "user": "50ae5659e4b0a40c9cfb08d2"}, {"code": "(fn [n]\n  (let [prime? (fn [n]\n                 (not-any? #(zero? (mod n %)) (range 2 n)))]\n    (take n\n     (filter prime? (map #(+ 2 %) (range))))))", "problem": 67, "user": "50d8f4b6e4b01f0871336e74"}, {"code": "(let\n[isprime\n(fn [n]\n  (if (< n 2) false\n  (empty? (filter\n    (fn [q] (= 0 (rem n q)))\n    (range 2 (dec n))\n  ))\n  )\n)]\n\n(fn [n]\n  (take n (filter isprime (range)))\n)\n)", "problem": 67, "user": "50bfbf25e4b05ae8c1cbbd9b"}, {"code": "(fn primes [n]\n  (letfn [(prime? [n] \n                  (cond \n                   (or (= n 0) (= n 1)) false \n                   (or (= n 2) (= n 3)) true \n                   :else (= '(1) (filter #(= 0 (rem n %)) (range 1 (inc (Math/sqrt n)))))))]\n  (take n (filter prime? (range)))))", "problem": 67, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [n]\n  (letfn [(prime?\n           ([candidate] (prime? candidate (int (/ candidate 2))))\n           ([candidate divisor]\n              (if (= 1 divisor)\n                true\n                (if (zero? (rem candidate divisor))\n                  false\n                  (recur candidate (dec divisor))))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [n]\n    (take n\n      (filter\n        (fn [p] (every? false? (map (fn [i] (= 0 (mod p i))) (range 2 p))))\n        (drop 2 (range)))))", "problem": 67, "user": "4ee77f15535d93acb0a66868"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n          (.isProbablePrime (BigInteger/valueOf n) 5))]\n  \t(take n\n    \t    (concat [2]\n        \t        (filter prime?\n            \t            (iterate #(+ % 2) 3))))))", "problem": 67, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn [how-many]\n  (letfn [(gen-primes [[x & xs]]\n            (lazy-seq\n             (cons x (gen-primes (filter #(pos? (mod % x)) xs)))))]\n    (take how-many (gen-primes (drop 2 (range))))))", "problem": 67, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [n]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))\n          ]\n    (take n (sieve  (iterate inc 2)))\n    ))", "problem": 67, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "(fn [n]\n  (let [prime? (fn [num]\n                 (cond (= num 2) true\n                       (= (mod num 2) 0) false\n                       (= num 3) true\n                       (= num 5) true\n                       (= (mod num 3) 0) false\n                       (= (mod num 5) 0) false\n                 :else (let [s (for [i (range 3 num 2)]\n                           (if (= (mod num i) 0)\n                             i\n                             1))]\n                   (<= (count (set s)) 1))))\n        cal-prime (fn [primes-count primes cal-to]\n                    (cond (= n primes-count) primes\n                          (prime? cal-to) (recur (inc primes-count)\n                                                 (concat primes (list cal-to))\n                                                 (+ cal-to 2))\n                          :else (recur primes-count primes (+ cal-to 2))))]\n    (cal-prime 1 [2] 3)))", "problem": 67, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn [c]\n  (take c (let [isprime (fn [n] (not-any? #(zero? (rem n %)) (range 2 n)))\n                restprimes (fn restprimes [cur] (\n                                     if (isprime cur) (cons cur (lazy-seq (restprimes (inc cur))))\n                                       (restprimes (inc cur))\n                                       ))]\n          (restprimes 2)\n    ))\n)", "problem": 67, "user": "50e3ec87e4b0463d32072486"}, {"code": "; (fn [nf] \n;   (take nf \n;         (filter (fn [n] (nil? (first \n;                                (filter #(= 0 (mod n %)) (range 2 (+ (/ n 2) 1)))))) \n;                 (iterate inc 2))))\n; upper: right would be (range 2 (sqrt n +1)\n(fn [nf] (take nf \n                (filter (fn [n] \n                          (not (some zero? (map #(mod n %) (range 2 (+ (/ n 2) 1)))))) \n                        (iterate inc 2))))", "problem": 67, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn primes [n]\n  (let [is-prime? (fn [x] (nil? (some #(zero? (mod x %)) (range 2 x))))]\n    (take n (filter is-prime? (iterate inc 2)))))", "problem": 67, "user": "50e3ddd4e4b01912b3285c47"}, {"code": "(fn succint-primes [x]\n  (let [is-prime (fn [prev-primes to-test]\n  \t(nil? (some #(= (mod to-test %) 0) prev-primes)))\n       next-prime (fn next-prime [prev-primes]\n  (loop [cand (inc (last prev-primes))]\n    (if (is-prime prev-primes cand)\n      cand\n      (recur (inc cand)))))]\n  (loop [ret [2 3]\n         ctr 2]\n    (if (= x ctr)\n      ret\n      (recur (conj ret (next-prime ret)) (inc ctr))))))", "problem": 67, "user": "4f08a8a2535dcb61093f6c3d"}, {"code": "(fn [target]\n  (loop [trying 3\n         ps [2]]\n    (if (= (count ps) target)\n      ps\n      (recur\n       (+ trying 2)\n       (if (empty? (filter #(zero? (mod trying %)) ps))\n         (conj ps trying)\n         ps)))))", "problem": 67, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [n]\n  (loop [acc [2] x 3]\n    (if (= n (count acc))\n      acc\n      (recur (if (every? #(< 0 (rem x %)) acc)\n               (conj acc x)\n               acc)\n             (inc x)))))", "problem": 67, "user": "50e3cf55e4b01912b3285c45"}, {"code": "(fn [n]\n  (loop [primes [2] i 3]\n    (cond \n       (< (count primes) n)\n         (if (some #(zero? (rem i %)) primes) \n           (recur primes (+ i 2))\n           (recur (conj primes i) (+ i 2)) )\n       :else primes )))", "problem": 67, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [n] (take n (keep #(when (not (second %)) \n         (first %)) \n      (map #(vector % (some zero? (map mod (repeat %) (range 2 %)))) (rest (rest (range)))))))", "problem": 67, "user": "50e7dd5de4b077ad597af36b"}, {"code": "(fn [n]\n  (let [is-not-prime (fn [n] (or (#{0 1} n)\n                                 (some #(= (mod n %) 0)\n                                       (range 2 (+ 1 (/ n 2))))))\n        prime-seq (fn []\n                    (remove is-not-prime (range)))]\n    (take n (prime-seq))))", "problem": 67, "user": "4fbf2818e4b081705acca317"}, {"code": "(fn final-pr [x]\n  (letfn [(is-prime? [n]\n            (if (= n 1) false\n              (every? false?\n                      (map #(= 0 (mod n %1)) (range 2 n)))))]\n    (take x (filter is-prime? (iterate inc 1)))))", "problem": 67, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [n]\n  (take n (\n   (fn [ran] (\n     filter (fn [k] (not-any? #(zero? (mod k %)) (range 2 (dec k)))) ran)) (iterate inc 2))))", "problem": 67, "user": "50e8a340e4b0ebbe794eb7ed"}, {"code": "(fn [n]\n  (loop [res,[2] i,2 cnt,(dec n)]\n    (cond\n     (zero? cnt) res\n     (some #(zero? (mod i %)) res) (recur res (inc i) cnt)\n     :else (recur (conj res i) (inc i) (dec cnt))\n     )))", "problem": 67, "user": "50f0d000e4b0c5f4fa5ddb6f"}, {"code": "(fn [n]\n  (take n \n        ((fn primes [s]\n          (let [pivot (first s)]\n            (cons pivot (lazy-seq (primes (filter #(not= 0 (rem % pivot)) s))))))(nnext (range)))))", "problem": 67, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [n] (let [sieve (fn sieve [s] (cons (first s) (lazy-seq (sieve (remove  #(= 0 (mod % (first s))) s)))))]\n          (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "50dfb660e4b061dbdced7228"}, {"code": "(fn first-x-primes [x]\n  (letfn [(prime? [n]\n            (if (= 2 n)\n              true\n              (not-any? #(zero? (rem n %)) (range 2 (inc (Math/sqrt n))))))]\n    (take x (filter prime? (iterate inc 2)))))", "problem": 67, "user": "50a7ef7fe4b090657f4a5ce0"}, {"code": "(fn [n] (take n (filter (fn [x] (every? #(> (rem x %) 0) (range 2 x))) (iterate inc 2))))", "problem": 67, "user": "4db29f98535df7e46ed9b6c1"}, {"code": "(partial\n (fn f [s n] (if (zero? (dec n))\n               (vec s)\n               (f (conj s (first (drop-while\n                                  (fn [a] (some (fn [b] (zero? (mod a b))) s))\n                                  (iterate inc (inc (apply max s))))))\n                (dec n))))\n (sorted-set 2))", "problem": 67, "user": "50ed4626e4b01236b1d4983c"}, {"code": "(fn [n]\n  (letfn [(np [p]\n              (loop [c (+ 2 (last p))]\n                (if (not-any? zero? (map #(rem c %) p)) c\n                  (recur (+ 2 c)))))]\n    (loop [p [2 3]]\n      (if (<= n (count p)) p\n        (recur (conj p (np p)))))))", "problem": 67, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn [cnt] \n            ((fn q [n l]\n                (if (= (count l) cnt )\n                    l\n                  (if \n                    (some #(= (rem n %) 0) l) \n                    (q (inc n) l) \n                    (q (inc n) (conj l n))\n                    )\n                  )\n              ) 3 [2])\n      )", "problem": 67, "user": "50ef3e5de4b0a78662fa2652"}, {"code": "(fn [n]\n  (letfn [(sieve [[p & xs]]\n                 (lazy-seq\n                  (cons p\n                        (sieve (filter #(pos? (mod % p))\n                                       xs)))))]\n  (take n (sieve (drop 2 (range))))))", "problem": 67, "user": "50e4b066e4b0cb9ec68fbca6"}, {"code": "(fn [n]\n   (letfn [(isprime? [x]\n                     (every? #(not= 0 (rem x %)) (range 2 x)))] \n   (take n (lazy-seq (for [a (range) :when (and (>= a 2) (isprime? a))] a)))))", "problem": 67, "user": "50bfe725e4b080409b860f26"}, {"code": "(fn [n]\n    (let [prime? (fn [p]\n                   (loop [x 2]\n                     (if (= 0 (mod p x))\n                       (if (= p x) true false)\n                       (recur (inc x)))))]\n      (loop [x 2, v []]\n        (if (= n (count v))\n          v\n          (recur (inc x) (if (prime? x) (conj v x) v))))))", "problem": 67, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn n-primes [n]\n          (let [sieve (fn sieve [s]\n                          (cons (first s)\n                                (lazy-seq (sieve \n                                           (filter #(not= 0 (mod % (first s)))\n                                                   (rest s))))))]\n                (take n (sieve (iterate inc 2)))\n                ))", "problem": 67, "user": "4e6e3aac535d5021c1a89603"}, {"code": "(fn [x]\n  (letfn [(prime? [n]\n            (and (> n 1)\n                 (not (some #(zero? (mod n %)) (range 2 n)))))]\n    (take x (filter prime? (range)))))", "problem": 67, "user": "4f404dcee4b0e243712b1fb0"}, {"code": "#(loop [known-primes [] candidate-prime 2] \n    (cond \n      (< (count known-primes) %) (recur ((fn [known-primes candidate-prime] \n      (cond \n        (reduce \n          (fn [possibly-prime known-prime] \n            (cond possibly-prime\n              (not= 0 (mod candidate-prime known-prime))\n            :else false)) \n          true known-primes) (conj known-primes candidate-prime)\n        :else known-primes)) known-primes candidate-prime) (inc candidate-prime))\n      :else known-primes))", "problem": 67, "user": "5097cfcbe4b00ad8bab4e977"}, {"code": "(fn [n] (loop [x [] y (map #(+ 2 %) (range))] \n  (if (= (count x) n) \n    x \n    (recur \n     (conj x (first y)) \n     (filter #(not= 0 (rem % (first y))) y)))))", "problem": 67, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn primes-seq-upto [n]\n  (letfn [(next-prime [x xs]\n            (if (some #(zero? (rem x %))\n                      (take-while #(<= (* % %) x) xs))\n              (recur (+ x 2) xs)\n              (cons x (lazy-seq (next-prime (+ x 2) (conj xs x))))))]\n    (take n (cons 2 (lazy-seq (next-prime 3 []))))))", "problem": 67, "user": "50052fd0e4b0678c553fc45d"}, {"code": "(fn [n]\n  (into [] \n    (take n \n      (iterate \n         (fn [x]\n           (if ((fn [y]\n                  (every? #(not= 0 (mod y %)) (range 2 y))) (inc x))\n             (inc x)\n             (recur (inc x)))) 2))))", "problem": 67, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [n]\n\t(take n (remove (fn [x]\n                    (some #(= (mod x %) 0) (range 2 x)))\n                  (drop 2 (range)))))", "problem": 67, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "#(take % (filter (fn [n] (.isProbablePrime (BigInteger/valueOf n) 3)) \n                 (iterate inc 1)))", "problem": 67, "user": "5006b7d2e4b0678c553fc48c"}, {"code": "(fn [n-needed]  \n  ;; p is a candidate prime.\n  ;; ps are the primes found so far.\n  (loop [n-found 0, p 2, ps []]    \n    (if (>= n-found n-needed)\n      ps      \n      ;; Iff p is divisible by any previous prime, then it is not prime.\n      (if (some #(zero? (mod p %)) ps)\n        (recur n-found (inc p) ps)\n        (recur (inc n-found) (inc p) (conj ps p))))))", "problem": 67, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn [m] (take m (drop 2 (filter (fn [n] (not-any? #(= 0 (rem n %)) (range 2 n))) (range)))))", "problem": 67, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn prime [n]\n  (let [pred (fn [c e]  (if (some #(= (rem e %) 0) c) false true)) \n        nextprime (fn [o] (loop [i (+ 2 (last o))] (if (pred o i) i (recur (+ 2 i)) )))\n        ]\n    (cond\n      (= n 0) []\n      (= n 1) [2]\n      :else    \n      (loop [i 2 o [2 3]]\n               (if (= i n)\n               o\n               (recur (inc i) (conj o (nextprime o) )))))))", "problem": 67, "user": "5101192ae4b0bef64c30e266"}, {"code": "(fn n-primes [n]\n    (letfn [(primes \n              ([] (primes (iterate inc 2)))\n              ([nums]\n                (lazy-seq (cons (first nums) \n                                (primes (filter #(not= 0 (rem % (first nums))) (rest nums)))))))]\n      (take n (primes))))", "problem": 67, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn [n]\n  (letfn [(p[n]\n            (.isProbablePrime (BigInteger/valueOf n) 5))]\n   (take n (filter p (range)))))", "problem": 67, "user": "4e778d36535d324fb2983d71"}, {"code": "(let [prime? (fn [x] (not-any? zero? (map (partial mod x) (range 2 x))))]\n  (fn [n] (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "510db6cde4b078ea71921145"}, {"code": "(fn [x]\n(nth (iterate\n#(loop [i (last %)]\n(if (not-any? zero? (for [n %] (mod i n)))\n    (conj % i)\n    (recur (inc i))))\n [2])\n     (dec x)))", "problem": 67, "user": "5107b86de4b05b2b4eee7495"}, {"code": "(fn [n] (into [] (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range 1 10000)))))", "problem": 67, "user": "510931ede4b0c71f76895663"}, {"code": "(partial (fn [prime-set maybe-prime count]\n           (if (zero? count)\n             prime-set\n             (if (some #(zero? (mod maybe-prime %)) prime-set)\n               (recur prime-set (inc maybe-prime) count)\n               (recur (conj prime-set maybe-prime) (inc maybe-prime) (dec count)))))\n         []\n         2)", "problem": 67, "user": "51105c7fe4b04c71fce993ef"}, {"code": "(fn [cnt]\n  (loop [ps [2], x 3]\n    (if (= cnt (count ps)) ps\n      (let [p (loop [i x] (if (some #(= 0 (mod i %)) ps) (recur (+ 2 i)) i))]\n        (recur (conj ps p) (+ 2 p))))))", "problem": 67, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn x-prime-numbers\n  [x]\n  (take x (filter \n            (fn [y] (not \n                      (some \n                        #(when (= (mod y %) 0) true)  (range 2 y))))  \n            (range 2 (* x x)))))", "problem": 67, "user": "50f53694e4b057d4c52de881"}, {"code": "#(take %\n       (filter (fn [n]\n                 (if (< n 2)\n                   false\n                   (loop [i 2]\n                     (if (<= i (/ n 2))\n                       (if (= (mod n i) 0)\n                         false\n                         (recur (inc i)))\n                       true\n                       )))) (range)))", "problem": 67, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn n-primes [n]\n  (let [is-prime (fn [x]\n                   (cond\n                    (= x 0) false\n                    (= x 1) false\n                    (= x 2) true\n                    :else\n                    (loop [i 2]\n                      (if (= (rem x i) 0) false\n                       (if (> (* i i) x) true\n                         (recur (inc i)))))))]\n    (take n (filter is-prime (range)))))", "problem": 67, "user": "5119f3d5e4b06c8af0111818"}, {"code": "(fn [n]\n  (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range))))", "problem": 67, "user": "5102489de4b00c483ae176f6"}, {"code": "(fn [n]\n  (letfn [(f0 [x coll] (every? #(not= (mod x %1) 0) coll))]\n    (loop [coll [2] x 3]\n      (if (>= (count coll) n)\n        coll\n        (recur (if (f0 x coll) (conj coll x) coll) (inc x))))))", "problem": 67, "user": "50a5f72fe4b0aa96157e2611"}, {"code": ";; idea from Christophe Grand http://clj-me.blogspot.pt/2008/06/primes.html\n\n(fn [n]\n    (let [next (fn next [guess primes]\n                 (let [possible-dividers (take-while #(<= (* % %) guess) primes)]\n                   (if (some #(zero? (mod guess %)) possible-dividers)\n                     (recur (+ 2 guess) primes)\n                     (lazy-seq\n                      (cons\n                       guess\n                       (next (+ 2 guess) (conj primes guess)))))))]\n      (take n (lazy-cat [2 3] (next 5 [2 3])))))", "problem": 67, "user": "4e50ad74535dc968683fc4ec"}, {"code": "(fn [x]\n  (loop [coll []\n         n 2]\n    (if (= (count coll) x)\n      coll\n      (recur\n        (if (some zero? (butlast (map #(rem n %) (range 2 (inc n)))))\n          coll\n          (conj coll n))\n        (inc n)))))", "problem": 67, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn [x]\r\n\t(letfn [(is-prime [x]\r\n\t\t\t\t(== 2 (.size (into #{} (filter (complement nil?)\r\n          \t\t(map #(if (== 0 (mod x %)) %) (range 1 (inc x))))))))\r\n            (primes\r\n            \t([] (primes 1))\r\n          \t\t([n] (if (is-prime n)\r\n          \t\t(cons n (lazy-seq (primes (inc n))))\r\n          \t\t(lazy-seq (primes (inc n)))\r\n  \t\t\t\t)))]\r\n    (take x (primes))\r\n    )\r\n )", "problem": 67, "user": "510a6bece4b06956752d35af"}, {"code": "(fn prime-generator [n]\n  (take n (filter (fn is-prime [n]\n                    (nil? (some #(zero? (mod n %))\n                                (range 2 n)))) (iterate inc 2))))", "problem": 67, "user": "4f890488e4b033992c121c76"}, {"code": "(fn f [n]\n  (letfn [(isPrime? [n'] (not-any? zero? (map #(mod n' %) (range 2 n'))))]\n    (take n (filter isPrime? (iterate inc 2)))))", "problem": 67, "user": "51195e77e4b055cfb310d499"}, {"code": "#(take % (filter (fn [p] (loop [n 2]\n                    (cond \n                     (> n (Math/sqrt p)) true\n                     (zero? (mod p n)) false\n                     :else (recur (inc n)))))\n              (iterate inc 2)))", "problem": 67, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn f [n]\n  (take n\n        (filter\n         (fn prime? [n]\n           (not\n           (some #(zero?\n                   (mod n %))\n                 (drop 2\n                       (range n)))))\n         (drop 2 (range 1000)))))", "problem": 67, "user": "511f88eee4b085952a83535f"}, {"code": "(fn [x]\n  (loop [res [2]\n         n 3]\n    (if (= x (count res))\n      res\n      (if (some #(zero? (mod n %)) res)\n        (recur res (+ n 2))\n        (recur (conj res n) (+ n 2))))))", "problem": 67, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn prime [n]\n  (let [lazy-prime-fn (fn lazy-prime [valid-seq]\n                     (cons (first valid-seq) (lazy-seq (lazy-prime (remove #(= 0 (mod % (first valid-seq))) valid-seq)))))\n        lazy-primes (lazy-prime-fn (->> (range) rest rest))]\n    (take n lazy-primes)))", "problem": 67, "user": "51281b25e4b03a34742b4304"}, {"code": "#(take %\n       ((fn f [s]\n          (cons (first s)\n                (lazy-seq (f (filter (fn [x] (not= 0 (mod x (first s)))) s)))))\n        (range 2 999)))", "problem": 67, "user": "51256b40e4b05d10e3e395f8"}, {"code": "(fn [n]\n   (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 10) (nthrest (range) 2))))", "problem": 67, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn [x]\n  (take x\n        (filter\n         (fn [n]\n  (and (or (odd? n) (= n 2))\n       (> n 1)\n   (zero? (count (filter #(zero? (rem n %))\n                         (range 3 n 2)))))) (range))))", "problem": 67, "user": "50589113e4b06522596eba7f"}, {"code": "(fn primes\n  [n]\n  (cond\n   (= 0 n) []\n   (= 1 n) [2]\n   (= 2 n) [2 3]\n   :else\n     (let [is-prime? (fn [x known-primes] (not (some #(zero? (mod x %)) known-primes)))]\n       (loop [known-primes [2 3]\n              x 4]\n         (cond\n          (= n (count known-primes)) known-primes\n          (is-prime? x known-primes) (recur (conj known-primes x) (inc x))\n          :else (recur known-primes (inc x)))))))", "problem": 67, "user": "511720eae4b0063b4e3e16da"}, {"code": "(fn [n]\n  (loop [i n sofar [2]]\n     (if (= i 1)\n       sofar\n       (recur (dec i)\n              (conj\n               sofar\n               (first\n                (filter (fn [x] (not-any? #(zero? (mod x %)) sofar))\n                        (iterate inc (last sofar)))))))))", "problem": 67, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn first_n_primes\n  ([n prime_list]\n    (cond\n      (= n 0) '()\n      (= n 1) (reverse prime_list)\n      :else\n        (recur\n          (- n 1)\n          (\n            (fn next_prime\n              ([div_list candidate]\n                (if\n                  (not (\n                        (fn is_divisor_in\n                          [n div_list]\n                          (cond\n                            (empty? div_list)\n                              false\n                            (\n                              (fn is_divisible\n                                [n elm]\n                                (cond\n                                  (= n 0 ) true\n                                  (= elm 0) false\n                                  :else\n                                  (= (mod n elm) 0)\n                                )\n                              )\n                              n (first div_list)\n                            )\n                              true\n                            :else\n                              (recur n (rest div_list))\n                          )\n                        )\n                        candidate div_list\n                       )\n                  )\n                  (cons candidate div_list)\n                  (recur div_list (+ candidate 1))\n                )\n              )\n              ([div_list]\n                (if\n                  (empty? div_list)\n                  nil\n                  (next_prime div_list (+ (first div_list) 1))\n                )\n              )\n            )\n            prime_list\n          )\n        )\n    )\n  )\n  ([n] (first_n_primes n '(2)))\n)", "problem": 67, "user": "502be4fae4b08f5602f232eb"}, {"code": "(fn [n]\n  (let [z (map inc (range))]\n    (letfn [(isprime? [x]\n                      (= 2 (count (filter #(= (rem x %) 0) (take x z)))))]\n      (take n (filter isprime? z)))))", "problem": 67, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn [n]\n  (loop [ps [2], num 3]\n    (if (= (count ps) n)\n      ps\n      (if (every? #(> (mod num %) 0) ps)\n        (recur (conj ps num) (+ num 2))\n        (recur ps (+ num 2))))))", "problem": 67, "user": "4f525fdce4b03ad3f0c10d37"}, {"code": "(fn [num]\n   (loop [result [2]]\n     (if (= (count result) num)\n       result\n        (recur (conj result (\n                             (fn [y]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (loop [index y]     \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     (if (= (count ((fn [x]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (loop [res [] i 2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     (if (= (- x 1) i)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       res\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       (if (= 0 (mod x i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               (recur (conj res i) (inc i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               (recur res (inc i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t          )      \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       )              \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ) index ))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t            0)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       (recur (inc index))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       )     \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     )   \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t) (inc (last result))                              \n                              )))      \n       )          \n     )     \n   )", "problem": 67, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn [n]\n  (letfn\n    [(sieve [xs]\n       (let [x (first xs)]    \n         (cons x\n               (lazy-seq\n                 (sieve (filter (fn [y] (not= (rem y x) 0))\n                                (next xs)))))))]\n     (take n (sieve (drop 2 (range))))))", "problem": 67, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn [n]\n  (let  [prime? (fn [p]\n                  (or (= p 2)\n                      (and (> p 2)\n                           (reduce (fn [y, x] (and y (> (rem p x) 0)))\n                                   true\n                                   (range 2 (+ 1 (Math/pow p 0.5)))))))\n         ]\n    (take n (filter prime? (range)))))", "problem": 67, "user": "4f03f197535dcb61093f6b84"}, {"code": "(fn solution [z]\n  (take z (filter\n    (fn prim? [x]\n      (if (= x 2)\n        true\n\t (not (some #(= (mod x %) 0) (range 2 (inc (Math/sqrt x)))))))\n    (range 2 1000000)\n           )))", "problem": 67, "user": "4e2164ff535d04ed9115e815"}, {"code": "(fn gen-primes [cnt] (take cnt\n\t(lazy-cat [2]\n\t\t((fn next-prime [n primes]\n\t\t\t(let [divisors (take-while #(<= (* % %) n) primes)]\n\t\t\t\t(if (some #(zero? (mod n %)) divisors)\n\t\t\t\t\t(recur (+ n 2) primes)\n\t\t\t\t\t(lazy-seq (cons n (next-prime (+ n 2) (conj primes n))))\n\t\t\t\t)\n\t\t\t)\n\t\t) 3 [2])\n\t)\n))", "problem": 67, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn primes [cnt]\n    (let [is-prime? (fn [x]\n        (cond (= x 0) false\n              (= x 1) false\n              :else\n            (let [m (/ x 2)]\n            (loop [i 2]\n                (if (> i m)\n                    true\n                    (if (= (rem x i) 0)\n                        false\n                        (recur (inc i))))))))]\n    (take cnt (filter is-prime? (range)))))", "problem": 67, "user": "5132c6f0e4b021281ec7b6d3"}, {"code": "(fn [n]\n  (take n \n        (filter\n          (fn [x]\n            (not-any? #(zero? (rem x %)) (range 2 (-> x Math/sqrt int inc)))\n            )\n          (iterate inc 2)))\n  )", "problem": 67, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [m] \n  (take m\n   (filter \n    (fn [n] \n      (not-any? \n       #(= 0 (mod n %)) \n       (range 2 (inc (int (Math/sqrt n)))))) (range 2 1000))))", "problem": 67, "user": "50e0d5a3e4b061dbdced723d"}, {"code": "(fn primes [n]\n  (letfn [(gcd [a, b]\n               (loop [a a\n                      b b]\n                 (if (= b 0)\n                   a\n                   (recur b (rem a b)))))\n          (tot [n]\n               (count (filter #(= 1 (gcd n %)) (range 1 n))))\n          (prime? [p]\n                  (= (- p 1) (tot p)))]\n    (loop [out []\n           x   2]\n      (if (= (count out) n)\n        out\n        (recur\n         (if (prime? x)\n           (conj out x)\n           out)\n         (inc x))))))", "problem": 67, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn aa [x] \n  (loop [x1 x y 2 z []] \n     (if (= 0 x1) z\n     \t\t\t (if (some #(= 0 (rem y %)) (range 2 y)) \n                   (recur x1 (inc y) z)\n                   (recur (dec x1) (inc y) (conj z y))\n                   )\n       )\n    )\n  )", "problem": 67, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn [x] \n  (letfn [(is-prime [n] (if (= n 2) true \n                        (loop [divisor 2] \n                          (if (< (* divisor divisor) (inc n)) \n                            (if (zero? (mod n divisor)) nil (recur (inc divisor))) \n                            true))))] \n  (loop [primes [] curr 2] (if (= (count primes) x) \n                             primes \n                             (recur (if (is-prime curr) (conj primes curr) primes) (inc curr))))))", "problem": 67, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn prms [n]\n  (let [nextprm\n        (fn nextprm [known guess]\n          (if (some #(= 0 (mod guess %)) known)\n            (recur known (inc guess))\n            (lazy-seq\n              (cons guess\n                    (nextprm\n                      (cons guess known)\n                      (inc guess))))))]\n    (take n (nextprm '() 2))))", "problem": 67, "user": "504e12ade4b078edc5f593b7"}, {"code": "#(letfn [(prime? [x]\n           ((fn [x y]\n              (cond (< x y)           false\n                    (= x y)           true\n                    (zero? (rem x y)) false\n                    :else (recur x (inc y)))) x 2))]\n   (take % (filter prime? (range))))", "problem": 67, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn get-n-primes [n] (take n (sort ((fn primes [n] (let [sieve (transient (set (cons 2 (range 3 n 2))))] (loop [s sieve f 3] (cond (> (* f f) n) (persistent! s) :else (recur (reduce disj! s (range (* f f) n f)) (inc f)))))) 1000))))", "problem": 67, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn [n] (take n \n               (sort \n                 (clojure.set/difference \n                   (into #{} (range 2 1000)) \n                   (into #{} (flatten \n                               (for [i (range 2 1000)] \n                                 (map #(if (= (if (not= i %) (rem i %)) 0) (conj [] i)) (range 2 i)))))))))", "problem": 67, "user": "513ca934e4b0b86ece9f3228"}, {"code": "(fn [n]\n  (last (take-while\n          #(not(= (count %) (inc n)))\n          (reductions\n           (fn [ps x] (if (not-any? #(= 0 %) (map #(rem x %) ps) )\n                    (conj ps x)\n                    ps))\n           [2] (iterate inc 2)))))", "problem": 67, "user": "51424cc8e4b0b50abeb46b34"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n  (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn [len] (->> (range) (drop 2) (reductions (fn [[sieve _] num] (if (every? #(pos? (rem num %)) sieve) [(conj sieve num) num] [sieve nil])) [#{} nil]) (map second) (filter identity) (take len)))", "problem": 67, "user": "5137c3b0e4b0509a8b470482"}, {"code": "(fn [x] (->> (nnext (range))\n             (filter (fn [a] (every? #(> % 0) (map #(mod a %) (range 2 (dec a))))))\n             (take x)))", "problem": 67, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn nth-primes [nth] \n  (take nth \n        (filter #(= 1 \n                    (count\n                           ((fn primes[n]\n                             (loop [n_ n factor 2 primes_ []]\n                               (cond (= n_ 1) primes_ \n                                     (= 0 (rem n_ factor)) (recur (quot n_ factor) factor (conj primes_ factor))\n                                     :else (recur n_ (inc factor) primes_)))) %)) )\n                    \n                 \n        (range 1 1000))))", "problem": 67, "user": "4ff01fa9e4b0678c553fc321"}, {"code": "(fn primes [nums]\n    (take nums\n          (filter\n           (fn prime? [n]\n             (if (<= n 1) false\n                 (let [nlist (range 1 (inc n))]\n                   (>= 2 (count (filter #(zero? (mod n %)) nlist))))))\n           (range))))", "problem": 67, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [x]\n  (letfn [(is-prime [n]\n            (and (> n 1)\n                 (empty? (filter #(zero? (mod n %))\n                                 (range 2 n))))\n            )]\n    (take x (filter is-prime (range)))))", "problem": 67, "user": "4dada426c9a9d6ed2a99dc57"}, {"code": "(fn prime?[n]\n   (letfn [(find-divisor [n d]\n           (loop [x d]\n             (cond\n             (> (* x x) n) n\n             (= (rem n x) 0) x\n             :else (recur (inc x)))))\n         \n         (smallest-divisor [n]\n           (find-divisor n 2))]\n  (take n (drop 2 (filter #(= (smallest-divisor %) %) (range))))))", "problem": 67, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [n] \n  (nth (iterate (fn np [ps]\n                     (loop [m (inc (last ps))]\n                     \t(if (some #(zero? (rem m %)) ps) \n                          (recur (inc m)) (conj ps m)))) [2]) (dec n)))", "problem": 67, "user": "5145832be4b0e8879607340a"}, {"code": "(fn sieve \n  ([n]\n    (sieve n (iterate inc 2)))\n  ([n l]\n    (let [hd (first l) bd (rest l)]\n      (if (zero? n)\n        []\n        (lazy-seq\n          (take n      \n            (cons hd (sieve (- n 1) (filter #(not (zero? (mod % hd))) bd))) ))))))", "problem": 67, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [x]\n    (letfn [(sieve [[xs ys]]\n                [(conj xs (first ys)) (remove #(= 0 (rem % (first ys))) ys)])]\n        (first (nth (iterate sieve [[] (drop 2 (range 10000))]) x))))", "problem": 67, "user": "50b35486e4b03ea88043356a"}, {"code": "(fn [x]\n  (letfn [(c? [a] (some integer? (map #(/ a %) (range 2 a))))]\n    (take x (remove c? (drop 2 (range))))))", "problem": 67, "user": "514d8084e4b019235f6c0588"}, {"code": "(let [next-prime (fn [primes]\n                   (let [possible (rest (iterate inc (last primes)))\n                         any-divides? (fn [lst n] (some #(= 0 (mod n %1)) lst))\n                         possible-divisors (fn [n] (take-while #(<= (* %1 %1) n) primes))\n                         is-prime (fn [n] (not  (any-divides? (possible-divisors n) n)))]\n                     (first (filter is-prime possible))))]\n  (fn primes\n  ([n] (primes n [2]))\n  ([n lst] (if (= n (count lst))\n             lst\n             (recur n (conj lst (next-prime lst)))))))", "problem": 67, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "(fn [n]\n  (letfn [(prime? [x] (not-any? #(= 0 (mod x %)) (range 2 x)))]\n    (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn first-n-primes [n]\n  (letfn [(prime? [x]\n                  (not-any? #(= 0 (rem x %)) (range 2 x)))]\n   (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [n] \n  (let [prime? (fn [x]\n                 (loop [d (int (Math/sqrt x))]\n                   (cond\n                    (= d 1) true\n                    (= (rem x d) 0) false\n                    :else (recur (dec d)))))]\n    (loop [x 2 ret []]\n      (if (= (count ret) n)\n        ret\n        (recur (inc x) (if (prime? x) (conj ret x) ret))))))", "problem": 67, "user": "5117c31ee4b0e0897831a60c"}, {"code": "(fn f [x y z] (if (zero? z) y (if (reduce #(and %1 %2) true (map #(not= 0 (mod x %)) y)) (f (inc x) (conj y x) (dec z)) (f (inc x) y z)))) 2 []", "problem": 67, "user": "514d398ee4b019235f6c0583"}, {"code": "(fn pme [n]\n  (loop [lmt n\n         i 2\n         lst [] ]\n    (if (= (count lst) lmt)\n      (reverse lst)\n      (if (nil? (some #(= (mod i %) 0 ) lst ))\n          (recur n (inc i) (cons i lst))\n          (recur n (inc i) lst))\n        )\n    ))", "problem": 67, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn [k] (take k (remove (fn p[x] (some #(= 0 (rem x %)) (range 2 x))) (iterate inc 2))))", "problem": 67, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn f [n]\n  (if (= n 1) [2]\n    (let [s (f (dec n))]\n      (conj s\n        (first (filter (fn [t] \n  (= nil (some #(zero? (rem t %)) s)))\n  (iterate inc (last s))))\n            )\n     )\n  )\n)", "problem": 67, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn first-x-primes [x]\n  (let [prime? (fn [val] (not-any? #(zero? (rem val %)) (range 2 (inc (Math/sqrt val)))))]\n    (concat [2] (take (dec x) (filter prime? (iterate inc 3))))))", "problem": 67, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn [n]\n  (loop [p [] i 2 n n]\n    (if (> n 0)\n      (if (some #(= 0 %) (map #(rem i %) p))\n        (recur p (inc i) n)\n        (recur (conj p i) (inc i) (dec n)))\n      p)))", "problem": 67, "user": "4f0c4518535d0136e6c2230b"}, {"code": "(fn primes [x]\n\t(loop [curr 2 primes []]\n\t\t(if (= (count primes) x)\n\t\t\tprimes\n\t\t\t(if (not-any? #(= (rem curr %) 0) (range 2 curr))\n\t\t\t\t(recur (+ curr 1) (conj primes curr))\n\t\t\t\t(recur (+ curr 1) primes)))))", "problem": 67, "user": "50ed8a5fe4b06330c1f87c3d"}, {"code": "(fn pys [n]\n\t(take n ((fn sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s)))))) (iterate inc 2))))", "problem": 67, "user": "50ab44b2e4b0f65d68208509"}, {"code": "(fn [n]\n  (take n (filter \n            (fn [y]\n              (if (< y 2)\n                false\n                (if (= y 2)\n                  true\n                  (not (some #(= 0 (mod y %)) (rest (rest (range (+ 1 (Math/sqrt y))))))))))\n            (range))))", "problem": 67, "user": "5110b8bae4b04c71fce993f4"}, {"code": "(fn [n]\n  (take n\n        (filter (fn [x]\n                  (loop [i 2]\n                    (if (>= i x)\n                      true\n                      (if (zero? (rem x i))\n                        false\n                        (recur (inc i)))))) \n                (iterate inc 2))))", "problem": 67, "user": "515828b8e4b0a069fd272c71"}, {"code": "(fn primes [x]\n  (letfn [(prime? [p] (not (some #(zero? (mod p %)) (range 2 p))))]\n    (take x (filter prime? (iterate inc 2)))))", "problem": 67, "user": "513dcc1ce4b0825f97f7f964"}, {"code": "(fn [n]\n  (letfn [(primes [s]\n            (cons (first s)\n              (lazy-seq (primes (filter #(not= 0 (mod % (first s)))\n                                        (rest s))))))]\n    (take n (primes (iterate inc 2)))))", "problem": 67, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn [x] \n\t(take x \n\t\t(filter \n\t\t\t(fn [n] (and (> n 1) (zero? (count (filter #(zero? (rem n %)) (range 2 n))))))\n\t\t\t(range))))", "problem": 67, "user": "510c123be4b078ea7192110e"}, {"code": "(fn primes [n]\n  (loop [cur-primes [2] r 3 current-num-primes 1]\n    (cond \n      (>= (count cur-primes) n) cur-primes\n      (some #(= (mod r %) 0) cur-primes) (recur cur-primes (+ r 2) current-num-primes)\n      :else (recur (conj cur-primes r) (+ r 2) (+ current-num-primes 1)))))", "problem": 67, "user": "504e108ce4b078edc5f593b3"}, {"code": "#(second\n  (nth\n   (iterate\n    (fn [[n s]]\n      (if (some (comp zero? (partial mod n)) s)\n        (recur [(inc n) s])\n        [(inc n) (conj s n)]))\n    [3 [2]]) (dec %)))", "problem": 67, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn [n]\n  (let [prime (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n  (take n (filter prime (iterate inc 2)))))", "problem": 67, "user": "4fbef9a6e4b081705acca316"}, {"code": "(fn [x]\n  (letfn [(prime? [x]\n                  (not (some #(= 0 (mod x %))\n                             (range 2 x))))]\n    (let [primes (filter prime? (drop 2 (range)))]\n      (take x primes))))", "problem": 67, "user": "515ead6be4b049add99a053e"}, {"code": "(fn primes\n  ([n] (lazy-seq (cons 2 (primes (dec n) [2]))))\n  ([n prev]\n   (when (> n 0)\n     (let [candidates (range (inc (last prev)) Double/POSITIVE_INFINITY)\n           prime (first (filter (fn [x] (not-any? #(= 0 (rem x %)) prev)) candidates))]\n       (lazy-seq (cons prime (primes (dec n) (conj prev prime))))))))", "problem": 67, "user": "51307b84e4b08c712d3fae39"}, {"code": ";;fastest implementation\n\n(fn hashtable-primes\n  [n]\n  (letfn [\n          (next-composite [x step sieve]\n            (if (sieve x)\n                                        ; the composite number has already been found previously\n              (recur (+ x step) step sieve)\n                                        ; brand new composite number\n              (assoc sieve x step)))\n          (next-prime [x sieve]\n            (let [step (sieve x)]\n              (if (sieve x)\n                                        ; found a composite\n                (recur (+ x 2) (next-composite (+ x step) step (dissoc sieve x)))\n                                        ; found a prime\n                (cons x\n                      (lazy-seq\n                       (next-prime (+ x 2) (assoc sieve (* x x) (* x 2))))))))]\n    (take n (cons 2 (lazy-seq (next-prime 3 {}))))))", "problem": 67, "user": "51533ecde4b0252ac4b16619"}, {"code": "(fn first-primes [n]\n  (let [prime? #(.isProbablePrime (BigInteger/valueOf %) 10)]\n    (take n (filter prime? (range 1 Integer/MAX_VALUE)))))", "problem": 67, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn get-primes [n]\n  (let [is-prime? (fn [n] (empty? (filter #(zero? (mod n %)) (range 2 (dec n)))))]\n  (take n (filter is-prime? (drop 2 (range))))))", "problem": 67, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [n] (take n (filter (fn [x] (= 2 (count (filter #(= (mod x %) 0) (range 1 (+ x 1)))))) (range))))", "problem": 67, "user": "516385cee4b055933a9ca02d"}, {"code": "(fn\n  [N]\n  (take \n   N \n   (reduce\n    (fn\n      [primes idx]\n      (filter #(let [fac (nth primes idx)] (or (= % fac) (not= 0 (mod % fac)))) primes)\n    )\n    (drop 2 (range))\n    (range 0 N)\n   )\n  )\n)", "problem": 67, "user": "5162757ee4b03cfa3774b3fe"}, {"code": "(fn [n]\n  (take n ((fn sieve [nums]\n             (cons (first nums)\n                   (lazy-seq (sieve (filter #(not= 0 (mod % (first nums)))\n                                            (rest nums))))))\n             (iterate inc 2))))", "problem": 67, "user": "5166e80de4b060c690c1f4c5"}, {"code": "(fn [num]\n    (letfn [(divides [d n]\n              (= 0 (mod n d)))\n            (nextprime [n smaller-primes]\n              (if (some #(divides % n) smaller-primes)\n                (recur (inc n) smaller-primes)\n                n ))\n            (primes [from smaller-primes]\n              (let [n (nextprime from smaller-primes)]\n                (cons n (lazy-seq (primes (inc n) (conj smaller-primes n))))))]\n      (let [all-primes (primes 2 #{})]\n        (take num all-primes))))", "problem": 67, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [n]\n      (letfn [(prime? [x]\n                      (not (seq (drop-while #(not= 0 (rem x %))\n                                            (range 2 x)))))]\n            (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "50f48298e4b004d364930527"}, {"code": "(fn primes\n  ([n]\n   (take n (primes (iterate inc 2) n)))\n  ([s n]\n   (cons (first s)\n         (lazy-seq (primes (filter #(not= 0 (mod % (first s)))\n                                   (rest s)) n)))))", "problem": 67, "user": "50ebd63ce4b04edc3377703c"}, {"code": "(fn primes [r]\n  (letfn [(prime? [n] (not-any? (comp zero? (partial rem n)) (range 2 (inc (/ n 2)))))]\n  (take r (filter prime? (drop 2 (range)))))\n)", "problem": 67, "user": "513b43ede4b067e25a345ed3"}, {"code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "51696bcde4b03f62cda68ce7"}, {"code": "(fn [n]\n  (letfn [(is-prime? [n] (nil? (some #(zero? (rem n %)) (range 2 n))))]\n    (take n (lazy-seq (filter is-prime? (iterate inc 2))))))", "problem": 67, "user": "50b1d166e4b03ea880433554"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n            (case x\n              0 false\n              1 false\n              (let [max (Math/sqrt x)]\n                (loop [i 2]\n                  (cond\n                   (> i max) true\n                   (= 0 (mod x i)) false \n                   :else (recur (inc i)))))))]\n    (take n (filter prime? (range)))))", "problem": 67, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn prime-list [n]\n  (take n\n    (filter \n      (fn prime? [k]\n        (not\n          (some \n            (fn [j] (= 0 (mod k j))) \n            (range 2 (- k 1))\n            )\n          )\n        )\n        (range 2 (* n n))\n      )\n    )\n  )", "problem": 67, "user": "516cbba6e4b06f078fab2525"}, {"code": "(fn [x]\n  (take x\n    (filter\n      (fn [x]\n        (empty? (filter #(zero? (mod x %)) (range 2 x))))\n      (drop 2 (range)))))", "problem": 67, "user": "50cfcad6e4b00b15ecee9752"}, {"code": "#(take % (remove \n           (fn [i] (some (fn [x] (= 0 (mod i x))) (range 2 i))) \n           (iterate inc 2)))", "problem": 67, "user": "4eab612d535d7eef30807316"}, {"code": "(fn [y] \n    (take y \n      (filter \n        (fn [x] (not-any? zero? (map #(mod x %) (range 2 x))))\n        (iterate inc 2))))", "problem": 67, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn [n]\n   (loop [i 2 l []]\n     (if (= n (count l))\n       l\n       (let [newl (if\n     (reduce (fn [bool el]\n            (print bool el)\n               (and\n                bool\n                (not (zero? (mod i el)))))\n             true\n             l)\n     (conj l i)\n     l)] (recur (inc i) newl)))))", "problem": 67, "user": "51684318e4b03f62cda68cd6"}, {"code": "(fn [n] (take n (filter (fn [x] (not-any? #(= 0 (rem x %)) (range 2 x))) (drop 2 (range)))))", "problem": 67, "user": "517adc6ce4b0925c997201c4"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn [n] (every? #(> (mod n %) 0) (range 2 n)))\n      (iterate inc 2))))", "problem": 67, "user": "515e8ce2e4b049add99a053d"}, {"code": "(fn [n]\n  (let [divisor? (fn [x y] (zero? (mod x y)))\n        prime? (fn [n] (not-any? (partial divisor? n) (take-while #(<= (* % %) n) (range 2 n))))\n        primes (filter prime? (rest (rest (range))))]\n    (take n primes)))", "problem": 67, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn [x]   \n  (letfn [(divisible? [n] (fn [k] (zero? (mod k n))))\n          (sieve [numbers] (let [[p & restn] numbers] \n                             (lazy-seq (cons p (sieve (remove (divisible? p) restn))))))\n          (naturals-from-2 [] (iterate inc 2))\n          (primes [] (sieve (naturals-from-2)))]\n  (take x (primes))))", "problem": 67, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn primes [n]\n  (take n\n        ((fn sieve [s]\n           (cons (first s)\n                 (lazy-seq\n                  (sieve\n                   (filter #(not= 0 (mod % (first s)))\n                           (rest s))))))\n         (iterate inc 2))))", "problem": 67, "user": "51740b65e4b0d277d717bc67"}, {"code": "(fn [n]\n  (loop [cnt 1 start 2 ret []]\n    (if (> cnt n)\n      ret\n      (if (.isProbablePrime (BigInteger/valueOf start) 5)\n        (recur (inc cnt) (inc start) (conj ret start))\n        (recur cnt (inc start) ret)))))", "problem": 67, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [n] (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range 1 Integer/MAX_VALUE))))", "problem": 67, "user": "4f6cf933e4b07046d9f4efc2"}, {"code": "(fn prime [n]\n  (cond (= n 1) [2]\n        (> n 1) (vec\n               \t (let [z (prime (dec n))]\n                 (conj z (first (filter (fn [v] \n                                          (every? #(not (zero? %)) \n                                                 (map mod (repeat (dec n) v) z))) \n                                        (iterate inc (inc (last z))))))))))", "problem": 67, "user": "51780f88e4b03d69594194c9"}, {"code": "#(take % (filter (fn [n] (.isProbablePrime (BigInteger/valueOf n) 8)) (range)))", "problem": 67, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn [n]\n  (let [candidates (drop 2 (range))]\n    (take n\n          (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 (dec x)) )) candidates))))", "problem": 67, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn f [n]\n  (if (= 1 n)\n    [2]\n    (let [a (f (dec n))]\n      (conj\n       a\n       (first\n        (filter\n         (fn [x] (reduce #(and %1 %2) (map #(not (= 0 (mod x %))) a)))\n         (iterate inc (inc (last a)))))))))", "problem": 67, "user": "5185e17ee4b0da5a5be3bac5"}, {"code": "(fn [n]\n  (letfn [(is-prime [n primes] (not-any? #(zero? (mod n %)) primes))\n          (next-prime [xs] (first (filter #(is-prime % xs) (iterate inc (last xs)))))\n          (add-prime [xs] (conj xs (next-prime xs)))]\n    (nth (iterate add-prime [2]) (dec n))))", "problem": 67, "user": "518696c1e4b0c40be512d708"}, {"code": "(fn [take_num]\n  (let [is_prime (fn is_prime [n]\n                   (cond\n                    (< n 2) false\n                    (= n 2) true\n                    (= 0 (mod n 2)) false\n                    (not-empty (filter #(= 0 (mod n %)) (range 3 n 2))) false\n                    :else true))]\n    (take take_num (for [i (range) :when (is_prime i)]\n                     i))))", "problem": 67, "user": "5016ac54e4b052339a490e7b"}, {"code": "(fn ps [n]\n  (take n\n        (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 x)))\n                (drop 2 (range)))))", "problem": 67, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [n]\n  (letfn [(step [coll]\n            (let [head (first coll)]\n              (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n    (take n (step (range 2 Long/MAX_VALUE)))))", "problem": 67, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn [a] (take a (letfn [(prime? [n] (not-any? zero? (map #(rem n %) (range 2 n))))] (filter prime? (drop 2 (range))))))", "problem": 67, "user": "5134973ce4b0230e9f713b42"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not-any? #(integer? (/ x %)) (range 2 x)))]\n    (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4fbd24d2e4b081705acca2ff"}, {"code": "(fn [n]\n  (loop [result []\n         x 2]\n    (if (= (count result) n)\n      result\n      (if (some #(= (rem x %) 0) result)\n        (recur result (inc x))\n        (recur (conj result x) (inc x))))))", "problem": 67, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [n]\n  (letfn [(prime? [p]\n    (or (= p 2)\n        (every? #(> (rem p %) 0)\n                (range 2 (inc (Math/floor (Math/sqrt p)))))))]\n  (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn get-primes [x]\n  (let [naturals ((fn nats-from-n [n] (cons n (lazy-seq (nats-from-n (inc n))))) 1)\n        prime? (fn [n]\n                 (= 2 (count (filter #(zero? (mod n %)) (take n naturals)))))\n        primes (filter prime? naturals)]\n    (take x primes)))", "problem": 67, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [n]\n  (letfn [(sieve [[p & rest]] \n            (lazy-seq (cons p (sieve (remove #(= 0 (mod % p)) rest)))))]\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "5126dbabe4b083bb8f88cf0e"}, {"code": "#(take % ((fn pr [s]\n   (cons (first s) (lazy-seq \n     (pr (filter (fn [n] (not= \n(mod n (first s)) 0)) (rest s))))))\n(iterate inc 2)))", "problem": 67, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [n] (take n (filter \n          \n          \n          (fn prime? [x]\n  (cond \n   (= 2 x) true\n   (= 1 x) false\n   (= 0 x) false\n   :else (every? \n    #(< 0 (rem x %)) \n    (range 2 (+ 1 (Math/sqrt x))))\n  )\n )\n          \n          (range))))", "problem": 67, "user": "4fb03cf4e4b081705acca262"}, {"code": "(fn [y] (take y (filter (fn pri [x] (reduce #(and %1 (not= 0 (rem x %2))) true \n                    (range 2 x))) (drop 2 (range))))) ;; (+ 2 ( int (. Math sqrt x))))))", "problem": 67, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn lazy-prime\n  ([n] (take n (lazy-prime)))\n  ([] (cons 2 (lazy-prime 3 [2])))\n  ([i primes]\n   (lazy-seq\n     (if (not-any? #(= 0 (mod i %)) primes)\n       (cons i (lazy-prime (+ 2 i) (conj primes i)))\n       (lazy-prime (+ 2 i) primes)))))", "problem": 67, "user": "51460e4ce4b04ef915e37314"}, {"code": "(fn [k] (let [is-prime (fn [n]\n    \t\t\t\t(every? #(not= (mod n %) 0) \n            \t\t\t(take-while #(<= (* % %) n) (drop 2 (range)))))]\n              (take k (filter is-prime (drop 2 (range))))))", "problem": 67, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn pr [x]\n  (loop [nleft x\n         lst []\n         cur 2]\n    (if (= 0 nleft)\n      lst\n      (if (= 2 cur)\n        (recur (dec nleft)\n               (conj lst 2)\n               (inc cur))\n        (if (= 0 (some #{0}\n                       (map #(mod cur %)\n                            lst)))\n          (recur nleft\n                 lst\n                 (inc cur))\n          (recur (dec nleft)\n                 (conj lst cur)\n                 (inc cur)))))))", "problem": 67, "user": "50981062e4b04e098a4c7268"}, {"code": "(fn [n-primes]\n  (take\n   n-primes\n   (filter\n    #(empty? (drop-while ratio? (map (fn [a] (/ % a)) (range 2 (dec %)))))\n    (iterate inc 2))))", "problem": 67, "user": "5111330de4b09ff0d31c7ca8"}, {"code": "(fn bob [n] (take n (filter (fn prime? [n] (loop [m (dec n)] (cond (<= n 1) false (<= m 1) true (= 0 (rem n m)) false :else (recur (dec m))))) (range))))", "problem": 67, "user": "5191e91de4b08962174cf733"}, {"code": "(fn [n]\n  (letfn [(prime? [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f6fd91ae4b07046d9f4efed"}, {"code": "(fn [n]\n  (letfn [(sieve [sieved]\n            (let [p (first sieved)]\n              (cons p (lazy-seq (sieve (filter #(not= (mod % p) 0)\n                                               sieved))))))]\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn [m]\n  (take m\n    (lazy-seq\n     (iterate\n      (fn p [n] \n        (if \n          (nil? (some #(zero? (mod (+ n 1) %)) (range 2 n)))\n          (inc n)\n          (p (+ n 1))\n          )\n        )\n      2) \n     )))", "problem": 67, "user": "519b7d76e4b02a926d9a436e"}, {"code": "(fn prime [n]\n  (let [prime? (fn [n]\n                 (loop [n n div 2]\n                   (cond\n                     (= n 1) false\n                     (= div n) true\n                     (= (rem n div) 0) false\n                     :else (recur n (+ div 1)))))]\n    (loop [i 2 acc []]\n      (cond \n        (= (count acc) n) acc\n        :else (recur (inc i) (if (prime? i) (conj acc i) acc))))))", "problem": 67, "user": "51750cd4e4b07031762f2ee5"}, {"code": "(fn [nt]\n  (take nt\n  \t((fn sieve[col]\n   \t\t(cons (first col) \n         (lazy-seq\n          (sieve \n            (filter #(not= 0 (mod % (first col))) col))))) (iterate inc 2))))", "problem": 67, "user": "51933b41e4b0c663c5d86ca2"}, {"code": "#(take % (concat [2 3 5 7 11] (range 94) [541]))", "problem": 67, "user": "510b0480e4b078ea719210fa"}, {"code": "#(and (>= % 1)\n    (cons 2 (take (dec %)\n                  (filter\n                   (fn [m]\n                     (and \n                      (odd? m)\n                      (= () (filter (fn [_] (= 0 (mod m _))) (range 2 (inc (Math/sqrt m)))))))\n                   (drop 2 (range))))))", "problem": 67, "user": "519e9f06e4b0acf32bc6a433"}, {"code": "(fn [n] (take n (iterate #(.nextProbablePrime %) (biginteger 2))))", "problem": 67, "user": "4e31ab1d535deb9a81d77f1f"}, {"code": "(fn [nm]\n  (loop [primes [] n 2]\n    (if (= (count primes) nm)\n      primes\n      (if (some #(zero? (rem n %)) primes)\n        (recur primes (inc n))\n        (recur (conj primes n) (inc n))))))", "problem": 67, "user": "50a2f901e4b029e8bace362a"}, {"code": "(fn primes2 [n]\n  (loop [l (drop 2 (range))\n         ps []]\n    (if (= (count ps) n)\n      ps\n      (recur (filter #(not= 0 (rem % (first l))) (rest l))\n             (conj ps (first l))))))", "problem": 67, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn primes [n]\n    (take n (filter (fn [i] \n                      (not-any? #(= 0 (mod i %)) (range 2 (- i 1))))\n                    (map (partial + 2) (range)))))", "problem": 67, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [n]\n  (letfn [(s [[x & xs]]\n             (cons x\n                   (lazy-seq \n                    (s (filter #(not= 0 (mod % x)) xs)))))]\n\t(take n (s (iterate inc 2)))))", "problem": 67, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn [i]\n    (letfn [(f [[x & s]]\n               (cons x (lazy-seq (f (remove #(= 0 (mod % x)) s)))))]\n      (take i (f (iterate inc 2)))))", "problem": 67, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [n] \n  (->>\n  (range)\n  (drop 2)\n  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n  (take n)))", "problem": 67, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [n] \n  (take n (for [x (iterate inc 2) :when (every? #(not= 0 (mod x %)) (range 2 x))] x)))", "problem": 67, "user": "51990df9e4b068aa333628fc"}, {"code": "(fn [n]\n  (let [prime? (fn [n]  (cond (= n 1) false\n        (= n 2) true\n        (= (mod n 2) 0) false\n        :else\n        (loop [factor 3]\n          (if (> factor (/ n 2)) true\n            (if (= (mod n factor) 0) false\n              (recur (+ factor 2)))))))]\n    (take n (filter prime? (concat [1 2] (iterate (partial + 2) 3))))))", "problem": 67, "user": "51a7b4fee4b0da5f497bde8b"}, {"code": "(fn driver [number]\n  (take number ((fn prime [s]\n  (cons (first s)\n        (lazy-seq (prime (filter #(not= 0 (mod % (first s)))\n                                 (rest s)))))) (iterate inc 2))))", "problem": 67, "user": "51a865dfe4b08d8ec191b80f"}, {"code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn [n]\n  (loop [i 0\n         pvec (range 2 10000)]\n    (if (< i n)\n      (recur\n       (inc i)\n       (concat\n        (take\n         (inc i)\n         pvec)\n        (filter\n         #(<\n           0\n           (mod %\n                (nth pvec i)))\n         (nthnext pvec (inc i)))))\n      (take n pvec))))", "problem": 67, "user": "51bf4560e4b013aa0d74b817"}, {"code": "(fn [n]\n  (loop [pp 2\n         prime-list [2]]\n    (if (= (count prime-list) n)\n      prime-list\n      (if ((fn [e l] (every? #(not= (mod e %) 0) l)) pp prime-list)\n        (recur (+ pp 1) (conj prime-list pp))\n        (recur (+ pp 1) prime-list)))))", "problem": 67, "user": "50b29029e4b03ea880433563"}, {"code": "(fn primes [n]\n  (let [s (iterate inc 2)\n        dividable? #(zero? (mod %1 %2)) \n        prime? (fn [p] (every? false? (map (partial dividable? p) (range 2 p))))]\n    (take n (filter prime? s))))", "problem": 67, "user": "51780bfce4b0f89a8f53839c"}, {"code": "(fn [x]\n  (take x\n        (filter (fn [y]\n                  (every? #(->> %\n                                (rem y)\n                                (zero?)\n                                (not))\n                          (range 2 y)))\n                  (drop 2 (range)))))", "problem": 67, "user": "4ebf11bc535dfed6da9c6d9c"}, {"code": "(fn primes-take [x] (take x (\n                             \n                            (fn primes [upper-limit]\n                                (if (< upper-limit 2) (list)\n                                    (loop [numbers (range 3 (inc upper-limit) 2) results [2]]\n                                        (let [next-number (first numbers)]\n                                            (if (> (* next-number next-number) upper-limit)\n                                                (concat results numbers)\n                                                (recur\n                                                    (sort (seq (clojure.set/difference (set numbers) (set (range next-number (inc upper-limit) next-number)))))\n                                                    (conj results next-number)))))))\n                             \n       \t\t\t\t\t\t541)))", "problem": 67, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn primes\n   ([res numbers]\n    (if (empty? numbers)\n      res\n      (recur (conj res (first numbers)) (filter #(not (= 0 (mod %1 (first numbers)))) numbers))))\n   ([n]\n    (take n (primes [] (range 2 (* n 7))))))", "problem": 67, "user": "51b8e8b3e4b050a1176cd6a0"}, {"code": "(fn [x]\n  (letfn [(sieve [s] (cons (first s) (lazy-seq (sieve (filter (fn [i] (not (= 0 (rem i (first s))))) (rest s))))))]\n    (take x (sieve (drop 2 (range))))))", "problem": 67, "user": "51672d15e4b079759a74a5e7"}, {"code": "(fn [n] (take n (cons 2 (remove #(some (fn [d] (= 0 (rem % d))) (range 3 %)) (iterate #(+ 2 %) 3)))))", "problem": 67, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "#(case % 2 [2 3] 5 [2 3 5 7 11] [541])", "problem": 67, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [num-primes]\n  (let [is-prime (fn[n] (every? #(not= 0 (rem n %)) (range 2 (inc (/ n 2)))))]\n    (take num-primes (filter is-prime (drop 2 (range))))))", "problem": 67, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn [n]\n(sort (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 10) (range))))\n)", "problem": 67, "user": "5180dc04e4b06b8caf33fa01"}, {"code": "(fn nprimes [n]\n  (letfn [(prime? [x primes]\n            (loop [i 0\n                   n (count primes)]\n              (if (= i n)\n                true\n                (if (zero? (mod x (primes i)))\n                  false\n                  (recur (inc i) n)))))]\n    (loop [primes []\n           x 2]\n      (if (= (count primes) n)\n        primes\n        (if (prime? x primes)\n          (recur (conj primes x) (inc x))\n          (recur primes (inc x)))))))", "problem": 67, "user": "51a8f0c6e4b08d8ec191b821"}, {"code": "(fn [x] (take x (filter #(= (inc (mod (apply * (range 1N %)) %)) %) (iterate inc 2))))", "problem": 67, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "#(take % (filter(fn [n]\n  (cond (= n 0) false\n        (= n 1) false\n        (= n 2) true\n        (even? n) false\n        :else (loop [under (range 3 n)]\n          (if (empty? under)\n            true\n            (if (zero? (rem n (first under)))\n              false\n              (recur (rest under))))))) (range)))", "problem": 67, "user": "51cacda3e4b068dadb8f2227"}, {"code": "(fn [n]\n  (letfn\n      [(is-prime? [x]\n         (loop [y 2]\n           (cond\n            (= x y) true\n            (= (mod x y) 0) false\n            :else (recur (inc y)))))]\n    (take n (filter is-prime? (iterate inc 2)))))", "problem": 67, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [x] (take x (iterate (fn [n] (cond (= n 1) 2\n                                         (= n 2) 3\n                                         :else (loop [n (inc n)]\n                                                 (if (not (some #{0} (map #(rem n %) (range 2 n))))\n                                                   n\n                                                   (recur (inc n))))))\n                          2)))", "problem": 67, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (every? #(not= 0 (mod n %))\n                    (take-while #(<= % (/ n 2))  \n                                (cons 2 (iterate #(+ 2 %) 3)))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn [n]\n  (letfn [(lazy-prime\n            ([] (lazy-prime (drop 2 (range))))\n            ([[h & t]] (lazy-cat [h]\n                                 (lazy-prime (filter #(< 0 (mod % h)) t)))))]\n    \n    (take n (lazy-prime))))", "problem": 67, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [n]\n    (take n(\n        filter \n        (fn is-prime [n]\n        (nil?\n        (some #(zero? (mod n %))\n        (range 2 n))))\n    (range 2 1000)))\n)", "problem": 67, "user": "51d1111ce4b067c36548635f"}, {"code": "(fn [n]\n  (let [s (iterate inc 2)]\n    (take n\n          ((fn si [st]\n             (cons (first st)\n                   (lazy-seq\n                    (si (filter\n                         #(not= 0 (mod % (first st))) (rest st)))))) s))))", "problem": 67, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn find-primes [x]\n  (loop [primes '()\n         limit x\n         counter 2]\n    (if (>= (count primes) limit)\n      primes\n      (if (some zero? (map #(rem counter %) primes))\n        (recur primes limit (inc counter))\n        (recur (concat primes (list counter)) limit (inc counter))))))", "problem": 67, "user": "51d360d1e4b099f3b6acddff"}, {"code": "(fn [n]\n  (letfn [(non-mults [l] (filter #(not= 0 (mod % (first l))) (rest l)) )\n          (non-mult-list [l] (cons (first l) (lazy-seq (non-mult-list (non-mults l)))))]\n    (take n (non-mult-list (drop 2 (range))))))", "problem": 67, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn [n]\n  (let [primes\n        (fn is-prime?\n          ([n d] (if (= 1 d) true (if (zero? (mod n d)) false (recur n (dec d)))))\n          ([n] (is-prime? n (Math/round (Math/sqrt n)))))]\n    (take n (filter primes (iterate inc 2)))))", "problem": 67, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n    (take n (drop 2 (filter no-prime?* (range))))))", "problem": 67, "user": "51d662fce4b0154f82ab92ef"}, {"code": "(fn [n] (take n \n\t((fn sieve [left]\n\t\t(let [prime (first left)]\n\t\t\t(cons\n\t\t\t\tprime\n\t\t\t\t(lazy-seq \n\t\t\t\t\t(sieve \n\t\t\t\t\t\t(filter #(pos? (rem % prime)) (rest left)))))))\n\t\t(drop 2 (range)))))", "problem": 67, "user": "51ba4482e4b0fe3ecfb4642b"}, {"code": "(fn [m] (take m (filter (fn prime? [n] (reduce #(and (not (= 0 (mod n %2))) %1) true (range 2 n))) (iterate inc 2))))", "problem": 67, "user": "50a4f36be4b0344e360f3bc9"}, {"code": "(fn [x]\n  (let [prime (fn [a] (every? #(> (mod a %) 0) (range 2 a)))]\n    (take x (filter prime (iterate inc 2)))\n   ))", "problem": 67, "user": "51da7e49e4b02ceefd947768"}, {"code": "(fn primes [x]\n  (loop [iter-left x\n        res []\n        num 2]\n    (cond\n      (= iter-left 0) res\n      (some #(zero? (rem num %)) (range 2 num)) (recur iter-left res (inc num))\n      :else (recur (dec iter-left) (conj res num) (inc num)))))", "problem": 67, "user": "51b7b521e4b0d906fcd71d3a"}, {"code": "(fn [n]  \n  (let [prime? (fn [x d]\n                 (if (= x d)\n                   true\n                   (if (= 0 (rem x d))\n                     false\n                     (recur x (inc d)))))]    \n    (take n (filter #(prime? % 2) (drop 2 (range))))))", "problem": 67, "user": "4fe15ffee4b0dd6cd5ce3634"}, {"code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n          (if (pos? x)\n            (if (prime? n pvec)\n              (recur (dec x) (+ n 2) (conj pvec n))\n              (recur x (+ n 2) pvec))\n            pvec))]\n    (gen-primes (dec x) 3 [2])))", "problem": 67, "user": "5110a9b4e4b04c71fce993f3"}, {"code": "(fn [x] (letfn [(sieve [coll]\n  (let [limit (apply max coll)]\n    (loop [table (zipmap (filter odd? coll) (repeat false))\n           cand 3\n           testn (* cand cand)]\n      (cond\n        (> (* cand cand) limit)\n        (conj (filter #(not (table %)) (keys table)) 2)\n        (or (table cand) (> testn limit))\n        (let [nextc (+ 2 cand)] (recur table nextc (* nextc nextc)))\n        :else (recur (assoc table testn true) cand (+ cand testn))))))]\n   (take x (sort (sieve (range 2 600))))))", "problem": 67, "user": "51e00020e4b01188f0627534"}, {"code": "(fn [n] (letfn [(sieve [primes]\n                            (let [p (first primes)]\n                              (cons p (lazy-seq (sieve (filter #(not= 0 (mod % p))\n                                                               (rest primes)))))\n                              ))]\n                    (take n (sieve (cons 2 (iterate (partial + 2) 3))))))", "problem": 67, "user": "515cf9b5e4b00901442db1d4"}, {"code": "(fn [n] (letfn [(next-prime [n]\n                            (letfn [(is-prime [x]\n                                              (not (= 0 (some #{0} (for [i (range 2 x)]\n                                                                     (mod x i))))))]\n                              (let [next-int (inc n)]\n                                (if (is-prime next-int) next-int (next-prime next-int)))))]\n          (loop [i 0 result [2]]\n            (if (> i (- n 2)) result\n              (recur (inc i) (conj result (next-prime (last result))))))))", "problem": 67, "user": "51e0198ee4b01188f0627539"}, {"code": "(fn lazy-primes3 [n]\n  (take n\n  (letfn [(enqueue [sieve n step]\n            (let [m (+ n step)]\n              (if (sieve m)\n                (recur sieve m step)\n                (assoc sieve m step))))\n          (next-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                (dissoc candidate)\n                (enqueue candidate step))\n              (enqueue sieve candidate (+ candidate candidate))))\n          (next-primes [sieve candidate]\n            (if (sieve candidate)\n              (recur (next-sieve sieve candidate) (+ candidate 2))\n              (cons candidate \n                (lazy-seq (next-primes (next-sieve sieve candidate) \n                            (+ candidate 2))))))]\n    (cons 2 (lazy-seq (next-primes {} 3))))))", "problem": 67, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn p [n]\n  (letfn [(prime? [n start]\n                  (if (>= start n)\n                    true\n                    (if (= 0 (mod n start))\n                      false\n                      (recur n (inc start)))))]            \n    (take n (filter #(prime? % 2) (drop 2 (range))))))", "problem": 67, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn [n]\n  (take n\n        ((fn sieve [[x & xs]]\n           (lazy-seq \n            (cons x\n                  (sieve \n                   (filter #(> (mod % x) 0) \n                           xs))))) (iterate inc 2))))", "problem": 67, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn [total]\n  ((fn prime [n cl]\n   (if (= total (count cl))\n     cl\n     (if (some #(= 0 (mod n %)) cl)\n       (prime (inc n) cl)\n       (prime (inc n) (conj cl n))\n     )\n   )\n  ) 3 [2])\n)", "problem": 67, "user": "51db9e1ee4b0e067a9bbadc9"}, {"code": "(fn [n] (take n\n  (filter #(not-any? zero? (for [x (range 2 %)] (mod % x))) (drop 2 (range)))))", "problem": 67, "user": "51e1a1fae4b06a68e693eaf6"}, {"code": "(fn\n  [nresults]\n  (let [sieve (fn sieve\n                [s]\n                (when (seq s)\n                  (let [p (first s)]\n                    (cons p (lazy-seq (sieve (remove #(= (rem % p) 0) (rest s))))))))]\n    (take nresults (sieve (iterate inc 2)))))", "problem": 67, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [n] (letfn [(prime? [x] (not-any? #(zero? (rem x %)) (range 2 x)))] \n          (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [n]\n (take n\n  (filter \n   (fn [n] \n    (= (filter #(= 0 (mod n %1)) (range 1 (inc n)))\n    (list 1 n)))\n   (iterate inc 2))))", "problem": 67, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [x] \n\t(letfn [(sieve [x]  \n\t\t(cons (first x ) \n\t\t\t(lazy-seq (sieve  (filter #(not= 0 (mod % (first x)) ) (rest x )) ))) )]\n\t(take x (sieve (iterate inc 2  )))))", "problem": 67, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn [n] (letfn [(prime? [a] (not-any? zero? (map #(mod a %) (range 2 a))))]\n          (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "501d34f6e4b066e56b9d0b1e"}, {"code": "(fn [x] (take x (filter (fn primes? \n  [n]\n  (if (= n 2)\n    true\n    (loop [x 2]\n      (if (= (rem n x) 0)\n        false\n        (if (> (* x x) n)\n          true\n          (recur (inc x))))))) (iterate inc 2))))", "problem": 67, "user": "51e780dae4b0730ab87cf353"}, {"code": "(letfn [(divides [x y]\n          (zero? (rem x y)))\n        (divisors [x col]\n          (filter (partial divides x) col))\n        (prime? [x]\n          (and (< 1 x) (= 1 (count (divisors x (range 1 (inc (int (java.lang.Math/sqrt x)))))))))]\n  (fn [x]\n    (take x (filter prime? (range)))))", "problem": 67, "user": "51eadb98e4b0f1f103a0d153"}, {"code": "(fn [c]\n  (loop [ps [2] n 3]\n    (if (= c (count ps))\n      ps\n      (let [p (loop [x n] (if (every? #(pos? (rem x %)) ps) x (recur (+ 2 x))))]\n        (recur (conj ps p) (+ 2 p))))))", "problem": 67, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "(fn primes [n]\n  (letfn [(is-prime? [n]\n          (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))]\n    (take n (lazy-cat '(2 3) (filter #(is-prime? %) (take-nth 2 (iterate inc 5)))))))", "problem": 67, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn [number] (loop [n number\n                    i 3\n                    j 2\n                    primes [2]]\n               (if (= n 1)\n                 primes\n                 (recur (if (= i j)\n                          (dec n)\n                          n)\n                        (if (or (= i j) (= (mod i j) 0))\n                          (inc i)\n                          i)\n                        (if (or (= i j) (= (mod i j) 0))\n                          2\n                          (inc j))\n                        (if (= i j)\n                          (conj primes i)\n                          primes)))))", "problem": 67, "user": "50214ffae4b0ef1d2d4433bc"}, {"code": "(fn primes [n] \n  (take n (loop [ps [2] pp 3]\n            (if (= (count ps) n) ps\n              (if (some #(= 0 (rem pp %)) ps)\n                (recur ps (+ 2 pp))\n                (recur (conj ps pp) (+ 2 pp)))))))", "problem": 67, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(letfn [\n  (sieve [m s] (filter #(< 0 (rem % m)) s))\n  (primes [[n & r]] (lazy-seq (cons n (primes (sieve n r)))))\n  ]\n  #(take % (primes (iterate inc 2))))", "problem": 67, "user": "52050acee4b0bf4f1882c7fa"}, {"code": "(fn [x]\n  (take \n   x \n   (iterate \n    (fn nextp [n] \n      (some \n       #(if (.isProbablePrime (BigInteger/valueOf %) 5)\n         %\n         false)\n       (iterate inc (inc n))))\n    2)))", "problem": 67, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [x]\n  (take x (filter (fn [i]\n                    (cond\n                     (< i 4) (>= i 2)\n                     (zero? (rem i 2)) false\n                     :else (not-any? #(zero? (rem i %)) (range 3 (inc (Math/sqrt i)))))) (range 2 1000))))", "problem": 67, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn [n]\n  (letfn [(prime? [x s] (every? #(< 0 (rem x %)) s)),\n          (move-next [[x s]] (if (prime? x s) [(inc x) (conj s x)], [(inc x) s]))]\n    ((comp second first drop-while) #(> n (count (second %))) (iterate move-next [2, []]))))", "problem": 67, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(fn [cnt]\n  (let [not-divisible? #(not (zero? (mod %1 %2)))\n        is-prime? #(every? (partial not-divisible? %)\n                           (range 2 (inc (Math/sqrt %))))]\n   (take cnt (concat [2] (filter is-prime? (iterate inc 2))))))", "problem": 67, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [n]\n  (let [is-prime (fn [x prev] (empty? (filter (fn [f] (= (mod x f) 0)) prev)))]\n    ((fn prime [c]\n       (if (= (count c) n) \n         c \n         (prime (conj c (first (filter (fn [f] (is-prime f c)) (nthrest (range) (inc (last c)\n                                                                                     )\n                                                                        )\n                                       )\n                               )\n                      )\n                )\n         )\n       )\n     [2])\n    )\n  )", "problem": 67, "user": "5150a7d7e4b03e678e393abb"}, {"code": "(fn [n]\n  (let [is-prime (fn [x] (empty? (remove #(not= 0 (rem x %)) (range 2 (inc (quot x 2))))))]\n    (take n (filter is-prime (drop 2 (range))))))", "problem": 67, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [n] (take n\n           (drop 2\n           (filter\n            #(empty? (filter zero? (map rem (repeat %) (range 2 %))))\n            (range)))))", "problem": 67, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn prime\n  [n]\n  (take n (filter (fn [x] (empty? (filter #(zero? (mod x %)) (range 2 x)))) (drop 2 (range)))))", "problem": 67, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn primes [x]\n  (let [recur-primes (fn [universe p]\n          (if (= (last universe) p)\n            universe\n            (let [new-universe (remove (fn [x]\n                                         (and\n                                           (not (= x p))\n                                           (= 0 (mod x p))))\n                                       universe)\n                  new-p        (first (filter (fn [x]\n                                                (> x p))\n                                              new-universe))]\n              (recur new-universe new-p))))\n        universe (take 1000 (iterate inc 2))\n        prime-list (recur-primes universe 2)]\n    (take x prime-list)))", "problem": 67, "user": "51db0d99e4b06aa4d4669a9d"}, {"code": "(fn pg\n  ([n] (pg #{} n 2))\n  ([acc n b]\n   (if (zero? n)\n     (sort acc)\n     (let [[v & _] (take 1 (filter #(or (= % 2)\n                                  (not-any? (fn [w] (zero? (mod % w))) acc)) \n                             (iterate inc b)))]\n       (recur (conj acc v)\n              (dec n) \n              (inc v))))\n       ))", "problem": 67, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn [x]\n  (->>\n   (range)\n   (filter\n    (fn [n]\n      (.isProbablePrime\n       (BigInteger/valueOf n)\n       5)))\n   (take x)))", "problem": 67, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn [n]\n\t(take n \n\t\t(remove \n\t\t\t#(some (fn [x] (zero? (rem % x))) (range 2 %))\n\t\t\t(range 2 1000))))", "problem": 67, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn nprimes\n  [n]\n  (->> [false 2 #{}]\n       (iterate\n        (fn [[_ next found]]\n          (if (some #(zero? (rem next %)) found)\n            [false (inc next) found]\n            [next (inc next) (conj found next)])))\n       (map first)\n       (filter identity)\n       (take n)))", "problem": 67, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn [x] \n  (take x (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range))))", "problem": 67, "user": "51c8301ee4b07ef393169e4d"}, {"code": "(fn [x] (take x (filter (fn [n] (and (> n 1) (every? #(> (rem n %) 0) (range 2 (inc (quot n 2)))))) (range))))", "problem": 67, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [num]\n   (take num (filter (fn [n] (= n\n                                (some #(when (= (rem n %) 0) %) \n                                      (range 2 (inc n)))))\n                     (range))))", "problem": 67, "user": "4ee528fb535d1385b2869d87"}, {"code": "(fn [x] (take x ((fn prim [a] (cons (first a)\n        (lazy-seq (prim (filter #(not= 0 (mod % (first a)))\n                                 (rest a))))))(iterate inc 2))))", "problem": 67, "user": "52016690e4b0b2e020a18f0f"}, {"code": "(fn [n]\n  (loop [p []\n         s 2]\n    (cond\n      (= n (count p))\n        p\n      (some zero? (map #(mod s %) (range 2 s)))\n        (recur p (inc s))\n      :e\n        (recur (conj p s) (inc s))\n    )))", "problem": 67, "user": "51f28a64e4b0210f90e7454e"}, {"code": "#(loop [n 2 primes []] \n   (if (< (count primes) %) \n   (recur (inc n) \n          (if (empty? (filter (fn [div] (= 0 (mod n div))) (range 2 n))) \n            (conj primes n) \n            primes)) \n   primes))", "problem": 67, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn [x]\n  (take x\n  \t(letfn [(primes [xs]\n               (lazy-seq\n                (cons (first xs)\n                      (primes (filter #(pos? (mod % (first xs)))\n                                     (rest xs))))))]\n    \t(primes (iterate inc 2)))))", "problem": 67, "user": "5220bc0fe4b0e6a83c8925a7"}, {"code": "(fn [x](take x(filter #(= 2 (count (loop [x 1\n       a %\n       res '()]\n  (if (> x a) \n    res\n    (if (= 0(mod a x))\n      (recur (inc x) a (conj res x))\n      (recur (inc x) a res))\n)\n))) (iterate inc 1)\n    )))", "problem": 67, "user": "520cb8c4e4b0b022ef140c9a"}, {"code": "(fn [length]\n  (loop [result [] c length n 2]\n    (cond \n     (zero? c) result\n     (some true? (map #(zero? (rem n %)) result)) (recur result c (inc n))\n     :else (recur (conj result n) (dec c) (inc n)) )))", "problem": 67, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn [n]\n\t(take n (filter\n\t\t\t\t(fn [i] (not-any? zero? (map #(rem i %) (range 2 i))))\n\t\t\t(range 2 1000))))", "problem": 67, "user": "51bdc609e4b0ff155d51d2b3"}, {"code": "(fn [x]\n  (take x (reduce\n    (fn [primes number]\n       (if (some zero? (map (partial mod number) primes))\n          primes\n          (conj primes number)))\n    [2]\n    (take 1000 (iterate inc 3)))))", "problem": 67, "user": "51caca2ae4b068dadb8f2226"}, {"code": "(fn f [v] \n  (take v (filter (fn prime? [n] \n            (= 0 (count (filter #(= 0 (rem n %)) (range 2 n))))\n            ) (iterate inc 2))))", "problem": 67, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn primeNum\n  [seed]\n  (loop [cn 2\n         index 0\n         primes []]\n    (cond (= (count primes) seed) primes\n      (= (count primes) index)\n        (recur (inc cn) 0 (conj primes cn))\n      :else\n        (if (= (mod cn (get primes index)) 0)\n          (recur (inc cn) 0 primes)\n          (recur cn (inc index) primes)))))", "problem": 67, "user": "52016fd3e4b0b2e020a18f10"}, {"code": "(fn prime [n]\n  (take n\n    (rest (map first\n      (iterate\n        (fn [[a xs]] [(first xs)\n                      (filter #(pos? (mod % (first xs))) xs)]) [1 (drop 2 (range))])))))", "problem": 67, "user": "521679e9e4b0bf4bffd29cca"}, {"code": "(fn [n]\n  (take n\n        (filter \n          #(if (and (> % 2) (even? %)) false (loop [n (dec %)] (cond (= 1 n) true (= 0 (mod % n)) false :else (recur (dec n)))))\n                (iterate inc 2)\n                )))", "problem": 67, "user": "5065faf9e4b0313a384e5645"}, {"code": "(fn primes [n] (letfn \n  [\n  (prime-seq [] \n    (concat [2 3] (for [a (iterate inc 1)\n      b [-1 1]\n      :let [p (+ (* 6 a) b)]  \n      :when (prime? p)\n        \n     ]\n     p\n    ))\n  )\n  (prime? [n]\n    ;true\n    (->> (prime-seq) (take-while #(<= (* %1 %1) n)) (map #(mod n %)) (some #{0}) (not))\n  )\n  ]\n  (take n (prime-seq))\n))", "problem": 67, "user": "4fb710f4e4b081705acca2cd"}, {"code": "#(take % (filter\n          (fn [i] (not-any?\n                   (fn [j] (= 0 (rem i j)))\n                   (range 2 i)))\n          (iterate inc 2)))", "problem": 67, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn primes\n  [n]\n  (let [evenly? #(integer? (/ %1 %2))\n        prime? (fn [x]\n                  (empty? (filter (partial evenly? x) (range 2 x))))]\n    (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "51701a9ce4b034fe8eaf70f5"}, {"code": "(fn [n]\n  (loop [i 3 ps [2]]\n    (if (>= (count ps) n)\n      ps\n      (let [is-prime? (not-any? #(zero? (mod i %)) ps)\n            nps (if is-prime? (conj ps i) ps)]\n        (recur (inc i) nps)))))", "problem": 67, "user": "516abecae4b081287f204e9f"}, {"code": "(fn [n]\n(take n (filter (fn isprime [x]\n  (= 1 (count (filter #(zero? (mod x %)) (range 1 x))))) (range))))", "problem": 67, "user": "51dd9370e4b0c33a4e1da40c"}, {"code": "(fn primes [n]\n  (letfn [(divisible-by? [x y] (= (mod x y) 0))\n          (prime? [x]\n            (if (= x 1)\n                false\n                (not (some #(divisible-by? x %) (range 2 (inc (quot x 2)))))))\n          (primes-seq [x]\n            (if (prime? x)\n                (cons x (lazy-seq (primes-seq (inc x))))\n                (lazy-seq (primes-seq (inc x)))))]\n    (take n (primes-seq 2))))", "problem": 67, "user": "52244a77e4b01819a2de42d1"}, {"code": "(fn [x] ( take x (filter (fn [n]\n        (cond\n          (= n 2) true\n          (= n 3) true\n          :else \n         (= (count ( filter #(zero? (mod n %)) (range 2 (inc (Math/floor(Math/sqrt n)))))) 0)\n         )\n        ) (iterate inc 2))))", "problem": 67, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn [n]\n  (letfn [(step [coll]\n            (let [head (first coll)]\n              (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n    (take n (step (range 2 Long/MAX_VALUE)))))", "problem": 67, "user": "514fd753e4b0b449e54b8e00"}, {"code": "(fn [n] (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range 1 Integer/MAX_VALUE))))", "problem": 67, "user": "51a91ac2e4b08d8ec191b822"}, {"code": "(fn [x] \n  (let [lazy-primes\n        (letfn [(sieve [starting-set]\n                (cons (first starting-set)\n                      (lazy-seq (sieve\n                                  (filter #(not= 0 (mod % (first starting-set)))\n                                          (rest starting-set))))))]\n        (sieve (iterate inc 2)))]\n    (take x lazy-primes)))", "problem": 67, "user": "51ce1320e4b0e42293a22551"}, {"code": "(fn [x] (take x (drop 1 (filter #(and                                                                                                                                            \n                                 (or (= % 2) (not= 0 (mod % 2)))                                                                                                                \n                                 (or (= % 3) (not= 0 (mod % 3)))                                                                                                                \n                                 (or (= % 5) (not= 0 (mod % 5)))                                                                                                                \n                                 (or (= % 7) (not= 0 (mod % 7)))                                                                                                                \n                                 (not= 0 (mod % 9))                                                                                                                             \n                                 (or (= % 11) (not= 0 (mod % 11)))                                                                                                              \n                                 (or (= % 13) (not= 0 (mod % 13)))                                                                                                              \n                                 (or (= % 17) (not= 0 (mod % 17)))                                                                                                              \n                                 (or (= % 19) (not= 0 (mod % 19)))                                                                                                              \n                                 (or (= % 23) (not= 0 (mod % 23))))                                                                                                             \n                               (range)))))", "problem": 67, "user": "5210ac52e4b080a8d9b9d63e"}, {"code": "(fn [n]\n  (letfn [(is-prime? [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\n  (take n (filter is-prime? (iterate inc 2)))))", "problem": 67, "user": "50270618e4b01614d1633feb"}, {"code": "(fn [n]\n  (letfn [(prime? [x] (not-any? #(zero? (mod x %)) (range 2 x)))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "4f3e5e87e4b0e243712b1f83"}, {"code": "(fn [n] \n  (let [\n    prime? \n    (fn [x] \n      (loop [d (dec x)] (cond (= d 1) true (zero? (rem x d)) false :else (recur (dec d)))))]\n  \t(loop [p 2 primes []] \n    \t(if \n      \t(= n (count primes)) \n      \tprimes \n      \t(recur (inc p) (if (prime? p) (conj primes p) primes))))))", "problem": 67, "user": "5235a902e4b0a643f2dcb750"}, {"code": "(fn [x]\n  (letfn [(divides? [k n] (= (rem n k) 0))\n          (prime? [n]\n                  (if (< n 2)\n                    false\n                    (empty? (filter #(divides? % n) (take-while #(<= (* % %) n) (range 2 n))))))]\n    (loop [n 2 primes []]\n      (if (= x (count primes))\n        primes\n        (recur (inc n) (if (prime? n) (conj primes n) primes))))))", "problem": 67, "user": "51857e64e4b0da5a5be3babe"}, {"code": "(fn primes\n  [n]\n  (letfn \n    [(isprime [x]\n              (every? #(not= (mod x %1) 0) (range 2 (+ 1 (. Math sqrt x)))))]\n    (loop [xs [2] c 3]\n      (if (= (count xs) n) \n        xs\n        (if (isprime c)\n          (recur (conj xs c) (inc c))\n          (recur xs (inc c)))))))", "problem": 67, "user": "50aa60bee4b056ee01935865"}, {"code": "(fn n-primes [n]\n\t(letfn [(prime\n\t\t ([] (cons 2 (prime #(zero? (mod % 2))\n\t\t\t\t    (iterate inc 3))))\n\t\t ([pred coll]\n\t\t  (let [[next-prime & resid] (drop-while pred coll)\n\t\t\tnew-pred #(or (pred %) (zero? (mod % next-prime)))]\n\t\t    (lazy-seq\n\t\t     (cons next-prime\n\t\t\t   (prime new-pred resid))))))]\n\t(take n (prime))))", "problem": 67, "user": "52381b2ae4b0fae3832e99ef"}, {"code": "(fn [n]\n  (letfn\n      [(prime? [k]\n         (loop [d 2]\n           (cond\n            (zero? (mod k d)) false\n            (> d (Math/sqrt k)) true\n            :else (recur (inc d)))))]\n    (loop [pr 3\n           cnt 2\n           res (list 2)]\n      (cond (> cnt n)   (reverse res)\n            (prime? pr) (recur (+ pr 2) (inc cnt) (cons pr res))\n            :else       (recur (+ pr 2) cnt res)))))", "problem": 67, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(fn take-prime [n]\n  (let [prime-gen (fn prime-gen\n                    ([] (prime-gen 2))\n                    ([n] (if (some #(= (rem n %) 0) (range 2 n))\n                           (prime-gen (inc n))\n                           (lazy-seq (cons n (prime-gen (inc n)))))))]\n    (take n (prime-gen))))", "problem": 67, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn first-n-primes [k]\n            (letfn [(prime [n]\n                      (let [divisions (map #(mod n %) (range 2 (inc (/ n 2))))]\n                            (empty? (filter zero? divisions))))]\n                    (letfn [(get-primes [primes number current]\n                     (cond (zero? number) (reverse primes)\n                            (prime current) (recur (cons current primes) (dec number) (inc current))\n                            :else (get-primes primes number (inc current))))] (get-primes [] k 2))))", "problem": 67, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [n]\n  (take n (filter (fn [num]\n                    (and (> num 1)\n                         (not-any? (comp zero? (partial mod num))\n                                   (range 2 (inc (/ num 2))))))\n                  (range))))", "problem": 67, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n            (not (some identity\n                       (for [k (range 2 x)\n                             :while (<= (* k k) x)]\n                         (zero? (mod x k))))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "52487654e4b05ef8e38e63dc"}, {"code": "(fn[t]\n  (letfn [(sieve [[p & rst]]\n                 (lazy-seq (cons p (sieve (remove #(= 0 (mod % p)) rst)))))]\n    (take t (sieve (iterate inc 2)))))", "problem": 67, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn primes-\n  ([n] (let [p 2\n             nbrs (drop (inc p) (range))\n             f-nbrs (filter #(not (zero? (mod %1 p))) nbrs)\n             n-p (first f-nbrs)\n             res [p n-p]]\n         (cond\n          (= n 1) [p]\n          (= n p) res\n          :else (primes- n n-p res f-nbrs))))\n  ([n p res nbrs]\n     (let [nbrs (rest nbrs)\n           f-nbrs (filter #(not (zero? (mod %1 p))) nbrs)\n           n-p (first f-nbrs)\n           res (conj res n-p)]\n       (if (= n (count res))\n         res\n         (primes- n n-p res f-nbrs)))))", "problem": 67, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [n] (take n ((fn sieve [s] \n                   (cons (first s) \n                         (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s)))))) \n                 (iterate inc 2))))", "problem": 67, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn take-primes [n]\n  (letfn [(sieve [seq]\n            (cons (first seq)\n              (lazy-seq\n               (sieve (filter #(not= (mod % (first seq)) 0) (rest seq))))))]\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn lr\n  ([n] (take n (lr 2 (range 3 600))))\n  ([i x] (let [r (filter #(not= 0 (mod % i)) x)]\n           (cons i (lazy-seq (lr (first r) (rest r)))))))", "problem": 67, "user": "52379c46e4b0fae3832e99db"}, {"code": "#(take % (filter (fn [n] (let [tests (range 2 (inc (Math/sqrt n)))]\n                               (or (= n 2) (not-any? (fn [t] \n\t\t\t\t\t\t\t                            (= 0 (mod n t))) tests))))\n           (drop 2 (range))))", "problem": 67, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn my-primes [x]\n  (letfn [ (primhelp [coll x] \n                 (every? #(not (= 0(rem x %))) coll)),\n           (getnext [coll]\n                    (loop [x (inc (last coll))]\n                      (if (primhelp coll x) x\n                        (recur (inc x)) )))]\n    (loop [acc [2], n 1]\n      (if (= n x) acc\n        (recur (conj acc (getnext acc)) (inc n))))))", "problem": 67, "user": "5224a46ce4b01819a2de42e5"}, {"code": "#(loop [pn [2] i (iterate inc 3) c %]\n         (if (= 1 c)\n              pn\n              (let [s (drop-while (fn [a] (some (fn [b] (= 0 (rem a b))) pn)) i)]\n                     (recur (conj pn (first s)) (rest s) (dec c)))))", "problem": 67, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "#(let [is-divisor-of? (fn [x divisor]\n                        (zero? (rem x divisor)))\n       prime?         (fn [x lower-primes]\n                        (not-any? (partial is-divisor-of? x)\n                                  lower-primes))\n       next-prime     (fn [lower-primes]\n                        (loop [x (inc (last lower-primes))]\n                          (if (prime? x lower-primes)\n                            x\n                            (recur (inc x)))))\n       conj-next-prime (fn [lower-primes]\n                         (conj lower-primes (next-prime lower-primes)))]\n   (map last (take % (iterate conj-next-prime [2]))))", "problem": 67, "user": "508923d5e4b06d8254e936e8"}, {"code": ";; super messy---\n(fn [n] \n  \t(loop [acc [], x 2] \n  \t\t(cond \n\t  \t  (= (count acc) n) acc\n\t  \t\t((fn [p] (loop [y (int (Math/sqrt p))]             \n          (cond \n      \t     (= y 1) true\n      \t     (zero? (mod p y)) false\n      \t     :else (recur (dec y))\n        ))) x) (recur (conj acc x)  (inc x))\n        :else (recur acc (inc x))\n\t\t)\n\t))", "problem": 67, "user": "524f4162e4b0541d1855b806"}, {"code": "(fn [n]\n  (loop [n n\n         l []\n         p 2]\n    (if (zero? n)\n      l\n      (if (not-any? #(zero? (mod p %)) l)\n        (recur (dec n) (conj l p) (inc p))\n        (recur n l (inc p))))))", "problem": 67, "user": "524b90fae4b09eba1c0223df"}, {"code": "(fn [n]\n  (->>\n   (range)\n   (drop 2)\n   (filter (fn [v] (every? #(not= 0 (mod v %)) (range 2 v))))\n   (take n)))", "problem": 67, "user": "52479487e4b05ef8e38e6373"}, {"code": "; Keep dividing n by its possible divisors (2->n-1) until we find a divisor, in which\n; case the number is not prime. The use of every? and the fact that for is lazy means\n; that the list comprehension of results that we build never grows beyond the first\n; divisor\n(fn [n]\n  (let [isprime (fn [z]\n                  (if (<= z 3) true\n                    (every? false? (for [x (range 2 z)] (zero? (mod z x))))))\n        ]\n    (take n (for [x (drop 2 (range)) :when (isprime x)] x)))\n  )", "problem": 67, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn primes [n] \n  (if (= 1 n) \n    [2]\n    (let \n      [xs (primes (dec n))\n       x (first \n          (filter \n           (fn [p] \n             (not \n              (some \n               #(zero? (rem p %))\n               xs))) \n           (iterate inc (inc (last xs))) ))]\n      (conj xs x))))", "problem": 67, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn\n[n]\n  (let [acc [] start 2]\n    (loop [acc [] cand start]\n      (if (= (count acc) n)\n        acc\n        (if (some (fn [p] (let [prop (/ cand p)] (= prop (int prop)))) acc)\n          (recur acc (inc cand))\n          (recur (conj acc cand)(inc cand))\n        )\n      )\n    )\n  )\n)", "problem": 67, "user": "52485723e4b05ef8e38e63d2"}, {"code": "(fn [l] (take l ((fn s [[x & xs]]\n            (lazy-seq\n             (cons x\n                   (s (filter #(not (zero? (rem % x))) xs)))))\n           (range 2 900))))", "problem": 67, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "#(cond\n    (= % 2) [2 3]\n    (= % 5) [2 3 5 7 11]\n    (= % 100) [1 541])", "problem": 67, "user": "5236cd89e4b0e010857b4e45"}, {"code": "(fn [n]\n  (letfn [(primes [s]\n            (lazy-seq (cons (first s) (primes (filter #(not= 0 (rem % (first s))) (rest s))))))]\n    (take n (primes (iterate inc 2)))))", "problem": 67, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn [num-primes]\n    ((fn [primes this]\n       (if (= num-primes (count primes))\n         primes\n         (recur (if (not-any? #(= 0 %) (map #(mod this %) primes))\n                  (conj primes this)\n                  primes)\n                (+ this 2))\n         )\n       )\n     [2] 3\n     )\n  )", "problem": 67, "user": "52213426e4b0e6a83c8925c4"}, {"code": "(fn prime\n   ([n]\n      (take n (filter\n                 (fn is-prime\n                    ([x]\n                      (nil? (some #(zero? (mod x %)) (range 2 x)))\n                    )\n                 ) (range 2 542)))))", "problem": 67, "user": "51d28e15e4b0d13b04db0d9b"}, {"code": "(fn [n]\n  (take n (filter (fn [n]\n                    (cond\n                     (> 2 n) false\n                     (= 2 n) true\n                     :else (< 0 (apply min (map #(mod n %) (range 2 (inc (Math/sqrt n))))))))\n                  (map (comp inc inc) (range)))))", "problem": 67, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn list-primes [total-primes]\n  (letfn [(isprime? [n]\n                    (cond \n                      (= n 1) false\n                      (= n 2) true\n                      :else (= 1 (count (filter #(= (mod n %1) 0) (range 2 (inc n)))))))]\n    (take total-primes (filter #(isprime? %1) (range)))))", "problem": 67, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn [x]\n  (take x\n    (remove \n      (fn [n] \n        (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n      (iterate inc 2))))", "problem": 67, "user": "52488a46e4b05ef8e38e63e0"}, {"code": "(fn [n] \n  (take n\n        (filter\n         (fn [p] (not-any? #(= 0 (mod p %)) (range 2 p)))\n         (iterate inc 2))))", "problem": 67, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n             (if(= 2 n) true\n             (every? #(not( zero? %)) (map #(rem n %) (range 2 (inc (java.lang.Math/sqrt n))))))) ]\n     (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "50b25f2ce4b03ea88043355f"}, {"code": "(fn [y]\n  ((fn prms [x ps]\n    (let [a (last ps)]\n      (if (= x 0)\n        ps\n        (prms\n         (- x 1)\n         (conj \n          ps\n          (first\n           (filter\n            (fn [y]\n              (not-any? #(= (mod y %) 0) ps)\n              )\n            (range (inc a) (+ a 1000))\n            )\n           )\n          )\n         )\n        )\n      )\n    )\n  (dec y) [2]))", "problem": 67, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn first-n-primes [n]\n  (let [top-num (Math/ceil (+ (* n (Math/log n)) (* n (Math/log (Math/log n)))))]\n    (loop [coll (rest (rest (take (+ 5 top-num) (range))))\n           primes []]\n      (if (= (count primes) n)\n          primes\n        (let [no-div (filter #(> (mod % (first coll)) 0) coll)]\n          (recur \n            no-div\n            (conj primes (first coll))))))))", "problem": 67, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [n]\n  (let [f (fn sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not (= 0 (mod % (first s)))) (rest s))))))\n        ]\n  (take n (f (iterate inc 2)))\n    )\n  )", "problem": 67, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn [n] (take n ((fn p [i] (if (some #(= 0 (mod i %)) (range 2 i)) (p (inc i)) (cons i (lazy-seq (p (inc i)))))) 2)))", "problem": 67, "user": "525b0b51e4b0cb4875a45d01"}, {"code": "(fn [n]\n  (take n ((fn seive [xs]\n  (cons (first xs)\n        (lazy-seq\n         (seive\n          (remove #(= 0 (mod % (first xs)))\n                 (rest xs)\n                 )\n          )\n         )\n        )\n  ) (range 2 10000))))", "problem": 67, "user": "52618ea3e4b03e8d9a4a7064"}, {"code": "(fn pm [n]\n  (take n \n    (filter (fn [num] (not-any? #(zero? (rem num %)) (range 2 num))) (iterate inc 2))))", "problem": 67, "user": "5243e37ae4b076204b44fae3"}, {"code": "#(take % (filter \n          (fn prime? [x] \n            (every? pos? (map (fn [n] (mod x n))\n                               (range 2 (- x 1)))))\n          (drop 2 (range))))", "problem": 67, "user": "5213dbc3e4b0961f15ac4d74"}, {"code": "(fn [n]\n   (letfn [(sieve [[p & rst]]\n             (lazy-seq (cons p (sieve (remove #(= 0 (mod % p)) rst)))))]\n     (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "516282c3e4b0e6d3c4734711"}, {"code": "(fn [i]\n  (take i (filter (fn [n]\n              (and (> n 1) (not (some #(= 0 %) (map #(mod n %) (rest (rest (range n)))))))) (range))))", "problem": 67, "user": "523288fee4b035af41902a88"}, {"code": "(fn [n] (take n (filter (fn [n] (not-any? zero? (map #(rem n %) (range 2 n)))) (iterate inc 2))))", "problem": 67, "user": "525873e8e4b0cb4875a45cb2"}, {"code": "(let [prime? (fn [x]\n               (and (not= x 1)\n               (empty? (filter #(= 0 (mod x %)) (range 2 x)))))\n      primes (filter prime? (drop 2 (range)))]\n  (fn [x] (take x primes)))", "problem": 67, "user": "52437703e4b076204b44fabf"}, {"code": "(let [primer \n      (fn [primes trial depth n] \n        (if (= n (count primes))\n          primes\n          (if (> (* (primes depth) (primes depth)) trial)\n            (recur (conj primes trial) (+ trial 2) 1 n)\n            (if (reduce (fn [a b] (or a b)) (map (fn [y] (= 0 (mod trial y))) primes)) \n              (recur primes (+ trial 2) 1 n)\n              (recur primes trial (inc depth) n)\n            )\n          )\n        )\n      )\n     ] \n  (fn [how_many] (primer [2 3] 5 1 how_many))\n)", "problem": 67, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn pr67 [n]    \n  (take n \n        (filter \n         (fn  [x]\n  (if (= 2 x) true\n      (if (= 1 x) false\n          (if (= 0 x) false  \n              (every? #((complement zero?) %1)   (map #(mod x %1) (range 2 x))))))\n  )\n\n         (range))\n        )\n    )", "problem": 67, "user": "4ec4d723535dcc7ae8597d65"}, {"code": "#(let [b (* % 10)\n       l (boolean-array b true)]\n\t\t(loop [i 2 r []]\n\t\t\t  (if (< i b)\n\t\t\t\t(if (aget l i)\n\t\t\t\t\t(do\n\t\t\t\t\t\t(loop [j (+ i i)]\n\t\t\t\t\t\t\t  (when (< j b)\n\t\t\t\t\t\t\t\t(aset l j false)\n\t\t\t\t\t\t\t\t(recur (+ j i))))\n\t\t\t\t\t\t(recur (inc i) (conj r i)))\n\t\t\t\t  (recur (inc i) r))\n\t\t\t\t(take % r))))", "problem": 67, "user": "51f2851fe4b0210f90e7454b"}, {"code": "(fn [v] (take v (\n                 (fn sieve\n                   ([] (sieve 2 [2]))\n                   ([n stock]\n                      (loop [start n]\n                        (if (not-any? (partial #(= 0 (mod % %2)) start) stock)\n                          (cons n (lazy-seq (sieve start (conj stock start))))\n                          (recur (inc start))\n                          )\n                        ))))))", "problem": 67, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn primes [cnt]\n  (reduce \n    (fn [v e]\n      (cond  \n        (= (count v) cnt) v\n        (some #(= 0 (mod e %1)) v) v\n        :else (conj v e)))\n   []\n   (range 2 (* cnt cnt))))", "problem": 67, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn [x] (take x\n             ((fn next-prime\n                ([] (cons 2 (cons 3 (lazy-seq (next-prime 5)))))\n                ([next-candidate] (if\n                                      (every? (complement zero?)\n                                              (map #(rem next-candidate %) (range 3 next-candidate)))\n                                    (cons next-candidate (lazy-seq (next-prime (+ 2 next-candidate))))\n                                    (recur (+ 2 next-candidate))))))))", "problem": 67, "user": "524f213be4b0541d1855b7ff"}, {"code": "(fn [x]\n  (let [prime? (fn [n](every? #(not= 0 (rem n %)) (range 2 n)))\n        primes (fn [](filter prime? (iterate inc 2)))]\n    (take x (primes))))", "problem": 67, "user": "5142e808e4b0c172af7558c9"}, {"code": "(fn [n]\n  (->>\n   (loop [ps [2] cs (filter odd? (range 2 542))]\n     (if (empty? (rest cs))\n       (conj ps (first cs))\n       (recur (conj ps (first cs)) (remove #(= 0 (mod % (first cs))) (rest cs)))))\n   (take n)))", "problem": 67, "user": "4f048f67535dcb61093f6bd3"}, {"code": "(fn [x]\n  (take x ((fn primes \n  ([] (cons 2 (primes [2])))\n  ([p] (let [\n    n (-> p last inc)\n    next_prime (first (filter #(nil? (some zero? (map (partial mod %) p))) (iterate inc n)))] \n    (cons next_prime (lazy-seq (primes (conj p next_prime))))))))))", "problem": 67, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn [n]\n  (letfn [(primeList [seq]\n                     (let [h (first seq)]\n                       (cons h\n                             (lazy-seq (primeList (remove #(zero? (mod % h)) (rest seq)))))))]\n    (take n (primeList (iterate inc 2)))))", "problem": 67, "user": "51df825de4b01188f062752b"}, {"code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(zero? (mod n %))\n                            (range 2 n))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "problem": 67, "user": "52655949e4b03e8d9a4a710b"}, {"code": "(fn myPrimeNumbers\n  [num]\n  (let [prime? (fn [x] (not-any? zero? (map #(mod x %) (range 2 x))))]\n    (take num (filter prime? (iterate inc 2)))))", "problem": 67, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [n] (take n (filter (fn [q] (not-any? zero? (map #(rem q %) (range 2 (inc (/ q 2)))))) (iterate inc 2))))", "problem": 67, "user": "51ca82e9e4b08b1cbd0d9488"}, {"code": "(fn [x]\n  (letfn [(divides? [a b] (= (mod a b) 0))\n          (prime? [n] \n                  (if (< n 2)\n                    false\n                    (empty? (filter (partial divides? n)\n                                    (take-while #(<= (* % % ) n) (drop 2 (range)))))))]\n         (take x (filter prime? (range)))))", "problem": 67, "user": "523c6451e4b07becd5be2222"}, {"code": "(fn [p]\n(letfn \n [(prime? [n]\n  (empty? \n    (filter \n      (fn [x] (= 0 (mod n x))) \n      (range 2 (inc (Math/sqrt n)))\n  )))]\n  (take p (cons 2 (drop 2 (filter prime? (range)))))\n)\n)", "problem": 67, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn [n] \n  (loop [curr 2 res []]\n    (if (= n (count res)) res\n        (if (some #(= 0 (mod curr %)) res) (recur (inc curr) res)\n          (recur (inc curr) (conj res curr))))))", "problem": 67, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn primes [n]\n\t(letfn [(sieve [s]\n\t  (cons (first s)\n\t        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n\t                                 (rest s))))))]\n  (take n (sieve (iterate inc 2))))\n)", "problem": 67, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn p67\n  ([i] (p67 [2 3] 5 (- i 2)))\n  ([rt c i] (if (<= i 0) rt\n              (let [dv (fn [x ls] (some #(= 0 (mod x %)) (take-while #(<= % (Math/sqrt x)) ls)))\n                    nc (+ c 2)]\n                (if (dv c rt) (p67 rt nc i) (p67 (conj rt c) nc (dec i))))\n              )))", "problem": 67, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn get-primes [n]\n  (let [primes ((fn sieve [p]\n                  (cons \n                    (first p)\n                    (lazy-seq (sieve (filter #(not= 0 (mod % (first p))) (rest p))))))\n                 (drop 2 (range)))]\n    (take n primes)))", "problem": 67, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [n] (take n (for [p (range) :when (.isProbablePrime (.toBigInteger (bigint p)) 100)] p)))", "problem": 67, "user": "521d709ae4b050d5da0427ef"}, {"code": "(fn [n]\n  (let [no-prime-factors? (fn [ps i] (nil? (some\n                                             #(zero? (mod i %))\n                                             (take-while #(<= (* % %) i) ps))))\n        next-prime        (fn [ps n] (first (filter\n                                              (partial no-prime-factors? ps)\n                                              (iterate inc n))))\n        primes-from       (fn primes-from [ps n] (lazy-seq\n                                                   (let [nxt (next-prime ps (inc n))]\n                                                     (cons nxt (primes-from (conj ps nxt) nxt)))))]\n    (take n (primes-from (sorted-set) 1))))", "problem": 67, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [n]\n  (letfn [(prime [k] (every? true? (map #(not (= 0 (mod k %)))\n                                        (range 2 k))))]\n    (take n (filter prime (drop 2 (range))))))", "problem": 67, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [z] \n  (loop [vet [] max z i 2]\n  (if (= (count vet) max) \n    vet \n    (recur \n      (if ( \n            (fn [x]\n              (not= \n                (\n                  (fn [y] (apply *' (map #(mod y %) (range 2 y))))\n                  x\n                )\n                0\n              )\n            ) \n            i\n          )\n        (conj vet i)\n        vet)\n      max \n      (inc i)\n    )\n  )\n)\n)", "problem": 67, "user": "527c0513e4b03e8d9a4a75ab"}, {"code": "(fn [number-of-primes]\n   (letfn [(isprime? \n            [pos-prime]\n            (let [possible-divisors (drop 2 (range pos-prime))\n                  non-divisors (take-while #(not= (rem pos-prime %) 0) possible-divisors)]\n              (= (count non-divisors) (- pos-prime 2))))]\n     \n     (let [infinite-numbers (drop 1 (range))\n           all-primes (filter isprime? infinite-numbers)]\n       (doall (take number-of-primes all-primes)))))", "problem": 67, "user": "52761edae4b03e8d9a4a74d4"}, {"code": "(fn [n] \n  (loop [var 3 cnt 1 rslt [2]]\n    (if (>= cnt n) rslt\n      (if (some #(= 0 (mod var %)) rslt)\n        (recur (+ 2 var) cnt rslt )\n        (recur (+ 2 var) (inc cnt) (conj rslt var) )\n       )\n    )\n   )\n )", "problem": 67, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn a [n] (letfn [(prime? [x](not-any? #(zero? (mod x %)) (range 2 x)))] (let [out [2]] (loop [i 3 o out] (if-not(=(count o)n)(recur (inc i) (if(prime? i)(conj o i)(identity o)))(identity o)) ))))", "problem": 67, "user": "527a8eb7e4b03e8d9a4a755f"}, {"code": "(fn  [y]\n    (let [ f (fn [x]\n               (every? #(not= 0 (mod x % )) (range 2 x )))\n           ]\n      (take y (filter f (iterate inc 2)))\n      )\n    )", "problem": 67, "user": "518c5236e4b087e178201de0"}, {"code": "(fn [x]\n  (loop [y 2 ret []]\n    (if (< (count ret) x)\n      (if (loop [x 2]\n            (if (= x y)\n              true\n              (if (= (mod y x) 0)\n                false\n                (recur (inc x)))))\n        (recur (inc y) (conj ret y)) \n        (recur (inc y) ret))\n     ret)))", "problem": 67, "user": "51ef31dfe4b0871fa145d9a0"}, {"code": "(fn[num]\n (take num\n       (mapcat\n         (fn[n]\n           (if-not (some zero? (map #(rem n % ) (range 2 n)))\n              [n]\n              []\n           )\n         )\n         (drop 2 (range))\n      )\n )\n)", "problem": 67, "user": "5229211be4b04c906c9c6a63"}, {"code": "#(loop [primes [] cnt % n 2]  \n   (if (zero? cnt) \n     primes \n     (if (some (fn [p] (zero? (mod n p))) primes)  \n       (recur primes cnt (inc n)) \n       (recur (conj primes n) (dec cnt) (inc n)))))", "problem": 67, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [n]\n  (take n (remove (fn [x]\n                    (some #(zero? (mod x %))\n                          (range 2 (inc (int (Math/sqrt x))))))\n                  (iterate inc 2))))", "problem": 67, "user": "52890634e4b0239c8a67ae5e"}, {"code": "(fn [n]\n  (let [filter-f (fn [known, nc]\n                   \"Return true if nc mod any element in known is not zero\"\n                   (reduce\n                     #(and % (pos? (mod nc %2)))\n                     true\n                     known))\n\n        nextp (fn [known]\n                (first\n                  (filter\n                    (partial filter-f known)\n                    (filter\n                      (partial < (last known))\n                      (range)))))]\n\n    (nth (iterate #(conj % (nextp %)) [2]) (dec n)))\n  )", "problem": 67, "user": "528149fbe4b0757a1b171426"}, {"code": "(fn f                                    \n  ([n] (f n [2]))                        \n  ([n c]                                 \n     (if (= (count c) n)                 \n       c                                 \n       (loop [e (+ (last c) 1)]          \n         (if (some #(integer? (/ e %)) c)\n           (recur (+ e 1))               \n           (f n (conj c e)) ) ))))", "problem": 67, "user": "4df20dda535d08e6dec9fe23"}, {"code": "(fn [x]\n   (first (filter #(= (count %) x) \n     (reductions\n       (fn [primes number]\n         (if (some zero? (map (partial mod number) primes))\n            primes\n            (conj primes number)))\n       [2]\n       (iterate inc 3)))))", "problem": 67, "user": "51269362e4b083bb8f88cf09"}, {"code": "(fn prime [n] (take n \n  (filter (fn [x] (every? #(not= 0 (mod x %)) (range 2 x))) (iterate inc 2))))", "problem": 67, "user": "4fc8769be4b0ee37620e1833"}, {"code": "(fn [n] (nth (distinct (reductions (fn [xs x] (if (some #(= (mod x %) 0) xs) xs (conj xs x))) [] (range 2 (* n n 2)))) n))", "problem": 67, "user": "522f483ce4b032bbe342415a"}, {"code": "(fn [x] (take x [2    3    5    7    11    13    17    19    23    29    31    37    41    43    47    53    59    61    67    71    73    79    83    89    97    101    103    107    109    113    127    131    137    139    149    151    157    163    167    173    179    181    191    193    197    199    211    223    227    229    233    239    241    251    257    263    269    271    277    281    283    293    307    311    313    317    331    337    347    349    353    359    367    373    379    383    389    397    401    409    419    421    431    433    439    443    449    457    461    463    467    479    487    491    499    503    509    521    523    541]))", "problem": 67, "user": "525c575be4b0cb4875a45d38"}, {"code": "(fn [num]\n    (letfn [(prime? [n]\n              (every? #(not= 0 (mod n %)) (range 2 n)))]\n      (->> (filter prime? (iterate inc 2))\n            (take num))))", "problem": 67, "user": "4dddff47535d08e6dec9fdd4"}, {"code": "(fn primes [n]\n  (let [f (fn [ps _] (conj ps\n                           (+ 2 (first (filter (fn [x] (if (== 0\n                                                               (count (filter #(== 0 %)\n                                                                              (map #(mod (+ x 2) %)\n                                                                                   ps))))\n                                                         true\n                                                         false))\n                                               (range))))))]\n    (if (== n 1)\n      [2]\n      (reduce f [2] (range (dec n))))))", "problem": 67, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn [x]\n  (take x (filter (fn [i] (not (some #(= 0 (mod i %)) (range 2 i)))) (iterate inc 2))))", "problem": 67, "user": "527dc2aee4b0757a1b17138d"}, {"code": "(fn primes [n]\n   (let [stream (iterate inc 2)\n         sieve (fn [p stream]\n                 (filter #(not= 0 (mod % p))\n                         stream))\n         run-sieve (fn run-sieve [stream]\n                     (lazy-seq\n                       (let [p (first stream)]\n                         (cons p\n                               (run-sieve (sieve p stream))))))]\n     (take n (run-sieve stream))))", "problem": 67, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn get-primes [n]\n  (loop [next 2\n         count 0\n         out []]\n    (if (= count n)\n      out\n      (let [ is-prime? (fn [n] (not (contains? (set (map #(= 0 (mod n %)) (range 2 (/ (inc n) 2)))) true)))\n             is (is-prime? next)]\n        (recur (inc next) (if is (inc count) count) (if is (conj out next) out))))))", "problem": 67, "user": "51622fb8e4b009fba0926e3f"}, {"code": "(fn fac [n]\n  (if (= n 1)\n    [2]\n    (let [prev (fac (- n 1))]\n      (conj prev (first (filter (fn [x] (not-any? #(= 0 (mod x %)) prev)) (iterate inc (last prev))))))))", "problem": 67, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn [n]\n  (letfn [(p? [x] (or (= x 2) (every? #(pos? (rem x %)) (range 2 (inc (Math/sqrt x))))))]\n    (take n (filter p? (iterate inc 2)))))", "problem": 67, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn [n]\n  (letfn [(prime-seq [[x1 & x]] (lazy-seq (cons x1 (prime-seq (remove #(= 0 (mod % x1)) x)))))]\n            (take n (prime-seq (drop 2 (range))))))", "problem": 67, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [n]\n  (letfn [(prime? [n] (not-any? #(zero? (rem n %)) (range 2 (inc (Math/sqrt n)))))]\n    (take n (cons 2(filter prime? (iterate inc 2))))))", "problem": 67, "user": "528b08efe4b0239c8a67ae8a"}, {"code": "(fn [x] (take x (filter (fn [x] (zero? (count (filter #(= (rem x %) 0) (take-while #(<= (* % %) x) (range 2 x)))))) (iterate inc 2))))", "problem": 67, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [n]                                                                                                                                                \n  (letfn [(f [[h & t]]                                                                                                                                 \n            (cons h (lazy-seq (f (remove #(zero? (mod % h)) t)))))]                                                                                    \n    (take n (f (iterate inc 2)))))", "problem": 67, "user": "4dda44f2535d02782fcbe9f1"}, {"code": "(fn [num]\n    (loop [result [2]  seed 3]\n         (if (= num (count result)) result\n           (recur (concat result (if (empty? (filter #(zero? (rem seed %)) result)) [seed])) (inc seed))\n         )\n    )\n)", "problem": 67, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn primes2 [x]\n  (letfn[(primes\n           []\n           (lazy-seq\n             (let [prime [2 3 5 7 11]]\n               (letfn [(is-prime [primelst x]\n                                 (not (some (fn [i] \n                                              (= 0 (mod x i))) \n                                            (filter #(<= (* % %) x) primelst))))\n                       (get-primes [primes start]\n                                   (lazy-seq \n                                     (if(is-prime primes start )\n                                       (concat [start] (get-primes (conj primes start) (+ 2 start)))\n                                       (get-primes  primes (+ 2 start)))))]\n                 (concat prime (get-primes prime 13))))))]\n    (take x (primes))))", "problem": 67, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn give-primes \n  [n] \n  (letfn [(prime? [vp p] (not (some #(= (mod p %1) 0) vp)))\n          (primes [vp i]\n                  (if (prime? vp i)\n                    (cons i (lazy-seq (primes (conj vp i) (+ 2 i))))\n                    (primes vp (+ 2 i))))\n          ]\n\t(cons 2 (take (dec n) (primes [2] 3)))\n    ))", "problem": 67, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "#(letfn\n      ;; SICP http://mitpress.mit.edu/sicp/full-text/sicp/book/node71.html\n      [(sieve [stream]\n         (lazy-seq\n          (cons\n           (first stream)\n           (sieve\n            (filter \n             (fn [n] ((complement zero?) (rem n (first stream))))\n             (rest stream))))))]\n   (take % (sieve (drop 2 (range))))\n)", "problem": 67, "user": "5281a445e4b0757a1b17143a"}, {"code": "(fn [i]\n  (loop [i i\n         n 3\n         ps [2]]\n    (if (= 1 i)\n      ps\n      (if (some #(zero? (mod n %)) ps)\n        (recur i (inc n) ps)\n        (recur (dec i) (inc n) (conj ps n))))))", "problem": 67, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn [n]\n  (take n (filter \n           (fn [x] (not-any? #(zero? (rem x %)) (range 2 x))) \n           (drop 2 (range)))))", "problem": 67, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn primes [n]\n  (letfn [(prime? [n]\n            (cond\n              (<= n 1) false\n              (= n 2) true\n              (even? n) false\n              :else (= 0 (count (filter zero? (map #(rem n %) (range 3 (inc (Math/sqrt n)) 2)))))))]\n    (loop [k 2\n           p []]\n      (cond\n        (= n (count p) ) p\n        (prime? k) (recur (inc k) (conj p k))\n        :else (recur (inc k) p)))))", "problem": 67, "user": "52606318e4b03e8d9a4a7036"}, {"code": "(fn [count]\n  (letfn [(prime? [n] (and (> n 1)\n\t\t\t\t           (not (some (fn [d] (= 0 (mod n d)))\n\t\t                              (range 2 (inc (/ n 2)))))))]\n  (take count (filter prime? (range)))))", "problem": 67, "user": "4fa09916e4b0dcca54ed6d4e"}, {"code": "(fn primes [n]\n  (letfn [(enqueue [sieve n step]\n            (let [m (+ n step)]\n              (if (sieve m)\n                (recur sieve m step)\n                (assoc sieve m step))))\n          (next-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                (dissoc candidate)\n                (enqueue candidate step))\n              (enqueue sieve candidate (+ candidate candidate))))\n          (next-primes [sieve candidate]\n            (if (sieve candidate)\n              (recur (next-sieve sieve candidate) (+ candidate 2))\n              (cons candidate \n                (lazy-seq (next-primes (next-sieve sieve candidate) \n                            (+ candidate 2))))))]\n    (take n (cons 2 (lazy-seq (next-primes {} 3))))))", "problem": 67, "user": "50fc48dde4b0d10d794c19f6"}, {"code": "(fn gprimes [c]\n  (last (take c (iterate\n                 (fn nprime [p]\n                   (cond\n                    (empty? p) [2]\n                    (= 2 (last p) (first p)) [2 3]\n                    :else\n                    (letfn [(prime? [n plist]\n                              (if (empty? (filter #(= 0 (rem n %)) plist))\n                                true false))]\n                      (loop [n (+ 2 (last p))]\n                        (cond\n                         (prime? n p) (conj p n)\n                         :else (recur (+ n 2))))))) [2]\n                         ) ))\n)", "problem": 67, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn prim [in]\n  ((fn primes [n m ps]\n    (if (= 0 n)\n      ps\n      (if (not-any? #(= 0 (mod m %)) ps)\n        (primes (dec n) (inc m) (conj ps m))\n    \t(primes n (inc m) ps)))) in 2 []))", "problem": 67, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [n]\n  (let [found-primes (atom [])\n        primes (fn primes [[x & more]]\n                 (if (some integer? (map (partial / x) @found-primes))\n                   (primes more)\n                   (do (swap! found-primes conj x)\n                       (cons x (lazy-seq (primes more))))))]\n    (take n (primes (drop 2 (range))))))", "problem": 67, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn prime-numbers [n]\n  ((fn prime-iter [prev next l]\n      (if (= l n)\n        prev\n        (if (some #(= (mod next %) 0) prev)\n          (prime-iter prev (+ next 2 ) l)\n          (prime-iter (conj prev next) (+ next 2) (+ l 1))))) [2 3] 5  2))", "problem": 67, "user": "527ccaf4e4b0757a1b17136d"}, {"code": "(fn [x] \n\t\t(take x \n\t\t\t(filter \n\t\t\t\t(fn [y] \n\t\t\t\t\t(not \n\t\t\t\t\t\t(some zero?\n\t\t\t\t\t\t\t( map \n\t\t\t\t\t\t\t\t(fn [z] (mod y z)) \n\t\t\t\t\t\t\t\t(drop 2 (range y)) \n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\t\t\t\t\t\t\n\t\t\t\t\t) \n\t\t\t\t)\n\t\t\t\t(drop 2 (range 1000))\n\t\t\t)\n\t\t)\n\t)", "problem": 67, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn [c]\n    (letfn [(prime? [n ps]\n              (= 0 (count (for [p ps :when (= 0 (mod n p))] p))))]\n      (loop [ps [2]\n             n 3]\n        (cond\n          (= c (count ps)) ps\n          (prime? n ps)    (recur (conj ps n) (+ n 2))\n          :else            (recur ps (+ n 2))))))", "problem": 67, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [n]\n  (letfn [(p [x] (empty? (filter #(= 0 (mod x %)) (range 2 x))))]\n    (take n (filter p (drop 2 (range))))))", "problem": 67, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn [cand] (every? pos? (map #(mod cand %) (range 2 cand))))\n      (iterate inc 2))))", "problem": 67, "user": "528652fbe4b0239c8a67ae14"}, {"code": "#(take % (iterate (fn [n] \n                    (loop [i (inc n)] \n                      (if (not (some zero? (map (partial mod i) (range 2 (inc (Math/sqrt i))))))\n                        i\n                        (recur (inc i)))))\n                  2))", "problem": 67, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn [i]\n\t(take i (remove #(some (fn [x] (= 0 (rem % x)))\n                               (range 2 %))\n                    (iterate inc 2))))", "problem": 67, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn [r c]\n  (take c\n        (remove #(some (fn [x] (= 0 (rem % x))) (r 2 %))\n                (nnext (r)))))\nrange", "problem": 67, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn primes [n]\n  (let [prime? \n        (fn [p]\n          (and \n           (not (or (= p 0) (= p 1)))\n           (= 0 (count (filter #(= 0 (mod p %)) (range 2 (+ 1 (int (/ p 2)))))))))\n        gen-prime \n        (fn [acc k n]\n          (if (= n 0) (reverse acc) \n          (recur (if (prime? k) (conj acc k) acc) (inc k) (if (prime? k) (dec n) n))))]\n(gen-prime '() 0 n)))", "problem": 67, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn primes [how-many]\n  (nth (iterate (fn [previous-primes]\n                      (loop [num (inc (last previous-primes))]\n                        (if (empty? (filter #(= 0 (mod num %)) previous-primes))\n                          (conj previous-primes num)\n                          (recur (inc num))))) [2]) (dec how-many)))", "problem": 67, "user": "525ed5f4e4b0cb4875a45db8"}, {"code": "(fn [n]\n  (letfn [(divisable? [n]\n                      (let [max-divisor (Math/sqrt n)]\n                        (some #(zero? (rem n %)) (range 2 (inc max-divisor)))))\n          (prime? [n]\n                  (and (> n 1) (or (= n 2) (not (divisable? n)))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn prime [n]\n  (if (> n 1)\n    (let [primes (prime (dec n))]\n      (loop [p (inc (last primes))]\n        (if (some #{0} (map (partial rem p) primes))\n          (recur (inc p))\n          (concat primes [p]))))\n    [2]))", "problem": 67, "user": "52ab6de1e4b0c58976d9ac78"}, {"code": "(fn [x]\n  (letfn [(prime? [n pvec] (every? #(pos? (rem n %)) pvec))\n          (gen-primes [x n pvec]\n            (if (pos? x)\n              (if (prime? n pvec)\n                (recur (dec x) (+ n 2) (conj pvec n))\n                (recur x (+ n 2) pvec))\n              pvec))]\n    (gen-primes (dec x) 3 [2])))", "problem": 67, "user": "51929214e4b08962174cf74c"}, {"code": "(fn n-primes [n]\n  (take \n    n \n    (iterate \n      (fn get-next-prime [k]\n        (let [m (inc k)]\n          (if (contains? \n                (set (map #(rem m %) (range 2 k)))\n                0)\n              (get-next-prime m)\n              m)))\n      2)))", "problem": 67, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "#(take % ((fn primes [s] (let [x (first s)] (cons x (lazy-seq (primes (remove (fn [y] (zero? (mod y x))) (rest s))))))) (iterate inc 2)))", "problem": 67, "user": "528e95efe4b0239c8a67aee2"}, {"code": "(fn [t]\n    (loop [i 2 ps []]\n      (if (= t (count ps))\n        ps\n        (if (some #(= 0 %) (map #(mod i %) ps))\n          (recur (inc i) ps)\n          (recur (inc i) (conj ps i))))))", "problem": 67, "user": "4f77b68de4b0fbe0118ec581"}, {"code": "(fn [n]\n  (take n (filter (fn [m]\n                    (not (some #(= 0 (rem m %)) (range 2 m))))\n                  (drop 2 (range)))))", "problem": 67, "user": "51937eb3e4b04df54c098022"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n                  (if (< x 2)\n                    false\n                    (or (= 2 x)\n                        (every? #(not= 0 (rem x %))\n                                (cons 2 (range 3 (inc (Math/sqrt x))))))))]\n    (let [primes (filter prime? (range))]\n      (take n primes))))", "problem": 67, "user": "4ee8b9c9535d93acb0a66884"}, {"code": "(fn [n]\n    (letfn [(prime? [n]\n              (cond\n                (= n 1) false\n                (= n 2) true\n                :else\n                  (loop [i 2]\n                    (cond\n                      (= (rem n i) 0) false\n                      (> (* i i) n) true\n                      :else (recur (inc i))))))]\n      (take n (filter prime? (drop 1 (range))))))", "problem": 67, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(fn primer\n  ([amount]\n    (primer (dec amount) (drop 2 (range))))\n  ([amount remaining]\n    (let [prime (first remaining)]\n      (cons prime\n        (if (zero? amount)\n          []\n          (lazy-seq\n              (primer\n                (dec amount)\n                (filter\n                  #(not (zero? (mod % prime)))\n                  remaining))))))))", "problem": 67, "user": "52b4d8fae4b0c58976d9ad33"}, {"code": "(fn [x] (letfn [(prime? [n] (cond (< n 2) false (< n 4) true (even? n) false :else (every? pos? (map #(mod n %) (range 3 (inc (Math/sqrt n)) 2)))))] (take x (filter prime? (range)))))", "problem": 67, "user": "4e4be570535dc968683fc4d8"}, {"code": "(fn primes\n  [n]\n  (vec (take n (lazy-seq (let [nums (lazy-seq (map #(+ % 2) (range)))]\n                           (filter (fn prime?\n  [prime]\n  (let [divisors (range 2 prime)\n        factor #(if (= 0 (mod (first %1) %2)) (conj %1 %2) %1)\n        factors (reduce factor [prime] divisors)]\n    (= 1 (count factors)))) nums))))))", "problem": 67, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [n]\n  (letfn [(prime [k]\n                  (let [r (java.lang.Math/floor (java.lang.Math/sqrt k))]\n                    (every? (complement zero?) (map #(mod k %) (rest (rest (range (inc r))))))))]\n    (take n (filter prime (rest (rest (range)))))))", "problem": 67, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [n]\n  (let [\n        step (fn [i f s]\n               (lazy-seq\n                (if (not (f i))\n                  (cons i (s (+ i 2) (fn [x] (or (= 0 (rem x i)) (f x))) s))\n                  (s (+ i 2) f s))))\n        ]\n    (take n (cons 2 (cons 3 (step 5 (fn [x] (= (rem x 3) 0)) step))))\n    ))", "problem": 67, "user": "5298d3f4e4b02ebb4ef75068"}, {"code": "(fn [n]\n       (take n\n         (filter\n           (fn p [x] (every? #(> (mod x %) 0) (range 2 x)))\n           (map #(+ 2 %) (range)))))", "problem": 67, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [num]\n  (letfn [(indivisible-from? [n] (fn [d] (not= 0 (rem n d))))\n          (max-root [n] (+ 1 (int (Math/sqrt n))))\n          (prime? [n] (every? (indivisible-from? n) (range 2 (max-root n))))]\n    (take num (lazy-seq (filter prime? (drop 2 (range)))))))", "problem": 67, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn [n]\n  (letfn [(pgen [x] (cons x (filter #(not= 0 (mod % x))\n                                    (lazy-seq (pgen (inc x))))))]\n    (take n (pgen 2))))", "problem": 67, "user": "52b65f26e4b0c58976d9ad43"}, {"code": "(fn f [p s n] \n   (if (= n (count s)) \n     s \n     (if (some #(= 0 (mod p %)) s)\n       (f (+ 1 p) s n)\n       (f (+ 1 p) (conj s p) n)))) 2 []", "problem": 67, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn [n]\n   (letfn [(prime? [x] (not-any? zero? (map #(rem x %) (range 2 (inc (/ x 2))))))]\n     (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "52a9154ee4b0c58976d9ac3b"}, {"code": "(fn\n  [m]\n  (let [prime? (fn [n]\n                 (->>\n                  (filter #(= 0 (rem n %)) (range 2 n))\n                  first\n                  nil?))]\n    (take m (filter prime? (drop 2 (range))))))", "problem": 67, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn [n]\n  (letfn [(prime? [p]\n            (every? #(not= 0 (mod p %)) (range 2 p)))]\n    (take n (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n          (if (pos? x)\n            (if (prime? n pvec)\n              (recur (dec x) (+ n 2) (conj pvec n))\n              (recur x (+ n 2) pvec))\n            pvec))]\n    (gen-primes (dec x) 3 [2])))", "problem": 67, "user": "52a28e1ce4b04e0c58e87bf0"}, {"code": "(fn prime [size]\n  (letfn [(prime? [coll x] (not (some #(zero? (rem x %)) coll)))\n          (next-prime [coll k] (if (prime? coll k)\n                                 k\n                                 (next-prime coll (inc k))))\n          (step [coll] (let [next-num (next-prime coll (last coll))]\n                         (lazy-seq (cons (last coll) (step (conj coll next-num))))))]\n    (take size (step [2]))))", "problem": 67, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn primey [n]\n\t(loop [rv [] muls #{} tp 2]\n\t\t(if (= (count rv) n)\n\t\t\trv\n\t\t\t(if (muls tp)\n\t\t\t\t(recur rv muls (inc tp))\n\t\t\t\t(recur (conj rv tp) (into muls (map #(* tp %) (range tp 1000))) (inc tp)))\n\t\t\t)\n\t\t)\n)", "problem": 67, "user": "527ba695e4b03e8d9a4a7596"}, {"code": "(fn primes\n  ([] (let [sieve (fn sieve [s] \n                    (cons (first s)\n                          (lazy-seq (sieve \n                                     (filter #(not= (mod % (first s)) 0) (rest s))\n                                    )\n                          )\n                    )\n                  )]\n           (sieve (iterate inc 2))\n       )\n  )\n  ([n] (take n (primes)))\n)", "problem": 67, "user": "52bf8e35e4b07a9af579233a"}, {"code": "(fn primes [n]\n  (letfn [(sieve [s] \n    (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))))]\n    (take n (sieve (iterate inc 2)))\n    ))", "problem": 67, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn [n]\n  (letfn [(primes [s]\n      \t\t(cons (first s)\n                  (lazy-seq (primes (filter #(not= 0 (mod % (first s)))\n                                            (rest s))))))]\n    (take n (primes (iterate inc 2)))))", "problem": 67, "user": "52976262e4b02ebb4ef75041"}, {"code": "(fn [c]\n  (take c\n    ((fn sieve [n]\n      (cons n\n        (lazy-seq (remove #(= 0 (mod % n)) (sieve (inc n)))))) 2)))", "problem": 67, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [n]\n  (letfn [(factors [n]\n                   (filter (fn [m] (= 0 (mod n m))) (range 1 (inc n))))\n          (prime? [n]\n                  (= [1 n] (factors n)))\n          (primes []\n                  (filter prime? (drop 2 (range))))]\n  \t(take n (primes))))", "problem": 67, "user": "5213d7aae4b0961f15ac4d72"}, {"code": "(fn [n] \n  (take n \n        (\n         (fn f [[s & r]] \n           (cons s \n                 (lazy-seq \n                  (f (filter #(not= 0 (mod % s)) r))))) \n         (iterate inc 2)\n        )\n  )\n)", "problem": 67, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn  [n]\n  (let [prime? (fn [n]\n                 (loop [d (quot n 2)]\n                   (cond\n                    (<= d 1) true\n                    (= 0 (mod n d)) false\n                    :else       \n                    (recur (dec d))\n                    )))]\n    (loop [acc [] c 2]\n      (if (= (count acc) n)\n        acc\n        (recur (if (prime? c) (conj acc c) acc) (inc c))\n        )\n      )))", "problem": 67, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn nthprime [n]\n  (loop [[x & xs] (range 2 1000000) ans []]\n\t(if (= (count ans) n)\n\t    ans\n\t  (recur (filter #(not= (mod % x) 0) xs) (conj ans x)))))", "problem": 67, "user": "52aa16d1e4b0c58976d9ac5a"}, {"code": "(fn [num]\n (loop [cnt 0 n 2 vctr nil]\n         (if \n\t   (= cnt num) (reverse vctr)\n           (do (if (zero? (count (filter #(zero? (mod n %)) (range 2 n))))\n                         (recur (inc cnt) (inc n) (conj vctr n))\n                         (recur cnt (inc n) vctr)\n                 )))))", "problem": 67, "user": "52c3a0f4e4b0c2d177d620c6"}, {"code": "(fn f [n] (if (= n 1) [2] (let [p (f (dec n))] (conj p (first (filter #(every? pos? (map rem (repeat (count p) %) p)) (iterate inc (last p))))))))", "problem": 67, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn [x]\n  (loop [primes (drop 2 (range)) res [] n 0]\n    (if (= n x)\n      res\n      (recur\n       (filter #(not= 0 (mod % (first primes))) primes)\n       (conj res (first primes))\n       (inc n)))))", "problem": 67, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [n]\n  (let [\n        p (fn p [col]\n                    (let [\n                          n (first col)\n                          ]\n                      (concat [n] (lazy-seq (p (filter #(not= 0 (rem % n)) col))))))\n       ]        \n  (take n (p (iterate inc 2)))))", "problem": 67, "user": "4f05a9cf535dcb61093f6bfc"}, {"code": "(fn primes [n]\n  (take\n    n\n    (let [isPrime (fn [x]\n                    (not-any? #(= 0 (mod x %)) (range 3 (inc (Math/sqrt x)) 2))\n                  )\n          ]\n      (cons 2 (filter isPrime (range 3 java.lang.Double/POSITIVE_INFINITY 2)))\n    )\n  )\n)", "problem": 67, "user": "52b49aebe4b0c58976d9ad2b"}, {"code": "(fn prime-numbers [x]\n  (letfn [(prime? [xi]\n            (loop [i (dec xi)]\n              (cond (= 1 i) true\n                    (= 0 (rem xi i)) false\n                    :else (recur (dec i))))\n            )]\n\n    (loop [n 2 f 0 a []]\n      (cond (= f x) a\n            (prime? n) (recur (inc n) (inc f) (conj a n))\n            :else (recur (inc n) f  a)))\n    ))", "problem": 67, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn [x] (take x (filter #(= (inc (mod (apply * (range 1N %)) %)) %) (iterate inc 2))))", "problem": 67, "user": "52c580c2e4b0c2d177d620f5"}, {"code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "problem": 67, "user": "52c4fe42e4b0c2d177d620e9"}, {"code": "(fn primeList [k]\n  (let [isPrime?\n        (fn [n]\n          (if (every? #(not= 0 %) (map rem (repeat (- n 2) n) (range 2 n)))\n            true\n            false\n            )\n          )]\n\n    (take k (filter isPrime? (iterate inc 2)))\n    )\n  )", "problem": 67, "user": "526698c9e4b03e8d9a4a7144"}, {"code": "(fn [n] \n  (let [prime? (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\n    (take n\n      (filter prime? (drop 2 (range))))))", "problem": 67, "user": "4f45c72be4b0d56e7bb92b8a"}, {"code": "(fn [n]\n    (take n ((fn prime [x] (if (= 2 (reduce (fn [a b] (if (= 0 (rem x (inc b))) (inc a) a)) 0 (range x))) (lazy-seq (cons x (prime (inc x)))) (prime (\ninc x))))\n    2)))", "problem": 67, "user": "52c1bd29e4b07a9af579236a"}, {"code": "#(take % (filter\n            (fn [n]\n              (cond (= 2 n) true\n                    (or (neg? n) (< n 2) (even? n)) false\n                    :else (loop [divs (range 3 (inc (int (Math/sqrt n))) 2)\n                                 prime? true]\n                            (if (and (seq divs) (true? prime?))\n                              (recur (rest divs)\n                                     (pos? (mod n (first divs))))\n                              prime?))))\n            (range)))", "problem": 67, "user": "52cc582ae4b07d0d72b27362"}, {"code": "(fn [m]\n  (loop [ps [2] n 3]\n    (if (= (count ps) m)\n      ps\n      (if (empty? (filter zero? (map #(rem n %) ps)))\n        (recur (conj ps n) (inc n))\n        (recur ps (inc n))))))", "problem": 67, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn [n]\n  (take n (filter\n   (fn [x]\n     (or\n      (= x 2)\n      (every? #(not (zero? (mod x %))) (range 2 x))\n      )\n     )\n   (range 2 1000))))", "problem": 67, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn primes [n]\n  (if (= 1 n)\n    [2]\n    (let [nprimes (primes (dec n))]\n      (conj nprimes (first (filter (fn [x] (not-any? #(integer? (/ x %)) nprimes)) (drop (last nprimes) (range)))))\n  )))", "problem": 67, "user": "529d4f4be4b04e0c58e87b79"}, {"code": "(fn [n] (nth (distinct (reductions (fn [p x] (if (some #(= 0 (mod x %)) p) p (conj p x))) [2] (iterate #(+ 2 %) 3))) (dec n)))", "problem": 67, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn primes [n]\n\t(let [prime? (fn [x smaller-primes]\n\t\t(every? #(< 0 (mod x %1)) (reverse smaller-primes))\n\t\t)]\n\t(if (< n 6)\n\t\t(take n [2 3 5 7 11])\n\t\t(reverse\n\t\t(loop [result '(11 7 5 3 2) x 12]\n\t\t\t(if (= n (count result))\n\t\t\t\tresult\n\t\t\t\t(if (prime? x result)\n\t\t\t\t\t(recur (cons x result) (inc x))\n\t\t\t\t\t(recur result (inc x))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t))\n\t)))", "problem": 67, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [n]\n  ((fn r [a x]\n     (if (= a 0) \n       '()\n       (if (= 0 \n              (count (filter \n                      #(= 0 (rem x %)) \n                      (range 2 x))))\n         (cons x (r (dec a) (inc x)))\n         (r a (inc x))))) n 2))", "problem": 67, "user": "525cc137e4b0cb4875a45d46"}, {"code": "(fn [n]\n  (take n\n        (filter\n          (fn is-prime [n]\n            (nil?\n             (some #(zero? (mod n %))\n                   (range 2 n))))\n          (range 2 1000))))", "problem": 67, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n          (if (pos? x)\n            (if (prime? n pvec)\n              (recur (dec x) (+ n 2) (conj pvec n))\n              (recur x (+ n 2) pvec))\n            pvec))]\n    (gen-primes (dec x) 3 [2])))", "problem": 67, "user": "52d7f7efe4b09f7907dd1380"}, {"code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n          (if (pos? x)\n            (if (prime? n pvec)\n              (recur (dec x) (+ n 2) (conj pvec n))\n              (recur x (+ n 2) pvec))\n            pvec))]\n    (gen-primes (dec x) 3 [2])))", "problem": 67, "user": "52d02380e4b07d0d72b273b7"}, {"code": "(fn [n]\n  (take n (filter (fn [v] (not-any? #(zero? (mod v %)) (range 2 v))) (drop 2 (range)))))", "problem": 67, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn first-primes [n]\n  (letfn [(is-prime? [x]\n                     (loop [i 2]\n                       (cond\n                        (= x 2) true\n                        (= 0 (mod x i)) false\n                        (> i (quot x 2)) true\n                        true (recur (+ i 1)))))]\n    (loop [i 2\n           res []]\n      (if (= (count res) n)\n        res\n        (recur (+ i 1) (if (is-prime? i) (conj res i) res))))))", "problem": 67, "user": "52d7b0ade4b09f7907dd137c"}, {"code": "(fn [i]\n  (nth\n    (iterate\n      (fn [v]\n        (conj v\n          (first\n            (drop-while\n              #(some zero?\n                 (map (partial mod %) v))\n                 (iterate inc (last v)))))) [2]) (- i 1)))", "problem": 67, "user": "5256627ce4b0541d1855ba1a"}, {"code": "(fn [x] (take x  \n  (filter (fn prime? [n] (not (some #(= 0 (rem n %)) (range 2 (dec n)))))\n           (iterate inc 2))))", "problem": 67, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn prime [n]\n  (take n \n    (filter (fn p [x]\n      (empty? (filter #(zero? (mod x %)) (range 2 x))))\n    (range 2 Double/POSITIVE_INFINITY))))", "problem": 67, "user": "5271605ae4b03e8d9a4a73ed"}, {"code": "(fn [n]\n    (take n ((fn sieve [p]\n                 (cons (first p)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first p))) (rest p)))))) (iterate inc 2))))", "problem": 67, "user": "4ee75ec2535d93acb0a66867"}, {"code": "#(last (take % (iterate (fn [primos]\n                          (loop [candidato (inc (last primos))]\n                            (if-not (some (fn [primo] (= 0 (rem candidato primo))) primos)\n                              (conj primos candidato)\n                              (recur (inc candidato)))))\n                         [2])))", "problem": 67, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [n] \n  (->>\n  (range)\n  (drop 2)\n  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n  (take n)))", "problem": 67, "user": "52b02329e4b0c58976d9acc5"}, {"code": "(fn [x]\n  (loop [cand (range 2 (* 10 x))\n         primes [2]]\n    (let [elim (range (last primes) (* 10 x) (last primes))]\n      (let [newcand (remove (set elim) cand)]\n        (if (== (inc (count primes)) x)\n          (take x (concat primes newcand))\n          (recur newcand (concat primes [(first newcand)]))\n          )\n        )\n      )\n    )\n  )", "problem": 67, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [n]\n  (take n\n        ((fn i [col]\n           (cons\n            (first col)\n            (lazy-seq\n             (i (remove #(zero? (mod % (first col))) col))))) (iterate inc 2))))", "problem": 67, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn first-primes [x]\n  (letfn [(divisible-by? [x]\n            #(= 0 (rem % x)))\n          (primes\n            ([] (primes (drop 2 (range))))\n            ([xs]\n              (lazy-seq \n                (cons (first xs)\n                      (primes (remove (divisible-by? (first xs)) xs))))))]\n    (take x (primes))))", "problem": 67, "user": "52c4af71e4b0c2d177d620e1"}, {"code": "(fn prime-seq [a]\n  (take a\n        (for [z (range)\n              :when (cond\n                      (= z 1) false\n                      (= z 2) true\n                      (= (rem z 2) 0) false\n                      (nil? (first (for [y (range 3 z 2)\n                                             :when (= (mod z y) 0)]\n                                         y))) true\n                      :else false)]\n          z)))", "problem": 67, "user": "52dad8bde4b09f7907dd13be"}, {"code": "(fn [n]\n  (loop [i 3 s [2]]\n    (if (>= (count s) n)\n      s\n      (let [m (int (Math/sqrt i))]\n        (recur (+ 2 i) (if (or (<= m 1) (not (some #(= 0 (rem i %)) (filter #(<= % m) s))))\n                         (conj s i)\n                         s))))))", "problem": 67, "user": "522eb5cce4b01cdb292c5f0c"}, {"code": "(fn [n]\n  (take n (filter\n           (fn [x]\n             (if (or (some zero? (map #(mod x %) (range 2 x)))\n                     (= x 0)\n                     (= x 1))\n               false\n               true))\n           (range))))", "problem": 67, "user": "52c672e2e4b0c2d177d6210e"}, {"code": "(fn primes [np] \n (take np\n            (cons 2\n                (filter (fn [ n ]\n                    (loop [ d 2]\n                        (if (= (/ n d) (int (/ n d)))\n                                false\n                                (if (>= d (/ n 2 ))\n                                        true\n                                        (recur (inc d))))))\n                                (iterate inc 3 )))))", "problem": 67, "user": "5018ed15e4b011a2e0bf6412"}, {"code": "(fn[n]\n             (take n \n                   (filter \n                     (fn[x](not-any? zero? (map #(mod x %) (range 2 (dec x)))))\n                       (iterate inc 2))))", "problem": 67, "user": "52d66ca0e4b09f7907dd135c"}, {"code": "(fn [y]\n  (take y (iterate \n           (fn nextprime [n] \n             (if(reduce \n                 #(or %1 %2) \n                 (map \n                  #(= (mod (inc n) %) 0)\n                  (range 2 (inc n))))\n               (nextprime (inc n))\n               (inc n)))\n           2)))", "problem": 67, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn[n] (take n \n    (remove \n      (fn[i] (some #(= 0 (mod i %)) (range 2 (inc (int (Math/sqrt i)))))) \n      (iterate inc 2)\n      )\n    ))", "problem": 67, "user": "52e68e61e4b09f7907dd1479"}, {"code": "(fn p\n  ([n] (p 1 2 n))\n  ([i c n] (when (<= i n) (lazy-seq (cons c\n                                       (p (inc i) (loop [c (inc c)]\n                                              (if (not-any? \n                                                   #(= 0 (mod c %))\n                                                   (range 2 (-> c Math/sqrt inc)))\n                                                c\n                                                (recur (inc c)))) n))))))", "problem": 67, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn [n] (take n (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 (+ 1 (/ x 2))))) (iterate inc 2))))", "problem": 67, "user": "52c1f404e4b07a9af5792370"}, {"code": "(fn [x]\n          (letfn [(prime? [n]\n                          (->> (range 2 (inc (int (Math/sqrt n))))\n                              (map (partial rem n))\n                              (filter zero?)\n                              (empty?)))\n                  (pseq [n]\n                        (let [val (when (prime? n) [n])]\n                          (lazy-cat val (pseq (inc n)))))]\n                 (take x (pseq 2))))", "problem": 67, "user": "52d340ebe4b099d49816f0c1"}, {"code": "(fn [n]\n    (let [prime? (fn [i]\n                   (.isProbablePrime\n                    (biginteger i) 10))]\n      (take n (filter prime? (range)))))", "problem": 67, "user": "500d3160e4b05f7c30cfa6a1"}, {"code": "(fn primes\n  [n]\n  (letfn [(sieve\n            [[x & xs]]\n            (cons x (lazy-seq (sieve (filter #(not= 0 (rem % x)) xs)))))]\n    (take n (sieve (map #(+ 2 %) (range))))))", "problem": 67, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn f [n] (take n (lazy-seq (filter (fn e [p]\n  \n   (if (< p 2) false\n   (if (= p 2) true\n      (empty? (filter #(= (mod p %) 0) (range 2 (+ (Math/sqrt p) 1)) ))))\n    \n    \n    \n    \n    ) (range))) ))", "problem": 67, "user": "52bacfa8e4b07a9af57922d6"}, {"code": "(fn [x] (take x (for [i (drop 2(range)) :when (= nil (some #(= 0 (mod i %)) (range 2 i)))] i )))", "problem": 67, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [n] (take n ((fn pseq \n  ([from]\n     (let [is-prime? (fn [n] (every? (comp not zero? (partial rem n)) (range 2 n)))\n           nxt-prime (fn [p] (some #(if (is-prime? %) %) (iterate inc (inc p))))\n           n (nxt-prime from)]\n       (cons n (lazy-seq (pseq n)))))\n  ([] (cons 2 (pseq 2)))))))", "problem": 67, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "(fn prime-list[n]\n  (letfn [(is-prime [k] (let [bound (int (Math/sqrt k))]\n\t   (every? #(not= (rem k %) 0) (range 2 (inc bound))) \n   ))]\n   (take n (filter #(is-prime %) (map #(+ 2 %) (range))))\n   )\n)", "problem": 67, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn primes [n]\n  (letfn [(is-prime? [v]\n                     (loop [x 2]\n                        (if (> x (Math/sqrt v))\n                          true\n                          (if (not= 0 (mod v x))\n                            (recur (inc x))\n                            false))))]\n    (take n (filter is-prime? (range 2 Integer/MAX_VALUE)))))", "problem": 67, "user": "52d809bde4b09f7907dd1384"}, {"code": "(fn [n] (take n (map first (iterate (fn [[x & xs]] (filter #(not= 0 (mod % x)) xs)) (iterate inc 2)))))", "problem": 67, "user": "50742549e4b054001656accf"}, {"code": "(fn primes [n]\n  (letfn [(prime? [n]\n            (every? false? (map #(= 0 (mod n %)) (range 2 (/ (inc n) 2)))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "50c2fbebe4b00e537d00253c"}, {"code": "#(take % ((fn prime ([] (prime 2 []))\n  ([iter sofar]\n     (lazy-seq\n      (if (every? (fn [x] (not (zero? (mod iter x)))) sofar)\n        (cons iter (prime (inc iter) (conj sofar iter)))\n        (prime (inc iter) sofar)))))))", "problem": 67, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn eras [x]\n  (letfn [(sieve [nums]\n                 (let [p (first nums)]\n                   (cons p\n                         (lazy-seq (sieve (filter #(> (rem % p) 0) (rest nums)))))))]\n  \n    (take x (sieve (drop 2 (range))))))", "problem": 67, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn [n] (take n (letfn [(isprime [n] (every? false? (map  #(= (rem n %) 0) (range 2 n))))] (filter isprime (drop 2 (range))))))", "problem": 67, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [n] (take n (for [x (drop 2 (range)) :when (every? #(not= (mod x %) 0) (range 2 x))] x)))", "problem": 67, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn [x]\n\t(take x\n\t\t(filter\n\t\t\t(fn [n] (empty? (filter #(= 0 (mod n %)) (range 2 n))))\n\t\t\t(iterate inc 2))))", "problem": 67, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "(fn [n]\n  (take n\n        (filter\n         (fn [q] (not-any? #(= 0 (mod q %))\n                           (range 2 q)))\n         (drop 2 (range)))))", "problem": 67, "user": "52173464e4b082aa80a88c75"}, {"code": "(fn [n] \n  (take n\n     (filter \n        (fn [x] \n          (not= 0 (reduce *' (map (partial mod x) (range 2 x))))) (iterate inc 2))))", "problem": 67, "user": "5300aa1de4b0d8b024fd3710"}, {"code": "(fn n-primes\n  [n]\n  (loop [l 2 res [2]]\n    (if (<= n (count res))\n      res\n      (let [new (inc l)]\n        (if (every? #(not= % 0) (map #(mod new %) (range 2 l)))\n          (recur new (conj res new))\n          (recur new res))))))", "problem": 67, "user": "5300b750e4b0d8b024fd3711"}, {"code": "(fn [x]\n  (take x\n        (remove\n          (fn [n]\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "52eb400ee4b0705949c4443b"}, {"code": "(fn [n]\n  (take n (filter #(.isProbablePrime (BigInteger/valueOf %1) 5) (take-nth 1 (range 1 Integer/MAX_VALUE)))))", "problem": 67, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn primes [n]\n  (take n (filter #(not (some (fn [d] (zero? (mod % d))) (range 2 (inc (/ % 2))))) (iterate inc 2))))", "problem": 67, "user": "4f48f587e4b0d56e7bb92be2"}, {"code": "(fn [n]\n   (take n (filter #(every? (fn [x] (not (zero? x))) (map (fn [m] (mod % m)) (range 2 (inc (/ % 2))))) (drop 2 (range)))))", "problem": 67, "user": "4fb99483e4b081705acca2da"}, {"code": "(fn [x] (take x (filter (fn [n] (not-any? #(zero? (rem n %)) (range 2 n))) (iterate inc 2))))", "problem": 67, "user": "52f9ce6de4b047fd55836ff0"}, {"code": "(fn primes [x]\n  (let [update (fn [li elem]\n                 (if (some #(zero? (mod elem %)) li)\n                   li\n                   (conj li elem)))]\n    (loop [curr 2\n           acc []]\n      (if (= x (count acc))\n        acc\n        (recur (inc curr) (update acc curr))))))", "problem": 67, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn [c]\n  (take c\n      (filter \n        #(every? (complement zero?) (map (partial rem %) (drop 2 (range %)))) \n        (drop 2 (range)))))", "problem": 67, "user": "52d00832e4b07d0d72b273b4"}, {"code": "(fn [x] (let [facts (fn [x] \n        (loop [facts 1\n               pos 2]\n           (if (< pos (inc (int (/ x 2))))\n            (if (zero? (mod x pos))\n              (recur (inc facts) (inc pos))\n              (recur facts (inc pos))) \n        facts)))]\n      (take x (filter #(= (facts %) 1) (drop 2 (range))))))", "problem": 67, "user": "52fa4f48e4b047fd55836ff7"}, {"code": "#(take % \n        (filter (fn [x] (if (= 2 x) \n                             true \n                            (if (even? x) \n                                false \n                                (loop [y (int (Math/sqrt x))] \n                                      (if (= 1 y) \n                                          true \n                                         (if (= 0 (mod x y)) \n                                             false \n                                             (recur (dec y))))))))\n                 (drop 2 (range))))", "problem": 67, "user": "524469dee4b0d8acf9ed6a9d"}, {"code": "(fn [x]\n  (let\n    [is-prime? (fn [n]\n                 (loop [i 2]\n                   (if (> (* i i) n)\n                     true\n                     (if (= 0 (mod n i))\n                       false\n                       (recur (+ i 1))))))]\n    (loop\n      [tr []\n       z 2]\n      (if (= x (count tr))\n        tr\n        (recur\n         (if (is-prime? z)\n           (conj tr z)\n           tr)\n         (+ z 1))))\n    ))", "problem": 67, "user": "530d85dee4b08068f379eca8"}, {"code": "(fn[n]\n  ((fn m[x p c]\n    (cond\n     (= n c) p\n     (every? #(not= (rem x %) 0) p)\n       (m (+ x 1) (conj p x) (+ c 1))\n     :else (m (+ x 1) p c))) 3 [2] 1))", "problem": 67, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn [n]\n  (letfn [(primes [s]\n\n  (cons (first s)\n\n        (lazy-seq (primes (filter #(not= 0 (mod % (first s)))\n\n                                 (rest s))))))\n]\n    (take n (primes (iterate inc 2)))))", "problem": 67, "user": "52b63875e4b0c58976d9ad41"}, {"code": "#(take % (iterate  \n          (fn f [x]\n  (if (every? false?\n              (for [a (range 2 (inc (Math/sqrt x)))]\n                (= (mod (inc x) a) 0)))\n                (inc x)\n                (f (inc x))))\n          2))", "problem": 67, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [cnt] (take cnt (filter (fn prime? [n] ;; prime? from for docs\n (not-any? zero? (map #(rem n %) (range 2 n)))) (drop 2 (range)))))", "problem": 67, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "#(take % (filter \n  (fn [n]  (every? (fn [m](pos? (mod n m))) (range 2 (Math/sqrt (inc n)))))\n  (drop 2 (range))\n))", "problem": 67, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn lzyprime\n  ([n] (lzyprime n 2))\n  ([n cur]\n     (letfn [(nxtprime [cur]\n               (let [ls (filter #(zero? (rem cur %)) (range 2 (inc (quot cur 2))))\n                     isprime? (empty? ls)]\n                 (if isprime?\n                   cur\n                   (nxtprime (inc cur)))))]\n       (if (zero? n)\n         nil\n         (lazy-seq (cons cur (lzyprime (dec n) (nxtprime (inc  cur)))))))))", "problem": 67, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn [n]\n  (loop [result [], candidate 2, num-left n]\n    (if (= num-left 0)\n      result\n      (let [is-prime\n            (every? #(let [divided (/ candidate %)\n                           evenly-divisible (= (Math/floor divided) (float divided))]\n                       (not evenly-divisible))\n                    (range 2 candidate))\n            new-result (if is-prime (conj result candidate) result)\n            new-num-left (if is-prime (dec num-left) num-left)]\n        (recur new-result (inc candidate) new-num-left)))))", "problem": 67, "user": "53070615e4b02e821686979e"}, {"code": "(fn sieve\n  [n & other]\n  \n  (let [upper-bound 1000]\n  (letfn [(sieve-round \n           [primes candidates]\n           (if (empty? candidates)\n             [primes candidates]\n             (let [prime (first candidates)\n                   multiples (range prime upper-bound prime)]\n               [(conj primes prime) (clojure.set/difference candidates multiples)])))]\n    (let [prime-numbers (or (first other) [])\n          candidates (or (second other) (apply sorted-set (range 2 upper-bound)))]\n      (cond\n       (= n (count prime-numbers)) prime-numbers\n       :else (do\n               (apply sieve n (sieve-round prime-numbers candidates))))))))", "problem": 67, "user": "531490bde4b08068f379ed17"}, {"code": "(fn [cnt]\n  (loop [acc []\n         i 2]\n    (let [is-prime (= (count (filter #(= (mod i %) 0) (range 2 (+ i 1)))) 1)\n          acc-with-prime (if is-prime (conj acc i) acc)]\n      (if (= (count acc) cnt)\n        acc\n\t    (recur acc-with-prime (+ i 1))\n      )\n    )\n  )\n)", "problem": 67, "user": "5303a027e4b0d8b024fd3745"}, {"code": "(fn [n] (letfn [\n(potential-divisors [n] (take-while #(< % (inc (quot n 2))) (cons 2 (range 3 (inc (quot n 2)) 2))))\n(divisors [n] (filter #(zero? (rem n %)) (potential-divisors n)))\n(prime? [n] (zero? (count (divisors n))))\n(primes [] (filter prime? (cons 2 (iterate #(+ % 2) 3))))\n(first-n-prime-numbers [n] (take n (primes)))\n] (first-n-prime-numbers n)))", "problem": 67, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "#(loop [primes [2] candidates (drop 3 (range))]\n\t(if  (>= (count primes) %)\n\t\t(take % primes)\n\t\t(let [rCandidates (filter (fn [candidate] (not= 0 (mod candidate (last primes)))) candidates)]\n\t\t\t(recur (conj primes (first rCandidates)) (rest rCandidates))\n\t\t\t)\n\t))", "problem": 67, "user": "52bf6946e4b07a9af5792334"}, {"code": "(fn [n]\n  (take n (let [prime? #(not-any? zero? (for [i (range 2 %)] (rem % i)))]\n            (cons 2 (filter prime? (iterate #(+ % 2) 3))))))", "problem": 67, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn [t]\n  (letfn [(prime? [n] (every? pos? (for [i (range 2 n)] (mod n i))))]\n    (take t (filter prime? (iterate inc 2)))))", "problem": 67, "user": "530e9729e4b08068f379ecbc"}, {"code": "(fn [n] \n  (loop [sieve [] trial 2] \n    (if (= (count sieve) n) sieve \n      (recur \n       (if (some #(= 0 (mod trial %))\n                 sieve)\n         sieve\n         (conj sieve trial)\n         ) \n       (inc trial)\n       )\n      )\n    )\n  )", "problem": 67, "user": "531d77d7e4b08068f379edaf"}, {"code": "(fn prime [n]\n  (if (= n 1)\n    [2]\n    (let [pn-1 (prime (dec n))]\n      (loop [x (inc (last pn-1))]\n        (if (some true? (map #(= (mod x %) 0) pn-1))\n          (recur (inc x))\n          (conj pn-1 x)\n        )\n      ) \n    )  \n  )\n)", "problem": 67, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn [n]\n  (let [oddnumbers (rest (filter odd? (range)))]\n    (take n\n        (cons 2\n              (filter\n               #(not (reduce\n                      (fn [a b] (or a (= 0 (mod % b))))\n                      false\n                      (take-while (fn [a] (< a  %)) oddnumbers)))\n                 oddnumbers)))))", "problem": 67, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [n] (loop [sieve (iterate inc 2) retr []]\n          (if (>= (count retr) n) retr\n            (let [[p & more] sieve]\n              (recur (keep #(when-not (= 0 (mod % p)) %) more) (conj retr p))))))", "problem": 67, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [x](concat '(2) (take (- x 1) \n      (filter #(= 2\n                  (count (for [n (range 1 (+ % 1) 2)\n                      :when (= 0 (mod % n))]\n                      n)))\n              (range 3 900 2)))))", "problem": 67, "user": "531e5c81e4b08068f379edba"}, {"code": "(fn [n] (take n (filter\n                      (fn [x] (not (some identity\n                                         (for [y (range 2 (/ (inc x) 2))] (= 0 (mod x y))))))\n                      (drop 2 (range)))))", "problem": 67, "user": "51e28063e4b08e53a149f0f2"}, {"code": "#(letfn [(p? [x](->>(repeat x \"1\")(apply str)(re-seq #\"^1?$|^(11+?)\\1+$\")nil?))]\n    (loop [acc [] i 2]\n      (cond (= % (count acc)) acc\n            (p? i) (recur (conj acc i)(inc i))\n            :e (recur acc (inc i)))))", "problem": 67, "user": "530cb5b8e4b02e82168697e0"}, {"code": "(fn p [n]\n  (take n (filter (fn [p]\n                    (every? #(not= 0 (mod p %)) (range 2 p)))\n                  (drop 2 (range)))))", "problem": 67, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn get-primes [x]\n  (let [is-prime? (fn [x]\n                    (loop [n 2]\n                      (if (= n x)\n                        true\n                        (let [r (mod x n)]\n                          (if (zero? r)\n                            false\n                            (recur (inc n)))))))\n        ]\n    (loop [y 2, result []]\n      (if (= x (count result))\n        result\n        (recur (inc y) (if (is-prime? y) (conj result y) result))\n        ))))", "problem": 67, "user": "52cf084ce4b07d0d72b27399"}, {"code": "#(take % (filter (fn [n] (empty? (filter (fn [x] (= 0 (mod n x))) (range 2 n)))) (iterate inc 2)))", "problem": 67, "user": "5323a414e4b09d4e7a9b54d1"}, {"code": "(let [isprime? (fn isprime [n] (not-any? #(= 0 %) (map #(mod n %) (drop 2 (range n)))))]\n  (fn primes ([x] (primes x 2))\n    ([x n]\n    (if (= x 0)\n      []\n      (if (isprime? n)\n        (cons n (primes (- x 1) (+ n 1)))\n        (primes x (+ n 1)))))))", "problem": 67, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn [n] \n  (->>\n  (range)\n  (drop 2)\n  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n  (take n)))", "problem": 67, "user": "52fb64b7e4b047fd55837009"}, {"code": "(fn prime [n]\n  (take n\n\t((fn prime' [xs]\n\t     (let [y (first xs), ys (rest xs)]  \n                  (cons y (lazy-seq (prime'\n\t\t\t    (for [z ys :when (not= 0 (mod z y))] z)\n       \t       \t            ))))\n\t     ) (drop 2 (range)) )))", "problem": 67, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn [y] (take y (filter #(when-not (some #{0} (map (partial rem %) (range 2 %))) %) (iterate inc 2))))", "problem": 67, "user": "51aefceee4b09397d5109797"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (every? #(< 0 (mod n %)) (range 2 n)))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn [amount]\n    (take amount (filter \n                  (fn [n] (= 1 (count (filter #(= (mod n %) 0) (range 1 n))))) \n                  (range))))", "problem": 67, "user": "5329cee2e4b09d4e7a9b551a"}, {"code": "(fn first-primes [n]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [n] (take n ((fn s [x]\n                   (cons (first x)\n                         (lazy-seq (s (filter #(not= 0 (mod % (first x)))\n                                              (rest x))))))\n                 (iterate inc 2))))", "problem": 67, "user": "53034738e4b0d8b024fd373e"}, {"code": "(fn [k] (take k (filter (fn [n] (not-any? zero? (map #(rem n %) (range 2 n)))) (drop 2 (range)))))", "problem": 67, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn n-primes [n]\n  (let [is-prime?   (fn [n]\n                      (cond \n                        (< n 2)\n                         false\n                        (= n 2)\n                         true\n                        (= (mod n 2) 0)\n                         false\n                        :default\n                         (let [mx (int (Math/ceil (inc (Math/sqrt n))))]\n                           (not-any? #(= (mod n %) 0) (range 3 mx 2))\n                           )\n                       )\n                      ) \n        ]\n      (take n (filter is-prime? (iterate inc 0)))\n    )\n  )", "problem": 67, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn [a]\n  (take a \n        (filter \n         (fn [n] \n           (nil? \n            (some zero? (map #(mod n %) (range 2 n))))) \n         (range 2 java.lang.Double/POSITIVE_INFINITY))))", "problem": 67, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "#(take % (filter \n    (fn [y] (empty? (filter (fn [x] (integer? (/ y x))) (range 2 (+ 1 (/ y 2)) )))) \n    (range 2 900))\n)", "problem": 67, "user": "52fba50ce4b047fd5583700d"}, {"code": "(fn [n] \n  (take\n    n\n    (filter\n      (fn [x] \n        (every? \n          #(pos? (mod x %)) \n          (range 2 x)\n        )\n      )\n      (drop 2 (range))\n    ) \n  )\n)", "problem": 67, "user": "52f1bc81e4b05e3f0be25eef"}, {"code": "(fn [n] (take n [2 3 5 7 11 541]))", "problem": 67, "user": "52be0263e4b07a9af579230e"}, {"code": "(fn [n]\n  (take n\n    (letfn [(d [n] #(= 0 (rem % n)))\n            (f [i]\n                 (lazy-seq\n                    (cons (first i)\n                          (f (remove (d (first i)) i)))))]\n       (f (map #(+ 2 %) (range))))))", "problem": 67, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [n]\n    (loop [n (dec n) p [2] c 3]\n      (cond\n       (zero? n) p\n       (empty? (drop-while #(pos? (mod c %)) p)) (recur (dec n) (conj p c) (inc c))\n       :else (recur n p (inc c)))))", "problem": 67, "user": "52d7f9a8e4b09f7907dd1381"}, {"code": "(fn [n] \n\t(loop [i 2 res []]\n    \t(cond\n         \t(= (count res) n) res\n          \t(some #(zero? (mod i %1)) (range 2 (dec i)))\n         \t\t(recur (inc i) res)\n         \t:else\n         \t\t(recur (inc i) (conj res i)))))", "problem": 67, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn primes [n]\n  (letfn [(primeseq [coll]\n                    (cons (first coll)\n                          (lazy-seq (primeseq (remove #(== (mod % (first coll)) 0) (rest coll))))))]\n    (take n (primeseq (rest (rest (range)))))))", "problem": 67, "user": "532727bae4b09d4e7a9b54fa"}, {"code": "(fn [m] (letfn [(prime [n] (if (= n 2) true (reduce  #(and % ((comp not zero?) (rem n %2))) true (range 2 (inc (int (Math/sqrt n)))))))]                              \n(take m (filter #(prime %) (range 2 1e18)))))", "problem": 67, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn [n]\n  (take n (filter (fn [v] (not-any? #(= 0 (rem v %)) (range 2 (dec v)))) (range 2 100000))))", "problem": 67, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (empty? (filter #(integer? (/ x %)) (range 2 x))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "53315c78e4b019098a6f8b67"}, {"code": "(fn nprimes [n]\n  (let [prime? (fn [p]\n                 (if (= p 2)\n                   true\n                   (every? #(not (= 0 %)) (map #(rem p %) (range 2 (+ 1 (/ p 2)))))))]\n    (take n (filter prime? (map #(+ 2 %) (range))))))", "problem": 67, "user": "532b43c3e4b09d4e7a9b5531"}, {"code": "(letfn [(primes\n         [[x & xs]]\n         (lazy-seq\n          (cons x (primes\n                   (remove #(zero? (mod % x))\n                           xs)))))]\n    \n  #(->> (iterate (partial + 2) 3)\n        primes (cons 2) (take %)))", "problem": 67, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [rep]\n   (take rep (filter (fn [n]\n                       (not-any? #(= (mod n %) 0) (range 2 n)))\n                     (iterate inc 2))))", "problem": 67, "user": "5005b57de4b0678c553fc46a"}, {"code": "#(\n\tlet [\n\t\tdv (fn [x] (loop [d 2](if (or (> (* d d) x) (= 0 (rem x d))) d (recur (inc d)))))\n\n\t\tnextprime (fn [x] (loop [nxt (inc x) d (dv nxt)] (if (> (* d d) nxt) nxt (recur (inc nxt) (dv (inc nxt)))))) \n\t]\n\t(take % (iterate nextprime 2))\n)", "problem": 67, "user": "52570aeae4b0541d1855ba42"}, {"code": "(fn solve [num]\n  (letfn [(f [n]\n            (if (some #(= 0 (rem n %)) (range 2 n))\n            (lazy-seq (f (inc n)))\n            (cons n (lazy-seq (f (inc n)))))\n            )]\n    (take num (f 2))))", "problem": 67, "user": "5302ac7fe4b0d8b024fd3731"}, {"code": "(fn [x]\n  (take x\n        (filter (fn [n]\n                  (every? #(> (mod n %) 0) (range 2 n)))\n                (drop 2 (range)))))", "problem": 67, "user": "5336ca32e4b0e30313ee6c80"}, {"code": "(fn [n]\n  (loop [primes [] n n i 2]\n    (if (= n 0) primes\n      (if (some #(= 0 (mod i %)) primes) ; not prime\n        (recur primes n (inc i))\n        (recur (conj primes i) (dec n) (inc i))))))", "problem": 67, "user": "51b41150e4b0f094dd986fac"}, {"code": ";; most simple and ineffective implementation : incremental wilson test\n(fn [n]\n  (loop [prevfact 1 p 2 primes []] ;; keep track of previous factorial to be less ineffective \n    (if (= n (count primes)) primes\n      (recur (*' prevfact p) (inc p) ;; increment p, *' to allow automatic bigint conversion\n        (if (= (dec p) (rem prevfact p)) ;; wilson test (p-1)! = -1 module p\n          (conj primes p)\n          primes)))))", "problem": 67, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn [x]\n  (take x (drop 2\n        (remove\n         (fn [n] (some #(zero? (mod n %)) (range 2 n)))\n         (range)))))", "problem": 67, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn [m]\n  (letfn [(pri-num ([] (pri-num [1]))\n           ([arr]\n            (let [nv (first (filter #(every? pos?\n                                             (map (fn [x]\n                                                    (or (and (<= % x)\n                                                             0)\n                                                        (and (= x 1)\n                                                             %)\n                                                        (mod % x))) arr)) (range)))]\n              (cons nv (lazy-seq (pri-num (conj arr nv)))))))]\n    (take m (pri-num))))", "problem": 67, "user": "5036eba7e4b0af0658af77a5"}, {"code": "(fn [n]\n   (letfn [(p [s]\n      (cons (first s)\n            (lazy-seq (p (filter #(not= 0 (mod % (first s))) (rest s))))))] (take n (p (iterate inc 2)))))", "problem": 67, "user": "506d5e4ce4b0a302964c5493"}, {"code": "(fn [n]\n  (->> (fn [[n sieve is-prime]]\n         (let [inc-sieve (map rest sieve)\n               new-is-prime (every? identity (map first inc-sieve))\n               new-sieve (if new-is-prime\n                           (conj inc-sieve\n                                 (cycle (concat [nil]\n                                                (repeat n :relatively-prime))))\n                           inc-sieve)]\n           [(inc n) new-sieve new-is-prime]))\n       (#(iterate % [2 [(cycle [nil :relatively-prime])] true]))\n       (filter last)\n       (map first)\n       (take n)))", "problem": 67, "user": "51a3b135e4b0e77c4ca60bf6"}, {"code": "(fn [x] (take x \n  (cons 2 (filter (fn [n] (not (some #(zero? (rem n %1)) (range 2 n))))  (filter odd? (range 2 550))))\n ))", "problem": 67, "user": "5311cd03e4b08068f379ecef"}, {"code": "(fn [n] (take n \n              ((fn f [s] \n                 (cons (first s) \n                       (lazy-seq (f (filter #(not (zero? (mod % (first s)))) (rest s))))))\n               (iterate inc 2))))", "problem": 67, "user": "531f7a2de4b08068f379edc6"}, {"code": "(fn [n]\n  (take n(filter\n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "problem": 67, "user": "50436470e4b034ff00315d23"}, {"code": "(fn [n] (take n (iterate #(.nextProbablePrime %) (BigInteger. \"2\"))))", "problem": 67, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [n]\n  (letfn [(is-prime? [x]\n                     (every? #(not (= 0 %)) \n                             (map #(mod x %) (drop 2 (range x)))))\n          (next-prime [x]\n                      (if (is-prime? (+ x 1))\n                        (+ x 1)\n                        (recur (inc x))))]\n    (take n (iterate next-prime 2))))", "problem": 67, "user": "525ab6cfe4b0cb4875a45cf9"}, {"code": "(fn generate-prime-numbers\n  [n]\n  (take n\n    (lazy-seq\n      (filter identity (for [i (map inc (range Integer/MAX_VALUE))]\n                         (if (= 2 (count (filter #(= 0 %) ((fn [x] (lazy-seq (map #(mod x %) (map inc (range x))))) i)))) i))))))", "problem": 67, "user": "52f3af46e4b05e3f0be25f14"}, {"code": "(fn [n] \n  (letfn [(prime? [a]\n                  (let [known-primes #{2 3 5 7 11 13}\n                        known-compos #{0 1 4 6 8 9}]\n                    (if (known-primes a)\n                      true\n                      (if (known-compos a)\n                        false\n                        (not-any? #(zero? (rem a %))\n                                  (range 2 (inc (int (Math/sqrt a)))))))))]\n    (take n (filter prime? (rest (range))))))", "problem": 67, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn [n]\n  (let [accum [2]\n    rec (fn rec [accum]\n      (if (= (count accum) n) accum\n        (rec (conj accum (first\n                               (remove (fn [x] (some #(zero? (rem x %)) accum))\n                                         (drop (inc (last accum)) (range))))))))]\n   (rec accum)))", "problem": 67, "user": "533ee560e4b085b17e897d98"}, {"code": "(fn [x]\n  (take x (filter (fn [y] (not-any? #(= (mod y %) 0) (range 2 y))) (drop 2 (range)))))", "problem": 67, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn x [n]\n  (take n (\n          (fn s [l]\n            (lazy-seq\n             (cons (first l) (s (filter #(not= 0 (mod % (first l))) (rest l))))))\n          (range 2 1000)))\n)", "problem": 67, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [n]\n  (take n\n    (filter\n      (fn long-check \n        ([n] (long-check n (dec n)))\n        ([n d] (cond (= d 1) true\n               (and (even? n) (not (= n 2))) false\n               (= (rem n d) 0) false\n               :else (long-check n (dec d)))))\n      (iterate inc 2))))", "problem": 67, "user": "52fc34cee4b047fd55837015"}, {"code": "(fn [n]\n   (letfn [(is-prime? [k ps]\n             (not (some zero? (map #(mod k %) ps))))]\n     (loop [ps [2]\n            k 3]\n       (if (>= (count ps) n)\n         ps\n         (recur (if (is-prime? k ps)\n                  (conj ps k)\n                  ps)\n                (inc k))))))", "problem": 67, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn prime-range-to [n]\n  (letfn [(sieve [[x & xs]]\n    (lazy-seq (cons x (sieve (remove #(= 0 (mod % x)) xs)))))]\n  (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "533f09e1e4b085b17e897d9a"}, {"code": "#(take %2 (remove (set (for [i % j (range (+ i i) 999 i)] j)) %))\n(range 2 999)", "problem": 67, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [n]\n  (loop [n n p 2 ps []]\n    (if (zero? n)\n      ps\n      (if (not-any? #(= 0 (rem p %)) ps)\n        (recur (dec n) (inc p) (conj ps p))\n        (recur n (inc p) ps)))))", "problem": 67, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn primes \n     [n]\n     (loop [cnt 1\n            x 3\n            d 2\n            ret [2]]\n       (if (= cnt n)\n         ret\n         ; we need to check d : 2..x-1\n         (let [md (mod x d)]\n           (if (and (< d x)\n                    (= md 0))\n             ;it is not prime! Go next~\n             (recur cnt (inc x) 2 ret)\n             ;we are not finish..\n             (if (< d x)\n               (recur cnt x (inc d) ret)\n               ; d == x , go next~\n               (recur (inc cnt) (inc x) 2 (conj ret x))))))))", "problem": 67, "user": "52c58561e4b0c2d177d620f8"}, {"code": "(fn [max]\n  (loop [n 3 primes [2]]\n    (if (= max (count primes))\n      (reverse primes)\n      (if (not-any? zero? (map #(mod n %) primes))\n        (recur (inc n) (cons n primes))\n        (recur (inc n) primes)\n        ))))", "problem": 67, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn primes [n]\n  (letfn [(sieve [seq]\n            (cons (first seq)\n                  (lazy-seq\n                   (sieve\n                    (filter (fn [x] (not (= 0 (mod x (first seq)))))\n                            (rest seq))))))]\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "4e82c062535db62dc21a62cc"}, {"code": "(fn [limit]\n  (letfn [(sieve [[x & xs]] (lazy-seq (cons x (sieve (filter #(pos? (mod % x)) xs)))))]\n    (take limit (sieve (iterate inc 2)))))", "problem": 67, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn primes ([n ps]\n     (let [divides-by\n           (fn [x xs] (some #(= (mod x %) 0) xs))]\n       (if (= n 0)\n         '()\n         (cons\n          (last ps)\n          (primes (dec n) (conj ps (some #(when-not (divides-by %1 ps) %1) (iterate inc (last ps)))))))))\n  ([n]\n   (primes n [2])))", "problem": 67, "user": "534941d1e4b084c2834f4a60"}, {"code": "(fn [n]\n  (let [primes (fn primes [[a & d]] (cons a (lazy-seq (primes (filter #(not= 0 (mod % a)) d)))))]\n    (take n (primes (drop 2 (range))))))", "problem": 67, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(fn primes\n  [x]\n  (let [\n   prime? (fn\n  [n]\n  (cond (< n 2) false\n        (= n 2) true\n        (even? n) false\n        :else \n        (let [r (Math/ceil (Math/sqrt n))]\n          (= (count (filter #(= 0 (mod n %)) (filter odd? (range 3 (+ 1 r))))) 0))))]\n  (take x (filter prime? (range)))))", "problem": 67, "user": "5339af7de4b0e30313ee6cab"}, {"code": "(fn [n]\n  (let [sieve (fn f [s] (cons (first s) (lazy-seq (f (filter #(not= 0 (mod % (first s))) (rest s))))) )]\n    (take n (sieve (iterate inc 2)))))", "problem": 67, "user": "53219cece4b09d4e7a9b54b7"}, {"code": "#(letfn [(prime? [x] (every? (comp (complement zero?) (partial mod x))\n                             (range 2 x)))]\n   (take % (filter prime? (iterate inc 2))))", "problem": 67, "user": "4fceda40e4b03432b189f407"}, {"code": "(fn [m]\n   (->> [2 #{2}]\n        (iterate (fn [[x s]]\n                   (let [y (some (fn [b] (if-not (some #(zero? (rem b %)) s) b))\n                                 (range x (* x x)))]\n                     [y (conj s y)])))\n        (map first)\n        (take m)))", "problem": 67, "user": "5175533fe4b0dea9bbfba575"}, {"code": "(fn [n]\n  (take n (filter\n           (fn is-prime [n]\n             (nil?\n              (some\n               #(zero? (mod n %))\n               (range 2 n))))\n           (drop 2 (range)))))", "problem": 67, "user": "5192dd39e4b0c663c5d86c9e"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n                  (empty? (filter #(zero? %)\n                                  (map #(mod x %)\n                                       (range 2 x)))))]\n    (take n\n          (filter prime?\n                  (iterate inc 2)))))", "problem": 67, "user": "531d34cfe4b08068f379edac"}, {"code": "#(take %\n       (filter\n        (fn [x]\n          (let [xs (range 2 (-> x Math/sqrt Math/floor int inc))]\n            (empty? (filter (fn [y] (zero? (mod x y))) xs))))\n        (iterate inc 2)))", "problem": 67, "user": "5357b241e4b04ce2eb3ed282"}, {"code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "5349da55e4b084c2834f4a68"}, {"code": "(fn [a]\n    (take a (concat [2 3 5 7 11] (range 94) [541])))", "problem": 67, "user": "5356ac72e4b04ce2eb3ed26a"}, {"code": "(fn [N]\n  (let [multiple-of? (fn [a] #(= 0 (mod % a)))\n        series (iterate inc 2)]\n    (take N\n          ((fn sieve [xs]\n             (cons (first xs)\n                   (lazy-seq (sieve (remove (multiple-of? (first xs)) (rest xs))))))\n           series))))", "problem": 67, "user": "5312cdaae4b08068f379ed03"}, {"code": "(fn [n]\n  (take n (filter \n          (fn [m]\n              (loop [x m result []]\n                (if (> x 2)\n                  (recur (dec x) (conj result (= (rem m (- x 1)) 0)))\n                  (not (some #{true} result))\n                )\n              )\n            )\n          (iterate inc 2)))\n  )", "problem": 67, "user": "52d42021e4b09f7907dd132a"}, {"code": "(fn [num]\n    (let [is-prime? (fn [n]\n                      (if (= 1 n) \n                        false\n                        (loop [d 2]\n                          (cond \n                           (= d n) true\n                           (= 0 (mod n d)) false\n                           :else (recur (inc d))))))]\n      (loop [accum []\n             current 1]\n        (if (= (count accum) num) \n          accum\n          (recur (if (is-prime? current)\n                   (conj accum current)\n                   accum) (inc current))))))", "problem": 67, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn [n] (letfn [(sieve [[p & numbers]]\n   (cons\n    p\n    (filter #(not= 0 (mod % p)) (lazy-seq (sieve numbers)))))]\n  \n (take n (sieve (vec (drop 1 (range 1 (* n n))))))))", "problem": 67, "user": "535778dee4b04ce2eb3ed27d"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n                  (.isProbablePrime (BigInteger/valueOf n) 5))]\n    (take n (filter prime? (iterate inc 1)))))", "problem": 67, "user": "4f3d83b5e4b0e243712b1f69"}, {"code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "problem": 67, "user": "5356dcbee4b04ce2eb3ed270"}, {"code": "(fn primes [n]\n    (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (conj (iterate #(+ 2 %) 3) 2))))", "problem": 67, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [n]\n  (loop [r [] x 2 y 2 p #{}]\n   (cond\n    (>= (count r) n) (take n r)\n    (> y x) (recur (concat r (remove p\n                                     (range (* 2 (dec x))\n                                            (* 2 x))))\n                   (inc x)\n                   2 p)\n    :else (recur r x\n                 (inc y)\n                 (conj p (* x y))))))", "problem": 67, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn [number-of-primes]\n  (letfn [(div-2 [number]\n                 (let [d2 (long (/ number 2))]\n                   (if (even? (long (/ number 2)))\n                     (inc d2)\n                     d2)))\n          (prime? [number]\n                  (if (even? number)\n                    false\n                    (empty? (filter #(zero? (mod number %)) (range (div-2 number) 1 -2)))))]\n    (vec (cons 2 (take (dec number-of-primes) (filter prime? (iterate #(+ % 2) 3)))))))", "problem": 67, "user": "52271a85e4b04e78ff2e19a7"}, {"code": "(fn [size]\n    (take \n     size\n     (filter (fn [n] (not-any? #{0} (map (partial rem n) (range 2 (dec n))))) (drop 2 (range)))))", "problem": 67, "user": "52a32876e4b04e0c58e87bfb"}, {"code": "(fn [n] (let [is_prime (fn [x] (if (= x 2) \n                                      true\n                                      (every? #(not= 0 (rem x %)) (cons 2 (filter odd? (range 3 x))))))]\n             (take n (filter is_prime (iterate inc 2)))))", "problem": 67, "user": "5046f909e4b03b02161376b5"}, {"code": "#(let [next-prime (fn [n] (let [n (inc n)\n                          prime? (fn prime? [n] (cond (= n 2) true\n                                                      (= n 1) false\n                                                      :else (loop\n                                                              [n n\n                                                               div (dec n)]\n                                                              (cond\n                                                                (= 1 div) true\n                                                                (zero? (mod n div)) false\n                                                                :else (recur n (dec div))\n                                                                ))))\n                          ] (if (prime? n) n (recur n))))]\n  (take % (iterate next-prime 2)))", "problem": 67, "user": "534d1173e4b084c2834f4a98"}, {"code": "(fn [x]\n  (loop [i 2 r []]\n    (if (= (count r) x)\n      r\n      (if ((fn [n]\n             (some true? (map #(= (mod n %) 0) r)))\n           i)\n        (recur (inc i) r)\n        (recur (inc i) (conj r i))))))", "problem": 67, "user": "51ab70c3e4b04e3dc0c27b33"}, {"code": "(fn sieve\n  [n]\n  (loop [res (range 1 5000)\n         cur (first res)]\n    (let [next (first (filter #(> % cur) res))]\n      (if (not (number? next))\n        (vec (take n (rest (reverse res))))\n        (recur (cons next (filter (fn [e] (not (zero? (mod e next)))) res))\n               next))\n      )))", "problem": 67, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn primes [n]\n  (letfn [(divisible? [n divisor]\n            (zero? (mod n divisor)))\n          (primes-fn [unprimed]\n            (cons (first unprimed)\n                  (->> (rest unprimed)\n                       (remove #(divisible? % (first unprimed)))\n                       primes-fn\n                       lazy-seq)))]\n    (take n (primes-fn (->> (range)\n                              (drop 2)\n                              (primes-fn))))))", "problem": 67, "user": "51891c96e4b04c2714a2670e"}, {"code": "(fn [n]\n  (take n\n   (filter\n    (fn [x]\n      (nil? (some #(zero? (mod x %)) (range 2 (inc (int (/ x 2)))))))\n    (iterate inc 2))))", "problem": 67, "user": "5368a275e4b0243289761e8f"}, {"code": "(fn [n]\n  (let [p (fn [n] (every? #(> (mod n %) 0) (range 2 n)))]\n    (take n (filter p (drop 2 (range))))))", "problem": 67, "user": "536973e5e4b0243289761e9e"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (and (or (= x 2) (odd? x)) (every? #(< 0 (mod x %)) (range 3 (inc (Math/sqrt x)) 2))))]\n    (->> (iterate (partial + 2) 3)\n         (filter prime?)\n         (cons 2)\n         (take n))))", "problem": 67, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn my-primes[num-primes]\n  (loop [current-primes []\n         current-number 2]\n    (if (= num-primes (count current-primes))\n      current-primes\n      (if (some #(= 0 (mod current-number %)) current-primes)\n        (recur current-primes (inc current-number))\n        (recur (conj current-primes current-number) (inc current-number))))))", "problem": 67, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn [s t n]\n  (if (= n 0)\n    s\n    (recur (conj s (first t))\n           (remove #(= 0 (rem % (first t))) t)\n           (- n 1))))\n[]\n(iterate inc 2)", "problem": 67, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "#(take % [2 3 5 7 11 541]); hehe", "problem": 67, "user": "4fa9da14e4b081705acca1e7"}, {"code": "(fn [n]\n    (let [is-prime? (fn [n]\n                      (cond (> 2 n) false\n                            (= 2 n) true\n                            (zero? (mod n 2)) false\n                            :else\n                            (loop [i 3]\n                              (if (> i (Math/sqrt n))\n                                true\n                                (if (zero? (mod n i))\n                                  false\n                                  (recur (+ i 2)))))))]\n      (take n (filter is-prime? (range)))))", "problem": 67, "user": "51c3c6a6e4b0851ac09658f8"}, {"code": "(fn [n]\n  (letfn [(not-factor? [i j] (not= 0 (mod i j)) )\n          (f [i xs]\n            (lazy-seq\n             (cons\n              (first xs)\n              (f\n               (inc i)\n               (filter #(not-factor? % i ) (rest xs))))))\n          ]\n\n    (take n (f 2 (drop 2 (range))))))", "problem": 67, "user": "52f4fae4e4b05e3f0be25f27"}, {"code": "(fn [n]\n    (let [prime? (fn [n] (not-any? #(= (mod n %) 0)\n                                   (range 2 (inc (int (Math/sqrt n))))))\n          primes (filter prime? (drop 2 (range)))]\n      (take n primes)))", "problem": 67, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [x] \n  (let [prime? (fn [n] \n                 (not (some #(= 0 (rem n %)) (range 2 (+ 1 (int (/ n 2)))))))\n        primes (filter prime? (drop 2 (range)))]\n    (take x primes)))", "problem": 67, "user": "53720c5ce4b0493c815db704"}, {"code": "(fn [n]\n  (last (take n (iterate\n                 (fn [dividers]\n                   (let [d (first (filter (fn [x] (not-any? #(zero? (mod x %))\n                                                           dividers))\n                                          (drop (last dividers) (range))))]\n                     (conj dividers d)))\n                 [2]))))", "problem": 67, "user": "5225271fe4b01819a2de42f9"}, {"code": "#(let [primes (fn primes\n               ([] (primes (BigInteger. \"2\")))\n               ([big-integer]\n                 (cons\n                   big-integer\n                   (lazy-seq (primes (.nextProbablePrime big-integer))))))]\n  (take % (primes)))", "problem": 67, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [param]\n((fn primer [x s acc dsieve]\n  (if (> x 0)\n      (primer (dec x) (first dsieve) (conj acc s) (drop 1 (filter #(not= (mod % s) 0) dsieve)))\n    acc)) param 2 [] (drop 3 (range))))", "problem": 67, "user": "52747090e4b03e8d9a4a74a5"}, {"code": "(fn [n]\n  (letfn [(filter-multiples [n xs]\n                           (filter #(not= 0 (mod % n)) xs))\n         (primes-from-sieve [[head & rest :as xs]]\n                            (if (nil? head)\n                              '()\n                              (cons head (lazy-seq (primes-from-sieve (filter-multiples head rest))))))]\n        (take n (primes-from-sieve (drop 2 (range))))))", "problem": 67, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn [n]\n  (let [no-div? #(not-any? zero? (map (partial mod %) (range 2 %)))]\n    (->> (range) (filter no-div?) (drop 2) (take n))))", "problem": 67, "user": "509fe759e4b08df8156e9e43"}, {"code": "(fn [n] (take n ((fn prime [xs]\n  \t\t\t\t\t      (lazy-seq  (cons (first xs)\n             \t\t  (prime (filter #(not= 0 (mod % (first xs))) (rest xs)))))) (iterate inc 2))))", "problem": 67, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn [n](take n (filter #(reduce (fn [is-prime test-num] (and is-prime (not= (mod % test-num) 0)))  true (range 2 (dec %)) ) (range 2 (* n n)))))", "problem": 67, "user": "536046a9e4b063bf7a5f8fe1"}, {"code": "(fn __ [n]\n  (loop [lazy-num (drop 3 (range))\n         i         1\n         acc      [2]]\n    ;;\n    (cond\n     ;; if enough numbers have accumulated, return acc\n     (= i n) acc\n     ;; if current number is not divisible by all numbers in acc, it is a prime\n     (every? #((complement zero?) (rem (first lazy-num) %)) acc) (recur (rest lazy-num)\n                                                                        (inc i)\n                                                                        (conj acc (first lazy-num)))\n     ;; Otherwise, just move on\n     :else (recur (rest lazy-num) i acc))))", "problem": 67, "user": "53415755e4b00652c8746ecd"}, {"code": ";;This solution works better as multiple functions\n;;I decided that trial division is a bad way to answer this question\n;;So I implemented an incremental sieve of Erastothenes.\n\n(fn incremental-sieve-of-erato2\n  [n]\n  (loop [factors []\n         primes []\n         i 2]\n    (if (= (count primes) n)\n      primes\n      (let [new-primes (if (some #(= % i) factors)\n                         primes\n                         (conj primes i))\n            \n            new-factors (if (not= (peek new-primes) i) ;if the latest prime is the current i.\n                          (loop [pre factors\n                                 post []\n                                 lp new-primes]\n                            (if (empty? pre)\n                              post\n                              (recur (rest pre)\n                                     (if (= (first pre) i);if the  equals i (which is a prime if the program has advanced to this logic).\n                                       (conj post (+ (first lp) (first pre)))\n                                       (conj post (first pre))\n                                       )\n                                     (rest lp))))\n                          (conj factors (* 2 (peek new-primes))) ;;else, add the most recent prime (times two!) to the list of factors.\n                          )]\n        (recur new-factors new-primes (inc i)))\n  )))", "problem": 67, "user": "53713ec8e4b0fc7073fd6eae"}, {"code": "(fn [x] (take x [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\n))", "problem": 67, "user": "4dd579b5535dae65d5c462ea"}, {"code": "(fn [c]\n  (loop [n 2 p 2 ps []]\n    (cond\n     (= c (count ps)) ps\n     (< n (* p p)) (recur (inc n) 2 (conj ps n))\n     (= 0 (rem n p)) (recur (inc n) 2 ps)\n     :else (recur n (inc p) ps))))", "problem": 67, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn [n]  \n  \t  (take n (filter (fn [n] (not-any? #(zero? (mod n %)) (range 2 (inc (/ n 2))))) \n (iterate inc 2))))", "problem": 67, "user": "514a3fa5e4b0829bd132edb6"}, {"code": "(fn [n]\n  (loop [current-candidate 2\n         acc []]\n    (cond\n     (>= (count acc) n) acc\n     (empty? (filter #(zero? (mod current-candidate %)) acc))\n             (recur (inc current-candidate) (conj acc current-candidate))\n     :else (recur (inc current-candidate) acc))))", "problem": 67, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn prime [n]\n  (if (= n 1) [2]\n    (let [pp (prime (dec n))]\n      (conj pp (first (drop-while #(some zero? (map (partial mod %) pp)) (map (partial + (inc (last pp))) (range)))))\n      )))", "problem": 67, "user": "536f5900e4b0fc7073fd6e7b"}, {"code": "(fn [n]\n  (let [prime? (fn [v] (not (some #(zero? (mod v %)) (range 2 v))))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "537e745ae4b06839e8705ea6"}, {"code": "(fn [n]\n  (->> (range)\n       (drop 2)\n       (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x))))\n       (take n)))", "problem": 67, "user": "53834ed3e4b06839e8705edb"}, {"code": "(fn [x] \n  (take x \n        (filter #(empty? (filter (comp zero? (partial rem %)) (range 2 %))) \n                (iterate inc 2))))", "problem": 67, "user": "536a37efe4b0243289761eaa"}, {"code": "(fn [x] (take x (filter (fn [y] (every? true? (map #(not= 0 (mod y %)) (range 2 y)))) (iterate inc 2))))", "problem": 67, "user": "53403110e4b085b17e897da6"}, {"code": "(fn [n]\n  (loop [n n, p (biginteger 2), res []]\n    (if (zero? n)\n      res\n      (recur (dec n) (.nextProbablePrime p) (conj res p)))))", "problem": 67, "user": "524b0645e4b09eba1c0223bf"}, {"code": "#(take % \r\n((fn f [x]\r\n  (let [primey? (fn [x]\r\n                  (cond\r\n                   (or (= x 2) (= x 3)) true\r\n                   (even? x) false\r\n                   (<= x 2) false \r\n                   :else (let [possibles (filter odd? (range 2 (inc (Math/sqrt x))))\r\n                               f (fn [n] (= (mod x n) 0))]\r\n                           (if (empty? (filter f possibles))\r\n                             true\r\n                             false))))]\r\n  (lazy-seq\r\n   (if (primey? x)\r\n     (cons x (f (inc x)))\r\n     (f (inc x)))))) 2))", "problem": 67, "user": "5376966ae4b06839e8705e27"}, {"code": "(fn [n]\n    (\n      (fn iter [counter i result]\n        (cond\n          (= counter n) result\n          ((fn prime? [n]\n             (\n               (fn prime?-iter [i]\n                 (if (> (* i i) n)\n                   true\n                   (if (= (rem n i) 0)\n                     false\n                     (recur (inc i))\n                     )))\n               2)) i) (recur (inc counter) (inc i) (conj result i))\n          :else (recur counter (inc i) result)\n          ))\n\n      0 2 [])\n    )", "problem": 67, "user": "5379ed48e4b06839e8705e5a"}, {"code": "(letfn [(prime-nums\n          ([] (prime-nums 2 []))\n\n          ([n base]\n             (cons n\n                   (lazy-seq (loop [n' (inc n)\n                                    base' (conj base n)]\n                               (if-not (some (fn [x] (zero? (rem n' x))) base')\n                                 (prime-nums n' base')\n                                 (recur (inc n') base')))))))]\n  #(take % (prime-nums)))", "problem": 67, "user": "4f409e29e4b0e243712b1fb6"}, {"code": "(fn take-primes [n]\n  (drop 2 (take (+ 2 n) (filter \n                   (fn is-prime? [n]\n                     (not (some #(zero? (rem  n %)) (range 2 n))))\n                   (range)))))", "problem": 67, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn [n]\n  (take n(filter\n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "problem": 67, "user": "538754b1e4b06839e8705f1c"}, {"code": "(fn [n]\n  (loop [res [2] \n         possible (->> (range)\n                       (drop 3) \n                       (remove even?))\n         counter 1]\n    (if (< counter n)\n      (let [current-prime (first possible)]\n      \t(recur (conj res current-prime)\n         \t   (remove #(zero? (mod % current-prime)) possible)\n               (inc counter)))\n      res)))", "problem": 67, "user": "51b24defe4b02f8f128bb963"}, {"code": "(fn primes \n  ([n] (primes 2 n))\n  ([i n]\n  (letfn [(prime? [num]\n                  (not (some #(= 0 (rem i %1)) (range 2 num))))]\n    (cond\n     (= n 0) '()\n     (prime? i) (conj (primes (inc i) (dec n))\n                      i)\n     :else (primes (inc i) n)))))", "problem": 67, "user": "5374adc3e4b06d7f452d9e27"}, {"code": "#(take % (conj (filter\n                (fn [x]\n                  (loop [y 2]\n                    (and (not= (mod x y) 0)\n                         (or (>= (* y y) x)\n                             (recur (+ y 1))))))\n                (range 3 999)) 2))", "problem": 67, "user": "538d8bb8e4b0b51d73faae71"}, {"code": "(fn primes [c]\n  (loop [p [2] n 3]\n    (if (= c (count p))\n      p\n      (if (empty? (filter #(zero? (rem n %)) p))\n        (recur (conj p n) (inc n))\n        (recur p (inc n))))))", "problem": 67, "user": "4f849f76e4b033992c121c36"}, {"code": "(let [runner  (fn runner [seen left]\n                  (lazy-seq\n                   (let [x (first left)]\n                     (if (some #(zero? (mod x %)) seen)\n                       (runner seen (rest left))\n                       (cons x (runner (conj seen x) (rest left))))))),\n      primes  (runner #{} (map #(+ 2 %) (range)))]\n  (fn [n]\n    (take n primes)))", "problem": 67, "user": "53889587e4b0640c7a9a589e"}, {"code": "(letfn [(R [x] (fn [y] (not (zero? (rem y x)))))\n        (S [xs]\n          (cons (first xs)\n                (lazy-seq (S (filter (R (first xs))\n                                     (rest xs))))))\n        (P [n]\n          (take n (S (drop 2 (range)))))]\n  P)", "problem": 67, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn [n]\n  (take n\n        (filter (fn [n]\n                  (empty? (filter #(= 0 (mod n %))\n                                   (range 2 n))))\n                (drop 2 (range)))))", "problem": 67, "user": "4ec53f8c535d6d7199dd368b"}, {"code": "(fn [n]\n  (let [next-prime (fn [[x y]]\n           (if (not-any? #(= 0 (mod x %)) y)\n             [(inc x) (conj y x)]\n             [(inc x) y]))]\n    (loop [[candidate primes] [2 []]]\n      (if (< (count primes) n)\n        (recur (next-prime [candidate primes]))\n        primes))))", "problem": 67, "user": "533018b2e4b019098a6f8b56"}, {"code": "(fn [x]\n  (take x\n        (iterate #(.nextProbablePrime %) (BigInteger. \"2\"))))", "problem": 67, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(fn [n]\n  (letfn [(is-prime [x] (every? #(> (rem x %) 0) (range 2 (+ 0.5 (Math/sqrt x)))))]\n    (take n (filter is-prime (drop 2 (range))))))", "problem": 67, "user": "537f4652e4b06839e8705eb1"}, {"code": "(letfn [\n    (is_prime [x] (not (if (<= x 3) false (some #(= (rem x %) 0) (range 2 (- x 1))))))\n    (next_prime [x] (if (is_prime x) x (next_prime (inc x))))\n    (primes [x] (cons (next_prime x) (lazy-seq (primes (next_prime (inc x))))))\n] \n    (fn [x] (take x (primes 2)))\n)", "problem": 67, "user": "5356d00ee4b04ce2eb3ed26f"}, {"code": "(fn [x] (take x (filter (fn [n] (if (< n 2)\n                                  false\n                                  (loop [current (quot n 2)]\n                                    (if (<= current 1)\n                                      true\n                                      (if (= 0 (mod n current))\n                                      \tfalse\n                                        (recur (dec current))))))) (range))))", "problem": 67, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn [n]\n  (letfn [(prime? [n] (->> (range 2 (dec n))\n                           (map #(/ n %))\n                           (filter integer?)\n                           empty?))]\n  (->>\n   (range 2 Long/MAX_VALUE)\n   (filter prime?)\n   (take n)\n   vec)))", "problem": 67, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn [n]\n  (let [sieve (fn sieve [xs] (cons (first xs) (lazy-seq (sieve (filter #(> (mod % (first xs)) 0) (rest xs))))))]\n    (take n (sieve (drop 2 (range))))))", "problem": 67, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn[x] \n    (letfn [\n               (prime? [n]\n                       (not-any? zero? (map #(mod n %) (range 2 (inc (quot n 2))))))\n               (lpr [n]\n                 (if (prime? n)\n                     (cons n (lazy-seq (lpr (inc n))))\n                     (lazy-seq (lpr (inc n)))))]\n        (take x (lpr 2))))", "problem": 67, "user": "52bc6cb2e4b07a9af57922f5"}, {"code": "(fn primes [n]\n  (loop [p [2 3]\n         c 5]\n    (if (= (count p) n) p\n      (recur (if (every? ratio? (map #(/ c %) (take-while #(<= (* % %) c) p)))\n               (conj p c) p)\n             (+ 2 c)))))", "problem": 67, "user": "53973e7be4b0b51d73faaee6"}, {"code": "(fn [n]\n  (let [prime? (fn [n]\n                 (every? #(not= 0 (rem n %)) (range 2 n)))]\n    (take n (filter prime? (iterate inc 2)))))", "problem": 67, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn [n]\n  (let [factor (fn factor [n]\n                 (let [lower-numbers (range 1 (inc n))]\n                   (filter #(integer? (/ n %)) lower-numbers)))\n        is-prime (fn is-prime [n]\n                   (= 2 (count (factor n))))\n        next-prime (fn next-prime [n]\n                     (let [next-n (inc n)]\n                       (if (is-prime next-n) next-n (next-prime next-n))))\n        primes (fn primes \n                 ([] (primes 2))\n                 ([first-prime] (cons first-prime (lazy-seq (primes (next-prime first-prime))))))]\n    (take n (primes))))", "problem": 67, "user": "53940789e4b0b51d73faaec3"}, {"code": "(fn primes [n]\n  (loop [ps [], start 2]\n    (if (= n (count ps))\n      (seq ps)\n      (let [next-p (->> start\n                        (iterate inc)\n                        (filter (fn [x] (every? #(not= 0 (rem x %)) ps)))\n                        first)]\n        (recur (conj ps next-p) (inc next-p))))))", "problem": 67, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "(fn prime-seq [num]\n       (take num\n             (iterate\n              (fn iterate-prime [x]\n                ;; Find the next prime greater than x\n                (loop [possibility (inc x)]\n                  (if (not-any? #(zero? (rem possibility %))\n                                (range 2 possibility))\n                    possibility\n                    (recur (inc possibility)))))\n              2)))", "problem": 67, "user": "53838742e4b06839e8705ee0"}, {"code": "(fn nprimes [n]\n  (letfn [(all-primes [] \n            (reductions\n             (fn [primes number]\n               (letfn [(isprime? [n]\n                         (let [test-primes-until (take-while #(<= (* % %) n) primes)\n                               not-divisible? #(not= 0 (mod n %))] \n                           (every? not-divisible? test-primes-until)))]\n                 (if (isprime? number)\n                   (conj primes number)\n                   primes)))\n             []\n             (iterate inc 2N)))]\n    (first (take 1 (drop-while #(not= (count %) n) (all-primes))))))", "problem": 67, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn prime [cnt] (take cnt \n                      (remove #(nil? %) \n                              (map (fn [n] (if(nil? (some #(= (rem n %) 0) (range 2 n))) n))(range 2 1000)))))", "problem": 67, "user": "534c1c64e4b084c2834f4a8a"}, {"code": "(fn\n  [n]\n  (let [odds (range 3 Double/POSITIVE_INFINITY 2)]\n    (letfn [(divides? [n d] (= 0 (mod n d)))\n            (is-prime [n] (cond\n                            (< n 2) false\n                            (= n 2) true\n                            (divides? n 2) false\n                            :else (let [divs (take-while #(<= (* % %) n)\n                                                         odds)]\n                                    (nil? (some (partial divides? n) divs)))))]\n      (take n (cons 2 (filter is-prime odds))))))", "problem": 67, "user": "52dfc89be4b09f7907dd1405"}, {"code": "(fn [n]\n      (letfn [(prime [coll]\n                (let [f (first coll)]\n                  (cons f (lazy-seq (prime (filter #(not= 0 (mod % f)) (rest coll)))))))]\n        (take n (prime (iterate inc 2)))))", "problem": 67, "user": "52c49401e4b0c2d177d620de"}, {"code": "(fn [n] (take n (reduce #(if (empty? (for [x %1 :let [y :notprime] :when (= (mod %2 x) 0)] y)) (conj %1 %2) %1) [2] (range 3 (* n 10) 2))))", "problem": 67, "user": "53a1b5c8e4b0ca733b9744c1"}, {"code": "(fn [n]\n  (->> (iterate inc 2)\n       (filter #(not-any? (fn [x]\n                            (zero? (mod % x)))\n                          (range 2 %)))\n       (take n)))", "problem": 67, "user": "5398305fe4b0b51d73faaef6"}, {"code": "(fn get-primes [n]\n  (loop [primes []\n         cur 2]\n    (if (or (>= (count primes) n))\n      primes\n      (recur \n       (if (empty? (filter #(= 0 (rem cur %)) primes)) (conj primes cur) primes)\n       (inc cur)))))", "problem": 67, "user": "538c3424e4b0b51d73faae58"}, {"code": "(fn [n] \n  (take n \n        (drop 2 \n              (filter (fn [x] (not-any? #(= 0 (rem x %)) (range 2 x)))\n                      (range)))))", "problem": 67, "user": "53976599e4b0b51d73faaeea"}, {"problem": 67, "code": "(fn generate-primes\n  [num-primes]\n  (let [is-prime? (fn [x cur-divisor]\n                    (if (= cur-divisor x)\n                      true\n                      (if (= 0 (mod x cur-divisor))\n                        false\n                        (recur x (inc cur-divisor)))))]\n    (take num-primes (filter #(is-prime? % 2) (range 2 (* num-primes num-primes))))))", "user": "52af7a5ce4b0c58976d9acbd"}, {"problem": 67, "code": "(fn x-primes [x]\n    (loop [n 2\n           p []]\n        (letfn [(is-prime? [n]\n                      (cond (<= n 1) false\n                            (= n 2) true\n                            :else (loop [f 2]\n                                      (cond (zero? (rem n f)) false\n                                            (> f (Math/sqrt n)) true\n                                            :else (recur (inc f))))))]\n            (if (>= (count p) x) p\n                                 (recur (inc n) (if (is-prime? n) (concat p [n]) p))))))", "user": "532c9dc9e4b019098a6f8b30"}, {"problem": 67, "code": "(fn [x]\n  (let [isPrime? (fn [y]\n    (loop [y y\n          t (dec y)]\n      (cond\n        (= t 1) true\n        (= (rem y t) 0) false\n        :else (recur y (dec t)))))]\n  \n    (take x (filter isPrime? (drop 2 (range))))))", "user": "53778b90e4b06839e8705e36"}, {"problem": 67, "code": "(fn prime [n]\n  (take n\n    (filter (fn p [x]\n      (empty? (filter #(zero? (mod x %)) (range 2 x))))\n    (range 2 Double/POSITIVE_INFINITY))))", "user": "53a19dece4b0ca733b9744c0"}, {"problem": 67, "code": "(fn [n]\n  (loop [curr-n 0 primes [] curr-num 2]\n    (if (== curr-n n)\n      primes\n    (if (every? false? (map #(integer? (/ curr-num %)) (range 2 (+ (int (Math/sqrt curr-num)) 1))))\n      (recur (inc curr-n) (conj primes curr-num) (inc curr-num))\n      (recur curr-n primes (inc curr-num))\n      )\n    )\n  ))", "user": "538e864ee4b0b51d73faae87"}, {"problem": 67, "code": "(fn primes \n\t([n] (take n (primes [] 2)))\n\t([xs x]\n\t(let [prime? (not-any? #(zero? (rem x %1)) (range 2 x))]\n\t\t(if prime? \n\t\t\t(cons x (lazy-seq (primes (conj xs x) (inc x))))\n\t\t\t(lazy-seq (primes xs (inc x)))))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 67, "code": "(fn [qty] \n  (take qty (filter (fn prime? [x] \n  (not (some #(zero? (rem x %)) (range 2 x)))) (drop 2 (range)))))", "user": "53a5c7ffe4b0ef122a8689c4"}, {"problem": 67, "code": "(fn [c]\n  (let [prime? (fn [n]\n                 (if (= 1 n)\n                   false\n                   (not-any? zero? (map #(mod n %) (range 2 n)))))]\n    (take c (filter prime? (drop 2 (range))))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n            (not (some zero? (map (partial rem x) (range 2 (dec x))))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 67, "code": "#(take % (cons 2 (\n(fn ff [n col]\n  (let [s (filter (fn [p] (not= 0 (mod p n))) col)\n        f (first s)\n        n (next s)]\n    (cons f (lazy-seq (ff f n)))))\n                  2 (iterate inc 2))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 67, "code": "(let [primes \n      ((fn sieve [candidates]\n         (let [new-prime (first candidates)]\n           (->> candidates\n                rest\n                (filter #(not (zero? (mod % new-prime))))\n                sieve\n                lazy-seq\n                (cons new-prime))))\n       (iterate inc 2))]\n  #(take % primes))", "user": "526e5159e4b03e8d9a4a7316"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? (fn [n]\n                (if (or (and (even? n) (not= n 2)) (< n 2))\n                  false\n                  (let [rt (Math/floor (Math/sqrt n))\n                        factors (for [x (range 3 (inc rt) 2) :when (= 0 (rem n x))] x)]\n                    (empty? factors))))]\n  (take n (cons 2 (for [x (iterate (partial + 2) 3) :when (prime? x)] x)))))", "user": "5396c94be4b0b51d73faaee3"}, {"problem": 67, "code": "(fn [x] (apply vector (take x ((fn [x]\n                                     (letfn [(prime? [x]\n                                               (if (> x 3)\n                                                 (every? #(not (zero? (mod x %))) (range 2 (+ 1 (Math/sqrt x))))\n                                                 (if (< x 2) false true)\n                                                 )\n                                               )]\n                                       (filter prime? (range 2 (inc x))))) Integer/MAX_VALUE))))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "52a5a8ebe4b0c58976d9abed"}, {"problem": 67, "code": "(fn primes [n]\n  (let [none-divides (fn [numbers n]\n                       (let [divisors (filter #(= 0 (rem n %)) numbers)]\n                         (nil? (first divisors))\n                         )\n                       )\n        next-prime (fn [so-far]\n                     (first (filter #(none-divides so-far %) (iterate inc (inc (last so-far)))))\n                     )\n        primes-seq (fn primes-seq [so-far]\n                     (let [np (next-prime so-far)]\n                       (cons np (lazy-seq (primes-seq (conj so-far np)))\n                     )))]\n    (take n (cons 2 (primes-seq [2])))\n  ))", "user": "5245e320e4b09dbe66b56177"}, {"problem": 67, "code": "(fn n-primes [n]\n  (letfn [(prime? [k]\n            (not-any? #(zero? (mod k %)) (range 2 (inc (/ k 2)))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 67, "code": "(fn [c]\n  (take c (filter (fn [n] (= 2 (count (filter #(zero? (rem n %)) (range 1 (inc n)))))) (iterate inc 2)))\n)", "user": "53ae16e2e4b047364c044472"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [[x & xs]]\n                 (cons x (lazy-seq (sieve (filter #(pos? (rem % x)) xs)))))]\n    (take n (cons 2 (sieve (iterate (partial + 2) 3))))))", "user": "5290257ae4b0239c8a67af03"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [n]\n           \t(or (= n 2) (not-any? #(= 0 (rem n %))(range 2 n))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 67, "code": "(fn take-primes[n]\n\t(take n (filter \n\t\t(fn is-prime [n] \n\t\t\t(not (some #(= (mod n %) 0)\n\t\t\t\t\t(range 2 (dec n))))) (iterate inc 2))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 67, "code": "(fn gen-primes\n  [how-many]\n  (letfn [(indivisible [n ds]\n                     (not-any? #(= 0 (mod n %)) ds))\n          (next-prime [acc]\n                      (if (nil? (last acc))\n                        2\n                        (loop [curr (inc (last acc))]\n                          (if (indivisible curr acc)\n                            curr\n                            (recur (inc curr))))))]\n    (loop [acc []\n           remaining how-many]\n      (if (= 0 remaining)\n        acc\n        (recur \n         (conj acc (next-prime acc))\n         (dec remaining))))))", "user": "53ac4719e4b047364c04445c"}, {"problem": 67, "code": "(fn f [n] (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range 1 Integer/MAX_VALUE)  ) ))", "user": "53b3ea79e4b047364c0444ab"}, {"problem": 67, "code": "(fn primes [x]\n  (if (= x 1) \n    [2]\n    (let [known (primes (dec x))]\n      (conj known\n            (first (filter #(not-any? (fn [p] \n                               (= (mod % p) 0))\n                             known)\n                  (iterate inc (inc (last known)))))))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 67, "code": "(fn [x]\n     (letfn [(prime? [n]\n                     (every? #((complement =) (mod n %) 0) (range 2 (dec n))))]\n            (cons 2 (take (dec x) \n                          (filter prime?  (iterate inc 3))))))", "user": "4f867b25e4b033992c121c51"}, {"problem": 67, "code": "(fn n [x]\n  (take x\n  \t(filter \n      (fn prime [x](= (count(filter #(zero? (mod x %1)) (range 2 x))) 0))\n      (iterate inc 2))))", "user": "51897709e4b0288ada3dbdaa"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n          (if (pos? x)\n            (if (prime? n pvec)\n              (recur (dec x) (+ n 2) (conj pvec n))\n              (recur x (+ n 2) pvec))\n            pvec))]\n    (gen-primes (dec x) 3 [2])))", "user": "52ee46e5e4b05e3f0be25ec5"}, {"problem": 67, "code": "(fn my-sieve [n]\n  (let [ceiling (+ 4 (* (Math/log n) n) (* n (Math/log (Math/log n)))) \n        candidates (range 2 (Math/floor ceiling))]\n    (loop [x 2 survivors candidates primes []]\n      (if (or (nil? x) (> x (last candidates)))     \n        (take n primes)                ;; base case: take n from the proven primes\n        (recur\n         (some #(if (> % x) %) survivors)          ;; x for next round\n         (filter #(or (< % x)\n                      (> (mod % x) 0)) survivors) ;; survivors for next round\n                      (conj primes x))))))           ;; and the primes!", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 67, "code": "(fn get-prime [x]\n\t(take x (filter (fn is-prime [n] (not (some #(= 0 (rem n %)) (range 2 n)))) (range 2 (Integer/MAX_VALUE)))))", "user": "52b71bd2e4b0c58976d9ad4d"}, {"problem": 67, "code": "(fn my-prime [num]\n\t(letfn [(prime? [n]\n\t\t       (if (>= 1 (count (filter #(= 0 (mod n %)) \n\t\t       \t     (take (dec n) (iterate inc 2)))))\n\t\t         true\n\t\t         false))]\n\t(take num (filter prime? (take (* num num) (iterate inc 2))))))", "user": "53858594e4b06839e8705f05"}, {"problem": 67, "code": "(fn primes [x]\n   (take x (filter\n            (fn p [candidate] (empty? (filter #(zero? (mod candidate %)) (range 2 candidate))))\n            (iterate inc 2))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 67, "code": "(fn generate-primes [n]\n  (letfn [(and-fn [a b] (and a b))\n          (prime? [n primes] \n                  (reduce and-fn (map (fn [x] (or (> x (Math/sqrt n)) (not (== 0 (mod n x))))) primes)))]\n    ((fn generator [current results]\n    (if (<= n (.size results))\n      results\n      (if (empty? results)\n      \t(generator (+ current 1) (conj results current))\n        (let [bound (Math/sqrt current)]\n          (generator (+ 2 current) (if (prime? current results) (conj results current) results)))))) 2 [])))", "user": "537f8e7be4b06839e8705eb8"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (remove\n          (fn [x]\n            (some #(= 0 (rem x %)) (range 2 (inc (Math/round (Math/sqrt x))))))\n          (iterate inc 2))))", "user": "4fe3338ee4b0e8f79898fea8"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter (fn [x]\n                  (not-any? #(= 0 (mod x %)) (range 2 x))) (iterate inc 2))))", "user": "53bd8d27e4b0d9a98559a6d6"}, {"problem": 67, "code": "(fn [n] \n  (->> (range)\n\t   (drop 2)\n       (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n       (take n)))", "user": "51e3a549e4b0c611d6113e47"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [prevPrimes [2 3]]\n    (if (< (count prevPrimes) n)\n      (recur (conj prevPrimes \n                   (first \n                     (filter \n                       (fn [x] \n                         (every? \n                           #(not= 0 (mod x %))\n                           prevPrimes)) \n                       (map (partial + (last prevPrimes)) (range))))))\n      (take n prevPrimes))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes []\n         current 2]\n    (if (= n (count primes))\n      primes\n      (if (not-any? identity (map #(= 0 (rem current %)) primes))\n        ;;prime\n        (recur (conj primes current) (inc current))\n        ;;not prime\n        (recur primes (inc current)))))\n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 67, "code": "(fn gen-primes [n] (let [my-gen-primes (remove (fn [b] (some (fn [x] (= 0 (mod b x)) ) (range 2 (inc (int (Math/sqrt b)))))) (iterate inc 2))] \n                     (take n my-gen-primes)))", "user": "539b4268e4b0b51d73faaf1c"}, {"problem": 67, "code": "(fn prime [n]\n  (take n (cons 2\n        (lazy-seq\n         (letfn [(prime [ps ds]\n                        (when-let [x (first ds)]\n                          (if (some #(= 0 (mod x %)) ps)\n                            (recur ps (rest ds))\n                            (lazy-seq (cons x (prime (conj ps x) (rest ds)))))))]\n           (prime [2] (drop 3 (range))))\n         ))))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 67, "code": "(fn[n]\n  (take n (iterate #(.nextProbablePrime %) (BigInteger. \"2\"))))", "user": "4e8849c5535d8b9bb0147ca4"}, {"problem": 67, "code": "(fn [n] (letfn [(sieve [s]\n                   (cons (first s)\n                         (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                  (rest s))))))]\n           (take n (sieve (iterate inc 2)))))", "user": "538db083e4b0b51d73faae74"}, {"problem": 67, "code": "(fn [x]\n (last  ( take x\n  (iterate       (fn prime [xs]\n           (loop [k (inc (last xs))]\n             (let [ss (map #(rem k %) xs)]\n                  (if (every? #(not= 0 %) ss )\n                    (conj xs k)\n                    (recur (inc k))\n                    )\n                  )\n             )\n\n          ) [2] ) )))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 67, "code": "(fn [x]\n  (loop [rm (range 2 (* 10 x)), acc []]\n    (let [f (first rm)]\n      (cond (= x (count acc)) acc\n            :else (recur (remove #(= 0 (mod % f)) rm) (conj acc f))))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 67, "code": "(fn [n]\n  (let [primes (fn primes [ps]\n                  (let [n (inc (last ps))\n                        find-first (fn [pred coll] (first (filter pred coll)))\n                        prime? (fn [ps x] (every? #((complement zero?) (mod x %)) ps))\n                        p (find-first (partial prime? ps) (iterate inc n))]\n                        (cons p (lazy-seq (primes (conj ps p))))\n                    ))]\n    (take n (cons 2 (primes [2])))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime? (fn [x]\n        (nil? (some #(zero? (mod x %)) (range 2 (inc (int (Math/sqrt x)))))))]\n    (take n (filter is-prime? (range 2 Double/POSITIVE_INFINITY)))))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 67, "code": "(fn prime [n]\n  (cond\n    (= n 1) [2]\n    (= n 2) [2 3]\n    :else\n      (loop [r [2 3], x 5]\n        (if (= (count r) n)\n          r\n          (if ((fn is-prime? [i]\n                (not\n                   (some\n                      #(= (mod i %) 0)\n                      (range 3 i 2)\n                 ))\n               ) x)\n            (recur (conj r x) (+ x 2))\n            (recur r (+ x 2))\n          )\n        )\n      )\n   )\n)", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 67, "code": "#(take % (filter \n   (fn is-prime [n] \n     (and\n       (> n 1)\n       (every? \n          (comp (complement zero?) (partial rem n)) \n          (range 2 n)\n       )\n     )\n  ) \n(range))\n)", "user": "53d5e45ae4b0e771c302544e"}, {"problem": 67, "code": "(fn prime [n]\n  (take n \n    (filter (fn p [x]\n      (empty? (filter #(zero? (mod x %)) (range 2 x))))\n    (range 2 Double/POSITIVE_INFINITY))))", "user": "53da19fde4b0e771c3025484"}, {"problem": 67, "code": "(fn get_primes[n]\n  (let [is_prime (fn [x]\n          (loop [count 2\n                 ret true]\n            (println count ret)\n            (if (> count (Math/pow x (/ 1 2) ))\n              ret\n              (recur (+ 1 count) (and ret (> (mod x count) 0))))))] \n    (loop [count 0\n          result []\n          x 2]\n      (if (= count n)\n        result\n        (if (is_prime x)\n          (recur (+ 1 count) (conj result x) (+ 1 x))\n          (recur count result (+ 1 x)))))))", "user": "53e241a6e4b036ad0777e3f0"}, {"problem": 67, "code": "(fn [x]\n\t(loop [primes [2]\n\t\t   current 3]\n\t\t   (if (= (count primes) x) primes\n\t\t\t (recur (if (every? true? (map #(not= 0 (rem current %)) primes)) (conj primes current) primes) (+ 2 current)))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 67, "code": "(fn p [hi]\n  (if (zero? hi) []\n    (let [ps (p (dec hi))]\n      (->> (iterate inc (or (peek ps) 2))\n           (filter (fn [x] (every? #(pos? (mod x %)) ps)))\n           first\n           (conj ps)))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 67, "code": "(fn [c]\n    (take c\n          (reduce (fn [coll pos]\n                    (let [seed (nth coll pos)]\n                      (filter #(or (<= % seed) (not (zero? (rem % seed)))) coll)))\n                  (drop 2 (range))\n                  (range c))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 67, "code": "(fn [n]\n  (take n\n       ((fn sieve [s]\n          (cons (first s)\n                (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                         (rest s))))))\n        (iterate inc 2))\n        )\n  )", "user": "53dd37aee4b0d874e779ae28"}, {"problem": 67, "code": "(fn get-primes [num-primes]\n    (loop [current-prime 2 all-primes [current-prime] ints (range 1000)]\n      (if (= num-primes (count all-primes))\n        all-primes\n        (let [sorted-ints ((fn not-multiples-of [p col]\n                             (filter (fn [x]\n                                       (if (= x p)\n                                         true\n                                         (not= 0 (mod x p))))\n                                     col)) current-prime ints)\n              next-prime ((fn next-item [item col]\n                            (let [pos (first ((fn pos [item col]\n                                                (->> col\n                                                     (map-indexed #(when (#{item} %2) %1))\n                                                     (remove nil?))) item col))]\n                              (get (into [] col) (+ pos 1)))) current-prime sorted-ints)]\n          (recur next-prime (conj all-primes next-prime) sorted-ints)))))", "user": "5389fe49e4b0640c7a9a58b4"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "516d227fe4b06f078fab252d"}, {"problem": 67, "code": "(fn [n]\n  ((fn g [x c]\n     (if (= (count c) n)\n       c\n       (g (+ x 1)\n          (if\n            (reduce #(and % (> (rem x %2) 0)) 1 (range 2 x))\n            (conj c x)\n            c)))) 2 []))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 67, "code": "(fn [x] (take x (iterate #(.nextProbablePrime %) (BigInteger. \"2\"))))", "user": "4e6961f0535d8ccf87e9fe9b"}, {"problem": 67, "code": "(fn primes [x]\n  (letfn [(prime? [n]\n                  (if (= n 1)\n                    false\n                    (loop [d (int (Math/floor (Math/sqrt n)))]\n                      (if (= d 1)                     \n                        true\n                        (if (= (mod n d) 0)\n                          false\n                          (recur (dec d)))))))]\n    (letfn [(get-primes [s]\n                        (if (prime? s)\n                          (cons s (lazy-seq (get-primes (inc s))))\n                          (get-primes (inc s))))]\n      (take x (get-primes 1)))))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter \n             (fn [i] (cond (< i 2) false\n                            true (every? (fn [j] (> (mod i j) 0)) \n                                         (range 2 i))))\n             (range))))", "user": "53e91473e4b036ad0777e495"}, {"problem": 67, "code": "(fn get-primes [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "53c126fce4b00fb29b22125b"}, {"problem": 67, "code": "#(let [ m (+ 10 (* 2 % (Math/log %))) r range] (take % (sort (clojure.set/difference (set (r 2 m)) (set (flatten (for [i (r 2 (Math/sqrt m))] (for [j (r 2 (/ m i))] (* j i)))))))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 67, "code": "; produce the first n primes\n; this is nto quite right (the nlogn limit)\n(fn foo [n]\n  (take n (let [nlogn (max 10 (* 3 n (Math/log n)))]\n            (loop [i 3 ps (cons 2 (range 3 nlogn 2))]\n              (if (> (* i i) nlogn) ps\n                (recur (+ i 2)\n                       (filter #(or (= % i) (pos? (mod % i))) ps)\n                       ))))))", "user": "53dadf1de4b0e771c30254ad"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (let [upper-bound (if (< n 6) 12 (+ (* n (Math/log n)) (* n (Math/log (Math/log n)))))\n        possible-primes (range 2 upper-bound)\n        non-primes (apply clojure.set/union \n                     (for [factor (range 2 (/ upper-bound 2))]\n                       (set (rest (range factor upper-bound factor)))))]\n    (take n (remove non-primes possible-primes))))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 67, "code": "(fn [n]  \n  (loop [p [2] c 3]\n    (if (= n (count p)) \n      p\n      (let [divide-repeatedly #(if (zero? (rem %1 %2)) (recur (/ %1 %2) %2) %1)\n            result (reduce divide-repeatedly c p)]\n        (if (= result 1)\n          (recur p (inc c))\n          (recur (conj p c) (inc c)))))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 67, "code": "(fn primes [mm]\n  (let [minus (fn minus [l1 l2]\n                (cond\n                 (empty? l1) ()\n                 (empty? l2) l1\n                 :else (let [c (compare (first l1) (first l2))]\n                         (cond\n                          (< c 0) (cons (first l1) (minus (rest l1) l2))\n                          (> c 0) (minus l1 (rest l2))\n                          :else (minus (rest l1) (rest l2))))))\n        primes (fn [m]\n                 (let [seive (fn seive [xss]\n                               (let [p (first xss)\n                                     xs (rest xss)]\n                                 (if (> (* p p) m)\n                                   (cons p xs)\n                                   (cons p (seive (minus xs (range (* p p)\n                                                                   (inc m)\n                                                                   (* 2 p))))))))\n                       ]\n                   (cons 2 (seive (doall (range 3 (inc m) 2))))))\n        ]\n    (take mm (primes 1000))))", "user": "53e27bf1e4b036ad0777e3f2"}, {"problem": 67, "code": ";(fn [n]\n;  (take n\n;    (filter\n;      (fn [i]\n;        (empty?\n;          (drop-while #(not= 0 (mod i %))\n;            (range (int (Math/sqrt i)) 1 -1)\n;            )))\n;      (range 2 Double/POSITIVE_INFINITY)\n;      )))\n\n(fn [n]\n  (take n\n    ((fn sieve [s] \n       (cons\n         (first s)\n         (lazy-seq\n           (sieve\n             (filter #(not= 0 (mod % (first s))) (rest s))\n             )))) \n     (iterate inc 2)\n     )))", "user": "53ecac57e4b0d648e757f4b3"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [acc [] cand 2 n n]\n    (if (= n 0)\n      acc\n      (if (not-any? #(= (mod cand %) 0) acc)\n        (recur (conj acc cand) (inc cand) (dec n))\n        (recur acc (inc cand) n)))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 67, "code": "#(take % (reduce\n   (fn [primes number]\n     (if (some zero? (map (partial mod number) (range 2 (- number 1))))\n       primes\n       (conj primes number)))\n   [2]\n   (take 1000 (iterate inc 3))))", "user": "53e0001be4b0d874e779ae48"}, {"problem": 67, "code": "(fn [n]\n  (let\n    [primes\n     (cons\n      2\n      (filter\n       (fn [c]\n         (every? (fn [p] (> (rem c p) 0)) (take-while (fn [p] (<= (* p p) c)) (range 3 1000 2))))\n       (range 3 1000 2)))]\n    (take n primes)))", "user": "53e4fa2ce4b036ad0777e454"}, {"problem": 67, "code": "(fn\n  [n]\n  (letfn [(gen-prime [x]\n            (let [num (inc x)]\n             (cond\n              (<= num 2) 2\n              (zero? (mod num 2)) (recur num)\n              (some #(zero? (mod num %)) (range 3 num 2)) (recur num)\n              :else num)))]\n    (take n (iterate gen-prime 2))))", "user": "4fca4c37e4b0ee37620e184f"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime?\n           [k]\n           (not-any? #(= 0 %) (map #(mod k %) (range 2 k))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "53cbe808e4b00fb29b2212d4"}, {"problem": 67, "code": "(fn primes \n  ([n]\n   (primes n 2 []))\n  ([n cur nums]\n   (if (not= 0 n)\n     (let [is-prime? (not (some #(= 0 (mod cur %)) (range 2 (dec cur))))]       \n       (primes (if is-prime? (dec n) n) \n               (inc cur) \n               (if is-prime? (conj nums cur) nums)))\n     nums)))", "user": "523578efe4b0a643f2dcb74c"}, {"problem": 67, "code": "(fn [t]\n  (let [primes (fn ps [coll]\n            (lazy-seq\n             (cons (first coll)\n                   (ps (filter #(not= 0 (mod % (first coll))) (rest coll))))))]\n  (take t (primes (rest (rest (range)))))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 67, "code": "(fn [v]\n  (take v (filter (fn [x] (if (< x 2) false\n                                     (not-any? #(= 0 (mod x %)) (range 2 x))))\n                  (range))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 67, "code": "(fn [x]\n    (take x (cons 2\n                  (filter #(loop[i 2](if(=(mod % i)0)nil(or(>(* i i)%)(recur(inc i)))))\n                          (drop 3 (range))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 67, "code": "(fn getprimes \n  ( [cnt] \n    (getprimes (dec cnt)  [2] 3))\n\n  ([cnt primes curr] \n  (let [prime? (fn [] (not (some #(zero? (mod curr %)) primes))) ]\n   (if (zero? cnt)\n      primes\n      (if (prime?) \n        (recur (dec cnt) (conj primes curr) (+ 2 curr))\n        (recur cnt primes (+ 2 curr))\n)))))", "user": "5364ab34e4b0243289761e64"}, {"problem": 67, "code": "(fn primes [total]\n  (loop [n 2\n         acc []]\n    (if (< (count acc) total)\n      (if (not-any? \n           #(zero? (mod n %))\n           (range 2 (dec n)))\n        (recur (inc n) (conj acc n))\n        (recur (inc n) acc))\n      acc)))", "user": "53f7820be4b0de5c41848560"}, {"problem": 67, "code": "(fn sieve [n]\n  (loop [p 2 x (drop 3 (range)) out []]\n    (if (= n (count out)) out\n      (recur (first x) (filter #(> (mod % p) 0) (rest x)) (conj out p))))\n  )", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 67, "code": "(fn e-67 [n]\n  (take n\n        (filter (fn [x] \n                  (> 1 (count\n                         (filter (fn [y] \n                                   (= 0 (mod x y))) (range 2 (- x 1))))))\n                (range 2 Integer/MAX_VALUE))))", "user": "53bd7080e4b0d9a98559a6d1"}, {"problem": 67, "code": "(fn [n]\n  (nth\n        (iterate\n         (fn [l]\n           (conj l \n                 (first\n                  (filter #(every? (fn [k] (not= (mod % k) 0)) l)\n                          (range (last l) (* 2 (last l)))))))\n           [2])\n   (dec n)))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 67, "code": "(fn [z] (take z (\n     (fn peu [x y] \n       \t\t(if \n              (not (some #(= 0 (mod x %)) y)) \n              (cons x (lazy-seq (peu (inc x) (conj y x))) )\n              (peu (inc x) y)\n            )\n     )\n2 [])))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 67, "code": "(fn[b](take b(filter(fn[a](every? #(< 0(mod a %))(range 2 a)))(drop 2(range)))))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 67, "code": "(fn primes [n]\n   (let [sieve (fn sv [k] #(> (rem % k) 0))]\n    (->> (iterate inc 2)\n         (filter (fn super-sieve [x] (every? identity (map #(% x) (map #(sieve %) (range 2 x))))))\n         (take n))))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 67, "code": "#(let [   \n   prime? (fn prime?\n   ([x] (cond \n     (= 1 x) false\n\t (or (= 2 x) (= 3 x)) true\n     :else (prime? x (inc (.intValue (Math/sqrt x))))))\n   ([x p] (cond \n      (= 1 p) true\n\t  (zero? (mod x p)) false\n\t  :else (recur x (dec p))\n\t  )))\n     ] \n\t (take % (filter prime? (iterate inc 1))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 67, "code": "(fn [num] (take num (filter (fn prime? [num]\n                               (not (some #(= 0 (mod num %))\n                                          (range 2 (+ 1 (Math/floor (Math/sqrt num)))))))\n                             (iterate inc 2))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 67, "code": "(fn mm [n]\n  (take n (iterate (fn [x]\n                     (first (filter (fn [y] \n                                      (nil? (some #(zero? (mod y %)) (range 2 y)))) \n                                    (iterate inc (inc x)))))\n                   2)))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 67, "code": "(fn [x] (take x (drop 2 (filter \n                         (fn [y] (empty? (filter #(= % (int %)) (map #(/ y %) (range 2 y)))))                         \n                         (range)))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 67, "code": "#(letfn [(upper-bound [n] (if (>= n 6) \n                             (int (inc (+ (* n (Math/log n)) (* n (Math/log (Math/log n))))))\n                             11)),\n          (sieve [k]\n            (loop [ls (range 2 (inc k)), primes []]\n              (if (empty? ls)\n                primes\n                (recur\n                 (remove (set (take-while (partial >= k) \n                                          (map (partial * (first ls)) (range)))) \n                         ls) \n                 (conj primes (first ls))))))] (take % (sieve (upper-bound %))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "53be3ee7e4b0d9a98559a6df"}, {"problem": 67, "code": "(fn foo [n] \n  (letfn [(primes-lazy\n            ([] (primes-lazy (iterate inc 2)))\n            ([s] \n              (cons \n                (first s)\n                (lazy-seq \n                  (primes-lazy \n                    (filter #(not= 0 (mod % (first s))) (rest s)))))))]\n\n    (take n (primes-lazy))))", "user": "53a94b63e4b047364c044434"}, {"problem": 67, "code": "(fn primes [n]\n  (let [sieve (fn sieve [xs]\n                (let [k (first xs)\n                      nonmultiples (remove #(= 0 (mod % k)) xs)]\n                  (lazy-seq (cons k (sieve nonmultiples)))))]\n    (take n (sieve (drop 2 (range))))))", "user": "53e8c684e4b036ad0777e48b"}, {"problem": 67, "code": "(letfn [(primes\n          ([] (primes {} 2 Integer/MAX_VALUE))\n          ([table n max]\n            (if-not (> n max)\n              (if-let [factors (table n)]\n                (let [new-table (apply (partial merge-with (comp flatten conj) (dissoc table n))\n                                       (map #(hash-map (+ n %) [%]) factors))]\n                  (recur new-table (inc n) max))\n                (lazy-seq (cons n (primes (conj table [(* n n) [n]]) (inc n) max)))))))]\n  (fn [x] (take x (primes))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 67, "code": "(fn primes \n  ([]\n   (let [sieve (fn sieve [s]\n  \t(cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))))]\n   (sieve (iterate inc 2))))\n  ([n]\n  (take n (primes))))", "user": "540b2dcbe4b0addc1aec66f4"}, {"problem": 67, "code": "(fn [x]\n  (take x (filter (fn [b]\n    (every? #(not (zero? (mod b %))) (take-while #(>= (/ b 2) %)(iterate inc 2)))\n) (iterate inc 2))))", "user": "54051338e4b0addc1aec6662"}, {"problem": 67, "code": "(fn [x] \n   (let [n 1000]\n   (letfn [(union [x y] (clojure.set/union x y))\n           (difference [x y] (clojure.set/difference x y))\n           (hash-set' [& args] (apply apply hash-set args))\n           (gen-set [coll p n] \n                    (union coll (hash-set' (take-while #(<= % n) (range (* 2 p) n p)))))\n           (next-p [coll p] (if (coll p) (next-p coll (inc p)) p))\n           (sieve-era [n]  \n                       (loop [p 2 coll (gen-set #{} p n)]\n                         (if (>= p n)\n                           coll\n                           (recur (next-p coll (inc p))\n                                  (gen-set coll p n)))))]\n\n       (->> (sieve-era n)\n            (difference (hash-set' (range 2 n)))\n            sort\n            lazy-seq\n            (take x)))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 67, "code": "(fn [x] (take x (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (iterate inc 2))))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (let [is-prime? (fn \n                    [x]\n                    ((complement some) #{0} (map #(rem x %) (range 2 x))))]\n    (take n (filter #(is-prime? %) (range 2 1e8)))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 67, "code": "#(take %\n      (\n(fn primes\n  ([] (cons 2 (cons 3 (primes [2 3]))))\n  ([x] (let [n\n        (some (fn [y] (if (nil? (some (fn [z] (= 0 (mod y z))) x)) y false))\n              (iterate (partial + 2) (last x)))]\n        (cons n (lazy-seq (primes (cons n x))))\n        )\n   ))\n)\n)", "user": "50856bd1e4b004985b776e4c"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes\n            ([] (cons 2 (lazy-seq (primes [2] 3))))\n            ([ps p]\n               (let [p'\n                     (loop [n (+ 2 p)]\n                       (if-not (some #(= 0 %) (map #(rem n %) (cons p ps)))\n                         n\n                         (recur (+ 2 n))))]\n                 (cons p (lazy-seq (primes (cons p ps) p'))))))]\n    (take n (primes)))\n  )", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 67, "code": "(fn [n]\n  (if (> n 0)\n    (loop [accu [2]\n           current 3]\n      (if (= (.size accu) n)\n        accu\n        (if (some #(= (mod current %) 0) accu)\n          (recur accu (inc current))\n          (recur (conj accu current) (inc current)))))))", "user": "540d7dd1e4b0addc1aec6713"}, {"problem": 67, "code": "(let [is-prime? (fn [x]\n                  (let [possible (range 2 (inc (/ x 2)))]\n                    (not-any? #(= 0 (rem x %)) possible)))]\n  (fn my-primes [n]\n    (take n (filter is-prime? (drop 2 (range))))))", "user": "53edb628e4b0d648e757f4c8"}, {"problem": 67, "code": "(fn [n]\n  (let [\n    is-prime (fn [x] \n      (empty? \n       (filter\n        (fn [y] (= (mod x y) 0))\n        (range 2 x))))]\n    (take n (drop 2 (filter is-prime (range))))))", "user": "540d5085e4b0addc1aec670e"}, {"problem": 67, "code": "(fn get-primes [n]\n  (letfn [(divisible? [x y]\n            (= (mod x y) 0))\n          (prime? [n]\n            (not (some #{true} (map #(divisible? n %)\n                                    (range 2 n)))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "54084784e4b0addc1aec66c9"}, {"problem": 67, "code": "(fn [num]\n\t(letfn [(is-prime? [c a]\n\t\t\t(if (= c a)\n                true\n                (if (= (mod a c) 0)\n                  false\n                  (recur (+ 1 c) a))))]\n      (letfn [(primes [n acc]\n                (let [res (if (is-prime? 2  n) (conj acc n) acc)]\n                  (if (= num (count acc))\n                    res\n                    (recur (+ 1 n) res))))]\n        (primes 2 []))))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 67, "code": "(fn prime-count [x]\n  (letfn [(is-prime? [y]\n            (not-any? #(zero? (rem y %)) (range 2 y)))]\n    (loop [acc 2\n           primes #{}]\n      (cond (= (count primes) x)\n            (vec (sort primes))\n            :else (recur (inc acc) (if (is-prime? acc)\n                                     (conj primes acc)\n                                     primes))))))", "user": "52474133e4b05ef8e38e635e"}, {"problem": 67, "code": "(fn tp [n]\n  (let [prime? (fn [x]\n                 (let [ceiling (/ x 2)]\n                   (loop [m 2]\n                     (if (> m ceiling)\n                       true\n                       (if (= (mod x m) 0)\n                         false\n                         (recur (inc m)))))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 67, "code": "{2 [2 3]\n 5 [2 3 5 7 11]\n 100 [541]}", "user": "539f4e9ee4b0ca733b974498"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(composite? [n]\n            (some #(= 0 (mod n %))\n                  (range 2 (inc (Math/sqrt n)))))]\n    (cons 2\n          (take (dec n)\n                (remove composite? (iterate inc 2))))))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 67, "code": "(fn [n]\n   (let [prime? (fn [n] (empty? (filter #(zero? (mod n %)) (range 2 n))))]     \n     (take n (filter prime? (iterate inc 2)))))", "user": "54094824e4b0addc1aec66da"}, {"problem": 67, "code": "(fn [z] (nthrest (take (+ z 2) (for [x (range) :when ((fn prime [x] (if (= 0 (count (filter  #(= 0 (mod x %)) (range 2 x)))) true false)) x)] x)) 2))", "user": "540479e7e4b0addc1aec665a"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    ((fn sieve [s]\n       (cons (first s)\n             (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                       (rest s))))))\n     (iterate inc 2))))", "user": "53806e5be4b06839e8705ec1"}, {"problem": 67, "code": "#(loop [l [2]\n        n 3]\n   (if (= (count l) %)\n     l\n     (recur (if (some zero? (map (partial mod n) l))\n              l\n              (conj l n))\n            (inc n))))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 67, "code": "(clojure.core/fn ([n]\n                    \"Returns a sequence of n prime numbers. (#67 4clojure.com)\"\n                    (let [prime? (fn \n                                   [n]\n                                   (cond\n                                     (= n 0) false\n                                     (= n 1) false\n                                     :else\n                                     (loop \n                                       [a 2]\n                                       (cond\n                                         (= a n) true\n                                         (= (rem n a) 0) false\n                                         :else (recur (inc a))))))]\n                      (take n (filter prime? (range))))))", "user": "52a7634ae4b0c58976d9ac16"}, {"problem": 67, "code": "#(loop[c % n 2 p []]\n   (if (= c (count p)) p\n    (if (some (fn prim[x] (= 0 (rem n x))) p) (recur c (inc n) p)\n              (recur c (inc n) (conj p n)))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 67, "code": "#(condp = %\n   2 [2 3]\n   5 [2 3 5 7 11]\n   100 [541])", "user": "539c88e1e4b0b51d73faaf2c"}, {"problem": 67, "code": "(fn [n]\n  (let [is-p (fn [x]\n               (not-any? #(= 0 (rem x %)) (range 2 x)))]\n    (take n (filter is-p (drop 2 (range))))))", "user": "53dcf474e4b0d874e779ae25"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  (letfn [(isPrime [x] (not-any? #(= 0 (rem x %)) (range 2 x)))]\n    (take n (filter isPrime (iterate inc 2)))))", "user": "53ff8c31e4b0de5c41848603"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n\t                                   (rest s))))))]\n\t (take n (sieve (iterate inc 2)))))", "user": "5047782ce4b0371827a27bc2"}, {"problem": 67, "code": "(fn prime-numbers \n  ([]\n   ((fn sde [scoll]\n     (cons (first scoll)\n           (lazy-seq (sde (filter #(not= 0 (mod % (first scoll))) (rest scoll)))))) (iterate inc 2)))\n  ([n] (take n (prime-numbers))))", "user": "53f35c34e4b0742d9025b0f4"}, {"problem": 67, "code": "(fn [n]\n        (letfn [(sieve [s]\n                  (cons (first s)\n                        (lazy-seq\n                         (sieve (filter #(not= 0 (mod % (first s)))\n                                        (rest s))))))]\n          (take n (sieve (iterate inc 2)))))", "user": "541ae7dbe4b01498b1a71a61"}, {"problem": 67, "code": "(fn [i]\n  (let [sq (range 2 (* i i))]\n    (take i (reduce\n     (fn [sq n]\n       (remove #(and (not= % n) (= (mod % n) 0)) sq))\n     sq (range 2 (inc i))))))", "user": "54157dace4b01498b1a719f4"}, {"problem": 67, "code": "(fn [number-of-primes]\n\t(loop [candidates (range 2 1000) primes []]\n\t\t(if (= (count primes) number-of-primes)\n\t\t\tprimes\n\t\t\t(recur (remove #(= 0 (rem % (first candidates))) (rest candidates)) (conj primes (first candidates))))\n\t)\n)", "user": "5409f8eae4b0addc1aec66e6"}, {"problem": 67, "code": "(fn prime [n]\n  (take n \n    (filter (fn p [x]\n      (empty? (filter #(zero? (mod x %)) (range 2 x))))\n    (range 2 Double/POSITIVE_INFINITY))))", "user": "4eb3fcba535d7eef30807359"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s)))))) (iterate inc 2))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 67, "code": "(fn fprimes [n]\n  (let [prime? (fn [x primes] (not-any? #(= (rem x %) 0) primes))\n        gen-primes\n        (fn [cnt tst primes]\n          (if (= cnt 0)\n            primes\n            (if (prime? tst primes)\n              (recur (dec cnt) (+ tst 2) (conj primes tst))\n              (recur cnt (+ tst 2) primes))))]\n    (gen-primes (dec n) 3 [2])))", "user": "541475afe4b01498b1a719eb"}, {"problem": 67, "code": "(fn primes [n]\n   (let [divisible-by (fn [x y] (= 0 (rem x y)))\n         isprime (fn [prevprimes x]\n                   (every? #(not (divisible-by x %)) prevprimes))\n         nextprime (fn [prevprimes]\n                     (loop [xx (+ 1 (last prevprimes))]\n                       (if (isprime prevprimes xx)\n                         xx\n                         (recur (+ 1 xx)))))]\n     (loop [currprimes [2]]\n       (if (= n (count currprimes))\n         currprimes\n         (recur (conj currprimes (nextprime currprimes)))))))", "user": "5429986ce4b01498b1a71b3b"}, {"problem": 67, "code": "(fn [n]\n    (take n\n          (remove\n            (fn [n] (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n            (iterate inc 2))))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 67, "code": "(fn takeprime\n  [x]\n  (let [zs \n    (fn zhishu\n    ([] (cons 2 (zhishu [3])))\n    ([x]\n       (if (some true? (map #( = (mod (first x) %) 0) (range 2 (first x))))\n            (lazy-seq (zhishu [(inc (first x))]))\n            (cons (first x) (lazy-seq (zhishu [(inc (first x))]))))))]\n    (take x (zs))\n   )\n  )", "user": "53d6b266e4b0e771c3025459"}, {"problem": 67, "code": "#(if\n     (= %3 (count %))\n       %\n     (recur\n       (if (= % (filter (fn [x] (< 0 (mod %2 x))) %)) (conj % %2) %)\n       (+ 1 %2)\n       %3)) [] 2", "user": "542f574be4b0dad94371f2d0"}, {"problem": 67, "code": "(fn [x] (take x (filter #(= (inc (mod (apply * (range 1N %)) %)) %) (iterate inc 2))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 67, "code": "(fn [n]\n  (loop [[x & rst] (nnext (range))\n         primes []\n         n  n]\n    (if (= n 0)\n      primes\n      (recur (remove #(zero? (mod % x)) rst)\n             (conj primes x)\n             (dec n)))))", "user": "51b8d3d5e4b050a1176cd69d"}, {"problem": 67, "code": "(fn [num-primes]\n  (if (= num-primes 0)\n    []\n    (loop [n 3 primes [2]]\n      (if (= num-primes (count primes))\n        primes\n        (recur (inc n) (concat primes (when (every? identity (map #(not= 0 (mod n %)) primes)) [n])))))))", "user": "51aab611e4b04e3dc0c27b2d"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (cons 2\n      (filter (fn [x] (every? #(pos? (mod x %))\n                              (cons 2 (range 3 (/ x 2) 2))))\n              (iterate inc 2)))))", "user": "50d882d4e4b01f0871336e69"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter #(not-any? (fn [x] (= 0 (mod % x))) (range 2 (inc (int (/ % 2))))) (->> (range) rest rest))))", "user": "542c22bde4b0dad94371f29e"}, {"problem": 67, "code": "(fn prime-numbers [x]\n  (take x\n    (filter\n      (fn prime? [n]\n        (.isProbablePrime (BigInteger/valueOf n) 10))\n      (range 1 Integer/MAX_VALUE))))", "user": "528bba38e4b0239c8a67aea9"}, {"problem": 67, "code": "#(take %\n   (map first\n     (iterate\n       (fn [[x primes]]\n         (if (some (fn [p] (= (mod x p) 0)) primes)\n           (recur [(inc x) primes])\n           [x (conj primes x)]))\n       [2 [2]])))", "user": "54397533e4b032a45b86931d"}, {"problem": 67, "code": "(fn [n] \n  (letfn [(primes \n           [xs]\n           (cons (first xs)\n                 (lazy-seq (primes (remove #(= 0 (mod % (first xs))) (rest xs) )))))]\n    (take n (primes (iterate inc 2)))))", "user": "531bfb69e4b08068f379ed97"}, {"problem": 67, "code": "(fn take-prime [n]\n  (letfn [(prime-numbers  ([] (concat [2 3 5 7] (prime-numbers [2 3 5 7])))\n                          ([prev-primes]\n                            (let [start (inc (last prev-primes))\n                                  is-prime (fn [i] (every? #(not= (mod i %) 0) prev-primes))\n                                  first-prime (fn [n] (if (is-prime n) n (recur (inc n))))\n                                  p (first-prime start)\n                                  next-primes (conj prev-primes p)]\n                              (lazy-seq (cons p (prime-numbers next-primes))))))]\n    (take n (prime-numbers))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(is-prime? [n]\n              (cond\n               (= 1 n) false\n               (= 2 n) true\n               (even? n) false\n               :else\n               (->> (range 3 (inc (Math/sqrt n)))\n                    (filter is-prime?)\n                    (filter #(zero? (rem n %)))\n                    empty? )))]\n      (take n (filter is-prime? (range)))))", "user": "5433a07be4b0b6b47310fce0"}, {"problem": 67, "code": "#(take %\n       (filter \n        (fn [n]\n          (if (< n 2)\n            false\n            (= 0 (apply + (for [i (range 2 (inc (int (Math/sqrt n))))]\n                            (if (= (mod n i) 0) 1 0))))))\n        (range)\n        ))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 67, "code": "(fn [n]\n   (take n\n         (filter (fn [x]\n                   (loop [counter 2]\n                     (cond\n                      (> counter (Math/sqrt x)) true\n                      (zero? (mod x counter)) false\n                      :else (recur (inc counter)))))\n                 (range 2 1000))))", "user": "52561295e4b0541d1855ba03"}, {"problem": 67, "code": "(fn [n]\n\t(letfn [(prime? [x] (loop [i 2] (if (> i (Math/sqrt x)) true (if (= (mod x i) 0) false (recur (inc i))))))] \n  \t(loop [i 2 f []] (if (= (count f) n) f (recur (inc i) (if (prime? i) (conj f i) f)))) \n      ))", "user": "542edb4ae4b0dad94371f2c8"}, {"problem": 67, "code": "(fn _prime [n]\n        (let [next-prime (memoize\n                           (fn [s]\n                             (loop [p (last s)]\n                               (if (empty? (filter #(zero? (rem p %)) s))\n                                 (conj s p)\n                                 (recur (inc p))))))]\n          (cond\n            (= n 1) [2]\n            (> n 1) (next-prime (_prime (dec n)))\n            )\n        ))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(find-smallest-divisor\n            ([x] (find-smallest-divisor x 2))\n            ([x test-div] (cond (> (* test-div test-div) x) x\n                                (zero? (rem x test-div)) test-div\n                                :else (recur x (inc test-div)))))\n           (prime? [x]\n             (= x (find-smallest-divisor x)))]\n    (take x (lazy-seq (filter #(prime? %) (iterate inc 2))))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 67, "code": "(fn nprimes ([n] (nprimes [] 2 n))\n  \t\t\t([primes curr n] (if (= n 0)\n                               \t primes\n                               \t (if (reduce #(if (= (rem curr %2) 0) false %1) true primes) \n                                     (nprimes (conj primes curr) (inc curr) (dec n)) \n                                     (nprimes primes (inc curr) n)\n                                 )\n                             )\n            )\n)", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 67, "code": "(fn [db]\n  (letfn [(sieve [[f & rst]] (cons f (lazy-seq (sieve (remove #(= 0 (mod % f)) rst)))))]\n    (take db (sieve (iterate inc 2)))))", "user": "543f854fe4b032a45b86935b"}, {"problem": 67, "code": ";;; This is a reasonably efficient implementation of the Sieve of Eratosthenes.\n;;; I would love to figure out how to shorten this up, using Clojure magic, and\n;;; how to make it lazy.  But to do the sieve right might not be amenible to a\n;;; short program.  See http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\n;;; In my program, what I call a \"filter\" is a 2-element vector [x y] where\n;;; y is an already-discovered prime number, and x is some multiple of it.  I\n;;; maintain a sorted set of filters, which are used to eliminate non-primes.\n;;; As \"i\" marches forward, it matches the \"x\" of one or more filters, which\n;;; eliminates it as a prime, and causes those filters to be moved forward to\n;;; the next multiple.  If an \"i\" doesn't match any filter (i.e. if the filter\n;;; with the lowest \"x\" is larger than \"i\"), then \"i\" is prime, and a new filter\n;;; is added for it.\n(fn [in-n]\n    ;; For filters that apply to i, re-add at next multiple.                                                    \n    (letfn [(re-filter [in-filts i]\n              (loop [filts in-filts]\n                (let [[x y] (first filts)]\n                  (if (> x i)\n                    filts\n                    ;; Since we are skipping even numbers, add the prime twice.                                    \n                    (recur (conj (disj filts [x y]) [(+ x y y) y]))))))]\n\n      (loop [res (sorted-set 2 3)      ; Already have first 2 answers (can't return just one).\n             filts (sorted-set [9 3])  ; Skipping even nums, so don't need [2 4].\n             i 5                       ; last prime was 3, skipped over 4, so next candidate to test is 5.\n             n (- in-n 2)]             ; Already have 2 answers.\n        (cond (= 0 n) (vec res)   ; Done!\n              ; Find a prime!\n              (< i (first (first filts))) (recur (clojure.set/union res #{i})\n                                                 (clojure.set/union filts #{[(* i i) i]})\n                                                 (+ i 2)\n                                                 (- n 1))\n              ; i is >= current multiple of first filter; i is not prime.\n              :else (recur res\n                           (re-filter filts i)\n                           (+ i 2)\n                           n)))))", "user": "540e0637e4b0addc1aec6717"}, {"problem": 67, "code": "#_(fn [n]\n    (take n (filter integer? (for [y (range 2 1000)] \n        (if-not \n          (some zero? \n              (map (partial mod y) \n                   (range 2 (- y 1))))\n          y)))))\n\n\n(fn [n]\n  ((fn primes [col y]\n    (if (= (count col) n)\n      col \n        (if-not\n          (some zero?\n           (map (partial mod y) col))\n          (primes (conj col y) (inc y))\n          (primes col (inc y)))\n      )) [] 2))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [ret [2]\n         candidate 3]\n    (if (= n (count ret))\n      ret\n      (if (some zero? (map #(rem candidate %) ret))\n        (recur ret (inc candidate))\n        (recur (conj ret candidate) (inc candidate))))))", "user": "532a033be4b09d4e7a9b551f"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-divisible-by? (fn [number divisor]\n                           (zero? (mod number divisor)))\n        is-prime? (fn [number]\n                    (if (< number 4)\n                      (> number 1)\n                      (let [sqrt (int (Math/ceil (Math/sqrt number)))\n                            divisors-candidates (range 2 (+ 1 sqrt))]\n                        (nil? (some #(zero? (mod number %)) divisors-candidates)))))]\n      (take n (filter is-prime? (range)))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 67, "code": "(fn get-primes [n]\n  (let [is-prime (fn [x]\n                  (not-any? #(= 0 (mod x %)) (range 2 x)))]\n    (take n (filter is-prime (range 2 1000)))))", "user": "54448e84e4b032a45b869393"}, {"problem": 67, "code": "(fn [numb]\n  (letfn [(prime? [x]\n                  (every? identity (map #(not= 0 (mod x %))\n                                        (range 2 (inc (int (Math/sqrt x)))))))]\n    (take numb (filter prime? (iterate inc 2)))\n    ))", "user": "53f6bfd9e4b0db01ade6f9e4"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn p [[a & as]]\n             (lazy-cat [a] (p (filter #(pos? (rem % a)) as)))) (iterate inc 2))))", "user": "541096bde4b01498b1a719b2"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(is-prime? [n]\n                     (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))]\n    (cons 2 (take (dec x) (filter #(is-prime? %) (range 3 1000 2))))))", "user": "5447e08ce4b032a45b8693c3"}, {"problem": 67, "code": "(fn [n]\n   (take n\n         (filter (fn [n]\n                   (loop [idx 2]\n                     (cond \n                      (> (* idx idx) n) true\n                      (zero? (mod n idx)) false\n                      :else (recur (inc idx)))))\n                 (drop 2 (range)))))", "user": "5370d152e4b0fc7073fd6e9d"}, {"problem": 67, "code": "(fn [t]\n  (loop [c [2] n 3]\n    (if (= (count c) t)\n      c\n      (if (= (mod (+' (apply *' (range 2 n)) 1) n) 0)\n        (recur (conj c n) (+ n 2))\n        (recur c (+ n 2))))))", "user": "52117ea7e4b07aea8afc4f70"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x pp] (not (some #(zero? (mod x %)) pp)))]\n    (loop [n n i 2 r []]\n      (if (zero? n)\n        r\n        (if (prime? i r)\n          (recur (dec n) (inc i) (conj r i))\n          (recur n (inc i) r))))))", "user": "5122925ae4b068a9582e656d"}, {"problem": 67, "code": "(fn [num]\n  (take num \n        (iterate (fn p [s]\n                   (let [n (+ 1 s)]\n                   (if (= 1 (count (filter #(zero? (mod n %)) (range 1 s) )))\n                     n\n                     (p n))))\n                 2)))", "user": "544b9df2e4b0e39780006968"}, {"problem": 67, "code": "(fn [n] (take n \n              ((fn p[s] (cons (first s) \n                              (lazy-seq (remove #(= (mod % (first s)) 0)\n                                                (p (rest s)))))) \n               (iterate inc 2))))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 67, "code": "(fn [k] \n  (take k (filter (fn [n] (if (< n 2)\n                        false\n                        (if (= n 2)\n                          true\n                          (if (empty? (drop-while #(not= 0 (mod n %)) (range 2 (inc (Math/sqrt n)))))\n                            true\n                            false)\n                          ))) (range))))", "user": "54349368e4b0b6b47310fcf1"}, {"problem": 67, "code": "(fn first-primes [n]\n  (letfn [(compute-primes [cnt result number]\n                          (if (= cnt 0)\n                            result\n                            (let [divisors (take-while #(<= (* % %) number) result)]\n                              (if (some #(zero? (rem number %)) divisors)\n                                (recur cnt result (+ number 2))\n                                (recur (dec cnt) (conj result number) (+ number 2))))))]\n    (compute-primes (dec n) [2] 3)))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 67, "code": "(fn [n]\n  (let [e? #(zero? (rem %1 %2))\n        p? (fn [x] (not-any? #(e? x %) (range 2 x)))\n        xs (map #(+ 2 %) (range))]\n    (->> xs (filter p?) (take n))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 67, "code": "(fn [n]\n  (loop [s [], i 2, z n]\n    (if (= 0 z)\n      s\n      (if (some zero? (map rem (repeat i) s)) \n        (recur s (inc i) z)\n        (recur (conj s i) (inc i) (dec z))\n))))", "user": "54524afbe4b0e397800069bc"}, {"problem": 67, "code": "(fn \n  [n]\n  (letfn [(prime? \n            [n]\n            (cond\n              (<= n 3) (>= n 2)\n              (or (= 0 (mod n 2)) (= 0 (mod n 3))) false\n              :else (every? #(and (not (= (mod n %) 0)) (not (= (mod n (+ % 2)) 0))) (range 5 (inc (Math/sqrt n)) 6)))\n            )]\n  (take n (filter prime? (iterate inc 2)))))", "user": "4fee04a0e4b0678c553fc308"}, {"problem": 67, "code": "(fn primes [i]\n  (take i (filter\n   \t(fn prime? [n] \n  \t\t(> 2 (count (filter #(zero? (mod n %)) (take (- n 1) (drop 1 (range))))))\n  \t)\n   \t(drop 2 (range)))\n   ))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 67, "code": "(fn prime [num]\n  (->> (filter (fn [n]\n             (every? #(not= (mod n %) 0) (range 2 n)))\n           (drop 2 (range)))\n      (take num)))", "user": "523c61b2e4b07becd5be2220"}, {"problem": 67, "code": "#(cond\n    (= % 2) [2 3]\n    (= % 5) [2 3 5 7 11]\n    :else [541])", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 67, "code": "(fn [n]\n  (take \n   n\n   (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 67, "code": "(fn [n]\n  (take n\n   (filter\n    (fn [x] (every? #(pos? (mod x %)) (range 2 x)))\n    (iterate inc 2))))", "user": "505aa653e4b021387fb89857"}, {"problem": 67, "code": "(fn [x]\n    (letfn [(isPrime [n]\n                     (not-any? true? (->>\n                                      (range 2 n)\n                                      (map (fn [d] (mod n d)))\n                                      (map zero?))))]\n                    \n    (->> \n     (range)\n     (drop 2)\n     (filter #(isPrime %))\n     (take x))))", "user": "5409a12fe4b0addc1aec66df"}, {"problem": 67, "code": "(fn [n] \n  (loop [i 2 r n lst []] \n    (cond \n     (= 0 r) lst \n     (some #(= 0 (mod i %)) lst) (recur (inc i) r lst) \n     :else (recur (inc i) (dec r) (conj lst i)))))", "user": "545e7ab0e4b01be26fd7467c"}, {"problem": 67, "code": "(fn f [n]\n  (letfn [(next_prime [x]\n          (if (nil? x)\n            2\n            (loop [i (inc x)]\n              (if (loop [j 2]\n                   (if (= i j)\n                     true\n                     (if (= (rem i j) 0)\n                       false\n                       (recur (inc j))\n                     )\n                   ))\n                i\n                (recur (inc i))\n               ))\n           ) \n          )]\n  (loop [result []]\n    (if (= (count result) n)\n      result\n      (recur (conj result (next_prime (last result))))\n   )\n ))\n)", "user": "54021f13e4b0df28a13c62cc"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (filter \n      #(not-any? (fn [k] (= 0 (rem %1 k))) (range 2 %1))\n      (iterate inc 2))))", "user": "544e9022e4b0e3978000698b"}, {"problem": 67, "code": "(fn [x]\n    ;; Efficient prime algorithm.\n    (letfn [(prime? [n]\n                    (cond (< n 2) false\n                          (#{2 3} n) true\n                          (even? n) false\n                          (zero? (mod n 3)) false\n                          (some #(or (zero? (mod n %)) (zero? (mod n (+ 2 %))))\n                                (range 5 (inc (Math/pow n 0.5)) 6)) false\n                          :else true))]\n      (take x (filter prime? (iterate inc 1)))))", "user": "537bde5de4b06839e8705e73"}, {"problem": 67, "code": "(fn [x]\n  (loop [left x\n         i 2\n         ps []]\n    (if (= left 0)\n      ps\n      (if (some #(= 0 (mod i %)) ps)\n        (recur left (inc i) ps)\n        (recur (dec left) (inc i) (conj ps i))))))", "user": "54651982e4b01be26fd746d4"}, {"problem": 67, "code": "(fn get-primes [n]\n  (loop [primes #{2} i 2]\n    (if (= (count primes) n)\n      (sort primes)\n      (if (some #(= 0 (mod i %)) primes)\n        (recur primes (inc i))\n        (recur (conj primes i) (inc i))\n        ))))", "user": "546c1b2ce4b00cfc9eacc174"}, {"problem": 67, "code": "(fn [n]\n   (loop [c [2] k 3] \n     (if (= (count c) n)\n       c\n       (if \n         (not-any? zero?\n            (map #(mod k %) c))\n          (recur (conj c k) (inc k))\n          (recur c (inc k))\n         )\n       )\n     )\n)", "user": "5412646de4b01498b1a719d4"}, {"problem": 67, "code": "(fn [n](\n         take n \n              (filter \n                    (fn [x] (empty? (filter #(zero? (rem x %)) (range 2 x)))) \n                    (range 2 1000))\n       ))", "user": "546280d8e4b01be26fd746b0"}, {"problem": 67, "code": "#(let [divides? (fn [a b] (= (rem b a) 0))\n       square (fn [x] (* x x))\n       find-divisor (fn [n test-divisor]\n                      (cond (> (square test-divisor) n) n\n                            (divides? test-divisor n) test-divisor\n                            :else (recur n (+ test-divisor 1))))\n       smallest-divisor (fn [n] (find-divisor n 2))\n       prime? (fn [n] (= n (smallest-divisor n)))]\n   (take % (filter prime? (nthrest (range) 2))))", "user": "4ebbc1f6535dfed6da9c6d72"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [n]\n            (or (== n 2)\n                (loop [i (Math/ceil (Math/sqrt n))]\n                  (cond (<= i 1) true\n                        (== (mod n i) 0) false\n                        :else (recur (dec i))))))]\n    (take n (filter prime? (rest (rest (range)))))))", "user": "52c4d327e4b0c2d177d620e6"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [c n\n         acc []\n         nums (lazy-seq (iterate inc 2))]\n    (if (= c 0)\n      acc\n      (recur (dec c)\n             (conj acc (first nums))\n             (lazy-seq (filter #(not= (mod % (first nums)) 0) nums))))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 67, "code": "(fn [x] (take x (filter (fn [n] (if (= 2 n) true (empty? (for [i (range 2 (+ 1 (Math/sqrt n))) :let [r (mod n i)] :when (= 0 r)] i)))) (iterate inc 2))))", "user": "5464a536e4b01be26fd746cf"}, {"problem": 67, "code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "user": "540997ede4b0addc1aec66dd"}, {"problem": 67, "code": "(fn[n]\n  (loop [i 2 primes []]\n    (cond (= (count primes) n) primes\n          (some #(= 0 (mod i %)) primes) (recur (inc i) primes)\n          :else (recur (inc i) (conj primes i)))))", "user": "5472cba1e4b094393f72dd7a"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [p] (not-any? #(zero? (mod p %)) (range 2 p))) (iterate inc 2))))", "user": "5136f659e4b04059df19f2fd"}, {"problem": 67, "code": "(fn primes [x]\n  (letfn [(f [seq]\n            (lazy-seq\n             (cons (first seq)\n                   (f (filter #((complement zero?)\n                                (mod % (first seq)))\n                              (rest seq))))))]\n    (take x (f (iterate inc 2)))))", "user": "546c1f73e4b00cfc9eacc175"}, {"problem": 67, "code": "(fn [n]\n  (take n (concat [2 3 5 7 11] (take 94 (repeat 0)) '(541))))", "user": "5125d963e4b05d10e3e395fe"}, {"problem": 67, "code": "(fn primes\r\n  ([] (cons 2 (primes [2] 3)))\r\n  ([n] (take n (primes)))\r\n  ([s x]\r\n    (loop [k x] \r\n      (if (some #(= (mod k %) 0) s)\r\n        (recur (inc k))\r\n        (lazy-seq (cons k (primes (cons k s) (inc k))))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 67, "code": ";\n;(defn prime? [n ndiv]\n;  (if (< n 2)\n;    false\n;    (if (or (= n 2) (= n 3))\n;      true\n;      (if (= (mod n ndiv) 0)\n;        false\n;        (if (< (int (inc (/ n ndiv))) ndiv)\n;          true\n;          (prime? n (inc ndiv))\n;        )\n;      ) \n;    )\n;  )\n;)\n;\n;cheating a bit (didn't really solve the problem of returning a lazy vector of primes. \n;Instead, tested the first 600 integers for being primes and took n elements from the resulting vector)\n;\n;#(take % (filterv (fn[x] (prime? x 2)) (range 600)))\n;\n\n\n#(take % (filterv (fn[x] ((fn prime? [n ndiv] (if (< n 2) false (if (or (= n 2) (= n 3)) true (if (= (mod n ndiv) 0) false (if (< (int (inc (/ n ndiv))) ndiv) true (prime? n (inc ndiv))))))) x 2)) (range 600)))", "user": "545537c1e4b0e397800069dd"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5460f59ce4b01be26fd74695"}, {"problem": 67, "code": "(fn find-primes [x] \n  (take x \n        (filter (fn prime? [n] \n                  (nil? (some #(zero? (mod n %)) (range 2 n)))) \n                (drop 2(range)))))", "user": "541f5b37e4b01498b1a71a97"}, {"problem": 67, "code": "(fn [n]\n  (take n \n    (filter (fn [i] (not-any? #(= 0 (mod i %)) (range 2 i))) (drop 2 (range)))))", "user": "547adcb0e4b0c51c1f4d72cf"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(sieve [n s] (remove #(zero? (mod % n)) s))\n      \t  (primes [s]\n                  (if (not-empty s) \n                    (cons (first s) (lazy-seq (primes (sieve (first s) (rest s)))))))]\n  \t(take x (primes (iterate inc 2)))))", "user": "5478e57de4b0c51c1f4d72c1"}, {"problem": 67, "code": "(fn [n]\n   (vec\n    (cons 2\n          (take (dec n)\n                ((fn p [primes]\n                   (loop [i (inc (last primes))]\n                     (if (some #(= 0 (mod i %)) primes)\n                       (recur (inc i))\n                       (cons i (lazy-seq (p (conj primes i)))))))\n                 [2])))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= 1 n)\n    [2]\n    (let [prev-primes (primes (dec n))]\n      (conj prev-primes (first (filter \n                                (fn [n] (not-any? zero? (map #(rem n %) prev-primes)))\n                                (iterate inc (peek prev-primes))))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 67, "code": "(fn [x] (take x (iterate \n         (fn [y] (let [y (inc y)]\n           (if (seq (filter #(= 0 (rem y %)) (range 2 y)))\n             (recur y) \n             y)))\n         2)))", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 67, "code": "(fn [n]\n  (take n\n \t((fn sieve [s]\n  \t\t(cons (first s)\n        \t(lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))\n              ))\n\t\t(iterate inc 2))\n       ))", "user": "52e7afe1e4b09f7907dd148b"}, {"problem": 67, "code": "(fn [x] (cons 2 (take (dec x) (filter (fn [y] (= 1 (reduce min 2 (map #(mod y %) (range 2 y))))) (range) ))))", "user": "548485f5e4b0e286459a119f"}, {"problem": 67, "code": "(fn [x]\n  (let [prime?\n          (fn [n]\n            (let [helper (fn p [n m]\n                           (if (< m n)\n                             (if (zero? (mod n m))\n                               false\n                               (p n (inc m)))\n                             true))]\n              (helper n 2)))]\n  (take x (filter #(and (prime? %) (> % 1)) (range)))))", "user": "4e41a04e535dc968683fc49e"}, {"problem": 67, "code": "#(letfn [(prime? [x] (not (zero? (reduce * (map (partial mod x) (range 2 (+ 1 (int (Math/sqrt x)))))))))] \n        (take % (filter prime? (drop 2 (range)))))", "user": "54857e3be4b0e286459a11ad"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter\n           (fn [n]\n             (not-any? #(zero? (rem n %)) (range 2 n))\n             )\n           (range 2 1000))))", "user": "5486adf7e4b0e286459a11be"}, {"problem": 67, "code": "(fn [x] \n  (take x (iterate #(.nextProbablePrime %) (BigInteger/valueOf 2))))", "user": "53c06438e4b0c98a41f5ccb0"}, {"problem": 67, "code": "(fn first-primes\n  [n]\n  (if (= 0 n)\n    []\n    (let [primes (first-primes (dec n))\n          next-prime (fn [primes]\n                    (let [lst-prime (or (last primes) 1)]\n                      (loop [start (inc lst-prime)]\n                        (if (every? #(not= 0 (rem start %)) primes)\n                          start\n                          (recur (inc start))\n                          )\n                    )))\n          ]\n      (conj primes (next-prime primes)))))", "user": "526143b7e4b03e8d9a4a705a"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn p [[a & r]]\n             (lazy-seq (cons a\n                             (p (remove #(= 0 (mod % a))\n                                        r)))))\n           (drop 2 (range)))))", "user": "5466aabbe4b01be26fd746e8"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? (fn [p]\n                 (every? #(not (= 0 (mod p %))) (range 2 p))\n                 )]\n    (take n (filter prime? (drop 2 (range))))\n    )\n  )", "user": "5488872ee4b0e286459a11d3"}, {"problem": 67, "code": "(fn prime-n [n]\n  (letfn [(sieve [s] ;;\u7b5b\u5b50\n            (cons (first s)\n                  (lazy-seq\n                   (sieve (filter #(not= 0 (mod % (first s)))\n                                  (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? (fn [x]\n                 (not (some #(and\n                              (not= x %)\n                              (zero? (mod x %)))\n                            (range 2 (inc (Math/sqrt x))))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "542c026ae4b0dad94371f29a"}, {"problem": 67, "code": "(fn trial-division [n]\n    (letfn [(prime? [x]\n              (cond\n                (< x 2) false\n                (= x 2) true\n                (zero? (rem x 2)) false\n                (some #(zero? (rem x %)) (range 3 (inc (Math/sqrt x)) 2)) false\n                :else true))]\n      (take n (filter prime? (range)))))", "user": "5470b3d0e4b00cfc9eacc1bb"}, {"problem": 67, "code": "(fn [x]\n  (let [\n        gcd (fn [a b] (loop [a' a b' b] (if (= 0 b') a' (recur b' (mod a' b')))))\n        is-prime (fn [x] (not-any? #(> % 1) (map #(gcd x %) (range (- x 1) 0 -1))))\n        ]\n   (take x (filter is-prime (iterate inc 2)))))", "user": "4fbfbd4fe4b081705acca31c"}, {"problem": 67, "code": "(fn [n]\n\t(take n\n\t\t((fn sieve [s]\n\t\t\t(cons (first s)\n\t\t\t\t(lazy-seq\n\t\t\t\t\t(sieve\n\t\t\t\t\t\t(remove \n\t\t\t\t\t\t\t#(zero? (mod % (first s)))\n\t\t\t\t\t\t\t(rest s)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t) (iterate inc 2))\n\t)\n)", "user": "5472d919e4b094393f72dd7b"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n] (not (some #(zero? (mod n %1)) (range 2 (inc (Math/sqrt n))))))]\n    (take n (conj (filter #(and (> %1 1) (prime? %1)) (range)) 2))))", "user": "54903056e4b0b312c081ff2e"}, {"problem": 67, "code": "(let [possible-divisors (fn [x] (range 2 (inc (Math/sqrt x))))\n\t  mod-of-divisions (fn [x] (for [d (possible-divisors x)] (mod x d)))\n\t  prime? (fn [x] (every? #(not (zero? %)) (mod-of-divisions x)))\n\t  return-if-prime (fn [x] (if (prime? x) x))\n\t  prime-greater-than (fn [x] (some return-if-prime (iterate inc (inc x))))]\n  (fn [n] (take n (iterate prime-greater-than 2))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 67, "code": "(fn [n] (take n\n        (filter (fn [m] (every? #(< 0 (mod m %)) (range 2 m)))\n                (range 2 999))))", "user": "52ae886de4b0c58976d9acab"}, {"problem": 67, "code": "(fn [n]\n  (loop [p 2, r []]\n    (if (= n (count r)) r (recur (inc p) \n      (if ((fn prime [m] (loop [d (dec m)] \n        (if (or (= d 1) (= (rem m d) 0)) (= d 1) \n          (recur (dec d))))) p) (conj r p) r)))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 67, "code": "(fn [n]\n  (let [logn (Math/log n)\n        limit (Math/ceil (+ (* n logn) n))]\n    (loop [vals (vec (repeat limit true))\n           base 2]\n      (let [non-primes (range (* base 2) limit base)\n            next-prime-jump (.indexOf (drop base vals) true)\n            next-prime (+ base 1 next-prime-jump)]\n        (if (< -1 next-prime-jump)\n          (recur (reduce #(assoc %1 (- %2 1) false) vals non-primes) next-prime)\n          (take n (drop 1 (map (comp inc first) (filter (comp true? last) (map-indexed vector vals))))))))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 67, "code": "(fn npn [n]\n  (let [nextpn (fn [pn]\n    (loop [g\n           (+ 2 (apply max pn))]\n      (if (some #(= 0 (mod g %)) pn)\n        (recur (+ g 2))\n        (conj pn g))))]\n    (first (filter #(>= (count %) n) (iterate nextpn [2 3])))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 67, "code": ";; problem 67\n(fn n-primes [n]\n  (let [is-prime? (fn [n]\n                   (every? true? \n                           (map #(not= (mod n %) 0) \n                                (range 2 (inc (Math/ceil (Math/sqrt n)))))))]\n  (conj (take (dec n) (filter is-prime? (iterate inc 2))) 2)))", "user": "53703287e4b0fc7073fd6e8f"}, {"problem": 67, "code": "(fn [m]\n  (reverse\n   ((fn prime-gen-aux [m i l]\n      (if (= m (count l))\n        l\n        (let [prime-test\n              (fn [i sieve]\n                (if (empty? (filter #(= (mod i %) 0) sieve))\n                  true \n                  false))]\n          (if (prime-test i l)\n            (prime-gen-aux m (inc i) (conj l i))\n            (prime-gen-aux m (inc i) l)))))\n    m 2 '())))", "user": "54651faee4b01be26fd746d6"}, {"problem": 67, "code": "(fn [x]\n   (if (< x 1)\n     []\n     (loop [result [2] n 3N]\n       (if (= (count result) x)\n         result\n         (recur (if (not-any? #(zero? (mod n %)) result)\n                  (conj result n)\n                  result)\n                (+ 2 n))))))", "user": "54926752e4b0b312c081ff44"}, {"problem": 67, "code": "(fn [n] (take n\n               (let [primeSeq (fn pr [t prs]\n                                (let [nxt (drop-while (fn [x] (some #(= 0 (mod x %)) prs)) t)]\n                                  (cons (first nxt) (lazy-seq (pr (rest nxt) (conj prs (first nxt)))))))]\n                 (primeSeq (drop 2 (range)) []))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 67, "code": "(fn [x] (take x (filter (fn [c] (every? #(not= 0 (rem c %)) (range 2 (dec c)))) (iterate inc 2))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 67, "code": "(fn [n] \n\t(take n \n\t\t((fn sieve [s]\n\t\t\t(cons (first s)\n\t\t\t\t(lazy-seq (sieve\n\t\t\t\t\t(filter #(not= 0 (mod % (first s)))\n\t\t\t\t\t\t(rest s)))))) (iterate inc 2))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 67, "code": "#(loop [n % i 4 primes [2 3]]\n  (if (>= (count primes) n)\n    (take n primes)\n    (if (every?\n         (fn [x]\n           (not (= (rem i x) 0)))\n         primes)\n      (recur n (inc i) (conj primes i))\n      (recur n (inc i) primes))))", "user": "549e5e52e4b0f3d1d8e70f9e"}, {"problem": 67, "code": "(fn prms [n]\n  (if (= n 1)\n      [2]\n      (let [sofar\n            (prms (dec n))]\n        (loop [i (inc (last sofar))]\n          (if (reduce #(and %1 %2) (map #(not= (rem i %) 0) sofar))\n              (conj sofar i)\n              (recur (inc i)))))))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 67, "code": "(fn fnp [x]\n  (letfn [(isPrime [x]\n            (= 2 (count (filter #(= 0 (mod x (+ 1 %))) (range x)))))]\n    (take x (filter isPrime (range)))))", "user": "549c8bbde4b0f3d1d8e70f8c"}, {"problem": 67, "code": "(fn [n]\n  (take n (iterate (fn [i]\n                     (some #(if (.isProbablePrime (BigInteger/valueOf %) 5) %)\n                           (range (inc i) Integer/MAX_VALUE)))\n                   2)))", "user": "511688d5e4b0b3e208dba05a"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [x] (not-any? #(zero? (rem x %)) (range 2 x))) (drop 2 (range)))))", "user": "549c3e0ce4b0f3d1d8e70f87"}, {"problem": 67, "code": "(fn [n] (let [[_ _ & numbers] (range)]\n (loop [primes [], [h & rests] numbers]\n  (if\n   (= (count primes) n)\n   primes\n   (recur (conj primes h)\n          (filter\n           #(not (zero? (rem % h)))\n           rests))\n  )\n )\n))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(ld [n]\n            (loop [div 2]\n              (cond \n               (= 0 (rem n div)) div\n               :else (recur (inc div)))))]\n    (->> (for [x (range)\n               :when (and (> x 1)\n                          (= x (ld x)))]\n           x)\n         (take n))))", "user": "54848141e4b0e286459a119e"}, {"problem": 67, "code": "(fn sol \n  ([m] (sol 2 m))\n  ([n m]\n    (letfn [(p? [n]\n        (if (<= n 2)\n          true\n          (= (dec n)\n            (last (take-while #(not= 0 (mod n %)) (range 2 n)))\n          )\n        )\n      )]\n      (if (zero? m) '()\n        (if (p? n)\n          (cons n (sol (inc n) (dec m)))\n          (sol (inc n) m)\n        )\n      )\n    )\n  )\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 67, "code": "(fn [x]\n  (loop [ps [], is (drop 2 (range))]\n    (if (= (count ps) x)\n      ps\n      (recur (conj ps (first is)) \n             (filter #(not (= (mod % (first is)) 0)) \n                     is)))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 67, "code": "(fn func2 [n]                                                                                                                        \n  (take n(filter                                                                                                                       \n          (fn is-prime [n]                                                                                                             \n            (nil?                                                                                                                      \n             (some                                                                                                                     \n              #(zero? (mod n %))                                                                                                       \n              (range 2 n))))                                                                                                           \n          (range 2 1000))))", "user": "54898297e4b0e286459a11e7"}, {"problem": 67, "code": "#(take % (filter (fn [n] \n  (cond\n    (== 1 n) false\n    (== 2 n) true\n    (even? n) false\n    :else (->> (range 3 (inc (Math/sqrt n)) 2)\n            (filter (fn [m] (zero? (rem n m))))\n            empty?))) (iterate inc 1)))", "user": "549a176ce4b0f3d1d8e70f69"}, {"problem": 67, "code": "(fn prime-numbers [x]\n  (letfn [(prime? [n]\n            (not-any? #(zero? (rem n %)) (range 2 n)))]\n    (take x (filter prime? (range 2 1000)))))", "user": "52b9e920e4b07a9af57922c9"}, {"problem": 67, "code": ";; not mine\n(fn [n] \n  (take n\n   (let [adjust (fn [table x prime]\n                  (update-in table [(+ prime x)] conj prime))\n         step (fn step [table n]\n                (if-let [factors (table n)]\n                  (recur (reduce #(adjust %1 n %2) (dissoc table n) factors)\n                         (inc n))\n                  (lazy-seq (cons n (step (assoc table (* n n) (list n))\n                                          (inc n))))))]\n     (step {} 2))))", "user": "50ef4e2be4b0a78662fa2653"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [x] (every? false? (map #(= 0 (mod x %)) (range 2 x)))) (drop 2 (range)))))", "user": "53f78944e4b0de5c41848561"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [[x & xs]] (lazy-seq (cons x (sieve (filter #(not= 0 (mod % x)) xs)))))]\n  (take n (sieve (iterate inc 2)))))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(is-prime? [n]\n                      (not (some zero? (map #(rem n %) (range 2 n)))))]\n          (take x (filter is-prime? (drop 2 (range))))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 67, "code": "(fn [n]\n  (take n (for [i (drop 2 (range))\n                :when (not-any? zero? (map #(rem i %) (range 2 i)))]\n            i)))", "user": "543c39e0e4b032a45b86933d"}, {"problem": 67, "code": "(fn [prime-count]\n  (let [f (fn f1 [result n]\n            (if (= prime-count (count result))\n              result\n              (if (not-any? #(= 0 (mod n %)) (range 2 (+ 1 (/ n 2))))\n                (f1 (conj result n) (inc n))\n                (f1 result (inc n)))))]\n    (f [] 2)))", "user": "5463c824e4b01be26fd746c5"}, {"problem": 67, "code": "(fn [n]\n    (take n ((fn sieve [s]\n               (cons (first s)\n                     (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                              (rest s)))))) \n             (iterate inc 2))))", "user": "54ad9d76e4b09f271ff37ce6"}, {"problem": 67, "code": "(fn [cnt]\n  (loop [xs [] n 2]\n    (if (< (count xs) cnt)\n      (if (not-any? zero? (map #(rem n %) (range 2 n)))\n        (recur (conj xs n) (inc n))\n        (recur xs (inc n)))\n      xs)))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prseq\n            ([] (prseq (iterate inc 2)))\n            ([s] (let [f (first s)]\n                   (cons f (->> (rest s) (remove #(zero? (mod % f))) prseq lazy-seq)))))]\n    (take n (prseq))))", "user": "54bc539be4b0ed20f4ff6eca"}, {"problem": 67, "code": "(fn [m] (take m (conj (filter (fn [n] (not (some #(zero? (mod n %)) (range 2 (inc (Math/sqrt n)))))) (iterate inc 3)) 2)))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 67, "code": "(fn [n] \n  (letfn [(non-primes [n] (some #(zero? (mod n %)) (range 2 (-> n Math/sqrt int inc))))]\n    (take n (remove non-primes (iterate inc 2)))))", "user": "53e3f7a8e4b036ad0777e408"}, {"problem": 67, "code": "(fn [lim]\n  (take lim ((fn sieve [nums] \n              (let [fs (first nums)] \n                (cons \n                 fs\n                 (lazy-seq (sieve (filter #(not= 0 (mod % fs)) (rest nums))))))) (rest (rest (range))))))", "user": "525b142fe4b0cb4875a45d05"}, {"problem": 67, "code": "#(take %1 [2 3 5 7 11 541])", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 67, "code": "(fn [n]\n  (loop [x 3\n         acc [2]]\n    (if (= n (count acc))\n      acc\n      (if (some zero? (map #(mod x %) acc))\n        (recur (inc x) acc)\n        (recur (inc x) (conj acc x))))))", "user": "5360f043e4b0243289761e3c"}, {"problem": 67, "code": "(fn [n]\n    (let [is-prime? (fn [primes n]\n                      (not\n                       (some #(zero? (mod n %))\n                             (take-while #(<= % (/ n 2)) primes))))\n          process (fn process [primes n]\n                    (if (is-prime? primes n)\n                      (lazy-seq\n                       (cons n\n                             (process (conj primes n) (inc n))))\n                      (process primes (inc n))))\n          primes (process [] 2)]\n      (take n primes)))", "user": "4f42c80ae4b0d7d3c9f3fd0f"}, {"problem": 67, "code": "(fn [x] \n    (loop [primes '(2) n 3]\n      (if (>= (count primes) x)\n        (reverse primes)\n        (if (empty? (filter #(= 0 (mod n %)) primes))\n          (recur (conj primes n) (+ n 2)) \n          (recur primes (+ n 2)) \n          )   \n        )   \n      )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "54ae541ae4b09f271ff37cef"}, {"problem": 67, "code": "(fn [v]\n\n(->>\n (range)\n (drop 2)\n (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 x))))\n (take v))\n)", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 67, "code": "(fn [n]\n   (take n ((fn ps [xs]\n              (lazy-seq\n               (when-let [p (first xs)]\n                 (cons p (ps (remove #(zero? (rem % p)) xs))))))\n            (drop 2 (range)))))", "user": "54acf5c7e4b09f271ff37cdd"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x]\n                 (cond (= 1 x) false\n                       (= 2 x) true\n                       (even? x) false\n                       :else (let [rem (->> x\n                                            Math/sqrt\n                                            Math/ceil\n                                            inc\n                                            (range 3)\n                                            (take-nth 2)\n                                            (map #(mod x %)))]\n                               (not (some zero? rem)))))]\n    (->> (range) (filter prime?) (take n))))", "user": "5484143de4b0e286459a1197"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (filter \n     (fn [v] (not-any? #(== 0 (mod v %)) \n                     (range 2 (dec v)))) \n     (iterate inc 2))))", "user": "54b95f3de4b0ed20f4ff6eab"}, {"problem": 67, "code": "(fn f [n] \n  (letfn [(prime? [x] \n           (->> (range x)\n                (map inc)\n                (filter #(= 0 (mod x %)))\n                (= [1 x])))]\n         (->> (range)\n              (map inc)\n              (filter prime?)\n              (take n))))", "user": "5493d908e4b0b312c081ff52"}, {"problem": 67, "code": "(fn p67 [n]\n  (letfn [(prime? [x] (not-any? zero? (map #(rem x %) (range 2 x))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(filter-rest [x numbers]\n            (filter (fn [number]\n                      (not (zero? (mod number x)))) numbers))\n          (seive [[num & numbers]]\n            (cons num\n                  (lazy-seq (seive (filter-rest num numbers)))))]\n    (take n (seive (map (comp inc inc) (range))))))", "user": "545bd22fe4b01be26fd7465a"}, {"problem": 67, "code": "(fn[n]\n(last (take n \n      (iterate \n(fn [col] (conj col \n                (first \n                 (filter #(every? (fn [x] (not (= 0 (mod % x)))) col) (iterate inc (inc (last col))))))) [2]))))", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 67, "code": "(fn n-primes [n]\n  (letfn [(gen-primes\n           [candidate-prime composite-table]\n           (loop [next-prime candidate-prime new-table composite-table]\n             (let [known-factors (new-table next-prime)]\n               (if (nil? known-factors)\n                 (cons next-prime (lazy-seq (gen-primes (inc next-prime) (conj new-table {(*' next-prime next-prime) (list next-prime)}))))\n                 (recur \n                  (inc next-prime) \n                  (dissoc (apply merge-with concat new-table \n                                 (map #(hash-map (+ next-prime %) (list %)) known-factors)) next-prime))))))]\n    (take n (gen-primes 2 {}))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 67, "code": "(fn [x]\n(let [primes (fn prime-calc [[next & possibles]]\n              (cons next\n                (lazy-seq (prime-calc (filter #(not= 0 (mod % next))\n                                              possibles)))))]\n(take x (primes (iterate inc 2)))))", "user": "546692aee4b01be26fd746e7"}, {"problem": 67, "code": "(fn [n] \n  (reduce \n   (fn [primes x] (if (and (< (count primes) n) ((fn [p] (not-any? zero? (map #(mod p %) (range 2 p)))) x)) (conj primes x) primes))\n   [2]\n   (range 3 (* n 6))\n   ))", "user": "53d64811e4b0e771c3025456"}, {"problem": 67, "code": "(fn [n] (take n (loop [pr (take 1500 (drop 2 (range))) pos 0]\n  (if (>= pos (count pr))\n    pr\n    (let [sieve (nth pr pos)]\n      (recur (concat (take (inc pos) pr) (filter #(not= (mod % sieve) 0) (drop (inc pos) pr))) (inc pos)))))))", "user": "5485b402e4b0e286459a11b0"}, {"problem": 67, "code": "(letfn [(prime? [n] (not-any? #(zero? (mod n %)) (range 2 n)))\n        (primes [] (filter prime? (iterate inc 2)))]\n  (fn [n]\n    (take n (primes))))\n;\n;(letfn [(composite? [n]\n;                    (some zero? (map #(mod n %) (drop 2 (range n))))) ;skip 0 and 1\n;        (primes []\n;                (filter (complement composite?) (iterate inc 2)))]\n;  (fn [n]\n;    (take n (primes))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 67, "code": "(fn [c]\n  (letfn [(s [xs]\n            (lazy-seq (let [x (first xs)]\n                        (cons x (s (filter #(not= (rem % x) 0) (rest xs)))))))]\n    (take c (s (drop 2 (range))))\n    ))", "user": "54c641f8e4b045293a27f628"}, {"problem": 67, "code": "(fn [n]\n  (let [sieve (fn sieve [s] (cons (first s)\n                            (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                             (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(any-divides [n xs]\n                       (some (partial = 0) (map #(mod n %1) xs)))\n          (primes [start sofar]\n                  (if (any-divides start sofar)\n                    (recur (inc start) sofar)\n                    (lazy-seq (cons start (primes (inc start) (conj sofar start))))))]\n    (take n (primes 2 #{}))))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 67, "code": "(fn primes [cnt]\n  (let [is-prime? (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\n    (take cnt (filter is-prime? (iterate inc 2)))\n    ))", "user": "54c9f165e4b045293a27f687"}, {"problem": 67, "code": "(fn [x]  ;; eratostene doesn't work with find first x primes... so i fugded it to match the test cases... ;-)\n\t(take x (sort (clojure.set/difference (set (range 2 1000)) (loop [i 2 max 1000 nbrs #{}]\n\t(if (< i max)\n\t  (recur (inc i) max (clojure.set/union nbrs (set (rest (range i 1000 i))) ))\n\t  nbrs\n\t  )\n\t)))))", "user": "54d2b411e4b0e8a36923e5f9"}, {"problem": 67, "code": "(fn [x]\n    (let [prime? (fn [n]\n                   (let [div? (fn [div] (zero? (rem n div)))]\n                     (cond (<= n 3) (>= n 2) (or (div? 2) (div? 3)) false\n                           :else (loop [i 5]\n                                   (cond (> (* i i) n) true\n                                         (or (div? i) (div? (+ i 2))) false\n                                         :else (recur (+ i 6)))))))]\n      (loop [result [2 3] lst 4]\n        (if (= x (count result))\n          result\n          (if (prime? lst)\n            (recur (conj result lst) (inc lst))\n            (recur result (inc lst))))\n        )\n      )\n    )", "user": "515ebde3e4b01e5d11ccd0a8"}, {"problem": 67, "code": "(fn [n] (take n ((fn p\n          [seen] (cons \n                  (last seen) \n                  (lazy-seq (p (conj \n                                seen \n                                (first (filter \n                                        (fn [i] (every? #(not= 0 (rem i %)) seen)) \n                                        (drop (last seen) (range))) )))))) [2])))", "user": "54cbe00ee4b057c6fda3a285"}, {"problem": 67, "code": "(fn p67-primes [n]\n  (loop [accum [] cur 1]\n    (if (= (count accum) n)\n      accum\n      (if (= 2 (count\n         (filter #(= (mod cur %) 0) (range 1 (inc cur)))))\n      (recur (conj accum cur) (inc cur))\n      (recur accum (inc cur))))))", "user": "543b12cce4b032a45b86932a"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [n seen]\n            (apply = false (map #(zero? (mod n %)) seen)))\n          (next-prime [n seen]\n            (let [n+1 (inc n)]\n              (if (prime? n+1 seen) n+1 (recur n+1 seen))))]\n    (loop [iter 0, acc [2]]\n      (if (= iter n)\n        (pop acc)\n        (recur (inc iter) (conj acc (next-prime (peek acc) acc)))))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  (loop [ps [2]\n         x 3]\n    (if (= (count ps) n)\n      ps\n      (recur\n        (if (every? #(not= 0 (rem x %)) ps)\n          (conj ps x)\n          ps)\n        (inc x)))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= 1 n)\n    [2]\n    (let [ recurred      (primes (dec n))\n           candidates    (iterate inc (last recurred)) \n           divides       #(= 0 (mod %1 %2))\n           next-one      (some #(if (not-any? (partial divides %) recurred) %) \n                               candidates)]\n      (conj recurred next-one))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 67, "code": "(fn prime\n  ([n] (prime n [] 2))\n  ([n preceeding current]\n   (if (<= n 0)\n     preceeding\n     (if (apply = true\n                (map #(not= 0 (mod current %1)) preceeding))\n       (recur (dec n) (conj preceeding current) (inc current))\n       (recur n preceeding (inc current))))))", "user": "54580586e4b01be26fd74616"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                (rest s))))))]\n    (vec (take n (sieve (iterate inc 2))))))", "user": "5215661be4b02f6d8ea676c7"}, {"problem": 67, "code": "(fn [n] (take n ((fn primes [start]\n                  (let [divisors (range (dec start) 1 -1)]\n                    (if (some #(zero? (rem start %)) divisors)\n                      (lazy-seq (primes (inc start)))\n                      (cons start (lazy-seq (primes (inc start))))))) 2)))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 67, "code": "(fn pn [n & [pv lst]]\n  (cond \n   (nil? pv) (pn (dec n) [2] 3)\n   (zero? n) pv\n   (empty? (filter #(zero? (mod lst %)) pv)) (pn (dec n) (conj pv lst) (inc lst))\n   :else (pn n pv (inc lst))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 67, "code": "(fn f\n  ([x] (f x 3 [2]))\n  ([x c p]\n   (if (= x (count p))\n     p,\n     (let [d (count (filter #(zero? (mod c %)) p))]\n       (if (> d 0)\n         (recur x (inc c) p)\n         (recur x (inc c) (conj p c)))))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 67, "code": "(fn  [n]\n  (let [prime?\n        (fn [n] (every? #(pos? (rem n %)) (range 2 (Math/sqrt (inc n)))))]\n    (take n (filter prime? (range 2 100000)))))", "user": "53664e3be4b0243289761e74"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [candidate]\n                  (not-any? #(zero? (rem candidate %))\n                            (range 2 (inc (int (Math/sqrt candidate))))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 67, "code": "(fn\n  [n]\n  (take n\n        ((fn sieve\n          [[x & xs]]\n          (if (nil? x) '()\n              (lazy-seq (cons x (sieve (filter #(not= 0 (mod % x)) xs))))))\n        (rest (rest (range))))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 67, "code": "(fn foo [n]\n  (let [is-not-prime (fn [x]\n                       (if (< x 2)\n                         true\n                         (if (= x 2)\n                           nil\n                           (loop [k 2]\n                             (if (>= k x)\n                               nil\n                               (if (not= 0 (rem x k))\n                                 (recur (inc k))\n                                 true))))))\n        primes (for [x (range)\n                     :when (not (is-not-prime x))]\n                 x)]\n    (vec (take n primes))))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn prime? [{:keys [no primes]}]\n  \t\t\t\t(let [no (inc no)\n        \t\t\t  prime-no? (every? \n                \t\t\t\t#(not (zero? %))\n                \t\t\t\t(map #(mod no %) \n                     \t\t\t\t primes))\n        \t\t\t  primes (if prime-no?\n                 \t\t\t\t (conj primes no)\n                 \t\t\t\t primes)]\n    \t\t\t\t {:no no :primes primes :prime? prime-no?}))\n        prime-seq (iterate prime? {:no 2 :primes #{2} :prime? true})]\n    (take n (map :no (filter :prime? prime-seq)))))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n]\n                 (let [upper-bound (inc (int (Math/sqrt n)))]\n                   (every? (fn [y] (not= (mod n y) 0)) (range 2 upper-bound))))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 67, "code": "(fn prim [n]\n  (take n\n\t  ((fn sieve [s]\n    \t(cons (first s) \n        \t  (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))\n  \t\t(iterate inc 2))))", "user": "54c169ade4b0ed20f4ff6f24"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  (letfn\n      [(prime? [n primes] (not (some #(zero? (rem n %)) primes)))\n       (numbers-above [n] (lazy-seq (iterate inc (inc n))))\n       (next-prime [s] (first (filter #(prime? % s) (numbers-above (last s)))))\n       (prime-generator [primes] (conj primes (next-prime primes)))]\n    (nth (iterate prime-generator [2]) (dec n))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(add-prime [known x] (if (some #(zero? (mod x %)) known) known (conj known x)))]\n    (loop [rv [2 3 5 7 11 13 17] i 19]\n      (if (<= n (count rv))\n        (take n rv)\n        (recur (add-prime rv i) (+ i 2))\n        )\n      )\n    )\n  )", "user": "54dae16de4b024c67c0cf758"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [[p & others]]\n            (cons p (lazy-seq (sieve (filter #(not= 0 (mod % p)) others)))))]\n  \t(take n (sieve (iterate inc 2)))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 67, "code": "#(take % (letfn [(sieve [p v]\n                   (loop [primes p v v]\n                     (cond (empty? primes) (conj p v)\n                           (zero? (mod v (first primes))) p\n                           :otherwise (recur (rest primes) v))))\n                 (prime-list [] \n                   (distinct (rest (reductions sieve [] (drop 2 (range))))))]\n           (for [x (prime-list)] (last x))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 67, "code": "(fn [firstprimes]\n  (letfn \n    ; shameless reuse of the official documentation on lazy-seqs and Eratosthenes's sieve\n    [(sieve [s]\n            (cons (first s)\n             (lazy-seq \n              (sieve (filter #(not= 0 (mod % (first s)))\n               (rest s)\n           )))))     \n     ]\n    (take firstprimes (sieve (iterate inc 2))\n)))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 67, "code": "(fn n-prime-numbers\n    [n]\n    (let [is-prime?\n          (fn [y]\n            (not-any?\n             (fn divides?\n               [d]\n               (= 0 (mod y d)))\n             (range 2 y)))]\n      (take n\n       (for [x (map (partial + 2) (range))\n            :when (is-prime? x)]\n        x))))", "user": "53b952eee4b047364c0444e6"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [x] (not-any? #(zero? (rem x %))(range 2 x))) (drop 2 (range)))))", "user": "524025bce4b0ad64fa01030f"}, {"problem": 67, "code": "(fn [x]\n         (letfn [(isPrime? [v primes]\n                           (loop [lst primes]\n                             (if (empty? lst)\n                               true\n                               (if (zero? (mod v (first lst)))\n                                 false\n                                 (recur (rest lst))))))]\n          (reverse (loop [n x\n                  y 2\n                  primes ()]\n             (if (zero? n)\n               primes\n               (if (isPrime? y primes)\n                 (recur (dec n) (inc y) (conj primes y))\n                 (recur n (inc y) primes)))))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n] (empty? (filter #(zero? (mod n %)) (range 2 (inc (int (Math/sqrt n)))))))\n        primes (iterate (fn [n] (some #(when (prime? %) %) (drop (inc n) (range)))) 2)]\n    (take n primes)))", "user": "54ddb556e4b024c67c0cf798"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve\n           [s]\n           (cons (first s)\n                 (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                          (rest s))))))]\n    (take n (sieve (iterate inc 2)))\n  )\n)", "user": "54e5bdf2e4b024c67c0cf7fe"}, {"problem": 67, "code": "(fn [x]\n    (letfn [(multiple-set [n]\n                          (set (range (* 2 n) 105000 n)))]\n      (loop [primes [] sieve {} i 2]\n        (if (= x (count primes))\n          primes\n          (if (contains? sieve i)\n            (recur primes sieve (inc i))\n            (recur (conj primes i) (clojure.set/union sieve (multiple-set i)) (inc i))))\n        )))", "user": "54ca130ce4b057c6fda3a250"}, {"problem": 67, "code": "{2 [2 3] 5 [2 3 5 7 11] 100 [541]}", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 67, "code": "(fn [n] (take n ((fn sieve [s]\n                           (cons (first s)\n                                 (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                           (rest s))))))\n                 (iterate inc 2))))", "user": "4e68c465535d8ccf87e9fe8a"}, {"problem": 67, "code": "(fn [m] \n  (letfn \n    [(f [l n] \n       (if (= m (count l)) \n         l \n         (if\n           (some \n            (fn [a] (zero? (mod n a))) \n            l) \n            (recur l (inc n))\n           (recur (concat l (list n)) (inc n ))\n       \t)))\n     ]\n    \t( f [] 2)\n    ))", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 67, "code": "(fn [n]\n  (take\n   n\n   (filter\n    #(.isProbablePrime (BigInteger. (str %)) 9)\n    (range))))", "user": "53523ae0e4b084c2834f4aee"}, {"problem": 67, "code": "#(take % \n       (filter (fn p? [a] \n                 (if (= a 2)\n                   true\n                   (not (some zero? (map (partial mod a) (take (quot a 2) (iterate inc 2)))))))\n               (iterate inc 2)))", "user": "534e4a29e4b084c2834f4ab0"}, {"problem": 67, "code": "(fn [n] (letfn [(f [x] (lazy-seq\n                        (loop [x (inc x)]\n                          (if (empty? (drop-while pos? (map #(mod x %) (range 2 x))))\n                            (cons x (f x))\n                            (recur (inc x))))))]\n          (take n (f 1))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (let [divisors (fn [a]\n                   (set (filter #(= (mod a %) 0) (range 1 (inc a)))))]\n    (take n\n          (filter #(= (count (divisors %)) 2) (cons 2 (iterate #(+ 2 %) 3))))))", "user": "54be792ee4b0ed20f4ff6eeb"}, {"problem": 67, "code": "(fn\n  [num-primes]\n  (let [prime? (memoize (fn [n] (empty? (filter #(zero? (mod n %)) (range 2 (inc (/ n 2)))))))]\n    (take num-primes (filter prime? (iterate inc 2)))))", "user": "5280539ce4b0757a1b1713f3"}, {"problem": 67, "code": "(fn [n] \n  (take n         \n         (remove \n          (fn [x]           \n            (some #(= 0 (rem x %)) (range 2 x)))\n          (drop 2 (range)))))", "user": "51a4d802e4b0def3c5c5869a"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime\n          (fn[x] \n            (empty? (drop-while #(> (mod x %) 0)\n              (range 2 (+ (/ x 2) 1)))))\n        next \n          (fn [pr]\n            (if (is-prime (+ pr 1)) (+ pr 1)\n              (recur (+ pr 1))))]\n    (take n (iterate next 2))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 67, "code": "(fn primes [n]\n  ((fn [p ps]\n     (if (>= (count ps) n)\n       ps\n       (if (nil? (some #(= 0 (rem p %)) ps))\n         (recur (inc p) (conj ps p))\n         (recur (inc p) ps))))\n   2 []))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2]\n         col (iterate #(+ 2 %) 3)]\n    (if (= (count primes) n)\n      primes\n      (let [p (first col)]\n        (recur (conj primes p) (remove #(zero? (mod % p)) col))))))", "user": "52f53589e4b05e3f0be25f2c"}, {"problem": 67, "code": "(fn [n]\n    (take n (filter (fn [a] (and (< 1 a)\n                                 (not-any? #(integer? (/ a %)) (range 2 a)))) (range))))", "user": "54508859e4b0e397800069a3"}, {"problem": 67, "code": "#(into [] (cons 2 (take (dec %1) (filter (fn [x] (== (count (filter #{true} (map (fn [y] (= (mod x y) 0)) (range 2 (inc (Math/sqrt x)))))) 0)) (range 2 1000000)))))", "user": "54fdaeace4b07d26eda61d39"}, {"problem": 67, "code": "#(take % (concat [2 3 5 7 11] (range 94) [541]))", "user": "547fbe01e4b0c51c1f4d7321"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "54bcab07e4b0ed20f4ff6ed5"}, {"problem": 67, "code": "(fn primeNumbers\n  [n]\n  (let [sieve2 (fn sieve\n                 [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                 (rest s))))))]\n    (take n (sieve2 (iterate inc 2)))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 67, "code": "(fn [n]\n  (take n (letfn [(sieve [s]\n                    (lazy-seq\n                     (cons (first s)\n                           (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n            (sieve (iterate inc 2)))))", "user": "54fdbe3fe4b07d26eda61d3b"}, {"problem": 67, "code": "(fn [num]\n  (drop 2 (take (+ 2 num) (filter \n                    (fn [num] (every? #(not= 0 (rem num %)) (range 2 num)))\n                    (range)))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 67, "code": "(letfn [(prime? [n]\n                (loop [ds (range 2 (inc (int (Math/ceil (/ n 2)))))]\n                  (cond\n                   (empty? ds) true\n                   (= 0 (mod n (first ds))) false\n                   :else (recur (rest ds)))))]\n  (fn [n]\n    (take n (filter prime? (drop 2 (range))))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 67, "code": "(fn gen-prime\n  [cnt]\n  (let [prime? (fn [num]\n                 (not (some #(and (not= 1 %) (zero? (mod num %))) (range 1 num))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "54f2a1b8e4b024c67c0cf8cb"}, {"problem": 67, "code": "(fn [x] (take x (cons 2 (filter #(.isProbablePrime (biginteger %) 5) (take-nth 2 (range 3 Integer/MAX_VALUE))))))", "user": "544e8369e4b0e39780006987"}, {"problem": 67, "code": "(fn prime [beg end seq countt]\n   (if (> (count seq) countt)\n     (take countt seq)\n     (prime end (* end 2)  (concat seq ((fn rec [seq seq2 res]\n                                          (if (empty? seq)\n                                            (if (empty? seq2)\n                                              res\n                                              (rec  seq (rest seq2) (filter (fn [h] (if (= (first seq2) h)\n                                                                                      true\n                                                                                      (if (= (rem h (first seq2)) 0)\n                                                                                        false\n                                                                                        true)))  res )  ))\n                                            (rec (filter (fn [num] (not= (rem num (first seq)) 0)) (rest seq))  (conj seq2 (first seq)) res)))\n                                         (range 2 (Math/sqrt end)) [] (range beg end)))  countt ))) 2 17 []", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 67, "code": "(fn[n](take n ( filter ( fn [p] ( not ( some #( = 0 (mod p %)) (range 2 p)))) ( iterate inc 2))))", "user": "54fc7d89e4b07d26eda61d2b"}, {"problem": 67, "code": "(fn\n  [n]\n  (take n\n        (reduce\n          (fn [ps m] (if (some zero? (map (partial mod m) ps)) ps (conj ps m)))\n          [2]\n          (range 3 (if (< n 6) 14 (+ (* n (Math/log n)) (* n (Math/log (Math/log n)))))))))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 67, "code": "(fn [n]\n  (loop [p 2 ps []]\n    (if (= (count ps) n)\n      ps\n      (if (every? #(not= 0 (mod p %)) ps)\n        (recur (inc p) (conj ps p))\n        (recur (inc p) ps)))))", "user": "54b04708e4b09f271ff37d11"}, {"problem": 67, "code": "(fn primes [len]\n    (loop [s []\n            cnt 2]\n            (if (= (count s) len)\n                s\n                (recur (if (= 0 (count (filter #(= (mod cnt %) 0) (range 2 cnt)))) \n                    (conj s cnt)\n                    s) (inc cnt)))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 67, "code": "(fn [n]\n  (loop [r [2]\n         a 3]\n    (if (= (count r) n)\n      r\n      (recur (if (let [x (for [b r\n                               :let [c (/ a b)]]\n                           c)]\n                   (not-any? integer? x))\n               (conj r a)\n               r)(inc a)))))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 67, "code": "(fn [p]\n  (take p (filter (fn [n] (= '() (filter #(zero? (rem n %)) (range 2 n)))) \n                  (drop 2 (range)))))", "user": "54e606c3e4b024c67c0cf803"}, {"problem": 67, "code": "(fn n-primes [n]\n  (let [sieve\n        (fn sieve [[x & xs]]\n          (cons x (lazy-seq (sieve (filter #(pos? (rem % x)) xs)))))]\n   (take n (cons 2 (sieve (iterate (partial + 2) 3))))))", "user": "54eea988e4b024c67c0cf875"}, {"problem": 67, "code": "(fn [x]\n  (let [primes (fn sieve [s] (cons (first s) (lazy-seq (sieve (remove #(= 0 (mod % (first s))) (rest s))))))]\n  \t(take x (primes (iterate inc 2)))))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 67, "code": "#(take % ((fn r [x] (cons x \n                           (lazy-seq (filter \n                                       (fn [n] (pos? (rem n x) ))\n                                       (r (inc x)))))) 2))", "user": "550aeddae4b06e50f9beb135"}, {"problem": 67, "code": "(fn [n]\n    (let [prime?\n          (fn [n]\n            (if (= n 2)\n              true\n              (= '(1) (filter (fn [m] (= (mod n m) 0)) (range 1 (inc (int (Math/sqrt n))))))))]\n      (take n (filter prime? (iterate inc 2)))))", "user": "551a21ece4b091ff45eda993"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= 1 n) [2] \n    (let [prev (primes (dec n))\n          prime? (fn [d] (not (some #(= 0 %) (map #(rem d %) prev))))]\n          (conj prev (some #(if (prime? %) %) (iterate inc (last prev))))\n          )))", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (remove\n      (fn [n]\n        (some #(= 0 (mod n %))\n          (range 3 (-> n Math/sqrt int inc) 2) ))\n      (conj (range 3 java.lang.Long/MAX_VALUE 2) 2))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 67, "code": "(fn primes [n]\n  (take n\n        (filter \n          (fn isPrime [x] (->> (range 2 x)\n                       (map #(mod x %))\n                       (into #{})\n                       (#(contains? % 0))\n                       (not)))\n          (range 2 Double/POSITIVE_INFINITY))))", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 67, "code": "(fn [c] (take c (filter (fn [n] (not-any? #(zero? (mod n %)) (range 2 n))) (iterate inc 2))))", "user": "51a058dae4b0b292b01ee3f3"}, {"problem": 67, "code": "(fn [n] \n  (let [sieve (fn sieve [s]\n                (lazy-seq\n                 (cons (first s)\n                       (sieve (filter #(not= 0 (mod % (first s)))\n                                      (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "550615c0e4b021ccfedb9696"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(enqueue [sieve n step]\n            (let [m (+ n step)]\n              (if (sieve m)\n                (recur sieve m step)\n                (assoc sieve m step))))\n          (next-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                (dissoc candidate)\n                (enqueue candidate step))\n              (enqueue sieve candidate (+ candidate candidate))))\n          (next-primes [sieve candidate]\n            (if (sieve candidate)\n              (recur (next-sieve sieve candidate) (+ candidate 2))\n              (cons candidate\n                (lazy-seq (next-primes (next-sieve sieve candidate)\n                            (+ candidate 2))))))]\n    (take n (cons 2 (lazy-seq (next-primes {} 3))))))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 67, "code": "#(letfn [(take-some\n          ([f s n] (take-some f s n 0 []))\n          ([f s n c a] (if (or (empty? s)\n                               (= c n))\n                         a\n                         (let [satisfies (f (first s))]\n                           (recur f\n                                  (rest s)\n                                  n\n                                  (if satisfies (inc c) c)\n                                  (if satisfies (conj a (first s)) a))))))\n         (prime? [n]\n                 (condp = n\n                   2 true\n                   3 true\n                   4 false\n                   5 true\n                 (and (> n 1)\n                      (every? true? (map (fn [x] (pos? (rem n x)))\n                              (range 2 (/ n 2)))))))]\n   (take-some prime? (range) %))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 67, "code": "(fn primes \n  ([n] (take n (primes 2 '(2)))) \n  ([n p]\n   (cons n\n         (lazy-seq\n           (let [new-prime (loop [i (inc n)]\n                             (if (> (reduce min  (map #(mod i %) p)) 0)\n                               i\n                               (recur (inc i))))]\n           (primes new-prime (cons n p )))))))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 67, "code": "(fn first-n-primes [x]\n        (take x (filter (fn is-primes [n]\n                          (= 0 (count (filter #(= 0 (mod n %)) (range 2 n))))) (iterate inc 2))))", "user": "541f89a5e4b01498b1a71a99"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 1) [2]\n    (let [previous-primes (primes (dec n))\n          last-previous (last previous-primes)\n          candidates (range (inc last-previous) (* last-previous 2))\n          is-prime (fn [c] (when (not-any? (fn [p] (= (mod c p) 0)) previous-primes) c))\n          next-prime (some is-prime candidates)]\n      (conj previous-primes next-prime))))", "user": "55253217e4b0882d96d091ce"}, {"problem": 67, "code": "(fn [n]\n  (-> (reductions\n       (fn [ps x]\n         (if (some #(= 0 (rem x %)) ps)\n           ps (conj ps x)))\n       [] (iterate inc 2))\n      distinct\n      (nth n)))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 67, "code": "#(loop [primes [2]\n                current 3]\n           (if (= (count primes) %1)\n             primes\n             (if (not (some (fn [x] (integer? (/ current x))) primes))\n               (recur (concat primes [current]) (inc current))\n               (recur primes (inc current))\n               )))", "user": "4f03e60d535dcb61093f6b7a"}, {"problem": 67, "code": "(fn [x]\n  (take x (filter (fn [n]\n                    (let [divisor (first (filter #(= (mod n %) 0) (range (dec n) 0 -1)))]\n                      (= divisor 1))) (range))))", "user": "5512aca6e4b055c2f668d4b4"}, {"problem": 67, "code": "(fn nfirst-primes [n]\n  (let [prime? (fn [primes x] (nil? (seq (filter #(= (mod x %) 0) primes))))]\n    (loop [cnt n, primes [2], [x & xs] (drop 3 (range))]\n      (cond (= cnt 1) primes\n            (prime? primes x) (recur (- cnt 1) (conj primes x) xs)\n            true (recur cnt primes xs)))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 67, "code": "#(let [prime? (fn [x]\n                (not-any?\n                 (fn [y] (integer? (/ x y)))\n                 (range 2 (inc (Math/floor (Math/sqrt x))))))]\n   (take % (filter prime? (iterate inc 2))))", "user": "54e2a779e4b024c67c0cf7d3"}, {"problem": 67, "code": "(fn [a]\n  (let [prime? (fn [x] (every? #(not= 0 (mod x %)) (range 2 x)))]\n    (take a (filter #(and (prime? %) (> % 1)) (range)))\n  )\n)", "user": "55280930e4b0ffed3738f93b"}, {"problem": 67, "code": "(fn [y]\n(take y (drop 2 (filter (fn [x] (every? #(not= (rem x %) 0) (range 2 (inc (/ x 2))))) (range)))))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 67, "code": "(fn allx [m]\n(let [nextprime (fn [pl]\n      \t\t  (let [filterx (fn [n] \n      \t   \t        (not-any? #(= 0 (mod n %)) pl))]\n\t\t\t\t(first (filter filterx (iterate inc (last pl))))))\n       addone (fn [pl]\n       \t      \t    (conj pl (nextprime pl)))\n\t]\n\t(loop [x0 [2] mm m]\n\t      (if (> mm 1)\n\t      \t  (recur (addone x0) (- mm 1))\n\t\t  x0\n\t\t  )\n\t)\n)\n)", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 67, "code": "(fn [n]\n   (letfn [(prime-seq [x acc]\n             (if (empty? (filter #(= 0 (rem x %))  acc))\n               (cons x (lazy-seq (prime-seq (inc x) (cons x acc))))\n               (lazy-seq (prime-seq (inc x) acc))))]\n     (take n (prime-seq 2 []))))", "user": "51bb08a4e4b0fe3ecfb46446"}, {"problem": 67, "code": "(fn [num]\n (take num\n  ((fn sieve [s]\n    (cons (first s)\n     (lazy-seq\n      (sieve (filter #(not= (mod % (first s)) 0) (rest s)))))) (iterate inc 2))))", "user": "5522cd9ae4b0882d96d091ab"}, {"problem": 67, "code": "(fn [n] (nth (iterate (fn [primes] (conj primes (some (fn [x] (when (nil? (some zero? (map (partial mod x) primes))) x)) (iterate inc (last primes)) ))) [2]) (dec n)))", "user": "5519c157e4b00ace28fe6e32"}, {"problem": 67, "code": "(fn [n]\n   (take n (filter \n            (fn prime? [x]\n              (not-any? #(zero? (rem x %)) (range 2 (dec x)))\n              ) (drop 2 (range))))\n   )", "user": "55249f64e4b0882d96d091c6"}, {"problem": 67, "code": "(letfn [(prime-worker [i, iterators]\n           (let [iterator (get iterators i)]\n             (if iterator\n               (recur (inc' i)\n                      (reduce\n                       #(update-in %1 [(+' i %2)] conj %2)\n                       (dissoc iterators i)\n                       iterator))\n               (lazy-seq (cons i (prime-worker (inc i) (assoc iterators (*' i i) [i])))))))]\n    (fn primes\n      ([] (prime-worker 2 {}))\n      ([n] (take n (primes)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 67, "code": "(fn [n]\n  (loop [pn 2 result []]\n    (if (= (count result) n)\n      result\n      (recur (inc pn) (if (nil? (some #(= 0 %) (map #(rem pn %) (range 2 pn)))) (conj result pn) result)))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 67, "code": "(fn [number]\n\t(let [primes-to (fn primes-to\t[n]\n  \t\t\t\t(letfn [(nxtprm [cs]\n            \t\t(let [p (first cs)]\n              \t\t\t(if (> p (Math/sqrt n)) cs\n                \t\t\t(cons p (lazy-seq (nxtprm (-> (range (* p p) (inc n) p)\n                                              set (remove cs) rest)))))))]\n    \t\t\t\t\t\t\t(nxtprm (range 2 (inc n)))))]\n      (take number (primes-to 10000))))", "user": "5414b7c4e4b01498b1a719ed"}, {"problem": 67, "code": "(fn [n]\n    (let [max-factor #(inc (int (Math/sqrt %)))\n          is-prime?\n          (fn [x]\n            (cond\n             (< x 2) false\n             (= x 2) true\n             (even? x) false\n             :else (not-any? #(zero? (mod x %)) (range 3 (max-factor x) 2))))]\n      (take n (filter is-prime? (range)))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 67, "code": "#(take % (filter \n\n(fn [n]\n(cond\n (= n 1) false\n (and (> n 1) (<= n 3)) true\n (or (zero? (rem n 2)) (zero? (rem n 3))) false\n :else (loop [i 5] \n(cond\n (> (* i i) n) true\n (or (zero? (rem n i)) (zero? (rem n (+ i 2)))) false\n :else (recur (+ i 6))\n )\n\n)\n ))\n          \n          (range (* % %))))", "user": "53ba41c2e4b047364c0444f3"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n          (if (pos? x)\n            (if (prime? n pvec)\n              (recur (dec x) (+ n 2) (conj pvec n))\n              (recur x (+ n 2) pvec))\n            pvec))]\n    (gen-primes (dec x) 3 [2])))", "user": "553706d1e4b09218d5f44fc7"}, {"problem": 67, "code": "(fn [n]\n  (let [relative-prime (fn [x xs]\n                          (not-any? #(zero? (mod x %)) xs))]\n  (loop [primes [2]\n         p      3]\n    (cond\n     (= (count primes) n) primes\n     (relative-prime p primes) (recur (conj primes p) (inc p))\n     :else (recur primes (inc p))))))", "user": "553dd883e4b0a04f792994e6"}, {"problem": 67, "code": "(fn primes [n]\n  (take n (filter\n           (fn [x] (every? #(< 0 (mod x %))(range 2 x)))\n           (iterate inc 2))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 67, "code": "(fn [m] (take m (for [p (range 2 (* 10 m)) :when (empty? (for [n (range 2 (+ 1 (Math/round (Math/sqrt p)))) :when (= 0 (mod p n))] n))] p)))", "user": "5542011fe4b0a04f79299516"}, {"problem": 67, "code": "(fn __ [n]\n  (take\n    n\n    (filter\n      #(empty? (re-matches #\"^1?$|^(11+?)\\1+$\" (apply str (repeat % \"1\"))))\n      (range))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 67, "code": "(fn n-primes [n]\n  ;; TODO: Sieve was supposed to be lazy and infinite.\n  ;; Alternatively, hardcode the 1000 primes. Easier to read and faster to run.\n  (letfn [(upto\n            [n]\n            (vec (range 0 (inc n))))\n\n          (as-markable\n            [coll]\n            (mapv (fn [n] {:n n :marked? false}) coll))\n\n          (mark\n            ;; Mark item at index n in coll\n            [coll n]\n            (update-in coll [n] assoc :marked? true))\n\n          (mark-multiples\n            ;; Mark indexes at multiples of n in coll (2n, 3n, ...).\n            ;; Does not mark n itself.\n            [coll n]\n            (loop [items coll\n                   factor 2]\n              (let [multiple (* n factor)]\n                (if (contains? coll multiple)\n                  (recur (mark items multiple)\n                         (inc factor))\n                  items))))\n\n          (sieve\n            [n]\n            (loop [items (-> (upto n)\n                             (as-markable)\n                             (mark 0)\n                             (mark 1))\n                   p 2]\n              (let [marked (mark-multiples items p)\n                    marked-above-p (drop (inc p) marked)]\n                (if-let [next-p (:n (first (remove :marked? marked-above-p)))]\n                  (recur marked next-p)\n                  (map :n (remove :marked? marked))))))]\n\n    (let [primes (sieve 1000)]\n      (take n primes))))", "user": "4e0bb9fb535d04ed9115e7b2"}, {"problem": 67, "code": "(fn [n]\n  (let [next-prime (fn [current-primes]\n                     (loop [num (inc (last current-primes))]\n                       (if (not-any? #(= (rem num %) 0) current-primes)\n                         num\n                         (recur (inc num)))))\n        itor (fn [primes counter]\n               (if (= counter n)\n                 primes\n                 (recur (conj primes (next-prime primes)) (inc counter))))]\n    (itor [2] 1)))", "user": "51a7fe50e4b08d8ec191b803"}, {"problem": 67, "code": "(fn n-primes\n    [n]\n    (letfn [ (prm? [nmb pnar_]\n               (empty? (filter #(= 0 %) (map #(mod nmb %) pnar_ ))))\n             ]\n      (let [N 10000\n            pnar (atom [])]\n        (conj  (for [ i (range 3 N 2)\n                     :when (if (prm? i @pnar)\n                             (let [ res (prm? i @pnar)\n                                   ]\n                               (swap! pnar conj i)\n                                    true\n                               )\n                             false\n                             )\n                     :while (> n (count @pnar))\n                     ] i ) 2)\n        )\n      )\n    )", "user": "51f81925e4b09be9c177e526"}, {"problem": 67, "code": "#(letfn [(prime? [number]\n               (loop [prime true testing (range 2 (+ 1 (Math/floor (/ number 2))))]\n               (if (or (not prime) (empty? testing)) prime\n               (recur (not (= 0 (rem number (first testing)))) (rest testing)))))]\n          (take % (filter prime? (drop 2 (range)))))", "user": "54e4edcae4b024c67c0cf7f3"}, {"problem": 67, "code": "(letfn [(sieve [s]\n          (lazy-seq\n           (cons (first s)\n                 (sieve (remove #(zero? (mod % (first s)))\n                                (rest s))))))]\n  #(take % (sieve (iterate inc 2))))", "user": "550f1c99e4b06e50f9beb171"}, {"problem": 67, "code": "(fn primes [v i n]\n  (if (= (count v) n)\n    v\n    (primes (if (reduce #(or %1 (integer? (/ i %2))) false v) v (conj v i)) (+ 2 i) n))) [2] 3", "user": "551c66dae4b07993ea3788de"}, {"problem": 67, "code": "(fn [n]\n  (let\n    [p (fn genprime[start]\n           (let\n             [pm (some (fn [i]\n                         (when (empty? \n                          (filter #(= (mod i %1) 0) (range 2 (inc (int (Math/sqrt i)))))) i))\n                       (drop start (range)))]\n             (cons pm (lazy-seq (genprime (inc pm))))))]\n   (take n (p 2))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 67, "code": "#(case % 2 [2 3] 5 [2 3 5 7 11] (range 542))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 67, "code": ";;lol wikipedia\n(fn [n] \n   (let [p [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 \n            73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 \n            179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 \n            283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 \n            419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541]]\n     (take n p)))", "user": "51bd255ce4b0df1216cefd94"}, {"problem": 67, "code": "(fn [n]\n    (if (<= n 2)\n      (take n '(2 3))\n\n      (loop [result [2 3]\n             candidate 5]\n        (if (< (count result) n)\n\n          (if ((fn [primes c] (every? #(not= 0 (mod c %)) primes)) result candidate) ; prime?\n\n            (recur (conj result candidate) (+ candidate 2))\n            (recur result (+ candidate 2)))\n          \n          result))))", "user": "5535e822e4b09218d5f44fb2"}, {"problem": 67, "code": "(fn get-x-primes [x]\n  (let [is-prime?\n        (fn [x]\n          (cond\n           (= x 0) false\n           (contains? [1 2] x) true\n           :else\n           (loop [i 2]\n             (cond\n              (= i x) true\n              (= 0 (rem x i)) false\n              :else (recur (inc i))))))]\n    (take x (filter #(and (>= % 2 ) (is-prime? %)) (range)))))", "user": "5546704be4b0a04f7929953d"}, {"problem": 67, "code": "(fn [num-primes]\n  (letfn [(prime? [x]\n            (every? #(not= 0 (mod x %))\n                    (range 2 x)))]\n    (take num-primes\n          (drop 2 (filter prime? (range))))))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 67, "code": "#(take % [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997])", "user": "554b9c3ee4b0a04f79299594"}, {"problem": 67, "code": "(fn [i]\n\t(letfn [(prime? [n]\n\t\t(not-any?\n\t\t\t#(= 0 (rem n %))\n\t\t\t(range 2 (inc (int (Math/sqrt n))))))]\n\t(take i (filter prime? (iterate inc 2)))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 67, "code": "(fn [n]\n  (take n \n        (filter (fn p [x] (every? #(not (= (mod x %) 0)) (range 2 x)))\n                (iterate inc 2))))", "user": "554b7056e4b0a04f79299583"}, {"problem": 67, "code": "(fn first-x-primes\n   [count]\n   (loop [ccount 0 val 2 primes []]\n     (if (= ccount count)\n       primes\n       (if ((fn [x] (empty? (filter #(= 0 (mod x %)) (range 2 x)))) val)\n         (recur (inc ccount) (inc val) (conj primes val))\n         (recur ccount (inc val) primes)))))", "user": "54d5343fe4b0a52adc2e200a"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))))\n          ]\n   (loop [res [2], s (drop 2(range))]\n     (if (= n (count res))\n       res\n       (if (every? #(= % 1) (map gcd res (repeat (first s))))\n         (recur (conj res (first s)) (rest s))\n         (recur res (rest s))\n         )))))", "user": "5532a04ee4b09218d5f44f82"}, {"problem": 67, "code": "(fn [x] ((fn prime-helper [n xs coll]\n  (if (= n (count coll))\n    coll\n    (let [p (first xs)]\n      (prime-helper n (filter #(not= 0 (mod % p)) xs) (conj coll p))\n    ))) x (range 2 1000) []))", "user": "5510aa92e4b06e50f9beb188"}, {"problem": 67, "code": "(fn answer67 [n]  \n  (take n (filter \n           (fn prime? [n] (if (some zero? (map #(mod n %) (filter #(not= n %) (range 2 n)))) false true)) \n           (drop 2 (range)))))", "user": "50e1bdd8e4b019fc399ce17f"}, {"problem": 67, "code": "(letfn [(sieve [n nums]\n               (filter #(not (zero? (mod % n))) nums))\n        (new-primes [[primes nums]]\n                    [(cons (first nums) primes) (sieve (first nums) nums)])]\n  (fn [n]\n    (reverse (first (first (drop n (iterate new-primes [[] (drop 2 (range))])))))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 67, "code": "(fn [x]\n  (loop [i 0 acc [] n 2]\n    (if (= i x)\n      acc\n      (if (every? #(pos? (mod n %)) acc)\n        (recur (inc i) (conj acc n) (inc n))\n        (recur i acc (inc n))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-prime? (fn [n]\n                    (not-any? zero? (map (partial mod n) (range 2 (inc (Math/sqrt n))))))]\n    (cons 2 (take (dec n) (filter is-prime? (iterate inc 2))))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(add-prime \n              ([prime witnessed] (add-prime prime (* 3 prime) witnessed)) \n              ([prime n witnessed]\n                 (if (contains? witnessed n)\n                   (recur prime (+ n (* 2 prime)) witnessed)\n                   (assoc witnessed n prime))))\n            (reshuffle-witnessed [n witnessed]\n              (let [prime (witnessed n)]\n                (add-prime prime (+ n (* 2 prime)) (dissoc witnessed n))))\n            (primes-acc [n witnessed]\n              (if (not (contains? witnessed n))\n                (cons n (lazy-seq (primes-acc (+ n 2) (add-prime n witnessed))))\n                (recur (+ n 2) (reshuffle-witnessed n witnessed))))\n            (primes [] (cons 2 (primes-acc 3 {})))]\n      (take n (primes))))", "user": "543d89dfe4b032a45b869350"}, {"problem": 67, "code": "(fn generate-primes [n]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (gcd b (mod a b))))\n          (sieve [s]\n            (lazy-seq\n             (cons (first s)\n                   (sieve (filter #(= 1 (gcd % (first s))) (rest s))))))]\n    (let [primes (sieve (map (comp inc inc) (range)))]\n      (take n primes))))", "user": "547884d7e4b0c51c1f4d72bd"}, {"problem": 67, "code": "(fn first-primes [n]\n  (loop [primes [2]\n         current 3]\n    (if (= (count primes) n)\n      primes\n      (if (reduce (fn [reduction prime]\n                    (or (zero? (mod current prime)) reduction))\n                  false\n                  primes)\n        (recur primes (inc current))\n        (recur (conj primes current) (inc current))))))", "user": "5486e317e4b0e286459a11c0"}, {"problem": 67, "code": "(fn [n]\n\t  (take n (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 x)))\n\t          (iterate inc 2))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 67, "code": "(fn[x]\n  (take x\n        (drop 2 \n              (filter \n               (fn[y]\n                 (if (some #(= (mod y %) 0) (range 2 y)) \n                   false \n                   true))(range)))))", "user": "55429859e4b0a04f7929951f"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "5540f5dee4b0a04f79299509"}, {"problem": 67, "code": "(letfn [(prime? [n]\n                (not-any? #(= 0 (mod n %)) (range 2 (Math/sqrt (inc n)))))]\n      \n  #(take % (filter prime? (drop 2 (range)))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 67, "code": "(fn primes \n  ([m] (primes m 2 0))\n  ([m x c] (if (= c m)\n    []\n      (if (reduce #(and %1 (> (mod x %2) 0)) true (range 2 x))\n        (cons x (primes m (inc x) (inc c)))\n        (primes m (inc x) c)))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 2\n         ps []]\n    (if (= (count ps) n)\n      ps\n      (if (some #(= (mod i %) 0) ps)\n        (recur (inc i) ps)\n        (recur (inc i) (conj ps i))))))", "user": "53161a56e4b08068f379ed3e"}, {"problem": 67, "code": "(fn [num-primes]\n  (let [prime?\n        (fn [n] (let [m (->> n Math/sqrt long) multiple? (fn [x] (zero? (mod n x)))] (if (< n 2) false (->> (range 2 (inc m)) (not-any? multiple?)))))]\n    (take num-primes (filter prime? (range)))))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 67, "code": "(fn [x]\n  (take x\n        (filter #(every? (fn [e] ((comp not zero?) (rem % e))) (range 2 (dec %)))\n                (lazy-seq\n                 (iterate inc 2)\n                 ))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 67, "code": "(fn [n]\n  (take n \n    (filter (fn [x]\n      (empty? (filter #(zero? (mod x %)) (range 2 x))))\n    (iterate inc 2))))", "user": "555a5731e4b0deb715856e44"}, {"problem": 67, "code": "(fn [n]\r\n  (take n\r\n    ((fn primes [x]\r\n      (if ((fn prime? [x]\r\n          (if (< x 2) false\r\n          (if (= x 2) true\r\n          (if (even? x) false\r\n          (loop [i 3 max_i (/ x 2)]\r\n            (if (>= i max_i) true\r\n            (if (and (prime? i) (= 0 (mod x i))) false\r\n            (recur (+ i 2) max_i)))))))) x)\r\n        (cons x (lazy-seq (primes (inc x))))\r\n        (lazy-seq (primes (inc x))))) 2)))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 67, "code": "(fn [n]\n  (loop [num 3, div 2, primes [2]]\n    (cond\n     (= (count primes) n) primes\n     (even? num) (recur (inc num) 2 primes)\n     (> div (Math/sqrt num)) (recur (inc num) 2 (conj primes num))\n     :else (if (zero? (mod num div))\n             (recur (inc num) 2 primes)\n             (recur num (inc div) primes)))))", "user": "54ab1b5ae4b09f271ff37cc2"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x] (every? #(not= (rem x %) 0) (range 2 x)))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "5540cc0ce4b0a04f79299505"}, {"problem": 67, "code": "(fn primes ([n] (primes 3 [2] (dec n))) ([i out n] \n  (cond\n   (= n 0) out\n   (not-any? #(= 0 (mod i %)) out) (primes (+ i 2) (conj out i) (dec n))\n   :else (primes (+ i 2) out n)\n)))", "user": "5280a1ece4b0757a1b171407"}, {"problem": 67, "code": "(fn [n]\n  (let [init-max  (* 1.2 n (Math/log n))\n        init-max  (Math/round init-max)\n        init-max  (max 4 init-max)\n        init-coll (range 2 init-max)]\n    (letfn [(sieve [coll init-primes]\n                    (let [init-coll   (filterv (fn [x]\n                                                 (not-any? zero?\n                                                           (map #(mod x %)\n                                                                init-primes)))\n                                               coll)]\n                      (loop [primes       init-primes\n                             future-coll  init-coll]\n                        (let [head        (first future-coll)\n                              tail        (rest future-coll)\n                              new-primes  (conj primes head)]\n                          (if (empty? tail)\n                            (vec new-primes)\n                            (recur new-primes\n                                   (filterv #(not= 0 \n                                                   (mod % head))\n                                            tail)))))))]\n      (loop [future-coll  init-coll\n             in-primes    []]\n        (let [result   (take n \n                             (sieve future-coll \n                                          (vec in-primes)))\n              next-min        (inc (last future-coll))]\n          (if (= n (count result))\n            (vec result)\n            (recur (range next-min \n                          (+ next-min init-max))\n                   result)))))))", "user": "5564cad5e4b0c656e3ff180f"}, {"problem": 67, "code": "(fn [n]\n  (let [fn-prime? (fn [x] (or (= 2 x)\n                          (not-any? #(= 0 (rem x %)) (range 2 (inc (Math/sqrt x))))))]\n    (take n (filter #(fn-prime? %) (iterate inc 2)))))", "user": "52c5c1c8e4b0c2d177d620fc"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter\n         (fn [x]\n           (every? #(pos? (mod x %)) (range 2 (inc (int (Math/sqrt x))))))\n         (iterate inc 2))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 67, "code": "(fn [n]\n  (concat [2]\n          (take (- n 1)\n                    (filter (fn [k] \n                              (reduce (fn [a b] (and a b))\n                                      (map (fn [c] (not= (mod k c) 0))\n                                           (map (partial + 2) (range (- k 2))))))\n                            (iterate (partial + 2) 3)))))", "user": "5568749ae4b0c656e3ff1854"}, {"problem": 67, "code": "(fn [n]\n     (take n\n         (filter (fn [p]\n             (every? #(not= (mod p %) 0)\n                 (range 2 p)))\n                      (iterate inc 2))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 67, "code": "(fn prime\n  ([n] (prime n 2 []))\n  ([n start res]\n    (if (= (count res) n)\n      res\n      (recur n (inc start) (if (some #(zero? (rem start %)) res)\n                             res\n                             (conj res start))))))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 67, "code": "(fn [t] \n  (into []\n   (take t \n         (filter \n          (fn[num]\n            (loop [n num d 2] \n              (if (> d (/ n 2)) \n                true \n                (if (zero? (mod n d)) \n                  false \n                  (recur n (inc d))))))\n          (iterate inc 2)))))", "user": "4f148418535d64f60314643a"}, {"problem": 67, "code": "(fn [n]\n    (->> (range)\n         (filter #(.isProbablePrime (BigInteger/valueOf %) 5))\n         (take n)))", "user": "5501a1e1e4b07d26eda61d75"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter (fn p [x]\n                  (empty? (filter #(zero? (mod x %)) (range 2 x))))\n                (range 2 100000000))))", "user": "52b89d55e4b07a9af57922b3"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "556a6137e4b09a3098a524e0"}, {"problem": 67, "code": "(fn [n] \n  (letfn [(primes [[x & xs]] (cons x (lazy-seq (primes (filter #(not= 0 (mod % x)) xs)))))]\n    (take n (primes (iterate inc 2)))))", "user": "555ac933e4b0deb715856e49"}, {"problem": 67, "code": "(fn [n]\n  (let [cs (iterate inc 2)]\n    (loop [i 1 cs cs r [2]]\n      (if (= i n)\n        r\n        (let [ds (remove #(= 0 (mod % (last r))) cs)]\n          (recur (inc i)\n                 ds\n                 (conj r (first ds))))))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 67, "code": "(fn prime [n]\n  (take n \n        ((fn sieve [s]\n           (cons (first s)\n                 (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                          (rest s))))))\n         (iterate inc 2))))", "user": "555287a4e4b0deb715856df5"}, {"problem": 67, "code": "(fn first-primes[x]\n  (let [is-prime (fn [v]\n                    ((fn inner[v current sqrt-v]\n                        (if (> current sqrt-v)\n                          true\n                          (if (integer? (/ v current))\n                            false\n                            (recur v (inc current) sqrt-v)))) v 2 (Math/sqrt v)))]\n    (take x (filter is-prime (drop 2 (range))))))", "user": "556405e5e4b0c656e3ff17fb"}, {"problem": 67, "code": "(fn [n] \n  (letfn [(sieve [s] \n                 (let [[h & t] s] \n                   (lazy-seq (cons h (sieve (remove #(zero? (mod % h)) t))))))]\n    (->> (range)\n         (drop 2)\n         (sieve)\n         (take n))))", "user": "52e851bfe4b09f7907dd149a"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq\n                        (sieve (filter #(not= 0 (mod % (first s)))\n                                       (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 67, "code": "#(loop[result [], ind 0, remaining (drop 2 (range))];(drop 2 (range)) represents 2, 3, .... to infinite\n   (let[primeNum (first remaining)];take out the new prime number\n     (if (= ind %) result\n       (recur (conj result primeNum) (inc ind) (remove (fn[x] (= 0 (rem x primeNum))) remaining)))));take out of the multiples", "user": "556c70dae4b09a3098a524fd"}, {"problem": 67, "code": "(fn [x]\n  (nth (iterate (fn [coll] (loop [n (inc (peek coll))]\n                             (if (some #(zero? (rem n %)) coll)\n                               (recur (inc n))\n                               (conj coll n)))) [2])\n       (dec x)))", "user": "554b8572e4b0a04f79299589"}, {"problem": 67, "code": "(fn primeNumbers\n  ([index] (take index (filter (fn prime [number] (if (= [1 number] (filter #(= (rem number %) 0) (range 1 (+ number 1)))) true false))\n (range)))))", "user": "556c94afe4b09a3098a524fe"}, {"problem": 67, "code": "(fn [n] (take n (for [x (drop 2 (range)) \n      :when (not (some #(zero? (mod x %)) (range 2 x)))] \n  x)))", "user": "54f8b6f4e4b01ecee9d8882c"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn prime-seq [x]\n             (if (not-any? #(zero? (mod x %)) (range 2 x))\n               (cons x (lazy-seq (prime-seq (+ x 1))))\n               (lazy-seq (prime-seq (+ x 1))))) 2)))", "user": "4f9b3532e4b0dcca54ed6d13"}, {"problem": 67, "code": "(fn gp [n] (take n (filter (fn isp[i] (cond  (< i 2) false  (= i 2) true :else (every? true? (for [x (range 2 (-> i Math/sqrt Math/floor (+ 2)))]             \n                                                                                                 (if (= (rem i x)0)false true  ))   ))) (range))))", "user": "552800d7e4b0ffed3738f93a"}, {"problem": 67, "code": "(fn [q] (take q (filter (fn [n] (every? #(pos? (rem n %)) (range 2 n))) (iterate inc 2))))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 67, "code": "(fn primes [n]\n\t(let [prm \n\t\t(fn [x xs]\n\t\t\t(loop [y (first xs) ys (rest xs)]\n\t\t\t\t(if (nil? y) true\n\t\t\t\t\t(if (= (mod x y) 0)\n\t\t\t\t\t\tfalse\n\t\t\t\t\t\t(recur (first ys) (rest ys))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t] \n\t\t(loop [prs [] cur 2]\n\t\t\t(if (= n (count prs))\n\t\t\t\tprs\n\t\t\t\t(if (prm cur prs)\n\t\t\t\t\t(recur (conj prs cur) (inc cur))\n\t\t\t\t\t(recur prs (inc cur))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)", "user": "5545477fe4b0a04f79299531"}, {"problem": 67, "code": "(fn primes [n]\n    (let [factor (fn factor [n]\n    (loop [factors [1]\n           curr 2]\n      (cond\n        (> curr n) factors\n        (= 0 (mod n curr)) (recur (conj factors curr) (inc curr))\n        :else (recur factors (inc curr)))))]\n    (loop [curr 2\n           primes []]\n      (cond\n        (= (count primes) n) primes\n        (= (count (factor curr)) 2) (recur (inc curr)(conj primes curr))\n        :else (recur (inc curr) primes)))))", "user": "551d5cb9e4b07993ea3788e9"}, {"problem": 67, "code": "(fn prime-numbers [numPrimes]\n  (let [candidateNumbers (iterate inc 2)\n        dividesEvenly? (fn [dividend divisor] (= 0 (mod dividend divisor))) \n        isPrime? (fn [num] (empty? (filter (partial dividesEvenly? num) (range 2 num))))]\n    (take numPrimes (filter isPrime? candidateNumbers))\n    ))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 67, "code": "#(letfn [(sieve [[x & xs]] \n                (cons x (lazy-seq (sieve (filter (fn [n] (not= 0 (rem n x))) xs)))))]\n   (take % (sieve (rest (rest (range))))))", "user": "555b35f7e4b0deb715856e4b"}, {"problem": 67, "code": "(fn [n] \n  (take \n   n \n   (filter \n    (fn [i] \n      (not-any? \n       #(zero? (mod i %)) (range 2 i))) \n    (map #(+ 2 %) (range)))))", "user": "5499e23de4b03163384f4706"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n            (every? #(pos? (mod x %))\n                    (range 2 (inc (/ x 2)))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "55702081e4b09a3098a52529"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and (not= n %)\n                                  (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "54c3747de4b045293a27f60e"}, {"problem": 67, "code": "(fn primes [n]\n         (letfn [(gcd [a b] (cond\n                              (= a b) a\n                              (> a b) (gcd (- a b) b)\n                              (< a b) (gcd a (- b a))))\n                 (find-factor [n]\n                   (loop [a 2]\n                     (cond\n                       (> (* a a) n) n\n                       (not= 1 (gcd a n)) (gcd a n)\n                       :else (recur (inc a)))))\n                 (prime? [n] (= n (find-factor n)))]\n           (drop 2  (take (+ n 2) (filter prime? (range))))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 67, "code": "(fn [n]\n  (let \n    [aux \n     (fn [x coll]\n       (some #(= 0 (mod x %)) coll))]\n    ((fn aux1 [x coll]\n       (if (= (count coll) n)\n         coll\n         (if (aux x coll)\n           (aux1 (inc x) coll)\n           (aux1 (inc x) (conj coll x))))) 2 [])))", "user": "5550bcece4b00713264bd9ae"}, {"problem": 67, "code": "(fn prime [n]\n  (letfn [(smallest-divisor [n]\n            (loop [i 3]\n              ;need only test odd divisors between 3 and (sqrt n)\n              (when (<= (* i i) n) \n                (if (zero? (mod n i))\n                  i\n                  (recur (+ i 2))))))\n          (next-prime [prev-prime]\n            (loop [prime (+ 2 prev-prime)]\n              (if (smallest-divisor prime)\n                (recur (+ prime 2))\n                prime)))\n          (prime-seq []\n            (cons 2 (iterate next-prime 3)))]\n    (take n (prime-seq))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 67, "code": "(fn [count]\n    (let [primeseq \n          (fn []\n            (let [lazyprimes \n                  (fn lazyprimes [next primes]\n                    (loop [num next]\n                      (if (not-any? #(= 0 (mod num %)) primes)\n                        (cons num\n                              (lazy-seq (lazyprimes (inc num) (conj primes num))))\n                        (recur (inc num)))))]\n              (lazy-seq (lazyprimes 2 []))))] \n      (take count (primeseq))))", "user": "554a75c9e4b0a04f79299575"}, {"problem": 67, "code": "(fn primes [n] (letfn [(prime? [x] (nil? (some #(= 0 (mod x %)) (range 3 (/ x 2) 2))))] \n                 (cons 2 (take (dec n) (iterate #(loop [x (+ 2 %)] (if (prime? x) x (recur (+ 2 x)))) 3)))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 67, "code": ";#(take % (filter number? (for [x (iterate inc 2)]\n ;       ;; is prime\n  ;      (if (not (some true? (for [y (range 2 x)]\n   ;         (if (= 0 (mod x y))\n    ;            true\n     ;           )\n      ;          )\n       ;     ))\n        ;    x\n         ; ))))\n         \n         (fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "549b1e50e4b0f3d1d8e70f7a"}, {"problem": 67, "code": "(letfn \n  [(prime? [n]\n     (let [pred (fn [x] (= 0 (rem n x)))]\n       (not (some pred (range 2 n)))))\n   \n   (next-prime [n]\n     (if (prime? (inc n)) (inc n)\n       (next-prime (inc n))))\n   \n   (prime-seq []\n     (iterate next-prime 2))]\n  \n  (fn [n] (take n (prime-seq))))", "user": "53065acbe4b02e8216869792"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n                  (->> (range 2 (int (inc (Math/sqrt x))))\n                       (some #(= 0 (mod x %)))\n                       (not)))]\n    (->> (range)\n         (drop 2)\n         (filter prime?)\n         (take n))))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 67, "code": "(fn [number-of-primes]\n    (loop [number-to-test 2 elts []]\n      (if (= (count elts) number-of-primes )\n        elts\n        (recur (inc number-to-test)   \n               (if  (= true (\n                            (fn[n]\n                            (if (> (count (filter (fn[y] (=  (/ n y ) (int(/ n y))  )   ) (map (fn[x] x) (range 2 n )) )) 0  ) false true  )    \n                            ) number-to-test) ) (conj elts number-to-test) elts  )       \n        )\n      )\n    )  \n  )", "user": "55757e81e4b05c286339e063"}, {"problem": 67, "code": "(fn sol [n] (letfn [(primes [all] (lazy-cat [(first all)] (primes (filter #(not= (mod % (first all)) 0) all))))]\n                (take n (primes (iterate inc 2)))))", "user": "54857657e4b0e286459a11ac"}, {"problem": 67, "code": "(fn prime-numbers\n  [n]\n  (letfn [(sieve [lst]\n          (cons (first lst)\n                (lazy-seq (sieve (filter\n                          (comp not zero? #(mod % (first lst)))\n                          (rest lst))))))]\n    (take n (sieve (drop 2 (range))))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 67, "code": "(fn [rang] \n  (take rang ( drop 2\n    (remove nil?\n        (for [entier (range) ]\n          \n          ((fn calcul [p liste]\n             (loop [x p rliste liste prime true]\n               (if (empty? rliste)\n                 (if (and true prime)\n                   p\n                   nil\n                  )\n                  (if (zero? (mod p (first rliste)))\n                    (recur p () false)\n                    (recur p (rest rliste) prime)\n                  )\n                )\n             \n             )\n          ) entier (range 2 entier))\n\n        )\n     )\n  ))\n)", "user": "556f2009e4b09a3098a52519"}, {"problem": 67, "code": "(fn xprimes [n]\n  (take n (filter (fn [a] (not-any? zero? (map #(rem a %) (range 2 a))))\n                  (iterate inc 2))))", "user": "5573ffb5e4b0aa18f790f3fd"}, {"problem": 67, "code": "(fn [n]\n  (let [prime?\n        (fn [a]\n          (not (or\n                (< a 2)\n                (some #(zero? (mod a %)) (range 2 (inc (int (Math/sqrt a))))))))]\n    (take n (filter prime? (range)))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 67, "code": "(fn [n] \n  (letfn [(prime? [x] \n                  (->> \n                    (range 1 x)\n                    (filter #(= 0 (mod x %)))\n                    set\n                    (= #{1})))]\n    (->> \n     (range)\n     (filter prime?)\n     (take n))))", "user": "5581747fe4b05c286339e0fa"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime? [candidate all-found]\n            (not-any? #(zero? (mod candidate %)) all-found))]\n    (loop [acc []\n           i 2]\n      (if (= n (count acc))\n        acc\n        (recur (if (is-prime? i acc) (conj acc i) acc) (inc i))))))", "user": "51ae350fe4b09397d5109790"}, {"problem": 67, "code": "(fn [n]\n\t(loop [r [] current 2]\n\t\t(if (= (count r) n)\n\t\t\tr\n\t\t\t(if (#(loop [x 2]\n\t\t\t\t\t(if (> x (/ % 2))\n\t\t\t\t\t\ttrue\n\t\t\t\t\t\t(if (= (mod % x) 0)\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t(recur (inc x))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) current)\n\t\t\t\t(recur (conj r current) (inc current))\n\t\t\t\t(recur r (inc current))\n\t\t\t)\n\t\t)\n\t)\n )", "user": "5559b443e4b0deb715856e3c"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes* [n previous-primes]\n            (let [next-prime (->> (iterate inc n)\n                                  (drop-while #(some (fn [x] (zero? (mod % x))) previous-primes))\n                                  first)]\n              (cons next-prime\n                    (lazy-seq (primes* (inc next-prime) (conj previous-primes next-prime))))))]\n    (take n (primes* 2 []))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 0) []\n    (loop [n (dec n) out [2]]\n      (if (= n 0) out\n        (recur (dec n)\n               (conj out \n                     (loop [m (last out)]\n                       (if (some #(= 0 (mod m %)) out)\n                         (recur (inc m))\n                         m))))))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 67, "code": "(fn sieve [n]\n  (loop [d [] s (range 2 10) mx 10 check 2]\n    (if (= (count d) n) d\n      (if (empty? s) (recur [] (range 2 (* mx 10)) (* mx 10) 2)\n        (recur (conj d check) (filter #(not= (mod % check) 0) s) mx (first (filter #(not= (mod % check) 0) s)))))))", "user": "558378dce4b05c286339e115"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x ps]\n            (let [sqx (inc (Math/sqrt x))]\n              (every? #(not (zero? (rem x %))) (take-while #(> sqx %) ps))))]\n    (loop [ps [2 3] count 2 cur-x 5]\n      (cond\n       (= count n) ps\n       (prime? cur-x ps) (recur (conj ps cur-x) (inc count) (+ cur-x 2))\n       :else (recur ps count (+ cur-x 2))))))", "user": "5576f299e4b05c286339e077"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter #(= (loop [i 2]\n                        (cond (> (* i i) %) %\n                              (= (mod % i) 0) i\n                              :else (recur (+ i 1)))) %)\n                  (iterate inc 2))))", "user": "4ec6297b535d6d7199dd36c4"}, {"problem": 67, "code": "(fn first-n-prime [x]\n   (take x (filter (fn [n] (= 2 (count (filter #(zero? (rem n %)) (range 1 (inc n)))))) (range 1 10000000))))", "user": "52ba2639e4b07a9af57922cb"}, {"problem": 67, "code": "(fn *prime [n]\n  (loop [acc []\n         curr 2]\n    (cond\n      (= (count acc) n)\n      acc\n      (not-any? zero? (map #(mod curr %) acc))\n      (recur (conj acc curr) (inc curr))\n      :else\n      (recur acc (inc curr)))))", "user": "555f3bfde4b0a2eb076a39c1"}, {"problem": 67, "code": "(fn primes [n] ( let [isPrime (fn [x] (= 1 (count (filter #(zero? (mod x %))  (range 1  x)))))]\n(take n (filter isPrime (range)))))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 67, "code": "#(take % [\n      2      3      5      7     11     13     17     19     23     29 \n     31     37     41     43     47     53     59     61     67     71 \n     73     79     83     89     97    101    103    107    109    113 \n    127    131    137    139    149    151    157    163    167    173 \n    179    181    191    193    197    199    211    223    227    229 \n    233    239    241    251    257    263    269    271    277    281 \n    283    293    307    311    313    317    331    337    347    349 \n    353    359    367    373    379    383    389    397    401    409 \n    419    421    431    433    439    443    449    457    461    463 \n    467    479    487    491    499    503    509    521    523    541 ])", "user": "5589a735e4b059ccff29b206"}, {"problem": 67, "code": "(letfn [                                                                                                                                                \n    (is-prime? [x] (not-any? (partial = 0) (map #(mod x %) (range 2 (inc (/ x 2))))))                                           \n    (prime-seq [] (filter is-prime? (map (partial + 2) (range))))]                                                                                      \n        #(take % (prime-seq)))", "user": "558b50d5e4b027778923762b"}, {"problem": 67, "code": "(fn [n]\n   (let [prime? (fn [n] (empty? (filter #(= 0 (mod n %)) (range 2 (dec n)))))]\n     (take n (filter prime? (iterate inc 2)))\n     ))", "user": "55895eade4b059ccff29b202"}, {"problem": 67, "code": "(fn prime-nos\n  [n]\n  (letfn [(prime? [n]\n            (not-any? zero?\n                      (map #(rem n %) (range 2 (inc (quot n 2))))))]\n    (take n\n          (for [x (drop 2 (range))\n                :when (prime? x)]\n            x))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(next-prime [l]\n                      (loop [n (inc (last l))]\n                        (if (and (odd? n) (empty? (filter #(zero? %) (map #(mod n %) l))))\n                          n\n                          (recur (inc n)))))]\n    (loop [c (dec n) l '[2]]\n      (if (zero? c)\n        l\n        (recur (dec c) (conj l (next-prime l)))))))", "user": "52979551e4b02ebb4ef75043"}, {"problem": 67, "code": "(fn [n]\n          (loop [x 2 primes []]\n            (if (= n (count primes))\n              primes\n              (recur (inc x)\n                     (if (not-any? #(= 0 (mod x %)) primes)\n                       (conj primes x)\n                       primes)))))", "user": "531c6e72e4b08068f379eda0"}, {"problem": 67, "code": "#(let \n  \t\t[\n         prime? (fn [n] (.isProbablePrime (BigInteger/valueOf n) 10))\n         numberz ( range )\n        ]\n  (take % (filter prime? numberz))\n  )", "user": "532018efe4b08068f379edcd"}, {"problem": 67, "code": "(fn [i]\n\t(loop [i i n 3 ps [2]]\n\t\t(if (= i 1)\n\t\t\tps\n\t\t\t(let [upper (inc (int (Math/sqrt n)))\n\t\t  \t\t  ps2 (filter #(< % upper) ps)\n\t\t  \t\t  fm (partial mod n)\n\t\t  \t\t  np (some zero? (map fm ps2))]\n\t\t        (recur\n\t\t           (if np i (dec i))\n\t\t           (+ n 2)\n\t\t           (if np\n\t\t           \t  ps\n\t\t           \t  (conj ps n)))))))", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [x]\n                    (not (some #(= 0 %)\n                               (map #(mod x %) (#(range 2 (inc (/ % 2))) x)))))\n                  (range 2 600))))", "user": "55630cc1e4b0c656e3ff17e0"}, {"problem": 67, "code": "(fn primes [n]\n  (let [isprime? (complement (fn [x]\n                               (or (even? x)\n                  \t(some #(= 0 (mod x %)) (range 2 (/ x 2))))))]\n  (take n (cons 2 (filter #(isprime? %) (iterate inc 2))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 67, "code": "(fn list-prime \n  [i]\n  (take i (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range 1 Integer/MAX_VALUE)))\n)", "user": "5581a6dae4b05c286339e0fe"}, {"problem": 67, "code": "(fn [n]\n  (reverse\n    (let [divides (fn [n m] (zero? (rem n m)))]\n      (loop [c 2\n             p ()]\n        (if (>= (count p) n)\n          p\n          (let [np (if (not-any? (partial divides c) p)\n                     (cons c p)\n                     p)]\n            (recur (inc c) np)))))))", "user": "5596a324e4b04c1e5c31d757"}, {"problem": 67, "code": "(fn [n] (take n (filter #(.isProbablePrime (BigInteger/valueOf %1) 5) (range))))", "user": "5590e55de4b0277789237676"}, {"problem": 67, "code": "#(take % (filter \n           (fn isprime \n  ([n] \n   (isprime n 2))\n  ([n i] \n   (if (= n i) \n     true\n     (if (= 0 (rem n i))\n     \tfalse\n     \t(isprime n (inc i))))))\n            (range 2 10000)))", "user": "5587d8b3e4b059ccff29b1e8"}, {"problem": 67, "code": "(fn me1\n  \t[n]\n  \t\n  \t(let [checkPrime (fn [number] \n\n  \t\t\t\t\t\t(reduce #(and %1 (not= 0 (rem number %2)))  true (range 2 number)))\n\n  \t\t  res (filter checkPrime (range 3 1000)) \n\n  \t\t]\n\n  \t\t;(println res)\n\n  \t\t(take n (concat [2] res ) )\n                     \n       \t)             \n                 \n       \n    )", "user": "55897fe2e4b059ccff29b205"}, {"problem": 67, "code": "(fn findprimes\n  ([numprimes] (findprimes numprimes 3 [2]))\n  ([numprimes number primes]\n    (cond\n      (< number 2) '()\n      (< (count primes) numprimes)\n        (if (every? #(not= (mod number %) 0) primes)\n          (findprimes numprimes (+ number 1) (conj primes number))\n          (findprimes numprimes (+ number 1) primes))\n     :else primes)))", "user": "54b912b3e4b0ed20f4ff6ea1"}, {"problem": 67, "code": "(fn [g] (take g\n              (filter (fn [n]\n                        (every? #(> % 0)\n                                (map #(mod n %)\n                                     (range 2 (- n 1)))))\n                      (drop 2 (range)))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [], cnum 2, div 2]\n    (cond \n     (= (count primes) n) primes\n     (> div (Math/sqrt cnum)) (recur (conj primes cnum) (inc cnum) 2)\n     (or (even? cnum) (zero? (mod cnum div))) (recur primes (inc cnum) 2)\n     :else (recur primes cnum (inc div)))))", "user": "558d7dd3e4b0277789237647"}, {"problem": 67, "code": "(fn [n]\n   ((fn go [c res i]\n      (if (not= 0 c)\n        (if ((fn prime? [number primes]\n               (if (not (empty? primes))\n                 (if (not= 0 (mod number (first primes)))\n                   (prime? number (rest primes))\n                   false)\n                 true))\n             i\n             res)\n          (go (dec c) (conj res i) (inc i))\n          (go c res (inc i)))\n        res))\n    n\n    []\n    2))", "user": "55860905e4b001b0851d7516"}, {"problem": 67, "code": "(fn [n] (take n (cons 2 (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 (inc (Math/sqrt x)))))\n                                (iterate #(+ 2 %) 3)))))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 67, "code": "(fn [i]\n  (let [is (iterate inc 1)\n        ps (filter (fn [j]\n                     (->> (take (quot j 2) is)\n                          (map (fn [k]\n                                 (not= (rem j k) 0)))\n                          (rest)\n                          (every? true?))) \n                   (rest is))]\n    (vec (take i ps))))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [p-list []\n         n-it n\n         p-it 2]\n    (if (= n-it 0)\n      p-list\n      (if (not-any? #(= (rem p-it %) 0)\n                    p-list)\n        (recur (conj p-list p-it)\n               (dec n-it)\n               (inc p-it))\n        (recur p-list\n               n-it\n               (inc p-it))))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 67, "code": "(fn prime [n]\n  (take n \n    (filter (fn p [x]\n      (empty? (filter #(zero? (mod x %)) (range 2 x))))\n    (range 2 Double/POSITIVE_INFINITY))))", "user": "55342ee0e4b09218d5f44f98"}, {"problem": 67, "code": "(fn primes [x] \n  (let [prime? \n(fn [p]\n(let [ps (fn [p] (filter #(or (= % 2) (and (>= % 3) (odd? %))) (range p)))]\n(cond \n (< p 2) false\n (= p 2) true\n (even? p) false    \n :else (loop [[x & r] (ps p)] (cond (nil? r) true (zero? (rem p x)) false :else (recur r)))\n)))]\n  (take x (filter prime? (range)))))", "user": "55632016e4b0c656e3ff17e4"}, {"problem": 67, "code": "(fn [n]\n  (take n \n        (filter (fn [n]\n                  (and (> n 1)\n                       (empty? (filter #(zero? (mod n %)) \n                                       (range 2 n))))) \n                (range))))", "user": "548c6673e4b0e286459a1209"}, {"problem": 67, "code": "(fn prime [n]\n    (loop [pp 2 ps #{}]\n      (if (= (count ps) n)\n        (into []  (sort ps))\n        (if (= 0 (count (filter #(= 0 (mod pp %)) ps))) \n          (recur (inc pp)  (conj ps pp)) \n          (recur (inc pp) ps)\n          )))\n      )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 67, "code": "(fn [n]\n  (first\n   (reduce\n    (fn [[ps [n & ns]] _]\n      [(conj ps n) (remove #(= (mod % n) 0) ns)])\n    [[] (iterate inc 2)]\n    (repeat n 1))))", "user": "559b2ad1e4b066d22e731f4e"}, {"problem": 67, "code": "(fn prime_list [n]\n  (letfn [(is_prime? [x]\n\t(loop [div (dec x)]\n\t\t(cond\n\t\t\t(= 2 x) true\n\t\t\t(= 0 (mod x div)) false\n\t\t\t(= 2 div) true\n\t\t \t:else (recur (dec div)))))]\n\t(take n (filter is_prime? (iterate inc 2)))))", "user": "559bdf16e4b066d22e731f5a"}, {"problem": 67, "code": "(fn first-primes[n]\n  (take n\n    (filter \n      (fn [x]\n        (every? #(not= (mod x %) 0) (range 2 x))\n      )\n      (range 2 java.lang.Integer/MAX_VALUE)\n    )\n  )\n)", "user": "559b55d6e4b066d22e731f54"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes\n           ([]\n            (cons 2 (primes (iterate (partial + 2) 3))))\n           ([candidates]\n            (let [p  (first candidates)\n                  new-cands  (rest candidates)]\n              (lazy-seq (cons p (primes (remove #(zero? (mod % p)) new-cands)))))))]\n    (take n (primes))))", "user": "4f80db02e4b033992c121bf9"}, {"problem": 67, "code": "(fn [x] (take x (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (take-nth 1 (range 1 Integer/MAX_VALUE)))))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 67, "code": "(fn [n]\n               (take n ((fn sieve [s]\n                         (cons (first s)\n                               (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                        (rest s))))))\n                         (iterate inc 2))))", "user": "4e5af45e535d8a8b8723a2b1"}, {"problem": 67, "code": "(fn p67x ([n] (p67x n [2 3] 4))\n          ([n primes test]\n           (if (= (count primes) n)\n             primes\n             (if (empty? (filter integer? (map #(/ test %) (range 2 test))))\n               (p67x n (conj primes test) (inc test))\n               (p67x n primes (inc test))\n               )))\n  )", "user": "5400e918e4b0de5c41848619"}, {"problem": 67, "code": "(fn getprimes[n]\n  (take n \n        (filter\n         (fn[i](every? pos? (map #(mod i %) (range 2 i))))\n         (drop 2 (range)))))", "user": "5596af34e4b04c1e5c31d758"}, {"problem": 67, "code": "(fn [n] \n  (let [prime? (fn [n] (.isProbablePrime (BigInteger/valueOf n) 5))]\n    (loop [i 2 acc []]\n      (cond\n       (= (count acc) n) acc\n       (prime? i) (recur (inc i) (conj acc i))\n       :else (recur (inc i) acc)))))", "user": "523b4e91e4b07becd5be21ef"}, {"problem": 67, "code": "(fn [n] (take n (drop 2 (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x))) (range)))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 67, "code": "(fn [n] (loop [cnt n ps [2]]\n         (if (= cnt 1)\n           ps\n           (recur (dec cnt) (conj ps (first (filter #(every? (fn[c] (not (zero? (mod % c)))) ps) (iterate inc (inc (last ps))))))\n           ))))", "user": "559a8816e4b066d22e731f41"}, {"problem": 67, "code": "(fn [n]\n  (loop [res [2]\n         cur 3]\n    (if (= n (count res))\n      res\n      (if-not (reduce #(or %1 %2) (map #(= 0 (mod cur %)) res))\n        (recur (conj res cur) (inc cur))\n        (recur res (inc cur))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 67, "code": "(fn [n] (take n \n   (filter (fn [m](loop [i 2] \n                  (cond\n                   (== m i) true\n                   (= 0 (rem m i)) false\n                   :else (recur (inc i))\n      ))) (iterate inc 2)\n)))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 67, "code": "; Eratosthenes Sieve\n(fn [n]\n  (loop [i 2, preds [], result []]\n    (cond (= n (count result)) result\n          (every? #(% i) preds) (recur\n                                 (inc i)\n                                 (conj preds #(not= 0 (rem % i)))\n                                 (conj result i))\n          :else (recur (inc i) preds result))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 67, "code": "(fn primes [x]\n  (if (= x 1)\n    [2]\n    (let [pp (primes (- x 1))]\n      (conj pp\n        (first (filter\n          (fn [i] (every? #(< 0 (mod i %)) pp))\n          (range (last pp) (* 2 (last pp)))))))))", "user": "55afc197e4b002ce9d5cbc18"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "53cb5559e4b00fb29b2212d2"}, {"problem": 67, "code": "(fn [number]\n  (take number (filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "54f296efe4b024c67c0cf8c8"}, {"problem": 67, "code": "(fn [l]\n    (let [is-prime? (fn [n] (empty? (filter #(= 0 (mod n %)) (range 2 n))))]\n      (into [] (take l (filter #(and (> % 1) (is-prime? %)) (range))))))", "user": "559a9a3de4b066d22e731f45"}, {"problem": 67, "code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "user": "559c3d73e4b066d22e731f65"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime? (fn [x ps]\n                    (every? #(not= 0 (mod x %)) ps))\n        next-prime (fn [x ps]\n                     (if (is-prime? x ps)\n                       x\n                       (recur (+ x 2) ps)))\n        primes (iterate\n                 (fn [ps]\n                   (conj ps (next-prime (last ps) ps)))\n                 [2 3 5 7])]\n    (->> primes\n         (take n)\n         last\n         (take n))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 67, "code": "(fn ErastS  ([nom] (take nom (trampoline ErastS [] (let [lnNom (Math/log nom) lnlnNom (Math/log lnNom)] \n                                                   (range 2 (+ 3 (* nom (+ lnNom lnlnNom)))))))) \n            ([prim rang] (let [fe (first rang) ]  \n                         (if (< (* 2 fe) (last rang)) \n                             #(ErastS (conj prim (first rang)) (remove (fn [t] (.contains (range fe (last rang) fe) t)) rang))\n                              (concat prim rang)))) )", "user": "5576e78de4b05c286339e075"}, {"problem": 67, "code": "(fn [n]\n  (loop [ret [] n n i 2]\n    (if (zero? n)\n      ret \n      (if (some #(zero? (mod i %)) ret)        \n        (recur ret n (inc i))\n        (recur (conj ret i) (dec n) (inc i))))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 67, "code": "(fn [n] \n   (take n \n         (remove  \n          (fn [n] (some #{0} \n                        (for [i (range 2 n)\n                              :while (<= (* i i) n)] \n                           (mod n i)))) \n          (nnext (range)))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 67, "code": "(fn prime [n]\n   (take\n    n\n    (filter (fn p [x]\n              (empty? (filter #(zero? (mod x %))\n                              (range 2 x))))\n            (range 2 Double/POSITIVE_INFINITY))))", "user": "55b54ecbe4b01b9910ae2987"}, {"problem": 67, "code": "(fn [n]\n  (let [prime (fn primes [[the-first & the-rest]]\n                (cons the-first\n                      (lazy-seq (primes (filter #(not= 0 (mod % the-first))\n                                                the-rest)))))]\n    (take n (prime (rest (rest (range)))))))", "user": "55bbfd60e4b01b9910ae29ed"}, {"problem": 67, "code": "(fn [n]\n   (last\n     (take n (iterate (fn [primes-so-far]\n                        (conj primes-so-far\n                              (first\n                                (filter\n                                  (fn [candidate-prime]\n                                    (not-any? #(= (mod candidate-prime %) 0) primes-so-far))\n                                  (nthnext (range) (last primes-so-far))))))\n                      [2]))))", "user": "5587cd86e4b059ccff29b1e6"}, {"problem": 67, "code": "(fn n-primes [n]\n\t(take n (filter \n\t\t\t #(every? (fn [x] (not= 0 (rem %1 x))) \n\t\t\t \t      (range 2 (Math/sqrt (inc %1))))\n\t\t     (drop 2 (range)))))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 67, "code": "(fn [x]\n  (cond (= x 2) (list 2 3)\n        (= x 5) (list 2 3 5 7 11)\n        (= x 100) (list 1 541)))", "user": "55b3c03ee4b01b9910ae2975"}, {"problem": 67, "code": "(fn [n]\n  (loop [p 2 primes []]\n    (if (= n (count primes))\n      primes\n      (if (some #(= (rem p %1) 0) primes)\n        (recur (inc p) primes)\n        (recur (inc p) (conj primes p))))))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [[x & xs]]\n                 (cons\n                  x\n                  (lazy-seq (sieve (remove #(zero? (rem % x)) xs)))))]\n    (take n (sieve (iterate inc 2)))))", "user": "55aa7c5ce4b0988bba2ad94d"}, {"problem": 67, "code": "(fn primes\n  ([n] (take n (primes 2 (drop 3 (range)))))\n  ([i r]\n    (cons i\n      (lazy-seq\n      \n      (primes (first r)\n        (remove #(zero? (rem % i)) (rest r)))))))", "user": "55647a31e4b0c656e3ff1808"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes-seq []\n            (letfn [(insert-into-queue [m x p]\n                      (if (m x)\n                        (recur m (+ x p p) p)\n                        (assoc! m x p)))\n                    (next-primes [m x]\n                      (if-let [p (m x)]\n                        (recur (insert-into-queue (dissoc! m x) (+ x p p) p)\n                               (+ x 2))\n                        (cons x (lazy-seq (next-primes (insert-into-queue m (* x x) x)\n                                                       (+ x 2))))))]\n              (cons 2 (lazy-seq (next-primes (transient {}) 3)))))]\n    (take n (primes-seq))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 67, "code": "(fn [d] \n  (take d (drop 2 (filter \n   (fn [n] \n     (not (some \n           #(zero? (mod n %)) \n           (range 2 n)))) \n   (range)))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 67, "code": "(fn [n] \n  (take n \n        (filter \n         (fn prime? [n]\n           (cond\n             (= n 2) true\n             (even? n) false \n             :else (let [root (num (int (Math/sqrt n)))] \n               (loop [i 3] \n                 (if (> i root) true \n                   (if (zero? (mod n i)) false \n                     (recur (+ i 2))))))))\n         (iterate inc 2))))", "user": "55306f9de4b076ab5578f814"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? (fn [x]\n                 (every? #(> (mod x %) 0)\n                         (range 2 (inc (Math/sqrt x)))))]\n    (loop [i 3\n           r [2]]\n      (if (< (count r) n)\n        (recur (inc i)\n               (if (prime? i)\n                 (conj r i)\n                 r))\n        r))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 67, "code": "(fn [n] (take n ((fn sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) \n                                                                        (rest s)))))) (iterate inc 2)\n                 )))", "user": "55c10409e4b01b9910ae2a2c"}, {"problem": 67, "code": "(fn primes [n]\n  (let [p (atom [])]\n    (loop [i 2]\n      (when (not-any? #(zero? (mod i %)) @p)\n        (swap! p conj i))\n      (when (not= (count @p) n)\n        (recur (inc i))))\n    @p))", "user": "54f4adc8e4b0f2f3c5226e86"}, {"problem": 67, "code": "#(case %\n   2 [2 3]\n   5 [2 3 5 7 11]\n   100 [541])", "user": "54e1939ce4b024c67c0cf7c5"}, {"problem": 67, "code": "(fn prime-seq [n]\n   (letfn [(is-prime? [n]\n                      (loop [i 2]\n                        (cond (= i n) true\n                              (= (mod n i) 0) false\n                              :else (recur (inc i)))))\n           (next-prime [n]\n                       (loop [i (inc n)]\n                         (if (is-prime? i)\n                           i\n                           (recur (inc i)))))\n           (lazy-prime-seq [start]\n                           (lazy-seq\n                            (cons start (lazy-prime-seq (next-prime start)))))]\n     (take n (lazy-prime-seq 2))))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 67, "code": "(fn prime [k]\n  (let [estimate-prime  ; http://stackoverflow.com/a/25440642\n          (fn [n]\n            (let [log-n (Math/log n)\n                  log-log-n (Math/log log-n)\n                  upper\n                    (cond\n                      (< n 6)\n                        ([0 2 3 5 7 11] n)\n                      (>= n 688383)\n                        (* n (+ log-n log-log-n -1.0 (/ (- log-log-n 2.00) log-n)))\n                      (>= n 178974)\n                        (* n (+ log-n log-log-n -1.0 (/ (- log-log-n 1.95) log-n)))\n                      (>= n 39017)\n                        (* n (+ log-n log-log-n -0.9484))\n                      :else\n                        (* n (+ log-n (* 0.6 log-log-n))))]\n                  (Math/ceil upper)))\n        n (estimate-prime k)\n        candi (range 2 (inc n))\n        div-by (fn [divisor]\n                   #(= (mod % divisor) 0))]\n    (loop [curr k\n           remain candi\n           out []]\n      (let [head (first remain)\n            new-out (conj out head)]\n        (if (= curr 1)\n            new-out\n            (recur (dec curr) (doall (remove (div-by head) (rest remain))) new-out))))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 67, "code": "(fn primes\n   ([p] (primes p (drop 2 (range))))\n   ([p coll] (let [i (first coll)\n                   j (dec p)]\n               (if (= 0 j) [i] (cons i (primes j (filter #(not= 0 (mod % i)) (drop 1  coll))))))))", "user": "55c1eb52e4b0e31453f64970"}, {"problem": 67, "code": "(fn primes\n  ([x] (take x (primes)))\n  ([] (primes 2 [2]))\n  ([x xs] (let [n (first\n                   (filter\n                    (fn [i] (reduce #(and %1 (pos? (mod i %2))) true xs))\n                    (iterate inc (inc x))))]\n            (cons x (lazy-seq (primes n (conj xs n)))))))", "user": "4f85a75ce4b033992c121c48"}, {"problem": 67, "code": "(fn [n]\n    (take n \n      (filter (fn [x]\n        (every? #(< 0 (mod x %)) (range 2 x)))\n      (drop 2 (range)))))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 67, "code": "; Sieve of Eratosthenes\n(fn primes [n]\n  (letfn [(f [[x & xs]] \n            (cons x (lazy-seq (f (filter #(not= 0 (rem % x)) xs)))))]\n    (take n (f (drop 2 (range))))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 67, "code": "(fn primes \n  [n]\n  (take n (filter (fn [x] (and (not-any? (partial (fn [x y] (= (mod x y) 0)) x) (next (next (range x)))) (> x 1))) (range))))", "user": "55acd080e4b03311e7b73298"}, {"problem": 67, "code": "(fn [c]\n  (take c (filter (fn isprim? [n]\n                    (cond (= 1 n) false\n                          (= 2 n) true\n                          (even? n) false\n                          :else ((fn prim? [_n coll]\n                                   (cond (empty? coll) true\n                                         (zero? (mod _n (first coll))) false\n                                         :else (recur _n (rest coll))))\n                                  n (filter odd? (range 3 (quot n 2))))))\n                  (range))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(step [coll]\n            (let [head (first coll)]\n              (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n    (take n (step (range 2 Long/MAX_VALUE)))))", "user": "55c423e1e4b0e31453f64994"}, {"problem": 67, "code": "(fn [number]\n  (letfn [(p? [n] (every? (complement zero?) (map (partial rem n) (range 2 n))))]\n    (loop [r []\n           next 2]\n      (if (= number (count r))\n        r\n        (if (p? next)\n          (recur (conj r next) (inc next))\n          (recur r (inc next)))))))\n\n;(fn [n]\n;  (loop [primes [] nums (iterate inc 2)]\n;    (if (= n (count primes))\n;        primes\n;        (recur (conj primes (first nums)) \n;               (filter #(not= 0 (mod % (first nums))) nums)))))", "user": "55236ad6e4b0882d96d091b1"}, {"problem": 67, "code": "(fn [n]\n  (loop [curr 3 acc [2]]\n    (if (= (count acc) n)\n      acc\n      (recur (+ 2 curr) (if ((fn is-prime? [n]\n                               (if (= n 2)\n                                 true\n                                 (let [root (Math/floor (int (Math/sqrt n)))]\n                                   (loop [i 3]\n                                     (if (> i root) true\n                                         (if (= 0 (mod n i)) false\n                                             (recur (+ i 2)))))))) curr)\n                          (conj acc curr)\n                          acc)))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 67, "code": "(fn [n]\n    (take n (let [log (Math/log n)\n           lim (if (< n 6) 14 (* n (+ (Math/log log) log)))]\n       (loop [ns (range 3 lim 2) ps [2]]\n         (if (empty? ns)\n           ps\n           (let [[h & t] ns]\n             (recur (filter #(not= 0 (mod % h)) t) (conj ps h))\n             ))\n         ))))", "user": "54864662e4b0e286459a11b8"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [i] (every? #(not= (rem i %) 0) (range 2 (dec i)))) (drop 2 (range)))))", "user": "55b0f5bfe4b002ce9d5cbc28"}, {"problem": 67, "code": "(fn primes [limit]\n  (loop [primes [2]\n         candidate 3]\n    (cond (= (count primes) limit) primes\n          (some #(zero? (mod candidate %1)) primes) (recur primes (+ 2 candidate))\n          true (recur (conj primes candidate) (+ 2 candidate)))))", "user": "55d95be7e4b0e31453f64ac9"}, {"problem": 67, "code": "(fn first-x-prime-nums [bound]\n  (letfn [(prime? [x]\n            (empty? (filter #(zero? (rem x %)) (range 2 x))))]\n    (take bound (nnext (filter prime? (range))))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "55dab5c8e4b0e31453f64ada"}, {"problem": 67, "code": "(letfn ((primes\r\n          ([] (primes (cons 2 (iterate #(+ 2 %) 3))))\r\n          ([cands]\r\n           (let [x (first cands)]\r\n             (lazy-seq\r\n              (cons x (primes (remove #(= 0 (mod % x))\r\n                                      (drop 1 cands)))))))))\r\n  #(take % (primes)))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 67, "code": "(fn [n]\n  (->> (iterate inc 2)\n       (filter #(every? pos? (map (partial mod %) (range 2 %))))\n       (take n) ))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 67, "code": "#(take (min 6 %) [2 3 5 7 11 541])", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter #(not-any? zero? (map (partial rem %) (range 2 (inc (int (Math/sqrt %)))))) (drop 2 (range)))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter #(.isProbablePrime (biginteger %) 6) (range))))", "user": "55933c7ae4b0c79f6e1db938"}, {"problem": 67, "code": "(letfn [(update-tables [tables x p]\n                        (update-in tables [(+ x p p)] conj p))\n         (prime-step [tables x]\n                     (if-let [factors (get tables x)]\n                       (recur (reduce #(update-tables %1 x %2)\n                                      (dissoc tables x)\n                                      factors)\n                              (+ x 2))\n                       (lazy-seq\n                        (cons x (prime-step (assoc tables (* x x) [x])\n                                            (+ x 2))))))]\n   #(take % (cons 2 (prime-step {} 3))))", "user": "55db7e15e4b0e31453f64ae8"}, {"problem": 67, "code": "(fn prime [n] (take n (\n                       \n (fn lazy-prime \n  ([] (lazy-prime 2))\n  ([p]\n    ;test if p is prime\n    (lazy-seq \n     (let [p (max 2 p)] \n       (if (some #(= 0 (rem p %1)) (range 2 (inc (int (Math/sqrt p))) ))\n          (lazy-prime (inc p))\n          (cons p (lazy-prime (inc p)))))))))))", "user": "558bdcefe4b0277789237633"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        ((fn primes [coll]\n           (cons (first coll) (lazy-seq (primes (filter #(not= (mod % (first coll)) 0) coll)))))\n         (map (partial + 2) (range)))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 67, "code": "(fn primes [n]\n  (->\n   (iterate\n    (fn [[primes nums]]\n      [(conj primes (first nums)) (remove #(zero? (mod % (first nums))) nums)])\n    [[2] (iterate #(+ 2 %) 3)])\n   (nth (dec n))\n   first))", "user": "5561d2c2e4b0c656e3ff17cd"}, {"problem": 67, "code": "(fn [n]\n  (letfn [\n    (sieve [s]\n      (cons (first s)\n            (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n      (take n (sieve (iterate inc 2)))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 67, "code": "(fn [n] (take n\n              (filter (fn [x] (not (contains? (into #{} (map #(mod x %) (range 2 x))) 0)))\n              \t(range 2 Double/POSITIVE_INFINITY))))", "user": "55cae949e4b0e31453f649fe"}, {"problem": 67, "code": "(fn [primes x left]\n  (if (= left 0)\n    primes\n    (if (some #(= (rem x %) 0) primes)\n      (recur primes (inc x) left)\n      (recur (conj primes x) (inc x) (dec left))))) [] 2", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (filter\n      (fn [i]\n        (empty? (filter #(= 0 (rem i %)) (range 2 i)))\n        ) (drop 2 (range))\n      )\n    )\n  )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 67, "code": "#(take % (filter (fn [n]\n                   (and (not (zero? n))\n                        (not (= 1 n))\n                        (not-any? (fn [m] (zero? (mod n m)))\n                                  (range 2 (inc (quot n 2))))))\n                 (range)))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n              (cons (first s)\n                    (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                             (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 67, "code": "(fn [n]\n   (take n\n         (for [i (iterate inc 2)\n               :when (empty? (filter #(= (mod i %) 0) (range 2 i)))]\n           i)))", "user": "50f02de7e4b0bdaecbb47db0"}, {"problem": 67, "code": "(fn [x] (take x (iterate\n\n                    (fn [z]\n                      (loop [n (inc z)]\n                        (if ((every-pred odd? #(loop [y (dec %)] (if (= 2 y) true (if (integer? (/ % y)) false (recur (dec y)))))) n)\n                          n\n                          (recur (inc n)))))\n                    \n                    2)))", "user": "553bda0de4b09218d5f4500b"}, {"problem": 67, "code": "(fn prime [x]\n  (loop [res [2]\n         p 3\n         sum x]\n    (cond (= (count res) sum) res\n          :else (if (some #(= 0 %) (map mod (repeat p) (range 2 p)))\n                  (recur res (inc p) sum)\n                  (recur (conj res p) (inc p) sum)\n                  )\n          )\n    )\n  )", "user": "559067ace4b0277789237670"}, {"problem": 67, "code": "#(let [prime? (fn [x] (.isProbablePrime (BigInteger/valueOf x) 100))] (take % (filter prime? (range 1 Integer/MAX_VALUE))))", "user": "55b39523e4b01b9910ae2973"}, {"problem": 67, "code": "(fn prime\n  [n]\n  (take n\n  \t(filter\n  \t\t(fn [x] (empty? (filter #(zero? (mod x %)) (range 2 x))))\n  \t\t(drop 2 (range)))))", "user": "55c77070e4b0e31453f649d0"}, {"problem": 67, "code": "(fn[n] (let [divs (fn [num] (filter #(= 0 (mod num %)) (range 2 num)))]\n              (take n (filter #(= 0 (count (divs %))) (iterate inc 2)))))", "user": "555c6344e4b0b056612e224c"}, {"problem": 67, "code": "(fn prime-sieve\n  [x]\n  (letfn\n      [(next-composites [composite-map n step]\n         (let [prime-factor (composite-map n)\n               final-value (if (= n step) (+ n step step) n)]\n           (if prime-factor\n             (recur composite-map (+ n step step) step)\n             (assoc composite-map final-value step))))\n       (next-prime\n         [n composite-map]\n         (let [prime-factor (composite-map n)\n               prime? (nil? prime-factor)\n               step (if prime-factor prime-factor n) \n               composite-map (next-composites composite-map n step)\n               composite-map (dissoc composite-map n)]\n           (if prime?\n             (lazy-seq (cons n (next-prime (+ n 2) composite-map)))\n             (recur (+ n 2) composite-map))))]\n  (take x (lazy-seq (cons 2 (next-prime 3 {}))))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (\n      (fn primes\n        ([] (primes '()))\n        ([known-primes]\n          (letfn [(prime-test [x] (not-any? #(zero? (mod x %)) known-primes))]\n            (let [next-prime\n              (if (empty? known-primes)\n                2\n                (some #(when (prime-test %) %) (iterate inc (inc (first known-primes))))\n              )]\n              (cons next-prime (lazy-seq (primes (cons next-prime known-primes))))\n            )\n          )\n        )\n      )\n    )\n  )\n)", "user": "51f09f3de4b0274c496158d7"}, {"problem": 67, "code": ";; naive implementation of Sieve of Eratosthenes\n(fn primes [n]\n  (let [max (* 10 n)\n        filt #(set (map (partial * %)\n                        (range 2 (/ max %))))]\n    (take n (sort\n             (reduce (fn [s i] \n                       (if (contains? s i)\n                         (clojure.set/difference s (filt i))\n                         s))\n                     (set (range 2 max)) \n                     (range 2 max))))))", "user": "558bb38fe4b0277789237631"}, {"problem": 67, "code": "(fn [x]\n  (take x ((fn sieve [s]\n             (let [head (first s)\n                   tail (rest s)]\n               (cons head (lazy-seq (sieve (filter #(not= (mod % head) 0) tail))))))\n           (iterate inc 2))))", "user": "55d5ee3fe4b0e31453f64a92"}, {"problem": 67, "code": "(fn [n]\n    (take n\n          (reduce\n            (fn [acc n]\n              (if (not-any? #(zero? (mod n %)) acc)\n                (conj acc n)\n                acc))\n            []\n            (drop 2 (range 900)))))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 67, "code": "(fn [cnt]\n  (take cnt (drop 2\n        (filter #(loop [i 2 m (Math/floor (Math/sqrt %))]\n                             (cond\n                              (< m i) true\n                              (= 0 (mod % i)) false\n                              :else (recur (inc i) m)))\n                (range)))))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 67, "code": "(fn [x]\n  (loop [result [] current 2]\n    (if (= (count result) x)\n      result\n      (if (= 0 (count (filter #(= 0 (rem current %)) (range 2 current))))\n        (recur (conj result current) (inc current))\n        (recur result (inc current))\n      )\n    )\n  )\n)", "user": "55d79b87e4b0e31453f64aa8"}, {"problem": 67, "code": "(fn [n]\n (letfn [(prime? [primes num] (not (some #(zero? (mod num %)) primes)))\n          (add-prime [primes num] (if (prime? primes num) (conj primes num) primes))]\n    (loop [ct 2 primes []]\n      (let [n-primes (add-prime primes ct)]\n        (if (= n (count n-primes))\n          n-primes\n          (recur (inc ct) n-primes))))))", "user": "55d93d24e4b0e31453f64ac6"}, {"problem": 67, "code": "#(apply vector (take % (filter (fn [x] (not-any? zero? (map (fn [m ] (rem x m )) (range 2 (+ 1 (int (/ x 2) ) )) ) ) ) (drop 2 (range ))) ) )", "user": "55d44dd6e4b0e31453f64a75"}, {"problem": 67, "code": "(fn [x a n] \n  (if (= (count a) n)\n    a\n    (recur (+ 1 x)\n           (if (some #(= 0 (mod x %)) a)\n               a\n               (conj a x))\n           n))) \n2\n[]", "user": "55dab408e4b0e31453f64ad9"}, {"problem": 67, "code": "(fn primes\n  [c]\n  (if (= 1 c) [2]\n              (let [pl (primes (- c 1))]\n                (loop [v (+ 1 (last pl))]\n                  (if (every? #(not= 0 (mod  v %)) pl)\n                    (conj pl v)\n                    (recur (+ (if (odd? v) 2 1) v)))))))", "user": "55f04526e4b06e875b46ce20"}, {"problem": 67, "code": "(fn\n  [m]\n  (take m (let [n (double m)\n                logn (Math/log n)\n                loglogn (Math/log logn)\n                p (cond\n                    (>= m 7022) (* n (+ logn (- loglogn 0.9385)))\n                    (>= m 6)    (* n (+ logn loglogn))\n                    (>  m 0)    ([2 3 5 7 11 13] m)\n                    :else       0)]\n            (loop [a (apply sorted-set (range 2 p))\n                   b []]\n              (if (empty? a)\n                b\n                (recur\n                  (clojure.set/select #(pos? (rem % (first a))) a)\n                  (conj b (first a))))))))", "user": "55d1b565e4b0e31453f64a49"}, {"problem": 67, "code": "(fn [c]\n  (letfn [(prime? [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\n    (->> (iterate inc 2)\n         (filter prime?)\n         (take c))))", "user": "54722c55e4b094393f72dd74"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2 3]\n         candidate 5]\n    (if (= n (count primes))\n      primes\n      (if (every? #(> (mod candidate %) 0) primes)\n        (recur (conj primes candidate) (+ 2 candidate))\n        (recur primes (+ 2 candidate))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 67, "code": "(fn [x]\n  (take x (filter\n           (fn [n]\n             (when (< n 3) true)\n             (not (some zero? (map #(mod n %) (range 2 (-> (Math/sqrt n) int inc))))))\n           (iterate inc 2))))", "user": "55f6f1d3e4b06e875b46cea0"}, {"problem": 67, "code": "(fn [k] (take k ((fn primes [p n]\n                        (if (some #(= 0 (mod n %)) p)\n                          (primes p (inc n))\n                          (cons n (lazy-seq (primes (conj p n) (inc n))))))\n                      [] 2)))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 67, "code": "(fn prime-numbers\n  [x]\n  (drop 2\n    (take (+ x 2) \n      (let [n 10000\n          a (into [] (map #(not %) (boolean-array n)))\n          end (Math/sqrt n)]\n        ((fn sieve [i end candidates]\n          (if (< i end)\n            (when (a i)\n              (loop [j (* i i)\n                     primes candidates]\n                (if (< j n)\n                  (recur (+ j i) (assoc primes j false))\n                  (sieve (+ 1 i) end primes))))\n            (keep-indexed #(if %2 %1) candidates)))\n          2 (Math/sqrt n) a)))))", "user": "5574c172e4b05c286339e059"}, {"problem": 67, "code": "(fn [n] (take n\n      (filter (fn prime? [k] \n    (and (> k 1) (nil? \n          (some #(> %1 1) \n                (map #((fn gcd [a b] \n                           (if (= 0 b) \n                               a \n                               (recur b (mod a b)))) k %1) (range 1 (- k 1))))))) (range))))", "user": "55627de1e4b0c656e3ff17d9"}, {"problem": 67, "code": "(fn prob67 [n]\n  (take n\n        (cons 2 (filter \n                 (fn [x] ;; is prime\n                   (empty? (filter #(= 0 (mod x %)) (range 2 x)))\n                   )\n                 (iterate #(+ 2 %) 3)))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 67, "code": "(fn [n]\n  (take n (lazy-seq\n   (filter (fn prime? [x]\n  (if (= x 2)\n    2\n    (reduce #(and %1 (> (mod x %2) 0)) true (range 2 x)))) (drop 2 (range))))))", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  (let [next-prime (fn next-prime [prev-primes]\n                     (loop [n (inc (last prev-primes))]\n                       (if (every? identity (map  #(not (= 0 (mod n %))) prev-primes))\n                         n\n                         (recur (inc n)))))\n        seq-next-prime (fn [prev-primes]\n                         (conj prev-primes (next-prime prev-primes)))]\n    (cond\n      (< n 1) []\n      (= n 1) [2]\n      (= n 2) [2 3]\n      :else (nth (iterate seq-next-prime [2 3]) (-  n 2)))))", "user": "53350264e4b0656e627bfd73"}, {"problem": 67, "code": "(fn primes [n]\n  (let [max-n (* n n)\n        composites (loop [acc []\n                          a 2]\n                     (if (> a n)\n                       acc\n                       (let [ns (range (* a a) max-n a)]\n                         (recur (concat acc ns) (inc a)))))]\n    (take n (sort (vec (clojure.set/difference (set (range 2 max-n))\n                                        (set composites)))))))", "user": "50e3e108e4b01912b3285c48"}, {"problem": 67, "code": "(fn __\n  [num]\n  (->> (range) (map str) (map #(new BigInteger %)) (filter #(.isProbablePrime % 5)) (take num)))", "user": "55a62092e4b0acc240e31554"}, {"problem": 67, "code": "(fn primesTill [thenum] (let [results (atom [2]) ctr (atom 2) total (atom 1)]\n(letfn [(prime? [n] (not-any? #(zero? (mod n %)) (range 2 (inc (Math/sqrt n)))))]\n(while (< @total thenum)\n(if (prime? @ctr)\n(do (swap! results conj @ctr)\n(swap! total inc)\n))\n(swap! ctr inc)\n)) \n@results\n))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 67, "code": "(fn [n]\n (letfn \n  [(isdiv? [b]\n    (fn [a]\n     (not= 0 (mod a b))))\n   (sieve [s] \n    (lazy-seq\n     (cons\n      (first s) \n      (sieve (filter \n              (isdiv? (first s))\n              (rest s))))))]\n  (take n \n    (sieve (iterate inc 2)))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 67, "code": "(fn [n]\n      (loop [primes []\n             c 0\n             i 2]\n        (cond\n          (= c n) primes\n          (some zero?\n                (map (partial mod i) primes)) (recur primes c (inc i))\n          :else (recur (conj primes i) (inc c) (inc i)))))", "user": "50a3ad0ee4b0ceace084d493"}, {"problem": 67, "code": "(fn [num]\n  (take num (filter\n             (fn [x]\n               (not-any? #(= 0 (mod x %)) (range 2 x)))\n             (iterate inc 2))))", "user": "5602bdf9e4b04bb52996e1a7"}, {"problem": 67, "code": "(fn [n]\n  (loop [number 3, prime-seq [2], idx 1]\n    (if (< idx n)\n      (if (some #(zero? (rem number %)) prime-seq)\n        (recur (inc number) prime-seq idx)\n        (recur (inc number) (conj prime-seq number) (inc idx))\n        )\n      prime-seq\n      )\n    )\n  )", "user": "55fe7e15e4b00f4cabc57651"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "55af3e6be4b03311e7b732c7"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2] x 3]\n    (cond \n      (= n (count primes)) primes\n      (every? #(not= 0 (mod x %)) primes)(recur (conj primes x)(+ 2 x))\n      :else (recur primes (+ 2 x)))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 67, "code": "(fn [n]\n    (->> (range)\n         (filter #(not-any? zero? (map (partial mod %1) (range 2 (inc (int (Math/sqrt %1)))))))\n         (drop 2)\n         (take n)))", "user": "55f081bbe4b06e875b46ce25"}, {"problem": 67, "code": "(fn take-prime-numbers\n  [n]\n  (letfn\n    [(prime?\n        [n primes]\n        (reduce\n          (fn [val x]\n            (and val (not (zero? (mod n x)))))\n          true\n          primes))\n     (next-prime\n       [primes]\n       (first (filter\n                #(prime? % primes)\n                (drop (inc (last primes)) (range)))))\n     (prime-numbers\n       ([] (prime-numbers (vector 2)))\n       ([primes]\n          (cons (last primes) (lazy-seq (prime-numbers (conj primes (next-prime primes)))))))]\n    (take n (prime-numbers))))", "user": "55996253e4b031d6649c9baa"}, {"problem": 67, "code": "(fn primahh\n  [o]\n  (let [primx (fn primx\n                 [x]\n                 (let [akar (Math/sqrt x)\n                       iter (fn iter [i]\n                              (cond (> i akar) true\n                                    (zero? (rem x i)) false\n                                    :else (iter (+ i 2))))]\n                   (cond (<= x 1) false\n                         (= x 2) true\n                         (even? x) false\n                         :else (iter 3))))]\n    (take o (filter primx (range 1000)))))", "user": "55d9743ae4b0e31453f64aca"}, {"problem": 67, "code": ";(fn [n]\n;  (letfn [(isprime? [m]\n;            (not-any? #(zero? (mod m %)) (range 2 (inc (int (Math/sqrt m))))))]\n;    (take n (filter isprime? (rest (rest (range)))))))\n\n; easy optimization:\n; since 2 is the only even prime, and since an odd number cannot have\n; an even divisor:\n\n(fn primes [n]   ; or Integer/MAX_VALUE, or (iterate #(+ 2 %) 3)\n  (let [all-odds (range 3 Double/POSITIVE_INFINITY 2)\n        isprime? (fn [m]\n                   (let [some-odds (range 3 (inc (int (Math/sqrt m))) 2)]\n                     (every? #(pos? (unchecked-remainder-int m %)) some-odds)))]\n    (cond (= n 1) '(2)\n          (< n 1) '( )\n          :else (cons 2 (take (dec n) (filter isprime? all-odds))))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [x] (not-any? zero? (map #(rem x %) (range 2 (inc (Math/floor (Math/sqrt x)))))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "55e7d06ee4b050e68259b496"}, {"problem": 67, "code": "(fn [num-primes]\n  (loop [primes [2]\n         test-int 3]\n    (if (= (count primes) num-primes) primes\n      (if (not-any? zero? (map (partial mod test-int) primes))\n        (recur (conj primes test-int) (inc test-int))\n        (recur primes (inc test-int))))))", "user": "56041883e4b0c80df0ca2655"}, {"problem": 67, "code": "(fn [n] (->> (range) \n              rest \n              rest \n              (filter (fn prime?\n                         [x]\n                         (not-any? #(zero? (mod x %)) (range 2 x))))\n              (take n)))", "user": "5361d423e4b0243289761e49"}, {"problem": 67, "code": "(fn [no-of-primes]\n  (take no-of-primes\n    (filter\n      (fn [x]\n        (->> (range 2 x)\n             (map #(mod x %))\n             (into #{})\n             (#(contains? % 0))\n             (not)))\n      (map #(+ % 2) (range)))))", "user": "552d2e4fe4b076ab5578f7e1"}, {"problem": 67, "code": "(fn seq-prime [t]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take t (filter prime? (iterate inc 2)))))", "user": "56084e91e4b046a4fc0ac00f"}, {"problem": 67, "code": "(fn [n]\n  (loop [out [2]\n         count 1\n         cur-num 3]\n    (cond\n      (= count n) out\n      (some (fn [x](= 0 (mod cur-num x))) out)(recur out count (+ 2 cur-num))\n      :else (recur (conj out cur-num) (inc count) (+ 2 cur-num)))))", "user": "55f8180fe4b06e875b46ceba"}, {"problem": 67, "code": "(fn [n]              \n   (cond \n     (= n 1) [2] \n     (= 2 n) [2 3]\n     :else (loop [cnt 3 primes [2 3 5] prime 7]\n                  (if (= cnt n)\n                    primes\n                    (if ((fn [p] ;; prime?\n                           (loop [x 2 top (inc (quot p 2))] (if (= x top) true\n                                                              (if (= 0 (mod p x)) false (recur (inc x) top))))) prime)\n                      (recur (inc cnt) (conj primes prime) (+ prime 2) )\n                      (recur cnt primes (+ prime 2)))))))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 67, "code": "(fn [num-primes]\n  (loop [p 2 l (drop 2 (range))  res []]\n  \t(let [nl (filter #(not= 0 (mod % p)) l)]\n      (do (println (take 100 nl)))\n\t  (if (= num-primes (count res))\n        res\n        (recur (first nl) nl (conj res p))))))", "user": "53573d70e4b04ce2eb3ed278"}, {"problem": 67, "code": "(fn [n]\n  (let [divides? (fn [x] (fn [divisor] (zero? (mod x divisor))))]\n   (loop [i 2\n         primes []]\n    (if (>= (count primes) n)\n      primes\n      (recur (inc i)\n      \t     (if (some (divides? i) primes)\n               primes\n               (conj primes i)))))))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 67, "code": "#(take % ((fn list-primes [primes prime?]\n  (if (not-any? (comp zero? (partial mod prime?)) primes)\n                               (cons prime? (lazy-seq (list-primes (conj primes prime?) (inc prime?))))\n                                        (lazy-seq (list-primes primes (inc prime?))))) #{} 2))", "user": "532ecd44e4b019098a6f8b49"}, {"problem": 67, "code": "(fn [x] (take x\n              (filter #(every? identity\n                               (for [i (range 2 (inc (int (Math/sqrt %))))]\n                                 (pos? (mod % i))))\n                      (iterate inc 2))))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 67, "code": "(fn prime-seq1 [n]\n  \"This function returns the given size of prime numbers\"\n  (vec (take n (filter (fn [num]\n                         (if (< num 2)\n                           false\n                           (empty? (filter (fn [x]\n                                             (if (= 0 (mod num x)) true false )) (range 2 num)))))\n                       (iterate inc 0)))))", "user": "56038f34e4b04bb52996e1bc"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(is-prime [x]\n              (cond\n                (= x 2) true\n                (= x 3) true\n                :else (reduce #(and %1 (not= (rem x %2) 0))\n                              true (range 2 x))))\n            (primes [n]\n              (lazy-seq\n               (if (is-prime n)\n                (cons n (primes (inc n)))\n                (primes (inc n)))))]\n      (take n (primes 2))))", "user": "560e9a2de4b05f002753df52"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(isprime? [a] \n       (not (some #(= 0 (mod a %)) (range 2 (inc (/ a 2)))))               \n     )]\n    (take n \n      (filter isprime? (drop 2 (range)))\n    ) \n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 67, "code": "(fn [n]\n  (->> (drop 3 (range))\n       (filter (fn [x] (and (odd? x) (every? #(> (rem x %) 0) (range 3 x 2)))))\n       (cons 2)\n       (take n)))", "user": "55e732c5e4b050e68259b492"}, {"problem": 67, "code": "(fn [n]\n  (-> (fn [ps]\n        (->> (rest (iterate inc (last ps)))\n             (filter (fn [n] (not-any? #(= 0 (rem n %)) ps)))\n             first (conj ps)))\n      (iterate [2])\n      (nth (dec n))))", "user": "553698fae4b09218d5f44fc0"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n                 (lazy-seq (cons (first s) (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn sieve [[fs & ss]]\n             (cons fs\n                   (lazy-seq (sieve (filter #(not= 0 (mod % fs)) ss))))) (iterate inc 2))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 67, "code": "; NA\u00cfVE METHOD\n(fn [n]\n  (take n\n        (reduce\n         (fn [a b]\n           (if\n            (not-any? #(zero? (mod b %))\n                      a)\n            (conj a b)\n            a))\n         [2]\n         (range 3 1000))))", "user": "540c54a7e4b0addc1aec6700"}, {"problem": 67, "code": "(fn [c]\n  (take c ((fn gpl\n             ([n]    (cons n (lazy-seq (gpl (inc n) [n]))))\n             ([n pl] (let [np (first (filter (fn [m]\n                                               (every? identity (map #(not= (mod m %) 0) pl)))\n                                             (drop n (range))))]\n                       (cons np (lazy-seq (gpl (inc np) (conj pl np))))))) \n           2)))", "user": "56051095e4b08b23635d3162"}, {"problem": 67, "code": "(fn [x] (take x (filter (fn [t] (not-any? #(= 0 (rem t %)) (range 2 (dec t)))) (iterate inc 2))))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 67, "code": "(fn [n] (take n (filter #(not (nil? %)) \n                         (map #(when ((fn prime? [number]\n                                        (case number\n                                          0 false\n                                          1 false\n                                          (loop [i (dec number)]\n                                            (if (< i 2) \n                                              true\n                                              (if (= 0 (rem number i))\n                                                false\n                                                (recur (dec i))))))) %) %) \n                              (range 1000)))))", "user": "5603d057e4b0c80df0ca264e"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n                  (not (some zero? (map #(mod x %) (range 2 x)))))]\n    (take n (for [n (drop 2 (range)) :when (prime? n)]  n))))", "user": "54dce62be4b024c67c0cf78b"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(prime? [a]\n              (if (or (= a 1) (= a 2)) true\n                  (not-any? #(zero? (mod a %)) (range 2 a))))]\n      (take n (filter prime? (iterate inc 2)))))", "user": "532f8569e4b019098a6f8b4f"}, {"problem": 67, "code": "(fn primes [n]\n  (take n\n    (filter\n      (fn [cand] (not-any? #(zero? (mod cand %)) (range 2 cand)))\n      (drop 2 (range)))))", "user": "561f9110e4b064ca9f4b16ce"}, {"problem": 67, "code": "(fn [limit]\n  (let [is-prime (fn [num1]\n                   (loop [i 2]\n                     (if (> (* i i) num1)\n                       true\n                       (if (= 0 (mod num1 i))\n                         false\n                         (recur (inc i))))))]\n    (loop [primes []\n           n 2\n           num-primes 0]\n      (if (= limit num-primes)\n        primes\n        (if (is-prime n)\n          (recur (conj primes n) (inc n) (inc num-primes))\n          (recur primes (inc n) num-primes))))))", "user": "561fc0d0e4b064ca9f4b16d2"}, {"problem": 67, "code": "(fn [n]\n    (take n (filter (fn [x] (every? #(not= 0 (mod  x %)) (range 2 x)) )\n                 (map (partial + 2) (range))))\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 67, "code": "(fn [n] \n  (take n \n    (remove\n      #(some (fn [i] (= 0 (mod % i))) (range 2 %))\n      (drop 2 (range)))))", "user": "561047eae4b05f002753df6d"}, {"problem": 67, "code": "(fn [t]\n   (letfn [(prime? [x]\n             (every? #(pos? (mod x %))\n                     (range 2 (Math/sqrt (inc x)))))]\n     (take t (filter prime? (iterate inc 2)))))", "user": "55b1e9e7e4b0da326a65cf74"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x] (or (= x 2) (not (some #(= (mod x %) 0) (range 2 (- x 1))))))]\n    (loop [nr 2\n           primes-found 0\n           res []]\n      (if (= primes-found n)\n        res\n        (if (prime? nr)\n          (recur (inc nr) (inc primes-found) (conj res nr))\n          (recur (inc nr) primes-found res))))))", "user": "56228d00e4b03f08ee9a9227"}, {"problem": 67, "code": "(fn nPrimes\n  [n]\n  (take n (filter (fn isprime\n  [num]\n  (= 0 (count (filter #(= 0 %)\n                  (map #(mod num %)\n                       (range 2 (/(+ num 1)\n                                  2))))))) (iterate inc 2))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 67, "code": "(fn [n]\n            (let [next-prime (fn [from]\n                               (first (filter (fn [n]\n                                                (not-any? (fn [p] (= 0 (rem n p))) (range 2 (- n 1)))\n                                                ) (iterate inc from)\n                                              )))\n                  first-primes (fn fp [n] (let [next (next-prime n)]\n                                         (cons next (lazy-seq (fp (+ next 1))))\n                                         ))\n                  ]\n              (take n (first-primes 2))\n              ))", "user": "55aa5f73e4b0988bba2ad94b"}, {"problem": 67, "code": "(fn [count]\n  (let [devides? (fn [a b]\n                   (= 0 (rem a b)))\n        find-divisor (fn [n]\n                       (loop [div 2]\n                         (cond\n                           (devides? n div) div\n                           (> (* div div) n) n\n                           :else\n                           (recur (inc div)))))\n        is-prime? (fn [n]\n                    (let [div (find-divisor n)\n                          result (= div n)]\n                      result))]\n    (into [] (take count  (filter is-prime? (drop 2 (range)))))))", "user": "559e6f42e4b08a52bd4f97d3"}, {"problem": 67, "code": "(fn [x] (take x ((fn primes [s]\n           (cons (first s)\n                 (lazy-seq (primes (filter\n                                    #(not= 0 (mod % (first s)))\n                                    (rest s)))))) (iterate inc 2))))", "user": "5614fa1de4b05f002753dfbe"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (remove (fn [x]\n                  (some #(= 0 (mod x %))\n                        (range 2 (inc (int (Math/sqrt x))))))\n                (iterate inc 2))))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 67, "code": "(fn [x]\n  (take x (letfn [(%ps [v]\n            (lazy-seq (if (not-any? #(zero? (mod v %)) (drop 2 (range v)))\n                        (cons v (%ps (+ 1 v)))\n                        (%ps (+ 1 v)))))] (%ps 2))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 67, "code": "(fn sieve [n]\n  (let [anyPredicate  (fn [n predicates]\n  (if (= 0 (count predicates))\n    false\n    (loop [a (first predicates)\n           b (rest predicates)]\n      (cond\n        (a n) true\n        (= 0 (count b)) false\n        :else (recur (first b) (rest b))\n      )\n    )\n  )\n)]\n  (loop [result []\n         predicates []\n         a 2\n         b (drop 3 (range))]\n       (cond\n         (= n (count result)) result\n         (anyPredicate a predicates)\n           (recur result predicates (first b) (rest b))\n         :else\n           (recur (conj result a) (conj predicates #(= 0 (mod % a))) (first b) (rest b))\n       )\n  )\n  )\n)", "user": "56195e57e4b053970a773af6"}, {"problem": 67, "code": "(fn primes[n]\n  (first\n    (filter \n      #(>= (count %) n)\n      (reductions\n        (fn [l x]\n          (if (every? #(not= 0 %) (map #(mod x %) l))\n            (conj l x)\n            l))\n        []\n        (iterate inc 2))\n  )))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 67, "code": "(fn gen-primes [n]\n  (take n (lazy-seq\n           (drop 2 (filter\n                    (fn prime? [n]\n                      (every? #(pos? (mod n %)) (range 2 n)))\n                    (range))))))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 67, "code": "#(take % (filter (fn [x]\n                    (loop [y 2]\n                      (cond\n                        (> (* y y) x) true\n                        (= (rem x y) 0) false\n                        :else (recur (inc y))\n                        ))\n                    ) (range 2 10000)))", "user": "5628cb07e4b00e49c7cb47ef"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (filter\n      (fn [m] (pos? (apply *' (map #(mod m %) (range 2 m)))))\n      (iterate inc 2))))", "user": "5566463ee4b0c656e3ff1831"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes []\n         sieve (drop 2 (range))]\n    (if (<= n (count primes))\n      primes\n      (let [prime (first sieve)]\n        (recur \n         (conj primes prime)\n         (filter #(not (= 0 (mod % prime))) sieve))))))", "user": "5368fedee4b0243289761e93"}, {"problem": 67, "code": "(fn [x] \n  (let [is-prime? (fn [n] (empty? (filter #(= (mod n %) 0) (range 2 n))))]\n  (take x (filter is-prime? (range 2 1000)))))", "user": "5272645de4b03e8d9a4a742c"}, {"problem": 67, "code": "(fn [left]\n  (cons 2\n    (loop [n 3, ps [], left (dec left)]\n      (if (zero? left) ps\n        (let [n-is-p (not-any? #(= 0 (mod n %)) ps)]\n          (recur (+ n 2) \n                 (if n-is-p (conj ps n) ps) \n                 (if n-is-p (dec left) left)))))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 67, "code": "(fn [n] (->> (iterate inc 2) ((fn R [[m & M]] (lazy-cat [m] (R (filter (fn [i] (< 0 (mod i m))) M))))) (take n)))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 67, "code": "(fn take-prime-numbers [num]\n  (letfn [(prime? [n]\n                  (not (some #(= (mod n %) 0) (range 2 n))))]\n    (take num (filter prime? (iterate inc 2)))))", "user": "54eb22a0e4b024c67c0cf845"}, {"problem": 67, "code": "(fn [k] (take k (filter #((fn [j] (= 2 (count ((fn [i] (filter (fn [o] (zero? (mod i o))) (range 1 (inc i)))) j)))) %) (range 1000))))", "user": "53b1db8ee4b047364c044495"}, {"problem": 67, "code": "(fn [n] (let [\n\tinc2 \t#(+ 2 %)\n\tdiv?    #(comp zero? (partial mod %))         \n    prime?  #(some (div? %2) %)\n    next-prime #(->> (iterate inc2 (last %)) \n                     (drop-while (partial prime? %))\n                     first\n              \t\t (conj %))\n]\n  \n(->> [2 3]\n\t(iterate next-prime) \n\t(take (dec n))\n\tlast)))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 67, "code": "(fn [a]\n  (take a (reverse \n           ((fn prime-sieve [n]\n            (loop [f [] l (range 2 n)]\n              (if (empty? l)\n                f\n                (recur (cons (first l) f) (remove #(zero? (mod % (first l))) l))))) 1000))))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": 67, "code": "(fn primes [n]\n (let [isPrime?\n       (fn [x col] (not (some #(= 0 %) (map #(rem x %) col))))]     \n   (loop [a 3, sieve [2]]\n\t(if (= (count sieve) n) sieve\n\t(recur (inc a) (if (isPrime? a sieve) (conj sieve a) sieve))))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 67, "code": "(fn [x] (loop [result [] nums (drop 2 (range))]\n\t      (cond (= x (count result)) result\n\t\t    :else (recur (conj result (first nums)) (remove #(= 0 (mod % (first nums))) nums)))\n\t ))", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 67, "code": "(fn prime-numbers-solution\n  [n] ;; update args as needed\n  ;; Write a function which returns the first x\n  ;; number of prime numbers.\n  (take n \n        (filter \n         #(not-any? (fn [x] (= 0 (rem %1 x)))\n                    (range 2 (dec %1))\n          )\n         (iterate inc 2)\n         )))", "user": "536829c8e4b0243289761e8b"}, {"problem": 67, "code": "(fn [n] (->> (filter #(= % ((fn [number] (->> (range 2 (inc number))\n                                        (drop-while (fn [x] (pos? (mod number x))))\n                                        first)) %)) (range))\n       (take n)))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 67, "code": "(fn [n] (letfn [(p [x]\n  (loop [v x d (dec x)]\n    (cond\n     (<= x 1) false\n     (<= d 1) 1\n     (= (rem v d) 0) false\n     :else (recur v (dec d)))))]\n   (take n (filter p (range)))))", "user": "55ed9108e4b0121d4835fddc"}, {"problem": 67, "code": "(fn [cnt]\n  (letfn [(prime? [x]\n                  (loop [i (int (Math/sqrt x))]\n                    (cond\n                     (= 1 i) true\n                     (= 0 (rem x i)) false\n                     :else (recur (dec i)))))]\n  (loop [cnt cnt x 2 res []]\n    (cond\n     (zero? cnt) res\n     (prime? x) (recur (dec cnt) (inc x) (conj res x))\n     :else (recur cnt (inc x) res)))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 67, "code": "(fn n-primes\n  [n]\n  (let [prime? (fn\n                 [n]\n                 (case n\n                   2 true\n                   (let [top (int (/ n 2))]\n                     (loop [i 2]\n                       (cond\n                        (zero? (mod n i)) false\n                        (>= i top) true\n                        :else (recur (inc i)))))))]\n    (loop [result []\n           i 2]\n      (cond\n       (>= (count result) n) result\n       (prime? i) (recur (conj result i) (inc i))\n       :else (recur result (inc i))))))", "user": "4fc524aae4b081705acca37e"}, {"problem": 67, "code": "(fn [num-primes]\n  (let [is-prime? (fn [n] (every? #(> (rem n %) 0) (range 2 n)))]\n    (take num-primes (filter is-prime? (iterate inc 2)))))", "user": "562e8b2be4b0ab312c17ebbb"}, {"problem": 67, "code": "(fn [x]\n  (take x\n    (filter\n      (fn [n]\n        (if (= 2 n) \n          true \n          (empty? (for [i (range 2 (+ 1 (Math/sqrt n))) :let [r (mod n i)] :when (= 0 r)]\n            i))))\n      (iterate inc 2))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 67, "code": "(fn [np] (take np (filter (fn [n] (not-any? #(zero? (mod n %)) (range 2 n))) (drop 2 (range)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(iterate inc 2))))", "user": "5632b0a9e4b0bfe05bf117a8"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [n] (nil? (some #(zero? (mod n %)) (range 2 n)))) (range 2 1000))))", "user": "56399b7ee4b0bfe05bf117f5"}, {"problem": 67, "code": "(fn [n] (loop [primes [2] candidate 3]\n    (if (>= (count primes) n)\n      primes\n      (recur\n         (if (first (filter #(= (rem candidate %) 0) primes)) primes (conj primes candidate))\n         (+ candidate 2)))))", "user": "561cb6cfe4b064ca9f4b169e"}, {"problem": 67, "code": "(fn [x]\n   (take x (remove (fn [number]\n                     (some zero?\n                           (map (partial rem number)\n                                (range 2 number))))\n                   (map (partial + 2) (range)))))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 67, "code": "(fn[n](\nloop[s [2] i 3](\n  if(= (count s) n) s\n  (recur (\n           if(some true? (map (fn[j](= (int(/ i j)) (/ i j))) s))\n           s\n           (conj s i) \n           ) (+ i 2))\n)\n))", "user": "56039843e4b04bb52996e1be"}, {"problem": 67, "code": "(fn primes*\n  [n]\n  (if (= n 1) [2]\n    (let [previous (primes* (dec n))\n          find-by (comp first filter)\n          divisible-by-any? #(some (fn [val] (zero? (mod %2 val))) %1)\n          ]\n      (conj previous (find-by #(not (divisible-by-any? previous %)) (iterate inc (last previous))))\n      )\n  ))", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 67, "code": "(fn [x]\n  (take x\n        (let [primes (atom [])]\n          (for [n (iterate inc 2)\n                :when (not-any? #(zero? (rem n %))\n                             (filter #(<= % (Math/sqrt n)) \n                                     @primes))]\n            (do (swap! primes conj n)\n             n)))))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 67, "code": "(fn prime-numbers\n  ([n] (prime-numbers n 0 1))\n  ([n generated-so-far last-prime]\n  (if (= n generated-so-far) (list)\n    (let [\n      is-prime (fn [x]\n        (cond\n          (= x 2) true\n          (= x 3) true\n          :else (reduce #(and %1 %2) (map #(pos? (rem x %)) (range 2 (dec x))))\n        )\n      )\n  \n      get-prime-after (fn [x]\n        (first (drop-while (complement is-prime) (iterate inc (inc x))))\n      )\n      ]\n    \n      (let [next-prime (get-prime-after last-prime)]\n        (cons next-prime (prime-numbers n (inc generated-so-far) next-prime))\n      )\n    ))\n  )\n)", "user": "56393681e4b0bfe05bf117f2"}, {"problem": 67, "code": ";; Sieve\n;(fn [n]\n;  (nth\n;   (map\n;    first\n;    (iterate\n;     (fn [[acc [x _ :as xs]]]\n;       [(conj acc x)\n;        (filter #(> (mod % x) 0) xs)])\n;     [[] (iterate inc 2)]))\n;   n))\n\n;; Naive\n(fn [n]\n  (take n\n        (filter (fn [x]\n                  (every? #(not (zero? (mod x %)))\n                          (range 2 x)))\n                (iterate inc 2))))", "user": "54485749e4b032a45b8693c7"}, {"problem": 67, "code": "(fn first-primes  \n  ([n] (take n (first-primes 2 (drop 2 (range))))) \n  ([p coll]\n   (cons \n    p \n    (lazy-seq \n     (let [sieved-coll (remove #(zero? (mod % p)) coll)]\n       (first-primes (first sieved-coll) \n                     (drop 1 sieved-coll)))))))\n\n;(fn [n]\n;  (map \n;   first\n;   (take \n;    n \n;    (iterate\n;     (fn [[p coll]]\n;       (let [sieved-coll (remove #(zero? (mod % p)) coll)]\n;       [(first sieved-coll)\n;        (drop 1 sieved-coll)]))\n;     [2 (drop 2 (range))]))))", "user": "52f3568fe4b05e3f0be25f0e"}, {"problem": 67, "code": "(fn [x]\n  (let [certainty 5\n        prime? (fn [n]\n                  (.isProbablePrime (BigInteger/valueOf n)\n                                    certainty))]\n        (take x (filter prime? (lazy-cat [2] (take-nth 2 (range 3 Integer/MAX_VALUE)))))))", "user": "4f856adfe4b033992c121c44"}, {"problem": 67, "code": "(fn [n] (take n (filter #(empty? (for [x (range 2 (Math/sqrt (inc %))) :when (= (mod % x) 0)] x)) (iterate inc 2))))", "user": "56347285e4b0bfe05bf117bc"}, {"problem": 67, "code": "(fn primes\n  [x]\n  (let [prime? (fn [n] (not-any? #(zero? (rem n %))\n                                 (range 2 n)))\n        primes (for [x (iterate inc 2) :when (prime? x)] x)]\n    (take x primes)))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 67, "code": "(fn primes [x]\n  (loop [p [], n 2, cnt 0]\n    (println \"loop\" p n cnt)\n    (cond (= cnt x) p,\n          (some #(= 0 (rem n %)) p)\n          (recur p (inc n) cnt),\n          :else (recur (conj p n) (inc n) (inc cnt)))))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 67, "code": "(fn [x] (let [primes \n      ((fn [] \n        (loop [nums (range 2 1000) div  2 ]\n          (let [isprime?  #(or (> (mod % div) 0) (= % div))]\n          (if (> div 500) nums\n            (recur (filter isprime? nums) (inc div)))))))]\n  (take x primes)\n  ))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 67, "code": "(fn [n]\n  (let [s (iterate inc 2)\n        f (fn sieve [s] (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                (rest s))))))]\n    (take n (f s))))", "user": "563ed73ae4b08d4f616f5ecb"}, {"problem": 67, "code": "(fn find-n-primes [n ] \n  (letfn [(divisors [n]\n                    (loop [d 2, acc []]\n                      (cond (> d (/ n 2)) acc\n                            (= 0 (mod n d))     (recur (inc d) (conj acc d))\n                            :else               (recur (inc d) acc))))\n\n          (prime? [n]\n                  (= 0 (count (divisors n))))]\n    (loop [p   2\n           acc []]\n      (if (= n (count acc)) \n        acc\n        (if (prime? p)\n          (recur (if (= p 2) 3 (+ p 2)) (conj acc p))\n          (recur (if (= p 2) 3 (+ p 2)) acc))))))", "user": "563772a9e4b0bfe05bf117d7"}, {"problem": 67, "code": "(letfn [(primes\n         [[x & xs]]\n         (lazy-seq\n          (cons x (primes\n                   (remove #(zero? (mod % x))\n                           xs)))))]\n\n  #(->> (iterate (partial + 2) 3)\n        primes (cons 2) (take %)))", "user": "505fdf63e4b08f2a82ad10b9"}, {"problem": 67, "code": "(fn primes [n]\n  (let [divisors (fn [x]\n                   (filter\n                    #(zero? (mod x %))\n                    (range 1 (inc x))))\n        is-prime? (fn [x]\n                    (= 2 (count (divisors x))))]\n    \n    (take n (filter is-prime? (range)))))", "user": "5641296de4b08d4f616f5ef4"}, {"problem": 67, "code": "#(first (take % (reduce (fn [[prm rst] _]\n                   (let [fst (first rst)]\n                     [(conj prm fst)\n                      (filter (fn [t]\n                                (-> (mod t fst) zero? not))\n                              rst)]))\n                 [[] (-> 1000 range (nthnext 2))]\n                 (range %))))", "user": "5649542fe4b0284900eef63f"}, {"problem": 67, "code": "(fn [x]\n   (take x ((fn sieve\n              ([] (sieve [2] 2))\n              ([primes n]\n               (cons n\n                     (lazy-seq\n                       (let [next (first\n                                    (drop-while\n                                      (fn [i] (some (fn [p] (zero? (mod i p))) primes))\n                                      (drop (inc n) (range))))]\n                         (sieve (conj primes next) next)))))))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 67, "code": "#(take % (filter (fn prime? [x]\n  (cond (<= x 1) false\n    (= x 2) true\n    (even? x) false\n    :else ((fn prima [x y]\n  (cond (= x  y) true\n    (zero? (rem x y)) false\n    :else (recur x (inc y)))) x 3))) (range)))", "user": "5643ba10e4b0018b46ad8bff"}, {"problem": 67, "code": "(fn [x] (let [prime? (fn [n]\n                       (cond\n                         (= 1 n) false\n                         (even? n) (= 2 n)\n                         :else\n                         (not\n                           (reduce #(or %1 %2) false\n                                   (map #(= (mod n %) 0)\n                                        (range 3 (+ 1 (Math/sqrt n)) 2))))))\n              next-prime (fn [n]\n                           (cond\n                             (= 1 n) 2\n                             :else\n                             (first\n                               (filter prime?\n                                       (range (+ n 1) (* n 2))))))]\n          (take x (iterate next-prime 2))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [num]\n                 (not-any? #(zero? (rem num %)) (range 2 num)))\n        ]\n    (take n (filter prime? (iterate inc 2)))))", "user": "55eb026de4b0121d4835fdb7"}, {"problem": 67, "code": "(fn [n]\n  (let [divides (fn[a b] (= 0 (mod a b)))\n        n-inf (fn [m](iterate inc m))\n        next-prime (fn [S]  (conj S (first (drop-while (fn [m] (some #(divides m %) S)) (n-inf (inc (last S))))))   )]\n    \t(nth (iterate next-prime [2]) (dec n))\n   \n   )\n \n )", "user": "5649615be4b0284900eef641"}, {"problem": 67, "code": "(fn nprimes [n]\n\t(loop [k 2 primes '()]\n\t\t(if (= (count primes) n)\n\t\t\t(reverse primes)\n\t\t\t(recur \n\t\t\t\t(inc k)\n\t\t\t\t(if (every? (fn [x] (not (zero? (mod k x)))) primes) (cons k primes) primes)))))", "user": "563d12f9e4b0bfe05bf11845"}, {"problem": 67, "code": "(fn [x]\n  (take x\n   (filter \n   (fn [n] \n     (every? #(not (zero? %)) \n             (map #(rem n %) (range 2 n))\n             )) \n   (range 2 10000))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    ((fn primes []\n      (lazy-cat\n        [2 3 5]\n        (for\n            [x (lazy-seq (iterate (fn [a] (+ 2 a)) 7))\n               :when (empty?\n                        (for [b (take-while #(<= % (biginteger (Math/ceil (Math/sqrt x))))\n                                            (primes))\n                              :when (= 0 (mod x b))]\n                              b))]\n            x))))\n        ))", "user": "55c49394e4b0e31453f6499e"}, {"problem": 67, "code": "(fn [x] (letfn [(prime? [n]\n \t\t\t(or (= n 2)\n\t\t\t (= n 3)\n\t\t\t(empty? (remove #(not= 0 (rem n %)) (drop 2 (range (inc (Math/sqrt n))))))))\n\t\t (next-prime [n]\n\t\t  (loop [i (inc n)]\n\t\t   (if (prime? i) i\n\t\t    (recur (inc i)))))\n]\n (take x (iterate next-prime 2))\n   ))", "user": "54227fc6e4b01498b1a71ac0"}, {"problem": 67, "code": "(fn primes [n]\n  (take n (for [x (drop 2 (range)) \n\t:when (let [rootN (Math/sqrt x)]\n\t\t\t(loop [i 2]\n\t\t\t\t(if (<= i rootN)\n\t\t\t\t\t(if (= 0 (mod x i)) false (recur (inc i)))\n\t\t\t\t\ttrue)))] x)))", "user": "564d02cde4b0284900eef679"}, {"problem": 67, "code": "(fn [n]\n    (let [prime? (fn [x] (not-any? #(= 0 (mod x %)) (range 2 (- x 1))))]\n      (take n (filter prime? (iterate inc 2)))))", "user": "4f213e2ee4b0d66497709fcf"}, {"problem": 67, "code": "#(take % (filter (fn [x] ( cond\n                          (>= 1 x) false\n                          (= 2 x) true\n                          (= 3 x) true\n                          (even? x) false\n                          (= (mod x 3) 0) false\n                          :default (loop [d 5 n x]\n                                     (cond\n                                       (= d x) true\n                                       (= (mod x d) 0) false\n                                       :default (recur (+ d 2) x))))) (range) ))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 67, "code": "(letfn [(sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))))\n        (gen-primes [n]\n                    (take n (sieve (iterate inc 2))))]\n  gen-primes)", "user": "560bb1f7e4b05f002753df20"}, {"problem": 67, "code": "{2 [2 3], 5 [2 3 5 7 11], 100 [541]}", "user": "4ee67364535d93acb0a6685f"}, {"problem": 67, "code": "#(loop[i 0, n 2, r '()] \n   (if(= i %)\n     (sort r)\n     (if(loop[f 2] (if(and (integer? (/ n f)) (< f n)) false (if(= f n) true (recur(inc f)))))\n       (recur(inc i)(inc n)(cons n r))\n       (recur(+ i 0)(inc n)(and 1 r)))))", "user": "5654e8ade4b0f9d632dd848e"}, {"problem": 67, "code": "(fn [n] (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5)\n                                (range 1 Integer/MAX_VALUE))))", "user": "54a677a9e4b09f271ff37c88"}, {"problem": 67, "code": "#(take % (keep\n            (fn [n]\n              (loop [i 2]\n                (cond (= i n) n\n                      (or (< n 2) (= 0 (rem n i))) nil\n                      1 (recur (inc i)))))\n            (range)))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 67, "code": "(fn [n] (take n ((fn primes [s] (cons (first s) (lazy-seq (primes (filter #(not= 0 (mod % (first s)))\n                                                                   (rest s)))))) (iterate inc 2))))", "user": "55c13e73e4b01b9910ae2a2f"}, {"problem": 67, "code": "(fn prime [howmany] \n       (reductions (fn [last _]\n                     (loop [cur (inc last)]\n                       (if (or (< cur 4) (not-any? #(integer? (/ cur %)) (range 2 (dec cur))))\n                         cur\n                         (recur (inc cur)))))\n                   (range 2 (+ howmany 2))))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 67, "code": "(fn prime [n]\n  (let [sieve (fn toto[s]\n           (cons (first s)\n             (lazy-seq (toto (filter #(not= 0 (mod % (first s)))\n                                (rest s))))))]\n\n    (take n (sieve (iterate inc 2)))\n    )\n\n  )", "user": "563b9acbe4b0bfe05bf11827"}, {"problem": 67, "code": "(fn prime [n] (loop [result []\n                       prime-stream (drop 2 (range))]\n                  (if (< (count result) n)\n                    (recur\n                      (conj result (first prime-stream))\n                      (filter #(> (mod % (first prime-stream)) 0) prime-stream))\n                    result)\n                  ))", "user": "563f2eaae4b08d4f616f5ed1"}, {"problem": 67, "code": "(fn [x]\n  (nth (iterate (fn [p]\n                  (conj p (loop [l (inc (last p))]\n                            (if (some #(= (rem l %) 0) p) (recur (inc l)) l)))) [2]) (dec x)))", "user": "5382704be4b06839e8705ed4"}, {"problem": 67, "code": "(fn primes ([n] (primes n [2] 3))\n  ([n ps s] (if (= n (count ps)) ps\n              (if (reduce #(and %1 (< 0 (mod s %2))) true ps) (primes n (conj ps s) (inc s))\n                (primes n ps (inc s))))))", "user": "565a3e25e4b068f2fe63dbfb"}, {"problem": 67, "code": "(fn [num] (take num\n                (for [x (cons 2 (range 3 1000 2))\n                      :when ((fn [n]\n                              (not-any? zero? (map #(rem n %) (range 2 n)))) x)] x)))", "user": "5658d775e4b00d3155796114"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n                (lazy-seq (cons (first s)\n                                (sieve (filter #(not (zero? (mod % (first s)))) (rest s))))))]\n\t(take n (sieve (iterate inc 2)))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 67, "code": "(fn crible \n  ([x] (crible x 2 #{}))\n  ([x n prims]\n   (if (zero? x) \n     '()\n     (lazy-seq \n      (if (some #(= (rem n %) 0) prims)\n        (crible x (inc n) prims)\n        (cons n (crible (dec x) (inc n) (conj prims n))))))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 67, "code": "(fn prime [x]\n  (let [n      300\n        nums   (range 1 (inc n))\n        remove (mapcat (fn [i] (map #(+ i % (* 2 i %)) nums)) nums)\n        remaining (clojure.set/difference (set nums) (set remove))]\n    (take x (sort (cons 2 (map #(inc (* 2 %)) remaining))))))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 67, "code": "(fn [n] (take n \n      (filter \n       (fn [num] (not-any? #(zero? (mod num %)) (range 2 num)))\n       (iterate inc 2))))", "user": "561c0278e4b064ca9f4b1691"}, {"problem": 67, "code": "(fn [x r n]\n  (if (= n 1)\n    r\n    (if (not-any? #(= 0 %) (map #(mod x %) r))\n      (recur (inc x) (conj r x) (dec n))\n      (recur (inc x) r n)))) 3 [2]", "user": "54b2ec84e4b09f271ff37d33"}, {"problem": 67, "code": "(fn primes [n] (->> (range)\n                     (drop 2)\n                     (filter (fn prime? [x] (->> (range)\n                                   (take x)\n                                   (drop 1)\n                                   (map (partial mod x))\n                                   (filter zero?)\n                                   count\n                                   (= 1))))\n                     (take n)))", "user": "56561119e4b0f9d632dd849d"}, {"problem": 67, "code": "(fn [n]\n  (take\n   n\n   (map\n    first\n    (iterate\n     (fn [[n xs]]\n       (let [xs (remove #(zero? (mod % n)) xs)]\n         [(first xs) (rest xs)]))\n     [2 (drop 2 (range))]))))", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 67, "code": "(fn primes [n]\n  (take n ((fn sieve [s]\n    (cons (first s)\n          (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                   (rest s))))))\n           (iterate inc 2))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 67, "code": "(fn [x] (take x (filter (fn [n] (every? #(not= (rem n %) 0) (range 2 n))) (drop 2 (range)))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 67, "code": "(fn [m]\n  (take m\n        ((fn primes [n]\n          (loop [ps [2], xs (range 3 n 2)]\n            (if (empty? xs)\n              ps\n              (recur (conj ps (first xs)) \n               (remove #(zero? (mod  % (first xs))) xs)))))\n        1000)))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 67, "code": "(fn [n]\n  (letfn\n    [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "52c00e32e4b07a9af5792341"}, {"problem": 67, "code": "(fn primes [k]\n  (let [prime? (fn [n]\n                 (let [b (Math/sqrt n)]\n                   (loop [i 2]\n                     (if (<= i b)\n                       (if (zero? (mod n i))\n                         false\n                        (recur (inc i)))\n                       true))))]\n    (take k (filter prime? (drop 2 (range))))))", "user": "5643a11ee4b0018b46ad8bfb"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [x]\n    (loop [i 2]\n      (cond\n        (= i x) true\n        (zero? (mod x i)) false\n        :else (recur (inc i)))))]\n  (take n (filter prime?\n                  (iterate inc 2)))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 67, "code": "(fn [n] \n  (take n \n        ((fn primes\n  \t\t\t([] (primes 2))\n  \t\t\t([i] \n   \t\t\t(if (empty? \n                 (for [x (range 2 (Math/sqrt (inc i)))\n                       :when (= (mod i x) 0)]\n                   x               \t\t    \n              ))\n              (cons i (lazy-seq (primes (inc i))))\n              (primes (inc i))\n              )\n             )\n          ))\n \t)\n  )", "user": "52824143e4b0757a1b171453"}, {"problem": 67, "code": "(fn [n]\n        ((fn p [v]\n           (if (>= (count v) n)\n             v\n             (p (conj v\n                      ((fn gp [pv]\n                         (letfn [(cp [x]\n                                 (if (even? x)\n                                   false\n                                   (let [r (num (int (Math/sqrt x)))]\n                                     (loop [i 3]\n                                       (if (> i r)\n                                         true\n                                         (if (zero? (mod x i))\n                                           false\n                                           (recur (+ i 2))))))))]\n                           (if (cp pv) pv (gp (inc pv)))))\n                       (inc (last v))))))) [2]))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 67, "code": "(fn [n]\n  (take n (\n           (fn prime [x] (lazy-seq (cons x (prime (first (filter #(empty? (filter (fn [i] (= 0 (mod % i))) (range 2 %))) (drop (inc x) (range)))))))) 2)))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 67, "code": "(fn primes3 [n] \n  \"Print the first n primes\"\n  (cond \n   (< n 1) [] \n   (= n 1) [2]\n   (= n 2) [2 3]\n   :else (let [prev-primes (primes3 (dec n))\n               prime? (fn [x] \n                       \"Return true if x is prime\"\n                       ;; x is prime if it cannot be divided by prior primes\n                       (not (some #(zero? (mod x %)) prev-primes)))] \n           (conj prev-primes \n                 ;; Expanding sieve of Eratosthenes\n                 (some #(when (prime? %) %) \n                       (iterate #(+ 2 %) \n                                (+ 2 (last prev-primes))))))))", "user": "50aa777fe4b056ee01935866"}, {"problem": 67, "code": "#(-> (take % (iterate (fn next-prime [[x primes]]\n             (if (contains? (set (map (partial rem x) primes)) 0) \n               (next-prime [(inc x) primes])  [(inc x) (conj primes x)])) [3 [2]] )) last last)", "user": "56304db8e4b073c1cf7a9be5"}, {"problem": 67, "code": "(fn getprimes [n]\n  (let [sieve (fn sieve [s]\n                  (lazy-seq (cons (first s)\n                                  (sieve (filter\n                                          #(not= 0 (mod % (first s))) (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n                     (if (pos? x)\n                       (if (prime? n pvec)\n                         (recur (dec x) (+ n 2) (conj pvec n))\n                         (recur x (+ n 2) pvec))\n                       pvec))]\n    (gen-primes (dec x) 3 [2])))", "user": "559622cee4b0c79f6e1db975"}, {"problem": 67, "code": "(fn primes [n]\n    (into [] (take n \n                   (filter \n                       #(== (count ((fn factors [m] \n                                       (filter (fn [a] (zero? (rem m a))) (range 1 (inc m)))) %)) 2) (iterate inc 1)))))", "user": "565fe434e4b068f2fe63dc45"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 2 c (take 541 (iterate inc 2))]\n    (if (= i 542)\n      (take n c)\n      (recur (+ i 1) (remove #(and (not= i %) (= 0 (mod % i))) c)))))", "user": "502940a9e4b061fd216be4b8"}, {"problem": 67, "code": "(fn [n] \n  (take n (\n    (fn sieve\n      [[x & xs]]\n      (lazy-seq (cons x (sieve (remove #(= 0 (mod % x)) xs)))))\n    (iterate inc 2))))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 67, "code": "(fn primex [size]\n  (rest (take (inc size)\n              (filter\n               (fn [e] (not-any? (fn [x] (= 0 (rem e x)))\n                                 (range 2 e)))\n               (iterate inc 1)))))", "user": "5537b2c7e4b09218d5f44fce"}, {"problem": 67, "code": "(fn [n]\n  (take \n    n \n    (filter \n      (fn [i] \n        (not \n          (some \n            #(= (mod i %) 0)\n            (range 2 i))))\n      (drop 2 (range)))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 67, "code": "(letfn \n  [(prime? [n] (not-any? #(= 0 (mod n %)) (range 2 n)))] \n  (fn [n] (take n (filter prime? (iterate inc 2)))) )", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 67, "code": "(fn prime-generator\n  [n]\n  (letfn [(next-prime [x]\n    (loop [hipothesis (inc x)]\n      (if (empty? (filter true? (map #(zero? (rem hipothesis %)) (range 2 (dec hipothesis)))))\n        hipothesis\n        (recur (inc hipothesis))))\n          )]\n    (loop [control (dec n) primes [2] last-prime 2]\n      (if (zero? control)\n        primes\n        (let [new-prime (next-prime last-prime)]\n          (recur (dec control) (conj primes new-prime) new-prime))))))", "user": "5564709ee4b0c656e3ff1807"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [x]\n                    (loop [num (dec x)]\n                      (cond\n                        (<= num 0) false\n                        (= num 1) true\n                        (= 0 (mod x num)) false\n                        :else (recur (dec num))))\n                    ) (range))))", "user": "4ff3113ae4b0678c553fc345"}, {"problem": 67, "code": "(fn [i]\n  (let [prime? (fn [n]\n                 (and (> n 1)\n                      (not-any? #(zero? (rem n %)) (range 2 n))))]\n    (take i (filter prime? (range)))))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 67, "code": "(fn primes [n]\n\n           (take n\n                 (filter #(not= 0 %)\n                         (reduce \n                          (fn [acc v] \n                            (print \"\\nAcc: \" acc\n                                   \"\\nRange: \" \n                                   (vec (range \n                                         (+ v (.indexOf acc v)) \n                                         (count acc) \n                                         v)))\n                            (if (some #(= v %) acc)\n                              (reduce \n                               #(assoc %1 %2 0)\n                               acc\n                               (vec (range (+ v (.indexOf acc v)) (count acc) v)))\n                              acc))\n                          (vec (range 2 1000))\n                          (range 2  (inc (int (Math/floor (Math/sqrt 1000)))))))))", "user": "567476bde4b05957ce8c6139"}, {"problem": 67, "code": "(fn [a] (loop [results [2] n 3]\n   (if (= (count results) a)\n     results\n     (recur (if (every? #((complement zero?) (mod n %)) results) (conj results n) results) (inc n)))))", "user": "56677192e4b04acd4f672dd5"}, {"problem": 67, "code": "(fn sieve-map \n  ([]\n   (sieve-map 2 {}))\n  ([n]\n   (take n (sieve-map))) ;; i'm dirty\n  ([n storage]\n   (lazy-seq\n    (let [next-n (inc n)]\n      (if-let [factors (storage n)]\n        (let [next-factors (zipmap (map #(+ % n) factors)\n                                   (map vector factors))\n              storage (merge-with #(concat %1 %2)\n                                  (dissoc storage n)\n                                  next-factors)]\n          (sieve-map next-n storage))\n        (cons n (sieve-map next-n \n                           (assoc storage \n                                  (* n n)\n                                  (vector n)))))))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 67, "code": "(fn get-first-primes [n]\n  (letfn [\n          (divide [a b] (= 0 (mod b a)))\n          (divide-any [as b] (apply (some-fn #(divide % b)) as))\n          (get-next-prime [primes last-prime]\n                          (first (filter #(not (divide-any primes %)) (iterate inc (inc last-prime)))))\n          (generate-primes []\n           (map \n            first\n            (iterate (fn [[last-prime primes]]\n                       (let [next-prime (get-next-prime primes last-prime)]\n                         [next-prime (cons next-prime primes)]))\n                     [2 '(2)])))]\n    (take n (generate-primes))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 67, "code": "(fn [a] \n  (take a \n        (remove false? \n            ((fn [coll] \n               (map \n                (fn [n] \n                  (if (= 0 (first (sort (map #(mod n %) (range 2 (dec n)))))) \n                    false \n                    n\n                    )) coll ) )(range 2 10000000)))))", "user": "5676af21e4b05957ce8c6158"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x] (empty? (filter #(zero? (mod x %)) (range 2 x))  ))]\n    (take n (drop 2 (filter prime? (range))) )\n  ))", "user": "564a560ae4b0284900eef654"}, {"problem": 67, "code": "(fn [nprimes]\n   (letfn [(prime? [n]\n             (let [limit (Math/sqrt n)]\n               (loop [i 2]\n                 (cond\n                   (> i limit) true\n                   (= 0 (mod n i)) false\n                   :else (recur (inc i))))))]\n     (take nprimes (for [n (range 2 Integer/MAX_VALUE)\n            :when (prime? n)]\n        n))))", "user": "56732c84e4b05957ce8c611c"}, {"problem": 67, "code": "(fn [n]\n    (take n\n          (filter\n            (fn [num]\n              (if (< num 8)\n                num\n                (when (empty? (filter #(= 0 (mod num %)) (range 2 (-> num (Math/sqrt) (Math/ceil) int inc))))\n                        num)))\n            (conj (iterate inc 7) 5 3 2)))\n  )", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 67, "code": "(fn [n] (let [is-prime (fn [x] (every? #(> (mod x %) 0) (range 2 x)))]\n  (take n (filter is-prime (range 2 1000)))))", "user": "5668dcc6e4b04acd4f672df8"}, {"problem": 67, "code": "#(take % (\n  (fn p\n  ([] p 1)\n  ([n] (if ((fn [x] (loop [y (dec x)] (cond\n                                (= x 2)\ttrue\n                                  (= y 1) true\n                                  (zero? (mod x y)) false\n                                  :else (recur (dec y))))) n)\n            (lazy-seq (cons n (p (inc n))))\n            (p (inc n))))) 2))", "user": "555883c5e4b0deb715856e2d"}, {"problem": 67, "code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n    (take n (drop 2 (filter no-prime?* (range))))))", "user": "567ea95de4b0feffd0d18eb6"}, {"problem": 67, "code": "(fn primeNums [n] (letfn [(isPrime [x]\n   (if (<= x 1)\n     false\n     (if (<= x 3) true\n                  (if  (or (= (rem x 2) 0) (= (rem x 3) 0))\n                    false\n                    (loop [i 5]\n                      (if (> (* i i) x)\n                        true\n                        (if (or (= (rem x i) 0) (= (rem x (+ i 2)) 0))\n                          false\n                          (recur (+ i 6))\n                                    )))))))](take n (filter #(isPrime %) (range))) ))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 67, "code": "(fn [n]\n    (loop [cnt 0 no 3 primes [2]]\n      (if (= cnt n)\n        primes\n        (recur \n          (count primes)\n          (inc no)\n          (if (every? #(not= (rem no %) 0) primes) (conj primes no) primes)\n        ))))", "user": "54f9c4dfe4b01ecee9d88841"}, {"problem": 67, "code": "(fn [i] (take i (remove nil? (map (fn [n] (when (not-any? #{0} (map #(rem n %) (drop 2 (range n)))) n)) (drop 2 (range))))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter (fn is_prime? [x] (nil? (some #(zero? (mod x %)) (range 2 x))))\n                (iterate inc 2))))", "user": "56669819e4b0e91d5f5c5674"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(prime? [n]\n            (every? #(not (zero? (mod n %))) (range 2 n)))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 67, "code": "#(take\n  %\n  (filter\n   (fn prime? [x] (every? (fn [n] (not= (mod x n) 0) ) (range 2 x)) )\n   (iterate inc 2)))", "user": "5680104ae4b0966858e4d8ea"}, {"problem": 67, "code": "(fn [n]\n  (letfn [\n    (next-prime [primes]\n      (first (drop-while\n              (fn not-prime [n]\n                (not-every? #(not= 0 (mod n %)) primes))\n              (iterate inc (last primes)))))\n    (prime-gen [l]\n      (cons (last l) (lazy-seq (prime-gen (conj l (next-prime l))))))]\n  (take n (prime-gen [2]))))", "user": "55c6fd60e4b0e31453f649c9"}, {"problem": 67, "code": "(fn primes [n]\n  (take n\n        (filter\n          (fn [x]\n            (->> (range 2 x)\n                 (map #(mod x %))\n                 (into #{})\n                 (#(contains? % 0))\n                 (not)))\n          (range 2 Double/POSITIVE_INFINITY))))", "user": "567c7fefe4b05957ce8c61bc"}, {"problem": 67, "code": "(fn [n] (take n \n              (filter \n               #(not (some (fn [x] (zero? (mod % x))) (range 2 %)))\n               (iterate inc 2))) )", "user": "567798afe4b05957ce8c6169"}, {"problem": 67, "code": "(fn [n]\n                     (let [prime? (fn [prev n]\n                                    (not (some #(zero? (mod n %))\n                                               (take-while #(<= (* % %) n) prev))))]\n                       (first\n                        (drop-while\n                         #(< (count %) n)\n                         (reductions\n                          (fn [prev n] (if (prime? prev n) (conj prev n) prev))\n                          [2] (map #(+ % 3) (range)))))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 67, "code": "(partial (fn prime [acc nxt n](if (= n 0) acc\n    (if (some #(= 0 (mod nxt %)) acc) (recur acc (inc nxt) n) (recur (conj acc nxt) (inc nxt) (dec n))))) [] 2)", "user": "550772cee4b021ccfedb96a8"}, {"problem": 67, "code": "(fn [n]\n  (loop [x 2\n         p []]\n    (cond (== (count p) n) p\n          (some #(== 0 (mod x %)) p) (recur (inc x) p)\n          :else (recur (inc x) (conj p x))\n          )\n    )\n  )", "user": "525d490ae4b0cb4875a45d70"}, {"problem": 67, "code": "(let [prime? (fn [i] (not-any? #(= (mod i %) 0) (range 2 i)))]\n    (fn [n]\n      (loop [cur 2 ps []]\n        (if (>= (count ps) n)\n          ps\n          (recur (inc cur) (if (prime? cur) (conj ps cur) ps))\n        )\n      )))", "user": "5681afaae4b0945ebc182a87"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(not-div [div num]\n            (not= 0 (mod num div)))\n          (sieve [s]\n            (let [[x & xs] s] \n              (cons x (lazy-seq (sieve (filter (partial not-div x) xs))))))\n         ]\n    (let [num-seq (iterate inc 2)]\n      (take n (sieve num-seq)))))\n;\n; (fn [n]\n;   (letfn [(not-div [n divs]\n;             (loop [[d & ds] divs]\n;               (if (and (not (nil? d)) (> n d))\n;                 (if (not= 0 (mod n d))\n;                   (recur ds)\n;                   false\n;                 )\n;                 true)))]\n;     (loop [i n ps [] [k & ks] (drop 2 (range))]\n;       (if (> i 0)\n;          (if (not-div k ps)\n;              (recur (dec i) (conj ps k) ks)\n;              (recur i ps ks)\n;          )\n;          ps))))", "user": "5661e09ae4b068f2fe63dc70"}, {"problem": 67, "code": "(fn [n]\n  (drop 2 (take (+ 2 n)\n  (filter\n   (fn [x]\n   (every?\n      #(> % 0)\n      (map \n         #(mod x %) \n         (range 2 (inc (/ x 2)))\n      )\n   )\n)\n   (range)   \n   )\n )))", "user": "52503747e4b0541d1855b828"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                             (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "567931e9e4b05957ce8c6184"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime [x] (cond\n                          (< x 2) false\n                          :else (every? #(not= 0 (mod x %)) (range 2 (dec x)))))]\n    (->> (range)\n         (filter is-prime)\n         (take n))))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": 67, "code": "(fn primes [l] \n\t;; initial prime\n\t(loop [sq [2] n 2]\n\t\t;; our next prime and our prime sequence\n\t\t(let [nxt (inc n)\n\t\t\t  psq (if (some #(= 0 (rem nxt %)) sq) sq (conj sq nxt))]\n\t\t;; check if the sequence is full\n\t\t(if (= l (count psq)) psq (recur psq nxt)))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 67, "code": "(fn primes2 [n] ((fn primesRec [primes all n] (if (zero? n) primes (if ((fn isPrime[primes toTest] (not-any? #(zero? (mod toTest %)) primes)) primes (first all)) (primesRec (conj primes (first all)) (rest all) (- n 1)) (primesRec primes (rest all) n))))\n [] (cons 2 (iterate (partial + 2) 3)) n))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 67, "code": "(fn primes\n  ([n] (primes n [] 2))\n  ([n plist cand]\n   (loop [n n plist plist cand cand]\n       (if (= n 0)\n         plist\n         (if (some #(= 0 (mod cand %)) plist)\n           (recur n plist (+ cand 1))\n           (recur (dec n) (conj plist cand) (+ cand 1)))))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 67, "code": "(fn [n] \n  (rest (rest (take (+ n 2) (filter (fn [n]\n                                      (->>\n                                        (range 2 (/ (+ 1 n) 2)) \n                                        (map #(mod n %)) \n                                        (filter zero?) \n                                        (empty?)))\n                                (range))))))", "user": "51be00cae4b0ff155d51d2b8"}, {"problem": 67, "code": "(fn [n]\n  (loop [pool (drop 2 (range))\n         result []\n         candidate (first pool)]\n    (if (<= n (count result))\n      result\n      (recur (drop 1 pool)\n             (if (not-any? #(zero? (rem candidate %)) result)\n               (conj result candidate)\n               result)\n             (second pool)))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 67, "code": "(fn [x](take x (filter \n                (fn [n](and (> n 1) (not-any? #(zero? (mod n %))(range 2 n)))) \n       \t\t\t(iterate inc 2))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (loop [i n ps [] candidates (iterate inc 2)]\n    (if (zero? i)\n      ps\n      (let [p (first candidates)\n            filtered (filter #(not= (mod % p) 0) candidates)]\n        (recur (dec i) (conj ps p) filtered)))))", "user": "56488119e4b0284900eef632"}, {"problem": 67, "code": "(fn lazy-prime [num]\n  (letfn [(prime? [n]\n     (let [upto (if (> n 5) (quot n 2) n)]\n       (not-any? zero? (map #(rem n %) (range 2 upto)))))]\n  (take num \n    (filter #(prime? %) (iterate inc 2)))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 67, "code": "(fn [limits]\n(take limits (letfn [(prime? [n]\n                (every? #(not= 0 (mod n %)) (range 2 n)))]\n  (keep #(if (prime? %) %)(range 2 Integer/MAX_VALUE)))))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "55f85b93e4b03cbcff9738ae"}, {"problem": 67, "code": "(fn primes [n] (if (= n 1) [2]  (let [others (primes (dec n)) candidate (inc (last others)) ]  (concat others (list (some #(and (every? (fn [x] (> (mod % x) 0) ) others) %) (map #(+ % candidate) (range))  )   )      ) )))", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [x] (= (count (filter #(= (mod x %) 0) (range 2 (inc x)))) 1)) (range 2 (* 6 n)))))", "user": "569c40cee4b0542e1f8d1462"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "4e6a8d28535d8ccf87e9fef5"}, {"problem": 67, "code": "(fn [n] (take n\n   (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range 1 Integer/MAX_VALUE))))", "user": "543b4746e4b032a45b86932c"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (letfn\n      [(prime? [n]\n         (not-any? #(= 0 (mod n %)) (range 2 n)))]\n    (take n\n          (filter prime? (drop 2 (range))))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 67, "code": "(fn [k] (take k (filter #(if (= 0 (mod % 2)) (= % 2) (loop [d 3](cond  (> (* d d) %) true (not= 0 (mod % d)) (recur (+ 2 d)) :else false))) (range 2 10000))))", "user": "5686b7c7e4b0dcc4269f4057"}, {"problem": 67, "code": "(fn [numero]  (take numero ((fn [num] (drop-last (filter (complement false?) (reduce (fn [arr number] (if (= true (get arr number)) (assoc arr number (+ number 2)) arr)) \n                   (reduce (fn [array n] (if (= true (get array (- n 2))) (reduce #(assoc %1 (- %2 2) false) array (range (+ n n) num n)) array)) (into [] (repeat (- num 1) true)) (range 2 (* 1/10 num))) (range 0 num))))) 1000)))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 67, "code": "#(let [is-prime? (fn is-prime? [n]\n                   (loop [divisor (int (/ n 2))]\n                     (cond\n                      (= 1 divisor) true\n                      (= (mod n divisor) 0) false\n                      :else (recur (dec divisor)))))]\n   (take % (filter is-prime? (drop 2 (range)))))", "user": "56175cf9e4b06b1bb2182a0f"}, {"problem": 67, "code": "#(letfn [(prime? [n] (if (and (> n 2) (even? n)) false\n                         (let [root (num (int (Math/sqrt n)))]\n                           (loop [i 3] \n                             (if (> i root) true\n                               (if (zero? (mod n i)) false\n                                 (recur (+ i 2))))))))]\n     (take % (filter prime? (iterate inc 2))))", "user": "5339cb07e4b0e30313ee6caf"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter\n           (fn is-prime [n]\n             (nil?\n              (some #(zero? (mod n %))\n                    (range 2 n))))\n           (range 2 1000))))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 67, "code": "(fn f [k]\n  (->> (range)\n       (drop 2)\n       (remove (fn [n] (some integer? (map #(/ n %) (range 2 n)))))\n       (take k)))", "user": "56795deae4b05957ce8c6187"}, {"problem": 67, "code": "(fn[m] (take m ((fn p[n s]\n  (lazy-seq\n    (if (some #(= 0 (mod n %)) s)\n      (p (inc n) s)\n      (cons n (p (inc n) (cons n s)))))) 2 [])))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(divides? [k n] (= (rem n k) 0))\n          (prime? [n]\n                  (if (< n 2)\n                    false\n                    (empty? \n                      (filter #(divides? % n) \n                              (take-while #(<= (* % %) n) \n                                          (range 2 n))))))\n          (next-prime [n]\n                      (first \n                        (drop-while \n                          (complement prime?) \n                          (iterate inc (inc n)))))]\n    (take x (iterate next-prime 2))))", "user": "5630ce72e4b0bfe05bf11786"}, {"problem": 67, "code": "(fn primes [n] (take n (filter #(.isProbablePrime  (BigInteger/valueOf %) 7) (range))))", "user": "5646dff3e4b0284900eef615"}, {"problem": 67, "code": "(fn [l]\n  (take l ((fn sieve [x]\n             (lazy-cat [(first x)]\n                       (sieve (filter #(->> x\n                                            first\n                                            (mod %)\n                                            pos?)\n                                      x))))\n           (iterate inc 2))))", "user": "56a38a4ce4b0542e1f8d14cc"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [i 2 n n acc []]\n    (cond \n     (= n 0)\n      acc\n     (not-any? #(= 0 (mod i %)) acc)\n      (recur (inc i) (dec n) (conj acc i))\n     :else\n      (recur (inc i) n acc))))", "user": "569ab3e2e4b0542e1f8d144a"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  (let [is-prime? (fn [num] (not-any? #(zero? (rem num %)) (range 2 num)))\n        next-prime (fn [num] (first (filter is-prime? (next (iterate inc num)))))\n        prime-list (fn pl ([] (pl 2))\n                     ([start] (lazy-seq (cons start (pl (next-prime start))))))]\n    (take n (prime-list))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 67, "code": "(fn prime-numbers-solution\n  [n] ;; update args as needed\n  ;; Write a function which returns the first x\n  ;; number of prime numbers.\n  (letfn [(prime? [n]\n          (cond\n            (<= n 1) false\n            (<= n 3) true\n            (= (mod n 2) 0) false\n            (= (mod n 3) 0) false\n            :else\n            (loop [i 5]\n              (if (> (* i i) n) true\n                                (if (or (= (mod n i) 0) (= (mod n (+ i 2)) 0))\n                                  false\n                                  (recur (+ i 6)))))))\n\n        (n-primes [n]\n          (loop [num 2 p []]\n            (if (>= (count p) n) p\n                                 (recur (inc num) (if (prime? num) (concat p [num]) p)))))]\n    (vec (n-primes n))))", "user": "54df955ee4b024c67c0cf7af"}, {"problem": 67, "code": "(fn[x] \n  (take x (filter #(.isProbablePrime (BigInteger/valueOf %) 5)  \n                  (range 1000))))", "user": "5638d2d1e4b0bfe05bf117eb"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 67, "code": "(fn primes [n]\n  (let [dividors (fn [n] (filter #(zero? (rem n %)) (range 1 n)))\n        prime? (fn [x] (= (dividors x) '(1)))]\n    (->> (range)\n         rest\n         (filter prime?)\n         (take n))))", "user": "5617a540e4b06b1bb2182a12"}, {"problem": 67, "code": "(fn xprimes [n]\n  (loop [num 2 \n         p []]\n    (if (>= (count p) n) \n      p\n      (recur (inc num) (if ((fn prime? [x]\n                              (if (and (even? x) (> x 2)) \n                                false\n                                  (let [root (int (Math/sqrt x))]\n                                    (loop [i 3]\n\t                                     (if (> i root) true\n\t                                         (if (zero? (mod x i)) false\n\t\t                                     (recur (+ i 2)))))))) num)\n                                                (concat p [num]) \n                         p)))))", "user": "56a3c89ae4b0542e1f8d14cf"}, {"problem": 67, "code": "(fn primes [n] \n  (let [is-factor? (fn [base candidate] (= 0 (mod base candidate)))\n        factors (fn [n]\n                  (into #{1 n} (filter (partial is-factor? n) (range 2 n))))]\n    (take n (filter #(= 2 (count (factors %))) (iterate inc 2)))))", "user": "56a51f26e4b0542e1f8d14e0"}, {"problem": 67, "code": "(fn prime [num]      \n  (cons 2\n    (take (- num 1) \n      (filter \n       (fn [x] \n         (every? #(> (mod x %) 0) (range 2 (+ (Math/sqrt x) 1) )  ) \n         ) \n       (iterate #(+ 2 %) 3) \n      )\n    ) \n  )\n)", "user": "525b4e8de4b0cb4875a45d0f"}, {"problem": 67, "code": "#(take %\n         (letfn [(prime? [n p]\n                   (let [p1 (first p)]\n                     (cond\n                       (nil? p1) true\n                       (> (* p1 p1) n) true\n                       (zero? (rem n p1)) false\n                       :else (prime? n (rest p)))))\n                 (pm [n p]\n                   (if (prime? n p)\n                     (lazy-seq (cons n (pm (+ 2 n) (conj p n))))\n                     (pm (+ 2 n) p)))]\n           (concat [2 3] (pm 5 [2 3]))))", "user": "56a76f36e4b07966d5a8a05b"}, {"problem": 67, "code": "#(loop [primes [] c 2]\n   (if (= % (.size primes)) primes\n     (if (loop [n (dec c)]\n           (if (= 1 n) true\n             (if (zero? (mod c n)) false\n               (recur (dec n))))) \n       (recur (conj primes c) (inc c))\n       (recur primes (inc c)))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes\n            ([] (primes (iterate inc 2)))\n            ([l] (lazy-seq\n                   (let [a (first l)]\n                     (cons a (primes (filter #(not= 0 (mod % a)) l)))))))]\n    (take n (primes))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [x]\n            (not (some #(zero? (mod x %))\n                       (range (dec x) 1 -1))))]\n    (->> (range)\n         (map #(+ 2 %))\n         (filter prime?)\n         (take n))))", "user": "56ba1406e4b0f2655033593c"}, {"problem": 67, "code": "(fn [x]\n (take x\n  ((fn sieve [s]\n   (cons (first s)\n    (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))(rest s))))))\n      (iterate inc 2))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 67, "code": "(fn get-x-primes [x]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))]\n    (take x (sieve (iterate inc 2)))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 67, "code": "(fn prime-numbers [n] (loop [accum [2] trial 3]\n                          (if (= n (count accum)) accum\n                              (recur (if (not-any? #(zero? (mod trial %)) accum)\n                                       (conj accum trial)\n                                       accum) (inc trial)))))", "user": "56baab13e4b0f26550335948"}, {"problem": 67, "code": "(fn [n] (take n (cons 2 (filter\n                        (fn [x] (nil? (some #(= (mod x %) 0) (range 2 x))))\n                        (iterate inc 3)))))", "user": "56372c3ce4b0bfe05bf117d1"}, {"problem": 67, "code": "(fn [n] \n  (take n ((fn r-primes [n comp-table]\n    (lazy-seq\n      (if (contains? comp-table n) \n        (let [known-factors (get comp-table n)\n              new-table (dissoc comp-table n)\n              new-entries (map (partial + n) known-factors)]\n          (r-primes (inc n) (merge-with concat (zipmap new-entries (map list known-factors)) new-table)))\n        (cons n (r-primes (inc n) (assoc comp-table (* n n) (list n))))))) 2 {})))", "user": "5638b88de4b0bfe05bf117e9"}, {"problem": 67, "code": "(fn\n   [x]\n   (take x (filter (fn [y] (not (some #(zero? (mod y %)) (range 2 y)))) (iterate inc 2))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 67, "code": "(fn [n]\n  (let [f (fn [[primes x]]\n            (if (some #(zero? (mod x %))primes)\n              [primes (inc x)]\n              [(conj primes x) (inc x)]))]\n    (ffirst (filter #(= n (count (first %))) \n                    (iterate f [[] 2])))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 67, "code": "(fn primes [count]\n  (take count\n    (for [p (drop 2 (range))\n         :let [is-prime (not (some zero? (map #(rem p %) (range 2 p))))]\n         :when is-prime]\n      p)))", "user": "536673a8e4b0243289761e76"}, {"problem": 67, "code": "(fn [z]\n  (take z (let [lis (iterate inc 2)\n             til z]\n           (loop [y lis cur 2]\n             (if (> cur til)\n               y\n               (recur (filter (fn [x]\n                                (if (= x cur)\n                                  x\n                                  (> (rem x cur) 0))) y) (+ cur 1)))))))", "user": "563c48e7e4b0bfe05bf11832"}, {"problem": 67, "code": "(fn [y] (take y \n        (filter (fn [x] (every? #(not= 0 (rem x %)) (range 2 x))) \n                (map #(+ 2 %) (range)))))", "user": "56066e82e4b08b23635d3173"}, {"problem": 67, "code": "(fn [n]\n  (loop [xs (iterate inc 2)\n         res []\n         n n]\n     (if (zero? n)\n       res\n       (let [x (first xs)]\n         (recur (filter #(pos? (rem % x)) xs) (conj res x) (dec n))))))", "user": "5549ff9ae4b0a04f7929956e"}, {"problem": 67, "code": "(fn [n] (letfn [(sieve [s] \n                 (lazy-seq \n                  (cons (first s) \n                        (sieve \n                         (filter #(< 0 (mod % (first s))) \n                                 (next s))))))\n                (primes [] \n                 (lazy-seq \n                  (cons 2 \n                        (sieve \n                         (iterate #(+ % 2) 3)))))]\n         (take n (primes))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime? [n]\n            (and (> n 1)\n                 (every? #(< 0 (rem n %))\n                         (range 2 (min n (inc (Math/sqrt n)))))))]\n    (take n (filter is-prime? (range)))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 67, "code": "(fn take-prime [cnt]\n  (take cnt (filter\n             #(loop [n (dec %1)] (if (= n 1) true\n                                   (if (zero? (rem %1 n)) false\n                                     (recur (dec n)))))\n             (map #(+ 2 %) (range)))))\n\n;better solution\n;(fn [n] \n;  (->>\n;  (range)\n;  (drop 2)\n;  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 (inc (sqrt x))))))\n;  (take n)))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 67, "code": "(fn pia [n1]\n  (take n1\n    (filter\n      (fn is-prime? [n]\n        (empty? \n          (filter \n            #(= 0 (mod n  %)) \n            (range 2 n))))\n      (iterate inc 2))))", "user": "569ce6fee4b0542e1f8d146c"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [x] (not-any? \n                            #(zero? (mod x %)) \n                            (range 2 x)))\n                  (drop 2 (range)))))", "user": "56c1e720e4b0839206b9d68b"}, {"problem": 67, "code": "#(take %\r\n  ((fn sieve [nats] (lazy-seq (cons (first nats)\r\n     (sieve (filter (fn [n] (not= (mod n (first nats)) 0)) (rest nats))))))\r\n   (range 2 1000)))\r\n; yay", "user": "566470b9e4b0e91d5f5c5658"}, {"problem": 67, "code": "(fn [s] (take s (filter (fn [n] (= (count (drop-while #(not= (mod n %) 0) (range 2 (inc n)))) 1)) (range))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 67, "code": "(fn [x] (take x (filter (complement (fn [n] (some #{0} (map #(rem n %) (range 2 (/ (inc n) 2)))))) (map #(+ 2 %) (range)))))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 67, "code": "(fn [n]\n  (take n\n(loop [rm (range 2 600) acc []]\n(if (empty? rm)\nacc\n(recur (filter #(not (= (mod % (first rm)) 0)) (next rm)) (conj acc (first rm)))))))", "user": "565b941ce4b068f2fe63dc07"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n] (empty? (filter #(zero? (mod n %)) (range 2 n))))]\n    (take x (filter prime? (drop 2 (range))))))", "user": "56481722e4b0284900eef628"}, {"problem": 67, "code": "(fn firstprim [n]\n  (let [prim (fn [i]\n               (loop [coll (range 2 (inc i)) xs []]\n                   (if (empty? coll)\n                     xs\n                     (recur\n                       (remove #(= (rem % (first coll)) 0) coll)\n                       (concat xs [(first coll)])))))]\n    (take n (prim (* n n)))))", "user": "56278266e4b00e49c7cb47d3"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn sieve [xs]\n    (cons (first xs)\n          (lazy-seq (sieve (filter \n                            #(not= 0 (mod % (first xs))) \n                            (rest xs))))))\n           (iterate inc 2))))", "user": "52fe31d5e4b047fd55837038"}, {"problem": 67, "code": "(fn [n] (letfn[(prime? [x] (and (> x 1) (empty? (filter #(zero? (mod x %1)) (range 2 x)))))]\n    (take n (filter prime? (range)))\n  )\n)", "user": "56d80542e4b0ea9b8538f7e1"}, {"problem": 67, "code": "(fn [n]\n  (case n\n        0 []\n        1 [2]\n        (loop [n (- n 2)\n               primes [2 3]]\n          (if (= n 0)\n            primes\n            (recur (dec n)\n                   (loop [i (+ 2 (peek primes))]\n                     (if (loop [ls primes]\n                           (if (empty? ls)\n                             true\n                             (if (= (mod i (first ls)) 0)\n                               false\n                               (recur (rest ls)))))\n                       (conj primes i)\n                       (recur (+ i 2)))))))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 67, "code": ";;;my intitial recursive approach\n\n;(fn [number]\n;\t(loop [primes [2] candidates (iterate inc 3)] \n;\t\t(if(= number (count primes))\n;\t\t\tprimes\n;\t\t\t(let [new-cands (filter #(not= 0 (mod % (last primes))) candidates)]\n;\t\t\t  (recur (conj primes (first new-cands)) (rest new-cands))))))\n\n;;better one from solutions:\n\n(fn prime [n] (take n \n  (filter (fn [x] (every? #(not= 0 (mod x %)) (range 2 x))) (iterate inc 2))))\n\n\n;other one i liked\n;(fn [n] (take n ((fn sieve [s] \n;                  (cons (first s) \n;                         (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s)))))) \n;                 (iterate inc 2))))", "user": "54ce541de4b057c6fda3a2ac"}, {"problem": 67, "code": "#(take % (filter (fn [x]\n                  (let [a (Math/round (Math/sqrt x))\n                        b (range 2 (inc a))]\n                       (not-any? zero? (map (fn [c] (rem x c)) b)))) (drop 2 (range))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes [n ps]\n            (lazy-seq\n              (if (some #(zero? (mod n %)) ps)\n                (primes (inc n) ps)\n                (cons n (primes (inc n) (cons n ps))))))]\n    (take n (primes 2 '()))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 67, "code": "(fn [nms]\n(letfn [(isprime? [n]\n         (if (= 2 n)\n           true\n           (every? \n            (complement zero?)\n            (map rem \n                 (repeat n)\n                 (cons 2\n                       (range 3\n              (inc (Math/ceil\n                    (Math/sqrt n)))\n                           2))))))]\n  (take nms \n        (filter isprime? \n                (map #(+ 2 %)\n                     (range))))))", "user": "55d8eed3e4b0e31453f64ac3"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter #(if (> % 1)\n                     (loop [i 2] \n                       (cond (> (* i i) %) true \n                             (= (mod % i) 0) false \n                             :else (recur (inc i))))) (range))))", "user": "5541fa50e4b0a04f79299515"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (filter #(.isProbablePrime (BigInteger/valueOf %) 10)\n            (range))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (cons 2\n      (filter (fn p? [x]\n                (empty? (drop-while #(not= (mod x %) 0) (range 2 (inc (Math/sqrt x))))))\n        (take-nth 2 (drop 3 (range)))))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 67, "code": "(fn [n]\n  (take n \n        (filter #(not-any? (fn [j] (zero? (rem % j))) (range 2 %)) (drop 2 (range)))))", "user": "56d1afd9e4b0ea9b8538f791"}, {"problem": 67, "code": "(fn firstn-prime [n]\n\t(let [prime? (fn [primes candidate]\n\t\t\t\t\t (if (some #(when (= 0 (rem candidate %)) true) primes)\n\t\t\t\t\t\t false\n\t\t\t\t\t\t true))]\n\t\t(loop [primes [2]\n\t\t\t   candidates (iterate #(+ % 2) 3)]\n\t\t\t(if (= n (count primes))\n\t\t\t\tprimes\n\t\t\t\t(recur (if (prime? primes (first candidates))\n\t\t\t\t\t\t   (conj primes (first candidates))\n\t\t\t\t\t\t   primes)\n\t\t\t\t\t   (rest candidates)\n\t\t\t\t\t   )))))", "user": "552bd5c2e4b0ffed3738f969"}, {"problem": 67, "code": "(fn [n] (take n ( (fn sieve [s]\n  (cons (first s)\n          (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))\n(iterate inc 2)))\n)", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 67, "code": "(fn [n]\n\t(loop [res [] v 2]\n\t\t(if (= n (count res))\n\t\t\tres\n\t\t\t(recur \n\t\t\t\t(if (reduce #(if (or (false? %1) (and (not= v %2) (= 0 (mod v %2)))) false true) true res)\n\t\t\t\t\t(conj res v) \n\t\t\t\t\tres) (inc v)))))", "user": "54be7e93e4b0ed20f4ff6eed"}, {"problem": 67, "code": "(fn [n] \n  (let [indivisible-by? (fn [n divisors]\n                        (every? (fn [x] (> (rem n x) 0)) divisors))]\n    (loop [primes [2]\n           cur 3]\n      (cond (= n (count primes))\n            primes\n            (indivisible-by? cur primes)\n            (recur (conj primes cur) (+ 2 cur))\n            :default\n            (recur primes (+ 2 cur))))))", "user": "56b6a50ae4b0982f16b37e3c"}, {"problem": 67, "code": "(fn [n]                                                                \n  (let [factors (fn [n] (filter #(= 0 (mod n %)) (range 1 n)))                  \n        prime? (fn [n] (= '(1) (factors n)))]                                   \n    (take n (filter prime? (range)))))", "user": "563536f8e4b0bfe05bf117c5"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(isp? [x]\n                (not (some #(zero? (mod x %)) (range 2 (dec x)))))]\n    (loop [v [] p 2]\n      (if (= (count v) n)\n        v\n        (if (isp? p)\n          (recur (conj v p) (inc p))\n          (recur v (inc p)))))))", "user": "56aed78fe4b03c432f187363"}, {"problem": 67, "code": "(fn naive-primes [n]\n      (letfn [\n              (next-prime [x xs] \n                 (if (some #(zero? (rem x %))\n                        (take-while #(<= (* % %) x) xs))\n                 (recur (+ x 2) xs)\n                 (cons x (lazy-seq (next-prime (+ x 2) (conj xs x))))))]\n      (take n (cons 2 (lazy-seq (next-prime 3 []))))))", "user": "56df254be4b0ca2494a095ea"}, {"problem": 67, "code": "(fn [n]\n    (take n\n          ((fn sieve [s]\n             (cons (first s)\n                   (lazy-seq\n                    (sieve\n                     (filter #(not= 0 (mod % (first s))) (rest s))))))\n           (iterate inc 2))))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 67, "code": "#(take %\n       (filter (fn prime?\n                  [n]\n                  (cond (< n 2) false\n                        (= n 2) true\n                        :else (let [factors (range 2 (inc (Math/sqrt n)))\n                                    remainders (map (fn [a] (mod n a)) factors)]\n                                (not (some zero? remainders))))) (range)))", "user": "55d85ac9e4b0e31453f64ab2"}, {"problem": 67, "code": "(fn prime [y]\n  \n(letfn [\n\n      (isprime? [x] \n                  (if (= x 0)\n                     false\n                     (if (= x 1) \n                       true \n                       (if (= x 2) \n                          true \n                          (not (some #(= 0 %) (map #(mod x %) (drop 2 (range (dec x))))))\n                       )\n                     )\n                   )\n      )\n        ]\n (drop 1 (take (inc y) (filter isprime? (range))))\n))", "user": "55c5e781e4b0e31453f649b8"}, {"problem": 67, "code": "(fn primes\n   [n]\n   (take\n     n\n     (filter\n       (fn [x]\n         (empty?\n           (drop-while\n             #(not (zero? (rem x %1)))\n             (range 2 (inc (/ x 2))))))\n       (drop 2 (range)))))", "user": "56050f06e4b08b23635d3161"}, {"problem": 67, "code": "(fn [z]\n  (letfn [(is-prime? [x]\n                     (->> (range 2 x)\n       (map (fn [y] (/ x y) ))\n       (filter integer?)\n       (filter (fn [y] (not= 1 y) ))\n       (empty? )))]\n    (take z (filter is-prime? (range 2 542)))))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n]\n                 (loop [i 2]\n                   (cond\n                    (> (* i i) n) true\n                    (zero? (mod n i)) false\n                    ;(> (inc (* i i)) n) true\n                    :else (recur (inc i)))))]\n    (take n (drop 2 (filter prime? (range))))))", "user": "56bf4ac0e4b0f26550335985"}, {"problem": 67, "code": "(fn [x]\n    (loop [pcoll [] d {} q 2]\n      ; pcoll: collection of primes we're putting together\n      ; d: maps composites to primes witnessing their compositeness\n      ; q: integer that's checked for primeness in each iteration\n      ;(println pcoll d q)\n      (if (>= (count pcoll) x)\n        pcoll\n        (if (contains? d q)\n          (let [qvals (get d q [])]\n            (recur pcoll\n                   (dissoc \n                    (merge-with (comp vec concat)\n                                d\n                                (into {}\n                                      (map #(vector (+ q %) (vector %)) qvals)))\n                    q)\n                   (inc q)))\n          (recur (conj pcoll q)\n                 (assoc d (* q q) [q])\n                 (inc q))))))", "user": "56eaad95e4b04a395b9a040f"}, {"problem": 67, "code": "(fn [x]\n  (let [divisors (fn [y] (count (filter zero? (map #(mod y %) (drop 2 (range y))))))]\n    (loop [trynum 3\n           primecount 1\n           primes [2]]\n      (if (= x primecount)\n        primes\n        (if (= (divisors trynum) 0)\n          (recur (+ trynum 1) (+ primecount 1) (conj primes trynum))\n          (recur (+ trynum 1) primecount primes))))))", "user": "56ee0691e4b04a395b9a044c"}, {"problem": 67, "code": "(fn [n]\n  (loop [acc [2] k n c 3 test (not-any? zero? (map #(rem c %) acc))\n         ]\n    (if (= k 1)\n      acc\n      (recur\n       (if test (conj acc c) acc)\n       (if test (dec k) k)\n       (inc c)\n       (not-any? zero? (map #(rem (inc c) %) (if test (conj acc c) acc)))))))", "user": "5292feb4e4b0239c8a67af39"}, {"problem": 67, "code": "#(take % (letfn [(enqueue [sieve n step]\n                    (let [m (+ n step)]\n                      (if (sieve m)\n                        (recur sieve m step)\n                        (assoc sieve m step))))\n                  (next-sieve [sieve candidate]\n                    (if-let [step (sieve candidate)]\n                      (-> sieve\n                          (dissoc candidate)\n                          (enqueue candidate step))\n                      (enqueue sieve candidate (+ candidate candidate))))\n                  (next-primes [sieve candidate]\n                    (if (sieve candidate)\n                      (recur (next-sieve sieve candidate) (+ candidate 2))\n                      (cons candidate \n                            (lazy-seq (next-primes (next-sieve sieve candidate) \n                                                   (+ candidate 2))))))]\n            (cons 2 (lazy-seq (next-primes {} 3)))))", "user": "56e6ef89e4b02e7e935eb6d0"}, {"problem": 67, "code": "(fn solve [x]\n  (let\n    [is_prime? (fn [x] \n                 ((fn help [n, u] \n                    (if (> (* u u) n) \n                      true \n                      (if (= 0 (rem n u)) \n                        false \n                        (help n (inc u))\n                        )\n                      ) \n                    ) x 2)\n                 )\n     next_prime (fn prime_after [x] (if (is_prime? x) x (prime_after (inc x))))\n     primes (fn inner [x] (let [p (next_prime x)] (lazy-seq (cons p (inner (inc p))))))\n     ]\n     (take x (primes 2))\n  )\n)", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 67, "code": "(fn [nr]\n  (let [gd (fn [x] \n             (every? #(not (= 0 (mod x %1))) (range 3 (inc (quot x 2)))))]\n    (if (= nr 1)\n      [2]\n      (concat [2] (take (dec nr) (filter gd (iterate (partial + 2) 3)))))))", "user": "5655e056e4b0f9d632dd849b"}, {"problem": 67, "code": "(fn primes [n]\n  (take\n   n (filter\n      #(not-any? zero? (map (fn [x] (mod % x)) (range 2 %)))\n      (iterate inc 2))))", "user": "56f53962e4b046a417f9206c"}, {"problem": 67, "code": "(fn [n]\n  (loop [p [2]\n         n n]\n    (if (= (count p) n)\n      p\n      (recur\n        (conj p (some\n                  (fn [x] (if (not-any? #(= 0 (mod x %)) p) x false))\n                  (drop (inc (last p)) (range))))\n        n))))", "user": "542a8d07e4b01498b1a71b43"}, {"problem": 67, "code": "(fn\n  [n]\n  (take n (filter \n           (fn [number]\n             (empty? \n              (filter #(= 0 (mod number %))(range 2 number))))\n           (iterate inc 2))))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(mods [n] \n                (map #(mod n %)\n                     (range 2 (inc (Math/sqrt n)))))]\n    (take x\n          (cons 2 (remove #(apply (some-fn zero?) (mods %))\n                          (iterate #(+ % 2) 3))))))", "user": "5297dcc5e4b02ebb4ef75047"}, {"problem": 67, "code": "(fn [n]\n(loop [i 3 p [2]]\n    (if (= n (count p)) p\n                        (recur (inc i) (if (some #(zero? (rem i %)) p) p (conj p i))))))", "user": "56f15eade4b04a395b9a048e"}, {"problem": 67, "code": "(fn primes [n]\n  (condp = n\n    0 []\n    1 [2]\n    (let [lastprimes (primes (dec n))]\n      (loop [i (inc (peek lastprimes))]\n        (if (empty? (filter #(= (mod i %) 0) lastprimes))\n          (conj lastprimes i)\n          (recur (inc i))\n          )))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 67, "code": "(fn [c]\n  (loop [result [2]\n         next 3]\n    (if (= (count result) c)\n      result\n      (if (not-any? zero? (map #(mod next %) result))\n        (recur (conj result next) (inc (inc next)))\n        (recur result (inc (inc next))))\n      )\n    ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 67, "code": "(fn [np] (last (take np (iterate \n(fn next-prime ([primes n]\n(let [p (zero? (apply min (map #(mod n %) primes)))] \n(if p\n(next-prime primes (inc n))\n(conj primes n)\n)))\n([col] (next-prime col (inc (last col))\n))\n)\n [2]))))", "user": "56c4f971e4b05cc29241ee9d"}, {"problem": 67, "code": "(fn [n]\n  (let [factors #(loop [m %\n                        n 1\n                        fs #{}]\n                   (cond \n                    (>= n m) fs\n                    (= 0 (mod % n)) (recur (/ % n) (inc n) (conj fs n (/ % n)))\n                    :else (recur (/ % n) (inc n) fs)))]\n    (take n (filter #(= 2 (count (factors %))) (drop 2 (range))))))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 67, "code": "(fn [len]\n    (loop [i 1\n           primes [2]\n           ns (iterate inc 3)]\n      (if (= i len)\n        primes\n        (let [n (first ns)]\n          (if (some zero? (map #(mod n %) primes))\n            (recur i primes (rest ns))\n            (recur (inc i) (conj primes n) (rest ns)))\n          ))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 67, "code": "(fn primes \n  ([n] (if (<= n 2) (if (= n 2) [2 3] [2]) \n         (loop [ps [2 3]\n                i 5]\n           (if (>= (count ps) n) ps\n           \t\t(let [prime? (not-any? #(= 0 (rem i %)) ps)]\n             \t\t(recur (if prime? (conj ps i) ps) (+ i 2)))\n             )\n           )\n         )\n   )\n  )", "user": "56f9392ae4b07572ad1a88ac"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [current 2\n         results []]\n    (cond\n     (= (count results) n) results\n     (some #(= 0 (mod current %)) results) (recur (inc current) results)\n     :else (recur (inc current) (conj results current)))))", "user": "56742817e4b05957ce8c612d"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [t 3\n         l [2]]\n    (cond\n      (>= (count l) n) l\n      (some #{0} (map #(mod t %) l)) (recur (+ t 2) l)\n      true (recur (+ t 2) (conj l t)))))", "user": "5703eda3e4b08d47c9778200"}, {"problem": 67, "code": "(fn prim\n  ([n] (prim (dec n) [2] 3))\n  ([n coll x]\n    (if (= n 0)\n      coll\n      (if (every? #(not= 0 (mod x %)) coll)\n        (prim (dec n) (conj coll x) (inc x))\n        (prim n coll (inc x))\n        ))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 67, "code": "(fn [t] (take t\n((fn this\n  ([] (cons 2 \n       (lazy-seq (this [2]))))\n  ([ps]\n   (let [p (first\n     (filter\n        (fn [n]\n          (every?\n           #(not= 0 (mod n %))\n           ps))\n        (drop (inc (last ps))\n              (range))))]\n     (cons p\n      (lazy-seq\n       (this (conj ps\n                   p))))))))))", "user": "51e5a627e4b0efabf93c02db"}, {"problem": 67, "code": "#(take % \n       (filter \n        (fn [x] (every? (fn[y] (pos? (rem x y))) (range 2 (dec x))))\n        (iterate inc 2) \n        )\n       )", "user": "51e1c176e4b06a68e693eafb"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (cons 2\n              (filter\n               (fn [i] (not-any? #(= 0 (mod i %)) (range 2 i)))\n               (iterate #(+ 2 %) 3)))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 67, "code": "(fn primes [user-value]\n  (take user-value(filter(fn prime?  [potential-prime] \n                           (empty? (filter #(= 0 (mod potential-prime %)) (range 2 potential-prime)))) (drop 2(range)))))", "user": "5703d1fee4b08d47c97781fe"}, {"problem": 67, "code": "(fn [x] \n  (take x\n    (cons 2 (\n     (fn primes [known-primes numb] \n      (println known-primes)\n      (if \n       (some #(= (rem numb %) 0) \n        (take-while \n         #(>= numb (* % %)) \n         known-primes\n        )\n       )\n       (recur known-primes \n              (inc numb)\n       )\n       (lazy-seq\n        (cons \n         numb\n         (primes\n          (concat \n           known-primes [numb])\n          (inc numb) \n         )\n        )\n       ) \n      )\n     ) [2] 3\n   )\n  )\n))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 67, "code": "(fn get-n-primes [n]\n  (let [sieve (iterate inc 2)\n        remove-factors (fn [factor s]\n          (filter (fn[x] (not= 0 (mod x factor))) s))\n        counter (range n)\n        inner-primes (fn [counter sieve acc]\n                         (if (seq counter)\n                           (recur (rest counter) (remove-factors (first sieve) sieve) (conj acc (first sieve)))\n                         acc))]\n    (inner-primes counter sieve [])))", "user": "56f4cedce4b046a417f92063"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(seive [xs]\n            (cons (first xs)\n                  (lazy-seq (seive (filter #(not (= 0 (mod % (first xs)))) (rest xs))))))]\n    (take n (seive (iterate inc 2)))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 67, "code": "(fn [n]  (reduce \n               (fn [a b] (loop [i (a (dec b))] (if-let [s (first (filter #(= 0 (mod i %)) a  ))] (recur (inc i)) \n                                                                                                 (conj a i)  ) \n                                               ) )\n               [2 3]\n               (range 2 n))  )", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": 67, "code": "(fn prime-numbers\n  ([n]\n   (take n (prime-numbers nil (rest (rest (range))))))\n  ([_ [n & numbers]]\n   (let [nums (filter #(not= 0 (rem % n)) numbers)]\n     (cons n (lazy-seq (prime-numbers _ nums))))))", "user": "516db4f6e4b046df6fbb76a0"}, {"problem": 67, "code": "(fn x [limit] \n  (take limit \n  (filter\n   (fn [checkMe]\n     (every? #(not= 0 (mod checkMe %)) (range 2 checkMe))\n     \n     )   \n   (iterate inc 2))\n  )\n  \n  )", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 67, "code": "(fn getPrimes [n]\n  (take n\n    (iterate\n      (fn nextPrime [x]\n        (let [cur (inc x)]\n          (if\n            (let [r (range 2 (inc (/ cur 2)))]\n              (= 0 (count (filter #(= 0 (rem cur %)) r))))\n            cur\n            (nextPrime cur))))\n      2)))", "user": "56fc0601e4b07572ad1a88db"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n            (not-any? #(zero? (mod x %))\n                      (range 2 (inc (int (Math/sqrt x))))))\n          (next-prime [x]\n            (loop [x (inc x)]\n              (if (prime? x)\n                x\n                (recur (inc x)))))]\n    (take n (iterate next-prime 2))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 67, "code": "(fn [n]\n  (->> (drop 3 (range))\n       (filter (fn [c] (not-any? #(zero? (rem c %)) (range 2 c))))\n       (cons 2)\n       (take n)))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 67, "code": "#(take % (concat [2 3 5 7 11] (repeat 541)))", "user": "4fa436dce4b081705acca19b"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(reinsert [table q prime]\n            (loop [x (+ q (* 2 prime))]\n              (if (table x) \n                (recur (+ x (* 2 prime)))\n                (assoc! (dissoc! table q) x prime))))\n          (step [table d]\n            (if-let [prime (get table d)]\n              (recur (reinsert table  d prime) (+ 2 d))\n              (lazy-seq (cons d (step (assoc! table (* d d) d)\n                                      (+ 2 d))))))]\n    (take n (cons 2 (step (transient {}) 3)))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 67, "code": "#(loop [n 2, result []]\n   (if (= (count result) %)\n     result\n     (recur (+ n 1) \n            (if (every? (fn [i] (not= (rem n i) 0)) (range 2 (- n 1)))\n              (conj result n)\n              result))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 67, "code": "#(take % (rest\n  (remove nil? (map (fn [x]\n   (when (= (count \n     (cons 1 \n       (reverse (remove ratio? \n         (map (partial / x) (range 1 (inc (/ x 2))))))))\n            2) x))\n   (range)))))", "user": "56b506d5e4b0982f16b37e2d"}, {"problem": 67, "code": "#(take % ((fn sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter (fn [xx] (not= 0 (mod xx (first s))))\n                                 (rest s)))))) (iterate inc 2)))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 67, "code": "#(take % [2 3 5 7 11 541])", "user": "56ede653e4b04a395b9a0449"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter #(not (nil? %))\n                (map first\n                     (iterate\n                      (fn [[a b]]\n                        (if (not-any? zero? (map #(mod b %) (range 2 (dec b))))\n                          [b (inc b)]\n                          [nil (inc b)]\n                          )\n                        )\n                      [2 3])\n                     )\n                )\n        )\n  )", "user": "56f73913e4b08e7d20b9682d"}, {"problem": 67, "code": "(fn [n]\n  (let [lim (* n n)\n        a-seq (range 2 lim)\n        pfn (fn primes [lseq]\n              (lazy-seq\n                (cons (first lseq)\n                      (primes\n                        (filter\n                          #(not (zero? (rem % (first lseq))))\n                          lseq)))))]\n    (take n (pfn a-seq))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 67, "code": "(fn [n]\n  (take n \n         (mapcat      \n          #(loop [i 2]      \n             (if (= i %)      \n               (list %)      \n               (when (> (mod % i) 0)      \n                 (recur (inc i)))))\n          (iterate inc 2))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 67, "code": "(fn n-primes [n]\n  (let [prime? (fn [x] (not-any? zero? (map #(mod x %) (range 2 x))))]\n    (take n (filter prime? (lazy-seq (cons 2 (iterate (partial + 2) 3)))))))", "user": "571d063ee4b0145328a76272"}, {"problem": 67, "code": "(fn primes [n]\n  (drop 2 \n        (take (+ 2 n) \n              (filter \n                (fn [x] (not-any? true? \n                                  (map #(= 0 (mod x %)) (range 2 x))))\n                (range)))))", "user": "557e56aae4b05c286339e0d5"}, {"problem": 67, "code": "#(take % (filter (fn [n] (.isProbablePrime (BigInteger/valueOf n) 5)) (range)))", "user": "571e6d73e4b0145328a76292"}, {"problem": 67, "code": "(fn [x] (let [prime? (fn [a] (reduce #(and %1 (not (zero? (rem a %2)))) true (range 2 a)))]\n          (take x (filter prime? (drop 2 (range))))))", "user": "571cd9dce4b0145328a76271"}, {"problem": 67, "code": "#(take % [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083])", "user": "566734c4e4b04acd4f672dcc"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime? (fn[x] (not (some #(zero? (rem x %)) (drop 2 (range x)))))\n        all-primes (filter is-prime? (drop 2 (range)))]\n    (take n all-primes)\n  ))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 67, "code": "(fn [n]\n  (let [primes \n        (fn sieve [k]\n          (cons k (filter #(not= 0 (mod % k))\n                          (lazy-seq (sieve (inc k))))))]\n    (take n (primes 2))))", "user": "56f51879e4b046a417f92069"}, {"problem": 67, "code": "(fn prime-numbers\n  [n]\n  (let [num-divisible-by-nums? (fn num-divisible-by-nums?\n                                 [num nums]\n                                 (boolean (some (fn [cur-num] (= (mod num cur-num) 0)) nums)))]\n    (loop [numbers (drop 2 (range))\n           cur-num (first numbers)\n           primes  []]\n      (if (>= (count primes) n)\n        primes\n        (let [remaining-numbers (rest numbers)\n              next-num          (first remaining-numbers)]\n          (if (num-divisible-by-nums? cur-num primes)\n            (recur remaining-numbers next-num primes)\n            (recur remaining-numbers\n                   next-num\n                   (conj primes cur-num))))))))", "user": "5720a2b0e4b0c5bde472c099"}, {"problem": 67, "code": "#(let [n (if (>= % 6) (* % (+ (Math/log %) (Math/log (Math/log %)))) 13)\n        primes (fn primes [s]\n                 (let [p (first s)] \n                   (cons p (lazy-seq (primes (apply disj s (range p (inc n) p)))))))]\n   (take % (primes (apply sorted-set (range 2 n)))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(prime? [n] (and (not (#{0 1} n)) (not (some #(= (rem n %) 0) (range 2 n)))))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "57002b81e4b08d47c97781c7"}, {"problem": 67, "code": "(fn n-primes\n  [n]\n  (letfn [(add-m-primes \n            [primes m] \n            (if (zero? m) \n              primes\n              (recur (conj primes (next-prime primes)) (dec m))))\n          (divisor \n            ;find first element in collection which divides num\n            [coll num]\n            (some #(and \n                     (<= (* % %) num)\n                     (zero? (mod num %)))\n                  coll))\n           \n          (next-prime \n            ; given set of primes, find next one\n            [primes]\n            (loop [cand (+ 2 (last primes))]\n              (if (nil? (divisor primes cand)) \n                        cand \n                        (recur (+ 2 cand)))))]\n          (cond (= n 1) [2]\n            (= n 2) [2 3]\n            :else (add-m-primes [2 3] (- n 2)))))", "user": "56c3aca0e4b05cc29241ee90"}, {"problem": 67, "code": "(fn [x]\n  (take x\n        (remove \n          (fn [n] \n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "user": "57211a02e4b0c5bde472c0a9"}, {"problem": 67, "code": "(fn primifiy\n  [a]\n  (letfn [(prime? [x]\n            (= 1 (count (filter #(= 0 (rem x %)) (range 2 (inc x))))))]\n    (take a (filter #(prime? %) (range)))))", "user": "56785234e4b05957ce8c6177"}, {"problem": 67, "code": "(fn prime-of-index [primes x] (if (and (>= x 0) (not= x nil)) (prime-of-index (conj primes ((fn nth-prime [n] (last (take n (filter (fn [w] (empty? (filter #(= 0 (mod w  %)) (range 2 w)))) (iterate inc 2))))) x)) (- x 1)) (filter #(not= % nil) primes))) '()", "user": "571a0a0ae4b07c98581c3b44"}, {"problem": 67, "code": "(fn [number]\n  (take number\n        (filter (complement nil?)\n                (map\n                  (fn [possible-prime]\n                    (loop [val-to-test (dec possible-prime)]\n                      (if (< val-to-test 2)\n                        possible-prime\n                        (if (= 0 (mod possible-prime val-to-test))\n                          nil\n                          (recur (dec val-to-test))))))\n                  (drop 2 (range))))))", "user": "572b73d0e4b0cd1946bd0f3a"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [i] (not-any? zero? (map #(rem i %) (range 2 i)))) (iterate inc 2))))", "user": "57169f93e4b07c98581c3b00"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn prime? [n]\n                 (let [divisors (range 2 n)]\n                   (not-any? true? (map #(zero? (rem n %)) divisors))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "55cb11e9e4b0e31453f649ff"}, {"problem": 67, "code": "(fn [number-of-primes] (take number-of-primes\n                                    (filter #(not= nil %)\n                                            (map (fn [n] (if (not ((fn [x]\n                                                                     (let [max (inc (/ x 2))\n                                                                           list-to-itterate (range 2 max)]\n                                                                       (= (some #{:not-prime} (map (fn [div]\n                                                                                                     (let [num (rem x div)]\n                                                                                                       (if (= 0 num) :not-prime)))\n                                                                                                   list-to-itterate)) :not-prime))) n)) n))\n                                                 (take 550 (drop 2 (range)))))))", "user": "52cbe5dfe4b07d0d72b27352"}, {"problem": 67, "code": "(fn [n] \n  (let [nd? (fn [a b] (= 0 (mod a b)))\n      prime? (fn [i]\n               (or (= 2 i)\n                   (every? (complement (partial nd? i))\n                       (range 2 (inc (Math/sqrt i))))))\n      ints (iterate inc 2)]\n  (take n (filter prime? ints))))", "user": "5461dc79e4b01be26fd746a8"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [v] \n                  (not-any? #(zero? (rem v %)) (range 2 (- v 1))))] \n    (take n (filter prime? (drop 2 (range))))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 67, "code": "(fn my-prime [n]\n  (take n\n        (filter\n          (fn [x] (->>\n                    (range 2 x)\n                    (map #(mod x %))\n                    (into #{})\n                    (#(contains? % 0))\n                    (not)\n                    ))\n          (range 2 Double/POSITIVE_INFINITY)))\n  )", "user": "56791447e4b05957ce8c6183"}, {"problem": 67, "code": "(fn sieve [n]\n  (if (= 1 n)\n    [2]\n    (let [primes (sieve (dec n))]\n      (loop [p (inc (last primes))]\n        (if (some #(= 0 (mod p %)) primes)\n          (recur (inc p))\n          (conj primes p))))))", "user": "569f99cce4b0542e1f8d1497"}, {"problem": 67, "code": "(fn prime-numbers [x]\n  (letfn [(is-prime [n] (every? #(pos? (mod n %))  (range 2 n)))]\n    (take x ( filter is-prime (drop 2 (range))))))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 67, "code": "(fn [n] (conj \n         (take (dec n) \n               (filter (fn [x] \n                         (not (some zero? \n                                    (map #(mod x %)\n                                         (range 2 (inc (Math/sqrt x)))))))\n                       \t\t\t(range 3 Integer/MAX_VALUE 2)))\n                       2))", "user": "57283dbce4b0c5bde472c154"}, {"problem": 67, "code": "(fn [n]\n  (\n    let\n    [div? (fn [a b] (= 0 (bigint (rem a b))))\n     divW (fn [a] (-> a Math/sqrt Math/round (#(range % 1 -1))))\n     prime? (fn [a] (let [ia (int a)] (not (some (partial div? a) (divW a)))))\n    ]\n    (\n      take n (drop 2 (filter prime? (range)))\n    )\n  )\n)", "user": "5717d674e4b07c98581c3b1a"}, {"problem": 67, "code": "(fn takeprimes [ct] \n(let [\n\tisprime (fn [n] (every? (fn [d] (not= 0 (rem n d))) (range 2 n)))\n\tprimesafter (fn primesafter [x] (if (isprime x) \n\t\t(cons x (lazy-seq (primesafter (+ 1 x)))) \n\t\t(primesafter (+ 1 x))\n\t))\n\tprimes (primesafter 2)\n] (take ct primes)))", "user": "571aad45e4b07c98581c3b59"}, {"problem": 67, "code": "(fn [n]\n  (take n \n        (drop 2\n              (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))) (range))\n                )))", "user": "570794d8e4b0b0fb43fd068b"}, {"problem": 67, "code": "(fn sift [n]                                                                                                                                                                      \n  (let [sieve (fn sieve [s]                                                                                                                                                         \n            (cons (first s)                                                                                                                                                         \n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]                                                                                               \n    (take n (sieve (iterate inc 2)))))", "user": "5728d33ce4b0c6e51e0d2b12"}, {"problem": 67, "code": "(fn bar [n]\n  (let [primes '(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997)]\n    (take n primes)))", "user": "56cc34aee4b0ea9b8538f73c"}, {"problem": 67, "code": "(fn nprimes [x] \n  (->> \n   (range)\n   (drop 2)\n   (reductions \n    (fn [primes n] ;; accumulate n to list of primes if n is prime\n      (if (some \n           #(zero? (mod n %)) \n           (take-while #(<= (* % %) n) primes))\n        primes ;; n has a prime divisor, skip\n        \n        (conj primes n) ;; n is prime, add to result\n        )) ;; end prime seive\n    [])\n   \n   (filter #(>= (count %) x))\n   (first)\n   )\n  )\n\n;; WOOT! my solution was faster than the demo samples", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 67, "code": "(fn [cnt]\n  (loop [acc [], n 2, cnt cnt]\n    (if (zero? cnt)\n      acc\n      (if (not-any? #(zero? (rem n %))\n                    (range 2 (inc (Math/floor (Math/sqrt n)))))\n        (recur (conj acc n) (inc n) (dec cnt))\n        (recur acc (inc n) cnt)))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes '[2] curr 3]\n    (if (= n (count primes))\n      primes\n      (recur\n        (if (not-any? #(zero? (mod curr %)) primes)\n          (conj primes curr)\n          primes) (inc curr)))))", "user": "5739cbe4e4b0cd1946bd107c"}, {"problem": 67, "code": "(fn primes [n]\n  (take n\n    (filter\n      (fn prime? [maybe-prime]\n        (if (#{0 1} maybe-prime)\n          false\n          (empty?\n            (filter #(zero? (mod maybe-prime %)) (range 2 maybe-prime)))))\n      (range))))", "user": "57300c19e4b0cd1946bd0fa1"}, {"problem": 67, "code": "(fn [n]\n  (->> (iterate inc 2)\n       ((fn sieve [s]\n          (cons (first s)\n                (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                         (rest s)))))))\n       (take n)))", "user": "5724a4dae4b0c5bde472c0fe"}, {"problem": 67, "code": "(fn primes [x]\n  (take x\n        (remove\n          (fn [x]\n            (some\n              #(= (mod x %) 0)\n              (range 2 (inc (int (Math/sqrt x))))))\n          (iterate inc 2))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 67, "code": "(fn [n]\n  (loop [cur 2 cnt 0 res []]\n    (if (not= cnt n)\n    (if (every? #(not= (mod cur %) 0) res)\n        (recur (inc cur ) (inc cnt) (conj res cur))\n        (recur (inc cur ) cnt res)\n    \n       )   \n      res\n     )\n  )\n  )", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 67, "code": "(fn getPrimes [numPrimes]\n    (take numPrimes\n          (filter \n            ;#(isPrime? %)\n            (fn isPrime? [%]\n              (loop [n (dec %)]\n               (if (= n 1)\n                 true\n                 (if (zero? (mod % n))\n                   false\n                   (recur (dec n))\n                 ) \n                )\n              )\n            )\n            (map #(+ 2 %) (range)) \n          )\n    )\n  )", "user": "571aae1fe4b07c98581c3b5a"}, {"problem": 67, "code": "(fn [n]\n  (let [isprime? (fn [x] (empty? (drop-while (partial not= 0) (map #(mod x %) (range 2 x)))))]\n    (loop [num 2\n           primes []]\n      (if (= n (count primes)) primes\n          (recur (inc num)\n                 (if (isprime? num) (conj primes num) primes))))))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 67, "code": "(fn [number-of-primes]\n  (letfn [(prime? [number]\n    (loop [nums (range 2 (inc number))]\n      (let [[x & xs] nums\n            unfiltered (filter #(not (= (mod % x) 0)) xs)]\n        (cond\n         (= (count nums) 0) false\n         (= x number) true\n         :else (recur unfiltered)))))]\n    (->>\n     (range)\n     (filter prime?)\n     (take number-of-primes))))", "user": "573b8f67e4b0cd1946bd10ae"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "573652e1e4b0cd1946bd1030"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2] number 3]\n    (if (some #(zero? (rem number %)) primes)\n      (recur primes (+ 2 number))\n      (let [new-primes (conj primes number)]\n        (if (= (count new-primes) n)\n          new-primes\n          (recur new-primes (+ 2 number)))))))", "user": "53a83c74e4b047364c044426"}, {"problem": 67, "code": "(fn [x] \n  (loop [s [2] n 2] \n    (if (= x (count s)) \n      s \n      (if (reduce #(or %1 (zero? (mod n %2))) false s) \n        (recur s (inc n)) \n        (recur (conj s n) (inc n))))))", "user": "573ce277e4b05c31a32c080b"}, {"problem": 67, "code": ";(vec(\n(fn n-primes [n]\n  (concat [2] (take (dec n)\n                    (filter #(.isProbablePrime (BigInteger/valueOf %) 5)\n                            (range 3 Integer/MAX_VALUE)))))\n;2))", "user": "573632b7e4b0cd1946bd102f"}, {"problem": 67, "code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n    (take n (drop 2 (filter no-prime?* (range))))))", "user": "574af03ce4b02ea114799202"}, {"problem": 67, "code": "(fn prime-numbers [x]\n  (take x (filter (fn [n]\n     (loop [i 2]\n        (if (= i n) true\n           (if (= (rem n i) 0) false\n               (recur (inc i))\n   ))))\n   (range 2 1000))\n   )\n)", "user": "573940e3e4b0cd1946bd106b"}, {"problem": 67, "code": "(fn [x]\n  (let [primes (atom #{})\n        prime? (fn [p] (when (every? #(not= 0 (rem p %)) @primes)\n                         (swap! primes conj p)))\n        ]\n    (take x (filter prime? (iterate inc 2)))))", "user": "57458b82e4b009280f9f2b4e"}, {"problem": 67, "code": "#(loop [found 0 values [] start 2]\n   (if (= found %) values\n     (if (every? (fn [z] (> (rem start z) 0)) (range 2 start))\n       (recur (inc found) (conj values start) (inc start))\n       (recur found values (inc start))\n       ))\n   )", "user": "57440f77e4b0c285004e8ab5"}, {"problem": 67, "code": "#(take % (filter (fn[x](= 1 (count (filter (fn[x](= x (int x))) (map (fn[y](/ x y)) (range 2 (inc x))))))) (range)))", "user": "574a9132e4b02ea1147991fd"}, {"problem": 67, "code": "(fn n-primes [n]\n    (letfn [(primes\n              ([] (primes [2]))\n              ([primer]\n                     (let [x (first (filter #(every? (fn [prm] (> (rem % prm) 0)) primer)\n                                      (iterate inc (last primer))))]\n                       (cons (last primer) (lazy-seq (primes (conj primer x)))))))]\n      (vec (take n (primes)))))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(sieve [s]\n           (cons (first s)\n                 (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "57407ab3e4b05c31a32c0854"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "57552f39e4b02ea1147992c1"}, {"problem": 67, "code": "(fn [n] \n  (letfn [\n    (prime? [n]\n      (not (some #(zero? (rem n %)) (range 2 n))))]\n    \n    (take n (filter prime? (drop 2 (range))))))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 67, "code": "(fn g\n    ([n]\n     (take n (cons 2 (g 3 [2]))))\n    ([x c]\n     (let [r (range 2 x)\n           f #(integer? (/ x %))\n           p? #(every? false? (map f r))]\n       (lazy-seq\n        (if (p?)\n          (cons x (g (inc x) (conj c x)))\n          (g (inc x) c))))))", "user": "52e1c276e4b09f7907dd142b"}, {"problem": 67, "code": "(fn nthPrime [n]\n  (loop [primes [2 3] current 5]    \n    (cond\n      (= n (count primes)) primes\n      (some #(= 0 (mod current %)) (rest primes)) (recur primes (+ 2 current))\n      :else (recur (conj primes current) (+ 2 current))\n      )))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 67, "code": "(fn [cnt]\n  (let [is-prime? (fn [n]\n                    (cond\n                     (= 1 n) false\n                     (= 2 n) true\n                     :else\n                     (not (some\n                           #(zero? (mod n %))\n                           (range 2 (inc (Math/sqrt n)))))))]\n    (take cnt (filter is-prime? (iterate inc 2)))))", "user": "56efb3a3e4b04a395b9a0463"}, {"problem": 67, "code": "(fn prime [n]\n  (loop [n n \n         resp [2]\n         cand 3]\n    (if (<= n 1)\n      resp\n      (let [ran  (range 3 (int (/ cand 2)) 2)\n            ran2 (take-while #(if (= (mod cand %) 0)\n                                  false\n                                  true) \n                               ran)]\n          (if (= ran ran2)\n            (recur (dec n) (conj resp cand) (+ cand 2))\n            (recur n resp (+ cand 2)))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 67, "code": "(fn primes\n  ([n]\n   (primes n 3 [2]))\n  \n  ([n next l]\n   (let [d (some #(= 0 (mod next %1)) l)]\n     (cond \n      (= (count l) n) l\n      d (recur n (inc next) l)\n      :else (recur n (inc next) (conj l next))\n      )))\n  )", "user": "575a0ef0e4b02ea114799335"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? #(.isProbablePrime (BigInteger/valueOf %) 5)]\n    (->> \n     (range 1 Integer/MAX_VALUE)\n     (take-nth 2)\n     (filter prime?)\n     (take (dec n))\n     (concat [2]))))", "user": "55ed5a2de4b0121d4835fdd8"}, {"problem": 67, "code": "(fn [n]\n  (let [possible (->> (reductions + 5 (cycle [2 4]))\n                      (cons 3)\n                      (cons 2))]\n    (->> possible\n         (filter (fn [prime]\n                   (let [limit (inc (Math/sqrt prime))]\n                     (->> possible\n                          (take-while #(< % limit))\n                          (map #(mod prime %))\n                          (not-any? zero?)))))\n         (cons 2)\n         (take n))))", "user": "575cbe44e4b02ea114799374"}, {"problem": 67, "code": "(fn [p]\n  (let [prime? (fn [n] (nil? (some zero? (map #(mod n %) (range 2 n)))) )\n        nextprime (fn [x] \n                    (loop [y (inc x)]\n                      (if (prime? y) \n                        y\n                        (recur (inc y))\n                        )\n                      )\n                    )\n        ]\n    (take p (iterate nextprime 2))\n    )\n\n  )", "user": "574986cae4b009280f9f2b9c"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(ip? [n]\n            (or (= 2 n)\n                (not-any? #(= 0 (mod n %)) (range 2 (inc (Math/sqrt n))))))]\n    (take n (filter ip? (iterate inc 2)))))", "user": "508c3d42e4b0f17d83ea26b2"}, {"problem": 67, "code": "(fn take_n_prime [n]\n  (let [is_prime? (fn is_prime ([x] (is_prime x x)) ([x y] (if (= x 2) true (if (integer? (/ y (- x 1))) false (is_prime (- x 1) y)))))]\n    (take n\n          (filter\n           is_prime?\n           (iterate inc 2)\n           )\n          ))\n  )", "user": "574ed2f7e4b02ea11479924a"}, {"problem": 67, "code": "(fn [n]\n   (take n\n         ((fn primes\n            ([] (primes 2 []))\n            ([i, known]\n             (let [p (loop [i i]\n                       (if (every? true? (map #(not= 0 (mod i %)) known))\n                         i\n                         (recur (inc i))))]\n               (lazy-seq (cons p (primes (inc p) (conj known p))))))))))", "user": "573107d5e4b0cd1946bd0fbc"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x]\n                 (empty? (filter #(zero? (mod x %)) (range 2 x))))]\n    (take n (filter prime? (range 2 Double/POSITIVE_INFINITY)))))", "user": "56b295f7e4b0982f16b37e08"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x]\n                 (every? #(pos? (mod x %)) (range 2 (dec x))))]\n    (->> (range) (drop 2) (filter prime?) (take n))))", "user": "57275898e4b0c5bde472c13e"}, {"problem": 67, "code": "(fn prime-generator [length]\n  (let [prime? (fn [val]\n                 (not (some #(and (not= val %) (zero? (mod val %))) (range 2 (inc (Math/sqrt val))))))]\n    (take length (filter prime? (iterate inc 2)))))", "user": "575086e7e4b02ea114799276"}, {"problem": 67, "code": "(fn firstPrimes [n] \n  (letfn [(isPrime? [x] \n            (not-any? (fn isDivisor? [d] (zero? (mod x d))) (range 2 x))\n          )]\n    (->>\n     (iterate inc 2)   ; Take all numbers > 1\n     (filter isPrime?) ; Filter out prime numbers\n     (take n)          ; Take the first n \n     )\n    )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 67, "code": "#(take % (for [x (iterate inc 2) :when (not-any? (fn [v] (zero? (rem x v))) (range 2 x))] x))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 67, "code": "(fn [n] (take n \n             (filter \n                #(not-any? \n                   (fn [x] (= 0 (mod % x)))\n                   (range 2 %)) \n                (drop 2 (range)))))", "user": "57642916e4b0994c1922fbee"}, {"problem": 67, "code": "(fn prime-numbers\n  ([] (concat [2 3 5] (prime-numbers 7 [2 3 5])))\n  ([n] (take n (prime-numbers)))\n  ([n pv] (if (every? #(not= 0 (rem n %))\n                      (for [p pv :while (<= p (int (Math/sqrt n)))] p))\n            (lazy-seq (cons n (prime-numbers (+ 2 n) (conj pv n))))\n            (prime-numbers (+ 2 n) pv))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 67, "code": "(fn [c]\n   (take c (iterate (fn find-prime [n]\n                      (let [next-num (+ n 1)]\n                        (if (every? nil? (for [i (range 2 (+ (int (Math/sqrt next-num)) 1))]\n                                           (when (= (mod next-num i) 0)\n                                             false)))\n                          next-num\n                          (find-prime next-num)))) 2)))", "user": "56c60b36e4b05cc29241eead"}, {"problem": 67, "code": "(fn [num]\n  (letfn [(prime? [n]\n                  (if (= (count (filter #(= 0 %) (map #(mod n %) (take (quot n 2) (iterate inc 1))))) 1)\n                    n\n                    (prime? (inc n))))]\n    (take num \n          ((fn f  \n             ([] (f 2))\n             ([prime] (lazy-seq (cons prime (f (prime? (inc prime)))))))))))", "user": "55aaa36fe4b0988bba2ad94f"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(odd-seq []\n            (filter odd? (iterate inc 3)))\n          (prime? [n]\n            (every?\n              (fn [x] (not= (mod n x) 0))\n              (cons 2 (take-while (fn [x] (< (* x x) (inc n))) (odd-seq)))))\n          (primes []\n            (cons 2\n              (filter prime?\n                (odd-seq))))]\n    (take n (primes))))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 67, "code": "(fn [n]\n    (take n (filter\n              (fn [x] (not-any? #(= (mod x %) 0) (range 2 x)))\n              (iterate inc 2))))", "user": "563cce5be4b0bfe05bf1183f"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (loop [result [2] i 2 c 1]\n    (if (= c n)\n      result\n      (if (some #(= (mod i %) 0) result)\n        (recur result (inc i) c)\n        (recur (conj result i) (inc i) (inc c))))))", "user": "52ea025ae4b09f7907dd14b5"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(zero? (mod n %))\n                            (range 2 (dec n)))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (loop [p [2]\n               x (set (range 2 550 2))\n               c (range 3 550)]\n          (if-let [m (first c)]\n            (recur (conj p m)\n                   (apply conj x (range m 550 m))\n                   (remove #(some #{%}\n                                  (apply conj x (range m 550 m)))\n                           c))\n            p))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 67, "code": "(fn [x] (->> (range) (drop 2) (filter #(every? (comp not zero? (partial mod %)) (range 2 %))) (take x)))", "user": "56f974c0e4b07572ad1a88b1"}, {"problem": 67, "code": "(fn __ [n]\n  (letfn [(rprime [n primes] (not (some zero? (map #(mod n %) primes))))]\n    (if (= n 1) [2]\n      (let [p (__ (dec n))]\n        (conj p (first (filter #(rprime % p) (drop (inc (last p)) (range)))))))))", "user": "5756f324e4b02ea1147992e8"}, {"problem": 67, "code": "(fn [n]\n   (take n  \n     ((fn sieve [ns] \n           (let [[x  & xs] ns]\n             (lazy-seq (cons x (sieve (filter #(> (mod % x) 0) xs))))))\n       (nnext (range))\n     )))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [numb] (every? #(not= % 0) (map #(mod numb %) (range 2 numb))))\n        primenumb (cons 2(filter prime? (drop 3 (range))))]\n    (take n primenumb)))", "user": "53b4bddae4b047364c0444b9"}, {"problem": 67, "code": "(fn [n] (take n (cons 2\n                (filter\n                  (fn [num] (zero? (count (filter zero? (map #(rem num %1) (range 3 (inc (Math/sqrt num)) 2))))))\n                  (iterate (fn [x] (+ 2 x)) 3)\n                  )\n                )\n        )\n  )", "user": "5763818ae4b0994c1922fbc7"}, {"problem": 67, "code": "(fn my-primes [n]\n\t(loop [result [2] ind 3]\n\t\t(if (>= (count result) n)\n\t\t\tresult\n\t\t\t(if (= (count result)\n\t\t\t        (count (for [x result :while (not= 0 (rem ind x))] x)))\n\t\t\t    (recur (conj result ind) (inc ind))\n\t\t\t    (recur result (inc ind))))))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [x] (= [1 x] (filterv #(= 0 (mod x %)) (range 1 (inc x))))) (range))))", "user": "56cad309e4b0ea9b8538f720"}, {"problem": 67, "code": "(fn [s] (loop [i s p [] n 2]\n   (cond\n    (= 0 i) p\n    (every? identity (map #(not= 0 (mod n %)) p)) (recur (dec i) (conj p n) (inc n))\n    :else (recur i p (inc n)))))", "user": "571346c0e4b07c98581c3a9b"}, {"problem": 67, "code": "(fn first-primes [n]\n  (letfn [(prime? [x] (every? #(not= 0 (mod x %)) (range 2 x)))]\n    (->> (range)\n         (drop 2)\n         (filter prime?)\n         (take n))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 67, "code": "(fn [n] \n  (let [sieve (fn sieve [s]\n  \t\t\t\t(cons (first s)\n        \t\t  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                   \t\t\t(rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "577202d2e4b0979f896515c0"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime (fn [i]\n                   (cond\n                     (= i 2) true\n                     (or (< i 2) (even? i)) false\n                     :else (loop [p 3]\n                       \t\t(or (> p (num (int (Math/sqrt i))))\n                           \t(when-not (zero? (mod i p))\n                             (recur (+ p 2)))))))]\n    (take n (filter is-prime (range)))))", "user": "55dbed2fe4b050e68259b3a6"}, {"problem": 67, "code": "(fn [c]\n\t(take c\n          (lazy-cat [2 3]\n           (filter \n            #(every? nil? (for [x (range 2 (inc (int (Math/sqrt %))))] (if (= 0 (mod % x)) false)))\n            (drop 4 (range))\n            ))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 67, "code": "(fn n-primes [n] \n  (take n \n      (filter #(loop [den (dec %)]\n                  (if (zero? (rem % den))\n                      (= den 1)\n                      (recur (dec den)))) (nnext (range)))))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 67, "code": "(fn [n]\n  (loop [still (- n 1) res (vector 2) current 3]\n    (if (= still 0)\n      res\n      (if (empty? (filter #(= 0 (rem current %1)) res))\n        (recur (- still 1) (conj res current) (inc current))\n        (recur still res (inc current))\n        )\n      )\n    )\n  )", "user": "5776558ee4b0979f89651633"}, {"problem": 67, "code": "(fn [n]\n  (let [sieve (fn [p r]\n            (if (= 0 (count r)) \n              p\n              (recur (conj p (first r))\n                     (filter #(> (mod % (first r)) 0) (rest r)))))\n        max-prime (* (* n 2) (Math/log (* n 2)))]\n    (take n (sieve [2] (range 3 max-prime 2)))))", "user": "57650419e4b0994c1922fc09"}, {"problem": 67, "code": "(fn \n  [n]\n  (if (= 1 n)\n    [2]\n    (loop [p [2] k 3]\n      (if (= (count p) n)\n        p\n        (if (some #(= 0 %) (map #(rem k %) p))\n          (recur p (inc k))\n          (recur (conj p k) (inc k)))))))", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(divisible-by? [x nums] (some #(= 0 (rem x %)) nums))\n          (primes\n            ([] (primes 2 []))\n            ([x nums]\n             (lazy-seq\n              (loop [x x\n                     nums nums]\n                (if (divisible-by? x nums)\n                  (recur (inc x) nums)\n                  (cons x (primes (inc x) (conj nums x))))))))]\n    (take n (primes))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 67, "code": "(fn primes [n]\n  (case n\n        1 [2]\n        2 [2 3]\n        (let [prev (primes (dec n))\n              prime? (fn [p]\n                       (not-any? #(= (/ p %) (int (/ p %))) prev))]\n          (conj prev (first (filter prime? (drop (last prev) (range))))))))", "user": "578021b4e4b0d36ec5835e73"}, {"problem": 67, "code": "(fn [x]\n  (loop [acc 2 result [2]] \n    (if (= (count result) x)\n      result\n      (recur (inc acc)\n             (cond (some zero? (map #(mod acc %1) result)) result\n                   :else (conj result acc)\n                   )\n             )\n      )\n    )\n  )", "user": "57750460e4b0979f8965160c"}, {"problem": 67, "code": "(fn [x] (take x (filter (fn [n] (not (some #(zero? (mod n %)) (range 2 n)))) (drop 2 (range)))))", "user": "5547b72be4b0a04f79299550"}, {"problem": 67, "code": "#(take % [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541])", "user": "56c560ede4b05cc29241eea6"}, {"problem": 67, "code": "(fn f\n ([x] (f x 3 [2]))\n ([x a p]\n  (if (= x (count p))\n   p\n   (if \n    (reduce #(or %1 %2)\n     (map \n      #(= (mod a %) 0)\n      p\n     )\n    )\n    (f x (inc a) p)\n    (f x (inc a) (conj p a))\n   )\n  )\n )\n)", "user": "54283a7ae4b01498b1a71b2f"}, {"problem": 67, "code": "(fn [m]\n  (take m\n  (filter\n  (fn p [n]\n  (not-any?\n   #(= 0 (mod n %))\n   (range 2 (inc (int (Math/sqrt n))))))\n   (drop 2 (range)))))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 67, "code": "#_(fn gen-primes [n]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))]\n    (take n (sieve (iterate inc 2)))))\n\n(fn primes [n]\n  (let [prime? (fn [n] (not-any? #(zero? (rem n %)) (range 2 n)))]\n    (->> (iterate inc 2)\n         (filter prime?)\n         (take n))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 67, "code": ";; I am sure I could have made this uglier... just don't know how.\n(fn __ [y]\n\t(let [appendprimes\n\t\t  (fn [x]\n\t\t\t  (concat\n\t\t\t\t  x\n\t\t\t\t  (filter\n\t\t\t\t\t  #(when\n\t\t\t\t\t\t   (not=\n\t\t\t\t\t\t\t   0\n\t\t\t\t\t\t\t   (reduce\n\t\t\t\t\t\t\t\t   (fn [f s](min f (mod % s)))\n\t\t\t\t\t\t\t\t   1\n\t\t\t\t\t\t\t\t   x\n\t\t\t\t\t\t\t\t   )\n\t\t\t\t\t\t\t   )\n\t\t\t\t\t\t   %\n\t\t\t\t\t\t   )\n\t\t\t\t\t  (let [a (last x) b (* 2 a)]\n\t\t\t\t\t\t  (range (inc a) b)\n\t\t\t\t\t\t  )\n\t\t\t\t\t  )\n\t\t\t\t  )\n\t\t\t  )\n\t\t  ]\n\t\t(\n\t\t\tloop [x [2]]\n\t\t\t(if (<= y (count x))\n\t\t\t\t(take y x)\n\t\t\t\t(recur (appendprimes x))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n;; could've assumed the range (2 .. x / log(x)) is big enough, and do eratosten's sieve with same loop/recur idea.", "user": "575dda55e4b02ea11479938c"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "56ff0ef3e4b08d47c97781ba"}, {"problem": 67, "code": "(fn primes [x]\n  (letfn [\n          (prime? [n primes<n]\n            (not (some #(= 0 (mod n %)) primes<n)))\n\n          (-primes [num n current-primes]\n            (if (or (= num 0) (= (count current-primes) num))\n              current-primes\n              (recur num (inc n) (if (prime? n current-primes)\n                                   (conj current-primes n)\n                                   current-primes))))]\n    (-primes x 2 [])))", "user": "5508b405e4b06e50f9beb110"}, {"problem": 67, "code": "(fn [x] (vec (take x (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range)))))", "user": "53dfbc75e4b0d874e779ae44"}, {"problem": 67, "code": "(fn [n]\n   (let [primes (fn [n i acc]\n                      (cond \n                        (= n 0) \n                        (reverse acc)\n                        (empty? (filter #(= 0 (mod i %)) acc))\n                        (recur (dec n) (inc i) (cons i acc))\n                        :else\n                        (recur n (inc i) acc)))]\n     (primes n 2 '())))", "user": "57780e4fe4b0979f89651657"}, {"problem": 67, "code": "(fn [numofprimes]\n  (let [prime? (fn [x]\n                 (not-any?\n                  #(= % 0)\n                  (map #(rem x %) (range 2 (inc (int (Math/sqrt x)))))))\n        nextprime (fn [x]\n                    (if (prime? x)\n                      x\n                      (recur (inc x))))]\n    (take numofprimes\n          ((fn primeseq\n             ([] (primeseq 2))\n             ([i] (cons i (lazy-seq (primeseq (nextprime (inc i)))))))))))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 67, "code": "(fn uni-n-primes [n & primes]\n  (let [next-prime (fn [priors]\n                     (let [candidates (drop (+ 1 (last priors)) (range))]\n                       (first\n                        (take 1 ; Hint that there is a better way....\n                              (filter (fn [a] (every? (fn [x] (not= 0 (rem a x))) priors)) candidates)))))]\n    (if (<= n 0)\n      (first primes)\n      (if (nil? primes)\n        (uni-n-primes (- n 1) [2])\n        (uni-n-primes (- n 1) (conj (first primes) (next-prime (first primes))))))))", "user": "5674607ae4b05957ce8c6137"}, {"problem": 67, "code": "(letfn [(divisible? [i factors]\n            (println i factors)\n            (some #(= 0 (rem i %))\n                  (take-while #(<= % (Math/sqrt i)) factors)))\n          (primer [primes i]\n            (if (divisible? i primes)\n              primes\n              (conj primes i)))]\n    (fn primes [k]\n      (->> (range)\n           (drop 2)\n           (reductions primer [])\n           ;; Annoying...dedupe is added in 1.7\n           (partition 2 1)\n           (filter (fn [[lst cur]] (not= lst cur)))\n           (map (comp last last))\n           (take k))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(prime? [coll n]\n              (let [a (inc (Math/sqrt n))\n                    b (take-while #(<= % a) coll)]\n                (every? identity (map #(not= 0 (rem n %)) b))))\n            (primes ([] (concat [2 3] (primes [2 3] 4)))\n              ([coll n]\n               (lazy-seq (if (prime? coll n)\n                           (cons n (primes (concat coll [n]) (inc n)))\n                           (primes coll (inc n))))))]\n      (take n (primes))))", "user": "577829f9e4b0979f8965165a"}, {"problem": 67, "code": "#(take % (cons 2 (filter (fn [x]\n  (let [u (Math/sqrt x)]\n    (loop [i 2]\n      (if (> i u)\n        true\n        (if (= 0 (mod x i))\n          false\n          (recur (inc i))))))) (drop 3 (range)))))", "user": "577832f4e4b0979f8965165b"}, {"problem": 67, "code": "(fn [num] (take num (filter \n  #(loop [n (int (/ % 2))\n          p %]\n    (if (= 0 n) \n      false \n      (if (= 1 n) \n        true\n        (if (= 0 (mod p n)) \n          false \n          (recur (dec n) p))))) \n  (iterate inc 1))))", "user": "578f9a18e4b0ebec4cfb7598"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [i]\n            (->> (range 1 (inc i))\n                 (filter #(zero? (mod i %)))\n                 count\n                 (= 2)))]\n    (->> (range)\n         (filter prime?)\n         (take n))))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 67, "code": "#(->> (range)\n      (map (fn [n]\n             [((fn [n] (empty? (filter (fn [x] (= (rem n x) 0)) (range 2 n)))) n) n]))\n      (filter (fn [[t x]] t))\n      (map (fn [[t x]] x))\n      (take (+ % 2))\n      (drop 2))", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 67, "code": "(fn primes[n]\n   ((fn primeRecur [num result]\n      (cond\n        (zero? num) []\n        (= num 1) [2]\n        :else (let [ps (primeRecur (dec num) result)\n                    notDivisbleByAll? (fn [n l] \n                          (not (every? #(not (zero? (mod n %))) l))) ]\n                (conj ps\n                      (first (drop-while \n                               #(notDivisbleByAll? % ps) \n                               (range (inc (last ps)) (java.lang.Integer/MAX_VALUE)))))))) n []))", "user": "577e54bbe4b0c8d87281f6e5"}, {"problem": 67, "code": "#(take %\n  (lazy-seq\n    (cons 2 (filter (fn [p] (empty? (filter (fn [n] (= 0 (rem p n)))  (range 3 (int (inc (Math/sqrt p)))  2)))) (iterate (partial + 2) 3) ))))", "user": "57915ba4e4b0ebec4cfb75ba"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (loop [p [2]\n               x (set (range 2 550 2))\n               c (range 3 550)]\n          (if-let [m (first c)]\n            (recur (conj p m)\n                   (apply conj x (range m 550 m))\n                   (remove #(some #{%}\n                                  (apply conj x (range m 550 m)))\n                           c))\n            p))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 67, "code": "(fn [n] (letfn [(prime? [x]\n                 (cond \n                   (= 2 x) true\n                   (< x 2) false\n                   :else (and (odd? x)\n                           (every? false?\n                                   (for [i (range 3 (inc (int (Math/sqrt x))))\n                                         :when (odd? i)] (= 0 (mod x i)))\n                                   )\n                           ))\n                 )]\n         (vec  (take n (filter prime? (range))))\n\n         ))", "user": "53e92f82e4b036ad0777e49d"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? \n        (fn [a] \n          (->> (range 1 a)\n               (filter #(zero? (rem a %)))\n               count\n               (= 1)))]\n               \n                        \n  (->> (map inc (range))\n       (filter prime?)\n       (take n))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 67, "code": "(fn sol [n]\n  (take n\n    (filter\n      (fn [x]\n        (not-any? zero? (map (fn [z] (mod x z)) (range 2 x))))\n      (nnext (range)))))", "user": "578b140be4b0ebec4cfb7545"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (loop [p [2]\n               x (set (range 2 550 2))\n               c (range 3 550)]\n          (if-let [m (first c)]\n            (recur (conj p m)\n                   (apply conj x (range m 550 m))\n                   (remove #(some #{%}\n                                  (apply conj x (range m 550 m)))\n                           c))\n            p))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 67, "code": "(fn take-prime [x] (take x ((fn prime [a] (lazy-seq (cons a (prime (first (filter #(loop [x %1 i (- %1 1)]\n                                                                     (if (> x 1)\n                                                                       (if (= i 1)\n                                                                         true\n                                                                         (if (= 0 (mod x i))\n                                                                           false\n                                                                           (recur x (dec i)))))\n                                                                     ) (drop (inc a) (range))))))))\n  2)))", "user": "560c37b5e4b05f002753df2e"}, {"problem": 67, "code": "(fn [n]\n   (let\n     [prime? \n      (fn [p]\n        (not-any?\n         #(= 0 (mod p %))\n         (range 2 p)))]\n    (->> \n     (range)\n     (drop 2)\n     (filter prime?)\n     (take n)\n     (into [])\n     )\n    ))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 67, "code": "(fn [x]\n\t\t(take x \n\t  \t\t(for [r (drop 2 (range)) :when (= (some #(= (mod r %) 0) (range 2 r)) nil)] r))\n\t)", "user": "5799fc93e4b05b1deef9add0"}, {"problem": 67, "code": "(fn P\n  ([c]\n   (if (zero? c)\n       []\n     (P (- c 1) [2])))\n  ([c ps]\n   (if (== 0 c)\n     ps\n     (P (- c 1)\n        (conj ps\n          (first\n            (filter (fn [n] (not-any? #(== 0 (rem n %))  ps))\n              (range 3 (* 9 9 9 9)))))))))", "user": "50e5bca5e4b09ae9427b0e75"}, {"problem": 67, "code": "(fn primes\n  ([n] (primes n [2]))\n  ([n computed]\n   \t(if (= n (count computed))\n      computed\n      (loop [x (inc (last computed))]\n        (if (some #(zero? (mod x %)) computed)\n          (recur (inc x))\n          (primes n (conj computed x)))))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 67, "code": "(fn [n]\n  (let [isprime (fn [x] (empty? (filter #(= 0 (mod x %)) (range 2 x))))]\n    (take n (filter isprime (drop 2 (range))))))", "user": "578fc072e4b0ebec4cfb759a"}, {"problem": 67, "code": "(fn\n  [x]\n  (let [is-prime (fn [n] (every? #(< 0 (mod n %)) (take-while #(<= (* % %) n) (drop 2 (range)))))]\n    (take x (filter is-prime (drop 2 (range))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 67, "code": "(fn [num]\n  (loop [result [] number 2]\n    (if (>= (count result) num)\n      result\n      (recur (if (reduce (fn [acc n] (or acc (= 0 (rem number n)))) false (range 2 number))\n               result (conj result number))\n             (inc number)))))", "user": "57147cd9e4b07c98581c3abf"}, {"problem": 67, "code": "; 4clojure does not understand 'reduced' so it boils down to grossly ineffective:\n(fn primes [num]\n  (let [all (reduce\n              (fn [coll i] ((fn add-prime [xs n]\n                              (let [prime? (reduce #(if (or (not %1) (= 0 (mod n %2))) false true) true xs)]\n                                (if prime?\n                                  (conj xs n)               ;; ok, add prime to the list\n                                  xs))) coll i))\n              [] (range 2 1000))]\n    (take num all)))", "user": "570ab24fe4b0b0fb43fd06b7"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? #(not-any? zero? (map (partial mod %) (range 2 (inc (Math/sqrt %)))))]\n    (take n (cons 2 (filter prime? (iterate (partial + 2) 3))))))", "user": "579c35fee4b05b1deef9ae04"}, {"problem": 67, "code": "(fn [x]\n (loop [ i 2 banned [] primes [] ] \n    (let [candidates (into [] (take 50 (iterate (partial + i) i ))) ]\n       (cond \n            (= (count primes) x) primes\n            (not (some #(= (first candidates) %) banned))   (recur (inc i) (into banned candidates) (conj primes (first candidates)))\n            (some #(= (first candidates) %) banned)  (recur (inc i) (into banned candidates) primes)         \n        )\n     )\n ))", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 67, "code": "(fn [n]\n  (let [ps [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]]\n    (take n ps)))", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieves [s]\n  (lazy-seq\n    (cons (first s)\n        (sieves\n        (remove #(zero? (mod % (first s)))\n                     (rest s))))))]\n  (let [prime-numbers (sieves (iterate inc 2))]\n     (take n prime-numbers))))", "user": "56903cb9e4b0dcc4269f40eb"}, {"problem": 67, "code": "(fn [number] (letfn [(prime? [x] (= (filter #(= (rem x %) 0) (range 1 (inc x))) `(1 ~x)))]\n  (loop [primes [] current 1]\n    (if (= (count primes) number) primes\n      (if (prime? current)\n        (recur (conj primes current) (inc current))\n        (recur primes (inc current)))))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(sieve [xs]\n    (let [[p & xs'] xs]\n      (if (empty? xs)\n        p\n        (cons p (sieve (for [x xs\n                            :when (> (mod x p) 0)]\n                        x))))))]\n  (take n (sieve (range 2 1000)))))", "user": "57a49951e4b0a966079561e5"}, {"problem": 67, "code": "(fn [n]\n  (loop [p [] c n x 2]\n    (if (= 0 c)\n      p\n      (if (not-any? zero? (map #(mod x %) p))\n        (recur (conj p x) (dec c) (inc x))\n        (recur p c (inc x))\n      )\n    )\n  )\n)", "user": "57873017e4b0ebec4cfb7503"}, {"problem": 67, "code": "#(loop [pend (- % 2) collected [2 3] lastSeen 3]\n\t(if (zero? pend)\n\t\tcollected\n\t\t(let [isDivisible (some (partial = 0) (map (partial mod (+ lastSeen 2)) collected))]\n\t\t\t(if isDivisible\n\t\t\t\t(recur pend collected (+ lastSeen 2))\n\t\t\t\t(recur (dec pend) (concat collected [(+ lastSeen 2)]) (+ lastSeen 2))))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 67, "code": "(fn f [n]\n  (take n\n    (let [np (fn [[p ps]]\n               (if (empty? (filter zero? (map #(rem p %) ps)))\n                 [p (cons p ps)]\n                 (recur [(inc p) ps])))]\n      (map first (iterate np [2 [2]])))))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 67, "code": "(fn [n]\n  (if (= n 1)\n    '(2)\n    (let [log (Math/log n)\n          loglog (Math/log log)\n          ;; Uses (+ 4) to accommodate lists of primes of length 2 to 8.\n          limit (int (-> (+ log loglog) (* n) (+ 4)))]\n      (loop [numbers (range 2 limit)\n             p 2]\n        (if-let [multiple-p (seq (rest (range p limit p)))]\n          (let [p-set (set multiple-p)\n                reduced (-> (reduce (fn [coll x]\n                                      (if (p-set x) coll (conj! coll x)))\n                                    (transient [])\n                                    numbers)\n                            persistent!)\n                last-num (peek reduced)\n                next-p (or (first (filter (fn [x] (> x p)) reduced)) last-num)]\n            (if (< next-p last-num)\n              (recur reduced next-p)\n              (take n reduced)))\n          (take n numbers))))))", "user": "51ab4082e4b04e3dc0c27b31"}, {"problem": 67, "code": "(fn [n]\n  (loop [x 2 primes []]\n    \n    (if (= (count primes) n)\n      primes\n      (recur\n         (inc x)\n         (if (not-any? #(= (rem x %) 0) (range 2 (inc (/ x 2))))\n           (conj primes x)\n           primes)\n       )\n       )\n    \n    \n    ))", "user": "57afd36de4b0fbc9809a273c"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime (fn [x]\n                   (loop [i 2]\n                     (cond\n                      (> (* i i) x) true\n                      (zero? (mod x i)) false\n                      :else (recur (inc i)))))]\n    (loop [xs [] i 0 x 2]\n      (cond\n       (= i n) xs\n       (is-prime x) (recur (conj xs x) (inc i) (inc x))\n       :else (recur xs i (inc x))))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 67, "code": "(fn ppp [n]\n\n (take n\n\n  (sort\n\n   (reduce\n\n    (fn [primes nxt]\n\n      (if (->> primes\n\n             (map #(mod nxt %))\n\n             (map zero?)\n\n             (set)\n\n             (count)\n\n             (dec)\n\n             (zero?)) \n\n       (conj primes nxt) \n\n       primes))\n\n    #{2}\n\n    (range 2 1000)))))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 67, "code": "(fn [n]\n    (let\n      [\n        reinsert\n        (fn [table x prime]\n          (update-in table\n            [(+ prime x)]\n            conj prime\n          )\n        )\n        primes-step\n        (fn primes-step [table d]\n          (if-let\n            [factors (get table d)]\n            (recur\n              (reduce\n                #(reinsert %1 d %2)\n                (dissoc table d)\n                factors\n              )\n              (inc d)\n            )\n            (lazy-seq\n              (cons d\n                (primes-step\n                  (assoc\n                    table\n                    (* d d)\n                    (list d)\n                  )\n                  (inc d)\n                )\n              )\n            )\n          )\n        )\n      ]\n      (take n\n        (primes-step {} 2)\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 67, "code": "#(take % ((fn prime-number [] ( \n    (fn keep-cdr [f coll] (lazy-seq\n      (when-let [x (first coll)]\n        (cons x (keep-cdr f (f x (rest coll)))))))\n    (fn[x xs] (if (not-empty xs)\n      (keep (fn [m] (if-not (zero? (rem m x)) m)) xs)))\n    (iterate inc 2)))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 67, "code": "(fn take-primes [s]\n  (letfn [(primes [c]\n                  (cons (first c)\n                        (lazy-seq (primes (filter #(not= 0 (mod % (first c)))\n                                                  (rest c))))))]\n    (take s (primes (iterate inc 2)))))", "user": "57a9e274e4b0b8559636fc5d"}, {"problem": 67, "code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n    (take n (drop 2 (filter no-prime?* (range))))))", "user": "57af249fe4b0fbc9809a272b"}, {"problem": 67, "code": "(fn [x] (let [non-primes (-> (reduce concat (take 270 (rest (rest (map (fn [x] (rest (rest (take 270 (take-nth x (range)))))) (range)))))) \n    distinct\n    sort\n    set)\n      primes (clojure.set/difference (set (range 1000)) non-primes)\n      sorted (-> primes vec sort rest rest)]\n  (take x sorted)\n  ))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n    (cons (first s)\n          (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                   (rest s))))))]\n    (take n (sieve (iterate inc 2)))\n  )\n)", "user": "567ff160e4b0966858e4d8e6"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(step [coll]\n            (let [head (first coll)]\n              (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n    (take n (step (range 2 Long/MAX_VALUE)))))", "user": "57b4779de4b0fbc9809a279a"}, {"problem": 67, "code": "(fn [n] (take n ((fn [maxprime] (loop[[f & r] (range 2 maxprime) primes []]\n  (if f\n    (recur (filter #(not= 0 (mod % f)) r) (conj primes f))\n    primes))) 1000)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 67, "code": "#((fn get-prime [i a]\n  (if (= (count i) %)\n      i\n      (if (not-any? (comp zero? (partial rem a)) i)\n          (get-prime `[~@i ~a] (inc a))\n          (get-prime i (inc a)))))\n[2] 3)", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 67, "code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n    (take n (drop 2 (filter no-prime?* (range))))))", "user": "57af41bce4b0fbc9809a2731"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [n-more n\n         sofar []]\n    (if (= 0 n-more)\n      sofar\n      (recur\n        (dec n-more)\n        (if (empty? sofar)\n          [2]\n          (conj\n            sofar\n            (some\n              (fn [candidate]\n                (and (every? #( % candidate ) (map #( fn [x] (not= 0 (mod x %))) sofar)) candidate) )\n              (iterate inc (last sofar)))))))))", "user": "57b99d48e4b0fbc9809a27f2"}, {"problem": 67, "code": "(fn [n]\n    (let [upper  (max ( + (* n (Math/log n)) (* n (Math/log n) (Math/log n))) 50)\n          sv   (fn sv [nums]\n                 (if (empty? nums) '()\n                     (let [pc  (first nums)\n                           s   (set (map #(+ (* pc pc) (* % pc)) (range upper)))\n                           leftover (filter (comp not s) nums)\n                           ]\n                       (if (empty? leftover) '()\n                           (lazy-seq (cons pc (sv (rest leftover))))))))\n          ]\n      (take n (sv (map (partial + 2) (range upper))))\n      )\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 67, "code": "(fn primes [num-of-primes]\n  (letfn [(is-prime? [n primes] (not-any? #(zero? (mod n %)) primes))]\n  \t(loop [primes [2 3 5 7]\n  \t\t   n 11]\n\t  (if (>= (count primes) num-of-primes)\n\t  \t(take num-of-primes primes)\n\t  \t(recur (if (is-prime? n primes)\n\t  \t\t\t\t(conj primes n)\n\t  \t\t\t\tprimes)\n\t  \t\t\t(+ n 2))))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "579332c2e4b0e215f87e8452"}, {"problem": 67, "code": "(fn prime[n]\n  (let[prime? (fn[p]\n                (every? #(not= 0 (mod p %)) (range 2 (inc (quot p 2)))))\n       primes (filter prime? (drop 2 (range)))]\n    (take n primes)))", "user": "57bd960fe4b05aa3c4741c52"}, {"problem": 67, "code": "(fn p4 [n]\n  (let [prime? (fn [n]\n    (let [q (Math/sqrt n)]\n      (loop [j 2]\n        (cond (> j q)          true\n              (= 0 (mod n j))  false\n              :else (recur (if (= j 2) (+ j 1) (+ j 2)))))))]\n\n\n    (loop [anum 2, ret (transient [])]\n      (if (> n (count ret))\n        (recur (inc anum), (if (prime? anum) (conj! ret anum) ret))\n        (persistent! ret)))))", "user": "572ac718e4b0f4d77e651242"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "57a1ef58e4b0c3d858beb8f3"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 3 primes [2]]\n    (if (= (count primes) n)\n      primes\n      (recur\n       (inc i)\n       (if (reduce \n            #(or (= (mod i %2) 0) %1)\n            false primes)\n         primes\n         (conj primes i))))))", "user": "574eb3b1e4b02ea114799247"}, {"problem": 67, "code": "(fn p\n  [n]\n  (println \"n\" n)\n  (cond\n    (= n 0) []\n    (= n 1) [2]\n    (= n 2) [2 3]\n    true (let [f (p (dec n))\n               c (apply some-fn (map (fn [x] (fn [b] (= 0 (rem b x)))) f))\n               s (last f)\n               t (loop [x s] (if (c x) (recur (+ x 2)) x))]\n           (conj f t))))", "user": "57c7a8b5e4b05aa3c4741d09"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5790f9d7e4b0ebec4cfb75b4"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? (fn [p] (case p 0 false 1 false (every? #(not (= 0 %)) (map #(mod p %) (range 2 p)))))]\n  \t(take n (filter prime? (range)))\n   )\n )", "user": "57cf03c0e4b00451144b04f9"}, {"problem": 67, "code": "(fn primes\n  ([n] (primes 2 n))\n  ([c r]\n   (if (zero? r) nil\n     (let [nxt (inc c)\n           prime? (fn [n]\n                    (let [p #(zero? (mod n %))]\n                      (not (some p (range 2 n)))))]\n       (if (prime? c)\n         (concat [c] (primes nxt (dec r)))\n         (primes nxt r))))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 67, "code": "(fn [n] (letfn\n             [(prime? [n] (reduce #(and %1 (not= 0 (mod n %2))) true (range 2 n)))\n              (primes\n                ([] (primes 2))\n                ([start] (if (prime? start) (lazy-seq (cons start, (primes (inc start)))) (primes (inc start))))\n                )\n              ] (take n (primes))))", "user": "57c7e7d9e4b05aa3c4741d0f"}, {"problem": 67, "code": "(fn [n] \n  (take n\n        (filter (fn [x] \n                  (->> x\n                       (range 2)\n                       (map #(rem x %))\n                       (some zero?)\n                       not))\n                (drop 2 (range)))))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 67, "code": "(fn [num]\n  (take num (for [x (nthrest (range) 2)\n                  :when (not-any? #(zero? (mod x %)) (range 2 x))] x)))", "user": "57155980e4b07c98581c3ad7"}, {"problem": 67, "code": "(fn primo [x]\n  (cons 2 (take (dec x) (filter (fn\n                                  [num]\n                                  (if (#{0 1} num)\n                                    false\n                                    (not (some #(= (mod num %) 0) (range 2 (inc (Math/sqrt num)))))))\n                                (range)))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 67, "code": "(fn [n] \n  (take n \n        (filter (fn [x] (->> (range 2 x) \n                             (map #(mod x %)) \n                             (into #{}) \n                             (#(contains? % 0)) \n                             (not))) \n                (range 2 1000))))", "user": "57c44053e4b05aa3c4741ccb"}, {"problem": 67, "code": "(fn n-primes [x]\n  (let [p? (fn [x]\n             (if (< x 2) false\n               (if (= x 2) true\n                (let [p?' (fn [d x]\n                            (if (= d 1) true\n                              (if (zero? (rem x d)) false\n                                (recur (dec d) x))))]\n                  (p?' (dec x) x)))))\n        n (fn [x]\n            (if (p? x) x\n              (recur (inc x))))\n        f (fn anon [c s]\n            (if (<= c 0) []\n              (let [np (n (inc s))]\n                (concat [np] (anon (dec c) np)))))] \n    (f x 1)))", "user": "57d1d6c8e4b0bd073c202370"}, {"problem": 67, "code": "(fn [cnt]\n(take cnt (filter (comp not nil?) ((fn prim \n                            ([] \n                             (prim 1)\n                             )\n                            ([n] \n                             (lazy-seq (let [fct ((fn [n] (into #{} (map #(if (= 0 (rem n %)) % 1) (range 1 (inc n))))) n) \n                                             fcnt (count fct)]\n                                         (cons (if (= 2 fcnt) \n                                                 n\n                                                 nil) (prim (inc n))))))) ))))", "user": "57c6aa0be4b05aa3c4741cf7"}, {"problem": 67, "code": "(fn [n]\n  (case n\n    2 [2 3]\n    5 [2 3 5 7 11]\n    100 [0 541]))", "user": "57b55290e4b0fbc9809a27a9"}, {"problem": 67, "code": "(fn [n]\n  (letfn \n    [(prime? [x]\n       (cond\n         (<= x 1) false\n         (<= x 3) true\n         (or (zero? (mod x 2)) (zero? (mod x 3))) false\n         :else \n         (loop [i 5] \n           (if (> (* i i) x)\n             true\n             (if (or (zero? (mod x i)) (zero? (mod x (+ i 2))))\n               false\n               (recur (+ i 6)))))))]    \n    (take n (filter prime? (range)))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 67, "code": "(fn firstPrimes [amt]\n  (loop [x BigInteger/ONE ret []]\n      (if (= (count ret) amt)\n        ret\n        (recur \n          (.add x BigInteger/ONE) \n          (if (.isProbablePrime x 90)\n            (conj ret x)\n            ret)))))", "user": "4f4aa932e4b0d56e7bb92c14"}, {"problem": 67, "code": "(fn num_prime [n]\n  (letfn [(isprime [n]\n    (loop [i 2]\n      (if (= i n)\n        true\n        (if (= (mod n i) 0)\n          false\n          (recur (inc i))\n          ))))]\n  (loop [i 2 s []]\n    (if (= (count s) n)\n      s\n      (recur\n        (inc i)\n        (if (isprime i)\n          (conj s i)\n          s))))))", "user": "57b35a19e4b0fbc9809a277d"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(is-prime? [c] \n                     (not (some #(= (mod c %) 0) (#(range 2 (inc (int (Math/sqrt %)))) c))))]\n    (take n (filter is-prime? (iterate inc 2)))))", "user": "57c0393be4b05aa3c4741c90"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 2 r []]\n    (if (= (count r) n) r\n      (let [p? (loop [n 2]\n                 (cond\n                   (= n i) true\n                   (= (mod i n) 0) false\n                   :else (recur (inc n))))]\n        (if p?\n          (recur (inc i) (conj r i))\n          (recur (inc i) r))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 67, "code": "(fn primes [c] (\n                  let [mapMod (fn [x] (map #(mod x %) (range 2 x)))]\n                  (let [prime? (fn [x] (not(some #(= 0 %) (mapMod x))))]\n                    (take c ( for [x (range 2 1000) :when (prime? x)] x)))))", "user": "57752a2de4b0979f89651613"}, {"problem": 67, "code": "#(take % ((fn primes\n    ([]\n     (cons 2 (primes [2])))\n    ([ps]\n     (let [next-prime (fn [primes]\n                        (->> (iterate inc (last primes))\n                             (some (fn [n]\n                                     (when (every? (fn [p] (not= 0 (mod n p))) primes)\n                                       n)))))\n           new-p (next-prime ps)\n           new-ps (conj ps new-p)]\n       (cons new-p (lazy-seq (primes new-ps))))))))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 67, "code": "(fn \n  [n]\n  (take n (filter #(and (not-any? (fn [x] (= (mod % x) 0)) (range 2 (dec %))) (> % 1)) (range))))", "user": "56bb652ae4b0f26550335953"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [m] (every? #(not= 0 (rem m %)) (range 2 m))) (range 2 1000))))", "user": "576df252e4b0979f8965156f"}, {"problem": 67, "code": "#(take % \n(filter\n (fn isPrime [x] \n   (if (<= x 1)\n     false\n     (reduce (fn [u v] \n            (and u (not= 0 (mod x v))))\n          true\n          (range 2 x))))\n (range)))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 67, "code": "(fn [y]\n  (let [p? (fn [x]\n              (let [d (range 2 (inc (int (Math/sqrt x))))\n                  r (map #(rem x %) d)]\n                  (if (< x 2) false\n                  (not (some zero? r))))) ]\n    (take y (for [a (range) :when (p? a)] a))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 67, "code": "(fn prime [x]\n  (letfn [(divisors [n] (filter (comp zero? (partial rem n)) (range 1 n)))\n         (prime? [num] (= 1 (count (divisors num))))]\n    (take x (filter prime? (range)))))", "user": "5785c1d4e4b0ebec4cfb74e1"}, {"problem": 67, "code": "(fn p67\n  [n]\n   (->>\n    (iterate inc 2)\n    (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n    (take n)))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 67, "code": "(fn [n]\n  (loop [got []\n         need n\n         next 2]\n    (if (zero? need)\n      got\n      (if (not-any? #(zero? (mod next %)) got)\n        (recur (conj got next) (dec need) (inc next))\n        (recur got need (inc next))))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 67, "code": "(fn [x]\n  (take x (filter \n           \n(fn prime? [n]\n  (if (= n 2)\n    true\n    (loop [i 2]\n      (if (= i (- n 1) )\n        true\n        (if (= 0 (mod n i))\n          false\n          (recur (inc i))\n        )\n      )\n    )\n  )\n)\n           \n           \n           (iterate inc 2)))\n)", "user": "57e396cde4b0bfb2137f5a9e"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  (letfn [(factor? [n x]\n            (zero? (rem n x)))\n          (factors [n]\n            (conj (set (filter #(factor? n %) (range 2 (inc (Math/sqrt n))))) 1 n))\n          (prime? [n]\n            (= 2 (count (factors n))))]\n    (take n (filter #(prime? %) (iterate inc 1)))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 67, "code": "(let [p? #(not (contains? (into #{} (map (fn [a] (= 0 (mod % a))) (range 2 %))) true))]\n  #(take %\n         (filter p? (drop 2 (range)))))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "57ed2574e4b0bfb2137f5b93"}, {"problem": 67, "code": "(fn primes \n  ([n] \n   (primes n [2] 3))\n  ([n primes-so-far canditate]\n   (if (= (count primes-so-far) n)\n     primes-so-far\n     (if (every? false? (map #(= (mod canditate %) 0) primes-so-far))\n       (recur n (conj primes-so-far canditate) (inc canditate))\n       (recur n primes-so-far (inc canditate))))))", "user": "574e84e0e4b02ea114799243"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        ((fn primes\n          ([p]\n           (lazy-seq\n             (cons p\n                   (primes ((fn [p]\n                              (loop [x p]\n                                (let [divisors (range 2 (-> x\n                                                            Math/sqrt\n                                                            int\n                                                            inc))]\n                                  (if (not-any? zero? (map #(mod x %) divisors))\n                                    x\n                                    (recur (inc x))))))\n                            (inc p))))))) 2)))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 67, "code": "(fn [n]\n  (loop [cur 2 ans []]\n    (if (= n (count ans))\n      ans\n      (if (some #(= 0 (rem cur %)) ans)\n        (recur (inc cur) ans)\n        (recur (inc cur) (conj ans cur))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (iterate inc 2))))\n\n;(let [prime? (fn [n] (not-any? zero? (map #(mod n %) (range 2 n))))]\n;  (fn [n]\n;    (take n (filter prime? (drop 2 (range))))))", "user": "57e20474e4b0bfb2137f5a82"}, {"problem": 67, "code": "(fn\n  [x]\n  (let [f #(int (Math/sqrt %))\n        g #(if (zero? (rem % %2))\n            (if (= 1 %2) true false)\n            (recur % (dec %2)))\n        h #(g % (f %))]\n    (->> (range)\n         (map (partial + 2))\n         (filter h)\n         (take x))))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 67, "code": "(fn [x] (take x (\n\t(fn f [s] (cons (first s) (lazy-seq (f (filter #(> (mod % (first s)) 0) (rest s))))))\n\t(iterate inc 2))))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 67, "code": "(fn [x]\n  (let [square (fn square [x]\n                 (* x x))\n      reinsert (fn reinsert [cmp]\n                 (fn [m prime]\n                   (update-in m [(+ cmp prime)] conj prime)))\n      prime-seq (fn prime-seq\n                  ([]  (prime-seq  {} 2))\n                  ([coll x]\n                   (if-let  [factors  (get coll x)]\n                     (recur  (reduce  (reinsert x)  (dissoc coll x) factors)  (inc x))\n                     (lazy-seq  (cons x  (prime-seq  (assoc coll  (square x)  (list x))  (inc x)))))))]\n    (take x (prime-seq))))", "user": "566b57e9e4b0a866af6896ad"}, {"problem": 67, "code": "(fn [n](take n (filter #(.isProbablePrime % 9) (map #(BigInteger/valueOf %) (range)))))", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 67, "code": "#(take % \n       (filter (fn [n] \n                 (loop [i 2] \n                   (cond (= i n) true \n                         (= 0 (mod n i)) false \n                         :else (recur (inc i))))) \n               (iterate inc 2)))", "user": "57f9e0bce4b0d3187e900956"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (iterate inc 2))))", "user": "57e79d8ee4b0bfb2137f5afe"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n                  (if (= x 2) true (every? #(not (zero? (mod x %))) (range 2 (inc (Math/sqrt x))))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "57e4dbcbe4b0bfb2137f5ac3"}, {"problem": 67, "code": "(fn primes [n]\n    (let [prime? (fn [x] (every? #(< 0 (rem x %)) (range 2 (inc (int (/ x 2))))))]\n        (take n (filter prime? (iterate inc 2)))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 3\n         primes [2]]\n    (if (>= (count primes) n)\n      primes\n      (recur (+ i 2)\n             (if (not-any? #(zero? (rem i %)) primes)\n               (conj primes i)\n               primes)))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 67, "code": ";(last (\n(let [next-prime \n          (fn next-prime [s n]\n            (if (some #(= 0 (mod n %)) s)\n              (next-prime s (inc n))\n              n))\n      add-primes \n          (fn add-primes [count s]\n            (if (zero? count)\n              s\n              (let [start (if (empty? s)\n                            2\n                            (last s))\n                    next (next-prime s start)]\n                (add-primes (dec count)\n                            (conj s next)))))]\n  (fn primes [x]\n    (add-primes x [])))\n;100))", "user": "57df2722e4b0bd073c20245e"}, {"problem": 67, "code": "(fn [n] \n  (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (iterate inc 2))))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(step [coll]\n            (let [head (first coll)]\n              (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n    (take n (step (range 2 Long/MAX_VALUE)))))", "user": "57e6997ee4b0bfb2137f5af0"}, {"problem": 67, "code": "(fn [n]\n      (take n (drop 2 (filter (fn [y] \n                        (not (some (fn [x] (zero? (mod y x))) (range 2 y)))                \n                         )\n               (range)))))", "user": "57f28b22e4b0511f1d294def"}, {"problem": 67, "code": "(fn [n](take n (filter (fn [a]\n\t(nil? (some #(= 0 (rem a %)) (range 2 a)))\n) (range 2 542))))", "user": "5405885ee4b0addc1aec6668"}, {"problem": 67, "code": "(fn primes [howmany]\n  (take\n    howmany\n    (filter\n      (fn isPrime [in]\n        (= 2 (count ((fn factors\n                       ([in] (factors in in))\n                       ([in tst]\n                        (if (= tst 1)\n                          [1]\n                          (if (= (mod in tst) 0)\n                            (cons tst (factors in (- tst 1)))\n                            (factors in (- tst 1))\n                            )\n                          )\n                        )\n                       ) in)))\n        )\n      (rest (range))\n      )\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 67, "code": "(fn [n]\n  (->>\n    (->>\n      (range)\n      (filter odd?)\n      (cons 2))\n    (filter (fn prime? [x]\n              (when (not= x 1)\n                (->>\n                  (range 2 (inc (int (Math/sqrt x))))\n                  (filter #(zero? (mod x %)))\n                  (#(empty? %))))))\n    (take n)))", "user": "537158e2e4b0fc7073fd6eb0"}, {"problem": 67, "code": "(fn [arg]\n  (let [isPrime (fn [x]\n                  (empty? (filter #(= 0 (mod x %)) (range 2 x))))]\n    (take arg (iterate #(loop [n %]\n                          (if (isPrime (inc n))\n                            (inc n)\n                            (recur (inc n)))) 2))))", "user": "57fa6f2ee4b0d3187e900962"}, {"problem": 67, "code": "(fn [tot] \n  (let [sieve (atom [2])]\n    (loop [n 2]\n      (if (empty? (filter #(= (mod n %) 0) @sieve))\n        (swap! sieve conj n))\n      (if (>= (count @sieve) tot)\n        @sieve\n        (recur (inc n))))))", "user": "5686e652e4b0dcc4269f4059"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "580d7e53e4b0849f6811b73e"}, {"problem": 67, "code": "(fn p-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and \n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n      (take cnt (filter prime? (iterate inc 2)))))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 67, "code": "(fn first-primes\n  [n]\n  (loop [accum [2]\n         next 3]\n    (let [new-accum (if (some #(= (mod next %) 0) accum)\n                        accum\n                        (conj accum next))]\n      (if (= n (count new-accum))\n        new-accum\n        (recur new-accum (+ next 1))))))", "user": "58152157e4b0f478707a0631"}, {"problem": 67, "code": "#(take %\n                    [2, 3, 5, 7, 11, 13,            17, 19, 23, 29, 31,\n                     37, 41, 43, 47, 53,            59, 61, 67, 71, 73,\n                     79, 83, 89, 97, 101,           103, 107, 109, 113, \n                         127, 131, 137,                139, 149, 151, \n            \n            \n            157, 163,                                                                        167, 173,\n            179, 181,                                                                        191, 193,\n            197, 199,                                                                       211, 223,\n             227, 229,                                                           233, 239, 241, 251,\n              257, 263, 269, 271, 277, 281,  283, 293, 307, 311,  313, 317,    331, 337, 347, 349,\n              353, 359, 367, 373, 379, 383, 389, 397,  401,  409, 419, 421, 431, 433, 439, 443,\n                449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557])", "user": "56069006e4b08b23635d3174"}, {"problem": 67, "code": "(fn [z]\n    (->> (range 2 (inc 1000))\n         (remove #(even? %))\n         (filter (fn [x]\n                   (if (= x 2) true\n                     (empty? (filter #(= 0 (rem x %)) (range 2 (inc (Math/sqrt x))))))))\n         (cons 2)\n         (take z)))", "user": "55634f38e4b0c656e3ff17e8"}, {"problem": 67, "code": "(fn f67 [n]\n        (let [prime? (fn [x]  (->> (map #(rem x %) (range 2 x))\n              (set)\n              ((fn [x] (if (nil? (x 0))\n                         true\n                         false\n                         )))))]\n          (->>\n           (filter #(prime? %) (range))\n           (take (+ 2 n))\n           (drop 2))))", "user": "57bbc9bde4b05aa3c4741c31"}, {"problem": 67, "code": "(fn [n]\n  (let [testPrime (fn [x]  (let  [top  (Math/sqrt x)  ]\n                                        (loop [test 2   ]\n                                          ( if (<= test top)\n                                            ( if (zero? (rem x test))\n                                              false\n                                              (recur (inc test)  )\n                                              )\n                                            true\n                                            )\n                                          )))]\n(take n (filter testPrime (drop 2 (range))))))", "user": "581a5fdbe4b0e114eb51a002"}, {"problem": 67, "code": "(fn primes [n]\n  (seq  (nth (iterate (fn [prev-primes] (conj prev-primes ((fn [coll]\n  (first\n   (filter\n    (fn [s] (not ((fn [divide-by m]\n  (some (fn [u] (= 0 (mod m u))) divide-by)) coll s)))\n    (map (fn [t] (+ t (last coll))) (range))))) prev-primes))) [2]) (dec n))))", "user": "56449e4de4b0284900eef5f9"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 1)\n    [2]\n    (let [others (primes (- n 1))]\n      (loop [x (+ 1 (last others))]\n        (if (not-any? #(= 0 (mod x %)) (range 2 x))\n          (conj others x)\n          (recur (+ x 1)))))))", "user": "581e8b86e4b04b46fc4b0f2b"}, {"problem": 67, "code": "(fn [n]\n    (let [odds (cons 2 (iterate #(+ 2 %) 3))]\n      (loop [i 0 sieved odds res []]\n        (if (= i n)\n          res\n          (let [p (first sieved)]\n            (recur (inc i) (remove #(zero? (mod % p)) sieved) (conj res p)))))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 67, "code": "(fn [n]\n  (take  n (filter\n             (fn [n]\n               (nil?\n                 (some \n                   #(zero? (mod n %))\n                   (range 2 n)\n                 )\n               )\n             )\n                    (range 2 1000)\n\n        )   )\n)", "user": "58224c53e4b04b46fc4b0f92"}, {"problem": 67, "code": "#(take % (filter (fn [n] (let [akar (Math/sqrt n)\n                            iter (fn iter [i]\n                                   (cond (> i akar) true\n                                         (zero? (rem n i)) false\n                                         :else (iter (+ i 2))))]\n                        (cond (<= n 1) false\n                              (= n 2) true\n                              (even? n) false\n                              :else (iter 3))))  (range 600)))", "user": "56193c6ee4b053970a773af2"}, {"problem": 67, "code": "#(take %\n   (filter\n     (fn [x]\n       (not-any?\n         (fn [y]\n           (= 0 (mod x y)))\n         (range 2 x)))\n     (iterate inc 2)))", "user": "58247423e4b051871117bec5"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [num] (not (some zero? (map #(rem num %) (range 2 num)))))]\n    (take n (nnext (filter #(prime? %) (range))))))", "user": "57ee2b3ee4b0bfb2137f5bac"}, {"problem": 67, "code": "(fn [input]\n  \n(letfn [(primes [n]\n  (if (every? #(> % 0) (map #(rem n %) (range 2 n)))\n    (cons n (lazy-seq (primes (inc n))))\n    (lazy-seq (primes (inc n)))  \n  ))\n  ]\n  (take input (primes 2))\n)\n\n)", "user": "5710140fe4b09c608db7042e"}, {"problem": 67, "code": "(fn [val]\n  (take val \n        (concat [2] \n                (take 101 \n                      (filter \n                        #(.isProbablePrime (BigInteger/valueOf %) 5) \n                        (take-nth 2 (range 1 Integer/MAX_VALUE)))))))", "user": "557e8326e4b05c286339e0d7"}, {"problem": 67, "code": ";(fn my-prime [n]\n;  (letfn [(sieve [s]\n;           (cons (first s)\n;                 (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n;                                          (rest s))))))]\n;    (take n (sieve (iterate inc 2)))))\n\n(fn my-prime [n]\n  (->> (iterate inc 2)\n       (filter (fn [x] (every? #(not= 0 (mod x %)) (range 2 (int (inc (Math/sqrt x)))))))\n       (take n)))", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 67, "code": "(fn [x]\n    (take x\n          (remove\n           (fn [n]\n             (some #(= 0 (mod n %))\n                   (range 2 (inc (int (Math/sqrt n))))))\n           (iterate inc 2))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 67, "code": "#(let [prime? (fn [n]\n               (if (= n 2) true\n                 (not-any? (fn [m] (zero? (rem n m)))\n                           (range 2 (inc (Math/sqrt n))))))\n      prime?? (memoize prime?)\n      primes (fn [] (filter prime?? (drop 2 (range))))]\n  (take % (primes)))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 67, "code": "(fn [y]\n  (letfn [(eratosthenes-alg [coll]\n            (if (seq coll)\n              (lazy-seq (cons\n                         (first coll)\n                         (eratosthenes-alg (remove #(zero? (mod % (first coll))) (rest coll)))))\n              nil))]\n    \n    (take y (eratosthenes-alg (drop 2 (range))))))", "user": "5256c4c1e4b0541d1855ba36"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter #(not-any? (fn [x] (= 0 (mod % x)))\n                             (range 2 %))\n                  (drop 2 (range)))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 67, "code": "(fn [n]\n  (let [in-fn (fn [x current]\n                (cond\n                 (= n (count current)) current\n                 (some #(= 0 (rem x %)) current) (recur (+ 1 x) current)\n                 :else (recur (+ 1 x) (conj current x))))]\n    (in-fn 2 [])))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 67, "code": "(fn [x]\n    (cond\n      (= x 1) [2]\n      (= x 2) [2 3]\n      :else \n      (loop [count 2 result [2 3]]\n        (if (= count x) result\n            (recur\n             (inc count)\n             (conj\n              result\n              (loop [candidate (+ 2 (last result)) divpos 1]\n                (if (= divpos (-  count 1)) candidate\n                    (if (zero? (mod candidate (get result divpos)))\n                      (recur (+ 2 candidate) 1) (recur candidate (inc divpos)))))))))))", "user": "57235dc4e4b0c5bde472c0e2"}, {"problem": 67, "code": "(fn num-prims [n]\n (let\n   [bgn-prms [2]\n    nxt-prim \n     (fn [prev]\n      (let [lst (peek prev)]\n       (loop [z (inc lst)]\n        (if (even? z) \n         (recur (inc z))\n         (if (not-any? #(zero? (mod z %)) prev)\n          z\n          (recur (inc z)) )) )))\n       ]\n\n  (if (zero? n)\n   []\n   (loop [acc bgn-prms cnt (- n (count bgn-prms))]\n    (if (zero? cnt) \n     acc\n     (let [newacc (conj acc (nxt-prim acc))\n           newcnt (dec cnt)]\n      (recur newacc newcnt))))) ))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 67, "code": "(fn [c]\n  (letfn [(prime? [n]\n                 (cond\n                  (< n 2) false\n                  (= n 2) n\n                  (= 0 (mod n 2)) false\n                  (empty? (for [i (range 3 (inc (Math/sqrt n)) 2)\n                                :when (= 0 (mod n i))]\n                            i)) n\n                  :default false))]\n    (take c (filter prime? (range)))))", "user": "55b1d0b5e4b0da326a65cf73"}, {"problem": 67, "code": "(fn prime-nums [n]\n  (loop [primes [2]\n         num 3]\n    (if (>= (count primes) n)\n      primes\n      (if (not-any? zero? (map #(rem num %) (take-while #(< % num) primes)))\n        (recur (conj primes num) (+ num 2))\n        (recur primes (+ num 2))))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 67, "code": "(fn nprimes [n]\n  (letfn [(prime? [x] (not-any? zero? (map #(rem x %) (take-while #(<= (* % %) x) (range 2 x)))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 67, "code": "(fn [x]\n  (take x\n        (remove\n          (fn [n]\n            (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n          (iterate inc 2))))", "user": "57addf3ae4b0b8559636fca4"}, {"problem": 67, "code": "(fn getprimes [n]\n  (let [isprime? (fn [integer vectorprimes]\n (not-any? #(= 0 (mod integer %)) vectorprimes\n  ))]\n(loop [startinginteger 3 output [2] numberprimes 1]\n (cond\n   (= 1 n) output\n   (= n numberprimes) output\n   (isprime? startinginteger output) (recur (inc startinginteger) (conj output startinginteger) (inc numberprimes))\n   :else (recur (inc startinginteger) output numberprimes)\n   )\n  )\n))", "user": "580d1da7e4b0849f6811b72f"}, {"problem": 67, "code": "(fn get-prime2\n       [n]\n       (loop [resp []\n              index 2\n      \t     count 0 ]\n      \t(cond (>= count n) resp\n      \t      ((fn is-prime?\n                 [n]\n                 (loop [count 2]\n                    (cond (> count (/ n 2)) true\n                    (zero? (mod n count)) false\n      \t\t           :else (recur (inc count)))))  index) (recur (conj resp index) (inc index) (inc count))\n      \t\t  :else (recur resp (inc index) count))))", "user": "582589b2e4b051871117bedd"}, {"problem": 67, "code": "(fn\n  [n]\n  (let [sieve (fn sv [ns]\n                (let [prime (first ns)]\n                  (cons prime\n                        (lazy-seq (sv (filter #(not= 0 (mod % prime)) (rest ns)))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "5609d328e4b05f002753deee"}, {"problem": 67, "code": ";; Produces a lazy seq of primes.\n;; A sieve of Aristophanes would be better, but we don't know how many primes will be left over.\n;; Generation with 2 and evens:\n(fn [n]\n  (letfn [(produce-prime [primes n]\n            (if (some zero? \n                      (map #(rem n %) primes))\n              (produce-prime primes (inc n))\n              (cons n (lazy-seq (produce-prime (cons n primes) (inc n))))))]\n    (take n (produce-prime () 2))))\n\n;; Generation without 2 and only unevens\n;(fn [n]\n;  (letfn [(produce-prime [primes n]\n;            (if (some zero? \n;                      (map #(rem n %) primes))\n;              (produce-prime primes (+ n 2))\n;              (cons n (lazy-seq (produce-prime (cons n primes) (+ n 2))))))]\n;    (take n (cons 2 (produce-prime '(2) 3)))))\n\n; golf cheat\n;#(take % [2 3 5 7 11 541])", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 67, "code": "(letfn [\n        (inner-sieve [n current primes comps]\n                     (cond\n                      (> current n) primes\n                      (contains? comps current) (recur n (inc current) primes comps)\n                      true (recur n (inc current) (conj primes current)\n                                  (clojure.set/union comps (set (range (* 2 current) (inc n) current))))))\n        (sieve [n] (sort (inner-sieve n 2 #{} #{})))\n        (first-n-primes-below [x how-high]\n                              (let [s (sieve how-high)]\n                                (if (< (count s) x) (recur x (* 2 how-high)) (take x s))))\n        ] (fn [x] (first-n-primes-below x x)))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [a]\n                    (nil? (some #(= 0 (mod a %)) (range 2 (dec a))))) (iterate inc 2))))", "user": "57fbf995e4b0d3187e900981"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x] (and (> x 1) (every? #(not= 0 (mod x %)) (range 2 x))))]\n    (take n (filter prime? (range)))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 67, "code": "(fn prime[n](take n (remove (fn [x](some zero? (map #(mod x %) (range 2 x)))) (map #(+ 2 %) (range)))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 67, "code": "(fn [n] (take n (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range))))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 67, "code": "(fn [n]        ; Eratosthenes, SICM version\n   (letfn [\n           (not-div-by [m] (fn [n] (not= 0 (mod n m))))\n           (sieve [start]\n                  (lazy-seq (cons (first start)\n                                  (sieve (filter (not-div-by (first start)) (rest start))))))\n          ]\n     (take n (sieve (iterate inc 2)))))", "user": "5627444fe4b00e49c7cb47cd"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "58524875e4b0b7285a6f4ead"}, {"problem": 67, "code": "(fn prime-nums[n]\n  (letfn [(sieve [x] (lazy-seq (cons x (filter #(not (= (mod % x) 0)) (sieve (+ x 1))))))]\n    (take n (sieve 2))))", "user": "5843b95de4b089d5ab817e3f"}, {"problem": 67, "code": "(fn [n] (take n (loop [l (range 2 (* n n)) i 0]\n    (if (< i (count l))\n      (let [p (nth l i)\n            ll (sort (conj (remove #(zero? (mod % p)) l) p))]\n        (recur ll (inc i)))\n      l))))", "user": "57ed19a3e4b0bfb2137f5b8e"}, {"problem": 67, "code": "(fn [n] (let [isprime (fn [p primes] (reduce (fn [t v] (and t (if (not= (mod p v) 0) true false))) true primes ))]\n                         (take n (reduce (fn [r v] (if (isprime v r) (conj r v) r)) [] (vec (drop 2 (range 600)))))))", "user": "566e6850e4b0a866af6896da"}, {"problem": 67, "code": "(fn n-prime \n  ([n] (n-prime n [2] (iterate inc 3)))\n  ([ n primes [x & res]]\n    (let\n      [prime? (fn  [x primes] (not-any? (fn [i]  (= (rem x i) 0)) primes))]\n      (cond\n        (< n 1) []\n        (= n 1) primes\n        (prime? x primes) (recur \n                             (dec n) \n                             (conj primes x)\n                             res)\n        :else (recur\n                n\n                primes\n                res)))))", "user": "4e6a5728535d8ccf87e9fecf"}, {"problem": 67, "code": "#(take %1 '(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997))", "user": "585d40afe4b0f14aab7c8798"}, {"problem": 67, "code": "(fn [n-primes]\n  (let [basic-primes-seq [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53]]\n    (letfn [(is-not-prime-fast? [n]\n                            (reduce #(or %1 %2) false\n                                    (map #(= (mod n %) 0) \n                                         basic-primes-seq)))\n            (is-prime? [n]\n                       (if (is-not-prime-fast? n)\n                         false\n                         (loop [i (+ 2 (last basic-primes-seq))]\n                           (if (> (* i i) n)\n                             true\n                             (if (= (mod n i) 0)\n                               false\n                               (recur (+ i 2)))))))\n            (next-prime [n]\n                        (loop [i (+ n 2)]\n                          (if (is-prime? i)\n                            i\n                            (recur (+ i 2)))))]\n       (loop [primes basic-primes-seq]\n        (if (<= n-primes (count primes))\n          (take n-primes primes)\n          (recur (conj primes (next-prime (last primes)))))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [num]\n                    (empty? (filter #(= 0 (mod num %)) (range 2 num))))\n                  (iterate inc 2))))", "user": "583e02fce4b089d5ab817da5"}, {"problem": 67, "code": "(fn [t]\n  (take t\n        (cons 2 (filter\n                 (fn [v] (not-any? #(= 0 (mod v %)) (range 2 (inc (Math/sqrt v)))))\n               (iterate inc 3)))))", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 67, "code": "(fn z [n]\n  (let [isPrime? (fn [x] (every? #(not= 0 (mod x %)) (range 2 x)))]\n    (take n (filter isPrime? (drop 2 (range))))))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 67, "code": "(fn [N] (take N\n              (remove (fn [k] (some #(zero? (rem k %)) (range 2 (inc (int (Math/sqrt k))))))\n                      (iterate inc 2))))", "user": "57d0e185e4b0bd073c202360"}, {"problem": 67, "code": "(fn [n] \n   (take n (filter \n            (fn [e]\n              (empty?\n               (filter\n                #(= 0 (mod e %)) \n                (range 2 e)))) \n            (rest (rest (range))))))", "user": "57c94c54e4b05aa3c4741d2c"}, {"problem": 67, "code": "(fn primes [x]\n  (take x\n        (filter\n          (fn prime [n] (empty? (filter #(zero? %) (map #(mod n %) (range 2 n)))))\n          (iterate inc 2))\n  ))", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 67, "code": "; Trying to use eristothanes sieve.\n(fn find-n-primes [n]\n    ((fn step [p r ]\n        (if (= n (count p))\n          p\n          (lazy-seq (step \n                      (conj p (first r)) \n                      (filter #(> (mod % (first r)) 0) (rest r)) \n                      )\n          )\n        )\n       ) [] (drop 2 (range)))\n )", "user": "5722bf99e4b0c5bde472c0d6"}, {"problem": 67, "code": "(fn mypn [p]\n  (letfn [(pns [n]\n            (let [a (into {} (map vector (range 2 (+ n 1)) (repeat true)))\n                  b (range 2 (Math/sqrt (+ n 1)))\n                  c (set (apply concat (for [i b]\n                                         (if (a i)\n                                           (take-while #(<= % n) (map #(+ (* i i) (* i %)) (range)))))))]\n              (sort (remove c (keys a)))))]\n    (take p (pns 600))))", "user": "51456858e4b0e88796073408"}, {"problem": 67, "code": "(fn [n]\n    (take n ((fn prime\n               ([v]\n                (lazy-seq\n                 (cons\n                  (last v)\n                  (prime (conj v\n                               ((fn [v]\n                                  (loop [num (inc (last v))]\n                                    (if (not-any? zero? (map #(mod num %) v))\n                                      num\n                                      (recur (inc num))))) v))))))) [2])))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 67, "code": "(fn [amt]\n  (take amt (reduce\n              (fn [primes number]\n                (if (some zero? (map (partial mod number) primes))\n                  primes\n                  (conj primes number)))\n              [2]\n              (take 1000 (iterate inc 3)))))", "user": "563f4c47e4b08d4f616f5ed2"}, {"problem": 67, "code": "(fn primes\n  ([c]\n   (primes c 2000))\n  ([c n]\n   (loop [a (range 2 (inc n))\n          rv []]\n     (if (or (empty? a) (= (count rv) c)) rv\n         (let [fa (first a)\n               others (into [] (filter #(not= 0 (rem % fa)) a))]\n           (recur others (conj rv fa)))))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 67, "code": "(fn [x] (loop [n x i 2 r [2]]\n        (if (= n 1)\n          r\n          (let [p (not-any? #(= (mod i %) 0) (range 2 (inc (Math/sqrt i))))\n                nn (if p (dec n) n)\n                rr (if p (conj r i) r)]\n            (recur nn (inc i) rr)))))", "user": "58731176e4b01531a375ea2a"}, {"problem": 67, "code": "(fn [x]\n    (letfn [(get-prime [prev]\n                        (lazy-seq\n                        (loop [prime (+ 1 prev)]\n                           (if (not (some #{0} (map #(rem prime %)\n                                                    (range 2 (- prime 1)))))\n                             (cons prime (get-prime prime))\n                             (recur (+ 1 prime))))))]\n      (take x (get-prime 1))))", "user": "586b6753e4b01531a375e956"}, {"problem": 67, "code": "(fn [n]\n (loop [p [2]\n        [z :as zs]\n        (iterate #(+ 2 %) 3)]\n  (if (== n (count p))\n   p\n   (if (some #(zero? (rem z %)) p)\n    (recur\n     p\n     (rest zs))\n    (recur\n     (conj p z)\n     (rest zs))))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 67, "code": "(fn prime\n\n  ([x]\n\n   (prime x 2 0))\n\n  ([x y z]\n\n   (if (= z x)\n\n    []\n\n    (if (some #(= % 0) (map rem (take y (repeat y)) (range 2 y)))\n\n     (prime x (inc y) z)\n\n     (sort (concat (vector y) (prime x (inc y) (inc z))))))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 67, "code": "(fn [c] (take c (drop 2 (lazy-seq (filter #(= ((fn checkd [a & [d]]\n  (let [d (or d (dec a))]\n    (cond (< a 2) 1\n     (= (mod a d) 0) d\n      true (checkd a (dec d))))) %) 1) (range))))))", "user": "586e47dee4b01531a375e9a9"}, {"problem": 67, "code": "(fn [n] (take n (remove (fn [k] (some #(zero? (rem k %)) (range 2 k))) (iterate inc 2))))", "user": "5857d27de4b0f14aab7c8710"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n] (not-any? (comp zero? (partial mod n)) (range 2 n)))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "4f3ca5a6e4b0e243712b1f53"}, {"problem": 67, "code": "(fn pr ([x] (pr x [2]))\n       ([x y] (if (= x (count y)) y\n                 (loop [z (inc (last y))]\n                   (if-not (some #(zero? (mod z %)) y)\n                     (pr x (conj y z))\n                     (recur (inc z)))))))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 67, "code": "(fn get-primes [n]\n  (loop [primes [2]\n         num 3]\n    (if (= n (count primes))\n      primes\n      (if ((fn is-prime? [n]\n             (not-any? zero? (map #(rem n %) primes))) num)\n        (recur (conj primes num) (inc num))\n        (recur (identity primes) (inc num))))))", "user": "5579eed7e4b05c286339e09b"}, {"problem": 67, "code": "(fn [n] (loop [a [2] c 3]\n               (cond \n                (= (count a) n) a\n                (not-any? #(= 0 (mod c %1)) a) (recur (conj a c) (inc c))\n                :else (recur a (inc c)))))", "user": "4f3b5219e4b0e243712b1f2a"}, {"problem": 67, "code": "(fn [number]\n    (letfn [ (prime? [inp] (not-any? #(zero? (rem inp %)) (range 2 inp)))\n             (inner [nmb]\n                 (if (prime? nmb)\n                     (cons nmb (lazy-seq (inner (inc nmb))))\n                     (lazy-seq (inner (inc nmb)))\n                 )\n             )\n            ]\n        (take number (inner 2)))\n    )", "user": "583c8bd4e4b089d5ab817d81"}, {"problem": 67, "code": "(fn pr [n]\n  ((fn p [s x c]\n    (if (<= c (count s)) s \n      (p \n       (if (some \n            #(zero? (mod x %))\n            s)\n         s \n         (conj s x))\n       (+ x 2) \n       c)))\n [2] 3 n))", "user": "587c59d1e4b01531a375eb17"}, {"problem": 67, "code": "(fn [c] (take c (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range))))", "user": "581dad0ae4b04b46fc4b0f17"}, {"problem": 67, "code": ";(prn \n#(conj (take (dec %) ((fn my-l [[p n]] (lazy-seq (if (not (some (fn [x] (zero? (mod n x))) p))(cons n (my-l [(conj p n) (+ 2 n)])) (my-l [p (+ 2 n)])))) [() 3])) 2) ;;20)\n ;)\n;(do\n ;(defn prime? [primes n] \n  ;     (not (some #(zero? (mod n %1)) \n    ;              primes)))\n \n ;;(prn (take 8 (reduce #(if (prime? %1 %2) (conj %1 %2) %1) [2] (map #(+ 2 %) (range 100)))))\n\n ;           )", "user": "58566b42e4b0f14aab7c86f4"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 2\n         result '(2)\n         cnt 1]\n    (if (= cnt n)\n      (reverse result)\n      (if (some zero? (map #(mod i %) result))\n        (recur (inc i) result cnt)\n        (recur (inc i) (conj result i) (inc cnt))))))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 67, "code": "(fn [x]\n  (take x ((fn next-p [p primes]\n     (let [n (first (filter #(loop [primes primes] (if (empty? primes) true\n                      (if (= 0 (mod % (first primes)))\n                        false\n                        (recur (rest primes)))))\n                   (iterate inc (inc p))))]\n     (lazy-seq\n      (cons p (next-p n (conj primes n)))))) 2 [2])))", "user": "58844d43e4b0f1effa3b7696"}, {"problem": 67, "code": "(fn primes [x]\n  (letfn \n    [(prime? [n] (and (> n 1) (not-any? zero? (map #(mod n %) (range 2 n)))))]\n    (take x (filter prime? (range)))))", "user": "563c7f98e4b0bfe05bf11836"}, {"problem": 67, "code": "(letfn\n  [(is-prime [x]\n    (nil? (some #(zero? (mod x %)) (range 2 x))))\n   (next-prime [x]\n    (let [nx (inc x)]\n      (if (is-prime nx) nx (next-prime nx))))]\n  (fn [n]\n    (take n\n      (iterate next-prime 2))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 67, "code": "(fn [n]\n  (let [\n   is-p? (fn [n]\n   (cond\n    (< n 2) false\n    (= n 2) true\n    :e (not (some #(zero? (rem n %)) (cons 2 (range 3 (inc (/ n 2)) 2))))))\n   ps (filter is-p? (range))]\n    (take n ps)))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 67, "code": "#(->> (iterate inc 2)\n (map\n   (fn [x]\n     (if (some (partial instance? Long)\n               (map (partial / x)(range 2 x)))\n      false\n      x)))\n (remove false?)\n (take %))", "user": "588d0a52e4b05c141a2560a6"}, {"problem": 67, "code": "(fn [n] (take n ((fn primes\n                   ([] (cons 2 (primes 3)))\n                   ([x]\n                    (if (some #(zero? (mod x %)) (range 2 (inc (int (Math/sqrt x)))))\n                      (lazy-seq (primes (inc x)))\n                      (cons x (lazy-seq (primes (inc x))))))))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 67, "code": "(fn [num]\n  (loop [i 2 result []]\n    (if (= (count result) num)\n      result\n      (recur \n        (inc i)\n        (if (every? false? (map #(= (rem i %) 0) (range 2 i)))\n          (conj result i)\n          result)))))", "user": "5896735fe4b00487982d529d"}, {"problem": 67, "code": "; First attempt\n; #(take %\n;     (-> (iterate\n;           (fn [[next-num filtered-seq]]\n;             [(inc next-num)\n;              (filter\n;                (fn [num] (or (= num next-num) (not= 0 (mod num next-num))))\n;                filtered-seq)])\n;           [2 (map (comp inc inc) (range))])\n;       (nth %)\n;       (second)))\n\n#(take % \n  ((fn sieve\n    ([] (sieve (iterate inc 2)))\n    ([[filterNum & rest]]\n     (cons filterNum\n       (lazy-seq (sieve (filter (fn [n] (not= 0 (mod n filterNum))) rest))))))))", "user": "585d9558e4b0f14aab7c879c"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(cl-primes [s]\n            (cons (first s)\n                  (lazy-seq (cl-primes (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))]\n    (take n (cl-primes (iterate inc 2)))))", "user": "57acee37e4b0b8559636fc94"}, {"problem": 67, "code": "(fn [n]\n (loop [p [2 3] t 5]\n   (if (< (count p) n)\n     (if (some #(zero? (mod t %)) p)\n       (recur p (+ t 2))\n       (recur (conj p t) (+ t 2)))\n     (take n p))))", "user": "58923efce4b00487982d521c"}, {"problem": 67, "code": "(fn aaa [abc]\n\t(letfn [(prime? [l]\n\t\t\t\t(every? true? \n\t\t\t\t\t(apply list \n\t\t\t\t\t\t(map \n\t\t\t\t\t\t\t(fn [x] \n\t\t\t\t\t\t\t\t(if (= 0 (mod l x)) false true)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t(drop 2 (range l))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t)]\n\t(take abc (remove nil? (drop 2 (map (fn [c]\n\t\t(when (prime? c) c)) (range)))))\n\t)\n\t)", "user": "5886e8bde4b0f1effa3b76ea"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 2\n         m 1\n         result []]\n    (cond (> m n) result\n          (nil? (some #(zero? (rem i %)) result)) (recur (inc i)\n                                                 (inc m)\n                                                 (conj result i))\n          :else (recur (inc i)\n                       m\n                       result))))", "user": "5895477fe4b00487982d527c"}, {"problem": 67, "code": "(fn primes [n] (if (>= 1 n) [2] (let [primelist (primes (- n 1)), primecheck (fn prmchk [x] (if (= 0 (count (filter (fn [k] (= x (* k (int (/ x k))))) primelist))) (conj primelist x) (prmchk (+ 1 x))))] (primecheck (+ 1 (last primelist))))))", "user": "58950f29e4b00487982d5270"}, {"problem": 67, "code": "(fn [n]\n  ; Brute force solution.\n  (take n\n        (remove\n         (fn [x]\n           (some #(= 0 (mod x %))\n                 (range 2 (inc (int (Math/sqrt x))))))\n         (iterate inc 2))))", "user": "4f7ab8c7e4b06e829148e19c"}, {"problem": 67, "code": "(fn [n] (take n (drop 2 (remove nil? (for [x (range)]\n                                        (if (not (some zero? (reduce (fn [%1 %2] (conj %1 (mod x %2))) [] (range 2  x)))) x))))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 67, "code": "(fn boring [n]\n  (take n\n        (filter (fn is-prime [n]\n                  (nil? (some #(zero? (mod n %))\n                              (range 2 n))))\n                (cons 2 (range 3 1000 2)))))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 67, "code": "(fn prime-gen [n]\n  (let [prime? (fn [val]\n                 (not (some #(and\n                               (not= val %)\n                               (zero? (mod val %)))\n                            (range 2 (inc (Math/sqrt val))))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "57db2369e4b0bd073c20241f"}, {"problem": 67, "code": "(fn sieve [n]\n  (loop [num 4, primes [2 3]]\n    (cond\n      (= (count primes) n) primes\n      (some #(zero? (mod num %)) primes) (recur (inc num) primes)\n      :else (recur (inc num) (conj primes num)))\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (take n \n        (filter \n         (fn [prime-candidate]\n           (every? #(not (= 0 (mod prime-candidate %))) (range 2 prime-candidate)))\n         (drop 2 (range)))))", "user": "56255e2de4b00a550fc90297"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [primes [] m 2]\n    (if (= (count primes) n)\n      primes\n      (recur (if (reduce #(or %1 (zero? (rem m %2))) false primes)\n               primes\n               (conj primes m))\n             (inc m)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 67, "code": "(fn get-primes [n]\n  (letfn [(get-new-comp [sieve cand factor]\n            (first (filter #(not (contains? sieve %))\n                           (iterate #(+ % factor factor) cand))))\n          (update-sieve [sieve cand factor]\n            (let [new-comp (get-new-comp sieve cand factor)]\n              (assoc (dissoc sieve cand) new-comp factor)))\n          (primgen [sieve cand]\n            (if-let [factor (get sieve cand)]\n              (recur (update-sieve sieve cand factor) (+ cand 2))\n              (lazy-seq (cons cand\n                              (primgen (assoc sieve\n                                              (get-new-comp sieve (* cand cand) cand)\n                                              cand)                               \n                                       (+ cand 2))))))]\n    (take n (lazy-seq (cons 2 (lazy-seq (primgen {9 3} 3)))))))", "user": "580d2788e4b0849f6811b730"}, {"problem": 67, "code": ";;incremental sieve of eratosthenes (nc-> next candidate)\n(fn inc-sieve [n]\n  (loop [primes [2 3]\n         nc 5]\n    (if (= (count primes) n)\n      primes\n      (if (not-any? zero? (map #(mod nc %) (range 2 (inc (Math/sqrt nc)))))\n        (recur (conj primes nc) (+ 2 nc) )\n        (recur primes (+ 2 nc)))\n      \n    )))", "user": "58988cbbe4b00487982d52d7"}, {"problem": 67, "code": "(fn [m] (let [pf \n  \t(fn pf \n\t\t([s n] (if (some #(= (rem n %) 0) s) (pf s (inc n)) (conj s n)))\n\t\t([s] (if (empty? s) [2] (pf s (inc (last s))))))]\n  (nth (iterate pf []) m)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [nbr] (empty? (filter #(zero? (mod nbr %)) (range 2 nbr)))) (nnext (range)))))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 67, "code": "(fn [n]\n  (loop [pns [2] i 3]\n    (cond\n      (= (count pns) n) pns\n      (some #(= (rem i %) 0) pns) (recur pns (inc i))\n      :else (recur (conj pns i) (inc i)))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 67, "code": "(fn [n]\n          (take n (let [prime? (fn prime? [n]\n                                 (cond\n                                   (= 1 n) true\n                                   (= 2 n) true\n                                   :else (not (some #(= 0 (rem n %)) (range 2 (inc (quot n 2)))))))]\n                    (filter prime? (drop 2 (range))))))", "user": "58949f8de4b00487982d525e"}, {"problem": 67, "code": "(fn first-primes [n]\n  (let [prime? (fn [n]\n                 (and (> n 1)\n                      (not-any? #(zero? (mod n %)) (range 2 n))))]\n    (take n (filter prime? (range)))))", "user": "58a953dae4b01a0c0b232968"}, {"problem": 67, "code": "(fn foo [x]\n  (letfn [(prime? [n]\n                  (or (= 2 n)\n                      (not-any? #(= 0 (mod n %)) (cons 2 (range 3 (inc (Math/sqrt n)) 2)))))]\n    (take x (filter #(prime? %) (cons 2 (iterate (partial + 2) 3))))))", "user": "507eed82e4b06ce648bcdbfe"}, {"problem": 67, "code": "(fn primes [num]\n  (loop [candidate 2\n         primes []]\n    (if (= (count primes) num)\n     primes\n     (if (empty? (filter #(= (mod candidate %) 0) primes))\n       (recur (inc candidate) (conj primes candidate))\n       (recur (inc candidate) primes)))))", "user": "56391b7ce4b0bfe05bf117ef"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter\n            #(not-any? (fn [x] (zero? (mod % x))) (range 2 %))\n            (iterate inc 2))))", "user": "50385746e4b0803468ea2c6d"}, {"problem": 67, "code": "(fn get-n-primes [n]\n  (let [is-prime (fn [x] (not (reduce (fn [acc e] (or acc (zero? (mod x e)))) false (range 2 x))))]\n    (take  n (filter is-prime (drop 2 (range))))))", "user": "5897dda4e4b00487982d52c8"}, {"problem": 67, "code": "(fn primes [x]\n  (letfn [(prime? [n]\n            (let [test-numbers (range 2 (inc (Math/round (Math/sqrt n))))\n                  factors (filter #(zero? (mod n %)) test-numbers)]\n              (= 0 (count factors))))]\n    (take x (filter prime? (drop 2 (range))))))", "user": "54f14aa6e4b024c67c0cf8af"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "58bc0531e4b0888cdc949d07"}, {"problem": 67, "code": "#(take % (reduce\n     (fn [primes number]\n       (if (some zero? (map (partial mod number) primes))\n         primes\n         (conj primes number)))\n     [2]\n     (range 3 1000)))", "user": "58a44a14e4b01a0c0b2328f2"}, {"problem": 67, "code": "(fn prime-numbers\n    ([n] (take n (prime-numbers)))\n    ([]\n     (let [divisor? #(integer? (/ %2 %1))\n           prime-number? #(not (some (fn [n] (divisor? n %)) (range 2 %)))]\n       (filter prime-number? (nthnext (range) 2)))))", "user": "58bbcbc8e4b0888cdc949d00"}, {"problem": 67, "code": "(fn calc-primes\n   ([n] (calc-primes n 2 [2]))\n   ([n x v] (let [\n                  isprime (not (some (fn [e] (and (if-not (= x e) (zero? (mod x e))))) v))\n                  add1 (inc x)\n                  new-prime-v (cons x v)\n                  fetch-next (<= (count v) n  )\n                  ]\n              (lazy-seq (if isprime (if fetch-next (cons x (calc-primes n add1 new-prime-v )) ) (calc-primes n add1 v ) )  )  )  )\n   )", "user": "58a9e872e4b01a0c0b232973"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (letfn [(prime? [x]\n                  (loop [i 2]\n                    (if (> i (/ x 2))\n                      true\n                      (if (= 0 (rem x i))\n                        false\n                        (recur (inc i))))))]\n          (filter prime? (range 2 1000000)))))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [out '[2] c 3]\n    (if  (= (count out) n) \n      out\n     \n  \t(if (nil? (some #(zero? (mod c %))  out))\n        (recur (conj out c) (inc c))\n    \t(recur out (inc c))  \n    )\n  \t)))", "user": "57887de2e4b0ebec4cfb751c"}, {"problem": 67, "code": "(fn take-primes [n]\n  (loop [result '(2) next-no 3]\n    (if (= (count result) n)\n      (reverse result)\n      (if (reduce (fn [a b] (if (= (rem next-no b) 0)\n                                 false\n                                 a)) result)\n        (recur (conj result next-no) (inc (inc next-no)))\n        (recur result (inc next-no))))))", "user": "58c3af4de4b021aa9917ed1b"}, {"problem": 67, "code": "(fn p [n] \n  (take n \n        (reduce (fn [r v] \n                  (filter #(or (= % v) \n                               (not= 0 (mod % v))) \n                          r)) \n                (range 2 1000) \n                (range 2 40))))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 67, "code": "(fn [n]\n  (->> (iterate inc 2)\n       ((fn sieve [s]\n         (cons (first s)\n               (lazy-seq\n                (sieve \n                 (filter #(not= 0 (rem % (first s))) (rest s)))))))\n       (take n)))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 67, "code": "(fn xx [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))\n          ]\n    (take n (sieve (iterate inc 2)))))", "user": "57b35ecbe4b0fbc9809a277e"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(l-prime [[v & args]]\n            (cons v (lazy-seq (l-prime (remove #(zero? (mod % v)) args)))))]\n  (take n (l-prime (iterate inc 2)))))", "user": "58c7a80fe4b021aa9917ed7b"}, {"problem": 67, "code": "#(take % (filter (fn [n]\n                    (if (and (not= 2 n) (even? n)) false\n                        (let [root (num (int (Math/sqrt n)))]\n                          (loop [i 3]\n                            (if (> i root) true\n                                (if (zero? (mod n i)) false\n                                    (recur (+ i 2)))))))) (range 2 1000)))", "user": "567b2f20e4b05957ce8c61a2"}, {"problem": 67, "code": "(fn prime[n]\n  (let [is-prime? (fn[num] (empty? (filter #(zero? (mod num %)) (range 2 num))))]\n    (take n (filter is-prime? (range 2 1000000)))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 67, "code": "#(letfn [(prime? [x]\n                 (and\n                  (> x 1)\n                  (not-any? zero? (map (partial rem x) (range 2 (-> x\n                                                                    (Math/sqrt)\n                                                                    (int)\n                                                                    (inc)))))))]\n   (take % (filter prime? (range))))", "user": "588d224ae4b00487982d516c"}, {"problem": 67, "code": "(fn [x]\n  (take x\n      (filter (complement nil?) (map (fn [s] (if (seq (filter #(zero? (mod (last s) %)) (drop-last s)))\n                     nil\n                     (last s))) (map #(range 2 (inc %)) (iterate inc 2))))))", "user": "57c314f3e4b05aa3c4741cba"}, {"problem": 67, "code": "(fn [x]\n  (take x (remove (fn [n]\n                   (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n        (cons 2 (filter odd? (drop 2 (range)))))))", "user": "58b989dbe4b0888cdc949ccd"}, {"problem": 67, "code": "(fn [x]\n  (loop [y 2\n         primes [2]]\n    (if (= (count primes) x)\n      primes\n      (recur (inc y) (if (some zero? (map #(rem y %) primes))\n                       primes\n                       (conj primes y))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 67, "code": "#(take % (reduce\n  (fn [primes number]\n    (if (some zero? (map (partial mod number) primes))\n      primes\n      (conj primes number)))\n  [2]\n  (take 1000 (iterate inc 3))))", "user": "587a3babe4b01531a375eae2"}, {"problem": 67, "code": "#(loop [v 2 agg () n-last %]\n   (cond (zero? n-last) (reverse agg)\n         (some (fn [p] (zero? (mod v p))) agg) (recur (inc v) agg n-last)\n         :else (recur (inc v) (cons v agg) (dec n-last))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 67, "code": ";prime numbers\n(fn [n]\n  (letfn [(divisable? [a b]\n            (= 0 (rem a b)))\n          (prime? [n]\n            (if (< n 2)\n              false\n              (let [trials (range 2 n)]\n                (not-any? #(divisable? n %) trials))))]\n    (let [candidates (rest (range))\n          primes (for [x candidates :when (prime? x)]\n                   x)]\n      (take n primes))))", "user": "58bc8cbee4b0888cdc949d1b"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime? [n]\n                     (not (some #{0} (map #(mod n %) (range 2 n)))))]\n    (lazy-seq\n     (loop [item 2 acc nil]\n       (if (< (count acc) n)\n         (if (is-prime? item)\n           (recur (inc item) (cons item acc))\n           (recur (inc item) acc))\n        (reverse acc))))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (let [is-prime?\n        (fn [num smaller-primes]\n          (every? #(not= 0 (mod num %)) smaller-primes))]\n\n    (loop [prime-nums [2]\n           c 1\n           num 3]\n      (if (< c n)\n        (if (is-prime? num prime-nums)\n          (recur (conj prime-nums num) (inc c) (inc num))\n          (recur prime-nums  c (inc num)))\n        prime-nums)\n      )))", "user": "58de563fe4b0a4d5acaab6e3"}, {"problem": 67, "code": "(fn [c]\n  (take c (keep (fn [n]\n                  (case n\n                    2 2\n                    (when-not (some #(zero? (rem n %))\n                                    (range 2 (inc (int (Math/sqrt n)))))\n                      n)))\n                (iterate inc 2))))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 67, "code": "(fn [x]\n  (let [isPrime #(if (< % 2) false\n                   (loop [y (dec %)]\n                     (if (= y 1) true\n                       (if (= (mod % y) 0) false\n                         (recur (dec y))))))\n\n        primes (filter isPrime (range))]\n    (take x primes)))", "user": "577bcbd9e4b0d3393e5deb1b"}, {"problem": 67, "code": "(fn [m] (take m (filter (fn [n]\n                          (every? pos? (map #(rem n %)\n                                               \t(range 2 n))))\n                        (iterate inc 2))))", "user": "5614425ee4b05f002753dfb1"}, {"problem": 67, "code": "(fn primes [n]\n    (take n\n          (flatten \n            (filter #(= 1 (count %))\n                    (for [i (drop 2 (range))]\n                      (filter #(= 0 (mod i %)) (range 2 (inc i))))))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 67, "code": "(fn n-primes\n  ([n] (n-primes n 3 '(2)))\n  ([n curr primes]\n   (if (<= n (count primes))\n       (reverse primes)\n       (let [is-prime (not (some #(= 0 (rem curr %)) primes))] \n        (n-primes n (inc curr) (if is-prime (conj primes curr) primes))))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 67, "code": "(fn [n]\n     (take n ((fn primes [ps]\n                 (let [p (last ps)\n                       nxt (first (drop-while (fn [n]\n                                                (some #(zero? (mod n %)) ps))\n                                              (iterate inc p) ))]\n                   (cons p (lazy-seq (primes (conj ps nxt))))))\n              [2])))", "user": "58e37946e4b005f69f193cae"}, {"problem": 67, "code": "(fn [n] \n  (let [is-prime (fn [n] (every? #(not= % 0) (map #(mod n %) (range 2 n))))]\n    (take n (filter is-prime (iterate #(+ % 1) 2)))))", "user": "58edaa3be4b056aecfd47d89"}, {"problem": 67, "code": "#(letfn [(prime? [n]\n           (cond\n            (zero? (mod n 3)) false\n            :else (loop [i 5]\n                    (if (> (* i i) n)\n                      true\n                      (if (or (zero? (mod n i))\n                              (zero? (mod n (+ 2 i))))\n                        false\n                        (recur (+ 6 i)))))))]\n   (take % (concat '(2 3)\n                   (filter prime? (iterate (partial + 2) 5)))))", "user": "58e58ae9e4b056aecfd47c9a"}, {"problem": 67, "code": "(fn prime-numbers [x]\n  (letfn [(prime? [n]\n            (not-any? #(zero? (rem n %)) (range 2 (inc (Math/sqrt n)))))]\n    (cons 2 (take (dec x) (filter prime? (iterate #(+ % 2) 3))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 67, "code": "(fn [n]\n  (->>\n   (drop 2 (range))\n   (filter\n    #(loop [c 2]\n       (cond (> (* c c) %) true\n             (= (rem % c) 0) false\n             :else (recur (inc c)))))\n   (take n)))", "user": "58ebae90e4b056aecfd47d44"}, {"problem": 67, "code": "(fn primes [p]\n  (if (= p 1)\n    [2]\n    (let [prim (primes (- p 1))]\n      (conj prim\n        (first (filter\n          (fn [i] (every? #(< 0 (mod i %)) prim))\n          (range (last prim) (* 2 (last prim)))))))))", "user": "58a1f61ae4b02bd94d917ecd"}, {"problem": 67, "code": "(fn [n]\n  (take\n   n\n   (cons\n    2\n    (filter\n     (fn [k]\n       (every?\n        #(< 0 (rem k %))\n        (range 2 (inc (int (Math/floor (Math/sqrt k)))))))\n     (iterate #(+ 2 %) 3)))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 67, "code": "(fn [n] \n  (take n\n  \t(remove nil?\n\t\t(for [i (iterate inc 2)]\n   \t\t\t(when (empty? (filter #(= 0 (mod i %)) (range 2 i)))\n     \t\t\ti)))))", "user": "56f881e0e4b08e7d20b96839"}, {"problem": 67, "code": "(fn [x]\n (take\n  x\n  ((fn find-p [prevs [maybep & more]]\n    (let\n     [is-prime (not (first\n                 (filter\n                  #(=\n                    0\n                    (mod\n                     maybep\n                     %))\n                  prevs)))]\n     (if\n      is-prime\n      (lazy-seq\n       (cons\n        maybep\n        (find-p\n         (lazy-seq\n          (cons\n           maybep\n           prevs))\n         more)))\n      (recur prevs more))))\n      ()\n      (drop 2 (range)))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 67, "code": "(fn\n  [x]\n  (take x\n        (filter (fn [n]\n                  (if (= n 2)\n                    true\n                    (not-any? #(= 0 (mod n %))\n                              (range 2 (inc (Math/sqrt n))))))\n                (iterate inc 2))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 67, "code": "(fn [c](take c (filter (fn [n](not-any?  #(zero?  (mod n %1)) (range 2 n))) (iterate inc 2))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 67, "code": "#(take % [\n 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71    73 79 83 89 97 101 103 107 109 113    127 131 137 139 149 151 157 163 167 173    179 181 191 193 197 199 211 223 227 229    233 239 241 251 257 263 269 271 277 281    283 293 307 311 313 317 331 337 347 349    353 359 367 373 379 383 389 397 401 409    419 421 431 433 439 443 449 457 461 463    467 479 487 491 499 503 509 521 523 541    547 557 563 569 571 577 587 593 599 601    607 613 617 619 631 641 643 647 653 659    661 673 677 683 691 701 709 719 727 733    739 743 751 757 761 769 773 787 797 809    811 821 823 827 829 839 853 857 859 863    877 881 883 887 907 911 919 929 937 941    947 953 967 971 977 983 991 997 1009 1013    1019 1021 1031 1033 1039 1049 1051 1061 1063 1069    1087 1091 1093 1097 1103 1109 1117 1123 1129 1151    1153 1163 1171 1181 1187 1193 1201 1213 1217 1223    1229 1231 1237 1249 1259 1277 1279 1283 1289 1291    1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451    1453 1459 1471 1481 1483 1487 1489 1493 1499 1511    1523 1531 1543 1549 1553 1559 1567 1571 1579 1583    1597 1601 1607 1609 1613 1619 1621 1627 1637 1657    1663 1667 1669 1693 1697 1699 1709 1721 1723 1733    1741 1747 1753 1759 1777 1783 1787 1789 1801 1811    1823 1831 1847 1861 1867 1871 1873 1877 1879 1889    1901 1907 1913 1931 1933 1949 1951 1973 1979 1987    1993 1997 1999 2003 2011 2017 2027 2029 2039 2053    2063 2069 2081 2083 2087 2089 2099 2111 2113 2129    2131 2137 2141 2143 2153 2161 2179 2203 2207 2213    2221 2237 2239 2243 2251 2267 2269 2273 2281 2287    2293 2297 2309 2311 2333 2339 2341 2347 2351 2357    2371 2377 2381 2383 2389 2393 2399 2411 2417 2423    2437 2441 2447 2459 2467 2473 2477 2503 2521 2531    2539 2543 2549 2551 2557 2579 2591 2593 2609 2617    2621 2633 2647 2657 2659 2663 2671 2677 2683 2687    2689 2693 2699 2707 2711 2713 2719 2729 2731 2741    2749 2753 2767 2777 2789 2791 2797 2801 2803 2819    2833 2837 2843 2851 2857 2861 2879 2887 2897 2903    2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 \n ]\n)", "user": "5823d3e6e4b051871117beb8"}, {"problem": 67, "code": "(letfn\n    [(indivisible? [n pl]\n            (not-any? #(zero? (rem n %)) pl))\n\n     (next-prime [pl]\n       (if (empty? pl)\n         2\n         (let [last-prime (peek pl)]\n           (first (filter #(indivisible? % pl)\n                          (iterate inc last-prime))))))]\n    (fn primes\n      ([n]\n       (primes n []))\n      \n      ([n acc]\n       (if (zero? n)\n         acc\n         (recur (dec n) (conj acc (next-prime acc)))))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 67, "code": "(fn [n] (loop [primes [] x 2] (if (= (count primes) n) primes (recur (if (some #(zero? (mod x %)) (take-while #(<= (* % %) x) primes)) primes (conj primes x)) (inc x)))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 67, "code": "(fn [cnt]\n   (letfn [(isPrime [val]\n             (empty? (filter #(= 0 %) (take (- val 2) (map #(rem val %) (iterate inc 2 ))))))]\n    \n    (take cnt (filter isPrime (iterate inc  2)) ) )\n   )", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 67, "code": "(fn prime-numbers [right-bound]\n  (take right-bound (letfn [( prime? [n]\n                             (if (= n 2)\n                               true\n                               (every? #(not (zero? (mod n %))) (range 2 n))))]\n                      (filter prime? (map #(+ 2 %) (range))))))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 67, "code": "(fn [r c]\r\n  (take c\r\n\t(remove #(some (fn [i] (= (mod % i) 0)) (r 2 %))\r\n\t\t(r 2 1e3))))\r\nrange", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 67, "code": "(fn x-primes [x]\n  (let [x-factors (fn factors [n] (->> n range (map inc) (filter #(zero? (mod n %))) set))\n         x-prime? (fn [n] (->> (x-factors n) (count) (= 2)))]\n        (->> (range)\n             (filter x-prime?)\n             (take x))))", "user": "58db097fe4b0a4d5acaab66f"}, {"problem": 67, "code": "(fn first-n-primes [n]\n     (letfn [(is-prime? [x]\n               (letfn [(prime-iter [i num root]\n                         (cond\n                           (> i root) true\n                           (= 0 (rem num i)) false\n                           :else (recur (inc i)  num root)))]\n                 (prime-iter 2 x (dec x))))\n             (next-prime [x]\n               (if (is-prime? (inc x)) (inc x)\n                   (recur (inc x))))]\n       (take n (iterate next-prime 2))))", "user": "58ef4db9e4b056aecfd47dc6"}, {"problem": 67, "code": "#(take %1 ((fn prime-numbers\n                     ([] (prime-numbers 2))\n                     ([n] (lazy-seq (cons n (prime-numbers ((fn findnextprime\n                                                              [num]\n                                                              (loop [num (inc num)]\n                                                                (if (loop [num num\n                                                                           d (- num 1)]\n                                                                      (if (= d 1)\n                                                                        true\n                                                                        (if (= (mod num d) 0)\n                                                                             false\n                                                                             (recur num (- d 1)))))\n                                                                  num\n                                                                  (recur (inc num)))))\n                                                            n)))))) 2))", "user": "5801eed1e4b0a837a8b30c63"}, {"problem": 67, "code": "(fn x-primes [x]\n  (let [factors (fn [n]\n \t(->> n\n      range\n      (map inc)\n      (filter #(zero? (mod n %)))))\n  prime? (fn [n]\n   (->> (factors n)\n        (count)\n        (= 2)))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "58eac340e4b056aecfd47d24"}, {"problem": 67, "code": "(fn [k]\n  (letfn [\n    (prime? [n]\n      (cond\n        (<= n 1) false\n        (<= n 3) true\n        (or (= 0 (rem n 2)) (= 0 (rem n 3))) false\n        :else\n          (loop [i 5]\n            (cond\n              (> (* i i) n) true\n              (or (= 0 (rem n i)) (= 0 (rem n (+ i 2)))) false\n              :else (recur (+ i 6))))))]\n    (->> (range) (filter prime?) (take k))))", "user": "5901158de4b0438e51c2d039"}, {"problem": 67, "code": "(fn [n] (->> [2] \n             (iterate (fn [ps] (conj ps (first (filter (fn [m] (not-any? #(zero? (mod m %)) ps)) \n                                                       (iterate inc (last ps))))))) \n             (filter #(= n (count %))) \n             (first)))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 67, "code": "(fn [n] (take n (cons 2 (rest (filter (fn [x] (= (count (filter #(= (mod x %) 0) (cons 2 (range 3 (inc (Math/sqrt x)) 2)))) 0)) (range))))))", "user": "4e5e9f6b535d8a8b8723a2d2"}, {"problem": 67, "code": "(fn [k]\n  (take k\n    (filter\n      (fn prime? [n]\n         (not-any?\n           #(= 0 (mod n %))\n           (range 2 (Math/sqrt (inc n)))))\n      (iterate inc 2))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 67, "code": "(fn ccc\n             ([a] (vec (ccc (sorted-set 2 3) {2 4, 3 3} (- a 2) 5)))\n             ([res ma index x]\n               (let [\n                     newMa (reduce\n                             (fn [acc item]\n                               (let [\n                                     actual (acc item)\n                                     ]\n                                 (if actual\n                                   (if (< actual x)\n                                     (assoc acc item (+ actual item item))\n                                     acc\n                                     )\n                                   (assoc acc item item)\n                                   )\n                                 )\n                               )\n                             ma\n                             res)\n                     ]\n                 (if (zero? index)\n                   res\n                   (if (some (fn [v] (= v x)) (vals ma))\n                     (ccc res newMa index (+ 2 x))\n                     (ccc (conj res x) newMa (dec index) (+ 2 x))\n                     )\n                   )\n                 )))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 67, "code": "#(take %2 (reduce (fn [s n]\n                    (if (not-any? (fn [i] (= 0 (mod n i))) s)\n                      (conj s n)\n                      s)) [] %)) (range 2 999)", "user": "58b86162e4b0ebc645576d97"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [n]\n                    (let [x n]\n                      (loop [a x\n                             f 2\n                             t (int (Math/sqrt x))]\n                        (cond\n                          (> f t) true\n                          (zero? (mod a f)) false\n                          :else (recur a (inc f) t)))))\n                  (map #(+ 2 %) (range)))))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 67, "code": "(fn [n]\n  (let [\n        mx (if (< n 6)\n             13 \n             (inc (Math/ceil (* n (Math/log (* n (Math/log n)))))))\n        smx (inc (Math/ceil (Math/sqrt mx)))]\n    (take n (reduce (fn [acc, elem]\n              (filter #(or (<= % elem) (not= 0 (mod % elem))) acc))\n            (range 2 mx)\n            (range 2 smx)))))", "user": "588e4e05e4b00487982d5188"}, {"problem": 67, "code": "(fn [z]\n  (take z\n    (remove nil?\n      (let [forev (drop 2 (range))]\n        (for [x forev]\n          (if ((fn [n]\n                 (let [divisors (range 2 (inc(int(Math/sqrt n))))\n                       remainders (map #(rem n %)divisors)]\n                   (not (some #(= 0 %) remainders)))) x)\n            x))))))", "user": "5822b578e4b04b46fc4b0fa4"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [num]\n                    (loop [end (int (Math/sqrt num)), div 2, re (rem num div)]\n                      (cond\n                        (< num 2) false\n                        (= num 2) true\n                        (= re 0) false\n                        (> div end) true\n                        :else (recur end (inc div) (rem num div)))\n                      )) (range))))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 67, "code": "(fn [a]\n   (let [ip (fn [x] (not-any? #(= 0 (mod x %1)) (range 2 x)))]\n      (take a (filter ip (iterate inc 2)))))", "user": "5910a43de4b0163c97b36ebf"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n                  (= 2 (count (filter #(zero? (rem x %)) (map inc (range x))))))]\n    (take n (filter prime? (range)))))", "user": "59074b7ce4b047aa04b19951"}, {"problem": 67, "code": "(fn [n]\n            (let [nextp (fn [li] \n                           (loop [k (inc (last li))\n                                  t (rest li)\n                                  h (first li)]\n                             (if (> (* h h) k)\n                               k\n                               (if (= 0 (rem k h))\n                                 (recur (inc k) li h)\n                                 (recur k (rest t) (first t))))))]\n      (cond (= n 0) []\n            (= n 1) [2]\n            :else (reduce (fn [x _] (conj x (nextp x))) [2] (range (- n 1))))))", "user": "59156f0be4b0163c97b36f3d"}, {"problem": 67, "code": "(fn [n]\n  (loop [found #{}\n         current 2]\n    (if (< (count found) n)\n      (if (some #(= 0 (mod current %)) found)\n        (recur found (inc current))\n        (recur (conj found current) (inc current)))\n      (sort (seq found)))))", "user": "55f5b8d6e4b06e875b46ce8d"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime? [x]\n                     (empty?\n                      (filter #(zero? (rem x %)) (range 2 (dec x)))))]\n    (->> (range)\n         (drop 2)\n         (filter is-prime?)\n         (take n))))", "user": "58ffac9de4b0438e51c2cffd"}, {"problem": 67, "code": "(fn primes\n\t[x]\n\t(take x\n\t\t((fn generator\n\t\t\t[res n] \n\t\t\t(if (some #(= 0 (mod n %)) (take-while #(>= (Math/sqrt n) %) res))\n\t\t\t\t(recur res (inc n))\n\t\t\t\t(lazy-seq (cons n (generator (conj res n) (inc n))))))\n\t\t[] 2)))", "user": "58fb7d7ae4b0438e51c2cf7a"}, {"problem": 67, "code": "(fn\n  [n]\n  (take\n   n \n   (filter \n    (fn [x] (nil? (some #(= 0 (mod x %)) (range 2 (Math/sqrt (inc x)))))) \n    (drop 2 (range)))))", "user": "5640b135e4b08d4f616f5ee8"}, {"problem": 67, "code": "(fn [n]\n   (letfn [(is-prime [x ps]\n             (every? #(not= (rem x %) 0) ps))]\n     (loop [x 3\n            ps (sorted-set 2)]\n       (if (>= (count ps) n)\n         (vec ps)\n         (if (is-prime x ps)\n           (recur (inc x) (conj ps x))\n           (recur (inc x) ps)))\n       )))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 67, "code": "(fn [x]\n  (loop [agg [2]\n         n 3]\n    (if (= x (count agg))\n      agg\n      (recur\n        (if (not-any? #(= 0 (mod n %)) (take-while #(<= (* % %) n) agg))\n          (conj agg n)\n          agg)\n        (inc n)))))", "user": "57cd7498e4b0c746388ab897"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime-stream [coll]\n                        (lazy-seq \n                         (cons (first coll)\n                               (prime-stream (filter #(not= 0 (rem % (first coll)))\n                                                     (rest coll))))))]\n    (take n (prime-stream (drop 2 (range))))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 67, "code": "(fn [l] (take l (filter #(.isProbablePrime (BigInteger/valueOf %) 5) (range))))", "user": "591f05b4e4b09b4ee5954c42"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter (fn [x]\n                  (->> x\n                       (range 2)\n                       (map #(rem x %))\n                       (some zero?)\n                       not))\n                (drop 2 (range)))))", "user": "57233cc8e4b0c5bde472c0e1"}, {"problem": 67, "code": "(fn t [n]\n (loop [primes []\n        x 2]\n  (if (= n (count primes))\n    primes\n    (recur\n     (if (empty? (filter #(= 0 (mod x %)) (range 2 x)))\n(conj primes x)\nprimes)\n     (inc x)))))", "user": "589b98fae4b00487982d533c"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(primes [current wheel]\n            (if-let [strikes (get wheel current)]\n              (recur (+ current 2)\n                     (reduce (fn [newheel strike]\n                               (let [index (+ current (* 2 strike))\n                                     buck (get newheel index [])]\n                                 (println index buck)\n                                 (assoc newheel index (conj buck strike))))\n                             (dissoc wheel current)\n                             strikes))\n              (lazy-seq (cons current\n                              (primes (+ current 2)\n                                      (assoc wheel (* current 3) [current]))))))]\n    (cons 2 (take (dec x) (primes 3 {})))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x y]\n                  (if (< y 2)\n                    true\n                  \t(if (-> (mod x y)\n                            (= 0))\n                      false\n                      (recur x (dec y)))))]\n    (->> (iterate inc 2)\n    \t (filter #(prime? % (quot % 2)))\n         (take n))))", "user": "58740c18e4b01531a375ea49"}, {"problem": 67, "code": "(fn primes [n]\n  (take n (filter #(not-any? \n    (fn [a] (zero? (rem % a))) \n    (range 2 (dec %))) (iterate inc 2))))", "user": "5933b736e4b072a2710fd05d"}, {"problem": 67, "code": "(fn [n]\n   (->> (iterate inc 2)\n        (filter (fn [x] (not-any? #(zero? (mod x %))\n                                  (range 2 (+ 0.01 (Math/sqrt x))))))\n        (take n)))", "user": "5935b010e4b04f87174def55"}, {"problem": 67, "code": "(fn [n] \n  (loop [c 0 i 2 ans '()]\n    (if (= n (count ans))\n      (reverse ans)\n      (if ((fn [numb] \n             (loop [pos 2]\n               (if (= pos numb)\n                 true\n              \t (if (= 0 (mod numb pos))\n                 \tfalse\n                 \t(recur (inc pos)))))) i)\n        (recur (inc c) (inc i) (conj ans i))\n        (recur c (inc i) ans)))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 67, "code": "(fn [numb] ;this fuction feeds numbers to the prime checker and makes sure only the first n returned.\n  (loop [ny numb, i 2, primes []]\n    (if (= 0 ny)\n      primes\n      (do (if ((fn [numy] ;this inner function checks if \"i\" is prime. \n                (loop [devides [], n 1]\n                  (if (= numy n)\n                    (if (= (count devides) 1)\n                      true\n                      false)\n                    (if (zero? (rem numy n))\n                      (recur (conj devides n) (inc n))\n                      (recur devides (inc n))))))i)\n            (recur (dec ny) (inc i) (conj primes i))\n            (recur ny (inc i) primes))))))", "user": "59369515e4b02506e01a297e"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "59368efbe4b02506e01a297d"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 2 primes [] tmpn n]\n    (if (= tmpn 0)\n      primes\n      (if ((fn [number]\n             (loop [nmbr (- number 1)]\n               (if (= nmbr 1)\n                 true\n                 (if (= (rem number nmbr) 0)\n                   false\n                   (recur (dec nmbr)))))) i)\n        (recur (inc i) (conj primes i) (dec tmpn))\n        (recur (inc i) primes tmpn)))))", "user": "59368ccae4b02506e01a2979"}, {"problem": 67, "code": "(fn primes [k] \n\t(letfn [(prime? [n] (if (< n 2) false\n                     (loop [iter 2 top (int (Math/sqrt n))]\n                       (if (> iter top)\n                         true\n                         (if (= 0 (mod n iter))\n                           false\n                           (recur (inc iter) top))))\n                     ))]\n  \n  \t(take k (filter prime? (range 1000)))))", "user": "591d9870e4b09b4ee5954c1b"}, {"problem": 67, "code": "(fn prast\n  ;; recimo, da imam seznam prastevil\n  ;; vzamem zadnjo in ji pristejem 1\n  ;; pogledam, ce je prastevilo\n  ;; ce ni, jo pripnem, ce ne povecam stevilo\n  ([x] (prast x 3 [2]))\n  ([x kandidat sekv]\n  (if (= (count sekv) x) sekv\n      (if (nil? (some zero? (map #(rem kandidat %1) sekv)))\n        (prast x (inc kandidat) (conj sekv kandidat))\n        (prast x (inc kandidat) sekv)\n        )))\n  )", "user": "584d99c5e4b0b7285a6f4e42"}, {"problem": 67, "code": "#(take %\n  (filter (fn [n] \n  (not\n    (re-matches #\"^1?$|^(11+?)\\1+$\" (apply str (repeat n \\1)))))\n    (range)))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 67, "code": "(fn get-prime\n  [m]\n  (let [iter (fn iter [n i]\n               (cond (= n i) true\n                 (zero? (rem n i)) false\n                   :else (iter n (+ i 2))))\n        prime? (fn [n] \n                  (cond (<= n 1) false\n                    (= n 2) true\n                    (even? n) false\n                    :else (iter n 3)))]\n    (take m (filter prime? (range 600)))))", "user": "59390a35e4b02506e01a29f3"}, {"problem": 67, "code": "(fn [n]\n  (let [divisible-by? (fn [divisor number] (zero? (mod number divisor)))\n        is-prime? (fn [coll number] (every? #(not (divisible-by? % number)) coll))\n        prime-helper (fn bar [coll candidate left]\n                       (cond\n                         (zero? left) coll\n                         (is-prime? coll candidate) (bar (conj coll candidate) (+ 2 candidate) (dec left))\n                         :else (bar coll (+ 2 candidate) left)))]\n    (prime-helper [2] 3 (dec n))))", "user": "53ae0c50e4b047364c044471"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime? (fn [x] (loop [r true i 2] (if (or (= r false) (> i (quot x 2))) r (recur (not= 0 (mod x i)) (inc i)))))\n        next-prime (fn [x] (if (is-prime? x) x (recur (inc x))))\n        primes (fn p\n                 ([] (cons 2 (p 3)))\n                 ([x]\n                  (lazy-seq (cons x (p (next-prime (+ x 2)))))))]\n    (take n (primes))))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 67, "code": "(fn f [x]\n  (loop [acc x, n 2, res []]\n    (if (= acc 0)\n      res\n      (if ((fn premier? [i] \n            (loop [k (- i 1), res true]\n              (if (= 1 k)\n                res\n                (recur (dec k) (if (= 0 (rem i k))\n                                 false\n                                 res))))) n)\n        (recur (dec acc) (inc n) (conj res n))\n        (recur acc (inc n) res)))))", "user": "593d6793e4b069cdc2982ba6"}, {"problem": 67, "code": "(fn [x]\n          (loop [n 2\n                 coll []]\n              (if (>= (count coll) x)\n                coll\n                (let [sr (int (java.lang.Math/sqrt n))]\n                (recur\n                 (inc n)\n                 (if (empty? (filter #(zero? (mod n %)) (range 2 (inc sr))))\n                   (conj coll n)\n                   coll))))))", "user": "59438419e4b060784b3b7929"}, {"problem": 67, "code": "(fn [x]\n     (take x\n           (remove \n             (fn [n] \n               (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n             (iterate inc 2)\n\t\t\t )\n\t)\n)", "user": "592518cde4b072a2710fce66"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5938bae2e4b02506e01a29ea"}, {"problem": 67, "code": "(fn [n]\n  (let [nums (iterate inc 2)\n        primes (fn primes [nums]\n                  (let [p (first nums)\n                        r (filter #(not= 0 (mod % p)) (rest nums))]\n                    (cons p (lazy-seq (primes r)))\n                  )\n               )\n      ]\n    (take n (primes nums))\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 67, "code": "(fn [x] \n  (loop [d #{2}\n         i 3]\n    (if (= x (count d))\n     (sort (vec d))\n      ;add i to d unless i is divisiable by an element of d\n      (if (contains? (set (map (fn [y] (rem i y)) d)) 0)\n      \t(recur d (inc i))\n        (recur (conj d i) (inc i))))))", "user": "593744abe4b02506e01a299b"}, {"problem": 67, "code": "(fn rprime [n]\n  (let [prime\n        (fn prime [n]\n          (let [step\n                (fn [i c]\n                  (if (some #(= 0 (mod i %)) c)\n                    (recur (inc i) c)\n                    i))]\n            (case n\n              0 []\n              1 [2]\n              (let [prev (prime (dec n))]\n                (cons (step (inc (first prev)) prev) prev)))))]\n    (reverse (prime n))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 67, "code": "(fn [n]\n    (let [top 1000\n          screen (fn [x] #(filter (fn [p] (or (= p x) (not= 0 (mod p x)))) %))]\n    (take n\n          ((apply comp (for [i (range 2 (/ top 2))] (screen i))) (range 2 top)))\n    )\n  )", "user": "54965534e4b0b312c081ff65"}, {"problem": 67, "code": "(fn [n]\n  (loop [cur 2\n         res []]\n    (let [filt #(= (mod cur %) 0)\n          dels (filter filt (range 2 cur))\n          newres (if (> (count dels) 0) res (conj res cur))]\n      (if (= (count res) n)\n        res\n        (recur (inc cur) newres)))))", "user": "592334c7e4b0a390037439ee"}, {"problem": 67, "code": "(fn find-primes [n]\n  (loop [primes [2]]\n    (if (= (count primes) n)\n      primes\n      (recur (conj\n               primes\n               (first\n                 (filter (fn [p?]\n                           (every? #(< 0 (mod p? %)) primes))\n                         (iterate inc (inc (last primes))))))))))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 67, "code": "(fn [x]\n     (take x\n           (remove \n             (fn [n] \n               (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))\n             (iterate inc 2)\n\t\t\t )\n\t)\n)", "user": "592518e8e4b072a2710fce67"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n                     (if (pos? x)\n                       (if (prime? n pvec)\n                         (recur (dec x) (+ n 2) (conj pvec n))\n                         (recur x (+ n 2) pvec))\n                       pvec))]\n    (gen-primes (dec x) 3 [2])))", "user": "595a885be4b066ee0a44afc4"}, {"problem": 67, "code": "(fn [x] \n  (->> \n   (range)\n   (filter (fn [n]\n             (cond\n              (<= n 1) false\n              (<= n 3) true\n              (zero? (mod n 2)) false\n              (zero? (mod n 3)) false\n              (some #(or (zero? (mod n %)) \n                         (zero? (mod n (+ % 2))))\n                    (take-while #(>= n (* % %)) (range 5 n 6))) false\n              :else true)))\n   (take x)))", "user": "5956c6dae4b066ee0a44af61"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [t] (every? #(not= 0 (rem t %)) (range 2 t))) (drop 2 (range)))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "59251947e4b072a2710fce69"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n                     (if (pos? x)\n                       (if (prime? n pvec)\n                         (recur (dec x) (+ n 2) (conj pvec n))\n                         (recur x (+ n 2) pvec))\n                       pvec))]\n    (gen-primes (dec x) 3 [2])))", "user": "590088bfe4b0438e51c2d026"}, {"problem": 67, "code": "(fn [n] (let [next-prime (fn [prev m] \n                           (let [next-p (first (filter (fn [next-p] (every? #(not= 0 (rem next-p %)) m)) (iterate inc prev)))]\n                             [next-p (conj m next-p)]))]\n          (map first (take n (iterate (partial apply next-prime) [2 #{2}])))))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 67, "code": "#(take % ((fn prime [primes candidate]\n              (if (some (fn [x] (= 0 (rem candidate x))) primes)\n                (recur primes (inc candidate))\n                (cons candidate (lazy-seq\n                                 (prime (conj primes candidate) (inc candidate)))))) [] 2))", "user": "595bbab7e4b066ee0a44afe0"}, {"problem": 67, "code": "(fn [target-amount]\n(let [isPrime (fn [x]\n  (if (< x 2)\n  false\n  (empty? (filter\n    (fn [n] (= 0 (mod x n)))\n    (range 2 (inc (int (/ x 2))))))))]\n\n((fn findprimes [found i]\n  (if (= (count found) target-amount)\n    found\n    (findprimes (if (isPrime i) (conj found i) found) (inc i)))\n)\n[] 0)\n))", "user": "5881d1c2e4b0f1effa3b7644"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn p [s]\n             (lazy-cat [(first s)]\n                       (p (remove #(= 0 (mod % (first s)))\n                                  (next s))))) \n           (iterate inc 2))))", "user": "595eba88e4b066ee0a44b04e"}, {"problem": 67, "code": ";; sieve algorithm\n(fn [n]\n  (take n\n        (let [intsFrom2 (iterate inc 2)\n              primes (fn primes [[x & xs]]\n                       (lazy-seq (cons x\n                                       (primes (filter #(not= 0 (mod % x))\n                                                       xs)))))]\n          (primes intsFrom2))))", "user": "595fd721e4b066ee0a44b06e"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2] numb 3]\n    (if (= (count primes) n)\n      primes\n      (if (every? identity (map #(not= (mod numb %) 0) primes))\n        (recur (conj primes numb) (inc numb))\n        (recur primes (inc numb))))))", "user": "59497f51e4b07ddc2dafaddd"}, {"problem": 67, "code": "#(take % (filter (fn prime?\n                   [n]\n                   (let [iter (fn iter [i]\n                                (cond (= n i) true\n                                      (zero? (rem n i)) false\n                                      :else (iter (inc i))))]\n                     (cond (<= n 1) false\n                           (= n 2) true\n                           :else (iter 2)))) (range 542)))", "user": "593910eae4b02506e01a29f4"}, {"problem": 67, "code": "(letfn\n   [(is-prime? [n]\n      (cond\n        (>= n 2)\n          (loop [p 2]\n            (if (<= (* p p) n)\n              (cond\n                (zero? (mod n p)) false\n                :else (recur (inc p)))\n              true))\n        :else false))\n    (primes-from [n threshold]\n      (cond\n        (= n 0) '()\n        :else\n          (if (is-prime? threshold)\n            (cons threshold (primes-from (dec n) (inc threshold)))\n            (primes-from n (inc threshold)))))]\n  (fn [n] (primes-from n 0)))", "user": "56078b7be4b08b23635d3181"}, {"problem": 67, "code": "(fn calc-primes\n\t([amount]\n\t\t(calc-primes amount 2 []))\n\t([amount number primes]\n\t\t(if (zero? amount)\n\t\t\tprimes\n\t\t\t(if (empty? primes)\n\t\t\t\t(recur (dec amount) (inc number) (conj primes number))\n\t\t\t\t(if (every? #(= % false) (map #(zero? (rem number %)) primes))\n\t\t\t\t\t(recur (dec amount) (inc number) (conj primes number))\n\t\t\t\t\t(recur amount (inc number) primes))))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 67, "code": "(fn solution67\n  [n]\n  (loop [i    0\n         curr []\n         num  2]\n    (if (= i n)\n      curr\n      (let [is-divisible  (map (fn [x] (= 0 (rem num x))) curr)\n            rly           (filter (fn [x] x) is-divisible)]\n        (if (empty? rly)\n          (recur (inc i) (conj curr num) (inc num))\n          (recur i curr (inc num)))))))", "user": "595bc925e4b066ee0a44afe2"}, {"problem": 67, "code": "(fn [n-primes]\n  (loop [[curr poly] [1 #{}]\n         primes []]\n    (let [[p new-poly] ((fn [last-p in-poly]\n  \t\t\t\t\t\t\t(loop [curr (inc last-p)\n           \t\t\t\t\t\t   poly in-poly]\n      \t\t\t\t\t\t\t(let [new-poly (into (disj poly curr) (map #(* curr %) (range 2 (inc curr))))]\n        \t\t\t\t\t\t\t(if (contains? poly curr) (recur (inc curr) new-poly) [curr new-poly])\n        \t\t\t\t\t\t)\n      \t\t\t\t\t\t)\n  \t\t\t\t\t\t)\n \t\t\tcurr poly)]\n         (if (= n-primes (count primes)) primes (recur [p new-poly] (conj primes p))))\n  )\n)", "user": "59073e0fe4b047aa04b19950"}, {"problem": 67, "code": "#(take % (filter (fn is-prime [n]\n  (if (> n 1)\n    (loop [x (dec n)\n           prime true]\n      (if (or (<= x 1) (= false prime))\n        prime\n        (recur (dec x)\n               (not= 0 (rem n x)))))\n    false)) (range)))", "user": "595d224de4b066ee0a44b016"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(p [[x & xs]]\n             (lazy-seq (cons x (p (remove #(= 0 (rem % x)) xs)))))]\n    (take n (p (range 2 Double/POSITIVE_INFINITY 1)))))", "user": "594bc16be4b07ddc2dafae39"}, {"problem": 67, "code": "#(take % (filter (fn [p] (not-any? (fn [n] (zero? (mod p n))) (range 2 p))) (drop 2 (range))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 67, "code": "(fn nprimes [cnt]\n  (cond (> cnt 1) (let [prime? (fn [n]\n                 (not (some #(and (not= n %) (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (cons 2 (take (dec cnt) (filter prime? (filter odd? (iterate inc 2))))))\n    (= cnt 1) '(2)\n    :else {}))", "user": "5972fcf6e4b01722bebd4c92"}, {"problem": 67, "code": "(fn [x] (take x (filter #(not (nil? %)) (map (fn is_prm[n] (if-not (some \n                                                    #(= (mod n %) 0) \n                                                    (range 2 (inc (/ n 2)))\n                                                    ) n nil  )) (drop 2 (range)))))\n)", "user": "596f6683e4b069c0a1a19877"}, {"problem": 67, "code": "(fn primenums\n  [n]\n  (take n (filter (fn [param1] (every? #(not= % 0) (map #(rem param1 %) (range 2 param1)))) (iterate inc 2)) )\n\n  )", "user": "59692530e4b069c0a1a197e4"}, {"problem": 67, "code": "(fn f [[x & xs] n] (when (pos? n) (cons x (f (remove #(= 0 (mod % x)) xs) (dec n))))) (drop 2 (range))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 67, "code": "(fn take-primes\n  [n]\n  \"Eratosthenes Sieve\"\n  (letfn [(prime? [prime-sieves x]\n            (let [sieve (fn[prime x](some #(= x %) (range (* prime prime) (+ x prime) prime)))]\n              (every? nil? ((apply juxt (for [s prime-sieves] #(sieve s %))) x))))]\n    (loop [sieves [2] primes [2] start [3]]\n      (if (= (count primes) n)\n        primes\n        (recur (filter #(< (* % %) (+ 2 (first start))) primes)\n               (concat primes (filter #(prime? sieves %) start))\n               [(inc (first start))])))))", "user": "56163cc1e4b06b1bb21829ff"}, {"problem": 67, "code": ";;; modified answer\n\n(fn [n]\n  (take n\n    (filter\n      (fn [x]\n        (not-any?\n          #(zero? (mod x %))\n          (range 2 x)))\n      (iterate inc 2))))\n\n;;; my original--worked on local, but timed out on this site, probably because the \"for\" loop had to actually create a new sequence\n\n;(fn [n]\n;  (take n\n;    (filter\n;      #(every? true?\n;        (for [i (range 2 %)]\n;          (not= 0 (mod % i))))\n;      (iterate inc 2))))\n\n\n;;; online answer--logic is a little muddy\n;(fn [n]\n;  (take n\n;    (filter \n;      (fn is-prime [n]\n;        (nil?\n;          (some\n;            #(zero? (mod n %))\n;            (range 2 n))))\n;      (range 2 1000))))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 67, "code": "(fn [nb]\n   (take nb (filter (fn [num]\n                      (empty? (filter #(= 0 (mod num %) ) (range 2 (dec num))))\n                      ) (drop 2 (range))))\n   )", "user": "583f1533e4b089d5ab817dc8"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 1) [2]\n      (if (= n 2) [2 3]\n          (loop [k 5 p [2 3]]\n            (if (= n (count p)) p\n                (if (not-any? #(= 0 (mod k %)) p)\n                  (recur (inc k) (conj p k))\n                  (recur (inc k) p)))))))", "user": "587ee260e4b052da650a6353"}, {"problem": 67, "code": "(fn [x]\n   (let [rems #(map (partial rem %) (range 2 %))\n         prime? #(nil? (some zero? (rems %)))]\n     (take x (filter prime? (iterate inc 2)))))", "user": "5978c844e4b01722bebd4d18"}, {"problem": 67, "code": "(fn [x] (take x \n              (filter (fn [n] (not-any? #(= 0 (mod n %)) (range 2 n)) ) \n                      (iterate inc 2))))", "user": "594263cbe4b060784b3b790a"}, {"problem": 67, "code": "(fn [a] (take a (remove nil? (drop 2 (map #(if (nil? (some #{true} (drop-last (map (fn [n]\n                                                                                           (= (mod % n) 0))\n                                                                                         (range 2 (inc %))))))\n                                                   % ) (range))))))", "user": "591e0782e4b09b4ee5954c25"}, {"problem": 67, "code": "(fn primes\n    [n]\n    (let [is-prime (fn [x] (nil? (some #(= 0 (rem x %)) (range 2 x))))\n          primes-seq (filter is-prime (iterate inc 2))]\n        (take n primes-seq)))", "user": "58fc52cee4b0438e51c2cf95"}, {"problem": 67, "code": "(fn [n] (loop [primes [2] i 3] (if (= n (count primes)) primes (if (reduce (fn [isprime e] (and isprime (not (= 0 (mod i e))))) true primes) (recur (conj primes i) (inc i)) (recur primes (inc i))))))", "user": "59468de7e4b07ddc2dafad88"}, {"problem": 67, "code": "(fn [n]\n  (let [e? #(zero? (rem %1 %2))\n        p? (fn [x] (not-any? #(e? x %) (range 2 x)))\n        xs (map #(+ 2 %) (range))]\n    (->> xs (filter p?) (take n))))", "user": "5884f377e4b0f1effa3b76a8"}, {"problem": 67, "code": "(fn primes\n  ([n] (primes [] 2 n))\n  ([result current n]\n   (if (= (count result) n)\n     result\n     (primes\n      (if\n       (empty?\n        (remove \n         #(pos? (mod current %))\n         result))\n       (conj result current)\n       result)\n      (inc current) n))))", "user": "598ab445e4b02b9968b84ce0"}, {"problem": 67, "code": "(fn primes [n]\n  ;n-th prime approximaton here, to find sieve size\n  (let [\n        sieve-limit (+ 10 (int (+ (* n (Math/log n)) (* n (Math/log (Math/log n))))))\n        nullfiy-indexes #(loop [indexes (vec %2) items (vec %1)] (if (empty? indexes) items (recur (rest indexes) (assoc items (first indexes) nil))))\n      ]\n    (loop [prime 2 primes [] sieve (range sieve-limit)]\n      (cond \n        ;return first n primes\n        (= n (count primes)) primes\n        ;not prime so don't bother with removing multiples\n        (nil? (nth sieve prime)) (recur (inc prime) primes sieve)\n       \t;remove multiples\n        :else\n          (recur\n            (inc prime)\n            (conj primes prime)\n            (nullfiy-indexes sieve (range (* 2 prime) (count sieve) prime))\n          )\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 67, "code": "(fn [limit]\n    (letfn [(is-prime? [x]\n                       (every? pos?\n                               (map #(mod x %)\n                                    (range 2 (inc (/ x 2)))\n                               )\n                       )\n           )]\n           (take limit\n                 (filter is-prime?\n                         (drop 2 (range))\n                 )\n           )\n    )\n)", "user": "5990fcb9e4b0866487ed0d5b"}, {"problem": 67, "code": "(fn small-primes\n  [n]\n  (take n [2      3      5      7     11     13     17     19     23     29\n           31     37     41     43     47     53     59     61     67     71\n           73     79     83     89     97    101    103    107    109    113\n           127    131    137    139    149    151    157    163    167    173\n           179    181    191    193    197    199    211    223    227    229\n           233    239    241    251    257    263    269    271    277    281\n           283    293    307    311    313    317    331    337    347    349\n           353    359    367    373    379    383    389    397    401    409\n           419    421    431    433    439    443    449    457    461    463\n           467    479    487    491    499    503    509    521    523    541]))", "user": "594266cfe4b060784b3b790b"}, {"problem": 67, "code": "(let [prm (fn [n] (or (= 2 n) (= 1 (apply min (map #(mod n %) (range 2 n))))))]\n  (fn [n]\n    (take n (filter prm (map #(+ 2 %) (range))))))", "user": "597a4277e4b02382a38ad1e2"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-not-prime (fn [n]\n                       (some #(zero? (mod n %)) (range 2 (inc (/ n 2)))))\n        is-prime (complement is-not-prime)]\n    (->> (range)\n         (map #(+ 2 %))\n         (filter is-prime)\n         (take n))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 67, "code": "(fn f ([n] (f n 2 [])) \n      ([n i s] (if (= n (count s)) \n                s \n                (if (some #(= 0 (rem i %)) s) (f n (inc i) s) (f n (inc i) (conj s i))))))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 67, "code": "(fn primes [n]\n  (map first (take n (iterate (fn [ps] (remove #(= 0 (mod % (first ps))) (rest ps)))\n                     (drop 2 (range))))))", "user": "59a24c92e4b066c664927d20"}, {"problem": 67, "code": "(fn prime\n    ([n]\n     (->> (range)\n          (drop 2)\n          (filter #(every? (fn [y] (pos? (mod % y))) (range 2 %) ))\n          (take n)\n          )\n      ))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 67, "code": "(fn primes [x]\n  (take x\n        (filter (fn [n] (not (some #(zero? (mod n %)) (range 2 n))))\n                (iterate inc 2)))\n)", "user": "59971e2de4b07157cc8daacc"}, {"problem": 67, "code": "(fn [n]\n  (take n ((fn sieve [s]\n             (cons (first s)\n                   (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                            (rest s))))))\n           (iterate inc 2))))", "user": "59944e73e4b0b211ea3aaac2"}, {"problem": 67, "code": "(fn [size]\n    (loop [n 2\n           results ()]\n      (if (= size (count results))\n        (reverse results)\n        (let [isPrime (empty? (filter\n                                #(integer? (/ n %))\n                                (range 2 n)))]\n          (recur (inc n)\n                 (if isPrime\n                   (cons n results)\n                   results\n    ))))))", "user": "5954cea2e4b066ee0a44af0a"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [x]\n            (cond\n             (= x 2) true\n             (or (even? x)\n                 (= 1 x)) false\n             :odd (not-any? #(zero? (mod x %)) (range 3 x))))]\n    (take n (filter prime? (range)))))", "user": "59b1c2eae4b0e1f4e384c8ec"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime?\n            ([n]\n              (if (< n 2)\n                false\n                (prime? 2 (Math/sqrt n) n)))\n            ([i sqrt n]\n              (if (> i sqrt)\n                true\n                (if (zero? (mod n i))\n                  false\n                  (recur (inc i) sqrt n)))))]\n    (take n (filter prime? (range)))\n  ))", "user": "59a72effe4b066c664927d94"}, {"problem": 67, "code": "(fn my-primes [n]\n  (letfn [(prime-list [coll]\n            (lazy-seq\n              (cons (first coll)\n                    (prime-list\n                      (filter #(->> coll\n                                    first\n                                    (mod %)\n                                    zero?\n                                    not)\n                              (rest coll))))))]\n    (take n (prime-list (iterate inc 2)))))", "user": "58fed70de4b0438e51c2cfdd"}, {"problem": 67, "code": "(fn [n] (take n ((fn sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s)))))) (iterate inc 2))\n      ))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (letfn [(prime? [n]\n            (.isProbablePrime (BigInteger/valueOf n) 10))]\n    (take n (filter prime? (range)))))", "user": "571dd145e4b0145328a76283"}, {"problem": 67, "code": "(fn prime\n  ([n] (prime n [1] 2))\n  ([n coll number]\n   (if (= (+ n 1) (count coll))\n     (next coll)\n     (recur n\n            (if (< 1 (count (filter #(= % 0) (map #(mod number %) coll))))\n              coll\n              (conj coll number))\n            (+ number 1)))))", "user": "5888b75fe4b0f1effa3b771b"}, {"problem": 67, "code": "(fn[cnt]\n        (let [prime? (fn[n]\n                       (let [candidates (range 2 n)]\n                         (not (some identity (map #(zero? (mod n %)) candidates)))))]\n          (take cnt (filter prime? (iterate inc 2)))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 67, "code": "(fn n-primes\n  [n]\n  (loop [num 3\n         result [2]]\n    (if (= n (count result))\n      result\n      (if (every? pos? (map #(mod num %) (range 2 num)))\n        (recur (inc num) (conj result num))\n        (recur (inc num) result)))))", "user": "59b62f8de4b05c620303ca1f"}, {"problem": 67, "code": "(fn [n] \n  (->>\n  (range)\n  (drop 2)\n  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n  (take n)))", "user": "592fa9f8e4b072a2710fcfcb"}, {"problem": 67, "code": "#(let [prime? (fn [x]\n                (if (= x 2)\n                  x\n                  (loop [y (range 2 (inc (int (Math/floor (Math/sqrt x)))))]\n                    (if (empty? y)\n                      x\n                      (if (= 0 (mod x (first y)))\n                        nil\n                        (recur (rest y)))))))]\n       (take % (filter prime? (drop 2 (range)))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 67, "code": "(fn [y] (loop [len y out [] i 2]\n        (cond (= (count out) len) out\n        (empty? (filter #(= (rem i %) 0) (range 2 i))) (recur len (concat out (list i)) (inc i))\n:else (recur len out (inc i))) ))", "user": "54c98ac0e4b045293a27f679"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2] \n         i 3]\n    (if (= n (count primes))\n      primes\n      (if (some #(zero? (mod i %)) primes)\n        (recur primes (inc i))\n        (recur (conj primes i) (inc i))))))", "user": "59cc4d5ee4b0a024fb6ae5d0"}, {"problem": 67, "code": "(fn get-primes\n  [n]\n  (loop [primes []\n         i      2]\n    (cond\n      (= n (count primes))\n        primes\n      ((fn is-prime? \n          [n]\n          (loop [i 2]\n            (cond\n              (>= i n)\n              true\n              (zero? (mod n i))\n              false\n              :else\n              (recur (inc i))))) i)\n        (recur (conj primes i) (inc i))\n      :else\n        (recur primes (inc i)))))", "user": "59089229e4b047aa04b1997c"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [n]\n            (if (< n 2)\n              false\n              (every? pos? (map #(rem n %) (range 2 n)))))]\n    (take n (filter prime? (range)))))", "user": "572010a4e4b0c5bde472c08c"}, {"problem": 67, "code": "(fn [n] (letfn [(prime? [p] (or (= p 2) (every? #(> (rem p %) 0) (range 2 \n(inc (quot p 2))))))] (take n (filter prime? (iterate inc 2)))))", "user": "59358f74e4b04f87174def52"}, {"problem": 67, "code": "(fn [m] (take m (filter (fn [x] (->> x Math/sqrt int inc (range 2) (map #(ratio? (/ x %))) (every? identity))) (iterate inc 2))))", "user": "59cf4013e4b0ef0a1e9b5b68"}, {"problem": 67, "code": "(fn algo [x]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "59e56c75e4b08badc2a0c556"}, {"problem": 67, "code": "(fn [x] \n  (take x (filter \n    (fn [val] \n      (if (= 2 val) \n        true \n        (not (reduce #(or (integer? (/ val %2)) %) false (let [x (int (inc (Math/sqrt val)))] (if (= 2 x) [2] (range 2 x))))))) (drop 2 (range)\n       )\n     )\n   )\n)", "user": "59c734e3e4b0a024fb6ae53f"}, {"problem": 67, "code": "(fn take-primes \n  ([n] (take n (list* 2 3 (take-primes n [2 3]))))\n  ([n primes] (lazy-seq\n                (let [next-prime (fn next-prime [primes]\n                                    (loop [n (+ (last primes) 2)]\n                                      (let [prime? (not-any? #(zero? (rem n %)) primes)]\n                                        (if prime? n (recur (+ n 2))))))\n                      prime (next-prime primes)]\n                  (cons prime (take-primes n (conj primes prime)))))))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 67, "code": "(fn [c]\n  (letfn [(prime? [n] (if (or (even? n) (< n 2)) false (reduce #(and %1 (not= 0 (mod n %2))) true (range 2 (inc (int (Math/sqrt n)))))))\n          (lazy-prime [n] (lazy-seq (cons n (lazy-prime (loop [m (inc n)] (if (prime? m) m (recur (inc m))))))))]\n    (take c (lazy-prime 2))))", "user": "59ddae03e4b01968742fed65"}, {"problem": 67, "code": "(fn [n]\n    (take n\n          ((fn primes [candidate]\n             (lazy-seq\n              (if (some #(zero? (mod candidate %)) (range 2 candidate))\n                (primes (inc candidate))\n                (cons candidate (primes (inc candidate))))))\n           2)))", "user": "5777cffae4b0979f89651651"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(next-prime [found]\n            (loop [n (inc (peek found))]\n              (if (some (fn [prime] (zero? (rem n prime))) found)\n                (recur (inc n))\n                (conj found n))))]\n    (first (drop (dec n) (iterate next-prime [2])))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 67, "code": "(fn [n]\n     (->> (filter (fn [x]\n                    (when (not-any? #{0} (map #(mod x %) (range 2 (inc (Math/sqrt x)))))\n                      true)\n                    ) (drop 2 (range)))\n          (cons 2)\n          (take n)))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 67, "code": "(fn [n]\n    (take n ((fn primes [m]\n               (lazy-seq (cons m (remove #(zero? (mod % m)) (primes (inc m)))))) 2)))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 67, "code": "(fn  [n]\n  (take n (filter \n            (fn is-prime [num]\n              (cond\n                (< num 2) false\n                (<= num 3) true\n                (zero? (mod num 2)) false\n                :else \n                  (loop [x 3]\n                    (cond \n                      (zero? (mod num x)) false     \n                      (> (* x x) num) true\n                      :else (recur (+ 2 x))))))\n            (range))))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 67, "code": "(fn [i]\n  (let [prime-seq\n        (fn prime-seq\n          ([] (lazy-seq (cons 2 (prime-seq [2]))))\n          ([s] (let\n                 [prime? (fn [n]\n                           (let [bound (Math/sqrt n)]\n                             (empty? (drop-while\n                                       #(> (mod n %) 0)\n                                       (filter #(<= % bound) s)))))\n                  p (loop [n (inc (last s))]\n                      (if (prime? n) n (recur (inc n))))]\n                 (lazy-seq (cons p (prime-seq (conj s p)))))))]\n    (take i (prime-seq))))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x]\n                 (not (some #(and\n                              (not= x %)\n                              (zero? (mod x %)))\n                            (range 2 (inc (Math/sqrt x))))))]\n  \t(take n (filter prime? (iterate inc 2)))))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 67, "code": "(fn prime [n]\n  (take n\n    (remove (fn [k] (some #(zero? (rem k %)) \n                           (range 2 (inc (int (Math/sqrt k))))))\n            (iterate inc 2))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 67, "code": "(fn [n]\n    (let [max-factor #(inc (int (Math/sqrt %)))\n          is-prime?\n          (fn [x]\n            (cond\n             (< x 2) false\n             (= x 2) true\n             (even? x) false\n             :else (not-any? #(zero? (mod x %)) (range 3 (max-factor x) 2))))]\n      (take n (filter is-prime? (range)))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 67, "code": "(fn [n]\n   (let [prime? (fn [x] \n                  (not-any? #(zero? (mod x %)) (range 2 x)))]\n  (->>\n  (range)\n  (drop 2)\n  (filter prime?)\n  (take n)\n  )))", "user": "59f15e20e4b0966464fe6a5a"}, {"problem": 67, "code": "(fn [ n ]\n  (let [ isPrime\n        (fn bla\n          ([ n ] (bla n 2))\n          ([ n curIndex ]\n           (if (= curIndex n)\n             true\n             (if (= 0 (mod n curIndex))\n               false\n               (bla n (inc curIndex))))))]\n    (take n (filter isPrime (iterate inc 2)))))", "user": "59f90e6ae4b0ca45a743a337"}, {"problem": 67, "code": "(fn __ [n]\n  (if (= n 0)\n    []\n    (loop [n n try 3 acc [2]]\n      (cond\n        (= n 1)\n        acc\n\n        (some #(= 0 (mod try %)) acc)\n        (recur n (inc try) acc)\n\n        :else\n        (recur (dec n) (inc try) (conj acc try))))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 67, "code": "(fn [n]\n  (let [all-remainders (fn [x divs]\n                        (map #(rem x %) divs))\n        prime?        (fn [x]\n                        (let [divisors   (range 2 x)\n                              remainders (all-remainders x divisors)]\n                          (empty? (filter zero? remainders))))\n        primes  (filter prime? (drop 2 (range)))]\n    (take n primes)))", "user": "5054d243e4b0b1b9d1860eb5"}, {"problem": 67, "code": "(fn [n]\n  (->> (range)\n       (filter #(.isProbablePrime (BigInteger/valueOf ^long %) 64))\n       (take n)))", "user": "59a080e3e4b0871e7608b837"}, {"problem": 67, "code": "(fn[numberOfPrimes]\n   (take numberOfPrimes \n    (filter \n    #(loop [currentNum 2]\n        (if (= % currentNum) true\n        (if (zero? (rem % currentNum)) false\n            (recur (inc currentNum))))) \n    (nnext (range)))))", "user": "571172ece4b09c608db70446"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(prime? [x]\n              (cond\n                (= 2 x)   true\n                (= 3 x)   true\n                (even? x) false\n                :else     (not (apply (some-fn zero?)\n                                      (for [i (range 3 (inc (Math/sqrt x)) 2)]\n                                        (rem x i))))))]\n      (take n (filter prime? (drop 2 (range))))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 67, "code": "(fn [x] (take x (reduce \n  (fn [p n] \n    (if (some #(= 0 (mod n %)) p)\n      p\n      (conj p n))) \n  [2 3] \n  (range 5 1000))))", "user": "59ba2ea0e4b0a024fb6ae3e1"}, {"problem": 67, "code": "#(take % ((fn prime-gen \n  ([] \n   (prime-gen [] 2))\n  ([xs n]\n   (if (some (comp zero? (partial rem n)) xs)\n     (recur xs (inc n))\n     (cons n (lazy-seq (prime-gen (conj xs n) (inc n)))))))))", "user": "5a01d8f6e4b01bb0ae8afd53"}, {"problem": 67, "code": "(fn primes [n]\n\n  (take n (lazy-seq (for [x (drop 2 (range)) :when (not-any? zero? (map #(rem x %) (range 2 x))) ] x )))\n\n)", "user": "56f2611fe4b04a395b9a04a2"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5a0a25fce4b0eab8c044893d"}, {"problem": 67, "code": "(fn [n]\n    (->> (iterate #(+ 2 %) 3)\n         (filter (fn [x] \n                   (every? #(ratio? (/ x %)) (range 3 x))))\n         (cons 2)\n         (take n)))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 67, "code": "(fn [x] (take x ((fn prime-sieve\n  []\n  (letfn\n      [(next-composite [composite-map n step]\n         (if (composite-map n)\n           (recur composite-map (+ n step step) step)\n           (let [final-value (if (= n step) (+ n step step) n)]\n             (assoc composite-map final-value step))))\n       (next-prime\n         [n composite-map]\n         (let [prime-factor (composite-map n)\n               prime? (nil? prime-factor)\n               step (if prime-factor prime-factor n) \n               composite-map (next-composite composite-map n step)\n               composite-map (dissoc composite-map n)]\n           (if prime?\n             (lazy-seq (cons n (next-prime (+ n 2) composite-map)))\n             (recur (+ n 2) composite-map))))]\n  (lazy-seq (cons 2 (next-prime 3 {}))))))))", "user": "5a12dea3e4b04bbd27e6da44"}, {"problem": 67, "code": "(fn [n]\n  \n  (loop [i n\n         primes [2]]\n    (if (= i 1)\n      primes\n      (recur (dec i) ((fn primes-helper [primes-coll]\n    (loop [x (inc (peek primes-coll))]\n      (if\n        (reduce #(or %1 (zero? (mod x %2))) false primes-coll)\n        (recur (inc x))\n        (conj primes-coll x)))) primes)))))", "user": "580a0783e4b0a837a8b30d2c"}, {"problem": 67, "code": "#(take % (iterate (fn [n]\r\n                      (loop [nn (inc n)]\r\n                        (if ((fn [n]\r\n                               (and\r\n                                (not= n 1)\r\n                                (= ((fn smallest-divisor [n test]\r\n                                      (cond\r\n                                        (> (* test test) n) n\r\n                                        (= (mod n test) 0) test\r\n                                        :else (smallest-divisor n (inc test)))) n 2) n))) nn)\r\n                          nn\r\n                          (recur (inc nn))))) 2))", "user": "580e7761e4b0849f6811b753"}, {"problem": 67, "code": "(fn [n] (take n ((fn sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s)))))) (iterate inc 2))))", "user": "5a07fefee4b01bb0ae8afde5"}, {"problem": 67, "code": "(fn [n](take n ( filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))) (range 2 1000))))", "user": "59e8bb43e4b0249b72820735"}, {"problem": 67, "code": "(fn prime-numbers [c]\n  (let [not-prime? (fn [v]\n                     (some (fn [n] (zero? (mod v n))) (range 2 (/ (inc v) 2))))]\n    (take c (remove not-prime? (drop 2 (range))))))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 67, "code": "(fn [z] (take z (iterate (fn p [x] (let [x (inc x)\n                  c (filter #(-> x (rem %) zero?) (range 2 x))]\n              (if (empty? c)\n                x\n                (p x)))) 2)))", "user": "4dc78527535d8a4b2fd7428f"}, {"problem": 67, "code": "(fn [n] (letfn [(dvd [m d] (if (= m (* d (int (/ m d)))) true false))\n                (ndvdall [m xs] (not (reduce #(or %1 %2) (map #(dvd m %) xs)) ) )\n                (primes [ps k] (lazy-seq \n                         (if (= k 2) (cons k (primes (conj ps k) (inc k)))       \n                             (if (ndvdall k ps) (cons k (primes (conj ps k) (inc k) )) \n                                                (primes ps (inc k))\n                                 \n                              )\n                         )\n                                )\n                 ) ]\n          (take n (primes [] 2))\n          )\n  )", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 67, "code": "(fn [n]\n  (nth \n   (iterate \n    (fn [ps]\n      (conj ps \n            (some (fn [new]\n                    (when (every? #(ratio? (/ new %)) ps)\n                      new))\n                  (drop (last ps) (range))))) \n    [2])\n   (dec n)))", "user": "54497569e4b032a45b8693d2"}, {"problem": 67, "code": "(fn [x] \n  ((fn fp [c n acc] \n      (cond \n        (zero? c) acc \n        (some (fn [a] (zero? (mod n a))) acc) (fp c (inc n) acc) \n        :else (fp (dec c) (inc n) (conj acc n))))\n    (dec x) 3 [2]))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 67, "code": "(fn [n] \n\t(let [p? (fn [x] \n\t\t\t\t(not-any? #(= 0 (mod x %)) (range 2 x)))\n\t\t  ps (fn ps [y] \n\t\t  \t\t(if (p? y) \n\t\t  \t\t\t(lazy-seq (cons y (ps (inc y)))) \n\t\t  \t\t\t(lazy-seq (ps (inc y)))))]\n\t\t(take n (ps 2))))", "user": "59fa5773e4b0ca45a743a35e"}, {"problem": 67, "code": "(fn [n]\n  (take n (drop 2 (filter  (fn [x] (not-any? zero? (map #(mod x %) (range 2 x)))) (range)))))", "user": "5a1bec89e4b0ff51aa4b322f"}, {"problem": 67, "code": "(fn [n]\n  (loop [l (drop 2 (range)) result []]\n    (if (= (count result) n)\n      result\n      (let [p (first l)]\n        (recur\n          (filter #(not= (mod % p) 0) (rest l))\n          (conj result p))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 67, "code": "(fn [n]\n    (let [prime? (fn [x primes]\n                     {:pre [(> x 0)]}\n                     (cond (= x 1) false\n                           (= x 2) true\n                           (= 0 (rem x 2)) false\n                           :else (loop [temp_primes primes]\n                                       (if (empty? temp_primes)\n                                           true\n                                           (let [p (first temp_primes)\n                                                 recur_primes (rest temp_primes)]\n                                                (if (= 0 (rem x p))\n                                                    false\n                                                    (recur recur_primes)))))))]\n         (loop [y 3\n                i 1\n                primes [2]]\n               (if (< i n)\n                   (if (prime? y primes)\n                       (recur (inc y) (inc i) (conj primes y))\n                       (recur (inc y) i primes))\n                   primes))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 67, "code": "(fn primes [n]\n   (let [s (iterate inc 2)\n         p (fn [x] (every? identity (map #(pos? (mod x %)) (range 2 x))))]\n        (take n (filter p s))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (let [prime? (fn prime? [n]\n                 (cond\n                   (< n 2) false\n                   (= n 2) true\n                   (= n 3) true\n                   :else (loop [p (dec n)\n                                limit (int (Math/sqrt n))]\n                           (if (>= p limit)\n                             (if (= 0 (mod n p))\n                               false\n                               (recur (dec p) limit))\n                             true))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "5a06c154e4b01bb0ae8afdce"}, {"problem": 67, "code": "(fn [n]\n  (letfn[(prime? [x]\n  (cond (== x 1) false\n        (== x 2) true\n        (even? x) false\n :t (->> (range 3 (inc (Math/sqrt x)) 2)\n    (filter #(zero? (rem x %)))\n    empty?)))]\n   (take n (filter prime? (range)))))\n\n\n #_(fn prime-lst \n  [n]\n  (letfn[(divides? [a b]\n(= (rem b a) 0))\n(find-divisor [n test-divisor]\n(cond (> (* test-divisor test-divisor) n) n \n(divides? test-divisor n) \ntest-divisor\n :t\n(find-divisor n (+ test-divisor 1)))) \n(smallest-divisor [n]\n(find-divisor n 2))\n(prime? [n] \n(= n (smallest-divisor n)))]\n(drop 2(take (+ n 2)(filter #(prime? %)(range))))))", "user": "52faf67ce4b047fd55837005"}, {"problem": 67, "code": "(fn [n]\n  (letfn\n      [(prime? [n]\n         (not-any? #(= 0 (mod n %)) (range 2 n)))]\n    (take n\n          (filter prime? (drop 2 (range))))))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2 3] next-num 5]\n    (cond\n      (<= n (count primes)) (subvec primes 0 n)\n      (some #(zero? (mod next-num %)) primes) (recur primes (inc next-num))\n      :else (recur (conj primes next-num) (inc next-num))\n      )))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 67, "code": "(fn [n] \n(take n (filter\n#(loop \n[ test (cons 2 (range 3 (+ 4 (Math/ceil (Math/sqrt %)) ) 2) ) ]\n(if (empty? test) true\n(do\n(if (and(= 0 (mod % (first test))) (not (= % (first  test)))) \nfalse\n(recur (rest test)) ))))\n(drop 2 (range)))))", "user": "5a1c8c26e4b0ff51aa4b3247"}, {"problem": 67, "code": "(fn [x]\n(take x ((fn filter-primes [lz-seq]\n  (let [v (first lz-seq)]\n    (cons v\n        (lazy-seq (filter-primes (filter #(not= 0 (rem % v)) (rest lz-seq))))))) (iterate inc 2))))", "user": "5a3c5c54e4b001c08efc0ce3"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn  [x]\n  (nil?\n  (some\n    #(zero? (mod x %))\n    (range 2 x))))\n(range 2 1000))))", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 67, "code": "(fn n-primes\n  [n]\n  (let [is-prime? (fn [x]\n                    (not-any? #(= (mod x %) 0) (range 2 x)))\n        next-prime? (fn [last-prime]\n                      (loop [i (inc last-prime)]\n                        (if (is-prime? i)\n                          i\n                          (recur (inc i)))))]\n    (reduce (fn [coll x]\n              (conj coll (next-prime? (last coll)))) [2] (range 1 n))))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 67, "code": "#(take %\n(let [sieve\n      (fn er [s] (cons (first s)\n                 (lazy-seq (er (filter (fn [x] (not= 0 (mod x (first s)))) (rest s))))))]\n  (sieve (drop 2 (range)))))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn prime? [k] (nil? (some #(zero? (rem k %)) (range 2 k)))) (iterate inc 2)) ))", "user": "5a535572e4b05d388ecb6c0b"}, {"problem": 67, "code": "(fn [n]\n    (loop [acc [] x 2]\n       (if (= (count acc) n)\n            acc\n            (\n              recur \n                     (if (true? ( some integer? (map #( / x %) (butlast (range 2 (inc x))) )) )\n                         acc\n                        (conj acc x)\n                     )\n                     (inc x)\n            )\n)))", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 67, "code": "(fn [n] (take n (last (take n (iterate\n\n                        (fn next-prime [primes]\n                          (conj\n                           primes\n                           (first (filter\n                                   (fn [cand] (every? #(not= 0 (mod cand %)) primes))\n                                   (rest (iterate #(+ 2 %) (last primes)))))))\n                        [2 3])))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 67, "code": "(fn [x]\n  (take x\n        (filter\n         (fn prime? [n]\n           (cond\n             (= 1 n) false\n             (= 2 n) true\n             (even? n) false\n             :else (empty?\n                    (filter\n                     #(zero? (rem n %))\n                     (range 3 (inc (Math/sqrt n)) 2)))))\n         (range))))", "user": "590b8607e4b047aa04b199db"}, {"problem": 67, "code": "(fn gen-primes [n] \n  (let [is-prime? (fn [pp primes] \n                      (not-any? #(= (mod pp %) 0) primes))]\n    (loop [pp 3\n           primes [2]]\n          (cond \n            (= (count primes) n) primes\n            (is-prime? pp primes) (recur (+ 2 pp) (conj primes pp))\n            :else (recur (+ 2 pp) primes)))))", "user": "5a409d77e4b0447ef91cc5d3"}, {"problem": 67, "code": "(fn take-primes [n]\n  (take n\n        (filter (fn primes? [a]\n                  (if (= a 2)\n                    true\n                    (not-any?\n                      #(zero? (rem a %))\n                      (range 2 (inc (Math/sqrt a))))))\n                (range 2 1000))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 67, "code": "(letfn [(prime? [n]\n  (cond\n   (= 2 n) true\n   (= 3 n) true\n   :else\n   (nil? (some #(= (mod n %) 0)\n               (filter prime?\n                       (range 2 (inc (int (Math/sqrt n)))\n                              ))))))]\n  (fn [n]\n    (loop [r [] c 2]\n      (if (< (count r) n)\n        (if (prime? c)\n          (recur (conj r c) (inc c))\n          (recur r (inc c)))\n        r))))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 67, "code": "(fn [n]\n    (let [prime? (fn [x]\n                   (cond\n                     (= (rem x 2) 0) false\n                     (= (rem x 3) 0) false\n                     :else (let [to-check (range 4 (inc (quot x 3)))]\n                             (not (some zero? (map (partial rem x) to-check))))))]\n      (take n (cons 2 (cons 3 (filter prime? (iterate inc 4)))))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 67, "code": "(fn [n]\n  (vec (take n (filter \n                (fn [n]\n\t            (cond\n    \t          (= n 1) false\n        \t      (= n 2) true\n            \t  (even? n) false\n\t              :else (every? #((complement zero?) (rem n %)) (range 3 n 2))))\n                (iterate inc 1)))))", "user": "53f053ebe4b0742d9025b0d3"}, {"problem": 67, "code": "(fn primes [n]\n (loop [i 3 len 1 res [2]]\n   (if (= len n) res\n     (if \n      (not-any? #(zero? (mod i %)) res)\n      (recur (+ 2 i) (inc len) (conj res i))\n      (recur (+ 2 i) len res)\n     )\n   )\n )\n)", "user": "5a424954e4b0447ef91cc5f0"}, {"problem": 67, "code": "(fn primenumbers [n]\n  (take n (filter \n           (fn prime? [p] \n             (loop [x 2]\n               (if (= x p) true\n                 (if (= (mod p x) 0) false\n                   (recur (inc x))\n        )\n      )\n    )\n  ) (iterate inc 2))))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "527ba29de4b03e8d9a4a7594"}, {"problem": 67, "code": "(fn primes [n]\n    (let [is-prime? (fn [p]\n                      (and (odd? p)\n                           (empty? (filter zero? (map #(rem p %)\n                                                      (filter odd? (range 3 p 2)))))))]\n      (take n (lazy-seq (cons 2 (filter is-prime? (drop 3 (range))))))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 67, "code": "(fn f\n  ([c] (f c [2] 3))\n  ([c l n] (if\n             (= c (count l))\n             l\n             (if \n               ((fn p\n  ([x] (p x 3))\n  ([x d] (if\n           (> (* d d) x)\n           true\n           (if \n             (= 0 (rem x d))\n             false\n             (recur x (+ 2 d)))))) n)\n               (f c (conj l n) (+ 2 n))\n               (f c l (+ 2 n))))))", "user": "5a3c2a08e4b001c08efc0cdf"}, {"problem": 67, "code": "(fn prime-nums [n]\n  (let [prime?\n        (fn [x]\n          (if (not-any? #(= 0 (mod x %)) (range 2 x))\n           true\n           false))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "58a6806ee4b01a0c0b23292f"}, {"problem": 67, "code": "(fn prime\n  ([n]\n    (prime n (drop 2 (range))))\n  ([n rest-prime]\n    (let [sieve (first rest-prime)]\n         (if (pos? n)\n             (cons sieve \n                   (prime (dec n)\n                          (filter #(not= 0 (mod % sieve))\n                                  rest-prime)))\n             nil))))", "user": "5974d2ede4b01722bebd4cb6"}, {"problem": 67, "code": ";; a map over a lazy seq of lazy seqs\n#(take % \n        (map first \n            (iterate \n             (fn [[x & xs]]\n               (filter (fn [y] (not= (mod y x) 0)) xs))        \n             (iterate inc 2))))\n\n;; hacky sieve, with a fixed `max` value; not lazy! :(\n;; This is faster, but presumes you know an approx value already!\n#_#(take % \n         ((fn [max & [acc xs]]\n            (let [[x & xs] (or xs (iterate inc 2))\n                  acc (or acc [])]\n              (if (> x max)\n                acc\n                (recur max [(conj acc x) \n                            (for [y xs :when (> (mod y x) 0)] y)])))) \n          550))\n\n;; TODO Reading: https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\n;;               https://yonatankoren.com/post/3-lazy-prime-sequence", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 67, "code": "(fn\n  [x]\n  (let [p (fn p [n]\n            (if (some #(zero? (rem n %))\n                      (range 2 (int (+ 1 (Math/sqrt n)))))\n              false\n              true))]\n    (take x (filter #(p %) (iterate inc 2)))))", "user": "5a067f26e4b01bb0ae8afdcc"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [primes number]\n                 (not (some zero? (map (partial mod number) primes))))]\n    (loop [ps [2] x 3]\n      (if (= (count ps) n) ps (recur (if (prime? ps x) (conj ps x) ps) (inc x))))))", "user": "5a34de78e4b0ddc586f153d0"}, {"problem": 67, "code": "(fn n-primes2 [n]\n  (loop [primes [2 3] at 2]\n    (if (= at n)\n      primes\n     (recur (conj primes (some (fn [j]\n                                (if (not-any? #(zero? ( mod j % ))\n                                          (cons 2 (range 3 (/ j 2) 2) )) j nil ))\n                               (iterate #(+ 2 %) (+ 2 (last primes) ))))\n            (inc at))))\n  )", "user": "5a527beee4b05d388ecb6bfe"}, {"problem": 67, "code": "(fn prime [n]\n  (if (= n 0)\n    []\n    (loop [i 1\n           x 3\n           res [2]]\n      (if (= i n)\n        res\n        (let [is-prime-x\n              (every?\n               #(not= (mod x %) 0)\n               (drop 2 (range (+ (int (/ x 2)) 1))))]\n          (recur (if is-prime-x (+ i 1) i)\n                 (+ x 1)\n                 (if is-prime-x (conj res x) res)))))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [elem] (not-any? #(= (rem elem %) 0) (range 2 (inc (int (Math/sqrt elem)))))) (drop 2 (range)))))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 67, "code": "(fn [x]\n  (let [er (fn [limit]\n   (loop [candidates (range 2 limit) sl (inc (int (Math/sqrt limit))) current 2]\n  \t(if (= current sl)\n      candidates\n      (recur (remove (set (map #(* current %) (range 2 (/ limit 2)))) candidates) sl (inc current)))))]\n   (take x (er (* x x)))\n  )\n)", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (loop [primes []\n         [num & nums] (iterate inc 2)]\n    (if (>= (count primes) n)\n      primes\n      (let [primes\n            (if (some #(zero? (mod num %)) primes)\n              primes\n              (conj primes num))]\n        (recur primes nums)))))", "user": "5a188be3e4b0ff51aa4b31ec"}, {"problem": 67, "code": "(fn [x]\n  (loop [primes [2] current 3]\n    (if (= (count primes) x)\n      primes\n      (let [remainders (map #(rem current %) primes)]\n        (recur \n          (if (not (.contains remainders 0))\n            (conj primes current)\n            primes\n          )\n          (inc current)\n        )\n      )\n    )\n  )\n)", "user": "586f3f7ee4b01531a375e9c1"}, {"problem": 67, "code": "(fn [a] (take a (filter (fn premier? [x]\n  (if (<= x 1)\n    false\n    (if (<= x 3)\n      true\n      (if (or (= 0 (rem x 2)) (= 0 (rem x 3)))\n        false\n        (not (some #(= 0 (rem x %)) (range 5 (/ x 2)))))))) (range))))", "user": "594a7ed1e4b07ddc2dafae02"}, {"problem": 67, "code": "(fn [x] (take x ((fn primes\n  ([] (cons 2 (primes [2] 3)))\n  ([ps n] \n   (if (some #(= 0 (rem n %)) ps) \n     (primes ps (inc n)) \n     (cons n (lazy-seq (primes (conj ps n) (inc n))))))))))", "user": "552d9b31e4b076ab5578f7eb"}, {"problem": 67, "code": "(fn prime-me\n   ([n] (prime-me n [] 2))\n   ([n coll iter]\n    (let [func (fn [x]\n                 (filter #(zero? (rem x %)) (range 1 (inc x))))]\n      (if (= (count coll) n)\n        coll\n        (do\n          (if (= (count (func iter)) 2)\n            (prime-me n (conj coll iter) (inc iter))\n            (prime-me n coll (inc iter))\n            )))\n      )))", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 67, "code": "(fn [x]\n  (let [_genprimes (fn genprimes [n candi]\n                     (let [new-candi (filter #(not= (mod % n) 0) candi)]\n                       (lazy-seq (cons n (genprimes (first new-candi) new-candi)))))]\n    (take x (_genprimes 2 (iterate inc 3)))))", "user": "5a813b90e4b00b71e582a065"}, {"problem": 67, "code": "(fn [x]\n  (loop [n 3 primes [2]]\n    (if (= x (count primes))\n      primes\n      (if (empty? (filter #(= (mod n %) 0) primes))\n        (recur (inc n) (conj primes n))\n        (recur (inc n) primes)\n      ))))", "user": "5a342188e4b0ddc586f153bd"}, {"problem": 67, "code": "(fn [z] (reverse ((fn [x acc n] (if (= x (count acc))\n                   acc\n                   (if (some #(= 0 (mod n %)) acc)\n                       (recur x acc (+ 1 n))\n                       (recur x (cons n acc) (+ 1 n))))) z (list) 2)))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 67, "code": "(fn [x]\n  (let [max-num (int (Math/pow x 2))\n        numbers (range 2 max-num)\n        iter-num (int (Math/sqrt (last numbers)))]\n    (take x (loop [i 0\n           nums numbers]\n      (if (> (nth nums i) iter-num)\n        nums\n        (recur (inc i) (filter #(or (= % (nth nums i)) (> (mod % (nth nums i)) 0)) nums)))))))", "user": "5a388675e4b001c08efc0ca2"}, {"problem": 67, "code": "(fn [n] (take n (filter\n  (fn [x]\n    (every? #(not= 0 (mod x %))\n            (range 2 x)))\n  (drop 2 (range)))))", "user": "5a9181c5e4b002d099cae6f6"}, {"problem": 67, "code": "(fn get-n-primes [x]\n    (let [is-prime? (fn [x]\n                      (let [divisors\n                            (apply hash-set\n                                   (->> (range 2 (inc x))\n                                        (filter #(= 0 (rem x %)))))]\n                       (= #{x} divisors)))]\n      (take x (filter is-prime? (range)))))", "user": "5920c191e4b09b4ee5954c61"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 67, "code": "(fn [x]\n  (loop [p [] n 2]\n    (if (= (count p) x)\n      p\n      (if (some #(zero? (mod n %))\n                p)\n        (recur p (inc n))\n        (recur (conj p n) (inc n))))))", "user": "57596ba7e4b02ea11479931a"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n            (lazy-seq\n              (when (seq s)\n                (cons (first s) (sieve (filter #(not (zero? (mod % (first s)))) (rest s)))))))]\n  \t(take n (sieve (map #(+ 2 %) (range))))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(add-next-prime\n           [acc]\n           (loop [candidate (+ 2 (last acc))]\n             (if (->> acc\n                      (take-while #(<= (* % %) candidate))\n                      (map #(not= 0 (mod candidate %)))\n                      (reduce #(and %1 %2) true))\n               (conj acc candidate)\n               (recur (+ 2 candidate)))))]\n    (nth (iterate add-next-prime [2 3]) (- x 2))))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(make-prime [[a & coll]]\n            (lazy-seq (cons a\n                            (make-prime (remove #(zero? (mod % a)) coll)))))]\n    (take n (make-prime (iterate inc 2)))))", "user": "5a546344e4b05d388ecb6c27"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n] (every? #(> (mod n %) 0) (range 2 (inc (/ n 2)))))]\n    (take n (lazy-seq (filter prime? (drop 2 (range)))))))", "user": "4ed45563535d10e5ff6f52c9"}, {"problem": 67, "code": "(fn\n  [n]\n  (loop [primes [2]\n         candidate 3]\n    (if (= n (count primes))\n      primes\n      (if (->> primes (filter #(zero? (rem candidate %))) empty?)\n        (recur (conj primes candidate) (inc candidate))\n        (recur primes (inc candidate))))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 67, "code": "(fn [n]\n   (take n (filter (fn [i] (empty? (filter #(= 0 (mod i %)) (range 2 i)))) (rest (rest (range))))))", "user": "5a4d656fe4b05d388ecb6ba9"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(eratos\n          ([] (eratos (map #(+ 2 %) (range))))\n          ([coll]\n          (lazy-seq\n            (if (seq coll)\n              (cons (first coll) (eratos (filter #((complement =) 0 (mod % (first coll))) coll)))))))] (take n (eratos))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n]\n                 (or (= 2 n) \n                     (= 3 n)\n                     (and (< 1 n)\n                          (odd? n)\n                          (not-any? #(zero? (mod n %))\n                                    (range 3 (inc (Math/sqrt n)) 2)))))]\n    (->> (range) (filter prime?) (take x))))", "user": "5aa4f7dae4b0d174b936c88c"}, {"problem": 67, "code": "(fn [n]\n   (loop [\n          i 1\n          res []\n          primes (map number?\n                      (take 600\n                            (range)))]\n     (if (or\n           (>= i (count primes))\n           (= (count res) n))\n       res\n       (if (= (nth primes i) true)\n         (recur (+ i 1) (conj res (+ i 1))\n                (let [t (+ i 1)]\n                  (map-indexed\n                    (fn [j val]\n                      (if (= (rem (+ j 1) t) 0)\n                        false\n                        val)) primes)))\n         (recur (+ i 1) res primes))))\n   )", "user": "5a9e3698e4b0d174b936c7fc"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime? (fn [x] (= 1 (count (keep #(when (zero? (mod x %)) %) (range 2 (inc x))))))] \n    (take n (filter is-prime? (range)))))", "user": "59f44189e4b0966464fe6aab"}, {"problem": 67, "code": "(fn [n]\n  (loop [lst (take (* n n) (iterate inc 2)) ret [] prime 2]\n    (if (= (count ret) n)\n      ret\n      (let [fil-lst (filter #(not= (mod %1 prime) 0) lst)]\n        (recur fil-lst (conj ret prime) (first fil-lst))))))", "user": "5a9a12d6e4b0d174b936c7b7"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n] (not-any? zero? (map (partial mod n) (range 2 n))))]\n    (->> 2\n         (iterate inc)\n         (filter prime?)\n         (take n))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 67, "code": "(fn get-primes [n]\n  (let [prime? (fn [number]\n                 (and (> number 1) (not-any? (partial #(zero? (mod %1 %2)) number) (range 2 number))))]\n    (take n (filter prime? (range)))))", "user": "5a59a76fe4b05d388ecb6c98"}, {"problem": 67, "code": "(fn\n  [x]\n  (if (= x 2)\n    [2 3]\n    (if (= x 5)\n      [2 3 5 7 11]\n      [541])))", "user": "5a90395ce4b05369db4d254a"}, {"problem": 67, "code": "(fn primes [p]\n  (letfn [(prime? [n] (if (some true? (map #(= 0 (mod n %)) (range 2 n)) ) false true))] (take p (drop 2 (filter #(prime? %) (range))))) )", "user": "59fa0bb6e4b0ca45a743a352"}, {"problem": 67, "code": "(fn [num]\n  (let [prime? (fn [num]\n                (not (some true?\n                           (map #(zero? (mod num %)) (range 2 num)))))] (loop [counter 2\n                primes []]\n        (if (= num (count primes))\n          primes\n          (recur (inc counter) (if (prime? counter)\n                                 (conj primes counter)\n                                 primes))))))", "user": "5a912080e4b002d099cae6ea"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5a9db5c9e4b0d174b936c7f1"}, {"problem": 67, "code": "(fn __\n  ([x]\n   (cond\n    (= x 1) [2]\n    (>= x 2) (__ (- x 2) [2 3])\n    :else []))\n\n  ([x p]\n      (letfn [(prime? [x p]\n                      (let [sx (inc (int (Math/sqrt x)))]\n                           (every? #(not= 0 (mod x %))\n                                   (filter #(<= % sx) p))))]\n        (if (zero? x) p\n          (loop [s (+ 2 (last p))]\n                (if (prime? s p) (__ (dec x) (conj p s))\n                  (recur (+ 2 s)))))))\n)", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 67, "code": "(fn [n]\n  (take n (keep\n           (fn [n]\n             (if (nil? (some #(zero? (mod n %)) (range 2 n))) n))\n           (iterate inc 2))\n        )\n  )", "user": "58637221e4b0f14aab7c881d"}, {"problem": 67, "code": "(fn first-primes-2 [max]\n  (let [is-prime? (fn [x] (not-any? #(= 0 (mod x %)) (range 2 (dec x))))]\n    (->> (range)\n         (drop 2)\n         (filter is-prime?)\n         (take max)\n         )\n    )\n  )", "user": "5aada061e4b073f17744257a"}, {"problem": 67, "code": "(fn prime [n]\n  (take n\n        (filter\n         (fn [x]\n           (->> (range 2 (max 2 (/ (inc x) 2)))\n                (map (partial mod x))\n                (some zero?)\n                not))\n         (drop 2 (range)))))", "user": "55d50a38e4b0e31453f64a80"}, {"problem": 67, "code": "(fn primenum [n]\n  (loop [cnt n\n         result []\n         num_to_test 2]\n    (if (zero? cnt)\n      result\n      (if (some #(zero? (mod num_to_test %)) (range 2 (dec num_to_test)))\n        (recur cnt result (inc num_to_test))\n        (recur (dec cnt) (conj result num_to_test) (inc num_to_test))))))", "user": "5ab490f4e4b073f17744261d"}, {"problem": 67, "code": "(fn [n]\n  (take n\n  (for [p (concat [2] (iterate #(+ 2 %) 3))\n        :when (every? #(not= (rem p %) 0) (range 3 (inc (Math/sqrt p))))]\n   p)))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 67, "code": "(fn [n]\n  (let [endless-sieve (fn endless-sieve [current known-primes]\n                        (let [is-divisible? (some #(= 0 (mod current %)) known-primes)]\n                          (cond\n                           is-divisible? (endless-sieve (inc current) known-primes)\n                           :else (lazy-seq (cons current (endless-sieve (inc current) (conj known-primes current))))\n                           )\n                          )\n                        )]\n    (take n (endless-sieve 2 #{}))\n    )\n)", "user": "5aba34c5e4b073f1774426a3"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter \n        (fn prime? [m] \n          (cond\n           (zero? m) false\n           (= 1 m) false\n           (< m 4) true\n           :else (every? (fn [a] (not= 0 (mod m a))) (range 2 m))\n          ))\n           (range))))", "user": "5ab9fe71e4b073f17744269d"}, {"problem": 67, "code": "(fn [n]\n   (let [prime? (fn [x]\n                  (empty? (filter #(= 0 (rem x %)) (range 2 x))))\n         prime-range (fn prime-x [val]\n                       (if (not (prime? val))\n                         (prime-x (inc val))\n                         (lazy-seq\n                           (cons val (prime-x (inc val))))))]\n\n     (take n (prime-range 2))))", "user": "5ab23c99e4b073f1774425e2"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (every? #(or (= n %) (not= 0 (mod n %)))\n                         (range 2 (inc (Math/sqrt n)))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5abc5a09e4b073f1774426e9"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x] (not-any? #(= 0 %) (map #(rem x %) (range 2 (dec x)))))]\n    (take n (lazy-seq (cons 2 (filter prime? (iterate inc 3)))))))", "user": "5a67cedbe4b0512ff01cd9ee"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [x]\n                    (if (= x 2)\n                      true\n                      (not-any? #(= (rem x %) 0) (range 2 (dec x)))))\n                  (drop 2 (range)))))", "user": "55b28b57e4b01b9910ae296c"}, {"problem": 67, "code": "(let [primes (fn primes\n  ([] (cons 2 (lazy-seq (primes [2]))))\n  ([ps] (print ps) (let\n          [nextPrime (first (drop-while\n                       #(or\n                          (<= % (last ps))\n                          (some (fn [prime] (= 0 (rem % prime))) ps))\n                       (range)))\n           nps (conj ps nextPrime)\n           ]\n          (cons nextPrime (lazy-seq (primes nps)))))\n  )]\n  (fn [n] (take n (primes))))", "user": "5ab5f60be4b073f177442643"}, {"problem": 67, "code": "(fn primes [x]\n  (letfn [(prime? [n]\n            (cond\n              (< n 2) false\n              (== 2 n) true\n              (zero? (mod n 2)) false\n              true\n              (loop [k 3]\n                (cond (> k (/ n 2)) true\n                      (zero? (mod n k)) false\n                      true (recur (+ k 2))))))]\n    (take x (filter prime? (range)))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 67, "code": "(fn [foo] (take foo (filter\n                         (fn prime? [bar]\n                           (not-any? #(= 0 (mod bar %)) (range 2 (+ 1 (/ bar 2)))))\n                         (range 2 (java.lang.Integer/MAX_VALUE))))\n     )", "user": "5908882de4b047aa04b19979"}, {"problem": 67, "code": "(fn [n]\n    (take n (filter (fn [x] (every? (fn [y] (not= (mod x y) 0))\n                                    (range 2 x)))\n                    (iterate inc 2))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [v] (loop [d (dec v)] (cond (= 1 d) true (zero? (rem v d)) false :else (recur (dec d))))) (conj (iterate #(+ % 2) 3) 2))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(is-prime\n              [x]\n              (loop [i 2]\n                (if (> (* i i) x)\n                  true\n                  (if (= (mod x i) 0)\n                    false\n                    (recur (inc i))))))]\n      (loop [res []\n             x 2]\n        (if (= (count res) n)\n          res\n          (if (is-prime x)\n            (recur (conj res x) (inc x))\n            (recur res (inc x)))))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "58a32c21e4b02bd94d917eeb"}, {"problem": 67, "code": "(fn  [n]\n  (loop [sols [2]\n         candidates (drop 3 (range))]\n    (let [current-sieve (last sols)\n          filtered-candidates (filter #(not (zero? (mod % current-sieve))) candidates) \n          new-sols (conj sols (first filtered-candidates))] \n      (if (< (count new-sols) n)\n        (recur new-sols filtered-candidates)\n        new-sols))))", "user": "5acd235ae4b0e27600da7824"}, {"problem": 67, "code": "(fn [n] \n  (letfn [(prime \n           [[x & xs]] \n           (lazy-seq \n            (cons x (prime (filter #(not= 0 (rem % x)) xs)))))]\n    (take n (prime (iterate inc 2)))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 67, "code": "(fn wilson-primes [amount]\n  \"Not very effective for large numbers\"\n    (let [cache (atom {1 (bigint 1)})\n          factorial (fn [n]\n                        (loop [num n total (bigint 1)]\n                            (let [cached (@cache num)]\n                                (if cached\n                                 ((swap! cache assoc n (* total cached)) n)\n                                 (recur (dec num) (* total num))))))]\n        (->> (iterate inc 2)\n             (filter (fn [i] (zero? (mod (inc (factorial (dec i))) i))))\n             (take amount))))", "user": "5abbbd46e4b073f1774426db"}, {"problem": 67, "code": "(fn [x]\n  (take x ((fn gen[y]\n            (cons (first y)\n                  (lazy-seq (gen (filter #(not= 0 (mod % (first y)))\n                                         (rest y)))))) (iterate inc 2))))", "user": "57b19fa1e4b0fbc9809a2754"}, {"problem": 67, "code": "; #(take % (cons 2 (filter\n;           (fn [candidate]\n;             (loop [test (-> candidate Math/sqrt int inc)]\n;               (cond\n;                 (<= test 1) true\n;                 (zero? (mod candidate test)) false\n;                 :else (recur (dec test)))))\n;           (iterate (partial + 2) 3))))\n\n; modified adereth\n(fn [n]\n  (->>\n   (range)\n   (drop 2)\n   (filter (fn [p] (not-any? #(zero? (mod p %)) (range 2 p))))\n   (take n)))", "user": "5a544eeee4b05d388ecb6c24"}, {"problem": 67, "code": "(fn [n] (take n\n               ((fn n-primes\n                  []\n                  (filter (fn [num]\n                            (loop [end (int (Math/sqrt num)), div 2, re (rem num div)]\n                              (cond\n                                (< num 2) false\n                                (= num 2) true\n                                (= re 0) false\n                                (> div end) true\n                                :else (recur end (inc div) (rem num div)))\n                              )) (range))))\n))", "user": "5ac92dc3e4b0e27600da77bf"}, {"problem": 67, "code": "(fn primes\n      ([x] (primes [2] 3 (dec x)))\n      ([p n m]\n        (if (<= m 0)\n          p\n          (if (some zero? (map #(rem n %) p))\n            (recur p (inc n) m)\n            (recur (conj p n) (inc n) (dec m))))))", "user": "5acd1a43e4b0e27600da7823"}, {"problem": 67, "code": "(fn rep [ n ] \n\t(let [isprime (fn [n] \n\t\t\t\t\t(not (some #(= 0 %) (map #(mod n %) (nthrest (range n) 2)))) \n\t\t\t\t\t) \n\t      ] \n\t      (take n (filter isprime (nthrest (range) 2)))\t\n\t))", "user": "5ac04101e4b073f177442737"}, {"problem": 67, "code": "(fn __\n  [number-of-primes]\n  (let [is-prime (fn [number]\n                   (= 2 (count (filter #(zero? (rem number %)) (range 1 (inc number))))))]\n    (loop [primes []\n           i 1]\n      (if (= number-of-primes (count primes))\n        primes\n        (recur\n          (if (is-prime i) (conj primes i) primes)\n          (inc i))))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 67, "code": "(fn r [c] (loop [c (dec c) pl [2]]\n             (if (= c 0)\n               pl\n               (recur\n                (dec c)\n                (conj pl (first (filter (fn [num]\n                                          (loop [checked 2]\n                                            (if (> checked (Math/sqrt num))\n                                              true\n                                              (if (-> num (mod checked) (= 0))\n                                                false\n                                                (recur (inc checked)))))) (iterate inc (inc (last pl))))))\n                ))))", "user": "5831846ae4b051871117c02c"}, {"problem": 67, "code": "(fn [num]\n   (loop [result [2]\n          n 3]\n     (println result n)\n     (if (= num (count result))\n       result\n       (if (some #(= % 0) (map #(rem n %) result))\n         (recur result (inc n))\n         (recur (conj result n) (inc n))))\n     )\n   )", "user": "5aefdc8de4b0cc2b61a3bc40"}, {"problem": 67, "code": "(fn [n]\n  (loop [a 3\n         out [2]]\n    (if (>= (count out) n)\n      out\n      (recur (inc a) (if (not ((fn has-divisor [num nums]\n                            (loop [ms nums]\n                              (if (= 0 (count ms))\n                                false\n                                (if (= 0 (mod num (first ms)))\n                                  true\n                                  (recur (drop 1 ms)))))) a out))\n                       (conj out a)\n                       out)))))", "user": "5ad3d730e4b0ea6055cfabc8"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(div            [x nums]\n                           (some #(= 0 %) (map #(mod x %) nums)))]\n          (cond\n            (< n 1) []\n            (= n 1) [2]\n            :def    (let [current-list (primes (dec n))\n                          start        (last current-list)]\n                      (conj current-list (first (remove #(div % current-list) (iterate inc start))))))))", "user": "583048d9e4b051871117c007"}, {"problem": 67, "code": "(fn [n]\n    (loop [i 2 l []]\n      (if (= (count l) n)\n        l\n        (if (\n             ; trial division. returns true if x is composite, nil otherwise.\n             (fn [x] (some\n                       #(== % 0)\n                       (map #(mod x %) (range 2 (inc (int (Math/sqrt x)))))\n                       ))\n             i)\n          (recur (inc i) l)\n          (recur (inc i) (conj l i))\n          ))))", "user": "5a9d64c8e4b0d174b936c7eb"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (filter (fn [m]\n              (not-any? #(zero? %) (map #(mod m %) (range 2 m))))\n        (drop 2 (range)))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 67, "code": "(fn [l] (take l (filter (fn [n]\n                                 (if (< n 2)\n                                   false\n                                   (let [r (range 2 n)]\n                                     (every? #(< % 2) (map #(if (zero? (mod n %)) % 0) r))))) (range))))", "user": "57086931e4b0b0fb43fd069e"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes [n]\n            (loop [l (transient (vec (range n)))\n                   i 2]\n              (if (> (* i i) n)\n                (filter #(> % 1) (persistent! l))\n                (recur (reduce #(assoc! %1 %2 0) l (range (* 2 i) n i)) (inc i)))))]\n    (take n (primes (* n n)))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 67, "code": "(fn [i]\n  (let\n    [dividable? (fn dividable?\n      ([n ds] (some zero? (map #(mod n %) ds)))\n      ([n] (dividable? n (range 2 n))))\n     next-prime (fn [n]\n      (if (dividable? (inc n))\n        (recur (inc n))\n        (inc n)))\n     primes (fn primes\n      ([] (primes 2))\n      ([n] \n       (lazy-seq \n         (cons n (primes (next-prime n))))))]\n    (take i (primes))))", "user": "546e4ab8e4b00cfc9eacc19c"}, {"problem": 67, "code": "(fn primeke\n  [k]\n  (letfn [(prime?\n           [x]\n           (cond\n             (< x 2) false\n             (= x 2) true\n             (even? x) false\n             :else (loop [i 3]\n                     (cond\n                       (> (* i i) x) true\n                       (= 0 (rem x i)) false\n                       :else (recur (+ i 2))))))]\n    (->> (range) (filter prime?) (take k))))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [num] (every? #(not= 0 (mod num %)) (range 2 num))) (iterate inc 2))))", "user": "5aa4a1ffe4b0d174b936c886"}, {"problem": 67, "code": "(fn [x]\n  (take x\n   (filter\n    (fn [n]\n     (cond\n      (< n 2) nil\n      (= n 2) true\n      :else (not-any? #(= 0 (mod n %)) (cons 2 (range 3 (inc (Math/sqrt n)) 2))))) (range))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n pvec] (every? #(pos? (rem n %)) pvec))\n        gen-primes (fn [x n pvec]\n                     (if (pos? x)\n                       (if (prime? n pvec)\n                         (recur (dec x) (+ n 2) (conj pvec n))\n                         (recur x (+ n 2) pvec))\n                       pvec))]\n(gen-primes (dec x) 3 [2])))", "user": "5ae0976be4b0837691e92c43"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x]\n                 (not (some #(zero? (mod x %)) (range 2 x))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "5afcd6d1e4b0cc2b61a3bd17"}, {"problem": 67, "code": "(fn [amount]\n\t(if (< amount 1)\n\t\t[]\n\t\t(loop [primes [2] n 3]\n\t\t\t(if (= (count primes) amount)\n\t\t\t\tprimes\n\t\t\t\t(recur\n\t\t\t\t\t(if (some #(zero? (mod n %)) primes) \n\t\t\t\t\t\tprimes \n\t\t\t\t\t\t(conj primes n))\n\t\t\t\t\t(+ n 2))))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 67, "code": "(fn [number]\n        (loop [v [] n (range 2 542) p number]\n            (if (= p 0)\n                v\n                (recur\n                    (conj v (first n))\n                    (filter #(not= (mod % (first n)) 0) (rest n))\n                    (dec p)))))", "user": "5b083513e4b0cc2b61a3bdb4"}, {"problem": 67, "code": "(fn primes\n  ([n] (primes n []))\n  ([n s]\n    (let [get-next (fn get-next ([s] (get-next s 2))\n  ([s c]\n    (cond ((fn is-good? [s n]\n  (->> s\n    (filter (fn [x] (= (rem n x) 0)))\n    count\n    (= 0))) s c) c\n          :else (get-next s (inc c)))))]\n    (if (= n 0)\n      s\n      (recur (dec n) (conj s (get-next s)))))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 67, "code": "(fn [x] \n  (let [prime? (fn [x] (->> (range 1 x) \n                            (map #(mod x %)) \n                            (filter zero?) \n                            (count) \n                            (= 1)\n                            ))]\n    (->> (iterate inc 2)\n         (filter prime?)\n         (take x)\n         )))", "user": "5b118b7be4b0cc2b61a3be34"}, {"problem": 67, "code": "(fn [x] (take x (filter (fn [n] (= 0 (count (filter #(= 0 (rem n %)) (range 2 n))))) (iterate inc 2))))", "user": "5b198eace4b03cfeda66ecbb"}, {"problem": 67, "code": "(fn [n]\n   (->> (map inc (range (* n n)))\n        (filter\n         (fn [m]\n           (every? (fn [s] (not (zero? (mod m s))))\n                   (rest (rest (range m))))))\n        (rest)\n        (take n)))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 67, "code": "(fn [n]\n  (take\n   n\n   (filter\n    (fn [m]\n      (and (> m 1) (not-any? zero? (map #(rem m %) (range 2 m)))))\n    (range))))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 67, "code": ";; Make lazy\n(fn pn[n]\n  (let [non-prime? (fn [x] (some zero? (map #(rem x %) (range 2 x))))\n        prime? (fn [x]((complement non-prime?) x))]\n    (take n\n          (filter prime? (range 2 542)))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 67, "code": "#(take % (filter (fn pr \n                   ([number] (if (= number 2)\n                               true\n                               (pr 2 number)))\n                   ([current number] (if (> current (Math/sqrt number))\n                    true\n                    (do (if (= (mod number current) 0 )\n                          false\n                          (recur (inc current) number))))))\n                        (drop 2 (range))))", "user": "5afdb2bae4b0cc2b61a3bd1f"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-prime (fn [x] (not-any? #(= 0 (mod x %)) (range 2 (- x 1))))]\n    (->>\n      (range)\n      (drop 2)\n      (filter is-prime)\n      (take n))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 67, "code": "(fn [i] (take i (filter (fn [num] (not (reduce (fn [y x] (or y (= (mod num x) 0))) false (range 2 num)))) (drop 2 (range)))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 67, "code": "(fn n-primes [n]\n  (letfn [(prime? [n]\n            (let [max (java.lang.Math/round (java.lang.Math/sqrt n))]\n              (loop [i 2]\n                (cond\n                  (> i max) true\n                  (zero? (mod n i)) false\n                  :else (recur (inc i))))))]\n    (loop [i 2\n           result []]\n      (cond\n        (= n (count result)) result\n        (prime? i) (recur (inc i) (conj result i))\n        :else (recur (inc i) result)))))", "user": "5b1d61b3e4b03cfeda66ecfe"}, {"problem": 67, "code": "#(take % ((fn sieve [[f & r]]\n               (cond\n                 (empty? r) ()\n                 :else\n                 (cons f (sieve (remove (fn [n] (zero? (mod n f))) r)))\n                 ))\n             (range 2 548)))", "user": "4e6a23d0535d8ccf87e9fea0"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(next-prime [k] (if (every? #(> (mod k %) 0) (range 2 k)) k (next-prime (inc k))))\n          (gen-primes ([] (gen-primes 2))\n            ([s] (lazy-seq (cons s (gen-primes (next-prime (inc s)))))))]\n    (take n (gen-primes))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (if (< n 2)\n              false\n              (let [sqrt (Math/sqrt n)]\n                (loop [i 2]\n                  (cond\n                    (> i sqrt) true\n                    (zero? (mod n i)) false\n                    :else (recur (inc i)))))))]\n    (loop [i 2\n           acc []]\n      (if (= n (count acc))\n        acc\n        (recur (inc i)\n               (if (prime? i) (conj acc i) acc))))))", "user": "5777c3d6e4b0979f8965164f"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "5b47874be4b02d533a91bc70"}, {"problem": 67, "code": "(let\n  [prime (fn [x] (or (< x 4) (not (some #(= (mod x %) 0) (range 2 x)))))]\n  (let\n    [primes (fn primes [part totry n] (if\n                                        (= n (count part))\n                                        part\n                                        (primes (if (prime totry) (conj part totry) part) (inc totry) n)))]\n    #(primes [] 2 %)))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 67, "code": "(fn [i] (let [f (fn [i] (= 1 (count (filter #(= 0 (rem i %)) (range 1 i)))))]\n           (take i (lazy-seq (filter #(f %) (range 2 Long/MAX_VALUE))))))", "user": "5b0948f3e4b0cc2b61a3bdbb"}, {"problem": 67, "code": "(fn [x] (take x (filter (fn [n] (empty? (filter #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))) (rest (rest (range))))))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 67, "code": "(fn [n] \n  (let [primes (lazy-seq (loop [ps [2 3 5] i 5]\n                 (cond\n                  (>= (count ps) n) ps\n                  (some zero? (map #(mod i %) ps)) (recur ps (+ i 2))\n                  :else (recur (conj ps i) (+ i 2))\n                 )))]\n      (take n primes)))", "user": "54d5fbe9e4b0a52adc2e2014"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(is-prime? [x]\n            (and (> x 1) (every? pos? (map #(rem x %) (range 2 x)))))]\n    (take n (filter is-prime? (range)))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 67, "code": "(fn [n]\n  (loop [ps #{} k 2]\n    (if (= n (count ps)) (seq (apply sorted-set ps))\n      (recur (if ((fn [p i] (reduce #(if (and %1 (not= 0 (mod i %2))) true false) true p)) ps k) (conj ps k) ps) (inc k))\n    )))", "user": "5b4ff637e4b02d533a91bce0"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 1) [2]\n      (let [pprime (primes (dec n))\n            divis? (fn [pcand] (nil? (some #(= 0 (mod pcand %)) pprime)))\n            prime? (fn [pcand] (if (divis? pcand) pcand))\n            pcands (drop (inc (last pprime)) (range))]\n        (conj pprime (some prime? pcands)))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(prime? [a]\n              (or (< a 4)\n                  (->> (map (partial mod a) (range 2 (inc (/ a 2))))\n                       (every? pos?))))]\n      (loop [x      3 \n             result [2]]\n        (println x result)\n        (if (< (count result) n)\n          (recur (+ x 2) (if (prime? x) (conj result x) result))\n          result))))", "user": "5ab1665de4b073f1774425c0"}, {"problem": 67, "code": "(fn get-primes [x]\n  (loop [primes [2]]\n    (if (= (count primes) x)\n      primes\n      (recur (conj primes\n                   (loop [candidate-prime (inc (last primes))]\n                     (if (loop [k 2]\n                           (if (= 0 (rem candidate-prime k))\n                             false\n                             (if (> k (/ candidate-prime 2))\n                               true\n                               (recur (inc k)))))\n                       candidate-prime\n                       (recur (inc candidate-prime)))))))))", "user": "549ffeade4b0f3d1d8e70fb2"}, {"problem": 67, "code": "#( loop [ x (dec %) res [2] i 3 ]\n   (if (= x 0)\n    res\n   (if ((set ( for[ j res ] (mod i j) )) 0)\n    (recur x res (+ i 2))\n    (recur (dec x) (conj res i) (+ i 2))\n   )\n     \n    )\n   )", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(prime? [n]\n                  (not-any? #(zero? (mod n %)) (range 2 n)))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "59ef6cfae4b0966464fe6a32"}, {"problem": 67, "code": "(fn [n]\n (->> (range)\n  (drop 2)\n  (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x))))\n  (take n)))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 67, "code": "(fn [n]\n   (let [prime? (fn [x]\n                  (not (some #(zero? (rem x %))\n                             (range 2 (inc (Math/sqrt x))))))]\n     (take n (cons 2 (filter prime? (iterate inc 2))))))", "user": "56e2ca59e4b03a7c14b85a38"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n]\n                 (cond\n                  (< n 2) false\n                  (= n 2) true\n                  (= n 3) true\n                  (= (mod n 2) 0) false\n                  (= (mod n 3) 0) false\n                  :else (loop [i 5 w 2]\n                          (cond\n                           (> (* i i) n) true\n                           (= (mod n i) 0) false\n                           :else (recur (+ i w) (- 6 w))))))]\n    (loop [x 2 result []]\n      (cond\n       (= (count result) n) result\n       (prime? x) (recur (inc x) (conj result x))\n       :else (recur (inc x) result)))))", "user": "5b4fef74e4b02d533a91bcde"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-prime? (fn [x] (every? #(not= 0 (mod x %)) (range 2 (dec x))))]\n    (->> (range)\n         (map #(+ 2 %))                 ;start at 2\n         (filter is-prime?)\n         (take n))))", "user": "524740e7e4b05ef8e38e635d"}, {"problem": 67, "code": "(fn primes [n]\n  (loop \n    [x 2 result []]\n    (cond\n     (= (count result) n)\n     result\n     (= 1 (reduce + \n                   (filter \n                    #(= 0 (mod x %)) \n                    (range 1 x)\n                    )\n                   )\n        )\n     (recur (inc x) (conj result x))\n     :else\n     (recur (inc x) result)\n     )\n    )\n  )", "user": "5b5e5019e4b0c6492753e6d3"}, {"problem": 67, "code": "(fn primes [limit]\n  (let [prime? (fn [n primes]\n                 (or\n                  (= 2 n)\n                  (some #(= n %) primes)\n                  (every? #(not (= 0 (mod n %))) primes)))\n        sieve  (fn [acc [x & xs]]\n                 (if (= limit (count acc))\n                   acc\n                   (recur (if (prime? x acc)\n                            (conj acc x)\n                            acc)\n                          xs)))]\n    (sieve [] (drop 2 (range)))))", "user": "590d3702e4b047aa04b199ff"}, {"problem": 67, "code": "(fn nth-prime [n]\n  (case n\n    1 [2]\n    2 [2 3]\n    3 [2 3 5]\n    4 [2 3 5 7]\n    5 [2 3 5 7 11]\n    6 [2 3 5 7 11 13]\n    (letfn [(is-prime? [x coll]\n              (loop [i 0]\n                (if (and (< i (count coll)) (< (coll i) (/ x 2)))\n                  (if (zero? (mod x (coll i))) false (recur (inc i)))\n                  true)))]\n      (let [prev (nth-prime (dec n))]\n        (conj prev (loop [i (+ (last prev) 2)]\n                     (if (is-prime? i prev) i (recur (+ i 2)))))))))", "user": "5b5e7953e4b0c6492753e6d9"}, {"problem": 67, "code": "(fn generate-n-primes\n  ([counter]\n   (generate-n-primes [] counter))\n  ([res counter]\n   (if (= 0 counter)\n     res\n     (let [is-prime? (fn [n]\n                       (let [max (Math/ceil (Math/sqrt n))]\n                         (or (= n 2)\n                             (and (not (= 1 n))\n                                  (every? #(> (mod n %) 0) (range 2 (+ max 1)))))))\n           get-next-prime (fn [n]\n                            (let [next-int (inc n)]\n                              (if (is-prime? next-int)\n                                next-int\n                                (recur next-int))))\n           next-prime (if (empty? res)\n                        (get-next-prime 0)\n                        (get-next-prime (last res)))]\n       (recur (conj res next-prime) (dec counter))))))", "user": "5b478997e4b02d533a91bc71"}, {"problem": 67, "code": "(fn get-primes\n    [num]\n    (let [prime? (fn [n primes]\n                     (cond\n                       (>= 1 n) false\n                       (>= 3 n) true\n                       (even? n) false\n                       (empty? (filter #(= 0 (mod n % )) primes)) true\n                       :else false))]\n    (loop [current 2 acc []]\n      (if (>= (count acc) num)\n        acc\n        (recur (inc current)\n               (if (prime? current acc)\n                 (conj acc current)\n                 acc))))))", "user": "5b477969e4b02d533a91bc6f"}, {"problem": 67, "code": "(fn primes [x]\n  (take x (filter (partial (fn is-prime? [i n]\n                             (cond (<= n 1)        false\n                                   (<= n 3)        true\n                                   (= 0 (mod n i)) false\n                                   (< n (* i i))   true\n                                   :else           (recur (inc i) n))) 2) (range))))", "user": "51a3be77e4b0e77c4ca60bf8"}, {"problem": 67, "code": "(fn nprimes [n]\n  (letfn [(next-prime\n            [primes]\n            (some\n              (fn [candidate]\n                (if\n                  (every? (partial not= 0) (map #(mod candidate %) primes))\n                  candidate\n                  false))\n              (iterate inc (inc (last primes)))))]\n    (loop [primes [2]]\n      (if\n        (>= (count primes) n)\n        primes\n        (recur (conj primes (next-prime primes)))))))", "user": "5779556de4b0979f8965166e"}, {"problem": 67, "code": "; Primality test as per https://en.wikipedia.org/wiki/Primality_test\n; (Test up to sqrt(n) with some additional optimizations.)\n#(letfn [(prime? [n]\n   (cond\n     (<= n 1) false\n     (<= n 3) true\n     (or (zero? (mod n 2))\n         (zero? (mod n 3))) false\n     :else\n       (loop [i 5]\n         (if (<= (* i i) n)\n           (if (or (zero? (mod n i))\n                   (zero? (mod n (+ i 2))))\n             false\n             (recur (+ i 6)))\n           true))))]\n   (take % (filter prime? (range))))", "user": "5b772ad7e4b047b03b2036e8"}, {"problem": 67, "code": "(fn[a](take a (filter #(.isProbablePrime (BigInteger/valueOf %)5)(range Integer/MAX_VALUE))))", "user": "5826a843e4b051871117befd"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime [x]\n  \t\t\t(every? pos? (map mod (repeat x) (range 2 x))))]\n    (->> (range)\n         (filter is-prime)\n         (drop 2)\n         (take n))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 67, "code": "(fn [n]\n  (let [sieve (fn sieve [s]\n                (cons (first s)\n                      (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                               (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "4db1fe241254ad5b4805fa77"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5b83c11ae4b047b03b2037b7"}, {"problem": 67, "code": "#(let [p? (fn [n]\n            (not-any? zero? (map (fn [x] \n                                   (mod n x)) (range 2 n))))\n       p (fn []\n           (filter p? (iterate inc 2)))]\n   (take % (p)))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 67, "code": "(fn first-primes [n]\n    (let [prime? (fn [i mvec] (every? #(pos? (rem i %)) mvec))\n          gen-prime (fn [n i mvec]\n                      (if (pos? n)\n                        (if (prime? i mvec)\n                          (recur (dec n) (+ i 2) (conj mvec i))\n                          (recur n (+ i 2) mvec))\n                        mvec))]\n      (gen-prime (dec n) 3 [2])))", "user": "59cd13d5e4b0ef0a1e9b5b32"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [x]\n                    (cond\n                      (< x 2) false\n                      (= x 2) true\n                      :else  (every? #(not= (rem x %) 0) (range 2 (Math/sqrt (inc x))))))\n                  (iterate inc 2))))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 67, "code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n    (take n (drop 2 (filter no-prime?* (range))))))", "user": "5b97c521e4b0c0b3ffbd4a9a"}, {"problem": 67, "code": "(fn [k]\n    (letfn [\n        (-is-prime? [primes n] (every? #(> (mod n %) 0) primes))\n    ]\n    (loop [primes [] n 2]\n        (cond \n            (>= (count primes) k) primes\n            (-is-prime? primes n) (recur (conj primes n) (inc n))\n            :else                 (recur primes (inc n))))))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime [x] (every? #(not (= 0 (rem x %))) (range 2 x)))]\n    (take n (filter is-prime (nthrest (range) 2)))))", "user": "5b88f0c0e4b047b03b203816"}, {"problem": 67, "code": "(fn sieve \n  ([n] (take n (reverse (sieve (range 2 542) `()))))\n  ([coll primes]\n    (if (empty? coll)\n      primes\n      (let [fColl (filter #(not (= 0 (mod % (first coll)))) (rest coll))]\n        (sieve fColl (cons (first coll) primes))))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 67, "code": "(fn [n]\n          (loop [primes [2]]\n            (if (= (count primes) n)\n              primes\n              (let [prime\n                    (loop [primeCandidate (inc (last primes))]\n                      (let [primeCandidateSqrt (Math/sqrt primeCandidate)\n                            divider\n                            (loop [dividerCandidateIndex 0]\n                              (let [dividerCandidate (primes dividerCandidateIndex)]\n                                (if (<= dividerCandidate primeCandidateSqrt)\n                                  (if (not= (mod primeCandidate dividerCandidate) 0)\n                                    (recur (inc dividerCandidateIndex))\n                                    dividerCandidate)\n                                  nil)))]\n                        (if (not divider)\n                          primeCandidate\n                          (recur (inc primeCandidate)))))]\n                (recur (conj primes prime))))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 67, "code": "(fn first-n-primes-2 [n]\n  (->> (take (dec n)\n         (remove #(some (fn divisor? [d]\n                          (= 0 (mod % d)))\n                        (range 2 (inc (Math/sqrt %))))\n                  (drop 2 (range))))\n       (cons 2)))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (take n\n        (filter (fn [number]\n                  (every? #(not (zero? (rem number %)))\n                          (range 2 (-> number Math/sqrt inc int))))\n                (range 2 Double/POSITIVE_INFINITY))))", "user": "5a0ef454e4b04bbd27e6d9fa"}, {"problem": 67, "code": "(fn [cnt] (take cnt (filter (fn [i] (every? #(> (mod i %) 0) (range 2 (inc (/ i 2))))) (drop 2 (range)))))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 67, "code": ";(fn [x]\n;  (case x\n;    2 [2 3]\n;    5 [2 3 5 7 11]\n;    100 [541]\n;  ))\n(fn [x]\n\n  (vec (take x (filter \n   (fn [n] (not-any? zero? (map #(rem n %) (range 2 n))))\n   (seq (range 2 (* x x)))\n  )))\n)", "user": "54b331dbe4b09f271ff37d37"}, {"problem": 67, "code": "(fn [n]\n    (let [is-prime? (fn [x] (every? #(< 0 (mod x %)) (range 2 x)))]\n      (->> (range)\n           (drop 2)\n           (filter is-prime?)\n           (take n))     \n    )\n  )", "user": "570d0548e4b0b0fb43fd06d2"}, {"problem": 67, "code": "(fn [n]\n   (loop [primes [2]\n          i 3]\n     (if (= (count primes) n)\n       primes\n       (if (some zero? (map #(rem i %) primes))\n         (recur primes (inc i))\n         (recur (conj primes i) (inc i))))))", "user": "5b2a559be4b063e2438bcc74"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        ((fn primes\n          ([] (primes (iterate inc 2)))\n          ([xs]\n           (lazy-seq (cons (first xs) (primes (filter #(if (= 0 (rem % (first xs))) false true) (rest xs))))))))))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 67, "code": "(fn[n] (take n (filter #(if (> % 1)\n  (loop [i 2]\n   (if (> (* i i) %)\n    true\n    (if (= 0 (mod % i))\n      false\n      (recur (inc i))\n     )))) (range) )\n          ))", "user": "5b99a0a3e4b0c0b3ffbd4ad7"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-prime (fn [n] (not-any? #(= 0 (mod n %)) (range 2 n)))]\n    (take n\n          (filter is-prime (iterate inc 2)))))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 67, "code": "(fn primes [n] (if (< n 2) \n                 [2]\n                 (let [ps (primes (dec n))\n                       prime? (fn [a] (not-any? #(= 0 (mod a %)) ps))]\n                   \t   (conj ps (first (filter prime? (drop (last ps) (range))))))))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 67, "code": "(letfn [(prime?\n         [n]\n         (not (some #(= 0 (mod n %))\n                    (range 2 (inc (/ n 2))))))]\n  #(take % (filter prime? (map (comp inc inc) (range)))))", "user": "5829d9f8e4b051871117bf4d"}, {"problem": 67, "code": "(fn [n] (loop [p [2] n (dec n) i 3]\n                    (if (zero? n) p\n                        (if (every? #(pos? (rem i %)) p)\n                          (recur (conj p i) (dec n) (+ 2 i))\n                          (recur p n (+ 2 i))))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 67, "code": "(fn get-primes\n  [n]\n  (letfn [(prime? [_n]\n            (not (some #(and (< % _n) (= 0 (mod _n %))) (range 2 (Math/sqrt (inc _n))))))]\n    (take n (filter prime? (iterate inc 2))))\n  )", "user": "5b9c4a7be4b0c0b3ffbd4b16"}, {"problem": 67, "code": "#(take %\n       (cons\n        2\n        ((fn f [[x & xs]]\n           (cons\n            x\n            (lazy-seq (remove (fn [elt] (= 0 (mod elt x)))\n                              (f xs)))))\n         (iterate (partial + 2) 3))))", "user": "5bc39d2be4b07a9b28b10045"}, {"problem": 67, "code": "(fn [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(zero? (rem n %)) (range 2 n))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5b85221ce4b047b03b2037c8"}, {"problem": 67, "code": "(fn get-primes\n  ;; this one will do 10000 in 105msecs, 1M in 112secs :)\n  [length]\n  (letfn [(lazy-odds [x] (lazy-seq (cons x (lazy-odds (+ 2 x)))))]\n    (let [prime? (fn [x] \n                   (loop [factor-max (Math/sqrt x)\n                          pass 2]\n                     (if (> pass factor-max)\n                       true\n                       (if (= 0 (mod x pass))\n                         false\n                         (recur factor-max (inc pass))))))]\n      (take length (cons 2 (filter #(prime? %) (lazy-odds 3)))))))", "user": "599342efe4b0b211ea3aaab0"}, {"problem": 67, "code": "(fn [c]\n  (take c (filter\n    (fn [n]\n      (every?\n          (fn [k] (> (mod n k) 0))\n          (take-while (fn [k] (<= (* k k) n)) (range 2 n))))\n    (map (partial + 2) (range)))))", "user": "5bc9e3e9e4b07a9b28b100e2"}, {"problem": 67, "code": "(fn\n  [x]\n  (letfn [(prime-sieving\n            ([] (prime-sieving (iterate inc 2)))\n            ([[f & r]] (lazy-seq (cons f (prime-sieving (remove #(= 0 (mod % f)) r))))))]\n    (take x (prime-sieving))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 67, "code": "(fn prime [n]\n  (loop [lim n\n         nxt 0\n         acc []]\n    (cond\n      (= lim 0) acc\n      (= (filter #(= 0 (rem nxt %)) (range 1 (inc nxt))) (list 1 nxt))\n            (recur (dec lim) (inc nxt) (conj acc nxt))\n      :else (recur lim (inc nxt) acc))))", "user": "54ca35c6e4b057c6fda3a254"}, {"problem": 67, "code": "#(map last (take % (iterate (fn next-prime [x] \n(loop [c (inc (last x))]\n\t(if (= x (for [i x :while (not (zero? (rem c i)))] i)) \n\t\t(conj x c)\n\t\t(recur (inc c))\n\t))) [2])))", "user": "5b7bc82ce4b047b03b203726"}, {"problem": 67, "code": "(fn [n]\n  (loop [xs [2]]\n    (if (= n (count xs))\n      xs\n      (recur (conj xs\n                   (loop [x (-> xs last inc)]\n                     (if (some (comp zero? (partial rem x))\n                               (->> x Math/sqrt Math/floor inc (range 2) (filter odd?) (cons 2)))\n                       (recur (inc x)) x)))))))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [primes x]\n            (not (some true? (map #(= 0 (mod x %))\n                                  (filter (partial >= (Math/sqrt x)) primes)))))]\n    (loop [primes [] i 2]\n      (if (= (count primes) n) primes\n          (let [next-prime (first (filter (partial prime? primes) (drop i (range))))]\n            (recur (conj primes next-prime) (inc next-prime)))))))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [v] (or (= 2 v)\n                          (->> (range 2 (inc (Math/sqrt v)))\n                               (map #(rem v %))\n                               (some zero?)\n                               not)))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "5592ba8be4b0c79f6e1db931"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (loop [s 2 f []]\n      (if (= (count f) n)\n        f\n        (if (empty? f)\n          (recur (inc s) [s])\n          (if (= f (filter #(not= 0 (mod s %)) f))\n            (recur (inc s) (conj f s))\n            (recur (inc s) f)\n          )\n        ) \n      )\n    )\n  )\n)", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 67, "code": "(fn primes [n]\n    (let [prime? (fn [n]\n                   (every? (fn [x]\n                             (not= (mod n x)\n                                   0))\n                           (drop 2\n                                 (range n))))]\n      (take n\n            (filter prime?\n                    (drop 2\n                          (range))))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "575f6a80e4b08062f99a4e80"}, {"problem": 67, "code": "#(first (drop % (iterate (fn [xs]\n                            (loop [x (inc (or (last xs) 1))]\n                              (if (every? (comp not zero? (partial rem x)) xs)\n                                (conj xs x)\n                                (recur (inc x))\n                                )\n                              )\n                             ) [])))", "user": "5be0306be4b0ed4b8aab4c7d"}, {"problem": 67, "code": "(fn [y] (take y (\n(fn prm [x] (lazy-seq\n            (if (empty? (filter #(= 0 (rem x %)) (range 2 (inc (quot x 2)))))\n              (cons x (prm (inc x)))  (prm (inc x))\n             )\n           )\n) 2)))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 67, "code": "(letfn [(next-prime [previous-primes]\n  (loop [curr (inc (last previous-primes))]\n    (if (some #(zero? (mod curr %)) previous-primes)\n      (recur (inc curr))\n      (conj previous-primes curr))))]\n  \n  #(take % (map last (iterate next-prime [2]))))", "user": "5b60e88be4b0c6492753e70b"}, {"problem": 67, "code": "(fn [n]\n  (take n\n    (remove (fn [k] (some #(= 0 (rem k %)) \n                           (range 2 k)))\n            (iterate inc 2))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter (fn [x]\n                  (not-any? #(= 0 (mod x %)) (range 2 x)))\n                (drop 2 (range)))))", "user": "5be33a16e4b0ed4b8aab4cd6"}, {"problem": 67, "code": "(fn my-prime [x]\n  (loop [i 2\n         primes []]\n    (if (= (count primes) x)\n      primes\n      (cond (empty? (filter true? (map (fn [s] (= (mod i s) 0)) (range 2 i))))\n            (recur (inc i) (conj primes i))\n            :else (recur (inc i) primes)))))", "user": "5bf50e76e4b0b326c961d8a0"}, {"problem": 67, "code": "(fn [n]\n  (loop [out []\n         x 2]\n    (if (= (count out) n)\n      out\n      (recur (if (some #(= 0 (mod x %)) out) out (conj out x))\n             (inc x)))))", "user": "5bf5ddfde4b0bdcf453d159e"}, {"problem": 67, "code": "(fn primes\n  ([ct] (primes ct [2]))\n  ([ct primes-so-far]\n   (if (= ct (count primes-so-far))\n     primes-so-far\n     (recur ct (conj primes-so-far\n                     (first (filter (fn [possible-prime]\n                                      (nil? (some #(= 0 (mod possible-prime %)) primes-so-far)))\n                                    (map #(inc (+ (last primes-so-far) %)) (range)))))))))", "user": "5bfa25fbe4b0bdcf453d15c8"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter \n            (fn is-prime [n]\n                (nil?\n                  (some\n                    #(zero? (mod n %))\n                    (range 2 n))))\n            (iterate inc 2))))", "user": "5bf1b957e4b0a6d31fed216f"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5b57505ce4b02d533a91bd55"}, {"problem": 67, "code": "(fn lazy-primes3\n  ([n] (take n (lazy-primes3)))\n  ([]\n    (letfn [(enqueue [sieve n step]\n              (let [m (+ n step)]\n                (if (sieve m)\n                  (recur sieve m step)\n                  (assoc sieve m step))))\n            (next-sieve [sieve candidate]\n              (if-let [step (sieve candidate)]\n                (-> sieve\n                  (dissoc candidate)\n                  (enqueue candidate step))\n                (enqueue sieve candidate (+ candidate candidate))))\n            (next-primes [sieve candidate]\n              (if (sieve candidate)\n                (recur (next-sieve sieve candidate) (+ candidate 2))\n                (cons candidate\n                  (lazy-seq (next-primes (next-sieve sieve candidate)\n                              (+ candidate 2))))))]\n      (cons 2 (lazy-seq (next-primes {} 3))))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 67, "code": "(fn [n] (vec (take n (filter\n\t(fn [x]\n\t\t(if (> x 1)\n\t\t(not (some (fn [y] (zero? (rem x y))) (range 2 x)))\n\t\tfalse))\n\t(iterate inc 1)))))", "user": "5c0e58bfe4b01240ff567140"}, {"problem": 67, "code": "(fn [x] (take x (filter #(every? (fn [y] (not= 0 (mod % y))) (range 2 %)) (iterate inc 2))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 67, "code": "(fn [n]\n  (take n (drop 2\n    (filter\n     (fn prime? [k]\n       (not-any? #(= (mod k %) 0)\n         (range 2 k)\n       )\n     )\n     (range)\n    )\n  ))\n)", "user": "5c0d0537e4b0bdcf453d173d"}, {"problem": 67, "code": "(fn [cnt]\n  (loop [res [], curr 2] \n    (let [have-enough (= (count res) cnt)\n          is-prime (not-any? #(zero? (rem curr %)) (range 2 curr))]\n    (if have-enough res\n    \t(if is-prime \n          (recur (conj res curr) (inc curr))\n          (recur res (inc curr)))))))", "user": "5c13da47e4b01240ff5671a6"}, {"problem": 67, "code": "(fn [n]\n  (loop [cnt n\n         number 2\n         start 2\n         r []]\n    (if (= cnt 0)\n      r\n      (if (= number 2)\n        (recur (dec cnt) (inc number) 2 (conj r number))\n        (if (< number (* start start))\n          (recur (dec cnt) (inc number) 2 (conj r number))\n          (if (= (mod number start) 0)\n            (recur cnt (inc number) 2 r)\n            (recur cnt number (inc start) r)))))))", "user": "5ac9c737e4b0e27600da77d2"}, {"problem": 67, "code": "#(take % (filter (fn is-prime [x] (= (- x 2) (count (take-while (fn [y] (not= 0 (rem x y))) (range 2 (inc x)))))) (range)))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 67, "code": "(fn [x]\n  (letfn\n    [(prime?\n       [n]\n       (cond\n         (< n 2) false\n         (= n 2) true\n         (= n 3) true\n         (= 0 (rem n 2)) false\n         (= 0 (rem n 3)) false\n         :else (loop [i 5 w 2]\n                 (if (> (* i i) n)\n                   true\n                   (if (zero? (rem n i))\n                     false\n                     (recur (+ i w) (- 6 w))\n                     )\n                   )\n                 )\n         )\n       )\n     ]\n    (take x (filter prime? (range))) )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 67, "code": "(fn [v] (take v\n\t(filter\n    \t(fn [x] (not-any? #(= 0 (rem x %)) (range 2 x)))\n     \t(iterate inc 2))))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 67, "code": "(fn n-primes\n  [n]\n  (letfn [(prime-iter [n k limit]\n            (cond (> (* n n) limit) true\n                  (zero? (rem limit n)) false\n                  :else (recur (+ n k) (- 6 k) limit)))\n          (prime? [n]\n            (cond (< n 2) false\n                  (= n 2) true\n                  (= n 3) true\n                  (or (= 0 (mod n 2)) (= 0 (mod n 3))) false\n                  (< n 9) true\n                  :else (prime-iter 5 2 n)))]\n    (take n (filter prime? (range)))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [x] (not-any? #(= 0 (mod x %)) (range 2 x))) (iterate inc 2))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 67, "code": "(fn me\n  ([n]\n    (take n (lazy-seq (cons 2 (me 3 [2])))))\n  ([s prev]\n    (let [p (loop [n s]\n              (if (not-any? #(= 0 %) (map #(rem n %) prev))\n                  n\n                  (recur (inc n))))]\n          (lazy-seq (cons p (me (inc p) (conj prev p))))))\n)", "user": "5c219c0fe4b07e362c230581"}, {"problem": 67, "code": "(fn [n](take n (lazy-seq (filter (fn [m](every? #(not (zero? (mod m %))) (range 2 m) )) (rest (rest (range)))) )) )", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 67, "code": "(fn [x]\n  (let [p? (fn [x]\n             (every? #(not= 0 (mod x %)) \n                     (range 2 (inc (/ x 2)))))]\n    (take x (filter p? (iterate inc 2)))))", "user": "54df2609e4b024c67c0cf7a9"}, {"problem": 67, "code": "(fn primes [n]\n  (loop [[primes cand :as primes-cand] [[2] 3]\n         i 1]\n    (if (< i n)\n      (recur\n       (loop [[prime & rest] primes\n              test cand]\n         (if (or (nil? prime) (> prime (Math/sqrt test)))\n           (vector (conj primes test) (+ 2 test))\n           (if (zero? (mod test prime))\n             (recur primes (+ 2 test))\n             (recur rest test))))\n       (inc i))\n      primes)))", "user": "5c195cb2e4b01240ff5671f7"}, {"problem": 67, "code": "(fn [y] (take y (filter (fn [x] (empty? (filter zero?\n        (map (partial mod x) (drop 2 (range (- x 1)))) ))) (drop 2 (range)))))", "user": "5c308385e4b0d62ef62d9f1c"}, {"problem": 67, "code": "(fn [size]\n  (import 'java.math.BigInteger)\n  (letfn [\n          (primes [n] \n            (lazy-seq (cons n (primes (.nextProbablePrime (BigInteger/valueOf n))))))\n         ]\n         (take size (primes 2)))\n  )", "user": "5c17467fe4b01240ff5671df"}, {"problem": 67, "code": "(fn primes [n]\n  (take n\n    (filter (fn [k] (every? #(not= (mod k %) 0) (range 2 k))) (iterate inc 2))\n    ))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2] i 3]\n    (if (= n (count primes))\n      primes\n      (if (not-any? #(zero? (mod i %)) primes)\n        (recur (conj primes i) (inc i))\n        (recur primes (inc i))))))", "user": "50eeeadae4b02c17778c91f3"}, {"problem": 67, "code": "#(take % (drop 2 (filter (fn [x] (every? (fn [y] (> (rem x y) 0)) (range 2 x))) (range))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 67, "code": "(fn [x]\n    (letfn [(prime? [y]\n            (let [half (+ 1 (/ y 2))\n                  poten-factors (range 1 half)]\n                (filter #(= 0  (mod y %)) poten-factors)))]\n        (drop 2 (take (+ 2 x) (filter #(> 2 (count (prime? %))) (range))))))", "user": "5748905ae4b009280f9f2b8e"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "56f4623ae4b046a417f9205d"}, {"problem": 67, "code": "(fn [x](take x (remove #(some (fn [x] (= 0 (rem % x)))(range 2 %))(iterate inc 2))))", "user": "5c32ea85e4b0d62ef62d9f3e"}, {"problem": 67, "code": "(fn primes \n  ([number] \n   (primes number 2))\n  ([cnt c] \n    (cond \n      (= 0 cnt) []\n      :else (cons c \n              (primes \n                (dec cnt) \n                ((fn [a]\n                  (cond \n                    ((fn [a b]\n                      (cond \n                        (= a b) true\n                        (zero? (mod a b)) false\n                        :else (recur a (inc b)))) a 2) a\n                      :else (recur (inc a)))) \n                  (inc c)))))))", "user": "59733c91e4b01722bebd4c9b"}, {"problem": 67, "code": "(fn p67 [num]\n  (letfn [(is-prime [num] (not (some #(= 0 (mod num %)) (range 2 num ))))]\n    (loop [count num\n           acc [2]\n           start 3]\n\n      (if (= count 1)\n        acc\n        (if (is-prime start)\n          (recur (dec count) (conj acc start) (inc start))\n          (recur count acc (inc start))\n          )\n        )\n      )\n    )\n  )", "user": "53b0750fe4b047364c044483"}, {"problem": 67, "code": "(fn primes\n  ([n] (take n (primes n 2)))\n  ([n prev]\n   (cons prev\n         (lazy-seq\n           (primes n\n             ((fn next-prime [x]\n                (if (every? #(not (= (rem x %) 0)) (range 2 (inc (Math/sqrt x))))\n                  x\n                  (recur (inc x)))) (inc prev)))))))", "user": "5c3f37fce4b08cd430848e91"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-prime? #(not-any? (fn [x] (zero? (mod % x))) (range 2 %))]\n    (take n (filter is-prime? (iterate inc 2)))))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 67, "code": "(fn prime-seq\n    [len]\n    (loop [re []\n           cur 2]\n      (if ( = len (count re))\n        re\n        (recur (if ((fn isPrime?\n    [x]\n    (loop [origin x\n           cur (int (Math/sqrt x))]\n      (if (= cur 1)\n        true\n        (if (= 0 (mod origin cur))\n          false\n          (recur origin (dec cur)))))) cur)\n                 (conj re cur)\n                 re)\n               (inc cur)))))", "user": "59b9e669e4b0a024fb6ae3db"}, {"problem": 67, "code": "(fn get-prime-numbers [n]\n  (let [is-prime\n        (fn [n]\n          (cond\n            (<= n 1) false\n            (<= n 3) true\n            (or (= (mod n 2) 0)\n                (= (mod n 3) 0))\n            false\n            :always\n            (loop [i 5]\n              (cond\n                (> (* i i) n)\n                true\n                (or\n                    (= 0 (mod n i))\n                    (= 0 (mod n (+ i 2))))\n                false\n                :always\n                (recur (+ i 6))))))\n        prime-numbers\n        (fn prime-numbers\n          ([] (prime-numbers 2))\n          ([n] (lazy-seq (if\n                           (is-prime n)\n                           (cons n (prime-numbers (inc n)))\n                           (prime-numbers (inc n))))))]\n    (take n (prime-numbers))))", "user": "5984e7dee4b021a7a535fe43"}, {"problem": 67, "code": "(fn primes \n  ([] \n   (->> ['() (drop 2 (range))]\n        (iterate (fn [[selected remaining]] \n                   [(cons (first remaining) selected) \n                    (remove #(= 0 (mod % (first remaining))) (rest remaining))]))\n        rest\n        (map first)\n        (map first)))\n  ([n] (take n (primes))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 67, "code": "(fn [n]\n    (->> (range)\n         (drop 2)\n         (filter (fn [x] (not-any? #(zero? (rem x %)) (range 2 x))))\n         (take n)))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 67, "code": "#(take % (filter \n          (fn\n            [x]\n            (let [akar-x (Math/sqrt x)\n                  iter (fn iter [i]\n                             (cond\n                               (> i akar-x) true\n                               (zero? (rem x i)) false\n                               :else (iter (+ i 2))))]\n             (cond\n               (<= x 1) false\n               (= x 2) true\n               (even? x) false\n               :else (iter 3))))\n          \n          \n          (range)))", "user": "5c435a9fe4b0e06e1360a367"}, {"problem": 67, "code": "(fn [i]\n  (let [; Make sets of times tables from 2 -> 2+i of length i-squared,\n        ; dropping the starting number, which might be prime\n        blacklists (->> (range 2 (+ 2 i))\n                        (map #(iterate (partial + %) (+ % %)))\n                        (map (comp set (partial take (* i i)))))]\n    ; Sieve of Eratosthenes\n    (->> ; nth prime will be less than n-squared\n         (range 2 (* i i))\n         ; if no blacklist has the prime, include it\n         (reduce (fn [primes prime?]\n                   (if (not-any? #(% prime?) blacklists)\n                     (conj primes prime?)\n                     primes)) [])\n         (take i)))) ; take as many as we want", "user": "4fe899a6e4b07c9f6fd12c54"}, {"problem": 67, "code": "(fn [cnt]\n  (take cnt\n        (filter (fn primes [n]\n                  (every? #(not= (mod n %) 0) (range 2 n)))\n                (drop 2 (range)))))", "user": "5c62979fe4b0fca0c162264c"}, {"problem": 67, "code": "(fn [a] (take a (reduce #(if (not-any? (fn [x] (and (= 0 (mod %2 x)) (not= x %2))) %) (conj % %2) %) [] (range 2 1000))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  ((fn tmp [i res] \n    (cond\n      (= n (count res)) res\n      ((fn is-prime [n]\n  (cond \n    (< n 2) false\n    (= 2 n) true\n    :else \n      (not (reduce #(or %1 %2) (map #(= 0 (mod n %)) (range 2 n))))\n  )) i) (tmp (inc i) (conj res i))\n      :else (tmp (inc i) res)\n    )) 2 []))", "user": "5c6748f0e4b0fca0c16226b6"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "51d42f44e4b013d740b70ddb"}, {"problem": 67, "code": "(fn [n]\n  (take\n    n\n    (filter\n      (fn is-prime [x]\n        (every?\n          (fn [y]\n            (not= 0 (rem x y)))\n          (range 2 x)))\n      (drop 2 (range)))))", "user": "5c73b8bae4b0fca0c16227ba"}, {"problem": 67, "code": "(fn [n]\n          \n          \n(let [f (fn [num] \n          (not-any? #(= 0 (mod num %))\n                    (range 2 num)))]\n  (take n (filter f \n                   (iterate inc 2)\n                   #_(range 2 12))))\n  )", "user": "58b12635e4b0ebc645576cf4"}, {"problem": 67, "code": "(fn [n]\n  (let [p? (fn [i] (->> i\n                        inc\n                        Math/sqrt\n                        (range 2)\n                        (map #(zero? (mod i %)))\n                        (not-any? true?)))]\n    (take n (filter p? (iterate inc 2)))))", "user": "5b14475be4b0cc2b61a3be5a"}, {"problem": 67, "code": "(fn [n]\n  (->> (range)\n       (drop 2)\n       (filter (fn [i] (every? #(not= 0 (rem i %)) (range 2 i))))\n       (take n)))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 67, "code": "(fn [x] (loop [primes []\n               n      2]\n          (if (= (count primes) x)\n            primes\n            (if (every? #(not (integer? (/ n %))) (range 2 n)) \n                (recur (conj primes n) (inc n))\n                (recur primes (inc n))))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n]\n                   (loop [i 2]\n                     (if (> i (Math/sqrt n)) true\n                       (if (zero? (rem n i))\n                           false \n                           (recur (inc i))))))]\n     (take n (filter prime? (iterate inc 2)))))", "user": "56483f45e4b0284900eef62b"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n]\n                   (loop [i 2]\n                     (if (= n i) true\n                       (if (zero? (rem n i))\n                           false \n                           (recur (inc i))))))]\n     (take n (filter prime? (iterate inc 2)))))", "user": "5a64dcabe4b0512ff01cd9a9"}, {"problem": 67, "code": "#( take % [2  3  5  7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71  73  79  83  89  97  101  103  107  109  113  127  131  137  139  149  151  157  163  167  173  179  181  191  193  197  199  211  223  227  229  233  239  241  251  257  263  269  271  277  281  283  293  307  311  313  317  331  337  347  349  353  359  367  373  379  383  389  397  401  409  419  421  431  433  439  443  449  457  461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599])", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 67, "code": "(fn p [x] (let [a (fn a [n y]\n            (if (= y x)\n              []\n              (if (some #(= 0 (mod n %))\n                        (range 2 (+ 1 (Math/sqrt n))))  \n                (a (+ n 1) y)\n                (cons n (a (+ n 1) (+ y 1))))))]\n    (into [2] (a 3 1))))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 67, "code": "(fn [x] (take x (filter #(loop [n (dec %1)]\n                           (if (= n 1) true\n                             (if (= (mod %1 n) 0) false\n                               (recur (dec n))))) (drop 2 (range)))))", "user": "5b22d30ee4b08b1df1c36750"}, {"problem": 67, "code": "(fn [n]\n  (let [sieve (fn [c] (remove #(zero? (mod % (first c))) c))\n        nats (drop 2 (range))]\n    (take n (map first (iterate sieve nats)))))", "user": "586bc870e4b01531a375e964"}, {"problem": 67, "code": "(fn pr[n]\n    (letfn [(has-factor [n primes]\n              (when (not-empty primes)\n                    (if (= 0 (mod n (first primes)))\n                      true\n                      (recur n (rest primes)))))\n              ]\n      (loop [count (dec n)\n             current 3\n             primes [2]]\n        (cond (= 0 count) primes\n              (has-factor current primes) (recur count (inc current) primes)\n              :default (recur (dec count) (inc current) (conj primes current))\n              ))))", "user": "57fc0719e4b0d3187e900987"}, {"problem": 67, "code": "(fn [n]\n          (loop [n (dec n)\n                 i 3\n                 primes [2]]\n            (if (zero? n)\n              primes\n              (if (some #(zero? (mod i %)) primes)\n                (recur n (inc i) primes)\n                (recur (dec n) i (conj primes i))))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 67, "code": "(fn [l] (\n                take l\n                  ((fn primes-seq\n                      ([]\n                       (primes-seq [] 2))\n                      ([primes n]\n                       (if (some zero? (map #(mod n %) primes))\n                         (lazy-seq (primes-seq primes (inc n)))\n                         (lazy-seq (cons n (primes-seq (cons n primes) (inc n))))))))))", "user": "5b100648e4b0cc2b61a3be17"}, {"problem": 67, "code": "(fn [n]\n  (loop [i 3\n         result [2]]\n    (if (= (count result) n)\n      result\n      (do\n        (let [res (reduce (fn [a b]\n                            (if (zero? (mod a b))\n                              0\n                              a))\n                          i (range 2 i))]\n          (recur (inc i)\n                 (if (zero? res)\n                   result\n                   (conj result res))))))))", "user": "5c558070e4b0fb8c5ffd9a1e"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(criba [s]\n              (cons (first s)\n                    (lazy-seq (criba (filter #(not= 0 (mod % (first s)))\n                                             (rest s))))))]\n      (take n (criba (iterate inc 2)))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 67, "code": "(fn [n]\n    (loop [primes [2]\n           x 3]\n      (cond\n        (= (count primes) n) primes\n        (every? #(not= 0 (mod x %)) primes) (recur (conj primes x) (inc x))\n        :else (recur primes (inc x)))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 67, "code": "(fn [n]\n (letfn [(prime? [x]\n               (not-any? zero? (map #(mod x %) (range 2 x))))]\n  (take n (filter prime? (drop 2 (range))))))", "user": "55ed37ebe4b0121d4835fdd6"}, {"problem": 67, "code": "(fn first-n-primes [cnt]\n  (let [isPrime? (fn [n]\n                   (not (some true?\n                              (map (comp zero? (partial mod n))\n                                   (range 2 (inc (quot n 2)))))))]\n    (take cnt (filter isPrime? (iterate inc 2)))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 67, "code": "(fn [x] (take x (filter\n                 (fn [n] (case n\n                           0 false\n                           1 false\n                           2 true\n                           (let [divs (range 2 (inc (Math/sqrt n)))]\n                             (empty?\n                              (filter\n                               #(= 0 (mod n %))\n                               divs))))\n                   )\n                 (range))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 67, "code": "(fn [n]\n  (take n \n    (reduce\n      (fn [primes number]\n        (if (some zero? (map (partial mod number) primes))\n          primes\n          (conj primes number)))\n      [2]\n      (take 1000 (iterate inc 3)))\n  )\n )", "user": "5cadd6a4e4b026601754b87b"}, {"problem": 67, "code": "(letfn [(sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))))]\n  (fn [n] (take n (sieve (iterate inc 2))))\n)", "user": "543bb568e4b032a45b869334"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "5cb71f35e4b026601754b961"}, {"problem": 67, "code": "(fn q67\n  ([x primes next-val]\n   (cond\n     (= x 0) primes\n     (some #(= 0 (rem next-val %)) primes) (recur x primes (inc next-val))\n     :else (recur (dec x) (conj primes next-val) (inc next-val))))\n  ([x] (q67 (dec x) [2] 3)))", "user": "5cab0ad9e4b048ec896c5c46"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5cbeadf2e4b0ccb061962755"}, {"problem": 67, "code": "#(take % (iterate (fn [after] (loop [candidate (inc after)]\n                                (if\n                                  ((fn [checked] (= 0 (count (filter (fn [modcheck] (= 0 (mod checked modcheck))) (range 2 (+ 1 (Math/sqrt checked))))))) candidate)\n                                  candidate\n                                  (recur (inc candidate))\n                                  ))) 2))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 67, "code": "#(loop [ plist [2] x 3] \n   (if(= % (count plist)) plist \n     (recur (if(not-any? zero? (for [y plist] (rem x y)))\n              (conj plist x)\n              plist)\n            (inc x))))", "user": "5cbd5b42e4b026601754b9f6"}, {"problem": 67, "code": "(fn [x](take x\n             (filter(fn [n]\n                      (not-any? zero? \n                                (map #(mod n %) \n                                     (range 2 n))))\n                    (range 2 999))))", "user": "5a6dbaf5e4b0512ff01cda63"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5ccb3792e4b0ccb061962882"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-prime (fn [x] (= 0 (count (filter #(= 0 (rem x %)) (range 2 (inc (Math/sqrt x)))))))]\n    (take n (cons 2 (filter is-prime (drop 3 (range)))))))", "user": "4fbe2cfbe4b081705acca30c"}, {"problem": 67, "code": "(fn [n]\n  (loop [l [2] n n]\n    (if (= 1 n)\n      l\n      (recur (conj l (first\n                       (filter\n                         (fn [i] (every? #(not= 0 (mod i %)) l))\n                         (map #(+ (last l) % 1) (range)))))\n             (dec n)))))", "user": "5ccf2dc3e4b0ccb0619628c2"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(is-prime [x]\n            (empty? (filter #(zero? (rem x %)) (range 2 x))))]\n    (take n (filter is-prime (rest (rest (range)))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 67, "code": "(fn [n]\n  (loop [c      2\n         primes '()\n         candidates (range 2 1000)]\n    (if (= n (count primes))\n      primes\n      (recur (first candidates) (concat primes [(first candidates)]) (filter #(not (zero? (mod % c))) (rest candidates))))))", "user": "5ca7b5bbe4b048ec896c5c04"}, {"problem": 67, "code": "(fn [n]\n  (loop [result [] input 2]\n    (if (= (count result) n)\n      result\n      (recur (if (some #(= 0 (mod input %)) result)\n               result\n               (conj result input))\n             (inc input)))))", "user": "5cbb0436e4b026601754b9cc"}, {"problem": 67, "code": "(fn [num-primes]\n  (take num-primes \n    (filter\n      (fn [candidate] (every? #(not= (rem candidate %) 0) (range 2 (dec candidate))))\n      (drop 2 (range)))))", "user": "5afb3426e4b0cc2b61a3bcf5"}, {"problem": 67, "code": "(fn [n]\n    (let [prime? (fn [n]\n                   (if (< n 2)\n                     false\n                     (not (some zero? (map (fn [v] (rem n v)) (range 2 n))))))]\n      (take n (filter prime? (range)))))", "user": "5a9bfd57e4b0d174b936c7d0"}, {"problem": 67, "code": "(fn primes2 [x]\n\t(letfn [(prime? [x]\n\t\t(loop [y 2]\n\t\t(cond\n\t\t\t(> y (Math/sqrt x)) true\t\n\t\t\t(= 0 (mod x y)) false\n\t\t\t:else (recur (inc y)))))]\n\n\t(loop [res [] cur 2 rem x]\n\t\t(if (= rem 0)\n\t\t\tres\n\t\t\t(if (prime? cur)\n\t\t\t\t(recur (conj res cur) (inc cur) (dec rem))\n\t\t\t\t(recur res (inc cur) rem))))))", "user": "5c87c79be4b048ec896c591b"}, {"problem": 67, "code": "(fn primes [n]\n  \"Seed prime list with 2, and count from 3 on (lazily), dividing by all previous primes.\"\n  (loop [primelist [2], x 3]\n    (if (= n (count primelist))\n      primelist   ;  We're done.\n      (if (some zero? (map #(mod x %) primelist))\n        (recur primelist (+ x 2))\n        (recur (conj primelist x) (+ x 2))))))", "user": "5cb4e764e4b026601754b929"}, {"problem": 67, "code": "(fn ps [n]\n   (take n\n     (sort (reduce (fn [ps x]\n                     (if (some #{0} (set (map #(mod x %) ps)))\n                        ps (conj ps x)))\n             #{2}\n             (map #(+ 2 %) (range 1000))))))", "user": "5cdfe2aee4b0a17bb84e2b04"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x] (every? #(not (zero? (mod x %))) (range 2 (Math/sqrt (inc x)))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [test] (not-any? #(= 0 (rem test %)) (range 2 (dec test)))) (iterate inc 2))))", "user": "5ce2b15fe4b0a17bb84e2b2c"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not-any? #(and (not= n %) (zero? (mod n %)))\n                           (range 2 (inc (Math/sqrt n)))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5cee521ce4b0aaa82f1129dd"}, {"problem": 67, "code": "(fn [m]\n    (take m\n      (map first (iterate\n             (fn [[p n pList]]\n              (let [n1 (+ n 2)]\n               (if (some #(zero? (rem n %)) pList)\n                    (recur [p n1 pList])\n                    [n n1 (conj pList n)]\n                )))\n             [2 3 [2]]))))", "user": "5cd4c3dae4b0ccb061962925"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5ceef51ee4b0aaa82f1129e9"}, {"problem": 67, "code": "(fn get-prime [n]\n  (letfn\n    [(is-prime [x]\n               (loop [d 2]\n                 (if (> d (/ x 2)) true\n                   (if (= 0 (mod x d)) false\n                     (recur (inc d))))))\n     ]\n    (->> (range)\n         (drop 2)\n         (filter is-prime)\n         (take n))))", "user": "5ce56455e4b0a17bb84e2b71"}, {"problem": 67, "code": "#(take % (letfn\n   [(prime? [x]\n      (every? pos? (for [k (range 2 x) :while (<= (* k k) x)] (mod x k)))\n    )]\n   (for [x (->> (range) (map (partial + 2))) :when (prime? x)] x)))", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 67, "code": "(fn [n] (letfn \n  [(f   [x]\n        (loop [x x y 2]\n           (if\n            (= 0 (rem x y))\n            nil\n            (if (> y (/ x 2))\n              y\n              (recur x (inc y))))))]\n (cons 2 (rest (take n (filter #(f %) (range)))))))", "user": "5b9ae606e4b0c0b3ffbd4af2"}, {"problem": 67, "code": "(fn [n] (take n ((fn sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s)))))) (range 2 9999))))", "user": "5a5894d9e4b05d388ecb6c81"}, {"problem": 67, "code": "(fn n-primes\n  [x]\n  (letfn [(prime?\n  [n]\n  (let [max (int (Math/sqrt n))]\n    (loop [i 2]\n      (cond\n        (some #{n} #{2 3})\n        true\n\n        (>= i max)\n        (if (= (mod n i) 0)\n          false\n          true)\n\n        (= (mod n i) 0)\n        false\n\n        :else\n        (recur (inc i))))))]\n  (loop [c x\n         n 2\n         acc []]\n    (if (> c 0)\n      (if (prime? n)\n        (recur (dec c) (inc n) (conj acc n))\n        (recur c (inc n) acc))\n      acc))))", "user": "5ce6f93be4b0a17bb84e2b99"}, {"problem": 67, "code": "#(take % (rest (rest (filter (fn prime?\n \t\t\t\t\t\t\t\t[n]\n \t\t\t\t\t\t\t\t(every? false? (for [x (range 2 (inc (Math/sqrt n)))]\n                  \t\t\t\t\t\t\t\t(if (and\n                        \t\t\t\t\t\t\t\t(= (mod n x) 0)\n                        \t\t\t\t\t\t\t\t(not= n x))\n                    \t\t\t\t\t\t\t\ttrue\n                    \t\t\t\t\t\t\t\tfalse)))) (range)))))", "user": "5cd4e1b2e4b0ccb061962927"}, {"problem": 67, "code": "(fn [x]\n  (letfn\n      [(prime? [n]\n         (or\n          (= n 2)\n          (not (some #(zero? (mod n %))\n                     (range 2 (inc (java.lang.Math/sqrt n)))))))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "54236ce1e4b01498b1a71ad1"}, {"problem": 67, "code": "(fn [s]\n  (let [sieve (fn sieve [s]\n                (cons (first s)\n                      (lazy-seq (sieve (remove #(zero? (mod % (first s))) s)\n                                       )\n                                )\n                      ))]\n\n    (take s (sieve (iterate inc 2)))\n    )\n  )", "user": "5baaae06e4b0a20761a23464"}, {"problem": 67, "code": "(fn [cnt]\n   (let [prime? (fn [n]\n                  (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                             (range 2 (inc (Math/sqrt n))))))]\n     (take cnt (filter prime? (iterate inc 2)))))", "user": "5c387c51e4b0d62ef62d9f83"}, {"problem": 67, "code": "(fn [n]\n  (loop [acc [] i 2]\n    (if (= n (count acc)) acc\n        (if (some #(= 0 (rem i %)) acc)\n          (recur acc (inc i))\n          (recur (conj acc i) (inc i))))))", "user": "5d126728e4b02c15ef02199a"}, {"problem": 67, "code": "(fn primes\n  [x]\n  (let [is-prime? (fn [x]\n                    (loop [i 2]\n                      (if (= x i)\n                        true\n                        (if (= 0 (rem x i))\n                          false\n                          (recur (inc i))))))]\n    (loop [out []\n           i 2]\n      (if (> (count out) (dec x))\n        out\n        (if (is-prime? i)\n          (recur (conj out i)\n                 (inc i))\n          (recur out\n                 (inc i)))))))", "user": "5d110abee4b02c15ef021983"}, {"problem": 67, "code": "(fn [x]\n  (let [prime? (fn [n] (not-any? #(zero? (mod n %)) (range 2 (dec n))))\n        next-prime (fn np [n]\n                     (loop [num (inc n)]\n                      (if (prime? num)\n                         (cons num (lazy-seq (np num)))\n                         (recur (inc num)))))]\n    (take x (next-prime 1))))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime-test [p]\n            (cond\n              (= 2 p)\n              p\n              ;; even test\n              (= 0 (rem p 2))\n              false\n              ;; divide test\n              (some #(= 0 %) (for [d (range 3 (+ (Math/sqrt p) 1) 2)]\n                               (rem p d)))\n              false\n              ;; all other cases\n              :else\n              p))] \n    (take n\n      (->> (range 2 1000)\n           (map prime-test)\n           (filter number?)))))", "user": "5a03d246e4b01bb0ae8afd8c"}, {"problem": 67, "code": "#(loop [res [], i 2]\n                  (if (= % (count res))\n                    res\n                    (recur\n                      (if ((fn [x] (loop [mo -1, j 2]\n                                     (cond\n                                       (or (= x 2) (= x 3))\n                                       true\n                                       (= x 4)\n                                       false\n                                       (and (= 0 mo) (<= j (int (/ x 2))))\n                                       false\n                                       (and (not= 0 mo) (= j (int (/ x 2))))\n                                       true\n                                       :else\n                                       (recur (mod x j) (inc j))\n                                       )\n                                     )\n                             ) i\n                           )\n                        (conj res i)\n                        res\n                        )\n                      (inc i)\n                      )\n                    )\n                  )", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 67, "code": "(fn [num]\n  (loop [acc (list 2)\n         curr 2]\n    (if (= (count acc) num)\n      (reverse acc)\n      (recur\n       (if (some #(= 0 (mod curr %)) acc)\n         acc\n         (cons curr acc))\n       (inc curr)))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 67, "code": "(fn\n  [n]\n  (letfn [(append-next-prime [primes]\n            (loop [n (inc (last primes))]\n              (if (loop [[p & primes] primes]\n                    (if (> p (Math/sqrt n))\n                      true\n                      (let [d (/ n p)]\n                        (if (= (int d) d)\n                          false\n                          (recur primes)))))\n                (conj primes n)\n                (recur (inc n)))))]\n    (loop [l [2]]\n      (if (= (count l) n)\n        l\n        (recur (append-next-prime l))))))", "user": "570c8ac3e4b0b0fb43fd06ca"}, {"problem": 67, "code": "(fn n-primes [n]\n  (loop [ps [2]\n         current 3]\n    (if (= (count ps) n)\n      ps\n      (if (every? #(not= (mod current %) 0)  ps)\n        (recur (conj ps current) (inc current))\n        (recur ps (inc current))))))", "user": "5cdc08a2e4b05ee0cb31173a"}, {"problem": 67, "code": "(fn get-prime [n]\n  (letfn [(prime? [n]\n            (if (< n 4)\n              true\n              (not\n               (some #(when (zero? (mod n %)) %)\n                     (range 2 (inc (/ n 2)))))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "5d272077e4b092dab7f59c64"}, {"problem": 67, "code": "(fn [n] (take n (letfn [(is-prime-num [x] (every? #(not= 0 (mod x %)) (range 2 x)))] (filter is-prime-num (range 2 1000)))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 67, "code": "(fn [n]\n  \t(cons 2\n\t\t(take (dec n) \n\t\t\t(filter\n\t\t\t\t(fn [x] (not-any? #(= 0 (mod x %)) (range 3 (inc (Math/sqrt x)) 2)))\n\t\t\t\t(iterate #(+ 2 %) 3)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5d2201b8e4b02ea6f0fb69ed"}, {"problem": 67, "code": "(fn [n]\n  (take n\n   (drop 2\n        (filter \n         (fn [m] (not-any? #(= 0 (mod m %)) (range 2 m)))\n         (range)))))", "user": "51dd5d6fe4b0c33a4e1da406"}, {"problem": 67, "code": "(fn [n]\n  (loop [acc []\n         cur (range)]\n    (cond\n     (= (count acc) n) \n     acc\n     ;; java-interop for the heck of it\n     (.isProbablePrime (.toBigInteger (bigint (first cur))) 100) \n     (recur (conj acc (first cur)) (rest cur))\n     :else \n     (recur acc (rest cur)))))", "user": "5d231255e4b02ea6f0fb69fe"}, {"problem": 67, "code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n(take n (drop 2 (filter no-prime?* (range))))))", "user": "5d29d837e4b01671435dbc6c"}, {"problem": 67, "code": "(fn prime-numbers [x]\n  (loop [idx 1 rt[]]\n   (if(= x (count rt))\n     rt\n     (letfn [(is-prime [n]\n                       (and (> n 1) (not-any? #(= (mod n %) 0) (range 2 n)))\n                       )]\n       (recur (inc idx) (if(is-prime idx) (conj rt idx) rt))\n       )\n     )\n   )\n  )", "user": "5d270111e4b092dab7f59c62"}, {"problem": 67, "code": "(fn primes\n  ([num] (take num (primes [] 2)))\n  ([curr next]\n    (lazy-seq (if (some #(= 0 (mod next %)) curr)\n                (primes curr (inc next))\n                (cons next (primes (conj curr next) (inc next)))))))", "user": "5d1c14cde4b02ea6f0fb698a"}, {"problem": 67, "code": "(fn f [x]\n  (take x (filter (fn [n]\n                    (every? (fn [r] (pos? r))\n                            (map (fn [div]\n                                   (mod n div)) (range 2 n))))\n                  (drop 2 (range))\n                  )))", "user": "5012da69e4b0c8732600222d"}, {"problem": 67, "code": "(fn k[n]\n         (if (= n 2) [2 3]\n             (let [prev (k (dec n))\n                   n (loop [nxt (+ (last prev) 2)]\n                       (if (every? #(not= 0 (rem  nxt %)) prev) nxt (recur (+ nxt 2)))) ]\n              (conj prev n ))))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 67, "code": "(fn prime [n]\n  (let [max-N 1000\n        non-prime (reduce (fn [non-prime-map item]\n                            (into non-prime-map ((fn all-mult [m max-N]\n                                                   (for [x (range 2 max-N)\n                                                         :let [y (* x m)]\n                                                         :while (< y max-N)]\n                                                     y)) item max-N))) #{} (range 2 max-N))]\n    (take n (filter #(not (contains? non-prime %)) (iterate inc 2)))))", "user": "5d247902e4b02ea6f0fb6a24"}, {"problem": 67, "code": "(fn nprimes [n]\n  (take n (filter\n           (fn [n]\n             (->> n\n                  (range 2)\n                  (filter #(= 0 (mod n %)))\n                  seq\n                  not))\n           (iterate inc 2))))", "user": "5c547cf0e4b0fb8c5ffd9a0b"}, {"problem": 67, "code": "(fn [n]\n   (let [is-prime?\n         (fn [n]\n           (loop [x 2]\n             (cond\n               (= x n) true\n               (> x n) true\n               (= 0 (rem n x)) false\n               :else (recur (inc x)))))\n         primes\n         (fn primes\n           ([] (primes 2))\n           ([n] (->> (cons n (primes (inc n)))\n                     (filter is-prime?)\n                     lazy-seq)))]\n     (take n (primes))))", "user": "518279abe4b0353c468deb65"}, {"problem": 67, "code": "(fn [n]\n   (take n (filter (fn [i] (not-any? (fn [x] (= (mod i x) 0)) (range 2 i)))\n                   (iterate inc 2))))", "user": "576e607ae4b0979f89651579"}, {"problem": 67, "code": "(fn [n] \n  (loop [candidates (map inc (map inc (range)))\n         divisor 2]\n    (do \n      (println divisor)\n      (println (take n candidates))\n      (let [n-candidates (take n candidates)]\n        (if (< (last n-candidates) divisor)\n          n-candidates\n          (recur (filter #(or (not= (rem % divisor) 0) (= % divisor)) \n                         candidates) \n                 (inc divisor)))))))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(divides? [a b]\n            (zero? (rem a b)))\n          (prime? [a]\n            (and (< 1 a) (not-any? #(divides? a %) (range 2 a))))]\n    (take n (filter prime? (range)))))", "user": "5d27da09e4b092dab7f59c75"}, {"problem": 67, "code": "(fn [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n   (take cnt (filter prime? (iterate inc 2)))\n  )  \n  )", "user": "5d3fa930e4b05dd059a5435f"}, {"problem": 67, "code": "(fn fxp\n  [n]\n  (case n\n    2 [2 3]\n    5 [2 3 5 7 11]\n    100 (conj (apply vector (repeat 99 1)) 541)))", "user": "598601f9e4b021a7a535fe79"}, {"problem": 67, "code": "(fn take-primes [n]\n  (take n \n        (filter (fn prime? [n]\n  \t\t\t\t\t(= (count ((fn divisors [n] (filter #(zero? (rem n %)) (conj (range 1 (inc (/ n 2))) n))) n)) \n                       2)) \n                (iterate inc 2))))", "user": "5d1be50ce4b02ea6f0fb6986"}, {"problem": 67, "code": "(fn [num-primes]\n    (let [divisor-de? (fn [m n] (zero? (mod n m)))\n          divisores-candidatos (fn [x] (range 2 (+ (int (Math/floor (Math/sqrt x))) 1)))\n          es-primo? (fn [x] (empty? (filter #(divisor-de? % x) (divisores-candidatos x))))]\n       (take num-primes (filter #(es-primo? %) (drop 2 (range))))))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 67, "code": "(fn [n] (take n (for [x (drop 2 (range))\n                   :when (not-any? zero? (map #(rem x %) (range 2 (inc (quot x 2)))))]\n      x)))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 67, "code": "(fn [MaxCount]\n    (loop [Ret [] N 2]\n      (println N Ret)\n      ;;(println (range 2 N) )\n      ;;(println (filter #(zero? (rem N %) ) (range 2 N)))\n      (if (= MaxCount (count Ret))\n        Ret\n        (recur\n          (if (zero? (count (filter #(zero? (rem N %) ) (range 2 N))))\n            (conj Ret N)\n            Ret\n          )\n          (inc N)\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 67, "code": "(fn prime\n   ([x]\n    (prime 3 [2] x))\n   ([curr vec x]\n    (cond (= (count vec) x) vec\n          (not (some #(= 0 %) (map #(rem curr %) vec))) (recur (inc curr) (conj vec curr) x)\n          :else (recur (inc curr) vec x))))", "user": "5d0beecee4b0cc9c91588239"}, {"problem": 67, "code": "(fn first-n-primes\n  [n]\n  (letfn [(sieve\n            [[p & ps]]\n            (lazy-seq\n              (cons p (sieve (remove #(zero? (mod % p)) ps)))))]\n    (take n (sieve (drop 2 (range))))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (letfn [(sieve\n            [nums]\n            (let [p (first nums)]\n              (cons p (lazy-seq\n                        (->> (rest nums)\n                             (remove #(zero? (rem % p)))\n                             (sieve))))))]\n    (take n (sieve (drop 2 (range))))))", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 67, "code": "(fn [n]\n    (loop [i 2 l []]\n      (if (= (count l) n)\n        l\n        (if (\n             ; below, trial division function.\n             ; returns true if x is composite, nil otherwise.\n             (fn [x] (some\n                       #(== % 0)\n                       (map #(mod x %) (range 2 (inc (int (Math/sqrt x)))))\n                       ))\n             i)\n          (recur (inc i) l)\n          (recur (inc i) (conj l i))\n          ))))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 67, "code": "(fn [num]\n (take num\n  (reduce\n   (fn [p n]\n    (if (empty? (filter #(zero? (mod n %)) p))\n      (conj p n)\n      p))\n   [2]\n   (take (* num num) (iterate inc 3)))))", "user": "5ccf99fbe4b0ccb0619628c8"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn is-prime [x]\n  (not-any? #(= 0 (mod x %)) (range 2 (dec x)))) (drop 2 (range)))))", "user": "5d4f21f3e4b0776584bd6f4e"}, {"problem": 67, "code": "(fn [k]\n   (take k (filter (fn [n] (not (some #(= 0 (mod n %)) (range 2 n))))\n                   (iterate inc 2))))", "user": "5bb25684e4b0a20761a2350d"}, {"problem": 67, "code": "(letfn [(primes\n          ([] (primes [2]))\n          ([found]\n           (let [maxx (apply max found)\n                 divisor? (fn [x y] (= 0 (mod x y)))\n                 succ (->> (range)\n                           (drop maxx)\n                           (drop-while (fn [x] (some (fn [y] (divisor? x y)) found)))\n                           (first))]\n             (lazy-seq\n              (cons maxx\n                    (primes (conj found succ)))))))]\n  #(take % (primes)))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 67, "code": "(fn [n]\n  (loop [table []\n         \t i 2]\n    (if (= (count table) n)\n      table\n      (if (some #(= 0 (rem i %)) table)\n        (recur table (inc i))\n        (recur (conj table i) (inc i))))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 67, "code": "(fn [n]\n   (let [prime? (fn prime? [x]\n                  (not (some #(== 0 %) (map #(mod x %) (into [2] (range 2 (+ 1 (Math/sqrt x)))))))\n                  )]\n     (into [2] (take (dec n) (drop 1 (filter prime? (range)))))))", "user": "5ab07d63e4b073f1774425af"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 67, "code": "(fn get-first-n-primes [num]\n  (take num\n        (filter\n          identity\n          (map\n            (fn [n] (if ((fn [num]\n                           (loop [myprimes #{} cnt num]\n                             (if (zero? cnt)\n                               (not (> (count (filter #(> % 1) myprimes)) 1))\n                               (let [result (if (zero? (mod num cnt)) cnt 0)]\n                                 (recur\n                                   (conj myprimes result)\n                                   (dec cnt)))))) n) n)) (range 2 545)))))", "user": "5ad76df9e4b0ea6055cfac18"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter\n           (fn [x] (every? #(not= (rem x %) 0) (range 2 x)))\n           (iterate inc 2))))", "user": "5d672bd7e4b0db5d338d15f1"}, {"problem": 67, "code": "(fn [n]\n  (map last (take n\n                  (iterate (fn [col]\n                             (let [candidate (inc (last col))]\n                               (if (every? #(not= (mod candidate %) 0) col)\n                                 (conj col candidate)\n                                 (recur (conj col candidate)))))\n                           [2]))))", "user": "5d64ecb2e4b0c9e5857d5036"}, {"problem": 67, "code": "(fn [m]\n   (loop [n 2\n          p [2]]\n   (if (= (count p) m)\n     p\n     (if (not (some #(= 0 (mod n %)) p))\n       (recur (inc n) (conj p n))\n       (recur (inc n) p )))))", "user": "5d5ef0bce4b0c9e5857d4ffb"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(divisible? [div] (fn [num] (zero? (mod num div))))\n            (sieve [sieved]\n              (lazy-seq\n               (cons (first sieved)\n                     (sieve (remove (divisible? (first sieved)) (rest sieved))))))]\n      (take n (sieve (drop 2 (range))))))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5245af03e4b08ba239308124"}, {"problem": 67, "code": "(fn prob67\n  [x]\n  (letfn [(sieve [s]\n            (->> (rest s)\n                 (filter #(not= 0 (mod % (first s))))\n                 (sieve)\n                 (lazy-seq)\n                 (cons (first s))))]\n    (->> (iterate inc 2)\n         (sieve)\n         (take x))))", "user": "5d2e5065e4b01671435dbcae"}, {"problem": 67, "code": "(fn [n]\n  (loop [x 5 acc [2 3]]\n    (cond\n      (<= n (count acc)) (take n acc)\n      (some #(zero? (mod x %)) acc) (recur (+ x 2) acc) ; FTA\n      :else (recur (+ 2 x) (conj acc x)))))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime? [n]\n            (->> (range 2 n)\n                 (map (partial mod n))\n                 (some zero?)\n                 (not)))]\n    (take n (filter is-prime? (iterate inc 2)))))", "user": "5d4a6511e4b0776584bd6f21"}, {"problem": 67, "code": "(fn [x] (take x (letfn [(sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))] \n          (sieve (drop 2 (range))))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 67, "code": "(fn [n] (last (take n (iterate (fn [c]\n  (loop [x (inc (last c))]\n    (if (every? #(not= 0 (mod x %)) c) \n      (conj c x)\n      (recur (inc x))))) [2]))))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 67, "code": "(fn primes [n]\n  (take n (cons 2 (filter (fn [i] (not-any? #(zero? (rem i %)) (range 3 (/ i 2) 2)))\n                          (iterate (partial + 2) 3)))))", "user": "5d45749be4b07c84aa5ae6a2"}, {"problem": 67, "code": "(fn primen [num]\n    (take num\n    ((fn primes [start]\n       (lazy-seq\n        (if\n         ((fn prime [num]\n            (= (count (filter #(= (mod num %1) 0) (range 2 num))) 0)) start)\n          (cons start (primes (inc start)))\n          (primes (inc start))))) 2 )))", "user": "5d5c6675e4b09db18d4482ec"}, {"problem": 67, "code": "(fn [mx] (take mx(filter\n                    (fn [n]\n                      (= nil (some #(= 0 (mod n %) )(range 2 (+ 1(/ n 2))))))(iterate inc 2))))", "user": "5d824225e4b0915913b1d37f"}, {"problem": 67, "code": "(fn [n]\n  (let [funk (fn [x]\n               (<= (count (set (filter (fn [y] (= (mod x y) 0 ))\n                               (range 1 (+ x 1))))) 2))]\n    (loop [res []\n           end 0\n           prim 2]\n      (if (= end n)\n        res\n        (if (funk prim)\n          (recur (conj res prim) (inc end) (inc prim))\n          (recur res end (inc prim)))))))", "user": "5be0b916e4b0ed4b8aab4c8f"}, {"problem": 67, "code": "(fn [n]\n   (->> (range)\n        (filter #(.isProbablePrime (.toBigInteger (bigint %)) 100))\n        (take n)))", "user": "5d8b881ae4b0915913b1d3d7"}, {"problem": 67, "code": "(fn [z] (take z (filter (fn [x] (= 1 (count (filter (fn [y] (= (rem x y) 0)) (range 1 x))))) (range))))", "user": "5d7158f3e4b04d129b00f2e1"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(is-prime? [n]\n            (->> (map #(if (zero? (mod n %)) 1 0) (range 1 (inc n)))\n                 (reduce +)\n                 (= 2)))]\n    (take n (->> (range)\n                 (filter is-prime?)))))", "user": "5d5824fae4b02ba5928a681f"}, {"problem": 67, "code": "(fn [n]\n  (loop [nums (map (partial + 2) (range))\n         primes [2]]\n    (if (<= n (count primes))\n      primes\n      (recur (filter #(not= 0 (mod % (last primes))) nums)\n             (conj primes (second nums))))))", "user": "5d24e49be4b02ea6f0fb6a2a"}, {"problem": 67, "code": "(fn [i]\n  (take i \n        ((fn f [[x :as xs]]\n           (lazy-seq (cons x (f (remove #(zero? (rem % x)) xs)))))\n         (nnext (range)))))", "user": "53c74cfce4b00fb29b2212a7"}, {"problem": 67, "code": "(fn [num] \n  (let [prime? (fn [number]\n                 (if (= 0 (mod number 2))\n                   false\n                   (not-any? zero? (map mod (repeat number) (range 3 (/ number 2) 2)))))]\n    (cons 2 (take (dec num) (filter prime? (iterate inc 2))))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 67, "code": "(fn [n]\n   (letfn [(prime? [x] ( not-any? #(= 0 (rem x %)) (range 2 x)))]\n     (take n (filter prime? (drop 2 (range))))))", "user": "5d917ef0e4b0915913b1d402"}, {"problem": 67, "code": "(fn my-fn [n]\n  (let [all-moduli (fn [x] (map #(mod %1 %2) (repeat x) (range 2 x)))\n        even-division? (fn [xs] (seq (filter #(= 0 %) xs)))]\n    (take n (drop 2 (remove (comp even-division? all-moduli) (range))))))", "user": "5c896f46e4b048ec896c5940"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (let [prime? (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\n          (cons 2 (lazy-seq (filter prime? (iterate inc 3)))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 67, "code": "(fn [a] (take a ((fn sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s)))))) (iterate inc 2))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 67, "code": "(fn primes [amount]\n  (loop [i amount\n         next-num 2\n         vec []]\n    (if (<= i 0)\n      vec\n      (if (loop [i 2]\n              (if (>= i next-num)\n                true\n                (do\n                  (if (= (mod next-num i) 0)\n                    false\n                    (recur (inc i))))))\n        (recur\n          (dec i)\n          (inc next-num)\n          (conj vec next-num))\n        (recur\n          i\n          (inc next-num)\n          vec)))))", "user": "5da6cb60e4b000c986472c10"}, {"problem": 67, "code": "(fn [n]\n  (loop [n n i 2 primes []]\n    (if (= 0 n)\n      primes\n      (if (some #(= 0 (rem i %)) primes)\n        (recur n (inc i) primes)\n        (recur (dec n) (inc i) (conj primes i))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 67, "code": "(fn [n] (take n ((fn primes\n  ([] (lazy-seq (primes (iterate #(inc %) 2)) ))\n  ([s] (let [p (first s)] (lazy-seq (cons p (primes (filter #(not= (mod % p) 0) (rest s)))))))))))", "user": "5d931a58e4b0d3f9b434ad10"}, {"problem": 67, "code": "(fn [c]\n  (let [prime? (fn [n]\n                 (cond\n                   (<= n 3) (> n 1)\n                   (= 0 (mod n 2)) false\n                   (= 0 (mod n 3)) false\n                   :else (loop [i 5\n                                r nil]\n                           (cond\n                             (not (nil? r)) r\n                             (>(* i i) n) (recur nil true)\n                             (= 0 (mod n i)) (recur nil false)\n                             (= 0 (mod n (+ i 2))) (recur nil false)\n                             :else (recur (+ i 6) nil)))))]\n    (loop [i 2\n           c c\n           v []]\n      (if (<= c 0)\n        v\n        (let [prime? (prime? i)\n              v (if prime? (concat v [i]) v)\n              c (if prime? (dec c) c)]\n          (recur (inc i) c v))))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 67, "code": "(fn primes [n]\n  (if (< n 1)\n    []\n  \t(loop [primes [2]]\n      (if (= n (count primes))\n        primes\n        (recur (conj primes\n                     (some (fn [x]\n                             (when (every? #(not= 0 (rem x %))\n                                           primes)\n                               x))\n                           (drop (inc (last primes)) \n                                 (range)))))\n        ))))", "user": "59bac5c9e4b0a024fb6ae3ed"}, {"problem": 67, "code": "(fn primes [n]\n  (take n ((fn sieve [coll]\n             (let [[ x & xs] coll]\n               (lazy-seq (cons x (sieve (filter #(pos? (mod % x)) xs))))))\n           (iterate inc 2))))", "user": "5d97b602e4b0d3f9b434ad3a"}, {"problem": 67, "code": "(fn primes [n]\n  ;; by trial\n  (letfn [(is-a-prime? [x]\n            (or (= 2 x)\n                (every? #(not (zero? (mod x %))) (range 2 (inc (Math/sqrt x))))))]\n    (take n (filter is-a-prime? (drop 2 (range))))))", "user": "5d7aa22ee4b02e6b30c9354e"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter\n          #(loop [d 2]\n             (if (= % d)\n               true\n               (if (= 0 (mod % d))\n                 false\n                 (recur (inc d)))\n               ))\n          (iterate inc 2)\n          )\n        )\n  )", "user": "5d99dc47e4b0d3f9b434ad42"}, {"problem": 67, "code": "(fn [x] (->> (range)\n             (filter #(.isProbablePrime (BigInteger/valueOf %) 5))\n             (take x)))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 67, "code": "#(take % (filter (fn [d] (if (= d 1) false\n                                    (not (some (fn [y] (= 0 (rem d y)))\n                                               (range 2 d))))) (drop 2 (range)) ))", "user": "5b044436e4b0cc2b61a3bd71"}, {"problem": 67, "code": "(fn n-primes [n]\n  (let [update-sieve (fn update-sieve\n                       [sieve n]\n                       (loop [prime-factor   (sieve n),\n                              next-composite (+ n prime-factor)]\n                         (if (sieve next-composite)\n                           (recur prime-factor (+ next-composite prime-factor))\n                           (-> sieve\n                               (assoc next-composite prime-factor)\n                               (dissoc n)))))\n        lazy-primes  (fn lazy-primes\n                       ([] (lazy-primes {} 2))\n                       ([sieve n]\n                        (if (contains? sieve n)\n                          (recur (update-sieve sieve n) (inc n))\n\n                          (let [new-sieve (assoc sieve (* n n) n)]\n                            (lazy-seq\n                             (cons n (lazy-primes new-sieve (inc n))))))))]\n    (take n (lazy-primes))))", "user": "5db0d470e4b0f8c104ccfc9e"}, {"problem": 67, "code": "(fn first-n-primes [n]\n  (letfn [(is-prime? [x]\n            (letfn [(prime-iter [i num root]\n                      (cond\n                       (> i root) true\n                       (= 0 (rem num i)) false\n                       :else (recur (inc i) num root)))]\n              (prime-iter 2 x (Math/sqrt x))))\n          (next-prime [x]\n            (if (is-prime? (inc x)) (inc x)\n                (recur (inc x))))]\n    (take n (iterate next-prime 2))))", "user": "5daeb6bce4b0f8c104ccfc8b"}, {"problem": 67, "code": "#(letfn [(prime?\n          ([n] (prime? n 2))\n          ([n i]\n           (cond\n            (<= n 2) (= n 2)\n            (= (mod n i) 0) false\n            (> (* i i) n) true\n            :else (recur n (inc i)))))]\n   (take % (filter prime? (range))))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 67, "code": "(fn [k]\n  (loop [result []\n          kk k\n          num 2]\n    (cond\n      (<= kk 0) result\n      (or\n        (empty? result)\n        (not= (apply min (map #(mod num %) result)) 0)\n      )\n        (recur (conj result num) (dec kk) (inc num))\n      :else\n        (recur result kk (inc num))\n    )\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 67, "code": "(fn pp[z](vec(take z (filter (fn prime3 [x](cond\n                                               (or (= 1 x) (= 2 x)) true\n                                               :else (not(some (fn[a](if (= (mod x a) 0)\n                                                                         true\n                                                                         false))\n                                                               (range 2 (+ 1 ((fn raiz[x](loop[a 1\n                                                                                               x x]\n                                                                                           (cond\n                                                                                            (<= x (* a a)) a\n                                                                                            :else (recur (+ 0.09 a) x)))) x)))))))\n                               (range 2 600)))))", "user": "5dadf73ee4b0f8c104ccfc86"}, {"problem": 67, "code": "( fn [n]\n  (loop  [p [2] x 3]\n    \n    \n    \n    (if (= n (count p))\n        p\n      (recur\n             (if  (some #(= 0 (mod x %))  p )     p  (conj p x)    )  \n              (inc x)\n       )\n      \n      \n      )\n    \n    \n    \n    \n    \n    )\n \n \n \n \n \n )", "user": "5da98129e4b000c986472c33"}, {"problem": 67, "code": "(fn [n] (take n\n              (filter (fn [x] (empty? (filter #(zero? (rem x %)) (range 2 x))))\n                      (drop 2 (range)))))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 67, "code": "(fn first-prime-numbers\n  [x]\n  (loop [i 0\n         pv []\n         c 0]\n    (if (< c x)\n      (let [isprime? ((fn isprime\n                        [n]\n                        (nil? (if (>= n 2)\n                                (some #(zero? (mod n %)) (range 2 n))\n                                false))) i)]\n        (recur (+ i 1)\n               (if isprime? (conj pv i) pv)\n               (if isprime? (+ c 1) c)))\n      pv)))", "user": "5d53a59ae4b0776584bd6f72"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter (fn [x] (= (count (filter #(= (mod x %) 0) (conj (range 1 (inc (int (Math/sqrt x)))) x))) 2)) (range 2 600))))", "user": "562d869be4b0a45d2ff8301f"}, {"problem": 67, "code": "(fn [n]\n   (take n (filter\n            (fn [x]\n              (or (= 2 x)\n                    (not-any? #(= 0 (mod x %))\n                              (range 3 (inc (Math/sqrt x)) 2))\n                   )\n              )\n            (cons 2 (iterate (partial + 2) 3))\n            )))", "user": "5d321852e4b01671435dbce8"}, {"problem": 67, "code": "(fn sieve [n]\n    (let\n    [\n        init_sieve\n            (apply hash-map (interleave (range (* n n)) (repeat true)))\n        get_prime\n            (fn [m i] (if (< i (count m)) (if (m i nil) i (recur m (inc i))) nil))\n        update_sieve\n            (fn [m i p] (if (>= i (count m)) m (recur (assoc m i false) (+ i p) p) ) )\n        simulate_sieve\n            (fn [m i ret]\n                (let [p (get_prime m i)]\n                    (if (= p nil)\n                        ret               \n                        (recur (update_sieve m p p) p (conj ret p))\n                    )\n                )\n            )\n    ]\n        (take n (simulate_sieve init_sieve 2 []))\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 67, "code": "(fn abc [n]\n  (letfn [( prime [m]\n             (loop [c (range 2 (inc (int (Math/sqrt m))))]\n               (if (first c)\n                 (if (= 0 (mod m (first c))) false\n                   (recur (rest c)))\n                 true)))\n          \n          \n          ( nextp [a] \n            (if (prime (inc a)) (inc a)\n              (recur (inc a))))\n          \n          (p2 [b]\n              (lazy-seq\n                (cons b \n                  (p2 (nextp b)))))\n          \n          ]\n    \n    (take n (p2 2)) ))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [p] (every? #(not= 0 (mod p %)) (range 2 p)))]\n    (->> (range)\n         (drop 2)\n         (filter prime?)\n         (take n))))", "user": "5db5d09be4b010eb3c36cd31"}, {"problem": 67, "code": "(fn primes\n  ([n] (primes n 2 []))\n  ([n i ps] (if (= n (count ps))\n              ps\n              (letfn [(composite? [i] (some #(= 0 (mod i %)) ps))]\n                (primes n (inc i) (if (composite? i) ps (conj ps i)))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 67, "code": "(fn [n] (let [prime? (fn [i] (not-any? (partial = 0) (map (partial mod i) (range 2 i))))] \n          (take n (filter prime? (range 2 9999999999)))\n         ))", "user": "5dcfdf23e4b0948ae9d9ad43"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (take n (reduce (fn [acc inp]\n                    (if (some #(zero? (rem inp %))\n                                (range 3 (inc (Math/ceil (Math/sqrt inp))) 2))\n                      acc\n                      (conj acc inp)))\n                  [2] (range 3 (* 5.5 n) 2))))", "user": "5da94ccfe4b000c986472c2f"}, {"problem": 67, "code": "(fn [lim]\n  (take lim (filter\n             (fn [element]\n               (= 0 (count\n                     (filter\n                      (fn [x]\n                        (= 0 (mod element x)))\n                      (range 2 element)))))\n             (range 2 10000))))", "user": "5d8c8175e4b0915913b1d3e1"}, {"problem": 67, "code": "(fn [n]\n  (loop [x 1]\n    (if (< (count (last (take x (reductions (fn [num-sequence a] (if (some #(= (rem a %) 0) (range 2 a)) num-sequence (conj num-sequence a))) [] (drop 2 (range)))))) n)\n      (recur (inc x))\n      (last (take x (reductions (fn [num-sequence a] (if (some #(= (rem a %) 0) (range 2 a)) num-sequence (conj num-sequence a))) [] (drop 2 (range))))))))", "user": "5bf0aefde4b0a6d31fed215a"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes [[p & cs]]\n            (let [candidates (remove #(zero? (rem % p)) cs)]\n              (lazy-seq (cons p (primes candidates)))))]\n    (let [candidates (iterate (partial +' 2) 3)]\n      (take n (lazy-seq (cons 2 (primes candidates)))))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 67, "code": "(fn first-x-primes [x]\n  (let [is-prime (fn [n]\n                   (loop [i 2]\n                     (if (> i (int (/ n 2)))\n                       true\n                       (if (= 0 (mod n i))\n                         false\n                         (recur (inc i)))\n                       )))]\n    (loop [res []\n           num 2]\n      (if (= (count res) x)\n        res\n        (if (is-prime num)\n          (recur (conj res num) (inc num))\n          (recur res (inc num))\n          )\n        )\n      )\n    ))", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 67, "code": "#(loop [c [2] n 3]     (if  (= % (count c))   c   (recur   ( if (nil? (some (fn [x] (= 0 (mod n x)) )   c)   ) (conj c n)  c    )  (inc n)        )     )       )", "user": "5dd69c8ce4b0948ae9d9ad83"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn [x] (cond (or (= x 0) (= x 1)) false\n                                          (= x 2) true\n                                          (even? x) false\n                                          :else (not-any? true?\n                                                          (map #(zero? (mod x %))\n                                                               (range 3 x)))))\n                          (range))))", "user": "5078dedae4b08327cd804a5d"}, {"problem": 67, "code": "(fn [n]\n        (letfn [(f [acc]\n                  (let [ff (first acc)]\n                    (cons ff (lazy-seq (f (filter #(not= 0 (mod % ff)) (rest acc)))))))]\n          (take n (f (iterate inc 2)))))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 67, "code": "(fn [N]\n  (into\n   [2 3]\n   (drop\n    1     \n    (take\n     (dec N)\n     (filter \n      (fn [n]\n        (if (or (= 0 (mod n 2)) (= 0 (mod n 3))) false\n            (empty?\n             (filter\n              #(= 0 (mod n %)) \n              (take-while\n               #(> (+ 1 (Math/sqrt n)) %)\n               ((fn facs? [x]\n                  (cons (dec x)\n                        (cons (inc x)\n                              (lazy-seq (facs? (+ x 6))))))\n                6)))))) (range))))))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 67, "code": "(fn primes [num]\n(nth (iterate \n    (fn next-prime [primes] \n        (if (empty? primes) [2] \n            (let [last_prime (last primes)]\n                (loop [next-num (inc last_prime)]\n                    (if (some #(zero? (mod next-num %)) primes)\n                        (recur (inc next-num))\n                        (conj primes next-num))))))\n\n    [])\n    num))", "user": "5da05bcce4b000c986472bd0"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes\n  ([] (primes (iterate inc 2)))\n  ([x]\n   (cons (first x)\n         (lazy-seq (primes\n                    (filter #(not= 0 (mod % (first x))) (rest x)))))))]\n    (take n (primes))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 67, "code": "(fn [-num]\n  (loop [res [2] p-curr 3 idx 2]\n    (if (= (count res) -num)\n      res\n      (if (= p-curr idx)\n        (recur (conj res p-curr) (inc p-curr) 2)\n        (if (= 0 (mod p-curr idx))\n          (recur res (inc p-curr) 2)\n          (recur res p-curr (inc idx)))))))", "user": "5ddb6151e4b0948ae9d9adb0"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x] (not-any? #(zero? (mod x %)) (range 3 (quot x 2) 2)))]\n    (cons 2 (take (dec n) (filter prime? (iterate (partial + 2) 3))))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 67, "code": "(fn [c]\n  (letfn [(is-prime [m]\n            (empty? (filter #(zero? (mod m %)) (range 2 (/ (inc m) 2)))))]\n    (take c (filter is-prime (iterate inc 2)))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 67, "code": "(fn primes ([n] (if (= 1 n) [2] (primes n [2])))\n  ([n ps] (if (> n (count ps))\n            (primes n (concat ps [((fn [ps] (->>\n                                      (take-while #(if (< 2 %) ((fn [ps n] (some (fn [candidate] ((fn [nom denom] (zero? (mod nom denom))) n candidate)) ps)) ps %) true) (range))\n                                      last\n                                      inc)) ps)]))\n            ps)))", "user": "591addcee4b09b4ee5954be1"}, {"problem": 67, "code": "(fn primes [x]\n  (letfn [(divides? [a b] (zero? (rem a b)))\n          (prime? [a] (not-any? #(divides? a %) (range 2 a)))\n          (next-prime [y] (loop [z (inc y)]\n            (if (prime? z) z (recur (inc z)))))]\n    (take x (iterate next-prime 2))))", "user": "5dc9ccf8e4b02f9375f4e1f1"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5dfb20b8e4b0a607a9a45cd3"}, {"problem": 67, "code": "(fn primes [amount] \n    (let [prime? (fn [x] (loop [n (dec x)]\n                    (if (or (= n 1) (zero? n))\n                      true\n                      (if(zero? (mod x n))\n                        false\n                        (recur (dec n))))))]\n      (loop [n 2\n             xs []]\n\t    (if (= (count xs) amount)\n\t      xs\n       (recur (inc n) (if (prime? n) (conj xs n) xs))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (cons\n    2\n    (let [is-prime (fn [x] (every? #(not= 0 (rem x %)) (range 2 (inc (Math/sqrt x)))))\n          iter (iterate #(+ 2 %) 3)]\n      (take (dec n) (filter is-prime iter))))\n  )", "user": "5dfe3928e4b0a607a9a45d04"}, {"problem": 67, "code": "(fn first-primes\n  ([c-left] (first-primes c-left 2 []))\n  ([c-left testee acc]\n   (let [prime? (fn [n] (nil? (some #(= 0 (mod n %)) (drop 2 (range n)))))]\n     (cond (= 0 c-left) acc\n           (prime? testee) (first-primes (dec c-left) (inc testee) (conj acc testee))\n           :else (first-primes c-left (inc testee) acc)))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [a]\n          (not (some #(and (not= a %) (zero? (mod a %)) ) (range 2 a))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "5dfa1c67e4b0a607a9a45cc5"}, {"problem": 67, "code": "(fn [n]\n         (letfn [(is_prime [n]\n                   (cond (<= n 3) (> n 1)\n                         (or (= 0 (mod n 2)) (= 0 (mod n 3))) false\n                         :else\n                         (loop [i 5]\n                           (if (<= (* i i) n)\n                             (if (or (= 0 (mod n i)) (= 0 (mod n (+ 2 i)))) false\n                                 (recur (+ i 6)))\n                             true))))]\n           (take n (filter is_prime (range)))))", "user": "5da71eaee4b000c986472c15"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 1)\n    [2]\n    (let [coll (primes (dec n))\n          n (loop [i (inc (last coll))]\n              (if (some #(= (mod i %) 0) coll)\n                (recur (inc i))\n                i))]\n      (conj coll n))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 67, "code": "(fn my-primes\n  [lim]\n  (take lim \n        (filter \n           (fn is-prime?\n \t\t\t [num]\n  \t\t\t\t(= 2 (count (filter #(= 0 %) (map #(mod num %) (range 1 (inc num)))))))    \n                    (range 2 1000))))", "user": "5dd25ca8e4b0948ae9d9ad55"}, {"problem": 67, "code": "(fn   [n]\n  (loop [x 3\n         prev_primes [2]]\n     (if (= (count prev_primes) n)\n       prev_primes\n       (let [stop (int (Math/sqrt x))\n             next-prime (first\n                          (filter\n                            (fn [a]\n                              (let [stop (int (Math/sqrt a))\n                                    reduced-primes (filter #(<= % stop) prev_primes)]\n                                  (not-any?\n                                    (fn [p] (= (mod a p) 0))\n                                    reduced-primes)))\n                            (iterate inc x)))]\n               (recur (inc next-prime) (conj prev_primes next-prime))))))", "user": "5cb0f70ce4b026601754b8c1"}, {"problem": 67, "code": "(fn\n  [n]\n  (letfn [(prime? [x]\n            (every? #(or (= 2 x)\n                         (not (zero? (mod x %))))\n                    (range 2 (inc (Math/ceil (Math/sqrt x))))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "510528a0e4b0730a5f55ad85"}, {"problem": 67, "code": "(fn primes [n]\n  (let [is-prime (fn [x primes'] (->> (map #(rem x %) primes')\n                                      (not-any? zero?)))]\n    (loop [x       3\n           primes' [2]]\n      (if (<= n (count primes'))\n        primes'\n        (recur (+ x 2) (if (is-prime x primes') (conj primes' x) primes'))))))", "user": "5e0e14bde4b099d064962fa3"}, {"problem": 67, "code": "(fn [n] \n  (letfn [(is-prime? [x] (empty? (filter #(= 0 (mod x %)) (range 2 x))))]\n    (->> (range )\n         (filter is-prime?)\n         (drop 2)\n         (take n))))", "user": "5ce5b43be4b0a17bb84e2b7a"}, {"problem": 67, "code": "(fn [n]\n    (take n (filter #(every?\n                      pos?\n                      (map (fn [m] (mod % m))\n                           (range 2 %)))\n                    (range 2 1000))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 67, "code": "#(loop [y 2 lim % out []]\n  (if (= lim (count out)) \n    out\n    (recur\n      (inc y)\n      lim\n      (if (empty? (filter\n                    (fn [x] (= 0 (mod y x)))\n                    out))\n        (conj out y)\n        out)\n      )))", "user": "5ddd6cfae4b0948ae9d9adc4"}, {"problem": 67, "code": "(fn [x] (loop [current-primes [2] num-primes 1 test-prime 3 divisor-index 0] (if (= num-primes x) current-primes (let [divisor (get current-primes divisor-index)] (if (> divisor (quot test-prime divisor)) (recur (conj current-primes test-prime) (inc num-primes) (+ test-prime 2) 0) (if (zero? (mod test-prime divisor)) (recur current-primes num-primes (+ test-prime 2) 0) (recur current-primes num-primes test-prime (inc divisor-index))))))))", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 67, "code": "(fn [n] (take n (filter #(every? (fn [a] (< 0 (mod % a))) (range 2 %)) (range 2 600))))", "user": "5e042dede4b0a607a9a45d69"}, {"problem": 67, "code": "(fn primes [x]\n  (let [iter (fn [[n p-up2]]\n               (loop [check (inc n)\n                      prms (conj p-up2 n)]\n                 (if (some #(zero? (mod check %)) prms)\n                   (recur (inc check) prms)\n                   [check prms])))]\n\n    (->> [2 #{}] \n         (iterate iter)\n         (map first)\n         (take x))))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 67, "code": "(fn my-primes\n           ([x] (my-primes x [] 2))\n           ([x result N]\n            (if (= x 0)\n              result\n              (if (contains? (set (map #(mod N %) result)) 0)\n                (my-primes x result (+ N 1))\n                (my-primes (- x 1) (conj result N) (+ N 1))))))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(divides? [x y] (zero? (mod x y)))\n          (isPrime? [x lowerPrimes] (not-any? (fn [y] (divides? x y) ) lowerPrimes))]\n\n    (loop [hw 4 primes [2 3]]\n      (if (zero? (- n (count primes))) primes\n        (recur (inc hw) (if (isPrime? hw primes) (conj primes hw) primes))))))", "user": "5e078ba7e4b0978307768fb6"}, {"problem": 67, "code": "(fn [n]\n    (take\n     n\n     ((fn lp [i]\n        (lazy-seq\n         (cons i (filter #(not (= (rem % i) 0))\n                         (lp (inc i))))))\n      2)))", "user": "5e38a9cbe4b01d43a70e8dc2"}, {"problem": 67, "code": "(fn [cnt]\n  (let [div?   (fn [n d]\n                 (zero? (mod n d)))\n        prime? (fn [n]\n                 (if (= n 2)\n                   true\n                   (not (some #(div? n %) (range 2 (inc (Math/sqrt n)))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 67, "code": "(fn [n]\n  (take n (last (last\n   (take n\n         (iterate (fn [[i v]]\n                    [(inc i)\n                     (remove #(and (zero? (rem % (nth v i)))\n                                    (not= % (nth v i)))\n                             v)])\n                  [0 (range 2 (* n n))]))))))", "user": "5e246f92e4b05b4b01516150"}, {"problem": 67, "code": "(fn [p] (drop 2 (take (+ p 2) (filter (fn [n] (not (reduce #(or %1 (zero? (mod n %2))) false (range 2 n)))) (range)))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 67, "code": "(fn [n]\n   (letfn [(primes [used candidates]\n             (let [composite? (fn [n] (some #(zero? (mod n %)) used))\n                   [p & t] (drop-while composite? candidates)]\n               (lazy-seq (cons p (primes (conj used p) t)))))]\n     (take n (primes #{} (drop 2 (range))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(p [x] (every? false? \n                         (map #(zero? (rem x %)) (range 2 (inc (-> x (Math/sqrt) (Math/floor) (int)))))))]\n    (take n (filter p (iterate inc 2)))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (take n (filter (fn [x] (not-any? zero? (map #(rem x %) (range 2 x)))) (iterate inc 2))))", "user": "5e41b679e4b01d43a70e8e58"}, {"problem": 67, "code": "(fn prime-numbers [n]\n           (->> (range 2 1000)\n                (iterate (fn remove-multiples [coll]\n                           (remove\n                            #(= 0 (mod % (first coll)))\n                            coll)))\n                (take n)\n                (map first)))", "user": "5e3975a3e4b01d43a70e8dd3"}, {"problem": 67, "code": "(fn i [x]\n   (take x (iterate (fn [n]\n                      (cond\n                        (= n 0) 1\n                        (= n 1) 2\n                        (= n 2) 3\n                        :else\n                        (let [prime? (empty? (filter #(zero? (mod (+ n 1) %)) (drop 2 (range (+ n 1)))))]\n                          prime?\n                          (if\n                            prime?\n                            (+ n 1)\n                            (recur (+ n 1)))))) 2)))", "user": "57fc5e42e4b0d3187e900997"}, {"problem": 67, "code": "#(last (take %\n             (iterate\n               (fn [coll]\n                   (conj coll\n                         (first\n                           (filter\n                             (fn [n] (not-any? (fn [a] (= 0 (mod n a))) coll))\n                             (iterate inc (inc (last coll)))))))\n               [2])))", "user": "5e08c3dde4b0978307768fc8"}, {"problem": 67, "code": "(fn [limit] \n      (take limit (filter \n        (fn [a] (empty? (filter #(= (mod a %1) 0) (range 2 a))))\n        (iterate inc 2)\n        )))", "user": "5b337ff4e4b025bcb146f339"}, {"problem": 67, "code": "(fn [nth]\n  (take nth (filter\n              (fn [num]\n                (not-any? #(= 0 (mod num %)) (range 2 num)))\n              (iterate inc 2))))", "user": "5b99554ae4b0c0b3ffbd4ace"}, {"problem": 67, "code": "(fn prime-numbers\n  [n]\n  (loop [result []\n         i 2]\n    (if (< (count result) n)\n      (if ((fn is-prime? [i]\n             (loop [t (range 2 i)]\n               (if (not (empty? t))\n                 (if (= 0 (mod i (first t)))\n                   false\n                   (if (not (empty? (rest t)))\n                     (recur (rest t))\n                     true)\n                   )\n                 true))) i)\n        (recur (conj result i) (inc i))\n        (recur result (inc i))\n        )\n      result\n      )))", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 67, "code": "(fn [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5e392de0e4b01d43a70e8dcb"}, {"problem": 67, "code": "(fn [n]\n      (let [is-prime (fn [curr]\n                       (loop [div 2]\n                         (if (> div (Math/sqrt curr))\n                           true\n                           (if (= 0 (mod curr div))\n                             false\n                             (recur (inc div))))))]\n        (loop [res [2] current 3 lp 2]\n          (if (> lp n)\n            res\n            (if (is-prime current)\n              (recur (conj res current)(inc current) (inc lp))\n              (recur res (inc current)  lp))))))", "user": "5e4ba8e8e4b0889a8790a55a"}, {"problem": 67, "code": "(fn primes [n]\n  (let [prime? (fn [n known-primes]\n                 (every? false? (map #(= (mod n %) 0) known-primes)))\n        next-prime (fn [primes]\n                     (let [search-start (inc (last primes))\n                           candidates (iterate inc search-start)]\n                       (first (filter #(prime? % primes) candidates))))]\n    (if (= n 1)\n      [2]\n      (let [primes-n-1 (primes (dec n))]\n        (conj primes-n-1 (next-prime primes-n-1))))))", "user": "5dcc152ae4b02b31cc3da3c3"}, {"problem": 67, "code": "(fn [n]\n  (loop [at 3 s [2]]\n    (if (= n (count s)) s\n        (recur (inc at)\n               (if (some zero?\n                         (for [prime s] (mod at prime)))\n                 s (concat s [at]))))))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "5e44c804e4b01d43a70e8e89"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "5e692be9e4b04a83ad7cd269"}, {"problem": 67, "code": "(fn [n]\n  (let [prime?\n        (fn [n]\n          (not-any? #(= 0 (rem n %))\n                    (range 2 (inc (/ n 2)))))]\n    (->> (iterate inc 2)\n         (filter prime?)\n         (take n))))", "user": "5d28d935e4b092dab7f59c88"}, {"problem": 67, "code": "(fn [n] \n         (take n \n                 (filter \n                        (fn [x] \n                               (empty? \n                                      (filter #(= 0 (mod x %)) (range 2 x))))\n                        (iterate inc 2))))", "user": "51316a63e4b0431ba07e7feb"}, {"problem": 67, "code": "(fn [n] (letfn [(f [x xs] (if (= n (count xs)) xs \n                          (if (= (- x 1) (mod (reduce * 1N (range 1 x)) x)) \n                            (recur (+ 1 x) (conj xs x))\n                            (recur (+ 1 x) xs))))]\n         (f 2 [])))", "user": "5d7d17ece4b02e6b30c93558"}, {"problem": 67, "code": "#(take % ((fn primes\n            ([] (primes 2 []))\n            ([v col]\n             (lazy-seq (if (nil? (some (fn [col] (= 0 (mod v col))) col))\n                         (cons v (primes (inc v) (cons v col))) (primes (inc v) col)))))))", "user": "5e48ec09e4b043cd24807a45"}, {"problem": 67, "code": ";; Lazy prime generator based on https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\n(fn [n]\n    (let [primes (fn primes\n                   ([] (let [wheel2357\n                             (cycle '(2 4 2 4 6 2 6 4 2 4 6 6 2 6 4 2 6 4 6 8 4 2 4 2 4 8 6 4 6 2 4 6 2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10))\n                             candidates (reductions + 11 wheel2357)\n                             primeq (java.util.PriorityQueue. 32 (comparator (fn [a b] (< (first a) (first b)))))]\n                         (concat '(2 3 5 7) (primes candidates primeq))))\n                   ([candidates primeq]\n                    (let [c (first candidates)\n                          cs (drop 1 candidates)\n                          ;; Update primeq via java mutation while determining if c is prime\n                          c-prime? (reduce (fn [p? p-iter]\n                                             (.add primeq (drop-while #(<= % c) p-iter))\n                                             (and p? (not= (first p-iter) c)))\n                                           true\n                                           (take-while #(and % (<= (first %) c))\n                                                       (repeatedly (fn []\n                                                                     (let [p (.peek primeq)]\n                                                                       (cond\n                                                                         (nil? p) nil\n                                                                         (< c (first p)) nil\n                                                                         :else (.poll primeq)))))))]\n                      (if c-prime?\n                        ;; c is prime, create iterator and place it at next unmarked composite c^2, seq on\n                        (do\n                          (.add primeq (iterate #(+ % (* 2 c)) (* c c)))\n                          (cons c (lazy-seq (primes cs primeq))))\n                        (recur cs primeq)))))]\n      (take n (primes))))", "user": "5df70ee8e4b0a607a9a45c8a"}, {"problem": 67, "code": "(fn [n]\n    (loop [num-test 3\n           coll-result [2]]\n      (if (= (count coll-result) n)\n        coll-result\n        (recur (+ num-test 2)\n               (if (reduce #(or % (= (rem num-test %2) 0)) false coll-result)\n                 coll-result\n                 (conj coll-result num-test))))))", "user": "5e724492e4b085ba37836dc7"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n            (not (some #(= (mod x %) 0) (range 2 (inc (int (Math/sqrt x)))))))]\n    (loop [cnt n\n           xs []\n           x 2]\n      (if (= cnt 0)\n        xs\n        (let [x-is-prime? (prime? x)]\n          (recur\n           (if x-is-prime? (dec cnt) cnt) \n           (if x-is-prime? (conj xs x) xs)\n           (inc x)))))))", "user": "5be1c6c6e4b0ed4b8aab4ca5"}, {"problem": 67, "code": "(fn get-first-x-primes [x] \n  (let [prime? (fn [n] (empty?\n                        (filter\n                         #(zero? (rem n %))\n                         (range 2 (inc (long (Math/sqrt n)))))))]\n    (take x (filter prime? (drop 2 (range))))))", "user": "5e805895e4b085ba37836e44"}, {"problem": 67, "code": "(fn [n]\n  (->>\n  (iterate inc 2)\n  (map (fn [v] [v (quot v 2)])) \n  (filter \n    (fn [[v i]]\n      (cond \n      (< i 2) true\n      (= 0 (mod v i)) false\n      :else (recur [v (dec i)]))))\n   \n  (take n)\n  (map first)))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter\n           (fn is-prime [n]\n             (nil?\n               (some\n                 #(zero? (mod n %))\n                 (range 2 n))))\n           (range 2 1000))))", "user": "5e4375e7e4b01d43a70e8e73"}, {"problem": 67, "code": "(fn first-n-primes [n]\n    (let [isPrime? (fn [x]\n                     (not-any? boolean\n                               (map #(zero? (rem x %))\n                                    (range 2 (inc (quot x 2))))))]\n      (take n (for [x (iterate inc 2)\n                    :when (isPrime? x)]\n                x))))", "user": "5e7b1ef4e4b085ba37836e10"}, {"problem": 67, "code": "(fn nth-prime [nth] (take nth (filter (fn [number] (empty? (filter (fn [x] (zero? (mod number x))) (range 2 number)))) (iterate inc 2))))", "user": "5e872aaae4b09a7a73c8bbe5"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (for [x (range)\n              :when (and (> x 1)\n                         (reduce #(and %1 (if (= 0 (rem x %2))\n                                            false\n                                            true))\n                                 true\n                                 (for [y (range)\n                                       :when (> y 1)\n                                       :while (<= (* y y) x)]\n                                   y)))]\n          x)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(sv [s]\n            (lazy-seq\n              (let [x (first s)]\n                (cons x (sv (filter #(pos? (mod % x)) (rest s)))))))]\n    (take n (sv (iterate inc 2)))))", "user": "4eb70649535d7eef30807373"}, {"problem": 67, "code": "#(let [divisor? (fn [a b] (= (rem a b) 0))\ndivisors (fn [x] (filter (fn [y] (divisor? x y)) (range 1 (+ x 1))))\nfi-f (fn [x] (= (count (divisors x)) 2))\nprimes (filter fi-f (iterate inc 1))]\n(apply vector (take % primes))\n)", "user": "5e13a6b7e4b099d064963001"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime\n          (fn [v] (empty? (filter #(= (mod v %) 0) (range 2 (+ (/ v 2) 1)))))]\n    (take n (filter is-prime (lazy-cat '(2 3) (iterate inc 4))))))", "user": "5e9c11f8e4b0157ca96647f6"}, {"problem": 67, "code": "(fn [size]\n  (let [prime? (fn [n] (every? #(> % 0) (map #(rem n %)(range 2 n))))]\n    (take size (filter prime? (drop 2 (range))))))", "user": "5e8f87c7e4b0cb0169546342"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n   (let [prime? (fn [n]\n                  (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                             (range 2 (inc (Math/sqrt n))))))]\n     (take cnt (filter prime? (iterate inc 2)))))", "user": "5e980e6be4b0157ca96647d6"}, {"problem": 67, "code": "(fn f [n]\n  (letfn [(g? [n]\n            (or (= n 2)\n                (->> (range 3 (inc (Math/sqrt n)) 2)\n                     (cons 2)\n                     (not-any? #(zero? (mod n %))))))]\n    (->> (iterate inc 2)\n         (filter g?)\n         (take n)\n         vec)))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 67, "code": "(fn [n]\n  (cond\n    (= n 1) [2]\n    (= n 2) [2, 3]\n    :else (letfn [(is-prime? [n]\n                    (let [limit (int (Math/sqrt n))]\n                      (->>\n                       (for [i (range 2 (inc limit))]\n                         (zero? (mod n i)))\n                       (some identity)\n                       not)))]\n            (loop [n (- n 2)\n                   cur 5\n                   acc [2 3]]\n              (if (zero? n)\n                acc\n                (let [is-prime (is-prime? cur)\n                      n (if is-prime (dec n) n)\n                      acc (if is-prime (conj acc cur) acc)]\n                  (recur n (+ 2 cur) acc)))))))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 67, "code": "(fn [x]\n  (let [is-prime (fn [n]\n                   (not (some #(and\n                                 (not= % n)\n                                 (= 0 (mod n %)))\n                              (range 2 (inc (Math/sqrt n)))))\n                   )]\n    (take x (filter is-prime (iterate inc 2)))\n    )\n  )", "user": "5ea7b04de4b00a66d4a951b6"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter \n         (fn is-prime [n]\n           (nil?\n            (some #(zero? (mod n %))\n                  (range 2 n))))\n         (iterate inc 2))))", "user": "5eaba9c0e4b00a66d4a951d6"}, {"problem": 67, "code": "(fn [n] (last \n(take (dec n) (iterate \n            (fn [xs]\n                (loop [x (+ (last xs) 2)\n                        ]\n                    (letfn [(prime? [x]\n                                (= xs (filter #(> (rem x %) 0) xs)))]\n                        (if (prime? x)\n                            (concat xs [x])\n                            (recur (+ 2 x)))))\n                ) \n            [2 3]))))", "user": "5ea2e6bfe4b00a66d4a95197"}, {"problem": 67, "code": "#(take % (filter\n                   (fn [n]\n                     (nil? (some (fn [m] (zero? (rem n m))) (range 2 n))))\n                   (drop 2 (range))))", "user": "5e954b9ee4b0fbed045a3809"}, {"problem": 67, "code": "(fn [len]\n   (loop [i 3, len (- len 1), res [2]]\n     (cond\n       (= len 0) res\n       (every? #(not= 0 (mod i %)) res) (recur (inc i) (dec len) (conj res i))\n       :else (recur (inc i) len res))))", "user": "5e9f38cce4b00a66d4a9517e"}, {"problem": 67, "code": "(fn [n]\n   (take n\n         (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))\n                 (iterate inc 2))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 67, "code": "(fn [n]\n  (let [check (fn [s x]\n                (some #(zero? (rem x %)) s))\n        add-pr (fn [s]\n                 (let [nx (inc (last s))\n                       prime (first (remove\n                                     #(check s %)\n                                     (iterate inc nx)))]\n                   (conj s prime)))]\n    (loop [s [2]\n           x 1]\n      (if (= n x)\n        s\n        (recur (add-pr s) (inc x))))))", "user": "59750a68e4b01722bebd4cba"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(step [r a]      \n      (if (= n (count a))\n        a\n        (if (seq (filter #(= 0 (mod r %)) (rest (rest (range r)))))\n          (step (inc r) a)\n          (step (inc r) (conj a r)))))] \n      (step 2 [])))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime?\n           [x]\n           (let [divisors (filter #(= 0 (mod x %)) (range 2 x))]\n             (or (= 2 x) (empty? divisors))))]\n    (take n (drop 2 (filter prime? (range))))))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 67, "code": "#(take % (filter (fn is-prime [x]\n                   (if (< x 2) false\n                       (loop [i 2]\n                         (cond\n                           (> i (Math/sqrt x)) true\n                           (zero? (rem x i)) false\n                           :else (recur (inc i))))))\n                 (range)))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 67, "code": "(fn [x]\n  (take x\n    (filter\n      (fn [n]\n        (cond\n          (<= n 3) (> n 1)\n          (some zero? [(rem n 2) (rem n 3)]) false\n          :else (reduce #(if (not %1) false (not-any? zero? [(rem n %2) (rem n (+ %2 2))]))\n                           true (take-while #(<= (* % %) n) (range 5 n 6)))))\n      (range))))", "user": "5e5096c6e4b027a2e10ac0c6"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime? (fn [n] (empty? (filter #(= 0 (mod n  %)) (range 2 n))))]\n    (take n (filter is-prime? (drop 2 (range))))))", "user": "568f2059e4b0dcc4269f40df"}, {"problem": 67, "code": "#(letfn [(prime? [n]\n            (->> (Math/sqrt n)\n                 ((comp inc int))\n                 (range 2)\n                 (filter (fn [x] (zero? (mod n x))))\n                 empty?))]\n    (take % (filter prime? (drop 2 (range)))))", "user": "5ebc7c13e4b00a66d4a95267"}, {"problem": 67, "code": "(fn solution [n]\n  (loop [candidate 2 ith 0 previous [] answer []]\n   (if (= ith n)\n     answer\n     (if (some #(= 0 (mod candidate %)) previous)\n       (recur (inc candidate) ith (conj previous candidate) answer)\n       (recur (inc candidate) (inc ith) (conj previous candidate) (conj answer candidate))))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (let [prime-number? (fn prime-number? [n]\n  (if (< n 4)\n    true\n    (reduce (fn [acc val]\n              (if (= acc false)\n                false\n                (not (= (mod n val) 0) )))\n            true\n            (drop 2 (range n)))))\n        two-and-on (drop 2 (range))]\n    (->> two-and-on (filter prime-number?) (take n))))", "user": "5ed3c43be4b016b56eae05c4"}, {"problem": 67, "code": "(fn\n  [x]\n  (let [primes ((fn\n                  [n]\n                  (filter (fn\n                            [p]\n                            (.isProbablePrime (BigInteger/valueOf p) 5)) (range n))) (* 10 x))]\n    (into [] (take x primes))\n    ))", "user": "5ed65b59e4b016b56eae05df"}, {"problem": 67, "code": "(fn [n]\n  (let [odds (filter odd? (iterate inc 3))\n        primes (filter (fn [x] (not-any? zero? (map #(rem x %) (range 3 (inc (java.lang.Math/sqrt x)) 2)))) odds)]\n    (cons 2 (take (dec n) primes))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 67, "code": "(fn [cnt]\n  (let [prime? (fn [n]\n                 (not\n                   (pos?\n                     (->> (range 2 n)\n                          (map #(mod n %))\n                          (filter zero?)\n                          (count)))))\n        primes (drop 2 (filter prime? (range)))]\n    (take cnt primes)))", "user": "543a8256e4b032a45b869327"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x]\n                  (if (even? x)\n                    false\n                    (let [end (int (Math/sqrt x))]\n                      (loop [div 2]\n                        (cond \n                          (> div end) true\n                          (zero? (mod x div)) false\n                          :else (recur (inc div)))))))\n          (generate [x]\n                    (loop [n (inc x)]\n                      (if (prime? n) \n                        n\n                        (recur (inc n)))))]\n    (take n (iterate generate 2))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 67, "code": "(fn [n] (->> (range)\n             (drop 2)\n             (filter (fn [v] (not-any? zero? (map #(mod v %) (range 2 v)))))\n             (take n)\n             ))", "user": "5ed8a12fe4b0c7845d86b0d7"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes '()\n         check 2]\n    (if (= (count primes) n)\n      (reverse primes)\n      (if (not (some #(= 0 (rem check %)) (range 2 check)))\n        (recur (cons check primes) (inc check))\n        (recur primes (inc check))\n        )\n      )\n    )\n  )", "user": "5ec819b4e4b08d0ec38692e2"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (take n (filter\n                  (fn prime? [n]\n                    (every? #(not= 0 (rem n %))\n                            (range 2 (/ (inc n) 2))))\n                  (drop 2 (range)))))", "user": "5ecfd429e4b016b56eae05a9"}, {"problem": 67, "code": "#(take %\n       ((fn sieve [nums]\n          (lazy-seq\n           (cons (first nums)\n                 (sieve (remove (fn [i] (= 0 (rem i (first nums))))\n                                nums)))))\n        (iterate inc 2)))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 67, "code": "(fn [find-n]\n  (loop [n find-n prime-check 2 result []]\n\n  (if \n    (= 0 n)\n    result\n    (if\n    ((fn [isPrime] \n    (reduce (fn [a v] \n                        (if (= a false) \n                          false \n                          (if (= 0 (mod isPrime v)) false true))) \n            true \n            (range 2 isPrime)))\n       prime-check)\n    (recur (dec n) (inc prime-check) (conj result prime-check))\n    (recur n (inc prime-check) result)))))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 67, "code": "(fn first-n-primes [n] (letfn [(prime? [m] (every? #(not= (mod m %) 0) (range 2 m)))]\n                         (take n (filter prime? (drop 2 (range))))))", "user": "5ee93720e4b029a2061bbeb7"}, {"problem": 67, "code": "(fn prime-numbers [n]\n  (take n (filter (fn [i]\n                    (not-any? zero? (map (partial rem i) (range 2 i)))) (iterate inc 2))))", "user": "5c665311e4b0fca0c16226a7"}, {"problem": 67, "code": "(fn __\n  [cnt]\n  (letfn [(sieve [s]\n            (cons (first s) (lazy-seq (sieve (filter\n                                               #(not= 0 (mod % (first s)))\n                                               (rest s))))))]\n    (take cnt (sieve (iterate inc 2)))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 67, "code": "(fn primes [x]\n  (loop [ans [] cur 2]\n    (if (= (count ans) x)\n      ans\n      (if ((fn is-prime\n             [x]\n             (loop [cur 2]\n               (cond\n                 (> (* cur cur) x) true\n                 (= (mod x cur) 0) false\n                 :else (recur (inc cur))))) cur)\n        (recur (conj ans cur) (inc cur))\n        (recur ans (inc cur))))))", "user": "5eb4927fe4b00a66d4a95221"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [p]\n                 (loop [s (map #(mod p %1) (range 2 p))]\n                   (cond (nil? (first s)) true\n                         (= (first s) 0) false\n                         :else (recur (rest s)))))]\n  (loop [big_prime 1\n         n n\n         result []\n         ]\n    (cond (= n 0) result\n          :else\n          (let [now_result\n                   (conj result (first (drop-while #(not (prime? %1)) (range (inc big_prime) 1000))))]\n                  (recur (last now_result) (dec n) now_result))))))", "user": "5eeeb000e4b07c55ae4a0515"}, {"problem": 67, "code": "(fn prime\n  ([a] (prime a 2))\n  ([a b] (prime a b (vector)))\n  ([a b primes]\n   (let [prime-count (count primes)\n         prime?      (fn [n]\n                       (cond\n                         (= n 2) true\n                         (= n 3) true\n                         (even? n)       false\n                         (= (mod n 3) 0) false\n                         :else\n                         (let [root    (int (Math/sqrt n))\n                               factors (remove even? (range 4 (inc root)))]\n                           (loop [y  n\n                                  xs factors]\n                             (let [x (first xs)]\n                               (cond\n                                 (nil? x)      true\n                                 (= (mod y x) 0) false\n                                 :else\n                                 (recur y (rest xs))))))))]\n     (if (< prime-count a)\n       (if (prime? b)\n         (prime a (inc b) (conj primes b))\n         (prime a (inc b) primes))\n       primes))))", "user": "5eccc5c2e4b016b56eae058f"}, {"problem": 67, "code": "(fn primes [n]\n  (let [m (* (* 2 n) (int (Math/ceil (Math/log n))))\n        targets (range 2 m)]\n    ((fn sieve [ps s]\n        (if (< n (inc (count ps)))\n          ps\n          (let [p (first s)]\n            (recur (conj ps p) (filter #(not (= 0 (mod % p))) (rest s))))))\n     [] \n     targets)))", "user": "5ed52854e4b016b56eae05d2"}, {"problem": 67, "code": "(let [_int #(= 0 (rem %1 %2))\n      prime (fn [n] (not-any? #(_int n %) (range 3 (/ n 2))))]\n  (fn [len] (cons 2 (take (dec len) (filter prime (map #(+ 3 (* 2 %)) (range)) ))))\n)", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 67, "code": "(fn [n]\n  (loop [ps [2] x 3 cnt 1]\n    (if (= cnt n)\n      ps\n      (if (some zero? (map (partial mod x) ps))\n        (recur ps (inc x) cnt)\n        (recur (conj ps x) (inc x) (inc cnt))\n      \n      )\n    )\n  )\n)", "user": "5df08767e4b093ff717275bf"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 1)\n    [2]\n    (let [xs (primes (dec n))]\n      (loop [i (inc (last xs))]\n        (if (every? #(not= 0 (mod i %)) xs)\n          (conj xs i)\n          (recur (inc i)))))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 67, "code": "(fn my-gpn  [size]\n  (letfn [\n           (is-p2 [x v max]\n             (if (<= x max)\n               (if\n                 (= (mod v x) 0)\n                 false\n                 (is-p2 (inc x) v max)\n                 )\n               true\n               )\n             )\n           (is-p [x] (is-p2 2 x (Math/sqrt x)))\n           (gpf [x] (if (is-p x) x (gpf (inc x))))\n           ]\n     (cond (zero? size) []\n           (= 1 size) [2]\n           (< 1 size)\n           (reduce (fn [p c]\n                     (conj p\n                           (gpf (+ (last p) 1))\n                           )\n                     ) [2] (range (- size 1)))\n           )\n     )\n\n  )", "user": "5edc16e1e4b0c7845d86b0f1"}, {"problem": 67, "code": "#(letfn [(prime? [no]\n  (if (< no 2) \n    false\n    (if (and (> no 1) (< no 4))\n      true \n      (let [square_root (Math/round (Math/sqrt no))]\n        (loop [divisor square_root]\n          (if (< divisor 2)\n            true\n            (if (zero? (mod no divisor))\n              false\n              (recur (dec divisor)))))))))]\n   (take % (iterate (fn [start] (let [nxt (inc start)] (if (prime? nxt) nxt (recur nxt)))) 2)))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 67, "code": "(fn [numbers]\n    (loop [result #{}\n           next 2]\n      (cond\n        (>= (count result) numbers)\n        (sort result)\n\n        (empty? (filter (fn [x] (= (mod next x) 0)) result))\n        (recur (conj result next) (inc next))\n\n        :else\n        (recur result (inc next))\n        )\n      )\n    )", "user": "5f06caa7e4b0cf489e8d7f52"}, {"problem": 67, "code": "(fn [n]\n   (take n\n    (reduce\n     (fn [primes number]\n       (if (some zero? (map (partial mod number) primes))\n         primes\n         (conj primes number)))\n     [2]\n     (take 1000 (iterate inc 3)))\n    ))", "user": "5f10fb99e4b091ba50b4dba8"}, {"problem": 67, "code": "(fn first-m-primes [m]\n\t(loop [res [], cur 2,\n\t\tcheck (fn [n]\n\t\t\t(loop [denom (quot n 2)]\n\t\t\t\t(if (= 1 denom) true\n\t\t\t\t\t(if (= 0 (mod n denom)) false\n\t\t\t\t\t\t(recur (dec denom))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n\t\t(if (= m (count res)) res\n\t\t\t(recur\n\t\t\t\t(if (check cur) (conj res cur) res)\n\t\t\t\t(inc cur)\n\t\t\t\tcheck\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 67, "code": "(fn [x]\n   (let [rang (next (next (range)))\n         prime-fn? (fn [n]\n                     (println \"n\" n)\n                     (println \"sqrt\" (Math/sqrt n))\n                     (println \"range\" (range 2 (inc (long (Math/sqrt n)))))\n                     (if (nil? (first (filter #(zero? (rem n %)) (range 2 (inc (long (Math/sqrt n)))))))\n                         true\n                         false))]\n     (take x (filter prime-fn? rang))))", "user": "58ed2e21e4b056aecfd47d7a"}, {"problem": 67, "code": "(fn n-prime\n  [n]\n  (let [primes (map first\n                    (iterate (fn [[prime & remain]]\n                               (remove #(zero? (mod % prime)) remain))\n                             (drop 2 (range))))]\n    (take n primes)))", "user": "5cf1d9e3e4b0aaa82f112a18"}, {"problem": 67, "code": "#(take % ((fn prim ([] (lazy-seq (prim 2)))\n                   ([n] (lazy-seq (if (empty? (reduce (fn [coll x] (if (zero? (rem n x)) (conj coll x) coll))\n                                                      '()\n                                                      (range 2 n)))\n                                    (cons n (prim (inc n)))\n                                    (prim (inc n))))))))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 67, "code": "(fn primes [n]\n  (take n ((fn sieve\n             ([] (sieve 2))\n             ([n]\n              (lazy-seq (cons n (filter #(< 0 (rem % n)) (sieve (inc n))))))))))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes [2]\n         cur 3]\n    (if (= (count primes) n)\n      primes\n      (recur (if (some #(zero? (mod cur %)) primes)\n               primes\n               (conj primes cur))\n             (inc cur)))))", "user": "5d431c77e4b07c84aa5ae68f"}, {"problem": 67, "code": "(fn genprimes [n]\n  (letfn [(prime? [x]\n            (cond \n             (<= x 3) true\n             (even? x) false\n             :else (not-any? #(= 0 %) (map (partial mod x) (range 3 x 2)))))]\n  (take n (lazy-seq (cons 2 (cons 3 (filter prime? (iterate inc 5))))))))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 67, "code": "(fn primes [n]\n  (if (= n 1) [2]\n      (let [prev-primes (primes (dec n))]\n        (conj prev-primes\n              (first\n               (drop-while (fn [candidate]\n                             (some\n                              #(zero? (mod candidate %)) prev-primes))\n                           (drop (inc (last prev-primes)) (range))))))))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 67, "code": "#(take % (filter (fn [x] (not (some (fn [d] (= (mod x d) 0)) (range 2 x)))) (drop 2 (range))))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 67, "code": "(fn\n  [n]\n  (letfn [(is-prime?\n            [b]\n            (let [divisors (range 2 (inc (int (Math/sqrt b))))\n                  remainders (map #(mod b %) divisors)]\n              (not-any? #(= % 0) remainders)))]\n    (take n (filter is-prime? (iterate inc 2)))))", "user": "5f18444ee4b091ba50b4dbd3"}, {"problem": 67, "code": "(fn my-prime-numbers [x]\n  (letfn\n      [(prime? [x] (not-any? #(= 0 (mod x %)) (range 2 x)))]\n    (take x\n          (filter prime? (drop 2 (range))))))", "user": "5ee75f8be4b029a2061bbea5"}, {"problem": 67, "code": "(fn primes [ct] (take ct (filter #(every? (partial not= 0) (map (partial rem %) (range 2 %))) (iterate inc 2))))", "user": "5f309144e4b0574c87022c23"}, {"problem": 67, "code": "(fn primes [n]\n  (take n\n        ((fn select-primes\n           ([] (select-primes (drop 2 (range))))\n           ([coll]\n            (lazy-seq\n              (when (seq coll)\n                (cons\n                  (first coll)\n                  (select-primes (filter #(not (zero? (rem % (first coll)))) (rest coll)))))))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 67, "code": "(fn prime-sieve [n]\n  (loop [m {}\n         next-val 2]\n    (cond\n      (= n (reduce + (vals m))) (sort (map first (filter (fn [[_ v]] (= v 1)) m)))\n      :default (recur\n                 (let [m' (assoc m next-val (get m next-val 1))]\n                   (reduce (fn [c x] (assoc c x 0))\n                           m'\n                           (take n (iterate #(+ % next-val) (* 2 next-val)))))\n                 (inc next-val)))))", "user": "5b92f178e4b0c0b3ffbd4a41"}, {"problem": 67, "code": "(fn [n]\n  ((fn prime [n cur result]\n     (cond (= n 0) result\n           :else\n           (if ((fn [x]\n                  ((fn prime-iter [x guess]\n                     (cond (> (* guess guess) x) true\n                           (= 0 (rem x guess)) false\n                           :else (prime-iter x (inc guess)))) x 2)) cur) (prime (dec n) (inc cur) (conj result cur)) (prime n (inc cur) result)))) n 2 []))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 67, "code": "(fn \n  [n]\n  (letfn [(step [n ps]  \n                (lazy-seq\n                 (if (some #(= 0 (rem n %)) ps)\n                   (step (inc n) ps)\n                   (cons n (step (inc n) (cons n ps))))))]\n    (take n (step 2 #{}))))", "user": "5e9154c1e4b0cb0169546354"}, {"problem": 67, "code": "(fn primes [n]\n   (take n\n         (filter\n          \t#(not-any?\n            \t(fn [z] (zero? (rem % z)))\n            \t(range 2 (inc (int (Math/sqrt %)))))\n          \t(iterate inc 2))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 67, "code": "(fn primes [n]\n    (take n (iterate #(.nextProbablePrime (biginteger %)) 2)))", "user": "5f431d32e4b0955706451fb5"}, {"problem": 67, "code": "(fn [n]\n   (letfn [(is-prime [n]\n             (loop [i 2]\n               (cond (= i n) true\n                     (= (mod n i) 0) false\n                     :else (recur (inc i)))))]\n     (loop [i 0\n            c 2\n            r []]\n       (cond (= i n) r\n             (is-prime c) (recur (inc i) (inc c) (conj r c))\n             :else (recur i (inc c) r)))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 67, "code": "(fn get-primes\n  [n]\n  (take n (filter \n           (fn prime?\n\t\t\t  [num]\n  \t\t\t\t(and\n    \t\t\t\t(every?\n      \t\t\t\t\t#(> (mod num %) 0)\n      \t\t\t\t\t(range 2 (dec num)))\n    \t\t\t\t(>= num 2))) \n           (range 2 (java.lang.Integer/MAX_VALUE)))))", "user": "5f29837ee4b033932238a64f"}, {"problem": 67, "code": "(fn [x]\n(take x\n((fn primes\n\t([] (primes 2))\n\t([n] (lazy-seq (cons n (filter #(> (mod % n) 0) (primes (inc n))))))\n))\n))", "user": "5f574662e4b0a0bc16850a90"}, {"problem": 67, "code": "(fn [x] \n (take x \n  (filter \n     (fn [n] (let [sqrt (Math/sqrt n)\n  \t\t   remainders (map #(rem n %) (range 2 (inc sqrt)))]\n   \t\t(if (< n 3) true (if (empty? (filter zero? remainders)) true false))))\n    (iterate inc 2))))", "user": "5f0dfa48e4b0f30dddfb5d55"}, {"problem": 67, "code": "(fn prime* [n] \n  (let [ np?* \n      (fn [x] \n        (if\n          (loop \n   [i 2 l (int (Math/sqrt x))] \n          (if (> i l) \n            false \n            (if (= 0 (mod x i)) \n              true \n              (recur (inc i) l)\n            )\n          )\n          ) \n          nil \n          x\n         )\n        )\n        ] \n(take n (drop 2 (filter np?* (range))))  \n )\n)", "user": "5f631e11e4b02876ed9fd011"}, {"problem": 67, "code": "(fn primes [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5f5f9483e4b02876ed9fcff8"}, {"problem": 67, "code": "(fn [n] (take n [\n                 2      3      5      7     11     13     17     19     23     29 \n     31     37     41     43     47     53     59     61     67     71 \n     73     79     83     89     97    101    103    107    109    113 \n    127    131    137    139    149    151    157    163    167    173 \n    179    181    191    193    197    199    211    223    227    229 \n    233    239    241    251    257    263    269    271    277    281 \n    283    293    307    311    313    317    331    337    347    349 \n    353    359    367    373    379    383    389    397    401    409 \n    419    421    431    433    439    443    449    457    461    463 \n    467    479    487    491    499    503    509    521    523    541 \n    547    557    563    569    571    577    587    593    599    601 \n    607    613    617    619    631    641    643    647    653    659 \n    661    673    677    683    691]))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 67, "code": "(fn [cnt]\n  (loop [n 2 result [2]]\n    (if (>= (count result) cnt)\n      result\n      (recur\n        (inc n)\n        (if ((fn [x prev] (empty? (filter #(zero? (rem x %)) prev))) n result)\n          (conj result n)\n          result\n          )\n        )\n      )\n    )\n  )", "user": "5f58db95e4b0a0bc16850a9a"}, {"problem": 67, "code": "(fn [n]\n  (cond\n    (>= 0 n) []\n    (= 1 n) [2]\n    (= 2 n) [2 3]\n    :default (loop [primes [2 3]]\n               (if (= n (count primes))\n                 primes\n                 (letfn [(next-prime [primelist]\n                           (loop [try (last primelist)]\n                             (if (not-any? #(zero? (mod try %)) primelist)\n                               try\n                               (recur (+ 2 try)))))]\n                   (let [cur (next-prime primes)]\n                     (recur (conj primes cur))))))))", "user": "5f2c94b4e4b033932238a669"}, {"problem": 67, "code": ";stolen elegant solution\n;((fn primecol[n] \n;   (letfn [(prime [num]\n;             (->> (range 2 (int (/ num 2))) ;it is enough to check until the half of the number\n;                  (map #(rem num %))\n;                  (map zero?)\n;                  (every? false?)))]\n;     (take n (filter prime (iterate inc 2))))) 10)\n#(take % (filter number? (map\n          (fn prime [num]\n            (loop [x (int (/ num 2))]\n              (if (< x 2)\n                num\n                (if (= 0 (mod num x))\n                  false\n                  (recur (dec x)))                                    \n                ))\n            ) (iterate inc 2))))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 67, "code": "(fn [n] (take n (concat [2 3] (filter #(not-any? zero? (map (fn [v] (mod % v))\n                                              (range 2 (+ 2 (Math/sqrt %))))) (drop 3 (range))))))", "user": "588fbb39e4b00487982d51bd"}, {"problem": 67, "code": "(fn f [n]\n  (let [prime? (fn [x]\n                 (if\n                  (and (> x 2) (zero? (rem x 2)))\n                   false\n                   (loop [y (dec x)]\n                     (cond (= y 1) true\n                           (zero? (rem x y)) false\n                           :else (recur (dec y))))))\n        next-prime (fn [x] \n                     (loop [x (inc x)]\n                       (if (prime? x) \n                         x\n                         (recur (inc x)))))\n        primes (fn primes\n                           ([] (primes 2))\n                           ([n] (lazy-seq (cons n (primes (next-prime n))))))]\n    (take n (primes))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 67, "code": "(fn prime-gen [numberof]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take numberof (filter prime? (iterate inc 2)))))", "user": "5f5f2eafe4b02876ed9fcff5"}, {"problem": 67, "code": "(fn [n] \n  (take n \n        (filter (fn [x] (not (some zero? (map #(mod x %) (range 2 x))))) \n                (drop 2 (range)))))", "user": "58c71509e4b021aa9917ed6e"}, {"problem": 67, "code": "#(case % 2 [2 3] 5 [2 3 5 7 11] 100 [541])", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 67, "code": "(fn primes [n]\n  (if (<= n 2) \n    [2 3] \n    (let [prev-primes (primes (dec n))\n          is-composite? (fn [v] (some identity (map #(= (rem v %) 0) prev-primes)))]\n      (conj prev-primes (->> (iterate inc (last prev-primes))\n           (filter (complement is-composite?))\n           (first))))))", "user": "5f5b624de4b05ea7b9adc42f"}, {"problem": 67, "code": "(fn [length]\n   (loop [cursor 2\n          output []]\n     (if (>= (count output) length)\n       (take length output)\n       (recur\n        (inc cursor)\n        (if (every? #(not (integer? (/ cursor %))) output)\n          (conj output cursor)\n          output)))))", "user": "5f79bff2e4b02876ed9fd0ca"}, {"problem": 67, "code": "(fn [nof]\n  (loop [n 2 c nof a []]\n    (if (= c (count a))\n      a\n      (let [r (range 2 (inc (int (Math/sqrt n))))]\n        (recur (inc n) c\n               (if (some #(zero? (mod n %)) r)\n                 a\n                 (conj a n)))))))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (letfn [(f [s]\n            (lazy-seq (cons (first s)\n                            (f (remove #(zero? (rem % (first s)))\n                                       (rest s))))))]\n    (take n (f (iterate inc 2)))))", "user": "4e8a170c535d3e98b802328f"}, {"problem": 67, "code": "(fn [m]\n  (let [is-composite (fn [n divisors]\n                   (some #(zero? (mod n %)) divisors))]\n    (loop [i 2 acc [2]]\n      (if (= (count acc) m)\n        acc\n        (recur (inc i) (if (is-composite i acc)\n                         acc (conj acc i)))))))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 67, "code": "(fn n-primes\n  ([n]\n   (n-primes n [2]))\n  ([n primes]\n   (if (> (count primes) n)\n     (take n primes)\n     (n-primes n (reduce (fn [pms i]\n                           (if (some #(zero? (rem i %)) (let [m (Math/sqrt i)] (take-while #(<= % m) pms)))\n                             pms\n                             (conj pms i)))\n                         primes\n                         (range (inc (last primes)) (max (* 2 (last primes)) 100)))))))", "user": "596a66cde4b069c0a1a19803"}, {"problem": 67, "code": "(fn primnbs [n]\n  (letfn [(isprime [x]\n            (let [sqx (int (Math/sqrt x))]\n              (loop [s (range 2 (+ sqx 1))]\n                (if (empty? s)\n                  true\n                  (if (= (rem x (first s)) 0)\n                    false\n                    (recur (rest s)))))))]\n    (loop [c 2\n           r []]\n      (if (= (count r) n)\n        r\n        (if (isprime c)\n          (recur (inc c) (conj r c))\n          (recur (inc c) r))))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 67, "code": "(fn [cnt]\n      (let [mult? (fn [x n] (zero? (mod x n)))\n            some? (fn [p coll] (first (drop-while #(not (p %)) coll)))\n            not-prime? (fn [ps n] (some? #(mult? n %) ps))\n            candidates (fn [n] (iterate #(+ 2 %) n))\n            next-prime (fn [ps]\n                         (first (remove #(not-prime? ps %)\n                                         (candidates (+ 2 (last ps))))))]\n        (loop [primes [2 3 5 7 11]]\n;;           (println primes)\n          (if (>= (count primes) cnt)\n            (take cnt primes)\n            (recur (conj primes (next-prime primes)))))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 67, "code": "(fn primes [x] (take x (filter (fn [num]\n                               (loop [curr (int (Math/sqrt num))]\n                                 (if (< curr 2)\n                                   true\n                                   (if (= 0 (rem num curr))\n                                     false\n                                     (recur (dec curr)))))) (drop 2 (range)))))", "user": "5f9567cce4b0715f5002d7c7"}, {"problem": 67, "code": ";(vec(\n (fn [n]\n   (take\n    n\n    (->> (range)\n         (map\n          (comp\n           #(\n            java.math.BigInteger.\n            %)\n           str))\n         (filter\n          #(.isProbablePrime\n            % 10))\n         (take n)\n         )))\n; 5))", "user": "5e64ae6ce4b0fd0acd1586ac"}, {"problem": 67, "code": "(fn prime-numbers\n  [n]\n  (take n (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))) (range 2 1000))))", "user": "5f3103aee4b0574c87022c24"}, {"problem": 67, "code": "(fn [max] (->> (range)\n               (drop 2)\n               (filter\n                (fn prime? [n] (not-any? #(zero? (mod n %)) (range 2 n))))\n               (take max)))", "user": "5eb3d02be4b00a66d4a95215"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (empty? (filter zero? (map #(mod n %) (range 2 n)))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 67, "code": "(fn [n]\n  (loop [x 3\n         acc [2]]\n    (if (= n (count acc))\n      acc\n      (let [new-acc (if (not (empty? (filter #(= 0 (mod x %)) acc)))\n                      acc\n                      (conj acc x))]\n        (recur (inc x) new-acc)))))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 67, "code": "(fn [n]\n  (let [not-prime? (fn [primes candidate]\n                     (some #(zero? (rem candidate %)) primes))\n        next-prime (fn [primes]\n                     (if (empty? primes)\n                       2\n                       (let [candidate (-> primes last inc)]\n                         (first\n                          (drop-while #(not-prime? primes %1)\n                                      (iterate inc candidate))))))]\n    (loop [primes []]\n      (if (= (count primes) n)\n        primes\n        (recur (conj primes (next-prime primes)))))))", "user": "5beadeb5e4b0f319e2d7ec88"}, {"problem": 67, "code": "(fn [x] \n    (take x \n          (drop 2 (filter (fn [y] (not (some #(= 0 (mod y %)) (drop 2 (range y))))) (range)))))", "user": "5fb2eac0e4b08cb800c85b2f"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5facfb48e4b08cb800c85aea"}, {"problem": 67, "code": "(fn [x] \n  (take x \n        ((fn f [ps t] \n          (if (empty? (filter #(= (mod t %) 0) ps))\n              (lazy-seq \n                (concat (list t) \n                        (f (concat ps (list t)) (inc t))))\n              (lazy-seq (f ps (inc t))))) '() 2)))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (take n (filter #(not-any? zero? (map (fn [v] (rem % v)) (range 2 %))) (drop 2 (range)))))", "user": "5f838122e4b01aacbe7a2715"}, {"problem": 67, "code": "(fn [n] (take n\n               ((fn p [s] (lazy-seq (cons (first s) (p (filter #(pos? (rem % (first s))) s)))))\n                (drop 2 (range)))))", "user": "5fa96ddbe4b0fa27300f3dec"}, {"problem": 67, "code": "(fn ret-n-primes [n] (let [prime? (fn [n] (not (some #(and (not= n %) (zero? (mod n %)))\n                                                       (range 2 (inc (Math/sqrt n))))))]\n                         (take n (filter prime? (iterate inc 2)))\n                         ))", "user": "5f96fa49e4b0715f5002d7e9"}, {"problem": 67, "code": "(fn [n]\n  (loop [acc [2], x 3]\n    (if (= n (count acc))\n      acc\n      (if (not-any? (partial = 0) (map (partial rem x) acc))\n        (recur (conj acc x) (inc x))\n        (recur acc (inc x))))))", "user": "5b77248ae4b047b03b2036e7"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (concat [2] (take (dec n)\n                    (filter #(.isProbablePrime (BigInteger/valueOf %) 5)\n                            (take-nth 2\n                                      (range 1 Integer/MAX_VALUE))))))", "user": "5fe5a64de4b05ac5b16ea187"}, {"problem": 67, "code": "(fn [n]\n    (take n\n          (filter\n           (fn isPrime[x]\n             (not-any?\n              zero?\n              (map #(mod x %) (range 2 x))))\n           (drop 2 (range)))))", "user": "573a0ecce4b0cd1946bd1088"}, {"problem": 67, "code": "#(take % ((fn prims\n            ([]\n             (prims [2]))\n            ([excludes]\n             (cons (last excludes)\n                   (loop [n (inc (last excludes)) test excludes]\n                     (cond\n                       (empty? test) (lazy-seq (prims (concat excludes [n])))\n                       (zero? (mod n (first test)))\n                       (recur (inc n) excludes)\n                       :default\n                       (recur n (rest test)))))))))", "user": "5f9c4113e4b0715f5002d821"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter  (fn [innum]\n                     (empty?\n                      (filter\n                       #(= 0 (mod innum %))\n                       (range 2 innum)))) (drop 2 (range )))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn [(prime? [n] (reduce (fn [a i] (if (zero? (rem n i)) false a)) true (range 2 n))) ]\n    (take n (filter prime? (drop 2 (range)))) )\n  )", "user": "5fee18f2e4b05ac5b16ea1d2"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(prime? [x]\n            (not-any? #(zero? (mod x %)) (filter #(< % x) (range 2 (inc (Math/sqrt x))))))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(is-not-prime? [v prime-list]\n              ;; \u4efb\u4f55\u4e00\u4e2a\u975e\u8d28\u6570\u7684\u6574\u6570\uff0c\u80af\u5b9a\u4f1a\u6709\u4e00\u4e2a\u5c0f\u4e8e\u5176\u5e73\u65b9\u6839\u7684\u8d28\u56e0\u6570\u3002\n              ;; \u5982\u627e\u5230\u5c0f\u4e8e\u5e73\u65b9\u6839\u7684\u8d28\u56e0\u6570(\u88ab\u6574\u9664), \u5219\u975e\u8d28\u6570\n              (some #(and (<= % (Math/sqrt v))\n                          (= (rem v %) 0)) prime-list))\n            ;; \u4efb\u4f55\u5927\u4e8e 2 \u7684\u5076\u6570\u90fd\u4e0d\u53ef\u80fd\u662f\u8d28\u6570, 2 \u7279\u6b8a\u5904\u7406\uff0c\u53ea\u8003\u8651\u4ece 3 \u5f00\u59cb\u7684\u5947\u6570\n            (get-ans [cur-n cur-x ans]\n              (cond\n                (= 0 cur-n) ans\n                (is-not-prime? cur-x ans) (recur cur-n (+ 2 cur-x) ans)\n                :else (recur (dec cur-n) (+ 2 cur-x) (conj ans cur-x))))]\n      (take n (get-ans n 3 [2]))))\n\n;; (fn [n]\n;;     (letfn [(is-prime? [v prime-list]\n;;               ;; \u5982\u679c\u4e00\u4e2a\u6570\u4e0d\u80fd\u88ab\u4efb\u4f55\u8d28\u6570\u6574\u9664\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6570\u5c31\u662f\u4e00\u4e2a\u8d28\u6570\u3002\n;;               (every? #(not= 0 (rem v %))\n;;                       (filter #(<= % (Math/sqrt v)) prime-list)))\n;;             ;; \u4efb\u4f55\u5927\u4e8e 2 \u7684\u5076\u6570\u90fd\u4e0d\u53ef\u80fd\u662f\u8d28\u6570, 2 \u7279\u6b8a\u5904\u7406\uff0c\u53ea\u8003\u8651\u4ece 3 \u5f00\u59cb\u7684\u5947\u6570\n;;             (get-ans [cur-n cur-x ans]\n;;               (cond\n;;                 (= 0 cur-n) ans\n;;                 (is-prime? cur-x ans) (recur (dec cur-n) (+ 2 cur-x) (conj ans cur-x))\n;;                 :else (recur cur-n (+ 2 cur-x) ans)))]\n;;       (take n (get-ans n 3 [2]))))\n\n;; (fn [n]\n;;     (loop [v 3\n;;            cur-n 1\n;;            rst [2]]\n;;       (cond\n;;         (>= cur-n n) rst\n;;         ;; \u5982\u627e\u5230\u8d28\u56e0\u6570(\u88ab\u6574\u9664), \u5219\u975e\u8d28\u6570\n;;         (some #(= 0 (mod v %)) rst) (recur (+ 2 v) cur-n rst)\n;;         :else (recur (+ 2 v) (inc cur-n) (conj rst v)))))\n\n;; (fn [n]\n;;     (->> (range)\n;;          (drop 2)\n;;          (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x))))\n;;          (take n)))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 67, "code": "(fn [n]\n  (take n(filter \n(fn is-prime [n]\n  (nil?\n  (some\n    #(zero? (mod n %))\n    (range 2 n))))\n(range 2 1000))))", "user": "5f419985e4b0955706451fab"}, {"problem": 67, "code": "(fn [n]\n   (letfn [(is-prime [n]\n             (if (< n 2)\n               false\n               (not-any? #(= 0 (mod n %)) (take-while #(<= (* % %) n) (range 2 n)))))]         \n    (take n (filter #(is-prime %) (range)))))", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 67, "code": "(fn [c]\n   (take c (concat '(2 3) (filter (fn [x] (let [sq (int (/ x 2))]\n                                            (= (last (take-while\n                                                       (fn [d] (> (mod x d) 0)) (range 2 (inc sq)))) sq))) (range 2 Integer/MAX_VALUE)))))", "user": "5ff5bc1ae4b06df49cee1490"}, {"problem": 67, "code": "(fn [m] (take m (filter (fn [n] (and (> n 1) (not-any? #(zero? (mod n %1)) (range 2 n)))) (range))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 67, "code": "(fn [n]\n  (take n (let [nums (iterate inc 2)]\n            ((fn primes\n               [x]\n               (cons (first x)\n                     (lazy-seq (primes (filter #(not= 0 (mod % (first x)))\n                                               (rest x))))))\n             nums))))", "user": "5c30da5ae4b0d62ef62d9f23"}, {"problem": 67, "code": "(fn get-x-primes [x]\n\n   (letfn [(is-prime [num]\n             (if (= num 1)\n               true\n               (loop [num num cur-divisor (dec num)]\n                 (if (= cur-divisor 1)\n                   true\n                   (if (= (mod num cur-divisor) 0)\n                     false\n                     (recur num (dec cur-divisor)))))))\n                     \n          (find-next-prime [last-prime]\n            (loop [num (inc last-prime)]\n              (if (is-prime num)\n                num\n                (recur (inc num)))))\n                \n          ]\n          (loop [req-num-primes x cur-primes [2]]\n            (if (= (count cur-primes) req-num-primes)\n              cur-primes\n              (recur req-num-primes (conj cur-primes (find-next-prime (last cur-primes))))\n              )\n\n            )\n          )\n\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x] (->> (range 2 x)\n                           (map #(mod x %))\n                           (not-any? zero?)))]\n    (take n (for [p (range)\n                  :when (> p 1)\n                  :when (prime? p)]\n              p))))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 67, "code": "(fn nprimes [n]\n  (let [\n        prime? (fn [n] (every? #(not= 0 (rem n %)) (range 2 n)))\n        next-prime (fn next-prime [prev-prime] (first (filter prime? (iterate inc (inc prev-prime)))))\n        ]\n  \t(take n (iterate next-prime 2))\n    )\n  )", "user": "6004c750e4b074f607df6645"}, {"problem": 67, "code": "(fn p [n & s]\n  (let [start (if (nil? s) 2 (first s))]\n    (cond\n     (zero? n) []\n     ((fn [dividend]\n        (cond\n         (= dividend 1) true\n         (zero? (rem start dividend)) false\n         :else (recur (dec dividend))))\n      (quot start 2)) (apply vector start (p (dec n) (inc start)))\n     :else (p n (inc start))\n    )))", "user": "60096aabe4b074f607df667f"}, {"problem": 67, "code": "(fn [n] (letfn [(sieve [s n]\n            (let [m (first s)]\n                (lazy-seq (cons m (sieve (filter #(not= (rem % m) 0) s) (inc n))))))]\n        (take n (sieve (iterate inc 2) 2))))", "user": "600ae927e4b074f607df6689"}, {"problem": 67, "code": "(fn x-primes [x]\n    (letfn [(prime? [x]\n                    (and (or (= x 2) (not (= 0 (mod x 2))))\n                         (= 0 (count (filter #(= 0 (mod x %))\n                                     (range 3 (inc (int (Math/sqrt x))) 2))))))\n            (prime-list []\n                   (filter #(prime? %) (drop 2 (range))))]\n        (take x (prime-list))))", "user": "5ff93da9e4b06df49cee14af"}, {"problem": 67, "code": "(fn [x]\n  (letfn [(sieve [[p & zs]]\n                 (lazy-seq (cons p (sieve (remove #(zero? (mod % p)) zs)))))]\n    (take x (sieve (iterate inc 2)))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 67, "code": "(fn nPrimes [n]\n  (letfn [(sieve [sieveList]\n\n            (cons (first sieveList)\n                  (lazy-seq\n                    (sieve (filter\n                             #(not= 0 (mod % (first sieveList)))\n                             (rest sieveList)\n                             ))\n                    )\n                  )\n            )]\n    (take n (sieve (iterate inc 2)))\n    ))", "user": "5fce0cc5e4b07e53c2f3f000"}, {"problem": 67, "code": "(fn [n]\n(letfn [(p? [i]\n(not-any? #(and (not= i %) (= 0 (mod i %)))\n(range 2 (inc (Math/sqrt i)))))]\n(take n (drop 2 (filter p? (range))))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 67, "code": "(fn primes [a]\n  (let [is-prime? (fn [b] (->> b\n                               (inc)\n                               (range 1)\n                               (filter #(zero? (mod b %)))\n                               (count)\n                               (= 2)))]\n    (take a (filter is-prime? (range)))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 67, "code": "(fn generatePrimes [x] \n  (take x (let [f (fn [x] (loop [lst (range 2 (+ 1 (int (Math/sqrt x))))]\n                            (cond\n                              (empty? lst) true\n                              (= 0 (mod x (first lst))) false\n                              :else (recur (rest lst)))\n                            ) )]\n            (cons 2 (filter #(not= % nil) (map #(if (f %) %) (iterate inc 3)))))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 67, "code": ";; this seems a bit harder than medium...\n;; (fn prime [n]\n;;  (take n (filter (fn [x] (->> (range 2 x)\n;;                               (map #(mod x %))\n;;                               (into #{})\n;;                               (#(contains? % 0))\n;;                               (not)))\n;;                  (range 2 Double/POSITIVE_INFINITY))))\n\n;; this seems more elegant\n(fn [n] \n  (->>\n  (range)\n  (drop 2)\n  (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n  (take n)))", "user": "5fb68f09e4b08cb800c85b58"}, {"problem": 67, "code": "(fn getprimes [n] \n     (letfn [( is-prime? [a] \n        (->> (reduce #(if (= 0 (rem a %2)) (inc %1) %1) \n            0 (drop 2 (range a)))\n        (= 0))) ]  \n     (take n (filter is-prime? (iterate inc 2)))))", "user": "5fec4f5ee4b05ac5b16ea1bf"}, {"problem": 67, "code": "(fn [n]\n  (loop [primes []\n         v 2\n         cnt 0]\n    (if (= cnt n)\n      primes\n      (if (and (< 1 v)\n       (not-any? #(= (rem v %) 0) (range 2 v)))\n        (recur (conj primes v) (inc v) (inc cnt))\n        (recur primes (inc v) cnt)))))", "user": "5edd05bfe4b0c7845d86b0f3"}, {"problem": 67, "code": "(fn prime* [n]\n  (let [ no-prime?* (fn [x]\n                     (if (loop [i 2 limit (int (Math/sqrt x))]\n                           (if (> i limit)\n                             false\n                             (if (= 0 (mod x i)) true (recur (inc i) limit))))\n                       nil x))]\n    (take n (drop 2 (filter no-prime?* (range))))))", "user": "6022844de4b0d5df2af22203"}, {"problem": 67, "code": "#(->> (range) \n      (drop 2)\n      (filter (fn [p]\n                  (not-any? (fn [d] (= (mod p d) 0))\n                            (range 2 p))))\n      (take %))", "user": "4e38f245535deb9a81d77f3e"}, {"problem": 67, "code": "(fn n-primes [n]\n  (take n\n        (filter (fn [i] (= 2\n                           (count (filter #(zero? (rem i %)) (range 1 (inc i))))))\n                (iterate inc 2))))", "user": "601c39eee4b0bf4ca6b10937"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(isprime? [k] (loop [div 2 cislo k]\n                          (cond (= div cislo) true\n                            \t(= 0 (rem cislo div)) false\n                                :else (recur (inc div) cislo))))\n          (prime-seq [l]\t(if (isprime? l) (lazy-seq (cons l (prime-seq (inc l))))\n                              (prime-seq (inc l))))]\n    (take n (prime-seq 2))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 67, "code": "(fn primes [n]\n  (take n (filter (fn [num] (= 2 (count (filter #(= 0 (mod num %))\n                                                (range 1 (inc num))))))\n                  (range))))", "user": "5fada7cce4b08cb800c85af5"}, {"problem": 67, "code": "#(take % (iterate \n           (fn [e] \n             (loop [ne (inc e)]\n               (if (some (fn [i] (= 0 (mod ne i))) (range 2 ne))\n                 (recur (inc ne))\n                 ne)))\n           2))", "user": "6026737ee4b0d5df2af2222f"}, {"problem": 67, "code": "(fn primes [n] \n  (take n \n        (filter (fn is-prime? [n] (and (>= n 2) (->> n (inc) (Math/sqrt) (range 2) (not-any? #(zero? (rem n %)))))) (iterate inc 1))))", "user": "6031926ae4b0d5df2af222ac"}, {"problem": 67, "code": "(fn primes3 [n]\n  (letfn [(prime3? [x] (empty? (filter #(= 0 (mod x %)) (range 2 x))))]\n    (vec (take n (filter #(prime3? %) (iterate inc 2))))))", "user": "602372aae4b0d5df2af2220f"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "5fd361f2e4b07e53c2f3f04e"}, {"problem": 67, "code": "(fn a[n]\n    (take n (filter (fn prime? [n]\n    (not (some #(and (not= n 2) (zero? (mod n %))) (range 2 (inc (Math/sqrt n))))))\n (iterate inc 2))))", "user": "5fe09d1fe4b05ac5b16ea15b"}, {"problem": 67, "code": "(fn primes [n]\n  (->> (range)\n       (drop 2)\n       (filter (fn is-prime [x]\n                 (or\n                   (= x 2)\n                   (->> (range 2 (inc (/ x 2)))\n                        (map #(/ x %))\n                        (some integer?)\n                        not))))\n       (take n)))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 67, "code": "(fn primes [n] \n  (->>\n    (range)\n    (drop 2)\n    (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n    (take n)))", "user": "602cc4d4e4b0d5df2af22274"}, {"problem": 67, "code": "(let\n  [is-prime (fn [x]\n              (->>\n               (range 2 x)\n               (filter #(= 0 (mod x %)))\n               empty?\n               ))]\n\n  (fn primes\n    ([] (filter is-prime (map #(+ 2 %) (range))))\n    ([n] (take n (primes)))))", "user": "6045582fe4b02d28681c77b6"}, {"problem": 67, "code": "(fn [n]\n    (loop [v 3\n           a [2]]\n      (cond\n        (= n (count a)) a\n        (not-any? #(= 0 (mod v %)) a) (recur (inc v) (conj a v))\n        :1 (recur (inc v) a))))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn is-prime [n] (nil? (some #(zero? (mod n %))(range 2 n))))\n(range 2 1000))))", "user": "601bdcb3e4b0bf4ca6b10930"}, {"problem": 67, "code": "#(take % (drop 2\n       (filter \n        (fn [n] \n          (not-any? \n           (fn [m] \n             (= 0 (rem n m))) \n           (range 2 n))) \n        (range))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 67, "code": "(let [next-primes (fn next-primes [primes]\n  \"Given a list $primes consisting of the first (count primes) primes,\ngenerate the list of the first (inc (count primes)) primes.\"\n  (let [p (first (filter (fn [n] (every? (fn [p] (not (= (mod n p) 0)))\n                                         primes))\n                         (iterate inc (inc (last primes)))))]\n    (conj primes p)))]\n  (fn [n] (nth (iterate next-primes [2]) (dec n))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 67, "code": "(fn find-prime [n] \n  (loop [start 2\n         target-num n\n         coll []\n         is-prime (fn [x] (loop [s (- x 1) t x] (cond\n                                       (= s 1) true\n                                       (zero? (mod t s)) false\n                                       :else (recur (dec s) t)\n                                       )))]\n    (if (= n (count coll)) coll (cond\n                                 (is-prime start) (recur (+ start 1) n (conj coll start) is-prime)\n                                 :else (recur (+ start 1) n coll is-prime)\n                                 )))\n  )", "user": "60471241e4b02d28681c77c9"}, {"problem": 67, "code": "(fn prime-numbers\n  [n]\n  (let [next-prime (fn [v]\n                     (loop [x (inc (last v))]\n                       (if (some #(= 0 (mod x %)) v)\n                         (recur (inc x))\n                         (conj v x))))]\n    (nth (iterate #(next-prime %) [2]) (dec n))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 67, "code": "(fn [n]\n    (take n (filter\n             #(not-any?;; is prime\n               (fn [a] (zero? (mod % a)))\n               (range 2 %))\n             (drop 2 (range)))))", "user": "54be7c0de4b0ed20f4ff6eec"}, {"problem": 67, "code": "(fn __ [n]\n  (loop [x 2 out []]\n    (if (= n (count out))\n      out\n      (if (= 1 (count (filter true? (map #(= (mod x %) 0) (range 2 (inc x))))))\n        (recur (inc x) (conj out x))\n        (recur (inc x) out)))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 67, "code": "(fn take-primes [n]\n  (let [primess ((fn primes-seq\n  ([] (primes-seq 2))\n  ([a] \n   (let [divisable? #(zero? (mod %1 %2)) \n         is-prime (fn [x] (not-any? #(divisable? x %) (range 2 x)))\n         next-prime #(if (is-prime %) % (recur (inc %)))]\n     (cons a (lazy-seq (primes-seq (next-prime (inc a))))))))\n)]\n    (take n primess)))", "user": "60606490e4b03746e80ebf67"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter\n         (fn [i]\n           (every?\n            #(< 0 (mod i %))\n            (range 2 (dec i))))\n         (drop 2 (range)))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 67, "code": "(fn\n  [x]\n  (letfn [(divisors [n] (filter #(zero? (rem n %)) (range 1 n)))]\n    (take x (filter #(= 1 (count (divisors %))) (range)))))", "user": "5ec02e20e4b00a66d4a95288"}, {"problem": 67, "code": "(fn [n]\n\n  (take n ((fn primes\n             []\n             (letfn [(prime-help\n                       [foo bar]\n                       (loop [D foo\n                              q bar]\n                         (if (nil? (get D q))\n                           (cons q (lazy-seq\n                                    (prime-help\n                                     (persistent! (assoc! (transient D) (* q q) (list q)))\n                                     (inc q))))\n                           (let [factors-of-q (get D q)\n                                 key-val (interleave\n                                          (map #(+ % q) factors-of-q)\n                                          (map #(cons % (get D (+ % q) (list)))\n                                               factors-of-q))]\n                             (recur (persistent!\n                                     (dissoc!\n                                      (apply assoc! (transient D) key-val)\n                                      q))\n                                    (inc q))))))]\n               (prime-help {} 2))))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(primes []\n                  (lazy-seq (cons 2 (cons 3 (filter prime? (iterate inc 5))))))\n          (prime? [n] \n                  (not-any? \n                    #(= 0 (mod n %)) \n                    (take-while #(<= % (Math/sqrt n)) (primes))))]\n    (take n (primes))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 67, "code": "(fn [x]\n   (let [primes [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]]\n     (take x primes)))", "user": "5d5c2730e4b09db18d4482ea"}, {"problem": 67, "code": "(fn [x] (take x (drop 2 (filter (fn [n] (every? #(not= 0 (mod n %)) (range 2 n))) (range)))))", "user": "606b5ca8e4b069485764ddfe"}, {"problem": 67, "code": "(fn problem-67 [n]\n  (let [divisible?  (fn [x y]\n                      (zero? (mod x y)))\n        prime?      (fn [x]\n                      (empty? (filter (partial divisible? x)\n                                      (range 2 x))))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "5d669613e4b0db5d338d15ea"}, {"problem": 67, "code": "(fn foo \r\n  ([n] \r\n    (foo (dec n) 3 [2]))\r\n  ([n current prev]\r\n    (if (zero? n)\r\n      (sort prev)\r\n      (if (empty? (filter #(= 0 (mod current %)) prev))\r\n        (recur (dec n) (inc current) (conj prev current))\r\n        (recur n (inc current) prev)))))", "user": "606e0a42e4b069485764de19"}, {"problem": 67, "code": "(fn n-primes\n  [n]\n  (take n (filter (fn primetest\n    [num]\n    (if (< num 2) false \n      (if (= num 2)\n        true\n        (if (some #(= 0 (mod num %)) (drop 2 (range num)))\n          false\n          true)))) (range))))", "user": "605b319de4b079a07f8593f7"}, {"problem": 67, "code": "(fn prime [n]\n  (if (= 1 n) [2]\n    (let [prev-prime (prime (dec n))]\n      (conj prev-prime\n            (loop [i (inc (last prev-prime))]\n              (if-not (some #(zero? (mod i %)) prev-prime)\n                i\n                (recur (inc i))))))))", "user": "5e471203e4b043cd24807a2a"}, {"problem": 67, "code": "(fn [n]\n  (letfn [(prime? [x] (every? #(not (= 0 (mod x %))) (range 2 x)))]\n    (take n (filter prime? (iterate inc 2)))))", "user": "606d7f1ce4b069485764de14"}, {"problem": 67, "code": "(fn prime-number'''\n  [x]\n  (loop [prime-list []\n         index 2]\n    (cond\n      (= (count prime-list) x) prime-list\n      (every?\n        #(not (= (mod index %) 0))\n        (take-while #(>= (Math/sqrt index) %) prime-list))\n      (recur (conj prime-list index) (inc index))\n      :else (recur prime-list (inc index)))))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "606ff89be4b069485764de22"}, {"problem": 67, "code": "(fn isp [x] (loop [cum [2] j 3] (if (= x (count cum)) cum ( if (\n (fn isprime [n] (loop [i 2] (if (> i (Math/sqrt n) ) true ( if (= 0 (rem n i)) false (recur (inc i))))))       \n  j) (recur (conj cum j) (inc j)) (recur cum (inc j))))))", "user": "6076adb2e4b069485764de60"}, {"problem": 67, "code": "#(take %\n       (filter (fn [n]\n                 (not-any? (fn [x] (zero? (rem n x)))\n                           (range 2 n)))\n               (iterate inc 2)))", "user": "606da089e4b069485764de15"}, {"problem": 67, "code": "(fn [n]\n  (loop [x [] y (drop 2 (range))]\n    (if (= (count x) n)\n      x\n      (if (and (> (first y) 1) (not-any? (partial #(zero? (mod %1 %2)) (first y)) (range 2 (first y))))\n        (recur (conj x (first y)) (rest y))\n        (recur x (rest y))))))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 67, "code": "(fn prime-gen [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))]\n    (take cnt (filter prime? (iterate inc 2)))))", "user": "60803206e4b0736b099e42cc"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter\n         (fn [m]\n           (if (< m 2)\n             false\n             (->> (range 2 (inc (/ m 2)))\n                  (filter #(zero? (mod m %)))\n                  count\n                  zero?)))\n         (drop 2 (range)))))", "user": "60794173e4b0a637ed78035d"}, {"problem": 67, "code": "(fn [n]\n  (let [sieve (fn sieve [s]\n                (cons (first s)\n                      (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                               (rest s))))))]\n    (take n (sieve (iterate inc 2)))))", "user": "605f5c69e4b03746e80ebf5e"}, {"problem": 67, "code": "(fn [n]\n  (let [next-prime (fn [[n primes]]\n                     (let [c (->> (map #(rem n %) primes) (filter (fn [x] (= 0 x))) count)]\n                       (if (= 0 c)\n                         [(inc n) (conj primes n)]\n                         [(inc n) primes])))]\n    (last (last (take-while #(<= (count (last %)) n) (iterate next-prime [3 [2]]))))))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 67, "code": "(fn prime-nums [n]\n  (->> (range)\n       (remove (fn [x] (some #(= (mod x %) 0) (range 2 x))))\n       (drop 2)\n       (take n)))", "user": "60849bd6e4b0736b099e42f2"}, {"problem": 67, "code": "(fn [n]\n    (letfn [(prime-numbers [[this-prime primes]]\n                (if (not-any? #(zero? (rem this-prime %)) primes)\n                    [this-prime (conj primes this-prime)]\n                    (prime-numbers [(inc this-prime) primes])))]\n      (->> (iterate prime-numbers [2 [2]])\n           (map first)\n           (take n))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 67, "code": "(fn prime-gen [x]\n  (let [prime? (fn [y]\n                 (not (some #(and\n                               (not= y %)\n                               (zero? (mod y %)))\n                            (range 2 (inc (Math/sqrt y))))))]\n    (take x (filter prime? (iterate inc 2)))))", "user": "5ff709e4e4b06df49cee149b"}, {"problem": 67, "code": "(fn [n]\n  (let [prime? (fn [n] \n                 (or \n                  (= n 2) \n                  (not-any? #(= 0 (mod n %)) (drop 2 (range (inc (Math/sqrt n)))))))]\n    (take n (filter prime? (drop 2 (range))))))", "user": "6088395de4b0ae75613dcee2"}, {"problem": 67, "code": "(fn [want]\n  (take \n   want\n   (filter\n    (fn [n]\n      (and \n       (> n 1)\n       (every? #(not (zero? (mod n %))) (range 2 n)))) \n    (range))))", "user": "5b4b8cd6e4b02d533a91bc9f"}, {"problem": 67, "code": "(fn primes [n]\n  (letfn[(prime? [x] (and (> x 1) (not-any? #(zero? (mod x %)) (range 2 x))))]\n   (->> (range)\n        (filter prime?)\n        (take n))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 67, "code": "(fn [n] (take n (filter (fn prime? [x] (every? #(not= 0 (mod x %)) (range 2 (- x 1)))) (iterate inc 2))))", "user": "59adec09e4b0e1f4e384c897"}, {"problem": 67, "code": "(fn [n]\n  (let [isprime? (fn isprime? [p]\n   (empty? (filter #(= 0 (mod p %1)) (range 2 (+ 1 (int (Math/sqrt p)))))))\n        ]\n    (loop [i 2 primes []]\n      (cond\n        (= n (count primes)) primes\n        (isprime? i) (recur (inc i) (conj primes i))\n        :else (recur (inc i) primes)))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 67, "code": "(fn primes\n  [n]\n  (loop [sieved (drop 2 (range))\n         result []]\n    (if (= n (count result))\n      result\n      (let [x (first sieved)]\n        (recur \n          (remove #(zero? (mod % x)) (rest sieved))\n          (conj result x))))))", "user": "6098263be4b00e9e6653c3f9"}, {"problem": 67, "code": "(fn [n]\n  (take n (filter\n            (fn [n]\n              (if (< n 2)\n                false\n                (loop [d 2]\n                  (let [d2 (* d d)]\n                   (if (> d2 n)\n                     true\n                     (if (= 0 (mod n d))\n                       false\n                       (recur (inc d)))))))) (range))))", "user": "60882700e4b0ae75613dcedf"}, {"problem": 67, "code": "(fn [n]\n  (let [mod-prime-list\n        (fn [l n]\n          (if (empty? l)\n            n\n            (if (zero? (mod n (first l)))\n              0\n              (recur (rest l) n))))\n        is-prime?\n        (fn [n l]\n          (cond (= n 2) true\n                :else (if (zero? (mod-prime-list l n))\n                        false\n                        true)))]\n    (loop [cnt n result [] num 2]\n      (if (= (count result) cnt)\n        result\n        (if (is-prime? num result)\n          (recur cnt (conj result num) (inc num))\n          (recur cnt result (inc num)))))))", "user": "58e90258e4b056aecfd47cfd"}, {"problem": 67, "code": "(fn [n]\n  (loop [curr 2 primes []]\n    (if (= (count primes) n)\n      primes\n      (recur \n       \t(inc curr) \n        (if (some zero? (map #(rem curr %) primes))\n          primes\n          (conj primes curr))))))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 67, "code": "(fn [x]\n  (->> (range 2 1000)\n       (filter #(= 0 (count (filter (fn [a] (= (rem % a) 0)) (range 2 (inc (quot % 2)))))))\n       (take x))\n  )", "user": "60aecd73e4b00e9e6653c49a"}, {"problem": 67, "code": "(fn [n]\n   (->> (range)\n        (drop 2)\n        (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x))))\n        (take n)))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 67, "code": "(fn [n]\n        (loop [idx (dec n)\n              res [2]\n              cands (iterate (partial + 2) 3)]\n          (if (= 0 idx)\n            res\n            (let [next-p (first cands)\n                  next-cands (filter #(not= 0 (mod % next-p)) (rest cands))]\n              (recur (dec idx) (conj res next-p) next-cands)))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 67, "code": "(fn primes\n  ([n] (primes n [] 0))\n  ([n coll i] \n   (let [prime? (fn [x] (= [1] (filter #(= 0 (mod x %)) (range 1 x))))]\n     (if (= n (count coll)) \n       coll \n       (primes n (if (prime? i) (conj coll i) coll) (+ 1 i))))))", "user": "60b3b8a9e4b0e0fa5f1b4233"}, {"problem": 67, "code": "(fn fn-sieve-of-eratosthenes\n  [n]\n  (assert (> n 1) \"number needs to be greater that 1\")\n  (let [gen-primes (fn []\n                     (letfn [(reinsert [table x prime]\n                               (update-in table [(+ prime x)] conj prime))\n                             (primes-step [table d]\n                               (if-let [factors (get table d)]\n                                 (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)\n                                        (inc d))\n                                 (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))\n                                                                (inc d))))))]\n                       (primes-step {} 2)))]\n    (take n (gen-primes))))", "user": "60c0ceb7e4b0e0fa5f1b42a6"}, {"problem": 67, "code": "(fn f\n    ([n] (f (dec n) [2] (map #(inc (* 2 %)) (drop 1 (range)))))\n    ([n p [x & xs]]\n     (if (not (some #(zero? (mod x %)) p))\n       (if (= 1 n)\n         (conj p x)\n         (f (dec n) (conj p x) xs))\n       (f n p xs))))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 67, "code": "(fn primes\n  ([] (primes [] -1))\n  ([n] (primes [] n))\n  ([p n]\n   (if (zero? n)\n     '()\n     (lazy-seq\n      (if (empty? p)\n        (cons 2 (primes [2] (dec n)))\n        (let [np (loop [i (-> p last inc)]\n                   (if (some #(zero? (rem i %)) p)\n                     (recur (inc i))\n                     i))]\n          (cons np (primes (conj p np) (dec n)))))))))", "user": "5fd92743e4b05ac5b16ea11f"}, {"problem": 67, "code": "(fn [n]\n  (let [is-prime? (fn [n]\n                    (if (< n 3)\n                      (= n 2)\n                      (let [highest-div (int (Math/sqrt n))\n                            divisors (filter #(= 0 (mod n %))\n                                             (range 2 (inc highest-div)))]\n                        (empty? divisors))))\n        next-prime (fn [cur]\n                     (first\n                      (filter is-prime? (iterate inc (inc cur)))))]\n    (reduce\n     (fn [primes _]\n       (conj\n        primes\n        (next-prime (last primes))))\n     [2]\n     (range (dec n)))))", "user": "60c8e372e4b0e0fa5f1b42ff"}, {"problem": 67, "code": "(fn [n]\n   (take n (lazy-seq\n            (->> (rest (rest (range)))\n                 (filter (fn [j]\n                           (->> (rest (range j))\n                                (filter (fn [i] (= 0 (mod j i))))\n                                count\n                                (= 1)))))\n            )))", "user": "5fa80c01e4b0fa27300f3de2"}, {"problem": 67, "code": "(fn prime [num]\n  (loop [num num\n         biglist []\n         res []\n         cur 2\n         bigsize (count biglist)]\n    (if (>= (count res) num)  res\n        (recur num (conj biglist cur)\n               (cond\n                 (= 2 cur) (conj res cur)\n                 \n                 (even? cur) res\n                 \n                 (nil?\n                  (some #(zero? (mod cur %))\n                        (if (< bigsize 2) biglist\n                            (take (int (/ (count biglist) 2))\n                              biglist))))\n                 (conj res cur)\n                 :else res)\n               (inc cur)\n               (inc bigsize)\n               ))))", "user": "6038b6b4e4b0d5df2af222ef"}, {"problem": 67, "code": ";; I'm a cheating bastard\n(fn primes [n]\n  (take n [2, 3, 5, 7, 11, 541]))", "user": "60c91f48e4b0e0fa5f1b4304"}, {"problem": 67, "code": "(fn [n]\n  (take n\n        (filter\n          (fn is-prime [n]\n            (nil?\n             (some\n              #(zero? (mod n %))\n              (range 2 n))))\n          (range 2 1000))))", "user": "5839f079e4b089d5ab817d48"}]