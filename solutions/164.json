[{"code": "(fn [{:keys [states start accepts transitions]}]\n  ((fn words [queue]\n     (lazy-seq\n       (when (seq queue)\n         (let [[state path] (peek queue)\n               more-results (words (into (pop queue)\n                                         (for [[letter state] (transitions state)]\n                                           [state (conj path letter)])))]\n           (if (accepts state)\n             (cons (apply str path)\n                   more-results)\n             more-results)))))\n   (conj clojure.lang.PersistentQueue/EMPTY\n         [start []])))", "problem": 164, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn enumerate-lang [dfa]\n  (letfn [(vrest [v] (subvec v 1))\n          (vconcat [v xs] (if (seq xs) (apply conj v xs) v))\n          (helper [queue]\n            (if (seq queue)\n              (let [[node output] (first queue)\n                    kids (for [[sym child] (get-in dfa [:transitions node])]\n                           [child (str output sym)])\n                    queue (vconcat (vrest queue) kids)]\n                (if (get-in dfa [:accepts node])\n                  (lazy-seq (cons output (helper queue)))\n                  (recur queue)))))]\n    (helper [[(dfa :start) \"\"]])))", "problem": 164, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn solve [dfa]\n  (let [accepts?\n        (fn [state] (contains? (dfa :accepts)\n                               (state :label)))\n\n        transition\n        (fn [state path]\n          (when-let [next-state-name (get-in dfa [:transitions (state :label) path])]\n            {:label next-state-name :path (str (state :path) path)}))\n\n        paths-from\n        (fn [state]\n          (keys (get-in dfa [:transitions (state :label)])))\n\n        perform-walk\n        (fn [state]\n          (keep identity\n                (map #(transition state %)\n                     (paths-from state))))\n\n        gen-states\n        (fn gen-states [frontier]\n          (when (seq frontier)\n            (let [next-frontier\n                  (apply concat (map perform-walk frontier))]\n              (lazy-cat frontier\n                        (lazy-seq (gen-states next-frontier))))))\n\n        start-state\n        {:path \"\" :label (dfa :start)}]\n\n    (map :path\n         (filter accepts?\n                 (gen-states [start-state])))))", "problem": 164, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn l\n   ([dfa] (l dfa [[(dfa :start) \"\"]]))\n   ([dfa tup]\n     (if (not (empty? tup))\n     (let [cur (first tup)\n           rst (vec (rest tup))\n           nxt (vec (map #(vector (second %) (str (second cur) (first %))) ((dfa :transitions) (first cur))))\n           all (if (empty? nxt) rst (apply conj rst nxt))] \n         (lazy-seq (if ((dfa :accepts) (first cur)) (cons (second cur) (l dfa all)) (l dfa all)))))))", "problem": 164, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [d]\n  (let [q (fn q [[c n]]\n            (if (empty? c)\n              (if (empty? n)\n                nil\n                (q [n []]))\n              (let [[e f] (first c)\n                    m (lazy-cat n (map (fn [[k h]] [(conj e k) h]) (get (:transitions d) f)))\n                    r [(rest c) m]]\n                (if ((:accepts d) f)\n                  [e r]\n                  (recur r)))))\n        p (fn p [cj]\n            (let [[g h] (q cj)]\n              (lazy-cat (if (nil? h) nil (cons g (p h))))))]\n    (map #(apply str %) (p [[[[] (:start d)]] []]))))", "problem": 164, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [\n      (next-paths [[st trail]]\n        (map\n          (fn [[sym next-st]] [next-st (conj trail sym)])\n          (transitions st)))\n      (final? [[st _]] (accepts st))\n      (string [[_ trail]] (apply str trail))\n      (seq-cont [aseq cont]\n        (lazy-seq\n          (if-let [elem (first aseq)]\n            (cons elem (seq-cont (rest aseq) cont))\n            (cont))))\n      (lazy-concat [cols]\n        (when-let [col (first cols)]\n          (seq-cont col #(lazy-concat (rest cols)))))]\n   (->> (iterate #(set (mapcat next-paths %)) #{[start []]})\n      (take-while not-empty)\n      lazy-concat\n      (filter final?)\n      (map string))))", "problem": 164, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "#(keep \n  (fn [[s t]] (when ((:accepts %) t) s)) \t\t\t\n\t((fn f [x] \n\t\t(when-not (empty? x)\n\t\t\t(concat\n\t\t\t\tx\n\t\t\t\t(lazy-seq \n\t\t\t\t\t(f\n\t\t\t\t\t\t(mapcat \n\t\t\t\t\t\t\t(fn [[s t]] (map (fn [[a n]] [(str s a) n]) ((:transitions %) t))) \n\t\t\t\t\t\t\tx))))))\n\t\t[[\"\" (:start %)]]))", "problem": 164, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [dfa]\n  (letfn [\n    (statestep [[prefix state]]\n      (fn [[ch state2]] \n        [(str prefix ch) state2]))\n    (step [st]\n      (map (statestep st) \n        (get (:transitions dfa) (last st) {})))\n    (steps [sts]\n      (apply concat (map step sts)))\n    (all [sts]\n      (lazy-seq\n        (if (empty? sts) [] \n          (concat \n            (map first\n              (filter #(contains? (:accepts dfa) (last %)) sts))\n            (all (steps sts))))))\n    ]\n  (all [[\"\" (:start dfa)]])))", "problem": 164, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [dfa]\r\n  (let [{:keys [alphabet start accepts transitions]} dfa]\r\n    (letfn [(doit [curr]\r\n              (let [next\r\n                    (for [[s w] curr\r\n                          x alphabet\r\n                          :let [ns (when-let [t (transitions s)] (t x))]\r\n                          :when ns]\r\n                      [ns (conj w x)])]\r\n                (when-not (empty? next)\r\n                  (lazy-cat\r\n                    (map #(apply str (second %)) (filter #(accepts (first %)) next))\r\n                    (doit next)))))]\r\n      (doit [[start []]]))))", "problem": 164, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [d]\n  ((fn dfa [ds]\n     (let [dsn (for [[state path] ds\n                     [letter next-state] ((:transitions d) state)]\n                 [next-state (str path letter)])]\n       (if (seq dsn)\n         (lazy-seq (concat (for [[state path] dsn :when ((:accepts d) state)] path)\n                           (dfa dsn))))))\n    [[(:start d) \"\"]]))", "problem": 164, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn [m]\n  ((fn vm [q]\n     (when-not (empty? q)\n       (let [[s x] (first q)\n             g (for [[c t] ((m :transitions) s)]\n                 [t (str x c)])]\n         (lazy-cat (keep (fn [[s x]] (if ((m :accepts) s) x)) g)\n                   (vm (concat (rest q) g))))))\n   [[(m :start) \"\"]]))", "problem": 164, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [{q0 :start :keys [transitions accepts]}]\n  (letfn [(exp [wip]\n            (when (seq wip)\n              (let [[s1 word] (first wip)\n                    wip2 (into (rest wip)\n                  (sort-by #(if (accepts (first %)) 1 0)\n                    (for [[sym s2] (transitions s1)]\n                    [s2 (.concat word (.toString sym))])))]\n                (if (accepts s1)\n                  (cons word (lazy-seq (exp wip2)))\n                  (recur wip2)))))]\n    (exp [[q0 \"\"]])))", "problem": 164, "user": "4e95f5a5535dbda64a6f6b3b"}, {"code": "(fn all-strings [dfa]\r\n  (let \r\n    [start (dfa :start)\r\n     word \"\"\r\n     cheato false\r\n     ;state [start word]\r\n     ;to-dos []\r\n     step (fn step [state-words dones]\r\n            (let\r\n              [;_ (println \"state\" state)\r\n               ;_ (println \"word\" word)\r\n               ;_ (println \"num todos\" (count todos))\r\n               ;_ (println \"todos\" todos)\r\n               new-dones (conj dones state-words)\r\n\r\n               valid-words (for [[state word] state-words\r\n                                 :when ((dfa :accepts) state)] word)\r\n               ;_ (println \"valid words\" valid-words)\r\n               next-state-words (for [[state word] state-words\r\n                                      [next-letter next-state] ((dfa :transitions) state)]\r\n                                     [next-state (str word next-letter)])\r\n\r\n               unseen-next-state-words \r\n                (if cheato\r\n                (filter #(re-matches #\"limit|(?:loop)+|(?:loop)+l|(?:loop)+lo(?:loop)+loo\" (second %))\r\n                   (remove #(new-dones %) next-state-words))\r\n                (remove #(new-dones %) next-state-words))\r\n               ];_ (println \"unsw\" unseen-next-state-words)]\r\n                                     \r\n               (if (seq next-state-words)\r\n                 (lazy-seq\r\n                   (concat valid-words (step unseen-next-state-words new-dones)))\r\n                 valid-words)))]\r\n     (step [[start word]] #{})))", "problem": 164, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [d]\n  (let [f (fn [[k v]] (for [[q w] ((:transitions d) v)] [(str k q) w]))]\n    (mapcat #(keep (fn [[k v]] (if ((:accepts d) v) k)) %)\n            (take-while seq (iterate #(mapcat f %) (f [\"\" (:start d)]))))))", "problem": 164, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn dfa [{:keys [accepts start transitions]}]\n  (letfn [(accepts? [state] (contains? accepts (:state state)))\n          (step [{:keys [state string]}]\n            (map (fn [[symb new-state]]\n                   {:state new-state :string (str string symb)})\n              (transitions state [])))\n          (step-all [[_ states]]\n            [(map :string (filter accepts? states))\n             (mapcat step states)])]\n  (->> (iterate step-all [[] [{:state start :string \"\"}]])\n       (take-while #(some (comp not empty?) %))\n       (mapcat first))))", "problem": 164, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [dfa]\n    (->>\n     [[[] (:start dfa)]]\n     (iterate (partial mapcat (fn [[s q]]\n                                (for [[c nq] (get-in dfa [:transitions q])]\n                                  [(conj s c) nq]))))\n     (take-while seq)\n     (apply concat)\n     (filter (comp (:accepts dfa) second))\n     (map #(apply str (first %)))))", "problem": 164, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [{:keys [states start accepts transitions]}]\n  (->> [[\"\" start]]\n    (iterate \n      #(mapcat (fn [[s state]]\n                 (for [[x next-state] (transitions state)]\n                   [(str s x) next-state])) %))\n    (take-while seq)\n    (mapcat (fn [xs] (keep (fn [[s state]] \n                             (when (accepts state) s)) xs)))))", "problem": 164, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn dfa-to-regex [dfa]\n  (let [{:keys [start accepts transitions states]} dfa\n        trans (assoc (reduce #(assoc %1 %2 (assoc (%1 %2) nil :_end)) transitions accepts) :_start {nil start})\n        rip-state (fn [trans s]\n         (let [loops (if-let [lp (not-empty (apply str (for [[e os] (trans s) :when (= os s)] e)))] (str \\( lp \\)))]\n           (dissoc\n             (reduce (fn [acc [ie is]]\n                          (assoc acc is\n                              (into (dissoc (acc is) ie)\n                                    (map #(vector (str ie loops (first %1)) (second %1))\n                                         (remove #(= s (val %)) (acc s))))))\n                     trans\n                     (for [[cs tm] trans [k v] tm :when (and (not= cs v) (= v s))] [k cs]))\n              s)))\n        trans (reduce #(rip-state %1 %2) trans states)\n        regex (group-by #(re-find #\"(.*)\\((.+)\\)(.*)\" %)\n              (keys (filter #(= :_end (val %)) (trans :_start))))]\n    (if-let [[_ pre rep suf] (some #(if (vector? %) %) (keys regex))]\n        (concat (regex nil) (map #(str pre % suf) (iterate #(str % rep) \"\")))\n        (regex nil))))", "problem": 164, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [{start :start acc :accepts tran :transitions}]\n  (letfn [(new-states [[state s]]\n            (map (fn [[sym n-state]] [n-state (conj s sym)])\n                 (tran state)))\n          (iter [coll]\n            (if (empty? coll) nil\n              (lazy-cat\n                (map second (filter #(acc (first %)) coll))\n                (iter (mapcat new-states coll)))))]\n    (map #(apply str %) (iter [[start []]]))))", "problem": 164, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [{:keys [start accepts transitions]}]\n  (let [step (fn [states]\n               (mapcat\n                 (fn [[src string]]\n                   (map \n                     (fn [[char dst]]\n                       [dst (str string char)])\n                     (transitions src)))\n                 states))\n        succ (fn succ [states]\n               (if-not (empty? states)\n                 (lazy-cat states (succ (step states)))))]\n    (map second (filter (comp accepts first) (succ [[start \"\"]])))))", "problem": 164, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn [{:keys [states start accepts transitions]}]\n  (let [step (fn [wm]\n               (apply merge-with concat\n                 (for [p states\n                       [a q] (transitions p)\n                       x (wm p)]\n                   {q [(str x a)]})))]\n    (mapcat\n      #(flatten (vals (select-keys % accepts)))\n      (take-while\n        #(not (empty? %))\n        (iterate step {start [\"\"]})))))", "problem": 164, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [{:keys [start accepts transitions]}]\r\n  (let [l (atom #{})]\r\n    (letfn [(f1 [edges cs cw count]\r\n              (if (and edges (<= count 20))\r\n                (let [[[cl ns] & rest] edges \r\n                      word (str cw cl)\r\n                      new-e (seq (transitions ns))]\r\n                  (if (accepts ns) (swap! l conj word))\r\n                  (if new-e (f1 new-e ns word (inc count)))\r\n                  (if rest (f1 rest cs cw (inc count)))\r\n                  )))]\r\n      (f1 (seq ( transitions start)) start \"\" 0))\r\n    @l))", "problem": 164, "user": "4e79ff2a535db169f9c796a9"}, {"code": "(fn [dfa]\n  (letfn [\n    (produce\n      [states]\n        (when (seq states)\n          (let [[state string] (first states)\n                trans (state (:transitions dfa))\n                stnext (map (fn [[a st]] [st (str string a)]) trans)\n                next (into (disj states [state string]) stnext)]\n            (if ((:accepts dfa) state)\n              (lazy-seq (cons string (produce next)))\n              (produce next))))\n         )]\n    (produce #{[(:start dfa) \"\"]})))", "problem": 164, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [dfa]\n  (letfn [(push [q xs] (vec (concat xs q)))\n          (step [[pending sol]]\n            (comment \n              pending list = [[current-state acc] ...]\n              ;;sol = [syms] or nil  ;;NB: too slow, had to produce strings\n              ;;directly, see commented code below\n              sol = \"str\" or nil\n              )\n            (when (seq pending)\n              (let [[current-state acc] (peek pending)\n                    pending (pop pending)\n                    next-states (map\n                               ;;(fn [[sym next-state]] [next-state (conj acc sym)]) \n                                 (fn [[sym next-state]] [next-state (str acc sym)])\n                                 (-> dfa :transitions current-state))\n                    pending (push pending next-states)]\n                (if ((:accepts dfa) current-state)\n                  [pending acc]\n                  (recur [pending nil])))))]\n  ;;(->> (iterate step [[[(:start dfa) []]] []])\n    (->> (iterate step [[[(:start dfa) \"\"]] []])\n         (map second)\n         (take-while (complement nil?))\n         next)))  ;; spurious first \"solution\"\n       ;;(map #(reduce str \"\" %)))))", "problem": 164, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [dfa]\n  (letfn [(iter [q]\n            (when-let [[state string] (peek q)]\n              (let [t (-> dfa :transitions state)\n                    to-q (map (fn [[c n]] [n (str string c)]) t)\n                    new-q (-> q pop (into to-q))]\n                (if (-> dfa :accepts state)\n                  (cons string (lazy-seq (iter new-q)))\n                  (recur new-q)))))]\n    (iter (conj clojure.lang.PersistentQueue/EMPTY\n                [(:start dfa) \"\"]))))", "problem": 164, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [dfa]\n  (let [trans (dfa :transitions)\n        acc (dfa :accepts)\n        single (fn [[st string]]\n                (map\n                  (fn [[a nst]] [nst (str string a)])\n                  (trans st)))\n        go (fn go [states] \n              (when (not (empty? states))\n                (lazy-cat \n                  (keep\n                    (fn [[st string]] \n                      (when (acc st) string))\n                    states)\n                  (go (mapcat single states)))))]\n    (go [[(dfa :start) \"\"]])))", "problem": 164, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn dfa [lang] \r\n         ((fn enum [pos string backlog]\r\n            (let [backlog2 (reduce (fn [acc [c st]] (conj acc [st (str string c)])) backlog ((:transitions lang) pos ()))]\r\n              ;(do (println pos string backlog backlog2)\r\n              (if (empty? backlog2)\r\n                (cons string ())\r\n                (let [[nextpos nextstring] (first backlog2)\r\n                      newbacklog (subvec backlog2 1)]\r\n                  (if ((:accepts lang) pos)\r\n                    (cons string (lazy-seq (enum nextpos nextstring newbacklog)))\r\n                    (recur nextpos nextstring newbacklog))))\r\n              ;)\r\n              ))\r\n           (:start lang) \"\" []))", "problem": 164, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [d]\n  ((fn f [b]\n     (if (= [] b)\n       []\n       (lazy-cat\n         (map #(% 0)\n           (filter\n             #((:accepts d) (% 1))\n             b))\n         (f (for [[r s] b\n                  [a n] ((:transitions d) s)]\n              [(str r a) n])))))\n   [[\"\" (:start d)]]))", "problem": 164, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn p164\n  ([dfa] (->> (p164 dfa [])\n              flatten\n              (filter (complement nil?))))\n  ([{:keys [transitions start accepts] :as dfa} word]\n     (when-let [trs (get transitions start)]\n       (let [[k v] (first trs)\n             [k2 v2] (second trs)\n             fstaccepted (some #{v} accepts)\n             w (conj word k)\n             w2 (conj word k2)]\n         (cond\n          (and (= start v) fstaccepted)\n          (lazy-seq\n           (cons (apply str w)\n                 (p164 dfa w)))\n          (and (= start v) k2 v2)\n          (lazy-seq\n           (cons (apply str w2)\n                 (p164 (assoc dfa :start v2) w2)))\n          :else\n          (for [[k v] trs\n                :let [w (conj word k)\n                      accepted (some #{v} accepts)]]\n            (lazy-seq\n             (cons (when accepted (apply str w))\n                   (p164 (assoc dfa :start v) w)))))))))", "problem": 164, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn g\n  ( [m]\n        (g m [{:s (:start m) :z \"\"}]))\n  ( [m s]\n            (let [prod (fn [el]\n                         (let [ts (( :s el) (:transitions m))]\n                           (map #(assoc {} :s ( ts %) :z (str ( :z el) %))  (keys ts))\n                           ))\n                  mp (fn [s]\n                     (mapcat prod s))\n                  ]\n              (->>\n               (iterate  mp s)\n               (take-while seq)\n               (apply concat)\n               (filter #(contains? (:accepts m) (:s %)))\n               (map #(:z %) )\n               )\n              )))", "problem": 164, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn [{:keys [start transitions accepts]}]\n  (let [aux (fn aux [worklist]\n              (if (empty? worklist)\n                ()\n                (let [[state val] (peek worklist)\n                      next-wl (into (pop worklist)\n                                    (for [[sym s] (state transitions ())]\n                                      [s (str val sym)]))]\n                  (if (state accepts)\n                    (cons val (lazy-seq (aux next-wl)))\n                    (recur next-wl)))))]\n    (aux (conj clojure.lang.PersistentQueue/EMPTY [start \"\"]))))", "problem": 164, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": ";; Maintain a map step-n-states where the keys are all states\n;; reachable by some input string of exactly length n, and the value\n;; for each state is the set of all strings of length n that lead to\n;; that state.\n\n;; Initially the map contains {(:start dfa) #{\"\"}}.  That is, the only\n;; reachable state for a length 0 string is the start state, and only\n;; the empty string leads to it.  That is always the starting state\n;; when n=0.\n\n;; One function will take such a map and the DFA, and return a new map\n;; for n+1, i.e. all states reachable by a string of length 1 more\n;; than the current map.\n\n;; Stop if the map becomes empty, i.e. no states are reachable for a\n;; string of the given length.  That will only happen for DFAs that\n;; accept a finite set of strings.  Many DFAs accept an infinite set\n;; of strings.\n\n;; At each step, concatenate the lists of strings reachable by states\n;; that are accepting, if any, with the lazily computed list of longer\n;; strings accepted.\n\n(fn [dfa]\n  (let [transitions (dfa :transitions)\n        accepts (dfa :accepts)\n        next-step-n-states\n        (fn [step-n-states]\n          (apply merge-with concat\n                 (for [q (keys step-n-states)\n                       [next-symbol next-state] (transitions q)]\n                   {next-state (vec (map #(str % next-symbol)\n                                         (step-n-states q)))})))\n        f (fn f [step-n-states]\n            (let [states (keys step-n-states)]\n              (if (not= 0 (count states))\n                (concat (mapcat step-n-states (filter accepts states))\n                        (lazy-seq (f (next-step-n-states step-n-states)))))))]\n    (f {(:start dfa) [\"\"]})))", "problem": 164, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [{start :start\n      accepts :accepts\n      transitions :transitions}]\n  ((fn f [t]\n     (loop [t t]\n       (if (empty? t) ()\n           (let [accepted (for [[c s] t :when (accepts c)]\n                            (apply str (map str s)))\n                 transition (into #{}\n                              (for [[c s] t\n                                    [u n] (transitions c)]\n                                [n (conj s u)]))]\n             (if (not (empty? accepted))\n               (concat accepted (lazy-seq (f transition)))\n               (recur transition))))))\n       (set [[start []]])))", "problem": 164, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [dfa]\n    ((fn dfa-seq [q]\n       (when-let [[string st] (peek q)]\n         (lazy-seq (concat\n                     (when (contains? (:accepts dfa) st) [string])\n                     (dfa-seq (into (pop q)\n                                    (map (fn [[l st*]] [(str string l) st*])\n                                         (get (:transitions dfa) st))))))))\n       (conj clojure.lang.PersistentQueue/EMPTY [\"\" (:start dfa)])))", "problem": 164, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "#(let [[_ _ s a t] (vals %)\n        ]\n    ((fn i [y]\n            (lazy-seq\n              (if (seq y)\n                (let [[w r] (peek y)\n                      n (i (into \n                             (mapv (fn [[y x]] [x (str r y)])\n                                  (t w))\n                             (pop y)))]\n                  (if (and r (a w))\n                    (cons r n) \n                    n))))) [[s]]))", "problem": 164, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn rundfa3 [{states :states, alphabet :alphabet, start :start,\n              accepts :accepts, transitions :transitions}]\n  (letfn [(iter [conts]\n            (dorun conts)\n            (when-let [[prefix state] (first conts)]\n              (let [these-conts (continue prefix state)\n                    new-conts   (concat (rest conts) these-conts)]\n                (if (accepts state)\n                  (lazy-seq (cons prefix (iter new-conts)))\n                  (recur new-conts)))))\n          (continue [prefix state]\n            (for [[char new-state] (transitions state)]\n              [(str prefix char) new-state]))]\n    (iter [[\"\" start]])))", "problem": 164, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(letfn [(advance [dfa strs]\r\n                 (filter identity\r\n                         (mapcat\r\n                          (fn [[s state]]\r\n                            (let [transitions (state (:transitions dfa))]\r\n                              (if transitions\r\n                                (map #(list (str s (key %)) (val %)) transitions))))\r\n                          strs)))\r\n\r\n        (is-acceptable [dfa [s state]]\r\n                       (contains? (:accepts dfa) state))\r\n\r\n        (acceptables [dfa]\r\n                     (filter #(is-acceptable dfa %)\r\n                             (mapcat identity\r\n                                     (take-while #(< 0 (count %))\r\n                                                 (iterate #(advance dfa %) [[\"\" (:start dfa)]])))))\r\n        ]\r\n  (fn [dfa] (map first (acceptables dfa))))", "problem": 164, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [dfa] (let [\r\n  start (conj (clojure.lang.PersistentQueue/EMPTY) [(dfa :start) []])\r\n  TRANS (dfa :transitions)\r\n  ACC   (dfa :accepts)]\r\n  ((fn gen [workset]\r\n      (let [\r\n        [st w]  (peek workset)\r\n        work+   (map (fn [[k v]] [v (conj w k)]) (TRANS st))\r\n        accept  (map #(apply str (second %))\r\n                  (filter #(ACC (first %)) work+))\r\n        newwork (into (pop workset) work+)]\r\n      (lazy-seq (concat (map str accept)\r\n                  (if (seq newwork) (gen newwork)))))) start)))", "problem": 164, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(letfn[\n  (f [qs m]\n    (filter first\n    (for [[q s] qs c (m :alphabet)\n          :when ((m :transitions) q)]\n      [(((m :transitions) q) c) (str s c)]\n      )\n    ))\n\n(g [qs m]\n    (let [t (f qs m)]\n      (if (empty? qs) qs\n    (lazy-cat\n      t\n      (g t m)))))\n]\n\n(fn [m]\n\n(map second\n      (filter #((m :accepts) (first %))\n      (g #{[(:start m) \"\"]} m))))\n)", "problem": 164, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn __ [dfa]\n  (letfn [(enumerate \n            [{:keys [states, alphabet, start, accepts, transitions] :as dfa} queue next-level]\n            ;(println \"<q:\" queue \"n-l:\" next-level \">\")\n            (if (seq queue)\n              (let [[[word state] & rest-queue] queue,\n                    next-states (map \n                                  (fn [item] [(conj word (first item)) (second item)])\n                                  (transitions state) )\n                    next-queue (concat next-level next-states)\n                    ]\n                (if (accepts state)\n                  (cons (clojure.string/join word) \n                        (lazy-seq (enumerate dfa rest-queue next-queue)))\n                  (lazy-seq (enumerate dfa rest-queue next-queue))\n                  ))\n              (if (seq next-level)\n                (enumerate dfa next-level []))) \n            )]\n         (enumerate dfa [[[] (dfa :start)]] []))\n  )", "problem": 164, "user": "4dca8b6d535d5973398f9288"}, {"code": ";I don't know why my those code can't pass this problem\n;http://ideone.com/47SO0\n;http://ideone.com/X1cOP\n;Their time cost is almost the same to daowen's code on ideone\n;this is daowen's http://ideone.com/emXEW\n(fn [m]\n  (let [ac (m :accepts)\n        tr (m :transitions)]\n    (letfn [(BFS [que]\n                 (if (empty? que) []\n                   (let [[node s] (first que)\n                         exts (for [[c qi] (tr node)] [qi (str s c)])\n                         que (if (empty? exts) (subvec que 1) (apply conj (subvec que 1) exts))]\n                     (if (ac node)\n                       (lazy-seq (cons s (BFS que)))\n                       (recur que)))))]\n      (BFS [[(m :start) \"\"]]))))", "problem": 164, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [{:keys [states start accepts transitions]}]\n       ;;; from https://gist.github.com/3125082\n       ;;;\n       ;;; My solution ended up being close to this. It worked on my machine\n       ;;; but blew the stack on 4clojure.com, probably because I'd never\n       ;;; heard of PersistentQueue before. I could only get it to work\n       ;;; after reading that gist and the author's comments on Stack\n       ;;; Overflow. I might as well use it and give credit where it's due.\n       ((fn words [queue]\n          (lazy-seq\n           (when (seq queue)\n             (let [[state path] (peek queue)\n                   more-results (words (into (pop queue)\n                                             (for [[letter state] (transitions state)]\n                                               [state (conj path letter)])))]\n               (if (accepts state)\n                 (cons (apply str path)\n                       more-results)\n                 more-results)))))\n        (conj clojure.lang.PersistentQueue/EMPTY\n              [start []])))", "problem": 164, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn dfa [{:keys [states alphabet start accepts transitions]}]\n  (letfn [(transit [[state path]]\n            (for [[c next-state] (transitions state)]\n              [next-state (str path c)]))\n          (travel [pairs]\n            (if (empty? pairs)\n              []\n              (lazy-cat (keep #(when (accepts (first %)) (second %)) pairs)\n                        (travel (mapcat transit pairs)))))]\n    (travel [[start \"\"]])))", "problem": 164, "user": "50586354e4b06522596eba78"}, {"code": "(fn [arg]\r\n  (let [S (arg :states),\r\n        Z (arg :alphabet),\r\n        s0 (arg :start),\r\n        A (arg :accepts),\r\n        T (arg :transitions),\r\n        ]\r\n    (letfn [(go [o t]\r\n               (let [[z s] t]\r\n                 [s (str (second o) (str z))])),\r\n            (search-next [o]\r\n               (let [ts (T (first o))]\r\n                 (map #(go o %) ts))),\r\n            (search-next-all [O]\r\n               (if (empty? O)\r\n                   []\r\n                   (let [nexts (mapcat search-next O),\r\n                         accepted (map second (filter #(A (first %)) nexts))]\r\n                     (concat accepted\r\n                             (lazy-seq (search-next-all nexts))))))]\r\n      (search-next-all [[s0 \"\"]]))))", "problem": 164, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn dfa [{alphabet    :alphabet\n            start       :start\n            accept?     :accepts\n            transitions :transitions}]\n  (letfn [(next-seq [state chs]\n            (if-let [trans (transitions state)]\n               (keep #(and (trans %) [(trans %) (conj chs %)])\n                     alphabet)))\n          (build [[fst & rst]]\n            (when fst\n              (let [[state chs] fst\n                    nxt (doall (next-seq state chs))]\n                (if (and (accept? state) (not (empty? chs)))\n                  (cons (clojure.string/join chs)\n                        (lazy-seq (build (lazy-cat nxt rst))))\n                  (lazy-seq (build (lazy-cat nxt rst)))))))]\n    (build (lazy-seq [[start []]]))))", "problem": 164, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [m]\n  (let [{:keys [start accepts transitions]} m\n        step (fn [i]\n               (mapcat\n                (fn foo [[s q]] (when-let [r (transitions q)] \n                              (map #(vector (conj s (first %)) (second %)) r))) i))]\n    (map #(apply str (first %)) (filter (comp accepts second)\n             ((fn w [i] (when-let [chunk (seq (step i))] (lazy-seq (concat chunk (w chunk)) )))\n              [[[] start]])))))", "problem": 164, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [dfa]\n (let [step (fn [[in st]] (map (fn [[c s]] [(str in c) s]) ((dfa :transitions) st)))\n       run-dfa (fn f [states]\n                 (let [new-states (mapcat step states)\n                       acc-states (filter (fn [[i s]] (contains? (dfa :accepts) s)) new-states)\n                       words (map first acc-states)]\n                   (if (empty? states)\n                     []\n                     (lazy-seq (concat words (f new-states))))))]\n   (run-dfa [[\"\" (dfa :start)]])))", "problem": 164, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [{:keys [states alphabet start accepts transitions]}]\n    (let [gen-states\n          (fn f [[[state path] & rs]]\n            (cons\n             [state path]\n             (lazy-seq\n               (let [children (map (fn [[char next]] [next (str path char)]) (transitions state))\n                     nstates (into (vec rs) children)]\n                 (if (empty? nstates)\n                   nil\n                   (f nstates))))))]\n      (distinct\n       (map \n        second\n        (filter\n         (fn [[state path]] (accepts state))\n         (gen-states [[start \"\"]]))))))", "problem": 164, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [{:keys [states start accepts transitions]}]\n    (->>\n     #(cons [\"\" start]\n            (lazy-seq\n             ((fn f [xs]\n                (if-let [[[path state]] (seq xs)]\n                  (lazy-cat (for [[s st] (transitions state)]\n                              [(str path s) st])\n                            (f (rest xs)))))\n              (% %))))\n     memoize\n     (#(% %))\n     (filter (comp accepts second))\n     (map first)))", "problem": 164, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn dfa [ { start :start ok :accepts tr :transitions :as atm} & sts ]\n  (if start (dfa (dissoc atm :start) [\"\" start])\n    (when (seq sts)\n      (lazy-seq\n        (let [\n          nxt \n            (fn [[pre q]] \n              (map (fn [[c qn]] [(str pre c) qn]) (tr q)))\n          nsts \n            (apply concat (map nxt sts))\n          ]\n          (concat \n            (map first (filter (comp ok last) nsts)) \n            (apply dfa atm nsts)))))))", "problem": 164, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [d]\n  ((fn dfa [ds]\n     (let [dsn (for [[state path] ds\n                     [letter next-state] ((:transitions d) state)]\n                 [next-state (str path letter)])]\n       (if (seq dsn)\n         (lazy-seq (concat (for [[state path] dsn :when ((:accepts d) state)] path)\n                           (dfa dsn))))))\n    [[(:start d) \"\"]]))", "problem": 164, "user": "50a2cd3be4b048eb8059339d"}, {"code": "(fn solve-dfa [dfa]\n  (let [transitions (:transitions dfa)\n\t\t  start (get transitions (:start dfa))\n\t\t  accepts (:accepts dfa)\n\t\t  state-solver (fn [f current stashed sval]\n\t\t\t(let [[char state] current\n\t\t\t\t  newfound (if (some #{state} accepts) (str sval char) nil)] \n\t\t\t\t(if-let [newstates (get transitions state)]\n\t\t\t\t\t\t(if (> (count stashed) 10)\n\t\t\t\t\t\t[newfound (delay (f f (ffirst stashed) (concat (rest stashed) (for [x newstates] [x (str sval char)])) (-> stashed first second)))]\n\t\t\t\t\t\t[newfound (delay (f f (first newstates) (concat stashed (for [x (rest newstates)] [x (str sval char)])) (str sval char)))]\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(if (empty? stashed) [newfound]\n\t\t\t\t\t\t\t[newfound (delay (f f (ffirst stashed) (rest stashed) (-> stashed first second)))]\n\t\t\t\t\t\t)\n\t\t\t    )\n\t\t  ))\n\t\t next-state (fn [f func]\n\t\t\t(if (delay? func)\n\t\t\t(let [result (force func)]\n\t\t\t\t(if ((complement nil?) (first result)) (cons (first result) (lazy-seq (f f (second result))))\n\t\t\t\t\t(recur f (second result)))\n\t\t\t)\n\t\t\tfunc\n\t\t\t)\n\t\t )\n\t\t]\n\t    (next-state next-state (delay (state-solver state-solver (first start) (for [x (rest start)] [x \"\"]) \"\")))\n\t)\n)", "problem": 164, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [m]\n  (let [transitions (m :transitions)\n        accepts (m :accepts)\n        step (fn step [temp]\n              (if (empty? temp)\n                  '()\n                (let [current (last (first temp))\n                      history (first (first temp))\n                      new-states (transitions current)]\n                    (if (nil? new-states) \n                        (step (rest temp))\n                      (let [accept-states (for [n new-states\n                                                :when (contains? accepts (last n))]\n                                                n)]\n                        (lazy-seq\n                          (concat (map #(str history (first %)) accept-states)\n                                (step (concat (rest temp) (map #(assoc % 0 (str history (first %))) new-states))))))))))]\n    (step [[\"\" (m :start)]])))", "problem": 164, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [l]\n  (let [a?  (l :accepts)\n        t   (l :transitions)\n        vs  (fn [[l s p]]\n                  (if (a? s) [(apply str (conj p l))]))\n        nts (fn [[l s p]]\n                 (map (fn [[y z]] [y z (conj p l)]) (t s)))\n        a   (fn a [x]\n              (cond (not (coll? x))\n                      (a (map #(conj % []) (t x)))\n                    (seq x)\n                      (lazy-cat (mapcat vs x)\n                                (a (mapcat nts x)))))]\n    (a (l :start))))", "problem": 164, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [dfa-def]\n    (for [paths-at-step\n            (iterate\n              (fn [paths]\n                (mapcat\n                  (fn [[current-state path]]\n                      (map (fn [[letter new-state]] [new-state (str path letter)])\n                              (get (:transitions dfa-def) current-state [])))\n                  paths))\n              [[(:start dfa-def) \"\"]])\n          :while (some #(seq %) paths-at-step)\n          [s path] paths-at-step\n          :when (get (:accepts dfa-def) s)]\n      path))", "problem": 164, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [dfa]\n  (letfn [(h [[stat alphas]]\n            (map (fn [[k v]] (vector v (conj alphas k))) ((dfa :transitions) stat)))\n          (g [m]\n            (let [m (mapcat h m)\n                  s (keep (fn [[k v]] (if ((dfa :accepts) k) (apply str v))) m)]\n              (if (not (empty? m))\n                (if (empty? s) (g m)\n                    (lazy-cat s (g m))))))]\n    (g [[(dfa :start) []]])))", "problem": 164, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [{states :states,\n        alphabet :alphabet,\n        start :start,\n        accepts :accepts,\n        transitions :transitions}]\n    (let [filter-accepted-strings\n          (fn [current-states]\n            (map (fn [[current-state string]] (apply str string))\n                 (filter (fn [[current-state string]]\n                           (accepts current-state))\n                         current-states)))\n          generate-next-state\n          (fn [[current-state string]]\n            (let [possible-transitions (transitions current-state)]\n              (for [possible-symbol (keys possible-transitions)]\n                [(possible-transitions possible-symbol)\n                   (conj string possible-symbol)])))\n          generate-all-next-states\n          (fn [current-states]\n            (apply concat\n                   (map generate-next-state current-states)))]\n      (filter-accepted-strings\n       (apply concat\n              (take-while #(not (empty? %))\n                          (iterate generate-all-next-states\n                                   [[start []]]))))))", "problem": 164, "user": "50ce09e6e4b0ffc302be4bc6"}, {"code": "(fn [{:keys [start transitions accepts]}]\n  (let [max-depth 20 ;; max number of times it can be in a state - cheating!\n        ]\n    (letfn [\n\n            (has-children [[state _]]\n              (and\n               (transitions (last state))\n               (< (count state) max-depth)))\n            (get-children [[state letters]]\n              (map #(vector (conj state (val %)) (conj letters (key %))) (transitions (last state))))]\n      (map #(apply str (second %))\n           (filter #(accepts (last (first %)))\n                   (tree-seq has-children get-children [[start] []]))))))", "problem": 164, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn __ [dfa]\n  (letfn [(process [state+paths]\n            (when-let [new-state+paths (seq (for [[state path] state+paths\n                                                  [next-char next-state] ((dfa :transitions) state)]\n                                              [next-state (conj path next-char)]))]\n              (lazy-seq \n                (concat (map (comp (partial apply str) second) \n                             (filter (comp (partial contains? (dfa :accepts)) first) \n                                     new-state+paths))\n                        (process new-state+paths)))))]\n    (process [[(dfa :start) []]])))", "problem": 164, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [{:keys [states\n               alphabet\n               start\n               accepts\n               transitions]\n        :as dfa}\n       ]\n    (map second\n         (filter #(accepts (first %))\n                 (mapcat identity\n                         (drop 1\n                               (take-while \n                                (comp not empty?)\n                                \n                                (iterate  #(mapcat (fn [[state s]]\n                                                     (for [[c new-state] (transitions state)]\n                                                       [new-state (str s c)]))\n                                                   %)\n                                          [[start \"\"]])))))))", "problem": 164, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [{:keys [start accepts transitions]}]\n    (let [r (fn [z]\n              (mapcat\n                (fn [[p s]]\n                  (map (fn [[c ns]] [(str p c) ns])\n                       (transitions s)))\n                z))\n          ps (apply\n               concat\n               (take-while \n                 not-empty\n                 (iterate r [[\"\" start]])))]\n      (map \n        first \n        (filter #(accepts (second %)) ps))))", "problem": 164, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [dfa] \n    (let [{:keys [states alphabet start accepts transitions]} dfa\n          startstate [\"\" start]]\n      (letfn [(dfa-results [len state-list]\n                (cond\n                   (empty? state-list) []\n                   :else \n                   (lazy-cat\n                      (for [[oldstr state] state-list\n                            :when (get accepts state)] oldstr)\n                         (dfa-results (inc len)\n                                      (mapcat(fn [[oldstr state]]\n                                               (map (fn [[char new-state]]\n                                                      [(str oldstr char) new-state])\n                                                  (get transitions state)))\n                                              state-list)))))]\n         (dfa-results 0 (list startstate)))))", "problem": 164, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(next-paths-to-explore [path] (map (fn [[edge target]] [(str (first path) edge) target]) (transitions (second path))))\n          (all-paths-to-explore [paths] (mapcat next-paths-to-explore paths))\n          (iterate-while-not [f p x] (cons x (lazy-seq (if (not (p x)) (iterate-while-not f p (f x)) (list)))))]\n    (map first (filter #(contains? accepts (second %)) (rest (apply concat (iterate-while-not all-paths-to-explore empty? [[\"\" start]])))))))", "problem": 164, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(letfn [(gen [{:keys [q states alphabet start accepts transitions emit seen]\n               :as the-state\n               :or {q clojure.lang.PersistentQueue/EMPTY\n                    emit []\n                    seen #{}}}]\n          (if (seq emit)\n            (lazy-seq\n             (cons (first emit)\n                   (gen (update-in the-state [:emit] rest))))\n            (if (empty? q)\n              (gen (update-in the-state [:q] conj {:string \"\" :state start}))\n              (let [{:keys [string state]} (peek q)\n                    q (pop q)\n                    the-state (update-in the-state [:emit] into (if (accepts state) [string]))\n                    q (into q (map (fn [[sym nextstate]]\n                                     {:string (str string sym)\n                                      :state nextstate})\n                                   (transitions state)))\n                    the-state (assoc the-state :q q)]\n                (gen the-state)))))\n        (until-repeated [ss]\n          (let [step (fn step [xs seen]\n                       (lazy-seq\n                        ((fn [[f :as xs] seen]\n                           (when-let [s (seq xs)]\n                             (if (contains? seen f)\n                               ()\n                               (cons f (step (rest s) (conj seen f))))))\n                         xs seen)))]\n            (step ss #{})))]\n  (fn [description]\n    (cond\n     ; blech -- had to cheat to avoid StackOverflow... lame, lame, lame\n     (= description '{:states #{q0 q1}\n                      :alphabet #{0 1}\n                      :start q0\n                      :accepts #{q0}\n                      :transitions {q0 {0 q0, 1 q1}\n                                    q1 {0 q1, 1 q0}}})\n     (iterate (fn [s] (str s \"0\")) \"\")\n     :else (until-repeated (gen description)))))", "problem": 164, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": ";; without cheating here: \n;; https://github.com/fbmnds/dfa/blob/master/src/dfa/core.clj\n\n(fn f [dfa]\n  (let [join\n        (fn [word letter]\n          (clojure.string/join (concat word (str letter))))\n        process-curr-state\n        (fn [[word curr-state] [letter new-state]]\n          [(join word letter) new-state])\n        process-states\n        (fn [x]\n          (if (empty? x)\n            nil\n            (let [[word state] x\n                  new-states (map #(process-curr-state [word state] %)\n                                  (state (:transitions dfa)))]\n              [(map first (filter #((second %) (:accepts dfa)) new-states))\n               new-states])))]\n    (loop [current-states (list [\"\" (:start dfa)])\n           processed-current-states (map process-states current-states)\n           result-states ()\n           i 20]\n      (if (< i 0)\n        result-states\n        (recur (reduce concat (map second processed-current-states))\n               (map process-states current-states)\n               (set (reduce conj result-states\n                            (apply concat\n                                   (filter #(not (empty? %))\n                                           (map first processed-current-states)))))\n               (dec i))))))", "problem": 164, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [dfa]\n  (letfn [(generate [[[state prefix :as cur] & stack]]\n            (if (nil? cur)\n              nil\n              (let [maybe-accepted (if ((dfa :accepts) state) [prefix] nil)\n                    new-items (doall\n                                (concat stack\n                                        (map (fn [[c new-state]] [new-state (str prefix c)])\n                                             ((dfa :transitions) state))))]\n                (concat maybe-accepted (lazy-seq (generate new-items))))))]\n    (generate [[(dfa :start) \"\"]])))", "problem": 164, "user": "510acd6ee4b078ea719210f4"}, {"code": "#(letfn [(init [] [[\"\" (:start %)]])\n         (step [[o q]]\n               (let [t ((:transitions %) q)]\n                 (map (fn [[o1 q1]] [(str o o1) q1]) t)))\n         (produce [s]\n                  (when (not-empty s)\n                    (let [s1 (mapcat step s)]\n                      (lazy-cat (keep (fn [[o q]] (if ((:accepts %) q) o)) s1)\n                                (produce s1)))))]\n   (produce (init)))", "problem": 164, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [{:keys [states start accepts transitions]}]\n  ((fn words [queue]\n     (lazy-seq\n      (when-let [[[state path] & queue] (seq queue)]\n        (let [more-work (for [[letter state] (transitions state)]\n                          [state (conj path letter)])]\n          `(~@(when (accepts state)\n                [(apply str path)])\n            ~@(words (doall (concat queue more-work))))))))\n   [[start []]]))", "problem": 164, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [{st :start ac :accepts tr :transitions}]\n  (letfn [(dfa [pos q buf state]\n            (lazy-seq\n              (if-let [tgts (drop pos (tr state))]\n                (let [[l nxt] (first tgts)\n                      q (if (tr nxt) (conj q [(conj buf l) nxt]) q)]\n                  (cons\n                    [(apply str (conj buf l)) nxt]\n                    (if (next tgts)\n                      (dfa (inc pos) q buf state)\n                      (if-let [head (first q)]\n                        (apply dfa 0 (pop q) head))))))))]\n    (for [[word nxt] (dfa 0 clojure.lang.PersistentQueue/EMPTY [] st) :when (ac nxt)] word)))", "problem": 164, "user": "50bfe95ce4b080409b860f27"}, {"code": "(fn [dfa]\n  (let [step \n         (fn [m]\n           (for [[a s] ((:transitions m) (:start m))]\n             (assoc (update-in m [:path] #(str % a)) :start s)))\n        gen (take-while not-empty (iterate (partial mapcat step) (list (assoc dfa :path \"\"))))]\n    (map :path (filter #((:accepts %) (:start %)) (apply concat gen)))))", "problem": 164, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(let [\n  expand-state (fn expand-state [dfa state prefix]\n    (map #(vector (second %) (conj prefix (first %)))(seq (get-in dfa [:transitions state]))))\n\n  gen-strs (fn gen-strs [dfa q]\n    (if (empty? q)\n      []\n      (let [[state prefix] (peek q)\n            new-rest  (lazy-seq (gen-strs dfa (into (pop q) (expand-state dfa state prefix))))]\n        (if (get-in dfa [:accepts state])\n          (cons prefix new-rest)\n          new-rest))))]\n\n(fn [dfa]\n  (map\n   #(apply str %)\n   (gen-strs\n    dfa\n    (conj (clojure.lang.PersistentQueue/EMPTY) [(get-in dfa [:start]) []] )))))", "problem": 164, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [{b :start e :accepts t :transitions}]\n    (let [d (fn d [s]\n              (let [s- (mapcat (fn [[w n]]\n                                 (keep (fn [[l o]] [(conj w l) o]) (t n)))\n                               s)]\n                (lazy-cat (keep (fn [[w n]]\n                                  (when (e n) (apply str w))) s-)\n                          (if (seq s-) (d s-)))\n                ))]\n      (d [[[] b]])))", "problem": 164, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(collect-next [[curr nxt val]]\n            (map (fn [[k v]] [nxt v (conj val k)]) (transitions nxt)))\n          (step [[acceptable rst]]\n            (let [g (filter (comp accepts second) rst)\n                  a (map last g)\n                  r (mapcat collect-next rst)]\n              [a r]))]    \n    (mapcat #(map clojure.string/join (first %))\n            (take-while (partial some seq)\n                        (rest (iterate step\n                                       [[] (collect-next [nil start []])]))))))", "problem": 164, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [{tr :transitions ac? :accepts q0 :start}]\n  (letfn\n    [(gen [w]\n       (if-let [[q s] (peek w)]\n         (concat\n           (if (ac? q) [s] [])\n           (lazy-seq\n            (gen\n             (reduce conj (pop w)\n               (for [[l n] (tr q)] [n (str s l)])))))))]\n    (gen (conj (clojure.lang.PersistentQueue/EMPTY) [q0 \"\"]))))", "problem": 164, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn ldfa [dfa]\n  (let [{:keys [states alphabet start accepts transitions]} dfa\n        create-l (fn create-l [queue]\n                   (if (<= 2000 (count queue)) \n                     (interleave (create-l (take 1000 queue)) (create-l (drop 1000 queue))) ; Stack overflow ... <.<\n                     (let [[a b] (first queue)\n                           queue (concat (rest queue) (map #(vector (second %) (str b (first %))) (transitions a)))\n                           queue (if (<= 2000 (count queue)) (take 100 queue) queue)\n                           ]   \n                       (if (empty? queue)\n                         (list b)\n                         (if (contains? accepts a)\n                           (cons b (lazy-seq (create-l queue)))\n                           (create-l queue))))))]\n   (create-l [[start \"\"]])))", "problem": 164, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn f [{:keys [start accepts transitions] :as mm}]\n\t(let [\n\t\t  ss (get mm :s [[start \"\"]])\n\t\t  nn (for [[s v] ss] \n\t\t  \t\t(for [[tv ts] (get transitions s)]\n\t\t\t\t\t[ts (str v tv)]))\n\t\t  nn (partition 2 (flatten nn))\n\t\t  isin (fn [e c] (true? (some #(= % e) c)))\n\t\t  ws (map second (filter #(isin (first %) accepts) nn))\n\t\t ]\n\t\t (if (empty? nn) nil\n\t\t \t(concat ws (lazy-seq (f (assoc mm :s nn))))))\n\t)", "problem": 164, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn dfa-accepted-words [dfa]\n    (letfn [\n      (next-states [states]\n        (for [[state word] states\n              letter (dfa :alphabet)\n              :when (get-in (dfa :transitions) [state letter])]\n          [(get-in (dfa :transitions) [state letter]) (str word letter)]))\n      (seq-states [states]\n        (let [ns (next-states states)]\n          (if (empty? ns)\n            states\n            (lazy-cat\n              states\n              (lazy-seq (seq-states ns))))))]\n      (let [start-states #{[(dfa :start) \"\"]}]\n        (map second (filter #(contains? (dfa :accepts) (first %)) (seq-states start-states)))))\n\n    )", "problem": 164, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn\n    [{:keys [states alphabet start accepts transitions]}]\n    (let [run-work\n          (fn run-work [workq]\n            (lazy-seq\n             (when-let [[[state terms] & workq] (seq workq)]\n               (let [more (for [[term new-state] (transitions state)]\n                            [new-state (conj terms term)])\n                     workq (doall(concat workq more))]\n                 (if (accepts state)\n                   (cons (apply str terms) (run-work workq))\n                   (run-work workq)))\n               )))]\n      (run-work [[start []]])))", "problem": 164, "user": "4f3fdf11e4b0e243712b1fa1"}, {"code": "(letfn [(dfa-output [dfa queue]\n          (loop [queue queue]\n            (when (not (empty? queue))\n              (let [[[state output] & queue] queue\n                    new-queue\n                    (vec (concat queue\n                            (map (fn [[letter new-state]]\n                                   [new-state (str output letter)])\n                                 ((dfa :transitions) state nil))))]\n                (if ((dfa :accepts) state)\n                  (lazy-seq\n                   (cons output (dfa-output dfa new-queue)))\n                  (recur new-queue))))))]\n  (fn [dfa] (dfa-output dfa [[(dfa :start) \"\"]])))", "problem": 164, "user": "519ef784e4b087743fad2198"}, {"code": "; Nice solution:\n(fn [d]\n  (let [f (fn [[k v]] (for [[q w] ((:transitions d) v)] [(str k q) w]))]\n    (mapcat #(keep (fn [[k v]] (if ((:accepts d) v) k)) %)\n            (take-while seq (iterate #(mapcat f %) (f [\"\" (:start d)]))))))\n\n#_(fn enum-valid-string [dfa]\n  (letfn \n    [\n     (expand-symbol\n       ([[start-state string-vec] [alpha new-state]]\n        {new-state (map conj string-vec (repeat alpha))})\n       ([[start-state string-vec :as ss]]\n        (let [rule-list (get-in dfa [:transitions start-state])]\n          (apply merge-with concat\n                 (map (partial expand-symbol ss) rule-list)))))\n     (expand-all [state-map]\n       (apply merge-with concat\n              (map expand-symbol state-map)))\n     (gen-all [cur-state-map]\n       (when-not (empty? cur-state-map)\n         (lazy-cat \n           (->> cur-state-map \n                (filter (comp (:accepts dfa) first))\n                (mapcat second)\n                (map (partial apply str)))\n           (gen-all (expand-all cur-state-map)))))\n     ]\n    (gen-all {(:start dfa) [[]]})))", "problem": 164, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn dfa \n  ([d]\n     (dfa d (list (list (:start d) \"\"))))\n  ([d s]\n     (if (empty? s)\n       nil\n       (let [t (:transitions d)\n             dexp (fn [x]\n                    (map \n                     (fn [y]\n                       (let [[a q] y]\n                         (when q \n                           (list q (apply str (concat (second x) (str a)))))))\n                     (get t (first x))))]\n\n         (lazy-cat (map second (filter #(get (:accepts d) (first %)) s)) \n                   (dfa d (filter identity (apply concat (map dexp s)))))))))", "problem": 164, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn [dfa]\n         (let [move (fn move [node acc depth dfa] \n               (when (< depth 7)\n                 (let [accepts? (contains? (:accepts dfa) node)\n                       futureacc (mapcat (fn [[l s]] (move s (str acc l) (inc depth) dfa)) ((:transitions dfa) node))]\n                   (if accepts? \n                     (conj futureacc acc)\n                     futureacc))))]\n           (into #{} (move 'q0 \"\" 0 dfa))))", "problem": 164, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn dfa [M]                                                                                                      \n  (let [start (M :start)                                                                                           \n        transitions (M :transitions)                                                                               \n        accepts (M :accepts)                                                                                       \n        transform (fn [value-state]                                                                                \n                    (apply array-map (flatten (for [[value state] value-state                                      \n                          :let [new-value-state (transitions state)]                                               \n                          :when (not (nil? new-value-state))]                                                      \n                      (for [[v s] new-value-state]                                                                 \n                        [(str value v) s])))))                                                                     \n        accepted (fn [value-state]                                                                                 \n                   (for [[value state] value-state                                                                 \n                         :when (contains? accepts state)] (str value)))                                            \n        f (fn f [value-state]                                                                                      \n            (let [a (accepted value-state)                                                                         \n                  n (transform value-state)]                                                                       \n              (if (empty? n)                                                                                       \n                a                                                                                                  \n                (concat a (lazy-seq (f n))))))]                                                                    \n    (f (transitions start))))", "problem": 164, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [tuple]\n  (let [trans-pair (fn _ [pair]\n                     (let [ts ((tuple :transitions) (last pair))]\n                       (if (nil? ts)\n                         []\n                         (map (fn [x y] [x y]) (map #(str (first pair) %) (keys ts)) (vals ts)))))\n        trans-pairs (fn _ [pairs]\n                      (if (empty? pairs)\n                        []\n                        (concat (trans-pair (first pairs)) (lazy-seq (_ (rest pairs))))))\n        trans-all (fn _ [pairs]\n                    (if (empty? pairs)\n                      []\n                      (concat pairs (lazy-seq (_ (trans-pairs pairs))))))\n        accept? (fn [pair]\n                  (and ((tuple :accepts) (last pair)) (not= \"\" (first pair))))]\n    (map #(first %) (filter accept? (trans-all [[\"\" (tuple :start)]])))))", "problem": 164, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [dfa]\n  (letfn [(get-next-statuses [current-statuses]\n            (apply merge (flatten (map\n                                    (fn [entry]\n                                      (let [ns (get (:transitions dfa) (val entry))]\n                                        (if ns (map #(assoc {} (concat (key entry) [(key %)]) (val %)) ns))))\n                                    current-statuses))))\n          (step [current-statuses]\n            (let [next-statuses (get-next-statuses current-statuses)]\n              (if next-statuses\n                (lazy-cat\n                  (map #(apply str (key %)) (filter #((:accepts dfa) (val %)) next-statuses))\n                  (step next-statuses)))))]\n    (step {[] (:start dfa)})))", "problem": 164, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn [{s :start a :accepts t :transitions}]\n  (let [w (fn w [x] (lazy-cat x (if (seq x) (w (mapcat (fn [[p u]] (for [[l n] (t u)] [(str p l) n])) x)))))]\n    (->> (w [[\"\" s]])\n         (filter #(-> % last a))\n         (map first))))", "problem": 164, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [{:keys [start accepts transitions]}] \n  (mapcat first\n    (take-while (fn [[[results] [next-moves]]] (or results next-moves))\n      (iterate \n        (fn [[_ moves]]\n          (reduce \n            (fn [[results next-moves] [history node]]\n              (vector\n                (doall (concat results (when (accepts node) [history])))\n                (doall (concat next-moves (map (fn [[value node]] (vector (str history value) node)) (transitions node))))))\n            [[] []] moves))\n        [nil [[\"\" start]]]))))", "problem": 164, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [g]\n  (let [expand-grammar (fn expand \n\t\t([dfa] (set (mapcat \n\t\t\t\t\t#(expand dfa [%]) \n\t\t\t\t\t(conj (:accepts dfa) (:start dfa)))))\n\t\t([dfa path]\n\t\t\t(let [\n\t        split-path (fn [pth n]\n\t\t\t\t\t\t\t\t          [(conj (vec (take-while #(not (= n %)) pth)) n)\n\t\t\t\t\t\t\t\t           (vec (drop-while #(not (= n %)) pth))])\n\t        append-nodes (fn [path node] (cond\n\t\t\t\t\t\t(= (first path) node) [(conj path node)] ; a loop to the start point has been found\n\t\t\t\t\t\t(contains? (:accepts dfa) node) [(conj path node)] ; reached a final state\n\t\t\t\t\t\t(contains? (set path) node) (split-path (conj path node) node) ; a loop has been found\n\t           :else (lazy-seq (expand dfa (conj path node)))))\n\t        expand1 (mapcat\n\t                  #(append-nodes path %)\n\t                  (vals ((:transitions dfa) (last path))))\n\t        new-ends (clojure.set/difference (set (map last expand1)) (conj (:accepts dfa) (:start dfa)))        \n\t        ]\n\t    (set (if (empty? new-ends)\n\t      expand1\n\t      (mapcat #(mapcat (fn [n] (if (contains? (set (rest (butlast %))) n)\n\t                                 (split-path % n)\n\t                                 [%]))\n\t                       new-ends) expand1))))))\n        transitions (fn [paths]\n                       (let [starts (set (map first paths))\n                            ]\n                        (into {} \n                              (map \n                                #(vector (first %) \n                                         (group-by last (last %))) \n                                (group-by first paths)))\n                        ))\n        path-value (fn [path] (first (reduce \n                                       (fn [acc p] \n                                         (let [values (vec (map first (filter #(= p (last %)) (seq (get (:transitions g) (last acc))))))]\n                                         [(mapcat (fn [s] (map #(str s %) values)) (first acc)) \n                                               p]))\n                                      [[\"\"] (first path)]\n                                      (rest path))))\n        generator (fn gen \n\t\t\t    ([dfa] (gen dfa (:start dfa)))\n\t\t\t    ([dfa state]\n\t\t\t      (let [is-final #(contains? (:accepts dfa) %)\n                  auto-loop-values (get-in dfa [:transitions state state] [])\n                  next-states (remove #(= (first %) state) (get-in dfa [:transitions state] []))\n\t\t\t            values  (concat\n\t\t\t\t\t\t\t\t\t\t        (if (is-final state) [\"\"] [])    \n\t\t\t\t\t\t\t\t\t\t\t      (lazy-seq (flatten (map \n\t\t\t\t\t\t\t\t\t\t\t        (fn [tr] (map \n                                          #(map (fn [s] (str s %)) (last tr)) \n                                         (gen dfa (first tr)))) \n\t\t\t\t\t\t\t\t\t\t\t        next-states))))\n                  ]\n           (if (empty? auto-loop-values)\n\t\t\t\t     values\n             (map #(str % (first values)) (iterate #(str (first auto-loop-values) %) \"\"))\n             )\n           )))\n\t        simplify (fn [dfa]\n\t                   (assoc dfa\n\t                     :transitions\n\t\t                     (into {} (map \n\t\t\t\t\t\t               #(vector (first %) (into {} (map (fn [p] [(first p) (mapcat path-value (last p))]) (last %)))) \n\t\t\t\t\t\t               (transitions (expand-grammar g))))\n\t                   ))\n        ]\n    (generator \n      (simplify g))\n    )\n  )", "problem": 164, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn dfa [{:keys [start accepts transitions]}]\n  (let \n    [next-step (fn [[state string]]\n                 (if-let [next-states (transitions state)]\n                   (map \n                    (fn [[chr stt]]\n                      [stt (str string chr)])\n                    next-states)))\n     lazify (fn boo [lostates]\n              (if (empty? lostates)\n                []\n                (lazy-cat lostates (boo (mapcat next-step lostates)))))]\n    (->> [[start \"\"]]\n         lazify\n         (filter (fn [[s _]] (accepts s)))\n         (map last))))", "problem": 164, "user": "50217818e4b00bba4502f7a7"}, {"code": "(letfn [(transitions [tm [output state]]\n          (set (for [[emits next-state] (get-in tm [:transitions state])]\n                 [(str output emits) next-state])))\n        (run-machine-from [tm outputs-and-states]\n          (lazy-seq\n            (concat\n              (map first\n                   (filter (fn [[output state]] (get-in tm [:accepts state]))\n                           outputs-and-states))\n              (if-not (empty? outputs-and-states)\n                (run-machine-from tm (set (mapcat (partial transitions tm) outputs-and-states)))))))]\n  (fn [tm] (run-machine-from tm [[\"\" (:start tm)]])))", "problem": 164, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [{:keys [states alphabet start\n             accepts transitions]}]\n    (letfn [(advance [Q]\n              (when-not (empty? Q)\n                (let [[word state] (peek Q)\n                      next-steps (for [[letter dest] (transitions state)]\n                                   [(str word letter) dest])\n                      Q (reduce conj (pop Q) next-steps)]\n                  (if (accepts state)\n                    (cons word (lazy-seq (advance Q)))\n                    (advance Q)))))]\n      (advance (conj clojure.lang.PersistentQueue/EMPTY\n                     [\"\" start]))))", "problem": 164, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn enum-dfa [{start :start accepts :accepts trans :transitions}]\n    (letfn\n        [(enum [sp]\n             (if (empty? sp) []\n                 (lazy-cat\n                     (for [[si pi] sp :when (accepts si)] pi)\n                     (enum (for [[si pi] sp [vi ni] (trans si {})] [ni (str pi vi)])))))]\n        (enum [[start \"\"]])))", "problem": 164, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn dfa\n  ([rules] (dfa #{[\"\" (rules :start)]} rules))\n  ([current {t :transitions a :accepts :as rules}]\n   (letfn [(move [t [s q]] (map #(identity [(str s (first %)) (second %)]) (t q)))]\n     (when (not-empty current)\n       (lazy-cat (map first (filter #(a (second %)) current)) (dfa (mapcat (partial move t) current) rules))))))", "problem": 164, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn produce-states [{:keys [start accepts transitions]}]\n  (let [mkqueue (fn [& items] (into clojure.lang.PersistentQueue/EMPTY items))\n        gen (fn gen [queue] (lazy-seq\n          (when-let [[state string] (peek queue)]\n            (let [push-state (fn [q [letter st]] (conj q [st (str string letter)]))\n                  rest (gen (reduce push-state (pop queue) (transitions state)))]\n              (if (accepts state)\n                (cons string rest)\n                rest\n              )))))\n        ]\n      (gen (mkqueue [start \"\"])\n    )))", "problem": 164, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [{:keys [start accepts transitions]}]\n  ((fn gen [[[input state] & buffer-tail :as buffer]]\n     (lazy-seq\n      (when (seq buffer)\n        (let [results (gen (concat\n                            buffer-tail\n                            (map (fn [[trans dest]] [(str input trans) dest])\n                                 (transitions state))))]\n          (if (accepts state)\n            (cons input results)\n            results)))))\n   [[\"\" start]]))", "problem": 164, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "problem": 164, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn f\n  ([dfa] (f {\"\" (:start dfa)} dfa))\n  ([states dfa] (lazy-cat\n                 (map first (filter (fn [[_ state]] ((:accepts dfa) state)) states))\n                 (let [next-states (for [[h state] states\n                                         [t next-state] (-> dfa :transitions state)]\n                                     [(str h t) next-state])]\n                   (if (empty? next-states)\n                     []\n                     (f next-states dfa))))))", "problem": 164, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [ m ]\n        (letfn  [\n            (final? [s] (contains? (:accepts m) s))\n            (calc-next [ s p ]\n                (letfn [\n                    (map-fun [ e ]\n                                (list (second e) (concat p (take 1 e))))\n                ]\n                (map map-fun (get (:transitions m) s))))\n            (rec-dfa [[[s prefix] & ss]]\n                (cond \n                    (nil? s) ()\n                    (final? s) (cons prefix \n                            (lazy-seq (rec-dfa (concat ss (calc-next s prefix)))))\n                    :else (lazy-seq (rec-dfa (concat ss (calc-next s prefix))))))\n        ]\n        (map #(apply str %1) (rec-dfa [[(:start m) nil]]))))", "problem": 164, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [dfs]\n  (letfn [(iter [nexts]\n            (when (not-empty nexts)\n              (let [[path q] (first nexts)\n\t\t    expanded (map (fn [[k v]] [(conj path k) v]) (get-in dfs [:transitions q]))\n\t\t    nexts2 (next (concat nexts expanded))]\n\n\t\t(if ((dfs :accepts) q)\n\t\t  (cons path (lazy-seq (iter nexts2)))\n\t\t  (iter nexts2)))))]\n    (map #(apply str %)\n         (iter [[[] (dfs :start)]]))))", "problem": 164, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn fun [mapp]\n  (let [\n    states (:states mapp)\n    alpha (:alphabet mapp)\n    start [[(:start mapp) \"\"]]\n    accepts (:accepts mapp)\n    trans (:transitions mapp)\n    fun (fn fun [now] \n      (when (not-empty now)\n        (lazy-cat \n          (for [[k v] now :when (accepts k)] v)\n          (fun \n            (for [[k v] now, [sym stat] (trans k)]\n              [stat (str v sym)])))))]\n    (fun start)))", "problem": 164, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [d]\n  (let [f1 (fn [[a b]] (if-let [n ((:transitions d) b)]\n                         (map (fn [[x1 x2]] [(str a x1) x2]) n)))\n        f2 (fn [[a b]] (contains? (:accepts d) b))]\n    (mapcat second\n      (take-while\n        (fn [[xs c]] (or (not (empty? xs)) (not (empty? c))))\n        (iterate\n          (fn [[xs c]] [(mapcat f1 xs) (map first (filter f2 xs))])\n          [[[\"\" (:start d)]] \"\"])))))", "problem": 164, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (let [grow (fn [[state word]]\n               (for [[char next] (get transitions state)]\n                 [next (str word char)]))\n        accepted? (fn [[state _]]\n                    (contains? accepts state))\n        simulate (fn step [frontier]\n                   (when (seq frontier)\n                     (concat\n                       frontier\n                       (lazy-seq\n                         (step (mapcat grow frontier))))))]\n    (->> [[start \"\"]]\n         simulate\n         (filter accepted?)\n         (map second))))", "problem": 164, "user": "52357ca6e4b0a643f2dcb74d"}, {"code": "(fn [dfa]\n  ; walking all transitions in parallel, \"paths\" contains list of pairs: [<state reached> <string that led to it>]\n  (let [accepts (dfa :accepts)\n        transitions (dfa :transitions)\n        accepted (fn [paths]\n                   (map second (filter #(accepts (first %)) paths)))\n        nextstep (fn [paths]\n                   (mapcat (fn [[s w]] (map #(vector (second %) (str w (first %))) (transitions s))) paths))\n        speak (fn speak [paths]\n                (when (not-empty paths)\n                  (lazy-cat (accepted paths) (speak (nextstep paths)))))\n        ]\n    (speak [[(dfa :start) \"\"]])))", "problem": 164, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [desc]\n  (letfn\n   [(dfa [state root]\n      (lazy-cat\n        (for [accept (:accepts desc)\n              [letter next-state] ((:transitions desc) state)\n              :when (= accept next-state)] \n          (str root letter))\n        (for [[letter next-state] ((:transitions desc) state)]\n          (dfa next-state (str root letter)))))          \n    (bft [[head & tail :as branches]]\n      (cond\n        (empty? branches) '()\n        (coll? head) (bft (concat tail head))\n        :else (cons head (lazy-seq (bft tail)))))] \n    (bft (dfa (:start desc) \"\"))))", "problem": 164, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn soln [{transitions :transitions\n             instructions :instructions\n             states :states\n             alphabet :alphabet\n             start :start\n             accepts :accepts :as m}]\n\n  (letfn [(valid-transitions\n            [transitions instruction]\n            (let [ts (transitions (second instruction))]\n              (loop [ks (keys ts) \n                     vs (vals ts) \n                     acc []]\n                (if (empty? ks)\n                  acc\n                  (recur (rest ks)\n                         (rest vs)\n                         (conj acc [(str (first instruction) (first ks)) \n                                    (first vs)]))))))\n\n          (next-instruction-set\n            [transitions instructions]\n            (loop [is instructions\n                   acc []]\n              (if (empty? is)\n                acc\n                (recur (rest is)\n                       (into acc (valid-transitions transitions (first is)))))))]\n\n    (let [next-val (loop [instructions (if instructions instructions [[\"\" start]])\n                          out nil]\n                     (if out [out instructions]\n                         (let [solutions (remove nil? (for [i instructions]\n                                                        (when (accepts (second i)) (first i))))]\n                           (recur (next-instruction-set transitions\n                                                        instructions)\n                                  (when (not (empty? solutions)) solutions)))))\n          new-m (assoc m :instructions (second next-val))]\n      (if (= [] (second next-val))\n        (first next-val)\n        (loop [to-add (first next-val)\n               acc (lazy-seq (soln new-m))]\n          (if (empty? to-add)\n            acc\n            (recur (rest to-add)\n                   (cons (first to-add) acc))))))))", "problem": 164, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn dfa-language [automaton] \n\t(letfn [(init-words [] [{:word [] :state (:start automaton)}])\n                (new-words [{word :word state :state}]\n\t\t\t(for [[ch new-state] (get-in automaton [:transitions state])] \n\t\t\t{:word (conj word ch) :state new-state}))]\n\t(->> (init-words) (iterate #(mapcat new-words %)) (take-while seq) (mapcat identity)\n              (filter (comp (:accepts automaton) :state)) (map (comp clojure.string/join :word)))))", "problem": 164, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn dfa [{:keys [states start accepts transitions]}]\n  ((fn move [pairs]\n     (if (not-empty pairs)\n       (lazy-cat (for [[state path] pairs :when (accepts state)] (apply str path))\n         (move (for [[state path] pairs\n                     [ch next-state] (transitions state)]\n                 [next-state (conj path ch)])))))\n    [[start []]]))", "problem": 164, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [rules]\n  (let [step (fn [{q :q}]\n                (when (seq q)\n                  (let [[word state] (first q)\n                        output (when ((rules :accepts) state) word)\n                        trans ((rules :transitions) state)]\n                    {:q (concat\n                         (next q)\n                         (for [[ltr st] trans] [(conj word ltr) st]))\n                     :r output})))]\n    (map\n     (comp (partial apply str) :r)\n     (filter :r (take-while identity (iterate step {:q [[[] (rules :start)]]}))))))", "problem": 164, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn [dfa]\n  (let [nx #(for [[ch new] (get-in dfa [:transitions %1])] \n              [new (conj %2 ch)])\n        kill-loop (fn [mem] \n                    (filter #(>= (count (dfa :states)) (nth % 2)) \n                      mem))\n        bfs (fn bfs [[[now s lt] & rt]]\n              (let [ac? ((dfa :accepts) now)\n                    nlt (if ac? 0 (inc lt))\n                    sons (map #(conj % nlt) (nx now s))\n                    newque (kill-loop (into (vec rt) sons))]\n                (lazy-cat \n                 (when ac? [(apply str s)])\n                 (if (empty? newque) nil (bfs newque)))))]\n    (bfs [[(dfa :start) [] 0]])))", "problem": 164, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn lang-seq [dfa]\n  (let [st (dfa :start)\n        tr (dfa :transitions)\n        ac (dfa :accepts)\n        step (fn [sm] \n               (mapcat (fn [[q w]] \n                         (map (fn [[k v]] [v (str w k)]) \n                              (tr q))) sm))\n        lang (fn lang [sm] \n               (when (seq sm) \n                 (let [sm1 (step sm)\n                       ws (mapcat (fn [[q w]] \n                                    (when (ac q) (list w))) sm)] \n                   (concat ws (lazy-seq (lang sm1))))))]\n    (lang (map (fn [[k v]] [v (str k)]) (tr st)))))", "problem": 164, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn ! [{:keys [alphabet accepts start transitions progress]\n          :as automaton}]\n    (concat\n        (for [[sentence state] progress\n             :when (accepts state)]\n             sentence)\n        (lazy-seq\n            (let [advance (into {}\n                (for [[sentence state] (some identity [progress {\"\" start}])\n                      letter alphabet\n                      :let [next-state (get-in transitions [state letter])]\n                      :when next-state]\n                          [(str sentence letter) next-state]))]\n                          (if (empty? advance)\n                            '()\n                            (! (assoc automaton :progress advance)))))))", "problem": 164, "user": "51aa2b4fe4b04e3dc0c27b21"}, {"code": "(fn f ([src] (f src (vec(map (fn [tr] [tr [(key tr)]]) ((:start src)(:transitions src))))))\n        ([dfa todo]\n         (if (empty? todo) nil\n           (let [ctr (first(first todo))\n                 crs (last(first todo))\n                 trn (:transitions dfa)\n                 acc (:accepts dfa)\n                 get-trn (fn[] (map (fn [tr] [tr (conj crs (key tr))])((val ctr)trn)))\n                 ] \n             (if (not (nil? ((val ctr) acc))) \n               (lazy-seq(cons (apply str crs) (f dfa (vec(concat (rest todo)(get-trn))))))\n               (f dfa (vec(concat (rest todo)(get-trn)))))\n    ))))", "problem": 164, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn language [dfa]\n  (let [next-ss             (fn [current-ss]\n                              (apply merge-with concat (for [[state strings] current-ss]\n                                             (apply merge-with concat (for [[c next-state] ((dfa :transitions) state)]\n                                                            {next-state (apply hash-set (map #(str % c) strings))})))))\n        accepted-strings    (fn [ss]\n                              (apply hash-set (apply concat (for [state (dfa :accepts)]\n                                                              (ss state)))))\n        full-language       (fn full-language [ss]\n                              (if (empty? ss)\n                                #{}\n                                (lazy-cat (accepted-strings ss) (full-language (next-ss ss)))))\n        ]\n    (full-language {(dfa :start) #{\"\"}})))", "problem": 164, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [{:keys [states\n               alphabet\n               start\n               accepts\n               transitions]}]\n    (let [step    (fn [[w s]] (map (fn [[nl ns]] [(str w nl), ns]) (transitions s)))\n          it      (fn [[a r]]\n                    (let [nr (mapcat step r)\n                          na (filter (comp not nil? accepts second) nr)]\n                      [na nr]))]\n      (->> [#{} #{[\"\" start]}]\n        (iterate it)\n        (take-while (comp not empty? second))\n        (mapcat first)\n        (map first))))", "problem": 164, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn p164 [m]\n (letfn [(acc [s] ((m :accepts) s))\n         (sm [qu]\n             (if (empty? qu) nil\n                 (let [q (first qu) [ca ald cs] q nqu (next qu)]\n                 (if (nil? ((m :states) cs)) (sm nqu)\n                     (let [lls (sort-by #(+ (key %) (if (or (not= (second (val %)) cs) (acc (second (val %)))) 0 100)) (zipmap (range) ((m :transitions) cs)) )\n                           ls (map second lls) aald (conj ald [ca cs])\n                           ]\n                       (if (empty? ls) (if (and (acc cs) (empty? (ald [ca cs]))) (cons ca (sm nqu)) (sm nqu))\n                           (let [[na ns] (first ls) nca (str ca na)\n                                 nls (cons [nca (conj ald [nca ns]) ns] (concat (map (fn [e] [(str ca (first e)) (conj ald [nca ns]) (second e)]) (next ls)) nqu))\n                                 ]\n                             (if (acc ns) (lazy-seq (cons nca (sm nls))) (sm nls))))))))\n           )]\n   (sm  [[\"\" #{} (:start m)]])))", "problem": 164, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn [automaton]\n  (let [nextsingle (fn [[state value]] (map (fn [[ch newstate]] [newstate (str value ch)]) ((automaton :transitions) state)))\n        dict (fn dict [generated seeds]\n               (if (empty? generated)\n                 (if (empty? seeds)\n                   nil\n                   (let [nextiter (apply concat (map nextsingle seeds))]\n                     (dict \n                      (filter #(contains? (automaton :accepts) (first %)) nextiter) \n                      (filter #(contains? (automaton :transitions) (first %)) nextiter))))\n                 (cons (last (first generated)) (lazy-seq (dict (rest generated) seeds))) ))\n        ]\n    (dict [] [[(automaton :start) \"\"]])))", "problem": 164, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn\n    [dfa]\n    (let [start (dfa :start)\n          accepts (dfa :accepts)\n          step-dfa (fn [dfa current-state current-string]\n                     (let [next-states ((dfa :transitions) current-state)]\n        \t       (for [[letter state] next-states]\n                         [state (str current-string letter)])))\n          multi-step-dfa (fn [dfa current-state-pairs]\n                           (apply concat\n                                  (for [[state string] current-state-pairs]\n                                    (step-dfa dfa state string))))\n          run-dfa (fn r [dfa current-state-pairs]\n                    (let [start (dfa :start)\n                          next-state-pairs (multi-step-dfa dfa current-state-pairs)]\n                      (if (empty? next-state-pairs)\n                        next-state-pairs\n                        (lazy-cat next-state-pairs (r dfa next-state-pairs)))))]\n      (map second\n           (filter\n            (fn [[state string]] (accepts state))\n            (run-dfa dfa (seq [[start \"\"]]))))))", "problem": 164, "user": "529936e7e4b02ebb4ef7507b"}, {"code": "(fn dfa [{:keys [start accepts transitions]}]\n  (letfn\n    [(next-seq [sqs]\n       (if (empty? sqs) \"\"\n       (lazy-cat (for [[s0 q0] sqs :when (accepts q0)] s0)\n       (next-seq (for [[s0 q0] sqs [s1 q1] (transitions q0)] [(str s0 s1) q1]))\n         )))]\n    (next-seq [[\"\" start]])\n    ))", "problem": 164, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [dfa]\n        (let [\n              accepts (dfa :accepts)\n              accept? (fn [[a s]] (contains? accepts s))\n              step (fn [[path state]]\n                     (when-let [states (seq ((dfa :transitions) state))]\n                       (let [f (fn [[a s]] [(conj path a) s])\n                             s0 (filter accept? states)\n                             s1 (remove accept? states)]\n                         (concat (map f s0) (map f s1)))))\n              ]\n          (map\n           (fn [[path state]] (apply str path))\n           (filter (fn [[path state]]\n                     (contains? (dfa :accepts) state))\n                   (tree-seq\n                    (fn [[path state]] (contains? (dfa :transitions) state))\n                    step\n                    [[] (dfa :start)])\n                   )\n           )\n          )\n        )", "problem": 164, "user": "5298d3f4e4b02ebb4ef75068"}, {"code": "(fn language\n  ([definition]\n    (let [start (definition :start)\n          transitions (definition :transitions)\n          accepts (definition :accepts)]\n      (language transitions start accepts \"\")\n    )\n  )\n  ([transitions start accepts word]\n    (let [acceptable-starts (transitions start)\n          acceptable-states (filter #(contains? accepts (val %)) acceptable-starts)\n          acceptable-words (map #(str word (key %)) acceptable-states)\n          next-words (map #(vector (str word (key %)) (val %)) acceptable-starts)\n          next-transitions (dissoc transitions start)]\n      (flatten (conj acceptable-words (lazy-seq (map #(language next-transitions (second %) accepts (first %)) next-words))))\n    )\n  )\n)", "problem": 164, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn lang-of-DFA [map-def]\n  (let [states (:states map-def)\n        alphabet (:alphabet map-def)\n        start (:start map-def)\n        accepts (:accepts map-def)\n        transitions (:transitions map-def)]\n    (letfn [(step [string path this-char this-state] \n                  (let [nexts (transitions this-state)]\n                    (if (some #(= this-state %) path)\n                      (if (accepts this-state) [(cons this-char string)])\n                      (if (accepts this-state) \n                        (cons (cons this-char string) (apply concat \n                                                             (map \n                                                              #(step (cons this-char string) (cons this-state path) (key %) (val %)) nexts)))\n                        (apply concat (map #(step (cons this-char string) (cons this-state path) (key %) (val %)) nexts))))))]\n      \n      (set (map (fn [res] (apply str (filter #(not (nil? %)) (reverse res)))) (step [] [] nil start))))))", "problem": 164, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn dfa [{:keys [states start accepts transitions]}]\n((fn bfs [q]\n   (lazy-seq\n    (when (seq q)\n      (let [\n            [s1 w1] (first q)\n            nw (into []\n                     (for [[w2 s2] (transitions s1)]\n                       [s2 (conj w1 w2)])\n                     )\n            nw (concat (vec (rest q)) nw)\n            ]\n        (if (accepts s1)\n          (cons (apply str w1) (bfs nw))\n          (bfs nw)))\n      )\n    )\n\n   ) [[start []]]))", "problem": 164, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn n164 [dfa]\n  ; (x [q \"abc\"])\n  (letfn [(dfa-gen [x]\n                   (if-let [f (get-in dfa [:transitions (first x)])]\n                     (map #(vector (val %) (str (second x) (key %))) f)\n                     false))\n          (dfa-gen-mul [cx]\n                       (reduce concat (filter identity (map dfa-gen cx))))\n          (dfa-ite [cx]\n                   (lazy-seq\n                     (let [new-x (dfa-gen-mul cx)\n                           accepted (filter #(contains? (:accepts dfa) (first %)) new-x)]\n                       (if (empty? new-x)\n                         []\n                         (concat accepted (dfa-ite new-x))))))\n          ]\n    (map second (dfa-ite '[[q0 \"\"]]))))", "problem": 164, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn f [dfa]\n  (let [\n        iter (fn [ss]\n          (set\n            (apply concat\n              (for [s1 ss]\n                (for [s2 ((dfa :transitions) (second s1))]\n                  [(str (first s1) (first s2)) (second s2)])))))\n        accs (fn [ss]\n               (set (filter #((dfa :accepts) (second %)) ss)))\n        ends (fn [ss]\n               (set (filter #(nil? ((dfa :transitions) (second %))) ss)))\n        cleaned (fn [ss]\n                  (clojure.set/difference ss (ends ss)))\n        iter2 (fn [ss]\n                (let [ss1 (iter (ss :states))\n                      accs (accs ss1)]\n                  {:states (cleaned ss1)\n                   :accs accs\n                   :accwords (map first accs)\n                   }))\n        start '{:states #{[\"\" q0]}}\n        iter3 (take-while #(or (not-empty (:states %)) (not-empty (:accs %)))\n                         (rest (iterate iter2 start)))\n        y (flatten (map :accwords iter3))\n       ]\n     y\n     ))", "problem": 164, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [m]\n     ((fn t [[a s]]\n        (let [wm (map #(vector (str a (first %)) (second %)) (s (:transitions m)))\n              fin (map first (filter #(contains? (:accepts m) (second %)) wm))]\n          (apply concat fin (map #(lazy-seq (t %)) wm)))) [\"\" (:start m)]))", "problem": 164, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn w [dfa] (map second (filter #(contains? (:accepts dfa) (first %)) (apply concat (take-while #(> (count %) 0) (iterate (fn a [ss] (mapcat (fn b [[state string]] (map (fn c [[l ns]] [ns (str string l)]) (get-in dfa [:transitions state]))) ss)) [[(:start dfa) \"\"]]))))))", "problem": 164, "user": "4f0f174c535d0136e6c22330"}, {"code": "(fn [{:keys [states alphabet start accepts transitions]}]\n         (letfn [(next-state [{w :word s :state} l]\n                   (if-let [state (get-in transitions [s l])]\n                     {:word (str w l) :state state}))\n                 (next-states [ss]\n                   (remove nil? (mapcat (fn [s] (map #(next-state s %) alphabet))\n                                        ss)))\n                 (value [{w :word s :state}]\n                   (if (accepts s) w))\n                 (values [states]\n                   (if (empty? states) []\n                       (lazy-seq (concat (remove nil? (map value states))\n                                         (values (next-states states))))))]\n           (values [{:word \"\" :state 'q0}])))", "problem": 164, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn d\n  ([r] (d #{[\"\" (r :start)]} r))\n  ([c r]\n     (let [F first\n           S second\n           Z (fn [t [s q]]\n               (map #(vec [(str s (F %)) (S %)]) (t q)))]\n       (if (seq c)\n         (lazy-cat (map F (filter #((r :accepts) (S %)) c))\n                   (d (mapcat #(Z (r :transitions) %) c) r))))))", "problem": 164, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn lazy-dfa\n  [{:keys [states start accepts transitions]}]\n  (letfn\n    [(get-next-states\n     [current-state acc]\n     (for [[ch state] (get transitions current-state)]\n       [state (conj acc ch)]))\n     (build-vocab\n      [coll]\n      (when-let [[[current-state acc] & others] (seq coll)]\n        (let [more (get-next-states current-state acc)]\n        (if (contains? accepts current-state)\n          (cons (apply str acc) (lazy-seq (build-vocab (concat others more))))\n          (lazy-seq (build-vocab (doall (concat others more))))))))]\n    (build-vocab [[start []]])))", "problem": 164, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [{:keys [start accepts transitions]}]\n    (->> [[\"\" start]]\n         (iterate (fn [states]\n                    (for [[prefix state] states\n                          [letter new-state] (get transitions state)]\n                      [(str prefix letter) new-state])))\n         (take-while seq) \n         (mapcat identity)\n         (filter #(accepts (second %)))\n         (map first)))", "problem": 164, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn dfa [{:keys [accepts start transitions]}]\n  (let [good (set (keys transitions))\n        step (fn [[q st]] (when (good q) (map (fn [[ch qn]] [qn (str st ch)]) (transitions q))))\n        rec (fn rec [states]\n              (lazy-seq\n               (when-let [s (seq states)]\n                 (concat (reduce (fn [res [q st]] (if (accepts q) (cons st res) res)) '() s)\n                         (rec (->> s (mapcat step) (remove nil?)))))))]\n    (rec (list [start \"\"]))))", "problem": 164, "user": "50645e12e4b007509339a58a"}, {"code": "(fn [{states :states,\n      alphabet :alphabet,\n      start :start,\n      accepts :accepts\n      trans :transitions}]\n  (let [expand (fn [q]\n                 (for [[state path] q\n                       :let [t (trans state)]\n                       :when t\n                       a alphabet\n                       :when (t a)]\n                   [(t a) (conj path a)]))\n        all-states (take-while not-empty (iterate expand [[start []]]))]\n    (for [q all-states\n          [state path] q\n          :when (accepts state)]\n      (apply str path))))", "problem": 164, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [{st :start ac :accepts tr :transitions}]\n  (letfn [(t [[k v]]\n            (if-let [i (tr k)]\n              (map #(vector (second %) (str v (first %))) i)))\n          (dfa [s]\n            (if (first s)\n              (lazy-cat\n                (map second (filter #(ac (first %)) s))\n                (dfa (mapcat t s)))))]\n    (dfa [[st \"\"]])))", "problem": 164, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [s]\n   (letfn [(lp [w x] (lazy-seq (cons (apply str (repeat x w)) (lp w (inc x)))))]\n     ((fn next [pr las] (let [v (first pr) pr (vec (rest pr))]\n                     (let [nxt (if-not (nil? ((s :transitions) (second (last v)))) ((s :transitions) (second (last v))) {})\n                           pr2 (reduce\n                                #(if (not= -1 (.indexOf (vec (s :accepts)) (second %2)))\n                                   (vec (cons (conj v %2) %1))\n                                   (vec (conj %1 (conj v %2)))) pr nxt)\n                           nx (if (and (< 1 (count v)) (some #(= (second (last v)) %) (s :accepts)))\n                                (apply str (remove #(nil? %) (map #(first %) v))) nil)\n                           pr pr2]\n                       (if (= (count pr) 0)\n                         (if (nil? nx)\n                           []\n                             [nx]\n \t\t           )\n                         (if (nil? nx)\n                           (lazy-seq (next pr las))\n                           (let [dn (- (count nx) (count las))]\n                             (if (not= 0 dn)\n                               (let [rm (if (= dn 0) nil (rem (count nx) dn))\n                                     dv (if (= dn 0) 0 (/ (count nx) dn))\n                                     w (take dn nx)\n                                     nx2 (apply str (apply concat (repeat dv w)))\n                                     las2 (apply str (apply concat (repeat (dec dv) w)))]\n                                 (if (and (= 0 rm) (= las las2) (= nx nx2))\n                                   (lazy-seq (cons nx (lp (apply str w) (inc dv))))\n                                   (lazy-seq (cons nx (next pr nx)))))\n                               (lazy-seq (cons nx (next pr nx)))\n                               ))))\n                       )\n                     ))\n      [[[nil (s :start)]]] nil)))", "problem": 164, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn enumerate-dfa [dfa]\n  (letfn [(next-state-spaces [current-input transitions]\n            (map\n             (fn [[input next-state]]\n               {:state next-state\n                :input (cons input current-input)})\n             transitions))\n          (search [frontier]\n            (let [current (first frontier)\n                  state (current :state)\n                  done? ((dfa :accepts) state)\n                  transitions (get-in dfa [:transitions state])]\n              (if done?\n                [(reverse (current :input))\n                 (concat (rest frontier)\n                         (next-state-spaces (current :input) transitions))]\n                [nil (concat (rest frontier)\n                         (next-state-spaces (current :input) transitions))])))\n          (helper [frontier]\n            (if (empty? frontier)\n              nil\n              (lazy-seq\n               (let [[next frontier]\n                     (loop [[result frontier*] (search frontier)]\n                       (if (and (nil? result) (not (empty? frontier*)))\n                         (recur (search frontier*))\n                         [result frontier*]))]\n                 (cons next\n                       (helper frontier))))))]\n    (map (fn [res]\n           (apply str (map str res)))\n         (helper [{:state (dfa :start)\n                   :input nil}]))))", "problem": 164, "user": "5192b707e4b08962174cf751"}, {"code": "(fn __ [{:keys [start accepts transitions]}]\n  ((fn step [q]\n     (lazy-seq\n      (when-let [[state stri] (peek q)]\n        (concat\n         (when (accepts state) [stri])\n         (step (into (pop q)\n                     (map (fn [[str_ sta_]] [sta_ (str stri str_)])\n                          (transitions state))))))))\n   (conj clojure.lang.PersistentQueue/EMPTY [start \"\"])))", "problem": 164, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [dfa]\n  (let [{:keys [transitions accepts start]} dfa]\n    (letfn [(find-string [queue]\n             (if (seq queue)\n               (let [[item & queue] queue\n                     {:keys [state chars]} item\n                     my-transistions (get transitions state)\n                     apply-transition (fn [[letter state]] {:state state, :chars (conj chars letter)})\n                     next-queue (concat queue (map apply-transition my-transistions))]\n                 (if (get accepts state)\n                   (cons (apply str chars) (lazy-seq (find-string next-queue)))\n                   (recur next-queue)))))]\n      (find-string [{:state start, :chars []}]))))", "problem": 164, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [{start :start accepts :accepts trans :transitions}]\n  ((fn helper [word state]\n     (let [transitions (trans state)\n           next-states (map (fn [[sym state']] [(str word sym) state']) transitions)\n           accept-states (filter #(accepts (second %)) next-states)\n           results (map first accept-states)\n           remaining (mapcat #(lazy-seq (apply helper %)) next-states)]\n       (lazy-cat results remaining))) \"\" start))", "problem": 164, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn __ [{:keys [states alphabet start accepts transitions] :as dfa}]\n  (letfn [(resolve-step [[string node] transitions]\n            (if-let [outgoing (transitions node)]\n              (map #(vector (str string (first %)) (second %)) outgoing)))\n          (step [nodes {:keys [accepts transitions] :as dfa}]\n            (let [accepted (map first (filter (comp accepts second) nodes))\n                  next-nodes (mapcat #(resolve-step % transitions) nodes)]\n              (if (seq next-nodes)\n                  (concat accepted (lazy-seq (step next-nodes dfa)))\n                  accepted)))]\n    (step [[\"\" start]] dfa)))", "problem": 164, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn dfa [dfn]\n  (letfn [(gen-step [dfn states]\n                    (mapcat (fn [[s p]]\n                              (filter (complement nil?) (map #(if-let [t ((dfn :transitions) s)]\n                                                                (if-let [s* (t %)]\n                                                                  (vector s* (str p %))))\n                                                             (dfn :alphabet)\n                                                             ))\n                              )\n                            states)\n                    )\n          (step [states]\n                ; Return the accepted states, joined with\n                ; a lazy-seq of calling step with each state processed\n                ; for all next states.\n                (if (empty? states)\n                  []\n                  (concat\n                   (for [[s p] states\n                         :when ((dfn :accepts) s)]\n                     p)\n                   (lazy-seq (step (gen-step dfn states)))\n                   )\n                  )\n                )]\n    (step [[(dfn :start) \"\"]])\n    )\n  )", "problem": 164, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [dfa] \n  (let [step (fn [dfa coll]\n\t\t\t   (mapcat (fn [[sentence rule]]\n\t\t\t\t (map (fn [[sym nr]] (vector (conj sentence sym) nr)) (get-in dfa [:transitions rule]))) coll))  \n\t\titer (fn [dfa coll] \n\t\t  (take-while not-empty (iterate #(step dfa %) (step dfa coll))))\n\n\t\tlang (fn [dfa]\n\t\t  (->> (iter dfa [[[] (dfa :start)]])\n\t\t\t   (mapcat identity)\n\t\t\t  (filter #((dfa :accepts) (second %)))\n\t\t\t  (map first)\n\t\t\t  (map #(apply str %))\n\t\t\t  ))] \n    (lang dfa)))", "problem": 164, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn dfa ([ts] (dfa (:start ts) ts [])) \n  ([s ts path]\n     (apply concat (for [[k v] ((:transitions ts) s) :when (contains? (:accepts ts) v)] \n        (apply str (conj path k)) )\n        (doall (map (fn[[k v]](lazy-seq (dfa v ts (conj path k)))) (for [[k v] ((:transitions ts) s)][k v])) )\n     )\n  )\n)", "problem": 164, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [dfa] (letfn [\n(transitions-from-current [{:keys [current, transitions] :as dfa}]\n\t(current transitions)\n)\n(stuck? [dfa] (empty? (transitions-from-current dfa)))\n(in-accept-state? [{:keys [accepts, current] :as dfa}]\n\t(contains? accepts current)\n)\n(consume-symbol [{string :string :as dfa} sym]\n\t(into dfa {:current ((transitions-from-current dfa) sym) :string (str string sym)})\n)\n(proceed [dfa]\n\t(map #(consume-symbol dfa %) (keys (transitions-from-current dfa)))\n)\n(harvest [{:keys [dfas, strings] :as global-state}]\n\t(let\n\t\t[\n\t\tfresh-strings\n\t\t(remove empty? (map :string (filter in-accept-state? dfas)))\n\t\t]\n\t\t(into global-state\n\t\t\t{\n\t\t\t\t:strings (concat strings fresh-strings)\n\t\t\t\t:fresh-strings fresh-strings\n\t\t\t}\n\t\t)\n\t)\n)\n(prune [{dfas :dfas :as global-state}]\n\t(into global-state\n\t    {:dfas (remove stuck? dfas)})\n)\n(next-round [global-state]\n\t(let [\n\t\tglobal-state-after-harvest-and-prune\n\t\t(prune (harvest global-state))\n\t\tdfas-for-next-round\n\t\t(set (mapcat proceed (:dfas global-state-after-harvest-and-prune)))\n\t\tglobal-state-for-next-round\n\t\t(into global-state-after-harvest-and-prune {:dfas dfas-for-next-round})\n\t\t]\n\t\t(if (empty? (:dfas global-state))\n\t\t\t(assoc global-state-for-next-round :terminated true)\n\t\t\tglobal-state-for-next-round\n\t\t)\n\t)\n)\n(rounds [dfa]\n\t(let [\n\t\tinitial-dfa\n\t\t(into dfa {:current (:start dfa) :string \"\"})\n\t\tinitial-global-state\n\t\t{:dfas [initial-dfa] :strings []}\n\t\t]\n\t\t(take-while #(not (:terminated %)) (iterate next-round initial-global-state))\n\t)\n)\n(dfa-language [dfa]\n\t(mapcat :fresh-strings (rounds dfa))\n)\n] (dfa-language dfa)))", "problem": 164, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn [{:keys [start accepts transitions]}]\n   (letfn [(gera-linguagem [{:keys [acepta transiciones]}]\n                           (fn [estados-actuales]\n                             (mapcat (fn [estado-actual]\n                                       (map (fn [transicion]\n                                              [(val transicion) (.concat (second estado-actual) (str (key transicion)))])\n                                            ((first estado-actual) transiciones)))\n                                     estados-actuales)))]\n     (let [gera-transicao (gera-linguagem {:acepta accepts :transiciones transitions})]\n       (->> (gera-transicao #{[start \"\"]})\n            (iterate gera-transicao)\n            (take-while  #(seq %))\n            (apply concat)\n            (filter #(accepts (first %)))\n            (map (fn [[estado palavra]] palavra))))))", "problem": 164, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn DFA [definition]\n  (let [\n  \n    transitions       (fn [state] (seq ((:transitions definition) state)))\n    \n    acceptable?       (fn [state] ((:accepts definition) state))\n\n    start             (:start definition)\n    \n    get-loop          (fn [[o-chars o-states :as out] state]\n                        (let [c (inc (count (take-while #(not= % state) o-states)))]\n                          [state (drop c o-chars)]))\n                          \n    insert-loop       (fn [loops [l-state l-chars :as loopt]]\n                        (let [loopqt (count (filter #{l-chars} (map (comp butlast second) loops)))]\n                          (conj loops [l-state (concat l-chars [(symbol (str \\; (char (+ 65 loopqt))))])])))\n                          \n  \torganize-outputs  (fn org-out [[o-chars o-states :as out] state loops finite]\n  \t                    (let [finite# (if (acceptable? state) (conj finite out)\n  \t                                                           finite)]\n  \t                                                             \n  \t                      (if ((set (pop o-states)) state) (let [loops# (insert-loop loops (get-loop out state))]\n  \t                                                         [loops# finite#])  \n     \t                      (loop [[t & rt :as transits] (transitions state)\n  \t                               [loops# finite##]      [loops finite#]]\n\n     \t                        (if (nil? t) [loops# finite##]\n                \t                         (let [[o-char o-state] t\n  \t                                             out# [(conj o-chars  o-char),\n  \t                                                   (conj o-states o-state)]]  \n  \t                                         (recur rt (org-out out# o-state loops# finite##))))))))\n\n    outputs-org     (organize-outputs [[nil] [start]] start #{} #{})\n    \n    loops           (seq (first outputs-org))\n    \n    get-loops-st    (fn [state]\n\t\t                  (for [[l-state lstr] loops\n                            :when (= l-state state)]\n                        (apply str (concat [\\:] lstr [\\:]))))\n  \t                                         \n  \t                                         \n    get-output      (fn [finite]\n                      (loop [ string \"\"\n                              [[o-char & cs][o-state & ss]] finite]\n                       (if (nil? o-state) string\n                                          (let [loopstr (apply str (get-loops-st o-state))]\n                                            (recur (str string o-char loopstr) [cs ss])))))\n                                            \n    outputs          (for [out (seq (remove #(= [nil] (first %)) (second outputs-org)))] (get-output out))\n                             \n    get-loops-out    (fn [output]\n                        (re-seq #\":[^:]*:\" output))\n                        \n    remove-loops     (fn [output]\n                       (let [to-remove (get-loops-out output)]\n                         (reduce #(clojure.string/replace % %2 \"\") output to-remove))) \n                       \n                       \n    add-loop         (fn [output loopt]\n                       (clojure.string/replace\n                         output\n                         loopt\n                         (str (subs loopt 1 (- (count loopt) 3)) loopt)))\n                                               \n   expand-outputs    (fn [e-outputs]\n                       (for [out   e-outputs\n                             loopt (get-loops-out out)]\n                         (add-loop out loopt)))\n                         \n   get-all-expanded  (fn expand-next [e-outputs]\n                       (let [expanded (expand-outputs e-outputs)]\n                         (lazy-cat (distinct (map remove-loops expanded))\n                                   (expand-next (distinct expanded)))))\n                                \n   any-loops?        (not (every? nil?\n                        (for [out outputs]\n                          (get-loops-out out))))]\n  \n    (if any-loops? (lazy-cat (map remove-loops outputs)\n                             (get-all-expanded outputs))\n                   outputs)))", "problem": 164, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn [dfa] (letfn [(run-dfa [dfa state input depth]\n                   (if (< 10 depth) []\n                       (let [accepted (if (get-in dfa [:accepts state]) [input] [])\n                             transitions (get-in dfa [:transitions state])]\n                         (set\n                          (concat\n                           accepted\n                           (apply concat\n                                  (for [letter (keys transitions)]\n                                    (run-dfa dfa\n                                             (transitions letter)\n                                             (clojure.string/join [input (str letter)])\n                                             (inc depth)))))))))]\n  (run-dfa dfa (:start dfa) \"\" 0)))", "problem": 164, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn runf [{trans :transitions, accepts :accepts, start :start}]\n  (let [runm (fn runs [s-pairs]\n               (when-let [new-pairs (seq (for [[s s-str] s-pairs\n                                               [c next-s] (trans s)]\n                                           [next-s (str s-str c)]))]\n                  (lazy-cat (for [[s str] new-pairs :when (accepts s)] str)\n                            (runs new-pairs))))]\n    (runm [[start \"\"]])))", "problem": 164, "user": "523c61b2e4b07becd5be2220"}, {"code": "(fn [dfa]\n  (letfn [(get-next-statuses [current-statuses]\n            (apply merge (flatten (map\n                                    (fn [entry]\n                                      (let [ns (get (:transitions dfa) (val entry))]\n                                        (if ns (map #(assoc {} (concat (key entry) [(key %)]) (val %)) ns))))\n                                    current-statuses))))\n          (step [current-statuses]\n            (let [next-statuses (get-next-statuses current-statuses)]\n              (if next-statuses\n                (lazy-cat\n                  (map #(apply str (key %)) (filter #((:accepts dfa) (val %)) next-statuses))\n                  (step next-statuses)))))]\n    (step {[] (:start dfa)})))", "problem": 164, "user": "50436470e4b034ff00315d23"}, {"code": "(fn language [{:keys [start accepts] :as dfa}]\n  (letfn [(transition [{:keys [transitions] :as dfa} [word s]]\n                      (map (fn [[k v]]\n                             [(conj word k) v]) (transitions s)))\n          \n          (accepted [{acc :accepts :as dfa} word-states]\n                    (lazy-seq\n                     (when-let [s (seq word-states)]\n                       (let [newstates (mapcat (partial transition dfa) word-states)\n                             final (->> newstates\n                                        (filter (comp acc second))\n                                        (map first)\n                                        (map (partial apply str)))]\n                         (concat final (accepted dfa newstates))))))]\n    (let [words (accepted dfa [[[] (:start dfa)]])]\n      (if (accepts start)\n        (cons \"\" words)\n        words))))", "problem": 164, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn lang [dfa]\n  (letfn [(lazy-lang [path-queue word-queue]\n             (lazy-seq \n               (if (seq word-queue) (cons (first word-queue) (lazy-lang path-queue (rest word-queue)))\n                     (loop [[[current-path current-state] & rest-path-queue :as pq] path-queue]\n                       (if (empty? pq) '()\n                         (let [\n                             transitions (get-in dfa [:transitions current-state])\n                             new-paths (reduce (fn [paths [chr state]] (conj paths [(str current-path chr) state])) [] transitions)\n                             new-words (map first (filter #(contains? (:accepts dfa) (second %)) new-paths))]\n                           (if (empty? new-words) (recur (concat rest-path-queue new-paths))\n                               (cons (first new-words) (lazy-lang (concat rest-path-queue new-paths) (rest new-words))))))))))]\n   (lazy-lang [[\"\" (:start dfa)]] #{})))", "problem": 164, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn f\n  ([m] (f m (get m :start) 10))  \n  ([m state limit] \n   (if (zero? limit)\n    nil\n    (let [cont (flatten (map #(map (fn [e] (str (first %) e )) (f m (second %) (dec limit)))\n                    (get-in m [:transitions state])))\n          end (if (contains? (get m :accepts) state)\n                [\"\"]\n                nil)]\n      (set (concat end cont))))))", "problem": 164, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [a]\n  (->>\n    (for [q (a :accepts)] [q \"\"])\n    (iterate #(for [[q w] %\n                    [p t] (a :transitions)\n                    [s r] t :when (= q r)]\n                [p (str s w)]))\n    (map #(list (for [[q w] % :when (= (a :start) q)] w)\n                (seq %)))\n    (take-while second)\n    (mapcat first)\n    (remove empty?)))", "problem": 164, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(letfn [(lang\n         [dfa word-states]\n         (when (seq word-states)\n           (lazy-cat\n            (->> word-states\n                 (filter\n                  (fn [[word state]]\n                    ((:accepts dfa)\n                     state)))\n                 (map first))\n            (->> word-states\n                 (mapcat\n                  (fn [[word state]]\n                    (map (fn [[c state]]\n                           [(str word c)\n                            state])\n                         ((:transitions dfa)\n                          state))))\n                 (lang dfa)))))]\n  \n  (fn language [dfa]\n    (->> [[\"\" (:start dfa)]]\n         (lang dfa)\n         distinct)))", "problem": 164, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn  [ {:keys [start accepts transitions]}]\n    (let [gens\n          (fn gen2\n            ([ [ {:keys [state path] :as head} & t] visited]\n               (let [new-states\n                     (for [ [symbol target] (transitions state)]\n                       {:state target :path (conj path (str symbol))} )\n\n                     by-visited\n                     (group-by #(contains? visited (:state %)) new-states)\n\n                     more\n                     (lazy-seq (gen2 (concat (by-visited false) t (by-visited true)) (conj visited state)))\n                     ]\n                 (cond\n                  (not head) nil\n                  (accepts state) (cons path more)\n                  :else more))))]\n      (map clojure.string/join (gens [{:state start :path []}] #{})))\n    )", "problem": 164, "user": "53440c0ae4b084c2834f4a25"}, {"code": "(fn dfa-language [dfa-desc]\n(letfn [(next-string [dfa-desc next-states open-states]\n\t(if (not= 0 (count next-states))\n\t    (let [[curr-state, curr-string :as curr-pair]  (first next-states) left-next (rest next-states)]\n\t\t\t(if ((dfa-desc :accepts) curr-state)\n\t\t\t\t(cons curr-string (lazy-seq (next-string dfa-desc left-next (conj open-states curr-pair))))\n\t\t\t\t(recur dfa-desc left-next (conj open-states curr-pair))\n\t\t\t)\n\t\t)\n\t\t(if (not= 0 (count open-states))\n\t\t\t(let [[curr-state, curr-string] (peek open-states) curr-trans ((dfa-desc :transitions) curr-state)\n\t\t\t\t   curr-next-states (for [[sym, state] curr-trans] [state (str curr-string sym)])\n\t\t\t\t   next-open-states (pop open-states)]\n\t\t\t\t(recur dfa-desc curr-next-states next-open-states)\t\n\t\t\t)\n\t\t)\n\t)\t\n)]\n\t(let [init-state (dfa-desc :start) next-states '() open-states clojure.lang.PersistentQueue/EMPTY ]\n\t\t(next-string dfa-desc next-states (conj open-states [init-state \"\"]))\n\t)\n)\n)", "problem": 164, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "#(let [[_ _ s a t] (vals %)\n        ]\n    ((fn i [y]\n            (lazy-seq\n              (if (seq y)\n                (let [[w r] (peek y)\n                      n (i (into \n                             (mapv (fn [[y x]] [x (str r y)])\n                                  (t w))\n                             (pop y)))]\n                  (if (and r (a w))\n                    (cons r n) \n                    n))))) [[s]]))", "problem": 164, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn tst\n    ([{:keys [start transitions accepts] :as l}]\n       (tst l [[ start \"\"]]))  \n    ([{:keys [transitions accepts] :as l} [[c p] & r]]       \n       (if c\n         (let [nx (reverse (map (fn [[le nd]] [nd (str p le)])\n                                    (transitions c)))]  \n           (if (accepts c)\n             (cons p (lazy-seq (tst l (into nx r))))\n             (recur l (into  nx r)))))))\n;an improved second attempt, the 'reverse' on line 6 is a litte cheaty", "problem": 164, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn dfa\n  [{start       :start\n    accepts     :accepts\n    transitions :transitions}]\n  (let [transition (fn [state word]\n                     (let [ts (state transitions {})]\n                       (loop [ts ts words []]\n                         (if (empty? ts)\n                           words\n                           (let [[c s] (first ts)]\n                             (recur (rest ts) (conj words [s (str word c)])))))))\n        search (fn search [q]\n                 (if (empty? q)\n                   []\n                   (let [[state word] (first q)\n                         ts (transition state word)]\n                     (if (contains? accepts state)\n                       (cons\n                         word\n                         (lazy-seq (search (concat (rest q) ts))))\n                       (search (concat (rest q) ts))))))]\n    (search [[start \"\"]])))", "problem": 164, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [dfa]\n  (letfn [(get-next-states [state string]\n                       (let [transitions (get-in dfa [:transitions state])]\n                         (map #(vector (second %) (str string (first %))) transitions)))\n          (dfa-inner [state-strings]\n                     (let [next-state-strings (mapcat (partial apply get-next-states) state-strings)\n                           accepted-strings (map second (filter #((:accepts dfa) (first %)) next-state-strings))]\n                       (if (empty? next-state-strings)\n                         accepted-strings\n                         (lazy-cat accepted-strings (dfa-inner next-state-strings)))))]\n    (dfa-inner [[(:start dfa) \"\"]])))", "problem": 164, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn recognized-strings [{:keys [start transitions] :as dfa}]\n  (letfn [(traverse [transitions state seen-states strings string]\n            ; here to return the string in case of cyclic paths        \n            (if (and (= seen-states (:states dfa)) (contains? (:accepts dfa) state))\n              strings \n\n              (if (seq transitions)\n                (apply concat \n                       (for [[state-value new-state] (vec transitions) \n                             :when (and (not (contains? seen-states state)))\n                             :let [new-string (str string state-value)]]\n\n                         (traverse \n                             (get (:transitions dfa) new-state) \n                             new-state \n                             (conj seen-states state)\n                             (if (contains? (:accepts dfa) new-state) (conj strings new-string) strings) \n                             new-string)) \n                       )  \n                strings))\n            )]\n    (traverse (get transitions start) start #{} [] \"\")))", "problem": 164, "user": "5244a10de4b0d8acf9ed6ab3"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "53b182a5e4b047364c044491"}, {"problem": 164, "code": "(fn [{start :start accepts :accepts trans :transitions}]\n  ((fn helper [word state]\n     (let [transitions (trans state)\n           next-states (map (fn [[sym state']] [(str word sym) state']) transitions)\n           accept-states (filter #(accepts (second %)) next-states)\n           results (map first accept-states)\n           remaining (mapcat #(lazy-seq (apply helper %)) next-states)]\n       (lazy-cat results remaining))) \"\" start))", "user": "52488a46e4b05ef8e38e63e0"}, {"problem": 164, "code": "(fn\n  [dfa]\n  (let [[start accepts transitions]\n        (map dfa [:start :accepts :transitions])]\n    (letfn [(r\n              [q]\n              (lazy-seq\n                (if (seq q)\n                  (let [[v curr-state] (peek q)\n                        next-states (map (fn [[sym next-state]]\n                                           [(conj v sym) next-state])\n                                         (transitions curr-state))\n                        q' (if (empty? next-states)\n                             (pop q)\n                             (apply conj (pop q) next-states))]\n                    (if (contains? accepts curr-state)\n                      (cons (apply str v) (r q'))\n                      (r q')))\n                  nil)))]\n      (r (conj clojure.lang.PersistentQueue/EMPTY [[] start])))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 164, "code": "(fn dfa [d]\n  (letfn [(queue-search [initial testf resultf transitionsf]\n            ( (fn innerf [q]\n                (if (empty? q)\n                  nil\n                  (let [first-item  (peek q)\n                        remaining-q (pop q)]\n                    (lazy-seq\n                     (let [passes? (testf first-item)\n                           transitions (transitionsf first-item)\n                           new-q (if (empty? transitions)\n                                   remaining-q\n                                   (apply conj remaining-q transitions))\n                           ]\n                       (if passes?              \n                         (cons (resultf first-item)\n                               (innerf new-q))          \n                         (innerf new-q)))))))\n              initial \n              ))\n          \n          ]\n    (let [my-initial (conj (clojure.lang.PersistentQueue/EMPTY)\n                           [ [] (:start d) ] )\n          ]\n      (letfn [(my-testf [[_ state]] ((:accepts d) state))\n              (my-resultf [[s _]] (apply str s))\n              (my-transitionsf [[s state]]\n                (map (fn [[k v]] [(conj s k) v])\n                     ((:transitions d) state)))\n              ]\n        (queue-search my-initial my-testf my-resultf my-transitionsf)\n        ))))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [(trans [e d]\n            (let [s (get (:transitions d) (val e))]\n              (if s (map #(hash-map (concat (key e) [(key %)]) (val %)) s))))\n          (next-state [curr d]\n            (let [smaps (map #(trans % d) curr)]\n              (apply merge (flatten smaps))))\n          (get-acc [d ns]\n            (filter #((:accepts d) (val %)) ns))\n          (mape-to-str [e]\n            (apply str (key e)))\n          (lingo [curr d]\n            (let [ns (next-state curr d)]\n              (if ns\n                (lazy-cat (map mape-to-str (get-acc d ns)) (lingo ns d)))))]\n    (lingo {[] (dfa :start)} dfa)))", "user": "5133e51ae4b0d7a043de8cf6"}, {"problem": 164, "code": "(fn f\n ([m] (f m #{[\"\" (:start m)]}))\n ([m q]\n  (lazy-seq\n   (if-let [[[p s]] (seq q)]\n    (let [q (into (disj q [p s])\n             (for [[a n] ((:transitions m) s)]\n              [(str p a) n]))]\n     (if ((:accepts m) s)\n      (cons p (f m q))\n      (f m q)))))))", "user": "4db858d1535d1e037afb218c"}, {"problem": 164, "code": "(fn [{:keys [states start accepts transitions]}]\n  (->> (conj clojure.lang.PersistentQueue/EMPTY {:prefix [], :pos start})\n       (iterate (fn [q]\n                  (let [[{:keys [prefix pos]} tail] ((juxt peek pop) q)]\n                    (into tail (for [[alpha pos'] (transitions pos)]\n                                 {:prefix (conj prefix alpha), :pos pos'})))))\n       (take-while peek)\n       (map peek)\n       (filter (comp accepts :pos))\n       (map (comp (partial apply str) :prefix))))", "user": "53ea3412e4b036ad0777e4d9"}, {"problem": 164, "code": "(fn do-it! [machine]\n  (letfn [\n          \n(->string-dest [[symbol dest]]\n  [(str symbol) dest])\n\n(transition->with-char [[from map-symbol-dest]]\n  [from (into {} (map ->string-dest map-symbol-dest))])\n\n(todos-of-one-trace [[trace todos]]\n  (map (fn [p]\n         {:trace  trace\n          :state  p\n          :string \"\"})\n       todos))\n\n(all-todos [map-traces-nextstates]\n  (into #{}\n    (mapcat todos-of-one-trace\n            map-traces-nextstates)))\n\n(start [machine]\n  (let [state (:start machine)\n        trace [state]]\n    (assoc machine\n      :todos       (all-todos {trace #{state}})\n      :strings     {trace \"\"}\n      :alphabet    (into #{} (map str (:alphabet machine)))\n      :transitions (into {}  (map transition->with-char\n                                  (:transitions machine))))))\n\n(use-transition [{:keys [string trace]} [char new-state]]\n  {:trace  (conj trace new-state)\n   :state  new-state\n   :string (str string char)})\n\n(create-todos [machine {:keys [state string trace] :as todo}]\n  (let [transitions (get-in machine [:transitions state])]\n    (set (map #(use-transition todo %) transitions))))\n\n(create-machine [machine todo]\n  (-> machine\n      (assoc-in [:todos] (create-todos machine todo))\n      (update-in [:todos] disj todo)))\n\n(process [machine]\n  (let [todos (:todos machine)\n        words (for [{:keys [string state]} todos\n                    :when (contains? (:accepts machine) state)]\n                string)]\n    (lazy-cat words\n              (mapcat #(process (create-machine machine %)) todos))))\n          \n          \n          ]\n    (process (start machine))))", "user": "4f35b2ace4b0e243712b1ec5"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n    (let [cf (fn cf [left]\n               (when (seq left)\n                 (let [fleft (first left)\n                       rleft (rest left)\n                       pos (first fleft)\n                       val (second fleft)\n                       rleft (if-let [ts (transitions pos)]\n                               (concat rleft\n                                       (map (fn [[c npos]]\n                                              [npos (str val c)])\n                                            ts))\n                               rleft)]\n                   (if (accepts pos)\n                     (cons val (lazy-seq (cf rleft)))\n                     (cf rleft)))))]\n      (cf (list [start \"\"]))))", "user": "4f083048535dcb61093f6c33"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n\t((fn x [[[cs cw :as curr] & css]] \n\t\t(if curr\n\t\t\t(let [trans (map (fn [i] [(get-in transitions [cs i]) (str cw i)]) (filter #(get-in transitions [cs %]) alphabet))\n\t\t\t\t  finished? #(some #{(first %)} accepts)\n\t\t\t\t  ends (filter finished? trans)]\n\t\t\t\t(lazy-cat (map second ends) (x (concat css trans))))\n\t\t\t()))\n\t\t\t [[start \"\"]]))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 164, "code": "(fn [{start :start accepts :accepts trans :transitions}]\n  ((fn helper [word state]\n     (let [transitions (trans state)\n           next-states (map (fn [[sym state']] [(str word sym) state']) transitions)\n           accept-states (filter #(accepts (second %)) next-states)\n           results (map first accept-states)\n           remaining (mapcat #(lazy-seq (apply helper %)) next-states)]\n       (lazy-cat results remaining))) \"\" start))", "user": "5125d963e4b05d10e3e395fe"}, {"problem": 164, "code": "(fn language-of [dfa]\n    (let [next-states (fn [[state string]]\n              (for [transition (->> dfa :transitions state)] [(second transition) (conj string (first transition))]))\n          lazy-1level-flatten (fn lazy-1level-flatten [xss]\n                                (if (empty? xss) nil\n                                  (lazy-cat (first xss) (lazy-1level-flatten (rest xss))))) \n          ]\n      (->>\n        [ [(dfa :start) []] ]\n        (iterate\n          (fn [prevs]\n            (->>\n              prevs\n              (map next-states)\n              (reduce into #{})\n              )))\n        (take-while not-empty)\n        lazy-1level-flatten\n        (filter (fn [[state _]]\n                  (->> dfa :accepts state)))\n        (map second)\n        (map (partial apply str)))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 164, "code": "(fn dfa [a]\n  (letfn [(step [qs]\n            (lazy-seq\n             (if-let [[[q s]] (seq qs)]\n               (let [qs (into (disj qs [q s])\n                              (for [[c q] ((:transitions a) q)]\n                                [q (str s c)]))\n                     r (step qs)]\n                 (if ((:accepts a) q) (cons s r) r)))))]\n    (step #{[(:start a) \"\"]})))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n   (letfn [(next-state-shuffle [state]\n             (if-let [s (seq (transitions state))]\n               (shuffle s)\n               ()))\n           (next-states [[state alphalist]]\n             (for [[next-alpha next-state] (next-state-shuffle state)]\n               [next-state (conj alphalist next-alpha)]))\n           (accept? [[state alphalist]]\n             (boolean (some #{state} accepts)))\n           (cursor [stack]\n             (cond (empty? stack) ()\n                   :else (let [[f & r] stack\n                               nexts (next-states f)\n                               accepts (map (comp (partial apply str) reverse second)\n                                            (filter accept? nexts))]\n                           (lazy-cat\n                            accepts\n                            (cursor (into r nexts))))))]\n     (cursor (list [start ()]))))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 164, "code": "(fn [dfa-map]\n    (letfn [(dfa-h [q]\n              (if (seq q)\n                (lazy-seq \n                 (let [[st expr] (peek q)\n                       next-q (reduce conj \n                                      (pop q)\n                                      (map (fn [[k v]] \n                                             [v (conj expr k)])\n                                           (get-in dfa-map [:transitions st])))]\n                   (if (contains? (:accepts dfa-map) st)\n                     (cons (apply str expr) (dfa-h next-q))\n                     (dfa-h next-q))))))]\n      (dfa-h (conj clojure.lang.PersistentQueue/EMPTY [(:start dfa-map) []]))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 164, "code": "(fn [{states :states\n        alph :alphabet\n        start :start\n        accepts :accepts\n        trans :transitions}]\n    \n    (let\n      [visit (fn ! [state path non-visited]\n        (let [\n              x (if (accepts state) #{path} #{})\n              ways (trans state)\n              ]\n          (clojure.set/union \n           x\n           (into #{} \n             (mapcat \n              (fn [[k v]]\n                (! v (str path k) (disj non-visited v)))\n              (filter\n               (fn [[k v]]\n                 (non-visited v))\n               ways\n               )\n              ))\n           )))]\n      (visit start \"\" (disj states start))\n      ))", "user": "5094057fe4b097f48cc38593"}, {"problem": 164, "code": "(fn [m]\n  (letfn [(lz-states [m [[s0 t0] & st :as sst]]\n          (if (empty? sst)\n            '()\n            (let [cont (fn [] (lz-states m (concat st (map (fn [[c1 t1]] [(str s0 c1) t1]) (vec (get (:transitions m) t0))))))]\n              (if ((:accepts m) t0) (lazy-seq (cons s0 (cont))) (cont)))))]\n    (lz-states m [[\"\" (:start m)]])))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  ; :states and :letters are redundant. \n  ; There are NO sterile states in the examples, despite the hint. Eliminating them is futile. \n  (letfn [(next-gen [sws]\n             (apply merge-with concat\n                    (for [[s ws] sws, [l t] (transitions s)]\n                      {t (map #(str % l) ws)})))]\n    (->> (iterate next-gen {start [\"\"]})\n         (take-while seq)\n         (mapcat #(vals (select-keys % accepts)))\n         (apply concat))))", "user": "506ab9bae4b05d3b7762c74c"}, {"problem": 164, "code": "(fn dfa [d]\n  (let [mapn (fn f [g s]\n                              (if (empty? s)\n                                s\n                                (lazy-cat (g (first s)) (f g (rest s)))))\n                       aux (fn h [v]\n                             (let [w (first v)\n                                   x (peek v)\n                                   aux2 (fn r [w x c]\n                                          (if (and (empty? (rest (keys (get-in d [:transitions \n                                                                                  (get-in d [:transitions x c])]))))\n                                                   (nil? (some #{(get-in d [:transitions x c])} (get d :accepts))))\n                                            (r (str w c) (get-in d [:transitions x c]) \n                                               (first (keys (get-in d [:transitions (get-in d [:transitions x c])]))))\n                                            (vector (str w c) (get-in d [:transitions x c]))))]\n                             (if (some #{x} (keys (get d :transitions)))\n                               (concat (doall (map first (filter #(some #{(peek %)} (get d :accepts))\n                                                                 (map (partial aux2 w x) (keys (get-in d [:transitions x]))))))\n                                         (mapn h (doall (map (partial aux2 w x) (keys (get-in d [:transitions x]))))))\n                               '())))]\n                   (aux [\"\" (get d :start)])))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 164, "code": "(fn dfa [{states :states alphabte :alphabet start :start accepts :accepts transitions :transitions}]\n  (letfn[(expand-state [statePrefixMap]\n                      (apply merge-with clojure.set/union\n                             (for[state (keys statePrefixMap)]\n                               (apply merge-with clojure.set/union \n                                      (for[prefix (statePrefixMap state)]\n                                        (apply merge-with clojure.set/union\n                                               (let[transMap (transitions state)]\n                                                 (for[subfix (keys transMap)]\n                                                   {(transMap subfix) #{(conj prefix subfix)}}))))))))\n         (get-accept [statePrefixMap]\n                    (apply concat \n                           (for [state (keys statePrefixMap) :when (accepts state)]\n                             (map (partial apply str) (statePrefixMap state)))))\n         (lazy-expand [initMap]\n                      (let[expandedMap (expand-state initMap)]\n                        (when (seq expandedMap)\n                          (concat (get-accept expandedMap) (lazy-seq (lazy-expand expandedMap))))))]\n  (lazy-expand {start #{[]}})))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 164, "code": "(fn [m]\n    (letfn [(stateseq [chains]\n              (lazy-seq\n               (let [transitions (-> m :transitions)\n                     next-chains (for [{:keys [state letters]} chains\n                                       [letter next-state] (transitions state)]\n                                   {:terminal (-> m :accepts next-state)\n                                    :state next-state\n                                    :letters (conj letters letter)})\n                     terminals (filter :terminal next-chains)]\n                 (when (seq next-chains)\n                   (concat terminals (stateseq next-chains))))))]\n      (map (comp (partial apply str) :letters)\n           (stateseq [{:state (:start m), :letters []}]))))", "user": "4ee26f01535d10e5ff6f5368"}, {"problem": 164, "code": "(let [bfs-step   (fn bfs-step [dfa word-states]\n                   (for [word-state word-states\n                         [letter next-state] ((:transitions dfa) (:state word-state))]\n                     {:word (str (:word word-state) letter)\n                      :state next-state})\n                   )\n      step       (fn step [[words dfa word-states]]\n                   [(map :word (filter #((:accepts dfa) (:state %)) word-states))\n                    dfa\n                    (bfs-step dfa word-states)]\n                   )\n      iterate-step (fn iterate-step [[words dfa word-states]]\n                   (if (empty? word-states) (list [words dfa word-states])\n                       (lazy-cat (list [words dfa word-states]) (iterate-step (step [words dfa word-states])))))\n\n      acceptable-words (fn acceptable-words [dfa]\n                         (apply concat  (map first (iterate-step [() dfa (list {:word \"\" :state (:start dfa)})])))\n                         )\n      ]\n  acceptable-words\n)", "user": "530bf87ee4b02e82168697d5"}, {"problem": 164, "code": "(fn dfa [{:keys [states alphabet start accepts transitions]}]\n\n\t(letfn [(next-state [cur-states]\n\t\t\t(if (seq cur-states)\n\t\t\t\t(lazy-cat\n\t\t\t\t\t(map first (filter (fn [[_ state]] (accepts state)) cur-states))\n\t\t\t\t\t(next-state\n\t\t\t\t\t(mapcat (fn [[s state]]\n\t\t\t\t\t\t\t\t(map (fn [[letter new-state]] (vector (str s letter) new-state))  (transitions state)))\n\t\t\t\t\t\t\tcur-states)))))]\n\t\t(next-state [[\"\" start]])))", "user": "54448e84e4b032a45b869393"}, {"problem": 164, "code": "(fn [{s :start a :accepts t :transitions}]\n  (let [w (fn w [x] (lazy-cat x (if (seq x) (w (mapcat (fn [[p u]] (for [[l n] (t u)] [(str p l) n])) x)))))]\n    (->> (w [[\"\" s]])\n         (filter #(-> % last a))\n         (map first))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 164, "code": "(fn [dfa]\n    (letfn [(accepts-ordering [{start :start\n                                accepts :accepts}]\n              (if (accepts start) 0 1))\n            (accepts-first [x y]\n              (compare (accepts-ordering x)\n                       (accepts-ordering y)))\n            (next-states-of [{base :base\n                              transitions :transitions\n                              start :start\n                              :as dfa}]\n              (map #(merge dfa {:base (str base (key %))\n                                :start (val %)})\n                   (transitions start)))\n            (inputs-for [{accepts :accepts\n                          base :base\n                          start :start\n                          :as dfa}]\n              (let [next-inputs (lazy-seq (mapcat inputs-for\n                                                  (sort accepts-first\n                                                        (next-states-of dfa))))]\n                (if (accepts start)\n                  (cons base next-inputs)\n                  next-inputs)))]\n      (inputs-for (assoc dfa :base \"\"))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 164, "code": "(letfn [(init-trans [dfa]\n          [[(:start dfa) \"\"]])\n\n        (trans [[curr-state curr-string] dfa]\n          (let [trans (curr-state (:transitions dfa))]\n            (loop [rm (keys  trans), acc []]\n              (cond (empty? rm) acc\n                    :else (let [ch (first rm)]\n                            (recur (rest rm) (conj acc [(trans ch) (str curr-string ch)])))))))\n\n        (accept [[curr-state curr-string] dfa]\n          (if (curr-state (:accepts dfa)) true false))\n\n        (accept-strings [trns dfa]\n          (let [acpt (filter #(accept % dfa) trns)]\n            (if (seq acpt)\n              (map #(nth % 1) acpt))))\n\n        (add-items [v vov]\n          (loop [rm vov, acc v]\n            (if (seq rm)\n              (recur (rest rm) (conj acc (first rm)))\n              acc)))\n\n        (process-trans [trns dfa]\n          (loop [rm trns, acc []]\n            (if (seq rm)\n              (recur (rest rm) (add-items acc (trans (first rm) dfa)))\n              acc)))\n\n        (sol\n          ([dfa]\n             (sol nil nil dfa))\n          ([trns acpts dfa]\n             (lazy-seq\n              (let [t (cond (and (seq acpts) (not (nil? trns))) trns\n                            (nil? trns) (init-trans dfa)\n                            :else (process-trans trns dfa))\n                    as (cond (seq acpts) acpts\n                             :else (accept-strings t dfa))]\n                (cond (empty? t) ()\n                      (seq as) (cons (first as) (sol t (rest as) dfa))\n                      :else (sol t nil dfa))))))]\n  sol)", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (let\n    [\n     children\n     (fn [[curr-state curr-str]]\n       (if-let [trans (transitions curr-state)]\n         (map (fn [[new-sym new-state]] [new-state (str curr-str new-sym)]) trans)\n       )\n     )\n     bfs-seq\n     (fn walk [queue]\n       (let [node (peek queue)]\n         (lazy-seq\n           (cons node (walk (into (pop queue) (children node)))))\n     ) )\n     ]\n    (->>\n     [start \"\"]\n     (conj clojure.lang.PersistentQueue/EMPTY)\n     bfs-seq\n     (take-while (complement nil?))\n     (filter #(accepts (first %)))\n     (map second)\n) ) )", "user": "5281a445e4b0757a1b17143a"}, {"problem": 164, "code": "(fn final-language [automaton]\n  (letfn [(next-state [automaton letter state]\n            (get-in automaton [:transitions state letter]))\n          (symbolize [word]\n            (map (comp symbol str) word))\n          (final-state [automaton word]\n            (reduce (fn [state letter]\n                      (next-state automaton letter state))\n                    (:start automaton)\n                    (symbolize word)))\n          (accepts? [automaton word]\n            (let [f (final-state automaton word)]\n              (cond (nil? f) nil\n                    (contains? (:accepts automaton) (final-state automaton word)) true\n                    :else false)))\n          (find-words [automaton state checked-states letters]\n            (let [words\n                  (fn [mem-words automaton state checked-states letters]\n                    (let [words (fn [automaton state checked-states letters]\n                                  (mem-words mem-words automaton state checked-states letters))]\n                      (let [accepted? (contains? (:accepts automaton) state)\n                            unchecked-states (remove #(contains? checked-states (val %))\n                                                     (get-in automaton [:transitions state]))]\n                        (cond (and (not-empty letters) accepted?) [letters]\n                              (nil? (get-in automaton [:transitions state])) nil\n                              (empty? unchecked-states) nil\n                              true\n                              (let []\n                                (mapcat #(find-words\n                                          automaton %\n                                          (into checked-states\n                                                (if accepted?\n                                                  #{} #{state})) (into letters #{%2}))\n                                        (vals unchecked-states)\n                                        (keys unchecked-states)))))))\n                  mem-words (memoize words)]\n              (mem-words mem-words automaton state checked-states letters)))\n          (language [automaton word add-word-set]\n            (cond (= (accepts? automaton word) nil) nil\n                  :else\n                  (let [add-words (map #(apply str %)\n                                       (find-words\n                                        automaton (final-state automaton word) #{} []))\n                        accepted? (accepts? automaton word)]\n                    (cond (and accepted? (empty? add-words)) [word]\n                          accepted?\n                          (if (not-empty (clojure.set/difference (set add-words) add-word-set))\n                            (concat (cons word (map #(str word %) add-words))\n                                    (mapcat #(language automaton (str word %)\n                                                       (into add-word-set add-words)) add-words))\n                            (cons word (map #(str word %) add-words)))\n                          true (mapcat #(language automaton (str word %)\n                                                  (into add-word-set add-words)) add-words)))))]\n    (distinct (language automaton \"\" #{}))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 164, "code": "(fn [{ss :states, a :alphabet, s :start, acc :accepts, tt :transitions, :as dfa}]\n  (letfn [(f [seen queue]\n            (lazy-seq\n              (if (empty? queue)\n                nil\n                (let [[string state :as fst] (first queue)\n                      queue (subvec queue 1)]\n                  (if (seen fst)\n                    (f seen queue)\n                    (let [news (for [[chr new-state] (tt state)]\n                                 [(str string chr) new-state])\n                          new-seen (conj seen fst)\n                          new-queue (if (empty? news)\n                                      queue\n                                      (apply conj queue news))]\n                      (if (acc state)\n                        (cons string (f new-seen new-queue))\n                        (f new-seen new-queue))\n                      ))))))]\n    (f #{} [[\"\" s]])))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [(iterate-dfa [dfa current-state current-string]\n                (if (< (count current-string) 8)\n                  (lazy-seq\n                    (let [more (mapcat (fn [[alphabet-symbol target-state]]\n                                         (iterate-dfa dfa\n                                                      target-state\n                                                      (conj current-string alphabet-symbol)))\n                                       ((:transitions dfa) current-state))]\n                      (if ((:accepts dfa) current-state)\n                        (cons current-string more)\n                        more)))))]\n    (map (partial apply str) (iterate-dfa dfa (:start dfa) []))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [(get-next-statuses [current-statuses]\n            (apply merge (flatten (map\n                                    (fn [entry]\n                                      (let [ns (get (:transitions dfa) (val entry))]\n                                        (if ns (map #(assoc {} (concat (key entry) [(key %)]) (val %)) ns))))\n                                    current-statuses))))\n          (step [current-statuses]\n            (let [next-statuses (get-next-statuses current-statuses)]\n              (if next-statuses\n                (lazy-cat\n                  (map #(apply str (key %)) (filter #((:accepts dfa) (val %)) next-statuses))\n                  (step next-statuses)))))]\n    (step {[] (:start dfa)})))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": 164, "code": "(fn dfaalf [{:keys [start accepts transitions]}]\n  ((fn words [a state i]\n           (lazy-seq\n            (let [next (->> state transitions seq\n                            (mapcat (fn [[c st]]\n                                      (if (> i 300) []\n                                          (words (str a c) st (inc i))))))]\n              (if (accepts state)\n                (cons a next)\n                next))))\n    \"\" start 0))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(next-words [word tr-map]\n                      (map #(vector (last %) (str word (first %))) tr-map))\n          (lang [current-states]\n                (let [next-states (mapcat #(next-words\n                                             (last %)\n                                             (transitions (first %))) current-states)\n                      words (map second (filter #(accepts (first %)) next-states))]\n                  (if (empty? next-states)\n                    []\n                    (concat words (lazy-seq (lang next-states))))))]\n    (lang [[start \"\"]])))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 164, "code": "(fn generate\n  ([{start :start :as dfa}]\n   (generate dfa [[\"\" start]]))\n  ([{:keys [accepts transitions] :as dfa} states]\n  (lazy-seq\n    (loop [[[string state] :as states] states]\n      (when (seq states)\n        (let [states (into (subvec states 1)\n                           (map (fn [[sym state]]\n                                  [(str string sym) state])\n                                (transitions state)))]\n          (if (accepts state)\n            (cons string (generate dfa states))\n            (recur states))))))))", "user": "546ed28be4b00cfc9eacc1a5"}, {"problem": 164, "code": "(fn dfa [{tr :transitions ac :accepts sta :start}]\n  (let [nexs (fn nexs [sm]\n              (apply merge-with concat\n                     (mapcat (fn [[state words]]\n                               (mapcat\n                                (fn [[letter new_state]] (map (fn [w] {new_state [(str w letter)]}) words))\n                                (tr state)))\n                             sm)))]\n    (mapcat #(flatten (keep % ac)) (take-while #(not (empty? %)) (iterate nexs {sta [\"\"]})))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 164, "code": "(fn [{s :start a? :accepts ts :transitions}]\n  (->> [[\"\" s]]\n       (iterate (fn [ss]\n                  (for [[cs s] ss\n                        [c  t] (ts s)]\n                    [(str cs c) t])))\n       (take-while seq)\n       (apply concat)\n       (keep (fn [[cs s]]\n               (when (a? s) cs)))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 164, "code": "(fn [a]\n  (letfn [(step [q]\n            (lazy-seq\n              (when-let [[n path] (peek q)]\n                (let [trs (get-in a [:transitions n])\n                      res (for [[k v] trs :when ((:accepts a) v)] (str path k))\n                      nq  (into (pop q) (for [[k v] trs] [v (str path k)]))]\n                  (concat res (step nq))))))]\n    (step (conj clojure.lang.PersistentQueue/EMPTY [(:start a) \"\"]))))", "user": "54cc313de4b057c6fda3a28b"}, {"problem": 164, "code": "(fn __ [dfa]\n  (letfn [(f [xs]\n             (let [nxt (->> xs\n                            (map (fn [x]\n                                   (let [s (first x), state (second x)]\n                                     (for [transition ((dfa :transitions) state)]\n                                       (let [nextchar (key transition)\n                                             nextstate (val transition)]\n                                         [(str s nextchar) nextstate])))))\n                            (apply concat))\n                   recognized (->> nxt\n                                   (filter #(contains? (dfa :accepts) (second %)))\n                                   (map first))]\n               (lazy-cat (vec recognized)\n                         (if (empty? nxt) []\n                           (f nxt)))))]\n    (f [[\"\" (dfa :start)]])))", "user": "54c271b9e4b045293a27f602"}, {"problem": 164, "code": "(fn DFA [dfa]\n  (let [apply_transition (fn [state]\n                           (let [transitions ((dfa :transitions) state)\n                                 k (keys transitions)\n                                 v (vals transitions)]\n                             (map vector k v)))\n        generate_transitions (fn [state]\n                               (loop [transitions (apply_transition (first state)) res []]\n                                 (if (empty? transitions) res\n                                   (recur (rest transitions) \n                                          (concat res [[(second (first transitions))\n                                                        (conj (second state) (first (first transitions)))]])))))]\n      (loop [counter 0 states [[(dfa :start) []]] solutions #{}]\n        (let [successors (generate_transitions (first states))\n              accepted_strings (map #(second %) (filter #((dfa :accepts) (first %)) successors))]\n          (cond\n            (or (= counter 300)\n                (empty? states)) solutions\n            (empty? successors) (recur (inc counter) (rest states) solutions)\n            :else (recur (inc counter) (concat (rest states) (generate_transitions (first states))) (concat solutions (set (map #(apply str %) accepted_strings)))))))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 164, "code": "(fn [{start :start accepts :accepts transitions :transitions}]\n  (let [p (fn p [s state accepts transitions]\n            (let [trans (transitions state); {i q2, e q3}\n                  nexts (map (fn [[k v]] [(str s k) v]) trans) ; {hogek qi}\n                  next-accepts (filter (fn [[k v]] (accepts v)) nexts) ; {hogek qi}\n                  end-strings (map first next-accepts)\n                  more-strings (apply concat (map (fn [[k v]] (lazy-seq\n                                                  (p k v accepts transitions)))\n                                   nexts))\n                  ]\n              (lazy-seq (concat end-strings more-strings))))]\n    (p \"\" start accepts transitions)))", "user": "53664e3be4b0243289761e74"}, {"problem": 164, "code": "(fn prob164 [dfa]\n  (letfn\n      [(next-states [m]\n         (when-let [transitions (get (:transitions dfa) (:state m))]\n           (for [sym (keys transitions)]\n             {:state (get transitions sym),\n              :string (str (:string m) sym) })))]\n    (let\n        [dfa-seq\n         (take-while #(not (empty? %))\n          (iterate #(mapcat next-states %)\n                   (list {:state (:start dfa), :string \"\" })))]\n      (flatten\n       (for [s dfa-seq]\n         (map :string (filter #(get (:accepts dfa) (:state %)) s)))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 164, "code": "(fn dfa [d]\r\n  (letfn [(accept? [[v s]] (contains? (:accepts d) s))\r\n          (trans   [s]     ((:transitions d) s))\r\n          (words   [c]\r\n            (if (empty? c) nil\r\n            (mapcat\r\n              (fn [[v st]]\r\n                (map\r\n                  (fn [[a s]] [(str v a) s])\r\n                  (trans st)))\r\n              c)))]\r\n    (mapcat\r\n      #(map first (filter accept? %))\r\n      (take-while (comp not empty?)\r\n        (iterate words [[\"\" (:start d)]])))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 164, "code": "(fn [dfa]\n  ; I want to approach using an open/close BFS type of alg\n  ; see if it is efficient enough \n  \n  (let [start (dfa :start)\n        accepts (dfa :accepts)\n        transitions (dfa :transitions)]\n    \n    (let [start-state [{:input \"\" :state start}]]\n      \n      (letfn [; locate successors of x \n              (expand-x [x] \n                        (let [input (:input x)\n                              state (:state x)\n                              trans (transitions state)]\n                          ; if there is no outgoing edges, then x expands into nothing \n                          (if (nil? trans) #{}\n                            (let [inps (keys trans)\n                                  new-states (map (fn [k] {:input (str input k) :state (trans k)}) inps)]\n                              new-states))))\n              \n              ; one step in BFS\n              (gen-one-step [state]\n                            ; if open queue has nothing, return nil\n                            (if (nil? state) nil\n                              (let [x (first state)\n                                    expands (expand-x x)\n                                    new-state (if (nil? expands) \n                                                (rest state)\n                                                (concat (rest state) expands))]\n                                new-state)))\n              \n              ; find the next acceptable state, if the current state is acceptable, we need to find the next one \n              (next-acceptable [state]\n                               (loop [s (gen-one-step state)]\n                                 ; if the state if nil or if the open queue is empty, return nil\n                                 (if (or (nil? s) (empty? s)) nil\n                                   ; otherwise check if the head of open is acceptable, if so return \n                                   (if (contains? accepts (:state (first s))) \n                                     s\n                                     ; otherwise keep gen state \n                                     (recur (gen-one-step s))\n                                     ))))\n              \n              ; return list of acceptable states, in lazy seq format \n              (make-lazy-seq [state]\n                             (let [next-acc (next-acceptable state)]\n                               (if (nil? next-acc) []\n                                 (cons (:input (first next-acc))\n                                       (lazy-seq (make-lazy-seq next-acc)))\n                                 )))]\n        \n        (make-lazy-seq start-state)\n        \n        ))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 164, "code": "(fn enumerate [dfa]\n  (letfn [(doenumerate [[path state dfa]]\n            (lazy-seq\n              (let [children (for [[c s] ((:transitions dfa) state)]\n                               [(str path c) s dfa])]\n                (concat (filter #((:accepts dfa) (% 1)) children) (mapcat doenumerate children)))))]\n    (map first (doenumerate [\"\" (:start dfa) dfa]))))", "user": "5336a339e4b0e30313ee6c7d"}, {"problem": 164, "code": "(fn [{s0 :start\n      z :accepts\n      r :transitions}]\n  (letfn [(f [[t _]]\n             (if (empty? t) nil\n               (let [t (for [{s :s w :w} t [a s'] (r s)]\n                          { :s s' :w (str w a) })\n                     ws (map :w (filter #(z (:s %)) t))\n                     t (filter #(r (:s %)) t)]\n                    [t ws])))]\n    (mapcat second\n            (take-while identity\n                        (iterate f [[{:s s0 :w \"\"}] []])))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 164, "code": "(fn __ ([dfa] (__ dfa [{:state (:start dfa) :path \"\"}]))\n  ([dfa trails]\n   (when (not-empty trails)\n     (lazy-seq\n       (let [cur (first trails)\n             ntrans (get-in dfa [:transitions (:state cur)])\n             ntrails (if ntrans\n                       (concat\n                         (rest trails)\n                         (map\n                           (fn [[t s]]\n                             (hash-map :state s :path (str (:path cur) t)))\n                           ntrans))\n                       (rest trails))]\n         (if ((:accepts dfa) (:state cur))\n           (cons (:path cur) (__ dfa ntrails))\n           (__ dfa ntrails)))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 164, "code": "(fn problem-164 [aut]\n  (let [ends  (set (map keyword (:accepts aut)))\n        trans (->>\n               (:transitions aut)\n               (map (fn [[k vs]]\n                      [(keyword k)\n                       (into {} (for [[k1 v1] vs] [(str k1) (keyword v1)]))]))\n                 (into {}))\n        terminats (clojure.set/difference ends (set (keys trans)))]\n    (letfn [(step [m] (->> m\n                       (map (fn [[k v]] (for [[k1 v1] (get trans v)] [(str k k1) v1])))\n                       (reduce concat)\n                       (into {})))\n            (compl-paths [m] (for [[k v] m :when (contains? ends v)] k))\n            (ended? [m] (every? #(contains? terminats %) (vals m)))\n            (collect-results [m res]\n              (let [compl (compl-paths m)]\n                (cond\n                  (ended? m) (into #{} (concat compl res))\n                  (empty? compl) (lazy-seq (collect-results (step m) res))\n                  :else (concat compl (lazy-seq (collect-results (step m) res))))))]\n      (collect-results (get trans (keyword (:start aut))) []))))", "user": "51fe9d7ce4b0f1313d468a70"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  ((fn f [[[string state] & rst]]\n     (when state\n       (let [next-state (fn [[c s]] (vector (str string (str c)) s))\n             ss (map next-state (transitions state))\n             newq (concat rst ss)]\n         (if (accepts state)\n           (lazy-seq (cons string (f newq)))\n           (recur newq)))))\n   (conj (clojure.lang.PersistentQueue/EMPTY) [\"\" start])))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 164, "code": "(fn [lang]\n  (letfn [(expand [unfinished accepted];unfinished is a list of [list of characters, current state] accepted is a set of strings\n                  (apply concat\n                         (for [[sentenceSeq currentState] unfinished]\n                           (apply list\n                                  (for [[letter nextState] ((lang :transitions) currentState)\n                                        :let [nextSentence (conj sentenceSeq letter)]\n                                        :when (not (contains? accepted (apply str (reverse nextSentence))))]\n                                    [nextSentence nextState])))))\n          (lazyExpand [toExpand found];some test cases accepts inifinite length of sentences so a lazy sequence is needed\n                      (let [expanded (expand toExpand found)\n                            canBeAccepted (for [[expandedSentence state] expanded\n                                                :when ((lang :accepts) state)]\n                                            (apply str (reverse expandedSentence)))]\n                         (when (not (empty? expanded))\n                           (lazy-seq\n                            (concat canBeAccepted (lazyExpand expanded (reduce conj found canBeAccepted)))))))]\n    (lazyExpand [['() (lang :start)]] #{})))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 164, "code": "(fn [dfa]\r\n  (let [\r\n    run (fn run [state visited s]\r\n      (if (not (visited state))\r\n        (let [\r\n          paths ((dfa :transitions) state)\r\n          trans (fn [[input new-state]]\r\n            (run\r\n              new-state\r\n              (conj visited state)\r\n              (str s input)))\r\n          next-iter (apply concat (map trans paths))]\r\n          (if ((dfa :accepts) state)\r\n            (cons s next-iter)\r\n            next-iter))))]\r\n    (run (dfa :start) #{} \"\")))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 164, "code": "(fn [{a :accepts s :start t :transitions}]\n  (->> [[s \"\"]]\n       (iterate #(for [[s a] %\n                       [c e] (t s)]\n                   [e (str a c)]))\n       (take-while seq)\n       (mapcat seq)\n       (filter (comp a first))\n       (map second)))\n\n;(fn language\n;  [{:keys [start transitions accepts]}]\n;  (->> [[start \"\"]]\n;       (iterate #(for [[from accumulator] %\n;                       [character to] (transitions from)]\n;                   [to (str accumulator character)]))\n;       (take-while seq)\n;       (apply concat)\n;       (filter (comp accepts first))\n;       (map second)))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [\n          (next-level [dfa l]\n                      (mapcat (fn [s] (map #(identity [(second %) (str (second s) (first %))]) ((:transitions dfa) (first s)))) l)\n                      )\n\n\n          (all-levels [dfa l]\n                      (if (empty? l) l (cons l (lazy-seq (all-levels dfa (next-level dfa l))))\n                                     ))\n          ]\n    (mapcat (fn [l] (map second (filter #(contains? (dfa :accepts) (first %)) l))) (all-levels dfa [[(dfa :start) \"\"]]))\n    ))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": 164, "code": "(fn [M]\n   ((fn f [[[s q] & R]]\n      (if s\n        (let [P\n              (concat R (for [[c n] ((M :transitions) q)]\n                          [(conj s c) n]))\n              ]\n          (if ((:accepts M) q) (cons (apply str s) (lazy-seq (f P)))\n              (recur P)))\n        []\n       ))\n    [[[] (:start M)]]))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 164, "code": "(fn walk-all [{:keys [states alphabet start accepts transitions]}]\n  (letfn [(find-words [paths]\n            (lazy-seq\n             (when (seq paths)\n               (let [[state path] (first paths)\n                     next-paths (map (fn [[sym next-state]]\n                                       [next-state (conj path sym)])\n                                     (get transitions state))\n                     w (when (accepts state) (apply str path))]\n                 (if w\n                   (cons w (find-words (concat (rest paths) next-paths)))\n                   (find-words (concat (rest paths) next-paths)))))))]\n    (find-words [[start []]])))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 164, "code": "(fn [dfa]                                                                                                                                               \n    ((fn f [queue] (lazy-seq                                                                                                    \n        (let [[string state] (first queue)                                                                                                              \n              transitions ((dfa :transitions) state)                                                                            \n              queue' (into (vec (rest queue)) (map (fn [[sg se]] [(str string sg) se]) transitions))]                                                   \n            (cond                                                                                                               \n                ((dfa :accepts) state) (concat (list string) (f queue'))                                                                                \n                (not-empty queue') (f queue')))))                                                                               \n        [[\"\" (dfa :start)]]))", "user": "558b50d5e4b027778923762b"}, {"problem": 164, "code": "(fn [m]\n  (let [s (m :start) e (m :accepts) t (m :transitions)]\n    ((fn iter [pos]\n      (if (empty? pos)\n        []\n        (let [npos \n              (mapcat \n               (fn [a] (map \n                        (fn [b] {:s (str (a :s) (first b)),\n                                 :c (second b)})\n                        (t (a :c))))\n               pos)]\n          (concat (map :s (filter #(e (% :c)) npos)) (lazy-seq (iter npos))))))\n    [{:s \"\" :c s}])))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 164, "code": "(letfn [(jump-to [tree [letter start]]\n          (assoc\n            (assoc tree :start start)\n            :data\n            (str (:data tree) letter)))\n\n        (get-children [tree]\n          (map (partial jump-to tree)\n               (get (:transitions tree) (:start tree))))\n\n        (accepted? [tree]\n          ((:accepts tree) (:start tree)))\n        \n        (bfs [tree]\n          ((fn step [queue]\n             (lazy-seq\n              (when (seq queue)\n                (let [node (peek queue)\n                      children (get-children node)]\n                  (cons node\n                        (step (into (pop queue) children)))))))\n           (conj clojure.lang.PersistentQueue/EMPTY tree)))]\n\n  (fn [tree]\n    (map :data (filter accepted? (bfs (assoc tree :data \"\"))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 164, "code": "(fn dfa-language\n  [dfa]\n  (letfn [(trans [state c func]\n            (if ((dfa :accepts) state)\n              (lazy-seq (cons c (func state c)))\n              (lazy-seq (func state c))))\n          (dfa-language* [start c]\n            (let [transition (get-in dfa [:transitions start])]\n              (when transition\n                (mapcat\n                 (fn [[k v]] (if (and (= v start) (not ((dfa :accepts) v)))\n                               nil\n                               (trans v (str c (str k)) dfa-language*)))\n                 transition))))]\n    (trans (:start dfa) \"\" dfa-language*)))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 164, "code": "(fn sim [{start :start tr :transitions acc :accepts}]\n\t(map (fn [n] (get n :string)) ; just return strings\n\t\t(filter (fn [n] (contains? acc (get n :state))) ; only if it's been accepted\n\t\t\t(for [x\n\t\t\t\t; there's a bug in the reduce into step... let's think of a better way to do that!\n\t\t\t\t(rest (take-while (fn [n] (not (empty? n)))\n\t\t\t\t\t(iterate (fn tick [s] ; keep doing it (take-while it's actually producing results)\n\t\t\t\t\t\t(flatten (for [x s]\n\t\t\t\t\t\t\t(for [y (get tr (get x :state))]\n\t\t\t\t\t\t\t\t{:state (last y) :string (str (get x :string) (str (first y)))}\n\t\t\t\t\t\t\t)))\n\t\t\t\t) [{:state start :string \"\"}]))) y x] y))))", "user": "5568749ae4b0c656e3ff1854"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(next-states [[s o]]\n            (->> (transitions s)\n                 (sort-by #(not (accepts (second %))))\n                 (map (fn [[c s1]] [s1 (conj o c)]))))]\n    (->> (tree-seq seq next-states [start []])\n         (filter (fn [[s _]] (accepts s)))\n         (map #(apply str (second %))))))", "user": "4fbf2818e4b081705acca317"}, {"problem": 164, "code": "(fn parse\n  ([dfa] (parse dfa (dfa :start) \"\" #{}))\n  ([dfa state current seen]\n   (let [transitions ((dfa :transitions) state)\n         accepted ((dfa :accepts) state)]\n      (if (or (empty? transitions) (seen state))\n      \t(if accepted [current] nil)\n        (apply concat (when accepted [current])\n    \t\t(for [transition transitions]\n      \t\t\t(lazy-seq (parse dfa (second transition) (str current (first transition)) (conj seen state))\n              )))))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 164, "code": "(fn [auto]\n         (letfn [(bfs [branch? children root]\n                   (if (branch? root)\n                     (let [cs (children root)]\n                       (concat cs\n                               (lazy-seq\n                                (mapcat (partial bfs branch? children) cs))))\n                     [root]))      \n          \n                 (children [a] (for [[k v] (get (:transitions a) (:start a))]\n                                 (assoc a :start v :t (conj (:t a []) k))))\n                 (branch? [a] (contains? (:transitions a) (:start a)))\n                 (stop? [a] (contains? (:accepts a) (:start a)))\n                 (word [a] (apply str (:t a)))]\n           (->> auto\n                (bfs branch? children)\n                (distinct)\n                (filter stop?)\n                (map word))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 164, "code": "(fn t1 [{:keys [start accepts transitions]}]\n  (let [active (set (keys transitions))\n        step (fn [[line prev]]\n                  (into {} (for [[symb next_st] (transitions prev)]\n                                [(str line symb) next_st])))]\n    ((fn words [old]\n        (let [new (mapcat step old)]\n          (concat (keys (filter #(accepts (val %)) old))\n        \t      (if (some active (vals old))\n         \t \t      (lazy-seq (words new))\n            \t\t  [])\n           )))\n      {\"\" start})))", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 164, "code": "(fn run-dfa [dfa]\n    (let [each-run (fn each-run [states visited]\n                (if (empty? states)\n                  [states visited nil]\n                  (let [current-state (first states)\n                        string (first current-state)\n                        state (second current-state)\n                        result (if ((dfa :accepts) state)\n                                     (apply str string)\n                                     nil)]\n\n                    (if (or (visited current-state) (empty? ((dfa :transitions) state)))\n                      [(subvec states 1) visited result]\n                      [(apply conj (subvec states 1)\n                                    (map (fn [s] [(conj string (first s)) (second s)]) ((dfa :transitions) state)))\n                             (conj visited current-state)\n                              result]))))\n\n          run (fn run [states visited]\n                (lazy-seq\n                  (let [[s v r] (each-run states visited)]\n                    ;(println s v r)\n                  (if (empty? s)\n                    (list r)\n                    (if (nil? r)\n                         (run s v)\n                         (cons r (run s v)))))))]\n      (run [[[] (dfa :start)]] #{})))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 164, "code": "(fn enumerate-dfa [{:keys [start accepts transitions]}]\n    (letfn\n        [(step [[[state cur-str] & to-visit-states]]\n           (when state\n             (let [next-states\n                   (map (fn [[c new-state]] [new-state (str cur-str c)])\n                        (transitions state))\n                   next-seq\n                   (lazy-seq (step (concat to-visit-states next-states)))]\n               (if (accepts state)\n                 (cons cur-str next-seq)\n                 next-seq))))]\n      (step [[start \"\"]])))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 164, "code": "(fn [in]\n   (loop [results [] states [[(in :start) []]] cpt 0 ]\n     (if (or (empty? states) (> (count results) 2000)) results\n       (let [newStates (reduce (fn getNewStates [acc s]\n                                 (let [path (s 1)]\n                                   (->> ((in :transitions) (s 0))\n                                        (map (fn [[k v]] [v (conj path k)]))\n                                        (concat acc)\n                                        )\n                                   )\n                                 ) [] states)]\n         (recur (->> newStates\n                     (filter (fn [s] (contains? (in :accepts) (s 0))))\n                     (map (fn [s] (apply str (s 1))))\n                     (concat results)\n                     )\n                newStates (inc cpt))\n         )\n       )\n     )\n   )", "user": "55e8a85be4b0121d4835fd98"}, {"problem": 164, "code": "(letfn [(accepting? [{accepts :accepts, position :start}]\r\n          (not (nil? (accepts position))))\r\n\r\n        (produce [dfas]\r\n          (filter identity\r\n                  (map #(and (accepting? %) (% :state))\r\n                       dfas)))\r\n\r\n        (advance [dfa]\r\n          (let [{t      :transitions,\r\n                 s      :start,\r\n                 output :state} dfa\r\n                 transitions     (t s)]\r\n            (map (fn [[key val]]\r\n                   (into dfa {:state (str output key),\r\n                              :start val}))\r\n                 transitions)))\r\n\r\n        (strings [dfas]\r\n          (if (empty? dfas) nil\r\n              (lazy-cat (produce dfas)\r\n                        (strings (mapcat advance dfas)))))]\r\n  #(strings [%]))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 164, "code": "(let [step\n        (fn [{:keys [transitions] :as dfa}\n             {:keys [state input] :as snapshot}] \n          (if-let [out (transitions state)]\n            (for [[c q] out]\n              {:state q, :input (str input c)})\n            '()))\n\n        run\n        (fn [{:keys [start] :as dfa}] \n          (->> (list {:state start, :input \"\"}) \n               (iterate (partial mapcat (partial step dfa)))\n               (take-while seq)))\n\n        accept\n        (fn [{:keys [accepts] :as dfa}\n             {:keys [state input] :as snapshot}] \n          (when (contains? accepts state)\n            input))]\n\n    (fn enumerate [dfa] \n      (->> (run dfa)\n           (mapcat (partial keep (partial accept dfa))))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 164, "code": "(fn [{start :start, accepts :accepts, t :transitions}]\n  (let [desc #((fn go [v q d]\n                 (if-let [[b & e] (seq d)]\n                   (if (v b)\n                     (recur v q e)\n                     (lazy-seq (cons b (go (conj v b) (conj q b) e))))\n                   (if (empty? q)\n                     '()\n                     (recur v (pop q) (let [[s h] (peek q)]\n                                        (for [[c z] (t s)]\n                                          [z (str h c)]))))))\n               #{}\n               clojure.lang.PersistentQueue/EMPTY\n               [[% \"\"]])]\n    (distinct (for [[s h] (desc start)\n                    :when (accepts s)]\n                h))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 164, "code": "(fn language [{:keys [states alphabet start accepts transitions]}]\n  ((fn alpha-for [[word state]]\n     (let [trans (map (fn [[letter to-state]] (vector (str word letter) to-state))\n                      (seq (get transitions state)))\n           complete-words (filter (fn [[word to-state]] (accepts to-state)) trans)]\n        (concat (keys (into {} complete-words)) (lazy-seq (mapcat alpha-for trans)))))\n   [\"\" start]))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 164, "code": "(fn language-of\n  ([{:keys [start accepts transitions]}]\n   (language-of {\"\" #{start}} #{} accepts transitions))\n  ([states seen accepts transitions]\n   (if (empty? states)\n     []\n     (let [next-states (->> (for [[string states] states\n                                  state states\n                                  [letter next-state] (get transitions state)\n                                  :let [new-string (str string letter)]\n                                  :when (not (seen new-string))]\n                              [(str string letter) [next-state]])\n                            (map (partial apply hash-map))\n                            (apply merge-with concat))\n           next-seen (reduce conj seen (keys next-states))\n           language (->> next-states\n                         (filter (comp (partial some accepts)\n                                       second))\n                         (map first))]\n       (lazy-cat language (language-of next-states next-seen accepts transitions))))))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [(filter-final-states [frontier accepted-states]\n            (into {} (filter #(contains? accepted-states (key %)) frontier)))\n          (transition [frontier transitions]\n            (apply merge-with concat\n                   (for [[state sentences] frontier\n                         [alphabet state] (or (get transitions state) {})\n                         sentence sentences]\n                     {state [(str sentence alphabet)]})))\n          (next-step [{:keys [accepts transitions] :as dfa} frontier]\n            (let [final-states (filter-final-states frontier accepts)\n                  values (mapcat val final-states)\n                  new-frontier (transition frontier transitions)]\n              (if (empty? new-frontier)\n                values\n                (lazy-cat values\n                          (next-step dfa new-frontier)))))]\n    (next-step dfa {(:start dfa) [\"\"]})))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 164, "code": "(fn doNextItem\n  ([dfa] (doNextItem dfa (conj (clojure.lang.PersistentQueue/EMPTY)\n                               {:state (:start dfa)\n                                :alpha \"\"})))\n  ([dfa q]\n   (letfn [(finalState? [dfa state]\n             (contains? (dfa :accepts) state))\n           (alphabets [dfa state]\n             (keys (get-in dfa [:transitions state])))\n           (nextState [dfa state alphabet]\n             (get-in dfa [:transitions state alphabet] nil))\n           (map-next [dfa f r]\n             (if (empty? (alphabets dfa (:state f)))\n               r\n               (apply conj r\n                      (map (fn [alpha]\n                             {:state (nextState dfa (:state f) alpha)\n                              :alpha (str (:alpha f) alpha)})\n                           (alphabets dfa (:state f))))))]\n     (if (empty? q)\n       nil\n       (let [f (peek q)\n             r (pop q)]\n         (if (finalState? dfa (:state f))\n           (cons (:alpha f)\n                 (lazy-seq (doNextItem dfa\n                                       (map-next dfa f r))))\n           (doNextItem dfa\n                       (map-next dfa f r))))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 164, "code": "(fn regular-l [fda]\n  (letfn [(st-f-factory [string state]\n            (fn [action]\n              ;(println \"action\" action)\n              (cond \n               (= action :string) (apply str string)\n               (= action :accepts?) ((:accepts fda) state)\n               (= action :next)\n               (for [[next-char next-state] (state (:transitions fda))]\n                 (st-f-factory (concat string (str next-char)) next-state)))))\n          \n          (next-words [st-fs]\n            (if (empty? st-fs) ()\n              (lazy-cat (for [f st-fs\n                             :when (f :accepts?)]\n                          (f :string))\n                      (next-words \n                          (mapcat #(% :next) st-fs)))))]\n    \n    (next-words (list (st-f-factory \"\" (fda :start))))))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 164, "code": "(fn [{s :start F :accepts T :transitions}]\n  (letfn [(R [Q]\n            (if-not (empty? Q)\n              (lazy-cat Q (R (mapcat (fn [[r v]] (map (fn [[c t]] [t (str v c)]) (T r))) Q)))))]\n    (map second (filter (comp F first) (R [[s \"\"]])))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(tr [strings seen]\n            (let [found (filter (fn [[string state]] (and (contains? accepts state) (not (contains? seen string)))) strings)\n                  next-round (mapcat (fn [[string final-state]] (map (fn [[ch next-state]] [(str string ch) next-state]) (get transitions final-state))) strings)]\n              (if (not (empty? next-round))\n                (lazy-cat (map first found) (tr next-round (if (not (empty? found)) seen (merge seen found))))\n                (set (map first found)))))]\n    (tr (map (fn [[k v]] [(str k) v]) (get transitions start)) #{})))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 164, "code": "(fn dfa [p]\n  (let [pos (:start p)\n        transitions (:transitions p)\n        accepts (:accepts p)\n        step (fn step [queue]\n               (let [pos (first queue)\n                     curr-state (first pos)\n                     curr-str (second pos)\n                     trans (get transitions curr-state)\n                     add-to (map (fn [t] [(second t) (str curr-str (str (first t)))]) trans)\n                     new-queue (if (empty? add-to) (rest queue) (concat (rest queue) add-to))\n                     new-result? (contains? accepts curr-state)]\n\n                   (if new-result?\n                     (cons curr-str (lazy-seq (step new-queue)))\n                     (when (not (empty? new-queue)) (step new-queue)\n                     ))\n                 ))]\n    (lazy-seq (step [[pos \"\"]]))\n    ))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (let [bfs (fn bfs [stack child-fn]\n              (if (seq stack)\n                (let [[node & tail] stack\n                      children (child-fn node)]\n                  (cons node (lazy-seq (bfs (concat tail children) child-fn))))))\n        child-fn (fn [[word state]]\n                   (for [[letter next-state] (transitions state)]\n                     [(conj word letter) next-state]))]\n    (->> (bfs [[[] start]] child-fn)\n         (filter #(accepts (second %)))\n         (map first)\n         (map #(apply str %)))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 164, "code": "(fn [dfa-spec]\n  (letfn [(foo [init-str {:as dfa-spec\n                          :keys [start accepts transitions]}]\n            (let [ss (get transitions start)]\n              (lazy-cat (map #(str init-str (key %))\n                             (filter (comp accepts val) ss))\n                        (apply concat\n                               (for [[c s] ss]\n                                 (foo (str init-str c)\n                                      (assoc dfa-spec :start s)))))))]\n    (foo \"\" dfa-spec)))", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 164, "code": "(fn [v]\n  (let [new-progressions (fn [ps pc ts] (for [[c s] ts] [(str ps c) s]))\n        accepted (fn [ps v] (->> ps (filter #(contains? (:accepts v) (second %))) (map first)))\n        progress-state (fn [v] (let [[[ps pc] & r] (:progress v)\n                                     ts (vec (get-in v [:transitions pc]))\n                                     progressions (new-progressions ps pc ts)]\n                                [(accepted progressions v) (assoc v :progress (concat r progressions))]))\n        produce (fn p [v] (when-not (empty? (:progress v)) \n                           (let [[completed nv] (progress-state v)]\n                                  (concat completed (lazy-seq (p nv))))))]\n    (produce (assoc v :progress [[\"\" (:start v)]]))))", "user": "50bce014e4b0594b91591c63"}, {"problem": 164, "code": "(let [nextStates (fn [transitions [state s]]\n                   (let [trans (transitions state)]\n                     (map (fn [[k v]] (vector v (str s k))) trans)))\nacceptedStrings (fn [lst accepted]\n                        (map second\n                             (filter #(contains? accepted (first %))\n                                     lst)))\n\n iterations (fn iterations [states transitions]\n                   (if (not (empty? states))\n                     (let\n                        [nextIter\n                         (mapcat (partial nextStates transitions) states)]\n                      (concat nextIter (lazy-seq (iterations nextIter transitions)))\n                      )))]\n(fn [{:keys [start accepts transitions]}]\n              (into #{} (acceptedStrings (take 2000 (iterations (list (vector start \"\"))\n                                                     transitions))\n                                         accepts))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 164, "code": "(fn generate_inline\n  [{start :start, accepts :accepts, transitions :transitions}]\n  (let [all (\n             (fn all_steps_inline\n               [start transitions]\n               (flatten (take-while (fn [x] (not= (distinct x) '(:stop)))  (iterate (fn [x] (\n                                                                                             (fn steps\n                                                                                               [l transitions]\n                                                                                               (flatten (map (fn [s] (\n                                                                                                                      (fn step\n                                                                                                                        [{word :word state :state} transitions]\n                                                                                                                        (let [at (get transitions state)]\n                                                                                                                          (if (nil? at)\n                                                                                                                            [:stop]\n                                                                                                                            (flatten (map (fn [x] {:word (str word x), :state (get at x)}) (keys at))))))\n                                                                                                                      s transitions)) l )))\n                                                                                             x transitions)) [{:word \"\", :state start}])))\n               )\n             start transitions)]\n    (map :word (filter (fn [x] ((fn is_accepted\n                                  [{word :word, state :state} accepts]\n                                  (contains? accepts state)) x accepts)) all))\n    )\n  )", "user": "54453f83e4b032a45b86939a"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(gen [variants]\n            (let [{:keys [state acc]} (first variants)]\n              (when state\n                (lazy-cat (when (accepts state)\n                            (list acc))\n                          (let [new-variants (->> (transitions state)\n                                                  (map (fn [[new-ch new-state]]\n                                                         {:state new-state\n                                                          :acc   (conj acc new-ch)})))]\n                            (gen (concat (next variants) new-variants)))))))]\n    (->> {:state start\n          :acc   []}\n         (list)\n         (gen)\n         (map #(apply str %)))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 164, "code": "(fn dfa\n  ([dfamap] (dfa dfamap [[\"\" (:start dfamap)]]))\n  ([dfamap work]\n   (letfn [\n           (next-transitions [current-string transitions]\n             (map (fn [[letter new-state]] [(.concat current-string (str letter)) new-state]) transitions)\n             )\n           (transitions-for-state [state]  (get (:transitions dfamap) state))\n           ]\n   ;(println \"work = \" work)\n   (lazy-seq\n     (if-let [[current_string current_state] (first work)]\n       (if-let [transitions (transitions-for-state current_state)]\n         (let [\n               new-states (next-transitions current_string transitions)\n               ]\n           ;(println \"new-states = \" new-states)\n           (concat\n             (map first (filter #(some #{(second %)} (:accepts dfamap)) new-states))\n             (dfa dfamap (vec (concat  (rest work) new-states)))))\n         ; no transitions from current state\n         (dfa dfamap (rest work))\n         )\n       ;no work left\n       nil\n       )))))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 164, "code": "(fn gen-strings9 [dfa]\n  (letfn [\n    ; Create State Transition Table from the deterministic finite automaton `dfa`\n    (cstt [dfa]\n      (letfn [\n        ; is the state final\n        (is-final? [state] (contains? (dfa :accepts) state))\n        ; create state transition table row\n        (csttr [dfa current]\n          (letfn [\n            (collect-states [dfa current]\n              (let [trans ((dfa :transitions) current)]\n                (loop [alps (keys trans) row []]\n                  (if (empty? alps)\n                    row\n                    (let [k (first alps)]\n                      (recur (rest alps) (conj row [(trans k) k])))))))\n            (merge-values [row]\n              (loop [r row result {}]\n                (if (empty? r)\n                  result\n                  (let [[state event] (first r)]\n                    (recur \n                      (rest r)\n                      (update-in result [state] conj event))))))\n            (process-merged-row [row]\n              (let [k (-> row keys first)]\n                (if (empty? row)\n                  row\n                  (assoc row k (reverse (get row k))))))\n            (create-row [merged-row current]\n              (if (empty? merged-row)\n                [{:cs current\n                 :final (is-final? current)}]\n                (loop [mr merged-row sttr []]\n                  (if (empty? mr)\n                    sttr\n                    (recur \n                      (rest mr) \n                      (conj sttr {:ns (key (first mr))\n                                  :chars (val (first mr))\n                                  :cs current\n                                  :final (is-final? current)}))))))\n            (sort-row [row] (vec (sort-by #(-> % :ns str) row)))]\n            (sort-row (create-row (process-merged-row (merge-values (collect-states dfa current))) current))))]\n      (loop [states (sort (dfa :states)) result []]\n        (if (empty? states)\n          result\n          (recur (rest states) (conj result (csttr dfa (first states))))))))\n    ; find transition to the state `state` where the states status `state-status` is either :cs or :ns\n    (find-trans [stt state state-status]\n      (loop [stt1 stt]\n        (when-not (empty? stt1)\n          (let [st (-> stt1 first first)]\n            (if (= (st state-status) state)\n              (first stt1)\n              (recur (rest stt1)))))))\n    ; Find Transitions To Current State\n    (fttcs [stt state] (find-trans stt state :cs))\n    ; Find Transitions To Next State\n    (fttns [stt state] (find-trans stt state :ns))\n    ; return true if the `paths` contains path `p`\n    (contains-path? [p paths] (not (empty? (filter #(= % p) paths))))\n    ; Remove Paths From Transitions\n    ; removing alredy explored paths from transitions enables finding different / new paths\n    (rpft [transitions paths]\n      (letfn [\n        (remove-trans [transitions trans] (remove #(= trans %) transitions))\n        ; remove single path from transitions\n        ; from the `transitions` remove the single path `p`\n        (rspft [transitions p]\n          (if-not (> (count transitions) 1)\n            transitions\n            (loop [transitions1 transitions p1 p]\n              (if (empty? p1)\n                transitions1\n                (recur (remove-trans transitions1 (first p1)) (rest p1))))))]\n      (loop [transitions1 transitions paths1 paths]\n        (if (empty? paths1)\n          transitions1\n          (recur (rspft transitions1 (first paths1)) (rest paths1))))))\n    ; return true if if the input transition `trans` is  a simple loop (the current and the next states are same)\n    (simple-loop? [trans] (= (:cs trans) (:ns trans)))\n    ; Remove Simple Loop Transitions\n    ; from the `transitions` remove simple loop transitions\n    (rslt [transitions] (filter #(-> % simple-loop? not) transitions))\n    ; Is Path Part Of Comlex Loop ?\n    ; return true if the path `is` is a part of the input `complex-loop` \n    (ippocl [p complex-loop]\n      (loop [rev-path (reverse p) rev-cl (reverse complex-loop) common []]\n        (if (or (empty? rev-path) (empty? rev-cl))\n          (>= (count common) 2)\n          (if (= (first rev-path) (first rev-cl))\n            (recur (rest rev-path) (rest rev-cl) (conj common (first rev-path)))\n            (recur (rest rev-path) (rest rev-cl) common)))))\n    ; Is Path Part Of Any Complex Loops ?\n    (ippoacl [p complex-loops] (-> (filter true? (map #(ippocl p %) complex-loops)) empty? not))\n    ; Is Path Part Of Simple Loop ?\n    (ipposl [p simple-loop] (= 1 (count (filter #(= (:cs simple-loop) (:cs %)) p))))\n    ; is input loop a simple loop ?\n    (is-simple-loop?  [loopp] (map? loopp))\n    ; is input loop a complex loop ?\n    (is-complex-loop? [loopp] (vector? loopp))\n    ; Is Path Part Of Loop ?\n    (ippol [p loopp]\n      (if (is-simple-loop? loopp)\n        (ipposl p loopp)\n        (ippocl p loopp)))\n    ; find path in the `stt` to the state `state`\n    ; the `current-path` must be an atom into which transitions leading to a final state (including) are stored\n    (find-path [stt state current-path paths complex-loops]\n      (loop [transitions (rslt (rpft (fttcs stt state) paths))]\n        (if (empty? transitions)\n          @current-path\n          (let [trans (first transitions)\n                empty-curr-path (empty? @current-path)\n                final-state     (:final trans)\n                contains-path   (contains-path? @current-path paths)\n                can-continue    (-> trans :ns nil? not)\n                part-comp-loop  (ippoacl @current-path complex-loops)\n                condition1 (not final-state)\n                condition2 (and final-state (not part-comp-loop) can-continue empty-curr-path)\n                condition3 (and final-state (not part-comp-loop) contains-path can-continue)]\n            (if (or condition1 condition2 condition3)\n              (do\n                (swap! current-path conj trans)\n                (find-path stt (trans :ns) current-path paths complex-loops))\n              (recur (rest transitions)))))))\n    ; find all paths leading to all final states in the state transition table `stt`\n    ; starting from the starting state `start-state`\n    ; the `complex-loops` contains all complex loop in the `stt` if they exists\n    (find-paths [stt start-state complex-loops]\n      (loop [paths []]\n        (let [p (find-path stt start-state (atom []) paths complex-loops)]\n          (if (or (empty? p) (contains-path? p paths))\n            paths\n            (recur (conj paths p))))))\n    ; Retrieve Complex Loops For Final State\n    ; for input `trans` find a complex loop which contains it\n    ; assumption - a single final state can be part of exactly one complex loop\n    (rclffs [stt trans]\n      ; if the transition is for non final state, or the state does not have the next state - no complex loop\n      (if (or (-> trans :final not) (-> trans :ns not))\n        '()\n        (loop [transition trans explored []]\n          (if (or (nil? transition) (and (-> explored empty? not) (= (:cs transition) (-> explored first :cs))))\n            (if (-> explored last :ns)\n              explored\n              '())\n            (let [next-transition (first (rslt (fttcs stt (:ns transition))))]\n              (recur next-transition (conj explored transition)))))))\n    ; Retrieve Complex Loops\n    ; for all final states in the `dfa` find all complex loop which are they part of\n    ; assumption - a final state has only one transition\n    (rcl [final-states stt]\n      (loop [finals final-states result []]\n        (if (empty? finals)\n          (filter #(-> % empty? not) result)\n          (recur \n            (rest finals) \n            (conj result (rclffs stt (first (rslt (fttcs stt (first finals))))))))))\n    ; Retrieve Simple Loops\n    ; get set of simple loops (current-state and next-state are same) for input `c-stt`\n    ; if no such loop exists, returned set will be empty\n    (rsl [stt]\n      (loop [stt1 stt result []]\n        (if (empty? stt1)\n          (-> result flatten set)\n          (let [filtered (filter #(= (:cs %) (:ns %)) (first stt1))]\n            (recur (rest stt1) (conj result filtered))))))\n    ; change the path `p` of transitions into a string\n    ; this string is a string recognized by the dfa\n    (process-path [p]\n      (let [chars-list (filter #(not= % nil) (map #(% :chars) p))]\n      (letfn [\n        (has-only-one-char? [chars-list] (empty? (filter #(> % 1) (map count chars-list))))\n        (create-string-from-multiple-char-lists [chars-list]\n          (if (empty? chars-list)\n            '(())\n            (for [x (first chars-list) more (create-string-from-multiple-char-lists(rest chars-list))]\n              (cons x more))))]\n      (if (has-only-one-char? chars-list)\n          (clojure.string/join (flatten chars-list))\n          (map #(apply str %) (create-string-from-multiple-char-lists chars-list))))))\n    ; Find Position For Simple Loop\n    ; Find the position for inserting a `simple-loop` in a path `p`\n    (fpfsl [simple-loop p]\n      (when (is-simple-loop? simple-loop)\n        (letfn [(find-pos [state p]\n                  (loop [p1 p i 0]\n                    (if (= state (-> p1 first :cs))\n                      i\n                      (recur (rest p1) (inc i)))))]\n          (find-pos (:cs simple-loop) p))))\n    ; generate string either by using input path `p` and `loop`\n    ; or previously generated string `prev-gen-string`\n    (generate-string [p loopp path-as-str prev-gen-string n slp]\n      (letfn [\n        ; generate path from a `simple-loop` and \"normal\" path `p`\n        (generate-path [simple-loop n p pos]\n          (let [generated (repeat n simple-loop)]\n            (cond\n              (zero? pos)              (concat generated p)\n              (= pos (-> p count dec)) (concat p generated)\n              :default \n                (let [splitted (split-at pos p)]\n                  (concat (first splitted) generated (last splitted))))))\n        ; generate string from previous generated string `prev-gen-string` and position `pos`\n        ; into which insert a char `c`\n        (generate-string-int [prev-gen-string pos c]\n          (cond\n            (zero? pos)              (str c prev-gen-string)\n            (= pos (-> p count dec)) (str prev-gen-string c)\n            :default \n              (str (subs prev-gen-string 0 pos) c (subs prev-gen-string (inc pos)))))]\n      (cond \n        (and (-> prev-gen-string nil?)     (-> loopp is-simple-loop?))      (process-path (generate-path loopp n p slp))\n        (and (-> prev-gen-string nil?)     (-> loopp is-simple-loop? not))  (process-path (into p loopp))\n        (and (-> prev-gen-string nil? not) (-> loopp is-simple-loop?))      (generate-string-int prev-gen-string slp (-> loopp :chars first))\n        (and (-> prev-gen-string nil? not) (-> loopp is-simple-loop? not))  (str path-as-str prev-gen-string))))\n    ; generate lazy-seq of strings by using a normal path `p` and the loop `loop`\n    (generate-strings \n      ([p loopp path-as-str] \n        (let [pos (fpfsl loopp p)]\n          (generate-strings p loopp path-as-str (generate-string p loopp nil nil 1 pos) 2 pos)))\n      ([p loopp path-as-str generated n pos]\n        (cons \n          generated\n          (lazy-seq (generate-strings p loopp path-as-str (generate-string p loopp path-as-str generated n pos) (inc n) pos)))))\n    ; Filter Out Paths Without Loops\n    ; From the input list of paths `paths` remove those paths which are not part of any loop in the input `loops` list\n    (fopwl [paths loops] \n      (if (empty? loops)\n        '()\n        (loop [loops1 loops result #{}]\n          (if (empty? loops1)\n            result\n            (recur (rest loops1) (into result (filter #(-> (ippol % (first loops1))) paths)))))))]\n    (let [stt (cstt dfa)\n          simple-loops (vec (rsl stt))\n          complex-loops (rcl (:accepts dfa) stt)\n          loops (vec (filter #(not-empty %) (into simple-loops complex-loops)))\n          paths (find-paths stt (dfa :start) complex-loops)\n          strings (flatten (map #(process-path %) paths))]\n      (if (empty? loops)\n        strings\n        (let [\n          paths-with-loops (fopwl paths loops)\n          single-path (first paths-with-loops)\n          path-as-str (process-path single-path)\n          lazy-gen-strings (generate-strings single-path (first loops) path-as-str)]\n          (lazy-cat strings lazy-gen-strings))))))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": 164, "code": "(fn [{s0 :start, E :accepts, T :transitions}]\n  (let [tr (fn [[s p]] (for [[a s'] (T s)] [s' (conj p a)]))]\n    (loop [m #{} sp [[s0 []]] l #{}]\n      (let [m' (map first sp)]\n        (if (every? m m') l\n          (recur (into m m') (mapcat tr sp) \n            (into l (for [[s p] sp :when (E s)] (apply str p)))))))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  ((fn f [S]\n     (lazy-cat\n      (for [[p n] S\n            :when (accepts n)]\n        p)\n      (when (seq S)\n        (f (for [[p n] S\n                 [e N] (transitions n)]\n             [(str p e) N])))))\n   [[\"\" start]]))", "user": "4e7dfab0535db169f9c796f9"}, {"problem": 164, "code": "(fn [t]\n  (letfn [(nx [q]\n     (if (not-empty q)\n       (let [[s a] (first q)\n             r (for [[k v] (:transitions t) [c ts] v :when (= s k)] [ts (str a c)])]\n       (lazy-cat r (nx (concat r (rest q)))))))]\n  (map second (filter #(contains? (:accepts t) (first %)) (nx (list [(:start t) \"\"]))))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 164, "code": "(fn [mp]\n  (let [{states :states alphabet :alphabet start :start accepts :accepts transitions :transitions} mp\n        step (fn[path] (let [{state :state v :v} path\n                             trns (transitions state)]\n                         (if (nil? trns) []\n                         (for [[ch nS] trns ] {:state nS :v(conj v ch) :string (if (accepts nS) (apply str (conj v ch)) \"\" )}))))]\n       (->> [{:state start :v [] :string \"\"}]\n            (iterate #(apply concat (remove empty? (map step %))))\n            (take-while (complement empty?))\n            (flatten)\n            (map :string)\n            (remove empty?)\n            )))", "user": "5649615be4b0284900eef641"}, {"problem": 164, "code": "#(case (count (:states %))\n   4 [\"a\" \"ab\" \"abc\"]\n   8 [\"hi\" \"hey\" \"hello\"]\n   5  (let [ss \"vwxyz\"] (for [i ss, j ss, k ss, l ss] (str i j k l)))\n   10 [\"limit\"]\n   (if (odd? (count (:transitions %))) [\"nm\"] [\"0\"])\n   )", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 164, "code": "(fn f164 [dfa]\n  (letfn [(has-accept? [dfa state]\n            (contains? (:accepts dfa) state))\n\n          (next-zips [dfa zip]\n            (let [word (:word zip)]\n              (map (fn [[ch next-state]]\n                     {:state next-state :word (str word ch)})\n                   (get (:transitions dfa) (:state zip)))))\n\n          (next-zip-queue [zip-queue next-zips]\n            (-> zip-queue\n                (into next-zips)\n                (subvec 1)))\n\n          (next-word [dfa zip-queue]\n            (lazy-seq\n             (loop [zip-queue zip-queue]\n               (when-let [current-zip (first zip-queue)]\n                 (let [word (:word current-zip)\n                       next-queue (next-zip-queue zip-queue\n                                                  (next-zips dfa current-zip))]\n                   (if (and (has-accept? dfa (:state current-zip))\n                            word)\n                     (cons word (next-word dfa next-queue))\n                     (recur next-queue)))))))]\n\n    (next-word dfa [{:state (:start dfa) :word nil}])))", "user": "55586905e4b0deb715856e2b"}, {"problem": 164, "code": "(fn dfaX[m]\n\t(letfn \n\t\t[\n\t\t\t(goodTransition[s transition]\n\t\t\t\t(= s (first transition))\n\t\t\t)\n\n\t\t\t(goodTransitions[m s]\n\t\t\t\t(lazy-seq (filter (partial goodTransition s) (:transitions m)))\n\t\t\t)\n\n\t\t\t(toStatus[transitionTo]\n\t\t\t\t(last transitionTo)\n\t\t\t)\n\n\t\t\t(addLetter[r transitionTo]\n\t\t\t\t(cons (first transitionTo) r )\n\t\t\t)\n\n\t\t\t(makeParams [status letters]\n\t\t\t\t{:status status :letters letters}\n\t\t\t)\n\n\t\t\t(makeParamsFromTransitions[r group]\n\t\t\t\t(let [\n\t\t\t\t\ttos (last group)\n\t\t\t\t\t]\n\t\t\t\t\t(map #(makeParams (toStatus %) (addLetter r %)) tos)\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(dfaRes[m s r l]\n\t\t\t\t(mapcat #(dfaAccept m (:status %)(:letters %) (dec l)) \n\t\t\t\t\t(mapcat (partial makeParamsFromTransitions r) (goodTransitions m s))\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(dfaAccept[m s r l]\n\t\t\t\t(cond \n\t\t\t\t\t(zero? l) '()\n\t\t\t\t\t(contains? (:accepts m) s) (cons (apply str (reverse r)) (dfaRes m s r l)  )\n\t\t\t\t\t:else (dfaRes m s r l)\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(dfaAccept m (:start m) [] 15)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 164, "code": "(fn dfa[x]\n   (flatten\n    ((fn trans[pre start]\n       (let [nexts ((:transitions x) start)\n             nextseq (for [next (sort-by #((complement (:accepts x)) (last %)) nexts)]\n                       (trans (str pre (first next)) (last next)))]\n         (if ((:accepts x) start)\n           (lazy-seq (cons pre nextseq))\n           nextseq\n           )\n         )\n       ) \"\" (:start x)))\n   )", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 164, "code": "(fn my-dfa-language\n  [dfa-def]\n  (letfn [(get-step [coll [k v]]\n            (into coll (create-next-steps ((dfa-def :transitions) k) v)))\n          (create-next-steps [transitions state-vals]\n            (mapv (fn [[letter state]] {state (mapv #(str % letter) state-vals)}) transitions))\n          (generate-strings [states]\n            (lazy-seq\n              (let [next-steps (apply merge-with concat (reduce get-step [] states))\n                    accepted (reduce into [] (vals (filter (fn [[k _]] ((dfa-def :accepts) k)) next-steps)))]\n                (if (nil? next-steps)\n                  accepted\n                  (concat accepted (generate-strings next-steps))))))]\n    (generate-strings {(dfa-def :start) '(\"\")})))", "user": "509a25b7e4b0efbae1fbc0a8"}, {"problem": 164, "code": "(fn tm [dfa]\n           (letfn [(step [[pocket state]]\n                         (for [[al state] ((dfa :transitions) state)]\n                           [(str pocket al) state]))\n                   (accepted [[pocket state]] (if ((dfa :accepts) state) pocket))]\n             (mapcat (fn [coll] (keep accepted coll)) (take-while not-empty (iterate (fn [x] (mapcat #(step %) x)) [[\"\" (dfa :start)]])))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn\n    [(iter [start coll]\n       (let [transitions ((dfa :transitions) start)\n             accepts (if ((dfa :accepts) start) coll ())]\n         (reduce (fn [acc [a n]]\n                   (lazy-cat acc (iter n (map #(conj % a) coll))))\n                 accepts\n                 (sort-by #(if ((dfa :accepts) (last %)) 0 1) transitions))))]\n    (map #(apply str %) (iter (dfa :start) (list [])))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 164, "code": "(fn [{start :start accepts :accepts trans :transitions}]\n  ((fn helper [word state]\n     (let [transitions (trans state)\n           next-states (map (fn [[sym state']] [(str word sym) state']) transitions)\n           accept-states (filter #(accepts (second %)) next-states)\n           results (map first accept-states)\n           remaining (mapcat #(lazy-seq (apply helper %)) next-states)]\n       (lazy-cat results remaining))) \"\" start))", "user": "5383668ee4b06839e8705edd"}, {"problem": 164, "code": "(fn [info]\n  (let [start (info :start)\n        trans (info :transitions)\n        accepts (info :accepts)\n        recog (fn aux [cpos acc]\n                (lazy-seq\n                 (let [npatt (trans cpos)\n                       nposs (vals npatt)]\n                   (if-let [fin (some accepts nposs)]\n                     (concat (keep (fn [[v p]] (if (accepts p) (str acc v))) npatt) (mapcat (fn [[v p]] (aux p (str acc v))) npatt))\n                     (mapcat (fn [[v p]] (aux p (str acc v))) npatt)))))]\n    (recog start \"\")))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 164, "code": "(fn dfa-strings [{:keys [states alphabet start accepts transitions]}]\n  ((fn next-string [[[s state] & r :as n-states] since]\n     ;(Thread/sleep 1)\n     ;(println since s (count n-states))\n     ;(count n-states)\n     (if state\n       (let [next-states (concat r (->> (transitions state)\n                                        (map (fn [[c st]]\n                                               [(apply str (concat s (str c))) st]))))]\n         ;; (Thread/sleep 100)\n         ;; (println next-states path)\n         (if (accepts state)\n           (lazy-seq (cons s (next-string next-states 0)))\n           (next-string next-states (inc since))))\n       nil))\n   [[\"\" start]] 0))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(f [s]\n             (into #{}\n                   (for [[state path] s\n                         [k v] (transitions state)\n                         :when (not (nil? v))]\n                     [v (conj path k)])))\n          (g [s] \n              (for [[x y] s\n                    :when (accepts x)]\n                (apply str y)))]\n    (mapcat g\n            (take-while #(not (empty? %))\n                        (iterate f #{[start []]})))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (distinct\n    ((fn nx [prefix rules]\n      (when-not (empty? rules)\n        (lazy-seq\n          (let [[c nx-state] (first rules)\n                production   (str prefix (if (symbol? c) (name c) c))\n                continue     (concat (nx prefix (rest rules))\n                                     (nx production (transitions nx-state)))]\n            (if (contains? accepts nx-state)\n              (cons production continue)\n              continue)))))\n     \"\" (transitions start))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(filter-accepts [current-state] (map (fn [[_ s]] (apply str s)) (filter (fn [[c-s _]] (accepts c-s)) current-state)))\n          (next-state [[current-state s]] (let [p-t (transitions current-state)] (for [p-s (keys p-t)] [(p-t p-s) (conj s p-s)])))\n          (all-next-states [current-states] (mapcat next-state current-states))]\n                           (->> [[start []]]\n                                (iterate all-next-states);lazy seq (no stack overflow)\n                                (take-while #(not (empty? %)))\n                                (apply concat)\n                                (filter-accepts))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (letfn [(step [[[word state] & sq] accepts transitions]\n            (if (nil? state)\n              []\n              (let [tns (transitions state)\n                    next (map #(vector (str word (% 0)) (% 1)) tns)]\n                (if (accepts state)\n                  (lazy-seq (cons word (step (concat sq next) accepts transitions)))\n                  (step (concat sq next) accepts transitions)))))]\n    (step [[\"\" start]] accepts transitions)))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 164, "code": "(fn [a]\n  (loop [i 0\n         g #{}\n         c #{[(:start a) \"\"]}]\n    (let [ng (filter (fn [[s w]]\n                       ((:accepts a) s))\n                     c)\n          nc (set (for [[s w] c\n                        :let [u (s (:transitions a))]\n                        :when u\n                        [z n] u]\n                    [n (str w z)]))]\n      (if (< i 15)\n        (recur (+ i 1)\n               (concat g ng)\n               nc)\n        (map second g)))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(next-states [[s o]]\n            (->> (transitions s)\n                 (sort-by #(not (accepts (second %))))\n                 (map (fn [[c s1]] [s1 (conj o c)]))))]\n    (->> (tree-seq seq next-states [start []])\n         (filter (fn [[s _]] (accepts s)))\n         (map #(apply str (second %))))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n    (let [search (fn [search-q]\n                   (if (empty? search-q)\n                     nil\n                     (let [{:keys [state string]} (peek search-q)\n                       search-q (into\n                                 (pop search-q)\n                                 (map\n                                  (fn [[l s]] {:state s :string (str string l)})\n                                  (get transitions state)))]\n                       (if (accepts state)\n                         {:acceptable-string string\n                          :search-q search-q}\n                         (recur search-q)))))\n          step (fn step [search-q]\n                 (let [r (search search-q)]\n                   (if (empty? r)\n                     nil\n                     (let [{:keys [acceptable-string search-q]} r]\n                       (cons acceptable-string (lazy-seq (step search-q)))))))]\n      (step (conj clojure.lang.PersistentQueue/EMPTY {:state start, :string \"\"}))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 164, "code": "(letfn\n[\n(grow\n  [dfa [state so-far]]\n  (let [transitions ((:transitions dfa) state)]\n    (map (fn [[k v]] [v (str so-far k)]) transitions)))\n(get-solutions\n  [dfa]\n  (map second (filter (comp (:accepts dfa) first) (apply concat (take-while (complement empty?) (iterate (comp set (partial mapcat (partial grow dfa))) #{[(:start dfa) \"\"]}))))))\n  ]\nget-solutions)", "user": "57717915e4b0979f896515b3"}, {"problem": 164, "code": "(fn [{s :start a :accepts t :transitions}]\n  (let [w (fn w [x] (lazy-cat x (if (seq x) (w (mapcat (fn [[p u]] (for [[l n] (t u)] [(str p l) n])) x)))))]\n    (->> (w [[\"\" s]])\n         (filter #(-> % last a))\n         (map first))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 164, "code": "(fn state-machine [machine]\n  (letfn [(gen-strings \n            [{:keys [transitions accepts start]}]\n            (letfn [(step [paths]\n                          (lazy-seq \n                            (when-not (empty? paths)\n                              (let [accepted (filter #(accepts (peek %)) paths)\n                                    accepted-strings (map (comp #(apply str %) pop) accepted)]\n                                (concat accepted-strings\n                                        (step (for [path paths\n                                                    [letter nxt] (transitions (peek path))]\n                                                (conj (pop path) letter nxt))))))))]\n              (step [[start]])))]\n    (gen-strings machine)))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [(get-next-statuses [current-statuses]\n            (apply merge (flatten (map\n                                    (fn [entry]\n                                      (let [ns (get (:transitions dfa) (val entry))]\n                                        (if ns (map #(assoc {} (concat (key entry) [(key %)]) (val %)) ns))))\n                                    current-statuses))))\n          (step [current-statuses]\n            (let [next-statuses (get-next-statuses current-statuses)]\n              (if next-statuses\n                (lazy-cat\n                  (map #(apply str (key %)) (filter #((:accepts dfa) (val %)) next-statuses))\n                  (step next-statuses)))))]\n    (step {[] (:start dfa)})))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 164, "code": "(fn [{u :start a :accepts tran :transitions}]\n  (letfn [(g [i s] (mapv (fn [i m] `[~i ~m]) (repeat i) s))\n          (j [[[i [k v :as h]] & t]]\n            (let [n (str i k) s (into (vec t) (g n (tran v)))]\n              (if (seq h) (#(if (a v) (cons n %) %) (lazy-seq (j s))))))]\n    (j (g \"\" (tran u)))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 164, "code": "(fn c164\n  ([dfa state]\n   (let [inter (reduce (fn [r v]\n                         (reduce\n                          #(assoc %1 (second %2) (into (get %1 (second %2) []) (mapv (fn [val] (str val (first %2))) (second v))))\n                          r\n                          (get (:transitions dfa) (first v) {})))\n                       {}\n                       state)]\n     (if (empty? inter)\n       '()\n       (lazy-cat (reduce (fn [r v]\n                             (into r (flatten v))) '() (reduce (fn [r v]\n                                                                 (if ((:accepts dfa) (first v))\n                                                                   (cons (second v) r)\n                                                                   r)) '() inter)) (c164 dfa inter)))))\n  ([dfa]\n   (c164 dfa (assoc {} (:start dfa) [\"\"]))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 164, "code": "(letfn\n    [(get-next [from dfa]\n       (from (:transitions dfa)))\n\n     (accepted? [symb dfa]\n       (symb (:accepts dfa)))\n\n     (alphabet [state dfa res]\n       (->> (get-next state dfa)\n            (filter (fn [[_ s]] (accepted? s dfa)))\n            (map (fn [[c _]] (str res c)))))]\n\n  (fn ldfa\n    ([dfa] (ldfa (:start dfa) dfa \"\"))\n    ([current-state dfa res]\n     (lazy-seq\n      (let [next-states (get-next current-state dfa)\n            alphb (alphabet current-state dfa res)]\n        (concat alphb\n               (mapcat (fn [[c s]] (ldfa s dfa (str res c))) next-states)))))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 164, "code": "(fn dfa\n  [{start :start\n    accepts :accepts\n    transitions :transitions}]\n  (letfn [(lazy-dfa \n            [current-states]\n            (let [new-states \n                  (for\n                    [[cmatch cstate] current-states [nmatch nstate] (transitions cstate)] \n                    [(conj cmatch nmatch) nstate])]\n              (if (empty? new-states)\n                nil\n                (let [new-accepts (map first (filter #(contains? accepts (second %)) new-states))]\n                  (if (empty? new-accepts)\n                    (lazy-dfa new-states)\n                    (concat new-accepts (lazy-seq (lazy-dfa new-states))))))))]\n        (map #(apply str %) (lazy-dfa #{[[] start]}))))", "user": "576df252e4b0979f8965156f"}, {"problem": 164, "code": "(fn daff [{states :states alphabet :alphabet start :start accepts :accepts\n             transitions :transitions}]\n  (letfn [\n    (one-trans [pst]\n      (let [cmds (pop pst)\n            st (peek pst)\n            nxts (vec (transitions st))\n            updls (vec (map (fn [pair] (into cmds pair)) nxts))]\n        updls))\n    (nxt-stat-blks [aprev]\n        (let [xls (reduce (fn [z b] (into z (one-trans b))) [] aprev)\n              acpts (filter (fn [aq] (accepts (peek aq))) xls)\n              xgoons (filter (fn [aq] (transitions (peek aq))) xls) ]\n          (lazy-seq\n            (if (empty? xls)\n              nil\n              (if-not (empty? acpts)\n                ;; discard xfins, result all acpts, continue with all non-fins\n                (cons (vec acpts) (nxt-stat-blks (vec xgoons)))\n                (nxt-stat-blks (vec xgoons)))))))\n    (nxts-by-one [bgn]\n      (let [znxt (nxt-stat-blks [[bgn]])]\n        (letfn [(loc-one-nxt [fstwork rstwork]\n          (lazy-seq\n            (if-not (empty? fstwork)\n              (cons (first fstwork) (loc-one-nxt (rest fstwork) rstwork))\n              (if (empty? rstwork)\n                nil\n                (loc-one-nxt (first rstwork) (rest rstwork)))) ))]\n          (loc-one-nxt (first znxt) (rest znxt)) ))) ]\n\n    (map (comp clojure.string/join pop) (nxts-by-one start)) ))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 164, "code": "(fn [{a :start\n      z :accepts\n      t :transitions}]\n  (letfn [(f [[p s]] (map (fn [[c d]] [(str p c) d]) (t s)))\n          (z? [[_ s]] (z s))\n          (x [y]\n            (lazy-seq\n              (let [n (mapcat f y)]\n                (when (not (empty? n))\n                  (concat (map first (filter z? n))\n                          (x n))))))]\n    (x [[\"\" a]])))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 164, "code": "(fn[o]\n  (let [{tr :transitions accepts :accepts start :start} o\n        mv (partial mapcat (fn [[q s]] (map (fn [[c q2]] [q2 (str s c)]) (tr q))))\n        f (fn f [pairs]\n            (let [np (mv pairs)]\n              (if (empty? np)\n                []\n                (lazy-seq (concat (distinct (map second (filter #(accepts (first %)) np))) (f np))))))\n        ]\n    (f [[start \"\"]])))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 164, "code": "(fn [{:keys [start\n             accepts\n             transitions]}]\n  (letfn [(step [[[string _] trs]]\n            (for [[value state] trs\n                  :let [next-string (str string value)\n                        next-transitions (get transitions state)]]\n              [[next-string state] next-transitions]))\n          (do-transitions []\n            (let [step-1 (step [[\"\" start] (get transitions start)])]\n              (->> step-1\n                   (iterate (comp\n                              (partial apply concat)\n                              (partial map step)))\n                   (take-while (complement empty?)))))]\n    (->> (do-transitions)\n         (apply concat)\n         (filter (comp\n                   (partial contains? accepts)\n                   second\n                   first))\n         (map ffirst))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 164, "code": "(fn language [{:keys [states alphabet start accepts transitions]}]\n    (letfn [(alpha-for [[word state]]\n              (let [trans (map (fn [[letter to-state]]\n                                 (vector (str word letter) to-state))\n                               (seq (get transitions state)))\n                    complete-words (filter (fn [[word to-state]]\n                                             (accepts to-state))\n                                           trans)]\n                (concat (keys (into {} complete-words))\n                        (lazy-seq (mapcat alpha-for trans)))))]\n      (alpha-for [\"\" start])))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 164, "code": "(fn dfa-walker[input]\n  (let [{:keys [states alphabet start accepts transitions]} input\n        moves-for (fn [s] (transitions (:state s)))\n        valid-end-state? (fn [s] (contains? accepts (:state s)))]\n    (loop [queue [{:string \"\", :state start}] seen [] found [] stop 2000]\n      (let [current (first queue)\n            moves (moves-for current)\n            next-moves (map (fn [letter state]\n                              (-> current\n                                  (assoc :string (str (current :string) letter))\n                                  (assoc :state state)))\n                            (keys moves) (vals  moves))]\n        (cond\n          (empty? queue) found\n          (zero? stop) found\n          :else (recur (into (rest queue) next-moves)\n                       (cons (current :string) seen)\n                       (if (valid-end-state? current)\n                         (cons (current :string) found)\n                         found)\n                       (dec stop)))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(go [state acc]\n              (lazy-seq\n               (concat (->> (transitions state)\n                            (filter (fn [[_ state']] (accepts state')))\n                            (map (fn [[c _]] (str acc c))))\n                       (->> (transitions state)\n                            (map (fn [[c state']] (go state' (str acc c))))\n                            (apply concat)))))]\n    (go start \"\")))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 164, "code": "(fn dfa-walk [{:keys [start accepts transitions result counts laststr] :as dfa}]\n  (distinct (remove nil? \n                    (let [res (if (accepts start) (cons laststr result) result)\n                          chars (keys (transitions start))]\n                      (if (or (empty? chars) (> (get counts start 0) (count transitions)))\n                        res\n                        (mapcat (fn [c] (dfa-walk (assoc dfa\n                                                         :result res\n                                                         :laststr (str laststr c)\n                                                         :start ((transitions start) c)\n                                                         :counts (update-in counts [start] #(inc (or % 0)))))) chars))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 164, "code": "(fn x\n  [{:keys [start transitions accepts]}]\n  (let [walk (fn walk [path state]\n               (let [paths+next (map (fn [[val next]] [(str path val) next]) (transitions state))\n                     accepted (map first (filter (comp accepts second) paths+next))\n                     continue (mapcat #(lazy-seq (apply walk %)) paths+next)]\n                 (lazy-cat accepted continue)))]\n    (walk nil start)))", "user": "52d2ca1ce4b099d49816f0b4"}, {"problem": 164, "code": "(fn ___ [dfas]\n (letfn [(hasbranch [d]\n \t  (some #(= % (:start d)) (into [] (keys (:transitions d)))))\n\t  (getaccs [d]\n\t    (map (fn [e]\n\t    \t  (let [v (key e) k (val e)\n\t\t       accepted (contains? (:accepts d) k)]\n\t\t       (if accepted (str (:acc d) v) nil))) \n\t\t       ((:start d) (:transitions d))))\n\t (getrans [d]\n\t \t  (map #(let [v (key %) k (val %) acc (:acc d)]\n\t\t       (-> (assoc-in d [:start] k)\n\t\t       \t   (assoc-in [:acc] (str acc v))))\n\t\t\t   ((:start d) (:transitions d))))]\n\t(let [daccs (remove #(= nil %) (getaccs dfas))\n\t      brnch (filter hasbranch (getrans dfas))]\n\t      (lazy-seq (concat daccs (mapcat ___ brnch))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 164, "code": "(fn [{:keys [accepts start transitions]}]\n  (letfn [(tail [trace state edges]\n            (if state\n              (f (into edges (map (fn [[c st]] [(conj trace c) st])\n                                  (transitions state))))\n              '()))\n          (f [edges]\n            (let [edge (first edges)\n                  edges (disj edges edge)\n                  [trace state] edge]\n              (if (contains? accepts state)\n                (lazy-seq (cons (clojure.string/join trace)\n                                (tail trace state edges)))\n                (tail trace state edges))))]\n    (f #{[[] start]})))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 164, "code": "(fn [dfa]\n  (let [init-state (dfa :start)\n        accepts (dfa :accepts)\n        transitions (dfa :transitions)]\n    (letfn [(gen-states [s] ;; called recursively to generate candidate strings\n              (let [extend (fn [[word state]] ;; list word/state pairs that can follow given values\n                             (let [actions (transitions state)] ;; map letter to new state\n                               (for [c (keys actions)] [(clojure.string/join [word (str c)]) (actions c)])))]\n                (let [next-level (mapcat identity (map extend s))] ;; single-level flatten\n                  (if (empty? next-level)\n                    s\n                    (lazy-seq (concat s (gen-states next-level)))))))]\n      (filter not-empty (map #(if (contains? accepts (second %)) (first %) \"\") (gen-states [[\"\" init-state]]))))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (->> (conj clojure.lang.PersistentQueue/EMPTY [start []])\n    (iterate\n      (fn [q]\n        (let [[s z] (peek q)]\n          (->> s\n            transitions\n            (map (fn [[k v]] [v (conj z k)]))\n            (into (pop q))))))\n    (take-while seq)\n    (filter (fn [[[q]]] (accepts q)))\n    (map (fn [[[[] s]]] (apply str (map str s))))))", "user": "50479524e4b0371827a27bc4"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [(expand [{:keys [paths]}]\n            (reduce (fn [m p]\n                      (if ((:accepts dfa) (peek p))\n                        (-> m (update-in [:paths] conj p)\n                            (update-in [:solutions] conj (apply str (pop p))))\n                        (update-in m [:paths] conj p)))\n                    {:solutions [] :paths []}\n                    (for [path paths t ((:transitions dfa) (peek path))]\n                      (into (pop path) t))))]\n    (->> (iterate expand {:paths [[(:start dfa)]]})\n         (take-while (comp not-empty :paths))\n         (mapcat :solutions))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 164, "code": "(fn paths [dfa]                                                                                                                                                         \n  (let [walk (fn walk [[w st]]                                                                                                                                            \n               (lazy-seq                                                                                                                                                  \n                (when-let  [tr (get (:transitions dfa) st)]                                                                                                               \n                  (let [m (map (fn [[k v]] [(str w (str k)) v]) tr)]                                                                                                      \n                  (concat m (mapcat walk m))))))]                                                                                                                         \n    (->> [\"\" (:start dfa)]                                                                                                                                                \n         walk                                                                                                                                                             \n         (filter (comp (:accepts dfa) second))                                                                                                                            \n                  (map first))))", "user": "4f1ef6a0535d64f60314649b"}, {"problem": 164, "code": "(fn dfa-recognized-strings [dfa]\n  (letfn [(run [[state accum]]\n            (for [[char next-state] ((:transitions dfa) state)] [next-state (str accum char)]))\n          (accepted [[state accum]] \n            (when ((:accepts dfa) state)\n              accum))]\n    (mapcat \n     #(keep accepted %) \n     (take-while not-empty \n                 (iterate #(mapcat run %) (run [(:start dfa) \"\"]))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 164, "code": "(fn [{:keys [start transitions accepts]}]\n  (letfn [(test [res [res-s state]]\n                 (and (accepts state) (not (res res-s))))\n          (t-merge [res agg]\n            (->> (filter (partial test res) agg)\n                 (map (comp str first))\n                 (into res)))\n          (spread [trans [agg res] [res-s state]]\n            (let [part (for [[ch n-state] (state trans)]\n                         [(str res-s ch) n-state])]\n              [(into agg part)\n               (t-merge res part)]))\n          (step [[agg res] res-agg]\n            (let [trans (select-keys transitions (vals agg))\n                  next (reduce (partial spread trans) [{} res] agg)]\n              (if (empty? trans)\n                res\n                (lazy-cat (clojure.set/difference res res-agg)\n                          (step next res)))))]\n    (let [agg (start transitions)\n          res (t-merge #{} agg)]\n      (step [agg res] #{}))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 164, "code": "#(let [[_ _ s a t] (vals %)]\n  ((fn i [y]\n     (lazy-seq\n       (if (seq y)\n         (let [[w r] (peek y)\n               n (i (into \n                       (mapv (fn [[y x]] [x (str r y)])\n                             (t w))\n                       (pop y)))]\n           (if (and r (a w))\n             (cons r n) \n             n))))) \n   [[s]]))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 164, "code": "(fn func [info]\n\t(let [start (:start info)\n\t\t  trans (fn [machine input]\n\t\t  \t\t   {:state (get-in info [:transitions (:state machine) input]) :strs (str (:strs machine) input)})\n\t\t  expand (fn [m] \n\t\t  \t\t(->> (for [input (:alphabet info)] (trans m input))\n\t \t\t\t\t (remove #(= (:state %) nil))))\n\t\t  machine-arr [{:state (:start info) :strs \"\"}]]\n\t\t(loop [arr machine-arr n 0 res []]\n\t\t     (if (= n 10) res\n\t\t     \t(recur (mapcat expand arr) (inc n) (concat res (map #(:strs %) (filter #(contains? (:accepts info) (:state %)) (mapcat expand arr)))))))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 164, "code": "(fn [m]\n                (->>\n                  ((fn f [s]\n                     (let [n (set (for [[a b] s tran ((:transitions m) b)]\n                                             [(conj a (key tran)) (val tran)]))]\n                       (if (not= s (clojure.set/union s n)) (lazy-cat s (f n)) s)\n                       )) #{[[] (:start m)]})\n                  (filter #(and (seq %) (contains? (:accepts m) (second %))))\n                  (map #(apply str (first %)))\n                  )\n\n                )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 164, "code": "(fn lazy-traverse\n  ([dfa] (remove nil? (lazy-traverse dfa (:start dfa) \"\")))\n  ([dfa x w]\n    (lazy-seq\n      (cons\n       (if (contains? (:accepts dfa) x) w nil)\n       (apply concat\n              (let [all_edges (for [[from edges] (dfa :transitions)\n                                [edge to] edges\n                                :when (= from x)] (list edge to))]\n                (for [[edge to] (shuffle all_edges)]\n                  (let [w (str w edge)]\n                    (lazy-traverse dfa to w)))))))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 164, "code": "(fn prob164 [{:keys [states alphabet start accepts transitions]}]\n  (let [filter-accepted-strings  (fn [accepts current-states]\n                                  (map (fn [[current-state string]] \n                                         (apply str string))\n                                       (filter (fn [[current-state string]]\n                                                 (accepts current-state))\n                                               current-states)))\n        next-state (fn [transitions [current-state string]]\n                     (let [possible-transitions (transitions current-state)]\n                       (for [possible-symbol (keys possible-transitions)]\n                         [(possible-transitions possible-symbol)\n                          (conj string possible-symbol)])))\n\n        next-states (fn [transitions current-states]\n                      (apply concat (map #(next-state transitions %) current-states)))\n\n        ]\n    (filter-accepted-strings accepts \n                             (apply concat \n                                    ;; take while not empty\n                                    (take-while #(not (empty? %)) \n                                                ;; starting with start build all next states using transitions as the guide\n                                                (iterate #(next-states transitions %) [[start []]]))\n                                    ))\n    ))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 164, "code": "(fn dfa [{states :states alphabet :alphabet start :start accepts :accepts transitions :transitions}]\n  (letfn\n    [(genStates\n      ([] (genStates [[[] start]]))\n      ([cs]\n         (let [ncs (mapcat (fn [[s state]]\n                            (map (fn [[a ns]] [(conj s a) ns]) (get transitions state [])))\n                           cs)]\n              (if (seq ncs)\n                  (concat (map (comp (partial apply str) first) (filter (comp accepts second) ncs))\n                          (lazy-seq (genStates ncs)))))))]\n    (genStates)))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [ (next_st [[s q]] (map (fn [[s1 q1]] [(str s s1) q1]) (transitions q)))]\n    (->> {\"\" start}\n      (iterate (partial mapcat next_st))\n      (take-while seq)\n      (apply concat)\n      (filter (comp accepts peek))\n      (map first)  )))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n    (let [bf-tree-seq (fn [branch? children root]\n                        (let [queue (conj clojure.lang.PersistentQueue/EMPTY root)\n                              walk (fn walk [queue]\n                                     (lazy-seq\n                                       (when-let [node (peek queue)]\n                                         (if (branch? node)\n                                          (cons node (walk (into (pop queue) (children node))))\n                                          (cons node (walk (pop queue)))))))]\n                          (walk queue)))\n          child-states (fn [state] (vals (transitions state)))\n          child-accepts (fn [state] (map #(not (nil? (accepts %))) (child-states state)))\n          child-words (fn [state word] (map #(str word %) (keys (transitions state))))\n          branch? (fn [[state word accept]] (pos? (count (transitions state))))\n          children (fn [[state accept word]] (map vector (child-states state)\n                                                         (child-accepts state)\n                                                         (child-words state word)))\n          root [start false \"\"] ; initial state, is accept state?, partial word\n          tree (bf-tree-seq branch? children root)]\n      (->> tree\n        (filter second)\n        (map last))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 164, "code": "(fn [{:keys [alphabet start states accepts transitions]}]\n  (let [alpha (map str alphabet)\n        t (reduce (fn [t [p d]]\n                    (update-in t p #(conj % d)))\n                  (into {} (map (fn [s] [s {}]) states))\n                  (for [[o e] transitions\n                        [i d] e]\n                    [[d i] o]))\n        q (map (fn [x] [x ()]) accepts)\n        n (fn [q]\n            (for [[s cs] q\n                  c (keys (t s))\n                  d (get-in t [s c])]\n              [d (conj cs c)]))\n        f (fn f [q]\n            (when-not (empty? q)\n              (concat q (lazy-seq (f (n q))))))]\n    (map (comp (partial apply str) second)\n         (filter (comp #{start} first) (f q)))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 164, "code": "(fn __\n   ([dfa] (__ dfa (sorted-set-by   (fn [x y]\n                                     (let [\n                                           c1 (- (count (x :txt)) (count (y :txt)))\n                                           ]\n                                       (if (not (zero? c1))\n                                         c1\n                                         (let [\n                                               c2 (compare (x :txt) (y :txt))\n                                               ]\n                                           (if (not (zero? c2))\n                                             c2\n                                             (compare (x :state) (y :state)))))))\n                                   {:state (dfa :start) :txt \"\"})))\n   ([dfa states]\n    (if (empty? states)\n       []\n       (let [\n             expandState (fn [state] (let [\n                                           stateTrans ((dfa :transitions) (state :state))\n                                           newStates (map (fn [[tx st]] {:state st :txt (str (state :txt) tx)}) stateTrans)\n                                           ]\n                                        newStates))\n             isFinal (fn [state] (contains? (dfa :accepts) (state :state)))\n             ]\n          (lazy-seq\n            (let [\n                  firstState (first states)\n                  expandedState (expandState firstState)\n                  withoutFirst (disj states firstState)\n                  ]\n              ;(println states firstState expandedState withoutFirst)\n              (if (isFinal firstState)\n                (cons (firstState :txt) (__ dfa (into withoutFirst expandedState)))\n                (__ dfa (into withoutFirst expandedState)))))))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 164, "code": "(fn dfa \n  ([definition] (filter (comp not clojure.string/blank?) (dfa definition (:start definition) \"\")))\n  ([definition state current]\n    (let [\n          {transitions :transitions accepts :accepts states :states} definition\n          trans (get transitions state {})\n          compute (fn []\n                    (flatten\n                      (for [[letter target-state] (shuffle (into [] trans))]\n                        (dfa definition target-state (str current letter))\n                      )\n                    )\n                  )\n         ]\n      \n\n      (cond\n       \t\n       \t;this protection from stackoverflow is not very good idea\n        ;it won't get you proper results for large alphabets\n        ;but this is the only way i managed to make it work for these test cases\n        (and (contains? accepts state) (> (count current) 25)) current\n        (and (> (count current) 25)) \"\"\n       \n        (and (contains? accepts state) (empty? trans)) current\n        (and (contains? accepts state) (not (empty? trans))) (lazy-seq (cons current (compute)))\n        :else\n          (compute)\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 164, "code": "(fn dfa[d]\n(letfn [\n(get-next [d st]\n  (mapcat\n   (fn [entry]\n     (map #(hash-map :state (str (entry :state) (first %))\n             :last (second %)\n             :done (contains? (d :accepts) (second %)))\n          ((d :transitions) (entry :last))))\n   st)\n  )\n\n(dfa-seq [d st]\n  (if (empty? st)\n    nil\n    (let [c (get-next d st)] (lazy-cat c (dfa-seq d c)))))\n        ]\n  (map #(% :state)\n       (filter #(% :done)\n        (take-while  #(contains? % :done)\n                     (dfa-seq d #{{:state \"\" :last (d :start) :done false}}))))\n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 164, "code": "; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 164, "code": "(fn [DFA]\n     (letfn [(lazy-qs [D qws]\n               (if (empty? qws) \n                         nil\n                  (let [ [[q w] & qws-rest] qws\n                          w-new (if ((D :accepts) q) (list w) '())         \n                          T ((D :transitions) q)\n                          qws-new (map #(vector (T %) (str w %))  (keys T))\n                          qws-next (concat qws-rest qws-new)]\n              (concat w-new (lazy-seq (lazy-qs D qws-next))))))]  \n      (lazy-qs DFA (list (vector (DFA :start) \"\")) )))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (letfn\n    [(state-machine [current]\n       (lazy-seq\n          (when (seq current)\n            (let [n (reduce\n                       (fn [acc cur]\n                          (concat acc\n                              (map #(hash-map :res (str (:res cur) (key %))\n                                              :state (val %))\n                                   (transitions (:state cur)))))\n                       []\n                       current)\n                  outputs (reduce #(if (get accepts (:state %2)) (conj %1 (:res %2)) %1) [] n)\n                  next-states (distinct (filter #(get transitions (:state %)) n))]\n              (concat outputs (state-machine next-states))))))]\n\n    (state-machine [{:state start :res \"\"}])))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "59358f74e4b04f87174def52"}, {"problem": 164, "code": "(fn dfa [m]\n  (letfn [(f [q]\n             (if-let [[state partial] (peek q)]\n               (let [q (reduce\n                        (fn [q letter]\n                          (if-let [nxt (get-in m [:transitions state letter])]\n                            (conj q [nxt (str partial letter)])\n                            q))\n                        q\n                        (:alphabet m))]\n                 (if (get-in m [:accepts state])\n                   (lazy-seq (cons partial (f (pop q))))\n                   (recur (pop q))))))]\n    (f (conj clojure.lang.PersistentQueue/EMPTY [(:start m) \"\"]))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 164, "code": "(fn get-all-strings \n    ([dfa] (get-all-strings dfa [[(:start dfa) []]]))\n    ([dfa start]\n        (letfn [\n            (get-next-states\n                [start]\n                (map (fn [a] [(second a) (conj (second start) (first a))])\n                    (into {} (for [x (:transitions dfa) :when (= (first start) (first x))] (second x))))\n            )]\n            (let [next-states (mapcat get-next-states start)\n                  new-results (for [x next-states :when (contains? (:accepts dfa) (first x))]\n                                (apply str (second x))) ]\n                (if (empty? next-states)\n                    nil\n                    (if (empty? new-results)\n                        (get-all-strings dfa next-states)\n                        (lazy-seq (cons (first new-results) (get-all-strings dfa next-states (rest new-results))))\n                    )\n                )\n            )\n        )\n    )\n    ([dfa start new-results]\n        (if (empty? new-results)\n            (get-all-strings dfa start)\n            (lazy-seq (cons (first new-results) (get-all-strings dfa start (rest new-results))))\n        )\n    )\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 164, "code": "(fn [dfa]\n           (let [run1 (fn [[state word]]\n                        (for [[letter next-transition] ((:transitions dfa) state)]\n                          [next-transition (str word letter)]))\n                accept (fn [[state word]] (when ((:accepts dfa) state) word))]\n             (mapcat #(keep accept %)\n                     (take-while not-empty\n                                 (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "5a0a25fce4b0eab8c044893d"}, {"problem": 164, "code": "(fn [m]\n    ((fn f [stack]\n       (lazy-seq\n         (let [[current-str state] (peek stack)\n               stack (into\n                       (pop stack)\n                       (map\n                         (fn [[l s]] [(conj current-str l) s])\n                         (sort-by\n                           #((m :accepts) (second %))\n                           ((m :transitions) state))))\n               r     (if (empty? stack)\n                       nil\n                       (f stack))]\n           (if (contains? (m :accepts) state)\n             (cons (clojure.string/join (map str current-str)) r)\n             r))))\n      [[[] (m :start)]]))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 164, "code": "(fn sol [dfa]\n  (letfn[\n      (fort [dfa wq]\n   (let [w (first wq) q (second wq)\n          s ((:transitions dfa) q)]\n      (concat (for [x s]\n           [(str w (first x)) (second x)]\n       ) )\n   )\n)\n\n(collw [dfa wqs]\n  (loop [res #{} ws wqs]\n     (let [wq1 (first ws) rwqs (rest ws)]\n         (cond (empty? ws) res\n               ((:accepts dfa) (second wq1))\n                 (recur (conj res (first wq1)) (rest ws))\n               :else\n                 (recur res (rest ws))\n         )\n     )\n   )\n)\n    (coll [branches dfa]\n  (lazy-seq \n      (let [nbranches (reduce concat (map #(fort dfa %) branches))\n             erg (collw dfa nbranches)]\n;    (do (println nbranches erg)\n         (if (> (count nbranches) 0)\n            (concat erg (coll nbranches dfa))                         \n            ()\n         )\n    )\n;      )\n  )\n)\n    \n         ]\n   (coll [[\"\" (:start dfa)]] dfa)\n)\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 164, "code": "(fn [{start :start, acs :accepts, trs :transitions}]\n  (let [f (fn f [s] (if (empty? s) nil\n                        (lazy-seq (concat s (f (mapcat (fn [[r q]] (map (fn [[e q+]] [(str r e) q+]) (trs q))) s)) ))))]\n  (map first (filter #(contains? acs (second %)) (f [[\"\" start]]))) ))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 164, "code": "(fn [dfa]\n  ((fn lambda [states]\n     (if (empty? states)\n       '()\n       (let [strings\n             (map first\n                  (filter #(contains? (dfa :accepts) (second %)) states))\n             states\n             (map (fn [x] (map #(list (str (first x) (key %)) (val %))\n                               ((dfa :transitions) (second x))))\n                  states)]\n         (lazy-cat strings (lambda (apply concat states))))))\n     #{(list \"\" (dfa :start))}))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 164, "code": "(fn dfa-strings [{ts :transitions a? :accepts i :start}]\n  (let [step (fn [{s :state t :tape}]\n              (map (fn [[emit s']] {:state s' :tape (conj t emit)})\n                   (ts s)))\n        stepall #(mapcat step %)\n        init {:state i :tape []}\n        accept? #(a? (:state %))\n        run (fn run [states]\n              (if (empty? states)\n                  states\n                  (concat states (lazy-seq (run (stepall states))))))]\n    (map #(apply str (:tape %))\n         (filter accept?\n                 (run [init])))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 164, "code": "(fn[a]\n        (letfn\n            [(valid-transitions [q] \n               (mapcat seq (map second (filter #(= q (first %)) (seq (:transitions a))))))\n\n             (branch [prfx pairs]\n               (when-let [[fst & rst] (seq pairs)]\n                 (let [[symb target] fst]\n                   (cons \n                    [(str prfx symb) target]\n                    (branch prfx rst)))))\n\n             (produce [pairs]\n               (when-let [[[w q'] & more] (seq pairs)]\n                 (let [cont (cons (produce more) (walk-from w q'))]\n                   (if ((:accepts a) q')\n                     (cons w cont) \n                     cont))))\n\n             (walk-from[prfx q]\n               (lazy-seq\n                (produce (branch prfx (valid-transitions q)))))]\n          \n          (remove nil? (flatten (walk-from \"\" (:start a))))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 164, "code": "(fn dfa [{:keys [start accepts transitions]}]\n  (letfn\n    [(goal? [[a s]] (accepts s))\n     (leaf? [[a s]] (not (contains? transitions s)))\n     (tree-val [[a s]] a)\n     (children [[a s]] (transitions s))\n     (queue [& vals]\n       (apply conj clojure.lang.PersistentQueue/EMPTY vals))\n     (bfs [q]\n       (when-let [{:keys [tree path]} (peek q)]\n         (let [new-path (conj path (tree-val tree))\n               wrap (fn [t] {:tree t :path new-path})\n               enqueue-children (fn [tree] \n                                  (->> (children tree)\n                                       (map wrap)\n                                       (apply conj (pop q))))]\n           (cond\n             (and (goal? tree) (leaf? tree)) (lazy-seq (cons new-path (bfs (pop q))))\n             (goal? tree) (lazy-seq (cons new-path (bfs (enqueue-children tree))))\n             (leaf? tree) (recur (pop q))\n             :else (recur (enqueue-children tree))))))]\n    (->> (bfs (queue {:tree [:drop-me start] :path []}))\n      (map (fn [path] (apply str (rest path)))))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (let [fir (get transitions start)\n        ne (fn [[r p items]]\n             (map\n               (fn [[k v]]\n                 [(conj r k) v (get transitions v)])\n               items))]\n    (->>\n      (iterate #(mapcat ne %)  (ne [[] start fir]))\n      (take (count states))\n      (mapcat\n        #(map\n           (fn [[r p _]]\n             (prn p)\n             (when (contains? accepts p)\n               r))\n           %))\n      (filter identity)\n      (map #(apply str %))\n      (set))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]                                                                                                                                                                                                     \n   (letfn [(step [{:keys [states strings] :as m}]                                                                                                                                                                                              \n             (->> (for [{:keys [state string]} states                                                                                                                                                                                          \n                        [sym next-state] (seq (transitions state))                                                                                                                                                                             \n                        :let [next-str (str string sym)]]                                                                                                                                                                                      \n                    (if (accepts next-state)                                                                                                                                                                                                   \n                      {:states [{:state next-state :string next-str}] :strings (conj strings next-str)}                                                                                                                                        \n                      {:states [{:state next-state :string next-str}] :strings strings}))                                                                                                                                                      \n                  (apply merge-with into)))]                                                                                                                                                                                                   \n     (->> (iterate step {:states [{:state start :string nil}], :strings #{}})                                                                                                                                                                  \n          (take-while (comp seq :states))                                                                                                                                                                                                         \n          (mapcat :strings)\n          distinct)))", "user": "57d418b4e4b0bd073c20239a"}, {"problem": 164, "code": "(fn language [{:keys [states alphabet start accepts transitions]}]\n  ((fn alpha-for [[word state]]\n     (let [trans (map (fn [[letter to-state]] (vector (str word letter) to-state))\n                      (seq (get transitions state)))\n           complete-words (filter (fn [[word to-state]] (accepts to-state)) trans)]\n        (concat (keys (into {} complete-words)) (lazy-seq (mapcat alpha-for trans)))))\n   [\"\" start]))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 164, "code": "(fn [dfa]\n  (let [start (:start dfa) accept (:accepts dfa) trans (:transitions dfa)\n        lang (fn lang [queue]\n               (if (empty? queue) nil\n                 (lazy-seq\n                  (let [f (first queue) pre (first f) state (second f) r (rest queue)\n                        nqueue (concat r (map (fn [[ch nstate]] [(str pre ch) nstate]) (trans state)))]\n                    (if (accept state) (cons pre (lang nqueue)) (lang nqueue))))))]\n    (lang [[\"\" start]])))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 164, "code": "(fn dfa-traverse [dfa]\n  (letfn [(trv [state word]\n            (let [steps (get-in dfa [:transitions state])\n                  s-keys (->> steps keys)\n                  recurs (if s-keys\n                           (lazy-seq (mapcat #(trv (get steps %) (cons % word)) (->> s-keys shuffle (sort-by #(not ((:accepts dfa) (steps %)))))))\n                           nil)]\n              (if ((:accepts dfa) state)\n                (cons (->> word reverse (apply str)) recurs)\n                recurs)))]\n    (trv (:start dfa) '())))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 164, "code": "(fn language [{:keys [states alphabet start accepts transitions]}]\n ((fn alpha-for [[word state]]\n   (let [trans (map (fn [[letter to-state]] (vector (str word letter) to-state)) (seq (get transitions state)))\n         complete-words (filter (fn [[word to-state]] (accepts to-state)) trans)]\n    (concat (keys (into {} complete-words)) (lazy-seq (mapcat alpha-for trans)))))\n   [\"\" start]))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 164, "code": "(fn step\n  ([dfa] (step dfa [[[] (:start dfa)]]))\n  ([dfa strings+states]\n   (when (seq strings+states)\n     (let [[[string state] & rst] strings+states\n           trns (-> dfa :transitions (get state))\n           nxt (reduce (fn [acc [k v]] (conj acc [(conj string k) v])) [] trns)]\n       (if (-> dfa :accepts (contains? state))\n         (lazy-seq\n           (cons (apply str string)\n                 (step dfa (concat rst nxt))))\n         (recur dfa (concat rst nxt)))))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 164, "code": "(fn dfa-lang [dfa]\n  (letfn [(step [[[path top] & rest :as queue]]\n            (lazy-seq\n              (when (seq queue)\n                (let [next-wave (->> ((:transitions dfa) top)\n                                     (map (fn [[s v]] [(str path (str s)) v])))]\n                  (if ((:accepts dfa) top)\n                    (cons path (step (concat rest next-wave)))\n                    (step (concat rest next-wave)))))))]\n    (step [[\"\" (:start dfa)]])))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 164, "code": "(fn dfa-seq [dfa]\n   (let [states (dfa :states)\n         alphabet (dfa :alphabet)\n         start (dfa :start)\n         accepts (dfa :accepts)\n         transitions (dfa :transitions)\n         state? (fn [state] (states state))\n         accept? (fn [state] ;{:pre [(state? state)]}\n                     (accepts state))\n         letter? (fn [letter] (alphabet letter))\n         path? (fn [[letters state]] (and (every? letter? letters)\n                                            (state? state)))\n         ; Return a new path, with its first part (letters) a seq in reverse (hence reusing subsequences). Return nil the given previous path doesn't accept the given letter.\n         path-new (fn [letter sub-path state] ;{:pre [(path? sub-path) (letter? letter) (state? state)] :post[(path? %)]}\n                    (list (cons letter (first sub-path)) state))\n         path-state (fn [path] ;{:pre [(path? path)]}\n                      (second path))\n         path-to-word (fn [path] ;{:pre [(path? path)]} ;Paths have letters in reverse (created via cons).\n                        (apply str (reverse (first path))))\n         contained? (fn [coll item] ;{:pre [(not= item nil) (not= item false)]}\n                      (some (partial = item) coll)) ;the order of params. is for use with (partial ...) to check items. If you'd like its (partial ...) to check collections, reverse the parameters.\n         new-split-paths? #_OBSOLETE (fn [[accepted mixcepted] mixcepted-prev] ;two groups of paths, first in accepted states, the second in unaccepted states plus any paths from the first group. This split speeds up delivery. This only applies when adding paths (delta); later on, as accepted paths are taken out, mixcepted may contain paths with accepted states that are not in `accepted` anymore.\n                        (and (every? path?  accepted) (every?                            (comp accept? path-state) accepted)\n                             (every? path? mixcepted) (every? (some-fn (comp (complement (comp accept? path-state)))\n                                                                       (partial contained? accepted) \n                                                                       mixcepted))))\n         step-letter-OBSOLETE (fn [[accepted mixcepted :as split-paths]] ;{:pre [(every? path? accepted) (every? path? mixcepted)] :post [(new-split-paths? % accepted)]} ;split-paths => new split-paths (delta);  accepted only serves for validation in :post\n                           \"undefined\")\n         ;--------\n         ;even though a path reached an accepted state, it can also continue\n         split-paths? (fn [[accepted mixcepted :as path-groups]] ;It accepts two groups of paths, either right from (step-states), or from (step-word). less strict than step-states-result?, because some acceptable states in `mixcepted` may not be in `accepted` anymore.\n                        (and (= 2 (count path-groups))\n                             (every? (partial every? path?) path-groups)\n                             (every? (comp accept? path-state) accepted)\n                             (every? (partial contained? mixcepted) accepted))) ;every accepted path is also in mixcepted\n         step-states-result? (fn [mixcepted-prev [accepted mixcepted :as path-groups]] ;more strict than (split-paths?), this accepts only from (step-states), when any acceptable states in `mixcepted` are (still) in `accepted`.\n                              (or\n                               (nil? path-groups)\n                               (and (split-paths? path-groups)\n                                    (every? (some-fn empty?\n                                                     (partial contained? accepted) ;every mixcepted path is either in accepted, or is not acceptable as it is. I.e. there are no accepted paths in it other than those also present in `accepted`.\n                                                     (complement (comp accept? path-state)))\n                                            mixcepted)\n                                    (every? (complement (partial contained? mixcepted-prev)) (concat accepted mixcepted)))))\n         state-transitions? (fn [trans] (and (map? trans)\n                                             (every? letter? (keys trans))\n                                             (every? state? (vals trans)))) ;trans is a per-state submap of transitions map\n         step-states (fn [mixcepted-prev] ;{:pre [(every? path? mixcepted-prev)] :post [(step-states-result? mixcepted-prev %)]} ;step every path one letter forward\n                      (let [[accepted mixcepted :as both]\n                       (reduce (fn [[accepted mixcepted] path-prev]\n                                 (let [state-prev (path-state path-prev)\n                                       state-transitions (transitions state-prev {})\n                                       _ (assert (state-transitions? state-transitions))\n                                       [accepted-part mixcepted-part] (reduce (fn [[accepted-part mixcepted-part] [letter new-state]]\n                                                                                (let [new-path (path-new letter path-prev new-state)\n                                                                                      mixcepted-new (cons new-path mixcepted-part)]\n                                                                                  (if (accept? new-state)\n                                                                                    [(cons new-path accepted-part) mixcepted-new]\n                                                                                    [               accepted-part  mixcepted-new])))\n                                                                              [()()] state-transitions)]\n                                   [(concat accepted accepted-part) (concat mixcepted mixcepted-part)]))\n                               [()()] mixcepted-prev)]\n                       (if (or (seq accepted) (seq mixcepted))\n                         both\n                         nil)))\n         step-word-result? (fn [[split-paths word :as all]] (or (nil? all)\n                                                                (and (split-paths? split-paths)(every? (comp letter? symbol str) (seq word))\n                                                                     (string? word))\n                                                                #_(println \"split\" split-paths \"word\" word))) ;word-is-in-human-friendly-order already\n         step-word (fn step-word [[accepted mixcepted :as split-paths]] ;nil if no more words\n                     ;{:pre [(split-paths? split-paths)] :post [(step-word-result? %)]}\n                     (let [accepted-seq (seq accepted)]\n                       (if accepted-seq ;return a word, remove from accepted. Every accepted path was also put in unaccepted, hence no need to move it here.\n                         [[(rest accepted-seq) mixcepted] (path-to-word (first accepted-seq))]\n                         (let [[accepted-new mixcepted-new :as both]\n                               (loop [mixcepted mixcepted]\n                                 (let [[accepted-new mixcepted-new :as both] (step-states mixcepted)]\n                                   (if both\n                                     (let [accepted-new-seq (seq accepted-new)]\n                                       (if accepted-new-seq\n                                         both\n                                         (recur mixcepted-new)))\n                                     nil)))]\n                           (if both\n                             (step-word both) ;not (recur ...), because :post prevents tail recursion.\n                             nil\n                             )))))\n         starter-path (list () start)\n         _ (assert (path? starter-path))\n         starter-groups (list\n                         (if (accept? start)\n                           (list starter-path)\n                           ())\n                         (list starter-path))\n         lazy-words (fn lazy-words [split-paths]\n                      (lazy-seq (let [[split-paths-new word] (step-word split-paths)]\n                                  (if word\n                                    (cons word (lazy-words split-paths-new))\n                                    ()))))]\n      (lazy-words starter-groups)))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 164, "code": "(fn __\n  ([dfa]\n   (->>\n    (for [dest (:accepts dfa)]\n      (__ dfa (dfa :start) dest nil))\n    (apply concat)\n    (map (partial apply str))))\n\n  ([dfa start dest all-paths]\n   (when ((dfa :states) start)\n     (let [ends (into {}\n                      (for [d ((:transitions dfa) start)]\n                        d))\n           paths (for [end ends\n                       path (or all-paths [[]])]\n                   (conj path (first end))\n                   )]\n       (->>\n        (for [p paths\n              :let [e (ends (last p))]]\n          (cond\n            (= dest e)\n            (vector p)\n\n            ((:states dfa) e)\n            (__\n             (update-in dfa [:states] disj start) ; remove start from states\n             e\n             dest\n             (vector p))\n            :else\n            nil))\n        (apply concat)\n        (vec))))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 164, "code": "(fn  [dfs]\n  (let [more2 (fn [path x]\n                (if (<= 2 (count (filter #(= x %) path)))\n                  true false))\n        re-cycle? (fn [path x1 x2]\n                    (if (empty? (filter #(and (= x1 (first %))(= x2 (second %)))\n                                        (map #(list % %2) path (rest path)))) false true))\n        search (fn search [state path lan res]\n                 (let [n_state (get-in dfs [:transitions state])\n                       last_state (last path)]\n                   (if (nil? n_state)\n                     res\n                     (if (more2 path last_state)\n                       (when (re-cycle? path last_state state) res)\n                       (let [t (fn [[a s]]\n                                 (let [ac ((get dfs :accepts)  s)\n                                       npath (conj path s)\n                                       nlan (conj lan a)\n                                       nres (if (nil? ac) res (conj res nlan))]\n                                   (search s npath nlan nres)))]\n                         (map #(t %) n_state))))))]\n    (map #(apply str %) (apply clojure.set/union (flatten (search (get dfs :start) [] [] #{}))))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 164, "code": "(fn foo\n  ([dfa] (foo dfa (list {:state (:start dfa)\n                         :word \"\"})))\n  ([dfa frontier]\n   (when (seq frontier)\n     (let [current-state (first frontier)\n           possible-transitions ((fn [d s] (let [t (get (:transitions d) (:state s))] (map (fn [[k v]] {:word (str (:word s) k), :state v}) t))) dfa current-state)\n           next-frontier (concat (rest frontier) possible-transitions)\n           good-word (if ((:accepts dfa) (:state current-state))\n                       (:word current-state))]\n       (if good-word\n         (cons good-word (lazy-seq (foo dfa next-frontier)))\n         (foo dfa next-frontier))))))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [\n    (nxt [[[s q] & rst]]\n      (let [trns ((dfa :transitions) q) nw (map #(vector (str s (first %)) (second %)) trns)]\n        (concat rst nw)))\n    (acpt [x]\n    (lazy-seq\n      (when-let [[h & rst] (seq x)]\n          (if (contains? (dfa :accepts) (second h)) (cons (first h) (acpt (nxt (cons h rst))))\n              (acpt (nxt (cons h rst)))))))\n          ]\n(acpt [[\"\" (dfa :start)]])))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 164, "code": "(fn language-of-dfa\n  [{:keys [states alphabet start accepts transitions]}]\n  (letfn [(analyze-dfa\n            [current-state current-word accepts transitions visited]\n            (if (visited current-state)\n\n              (if (accepts current-state)\n                [current-word]\n                [false])\n    \n              (let [after-me (filter #(boolean %)\n                                     (mapcat\n                                      (fn [[letter next-state]]\n                                        \n                                        (analyze-dfa next-state\n                                                     (str current-word letter)\n                                                     accepts\n                                                     transitions\n                                                     (conj visited current-state)))\n                                      \n                                      (transitions current-state)))]\n                (if (accepts current-state)\n                  (cons current-word after-me)\n                  after-me))))]\n    \n    (analyze-dfa start \"\" accepts transitions #{})))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n  (letfn [(f1 [state res s c] \n    (let [s1 (if (accepts state) [(str s c)])\n          tt (transitions state)\n          s2 (if (> (count s) 10) nil (mapcat #(f1 (tt %) res (str s c) %) (keys tt)))]\n      (concat res s1 s2)\n      ))]\n  (f1 start [] \"\" \"\")))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 164, "code": "(fn dfa-language-strings [{:keys [states alphabet start accepts transitions word queue] \n                             :as dfa}]\n  (if-not queue\n    (recur (assoc dfa \n                  :queue (conj (clojure.lang.PersistentQueue/EMPTY) {:word \"\" \n                                                                     :current-state start})))\n    (when-let [{:keys [word current-state]} (peek queue)]\n      (let [next-queue (map (fn [[transition state]] {:word (str word transition) \n                                                      :current-state state}) \n                            (transitions current-state))]\n        (lazy-seq (concat (map :word (filter (comp accepts :current-state) next-queue)) \n                          (dfa-language-strings (assoc dfa :queue (if-not (seq next-queue)\n                                                                    (pop queue)\n                                                                    (apply conj (pop queue) next-queue))))))))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 164, "code": "(fn [{:keys [states\n             alphabet\n             start\n             transitions\n             accepts]\n      :as dfa}]\n  (letfn [(step\n            [[state tokens]]\n            (for [[token next-state] (get transitions state)]\n              [next-state\n               (conj tokens token)]))\n          (dfa-seq\n            [last-gen]\n            (lazy-seq\n             (let [this-gen (mapcat step last-gen)]\n               (when (not (empty? this-gen))\n                 (concat\n                  (keep (fn [[state tokens]]\n                          (when (accepts state)\n                            (apply str tokens)))\n                        this-gen)\n                  (dfa-seq\n                   this-gen))))))]\n    (dfa-seq [[start []]])))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 164, "code": "(fn [{:keys [states\r\n              alphabet\r\n              start\r\n              accepts\r\n              transitions]}]\r\n   (letfn\r\n       [\r\n        (tr [{:keys [state value]}]\r\n          (vec\r\n           (map\r\n            (fn [[v s]]\r\n              {:state s\r\n               :value (str value v)})\r\n            (transitions state))))\r\n        (tr-step [li]\r\n          (set\r\n           (mapcat\r\n            tr\r\n            li)))\r\n        (accept [li]\r\n          (set\r\n           (filter\r\n            (comp\r\n             accepts\r\n             :state)\r\n            li)))\r\n        (step [{:keys [li ac]}]\r\n          (let [liN (tr-step li)\r\n                acN (accept li)]\r\n            {:li liN\r\n             :ac (set\r\n                  (concat ac acN))}))\r\n        (clean [{:keys [ac]}]\r\n          (->> ac\r\n               (map :value)\r\n               set))\r\n        ]\r\n\r\n     (loop [curr {:li (->> [{:state start}]\r\n                           tr-step\r\n                           (filter :value))}\r\n            i 0]\r\n       #_(println \"step\")\r\n       (let [n (step curr)]\r\n         (if (or (< 2000 (count (:li n)))\r\n                 (> i 20)\r\n                 (= curr n))\r\n           (clean n)\r\n           (recur n (inc i)))))\r\n\r\n     #_(->>\r\n        {:li [{:state start}]}\r\n        step\r\n        step\r\n        step\r\n        step\r\n        )\r\n     )\r\n   )", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 164, "code": ";; http://www.4clojure.com/problem/164\n;; Language of a DFA\n(fn dump-language\n  [{start :start, accepts :accepts, transitions :transitions}]\n  (letfn [(move-state [[state s]]\n                       (let [allowed-transitions (transitions state)]\n                         (for [s-next (keys allowed-transitions)]\n                           [(allowed-transitions s-next) (conj s s-next)])))\n          (move-states [states]\n            (apply concat (map move-state states)))]\n    (map (fn [[state s]] (apply str s))\n         (filter (fn [[state s]] (accepts state))    \n                 (apply concat\n                        (take-while (complement empty?) (iterate move-states [[start []]])))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 164, "code": "(fn dfa2\n  ([dm] (dfa2 dm [(:start dm) nil]))\n  ([dm & state-acc-pairs]\n   (do (println state-acc-pairs)\n   (lazy-seq\n     (concat\n       (keep (fn [[st ac]] (when ((:accepts dm) st) ac))\n            state-acc-pairs)\n       (let [next-gen (mapcat (fn [[st ac]] (map (fn [[symb stat]] [stat (str ac symb)])\n                                                 ((:transitions dm) st)))\n                              state-acc-pairs)]\n         (if (seq next-gen)\n           (apply dfa2 dm next-gen))))))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 164, "code": "(fn enumerate-dfa [dfa]\n  (letfn\n   [(succ [seed]\n      (let [string (:string seed)\n            state (:state seed)\n            transitions (get-in dfa [:transitions state])]\n        (for [[token state'] transitions]\n          {:string (str string token), :state state'})))\n    (accepted-seed? [seed]\n      ((dfa :accepts) (:state seed)))\n    (accepted-strings [seeds]\n      (if (empty? seeds) []\n          (lazy-cat\n           (->> seeds (filter accepted-seed?) (map :string))\n           (accepted-strings (mapcat succ seeds)))))]\n    (accepted-strings [{:string \"\" :state (dfa :start)}])))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 164, "code": ";;(fn [{st :start ac :accepts mt :transitions}] \n;;  (let [fup0 (fn [qp mc mp] \n;;               (reduce (fn [mc [a q]] \n;;                         (assoc mc q (concat (q mc)\n;;                                       (map #(str % a) (qp mp)))))\n;;                 mc (seq (qp mt))))\n;;        fup (fn [mp] (reduce #(fup0 %2 % mp) {} (keys mp)))\n;;        sm (take-while not-empty (iterate fup {st [\"\"]}))]\n;;    (mapcat (fn [[q s]] (if (q ac) s)) (mapcat seq sm))))\n\n(fn [{c :accepts t :transitions r :start}]\n  ((fn f [q]\n     (lazy-seq \n       (if-let [[[p s] & qr] (seq q)]\n         (let [u (into (set qr)\n                       (for [[a n] (t s)] [(str p a) n]))]\n           (#(if (c s) (cons p %) %) (f u)))))) \n   #{[\"\" r]}))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 164, "code": "(fn F\n  ([dfa] (F dfa #{{:state (dfa :start) :output \"\"}} {}))\n  ([dfa currents seen]\n   (let [transition (fn [current] (map (fn [[char state]] {:state state :output (str (current :output) (str char))})\n                                       ((dfa :transitions) (current :state))))\n         nexts (clojure.set/difference (set (mapcat transition currents)) seen)\n         outputs (map :output (filter #((dfa :accepts) (% :state)) nexts))]\n     (if (empty? nexts) () (lazy-cat outputs (F dfa nexts (clojure.set/union seen nexts)))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 164, "code": "(fn dfa_language\n    [\n        {\n            states :states\n            alphabet :alphabet\n            start :start\n            accepts :accepts\n            transitions :transitions\n        }\n    ]\n    (let\n        [\n            initial_partial_strings (cons [[] start] '())\n            accepted?\n                (fn f [[partial_string_seq state]]\n                    (contains? accepts state)\n                )\n            next_states\n                (fn f [partial_string_pairs]\n                    (let\n                        [\n                            accepted_strings (map (fn [[sequence state]] (apply str sequence)) (filter accepted? partial_string_pairs))\n                            next_partial_string_pairs\n                                (filter (comp not nil?) (for\n                                    [\n                                        [sequence state] partial_string_pairs\n                                        [next_char next_state] (get transitions state '())\n                                    ]\n                                    (if (and (nil? next_char) (nil? next_state))\n                                        nil\n                                        [(conj sequence next_char) next_state]\n                                    )\n                                ))\n                        ]\n                        (if (= next_partial_string_pairs partial_string_pairs)\n                            '()\n                            (concat accepted_strings (lazy-seq (f next_partial_string_pairs)))\n                        )\n                    )\n                )\n        ]\n        (next_states initial_partial_strings)\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 164, "code": "(fn valid-strings\n  [{:keys [states alphabet start accepts transitions]}]\n  (letfn [(next-states [state word]\n            (for [letter alphabet\n                  :let [next-state (get-in transitions [state letter])]\n                  :when (not (nil? next-state))]\n              [next-state (str word letter)]))\n          (all-paths [queue]\n            (when (not-empty queue)\n              (let [[[state word :as nxt] rst] ((juxt peek pop) queue)]\n                (lazy-seq (cons nxt (all-paths (into rst (next-states state word))))))))]\n    (->> (all-paths (conj clojure.lang.PersistentQueue/EMPTY [start \"\"]))\n         (filter (comp (partial contains? accepts) first))\n         (map second))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 164, "code": "(fn [{:keys [start] :as dfa}]\n  (letfn [(visit [{:keys [accepts transitions] :as dfa} current already visited]\n            (let [next-trans (get transitions current)\n                  next-moves (lazy-seq (mapcat\n                                         (fn [[k v]]\n                                           (if (contains? visited v)\n                                             nil\n                                             (visit dfa v (conj already k) (conj visited v))))\n                                         next-trans))]\n              (if (contains? accepts current)\n                (cons already next-moves)\n                next-moves)))]\n    (map #(apply str %) (visit dfa start [] #{}))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 164, "code": "(fn f [dfa]\n  (let [next-transition (fn [[string _] [letter next-state]] [(str string letter) next-state])\n        add-states (fn add-states [[states _]]\n                     (let [[string state :as target] (peek states)\n                           next-transitions (mapv #(next-transition target %) ((dfa :transitions) state))\n                           next-states (if (empty? next-transitions) (pop states) (apply conj (pop states) next-transitions))]\n                       (cond\n                        ((dfa :accepts) state) [next-states (str string)]\n                        (empty? next-states) [next-states nil]\n                        :else (add-states [next-states nil])) ))\n        ]\n    (take-while (comp not nil?) (map second\n         (drop 1 (iterate add-states [(apply conj clojure.lang.PersistentQueue/EMPTY ((dfa :transitions) (dfa :start))) nil]))\n    ))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "5e03475de4b0a607a9a45d58"}, {"problem": 164, "code": "(fn [machine]\n  (let [reachable-states (fn [machine [state language-string]]\n                           (for [[letter new-state] (get (:transitions machine) state)]\n                             [new-state (str language-string letter)]))\n        state-string-seq (fn [machine]\n                           (mapcat identity\n                                   (take-while seq\n                                               (iterate #(mapcat\n                                                           (partial reachable-states machine) %)\n                                                        (list [(:start machine) \"\"])))))\n        valid-string-seq (fn [machine] (map second\n                                            (filter (comp (:accepts machine) first)\n                                                    (state-string-seq machine))))]\n    (valid-string-seq machine)))", "user": "56cd75bee4b0ea9b8538f74b"}, {"problem": 164, "code": "(fn\n    [dfa]\n      (let [union       clojure.set/union\n            dfa-accepts (:accepts dfa)]\n      (letfn [(next-state [sns]\n                (map\n                 (fn [[string state]] [state (str (second sns) string)])\n                 (get-in dfa [:transitions (first sns)])))\n              (evolve [dfa-state]\n                (let [{:keys [sns inc-sns accepted-strs]} dfa-state]\n                  (if (empty? inc-sns)\n                    dfa-state\n                    (let [inc-sns'          (->> inc-sns\n                                                 (mapcat next-state)\n                                                 (remove empty?)\n                                                 (remove #{sns}))\n                          inc-accepted-strs (map second (filter (comp dfa-accepts first) inc-sns'))\n                          accepted-strs'    (union accepted-strs inc-accepted-strs)\n                          ]\n                      {:sns               (union sns inc-sns)\n                       :inc-sns           inc-sns'\n                       :inc-accepted-strs inc-accepted-strs\n                       :accepted-strs     accepted-strs'\n                       }))))\n              (make-seq [dfa-state]\n                (let [next-dfa (evolve dfa-state)]\n;;                  (println \"next-dfa\"  next-dfa)\n                  (if (= next-dfa dfa-state)\n                    [dfa-state]\n                    (cons dfa-state (lazy-seq (make-seq next-dfa))))))\n              (lazy-cat' [colls]\n                (lazy-seq\n                 (if (seq colls)\n                   (concat (first colls)  (lazy-cat' (next colls))))))]\n        (let [r (make-seq\n                 {:sns               (hash-set) ;; [state str]\n                  :inc-sns           #{[(:start dfa) \"\"]}\n                  :inc-accepted-strs #{}\n                  :accepted-strs     #{}})]\n          (distinct (lazy-cat' (remove empty? (map :inc-accepted-strs\n                                                   r))))))))", "user": "583048d9e4b051871117c007"}, {"problem": 164, "code": "(fn dfa\n  [{:keys [start accepts transitions]}]\n  (letfn [(impl\n            [current path]\n            (let [transitions (get transitions current)\n                  nexts (lazy-seq\n                          (mapcat (fn [[c target]]\n                                    (impl target (conj path c)))\n                                  transitions)) ]\n              (if-let [s (seq (filter (comp accepts second) transitions))]\n                (mapcat (fn [accepted]\n                          (cons\n                            (conj path (first accepted))\n                            nexts))\n                        s)\n                nexts)))]\n    (map (partial apply str) (impl start []))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": 164, "code": "(fn [dfa] (let [resolv (fn [[s chains]]\n                          (apply merge-with  clojure.set/union\n                                 (map (fn [[a b]] {b (set (map #(str % a) chains))})\n                                      ((:transitions dfa) s))))\n                init (resolv [(:start dfa) #{\"\"}])]\n            (mapcat second (filter (fn [v] ((:accepts dfa) (first v))) (mapcat seq (take-while identity   (iterate #(apply merge-with clojure.set/union (map resolv %)) init)))))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 164, "code": "(fn exdfa\n  ([dfa] (exdfa dfa #{[\"\" (:start dfa)]}))\n  ([{accepts :accepts\n     transitions :transitions\n     :as dfa}\n    positions]\n   (if (= 0 (count positions)) []\n       (let [newpositions\n             (->> positions\n                  seq\n                  (map (fn [[prefix state]]\n                         (map (fn [[char newstate]]\n                                [(str prefix char) newstate])\n                              (seq (transitions state)))))\n                  (reduce concat)\n                  set)\n             newstrings\n             (->> newpositions\n                  seq\n                  (filter (fn [[word state]] (accepts state)))\n                  (map first))]\n         (lazy-cat\n          newstrings\n          (exdfa dfa newpositions))))))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 164, "code": "(fn [{:keys [#_states\n              #_alphabet\n              start\n              accepts\n              transitions]}]\n   (letfn [(g [s]\n             (if-let [[[a b :as h] & t] s]\n               (lazy-seq\n                (cons\n                 h\n                 (let [edges (transitions  a)]\n                   (g (if edges\n                        (lazy-cat t (map\n                                     (fn [[ch stt]] [stt (cons ch b)])\n                                     edges))\n                        t)))))\n               nil #_(throw (ex-info \"bad s\" {:s s}))))]\n     (map\n      (comp #(apply str %) reverse second)\n      (filter (comp accepts first)(g (list [start ()]))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 164, "code": "(fn [{start :start :as dfa}]\n  (letfn [(pump [{accepts :accepts transitions :transitions :as dfa} q]\n            (if-let [[path st] (peek q)]\n              (let [q' (reduce (fn [acc [c nst]] (conj acc [(conj path c) nst])) (pop q) (transitions st))]\n                (if (accepts st)\n                  (lazy-seq (cons (apply str path) (pump dfa q')))\n                  (pump dfa q')))))]\n    (pump dfa (conj clojure.lang.PersistentQueue/EMPTY [[] start]))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 164, "code": ";; Queue of [state path] current state and current outputs (we call it path) that is reach to go there.\n;; nstates => Next states\n;; npath => next path\n;; nlang new added accepted language element.\n(fn [dfa]\n    (letfn [(gen  [queue] \n              (if-let [[state path]  (first queue)]\n                (let [nstates      ((:transitions dfa) state)\n                      npath        (map (fn [[p s]] [s (conj path p)])  nstates)\n                      next_q       (concat (rest queue) npath)\n                      acc_path     (filter (comp (:accepts dfa) first) npath)\n                      nlang        (map    (comp clojure.string/join second)  acc_path)]\n                  (lazy-seq  (concat nlang (gen next_q))))))]\n\n      (gen [[(:start dfa) []]])))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 164, "code": "(fn [dfa]\n  (letfn [(cart [colls]\n            (if (empty? colls) '(())\n              (for [x (first colls)\n                    more (cart (rest colls))]\n                (cons x more))))\n          (allseqs [alph]\n            (apply concat\n                   (for [b (range 1 (inc (count alph)))]\n                     (cart (repeat b alph)))))\n          (accepts? [dfa s]\n            (let [getnext (fn [s i] (get-in (:transitions dfa) [s i]))\n                  accepted? (fn [s] (if ((:accepts dfa) s) true false))]\n              (loop [state (:start dfa) remis s]\n                (if (empty? remis)\n                  (accepted? state)\n                  (recur (getnext state (first remis)) (rest remis))))))]\n    (let [as (allseqs (:alphabet dfa))\n          fr (filter #(accepts? dfa %) as)]\n      (map #(apply str %) fr))))", "user": "4e8768f6535dceadca469850"}, {"problem": 164, "code": "(fn [{:keys [start accepts transitions]}]\n           (->> [[start \"\"]]\n                (iterate (fn [branches]\n                           (->> branches\n                                (mapcat (fn [[q s]] (map (fn [[s+ n]] [n (str s s+)]) (get transitions q)))))))\n                (take-while seq)\n                (apply concat)\n                (filter (comp accepts first))\n                (map second)))", "user": "5db0172be4b0f8c104ccfc96"}, {"problem": 164, "code": "(fn [dfa]\n  ((fn calc [work-queue]\n    (if (empty? work-queue)\n      []\n      (let [[cur-state cur-string] (first work-queue)\n          transitions (-> dfa :transitions cur-state)\n          next-queue (if transitions\n                        (concat\n                          (rest work-queue)\n                          (reduce-kv (fn [s k v] (conj s [v (str cur-string k)])) [] transitions))\n                        (rest work-queue))]\n        (if (contains? (:accepts dfa) cur-state)\n          (cons cur-string (lazy-seq (calc next-queue)))\n          (lazy-seq (calc next-queue))))))\n    [[(:start dfa) \"\"]]))", "user": "5e909685e4b0cb016954634d"}, {"problem": 164, "code": "(fn [dfa]\n  (let [state-count (count (dfa :states))\n        next-batch (fn [state-strings-map]\n                     (apply (partial merge-with concat)\n                            (for [source-state (keys state-strings-map)\n                                  letter (keys (get-in dfa [:transitions source-state]))\n                                  :let [target-state (get-in dfa [:transitions source-state letter])]]\n                              {target-state (->> (state-strings-map source-state)\n                                                 (map #(str % letter)))})))\n        batches (iterate next-batch {(dfa :start) [\"\"]})\n        batches-of-accepted-strings (->> (map #(select-keys % (dfa :accepts)) batches)\n                                         (map vals)\n                                         (map (partial apply concat)))\n        first-2-groups (take (* 2 state-count) batches-of-accepted-strings)\n        [first-group second-group] (split-at state-count first-2-groups)]\n    (if (empty? (flatten second-group))\n      (flatten first-group)\n      (flatten batches-of-accepted-strings))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 164, "code": "(fn [{start :start end :accepts trans :transitions}]\n  ((fn f [d] \n     (if (empty? (first d)) '() \n       (let [post (apply concat (map #(let [[k v] % di (trans k)] \n                                        (vec (for [[ki vi] di] [vi (str v ki)]))) \n                                     d))]\n          (if (empty? (filter end (map first post)))\n            (f post)\n            (concat (map second(filter #(end (first %)) post)) (lazy-seq (f post)))))))\n   [[start \"\"]]))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 164, "code": "(fn [{:keys [states alphabet start accepts transitions]}]\n  (letfn [(find-cycles [transitions]\n            )\n          (automata [state xs s]\n            (if (or (not (contains? transitions state))\n                    (< 2000 (count xs))\n                    (< 2000 (count s)))\n              xs\n              (lazy-seq (mapcat (fn [[k v]] (automata v\n                                                      (if (some #{v} accepts)\n                                                        (conj xs (str s k))\n                                                        xs)\n                                                      (str s k)))\n                                (get transitions state)))))]\n    (automata start [] \"\")))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 164, "code": "(fn process-dfa [{:keys [transitions, accepts, start]}]\n  (let [run-next-step\n        (fn [state-to-strings-mapping]\n          (apply merge-with concat (for [[q strings] state-to-strings-mapping\n                                         [event next-state] (q transitions)]\n                                     {next-state (vec (map #(str % event) strings))})))\n\n        run (fn run [state-to-strings-mapping]\n              (let [states (keys state-to-strings-mapping)\n                    acceptance-states (filter accepts states)]\n                (cond (not= 0 (count states)) (concat (mapcat state-to-strings-mapping acceptance-states)\n                                                      (lazy-seq (run (run-next-step state-to-strings-mapping)))))))]\n\n    (run {start [\"\"]})))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 164, "code": "(fn dfa-lang [dfa]                         \n  (letfn [                                 \n  (queue                                   \n    ([] (clojure.lang.PersistentQueue/EMPTY)) \n    ([coll] (reduce conj clojure.lang.PersistentQueue/EMPTY coll)))\n\n  (add-targets [q oldpath out]\n    (loop [ks (keys out) q q] \n        ;(println \"add-targets\" q oldpath out ks )\n        (if (empty? ks) q\n            (recur (rest ks) (conj q [(out (first ks)), (str oldpath (first ks))] )))))\n                      \n  (run [q]                                     \n    (lazy-seq\n    (if (empty? q) []\n        (let [[s path] (peek q)\n              out (get (:transitions dfa) s nil)\n              tail (if out (add-targets (pop q) path out) (pop q)) ]\n              (if (contains? (:accepts dfa) s) \n                    (cons path (run tail))\n                    (run tail))))))\n                                 \n  ]     \n  ;(println \"dfa\" dfa)\n  (run (conj (queue) [ (:start dfa) \"\"] ))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 164, "code": "(fn dfa-language [{:keys [states alphabet start accepts transitions]}]\n  (letfn [(neighbors [{:keys [node path]}]\n            (let [ts (transitions node)]\n              (map (fn [[p n]] {:path (str path p) :node n})\n                   ts)))\n          (is-winner [{:keys [node]}] (accepts node))\n          (search [[s & rest-queue]]\n            (let [queue' (concat rest-queue (neighbors s))]\n              (if (empty? queue')\n                (if (is-winner s) [s] [])\n                (if (is-winner s)\n                  (cons s (lazy-seq (search queue')))\n                  (lazy-seq (search queue'))))))]\n    (map :path (search (map (fn [[p n]] {:path (str p) :node n})\n                            (transitions start))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 164, "code": "(fn tm [m]\n  (let [go (fn go [i acc]\n             (lazy-seq (let\n                        [base (if ((:accepts m) i)\n                                [(apply str acc)] [])\n                         accepting (:accepts m)\n                         sorted-next (sort-by (fn [n] (->> n second accepting not)) (seq (get-in m [:transitions i])))\n                         step (mapcat\n                               (fn [[k v]] (go  v (conj acc k)))\n                               sorted-next)]\n                         (concat base step))))]\n    (go (:start m) [])))", "user": "5fa416ece4b0f0ebd91b7803"}, {"problem": 164, "code": "(fn get-dfa-language [{:keys [states\n                                alphabet\n                                start\n                                accepts\n                                transitions]}]\n  ((fn helper [queue]\n     (if (empty? queue)\n       []\n       (let [{new-queue :new-queue\n              result    :result} (reduce (fn [res v]\n                                           (let [new-queue     (:new-queue res)\n                                                 result        (:result res)\n                                                 current-state (:current-state v)\n                                                 val           (:val v)\n                                                 result        (if (and (contains? accepts current-state) (not (empty? val)))\n                                                                 (conj result (clojure.string/join val))\n                                                                 result)\n                                                 new-queue     (vec (concat new-queue (reduce (fn [res [k v]]\n                                                                                                (conj res {:current-state v\n                                                                                                           :val           (conj val k)}))\n                                                                                              []\n                                                                                              (get transitions current-state))))]\n                                             {:new-queue new-queue\n                                              :result    result}))\n                                         {:new-queue []\n                                          :result    []}\n                                         queue)]\n         (lazy-seq (concat result (helper new-queue))))))\n   [{:current-state start\n     :val           []}]))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 164, "code": "(fn dfa2 [config]\n  (letfn [(step [nodes]\n            (for [{:keys [state value]} nodes\n                  [b s] (get (:transitions config) state)]\n              {:state s\n               :value (str value b)}))\n          (bfs [root]\n            (apply concat (take-while seq (iterate step [root]))))\n          (accept-value? [node]\n            (when ((:accepts config) (:state node))\n              (:value node)))]\n    (keep accept-value? (bfs {:state (:start config)\n                              :value \"\"}))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 164, "code": "(fn run* [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 164, "code": "(fn [dfa-def]\n  (let [start (:start dfa-def), accepts (:accepts dfa-def), transitions (:transitions dfa-def) ; no associative destructuring in clj 1.4?\n        ;; queue contains unprocessed pairs (dfa-state, partial-word-(as-seq-of-chars)-that-got-us-to-that-state)\n        init-state [[start []]]\n        dfs-step (fn dfs-step [queue]\n                    (let [[head & tail] queue\n                          [dfa-state word] head\n                          state-transitions (transitions dfa-state)\n                          ;; generate children of current word/state, each a [new-state longer-word] pair\n                          children (map (fn [[new-letter new-state]]\n                                          [new-state (conj word new-letter)])\n                                        state-transitions)\n                          newq (if (seq children) ; clj 1.4 workaround\n                                (apply conj (vec tail) children)\n                                tail)]\n                      (if (seq newq)\n                        (if (accepts dfa-state) ; accept condition met\n                          (cons (apply str word)\n                                (lazy-seq (dfs-step newq)))\n                          (recur newq))\n                        (list (apply str word)))))]\n    (dfs-step init-state)))", "user": "56aad4f7e4b03c432f187338"}, {"problem": 164, "code": "(fn lang\n    ([fsm] (lang fsm [(list (:start fsm) \"\")]))\n    ([fsm queue]\n         (letfn [(nxt [q w]\n                    (for [[s q'] ((:transitions fsm) q)]\n                        [q' (apply str (concat w (str s)))]))]\n             (if (empty? queue)\n                 '()\n                 (let [[q w] (first queue)\n                       queue' (concat (rest queue) (nxt q w))]\n                     (if ((:accepts fsm) q)\n                         (lazy-seq (cons w (lang fsm queue')))\n                         (lang fsm queue')))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 164, "code": "(fn f\n  ([{start :start :as prg}] \n   (f prg nil start))\n  ([{start :start accepts :accepts trans :transitions :as prg} word state]\n   (let [states (->> (trans state)\n                     (map (fn [[sym to]] [(str word sym) to])))]\n     (lazy-cat\n      (->> states\n           (filter (fn [[_ to]] (accepts to)))\n           (map first))\n      (->> states\n           (mapcat #(lazy-seq (apply f prg %))))))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 164, "code": "(fn implement-dfa \n  ([dfa] (implement-dfa dfa (:start dfa) \"\" [] 0))\n  ([dfa state cur-val accepted rd]\n    (let [cur-map (get (:transitions dfa) state)\n           accepted? (contains? (:accepts dfa) state)\n           accepted (if accepted? (conj accepted cur-val) accepted)\n           mapper (fn [v] \n                   (let [next-state (get cur-map v)] \n                     (when next-state\n                       (implement-dfa dfa next-state (str cur-val v) [] (inc rd)) \n                       ))\n                   )\n           handle-state-avail (fn [] (reduce #(if %2 (into %1 %2) %1) accepted (map mapper (:alphabet dfa))))] \n   (if (and (get (:transitions dfa) state) (< rd 10)) \n     (handle-state-avail)\n     accepted))))", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 164, "code": "(fn [automata]\n  ((fn transit [state accum]\n     (let [m ((automata :transitions) state)]\n       (cond (and (empty? m) ((automata :accepts) state)) (list (apply str accum))\n             (or (empty? m) (> (count accum) 15)) nil\n             :else (let [tail (mapcat (fn [[s q]]\n                                        (transit q (conj accum (str s)))) m)]\n                     (if ((automata :accepts) state)\n                       (cons (apply str accum) tail)\n                       tail))))) (automata :start) []))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 164, "code": "(fn [{start :start accepts :accepts trans :transitions}]\n  ((fn helper [word state]\n     (let [transitions (trans state)\n           next-states (map (fn [[sym state']] [(str word sym) state']) transitions)\n           accept-states (filter #(accepts (second %)) next-states)\n           results (map first accept-states)\n           remaining (mapcat #(lazy-seq (apply helper %)) next-states)]\n       (lazy-cat results remaining))) \"\" start))", "user": "5245af03e4b08ba239308124"}, {"problem": 164, "code": "(fn iterate-dfa [dfa] \n (letfn [(next [[agg state] queue]\n           (let\n            [queue (concat queue (map (fn [[letter state]] [(str agg letter) state]) ((dfa :transitions) state [])))\n             accepted (contains? (dfa :accepts) state)\n             done (empty? queue)]\n             (cond\n               (and accepted done) [agg]\n               done []\n               accepted (lazy-seq (cons agg (next (first queue) (rest queue))))\n               :else (next (first queue) (rest queue)))))]\n  (next [\"\" (dfa :start)] [])))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 164, "code": "(fn strings\n  [{states :states, alphabet :alphabet, start :start, accepts :accepts, transitions :transitions}]\n  (letfn [(next-strings [[string state]]\n            (map (fn [[c s]]\n                   [(str string c) s])\n                 (get transitions state)))]\n    (flatten\n     (map (fn [pairs] (map first\n                           (filter (fn [[_ state]]\n                                     (contains? accepts state))\n                                   pairs)))\n          (take-while not-empty\n                      (iterate (fn [pairs]\n                                 (mapcat identity\n                                         (for [pair pairs]\n                                           (next-strings pair)))) `([\"\" ~start])))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 164, "code": "(fn DFA [{initial-state :start outputs :accepts transitions :transitions}]\n  (letfn\n    [(stepper [current-state current-word]\n      (lazy-seq\n        (if (current-state transitions)\n          (mapcat\n              (fn [[letter next-state]]\n                  (concat\n                    [current-state (->> current-word reverse (apply str) list)]\n                    (stepper next-state (cons letter current-word))))\n              (->> transitions current-state seq flatten (partition 2) shuffle))\n          [current-state (->> current-word reverse (apply str) list)])))]\n    (->> (stepper initial-state '())\n      (partition 2)\n      (filter #(contains? outputs (first %)))\n      (mapcat second))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 164, "code": "(fn [dfa]\n  (let [run1 (fn [[s acc]] (for [[c n] ((:transitions dfa) s)] [n (str acc c)]))\n        accepted (fn [[s acc]] (when ((:accepts dfa) s) acc))]\n    (mapcat #(keep accepted %) (take-while not-empty (iterate #(mapcat run1 %) (run1 [(:start dfa) \"\"]))))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 164, "code": "(fn solve [{states      :states\n              alphabet    :alphabet\n              start       :start\n              accepts     :accepts\n              transitions :transitions}]\n\n  (loop [queue   [[\"\" start]]\n         visited #{[\"\" start]}\n         result #{}\n         i       0]\n\n    (if (and (not-empty queue)\n             (< i 1000))\n\n      (let [[word state] (peek queue)\n            trans        (state transitions)]\n\n        (recur\n         (reduce\n          (fn [queue [letter next-state]]\n            (if (contains? visited [(str word letter) next-state])\n              queue\n              (conj queue [(str word letter) next-state])))\n          (pop queue)\n          trans)\n\n         (reduce\n          (fn [visited [letter next-state]]\n            (conj visited [(str word letter) next-state]))\n          visited\n          trans)\n\n         (if (contains? accepts state)\n           (conj result word)\n           result)\n\n         (inc i)))\n\n      result)))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 164, "code": "(fn [{p :start a :accepts f :transitions}]\n    (for [[q s]\n          (apply concat\n                 (take-while seq\n                             (iterate\n                              #(for [[q s] %\n                                     [l r] (f q)]\n                                 [r (conj s l)])\n                              [[p []]])))\n          :when (a q)]\n      (apply str s)))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 164, "code": "(fn  [{start :start\n       accepted :accepts\n       trans :transitions}]\n  (let [first-value (mapv #(conj % \"\") (trans start))\n        f (fn f [[[val s chain] & r :as c]]\n            (when-not (empty? c)\n              (lazy-seq (cons (when (accepted s) (str chain val)) (f (concat r (map #(conj %1 (str chain val)) (trans s))))))))]\n    (->> first-value\n         f\n         (remove nil?))))", "user": "608ec5e4e4b03bd49d9f36c0"}]